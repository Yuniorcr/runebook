<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="4fe1d3a13dd63ed4836e434d893dc270763cfe84" translate="yes" xml:space="preserve">
          <source>The release checklist is continuously evolving. As new problems or potential problems are discovered, new checklist items are added to make sure those problems do not appear in subsequent releases. The release checklist has proven to be an invaluable tool in helping to ensure that nothing is overlooked during the release process.</source>
          <target state="translated">发布检查表是不断发展的。随着新问题或潜在问题的发现,新的检查表项目被添加进来,以确保这些问题不会出现在随后的版本中。事实证明,发布检查清单是一个宝贵的工具,有助于确保在发布过程中不遗漏任何问题。</target>
        </trans-unit>
        <trans-unit id="54fb9bcb3273ff541df78c3b4ae7a5c1d95caf43" translate="yes" xml:space="preserve">
          <source>The release checklist is not automated: developers run each item on the checklist manually. We find that it is important to keep a human in the loop. Sometimes problems are found while running a checklist item even though the test itself passed. It is important to have a human reviewing the test output at the highest level, and constantly asking &quot;Is this really right?&quot;</source>
          <target state="translated">发布检查表不是自动的:开发人员手动运行检查表上的每个项目。我们发现,让人参与其中很重要。有时,即使测试本身通过了,但在运行检查表项目时还是会发现问题。让一个人在最高级别审查测试输出,并不断询问 &quot;这真的是对的吗?&quot;是很重要的。</target>
        </trans-unit>
        <trans-unit id="2c9d643524e4e559789769fa0d9c05fd5ba6364a" translate="yes" xml:space="preserve">
          <source>The relevancy of a document may depend on something other than just the data available in the return value of matchinfo. For example each document in the database may be assigned a static weight based on factors unrelated to its content (origin, author, age, number of references etc.). These values can be stored by the application in a separate table that can be joined against the documents table in the sub-query so that the rank function may access them.</source>
          <target state="translated">一个文档的相关性可能不仅仅取决于matchinfo的返回值中的数据。例如,数据库中的每个文档可以根据与其内容无关的因素(来源、作者、年龄、参考文献的数量等)分配一个静态权重。这些值可以由应用程序存储在一个单独的表中,可以与子查询中的文档表连接,以便排名函数可以访问它们。</target>
        </trans-unit>
        <trans-unit id="d03714ee4fa95f4e8679f472e2f3c59cc9a47883" translate="yes" xml:space="preserve">
          <source>The reliability and robustness of SQLite is achieved in part by thorough and careful testing.</source>
          <target state="translated">SQLite的可靠性和健壮性在一定程度上是通过彻底和仔细的测试实现的。</target>
        </trans-unit>
        <trans-unit id="7a3157bd64ab9a637ba9a36bada2711bd2147294" translate="yes" xml:space="preserve">
          <source>The remainder of this document will guide the reader through the steps needed to maintain a private branch. The general idea is the same as outlined above. This section merely provides more detail.</source>
          <target state="translated">本文件的其余部分将指导读者完成维护私人分支机构所需的步骤。总的思路与上文所述相同。本节只是提供更多细节。</target>
        </trans-unit>
        <trans-unit id="30a538553e382aa8cfb9498b6fd827480cf2d80b" translate="yes" xml:space="preserve">
          <source>The remaining fields of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object all store pointers to functions that implement primitive operations. We call these &quot;methods&quot;. The first method, xOpen, is used to open files on the underlying storage media. The result is an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. There are additional methods, defined by the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object itself that are used to read and write and close the file. The additional methods are detailed below. The filename is in UTF-8. SQLite will guarantee that the zFilename string passed to xOpen() is a full pathname as generated by xFullPathname() and that the string will be valid and unchanged until xClose() is called. So the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; can store a pointer to the filename if it needs to remember the filename for some reason. The flags argument to xOpen() is a copy of the flags argument to sqlite3_open_v2(). If sqlite3_open() or sqlite3_open16() is used, then flags is &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;. If xOpen() opens a file read-only then it sets *pOutFlags to include &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;. Other bits in *pOutFlags may be set. SQLite will also add one of the following flags to the xOpen() call, depending on the object being opened:</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的其余字段都存储指向实现原始操作的函数的指针。我们称这些为&amp;ldquo;方法&amp;rdquo;。第一种方法xOpen用于打开基础存储介质上的文件。结果是一个&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;对象。由&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;对象本身定义的其他方法可用于读取和写入以及关闭文件。其他方法将在下面详细说明。文件名采用UTF-8。 SQLite将确保传递给xOpen（）的zFilename字符串是由xFullPathname（）生成的完整路径名，并且该字符串在调用xClose（）之前将一直有效且不变。所以&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;如果由于某种原因需要记住文件名，可以存储指向文件名的指针。 xOpen（）的flags参数是sqlite3_open_v2（）的flags参数的副本。如果使用sqlite3_open（）或sqlite3_open16（），则标志为&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;。如果xOpen（）以只读方式打开文件，则它将* pOutFlags设置为包括&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;。 * pOutFlags中的其他位可以设置。 SQLite还将根据打开的对象向xOpen（）调用添加以下标志之一：</target>
        </trans-unit>
        <trans-unit id="75ee3ed9cd8aa1cdca7e660d366395ab9cdd104b" translate="yes" xml:space="preserve">
          <source>The remaining seven methods defined by this structure (xMutexAlloc, xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and xMutexNotheld) implement the following interfaces (respectively):</source>
          <target state="translated">该结构定义的其余七个方法(xMutexAlloc、xMutexFree、xMutexEnter、xMutexTry、xMutexLeave、xMutexHeld和xMutexNotheld)分别实现了以下接口。</target>
        </trans-unit>
        <trans-unit id="01d5ccb02fb58f9483b8bb4a6c89788e5e99328d" translate="yes" xml:space="preserve">
          <source>The remove_diacritics option is not supported.</source>
          <target state="translated">不支持 remove_diacritics 选项。</target>
        </trans-unit>
        <trans-unit id="5dc3bfc4e2330eb1c8eb7d47b9e9b34b4b7effb1" translate="yes" xml:space="preserve">
          <source>The remove_diacritics option may be set to &quot;0&quot;, &quot;1&quot; or &quot;2&quot;. The default value is &quot;1&quot;. If it is set to &quot;1&quot; or &quot;2&quot;, then diacritics are removed from Latin script characters as described above. However, if it is set to &quot;1&quot;, then diacritics are not removed in the fairly uncommon case where a single unicode codepoint is used to represent a character with more that one diacritic. For example, diacritics are not removed from codepoint 0x1ED9 (&quot;LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW&quot;). This is technically a bug, but cannot be fixed without creating backwards compatibility problems. If this option is set to &quot;2&quot;, then diacritics are correctly removed from all Latin characters.</source>
          <target state="translated">remove_diacritics选项可以设置为 &quot;0&quot;、&quot;1 &quot;或 &quot;2&quot;。默认值是 &quot;1&quot;。如果它被设置为 &quot;1 &quot;或 &quot;2&quot;,那么拉丁字母字符中的暗号就会如上所述被移除,但如果它被设置为 &quot;1&quot;,那么暗号就不会被移除。然而,如果它被设置为 &quot;1&quot;,那么在相当少见的情况下,当一个单一的unicode码点被用来表示一个有多个重音符号的字符时,重音符号就不会被移除。例如,0x1ED9码点(&quot;LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW&quot;)的暗号没有被删除。这在技术上是一个错误,但如果不造成向后的兼容性问题,就无法修复。如果这个选项被设置为 &quot;2&quot;,那么所有拉丁字符中的双音符就会被正确地删除。</target>
        </trans-unit>
        <trans-unit id="e878b1555960f1149f69c44e721edf9e3c3726dd" translate="yes" xml:space="preserve">
          <source>The replace(X,Y,Z) function returns a string formed by substituting string Z for every occurrence of string Y in string X. The &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt; collating sequence is used for comparisons. If Y is an empty string then return X unchanged. If Z is not initially a string, it is cast to a UTF-8 string prior to processing.</source>
          <target state="translated">replace（X，Y，Z）函数返回一个字符串，该字符串是用字符串Z替换字符串X中每次出现的字符串Y所形成的字符串&lt;a href=&quot;datatype3#collation&quot;&gt;。BINARY&lt;/a&gt;整理序列用于比较。如果Y为空字符串，则返回X不变。如果Z最初不是字符串，则在处理之前将其强制转换为UTF-8字符串。</target>
        </trans-unit>
        <trans-unit id="7d84cb3d97dd720ff83b043f47169f048a42ed9d" translate="yes" xml:space="preserve">
          <source>The repository created in the previous step is initially empty. The next step is to load the baseline SQLite release - circle (1) in the diagram above.</source>
          <target state="translated">上一步创建的版本库最初是空的。下一步是加载基线SQLite版本--上图中的圆圈(1)。</target>
        </trans-unit>
        <trans-unit id="10c2d611bbd1154503c3d2f589b7893620f36217" translate="yes" xml:space="preserve">
          <source>The reserved region is an area of unused space at the end of every page (except the locking page) that extensions can use to hold per-page information. The size of the reserved region is determined by the one-byte unsigned integer found at an offset of 20 into the database file header. The size of the reserved region is usually zero.</source>
          <target state="translated">保留区域是每页(除锁定页外)末尾未使用的空间,扩展程序可以用它来保存每页信息。保留区域的大小由数据库文件头中偏移量为20的一字节无符号整数决定。保留区域的大小通常为零。</target>
        </trans-unit>
        <trans-unit id="5406b5dfde9f00d0738ba2c75a1507fa33caf617" translate="yes" xml:space="preserve">
          <source>The reserved region.</source>
          <target state="translated">保留区域;</target>
        </trans-unit>
        <trans-unit id="aad9068a01cab0c1ed6f0408e5a3ca43105c9476" translate="yes" xml:space="preserve">
          <source>The response of SQLite to out-of-memory (OOM) errors is tested using a specialized memory allocator overlay that can simulate memory failures. The overlay is a layer that is inserted in between the memory allocator and the rest of SQLite. The overlay passes most memory allocation requests straight through to the underlying allocator and passes the results back up to the requester. But the overlay can be set to cause the Nth memory allocation to fail. To run an OOM test, the overlay is first set to fail on the first allocation attempt. Then some test script is run and verification that the allocation was correctly caught and handled is made. Then the overlay is set to fail on the second allocation and the test repeats. The failure point continues to advance one allocation at a time until the entire test procedure runs to completion without hitting a memory allocation error. This whole test sequence run twice. On the first pass, the overlay is set to fail only the Nth allocation. On the second pass, the overlay is set to fail the Nth and all subsequent allocations.</source>
          <target state="translated">使用专门的内存分配器覆盖层来测试SQLite对内存外(OOM)错误的响应,该覆盖层可以模拟内存故障。覆盖层是一个插入在内存分配器和SQLite其他部分之间的层。覆盖层将大部分内存分配请求直接传递给底层分配器,并将结果传回给请求者。但是覆盖层可以被设置为导致第N次内存分配失败。要运行OOM测试,首先设置覆盖层在第一次分配尝试时失败。然后运行一些测试脚本,验证分配是否被正确捕获和处理。然后在第二次分配时将覆盖设置为失败,然后重复测试。失败点每次继续推进一个分配,直到整个测试程序运行完成,没有碰到内存分配错误。这整个测试序列运行两次。在第一次通过时,覆盖点被设置为只在第N次分配时失败。在第二次测试中,覆盖点被设置为第N次分配和所有后续分配失败。</target>
        </trans-unit>
        <trans-unit id="12691a5bbec67aa65e24fe31d2477402bd3c4199" translate="yes" xml:space="preserve">
          <source>The rest of the module structure consists of methods used to implement various features of the virtual table. Details on what each of these methods do are provided in the sequel.</source>
          <target state="translated">该模块结构的其余部分由用于实现虚拟表的各种功能的方法组成。关于这些方法的详细内容将在后文中提供。</target>
        </trans-unit>
        <trans-unit id="4c062c28bf53cd1153a7f659fc941fb25e4394ee" translate="yes" xml:space="preserve">
          <source>The result column names generated for compound subqueries have been simplified to show only the name of the column of the original table and omit the table name. This makes SQLite operate more like other SQL database engines.</source>
          <target state="translated">对复合子查询生成的结果列名进行了简化,只显示原表的列名,省略表名。这使得SQLite的操作更像其他SQL数据库引擎。</target>
        </trans-unit>
        <trans-unit id="8fba3a08c8f1c5c3b4c188d84f260675274f7bae" translate="yes" xml:space="preserve">
          <source>The result of &quot;(1,2,3)=(1,NULL,3)&quot; is NULL because the result might be true if we replaced NULL&amp;rarr;2 or false if we replaced NULL&amp;rarr;9. The result of &quot;(1,2,3)=(1,NULL,4)&quot; is not NULL because there is no substitutions of the constituent NULL that will make the expression true, since 3 will never equal 4 in the third column.</source>
          <target state="translated">&amp;ldquo;（1,2,3）=（1，NULL，3）&amp;rdquo;的结果为NULL，因为如果替换为NULL&amp;rarr;2，则结果可能为true；如果替换为NULL&amp;rarr;9，则结果为false。结果&amp;ldquo;（1,2,3）=（1，NULL，4）&amp;rdquo;不是NULL，因为没有组成NULL的替换将使表达式为true，因为在第三列中3永远不会等于4。</target>
        </trans-unit>
        <trans-unit id="8f8beef2187bafe894f67b36f4b351c6bf0083c2" translate="yes" xml:space="preserve">
          <source>The result of an IN or NOT IN operator is determined by the following matrix:</source>
          <target state="translated">IN或NOT IN运算符的结果由以下矩阵决定:</target>
        </trans-unit>
        <trans-unit id="61365ffa3c163a280c658c5edf1eb2a5c12ca346" translate="yes" xml:space="preserve">
          <source>The result of any binary operator is either a numeric value or NULL, except for the</source>
          <target state="translated">任何二进制运算符的结果要么是一个数值,要么是NULL,但除了</target>
        </trans-unit>
        <trans-unit id="efe84f22635d66f10495dd8d63c09814ab5f5a9a" translate="yes" xml:space="preserve">
          <source>The result of combining all input changesets together is obtained by the application via a call to sqlite3changegroup_output().</source>
          <target state="translated">应用程序通过调用sqlite3changegroup_output()获得将所有输入的变化集组合在一起的结果。</target>
        </trans-unit>
        <trans-unit id="bf374835b6b23f4254068862fbe80fd36859e25a" translate="yes" xml:space="preserve">
          <source>The result of opening a file is an instance of an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object is an abstract base class defined as follows:</source>
          <target state="translated">打开文件的结果是&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;对象的实例。所述&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;对象是一个抽象基类定义如下：</target>
        </trans-unit>
        <trans-unit id="8384d1099fcb8eaa40cfc52c9ccfbf281fc795df" translate="yes" xml:space="preserve">
          <source>The result of the compound select is sent to the callback routine by the loop at instructions 22 through 25. There is nothing new or remarkable about this loop, except for the fact that the Column instruction at 23 will be extracting a column out of the record key rather than the record data.</source>
          <target state="translated">复合选择的结果由指令22到25的循环发送到回调例程。这个循环没有什么新的或值得注意的地方,除了23处的Column指令将从记录键中提取一列而不是记录数据。</target>
        </trans-unit>
        <trans-unit id="a2285b0635d880f7a2485fe902caef319bce2b4f" translate="yes" xml:space="preserve">
          <source>The result of this last example should be every unique value of the &quot;two&quot; column in the examp table, except any value that is in the &quot;four&quot; column of examp2 is removed. The code to implement this query is as follows:</source>
          <target state="translated">最后一个例子的结果应该是examp表中 &quot;2 &quot;列中的每一个唯一值,除了examp2的 &quot;4 &quot;列中的任何值都会被删除。实现这个查询的代码如下。</target>
        </trans-unit>
        <trans-unit id="ccf7a73ae578c847fadf3966512c178de5c0acda" translate="yes" xml:space="preserve">
          <source>The result of total() is always a floating point value. The result of sum() is an integer value if all non-NULL inputs are integers. If any input to sum() is neither an integer or a NULL then sum() returns a floating point value which might be an approximation to the true sum.</source>
          <target state="translated">total()的结果总是一个浮点值。如果所有非NULL输入都是整数,那么sum()的结果就是一个整数值。如果sum()的任何输入既不是整数也不是NULL,那么sum()返回的是一个浮点值,它可能是真实总和的近似值。</target>
        </trans-unit>
        <trans-unit id="3501cb60eee256e312e1519991e5a4a97f468bc9" translate="yes" xml:space="preserve">
          <source>The result shown above (0.0000011126) is the correct answer. But if you do this computation using binary64 floating-point, the answer you get is 0.00000095367431640625 - an error of about 14%. If you do many similar computations as part of your program, the errors add up so that your final result might be completely meaningless.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6fa042949920d8ab9a65592e82f3922c405d35" translate="yes" xml:space="preserve">
          <source>The resulting &quot;sqlite3.c&quot; amalgamation code file (and its associated header file &quot;sqlite3.h&quot;) can then be moved to a non-unix platform for final compilation using a native compiler.</source>
          <target state="translated">由此产生的 &quot;sqlite3.c &quot;合并代码文件(及其相关的头文件 &quot;sqlite3.h&quot;)可以移到非unix平台上使用本地编译器进行最终编译。</target>
        </trans-unit>
        <trans-unit id="e2d2e1926aa6ddaac2f60d9749f53fb11268ec2a" translate="yes" xml:space="preserve">
          <source>The results of a comparison depend on the storage classes of the operands, according to the following rules:</source>
          <target state="translated">根据以下规则,比较的结果取决于操作数的存储类别。</target>
        </trans-unit>
        <trans-unit id="32d9d0342a63956078e67d37802198109f0decfd" translate="yes" xml:space="preserve">
          <source>The results presented here come with the following caveats:</source>
          <target state="translated">这里介绍的结果有以下几点注意事项。</target>
        </trans-unit>
        <trans-unit id="0aa6d6ab54b80d454b7163f11aaed1a126d7a246" translate="yes" xml:space="preserve">
          <source>The return value from both sqlite3_soft_heap_limit64() and sqlite3_hard_heap_limit64() is the size of the heap limit prior to the call, or negative in the case of an error. If the argument N is negative then no change is made to the heap limit. Hence, the current size of heap limits can be determined by invoking sqlite3_soft_heap_limit64(-1) or sqlite3_hard_heap_limit(-1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9310ef8309cce9fab8d7528f6f21efe5cbb34c7" translate="yes" xml:space="preserve">
          <source>The return value from sqlite3_soft_heap_limit64() is the size of the soft heap limit prior to the call, or negative in the case of an error. If the argument N is negative then no change is made to the soft heap limit. Hence, the current size of the soft heap limit can be determined by invoking sqlite3_soft_heap_limit64() with a negative argument.</source>
          <target state="translated">sqlite3_soft_heap_limit64()的返回值是调用前软堆限制的大小,如果出现错误,返回值为负值。如果参数N为负值,则不会对软堆限制进行任何改变。因此,可以通过调用参数为负的sqlite3_soft_heap_limit64()来确定当前软堆限制的大小。</target>
        </trans-unit>
        <trans-unit id="b9ca53c6554299d5eae8ef584802645a6046ae33" translate="yes" xml:space="preserve">
          <source>The return value indicates the final state of the indirect flag: 0 if it is clear, or 1 if it is set.</source>
          <target state="translated">返回值表示间接标志的最终状态:如果是清除,则为0;如果是设置,则为1。</target>
        </trans-unit>
        <trans-unit id="7ce2179f1a4d84a59cb420b693cc86ea07338afc" translate="yes" xml:space="preserve">
          <source>The return value indicates the final state of the session object: 0 if the session is disabled, or 1 if it is enabled.</source>
          <target state="translated">返回值表示会话对象的最终状态:如果会话被禁用,则为0;如果会话被启用,则为1。</target>
        </trans-unit>
        <trans-unit id="cae4bd57ed056db33a88f07df4b39cc7f3ccb51d" translate="yes" xml:space="preserve">
          <source>The return value of the &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface is determined by the compile-time threading mode selection. If single-thread mode is selected at compile-time, then &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returns false. If either the multi-thread or serialized modes are selected, then &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returns true. The &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface predates the multi-thread mode and start-time and run-time mode selection and so is unable to distinguish between multi-thread and serialized mode nor is it able to report start-time or run-time mode changes.</source>
          <target state="translated">&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;接口的返回值由编译时线程模式选择确定。如果在编译时选择了单线程模式，则&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;返回false。如果选择了多线程或序列化模式，则&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;返回true。该&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;接口早在多线程模式和启动时间和运行时间模式选择，因此是无法多线程和序列化的模式，也没有区分是它能够报告开始时间或运行时模式的变化。</target>
        </trans-unit>
        <trans-unit id="39d80cd93bcac1fdb374e9a2b5c0dd95b400a1d6" translate="yes" xml:space="preserve">
          <source>The return value of the &lt;b&gt;sqlite_open&lt;/b&gt; function is a pointer to an opaque &lt;b&gt;sqlite&lt;/b&gt; structure. This pointer will be the first argument to all subsequent SQLite function calls that deal with the same database. NULL is returned if the open fails for any reason.</source>
          <target state="translated">&lt;b&gt;sqlite_open&lt;/b&gt;函数的返回值是一个不透明的&lt;b&gt;sqlite&lt;/b&gt;结构的指针。该指针将成为处理同一数据库的所有后续SQLite函数调用的第一个参数。如果打开由于任何原因失败，则返回NULL。</target>
        </trans-unit>
        <trans-unit id="6ab6c5924ac478fb10f4cbca37723d1a21ffdbb3" translate="yes" xml:space="preserve">
          <source>The returned string pointer is valid until either the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed by &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the next call to sqlite3_column_name() or sqlite3_column_name16() on the same column.</source>
          <target state="translated">返回的字符串指针是有效的，直到用&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;销毁&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;或直到针对特定运行的第一次调用&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;来自动重新准备该语句为止，或者直到下次调用sqlite3_column_name（）或sqlite3_column_name16（）为止。同一列。</target>
        </trans-unit>
        <trans-unit id="b378f46326a64f9ce7b892670372ed936b24e5cc" translate="yes" xml:space="preserve">
          <source>The returned string pointer is valid until either the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed by &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the next call to sqlite3_column_name() or sqlite3_column_name16() on the same column.</source>
          <target state="translated">返回的字符串指针是有效的，直到用&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;销毁&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;或直到针对特定运行的第一次调用&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;来自动重新准备该语句为止，或者直到下次调用sqlite3_column_name（）或sqlite3_column_name16（）为止。同一列。</target>
        </trans-unit>
        <trans-unit id="bee83cce7953088554432a61ef6e85ee98f1b384" translate="yes" xml:space="preserve">
          <source>The rewritten expression above is conceptual; WHERE clauses containing OR are not really rewritten this way. The actual implementation of the OR clause uses a mechanism that is more efficient and that works even for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables or tables in which the &quot;rowid&quot; is inaccessible. But the essence of the implementation is captured by the statement above: Separate indices are used to find candidate result rows from each OR clause term and the final result is the union of those rows.</source>
          <target state="translated">上面重写的表达是概念性的；包含OR的WHERE子句实际上不是用这种方式重写的。OR子句的实际实现使用一种效率更高的机制，甚至对于&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表或无法访问&amp;ldquo; rowid&amp;rdquo;的表也可以使用。但是，实现的实质已由上面的语句捕获：使用单独的索引从每个OR子句项中查找候选结果行，而最终结果是这些行的并集。</target>
        </trans-unit>
        <trans-unit id="1bd2a272126ae7fe0bcc8e6d37c8017e55bcc2f1" translate="yes" xml:space="preserve">
          <source>The rewritten term then might go on to constrain an index using the normal rules for *IN* operators. Note that</source>
          <target state="translated">然后,重写的项可能会继续使用*IN*运算符的正常规则来约束一个索引。注意</target>
        </trans-unit>
        <trans-unit id="d0930df338a07de9990756603662657ba4f08d89" translate="yes" xml:space="preserve">
          <source>The right-hand operand of an IN or NOT IN operator has no affinity if the operand is a list and has the same affinity as the affinity of the result set expression if the operand is a SELECT.</source>
          <target state="translated">如果操作数是列表,IN或NOT IN操作数的右侧操作数没有亲和力,如果操作数是SELECT,则与结果集表达式的亲和力相同。</target>
        </trans-unit>
        <trans-unit id="066626c86d12ae463e5bc63db194f29a635a8420" translate="yes" xml:space="preserve">
          <source>The right-hand side of the IN operator can now be a list of expressions instead of just a list of constants</source>
          <target state="translated">现在,IN操作符的右侧可以是表达式的列表,而不仅仅是常量的列表。</target>
        </trans-unit>
        <trans-unit id="5c40f29b907e12e70ce95f7046453c736453580d" translate="yes" xml:space="preserve">
          <source>The right-hand side of the LIKE or GLOB must be either a string literal or a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; bound to a string literal that does not begin with a wildcard character.</source>
          <target state="translated">LIKE或GLOB的右侧必须是字符串文字或绑定到不以通配符开头的字符串文字的&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b4246dd614eb68d70df4434b2497d819d23353bb" translate="yes" xml:space="preserve">
          <source>The right-hand table of the LEFT JOIN is not be used anywhere in the query outside of its own USING or ON clause.</source>
          <target state="translated">LEFT JOIN的右侧表在查询中除了它自己的USING或ON子句外的任何地方都不能使用。</target>
        </trans-unit>
        <trans-unit id="fc3dd2572b5bfa090299b30f5d81e58803cff0cb" translate="yes" xml:space="preserve">
          <source>The right-hand-side of the MATCH or = operator must be a constant expression that evaluates to a string consisting of the auxiliary function to invoke, followed by zero or more comma separated arguments within parenthesis. Arguments must be SQL literals. For example:</source>
          <target state="translated">MATCH 或=操作符的右侧必须是一个常量表达式,它的值是一个由要调用的辅助函数组成的字符串,后面的括号内是零个或多个逗号分隔的参数。参数必须是 SQL 字符。例如</target>
        </trans-unit>
        <trans-unit id="60bf6a0aa9c141c91d3c15f81e63af1fbe6058ec" translate="yes" xml:space="preserve">
          <source>The right-most SELECT of the compound select must not make use of &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate&lt;/a&gt; or &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;.</source>
          <target state="translated">复合选择的最右边的SELECT不得使用&lt;a href=&quot;lang_aggfunc&quot;&gt;聚集&lt;/a&gt;或&lt;a href=&quot;windowfunctions&quot;&gt;窗口函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7b1ae3c5986255800fb2859410b2b4acb04d2122" translate="yes" xml:space="preserve">
          <source>The rollback journal contains a small header (shown in green in the diagram) that records the original size of the database file. So if a change causes the database file to grow, we will still know the original size of the database. The page number is stored together with each database page that is written into the rollback journal.</source>
          <target state="translated">回滚日志包含一个小头(图中绿色所示),记录了数据库文件的原始大小。因此,如果一个变化导致数据库文件增长,我们仍然会知道数据库的原始大小。页码与每个写入回滚日志的数据库页一起存储。</target>
        </trans-unit>
        <trans-unit id="1c053ab6c700ac534ac79f62078cfd2e255f73f2" translate="yes" xml:space="preserve">
          <source>The rollback journal does not contain the name of a master journal file (see &lt;a href=&quot;#section_5_5&quot;&gt;section 5.5&lt;/a&gt; below) or if does contain the name of a master journal, then that master journal file exists.</source>
          <target state="translated">回滚日志不包含主日志文件的名称（请参阅下面的&lt;a href=&quot;#section_5_5&quot;&gt;5.5节&lt;/a&gt;），或者如果包含主日志的名称，则该主日志文件存在。</target>
        </trans-unit>
        <trans-unit id="070c8fccacf99462797ddd5845e4bd8960ffcf17" translate="yes" xml:space="preserve">
          <source>The rollback journal does not contain the name of a super-journal file (see &lt;a href=&quot;#section_5_5&quot;&gt;section 5.5&lt;/a&gt; below) or if does contain the name of a super-journal, then that super-journal file exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e312e9592f38c1d0abcf1823ca656ae6dc24729" translate="yes" xml:space="preserve">
          <source>The rollback journal exists.</source>
          <target state="translated">回滚日志存在。</target>
        </trans-unit>
        <trans-unit id="a6a9ff12c8273f443fb56b2bd7d0ab6853333cef" translate="yes" xml:space="preserve">
          <source>The rollback journal file can be deleted,</source>
          <target state="translated">可以删除回滚日志文件。</target>
        </trans-unit>
        <trans-unit id="841baedc01f54f9ab6f694a5b23bcc695e5f21f1" translate="yes" xml:space="preserve">
          <source>The rollback journal file can be truncated to zero length, or</source>
          <target state="translated">回滚日志文件可以被截断为零长度,或者是</target>
        </trans-unit>
        <trans-unit id="31415ebe9f384149b021a50dd2fb2ee645763262" translate="yes" xml:space="preserve">
          <source>The rollback journal is</source>
          <target state="translated">回滚日志是</target>
        </trans-unit>
        <trans-unit id="08afad671df0d2c575466e5f9fe1a518b69a6c6b" translate="yes" xml:space="preserve">
          <source>The rollback journal is a file associated with each SQLite database file that holds information used to restore the database file to its initial state during the course of a transaction. The rollback journal file is always located in the same directory as the database file and has the same name as the database file but with the string &quot;&lt;code&gt;-journal&lt;/code&gt;&quot; appended. There can only be a single rollback journal associated with a give database and hence there can only be one write transaction open against a single database at one time.</source>
          <target state="translated">回滚日志是与每个SQLite数据库文件关联的文件，其中包含用于在事务过程中将数据库文件还原到其初始状态的信息。回滚日志文件始终与数据库文件位于同一目录中，并且与数据库文件具有相同的名称，但是附加了字符串&amp;ldquo; &lt;code&gt;-journal&lt;/code&gt; &amp;rdquo;。与给定数据库只能有一个回滚日志，因此一次只能对一个数据库打开一个写事务。</target>
        </trans-unit>
        <trans-unit id="8a29cd2d15ece2c4c624bfe95a88741dea324ccf" translate="yes" xml:space="preserve">
          <source>The rollback journal is complete and intact on disk when the power is restored. This is a key point. The reason for the flush operation in &lt;a href=&quot;#section_3_7&quot;&gt;step 3.7&lt;/a&gt; is to make absolutely sure that all of the rollback journal is safely on nonvolatile storage prior to making any changes to the database file itself.</source>
          <target state="translated">恢复电源后，回滚日志已完成并且在磁盘上完好无损。这是关键。&lt;a href=&quot;#section_3_7&quot;&gt;步骤3.7&lt;/a&gt;中进行刷新操作的原因是，在对数据库文件本身进行任何更改之前，绝对要确保所有回滚日志都安全地存储在非易失性存储中。</target>
        </trans-unit>
        <trans-unit id="5d1b7832cc643f77f52a69083206bb3b5fc3e74c" translate="yes" xml:space="preserve">
          <source>The rollback journal is not an empty file.</source>
          <target state="translated">回滚日志不是一个空文件。</target>
        </trans-unit>
        <trans-unit id="194c559058723739212e12d7c3749019f8df5f55" translate="yes" xml:space="preserve">
          <source>The root page numbers of all tables in the database are integers stored in P4_INTARRAY argument.</source>
          <target state="translated">数据库中所有表的根号都是整数,存储在P4_INTARRAY参数中。</target>
        </trans-unit>
        <trans-unit id="a973ad8403210b9b222fd26c2aef5b8f2808389c" translate="yes" xml:space="preserve">
          <source>The round(X,Y) function returns a floating-point value X rounded to Y digits to the right of the decimal point. If the Y argument is omitted, it is assumed to be 0.</source>
          <target state="translated">round(X,Y)函数返回一个浮点值X,将其四舍五入到小数点右边的Y位。如果省略Y参数,则假定为0。</target>
        </trans-unit>
        <trans-unit id="5fa12ab6f93c055083bc1a95b917e71f9cff725b" translate="yes" xml:space="preserve">
          <source>The routines &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; accept an SQL statement list (sql-stmt-list) which is a semicolon-separated list of statements.</source>
          <target state="translated">例程&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;，&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;，&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16（）&lt;/a&gt;，&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;，&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;和&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;接受SQL语句列表（sql-stmt-list），该列表以分号分隔。</target>
        </trans-unit>
        <trans-unit id="94230b7f00353328063595629d48ef7be9fce389" translate="yes" xml:space="preserve">
          <source>The row-value notation is useful for updating two or more columns of a table from the result of a single query. An example of this is in the full-text search feature of the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil version control system&lt;/a&gt;.</source>
          <target state="translated">行值表示法对于从单个查询的结果更新表的两个或更多列很有用。例如，&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil版本控制系统&lt;/a&gt;的全文本搜索功能。</target>
        </trans-unit>
        <trans-unit id="12b6af8126e4e3b962d71bf35b72e9a66ab6fcba" translate="yes" xml:space="preserve">
          <source>The row_number() of the first peer in each group - the rank of the current row with gaps. If there is no ORDER BY clause, then all rows are considered peers and this function always returns 1.</source>
          <target state="translated">每组中第一个对等体的row_number()--当前有空隙的行的等级。如果没有ORDER BY子句,那么所有的行都被认为是对等体,这个函数总是返回1。</target>
        </trans-unit>
        <trans-unit id="d3978e13ae998834400769bcf87213e9a57acdbe" translate="yes" xml:space="preserve">
          <source>The row_number() window function assigns consecutive integers to each row in order of the &quot;ORDER BY&quot; clause within the window-defn (in this case &quot;ORDER BY y&quot;). Note that this does not affect the order in which results are returned from the overall query. The order of the final output is still governed by the ORDER BY clause attached to the SELECT statement (in this case &quot;ORDER BY x&quot;).</source>
          <target state="translated">row_number()窗口函数按照window-defn中的 &quot;ORDER BY &quot;子句(在本例中为 &quot;ORDER BY y&quot;)的顺序为每条记录分配连续的整数。请注意,这不会影响整个查询结果的返回顺序。最终输出结果的顺序仍然受SELECT语句中附加的ORDER BY子句的约束(在本例中为 &quot;ORDER BY x&quot;)。</target>
        </trans-unit>
        <trans-unit id="97fcd9de22c4efb0eb648cf609eba1ee3fdf411d" translate="yes" xml:space="preserve">
          <source>The rowid (and &quot;oid&quot; and &quot;_rowid_&quot;) is omitted in &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. WITHOUT ROWID tables are only available in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06) and later. A table that lacks the WITHOUT ROWID clause is called a &quot;rowid table&quot;.</source>
          <target state="translated">在&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表中省略了rowid（以及&amp;ldquo; oid&amp;rdquo;和&amp;ldquo; _rowid_&amp;rdquo;）。WITHOUT ROWID表仅在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;3.8.2&lt;/a&gt;（2013-12-06）及更高版本中可用。缺少WITHOUT ROWID子句的表称为&amp;ldquo; rowid表&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a4a453c67097537d0d10c4b81190fd5d03a4b9dd" translate="yes" xml:space="preserve">
          <source>The rowid column is not accessible on a WITHOUT ROWID virtual table (of course).</source>
          <target state="translated">rowid列在without rowid虚拟表上是无法访问的(当然)。</target>
        </trans-unit>
        <trans-unit id="101d05f0746854eb07065f446e80313cdc7692a7" translate="yes" xml:space="preserve">
          <source>The rowid of the document that contains the term instance.</source>
          <target state="translated">包含术语实例的文档的rowid。</target>
        </trans-unit>
        <trans-unit id="21037157130833680d029f7ec56534a7a85bda67" translate="yes" xml:space="preserve">
          <source>The rowid of the row in the table being changed</source>
          <target state="translated">表中被更改的行的行名。</target>
        </trans-unit>
        <trans-unit id="4967842a66478a8da76fb91a725d0ca4385c40a8" translate="yes" xml:space="preserve">
          <source>The rtreecheck() function performs the following checks:</source>
          <target state="translated">rtreecheck()函数执行以下检查。</target>
        </trans-unit>
        <trans-unit id="93e10cfe1c883491ee9016750849300312683ba1" translate="yes" xml:space="preserve">
          <source>The rtrim(X,Y) function returns a string formed by removing any and all characters that appear in Y from the right side of X. If the Y argument is omitted, rtrim(X) removes spaces from the right side of X.</source>
          <target state="translated">rtrim(X,Y)函数返回一个从X的右侧删除Y中出现的所有字符所形成的字符串,如果省略Y参数,rtrim(X)将从X的右侧删除空格。</target>
        </trans-unit>
        <trans-unit id="46ff031bad92aa35bcef2484317fc2661aa2d589" translate="yes" xml:space="preserve">
          <source>The rule above says that the letter &quot;a&quot; in user input can be matched against the letter &quot;&amp;auml;&quot; in the dictionary with a penalty of 5.</source>
          <target state="translated">上面的规则说，用户输入中的字母&amp;ldquo; a&amp;rdquo;可以与字典中的字母&amp;ldquo;&amp;auml;&amp;rdquo;匹配，罚分5。</target>
        </trans-unit>
        <trans-unit id="ed3a2c883d263a1e9abd7d6661fda464d09422b3" translate="yes" xml:space="preserve">
          <source>The rules for determining which collating function to use for a binary comparison operator (=, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, !=, IS, and IS NOT) are as follows:</source>
          <target state="translated">确定用于二进制比较运算符（=，&amp;lt;，&amp;gt;，&amp;lt;=，&amp;gt; =，！=，IS和IS NOT）的排序规则的规则如下：</target>
        </trans-unit>
        <trans-unit id="27705c6545cd7b92f01b98bd6ebfb1aa891406e9" translate="yes" xml:space="preserve">
          <source>The rules for when tables are analyzed are likely to change in future releases.</source>
          <target state="translated">在未来的版本中,何时对表格进行分析的规则可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="819c15849a2758e415f2520702095eeff7ea13a5" translate="yes" xml:space="preserve">
          <source>The safest and easiest to remember policy is this: assume that any result from</source>
          <target state="translated">最安全、最容易记住的政策是:假设任何结果从</target>
        </trans-unit>
        <trans-unit id="9bfc94ce3f6dbf06df6c899612d318253dda6014" translate="yes" xml:space="preserve">
          <source>The safest policy is to invoke these routines in one of the following ways:</source>
          <target state="translated">最安全的政策是以下列方式之一调用这些例程。</target>
        </trans-unit>
        <trans-unit id="376b573ee029dd7d9463b27b130e605260069a93" translate="yes" xml:space="preserve">
          <source>The salt-1 and salt-2 values in the frame-header match salt values in the wal-header</source>
          <target state="translated">框架头中的盐-1和盐-2的值与墙头中的盐值相匹配。</target>
        </trans-unit>
        <trans-unit id="b0647dc001e4e971c816ce4a73a18b5c698aa62d" translate="yes" xml:space="preserve">
          <source>The same SQL statement will fail on every other SQL implementation that we know of due to the use of keywords &quot;union&quot;, &quot;true&quot;, and &quot;with&quot; as identifiers.</source>
          <target state="translated">由于使用关键字 &quot;union&quot;、&quot;true &quot;和 &quot;with &quot;作为标识符,同样的SQL语句在我们知道的所有其他SQL实现上都会失败。</target>
        </trans-unit>
        <trans-unit id="67d39480596a16c7c11f0309e84be58f71d89746" translate="yes" xml:space="preserve">
          <source>The same basic B-Tree format is used but the details of the index keys were changed in order to provide better query optimization opportunities. Some of the headers were also changed in order to increase the maximum size of a row from 64KB to 24MB.</source>
          <target state="translated">使用相同的基本B-Tree格式,但为了提供更好的查询优化机会,改变了索引键的细节。为了将一行的最大大小从64KB增加到24MB,还改变了一些头文件。</target>
        </trans-unit>
        <trans-unit id="8827fbb3b64d8c27595464e7777bbb4e772df118" translate="yes" xml:space="preserve">
          <source>The same basic algorithm is followed, except this time the matching rows of the index are scanned from bottom to top instead of from top to bottom, so that the states will appear in descending order.</source>
          <target state="translated">同样的基本算法,只是这次索引的匹配行是从下往上扫描,而不是从上往下扫描,这样状态将按降序出现。</target>
        </trans-unit>
        <trans-unit id="8ef4bb6f50ee96f372f99fa9088d7b9c16950c07" translate="yes" xml:space="preserve">
          <source>The same core string formatter is also used internally by SQLite.</source>
          <target state="translated">同样的核心字符串格式化器也被SQLite内部使用。</target>
        </trans-unit>
        <trans-unit id="c76359de67616f16a26e96d68504c135072ade53" translate="yes" xml:space="preserve">
          <source>The same database connection may now be used simultaneously by separate threads.</source>
          <target state="translated">同一数据库连接现在可以由不同的线程同时使用。</target>
        </trans-unit>
        <trans-unit id="3bfa6cdc7cb80687d83044e6ab3337ab8d5595b5" translate="yes" xml:space="preserve">
          <source>The same indices are used to speed up every loop in both implementation options. The only difference in these two query plans is the order in which the loops are nested.</source>
          <target state="translated">在这两个实现方案中,使用相同的索引来加快每个循环的速度。这两个查询计划的唯一区别是循环的嵌套顺序。</target>
        </trans-unit>
        <trans-unit id="d1cd4608c87b02b3bc5ed6c81e7bb9ae9c4b8e13" translate="yes" xml:space="preserve">
          <source>The same technique ensures that an SQLite database file cannot be corrupted by a system failure that occurs at an inopportune moment. If a system failure does occur before SQLite has had a chance to execute sufficient</source>
          <target state="translated">同样的技术确保了SQLite数据库文件不会因为在不恰当的时刻发生的系统故障而损坏。如果系统故障确实发生在SQLite还没有来得及执行足够的程序之前。</target>
        </trans-unit>
        <trans-unit id="40cbe38c06ce85b1c49ad0c8414f8f89ac5525ac" translate="yes" xml:space="preserve">
          <source>The same thing can be done with an enterprise client/server database, of course. The advantage of SQLite is that it is easier to install and use and the resulting database is a single file that can be written to a USB memory stick or emailed to a colleague.</source>
          <target state="translated">当然,同样的事情也可以用企业客户/服务器数据库来完成。SQLite的优点是安装和使用比较方便,而且生成的数据库是一个单一的文件,可以写入U盘或者通过电子邮件发给同事。</target>
        </trans-unit>
        <trans-unit id="d9e7d4c0bf312ba2ed4d788d1d81806125454441" translate="yes" xml:space="preserve">
          <source>The scalar SQL function rtreecheck(R) or rtreecheck(S,R) runs an integrity check on the rtree table named R contained within database S. The function returns a human-language description of any problems found, or the string 'ok' if everything is ok. Running rtreecheck() on an R*Tree virtual table is similar to running &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; on a database.</source>
          <target state="translated">标量SQL函数rtreecheck（R）或rtreecheck（S，R）对数据库S中包含的名为R的rtree表运行完整性检查。该函数返回发现的任何问题的人工语言描述，或者返回字符串'ok'（如果存在）一切都好。在R * Tree虚拟表上运行rtreecheck（）类似于在数据库上运行&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="181bcf0e796a132dd22a68144a4e494726dfbf32" translate="yes" xml:space="preserve">
          <source>The scenario above sounds far-fetched. But the SQLite developers are aware of at least one commercial product that was released with exactly this bug. The vendor came to the SQLite developers seeking help in tracking down some infrequent database corruption issues they were seeing on Linux and Mac. The problem was eventually traced to the fact that the application was linking against two separate copies of SQLite. The solution was to change the application build procedures to link against just one copy of SQLite instead of two.</source>
          <target state="translated">上述情况听起来很牵强。但SQLite开发者知道至少有一款商业产品发布时恰恰存在这种错误。供应商向SQLite开发人员寻求帮助,以追踪他们在Linux和Mac上看到的一些不频繁的数据库损坏问题。这个问题最终被追溯到一个事实,即应用程序是针对SQLite的两个独立副本进行链接的。解决方法是改变应用程序的构建过程,使其只与一个SQLite副本而不是两个副本进行链接。</target>
        </trans-unit>
        <trans-unit id="7cf33abd12fd2e97d31a441b54d245ec800fc490" translate="yes" xml:space="preserve">
          <source>The schema above defines a directed graph with the ability to store a name at each node. Now consider a query against this schema:</source>
          <target state="translated">上面的模式定义了一个有向图,能够在每个节点上存储一个名字。现在考虑对这个模式进行查询。</target>
        </trans-unit>
        <trans-unit id="d37b6e6570fc572ab09d9f50bc38138c9b41b0ec" translate="yes" xml:space="preserve">
          <source>The schema cookie is a 4-byte big-endian integer at offset 40 that is incremented whenever the database schema changes. A prepared statement is compiled against a specific version of the database schema. When the database schema changes, the statement must be reprepared. When a prepared statement runs, it first checks the schema cookie to ensure the value is the same as when the statement was prepared and if the schema cookie has changed, the statement either automatically reprepares and reruns or it aborts with an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error.</source>
          <target state="translated">模式cookie是偏移量40处的4字节大尾数整数，每当数据库模式更改时，该cookie就会递增。准备好的语句是针对特定版本的数据库模式进行编译的。当数据库模式更改时，必须重新准备该语句。当准备好的语句运行时，它首先检查架构cookie，以确保该值与准备该语句时的值相同；如果架构cookie已更改，则该语句将自动重新准备并重新运行，或者由于&lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt;错误而中止。</target>
        </trans-unit>
        <trans-unit id="1ab0e540f94c93f90585f3869aa649d5881cec37" translate="yes" xml:space="preserve">
          <source>The schema cookie.</source>
          <target state="translated">模式cookie。</target>
        </trans-unit>
        <trans-unit id="4488aa59b7580b3c4da5952eb56f99b2cde228a2" translate="yes" xml:space="preserve">
          <source>The schema depicted above is not designed to store the full-text index directly. Instead, it is used to store one or more b-tree structures. There is one b-tree for each row in the %_segdir table. The %_segdir table row contains the root node and various meta-data associated with the b-tree structure, and the %_segments table contains all other (non-root) b-tree nodes. Each b-tree is referred to as a &quot;segment&quot;. Once it has been created, a segment b-tree is never updated (although it may be deleted altogether).</source>
          <target state="translated">上面所描述的模式并不是为了直接存储全文索引而设计的,而是用来存储一个或多个b-tree结构。相反,它被用来存储一个或多个b-tree结构。在%_segdir表中,每一行都有一个b树。%_segdir表行包含根节点和与b树结构相关的各种元数据,%_segments表包含所有其他(非根)b树节点。每个b树被称为 &quot;segments&quot;。一旦被创建,一个分段b树就不会被更新(尽管它可能被完全删除)。</target>
        </trans-unit>
        <trans-unit id="2b92ee620ed7f83eb29e5266f914917afed4620a" translate="yes" xml:space="preserve">
          <source>The schema for the DBSTAT virtual table looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd02dc53052cb07a4282595789654910705302c" translate="yes" xml:space="preserve">
          <source>The schema for the dbstat virtual table is this:</source>
          <target state="translated">dbstat虚拟表的模式是这样的。</target>
        </trans-unit>
        <trans-unit id="2252a25e95423355b1edc92e550e314acf60ad89" translate="yes" xml:space="preserve">
          <source>The schema for the table returned by json_each() and json_tree() is as follows:</source>
          <target state="translated">json_each()和json_tree()返回的表的模式如下。</target>
        </trans-unit>
        <trans-unit id="c3619e8cc0e29548b78032aaa5130408e5391fbe" translate="yes" xml:space="preserve">
          <source>The schema for the tables_used table is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f20e4cd592c03cab97adad3d2182916294f862d" translate="yes" xml:space="preserve">
          <source>The schema format number for a new database can be set at runtime using the &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format&lt;/a&gt; command.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format&lt;/a&gt;命令设置新数据库的模式格式编号。</target>
        </trans-unit>
        <trans-unit id="933a80ece41d7c4fe3169e373964e2826ef1d8f7" translate="yes" xml:space="preserve">
          <source>The schema format number is a 4-byte big-endian integer at offset 44. The schema format number is similar to the file format read and write version numbers at offsets 18 and 19 except that the schema format number refers to the high-level SQL formatting rather than the low-level b-tree formatting. Four schema format numbers are currently defined:</source>
          <target state="translated">模式格式号是一个4字节的大恩迪安整数,位于偏移量44。模式格式号与偏移量18和19处的文件格式读写版本号类似,只是模式格式号指的是高级SQL格式化,而不是低级b-tree格式化。目前定义了四种模式格式号。</target>
        </trans-unit>
        <trans-unit id="62a7a887a20a821d1b69e9b449caf90b4200d958" translate="yes" xml:space="preserve">
          <source>The schema format number. Supported schema formats are 1, 2, 3, and 4.</source>
          <target state="translated">方案格式号。支持的模式格式有1、2、3和4。</target>
        </trans-unit>
        <trans-unit id="c07d56a869023707575ade10738a217ecfcee4af" translate="yes" xml:space="preserve">
          <source>The schema of an SQL database is able to represent information more directly and succinctly than a key/value database such as a ZIP archive. This makes the document content more accessible to third-party applications and scripts and facilitates advanced features such as built-in document versioning, and incremental saving of work in progress for recovery after a crash.</source>
          <target state="translated">与ZIP档案等键/值数据库相比,SQL数据库的模式能够更直接、更简洁地表示信息。这使得文档内容更容易被第三方应用程序和脚本所访问,并促进了高级功能,如内置的文档版本,以及正在进行的工作的增量保存,以便在崩溃后恢复。</target>
        </trans-unit>
        <trans-unit id="4828e232778c36009f5d78cd72861a810e476bb6" translate="yes" xml:space="preserve">
          <source>The schema of the bytecode table is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a339d84c3beee1eeb93694c936d75161789ed451" translate="yes" xml:space="preserve">
          <source>The schema table can always be referenced using the name &quot;sqlite_schema&quot;, especially if qualifed by the schema name like &quot;main.sqlite_schema&quot; or &quot;temp.sqlite_schema&quot;. But for historical compatibility, some alternative names are also recognized, including:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70d31e0ed54ade1f01f5803b76d2ee1ab0a7fa16" translate="yes" xml:space="preserve">
          <source>The schema_version pragma will get or set the value of the schema-version integer at offset 40 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87cc88d5b4a5e95bb023c0790cc28378b9e2bd05" translate="yes" xml:space="preserve">
          <source>The schema_version pragma will to get or set the value of the schema-version integer at offset 40 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;.</source>
          <target state="translated">schema_version编译指示将获取或设置&lt;a href=&quot;fileformat2#database_header&quot;&gt;数据库标头&lt;/a&gt;中偏移40处的schema-version整数的值。</target>
        </trans-unit>
        <trans-unit id="077341a10c528ac1588a1408b9034c9f8021b705" translate="yes" xml:space="preserve">
          <source>The scheme of the URI must be &quot;&lt;code&gt;file:&lt;/code&gt;&quot;. Any other scheme results in the input being treated as an ordinary filename.</source>
          <target state="translated">URI的方案必须为&amp;ldquo; &lt;code&gt;file:&lt;/code&gt; &amp;rdquo;。任何其他方案都会导致输入被视为普通文件名。</target>
        </trans-unit>
        <trans-unit id="08d91918dffee8fc87a94df6946790f6caab8817" translate="yes" xml:space="preserve">
          <source>The score is a combination of rank and distance. The idea is that a lower score is better. The virtual table attempts to find words with the lowest score and by default (unless overridden by ORDER BY) returns results in order of increasing score.</source>
          <target state="translated">分数是等级和距离的组合。这个想法是分数越低越好。虚拟表试图找到得分最低的词,默认情况下(除非被ORDER BY覆盖)按得分增加的顺序返回结果。</target>
        </trans-unit>
        <trans-unit id="61fd3b441b127465c680d5c3514e6d464720698f" translate="yes" xml:space="preserve">
          <source>The script compiles the TH3 test harness into machine code (&quot;th3.o&quot;) if necessary.</source>
          <target state="translated">如果需要的话,这个脚本会把TH3测试线束编译成机器代码(&quot;th3.o&quot;)。</target>
        </trans-unit>
        <trans-unit id="9f405708716b43bff0ad67cd4c7d9fb92e6afc28" translate="yes" xml:space="preserve">
          <source>The script compiles the sqlite3.c source file into assembly language (&quot;sqlite3.s&quot;) if necessary.</source>
          <target state="translated">如果需要的话,脚本会将sqlite3.c源文件编译成汇编语言(&quot;sqlite3.s&quot;)。</target>
        </trans-unit>
        <trans-unit id="9bf1fc92f793f60b433b7ebac87847be7a48eb60" translate="yes" xml:space="preserve">
          <source>The script loops through instructions in the assembly language file to locate branch operations.</source>
          <target state="translated">脚本循环浏览汇编语言文件中的指令,以定位分支操作。</target>
        </trans-unit>
        <trans-unit id="576c62795ba33247bec0c331da3dd87f14e7a748" translate="yes" xml:space="preserve">
          <source>The script makes a copy of the original sqlite3.s file.</source>
          <target state="translated">脚本对原来的sqlite3.s文件进行复制。</target>
        </trans-unit>
        <trans-unit id="fbefc60f4848710280b3f195980be93ae6fb0731" translate="yes" xml:space="preserve">
          <source>The script shows progress for each cycle of the previous step then displays a summary of &quot;survivors&quot; at the end. A &quot;survivor&quot; is a mutation that was not detected by TH3.</source>
          <target state="translated">脚本显示了上一步的每个周期的进展,然后在最后显示 &quot;幸存者 &quot;的摘要。一个 &quot;幸存者 &quot;是指一个没有被TH3检测到的突变。</target>
        </trans-unit>
        <trans-unit id="4a731425cd1bb86844c78ad068a724419eca7459" translate="yes" xml:space="preserve">
          <source>The search for these strings in the type declaration is case insensitive, of course. If any of the above strings occur anywhere in the type declaration, then the datatype of the column is text. Notice that the type &quot;VARCHAR&quot; contains &quot;CHAR&quot; as a substring so it is considered text.</source>
          <target state="translated">当然,在类型声明中搜索这些字符串是不区分大小写的。如果在类型声明中的任何地方出现上述字符串,那么列的数据类型就是文本。注意,类型 &quot;VARCHAR &quot;中包含 &quot;CHAR &quot;作为子串,所以它被认为是文本。</target>
        </trans-unit>
        <trans-unit id="201735a6137bd8c721345300624cc86e3645ba64" translate="yes" xml:space="preserve">
          <source>The second &lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt; instruction begins a transaction and starts a rollback journal for database 1, the database used for temporary tables.</source>
          <target state="translated">第二个&lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt;指令开始一个事务并启动数据库1（用于临时表的数据库）的回滚日志。</target>
        </trans-unit>
        <trans-unit id="541464126fdf47682a89498dd2c1f59037e5c50b" translate="yes" xml:space="preserve">
          <source>The second SELECT is implemented by instructions 14 through 19. Instruction 14 initializes the loop by rewinding its cursor. A new result row is created from the &quot;four&quot; column of table &quot;examp2&quot; by instructions 15 and 16. But instead of using PutStrKey to write this new row into the temporary table, we instead call Delete to remove it from the temporary table if it exists.</source>
          <target state="translated">第二条SELECT由指令14至19实现。指令14通过将光标回卷来初始化循环。通过指令15和16从表 &quot;examp2 &quot;的 &quot;四 &quot;列中创建一条新的结果行。但是我们没有使用PutStrKey将这条新行写入临时表,而是调用Delete将其从临时表中删除(如果存在的话)。</target>
        </trans-unit>
        <trans-unit id="b382925f3a88c50c566963d5ae8b2f2a69bce488" translate="yes" xml:space="preserve">
          <source>The second advantage the SQLite printf routines have over &lt;b&gt;sprintf&lt;/b&gt; are two new formatting options specifically designed to support string literals in SQL. Within the format string, the %q formatting option works very much like %s in that it reads a null-terminated string from the argument list and inserts it into the result. But %q translates the inserted string by making two copies of every single-quote (') character in the substituted string. This has the effect of escaping the end-of-string meaning of single-quote within a string literal. The %Q formatting option works similar; it translates the single-quotes like %q and additionally encloses the resulting string in single-quotes. If the argument for the %Q formatting options is a NULL pointer, the resulting string is NULL without single quotes.</source>
          <target state="translated">与&lt;b&gt;sprintf&lt;/b&gt;相比，SQLite printf例程具有的第二个优势是两个新的格式设置选项，这些选项专门设计用于支持SQL中的字符串文字。在格式字符串中，％q格式设置选项的作用与％s非常相似，因为它从参数列表中读取以空值结尾的字符串并将其插入到结果中。但是％q通过为替换字符串中的每个单引号（'）字符制作两个副本来翻译插入的字符串。这具有在字符串文字中转义单引号的字符串结尾含义的效果。 ％Q格式化选项的工作原理类似；它翻译％q之类的单引号，并另外将结果字符串括在单引号中。如果％Q格式设置选项的参数为NULL指针，则结果字符串为NULL，不带单引号。</target>
        </trans-unit>
        <trans-unit id="24bd2add8c4054117cbe09f659537f282404edb5" translate="yes" xml:space="preserve">
          <source>The second and all subsequent 32768-byte units of the shm file are like this:</source>
          <target state="translated">shm文件的第二个及以后所有32768字节的单位是这样的。</target>
        </trans-unit>
        <trans-unit id="2f88dda8423c5371c7ad74eb85809481a6d1addf" translate="yes" xml:space="preserve">
          <source>The second and third forms return the computed edit distance between strings 'string1' and &quot;string2'. In the second form, a language id of 0 is used. The language id is specified in the third form.</source>
          <target state="translated">第二和第三种形式返回字符串 &quot;string1 &quot;和 &quot;string2 &quot;之间的计算编辑距离。在第二种形式中,使用的语言ID为0。在第三种形式中,语言ID被指定。</target>
        </trans-unit>
        <trans-unit id="bab5b375ff048a5d63f1a3b4cc3d343effcaa9c1" translate="yes" xml:space="preserve">
          <source>The second argument (xFilter) is the &quot;filter callback&quot;. For changes to rows in tables that are not attached to the Session object, the filter is called to determine whether changes to the table's rows should be tracked or not. If xFilter returns 0, changes are not tracked. Note that once a table is attached, xFilter will not be called again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a47f0193da66fdda72484a51d350d2076b5681" translate="yes" xml:space="preserve">
          <source>The second argument (xFilter) is the &quot;filter callback&quot;. For changes to rows in tables that are not attached to the Session object, the filter is called to determine whether changes to the table's rows should be tracked or not. If xFilter returns 0, changes is not tracked. Note that once a table is attached, xFilter will not be called again.</source>
          <target state="translated">第二个参数(xFilter)是 &quot;过滤器回调&quot;。对于没有连接到Session对象的表的行的更改,过滤器被调用来决定是否应该跟踪表的行的更改。如果xFilter返回0,则不跟踪更改。请注意,一旦表被附加,xFilter将不会被再次调用。</target>
        </trans-unit>
        <trans-unit id="718f90fed591046439ad14f60ea06810377e7e83" translate="yes" xml:space="preserve">
          <source>The second argument indicates the reason that FTS5 is requesting tokenization of the supplied text. This is always one of the following four values:</source>
          <target state="translated">第二个参数表示FTS5请求对提供的文本进行标记化的原因。该参数始终是以下四个值之一。</target>
        </trans-unit>
        <trans-unit id="1b37e9b1846948d626696aade4d54493fddd03d8" translate="yes" xml:space="preserve">
          <source>The second argument is a pointer to the function to invoke when a row is updated, inserted or deleted in a rowid table. The first argument to the callback is a copy of the third argument to sqlite3_update_hook(). The second callback argument is one of &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the operation that caused the callback to be invoked. The third and fourth arguments to the callback contain pointers to the database and table name containing the affected row. The final callback parameter is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row. In the case of an update, this is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; after the update takes place.</source>
          <target state="translated">第二个参数是指向在rowid表中更新，插入或删除行时要调用的函数的指针。回调的第一个参数是sqlite3_update_hook（）的第三个参数的副本。第二个回调参数是&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE之一&lt;/a&gt;，具体取决于导致调用回调的操作。回调的第三个和第四个参数包含指向数据库的指针和包含受影响的行的表名称。最后的回调参数是该行的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。在更新的情况下，这是更新发生后的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6eef977cb1db09c38e32ceda39f74ec952be8d2" translate="yes" xml:space="preserve">
          <source>The second argument is a pointer to the function to invoke when a row is updated, inserted or deleted in a rowid table. The first argument to the callback is a copy of the third argument to sqlite3_update_hook(). The second callback argument is one of &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the operation that caused the callback to be invoked. The third and fourth arguments to the callback contain pointers to the database and table name containing the affected row. The final callback parameter is the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row. In the case of an update, this is the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; after the update takes place.</source>
          <target state="translated">第二个参数是指向在rowid表中更新，插入或删除行时要调用的函数的指针。回调的第一个参数是sqlite3_update_hook（）的第三个参数的副本。第二个回调参数是&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;，&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;或&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE之一&lt;/a&gt;，具体取决于导致调用回调的操作。回调的第三个和第四个参数包含指向数据库的指针和包含受影响的行的表名称。最后的回调参数是该行的&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。在更新的情况下，这是更新发生后的&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="724bd11ad92d936922e1ead7d8425d39851a3038" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 32766).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e308f3aa98b17590b5e994747b662ab58b2433" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 999).</source>
          <target state="translated">第二个参数是要设置的SQL参数的索引。最左边的SQL参数的索引为1。当多次使用同一命名的SQL参数时，第二个及后续出现的索引与第一次出现的索引相同。如果需要，可以使用&lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index（）&lt;/a&gt; API 查找命名参数的索引。 &amp;ldquo;？NNN&amp;rdquo;参数的索引是NNN的值。 NNN值必须介于1到&lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;参数&lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER之间&lt;/a&gt;（默认值：999）。</target>
        </trans-unit>
        <trans-unit id="ff965dc4a3884d50d8419508e30018f226ac3b0d" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 32766).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f014790ea15d84ae5efd1a40e8d6440e64de4e" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 999).</source>
          <target state="translated">第二个参数是要设置的SQL参数的索引。最左边的SQL参数的索引为1。当多次使用同一命名的SQL参数时，第二个及后续出现的索引与第一次出现的索引相同。如果需要，可以使用&lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index（）&lt;/a&gt; API 查找命名参数的索引。 &amp;ldquo;？NNN&amp;rdquo;参数的索引是NNN的值。 NNN值必须介于1到&lt;a href=&quot;limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;参数&lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER之间&lt;/a&gt;（默认值：999）。</target>
        </trans-unit>
        <trans-unit id="2fb1bff691f79072fe4cf1aa2d31d1bd3832725a" translate="yes" xml:space="preserve">
          <source>The second argument passed to the xToken() callback (&quot;tflags&quot;) should normally be set to 0. The exception is if the tokenizer supports synonyms. In this case see the discussion below for details.</source>
          <target state="translated">传递给xToken()回调的第二个参数(&quot;tflags&quot;)通常应该设置为0。 如果tokenizer支持同义词,则例外。在这种情况下,详情请参考下面的讨论。</target>
        </trans-unit>
        <trans-unit id="ca943db57529952ad5f76d4c9a47b52221a6d6e3" translate="yes" xml:space="preserve">
          <source>The second argument to sqlite3_db_config(D,V,...) is the &lt;a href=&quot;#sqlitedbconfiglookaside&quot;&gt;configuration verb&lt;/a&gt; - an integer code that indicates what aspect of the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being configured. Subsequent arguments vary depending on the configuration verb.</source>
          <target state="translated">sqlite3_db_config（D，V，...）的第二个参数是&lt;a href=&quot;#sqlitedbconfiglookaside&quot;&gt;配置动词&lt;/a&gt; -一个整数代码，指示正在配置&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接的&lt;/a&gt;哪个方面。后续参数根据配置动词而有所不同。</target>
        </trans-unit>
        <trans-unit id="a7845e3bb7f88361055af36d05adde4b952592f9" translate="yes" xml:space="preserve">
          <source>The second argument to sqlite3_db_config(D,V,...) is the &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;configuration verb&lt;/a&gt; - an integer code that indicates what aspect of the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being configured. Subsequent arguments vary depending on the configuration verb.</source>
          <target state="translated">sqlite3_db_config（D，V，...）的第二个参数是&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;配置动词&lt;/a&gt; -一个整数代码，指示正在配置&lt;a href=&quot;sqlite3&quot;&gt;数据库连接的&lt;/a&gt;哪个方面。后续参数根据配置动词而有所不同。</target>
        </trans-unit>
        <trans-unit id="7ca88f23336b34513d2d790b7c87ef9c5d8d0e67" translate="yes" xml:space="preserve">
          <source>The second argument to the error logger callback is an integer &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt;. The third argument to the error logger is the text of the error message. The error message text is stored in a fixed-length stack buffer in the calling function and so will only be valid for the duration of the error logger callback function. The error logger should make a copy of this message into persistent storage if retention of the message is needed.</source>
          <target state="translated">错误记录器回调的第二个参数是整数&lt;a href=&quot;rescode#extrc&quot;&gt;扩展错误代码&lt;/a&gt;。错误记录器的第三个参数是错误消息的文本。错误消息文本存储在调用函数的固定长度堆栈缓冲区中，因此仅在错误记录器回调函数期间有效。如果需要保留消息，则错误记录器应将此消息复制到持久性存储中。</target>
        </trans-unit>
        <trans-unit id="a2a47b21d6064e4d10a2f6d6161c0f1dce1664a1" translate="yes" xml:space="preserve">
          <source>The second argument, &quot;zSql&quot;, is the statement to be compiled, encoded as either UTF-8 or UTF-16. The sqlite3_prepare(), sqlite3_prepare_v2(), and sqlite3_prepare_v3() interfaces use UTF-8, and sqlite3_prepare16(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() use UTF-16.</source>
          <target state="translated">第二个参数 &quot;zSql &quot;是要编译的语句,编码为UTF-8或UTF-16。sqlite3_prepare()、 sqlite3_prepare_v2()和 sqlite3_prepare_v3()接口使用UTF-8,sqlite3_prepare16()、 sqlite3_prepare16_v2()和 sqlite3_prepare16_v3()使用UTF-16。</target>
        </trans-unit>
        <trans-unit id="f2e250c2ef383dec7dc31067a07b23d0da95c91b" translate="yes" xml:space="preserve">
          <source>The second beta release for SQLite 3.0.</source>
          <target state="translated">SQLite 3.0的第二个测试版本。</target>
        </trans-unit>
        <trans-unit id="771287a1de97a728b2134cd9c420c1c39a0f52c6" translate="yes" xml:space="preserve">
          <source>The second column is the name of the table.</source>
          <target state="translated">第二列是表的名称。</target>
        </trans-unit>
        <trans-unit id="68511a08109abd7af5a81fce815eeb4f023584c9" translate="yes" xml:space="preserve">
          <source>The second form changes the journaling mode for &quot;</source>
          <target state="translated">第二种形式将日记模式改为&quot;&quot;。</target>
        </trans-unit>
        <trans-unit id="2f272c30ebac8ce92b2f903964b40a07bad463d7" translate="yes" xml:space="preserve">
          <source>The second form of the INSERT statement contains a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement instead of a VALUES clause. A new entry is inserted into the table for each row of data returned by executing the SELECT statement. If a column-list is specified, the number of columns in the result of the SELECT must be the same as the number of items in the column-list. Otherwise, if no column-list is specified, the number of columns in the result of the SELECT must be the same as the number of columns in the table. Any SELECT statement, including &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECTs&lt;/a&gt; and SELECT statements with &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; and/or &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; clauses, may be used in an INSERT statement of this form.</source>
          <target state="translated">INSERT语句的第二种形式包含&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句，而不是VALUES子句。对于通过执行SELECT语句返回的每一行数据，表中都会插入一个新条目。如果指定了列列表，则SELECT结果中的列数必须与列列表中的项目数相同。否则，如果未指定column-list，则SELECT结果中的列数必须与表中的列数相同。任何SELECT语句，包括&lt;a href=&quot;lang_select#compound&quot;&gt;复合SELECTs&lt;/a&gt;和带有&lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;和/或&lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt;子句的SELECT语句，都可以在这种形式的INSERT语句中使用。</target>
        </trans-unit>
        <trans-unit id="ec9aa9593798c759bbdf9a6cf2b73541eab87efe" translate="yes" xml:space="preserve">
          <source>The second form of the command is this:</source>
          <target state="translated">命令的第二种形式是这样的。</target>
        </trans-unit>
        <trans-unit id="fa9b557c755fe5c619c7e5fc0af0adff81ce48ad" translate="yes" xml:space="preserve">
          <source>The second form of the pragma listed above is used to set a new limit in bytes for the specified database. A negative number implies no limit. To always truncate rollback journals and WAL files to their minimum size, set the journal_size_limit to zero. Both the first and second forms of the pragma listed above return a single result row containing a single integer column - the value of the journal size limit in bytes. The default journal size limit is -1 (no limit). The &lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT&lt;/a&gt; preprocessor macro can be used to change the default journal size limit at compile-time.</source>
          <target state="translated">上面列出的编译指示的第二种形式用于为指定的数据库设置新的字节限制。负数表示没有限制。要始终将回滚日志和WAL文件截断为最小大小，请将journal_size_limit设置为零。上面列出的编译指示的第一种和第二种形式均返回包含单个整数列的单个结果行-日志大小限制的值（以字节为单位）。默认的日记帐大小限制为-1（无限制）。该&lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT&lt;/a&gt;预处理宏可以用来在编译时更改默认的日志大小限制。</target>
        </trans-unit>
        <trans-unit id="4008980ca9a9274111928748bc06de4b907efa68" translate="yes" xml:space="preserve">
          <source>The second integer, if it is present, is the aggregate size of all data stored on leaf pages in bytes. If the value is negative, then the segment is the output of an unfinished incremental-merge operation, and the absolute value is current size in bytes.</source>
          <target state="translated">第二个整数,如果存在,则是存储在叶页上的所有数据的总大小,单位是字节。如果该值为负,则该段是未完成的增量合并操作的输出,绝对值是当前大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="211c21970b7cdeb91101e574bc29708c2cdfae64" translate="yes" xml:space="preserve">
          <source>The second line above creates a virtual table named &quot;t1&quot; that reads the content of the file named in the argument. The number and names of the columns is determined automatically by reading the first line of content. Other options to the CSV virtual table provide the ability to take the CSV content from a string rather than a separate file, and give the programmer more control over the number and names of the columns. The options are detailed below. The CSV virtual table is usually created as a TEMP table so that it exists only for the current database connection and does not become a permanent part of the database schema. Note that there is no &quot;CREATE TEMP VIRTUAL TABLE&quot; command in SQLite. Instead, prepend the &quot;temp.&quot; schema prefix to the name of the virtual table.</source>
          <target state="translated">上面第二行创建了一个名为 &quot;t1 &quot;的虚拟表,读取参数中命名的文件内容。列的数量和名称是通过读取第一行内容自动确定的。CSV虚拟表的其他选项提供了从字符串而不是单独的文件中获取CSV内容的能力,并让程序员对列的数量和名称有更多的控制。这些选项详述如下。CSV虚拟表通常是作为TEMP表创建的,这样它只为当前的数据库连接而存在,不会成为数据库模式的永久部分。注意,在SQLite中没有 &quot;CREATE TEMP VIRTUAL TABLE &quot;命令。而是在虚拟表的名称前加上 &quot;temp.&quot;模式前缀。</target>
        </trans-unit>
        <trans-unit id="c3933495d9788c26f88ba69fbabb317f1e83064e" translate="yes" xml:space="preserve">
          <source>The second line of the file contains 211792 characters of impenetrable XML. Yes, 211792 characters all on one line. This file is a good stress-test for a text editor. Thankfully, the file is not some obscure binary format, but in terms of accessibility, it might as well be written in Klingon.</source>
          <target state="translated">文件的第二行包含211792个字符,是无法穿透的XML。是的,211792个字符都在一行。这个文件对文本编辑器来说是一个很好的压力测试。值得庆幸的是,这个文件并不是什么晦涩难懂的二进制格式,但就无障碍性而言,它也可能是用克林贡语写的。</target>
        </trans-unit>
        <trans-unit id="5c1d27adf7a874de9fb599be39fb1d27d63c3092" translate="yes" xml:space="preserve">
          <source>The second number Y is incremented for any change that breaks forward compatibility by adding new features. Most future SQLite releases are expected to increment the second number Y. The Z is reset to zero whenever Y is increased.</source>
          <target state="translated">第二位数字Y是通过增加新功能而破坏前向兼容性的任何变化而递增的,未来的大多数SQLite版本预计会递增第二位数字Y,每当Y增加时,Z会被重置为零。大多数未来的SQLite版本都会对第二个数字Y进行递增,每当Y增加时,Z会被重置为零。</target>
        </trans-unit>
        <trans-unit id="50b9dd44fd65466aa651f4fce7056da00ed7e13a" translate="yes" xml:space="preserve">
          <source>The second parameter (argc) and the fourth parameter (columnNames) are still valid and can be used to determine the number and names of the result columns if there had been a result. The default behavior is not to invoke the callback at all if the result set is empty.</source>
          <target state="translated">第二个参数(argc)和第四个参数(columnNames)仍然有效,如果有结果,可以用来确定结果列的数量和名称。如果结果集为空,默认行为是完全不调用回调。</target>
        </trans-unit>
        <trans-unit id="682054ab4ce2cb4dfe2528dcad7556d5d406ca5f" translate="yes" xml:space="preserve">
          <source>The second parameter is the name of the SQL function to be created or redefined. The length of the name is limited to 255 bytes in a UTF-8 representation, exclusive of the zero-terminator. Note that the name length limit is in UTF-8 bytes, not characters nor UTF-16 bytes. Any attempt to create a function with a longer name will result in &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt; being returned.</source>
          <target state="translated">第二个参数是要创建或重新定义的SQL函数的名称。名称的长度以UTF-8表示形式限制为255个字节，不包括零终止符。请注意，名称长度限制以UTF-8字节为单位，而不是字符或UTF-16字节。任何尝试使用更长名称创建函数的尝试都会导致返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="266b83f6439ab5e88dcd3928741ef542cdbb6626" translate="yes" xml:space="preserve">
          <source>The second parameter is the name of the SQL function to be created or redefined. The length of the name is limited to 255 bytes in a UTF-8 representation, exclusive of the zero-terminator. Note that the name length limit is in UTF-8 bytes, not characters nor UTF-16 bytes. Any attempt to create a function with a longer name will result in &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; being returned.</source>
          <target state="translated">第二个参数是要创建或重新定义的SQL函数的名称。名称的长度以UTF-8表示形式限制为255个字节，不包括零终止符。请注意，名称长度限制以UTF-8字节为单位，而不是字符或UTF-16字节。任何尝试使用更长名称创建函数的尝试都会导致返回&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="560b989b803d6b51bde79f3db2c1500c44cc5751" translate="yes" xml:space="preserve">
          <source>The second parameter to the preupdate callback is a pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that registered the preupdate hook. The third parameter to the preupdate callback is one of the constants &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE&lt;/a&gt; to identify the kind of update operation that is about to occur. The fourth parameter to the preupdate callback is the name of the database within the database connection that is being modified. This will be &quot;main&quot; for the main database or &quot;temp&quot; for TEMP tables or the name given after the AS keyword in the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for attached databases. The fifth parameter to the preupdate callback is the name of the table that is being modified.</source>
          <target state="translated">preupdate回调的第二个参数是指向注册preupdate挂钩的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;的指针。 preupdate回调的第三个参数是常量&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE之一，&lt;/a&gt;用于标识即将发生的更新操作的类型。 preupdate回调的第四个参数是数据库连接中正在修改的数据库的名称。对于主数据库，这将是&amp;ldquo; main&amp;rdquo;；对于TEMP表，这将是&amp;ldquo; temp&amp;rdquo;；对于已连接的数据库，这将在&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;语句中的AS关键字之后给出。 preupdate回调的第五个参数是要修改的表的名称。</target>
        </trans-unit>
        <trans-unit id="097d5db1a651bbf810ec3be53362ed0414cfc3f9" translate="yes" xml:space="preserve">
          <source>The second parameter to the preupdate callback is a pointer to the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that registered the preupdate hook. The third parameter to the preupdate callback is one of the constants &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; to identify the kind of update operation that is about to occur. The fourth parameter to the preupdate callback is the name of the database within the database connection that is being modified. This will be &quot;main&quot; for the main database or &quot;temp&quot; for TEMP tables or the name given after the AS keyword in the &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for attached databases. The fifth parameter to the preupdate callback is the name of the table that is being modified.</source>
          <target state="translated">preupdate回调的第二个参数是指向注册preupdate挂钩的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;的指针。 preupdate回调的第三个参数是常量&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;，&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;或&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE之一，&lt;/a&gt;用于标识即将发生的更新操作的类型。 preupdate回调的第四个参数是数据库连接中正在修改的数据库的名称。对于主数据库，这将是&amp;ldquo; main&amp;rdquo;；对于TEMP表，这将是&amp;ldquo; temp&amp;rdquo;；对于已连接的数据库，这将在&lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;语句中的AS关键字之后给出。 preupdate回调的第五个参数是要修改的表的名称。</target>
        </trans-unit>
        <trans-unit id="f5ad56c8e6b709d2294efc15c0b9ac27fea8d776" translate="yes" xml:space="preserve">
          <source>The second step finds the four shortest paths to visit two nodes beginning with one of the four paths from the previous step. In the case where two or more paths are equivalent (they have the same set of visited nodes, though possibly in a different order) only the first and lowest-cost path is retained. We have:</source>
          <target state="translated">第二步从上一步的四条路径中的一条开始,找出访问两个节点的四条最短路径。在两条或多条路径相等的情况下(它们有相同的访问节点集,虽然顺序可能不同),只保留第一条成本最低的路径。我们有:</target>
        </trans-unit>
        <trans-unit id="73fbb8fcf9b3b6fa8277785714e82cfa142507c2" translate="yes" xml:space="preserve">
          <source>The second through fifth forms of this pragma set the encoding that the main database will be created with if it is created by this session. The string 'UTF-16' is interpreted as &quot;UTF-16 encoding using native machine byte-ordering&quot;. It is not possible to change the text encoding of a database after it has been created and any attempt to do so will be silently ignored.</source>
          <target state="translated">这个pragma的第二到第五种形式设置了如果主数据库是由这个会话创建的,它将被创建的编码。字符串'UTF-16'被解释为 &quot;使用本机字节排序的UTF-16编码&quot;。在创建数据库后,不可能更改数据库的文本编码,任何试图这样做的行为都将被默默忽略。</target>
        </trans-unit>
        <trans-unit id="5882943850506b5e4c2358f26a0aca06e4d009ac" translate="yes" xml:space="preserve">
          <source>The secure_delete setting causes deleted content to be overwritten with zeros. There is a small performance penalty since additional I/O must occur. On the other hand, secure_delete can prevent fragments of sensitive information from lingering in unused parts of the database file after it has been deleted. See the documentation on the &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete pragma&lt;/a&gt; for additional information.</source>
          <target state="translated">secure_delete设置导致删除的内容被零覆盖。由于必须进行额外的I / O，因此性能损失很小。另一方面，secure_delete可以防止敏感信息的片段在删除后保留在数据库文件的未使用部分中。有关其他信息，请参见&lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete编译&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="5b04afcfc3f7fd09080833015b31410c518c0339" translate="yes" xml:space="preserve">
          <source>The separate &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; description provides details on the structure of a database file and of the write-head log file used in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. But details of the locking protocol and of the format of the WAL-index are deliberately omitted since those details are left to discretion of individual &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations. This document fills in those missing details for the unix and windows &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;.</source>
          <target state="translated">单独的&lt;a href=&quot;fileformat2&quot;&gt;文件格式&lt;/a&gt;描述提供了有关&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;使用的数据库文件和写头日志文件的结构的详细信息。但是有意省略了锁定协议的细节和WAL-index格式的细节，因为这些细节留给各个&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;实现酌情决定。本文档填充了UNIX和Windows &lt;a href=&quot;vfs&quot;&gt;VFS的&lt;/a&gt;那些缺失的详细信息。</target>
        </trans-unit>
        <trans-unit id="92103d1dd017d8e08e89604f71cfaaa913bec164" translate="yes" xml:space="preserve">
          <source>The session extension facilitates this by recording all changes to both Alice's and Bob's databases and writing those changes into changeset or patchset files. At the end of the day, Alice can send her changeset to Bob and Bob can &quot;apply&quot; it to his database. The result (assuming there are no conflicts) is that Bob's database then contains both his changes and Alice's changes. Likewise, Bob can send a changeset of his work over to Alice and she can apply his changes to her database.</source>
          <target state="translated">会话扩展通过记录Alice和Bob数据库的所有变化,并将这些变化写进变化集或补丁集文件中来实现这一目的。在一天结束的时候,Alice可以把她的变化集发送给Bob,Bob可以把它应用到他的数据库中。结果(假设没有冲突)是Bob的数据库中包含了他的变化和Alice的变化。同样的,Bob可以把他的工作变化集发送给Alice,而Alice可以把他的变化应用到她的数据库中。</target>
        </trans-unit>
        <trans-unit id="1c8659fbbef014d7697d1ea170e739bed552acd5" translate="yes" xml:space="preserve">
          <source>The session extension only works with tables that have a declared PRIMARY KEY. The PRIMARY KEY of a table may be an INTEGER PRIMARY KEY (rowid alias) or an external PRIMARY KEY.</source>
          <target state="translated">会话扩展只适用于有声明PRIMARY KEY的表。表的PRIMARY KEY可以是一个INTEGER PRIMARY KEY(rowid别名)或一个外部PRIMARY KEY。</target>
        </trans-unit>
        <trans-unit id="8619b8eb0bb510e39b3c8622337b2bb7b6549aba" translate="yes" xml:space="preserve">
          <source>The session extension provide a mechanism for recording changes to some or all of the &lt;a href=&quot;rowidtable&quot;&gt;rowid tables&lt;/a&gt; in an SQLite database, and packaging those changes into a &quot;changeset&quot; or &quot;patchset&quot; file that can later be used to apply the same set of changes to another database with the same schema and compatible starting data. A &quot;changeset&quot; may also be inverted and used to &quot;undo&quot; a session.</source>
          <target state="translated">会话扩展提供了一种机制，用于记录对SQLite数据库中某些或所有&lt;a href=&quot;rowidtable&quot;&gt;rowid表&lt;/a&gt;的更改，并将这些更改打包到&amp;ldquo; changeset&amp;rdquo;或&amp;ldquo; patchset&amp;rdquo;文件中，这些文件以后可用于将同一组更改应用于另一个具有相同架构和兼容起始数据的数据库。&amp;ldquo;变更集&amp;rdquo;也可以反转并用于&amp;ldquo;撤消&amp;rdquo;会话。</target>
        </trans-unit>
        <trans-unit id="0b97f5ba300285bc33992abb7779519b897b7aa7" translate="yes" xml:space="preserve">
          <source>The session object &quot;indirect&quot; flag is set when the change is made, or</source>
          <target state="translated">变更时设置会话对象 &quot;间接 &quot;标志,或者是</target>
        </trans-unit>
        <trans-unit id="ffcb76dee8dc3b4cb20fe29908bbbe2ff2230909" translate="yes" xml:space="preserve">
          <source>The session object is configured with a set of tables to monitor changes on.</source>
          <target state="translated">会话对象配置了一组表来监控变化。</target>
        </trans-unit>
        <trans-unit id="0c67ff7ccfd533851dea34da8187939bbeae8841" translate="yes" xml:space="preserve">
          <source>The session object is deleted using a call to the &lt;a href=&quot;session/sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt; API function.</source>
          <target state="translated">可以使用对&lt;a href=&quot;session/sqlite3session_delete&quot;&gt;sqlite3session_delete（）&lt;/a&gt; API函数的调用来删除会话对象。</target>
        </trans-unit>
        <trans-unit id="b41c2d1dd25f0b9daf0304c7870c3eb7ae78b919" translate="yes" xml:space="preserve">
          <source>The session object therefore accumulates two types of records - those that consist of primary key values only (created when the user inserts a new record) and those that consist of the primary key values and the original values of other table columns (created when the users deletes or updates a record).</source>
          <target state="translated">因此,会话对象积累了两种类型的记录--仅由主键值组成的记录(当用户插入一条新记录时创建)和由主键值和其他表列的原始值组成的记录(当用户删除或更新一条记录时创建)。</target>
        </trans-unit>
        <trans-unit id="67b4d05a6aa852ba851b95d39158470c33cead0c" translate="yes" xml:space="preserve">
          <source>The session object will be used to create changesets for tables in database zDb, where zDb is either &quot;main&quot;, or &quot;temp&quot;, or the name of an attached database. It is not an error if database zDb is not attached to the database when the session object is created.</source>
          <target state="translated">会话对象将用于为数据库zDb中的表创建更改集,其中zDb是 &quot;main &quot;或 &quot;temp&quot;,或者是附加数据库的名称。如果在创建会话对象时,数据库zDb没有被连接到数据库,这并不是一个错误。</target>
        </trans-unit>
        <trans-unit id="45a8679117c7936fefc29c4e8b252b099d09917b" translate="yes" xml:space="preserve">
          <source>The sessions module never invokes an xOutput callback with the third parameter set to a value less than or equal to zero. Other than this, no guarantees are made as to the size of the chunks of data returned.</source>
          <target state="translated">会话模块从不调用第三个参数设置为小于或等于0的xOutput回调。除此之外,我们不保证返回的数据块的大小。</target>
        </trans-unit>
        <trans-unit id="a218d47a709906affb4f3ae717da9de3077b519d" translate="yes" xml:space="preserve">
          <source>The sessions module revolves around creating and manipulating changesets. A changeset is a blob of data that encodes a series of changes to a database. Each change in a changeset is one of the following:</source>
          <target state="translated">会话模块围绕着创建和操作变更集展开。一个变化集是一个数据块,它编码了一系列对数据库的变化。变更集中的每一个变化都是以下几种情况之一。</target>
        </trans-unit>
        <trans-unit id="d639d6bbcd88a2f2cd5339240f5d5c5de8f80432" translate="yes" xml:space="preserve">
          <source>The set X contains the index in aPgno of every entry in the current 32768-byte unit of the shm file that might possible be a solution to the FindFrame(P,M) function. Each of these entries must be checked separately to ensure that the aPgno value is P and that the frame number does not exceed M. The largest frame number that passes those two tests is the answer.</source>
          <target state="translated">集X包含了shm文件当前32768字节单位中每一个可能是FindFrame(P,M)函数解的条目在aPgno中的索引。每一个条目都必须单独检查,以确保aPgno的值是P,并且帧数不超过M,通过这两个测试的最大帧数就是答案。</target>
        </trans-unit>
        <trans-unit id="daeab809359987c0f17f57c78f38704f62041f7b" translate="yes" xml:space="preserve">
          <source>The set of</source>
          <target state="translated">这套</target>
        </trans-unit>
        <trans-unit id="df619f50e7143055665ccf4d69e938c1340f4737" translate="yes" xml:space="preserve">
          <source>The set of built-in auxiliary functions provided by FTS5 may be improved upon in the future.</source>
          <target state="translated">未来可能会对FTS5提供的一组内置辅助功能进行改进。</target>
        </trans-unit>
        <trans-unit id="a49341beec33b485301f8bafe6ae6c61c6f39915" translate="yes" xml:space="preserve">
          <source>The set of checklist items for release checklist is potentially updated for each release. The content and complete history of each release checklist are retained for the historical record.</source>
          <target state="translated">每次发布时,发布检查表的检查项目集都有可能更新。每份发布检查表的内容和完整的历史记录都会被保留下来,作为历史记录。</target>
        </trans-unit>
        <trans-unit id="0f5a66644e1d1f4b0f41c960d4f2f7a794b20868" translate="yes" xml:space="preserve">
          <source>The set of static mutexes may change from one SQLite release to the next. Applications that override the built-in mutex logic must be prepared to accommodate additional static mutexes.</source>
          <target state="translated">静态mutexes集可能会从一个SQLite版本改变到下一个版本。覆盖内置的mutex逻辑的应用程序必须准备好适应额外的静态mutexes。</target>
        </trans-unit>
        <trans-unit id="9b60f1982b5c4164ca917a617479f0aacfe46294" translate="yes" xml:space="preserve">
          <source>The shadow tables are ordinary SQLite data tables. You can query them directly if you like, though this unlikely to reveal anything particularly useful. And you can &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; or even &lt;a href=&quot;lang_droptable&quot;&gt;DROP&lt;/a&gt; the shadow tables, though doing so will corrupt your R*Tree index. So it is best to simply ignore the shadow tables. Recognize that they hold your R*Tree index information and let it go as that.</source>
          <target state="translated">影子表是普通的SQLite数据表。您可以根据需要直接查询它们，尽管这不可能揭示任何特别有用的东西。而且您可以&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;，&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;，&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;甚至是&lt;a href=&quot;lang_droptable&quot;&gt;DROP&lt;/a&gt;影子表，尽管这样做会破坏您的R * Tree索引。因此，最好只是忽略影子表。认识到他们拥有您的R * Tree索引信息，并就这样继续进行。</target>
        </trans-unit>
        <trans-unit id="7b89e4e1261efca1d668789aecafeceb06cf0045" translate="yes" xml:space="preserve">
          <source>The shared library filename passed to &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; may omit the filename suffix, and an appropriate architecture-dependent suffix (&quot;.so&quot;, &quot;.dylib&quot;, or &quot;.dll&quot;) will be added automatically.</source>
          <target state="translated">传递给&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;的共享库文件名可以省略文件名后缀，并且将自动添加适当的与体系结构相关的后缀（&amp;ldquo; .so&amp;rdquo;，&amp;ldquo;。dylib&amp;rdquo;或&amp;ldquo; .dll&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="683712ddb2de169a205df89a5ffe29d5c006c2b5" translate="yes" xml:space="preserve">
          <source>The shared-memory file contains no persistent content. The only purpose of the shared-memory file is to provide a block of shared memory for use by multiple processes all accessing the same database in WAL mode. If the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; is able to provide an alternative method for accessing shared memory, then that alternative method might be used rather than the shared-memory file. For example, if &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMA locking_mode&lt;/a&gt; is set to EXCLUSIVE (meaning that only one process is able to access the database file) then the shared memory will be allocated from heap rather than out of the shared-memory file, and the shared-memory file will never be created.</source>
          <target state="translated">共享内存文件不包含任何持久性内容。共享内存文件的唯一目的是提供一块共享内存，供所有以WAL模式访问同一数据库的多个进程使用。如果&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;能够提供一种访问共享内存的替代方法，则可以使用该替代方法而不是共享内存文件。例如，如果&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMAlocking_mode&lt;/a&gt;设置为EXCLUSIVE（意味着只有一个进程能够访问数据库文件），则共享内存将从堆中分配，而不是从共享内存文件中分配，并且共享内存文件将永远不会被创造。</target>
        </trans-unit>
        <trans-unit id="d84d71db4e9c7a1a18a467e4bbe2be0320c053f2" translate="yes" xml:space="preserve">
          <source>The shared-memory file has the same lifetime as its associated WAL file. The shared-memory file is created when the WAL file is created and is deleted when the WAL file is deleted. During WAL file recovery, the shared memory file is recreated from scratch based on the contents of the WAL file being recovered.</source>
          <target state="translated">共享内存文件与其关联的WAL文件具有相同的寿命。当创建WAL文件时,共享内存文件被创建,当删除WAL文件时,共享内存文件被删除。在WAL文件恢复过程中,共享内存文件会根据被恢复的WAL文件的内容从头开始重新创建。</target>
        </trans-unit>
        <trans-unit id="c6175d074e784d9fffd662056186d3e1dc1f4cc9" translate="yes" xml:space="preserve">
          <source>The shm does not contain any database content and is not required to recover the database following a crash. For that reason, the first client to connect to a quiescent database will normally truncate the shm file if it exists. Since the content of the shm file does not need to be preserved across a crash, the shm file is never fsync()-ed to disk. In fact, if there were a mechanism by which SQLite could tell the operating system to never persist the shm file to disk but always hold it in cache memory, SQLite would use that mechanism to avoid any unnecessary disk I/O associated with the shm file. However, no such mechanism exists in standard posix.</source>
          <target state="translated">shm不包含任何数据库内容,也不需要在崩溃后恢复数据库。因此,第一个连接到静止数据库的客户端通常会截断shm文件(如果它存在的话)。由于shm文件的内容不需要在崩溃时保存,所以shm文件永远不会被fsync()-ed到磁盘上。事实上,如果有一种机制可以让SQLite告诉操作系统永远不要将shm文件持久化到磁盘上,而总是将其保存在缓存中,那么SQLite就会使用这种机制来避免与shm文件相关的任何不必要的磁盘I/O。然而,在标准posix中不存在这样的机制。</target>
        </trans-unit>
        <trans-unit id="2ce5842569cd9ae6cb873fe122d925e98dfd9e57" translate="yes" xml:space="preserve">
          <source>The shm file consists of one or more hash tables, where each hash table is 32768 bytes in size. Except, a 136-byte header is carved out of the front of the very first hash table, so the first hash table is only 32632 bytes in size. The total size of the shm file is always a multiple of 32768. In most cases, the total size of the shm file is exactly 32768 bytes. The shm file only needs to grow beyond a single hash table if when the wal file grows very large (more than 4079 frames). Since the default &lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;automatic checkpoint threshold&lt;/a&gt; is 1000, WAL files rare reach the 4079 threshold needed to make the shm file grow.</source>
          <target state="translated">shm文件由一个或多个哈希表组成，其中每个哈希表的大小为32768字节。除了在第一个哈希表的开头雕刻了一个136字节的标头之外，因此第一个哈希表的大小仅为32632字节。 shm文件的总大小始终是32768的倍数。在大多数情况下，shm文件的总大小恰好是32768字节。如果wal文件变得非常大（超过4079帧），则shm文件仅需要增长到单个哈希表之外。由于默认的&lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;自动检查点阈&lt;/a&gt;值为1000，因此WAL文件很少达到使shm文件增长所需的4079阈值。</target>
        </trans-unit>
        <trans-unit id="0d8774149ef596e36906cd1fe56afff10a697841" translate="yes" xml:space="preserve">
          <source>The signature of the xAccess method has been modified to return an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; and to store its output into an integer pointed to by a parameter, rather than returning the output directly. This change allows the xAccess() method to report failures. In association with this signature change, a new extended error code &lt;a href=&quot;rescode#ioerr_access&quot;&gt;SQLITE_IOERR_ACCESS&lt;/a&gt; has been added.</source>
          <target state="translated">已修改xAccess方法的签名，以返回&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;并将其输出存储到参数指向的整数中，而不是直接返回输出。此更改使xAccess（）方法可以报告失败。与此签名更改相关联，添加了新的扩展错误代码&lt;a href=&quot;rescode#ioerr_access&quot;&gt;SQLITE_IOERR_ACCESS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="73da15d1378e7e4cecf6c05a9921a5f1b3117f3b" translate="yes" xml:space="preserve">
          <source>The signature of the xCheckReservedLock method on &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; has been modified so that it returns an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; and stores its boolean result into an integer pointed to by a parameter. In association with this change, a new extended error code &lt;a href=&quot;rescode#ioerr_checkreservedlock&quot;&gt;SQLITE_IOERR_CHECKRESERVEDLOCK&lt;/a&gt; has been added.</source>
          <target state="translated">&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;上xCheckReservedLock方法的签名已被修改，以便它返回&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;并将其布尔结果存储到参数所指向的整数中。与此更改关联，添加了新的扩展错误代码&lt;a href=&quot;rescode#ioerr_checkreservedlock&quot;&gt;SQLITE_IOERR_CHECKRESERVEDLOCK&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23da313c5318bbaf1e11638c6787139e74ceff62" translate="yes" xml:space="preserve">
          <source>The simple, modular design of SQLite makes it a good platform for prototyping new, experimental database language features or ideas.</source>
          <target state="translated">SQLite简单、模块化的设计使其成为一个很好的平台,可以对新的、实验性的数据库语言功能或想法进行原型设计。</target>
        </trans-unit>
        <trans-unit id="2d0de7ad7a0838db1beb185b37e3f4659d20a947" translate="yes" xml:space="preserve">
          <source>The single row of result-set data created by evaluating the aggregate and non-aggregate expressions in the result-set forms the result of an aggregate query without a GROUP BY clause. An aggregate query without a GROUP BY clause always returns exactly one row of data, even if there are zero rows of input data.</source>
          <target state="translated">通过评估结果集中的聚合和非聚合表达式创建的单行结果集数据,形成了没有GROUP BY子句的聚合查询的结果。没有GROUP BY子句的聚合查询总是只返回一行数据,即使输入数据的行数为零。</target>
        </trans-unit>
        <trans-unit id="fee8fe6df1809775fcd62fdf9f110bcf759d94a6" translate="yes" xml:space="preserve">
          <source>The six streaming API xxx_strm() functions serve similar purposes to the corresponding non-streaming API functions:</source>
          <target state="translated">六个流式API xxx_strm()函数的作用与相应的非流式API函数类似。</target>
        </trans-unit>
        <trans-unit id="af903c0dcc364c9d11abbe191c3960a1c5d014f5" translate="yes" xml:space="preserve">
          <source>The sixth argument to sqlite3_bind_text64() must be one of &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; to specify the encoding of the text in the third parameter. If the sixth argument to sqlite3_bind_text64() is not one of the allowed values shown above, or if the text encoding is different from the encoding specified by the sixth parameter, then the behavior is undefined.</source>
          <target state="translated">sqlite3_bind_text64（）的第六个参数必须是&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;之一，以在第三个参数中指定文本的编码。如果sqlite3_bind_text64（）的第六个参数不是上面显示的允许值之一，或者文本编码与第六个参数指定的编码不同，则该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="3a920902ff183846916ffe84129516653c512659" translate="yes" xml:space="preserve">
          <source>The sixth argument to sqlite3_bind_text64() must be one of &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; to specify the encoding of the text in the third parameter. If the sixth argument to sqlite3_bind_text64() is not one of the allowed values shown above, or if the text encoding is different from the encoding specified by the sixth parameter, then the behavior is undefined.</source>
          <target state="translated">sqlite3_bind_text64（）的第六个参数必须是&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;，&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;，&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;或&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;之一，以在第三个参数中指定文本的编码。如果sqlite3_bind_text64（）的第六个参数不是上面显示的允许值之一，或者文本编码与第六个参数指定的编码不同，则该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="e8b06ccbdc8c379a9a470f7c185a0247a80f8e2b" translate="yes" xml:space="preserve">
          <source>The sixth, seventh and eighth parameters passed to the three &quot;sqlite3_create_function*&quot; functions, xFunc, xStep and xFinal, are pointers to C-language functions that implement the SQL function or aggregate. A scalar SQL function requires an implementation of the xFunc callback only; NULL pointers must be passed as the xStep and xFinal parameters. An aggregate SQL function requires an implementation of xStep and xFinal and NULL pointer must be passed for xFunc. To delete an existing SQL function or aggregate, pass NULL pointers for all three function callbacks.</source>
          <target state="translated">传递给三个 &quot;sqlite3_create_function*&quot;函数xFunc、xStep和xFinal的第六、第七和第八个参数是实现SQL函数或集合的C语言函数的指针。一个标量SQL函数只需要实现xFunc回调,NULL指针必须作为xStep和xFinal参数传递。聚合SQL函数需要xStep和xFinal的实现,必须为xFunc传递NULL指针。要删除一个现有的SQL函数或聚合函数,必须为这三个函数的回调传递NULL指针。</target>
        </trans-unit>
        <trans-unit id="5a1e0ca7d22b49ccdf57dfbe9e13e610f7e7488a" translate="yes" xml:space="preserve">
          <source>The sixth, seventh, eighth and ninth parameters (xStep, xFinal, xValue and xInverse) passed to sqlite3_create_window_function are pointers to C-language callbacks that implement the new function. xStep and xFinal must both be non-NULL. xValue and xInverse may either both be NULL, in which case a regular aggregate function is created, or must both be non-NULL, in which case the new function may be used as either an aggregate or aggregate window function. More details regarding the implementation of aggregate window functions are &lt;a href=&quot;../windowfunctions#udfwinfunc&quot;&gt;available here&lt;/a&gt;.</source>
          <target state="translated">传递给sqlite3_create_window_function的第六，第七，第八和第九个参数（xStep，xFinal，xValue和xInverse）是指向实现新功能的C语言回调的指针。 xStep和xFinal必须都为非NULL。 xValue和xInverse都可以为NULL（在这种情况下会创建常规的聚合函数），或者必须都为非NULL（在这种情况下，新函数可以用作聚合或聚​​合窗口函数）。有关聚合窗口功能实现的更多详细信息，&lt;a href=&quot;../windowfunctions#udfwinfunc&quot;&gt;请参见此处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f70d86715eabcca8a7d61d2f6e68b2fc4d6a57e" translate="yes" xml:space="preserve">
          <source>The sixth, seventh, eighth and ninth parameters (xStep, xFinal, xValue and xInverse) passed to sqlite3_create_window_function are pointers to C-language callbacks that implement the new function. xStep and xFinal must both be non-NULL. xValue and xInverse may either both be NULL, in which case a regular aggregate function is created, or must both be non-NULL, in which case the new function may be used as either an aggregate or aggregate window function. More details regarding the implementation of aggregate window functions are &lt;a href=&quot;windowfunctions#udfwinfunc&quot;&gt;available here&lt;/a&gt;.</source>
          <target state="translated">传递给sqlite3_create_window_function的第六，第七，第八和第九个参数（xStep，xFinal，xValue和xInverse）是指向实现新功能的C语言回调的指针。 xStep和xFinal必须都为非NULL。 xValue和xInverse都可以为NULL（在这种情况下会创建常规的聚合函数），或者必须都为非NULL（在这种情况下，新函数可以用作聚合或聚​​合窗口函数）。有关聚合窗口功能实现的更多详细信息，&lt;a href=&quot;windowfunctions#udfwinfunc&quot;&gt;请参见此处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="650196bb22cf5bf05d1563df9b31bf781c3e9a6d" translate="yes" xml:space="preserve">
          <source>The size of the blobs in the test data affects performance. The filesystem will generally be faster for larger blobs, since the overhead of open() and close() is amortized over more bytes of I/O, whereas the database will be more efficient in both speed and space as the average blob size decreases.</source>
          <target state="translated">测试数据中的 blobs 大小会影响性能。一般来说,文件系统对于较大的blob会更快,因为open()和close()的开销是通过更多的I/O字节来分摊的,而数据库随着blob平均大小的减小,在速度和空间上都会更有效率。</target>
        </trans-unit>
        <trans-unit id="71ba6b5b378d657456a5945d2ff20a780b1b14d4" translate="yes" xml:space="preserve">
          <source>The size of the lookaside memory pool has a global default value but can also be configured on a connection-by-connection basis. To change the default size of the lookaside memory pool at compile-time, use the &lt;a href=&quot;compile#default_lookaside&quot;&gt;-DSQLITE_DEFAULT_LOOKASIDE=&lt;i&gt;SZ,N&lt;/i&gt;&lt;/a&gt; option. To change the default size of the lookaside memory pool at start-time, use the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface:</source>
          <target state="translated">后备内存池的大小具有全局默认值，但也可以基于逐个连接进行配置。要在编译时更改后备内存池的默认大小，请使用&lt;a href=&quot;compile#default_lookaside&quot;&gt;-DSQLITE_DEFAULT_LOOKASIDE = &lt;i&gt;SZ，N&lt;/i&gt;&lt;/a&gt;选项。要在启动时更改后备内存池的默认大小，请使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;接口：</target>
        </trans-unit>
        <trans-unit id="7032e0044fe8cbf0ccd0392512f38ee2b17ffc25" translate="yes" xml:space="preserve">
          <source>The size of the matching term in bytes.</source>
          <target state="translated">匹配项的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="481f99d28cac0daa50062e9ad3a05601840366c0" translate="yes" xml:space="preserve">
          <source>The size of the memory-mapped I/O region cannot be changed while the memory-mapped I/O region is in active use, to avoid unmapping memory out from under running SQL statements. For this reason, the mmap_size pragma may be a no-op if the prior mmap_size is non-zero and there are other SQL statements running concurrently on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">内存映射的I / O区域处于活动状态时，不能更改内存映射的I / O区域的大小，以避免在正在运行的SQL语句中取消内存的映射。因此，如果先前的mmap_size不为零，并且在同一&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;上同时运行其他SQL语句，则mmap_size编译指示可能为空。</target>
        </trans-unit>
        <trans-unit id="19c67c781984d7843a725bf421c45281605af01e" translate="yes" xml:space="preserve">
          <source>The snippet function first attempts to find a fragment of text consisting of</source>
          <target state="translated">代码段函数首先尝试查找由以下内容组成的文本片段</target>
        </trans-unit>
        <trans-unit id="54b3f9fdd628ef57cd97424e1a01116d0ba15ccd" translate="yes" xml:space="preserve">
          <source>The snippet function is used to create formatted fragments of document text for display as part of a full-text query results report. The snippet function may be passed between one and six arguments, as follows:</source>
          <target state="translated">snippet函数用于创建格式化的文档文本片段,以便作为全文查询结果报告的一部分显示。可以通过一个到六个参数来传递snippet函数,如下所示:</target>
        </trans-unit>
        <trans-unit id="25ab90403f978d997e2573cced370b12d71d602c" translate="yes" xml:space="preserve">
          <source>The snippet() function is similar to highlight(), except that instead of returning entire column values, it automatically selects and extracts a short fragment of document text to process and return. The snippet() function must be passed five parameters following the table name argument:</source>
          <target state="translated">snippet()函数类似于highlight(),不同的是,它不是返回整个列的值,而是自动选择和提取文档文本的一个短片段来处理和返回。snippet()函数必须在表名参数后传递五个参数。</target>
        </trans-unit>
        <trans-unit id="650db23255aac8aa4103c6f6d9992ba8c2854051" translate="yes" xml:space="preserve">
          <source>The soft heap limit is &quot;soft&quot; in this sense: If SQLite is not able to free up enough auxiliary memory to stay below the limit, it goes ahead and allocates the extra memory and exceeds its limit. This occurs under the theory that it is better to use additional memory than to fail outright.</source>
          <target state="translated">软堆限制在这个意义上是 &quot;软 &quot;的:如果SQLite无法释放出足够的辅助内存,无法保持在限额以下,它就会去分配额外的内存,并超过其限额。这种情况发生的理论是,使用额外的内存比直接失败要好。</target>
        </trans-unit>
        <trans-unit id="f259c7b18142819d8b2454c94e82cad365d3cfbd" translate="yes" xml:space="preserve">
          <source>The soft heap limit is not enforced in the current implementation if one or more of following conditions are true:</source>
          <target state="translated">如果以下一个或多个条件为真,软堆限制在当前的实施中不会被执行。</target>
        </trans-unit>
        <trans-unit id="62f643dbe59889b37bb6ee27203ce861b75e4df1" translate="yes" xml:space="preserve">
          <source>The soft heap limit is set to zero.</source>
          <target state="translated">软堆限制设置为零。</target>
        </trans-unit>
        <trans-unit id="1e9f9417ca080fbcc56641af6510e79f88f545c2" translate="yes" xml:space="preserve">
          <source>The soft heap limit may not be greater than the hard heap limit. If the hard heap limit is enabled and if sqlite3_soft_heap_limit(N) is invoked with a value of N that is greater than the hard heap limit, the the soft heap limit is set to the value of the hard heap limit. The soft heap limit is automatically enabled whenever the hard heap limit is enabled. When sqlite3_hard_heap_limit64(N) is invoked and the soft heap limit is outside the range of 1..N, then the soft heap limit is set to N. Invoking sqlite3_soft_heap_limit64(0) when the hard heap limit is enabled makes the soft heap limit equal to the hard heap limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84963983acb45095ae249428915953ba1875b5f1" translate="yes" xml:space="preserve">
          <source>The solution was computed in less than 300 milliseconds on a modern workstation.</source>
          <target state="translated">在现代工作站上,该解决方案的计算时间不到300毫秒。</target>
        </trans-unit>
        <trans-unit id="d8fc439428a4b57b8a635dfdc3bc6c9e9458a598" translate="yes" xml:space="preserve">
          <source>The solver works by adding new entries to the &quot;x&quot; recursive table. Given prior entries, the recursive-select tries to fill in a single new position with all values between 1 and 9 that actually work in that position. The complicated &quot;NOT EXISTS&quot; subquery is the magic that figures out whether or not each candidate &quot;s&quot; string is a valid sudoku puzzle or not.</source>
          <target state="translated">求解器通过向 &quot;x &quot;递归表添加新条目来工作。给定先前的条目,递归选择试图用1到9之间的所有值来填补一个新的位置,而这些值实际上是在这个位置上工作的。复杂的 &quot;NOT EXISTS &quot;子查询是计算出每个候选 &quot;s &quot;字符串是否为有效数独谜题的法宝。</target>
        </trans-unit>
        <trans-unit id="a81e5007b5735cbaaaf41fe92b085a6bb28859ca" translate="yes" xml:space="preserve">
          <source>The sorter can use auxiliary helper threads to increase real-time response. This feature is off by default and may be enabled using the &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; command or the &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; compile-time option.</source>
          <target state="translated">排序器可以使用辅助帮助器线程来增加实时响应。此功能默认情况下处于关闭状态，可以使用&lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA线程&lt;/a&gt;命令或&lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt;编译时选项启用。</target>
        </trans-unit>
        <trans-unit id="f3082f533e58c712999cbf940673f567d8a29017" translate="yes" xml:space="preserve">
          <source>The soundex(X) function returns a string that is the soundex encoding of the string X. The string &quot;?000&quot; is returned if the argument is NULL or contains no ASCII alphabetic characters. This function is omitted from SQLite by default. It is only available if the &lt;a href=&quot;compile#soundex&quot;&gt;SQLITE_SOUNDEX&lt;/a&gt; compile-time option is used when SQLite is built.</source>
          <target state="translated">soundex（X）函数返回的字符串是字符串X的soundex编码。如果参数为NULL或不包含ASCII字母字符，则返回字符串&amp;ldquo;？000&amp;rdquo;。默认情况下，SQLite会省略此功能。仅当构建SQLite时使用&lt;a href=&quot;compile#soundex&quot;&gt;SQLITE_SOUNDEX&lt;/a&gt;编译时选项时，此选项才可用。</target>
        </trans-unit>
        <trans-unit id="9611e60fec986c004f40bb3986af444fd02497aa" translate="yes" xml:space="preserve">
          <source>The source &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; may be used by the application for other purposes while a backup operation is underway or being initialized. If SQLite is compiled and configured to support threadsafe database connections, then the source database connection may be used concurrently from within other threads.</source>
          <target state="translated">在备份操作正在进行或初始化时，应用程序可以将源&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;用于其他目的。如果将SQLite编译并配置为支持线程安全数据库连接，则可以从其他线程中同时使用源数据库连接。</target>
        </trans-unit>
        <trans-unit id="d46770cf519d64fb4869e93bb4ebad2a0d214ebb" translate="yes" xml:space="preserve">
          <source>The source &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; may be used by the application for other purposes while a backup operation is underway or being initialized. If SQLite is compiled and configured to support threadsafe database connections, then the source database connection may be used concurrently from within other threads.</source>
          <target state="translated">在备份操作正在进行或初始化时，应用程序可以将源&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;用于其他目的。如果将SQLite编译并配置为支持线程安全数据库连接，则可以从其他线程中同时使用源数据库连接。</target>
        </trans-unit>
        <trans-unit id="cb98bce78cf336a453aacfd68f1f2a70ccf1bb9e" translate="yes" xml:space="preserve">
          <source>The source code files for other SQL database engines typically begin with a comment describing your legal rights to view and copy that file. The SQLite source code contains no license since it is not governed by copyright. Instead of a license, the SQLite source code offers a blessing:</source>
          <target state="translated">其他SQL数据库引擎的源代码文件通常以注释开头,说明你查看和复制该文件的合法权利。SQLite源代码不包含许可证,因为它不受版权的约束。SQLite源代码提供的不是许可证,而是祝福。</target>
        </trans-unit>
        <trans-unit id="b230daf41ab11e7921fa2a959263c09c6fe7e609" translate="yes" xml:space="preserve">
          <source>The source code for Geopoly is included in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; but is not included in the library unless the &lt;a href=&quot;compile#enable_geopoly&quot;&gt;-DSQLITE_ENABLE_GEOPOLY&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">Geopoly的源代码包含在&lt;a href=&quot;amalgamation&quot;&gt;合并中，&lt;/a&gt;但没有包含在库中，除非使用&lt;a href=&quot;compile#enable_geopoly&quot;&gt;-DSQLITE_ENABLE_GEOPOLY&lt;/a&gt;编译时选项。</target>
        </trans-unit>
        <trans-unit id="9ce563d47e369284dcc9eb90d209f5fe50c9d87d" translate="yes" xml:space="preserve">
          <source>The source code for SQLite is in the public domain. No claim of copyright is made on any part of the core source code. (The documentation and test code is a different matter - some sections of documentation and test logic are governed by open-source licenses.) All contributors to the SQLite core software have signed affidavits specifically disavowing any copyright interest in the code. This means that anybody is able to legally do anything they want with the SQLite source code.</source>
          <target state="translated">SQLite的源代码是在公共领域。没有对核心源代码的任何部分提出版权要求。文档和测试代码是另一回事--文档和测试逻辑的某些部分受开源许可证的约束)。SQLite核心软件的所有贡献者都签署了宣誓书,明确表示不承认代码中的任何版权利益。这意味着任何人都可以合法地对SQLite源代码做任何他们想做的事情。</target>
        </trans-unit>
        <trans-unit id="1cfec4458134c689073b56a3f124a05cfee319a4" translate="yes" xml:space="preserve">
          <source>The source code in public SQLite releases uses unix line endings (ASCII code 10: &quot;newline&quot; only, NL) and spaces instead of tabs. If you will be changing the line ending to windows-style line endings (ASCII codes 13, 10: &quot;carriage-return&quot; and &quot;newline&quot;; CR-NL) or if you will be changing space indents into tab indents, &lt;b&gt;make that change now&lt;/b&gt; before you check in the baseline. The merging process will only work well if the differences between the public and the private branches are minimal. If every single line of the source file is changed in the private branch because you changed from NL to CR-NL line endings, then the merge steps will not work correctly.</source>
          <target state="translated">公共SQLite版本中的源代码使用unix行尾（ASCII代码10：仅&amp;ldquo; newline&amp;rdquo;，NL）和空格而不是制表符。如果要将行尾更改为Windows样式的行尾（ASCII代码13、10：&amp;ldquo; carriage-return&amp;rdquo;和&amp;ldquo; newline&amp;rdquo;； CR-NL），或者要将空格缩进更改为制表符缩进，请&lt;b&gt;进行更改现在，&lt;/b&gt;在检查基线之前。只有在公共部门和私人部门之间的差异很小的情况下，合并过程才能很好地工作。如果源文件的每一行都在私人分支中更改（因为您从NL更改为CR-NL行尾），则合并步骤将无法正常进行。</target>
        </trans-unit>
        <trans-unit id="c71fe30151d8d1ffe822e83fe610e421f8822069" translate="yes" xml:space="preserve">
          <source>The source code module that implements the spellfix1 virtual table also implements several SQL functions that might be useful to applications that employ spellfix1 or for testing or diagnostic work while developing applications that use spellfix1. The following auxiliary functions are available:</source>
          <target state="translated">实现spellfix1虚拟表的源码模块还实现了几个SQL函数,这些函数可能对采用spellfix1的应用程序或开发使用spellfix1的应用程序时的测试或诊断工作有用。以下是可用的辅助函数。</target>
        </trans-unit>
        <trans-unit id="06e0d7a5506cbf178b35ec85914ad01a3f38017c" translate="yes" xml:space="preserve">
          <source>The source code to SQLite is designed to be readable and accessible to the average programmer. All procedures and data structures and many automatic variables are carefully commented with useful information about what they do. Boilerplate commenting is omitted.</source>
          <target state="translated">SQLite的源代码被设计成对普通程序员来说是可读和可访问的。所有的程序和数据结构以及许多自动变量都有仔细的注释,并提供了它们的有用信息。锅炉板的注释被省略了。</target>
        </trans-unit>
        <trans-unit id="042c70a1cba19758906aae3ec84cad7dc8c53383" translate="yes" xml:space="preserve">
          <source>The source code to the SQLite R*Tree module is included as part of the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; but is disabled by default. To enable the R*Tree module, simply compile with the &lt;a href=&quot;compile#enable_rtree&quot;&gt;SQLITE_ENABLE_RTREE&lt;/a&gt; C-preprocessor macro defined. With many compilers, this is accomplished by adding the option &quot;-DSQLITE_ENABLE_RTREE=1&quot; to the compiler command-line.</source>
          <target state="translated">SQLite R * Tree模块的源代码包含在&lt;a href=&quot;amalgamation&quot;&gt;合并中，&lt;/a&gt;但默认情况下处于禁用状态。要启用R * Tree模块，只需使用定义的&lt;a href=&quot;compile#enable_rtree&quot;&gt;SQLITE_ENABLE_RTREE&lt;/a&gt; C预处理器宏进行编译。对于许多编译器，这是通过在编译器命令行中添加选项&amp;ldquo; -DSQLITE_ENABLE_RTREE = 1&amp;rdquo;来实现的。</target>
        </trans-unit>
        <trans-unit id="a40cbeb8ac52569bca99e948856ab4db846ed02b" translate="yes" xml:space="preserve">
          <source>The source code to the bytecode engine is in the &lt;a href=&quot;http://www.sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt; source file. The &lt;a href=&quot;opcode#codes&quot;&gt;opcode definitions&lt;/a&gt; in this document are derived from comments in that source file. The source code comments are the canonical source of information about the bytecode engine. When in doubt, refer to the source code.</source>
          <target state="translated">字节码引擎的源代码位于&lt;a href=&quot;http://www.sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt;源文件中。本文档中的&lt;a href=&quot;opcode#codes&quot;&gt;操作码定义&lt;/a&gt;源自该源文件中的注释。源代码注释是有关字节码引擎的规范信息源。如有疑问，请参考源代码。</target>
        </trans-unit>
        <trans-unit id="013177e363c21284dd8426d7c41bb413bf325a0a" translate="yes" xml:space="preserve">
          <source>The source code to the software that runs the checklists is stored in its own Fossil repository at &lt;a href=&quot;https://www.sqlite.org/checklistapp&quot;&gt;https://www.sqlite.org/checklistapp&lt;/a&gt;.</source>
          <target state="translated">运行清单的软件的源代码存储在其自己的Fossil信息库中，&lt;a href=&quot;https://www.sqlite.org/checklistapp&quot;&gt;网址&lt;/a&gt;为https://www.sqlite.org/checklistapp。</target>
        </trans-unit>
        <trans-unit id="79b8e8d26e2fd4c36bb8b15bd366cedd02031771" translate="yes" xml:space="preserve">
          <source>The source code to the sqlite3 command line interface is in a single file named &quot;shell.c&quot;. The shell.c source file is generated from other sources, but most of the code for shell.c can be found in &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src/shell.c.in&lt;/a&gt;. (Regenerate shell.c by typing &quot;make shell.c&quot; from the canonical source tree.) &lt;a href=&quot;howtocompile&quot;&gt;Compile&lt;/a&gt; the shell.c file (together with the &lt;a href=&quot;amalgamation&quot;&gt;sqlite3 library source code&lt;/a&gt;) to generate the executable. For example:</source>
          <target state="translated">sqlite3命令行界面的源代码位于一个名为&amp;ldquo; shell.c&amp;rdquo;的文件中。shell.c源文件是从其他来源生成的，但是大多数shell.c代码可以在&lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src / shell.c.in中&lt;/a&gt;找到。（通过从规范的源代码树中键入&amp;ldquo; make shell.c&amp;rdquo;来重新生成shell.c。）&lt;a href=&quot;howtocompile&quot;&gt;编译&lt;/a&gt; shell.c文件（与&lt;a href=&quot;amalgamation&quot;&gt;sqlite3库源代码一起&lt;/a&gt;）以生成可执行文件。例如：</target>
        </trans-unit>
        <trans-unit id="3baebed042eebfba10dcbc501e7f4785bd1f6d07" translate="yes" xml:space="preserve">
          <source>The source file and entry point are named for &quot;unionvtab&quot; instead of &quot;swarmvtab&quot;. Unionvtab is a &lt;a href=&quot;unionvtab&quot;&gt;separately documented&lt;/a&gt; virtual table that is bundled with swarmvtab.</source>
          <target state="translated">源文件和入口点以&amp;ldquo; unionvtab&amp;rdquo;而不是&amp;ldquo; swarmvtab&amp;rdquo;命名。Unionvtab是&lt;a href=&quot;unionvtab&quot;&gt;单独记录的&lt;/a&gt;虚拟表，与swarmvtab捆绑在一起。</target>
        </trans-unit>
        <trans-unit id="f3fba365763538ecbddb6c57bd7009fd058f9084" translate="yes" xml:space="preserve">
          <source>The special &quot;:memory:&quot; filename also works when using &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt;. For example:</source>
          <target state="translated">当使用&lt;a href=&quot;uri&quot;&gt;URI文件名&lt;/a&gt;时，特殊的&amp;ldquo;：memory：&amp;rdquo;文件名也可以使用。例如：</target>
        </trans-unit>
        <trans-unit id="e94ff833d41c9d30c15767ac9e7aeb85daf442aa" translate="yes" xml:space="preserve">
          <source>The special UPSERT processing happens only for uniqueness constraint on the table that is receiving the INSERT. A &quot;uniqueness constraint&quot; is an explicit UNIQUE or PRIMARY KEY constraint within the CREATE TABLE statement, or a &lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;unique index&lt;/a&gt;. UPSERT does not intervene for failed NOT NULL or foreign key constraints or for constraints that are implemented using triggers.</source>
          <target state="translated">特殊的UPSERT处理仅针对接收INSERT的表上的唯一性约束而发生。&amp;ldquo;唯一性约束&amp;rdquo;是CREATE TABLE语句中的显式UNIQUE或PRIMARY KEY约束，或者是&lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;唯一索引&lt;/a&gt;。UPSERT不会针对失败的NOT NULL或外键约束或使用触发器实现的约束进行干预。</target>
        </trans-unit>
        <trans-unit id="2e94e3f68bdf7fc07fc0dcd878c089797a3fe9a2" translate="yes" xml:space="preserve">
          <source>The special filename &quot;:memory:&quot; can be used anywhere that a database filename is permitted. For example, it can be used as the</source>
          <target state="translated">特殊的文件名&quot;:memory:&quot;可以用在任何允许数据库文件名的地方。例如,它可以被用作</target>
        </trans-unit>
        <trans-unit id="dff68709141a31a267598fa549dc38cfbd61c946" translate="yes" xml:space="preserve">
          <source>The special processing for opening ZIP archives is a trick of the command-line shell, not the core SQLite library. So if you want to open a ZIP archive as a database in your application, you will need to activate the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; module then run an appropriate &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29bca994e11cb6f841a93aac5cdb8471376e38df" translate="yes" xml:space="preserve">
          <source>The specified column of row iRow contains a value that is not a TEXT or BLOB value,</source>
          <target state="translated">行iRow的指定列包含一个不是TEXT或BLOB的值。</target>
        </trans-unit>
        <trans-unit id="06e48e6df6f51c35512fa45acc8a0e8a634c95f8" translate="yes" xml:space="preserve">
          <source>The speedtest1.c program is updated from time to time as the SQLite developers' understanding of what constitutes &quot;typical&quot; usage evolves.</source>
          <target state="translated">speedtest1.c程序会随着SQLite开发人员对 &quot;典型 &quot;用法的理解而不时更新。</target>
        </trans-unit>
        <trans-unit id="5446f248e6916745d646dc3f5e88e893b3ad00cc" translate="yes" xml:space="preserve">
          <source>The speedtest1.c workload that is being measured tries to be representative of a wide range of typical uses of SQLite. But every application is different. The speedtest1.c workload might not be a good proxy for the kinds of activities performed by some applications. The SQLite developers are constantly working to improve the speedtest1.c program, to make it a better proxy for actual SQLite usage. Community feedback is welcomed.</source>
          <target state="translated">正在测量的 speedtest1.c 工作负载试图代表 SQLite 的各种典型用途。但每个应用程序都是不同的。speedtest1.c 工作负载可能无法很好地代表某些应用程序所执行的活动类型。SQLite 开发人员正在不断努力改进 speedtest1.c 程序,使其更好地代表实际 SQLite 使用情况。欢迎社区的反馈意见。</target>
        </trans-unit>
        <trans-unit id="92167de554e681259504f6e2f3edf942b7026bd6" translate="yes" xml:space="preserve">
          <source>The spellfix1 virtual table creates a single shadow table named &quot;%_vocab&quot; (where the % is replaced by the name of the virtual table; Ex: &quot;demo_vocab&quot; for the &quot;demo&quot; virtual table). the shadow table contains the following columns:</source>
          <target state="translated">spellfix1虚拟表创建了一个名为&quot;%_vocab &quot;的影子表(其中%被虚拟表的名称所代替;Ex:&quot;demo_vocab &quot;代表 &quot;demo &quot;虚拟表),影子表包含以下列。</target>
        </trans-unit>
        <trans-unit id="f9097157fe13f14b48b89617ee87aed62da83c73" translate="yes" xml:space="preserve">
          <source>The spellfix1 virtual table uses editdist3 if the &quot;edit_cost_table=TABLE&quot; option is specified as an argument when the spellfix1 virtual table is created. But editdist3 can also be tested directly using the built-in &quot;editdist3()&quot; SQL function. The editdist3() SQL function has 3 forms:</source>
          <target state="translated">如果在创建spellfix1虚拟表时指定 &quot;edit_cost_table=TABLE &quot;选项作为参数,那么spellfix1虚拟表就会使用editdist3。但是editdist3也可以直接使用内置的 &quot;editdist3()&quot;SQL函数进行测试。editdist3()SQL函数有3种形式。</target>
        </trans-unit>
        <trans-unit id="e416e23f51996e4d87d84d45407db4bd482280e4" translate="yes" xml:space="preserve">
          <source>The sqlar_compress(X) function attempts to compress a copy of the string or blob X using the &lt;a href=&quot;https://zlib.net/&quot;&gt;Default&lt;/a&gt; algorithm and returns the result as a blob. If the input X is incompressible, then a copy of X is returned. This routine is used when inserting content into an SQLite Archive.</source>
          <target state="translated">sqlar_compress（X）函数尝试使用&lt;a href=&quot;https://zlib.net/&quot;&gt;Default&lt;/a&gt;算法压缩字符串或Blob X的副本，并将结果作为Blob返回。如果输入X是不可压缩的，则返回X的副本。在将内容插入SQLite存档时使用此例程。</target>
        </trans-unit>
        <trans-unit id="0c132e268d7082089985d58b1716bee78c9b6c72" translate="yes" xml:space="preserve">
          <source>The sqlar_uncompress(Y,SZ) function will undo the compression accomplished by sqlar_compress(X). The Y parameter is the compressed content (the output from a prior call to sqlar_compress()) and SZ is the original uncompressed size of the input X that generated Y. If SZ is less than or equal to the size of Y, that indicates that no compression occurred, and so sqlar_uncompress(Y,SZ) returns a copy of Y. Otherwise, sqlar_uncompress(Y,SZ) runs the Inflate algorithm on Y to uncompress it and restore it to its original form and returns the uncompressed content. This routine is used when extracting content from an SQLite Archive.</source>
          <target state="translated">sqlar_uncompress(Y,SZ)函数将撤销由sqlar_compress(X)完成的压缩。如果SZ小于或等于Y的大小,则表明没有发生压缩,所以sqlar_uncompress(Y,SZ)返回Y的副本。否则,sqlar_uncompress(Y,SZ)会在Y上运行Inflate算法来解压缩,并将其恢复到原始形式,然后返回未压缩的内容。这个例程在从SQLite Archive中提取内容时使用。</target>
        </trans-unit>
        <trans-unit id="9894bd2027e1ec7fe1defc073eb794af8cfcddba" translate="yes" xml:space="preserve">
          <source>The sqldiff.exe utility does not (currently) display differences in &lt;a href=&quot;lang_createtrigger&quot;&gt;TRIGGERs&lt;/a&gt; or &lt;a href=&quot;lang_createview&quot;&gt;VIEWs&lt;/a&gt;.</source>
          <target state="translated">所述sqldiff.exe实用程序执行中不（目前）显示差异&lt;a href=&quot;lang_createtrigger&quot;&gt;触发器&lt;/a&gt;或&lt;a href=&quot;lang_createview&quot;&gt;意见&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1eec35831f2ddb18882fbe495fb78b6e88f27f70" translate="yes" xml:space="preserve">
          <source>The sqldiff.exe utility is unable to compute differences for rowid tables for which the rowid is inaccessible. An example of a table with an inaccessible rowid is:</source>
          <target state="translated">sqldiff.exe 工具无法计算无法访问 rowid 的表的差异。下面是一个无法访问的表的例子。</target>
        </trans-unit>
        <trans-unit id="199f0fae6d132ab01eeef495a83df7f5456338b1" translate="yes" xml:space="preserve">
          <source>The sqldiff.exe utility works by finding rows in the source and destination that are logical &quot;pairs&quot;. The default behavior is to treat two rows as pairs if they are in tables with the same name and they have the same &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, or in the case of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table if they have the same &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;. Any differences in the content of paired rows are output as UPDATEs. Rows in the source database that could not be paired are output as DELETEs. Rows in the destination database that could not be paired are output as INSERTs.</source>
          <target state="translated">sqldiff.exe实用程序通过在源和目标中查找逻辑&amp;ldquo;对&amp;rdquo;的行来工作。默认行为是，如果两行位于相同名称的表中且具有相同的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;，则将它们视为对；如果为&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表，则将它们具有相同的&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;视为一对。成对行内容的任何差异都将作为UPDATE输出。源数据库中无法配对的行将作为DELETE输出。目标数据库中无法配对的行将作为INSERT输出。</target>
        </trans-unit>
        <trans-unit id="5a94a70315a765a01576195e900e88922987242a" translate="yes" xml:space="preserve">
          <source>The sqlite3 program is able to show the results of a query in 14 different formats:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a33930cce71afaf2bac4391a7d92f2102fe6799" translate="yes" xml:space="preserve">
          <source>The sqlite3 program is able to show the results of a query in eight different formats: &quot;csv&quot;, &quot;column&quot;, &quot;html&quot;, &quot;insert&quot;, &quot;line&quot;, &quot;list&quot;, &quot;quote&quot;, &quot;tabs&quot;, and &quot;tcl&quot;. You can use the &quot;.mode&quot; dot command to switch between these output formats.</source>
          <target state="translated">sqlite3程序能够以八种不同的格式显示查询结果。&quot;csv&quot;、&quot;column&quot;、&quot;html&quot;、&quot;insert&quot;、&quot;line&quot;、&quot;list&quot;、&quot;quote&quot;、&quot;tabs &quot;和 &quot;tcl&quot;。你可以使用&quot;.mode &quot;点命令来切换这些输出格式。</target>
        </trans-unit>
        <trans-unit id="c934dde95758c5fad9d43c84ef7f4c41bf3fe114" translate="yes" xml:space="preserve">
          <source>The sqlite3 program provides several convenience commands that are useful for looking at the schema of the database. There is nothing that these commands do that cannot be done by some other means. These commands are provided purely as a shortcut.</source>
          <target state="translated">sqlite3程序提供了几个方便的命令,这些命令对查看数据库的模式很有用。这些命令所做的事情没有什么是不能通过其他方式完成的。这些命令纯粹是作为一种快捷方式提供的。</target>
        </trans-unit>
        <trans-unit id="d730ebfc68ed44661fe9aaa4784f842bff23a6ec" translate="yes" xml:space="preserve">
          <source>The sqlite3_aggregate_context(C,N) routine returns a NULL pointer when first called if N is less than or equal to zero or if a memory allocate error occurs.</source>
          <target state="translated">sqlite3_aggregate_context(C,N)例程在第一次调用时,如果N小于或等于0,或者发生内存分配错误,则返回一个NULL指针。</target>
        </trans-unit>
        <trans-unit id="a781b80076608933fb39f35323ee417edf53e9fb" translate="yes" xml:space="preserve">
          <source>The sqlite3_analyzer utility program is updated to provide better descriptions and to compute a more accurate estimate for &quot;Non-sequential pages&quot;</source>
          <target state="translated">sqlite3_analyzer实用程序已经更新,以提供更好的描述,并计算出更准确的 &quot;非连续页面 &quot;估计值。</target>
        </trans-unit>
        <trans-unit id="cea6cec9b3cecf3cdb8b21b8c439ffacaf7e4757" translate="yes" xml:space="preserve">
          <source>The sqlite3_analyzer.exe Utility Program</source>
          <target state="translated">sqlite3_analyzer.exe实用程序。</target>
        </trans-unit>
        <trans-unit id="08064e181ad262ed7b2155684ee88c71ec311b40" translate="yes" xml:space="preserve">
          <source>The sqlite3_analyzer.exe utility is updated to report the depth of each btree and to show the average fanout for indexes and WITHOUT ROWID tables.</source>
          <target state="translated">sqlite3_analyzer.exe实用程序已经更新,以报告每个btree的深度,并显示索引和WITHOUT ROWID表的平均扇出。</target>
        </trans-unit>
        <trans-unit id="69ea749b99043a4585c42b36d581974b4510bba7" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup object records state information about an ongoing online backup operation. The sqlite3_backup object is created by a call to &lt;a href=&quot;#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; and is destroyed by a call to &lt;a href=&quot;#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_backup对象记录有关正在进行的联机备份操作的状态信息。所述sqlite3_backup目的通过一个调用创建到&lt;a href=&quot;#sqlite3backupinit&quot;&gt;sqlite3_backup_init（） &lt;/a&gt;，并通过呼叫销毁&lt;a href=&quot;#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ff5c92c4105199925092609d2d9f802d1fa55672" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup object records state information about an ongoing online backup operation. The sqlite3_backup object is created by a call to &lt;a href=&quot;backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; and is destroyed by a call to &lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_backup对象记录有关正在进行的联机备份操作的状态信息。所述sqlite3_backup目的通过一个调用创建到&lt;a href=&quot;backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init（） &lt;/a&gt;，并通过呼叫销毁&lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db586a6cde9f4397b1aba32074e60460ba79310a" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_remaining() and sqlite3_backup_pagecount() APIs report values stored by the previous call to sqlite3_backup_step(), they do not actually inspect the source database file. This means that if the source database is written to by another thread or process after the call to sqlite3_backup_step() returns but before the values returned by sqlite3_backup_remaining() and sqlite3_backup_pagecount() are used, the values may be technically incorrect. This is not usually a problem.</source>
          <target state="translated">sqlite3_backup_remaining()和 sqlite3_backup_pagecount()API报告之前调用 sqlite3_backup_step()所存储的值,它们实际上并不检查源数据库文件。这意味着,如果在调用 sqlite3_backup_step()返回之后,但在使用 sqlite3_backup_remaining()和 sqlite3_backup_pagecount()返回的值之前,源数据库被另一个线程或进程写入,那么这些值在技术上可能是不正确的。这通常不是一个问题。</target>
        </trans-unit>
        <trans-unit id="ab13e83a5eec05a800456f808bd2ed14f96ad7d8" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_remaining() routine returns the number of pages still to be backed up at the conclusion of the most recent sqlite3_backup_step(). The sqlite3_backup_pagecount() routine returns the total number of pages in the source database at the conclusion of the most recent sqlite3_backup_step(). The values returned by these functions are only updated by sqlite3_backup_step(). If the source database is modified in a way that changes the size of the source database or the number of pages remaining, those changes are not reflected in the output of sqlite3_backup_pagecount() and sqlite3_backup_remaining() until after the next sqlite3_backup_step().</source>
          <target state="translated">sqlite3_backup_remaining()例程返回最近一次 sqlite3_backup_step()结束时仍然需要备份的页面数。sqlite3_backup_pagecount()例程返回最近一次 sqlite3_backup_step()结束时源数据库的总页数。这些函数返回的值只由 sqlite3_backup_step()更新。如果源数据库被修改,改变了源数据库的大小或剩余页数,这些改变不会反映在sqlite3_backup_pagecount()和sqlite3_backup_remaining()的输出中,直到下一个sqlite3_backup_step()之后。</target>
        </trans-unit>
        <trans-unit id="027c7809f8a158ea3a080d548eaba037441f7cc5" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_step() might return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt; if</source>
          <target state="translated">该sqlite3_backup_step（）可能返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;如果</target>
        </trans-unit>
        <trans-unit id="44bfd22dba6c2a0335c1b72cfe8865a0ed15325c" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_step() might return &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; if</source>
          <target state="translated">该sqlite3_backup_step（）可能返回&lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;如果</target>
        </trans-unit>
        <trans-unit id="a2f8db9336dd78e8265a2d46cc59a9e446011dc7" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_* routines return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success or an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if anything goes wrong. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; might be returned if the size of a string or BLOB exceeds limits imposed by &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) or &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned if the parameter index is out of range. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; is returned if malloc() fails.</source>
          <target state="translated">sqlite3_bind_ *例程成功返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;，如果出现任何&lt;a href=&quot;rescode&quot;&gt;错误，&lt;/a&gt;则返回错误代码。&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt;如果字符串或BLOB的大小超过规定的限制，可能会返回&lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;（&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;）或&lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;。如果参数索引超出范围，则返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_RANGE&lt;/a&gt;。如果malloc（）失败，则返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb0da7fe06be85118ba3dab99ff46185b6777bbe" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_* routines return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success or an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if anything goes wrong. &lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; might be returned if the size of a string or BLOB exceeds limits imposed by &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) or &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;. &lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned if the parameter index is out of range. &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; is returned if malloc() fails.</source>
          <target state="translated">sqlite3_bind_ *例程成功返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;，如果出现任何&lt;a href=&quot;../rescode&quot;&gt;错误，&lt;/a&gt;则返回错误代码。&lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt;如果字符串或BLOB的大小超过规定的限制，可能会返回&lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;（&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;）或&lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;。如果参数索引超出范围，则返回&lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt;。如果malloc（）失败，则返回&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f71713542739e9593b1adb467245384ef671786" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_parameter_name(P,N) interface returns the name of the N-th &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL parameter&lt;/a&gt; in the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P. SQL parameters of the form &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; have a name which is the string &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; respectively. In other words, the initial &quot;:&quot; or &quot;$&quot; or &quot;@&quot; or &quot;?&quot; is included as part of the name. Parameters of the form &quot;?&quot; without a following integer have no name and are referred to as &quot;nameless&quot; or &quot;anonymous parameters&quot;.</source>
          <target state="translated">sqlite3_bind_parameter_name（P，N）接口在&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt; P中返回第N个&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL参数&lt;/a&gt;的名称。形式为&amp;ldquo;？NNN&amp;rdquo;或&amp;ldquo;：AAA&amp;rdquo;或&amp;ldquo; @AAA&amp;rdquo;或&amp;ldquo; $ AAA&amp;rdquo;的SQL参数有一个名称，分别是字符串&amp;ldquo;？NNN&amp;rdquo;或&amp;ldquo;：AAA&amp;rdquo;或&amp;ldquo; @AAA&amp;rdquo;或&amp;ldquo; $ AAA&amp;rdquo;。换句话说，首字母&amp;ldquo;：&amp;rdquo;或&amp;ldquo; $&amp;rdquo;或&amp;ldquo; @&amp;rdquo;或&amp;ldquo;？&amp;rdquo;包含在名称中。形式为&amp;ldquo;？&amp;rdquo;的参数没有后面的整数的名字没有名字，被称为&amp;ldquo;无名&amp;rdquo;或&amp;ldquo;匿名参数&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="8f7478b82c93544aa582bd52cdb8be854dddfaed" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_parameter_name(P,N) interface returns the name of the N-th &lt;a href=&quot;bind_blob&quot;&gt;SQL parameter&lt;/a&gt; in the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P. SQL parameters of the form &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; have a name which is the string &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; respectively. In other words, the initial &quot;:&quot; or &quot;$&quot; or &quot;@&quot; or &quot;?&quot; is included as part of the name. Parameters of the form &quot;?&quot; without a following integer have no name and are referred to as &quot;nameless&quot; or &quot;anonymous parameters&quot;.</source>
          <target state="translated">sqlite3_bind_parameter_name（P，N）接口在&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt; P中返回第N个&lt;a href=&quot;bind_blob&quot;&gt;SQL参数&lt;/a&gt;的名称。形式为&amp;ldquo;？NNN&amp;rdquo;或&amp;ldquo;：AAA&amp;rdquo;或&amp;ldquo; @AAA&amp;rdquo;或&amp;ldquo; $ AAA&amp;rdquo;的SQL参数有一个名称，分别是字符串&amp;ldquo;？NNN&amp;rdquo;或&amp;ldquo;：AAA&amp;rdquo;或&amp;ldquo; @AAA&amp;rdquo;或&amp;ldquo; $ AAA&amp;rdquo;。换句话说，首字母&amp;ldquo;：&amp;rdquo;或&amp;ldquo; $&amp;rdquo;或&amp;ldquo; @&amp;rdquo;或&amp;ldquo;？&amp;rdquo;包含在名称中。形式为&amp;ldquo;？&amp;rdquo;的参数没有后面的整数的名字没有名字，被称为&amp;ldquo;无名&amp;rdquo;或&amp;ldquo;匿名参数&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2f7ba9ace88be98840180479bfcb11ff0ebe16ce" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_pointer(S,I,P,T,D) routine causes the I-th parameter in &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S to have an SQL value of NULL, but to also be associated with the pointer P of type T. D is either a NULL pointer or a pointer to a destructor function for P. SQLite will invoke the destructor D with a single argument of P when it is finished using P. The T parameter should be a static string, preferably a string literal. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_bind_pointer（S，I，P，T，D）例程使已&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt; S中的第I个参数的SQL值为NULL，但也与类型T的指针P关联。D为NULL指针或指向P的析构函数的指针。使用P完成时，SQLite将使用P的单个参数调用析构函数D。T参数应为静态字符串，最好是字符串文字。 sqlite3_bind_pointer（）例程是为SQLite 3.20.0添加的&lt;a href=&quot;bindptr&quot;&gt;指针传递接口的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="658c91c6c69fa0e297b2600c0a7ae1e8d41b306a" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_pointer(S,I,P,T,D) routine causes the I-th parameter in &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S to have an SQL value of NULL, but to also be associated with the pointer P of type T. D is either a NULL pointer or a pointer to a destructor function for P. SQLite will invoke the destructor D with a single argument of P when it is finished using P. The T parameter should be a static string, preferably a string literal. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_bind_pointer（S，I，P，T，D）例程使已&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt; S中的第I个参数的SQL值为NULL，但也与类型T的指针P关联。D为NULL指针或指向P的析构函数的指针。使用P完成时，SQLite将使用P的单个参数调用析构函数D。T参数应为静态字符串，最好是字符串文字。 sqlite3_bind_pointer（）例程是为SQLite 3.20.0添加的&lt;a href=&quot;../bindptr&quot;&gt;指针传递接口的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="6397a7b2569f0831356316d22abee5d260da2f56" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_zeroblob() routine binds a BLOB of length N that is filled with zeroes. A zeroblob uses a fixed amount of memory (just an integer to hold its size) while it is being processed. Zeroblobs are intended to serve as placeholders for BLOBs whose content is later written using &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt; routines. A negative value for the zeroblob results in a zero-length BLOB.</source>
          <target state="translated">sqlite3_bind_zeroblob（）例程绑定长度为N的BLOB，并用零填充。在处理过程中，zeroblob使用固定数量的内存（仅保留一个整数即可容纳其大小）。Zeroblob旨在用作BLOB的占位符，其内容随后使用&lt;a href=&quot;#sqlite3_blob_open&quot;&gt;增量BLOB I / O&lt;/a&gt;例程编写。零blob的负值将导致零长度BLOB。</target>
        </trans-unit>
        <trans-unit id="c43ef2df76e0304e4b4beb3c8e7c5dbefc82b96b" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_zeroblob() routine binds a BLOB of length N that is filled with zeroes. A zeroblob uses a fixed amount of memory (just an integer to hold its size) while it is being processed. Zeroblobs are intended to serve as placeholders for BLOBs whose content is later written using &lt;a href=&quot;blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt; routines. A negative value for the zeroblob results in a zero-length BLOB.</source>
          <target state="translated">sqlite3_bind_zeroblob（）例程绑定长度为N的BLOB，并用零填充。在处理过程中，zeroblob使用固定数量的内存（仅保留一个整数即可容纳其大小）。Zeroblob旨在用作BLOB的占位符，其内容随后使用&lt;a href=&quot;blob_open&quot;&gt;增量BLOB I / O&lt;/a&gt;例程编写。零blob的负值将导致零长度BLOB。</target>
        </trans-unit>
        <trans-unit id="3d2cce49ac08682bc109d88559efafcb5bc906c9" translate="yes" xml:space="preserve">
          <source>The sqlite3_busy_handler(D,X,P) routine sets a callback function X that might be invoked with argument P whenever an attempt is made to access a database table associated with &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D when another thread or process has the table locked. The sqlite3_busy_handler() interface is used to implement &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;.</source>
          <target state="translated">sqlite3_busy_handler（D，X，P）例程设置一个回调函数X，只要在另一个线程或进程将表锁定时尝试访问与&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 相关联的数据库表，都可以使用参数P调用该回调函数。sqlite3_busy_handler（）接口用于实现&lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d3363e5f93709d191e40f4d06f477acdab0e375e" translate="yes" xml:space="preserve">
          <source>The sqlite3_busy_handler(D,X,P) routine sets a callback function X that might be invoked with argument P whenever an attempt is made to access a database table associated with &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D when another thread or process has the table locked. The sqlite3_busy_handler() interface is used to implement &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; and &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;.</source>
          <target state="translated">sqlite3_busy_handler（D，X，P）例程设置一个回调函数X，只要在另一个线程或进程将表锁定时尝试访问与&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 相关联的数据库表，都可以使用参数P调用该回调函数。sqlite3_busy_handler（）接口用于实现&lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;和&lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8d93853c1f8ff5d06942fd5a08d82650ba96772" translate="yes" xml:space="preserve">
          <source>The sqlite3_close() and sqlite3_close_v2() routines are destructors for the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. Calls to sqlite3_close() and sqlite3_close_v2() return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is successfully destroyed and all associated resources are deallocated.</source>
          <target state="translated">sqlite3_close（）和sqlite3_close_v2（）例程是&lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象的析构函数。如果&lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象成功销毁并且所有关联资源都已释放，则对sqlite3_close（）和sqlite3_close_v2（）的调用返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c3b661e4a47ed928f3b7e88dd929f7831fe5385b" translate="yes" xml:space="preserve">
          <source>The sqlite3_close() and sqlite3_close_v2() routines are destructors for the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. Calls to sqlite3_close() and sqlite3_close_v2() return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is successfully destroyed and all associated resources are deallocated.</source>
          <target state="translated">sqlite3_close（）和sqlite3_close_v2（）例程是&lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象的析构函数。如果&lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象成功销毁并且所有关联资源都已释放，则对sqlite3_close（）和sqlite3_close_v2（）的调用返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e35c3e04c8fe7269b95a0494cefdd5cde7acf02" translate="yes" xml:space="preserve">
          <source>The sqlite3_collation_needed() routine registers a callback which the database engine will invoke if it encounters an unknown collating sequence. The callback can lookup an appropriate comparison function and invoke sqlite_3_create_collation() as needed. The fourth parameter to the callback is the name of the collating sequence in UTF-8. For sqlite3_collation_need16() the callback sends the collating sequence name in UTF-16 host byte order.</source>
          <target state="translated">sqlite3_collation_needed()例程注册了一个回调,如果遇到未知的整理序列,数据库引擎会调用这个回调。该回调可以查找一个合适的比较函数,并根据需要调用sqlite_3_create_collation()。回调的第四个参数是整理序列的名称,用UTF-8表示。对于sqlite3_collation_need16(),回调会以UTF-16主机字节顺序发送整理序列名。</target>
        </trans-unit>
        <trans-unit id="289668a545984e8fa7c4b426fa20f850363028a3" translate="yes" xml:space="preserve">
          <source>The sqlite3_column_decltype() routine returns text which is the declared type of the column in the CREATE TABLE statement. For an expression, the return type is an empty string. sqlite3_column_name() returns the name of the Nth column. sqlite3_column_bytes() returns the number of bytes in a column that has type BLOB or the number of bytes in a TEXT string with UTF-8 encoding. sqlite3_column_bytes16() returns the same value for BLOBs but for TEXT strings returns the number of bytes in a UTF-16 encoding. sqlite3_column_blob() return BLOB data. sqlite3_column_text() return TEXT data as UTF-8. sqlite3_column_text16() return TEXT data as UTF-16. sqlite3_column_int() return INTEGER data in the host machines native integer format. sqlite3_column_int64() returns 64-bit INTEGER data. Finally, sqlite3_column_double() return floating point data.</source>
          <target state="translated">sqlite3_column_decltype()例程返回的文本是在CREATE TABLE语句中声明的列的类型。sqlite3_column_name()返回第N个列的名称。 sqlite3_column_bytes()返回BLOB类型的列的字节数或者UTF-8编码的TEXT字符串的字节数。 sqlite3_column_bytes16()对BLOB返回相同的值,但是对TEXT字符串返回UTF-16编码的字节数。sqlite3_column_blob()返回BLOB数据。 sqlite3_column_text()返回UTF-8格式的TEXT数据。 sqlite3_column_text16()返回UTF-16格式的TEXT数据。 sqlite3_column_int()返回主机本地整数格式的INTEGER数据。最后,sqlite3_column_double()返回浮点数据。</target>
        </trans-unit>
        <trans-unit id="a9b38d21f857b4d104b01ccf828564edcab9302b" translate="yes" xml:space="preserve">
          <source>The sqlite3_column_type() routine returns the &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype code&lt;/a&gt; for the initial data type of the result column. The returned value is one of &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL&lt;/a&gt;. The return value of sqlite3_column_type() can be used to decide which of the first six interface should be used to extract the column value. The value returned by sqlite3_column_type() is only meaningful if no automatic type conversions have occurred for the value in question. After a type conversion, the result of calling sqlite3_column_type() is undefined, though harmless. Future versions of SQLite may change the behavior of sqlite3_column_type() following a type conversion.</source>
          <target state="translated">sqlite3_column_type（）例程返回结果列的初始数据类型的&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;数据类型代码&lt;/a&gt;。返回的值是&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;，&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;，&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;，&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;或&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL之一&lt;/a&gt;。 sqlite3_column_type（）的返回值可用于确定应使用前六个接口中的哪个来提取列值。 sqlite3_column_type（）返回的值仅在没有针对该值进行自动类型转换的情况下才有意义。类型转换后，调用sqlite3_column_type（）的结果是不确定的，尽管无害。类型转换后，SQLite的未来版本可能会更改sqlite3_column_type（）的行为。</target>
        </trans-unit>
        <trans-unit id="d87c623fe2ec1f08f5218d69ec07d1b6f1fe406e" translate="yes" xml:space="preserve">
          <source>The sqlite3_column_type() routine returns the &lt;a href=&quot;c_blob&quot;&gt;datatype code&lt;/a&gt; for the initial data type of the result column. The returned value is one of &lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL&lt;/a&gt;. The return value of sqlite3_column_type() can be used to decide which of the first six interface should be used to extract the column value. The value returned by sqlite3_column_type() is only meaningful if no automatic type conversions have occurred for the value in question. After a type conversion, the result of calling sqlite3_column_type() is undefined, though harmless. Future versions of SQLite may change the behavior of sqlite3_column_type() following a type conversion.</source>
          <target state="translated">sqlite3_column_type（）例程返回结果列的初始数据类型的&lt;a href=&quot;c_blob&quot;&gt;数据类型代码&lt;/a&gt;。返回的值是&lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;，&lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;，&lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;，&lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;或&lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL之一&lt;/a&gt;。 sqlite3_column_type（）的返回值可用于确定应使用前六个接口中的哪个来提取列值。 sqlite3_column_type（）返回的值仅在没有针对该值进行自动类型转换的情况下才有意义。类型转换后，调用sqlite3_column_type（）的结果是不确定的，尽管无害。类型转换后，SQLite的未来版本可能会更改sqlite3_column_type（）的行为。</target>
        </trans-unit>
        <trans-unit id="80c9429e83e0f6600057106ffc072b05d6e8df14" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;../lang_transaction&quot;&gt;committed&lt;/a&gt;. Any callback set by a previous call to sqlite3_commit_hook() for the same database connection is overridden. The sqlite3_rollback_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;../lang_transaction&quot;&gt;rolled back&lt;/a&gt;. Any callback set by a previous call to sqlite3_rollback_hook() for the same database connection is overridden. The pArg argument is passed through to the callback. If the callback on a commit hook function returns non-zero, then the commit is converted into a rollback.</source>
          <target state="translated">sqlite3_commit_hook（）接口注册一个回调函数，只要&lt;a href=&quot;../lang_transaction&quot;&gt;提交&lt;/a&gt;事务即可调用该回调函数。先前调用sqlite3_commit_hook（）为同一数据库连接设置的任何回调都将被覆盖。 sqlite3_rollback_hook（）接口注册一个回调函数，每当事务&lt;a href=&quot;../lang_transaction&quot;&gt;回滚&lt;/a&gt;时，该回调函数就会被调用。先前调用sqlite3_rollback_hook（）为同一数据库连接设置的任何回调都将被覆盖。 pArg参数传递给回调。如果提交挂钩函数上的回调返回非零，则提交将转换为回滚。</target>
        </trans-unit>
        <trans-unit id="c831f98581f1e28276e947cc54e55e8093cff2bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;lang_transaction&quot;&gt;committed&lt;/a&gt;. Any callback set by a previous call to sqlite3_commit_hook() for the same database connection is overridden. The sqlite3_rollback_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;lang_transaction&quot;&gt;rolled back&lt;/a&gt;. Any callback set by a previous call to sqlite3_rollback_hook() for the same database connection is overridden. The pArg argument is passed through to the callback. If the callback on a commit hook function returns non-zero, then the commit is converted into a rollback.</source>
          <target state="translated">sqlite3_commit_hook（）接口注册一个回调函数，只要&lt;a href=&quot;lang_transaction&quot;&gt;提交&lt;/a&gt;事务即可调用该回调函数。先前调用sqlite3_commit_hook（）为同一数据库连接设置的任何回调都将被覆盖。 sqlite3_rollback_hook（）接口注册一个回调函数，每当事务&lt;a href=&quot;lang_transaction&quot;&gt;回滚&lt;/a&gt;时，该回调函数就会被调用。先前调用sqlite3_rollback_hook（）为同一数据库连接设置的任何回调都将被覆盖。 pArg参数传递给回调。如果提交挂钩函数上的回调返回非零，则提交将转换为回滚。</target>
        </trans-unit>
        <trans-unit id="8ed0ff1b29d3e198ebfc7c54c6d04128fb45e5b9" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook(D,C,P) and sqlite3_rollback_hook(D,C,P) functions return the P argument from the previous call of the same function on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call for each function on D.</source>
          <target state="translated">sqlite3_commit_hook（D，C，P）和sqlite3_rollback_hook（D，C，P）函数从相同&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上同一函数的上一次调用返回P参数，对于D上每个函数的首次调用返回NULL。</target>
        </trans-unit>
        <trans-unit id="5c814d040fa0b2376c6a44e987d8d06f8d405641" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook(D,C,P) and sqlite3_rollback_hook(D,C,P) functions return the P argument from the previous call of the same function on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call for each function on D.</source>
          <target state="translated">sqlite3_commit_hook（D，C，P）和sqlite3_rollback_hook（D，C，P）函数从相同&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上同一函数的上一次调用返回P参数，对于D上每个函数的首次调用返回NULL。</target>
        </trans-unit>
        <trans-unit id="a783ef29506da5187d0b6a8b529c5db8a199c982" translate="yes" xml:space="preserve">
          <source>The sqlite3_compileoption_get() function allows iterating over the list of options that were defined at compile time by returning the N-th compile time option string. If N is out of range, sqlite3_compileoption_get() returns a NULL pointer. The SQLITE_ prefix is omitted from any strings returned by sqlite3_compileoption_get().</source>
          <target state="translated">sqlite3_compileoption_get()函数允许通过返回第N个编译时的选项字符串来迭代编译时定义的选项列表。如果N超出了范围,sqlite3_compileoption_get()返回一个NULL指针。sqlite3_compileoption_get()返回的任何字符串都将省略SQLITE_前缀。</target>
        </trans-unit>
        <trans-unit id="39c27e864f7c32b9ceed46ceee3feba79ed9e6fc" translate="yes" xml:space="preserve">
          <source>The sqlite3_compileoption_used() function returns 0 or 1 indicating whether the specified option was defined at compile time. The SQLITE_ prefix may be omitted from the option name passed to sqlite3_compileoption_used().</source>
          <target state="translated">sqlite3_compileoption_used()函数返回0或1,表示指定的选项是否在编译时被定义。传递给sqlite3_compileoption_used()的选项名中可以省略SQLITE_前缀。</target>
        </trans-unit>
        <trans-unit id="c2f7b71d769d28cabe75800e2f0fc786a0e3ca05" translate="yes" xml:space="preserve">
          <source>The sqlite3_config() interface is used to make global configuration changes to SQLite in order to tune SQLite to the specific needs of the application. The default configuration is recommended for most applications and so this routine is usually not necessary. It is provided to support rare applications with unusual needs.</source>
          <target state="translated">sqlite3_config()接口用于对SQLite进行全局配置更改,以便根据应用程序的特定需求调整SQLite。对于大多数应用程序来说,默认配置是被推荐的,因此这个例程通常是不必要的。提供它是为了支持有特殊需求的罕见应用。</target>
        </trans-unit>
        <trans-unit id="2a43551c13014713b84ff3176d603e20a0bb2d0e" translate="yes" xml:space="preserve">
          <source>The sqlite3_config() interface may only be invoked prior to library initialization using &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; or after shutdown by &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. If sqlite3_config() is called after &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and before &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; then it will return SQLITE_MISUSE. Note, however, that sqlite3_config() can be called as part of the implementation of an application-defined &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_config（）接口只能在使用&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;初始化库之前或在通过&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;关闭后调用。如果sqlite3_config（）被称为后&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;和前&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown（） &lt;/a&gt;，然后将返回SQLITE_MISUSE。但是请注意，可以将sqlite3_config（）作为应用程序定义的&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_os_init（）&lt;/a&gt;的实现的一部分来调用。</target>
        </trans-unit>
        <trans-unit id="950f596cd61399b38213d68d8e3371f1294cd97c" translate="yes" xml:space="preserve">
          <source>The sqlite3_config() interface may only be invoked prior to library initialization using &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; or after shutdown by &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. If sqlite3_config() is called after &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and before &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; then it will return SQLITE_MISUSE. Note, however, that sqlite3_config() can be called as part of the implementation of an application-defined &lt;a href=&quot;initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_config（）接口只能在使用&lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;初始化库之前或在通过&lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;关闭后调用。如果sqlite3_config（）被称为后&lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;和前&lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown（） &lt;/a&gt;，然后将返回SQLITE_MISUSE。但是请注意，可以将sqlite3_config（）作为应用程序定义的&lt;a href=&quot;initialize&quot;&gt;sqlite3_os_init（）&lt;/a&gt;的实现的一部分来调用。</target>
        </trans-unit>
        <trans-unit id="f36e7397009cd60c7259be5a8cbdeb80264ff811" translate="yes" xml:space="preserve">
          <source>The sqlite3_context_db_handle() interface returns a copy of the pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; (the 1st parameter) of the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_context_db_handle（）接口返回指向最初注册了应用程序定义函数的&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;例程的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;（第一个参数）的指针的副本。</target>
        </trans-unit>
        <trans-unit id="04b3afa93b5033ef2c02acd3a1ef18374b3a066e" translate="yes" xml:space="preserve">
          <source>The sqlite3_context_db_handle() interface returns a copy of the pointer to the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; (the 1st parameter) of the &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_context_db_handle（）接口返回指向最初注册了应用程序定义函数的&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;和&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;例程的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;（第一个参数）的指针的副本。</target>
        </trans-unit>
        <trans-unit id="0b0f49ec423453d8567eeff6ab2f843591a04245" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation() function honors the SQLITE_UTF16_ALIGNED flag.</source>
          <target state="translated">sqlite3_create_collation()函数尊重SQLITE_UTF16_ALIGNED标志。</target>
        </trans-unit>
        <trans-unit id="0e46987511170cbb4e8e90d14cfd9fe052087146" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation() function specifies a collating sequence name and a comparison function to implement that collating sequence. The comparison function is only used for comparing text values. The eTextRep parameter is one of SQLITE_UTF8, SQLITE_UTF16LE, SQLITE_UTF16BE, or SQLITE_ANY to specify which text representation the comparison function works with. Separate comparison functions can exist for the same collating sequence for each of the UTF-8, UTF-16LE and UTF-16BE text representations. The sqlite3_create_collation16() works like sqlite3_create_collation() except that the collation name is specified in UTF-16 host byte order instead of in UTF-8.</source>
          <target state="translated">sqlite3_create_collation()函数指定了一个整理序列名和一个比较函数来实现该整理序列。比较函数只用于比较文本值。eTextRep参数是SQLITE_UTF8、SQLITE_UTF16LE、SQLITE_UTF16BE或SQLITE_ANY中的一个,用于指定比较函数工作的文本表示方式。对于UTF-8、UTF-16LE和UTF-16BE三种文本表示,同一整理序列可以存在单独的比较函数。sqlite3_create_collation16()的工作原理和 sqlite3_create_collation()一样,只是整理名称是以 UTF-16 主机字节顺序而不是 UTF-8 来指定的。</target>
        </trans-unit>
        <trans-unit id="3bb1bc030c0ecaf171e6e7837d4fc5ad509b9304" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation_v2() works like sqlite3_create_collation() with the addition that the xDestroy callback is invoked on pArg when the collating function is deleted. Collating functions are deleted when they are overridden by later calls to the collation creation functions or when the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is closed using &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_create_collat​​ion_v2（）的工作方式与sqlite3_create_collat​​ion（）相似，此外，删除整理功能后，在pArg上调用了xDestroy回调。当整理函数被以后对整理创建函数的调用所覆盖，或者使用&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close（）&lt;/a&gt;关闭&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;时，整理函数将被删除。</target>
        </trans-unit>
        <trans-unit id="cce8a06023084f98541458166466b478b68c97fc" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation_v2() works like sqlite3_create_collation() with the addition that the xDestroy callback is invoked on pArg when the collating function is deleted. Collating functions are deleted when they are overridden by later calls to the collation creation functions or when the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is closed using &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_create_collat​​ion_v2（）的工作方式与sqlite3_create_collat​​ion（）相似，此外，删除整理功能后，在pArg上调用了xDestroy回调。当整理函数被以后对整理创建函数的调用所覆盖，或者使用&lt;a href=&quot;close&quot;&gt;sqlite3_close（）&lt;/a&gt;关闭&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;时，整理函数将被删除。</target>
        </trans-unit>
        <trans-unit id="35eaa1fdb7403d0bf2c872e0985b90cb08324f23" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_filename(D,J,W,N,P) allocates memory to hold a version of database filename D with corresponding journal file J and WAL file W and with N URI parameters key/values pairs in the array P. The result from sqlite3_create_filename(D,J,W,N,P) is a pointer to a database filename that is safe to pass to routines like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2321a78d45e7f791f5be9bd5eeeecdd73b61cbff" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_module_v2() interface has a fifth parameter which is a pointer to a destructor for the pClientData. SQLite will invoke the destructor function (if it is not NULL) when SQLite no longer needs the pClientData pointer. The destructor will also be invoked if the call to sqlite3_create_module_v2() fails. The sqlite3_create_module() interface is equivalent to sqlite3_create_module_v2() with a NULL destructor.</source>
          <target state="translated">sqlite3_create_module_v2()接口有第五个参数,它是指向pClientData的析构器的指针,当SQLite不再需要pClientData指针时,SQLite会调用析构器函数(如果不是NULL)。当SQLite不再需要pClientData指针时,SQLite将调用destructor函数(如果它不是NULL)。如果调用 sqlite3_create_module_v2()失败,destructor 也会被调用。sqlite3_create_module()接口相当于sqlite3_create_module_v2()的NULL析构器。</target>
        </trans-unit>
        <trans-unit id="ce43917c89192dc7d4a31aeaa86afac14bcedebc" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; family of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23578428cca6b0b7cc9f351266849d54d3f4ac7" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_*()&lt;/a&gt; of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="translated">sqlite3_data_count（P）接口返回已&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt; P 结果集中当前行中的列数。如果已准备好的语句P没有准备好返回结果（通过调用接口的&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column _ *（）&lt;/a&gt;），则sqlite3_data_count（ P）返回0。如果P是NULL指针，则sqlite3_data_count（P）例程也返回0。如果先前对&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;（P）的调用返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;，则sqlite3_data_count（P）例程返回0 。如果先前对&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;（P）的调用返回了&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;，则sqlite3_data_count（P）将返回非零值，但&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA增量式&lt;/a&gt;真空的情况除外由于该多步骤编译指示的每一步都会返回0列数据，因此该位置始终返回零。</target>
        </trans-unit>
        <trans-unit id="f5791b68b76b19a4a15dafbc0a31b6f189b8fc89" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; family of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0331c5159620074031eabe2d2fffeb3879925815" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_*()&lt;/a&gt; of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="translated">sqlite3_data_count（P）接口返回已&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt; P 结果集中当前行中的列数。如果已准备好的语句P没有准备好返回结果（通过调用接口的&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column _ *（）&lt;/a&gt;），则sqlite3_data_count（ P）返回0。如果P是NULL指针，则sqlite3_data_count（P）例程也返回0。如果先前对&lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;（P）的调用返回&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;，则sqlite3_data_count（P）例程返回0 。如果先前对&lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;（P）的调用返回了&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;，则sqlite3_data_count（P）将返回非零值，但&lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA增量式&lt;/a&gt;真空的情况除外由于该多步骤编译指示的每一步都会返回0列数据，因此该位置始终返回零。</target>
        </trans-unit>
        <trans-unit id="043836a9d52018cfd95036ef1de8601c0dd65b27" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_config() interface is used to make configuration changes to a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. The interface is similar to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; except that the changes apply to a single &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; (specified in the first argument).</source>
          <target state="translated">sqlite3_db_config（）接口用于对&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;进行配置更改。该接口与&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;相似，不同之处在于更改适用于单个&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;（在第一个参数中指定）。</target>
        </trans-unit>
        <trans-unit id="cb382b8043f6bd41fb4e955562ae2dd8de8821a6" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_config() interface is used to make configuration changes to a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. The interface is similar to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; except that the changes apply to a single &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; (specified in the first argument).</source>
          <target state="translated">sqlite3_db_config（）接口用于对&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;进行配置更改。该接口与&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;相似，不同之处在于更改适用于单个&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;（在第一个参数中指定）。</target>
        </trans-unit>
        <trans-unit id="d9890e9099b39efa9f23ed1209f98fc2abd695d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_filename(D,N) interface returns a pointer to a filename associated with database N of connection D. The main database file has the name &quot;main&quot;. If there is no attached database N on the database connection D, or if database N is a temporary or in-memory database, then this function will return either a NULL pointer or an empty string.</source>
          <target state="translated">sqlite3_db_filename(D,N)接口返回一个指向连接D的数据库N相关联的文件名的指针,主数据库文件的名称为 &quot;main&quot;。如果数据库连接D上没有关联的数据库N,或者数据库N是一个临时的或者内存中的数据库,那么这个函数将返回一个NULL指针或者一个空字符串。</target>
        </trans-unit>
        <trans-unit id="6ce559d2134cd8f80b32424d9cafa088f3f1de6d" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_filename(D,N) interface returns a pointer to the filename associated with database N of connection D. If there is no attached database N on the database connection D, or if database N is a temporary or in-memory database, then this function will return either a NULL pointer or an empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a0142f7765d452e556a6d1ade538189bbf023a1" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_handle interface returns the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; handle to which a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; belongs. The &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; returned by sqlite3_db_handle is the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that was the first argument to the &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; call (or its variants) that was used to create the statement in the first place.</source>
          <target state="translated">sqlite3_db_handle接口返回已&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;所属的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;句柄。该&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;通过sqlite3_db_handle返回相同&lt;a href=&quot;#sqlite3&quot;&gt;的数据库连接&lt;/a&gt;，这是第一个参数到&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;是用于创建摆在首位的语句调用（或其变体）。</target>
        </trans-unit>
        <trans-unit id="0ed4944069eec7d7c0e7904b6909ffc71d6a37af" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_handle interface returns the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; handle to which a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; belongs. The &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; returned by sqlite3_db_handle is the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that was the first argument to the &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; call (or its variants) that was used to create the statement in the first place.</source>
          <target state="translated">sqlite3_db_handle接口返回已&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;所属的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;句柄。该&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;通过sqlite3_db_handle返回相同&lt;a href=&quot;sqlite3&quot;&gt;的数据库连接&lt;/a&gt;，这是第一个参数到&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;是用于创建摆在首位的语句调用（或其变体）。</target>
        </trans-unit>
        <trans-unit id="f13e3d008759351c9d014a67b0c7d66c909c38ed" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_readonly(D,N) interface returns 1 if the database N of connection D is read-only, 0 if it is read/write, or -1 if N is not the name of a database on connection D.</source>
          <target state="translated">sqlite3_db_readonly(D,N)接口如果连接D的数据库N是只读,则返回1,如果是读/写,则返回0,如果N不是连接D上的数据库名称,则返回-1。</target>
        </trans-unit>
        <trans-unit id="7c54e0312a49676acc8e0fa5a98fa6c3ca389049" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_release_memory(D) interface attempts to free as much heap memory as possible from database connection D. Unlike the &lt;a href=&quot;#sqlite3_release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface, this interface is in effect even when the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is omitted.</source>
          <target state="translated">sqlite3_db_release_memory（D）接口尝试从数据库连接D释放尽可能多的堆内存。与&lt;a href=&quot;#sqlite3_release_memory&quot;&gt;sqlite3_release_memory（）&lt;/a&gt;接口不同，即使忽略了&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;编译时选项，此接口也有效。</target>
        </trans-unit>
        <trans-unit id="a4505b330dae36966abd878a7a5251bb10a809a6" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_release_memory(D) interface attempts to free as much heap memory as possible from database connection D. Unlike the &lt;a href=&quot;release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface, this interface is in effect even when the &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is omitted.</source>
          <target state="translated">sqlite3_db_release_memory（D）接口尝试从数据库连接D释放尽可能多的堆内存。与&lt;a href=&quot;release_memory&quot;&gt;sqlite3_release_memory（）&lt;/a&gt;接口不同，即使忽略了&lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;编译时选项，此接口也有效。</target>
        </trans-unit>
        <trans-unit id="83634ce6a2d174966fca0f07d2eb6e5e52439e9f" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_status() routine returns SQLITE_OK on success and a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_db_status（）例程在成功时返回SQLITE_OK，在失败时返回非零&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7babdc84886f95b16b07a064461180aa8e231247" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_status() routine returns SQLITE_OK on success and a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_db_status（）例程在成功时返回SQLITE_OK，在失败时返回非零&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18d47ae58f8b29dbac7701bb014dc19e22eadf62" translate="yes" xml:space="preserve">
          <source>The sqlite3_deserialize() interface will fail with SQLITE_BUSY if the database is currently in a read transaction or is involved in a backup operation.</source>
          <target state="translated">如果数据库当前处于读取事务中或者参与了备份操作,那么sqlite3_deserialize()接口将以SQLITE_BUSY失败。</target>
        </trans-unit>
        <trans-unit id="12340c8333dc6a82eca44a1f4c8bbf0434fac375" translate="yes" xml:space="preserve">
          <source>The sqlite3_deserialize(D,S,P,N,M,F) interface causes the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D to disconnect from database S and then reopen S as an in-memory database based on the serialization contained in P. The serialized database P is N bytes in size. M is the size of the buffer P, which might be larger than N. If M is larger than N, and the SQLITE_DESERIALIZE_READONLY bit is not set in F, then SQLite is permitted to add content to the in-memory database as long as the total size does not exceed M bytes.</source>
          <target state="translated">sqlite3_deserialize（D，S，P，N，M，F）接口使&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D与数据库S断开连接，然后根据P中包含的序列化将S作为内存数据库重新打开。序列化的数据库P为N字节大小。M是缓冲区P的大小，它可能大于N。如果M大于N，并且F中未设置SQLITE_DESERIALIZE_READONLY位，则只要允许SQLite向内存数据库添加内容，就可以总大小不超过M个字节。</target>
        </trans-unit>
        <trans-unit id="afac5ec67e0561a540471ae51b94788f3734ed79" translate="yes" xml:space="preserve">
          <source>The sqlite3_deserialize(D,S,P,N,M,F) interface causes the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D to disconnect from database S and then reopen S as an in-memory database based on the serialization contained in P. The serialized database P is N bytes in size. M is the size of the buffer P, which might be larger than N. If M is larger than N, and the SQLITE_DESERIALIZE_READONLY bit is not set in F, then SQLite is permitted to add content to the in-memory database as long as the total size does not exceed M bytes.</source>
          <target state="translated">sqlite3_deserialize（D，S，P，N，M，F）接口使&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D与数据库S断开连接，然后根据P中包含的序列化将S作为内存数据库重新打开。序列化的数据库P为N字节大小。M是缓冲区P的大小，它可能大于N。如果M大于N，并且F中未设置SQLITE_DESERIALIZE_READONLY位，则只要允许SQLite向内存数据库添加内容，就可以总大小不超过M个字节。</target>
        </trans-unit>
        <trans-unit id="6ae05681a8b59259daa468a1d8590729337a135a" translate="yes" xml:space="preserve">
          <source>The sqlite3_drop_modules(D,L) interface removes all virtual table modules from database connection D except those named on list L. The L parameter must be either NULL or a pointer to an array of pointers to strings where the array is terminated by a single NULL pointer. If the L parameter is NULL, then all virtual table modules are removed.</source>
          <target state="translated">sqlite3_drop_modules(D,L)接口从数据库连接D中删除所有虚拟表模块,列表L中命名的模块除外。L参数必须是NULL或指向字符串指针数组的指针,其中数组以单个NULL指针结束。如果L参数为NULL,则删除所有虚拟表模块。</target>
        </trans-unit>
        <trans-unit id="cb17fe8b042f1bd6f76a39ed23dd1524edfc2345" translate="yes" xml:space="preserve">
          <source>The sqlite3_errcode() routine returns a result code for the most recent major API call. sqlite3_errmsg() returns an English-language text error message for the most recent error. The error message is represented in UTF-8 and will be ephemeral - it could disappear on the next call to any SQLite API function. sqlite3_errmsg16() works like sqlite3_errmsg() except that it returns the error message represented as UTF-16 in host native byte order.</source>
          <target state="translated">sqlite3_errcode()例程返回最近一次主要API调用的结果代码。 sqlite3_errmsg()返回最近一次错误的英文文本错误信息。sqlite3_errmsg16()的工作原理和sqlite3_errmsg()一样,只是它以主机本地字节顺序返回UTF-16表示的错误信息。</target>
        </trans-unit>
        <trans-unit id="5e0d9cf7c1277961ee0db98705525eacc5bb425f" translate="yes" xml:space="preserve">
          <source>The sqlite3_errmsg() and sqlite3_errmsg16() return English-language text that describes the error, as either UTF-8 or UTF-16 respectively. Memory to hold the error message string is managed internally. The application does not need to worry about freeing the result. However, the error string might be overwritten or deallocated by subsequent calls to other SQLite interface functions.</source>
          <target state="translated">sqlite3_errmsg()和sqlite3_errmsg16()分别以UTF-8或UTF-16的形式返回描述错误的英文文本。用于保存错误信息字符串的内存由内部管理。应用程序不需要担心释放结果。但是,错误字符串可能会被后续对其他SQLite接口函数的调用覆盖或重新分配。</target>
        </trans-unit>
        <trans-unit id="a3b2d05546afbeecb20b8fe87e3f3189bfedb642" translate="yes" xml:space="preserve">
          <source>The sqlite3_errstr() interface returns the English-language text that describes the &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt;, as UTF-8. Memory to hold the error message string is managed internally and must not be freed by the application.</source>
          <target state="translated">sqlite3_errstr（）接口以UTF-8 返回描述&lt;a href=&quot;../rescode&quot;&gt;结果代码&lt;/a&gt;的英语文本。包含错误消息字符串的内存是在内部进行管理的，应用程序不得释放该内存。</target>
        </trans-unit>
        <trans-unit id="3185f0fefecbff2d0db8b69bac9298083b70809e" translate="yes" xml:space="preserve">
          <source>The sqlite3_errstr() interface returns the English-language text that describes the &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt;, as UTF-8. Memory to hold the error message string is managed internally and must not be freed by the application.</source>
          <target state="translated">sqlite3_errstr（）接口以UTF-8 返回描述&lt;a href=&quot;rescode&quot;&gt;结果代码&lt;/a&gt;的英语文本。包含错误消息字符串的内存是在内部进行管理的，应用程序不得释放该内存。</target>
        </trans-unit>
        <trans-unit id="eec19de3d00e4cd6319cb02ddf72d5b612e30300" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface is a convenience wrapper around &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;, that allows an application to run multiple statements of SQL without having to use a lot of C code.</source>
          <target state="translated">sqlite3_exec（）接口是&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;的便捷包装，它允许应用程序运行多个SQL语句而无需使用大量C代码。</target>
        </trans-unit>
        <trans-unit id="9a4e88bd32574fff7b2361feb6cf37710d7194a2" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface is a convenience wrapper around &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;, and &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;, that allows an application to run multiple statements of SQL without having to use a lot of C code.</source>
          <target state="translated">sqlite3_exec（）接口是&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;，&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;和&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;的便捷包装，它允许应用程序运行多个SQL语句而无需使用大量C代码。</target>
        </trans-unit>
        <trans-unit id="5f6ecb5327784e2b3ab3076a060e42400e8e6e49" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface runs zero or more UTF-8 encoded, semicolon-separate SQL statements passed into its 2nd argument, in the context of the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; passed in as its 1st argument. If the callback function of the 3rd argument to sqlite3_exec() is not NULL, then it is invoked for each result row coming out of the evaluated SQL statements. The 4th argument to sqlite3_exec() is relayed through to the 1st argument of each callback invocation. If the callback pointer to sqlite3_exec() is NULL, then no callback is ever invoked and result rows are ignored.</source>
          <target state="translated">sqlite3_exec（）接口在作为第一个参数传入的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;的上下文中，运行零个或多个以UTF-8编码，以分号分隔的SQL语句，并将其传递给第二个参数。如果sqlite3_exec（）的第3个参数的回调函数不为NULL，则将对从评估的SQL语句中出来的每个结果行调用该函数。sqlite3_exec（）的第4个参数将中继到每个回调调用的第一个参数。如果指向sqlite3_exec（）的回调指针为NULL，则不会调用任何回调，并且将忽略结果行。</target>
        </trans-unit>
        <trans-unit id="7f2bf987e70ab4f6565417a4f7295b79e8706b9e" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface runs zero or more UTF-8 encoded, semicolon-separate SQL statements passed into its 2nd argument, in the context of the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; passed in as its 1st argument. If the callback function of the 3rd argument to sqlite3_exec() is not NULL, then it is invoked for each result row coming out of the evaluated SQL statements. The 4th argument to sqlite3_exec() is relayed through to the 1st argument of each callback invocation. If the callback pointer to sqlite3_exec() is NULL, then no callback is ever invoked and result rows are ignored.</source>
          <target state="translated">sqlite3_exec（）接口在作为第一个参数传入的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;的上下文中，运行零个或多个以UTF-8编码，以分号分隔的SQL语句，并将其传递给第二个参数。如果sqlite3_exec（）的第3个参数的回调函数不为NULL，则将对从评估的SQL语句中出来的每个结果行调用该函数。sqlite3_exec（）的第4个参数将中继到每个回调调用的第一个参数。如果指向sqlite3_exec（）的回调指针为NULL，则不会调用任何回调，并且将忽略结果行。</target>
        </trans-unit>
        <trans-unit id="fdc80de144729ab29ec768dc45f521935b24167a" translate="yes" xml:space="preserve">
          <source>The sqlite3_expanded_sql() interface returns NULL if insufficient memory is available to hold the result, or if the result would exceed the the maximum string length determined by the &lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;.</source>
          <target state="translated">如果没有足够的内存来保存结果，或者如果结果将超过&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;确定的最大字符串长度，则sqlite3_expanded_sql（）接口返回NULL 。</target>
        </trans-unit>
        <trans-unit id="253eafa1da6e36def799917e15566e8c664899fe" translate="yes" xml:space="preserve">
          <source>The sqlite3_expanded_sql() interface returns NULL if insufficient memory is available to hold the result, or if the result would exceed the the maximum string length determined by the &lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;.</source>
          <target state="translated">如果没有足够的内存来保存结果，或者如果结果将超过&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;确定的最大字符串长度，则sqlite3_expanded_sql（）接口返回NULL 。</target>
        </trans-unit>
        <trans-unit id="1d1fd4c0ad3995d89a0ef41f1f46affc2269eba4" translate="yes" xml:space="preserve">
          <source>The sqlite3_extended_result_codes() routine enables or disables the &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; feature of SQLite. The extended result codes are disabled by default for historical compatibility.</source>
          <target state="translated">sqlite3_extended_result_codes（）例程启用或禁用SQLite 的&lt;a href=&quot;../rescode#extrc&quot;&gt;扩展结果代码&lt;/a&gt;功能。默认情况下，扩展结果代码是禁用的，以实现历史兼容性。</target>
        </trans-unit>
        <trans-unit id="904ab00e0ae19fa09117889888e1162471d32017" translate="yes" xml:space="preserve">
          <source>The sqlite3_extended_result_codes() routine enables or disables the &lt;a href=&quot;rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; feature of SQLite. The extended result codes are disabled by default for historical compatibility.</source>
          <target state="translated">sqlite3_extended_result_codes（）例程启用或禁用SQLite 的&lt;a href=&quot;rescode#extrc&quot;&gt;扩展结果代码&lt;/a&gt;功能。默认情况下，扩展结果代码是禁用的，以实现历史兼容性。</target>
        </trans-unit>
        <trans-unit id="5daeea1eac71cd621bf8b80af259a724f2e831b8" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize() function is called to delete a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. If the most recent evaluation of the statement encountered no errors or if the statement is never been evaluated, then sqlite3_finalize() returns SQLITE_OK. If the most recent evaluation of statement S failed, then sqlite3_finalize(S) returns the appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt;.</source>
          <target state="translated">调用sqlite3_finalize（）函数以删除&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;。如果对语句的最新评估没有遇到错误，或者从未对语句进行评估，则sqlite3_finalize（）返回SQLITE_OK。如果对语句S的最新评估失败，则sqlite3_finalize（S）返回适当的&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;或&lt;a href=&quot;rescode#extrc&quot;&gt;扩展错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="74837217c620c1e41ee1e321a9ad17968e0d6486" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize() function is called to delete a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. If the most recent evaluation of the statement encountered no errors or if the statement is never been evaluated, then sqlite3_finalize() returns SQLITE_OK. If the most recent evaluation of statement S failed, then sqlite3_finalize(S) returns the appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt;.</source>
          <target state="translated">调用sqlite3_finalize（）函数以删除&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;。如果对语句的最新评估没有遇到错误，或者从未对语句进行评估，则sqlite3_finalize（）返回SQLITE_OK。如果对语句S的最新评估失败，则sqlite3_finalize（S）返回适当的&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;或&lt;a href=&quot;../rescode#extrc&quot;&gt;扩展错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cfdc64000a1f68dd938d60f9bb70e02c947748fd" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize(S) routine can be called at any point during the life cycle of &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S: before statement S is ever evaluated, after one or more calls to &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, or after any call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; regardless of whether or not the statement has completed execution.</source>
          <target state="translated">sqlite3_finalize（S）例程可以在已&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt; S 的生命周期中的任何时间调用：在评估语句 S之前，一次或多次调用&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;之后或在调用&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）之后，&lt;/a&gt;无论是否或语句尚未完成执行。</target>
        </trans-unit>
        <trans-unit id="1dec5478469a2333006cfdfd3bbed8c6613161e2" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize(S) routine can be called at any point during the life cycle of &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S: before statement S is ever evaluated, after one or more calls to &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, or after any call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; regardless of whether or not the statement has completed execution.</source>
          <target state="translated">sqlite3_finalize（S）例程可以在已&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt; S 的生命周期中的任何时间调用：在评估语句 S之前，一次或多次调用&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;之后或在调用&lt;a href=&quot;step&quot;&gt;sqlite3_step（）之后，&lt;/a&gt;无论是否或语句尚未完成执行。</target>
        </trans-unit>
        <trans-unit id="408796a34b26a6721118a4ab1b7c1f9baef90909" translate="yes" xml:space="preserve">
          <source>The sqlite3_free_filename(Y) routine releases a memory allocation previously obtained from sqlite3_create_filename(). Invoking sqlite3_free_filename(Y) where Y is a NULL pointer is a harmless no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a8a4dfedb4d5de550dae28093210eb5e1165c50" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_autocommit() interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively. Autocommit mode is on by default. Autocommit mode is disabled by a &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt; statement. Autocommit mode is re-enabled by a &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; or &lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;.</source>
          <target state="translated">如果给定的数据库连接分别处于或不处于自动提交模式，则sqlite3_get_autocommit（）接口分别返回非零或零。默认情况下，自动提交模式是打开的。自动提交模式被&lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt;语句禁用。自动提交模式由&lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt;或&lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;重新启用。</target>
        </trans-unit>
        <trans-unit id="c6407bbe024eecae19905f3987328770ebef955e" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_autocommit() interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively. Autocommit mode is on by default. Autocommit mode is disabled by a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; statement. Autocommit mode is re-enabled by a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; or &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;.</source>
          <target state="translated">如果给定的数据库连接分别处于或不处于自动提交模式，则sqlite3_get_autocommit（）接口分别返回非零或零。默认情况下，自动提交模式是打开的。自动提交模式被&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;语句禁用。自动提交模式由&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;或&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;重新启用。</target>
        </trans-unit>
        <trans-unit id="c54753db8fb054877250927a699aaaed04734d2b" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_auxdata(C,N) interface returns a pointer to the metadata associated by the sqlite3_set_auxdata(C,N,P,X) function with the Nth argument value to the application-defined function. N is zero for the left-most function argument. If there is no metadata associated with the function argument, the sqlite3_get_auxdata(C,N) interface returns a NULL pointer.</source>
          <target state="translated">sqlite3_get_auxdata(C,N)接口返回一个指针,指向sqlite3_set_auxdata(C,N,P,X)函数与应用定义函数的第N个参数值关联的元数据。对于最左边的函数参数,N为零。如果没有与函数参数相关联的元数据,sqlite3_get_auxdata(C,N)接口返回一个NULL指针。</target>
        </trans-unit>
        <trans-unit id="35597daf57a6a6a4650eb220c2a29fa2c91a59d0" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_table() function evaluates one or more semicolon-separated SQL statements in the zero-terminated UTF-8 string of its 2nd parameter and returns a result table to the pointer given in its 3rd parameter.</source>
          <target state="translated">sqlite3_get_table()函数对其第2个参数中的一个或多个以分号分隔的UTF-8字符串的SQL语句进行评估,并向其第3个参数中给出的指针返回一个结果表。</target>
        </trans-unit>
        <trans-unit id="acdf7ebaf34cc7cf8bdf020e8dc45c52df0d628c" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_table() interface is implemented as a wrapper around &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;. The sqlite3_get_table() routine does not have access to any internal data structures of SQLite. It uses only the public interface defined here. As a consequence, errors that occur in the wrapper layer outside of the internal &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt; call are not reflected in subsequent calls to &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_get_table（）接口被实现为&lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;的包装。 sqlite3_get_table（）例程无法访问SQLite的任何内部数据结构。它仅使用此处定义的公共接口。结果，内部&lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;调用外部的包装层中发生的错误不会反映在后续对&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）的&lt;/a&gt;调用中。</target>
        </trans-unit>
        <trans-unit id="566ec671a5bf78f09b92642b451438dd26c86350" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_table() interface is implemented as a wrapper around &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;. The sqlite3_get_table() routine does not have access to any internal data structures of SQLite. It uses only the public interface defined here. As a consequence, errors that occur in the wrapper layer outside of the internal &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt; call are not reflected in subsequent calls to &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_get_table（）接口被实现为&lt;a href=&quot;exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;的包装。 sqlite3_get_table（）例程无法访问SQLite的任何内部数据结构。它仅使用此处定义的公共接口。结果，内部&lt;a href=&quot;exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;调用外部的包装层中发生的错误不会反映在后续对&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;或&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）的&lt;/a&gt;调用中。</target>
        </trans-unit>
        <trans-unit id="b9b992cc0be7235d15c4a18cbb125e283656622e" translate="yes" xml:space="preserve">
          <source>The sqlite3_hard_heap_limit64(N) interface sets a hard upper bound of N bytes on the amount of memory that will be allocated. The sqlite3_hard_heap_limit64(N) interface is similar to sqlite3_soft_heap_limit64(N) except that memory allocations will fail when the hard heap limit is reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1053b2bb267ced2e3415b8b71b02dc7bb0d976" translate="yes" xml:space="preserve">
          <source>The sqlite3_index_info structure and its substructures is used as part of the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; interface to pass information into and receive the reply from the &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt;. The fields under **Inputs** are the inputs to xBestIndex and are read-only. xBestIndex inserts its results into the **Outputs** fields.</source>
          <target state="translated">sqlite3_index_info结构及其子结构用作&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;接口的一部分，以将信息传递到&lt;a href=&quot;module&quot;&gt;虚拟表模块&lt;/a&gt;的&lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;方法并从中接收答复。**输入**下的字段是xBestIndex的输入，并且是只读的。xBestIndex将其结果插入到&amp;ldquo;输出&amp;rdquo;字段中。</target>
        </trans-unit>
        <trans-unit id="779db7516101e2733ab83d988869d6422e837e26" translate="yes" xml:space="preserve">
          <source>The sqlite3_index_info structure and its substructures is used as part of the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; interface to pass information into and receive the reply from the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt;. The fields under **Inputs** are the inputs to xBestIndex and are read-only. xBestIndex inserts its results into the **Outputs** fields.</source>
          <target state="translated">sqlite3_index_info结构及其子结构用作&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;接口的一部分，以将信息传递到&lt;a href=&quot;#sqlite3_module&quot;&gt;虚拟表模块&lt;/a&gt;的&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;方法并从中接收答复。**输入**下的字段是xBestIndex的输入，并且是只读的。xBestIndex将其结果插入到&amp;ldquo;输出&amp;rdquo;字段中。</target>
        </trans-unit>
        <trans-unit id="f7b3a693ac538b125172c62d75cc7d377f31b955" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() interface is threadsafe, but sqlite3_shutdown() is not. The sqlite3_shutdown() interface must only be called from a single thread. All open &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; must be closed and all other SQLite resources must be deallocated prior to invoking sqlite3_shutdown().</source>
          <target state="translated">sqlite3_initialize（）接口是线程安全的，但sqlite3_shutdown（）不是。sqlite3_shutdown（）接口只能从单个线程中调用。在调用sqlite3_shutdown（）之前，必须关闭所有打开的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接，&lt;/a&gt;并且必须释放所有其他SQLite资源。</target>
        </trans-unit>
        <trans-unit id="88e442978d61726b76c4c6bd7b1f8a87808c119b" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() interface is threadsafe, but sqlite3_shutdown() is not. The sqlite3_shutdown() interface must only be called from a single thread. All open &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; must be closed and all other SQLite resources must be deallocated prior to invoking sqlite3_shutdown().</source>
          <target state="translated">sqlite3_initialize（）接口是线程安全的，但sqlite3_shutdown（）不是。sqlite3_shutdown（）接口只能从单个线程中调用。在调用sqlite3_shutdown（）之前，必须关闭所有打开的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接，&lt;/a&gt;并且必须释放所有其他SQLite资源。</target>
        </trans-unit>
        <trans-unit id="0e2957684efb0782443d87103a368a9305c21dfe" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine initializes the SQLite library. The sqlite3_shutdown() routine deallocates any resources that were allocated by sqlite3_initialize(). These routines are designed to aid in process initialization and shutdown on embedded systems. Workstation applications using SQLite normally do not need to invoke either of these routines.</source>
          <target state="translated">sqlite3_initialize()例程初始化SQLite库。sqlite3_shutdown()例程会重新分配由 sqlite3_initialize()分配的资源。这些例程被设计用来帮助嵌入式系统的进程初始化和关闭。使用SQLite的工作站应用程序通常不需要调用这两个例程。</target>
        </trans-unit>
        <trans-unit id="6344d658101e62a854952f62047632e568cb77e6" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine is called internally by many other SQLite interfaces so that an application usually does not need to invoke sqlite3_initialize() directly. For example, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt; calls sqlite3_initialize() so the SQLite library will be automatically initialized when &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt; is called if it has not be initialized already. However, if SQLite is compiled with the &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; compile-time option, then the automatic calls to sqlite3_initialize() are omitted and the application must call sqlite3_initialize() directly prior to using any other SQLite interface. For maximum portability, it is recommended that applications always invoke sqlite3_initialize() directly prior to using any other SQLite interface. Future releases of SQLite may require this. In other words, the behavior exhibited when SQLite is compiled with &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; might become the default behavior in some future release of SQLite.</source>
          <target state="translated">sqlite3_initialize（）例程由许多其他SQLite接口在内部调用，因此应用程序通常不需要直接调用sqlite3_initialize（）。例如，&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;调用sqlite3_initialize（），所以SQLite库时将被自动初始化&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;被调用，如果它没有被已经初始化。但是，如果使用&lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;编译SQLite使用compile-time选项，则将省略对sqlite3_initialize（）的自动调用，并且应用程序必须在使用任何其他SQLite接口之前直接调用sqlite3_initialize（）。为了获得最大的可移植性，建议应用程序始终始终在使用任何其他SQLite接口之前直接调用sqlite3_initialize（）。 SQLite的未来版本可能会要求这样做。换句话说，在将来的SQLite发行版中，使用&lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;编译SQLite时显示的行为可能成为默认行为。</target>
        </trans-unit>
        <trans-unit id="fcebb10283d6873f839e3d670ae393ff5c1368df" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine is called internally by many other SQLite interfaces so that an application usually does not need to invoke sqlite3_initialize() directly. For example, &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt; calls sqlite3_initialize() so the SQLite library will be automatically initialized when &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt; is called if it has not be initialized already. However, if SQLite is compiled with the &lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; compile-time option, then the automatic calls to sqlite3_initialize() are omitted and the application must call sqlite3_initialize() directly prior to using any other SQLite interface. For maximum portability, it is recommended that applications always invoke sqlite3_initialize() directly prior to using any other SQLite interface. Future releases of SQLite may require this. In other words, the behavior exhibited when SQLite is compiled with &lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; might become the default behavior in some future release of SQLite.</source>
          <target state="translated">sqlite3_initialize（）例程由许多其他SQLite接口在内部调用，因此应用程序通常不需要直接调用sqlite3_initialize（）。例如，&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;调用sqlite3_initialize（），所以SQLite库时将被自动初始化&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;被调用，如果它没有被已经初始化。但是，如果使用&lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;编译SQLite使用compile-time选项，则将省略对sqlite3_initialize（）的自动调用，并且应用程序必须在使用任何其他SQLite接口之前直接调用sqlite3_initialize（）。为了获得最大的可移植性，建议应用程序始终始终在使用任何其他SQLite接口之前直接调用sqlite3_initialize（）。 SQLite的未来版本可能会要求这样做。换句话说，在将来的SQLite发行版中，使用&lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;编译SQLite时显示的行为可能成为默认行为。</target>
        </trans-unit>
        <trans-unit id="ce2e2f5e58c3c92f466c0d1a9cbb3782ccb3ca7e" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success. If for some reason, sqlite3_initialize() is unable to initialize the library (perhaps it is unable to allocate a needed resource such as a mutex) it returns an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">sqlite3_initialize（）例程成功返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;。如果由于某种原因sqlite3_initialize（）无法初始化库（也许无法分配所需的资源，例如互斥锁），则它将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;以外的&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7cfd6fb2b2f9b6bef5dc2729044b616aa2e46340" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success. If for some reason, sqlite3_initialize() is unable to initialize the library (perhaps it is unable to allocate a needed resource such as a mutex) it returns an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; other than &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">sqlite3_initialize（）例程成功返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。如果由于某种原因sqlite3_initialize（）无法初始化库（也许无法分配所需的资源，例如互斥锁），则它将返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;以外的&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="004164880e4716eb9f6522ffa56490d8e1026730" translate="yes" xml:space="preserve">
          <source>The sqlite3_int64 and sqlite3_uint64 are the preferred type definitions. The sqlite_int64 and sqlite_uint64 types are supported for backwards compatibility only.</source>
          <target state="translated">sqlite3_int64和 sqlite3_uint64是首选类型定义。sqlite_int64和 sqlite_uint64类型只支持向后兼容。</target>
        </trans-unit>
        <trans-unit id="7d87f3d7209e128d2babe00e667401d22d9cc8a5" translate="yes" xml:space="preserve">
          <source>The sqlite3_int64 and sqlite_int64 types can store integer values between -9223372036854775808 and +9223372036854775807 inclusive. The sqlite3_uint64 and sqlite_uint64 types can store integer values between 0 and +18446744073709551615 inclusive.</source>
          <target state="translated">sqlite3_int64和sqlite_int64类型可以存储-9223372036854775808和+9223372036854775807(含)之间的整数值。sqlite3_uint64和sqlite_uint64类型可以存储0和+18446744073709551615(含)之间的整数值。</target>
        </trans-unit>
        <trans-unit id="d1945cfc4228bc66b1032ca0f61bc88893782d0c" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statement count reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eba8c8e6f99b81a907173174c705f9ed98298ab" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statements reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="translated">sqlite3_interrupt（D）调用将一直有效，直到&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上所有当前正在运行的SQL语句完成为止。在sqlite3_interrupt（）调用之后且正在运行的语句达到零之前启动的任何新SQL语句都被中断，就好像它们在sqlite3_interrupt（）调用之前已在运行一样。在运行语句计数达到零之后启动的新SQL语句不受sqlite3_interrupt（）的影响。在没有运行中的SQL语句时发生的对sqlite3_interrupt（D）的调用是无操作的，并且对在sqlite3_interrupt（）调用返回后启动的SQL语句没有影响。</target>
        </trans-unit>
        <trans-unit id="397354330de52f0df08035b92ede80f0eda59fd9" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statement count reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6b86af3fa8ce3c883af892e74e82bdad0554e41" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statements reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="translated">sqlite3_interrupt（D）调用将一直有效，直到&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上所有当前正在运行的SQL语句完成为止。在sqlite3_interrupt（）调用之后且正在运行的语句达到零之前启动的任何新SQL语句都被中断，就好像它们在sqlite3_interrupt（）调用之前已在运行一样。在运行语句计数达到零之后启动的新SQL语句不受sqlite3_interrupt（）的影响。在没有运行中的SQL语句时发生的对sqlite3_interrupt（D）的调用是无操作的，并且对在sqlite3_interrupt（）调用返回后启动的SQL语句没有影响。</target>
        </trans-unit>
        <trans-unit id="3bfe2e62ea9486a964b648fd6403e7edfa3b65f8" translate="yes" xml:space="preserve">
          <source>The sqlite3_keyword_check(Z,L) interface checks to see whether or not the L-byte UTF8 identifier that Z points to is a keyword, returning non-zero if it is and zero if not.</source>
          <target state="translated">sqlite3_keyword_check(Z,L)接口检查Z指向的L字节UTF8标识符是否是关键字,如果是,返回非零,如果不是,返回零。</target>
        </trans-unit>
        <trans-unit id="d4d8092bdf6d249db5e6e39b2ccbee0c913272c1" translate="yes" xml:space="preserve">
          <source>The sqlite3_keyword_count() interface returns the number of distinct keywords understood by SQLite.</source>
          <target state="translated">sqlite3_keyword_count()接口返回SQLite所理解的不同关键字的数量。</target>
        </trans-unit>
        <trans-unit id="dc0acf41ffb529d44b2ebca13529ac325b17bad2" translate="yes" xml:space="preserve">
          <source>The sqlite3_keyword_name(N,Z,L) interface finds the N-th keyword and makes *Z point to that keyword expressed as UTF8 and writes the number of bytes in the keyword into *L. The string that *Z points to is not zero-terminated. The sqlite3_keyword_name(N,Z,L) routine returns SQLITE_OK if N is within bounds and SQLITE_ERROR if not. If either Z or L are NULL or invalid pointers then calls to sqlite3_keyword_name(N,Z,L) result in undefined behavior.</source>
          <target state="translated">sqlite3_keyword_name(N,Z,L)接口找到第N个关键字,并使*Z指向该关键字,用UTF8表示,并将关键字的字节数写入*L中。*Z指向的字符串不以零结尾。sqlite3_keyword_name(N,Z,L)例程如果N在范围内则返回SQLITE_OK,如果不在范围内则返回SQLITE_ERROR。如果Z或L是NULL或无效指针,那么对sqlite3_keyword_name(N,Z,L)的调用将导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="0a1d77fc76c131dee5ee5dd030d6d5133cee00d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_last_insert_rowid(D) interface usually returns the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the most recent successful &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; into a rowid table or &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; on database connection D. Inserts into &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are not recorded. If no successful &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;s into rowid tables have ever occurred on the database connection D, then sqlite3_last_insert_rowid(D) returns zero.</source>
          <target state="translated">所述sqlite3_last_insert_rowid（d）接口通常返回&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;最近成功的&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;成一个rowid表或&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;上的数据库连接D.插入到&lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表不被记录。如果在数据库连接D上没有成功向rowid表&lt;a href=&quot;../lang_insert&quot;&gt;插入INSERT&lt;/a&gt;，则sqlite3_last_insert_rowid（D）返回零。</target>
        </trans-unit>
        <trans-unit id="96cc17a506c60ac9000086a1e0105e51d535d45e" translate="yes" xml:space="preserve">
          <source>The sqlite3_last_insert_rowid(D) interface usually returns the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the most recent successful &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; into a rowid table or &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; on database connection D. Inserts into &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are not recorded. If no successful &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;s into rowid tables have ever occurred on the database connection D, then sqlite3_last_insert_rowid(D) returns zero.</source>
          <target state="translated">所述sqlite3_last_insert_rowid（d）接口通常返回&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;最近成功的&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;成一个rowid表或&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;上的数据库连接D.插入到&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表不被记录。如果在数据库连接D上没有成功向rowid表&lt;a href=&quot;lang_insert&quot;&gt;插入INSERT&lt;/a&gt;，则sqlite3_last_insert_rowid（D）返回零。</target>
        </trans-unit>
        <trans-unit id="97d28d93a8572fd39455b44f97795fb1531500e9" translate="yes" xml:space="preserve">
          <source>The sqlite3_load_extension() interface attempts to load an &lt;a href=&quot;../loadext&quot;&gt;SQLite extension&lt;/a&gt; library contained in the file zFile. If the file cannot be loaded directly, attempts are made to load with various operating-system specific extensions added. So for example, if &quot;samplelib&quot; cannot be loaded, then names like &quot;samplelib.so&quot; or &quot;samplelib.dylib&quot; or &quot;samplelib.dll&quot; might be tried also.</source>
          <target state="translated">sqlite3_load_extension（）接口尝试加载文件zFile中包含的&lt;a href=&quot;../loadext&quot;&gt;SQLite扩展&lt;/a&gt;库。如果无法直接加载文件，则尝试使用添加的各种特定于操作系统的扩展名进行加载。因此，例如，如果无法加载&amp;ldquo; samplelib&amp;rdquo;，则也可以尝试使用&amp;ldquo; samplelib.so&amp;rdquo;或&amp;ldquo; samplelib.dylib&amp;rdquo;或&amp;ldquo; samplelib.dll&amp;rdquo;之类的名称。</target>
        </trans-unit>
        <trans-unit id="29a1d12e678745f57cc139b953c6116a8408aff6" translate="yes" xml:space="preserve">
          <source>The sqlite3_load_extension() interface attempts to load an &lt;a href=&quot;loadext&quot;&gt;SQLite extension&lt;/a&gt; library contained in the file zFile. If the file cannot be loaded directly, attempts are made to load with various operating-system specific extensions added. So for example, if &quot;samplelib&quot; cannot be loaded, then names like &quot;samplelib.so&quot; or &quot;samplelib.dylib&quot; or &quot;samplelib.dll&quot; might be tried also.</source>
          <target state="translated">sqlite3_load_extension（）接口尝试加载文件zFile中包含的&lt;a href=&quot;loadext&quot;&gt;SQLite扩展&lt;/a&gt;库。如果无法直接加载文件，则尝试使用添加的各种特定于操作系统的扩展名进行加载。因此，例如，如果无法加载&amp;ldquo; samplelib&amp;rdquo;，则也可以尝试使用&amp;ldquo; samplelib.so&amp;rdquo;或&amp;ldquo; samplelib.dylib&amp;rdquo;或&amp;ldquo; samplelib.dll&amp;rdquo;之类的名称。</target>
        </trans-unit>
        <trans-unit id="653b87892cb27376af041bf3731e3304fd208799" translate="yes" xml:space="preserve">
          <source>The sqlite3_log() interface is intended for use by extensions such as virtual tables, collating functions, and SQL functions. While there is nothing to prevent an application from calling sqlite3_log(), doing so is considered bad form.</source>
          <target state="translated">sqlite3_log()接口是为虚拟表、整理函数和SQL函数等扩展而设计的。虽然没有什么可以阻止应用程序调用sqlite3_log(),但这样做被认为是不好的形式。</target>
        </trans-unit>
        <trans-unit id="c4ad2aeb0d9be1f2327ef6d534ab004f6a2b8dc6" translate="yes" xml:space="preserve">
          <source>The sqlite3_malloc() routine returns a pointer to a block of memory at least N bytes in length, where N is the parameter. If sqlite3_malloc() is unable to obtain sufficient free memory, it returns a NULL pointer. If the parameter N to sqlite3_malloc() is zero or negative then sqlite3_malloc() returns a NULL pointer.</source>
          <target state="translated">sqlite3_malloc()例程返回一个指向至少N个字节长度的内存块的指针,其中N是参数。如果sqlite3_malloc()无法获得足够的空闲内存,它将返回一个NULL指针。如果sqlite3_malloc()的参数N为0或负值,那么sqlite3_malloc()返回一个NULL指针。</target>
        </trans-unit>
        <trans-unit id="a4e65f99f4accbf5db989c9154cb81e75b9ee8ed" translate="yes" xml:space="preserve">
          <source>The sqlite3_malloc64(N) routine works just like sqlite3_malloc(N) except that N is an unsigned 64-bit integer instead of a signed 32-bit integer.</source>
          <target state="translated">sqlite3_malloc64(N)例程的工作原理和sqlite3_malloc(N)一样,只是N是一个无符号的64位整数而不是有符号的32位整数。</target>
        </trans-unit>
        <trans-unit id="6aa420d40670b164a1cce9b427bd49e7d1c5fd88" translate="yes" xml:space="preserve">
          <source>The sqlite3_mprintf() and sqlite3_vmprintf() routines write their results into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt;. The strings returned by these two routines should be released by &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;. Both routines return a NULL pointer if &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; is unable to allocate enough memory to hold the resulting string.</source>
          <target state="translated">sqlite3_mprintf（）和sqlite3_vmprintf（）例程将其结果写入从&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;获得的内存中。这两个例程返回的字符串应由&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放。如果&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;无法分配足够的内存来容纳结果字符串，则这两个例程都将返回NULL指针。</target>
        </trans-unit>
        <trans-unit id="aeca10a8c44ac57eac0c9c7f71ba952063b68cc0" translate="yes" xml:space="preserve">
          <source>The sqlite3_mprintf() and sqlite3_vmprintf() routines write their results into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt;. The strings returned by these two routines should be released by &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;. Both routines return a NULL pointer if &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; is unable to allocate enough memory to hold the resulting string.</source>
          <target state="translated">sqlite3_mprintf（）和sqlite3_vmprintf（）例程将其结果写入从&lt;a href=&quot;free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;获得的内存中。这两个例程返回的字符串应由&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放。如果&lt;a href=&quot;free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;无法分配足够的内存来容纳结果字符串，则这两个例程都将返回NULL指针。</target>
        </trans-unit>
        <trans-unit id="f0bcf6e7726b974822789eb5eaa08500974adb52" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_alloc() routine allocates a new mutex and returns a pointer to it. The sqlite3_mutex_alloc() routine returns NULL if it is unable to allocate the requested mutex. The argument to sqlite3_mutex_alloc() must one of these integer constants:</source>
          <target state="translated">sqlite3_mutex_alloc()例程分配一个新的mutex并返回一个指向它的指针。如果不能分配所需的mutex,sqlite3_mutex_alloc()例程返回NULL。sqlite3_mutex_alloc()的参数必须是这些整数常数之一。</target>
        </trans-unit>
        <trans-unit id="2d81df454ad810426381d8f39e8b57e0d9de3e46" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt to enter a mutex. If another thread is already within the mutex, sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return SQLITE_BUSY. The sqlite3_mutex_try() interface returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; upon successful entry. Mutexes created using SQLITE_MUTEX_RECURSIVE can be entered multiple times by the same thread. In such cases, the mutex must be exited an equal number of times before another thread can enter. If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE more than once, the behavior is undefined.</source>
          <target state="translated">sqlite3_mutex_enter（）和sqlite3_mutex_try（）例程尝试输入互斥量。如果互斥锁中已有另一个线程，则sqlite3_mutex_enter（）将阻塞，而sqlite3_mutex_try（）将返回SQLITE_BUSY。成功输入后，sqlite3_mutex_try（）接口将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;。使用SQLITE_MUTEX_RECURSIVE创建的互斥锁可以由同一线程多次输入。在这种情况下，互斥锁必须退出相同的次数才能进入另一个线程。如果同一线程多次尝试输入除SQLITE_MUTEX_RECURSIVE以外的任何互斥锁，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="3b45ebc24527ab0f89738f7016be66d43d5251ac" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt to enter a mutex. If another thread is already within the mutex, sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return SQLITE_BUSY. The sqlite3_mutex_try() interface returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; upon successful entry. Mutexes created using SQLITE_MUTEX_RECURSIVE can be entered multiple times by the same thread. In such cases, the mutex must be exited an equal number of times before another thread can enter. If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE more than once, the behavior is undefined.</source>
          <target state="translated">sqlite3_mutex_enter（）和sqlite3_mutex_try（）例程尝试输入互斥量。如果互斥锁中已有另一个线程，则sqlite3_mutex_enter（）将阻塞，而sqlite3_mutex_try（）将返回SQLITE_BUSY。成功输入后，sqlite3_mutex_try（）接口将返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。使用SQLITE_MUTEX_RECURSIVE创建的互斥锁可以由同一线程多次输入。在这种情况下，互斥锁必须退出相同的次数才能进入另一个线程。如果同一线程多次尝试输入除SQLITE_MUTEX_RECURSIVE以外的任何互斥锁，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="a9c3683cf3483b6e604960673d2e4ca248bc41dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_free() routine deallocates a previously allocated dynamic mutex. Attempting to deallocate a static mutex results in undefined behavior.</source>
          <target state="translated">sqlite3_mutex_free()例程会重新定位之前分配的动态互斥。试图重新定位一个静态的mutex会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="c54fa9a704452135b01172d66edadf344257a173" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_held() and sqlite3_mutex_notheld() routines are intended for use inside assert() statements. The SQLite core never uses these routines except inside an assert() and applications are advised to follow the lead of the core. The SQLite core only provides implementations for these routines when it is compiled with the SQLITE_DEBUG flag. External mutex implementations are only required to provide these routines if SQLITE_DEBUG is defined and if NDEBUG is not defined.</source>
          <target state="translated">sqlite3_mutex_held()和 sqlite3_mutex_notheld()例程是为了在 assert()语句中使用。SQLite核心除了在assert()语句中使用这些例程外,从未使用过这些例程,建议应用程序遵循核心的引导。SQLite核心只有在编译时使用SQLITE_DEBUG标志时才会提供这些例程的实现。只有在定义了SQLITE_DEBUG和没有定义NDEBUG的情况下,外部mutex实现才需要提供这些例程。</target>
        </trans-unit>
        <trans-unit id="93534cd54fb671abd29d988fdeee0858c44767d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_leave() routine exits a mutex that was previously entered by the same thread. The behavior is undefined if the mutex is not currently entered by the calling thread or is not currently allocated.</source>
          <target state="translated">sqlite3_mutex_leave()例程会退出一个之前由同一线程进入的mutex。如果mutex当前没有被调用线程进入,或者当前没有被分配,那么这个行为就没有定义。</target>
        </trans-unit>
        <trans-unit id="fb745ae4bf7930e6464af0ad23559d80e7f2b3bc" translate="yes" xml:space="preserve">
          <source>The sqlite3_open() routine returns an integer error code rather than a pointer to the sqlite3 structure as the version 2 interface did. The difference between sqlite3_open() and sqlite3_open16() is that sqlite3_open16() takes UTF-16 (in host native byte order) for the name of the database file. If a new database file needs to be created, then sqlite3_open16() sets the internal text representation to UTF-16 whereas sqlite3_open() sets the text representation to UTF-8.</source>
          <target state="translated">sqlite3_open()例程返回一个整数错误代码,而不是像版本2接口那样返回一个指向sqlite3结构的指针。sqlite3_open()和sqlite3_open16()的区别在于,sqlite3_open16()采用UTF-16(按主机本地字节顺序)作为数据库文件的名称。如果需要创建一个新的数据库文件,那么sqlite3_open16()将内部的文本表示方式设置为UTF-16,而sqlite3_open()将文本表示方式设置为UTF-8。</target>
        </trans-unit>
        <trans-unit id="49cca3441049c31bbff034c5494130978bd29358" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() can take one of the following three values, optionally combined with the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;, and/or &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flags:</source>
          <target state="translated">sqlite3_open_v2（）接口的工作方式类似于sqlite3_open（），不同之处在于它接受两个附加参数来对新数据库连接进行附加控制。 sqlite3_open_v2（）的flags参数可以采用以下三个值之一，可以选择与&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;，&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;，&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;，&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;和/或&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;标志组合：</target>
        </trans-unit>
        <trans-unit id="e598ece82e5f2beb42f8604c9b91c3f1054b0c31" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() can take one of the following three values, optionally combined with the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;, and/or &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flags:</source>
          <target state="translated">sqlite3_open_v2（）接口的工作方式类似于sqlite3_open（），不同之处在于它接受两个附加参数来对新数据库连接进行附加控制。 sqlite3_open_v2（）的flags参数可以采用以下三个值之一，可以选择与&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;，&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;，&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;，&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;和/或&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;标志组合：</target>
        </trans-unit>
        <trans-unit id="5a0142d09a66478c971c322bbffc0dda8bf83c4b" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() must include, at a minimum, one of the following three flag combinations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e55b10d2fb69bf6bea01941ab944f29f8bde45c" translate="yes" xml:space="preserve">
          <source>The sqlite3_os_init() routine does operating-system specific initialization of the SQLite library. The sqlite3_os_end() routine undoes the effect of sqlite3_os_init(). Typical tasks performed by these routines include allocation or deallocation of static resources, initialization of global variables, setting up a default &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; module, or setting up a default configuration using &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_os_init（）例程对SQLite库进行操作系统特定的初始化。sqlite3_os_end（）例程撤消sqlite3_os_init（）的影响。这些例程执行的典型任务包括静态资源的分配或释放，全局变量的初始化，设置默认的&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;模块或使用&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;设置默认配置。</target>
        </trans-unit>
        <trans-unit id="ea78da5df45c282e78d4b89a318af0ce437587df" translate="yes" xml:space="preserve">
          <source>The sqlite3_os_init() routine does operating-system specific initialization of the SQLite library. The sqlite3_os_end() routine undoes the effect of sqlite3_os_init(). Typical tasks performed by these routines include allocation or deallocation of static resources, initialization of global variables, setting up a default &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; module, or setting up a default configuration using &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_os_init（）例程对SQLite库进行操作系统特定的初始化。sqlite3_os_end（）例程撤消sqlite3_os_init（）的影响。这些例程执行的典型任务包括静态资源的分配或释放，全局变量的初始化，设置默认的&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;模块或使用&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;设置默认配置。</target>
        </trans-unit>
        <trans-unit id="3bd4022600e005736b49c1c51ead1422ec8da9c9" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache type is opaque. It is implemented by the pluggable module. The SQLite core has no knowledge of its size or internal structure and never deals with the sqlite3_pcache object except by holding and passing pointers to the object.</source>
          <target state="translated">sqlite3_pcache类型是不透明的。它是由可插拔模块实现的。SQLite核心对它的大小和内部结构一无所知,除了持有和传递指向对象的指针外,从不处理sqlite3_pcache对象。</target>
        </trans-unit>
        <trans-unit id="07293c189451b8c181f77d9379a0238420ee3f47" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache_methods structure and the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache&quot;&gt;SQLITE_CONFIG_PCACHE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache&quot;&gt;SQLITE_CONFIG_GETPCACHE&lt;/a&gt; configuration parameters are deprecated. They are replaced by a new &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; structure and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache2&quot;&gt;SQLITE_CONFIG_GETPCACHE2&lt;/a&gt; configuration parameters.</source>
          <target state="translated">不建议使用sqlite3_pcache_methods结构以及&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache&quot;&gt;SQLITE_CONFIG_PCACHE&lt;/a&gt;和&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache&quot;&gt;SQLITE_CONFIG_GETPCACHE&lt;/a&gt;配置参数。它们由新的&lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt;结构以及&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;和&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache2&quot;&gt;SQLITE_CONFIG_GETPCACHE2&lt;/a&gt;配置参数代替。</target>
        </trans-unit>
        <trans-unit id="445aa02fd749c19bfbd930e14dfefb0c0e11a4d3" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache_page object represents a single page in the page cache. The page cache will allocate instances of this object. Various methods of the page cache use pointers to instances of this object as parameters or as their return value.</source>
          <target state="translated">sqlite3_pcache_page对象代表页面缓存中的一个页面。页面缓存将分配这个对象的实例。页面缓存的各种方法使用指向这个对象实例的指针作为参数或作为它们的返回值。</target>
        </trans-unit>
        <trans-unit id="7bf15591143e8308e465ab8ab773665acb5da577" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare interface compiles a single SQL statement into byte code for later execution. This interface is now the preferred way of accessing the database.</source>
          <target state="translated">sqlite3_prepare接口将一条SQL语句编译成字节码供以后执行。这个接口现在是访问数据库的首选方式。</target>
        </trans-unit>
        <trans-unit id="63425e76fcf41641f3bb3043a50f94b90abaff47" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() interfaces are recommended for all new programs. The older interfaces (sqlite3_prepare() and sqlite3_prepare16()) are retained for backwards compatibility, but their use is discouraged. In the &quot;vX&quot; interfaces, the prepared statement that is returned (the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object) contains a copy of the original SQL text. This causes the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; interface to behave differently in three ways:</source>
          <target state="translated">对于所有新程序，建议使用sqlite3_prepare_v2（），sqlite3_prepare_v3（），sqlite3_prepare16_v2（）和sqlite3_prepare16_v3（）接口。保留了较旧的接口（sqlite3_prepare（）和sqlite3_prepare16（））是为了向后兼容，但不鼓励使用它们。在&amp;ldquo; vX&amp;rdquo;接口中，返回的准备好的语句（&lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;对象）包含原始SQL文本的副本。这导致&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;接口以三种方式表现不同：</target>
        </trans-unit>
        <trans-unit id="31c4a31d37db839c6c488798a5abc3fd1e42192d" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() interfaces are recommended for all new programs. The older interfaces (sqlite3_prepare() and sqlite3_prepare16()) are retained for backwards compatibility, but their use is discouraged. In the &quot;vX&quot; interfaces, the prepared statement that is returned (the &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object) contains a copy of the original SQL text. This causes the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; interface to behave differently in three ways:</source>
          <target state="translated">对于所有新程序，建议使用sqlite3_prepare_v2（），sqlite3_prepare_v3（），sqlite3_prepare16_v2（）和sqlite3_prepare16_v3（）接口。保留了较旧的接口（sqlite3_prepare（）和sqlite3_prepare16（））是为了向后兼容，但不鼓励使用它们。在&amp;ldquo; vX&amp;rdquo;接口中，返回的准备好的语句（&lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;对象）包含原始SQL文本的副本。这导致&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;接口以三种方式表现不同：</target>
        </trans-unit>
        <trans-unit id="1133258b4a9a31b0c0513ddc50dd402acde6047e" translate="yes" xml:space="preserve">
          <source>The sqlite3_progress_handler(D,N,X,P) interface causes the callback function X to be invoked periodically during long running calls to &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; for database connection D. An example use for this interface is to keep a GUI updated during a large query.</source>
          <target state="translated">sqlite3_progress_handler（D，N，X，P）接口使长时间运行对数据库连接D的&lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_get_table（）的&lt;/a&gt;调用会定期调用回调函数X。此接口的示例用法是在大型查询期间保持GUI更新。</target>
        </trans-unit>
        <trans-unit id="6ede9775015331a2dade498d028dbb0b1a89b661" translate="yes" xml:space="preserve">
          <source>The sqlite3_progress_handler(D,N,X,P) interface causes the callback function X to be invoked periodically during long running calls to &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; and &lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; for database connection D. An example use for this interface is to keep a GUI updated during a large query.</source>
          <target state="translated">sqlite3_progress_handler（D，N，X，P）接口使长时间运行对数据库连接D的&lt;a href=&quot;exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;，&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;和&lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table（）的&lt;/a&gt;调用会定期调用回调函数X。此接口的示例用法是在大型查询期间保持GUI更新。</target>
        </trans-unit>
        <trans-unit id="92b3414b60e6ff01e63206d0ac8d5d46b8bec0e5" translate="yes" xml:space="preserve">
          <source>The sqlite3_realloc(X,N) interface attempts to resize a prior memory allocation X to be at least N bytes. If the X parameter to sqlite3_realloc(X,N) is a NULL pointer then its behavior is identical to calling sqlite3_malloc(N). If the N parameter to sqlite3_realloc(X,N) is zero or negative then the behavior is exactly the same as calling sqlite3_free(X). sqlite3_realloc(X,N) returns a pointer to a memory allocation of at least N bytes in size or NULL if insufficient memory is available. If M is the size of the prior allocation, then min(N,M) bytes of the prior allocation are copied into the beginning of buffer returned by sqlite3_realloc(X,N) and the prior allocation is freed. If sqlite3_realloc(X,N) returns NULL and N is positive, then the prior allocation is not freed.</source>
          <target state="translated">sqlite3_realloc(X,N)接口试图调整先前的内存分配X的大小,使其至少为N个字节。如果sqlite3_realloc(X,N)的X参数是一个NULL指针,那么它的行为和调用sqlite3_malloc(N)是一样的。如果sqlite3_realloc(X,N)的N参数是0或负数,那么它的行为与调用sqlite3_free(X)完全相同。sqlite3_realloc(X,N)返回一个指针,指向一个至少有N个字节大小的内存分配,如果可用内存不足,则返回NULL。如果M是前一个分配的大小,那么前一个分配的min(N,M)字节会被复制到sqlite3_realloc(X,N)返回的缓冲区的开头,并且释放前一个分配。如果sqlite3_realloc(X,N)返回NULL,且N为正值,那么之前的分配就不会被释放。</target>
        </trans-unit>
        <trans-unit id="e95adede07a7a66375653b101c394b5d26a89fcd" translate="yes" xml:space="preserve">
          <source>The sqlite3_realloc64(X,N) interfaces works the same as sqlite3_realloc(X,N) except that N is a 64-bit unsigned integer instead of a 32-bit signed integer.</source>
          <target state="translated">sqlite3_realloc64(X,N)接口的工作原理与 sqlite3_realloc(X,N)相同,只是 N 是一个 64 位的无符号整数,而不是一个 32 位的有符号整数。</target>
        </trans-unit>
        <trans-unit id="c45df4cf90bd7042631d9142c52fed7adb90361e" translate="yes" xml:space="preserve">
          <source>The sqlite3_rebaser object is deleted by calling sqlite3rebaser_delete().</source>
          <target state="translated">通过调用sqlite3rebaser_delete()删除sqlite3_rebaser对象。</target>
        </trans-unit>
        <trans-unit id="4a286ff8214a968ca30b48466d6f539d2ffd723c" translate="yes" xml:space="preserve">
          <source>The sqlite3_release_memory() interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library. Memory used to cache database pages to improve performance is an example of non-essential memory. sqlite3_release_memory() returns the number of bytes actually freed, which might be more or less than the amount requested. The sqlite3_release_memory() routine is a no-op returning zero if SQLite is not compiled with &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">sqlite3_release_memory（）接口尝试通过释放数据库库所持有的不必要的内存分配来释放N字节的堆内存。用于缓存数据库页面以提高性能的内存是非必需内存的一个示例。 sqlite3_release_memory（）返回实际释放的字节数，它可能大于或小于请求的数量。如果未使用&lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;编译SQLite，则sqlite3_release_memory（）例程是无操作的，返回零。</target>
        </trans-unit>
        <trans-unit id="e641eb92f089a94b694e1eb10428491e684eab1f" translate="yes" xml:space="preserve">
          <source>The sqlite3_release_memory() interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library. Memory used to cache database pages to improve performance is an example of non-essential memory. sqlite3_release_memory() returns the number of bytes actually freed, which might be more or less than the amount requested. The sqlite3_release_memory() routine is a no-op returning zero if SQLite is not compiled with &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">sqlite3_release_memory（）接口尝试通过释放数据库库所持有的不必要的内存分配来释放N字节的堆内存。用于缓存数据库页面以提高性能的内存是非必需内存的一个示例。 sqlite3_release_memory（）返回实际释放的字节数，它可能大于或小于请求的数量。如果未使用&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;编译SQLite，则sqlite3_release_memory（）例程是无操作的，返回零。</target>
        </trans-unit>
        <trans-unit id="54ae89d5ac2183e89297de25b936056b80fa288f" translate="yes" xml:space="preserve">
          <source>The sqlite3_reset() function is called to reset a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; object back to its initial state, ready to be re-executed. Any SQL statement variables that had values bound to them using the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_*() API&lt;/a&gt; retain their values. Use &lt;a href=&quot;#sqlite3_clear_bindings&quot;&gt;sqlite3_clear_bindings()&lt;/a&gt; to reset the bindings.</source>
          <target state="translated">调用sqlite3_reset（）函数可将&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;对象重置回其初始状态，以备重新执行。使用&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind _ *（）API&lt;/a&gt;绑定了值的任何SQL语句变量都将保留其值。使用&lt;a href=&quot;#sqlite3_clear_bindings&quot;&gt;sqlite3_clear_bindings（）&lt;/a&gt;重置绑定。</target>
        </trans-unit>
        <trans-unit id="55cabea2592a4db5b69eb055b74aa3254a909a13" translate="yes" xml:space="preserve">
          <source>The sqlite3_reset() function is called to reset a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; object back to its initial state, ready to be re-executed. Any SQL statement variables that had values bound to them using the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_*() API&lt;/a&gt; retain their values. Use &lt;a href=&quot;clear_bindings&quot;&gt;sqlite3_clear_bindings()&lt;/a&gt; to reset the bindings.</source>
          <target state="translated">调用sqlite3_reset（）函数可将&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;对象重置回其初始状态，以备重新执行。使用&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind _ *（）API&lt;/a&gt;绑定了值的任何SQL语句变量都将保留其值。使用&lt;a href=&quot;clear_bindings&quot;&gt;sqlite3_clear_bindings（）&lt;/a&gt;重置绑定。</target>
        </trans-unit>
        <trans-unit id="ee8a502aaf09ac296b4bb201f29d8a4e68054a04" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_blob() interface sets the result from an application-defined function to be the BLOB whose content is pointed to by the second parameter and which is N bytes long where N is the third parameter.</source>
          <target state="translated">sqlite3_result_blob()接口将一个应用程序定义的函数的结果设置为BLOB,其内容由第二个参数指向,并且是N个字节长,其中N是第三个参数。</target>
        </trans-unit>
        <trans-unit id="b7904572bea3279794f2bcc9179991e08e12d408" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_double() interface sets the result from an application-defined function to be a floating point value specified by its 2nd argument.</source>
          <target state="translated">sqlite3_result_double()接口将应用程序定义函数的结果设置为由其第2个参数指定的浮点值。</target>
        </trans-unit>
        <trans-unit id="ea6209b4564a5f3773fd6febf3293c65522a4bc0" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 in native byte order. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="translated">sqlite3_result_error()和sqlite3_result_error16()函数会使实现的SQL函数抛出异常。SQLite使用sqlite3_result_error()或sqlite3_result_error16()的第2个参数指向的字符串作为错误信息的文本。SQLite将来自sqlite3_result_error()的错误信息字符串解释为UTF-8。SQLite将来自sqlite3_result_error16()的字符串按照本机字节顺序解释为UTF-16。如果 sqlite3_result_error()或 sqlite3_result_error16()的第三个参数为负值,那么 SQLite 将从第一个零字符开始的所有文本作为错误信息。如果sqlite3_result_error()或sqlite3_result_error16()的第三个参数是非负值,那么SQLite将从第2个参数中取出的那么多字节(不是字符)作为错误信息。sqlite3_result_error()和 sqlite3_result_error16()例程在返回之前,会对错误信息的文本做一个私有的拷贝。因此,调用函数可以在返回后对文本进行重新分配或修改,而不会造成伤害。sqlite3_result_error_code()函数改变了SQLite因函数出错而返回的错误代码。默认情况下,错误代码是SQLITE_ERROR。随后调用sqlite3_result_error()或sqlite3_result_error16()会将错误代码重置为SQLITE_ERROR。</target>
        </trans-unit>
        <trans-unit id="29f28f42596987edc9ab24a265ebb7acbdeb19a7" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 using the same &lt;a href=&quot;#byteorderdeterminationrules&quot;&gt;byte-order determination rules&lt;/a&gt; as &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_text16()&lt;/a&gt;. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a0bd3f253d68fda2502decfe5e0f0d13527f91" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 using the same &lt;a href=&quot;bind_blob#byteorderdeterminationrules&quot;&gt;byte-order determination rules&lt;/a&gt; as &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_text16()&lt;/a&gt;. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9161e1bf262f2df329446fa1f6bc65f20e7794e5" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error_nomem() interface causes SQLite to throw an error indicating that a memory allocation failed.</source>
          <target state="translated">sqlite3_result_error_nomem()接口使SQLite抛出一个错误,表明内存分配失败。</target>
        </trans-unit>
        <trans-unit id="9e5d46d0dedea736182a8b4b5fc9e97d872ed801" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error_toobig() interface causes SQLite to throw an error indicating that a string or BLOB is too long to represent.</source>
          <target state="translated">sqlite3_result_error_toobig()接口使SQLite抛出一个错误,表示一个字符串或BLOB太长,无法表示。</target>
        </trans-unit>
        <trans-unit id="f6cfb870f85ac1c6d72052f09d1c9de9769820e3" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_int() interface sets the return value of the application-defined function to be the 32-bit signed integer value given in the 2nd argument. The sqlite3_result_int64() interface sets the return value of the application-defined function to be the 64-bit signed integer value given in the 2nd argument.</source>
          <target state="translated">sqlite3_result_int()接口将应用程序定义的函数的返回值设置为第2个参数中给出的32位有符号的整数值。sqlite3_result_int64()接口将应用程序定义的函数的返回值设置为第2个参数中给出的64位有符号的整数值。</target>
        </trans-unit>
        <trans-unit id="6279fe7ee925bdc0e3f640e0b50cfa7f6bf20e52" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_null() interface sets the return value of the application-defined function to be NULL.</source>
          <target state="translated">sqlite3_result_null()接口将应用定义函数的返回值设置为NULL。</target>
        </trans-unit>
        <trans-unit id="16d6bb7320a3240a335aa7ac5ed9b9a1d6945bef" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_result_pointer（C，P，T，D）接口将结果设置为SQL NULL值，就像&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null（C）一样&lt;/a&gt;，不同之处在于它还将主机语言指针P或类型T与该NULL值相关联，从而使指针可以使用&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;在&lt;a href=&quot;#sqlite3_create_function&quot;&gt;应用程序定义的SQL函数中&lt;/a&gt;检索。如果D参数不为NULL，则它是指向P参数的析构函数的指针。当SQLite用P结尾时，SQLite调用D作为唯一的参数。D参数应该是静态字符串，最好是字符串文字。 sqlite3_result_pointer（）例程是为SQLite 3.20.0添加的&lt;a href=&quot;bindptr&quot;&gt;指针传递接口的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="2141ed898fc1d1e35a1c686aae779faa61d104a5" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abeb9a4e536ac73c7793be889cbe18ade4a8329e" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="870667722e41d2c1c37c185e96c88c88778eea77" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_result_pointer（C，P，T，D）接口将结果设置为SQL NULL值，就像&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null（C）一样&lt;/a&gt;，不同之处在于它还将主机语言指针P或类型T与该NULL值相关联，从而使指针可以使用&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;在&lt;a href=&quot;create_function&quot;&gt;应用程序定义的SQL函数中&lt;/a&gt;检索。如果D参数不为NULL，则它是指向P参数的析构函数的指针。当SQLite用P结尾时，SQLite调用D作为唯一的参数。D参数应该是静态字符串，最好是字符串文字。 sqlite3_result_pointer（）例程是为SQLite 3.20.0添加的&lt;a href=&quot;../bindptr&quot;&gt;指针传递接口的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="a4e926904c44e1c10338c3ed629ffd93dee056e2" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">sqlite3_result_subtype（C，T）函数使带有&lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C 的&lt;a href=&quot;#sqlite3_create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;的结果子类型成为值T。在当前版本的SQLite中，仅保留了子类型T的低8位。高阶位被丢弃。在将来的SQLite版本中，SQLite保留的子类型字节数可能会增加。</target>
        </trans-unit>
        <trans-unit id="14b620485a8968d2bc78129bd173a352a06dd552" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b466179681aeddfbf231a03d679d2648006d92dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d462f96f6d4a97e8d351d18ac7f1c494815765c7" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">sqlite3_result_subtype（C，T）函数使带有&lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C 的&lt;a href=&quot;create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;的结果子类型成为值T。在当前版本的SQLite中，仅保留了子类型T的低8位。高阶位被丢弃。在将来的SQLite版本中，SQLite保留的子类型字节数可能会增加。</target>
        </trans-unit>
        <trans-unit id="8fc6882e24d42f347f5ab25fb2f2b1c639f2f020" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_text(), sqlite3_result_text16(), sqlite3_result_text16le(), and sqlite3_result_text16be() interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively. The sqlite3_result_text64() interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;. SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces. If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character. If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result. If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated. If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT then SQLite makes a copy of the result into space obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; before it returns.</source>
          <target state="translated">sqlite3_result_text（），sqlite3_result_text16（），sqlite3_result_text16le（）和sqlite3_result_text16be（）接口将应用程序定义函数的返回值设置为文本字符串，该文本字符串表示为UTF-8，UTF-16本机字节顺序，UTF-分别为16个小字节序或UTF-16大字节序。 sqlite3_result_text64（）接口将应用程序定义的函数的返回值设置为由第五个（也是最后一个）参数指定的编码的文本字符串，该参数必须是&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE之一&lt;/a&gt;。 SQLite从sqlite3_result_text *接口的第二个参数获取应用程序的文本结果。如果sqlite3_result_text *接口的第3个参数为负，则SQLite从第2个参数到第一个零字符获取结果文本。如果sqlite3_result_text *接口的第3个参数为非负数，则将第2个参数所指向的文本字节（不是字符）作为应用程序定义的函数结果。如果第三个参数为非负数，则它必须是字符串中NUL终止处出现的字符串中字节偏移量。如果字符串中出现的任何NUL字符的字节偏移小于第3个参数的值，那么结果字符串将包含嵌入式NUL，并且对带有嵌入式NUL的字符串进行运算的表达式的结果是不确定的。如果sqlite3_result_text *接口或sqlite3_result_blob的第4个参数是非NULL指针，则SQLite在使用完该结果后将调用该函数作为文本或BLOB结果的析构函数。如果sqlite3_result_text *接口或sqlite3_result_blob的第四个参数是特殊常量SQLITE_STATIC，则SQLite假定文本或BLOB结果位于恒定空间中，并且不复制参数的内容，也不会在其内容上调用析构函数完成使用该结果。如果sqlite3_result_text *接口或sqlite3_result_blob的第四个参数是特殊常量SQLITE_TRANSIENT，则SQLite会将结果的副本复制到从中获取的空间中&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;返回之前。</target>
        </trans-unit>
        <trans-unit id="ffc0515c64350de79930cdbbfae27bfbd23133bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_text(), sqlite3_result_text16(), sqlite3_result_text16le(), and sqlite3_result_text16be() interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively. The sqlite3_result_text64() interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;. SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces. If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character. If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result. If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated. If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT then SQLite makes a copy of the result into space obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; before it returns.</source>
          <target state="translated">sqlite3_result_text（），sqlite3_result_text16（），sqlite3_result_text16le（）和sqlite3_result_text16be（）接口将应用程序定义函数的返回值设置为文本字符串，该文本字符串表示为UTF-8，UTF-16本机字节顺序，UTF-分别为16个小字节序或UTF-16大字节序。 sqlite3_result_text64（）接口将应用程序定义的函数的返回值设置为由第五个（也是最后一个）参数指定的编码的文本字符串，该参数必须是&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;，&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;，&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;或&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE之一&lt;/a&gt;。 SQLite从sqlite3_result_text *接口的第二个参数获取应用程序的文本结果。如果sqlite3_result_text *接口的第3个参数为负，则SQLite从第2个参数到第一个零字符获取结果文本。如果sqlite3_result_text *接口的第3个参数为非负数，则将第2个参数所指向的文本字节（不是字符）作为应用程序定义的函数结果。如果第三个参数为非负数，则它必须是字符串中NUL终止处出现的字符串中字节偏移量。如果字符串中出现的任何NUL字符的字节偏移小于第3个参数的值，那么结果字符串将包含嵌入式NUL，并且对带有嵌入式NUL的字符串进行运算的表达式的结果是不确定的。如果sqlite3_result_text *接口或sqlite3_result_blob的第4个参数是非NULL指针，则SQLite在使用完该结果后将调用该函数作为文本或BLOB结果的析构函数。如果sqlite3_result_text *接口或sqlite3_result_blob的第四个参数是特殊常量SQLITE_STATIC，则SQLite假定文本或BLOB结果位于恒定空间中，并且不复制参数的内容，也不会在其内容上调用析构函数完成使用该结果。如果sqlite3_result_text *接口或sqlite3_result_blob的第四个参数是特殊常量SQLITE_TRANSIENT，则SQLite会将结果的副本复制到从中获取的空间中&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;返回之前。</target>
        </trans-unit>
        <trans-unit id="66d19148a84e04f07a639f83744f212454fd9d54" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_value() interface sets the result of the application-defined function to be a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object specified by the 2nd parameter. The sqlite3_result_value() interface makes a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; so that the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; specified in the parameter may change or be deallocated after sqlite3_result_value() returns without harm. A &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object may always be used where an &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object is required, so either kind of &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object can be used with this interface.</source>
          <target state="translated">sqlite3_result_value（）接口将应用程序定义的函数的结果设置为第二个参数指定的&lt;a href=&quot;#sqlite3_value&quot;&gt;不受保护的sqlite3_value&lt;/a&gt;对象的副本。所述sqlite3_result_value（）接口使得副本&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;使得&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;使用参数中指定可以改变或sqlite3_result_value（）无伤害返回之后被释放。甲&lt;a href=&quot;#sqlite3_value&quot;&gt;保护sqlite3_value&lt;/a&gt;对象总是可以用在一个&lt;a href=&quot;#sqlite3_value&quot;&gt;无保护sqlite3_value&lt;/a&gt;需要对象，因此任一种&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;对象可以与该接口时使用。</target>
        </trans-unit>
        <trans-unit id="9c611bb0b94d5204b93fd73ea02598841b3b449f" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_value() interface sets the result of the application-defined function to be a copy of the &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object specified by the 2nd parameter. The sqlite3_result_value() interface makes a copy of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; so that the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; specified in the parameter may change or be deallocated after sqlite3_result_value() returns without harm. A &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object may always be used where an &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object is required, so either kind of &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object can be used with this interface.</source>
          <target state="translated">sqlite3_result_value（）接口将应用程序定义的函数的结果设置为第二个参数指定的&lt;a href=&quot;value&quot;&gt;不受保护的sqlite3_value&lt;/a&gt;对象的副本。所述sqlite3_result_value（）接口使得副本&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;使得&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;使用参数中指定可以改变或sqlite3_result_value（）无伤害返回之后被释放。甲&lt;a href=&quot;value&quot;&gt;保护sqlite3_value&lt;/a&gt;对象总是可以用在一个&lt;a href=&quot;value&quot;&gt;无保护sqlite3_value&lt;/a&gt;需要对象，因此任一种&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;对象可以与该接口时使用。</target>
        </trans-unit>
        <trans-unit id="3b2bde2ed5663531d681bf21defe3755de5aa926" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_zeroblob(C,N) and sqlite3_result_zeroblob64(C,N) interfaces set the result of the application-defined function to be a BLOB containing all zero bytes and N bytes in size.</source>
          <target state="translated">sqlite3_result_zeroblob(C,N)和 sqlite3_result_zeroblob64(C,N)接口将应用定义函数的结果设置为一个包含所有零字节和N个字节大小的BLOB。</target>
        </trans-unit>
        <trans-unit id="38bbbf7ab9a0945b32615ce5c77fecc3dda2b8bb" translate="yes" xml:space="preserve">
          <source>The sqlite3_rtree_geometry structure that the first argument to the xGeom callback points to has a structure shown below. The exact same sqlite3_rtree_geometry structure is used for every callback for same MATCH operator in the same query. The contents of the sqlite3_rtree_geometry structure are initialized by SQLite but are not subsequently modified. The callback is free to make changes to the pUser and xDelUser elements of the structure if desired.</source>
          <target state="translated">xGeom回调的第一个参数所指向的sqlite3_rtree_geometry结构的结构如下所示。在同一个查询中,同一个MATCH操作符的每个回调都会使用完全相同的sqlite3_rtree_geometry结构。sqlite3_rtree_geometry结构的内容是由SQLite初始化的,但随后不会被修改。如果需要,回调可以自由地对结构中的pUser和xDelUser元素进行修改。</target>
        </trans-unit>
        <trans-unit id="23ca7c4bc54ebb3192ebcd695698caa11c607135" translate="yes" xml:space="preserve">
          <source>The sqlite3_rtree_query_callback() became available with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_5.html&quot;&gt;version 3.8.5&lt;/a&gt; (2014-06-04) and is the preferred interface. The sqlite3_rtree_geometry_callback() is an older and less flexible interface that is supported for backwards compatibility.</source>
          <target state="translated">sqlite3_rtree_query_callback（）在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_5.html&quot;&gt;3.8.5&lt;/a&gt;（2014-06-04）版本中可用，并且是首选接口。sqlite3_rtree_geometry_callback（）是一个较旧且较不灵活的接口，支持向后兼容。</target>
        </trans-unit>
        <trans-unit id="a4141688a761802a4dde7063e989412b5ba08576" translate="yes" xml:space="preserve">
          <source>The sqlite3_serialize(D,S,P,F) interface returns a pointer to memory that is a serialization of the S database on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.</source>
          <target state="translated">sqlite3_serialize（D，S，P，F）接口返回指向内存的指针，该内存是&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上S数据库的序列化。如果P不是NULL指针，则将以字节为单位的数据库大小写入* P.</target>
        </trans-unit>
        <trans-unit id="fd8828a508df0b7bef3d1d62a2ae33a5520d58f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_serialize(D,S,P,F) interface returns a pointer to memory that is a serialization of the S database on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.</source>
          <target state="translated">sqlite3_serialize（D，S，P，F）接口返回指向内存的指针，该内存是&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上S数据库的序列化。如果P不是NULL指针，则将以字节为单位的数据库大小写入* P.</target>
        </trans-unit>
        <trans-unit id="d9311ad5ed8e88f0e0e396fbe1a059c5d4e870f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_set_auxdata(C,N,P,X) interface saves P as metadata for the N-th argument of the application-defined function. Subsequent calls to sqlite3_get_auxdata(C,N) return P from the most recent sqlite3_set_auxdata(C,N,P,X) call if the metadata is still valid or NULL if the metadata has been discarded. After each call to sqlite3_set_auxdata(C,N,P,X) where X is not NULL, SQLite will invoke the destructor function X with parameter P exactly once, when the metadata is discarded. SQLite is free to discard the metadata at any time, including:</source>
          <target state="translated">sqlite3_set_auxdata(C,N,P,X)接口将P保存为应用定义函数的第N个参数的元数据。如果元数据仍然有效,后续对 sqlite3_get_auxdata(C,N)的调用将返回最近一次调用 sqlite3_set_auxdata(C,N,P,X)中的 P,如果元数据被丢弃,则返回 NULL。在每次调用sqlite3_set_auxdata(C,N,P,X)后,其中X不是NULL,SQLite将在元数据被丢弃时,准确地调用参数为P的析构函数X一次。SQLite可以在任何时候自由丢弃元数据,包括。</target>
        </trans-unit>
        <trans-unit id="ce7e4094de25df6c5d0672255fe4f34354822777" translate="yes" xml:space="preserve">
          <source>The sqlite3_set_last_insert_rowid(D, R) method allows the application to set the value returned by calling sqlite3_last_insert_rowid(D) to R without inserting a row into the database.</source>
          <target state="translated">sqlite3_set_last_insert_rowid(D,R)方法允许应用程序将调用sqlite3_last_insert_rowid(D)返回的值设置为R,而无需在数据库中插入一条记录。</target>
        </trans-unit>
        <trans-unit id="e1bb92256471e00d9337dbe91acedaceec62010e" translate="yes" xml:space="preserve">
          <source>The sqlite3_sleep() function causes the current thread to suspend execution for at least a number of milliseconds specified in its parameter.</source>
          <target state="translated">sqlite3_sleep()函数会使当前线程暂停执行至少一个在其参数中指定的毫秒数。</target>
        </trans-unit>
        <trans-unit id="932dc970d1649bf3cbe1cd6e521c5a774af59735" translate="yes" xml:space="preserve">
          <source>The sqlite3_snapshot object records state information about an historical version of the database file so that it is possible to later open a new read transaction that sees that historical version of the database rather than the most recent version.</source>
          <target state="translated">sqlite3_snapshot对象记录了数据库文件历史版本的状态信息,这样以后打开一个新的读事务,就可以看到该数据库的历史版本,而不是最新的版本。</target>
        </trans-unit>
        <trans-unit id="242ec5992913a3f34748a4cb2f4099b50b723004" translate="yes" xml:space="preserve">
          <source>The sqlite3_snapshot_cmp(P1, P2) interface is used to compare the ages of two valid snapshot handles.</source>
          <target state="translated">sqlite3_snapshot_cmp(P1,P2)接口用于比较两个有效快照句柄的年龄。</target>
        </trans-unit>
        <trans-unit id="01e7a2ddf509d560437f8041b7f083cd66113cd5" translate="yes" xml:space="preserve">
          <source>The sqlite3_snprintf() routine is similar to &quot;snprintf()&quot; from the standard C library. The result is written into the buffer supplied as the second parameter whose size is given by the first parameter. Note that the order of the first two parameters is reversed from snprintf(). This is an historical accident that cannot be fixed without breaking backwards compatibility. Note also that sqlite3_snprintf() returns a pointer to its buffer instead of the number of characters actually written into the buffer. We admit that the number of characters written would be a more useful return value but we cannot change the implementation of sqlite3_snprintf() now without breaking compatibility.</source>
          <target state="translated">sqlite3_snprintf()例程类似于标准C库中的 &quot;snprintf()&quot;。结果被写入第二个参数提供的缓冲区中,缓冲区的大小由第一个参数给出。请注意,前两个参数的顺序与snprintf()相反。这是一个历史性的意外,在不破坏向后兼容性的情况下无法修复。还要注意的是,sqlite3_snprintf()返回的是一个指向缓冲区的指针,而不是实际写入缓冲区的字符数。我们承认写入的字符数是一个更有用的返回值,但是我们现在无法在不破坏兼容性的情况下改变 sqlite3_snprintf()的实现。</target>
        </trans-unit>
        <trans-unit id="a1e7c63d0192b11455ed615eabf6f8b339d7c44c" translate="yes" xml:space="preserve">
          <source>The sqlite3_soft_heap_limit64() interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite. SQLite strives to keep heap memory utilization below the soft heap limit by reducing the number of pages held in the page cache as heap memory usages approaches the limit. The soft heap limit is &quot;soft&quot; because even though SQLite strives to stay below the limit, it will exceed the limit rather than generate an &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; error. In other words, the soft heap limit is advisory only.</source>
          <target state="translated">sqlite3_soft_heap_limit64（）接口设置和/或查询SQLite可能分配的堆内存量的软限制。 SQLite努力通过在堆内存使用率接近极限时减少页面缓存中保存的页面数，将堆内存使用率保持在软堆限制以下。软堆限制是&amp;ldquo;软&amp;rdquo;的，因为即使SQLite努力保持低于该限制，它也会超过该限制而不是生成&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;错误。换句话说，软堆限制仅是建议性的。</target>
        </trans-unit>
        <trans-unit id="d5aefe7f58cf6098f950ef6aaad46d0524e32f68" translate="yes" xml:space="preserve">
          <source>The sqlite3_soft_heap_limit64() interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite. SQLite strives to keep heap memory utilization below the soft heap limit by reducing the number of pages held in the page cache as heap memory usages approaches the limit. The soft heap limit is &quot;soft&quot; because even though SQLite strives to stay below the limit, it will exceed the limit rather than generate an &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; error. In other words, the soft heap limit is advisory only.</source>
          <target state="translated">sqlite3_soft_heap_limit64（）接口设置和/或查询SQLite可能分配的堆内存量的软限制。 SQLite努力通过在堆内存使用率接近极限时减少页面缓存中保存的页面数，将堆内存使用率保持在软堆限制以下。软堆限制是&amp;ldquo;软&amp;rdquo;的，因为即使SQLite努力保持低于该限制，它也会超过该限制而不是生成&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;错误。换句话说，软堆限制仅是建议性的。</target>
        </trans-unit>
        <trans-unit id="b94ad72c9e1e61f387a8b9571668f6ee1d93f6d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_sql(P) interface returns a pointer to a copy of the UTF-8 SQL text used to create &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P if P was created by &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;. The sqlite3_expanded_sql(P) interface returns a pointer to a UTF-8 string containing the SQL text of prepared statement P with &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; expanded. The sqlite3_normalized_sql(P) interface returns a pointer to a UTF-8 string containing the normalized SQL text of prepared statement P. The semantics used to normalize a SQL statement are unspecified and subject to change. At a minimum, literal values will be replaced with suitable placeholders.</source>
          <target state="translated">如果P是由&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;创建的，则sqlite3_sql（P）接口返回指向用于创建预&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备语句&lt;/a&gt; P 的UTF-8 SQL文本副本的指针。 sqlite3_expanded_sql（P）接口返回指向UTF-8字符串的指针，该字符串包含已准备好的语句P的SQL文本，且&lt;a href=&quot;lang_expr#varparam&quot;&gt;绑定参数已&lt;/a&gt;扩展。 sqlite3_normalized_sql（P）接口返回一个指向包含已准备好的语句P的规范化SQL文本的UTF-8字符串的指针。用于规范化SQL语句的语义是未指定的，并且可能会发生更改。至少，文字值将替换为合适的占位符。</target>
        </trans-unit>
        <trans-unit id="45ba0cce80e217739aee37fc8f257b9f4497c286" translate="yes" xml:space="preserve">
          <source>The sqlite3_sql(P) interface returns a pointer to a copy of the UTF-8 SQL text used to create &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P if P was created by &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;. The sqlite3_expanded_sql(P) interface returns a pointer to a UTF-8 string containing the SQL text of prepared statement P with &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; expanded. The sqlite3_normalized_sql(P) interface returns a pointer to a UTF-8 string containing the normalized SQL text of prepared statement P. The semantics used to normalize a SQL statement are unspecified and subject to change. At a minimum, literal values will be replaced with suitable placeholders.</source>
          <target state="translated">如果P是由&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;，&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;，&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;或&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;创建的，则sqlite3_sql（P）接口返回指向用于创建预&lt;a href=&quot;stmt&quot;&gt;准备语句&lt;/a&gt; P 的UTF-8 SQL文本副本的指针。 sqlite3_expanded_sql（P）接口返回指向UTF-8字符串的指针，该字符串包含已准备好的语句P的SQL文本，且&lt;a href=&quot;../lang_expr#varparam&quot;&gt;绑定参数已&lt;/a&gt;扩展。 sqlite3_normalized_sql（P）接口返回一个指向包含已准备好的语句P的规范化SQL文本的UTF-8字符串的指针。用于规范化SQL语句的语义是未指定的，并且可能会发生更改。至少，文字值将替换为合适的占位符。</target>
        </trans-unit>
        <trans-unit id="e775091a2d75ef8eec628ca58240bb3a4c44f41a" translate="yes" xml:space="preserve">
          <source>The sqlite3_status() and sqlite3_status64() routines return SQLITE_OK on success and a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_status（）和sqlite3_status64（）例程在成功时返回SQLITE_OK，在失败时返回非零&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="08017cba5dea56fb38bd261f36812b68e5da595b" translate="yes" xml:space="preserve">
          <source>The sqlite3_status() and sqlite3_status64() routines return SQLITE_OK on success and a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_status（）和sqlite3_status64（）例程在成功时返回SQLITE_OK，在失败时返回非零&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8844a5c0b1eb32242054752c1e25f36f36feae1a" translate="yes" xml:space="preserve">
          <source>The sqlite3_step() interface returns SQLITE_BUSY if it is unable to commit a change because of a lock</source>
          <target state="translated">如果因为锁而无法提交更改,sqlite3_step()接口返回SQLITE_BUSY。</target>
        </trans-unit>
        <trans-unit id="aadfbac7c6cbfe9d27468ec7c9a622af76c3660e" translate="yes" xml:space="preserve">
          <source>The sqlite3_step() routine return SQLITE_ROW if it is returning a single row of the result set, or SQLITE_DONE if execution has completed, either normally or due to an error. It might also return SQLITE_BUSY if it is unable to open the database file. If the return value is SQLITE_ROW, then the following routines can be used to extract information about that row of the result set:</source>
          <target state="translated">sqlite3_step()例程如果返回的是结果集的单行,则返回SQLITE_ROW,如果执行完毕,无论是正常执行还是错误执行,则返回SQLITE_DONE。如果无法打开数据库文件,它也可能返回SQLITE_BUSY。如果返回值是SQLITE_ROW,那么可以使用下面的例程来提取结果集中该行的信息。</target>
        </trans-unit>
        <trans-unit id="68ecf4c95ec171ac99c79d0f7b7218a0a2a7996e" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_busy(S) interface returns true (non-zero) if the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S has been stepped at least once using &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; but has neither run to completion (returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; from &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt;) nor been reset using &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt;. The sqlite3_stmt_busy(S) interface returns false if S is a NULL pointer. If S is not a NULL pointer and is not a pointer to a valid &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; object, then the behavior is undefined and probably undesirable.</source>
          <target state="translated">如果&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt; S已使用&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（S）&lt;/a&gt;至少执行了一次，但既未执行完毕（从&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（S）&lt;/a&gt;返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;），又未使用&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（&lt;/a&gt;）重置，则sqlite3_stmt_busy（S）接口返回true（非零）。S）。如果S是NULL指针，则sqlite3_stmt_busy（S）接口返回false。如果S不是NULL指针，也不是指向有效的&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;对象的指针，则该行为是不确定的，并且可能是不希望的。</target>
        </trans-unit>
        <trans-unit id="30e9a2351b8f1f389c8c1f5ed3bb5643292d6719" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_busy(S) interface returns true (non-zero) if the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S has been stepped at least once using &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; but has neither run to completion (returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; from &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt;) nor been reset using &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt;. The sqlite3_stmt_busy(S) interface returns false if S is a NULL pointer. If S is not a NULL pointer and is not a pointer to a valid &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; object, then the behavior is undefined and probably undesirable.</source>
          <target state="translated">如果&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt; S已使用&lt;a href=&quot;step&quot;&gt;sqlite3_step（S）&lt;/a&gt;至少执行了一次，但既未执行完毕（从&lt;a href=&quot;step&quot;&gt;sqlite3_step（S）&lt;/a&gt;返回&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;），又未使用&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（&lt;/a&gt;）重置，则sqlite3_stmt_busy（S）接口返回true（非零）。S）。如果S是NULL指针，则sqlite3_stmt_busy（S）接口返回false。如果S不是NULL指针，也不是指向有效的&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;对象的指针，则该行为是不确定的，并且可能是不希望的。</target>
        </trans-unit>
        <trans-unit id="90793b88a180a777be3c4f2d53caba9bba6af112" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_isexplain(S) interface returns 1 if the prepared statement S is an EXPLAIN statement, or 2 if the statement S is an EXPLAIN QUERY PLAN. The sqlite3_stmt_isexplain(S) interface returns 0 if S is an ordinary statement or a NULL pointer.</source>
          <target state="translated">如果准备好的语句S是EXPLAIN语句,则sqlite3_stmt_isexplain(S)接口返回1;如果语句S是EXPLAIN查询计划,则返回2。如果S是普通语句或NULL指针,sqlite3_stmt_isexplain(S)接口返回0。</target>
        </trans-unit>
        <trans-unit id="959c0941832b79e09f96d36c140b66399c0579af" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_readonly(X) interface returns true (non-zero) if and only if the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; X makes no direct changes to the content of the database file.</source>
          <target state="translated">当且仅当&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt; X没有直接更改数据库文件的内容时，sqlite3_stmt_readonly（X）接口才返回true（非零）。</target>
        </trans-unit>
        <trans-unit id="ac5964bf97c9886f6e336072767ae1979506a3cb" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_readonly(X) interface returns true (non-zero) if and only if the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; X makes no direct changes to the content of the database file.</source>
          <target state="translated">当且仅当&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt; X没有直接更改数据库文件的内容时，sqlite3_stmt_readonly（X）接口才返回true（非零）。</target>
        </trans-unit>
        <trans-unit id="46d5fb0793437180a07e66953d44f2fda8b50c88" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is created using &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_str对象是使用&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;创建的。</target>
        </trans-unit>
        <trans-unit id="58bd138876e3ab72759402d62d6773f8d1b76c11" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is created using &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_str对象是使用&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;创建的。</target>
        </trans-unit>
        <trans-unit id="709d2526ae98679c1dec5db36348e5bd59a7a2cf" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is destroyed and the string it created is returned using the &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt; interface.</source>
          <target state="translated">sqlite3_str对象被销毁，并使用&lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish（）&lt;/a&gt;接口返回它创建的字符串。</target>
        </trans-unit>
        <trans-unit id="17671bb4cfc45e29421b502c0583cd6458abaa8b" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is destroyed and the string it created is returned using the &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt; interface.</source>
          <target state="translated">sqlite3_str对象被销毁，并使用&lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish（）&lt;/a&gt;接口返回它创建的字符串。</target>
        </trans-unit>
        <trans-unit id="9c1806bb938001e1be73835ffc5a99f71985fc2b" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR and if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">sqlite3_table_column_metadata（X，D，T，C，....）例程返回有关&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; X 上数据库 D中表T列C的信息。sqlite3_table_column_metadata（）接口返回SQLITE_OK并在如果指定的列存在，则使用适当的值最后五个自变量。 sqlite3_table_column_metadata（）接口返回SQLITE_ERROR，如果指定的列不存在。如果sqlite3_table_column_metadata（）的column-name参数是NULL指针，则此例程仅检查表是否存在，如果表存在则返回SQLITE_OK，否则返回SQLITE_ERROR。如果对sqlite3_table_column_metadata（X，D，T，C，...）的调用中的表名参数T为NULL，则结果为未定义行为。</target>
        </trans-unit>
        <trans-unit id="1a9220a600a9fb3a4c23d26f17dc0f839445989b" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14811f3f6309b7a46fb7b07e8c86e4e522dd9f2d" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR and if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">sqlite3_table_column_metadata（X，D，T，C，....）例程返回有关&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; X 上数据库 D中表T列C的信息。sqlite3_table_column_metadata（）接口返回SQLITE_OK并在如果指定的列存在，则使用适当的值最后五个自变量。 sqlite3_table_column_metadata（）接口返回SQLITE_ERROR，如果指定的列不存在。如果sqlite3_table_column_metadata（）的column-name参数是NULL指针，则此例程仅检查表是否存在，如果表存在则返回SQLITE_OK，否则返回SQLITE_ERROR。如果对sqlite3_table_column_metadata（X，D，T，C，...）的调用中的表名参数T为NULL，则结果为未定义行为。</target>
        </trans-unit>
        <trans-unit id="1c11863e106d03a5d69e9f5e41b5782d50d0ba8d" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f71c56bc991c72ab07825bab1be2b2926a3b41" translate="yes" xml:space="preserve">
          <source>The sqlite3_test_control() interface is used to read out internal state of SQLite and to inject faults into SQLite for testing purposes. The first parameter is an operation code that determines the number, meaning, and operation of all subsequent parameters.</source>
          <target state="translated">sqlite3_test_control()接口用于读出SQLite的内部状态,并向SQLite注入故障,以达到测试的目的。第一个参数是一个操作代码,决定了后续所有参数的数量、意义和操作。</target>
        </trans-unit>
        <trans-unit id="5082c0760e0921243970779b3672c52191342376" translate="yes" xml:space="preserve">
          <source>The sqlite3_threadsafe() function returns zero if and only if SQLite was compiled with mutexing code omitted due to the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time option being set to 0.</source>
          <target state="translated">当且仅当由于将&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE的&lt;/a&gt;编译时选项设置为0 而省略了静音代码的情况下编译SQLite时，sqlite3_threadsafe（）函数才返回零。</target>
        </trans-unit>
        <trans-unit id="a21f6ed50c99e2696e83c890474c76bf238b4d0d" translate="yes" xml:space="preserve">
          <source>The sqlite3_threadsafe() function returns zero if and only if SQLite was compiled with mutexing code omitted due to the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time option being set to 0.</source>
          <target state="translated">当且仅当由于将&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE的&lt;/a&gt;编译时选项设置为0 而省略了静音代码的情况下编译SQLite时，sqlite3_threadsafe（）函数才返回零。</target>
        </trans-unit>
        <trans-unit id="bda43267162a3774849f8ead3ae62d9dfab76a35" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace() callbacks occur before each statement is executed, not when the statement is compiled.</source>
          <target state="translated">sqlite3_trace()回调发生在每条语句执行之前,而不是在语句编译时。</target>
        </trans-unit>
        <trans-unit id="1ffc76f2d02a8dff2313298df0260161ca209b9b" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2() interface is intended to replace the legacy interfaces &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_profile()&lt;/a&gt;, both of which are deprecated.</source>
          <target state="translated">sqlite3_trace_v2（）接口用于替换不推荐使用的旧接口&lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_profile（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="377ad2a0a4bd528d9de5514af64376270faee9cf" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2() interface is intended to replace the legacy interfaces &lt;a href=&quot;profile&quot;&gt;sqlite3_trace()&lt;/a&gt; and &lt;a href=&quot;profile&quot;&gt;sqlite3_profile()&lt;/a&gt;, both of which are deprecated.</source>
          <target state="translated">sqlite3_trace_v2（）接口用于替换不推荐使用的旧接口&lt;a href=&quot;profile&quot;&gt;sqlite3_trace（）&lt;/a&gt;和&lt;a href=&quot;profile&quot;&gt;sqlite3_profile（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="423d6e23fa8d1a2ce23d8999f3685bde80941a45" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2(D,M,X,P) interface registers a trace callback function X against &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, using property mask M and context pointer P. If the X callback is NULL or if the M mask is zero, then tracing is disabled. The M argument should be the bitwise OR-ed combination of zero or more &lt;a href=&quot;#SQLITE_TRACE&quot;&gt;SQLITE_TRACE&lt;/a&gt; constants.</source>
          <target state="translated">sqlite3_trace_v2（D，M，X，P）接口使用属性掩码M和上下文指针P 针对&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 注册跟踪回调函数X。如果X回调为NULL或M掩码为零，则禁用跟踪。M参数应为零或多个&lt;a href=&quot;#SQLITE_TRACE&quot;&gt;SQLITE_TRACE&lt;/a&gt;常数的按位&amp;ldquo;或&amp;rdquo;组合。</target>
        </trans-unit>
        <trans-unit id="c43af05001b13bd414732905f7825bbbb97dce0a" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2(D,M,X,P) interface registers a trace callback function X against &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, using property mask M and context pointer P. If the X callback is NULL or if the M mask is zero, then tracing is disabled. The M argument should be the bitwise OR-ed combination of zero or more &lt;a href=&quot;c_trace&quot;&gt;SQLITE_TRACE&lt;/a&gt; constants.</source>
          <target state="translated">sqlite3_trace_v2（D，M，X，P）接口使用属性掩码M和上下文指针P 针对&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 注册跟踪回调函数X。如果X回调为NULL或M掩码为零，则禁用跟踪。M参数应为零或多个&lt;a href=&quot;c_trace&quot;&gt;SQLITE_TRACE&lt;/a&gt;常数的按位&amp;ldquo;或&amp;rdquo;组合。</target>
        </trans-unit>
        <trans-unit id="99807c4e04d2f72ca0bf7cd79e0b0ccb8d1cdec6" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook() interface registers a callback function with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; identified by the first argument to be invoked whenever a row is updated, inserted or deleted in a &lt;a href=&quot;rowidtable&quot;&gt;rowid table&lt;/a&gt;. Any callback set by a previous call to this function for the same database connection is overridden.</source>
          <target state="translated">sqlite3_update_hook（）接口使用第一个参数标识的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;注册一个回调函数，只要在&lt;a href=&quot;rowidtable&quot;&gt;rowid表中&lt;/a&gt;更新，插入或删除行时就将调用该函数。先前调用此函数为同一数据库连接设置的任何回调都将被覆盖。</target>
        </trans-unit>
        <trans-unit id="f13c4b8c3d5b462597549f85fa26ca8898f02c2a" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook() interface registers a callback function with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; identified by the first argument to be invoked whenever a row is updated, inserted or deleted in a &lt;a href=&quot;../rowidtable&quot;&gt;rowid table&lt;/a&gt;. Any callback set by a previous call to this function for the same database connection is overridden.</source>
          <target state="translated">sqlite3_update_hook（）接口使用第一个参数标识的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;注册一个回调函数，只要在&lt;a href=&quot;../rowidtable&quot;&gt;rowid表中&lt;/a&gt;更新，插入或删除行时就将调用该函数。先前调用此函数为同一数据库连接设置的任何回调都将被覆盖。</target>
        </trans-unit>
        <trans-unit id="299c5d8dbf8312233913ebdfb7abe735c08c4d12" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook(D,C,P) function returns the P argument from the previous call on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call on D.</source>
          <target state="translated">sqlite3_update_hook（D，C，P）函数从同一&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上的上一次调用返回P参数，对于D上的第一次调用返回NULL。</target>
        </trans-unit>
        <trans-unit id="b7813b4170b9b916299f8d86a0cb2ffbf096aaa5" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook(D,C,P) function returns the P argument from the previous call on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call on D.</source>
          <target state="translated">sqlite3_update_hook（D，C，P）函数从同一&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上的上一次调用返回P参数，对于D上的第一次调用返回NULL。</target>
        </trans-unit>
        <trans-unit id="9e5c2049439d88f4f1e900d8863f9c93f3ca0ab3" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_boolean(F,P,B) routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P. The sqlite3_uri_boolean(F,P,B) routine returns true (1) if the value of query parameter P is one of &quot;yes&quot;, &quot;true&quot;, or &quot;on&quot; in any case or if the value begins with a non-zero number. The sqlite3_uri_boolean(F,P,B) routines returns false (0) if the value of query parameter P is one of &quot;no&quot;, &quot;false&quot;, or &quot;off&quot; in any case or if the value begins with a numeric zero. If P is not a query parameter on F or if the value of P does not match any of the above, then sqlite3_uri_boolean(F,P,B) returns (B!=0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d5885fa75b35071ed61bef7a0d72dc8a43c3b7" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_boolean(F,P,B) routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P. The sqlite3_uri_boolean(F,P,B) routine returns true (1) if the value of query parameter P is one of &quot;yes&quot;, &quot;true&quot;, or &quot;on&quot; in any case or if the value begins with a non-zero number. The sqlite3_uri_boolean(F,P,B) routines returns false (0) if the value of query parameter P is one of &quot;no&quot;, &quot;false&quot;, or &quot;off&quot; in any case or if the value begins with a numeric zero. If P is not a query parameter on F or if the value of P is does not match any of the above, then sqlite3_uri_boolean(F,P,B) returns (B!=0).</source>
          <target state="translated">sqlite3_uri_boolean(F,P,B)例程假设P是一个布尔参数,并根据P的值返回true(1)或false(0)。 sqlite3_uri_boolean(F,P,B)例程在任何情况下,如果查询参数P的值是 &quot;yes&quot;、&quot;true &quot;或 &quot;on &quot;之一,或者如果该值以非零数开头,则返回true(1)。sqlite3_uri_boolean(F,P,B)例程在任何情况下,如果查询参数P的值是 &quot;no&quot;、&quot;false &quot;或 &quot;off &quot;中的一个,或者如果值以数字0开头,则返回false(0)。如果P不是F上的查询参数,或者P的值不符合上述任何一种情况,那么sqlite3_uri_boolean(F,P,B)返回(B!=0)。</target>
        </trans-unit>
        <trans-unit id="d8465d3a607ae26cbee19418630adba78c7f16b3" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_int64(F,P,D) routine converts the value of P into a 64-bit signed integer and returns that integer, or D if P does not exist. If the value of P is something other than an integer, then zero is returned.</source>
          <target state="translated">sqlite3_uri_int64(F,P,D)例程将P的值转换为一个64位有符号的整数,并返回该整数,如果P不存在,则返回D。如果P的值不是整数,则返回0。</target>
        </trans-unit>
        <trans-unit id="00f6b921b58342af7827ee6740ce3bd7da1204bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_key(F,N) returns a pointer to the name (not the value) of the N-th query parameter for filename F, or a NULL pointer if N is less than zero or greater than the number of query parameters minus 1. The N value is zero-based so N should be 0 to obtain the name of the first query parameter, 1 for the second parameter, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4924027328fd6dc74b1360ec20381b3f6724812a" translate="yes" xml:space="preserve">
          <source>The sqlite3_user_data() interface returns a copy of the pointer that was the pUserData parameter (the 5th parameter) of the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_user_data（）接口返回指针的副本，该指针是最初注册应用程序定义函数的&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;例程的pUserData参数（第5个参数）。</target>
        </trans-unit>
        <trans-unit id="bf548778e52386bbdaeeb7ac3a4e8320cb6164f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_user_data() interface returns a copy of the pointer that was the pUserData parameter (the 5th parameter) of the &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_user_data（）接口返回指针的副本，该指针是最初注册应用程序定义函数的&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;和&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;例程的pUserData参数（第5个参数）。</target>
        </trans-unit>
        <trans-unit id="ea63e7ca04dfc54c7a9a4dfd28964eb4fb6446f1" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">作为参数传递到&lt;a href=&quot;#sqlite3_create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;的实现中的sqlite3_value对象受到保护。由&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;返回的sqlite3_value对象不受保护。未受保护的sqlite3_value对象只能用作&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup（）的参数&lt;/a&gt;。该&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type（）&lt;/a&gt;系列的接口需要保护sqlite3_value对象。</target>
        </trans-unit>
        <trans-unit id="878c26369032034cf1577de94a30701d2b72bfbf" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d8545cde1bbfc4f37da956f6919362a532aef6b" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d38041b5ccb2d09a369551e816f131ddba2abad9" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">作为参数传递到&lt;a href=&quot;create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;的实现中的sqlite3_value对象受到保护。由&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;返回的sqlite3_value对象不受保护。未受保护的sqlite3_value对象只能用作&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value（）&lt;/a&gt;，&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value（）&lt;/a&gt;和&lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup（）的参数&lt;/a&gt;。该&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type（）&lt;/a&gt;系列的接口需要保护sqlite3_value对象。</target>
        </trans-unit>
        <trans-unit id="a0129b60c59e08fad26659c0f3fdb0270cff463d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_dup(V) interface makes a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object D and returns a pointer to that copy. The &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; returned is a &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object even if the input is not. The sqlite3_value_dup(V) interface returns NULL if V is NULL or if a memory allocation fails.</source>
          <target state="translated">sqlite3_value_dup（V）接口创建&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;对象D 的副本，并返回指向该副本的指针。即使输入不是，返回的&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;是&lt;a href=&quot;#sqlite3_value&quot;&gt;受保护的sqlite3_value&lt;/a&gt;对象。如果V为NULL或内存分配失败，则sqlite3_value_dup（V）接口返回NULL。</target>
        </trans-unit>
        <trans-unit id="0aa98b18c314b7d86c75837f6de77eb6d3e0637d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_dup(V) interface makes a copy of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object D and returns a pointer to that copy. The &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; returned is a &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object even if the input is not. The sqlite3_value_dup(V) interface returns NULL if V is NULL or if a memory allocation fails.</source>
          <target state="translated">sqlite3_value_dup（V）接口创建&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;对象D 的副本，并返回指向该副本的指针。即使输入不是，返回的&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;是&lt;a href=&quot;value&quot;&gt;受保护的sqlite3_value&lt;/a&gt;对象。如果V为NULL或内存分配失败，则sqlite3_value_dup（V）接口返回NULL。</target>
        </trans-unit>
        <trans-unit id="e0414ddee749e340e753046c8b57c08bdec5a9dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_free(V) interface frees an &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object previously obtained from &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. If V is a NULL pointer then sqlite3_value_free(V) is a harmless no-op.</source>
          <target state="translated">sqlite3_value_free（V）接口释放先前从&lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup（）&lt;/a&gt;获得的&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;对象。如果V是NULL指针，则sqlite3_value_free（V）是无害的无操作。</target>
        </trans-unit>
        <trans-unit id="e1cbff52a059b27e36ab50ec612e0a1c2d7433c2" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_free(V) interface frees an &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object previously obtained from &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. If V is a NULL pointer then sqlite3_value_free(V) is a harmless no-op.</source>
          <target state="translated">sqlite3_value_free（V）接口释放先前从&lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup（）&lt;/a&gt;获得的&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;对象。如果V是NULL指针，则sqlite3_value_free（V）是无害的无操作。</target>
        </trans-unit>
        <trans-unit id="7d48e35fde2b5031a0a61511df13116d92432d3c" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, and expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">如果值X源自&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind（）&lt;/a&gt;接口之一，则sqlite3_value_frombind（X）接口返回非零值。如果X来自SQL文字值，表列和表达式，则sqlite3_value_frombind（X）返回零。</target>
        </trans-unit>
        <trans-unit id="80d4668ad9e2d92c3db76ff20be74213c969d9ff" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, or an expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4099e909bffc50f671788cefdd0e00a496608c5a" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, and expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">如果值X源自&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind（）&lt;/a&gt;接口之一，则sqlite3_value_frombind（X）接口返回非零值。如果X来自SQL文字值，表列和表达式，则sqlite3_value_frombind（X）返回零。</target>
        </trans-unit>
        <trans-unit id="d098066d168e6b39abb688284c2a26c07f3bcf76" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, or an expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ba714b8f0c8b8a0a85eade6cc85a5f85674f5b" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_numeric_type() interface attempts to apply numeric affinity to the value. This means that an attempt is made to convert the value to an integer or floating point. If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed. Otherwise no conversion occurs. The &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype&lt;/a&gt; after conversion is returned.</source>
          <target state="translated">sqlite3_value_numeric_type（）接口尝试将数字亲和力应用于该值。这意味着试图将值转换为整数或浮点数。如果可以进行这种转换而不会丢失信息（换句话说，如果该值是看起来像数字的字符串），那么将执行转换。否则，将不会发生转换。返回转换后的&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;数据类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d57e13a61eeb32fc6ccab4def9ab890b09fb83b8" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_numeric_type() interface attempts to apply numeric affinity to the value. This means that an attempt is made to convert the value to an integer or floating point. If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed. Otherwise no conversion occurs. The &lt;a href=&quot;c_blob&quot;&gt;datatype&lt;/a&gt; after conversion is returned.</source>
          <target state="translated">sqlite3_value_numeric_type（）接口尝试将数字亲和力应用于该值。这意味着试图将值转换为整数或浮点数。如果可以进行这种转换而不会丢失信息（换句话说，如果该值是看起来像数字的字符串），那么将执行转换。否则，将不会发生转换。返回转换后的&lt;a href=&quot;c_blob&quot;&gt;数据类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4ec72e1543814b021a25a90d5cb860b5227da9f5" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">sqlite3_value_subtype（V）函数返回&lt;a href=&quot;#sqlite3_create_function&quot;&gt;应用程序定义的SQL函数自&lt;/a&gt;变量V的子类型。子类型信息可用于将有限量的上下文从一个SQL函数传递给另一个SQL函数。使用&lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype（）&lt;/a&gt;例程为SQL函数的返回值设置子类型。</target>
        </trans-unit>
        <trans-unit id="ac784313e8a1c8814ecb1722aed4c17998bb6a84" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9482d5c89729cab0c852ef903cf3adcd7fd134d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff11a55e63d67f21f428483b7880706f081aadf2" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">sqlite3_value_subtype（V）函数返回&lt;a href=&quot;create_function&quot;&gt;应用程序定义的SQL函数自&lt;/a&gt;变量V的子类型。子类型信息可用于将有限量的上下文从一个SQL函数传递给另一个SQL函数。使用&lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype（）&lt;/a&gt;例程为SQL函数的返回值设置子类型。</target>
        </trans-unit>
        <trans-unit id="b0e636524c92f0e1651fb00be6db5e8d57af0255" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_text16() interface extracts a UTF-16 string in the native byte-order of the host machine. The sqlite3_value_text16be() and sqlite3_value_text16le() interfaces extract UTF-16 strings as big-endian and little-endian respectively.</source>
          <target state="translated">sqlite3_value_text16()接口以主机的本机字节顺序提取UTF-16字符串。sqlite3_value_text16be()和 sqlite3_value_text16le()接口分别将UTF-16字符串提取为big-endian和little-endian。</target>
        </trans-unit>
        <trans-unit id="abd8dcf49d86f46dedd1a279c57c33b107030fa7" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_type(V) interface returns the &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype code&lt;/a&gt; for the initial datatype of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object V. The returned value is one of &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL&lt;/a&gt;. Other interfaces might change the datatype for an sqlite3_value object. For example, if the datatype is initially SQLITE_INTEGER and sqlite3_value_text(V) is called to extract a text value for that integer, then subsequent calls to sqlite3_value_type(V) might return SQLITE_TEXT. Whether or not a persistent internal datatype conversion occurs is undefined and may change from one release of SQLite to the next.</source>
          <target state="translated">sqlite3_value_type（V）接口返回&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;对象V 的初始数据类型的&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;数据类型代码&lt;/a&gt;。返回值是&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;，&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;，&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;，&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;或&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL之一&lt;/a&gt;。其他接口可能会更改sqlite3_value对象的数据类型。例如，如果数据类型最初是SQLITE_INTEGER，并且调用sqlite3_value_text（V）提取该整数的文本值，则随后对sqlite3_value_type（V）的调用可能返回SQLITE_TEXT。不确定是否发生持久内部数据类型转换，并且可能会从一个SQLite版本更改为另一个版本。</target>
        </trans-unit>
        <trans-unit id="9cdf3c345651dd059fa86a01b992ffdfc67b3546" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_type(V) interface returns the &lt;a href=&quot;c_blob&quot;&gt;datatype code&lt;/a&gt; for the initial datatype of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object V. The returned value is one of &lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL&lt;/a&gt;. Other interfaces might change the datatype for an sqlite3_value object. For example, if the datatype is initially SQLITE_INTEGER and sqlite3_value_text(V) is called to extract a text value for that integer, then subsequent calls to sqlite3_value_type(V) might return SQLITE_TEXT. Whether or not a persistent internal datatype conversion occurs is undefined and may change from one release of SQLite to the next.</source>
          <target state="translated">sqlite3_value_type（V）接口返回&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;对象V 的初始数据类型的&lt;a href=&quot;c_blob&quot;&gt;数据类型代码&lt;/a&gt;。返回值是&lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;，&lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;，&lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;，&lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;或&lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL之一&lt;/a&gt;。其他接口可能会更改sqlite3_value对象的数据类型。例如，如果数据类型最初是SQLITE_INTEGER，并且调用sqlite3_value_text（V）提取该整数的文本值，则随后对sqlite3_value_type（V）的调用可能返回SQLITE_TEXT。不确定是否发生持久内部数据类型转换，并且可能会从一个SQLite版本更改为另一个版本。</target>
        </trans-unit>
        <trans-unit id="9fd8993db96d6be0a53b95ff8fe5c5a06191a2c2" translate="yes" xml:space="preserve">
          <source>The sqlite3_version[] string constant contains the text of &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; macro. The sqlite3_libversion() function returns a pointer to the to the sqlite3_version[] string constant. The sqlite3_libversion() function is provided for use in DLLs since DLL users usually do not have direct access to string constants within the DLL. The sqlite3_libversion_number() function returns an integer equal to &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;. The sqlite3_sourceid() function returns a pointer to a string constant whose value is the same as the &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macro. Except if SQLite is built using an edited copy of &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt;, then the last four characters of the hash might be different from &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;.</source>
          <target state="translated">sqlite3_version []字符串常量包含&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;宏的文本。 sqlite3_libversion（）函数返回一个指向sqlite3_version []字符串常量的指针。提供sqlite3_libversion（）函数供DLL使用，因为DLL用户通常无法直接访问DLL中的字符串常量。 sqlite3_libversion_number（）函数返回一个等于&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;的整数。 sqlite3_sourceid（）函数返回一个指向字符串常量的指针，该字符串常量的值与&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C预处理器宏相同。除非SQLite是使用&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;的编辑副本构建的，否则哈希的最后四个字符可能与&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;不同。</target>
        </trans-unit>
        <trans-unit id="a807d081504ff9864c4a0f322dee10127ba34ee0" translate="yes" xml:space="preserve">
          <source>The sqlite3_version[] string constant contains the text of &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; macro. The sqlite3_libversion() function returns a pointer to the to the sqlite3_version[] string constant. The sqlite3_libversion() function is provided for use in DLLs since DLL users usually do not have direct access to string constants within the DLL. The sqlite3_libversion_number() function returns an integer equal to &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;. The sqlite3_sourceid() function returns a pointer to a string constant whose value is the same as the &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macro. Except if SQLite is built using an edited copy of &lt;a href=&quot;../amalgamation&quot;&gt;the amalgamation&lt;/a&gt;, then the last four characters of the hash might be different from &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;.</source>
          <target state="translated">sqlite3_version []字符串常量包含&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt;宏的文本。 sqlite3_libversion（）函数返回一个指向sqlite3_version []字符串常量的指针。提供sqlite3_libversion（）函数供DLL使用，因为DLL用户通常无法直接访问DLL中的字符串常量。 sqlite3_libversion_number（）函数返回一个等于&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;的整数。 sqlite3_sourceid（）函数返回一个指向字符串常量的指针，该字符串常量的值与&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C预处理器宏相同。除非SQLite是使用&lt;a href=&quot;../amalgamation&quot;&gt;合并&lt;/a&gt;的编辑副本构建的，否则哈希的最后四个字符可能与&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;不同。</target>
        </trans-unit>
        <trans-unit id="b7f0635e95ae6f97edbc2a13b7ebfc89ee7bf9a3" translate="yes" xml:space="preserve">
          <source>The sqlite3_vfs_find() interface returns a pointer to a VFS given its name. Names are case sensitive. Names are zero-terminated UTF-8 strings. If there is no match, a NULL pointer is returned. If zVfsName is NULL then the default VFS is returned.</source>
          <target state="translated">sqlite3_vfs_find()接口返回一个给定名称的VFS指针。名称是区分大小写的,名称是零结尾的UTF-8字符串。名称是以零结尾的UTF-8字符串,如果没有匹配,返回一个NULL指针。如果没有匹配,将返回一个NULL指针。如果zVfsName为NULL,则返回默认的VFS。</target>
        </trans-unit>
        <trans-unit id="88892501427d74185f6b1bff1e11e202173ae158" translate="yes" xml:space="preserve">
          <source>The sqlite3_vsnprintf() routine is a varargs version of sqlite3_snprintf().</source>
          <target state="translated">sqlite3_vsnprintf()例程是 sqlite3_snprintf()的一个varargs版本。</target>
        </trans-unit>
        <trans-unit id="bfe11fb394a04090848d426f27d7f821bd426298" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint(D,X) is equivalent to &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;(D,X,&lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;,0,0).</source>
          <target state="translated">sqlite3_wal_checkpoint（D，X）等同于&lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;（D，X，&lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;，0,0）。</target>
        </trans-unit>
        <trans-unit id="a5b2980a50de42ca24a7d3c803dbeadfa7a488ca" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint(D,X) is equivalent to &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;(D,X,&lt;a href=&quot;c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;,0,0).</source>
          <target state="translated">sqlite3_wal_checkpoint（D，X）等同于&lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;（D，X，&lt;a href=&quot;c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;，0,0）。</target>
        </trans-unit>
        <trans-unit id="7f281b26d80df2d4297decb3bb5684de63641309" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpoint operation on database X of &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D in mode M. Status information is written back into integers pointed to by L and C. The M parameter must be a valid &lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;checkpoint mode&lt;/a&gt;:</source>
          <target state="translated">sqlite3_wal_checkpoint_v2（D，X，M，L，C）接口在模式M下对&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D的数据库X运行检查点操作。状态信息被写回到L和C所指向的整数。M参数必须为有效&lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;检查点模式&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="4f16d84b1dffbf24b61871d0a39f458136f5ce78" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpoint operation on database X of &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D in mode M. Status information is written back into integers pointed to by L and C. The M parameter must be a valid &lt;a href=&quot;c_checkpoint_full&quot;&gt;checkpoint mode&lt;/a&gt;:</source>
          <target state="translated">sqlite3_wal_checkpoint_v2（D，X，M，L，C）接口在模式M下对&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D的数据库X运行检查点操作。状态信息被写回到L和C所指向的整数。M参数必须为有效&lt;a href=&quot;c_checkpoint_full&quot;&gt;检查点模式&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="121e4ad510585a0237e3a007626cc2d427159cf6" translate="yes" xml:space="preserve">
          <source>The sqlite3changeset_apply() function automatically converts the zero-length blob back to a NULL value when updating the sqlite_stat1 table. However, if the application calls sqlite3changeset_new(), sqlite3changeset_old() or sqlite3changeset_conflict on a changeset iterator directly (including on a changeset iterator passed to a conflict-handler callback) then the X'' value is returned. The application must translate X'' to NULL itself if required.</source>
          <target state="translated">当更新sqlite_stat1表时,sqlite3changeset_apply()函数会自动将零长度的blob转换回NULL值。但是,如果应用程序直接在一个变化集迭代器上调用sqlite3changeset_new()、sqlite3changeset_old()或sqlite3changeset_conflict(包括传递给冲突处理回调的变化集迭代器),那么就会返回X''值。如果需要的话,应用程序必须自己将X''翻译成NULL。</target>
        </trans-unit>
        <trans-unit id="ab7530db4d4c9fc320d8eb6c02294cea75207425" translate="yes" xml:space="preserve">
          <source>The sqlite3rbu_open(T,A,S) function returns a pointer to an &quot;sqlite3rbu&quot; object, which is then passed into the subsequent interfaces.</source>
          <target state="translated">sqlite3rbu_open(T,A,S)函数返回一个指向 &quot;sqlite3rbu &quot;对象的指针,然后传入后续的接口。</target>
        </trans-unit>
        <trans-unit id="bcc8971708ade277f3f9ba38012f5db2060092ea" translate="yes" xml:space="preserve">
          <source>The sqlite3session_config() interface is not threadsafe. If it is invoked while any other thread is inside any other sessions method then the results are undefined. Furthermore, if it is invoked after any sessions related objects have been created, the results are also undefined.</source>
          <target state="translated">sqlite3session_config()接口不是线程安全的。如果在任何其他线程处于任何其他session方法中时调用它,那么结果是未定义的。此外,如果在任何会话相关对象被创建后调用它,结果也是未定义的。</target>
        </trans-unit>
        <trans-unit id="ed3502dd7610ba7f06fbfad0a9a6bcb2eec2c983" translate="yes" xml:space="preserve">
          <source>The sqlite3session_config() interface is used to make global configuration changes to the sessions module in order to tune it to the specific needs of the application.</source>
          <target state="translated">sqlite3session_config()接口用于对session模块进行全局配置修改,以便根据应用的具体需求进行调整。</target>
        </trans-unit>
        <trans-unit id="517ed7f5443765d182eb47f3b8b955f48af65e6e" translate="yes" xml:space="preserve">
          <source>The sqlite_compileoption_get() SQL function is a wrapper around the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get()&lt;/a&gt; C/C++ function. This routine returns the N-th compile-time option used to build SQLite or NULL if N is out of range. See also the &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;.</source>
          <target state="translated">sqlite_compileoption_get（）SQL函数是对&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get（）&lt;/a&gt; C / C ++函数的包装。此例程返回用于构建SQLite的第N个编译时选项；如果N超出范围，则返回NULL。另请参见&lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="62942f05e5a1956f6b33c8235e025eeea5e49332" translate="yes" xml:space="preserve">
          <source>The sqlite_compileoption_used() SQL function is a wrapper around the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; C/C++ function. When the argument X to sqlite_compileoption_used(X) is a string which is the name of a compile-time option, this routine returns true (1) or false (0) depending on whether or not that option was used during the build.</source>
          <target state="translated">sqlite_compileoption_used（）SQL函数是对&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used（）&lt;/a&gt; C / C ++函数的包装。当sqlite_compileoption_used（X）的参数X是作为编译时选项名称的字符串时，此例程将返回true（1）或false（0），具体取决于在构建过程中是否使用了该选项。</target>
        </trans-unit>
        <trans-unit id="029c047f81979126902e66d7c2206be9ceebe6ff" translate="yes" xml:space="preserve">
          <source>The sqlite_master table contains one row for each table, index, view, and trigger (collectively &quot;objects&quot;) in the database schema, except there is no entry for the sqlite_master table itself. The sqlite_master table contains entries for &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal schema objects&lt;/a&gt; in addition to application- and programmer-defined objects.</source>
          <target state="translated">sqlite_master表针对数据库架构中的每个表，索引，视图和触发器（统称为&amp;ldquo;对象&amp;rdquo;）包含一行，但sqlite_master表本身没有条目。sqlite_master表除了应用程序和程序员定义的对象外，还包含&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部模式对象的&lt;/a&gt;条目。</target>
        </trans-unit>
        <trans-unit id="9e701356a8021b4fb9727300fa9f7200eddb250b" translate="yes" xml:space="preserve">
          <source>The sqlite_master.name column will hold the name of the object. &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on tables cause SQLite to create &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; with names of the form &quot;sqlite_autoindex_TABLE_N&quot; where TABLE is replaced by the name of the table that contains the constraint and N is an integer beginning with 1 and increasing by one with each constraint seen in the table definition. In a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, there is no sqlite_master entry for the PRIMARY KEY, but the &quot;sqlite_autoindex_TABLE_N&quot; name is set aside for the PRIMARY KEY as if the sqlite_master entry did exist. This will affect the numbering of subsequent UNIQUE constraints. The &quot;sqlite_autoindex_TABLE_N&quot; name is never allocated for an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, either in rowid tables or WITHOUT ROWID tables.</source>
          <target state="translated">sqlite_master.name列将保存对象的名称。&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;表上的UNIQUE&lt;/a&gt;和&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;约束导致SQLite创建&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部索引&lt;/a&gt;，其名称格式为&amp;ldquo; sqlite_autoindex_TABLE_N&amp;rdquo;，其中TABLE替换为包含约束的表的名称，N为以1开头并随每个约束加1的整数。在表定义中可见。在&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表中，PRIMARY KEY没有sqlite_master条目，但是PRIMARY KEY却保留了&amp;ldquo; sqlite_autoindex_TABLE_N&amp;rdquo;名称，就好像sqlite_master条目确实存在一样。这将影响随后的UNIQUE约束的编号。 &amp;ldquo; sqlite_autoindex_TABLE_N&amp;rdquo;名称永远不会分配给&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;，在rowid表或WITHOUT ROWID表中。</target>
        </trans-unit>
        <trans-unit id="3bae42f70521e9e8cd4db2168d1d1babca7ff5fa" translate="yes" xml:space="preserve">
          <source>The sqlite_master.rootpage column stores the page number of the root b-tree page for tables and indexes. For rows that define views, triggers, and virtual tables, the rootpage column is 0 or NULL.</source>
          <target state="translated">sqlite_master.rootpage列存储了表和索引的根b树页的页码。对于定义视图、触发器和虚拟表的行,rootpage列是0或NULL。</target>
        </trans-unit>
        <trans-unit id="ccb922e59255362de7628494ea2946015486eb28" translate="yes" xml:space="preserve">
          <source>The sqlite_master.sql column stores SQL text that describes the object. This SQL text is a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;, or &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement that if evaluated against the database file when it is the main database of a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; would recreate the object. The text is usually a copy of the original statement used to create the object but with normalizations applied so that the text conforms to the following rules:</source>
          <target state="translated">sqlite_master.sql列存储描述对象的SQL文本。该SQL文本是&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;，&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;，&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;，&lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;或&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;语句，如果针对数据库文件进行评估（如果它是&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;的主数据库），则会重新创建该对象。文本通常是用于创建对象的原始语句的副本，但是应用了规范化，因此文本符合以下规则：</target>
        </trans-unit>
        <trans-unit id="8ef76cce54ac5ead8c9ecfb2e98b71a272278d61" translate="yes" xml:space="preserve">
          <source>The sqlite_master.tbl_name column holds the name of a table or view that the object is associated with. For a table or view, the tbl_name column is a copy of the name column. For an index, the tbl_name is the name of the table that is indexed. For a trigger, the tbl_name column stores the name of the table or view that causes the trigger to fire.</source>
          <target state="translated">sqlite_master.tbl_name列保存了对象所关联的表或视图的名称,对于一个表或视图,tbl_name列是名称列的副本。对于表或视图来说,tbl_name列是name列的副本。对于一个索引,tbl_name是被索引的表的名称。对于触发器,tbl_name列存储的是导致触发器被触发的表或视图的名称。</target>
        </trans-unit>
        <trans-unit id="1161ce8b03e8867e67c57e405c9c72a8e7f39824" translate="yes" xml:space="preserve">
          <source>The sqlite_master.type column will be one of the following text strings: 'table', 'index', 'view', or 'trigger' according to the type of object defined. The 'table' string is used for both ordinary and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">sqlite_master.type列将是以下文本字符串之一：&amp;ldquo; table&amp;rdquo;，&amp;ldquo; index&amp;rdquo;，&amp;ldquo; view&amp;rdquo;或&amp;ldquo; trigger&amp;rdquo;（根据定义的对象类型）。'table'字符串用于普通&lt;a href=&quot;vtab&quot;&gt;表&lt;/a&gt;和虚拟表。</target>
        </trans-unit>
        <trans-unit id="8a4ecb6a492d4b0952a80c0d2b263ba43418de02" translate="yes" xml:space="preserve">
          <source>The sqlite_offset(X) SQL function is only available if SQLite is built using the &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt; compile-time option.</source>
          <target state="translated">只有使用&lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt;编译时选项构建SQLite时，sqlite_offset（X）SQL函数才可用。</target>
        </trans-unit>
        <trans-unit id="f36120db3cfab77bf49cfde55bfe4a03928e953b" translate="yes" xml:space="preserve">
          <source>The sqlite_offset(X) function returns the byte offset in the database file for the beginning of the record from which value would be read. If X is not a column in an ordinary table, then sqlite_offset(X) returns NULL. The value returned by sqlite_offset(X) might reference either the original table or an index, depending on the query. If the value X would normally be extracted from an index, the sqlite_offset(X) returns the offset to the corresponding index record. If the value X would be extracted from the original table, then sqlite_offset(X) returns the offset to the table record.</source>
          <target state="translated">sqlite_offset(X)函数返回数据库文件中读取值的记录开头的字节偏移量。如果X不是普通表中的列,那么sqlite_offset(X)返回NULL。sqlite_offset(X)返回的值可能引用原始表或索引,这取决于查询。如果值X通常会从索引中提取,那么sqlite_offset(X)返回对应索引记录的偏移量。如果值X将从原始表中提取,那么sqlite_offset(X)返回到表记录的偏移量。</target>
        </trans-unit>
        <trans-unit id="7edde881cc83be6805465c505116db44a7c10317" translate="yes" xml:space="preserve">
          <source>The sqlite_schema table contains one row for each table, index, view, and trigger (collectively &quot;objects&quot;) in the database schema, except there is no entry for the sqlite_schema table itself. The sqlite_schema table contains entries for &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal schema objects&lt;/a&gt; in addition to application- and programmer-defined objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8cd91bb0f299cfe62ef641ec65f9fe2bb5de142" translate="yes" xml:space="preserve">
          <source>The sqlite_schema table contains one row for each table, index, view, and trigger (collectively &quot;objects&quot;) in the schema, except there is no entry for the sqlite_schema table itself. See the &lt;a href=&quot;fileformat2#ffschema&quot;&gt;schema storage&lt;/a&gt; subsection of the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; documentation for additional information on how SQLite uses the sqlite_schema table internally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b38e5a9d3444c64ea7992a244995da2b49b851" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.name column will hold the name of the object. (&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on tables cause SQLite to create &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; with names of the form &quot;sqlite_autoindex_TABLE_N&quot; where TABLE is replaced by the name of the table that contains the constraint and N is an integer beginning with 1 and increasing by one with each constraint seen in the table definition. In a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, there is no sqlite_schema entry for the PRIMARY KEY, but the &quot;sqlite_autoindex_TABLE_N&quot; name is set aside for the PRIMARY KEY as if the sqlite_schema entry did exist. This will affect the numbering of subsequent UNIQUE constraints. The &quot;sqlite_autoindex_TABLE_N&quot; name is never allocated for an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, either in rowid tables or WITHOUT ROWID tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e02071e2d759314e2fb363a98ec697450c31c3a5" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.name column will hold the name of the object. &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on tables cause SQLite to create &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; with names of the form &quot;sqlite_autoindex_TABLE_N&quot; where TABLE is replaced by the name of the table that contains the constraint and N is an integer beginning with 1 and increasing by one with each constraint seen in the table definition. In a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, there is no sqlite_schema entry for the PRIMARY KEY, but the &quot;sqlite_autoindex_TABLE_N&quot; name is set aside for the PRIMARY KEY as if the sqlite_schema entry did exist. This will affect the numbering of subsequent UNIQUE constraints. The &quot;sqlite_autoindex_TABLE_N&quot; name is never allocated for an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, either in rowid tables or WITHOUT ROWID tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b54e4469dd50abde5034fd8f801a4d0306037ed0" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.rootpage column stores the page number of the root b-tree page for tables and indexes. For rows that define views, triggers, and virtual tables, the rootpage column is 0 or NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6bcf89a71c75b0fa182495e5015131f7df248c" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.sql column stores SQL text that describes the object. This SQL text is a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;, or &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement that if evaluated against the database file when it is the main database of a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; would recreate the object. The text is usually a copy of the original statement used to create the object but with normalizations applied so that the text conforms to the following rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d911ebef016f1f15b28a4875cf26c113309d9fa3" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.tbl_name column holds the name of a table or view that the object is associated with. For a table or view, the tbl_name column is a copy of the name column. For an index, the tbl_name is the name of the table that is indexed. For a trigger, the tbl_name column stores the name of the table or view that causes the trigger to fire.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02a28099cf1bad8380c62abb7ce56059bbeb63ba" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.type column will be one of the following text strings: 'table', 'index', 'view', or 'trigger' according to the type of object defined. The 'table' string is used for both ordinary and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f99e581aad3bfe8af33ed6ae438c6f190e18bdd" translate="yes" xml:space="preserve">
          <source>The sqlite_sequence table is an internal table used to help implement &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;. The sqlite_sequence table is created automatically whenever any ordinary table with an AUTOINCREMENT integer primary key is created. Once created, the sqlite_sequence table exists in the sqlite_master table forever; it cannot be dropped. The schema for the sqlite_sequence table is:</source>
          <target state="translated">sqlite_sequence表是用于帮助实现&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;的内部表。每当创建具有AUTOINCREMENT整数主键的任何普通表时，都会自动创建sqlite_sequence表。创建后，sqlite_sequence表将永远存在于sqlite_master表中。它不能被丢弃。sqlite_sequence表的架构为：</target>
        </trans-unit>
        <trans-unit id="45d57d826d6c576b74670b2e5b7c281dbdfadbab" translate="yes" xml:space="preserve">
          <source>The sqlite_sequence table is an internal table used to help implement &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;. The sqlite_sequence table is created automatically whenever any ordinary table with an AUTOINCREMENT integer primary key is created. Once created, the sqlite_sequence table exists in the sqlite_schema table forever; it cannot be dropped. The schema for the sqlite_sequence table is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2336dfb15c81a1bc2e023f4a5ddff1cb80eb4aa" translate="yes" xml:space="preserve">
          <source>The sqlite_source_id() function returns a string that identifies the specific version of the source code that was used to build the SQLite library. The string returned by sqlite_source_id() is the date and time that the source code was checked in followed by the SHA1 hash for that check-in. This function is an SQL wrapper around the &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt; C interface.</source>
          <target state="translated">sqlite_source_id（）函数返回一个字符串，该字符串标识用于构建SQLite库的源代码的特定版本。sqlite_source_id（）返回的字符串是签入源代码的日期和时间，后跟该签入的SHA1哈希。该函数是&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid（）&lt;/a&gt; C接口的SQL包装器。</target>
        </trans-unit>
        <trans-unit id="7f3f3c25482d0c81576dfc7ce696a273cc1dcba3" translate="yes" xml:space="preserve">
          <source>The sqlite_stat1 is an internal table created by the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command and used to hold supplemental information about tables and indexes that the query planner can use to help it find better ways of performing queries. Applications can update, delete from, insert into or drop the sqlite_stat1 table, but may not create or alter the sqlite_stat1 table. The schema of the sqlite_stat1 table is as follows:</source>
          <target state="translated">sqlite_stat1是由&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令创建的内部表，用于保存有关表和索引的补充信息，查询计划程序可以使用这些信息来帮助其查找执行查询的更好方法。应用程序可以更新，删除，插入或删除sqlite_stat1表，但不能创建或更改sqlite_stat1表。sqlite_stat1表的架构如下：</target>
        </trans-unit>
        <trans-unit id="eac5f10d8bfa6fc7cd030e9acfc883c862434c99" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2 entries for an index that have sqlite_stat2.sampleno between 0 and 9 inclusive are samples of the left-most key value in the index taken at evenly spaced points along the index. Let C be the number of rows in the index. Then the sampled rows are given by</source>
          <target state="translated">一个索引的sqlite_stat2.sampleno在0到9(含)之间的sqlite_stat2条目是在索引中最左边的键值沿索引均匀间隔的点上取的样本。让C为索引中的行数。那么,采样的行数由以下公式给出</target>
        </trans-unit>
        <trans-unit id="db07f0500ccc51725e75c485f7f2868bee244cc2" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2 is only created and is only used if SQLite is compiled with SQLITE_ENABLE_STAT2 and if the SQLite version number is between 3.6.18 (2009-09-11) and 3.7.8 (2011-09-19). The sqlite_stat2 table is neither read nor written by any version of SQLite before 3.6.18 nor after 3.7.8. The sqlite_stat2 table contains additional information about the distribution of keys within an index. The schema of the sqlite_stat2 table is as follows:</source>
          <target state="translated">sqlite_stat2只在SQLite被编译为SQLITE_ENABLE_STAT2,并且SQLite版本号在3.6.18(2009-09-11)和3.7.8(2011-09-19)之间的情况下才会被创建和使用。sqlite_stat2表既不能被3.6.18之前的SQLite版本读取,也不能被3.7.8之后的SQLite版本写入。sqlite_stat2表包含了关于索引内键分布的附加信息。sqlite_stat2表的模式如下。</target>
        </trans-unit>
        <trans-unit id="5e0f4c3583a4ba1380f140be5cb19d805481ba5e" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2.idx column and the sqlite_stat2.tbl column in each row of the sqlite_stat2 table identify an index described by that row. There are usually 10 rows in the sqlite_stat2 table for each index.</source>
          <target state="translated">sqlite_stat2表中每行的sqlite_stat2.idx列和sqlite_stat2.tbl列标识了该行所描述的索引。在sqlite_stat2表中,每个索引通常有10行。</target>
        </trans-unit>
        <trans-unit id="2f0561169a2bdda1f406d666ccb3f34136d53934" translate="yes" xml:space="preserve">
          <source>The sqlite_stat3 is only used if SQLite is compiled with &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; or &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; and if the SQLite version number is 3.7.9 (2011-11-01) or greater. The sqlite_stat3 table is neither read nor written by any version of SQLite before 3.7.9. If the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is used and the SQLite version number is 3.8.1 (2013-10-17) or greater, then sqlite_stat3 might be read but not written. The sqlite_stat3 table contains additional information about the distribution of keys within an index, information that the query planner can use to devise better and faster query algorithms. The schema of the sqlite_stat3 table is as follows:</source>
          <target state="translated">只有在使用&lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt;或&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;编译SQLite 且SQLite版本号为3.7.9（2011-11-01）或更高版本时，才使用sqlite_stat3。在3.7.9之前的任何版本的SQLite都无法读写sqlite_stat3表。如果使用了&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;编译时选项，并且SQLite版本号是3.8.1（2013-10-17）或更高版本，则sqlite_stat3可能被读取但未被写入。 sqlite_stat3表包含有关索引内键的分布的其他信息，查询计划人员可以使用该信息来设计更好，更快的查询算法。 sqlite_stat3表的架构如下：</target>
        </trans-unit>
        <trans-unit id="00890c07b6c2c2c2cdb8874e2a1b39eb7801c048" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4 is a generalization of the sqlite_stat3 table. The sqlite_stat3 table provides information about the left-most column of an index whereas the sqlite_stat4 table provides information about all columns of the index.</source>
          <target state="translated">sqlite_stat4是sqlite_stat3表的泛化,sqlite_stat3表提供了索引最左边的列的信息,而sqlite_stat4表提供了索引所有列的信息。sqlite_stat3表提供了一个索引最左边的列的信息,而sqlite_stat4表提供了索引所有列的信息。</target>
        </trans-unit>
        <trans-unit id="17be4a34aae6ba200b1b6b315d0554ec130a710a" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4 is only created and is only used if SQLite is compiled with &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; and if the SQLite version number is 3.8.1 (2013-10-17) or greater. The sqlite_stat4 table is neither read nor written by any version of SQLite before 3.8.1. The sqlite_stat4 table contains additional information about the distribution of keys within an index or the distribution of keys in the primary key of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table. The query planner can sometimes use the additional information in the sqlite_stat4 table to devise better and faster query algorithms. The schema of the sqlite_stat4 table is as follows:</source>
          <target state="translated">sqlite_stat4仅在使用&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;编译SQLite 且SQLite版本号为3.8.1（2013-10-17）或更高版本时创建并使用。在3.8.1之前的任何版本的SQLite都无法读写sqlite_stat4表。 sqlite_stat4表包含有关索引中的键分布或&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表的主键中的键分布的其他信息。查询计划者有时可以使用sqlite_stat4表中的其他信息来设计更好，更快的查询算法。 sqlite_stat4表的架构如下：</target>
        </trans-unit>
        <trans-unit id="dc1ec4b833f86cdac2f0f4646210820d900eb53f" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.idx column holds name of the index that the row describes, or in the case of an sqlite_stat4 entry for a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, the name of the table itself.</source>
          <target state="translated">sqlite_stat4.idx列保存该行描述的索引的名称，或者对于&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表，如果为sqlite_stat4条目，则保留该表本身的名称。</target>
        </trans-unit>
        <trans-unit id="1916f53e908a81ccd0bcf17da67632c5df8295de" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nDLt column holds a list of N integers where the K-th integer is the approximate number of entries in the index that are distinct in the first K columns and where the left-most K columns are collectively less than the left-most K columns of the sample.</source>
          <target state="translated">sqlite_stat4.nDLt列中存放了N个整数列表,其中K-th整数是指索引中前K列不同的条目数,且最左K列的总和小于样本的最左K列。</target>
        </trans-unit>
        <trans-unit id="dc87c0d99b695b0cfc2da2e070670a4e3020def1" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nEq column holds a list of N integers where the K-th integer is the approximate number of entries in the index whose left-most K columns exactly match the K left-most columns of the sample.</source>
          <target state="translated">sqlite_stat4.nEq列持有N个整数列表,其中K-th整数是索引中最左K列与样本最左K列完全匹配的条目数的近似值。</target>
        </trans-unit>
        <trans-unit id="9c81743d3d82af763c76e0a7b4201b09b9bf99f3" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nLt column holds a list of N integers where the K-th integer is the approximate number of entries in the index whose K left-most columns are collectively less than the K left-most columns of the sample.</source>
          <target state="translated">sqlite_stat4.nLt列中存放了N个整数列表,其中K-th整数是指索引中K最左列总和小于样本最左列的条目数。</target>
        </trans-unit>
        <trans-unit id="d2e1c17126c7777e5bb111d59ea8156e8e7627c8" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.sample column holds a BLOB in the &lt;a href=&quot;fileformat2#record_format&quot;&gt;record format&lt;/a&gt; that encodes the indexed columns followed by the rowid for a rowid table or by the columns of the primary key for a WITHOUT ROWID table. The sqlite_stat4.sample BLOB for the WITHOUT ROWID table itself contains just the columns of the primary key. Let the number of columns encoded by the sqlite_stat4.sample blob be N. For indexes on an ordinary rowid table, N will be one more than the number of columns indexed. For indexes on WITHOUT ROWID tables, N will be the number of columns indexed plus the number of columns in the primary key. For a WITHOUT ROWID table, N will be the number of columns in the primary key.</source>
          <target state="translated">sqlite_stat4.sample列包含&lt;a href=&quot;fileformat2#record_format&quot;&gt;记录格式&lt;/a&gt;的BLOB，该BLOB 对索引列进行编码，然后对rowid表的rowid或对WITHOUT ROWID表的主键的列进行编码。 WITHOUT ROWID表本身的sqlite_stat4.sample BLOB仅包含主键的列。假设由sqlite_stat4.sample Blob编码的列数为N。对于普通rowid表上的索引，N将比索引的列数多一。对于WITHOUT ROWID表上的索引，N将是被索引的列数加上主键中的列数。对于WITHOUT ROWID表，N将为主键中的列数。</target>
        </trans-unit>
        <trans-unit id="d3368a66552678e4208326d2b99cb82cd670c435" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.tbl column holds name of the table that owns the index that the row describes</source>
          <target state="translated">sqlite_stat4.tbl列拥有该行所描述的索引的表名。</target>
        </trans-unit>
        <trans-unit id="b005c74909d1b6008d9a724163e0fb64f6a832fd" translate="yes" xml:space="preserve">
          <source>The sqlite_version() function returns the version string for the SQLite library that is running. This function is an SQL wrapper around the &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion()&lt;/a&gt; C-interface.</source>
          <target state="translated">sqlite_version（）函数返回正在运行的SQLite库的版本字符串。此函数是&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion（）&lt;/a&gt; C接口的SQL包装器。</target>
        </trans-unit>
        <trans-unit id="eeb9bf4120a8b3a5d3dfa457114e73704c247a52" translate="yes" xml:space="preserve">
          <source>The stability of the SQLite database file format and the fact that the file format is cross-platform combine to make SQLite database files an excellent choice as an &lt;a href=&quot;appfileformat&quot;&gt;Application File Format&lt;/a&gt;. The US Library Of Congress acknowledges this by listing SQLite as a &lt;a href=&quot;locrsf&quot;&gt;recommended storage format&lt;/a&gt; for long-term preservation of digital content.</source>
          <target state="translated">SQLite数据库文件格式的稳定性以及该文件格式是跨平台的事实共同使SQLite数据库文件成为&lt;a href=&quot;appfileformat&quot;&gt;应用程序文件格式&lt;/a&gt;的绝佳选择。美国国会图书馆通过将SQLite列为长期保存数字内容的&lt;a href=&quot;locrsf&quot;&gt;推荐存储格式&lt;/a&gt;来认可这一点。</target>
        </trans-unit>
        <trans-unit id="edcbc0ddf3b476ae82b56edb901d58f590378e61" translate="yes" xml:space="preserve">
          <source>The standard SQLite source tree contains built-in VFSes for unix and windows. Alternative VFSes can be added at start-time or run-time using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface.</source>
          <target state="translated">标准的SQLite源代码树包含用于UNIX和Windows的内置VFS。可以使用&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;接口在启动时或运行时添加备用VFS 。</target>
        </trans-unit>
        <trans-unit id="3afa9cfa18cab2a00e2e2667b20527102ceccaa0" translate="yes" xml:space="preserve">
          <source>The state of the computer when a database connection is first opened is shown conceptually by the diagram at the right. The area of the diagram on the extreme right (labeled &quot;Disk&quot;) represents information stored on the mass storage device. Each rectangle is a sector. The blue color represents that the sectors contain original data. The middle area is the operating systems disk cache. At the onset of our example, the cache is cold and this is represented by leaving the rectangles of the disk cache empty. The left area of the diagram shows the content of memory for the process that is using SQLite. The database connection has just been opened and no information has been read yet, so the user space is empty.</source>
          <target state="translated">第一次打开数据库连接时,计算机的状态由右图概念性地显示出来。图中最右边的区域(标为 &quot;Disk&quot;)表示存储在大容量存储设备上的信息。每个矩形是一个扇区。蓝色代表这些扇区包含原始数据。中间的区域是操作系统的磁盘缓存。在我们的例子中,缓存是冷的,这通过将磁盘缓存的矩形留空来表示。图中左侧区域显示的是使用SQLite的进程的内存内容。数据库连接刚刚打开,还没有读取任何信息,所以用户空间是空的。</target>
        </trans-unit>
        <trans-unit id="c2357c705a667a06ce3b401fc40060cc2044167c" translate="yes" xml:space="preserve">
          <source>The statement above creates a new geopoly table named &quot;newtab&quot;. Every geopoly table contains a built-in integer &quot;rowid&quot; column and a &quot;_shape&quot; column that contains the polygon associated with that row of the table. The example above also defines three auxiliary data columns named &quot;a&quot;, &quot;b&quot;, and &quot;c&quot; that can store whatever additional information the application needs to associate with each polygon. If there is no need to store auxiliary information, the list of auxiliary columns can be omitted.</source>
          <target state="translated">上面的语句创建了一个名为 &quot;newtab &quot;的新地缘表。每个地缘表都包含一个内置的整数 &quot;rowid &quot;列和一个&quot;_shape &quot;列,其中包含了与表中该行相关联的多边形。上面的例子还定义了三个名为 &quot;a&quot;、&quot;b &quot;和 &quot;c &quot;的辅助数据列,可以存储应用程序需要与每个多边形相关联的任何附加信息。如果不需要存储辅助信息,可以省略辅助列列表。</target>
        </trans-unit>
        <trans-unit id="d3ed1fe19431b8dcc87a89320be8ef338ed550ea" translate="yes" xml:space="preserve">
          <source>The statement above has three ordinary columns, &quot;a&quot; (the PRIMARY KEY), &quot;b&quot;, and &quot;c&quot;, and two generated columns &quot;d&quot; and &quot;e&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab1aefcd821f7c6a31149043d5432c19acbdf4f" translate="yes" xml:space="preserve">
          <source>The statement above may appear syntactically incorrect to some. Refer to the section describing the &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;simple fts queries&lt;/a&gt; for an explanation.</source>
          <target state="translated">上面的陈述在某些语法上可能看起来不正确。有关说明，请参阅描述&lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;简单fts查询&lt;/a&gt;的部分。</target>
        </trans-unit>
        <trans-unit id="ecd0da773db50485ad79c3fe0dd58ba001f98f02" translate="yes" xml:space="preserve">
          <source>The statement journal is given a randomized name, not necessarily in the same directory as the main database, and is automatically deleted at the conclusion of the transaction. The size of the statement journal is proportional to the size of the change implemented by the UPDATE or INSERT statement that caused the statement journal to be created.</source>
          <target state="translated">语句日志被赋予一个随机的名称,不一定与主数据库在同一目录下,并在事务结束时自动删除。语句日志的大小与导致创建语句日志的UPDATE或INSERT语句所实现的变化大小成正比。</target>
        </trans-unit>
        <trans-unit id="abce2a89006a756ad8f25f400ff4bbb7de7fef61" translate="yes" xml:space="preserve">
          <source>The status method is basically a wrapper on the &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; C-language interface.</source>
          <target state="translated">status方法基本上是&lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status（）&lt;/a&gt; C语言接口的包装。</target>
        </trans-unit>
        <trans-unit id="c5cf163b4b04538a4fb65ca4f4e01be3e19142a2" translate="yes" xml:space="preserve">
          <source>The step function for an aggregate should always begin with a call to the &lt;a href=&quot;c3ref/aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt; routine to fetch the persistent state of the aggregate function. On the first invocation of the step() function, the aggregate context is initialized to a block of memory that is N bytes in size, where N is the second parameter to sqlite3_aggregate_context() and that memory is zeroed. On all subsequent calls to the step() function, the same block of memory is returned. Except, sqlite3_aggregate_context() might return NULL in the case of an out-of-memory error, so aggregate functions should be prepared to deal with that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2957b92cef7bca913b9349499bded01bd701447b" translate="yes" xml:space="preserve">
          <source>The strategy is to compile a single SQL statement using &lt;b&gt;sqlite_compile&lt;/b&gt; then invoke &lt;b&gt;sqlite_step&lt;/b&gt; multiple times, once for each row of output, and finally call &lt;b&gt;sqlite_finalize&lt;/b&gt; to clean up after the SQL has finished execution.</source>
          <target state="translated">该策略是使用&lt;b&gt;sqlite_compile&lt;/b&gt;编译单个SQL语句，然后多次调用&lt;b&gt;sqlite_step（&lt;/b&gt;对于输出的每一行一次），最后在SQL完成执行后调用&lt;b&gt;sqlite_finalize&lt;/b&gt;进行清理。</target>
        </trans-unit>
        <trans-unit id="7809402bc982c32307d88a8090b6d47f604ca513" translate="yes" xml:space="preserve">
          <source>The string value P4 of length P1 (bytes) is stored in register P2.</source>
          <target state="translated">长度为P1(字节)的字符串值P4存储在寄存器P2中。</target>
        </trans-unit>
        <trans-unit id="9a7f87028156aaa8a8bf754d55b553e046a12fec" translate="yes" xml:space="preserve">
          <source>The string value returned by this routine is owned and managed by the database connection. The value will be valid until the database N is &lt;a href=&quot;../lang_detach&quot;&gt;DETACH&lt;/a&gt;-ed or until the database connection closes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb38b0feb448edc668a127b1d9c6a6f2f876060a" translate="yes" xml:space="preserve">
          <source>The string value returned by this routine is owned and managed by the database connection. The value will be valid until the database N is &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt;-ed or until the database connection closes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995f4878031e82187c641f145afc9d059e07a6dd" translate="yes" xml:space="preserve">
          <source>The strings returned by sqlite3_sql(P) and sqlite3_normalized_sql(P) are managed by SQLite and are automatically freed when the prepared statement is finalized. The string returned by sqlite3_expanded_sql(P), on the other hand, is obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and must be free by the application by passing it to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_sql（P）和sqlite3_normalized_sql（P）返回的字符串由SQLite管理，并在准备好的语句完成后自动释放。另一方面，sqlite3_expanded_sql（P）返回的字符串是从&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;获取的，并且必须由应用程序通过将其传递给&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;来释放。</target>
        </trans-unit>
        <trans-unit id="6988de3a51ce0d23769efda8a1dd27ed60344374" translate="yes" xml:space="preserve">
          <source>The strings returned by sqlite3_sql(P) and sqlite3_normalized_sql(P) are managed by SQLite and are automatically freed when the prepared statement is finalized. The string returned by sqlite3_expanded_sql(P), on the other hand, is obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and must be free by the application by passing it to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_sql（P）和sqlite3_normalized_sql（P）返回的字符串由SQLite管理，并在准备好的语句完成后自动释放。另一方面，sqlite3_expanded_sql（P）返回的字符串是从&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;获取的，并且必须由应用程序通过将其传递给&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;来释放。</target>
        </trans-unit>
        <trans-unit id="3deeab5872c796defa91ce886ebd57387fbb18a8" translate="yes" xml:space="preserve">
          <source>The subquery and outer query do not both use LIMIT.</source>
          <target state="translated">子查询和外层查询都不使用LIMIT。</target>
        </trans-unit>
        <trans-unit id="77e0e5365d2489d6a42fa705340d96f457af3864" translate="yes" xml:space="preserve">
          <source>The subquery and the outer query do not both have ORDER BY clauses.</source>
          <target state="translated">子查询和外查询不都有ORDER BY子句。</target>
        </trans-unit>
        <trans-unit id="c18b6359aac0e334ed733af3b59f97a0357158e6" translate="yes" xml:space="preserve">
          <source>The subquery does not use LIMIT or the outer query does not use aggregates.</source>
          <target state="translated">子查询不使用LIMIT或外查询不使用聚合。</target>
        </trans-unit>
        <trans-unit id="b5bd1b6abc2be3885b869265a72b70231dcb2d09" translate="yes" xml:space="preserve">
          <source>The subquery does not use LIMIT or the outer query is not a join.</source>
          <target state="translated">子查询没有使用LIMIT,或者外查询不是连接。</target>
        </trans-unit>
        <trans-unit id="9a0c8ea79566123f0e4ecc1c9a70135357fff910" translate="yes" xml:space="preserve">
          <source>The subquery does not use OFFSET.</source>
          <target state="translated">子查询不使用OFFSET。</target>
        </trans-unit>
        <trans-unit id="8e09a48cd0d988ee9dac8cadad6cdbfcea3b74f2" translate="yes" xml:space="preserve">
          <source>The subquery has a FROM clause.</source>
          <target state="translated">子查询中有一个FROM子句。</target>
        </trans-unit>
        <trans-unit id="36f95cae80ab7a78b4e298e8fc4b136f62be389f" translate="yes" xml:space="preserve">
          <source>The subquery in the FROM clause computes the amount by which the inventory should be reduced for each itemId. That subquery is joined against the inventory table and the quantity of each affected inventory row is reduced by the appropriate amount.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14960c81162a6f569b4caa226a699f43010d4c7e" translate="yes" xml:space="preserve">
          <source>The subquery is not DISTINCT.</source>
          <target state="translated">子查询不是DISTINCT。</target>
        </trans-unit>
        <trans-unit id="560b14fd5f0c196e23d6c05b79eac72d5d601e25" translate="yes" xml:space="preserve">
          <source>The subquery may not be a recursive CTE.</source>
          <target state="translated">子查询可能不是递归CTE。</target>
        </trans-unit>
        <trans-unit id="7577bd701d8770ad9fc4050124549876822aa978" translate="yes" xml:space="preserve">
          <source>The substitute character (unicode codepoint 26).</source>
          <target state="translated">替换字符(unicode码点26)。</target>
        </trans-unit>
        <trans-unit id="1b25cfaa2f051cde5a374dd5fbd3d25bcae8f82b" translate="yes" xml:space="preserve">
          <source>The substr() function in the SQL view above returns the text of the rbu_control argument with the first character (the one corresponding to column &quot;i&quot;, which is not required by the FTS table) removed.</source>
          <target state="translated">上面SQL视图中的substr()函数返回rbu_control参数的文本,但去掉了第一个字符(对应于列 &quot;i &quot;的那个字符,FTS表不需要)。</target>
        </trans-unit>
        <trans-unit id="1eb749257ff54f4f9f61b55605ad1eef34135ccf" translate="yes" xml:space="preserve">
          <source>The substr(X,Y,Z) function returns a substring of input string X that begins with the Y-th character and which is Z characters long. If Z is omitted then substr(X,Y) returns all characters through the end of the string X beginning with the Y-th. The left-most character of X is number 1. If Y is negative then the first character of the substring is found by counting from the right rather than the left. If Z is negative then the abs(Z) characters preceding the Y-th character are returned. If X is a string then characters indices refer to actual UTF-8 characters. If X is a BLOB then the indices refer to bytes.</source>
          <target state="translated">函数substr(X,Y,Z)返回一个从Y-th字符开始的输入字符串X的子串,长度为Z字符。如果省略Z,那么substr(X,Y)将返回从Y-th开始的字符串X的所有字符。X的最左边的字符是1号。如果Y是负数,那么子串的第一个字符是从右边而不是左边开始数的。如果Z是负数,那么返回Y-th字符前面的abs(Z)字符。如果X是一个字符串,那么字符索引指的是实际的UTF-8字符。如果X是一个BLOB,那么索引指的是字节。</target>
        </trans-unit>
        <trans-unit id="8f8f72577e48839e2c6e724a5bcfafdf7566b512" translate="yes" xml:space="preserve">
          <source>The sum of all &quot;four&quot; values. This is used to compute &quot;avg(four)&quot;.</source>
          <target state="translated">所有 &quot;四个 &quot;值的总和。用于计算 &quot;avg(four)&quot;。</target>
        </trans-unit>
        <trans-unit id="4a5f1cfa6e3d0c304a8016c9b0a8f3f6f7afd998" translate="yes" xml:space="preserve">
          <source>The sum() and total() aggregate functions return sum of all non-NULL values in the group. If there are no non-NULL input rows then sum() returns NULL but total() returns 0.0. NULL is not normally a helpful result for the sum of no rows but the SQL standard requires it and most other SQL database engines implement sum() that way so SQLite does it in the same way in order to be compatible. The non-standard total() function is provided as a convenient way to work around this design problem in the SQL language.</source>
          <target state="translated">sum()和total()集合函数返回组中所有非NULL值的总和。如果没有非NULL的输入行,那么sum()返回NULL,但是total()返回0.0。对于没有行的总和来说,NULL通常不是一个有用的结果,但是SQL标准要求这样做,而且大多数其他的SQL数据库引擎都是这样实现sum()的,所以为了兼容,SQLite也是这样做的。提供非标准的total()函数是为了方便地解决SQL语言中的这个设计问题。</target>
        </trans-unit>
        <trans-unit id="c8cc59294c9d81aba99fd5de24fb6dc6b41b0132" translate="yes" xml:space="preserve">
          <source>The super-journal file is only created for &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; operations that involve multiple database files where at least two of the databases meet all of the following requirements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee67fa1e83c36dfa202c1d70aacf19927252737" translate="yes" xml:space="preserve">
          <source>The super-journal file is used as part of the atomic commit process when a single transaction makes changes to multiple databases that have been added to a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. The super-journal file is always located in the same directory as the main database file (the main database file is the database that is identified in the original &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that created the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;) with a randomized suffix. The super-journal file contains the names of all of the various attached auxiliary databases that were changed during the transaction. The multi-database transaction commits when the super-journal file is deleted. See the documentation titled &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit In SQLite&lt;/a&gt; for additional detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b11b2e43da7a9faed114feb7f008a51dec0a5a77" translate="yes" xml:space="preserve">
          <source>The suppression of redundant columns in the key suffix of an index entry only occurs in WITHOUT ROWID tables. In an ordinary rowid table, the index entry always ends with the rowid even if the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column is one of the columns being indexed.</source>
          <target state="translated">仅在WITHOUT ROWID表中抑制索引条目的键后缀中的冗余列。在普通的rowid表中，即使&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列是被索引的列之一，索引条目也总是以rowid结尾。</target>
        </trans-unit>
        <trans-unit id="2572ed867faedb74714d50c5898bcb75f0754e78" translate="yes" xml:space="preserve">
          <source>The swarmvtab implementation may open or close databases at any point. By default, it attempts to limit the maximum number of simultaneously open database files to nine. This is not a hard limit - it is possible to construct a scenario that will cause swarmvtab to exceed it.</source>
          <target state="translated">swarmvtab 实现可以在任何时候打开或关闭数据库。默认情况下,它试图将同时打开的数据库文件的最大数量限制为九个。这并不是一个硬性的限制-可以构建一个会导致 swarmvtab 超过这个限制的方案。</target>
        </trans-unit>
        <trans-unit id="9f9e99aa51f888cdf6630598d938ef39ae15f9a3" translate="yes" xml:space="preserve">
          <source>The sync operations that SQLite performs to help ensure integrity can be disabled at run-time using the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;synchronous pragma&lt;/a&gt;. By setting PRAGMA synchronous=OFF, all sync operations are omitted. This makes SQLite seem to run faster, but it also allows the operating system to freely reorder writes, which could result in database corruption if a power failure or hard reset occurs prior to all content reaching persistent storage.</source>
          <target state="translated">SQLite为帮助确保完整性而执行的同步操作可以在运行时使用&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;同步编译指示&lt;/a&gt;禁用。通过将PRAGMA同步设置为OFF，将忽略所有同步操作。这使得SQLite看起来运行得更快，但是它也允许操作系统自由地对写操作进行重新排序，如果在所有内容到达持久存储之前发生电源故障或硬重置，则可能导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="8ed0f1cf6ef82d0d97320ed63cceee25b526aa88" translate="yes" xml:space="preserve">
          <source>The synchronous version of SQLite is the slowest of the group in this test, but the asynchronous version is the fastest. The difference is the extra time needed to execute fsync().</source>
          <target state="translated">在这个测试中,SQLite的同步版本是这组测试中最慢的,但异步版本是最快的。区别在于执行fsync()需要额外的时间。</target>
        </trans-unit>
        <trans-unit id="88535ccaca4588c188d3dec59b74e5b6c648c437" translate="yes" xml:space="preserve">
          <source>The syntax for a window function is like this:</source>
          <target state="translated">窗口函数的语法是这样的。</target>
        </trans-unit>
        <trans-unit id="e97f2e6030323368e9626fb51e9e8ff6dc7c7f0a" translate="yes" xml:space="preserve">
          <source>The syntax for integer and floating point literals (collectively &quot;numeric literals&quot;) is shown by the following diagram:</source>
          <target state="translated">整数字和浮点字(统称为 &quot;数字字&quot;)的语法如下图所示。</target>
        </trans-unit>
        <trans-unit id="c1140f24a0825da092ba683013464dc50c75b952" translate="yes" xml:space="preserve">
          <source>The syntax for row values and the circumstances in which row values can be used are illustrated in examples below.</source>
          <target state="translated">行值的语法和可以使用行值的情况在下面的例子中进行了说明。</target>
        </trans-unit>
        <trans-unit id="0601104dedcf396efbb0c30203a6d31fd40a4a67" translate="yes" xml:space="preserve">
          <source>The syntax for the ON CONFLICT clause is as shown above for the CREATE TABLE command. For the INSERT and UPDATE commands, the keywords &quot;ON CONFLICT&quot; are replaced by &quot;OR&quot; so that the syntax reads more naturally. For example, instead of &quot;INSERT ON CONFLICT IGNORE&quot; we have &quot;INSERT OR IGNORE&quot;. The keywords change but the meaning of the clause is the same either way.</source>
          <target state="translated">ON CONFLICT子句的语法与上面CREATE TABLE命令的语法相同。对于INSERT和UPDATE命令,关键字 &quot;ON CONFLICT &quot;被 &quot;OR &quot;代替,这样语法读起来更自然。例如,我们用 &quot;INSERT OR IGNORE &quot;代替 &quot;INSERT ON CONFLICT IGNORE&quot;。关键字变了,但无论哪种方式,子句的意思都是一样的。</target>
        </trans-unit>
        <trans-unit id="f067d61a53dcb338fdf63bf3df528ef6a0487e73" translate="yes" xml:space="preserve">
          <source>The syntax looks like this:</source>
          <target state="translated">语法是这样的。</target>
        </trans-unit>
        <trans-unit id="a61a22c417283e11aa14f2ba9ecd8cd0c90ce62d" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;, &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt;, &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt;, &lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt;, &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;, &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; and many other commands all permit the user to specify a database object either by its name alone, or by a combination of its name and the name of its database. If no database is specified as part of the object reference, then SQLite searches the main, temp and all attached databases for an object with a matching name. The temp database is searched first, followed by the main database, followed all attached databases in the order that they were attached. The reference resolves to the first match found. For example:</source>
          <target state="translated">&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;，&lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt;，&lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt;，&lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt;，&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;，&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;和许多其他命令的语法都允许用户仅通过名称或通过名称和名称的组合指定数据库对象它的数据库。如果未将任何数据库指定为对象引用的一部分，则SQLite将在主数据库，临时数据库和所有附加数据库中搜索具有匹配名称的对象。首先搜索临时数据库，然后搜索主数据库，再搜索所有连接的数据库，顺序为连接的顺序。参考解析为找到的第一个匹配项。例如：</target>
        </trans-unit>
        <trans-unit id="070a4a12a4cd8479f973f088343e30dee884b914" translate="yes" xml:space="preserve">
          <source>The syntax that occurs in between the &quot;ON CONFLICT&quot; and &quot;DO&quot; keywords is called the &quot;conflict target&quot;. The conflict target specifies a specific uniqueness constraint that will trigger the upsert. The conflict target is required for DO UPDATE upserts, but is optional for DO NOTHING. When the conflict target is omitted, the upsert behavior is triggered by a violation of any uniqueness constraint on the table of the INSERT.</source>
          <target state="translated">发生在 &quot;ON CONFLICT &quot;和 &quot;DO &quot;关键字之间的语法称为 &quot;冲突目标&quot;。冲突目标指定了将触发upsert的特定唯一性约束。对于DO UPDATE upsert来说,冲突目标是必须的,但对于DO NOTHING来说,冲突目标是可选的。当冲突目标被省略时,upsert行为会被INSERT表上的任何唯一性约束的违反所触发。</target>
        </trans-unit>
        <trans-unit id="6578fb33b7ba1ef0fa58c80688a069c9340aa258" translate="yes" xml:space="preserve">
          <source>The szOsFile field is the size in bytes of the structure that defines an open file: the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. This object will be described more fully below. The point here is that each VFS implementation can define its own &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object containing whatever information the VFS implementation needs to store about an open file. SQLite needs to know how big this object is, however, in order to preallocate enough space to hold it.</source>
          <target state="translated">szOsFile字段是定义打开文件的结构的大小（以字节为单位）：&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;对象。下面将更全面地描述该目的。这里的要点是，每个VFS实现都可以定义自己的&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;对象，其中包含VFS实现需要存储的有关打开文件的任何信息。SQLite需要知道该对象的大小，以便预先分配足够的空间来容纳它。</target>
        </trans-unit>
        <trans-unit id="4160b3968588675d955230ce2bf92a9066be0932" translate="yes" xml:space="preserve">
          <source>The szOsFile field is the size of the subclassed &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; structure used by this VFS. mxPathname is the maximum length of a pathname in this VFS.</source>
          <target state="translated">szOsFile字段是此VFS使用的子类&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt;结构的大小。mxPathname是此VFS中路径名的最大长度。</target>
        </trans-unit>
        <trans-unit id="0c08ad2486a604361da59adedd8095e01f05af8a" translate="yes" xml:space="preserve">
          <source>The szOsFile field is the size of the subclassed &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; structure used by this VFS. mxPathname is the maximum length of a pathname in this VFS.</source>
          <target state="translated">szOsFile字段是此VFS使用的子类&lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt;结构的大小。mxPathname是此VFS中路径名的最大长度。</target>
        </trans-unit>
        <trans-unit id="34b2e05f8be89f8919f89034a92c2255013098b0" translate="yes" xml:space="preserve">
          <source>The t2 table is completely unused in the query above, and so the query planner is able to implement the query as if it were written:</source>
          <target state="translated">在上面的查询中,t2表完全没有使用,所以查询规划器能够像写查询一样实现查询。</target>
        </trans-unit>
        <trans-unit id="4238f21507c2ee050a84b88e1b8452b278b7cbd3" translate="yes" xml:space="preserve">
          <source>The table &quot;t1&quot; has four columns &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, and &quot;d&quot; that have no particular datatype assigned. You can store anything you want in any of those columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69666453d6f0a7ffe136a772a15ed97e78f29762" translate="yes" xml:space="preserve">
          <source>The table being clear is in the main database file if P2==0. If P2==1 then the table to be clear is in the auxiliary database file that is used to store tables create using CREATE TEMPORARY TABLE.</source>
          <target state="translated">如果P2==0,则被清除的表在主数据库文件中,如果P2==1,则被清除的表在辅助数据库文件中,该文件用于存储使用CREATE TEMPORARY TABLE创建的表。</target>
        </trans-unit>
        <trans-unit id="b84cc68d91e3409f1edcdf58fc339f372294c1e2" translate="yes" xml:space="preserve">
          <source>The table being destroyed is in the main database file if P3==0. If P3==1 then the table to be clear is in the auxiliary database file that is used to store tables create using CREATE TEMPORARY TABLE.</source>
          <target state="translated">如果P3==0,则被销毁的表在主数据库文件中,如果P3==1,则要清除的表在辅助数据库文件中,该文件用于存储使用CREATE TEMPORARY TABLE创建的表。</target>
        </trans-unit>
        <trans-unit id="41f345ab868d88acd8992e4784839c2d5c1e8639" translate="yes" xml:space="preserve">
          <source>The table below lists a few of the virtual tables implementations available for SQLite. Developers can deploy these virtual tables in their own applications, or use the implementations shown below as templates for writing their own virtual tables.</source>
          <target state="translated">下表列出了一些可用于SQLite的虚拟表实现。开发人员可以在自己的应用程序中部署这些虚拟表,或者使用下面显示的实现作为模板来编写自己的虚拟表。</target>
        </trans-unit>
        <trans-unit id="0d5035ee89279b64afd0eeb8d11272d1a3924472" translate="yes" xml:space="preserve">
          <source>The table conceptually has a number of rows and columns. But these numbers are not part of the result table itself. These numbers are obtained separately. Let N be the number of rows and M be the number of columns.</source>
          <target state="translated">该表在概念上有若干行和列。但这些数字不是结果表本身的一部分。这些数字是单独获得的。设N为行数,M为列数。</target>
        </trans-unit>
        <trans-unit id="dcf57858fad384bb52da74fd124071a651012ac9" translate="yes" xml:space="preserve">
          <source>The table has at least as many columns as recorded in the changeset, and</source>
          <target state="translated">该表的列数至少与变化集中记录的列数相同,并且</target>
        </trans-unit>
        <trans-unit id="c59c86844961ecda887187879536aa8941add7f6" translate="yes" xml:space="preserve">
          <source>The table has primary key columns in the same position as recorded in the changeset.</source>
          <target state="translated">该表的主键列与变更集中记录的位置相同。</target>
        </trans-unit>
        <trans-unit id="80f1ee5eb53df523cde7e4859fa53a41bb0e9f57" translate="yes" xml:space="preserve">
          <source>The table has the same name as the name recorded in the changeset, and</source>
          <target state="translated">该表的名称与变更集中记录的名称相同,并且。</target>
        </trans-unit>
        <trans-unit id="7d27b581c3631a8cd2d37de114b2996daa06d034" translate="yes" xml:space="preserve">
          <source>The table named in the table_info pragma can also be a view.</source>
          <target state="translated">table_info pragma中命名的表也可以是一个视图。</target>
        </trans-unit>
        <trans-unit id="79bd6ebb5ebe8eca1811d6164c483996ae2dbb59" translate="yes" xml:space="preserve">
          <source>The table named on the left-hand side of the AS keyword must appear exactly once in the FROM clause of the right-most SELECT statement of the compound select, and nowhere else.</source>
          <target state="translated">AS关键字左侧命名的表必须在复合选择的最右侧的SELECT语句的FROM子句中准确出现一次,其他地方都不能出现。</target>
        </trans-unit>
        <trans-unit id="747fb24ebf8caf800f314099b86fad330ec2bb21" translate="yes" xml:space="preserve">
          <source>The table that is being changed</source>
          <target state="translated">正在更改的表</target>
        </trans-unit>
        <trans-unit id="e089550b926c62bbc2dcb5b20ca60a982f76e723" translate="yes" xml:space="preserve">
          <source>The table-name specified as part of a DELETE statement within a trigger body must be unqualified. In other words, the</source>
          <target state="translated">作为触发器主体中DELETE语句的一部分,指定的表名必须是无限制的。换句话说,在</target>
        </trans-unit>
        <trans-unit id="f34e54cb0abeaba37df0e01490317583d5a035fb" translate="yes" xml:space="preserve">
          <source>The table-name specified as part of an UPDATE statement within a trigger body must be unqualified. In other words, the</source>
          <target state="translated">在触发器主体中作为UPDATE语句的一部分指定的表名必须是无限制的。换句话说,在触发体中指定的</target>
        </trans-unit>
        <trans-unit id="234e68825ade4fb4c6a3d0e2fe2ac2487e1f2eea" translate="yes" xml:space="preserve">
          <source>The table-valued function returns one row for each record (file, directory or symbolic link) in the zip archive. Each row has the following columns:</source>
          <target state="translated">表值函数为zip压缩包中的每条记录(文件、目录或符号链接)返回一行。每一行有以下几列。</target>
        </trans-unit>
        <trans-unit id="d7dc1f7c6b1a5d93554b66158b8eab41e9fa0f02" translate="yes" xml:space="preserve">
          <source>The table-valued function syntax may also be used to specify an alternative ranking function. In this case the text describing the ranking function should be specified as the second table-valued function argument. The following three queries are equivalent:</source>
          <target state="translated">表值函数语法也可以用来指定一个替代的排序函数,在这种情况下,应该指定描述排序函数的文本作为第二个表值函数参数。在这种情况下,描述排序函数的文本应该被指定为第二个表值函数参数。以下三个查询是等价的。</target>
        </trans-unit>
        <trans-unit id="194c5b8001842ee44aaaa2c4539d9e178d7c37bd" translate="yes" xml:space="preserve">
          <source>The table-valued functions for PRAGMA feature was added in SQLite version 3.16.0 (2017-01-02). Prior versions of SQLite cannot use this feature.</source>
          <target state="translated">在SQLite 3.16.0版本(2017-01-02)中增加了PRAGMA的表值函数功能。之前版本的SQLite不能使用该功能。</target>
        </trans-unit>
        <trans-unit id="273bdbb137f334009fcac2c6deba9c8d09edc07d" translate="yes" xml:space="preserve">
          <source>The tableZ table has a single column named &quot;INTEGER&quot;. That column has no datatype specified, but it is the PRIMARY KEY. The column is &lt;em&gt;not&lt;/em&gt; the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; for the table because it has no datatype. The &quot;INTEGER&quot; token is used as an identifier for the column name, not as a datatype keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1296ca23d366e0c8b6ad53b34a86a007a9e6fcba" translate="yes" xml:space="preserve">
          <source>The tables necessary to do full and proper unicode case folding are larger than the whole SQLite library.</source>
          <target state="translated">做完整和正确的unicode大小写折叠所需的表比整个SQLite库还要大。</target>
        </trans-unit>
        <trans-unit id="1fa68f636ed5379e184e8d386d825c36877f4a63" translate="yes" xml:space="preserve">
          <source>The tables that participate in a union-vtab can be in the same database file, or they can be in separate databases files that are &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed to the same database connection.</source>
          <target state="translated">参与union-vtab的表可以位于同一数据库文件中，也可以位于已&lt;a href=&quot;lang_attach&quot;&gt;附加&lt;/a&gt;到同一数据库连接的单独数据库文件中。</target>
        </trans-unit>
        <trans-unit id="0d9a0645c34c7b267a5cc6a578129314b8359efc" translate="yes" xml:space="preserve">
          <source>The tables_used table is intended to show which btrees of the database file are read or written by a prepared statement, both by the main statement itself but also by related triggers and foreign key actions. The columns are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30590c6f42ddca035bfcfa04a6fd54a5c5428cad" translate="yes" xml:space="preserve">
          <source>The target database may already contain a row with the same PRIMARY KEY values as specified by the INSERT change.</source>
          <target state="translated">目标数据库可能已经包含了一条与INSERT更改所指定的PRIMARY KEY值相同的记录。</target>
        </trans-unit>
        <trans-unit id="ddffb3a24b55dea30b114ff8f89840fe90c8c752" translate="yes" xml:space="preserve">
          <source>The target database may contain a row with the specified PRIMARY KEY values, but the current values of the fields that will be modified by the change may not match the original values stored within the changeset. This type of conflict is not detected when using a patchset.</source>
          <target state="translated">目标数据库可能包含一条具有指定PRIMARY KEY值的记录,但将被修改的字段的当前值可能与存储在更改集中的原始值不匹配。这种类型的冲突在使用补丁集时不会被检测到。</target>
        </trans-unit>
        <trans-unit id="9637f3da3aa12d5bcfe7a6adc7e68c320df396f3" translate="yes" xml:space="preserve">
          <source>The target database may contain a row with the specified PRIMARY KEY values, but the other fields may contain values that do not match those stored as part of the changeset. This type of conflict is not detected when using a patchset.</source>
          <target state="translated">目标数据库可能包含一条具有指定的PRIMARY KEY值的行,但其他字段可能包含的值与作为变化集的一部分存储的值不匹配。当使用补丁集时,这种类型的冲突不会被检测到。</target>
        </trans-unit>
        <trans-unit id="11c37f0367cfc6691a61d3fba7a936ab62a7d348" translate="yes" xml:space="preserve">
          <source>The target database may contain no row with the specified PRIMARY KEY values to delete.</source>
          <target state="translated">目标数据库中可能没有包含指定PRIMARY KEY值的记录要删除。</target>
        </trans-unit>
        <trans-unit id="e2b06a833985a4c35aa0208799ae843a7b65a575" translate="yes" xml:space="preserve">
          <source>The target database may contain no row with the specified PRIMARY KEY values to modify.</source>
          <target state="translated">目标数据库中可能没有包含指定PRIMARY KEY值的记录要修改。</target>
        </trans-unit>
        <trans-unit id="6f87cac991eff302d9976172f7bdf73e926bb9c2" translate="yes" xml:space="preserve">
          <source>The target database may not be in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">目标数据库可能未处于&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e79db16e64c18b69803344025e269d729d3745a5" translate="yes" xml:space="preserve">
          <source>The target table is not included in the FROM clause, unless the intent is to do a self-join against the target table. In the event of a self-join, the table in the FROM clause must be aliased to a different name than the target table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711e958f26b3fdef5ca444454f4ee0f963fc86d6" translate="yes" xml:space="preserve">
          <source>The task of the &quot;query planner&quot; is to figure out the best algorithm or &quot;query plan&quot; to accomplish an SQL statement. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26), the query planner component has been rewritten so that it runs faster and generates better plans. The rewrite is called the &quot;next generation query planner&quot; or &quot;NGQP&quot;.</source>
          <target state="translated">&amp;ldquo;查询计划器&amp;rdquo;的任务是找出完成SQL语句的最佳算法或&amp;ldquo;查询计划&amp;rdquo;。从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;版本3.8.0&lt;/a&gt;（2013-08-26）开始，查询计划程序组件已被重写，以使其运行速度更快并生成更好的计划。重写称为&amp;ldquo;下一代查询计划程序&amp;rdquo;或&amp;ldquo; NGQP&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="42a7ae31a25e761d6c699099d742c17f30af41a6" translate="yes" xml:space="preserve">
          <source>The team_id field cannot be unique because there usually multiple people on the same team. One cannot make the combination of team_id and is_team_leader unique since there are usually multiple non-leaders on each team. The solution to enforcing one leader per team is to create a unique index on team_id but restricted to those entries for which is_team_leader is true:</source>
          <target state="translated">team_id字段不能是唯一的,因为通常在同一个团队中有多个人。我们不能让team_id和is_team_leader的组合成为唯一,因为每个团队中通常有多个非领导者。强制每个团队只有一个领导者的解决方案是在team_id上创建一个唯一的索引,但仅限于那些is_team_leader为真的条目。</target>
        </trans-unit>
        <trans-unit id="0785e2dbbfabdba0d3916b209d305b3e5683f44f" translate="yes" xml:space="preserve">
          <source>The technique of having xFindFunction() return values of &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; was initially used in the implementation of the &lt;a href=&quot;geopoly&quot;&gt;Geopoly module&lt;/a&gt;. The xFindFunction() method of that module returns SQLITE_INDEX_CONSTRAINT_FUNCTION for the &lt;a href=&quot;geopoly#goverlap&quot;&gt;geopoly_overlap()&lt;/a&gt; SQL function and it returns SQLITE_INDEX_CONSTRAINT_FUNCTION+1 for the &lt;a href=&quot;geopoly#gwithin&quot;&gt;geopoly_within()&lt;/a&gt; SQL function. This permits search optimizations for queries such as:</source>
          <target state="translated">最初在&lt;a href=&quot;geopoly&quot;&gt;Geopoly模块&lt;/a&gt;的实现中使用了具有xFindFunction（）返回值&lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt;的技术。该模块返回SQLITE_INDEX_CONSTRAINT_FUNCTION为的xFindFunction（）方法&lt;a href=&quot;geopoly#goverlap&quot;&gt;geopoly_overlap（）&lt;/a&gt; SQL函数，并将其返回SQLITE_INDEX_CONSTRAINT_FUNCTION + 1为&lt;a href=&quot;geopoly#gwithin&quot;&gt;geopoly_within（）&lt;/a&gt; SQL函数。这允许对查询进行搜索优化，例如：</target>
        </trans-unit>
        <trans-unit id="2710792de033b547bac6e441ea1f9b9d8e9fc431" translate="yes" xml:space="preserve">
          <source>The temp.sqlite_parameters table only provides values for parameters in the command-line shell. The temp.sqlite_parameter table has no effect on queries that are run directly using the SQLite C-language API. Individual applications are expected to implement their own parameter binding. You can search for &quot;sqlite_parameters&quot; in the &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;command-line shell source code&lt;/a&gt; to see how the command-line shell does parameter binding, and use that as a hint for how to implement it yourself.</source>
          <target state="translated">temp.sqlite_parameters表仅提供命令行外壳程序中参数的值。temp.sqlite_parameter表对直接使用SQLite C语言API运行的查询无效。各个应用程序应实现自己的参数绑定。您可以在&lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;命令行外壳程序源代码中&lt;/a&gt;搜索&amp;ldquo; sqlite_parameters&amp;rdquo;，以查看命令行外壳程序如何进行参数绑定，并将其用作如何自己实现的提示。</target>
        </trans-unit>
        <trans-unit id="e0243e43a9e092811e1870e88e873ed47024b50d" translate="yes" xml:space="preserve">
          <source>The temporary file created by the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command exists only for the duration of the command itself. The size of the temporary file will be no larger than the original database.</source>
          <target state="translated">&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令创建的临时文件仅在命令本身存在期间存在。临时文件的大小将不大于原始数据库。</target>
        </trans-unit>
        <trans-unit id="2f2df5fab6b729ca7d2c3e78798e53760ca0b74f" translate="yes" xml:space="preserve">
          <source>The temporary files associated with the TEMP database and its rollback journal are only created if the application makes use of the &quot;CREATE TEMP TABLE&quot; statement.</source>
          <target state="translated">只有当应用程序使用 &quot;CREATE TEMP TABLE &quot;语句时,才会创建与TEMP数据库及其回滚日志相关的临时文件。</target>
        </trans-unit>
        <trans-unit id="f07c39bdad21f0453b3d046fa930925221ebb2c1" translate="yes" xml:space="preserve">
          <source>The temporary files associated with transaction control, namely the rollback journal, master journal, write-ahead log (WAL) files, and shared-memory files, are always written to disk. But the other kinds of temporary files might be stored in memory only and never written to disk. Whether or not temporary files other than the rollback, master, and statement journals are written to disk or stored only in memory depends on the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter, the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;, and on the size of the temporary file.</source>
          <target state="translated">与事务控制关联的临时文件（即回滚日志，主日志，预写日志（WAL）文件和共享内存文件）始终写入磁盘。但是其他类型的临时文件可能只存储在内存中，而不会写入磁盘。除回滚，主日志和语句日志以外的临时文件是否写入磁盘或仅存储在内存中取决于&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;编译时参数，&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;和临时文件的大小。</target>
        </trans-unit>
        <trans-unit id="408ca6d25d3ec064e51ba766d2fa74811ccbfcc3" translate="yes" xml:space="preserve">
          <source>The temporary files associated with transaction control, namely the rollback journal, super-journal, write-ahead log (WAL) files, and shared-memory files, are always written to disk. But the other kinds of temporary files might be stored in memory only and never written to disk. Whether or not temporary files other than the rollback, super, and statement journals are written to disk or stored only in memory depends on the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter, the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;, and on the size of the temporary file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ee5d948678f086d276ab61d7dad5de2797f6e5" translate="yes" xml:space="preserve">
          <source>The term number of the matching term within the full-text query expression. Terms within a query expression are numbered starting from 0 in the order that they occur.</source>
          <target state="translated">全文查询表达式中匹配术语的术语号。查询表达式中的术语按其出现的顺序从0开始编号。</target>
        </trans-unit>
        <trans-unit id="2146ad4958dfdca7b01896ef7e97e3c556f6bfc0" translate="yes" xml:space="preserve">
          <source>The term, as stored in the FTS5 index.</source>
          <target state="translated">术语,存储在快三平台5指数中。</target>
        </trans-unit>
        <trans-unit id="efaf8ed4fd273fae5234c31a87ca20e1f921ce05" translate="yes" xml:space="preserve">
          <source>The terms &quot;protected&quot; and &quot;unprotected&quot; refer to whether or not a mutex is held. An internal mutex is held for a protected sqlite3_value object but no mutex is held for an unprotected sqlite3_value object. If SQLite is compiled to be single-threaded (with &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; and with &lt;a href=&quot;threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returning 0) or if SQLite is run in one of reduced mutex modes &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; or &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; then there is no distinction between protected and unprotected sqlite3_value objects and they can be used interchangeably. However, for maximum code portability it is recommended that applications still make the distinction between protected and unprotected sqlite3_value objects even when not strictly required.</source>
          <target state="translated">术语&amp;ldquo;受保护&amp;rdquo;和&amp;ldquo;不受保护&amp;rdquo;是指是否持有互斥体。对于受保护的sqlite3_value对象，将保留内部互斥锁，但对于不受保护的sqlite3_value对象，将不保留互斥锁。如果将SQLite编译为单线程（&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;且&lt;a href=&quot;threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;返回0），或者如果SQLite在简化互斥模式&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;或&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt;之一中运行，则受保护和不受保护的sqlite3_value对象之间没有区别，它们可以可以互换使用。但是，为了获得最大的代码可移植性，即使没有严格要求，建议应用程序仍应区分受保护的sqlite3_value对象和不受保护的sqlite3_value对象。</target>
        </trans-unit>
        <trans-unit id="9b59119835d0c98638847083b9be8651dcfed7b3" translate="yes" xml:space="preserve">
          <source>The terms &quot;protected&quot; and &quot;unprotected&quot; refer to whether or not a mutex is held. An internal mutex is held for a protected sqlite3_value object but no mutex is held for an unprotected sqlite3_value object. If SQLite is compiled to be single-threaded (with &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; and with &lt;a href=&quot;#sqlite3_threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returning 0) or if SQLite is run in one of reduced mutex modes &lt;a href=&quot;#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; or &lt;a href=&quot;#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; then there is no distinction between protected and unprotected sqlite3_value objects and they can be used interchangeably. However, for maximum code portability it is recommended that applications still make the distinction between protected and unprotected sqlite3_value objects even when not strictly required.</source>
          <target state="translated">术语&amp;ldquo;受保护&amp;rdquo;和&amp;ldquo;不受保护&amp;rdquo;是指是否持有互斥体。对于受保护的sqlite3_value对象，将保留内部互斥锁，但对于不受保护的sqlite3_value对象，将不保留互斥锁。如果将SQLite编译为单线程（&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;且&lt;a href=&quot;#sqlite3_threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;返回0），或者如果SQLite在简化互斥模式&lt;a href=&quot;#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;或&lt;a href=&quot;#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt;之一中运行，则受保护和不受保护的sqlite3_value对象之间没有区别，它们可以可以互换使用。但是，为了获得最大的代码可移植性，即使没有严格要求，建议应用程序仍应区分受保护的sqlite3_value对象和不受保护的sqlite3_value对象。</target>
        </trans-unit>
        <trans-unit id="d0d8bb329a3e29ad5aa4a494be22dcdfc57447c5" translate="yes" xml:space="preserve">
          <source>The terms in W and X must match exactly. SQLite does not do algebra to try to get them to look the same. The term &quot;b=6&quot; does not match &quot;b=3+3&quot; or &quot;b-6=0&quot; or &quot;b BETWEEN 6 AND 6&quot;. &quot;b=6&quot; will match to &quot;6=b&quot; as long as &quot;b=6&quot; is on the index and &quot;6=b&quot; is in the query. If a term of the form &quot;6=b&quot; appears in the index, it will never match anything.</source>
          <target state="translated">W和X中的术语必须完全匹配。SQLite不做代数来尝试让它们看起来一样。术语 &quot;b=6 &quot;不匹配 &quot;b=3+3 &quot;或 &quot;b-6=0 &quot;或 &quot;b BETWEEN 6 AND 6&quot;。&quot;b=6 &quot;将与 &quot;6=b &quot;匹配,只要 &quot;b=6 &quot;在索引中,&quot;6=b &quot;在查询中。如果在索引中出现 &quot;6=b &quot;形式的术语,它将永远不会匹配任何东西。</target>
        </trans-unit>
        <trans-unit id="1a91aabb1ee8a98e3573519dc568a9cdcf09f371" translate="yes" xml:space="preserve">
          <source>The test infrastructure verifies that SQLite does not misuse dynamically allocated memory by using a specially instrumented memory allocator. The instrumented memory allocator is enabled at compile-time using the &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; option. The instrumented memory allocator is much slower than the default memory allocator and so its use is not recommended in production. But when enabled during testing, the instrumented memory allocator performs the following checks:</source>
          <target state="translated">测试基础结构通过使用专门检测的内存分配器来验证SQLite不会滥用动态分配的内存。在编译时使用&lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt;选项启用检测的内存分配器。检测的内存分配器比默认的内存分配器慢得多，因此不建议在生产中使用它。但是，在测试过程中启用该功能后，检测的内存分配器将执行以下检查：</target>
        </trans-unit>
        <trans-unit id="23d89111adcbe2ab0ff1f685425a6f5892695526" translate="yes" xml:space="preserve">
          <source>The test suite is designed to be run three times, once for each of the ALWAYS() and NEVER() definitions shown above. All three test runs should yield exactly the same result. There is a run-time test using the &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_ALWAYS&lt;/a&gt;, ...) interface that can be used to verify that the macros are correctly set to the first form (the pass-through form) for deployment.</source>
          <target state="translated">该测试套件设计为可以运行3次，对于上面显示的每个ALWAYS（）和NEVER（）定义一次。所有三个测试运行应产生完全相同的结果。使用&lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt;（&lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_ALWAYS&lt;/a&gt;，...）接口进行了运行时测试，可用于验证宏是否正确设置为用于部署的第一种形式（传递形式）。</target>
        </trans-unit>
        <trans-unit id="77fbf4494f9eeac6c3dd3e8030fecebddc25654d" translate="yes" xml:space="preserve">
          <source>The test suites for SQLite also explore the result of stacking multiple failures. For example, tests are run to ensure correct behavior when an I/O error or OOM fault occurs while trying to recover from a prior crash.</source>
          <target state="translated">SQLite的测试套件还探索了堆叠多个故障的结果。例如,当发生I/O错误或OOM故障时,在试图从先前的崩溃中恢复时,会运行测试以确保正确的行为。</target>
        </trans-unit>
        <trans-unit id="a7eb514323fac72f4df40162cf2fb7ca6826d6f1" translate="yes" xml:space="preserve">
          <source>The test1.dir directory will contain 100,000 files with names like &quot;000000&quot;, &quot;000001&quot;, &quot;000002&quot; and so forth but the test1.tree directory will contain the same files in subdirectories like &quot;00/00/00&quot;, &quot;00/00/01&quot;, and so on. The test1.dir and test1.test directories take up approximately the same amount of space, though test1.test is very slightly larger due to the extra directory entries.</source>
          <target state="translated">test1.dir目录将包含100,000个文件,名称为 &quot;0000&quot;、&quot;000001&quot;、&quot;000002 &quot;等,但test1.tree目录将在 &quot;00/00/00&quot;、&quot;00/00/01 &quot;等子目录中包含相同的文件。test1.dir和test1.test目录占用的空间大致相同,不过test1.test由于多了一个目录项,所以占的空间非常小。</target>
        </trans-unit>
        <trans-unit id="833841004a13aff638c7a47f3f35a8f25f41ac0a" translate="yes" xml:space="preserve">
          <source>The test_async.c drive now does full file locking and works correctly when used simultaneously by multiple processes on the same database.</source>
          <target state="translated">test_async.c驱动器现在可以进行完全的文件锁定,并且在同一数据库上的多个进程同时使用时可以正常工作。</target>
        </trans-unit>
        <trans-unit id="eb420a5e9808216cc66d2c072d0472129ab690a9" translate="yes" xml:space="preserve">
          <source>The testcase() macro is often used to verify that boundary cases of an inequality comparison are checked. For example, at &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&lt;/a&gt;. These kind of checks help to prevent off-by-one errors.</source>
          <target state="translated">testcase（）宏通常用于验证是否检查了不等式比较的边界情况。例如，在&lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&lt;/a&gt;。这些检查有助于防止一次遗漏的错误。</target>
        </trans-unit>
        <trans-unit id="bfd50a8b5d17dc1d197a2f0aeffde22600cc3d5e" translate="yes" xml:space="preserve">
          <source>The testcase(X) macro is normally a no-op, but for a coverage test build it does generate a small amount of extra code that includes at least one branch, in order to verify that test cases exist for which X is both true and false.</source>
          <target state="translated">testcase(X)宏通常是没有操作的,但对于覆盖测试构建来说,它确实会产生少量额外的代码,其中包括至少一个分支,以验证是否存在测试用例,其中 X 既是真也是假。</target>
        </trans-unit>
        <trans-unit id="198025ed4b90dd540b423fcfb30efac73a9076a6" translate="yes" xml:space="preserve">
          <source>The testing process for SQLite is described in the &lt;a href=&quot;testing&quot;&gt;testing&lt;/a&gt; document. Testing objectives include:</source>
          <target state="translated">&lt;a href=&quot;testing&quot;&gt;测试&lt;/a&gt;文档中描述了SQLite的测试过程。测试目标包括：</target>
        </trans-unit>
        <trans-unit id="7f341b9da6892f9f513eb1e23029aaad7d1945bb" translate="yes" xml:space="preserve">
          <source>The testing process is controlled by the &lt;a href=&quot;testing#cklist&quot;&gt;release testing checklists&lt;/a&gt;. The checklists succinctly summary all steps necessary to fully validate SQLite, and they record when and by whom each validation step was performed.</source>
          <target state="translated">测试过程由&lt;a href=&quot;testing#cklist&quot;&gt;发布测试清单控制&lt;/a&gt;。清单简要总结了全面验证SQLite所需的所有步骤，并记录了执行每个验证步骤的时间和对象。</target>
        </trans-unit>
        <trans-unit id="b10a0b7612e25fb69c97ba29101b2f64b4a7581b" translate="yes" xml:space="preserve">
          <source>The text format is pure SQL so you can also use the .dump command to export an SQLite database into other popular SQL database engines. Like this:</source>
          <target state="translated">文本格式是纯SQL,所以你也可以使用.dump命令将SQLite数据库导出到其他流行的SQL数据库引擎中。像这样。</target>
        </trans-unit>
        <trans-unit id="002ca6dfea0de9e1d73a68077f123004fa9755de" translate="yes" xml:space="preserve">
          <source>The text in the sqlite_master.sql column is a copy of the original CREATE statement text that created the object, except normalized as described above and as modified by subsequent &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; statements. The sqlite_master.sql is NULL for the &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; that are automatically created by &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints.</source>
          <target state="translated">sqlite_master.sql列中的文本是创建对象的原始CREATE语句文本的副本，但如上所述和通过后续&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;语句进行了修改的规范除外。对于由&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;或&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;约束自动创建的&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部索引&lt;/a&gt;，sqlite_master.sql为NULL 。</target>
        </trans-unit>
        <trans-unit id="df540746bab5e3cce21edce12d96e726e4a223e9" translate="yes" xml:space="preserve">
          <source>The text in the sqlite_schema.sql column is a copy of the original CREATE statement text that created the object, except normalized as described above and as modified by subsequent &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; statements. The sqlite_schema.sql is NULL for the &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; that are automatically created by &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3362b59e42a116b494bb787cf561f00b28111a39" translate="yes" xml:space="preserve">
          <source>The text of query parameters is appended to the filename argument of the xOpen method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. Any %HH escape sequences in the query parameters are resolved prior to being appended to the xOpen filename. A single zero-byte separates the xOpen filename argument from the key of the first query parameters, each key and value, and each subsequent key from the prior value. The list of query parameters appended to the xOpen filename is terminated by a single zero-length key. Note that the value of a query parameter can be an empty string.</source>
          <target state="translated">查询参数的文本附加到&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;的xOpen方法的filename参数中。查询参数中的任何％HH转义序列都必须先解析，然后才能附加到xOpen文件名。单个零字节将xOpen文件名参数与第一个查询参数的键，每个键和值以及每个后续键与先前值分开。附加到xOpen文件名的查询参数列表由单个零长度键终止。请注意，查询参数的值可以是空字符串。</target>
        </trans-unit>
        <trans-unit id="f010a4aeda05a6fff949d6b23c4d99edd507a5b9" translate="yes" xml:space="preserve">
          <source>The text of the word that matches the pattern. Both word and pattern can contain unicode characters and can be mixed case.</source>
          <target state="translated">匹配模式的单词的文本。词和模式都可以包含unicode字符,也可以混合大小写。</target>
        </trans-unit>
        <trans-unit id="7af9ff5f020628933bb8ed136e797234a16f70b6" translate="yes" xml:space="preserve">
          <source>The text output of the one-argument form of ieee754() is great for human readability, but it awkward to use as part of a larger expression. Hence The ieee754_mantissa() and ieee754_exponent() routines were added to return the M and E values corresponding to their single argument F value. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ac3915c6fa697bff1880701cc84fcf41ef0614" translate="yes" xml:space="preserve">
          <source>The text to add to the start or end of the selected text to indicate that the returned text does not occur at the start or end of its column, respectively.</source>
          <target state="translated">要在所选文本的开头或结尾处添加的文字,以分别表示返回的文本不出现在其列的开头或结尾处。</target>
        </trans-unit>
        <trans-unit id="5d227441e585adc9dccb7fd5119a447b09eeb780" translate="yes" xml:space="preserve">
          <source>The text to insert after each phrase match within the returned text.</source>
          <target state="translated">在返回的文本中,每个短语匹配后插入的文本。</target>
        </trans-unit>
        <trans-unit id="c372789c27ae2ac063bb79f99aab7639b81bdf47" translate="yes" xml:space="preserve">
          <source>The text to insert after each phrase match.</source>
          <target state="translated">在每个短语匹配后插入的文字。</target>
        </trans-unit>
        <trans-unit id="98deed99ebb119a4eabb19891d9d80c8f6d99766" translate="yes" xml:space="preserve">
          <source>The text to insert before each phrase match within the returned text.</source>
          <target state="translated">在返回的文本中,每个短语匹配之前插入的文本。</target>
        </trans-unit>
        <trans-unit id="011020fd80da1d64051ffd57ff7d4f9db6949595" translate="yes" xml:space="preserve">
          <source>The text to insert before each phrase match.</source>
          <target state="translated">在每个短语匹配前插入的文字。</target>
        </trans-unit>
        <trans-unit id="41db7390257d3e1c83cfe7262fbe75efa4098374" translate="yes" xml:space="preserve">
          <source>The theoretical maximum number of rows in a table is 2&lt;sup&gt;&lt;small&gt;64&lt;/small&gt;&lt;/sup&gt; (18446744073709551616 or about 1.8e+19). This limit is unreachable since the maximum database size of 140 terabytes will be reached first. A 140 terabytes database can hold no more than approximately 1e+13 rows, and then only if there are no indices and if each row contains very little data.</source>
          <target state="translated">表中的理论最大行数为2 &lt;sup&gt;&lt;small&gt;64&lt;/small&gt;&lt;/sup&gt;（18446744073709551616或大约1.8e + 19）。由于将首先达到140 TB的最大数据库大小，因此无法达到此限制。一个140 TB的数据库最多可以容纳大约1e + 13行，然后仅在没有索引且每行包含的数据很少的情况下才可以。</target>
        </trans-unit>
        <trans-unit id="9c469d0a6dd7814f8f536d83dd0c0d4f9236b847" translate="yes" xml:space="preserve">
          <source>The theoretical maximum number of rows in a table is 2&lt;sup&gt;&lt;small&gt;64&lt;/small&gt;&lt;/sup&gt; (18446744073709551616 or about 1.8e+19). This limit is unreachable since the maximum database size of 281 terabytes will be reached first. A 281 terabytes database can hold no more than approximately 2e+13 rows, and then only if there are no indices and if each row contains very little data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e681320a770693ff8880c2fe787c3d46c58d6fe" translate="yes" xml:space="preserve">
          <source>The these routines may attempt to convert the datatype of the result. For example, if the internal representation is FLOAT and a text result is requested, &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; is used internally to perform the conversion automatically. The following table details the conversions that are applied:</source>
          <target state="translated">这些例程可能会尝试转换结果的数据类型。例如，如果内部表示形式为FLOAT并请求文本结果，则内部使用&lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;自动执行转换。下表详细介绍了应用的转换：</target>
        </trans-unit>
        <trans-unit id="d45ababe332de0d6a9b7d204a8229a091726f141" translate="yes" xml:space="preserve">
          <source>The these routines may attempt to convert the datatype of the result. For example, if the internal representation is FLOAT and a text result is requested, &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; is used internally to perform the conversion automatically. The following table details the conversions that are applied:</source>
          <target state="translated">这些例程可能会尝试转换结果的数据类型。例如，如果内部表示形式为FLOAT并请求文本结果，则内部使用&lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;自动执行转换。下表详细介绍了应用的转换：</target>
        </trans-unit>
        <trans-unit id="f29b8fd84fbcfd59fccde21c2067cc383b5612cf" translate="yes" xml:space="preserve">
          <source>The third and fourth parameters to this function are the table and column name of the desired column, respectively.</source>
          <target state="translated">该函数的第三个和第四个参数分别是所需列的表和列名。</target>
        </trans-unit>
        <trans-unit id="5dad7ccfb7adf02e60a4718cd1bfaf6cc7ad8094" translate="yes" xml:space="preserve">
          <source>The third argument (eTextRep) must be one of the constants:</source>
          <target state="translated">第三个参数(eTextRep)必须是常量之一。</target>
        </trans-unit>
        <trans-unit id="a12fbbce4ea7f98c6f3257e48e8cfdd9d6a7f402" translate="yes" xml:space="preserve">
          <source>The third argument is the value to bind to the parameter. If the third parameter to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_blob() is a NULL pointer then the fourth parameter is ignored and the end result is the same as sqlite3_bind_null().</source>
          <target state="translated">第三个参数是要绑定到参数的值。如果sqlite3_bind_text()或sqlite3_bind_text16()或sqlite3_bind_blob()的第三个参数是一个NULL指针,那么第四个参数将被忽略,最终结果与sqlite3_bind_null()相同。</target>
        </trans-unit>
        <trans-unit id="cfd2994dc5175da09229d952b2be33f11c05e0da" translate="yes" xml:space="preserve">
          <source>The third argument is the value to bind to the parameter. If the third parameter to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_blob() is a NULL pointer then the fourth parameter is ignored and the end result is the same as sqlite3_bind_null(). If the third parameter to sqlite3_bind_text() is not NULL, then it should be a pointer to well-formed UTF8 text. If the third parameter to sqlite3_bind_text16() is not NULL, then it should be a pointer to well-formed UTF16 text. If the third parameter to sqlite3_bind_text64() is not NULL, then it should be a pointer to a well-formed unicode string that is either UTF8 if the sixth parameter is SQLITE_UTF8, or UTF16 otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8896799f29c2adcd495a7004a3dfd8ef2c595b55" translate="yes" xml:space="preserve">
          <source>The third argument to the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt;,...) interface (the &quot;pData&quot; argument in the example above) is a pointer to arbitrary data. SQLite passes this pointer through to the first argument of the error logger callback. The pointer can be used to pass application-specific setup or state information, if desired. Or it can simply be a NULL pointer which is ignored by the callback.</source>
          <target state="translated">&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt;，...）接口的第三个参数（上面示例中的&amp;ldquo; pData&amp;rdquo;参数）是指向任意数据的指针。 SQLite将此指针传递到错误记录器回调的第一个参数。如果需要，该指针可用于传递特定于应用程序的设置或状态信息。或者它可以只是一个NULL指针，回调会忽略它。</target>
        </trans-unit>
        <trans-unit id="8e80d3a19f53ad5c94b48f6b4deace1bd8cd6a01" translate="yes" xml:space="preserve">
          <source>The third chart shows that reading blob content out of SQLite can be twice as fast as reading from individual files on disk for Mac and Android, and an amazing ten times faster for Windows.</source>
          <target state="translated">第三张图显示,对于Mac和Android来说,从SQLite中读取blob内容的速度是从磁盘上的单个文件中读取的速度的两倍,对于Windows来说则是惊人的十倍。</target>
        </trans-unit>
        <trans-unit id="ce81cfaf801aa960a0d4e258e6f72c47aaf642db" translate="yes" xml:space="preserve">
          <source>The third column is the minimum value for any rowid in the table.</source>
          <target state="translated">第三列是表中任何rowid的最小值。</target>
        </trans-unit>
        <trans-unit id="66b245a2c0333e9c6e002eaadabc21caae3f20aa" translate="yes" xml:space="preserve">
          <source>The third form of an INSERT statement is with DEFAULT VALUES. The INSERT ... DEFAULT VALUES statement inserts a single new row into the named table. Each column of the new row is populated with its &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default value&lt;/a&gt;, or with a NULL if no default value is specified as part of the column definition in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. The &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt; is not supported after DEFAULT VALUES.</source>
          <target state="translated">INSERT语句的第三种形式是带有DEFAULT VALUES。 INSERT ... DEFAULT VALUES语句将单个新行插入到命名表中。新行的每一列均填充有其&lt;a href=&quot;lang_createtable#dfltval&quot;&gt;默认值&lt;/a&gt;，如果&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句中的列定义未指定默认值，则填充NULL 。该&lt;a href=&quot;syntax/upsert-clause&quot;&gt;UPSERT子句&lt;/a&gt; DEFAULT值之后不被支持。</target>
        </trans-unit>
        <trans-unit id="80211bcbcab262c368d4da63de6e8f61d55d7f66" translate="yes" xml:space="preserve">
          <source>The third line of the example shows the virtual table being used, to read all content of the CSV file. This is perhaps the simplest possible use of the virtual table. The CSV virtual table can be used anywhere an ordinary virtual table can be used. One can use the CSV virtual table inside subqueries, or &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt; or add WHERE, GROUP BY, HAVING, ORDER BY, and LIMIT clauses as required.</source>
          <target state="translated">该示例的第三行显示了正在使用的虚拟表，用于读取CSV文件的所有内容。这可能是对虚拟表的最简单的使用。可以在可以使用普通虚拟表的任何地方使用CSV虚拟表。可以在子查询或&lt;a href=&quot;lang_with&quot;&gt;公共表表达式中&lt;/a&gt;使用CSV虚拟表，也可以根据需要添加WHERE，GROUP BY，HAVING，ORDER BY和LIMIT子句。</target>
        </trans-unit>
        <trans-unit id="37d0f732f75ffbc9298be10c6e109dfc37fa5d4b" translate="yes" xml:space="preserve">
          <source>The third number Z is incremented for releases consisting of only small changes that implement performance enhancements and/or bug fixes.</source>
          <target state="translated">第三个数字Z是递增的,因为发布的版本只包含小的变化,实现了性能增强和/或错误修复。</target>
        </trans-unit>
        <trans-unit id="d43fa02ec7a69fa0b5cb4656ab69a4413a6918c8" translate="yes" xml:space="preserve">
          <source>The third optimization, zeroing the journal file header rather than deleting the rollback journal file, does not depend on holding an exclusive lock at all times. This optimization can be set independently of exclusive lock mode using the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt; as described in &lt;a href=&quot;#section_7_6&quot;&gt;section 7.6&lt;/a&gt; below.</source>
          <target state="translated">第三种优化是将日志文件头清零而不是删除回滚日志文件，这并不取决于始终保持互斥锁。可以使用&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode杂注&lt;/a&gt;独立于独占锁定模式进行设置，如以下&lt;a href=&quot;#section_7_6&quot;&gt;7.6节&lt;/a&gt;所述。</target>
        </trans-unit>
        <trans-unit id="226219f131eebb1bb82e3a9e80c20160ef9e49d4" translate="yes" xml:space="preserve">
          <source>The third parameter (nArg) is the number of arguments that the SQL function or aggregate takes. If this parameter is -1, then the SQL function or aggregate may take any number of arguments between 0 and the limit set by &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;). If the third parameter is less than -1 or greater than 127 then the behavior is undefined.</source>
          <target state="translated">第三个参数（nArg）是SQL函数或聚合采用的参数数量。如果此参数为-1，则SQL函数或聚合可以接受介于0和&lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;（&lt;a href=&quot;#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;）设置的限制之间的任意数量的参数。如果第三个参数小于-1或大于127，则行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="11f56952c8e04a9269627afb8274637d6b360ea2" translate="yes" xml:space="preserve">
          <source>The third parameter (nArg) is the number of arguments that the SQL function or aggregate takes. If this parameter is -1, then the SQL function or aggregate may take any number of arguments between 0 and the limit set by &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;). If the third parameter is less than -1 or greater than 127 then the behavior is undefined.</source>
          <target state="translated">第三个参数（nArg）是SQL函数或聚合采用的参数数量。如果此参数为-1，则SQL函数或聚合可以接受介于0和&lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;（&lt;a href=&quot;c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;）设置的限制之间的任意数量的参数。如果第三个参数小于-1或大于127，则行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="7effa7c199d796ec9c7957d5b06f69295ac44ef2" translate="yes" xml:space="preserve">
          <source>The third step starts with the four shortest two-node paths and finds the four shortest three-node paths:</source>
          <target state="translated">第三步从四个最短的两节点路径开始,找到四个最短的三节点路径。</target>
        </trans-unit>
        <trans-unit id="97390ca779620e87876318d53cdbb5c0eb4c1782" translate="yes" xml:space="preserve">
          <source>The threading mode can be selected at compile-time (when the SQLite library is being compiled from source code) or at start-time (when the application that intends to use SQLite is initializing) or at run-time (when a new SQLite database connection is being created). Generally speaking, run-time overrides start-time and start-time overrides compile-time. Except, single-thread mode cannot be overridden once selected.</source>
          <target state="translated">线程模式可以在编译时(当SQLite库正在从源代码编译时)或启动时(当打算使用SQLite的应用程序正在初始化时)或运行时(当正在创建一个新的SQLite数据库连接时)选择。一般来说,运行时优先于启动时,启动时优先于编译时。只不过,单线程模式一旦选择,就不能被覆盖。</target>
        </trans-unit>
        <trans-unit id="7a0e198fd0423256115863d78eac9cac1343e176" translate="yes" xml:space="preserve">
          <source>The threading mode for an individual database connection is determined by flags given as the third argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; flag causes the database connection to be in the multi-thread mode and the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flag causes the connection to be in serialized mode. If neither flag is specified or if &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; are used instead of &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, then the default mode determined by the compile-time and start-time settings is used.</source>
          <target state="translated">单个数据库连接的线程模式由作为&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;的第三个参数给出的标志确定。所述&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;标志导致数据库连接是在多线程模式和&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;标志使是在串行化模式的连接。如果未指定任何标志，或者使用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;或&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;代替&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;，则使用由编译时和启动时设置确定的默认模式。</target>
        </trans-unit>
        <trans-unit id="a70f1f8b6fb5520108a2b27f649a3322d3c256dc" translate="yes" xml:space="preserve">
          <source>The three auxiliary functions are only useful within a SELECT statement that uses the FTS table's full-text index. If used within a SELECT that uses the &quot;query by rowid&quot; or &quot;linear scan&quot; strategies, then the snippet and offsets both return an empty string, and the matchinfo function returns a blob value zero bytes in size.</source>
          <target state="translated">这三个辅助函数只在使用FTS表的全文索引的SELECT语句中有用。如果在使用 &quot;按rowid查询 &quot;或 &quot;线性扫描 &quot;策略的SELECT内使用,那么snippet和offsets都返回一个空字符串,matchinfo函数返回一个大小为0字节的blob值。</target>
        </trans-unit>
        <trans-unit id="6eb0a1f7b89a823f8bdbde0d13568a18262e614a" translate="yes" xml:space="preserve">
          <source>The three basic query types described above may be used to query the full-text index for the set of documents that match the specified criteria. Using the FTS query expression language it is possible to perform various set operations on the results of basic queries. There are currently three supported operations:</source>
          <target state="translated">上述三种基本查询类型可以用来查询全文索引中符合指定标准的文档集。利用FTS查询表达式语言,可以对基本查询的结果进行各种集合操作。目前支持的操作有三种。</target>
        </trans-unit>
        <trans-unit id="7097964beca5dc252968954049e7c0946f78e4a9" translate="yes" xml:space="preserve">
          <source>The three leftmost columns of a zipfile virtual table, &quot;name&quot;, &quot;mode&quot; and &quot;mtime&quot;, may each be set to any value that may be inserted into the same column (see above). If either &quot;mode&quot; or &quot;mtime&quot; is set to NULL, the final value is determined as described for an INSERT of a NULL value - the current time for &quot;mtime&quot; and either 33188 or 16877 for &quot;mode&quot;, depending on whether or not the values specified for the next four columns of the zipfile table indicate that the entry is a directory or a file.</source>
          <target state="translated">zipfile虚拟表最左边的三列,&quot;name&quot;、&quot;mode &quot;和 &quot;mtime&quot;,可以分别设置为任何可以插入到同一列的值(见上文)。如果 &quot;mode &quot;或 &quot;mtime &quot;被设置为NULL,那么最终的值将被确定为一个NULL值的INSERT--&quot;mtime &quot;为当前时间,&quot;mode &quot;为33188或16877,这取决于为zipfile表的后面四列指定的值是否表明该条目是一个目录或文件。</target>
        </trans-unit>
        <trans-unit id="3411dedba6408ea6c13a17f75aea9b87b7d91fad" translate="yes" xml:space="preserve">
          <source>The time string can be followed by zero or more modifiers that alter date and/or time. Each modifier is a transformation that is applied to the time value to its left. Modifiers are applied from left to right; order is important. The available modifiers are as follows.</source>
          <target state="translated">时间字符串后面可以跟着零个或多个修改器,以改变日期和/或时间。每个修饰符都是应用于其左边的时间值的转换。修饰符从左到右应用,顺序很重要。可用的修饰符如下。</target>
        </trans-unit>
        <trans-unit id="30024a74e5aefa6cc166b0948a8f34eea1be4641" translate="yes" xml:space="preserve">
          <source>The time taken to execute each virtual machine operation can vary based on many factors. A typical value for a 1 GHz PC is between half and three million per second but may be much higher or lower, depending on the query. As such it is difficult to schedule background operations based on virtual machine operations. Instead, it is recommended that a callback be scheduled relatively frequently (say every 1000 instructions) and external timer routines used to determine whether or not background jobs need to be run.</source>
          <target state="translated">执行每个虚拟机操作所需的时间会根据许多因素而变化。1 GHz PC的典型值是每秒50万到300万之间,但根据查询情况,可能会高得多或低得多。因此,很难根据虚拟机操作来安排后台操作。相反,建议相对频繁地调度回调(例如每1000条指令),并使用外部定时器例程来确定是否需要运行后台作业。</target>
        </trans-unit>
        <trans-unit id="d31d23c9c6ce92ba1161f4e9fe89ef4c4bc1cceb" translate="yes" xml:space="preserve">
          <source>The times reported on all tests represent wall-clock time in seconds. Two separate time values are reported for SQLite. The first value is for SQLite in its default configuration with full disk synchronization turned on. With synchronization turned on, SQLite executes an &lt;b&gt;fsync()&lt;/b&gt; system call (or the equivalent) at key points to make certain that critical data has actually been written to the disk drive surface. Synchronization is necessary to guarantee the integrity of the database if the operating system crashes or the computer powers down unexpectedly in the middle of a database update. The second time reported for SQLite is when synchronization is turned off. With synchronization off, SQLite is sometimes much faster, but there is a risk that an operating system crash or an unexpected power failure could damage the database. Generally speaking, the synchronous SQLite times are for comparison against PostgreSQL (which is also synchronous) and the asynchronous SQLite times are for comparison against the asynchronous MySQL engine.</source>
          <target state="translated">所有测试报告的时间代表以秒为单位的挂钟时间。对于SQLite，报告了两个单独的时间值。第一个值是在默认配置下启用了全磁盘同步的SQLite。启用同步后，SQLite执行&lt;b&gt;fsync（）&lt;/b&gt;在关键点进行系统调用（或等效的调用），以确保已将关键数据实际写入磁盘驱动器表面。如果操作系统崩溃或在数据库更新过程中计算机意外断电，则必须进行同步以确保数据库的完整性。对于SQLite的第二次报告是关闭同步。关闭同步后，SQLite有时会快得多，但是存在操作系统崩溃或意外电源故障可能损坏数据库的风险。一般而言，同步SQLite时间用于与PostgreSQL（也是同步的）进行比较，异步SQLite时间用于与异步MySQL引擎进行比较。</target>
        </trans-unit>
        <trans-unit id="0fc05e4c39e5e71215073020483f372e45a3d893" translate="yes" xml:space="preserve">
          <source>The total amount of free space on a b-tree page consists of the size of the unallocated region plus the total size of all freeblocks plus the number of fragmented free bytes. SQLite may from time to time reorganize a b-tree page so that there are no freeblocks or fragment bytes, all unused bytes are contained in the unallocated space region, and all cells are packed tightly at the end of the page. This is called &quot;defragmenting&quot; the b-tree page.</source>
          <target state="translated">b-tree页面上的自由空间总量由未分配区域的大小加上所有自由块的总大小加上碎片自由字节的数量组成。SQLite可能会不时地重组b-tree页面,以便没有自由块或碎片字节,所有未使用的字节都包含在未分配的空间区域中,并且所有单元格都被紧紧地包装在页面的最后。这就是所谓的b树页的 &quot;碎片化&quot;。</target>
        </trans-unit>
        <trans-unit id="460e85c11483674a3089f1a062d5d6ad1f387294" translate="yes" xml:space="preserve">
          <source>The total number of instances of the term in the entire FTS5 table.</source>
          <target state="translated">该术语在整个FTS5表中的总实例数。</target>
        </trans-unit>
        <trans-unit id="8456fd817ff013feb889e3e84d49e1da8d0b8117" translate="yes" xml:space="preserve">
          <source>The total number of instances of the term that appear in column $col of the FTS5 table (considering all rows).</source>
          <target state="translated">在FTS5表中$col列中出现的术语实例总数(考虑到所有行)。</target>
        </trans-unit>
        <trans-unit id="8b23a01c6d0371374c2abef2c4b0a82ba4134902" translate="yes" xml:space="preserve">
          <source>The total number of pages in the btree for the current row</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e6d24f273b69a04a7a37a510d51811f2500b867" translate="yes" xml:space="preserve">
          <source>The total number of rows in the FTS table for which the column contains at least one instance of the phrase.</source>
          <target state="translated">FTS表中该列至少包含一个短语实例的总行数。</target>
        </trans-unit>
        <trans-unit id="36827e0806ceb5dc326cee16a98d2a59022e566e" translate="yes" xml:space="preserve">
          <source>The total number of times the phrase appears in the column in all rows in the FTS table.</source>
          <target state="translated">该短语在FTS表中所有行的列中出现的总次数。</target>
        </trans-unit>
        <trans-unit id="cf5b068f292efb4fb2def2e783aac8fbf8f0464d" translate="yes" xml:space="preserve">
          <source>The total_changes() function returns the number of row changes caused by INSERT, UPDATE or DELETE statements since the current database connection was opened. This function is a wrapper around the &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; C/C++ interface.</source>
          <target state="translated">自打开当前数据库连接以来，total_changes（）函数返回由INSERT，UPDATE或DELETE语句引起的行更改数。该函数是&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt; C / C ++接口的包装。</target>
        </trans-unit>
        <trans-unit id="e56b60d01d475c54e2abcd03a315a64862d2471f" translate="yes" xml:space="preserve">
          <source>The traditional rollback journal works by writing a copy of the original unchanged database content into a separate rollback journal file and then writing changes directly into the database file. In the event of a crash or &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;, the original content contained in the rollback journal is played back into the database file to revert the database file to its original state. The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; occurs when the rollback journal is deleted.</source>
          <target state="translated">传统的回滚日志的工作方式是将原始未更改的数据库内容的副本写入单独的回滚日志文件，然后将更改直接写入数据库文件。在发生崩溃或&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK的情况下&lt;/a&gt;，回滚日志中包含的原始内容将被回放到数据库文件中，以将数据库文件还原为原始状态。该&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;当回滚日志被删除时。</target>
        </trans-unit>
        <trans-unit id="fa45945065730186850cef64d952ee165c9cc090" translate="yes" xml:space="preserve">
          <source>The traditional way of communicating this information was to transform a C-language pointer into a BLOB or a 64-bit integer, then move that BLOB or integer through SQLite using the usual interfaces like &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_blob()&lt;/a&gt;, &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_blob()&lt;/a&gt; or the integer equivalents.</source>
          <target state="translated">传达此信息的传统方式是将C语言指针转换为BLOB或64位整数，然后使用&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob（）&lt;/a&gt;，&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_blob（）&lt;/a&gt;，&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_blob（）&lt;/a&gt;或常规接口通过SQLite通过SQLite移动该BLOB或整数整数等效项。</target>
        </trans-unit>
        <trans-unit id="c2d0f49e1ec0a4672583f25736f97bcbd3e6ba07" translate="yes" xml:space="preserve">
          <source>The transaction command can be used to group together several SQLite commands in a safe way. You can always start transactions manually using BEGIN, of course. But if an error occurs so that the COMMIT or ROLLBACK are never run, then the database will remain locked indefinitely. Also, BEGIN does not nest, so you have to make sure no other transactions are active before starting a new one. The &quot;transaction&quot; method takes care of all of these details automatically.</source>
          <target state="translated">事务命令可以用来将几个SQLite命令安全地分组。当然,你也可以随时使用BEGIN手动启动事务,但如果发生错误,使COMMIT或ROLLBACK从未运行过,那么数据库将无限期地被锁定。但是如果发生错误,以至于COMMIT或ROLLBACK从未运行,那么数据库将无限期地被锁定。另外,BEGIN不会嵌套,所以在启动一个新的事务之前,你必须确保没有其他事务在活动。&quot;事务 &quot;方法会自动处理所有这些细节。</target>
        </trans-unit>
        <trans-unit id="66431b524eb3e3d97e40f460537f3aa544382bf9" translate="yes" xml:space="preserve">
          <source>The transaction has already committed at this point so timing is not critical in the deletion of the rollback journals. The current implementation deletes a single rollback journal then unlocks the corresponding database file before proceeding to the next rollback journal. But in the future we might change this so that all rollback journals are deleted before any database files are unlocked. As long as the rollback journal is deleted before its corresponding database file is unlocked it does not matter in what order the rollback journals are deleted or the database files are unlocked.</source>
          <target state="translated">此时事务已经提交,所以在删除回滚日记的过程中,时间不是关键。目前的实现是先删除一个回滚日记,然后解锁相应的数据库文件,再进行下一个回滚日记。但在未来,我们可能会改变这种做法,在任何数据库文件解锁之前删除所有回滚日志。只要回滚日志在对应的数据库文件解锁之前被删除,那么回滚日志的删除顺序和数据库文件的解锁顺序就无关紧要。</target>
        </trans-unit>
        <trans-unit id="439b3c25010ac483338852bbf167e17f82acaecb" translate="yes" xml:space="preserve">
          <source>The transformation converts each vertex of the polygon according to the following formula:</source>
          <target state="translated">该变换根据以下公式转换多边形的每个顶点。</target>
        </trans-unit>
        <trans-unit id="970a22ffd83744a201d5b074bf5b2eed9b68c352" translate="yes" xml:space="preserve">
          <source>The transient table in which the result is built is created by instruction 0. Three loops then follow. The loop at instructions 5 through 10 implements the first SELECT statement. The second SELECT statement is implemented by the loop at instructions 14 through 19. Finally, a loop at instructions 22 through 25 reads the transient table and invokes the callback once for each row in the result.</source>
          <target state="translated">指令0创建了用于建立结果的瞬时表,接着是三个循环。指令5到10的循环实现了第一个SELECT语句。第二条SELECT语句由指令14到19处的循环实现。最后,指令22到25处的循环读取瞬时表,并对结果中的每一行调用一次回调。</target>
        </trans-unit>
        <trans-unit id="952fc2249e617c46359543a66e348109d3087d3d" translate="yes" xml:space="preserve">
          <source>The transient table in which the results of the inner SELECT are stored is created by the &lt;a href=&quot;opcode#OpenTemp&quot;&gt;OpenTemp&lt;/a&gt; instruction at 0. This opcode is used for tables that exist for the duration of a single SQL statement only. The transient cursor is always opened read/write even if the main database is read-only. The transient table is deleted automatically when the cursor is closed. The P2 value of 1 means the cursor points to a BTree index, which has no data but can have an arbitrary key.</source>
          <target state="translated">内部SELECT的结果存储在其中的临时表是由&lt;a href=&quot;opcode#OpenTemp&quot;&gt;OpenTemp&lt;/a&gt;指令（位于0 ）创建的。此操作码用于仅在单个SQL语句期间存在的表。即使主数据库是只读的，瞬态游标也始终以读写方式打开。关闭游标时，临时表将自动删除。 P2值为1表示光标指向BTree索引，该索引没有数据，但可以具有任意键。</target>
        </trans-unit>
        <trans-unit id="592350be0cb11625e2bd092767c6171c56d03c65" translate="yes" xml:space="preserve">
          <source>The transition from SQLite version 3.4.2 to 3.5.0 is a major change. Every source code file in the SQLite core had to be modified, some extensively. And the change introduced some minor incompatibilities in the C interface. But we feel that the benefits of the transition from 3.4.2 to 3.5.0 far outweigh the pain of porting. The new VFS layer is now well-defined and stable and should simplify future customizations. The VFS layer, and the separable memory allocator and mutex subsystems allow a standard SQLite source code amalgamation to be used in an embedded project without change, greatly simplifying configuration management. And the resulting system is much more tolerant of highly threaded designs.</source>
          <target state="translated">从SQLite 3.4.2版本过渡到3.5.0是一个重大的变化。SQLite核心中的每一个源代码文件都必须修改,有的还很广泛。而且这个变化在C接口中引入了一些小的不兼容性。但我们觉得从3.4.2过渡到3.5.0的好处远远超过了移植的痛苦。新的VFS层现在定义得很好,也很稳定,应该可以简化未来的定制。VFS层以及可分离的内存分配器和mutex子系统允许在嵌入式项目中使用标准的SQLite源代码合并,而不需要改变,大大简化了配置管理。而且由此产生的系统对高线程设计的容忍度更高。</target>
        </trans-unit>
        <trans-unit id="b0ecdf62ac64721b60f0c811bc6ae15d2a3d1b27" translate="yes" xml:space="preserve">
          <source>The trick here is the -DTCLSH=1 option. The TCL interface module for SQLite includes a &lt;b&gt;main()&lt;/b&gt; procedure that initializes a TCL interpreter and enters a command-line loop when it is compiled with -DTCLSH=1. The command above works on both Linux and Mac OS X, though one may need to adjust the library options depending on the platform and which version of TCL one is linking against.</source>
          <target state="translated">这里的技巧是-DTCLSH = 1选项。用于SQLite的TCL接口模块包括&lt;b&gt;main（）&lt;/b&gt;过程，该过程将初始化TCL解释器，并在使用-DTCLSH = 1进行编译时进入命令行循环。上面的命令在Linux和Mac OS X上均可使用，尽管可能需要根据平台和所链接的TCL版本来调整库选项。</target>
        </trans-unit>
        <trans-unit id="fc5d00c95debe18bbcee9e720337d19dcab11f5a" translate="yes" xml:space="preserve">
          <source>The trigger created by the previous statement is named &quot;AFTER&quot; and it is a &quot;BEFORE&quot; trigger. The &quot;AFTER&quot; token is used as an identifier instead of as a keyword, as that is the only way to parse the statement. Another example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9b7cf0a7967eed621bbbad3863190e29c44d61" translate="yes" xml:space="preserve">
          <source>The trim(X,Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.</source>
          <target state="translated">trim(X,Y)函数返回一个从X的两端删除Y中出现的所有字符所形成的字符串,如果省略Y参数,trim(X)将从X的两端删除空格。</target>
        </trans-unit>
        <trans-unit id="02041028dd7a37adeacbb35b1200b0b1a6b27a53" translate="yes" xml:space="preserve">
          <source>The true primary key for a rowid table (the value that is used as the key to look up rows in the underlying &lt;a href=&quot;fileformat2#btree&quot;&gt;B-tree&lt;/a&gt; storage engine) is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">rowid表的真正主键（用作在基础&lt;a href=&quot;fileformat2#btree&quot;&gt;B树&lt;/a&gt;存储引擎中查找行的键的值）是&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f9dae6c570b0f408d716bb105a5e25850cccf9f" translate="yes" xml:space="preserve">
          <source>The truncate optimization can also be disabled at runtime using the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface. If an authorizer callback returns &lt;a href=&quot;c3ref/c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; for an &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; action code, then the DELETE operation will proceed but the truncate optimization will be bypassed and rows will be deleted one by one.</source>
          <target state="translated">还可以在运行时使用&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;接口禁用截断优化。如果授权者回调返回&lt;a href=&quot;c3ref/c_deny&quot;&gt;SQLITE_DELETE&lt;/a&gt;操作代码的&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_IGNORE&lt;/a&gt;，则DELETE操作将继续进行，但截断优化将被绕过，行将被一一删除。</target>
        </trans-unit>
        <trans-unit id="7489f83785acf46d79dbedce76141d020e3a30b4" translate="yes" xml:space="preserve">
          <source>The truncate optimization can be permanently disabled for all queries by recompiling SQLite with the &lt;a href=&quot;compile#omit_truncate_optimization&quot;&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/a&gt; compile-time switch.</source>
          <target state="translated">通过使用&lt;a href=&quot;compile#omit_truncate_optimization&quot;&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/a&gt;编译时开关重新编译SQLite，可以永久禁用所有查询的截断优化。</target>
        </trans-unit>
        <trans-unit id="30f49567fa43c7d2e5e26ee8efe4338c93c45898" translate="yes" xml:space="preserve">
          <source>The trusted_schema setting is a per-connection boolean that determines whether or not SQL functions and virtual tables that have not been security audited are allowed to be run by views, triggers, or in expressions of the schema such as &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;DEFAULT clauses&lt;/a&gt;, &lt;a href=&quot;gencol&quot;&gt;generated columns&lt;/a&gt;, &lt;a href=&quot;expridx&quot;&gt;expression indexes&lt;/a&gt;, and/or &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;. This setting can also be controlled using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;,...) C-language interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e242c8734781e20213900394ec30db10b58ee560" translate="yes" xml:space="preserve">
          <source>The two &quot;0&quot; parameters do server a purpose in some contexts, but for using these routine to print a parse tree as ASCII-art on the terminal, they should both be &quot;0&quot;.</source>
          <target state="translated">这两个 &quot;0 &quot;参数在某些情况下有一定的作用,但对于使用这些例程在终端上打印ASCII-art的解析树,它们都应该是 &quot;0&quot;。</target>
        </trans-unit>
        <trans-unit id="46623d6b4b79b06cc3078e791041446a91edf407" translate="yes" xml:space="preserve">
          <source>The two 4-byte big-endian integers at offsets 52 and 64 are used to manage the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; modes. If the integer at offset 52 is zero then pointer-map (ptrmap) pages are omitted from the database file and neither auto_vacuum nor incremental_vacuum are supported. If the integer at offset 52 is non-zero then it is the page number of the largest root page in the database file, the database file will contain ptrmap pages, and the mode must be either auto_vacuum or incremental_vacuum. In this latter case, the integer at offset 64 is true for incremental_vacuum and false for auto_vacuum. If the integer at offset 52 is zero then the integer at offset 64 must also be zero.</source>
          <target state="translated">偏移量为52和64的两个4字节的大端整数用于管理&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;增量&lt;/a&gt;_vacuum模式。如果偏移量52处的整数为零，则将从数据库文件中省略指针映射（ptrmap）页，并且不支持auto_vacuum和增量_vacuum。如果偏移量52处的整数不为零，则它是数据库文件中最大根页的页码，数据库文件将包含ptrmap页，并且模式必须为auto_vacuum或增量_vacuum。在后一种情况下，偏移量64处的整数对于incremental_vacuum为true，对于auto_vacuum为false。如果偏移52处的整数为零，那么偏移64处的整数也必须为零。</target>
        </trans-unit>
        <trans-unit id="5d5cec8b4b21ae2b9d4802acdeb66477068dae88" translate="yes" xml:space="preserve">
          <source>The two &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; are:</source>
          <target state="translated">这两个&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;是：</target>
        </trans-unit>
        <trans-unit id="60d1d8fda3bbd4cfca022cc996f0d5a823d5b6ed" translate="yes" xml:space="preserve">
          <source>The two exceptions are:</source>
          <target state="translated">两个例外是:</target>
        </trans-unit>
        <trans-unit id="e1f0bf58781420b540ac606f0e7579a8a2be4378" translate="yes" xml:space="preserve">
          <source>The two fragments of SQL below are similar, but not entirely equivalent, as the latter will fail if the definition of window &quot;win&quot; contains a frame specification.</source>
          <target state="translated">下面的两个SQL片段相似,但并不完全等同,因为如果窗口 &quot;win &quot;的定义中包含框架规范,那么后者就会失败。</target>
        </trans-unit>
        <trans-unit id="f9a92735a6c1a485477340ad1399f41bdfef6983" translate="yes" xml:space="preserve">
          <source>The two remaining tables, %_segments and %_segdir, are used to store the full-text index. Conceptually, this index is a lookup table that maps each term (word) to the set of docid values corresponding to records in the %_content table that contain one or more occurrences of the term. To retrieve all documents that contain a specified term, the FTS module queries this index to determine the set of docid values for records that contain the term, then retrieves the required documents from the %_content table. Regardless of the schema of the FTS virtual table, the %_segments and %_segdir tables are always created as follows:</source>
          <target state="translated">剩下的两个表,%_segments和%_segdir,用来存储全文索引。从概念上讲,这个索引是一个查找表,它将每个术语(词)映射到与%_content表中包含一个或多个术语出现的记录相对应的docid值集。为了检索包含指定术语的所有文档,FTS模块查询该索引以确定包含该术语的记录的docid值集,然后从%_content表中检索所需文档。无论FTS虚拟表的模式如何,%_segments和%_segdir表总是按如下方式创建。</target>
        </trans-unit>
        <trans-unit id="57eb59a7de5c1f2eacd1a8c2e2793991396d4104" translate="yes" xml:space="preserve">
          <source>The two salt value copied from the WAL file header. These values are in the byte-order of the WAL file, which might be different from the native byte-order of the machine.</source>
          <target state="translated">从WAL文件头复制的两个盐值。这些值是按WAL文件的字节顺序排列的,可能与机器的原始字节顺序不同。</target>
        </trans-unit>
        <trans-unit id="ccc9e431ebc7fabfa6726082e51ef8838fff247f" translate="yes" xml:space="preserve">
          <source>The two-argument version of &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; accepts a pointer to the tokenizer method object even without the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;) setting if the second argument is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt;</source>
          <target state="translated">如果第二个参数是&lt;a href=&quot;lang_expr#varparam&quot;&gt;绑定参数，&lt;/a&gt;则即使没有&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;）设置，&lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer（）&lt;/a&gt;的两个参数版本也会接受指向令牌生成器方法对象的指针。</target>
        </trans-unit>
        <trans-unit id="6b8d35e3a824a79bc7ce101b6a6ae7997418f4f7" translate="yes" xml:space="preserve">
          <source>The two-byte integer at offset 1 gives the start of the first freeblock on the page, or is zero if there are no freeblocks.</source>
          <target state="translated">位于偏移量1的两个字节的整数,给出了页面上第一个自由块的开始,如果没有自由块,则为零。</target>
        </trans-unit>
        <trans-unit id="c4473928239ae1bda74a9fb4bb8276860fc5ffb5" translate="yes" xml:space="preserve">
          <source>The two-byte integer at offset 3 gives the number of cells on the page.</source>
          <target state="translated">偏移量3的两个字节整数给出了页面上的单元数。</target>
        </trans-unit>
        <trans-unit id="a06521372b9101f2c70d6a3c29239fdaf5cbc5a7" translate="yes" xml:space="preserve">
          <source>The two-byte integer at offset 5 designates the start of the cell content area. A zero value for this integer is interpreted as 65536.</source>
          <target state="translated">偏移量5的两个字节的整数表示单元格内容区域的开始。该整数的零值被解释为65536。</target>
        </trans-unit>
        <trans-unit id="85da2eb104aa5ac23b3d2218d186677a6dbc8b7e" translate="yes" xml:space="preserve">
          <source>The two-byte value beginning at offset 16 determines the page size of the database. For SQLite versions 3.7.0.1 (2010-08-04) and earlier, this value is interpreted as a big-endian integer and must be a power of two between 512 and 32768, inclusive. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_1.html&quot;&gt;version 3.7.1&lt;/a&gt; (2010-08-23), a page size of 65536 bytes is supported. The value 65536 will not fit in a two-byte integer, so to specify a 65536-byte page size, the value at offset 16 is 0x00 0x01. This value can be interpreted as a big-endian 1 and thought of as a magic number to represent the 65536 page size. Or one can view the two-byte field as a little endian number and say that it represents the page size divided by 256. These two interpretations of the page-size field are equivalent.</source>
          <target state="translated">从偏移量16开始的两字节值确定数据库的页面大小。对于SQLite版本3.7.0.1（2010-08-04）和更早版本，此值解释为big-endian整数，并且必须是512到32768（含）之间的2的幂。从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_1.html&quot;&gt;版本3.7.1&lt;/a&gt;（2010-08-23）开始，支持65536字节的页面大小。值65536将不适合两个字节的整数，因此要指定65536字节的页面大小，偏移量16处的值为0x00 0x01。此值可以解释为big-endian 1，并且可以视为表示65536页大小的幻数。或者，可以将两个字节的字段视为一个小端数字，并说它表示页面大小除以256。页面大小字段的这两种解释是等效的。</target>
        </trans-unit>
        <trans-unit id="d620a0d4c1327669927184e30780adb142926606" translate="yes" xml:space="preserve">
          <source>The typedef is necessary to work around problems in certain C++ compilers.</source>
          <target state="translated">类型定义是必要的,以解决某些C++编译器的问题。</target>
        </trans-unit>
        <trans-unit id="2acee6be58c92d0d4d1c18a3c705f7ce6eca583d" translate="yes" xml:space="preserve">
          <source>The typeof(X) function returns a string that indicates the &lt;a href=&quot;datatype3&quot;&gt;datatype&lt;/a&gt; of the expression X: &quot;null&quot;, &quot;integer&quot;, &quot;real&quot;, &quot;text&quot;, or &quot;blob&quot;.</source>
          <target state="translated">typeof（X）函数返回一个字符串，该字符串指示表达式X 的&lt;a href=&quot;datatype3&quot;&gt;数据类型&lt;/a&gt;：&amp;ldquo; null&amp;rdquo;，&amp;ldquo; integer&amp;rdquo;，&amp;ldquo; real&amp;rdquo;，&amp;ldquo; text&amp;rdquo;或&amp;ldquo; blob&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="7de0eb427df1bd72e4d6981f084f01d2fd7b104b" translate="yes" xml:space="preserve">
          <source>The types and default collation sequences attached to each column must be the same for all component tables.</source>
          <target state="translated">对所有的组件表来说,附加在每一列上的类型和默认整理序列必须是相同的。</target>
        </trans-unit>
        <trans-unit id="7a193d6baad5e9eae89c634a076cd20d9e39a2d0" translate="yes" xml:space="preserve">
          <source>The unary operator</source>
          <target state="translated">单利运算符</target>
        </trans-unit>
        <trans-unit id="5de3e6de824f9a3c28afdefed054e3e170c8e0d8" translate="yes" xml:space="preserve">
          <source>The uncompress function should uncompress data previously compressed by the compress function. In other words, for all SQLite values X, it should be true that uncompress(compress(X)) equals X. When data that has been compressed by the compress function is read from the database by FTS4, it is passed to the uncompress function before it is used.</source>
          <target state="translated">uncompress函数应该对之前被压缩函数压缩过的数据进行解压。换句话说,对于所有的SQLite值X,uncompress(compress(X))应该是真的等于X,当FTS4从数据库中读取已经被压缩函数压缩过的数据时,会在使用之前将其传递给uncompress函数。</target>
        </trans-unit>
        <trans-unit id="04cb6e28b7a92f43a8ce66195a1ea7614bfeaae5" translate="yes" xml:space="preserve">
          <source>The underlying implementation can support some subset of these locking levels as long as it meets the other requirements of this paragraph. The locking level is specified as the second argument to both xLock and xUnlock. The xLock method increases the locking level to the specified locking level or higher. The xUnlock method decreases the locking level to no lower than the level specified. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt; means that the file is unlocked. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; gives permission to read the file. Multiple database connections can hold &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; at the same time. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt; is like &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; in that it is permission to read the file. But only a single connection can hold a reserved lock at any point in time. The &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt; is also permission to read the file. Other connections can continue to read the file as well, but no other connection is allowed to escalate a lock from none to shared. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt; is permission to write on the file. Only a single connection can hold an exclusive lock and no other connection can hold any lock (other than &quot;none&quot;) while one connection holds an exclusive lock. The xLock returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success, &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if it is unable to obtain the lock, or &lt;a href=&quot;rescode#ioerr_rdlock&quot;&gt;SQLITE_IOERR_RDLOCK&lt;/a&gt; if something else goes wrong. The xUnlock method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_unlock&quot;&gt;SQLITE_IOERR_UNLOCK&lt;/a&gt; for problems.</source>
          <target state="translated">只要满足本段的其他要求，基础实现就可以支持这些锁定级别的某些子集。锁定级别被指定为xLock和xUnlock的第二个参数。 xLock方法将锁定级别增加到指定的锁定级别或更高。 xUnlock方法将锁定级别降低到不低于指定的级别。&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt;表示文件已解锁。&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;授予读取文件的权限。多个数据库连接可以同时保存&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;。&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt;就像&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;因为它是读取文件的权限。但是在任何时间点只有一个连接可以保留保留的锁。该&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt;也读取该文件的权限。其他连接也可以继续读取文件，但是不允许其他连接将锁从无锁升级为共享锁。&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt;是在文件上写入的权限。只有一个连接可以拥有排他锁，而其他任何连接都不能拥有任何锁（&amp;ldquo;无&amp;rdquo;除外），而一个连接则可以拥有排他锁。该XLOCK返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;成功，&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;如果无法获得锁，或者&lt;a href=&quot;rescode#ioerr_rdlock&quot;&gt;SQLITE_IOERR_RDLOCK&lt;/a&gt;如果遇到其他问题。 xUnlock方法返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;成功，&lt;a href=&quot;rescode#ioerr_unlock&quot;&gt;SQLITE_IOERR_UNLOCK&lt;/a&gt;解决问题。</target>
        </trans-unit>
        <trans-unit id="0269000c82eb39065f294879a620aecf2c6e833d" translate="yes" xml:space="preserve">
          <source>The underscore character (unicode codepoint 96).</source>
          <target state="translated">下划线字符(unicode cepoint 96)。</target>
        </trans-unit>
        <trans-unit id="94b1d236b1b1bdea969b9f218085fccfc7fb6de3" translate="yes" xml:space="preserve">
          <source>The undo::activate command creates temporary triggers in the database that record all changes made to the tables named in the arguments.</source>
          <target state="translated">undo::activate命令在数据库中创建临时触发器,记录对参数中命名的表的所有更改。</target>
        </trans-unit>
        <trans-unit id="9d719f9a44e55c933ab5b5fa11156ee426d1545d" translate="yes" xml:space="preserve">
          <source>The undocumented &lt;b&gt;sqlite3_os_switch()&lt;/b&gt; interface has been removed.</source>
          <target state="translated">未&lt;b&gt;公开的sqlite3_os_switch（）&lt;/b&gt;接口已被删除。</target>
        </trans-unit>
        <trans-unit id="93cdbdaae25242141056e83b2feecd9f656881a8" translate="yes" xml:space="preserve">
          <source>The unicode tokenizer classifies all unicode characters as either &quot;separator&quot; or &quot;token&quot; characters. By default all space and punctuation characters, as defined by Unicode 6.1, are considered separators, and all other characters as token characters. More specifically, all unicode characters assigned to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode_character_property#General_Category&quot;&gt; general category&lt;/a&gt; beginning with &quot;L&quot; or &quot;N&quot; (letters and numbers, specifically) or to category &quot;Co&quot; (&quot;other, private use&quot;) are considered tokens. All other characters are separators.</source>
          <target state="translated">Unicode标记生成器将所有Unicode字符分类为&amp;ldquo;分隔符&amp;rdquo;或&amp;ldquo;令牌&amp;rdquo;字符。默认情况下，Unicode 6.1定义的所有空格和标点字符都被视为分隔符，所有其他字符都被视为标记字符。更具体地说，所有分配给以&amp;ldquo; L&amp;rdquo;或&amp;ldquo; N&amp;rdquo;开头的&lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode_character_property#General_Category&quot;&gt;通用类别&lt;/a&gt;（特别是字母和数字）或类别&amp;ldquo; Co&amp;rdquo;（&amp;ldquo;其他用途&amp;rdquo;）的所有unicode字符都被视为令牌。所有其他字符都是分隔符。</target>
        </trans-unit>
        <trans-unit id="8359d1281537e2db390ccb27a011cf0c1e07387b" translate="yes" xml:space="preserve">
          <source>The unicode(X) function returns the numeric unicode code point corresponding to the first character of the string X. If the argument to unicode(X) is not a string then the result is undefined.</source>
          <target state="translated">unicode(X)函数返回与字符串X的第一个字符相对应的数字unicode码点,如果unicode(X)的参数不是字符串,则结果未定义。</target>
        </trans-unit>
        <trans-unit id="b06912261f5bb2d984a2ea7d12c5ea40ed3062a1" translate="yes" xml:space="preserve">
          <source>The union-vtab is not built into SQLite. Union-vtab is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;. The source code for union-vtab is contained in a single file located at &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/unionvtab.c&quot;&gt;ext/misc/unionvtab.c&lt;/a&gt; in the SQLite source tree.</source>
          <target state="translated">union-vtab未内置在SQLite中。Union-vtab是&lt;a href=&quot;loadext&quot;&gt;可加载的扩展&lt;/a&gt;。union-vtab的源代码包含在SQLite源树中&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/unionvtab.c&quot;&gt;ext / misc / unionvtab.c&lt;/a&gt;的单个文件中。</target>
        </trans-unit>
        <trans-unit id="70f606d5ad9373cd7360030770268b87dc04b4a8" translate="yes" xml:space="preserve">
          <source>The union-vtab is read-only. Support for writing may be added at a later time, but writing is not a part of the initial implementation.</source>
          <target state="translated">union-vtab是只读的。以后可能会增加对写入的支持,但写入不是初始实现的一部分。</target>
        </trans-unit>
        <trans-unit id="217c127b8d7dc9166357c6c852e4edb92e8bd2cc" translate="yes" xml:space="preserve">
          <source>The union-vtab shall optimize access to the underlying real tables when the constraints on the query are among forms shown below. Other kinds of constraints may be optimized in the future, but only these constraints are optimized in the initial implementation.</source>
          <target state="translated">当查询的约束条件属于下图所示形式时,union-vtab应优化对底层实表的访问。以后可能会优化其他种类的约束条件,但在初始实现中只优化这些约束条件。</target>
        </trans-unit>
        <trans-unit id="5ad25f83f6534911bf90077b4a8c2d24284bf894" translate="yes" xml:space="preserve">
          <source>The unique id (INTEGER PRIMARY KEY)</source>
          <target state="translated">唯一的ID(INTEGER PRIMARY KEY)</target>
        </trans-unit>
        <trans-unit id="37c73afc15f55751239631e696091c5fb7a86756" translate="yes" xml:space="preserve">
          <source>The unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; will never use a file descriptor less than</source>
          <target state="translated">Unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;绝不会使用小于</target>
        </trans-unit>
        <trans-unit id="ae8287e8b161fa1549dd3442fa8607f53d8dfe62" translate="yes" xml:space="preserve">
          <source>The unlikely(X) function returns the argument X unchanged. The unlikely(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles at run-time (that is, during calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;). The purpose of the unlikely(X) function is to provide a hint to the query planner that the argument X is a boolean value that is usually not true. The unlikely(X) function is equivalent to &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood&lt;/a&gt;(X, 0.0625).</source>
          <target state="translated">不太可能（X）函数返回参数X不变。不大可能（X）函数是一种无操作，代码生成器会对其进行优化，以使其在运行时（即，在调用&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;期间）不占用任何CPU周期。不可能的（X）函数的目的是向查询计划者提供一个提示，即参数X是通常不是真的布尔值。可能性函数（X）等于&lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;可能性&lt;/a&gt;（X，0.0625）。</target>
        </trans-unit>
        <trans-unit id="f74bf3865d4b8d380ed09cdf9682ebd8ba365f80" translate="yes" xml:space="preserve">
          <source>The unlock-notify callback is not reentrant. If an application invokes any sqlite3_xxx API functions from within an unlock-notify callback, a crash or deadlock may be the result.</source>
          <target state="translated">unlock-notify回调是不可重入的。如果应用程序在解锁-通知回调中调用任何 sqlite3_xxx API 函数,可能会导致崩溃或死锁。</target>
        </trans-unit>
        <trans-unit id="9f10c2e623337226e56371f152fe9704c596a75e" translate="yes" xml:space="preserve">
          <source>The unlock_notify method is used access the &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface to the SQLite core library for testing purposes. The use of this method by applications is discouraged.</source>
          <target state="translated">unlock_notify方法用于访问&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;接口到SQLite核心库以进行测试。不鼓励应用程序使用此方法。</target>
        </trans-unit>
        <trans-unit id="c0db7fcedecb648c350c1b6f11ba954f23165737" translate="yes" xml:space="preserve">
          <source>The update hook implementation must not do anything that will modify the database connection that invoked the update hook. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the update hook. Note that &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">更新挂钩实现不得做任何会修改调用更新挂钩的数据库连接的操作。任何修改数据库连接的操作都必须推迟到触发更新钩子的&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;调用完成之后。请注意，在本段中，&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;都修改了其数据库连接，以实现&amp;ldquo;修改&amp;rdquo;的含义。</target>
        </trans-unit>
        <trans-unit id="09532968164962481e11046837aaa8bacbe59ea0" translate="yes" xml:space="preserve">
          <source>The update hook implementation must not do anything that will modify the database connection that invoked the update hook. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the update hook. Note that &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">更新挂钩实现不得做任何会修改调用更新挂钩的数据库连接的操作。任何修改数据库连接的操作都必须推迟到触发更新钩子的&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;调用完成之后。请注意，在本段中，&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;和&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;都修改了其数据库连接，以实现&amp;ldquo;修改&amp;rdquo;的含义。</target>
        </trans-unit>
        <trans-unit id="f188e349260d6d862bd1151de1aa0b41c96135c8" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_master and sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="translated">修改内部系统表（即sqlite_master和sqlite_sequence）时，不会调用更新挂钩。修改&lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表时，不会调用更新挂钩。</target>
        </trans-unit>
        <trans-unit id="d4c3b215f10d00c42f1094ebb70e270136be0ef6" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_master and sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="translated">修改内部系统表（即sqlite_master和sqlite_sequence）时，不会调用更新挂钩。修改&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表时，不会调用更新挂钩。</target>
        </trans-unit>
        <trans-unit id="f04fa9936d514fac1b991da703764bce23461785" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b14dc5637688b2512ff9a25b9caa046cb0c8fc2" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b3d709a5bf6d8d9c48b677160252ac4da74295a" translate="yes" xml:space="preserve">
          <source>The upper bound on the database &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache size&lt;/a&gt; has traditionally defaulted to 2000 pages. SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;version 3.12.0&lt;/a&gt; also changes this default setting to be &quot;-2000&quot; which means 2000*1024 bytes, regardless of page size. So, the upper bound on the amount of memory used for the page cache is unchanged.</source>
          <target state="translated">传统上，数据库&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;高速缓存大小&lt;/a&gt;的上限默认为2000页。SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;版本3.12.0&lt;/a&gt;还将默认设置更改为&amp;ldquo; -2000&amp;rdquo;，这意味着2000 * 1024字节，与页面大小无关。因此，用于页面缓存的内存量的上限不变。</target>
        </trans-unit>
        <trans-unit id="55e210be964a43ed3f79f81acfb0252d2ec508a2" translate="yes" xml:space="preserve">
          <source>The upper(X) function returns a copy of input string X in which all lower-case ASCII characters are converted to their upper-case equivalent.</source>
          <target state="translated">upper(X)函数返回一个输入字符串X的副本,其中所有小写的ASCII字符都被转换为等价的大写字符。</target>
        </trans-unit>
        <trans-unit id="2ff3bb49a7df2e57465c506adbfbac36859c676c" translate="yes" xml:space="preserve">
          <source>The upsert above inserts the new vocabulary word &quot;jovial&quot; if that word is not already in the dictionary, or if it is already in the dictionary, it increments the counter. The &quot;count+1&quot; expression could also be written as &quot;vocabulary.count&quot;. PostgreSQL requires the second form, but SQLite accepts either.</source>
          <target state="translated">上面的upsert插入了新的词汇 &quot;jovial&quot;,如果该词还没有在字典中,或者如果它已经在字典中,则递增计数器。&quot;count+1 &quot;表达式也可以写成 &quot;vocabulary.count&quot;。PostgreSQL需要第二种形式,但SQLite接受任何一种形式。</target>
        </trans-unit>
        <trans-unit id="f98914d65daf1eee948f9cf4215d1bc155ef41fa" translate="yes" xml:space="preserve">
          <source>The usage of pagecache memory is somewhat harder to control in SQLite version 3.6.1, though mechanisms are planned for subsequent releases that will make controlling pagecache memory much easier. Prior to the introduction of these new mechanisms, the only way to control pagecache memory is using the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size pragma&lt;/a&gt;.</source>
          <target state="translated">在SQLite 3.6.1版中，页面缓存内存的使用在某种程度上很难控制，尽管计划为后续发行版设计机制，这将使控制页面缓存内存变得更加容易。在引入这些新机制之前，控制pagecache内存的唯一方法是使用&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size pragma&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="83c37f6e9e518d22e126d6f49713b321c1f31d9b" translate="yes" xml:space="preserve">
          <source>The use of &quot;:&quot; instead of &quot;$&quot; before the name of a variable can sometimes be useful if the SQL text is enclosed in double-quotes &quot;...&quot; instead of curly-braces {...}. When the SQL is contained within double-quotes &quot;...&quot; then TCL will do the substitution of $-variables, which can lead to SQL injection if extreme care is not used. But TCL will never substitute a :-variable regardless of whether double-quotes &quot;...&quot; or curly-braces {...} are used to enclose the SQL, so the use of :-variables adds an extra measure of defense against SQL injection.</source>
          <target state="translated">如果SQL文本用双引号&quot;...&quot;代替大括号{...},在变量名前使用&quot;:&quot;代替&quot;$&quot;有时会很有用。当SQL文本包含在双引号&quot;...&quot;内时,那么TCL会对$-变量进行替换,如果不格外小心,可能会导致SQL注入。但是TCL无论用双引号&quot;...&quot;还是用大括号{...}来封闭SQL,都不会用:-变量来替代,所以使用:-变量就多了一道防御SQL注入的措施。</target>
        </trans-unit>
        <trans-unit id="c10b4d5006af0e657932026cc02e7f4a31cf3940" translate="yes" xml:space="preserve">
          <source>The use of NUL characters in SQL text strings is not recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ba0fe6640d81c27b2028a34ac03622ddcd61d3" translate="yes" xml:space="preserve">
          <source>The use of a ZIP archive to encapsulate XML files plus resources is an elegant approach to an application file format. It is clearly superior to a custom binary file format. But using an SQLite database as the container, instead of ZIP, would be more elegant still.</source>
          <target state="translated">使用ZIP归档来封装XML文件加资源是一种优雅的应用文件格式的方法。它显然优于定制的二进制文件格式。但使用SQLite数据库作为容器,而不是ZIP,仍然会更优雅。</target>
        </trans-unit>
        <trans-unit id="62a1d7ca77be3f3b5567800401dc0bf052c2aaae" translate="yes" xml:space="preserve">
          <source>The use of a virtual machine in SQLite has been a great benefit to the library's development. The virtual machine provides a crisp, well-defined junction between the front-end of SQLite (the part that parses SQL statements and generates virtual machine code) and the back-end (the part that executes the virtual machine code and computes a result.) The virtual machine allows the developers to see clearly and in an easily readable form what SQLite is trying to do with each statement it compiles, which is a tremendous help in debugging. Depending on how it is compiled, SQLite also has the capability of tracing the execution of the virtual machine - printing each virtual machine instruction and its result as it executes.</source>
          <target state="translated">在SQLite中使用虚拟机对库的开发有很大的好处。虚拟机在SQLite的前端(解析SQL语句和生成虚拟机代码的部分)和后端(执行虚拟机代码和计算结果的部分)之间提供了一个清晰的、定义明确的交界点。&quot;虚拟机 &quot;使开发人员能够以一种易于阅读的形式清楚地看到SQLite编译的每一条语句要做什么,这对调试有极大的帮助。根据编译方式的不同,SQLite还具有跟踪虚拟机执行情况的功能--打印每条虚拟机指令及其执行结果。</target>
        </trans-unit>
        <trans-unit id="9d27ce1c6f5449fceeec41db3a7baef374e89122" translate="yes" xml:space="preserve">
          <source>The use of each of these methods will be explained in the sequel, though not in the order shown above.</source>
          <target state="translated">每一种方法的使用都将在后文中解释,尽管不是按照上述顺序。</target>
        </trans-unit>
        <trans-unit id="ac3e9e4d3a0d1a6a51dbf276370664c84cd0bc3c" translate="yes" xml:space="preserve">
          <source>The use of persistent journal mode provides a noticeable performance improvement on many systems. Of course, the drawback is that the journal files remain on the disk, using disk space and cluttering directories, long after the transaction commits. The only safe way to delete a persistent journal file is to commit a transaction with journaling mode set to DELETE:</source>
          <target state="translated">在许多系统中,使用持久性日志模式可以明显提高性能。当然,缺点是在事务提交后很长一段时间内,日志文件仍然留在磁盘上,占用磁盘空间,使目录杂乱无章。唯一安全的删除持久性日志文件的方法是提交事务时将日志模式设置为DELETE。</target>
        </trans-unit>
        <trans-unit id="ac2e1cc15280219a058aa01cbdd9d14acc3c174c" translate="yes" xml:space="preserve">
          <source>The use of pointer-passing is an advanced technique that should be used infrequently and cautiously. Pointer-passing should not be used haphazardly or carelessly. Pointer-passing is a sharp tool that can leave deep scars if misused.</source>
          <target state="translated">指针传递的使用是一种高级技术,应不经常使用,谨慎使用。不应随意或粗心地使用指针传递。指针传递是一种锋利的工具,如果使用不当,会留下很深的疤痕。</target>
        </trans-unit>
        <trans-unit id="716439e76a7ceab1c8c91b09a2f76c73c53bf8c1" translate="yes" xml:space="preserve">
          <source>The use of subtypes on pointers prevented pointer forgery using pure SQL. But subtypes do nothing to prevent an attacker from reading the values of pointers. In other words, subtypes on pointer values prevent attacks using SQL statements like this:</source>
          <target state="translated">在指针上使用子类型可以防止使用纯SQL的指针伪造。但是子类型对于防止攻击者读取指针的值没有任何作用。换句话说,指针值上的子类型可以防止使用这样的SQL语句进行攻击。</target>
        </trans-unit>
        <trans-unit id="d8ed607375ddfb8582a61f0a5132f51fb52c53b0" translate="yes" xml:space="preserve">
          <source>The use of the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is recommended for all applications.</source>
          <target state="translated">建议在所有应用程序中使用&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="789c46abbb3fc4976d476150773395da4c1e0a98" translate="yes" xml:space="preserve">
          <source>The use of the UTF-8 interfaces is preferred, as SQLite currently does all parsing using UTF-8. The UTF-16 interfaces are provided as a convenience. The UTF-16 interfaces work by converting the input text into UTF-8, then invoking the corresponding UTF-8 interface.</source>
          <target state="translated">使用UTF-8接口是首选,因为SQLite目前使用UTF-8进行所有的解析。UTF-16接口是作为一种方便而提供的,它的工作原理是将输入的文本转换成UTF-8,然后调用相应的UTF-8接口。UTF-16接口的工作原理是将输入文本转换为UTF-8,然后调用相应的UTF-8接口。</target>
        </trans-unit>
        <trans-unit id="7ed5c8c8570cfb3a0d0049b76c3fa5c381dc896c" translate="yes" xml:space="preserve">
          <source>The use of the error logger callback is highly recommended. The debugging information that the error logger provides has proven very useful in tracking down obscure problems that occurs with applications after they get into the field. The error logger callback has also proven useful in catching errors occasional errors that the application misses because of inconsistent checking of API return codes. Developers are encouraged to implement an error logger callback early in the development cycle in order to spot unexpected behavior quickly, and to leave the error logger callback turned on through deployment. If the error logger never finds a problem, then no harm is done. But failure to set up an appropriate error logger might compromise diagnostic capabilities later on.</source>
          <target state="translated">强烈建议使用错误记录器回调。事实证明,错误记录器提供的调试信息对于跟踪应用程序进入现场后发生的不明显问题非常有用。事实证明,错误记录器回调在捕捉错误方面也很有用,因为应用程序会因为不一致的API返回代码检查而错过错误。我们鼓励开发人员在开发周期的早期实现错误记录器回调,以便快速发现意外行为,并在部署过程中保持错误记录器回调的开启状态。如果错误记录器从未发现问题,那么就不会造成伤害。但是如果没有设置一个合适的错误记录器,可能会影响以后的诊断能力。</target>
        </trans-unit>
        <trans-unit id="a848d528e6bb7ea17daf03362baa03e736e192f7" translate="yes" xml:space="preserve">
          <source>The use of the standardized speedtest1.c workload and cachegrind has enabled significant performance improvement. However, it is important to recognize the limitations of this approach:</source>
          <target state="translated">使用标准化的speedtest1.c工作负载和cachegrind使性能得到显著提高。但是,必须认识到这种方法的局限性。</target>
        </trans-unit>
        <trans-unit id="fbf470196dd9e32d7a6c5961b17698cfadfdbb60" translate="yes" xml:space="preserve">
          <source>The use of variable-length records by SQLite has a number of advantages. It results in smaller database files, obviously. It also makes the database run faster, since there is less information to move to and from disk. And, the use of variable-length records makes it possible for SQLite to employ manifest typing instead of static typing.</source>
          <target state="translated">SQLite使用可变长度记录有很多优点。很明显,它可以使数据库文件更小。它还使数据库运行得更快,因为需要从磁盘上移入和移出的信息更少。而且,可变长度记录的使用使得SQLite有可能采用manifest typing而不是静态 typing。</target>
        </trans-unit>
        <trans-unit id="f495ec4a4bf3743c12d1f50425c742888001cad3" translate="yes" xml:space="preserve">
          <source>The user_version pragma will to get or set the value of the user-version integer at offset 60 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;. The user-version is an integer that is available to applications to use however they want. SQLite makes no use of the user-version itself.</source>
          <target state="translated">user_version编译指示将获取或设置&lt;a href=&quot;fileformat2#database_header&quot;&gt;数据库标头&lt;/a&gt;中偏移60处的user-version整数的值。用户版本是一个整数，应用程序可以根据需要使用它。SQLite不使用用户版本本身。</target>
        </trans-unit>
        <trans-unit id="81fbf2e7b21c5d201e92f96deae7ccf53bbeeddc" translate="yes" xml:space="preserve">
          <source>The usermerge option is similar to the automerge and crisismerge options. It is the minimum number of b-tree segments that will be merged together by a 'merge' command with a positive parameter. For example:</source>
          <target state="translated">usermerge 选项与 automerge 和 crisismerge 选项类似。它是一个带有正参数的 &quot;merge &quot;命令将合并在一起的b树段的最小数量。例如</target>
        </trans-unit>
        <trans-unit id="7380a4170d0b89318a355604d7dab9b3376f5f00" translate="yes" xml:space="preserve">
          <source>The usual &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; commands work on an R*Tree index just like on regular tables. So to insert some data into our sample R*Tree index, we can do something like this:</source>
          <target state="translated">常规&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;，&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;和&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;命令在R * Tree索引上工作，就像在常规表上一样。因此，要将一些数据插入示例R * Tree索引中，我们可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="7245ad2ccb3652b74420857f1f81436b120932a2" translate="yes" xml:space="preserve">
          <source>The usual case is that sqlite3_serialize() copies the serialization of the database into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and returns a pointer to that memory. The caller is responsible for freeing the returned value to avoid a memory leak. However, if the F argument contains the SQLITE_SERIALIZE_NOCOPY bit, then no memory allocations are made, and the sqlite3_serialize() function will return a pointer to the contiguous memory representation of the database that SQLite is currently using for that database, or NULL if the no such contiguous memory representation of the database exists. A contiguous memory representation of the database will usually only exist if there has been a prior call to &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize(D,S,...)&lt;/a&gt; with the same values of D and S. The size of the database is written into *P even if the SQLITE_SERIALIZE_NOCOPY bit is set but no contiguous copy of the database exists.</source>
          <target state="translated">通常的情况是sqlite3_serialize（）将数据库的序列化复制到从&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;获得的内存中，并返回指向该内存的指针。调用者负责释放返回的值，以避免内存泄漏。但是，如果F参数包含SQLITE_SERIALIZE_NOCOPY位，则不进行内存分配，并且sqlite3_serialize（）函数将返回一个指针，该指针指向SQLite当前用于该数据库的数据库的连续内存表示形式；如果否，则返回NULL。存在数据库的这种连续内存表示形式。通常只有在先调用&lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize（D，S，...）&lt;/a&gt;后，数据库的连续内存表示形式才会存在。具有相同的D和S值。即使将SQLITE_SERIALIZE_NOCOPY位置1，但不存在数据库的连续副本，数据库的大小也会写入* P。</target>
        </trans-unit>
        <trans-unit id="69659aa2e08fcc19f80f4fa144bcabaf8c7b3ed8" translate="yes" xml:space="preserve">
          <source>The usual case is that sqlite3_serialize() copies the serialization of the database into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and returns a pointer to that memory. The caller is responsible for freeing the returned value to avoid a memory leak. However, if the F argument contains the SQLITE_SERIALIZE_NOCOPY bit, then no memory allocations are made, and the sqlite3_serialize() function will return a pointer to the contiguous memory representation of the database that SQLite is currently using for that database, or NULL if the no such contiguous memory representation of the database exists. A contiguous memory representation of the database will usually only exist if there has been a prior call to &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize(D,S,...)&lt;/a&gt; with the same values of D and S. The size of the database is written into *P even if the SQLITE_SERIALIZE_NOCOPY bit is set but no contiguous copy of the database exists.</source>
          <target state="translated">通常的情况是sqlite3_serialize（）将数据库的序列化复制到从&lt;a href=&quot;free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;获得的内存中，并返回指向该内存的指针。调用者负责释放返回的值，以避免内存泄漏。但是，如果F参数包含SQLITE_SERIALIZE_NOCOPY位，则不进行内存分配，并且sqlite3_serialize（）函数将返回一个指针，该指针指向SQLite当前用于该数据库的数据库的连续内存表示形式；如果否，则返回NULL。存在数据库的这种连续内存表示形式。通常只有在先调用&lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize（D，S，...）&lt;/a&gt;后，数据库的连续内存表示形式才会存在。具有相同的D和S值。即使将SQLITE_SERIALIZE_NOCOPY位置1，但不存在数据库的连续副本，数据库的大小也会写入* P。</target>
        </trans-unit>
        <trans-unit id="2878cf43bc017da229299a9eeb8ee3b6c95340de" translate="yes" xml:space="preserve">
          <source>The usual case is that the entire database file is checked. However, if the argument is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fc6512389ff21ec6ba0d889f8647d34fa1771be" translate="yes" xml:space="preserve">
          <source>The usual output is an SQL script that will transform database1.sqlite (the &quot;source&quot; database) into database2.sqlite (the &quot;destination&quot; database). This behavior can be altered using command-line switches:</source>
          <target state="translated">通常的输出是一个SQL脚本,它将把database1.sqlite(&quot;源 &quot;数据库)转换成database2.sqlite(&quot;目标 &quot;数据库)。这种行为可以通过命令行开关来改变。</target>
        </trans-unit>
        <trans-unit id="ebe7d136ea02a608354f8bf5123226386a80e2bf" translate="yes" xml:space="preserve">
          <source>The usual usage pattern for an sqlite3_changegroup object is as follows:</source>
          <target state="translated">sqlite3_changegroup对象的通常使用模式如下。</target>
        </trans-unit>
        <trans-unit id="f006b61943f366c81b0414ad0d7a764b14620096" translate="yes" xml:space="preserve">
          <source>The usual way of storing a date in a database table is as a single field, as either a unix timestamp, a julian day number, or an ISO-8601 dates string. But some application store dates as three separate fields for the year, month, and day.</source>
          <target state="translated">通常在数据库表中存储日期的方法是作为一个单一的字段,如unix时间戳,julian日数,或者ISO-8601日期字符串。但有些应用程序将日期存储为年、月、日三个独立的字段。</target>
        </trans-unit>
        <trans-unit id="e446494ebae458b5aea2681dfd535005a9fb5001" translate="yes" xml:space="preserve">
          <source>The value</source>
          <target state="translated">价值</target>
        </trans-unit>
        <trans-unit id="1493e5c49d89b37715d26870b14178bb98eff899" translate="yes" xml:space="preserve">
          <source>The value extracted is stored in register P3.</source>
          <target state="translated">提取的值存储在寄存器P3中。</target>
        </trans-unit>
        <trans-unit id="b67d4fe7f5972a61b5da20c2ef9a98c84328f043" translate="yes" xml:space="preserve">
          <source>The value of NEW.rowid is undefined in a BEFORE INSERT trigger in which the rowid is not explicitly set to an integer.</source>
          <target state="translated">在BEFORE INSERT触发器中,如果rowid没有被显式地设置为一个整数,那么NEW.rowid的值就没有被定义。</target>
        </trans-unit>
        <trans-unit id="6ccbeb6aa89a69300ffd6eb190f7535f8bc566cf" translate="yes" xml:space="preserve">
          <source>The value of SQLITE_THREADSAFE can be determined at run-time using the &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;接口确定SQLITE_THREADSAFE的值。</target>
        </trans-unit>
        <trans-unit id="d5ab5daf4c7771df3bc76b4527132dffd8bea934" translate="yes" xml:space="preserve">
          <source>The value of an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column must always be a non-NULL integer. The PRIMARY KEY columns of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table are also required to be non-NULL.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列的值必须始终为非NULL整数。&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表的PRIMARY KEY列也必须为非NULL。</target>
        </trans-unit>
        <trans-unit id="94d5eebfcf21e24cf605bf00db4a0642798783cd" translate="yes" xml:space="preserve">
          <source>The value of the N parameter to these interfaces should be non-negative. Future enhancements may make use of negative N values to define new kinds of function caching behavior.</source>
          <target state="translated">这些接口的N参数的值应该是非负值。未来的改进可能会利用负N值来定义新的函数缓存行为。</target>
        </trans-unit>
        <trans-unit id="cc7bdc3b5bd50bd43536e1eeee3d4c188a48e335" translate="yes" xml:space="preserve">
          <source>The value of the change counter is copied to the database handle change counter (returned by subsequent calls to sqlite3_changes()). Then the VMs internal change counter resets to 0. This is used by trigger programs.</source>
          <target state="translated">变更计数器的值被复制到数据库句柄变更计数器(由后续调用sqlite3_changes()返回)。然后虚拟机内部的变更计数器重置为0,这被触发程序使用。</target>
        </trans-unit>
        <trans-unit id="4a5b194cd44f85aade16e1c37ccac8a115177304" translate="yes" xml:space="preserve">
          <source>The value returned by sqlite3_backup_finish is &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if no sqlite3_backup_step() errors occurred, regardless or whether or not sqlite3_backup_step() completed. If an out-of-memory condition or IO error occurred during any prior sqlite3_backup_step() call on the same &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object, then sqlite3_backup_finish() returns the corresponding &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">如果没有发生sqlite3_backup_step（）错误，则无论sqlite3_backup_step（）是否完成，sqlite3_backup_finish返回的值为&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;。如果在同一&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象上进行任何先前的sqlite3_backup_step（）调用期间发生了内存不足的情况或IO错误，则sqlite3_backup_finish（）返回相应的&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a8b2a631496d509ee2b275504f995fbe8e4ff87c" translate="yes" xml:space="preserve">
          <source>The value returned by sqlite3_backup_finish is &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if no sqlite3_backup_step() errors occurred, regardless or whether or not sqlite3_backup_step() completed. If an out-of-memory condition or IO error occurred during any prior sqlite3_backup_step() call on the same &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object, then sqlite3_backup_finish() returns the corresponding &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">如果没有发生sqlite3_backup_step（）错误，则无论sqlite3_backup_step（）是否完成，sqlite3_backup_finish返回的值为&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。如果在同一&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象上进行任何先前的sqlite3_backup_step（）调用期间发生了内存不足的情况或IO错误，则sqlite3_backup_finish（）返回相应的&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bc51fa501b0d744e2b8200daac75839a3f391d4e" translate="yes" xml:space="preserve">
          <source>The values &lt;b&gt;M&lt;/b&gt; and &lt;b&gt;n&lt;/b&gt; are properties of the application. If an application is constructed in such a way that both &lt;b&gt;M&lt;/b&gt; and &lt;b&gt;n&lt;/b&gt; are known, or at least have known upper bounds, and if the application uses the &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; memory allocator and is provided with &lt;b&gt;N&lt;/b&gt; bytes of available memory space using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; then Robson proves that no memory allocation request will ever fail within the application. To put this another way, the application developer can select a value for &lt;b&gt;N&lt;/b&gt; that will guarantee that no call to any SQLite interface will ever return &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;. The memory pool will never become so fragmented that a new memory allocation request cannot be satisfied. This is an important property for applications where a software fault could cause injury, physical harm, or loss of irreplaceable data.</source>
          <target state="translated">值&lt;b&gt;M&lt;/b&gt;和&lt;b&gt;n&lt;/b&gt;是应用程序的属性。如果以&lt;b&gt;M&lt;/b&gt;和&lt;b&gt;n&lt;/b&gt;都已知或至少具有已知上限的方式构造应用程序，并且如果该应用程序使用&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;内存分配器并使用&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;提供了&lt;b&gt;N&lt;/b&gt;字节的可用内存空间，则罗布森证明没有内存分配请求将永远不会在应用程序内失败。换句话说，应用程序开发人员可以为&lt;b&gt;N&lt;/b&gt;选择一个值，该值将确保对任何SQLite接口的调用都不会返回&lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM。&lt;/a&gt;&lt;b&gt;&lt;/b&gt;。内存池永远不会变得如此零散，以致无法满足新的内存分配请求。对于软件故障可能导致人身伤害，物理伤害或不可替代数据丢失的应用程序，这是重要的属性。</target>
        </trans-unit>
        <trans-unit id="22f534f2da25c6b7c05e8783b8e5bfbbc59c87e8" translate="yes" xml:space="preserve">
          <source>The values for each column in the record immediately follow the header. For serial types 0, 8, 9, 12, and 13, the value is zero bytes in length. If all columns are of these types then the body section of the record is empty.</source>
          <target state="translated">记录中每一列的值紧随页眉之后。对于序列类型0、8、9、12和13,值的长度为零字节。如果所有列都是这些类型,那么记录的主体部分是空的。</target>
        </trans-unit>
        <trans-unit id="d128efd1de498da70d20d12d2513201d5001c97a" translate="yes" xml:space="preserve">
          <source>The values for each column of the row are stored in these columns. The &quot;.recover&quot; command creates the lost_and_found table with as many columns as required by the longest orphaned row.</source>
          <target state="translated">行的每一列的值都存储在这些列中。&quot;.recover &quot;命令创建了丢失和发现表,表的列数与最长的孤儿行所需的列数相同。</target>
        </trans-unit>
        <trans-unit id="fd6b2ec514a48d20f0372d7449abd69ec8081347" translate="yes" xml:space="preserve">
          <source>The values placed in the sqlite_stat1 table by an approximate ANALYZE are not exactly the same as what would be computed by an unrestricted analysis. But they are usually close enough. The index statistics in the sqlite_stat1 table are approximations in any case, so the fact that the results of an approximate ANALYZE are slightly different from a traditional full scan ANALYZE has little practical impact. It is possible to construct a pathological case where an approximate ANALYZE is noticeably inferior to a full-scan ANALYZE, but such cases rare in real-world problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61332fb4ed04580474ae395b4c8e0cfc53138b43" translate="yes" xml:space="preserve">
          <source>The values returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; do not include the zero terminators at the end of the string. For clarity: the values returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; are the number of bytes in the string, not the number of characters.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16（）&lt;/a&gt;返回的值在字符串末尾不包含零终止符。为了清楚起见：&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16（）&lt;/a&gt;返回的值是字符串中的字节数，而不是字符数。</target>
        </trans-unit>
        <trans-unit id="56d75a71d4310cb50689d453693c130f5e211175" translate="yes" xml:space="preserve">
          <source>The values returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; do not include the zero terminators at the end of the string. For clarity: the values returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; are the number of bytes in the string, not the number of characters.</source>
          <target state="translated">&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes（）&lt;/a&gt;和&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16（）&lt;/a&gt;返回的值在字符串末尾不包含零终止符。为了清楚起见：&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes（）&lt;/a&gt;和&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16（）&lt;/a&gt;返回的值是字符串中的字节数，而不是字符数。</target>
        </trans-unit>
        <trans-unit id="9a34a413d802292386ca8ed35bad50613a2e40f9" translate="yes" xml:space="preserve">
          <source>The values returned by sqlite3_errcode() and/or sqlite3_extended_errcode() might change with each API call. Except, there are some interfaces that are guaranteed to never change the value of the error code. The error-code preserving interfaces are:</source>
          <target state="translated">sqlite3_errcode()和/或 sqlite3_extended_errcode()返回的值可能会随着每次API调用而改变。只不过,有一些接口是保证永远不会改变错误代码的值的。错误代码保存的接口有</target>
        </trans-unit>
        <trans-unit id="af0883b91a2c32edd6bb6e8adf9674294de318ba" translate="yes" xml:space="preserve">
          <source>The variable &lt;b&gt;$x&lt;/b&gt; is set by the above code to</source>
          <target state="translated">上面的代码将变量&lt;b&gt;$ x&lt;/b&gt;设置为</target>
        </trans-unit>
        <trans-unit id="e81b821adc588b80803661eb9435ef7daf5e77e6" translate="yes" xml:space="preserve">
          <source>The variable i in the previous expression varies between 0 and 9. Conceptually, the index space is divided into 10 uniform buckets and the samples are the middle row from each bucket.</source>
          <target state="translated">前面表达式中的变量i在0到9之间变化。从概念上讲,索引空间被分为10个统一的桶,样本是每个桶的中间一行。</target>
        </trans-unit>
        <trans-unit id="e46969b4d5144ef5a3ecc1c7c5e86080c0dd5e34" translate="yes" xml:space="preserve">
          <source>The various &lt;b&gt;sqlite_stat&lt;/b&gt;</source>
          <target state="translated">各种&lt;b&gt;sqlite_stat&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4ea0a2ad541e7dfd246d5e09a98161b66d983211" translate="yes" xml:space="preserve">
          <source>The various SQLite Archive Archive commands are implemented using SQL statements. Application developers can easily add SQLite Archive Archive reading and writing support to their own projects by running the appropriate SQL.</source>
          <target state="translated">各种SQLite Archive Archive命令都是使用SQL语句实现的。应用程序开发人员可以通过运行适当的SQL语句,轻松地将SQLite Archive Archive读写支持添加到自己的项目中。</target>
        </trans-unit>
        <trans-unit id="22f8ca9c7ec1168dbb45b57fd3ebfbf3e9d60926" translate="yes" xml:space="preserve">
          <source>The various assert()-like macros behave differently according to how SQLite is built.</source>
          <target state="translated">各种类似 assert()的宏根据 SQLite 的构建方式而表现不同。</target>
        </trans-unit>
        <trans-unit id="8789a3da4f75d5b0392ef189d216e2c9312d1546" translate="yes" xml:space="preserve">
          <source>The various unix VFSes differ only in the way they handle file locking - they share most of their implementation in common with one another and are all located in the same SQLite source file: &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt;. Note that except for &quot;unix&quot; and &quot;unix-excl&quot;, the various unix VFSes all use incompatible locking implementations. If two processes are accessing the same SQLite database using different unix VFSes, they may not see each others locks and may end up interfering with one another, resulting in database corruption. The &quot;unix-none&quot; VFS in particular does no locking at all and will easily result in database corruption if used by two or more database connections at the same time. Programmers are encouraged to use only &quot;unix&quot; or &quot;unix-excl&quot; unless there is a compelling reason to do otherwise.</source>
          <target state="translated">各种UNIX VFS的区别仅在于它们处理文件锁定的方式不同-它们彼此共享大多数实现，并且都位于同一SQLite源文件&lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/os_unix.c&quot;&gt;os_unix.c中&lt;/a&gt;。请注意，除了&amp;ldquo; unix&amp;rdquo;和&amp;ldquo; unix-excl&amp;rdquo;以外，各种UNIX VFS都使用不兼容的锁定实现。如果两个进程正在使用不同的unix VFS访问同一SQLite数据库，则它们可能看不到彼此的锁，并且最终可能会相互干扰，从而导致数据库损坏。特别是&amp;ldquo; unix-none&amp;rdquo; VFS根本没有锁定，如果同时由两个或多个数据库连接使用，则很容易导致数据库损坏。鼓励程序员仅使用&amp;ldquo; unix&amp;rdquo;或&amp;ldquo; unix-excl&amp;rdquo;除非有令人信服的理由否则。</target>
        </trans-unit>
        <trans-unit id="c5ffe5eea46cbcd5a1594ce73f72bf62a68d39e3" translate="yes" xml:space="preserve">
          <source>The versions of SQLite that come preinstalled on Apple Mac OS X computers contain a version of SQLite that has been extended to use alternative locking strategies that work on all network filesystems that Apple supports. These extensions used by Apple work great as long as all processes are accessing the database file in the same way. Unfortunately, the locking mechanisms do not exclude one another, so if one process is accessing a file using (for example) AFP locking and another process (perhaps on a different machine) is using dot-file locks, the two processes might collide because AFP locks do not exclude dot-file locks or vice versa.</source>
          <target state="translated">预装在苹果Mac OS X电脑上的SQLite版本包含了一个SQLite的版本,该版本已经扩展到使用替代锁定策略,可以在苹果支持的所有网络文件系统上工作。只要所有进程都以同样的方式访问数据库文件,苹果使用的这些扩展就非常好用。不幸的是,这些锁定机制并不相互排斥,因此,如果一个进程使用(例如)AFP锁定访问文件,而另一个进程(可能在不同的机器上)使用点文件锁定,这两个进程可能会发生碰撞,因为AFP锁定并不排斥点文件锁定,反之亦然。</target>
        </trans-unit>
        <trans-unit id="27a68965a58736f6647ab050fea465e20bf8ddef" translate="yes" xml:space="preserve">
          <source>The versions of the SQLite amalgamation that are supplied on the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; are normally adequate for most users. However, some projects may want or need to build their own amalgamations. A common reason for building a custom amalgamation is in order to use certain &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; to customize the SQLite library. Recall that the SQLite amalgamation contains a lot of C-code that is generated by auxiliary programs and scripts. Many of the compile-time options effect this generated code and must be supplied to the code generators before the amalgamation is assembled. The set of compile-time options that must be passed into the code generators can vary from one release of SQLite to the next, but at the time of this writing (circa SQLite 3.6.20, 2009-11-04) the set of options that must be known by the code generators includes:</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;下载页面&lt;/a&gt;上提供的SQLite合并版本通常适合大多数用户。但是，某些项目可能想要或需要构建自己的合并。建立自定义合并的常见原因是为了使用某些&lt;a href=&quot;compile&quot;&gt;编译时选项&lt;/a&gt;自定义SQLite库。回想一下，SQLite合并包含许多由辅助程序和脚本生成的C代码。许多编译时选项会影响此生成的代码，因此在组合合并之前必须将其提供给代码生成器。从一个版本的SQLite到下一个版本，必须传递给代码生成器的一组编译时选项可能会有所不同，但是在撰写本文时（大约在SQLite 3.6.20中，2009-11-04），这组选项代码生成器必须知道的内容包括：</target>
        </trans-unit>
        <trans-unit id="d08eefb01c3e7948c8ed07ad520422cff4b9225d" translate="yes" xml:space="preserve">
          <source>The very name &quot;Structured Query Language&quot; tells us that SQL should support nested queries. And, in fact, two different kinds of nesting are supported. Any SELECT statement that returns a single-row, single-column result can be used as a term in an expression of another SELECT statement. And, a SELECT statement that returns a single-column, multi-row result can be used as the right-hand operand of the IN and NOT IN operators. We will begin this section with an example of the first kind of nesting, where a single-row, single-column SELECT is used as a term in an expression of another SELECT. Here is our example:</source>
          <target state="translated">&quot;结构化查询语言 &quot;这个名字就告诉我们,SQL应该支持嵌套查询。而事实上,支持两种不同的嵌套。任何返回单行、单列结果的SELECT语句都可以作为另一条SELECT语句表达式中的术语。而且,一个返回单列、多行结果的SELECT语句可以作为IN和NOT IN操作符的右手操作数。我们将以第一种嵌套的例子开始本节,在这种嵌套中,一个单行、单列的SELECT被用作另一个SELECT表达式中的术语。下面是我们的例子。</target>
        </trans-unit>
        <trans-unit id="20c4a011c8e3b37249d4469eb52a0ff7a1d9c48e" translate="yes" xml:space="preserve">
          <source>The vfs query parameter causes the database connection to be opened using the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; called</source>
          <target state="translated">vfs查询参数导致使用称为&lt;a href=&quot;vfs&quot;&gt;VFS的VFS&lt;/a&gt;打开数据库连接</target>
        </trans-unit>
        <trans-unit id="7fc9c565eeb1c6123557989180ff5a163d06934e" translate="yes" xml:space="preserve">
          <source>The view to drop is identified by the view-name and optional schema-name specified as part of the DROP VIEW statement. This reference is resolved using the standard procedure for &lt;a href=&quot;lang_naming&quot;&gt;object resolution&lt;/a&gt;.</source>
          <target state="translated">要删除的视图由在DROP VIEW语句中指定的视图名称和可选模式名称标识。使用标准的&lt;a href=&quot;lang_naming&quot;&gt;对象解析&lt;/a&gt;程序可以解决此参考。</target>
        </trans-unit>
        <trans-unit id="3b2c6960eedc019bcf13fce258370b16a245ba89" translate="yes" xml:space="preserve">
          <source>The view v1 cannot be &lt;a href=&quot;optoverview#flattening&quot;&gt;flattened&lt;/a&gt; because it is DISTINCT. It must instead be run as a subquery with the results being stored in a transient table, then the join is performed between t2 and the transient table. The push-down optimization pushes down the &quot;b BETWEEN 10 AND 20&quot; term into the view. This makes the transient table smaller, and helps the subquery to run faster if there is an index on t1.b. The resulting evaluation is like this:</source>
          <target state="translated">由于视图v1 是DISTINCT，因此无法将其展&lt;a href=&quot;optoverview#flattening&quot;&gt;平&lt;/a&gt;。相反，它必须作为子查询运行，并将结果存储在临时表中，然后在t2和临时表之间执行联接。下推式优化将&amp;ldquo; b介于10和20之间&amp;rdquo;的条件下推到视图中。这使临时表变小，并且如果t1.b上有索引，则有助于子查询更快地运行。结果评估如下：</target>
        </trans-unit>
        <trans-unit id="ce6b93653a867ff824a137b275a2d8a4b5929427" translate="yes" xml:space="preserve">
          <source>The virtual machine itself is entirely contained in a single source file &lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt;. The &lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.h&quot;&gt;vdbe.h&lt;/a&gt; header file defines an interface between the virtual machine and the rest of the SQLite library and &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeInt.h&quot;&gt;vdbeInt.h&lt;/a&gt; which defines structures and interfaces that are private the virtual machine itself. Various other &lt;b&gt;vdbe*.c&lt;/b&gt; files are helpers to the virtual machine. The &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeaux.c&quot;&gt;vdbeaux.c&lt;/a&gt; file contains utilities used by the virtual machine and interface modules used by the rest of the library to construct VM programs. The &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c&lt;/a&gt; file contains external interfaces to the virtual machine such as the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_int()&lt;/a&gt; and &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. Individual values (strings, integer, floating point numbers, and BLOBs) are stored in an internal object named &quot;Mem&quot; which is implemented by &lt;a href=&quot;https://sqlite.org/src/file/src/vdbemem.c&quot;&gt;vdbemem.c&lt;/a&gt;.</source>
          <target state="translated">虚拟机本身完全包含在单个源文件&lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c中&lt;/a&gt;。所述&lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.h&quot;&gt;vdbe.h&lt;/a&gt;头文件定义了虚拟机和SQLite库的其余部分之间的界面&lt;a href=&quot;https://sqlite.org/src/file/src/vdbeInt.h&quot;&gt;vdbeInt.h&lt;/a&gt;其定义了私人虚拟机本身的结构和接口。其他各种&lt;b&gt;vdbe * .c&lt;/b&gt;文件都是虚拟机的帮助程序。所述&lt;a href=&quot;https://sqlite.org/src/file/src/vdbeaux.c&quot;&gt;vdbeaux.c&lt;/a&gt;文件包含由所用的库的其余部分来构造VM程序在虚拟机和接口模块中使用的工具。所述&lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c&lt;/a&gt;文件包含外部接口到所述虚拟机，如&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_int（）&lt;/a&gt;和&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;。各个值（字符串，整数，浮点数和BLOB）存储在名为&amp;ldquo; Mem&amp;rdquo;的内部对象中，该对象由&lt;a href=&quot;https://sqlite.org/src/file/src/vdbemem.c&quot;&gt;vdbemem.c&lt;/a&gt;实现。</target>
        </trans-unit>
        <trans-unit id="00bcd77d6dec3bc1a5f96c0e0f3985aefbea69f9" translate="yes" xml:space="preserve">
          <source>The virtual table contains an xShadowName method.</source>
          <target state="translated">该虚拟表包含一个xShadowName方法。</target>
        </trans-unit>
        <trans-unit id="aba94b8d1e25fe7120c464dc013b1d34868edb66" translate="yes" xml:space="preserve">
          <source>The virtual table mechanism allows an application to publish interfaces that are accessible from SQL statements as if they were tables. SQL statements can do almost anything to a virtual table that they can do to a real table, with the following exceptions:</source>
          <target state="translated">虚拟表机制允许应用程序发布接口,这些接口可以像表一样从SQL语句中访问。SQL语句几乎可以对虚拟表做任何它们可以对真实表做的事情,但有以下例外。</target>
        </trans-unit>
        <trans-unit id="7616eb3efb8cfc2b544466ae9f36f2a81289f276" translate="yes" xml:space="preserve">
          <source>The virtual table will return one row of output for each token in the input string. The &quot;token&quot; column is the text of the token. The &quot;start&quot; and &quot;end&quot; columns are the byte offset to the beginning and end of the token in the original input string. The &quot;position&quot; column is the sequence number of the token in the original input string. There is also an &quot;input&quot; column which is simply a copy of the input string that is specified in the WHERE clause. Note that a constraint of the form &quot;input=?&quot; must appear in the WHERE clause or else the virtual table will have no input to tokenize and will return no rows. The example above generates the following output:</source>
          <target state="translated">虚拟表将为输入字符串中的每个标记返回一行输出。token &quot;列是token的文本,&quot;start &quot;和 &quot;end &quot;列是原始输入字符串中token的开始和结束的字节偏移。开始 &quot;和 &quot;结束 &quot;列是原始输入字符串中标记的开始和结束的字节偏移量,&quot;位置 &quot;列是原始输入字符串中标记的序列号。位置 &quot;列是标记在原始输入字符串中的序列号。还有一个 &quot;input &quot;列,是WHERE子句中指定的输入字符串的副本。请注意,WHERE子句中必须出现 &quot;input=? &quot;这样的约束条件,否则虚拟表将没有输入标记,也不会返回任何记录。上面的例子会产生以下输出。</target>
        </trans-unit>
        <trans-unit id="e7d6d48d0123dd78c2ece991b5f7661cea292174" translate="yes" xml:space="preserve">
          <source>The wal-index file or &quot;shm&quot; file is not actually used as a file. Rather, individual database clients mmap the shm file and use it as shared memory for coordinating access to the database and as a cache for quickly locating frame within the wal file. The name of the shm file is the main database file name with the four characters &quot;-shm&quot; appended. Or, for 8+3 filesystems, the shm file is the main database file with the suffix changed to &quot;.SHM&quot;.</source>
          <target state="translated">wal-index文件或 &quot;shm &quot;文件实际上并不作为一个文件使用。相反,各个数据库客户端对shm文件进行mmap,并将其作为共享内存来协调对数据库的访问,并作为缓存来快速定位wal文件中的框架。shm文件的名称是主数据库文件名,后面附加&quot;-shm &quot;四个字符。或者,对于8+3文件系统,shm文件是主数据库文件,后缀改为&quot;.SHM&quot;。</target>
        </trans-unit>
        <trans-unit id="2705cff44fec902d1ca3ce2af3b554cabc339fb3" translate="yes" xml:space="preserve">
          <source>The wal-index file, usually named &quot;X-shm&quot;.</source>
          <target state="translated">wal-index文件,通常命名为 &quot;X-shm&quot;。</target>
        </trans-unit>
        <trans-unit id="3164ee82328b180dbc8289eddc9db733f9109901" translate="yes" xml:space="preserve">
          <source>The wal-index is transient. After a crash, the wal-index is reconstructed from the original WAL file. The VFS is required to either truncate or zero the header of the wal-index when the last connection to it closes. Because the wal-index is transient, it can use an architecture-specific format; it does not have to be cross-platform. Hence, unlike the database and WAL file formats which store all values as big endian, the wal-index stores multi-byte values in the native byte order of the host computer.</source>
          <target state="translated">wal-index是瞬时的。崩溃后,wal-index会从原来的WAL文件重建。当与wal-index的最后一个连接关闭时,VFS需要将wal-index的头截断或清零。因为wal-index是瞬时的,所以它可以使用特定架构的格式;它不一定要跨平台。因此,与数据库和WAL文件格式不同的是,wal-index以大英汉字存储所有的值,它以主机的本地字节顺序存储多字节的值。</target>
        </trans-unit>
        <trans-unit id="f37728360280f92c82e5f63eda2235cd3fe649d8" translate="yes" xml:space="preserve">
          <source>The wal_checkpoint pragma returns a single row with three integer columns. The first column is usually 0 but will be 1 if a RESTART or FULL or TRUNCATE checkpoint was blocked from completing, for example because another thread or process was actively using the database. In other words, the first column is 0 if the equivalent call to &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; would have returned &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; or 1 if the equivalent call would have returned &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. The second column is the number of modified pages that have been written to the write-ahead log file. The third column is the number of pages in the write-ahead log file that have been successfully moved back into the database file at the conclusion of the checkpoint. The second and third column are -1 if there is no write-ahead log, for example if this pragma is invoked on a database connection that is not in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">wal_checkpoint编译指示返回包含三列整数的单行。第一列通常为0，但是如果阻止RESTART或FULL或TRUNCATE检查点完成，则该列为1，例如，因为另一个线程或进程正在积极使用数据库。换句话说，如果对&lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;的等效调用将返回&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_OK&lt;/a&gt;，则第一&lt;a href=&quot;rescode#ok&quot;&gt;列为&lt;/a&gt; 0；如果等效调用将返回SQLITE_BUSY，则第一列为 1。。第二列是已写入预写日志文件的已修改页数。第三列是预写日志文件中在检查点结束时已成功移回到数据库文件中的页面数。如果没有预写日志，例如，如果在非&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;的数据库连接上调用此编译指示，则第二列和第三列为-1 。</target>
        </trans-unit>
        <trans-unit id="7abca67d3b2f6649a3ed46e41721882b254d1af5" translate="yes" xml:space="preserve">
          <source>The way SQLite deals with this is to first run the inner SELECT (the one against examp2) and store its result in a private memory cell. SQLite then substitutes the value of this private memory cell for the inner SELECT when it evaluates the outer SELECT. The code looks like this:</source>
          <target state="translated">SQLite处理这个问题的方法是首先运行内部SELECT(针对examp2的那个),并将其结果存储在一个私有内存单元中。然后,SQLite在评估外层SELECT时,将这个私有内存单元的值替换为内部SELECT。代码看起来像这样。</target>
        </trans-unit>
        <trans-unit id="d9f0711eae8ce05c73449f6cd3513a09a5b0c229" translate="yes" xml:space="preserve">
          <source>The way in which the IN and NOT IN operators handle NULL values in their right-hand expressions has been brought into compliance with the SQL standard and with other SQL database engines.</source>
          <target state="translated">IN和NOT IN操作符在其右侧表达式中处理NULL值的方式已经符合SQL标准和其他SQL数据库引擎的要求。</target>
        </trans-unit>
        <trans-unit id="1bcbf2e1391b1aa7e3ebafdb83d7f3bc20c48ce0" translate="yes" xml:space="preserve">
          <source>The whole point of the xShadowName method is to protect the content of shadow tables from being corrupted by hostile SQL. Every virtual table implementation that uses shadow tables should be able to detect and cope with corrupted shadow table content. However, bugs in particular virtual table implementation might allow a deliberately corrupted shadow table to cause a crash or other malfunction. The xShadowName mechanism seeks to avoid zero-day exploits by preventing ordinary SQL statements from deliberately corrupting shadow tables.</source>
          <target state="translated">xShadowName方法的全部意义在于保护影子表的内容不被敌对的SQL破坏。每个使用影子表的虚拟表实现都应该能够检测和应对损坏的影子表内容。但是,特定虚拟表实现中的bug可能会让故意损坏的影子表导致崩溃或其他故障。xShadowName机制旨在通过防止普通SQL语句故意破坏影子表来避免零日漏洞。</target>
        </trans-unit>
        <trans-unit id="7ba3625dd3002c676817bb5d0641f1c309f9b35c" translate="yes" xml:space="preserve">
          <source>The width field specifies the minimum width of the substituted value in the output. If the string or number that is written into the output is shorter than the width, then the value is padded. Padding is on the left (the value is right-justified) by default. If the &quot;-&quot; flag is used, then the padding is on the right and the value is left-justified.</source>
          <target state="translated">宽度字段指定了输出中替代值的最小宽度。如果写入输出的字符串或数字短于宽度,那么该值将被填充。默认情况下,填充是在左边(值是右对齐的)。如果使用&quot;-&quot;标志,那么填充是在右边,值是左对齐的。</target>
        </trans-unit>
        <trans-unit id="a12aad5ee5dbe2d3fff555e1c8b3c9090a69eb38" translate="yes" xml:space="preserve">
          <source>The width is measured in bytes by default. However, if the &quot;!&quot; flag is present then the width is in characters. This only makes a difference for multi-byte utf-8 characters, and those only occur on string substitutions.</source>
          <target state="translated">默认情况下,宽度以字节为单位。但是,如果有&quot;!&quot;标志,则宽度以字符为单位。这只对多字节utf-8字符有区别,而且这些字符只在字符串替换时出现。</target>
        </trans-unit>
        <trans-unit id="bb37fe25186c24e9c2d6b18924cc12e6bf999427" translate="yes" xml:space="preserve">
          <source>The word transliterated into lower-case ASCII. There is a standard table of mappings from non-ASCII characters into ASCII. Examples: &quot;&amp;aelig;&quot; -&amp;gt; &quot;ae&quot;, &quot;&amp;thorn;&quot; -&amp;gt; &quot;th&quot;, &quot;&amp;szlig;&quot; -&amp;gt; &quot;ss&quot;, &quot;&amp;aacute;&quot; -&amp;gt; &quot;a&quot;, ... The accessory function spellfix1_translit(X) will do the non-ASCII to ASCII mapping. The built-in lower(X) function will convert to lower-case. Thus: k1 = lower(spellfix1_translit(word)). If the word is already all lower-case ASCII, then the k1 column will contain a NULL. This reduces the storage requirements for the %_vocab table and helps spellfix to run a little faster. Therefore, it is advantageous to populate as much of the spellfix table as possible using lower-case ASCII vocabulary.</source>
          <target state="translated">该单词已译为小写ASCII。有一个从非ASCII字符到ASCII的映射的标准表。例如：&amp;ldquo;&amp;aelig;&amp;rdquo;-&amp;gt;&amp;ldquo; ae&amp;rdquo;，&amp;ldquo;&amp;thorn;&amp;rdquo;-&amp;gt;&amp;ldquo; th&amp;rdquo;，&amp;ldquo;&amp;szlig;&amp;rdquo;-&amp;gt;&amp;ldquo; ss&amp;rdquo;，&amp;ldquo;&amp;aacute;&amp;rdquo;-&amp;gt;&amp;ldquo; a&amp;rdquo;，...辅助函数spellfix1_translit（X）将执行非ASCII到ASCII的映射。内置的lower（X）函数将转换为小写字母。因此：k1 = Lower（spellfix1_translit（word））。如果单词已经是全小写的ASCII，则k1列将包含NULL。这减少了％_vocab表的存储要求，并帮助spellfix运行得更快。因此，使用小写ASCII词汇表填充尽可能多的拼写修正表是有利的。</target>
        </trans-unit>
        <trans-unit id="2aea0dad5536afb073da7952899f42822308cf24" translate="yes" xml:space="preserve">
          <source>The working directory</source>
          <target state="translated">工作目录</target>
        </trans-unit>
        <trans-unit id="1191da9cfb737ab513b0974862b6931c34d468a3" translate="yes" xml:space="preserve">
          <source>The write-ahead log file, usually named &quot;X-wal&quot;.</source>
          <target state="translated">写入式日志文件,通常命名为 &quot;X-wal&quot;。</target>
        </trans-unit>
        <trans-unit id="aa76cd0207c05b41731ac87f189a853ae60f3634" translate="yes" xml:space="preserve">
          <source>The write-ahead log or &quot;wal&quot; file is a roll-forward journal that records transactions that have been committed but not yet applied to the main database. Details on the format of the wal file are describe in the &lt;a href=&quot;fileformat2#walformat&quot;&gt;WAL format&lt;/a&gt; subsection of the main &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; document. The wal file is named by appending the four characters &quot;-wal&quot; to the end of the name of the main database file. Except on 8+3 filesystems, such names are not allowed, and in that case the file suffix is changed to &quot;.WAL&quot;. But as 8+3 filesystems are increasingly rare, that exceptional case can usually be ignored.</source>
          <target state="translated">预写日志或&amp;ldquo; wal&amp;rdquo;文件是前滚日志，记录已提交但尚未应用到主数据库的事务。有关wal文件格式的详细信息，请参见主&lt;a href=&quot;fileformat2&quot;&gt;文件格式&lt;/a&gt;文档的&lt;a href=&quot;fileformat2#walformat&quot;&gt;WAL格式&lt;/a&gt;小节。通过在主数据库文件名的末尾附加四个字符&amp;ldquo; -wal&amp;rdquo;来命名wal文件。除8 + 3文件系统外，不允许使用此类名称，在这种情况下，文件后缀将更改为&amp;ldquo; .WAL&amp;rdquo;。但是，随着8 + 3文件系统越来越稀有，通常可以忽略这种例外情况。</target>
        </trans-unit>
        <trans-unit id="9fcf91986e20f3838e989f19567544d31cd8c593" translate="yes" xml:space="preserve">
          <source>The writefile(X,Y) SQL function write the blob Y into the file named X and returns the number of bytes written. Use this function to extract the content of a single table column into a file. For example:</source>
          <target state="translated">writefile(X,Y)SQL函数将blob Y写入名为X的文件中,并返回写入的字节数。使用该函数可以将单个表列的内容提取到文件中。例如</target>
        </trans-unit>
        <trans-unit id="35efa113638256d189c7bffd527a8b95982adee0" translate="yes" xml:space="preserve">
          <source>The writing test above is not completely fair, since SQLite is doing &lt;a href=&quot;transactional&quot;&gt;power-safe transactions&lt;/a&gt; whereas the direct-to-disk writing is not. To put the tests on a more equal footing, add either the --nosync option to the SQLite writes to disable calling fsync() or FlushFileBuffers() to force content to disk, or using the --fsync option for the direct-to-disk tests to force them to invoke fsync() or FlushFileBuffers() when updating disk files.</source>
          <target state="translated">上面的写入测试并不完全公平，因为SQLite正在执行&lt;a href=&quot;transactional&quot;&gt;电源安全事务，&lt;/a&gt;而直接写入磁盘则不是。为了使测试更加平等，请在SQLite写入中添加--nosync选项以禁止调用fsync（）或FlushFileBuffers（）将内容强制插入磁盘，或将--fsync选项用于直接磁盘测试，以强制他们在更新磁盘文件时调用fsync（）或FlushFileBuffers（）。</target>
        </trans-unit>
        <trans-unit id="3500eedb790da60f6c7c2c2fe42347161ad2dc7e" translate="yes" xml:space="preserve">
          <source>The xAccess method is used to check for access permissions on a file. The filename will be UTF-8 encoded. The flags argument will be &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; to check for the existence of the file, &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; to check to see if the file is both readable and writable, or &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; to check to see if the file is at least readable. The &quot;file&quot; named by the second parameter might be a directory or folder name.</source>
          <target state="translated">xAccess方法用于检查文件的访问权限。文件名将采用UTF-8编码。flags参数将是&lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt;来检查文件是否存在，&lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt;来检查文件是否可读和可写，或&lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt;来检查文件是否至少可读。第二个参数命名的&amp;ldquo;文件&amp;rdquo;可能是目录名或文件夹名。</target>
        </trans-unit>
        <trans-unit id="7e3dceb3a3d82f8b52bd7f5b2f951ed3b0619691" translate="yes" xml:space="preserve">
          <source>The xAccess() method is invoked again to detect if the journal file is still in the file system. If it is, then it is a hot-journal file and SQLite tries to roll it back (see section</source>
          <target state="translated">再次调用xAccess()方法来检测日志文件是否还在文件系统中。如果在,那么它就是一个热日志文件,SQLite会尝试将其回滚(见第2节</target>
        </trans-unit>
        <trans-unit id="be1521ac61f6da801d0f89ccb40ef26362bd2aea" translate="yes" xml:space="preserve">
          <source>The xAccess() method of the VFS is allowed to return -1 to signal a memory allocation error.</source>
          <target state="translated">VFS的xAccess()方法允许返回-1,以提示内存分配错误。</target>
        </trans-unit>
        <trans-unit id="dbb116d3015d148d9aef4ab4eaf91f8dc7699911" translate="yes" xml:space="preserve">
          <source>The xBestIndex function may have requested the values of certain expressions using the aConstraintUsage[].argvIndex values of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure. Those values are passed to xFilter using the argc and argv parameters.</source>
          <target state="translated">xBestIndex函数可能已使用&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;结构的aConstraintUsage []。argvIndex值请求了某些表达式的值。这些值使用argc和argv参数传递到xFilter。</target>
        </trans-unit>
        <trans-unit id="e673068c08d7f626c7139b66b363abe588afdbfb" translate="yes" xml:space="preserve">
          <source>The xBestIndex method fills the idxNum and idxStr fields with information that communicates an indexing strategy to the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. The information in idxNum and idxStr is arbitrary as far as the SQLite core is concerned. The SQLite core just copies the information through to the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. Any desired meaning can be assigned to idxNum and idxStr as long as xBestIndex and xFilter agree on what that meaning is.</source>
          <target state="translated">xBestIndex方法使用将索引策略传达给&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;方法的信息填充idxNum和idxStr字段。就SQLite核心而言，idxNum和idxStr中的信息是任意的。SQLite核心仅将信息复制到&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;方法。只要xBestIndex和xFilter同意该含义，就可以将任何期望的含义分配给idxNum和idxStr。</target>
        </trans-unit>
        <trans-unit id="7549b2c421b13b6947674708c7a5360fc1373a57" translate="yes" xml:space="preserve">
          <source>The xBestIndex method is required for every virtual table implementation.</source>
          <target state="translated">每个虚拟表的实现都需要xBestIndex方法。</target>
        </trans-unit>
        <trans-unit id="6671b4241ef5e4b25933598f6cbd513b0faa9c69" translate="yes" xml:space="preserve">
          <source>The xBestIndex method may optionally populate the idxFlags field with a mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag - SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite assumes that the strategy may visit at most one row.</source>
          <target state="translated">xBestIndex 方法可以选择用 SQLITE_INDEX_SCAN_*标志的掩码来填充 idxFlags 字段,目前只有一个这样的标志-SQLITE_INDEX_SCAN_UNIQUE。目前只有一个这样的标志--SQLITE_INDEX_SCAN_UNIQUE。如果xBestIndex方法设置了这个标志,SQLite就会认为该策略最多只能访问一条记录。</target>
        </trans-unit>
        <trans-unit id="60dc1bff84d7b24ecf260c549a70a2e550acd608" translate="yes" xml:space="preserve">
          <source>The xBestIndex method may set aConstraintUsage[].argvIndex entries to values greater than zero. Exactly one entry should be set to 1, another to 2, another to 3, and so forth up to as many or as few as the xBestIndex method wants. The EXPR of the corresponding constraints will then be passed in as the argv[] parameters to xFilter.</source>
          <target state="translated">xBestIndex方法可以将aConstraintUsage[].argvIndex条目设置为大于0的值。确切地说,一个条目应该设置为1,另一个条目设置为2,另一个条目设置为3,以此类推,xBestIndex方法想要多少就有多少。相应约束条件的EXPR将作为argv[]参数传递给xFilter。</target>
        </trans-unit>
        <trans-unit id="b0c67bb7b3ba635b9cd74ad89d5155e843f934eb" translate="yes" xml:space="preserve">
          <source>The xBestIndex method should return SQLITE_OK on success. If any kind of fatal error occurs, an appropriate error code (ex: &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;) should be returned instead.</source>
          <target state="translated">如果成功，xBestIndex方法应返回SQLITE_OK。如果发生任何类型的致命错误，则应返回适当的错误代码（例如：&lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6e2147722085d4c968213130f4ef993a32c73b66" translate="yes" xml:space="preserve">
          <source>The xBestIndex method will be invoked once for each of the potential plans above. For plan 1, the aConstraint[].usable flag for for the SQLITE_CONSTRAINT_EQ constraint on the param1 column will be true because the right-hand side value for the &quot;param1 = ?&quot; constraint will be known, since it is determined by the outer realtab loop. But for plan 2, the aConstraint[].usable flag for &quot;param1 = ?&quot; will be false because the right-hand side value is determined by an inner loop and is thus an unknown quantity. Because param1 is a required input to the table-valued functions, the xBestIndex method should return SQLITE_CONSTRAINT when presented with plan 2, indicating that a required input is missing. This forces the query planner to select plan 1.</source>
          <target state="translated">xBestIndex方法将为上述每个潜在计划调用一次。对于计划1,对于param1列上的SQLITE_CONSTRAINT_EQ约束的aConstraint[].usable标志将为真,因为 &quot;param1=? &quot;约束的右侧值将是已知的,因为它是由外部realtab循环决定的。但是对于计划2,&quot;param1=?&quot;的aConstraint[].usable标志将为false,因为右侧的值是由内部循环决定的,因此是一个未知量。因为param1是表值函数的必要输入,所以当呈现计划2时,xBestIndex方法应该返回SQLITE_CONSTRAINT,表示缺少一个必要的输入。这就迫使查询规划器选择计划1。</target>
        </trans-unit>
        <trans-unit id="c5e6a28d9d92d2bf9deb3f28a367d165a9d141f6" translate="yes" xml:space="preserve">
          <source>The xCachesize() method may be called at any time by SQLite to set the suggested maximum cache-size (number of pages stored by) the cache instance passed as the first argument. This is the value configured using the SQLite &quot;&lt;a href=&quot;../pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt;&quot; command. As with the bPurgeable parameter, the implementation is not required to do anything with this value; it is advisory only.</source>
          <target state="translated">SQLite可以随时调用xCachesize（）方法来设置建议的最大缓存大小（作为第一个参数传递的缓存实例）的最大缓存大小（存储的页面数）。这是使用SQLite&amp;ldquo; &lt;a href=&quot;../pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt; &amp;rdquo;命令配置的值。与bPurgeable参数一样，实现不需要使用此值做任何事情；它仅是建议性的。</target>
        </trans-unit>
        <trans-unit id="64860c154593114b929547aef1bfe359a445dd93" translate="yes" xml:space="preserve">
          <source>The xCachesize() method may be called at any time by SQLite to set the suggested maximum cache-size (number of pages stored by) the cache instance passed as the first argument. This is the value configured using the SQLite &quot;&lt;a href=&quot;pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt;&quot; command. As with the bPurgeable parameter, the implementation is not required to do anything with this value; it is advisory only.</source>
          <target state="translated">SQLite可以随时调用xCachesize（）方法来设置建议的最大缓存大小（作为第一个参数传递的缓存实例）的最大缓存大小（存储的页面数）。这是使用SQLite&amp;ldquo; &lt;a href=&quot;pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt; &amp;rdquo;命令配置的值。与bPurgeable参数一样，实现不需要使用此值做任何事情；它仅是建议性的。</target>
        </trans-unit>
        <trans-unit id="76bfcc9d387b84934d7209d1ccf2568a52cae2ff" translate="yes" xml:space="preserve">
          <source>The xCheckReservedLock() method checks to see if another connection or another process is currently holding a reserved, pending, or exclusive lock on the file. It returns true or false.</source>
          <target state="translated">xCheckReservedLock()方法检查另一个连接或另一个进程当前是否在文件上持有保留、待定或独占的锁。它返回true或false。</target>
        </trans-unit>
        <trans-unit id="5108534fb3c98c994a35c533b42cb72d472a86d4" translate="yes" xml:space="preserve">
          <source>The xClose method closes a cursor previously opened by &lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt;. The SQLite core will always call xClose once for each cursor opened using xOpen.</source>
          <target state="translated">xClose方法关闭以前由&lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt;打开的游标。对于使用xOpen打开的每个游标，SQLite核心将始终调用一次xClose。</target>
        </trans-unit>
        <trans-unit id="a1fcaec496244ffb2502893506be9bff99222ddb" translate="yes" xml:space="preserve">
          <source>The xClose method closes the file. The space for the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; structure is deallocated by the caller. But if the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; contains pointers to other allocated memory or resources, those allocations should be released by the xClose method.</source>
          <target state="translated">xClose方法关闭文件。&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;结构的空间由调用方释放。但是，如果&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;包含指向其他已分配内存或资源的指针，则应通过xClose方法释放这些分配。</target>
        </trans-unit>
        <trans-unit id="2af5d67c2c34fed358127148fe670412a17ae024" translate="yes" xml:space="preserve">
          <source>The xClose method is required for every virtual table implementation.</source>
          <target state="translated">每个虚拟表的实现都需要xClose方法。</target>
        </trans-unit>
        <trans-unit id="57537332c9edcb104197db5e7bb9793f5df28547" translate="yes" xml:space="preserve">
          <source>The xColumn method is required for every virtual table implementation.</source>
          <target state="translated">每个虚拟表的实现都需要xColumn方法。</target>
        </trans-unit>
        <trans-unit id="ef93eeb561a6057de6700b4a7eda4c4170148438" translate="yes" xml:space="preserve">
          <source>The xColumnSize API always returns -1. There is no way to determine the number of tokens in a value stored within a contentless FTS5 table configured with columnsize=0.</source>
          <target state="translated">xColumnSize API总是返回-1。无法确定配置为 columnsize=0 的无内容 FTS5 表内存储的值中的令牌数。</target>
        </trans-unit>
        <trans-unit id="9e2d00478c87bed4be4b97709f42f53211a90ec1" translate="yes" xml:space="preserve">
          <source>The xConnect method is required for every virtual table implementation, though the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and xConnect pointers of the &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; object may point to the same function if the virtual table does not need to initialize backing store.</source>
          <target state="translated">尽管虚拟表不需要初始化后备存储，但&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt;对象的&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;和xConnect指针可能指向同一函数，但每个虚拟表实现都需要使用xConnect方法。</target>
        </trans-unit>
        <trans-unit id="3a84b2667247b1e27fdcdd3d4cc56221f573c090" translate="yes" xml:space="preserve">
          <source>The xConnect method is very similar to &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;. It has the same parameters and constructs a new &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure just like xCreate. And it must also call &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; like xCreate.</source>
          <target state="translated">xConnect方法与&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;非常相似。它具有相同的参数，并像xCreate一样构造一个新的&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;结构。并且它还必须像xCreate一样调用&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ec50befd1d20d9f6756f231c4255cc685afba32" translate="yes" xml:space="preserve">
          <source>The xConnect method must return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if it is successful in creating the new virtual table, or &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if it is not successful. If not successful, the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure must not be allocated. An error message may optionally be returned in *pzErr if unsuccessful. Space to hold the error message string must be allocated using an SQLite memory allocation function like &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; as the SQLite core will attempt to free the space using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; after the error has been reported up to the application.</source>
          <target state="translated">该xConnect方法必须返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;如果成功创建新的虚拟表，或&lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;如果它不成功。如果未成功，则不得分配&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;结构。如果失败，则可以选择在* pzErr中返回错误消息。必须使用SQLite内存分配函数（例如&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;或&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（））&lt;/a&gt;分配用于保存错误消息字符串的空间，因为在将错误报告给应用程序之后，SQLite核心将尝试使用&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放空间。</target>
        </trans-unit>
        <trans-unit id="6920f3a6545664c297cabaad1f1d797cb28640a2" translate="yes" xml:space="preserve">
          <source>The xCreate and xConnect methods are only different when the virtual table has some kind of backing store that must be initialized the first time the virtual table is created. The xCreate method creates and initializes the backing store. The xConnect method just connects to an existing backing store. When xCreate and xConnect are the same, the table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;.</source>
          <target state="translated">仅当虚拟表具有某种必须在首次创建虚拟表时初始化的后备存储时，xCreate和xConnect方法才不同。 xCreate方法创建并初始化后备存储。 xConnect方法仅连接到现有的后备存储。当xCreate和xConnect相同时，该表是&lt;a href=&quot;vtab#epovtab&quot;&gt;同义的虚拟表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dcf39a347f064ec02d2e007cec689340fd805ffc" translate="yes" xml:space="preserve">
          <source>The xCreate method is called to create a new instance of a virtual table in response to a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. If the xCreate method is the same pointer as the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method, then the virtual table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;. If the xCreate method is omitted (if it is a NULL pointer) then the virtual table is an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt;.</source>
          <target state="translated">调用xCreate方法以创建虚拟表的新实例，以响应&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;语句。如果xCreate方法是相同的指针作为&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;方法，则虚拟表是一个&lt;a href=&quot;vtab#epovtab&quot;&gt;同名虚拟表&lt;/a&gt;。如果省略xCreate方法（如果它是NULL指针），则虚拟表是&lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;仅&lt;/a&gt;具有别名的虚拟表。</target>
        </trans-unit>
        <trans-unit id="7fa820ae673d5a152c6735ecfbe5a6902d1afc09" translate="yes" xml:space="preserve">
          <source>The xCreate method need not initialize the pModule, nRef, and zErrMsg fields of the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object. The SQLite core will take care of that chore.</source>
          <target state="translated">xCreate方法不需要初始化&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;对象的pModule，nRef和zErrMsg字段。SQLite核心将负责这项工作。</target>
        </trans-unit>
        <trans-unit id="06c7e419a8719bf400eb11e6ddbab813f843fcfc" translate="yes" xml:space="preserve">
          <source>The xCreate should return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if it is successful in creating the new virtual table, or &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if it is not successful. If not successful, the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure must not be allocated. An error message may optionally be returned in *pzErr if unsuccessful. Space to hold the error message string must be allocated using an SQLite memory allocation function like &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; as the SQLite core will attempt to free the space using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; after the error has been reported up to the application.</source>
          <target state="translated">该xCreate应该返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;如果成功创建新的虚拟表，或&lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;如果它不成功。如果未成功，则不得分配&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;结构。如果失败，则可以选择在* pzErr中返回错误消息。必须使用SQLite内存分配函数（例如&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;或&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（））&lt;/a&gt;分配用于保存错误消息字符串的空间，因为在将错误报告给应用程序之后，SQLite核心将尝试使用&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放空间。</target>
        </trans-unit>
        <trans-unit id="f958ace0be88d27965e6fd7b0b417f1f44eb7a29" translate="yes" xml:space="preserve">
          <source>The xCurrentTime method finds the current time and date and writes the result as a double-precision floating point value into pointer provided by the second parameter. The time and date is in coordinated universal time (UTC) and is a fractional Julian day number.</source>
          <target state="translated">xCurrentTime方法找到当前时间和日期,并将结果作为一个双精度浮点值写入第二个参数提供的指针中。时间和日期是以协调的世界时(UTC)为单位,是一个小数的朱利安日数。</target>
        </trans-unit>
        <trans-unit id="6df2a95b2c02a08ca9301c1af593f076dcec3de1" translate="yes" xml:space="preserve">
          <source>The xDelete callback, if one is specified, is also invoked on the auxiliary data pointer after the FTS5 query has finished.</source>
          <target state="translated">如果指定了xDelete回调,在FTS5查询结束后,也会对辅助数据指针进行调用。</target>
        </trans-unit>
        <trans-unit id="684db9583b8006f9c3587ed123a3291e36233a15" translate="yes" xml:space="preserve">
          <source>The xDelete method in the built-in &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; now return SQLITE_IOERR_DELETE_NOENT if the file to be deleted does not exist.</source>
          <target state="translated">在内置的xDelete方法&lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;现在回到SQLITE_IOERR_DELETE_NOENT如果要删除的文件不存在。</target>
        </trans-unit>
        <trans-unit id="8acbdfc184b8627360b75ab194ff6c7691155e56" translate="yes" xml:space="preserve">
          <source>The xDelete method is used to delete a file. The name of the file is given in the second parameter. The filename will be in UTF-8. The VFS must convert the filename into whatever character representation the underlying operating system expects. If the syncDir parameter is true, then the xDelete method should not return until the change to the directory contents for the directory containing the deleted file have been synced to disk in order to ensure that the file does not &quot;reappear&quot; if a power failure occurs soon after.</source>
          <target state="translated">xDelete方法用于删除一个文件。文件的名称在第二个参数中给出。文件名将是UTF-8格式。VFS必须将文件名转换成底层操作系统期望的任何字符表示。如果syncDir参数为真,那么xDelete方法不应该返回,直到包含被删除文件的目录内容的变化已经同步到磁盘上,以确保文件不会在断电后不久就 &quot;重新出现&quot;。</target>
        </trans-unit>
        <trans-unit id="11b2a4e02961f3a81754bcacd1c2618edac811a1" translate="yes" xml:space="preserve">
          <source>The xDestroy callback is &lt;u&gt;not&lt;/u&gt; called if the sqlite3_create_collation_v2() function fails. Applications that invoke sqlite3_create_collation_v2() with a non-NULL xDestroy argument should check the return code and dispose of the application data pointer themselves rather than expecting SQLite to deal with it for them. This is different from every other SQLite interface. The inconsistency is unfortunate but cannot be changed without breaking backwards compatibility.</source>
          <target state="translated">如果sqlite3_create_collat​​ion_v2（）函数失败，则&lt;u&gt;不会&lt;/u&gt;调用xDestroy回调。调用带有非NULL xDestroy参数的sqlite3_create_collat​​ion_v2（）的应用程序应检查返回代码并自行处理应用程序数据指针，而不是期望SQLite为它们处理。这不同于其他所有SQLite接口。不一致是不幸的，但是在不破坏向后兼容性的情况下就无法更改。</target>
        </trans-unit>
        <trans-unit id="82fcb2416a6d15ad9c7eed2868bb3c1083659be9" translate="yes" xml:space="preserve">
          <source>The xDestroy method is required for every virtual table implementation, though it is acceptable for the &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; and xDestroy methods to be the same function if that makes sense for the particular virtual table.</source>
          <target state="translated">尽管对于特定的虚拟表有意义，但&lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt;和xDestroy方法可以使用相同的功能，但每个虚拟表实现都需要使用xDestroy方法。</target>
        </trans-unit>
        <trans-unit id="433eafbb64ee6df6fcf2cd0863165758dd2318f2" translate="yes" xml:space="preserve">
          <source>The xDestroy() method is used to delete a cache allocated by xCreate(). All resources associated with the specified cache should be freed. After calling the xDestroy() method, SQLite considers the &lt;a href=&quot;#sqlite3_pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache*&lt;/a&gt; handle invalid, and will not use it with any other sqlite3_pcache_methods2 functions.</source>
          <target state="translated">xDestroy（）方法用于删除xCreate（）分配的缓存。与指定的缓存关联的所有资源都应释放。调用xDestroy（）方法后，SQLite认为&lt;a href=&quot;#sqlite3_pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache *&lt;/a&gt;句柄无效，并且不会与任何其他sqlite3_pcache_methods2函数一起使用。</target>
        </trans-unit>
        <trans-unit id="8baf35611bcad0c5db55f35fee163e2aa0c149e9" translate="yes" xml:space="preserve">
          <source>The xDestroy() method is used to delete a cache allocated by xCreate(). All resources associated with the specified cache should be freed. After calling the xDestroy() method, SQLite considers the &lt;a href=&quot;pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache*&lt;/a&gt; handle invalid, and will not use it with any other sqlite3_pcache_methods2 functions.</source>
          <target state="translated">xDestroy（）方法用于删除xCreate（）分配的缓存。与指定的缓存关联的所有资源都应释放。调用xDestroy（）方法后，SQLite认为&lt;a href=&quot;pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache *&lt;/a&gt;句柄无效，并且不会与任何其他sqlite3_pcache_methods2函数一起使用。</target>
        </trans-unit>
        <trans-unit id="604385447aab898766cb3896d8016d04ab97fc0d" translate="yes" xml:space="preserve">
          <source>The xDeviceCharacteristics method of the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object returns an integer which is a vector of these bit values expressing I/O characteristics of the mass storage device that holds the file that the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; refers to.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象的xDeviceCharacteristics方法返回一个整数，该整数是这些位值的向量，这些值表示保存&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods所&lt;/a&gt;引用文件的大容量存储设备的I / O特性。</target>
        </trans-unit>
        <trans-unit id="b98ec973b9735d7dd446dd0f56fe3b7eb0a27d7c" translate="yes" xml:space="preserve">
          <source>The xDeviceCharacteristics method of the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object returns an integer which is a vector of these bit values expressing I/O characteristics of the mass storage device that holds the file that the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; refers to.</source>
          <target state="translated">&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象的xDeviceCharacteristics方法返回一个整数，该整数是这些位值的向量，这些值表示保存&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods所&lt;/a&gt;引用文件的大容量存储设备的I / O特性。</target>
        </trans-unit>
        <trans-unit id="c2e8466b1e208836960d6bb4f90ed3ea7832fd67" translate="yes" xml:space="preserve">
          <source>The xDeviceCharacteristics method returns an integer bit vector that defines any special properties that the underlying storage medium might have that SQLite can use to increase performance. The allowed return is the bit-wise OR of the following values:</source>
          <target state="translated">xDeviceCharacteristics方法返回一个整数位向量,它定义了底层存储介质可能具有的、SQLite可以用来提高性能的任何特殊属性。允许的返回值是以下值的位宽OR。</target>
        </trans-unit>
        <trans-unit id="1262b3501d52f25dbe2da92b37772cb17c293d40" translate="yes" xml:space="preserve">
          <source>The xDisconnect method is required for every virtual table implementation, though it is acceptable for the xDisconnect and &lt;a href=&quot;vtab#sqlite3_module.xDestroy&quot;&gt;xDestroy&lt;/a&gt; methods to be the same function if that makes sense for the particular virtual table.</source>
          <target state="translated">尽管对于特定的虚拟表有意义，但xDisconnect和&lt;a href=&quot;vtab#sqlite3_module.xDestroy&quot;&gt;xDestroy&lt;/a&gt;方法可以使用相同的功能，但每个虚拟表实现都需要使用xDisconnect方法。</target>
        </trans-unit>
        <trans-unit id="80202d349ad4d59a55548ad8afd689feeefba61b" translate="yes" xml:space="preserve">
          <source>The xDlOpen, xDlError, xDlSym, and xDlClose methods are all used for accessing shared libraries at run-time. These methods may be omitted (and their pointers set to zero) if the library is compiled with &lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt; or if the &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface is never used to enable dynamic extension loading. The xDlOpen method opens a shared library or DLL and returns a pointer to a handle. NULL is returned if the open fails. If the open fails, the xDlError method can be used to obtain a text error message. The message is written into the zErrMsg buffer of the third parameter which is at least nByte bytes in length. The xDlSym returns a pointer to a symbol in the shared library. The name of the symbol is given by the second parameter. UTF-8 encoding is assumed. If the symbol is not found a NULL pointer is returned. The xDlClose routine closes the shared library.</source>
          <target state="translated">xDlOpen，xDlError，xDlSym和xDlClose方法都用于在运行时访问共享库。如果使用&lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt;编译库，或者如果&lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension（），&lt;/a&gt;则可以忽略这些方法（它们的指针设置为零）。接口从不用于启用动态扩展加载。 xDlOpen方法将打开共享库或DLL，并返回指向句柄的指针。如果打开失败，则返回NULL。如果打开失败，则可以使用xDlError方法获取文本错误消息。该消息将写入第三个参数的zErrMsg缓冲区，该缓冲区的长度至少为nByte个字节。 xDlSym返回一个指向共享库中符号的指针。符号的名称由第二个参数给出。假设采用UTF-8编码。如果找不到该符号，则返回NULL指针。 xDlClose例程关闭共享库。</target>
        </trans-unit>
        <trans-unit id="2a328c23f376e27049c3463e790fd30ea24be07c" translate="yes" xml:space="preserve">
          <source>The xEof method is required for every virtual table implementation.</source>
          <target state="translated">每个虚拟表的实现都需要xEof方法。</target>
        </trans-unit>
        <trans-unit id="2f524de9f6418ba3f20971cbbb6e678439f267fb" translate="yes" xml:space="preserve">
          <source>The xEof method must return false (zero) if the specified cursor currently points to a valid row of data, or true (non-zero) otherwise. This method is called by the SQL engine immediately after each &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; and &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; invocation.</source>
          <target state="translated">如果指定的游标当前指向有效的数据行，则xEof方法必须返回false（零），否则返回true（非零）。每次&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;和&lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt;调用之后，SQL引擎都会立即调用此方法。</target>
        </trans-unit>
        <trans-unit id="31055a962a7bb13c9dfa534ee5cb14dc7402ab08" translate="yes" xml:space="preserve">
          <source>The xFetch() method locates a page in the cache and returns a pointer to an sqlite3_pcache_page object associated with that page, or a NULL pointer. The pBuf element of the returned sqlite3_pcache_page object will be a pointer to a buffer of szPage bytes used to store the content of a single database page. The pExtra element of sqlite3_pcache_page will be a pointer to the szExtra bytes of extra storage that SQLite has requested for each entry in the page cache.</source>
          <target state="translated">xFetch()方法在缓存中定位一个页面,并返回一个指向与该页面相关联的 sqlite3_pcache_page 对象的指针,或者一个 NULL 指针。返回的 sqlite3_pcache_page 对象的 pBuf 元素将是一个指向 szPage 字节的缓冲区的指针,用于存储单个数据库页面的内容。sqlite3_pcache_page的pExtra元素将是一个指针,指向SQLite为页面缓存中的每个条目请求的额外存储的szExtra字节。</target>
        </trans-unit>
        <trans-unit id="eec30896c07568e6756a1fd11de9a9be38006b51" translate="yes" xml:space="preserve">
          <source>The xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the (new and experimental) &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface. The second &quot;op&quot; argument is an integer opcode. The third argument is a generic pointer which is intended to be a pointer to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves opcodes less than 100 for its own use. A &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot;&gt;list of opcodes&lt;/a&gt; less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts.</source>
          <target state="translated">xFileControl（）方法是一个通用接口，允许自定义VFS实现使用（新的和实验性的）&lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;接口直接控制打开的文件。第二个&amp;ldquo; op&amp;rdquo;参数是整数操作码。第三个参数是通用指针，旨在用作指向结构的指针，该结构可能包含要在其中写入返回值的参数或空间。 xFileControl（）的潜在用途可能是启用超时锁定功能，更改锁定策略（例如，使用点文件锁定），查询锁定状态或破坏陈旧锁定的功能。 SQLite核心保留少于100的操作码供自己使用。一个&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot;&gt;操作码的列表&lt;/a&gt;少于100个可用。定义自定义xFileControl方法的应用程序应使用大于100的操作码以避免冲突。</target>
        </trans-unit>
        <trans-unit id="dddf7acfafd6d3f8269f8f981d3bcbe57970b96a" translate="yes" xml:space="preserve">
          <source>The xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface. The second &quot;op&quot; argument is an integer opcode. The third argument is a generic pointer intended to point to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves all opcodes less than 100 for its own use. A &lt;a href=&quot;#SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&quot;&gt;list of opcodes&lt;/a&gt; less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts. VFS implementations should return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; for file control opcodes that they do not recognize.</source>
          <target state="translated">xFileControl（）方法是一个通用接口，允许自定义VFS实现使用&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;接口直接控制打开的文件。第二个&amp;ldquo; op&amp;rdquo;参数是整数操作码。第三个参数是通用指针，旨在指向一个结构，该结构可能包含在其中写入返回值的参数或空间。xFileControl（）的潜在用途可能是启用超时锁定功能，更改锁定策略（例如，使用点文件锁定），查询锁定状态或破坏陈旧锁定的功能。SQLite核心保留所有少于100个操作码供自己使用。一个&lt;a href=&quot;#SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&quot;&gt;操作码的列表&lt;/a&gt;少于100个可用。定义自定义xFileControl方法的应用程序应使用大于100的操作码以避免冲突。 VFS实现应为无法识别的文件控制操作码返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0cff0bc514819c033ff2d05910e11b13ceab5fce" translate="yes" xml:space="preserve">
          <source>The xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface. The second &quot;op&quot; argument is an integer opcode. The third argument is a generic pointer intended to point to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves all opcodes less than 100 for its own use. A &lt;a href=&quot;c_fcntl_begin_atomic_write&quot;&gt;list of opcodes&lt;/a&gt; less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts. VFS implementations should return &lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; for file control opcodes that they do not recognize.</source>
          <target state="translated">xFileControl（）方法是一个通用接口，允许自定义VFS实现使用&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;接口直接控制打开的文件。第二个&amp;ldquo; op&amp;rdquo;参数是整数操作码。第三个参数是通用指针，旨在指向一个结构，该结构可能包含在其中写入返回值的参数或空间。xFileControl（）的潜在用途可能是启用超时锁定功能，更改锁定策略（例如，使用点文件锁定），查询锁定状态或破坏陈旧锁定的功能。SQLite核心保留所有少于100个操作码供自己使用。一个&lt;a href=&quot;c_fcntl_begin_atomic_write&quot;&gt;操作码的列表&lt;/a&gt;少于100个可用。定义自定义xFileControl方法的应用程序应使用大于100的操作码以避免冲突。 VFS实现应为无法识别的文件控制操作码返回&lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3203c926180842d31c782d904c037633ddf2f91f" translate="yes" xml:space="preserve">
          <source>The xFileSize() method determines the current size of the file in bytes and writes that value into *pSize. It returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_fstat&quot;&gt;SQLITE_IOERR_FSTAT&lt;/a&gt; if something goes wrong.</source>
          <target state="translated">xFileSize（）方法确定文件的当前大小（以字节为单位），并将该值写入* pSize。它返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;成功和&lt;a href=&quot;rescode#ioerr_fstat&quot;&gt;SQLITE_IOERR_FSTAT&lt;/a&gt;如果出现错误。</target>
        </trans-unit>
        <trans-unit id="96653ab4bb654a8e871b1a8c14aa48716aadb8ae" translate="yes" xml:space="preserve">
          <source>The xFilter method is required for every virtual table implementation.</source>
          <target state="translated">每个虚拟表的实现都需要xFilter方法。</target>
        </trans-unit>
        <trans-unit id="4479f4bd625e3440b28fa60e755d9671817cfbcf" translate="yes" xml:space="preserve">
          <source>The xFullPathname method is used to convert a relative pathname into a full pathname. The resulting full pathname is written into the buffer provided by the third parameter. SQLite will size the output buffer to at least mxPathname bytes. Both the input and output names should be in UTF-8.</source>
          <target state="translated">xFullPathname方法用于将相对路径名转换为完整路径名。产生的完整路径名被写入第三个参数提供的缓冲区。SQLite将把输出缓冲区的大小至少定为mxPathname字节。输入和输出名称都应该是UTF-8格式。</target>
        </trans-unit>
        <trans-unit id="5dbd41bd881211c13a1dbbcb8c736851e1bf5d97" translate="yes" xml:space="preserve">
          <source>The xGeom callback always does a depth-first search of the r-tree.</source>
          <target state="translated">xGeom回调总是对r树进行深度优先搜索。</target>
        </trans-unit>
        <trans-unit id="454e11b15802805175a3b539debe13d361beb72d" translate="yes" xml:space="preserve">
          <source>The xGetTempName method computes the name of a temporary file that SQLite can use. The name should be written into the buffer given by the second parameter. SQLite will size that buffer to hold at least mxPathname bytes. The generated filename should be in UTF-8. To avoid security problems, the generated temporary filename should contain enough randomness to prevent an attacker from guessing the temporary filename in advance.</source>
          <target state="translated">xGetTempName方法计算SQLite可以使用的临时文件的名称。该名称应该被写入第二个参数给出的缓冲区中。SQLite将把该缓冲区的大小确定为至少能容纳mxPathname字节。生成的文件名应该是UTF-8格式的。为了避免安全问题,生成的临时文件名应该包含足够的随机性,以防止攻击者提前猜测临时文件名。</target>
        </trans-unit>
        <trans-unit id="5d25f32f0f944f020730e420a59b761837d6fa20" translate="yes" xml:space="preserve">
          <source>The xGetTempname method has been removed from &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;. In its place, the xOpen method is enhanced to open a temporary file of its own invention when the filename parameter is NULL.</source>
          <target state="translated">xGetTempname方法已从&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs中&lt;/a&gt;删除。当文件名参数为NULL时，增强了xOpen方法以打开自己的发明的临时文件。</target>
        </trans-unit>
        <trans-unit id="e9de98bc73bd358a33146535bc6a4c0838edf0ac" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any require mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="translated">xInit方法初始化内存分配器。例如，它可能分配任何必需的互斥对象或初始化内部数据结构。 xShutdown方法由&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;调用（间接），并且应取消分配xInit获取的所有资源。 pAppData指针用作xInit和xShutdown的唯一参数。</target>
        </trans-unit>
        <trans-unit id="3fa9fa67f04b6378191cf480be2d31d4ea4b3e4c" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any require mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="translated">xInit方法初始化内存分配器。例如，它可能分配任何必需的互斥对象或初始化内部数据结构。 xShutdown方法由&lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;调用（间接），并且应取消分配xInit获取的所有资源。 pAppData指针用作xInit和xShutdown的唯一参数。</target>
        </trans-unit>
        <trans-unit id="b5977e9a51901888e399d44616a096c8dd4ad36a" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any required mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b210b9a34cdea6b00c84f118c3818052de5137" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any required mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="928f04710edbd4aadd8a60154ed8a2e307eed0ef" translate="yes" xml:space="preserve">
          <source>The xInit() method is called once for each effective call to &lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize()&lt;/a&gt; (usually only once during the lifetime of the process). The xInit() method is passed a copy of the sqlite3_pcache_methods2.pArg value. The intent of the xInit() method is to set up global data structures required by the custom page cache implementation. If the xInit() method is NULL, then the built-in default page cache is used instead of the application defined page cache.</source>
          <target state="translated">每次对&lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize（）的&lt;/a&gt;有效调用都会调用一次xInit（）方法（通常在该过程的生命周期内仅调用一次）。向xInit（）方法传递了sqlite3_pcache_methods2.pArg值的副本。 xInit（）方法的目的是设置自定义页面缓存实现所需的全局数据结构。如果xInit（）方法为NULL，则使用内置的默认页面缓存而不是应用程序定义的页面缓存。</target>
        </trans-unit>
        <trans-unit id="6ba32c8d759124102ccc057ecbe6a0c1c85fb3b5" translate="yes" xml:space="preserve">
          <source>The xInit() method is called once for each effective call to &lt;a href=&quot;initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize()&lt;/a&gt; (usually only once during the lifetime of the process). The xInit() method is passed a copy of the sqlite3_pcache_methods2.pArg value. The intent of the xInit() method is to set up global data structures required by the custom page cache implementation. If the xInit() method is NULL, then the built-in default page cache is used instead of the application defined page cache.</source>
          <target state="translated">每次对&lt;a href=&quot;initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize（）的&lt;/a&gt;有效调用都会调用一次xInit（）方法（通常在该过程的生命周期内仅调用一次）。向xInit（）方法传递了sqlite3_pcache_methods2.pArg值的副本。 xInit（）方法的目的是设置自定义页面缓存实现所需的全局数据结构。如果xInit（）方法为NULL，则使用内置的默认页面缓存而不是应用程序定义的页面缓存。</target>
        </trans-unit>
        <trans-unit id="8a32ff6fcc7d9e120e222fe6ef8bbf8b9661df8a" translate="yes" xml:space="preserve">
          <source>The xLock and xUnlock methods are used to set and clear file locks. SQLite supports five levels of file locks, in order:</source>
          <target state="translated">xLock和xUnlock方法用于设置和清除文件锁。SQLite支持五级文件锁,依次为:1:</target>
        </trans-unit>
        <trans-unit id="8a5c74b276f4ba001214e303873304b1cefc6f0e" translate="yes" xml:space="preserve">
          <source>The xMalloc, xRealloc, and xFree methods must work like the malloc(), realloc() and free() functions from the standard C library. SQLite guarantees that the second argument to xRealloc is always a value returned by a prior call to xRoundup.</source>
          <target state="translated">xMalloc、xRealloc和xFree方法必须像标准C库中的malloc()、realloc()和free()函数一样工作。SQLite保证xRealloc的第二个参数始终是之前调用xRoundup返回的值。</target>
        </trans-unit>
        <trans-unit id="f3c67d901eafc4b8170f137f64b1ed5325131c31" translate="yes" xml:space="preserve">
          <source>The xMutexEnd method defined by this structure is invoked as part of system shutdown by the sqlite3_shutdown() function. The implementation of this method is expected to release all outstanding resources obtained by the mutex methods implementation, especially those obtained by the xMutexInit method. The xMutexEnd() interface is invoked exactly once for each call to &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_shutdown（）函数在系统关闭过程中调用此结构定义的xMutexEnd方法。预期此方法的实现将释放通过互斥方法实现而获得的所有出色资源，尤其是通过xMutexInit方法获得的资源。对于&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown（）的&lt;/a&gt;每次调用，xMutexEnd（）接口仅被调用一次。</target>
        </trans-unit>
        <trans-unit id="29460abd69ce976afdb57bd86f856a912e6b2129" translate="yes" xml:space="preserve">
          <source>The xMutexEnd method defined by this structure is invoked as part of system shutdown by the sqlite3_shutdown() function. The implementation of this method is expected to release all outstanding resources obtained by the mutex methods implementation, especially those obtained by the xMutexInit method. The xMutexEnd() interface is invoked exactly once for each call to &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_shutdown（）函数在系统关闭过程中调用此结构定义的xMutexEnd方法。预期此方法的实现将释放通过互斥方法实现而获得的所有出色资源，尤其是通过xMutexInit方法获得的资源。对于&lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown（）的&lt;/a&gt;每次调用，xMutexEnd（）接口仅被调用一次。</target>
        </trans-unit>
        <trans-unit id="cd4f06c8938e3564cfbf224eac3d8cf5b5b06a0d" translate="yes" xml:space="preserve">
          <source>The xMutexInit method defined by this structure is invoked as part of system initialization by the sqlite3_initialize() function. The xMutexInit routine is called by SQLite exactly once for each effective call to &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">由sqlite3_initialize（）函数调用此结构定义的xMutexInit方法作为系统初始化的一部分。对于每次对&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize（）的&lt;/a&gt;有效调用，SQLite均只调用一次xMutexInit例程。</target>
        </trans-unit>
        <trans-unit id="dab4cb79a586f29424445d440e5fffbfe8ba4495" translate="yes" xml:space="preserve">
          <source>The xMutexInit method defined by this structure is invoked as part of system initialization by the sqlite3_initialize() function. The xMutexInit routine is called by SQLite exactly once for each effective call to &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">由sqlite3_initialize（）函数调用此结构定义的xMutexInit方法作为系统初始化的一部分。对于每次对&lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize（）的&lt;/a&gt;有效调用，SQLite均只调用一次xMutexInit例程。</target>
        </trans-unit>
        <trans-unit id="89ac720acef7b2cd1f40cadc5a9b4008a6051773" translate="yes" xml:space="preserve">
          <source>The xMutexInit() method must be threadsafe. It must be harmless to invoke xMutexInit() multiple times within the same process and without intervening calls to xMutexEnd(). Second and subsequent calls to xMutexInit() must be no-ops.</source>
          <target state="translated">xMutexInit()方法必须是线程安全的,在同一进程中多次调用xMutexInit()必须是无害的。在同一进程中多次调用xMutexInit()必须是无害的,并且不需要中间调用xMutexEnd()。对xMutexInit()的第二次和后续调用必须是无操作的。</target>
        </trans-unit>
        <trans-unit id="35cc67c51c972e7defc85a2cd19b646cf64aa418" translate="yes" xml:space="preserve">
          <source>The xNext method advances a &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;virtual table cursor&lt;/a&gt; to the next row of a result set initiated by &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;. If the cursor is already pointing at the last row when this routine is called, then the cursor no longer points to valid data and a subsequent call to the &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; method must return true (non-zero). If the cursor is successfully advanced to another row of content, then subsequent calls to &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; must return false (zero).</source>
          <target state="translated">xNext方法将&lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;虚拟表光标移到&lt;/a&gt;&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;初始化的结果集的下一行。如果在调用此例程时游标已经指向最后一行，则游标不再指向有效数据，并且随后对&lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt;方法的调用必须返回true（非零）。如果光标成功前进到另一行内容，则随后对&lt;a href=&quot;vtab#xeof&quot;&gt;xEof的&lt;/a&gt;调用必须返回false（零）。</target>
        </trans-unit>
        <trans-unit id="c07bbf2e5005e8108d2f1c166d0b989d5b0ef5de" translate="yes" xml:space="preserve">
          <source>The xNext method is required for every virtual table implementation.</source>
          <target state="translated">每个虚拟表的实现都需要xNext方法。</target>
        </trans-unit>
        <trans-unit id="eee0d952c4251db31a384eceabf2a26d2118eb4d" translate="yes" xml:space="preserve">
          <source>The xOpen method creates a new cursor used for accessing (read and/or writing) a virtual table. A successful invocation of this method will allocate the memory for the &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; (or a subclass), initialize the new object, and make *ppCursor point to the new object. The successful call then returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">xOpen方法创建用于访问（读取和/或写入）虚拟表的新游标。成功调用此方法将为&lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt;（或子类）分配内存，初始化新对象，并使* ppCursor指向新对象。成功的调用然后返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00b35252e3240b77ad5fc35ac862013d23c8ea89" translate="yes" xml:space="preserve">
          <source>The xOpen method is required for every virtual table implementation.</source>
          <target state="translated">每个虚拟表的实现都需要xOpen方法。</target>
        </trans-unit>
        <trans-unit id="fe219d8e760e2d5872424a8a4fa6980f7d9bd820" translate="yes" xml:space="preserve">
          <source>The xOpen method need not initialize the pVtab field of the &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; structure. The SQLite core will take care of that chore automatically.</source>
          <target state="translated">xOpen方法不需要初始化&lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt;结构的pVtab字段。SQLite核心将自动处理该琐事。</target>
        </trans-unit>
        <trans-unit id="5883a2e08ea426f3d0e98ebbcc84b207e43eeb5d" translate="yes" xml:space="preserve">
          <source>The xOutput callback is invoked zero or more times to return data to the application. The first parameter passed to each call is a copy of the pOut pointer supplied by the application. The second parameter, pData, points to a buffer nData bytes in size containing the chunk of output data being returned. If the xOutput callback successfully processes the supplied data, it should return SQLITE_OK to indicate success. Otherwise, it should return some other SQLite error code. In this case processing is immediately abandoned and the streaming API function returns a copy of the xOutput error code to the application.</source>
          <target state="translated">xOutput回调被调用零次或多次,以返回数据给应用程序。传递给每次调用的第一个参数是应用程序提供的pOut指针的副本。第二个参数pData指向一个缓冲区nData字节大小的数据,其中包含要返回的输出数据块。如果xOutput回调成功地处理了所提供的数据,它应该返回SQLITE_OK来表示成功。否则,它应该返回一些其他SQLite错误代码。在这种情况下,处理会被立即放弃,并且流式API函数会将xOutput错误代码的副本返回给应用程序。</target>
        </trans-unit>
        <trans-unit id="4fdec734fe0825d4b45223206e7ef21a40dca7d6" translate="yes" xml:space="preserve">
          <source>The xPagecount() method must return the number of pages currently stored in the cache, both pinned and unpinned.</source>
          <target state="translated">xPagecount()方法必须返回当前存储在缓存中的页数,包括钉入和未钉入的页数。</target>
        </trans-unit>
        <trans-unit id="f7670800549df532ce782308a5027526fc2bbf4f" translate="yes" xml:space="preserve">
          <source>The xQueryFunc must set the eWithin field of sqlite3_rtree_query_info to one of the values NOT_WITHIN, PARTLY_WITHIN, or FULLY_WITHIN depending on whether or not the bounding box defined by aCoord[] is completely outside the region, overlaps the region, or is completely inside the region, respectively. In addition, the xQueryFunc must set the rScore field to a non-negative value that indicates the order in which subtrees and entries of the query should be analyzed and returned. Smaller scores are processed first.</source>
          <target state="translated">xQueryFunc必须将sqlite3_rtree_query_info的eWithin字段设置为NOT_WITHIN、PARTLY_WITHIN或FULLY_WITHIN中的一个值,分别取决于aCoord[]定义的边界框是否完全在区域之外、是否与区域重叠或是否完全在区域之内。此外,xQueryFunc必须将rScore字段设置为一个非负值,该值表示应分析和返回查询的子树和条目的顺序。较小的分数会被优先处理。</target>
        </trans-unit>
        <trans-unit id="243e65d787818469363333eb640b0b44f38c6ec4" translate="yes" xml:space="preserve">
          <source>The xRandomness method is used exactly once to initialize the pseudo-random number generator (PRNG) inside of SQLite. Only the xRandomness method on the default VFS is used. The xRandomness methods on other VFSes are never accessed by SQLite. The xRandomness routine requests that nByte bytes of randomness be written into zOut. The routine returns the actual number of bytes of randomness obtained. The quality of the randomness so obtained will determine the quality of the randomness generated by built-in SQLite functions such as random() and randomblob(). SQLite also uses its PRNG to generate temporary file names. On some platforms (ex: Windows) SQLite assumes that temporary file names are unique without actually testing for collisions, so it is important to have good-quality randomness even if the random() and randomblob() functions are never used.</source>
          <target state="translated">xRandomness方法只用于初始化SQLite内部的伪随机数生成器(PRNG)一次。只有默认VFS上的xRandomness方法被使用。其他VFS上的xRandomness方法永远不会被SQLite访问。xRandomness例程请求将nByte字节的随机性写入zOut中。该例程返回获得随机性的实际字节数。这样得到的随机性的质量将决定由内置的SQLite函数如random()和randomblob()生成的随机性的质量。SQLite还使用它的PRNG来生成临时文件名。在某些平台上(例如:Windows),SQLite假定临时文件名是唯一的,而没有实际测试碰撞,因此即使从未使用过random()和randomblob()函数,获得高质量的随机性也很重要。</target>
        </trans-unit>
        <trans-unit id="2203fe5d9da94fc2d593e73757d6951b646a5aac" translate="yes" xml:space="preserve">
          <source>The xRandomness(), xSleep(), xCurrentTime(), and xCurrentTimeInt64() interfaces are not strictly a part of the filesystem, but they are included in the VFS structure for completeness. The xRandomness() function attempts to return nBytes bytes of good-quality randomness into zOut. The return value is the actual number of bytes of randomness obtained. The xSleep() method causes the calling thread to sleep for at least the number of microseconds given. The xCurrentTime() method returns a Julian Day Number for the current date and time as a floating point value. The xCurrentTimeInt64() method returns, as an integer, the Julian Day Number multiplied by 86400000 (the number of milliseconds in a 24-hour day). SQLite will use the xCurrentTimeInt64() method to get the current date and time if that method is available (if iVersion is 2 or greater and the function pointer is not NULL) and will fall back to xCurrentTime() if xCurrentTimeInt64() is unavailable.</source>
          <target state="translated">xRandomness()、xSleep()、xCurrentTime()和xCurrentTimeInt64()接口并不是严格意义上的文件系统的一部分,但为了完整性,它们被包含在VFS结构中。xRandomness()函数试图向zOut返回nBytes字节的优质随机性。返回值是获得随机性的实际字节数。xSleep()方法会使调用线程至少在给定的微秒数内睡眠。xCurrentTime()方法以浮点值的形式返回当前日期和时间的朱利安日数。xCurrentTimeInt64()方法以整数形式返回Julian Day Number乘以86400000(一天24小时中的毫秒数)。如果xCurrentTimeInt64()方法可用,SQLite将使用该方法来获取当前的日期和时间(如果iVersion是2或更大,并且函数指针不是NULL),如果xCurrentTimeInt64()不可用,则将返回到xCurrentTime()。</target>
        </trans-unit>
        <trans-unit id="9578c347ea12c88b2a68bb1b8891cc899dd6f688" translate="yes" xml:space="preserve">
          <source>The xRead method reads iAmt bytes from the file beginning at a byte offset to iOfst. The data read is stored in the pointer of the second parameter. xRead returns the &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success, &lt;a href=&quot;rescode#ioerr_short_read&quot;&gt;SQLITE_IOERR_SHORT_READ&lt;/a&gt; if it was not able to read the full number of bytes because it reached end-of-file, or &lt;a href=&quot;rescode#ioerr_read&quot;&gt;SQLITE_IOERR_READ&lt;/a&gt; for any other error.</source>
          <target state="translated">xRead方法从文件读取到iOfst的字节偏移量开始的iAmt字节。读取的数据存储在第二个参数的指针中。 xRead返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;成功，&lt;a href=&quot;rescode#ioerr_short_read&quot;&gt;SQLITE_IOERR_SHORT_READ&lt;/a&gt;如果它是不能够阅读完整的字节数，因为它达到结束的文件，或者&lt;a href=&quot;rescode#ioerr_read&quot;&gt;SQLITE_IOERR_READ&lt;/a&gt;任何其他错误。</target>
        </trans-unit>
        <trans-unit id="179305437ddf972de11f25d6c031548629b7dbeb" translate="yes" xml:space="preserve">
          <source>The xRekey() method is used to change the key value associated with the page passed as the second argument. If the cache previously contains an entry associated with newKey, it must be discarded. Any prior cache entry associated with newKey is guaranteed not to be pinned.</source>
          <target state="translated">xRekey()方法用于改变与作为第二个参数传递的页面相关联的键值。如果缓存中之前包含了一个与newKey相关联的条目,那么它必须被丢弃。任何之前与newKey相关联的缓存条目保证不会被钉住。</target>
        </trans-unit>
        <trans-unit id="ee97077a16637439ff4f073f89fa74d3ae66efba" translate="yes" xml:space="preserve">
          <source>The xRename method is optional. If omitted, then the virtual table may not be renamed using the ALTER TABLE RENAME command.</source>
          <target state="translated">xRename方法是可选的,如果省略,那么就不能使用ALTER TABLE RENAME命令重命名虚拟表。如果省略,那么就不能使用ALTER TABLE RENAME命令重命名虚拟表。</target>
        </trans-unit>
        <trans-unit id="ac1529fc1db9096e5e7532c56994cf7e11a7e7d4" translate="yes" xml:space="preserve">
          <source>The xRoundup method returns what would be the allocated size of a memory allocation given a particular requested size. Most memory allocators round up memory allocations at least to the next multiple of 8. Some allocators round up to a larger multiple or to a power of 2. Every memory allocation request coming in through &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; first calls xRoundup. If xRoundup returns 0, that causes the corresponding memory allocation to fail.</source>
          <target state="translated">xRoundup方法返回给定特定请求大小的内存分配的分配大小。大多数内存分配器将内存分配至少舍入到8的下一个整数倍。某些内存分配器将舍入到更大的整数倍或2的幂。每个通过&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;传入的内存分配请求都首先调用xRoundup。如果xRoundup返回0，则导致相应的内存分配失败。</target>
        </trans-unit>
        <trans-unit id="5558ee9f292501795b089dc2d3175bf349258bae" translate="yes" xml:space="preserve">
          <source>The xRoundup method returns what would be the allocated size of a memory allocation given a particular requested size. Most memory allocators round up memory allocations at least to the next multiple of 8. Some allocators round up to a larger multiple or to a power of 2. Every memory allocation request coming in through &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; first calls xRoundup. If xRoundup returns 0, that causes the corresponding memory allocation to fail.</source>
          <target state="translated">xRoundup方法返回给定特定请求大小的内存分配的分配大小。大多数内存分配器将内存分配至少舍入到8的下一个整数倍。某些内存分配器将舍入到更大的整数倍或2的幂。每个通过&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;或&lt;a href=&quot;free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;传入的内存分配请求都首先调用xRoundup。如果xRoundup返回0，则导致相应的内存分配失败。</target>
        </trans-unit>
        <trans-unit id="ac776ca96c027496fe8cb024585d72e01e0bde03" translate="yes" xml:space="preserve">
          <source>The xRowid method is required for every virtual table implementation.</source>
          <target state="translated">每个虚拟表的实现都需要xRowid方法。</target>
        </trans-unit>
        <trans-unit id="f91951a49d3cd2a19053a4c5034726651d8bcc0a" translate="yes" xml:space="preserve">
          <source>The xSectorSize returns the &quot;sector size&quot; of the underlying non-volatile media. A &quot;sector&quot; is defined as the smallest unit of storage that can be written without disturbing adjacent storage. On a disk drive the &quot;sector size&quot; has until recently been 512 bytes, though there is a push to increase this value to 4KiB. SQLite needs to know the sector size so that it can write a full sector at a time, and thus avoid corrupting adjacent storage space if a power loss occurs in the middle of a write.</source>
          <target state="translated">xSectorSize 返回底层非易失性介质的 &quot;扇区大小&quot;。一个 &quot;扇区 &quot;被定义为在不干扰相邻存储的情况下可以写入的最小存储单位。在磁盘驱动器上,&quot;扇区大小 &quot;直到最近都是512字节,尽管有一种趋势是将这个值增加到4KiB。SQLite需要知道扇区大小,这样才能一次写入一个完整的扇区,从而避免在写入过程中发生断电时破坏相邻的存储空间。</target>
        </trans-unit>
        <trans-unit id="7905596593f9a3650933e2dff7d4278590e16d18" translate="yes" xml:space="preserve">
          <source>The xSectorSize() method returns the sector size of the device that underlies the file. The sector size is the minimum write that can be performed without disturbing other bytes in the file. The xDeviceCharacteristics() method returns a bit vector describing behaviors of the underlying device:</source>
          <target state="translated">xSectorSize()方法返回文件底层设备的扇区大小。该扇区大小是在不干扰文件中其他字节的情况下可以执行的最小写。xDeviceCharacteristics()方法返回一个描述底层设备行为的位向量。</target>
        </trans-unit>
        <trans-unit id="c28ec934424705226c30dba3dc7fb3bbb1c98c66" translate="yes" xml:space="preserve">
          <source>The xSetSystemCall(), xGetSystemCall(), and xNestSystemCall() interfaces are not used by the SQLite core. These optional interfaces are provided by some VFSes to facilitate testing of the VFS code. By overriding system calls with functions under its control, a test program can simulate faults and error conditions that would otherwise be difficult or impossible to induce. The set of system calls that can be overridden varies from one VFS to another, and from one version of the same VFS to the next. Applications that use these interfaces must be prepared for any or all of these interfaces to be NULL or for their behavior to change from one release to the next. Applications must not attempt to access any of these methods if the iVersion of the VFS is less than 3.</source>
          <target state="translated">xSetSystemCall()、xGetSystemCall()和xNestSystemCall()接口不被SQLite核心使用。这些可选的接口是由一些VFSes提供的,以方便对VFS代码的测试。通过用其控制下的函数覆盖系统调用,测试程序可以模拟出原本难以或无法诱发的故障和错误条件。可以重写的系统调用集因VFS而异,也因同一VFS的不同版本而异。使用这些接口的应用程序必须为这些接口中的任何或所有接口为 NULL 或为它们的行为从一个版本到下一个版本的变化做好准备。如果VFS的iVersion小于3,应用程序不得尝试访问任何这些方法。</target>
        </trans-unit>
        <trans-unit id="5423cabb179d0301d2f1838406af9e345543b685" translate="yes" xml:space="preserve">
          <source>The xShadowName method exists to allow SQLite to determine whether a certain real table is in fact a shadow table for a virtual table.</source>
          <target state="translated">xShadowName方法的存在是为了让SQLite确定某个实表是否真的是虚拟表的影子表。</target>
        </trans-unit>
        <trans-unit id="947c2bf35d5cbfd4ce5579dacd8c602d7123b2d2" translate="yes" xml:space="preserve">
          <source>The xShadowName method returns true when its input is the part of the table name past the last &quot;_&quot; character.</source>
          <target state="translated">当它的输入是表名最后一个&quot;_&quot;字符之后的部分时,xShadowName方法返回true。</target>
        </trans-unit>
        <trans-unit id="bb9ed2671c0267a52c772896119a40dfbdf41d3e" translate="yes" xml:space="preserve">
          <source>The xShmLock method can transition between unlocked and SHARED or between unlocked and EXCLUSIVE. It cannot transition between SHARED and EXCLUSIVE.</source>
          <target state="translated">xShmLock方法可以在解锁和SHARED之间或在解锁和EXCLUSIVE之间转换。它不能在SHARED和EXCLUSIVE之间转换。</target>
        </trans-unit>
        <trans-unit id="3b138a7b2ca75c6da01e38d919aae9bc4beaeeca" translate="yes" xml:space="preserve">
          <source>The xShmLock method on &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; may use values between 0 and this upper bound as its &quot;offset&quot; argument. The SQLite core will never attempt to acquire or release a lock outside of this range</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;上的xShmLock方法可以使用0到此上限之间的值作为其&amp;ldquo;偏移&amp;rdquo;参数。SQLite核心绝不会尝试获取或释放超出此范围的锁</target>
        </trans-unit>
        <trans-unit id="99e14d7c5dc9f436dda83c4868de4dcfa29aa8e2" translate="yes" xml:space="preserve">
          <source>The xShmLock method on &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; may use values between 0 and this upper bound as its &quot;offset&quot; argument. The SQLite core will never attempt to acquire or release a lock outside of this range</source>
          <target state="translated">&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;上的xShmLock方法可以使用0到此上限之间的值作为其&amp;ldquo;偏移&amp;rdquo;参数。SQLite核心绝不会尝试获取或释放超出此范围的锁</target>
        </trans-unit>
        <trans-unit id="c9d6171767cbe080777a834fc404f8313c3bd7a0" translate="yes" xml:space="preserve">
          <source>The xShutdown() method is called by &lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. It can be used to clean up any outstanding resources before process shutdown, if required. The xShutdown() method may be NULL.</source>
          <target state="translated">xShutdown（）方法由&lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;调用。如果需要，它可以用来在进程关闭之前清除所有未使用的资源。xShutdown（）方法可以为NULL。</target>
        </trans-unit>
        <trans-unit id="89b517d093efdb5642222dcbac94dd78a355996a" translate="yes" xml:space="preserve">
          <source>The xShutdown() method is called by &lt;a href=&quot;initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. It can be used to clean up any outstanding resources before process shutdown, if required. The xShutdown() method may be NULL.</source>
          <target state="translated">xShutdown（）方法由&lt;a href=&quot;initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;调用。如果需要，它可以用来在进程关闭之前清除所有未使用的资源。xShutdown（）方法可以为NULL。</target>
        </trans-unit>
        <trans-unit id="809b6a168241db65edee19e686edd4e9bd3b2bfa" translate="yes" xml:space="preserve">
          <source>The xSleep method is used to suspend the calling thread for at least the number of microseconds given. This method is used to implement the &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; and &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; APIs. In the case of &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; the xSleep method of the default VFS is always used. If the underlying system does not have a microsecond resolution sleep capability, then the sleep time should be rounded up. xSleep returns this rounded-up value.</source>
          <target state="translated">xSleep方法用于将调用线程挂起至少给定的微秒数。此方法用于实现&lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep（）&lt;/a&gt;和&lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt; API。对于&lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep（）&lt;/a&gt;，始终使用默认VFS的xSleep方法。如果底层系统没有微秒分辨率的睡眠功能，则睡眠时间应四舍五入。xSleep返回此舍入值。</target>
        </trans-unit>
        <trans-unit id="097b3f659c15f2c222834063189d1813c9097500" translate="yes" xml:space="preserve">
          <source>The xSync method is called again, to ensure that the update to the</source>
          <target state="translated">xSync方法再次被调用,以确保更新到了</target>
        </trans-unit>
        <trans-unit id="c43866c10fb70246bff455fcc260272ec7695054" translate="yes" xml:space="preserve">
          <source>The xSync method is used to force previously written data out of operating system cache and into non-volatile memory. The second parameter is usually &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt;. If the second parameter is &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; then the xSync method should make sure that data has also been flushed through the disk controllers cache. The &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; parameter is the equivalent of the F_FULLSYNC ioctl() on Mac OS X. The xSync method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_fsync&quot;&gt;SQLITE_IOERR_FSYNC&lt;/a&gt; if anything goes wrong.</source>
          <target state="translated">xSync方法用于将先前写入的数据从操作系统缓存中强制出并进入非易失性内存。第二个参数通常是&lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt;。如果第二个参数是&lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL，&lt;/a&gt;则xSync方法应确保还通过磁盘控制器高速缓存刷新了数据。该&lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt;参数是相当于在Mac OS X上XSYNC方法返回F_FULLSYNC的ioctl（）的&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;成功和&lt;a href=&quot;rescode#ioerr_fsync&quot;&gt;SQLITE_IOERR_FSYNC&lt;/a&gt;如果有什么差错。</target>
        </trans-unit>
        <trans-unit id="d363e92ec2dbc091f6f79c8b02f677c3bfbb4dc4" translate="yes" xml:space="preserve">
          <source>The xSync method of the file-handle opened on the journal file is called. This operation ensures that all</source>
          <target state="translated">日志文件上打开的文件柄的xSync方法被调用。该操作确保所有的</target>
        </trans-unit>
        <trans-unit id="2abc7e1d2661195eacab3734a083049181c96938" translate="yes" xml:space="preserve">
          <source>The xTruncate method truncates a file to be nByte bytes in length. If the file is already nByte bytes or less in length then this method is a no-op. The xTruncate method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_truncate&quot;&gt;SQLITE_IOERR_TRUNCATE&lt;/a&gt; if anything goes wrong.</source>
          <target state="translated">xTruncate方法将文件截断为nByte字节长。如果文件的长度已经是nByte字节或更小，则此方法为无操作。该xTruncate方法返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;成功和&lt;a href=&quot;rescode#ioerr_truncate&quot;&gt;SQLITE_IOERR_TRUNCATE&lt;/a&gt;如果有什么差错。</target>
        </trans-unit>
        <trans-unit id="264cd9fc05e84b4a4186bdf81ed3b9dddd14f364" translate="yes" xml:space="preserve">
          <source>The xUpdate method is optional. If the xUpdate pointer in the &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; for a virtual table is a NULL pointer, then the virtual table is read-only.</source>
          <target state="translated">xUpdate方法是可选的。如果&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module中&lt;/a&gt;用于虚拟表的xUpdate指针是NULL指针，则该虚拟表是只读的。</target>
        </trans-unit>
        <trans-unit id="e7991b9300a6d5d1e9dd517f980e91bd729b810d" translate="yes" xml:space="preserve">
          <source>The xUpdate method must return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if and only if it is successful. If a failure occurs, the xUpdate must return an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;. On a failure, the pVTab-&amp;gt;zErrMsg element may optionally be replaced with error message text stored in memory allocated from SQLite using functions such as &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; or &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;.</source>
          <target state="translated">仅当成功时，xUpdate方法必须返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。如果发生故障，则xUpdate必须返回适当的&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。如果发生故障，可以使用诸如&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;或&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）之类的&lt;/a&gt;函数将pVTab-&amp;gt; zErrMsg元素替换为从SQLite分配的内存中存储的错误消息文本。</target>
        </trans-unit>
        <trans-unit id="4f4c20f5295bf2671dba3e7fbec564fd71238ee3" translate="yes" xml:space="preserve">
          <source>The xUpdate method will do a DELETE or an INSERT or both. The argv[0] element (which corresponds to memory cell P3) is the rowid of a row to delete. If argv[0] is NULL then no deletion occurs. The argv[1] element is the rowid of the new row. This can be NULL to have the virtual table select the new rowid for itself. The subsequent elements in the array are the values of columns in the new row.</source>
          <target state="translated">xUpdate方法将进行DELETE或INSERT操作,或者同时进行这两种操作。argv[0]元素(对应于内存单元格P3)是要删除的记录的rowid。如果 argv[0]为 NULL,那么就不会进行删除。argv[1]元素是新行的行名。这个元素可以是NULL,让虚拟表为自己选择新的行名。数组中的后续元素是新行中列的值。</target>
        </trans-unit>
        <trans-unit id="dce6593181b88387e0232c4fe3315ea114b78c31" translate="yes" xml:space="preserve">
          <source>The xWrite method writes iAmt bytes of data from the second parameter into the file beginning at an offset of iOfst bytes. If the size of the file is less than iOfst bytes prior to the write, then xWrite should ensure that the file is extended with zeros up to iOfst bytes prior to beginning its write. xWrite continues to extends the file as necessary so that the size of the file is at least iAmt+iOfst bytes at the conclusion of the xWrite call. The xWrite method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success. If the write cannot complete because the underlying storage medium is full, then &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; is returned. &lt;a href=&quot;rescode#ioerr_write&quot;&gt;SQLITE_IOERR_WRITE&lt;/a&gt; should be returned for any other error.</source>
          <target state="translated">xWrite方法将第二个参数的iAmt字节数据从iOfst字节的偏移量开始写入文件中。如果在写入之前文件的大小小于iOfst字节，则xWrite应该确保在开始写入之前，使用零将文件扩展到iOfst字节。 xWrite继续根据需要扩展文件，以便在xWrite调用结束时文件的大小至少为iAmt + iOfst字节。 xWrite方法成功返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。如果由于基础存储介质已满而无法完成写入，则返回&lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;。对于其他任何错误，应返回&lt;a href=&quot;rescode#ioerr_write&quot;&gt;SQLITE_IOERR_WRITE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d58a45ae0f446bdb86db23efea40a4365e8b2411" translate="yes" xml:space="preserve">
          <source>The zFormat string must not be NULL.</source>
          <target state="translated">zFormat字符串不能为NULL。</target>
        </trans-unit>
        <trans-unit id="4f80fc797d2d3e861743d9ee1212caa09c71f3bc" translate="yes" xml:space="preserve">
          <source>The zName field holds the name of the VFS module. The name must be unique across all VFS modules.</source>
          <target state="translated">zName字段保存VFS模块的名称。该名称在所有VFS模块中必须是唯一的。</target>
        </trans-unit>
        <trans-unit id="2e8507d62c194c1ae3ea2e8955ca09d80822bd5b" translate="yes" xml:space="preserve">
          <source>The zName field is the symbolic name of the VFS. This is the name that the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; compares against when it is looking for a VFS.</source>
          <target state="translated">zName字段是VFS的符号名称。这是&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find（）&lt;/a&gt;在查找VFS时要与之比较的名称。</target>
        </trans-unit>
        <trans-unit id="159171a13f5482b6256b050c73e581c3c1ed7fde" translate="yes" xml:space="preserve">
          <source>The zeroblob(N) function returns a BLOB consisting of N bytes of 0x00. SQLite manages these zeroblobs very efficiently. Zeroblobs can be used to reserve space for a BLOB that is later written using &lt;a href=&quot;c3ref/blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt;. This SQL function is implemented using the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_zeroblob()&lt;/a&gt; routine from the C/C++ interface.</source>
          <target state="translated">zeroblob（N）函数返回一个BLOB，该BLOB由N个0x00字节组成。SQLite非常有效地管理这些零点。Zeroblob可用于为BLOB保留空间，该空间随后使用&lt;a href=&quot;c3ref/blob_open&quot;&gt;增量BLOB I / O&lt;/a&gt;写入。此SQL函数是使用C / C ++接口中的&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_zeroblob（）&lt;/a&gt;例程实现的。</target>
        </trans-unit>
        <trans-unit id="211680c2a7f3cd39edd65730ba2dc5798231d4d2" translate="yes" xml:space="preserve">
          <source>The zipfile module provides read/write access to simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_%28file_format%29&quot;&gt;ZIP archives&lt;/a&gt;. The current implementation has the following restrictions:</source>
          <target state="translated">zipfile模块提供对简单&lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_%28file_format%29&quot;&gt;ZIP归档文件的&lt;/a&gt;读/写访问。当前的实现有以下限制：</target>
        </trans-unit>
        <trans-unit id="1b7b70776cb9a79f5d42a047fb481e44592ef0cc" translate="yes" xml:space="preserve">
          <source>The zipfile module provides three similar interfaces for accessing, updating and creating zip file archives:</source>
          <target state="translated">zipfile模块为访问、更新和创建压缩文件档案提供了三个类似的界面。</target>
        </trans-unit>
        <trans-unit id="a3bf102cd7b1098b918321543923b0fbcf9afd25" translate="yes" xml:space="preserve">
          <source>The zipfile module provides two similar interfaces for accessing zip archives. A table-valued function, which provides read-only access to existing archives, and a virtual table interface, which provides both read and write access.</source>
          <target state="translated">zipfile模块提供了两个类似的访问zip存档的接口。一个是表值函数,它提供了对现有档案的只读访问,另一个是虚拟表接口,它提供了读和写两种访问方式。</target>
        </trans-unit>
        <trans-unit id="7f26831f509249abeae6c04bd252c7253425a19e" translate="yes" xml:space="preserve">
          <source>The zipfile() aggregate function may be called with 2, 4 or 5 arguments. If it is called with 5 arguments, then the entry added to the archive is equivalent to inserting the same values into the &quot;name&quot;, &quot;mode&quot;, &quot;mtime&quot;, &quot;data&quot; and &quot;method&quot; columns of a zipfile virtual table.</source>
          <target state="translated">zipfile()聚合函数可以用2、4或5个参数来调用。如果调用5个参数,那么添加到归档中的条目就相当于在zipfile虚拟表中的 &quot;name&quot;、&quot;mode&quot;、&quot;mtime&quot;、&quot;data &quot;和 &quot;method &quot;列中插入相同的值。</target>
        </trans-unit>
        <trans-unit id="fda3c54068d6592ac94595a28e9ae2b5a7631d94" translate="yes" xml:space="preserve">
          <source>Then any query that uses operators =, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, &amp;lt;&amp;gt;, IN, LIKE, or GLOB on column &quot;c&quot; would be usable with the partial index because those comparison operators are only true if &quot;c&quot; is not NULL. So the following query could use the partial index:</source>
          <target state="translated">然后，对列&amp;ldquo; c&amp;rdquo;使用运算符=，&amp;lt;，&amp;gt;，&amp;lt;=，&amp;gt; =，&amp;lt;&amp;gt;，IN，LIKE或GLOB的任何查询都可与部分索引一起使用，因为这些比较运算符仅在&amp;ldquo; c&amp;rdquo;为真时才为true不为NULL。因此，以下查询可以使用部分索引：</target>
        </trans-unit>
        <trans-unit id="d38e46789e87cb85236cff516beec8a98a69642c" translate="yes" xml:space="preserve">
          <source>Then continue to merge the changes in &quot;trunk&quot; with your &quot;private&quot; changes as described in section 3.7.</source>
          <target state="translated">然后继续将 &quot;trunk &quot;中的更改与 &quot;private &quot;中的更改合并,如3.7节所述。</target>
        </trans-unit>
        <trans-unit id="4221ef1a5952683847cd93186bb995482d485923" translate="yes" xml:space="preserve">
          <source>Then creating &lt;a href=&quot;lang_createview&quot;&gt;VIEWs&lt;/a&gt; in that schema that implement the official information schema tables using table-valued PRAGMA functions.</source>
          <target state="translated">然后在该模式中创建&lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt;，以使用表值PRAGMA函数实现正式信息模式表。</target>
        </trans-unit>
        <trans-unit id="24143dcd35d1fb5f0ef327aba489cfb57e18e5f5" translate="yes" xml:space="preserve">
          <source>Then download the new version of the SQLite sources and overwrite the files that are in the checkout.</source>
          <target state="translated">然后下载新版的SQLite源码,覆盖结账中的文件。</target>
        </trans-unit>
        <trans-unit id="350d0a66ff74448747b37fd69238737bb7294306" translate="yes" xml:space="preserve">
          <source>Then either of the two queries below may be executed to find the number of documents in the database that contain the word &quot;linux&quot; (351). Using one desktop PC hardware configuration, the query on the FTS3 table returns in approximately 0.03 seconds, versus 22.5 for querying the ordinary table.</source>
          <target state="translated">然后可以执行下面两个查询中的任何一个查询,以查找数据库中含有 &quot;linux &quot;一词的文档数量(351)。使用一台台式电脑的硬件配置,对FTS3表的查询大约在0.03秒内返回,而对普通表的查询则需要22.5秒。</target>
        </trans-unit>
        <trans-unit id="dec93deaca5432fc2b3655d16d3eb7b184d40788" translate="yes" xml:space="preserve">
          <source>Then for each &quot;id&quot; value returned, suppose the application creates an UPDATE statement like the following and binds the &quot;id&quot; value returned against the &quot;?1&quot; parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b72f2d807bd1572c917e30647dff75353e7ffc89" translate="yes" xml:space="preserve">
          <source>Then let the application maintain a separate pool of larger lookaside memory buffers that it can distribute to &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; as they are created. In the common case, the application will only have a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; and so the lookaside memory pool can consist of a single large buffer.</source>
          <target state="translated">然后，让应用程序维护一个单独的较大后备内存缓冲区池，在创建它们时可以将其分配给&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;。在通常情况下，应用程序将只有一个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;，因此后备内存池可以由单个大缓冲区组成。</target>
        </trans-unit>
        <trans-unit id="e376e98c10da73b25d2ab9a479ff86c1a4e0ab3c" translate="yes" xml:space="preserve">
          <source>Then no rows are returned. SQLite knows that the t1.b column actually holds a 7-character string, and the 7-character string 'abc'||char(0)||'xyz' is not equal to the 3-character string 'abc', and so no rows are returned. But a user might be easily confused by this because the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; output seems to show that the string has only 3 characters. This seems like a bug. But it is how SQLite works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13bc76c23a2d1597cb4fa248a96e4ed2a6339b15" translate="yes" xml:space="preserve">
          <source>Then one of the constraints would be on the &quot;a&quot; column with operator &quot;=&quot; and an expression of &quot;5&quot;. Constraints need not have a literal representation of the WHERE clause. The query optimizer might make transformations to the WHERE clause in order to extract as many constraints as it can. So, for example, if the WHERE clause contained something like this:</source>
          <target state="translated">那么其中一个约束条件将是在 &quot;a &quot;列上,操作符为&quot;=&quot;,表达式为 &quot;5&quot;。约束不需要有WHERE子句的字面表示。查询优化器可能会对WHERE子句进行转换,以便提取尽可能多的约束条件。因此,例如,如果WHERE子句包含这样的内容。</target>
        </trans-unit>
        <trans-unit id="a6d85a4cee37097aa0048aa17c7e903390d7845d" translate="yes" xml:space="preserve">
          <source>Then run &quot;sh speed-check.sh trunk&quot;.</source>
          <target state="translated">然后运行 &quot;sh speed-check.sh trunk&quot;。</target>
        </trans-unit>
        <trans-unit id="5af7ca0994a03bba6845a3d09f85ba03527c6bbf" translate="yes" xml:space="preserve">
          <source>Then that term is rewritten as follows:</source>
          <target state="translated">那么,该术语重写如下:</target>
        </trans-unit>
        <trans-unit id="89cb6c0dfe329a7ee49493775fd34d7651a1097e" translate="yes" xml:space="preserve">
          <source>Then the LIKE operator pays attention to case and the example above would evaluate to false. Note that case insensitivity only applies to latin1 characters - basically the upper and lower case letters of English in the lower 127 byte codes of ASCII. International character sets are case sensitive in SQLite unless an application-defined &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#like&quot;&gt;like() SQL function&lt;/a&gt; are provided that take non-ASCII characters into account. But if an application-defined collating sequence and/or like() SQL function are provided, the LIKE optimization described here will never be taken.</source>
          <target state="translated">然后，LIKE运算符会注意大小写，并且上面的示例将评估为false。请注意，不区分大小写仅适用于latin1字符-基本上是ASCII的低127个字节代码中英文的大小写字母。国际字符集在SQLite中区分大小写，除非提供的应用程序定义的&lt;a href=&quot;datatype3#collation&quot;&gt;整理序列&lt;/a&gt;和&lt;a href=&quot;lang_corefunc#like&quot;&gt;like（）SQL函数&lt;/a&gt;考虑了非ASCII字符。但是，如果提供了应用程序定义的整理序列和/或like（）SQL函数，将永远不会采用此处描述的LIKE优化。</target>
        </trans-unit>
        <trans-unit id="be60a7454a5a8c066c86b3ca9b68995e4f6f1ddf" translate="yes" xml:space="preserve">
          <source>Then the RBU database should contain:</source>
          <target state="translated">那么,区域局的数据库应该包含:</target>
        </trans-unit>
        <trans-unit id="afb35789040d9830a99208d5f4ddcf476245eb59" translate="yes" xml:space="preserve">
          <source>Then the UPDATE might fail with an SQLITE_LOCKED error. The reason is that the initial query has not run to completion. It is remembering its place in the middle of a scan of the R-Tree. So an update to the R-Tree cannot be tolerated as this would disrupt the scan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="996a8ef99f82edf5bb93411418cadd30d4e95347" translate="yes" xml:space="preserve">
          <source>Then the generated SQL will look like the following:</source>
          <target state="translated">那么生成的SQL就会像下面这样。</target>
        </trans-unit>
        <trans-unit id="0e329a491713b53943766e19e0cd3bc2370d4353" translate="yes" xml:space="preserve">
          <source>Then the index is usable by the query because the &quot;b=6&quot; term appears in both the index definition and in the query. Remember: terms in the index should be OR-connected and terms in the query should be AND-connected.</source>
          <target state="translated">那么这个索引是可以被查询使用的,因为 &quot;b=6 &quot;这个术语同时出现在索引定义和查询中。记住:索引中的术语应该是OR连接的,而查询中的术语应该是AND连接的。</target>
        </trans-unit>
        <trans-unit id="2efe4248a37f7b9e147bfa69326ac21ae4833059" translate="yes" xml:space="preserve">
          <source>Then the index might be used if the initial columns of the index (columns a, b, and so forth) appear in WHERE clause terms. The initial columns of the index must be used with the *=* or *IN* or *IS* operators. The right-most column that is used can employ inequalities. For the right-most column of an index that is used, there can be up to two inequalities that must sandwich the allowed values of the column between two extremes.</source>
          <target state="translated">那么,如果索引的初始列(a列、b列等)出现在WHERE子句术语中,就可以使用索引。索引的初始列必须使用*=*或*IN*或*IS*运算符。使用的最右边的列可以采用不等式。对于使用的索引最右边的列,最多可以有两个不等式,这些不等式必须将该列的允许值夹在两个极端之间。</target>
        </trans-unit>
        <trans-unit id="f563dfd5bcb7f2cd99d04f3adadee6fc2e0e90d8" translate="yes" xml:space="preserve">
          <source>Then the index will &lt;u&gt;not&lt;/u&gt; be used because the expression on the CREATE INDEX statement (x+y) is not the same as the expression as it appears in the query (y+x). The two expressions might be mathematically equivalent, but the SQLite query planner insists that they be the same, not merely equivalent. Consider rewriting the query thusly:</source>
          <target state="translated">然后将&lt;u&gt;不&lt;/u&gt;使用索引，因为CREATE INDEX语句（x + y）上的表达式与查询（y + x）中出现的表达式不同。这两个表达式在数学上可能是等效的，但SQLite查询计划程序坚持认为它们是相同的，而不仅仅是等效的。考虑这样重写查询：</target>
        </trans-unit>
        <trans-unit id="faa0b455785c0547f03cc054aee1b96482863f25" translate="yes" xml:space="preserve">
          <source>Then the locking mode applies only to the named database. If no database name qualifier precedes the &quot;locking_mode&quot; keyword then the locking mode is applied to all databases, including any new databases added by subsequent &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; commands.</source>
          <target state="translated">然后，锁定模式仅适用于命名数据​​库。如果在&amp;ldquo; locking_mode&amp;rdquo;关键字之前没有数据库名称限定符，则锁定模式将应用于所有数据库，包括由后续&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;命令添加的任何新数据库。</target>
        </trans-unit>
        <trans-unit id="2ace62cf521cfc04b47d7dad558287516162d423" translate="yes" xml:space="preserve">
          <source>Then the virtual table would be created with two hidden columns, and with datatypes of &quot;VARCHAR(12)&quot; and &quot;INTEGER&quot;.</source>
          <target state="translated">然后用两个隐藏列创建虚拟表,数据类型为 &quot;VARCHAR(12)&quot;和 &quot;INTEGER&quot;。</target>
        </trans-unit>
        <trans-unit id="b398879a2efe1c2e2e8691470971432fd8ac7954" translate="yes" xml:space="preserve">
          <source>Then to read the first page of that database file, one merely runs:</source>
          <target state="translated">然后要读取该数据库文件的第一页,只需运行。</target>
        </trans-unit>
        <trans-unit id="9a0f2cc8cc7905afb88e588449e50b02e607b774" translate="yes" xml:space="preserve">
          <source>Then two &quot;virtual&quot; terms are added as follows:</source>
          <target state="translated">然后再加上两个 &quot;虚 &quot;字,如下。</target>
        </trans-unit>
        <trans-unit id="ca7fe30da623ecbcc16dc68b6763c7b9a4af11d0" translate="yes" xml:space="preserve">
          <source>Then use the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX()&lt;/a&gt; functions to bind your large string values to the SQL statement. The use of binding obviates the need to escape quote characters in the string, reducing the risk of SQL injection attacks. It also runs faster since the large string does not need to be parsed or copied as much.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d3ddffeb2cfef8ef81678864135303a52c1015f" translate="yes" xml:space="preserve">
          <source>Then use the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX()&lt;/a&gt; functions to bind your large string values to the SQL statement. The use of binding obviates the need to escape quote characters in the string, reducing the risk of SQL injection attacks. It is also runs faster since the large string does not need to be parsed or copied as much.</source>
          <target state="translated">然后，使用&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX（）&lt;/a&gt;函数将较大的字符串值绑定到SQL语句。绑定的使用避免了对字符串中的引号字符进行转义的需要，从而降低了SQL注入攻击的风险。由于不需要分析或复制大字符串，因此它的运行速度也更快。</target>
        </trans-unit>
        <trans-unit id="265606c9637ac4024a4237e1919b8d5a2a194605" translate="yes" xml:space="preserve">
          <source>Then, love your neighbor as yourself.</source>
          <target state="translated">那么,要爱你的邻居像爱自己一样。</target>
        </trans-unit>
        <trans-unit id="aaba5b69e34e258d19f535d62804a66ddc861cc0" translate="yes" xml:space="preserve">
          <source>Then, when the application attempts to open the database, register the system() function, then run an innocent query against the &quot;tab1&quot; table, it instead deletes all the files in its working directory. Yikes!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cfbc622cd136a62d323c5b8bab5c8bc5876d69e" translate="yes" xml:space="preserve">
          <source>There are &lt;a href=&quot;vtablist&quot;&gt;many other virtual table implementations&lt;/a&gt; in the SQLite source tree that can be used as examples. Locate these other virtual table implementations by searching for &quot;sqlite3_create_module&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf0cc9442c93b87173641af3ce48fe6ba6a56819" translate="yes" xml:space="preserve">
          <source>There are U or more such b-trees on a single level (see the documentation for the &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 automerge option&lt;/a&gt; for an explanation of b-tree levels), where U is the value assigned to the &lt;a href=&quot;fts5#the_usermerge_configuration_option&quot;&gt;FTS5 usermerge option&lt;/a&gt; option.</source>
          <target state="translated">在单个级别上有U个或多个这样的b树（请参阅&lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5自动合并选项&lt;/a&gt;的文档以获取 b树级别的说明），其中U是分配给&lt;a href=&quot;fts5#the_usermerge_configuration_option&quot;&gt;FTS5 usermerge选项&lt;/a&gt;选项的值。</target>
        </trans-unit>
        <trans-unit id="fd10b08d9cff8fbc86ae03afd572ce0a4529a480" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to being serverless. The main advantage is that there is no separate server process to install, setup, configure, initialize, manage, and troubleshoot. This is one reason why SQLite is a &quot;&lt;a href=&quot;zeroconf&quot;&gt;zero-configuration&lt;/a&gt;&quot; database engine. Programs that use SQLite require no administrative support for setting up the database engine before they are run. Any program that is able to access the disk is able to use an SQLite database.</source>
          <target state="translated">无服务器具有优点和缺点。主要优点是，没有安装，设置，配置，初始化，管理和故障排除的单独服务器进程。这就是SQLite是&amp;ldquo; &lt;a href=&quot;zeroconf&quot;&gt;零配置&lt;/a&gt; &amp;rdquo;数据库引擎的原因之一。使用SQLite的程序在运行之前不需要任何管理支持即可设置数据库引擎。任何能够访问磁盘的程序都可以使用SQLite数据库。</target>
        </trans-unit>
        <trans-unit id="9e47d4a7ae3779b3ce3872907368c2ebe6ca93d1" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to being serverless. The main advantage is that there is no separate server process to install, setup, configure, initialize, manage, and troubleshoot. This is one reason why SQLite is a &quot;zero-configuration&quot; database engine. Programs that use SQLite require no administrative support for setting up the database engine before they are run. Any program that is able to access the disk is able to use an SQLite database.</source>
          <target state="translated">无服务器有优势也有劣势。主要的优点是没有单独的服务器进程来安装、设置、配置、初始化、管理和故障排除。这也是为什么SQLite是一个 &quot;零配置 &quot;的数据库引擎的原因之一。使用SQLite的程序在运行前不需要管理支持来设置数据库引擎。任何能够访问磁盘的程序都能够使用SQLite数据库。</target>
        </trans-unit>
        <trans-unit id="a00099ff32dd16c72c3ea081a513584d8f3c38e0" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to using WAL instead of a rollback journal. Advantages include:</source>
          <target state="translated">使用WAL代替回滚日记账有其优势和劣势。优点包括:</target>
        </trans-unit>
        <trans-unit id="3093b427039bbfacae2cf7cc0c20cdff14795a5c" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to using memory-mapped I/O. Advantages include:</source>
          <target state="translated">使用内存映射的I/O有优势也有劣势。优点包括:</target>
        </trans-unit>
        <trans-unit id="79bd071128837bce919057f74da96b8e84ac063f" translate="yes" xml:space="preserve">
          <source>There are certain reasonable restrictions on expressions that appear in CREATE INDEX statements:</source>
          <target state="translated">对出现在CREATE INDEX语句中的表达式有一定的合理限制。</target>
        </trans-unit>
        <trans-unit id="0440cacf20ea4b02e6a0db0e8999f07d0748bd04" translate="yes" xml:space="preserve">
          <source>There are compile-time options that will set upper bounds on the sizes of various structures in SQLite. The compile-time options normally set a hard upper bound that can be changed at run-time on individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface.</source>
          <target state="translated">有一些编译时选项可以设置SQLite中各种结构的大小的上限。编译时选项通常设置一个硬上限，可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;接口在单个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;上更改该硬上限。</target>
        </trans-unit>
        <trans-unit id="5db06d3cdfac9a23d2859adb4baf70db2e25be47" translate="yes" xml:space="preserve">
          <source>There are currently 170 opcodes defined by the virtual machine. All currently defined opcodes are described in the table below. This table was generated automatically by scanning the source code from the file &lt;a href=&quot;http://www.sqlite.org/src/artifact/da4030a71acf42be18001b9b7067d6d34ffb76610603ce6fafa52854b9e52936&quot;&gt;vdbe.c&lt;/a&gt;.</source>
          <target state="translated">虚拟机当前定义了170个操作码。下表描述了所有当前定义的操作码。该表是通过扫描文件&lt;a href=&quot;http://www.sqlite.org/src/artifact/da4030a71acf42be18001b9b7067d6d34ffb76610603ce6fafa52854b9e52936&quot;&gt;vdbe.c中&lt;/a&gt;的源代码自动生成的。</target>
        </trans-unit>
        <trans-unit id="3d151e494351273cc5176bb466ee794220518dba" translate="yes" xml:space="preserve">
          <source>There are currently 175 opcodes defined by the virtual machine. All currently defined opcodes are described in the table below. This table was generated automatically by scanning the source code from the file &lt;a href=&quot;http://www.sqlite.org/src/artifact/e9f7f818f128c8600058c0eabb6b3975974c95153a104d340f419adabbc15b9f&quot;&gt;vdbe.c&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f94a164918f438c0d1173d53f7a4f94c08b35d7" translate="yes" xml:space="preserve">
          <source>There are currently the following configuration options:</source>
          <target state="translated">目前有以下配置选项:</target>
        </trans-unit>
        <trans-unit id="3c95acf82c00de5d5751bda48036e2a0038274e3" translate="yes" xml:space="preserve">
          <source>There are details to fill in here. Perhaps a screen can be provided that displays a history changes (perhaps with a graph) allowing the user to select which version they want to view or edit. Perhaps some facility can be provided to merge forks that might occur in the version history. And perhaps the application should provide a means to purge old and unwanted versions. The key point is that using an SQLite database to store the content, rather than a ZIP archive, makes all of these features much, much easier to implement, which increases the possibility that they will eventually get implemented.</source>
          <target state="translated">这里有一些细节需要填写。也许可以提供一个屏幕,显示历史变化(也许用图表),允许用户选择他们想要查看或编辑的版本。也许可以提供一些设施来合并可能发生在版本历史中的分叉。也许应用程序应该提供一种方法来清除旧的和不需要的版本。关键的一点是,使用SQLite数据库来存储内容,而不是ZIP存档,使得所有这些功能更容易实现,这增加了它们最终得到实现的可能性。</target>
        </trans-unit>
        <trans-unit id="97fa5e0129d965dcc6b70eeae4ab75a90f4ae6ee" translate="yes" xml:space="preserve">
          <source>There are dozens and dozens of SQL function implementations scattered throughout the SQLite source code that can be used as example applications. The built-in SQL functions use the same interface as application-defined SQL functions, so built-in functions can be used as examples too. Search for &quot;sqlite3_context&quot; in the SQLite source code to find examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98cb1601f44f3fee5a33f8d40abfeb82b5e7251a" translate="yes" xml:space="preserve">
          <source>There are five separate read locks, numbers 0 through 4. Read locks may be either SHARED or EXCLUSIVE. Connections obtain a shared lock on one of the read locks bytes while they are within a transaction. Connections also obtain an exclusive lock on read locks, one at a time, for the brief moment while they are updating the values of the corresponding read-marks. Read locks 1 through 4 are held exclusively when running &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt;.</source>
          <target state="translated">有五个单独的读取锁，编号为0到4。读取锁可以是SHARED或EXCLUSIVE。当连接处于事务中时，连接会在其中一个读取锁字节上获得共享锁。当连接在更新相应读取标记的值时，连接也会在短暂的时间内获得一次读锁定的排他锁。运行&lt;a href=&quot;walformat#recovery&quot;&gt;恢复&lt;/a&gt;时，将仅保留读取锁1至4 。</target>
        </trans-unit>
        <trans-unit id="c457ee41ba8d1b7387ba8e7edc9a0ac19be4f375" translate="yes" xml:space="preserve">
          <source>There are five ways to describe starting and ending frame boundaries:</source>
          <target state="translated">有五种方法来描述起止框界。</target>
        </trans-unit>
        <trans-unit id="c2ce0d23c5814413e2c1fb5364c7eef30a6e31f7" translate="yes" xml:space="preserve">
          <source>There are four independent test harnesses used for testing the core SQLite library. Each test harness is designed, maintained, and managed separately from the others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="253fb3b554421e91657bed4f34f13690b219d88b" translate="yes" xml:space="preserve">
          <source>There are many SQL-based database management systems available, besides SQLite. Common options include MySQL, PostgreSQL, and SQL-Server. All these systems use the SQL langauge to communicate with the application, just like SQLite. But these other systems different from SQLite in important respects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4083c54b42aa73500fa86d4b0409e55690866a09" translate="yes" xml:space="preserve">
          <source>There are many advantages to using SQLite as an application file format, including:</source>
          <target state="translated">使用SQLite作为应用文件格式有很多优势,包括:1:</target>
        </trans-unit>
        <trans-unit id="7e1c62962db715e611550a655ba502415a8c24f6" translate="yes" xml:space="preserve">
          <source>There are many benefits to this approach, including improved performance, reduced cost and complexity, and improved reliability. See technical notes &lt;a href=&quot;aff_short&quot;&gt;&quot;aff_short.html&quot;&lt;/a&gt; and &lt;a href=&quot;appfileformat&quot;&gt;&quot;appfileformat.html&quot;&lt;/a&gt; and &lt;a href=&quot;fasterthanfs&quot;&gt;&quot;fasterthanfs.html&quot;&lt;/a&gt; for more information. This use case is closely related to the &lt;a href=&quot;#wireproto&quot;&gt;data transfer format&lt;/a&gt; and &lt;a href=&quot;#container&quot;&gt;data container&lt;/a&gt; use cases below.</source>
          <target state="translated">这种方法有很多好处，包括改进的性能，降低的成本和复杂性以及改进的可靠性。有关更多信息，请参见技术说明&lt;a href=&quot;aff_short&quot;&gt;&amp;ldquo; aff_short.html&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;appfileformat&quot;&gt;&amp;ldquo; appfileformat.html&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;fasterthanfs&quot;&gt;&amp;ldquo; fasterthanfs.html&amp;rdquo;&lt;/a&gt;。该用例与下面的&lt;a href=&quot;#wireproto&quot;&gt;数据传输格式&lt;/a&gt;和&lt;a href=&quot;#container&quot;&gt;数据容器&lt;/a&gt;用例密切相关。</target>
        </trans-unit>
        <trans-unit id="a6dd1c1ec54122d1cd8a41e77d633d60c4de1054" translate="yes" xml:space="preserve">
          <source>There are many different extended result codes for I/O errors that identify the specific I/O operation that failed.</source>
          <target state="translated">I/O错误有许多不同的扩展结果代码,可以识别失败的具体I/O操作。</target>
        </trans-unit>
        <trans-unit id="f265782324871b5641aee92d51fefe1edfb475af" translate="yes" xml:space="preserve">
          <source>There are many fraudulent USB sticks in circulation that report to have a high capacity (ex: 8GB) but are really only capable of storing a much smaller amount (ex: 1GB). Attempts to write on these devices will often result in unrelated files being overwritten. Any use of a fraudulent flash memory device can easily lead to database corruption, therefore. Internet searches such as &quot;fake capacity usb&quot; will turn up lots of disturbing information about this problem.</source>
          <target state="translated">有许多欺诈性的USB棒在流通中,报告有一个高容量(如:8GB),但实际上只能存储更小的数量(如:1GB)。试图在这些设备上写东西,往往会导致不相关的文件被覆盖。因此,任何使用假冒闪存设备的行为都很容易导致数据库损坏。在互联网上搜索 &quot;假容量U盘 &quot;等,会发现很多关于这个问题的令人不安的信息。</target>
        </trans-unit>
        <trans-unit id="a53dc58a565490cefd808a058bfaad47e191a084" translate="yes" xml:space="preserve">
          <source>There are many more features not listed above. SQLite may be small in size and have &quot;Lite&quot; in its name, but it is not lacking in capability.</source>
          <target state="translated">还有很多功能没有在上面列出。SQLite可能体积很小,名字中也有 &quot;Lite&quot;,但它并不缺乏功能。</target>
        </trans-unit>
        <trans-unit id="60f662540321a06d796e68831dc73409bf49f397" translate="yes" xml:space="preserve">
          <source>There are many other dot-commands available in the command-line shell. See the &quot;.help&quot; command for a complete list for any particular version and build of SQLite.</source>
          <target state="translated">在命令行shell中还有许多其他的点命令。请参阅&quot;.help &quot;命令以获得任何特定版本和SQLite构建的完整列表。</target>
        </trans-unit>
        <trans-unit id="53f739b37a172fddf027f7c8afb4029bf933f8fe" translate="yes" xml:space="preserve">
          <source>There are many other testing options, which can be seen by running the command:</source>
          <target state="translated">还有很多其他的测试选项,可以通过运行命令来查看。</target>
        </trans-unit>
        <trans-unit id="461c7676d827031f4cd64d05f3d67e68ce256daf" translate="yes" xml:space="preserve">
          <source>There are many ways to measure test coverage. The most popular metric is &quot;statement coverage&quot;. When you hear someone say that their program as &quot;XX% test coverage&quot; without further explanation, they usually mean statement coverage. Statement coverage measures what percentage of lines of code are executed at least once by the test suite.</source>
          <target state="translated">衡量测试覆盖率的方法有很多。最流行的衡量标准是 &quot;语句覆盖率&quot;。当你听到有人说他们的程序是 &quot;XX%的测试覆盖率&quot;,而没有进一步的解释,他们通常指的是语句覆盖率。语句覆盖率衡量的是测试套件至少执行一次的代码行的百分比。</target>
        </trans-unit>
        <trans-unit id="15784824361af8c293ec21cb8076051131fb442d" translate="yes" xml:space="preserve">
          <source>There are no arbitrary limits in TH3. One could generate a single test program that contained all test modules and all configuration files. However, such a test program might be too large to deploy on embedded platforms. (As of 2018-05-19, a full-up TH3 test is over 850,000 lines and 58MB of C code.) TH3 provides the ability to break the library of test modules up into smaller, more easily digested pieces.</source>
          <target state="translated">在TH3中没有任意的限制。人们可以生成一个包含所有测试模块和所有配置文件的单一测试程序。然而,这样的测试程序可能太大,无法部署在嵌入式平台上。(截至2018-05-19,一个完整的TH3测试是超过85万行和58MB的C代码)。TH3提供了将测试模块库分解成更小的、更容易消化的片段的能力。</target>
        </trans-unit>
        <trans-unit id="67165e227e06a66e9e2a7c9a359bffd814ca48a8" translate="yes" xml:space="preserve">
          <source>There are no arbitrary limits on the number of indices that can be attached to a single table. The number of columns in an index is limited to the value set by &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt;,...).</source>
          <target state="translated">可以附加到单个表的索引数没有任意限制。索引中的列数限制为&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt;，...）设置的值。</target>
        </trans-unit>
        <trans-unit id="75e5745eabbe1f0d9742be6d3047103706a06632" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; to Multi-thread. In other words, it disables mutexing on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; objects. The application is responsible for serializing access to &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;. But other mutexes are enabled so that SQLite will be safe to use in a multi-threaded environment as long as no two threads attempt to use the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Multi-thread &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_MULTITHREAD configuration option.</source>
          <target state="translated">此选项没有参数。此选项将&lt;a href=&quot;../threadsafe&quot;&gt;线程处理模式设置&lt;/a&gt;为多线程。换句话说，它禁用&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;和预&lt;a href=&quot;stmt&quot;&gt;准备语句&lt;/a&gt;对象的静音。该应用程序负责序列化对&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;和&lt;a href=&quot;stmt&quot;&gt;准备好的语句的&lt;/a&gt;访问。但是启用了其他互斥锁，以便SQLite在多线程环境中可以安全地使用，只要没有两个线程尝试同时使用同一&lt;a href=&quot;sqlite3&quot;&gt;数据库连接即可&lt;/a&gt;。如果使用&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;编译时选项编译SQLite ，则无法设置多线程&lt;a href=&quot;../threadsafe&quot;&gt;线程模式&lt;/a&gt;和&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;如果使用SQLITE_CONFIG_MULTITHREAD配置选项调用，将返回&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="438fea25e22862b67e0b2e195af310125649fa4d" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; to Serialized. In other words, this option enables all mutexes including the recursive mutexes on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; objects. In this mode (which is the default when SQLite is compiled with &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=1&lt;/a&gt;) the SQLite library will itself serialize access to &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt; so that the application is free to use the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; or the same &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; in different threads at the same time. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Serialized &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SERIALIZED configuration option.</source>
          <target state="translated">此选项没有参数。此选项将&lt;a href=&quot;../threadsafe&quot;&gt;线程处理模式设置&lt;/a&gt;为序列化。换句话说，此选项启用所有互斥锁，包括&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;和&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;对象上的递归互斥锁。在这种模式下（这是使用&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 1&lt;/a&gt;编译SQLite时的默认设置），SQLite库本身将序列化对&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;和&lt;a href=&quot;stmt&quot;&gt;预处理语句的&lt;/a&gt;访问，以便应用程序可以在不同线程中自由使用相同的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;或相同的&lt;a href=&quot;stmt&quot;&gt;预处理语句&lt;/a&gt;与此同时。如果使用&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;编译SQLite编译时选项，则无法设置序列化&lt;a href=&quot;../threadsafe&quot;&gt;线程模式&lt;/a&gt;，如果使用SQLITE_CONFIG_SERIALIZED配置选项调用，则&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;将返回&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4b86fd3dbc8c8ae83073b70ec3ca59694912ef28" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; to Single-thread. In other words, it disables all mutexing and puts SQLite into a mode where it can only be used by a single thread. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to change the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; from its default value of Single-thread and so &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SINGLETHREAD configuration option.</source>
          <target state="translated">此选项没有参数。此选项将&lt;a href=&quot;../threadsafe&quot;&gt;线程处理模式&lt;/a&gt;设置为&amp;ldquo;单线程&amp;rdquo;。换句话说，它禁用所有静音，并将SQLite置于只能由单个线程使用的模式。如果使用&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0的&lt;/a&gt;编译时选项编译SQLite ，则无法将&lt;a href=&quot;../threadsafe&quot;&gt;线程模式&lt;/a&gt;从其默认值Single-thread 更改，因此&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;如果使用SQLITE_CONFIG_SINGLETHREAD配置选项调用，将返回&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6b294707b24261f0f532c64902934c051eedbd1" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Multi-thread. In other words, it disables mutexing on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; objects. The application is responsible for serializing access to &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;. But other mutexes are enabled so that SQLite will be safe to use in a multi-threaded environment as long as no two threads attempt to use the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Multi-thread &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_MULTITHREAD configuration option.</source>
          <target state="translated">此选项没有参数。此选项将&lt;a href=&quot;threadsafe&quot;&gt;线程处理模式设置&lt;/a&gt;为多线程。换句话说，它禁用&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;和预&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备语句&lt;/a&gt;对象的静音。该应用程序负责序列化对&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;和&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句的&lt;/a&gt;访问。但是启用了其他互斥锁，以便SQLite在多线程环境中可以安全地使用，只要没有两个线程尝试同时使用同一&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接即可&lt;/a&gt;。如果使用&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;编译时选项编译SQLite ，则无法设置多线程&lt;a href=&quot;threadsafe&quot;&gt;线程模式&lt;/a&gt;和&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;如果使用SQLITE_CONFIG_MULTITHREAD配置选项调用，将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="955a610f066915f2766fca467b944718d1ee6aea" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Serialized. In other words, this option enables all mutexes including the recursive mutexes on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; objects. In this mode (which is the default when SQLite is compiled with &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=1&lt;/a&gt;) the SQLite library will itself serialize access to &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt; so that the application is free to use the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; or the same &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; in different threads at the same time. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Serialized &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SERIALIZED configuration option.</source>
          <target state="translated">此选项没有参数。此选项将&lt;a href=&quot;threadsafe&quot;&gt;线程处理模式设置&lt;/a&gt;为序列化。换句话说，此选项启用所有互斥锁，包括&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;和&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;对象上的递归互斥锁。在这种模式下（这是使用&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 1&lt;/a&gt;编译SQLite时的默认设置），SQLite库本身将序列化对&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;和&lt;a href=&quot;#sqlite3_stmt&quot;&gt;预处理语句的&lt;/a&gt;访问，以便应用程序可以在不同线程中自由使用相同的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;或相同的&lt;a href=&quot;#sqlite3_stmt&quot;&gt;预处理语句&lt;/a&gt;与此同时。如果使用&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;编译SQLite编译时选项，则无法设置序列化&lt;a href=&quot;threadsafe&quot;&gt;线程模式&lt;/a&gt;，如果使用SQLITE_CONFIG_SERIALIZED配置选项调用，则&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1bc66a3a72545b16257e521a7b7467b7b7fb116b" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Single-thread. In other words, it disables all mutexing and puts SQLite into a mode where it can only be used by a single thread. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to change the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; from its default value of Single-thread and so &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SINGLETHREAD configuration option.</source>
          <target state="translated">此选项没有参数。此选项将&lt;a href=&quot;threadsafe&quot;&gt;线程处理模式&lt;/a&gt;设置为&amp;ldquo;单线程&amp;rdquo;。换句话说，它禁用所有静音，并将SQLite置于只能由单个线程使用的模式。如果使用&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0的&lt;/a&gt;编译时选项编译SQLite ，则无法将&lt;a href=&quot;threadsafe&quot;&gt;线程模式&lt;/a&gt;从其默认值Single-thread 更改，因此&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;如果使用SQLITE_CONFIG_SINGLETHREAD配置选项调用，将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="33e0331165757b835edb3c42bfc1d34942851312" translate="yes" xml:space="preserve">
          <source>There are numerous test cases that verify that SQLite is able to deal with malformed database files. These tests first build a well-formed database file, then add corruption by changing one or more bytes in the file by some means other than SQLite. Then SQLite is used to read the database. In some cases, the bytes changes are in the middle of data. This causes the content of the database to change while keeping the database well-formed. In other cases, unused bytes of the file are modified, which has no effect on the integrity of the database. The interesting cases are when bytes of the file that define database structure get changed. The malformed database tests verify that SQLite finds the file format errors and reports them using the &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; return code without overflowing buffers, dereferencing NULL pointers, or performing other unwholesome actions.</source>
          <target state="translated">有许多测试用例可以验证SQLite是否可以处理格式错误的数据库文件。这些测试首先构建格式正确的数据库文件，然后通过SQLite以外的其他方法通过更改文件中的一个或多个字节来添加损坏。然后使用SQLite读取数据库。在某些情况下，字节更改位于数据中间。这将导致数据库的内容发生变化，同时保持数据库的格式正确。在其他情况下，将修改文件的未使用字节，这不会影响数据库的完整性。有趣的情况是定义数据库结构的文件的字节被更改。格式错误的数据库测试将验证SQLite是否找到文件格式错误并使用&lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt;报告错误 返回代码而不会溢出缓冲区，取消引用NULL指针或执行其他有害操作。</target>
        </trans-unit>
        <trans-unit id="f9afe2547739122b5f898fca4cf352f033d81b8f" translate="yes" xml:space="preserve">
          <source>There are only two reasonable ways to implement this query. (There are many other possible algorithms, but none of the others are contenders for being the &quot;best&quot; algorithm.)</source>
          <target state="translated">只有两种合理的方法可以实现这个查询。有许多其他可能的算法,但其他算法都不是 &quot;最佳 &quot;算法的竞争者)。</target>
        </trans-unit>
        <trans-unit id="35c4953b7b40ec225a59ad1651360c7dbd0086b0" translate="yes" xml:space="preserve">
          <source>There are other SQL database engines with liberal licenses that allow the code to be broadly and freely used. But those other engines are still governed by copyright law. SQLite is different in that copyright law simply does not apply.</source>
          <target state="translated">还有其他一些SQL数据库引擎,它们拥有自由的许可证,允许广泛和自由地使用代码。但这些其他引擎仍然受版权法的约束。SQLite则不同,版权法根本不适用。</target>
        </trans-unit>
        <trans-unit id="00840e534b3409464615b9e5469c1789e0356b07" translate="yes" xml:space="preserve">
          <source>There are other VFS implementations both in the core SQLite source code library and in available extensions. The list above is not meant to be exhaustive but merely representative of the kinds of features that can be realized using the VFS interface.</source>
          <target state="translated">在SQLite核心源码库和可用的扩展中还有其他的VFS实现。上面的列表并不意味着详尽无遗,而只是代表了使用VFS接口可以实现的各种功能。</target>
        </trans-unit>
        <trans-unit id="fe657852dc4212647e79b2906ecbf326edcfcb96" translate="yes" xml:space="preserve">
          <source>There are several other ways to add an equivalent foreign key declaration to a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. Refer to the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE documentation&lt;/a&gt; for details.</source>
          <target state="translated">还有其他几种将等效的外键声明添加到&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句的方法。有关详细信息，请参考&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14687afe7afa4066d985b4f03845594063586e18" translate="yes" xml:space="preserve">
          <source>There are several ways of thinking about the RELEASE command:</source>
          <target state="translated">RELEASE命令有几种思路。</target>
        </trans-unit>
        <trans-unit id="22c57ea3a56c1a621fcb33ba044a6de73ca1f510" translate="yes" xml:space="preserve">
          <source>There are several ways to approach this in FTS5:</source>
          <target state="translated">在FTS5中,有几种方法可以解决这个问题。</target>
        </trans-unit>
        <trans-unit id="de40b756c06e57b21f4c7c518f428b201082172b" translate="yes" xml:space="preserve">
          <source>There are some contexts in SQLite that do not allow the use of non-deterministic functions:</source>
          <target state="translated">在SQLite中,有一些上下文不允许使用非确定性函数。</target>
        </trans-unit>
        <trans-unit id="ffb257ce26a3636acdb1a9134b8ec418a490f506" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of a VALUES clause that are not shown on the syntax diagrams:</source>
          <target state="translated">对于VALUES子句的使用有一些限制,这些限制没有在语法图上显示出来。</target>
        </trans-unit>
        <trans-unit id="4fc9c795ba02424df295c5bd8e19a42a3240738c" translate="yes" xml:space="preserve">
          <source>There are three frame types: ROWS, GROUPS, and RANGE. The frame type determines how the starting and ending boundaries of the frame are measured.</source>
          <target state="translated">有三种框架类型。ROWS、GROUPS和RANGE。帧类型决定了如何测量帧的起始和结束边界。</target>
        </trans-unit>
        <trans-unit id="b1e7d89744d05b6a27dde7db2836b2617aa1bbd6" translate="yes" xml:space="preserve">
          <source>There are three independent test harnesses used for testing the core SQLite library. Each test harness is designed, maintained, and managed separately from the others.</source>
          <target state="translated">有三个独立的测试线束用于测试核心SQLite库。每个测试线束都是单独设计、维护和管理的。</target>
        </trans-unit>
        <trans-unit id="045c3584370eb289c548f60cb3b6ecaf401b3ed3" translate="yes" xml:space="preserve">
          <source>There are three levels to the shared-cache locking model, transaction level locking, table level locking and schema level locking. They are described in the following three sub-sections.</source>
          <target state="translated">共享缓存锁定模型有三个层次,事务级锁定、表级锁定和模式级锁定。下面三个小节将对它们进行描述。</target>
        </trans-unit>
        <trans-unit id="e99c034a6b8af219b7e8f49f9f3d601cff4065a7" translate="yes" xml:space="preserve">
          <source>There are three math functions available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eaabb690f2c43b66d0713f1063a91097f30c63b" translate="yes" xml:space="preserve">
          <source>There are three possible outputs from the verify_checksum() function: 1, 0, and NULL. 1 is returned if the checksum is correct. 0 is returned if the checksum is incorrect. NULL is returned if the page is unreadable. If checksumming is enabled, the read will fail if the checksum is wrong, so the usual result from verify_checksum() on a bad checksum is NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="944bcf56eaccf2f8d8f73507f47a4f5f610aa075" translate="yes" xml:space="preserve">
          <source>There are three reasons to set the locking-mode to EXCLUSIVE.</source>
          <target state="translated">有三个原因可以将锁定模式设置为EXCLUSIVE。</target>
        </trans-unit>
        <trans-unit id="e889a4b513747e6b54c292e814d5a011df18d8e5" translate="yes" xml:space="preserve">
          <source>There are three special-case entries in the cost table:</source>
          <target state="translated">费用表中有三个特殊情况条目。</target>
        </trans-unit>
        <trans-unit id="3e8f3752e4f9aab9d7f5e605906342c5eeca4178" translate="yes" xml:space="preserve">
          <source>There are two advantages to using the SQLite printf functions instead of &lt;b&gt;sprintf&lt;/b&gt;. First of all, with the SQLite printf routines, there is never a danger of overflowing a static buffer as there is with &lt;b&gt;sprintf&lt;/b&gt;. The SQLite printf routines automatically allocate (and later frees) as much memory as is necessary to hold the SQL statements generated.</source>
          <target state="translated">使用SQLite printf函数而不是&lt;b&gt;sprintf&lt;/b&gt;有两个优点。首先，使用SQLite printf例程，永远不会像&lt;b&gt;sprintf&lt;/b&gt;那样存在溢出静态缓冲区的危险。SQLite printf例程会自动分配（并在以后释放）所需的内存，以容纳生成的SQL语句。</target>
        </trans-unit>
        <trans-unit id="391950a505dd77c6d9de2b0a8bf9dd26b935ed51" translate="yes" xml:space="preserve">
          <source>There are two aggregate SQL functions:</source>
          <target state="translated">有两个聚合SQL函数。</target>
        </trans-unit>
        <trans-unit id="631b7dfac93f3d53c23db92b1bef743005732dff" translate="yes" xml:space="preserve">
          <source>There are two cases to consider: (1) Table &quot;tab1&quot; does not previously exist and (2) table &quot;tab1&quot; does already exist.</source>
          <target state="translated">有两种情况需要考虑。(1)表 &quot;tab1 &quot;以前不存在,(2)表 &quot;tab1 &quot;已经存在。</target>
        </trans-unit>
        <trans-unit id="b8b8531dc422d3e33d42cc7bdad0abd37870f1fe" translate="yes" xml:space="preserve">
          <source>There are two column (M==2) and three rows (N==3). Thus the result table has 8 entries. Suppose the result table is stored in an array names azResult. Then azResult holds this content:</source>
          <target state="translated">有两列(M==2)和三行(N==3)。因此结果表有8个条目。假设结果表存储在一个名为azResult的数组中。那么azResult中就存放了这个内容。</target>
        </trans-unit>
        <trans-unit id="e8adb25d367ffc51207827de29ffc66a0b34c609" translate="yes" xml:space="preserve">
          <source>There are two columns (M==2) and three rows (N==3). Thus the result table has 8 entries. Suppose the result table is stored in an array named azResult. Then azResult holds this content:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="928a963ad2407ff0d2d21e12347ddb23d756bb64" translate="yes" xml:space="preserve">
          <source>There are two differences in this variation. The initial-select is &quot;SELECT 1&quot; instead of &quot;VALUES(1)&quot;. But those are just different syntaxes for saying exactly the same thing. The other change is that the recursion is stopped by a LIMIT rather than a WHERE clause. The use of LIMIT means that when the one-millionth row is added to the &quot;cnt&quot; table (and returned by the main SELECT, thanks to the query optimizer) then the recursion stops immediately regardless of how many rows might be left in the queue. On more complex queries, it can sometimes be difficult to ensure that the WHERE clause will eventually cause the queue to drain and the recursion to terminate. But the LIMIT clause will always stop the recursion. So it is good practice to always include a LIMIT clause as a safety if an upper bound on the size of the recursion is known.</source>
          <target state="translated">这个变化有两个不同之处。初始选择是 &quot;SELECT 1 &quot;而不是 &quot;VALUES(1)&quot;。但是这些只是不同的语法,说的是完全相同的事情。另一个变化是递归由一个LIMIT而不是WHERE子句来停止。使用LIMIT意味着当第100万条记录被添加到 &quot;cnt &quot;表中时(并由主SELECT返回,这要归功于查询优化器),那么递归就会立即停止,不管队列中可能还剩下多少条记录。在更复杂的查询中,有时很难确保WHERE子句最终会导致队列耗尽,递归终止。但是LIMIT子句总是会停止递归。所以,如果知道递归的大小有一个上限,那么作为安全起见,总是包含一个LIMIT子句是一个很好的做法。</target>
        </trans-unit>
        <trans-unit id="bb5962b52c02f4df27314354c0118e64e476f288" translate="yes" xml:space="preserve">
          <source>There are two separate configuration changes here which can be used either togethr or separately. The &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; setting disables the mutexes that serialize access to &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects. With this setting, the application is free to use SQLite from multiple threads, but it must make sure than no two threads try to access the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; or any &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. Two threads can use SQLite at the same time, but they must use separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;. The second &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; setting disables the mechanism in SQLite that tracks the total size of all outstanding memory allocation requests. This omits the need to mutex each call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;, which saves a huge number of mutex operations. But a consequence of disabling the memory statistics mechanism is that the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt;, &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt;, and &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interfaces cease to work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f943413bc9e88ca64edb6cc154e6b7583f6c77" translate="yes" xml:space="preserve">
          <source>There are two separate configuration changes here which can be used either togethr or separately. The &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; setting disables the mutexes that serialize access to &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects. With this setting, the application is free to use SQLite from multiple threads, but it must make sure than no two threads try to access the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; or any &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. Two threads can use SQLite at the same time, but they must use separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;. The second &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; setting disables the mechanism in SQLite that tracks the total size of all outstanding memory allocation requests. This omits the need to mutex each call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;, which saves a huge number of mutex operations. But a consequence of disabling the memory statistics mechanism is that the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt;, &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt;, and &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interfaces cease to work.</source>
          <target state="translated">这里有两个单独的配置更改，可以一起使用也可以单独使用。该&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt;设置禁用能够连续访问互斥&lt;a href=&quot;c3ref/sqlite3&quot;&gt;的数据库连接&lt;/a&gt;对象，并&lt;a href=&quot;c3ref/stmt&quot;&gt;事先准备好的声明&lt;/a&gt;的对象。使用此设置，应用程序可以从多个线程中自由使用SQLite，但必须确保没有两个线程尝试同时访问同一&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;或与该&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;关联的任何&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;。两个线程可以同时使用SQLite，但是它们必须使用单独的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;。第二个&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;设置将禁用SQLite中跟踪所有未完成的内存分配请求的总大小的机制。这省去了对每次调用&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;和&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;进行互斥的需求，从而节省了大量互斥操作。但是，禁用内存统计信息机制的结果是&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;，&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;和&lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64（）&lt;/a&gt;接口不再起作用。</target>
        </trans-unit>
        <trans-unit id="03b9684a8e7902c26ab2183576e54dd70242a272" translate="yes" xml:space="preserve">
          <source>There are two types of simple SELECT statement - aggregate and non-aggregate queries. A simple SELECT statement is an aggregate query if it contains either a GROUP BY clause or one or more aggregate functions in the result-set. Otherwise, if a simple SELECT contains no aggregate functions or a GROUP BY clause, it is a non-aggregate query.</source>
          <target state="translated">有两种类型的简单SELECT语句--聚合查询和非聚合查询。如果一个简单的SELECT语句包含一个GROUP BY子句或者在结果集中包含一个或多个聚合函数,那么它就是一个聚合查询。否则,如果一个简单的SELECT语句不包含聚合函数或GROUP BY子句,它就是一个非聚合查询。</target>
        </trans-unit>
        <trans-unit id="265655ffc7236582ade45c905963724f97d22dc0" translate="yes" xml:space="preserve">
          <source>There are two ways to use the &quot;content&quot; option:</source>
          <target state="translated">有两种方法可以使用 &quot;内容 &quot;选项。</target>
        </trans-unit>
        <trans-unit id="6c855557ba4350c988043164f7d90199d18c9af0" translate="yes" xml:space="preserve">
          <source>There are typically between 10 to 40 entries in the sqlite_stat4 table for each index for which statistics are available, however these limits are not hard bounds. The meanings of the columns in the sqlite_stat4 table are as follows:</source>
          <target state="translated">在sqlite_stat4表中,每个可以统计的索引通常有10到40个条目,然而这些限制并不是硬性的界限。sqlite_stat4表中各列的含义如下。</target>
        </trans-unit>
        <trans-unit id="7cc2860dd2126e117e20cc785f2f36fc98950f36" translate="yes" xml:space="preserve">
          <source>There are usually multiple entries in the sqlite_stat3 table for each index. The sqlite_stat3.sample column holds the value of the left-most field of an index identified by sqlite_stat3.idx and sqlite_stat3.tbl. The sqlite_stat3.nEq column holds the approximate number of entries in the index whose left-most column exactly matches the sample. The sqlite_stat3.nLt holds the approximate number of entries in the index whose left-most column is less than the sample. The sqlite_stat3.nDLt column holds the approximate number of distinct left-most entries in the index that are less than the sample.</source>
          <target state="translated">在sqlite_stat3表中,每个索引通常有多个条目。sqlite_stat3.sample列保存了由sqlite_stat3.idx和sqlite_stat3.tbl标识的索引最左边字段的值。sqlite_stat3.nEq列保存了索引中最左列与样本完全匹配的条目数。sqlite_stat3.nLt列存放了索引中最左列小于样本的条目数。sqlite_stat3.nDLt列持有索引中最左列小于样本的条目的近似数。</target>
        </trans-unit>
        <trans-unit id="3bc8ca2faf5f82d403479bc810eea0e330c59fbe" translate="yes" xml:space="preserve">
          <source>There can be an arbitrary number of sqlite_stat3 entries per index. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command will typically generate sqlite_stat3 tables that contain between 10 and 40 samples that are distributed across the key space and with large nEq values.</source>
          <target state="translated">每个索引可以有任意数量的sqlite_stat3条目。的&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令将典型地生成包含在跨越密钥空间，并与大NEQ值分布的样本10和40之间sqlite_stat3表。</target>
        </trans-unit>
        <trans-unit id="76781503806bdc9ca573d5796b00968614643484" translate="yes" xml:space="preserve">
          <source>There can be an arbitrary number of sqlite_stat4 entries per index. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command will typically generate sqlite_stat4 tables that contain between 10 and 40 samples that are distributed across the key space and with large nEq values.</source>
          <target state="translated">每个索引可以有任意数量的sqlite_stat4条目。的&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令将典型地生成包含在跨越密钥空间，并与大NEQ值分布的样本10和40之间sqlite_stat4表。</target>
        </trans-unit>
        <trans-unit id="4935a4962bbd49a87bfec8ba26bcb0ee96e2bc65" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler defined for each &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. Setting a new busy handler clears any previously set handler. Note that calling &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; or evaluating &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout=N&lt;/a&gt; will change the busy handler and thus clear any previously set busy handler.</source>
          <target state="translated">每个&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;只能定义一个繁忙的处理程序。设置新的繁忙处理程序将清除所有先前设置的处理程序。请注意，调用&lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;或评估&lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout = N&lt;/a&gt;会更改繁忙处理程序，从而清除任何先前设置的繁忙处理程序。</target>
        </trans-unit>
        <trans-unit id="595614b4fea7d83eeee9eca9b82c7f15a616950a" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler defined for each &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. Setting a new busy handler clears any previously set handler. Note that calling &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; or evaluating &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout=N&lt;/a&gt; will change the busy handler and thus clear any previously set busy handler.</source>
          <target state="translated">每个&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;只能定义一个繁忙的处理程序。设置新的繁忙处理程序将清除所有先前设置的处理程序。请注意，调用&lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;或评估&lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout = N&lt;/a&gt;会更改繁忙处理程序，从而清除任何先前设置的繁忙处理程序。</target>
        </trans-unit>
        <trans-unit id="4557f81c54cd198ad30dafda03e1a7688c37ee6a" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler for a particular &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; at any given moment. If another busy handler was defined (using &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt;) prior to calling this routine, that other busy handler is cleared.</source>
          <target state="translated">在任何给定时刻，特定&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;只能有一个繁忙的处理程序。如果在调用此例程之前定义了另一个繁忙处理程序（使用&lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;sqlite3_busy_handler（）&lt;/a&gt;），则将清除另一个繁忙处理程序。</target>
        </trans-unit>
        <trans-unit id="6c5612f166f3c19adb75f5b9420223d984d062bf" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler for a particular &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; at any given moment. If another busy handler was defined (using &lt;a href=&quot;busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt;) prior to calling this routine, that other busy handler is cleared.</source>
          <target state="translated">在任何给定时刻，特定&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;只能有一个繁忙的处理程序。如果在调用此例程之前定义了另一个繁忙处理程序（使用&lt;a href=&quot;busy_handler&quot;&gt;sqlite3_busy_handler（）&lt;/a&gt;），则将清除另一个繁忙处理程序。</target>
        </trans-unit>
        <trans-unit id="da947c700e89a2839d81ef99abfdba549201cf04" translate="yes" xml:space="preserve">
          <source>There can only be a single error logging callback per process. The error logging callback is registered at start-time using C-code similar to the following:</source>
          <target state="translated">每个进程只能有一个错误记录回调。错误记录回调在启动时使用类似于下面的C代码注册。</target>
        </trans-unit>
        <trans-unit id="297da7a4ca1508d9a0851c1993606776e3a61cd5" translate="yes" xml:space="preserve">
          <source>There can only be a single trace callback registered on a database connection. Each use of &quot;trace&quot; or &quot;trace_v2&quot; cancels all prior trace callback.</source>
          <target state="translated">在一个数据库连接上只能注册一个跟踪回调。每次使用 &quot;trace &quot;或 &quot;trace_v2 &quot;都会取消之前所有的跟踪回调。</target>
        </trans-unit>
        <trans-unit id="13fe35de43729e33636f83c267efada945c04a07" translate="yes" xml:space="preserve">
          <source>There exists some subtle problem with mmap() on QNX such that making a second mmap() call against a single file descriptor can cause the memory obtained from the first mmap() call to be zeroed. SQLite on unix uses mmap() to create a shared memory region for transaction coordination in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, and it will call mmap() multiple times for large transactions. The QNX mmap() has been demonstrated to corrupt database file under that scenario. QNX engineers are aware of this problem and are working on a solution; the problem may have already been fixed by the time you read this.</source>
          <target state="translated">QNX上的mmap（）存在一些细微的问题，例如，对单个文件描述符进行第二次mmap（）调用可能会使从第一次mmap（）调用获得的内存归零。 Unix上的SQLite在&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;使用mmap（）创建用于事务协调的共享内存区域，对于大型事务它将多次调用mmap（）。在这种情况下，QNX mmap（）已被证明损坏了数据库文件。 QNX工程师已经意识到了这个问题，并且正在研究解决方案。在您阅读本文时，该问题可能已经解决。</target>
        </trans-unit>
        <trans-unit id="d56d459074bf9b196b2551c494a4c7bec9d94df2" translate="yes" xml:space="preserve">
          <source>There has lately been a lot of interest in &quot;safe&quot; programming languages like Rust or Go in which it is impossible, or is at least difficult, to make common programming errors like memory leaks or array overruns. So the question often arises as to why SQLite is not coded in a &quot;safe&quot; language.</source>
          <target state="translated">最近,人们对Rust或Go这样的 &quot;安全 &quot;编程语言很感兴趣,在这些语言中,不可能或至少很难犯常见的编程错误,如内存泄漏或数组超限。所以经常有人问,为什么SQLite不采用 &quot;安全 &quot;的语言进行编码。</target>
        </trans-unit>
        <trans-unit id="52072b3d340cc958b2ff6cebc4a70e99aba7da9e" translate="yes" xml:space="preserve">
          <source>There have been three historical file formats for SQLite. SQLite 1.0 through 1.0.32 used the &lt;a href=&quot;https://www.gnu.org/software/gdbm/gdbm.html&quot;&gt;gdbm&lt;/a&gt; library as its storage engine. SQLite 2.0.0 through 2.8.17 used a custom b-tree storage engine that supported only text keys and data. All modern versions of SQLite (3.0.0 to present) use a b-tree storage engine that has full support for binary data and Unicode.</source>
          <target state="translated">SQLite有三种历史文件格式。SQLite的1.0到1.0.32中使用的&lt;a href=&quot;https://www.gnu.org/software/gdbm/gdbm.html&quot;&gt;GDBM&lt;/a&gt;库作为其存储引擎。SQLite 2.0.0至2.8.17使用了自定义的b树存储引擎，该引擎仅支持文本键和数据。所有现代版本的SQLite（目前为3.0.0）都使用b树存储引擎，该引擎完全支持二进制数据和Unicode。</target>
        </trans-unit>
        <trans-unit id="3be8d2f16b71e4444f7f725739b5254eb08f103c" translate="yes" xml:space="preserve">
          <source>There is a function named &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; which will return the integer key for the most recent insert operation.</source>
          <target state="translated">有一个名为&lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt;的函数，它将为最新的插入操作返回整数键。</target>
        </trans-unit>
        <trans-unit id="2c4047eace270e4351576190943319e0de00174c" translate="yes" xml:space="preserve">
          <source>There is a limit, set using &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; and &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt;, to the number of databases that can be simultaneously attached to a single database connection.</source>
          <target state="translated">使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;和&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt;设置了一个限制，该限制是可以同时附加到单个数据库连接的数据库数量。</target>
        </trans-unit>
        <trans-unit id="d03b97c401c9a348f14fea8d291ce117238dc810" translate="yes" xml:space="preserve">
          <source>There is a long list of conditions that must all be met in order for query flattening to occur. Some of the constraints are marked as obsolete by italic text. These extra constraints are retained in the documentation to preserve the numbering of the other constraints.</source>
          <target state="translated">有一长串的条件,必须全部满足,才能实现查询扁平化。有些约束条件用斜体字标明为过时的。文件中保留了这些额外的约束条件,以保留其他约束条件的编号。</target>
        </trans-unit>
        <trans-unit id="098b1868e66c13228c4371a548aa26b3bfac10d5" translate="yes" xml:space="preserve">
          <source>There is a new TypeOf() function used to determine if an expression is numeric or text.</source>
          <target state="translated">有一个新的TypeOf()函数用于确定一个表达式是数字还是文本。</target>
        </trans-unit>
        <trans-unit id="e6da2fbcc052924976fcf688d82595c343604804" translate="yes" xml:space="preserve">
          <source>There is a single row in the sqlite_sequence table for each ordinary table that uses AUTOINCREMENT. The name of the table (as it appears in sqlite_master.name) is in the sqlite_sequence.main field and the largest &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ever inserted into that table is in the sqlite_sequence.seq field. New automatically generated integer primary keys for AUTOINCREMENT tables are guaranteed to be larger than the sqlite_sequence.seq field for that table. If the sqlite_sequence.seq field of an AUTOINCREMENT table is already at the largest integer value (9223372036854775807) then attempts to add new rows to that table with an automatically generated integer primary will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error. The sqlite_sequence.seq field is automatically updated if required when new entries are inserted to an AUTOINCREMENT table. The sqlite_sequence row for an AUTOINCREMENT table is automatically deleted when the table is dropped. If the sqlite_sequence row for an AUTOINCREMENT table does not exist when the AUTOINCREMENT table is updated, then a new sqlite_sequence row is created. If the sqlite_sequence.seq value for an AUTOINCREMENT table is manually set to something other than an integer and there is a subsequent attempt to insert the or update the AUTOINCREMENT table, then the behavior is undefined.</source>
          <target state="translated">对于使用AUTOINCREMENT的每个普通表，在sqlite_sequence表中只有一行。该表的名称（显示在sqlite_master.name中）在sqlite_sequence.main字段中，并且曾经插入该表的最大的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;在sqlite_sequence.seq字段中。确保为AUTOINCREMENT表自动生成的新的整数主键大于该表的sqlite_sequence.seq字段。如果AUTOINCREMENT表的sqlite_sequence.seq字段已经是最大整数值（9223372036854775807），则尝试使用自动生成的整数主表向该表添加新行将失败，并显示&lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;错误。将新条目插入到AUTOINCREMENT表中时，如果需要，可自动更新sqlite_sequence.seq字段。删除表时，将自动删除AUTOINCREMENT表的sqlite_sequence行。如果在更新AUTOINCREMENT表时不存在AUTOINCREMENT表的sqlite_sequence行，那么将创建一个新的sqlite_sequence行。如果将AUTOINCREMENT表的sqlite_sequence.seq值手动设置为整数以外的其他值，并且随后尝试插入或更新AUTOINCREMENT表，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="873101a14a572759e5a45b0dc79cf0cd42bbd9dd" translate="yes" xml:space="preserve">
          <source>There is a single row in the sqlite_sequence table for each ordinary table that uses AUTOINCREMENT. The name of the table (as it appears in sqlite_schema.name) is in the sqlite_sequence.main field and the largest &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ever inserted into that table is in the sqlite_sequence.seq field. New automatically generated integer primary keys for AUTOINCREMENT tables are guaranteed to be larger than the sqlite_sequence.seq field for that table. If the sqlite_sequence.seq field of an AUTOINCREMENT table is already at the largest integer value (9223372036854775807) then attempts to add new rows to that table with an automatically generated integer primary will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error. The sqlite_sequence.seq field is automatically updated if required when new entries are inserted to an AUTOINCREMENT table. The sqlite_sequence row for an AUTOINCREMENT table is automatically deleted when the table is dropped. If the sqlite_sequence row for an AUTOINCREMENT table does not exist when the AUTOINCREMENT table is updated, then a new sqlite_sequence row is created. If the sqlite_sequence.seq value for an AUTOINCREMENT table is manually set to something other than an integer and there is a subsequent attempt to insert the or update the AUTOINCREMENT table, then the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f02c79b70988445eed051dee5ef879c5abc0fcef" translate="yes" xml:space="preserve">
          <source>There is a single row of the dbstat table for each page in the database file. Freelist pages, the lock page, and pointer-map pages of the database file do not appear in the dbstat virtual table.</source>
          <target state="translated">数据库文件中的每一页都有一行dbstat表。数据库文件的自由列表页、锁定页和指针映射页不出现在dbstat虚拟表中。</target>
        </trans-unit>
        <trans-unit id="aad819f0714ba351410884e15d9171da8c02d268" translate="yes" xml:space="preserve">
          <source>There is also a &quot;.once -e&quot; command which works similarly, except that it names the temporary file with a &quot;.txt&quot; suffix so that the default text editor for the system will be invoked, instead of the default spreadsheet.</source>
          <target state="translated">还有一个&quot;.once -e &quot;命令,工作原理类似,只是它用&quot;.txt &quot;后缀来命名临时文件,这样就会调用系统默认的文本编辑器,而不是默认的电子表格。</target>
        </trans-unit>
        <trans-unit id="d689365d69d51f44124dabea5ed23d15cbc239dd" translate="yes" xml:space="preserve">
          <source>There is also a function for computing the Wagner edit distance or the Levenshtein distance between a pattern and a word. This function is exposed as spellfix1_editdist(X,Y). The edit distance function returns the &quot;cost&quot; of converting X into Y. Some transformations cost more than others. Changing one vowel into a different vowel, for example is relatively cheap, as is doubling a constant, or omitting the second character of a double-constant. Other transformations or more expensive. The idea is that the edit distance function returns a low cost for words that are similar and a higher cost for words that are further apart. In this implementation, the maximum cost of any single-character edit (delete, insert, or substitute) is 100, with lower costs for some edits (such as transforming vowels).</source>
          <target state="translated">还有一个函数用于计算模式和单词之间的 Wagner 编辑距离或 Levenshtein 距离。这个函数以 spellfix1_editdist(X,Y)的形式出现。编辑距离函数返回将 X 转换为 Y 的 &quot;成本&quot;。有些转换的成本比其他转换的成本高。例如,将一个元音转换为不同的元音是相对便宜的,将一个常量加倍,或者省略双常量的第二个字符也是如此。其他变换或更昂贵。其想法是,编辑距离函数对相似的字返回的成本较低,对相距较远的字返回的成本较高。在本实施例中,任何单字符编辑(删除、插入或替换)的最大成本为100,某些编辑(如变换元音)的成本较低。</target>
        </trans-unit>
        <trans-unit id="8f729e8ad1be217b3b85bb1dbd08e4580826f423" translate="yes" xml:space="preserve">
          <source>There is also a new &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; opcode for the &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; that allows an application to query the powersafe overwrite property for a database file.</source>
          <target state="translated">&lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;还有一个新的&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt;操作码，它允许应用程序查询数据库文件的powersafe覆盖属性。</target>
        </trans-unit>
        <trans-unit id="d5d98dc46e0aff9a749813616cdf742a9f8913ea" translate="yes" xml:space="preserve">
          <source>There is also an SQL function that can be used to load extensions: &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension(X,Y)&lt;/a&gt;. It works just like the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; C interface.</source>
          <target state="translated">还有一个SQL函数可用于加载扩展：&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（X，Y）&lt;/a&gt;。它的作用就像&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt; C接口一样。</target>
        </trans-unit>
        <trans-unit id="043cd14b86c980f673cef92a152d79c2c6e3cf2c" translate="yes" xml:space="preserve">
          <source>There is always a default VFS. The legacy interfaces &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; always use the default VFS. The new interface for creating database connections, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, allows you to specify which VFS you want to use by name.</source>
          <target state="translated">始终有一个默认的VFS。旧版接口&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;和&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;始终使用默认VFS。用于创建数据库连接的新接口&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;允许您按名称指定要使用的VFS。</target>
        </trans-unit>
        <trans-unit id="a75d63f61cb222d77eadc6074711ab25e460df12" translate="yes" xml:space="preserve">
          <source>There is always one VFS which is the default VFS. On unix systems, the &quot;unix&quot; VFS comes up as the default and on windows it is &quot;win32&quot;. If no other actions are taken, new database connections will make use of the default VFS.</source>
          <target state="translated">总有一个VFS是默认的VFS。在unix系统中,&quot;unix &quot;VFS是默认的,在windows系统中是 &quot;win32&quot;。如果没有其他操作,新的数据库连接将使用默认的VFS。</target>
        </trans-unit>
        <trans-unit id="a07e87b2dfc85be098248de6c63083968b9cc2a5" translate="yes" xml:space="preserve">
          <source>There is an additional quasi-persistent &quot;&lt;code&gt;-wal&lt;/code&gt;&quot; file and &quot;&lt;code&gt;-shm&lt;/code&gt;&quot; shared memory file associated with each database, which can make SQLite less appealing for use as an &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;.</source>
          <target state="translated">每个数据库都有一个附加的准持久&amp;ldquo; &lt;code&gt;-wal&lt;/code&gt; &amp;rdquo;文件和&amp;ldquo; &lt;code&gt;-shm&lt;/code&gt; &amp;rdquo;共享内存文件，这会使SQLite不太适合用作&lt;a href=&quot;appfileformat&quot;&gt;应用程序文件格式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6c15ef6d2dec509f5afb1c6ad236607cae0e66e0" translate="yes" xml:space="preserve">
          <source>There is an assortment of sqlite3_bind routines used to assign values to wildcards in a prepared SQL statement. Unbound wildcards are interpreted as NULLs. Bindings are not reset by sqlite3_reset(). But wildcards can be rebound to new values after an sqlite3_reset().</source>
          <target state="translated">sqlite3_bind例程的种类繁多,用于在准备好的SQL语句中给通配符赋值。未绑定的通配符被解释为NULLs。sqlite3_reset()不能重置绑定。但是通配符可以在sqlite3_reset()之后被重定向为新的值。</target>
        </trans-unit>
        <trans-unit id="1cba197f7f4cf87333685b6d55dd8ea7d285abdf" translate="yes" xml:space="preserve">
          <source>There is an implied &quot;&lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; 0 0 0&quot; instruction inserted at the very end of every program. So a jump past the last instruction of the program is the same as executing &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt;.</source>
          <target state="translated">在每个程序的末尾都有一条隐含的&amp;ldquo; &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; 0 0 0&amp;rdquo;指令。因此，跳过程序的最后一条指令与执行&lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="16ef4ec82cf13cdae86f5bf01316c19576909f0f" translate="yes" xml:space="preserve">
          <source>There is an unofficial and unsanctioned Git clone of this repository at &lt;a href=&quot;https://github.com/mackyle/sqlite&quot;&gt;https://github.com/mackyle/sqlite&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;https://github.com/mackyle/sqlite&quot;&gt;https://github.com/mackyle/sqlite上&lt;/a&gt;有此存储库的非官方且未经批准的Git克隆。</target>
        </trans-unit>
        <trans-unit id="bea5c372cd0bf0b6a49c619c32079d5921e4aed3" translate="yes" xml:space="preserve">
          <source>There is another, deprecated, method for invoking the optimize operation using a SELECT statement. New code should use statements similar to the INSERT above to optimize FTS structures.</source>
          <target state="translated">还有另一种方法,已被废弃,就是使用SELECT语句来调用优化操作。新的代码应该使用类似于上述INSERT的语句来优化FTS结构。</target>
        </trans-unit>
        <trans-unit id="b085a1ad6ab5d12c0b0eb9f325abf631b21418bf" translate="yes" xml:space="preserve">
          <source>There is no &quot;CREATE TEMP VIRTUAL TABLE&quot; statement. To create a temporary virtual table, add the &quot;temp&quot; schema before the virtual table name.</source>
          <target state="translated">没有 &quot;CREATE TEMP VIRTUAL TABLE &quot;语句。要创建一个临时的虚拟表,在虚拟表名称前添加 &quot;temp &quot;模式。</target>
        </trans-unit>
        <trans-unit id="f17db4bcecd606fe4d51c30c972432fc774cef49" translate="yes" xml:space="preserve">
          <source>There is no RESERVED lock on the corresponding database file.</source>
          <target state="translated">在相应的数据库文件上没有RESOLED锁。</target>
        </trans-unit>
        <trans-unit id="e99ed00de2d6f07769da563a3ed2aa8bf01a7e2e" translate="yes" xml:space="preserve">
          <source>There is no agreement on what the C datatype for a UTF-16 string should be. Therefore, SQLite uses a generic type of void* to refer to UTF-16 strings. Client software can cast the void* to whatever datatype is appropriate for their system.</source>
          <target state="translated">对于UTF-16字符串的C数据类型应该是什么,目前还没有达成一致。因此,SQLite使用一个通用类型的void*来引用UTF-16字符串。客户端软件可以将void*转为任何适合其系统的数据类型。</target>
        </trans-unit>
        <trans-unit id="c505515229e6ccfbb2128baeaa4350ad9e337f7c" translate="yes" xml:space="preserve">
          <source>There is no conflicting row in this case. The results of invoking the sqlite3changeset_conflict() API are undefined.</source>
          <target state="translated">在这种情况下,没有冲突的记录。调用sqlite3changeset_conflict()API的结果是未定义的。</target>
        </trans-unit>
        <trans-unit id="a04b936246a75ee50e5104c87c5e5c3bc05ae139" translate="yes" xml:space="preserve">
          <source>There is no pre-defined release cycle. Releases occur when there is a critical mass of feature enhancements and/or bug fixes. Historically, releases have occurred about 5 or 6 times per year. Users of SQLite pick up new releases from the website on an as-needed basis.</source>
          <target state="translated">没有预先定义的发布周期。当功能增强和/或错误修复达到临界质量时,就会发布。从历史上看,每年大约会发布5到6次。SQLite的用户可以根据需要从网站上获取新版本。</target>
        </trans-unit>
        <trans-unit id="dd71d330015524aacf28e91f9c23458da952387d" translate="yes" xml:space="preserve">
          <source>There is no reserved lock on the main database file.</source>
          <target state="translated">主数据库文件上没有预留锁。</target>
        </trans-unit>
        <trans-unit id="7df732794b7961185fb08c11a413b1539639964a" translate="yes" xml:space="preserve">
          <source>There is no support for &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;. Changes to virtual tables are not captured.</source>
          <target state="translated">不支持&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;。未捕获对虚拟表的更改。</target>
        </trans-unit>
        <trans-unit id="11d7bfeb25e84c6d1e9766a1abf1f94079350c5e" translate="yes" xml:space="preserve">
          <source>There is normally one row per index, with the index identified by the name in the sqlite_stat1.idx column. The sqlite_stat1.tbl column is the name of the table to which the index belongs. In each such row, the sqlite_stat.stat column will be a string consisting of a list of integers followed by zero or more arguments. The first integer in this list is the approximate number of rows in the index. (The number of rows in the index is the same as the number of rows in the table, except for &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;.) The second integer is the approximate number of rows in the index that have the same value in the first column of the index. The third integer is the number number of rows in the index that have the same value for the first two columns. The N-th integer (for N&amp;gt;1) is the estimated average number of rows in the index which have the same value for the first N-1 columns. For a K-column index, there will be K+1 integers in the stat column. If the index is unique, then the last integer will be 1.</source>
          <target state="translated">通常每个索引有一行，该索引由sqlite_stat1.idx列中的名称标识。 sqlite_stat1.tbl列是索引所属的表的名称。在每个此类行中，sqlite_stat.stat列将是一个字符串，其中包含一个整数列表，后跟零个或多个参数。此列表中的第一个整数是索引中的大约行数。 （除&lt;a href=&quot;partialindex&quot;&gt;部分索引&lt;/a&gt;外，索引中的行数与表中的行数相同。）第二个整数是索引中第一行中具有相同值的大约行数。第三个整数是索引中前两列具有相同值的行数。第N个整数（对于N&amp;gt; 1）是索引中对前N-1列具有相同值的估计行平均数。对于K列索引，stat列中将有K + 1个整数。如果索引是唯一的，则最后一个整数将为1。</target>
        </trans-unit>
        <trans-unit id="c9c3e6d9120e8e4bfa41b1d6a3111f7343cb6f19" translate="yes" xml:space="preserve">
          <source>There is now a compile-time option that allows an application to define alternative malloc()/free() implementations without having to modify any core SQLite code.</source>
          <target state="translated">现在有了一个编译时选项,允许应用程序定义替代的malloc()/free()实现,而无需修改任何核心SQLite代码。</target>
        </trans-unit>
        <trans-unit id="f62ae2b58bd448bf76ec1b9c9d9ded56906eaff1" translate="yes" xml:space="preserve">
          <source>There is now a compile-time option that allows an application to define alternative mutex implementations without having to modify any core SQLite code.</source>
          <target state="translated">现在有了一个编译时选项,允许应用程序定义替代的mutex实现,而无需修改任何核心SQLite代码。</target>
        </trans-unit>
        <trans-unit id="b1cb6058c59ace1351641df9e565cb12b51e73fe" translate="yes" xml:space="preserve">
          <source>There is one entry in the %_node table for each R*Tree node. An R*Tree node consists of one or more entries that are proximate to one another. The nodes of an R*Tree for a tree. All nodes other than the root have an entry in the %_parent shadow table that identifies the parent node. Each entry in an R*Tree has a rowid. The %_rowid shadow table maps entry rowids to the node that contains that entry.</source>
          <target state="translated">在%_node表中,每个R*Tree节点都有一个条目。一个R*Tree节点由一个或多个条目组成,这些条目相互之间是近似的。一个R*Tree的节点为一棵树。除根节点外的所有节点在%_parent影子表中都有一个条目,标识父节点。R*Tree中的每个条目都有一个rowid。%_rowid影子表将条目的rowid映射到包含该条目的节点上。</target>
        </trans-unit>
        <trans-unit id="91aa566670abb0466fc190ee57ffd69271a7af7c" translate="yes" xml:space="preserve">
          <source>There is one exception to the previous paragraph: when a row is inserted, updated or deleted, if one or more of its primary key columns contain a NULL value, no record of the change is made.</source>
          <target state="translated">前一段有一个例外:当插入、更新或删除一行时,如果它的一个或多个主键列包含一个NULL值,则不做任何更改记录。</target>
        </trans-unit>
        <trans-unit id="545885bb104866881571615fd910604fef6b0f44" translate="yes" xml:space="preserve">
          <source>There is one important difference between ON UPDATE foreign key actions and SQL triggers. An ON UPDATE action is only taken if the values of the parent key are modified so that the new parent key values are not equal to the old. For example:</source>
          <target state="translated">ON UPDATE外键操作和SQL触发器之间有一个重要的区别。只有当父键的值被修改,使新的父键值不等于旧的父键值时,才会采取ON UPDATE操作。例如</target>
        </trans-unit>
        <trans-unit id="67f4030e1b4840bae9054c024eff72bf5cb42560" translate="yes" xml:space="preserve">
          <source>There is one other subtle difference between &quot;docid&quot; and the normal SQLite aliases for the rowid column. Normally, if an INSERT or UPDATE statement assigns discrete values to two or more aliases of the rowid column, SQLite writes the rightmost of such values specified in the INSERT or UPDATE statement to the database. However, assigning a non-NULL value to both the &quot;docid&quot; and one or more of the SQLite rowid aliases when inserting or updating an FTS table is considered an error. See below for an example.</source>
          <target state="translated">在 &quot;docid &quot;和普通SQLite对rowid列的别名之间还有一个微妙的区别。通常情况下,如果一条INSERT或UPDATE语句给rowid列的两个或多个别名分配了离散的值,SQLite会将INSERT或UPDATE语句中指定的这些值中最右边的一个写入数据库。然而,当插入或更新一个FTS表时,给 &quot;docid &quot;和一个或多个SQLite rowid别名分配一个非NULL值被认为是一个错误。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="f856aedc1ad69cfc42357d4bdb200682208f50ab" translate="yes" xml:space="preserve">
          <source>There is only one sorter object, so there are no instructions to open or close it. It is opened automatically when needed, and it is closed when the VDBE program halts.</source>
          <target state="translated">只有一个分拣机对象,所以没有打开或关闭它的指令。需要时自动打开,VDBE程序停止时关闭。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
