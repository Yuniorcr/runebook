<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="bee285158d4476d2f4cfb28e9d58a1b17557c72d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/next_stmt&quot;&gt;sqlite3_next_stmt()&lt;/a&gt; interface allows an application to discover all &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;c3ref/next_stmt&quot;&gt;sqlite3_next_stmt（）&lt;/a&gt;接口允许应用程序发现所有&lt;a href=&quot;c3ref/stmt&quot;&gt;准备的语句&lt;/a&gt;与一个相关联的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4b81e52f97bf4ca16a0cbc294595c0b869e9c9c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and related interfaces act as a compiler for converting SQL text into bytecode. The &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object is a container for a single bytecode program that implements a single SQL statement. The &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface passes a bytecode program into the virtual machine, and runs the program until it either completes, or forms a row of result to be returned, or hits a fatal error, or is &lt;a href=&quot;c3ref/interrupt&quot;&gt;interrupted&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;和相关接口充当SQL文本转换成字节码编译器。该&lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;对象是单字节码程序实现一个SQL语句的容器。的&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;接口传递一个字节码程序到虚拟机，并运行该程序，直到其完成，或将要返回的结果的行的形式，或命中了致命错误，或者被&lt;a href=&quot;c3ref/interrupt&quot;&gt;中断&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab075f99c29f68391431d9855c2d09e8ff55b4eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and related interfaces act as a compiler for converting SQL text into bytecode. The &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object is a container for a single bytecode program using to implement a single SQL statement. The &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface passes a bytecode program into the virtual machine, and runs the program until it either completes, or forms a row of result to be returned, or hits a fatal error, or is &lt;a href=&quot;c3ref/interrupt&quot;&gt;interrupted&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;和相关接口充当SQL文本转换成字节码编译器。该&lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;对象是使用实行单一SQL语句的单个字节码程序的容器。的&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;接口传递一个字节码程序到虚拟机，并运行该程序，直到其完成，或将要返回的结果的行的形式，或命中了致命错误，或者被&lt;a href=&quot;c3ref/interrupt&quot;&gt;中断&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f760f8c540dcc654012aa0be1cef03e69842a01e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; interface creates a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; that will automatically recompile itself if the schema changes. The easiest way to deal with &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; errors is to always use &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; instead of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;接口创建一个&lt;a href=&quot;c3ref/stmt&quot;&gt;事先准备好的声明&lt;/a&gt;，如果模式改变，它会自动重新编译自己。处理&lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt;错误的最简单方法是始终使用&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;而不是&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3cb166cb387770ce5ad92997ed9078bd0c5b5827" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_profile()&lt;/a&gt; callback is invoked (by &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;) for statements that did not run to completion.</source>
          <target state="translated">对于未运行完成的语句，调用&lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_profile（）&lt;/a&gt;回调（由&lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;或&lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c86c0301bb7f9f1fb47baffd646cd224ccc8e2ac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface will now attempt to reduce the memory usages across all database connections in all threads, not just connections in the thread where the interface is called.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory（）&lt;/a&gt;接口现在试图减少在所有数据库连接的存储器使用量中的所有线程，不只是在线程在接口被称为连接。</target>
        </trans-unit>
        <trans-unit id="049881541bf38acf3045d3cb673c48aa92e47dd3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt;, &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt;, and &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; interfaces now work cross all threads in the process, not just the single thread in which they are invoked. *** Potentially incompatible change ***</source>
          <target state="translated">现在，&lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory（）&lt;/a&gt;，&lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit（）&lt;/a&gt;和&lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）&lt;/a&gt;接口可跨进程中的所有线程工作，而不仅仅是在其中调用它们的单个线程。***可能不兼容的更改***</target>
        </trans-unit>
        <trans-unit id="a58543f2b7ba8e8bf7e29c328f9ab5da7da2ea1b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result() family of functions&lt;/a&gt; are used to specify the result of the scalar SQL function. One or more of these should be invoked by the callback to set the function return value. If none of these routines are invoked for a specific callback, then the return value will be NULL.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result（）系列函数&lt;/a&gt;用于指定的标量SQL函数的结果。回调应调用其中的一个或多个来设置函数的返回值。如果没有为特定的回调调用这些例程，则返回值为NULL。</target>
        </trans-unit>
        <trans-unit id="af837a86c1e38824ef1d301d32834ef9f9b670f7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer callback&lt;/a&gt; is invoked regardless of the presence of EXPLAIN or EXPLAIN QUERY PLAN.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;授权回调&lt;/a&gt;调用不管EXPLAIN或解释查询计划的存在下进行。</target>
        </trans-unit>
        <trans-unit id="af9451c90d2dee9cf3e529bb13a675b0008b0a17" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; interface now applies to all threads within a process, not to just the one thread in which it was run.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit（）&lt;/a&gt;接口现在适用于所有线程的过程中，不只是在它被运行一个线程。</target>
        </trans-unit>
        <trans-unit id="527b7feeedc271730252349576ab47baa1d727e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; interface works by registering a memory alarm at the soft heap limit and invoking &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; in the alarm callback. Application programs should not attempt to use the &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm()&lt;/a&gt; interface because doing so will interfere with the &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; module. This interface is exposed only so that applications can provide their own alternative implementation when the SQLite core is compiled with &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit（）&lt;/a&gt;接口的工作原理是在软堆限制登记存储器报警和调用&lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory（）&lt;/a&gt;在报警回调。应用程序不应尝试使用&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm（）&lt;/a&gt;接口，因为这样做会干扰&lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit（）&lt;/a&gt;模块。仅公开此接口，以便在使用&lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt;编译SQLite核心时，应用程序可以提供其自己的替代实现。</target>
        </trans-unit>
        <trans-unit id="b1ed21e10553df3077d02ccee7e2ab02fc21afc9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface can be used to set an upper bound on the total amount of outstanding memory that the general-purpose memory allocator for SQLite will allow to be outstanding at one time. If attempts are made to allocate more memory than specified by the soft heap limit, then SQLite will first attempt to free cache memory before continuing with the allocation request. The soft heap limit mechanism only works if &lt;a href=&quot;malloc#memstatus&quot;&gt;memory statistics&lt;/a&gt; are enabled and it works best if the SQLite library is compiled with the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option.</source>
          <target state="translated">所述&lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64（）&lt;/a&gt;接口可用于设置上界未完成的存储器的总量，对于SQLite的通用内存分配器将允许一次未完成的。如果尝试分配的内存超出了软堆限制所指定的数量，则SQLite将首先尝试释放缓存，然后再继续分配请求。软堆限制机制仅在启用了&lt;a href=&quot;malloc#memstatus&quot;&gt;内存统计信息的&lt;/a&gt;情况下才有效，并且如果使用&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;编译时选项编译SQLite库，则其效果最佳。</target>
        </trans-unit>
        <trans-unit id="1eb6a622a1771cf9ae256233e2fb0c463ea616f9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects are controlled by a small set of C/C++ interface routine listed below.</source>
          <target state="translated">的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;和&lt;a href=&quot;c3ref/stmt&quot;&gt;准备的语句&lt;/a&gt;的目的是通过一小的C / C ++接口例程的下列控制。</target>
        </trans-unit>
        <trans-unit id="5466713b299a5e73e4a0863d52f92664bc3844c8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; object: sqlite3</source>
          <target state="translated">该&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;对象：sqlite3的</target>
        </trans-unit>
        <trans-unit id="1c3b251682ed613e33db0de124845adce3edbb1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; that is running the VACUUM INTO statement was originally opened using the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag.</source>
          <target state="translated">最初使用&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;标志打开了运行VACUUM INTO语句的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="79e9d37ccb6719391098f5d43ea1dcd316705462" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object: sqlite3_stmt</source>
          <target state="translated">将&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;对象：sqlite3_stmt</target>
        </trans-unit>
        <trans-unit id="cbcb829701917628eb2fd7b1899f66a93be104f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; C/C++ interface together with the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusfullscanstep&quot;&gt;SQLITE_STMTSTATUS_FULLSCAN_STEP&lt;/a&gt; and &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatussort&quot;&gt;SQLITE_STMTSTATUS_SORT&lt;/a&gt; verbs can be used to detect at run-time when an SQL statement is not making effective use of indices. Many applications may prefer to use the &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; interface to detect index misuse rather than the INDEXED BY phrase described here.</source>
          <target state="translated">所述&lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status（）&lt;/a&gt; C / C ++接口与一起&lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusfullscanstep&quot;&gt;SQLITE_STMTSTATUS_FULLSCAN_STEP&lt;/a&gt;和&lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatussort&quot;&gt;SQLITE_STMTSTATUS_SORT&lt;/a&gt;动词可用于在运行时，以检测当一个SQL语句未有效地利用索引。许多应用程序可能更喜欢使用&lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status（）&lt;/a&gt;接口来检测索引滥用，而不是使用此处描述的INDEXED BY短语。</target>
        </trans-unit>
        <trans-unit id="d3e46371f36d9155345020a6a81ffaba033339b8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/table_column_metadata&quot;&gt;sqlite3_table_column_metadata()&lt;/a&gt; is enhanced to work correctly on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables and to check for the existence of a a table if the column name parameter is NULL. The interface is now also included in the build by default, without requiring the &lt;a href=&quot;compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; compile-time option.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/table_column_metadata&quot;&gt;sqlite3_table_column_metadata（）&lt;/a&gt;得到了增强，在正常工作&lt;a href=&quot;withoutrowid&quot;&gt;无ROWID&lt;/a&gt;表和检查表AA的存在，如果列名参数为NULL。现在，默认情况下该接口也包含在构建中，而无需使用&lt;a href=&quot;compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt;编译时选项。</target>
        </trans-unit>
        <trans-unit id="edc8c97e4cc1a5aa05b289505090d5b34bad9902" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_OPTIMIZATIONS&lt;/a&gt;, ...) interface allows selected SQL statement optimizations to be disabled at run-time. SQLite should always generate exactly the same answer with optimizations enabled and with optimizations disabled; the answer simply arrives quicker with the optimizations turned on. So in a production environment, one always leaves the optimizations turned on (the default setting).</source>
          <target state="translated">该&lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt;（&lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_OPTIMIZATIONS&lt;/a&gt;，...）接口允许选择SQL语句的优化，以在运行时被禁用。在启用优化和禁用优化的情况下，SQLite应始终生成完全相同的答案。启用优化后，答案很快就会到达。因此，在生产环境中，始终使优化处于打开状态（默认设置）。</target>
        </trans-unit>
        <trans-unit id="43fd3a5c9f7460ba2ff5df434fcffaa34616785e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; output for nested SQL statements should always begin with a &quot;--&quot; comment marker.</source>
          <target state="translated">嵌套SQL语句的&lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;输出应始终以&amp;ldquo;-&amp;rdquo;注释标记开头。</target>
        </trans-unit>
        <trans-unit id="19462b9c93da59d00cf4ac09d7e75c3130b9c27d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; API, which is only available if the library is compiled with the pre-processor symbol &lt;a href=&quot;compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/a&gt; defined, is &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;documented here&lt;/a&gt;. This article is not a substitute for reading the full API documentation!</source>
          <target state="translated">所述&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt; API，如果库与所述预处理器符号编译这是唯一可用的&lt;a href=&quot;compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/a&gt;所定义的，&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;记录在这里&lt;/a&gt;。本文不能代替阅读完整的API文档！</target>
        </trans-unit>
        <trans-unit id="3e8d6caa4b5453ea5545263fa9616b15bb0d4f1e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface is designed for use in systems that have a separate thread assigned to each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. There is nothing in the implementation that prevents a single thread from running multiple database connections. However, the &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface only works on a single connection at a time, so the lock resolution logic presented here will only work for a single database connection per thread.</source>
          <target state="translated">所述&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;接口被设计为在具有分配给每个单独的线程系统中使用的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;。在实现中，没有什么可以阻止单个线程运行多个数据库连接。但是，&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;接口一次只能在单个连接上工作，因此此处介绍的锁解析逻辑仅对每个线程一个数据库连接有效。</target>
        </trans-unit>
        <trans-unit id="1d6fc659db0d56afaed258d4fdfa842c7a2494e0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/update_hook&quot;&gt;update hook&lt;/a&gt; is not invoked for rows that are deleted by the REPLACE conflict resolution strategy. Nor does REPLACE increment the &lt;a href=&quot;c3ref/changes&quot;&gt;change counter&lt;/a&gt;. The exceptional behaviors defined in this paragraph might change in a future release.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/update_hook&quot;&gt;更新挂钩&lt;/a&gt;，则不会调用该由REPLACE冲突解决策略删除的行。REPLACE也不会增加&lt;a href=&quot;c3ref/changes&quot;&gt;更改计数器&lt;/a&gt;。本段中定义的异常行为可能会在将来的版本中更改。</target>
        </trans-unit>
        <trans-unit id="174d9ce4b7cba75823debe78170b5d882dfa96e7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt; routine returns a copy of the &lt;b&gt;pArg&lt;/b&gt; pointer that was given to &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; when the SQL function was created.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/user_data&quot;&gt;sqlite3_user_data（）&lt;/a&gt;例程返回的副本&lt;b&gt;PARG&lt;/b&gt;这是给指针&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;时创建的SQL函数。</target>
        </trans-unit>
        <trans-unit id="50634212838ce725193912da3e909e9a53b3f585" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; API is used to locate a particular VFS by name. Its prototype is as follows:</source>
          <target state="translated">所述&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find（）&lt;/a&gt; API用于通过名称查找特定VFS。其原型如下：</target>
        </trans-unit>
        <trans-unit id="cd79207584e9ef224be15cf9411b2100d6ae0c32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_unregister()&lt;/a&gt; API is used to remove an existing VFS from the system.</source>
          <target state="translated">所述&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_unregister（）&lt;/a&gt; API用于从系统中删除现有的VFS。</target>
        </trans-unit>
        <trans-unit id="ca7466f7f648f5cd0c7b32027691a4626bfd37a6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; structure represents a pointer to a specific row of a virtual table. This is what an sqlite3_vtab_cursor looks like:</source>
          <target state="translated">该&lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt;结构表示一个指向虚拟表的特定行。这是sqlite3_vtab_cursor的样子：</target>
        </trans-unit>
        <trans-unit id="7da2c1fa98bb7a679ac7ffc72d14de8a7e2722aa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connection's busy-handler callback. The argument is of type (void**) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connection's busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.</source>
          <target state="translated">该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt;文件控制可通过SQLite的它是为了提供一个自定义的VFS能够访问连接繁忙的处理程序回调打开后不久，数据库文件句柄调用。参数的类型为（void **）-两个（void *）值的数组。第一个（void *）实际上指向类型为（int（*）（void *））的函数。为了调用连接的busy-handler，应使用数组中的第二个（void *）作为唯一参数来调用此函数。如果返回非零值，则应重试该操作。如果返回零，则自定义VFS应该放弃当前操作。</target>
        </trans-unit>
        <trans-unit id="405e780a5eda0077cf02e3ce6060be9576266571" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connections busy-handler callback. The argument is of type (void **) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connections busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.</source>
          <target state="translated">该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt;文件控制可通过SQLite的它是为了提供一个自定义的VFS能够访问连接忙处理程序回调打开后不久，数据库文件句柄调用。参数的类型为（void **）-两个（void *）值的数组。第一个（void *）实际上指向类型为（int（*）（void *））的函数。为了调用连接busy-handler，应使用数组中的第二个（void *）作为唯一参数来调用此函数。如果返回非零值，则应重试该操作。如果返回零，则自定义VFS应该放弃当前操作。</target>
        </trans-unit>
        <trans-unit id="c09f9898013c2f2b9084c257d373e6d8fb8e1f1d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlchunksize&quot; id=&quot;sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZE&lt;/a&gt; opcode is used to request that the VFS extends and truncates the database file in chunks of a size specified by the user. The fourth argument to &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; should point to an integer (type int) containing the new chunk-size to use for the nominated database. Allocating database file space in large chunks (say 1MB at a time), may reduce file-system fragmentation and improve performance on some systems.</source>
          <target state="translated">所述&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlchunksize&quot; id=&quot;sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZE&lt;/a&gt;操作码被用来请求该VFS延伸并截断在由用户指定的尺寸的块中的数据库文件。&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;的第四个参数应指向一个整数（类型为int），该整数包含要用于提名数据库的新块大小。将数据库文件空间大块地分配（例如一次分配1MB）可以减少文件系统的碎片并提高某些系统上的性能。</target>
        </trans-unit>
        <trans-unit id="2724ba1a9151f430bfc44ff351307f4c931e3d2e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlckptdone&quot; id=&quot;sqlitefcntlckptdone&quot;&gt;SQLITE_FCNTL_CKPT_DONE&lt;/a&gt; opcode is invoked from within a checkpoint in wal mode after the client has finished copying pages from the wal file to the database file, but before the *-shm file is updated to record the fact that the pages have been checkpointed.</source>
          <target state="translated">该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlckptdone&quot; id=&quot;sqlitefcntlckptdone&quot;&gt;SQLITE_FCNTL_CKPT_DONE&lt;/a&gt;操作码是从沃尔玛模式检查点的客户端从沃尔玛文件到数据库文件复制完成后的页面中调用，但* -shm文件被更新，以记录的网页已设置检查点的事实面前。</target>
        </trans-unit>
        <trans-unit id="e6b7ae020cfbad6284212ff443474df4c8cbc164" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlckptstart&quot; id=&quot;sqlitefcntlckptstart&quot;&gt;SQLITE_FCNTL_CKPT_START&lt;/a&gt; opcode is invoked from within a checkpoint in wal mode before the client starts to copy pages from the wal file to the database file.</source>
          <target state="translated">该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlckptstart&quot; id=&quot;sqlitefcntlckptstart&quot;&gt;SQLITE_FCNTL_CKPT_START&lt;/a&gt;客户端开始从沃尔玛文件到数据库文件复制页面之前操作码是从沃尔玛模式关卡中调用。</target>
        </trans-unit>
        <trans-unit id="563228c7f58e18a697dff44f98d2797b60b51628" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot; id=&quot;sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be performed atomically. This file control returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if and only if the writes were all performed successfully and have been committed to persistent storage. Regardless of whether or not it is successful, this file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_COMMIT_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot; id=&quot;sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;操作码会导致所有的写操作，因为以前的成功调用&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;以原子执行。当且仅当所有写入均已成功执行且已提交到持久性存储时，此文件控件才返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。无论是否成功，此文件控件都会使文件描述符脱离批写模式，因此所有后续写操作都是独立的。如果没有事先成功调用SQLITE_FCNTL_BEGIN_ATOMIC_WRITE，SQLite将永远不会调用&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="78b45f1d52cb17aec209a2fdf03a83375e0b951e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitphasetwo&quot; id=&quot;sqlitefcntlcommitphasetwo&quot;&gt;SQLITE_FCNTL_COMMIT_PHASETWO&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS after a transaction has been committed immediately but before the database is unlocked. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitphasetwo&quot; id=&quot;sqlitefcntlcommitphasetwo&quot;&gt;SQLITE_FCNTL_COMMIT_PHASETWO&lt;/a&gt;操作码SQLite内部生成并发送至VFS之后事务已立即提交，但数据库被解锁之前。不需要此信号的VFS应静默忽略此操作码。应用程序不应使用此操作码调用&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;，因为这样做可能会破坏需要它的专用VFS的运行。</target>
        </trans-unit>
        <trans-unit id="fe01cd54971699e5fe35af1a0adc94faad95fbe1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The &quot;data version&quot; for the pager is written into the pointer. The &quot;data version&quot; changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface responds to internal changes only and omits changes made by other database connections. The &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command provide a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.</source>
          <target state="translated">该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt;操作码用以检测更改的数据库文件。该参数是一个指向32位无符号整数的指针。寻呼机的&amp;ldquo;数据版本&amp;rdquo;被写入指针。每当对相应的数据库文件进行任何更改时，&amp;ldquo;数据版本&amp;rdquo;都会更改，或者通过同一数据库连接上的SQL语句，或者通过可能在其他进程中由单独的数据库连接提交的事务来更改。该&lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;接口，可用于查找如果连接上的任何数据库已更改，但是该接口响应在TEMP变化以及主并没有提供一种机制来检测对仅MAIN。另外，&lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;接口仅响应内部更改，而忽略其他数据库连接所做的更改。的&lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt;命令提供一种机制来检测变化的发生是由于其他数据库连接的单个附加的数据库，但是省略通过改变在其上它被称为数据库连接实现。此文件控件是检测内部或外部发生的更改以及与特定附加数据库关联的更改的唯一机制。</target>
        </trans-unit>
        <trans-unit id="429853e91982da517f099946a428569f5a10010d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The &quot;data version&quot; for the pager is written into the pointer. The &quot;data version&quot; changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface responds to internal changes only and omits changes made by other database connections. The &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command provides a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.</source>
          <target state="translated">该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt;操作码用以检测更改的数据库文件。该参数是指向32位无符号整数的指针。寻呼机的&amp;ldquo;数据版本&amp;rdquo;被写入指针。每当对相应的数据库文件进行任何更改时，&amp;ldquo;数据版本&amp;rdquo;都会更改，或者通过同一数据库连接上的SQL语句，或者通过可能在其他进程中由单独的数据库连接提交的事务来更改。该&lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;接口，可用于查找如果连接上的任何数据库已更改，但是该接口响应在TEMP变化以及主并没有提供一种机制来检测对仅MAIN。另外，&lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;接口仅响应内部更改，而忽略其他数据库连接所做的更改。的&lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt;命令提供了一种机制来检测变化的发生是由于其他数据库连接的单个附加的数据库，但是省略通过改变在其上它被称为数据库连接实现。此文件控件是检测内部或外部发生的更改以及与特定附加数据库关联的更改的唯一机制。</target>
        </trans-unit>
        <trans-unit id="0e0a05c22977d8b1dc9945aac16fc4626f1dd660" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot; id=&quot;sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with a particular database connection. See also &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot; id=&quot;sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt;操作码被用来获得一个指针&lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt;与特定的数据库连接相关联的对象。另请参见&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ddddd8caea4f2699898b48925bf95b8d69764816" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlhasmoved&quot; id=&quot;sqlitefcntlhasmoved&quot;&gt;SQLITE_FCNTL_HAS_MOVED&lt;/a&gt; file control interprets its argument as a pointer to an integer and it writes a boolean into that integer depending on whether or not the file has been renamed, moved, or deleted since it was first opened.</source>
          <target state="translated">所述&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlhasmoved&quot; id=&quot;sqlitefcntlhasmoved&quot;&gt;SQLITE_FCNTL_HAS_MOVED&lt;/a&gt;文件控制解释它的参数的指针为一个整数，并将其写入一个布尔值到根据文件是否不是整数已被重命名，移动或删除，因为它第一次打开。</target>
        </trans-unit>
        <trans-unit id="bc589731780274c54e5cd365284382cd5887eded" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot; id=&quot;sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with the journal file (either the &lt;a href=&quot;../lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; or the &lt;a href=&quot;../wal&quot;&gt;write-ahead log&lt;/a&gt;) for a particular database connection. See also &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot; id=&quot;sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt;操作码被用来获得一个指针&lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt;与轴颈文件（或者相关联的对象&lt;a href=&quot;../lockingv3#rollback&quot;&gt;回滚日志&lt;/a&gt;或&lt;a href=&quot;../wal&quot;&gt;预写日志&lt;/a&gt;特定数据库连接）。另请参见&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5d8ff8dd3d322caf95cdc56c272ff4998cee7a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot; id=&quot;sqlitefcntllockstate&quot;&gt;SQLITE_FCNTL_LOCKSTATE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to write the current state of the lock (one of &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt;, &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;, &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt;, &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt;, or &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt;) into an integer that the pArg argument points to. This capability is used during testing and is only available when the SQLITE_TEST compile-time option is used.</source>
          <target state="translated">该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot; id=&quot;sqlitefcntllockstate&quot;&gt;SQLITE_FCNTL_LOCKSTATE&lt;/a&gt;操作码用于调试。此操作码使xFileControl方法将锁的当前状态（&lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt;，&lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;，&lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt;，&lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt;或&lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE之一&lt;/a&gt;）写入pArg参数指向的整数。此功能在测试期间使用，并且仅在使用SQLITE_TEST编译时选项时可用。</target>
        </trans-unit>
        <trans-unit id="835bd4a6a4daee4b5c892d531fad550f3b7944bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; opcode causes attempts to obtain a file lock using the xLock or xShmLock methods of the VFS to wait for up to M milliseconds before failing, where M is the single unsigned integer parameter.</source>
          <target state="translated">所述&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt;操作码会导致尝试获得使用VFS的XLOCK或xShmLock方法等待多达M个毫秒失败，其中M是单个的无符号整数的参数前的文件锁。</target>
        </trans-unit>
        <trans-unit id="f76db0b59ac49aa27a2ffafc1d9d0b7df64c41cd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; opcode is used to configure a VFS to block for up to M milliseconds before failing when attempting to obtain a file lock using the xLock or xShmLock methods of the VFS. The parameter is a pointer to a 32-bit signed integer that contains the value that M is to be set to. Before returning, the 32-bit signed integer is overwritten with the previous value of M.</source>
          <target state="translated">所述&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt;操作码用于配置一个VFS到块多达M个毫秒试图获得使用VFS的XLOCK或xShmLock方法文件锁时失效之前。该参数是指向32位带符号整数的指针，该整数包含M设置为的值。返回之前，32位带符号整数将被先前的M值覆盖。</target>
        </trans-unit>
        <trans-unit id="9534ed4df1d95266c96610467198479542d6649c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlmmapsize&quot; id=&quot;sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt; file control is used to query or set the maximum number of bytes that will be used for memory-mapped I/O. The argument is a pointer to a value of type sqlite3_int64 that is an advisory maximum number of bytes in the file to memory map. The pointer is overwritten with the old value. The limit is not changed if the value originally pointed to is negative, and so the current limit can be queried by passing in a pointer to a negative number. This file-control is used internally to implement &lt;a href=&quot;../pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlmmapsize&quot; id=&quot;sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt;文件控制用于查询或设置将被用于的最大字节数目的存储器映射I / O。该参数是一个指向sqlite3_int64类型的值的指针，该值是文件到内存映射中建议的最大字节数。指针将被旧值覆盖。如果最初指向的值是负数，则限制不会更改，因此可以通过将指针传递给负数来查询当前限制。此文件控件在内部用于实现&lt;a href=&quot;../pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="85959ccb42981e5ee3527aa791391f6482ac784e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntloverwrite&quot; id=&quot;sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITE&lt;/a&gt; opcode is invoked by SQLite after opening a write transaction to indicate that, unless it is rolled back for some reason, the entire database file will be overwritten by the current transaction. This is used by VACUUM operations.</source>
          <target state="translated">该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntloverwrite&quot; id=&quot;sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITE&lt;/a&gt;操作码被打开的SQLite写事务，以表明，除非它被回退由于某些原因后调用，整个数据库文件将被覆盖当前事务。 VACUUM操作使用它。</target>
        </trans-unit>
        <trans-unit id="d2750128ef1083c346294ef6e3be361e6eba77af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot; id=&quot;sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; opcode is used to set or query the persistent &lt;a href=&quot;../wal&quot;&gt;Write Ahead Log&lt;/a&gt; setting. By default, the auxiliary write ahead log (&lt;a href=&quot;../wal#walfile&quot;&gt;WAL file&lt;/a&gt;) and shared memory files used for transaction control are automatically deleted when the latest connection to the database closes. Setting persistent WAL mode causes those files to persist after close. Persisting the files is useful when other processes that do not have write permission on the directory containing the database file want to read the database file, as the WAL and shared memory files must exist in order for the database to be readable. The fourth parameter to &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable persistent WAL mode or 1 to enable persistent WAL mode. If the integer is -1, then it is overwritten with the current WAL persistence setting.</source>
          <target state="translated">该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot; id=&quot;sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;操作码是用来设置或查询持续&lt;a href=&quot;../wal&quot;&gt;预写日志&lt;/a&gt;设置。默认情况下，与数据库的最新连接关闭时，将自动删除用于事务控制的辅助&lt;a href=&quot;../wal#walfile&quot;&gt;预&lt;/a&gt;写日志（WAL文件）和共享内存文件。设置持久性WAL模式会导致这些文件在关闭后继续存在。当对包含数据库文件的目录没有写权限的其他进程想要读取数据库文件时，持久保留文件非常有用，因为必须存在WAL和共享内存文件才能使数据库可读。&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;的第四个参数这个操作码应该是一个指向整数的指针。该整数是0以禁用持久WAL模式，或为1以启用持久WAL模式。如果整数为-1，则将使用当前的WAL持久性设置覆盖它。</target>
        </trans-unit>
        <trans-unit id="e3329771b09c8d9c17e5ba63393baaa851477f87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot; id=&quot;sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; opcode is used to set or query the persistent &quot;powersafe-overwrite&quot; or &quot;PSOW&quot; setting. The PSOW setting determines the &lt;a href=&quot;c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; bit of the xDeviceCharacteristics methods. The fourth parameter to &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable zero-damage mode or 1 to enable zero-damage mode. If the integer is -1, then it is overwritten with the current zero-damage mode setting.</source>
          <target state="translated">该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot; id=&quot;sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt;操作码是用来设置或查询老大难&amp;ldquo;powersafe重写&amp;rdquo;或&amp;ldquo;PSOW&amp;rdquo;设置。PSOW设置确定xDeviceCharacteristics方法的&lt;a href=&quot;c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt;位。此操作码的&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;的第四个参数应为指向整数的指针。该整数是0以禁用零损坏模式，或为1以启用零损坏模式。如果整数为-1，则将使用当前的零损坏模式设置覆盖它。</target>
        </trans-unit>
        <trans-unit id="b7ebc915c79af1c389d3c702e8a0e217f15cd6b6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrbu&quot; id=&quot;sqlitefcntlrbu&quot;&gt;SQLITE_FCNTL_RBU&lt;/a&gt; opcode is implemented by the special VFS used by the RBU extension only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="translated">该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrbu&quot; id=&quot;sqlitefcntlrbu&quot;&gt;SQLITE_FCNTL_RBU&lt;/a&gt;操作码是由只有RBU扩展使用了特殊的VFS实现。所有其他VFS应该为此操作码返回SQLITE_NOTFOUND。</target>
        </trans-unit>
        <trans-unit id="d7a6279d094b2efb4418d75c6d39f8cf80f5db9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot; id=&quot;sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be rolled back. This file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot; id=&quot;sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt;操作码会导致所有的写操作，因为以前的成功调用&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;回滚。此文件控件使文件描述符脱离批写模式，因此所有后续写操作都是独立的。如果没有事先成功调用SQLITE_FCNTL_BEGIN_ATOMIC_WRITE，SQLite将永远不会调用&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="37dec85b72b827823523f2dbeaab4ae1365e897b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot; id=&quot;sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt; opcode is used by SQLite to give the VFS layer a hint of how large the database file will grow to be during the current transaction. This hint is not guaranteed to be accurate but it is often close. The underlying VFS might choose to preallocate database file space based on this hint in order to help writes to the database file run faster.</source>
          <target state="translated">该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot; id=&quot;sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt;操作码使用的SQLite给予VFS层的数据库文件将如何大发展是当前交易中的提示。此提示不能保证准确，但通常很接近。底层VFS可能会基于此提示选择预分配数据库文件空间，以帮助更快地写入数据库文件。</target>
        </trans-unit>
        <trans-unit id="53dec04041f2a1cd0f5d61ecfdd7363482736f2d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot; id=&quot;sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt; opcode is used by in-memory VFS that implements &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; to set an upper bound on the size of the in-memory database. The argument is a pointer to a &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt;. If the integer pointed to is negative, then it is filled in with the current limit. Otherwise the limit is set to the larger of the value of the integer pointed to and the current database size. The integer pointed to is set to the new limit.</source>
          <target state="translated">所述&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot; id=&quot;sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt;操作码所使用的内存VFS实现&lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize（）&lt;/a&gt;来设置上界内存数据库的大小。该参数是一个指向&lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt;的指针。如果所指向的整数是负数，则将其填充为当前限制。否则，将限制设置为所指向的整数的值和当前数据库大小中的较大者。指向的整数设置为新的限制。</target>
        </trans-unit>
        <trans-unit id="5eb8033743ca0212b9de7ee6d6d452df418e67e7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions master-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">所述&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt;操作码SQLite内部产生并立即XSYNC方法上的数据库文件描述符调用之前发送到VFS。或者，如果未调用xSync方法，因为用户已使用PRAGMAynchronous &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;= OFF&lt;/a&gt;配置了SQLite，则它将代替xSync方法被调用。在大多数情况下，与此文件控件一起传递的指针参数为NULL。但是，如果将数据库文件作为多数据库提交的一部分进行同步，则该参数指向一个以空字符结尾的字符串，其中包含事务主日志文件名。不需要此信号的VFS应静默忽略此操作码。应用程序不应调用&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt; 这样做可能会破坏需要它的专用VFS的运行。</target>
        </trans-unit>
        <trans-unit id="ca40036ed80ac456626498e6b097f64ffd5f3c6f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions super-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">所述&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt;操作码SQLite内部产生并立即XSYNC方法上的数据库文件描述符调用之前发送到VFS。或者，如果未调用xSync方法，因为用户已使用PRAGMAynchronous &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;= OFF&lt;/a&gt;配置了SQLite，则它将代替xSync方法被调用。在大多数情况下，与此文件控件一起传递的指针参数为NULL。但是，如果数据库文件作为多数据库提交的一部分进行同步，则该参数指向一个以nul终止的字符串，其中包含事务超级日志文件名。不需要此信号的VFS应静默忽略此操作码。应用程序不应调用&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt; 这样做可能会破坏确实需要它的专用VFS的运行。</target>
        </trans-unit>
        <trans-unit id="df5b82162695e993bb266a9bcb74822b0cb0729d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntltrace&quot; id=&quot;sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE&lt;/a&gt; file control provides advisory information to the VFS about what the higher layers of the SQLite stack are doing. This file control is used by some VFS activity tracing &lt;a href=&quot;../vfs#shim&quot;&gt;shims&lt;/a&gt;. The argument is a zero-terminated string. Higher layers in the SQLite stack may generate instances of this file control if the &lt;a href=&quot;../compile#use_fcntl_trace&quot;&gt;SQLITE_USE_FCNTL_TRACE&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntltrace&quot; id=&quot;sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE&lt;/a&gt;文件控制提供咨询信息，以什么SQLite的栈的高层正在做的VFS。一些VFS活动跟踪&lt;a href=&quot;../vfs#shim&quot;&gt;补片&lt;/a&gt;使用此文件控件。参数是一个以零结尾的字符串。如果启用了&lt;a href=&quot;../compile#use_fcntl_trace&quot;&gt;SQLITE_USE_FCNTL_TRACE&lt;/a&gt;编译时选项，则SQLite堆栈中的较高层可能会生成此文件控件的实例。</target>
        </trans-unit>
        <trans-unit id="dc747f657ceac57a6b93ab7190def0e8a928303d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfsname&quot; id=&quot;sqlitefcntlvfsname&quot;&gt;SQLITE_FCNTL_VFSNAME&lt;/a&gt; opcode can be used to obtain the names of all &lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; in the VFS stack. The names are of all VFS shims and the final bottom-level VFS are written into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and the result is stored in the char* variable that the fourth parameter of &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; points to. The caller is responsible for freeing the memory when done. As with all file-control actions, there is no guarantee that this will actually do anything. Callers should initialize the char* variable to a NULL pointer in case this file-control is not implemented. This file-control is intended for diagnostic use only.</source>
          <target state="translated">该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfsname&quot; id=&quot;sqlitefcntlvfsname&quot;&gt;SQLITE_FCNTL_VFSNAME&lt;/a&gt;操作码可用于获取所有的名字&lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt;在VFS栈。名称是所有VFS填充的名称，最终的底层VFS将写入从&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;获得的内存中，并将结果存储在&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;的第四个参数指向的char *变量中。完成后，调用方负责释放内存。与所有文件控制操作一样，不能保证此操作实际上会做任何事情。如果未实现此文件控件，则调用者应将char *变量初始化为NULL指针。此文件控件仅用于诊断用途。</target>
        </trans-unit>
        <trans-unit id="8a271c98ba50f856db7d26935d70d5164c6f00e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfspointer&quot; id=&quot;sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt; opcode finds a pointer to the top-level &lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; currently in use. The argument X in sqlite3_file_control(db,SQLITE_FCNTL_VFS_POINTER,X) must be of type &quot;&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; **&quot;. This opcodes will set *X to a pointer to the top-level VFS. When there are multiple VFS shims in the stack, this opcode finds the upper-most shim only.</source>
          <target state="translated">该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfspointer&quot; id=&quot;sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt;操作码找到一个指向顶层&lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt;当前正在使用。sqlite3_file_control（db，SQLITE_FCNTL_VFS_POINTER，X）中的参数X必须为&amp;ldquo; &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; **&amp;rdquo; 类型。该操作码会将* X设置为指向顶级VFS的指针。当堆栈中有多个VFS垫片时，此操作码仅查找最上方的垫片。</target>
        </trans-unit>
        <trans-unit id="5113389d53b260a388ff9b96ca66847bbd222b0d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwalblock&quot; id=&quot;sqlitefcntlwalblock&quot;&gt;SQLITE_FCNTL_WAL_BLOCK&lt;/a&gt; is a signal to the VFS layer that it might be advantageous to block on the next WAL lock if the lock is not immediately available. The WAL subsystem issues this signal during rare circumstances in order to fix a problem with priority inversion. Applications should &lt;em&gt;not&lt;/em&gt; use this file-control.</source>
          <target state="translated">所述&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwalblock&quot; id=&quot;sqlitefcntlwalblock&quot;&gt;SQLITE_FCNTL_WAL_BLOCK&lt;/a&gt;是一个信号到VFS层，如果锁不是立即可用，可能有利的是在下一WAL锁块。WAL子系统在极少数情况下会发出此信号，以解决优先级反转的问题。应用程序应该&lt;em&gt;不&lt;/em&gt;使用此文件控制。</target>
        </trans-unit>
        <trans-unit id="6f1b780daaf82dc713d986bde97a154815b1318d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32avretry&quot; id=&quot;sqlitefcntlwin32avretry&quot;&gt;SQLITE_FCNTL_WIN32_AV_RETRY&lt;/a&gt; opcode is used to configure automatic retry counts and intervals for certain disk I/O operations for the windows &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt; in order to provide robustness in the presence of anti-virus programs. By default, the windows VFS will retry file read, file write, and file delete operations up to 10 times, with a delay of 25 milliseconds before the first retry and with the delay increasing by an additional 25 milliseconds with each subsequent retry. This opcode allows these two values (10 retries and 25 milliseconds of delay) to be adjusted. The values are changed for all database connections within the same process. The argument is a pointer to an array of two integers where the first integer is the new retry count and the second integer is the delay. If either integer is negative, then the setting is not changed but instead the prior value of that setting is written into the array entry, allowing the current retry settings to be interrogated. The zDbName parameter is ignored.</source>
          <target state="translated">该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32avretry&quot; id=&quot;sqlitefcntlwin32avretry&quot;&gt;SQLITE_FCNTL_WIN32_AV_RETRY&lt;/a&gt;操作码用于配置某些磁盘自动重试次数和时间间隔为Windows I / O操作&lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt;为了在存在防病毒程序的情况下提供强大的功能。默认情况下，Windows VFS将重试文件读取，文件写入和文件删除操作最多10次，第一次重试之前的延迟为25毫秒，而每次后续重试的延迟都会增加25毫秒。此操作码允许调整这两个值（重试10次和延迟25毫秒）。对于同一过程中的所有数据库连接，将更改这些值。参数是一个指向两个整数的数组的指针，其中第一个整数是新的重试计数，第二个整数是延迟。如果任一整数为负，则不更改设置，而是将该设置的先前值写入数组条目，从而可以查询当前重试设置。zDbName参数将被忽略。</target>
        </trans-unit>
        <trans-unit id="937fe17d531247dde2a8c434e7c019ad55d302c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32gethandle&quot; id=&quot;sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE&lt;/a&gt; opcode can be used to obtain the underlying native file handle associated with a file handle. This file control interprets its argument as a pointer to a native file handle and writes the resulting value there.</source>
          <target state="translated">所述&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32gethandle&quot; id=&quot;sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE&lt;/a&gt;操作码可被用于获得与文件句柄相关联的底层本地文件句柄。该文件控件将其参数解释为指向本机文件句柄的指针，并将结果值写入该文件句柄。</target>
        </trans-unit>
        <trans-unit id="e6e591e785c2547026326ba62eddb1a8e3a00235" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32sethandle&quot; id=&quot;sqlitefcntlwin32sethandle&quot;&gt;SQLITE_FCNTL_WIN32_SET_HANDLE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to swap the file handle with the one pointed to by the pArg argument. This capability is used during testing and only needs to be supported when SQLITE_TEST is defined.</source>
          <target state="translated">该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32sethandle&quot; id=&quot;sqlitefcntlwin32sethandle&quot;&gt;SQLITE_FCNTL_WIN32_SET_HANDLE&lt;/a&gt;操作码用于调试。此操作码使xFileControl方法将文件句柄与pArg参数指向的文件句柄交换。此功能在测试期间使用，仅在定义SQLITE_TEST时才需要支持。</target>
        </trans-unit>
        <trans-unit id="5d3e0696fb81e2cd89dc43dbc9ef7b0440a8b5e7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlzipvfs&quot; id=&quot;sqlitefcntlzipvfs&quot;&gt;SQLITE_FCNTL_ZIPVFS&lt;/a&gt; opcode is implemented by zipvfs only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="translated">该&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlzipvfs&quot; id=&quot;sqlitefcntlzipvfs&quot;&gt;SQLITE_FCNTL_ZIPVFS&lt;/a&gt;操作码仅由zipvfs实现。所有其他VFS应该为此操作码返回SQLITE_NOTFOUND。</target>
        </trans-unit>
        <trans-unit id="15edb51b39cd83bfa83c4b8e2f7138c93f46e748" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; flag means the file should be deleted when it is closed. The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; will be set for TEMP databases and their journals, transient databases, and subjournals.</source>
          <target state="translated">该&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt;标志意味着当它关闭该文件应予删除。该&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt;将为TEMP数据库及其期刊，短暂的数据库，并subjournals进行设置。</target>
        </trans-unit>
        <trans-unit id="fc3c6baa196558e15836748dd318cdd30a688ef6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; flag is always used in conjunction with the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; flag, which are both directly analogous to the O_EXCL and O_CREAT flags of the POSIX open() API. The SQLITE_OPEN_EXCLUSIVE flag, when paired with the SQLITE_OPEN_CREATE, is used to indicate that file should always be created, and that it is an error if it already exists. It is</source>
          <target state="translated">所述&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt;标志总是与一起使用&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;标志，这两者都是直接类似于POSIX打开（）API的O_EXCL和O_CREAT标志。当与SQLITE_OPEN_CREATE配对使用时，SQLITE_OPEN_EXCLUSIVE标志用于指示应始终创建文件，如果该文件已经存在则为错误。它是</target>
        </trans-unit>
        <trans-unit id="c2061592c87f5f999944ce29cf7569df9e8b3f69" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; C preprocessor macro in the sqlite3.h header evaluates to a string literal that is the SQLite version in the format &quot;X.Y.Z&quot; where X is the major version number (always 3 for SQLite3) and Y is the minor version number and Z is the release number. The &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; C preprocessor macro resolves to an integer with the value (X*1000000 + Y*1000 + Z) where X, Y, and Z are the same numbers used in &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt;. The SQLITE_VERSION_NUMBER for any given release of SQLite will also be larger than the release from which it is derived. Either Y will be held constant and Z will be incremented or else Y will be incremented and Z will be reset to zero.</source>
          <target state="translated">sqlite3.h标头中的&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; C预处理程序宏求值为字符串文字，该字符串文字是格式为&amp;ldquo; XYZ&amp;rdquo;的SQLite版本，其中X为主要版本号（对于SQLite3始终为3），Y为次要版本号，Z为发布编号。所述&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; C预处理宏解析为一个整数，其值为（X * 1000000 + Y * 1000 + Z），其中X，Y，和Z是在所使用的相同的数字&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt;。任何给定版本的SQLite的SQLITE_VERSION_NUMBER也将大于其派生版本。 Y将保持恒定并且Z将增加，否则Y将增加并且Z将重置为零。</target>
        </trans-unit>
        <trans-unit id="ffc6747416294fa8545c14bddccb7cfdc4ee3b78" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; interface unregisters the initialization routine X that was registered using a prior call to &lt;a href=&quot;auto_extension&quot;&gt;sqlite3_auto_extension(X)&lt;/a&gt;. The &lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; routine returns 1 if initialization routine X was successfully unregistered and it returns 0 if X was not on the list of initialization routines.</source>
          <target state="translated">所述&lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension（X）&lt;/a&gt;接口注销这是使用于现有呼叫登记的初始化例程X &lt;a href=&quot;auto_extension&quot;&gt;sqlite3_auto_extension（X） &lt;/a&gt;。该&lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension（X）&lt;/a&gt;例程返回1，如果初始化程序X是成功注销，并将其返回0，如果X不是初始化程序的列表中。</target>
        </trans-unit>
        <trans-unit id="5d6d6c3ad7f7d02755c43722a7a4b2dabb76ea67" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;carray&quot;&gt;carray table-valued function&lt;/a&gt; needs to accept a pointer to an array of C-language values from the application.</source>
          <target state="translated">所述&lt;a href=&quot;carray&quot;&gt;CARRAY表值函数&lt;/a&gt;需要接受的指针C语言值的从应用程序阵列。</target>
        </trans-unit>
        <trans-unit id="6e118be6f5051683611f54652026dab741b99e41" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cli#dotdatabases&quot;&gt;.databases&lt;/a&gt; dot-command now shows the status of each database file as determined by &lt;a href=&quot;c3ref/db_readonly&quot;&gt;sqlite3_db_readonly()&lt;/a&gt; and &lt;a href=&quot;c3ref/txn_state&quot;&gt;sqlite3_txn_state()&lt;/a&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;cli#dotdatabases&quot;&gt;.databases&lt;/a&gt; DOT-命令现在显示的每个数据库文件作为所确定的状态&lt;a href=&quot;c3ref/db_readonly&quot;&gt;sqlite3_db_readonly（）&lt;/a&gt;和&lt;a href=&quot;c3ref/txn_state&quot;&gt;（）sqlite3_txn_state&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2640c803231626a3249e7d8e29a243d0fc2ba77e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cli#dotread&quot;&gt;.read&lt;/a&gt; dot-command now accepts a pipeline in addition to a filename.</source>
          <target state="translated">现在，&lt;a href=&quot;cli#dotread&quot;&gt;.read&lt;/a&gt;点命令除了文件名外还接受管道。</target>
        </trans-unit>
        <trans-unit id="467a3e3add4e8f323509cb384ea9db3beaf1960c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cli#dump&quot;&gt;.dump&lt;/a&gt; command in the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; omits the first NUL character and all subsequent text in the SQL output that it generates. In fact, the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; omits everything past the first NUL character in all contexts.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;CLI中&lt;/a&gt;的&lt;a href=&quot;cli#dump&quot;&gt;.dump&lt;/a&gt;命令忽略了它生成的SQL输出中的第一个NUL字符和所有后续文本。实际上，&lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;在所有情况下都忽略了第一个NUL字符之后的所有内容。</target>
        </trans-unit>
        <trans-unit id="99b9d11b0a4071822aa18a343a895720b0d0af06" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cli#dump&quot;&gt;.dump&lt;/a&gt; command now accepts multiple LIKE-pattern arguments and outputs the union of all matching tables.</source>
          <target state="translated">的&lt;a href=&quot;cli#dump&quot;&gt;使用.dump&lt;/a&gt;命令现在接受多个LIKE图案参数，并输出所有匹配表的联合。</target>
        </trans-unit>
        <trans-unit id="c282faf1973e4f89130abe26a61f3f513af735e2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#default_page_size&quot;&gt;SQLITE_DEFAULT_PAGE_SIZE&lt;/a&gt; compile-time option can be used to change the default page size assigned to new databases.</source>
          <target state="translated">该&lt;a href=&quot;compile#default_page_size&quot;&gt;SQLITE_DEFAULT_PAGE_SIZE&lt;/a&gt;时间编译选项可以用来更改分配给新数据库的默认页面大小。</target>
        </trans-unit>
        <trans-unit id="5f025c2cb604da7be21c2713e7ae110d6fc22479" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#default_page_size&quot;&gt;SQLITE_DEFAULT_PAGE_SIZE&lt;/a&gt; is increased from 1024 to 4096. The &lt;a href=&quot;compile#default_cache_size&quot;&gt;SQLITE_DEFAULT_CACHE_SIZE&lt;/a&gt; is changed from 2000 to -2000 so the same amount of cache memory is used by default. See the application note on the &lt;a href=&quot;pgszchng2016&quot;&gt;version 3.12.0 page size change&lt;/a&gt; for further information.</source>
          <target state="translated">该&lt;a href=&quot;compile#default_page_size&quot;&gt;SQLITE_DEFAULT_PAGE_SIZE&lt;/a&gt;增加从1024到4096 &lt;a href=&quot;compile#default_cache_size&quot;&gt;SQLITE_DEFAULT_CACHE_SIZE&lt;/a&gt;从2000变为-2000所以高速缓存存储器相同数量的默认情况下使用。有关更多信息，请参见关于&lt;a href=&quot;pgszchng2016&quot;&gt;3.12.0版页面大小更改&lt;/a&gt;的应用笔记。</target>
        </trans-unit>
        <trans-unit id="623f46dd8d1f8aedc876d36b9e6b7c6843fb38ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#direct_overflow_read&quot;&gt;-DSQLITE_DIRECT_OVERFLOW_READ&lt;/a&gt; compile-time option causes SQLite to bypass its page cache when reading content from overflow pages. This helps database reads of 10K blobs run a little faster, but not all that much faster. SQLite still holds a speed advantage over direct filesystem reads without the SQLITE_DIRECT_OVERFLOW_READ compile-time option.</source>
          <target state="translated">该&lt;a href=&quot;compile#direct_overflow_read&quot;&gt;-DSQLITE_DIRECT_OVERFLOW_READ&lt;/a&gt;编译时选项导致的SQLite绕过它的页面缓存读取来自溢出页内容时。这可以帮助数据库读取10K Blob的速度更快一些，但并没有那么快。与不使用SQLITE_DIRECT_OVERFLOW_READ编译时选项的直接文件系统读取相比，SQLite仍具有速度优势。</target>
        </trans-unit>
        <trans-unit id="e8d73bde2dc7785ffa127c202c3991e5af269a19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; compile-time option is now turned on by default in the standard builds.</source>
          <target state="translated">该&lt;a href=&quot;compile#enable_explain_comments&quot;&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt;编译时选项现在在标准默认开启的构建。</target>
        </trans-unit>
        <trans-unit id="ec9ba2ea4ea2e87921df34017de3d69d7b4137bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; compile-time option causes the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command to collect a small histogram of each index, to help SQLite better select among competing range query indices.</source>
          <target state="translated">该&lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;编译时选项导致&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令收集各指标的小直方图，以帮助更好的SQLite竞争范围的查询索引中进行选择。</target>
        </trans-unit>
        <trans-unit id="e0180c578d01206ca2260b932e5fe2d4e6cc6568" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_...&lt;/a&gt; compile-time options only work when building from canonical source files. They do &lt;u&gt;not&lt;/u&gt; work when you build from the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; or from the pre-processed source files.</source>
          <target state="translated">该&lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT _...&lt;/a&gt;编译时的选项只有从规范源文件时，建设工作。他们这样做&lt;u&gt;不是&lt;/u&gt;当你从SQLite的建设工作，&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;或从预处理后的源文件。</target>
        </trans-unit>
        <trans-unit id="f951ab56418025da71fd3229ec924e7681f98557" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#query_planner_limit&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT&lt;/a&gt; option sets an initial baseline value for the maximum number of index-and-constraint combinations that the query planner consider. The baseline query planner limit is increased by SQLITE_QUERY_PLANNER_LIMIT_INCR prior to processing each table of a join so that each table is guaranteed to be able to propose at least some index-and-constraint combinations to the optimizer even if prior tables of the join have exhausted the baseline limit. The default value for both this compile-time option and the &lt;a href=&quot;compile#query_planner_limit&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT&lt;/a&gt; option are set high enough so that they should never be reached for real-world queries.</source>
          <target state="translated">该&lt;a href=&quot;compile#query_planner_limit&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT&lt;/a&gt;选项设置索引和约束组合的查询规划考虑的最大数量的初始基线值。在处理联接的每个表之前，通过增加SQLITE_QUERY_PLANNER_LIMIT_INCR来提高基线查询计划程序的限制，从而即使在联接的先前表已用尽所有资源的情况下，也保证了每个表都能够向优化器建议至少一些索引和约束组合。基线极限。此编译时选项和&lt;a href=&quot;compile#query_planner_limit&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT&lt;/a&gt;选项的默认值都设置得足够高，以至于现实世界中的查询永远不能达到它们的默认值。</target>
        </trans-unit>
        <trans-unit id="4cd49b137fd67eca14bbcc5b6c746f08a2997711" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; compile-time option fixed to make sure that content is deleted even when the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; applies.</source>
          <target state="translated">该&lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt;时间编译选项固定，以确保当内容被删除，甚至&lt;a href=&quot;lang_delete#truncateopt&quot;&gt;截断优化&lt;/a&gt;应用。</target>
        </trans-unit>
        <trans-unit id="656d7af3931cb41fc80d6fdefc85a4cfb80b7c01" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter is a #define whose value is an integer between 0 and 3, inclusive. The meaning of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter is as follows:</source>
          <target state="translated">所述&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;编译时间参数是一个的#define，其值是0和3之间的整数。&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;编译时参数的含义如下：</target>
        </trans-unit>
        <trans-unit id="4c11588171d30d65004665748aee39867b770ec3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option can be used to limit the length of &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt; expansion in the output of sqlite3_trace().</source>
          <target state="translated">所述&lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt;编译时选项可用于限制所长度&lt;a href=&quot;lang_expr#varparam&quot;&gt;绑定参数&lt;/a&gt;在sqlite3_trace的输出扩展（）。</target>
        </trans-unit>
        <trans-unit id="355c715bbc78271373ada3410d668232a6d1cc69" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option limits the size of bound parameter expansions. The &lt;a href=&quot;compile#omit_trace&quot;&gt;SQLITE_OMIT_TRACE&lt;/a&gt; compile-time option causes sqlite3_expanded_sql() to always return NULL.</source>
          <target state="translated">所述&lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt;编译时选项限制结合的参数扩展的大小。该&lt;a href=&quot;compile#omit_trace&quot;&gt;SQLITE_OMIT_TRACE&lt;/a&gt;时间编译选项的原因sqlite3_expanded_sql（）总是返回NULL。</target>
        </trans-unit>
        <trans-unit id="d80a700ed456a052f14722da1654635b16877833" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#trusted_schema&quot;&gt;-DSQLITE_TRUSTED_SCHEMA=0&lt;/a&gt; compile-time option will cause this setting to default to OFF.</source>
          <target state="translated">该&lt;a href=&quot;compile#trusted_schema&quot;&gt;-DSQLITE_TRUSTED_SCHEMA = 0&lt;/a&gt;编译时选项将导致此设置默认为关。</target>
        </trans-unit>
        <trans-unit id="4f82d70cfe7739c80fc41874304dfb1e1ffafd3f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;, ...) interface can register an alternative page cache implementation by passing in an instance of the sqlite3_pcache_methods2 structure. In many applications, most of the heap memory allocated by SQLite is used for the page cache. By implementing a custom page cache using this API, an application can better control the amount of memory consumed by SQLite, the way in which that memory is allocated and released, and the policies used to determine exactly which parts of a database file are cached and for how long.</source>
          <target state="translated">该&lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;，...）接口可以通过传递sqlite3_pcache_methods2结构的一个实例注册一个替代页面缓存实现。在许多应用程序中，SQLite分配的大部分堆内存都用于页面缓存。通过使用此API实现自定义页面缓存，应用程序可以更好地控制SQLite占用的内存量，分配和释放内存的方式，以及用于确切确定要缓存数据库文件的哪些部分的策略以及多长时间。</target>
        </trans-unit>
        <trans-unit id="28bbb907be12b8d8d6cb3f58bde73db3db4a2a3e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; output no longer shows an estimate of the number of rows generated by each loop in a join.</source>
          <target state="translated">所述&lt;a href=&quot;eqp&quot;&gt;EXPLAIN查询计划&lt;/a&gt;输出不再示出了在由每个回路中产生的行数的估计加入。</target>
        </trans-unit>
        <trans-unit id="0403e12475b1041021c7db25c8bbeab40ee20902" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface makes a direct call to the xFileControl method for the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object associated with a particular database identified by the second argument. The name of the database is &quot;main&quot; for the main database or &quot;temp&quot; for the TEMP database, or the name that appears after the AS keyword for databases that are added using the &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL command. A NULL pointer can be used in place of &quot;main&quot; to refer to the main database file. The third and fourth parameters to this routine are passed directly through to the second and third parameters of the xFileControl method. The return value of the xFileControl method becomes the return value of this routine.</source>
          <target state="translated">所述&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;接口使得所述xFileControl方法的直接调用&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象与由第二个参数识别一个特定的数据库相关联。对于主数据库，数据库名称为&amp;ldquo; main&amp;rdquo;，对于TEMP数据库，数据库名称为&amp;ldquo; temp&amp;rdquo;，对于使用&lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL命令添加的数据库，名称为AS关键字之后。可以使用NULL指针代替&amp;ldquo; main&amp;rdquo;来引用主数据库文件。此例程的第三和第四参数直接传递给xFileControl方法的第二和第三参数。 xFileControl方法的返回值成为该例程的返回值。</target>
        </trans-unit>
        <trans-unit id="c477329521e0c202c4f6312a9b20720b0061408f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fileformat2&quot;&gt;underlying file format&lt;/a&gt; for SQLite databases does not change in incompatible ways. There are literally hundreds of billions, perhaps trillions, of SQLite database files in circulation and the SQLite developers are committing to supporting those files for decades into the future.</source>
          <target state="translated">SQLite数据库的&lt;a href=&quot;fileformat2&quot;&gt;基础文件格式&lt;/a&gt;不会以不兼容的方式更改。实际上，有数千亿甚至数万亿的SQLite数据库文件正在流通，并且SQLite开发人员致力于在未来数十年内支持这些文件。</target>
        </trans-unit>
        <trans-unit id="019a9b5a0c4bab7b2872e5382ef484fc4c667e1b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fileformat2#validfor&quot;&gt;version-valid-for number&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;fileformat2#validfor&quot;&gt;版本化有效的数字&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="47ad55bfdbffd81a341414cce2caff94549fb57d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fileformat2#walformat&quot;&gt;WAL file format&lt;/a&gt; is precisely defined and is cross-platform.</source>
          <target state="translated">该&lt;a href=&quot;fileformat2#walformat&quot;&gt;WAL文件格式&lt;/a&gt;的精确定义，是跨平台的。</target>
        </trans-unit>
        <trans-unit id="d24509e4b9939bc43b94f948e05ab88b6b7e58c7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;floatingpoint#decext&quot;&gt;decimal extension&lt;/a&gt; and the &lt;a href=&quot;floatingpoint#ieee754ext&quot;&gt;ieee754 extension&lt;/a&gt; are built-in to the CLI</source>
          <target state="translated">该&lt;a href=&quot;floatingpoint#decext&quot;&gt;小数延伸&lt;/a&gt;和&lt;a href=&quot;floatingpoint#ieee754ext&quot;&gt;IEEE754扩展&lt;/a&gt;是内置到CLI</target>
        </trans-unit>
        <trans-unit id="3e921edb70343a6bdb367da8f2286bed023bed5c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;foreignkeys#parentchild&quot;&gt;parent key&lt;/a&gt; of a &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; is not allowed to use the rowid. The parent key must used named columns only.</source>
          <target state="translated">该&lt;a href=&quot;foreignkeys#parentchild&quot;&gt;父键&lt;/a&gt;一个的&lt;a href=&quot;foreignkeys&quot;&gt;外键约束&lt;/a&gt;，不允许使用ROWID。父键只能使用命名列。</target>
        </trans-unit>
        <trans-unit id="94136fe2e1cb36bfe5b8895ca9db2e90ee44f1f5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; MATCH operator passes pointers into &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt;, &lt;a href=&quot;fts3#offsets&quot;&gt;offsets()&lt;/a&gt;, and &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; MATCH操作员传递到指针&lt;a href=&quot;fts3#snippet&quot;&gt;段（） &lt;/a&gt;，&lt;a href=&quot;fts3#offsets&quot;&gt;偏移量（） &lt;/a&gt;，和&lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="43eb5ae7856e6e2985afc5b90e134ad6efe6a669" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#*fts4rebuidcmd&quot;&gt;FTS4 &quot;rebuild&quot; command&lt;/a&gt; deletes the entire full-text index and rebuilds it based on the current set of documents in the content table. Assuming again that &quot;t3&quot; is the name of the external content FTS4 table, the rebuild command looks like this:</source>
          <target state="translated">该&lt;a href=&quot;fts3#*fts4rebuidcmd&quot;&gt;FTS4&amp;ldquo;重建&amp;rdquo;命令&lt;/a&gt;删除整个全文索引并重建它基于当前的一组中的内容表的文档。再次假设&amp;ldquo; t3&amp;rdquo;是外部内容FTS4表的名称，那么rebuild命令如下所示：</target>
        </trans-unit>
        <trans-unit id="a98c7bde5e55ca0fc0875001b5230f001bb8d1a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; function always returns NULL unless either the legacy application-defined FTS3 tokenizers interface are enabled using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;) setting, or unless the first argument to fts3_tokenizer() is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer（）&lt;/a&gt;函数总是返回NULL除非任何传统应用程序定义的FTS3断词接口正在使用的启用&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;）设置，或除非的第一个参数fts3_tokenizer（）是一个&lt;a href=&quot;lang_expr#varparam&quot;&gt;结合的参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1574210b17663fb17af96bfd5572d4febc918bf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;FTS MATCH&lt;/a&gt; operator is supported for queries based on the built-in full-text index.</source>
          <target state="translated">该&lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;FTS MATCH&lt;/a&gt;运算符支持基于内建的全文索引的查询。</target>
        </trans-unit>
        <trans-unit id="afda903a3f03dcbd2f01644e1f0a3ea9a0e62818" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#matchinfo-x&quot;&gt;matchinfo 'x' flag&lt;/a&gt; would report a single hit for the phrases &quot;a&quot; and &quot;c&quot;. However, the 'y' directive reports the number of hits for &quot;c&quot; as zero, as it is part of a sub-expression that does not match the document - (b AND c). For queries that do not contain AND operators descended from OR operators, the result values returned by 'y' are always the same as those returned by 'x'.</source>
          <target state="translated">该&lt;a href=&quot;fts3#matchinfo-x&quot;&gt;matchinfo&amp;ldquo;X&amp;rdquo;标志&lt;/a&gt;将报告单发命中的短语&amp;ldquo;一&amp;rdquo;和&amp;ldquo;C&amp;rdquo;。但是，&amp;ldquo; y&amp;rdquo;指令将&amp;ldquo; c&amp;rdquo;的命中次数报告为零，因为它是与文档不匹配的子表达式的一部分-（b AND c）。对于不包含从OR运算符派生的AND运算符的查询，&amp;ldquo; y&amp;rdquo;返回的结果值始终与&amp;ldquo; x&amp;rdquo;返回的结果值相同。</target>
        </trans-unit>
        <trans-unit id="5a3b429b14a3a0c21190f0bbe4a4fec620e8c35a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt;, &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt;, &lt;a href=&quot;fts3#offsets&quot;&gt;offsets()&lt;/a&gt;, and &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; are available to support full-text queries.</source>
          <target state="translated">该&lt;a href=&quot;fts3#snippet&quot;&gt;FTS辅助功能&lt;/a&gt;，&lt;a href=&quot;fts3#snippet&quot;&gt;片断（） &lt;/a&gt;，&lt;a href=&quot;fts3#offsets&quot;&gt;偏移量（） &lt;/a&gt;，和&lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo（）&lt;/a&gt;可用于支持全文查询。</target>
        </trans-unit>
        <trans-unit id="986cc21a6b9f4c0f213b24757430a9834e1ed2e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#snippet&quot;&gt;snippet&lt;/a&gt; function cannot be used with the above query. Because the outer query does not include a &quot;WHERE ... MATCH&quot; clause, the snippet function may not be used with it. One solution is to duplicate the WHERE clause used by the sub-query in the outer query. The overhead associated with this is usually negligible.</source>
          <target state="translated">该&lt;a href=&quot;fts3#snippet&quot;&gt;片断&lt;/a&gt;功能不能与上述查询中使用。因为外部查询不包含&amp;ldquo; WHERE ... MATCH&amp;rdquo;子句，所以代码片段功能可能无法与其一起使用。一种解决方案是在外部查询中复制子查询使用的WHERE子句。与之相关的开销通常可以忽略不计。</target>
        </trans-unit>
        <trans-unit id="6bce43282ea827774137f471cf2a2f9eafebbd71" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt; tokenizer is now included in &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; by default.</source>
          <target state="translated">该&lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt;标记生成器现在包含在&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;默认。</target>
        </trans-unit>
        <trans-unit id="d0b9e4179a7690f373db2c622ddd029271ea2c29" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25() auxiliary function&lt;/a&gt; returns a real value reflecting the accuracy of the current match. Better matches are assigned numerically lower values.</source>
          <target state="translated">的&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;BM25（）辅助功能&lt;/a&gt;返回反映当前匹配的准确度的实数值。较好的匹配将分配给数值较低的值。</target>
        </trans-unit>
        <trans-unit id="86d537287fe3b1d151168bae58fabce38b16555d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;columnsize&quot; option&lt;/a&gt;, used to configure whether or not the size in tokens of each value in the FTS5 table is stored separately within the database.</source>
          <target state="translated">所述&lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&amp;ldquo;columnsize&amp;rdquo;选项&lt;/a&gt;，用来配置是否在FTS5表中的每个值的代币的尺寸在数据库中分别存储。</target>
        </trans-unit>
        <trans-unit id="4542957e1a08fcc6a2bdcd49b04a58f559cf1ff8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_detail_option&quot;&gt;&quot;detail&quot; option&lt;/a&gt;. This option may be used to reduce the size of the FTS index on disk by omitting some information from it.</source>
          <target state="translated">在&lt;a href=&quot;fts5#the_detail_option&quot;&gt;&amp;ldquo;详细信息&amp;rdquo;选项&lt;/a&gt;。该选项可用于通过省略一些FTS索引来减少磁盘上FTS索引的大小。</target>
        </trans-unit>
        <trans-unit id="e41a2e84baae07818885bfa4f91b936da5a1f958" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_highlight_function&quot;&gt;highlight() auxiliary function&lt;/a&gt; returns a copy of the text from one of the columns of the current match with each instance of a queried term within the result surrounded by specified markup (for example &quot;&amp;lt;b&amp;gt;&quot; and &quot;&amp;lt;/b&amp;gt;&quot;).</source>
          <target state="translated">所述&lt;a href=&quot;fts5#the_highlight_function&quot;&gt;突出（）辅助功能&lt;/a&gt;返回从当前与之相匹配的结果内的查询术语由指定的标记（例如包围每个实例的列中的一文本的副本&amp;ldquo;的&amp;lt;b&amp;gt;&amp;rdquo;和&amp;ldquo;&amp;lt;/ b&amp;gt;的&amp;rdquo; ）。</target>
        </trans-unit>
        <trans-unit id="b98a3fb75c4347301e0a46ec5f5ca45961387193" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_snippet_function&quot;&gt;snippet() auxiliary function&lt;/a&gt; selects a short fragment of text from one of the columns of the matched row and returns it with each instance of a queried term surrounded by markup in the same manner as the highlight() function. The fragment of text is selected so as to maximize the number of queried terms it contains.</source>
          <target state="translated">的&lt;a href=&quot;fts5#the_snippet_function&quot;&gt;片断（）辅助功能&lt;/a&gt;选择从匹配的行，并用查询术语的每个实例返回它以相同的方式作为高亮（）函数包围标记的列中的一文本的短的片段。选择文本片段，以使其包含的查询术语的数量最大化。</target>
        </trans-unit>
        <trans-unit id="3a9eabcd215930eb738f36712bb83d6c0b14ec4f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;American Fuzzy Lop&lt;/a&gt; or &quot;AFL&quot; fuzzer is a recent (circa 2014) innovation from Michal Zalewski. Unlike most other fuzzers that blindly generate random inputs, the AFL fuzzer instruments the program being tested (by modifying the assembly-language output from the C compiler) and uses that instrumentation to detect when an input causes the program to do something different - to follow a new control path or loop a different number of times. Inputs that provoke new behavior are retained and further mutated. In this way, AFL is able to &quot;discover&quot; new behaviors of the program under test, including behaviors that were never envisioned by the designers.</source>
          <target state="translated">在&lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;美国的模糊罗布泊&lt;/a&gt;或&amp;ldquo;AFL&amp;rdquo;的fuzzer是米哈尔扎莱夫斯基最近（约2014）的创新。与大多数其他模糊器盲目生成随机输入的方法不同，AFL模糊器会检测正在测试的程序（通过修改C编译器的汇编语言输出），并使用该检测方法来检测输入何时导致程序执行不同的操作-进行跟踪新的控制路径或循环不同的次数。引发新行为的输入将保留并进一步突变。这样，AFL能够&amp;ldquo;发现&amp;rdquo;被测程序的新行为，包括设计人员从未想到的行为。</target>
        </trans-unit>
        <trans-unit id="8ddbb2bd7ba87408b594939a6917d04da89a5349" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt; is the version control system used to track all of the SQLite source code. A Fossil repository is an SQLite database file. (Readers are invited to ponder this recursion as an independent exercise.) Fossil is both the version-control system for SQLite and a test platform for SQLite. Whenever enhancements are made to SQLite, Fossil is one of the first applications to test and evaluate those enhancements. So Fossil was an early adopter of the NGQP.</source>
          <target state="translated">所述&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;化石DVCS&lt;/a&gt;是用于追踪所有SQLite的源代码的版本控制系统。 Fossil存储库是一个SQLite数据库文件。 （请读者考虑一下此递归是一项独立的练习。）Fossil既是SQLite的版本控制系统，也是SQLite的测试平台。每当对SQLite进行增强时，Fossil都是测试和评估这些增强的首批应用程序之一。因此，Fossil是NGQP的早期采用者。</target>
        </trans-unit>
        <trans-unit id="cca3e4effc9207d5a63c711cbfd8ac97defe5fba" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.sqlite.org/sqllogictest&quot; id=&quot;slt&quot;&gt;&lt;b&gt;SQL Logic Test&lt;/b&gt;&lt;/a&gt; or SLT test harness is used to run huge numbers of SQL statements against both SQLite and several other SQL database engines and verify that they all get the same answers. SLT currently compares SQLite against PostgreSQL, MySQL, Microsoft SQL Server, and Oracle 10g. SLT runs 7.2 million queries comprising 1.12GB of test data.</source>
          <target state="translated">在&lt;a href=&quot;http://www.sqlite.org/sqllogictest&quot; id=&quot;slt&quot;&gt;&lt;b&gt;SQL逻辑测试&lt;/b&gt;&lt;/a&gt;或SLT测试工具是用来运行对阵双方SQLite和其他几个SQL数据库引擎的SQL语句的数量巨大，并确认他们都得到同样的答案。 SLT当前将SQLite与PostgreSQL，MySQL，Microsoft SQL Server和Oracle 10g进行了比较。 SLT运行720万查询，包括1.12GB的测试数据。</target>
        </trans-unit>
        <trans-unit id="154e70bf20f83a327304d76749961d8773743242" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://en.wikipedia.org/wiki/Web_SQL_Database&quot;&gt;WebSQL&lt;/a&gt; interface to webkit allowed any webpage to run arbitrary SQL in the browser for Chrome and Safari. That arbitrary SQL was supposed to be run inside a sandbox where it could do no harm even if exploited, but that sandbox turned out to be less secure than people supposed. In the spring of 2017, one team of hackers was able to root an iMac using a long sequence of exploits, one of which involved corrupting the pointers passed as BLOB values to the snippet() FTS3 function of an SQLite database running via the WebSQL interface inside of Safari.</source>
          <target state="translated">Webkit 的&lt;a href=&quot;https://en.wikipedia.org/wiki/Web_SQL_Database&quot;&gt;WebSQL&lt;/a&gt;界面允许任何网页在Chrome和Safari浏览器中运行任意SQL。该任意SQL应该在沙箱中运行，即使被利用也不会造成任何危害，但事实证明沙箱的安全性不如人们想象的那样。在2017年春季，一个黑客团队能够使用一连串的漏洞来扎根iMac，其中之一涉及破坏作为BLOB值传递给通过WebSQL接口运行的SQLite数据库的snippet（）FTS3函数的指针在Safari中。</target>
        </trans-unit>
        <trans-unit id="6101be379589e2c8cd0e728015188ca8e192b3db" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil Distributed Version Control&lt;/a&gt; system provides users with the option to download check-ins as either Tarballs, ZIP Archives, or SQLite Archives.</source>
          <target state="translated">该&lt;a href=&quot;https://fossil-scm.org/&quot;&gt;化石分布式版本控制&lt;/a&gt;系统为用户提供了选择下载签入的任何压缩包，ZIP档案，或SQLite的档案。</target>
        </trans-unit>
        <trans-unit id="6106b2007efa210c8ee70fed3636c5f43bb5c12d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;Append VFS&lt;/a&gt; is a &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt; that allows an SQLite database to be appended to some other file. This allows (for example) a database to be appended to an executable that then opens and reads the database.</source>
          <target state="translated">该&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;追加VFS&lt;/a&gt;是&lt;a href=&quot;vfs#shim&quot;&gt;VFS垫片&lt;/a&gt;，其允许SQLite数据库要附加到某些其他文件。例如，这允许将数据库附加到可执行文件中，然后该可执行文件将打开并读取该数据库。</target>
        </trans-unit>
        <trans-unit id="80173a6349ab4ffb46f02ada86de670d66a57b26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/btreeinfo.c&quot;&gt;sqlite_btreeinfo&lt;/a&gt; eponymous virtual table for introspecting and estimating the sizes of the btrees in a database.</source>
          <target state="translated">所述&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/btreeinfo.c&quot;&gt;sqlite_btreeinfo&lt;/a&gt;同名虚拟表内省和估计在数据库中B树的尺寸。</target>
        </trans-unit>
        <trans-unit id="ab07c049c01997dbb19b575504dcb74af616cde0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/remember.c&quot;&gt;remember() extension&lt;/a&gt; needs a pointer to a C-language integer variable in which to remember the value it passes.</source>
          <target state="translated">该&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/remember.c&quot;&gt;记得（）扩展&lt;/a&gt;需要一个指向一个C语言整数变量，其中记住它传递值。</target>
        </trans-unit>
        <trans-unit id="56d93d46695516053b394cd5886b780db3048dfe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/vfsstat.c&quot;&gt;vfsstat.c&lt;/a&gt; extension show an example of a loadable extension that persistently registers both a new VFS and a new virtual table. The &lt;a href=&quot;https://sqlite.org/src/info/77b5b4235c9f7f11?ln=801-819&quot;&gt;sqlite3_vfsstat_init()&lt;/a&gt; initialization routine in that extension is called only once, when the extension is first loaded. It registers the new &quot;vfslog&quot; VFS just that one time, and it returns SQLITE_OK_LOAD_PERMANENTLY so that the code used to implement the &quot;vfslog&quot; VFS will remain in memory. The initialization routine also invokes &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; on a pointer to the &quot;vstatRegister()&quot; function so that all subsequent database connections will invoke the &quot;vstatRegister()&quot; function as they start up, and hence register the &quot;vfsstat&quot; virtual table.</source>
          <target state="translated">该&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/vfsstat.c&quot;&gt;vfsstat.c&lt;/a&gt;扩展显示一个可加载扩展，坚持既注册一个新的VFS和新的虚拟表的一例。首次加载扩展时，该扩展中的&lt;a href=&quot;https://sqlite.org/src/info/77b5b4235c9f7f11?ln=801-819&quot;&gt;sqlite3_vfsstat_init（）&lt;/a&gt;初始化例程仅被调用一次。它仅注册一次新的&amp;ldquo; vfslog&amp;rdquo; VFS，然后返回SQLITE_OK_LOAD_PERMANENTLY，以便用于实现&amp;ldquo; vfslog&amp;rdquo; VFS的代码将保留在内存中。初始化例程还会在指向&amp;ldquo; vstatRegister（）&amp;rdquo;函数的指针上调用&lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;，以便所有后续数据库连接在启动时都将调用&amp;ldquo; vstatRegister（）&amp;rdquo;函数，从而注册&amp;ldquo; vfsstat&amp;rdquo;虚拟表。</target>
        </trans-unit>
        <trans-unit id="037dcdadc7444a9f8e13871793682a198eab41e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/tool/speed-check.sh&quot;&gt;speed-check.sh&lt;/a&gt; shell script, also in the canonical source tree, is used to run the speedtest1.c program. To replicate the performance measurements, collect the following files into a single directory:</source>
          <target state="translated">还在标准源代码树中的&lt;a href=&quot;https://sqlite.org/src/file/tool/speed-check.sh&quot;&gt;speed-check.sh&lt;/a&gt; shell脚本用于运行speedtest1.c程序。要复制性能度量，请将以下文件收集到一个目录中：</target>
        </trans-unit>
        <trans-unit id="3427f1e6f488cf0eccc944462552651c0021ca21" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/finfo?name=src/shell.c&quot;&gt;src/shell.c&lt;/a&gt; source code to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; is no longer under version control. That file is now generated as part of the build process.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;命令行shell&lt;/a&gt;的&lt;a href=&quot;https://sqlite.org/src/finfo?name=src/shell.c&quot;&gt;src / shell.c&lt;/a&gt;源代码不再受版本控制。现在，将在构建过程中生成该文件。</target>
        </trans-unit>
        <trans-unit id="c808a45cb504200c3f1dbb6bdafa2749899db0fe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;SQLite Fossil Repository&lt;/a&gt; contains links for downloading a Tarball, ZIP Archive, or &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive&lt;/a&gt; for any historical version of SQLite. The URLs for these downloads are simple and can be incorporated easily into automated tools. The format is:</source>
          <target state="translated">在&lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;SQLite的化石库&lt;/a&gt;中包含用于下载压缩包，ZIP档案或链接&lt;a href=&quot;sqlar&quot;&gt;SQLite的存档&lt;/a&gt; SQLite的任何历史版本。这些下载的URL很简单，可以轻松地合并到自动化工具中。格式为：</target>
        </trans-unit>
        <trans-unit id="d3fbdd1d270cc576e74540d52236d70c3135bcb8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://tools.ietf.org/html/rfc7946&quot;&gt;GeoJSON standard&lt;/a&gt; is syntax for exchanging geospatial information using JSON. GeoJSON is a rich standard that can describe nearly any kind of geospatial content.</source>
          <target state="translated">该&lt;a href=&quot;https://tools.ietf.org/html/rfc7946&quot;&gt;GeoJSON的标准&lt;/a&gt;是用于交换使用JSON地理空间信息的语法。GeoJSON是一个丰富的标准，可以描述几乎任何种类的地理空间内容。</target>
        </trans-unit>
        <trans-unit id="a8212cd715bfd94418070c51a83dde87fd4d5020" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt; is the version control system used to track all of the SQLite source code. A Fossil repository is an SQLite database file. (Readers are invited to ponder this recursion as an independent exercise.) Fossil is both the version-control system for SQLite and a test platform for SQLite. Whenever enhancements are made to SQLite, Fossil is one of the first applications to test and evaluate those enhancements. So Fossil was an early adopter of the NGQP.</source>
          <target state="translated">所述&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;化石DVCS&lt;/a&gt;是用于追踪所有SQLite的源代码的版本控制系统。Fossil存储库是一个SQLite数据库文件。（请读者考虑一下此递归是一项独立的练习。）Fossil既是SQLite的版本控制系统，也是SQLite的测试平台。只要对SQLite进行了增强，Fossil便是测试和评估这些增强的首批应用程序之一。因此，Fossil是NGQP的早期采用者。</target>
        </trans-unit>
        <trans-unit id="103a9865440a893fd3c0abf774146aac35769fd1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil Version Control System&lt;/a&gt; uses its own printf() implementation that is derived from an early version of the SQLite printf() implementation, but those two implementations have since diverged.</source>
          <target state="translated">该&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;化石版本控制系统&lt;/a&gt;使用从SQLite的printf（）函数实现的早期版本获得了它自己的printf（）实现，但是这两个实现都因为分歧。</target>
        </trans-unit>
        <trans-unit id="6c9ad5b94e94e6f0742495238eb4e3e441c282ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; version control system (designed and written for the purpose of supporting SQLite development) allows mildly trusted users to enter arbitrary SQL for generating trouble-ticket reports. That SQL is sanitized using the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface, and no exploits have ever been found. But this is an example of potentially hostile agents being able to inject arbitrary SQL into the system.</source>
          <target state="translated">该&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;化石&lt;/a&gt;版本控制系统（设计和支持SQLite开发的目的书面）允许适度信任的用户进入任意的SQL生成故障单报告。使用&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;接口对SQL进行了清理，但从未发现过漏洞利用。但这是一个潜在的敌对代理程序能够向系统中注入任意SQL的示例。</target>
        </trans-unit>
        <trans-unit id="a2df486f32417b087332e328dab63b95863b0d03" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.sqlite.org/sqllogictest&quot; id=&quot;slt&quot;&gt;&lt;b&gt;SQL Logic Test&lt;/b&gt;&lt;/a&gt; or SLT test harness is used to run huge numbers of SQL statements against both SQLite and several other SQL database engines and verify that they all get the same answers. SLT currently compares SQLite against PostgreSQL, MySQL, Microsoft SQL Server, and Oracle 10g. SLT runs 7.2 million queries comprising 1.12GB of test data.</source>
          <target state="translated">在&lt;a href=&quot;https://www.sqlite.org/sqllogictest&quot; id=&quot;slt&quot;&gt;&lt;b&gt;SQL逻辑测试&lt;/b&gt;&lt;/a&gt;或SLT测试工具是用来运行对阵双方SQLite和其他几个SQL数据库引擎的SQL语句的数量巨大，并确认他们都得到同样的答案。SLT当前将SQLite与PostgreSQL，MySQL，Microsoft SQL Server和Oracle 10g进行了比较。SLT运行720万查询，包括1.12GB的测试数据。</target>
        </trans-unit>
        <trans-unit id="d3062c93a43df260caeb23ab2e3ad2153f90cd2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of rows examined by all iterations of the X-th loop.</source>
          <target state="translated">T参数指向的&lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt;变量将设置为第X次循环的所有迭代检查的总行数。</target>
        </trans-unit>
        <trans-unit id="db1220ff947aa3310307b8d1e97a7892f5326b35" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of times that the X-th loop has run.</source>
          <target state="translated">由T参数指向的&lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt;变量将设置为第X个循环运行的总次数。</target>
        </trans-unit>
        <trans-unit id="ffcdafee896254e841c8ceef0c82d886514030ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the V parameter will be set to the total number of rows examined by all iterations of the X-th loop.</source>
          <target state="translated">V参数指向的&lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt;变量将设置为第X次循环的所有迭代检查的总行数。</target>
        </trans-unit>
        <trans-unit id="c0533f74a6fe1362e5ed7a748ce1c72de0f80c71" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the V parameter will be set to the total number of times that the X-th loop has run.</source>
          <target state="translated">V参数指向的&lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt;变量将设置为第X个循环运行的总次数。</target>
        </trans-unit>
        <trans-unit id="d635355782e5d01fca2019b73467bea006012ad0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;intern-v-extern-blob&quot;&gt;Internal Versus External BLOBs&lt;/a&gt; article on this website is an earlier investigation (circa 2011) that uses the same approach as the Jim Gray paper &amp;mdash; storing the blob filenames as entries in the database &amp;mdash; but for SQLite instead of SQL Server.</source>
          <target state="translated">该网站上的《&lt;a href=&quot;intern-v-extern-blob&quot;&gt;内部与外部BLOB》一&lt;/a&gt;文是一项较早的调查（大约在2011年），使用的方法与Jim Gray的论文相同（将blob文件名存储为数据库中的条目），但使用的是SQLite而不是SQL Server。</target>
        </trans-unit>
        <trans-unit id="cf7fb4a466758f27d2e851f548bb98e33d7f26c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang&quot;&gt;SQL language documentation&lt;/a&gt; is converted to use &lt;a href=&quot;syntaxdiagrams&quot;&gt;syntax diagrams&lt;/a&gt; instead of BNF.</source>
          <target state="translated">在&lt;a href=&quot;lang&quot;&gt;SQL语言的文档&lt;/a&gt;转换为使用&lt;a href=&quot;syntaxdiagrams&quot;&gt;语法图&lt;/a&gt;，而不是BNF。</target>
        </trans-unit>
        <trans-unit id="e0edaa5ff21911b0f3da41c0480fbb1aa18847d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command works differently in two respects when foreign key constraints are enabled:</source>
          <target state="translated">启用外键约束时，&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;命令在两个方面的工作方式有所不同：</target>
        </trans-unit>
        <trans-unit id="7f9caf431fddd0486fb12661e16a4ade73718c32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command now gathers statistics on tables even if they have no indices.</source>
          <target state="translated">现在，即使表没有索引，&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令也可以收集表的统计信息。</target>
        </trans-unit>
        <trans-unit id="2e90c478519d8e9b1bd82d0dd1c5b19da711cd5f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement is an SQLite extension that allows two or more databases to be associated to the same database connection and to operate as if they were a single database. The number of simultaneously attached databases is limited to SQLITE_MAX_ATTACHED which is set to 10 by default. The maximum number of attached databases cannot be increased above 125.</source>
          <target state="translated">该&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;语句是一个SQLite扩展，它允许两个或更多的数据库要关联到同一个数据库连接，并进行操作，就好像它们是一个单一的数据库。同时连接的数据库数限制为SQLITE_MAX_ATTACHED，默认情况下设置为10。附加数据库的最大数量不能增加到125以上。</target>
        </trans-unit>
        <trans-unit id="e65f9f430c67e4418373e91a58e15ed50bb5c875" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clause</source>
          <target state="translated">该&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;子句</target>
        </trans-unit>
        <trans-unit id="95bae24e40c487084e590b6911b8c4960cecb060" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_conflict&quot;&gt;conflict resolution algorithm&lt;/a&gt; for the update operation of the DO UPDATE clause is always ABORT. In other words, the behavior is as if the DO UPDATE clause were actually written as &quot;DO UPDATE OR ABORT&quot;. If the DO UPDATE clause encounters any constraint violation, the entire INSERT statement rolls back and halts. This is true even if the DO UPDATE clause is contained within an INSERT statement or a trigger that specifies some other conflict resolution algorithm.</source>
          <target state="translated">DO UPDATE子句的更新操作的&lt;a href=&quot;lang_conflict&quot;&gt;冲突解决算法&lt;/a&gt;始终为ABORT。换句话说，该行为就好像DO UPDATE子句实际上被写为&amp;ldquo; DO UPDATE OR ABORT&amp;rdquo;。如果DO UPDATE子句遇到任何约束冲突，则整个INSERT语句将回滚并暂停。即使DO UPDATE子句包含在INSERT语句或指定其他冲突解决算法的触发器中，也是如此。</target>
        </trans-unit>
        <trans-unit id="3e1a4fb3e81abe601d6a76ca6511292629d722a1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#ifnull&quot;&gt;ifnull()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt; SQL functions are now implemented using in-line VDBE code rather than calling external functions, so that unused arguments need never be evaluated.</source>
          <target state="translated">在&lt;a href=&quot;lang_corefunc#ifnull&quot;&gt;IFNULL（）&lt;/a&gt;和&lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;COALESCE（）&lt;/a&gt; SQL函数是使用在线VDBE代码，而不是调用外部功能，让未使用的参数永远不需要评估现已实现。</target>
        </trans-unit>
        <trans-unit id="b195fd330fb530068f989ff0d4930e52e4333b6b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#length&quot;&gt;length() SQL function&lt;/a&gt; only counts characters up through and excluding the first NUL.</source>
          <target state="translated">的&lt;a href=&quot;lang_corefunc#length&quot;&gt;长度（）SQL函数&lt;/a&gt;只计算字符，直到通过与除第一NUL。</target>
        </trans-unit>
        <trans-unit id="c97e1aa1d73b591cf5ec83039aad0924cf633432" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; is subject to the &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt; limit of &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt;. Hence any printf() result with a width or precision more than the SQLITE_LIMIT_LENGTH will cause an &lt;a href=&quot;rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; error. However, the low-level formatting for the printf() function is done by a subroutine that does not have access to SQLITE_LIMIT_LENGTH. So the low-level formatting is done into a memory allocation that might be considerably larger than SQLITE_LIMIT_LENGTH and the SQLITE_LIMIT_LENGTH check is only performed after all formatting is complete. Thus there might be a transient buffer that exceeds SQLITE_LIMIT_LENGTH. The SQLITE_PRINTF_PRECISION_LIMIT option is an additional check that prevents excess sizes for the transient buffer used inside the low-level formatting subroutine, prior to the SQLITE_LIMIT_LENGTH check.</source>
          <target state="translated">的&lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf（）的SQL函数&lt;/a&gt;是受&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;的极限&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit（） &lt;/a&gt;。因此，任何宽度或精度大于SQLITE_LIMIT_LENGTH的printf（）结果都将导致&lt;a href=&quot;rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt;错误。但是，printf（）函数的低级格式化由无法访问SQLITE_LIMIT_LENGTH的子例程完成。因此，将低级格式化设置为可能远远大于SQLITE_LIMIT_LENGTH的内存分配，并且仅在所有格式化完成后才执行SQLITE_LIMIT_LENGTH检查。因此，可能存在一个超出SQLITE_LIMIT_LENGTH的瞬态缓冲区。SQLITE_PRINTF_PRECISION_LIMIT选项是一项附加检查，可防止在SQLITE_LIMIT_LENGTH检查之前在低级格式化子例程中使用的过渡缓冲区的大小过大。</target>
        </trans-unit>
        <trans-unit id="96634860ea9e8b060f6a1b99af9b163a5a4df212" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#quote&quot;&gt;quote() SQL function&lt;/a&gt; only shows characters up through and excluding the first NUL.</source>
          <target state="translated">该&lt;a href=&quot;lang_corefunc#quote&quot;&gt;报价（）SQL函数&lt;/a&gt;只能显示字符，直到通过和排除第一NUL。</target>
        </trans-unit>
        <trans-unit id="b38d1ab83adc6d5e3ecac3108de3718b731fffb5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#random&quot;&gt;random()&lt;/a&gt; function is obviously non-deterministic because it gives a different answer every time it is invoked. The answers from &lt;a href=&quot;lang_corefunc#changes&quot;&gt;changes()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid()&lt;/a&gt; depend on prior SQL statements, and so they are also non-deterministic. The &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_version()&lt;/a&gt; function is mostly constant, but it can change when SQLite is upgraded, and so even though it always returns the same answer for any particular session, because it can change answers across sessions it is still considered non-deterministic.</source>
          <target state="translated">在&lt;a href=&quot;lang_corefunc#random&quot;&gt;随机（）&lt;/a&gt;函数显然是不确定的，因为它给出了不同的答案每次调用时。&lt;a href=&quot;lang_corefunc#changes&quot;&gt;changes（）&lt;/a&gt;和&lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid（）&lt;/a&gt;的答案取决于先前的SQL语句，因此它们也不是确定性的。该&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_version（）&lt;/a&gt;函数主要是恒定的，但是当SQLite的升级，虽然它总是返回任何特定会话相同的答案也可以改变，所以即使，因为它可以改变整个答案会话它仍然被认为不确定性。</target>
        </trans-unit>
        <trans-unit id="201a260c8bdbe59035cb4cd8dc3341936a60ec2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset(X)&lt;/a&gt; SQL function requires a new interface on the B-tree storage engine, a new opcode in the &lt;a href=&quot;opcode&quot;&gt;virtual machine&lt;/a&gt; that runs SQL statements, and a new conditional in a critical path of the code generator. To avoid that overhead in applications that do not need the utility of sqlite_offset(X), the function is disabled by default.</source>
          <target state="translated">所述&lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset（X）&lt;/a&gt; SQL函数需要对B树存储引擎一个新的接口，在一个新的操作码&lt;a href=&quot;opcode&quot;&gt;的虚拟机&lt;/a&gt;运行SQL语句，并在代码发生器的关键路径新的条件。为了避免不需要sqlite_offset（X）实用程序的应用程序产生开销，默认情况下禁用此功能。</target>
        </trans-unit>
        <trans-unit id="c3ea26516e554b9c3fd98eb6ab42e75e02bdd0a0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr() SQL function&lt;/a&gt; can now also be called &quot;substring()&quot; for compatibility with SQL Server.</source>
          <target state="translated">现在，也可以将&lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr（）SQL函数&lt;/a&gt;称为&amp;ldquo; substring（）&amp;rdquo;，以与SQL Server兼容。</target>
        </trans-unit>
        <trans-unit id="5130992bbae98a73266f7f76541f0aac8e1ee306" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr()&lt;/a&gt; SQL function does not bother to measure the length its entire input string if it is only computing a prefix</source>
          <target state="translated">如果&lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr（）&lt;/a&gt; SQL函数仅计算前缀，则它不会费心测量整个输入字符串的长度</target>
        </trans-unit>
        <trans-unit id="051b877cf20f31f8d1edc5b8d94b799ecd70ba91" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; of a rowid table (if there is one) is usually not the true primary key for the table, in the sense that it is not the unique key used by the underlying &lt;a href=&quot;fileformat2#btree&quot;&gt;B-tree&lt;/a&gt; storage engine. The exception to this rule is when the rowid table declares an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;. In the exception, the INTEGER PRIMARY KEY becomes an alias for the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">rowid表的&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;（如果有）通常不是该表的真正主键，从某种意义上说，它不是基础&lt;a href=&quot;fileformat2#btree&quot;&gt;B树&lt;/a&gt;存储引擎使用的唯一键。当rowid表声明&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;时，此规则例外。例外的是，INTEGER PRIMARY KEY成为&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="d236ba188ef88897dc53c50ffce983697148b3b9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of a rowid table can be accessed (or changed) by reading or writing to any of the &quot;rowid&quot; or &quot;oid&quot; or &quot;_rowid_&quot; columns. Except, if there is a declared columns in the table that use those special names, then those names refer to the declared columns, not to the underlying &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;一个rowid表可以通过读取或写入到任何&amp;ldquo;ROWID&amp;rdquo;或&amp;ldquo;OID&amp;rdquo;或&amp;ldquo;_ROWID_&amp;rdquo;列被访问（或改变）。除非表中有使用这些特殊名称的已声明列，否则这些名称引用已声明的列，而不引用基础&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="57ebcd163f26bc17678c31c9203482eaa22d5842" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of a table must be an integer. Attempt to set the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; to anything other than an integer (or a NULL which will be automatically converted into the next available integer rowid) results in an SQLITE_MISMATCH error.</source>
          <target state="translated">表的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;必须为整数。尝试将&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;设置为非整数（或NULL，它将自动转换为下一个可用的整数rowid）以外的任何值，将导致SQLITE_MISMATCH错误。</target>
        </trans-unit>
        <trans-unit id="feca6ba206a41f2092893b9e83da76d7c569ae87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; statement now accepts an optional list of column names following the view name.</source>
          <target state="translated">现在，&lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;语句在视图名称之后接受列名称的可选列表。</target>
        </trans-unit>
        <trans-unit id="140e631b88f462024e846431476301a80f59bb76" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_datefunc&quot;&gt;Date And Time Functions&lt;/a&gt; are enhanced so that the current time (ex: julianday('now')) is always the same for multiple function invocations within the same &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call.</source>
          <target state="translated">该&lt;a href=&quot;lang_datefunc&quot;&gt;日期和时间函数&lt;/a&gt;的增强，使当前时间（例如：儒略日（&amp;ldquo;现在&amp;rdquo;））始终是相同的内的多个函数调用同一个&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;调用。</target>
        </trans-unit>
        <trans-unit id="50e6d59e6b5b950615232d8af21bbe3ba88f948d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; SQL command is used to obtain a high-level description of the strategy or plan that SQLite uses to implement a specific SQL query. Most significantly, EXPLAIN QUERY PLAN reports on the way in which the query uses database indices. This document is a guide to understanding and interpreting the EXPLAIN QUERY PLAN output. Background information is available separately:</source>
          <target state="translated">该&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN查询计划&lt;/a&gt; SQL命令来获得战略或计划的高级描述的是SQLite的使用，以实现特定的SQL查询。最重要的是，EXPLAIN QUERY PLAN报告查询使用数据库索引的方式。本文档是理解和解释EXPLAIN QUERY PLAN输出的指南。背景信息可单独获得：</target>
        </trans-unit>
        <trans-unit id="20275284a3bb298e3ed89b5acd684907f3305751" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; and &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; prefixes to SQL statements only affect the behavior of the statement during &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. That means that PRAGMA statements that take effect during &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; will behave the same way regardless of whether or not they are prefaced by &quot;EXPLAIN&quot;.</source>
          <target state="translated">SQL语句的&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;和&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;前缀仅影响&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;期间该语句的行为。这意味着在&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;期间生效的PRAGMA语句的行为方式相同，无论它们是否以&amp;ldquo; EXPLAIN&amp;rdquo;开头。</target>
        </trans-unit>
        <trans-unit id="65133dc98116af2c7f0912fa88b4b43954bbc4b2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator</source>
          <target state="translated">该&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;操作</target>
        </trans-unit>
        <trans-unit id="0fa44fcf9bdf1d542216cc05466871344f55fb9a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS operator&lt;/a&gt;</source>
          <target state="translated">该&lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS操作&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b92948d462015f78d114a35cb7f278e70f987a87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS operator&lt;/a&gt; is now able to drive indexes.</source>
          <target state="translated">该&lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS运营商&lt;/a&gt;现在能够推动指数。</target>
        </trans-unit>
        <trans-unit id="b253f85844781796ef1ae81936dfc99cf231cc5a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_expr#like&quot;&gt;ESCAPE&lt;/a&gt; clause of a &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator now overrides wildcard characters, so that the behavior matches what PostgreSQL does.</source>
          <target state="translated">现在，&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;运算符的&lt;a href=&quot;lang_expr#like&quot;&gt;ESCAPE&lt;/a&gt;子句将覆盖通配符，以便该行为与PostgreSQL的行为匹配。</target>
        </trans-unit>
        <trans-unit id="41d7aaefd27d25ac767f490e47e6b7c9452f7e20" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_indexedby&quot;&gt;INDEXED BY&lt;/a&gt; clause</source>
          <target state="translated">该&lt;a href=&quot;lang_indexedby&quot;&gt;收录情况&lt;/a&gt;子句</target>
        </trans-unit>
        <trans-unit id="2b3b6b4eb30c653aa6f7ff986fc3927d49da19df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; command only works if the transaction stack is empty, or in other words if there are no pending transactions. If the transaction stack is not empty when the &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; command is invoked, then the command fails with an error.</source>
          <target state="translated">仅当事务堆栈为空时，换句话说，如果没有挂起的事务，&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;命令才起作用。如果在调用&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;命令时事务堆栈不为空，则该命令将失败并显示错误。</target>
        </trans-unit>
        <trans-unit id="68024f72adbd8a0a422c4b54cc30c9ba1ec76d4a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; command commits all outstanding transactions and leaves the transaction stack empty.</source>
          <target state="translated">该&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;命令提交所有未完成的事务和树叶的交易栈空。</target>
        </trans-unit>
        <trans-unit id="6b3d11e09f03993abe204e129a5f26dcc598fb68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; command now succeeds even if there are pending queries. It returns &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if there are pending incremental BLOB I/O requests.</source>
          <target state="translated">现在，即使有挂起的查询，&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;命令也会成功。如果有未决的增量BLOB I / O请求，它将返回&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="502339818ec9310f1093ba4d9556feff42c6ac87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command without a TO clause rolls backs all transactions and leaves the transaction stack empty.</source>
          <target state="translated">不带TO子句的&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;命令将回滚所有事务，并使事务堆栈为空。</target>
        </trans-unit>
        <trans-unit id="f0b680e1a4603a4a26d05e9463e469518ed706b0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; and &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN EXCLUSIVE&lt;/a&gt; commands now work even if one or more attached database files are read-only.</source>
          <target state="translated">现在，即使一个或多个附加数据库文件是只读的，&lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt;和&lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN EXCLUSIVE&lt;/a&gt;命令也可以使用。</target>
        </trans-unit>
        <trans-unit id="22ed8eeff156b9ac5c3272aebc736d20e9be8ea0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, and &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statements within triggers do not support the full syntax for &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, and &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statements. The following restrictions apply:</source>
          <target state="translated">触发器内的&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;，&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;和&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;语句不支持&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;，&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;和&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;语句的完整语法。适用以下限制：</target>
        </trans-unit>
        <trans-unit id="25fa7af4817ff50638a1d09b6077bfa20413eee0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command packs the database about 1% tighter.</source>
          <target state="translated">该&lt;a href=&quot;lang_vacuum&quot;&gt;真空&lt;/a&gt;命令包约更紧1％的数据库。</target>
        </trans-unit>
        <trans-unit id="6f6f65ccce3c60bd3538bde45dbba0bdabdce834" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command preserves the setting of the &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt;. (Ticket #2804.)</source>
          <target state="translated">该&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令将保留的设置&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format编译&lt;/a&gt;。（票号＃2804。）</target>
        </trans-unit>
        <trans-unit id="47212a8707d0f0bd1679c6ba64f918cc5f5c6039" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command works by creating a temporary file and then rebuilding the entire database into that temporary file. Then the content of the temporary file is copied back into the original database file and the temporary file is deleted.</source>
          <target state="translated">该&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令通过创建一个临时文件，然后将整个数据库重建到该临时文件。然后，将临时文件的内容复制回原始数据库文件，并删除该临时文件。</target>
        </trans-unit>
        <trans-unit id="bdf2bbad9bfa5eb4a9865a13c14cd208bf3e40df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_with&quot;&gt;WITH&lt;/a&gt; clause must occur on the first SELECT of a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt;. It cannot follow a &lt;a href=&quot;syntax/compound-operator&quot;&gt;compound-operator&lt;/a&gt;.</source>
          <target state="translated">的&lt;a href=&quot;lang_with&quot;&gt;WITH&lt;/a&gt;子句必须在第一SELECT发生&lt;a href=&quot;lang_select#compound&quot;&gt;化合物SELECT&lt;/a&gt;。它不能跟随&lt;a href=&quot;syntax/compound-operator&quot;&gt;复合运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db6f4f9f7ee46543ffd0410e2806fc648ca23245" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; creates a faster parser.</source>
          <target state="translated">将&lt;a href=&quot;lemon&quot;&gt;柠檬解析器生成器&lt;/a&gt;产生更快的解析器。</target>
        </trans-unit>
        <trans-unit id="a0ba7e4dcf6a75ed4b1ebb47695358df4a104180" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt; documentation describes how to &lt;a href=&quot;loadext#build&quot;&gt;compile loadable extensions&lt;/a&gt; as shared libraries. The techniques described there work fine for the json1 module.</source>
          <target state="translated">在&lt;a href=&quot;loadext&quot;&gt;连接扩展&lt;/a&gt;文档描述了如何&lt;a href=&quot;loadext#build&quot;&gt;编译加载扩展&lt;/a&gt;的共享库。那里描述的技术对于json1模块工作正常。</target>
        </trans-unit>
        <trans-unit id="01edd329b33f240dcc5cfa34ddb1e15eb22f3ff1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;log&quot;&gt;sqlite3_log()&lt;/a&gt; interface writes a message into the &lt;a href=&quot;../errlog&quot;&gt;error log&lt;/a&gt; established by the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; option to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt;. If logging is enabled, the zFormat string and subsequent arguments are used with &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to generate the final output string.</source>
          <target state="translated">所述&lt;a href=&quot;log&quot;&gt;sqlite3_log（）&lt;/a&gt;接口将消息写入到&lt;a href=&quot;../errlog&quot;&gt;错误日志&lt;/a&gt;由既定&lt;a href=&quot;c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt;选项&lt;a href=&quot;config&quot;&gt;（）sqlite3_config&lt;/a&gt;。如果启用了日志记录，则zFormat字符串和后续参数与&lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;一起使用以生成最终的输出字符串。</target>
        </trans-unit>
        <trans-unit id="4883693c0c81d8dd1cc3d7c0223f243712aeaf0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; is enhanced to support two separate memory pools with different sized allocations in each pool. This allows more memory allocations to be covered by lookaside while at the same time reducing the heap memory usage to 48KB per connection, down from 120KB.</source>
          <target state="translated">所述&lt;a href=&quot;malloc#lookaside&quot;&gt;后备存储器分配器&lt;/a&gt;被增强以支持与在每个池中不同尺寸的分配两个单独的内存池。这样一来，后备空间可以覆盖更多的内存分配，同时将每个连接的堆内存使用量从120KB减少到48KB。</target>
        </trans-unit>
        <trans-unit id="81d8579383d45cb472d3a4833d1ee2e13e4c3902" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;malloc#lookaside&quot;&gt;后备内存分配器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6272b90c1e46ccb51f6a211fb05dce0a9b88e6f6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;.</source>
          <target state="translated">页面&lt;a href=&quot;malloc#pagecache&quot;&gt;高速缓存内存分配器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2033aab7c928977e8c566f6458591e6094a394bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; routine returns the number of bytes of memory currently outstanding (malloced but not freed). The &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; routine returns the maximum value of &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; since the high-water mark was last reset. The values returned by &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; include any overhead added by SQLite in its implementation of &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, but not overhead added by the any underlying system library routines that &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; may call.</source>
          <target state="translated">该&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;例程返回字节的内存目前优秀（malloced但不释放）的数量。该&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;例程返回的最大值&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;以来的高水位标记最后复位。&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;和&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;返回的值包括SQLite在实现&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）时&lt;/a&gt;添加的任何开销，但不包括&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;可能调用的任何基础系统库例程添加的开销。</target>
        </trans-unit>
        <trans-unit id="54555d04b0b2355ea81551452a102d3dd5b8966e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt; interface takes a single argument which is one of these integer constants.</source>
          <target state="translated">所述&lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc（）&lt;/a&gt;接口采用单个参数，它是这些整数常数之一。</target>
        </trans-unit>
        <trans-unit id="6bac46a1cfe1872e452f2e80ec2bbd9faeb289c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode&quot;&gt;bytecode engine&lt;/a&gt; document has more information on the bytecode format used by SQLite, and how to view and interpret an SQLite prepared statement.</source>
          <target state="translated">该&lt;a href=&quot;opcode&quot;&gt;字节码引擎&lt;/a&gt;文档具有对使用SQLite的字节码格式，以及如何查看详细信息，并解释SQLite的预处理语句。</target>
        </trans-unit>
        <trans-unit id="69f893d6e4ed45be57e659539245cae9d67b977d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; program created by the code generator is run by a virtual machine.</source>
          <target state="translated">由代码生成器创建的&lt;a href=&quot;opcode&quot;&gt;字节码&lt;/a&gt;程序由虚拟机运行。</target>
        </trans-unit>
        <trans-unit id="6f82427ae6db3af3b60ee7889919a09e27176099" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Delete&quot;&gt;Delete&lt;/a&gt; does the work of this loop; it pops an integer key off the stack (placed there by the preceding ListRead) and deletes the record of cursor P1 that has that key. Because P2 is true, the row change counter is incremented.</source>
          <target state="translated">该&lt;a href=&quot;opcode#Delete&quot;&gt;删除&lt;/a&gt;确实这个循环的工作; 它从堆栈中弹出一个整数键（由前面的ListRead放在那里），并删除具有该键的游标P1的记录。因为P2是true，所以行更改计数器增加。</target>
        </trans-unit>
        <trans-unit id="49cbb2109ea61f54a2e0e215073c0e8f4e901d2e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Ge&quot;&gt;Ge&lt;/a&gt; operator compares the top two elements on the stack, pops them, and then branches based on the result of the comparison. If the second element is &amp;gt;= the top element, then jump to address P2 (the Next instruction at the end of the loop). Because P1 is true, if either operand is NULL (and thus the result is NULL) then take the jump. If we don't jump, just advance to the next instruction.</source>
          <target state="translated">该&lt;a href=&quot;opcode#Ge&quot;&gt;葛&lt;/a&gt;运算符比较顶部的堆栈中的两个元件，它们弹出，以及基于所述比较的结果然后分支。如果第二个元素&amp;gt; =顶部元素，则跳转到地址P2（循环末尾的Next指令）。因为P1为true，所以如果任一操作数为NULL（因此结果为NULL），则执行跳转。如果我们不跳，则前进到下一条指令。</target>
        </trans-unit>
        <trans-unit id="04783e2a879da777c9928b0ae80c86689e955e7d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Gosub&quot;&gt;Gosub&lt;/a&gt; opcode stores the current program counter into register P1 then jumps to address P2. The &lt;a href=&quot;opcode#Return&quot;&gt;Return&lt;/a&gt; opcode jumps to address P1+1. Hence, every subroutine is associated with two integers: the address of the entry point in the subroutine and the register number that is used to hold the return address.</source>
          <target state="translated">该&lt;a href=&quot;opcode#Gosub&quot;&gt;GOSUB&lt;/a&gt;操作码存储当前程序计数器到寄存器P1，然后跳转到地址P2。在&lt;a href=&quot;opcode#Return&quot;&gt;返回&lt;/a&gt;操作码跳转到地址P1 + 1。因此，每个子例程都与两个整数关联：该子例程中入口点的地址和用于保存返回地址的寄存器号。</target>
        </trans-unit>
        <trans-unit id="cc4a6e0d461e428b5be9265ddcc51214a7a17162" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Goto&quot;&gt;Goto&lt;/a&gt; jumps back to the beginning of the loop. This is the end of the loop.</source>
          <target state="translated">将&lt;a href=&quot;opcode#Goto&quot;&gt;跳转&lt;/a&gt;跳回循环的开始。这是循环的结尾。</target>
        </trans-unit>
        <trans-unit id="36b42b8529eed45ca4088e7606ce454bf579c098" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ListRead&quot;&gt;ListRead&lt;/a&gt; instruction reads an element from the temporary storage list and pushes it onto the stack. If this was successful, it continues to the next instruction. If this fails because the list is empty, it branches to P2, which is the instruction just after the loop. Afterwards the stack looks like:</source>
          <target state="translated">所述&lt;a href=&quot;opcode#ListRead&quot;&gt;ListRead&lt;/a&gt;指令读取从临时存储列表中的一个元素，并将其推入堆栈。如果成功，它将继续执行下一条指令。如果由于列表为空而失败，则分支到P2，这是循环之后的指令。之后，堆栈如下所示：</target>
        </trans-unit>
        <trans-unit id="4879ed312fe574048c51b739d2a2e0c47c1cf28a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ListReset&quot;&gt;ListReset&lt;/a&gt; instruction empties the temporary storage list. This list is emptied automatically when the VDBE program terminates, so it isn't necessary in this case. The Close instruction closes the cursor P1. Again, this is done by the VDBE engine when it is finished running this program. The Commit ends the current transaction successfully, and causes all changes that occurred in this transaction to be saved to the database. The final Halt is also unnecessary, since it is added to every VDBE program when it is prepared to run.</source>
          <target state="translated">该&lt;a href=&quot;opcode#ListReset&quot;&gt;ListReset&lt;/a&gt;指令清空临时存储列表。VDBE程序终止时，此列表会自动清空，因此在这种情况下没有必要。关闭指令关闭光标P1。同样，这由VDBE引擎在完成运行该程序时完成。提交成功结束当前事务，并使该事务中发生的所有更改都保存到数据库中。最后的暂停也没有必要，因为它在准备运行时已添加到每个VDBE程序中。</target>
        </trans-unit>
        <trans-unit id="50c0b593163bf5647baef877e0e92b5b46f19553" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ListRewind&quot;&gt;ListRewind&lt;/a&gt; instruction rewinds the temporary storage list to the beginning. This prepares it for use in the second loop.</source>
          <target state="translated">该&lt;a href=&quot;opcode#ListRewind&quot;&gt;ListRewind&lt;/a&gt;指令倒带临时存储列表的开头。这准备好在第二个循环中使用。</target>
        </trans-unit>
        <trans-unit id="d684585d2e3d5fa36d7d1264c013ad5c814a5d30" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; opcode is only valid following an &lt;a href=&quot;opcode#SeekGT&quot;&gt;SeekGT&lt;/a&gt;, &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;, or &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; opcode used to position the cursor. &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; is not allowed to follow &lt;a href=&quot;opcode#SeekLT&quot;&gt;SeekLT&lt;/a&gt;, &lt;a href=&quot;opcode#SeekLE&quot;&gt;SeekLE&lt;/a&gt;, or &lt;a href=&quot;opcode#Last&quot;&gt;Last&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;opcode#Next&quot;&gt;下一步&lt;/a&gt;操作码之后的是唯一有效的&lt;a href=&quot;opcode#SeekGT&quot;&gt;SeekGT&lt;/a&gt;，&lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;，或&lt;a href=&quot;opcode#Rewind&quot;&gt;倒带&lt;/a&gt;用来定位光标的操作码。&lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;不允许跟随&lt;a href=&quot;opcode#SeekLT&quot;&gt;SeekLT&lt;/a&gt;，&lt;a href=&quot;opcode#SeekLE&quot;&gt;SeekLE&lt;/a&gt;或&lt;a href=&quot;opcode#Last&quot;&gt;Last&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4bec0991ede69ff0f5b657d6da948ae6ccecdc12" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; instruction pops the top stack element and uses it as an integer key. If a record with that key does not exist in table P1, then jump to P2. If a record does exist, then fall through to the next instruction. In this case P2 takes us to the Goto at the end of the loop, which jumps back to the ListRead at the beginning. This could have been coded to have P2 be 16, the ListRead at the start of the loop, but the SQLite parser which generated this code didn't make that optimization.</source>
          <target state="translated">所述&lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt;指令弹出堆栈顶部元件和使用它作为一个整数键。如果表P1中不存在具有该键的记录，则跳转到P2。如果确实存在一条记录，则转到下一条指令。在这种情况下，P2将我们带到循环末尾的Goto，然后从头跳回到ListRead。可以将其编码为P2为16，在循环开始时使用ListRead，但是生成此代码的SQLite解析器并未进行优化。</target>
        </trans-unit>
        <trans-unit id="1d15a242c00ad338da3936112e42488d3db597cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; opcode performs the same operation, but with &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; the P3 register must be guaranteed to contain an integer value. With this opcode, register P3 might not contain an integer.</source>
          <target state="translated">所述&lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt;码执行相同的操作，但与&lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; P3寄存器必须保证包含的整数值。使用此操作码，寄存器P3可能不包含整数。</target>
        </trans-unit>
        <trans-unit id="2ea51892f8acadad179e6f2fd2f42516a5edf44d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; opcode performs the same operation on index btrees (with arbitrary multi-value keys).</source>
          <target state="translated">所述&lt;a href=&quot;opcode#NotFound&quot;&gt;NOTFOUND&lt;/a&gt;操作码执行对索引B树相同的操作（具有任意多值的键）。</target>
        </trans-unit>
        <trans-unit id="066073395b0144e2fa69bed2cb062af29a031388" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; opcode is only valid following an &lt;a href=&quot;opcode#SeekLT&quot;&gt;SeekLT&lt;/a&gt;, &lt;a href=&quot;opcode#SeekLE&quot;&gt;SeekLE&lt;/a&gt;, or &lt;a href=&quot;opcode#Last&quot;&gt;Last&lt;/a&gt; opcode used to position the cursor. &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; is not allowed to follow &lt;a href=&quot;opcode#SeekGT&quot;&gt;SeekGT&lt;/a&gt;, &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;, or &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;opcode#Prev&quot;&gt;上一个&lt;/a&gt;操作码之后的是唯一有效的&lt;a href=&quot;opcode#SeekLT&quot;&gt;SeekLT&lt;/a&gt;，&lt;a href=&quot;opcode#SeekLE&quot;&gt;SeekLE&lt;/a&gt;，或&lt;a href=&quot;opcode#Last&quot;&gt;最后&lt;/a&gt;操作码用来定位光标。&lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;不允许关注&lt;a href=&quot;opcode#SeekGT&quot;&gt;SeekGT&lt;/a&gt;，&lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;或&lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e7073f193fc700364fff65aec536137cac5241f6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Recno&quot;&gt;Recno&lt;/a&gt; instruction pushes onto the stack an integer which is the first 4 bytes of the key to the current entry in a sequential scan of the table pointed to by cursor P1. The &lt;a href=&quot;opcode#ListWrite&quot;&gt;ListWrite&lt;/a&gt; instruction writes the integer on the top of the stack into a temporary storage list and pops the top element. This is the important work of this loop, to store the keys of the records to be deleted so we can delete them in the second loop. After this ListWrite instruction the stack is empty again.</source>
          <target state="translated">所述&lt;a href=&quot;opcode#Recno&quot;&gt;Recno中&lt;/a&gt;指令压栈的整数，其是前4个字节的关键，由光标指出P1到表中的顺序扫描的当前条目的。所述&lt;a href=&quot;opcode#ListWrite&quot;&gt;ListWrite&lt;/a&gt;指令写在堆栈的顶部到临时存储列表中的整数和弹出顶部元件。这是此循环的重要工作，用于存储要删除的记录的键，以便我们可以在第二个循环中将其删除。此ListWrite指令之后，堆栈再次为空。</target>
        </trans-unit>
        <trans-unit id="ee3dc9b6c04eaf92dc7b817ad9cb3a0c30096f49" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt; opcode may only be used with P5==0 or P5==OPFLAG_SEEKEQ and with P4 being a P4_KEYINFO object. Furthermore, the P3 value must be the same as every other &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt; or &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; for the same cursor number.</source>
          <target state="translated">所述&lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt;操作码只能与P5 == 0或P5 == OPFLAG_SEEKEQ并用P4是一个P4_KEYINFO对象使用。此外，对于同一光标编号，P3值必须与其他所有&lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt;或&lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="f1b24140a6cba2cd01303fe562cef908cbaa8ca3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt; opcode works like &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; except that it first checks to see if the cursor on P1 is already open on the same b-tree and if it is this opcode becomes a no-op. In other words, if the cursor is already open, do not reopen it.</source>
          <target state="translated">该&lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt;码就像&lt;a href=&quot;opcode#OpenRead&quot;&gt;打开读取&lt;/a&gt;区别在于它首先检查是否在P1上的光标已在同一B树开放的，如果是这样变成码无操作。换句话说，如果游标已经打开，则不要重新打开它。</target>
        </trans-unit>
        <trans-unit id="02cd685549e7ced789f6d67a2427e140b8a8620d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt; opcode causes the bytecode engine to pause and the corresponding &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call to return &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;. Before invoking &lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt;, the bytecoded program will have loaded the results for a single row of a query into a series of registers. C-language APIs such as &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_int()&lt;/a&gt; or &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt; extract the query results from those registers. The bytecode engine resumes with the next instruction after the &lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt; on the next call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt;操作码能够使字节码引擎暂停和相应的&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;来调用返回&lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;。在调用&lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt;之前，字节码程序将查询的单行结果加载到一系列寄存器中。诸如&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_int（）&lt;/a&gt;或&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_text（）之&lt;/a&gt;类的C语言API 从这些寄存器中提取查询结果。字节码引擎在下一次调用&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）时&lt;/a&gt;在&lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt;之后的下一条指令恢复。</target>
        </trans-unit>
        <trans-unit id="f2441406e5ac75bb5fd7cf1919c714faf20d6ab5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; instruction initializes a loop that iterates over the &quot;examp&quot; table. It rewinds the cursor P1 to the first entry in its table. This is required by the Column and Next instructions, which use the cursor to iterate through the table. If the table is empty, then jump to P2 (10), which is the instruction just past the loop. If the table is not empty, fall through to the following instruction at 6, which is the beginning of the loop body.</source>
          <target state="translated">该&lt;a href=&quot;opcode#Rewind&quot;&gt;倒带&lt;/a&gt;指令初始化一个循环，在&amp;ldquo;examp&amp;rdquo;表进行迭代。它将光标P1倒退到其表中的第一个条目。这是&amp;ldquo;列&amp;rdquo;和&amp;ldquo;下一步&amp;rdquo;指令所必需的，它们使用光标在表中进行迭代。如果该表为空，则跳转到P2（10），这是刚刚经过循环的指令。如果表不为空，请转到以下指令（位于循环主体的开头）6。</target>
        </trans-unit>
        <trans-unit id="1ab76354ba245818b171baddec5ddf5d9405c042" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;.P3 and &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;.P4 operands identify an unpacked key which is the desired entry that we want the cursor &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;.P1 to be pointing to. Call this &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;.P4/P5 row the &quot;target&quot;.</source>
          <target state="translated">该&lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt; .P3和&lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt; .P4操作数确定一个解压的关键是，我们希望光标所需的条目&lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt; .P1是指向。将此&lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt; .P4 / P5行称为&amp;ldquo;目标&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2de14c27a6545978f9bf6b60627e8141b94b7884" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#SeekRowid&quot;&gt;SeekRowid&lt;/a&gt; opcode performs the same operation but also allows the P3 register to contain a non-integer value, in which case the jump is always taken. This opcode requires that P3 always contain an integer.</source>
          <target state="translated">所述&lt;a href=&quot;opcode#SeekRowid&quot;&gt;SeekRowid&lt;/a&gt;操作码进行同样的动作，但也可以让P3寄存器包含一个非整数值，在这种情况下，跳转总是采取。此操作码要求P3始终包含一个整数。</target>
        </trans-unit>
        <trans-unit id="4b451f841c2d23194bca9774c72889abafce37d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt; opcode swaps the value of the program counter with the integer value in register P1. This opcode is used to implement coroutines. Coroutines are often used to implement subqueries from which content is pulled on an as-needed basis.</source>
          <target state="translated">的&lt;a href=&quot;opcode#Yield&quot;&gt;产率&lt;/a&gt;操作码交换与在寄存器P1中的整数值的程序计数器的值。此操作码用于实现协程。协程通常用于实现子查询，根据需要从中提取内容。</target>
        </trans-unit>
        <trans-unit id="db4abc1eb0c372a241642380d3b5ec05a20c9f32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;optoverview&quot;&gt;SQLite query planner&lt;/a&gt; and &lt;a href=&quot;queryplanner-ng&quot;&gt;Next Generation Query Planner&lt;/a&gt; documents have further details on the algorithms SQLite uses to implement SQL statements and how it goes above choosing an appropriate algorithm for each individual SQL statement.</source>
          <target state="translated">在&lt;a href=&quot;optoverview&quot;&gt;SQLite的查询规划&lt;/a&gt;和&lt;a href=&quot;queryplanner-ng&quot;&gt;下一代查询计划&lt;/a&gt;文件对算法SQLite的用途进一步的细节来实现SQL语句和它是如何去选择上面为每个单独的SQL语句合适的算法。</target>
        </trans-unit>
        <trans-unit id="2bf8499185976fd90927b75af83cad8ae29ef209" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; optimization is now capable of generating a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; if that is appropriate.</source>
          <target state="translated">的&lt;a href=&quot;optoverview#autoindex&quot;&gt;自动索引&lt;/a&gt;优化现在能够产生的&lt;a href=&quot;partialindex&quot;&gt;局部索引&lt;/a&gt;，如果这是合适的。</target>
        </trans-unit>
        <trans-unit id="430bd4f8cb87deb1b045d791ee37f7bd1ef6a250" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; is allowed to proceed even if the OR expression has also been converted into an IN expression. Uses of the OR optimization are now also &lt;a href=&quot;eqp#or-opt&quot;&gt;more clearly shown&lt;/a&gt; in the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; output.</source>
          <target state="translated">该&lt;a href=&quot;optoverview#or_opt&quot;&gt;OR优化&lt;/a&gt;被允许继续进行，即使OR表达还转换成中的表达。现在，在&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;输出中也&lt;a href=&quot;eqp#or-opt&quot;&gt;更清楚地显示&lt;/a&gt;了OR优化的用法。</target>
        </trans-unit>
        <trans-unit id="d9e2344b1a8686faee26008aaf6a744a538483c1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt; PRAGMA auto_vacuum=incremental&lt;/a&gt; setting is now persistent.</source>
          <target state="translated">该&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA auto_vacuum =增量&lt;/a&gt;设置现在是持久的。</target>
        </trans-unit>
        <trans-unit id="80d34339badbc8db002db2288680cbe2b4fee1a3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;PRAGMA compile_options&lt;/a&gt; command now attempts to show the version number of the compiler that generated the library.</source>
          <target state="translated">该&lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;PRAGMA compile_options&lt;/a&gt;现在命令尝试表明，所产生的库编译器的版本号。</target>
        </trans-unit>
        <trans-unit id="e347c28fc2dc6a091d91c4397055e68e6edfd76f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; should be avoided.</source>
          <target state="translated">所述&lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory编译指示&lt;/a&gt;可以修改此变量并且导致其指向从获得存储器&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;。此外，&lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt;始终假定此变量指向的任何字符串都保存在从&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;获得的内存中，并且pragma可以尝试使用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;释放该内存。因此，如果直接修改此变量，则应将其设置为NULL或指向从&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;获得的内存，否则应避免使用&lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory编译指示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dace9501e55329de3c436aaaf6d76500923f6803" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;PRAGMA defer_foreign_keys=ON&lt;/a&gt; statement now also disables &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;RESTRICT actions&lt;/a&gt; on foreign key.</source>
          <target state="translated">该&lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;PRAGMA defer_foreign_keys = ON&lt;/a&gt;语句现在还禁止&lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;操作限制&lt;/a&gt;外键。</target>
        </trans-unit>
        <trans-unit id="182946c7ddef87f825c408a1e9bcb94b2aebed4e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;defer_foreign_keys pragma&lt;/a&gt; can be used to temporarily change all foreign key constraints to deferred regardless of how they are declared.</source>
          <target state="translated">该&lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;编译defer_foreign_keys&lt;/a&gt;可以用来临时改变所有的外键约束递延不管它们是如何宣布。</target>
        </trans-unit>
        <trans-unit id="be06db32b407171ea5432f85af4fdd64982ffbf0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;database encoding&lt;/a&gt; is UTF-8.</source>
          <target state="translated">该&lt;a href=&quot;pragma#pragma_encoding&quot;&gt;数据库的编码&lt;/a&gt;是UTF-8。</target>
        </trans-unit>
        <trans-unit id="c8f76b3a27760e9d216beb8e378b627c5a5752f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_function_list&quot;&gt;PRAGMA function_list&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_module_list&quot;&gt;PRAGMA module_list&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_pragma_list&quot;&gt;PRAGMA pragma_list&lt;/a&gt; commands are now enabled in all builds by default. Disable them using &lt;a href=&quot;compile#omit_introspection_pragmas&quot;&gt;-DSQLITE_OMIT_INTROSPECTION_PRAGMAS&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;pragma#pragma_function_list&quot;&gt;PRAGMA function_list&lt;/a&gt;，&lt;a href=&quot;pragma#pragma_module_list&quot;&gt;PRAGMA MODULE_LIST&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_pragma_list&quot;&gt;PRAGMA pragma_list&lt;/a&gt;命令现在被启用在所有建立在默认情况下。使用&lt;a href=&quot;compile#omit_introspection_pragmas&quot;&gt;-DSQLITE_OMIT_INTROSPECTION_PRAGMAS&lt;/a&gt;禁用它们。</target>
        </trans-unit>
        <trans-unit id="530eb5492fa66c41d47c216aab5658b932f1fde0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_info&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_index_xinfo&quot;&gt;index_xinfo&lt;/a&gt; pragmas are enhanced to provide information about the on-disk representation of &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">的&lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_info&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_index_xinfo&quot;&gt;index_xinfo&lt;/a&gt;编译指示被增强，以提供有关的磁盘上表示信息&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表。</target>
        </trans-unit>
        <trans-unit id="e422cf4cf15df880c393dd24dbfb049b1fcebe08" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check pragma&lt;/a&gt; is enhanced to detect out-of-order rowids.</source>
          <target state="translated">所述&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;INTEGRITY_CHECK编译&lt;/a&gt;被增强，以检测出的无序的rowid。</target>
        </trans-unit>
        <trans-unit id="2e10d900e5bf7e69cd4dd309e31da996954ece3c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt; is not OFF, MEMORY, or WAL</source>
          <target state="translated">该&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt;未关闭，MEMORY，或WAL</target>
        </trans-unit>
        <trans-unit id="c602efe807a207ac9abab9847aa84a66f50dd768" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt; statement.</source>
          <target state="translated">该&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = OFF&lt;/a&gt;声明。</target>
        </trans-unit>
        <trans-unit id="49dd3e21f049f6bfedb0b7b5b1043722f3e1e37c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; setting is enabled prior to invoking this method, and the value for legacy_alter_table is restored after this method finishes. This is necessary for the correct operation of virtual tables that make use of &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt; where the shadow tables must be renamed to match the new virtual table name. If the legacy_alter_format is off, then the xConnect method will be invoked for the virtual table every time the xRename method tries to change the name of the shadow table.</source>
          <target state="translated">所述&lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt;设置之前调用此方法使能，以及用于legacy_alter_table值被此方法结束后恢复。这对于使用&lt;a href=&quot;vtab#xshadowname&quot;&gt;影子表&lt;/a&gt;的虚拟表的正确操作是必需的，在虚拟表中，影子表必须重命名以匹配新的虚拟表名称。如果legacy_alter_format关闭，则每次xRename方法尝试更改影子表的名称时，将为虚拟表调用xConnect方法。</target>
        </trans-unit>
        <trans-unit id="cd4d57758d0157882a76f0628926b46c59a64bbe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt; is deactivated. It is now a no-op. In its place, the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyfileformat&quot;&gt;SQLITE_DBCONFIG_LEGACY_FILE_FORMAT&lt;/a&gt; option to &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; is provided. The legacy_file_format pragma is deactivated because (1) it is rarely useful and (2) it is incompatible with &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; in schemas that have tables with both generated columns and descending indexes. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6484e6ce678fffab&quot;&gt;6484e6ce678fffab&lt;/a&gt;</source>
          <target state="translated">该&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format编译&lt;/a&gt;被停用。现在是无人值守。&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyfileformat&quot;&gt;取而代之的&lt;/a&gt;是，提供了&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;的SQLITE_DBCONFIG_LEGACY_FILE_FORMAT选项。停用legacy_file_format编译指示是因为（1）它很少有用，并且（2）在具有既具有生成列又具有降序索引的表的模式中，它与&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;不兼容。门票&lt;a href=&quot;https://www.sqlite.org/src/info/6484e6ce678fffab&quot;&gt;6484e6ce678fffab&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb34969d518c763e5a52bf4853965875f5d7c504" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_max_page_count&quot;&gt; max_page_count PRAGMA&lt;/a&gt; can be used to raise or lower this limit at run-time.</source>
          <target state="translated">该&lt;a href=&quot;pragma#pragma_max_page_count&quot;&gt;max_page_count PRAGMA&lt;/a&gt;可以用来提高或降低在运行时此限制。</target>
        </trans-unit>
        <trans-unit id="ed5ae39d1285e1f44b4d8e91bc72231ec08350d0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; statement will never increase the amount of address space used for memory-mapped I/O above the hard limit set by the &lt;a href=&quot;compile#max_mmap_size&quot;&gt;SQLITE_MAX_MMAP_SIZE&lt;/a&gt; compile-time option, nor the hard limit set start-time by the second argument to sqlite3_config(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;)</source>
          <target state="translated">所述&lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;语句将永远不会增加用于地址空间量存储器映射的I / O上述由硬限制集合&lt;a href=&quot;compile#max_mmap_size&quot;&gt;SQLITE_MAX_MMAP_SIZE&lt;/a&gt;编译时的选择，也没有硬限制设定起动时由第二个参数sqlite3_config（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="3bccc6c555afb6a2715bad46795ba129af0dfe49" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; command was first introduced with SQLite 3.18.0 (2017-03-28) and is a no-op for all prior releases of SQLite.</source>
          <target state="translated">的&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA优化&lt;/a&gt;命令首先用SQLite的3.18.0（2017年3月28日）介绍，并且是无操作SQLite的所有以前的版本。</target>
        </trans-unit>
        <trans-unit id="ce8494947b4ce168119d270366337d52ae940b6c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; command will automatically run ANALYZE on individual tables on an as-needed basis. The recommended practice is for applications to invoke the &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; statement just before closing each database connection.</source>
          <target state="translated">的&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA优化&lt;/a&gt;命令将自动运行分析关于各个表的需要的基础上。建议的做法是，应用程序在关闭每个数据库连接之前立即调用&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA优化&lt;/a&gt;语句。</target>
        </trans-unit>
        <trans-unit id="433dda316207c42123f3ff5f78471afdde0a76ae" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;optimize pragma&lt;/a&gt; is usually a no-op but it will occasionally run ANALYZE if it seems like doing so will be useful to the query planner. The &lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;analysis_limit pragma&lt;/a&gt; limits the scope of any ANALYZE command that the &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;optimize pragma&lt;/a&gt; runs so that it does not consume too many CPU cycles. The constant &quot;400&quot; can be adjusted as needed. Values between 100 and 1000 work well for most applications.</source>
          <target state="translated">在&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;优化编译&lt;/a&gt;通常是一个空操作，但它偶尔会运行分析是否好像这样做将是查询规划有用。所述&lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;analysis_limit编译&lt;/a&gt;限制的任何范围分析该命令&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;优化编译&lt;/a&gt;运行，以便它不占用太多的CPU周期。常数&amp;ldquo; 400&amp;rdquo;可以根据需要进行调整。对于大多数应用程序，介于100和1000之间的值效果很好。</target>
        </trans-unit>
        <trans-unit id="5fb4e7b95d0d162ecc58614e1af3f3f6380ba85b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting is not OFF</source>
          <target state="translated">该&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt;设置不是OFF</target>
        </trans-unit>
        <trans-unit id="7b30b153f5bd150efb6f72a306c286fdddb45c5b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; has an integer value which also influences the decision of where to store temporary files. The values of the temp_store pragma have the following meanings:</source>
          <target state="translated">该&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;TEMP_STORE编译&lt;/a&gt;具有一个整数值，这也影响在哪里存储临时文件的决定。temp_store pragma的值具有以下含义：</target>
        </trans-unit>
        <trans-unit id="f4fb45c2bb944888554bf90c8cb9a47bf3f2a979" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; should be avoided. Except when requested by the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, SQLite does not free the memory that sqlite3_temp_directory points to. If the application wants that memory to be freed, it must do so itself, taking care to only do so after all &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; objects have been destroyed.</source>
          <target state="translated">所述&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory编译指示&lt;/a&gt;可以修改此变量并且导致其指向从获得存储器&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;。此外，&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;始终假定此变量指向的任何字符串都保存在从&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;获得的内存中，并且pragma可以尝试使用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;释放该内存。因此，如果直接修改此变量，则应将其设为NULL或指向从&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;获得的内存，否则应避免使用&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory杂注&lt;/a&gt;。除非&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory编译指示有&lt;/a&gt;要求，SQLite不会释放sqlite3_temp_directory指向的内存。如果应用程序希望释放该内存，则它必须自己释放内存，只有在销毁所有&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;对象之后才注意这样做。</target>
        </trans-unit>
        <trans-unit id="b7aff6f6a70787230cfdaa84381a4df9ff6088c1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version&lt;/a&gt; pragmas correctly set their column names in the result set</source>
          <target state="translated">该&lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version&lt;/a&gt;编译指示正确地设置自己的列名的结果集</target>
        </trans-unit>
        <trans-unit id="e69bec34ec00cc126a20d5db14b73449e907cdd5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; can be used to invoke this interface from SQL.</source>
          <target state="translated">该&lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint编译&lt;/a&gt;可以被用来调用从SQL此接口。</target>
        </trans-unit>
        <trans-unit id="dae72cb78cf83086aebe14bf09934eef63425e9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;PRAGMA wal_checkpoint&lt;/a&gt; command can be used to invoke this interface from SQL.</source>
          <target state="translated">的&lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;PRAGMA wal_checkpoint&lt;/a&gt;命令可以被用来调用从SQL此接口。</target>
        </trans-unit>
        <trans-unit id="65a223c3d19041fa0b396d7e3f3b2e302f5459e8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; statement.</source>
          <target state="translated">该&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = ON&lt;/a&gt;语句。</target>
        </trans-unit>
        <trans-unit id="684edbb611cbfa5623d7b600fa16d86090b5ff1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_count(D)&lt;/a&gt; interface returns the number of columns in the row that is being inserted, updated, or deleted.</source>
          <target state="translated">所述&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_count（d）&lt;/a&gt;接口返回正在被插入，更新或删除的行中的列数。</target>
        </trans-unit>
        <trans-unit id="ba2d35feb7b268110f32aac36c1f5d65016e60f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_depth(D)&lt;/a&gt; interface returns 0 if the preupdate callback was invoked as a result of a direct insert, update, or delete operation; or 1 for inserts, updates, or deletes invoked by top-level triggers; or 2 for changes resulting from triggers called by top-level triggers; and so forth.</source>
          <target state="translated">所述&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_depth（d）&lt;/a&gt;接口返回0，如果更新前的回调被调用作为直接插入，更新或删除操作的结果; 或1表示由顶级触发器调用的插入，更新或删除；或2表示由顶级触发器调用的触发器引起的更改；等等。</target>
        </trans-unit>
        <trans-unit id="61dec61cb0cf17103a6811f56ba836ebb2ef7198" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; interface registers a callback function that is invoked prior to each &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; operation on a database table. At most one preupdate hook may be registered at a time on a single &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;; each call to &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; overrides the previous setting. The preupdate hook is disabled by invoking &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; with a NULL pointer as the second parameter. The third parameter to &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; is passed through as the first parameter to callbacks.</source>
          <target state="translated">所述&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook（）&lt;/a&gt;接口寄存器，每当之前调用的回调函数&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;，&lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt;，和&lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt;上的数据库表的操作。在一个&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;上一次最多可以注册一个preupdate挂钩;每次调用&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook（）都会&lt;/a&gt;覆盖先前的设置。通过使用带有NULL指针作为第二个参数的&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook（）&lt;/a&gt;来禁用preupdate挂钩。&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook（）&lt;/a&gt;的第三个参数作为第一个参数传递给回调。</target>
        </trans-unit>
        <trans-unit id="8df93bf8497a2d78f6914976e1609ba432170056" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_new(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row after it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_INSERT and SQLITE_UPDATE preupdate callbacks; if it is used by an SQLITE_DELETE callback then the behavior is undefined. The &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="translated">所述&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_new（d，N，P）&lt;/a&gt;接口写为P指针的&lt;a href=&quot;value&quot;&gt;保护sqlite3_value&lt;/a&gt;包含表行的第N列的值被更新后。 N参数必须比列数少0到1之间，否则行为将是不确定的。只能在SQLITE_INSERT和SQLITE_UPDATE预更新回调中使用；如果它由SQLITE_DELETE回调使用，则该行为未定义。当preupdate回调返回时，P指向的&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;将被销毁。</target>
        </trans-unit>
        <trans-unit id="aeb8933cda6d990d1669eb3665d8053606aee0ba" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_old()&lt;/a&gt;, &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_new()&lt;/a&gt;, &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_count()&lt;/a&gt;, and &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_depth()&lt;/a&gt; interfaces provide additional information about a preupdate event. These routines may only be called from within a preupdate callback. Invoking any of these routines from outside of a preupdate callback or with a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; pointer that is different from the one supplied to the preupdate callback results in undefined and probably undesirable behavior.</source>
          <target state="translated">所述&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_old（） &lt;/a&gt;，&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_new（） &lt;/a&gt;，&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_count（） &lt;/a&gt;，和&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_depth（）&lt;/a&gt;接口提供关于更新前的事件的其他信息。这些例程只能在更新前的回调中调用。从预更新回调之外或使用与提供给预更新回调的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;指针不同的数据库连接指针来调用这些例程中的任何一个都会导致未定义的行为，并且可能是不良行为。</target>
        </trans-unit>
        <trans-unit id="dd30234761e0c7ea9f1053536a7bfab89c37bb25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_old(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row before it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_UPDATE and SQLITE_DELETE preupdate callbacks; if it is used by an SQLITE_INSERT callback then the behavior is undefined. The &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="translated">所述&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_old（d，N，P）&lt;/a&gt;接口写为P指针的&lt;a href=&quot;value&quot;&gt;保护sqlite3_value&lt;/a&gt;包含表行的第N列的值被更新之前。N参数必须比列数少0到1之间，否则行为将是不确定的。只能在SQLITE_UPDATE和SQLITE_DELETE预更新回调中使用；如果它由SQLITE_INSERT回调使用，则该行为是未定义的。当preupdate回调返回时，P指向的&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;将被销毁。</target>
        </trans-unit>
        <trans-unit id="6f6dd20be85a6ee9376cfe67d011732f51298a56" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;queryplanner-ng&quot;&gt;next generation query planner&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;queryplanner-ng&quot;&gt;下一代查询规划&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0815af1640f3451efe07a076fe65835b297a94b7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;query planner checklist&lt;/a&gt; describes steps that application developers should following to help resolve query planner problems. Notice the that the use of INDEXED BY is a last resort, to be used only when all other measures fail.</source>
          <target state="translated">该&lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;查询规划的清单&lt;/a&gt;描述了应用程序开发人员应该如下，以帮助解决查询规划问题的步骤。请注意，使用INDEXED BY是最后的手段，仅在所有其他措施失败时才使用。</target>
        </trans-unit>
        <trans-unit id="0c1b5fdf8ac1234008ffa858abbdb051486a832c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;rescode#busy_snapshot&quot;&gt;SQLITE_BUSY_SNAPSHOT&lt;/a&gt; extended error code is returned in WAL mode when a read transaction cannot be upgraded to a write transaction because the read is on an older snapshot.</source>
          <target state="translated">该&lt;a href=&quot;rescode#busy_snapshot&quot;&gt;SQLITE_BUSY_SNAPSHOT&lt;/a&gt;扩展错误代码在WAL模式返回时，一个读事务无法升级到写事务，因为读是旧的快照。</target>
        </trans-unit>
        <trans-unit id="a55e40d30155becf01edc33f7916ec42f8c15006" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface does not change the values of any &lt;a href=&quot;bind_blob&quot;&gt;bindings&lt;/a&gt; on the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S.</source>
          <target state="translated">所述&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（S）&lt;/a&gt;接口不改变任何的值&lt;a href=&quot;bind_blob&quot;&gt;绑定&lt;/a&gt;在&lt;a href=&quot;stmt&quot;&gt;准备的语句&lt;/a&gt; S.</target>
        </trans-unit>
        <trans-unit id="3841b0084bc10aa5540a5c6c5c96fb98131e7bf0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface resets the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S back to the beginning of its program.</source>
          <target state="translated">该&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（S）&lt;/a&gt;接口重置&lt;a href=&quot;stmt&quot;&gt;准备好的声明&lt;/a&gt; S回其计划的开始。</target>
        </trans-unit>
        <trans-unit id="540e7b1566721b5eeac705b77c4d701d37c07cab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; returns this result code when an attempt is made to update the R-Tree while another prepared statement is actively reading the R-Tree. The update cannot proceed because any change to an R-Tree might involve reshuffling and rebalancing of nodes, which would disrupt read cursors, causing some rows to be repeated and other rows to be omitted.</source>
          <target state="translated">当另一个准备好的语句正在主动读取R-Tree时，尝试更新R-Tree时，&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展&lt;/a&gt;返回此结果代码。更新无法继续进行，因为对R-Tree的任何更改都可能涉及节点的重新组合和重新平衡，这将破坏读取游标，从而导致某些行被重复，而另一些行将被省略。</target>
        </trans-unit>
        <trans-unit id="b4b6d7c356a19c81f66c0c808b762014df51dab6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt; supports shared-cache read and write locks in the same way as all other database tables (see description above). The following special rules also apply:</source>
          <target state="translated">所述&lt;a href=&quot;schematab&quot;&gt;sqlite_schema表&lt;/a&gt;支持共享高速缓冲存储器读取和写锁以相同的方式，因为所有的其它数据库表（参见上面的描述）。以下特殊规则也适用：</target>
        </trans-unit>
        <trans-unit id="ea902d70a5e8f00659c3f526b5f4eb510993f6a6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;series&quot;&gt;generate_series(START,END,STEP)&lt;/a&gt; table-valued function extension is now built into the CLI.</source>
          <target state="translated">该&lt;a href=&quot;series&quot;&gt;generate_series（START，END，STEP）&lt;/a&gt;表值函数扩展现在内置的CLI。</target>
        </trans-unit>
        <trans-unit id="7707f3c0dce0c68c0fd1c390c4bccf3ca9ffcb57" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;session/sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; API is called to create and initialize an iterator to iterate through the contents of a changeset. Initially, the iterator points to no element at all.</source>
          <target state="translated">所述&lt;a href=&quot;session/sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt; API被调用以创建并通过变更的内容初始化的迭代器进行迭代。最初，迭代器根本没有指向任何元素。</target>
        </trans-unit>
        <trans-unit id="e2c05e642dac6053ce210738d48ce79ebc45ba34" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;set_authorizer&quot;&gt;authorizer callback function&lt;/a&gt; must return either &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; or one of these two constants in order to signal SQLite whether or not the action is permitted. See the &lt;a href=&quot;set_authorizer&quot;&gt;authorizer documentation&lt;/a&gt; for additional information.</source>
          <target state="translated">该&lt;a href=&quot;set_authorizer&quot;&gt;授权回调函数&lt;/a&gt;必须返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;以信号SQLite的动作是否被允许或这两个常量之一。有关其他信息，请参见&lt;a href=&quot;set_authorizer&quot;&gt;授权者文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4b9f192cd368c894585cf856c53081dab4346439" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface registers a callback function that is invoked to authorize certain SQL statement actions. The second parameter to the callback is an integer code that specifies what action is being authorized. These are the integer action codes that the authorizer callback may be passed.</source>
          <target state="translated">该&lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;接口寄存器被调用以授权某些SQL语句操作的回调函数。回调的第二个参数是整数代码，用于指定要授权的操作。这些是授权者回调可以传递的整数操作代码。</target>
        </trans-unit>
        <trans-unit id="c88888932989847ef34ae0441a4a296cbf9342ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object returned from a successful call to &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; must be freed using &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; to avoid a memory leak.</source>
          <target state="translated">成功调用&lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get（）&lt;/a&gt;返回的&lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt;对象必须使用&lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free（）&lt;/a&gt;释放，以避免内存泄漏。</target>
        </trans-unit>
        <trans-unit id="334527e56ba0a296ee1d1034ee6898a348187ebd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; interface is only available when the &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">所述&lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free（）&lt;/a&gt;的接口时仅可&lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt;用于编译时选择。</target>
        </trans-unit>
        <trans-unit id="41f028c2f95ad413ccf78f4f0e636bf684908330" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free(P)&lt;/a&gt; interface destroys &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; P. The application must eventually free every &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object using this routine to avoid a memory leak.</source>
          <target state="translated">所述&lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free（P）&lt;/a&gt;接口破阵&lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; P.应用程序必须最终释放每&lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt;使用此程序以避免内存泄漏对象。</target>
        </trans-unit>
        <trans-unit id="b60983fe9853f804b509f3ca97ea438091fe792b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; interface is only available when the &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">所述&lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get（）&lt;/a&gt;的接口时仅可&lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt;用于编译时选择。</target>
        </trans-unit>
        <trans-unit id="f3e22e1c7c111b00a70790db9ce08d967e255fcd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface attempts to make a new &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object that records the current state of schema S in database connection D. On success, the &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface writes a pointer to the newly created &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object into *P and returns SQLITE_OK. If there is not already a read-transaction open on schema S when this function is called, one is opened automatically.</source>
          <target state="translated">该&lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get（d，S，P）&lt;/a&gt;接口尝试建立一个新&lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt;对象，记录模式S的数据库连接D.如果成功了当前的状态，&lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get（d，S，P）&lt;/a&gt;接口写入指针到新创建的&lt;a href=&quot;snapshot&quot;&gt;将sqlite3_snapshot&lt;/a&gt;对象转换为* P并返回SQLITE_OK。如果在调用此函数时在模式S上尚未打开读取事务，则会自动打开该事务。</target>
        </trans-unit>
        <trans-unit id="086ca737ecffa34122715fb37e08e08253d88ee7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface is only available when the &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">所述&lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;的接口时仅可&lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt;用于编译时选择。</target>
        </trans-unit>
        <trans-unit id="511890649947f63b55f8621e1cda37e48d68f4cb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; interface either starts a new read transaction or upgrades an existing one for schema S of &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D such that the read transaction refers to historical &lt;a href=&quot;snapshot&quot;&gt;snapshot&lt;/a&gt; P, rather than the most recent change to the database. The &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface returns SQLITE_OK on success or an appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if it fails.</source>
          <target state="translated">该&lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open（d，S，P）&lt;/a&gt;接口或者开始一个新的读事务或升级现有的架构的小号&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; d使得读事务是指历史&lt;a href=&quot;snapshot&quot;&gt;快照&lt;/a&gt; P，而不是最近的更改到数据库。所述&lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;接口返回成功或适当SQLITE_OK &lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;，如果它失败。</target>
        </trans-unit>
        <trans-unit id="4cef92cfdf633fc0c634b624e8f2e6727a6b4196" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; extension allows the application to optionally specify the rowid for each INSERT.</source>
          <target state="translated">所述&lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt;扩展允许应用程序有选择地指定为每个插入的rowid。</target>
        </trans-unit>
        <trans-unit id="d837c3195216596d022a1ac6dfae8f94ace29826" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;spellfix1#editdist3&quot;&gt;editdist3()&lt;/a&gt; edit-distance function can also be selected or deselected at run-time by inserting an appropriate string into the &quot;command&quot; column of the virtual table:</source>
          <target state="translated">通过在虚拟表的&amp;ldquo;命令&amp;rdquo;列中插入适当的字符串，还可以在运行时选择或取消选择&lt;a href=&quot;spellfix1#editdist3&quot;&gt;editdist3（）&lt;/a&gt;编辑距离函数：</target>
        </trans-unit>
        <trans-unit id="832a2975224a148de7d49b3ae21cbf638061bcda" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive&lt;/a&gt; idea shows how SQLite can be used as a substitute for ZIP archives or Tarballs. An archive of files stored in SQLite is only very slightly larger, and in some cases actually smaller, than the equivalent ZIP archive. And an SQLite archive features incremental and atomic updating and the ability to store much richer metadata.</source>
          <target state="translated">在&lt;a href=&quot;sqlar&quot;&gt;SQLite的归档&lt;/a&gt;想法节目的SQLite如何被用作ZIP压缩文件或压缩包的替代品。与等效的ZIP存档相比，存储在SQLite中的文件存档仅稍大，在某些情况下实际上较小。SQLite存档具有增量和原子更新功能，并能够存储更丰富的元数据。</target>
        </trans-unit>
        <trans-unit id="e695129653037caa8407461dbbd9ea2a46762ce1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; pointer D in a call to &lt;a href=&quot;next_stmt&quot;&gt;sqlite3_next_stmt(D,S)&lt;/a&gt; must refer to an open database connection and in particular must not be a NULL pointer.</source>
          <target state="translated">调用&lt;a href=&quot;next_stmt&quot;&gt;sqlite3_next_stmt（D，S）时&lt;/a&gt;的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;指针D 必须引用打开的数据库连接，并且尤其不能为NULL指针。</target>
        </trans-unit>
        <trans-unit id="48a912a810b3a28ec149be0106a75289dbfa6333" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_append(X,S,N)&lt;/a&gt; method appends exactly N bytes from string S onto the end of the &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X. N must be non-negative. S must contain at least N non-zero bytes of content. To append a zero-terminated string in its entirety, use the &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendall()&lt;/a&gt; method instead.</source>
          <target state="translated">所述&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_append（X，S，N）&lt;/a&gt;方法附加恰好从串S N字节到的端&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;对象X. N必须是非负的。S必须包含至少N个非零字节的内容。要完整地附加一个以零结尾的字符串，请改用&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendall（）&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="1fad1c80b91150cb25ef6b94b5eb5de73c5d25b7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendall(X,S)&lt;/a&gt; method appends the complete content of zero-terminated string S onto the end of &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="translated">所述&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendall（X，S）&lt;/a&gt;方法附加零终止的字符串S的完整内容到的端&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;对象X.</target>
        </trans-unit>
        <trans-unit id="b0fd412f541ab2a0f3d35988066ed4e8e4128c77" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendchar(X,N,C)&lt;/a&gt; method appends N copies of the single-byte character C onto the end of &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X. This method can be used, for example, to add whitespace indentation.</source>
          <target state="translated">所述&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendchar（X，N，C）&lt;/a&gt;方法追加单字节字符的C N份到的端&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;对象X.，可以使用此方法，例如，添加空格缩进。</target>
        </trans-unit>
        <trans-unit id="8a49ade027432cc3ca56bc0bb1633c34a874ad30" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendf(X,F,...)&lt;/a&gt; and &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_vappendf(X,F,V)&lt;/a&gt; interfaces uses the &lt;a href=&quot;../printf&quot;&gt;built-in printf&lt;/a&gt; functionality of SQLite to append formatted text onto the end of &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="translated">所述&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendf（X，F，...）&lt;/a&gt;和&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_vappendf（X，F，V）&lt;/a&gt;接口使用&lt;a href=&quot;../printf&quot;&gt;内置的printf&lt;/a&gt;的SQLite的功能来格式化文本追加到的末尾&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;对象X.</target>
        </trans-unit>
        <trans-unit id="8207628b57fa2acb2222184f79be191c7783d2ec" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_reset(X)&lt;/a&gt; method resets the string under construction inside &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X back to zero bytes in length.</source>
          <target state="translated">所述&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_reset（X）&lt;/a&gt;方法重置在建字符串里面&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;长度对象X回零个字节。</target>
        </trans-unit>
        <trans-unit id="3979188fa64e50e829929b1acf8c993dc30e5490" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; method returns the current length, in bytes, of the dynamic string under construction in &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X. The length returned by &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; does not include the zero-termination byte.</source>
          <target state="translated">所述&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length（X）&lt;/a&gt;方法返回的当前长度，以字节为单位，正在建设中的动态字符串的&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;对象X.由返回的长度&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length（X）&lt;/a&gt;不包括零终止字节。</target>
        </trans-unit>
        <trans-unit id="94c6db74a667c1ebd14fbec47092019e01e83407" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; method returns a pointer to the current content of the dynamic string under construction in X. The value returned by &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; is managed by the sqlite3_str object X and might be freed or altered by any subsequent method on the same &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object. Applications must not used the pointer returned &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; after any subsequent method call on the same object. Applications may change the content of the string returned by &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; as long as they do not write into any bytes outside the range of 0 to &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; and do not read or write any byte after any subsequent sqlite3_str method call.</source>
          <target state="translated">所述&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value（X）&lt;/a&gt;方法返回指向在建X.动态串由返回的值的当前内容&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value（X）&lt;/a&gt;是由sqlite3_str对象X管理，并且可能由任何随后的方法在相同的被释放的或改变的&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;对象。在同一对象上进行任何后续方法调用之后，应用程序都不得使用返回的&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value（X）&lt;/a&gt;指针。应用程序可以更改&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value（X）&lt;/a&gt;返回的字符串的内容，只要它们不写入0到&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length（X）&lt;/a&gt;范围之外的任何字节，并且在后续任何sqlite3_str方法调用之后不读取或写入任何字节。</target>
        </trans-unit>
        <trans-unit id="7e06028d8d9a37c76976481d45631c9360b94773" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface destroys the sqlite3_str object X and returns a pointer to a memory buffer obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; that contains the constructed string. The calling application should pass the returned value to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; to avoid a memory leak. The &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface may return a NULL pointer if any errors were encountered during construction of the string. The &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface will also return a NULL pointer if the string in &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X is zero bytes long.</source>
          <target state="translated">所述&lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish（X）&lt;/a&gt;的界面破坏sqlite3_str对象X，并返回一个指针，从缓冲器得到的存储器&lt;a href=&quot;free&quot;&gt;（）sqlite3_malloc64&lt;/a&gt;包含构造的字符串。调用应用程序应将返回的值传递给&lt;a href=&quot;free&quot;&gt;sqlite3_free（），&lt;/a&gt;以避免内存泄漏。该&lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish（X）&lt;/a&gt;接口可返回NULL指针，如果施工字符串的过程中遇到的任何错误。如果&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;对象X中的字符串的长度为零字节，则&lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish（X）&lt;/a&gt;接口还将返回NULL指针。</target>
        </trans-unit>
        <trans-unit id="893b46b38f797cff31c49b4ea957f7271c4d11b6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface allocates and initializes a new &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object. To avoid memory leaks, the object returned by &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt; must be freed by a subsequent call to &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new（d）&lt;/a&gt;接口分配和初始化一个新&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;对象。为了避免内存泄漏，必须通过随后调用&lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish（X）&lt;/a&gt;来释放&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;返回的对象。</target>
        </trans-unit>
        <trans-unit id="c8f2751d83d7d253a00544efb010e3f4e128798b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface always returns a pointer to a valid &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object, though in the event of an out-of-memory error the returned object might be a special singleton that will silently reject new text, always return SQLITE_NOMEM from &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode()&lt;/a&gt;, always return 0 for &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length()&lt;/a&gt;, and always return NULL from &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;. It is always safe to use the value returned by &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; as the sqlite3_str parameter to any of the other &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; methods.</source>
          <target state="translated">该&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new（d）&lt;/a&gt;接口总是返回一个指向一个有效的&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;对象，虽然在内存不足，错误的情况下返回的对象可能是一个特殊的单，将默默地拒绝新的文字，总是从返回SQLITE_NOMEM &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode（）&lt;/a&gt;，对于&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length（）&lt;/a&gt;总是返回0 ，而对于&lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish（X）&lt;/a&gt;总是返回NULL 。将&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new（D）&lt;/a&gt;返回的值用作其他任何&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;方法的sqlite3_str参数始终是安全的。</target>
        </trans-unit>
        <trans-unit id="4893933da22367d13b4236043c7aa3ee536ea00a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern P. The definition of &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern matching used in &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; is the same as for the &quot;X GLOB P&quot; operator in the SQL dialect understood by SQLite. The &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; function is case sensitive.</source>
          <target state="translated">所述&lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob（P，X）&lt;/a&gt;接口返回零当且仅当序列X的匹配&lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;图案P上的定义&lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;中使用图案匹配&lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob（P，X）&lt;/a&gt;是与用于在所述&amp;ldquo;X GLOB P&amp;rdquo;算子SQLite可以理解的SQL方言。所述&lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob（P，X）&lt;/a&gt;函数是大小写敏感的。</target>
        </trans-unit>
        <trans-unit id="e174ba8e6223c998f458135f997fdab25603db49" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; APIs allow applications and extensions to compare the contents of two buffers containing UTF-8 strings in a case-independent fashion, using the same definition of &quot;case independence&quot; that SQLite uses internally when comparing identifiers.</source>
          <target state="translated">所述&lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp（）&lt;/a&gt;和&lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp（）&lt;/a&gt; API允许应用程序和扩展，以比较两种含在壳体无关的方式UTF-8字符串两个缓冲区的内容，使用&amp;ldquo;的情况下独立&amp;rdquo;的是比较的SQLite标识符时，在内部使用的相同的定义。</target>
        </trans-unit>
        <trans-unit id="f2f61b252192f444bf8f6f8d93e248db03a4d372" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function matches Unicode characters, though only ASCII characters are case folded.</source>
          <target state="translated">所述&lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike（P，X，E）&lt;/a&gt;函数匹配Unicode字符，虽然只有ASCII字符区分折叠。</target>
        </trans-unit>
        <trans-unit id="8540813014d56ead7baf2b2daf047a27f8df8c32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern P with escape character E. The definition of &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern matching used in &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; is the same as for the &quot;X LIKE P ESCAPE E&quot; operator in the SQL dialect understood by SQLite. For &quot;X LIKE P&quot; without the ESCAPE clause, set the E parameter of &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; to 0. As with the LIKE operator, the &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function is case insensitive - equivalent upper and lower case ASCII characters match one another.</source>
          <target state="translated">所述&lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike（P，X，E）&lt;/a&gt;接口返回零当且仅当序列X匹配&lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt;用转义字符E的定义图案P &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt;中使用的模式匹配&lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike（P，X，E）&lt;/a&gt;是相同的SQLite可以理解的SQL方言中的&amp;ldquo; X LIKE P ESCAPE E&amp;rdquo;运算符。对于不带ESCAPE子句的&amp;ldquo; X LIKE P&amp;rdquo;，请将&lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike（P，X，E）&lt;/a&gt;的E参数设置为0。与LIKE运算符一样，&lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike（P，X，E）&lt;/a&gt;函数不区分大小写-等效的上和下小写ASCII字符相互匹配。</target>
        </trans-unit>
        <trans-unit id="b590daec041ad3dfdb7873bcc65da23e4c6a89cf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;syntaxdiagrams&quot;&gt;syntax diagrams&lt;/a&gt; are now implemented as &lt;a href=&quot;https://pikchr.org/&quot;&gt;Pikchr&lt;/a&gt; scripts and rendered as SVG for improved legibility and ease of maintenance.</source>
          <target state="translated">在&lt;a href=&quot;syntaxdiagrams&quot;&gt;语法图&lt;/a&gt;现在实现为&lt;a href=&quot;https://pikchr.org/&quot;&gt;Pikchr&lt;/a&gt;脚本，并呈现为SVG改进的易读性和易于维护。</target>
        </trans-unit>
        <trans-unit id="4c4bc6f080bcb0613b19c8e24f2c8215e3263de6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; has been enhanced to use the &lt;a href=&quot;http://www.tcl-lang.org/cgi-bin/tct/tip/322.html&quot;&gt;Non-Recursive Engine (NRE)&lt;/a&gt; interface to the TCL interpreter when linked against TCL 8.6 or later.</source>
          <target state="translated">当与TCL 8.6或更高版本链接时，&lt;a href=&quot;tclsqlite&quot;&gt;TCL接口&lt;/a&gt;已得到增强，可以使用&lt;a href=&quot;http://www.tcl-lang.org/cgi-bin/tct/tip/322.html&quot;&gt;非递归引擎（NRE）&lt;/a&gt;接口连接到TCL解释器。</target>
        </trans-unit>
        <trans-unit id="23310616ad13ff4bf64157f6f266be2fa9a80e64" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz&lt;/a&gt; fuzzer also does an excellent job of verifying that SQLite responds sanely to malformed database files.</source>
          <target state="translated">该&lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz&lt;/a&gt;模糊器也确实验证了SQLite的三立响应畸形数据库文件的出色。</target>
        </trans-unit>
        <trans-unit id="de4e73f7d156e22fa7106d9f30fd3d58ff51bfbf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;testing#slt&quot;&gt;SQL Logic Tests&lt;/a&gt; are a set of test cases designed to show that SQLite behaves the same as other SQL database engines. These tests are hosted in a separate code public repository.</source>
          <target state="translated">在&lt;a href=&quot;testing#slt&quot;&gt;SQL逻辑测试&lt;/a&gt;是一组测试案例，旨在表明SQLite的行为与其他SQL的数据库引擎。这些测试托管在单独的代码公共存储库中。</target>
        </trans-unit>
        <trans-unit id="5f65ab47a0f86c2f22ae6f2632075f4320a179c7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;th3&quot;&gt;Test Harness #3&lt;/a&gt; or &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; test suite is a private set of test cases used to test SQLite to 100% MC/DC in an as-delivered configuration. TH3 sources are served on the same servers as the other SQLite repositories, but differ from the others in being proprietary. The TH3 code is only accessible to SQLite developers.</source>
          <target state="translated">该&lt;a href=&quot;th3&quot;&gt;测试工具＃3&lt;/a&gt;或&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;测试套件的私人组在作为递送配置用于测试的SQLite至100％MC / DC测试用例。TH3源与其他SQLite存储库在同一服务器上提供服务，但在专有性上与其他SQLite存储库不同。TH3代码仅适用于SQLite开发人员。</target>
        </trans-unit>
        <trans-unit id="e8a696ccc2b635cda261283e62314013cf8db5a9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes(D)&lt;/a&gt; interface only reports the number of rows that changed due to SQL statement run against database connection D. Any changes by other database connections are ignored. To detect changes against a database file from other database connections use the &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command or the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;file control&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes（d）&lt;/a&gt;接口只报告改变由于SQL语句的运行对数据库连接D.其他数据库连接的任何改变都将被忽略的行数。要检测来自其他数据库连接的数据库文件的更改，请使用&lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt;命令或&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION &lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;文件控件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f49c08b6ed161fe2560890c885dd50855619ba24" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;uintcseq&quot;&gt;UINT collating sequence&lt;/a&gt; extension is automatically loaded</source>
          <target state="translated">所述&lt;a href=&quot;uintcseq&quot;&gt;UINT排序序列&lt;/a&gt;扩展被自动加载</target>
        </trans-unit>
        <trans-unit id="5a2803f974353bfc4cbf30a15e234d493460a39f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;versionnumbers&quot;&gt;version numbering conventions&lt;/a&gt; for SQLite are revised to use the emerging standard of &lt;a href=&quot;http://semver.org/&quot;&gt;semantic versioning&lt;/a&gt;.</source>
          <target state="translated">修改了SQLite 的&lt;a href=&quot;versionnumbers&quot;&gt;版本编号约定&lt;/a&gt;，以使用新兴的&lt;a href=&quot;http://semver.org/&quot;&gt;语义版本控制&lt;/a&gt;标准。</target>
        </trans-unit>
        <trans-unit id="6ca284a5c0b69f330d98de127457542bdad0ece1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16) adds a new device characteristic named &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt;. Database files that report this characteristic are assumed to reside on storage systems that have the powersafe overwrite property. The default unix and windows &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; now report &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; if SQLite is compiled with &lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;-DSQLITE_POWERSAFE_OVERWRITE=1&lt;/a&gt; or they make the legacy assumption that storage does not have the powersafe overwrite property if compiled with &lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;-DSQLITE_POWERSAFE_OVERWRITE=0&lt;/a&gt;. For now, the default is for powersafe overwrite to be turned on, though we may revisit this in the future and default it off.</source>
          <target state="translated">用于SQLite 的&lt;a href=&quot;vfs&quot;&gt;VFS &lt;/a&gt;&lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;版本3.7.10&lt;/a&gt;（2012-01-16）添加了一个名为&lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt;的新设备特征。假定报告此特性的数据库文件驻留在具有powersafe overwrite属性的存储系统上。现在，如果使用&lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;-DSQLITE_POWERSAFE_OVERWRITE = 1&lt;/a&gt;编译SQLite，或者使用&lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;-DSQLITE_POWERSAFE_OVERWRITE = 0&lt;/a&gt;编译存储，则默认的unix和Windows &lt;a href=&quot;vfs&quot;&gt;VFS会&lt;/a&gt;报告&lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt;。目前，默认情况下将打开电源安全覆盖功能，尽管我们将来可能会重新访问它并将其默认设置为关闭。</target>
        </trans-unit>
        <trans-unit id="28df118ed088f75e95fa60751c2ccab88df9bbf6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xbestindex&quot;&gt;sqlite3_module.xBestIndex&lt;/a&gt; method in the implementation of this table checks for equality constraints against the HIDDEN columns, and uses those as input parameters to determine the range of integer &quot;value&quot; outputs to generate. Reasonable defaults are used for any unconstrained columns. For example, to list all integers between 5 and 50:</source>
          <target state="translated">此表的实现中的&lt;a href=&quot;vtab#xbestindex&quot;&gt;sqlite3_module.xBestIndex&lt;/a&gt;方法检查针对HIDDEN列的相等约束，并将其用作输入参数来确定要生成的整数&amp;ldquo;值&amp;rdquo;输出的范围。合理的默认值用于任何不受约束的列。例如，列出5至50之间的所有整数：</target>
        </trans-unit>
        <trans-unit id="e9cea685ebbde84bdb5186b0eb1062c8517be452" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex&amp;gt;0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and is not checked again by SQLite.</source>
          <target state="translated">该&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;方法必须填写aConstraintUsage []用什么参数传递给xFilter信息。如果argvIndex&amp;gt; 0，则将评估相应aConstraint []的右侧，并成为argv中的第argvIndex个条目。如果aConstraintUsage []。omit为true，则假定该约束已由虚拟表完全处理，并且SQLite不再对其进行检查。</target>
        </trans-unit>
        <trans-unit id="f8ae1ca39afc04ccf6f18ad86632ba85cedd64de" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex&amp;gt;0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and might not be checked again by the byte code. The aConstraintUsage[].omit flag is an optimization hint. When the omit flag is left in its default setting of false, the constraint will always be checked separately in byte code. If the omit flag is change to true, then the constraint may or may not be checked in byte code. In other words, when the omit flag is true there is no guarantee that the constraint will not be checked again using byte code.</source>
          <target state="translated">该&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;方法必须填写aConstraintUsage []用什么参数传递给xFilter信息。如果argvIndex&amp;gt; 0，则将评估相应aConstraint []的右侧，并成为argv中的第argvIndex个条目。如果aConstraintUsage []。omit为true，则假定该约束已由虚拟表完全处理，并且字节码可能不会再次对其进行检查。 aConstraintUsage []。omit标志是一个优化提示。当省略标志保留为默认设置false时，将始终以字节码单独检查约束。如果省略标志更改为true，则可以以字节码检查约束，也可以不以字节码检查约束。换句话说，当省略标志为true时，不能保证不会使用字节码再次检查约束。</target>
        </trans-unit>
        <trans-unit id="60b191bb31eb6d4e8bdeb7b48904acffd3c2dfc6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of a &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt; call this interface to declare the format (the names and datatypes of the columns) of the virtual tables they implement.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_module&quot;&gt;虚拟表模块&lt;/a&gt;的&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;和&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;方法调用此接口以声明它们实现的虚拟表的格式（列的名称和数据类型）。</target>
        </trans-unit>
        <trans-unit id="d6feb2481a619b82b0e2f46a25f49c2e66551dca" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; method is called whenever a database connection that uses a virtual table is closed. The xDestroy method is only called when a &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; statement is executed against the virtual table.</source>
          <target state="translated">所述&lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt;每当使用虚拟表的数据库连接关闭方法被调用。仅在针对虚拟表执行&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;语句时才调用xDestroy方法。</target>
        </trans-unit>
        <trans-unit id="8c0ce4af06185c37b128ad21eebbd21f3f9ac244" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method was originally designed around having a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; as a single value. The &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method has been expanded to accommodate an arbitrary PRIMARY KEY in place of the ROWID, but the PRIMARY KEY must still be only one column. For this reason, SQLite will reject any WITHOUT ROWID virtual table that has more than one PRIMARY KEY column and a non-NULL xUpdate method.</source>
          <target state="translated">所述&lt;a href=&quot;vtab#xupdate&quot;&gt;的XUpdate&lt;/a&gt;方法的最初目的是围绕具有&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;作为一个单一的值。在&lt;a href=&quot;vtab#xupdate&quot;&gt;使用XUpdate&lt;/a&gt;方法已经扩大，以适应地方的ROWID的任意PRIMARY KEY，但PRIMARY KEY仍然必须只有一个列。因此，SQLite将拒绝任何具有多个PRIMARY KEY列和一个非NULL xUpdate方法的WITHOUT ROWID虚拟表。</target>
        </trans-unit>
        <trans-unit id="e8e22d8d27e272cb6edbc57854c2655aac986253" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;wal#advantages&quot;&gt;second advantage of WAL-mode&lt;/a&gt; is that writers do not block readers and readers to do not block writers. This is &lt;u&gt;mostly&lt;/u&gt; true. But there are some obscure cases where a query against a WAL-mode database can return &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, so applications should be prepared for that happenstance.</source>
          <target state="translated">&lt;a href=&quot;wal#advantages&quot;&gt;WAL模式&lt;/a&gt;的第二个优点是，编写者不会阻止读者，而阅读者也不会阻止作家。这&lt;u&gt;基本上是&lt;/u&gt;对的。但是在某些模糊的情况下，针对WAL模式数据库的查询可以返回&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;，因此应为这种情况做好准备。</target>
        </trans-unit>
        <trans-unit id="73dd67efef2f2aca70b69d53d116d51359c36e68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint(D,N)&lt;/a&gt; is a wrapper around &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; that causes any database on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D to automatically &lt;a href=&quot;../wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; after committing a transaction if there are N or more frames in the &lt;a href=&quot;../wal&quot;&gt;write-ahead log&lt;/a&gt; file. Passing zero or a negative value as the nFrame parameter disables automatic checkpoints entirely.</source>
          <target state="translated">该&lt;a href=&quot;wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint（d，N）&lt;/a&gt;是围绕一个包装&lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;引起的任何数据库&lt;a href=&quot;sqlite3&quot;&gt;的数据库连接&lt;/a&gt; d自动&lt;a href=&quot;../wal#ckpt&quot;&gt;检查点&lt;/a&gt;提交事务后，如果有N帧以上的&lt;a href=&quot;../wal&quot;&gt;预写日志&lt;/a&gt;文件。作为nFrame参数传递零或负值将完全禁用自动检查点。</target>
        </trans-unit>
        <trans-unit id="70220a93d132293d087792692e0745eaa50f6944" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; function is used to register a callback that is invoked each time data is committed to a database in wal mode.</source>
          <target state="translated">所述&lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;函数是用来注册时调用每次数据致力于在沃尔玛模式的数据库中的回调。</target>
        </trans-unit>
        <trans-unit id="82c4cc754894816f7c5238173cc6918a40c6ae4d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;walformat#locks&quot;&gt;WAL-mode locks&lt;/a&gt; are described above.</source>
          <target state="translated">的&lt;a href=&quot;walformat#locks&quot;&gt;WAL模式锁&lt;/a&gt;如上所述。</target>
        </trans-unit>
        <trans-unit id="2815c286729fb6fca3fa728a7812f5c530ea71ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt; is implemented using an ordinary file that is mmapped for robustness. Early (pre-release) implementations of WAL mode stored the wal-index in volatile shared-memory, such as files created in /dev/shm on Linux or /tmp on other unix systems. The problem with that approach is that processes with a different root directory (changed via &lt;a href=&quot;http://en.wikipedia.org/wiki/Chroot&quot;&gt;chroot&lt;/a&gt;) will see different files and hence use different shared memory areas, leading to database corruption. Other methods for creating nameless shared memory blocks are not portable across the various flavors of unix. And we could not find any method to create nameless shared memory blocks on windows. The only way we have found to guarantee that all processes accessing the same database file use the same shared memory is to create the shared memory by mmapping a file in the same directory as the database itself.</source>
          <target state="translated">在&lt;a href=&quot;walformat#shm&quot;&gt;沃尔玛指数&lt;/a&gt;是否使用了mmapped健壮性一个普通文件实现。 WAL模式的早期（预发行版）实现将wal-index存储在易失的共享内存中，例如在Linux上的/ dev / shm中创建的文件，或在其他unix系统上的/ tmp中创建的文件。这种方法的问题是具有不同根目录的进程（通过&lt;a href=&quot;http://en.wikipedia.org/wiki/Chroot&quot;&gt;chroot&lt;/a&gt;更改））将看到不同的文件，因此使用不同的共享内存区域，从而导致数据库损坏。创建无名共享内存块的其他方法不能跨各种unix移植。而且，我们找不到在Windows上创建无名共享内存块的任何方法。我们发现保证访问同一数据库文件的所有进程使用相同共享内存的唯一方法是通过将文件映射到与数据库本身相同的目录中来创建共享内存。</target>
        </trans-unit>
        <trans-unit id="379219cdaf72393799eeaccc00a9c99a8148d1db" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt; is implemented using an ordinary file that is mmapped for robustness. Early (pre-release) implementations of WAL mode stored the wal-index in volatile shared-memory, such as files created in /dev/shm on Linux or /tmp on other unix systems. The problem with that approach is that processes with a different root directory (changed via &lt;a href=&quot;https://en.wikipedia.org/wiki/Chroot&quot;&gt;chroot&lt;/a&gt;) will see different files and hence use different shared memory areas, leading to database corruption. Other methods for creating nameless shared memory blocks are not portable across the various flavors of unix. And we could not find any method to create nameless shared memory blocks on windows. The only way we have found to guarantee that all processes accessing the same database file use the same shared memory is to create the shared memory by mmapping a file in the same directory as the database itself.</source>
          <target state="translated">在&lt;a href=&quot;walformat#shm&quot;&gt;沃尔玛指数&lt;/a&gt;是否使用了mmapped健壮性一个普通文件实现。 WAL模式的早期（预发行版）实现将wal-index存储在易失的共享内存中，例如在Linux上的/ dev / shm中创建的文件，或在其他unix系统上的/ tmp中创建的文件。这种方法的问题在于，进程具有不同的根目录（通过&lt;a href=&quot;https://en.wikipedia.org/wiki/Chroot&quot;&gt;chroot进行了&lt;/a&gt;更改））将看到不同的文件，因此使用不同的共享内存区域，从而导致数据库损坏。创建无名共享内存块的其他方法不能跨各种unix移植。而且我们找不到在Windows上创建无名共享内存块的任何方法。我们发现保证访问同一数据库文件的所有进程使用相同共享内存的唯一方法是通过映射与数据库本身相同的目录中的文件来创建共享内存。</target>
        </trans-unit>
        <trans-unit id="e0f2b794ee3e27ce7edc3429510c9bf44ed6503d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;whentouse#website&quot;&gt;Appropriate Uses For SQLite&lt;/a&gt; page says that dynamic pages on the SQLite website typically do about 200 SQL statements each. This has provoked criticism from readers. Examples:</source>
          <target state="translated">&lt;a href=&quot;whentouse#website&quot;&gt;SQLite的&lt;/a&gt; &amp;ldquo; 适当使用&amp;rdquo;页面表示，SQLite网站上的动态页面通常每个执行200条SQL语句。这引起了读者的批评。例子：</target>
        </trans-unit>
        <trans-unit id="edb12d8d86687eb25304ab545c4bdc2adb558bbf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; can read and write a &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;ZIP Archive&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;zipfile&quot;&gt;zip文件虚拟表&lt;/a&gt;可以读取和写入一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;ZIP档案&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d23698ad6db1bcbbe81ce38782af791870223128" translate="yes" xml:space="preserve">
          <source>The &lt;b id=&quot;tcl&quot;&gt;TCL Tests&lt;/b&gt; are the oldest set of tests for SQLite. They are contained in the same source tree as the SQLite core and like the SQLite core are in the public domain. The TCL tests are the primary tests used during development. The TCL tests are written using the &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;TCL scripting language&lt;/a&gt;. The TCL test harness itself consists of 26.9 KSLOC of C code used to create the TCL interface. The test scripts are contained in 1264 files totaling 20.5MB in size. There are 44792 distinct test cases, but many of the test cases are parameterized and run multiple times (with different parameters) so that on a full test run millions of separate tests are performed.</source>
          <target state="translated">在&lt;b id=&quot;tcl&quot;&gt;TCL测试&lt;/b&gt;是最古老的一套SQLite的测试。它们包含在与SQLite核心相同的源树中，就像SQLite核心在公共域中一样。 TCL测试是开发期间使用的主要测试。 TCL测试是使用&lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;TCL脚本语言编写的&lt;/a&gt;。 TCL测试工具本身包含用于创建TCL接口的26.9 KSLOC C代码。测试脚本包含在1264个文件中，总大小为20.5MB。有44792个不同的测试用例，但是许多测试用例已参数化并多次运行（使用不同的参数），因此在完整的测试运行中，要执行数百万个单独的测试。</target>
        </trans-unit>
        <trans-unit id="1ec2f6c6133a8488b1cdbdaeca80a7abf2b8d280" translate="yes" xml:space="preserve">
          <source>The &lt;b id=&quot;tcl&quot;&gt;TCL Tests&lt;/b&gt; are the oldest set of tests for SQLite. They are contained in the same source tree as the SQLite core and like the SQLite core are in the public domain. The TCL tests are the primary tests used during development. The TCL tests are written using the &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;TCL scripting language&lt;/a&gt;. The TCL test harness itself consists of 27.0 KSLOC of C code used to create the TCL interface. The test scripts are contained in 1272 files totaling 21.1MB in size. There are 46363 distinct test cases, but many of the test cases are parameterized and run multiple times (with different parameters) so that on a full test run millions of separate tests are performed.</source>
          <target state="translated">在&lt;b id=&quot;tcl&quot;&gt;TCL测试&lt;/b&gt;是最古老的一套SQLite的测试。它们包含在与SQLite核心相同的源树中，就像SQLite核心在公共域中一样。 TCL测试是开发期间使用的主要测试。 TCL测试是使用&lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;TCL脚本语言编写的&lt;/a&gt;。 TCL测试工具本身包含27.0 KSLOC的C代码，用于创建TCL接口。测试脚本包含在1272个文件中，总大小为21.1MB。有46363个不同的测试用例，但是许多测试用例已参数化并多次运行（使用不同的参数），因此在一个完整的测试运行中，要执行数百万个单独的测试。</target>
        </trans-unit>
        <trans-unit id="13cdecb1980e53f5f89b22590d89aaee57d271ef" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;+&lt;/b&gt; operator on the &lt;b&gt;x&lt;/b&gt; column will prevent that term from constraining an index. This would force the use of the ex2i2 index.</source>
          <target state="translated">的&lt;b&gt;+&lt;/b&gt;在操作者&lt;b&gt;X&lt;/b&gt;列将防止该术语从约束的索引。这将强制使用ex2i2索引。</target>
        </trans-unit>
        <trans-unit id="6a6c5521cf56a12cd7c97f53a6e81f778a626555" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;&lt;/b&gt; test harness is a set of proprietary tests, written in C that provide 100% branch test coverage (and &lt;a href=&quot;testing#mcdc&quot;&gt;100% MC/DC test coverage&lt;/a&gt;) to the core SQLite library. The TH3 tests are designed to run on embedded and specialized platforms that would not easily support TCL or other workstation services. TH3 tests use only the published SQLite interfaces. TH3 consists of about 69.4 MB or 948.1 KSLOC of C code implementing 44753 distinct test cases. TH3 tests are heavily parameterized, though, so a full-coverage test runs about 1.7 million different test instances. The cases that provide 100% branch test coverage constitute a subset of the total TH3 test suite. A soak test prior to release does hundreds of millions of tests. Additional information on TH3 is &lt;a href=&quot;th3&quot;&gt;available separately&lt;/a&gt;.</source>
          <target state="translated">所述&lt;b&gt;&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;&lt;/b&gt;测试工具是一组专有的测试中，用C语言编写的是提供100％的分支测试覆盖率（和&lt;a href=&quot;testing#mcdc&quot;&gt;100％MC / DC测试覆盖&lt;/a&gt;）到核心SQLite库。TH3测试旨在在无法轻松支持TCL或其他工作站服务的嵌入式和专用平台上运行。TH3测试仅使用已发布的SQLite接口。TH3包含约69.4 MB或948.1 KSLOC的C代码，实现了44753个不同的测试用例。不过，TH3测试是经过严格参数化的，因此，一个全覆盖测试将运行大约170万个不同的测试实例。提供100％分支测试覆盖率的案例构成了TH3测试套件总数的一部分。发布之前的浸泡测试会进行数亿次测试。TH3的其他信息&lt;a href=&quot;th3&quot;&gt;可单独获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d6d35eb6cfeae174de2bae520fa16645d47318a8" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;&lt;/b&gt; test harness is a set of proprietary tests, written in C that provide 100% branch test coverage (and &lt;a href=&quot;testing#mcdc&quot;&gt;100% MC/DC test coverage&lt;/a&gt;) to the core SQLite library. The TH3 tests are designed to run on embedded and specialized platforms that would not easily support TCL or other workstation services. TH3 tests use only the published SQLite interfaces. TH3 consists of about 71.5 MB or 978.3 KSLOC of C code implementing 46622 distinct test cases. TH3 tests are heavily parameterized, though, so a full-coverage test runs about 1.9 million different test instances. The cases that provide 100% branch test coverage constitute a subset of the total TH3 test suite. A soak test prior to release does hundreds of millions of tests. Additional information on TH3 is &lt;a href=&quot;th3&quot;&gt;available separately&lt;/a&gt;.</source>
          <target state="translated">所述&lt;b&gt;&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;&lt;/b&gt;测试工具是一组专有的测试中，用C语言编写的是提供100％的分支测试覆盖率（和&lt;a href=&quot;testing#mcdc&quot;&gt;100％MC / DC测试覆盖&lt;/a&gt;）到核心SQLite库。TH3测试旨在在无法轻松支持TCL或其他工作站服务的嵌入式和专用平台上运行。TH3测试仅使用已发布的SQLite接口。TH3包含约71.5 MB或978.3 KSLOC的C代码，实现了46622个不同的测试用例。不过，TH3测试是经过严格参数化的，因此，一个全覆盖测试将运行大约190万个不同的测试实例。提供100％分支测试覆盖率的案例构成了总TH3测试套件的一部分。发布之前的浸泡测试会进行数亿次测试。关于TH3的其他信息&lt;a href=&quot;th3&quot;&gt;可单独获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4cd8f15572230ed1f58d51c1d5372e68bc7d3339" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;&lt;i&gt;page number&lt;/i&gt;&lt;/b&gt; of the cached page. Pages are sequentially numbered within a database file starting from page 1 (page 1 begins at byte offset 0). Refer to</source>
          <target state="translated">缓存页面的&lt;b&gt;&lt;i&gt;页面号&lt;/i&gt;&lt;/b&gt;。从页面1开始，页面在数据库文件中按顺序编号（页面1从字节偏移0开始）。参考</target>
        </trans-unit>
        <trans-unit id="81a39adda694af530886e4e9df6d7182a049eea0" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SQLITE_ENABLE_REDEF_IO&lt;/b&gt; compile-time flag no longer functions. I/O procedures are now always redefinable.</source>
          <target state="translated">该&lt;b&gt;SQLITE_ENABLE_REDEF_IO&lt;/b&gt;编译时标志不再起作用。I / O程序现在始终可以重新定义。</target>
        </trans-unit>
        <trans-unit id="66961c7dbacae09d459d2962003215ef6b06eee5" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;ascii&lt;/b&gt; tokenizer, which assumes all characters outside of the ASCII codepoint range (0-127) are to be treated as token characters.</source>
          <target state="translated">假定所有ASCII码点范围（0-127）以外的字符的&lt;b&gt;ascii&lt;/b&gt;标记器都应视为标记字符。</target>
        </trans-unit>
        <trans-unit id="da7024788e6b267f1ba270622b866f7355ceaff9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;atomic-write&lt;/b&gt; property. A system that supports this property also specifies the size or sizes of the blocks that it is capable of writing. Valid sizes are powers of two greater than 512. If a write operation modifies a block of</source>
          <target state="translated">该&lt;b&gt;原子写入&lt;/b&gt;性能。支持此属性的系统还指定了它可以写入的块的大小。有效大小是大于512的2的幂。如果写操作修改了一个</target>
        </trans-unit>
        <trans-unit id="d4ac7f6fa28d8af8532959a7c557a99ffb086e4a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;cached data&lt;/b&gt;; a blob of data</source>
          <target state="translated">该&lt;b&gt;缓存数据&lt;/b&gt; ; 一滴数据</target>
        </trans-unit>
        <trans-unit id="4bdaa687775a7cc6ed8f468435ceaab97dc48b3c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;checksum initializer&lt;/b&gt; field is set to a pseudo-random value. It is used as part of the algorithm to calculate the checksum for all</source>
          <target state="translated">在&lt;b&gt;初始化校验&lt;/b&gt;字段设置为一个伪随机值。它用作算法的一部分，以计算所有</target>
        </trans-unit>
        <trans-unit id="9732c0255b0b0de3b180d5a5b9e6e0e0de10ed21" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;checksum&lt;/b&gt; field contains a checksum value stored as a 4-byte big-endian signed integer. The checksum value is calculated as the sum of the bytes that make up the</source>
          <target state="translated">该&lt;b&gt;校验&lt;/b&gt;字段包含存储为4字节大端符号整数的校验和值。校验和值的计算公式是构成校验和的字节的总和。</target>
        </trans-unit>
        <trans-unit id="808b646bb572829a50a12856cab578c0ba1273b4" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;child key&lt;/b&gt; is the column or set of columns in the child table that are constrained by the foreign key constraint and which hold the REFERENCES clause.</source>
          <target state="translated">该&lt;b&gt;子键&lt;/b&gt;是列或由外键约束的约束和子表列集按住参考条款。</target>
        </trans-unit>
        <trans-unit id="4eb5a92cd04b8762d6cafb14dc40e6502ca97d4b" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;child table&lt;/b&gt; is the table that a foreign key constraint is applied to and the table that contains the REFERENCES clause. The example in this section uses the</source>
          <target state="translated">该&lt;b&gt;子表&lt;/b&gt;是一个外键约束应用于表和包含参考条款表。本节中的示例使用</target>
        </trans-unit>
        <trans-unit id="d2c172ce98989ce0e6fad8d66979d45e11202395" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;columns=&lt;/b&gt;</source>
          <target state="translated">该&lt;b&gt;列=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4bbf98eb754afaa644e3f69b92d0dc2195f52253" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;data=&lt;/b&gt; argument specifies that</source>
          <target state="translated">该&lt;b&gt;数据=&lt;/b&gt;参数指定</target>
        </trans-unit>
        <trans-unit id="6baedccfb53deaad3fb37afa8fc4d96019b82c5a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;dbhash&lt;/b&gt; (or &lt;b&gt;dbhash.exe&lt;/b&gt; on Windows) utility is a command-line program that computes the SHA1 hash of the schema and content for an SQLite database.</source>
          <target state="translated">所述&lt;b&gt;dbhash&lt;/b&gt;（或&lt;b&gt;dbhash.exe&lt;/b&gt;在Windows上）实用程序是一个命令行程序，其计算的模式和内容SQLite数据库的SHA1哈希。</target>
        </trans-unit>
        <trans-unit id="d6a3ef16a0b39b8edb4795fe8274619e6786a20a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;dbstat&lt;/b&gt; virtual table is available on all &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; when SQLite is built using the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; compile-time option. The dbstat virtual table provides low-level information about btree and overflow pages in a database file.</source>
          <target state="translated">使用&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt;编译时选项构建SQLite时，&lt;b&gt;dbstat&lt;/b&gt;虚拟表可用于所有&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;。dbstat虚拟表提供有关数据库文件中btree和溢出页面的低级信息。</target>
        </trans-unit>
        <trans-unit id="c02b7772c7b3d35833dbf1451cc41f6819aeb8c0" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;experimental&lt;/b&gt; trigram tokenizer extends FTS5 to support substring matching in general, instead of the usual token matching. When using the trigram tokenizer, a query or phrase token may match any sequence of characters within a row, not just a complete token. For example:</source>
          <target state="translated">的&lt;b&gt;实验&lt;/b&gt;分词器延伸FTS5卦以支持在一般子串匹配，而不是通常的令牌匹配。使用Trigram标记器时，查询或短语标记可以匹配一行中的任何字符序列，而不仅仅是完整的标记。例如：</target>
        </trans-unit>
        <trans-unit id="76a580c33e2e93bdaf2b8468f5fe69cbcb6b77c7" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;filename=&lt;/b&gt; argument specifies an external file from which CSV content is read. Every CSV virtual table must have either a &lt;b&gt;filename=&lt;/b&gt; argument or a &lt;b&gt;data=&lt;/b&gt; argument and not both.</source>
          <target state="translated">的&lt;b&gt;文件名=&lt;/b&gt;参数指定从哪个CSV内容被读出的外部文件。每个CSV虚拟表都必须具有&lt;b&gt;filename =&lt;/b&gt;参数或&lt;b&gt;data =&lt;/b&gt;参数，并且不能同时具有两者。</target>
        </trans-unit>
        <trans-unit id="b993a193dd09d944f6699b7d9c40cd91aa1faf7c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;journal magic&lt;/b&gt; field always contains a well-known 8-byte string value used to identify SQLite journal files. The well-known sequence of byte values is:</source>
          <target state="translated">该&lt;b&gt;杂志的魔法&lt;/b&gt;领域始终包含用于识别SQLite的日志文件知名的8个字节的字符串值。字节值的众所周知的顺序是：</target>
        </trans-unit>
        <trans-unit id="a2e5b0d62ca7f429d717982cbc08462058d705f1" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;json1&lt;/b&gt; extension is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; that implements fifteen &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; and two &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that are useful for managing &lt;a href=&quot;http://json.org/&quot;&gt;JSON&lt;/a&gt; content stored in an SQLite database. There are thirteen scalar functions:</source>
          <target state="translated">所述&lt;b&gt;json1&lt;/b&gt;扩展是一个&lt;a href=&quot;loadext&quot;&gt;可加载的扩展&lt;/a&gt;实现15&lt;a href=&quot;appfunc&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;和两个&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;是用于管理有用&lt;a href=&quot;http://json.org/&quot;&gt;JSON&lt;/a&gt;存储在SQLite数据库的内容。有十三种标量函数：</target>
        </trans-unit>
        <trans-unit id="7704e120d31f1ad375a7cb151d4af3d29dea3f0a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;json1&lt;/b&gt; extension is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; that implements fifteen &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; and two &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that are useful for managing &lt;a href=&quot;https://json.org/&quot;&gt;JSON&lt;/a&gt; content stored in an SQLite database. There are thirteen scalar functions:</source>
          <target state="translated">所述&lt;b&gt;json1&lt;/b&gt;扩展是一个&lt;a href=&quot;loadext&quot;&gt;可加载的扩展&lt;/a&gt;实现15&lt;a href=&quot;appfunc&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;和两个&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;是用于管理有用&lt;a href=&quot;https://json.org/&quot;&gt;JSON&lt;/a&gt;存储在SQLite数据库的内容。有十三种标量函数：</target>
        </trans-unit>
        <trans-unit id="0fb60bd76a6daf3fc22f58ff7ed03bdcd9faa9a0" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;json1&lt;/b&gt; extension is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; that implements fifteen &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; and two &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that are useful for managing &lt;a href=&quot;http://json.org/&quot;&gt;JSON&lt;/a&gt; content stored in an SQLite database. There are thirteen scalar functions:</source>
          <target state="translated">所述&lt;b&gt;json1&lt;/b&gt;扩展是一个&lt;a href=&quot;loadext&quot;&gt;可加载的扩展&lt;/a&gt;实现15 &lt;a href=&quot;c3ref/create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;和两个&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;是用于管理有用&lt;a href=&quot;http://json.org/&quot;&gt;JSON&lt;/a&gt;存储在SQLite数据库的内容。有十三种标量函数：</target>
        </trans-unit>
        <trans-unit id="74a8fe72057fb6a9d52ebf2366e8ca3d47b3ef51" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;master journal name&lt;/b&gt; field contains the name of the master journal file, encoded as a utf-8 string. There is no nul-terminator appended to the string.</source>
          <target state="translated">在&lt;b&gt;主期刊名称&lt;/b&gt;字段包含主日志文件的名称，编码成UTF-8字符串。字符串中没有附加nul-terminator。</target>
        </trans-unit>
        <trans-unit id="32cd399bbb4e1a23152d71a26f07f3eec308179e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;name-length&lt;/b&gt; field contains the length of the previous field in bytes, formatted as a 4-byte big-endian unsigned integer.</source>
          <target state="translated">的&lt;b&gt;名称长度&lt;/b&gt;字段包含在字节上一字段的长度，格式为4字节大端无符号整数。</target>
        </trans-unit>
        <trans-unit id="fae22eeca9bdb678bd49709e0047fc71684a2c64" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;page size&lt;/b&gt; field contains the database page size used by the corresponding</source>
          <target state="translated">该&lt;b&gt;页面大小&lt;/b&gt;字段包含相应使用的数据库页面大小</target>
        </trans-unit>
        <trans-unit id="b47567cd5b3319ed0502d81821002b32b190c8e7" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;parent key&lt;/b&gt; is the column or set of columns in the parent table that the foreign key constraint refers to. This is normally, but not always, the primary key of the parent table. The parent key must be a named column or columns in the parent table, not the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">该&lt;b&gt;父键&lt;/b&gt;是列在父表中的列或组的外键约束是指。这通常是父表的主键，但并非总是如此。父键必须是父表中的一个或多个命名列，而不是&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec4c139f470f21c5fe4e5b5cefa7700a1825e05d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;parent table&lt;/b&gt; is the table that a foreign key constraint refers to. The parent table in the example in this section is the</source>
          <target state="translated">该&lt;b&gt;父表&lt;/b&gt;是表的外键约束是指。本节示例中的父表是</target>
        </trans-unit>
        <trans-unit id="36aa5afa4e61953d1ec495c1b005644b052981bb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;porter&lt;/b&gt; tokenizer, which implements the &lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;porter stemming algorithm&lt;/a&gt;.</source>
          <target state="translated">该&lt;b&gt;搬运工&lt;/b&gt;标记生成器，它实现了&lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;波特所产生的算法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ade0fb22c2403822d6a1734aee4559951cfcf4ff" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;porter&lt;/b&gt; tokenizer, which implements the &lt;a href=&quot;https://tartarus.org/martin/PorterStemmer/&quot;&gt;porter stemming algorithm&lt;/a&gt;.</source>
          <target state="translated">该&lt;b&gt;搬运工&lt;/b&gt;标记生成器，它实现了&lt;a href=&quot;https://tartarus.org/martin/PorterStemmer/&quot;&gt;波特所产生的算法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a37111e2fe594df629017fae4b6e16c1ee66e480" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;safe-append&lt;/b&gt; property. If a system supports the</source>
          <target state="translated">该&lt;b&gt;安全-追加&lt;/b&gt;属性。如果系统支持</target>
        </trans-unit>
        <trans-unit id="d6885cc42a1a11dedbc2ecde02a62efeb92c5994" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;schema=&lt;/b&gt; argument specifies a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement that the CSV virtual table passes to the &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; interface in order to define the names of the columns in the virtual table.</source>
          <target state="translated">该&lt;b&gt;架构=&lt;/b&gt;参数指定一个&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句，该CSV虚拟表传递给&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt;接口，以便在虚拟表来定义列的名称。</target>
        </trans-unit>
        <trans-unit id="062e562546606b031a29c9b1538d01a4933fdf4d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sequential-write&lt;/b&gt; property. A system that supports the</source>
          <target state="translated">在&lt;b&gt;连续写入&lt;/b&gt;性能。支持以下功能的系统</target>
        </trans-unit>
        <trans-unit id="9a93bd9a21f342ac487fc44f9c521120beed1f0d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite3&lt;/b&gt; command is used as follows:</source>
          <target state="translated">的&lt;b&gt;sqlite3的&lt;/b&gt;命令的使用如下：</target>
        </trans-unit>
        <trans-unit id="6bd9a1c77e9aedcf3a7d203f467b8767663fc753" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite3&lt;/b&gt; command opens the database named in the second argument. If the database does not already exist, the default behavior is for it to be created automatically (though this can be changed by using the &quot;&lt;b&gt;-create false&lt;/b&gt;&quot; option). The &lt;b&gt;sqlite3&lt;/b&gt; command always creates a new Tcl command to control the database. The name of the new Tcl command is given by the first argument. This approach is similar to the way widgets are created in Tk.</source>
          <target state="translated">在&lt;b&gt;sqlite3的&lt;/b&gt;命令打开第二个参数命名的数据库。如果该数据库尚不存在，则默认行为是自动创建该数据库（尽管可以使用&amp;ldquo; &lt;b&gt;-create false&lt;/b&gt; &amp;rdquo;选项来更改它）。在&lt;b&gt;sqlite3的&lt;/b&gt;命令总是创建一个新的Tcl命令来控制数据库。新的Tcl命令的名称由第一个参数给出。这种方法类似于在Tk中创建小部件的方式。</target>
        </trans-unit>
        <trans-unit id="b032b475b9199ee134a35698c55445c506e1d56e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite&lt;/b&gt; command-line utility uses the &lt;b&gt;sqlite_complete&lt;/b&gt; function to know when it needs to call &lt;b&gt;sqlite_exec&lt;/b&gt;. After each line of input is received, &lt;b&gt;sqlite&lt;/b&gt; calls &lt;b&gt;sqlite_complete&lt;/b&gt; on all input in its buffer. If &lt;b&gt;sqlite_complete&lt;/b&gt; returns true, then &lt;b&gt;sqlite_exec&lt;/b&gt; is called and the input buffer is reset. If &lt;b&gt;sqlite_complete&lt;/b&gt; returns false, then the prompt is changed to the continuation prompt and another line of text is read and added to the input buffer.</source>
          <target state="translated">在&lt;b&gt;sqlite的&lt;/b&gt;命令行实用程序使用&lt;b&gt;sqlite_complete&lt;/b&gt;功能知道什么时候需要调用&lt;b&gt;sqlite_exec&lt;/b&gt;。收到每行输入后，&lt;b&gt;sqlite&lt;/b&gt;在其缓冲区中的所有输入上调用&lt;b&gt;sqlite_complete&lt;/b&gt;。如果&lt;b&gt;sqlite_complete&lt;/b&gt;返回true，则&lt;b&gt;调用sqlite_exec&lt;/b&gt;并重置输入缓冲区。如果&lt;b&gt;sqlite_complete&lt;/b&gt;返回false，则提示更改为继续提示，并读取另一行文本并将其添加到输入缓冲区。</target>
        </trans-unit>
        <trans-unit id="332726262d6ef917130298a44650660fb1ebc042" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_busy_handler&lt;/b&gt; procedure can be used to register a busy callback with an open SQLite database. The busy callback will be invoked whenever SQLite tries to access a database that is locked. The callback will typically do some other useful work, or perhaps sleep, in order to give the lock a chance to clear. If the callback returns non-zero, then SQLite tries again to access the database and the cycle repeats. If the callback returns zero, then SQLite aborts the current operation and returns SQLITE_BUSY.</source>
          <target state="translated">所述&lt;b&gt;sqlite_busy_handler&lt;/b&gt;过程可用于注册一个忙回调以开放SQLite数据库。每当SQLite尝试访问已锁定的数据库时，都会调用busy回调。回调通常会做一些其他有用的工作，或者也许是睡觉，以便给锁一个清除的机会。如果回调返回非零值，则SQLite再次尝试访问数据库，并重复该循环。如果回调返回零，则SQLite中止当前操作并返回SQLITE_BUSY。</target>
        </trans-unit>
        <trans-unit id="21449bf7fdcd477c05c71384163b9f8717a257f0" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_changes&lt;/b&gt; API function returns the number of rows that have been inserted, deleted, or modified since the database was last quiescent. A &quot;quiescent&quot; database is one in which there are no outstanding calls to &lt;b&gt;sqlite_exec&lt;/b&gt; and no VMs created by &lt;b&gt;sqlite_compile&lt;/b&gt; that have not been finalized by &lt;b&gt;sqlite_finalize&lt;/b&gt;. In common usage, &lt;b&gt;sqlite_changes&lt;/b&gt; returns the number of rows inserted, deleted, or modified by the most recent &lt;b&gt;sqlite_exec&lt;/b&gt; call or since the most recent &lt;b&gt;sqlite_compile&lt;/b&gt;. But if you have nested calls to &lt;b&gt;sqlite_exec&lt;/b&gt; (that is, if the callback routine of one &lt;b&gt;sqlite_exec&lt;/b&gt; invokes another &lt;b&gt;sqlite_exec&lt;/b&gt;) or if you invoke &lt;b&gt;sqlite_compile&lt;/b&gt; to create a new VM while there is still another VM in existence, then the meaning of the number returned by &lt;b&gt;sqlite_changes&lt;/b&gt; is more complex. The number reported includes any changes that were later undone by a ROLLBACK or ABORT. But rows that are deleted because of a DROP TABLE are &lt;em&gt;not&lt;/em&gt; counted.</source>
          <target state="translated">该&lt;b&gt;sqlite_changes&lt;/b&gt; API函数返回已插入，删除或修改因为数据库最后一次静态的行数。 &amp;ldquo;静态&amp;rdquo;数据库是其中没有对&lt;b&gt;sqlite_exec的&lt;/b&gt;未完成调用，也没有由&lt;b&gt;sqlite_compile&lt;/b&gt;创建的尚未由&lt;b&gt;sqlite_finalize&lt;/b&gt;完成的&lt;b&gt;VM&lt;/b&gt;。在常见的用法，&lt;b&gt;sqlite_changes&lt;/b&gt;回报插入的行数，删除或最近修改&lt;b&gt;sqlite_exec&lt;/b&gt;来电或自最近&lt;b&gt;sqlite_compile&lt;/b&gt;。但是，如果您嵌套调用了&lt;b&gt;sqlite_exec&lt;/b&gt;（即，一个&lt;b&gt;sqlite_exec&lt;/b&gt;的回调例程调用了另一个）&lt;b&gt;sqlite_exec&lt;/b&gt;），或者如果在存在另一个VM的情况下调用&lt;b&gt;sqlite_compile&lt;/b&gt;创建新的VM，则&lt;b&gt;sqlite_changes&lt;/b&gt;返回的数字的含义更加复杂。报告的数字包括后来被ROLLBACK或ABORT撤消的所有更改。但是由于DROP TABLE删除的行&lt;em&gt;不&lt;/em&gt;计算在内。</target>
        </trans-unit>
        <trans-unit id="78ea929e712b658454a0d7a7507e5e6040d334f9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_compile&lt;/b&gt; &quot;compiles&quot; a single SQL statement (specified by the second parameter) and generates a virtual machine that is able to execute that statement. As with must interface routines, the first parameter must be a pointer to an sqlite structure that was obtained from a prior call to &lt;b&gt;sqlite_open&lt;/b&gt;.</source>
          <target state="translated">所述&lt;b&gt;sqlite_compile&lt;/b&gt; &amp;ldquo;编译&amp;rdquo;单个SQL语句（由第二个参数指定），并产生一个虚拟机，其能够执行该语句。与must接口例程一样，第一个参数必须是指向sqlite结构的指针，该结构是从对&lt;b&gt;sqlite_open&lt;/b&gt;的先前调用中&lt;b&gt;获得的&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="11aed5342f0d3f43d8e5e9d1781269c400901176" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_create_function()&lt;/b&gt; interface is used to create regular functions and &lt;b&gt;sqlite_create_aggregate()&lt;/b&gt; is used to create new aggregate functions. In both cases, the &lt;b&gt;db&lt;/b&gt; parameter is an open SQLite database on which the functions should be registered, &lt;b&gt;zName&lt;/b&gt; is the name of the new function, &lt;b&gt;nArg&lt;/b&gt; is the number of arguments, and &lt;b&gt;pUserData&lt;/b&gt; is a pointer which is passed through unchanged to the C implementation of the function. Both routines return 0 on success and non-zero if there are any errors.</source>
          <target state="translated">该&lt;b&gt;sqlite_create_function（）&lt;/b&gt;接口用于创建常规功能和&lt;b&gt;sqlite_create_aggregate（）&lt;/b&gt;用于创建新的聚合函数。在这两种情况下，&lt;b&gt;db&lt;/b&gt;参数都是应在其上注册函数的开放SQLite数据库，&lt;b&gt;zName&lt;/b&gt;是新函数的名称，&lt;b&gt;nArg&lt;/b&gt;是参数的数量，&lt;b&gt;pUserData&lt;/b&gt;是一个指针，该指针不更改地传递给C实现。功能的 这两个例程均在成功时返回0，如果有任何错误，则返回非零。</target>
        </trans-unit>
        <trans-unit id="5689a09fe87990c5eb5859050a66b6bf0ba7128a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_exec&lt;/b&gt; function is used to process SQL statements and queries. This function requires 5 parameters as follows:</source>
          <target state="translated">该&lt;b&gt;sqlite_exec&lt;/b&gt;功能是用来处理SQL语句和查询。此功能需要5个参数，如下所示：</target>
        </trans-unit>
        <trans-unit id="121679113b5d1c7ddf7783cb3755cec086d10308" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_exec&lt;/b&gt; function normally returns SQLITE_OK. But if something goes wrong it can return a different value to indicate the type of error. Here is a complete list of the return codes:</source>
          <target state="translated">该&lt;b&gt;sqlite_exec&lt;/b&gt;功能正常返回SQLITE_OK。但是，如果出现问题，它可以返回不同的值来指示错误的类型。这是返回码的完整列表：</target>
        </trans-unit>
        <trans-unit id="655f344d54e7a8508c37039b0267420f9c98a884" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_exec&lt;/b&gt; routine described above used to be the only way to retrieve data from an SQLite database. But many programmers found it inconvenient to use a callback function to obtain results. So beginning with SQLite version 2.7.7, a second access interface is available that does not use callbacks.</source>
          <target state="translated">上面描述的&lt;b&gt;sqlite_exec&lt;/b&gt;例程曾经是从SQLite数据库检索数据的唯一方法。但是许多程序员发现使用回调函数获取结果很不方便。因此，从SQLite版本2.7.7开始，可以使用第二个不使用回调的访问接口。</target>
        </trans-unit>
        <trans-unit id="0f4f5ac57e80af00b368fb64cb711d6dc8b648f6" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_finalize&lt;/b&gt; routine also returns the result code that indicates success or failure of the SQL operation that the virtual machine carried out. The value returned by sqlite_finalize() will be the same as would have been returned had the same SQL been executed by &lt;b&gt;sqlite_exec&lt;/b&gt;. The error message returned will also be the same.</source>
          <target state="translated">所述&lt;b&gt;sqlite_finalize&lt;/b&gt;程序也返回结果码，指示SQL操作虚拟机进行的成功或失败。）由sqlite_finalize（返回的值将是相同的将有相同的SQL被执行已返回&lt;b&gt;sqlite_exec&lt;/b&gt;。返回的错误消息也将相同。</target>
        </trans-unit>
        <trans-unit id="e5fe3b872ae55549d978788ef7dd0751c76061d1" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_get_table()&lt;/b&gt; function now returns an error if you give it two or more SELECTs that return different numbers of columns.</source>
          <target state="translated">该&lt;b&gt;sqlite_get_table（）&lt;/b&gt;函数现在返回如果你给它两个或两个以上选择该列返回不同数量的错误。</target>
        </trans-unit>
        <trans-unit id="6c359ecc30c529f766becf568f4c268c432080f6" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_get_table&lt;/b&gt; function is a wrapper around &lt;b&gt;sqlite_exec&lt;/b&gt; that collects all the information from successive callbacks and writes it into memory obtained from malloc(). This is a convenience function that allows the application to get the entire result of a database query with a single function call.</source>
          <target state="translated">该&lt;b&gt;sqlite_get_table&lt;/b&gt;函数是一个包装&lt;b&gt;sqlite_exec&lt;/b&gt;收集所有从连续回调信息并写入（）从取得的malloc存储器。这是一个便捷功能，允许应用程序通过单个函数调用获取数据库查询的整个结果。</target>
        </trans-unit>
        <trans-unit id="dc054248626971621053a5f41a56a6eacfcebb24" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_get_table&lt;/b&gt; routine returns the same integer result code as &lt;b&gt;sqlite_exec&lt;/b&gt;.</source>
          <target state="translated">所述&lt;b&gt;sqlite_get_table&lt;/b&gt;例程返回相同的整数结果代码&lt;b&gt;sqlite_exec&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="bd292002416cc2983b3342d6c1953e82de8e1607" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_interrupt&lt;/b&gt; function can be called from a different thread or from a signal handler to cause the current database operation to exit at its first opportunity. When this happens, the &lt;b&gt;sqlite_exec&lt;/b&gt; routine (or the equivalent) that started the database operation will return SQLITE_INTERRUPT.</source>
          <target state="translated">该&lt;b&gt;sqlite_interrupt&lt;/b&gt;功能可以从不同的线程或信号处理程序被调用，以使在其第一次机会在本届数据库操作退出。发生这种情况时，启动数据库操作的&lt;b&gt;sqlite_exec&lt;/b&gt;例程（或等效例程）将返回SQLITE_INTERRUPT。</target>
        </trans-unit>
        <trans-unit id="110634f7ff21aac9a3d6ba9124f053cdf818f538" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_mprintf()&lt;/b&gt; routine works like the standard library &lt;b&gt;sprintf()&lt;/b&gt; except that it writes its results into memory obtained from malloc() and returns a pointer to the malloced buffer. &lt;b&gt;sqlite_mprintf()&lt;/b&gt; also understands the %q and %Q extensions described above. The &lt;b&gt;sqlite_vmprintf()&lt;/b&gt; is a varargs version of the same routine. The string pointer that these routines return should be freed by passing it to &lt;b&gt;sqlite_freemem()&lt;/b&gt;.</source>
          <target state="translated">所述&lt;b&gt;sqlite_mprintf（）&lt;/b&gt;例行程序的作用与标准库&lt;b&gt;的sprintf（）&lt;/b&gt;不同之处在于它的结果写入从获得的malloc存储器（），并返回一个指针malloced缓冲器。&lt;b&gt;sqlite_mprintf（）&lt;/b&gt;也了解上述的％q和％Q扩展名。该&lt;b&gt;sqlite_vmprintf（）&lt;/b&gt;是一样的程序的可变参数版本。这些例程返回的字符串指针应通过将其传递给&lt;b&gt;sqlite_freemem（）&lt;/b&gt;来释放。</target>
        </trans-unit>
        <trans-unit id="1c001281fc04cb0f8f55a953f44815f9bb2acd94" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_progress_handler()&lt;/b&gt; routine can be used to register a callback routine with an SQLite database to be invoked periodically during long running calls to &lt;b&gt;sqlite_exec()&lt;/b&gt;, &lt;b&gt;sqlite_step()&lt;/b&gt; and the various wrapper functions.</source>
          <target state="translated">所述&lt;b&gt;sqlite_progress_handler（）&lt;/b&gt;例行程序可用于与SQLite数据库注册回调例程要在长时间运行调用定期调用&lt;b&gt;sqlite_exec（） &lt;/b&gt;，&lt;b&gt;）sqlite_step（&lt;/b&gt;和各种包装函数。</target>
        </trans-unit>
        <trans-unit id="2365ff095ada5e9e18ca628c551aa06ded148313" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;unicode61&lt;/b&gt; tokenizer, based on the Unicode 6.1 standard. This is the default.</source>
          <target state="translated">该&lt;b&gt;unicode61&lt;/b&gt;标记生成器，基于Unicode 6.1标准。这是默认值。</target>
        </trans-unit>
        <trans-unit id="c89f587843e082fe105c35ca8b1efaa6d37ded8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-shm&lt;/code&gt; and &lt;code&gt;-wal&lt;/code&gt; files already exists and are readable</source>
          <target state="translated">该 &lt;code&gt;-shm&lt;/code&gt; 和 &lt;code&gt;-wal&lt;/code&gt; 文件已经存在，并且是可读</target>
        </trans-unit>
        <trans-unit id="ae74358eb64792c48dfddc93166fad33cb929d0e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sqldiff.exe&lt;/code&gt; binary is a command-line utility program that displays the differences between SQLite databases. Example usage:</source>
          <target state="translated">所述 &lt;code&gt;sqldiff.exe&lt;/code&gt; 二进制是一个命令行实用程序，显示SQLite数据库之间的差异。用法示例：</target>
        </trans-unit>
        <trans-unit id="d7c66765c0cb2c27b3a6401331165fc804dadc56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sqlite3_analyzer.exe&lt;/code&gt; binary is a command-line utility program that measures and displays how much and how efficiently space is used by individual tables and indexes with an SQLite database file. Example usage:</source>
          <target state="translated">所述 &lt;code&gt;sqlite3_analyzer.exe&lt;/code&gt; 二进制是一个命令行实用程序，测量和显示多少和如何有效的空间被用于单个的表和索引与SQLite数据库文件。用法示例：</target>
        </trans-unit>
        <trans-unit id="6a1974b0f327d4817e6c9b37b72d6c96039edec4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sqlite3_analyzer.exe&lt;/code&gt; program is a &lt;a href=&quot;http://www.tcl.tk/&quot;&gt;TCL&lt;/a&gt; program that uses the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt; to gather information about the database file and then format that information neatly.</source>
          <target state="translated">该 &lt;code&gt;sqlite3_analyzer.exe&lt;/code&gt; 程序是&lt;a href=&quot;http://www.tcl.tk/&quot;&gt;TCL&lt;/a&gt;使用该程序&lt;a href=&quot;dbstat&quot;&gt;dbstat虚拟表&lt;/a&gt;来收集有关数据库文件的信息，然后整齐地格式化信息。</target>
        </trans-unit>
        <trans-unit id="3033d58be28640af9e3284640fcd218f93b46f42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sqlite3_analyzer.exe&lt;/code&gt; program is a &lt;a href=&quot;https://www.tcl.tk/&quot;&gt;TCL&lt;/a&gt; program that uses the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt; to gather information about the database file and then format that information neatly.</source>
          <target state="translated">该 &lt;code&gt;sqlite3_analyzer.exe&lt;/code&gt; 程序是&lt;a href=&quot;https://www.tcl.tk/&quot;&gt;TCL&lt;/a&gt;使用该程序&lt;a href=&quot;dbstat&quot;&gt;dbstat虚拟表&lt;/a&gt;来收集有关数据库文件的信息，然后整齐地格式化信息。</target>
        </trans-unit>
        <trans-unit id="ef70743aa444e28fbab143ed138c4d54acc4ad9c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&amp;lt;name&amp;gt;&lt;/em&gt; is the name your application chooses for the R*Tree index and &lt;em&gt;&amp;lt;column-names&amp;gt;&lt;/em&gt; is a comma separated list of between 3 and 11 columns. The virtual &amp;lt;name&amp;gt; table creates three &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt; to actually store its content. The names of these shadow tables are:</source>
          <target state="translated">所述&lt;em&gt;&amp;lt;名称&amp;gt;&lt;/em&gt;对于R *树索引和应用程序选择的名称&lt;em&gt;&amp;lt;列名&amp;gt;&lt;/em&gt;是逗号分隔的3和11之间的列的列表。虚拟&amp;lt;name&amp;gt;表创建三个&lt;a href=&quot;vtab#xshadowname&quot;&gt;阴影表&lt;/a&gt;以实际存储其内容。这些影子表的名称为：</target>
        </trans-unit>
        <trans-unit id="cfd2051780cda360472504e6c22be9c660375526" translate="yes" xml:space="preserve">
          <source>The ADD COLUMN syntax is used to add a new column to an existing table. The new column is always appended to the end of the list of existing columns. The &lt;a href=&quot;syntax/column-def&quot;&gt;column-def&lt;/a&gt; rule defines the characteristics of the new column. The new column may take any of the forms permissible in a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement, with the following restrictions:</source>
          <target state="translated">ADD COLUMN语法用于将新列添加到现有表。新列始终附加在现有列列表的末尾。该&lt;a href=&quot;syntax/column-def&quot;&gt;列的高清&lt;/a&gt;规则定义的新列的特性。新列可以采用&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句中允许的任何形式，但有以下限制：</target>
        </trans-unit>
        <trans-unit id="dd4a8c42527cc6ad0b74da94ea18e9ecc2a5a9ab" translate="yes" xml:space="preserve">
          <source>The ALTER TABLE command works by modifying the SQL text of the schema stored in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master table&lt;/a&gt;. No changes are made to table content. Because of this, the execution time of the ALTER TABLE command is independent of the amount of data in the table. The ALTER TABLE command runs as quickly on a table with 10 million rows as it does on a table with 1 row.</source>
          <target state="translated">ALTER TABLE命令通过修改存储在&lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master表&lt;/a&gt;中的模式的SQL文本来工作。表格内容未做任何更改。因此，ALTER TABLE命令的执行时间与表中的数据量无关。ALTER TABLE命令在具有1000万行的表上的运行速度与在具有1行的表上的运行速度一样快。</target>
        </trans-unit>
        <trans-unit id="b0731871ca262efc59fc6d44f9562ddd3fdb4667" translate="yes" xml:space="preserve">
          <source>The ALTER TABLE command works by modifying the SQL text of the schema stored in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt;. No changes are made to table content. Because of this, the execution time of the ALTER TABLE command is independent of the amount of data in the table. The ALTER TABLE command runs as quickly on a table with 10 million rows as it does on a table with 1 row.</source>
          <target state="translated">ALTER TABLE命令通过修改存储在&lt;a href=&quot;schematab&quot;&gt;sqlite_schema表&lt;/a&gt;中的模式的SQL文本来工作。表格内容未做任何更改。因此，ALTER TABLE命令的执行时间与表中的数据量无关。ALTER TABLE命令在具有1000万行的表上的运行速度与在具有1行的表上的运行速度一样快。</target>
        </trans-unit>
        <trans-unit id="3548d68842f13a30875b616a72010deb210b5992" translate="yes" xml:space="preserve">
          <source>The ALWAYS(X) and NEVER(X) macros are a weaker statement about the truth of X. The presence of ALWAYS(X) or NEVER(X) means that the developers believe X is always or never true, but there is no proof, or the proof is complex and error-prone, or the proof depends on other aspects of the system that seem likely to change.</source>
          <target state="translated">ALWAYS(X)和NEVER(X)宏是关于X的真实性的较弱的声明,ALWAYS(X)或NEVER(X)的存在意味着开发者认为X总是或从不真实,但没有证明,或者证明很复杂,容易出错,或者证明依赖于系统的其他方面,而这些方面似乎有可能发生变化。</target>
        </trans-unit>
        <trans-unit id="6ae8b97d0df4ab8cc5246397daf337e302574c90" translate="yes" xml:space="preserve">
          <source>The ALWAYS(X) and NEVER(X) macros behave like assert(X) during functionality testing, because the developers want to be immediately alerted to the issue if the value of X is different from what is expected. But for delivery, ALWAYS(X) and NEVER(X) are simple pass-through macros, which provide defense-in-depth. For coverage testing ALWAYS(X) and NEVER(X) are hard-coded boolean values so that they do not cause unreachable machine code to be generated.</source>
          <target state="translated">在功能测试时,ALWAYS(X)和NEVER(X)宏的行为就像assert(X)一样,因为开发人员希望在X的值与预期不同时,能立即得到问题的提醒。但是对于交付来说,ALWAYS(X)和NEVER(X)是简单的传递宏,它提供了深入的防御。对于覆盖测试来说,ALWAYS(X)和NEVER(X)是硬编码的布尔值,这样就不会导致产生不可到达的机器代码。</target>
        </trans-unit>
        <trans-unit id="e07bd491ac7cf8d45ca2e35ee71bfa7a388a2b49" translate="yes" xml:space="preserve">
          <source>The ANALYZE command gathers statistics about tables and indices and stores the collected information in &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal tables&lt;/a&gt; of the database where the query optimizer can access the information and use it to help make better query planning choices. If no arguments are given, all attached databases are analyzed. If a schema name is given as the argument, then all tables and indices in that one database are analyzed. If the argument is a table name, then only that table and the indices associated with that table are analyzed. If the argument is an index name, then only that one index is analyzed.</source>
          <target state="translated">ANALYZE命令收集有关表和索引的统计信息，并将收集的信息存储在数据库的&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部表&lt;/a&gt;中，查询优化器可以在其中访问该信息，并使用它来帮助做出更好的查询计划选择。如果未提供任何参数，则将分析所有连接的数据库。如果给定模式名称作为参数，则将分析该数据库中的所有表和索引。如果参数是表名，则仅分析该表以及与该表关联的索引。如果参数是索引名称，则仅分析该索引。</target>
        </trans-unit>
        <trans-unit id="eab24cd68f511dec396088e10ba12e5df9e965d6" translate="yes" xml:space="preserve">
          <source>The AND operator determines the &lt;b&gt;intersection&lt;/b&gt; of two sets of documents.</source>
          <target state="translated">AND运算符确定两组文档的&lt;b&gt;交集&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="a3b6d448d425bac9ff08d9f7709bfd23114eaa1f" translate="yes" xml:space="preserve">
          <source>The AND operator may be implicitly specified. If two basic queries appear with no operator separating them in an FTS query string, the results are the same as if the two basic queries were separated by an AND operator. For example, the query expression &quot;implicit operator&quot; is a more succinct version of &quot;implicit AND operator&quot;.</source>
          <target state="translated">AND运算符可以隐式指定。如果在FTS查询字符串中出现了两个基本查询,但没有运算符将它们分开,那么结果与两个基本查询用AND运算符分开的结果是一样的。例如,查询表达式 &quot;隐式运算符 &quot;是 &quot;隐式AND运算符 &quot;的一个更简洁的版本。</target>
        </trans-unit>
        <trans-unit id="15fd0430aabb02304def7c36146cf671599d3942" translate="yes" xml:space="preserve">
          <source>The API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="938085178daf2eb44e4c20ce7562d652c273a4d4" translate="yes" xml:space="preserve">
          <source>The API for SQLite 3.0 includes 83 separate functions in addition to several data structures and #defines. (A complete &lt;a href=&quot;c3ref/intro&quot;&gt;API reference&lt;/a&gt; is provided as a separate document.) Fortunately, the interface is not nearly as complex as its size implies. Simple programs can still make do with only 3 functions: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, and &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;. More control over the execution of the database engine is provided using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; to compile an SQLite statement into byte code and &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; to execute that bytecode. A family of routines with names beginning with &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_&lt;/a&gt; is used to extract information about the result set of a query. Many interface functions come in pairs, with both a UTF-8 and UTF-16 version. And there is a collection of routines used to implement user-defined SQL functions and user-defined text collating sequences.</source>
          <target state="translated">SQLite 3.0的API除了几个数据结构和#defines之外，还包括83个单独的函数。 （完整的&lt;a href=&quot;c3ref/intro&quot;&gt;API参考&lt;/a&gt;作为单独的文档提供。）幸运的是，该接口并不像它的大小所暗示的那样复杂。简单的程序仍然只能使用3个函数：&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;和&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;。使用&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;将SQLite语句编译为字节码，并使用&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;执行该字节码，从而可以更好地控制数据库引擎的执行。名称以&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_&lt;/a&gt;开头的一系列例程用于提取有关查询结果集的信息。许多接口功能都是成对出现的，同时具有UTF-8和UTF-16版本。还有一系列例程，用于实现用户定义的SQL函数和用户定义的文本整理序列。</target>
        </trans-unit>
        <trans-unit id="c44a4b3ab13cd66c53e9432e0d3af7281c445940" translate="yes" xml:space="preserve">
          <source>The API for version 3.0 is similar to the version 2.X API, but with some important changes. Most noticeably, the &quot;&lt;code&gt;sqlite_&lt;/code&gt;&quot; prefix that occurs on the beginning of all API functions and data structures are changed to &quot;&lt;code&gt;sqlite3_&lt;/code&gt;&quot;. This avoids confusion between the two APIs and allows linking against both SQLite 2.X and SQLite 3.0 at the same time.</source>
          <target state="translated">版本3.0的API与版本2.X API相似，但有一些重要更改。最值得注意的是，出现在所有API函数和数据结构开头的&amp;ldquo; &lt;code&gt;sqlite_&lt;/code&gt; &amp;rdquo;前缀被更改为&amp;ldquo; &lt;code&gt;sqlite3_&lt;/code&gt; &amp;rdquo;。这样可以避免两个API之间的混淆，并允许同时链接到SQLite 2.X和SQLite 3.0。</target>
        </trans-unit>
        <trans-unit id="36d190e36c6e5fa5963aab7e95daad2e70b8ee67" translate="yes" xml:space="preserve">
          <source>The ATTACH DATABASE statement adds another database file to the current &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. Database files that were previously attached can be removed using the &lt;a href=&quot;lang_detach&quot;&gt;DETACH DATABASE&lt;/a&gt; command.</source>
          <target state="translated">ATTACH DATABASE语句将另一个数据库文件添加到当前&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接中&lt;/a&gt;。可以使用&lt;a href=&quot;lang_detach&quot;&gt;DETACH DATABASE&lt;/a&gt;命令删除以前附加的数据库文件。</target>
        </trans-unit>
        <trans-unit id="1e719935b3c48aaab57f1043bcfdf280a49c9b8d" translate="yes" xml:space="preserve">
          <source>The AUTOINCREMENT keyword imposes extra CPU, memory, disk space, and disk I/O overhead and should be avoided if not strictly needed. It is usually not needed.</source>
          <target state="translated">AUTOINCREMENT关键字会带来额外的CPU、内存、磁盘空间和磁盘I/O开销,如果不是绝对需要,应该避免使用。通常是不需要的。</target>
        </trans-unit>
        <trans-unit id="48851d12ae740edbaa05f50e23f70eaa76ffb64c" translate="yes" xml:space="preserve">
          <source>The Ascii tokenizer is similar to the Unicode61 tokenizer, except that:</source>
          <target state="translated">Ascii tokenizer与Unicode61 tokenizer类似,只是。</target>
        </trans-unit>
        <trans-unit id="12502ac36995aeed690062079cb8e1d738f368d7" translate="yes" xml:space="preserve">
          <source>The B-tree module requests information from the disk in fixed-size pages. The default &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; is 4096 bytes but can be any power of two between 512 and 65536 bytes. The page cache is responsible for reading, writing, and caching these pages. The page cache also provides the rollback and atomic commit abstraction and takes care of locking of the database file. The B-tree driver requests particular pages from the page cache and notifies the page cache when it wants to modify pages or commit or rollback changes. The page cache handles all the messy details of making sure the requests are handled quickly, safely, and efficiently.</source>
          <target state="translated">B树模块以固定大小的页面从磁盘请求信息。默认的&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt;为4096字节，但可以是512到65536字节之间的任意2的幂。页面缓存负责读取，写入和缓存这些页面。页面缓存还提供回滚和原子提交抽象，并负责锁定数据库文件。 B树驱动程序从页面缓存中请求特定页面，并在想要修改页面或提交或回滚更改时通知页面缓存。页面缓存处理所有混乱的细节，以确保快速，安全，高效地处理请求。</target>
        </trans-unit>
        <trans-unit id="a9c46870576aba5a82ba72dd5f506b8ec80b72f2" translate="yes" xml:space="preserve">
          <source>The BEFORE or AFTER keyword determines when the trigger actions will be executed relative to the insertion, modification or removal of the associated row.</source>
          <target state="translated">BEFORE或AFTER关键字决定了相对于插入、修改或删除关联行的触发操作的执行时间。</target>
        </trans-unit>
        <trans-unit id="21f8310c8a4f643230a41569cc835883561b2976" translate="yes" xml:space="preserve">
          <source>The BEFORE or AFTER keyword determines when the trigger actions will be executed relative to the insertion, modification or removal of the associated row. BEFORE is the default when neither keyword is present.</source>
          <target state="translated">BEFORE或AFTER关键字决定了相对于插入、修改或删除关联行的触发操作的执行时间。当两个关键字都不存在时,BEFORE是默认的。</target>
        </trans-unit>
        <trans-unit id="b63dc07d0b34107d9ff47bbfc25d958a7f1dde76" translate="yes" xml:space="preserve">
          <source>The BETWEEN operator</source>
          <target state="translated">BETWEEN运算符</target>
        </trans-unit>
        <trans-unit id="bf7d42c3d7c926828f621e364e6fa7e162b22076" translate="yes" xml:space="preserve">
          <source>The BETWEEN operator is logically equivalent to a pair of comparisons. &quot;</source>
          <target state="translated">BETWEEN运算符在逻辑上相当于一对比较。&quot;</target>
        </trans-unit>
        <trans-unit id="b2bdb770820ef0c5e362d9c32237f45d4cd0627c" translate="yes" xml:space="preserve">
          <source>The BLOB argument to snippet() does not have the correct subtype, so the snippet function ignores it, makes no changes to any data structures, and harmlessly returns NULL.</source>
          <target state="translated">snippet()的BLOB参数没有正确的子类型,所以snippet函数忽略它,不对任何数据结构进行更改,并无害地返回NULL。</target>
        </trans-unit>
        <trans-unit id="3210a7f9aaf2f66bd9905568531663be357a3b69" translate="yes" xml:space="preserve">
          <source>The BTree module allocates large buffers using malloc() instead of off of the stack, in order to play better on machines with limited stack space.</source>
          <target state="translated">BTree模块使用malloc()而不是堆栈外分配大缓冲区,以便在堆栈空间有限的机器上有更好的发挥。</target>
        </trans-unit>
        <trans-unit id="28ec130c322725529d5d7532a31940b3096646c9" translate="yes" xml:space="preserve">
          <source>The Bytecode() And Tables_Used() Table-Valued Functions</source>
          <target state="translated">Bytecode()和Tables_Used()表值函数。</target>
        </trans-unit>
        <trans-unit id="21f5d882ac3e8071ceb7ad0fcec2c3ef4f2e3e7c" translate="yes" xml:space="preserve">
          <source>The C code below implements a simple window aggregate function named sumint(). This works in the same way as the built-in sum() function, except that it throws an exception if passed an argument that is not an integer value.</source>
          <target state="translated">下面的 C 代码实现了一个简单的窗口聚合函数 sumint()。该函数的工作方式与内置的sum()函数相同,只是如果传递的参数不是整数值,它会抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="d5cf82df30f7e154d46c9db25174e218f7ef9aef" translate="yes" xml:space="preserve">
          <source>The C function to the right demonstrates one of the simplest, and most common, uses of the backup API: loading and saving the contents of an in-memory database to a file on disk. The backup API is used as follows in this example:</source>
          <target state="translated">右边的C函数演示了备份API最简单、最常见的用法之一:将内存数据库的内容加载并保存到磁盘上的文件中。在这个例子中,备份API的使用如下。</target>
        </trans-unit>
        <trans-unit id="d54a9c2fa57a9ea05dba3dee97529bc735dc5276" translate="yes" xml:space="preserve">
          <source>The C language interface to SQLite Version 2</source>
          <target state="translated">SQLite第二版的C语言接口</target>
        </trans-unit>
        <trans-unit id="fe37317d6916dca66fe00426df36e00a240b1501" translate="yes" xml:space="preserve">
          <source>The C language is old and boring. It is a well-known and well-understood language. This is exactly what one wants when developing a module like SQLite. Writing a small, fast, and reliable database engine is hard enough as it is without the implementation language changing out from under you with each update to the implementation language specification.</source>
          <target state="translated">C语言是古老而枯燥的。它是一种众所周知的、好理解的语言。这正是人们在开发像SQLite这样的模块时想要的。编写一个小型的、快速的、可靠的数据库引擎已经很困难了,因为它不需要实现语言随着实现语言规范的每次更新而从你的脚下改变。</target>
        </trans-unit>
        <trans-unit id="7245ee6098ebc8d6b59383d4e63478298246efb9" translate="yes" xml:space="preserve">
          <source>The C parameter to &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close(C)&lt;/a&gt; and &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2(C)&lt;/a&gt; must be either a NULL pointer or an &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object pointer obtained from &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and not previously closed. Calling sqlite3_close() or sqlite3_close_v2() with a NULL pointer argument is a harmless no-op.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close（C）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2（C）&lt;/a&gt;的C参数必须是NULL指针或从&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;获得的&lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象指针，并且之前未关闭。使用NULL指针参数调用sqlite3_close（）或sqlite3_close_v2（）是无害的操作。</target>
        </trans-unit>
        <trans-unit id="7c0540d8d33318130da25d1e55f755e6a1ecc3bb" translate="yes" xml:space="preserve">
          <source>The C parameter to &lt;a href=&quot;close&quot;&gt;sqlite3_close(C)&lt;/a&gt; and &lt;a href=&quot;close&quot;&gt;sqlite3_close_v2(C)&lt;/a&gt; must be either a NULL pointer or an &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object pointer obtained from &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and not previously closed. Calling sqlite3_close() or sqlite3_close_v2() with a NULL pointer argument is a harmless no-op.</source>
          <target state="translated">&lt;a href=&quot;close&quot;&gt;sqlite3_close（C）&lt;/a&gt;和&lt;a href=&quot;close&quot;&gt;sqlite3_close_v2（C）&lt;/a&gt;的C参数必须是NULL指针或从&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;open&quot;&gt;sqlite3_open16（）&lt;/a&gt;或&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;获得的&lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象指针，并且之前未关闭。使用NULL指针参数调用sqlite3_close（）或sqlite3_close_v2（）是无害的操作。</target>
        </trans-unit>
        <trans-unit id="c6b84eb128b8b4492347bcdafbeda21b63c03f1b" translate="yes" xml:space="preserve">
          <source>The C-language API for SQLite provides the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;file control&lt;/a&gt; which gives &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations the opportunity to add new PRAGMA statements or to override the meaning of built-in PRAGMA statements.</source>
          <target state="translated">用于SQLite的C语言API提供了&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA &lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;文件控件&lt;/a&gt;，该控件使&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;实现可以添加新的PRAGMA语句或覆盖内置PRAGMA语句的含义。</target>
        </trans-unit>
        <trans-unit id="3cdde2acd27b2b36bcb4e6d376af3a07b88f1a00" translate="yes" xml:space="preserve">
          <source>The CASE expression</source>
          <target state="translated">CASE表达式</target>
        </trans-unit>
        <trans-unit id="b66ba15f2fad294f2684c4bed978c753222465dc" translate="yes" xml:space="preserve">
          <source>The CAST operator understands decimal integers only &amp;mdash; conversion of &lt;a href=&quot;lang_expr#hexint&quot;&gt;hexadecimal integers&lt;/a&gt; stops at the &quot;x&quot; in the &quot;0x&quot; prefix of the hexadecimal integer string and thus result of the CAST is always zero.</source>
          <target state="translated">CAST运算符仅理解十进制整数- &lt;a href=&quot;lang_expr#hexint&quot;&gt;十六进制整数的&lt;/a&gt;转换在十六进制整数字符串的&amp;ldquo; 0x&amp;rdquo;前缀中的&amp;ldquo; x&amp;rdquo;处停止，因此CAST的结果始终为零。</target>
        </trans-unit>
        <trans-unit id="a234c8e77cd8f0401958366a773fd160b49e7507" translate="yes" xml:space="preserve">
          <source>The CLI has another build-in SQL function named edit(). Edit() takes one or two arguments. The first argument is a value - usually a large multi-line string to be edited. The second argument is the name of a text editor. If the second argument is omitted, the VISUAL environment variable is used. The edit() function writes its first argument into a temporary file, invokes the editor on the temporary file, rereads the file back into memory after the editor is done, then returns the edited text.</source>
          <target state="translated">CLI有另一个内置的SQL函数edit()。edit()需要一个或两个参数。第一个参数是一个值--通常是一个要编辑的大型多行字符串。第二个参数是一个文本编辑器的名称。如果第二个参数被省略,则使用VISUAL环境变量。edit()函数将它的第一个参数写入一个临时文件,在临时文件上调用编辑器,在编辑器完成后将文件重读回内存,然后返回编辑后的文本。</target>
        </trans-unit>
        <trans-unit id="19b42365ba0a7a06fdcdf543ad6806dc3520342c" translate="yes" xml:space="preserve">
          <source>The CLI ignores whitespace (including comments) at the end of lines</source>
          <target state="translated">CLI会忽略行末的空白(包括注释)。</target>
        </trans-unit>
        <trans-unit id="dd9e96d76e423f66ac741c4a46deda1233291328" translate="yes" xml:space="preserve">
          <source>The COLLATE clause optionally following each column name or expression defines a collating sequence used for text entries in that column. The default collating sequence is the collating sequence defined for that column in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. Or if no collating sequence is otherwise defined, the built-in BINARY collating sequence is used.</source>
          <target state="translated">可选的在每个列名称或表达式之后的COLLATE子句定义用于该列中文本输入的整理顺序。默认的整理顺序是在&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句中为该列定义的整理顺序。或者，如果没有另外定义整理顺序，则使用内置的BINARY整理顺序。</target>
        </trans-unit>
        <trans-unit id="cce4b68250de466854c34f5909554bfe291d7ca1" translate="yes" xml:space="preserve">
          <source>The COLLATE clause specifies the name of a &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; to use as the default collation sequence for the column. If no COLLATE clause is specified, the default collation sequence is &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt;.</source>
          <target state="translated">COLLATE子句指定&lt;a href=&quot;datatype3#collation&quot;&gt;排序规则序列&lt;/a&gt;的名称，用作该列的默认排序规则序列。如果未指定COLLATE子句，则默认排序规则序列为&lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4b44ceebb8207f8e640174bbe459b285c5b2aace" translate="yes" xml:space="preserve">
          <source>The COLLATE operator is a unary postfix operator that assigns a &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; to an expression. The COLLATE operator has a higher precedence (binds more tightly) than any binary operator and any unary prefix operator except &quot;~&quot;. (COLLATE and &quot;~&quot; are associative so their binding order does not matter.) The collating sequence set by the COLLATE operator overrides the collating sequence determined by the COLLATE clause in a table &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definition&lt;/a&gt;. See the &lt;a href=&quot;datatype3#collation&quot;&gt;detailed discussion on collating sequences&lt;/a&gt; in the &lt;a href=&quot;datatype3&quot;&gt;Datatype In SQLite3&lt;/a&gt; document for additional information.</source>
          <target state="translated">COLLATE运算符是一元后缀运算符，用于将&lt;a href=&quot;datatype3#collation&quot;&gt;排序顺序&lt;/a&gt;分配给表达式。 COLLATE运算符的优先级（绑定更紧密）比任何二进制运算符和除&amp;ldquo;〜&amp;rdquo;之外的任何一元前缀运算符都高。 （COLLATE和&amp;ldquo;〜&amp;rdquo;是关联的，因此它们的绑定顺序无关紧要。）COLLATE运算符设置的整理顺序将覆盖表&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;列定义中&lt;/a&gt; COLLATE子句确定的整理顺序。有关其他信息，请参见&lt;a href=&quot;datatype3&quot;&gt;SQLite3&lt;/a&gt;中的数据类型中&lt;a href=&quot;datatype3#collation&quot;&gt;有关整理序列&lt;/a&gt;的详细讨论。</target>
        </trans-unit>
        <trans-unit id="a680bd512c99945ec1f5ce6f701753b4eac29105" translate="yes" xml:space="preserve">
          <source>The COMPLETION extension implements a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; named &quot;completion&quot; that can be used to suggest completions of partially entered words during interactive SQL input. The completion table can be used to help implement tab-completion, for example.</source>
          <target state="translated">COMPLETION扩展实现了一个名为&amp;ldquo; completion&amp;rdquo; 的&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;，该函数可用于在交互式SQL输入期间建议部分输入的单词的完成。例如，完成表可用于帮助实现制表符完成。</target>
        </trans-unit>
        <trans-unit id="f18272789e8a6f151079fbc600b2b7e84d838750" translate="yes" xml:space="preserve">
          <source>The COMPLETION() Table-Valued Function</source>
          <target state="translated">表值函数COMPLETION()</target>
        </trans-unit>
        <trans-unit id="6a7ddb1a93117b2b3bde0c54048509560ea3634c" translate="yes" xml:space="preserve">
          <source>The COPY command puts NULLs in columns whose data is '\N'.</source>
          <target state="translated">COPY命令在数据为&quot;/N &quot;的列中放置NULL。</target>
        </trans-unit>
        <trans-unit id="13eb987eb47f3316a50f4573a4bd655a2e5a8454" translate="yes" xml:space="preserve">
          <source>The CORRUPT_DB macro is used in many assert() statements. In functional testing builds, CORRUPT_DB references a global variable that is true if the database file might contain corruption. This variable is true by default, since we do not normally know whether or not a database is corrupt, but during testing while working on databases that are known to be well-formed, that global variable can be set to false. Then the CORRUPT_DB macro can be used in assert() statements such as seen at &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=1679-1680&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=1679-1680&lt;/a&gt;. Those assert()s specify pre-conditions to the routine that are true for consistent database files, but which might be false if the database file is corrupt. Knowledge of these kinds of conditions is very helpful to readers who are trying to understand a block of code in isolation.</source>
          <target state="translated">CORRUPT_DB宏用于许多assert（）语句中。在功能测试版本中，CORRUPT_DB引用一个全局变量，如果数据库文件可能包含损坏，则该变量为true。默认情况下，此变量为true，因为我们通常不知道数据库是否已损坏，但是在测试已知格式正确的数据库时，可以将全局变量设置为false。然后可以在assert（）语句中使用CORRUPT_DB宏，例如&lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=1679-1680&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=1679-1680&lt;/a&gt;。这些assert（）指定例程的前提条件，这些前提条件对于一致的数据库文件为true，但如果数据库文件损坏，则可能为false。对试图独立理解代码块的读者来说，了解这类条件非常有帮助。</target>
        </trans-unit>
        <trans-unit id="87b68f64512a185516fdf233a80a1c3ea3aa60fd" translate="yes" xml:space="preserve">
          <source>The CREATE INDEX command consists of the keywords &quot;CREATE INDEX&quot; followed by the name of the new index, the keyword &quot;ON&quot;, the name of a previously created table that is to be indexed, and a parenthesized list of table column names and/or expressions that are used for the index key. If the optional WHERE clause is included, then the index is a &quot;&lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;&quot;.</source>
          <target state="translated">CREATE INDEX命令由关键字&amp;ldquo; CREATE INDEX&amp;rdquo;，新索引的名称，关键字&amp;ldquo; ON&amp;rdquo;，先前要建立索引的表的名称以及带括号的表列名称和/组成的列表组成或用于索引键的表达式。如果包含可选的WHERE子句，则索引为&amp;ldquo; &lt;a href=&quot;partialindex&quot;&gt;部分索引&lt;/a&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="abdfd2b1dd5fd6ecf72fce71bade948329a001e4" translate="yes" xml:space="preserve">
          <source>The CREATE TRIGGER statement is used to add triggers to the database schema. Triggers are database operations that are automatically performed when a specified database event occurs.</source>
          <target state="translated">CREATE TRIGGER语句用于向数据库模式添加触发器。触发器是指当指定的数据库事件发生时自动执行的数据库操作。</target>
        </trans-unit>
        <trans-unit id="598d64a270f59326bd978afae12168eba5f52ca0" translate="yes" xml:space="preserve">
          <source>The CREATE VIEW command assigns a name to a pre-packaged &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. Once the view is created, it can be used in the FROM clause of another &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; in place of a table name.</source>
          <target state="translated">CREATE VIEW命令为预包装的&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句分配名称。创建视图后，可以在另一个&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;的FROM子句中使用它代替表名。</target>
        </trans-unit>
        <trans-unit id="174705dc4a8b591705076f7ea08e69231535552a" translate="yes" xml:space="preserve">
          <source>The CREATE VIRTUAL TABLE &quot;tokenize&quot; option is used to configure the specific tokenizer used by the FTS5 table. The option argument must be either an FTS5 bareword, or an SQL text literal. The text of the argument is itself treated as a white-space series of one or more FTS5 barewords or SQL text literals. The first of these is the name of the tokenizer to use. The second and subsequent list elements, if they exist, are arguments passed to the tokenizer implementation.</source>
          <target state="translated">CREATE VIRTUAL TABLE &quot;tokenize &quot;选项用于配置FTS5表使用的特定标记器。选项参数必须是一个FTS5裸词,或者一个SQL文本文字。参数的文本本身被视为由一个或多个FTS5裸词或SQL文本文字组成的空位序列。其中第一个是要使用的标记符的名称。第二个和后续的列表元素(如果存在)是传递给tokenizer实现的参数。</target>
        </trans-unit>
        <trans-unit id="5585953bde77b974603ba3ea6e6ff59c9cc91b38" translate="yes" xml:space="preserve">
          <source>The CREATE VIRTUAL TABLE statement creates a new table called table-name derived from the class class module-name. The module-name is the name that is registered for the virtual table by the &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; interface.</source>
          <target state="translated">CREATE VIRTUAL TABLE语句创建一个名为table-name的新表，该表是从类class module-name派生的。module-name是通过&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module（）&lt;/a&gt;接口为虚拟表注册的名称。</target>
        </trans-unit>
        <trans-unit id="1062968fd409aff74d10cea95e91438b9101e01c" translate="yes" xml:space="preserve">
          <source>The CREATE, TABLE, VIEW, TRIGGER, and INDEX keywords at the beginning of the statement are converted to all upper case letters.</source>
          <target state="translated">语句开头的CREATE、TABLE、VIEW、TRIGGER和INDEX关键字被转换为所有大写字母。</target>
        </trans-unit>
        <trans-unit id="640a12b822aa85aa459e9a1bb86ef50f7f04eecb" translate="yes" xml:space="preserve">
          <source>The CSV Virtual Table</source>
          <target state="translated">CSV虚拟表</target>
        </trans-unit>
        <trans-unit id="7457dbcb832f7358700e049001b26f6040f77dbe" translate="yes" xml:space="preserve">
          <source>The CSV virtual table is not built into the SQLite amalgamation. It is available as a &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/csv.c&quot;&gt;separate source file&lt;/a&gt; that can be compiled into a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;. Typical usage of the CSV virtual table from the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; would be something like this:</source>
          <target state="translated">CSV虚拟表未内置到SQLite合并中。它作为&lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/csv.c&quot;&gt;单独的源文件提供&lt;/a&gt;，可以编译成&lt;a href=&quot;loadext&quot;&gt;可加载的扩展名&lt;/a&gt;。&lt;a href=&quot;cli&quot;&gt;命令行外壳中&lt;/a&gt; CSV虚拟表的典型用法如下：</target>
        </trans-unit>
        <trans-unit id="15b49f55e220937bbbf59d823ad49d5a9aa75e6b" translate="yes" xml:space="preserve">
          <source>The CSV virtual table is useful to applications that need to bulk-load large amounts of comma-separated value content. The CSV virtual table is also useful as a template source file for implementing other virtual tables.</source>
          <target state="translated">CSV虚拟表对于需要批量加载大量逗号分隔值内容的应用程序非常有用。CSV虚拟表还可以作为实现其他虚拟表的模板源文件。</target>
        </trans-unit>
        <trans-unit id="ea497adefbfc963344834dc953220548ab21ec73" translate="yes" xml:space="preserve">
          <source>The CSV virtual table reads &lt;a href=&quot;https://www.ietf.org/rfc/rfc4180.txt&quot;&gt;RFC 4180&lt;/a&gt; formatted comma-separated values, and returns that content as if it were rows and columns of an SQL table.</source>
          <target state="translated">CSV虚拟表读取&lt;a href=&quot;https://www.ietf.org/rfc/rfc4180.txt&quot;&gt;RFC 4180&lt;/a&gt;格式的逗号分隔值，并返回该内容，就好像它是SQL表的行和列一样。</target>
        </trans-unit>
        <trans-unit id="701ea259a9685ea4d0bc43814eed54520d975a72" translate="yes" xml:space="preserve">
          <source>The Callback instruction in this example has to generate data for three result columns instead of two, but is otherwise the same as in the first query. When the Callback instruction is invoked, the left-most column of the result should be the lowest in the stack and the right-most result column should be the top of the stack. We can see the stack being set up this way at addresses 11 through 15. The Column instructions at 11 and 12 push the values for the first two columns in the result. The two Column instructions at 13 and 14 pull in the values needed to compute the third result column and the Concat instruction at 15 joins them together into a single entry on the stack.</source>
          <target state="translated">本例中的Callback指令必须为三个结果列而不是两个结果列生成数据,但其他方面与第一个查询相同。当调用Callback指令时,结果中最左边的一列应该是堆栈中最低的,最右边的结果列应该是堆栈的顶部。我们可以看到堆栈在地址11到15处是这样设置的。11和12处的Column指令推送结果中前两列的值。在13和14处的两条Column指令将计算第三列结果所需的值拉入,在15处的Concat指令将它们连接在一起,成为堆栈上的一个条目。</target>
        </trans-unit>
        <trans-unit id="421f0a20824677ed3aab71d6f46b98a38cc2b1ed" translate="yes" xml:space="preserve">
          <source>The Carray() Table-Valued Function</source>
          <target state="translated">Carray()表值函数</target>
        </trans-unit>
        <trans-unit id="b6379901f8c254a706f0c6dbee9e66ad0809b055" translate="yes" xml:space="preserve">
          <source>The Checklist Manifesto</source>
          <target state="translated">核对表宣言</target>
        </trans-unit>
        <trans-unit id="9d300d65d6982ada326a006dd308b939bbd26748" translate="yes" xml:space="preserve">
          <source>The Checksum VFS Shim</source>
          <target state="translated">校验和VFS Shim</target>
        </trans-unit>
        <trans-unit id="b16740a57ff0b848b3dcfa1e89789fe4179b42d5" translate="yes" xml:space="preserve">
          <source>The Clang/LLVM compiler is not competitive with GCC. Clang-generated binaries are consistently larger and slower than GCC-generated binaries.</source>
          <target state="translated">Clang/LLVM编译器与GCC相比没有竞争力。Clang生成的二进制文件一直比GCC生成的二进制文件大,速度慢。</target>
        </trans-unit>
        <trans-unit id="78bc8f511390974d6caf83474dc6a28ef2586f49" translate="yes" xml:space="preserve">
          <source>The Close instruction at the end of the program closes the cursor that points into the table &quot;examp&quot;. It is not really necessary to call Close here since all cursors will be automatically closed by the VDBE when the program halts. But we needed an instruction for the Rewind to jump to so we might as well go ahead and have that instruction do something useful. The Halt instruction ends the VDBE program.</source>
          <target state="translated">程序末尾的Close指令关闭了指向表 &quot;examp &quot;的游标。这里其实没有必要调用Close指令,因为当程序停止时,所有的游标都会被VDBE自动关闭。但是我们需要一个指令让Rewind跳转到,所以我们不妨继续让这个指令做一些有用的事情。Halt指令结束了VDBE程序。</target>
        </trans-unit>
        <trans-unit id="b524e42667c1ac047d027b2497617d613c12fde4" translate="yes" xml:space="preserve">
          <source>The D and N arguments to sqlite3_backup_init(D,N,S,M) are the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; associated with the destination database and the database name, respectively. The database name is &quot;main&quot; for the main database, &quot;temp&quot; for the temporary database, or the name specified after the AS keyword in an &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for an attached database. The S and M arguments passed to sqlite3_backup_init(D,N,S,M) identify the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and database name of the source database, respectively. The source and destination &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; (parameters S and D) must be different or else sqlite3_backup_init(D,N,S,M) will fail with an error.</source>
          <target state="translated">sqlite3_backup_init（D，N，S，M）的D和N参数分别是与目标数据库和数据库名称关联的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;。对于主数据库，数据库名称是&amp;ldquo; main&amp;rdquo;，对于临时数据库，数据库名称是&amp;ldquo; temp&amp;rdquo;，或者对于附加数据库，在&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;语句中的AS关键字之后指定的名称。传递给sqlite3_backup_init（D，N，S，M）的S和M参数分别标识&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;和源数据库的数据库名称。源和目标&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;（参数S和D）必须不同，否则sqlite3_backup_init（D，N，S，M）将失败并显示错误。</target>
        </trans-unit>
        <trans-unit id="f80ea416ab3893dba34d3603b147323625f4c5ae" translate="yes" xml:space="preserve">
          <source>The D and N arguments to sqlite3_backup_init(D,N,S,M) are the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; associated with the destination database and the database name, respectively. The database name is &quot;main&quot; for the main database, &quot;temp&quot; for the temporary database, or the name specified after the AS keyword in an &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for an attached database. The S and M arguments passed to sqlite3_backup_init(D,N,S,M) identify the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and database name of the source database, respectively. The source and destination &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; (parameters S and D) must be different or else sqlite3_backup_init(D,N,S,M) will fail with an error.</source>
          <target state="translated">sqlite3_backup_init（D，N，S，M）的D和N参数分别是与目标数据库和数据库名称关联的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;。对于主数据库，数据库名称是&amp;ldquo; main&amp;rdquo;，对于临时数据库，数据库名称是&amp;ldquo; temp&amp;rdquo;，或者对于附加数据库，在&lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;语句中的AS关键字之后指定的名称。传递给sqlite3_backup_init（D，N，S，M）的S和M参数分别标识&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;和源数据库的数据库名称。源和目标&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;（参数S和D）必须不同，否则sqlite3_backup_init（D，N，S，M）将失败并显示错误。</target>
        </trans-unit>
        <trans-unit id="8f1eeb8e873e48b54ccf8adc2382597a61daec29" translate="yes" xml:space="preserve">
          <source>The D parameter to &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; may be NULL. If the D parameter in &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; is not NULL, then the maximum length of the string contained in the &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object will be the value set for &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;(D,&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) instead of &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new（D）&lt;/a&gt;的D参数可以为NULL。如果&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new（D）中&lt;/a&gt;的D参数不为NULL，则&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;对象中包含的字符串的最大长度将是为&lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;（D，&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;）设置的值，而不是&lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f7435a55126fe3b0801a03e561888366bace9433" translate="yes" xml:space="preserve">
          <source>The D parameter to &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; may be NULL. If the D parameter in &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; is not NULL, then the maximum length of the string contained in the &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object will be the value set for &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;(D,&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) instead of &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new（D）&lt;/a&gt;的D参数可以为NULL。如果&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new（D）中&lt;/a&gt;的D参数不为NULL，则&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;对象中包含的字符串的最大长度将是为&lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;（D，&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;）设置的值，而不是&lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="091a2ba2d55b0a7d15b54d374b18e4d57aa3a683" translate="yes" xml:space="preserve">
          <source>The DBSTAT Virtual Table</source>
          <target state="translated">DBSTAT虚拟表</target>
        </trans-unit>
        <trans-unit id="97ceb7c4621bdd8f62a9cfbb2a879b8e9e999bd7" translate="yes" xml:space="preserve">
          <source>The DBSTAT table only reports on the content of btrees within the database file. Freelist pages, pointer-map pages, and the lock page are omitted from the analysis.</source>
          <target state="translated">DBSTAT表只报告数据库文件中btrees的内容。自由列表页、指针映射页和锁页在分析中被省略。</target>
        </trans-unit>
        <trans-unit id="76cd10f2092ca8f1b285dee48937f8c50e332d42" translate="yes" xml:space="preserve">
          <source>The DBSTAT virtual table is a read-only &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; that returns information about the amount of disk space used to store the content of an SQLite database. Example use cases for the DBSTAT virtual table include the &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt; utility program and the &lt;a href=&quot;https://www.sqlite.org/src/repo-tabsize&quot;&gt;table size pie-chart&lt;/a&gt; in the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil-implemented&lt;/a&gt; version control system for SQLite.</source>
          <target state="translated">DBSTAT虚拟表是一个只读的&lt;a href=&quot;vtab#epovtab&quot;&gt;同义虚拟表&lt;/a&gt;，它返回有关用于存储SQLite数据库内容的磁盘空间量的信息。DBSTAT虚拟表的示例用例包括&lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt;实用程序和SQLite在&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil实现的&lt;/a&gt;版本控制系统中的&lt;a href=&quot;https://www.sqlite.org/src/repo-tabsize&quot;&gt;表大小饼图&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="53bde0cca31e9e282f188b556d84747d1c6f1e06" translate="yes" xml:space="preserve">
          <source>The DBSTAT virtual table is a read-only &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; that returns information about which pages of the database files are used by which tables and indexes in the schema. The DBSTAT virtual table is used to implement &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt; utility program, and to help compute the &lt;a href=&quot;https://www.sqlite.org/src/repo-tabsize&quot;&gt;table size pie-chart&lt;/a&gt; in the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil-implemented&lt;/a&gt; version control system for SQLite.</source>
          <target state="translated">DBSTAT虚拟表是一个只读的&lt;a href=&quot;vtab#epovtab&quot;&gt;同义虚拟表&lt;/a&gt;，它返回有关模式中的哪些表和索引使用数据库文件的哪些页面的信息。 DBSTAT虚拟表用于实现&lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt;实用程序，并有助于在&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil实现&lt;/a&gt;的SQLite版本控制系统中计算&lt;a href=&quot;https://www.sqlite.org/src/repo-tabsize&quot;&gt;表大小的饼图&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a9ce5a525fa3a87844d5ab55ef30cdd54b0cc3c2" translate="yes" xml:space="preserve">
          <source>The DBSTAT virtual table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;, meaning that is not necessary to run &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; to create an instance of the dbstat virtual table before using it. The &quot;dbstat&quot; module name can be used as if it were a table name to query the dbstat virtual table directly. For example:</source>
          <target state="translated">DBSTAT虚拟表是一个&lt;a href=&quot;vtab#epovtab&quot;&gt;同义的虚拟表&lt;/a&gt;，这意味着在使用它之前，不必运行&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;来创建dbstat虚拟表的实例。可以使用&amp;ldquo; dbstat&amp;rdquo;模块名称作为直接查询dbstat虚拟表的表名称。例如：</target>
        </trans-unit>
        <trans-unit id="f357b6765d9672540c415d35375e9c82ab3dde27" translate="yes" xml:space="preserve">
          <source>The DBSTAT virtual table is available on all &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; when SQLite is built using the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; compile-time option.</source>
          <target state="translated">使用&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt;编译时选项构建SQLite时，DBSTAT虚拟表在所有&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;上均可用。</target>
        </trans-unit>
        <trans-unit id="8e77f3a2af88468cea075512b7c593d618135668" translate="yes" xml:space="preserve">
          <source>The DEFAULT clause specifies a default value to use for the column if no value is explicitly provided by the user when doing an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;. If there is no explicit DEFAULT clause attached to a column definition, then the default value of the column is NULL. An explicit DEFAULT clause may specify that the default value is NULL, a string constant, a blob constant, a signed-number, or any constant expression enclosed in parentheses. A default value may also be one of the special case-independent keywords CURRENT_TIME, CURRENT_DATE or CURRENT_TIMESTAMP. For the purposes of the DEFAULT clause, an expression is considered constant if it contains no sub-queries, column or table references, &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;, or string literals enclosed in double-quotes instead of single-quotes.</source>
          <target state="translated">如果用户在执行&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;时未明确提供任何值，则DEFAULT子句指定用于该列的默认值。如果没有显式的DEFAULT子句附加到列定义，则该列的默认值为NULL。显式的DEFAULT子句可以指定默认值为NULL，字符串常量，blob常量，带符号的数字或括号中包含的任何常量表达式。默认值也可以是与大小写无关的特殊关键字之一，CURRENT_TIME，CURRENT_DATE或CURRENT_TIMESTAMP。就DEFAULT子句而言，如果表达式不包含用双引号（而不是单引号）引起的子查询，列或表引用，&lt;a href=&quot;lang_expr#varparam&quot;&gt;绑定参数&lt;/a&gt;或字符串文字，则该表达式被视为常量。</target>
        </trans-unit>
        <trans-unit id="f30a44f7fde1290a9d66490fe4c7fc9d343db0a2" translate="yes" xml:space="preserve">
          <source>The DELETE command removes records from the table identified by the &lt;a href=&quot;syntax/qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;.</source>
          <target state="translated">DELETE命令从&lt;a href=&quot;syntax/qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;标识的表中删除记录。</target>
        </trans-unit>
        <trans-unit id="549ed1cfefc84f8dde1745ba5b3bb051dd3b5008" translate="yes" xml:space="preserve">
          <source>The DELETE command without a WHILE clause just removes the database files from the disk, rather than going through and deleting record by record.</source>
          <target state="translated">没有WHILE子句的DELETE命令只是将数据库文件从磁盘上删除,而不是逐条记录进行删除。</target>
        </trans-unit>
        <trans-unit id="0c69d162dd597ca7eb6e965c55e71ba6c6554cc2" translate="yes" xml:space="preserve">
          <source>The DELETE journaling mode is the normal behavior. In the DELETE mode, the rollback journal is deleted at the conclusion of each transaction. Indeed, the delete operation is the action that causes the transaction to commit. (See the document titled &lt;a href=&quot;atomiccommit&quot;&gt; Atomic Commit In SQLite&lt;/a&gt; for additional detail.)</source>
          <target state="translated">删除日记记录模式是正常行为。在DELETE模式下，回滚日志在每个事务结束时被删除。实际上，删除操作是导致事务提交的操作。（有关其他详细信息，请参见标题为&amp;ldquo; &lt;a href=&quot;atomiccommit&quot;&gt;SQLite&lt;/a&gt;中的原子提交&amp;rdquo;的文档。）</target>
        </trans-unit>
        <trans-unit id="1da9a7936dc2b558a9310f00abb6a148be159cba" translate="yes" xml:space="preserve">
          <source>The DELETE trigger must be fired before the actual delete takes place on the content table. This is so that FTS4 can still retrieve the original values in order to update the full-text index. And the INSERT trigger must be fired after the new row is inserted, so as to handle the case where the rowid is assigned automatically within the system. The UPDATE trigger must be split into two parts, one fired before and one after the update of the content table, for the same reasons.</source>
          <target state="translated">DELETE触发器必须在内容表的实际删除发生之前被激活。这是为了让FTS4仍然可以检索到原始值,以便更新全文索引。而INSERT触发器必须在插入新行之后才会被触发,这样才能处理系统内自动分配rowid的情况。UPDATE触发器必须分成两部分,一部分在内容表更新前和更新后发射,原因相同。</target>
        </trans-unit>
        <trans-unit id="3ab4459caaad95b429957125366d895b4021e494" translate="yes" xml:space="preserve">
          <source>The DELETE-mode locks are stored on the &lt;a href=&quot;fileformat2#lockbyte&quot;&gt;lock-byte page&lt;/a&gt; of the main database file. Only SQLITE_LOCK_SHARED and SQLITE_LOCK_EXCLUSIVE are factors for WAL-mode databases. The other locking states are used in rollback-mode, but not in WAL-mode.</source>
          <target state="translated">删除模式锁存储在主数据库文件的&lt;a href=&quot;fileformat2#lockbyte&quot;&gt;锁字节页面&lt;/a&gt;上。只有SQLITE_LOCK_SHARED和SQLITE_LOCK_EXCLUSIVE是WAL模式数据库的因素。其他锁定状态用于回滚模式，但不用于WAL模式。</target>
        </trans-unit>
        <trans-unit id="577fca03e1d22d54957a27f6f46f602e956a7f46" translate="yes" xml:space="preserve">
          <source>The DISTINCT keyword in an aggregate query</source>
          <target state="translated">汇总查询中的DISTINCT关键字。</target>
        </trans-unit>
        <trans-unit id="5960207cc3ff80c8b76aafd25f9f8b94d8c8f42b" translate="yes" xml:space="preserve">
          <source>The DISTINCT keyword now will sometimes use an INDEX if an appropriate index is available and the optimizer thinks its use might be advantageous.</source>
          <target state="translated">DISTINCT关键字现在有时会使用INDEX,如果有合适的索引,并且优化器认为使用它可能是有利的。</target>
        </trans-unit>
        <trans-unit id="fc7140e369fedc4714b9ea0083c995ff08e24d5b" translate="yes" xml:space="preserve">
          <source>The DISTINCT keyword on an aggregate query is implemented by creating a transient index in a temporary file and storing each result row in that index. As new result rows are computed a check is made to see if they already exist in the transient index and if they do the new result row is discarded.</source>
          <target state="translated">汇总查询中的DISTINCT关键字是通过在临时文件中创建一个瞬时索引并将每条结果行存储在该索引中来实现的。当计算新的结果行时,会检查它们是否已经存在于瞬时索引中,如果存在,新的结果行就会被丢弃。</target>
        </trans-unit>
        <trans-unit id="3c8c0a43ed7404e0a2eaed887060f73b06109a61" translate="yes" xml:space="preserve">
          <source>The DROP INDEX statement removes an index added with the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement. The index is completely removed from the disk. The only way to recover the index is to reenter the appropriate &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; command.</source>
          <target state="translated">DROP INDEX语句删除与&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;语句一起添加的索引。索引已从磁盘上完全删除。恢复索引的唯一方法是重新输入适当的&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="bf79716c365aa3a9096fb80997c218efa52bf726" translate="yes" xml:space="preserve">
          <source>The DROP TABLE statement removes a table added with the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. The name specified is the table name. The dropped table is completely removed from the database schema and the disk file. The table can not be recovered. All indices and triggers associated with the table are also deleted.</source>
          <target state="translated">DROP TABLE语句删除添加了&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句的表。指定的名称是表名称。删除的表已从数据库架构和磁盘文件中完全删除。该表无法恢复。与该表关联的所有索引和触发器也将被删除。</target>
        </trans-unit>
        <trans-unit id="36408d79ec98249ee45d04e3ce654c80cdb2a791" translate="yes" xml:space="preserve">
          <source>The DROP TRIGGER statement removes a trigger created by the &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement. Once removed, the trigger definition is no longer present in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; (or sqlite_temp_schema) table and is not fired by any subsequent INSERT, UPDATE or DELETE statements.</source>
          <target state="translated">DROP TRIGGER语句删除由&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;语句创建的触发器。一旦删除，触发器定义将不再出现在&lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt;（或sqlite_temp_schema）表中，并且不会被任何后续的INSERT，UPDATE或DELETE语句触发。</target>
        </trans-unit>
        <trans-unit id="8134f9df85fa3c68e953f09b317e3c27f145a52e" translate="yes" xml:space="preserve">
          <source>The DROP TRIGGER statement removes a trigger created by the &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement. Once removed, the trigger definition is no longer present in the sqlite_master (or sqlite_temp_master) table and is not fired by any subsequent INSERT, UPDATE or DELETE statements.</source>
          <target state="translated">DROP TRIGGER语句删除由&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;语句创建的触发器。一旦删除，触发器定义将不再出现在sqlite_master（或sqlite_temp_master）表中，并且不会被任何后续的INSERT，UPDATE或DELETE语句激发。</target>
        </trans-unit>
        <trans-unit id="5c4386299e0353e3df19809c98731f022556c566" translate="yes" xml:space="preserve">
          <source>The DROP VIEW statement removes a view created by the &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; statement. The view definition is removed from the database schema, but no actual data in the underlying base tables is modified.</source>
          <target state="translated">DROP VIEW语句删除由&lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;语句创建的视图。视图定义已从数据库架构中删除，但是基础基表中的实际数据均未修改。</target>
        </trans-unit>
        <trans-unit id="81bf67a5e4628332f9b58ee8c6d173a4c4f911e2" translate="yes" xml:space="preserve">
          <source>The Dbbe abstraction and the GDBM and memory drivers were removed.</source>
          <target state="translated">删除了Dbbe抽象和GDBM及内存驱动。</target>
        </trans-unit>
        <trans-unit id="b8ac6ee150153e29d6eb02ac712357b33cd11445" translate="yes" xml:space="preserve">
          <source>The Default Page Size Change of SQLite 3.12.0</source>
          <target state="translated">SQLite 3.12.0的默认页面大小变化</target>
        </trans-unit>
        <trans-unit id="9fa7fe014de7884ad65be67fee11ca70cb61f51e" translate="yes" xml:space="preserve">
          <source>The EXCEPT operator for compound queries is implemented by creating a transient index in a temporary file, storing the results of the left subquery in this transient index, then removing the result from right subquery from the transient index, and finally walking the index from beginning to end to obtain the final output.</source>
          <target state="translated">复合查询的EXCEPT运算符是通过在临时文件中创建一个瞬时索引,将左子查询的结果存储在这个瞬时索引中,然后将右子查询的结果从瞬时索引中删除,最后将索引从头到尾走一遍,得到最终的输出结果。</target>
        </trans-unit>
        <trans-unit id="5ae9f97f03202a131a787390ace280bc0296d78b" translate="yes" xml:space="preserve">
          <source>The EXISTS operator</source>
          <target state="translated">EXISTS运算符</target>
        </trans-unit>
        <trans-unit id="84773fe1424e26217a7a2df622779c7708ba171b" translate="yes" xml:space="preserve">
          <source>The EXISTS operator always evaluates to one of the integer values 0 and 1. If executing the SELECT statement specified as the right-hand operand of the EXISTS operator would return one or more rows, then the EXISTS operator evaluates to 1. If executing the SELECT would return no rows at all, then the EXISTS operator evaluates to 0.</source>
          <target state="translated">如果执行作为EXISTS操作符右侧操作数的SELECT语句会返回一条或多条记录,那么EXISTS操作符的值为1;如果执行SELECT不会返回任何记录,那么EXISTS操作符的值为0。</target>
        </trans-unit>
        <trans-unit id="93ef1c61206801602304d02bd0314e2e805ed955" translate="yes" xml:space="preserve">
          <source>The EXPLAIN QUERY PLAN command is described in &lt;a href=&quot;eqp&quot;&gt;more detail here&lt;/a&gt;.</source>
          <target state="translated">EXPLAIN QUERY PLAN命令在&lt;a href=&quot;eqp&quot;&gt;此处&lt;/a&gt;进行了详细描述。</target>
        </trans-unit>
        <trans-unit id="c62b11f7e5c5d50c87cb37698a2dd96b4ced3ac8" translate="yes" xml:space="preserve">
          <source>The EXPLAIN and EXPLAIN QUERY PLAN prefixes affect the behavior of running a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; using &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. The process of generating a new prepared statement using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or similar is (mostly) unaffected by EXPLAIN. (The exception to the previous sentence is that some special opcodes used by EXPLAIN QUERY PLAN are omitted when building an EXPLAIN QUERY PLAN prepared statement, as a performance optimization.)</source>
          <target state="translated">EXPLAIN和EXPLAIN QUERY PLAN前缀会影响使用&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;运行&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;的行为。使用&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;或类似方法生成新的预处理语句的过程（大部分）不受EXPLAIN的影响。（前一句话的例外是，在构建EXPLAIN QUERY PLAN预准备语句时，EXPLAIN QUERY PLAN使用的某些特殊操作码会被忽略，以进行性能优化。）</target>
        </trans-unit>
        <trans-unit id="c3ee00b5769ef7f7d7fa11249f75b6c728fff5d2" translate="yes" xml:space="preserve">
          <source>The Error And Warning Log</source>
          <target state="translated">错误和警告日志</target>
        </trans-unit>
        <trans-unit id="d0e00804aea114acdf8c7482e29e4b6fc1dd022a" translate="yes" xml:space="preserve">
          <source>The FAIL behavior only works for uniqueness, NOT NULL, and CHECK constraints. A &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; violation causes an ABORT.</source>
          <target state="translated">FAIL行为仅适用于唯一性，NOT NULL和CHECK约束。一个&lt;a href=&quot;foreignkeys&quot;&gt;外键约束&lt;/a&gt;冲突导致的退出。</target>
        </trans-unit>
        <trans-unit id="adadb0f9269151516b0ccaba4b14756b3c80bd9b" translate="yes" xml:space="preserve">
          <source>The FOR EACH STATEMENT clause on a trigger now causes a syntax error. It used to be silently ignored.</source>
          <target state="translated">触发器上的FOR EACH STATEMENT子句现在会导致语法错误。过去它被默默地忽略了。</target>
        </trans-unit>
        <trans-unit id="9cd48fd724eca1ec736eda16ef97971212fd20e2" translate="yes" xml:space="preserve">
          <source>The FTS modules may be compiled to use one of two slightly different versions of the full-text query syntax, the &quot;standard&quot; query syntax and the &quot;enhanced&quot; query syntax. The basic term, term-prefix, phrase and NEAR queries described above are the same in both versions of the syntax. The way in which set operations are specified is slightly different. The following two sub-sections describe the part of the two query syntaxes that pertains to set operations. Refer to the description of how to &lt;a href=&quot;fts3#compiling_and_enabling_fts3_and_fts4&quot;&gt;compile fts&lt;/a&gt; for compilation notes.</source>
          <target state="translated">FTS模块可以编译为使用全文查询语法（&amp;ldquo;标准&amp;rdquo;查询语法和&amp;ldquo;增强&amp;rdquo;查询语法）的两个稍有不同的版本之一。上面描述的基本术语，术语前缀，短语和NEAR查询在两种语法版本中都相同。指定设置操作的方式略有不同。以下两个小节描述了两种查询语法中与集合操作有关的部分。有关&lt;a href=&quot;fts3#compiling_and_enabling_fts3_and_fts4&quot;&gt;编译&lt;/a&gt;说明，请参阅有关如何编译fts的描述。</target>
        </trans-unit>
        <trans-unit id="b82e31fa29aba07c9204f92b3f977e0bafebbf9f" translate="yes" xml:space="preserve">
          <source>The FTS query syntax (right hand side of the MATCH operator) has changed in some ways. The FTS5 syntax is quite close to the FTS4 &quot;enhanced syntax&quot;. The main difference is that FTS5 is fussier about unrecognized punctuation characters and similar within query strings. Most queries that work with FTS3/4 should also work with FTS5, and those that do not should return parse errors.</source>
          <target state="translated">FTS查询语法(MATCH操作符的右侧)在某些方面发生了变化。FTS5的语法与FTS4的 &quot;增强语法 &quot;非常接近。主要的区别是FTS5对查询字符串中的未识别的标点符号和类似的字符更加挑剔。大多数与FTS3/4一起工作的查询也应该与FTS5一起工作,而那些不能工作的查询应该返回解析错误。</target>
        </trans-unit>
        <trans-unit id="452e2c3759f6eb486841492aa116e202a1ab1f44" translate="yes" xml:space="preserve">
          <source>The FTS table column number to extract the returned fragments of text from. Columns are numbered from left to right starting with zero. A negative value indicates that the text may be extracted from any column.</source>
          <target state="translated">FTS表的列号,用于提取返回的文本片段。列号从左到右从0开始。负值表示可以从任何一列提取文本。</target>
        </trans-unit>
        <trans-unit id="e03bf1e933cfbb832357f37ab56f4975c4a387f7" translate="yes" xml:space="preserve">
          <source>The FTS3 and FTS4 extension modules allows users to create special tables with a built-in full-text index (hereafter &quot;FTS tables&quot;). The full-text index allows the user to efficiently query the database for all rows that contain one or more words (hereafter &quot;tokens&quot;), even if the table contains many large documents.</source>
          <target state="translated">FTS3和FTS4扩展模块允许用户创建具有内置全文索引的特殊表(以下简称 &quot;FTS表&quot;)。全文索引允许用户高效地查询数据库中所有包含一个或多个单词(以下简称 &quot;令牌&quot;)的行,即使表中包含许多大型文档。</target>
        </trans-unit>
        <trans-unit id="7d4bac9786b108503576084f19784d9481dfe5de" translate="yes" xml:space="preserve">
          <source>The FTS3 and FTS4 modules provide three special SQL scalar functions that may be useful to the developers of full-text query systems: &quot;snippet&quot;, &quot;offsets&quot; and &quot;matchinfo&quot;. The purpose of the &quot;snippet&quot; and &quot;offsets&quot; functions is to allow the user to identify the location of queried terms in the returned documents. The &quot;matchinfo&quot; function provides the user with metrics that may be useful for filtering or sorting query results according to relevance.</source>
          <target state="translated">FTS3和FTS4模块提供了三个特殊的SQL标量函数,可能对全文查询系统的开发者有用。&quot;snippet&quot;,&quot;offsets &quot;和 &quot;matchinfo&quot;。&quot;snippet &quot;和 &quot;offsets &quot;函数的目的是允许用户识别查询术语在返回文档中的位置。&quot;matchinfo &quot;功能为用户提供了可能有助于根据相关性过滤或排序查询结果的指标。</target>
        </trans-unit>
        <trans-unit id="cd165aec23f192a3f9f07347a0254f2d27b32b66" translate="yes" xml:space="preserve">
          <source>The FTS3 extension has undergone a major rework and cleanup. New &lt;a href=&quot;fts3&quot;&gt;FTS3 documentation&lt;/a&gt; is now available.</source>
          <target state="translated">FTS3扩展程序已进行了重大的返工和清理。新的&lt;a href=&quot;fts3&quot;&gt;FTS3文档&lt;/a&gt;现在可用。</target>
        </trans-unit>
        <trans-unit id="9cae97c9c8daf8017ea793bf4be64df945be883c" translate="yes" xml:space="preserve">
          <source>The FTS3/4 &quot;automerge=X&quot; command has been replaced by the &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 automerge option&lt;/a&gt;.</source>
          <target state="translated">FTS3 / 4&amp;ldquo; automerge = X&amp;rdquo;命令已由&lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 automerge选项&lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="e8ba1806c7cd7bdfbbc2b404c832b1beab23a209" translate="yes" xml:space="preserve">
          <source>The FTS3/4 &quot;merge=X,Y&quot; command has been replaced by the &lt;a href=&quot;fts5#the_merge_command&quot;&gt;FTS5 merge command&lt;/a&gt;.</source>
          <target state="translated">FTS3 / 4&amp;ldquo; merge = X，Y&amp;rdquo;命令已由&lt;a href=&quot;fts5#the_merge_command&quot;&gt;FTS5合并命令&lt;/a&gt;替换。</target>
        </trans-unit>
        <trans-unit id="b2c4e64578a5475fd4fbd32b9347a70fbc56baad" translate="yes" xml:space="preserve">
          <source>The FTS4 prefix option causes FTS to index term prefixes of specified lengths in the same way that it always indexes complete terms. The prefix option must be set to a comma separated list of positive non-zero integers. For each value N in the list, prefixes of length N bytes (when encoded using UTF-8) are indexed. FTS4 uses term prefix indexes to speed up &lt;a href=&quot;fts3#termprefix&quot;&gt;prefix queries&lt;/a&gt;. The cost, of course, is that indexing term prefixes as well as complete terms increases the database size and slows down write operations on the FTS4 table.</source>
          <target state="translated">FTS4前缀选项使FTS以始终索引完整术语的相同方式来索引指定长度的术语前缀。必须将prefix选项设置为逗号分隔的正非零整数列表。对于列表中的每个值N，索引长度为N个字节的前缀（使用UTF-8编码时）。FTS4使用术语前缀索引来加速&lt;a href=&quot;fts3#termprefix&quot;&gt;前缀查询&lt;/a&gt;。当然，代价是索引术语前缀和完整术语会增加数据库大小，并减慢FTS4表上的写操作。</target>
        </trans-unit>
        <trans-unit id="f3623dd8b5a2a6147fa4bef6afa8dea8c88c6337" translate="yes" xml:space="preserve">
          <source>The F_FULLSYNC ioctl (currently only supported on Mac OS X) is disabled if the synchronous pragma is set to something other than &quot;full&quot;.</source>
          <target state="translated">F_FULLSYNC ioctl (目前只在Mac OS X上支持),如果同步pragma被设置为 &quot;full &quot;以外的其他值,则会被禁用。</target>
        </trans-unit>
        <trans-unit id="4a8e5028bc3ed89b6a1dc3d8dc7eba9bd090d027" translate="yes" xml:space="preserve">
          <source>The Fossil NGQP Upgrade Case Study</source>
          <target state="translated">Fossil NGQP升级案例研究</target>
        </trans-unit>
        <trans-unit id="6dc92de118e5e87426474c7d89d8139659caa059" translate="yes" xml:space="preserve">
          <source>The Fossil performance problem described in the previous section of this document arose because there were over ten-thousand entries in the TAGXREF table with the same value for the left-most column (the TAGID column) of the TAGXREF_I1 index.</source>
          <target state="translated">本文档上一节所述的Fossil性能问题的产生,是因为在TAGXREF表中,TAGXREF_I1索引的最左边一列(TAGID列)有超过一万个条目的数值相同。</target>
        </trans-unit>
        <trans-unit id="d2cc3db361bc3155e6c06330a65fa4635f5425d3" translate="yes" xml:space="preserve">
          <source>The Fossil view clearly shows that the branch was eventually merged back into trunk. It shows where the branch started, and it shows two occasions where changes on trunk were merged into the branch. GitHub shows none of this. In fact, the GitHub display is mostly useless in trying to figure out what happened.</source>
          <target state="translated">Fossil视图清楚地显示出该分支最终被合并回主干。它显示了该分支的起始位置,并显示了两次在 trunk 上的变更被合并到该分支的情况。而 GitHub 却没有显示这些。事实上,GitHub的显示在试图弄清楚发生了什么的时候大多是无用的。</target>
        </trans-unit>
        <trans-unit id="6b63744d939cc984f1b96440853e8df6692826ba" translate="yes" xml:space="preserve">
          <source>The Fts5PhraseIter structure is defined above. Applications should not modify this structure directly - it should only be used as shown above with the xPhraseFirst() and xPhraseNext() API methods (and by xPhraseFirstColumn() and xPhraseNextColumn() as illustrated below).</source>
          <target state="translated">上面定义了Fts5PhraseIter结构。应用程序不应该直接修改这个结构--它只应该如上图所示,与xPhraseFirst()和xPhraseNext()API方法一起使用(以及通过xPhraseFirstColumn()和xPhraseNextColumn()使用,如下图所示)。</target>
        </trans-unit>
        <trans-unit id="f67ba8b5c06d16c5494f43aac5e79c51a0f21c56" translate="yes" xml:space="preserve">
          <source>The GLOB operator is always case sensitive. The column on the left side of the GLOB operator must always use the built-in BINARY collating sequence or no attempt will be made to optimize that operator with indexes.</source>
          <target state="translated">GLOB操作符总是区分大小写。GLOB操作符左侧的列必须始终使用内置的BINARY整理序列,否则不会尝试用索引优化该操作符。</target>
        </trans-unit>
        <trans-unit id="a5efd19f10743bd231ab41e35fd5ac44fc6fbe77" translate="yes" xml:space="preserve">
          <source>The GLOB operator is always case sensitive. The column on the left side of the GLOB operator must always use the built-in BINARY collating sequence or no attempt will be made to optimize that operator with indices.</source>
          <target state="translated">GLOB操作符总是区分大小写。GLOB运算符左侧的列必须始终使用内置的BINARY整理序列,否则不会尝试用索引优化该运算符。</target>
        </trans-unit>
        <trans-unit id="ebb21a9ebdf2dcd06a6d1e05cc13a1948a1a0378" translate="yes" xml:space="preserve">
          <source>The GLOB operator is similar to LIKE but uses the Unix file globbing syntax for its wildcards. Also, GLOB is case sensitive, unlike LIKE. Both GLOB and LIKE may be preceded by the NOT keyword to invert the sense of the test. The infix GLOB operator is implemented by calling the function &lt;a href=&quot;lang_corefunc#glob&quot;&gt;glob(&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;X&lt;/i&gt;)&lt;/a&gt; and can be modified by overriding that function.</source>
          <target state="translated">GLOB运算符类似于LIKE，但是使用Unix文件通配符语法作为通配符。此外，与LIKE不同，GLOB区分大小写。 GLOB和LIKE都可以在NOT关键字之前，以反转测试的意义。通过调用函数&lt;a href=&quot;lang_corefunc#glob&quot;&gt;glob（&lt;i&gt;Y&lt;/i&gt;，&lt;i&gt;X&lt;/i&gt;）&lt;/a&gt;实现infix GLOB运算符，并且可以通过重写该函数来对其进行修改。</target>
        </trans-unit>
        <trans-unit id="6bf488312da9736e109b0de15500f2677c1ccca1" translate="yes" xml:space="preserve">
          <source>The Geopoly Interface To The SQLite R*Tree Module</source>
          <target state="translated">SQLite R*Tree模块的Geopoly接口。</target>
        </trans-unit>
        <trans-unit id="768b26bb16f751e006af08115829d3719bded2a3" translate="yes" xml:space="preserve">
          <source>The Geopoly module is an alternative interface to the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; that uses the &lt;a href=&quot;http://geojson.org&quot;&gt;GeoJSON&lt;/a&gt; notation (&lt;a href=&quot;https://tools.ietf.org/html/rfc7946&quot;&gt;RFC-7946&lt;/a&gt;) to describe two-dimensional polygons. Geopoly includes functions for detecting when one polygon is contained within or overlaps with another, for computing the area enclosed by a polygon, for doing linear transformations of polygons, for rendering polygons as &lt;a href=&quot;https://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;SVG&lt;/a&gt;, and other similar operations.</source>
          <target state="translated">Geopoly模块是&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展&lt;/a&gt;的替代接口，该扩展使用&lt;a href=&quot;http://geojson.org&quot;&gt;GeoJSON&lt;/a&gt;表示法（&lt;a href=&quot;https://tools.ietf.org/html/rfc7946&quot;&gt;RFC-7946&lt;/a&gt;）描述二维多边形。 Geopoly包括以下功能：检测一个多边形何时包含在另一个多边形中或与另一个多边形重叠，计算多边形所包围的面积，对多边形进行线性变换，将多边形渲染为&lt;a href=&quot;https://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;SVG&lt;/a&gt;以及其他类似操作。</target>
        </trans-unit>
        <trans-unit id="a237ed77d23b0a3e93b7e807216496727ce2d486" translate="yes" xml:space="preserve">
          <source>The Geopoly module only understands a small subset of GeoJSON, but a critical subset. In particular, GeoJSON understands the JSON array of vertexes that describes a simple polygon.</source>
          <target state="translated">Geopoly模块只理解GeoJSON的一小部分子集,但却是一个关键的子集。特别是,GeoJSON能理解描述简单多边形的顶点JSON数组。</target>
        </trans-unit>
        <trans-unit id="be3160b95c10c837d23b555d2d76ced7f5c9c397" translate="yes" xml:space="preserve">
          <source>The ICU tokenizer implementation is very simple. It splits the input text according to the ICU rules for finding word boundaries and discards any tokens that consist entirely of white-space. This may be suitable for some applications in some locales, but not all. If more complex processing is required, for example to implement stemming or discard punctuation, this can be done by creating a tokenizer implementation that uses the ICU tokenizer as part of its implementation.</source>
          <target state="translated">ICU tokenizer 的实现非常简单。它根据ICU规则分割输入文本,寻找字的边界,并丢弃任何完全由空白组成的标记。这可能适用于某些地区的某些应用,但不是所有的应用。如果需要进行更复杂的处理,例如实现词干或丢弃标点符号,可以通过创建一个使用 ICU tokenizer 的 tokenizer 实现来实现。</target>
        </trans-unit>
        <trans-unit id="a6ddce9bb57f20218d7a75f29be10f1ad340213b" translate="yes" xml:space="preserve">
          <source>The ICU tokenizer is not available.</source>
          <target state="translated">ICU tokenizer是不可用的。</target>
        </trans-unit>
        <trans-unit id="975a07114fdeda8b12153b2d0d474cd1f76f40a8" translate="yes" xml:space="preserve">
          <source>The IN and NOT IN operators</source>
          <target state="translated">IN和NOT IN运算符</target>
        </trans-unit>
        <trans-unit id="ae86038950b2d471648c3c6d1b5cdb4844f71708" translate="yes" xml:space="preserve">
          <source>The IN and NOT IN operators take an expression on the left and a list of values or a subquery on the right. When the right operand of an IN or NOT IN operator is a subquery, the subquery must have the same number of columns as there are columns in the &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; of the left operand. The subquery on the right of an IN or NOT IN operator must be a scalar subquery if the left expression is not a &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; expression. If the right operand of an IN or NOT IN operator is a list of values, each of those values must be scalars and the left expression must also be a scalar. The right-hand side of an IN or NOT IN operator can be a table</source>
          <target state="translated">IN和NOT IN运算符的左边是表达式，右边是值列表或子查询。当IN或NOT IN运算符的右操作数是子查询时，该子查询的列数必须与左操作数的&lt;a href=&quot;rowvalue&quot;&gt;行值&lt;/a&gt;中的列数相同。如果左表达式不是&lt;a href=&quot;rowvalue&quot;&gt;行值&lt;/a&gt;表达式，则IN或NOT IN运算符右侧的子查询必须是标量子查询。如果IN或NOT IN运算符的右操作数是值列表，则这些值中的每一个都必须是标量，而左表达式也必须是标量。IN或NOT IN运算符的右侧可以是表格</target>
        </trans-unit>
        <trans-unit id="a79accc7fc2bc30ac0fead525b227ad7d9b1df52" translate="yes" xml:space="preserve">
          <source>The IN operator is now a candidate for optimization even if the left-hand side is not the left-most term of the index. Multiple IN operators can be used with the same index.</source>
          <target state="translated">IN运算符现在是优化的候选者,即使左手边不是索引的最左项。同一索引可以使用多个IN运算符。</target>
        </trans-unit>
        <trans-unit id="84955ffcf9bdb1365dbcf57de003852e491d0f74" translate="yes" xml:space="preserve">
          <source>The IN-early-out optimization: When doing a look-up on a multi-column index and an IN operator is used on a column other than the left-most column, then if no rows match against the first IN value, check to make sure there exist rows that match the columns to the right before continuing with the next IN value.</source>
          <target state="translated">IN-早出的优化方法。当对多列索引进行查询时,如果在最左列以外的一列上使用了IN操作符,那么如果没有行与第一个IN值相匹配,则在继续下一个IN值之前,检查是否有行与右边的列相匹配。</target>
        </trans-unit>
        <trans-unit id="c69ea675978574ca724f9055d892093e6e8c8e6f" translate="yes" xml:space="preserve">
          <source>The INDEXED BY Clause</source>
          <target state="translated">INDEXED BY条款</target>
        </trans-unit>
        <trans-unit id="c7f2969be40943bb47a40ea44d17f6c5eac58206" translate="yes" xml:space="preserve">
          <source>The INDEXED BY and NOT INDEXED clauses are not allowed on DELETE statements within triggers.</source>
          <target state="translated">在触发器内的DELETE语句中不允许使用INDEXED BY和NOT INDEXED子句。</target>
        </trans-unit>
        <trans-unit id="f74b8a2cb9b68ac44cbe1110518350bde980f1d2" translate="yes" xml:space="preserve">
          <source>The INDEXED BY and NOT INDEXED clauses are not allowed on UPDATE statements within triggers.</source>
          <target state="translated">在触发器内的UPDATE语句中不允许使用INDEXED BY和NOT INDEXED子句。</target>
        </trans-unit>
        <trans-unit id="b6f68ce27c8cff5cc2a071306e82e684ac57bb2a" translate="yes" xml:space="preserve">
          <source>The INDEXED BY and NOT INDEXED clauses are not supported for &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements.</source>
          <target state="translated">&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;和&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;语句不支持INDEXED BY和NOT INDEXED子句。</target>
        </trans-unit>
        <trans-unit id="c219f61fe4cd1e708d4fe79c89efa6776605815d" translate="yes" xml:space="preserve">
          <source>The INDEXED BY clause is &lt;em&gt;not&lt;/em&gt; intended for use in tuning the performance of a query. The intent of the INDEXED BY clause is to raise a run-time error if a schema change, such as dropping or creating an index, causes the query plan for a time-sensitive query to change. The INDEXED BY clause is designed to help detect undesirable query plan changes during regression testing. Application developers are admonished to omit all use of INDEXED BY during application design, implementation, testing, and tuning. If INDEXED BY is to be used at all, it should be inserted at the very end of the development process when &quot;locking down&quot; a design.</source>
          <target state="translated">INDEXED BY子句&lt;em&gt;不适&lt;/em&gt;用于调整查询的性能。如果模式更改（例如删除或创建索引）导致时间敏感查询的查询计划发生更改，则INDEXED BY子句的目的是引发运行时错误。 INDEXED BY子句旨在帮助检测回归测试期间不希望的查询计划更改。建议应用程序开发人员在应用程序设计，实现，测试和调优期间忽略对INDEXED BY的所有使用。如果要使用INDEXED BY，则应在&amp;ldquo;锁定&amp;rdquo;设计时在开发过程的最后插入它。</target>
        </trans-unit>
        <trans-unit id="2f4cc404750644d945353fc113cb9dba262e1c3b" translate="yes" xml:space="preserve">
          <source>The INDEXED BY phrase forces the &lt;a href=&quot;optoverview&quot;&gt;SQLite query planner&lt;/a&gt; to use a particular named index on a &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;, or &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement. The INDEXED BY phrase is an SQLite extension and is not portable to other SQL database engines.</source>
          <target state="translated">INDEXED BY短语会强制&lt;a href=&quot;optoverview&quot;&gt;SQLite查询计划程序&lt;/a&gt;在&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;，&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;或&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;语句上使用特定的命名索引。INDEXED BY短语是SQLite扩展，不能移植到其他SQL数据库引擎中。</target>
        </trans-unit>
        <trans-unit id="272773ebe8d5f9cc82e317b171f77d7379a1e581" translate="yes" xml:space="preserve">
          <source>The INSERT change remains in the changegroup. The values in the INSERT change are modified as if the row was inserted by the existing change and then updated according to the new change.</source>
          <target state="translated">INSERT变更仍保留在变更组中。INSERT更改中的值被修改,就像该行是由现有的更改插入的,然后根据新的更改进行更新。</target>
        </trans-unit>
        <trans-unit id="110ff0538d0b835d343c6aa7fc9be56d02650901" translate="yes" xml:space="preserve">
          <source>The INSERT statement above adds a new row to the sqlite_master table that defines a table &quot;t2&quot; having the same on-disk format as index &quot;t1bc&quot; and pointing to the same b-tree. After adding this sqlite_master table entry, it is necessary to close and reopen the database in order to get SQLite to reread the schema. Then the &quot;t2&quot; table can be queried to see the content of the &quot;t1bc&quot; index.</source>
          <target state="translated">上面的INSERT语句在sqlite_master表中添加了一条新的记录,定义了一个表 &quot;t2&quot;,该表的盘上格式与索引 &quot;t1bc &quot;相同,并且指向同一个b树。在添加了这个sqlite_master表项后,需要关闭并重新打开数据库,以便让SQLite重新读取模式。然后就可以查询 &quot;t2 &quot;表,查看 &quot;t1bc &quot;索引的内容。</target>
        </trans-unit>
        <trans-unit id="cfe3ae8d2c81f2e60d52f407b340e91b2e1ca71c" translate="yes" xml:space="preserve">
          <source>The INSERT statement above adds a new row to the sqlite_schema table that defines a table &quot;t2&quot; having the same on-disk format as index &quot;t1bc&quot; and pointing to the same b-tree. After adding this sqlite_schema table entry, it is necessary to close and reopen the database in order to get SQLite to reread the schema. Then the &quot;t2&quot; table can be queried to see the content of the &quot;t1bc&quot; index.</source>
          <target state="translated">上面的INSERT语句在sqlite_schema表中增加了一条新的记录,定义了一个表 &quot;t2&quot;,其盘上格式与索引 &quot;t1bc &quot;相同,并且指向同一个b树。添加这个sqlite_schema表项后,需要关闭并重新打开数据库,以便让SQLite重新读取模式。然后就可以查询 &quot;t2 &quot;表,查看 &quot;t1bc &quot;索引的内容。</target>
        </trans-unit>
        <trans-unit id="08d21ad99ed5f4abc02a63a43ee6d040107fe785" translate="yes" xml:space="preserve">
          <source>The INSERT statement comes in three basic forms.</source>
          <target state="translated">INSERT语句有三种基本形式。</target>
        </trans-unit>
        <trans-unit id="47c4a334a3fe174333881ca555ae014ebc13040d" translate="yes" xml:space="preserve">
          <source>The INTERSECT operator for compound queries is implemented by creating two separate transient indices, each in a separate temporary file. The left and right subqueries are evaluated each into a separate transient index. Then the two indices are walked together and entries that appear in both indices are output.</source>
          <target state="translated">复合查询的INTERSECT操作符是通过创建两个单独的瞬时索引来实现的,每个索引都在一个单独的临时文件中。左子查询和右子查询分别被评估到一个单独的瞬时索引中。然后将两个索引一起走,输出出现在两个索引中的条目。</target>
        </trans-unit>
        <trans-unit id="24b1f06632bef12995013965847655934cbf7975" translate="yes" xml:space="preserve">
          <source>The Idx1 index is scanned from top to bottom (or from bottom to top if &quot;ORDER BY fruit DESC&quot; is used) in order to find the rowids for each item in order by fruit. Then for each rowid, a binary search is done to lookup and output that row. In this way, the output appears in the requested order without the need to gather the entire output and sort it using a separate step.</source>
          <target state="translated">Idx1索引从上到下扫描(如果使用 &quot;ORDER BY fruit DESC&quot;,则从下到上扫描),以便按照水果的顺序找到每个项目的rowid。然后对每个rowid进行二进制搜索,查找并输出该行。这样,输出的结果就会按照要求的顺序出现,而不需要收集整个输出结果并使用单独的步骤进行排序。</target>
        </trans-unit>
        <trans-unit id="2840ff0c49d75f050e9ec79f4cca0962bc4cd995" translate="yes" xml:space="preserve">
          <source>The JSON1 Extension</source>
          <target state="translated">JSON1扩展部分</target>
        </trans-unit>
        <trans-unit id="9880ae6264f9c31927d61592bb6cec20147ead44" translate="yes" xml:space="preserve">
          <source>The LIKE operator can be made case sensitive using the &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like pragma&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like pragma&lt;/a&gt;使LIKE运算符区分大小写。</target>
        </trans-unit>
        <trans-unit id="d553aca858e8d5460148027e2f586810cb9b2c44" translate="yes" xml:space="preserve">
          <source>The LIKE operator does a pattern matching comparison. The operand to the right of the LIKE operator contains the pattern and the left hand operand contains the string to match against the pattern. A percent symbol (&quot;%&quot;) in the LIKE pattern matches any sequence of zero or more characters in the string. An underscore (&quot;_&quot;) in the LIKE pattern matches any single character in the string. Any other character matches itself or its lower/upper case equivalent (i.e. case-insensitive matching). &lt;u&gt;Important Note:&lt;/u&gt; SQLite only understands upper/lower case for ASCII characters by default. The LIKE operator is case sensitive by default for unicode characters that are beyond the ASCII range. For example, the expression &lt;b&gt;'a' LIKE 'A'&lt;/b&gt; is TRUE but &lt;b&gt;'&amp;aelig;' LIKE '&amp;AElig;'&lt;/b&gt; is FALSE. The ICU extension to SQLite includes an enhanced version of the LIKE operator that does case folding across all unicode characters.</source>
          <target state="translated">LIKE运算符进行模式匹配比较。 LIKE运算符右侧的操作数包含模式，而左侧操作数包含要与模式匹配的字符串。 LIKE模式中的百分比符号（&amp;ldquo;％&amp;rdquo;）与字符串中任何零个或多个字符的序列匹配。 LIKE模式中的下划线（&amp;ldquo; _&amp;rdquo;）与字符串中的任何单个字符匹配。任何其他字符都将匹配其自身或其等效的小写/大写字母（即，不区分大小写的匹配）。&lt;u&gt;重要说明：&lt;/u&gt;默认情况下，SQLite仅理解ASCII字符的大写/小写。默认情况下，对于超出ASCII范围的Unicode字符，LIKE运算符区分大小写。例如，表达式&lt;b&gt;'a'LIKE'A'&lt;/b&gt;为TRUE，但&lt;b&gt;'&amp;aelig;'LIKE'&amp;AElig;'&lt;/b&gt;是FALSE。对SQLite的ICU扩展包括LIKE运算符的增强版本，它对所有unicode字符进行大小写折叠。</target>
        </trans-unit>
        <trans-unit id="1dc39afda5c7dfd4c06c9ca219ccdec668d80d92" translate="yes" xml:space="preserve">
          <source>The LIKE operator has two modes that can be set by a &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;pragma&lt;/a&gt;. The default mode is for LIKE comparisons to be insensitive to differences of case for latin1 characters. Thus, by default, the following expression is true:</source>
          <target state="translated">LIKE运算符有两种可以通过&lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;编译指示&lt;/a&gt;设置的模式。LIKE比较的默认模式对latin1字符的大小写差异不敏感。因此，默认情况下，以下表达式为true：</target>
        </trans-unit>
        <trans-unit id="1212c823074bac84702844422e3c272b2bd97163" translate="yes" xml:space="preserve">
          <source>The LIKE operator is case insensitive by default because this is what the SQL standard requires. You can change the default behavior at compile time by using the &lt;a href=&quot;compile#case_sensitive_like&quot;&gt;SQLITE_CASE_SENSITIVE_LIKE&lt;/a&gt; command-line option to the compiler.</source>
          <target state="translated">默认情况下，LIKE运算符不区分大小写，因为这是SQL标准所要求的。您可以使用编译器的&lt;a href=&quot;compile#case_sensitive_like&quot;&gt;SQLITE_CASE_SENSITIVE_LIKE&lt;/a&gt;命令行选项在编译时更改默认行为。</target>
        </trans-unit>
        <trans-unit id="974b1e3eeffaa9ed2ed23dfb8ae4c0123aeb3aed" translate="yes" xml:space="preserve">
          <source>The LIKE optimization might occur if the column named on the left of the operator is indexed using the built-in BINARY collating sequence and case_sensitive_like is turned on. Or the optimization might occur if the column is indexed using the built-in NOCASE collating sequence and the case_sensitive_like mode is off. These are the only two combinations under which LIKE operators will be optimized.</source>
          <target state="translated">如果操作符左边命名的列使用内置的BINARY整理序列进行索引,并且开启了case_sensitive_like模式,则可能会发生LIKE优化。或者,如果使用内置的NOCASE整理序列对列进行索引,并且case_sensitive_like模式被关闭,则可能发生优化。只有这两种组合下,LIKE操作符才会被优化。</target>
        </trans-unit>
        <trans-unit id="93b8dceb670473d258369826a0e1bcdc46904ecc" translate="yes" xml:space="preserve">
          <source>The LIKE optimization was generating incorrect byte-code and hence getting the wrong answer if the left-hand operand has numeric affinity and the right-hand-side pattern is '/%' or if the pattern begins with the ESCAPE character. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/c94369cae9b561b1f996d0054b&quot;&gt;c94369cae9b561b1f996d0054b&lt;/a&gt;</source>
          <target state="translated">LIKE优化生成了错误的字节码，因此如果左侧操作数具有数字亲和力且右侧模式为'/％'或模式以ESCAPE字符开头，则会得到错误的答案。票证&lt;a href=&quot;https://www.sqlite.org/src/info/c94369cae9b561b1f996d0054b&quot;&gt;c94369cae9b561b1f996d0054b的&lt;/a&gt;修复</target>
        </trans-unit>
        <trans-unit id="50c934a9b19a46fe0d3c49a41fee7d1fdd7083c0" translate="yes" xml:space="preserve">
          <source>The LIKE optimization will only be attempted if the right-hand side of the GLOB or LIKE operator is either literal string or a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that has been &lt;a href=&quot;c3ref/bind_blob&quot;&gt;bound&lt;/a&gt; to a string literal. The string literal must not begin with a wildcard; if the right-hand side begins with a wildcard character then this optimization is attempted. If the right-hand side is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that is bound to a string, then this optimization is only attempted if the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; containing the expression was compiled with &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;. The LIKE optimization is not attempted if the right-hand side is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and the statement was prepared using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;.</source>
          <target state="translated">仅当GLOB或LIKE运算符的右侧是文字字符串或已&lt;a href=&quot;c3ref/bind_blob&quot;&gt;绑定&lt;/a&gt;到字符串文字的&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数时&lt;/a&gt;，才尝试LIKE优化。字符串文字不能以通配符开头；如果右侧以通配符开头，则尝试进行此优化。如果右侧是绑定到字符串的&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;，则只有在使用&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;编译包含该表达式的&lt;a href=&quot;c3ref/stmt&quot;&gt;预备语句的&lt;/a&gt;情况下，才尝试进行此优化。如果右侧是&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;并且使用以下语句准备了语句，则不会尝试执行LIKE优化：&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;或&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="75a37b85ec9af203958779031808e1e864da0987" translate="yes" xml:space="preserve">
          <source>The LIKE optimization will only be attempted if the right-hand side of the GLOB or LIKE operator is either literal string or a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that has been &lt;a href=&quot;c3ref/bind_blob&quot;&gt;bound&lt;/a&gt; to a string literal. The string literal must not begin with a wildcard; if the right-hand side begins with a wildcard character then this optimization is not attempted. If the right-hand side is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that is bound to a string, then this optimization is only attempted if the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; containing the expression was compiled with &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;. The LIKE optimization is not attempted if the right-hand side is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and the statement was prepared using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;.</source>
          <target state="translated">仅当GLOB或LIKE运算符的右侧是文字字符串或已&lt;a href=&quot;c3ref/bind_blob&quot;&gt;绑定&lt;/a&gt;到字符串文字的&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数时&lt;/a&gt;，才尝试LIKE优化。字符串文字不能以通配符开头；如果右侧以通配符开头，则不会尝试此优化。如果右侧是绑定到字符串的&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;，则仅当包含该表达式的&lt;a href=&quot;c3ref/stmt&quot;&gt;准备语句&lt;/a&gt;是使用&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;编译时，才尝试进行此优化。如果右侧是&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;并且使用以下语句准备了语句，则不会尝试执行LIKE优化：&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;或&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bfdfb505c18eab193b8701d8963abc89096358bd" translate="yes" xml:space="preserve">
          <source>The LIKE, GLOB, REGEXP, and MATCH operators</source>
          <target state="translated">LIKE、GLOB、REGEXP和MATCH运算符。</target>
        </trans-unit>
        <trans-unit id="bd6f903f94d0893c11340df485d7ab2df47a60ff" translate="yes" xml:space="preserve">
          <source>The LIMIT and ORDER BY clauses (described below) are unsupported for DELETE statements within triggers.</source>
          <target state="translated">LIMIT和ORDER BY子句(如下所述)不支持触发器内的DELETE语句。</target>
        </trans-unit>
        <trans-unit id="ac40736f7c111bc231ce85d71233af9ca860229d" translate="yes" xml:space="preserve">
          <source>The LIMIT and ORDER BY clauses for UPDATE are unsupported within triggers, regardless of the compilation options used to build SQLite.</source>
          <target state="translated">无论用于构建SQLite的编译选项是什么,UPDATE的LIMIT和ORDER BY子句在触发器中都是不支持的。</target>
        </trans-unit>
        <trans-unit id="8e074183b71823eb43ac076c4294086172e78dd9" translate="yes" xml:space="preserve">
          <source>The LIMIT clause</source>
          <target state="translated">限制条款</target>
        </trans-unit>
        <trans-unit id="0504a702a97dc6330d2a4e4c66843d71b8b8976c" translate="yes" xml:space="preserve">
          <source>The LIMIT clause is used to place an upper bound on the number of rows returned by the entire SELECT statement.</source>
          <target state="translated">LIMIT子句用于对整个SELECT语句返回的行数设置一个上限。</target>
        </trans-unit>
        <trans-unit id="077d300ed4cc15ee3f95aa8d7373e80b1b912e57" translate="yes" xml:space="preserve">
          <source>The LIMIT clause now works on subselects</source>
          <target state="translated">LIMIT子句现在适用于子选择。</target>
        </trans-unit>
        <trans-unit id="243d546893ed2d7dba744bb55553e651413994ea" translate="yes" xml:space="preserve">
          <source>The LIMIT clause, if present, determines the maximum number of rows that will ever be added to the recursive table in step 2b. Once the limit is reached, the recursion stops. A limit of zero means that no rows are ever added to the recursive table, and a negative limit means an unlimited number of rows may be added to the recursive table.</source>
          <target state="translated">LIMIT子句,如果存在的话,决定了在步骤2b中递归表中添加的最大行数。一旦达到限制,递归就会停止。限定值为零意味着不会向递归表中添加任何行,负值意味着可以向递归表中添加无限的行数。</target>
        </trans-unit>
        <trans-unit id="9ff51df664023512f948df1ac796d229e7d0e9d2" translate="yes" xml:space="preserve">
          <source>The LOCKING_STYLE extension is now enabled by default on Mac OS X</source>
          <target state="translated">LOCKING_STYLE 扩展名现在在 Mac OS X 上是默认启用的。</target>
        </trans-unit>
        <trans-unit id="0d323fe988c47fdc7cf51035f151e1d7348afa80" translate="yes" xml:space="preserve">
          <source>The Lemon LALR(1) Parser Generator</source>
          <target state="translated">Lemon LALR(1)解析器生成器。</target>
        </trans-unit>
        <trans-unit id="cac145bc2534e8394ef262506cd070ba23b13005" translate="yes" xml:space="preserve">
          <source>The Lemon source code was originally written as separate source files, and only later merged into a single &quot;lemon.c&quot; source file.</source>
          <target state="translated">Lemon源码最初是作为单独的源文件编写的,后来才合并成一个 &quot;lemon.c &quot;源文件。</target>
        </trans-unit>
        <trans-unit id="217ce06ccfd8bf843619afe9ea4c73c55d14a961" translate="yes" xml:space="preserve">
          <source>The M value is the &quot;mantissa&quot; and E is the &quot;exponent&quot;. Both M and E are integers.</source>
          <target state="translated">M值是 &quot;咒语&quot;,E是 &quot;指数&quot;。M和E都是整数。</target>
        </trans-unit>
        <trans-unit id="f3666de7d407bd838db280e08d40dcf3369cd962" translate="yes" xml:space="preserve">
          <source>The MATCH operator is a special syntax for the match() application-defined function. The default match() function implementation raises an exception and is not really useful for anything. But extensions can override the match() function with more helpful logic.</source>
          <target state="translated">MATCH操作符是match()应用定义函数的一种特殊语法。默认的match()函数的实现会引发一个异常,而且对任何事情都没有用。但是扩展可以用更有用的逻辑覆盖match()函数。</target>
        </trans-unit>
        <trans-unit id="42afa4f5f59a4dbd2c306334064e90d9b1a32220" translate="yes" xml:space="preserve">
          <source>The MATCH operator of a custom R*Tree query function must be a top-level AND-connected term of the WHERE clause, or else it will not be usable by the R*Tree query optimizer and the query will not be runnable. If the MATCH operator is connected to other terms of the WHERE clause via an OR operator, for example, the query will fail with an error.</source>
          <target state="translated">自定义R*Tree查询函数的MATCH操作符必须是WHERE子句的顶层AND连接项,否则R*Tree查询优化器将无法使用,查询也无法运行。如果MATCH操作符通过OR操作符连接到WHERE子句的其他项,例如,查询将以错误方式失败。</target>
        </trans-unit>
        <trans-unit id="a59083e3614cc05a48a3bbb667742c5ff714f7ae" translate="yes" xml:space="preserve">
          <source>The MEMORY journaling mode stores the rollback journal in volatile RAM. This saves disk I/O but at the expense of database safety and integrity. If the application using SQLite crashes in the middle of a transaction when the MEMORY journaling mode is set, then the database file will very likely &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;go corrupt&lt;/a&gt;.</source>
          <target state="translated">MEMORY日记记录模式将回滚日记记录存储在易失性RAM中。这样可以节省磁盘I / O，但要以牺牲数据库安全性和完整性为代价。如果在设置MEMORY日记模式时使用SQLite的应用程序在事务中间崩溃，则数据库文件很可能&lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;会损坏&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f83732bb3e32c92cf54961a7828a9a9bf48899eb" translate="yes" xml:space="preserve">
          <source>The MySQL UPDATE statement does not have just one target table like other systems. Any of the tables that participate in the join can be modified in the SET clause. The MySQL UPDATE syntax allows you to update multiple tables at once!</source>
          <target state="translated">MySQL UPDATE语句不像其他系统那样只有一个目标表。任何一个参与联接的表都可以在SET子句中进行修改。MySQL UPDATE语法允许你一次更新多个表!</target>
        </trans-unit>
        <trans-unit id="02f3e583df88fe87cd750b4e8f9145cc25dd009e" translate="yes" xml:space="preserve">
          <source>The Mythical Man-Month</source>
          <target state="translated">神话中的人月</target>
        </trans-unit>
        <trans-unit id="47382a1ade54ee985c5d1e4d884a10d978c3d9d5" translate="yes" xml:space="preserve">
          <source>The NGQP has no way of knowing that TAGXREF_I1 is almost useless in this query, unless &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has been run on the database. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command gathers statistics on the quality of the various indexes and stores those statistics in &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;SQLITE_STAT1&lt;/a&gt; table. Having access to this statistical information, the NGQP easily chooses algorithm-1 as the best algorithm, by a wide margin.</source>
          <target state="translated">除非已在数据库上运行&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;，否则NGQP无法知道TAGXREF_I1在此查询中几乎没有用。该&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;上的各种指标和存储这些统计数据的质量命令收集统计&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;SQLITE_STAT1&lt;/a&gt;表。NGQP可以访问此统计信息，很容易就选择算法1作为最佳算法。</target>
        </trans-unit>
        <trans-unit id="143a4238d4916cb63313c4577ca26b997b836c83" translate="yes" xml:space="preserve">
          <source>The NGQP is almost always better than the legacy query planner. However, there may exist legacy applications that unknowingly depend on undefined and/or suboptimal behavior in the legacy query planner, and upgrading to the NGQP on those legacy applications could cause performance regressions. This risk is considered and a checklist is provided for reducing the risk and for fixing any issues that do arise.</source>
          <target state="translated">NGQP几乎总是比传统的查询规划器更好。然而,可能存在一些遗留应用程序,它们在不知情的情况下依赖于遗留查询规划器中的未定义和/或次优行为,在这些遗留应用程序上升级到 NGQP 可能会导致性能倒退。我们考虑了这一风险,并提供了一份检查表,以降低风险并解决确实出现的任何问题。</target>
        </trans-unit>
        <trans-unit id="2965ed7439648bc6c724543a8009a196c9039cf3" translate="yes" xml:space="preserve">
          <source>The NGQP uses a new heuristic for seeking the best path through the graph: &quot;N Nearest Neighbors&quot; (hereafter &quot;N3&quot;). With N3, instead of choosing just one nearest neighbor for each step, the algorithm keeps track of the N bests paths at each step for some small integer N.</source>
          <target state="translated">NGQP使用一种新的启发式方法来寻求图中的最佳路径。&quot;N个最近的邻居&quot;(以下简称 &quot;N3&quot;)。有了N3,算法不是每一步只选择一个最近的邻居,而是在每一步跟踪一些小整数N的N条最佳路径。</target>
        </trans-unit>
        <trans-unit id="0cc9ac5c6c19fb4a0c339daee645a66512bd3730" translate="yes" xml:space="preserve">
          <source>The NGQP will always find a good query plan as long as the schema does not contain indexes that have more than about 10 or 20 rows with the same value in the left-most column of the index.</source>
          <target state="translated">只要模式中不包含索引,在索引的最左边一列有超过约10或20行相同值的索引,NGQP总会找到一个好的查询计划。</target>
        </trans-unit>
        <trans-unit id="64782e52a0662885b1e4e8b616fd2a06e03a36a9" translate="yes" xml:space="preserve">
          <source>The NGQP will always find an equal or better query plan, compared to prior query planners, as long as it has access to accurate &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; data in the &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;SQLITE_STAT1&lt;/a&gt; file.</source>
          <target state="translated">只要NGQP可以访问&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;SQLITE_STAT1&lt;/a&gt;文件中的准确&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;数据，与以前的查询计划者相比，它将始终找到一个相等或更好的查询计划。</target>
        </trans-unit>
        <trans-unit id="19150b2c84a3f9ff0a3cf33ed2fd4c984408dbd2" translate="yes" xml:space="preserve">
          <source>The NOCASE collation is like BINARY except that uppercase ASCII characters ('A' through 'Z') are folded into their lowercase equivalents prior to running the comparison. Only ASCII characters are case-folded. NOCASE does not implement a general purpose unicode caseless comparison.</source>
          <target state="translated">NOCASE整理与BINARY一样,除了大写的ASCII字符('A'到'Z')在运行比较之前会被折叠成小写的字符。只有ASCII字符才会进行大小写折叠。NOCASE没有实现通用的无大小写比较。</target>
        </trans-unit>
        <trans-unit id="e84b5eaf17b803151297f975dc355cb961ea61cd" translate="yes" xml:space="preserve">
          <source>The NOT operator (or, if using the standard syntax, a unary &quot;-&quot; operator) may be used to compute the &lt;b&gt;relative complement&lt;/b&gt; of one set of documents with respect to another.</source>
          <target state="translated">NOT运算符（或者，如果使用标准语法，则是一元&amp;ldquo;-&amp;rdquo;运算符）可用于计算一组文档相对于另一组文档的&lt;b&gt;相对补余&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="0622850d3c0896e3d4a2cdc1368b8e7708693108" translate="yes" xml:space="preserve">
          <source>The NOT operator is not supported. Instead of the NOT operator, the standard query syntax supports a unary &quot;-&quot; operator that may be applied to basic term and term-prefix queries (but not to phrase or NEAR queries). A term or term-prefix that has a unary &quot;-&quot; operator attached to it may not appear as an operand to an OR operator. An FTS query may not consist entirely of terms or term-prefix queries with unary &quot;-&quot; operators attached to them.</source>
          <target state="translated">不支持NOT运算符。标准查询语法不支持NOT运算符,而是支持一个单调的&quot;-&quot;运算符,可以应用于基本的术语和术语前缀查询(但不支持短语或近似查询)。术语或术语前缀如果附加了一个单调的&quot;-&quot;运算符,则不能作为OR运算符的操作数出现。一个FTS查询不能完全由附加了单调&quot;-&quot;操作符的术语或术语前缀查询组成。</target>
        </trans-unit>
        <trans-unit id="92f10f8b9e2a034cee1135ad17b2a216a2126edd" translate="yes" xml:space="preserve">
          <source>The NULLS FIRST and NULLS LAST predicates are not supported for indexes. For &lt;a href=&quot;datatype3#sortorder&quot;&gt;sorting purposes&lt;/a&gt;, SQLite considers NULL values to be smaller than all other values. Hence NULL values always appear at the beginning of an ASC index and at the end of a DESC index.</source>
          <target state="translated">索引不支持NULLS FIRST和NULLS LAST谓词。为了进行&lt;a href=&quot;datatype3#sortorder&quot;&gt;排序&lt;/a&gt;，SQLite认为NULL值小于所有其他值。因此，NULL值始终出现在ASC索引的开头和DESC索引的结尾。</target>
        </trans-unit>
        <trans-unit id="7a314ee0d4a8c6c880fc2de97d4d977bd035a9e6" translate="yes" xml:space="preserve">
          <source>The NULLS FIRST and NULLS LAST predicates are not supported for indexes. For &lt;a href=&quot;datatype3#sortorder&quot;&gt;sorting purposes&lt;/a&gt;, SQLite considers NULL values to be smaller than all other values. Hences NULL values always appear at the beginning of an ASC index and at the end of a DESC index.</source>
          <target state="translated">索引不支持NULLS FIRST和NULLS LAST谓词。为了进行&lt;a href=&quot;datatype3#sortorder&quot;&gt;排序&lt;/a&gt;，SQLite认为NULL值小于所有其他值。因此，NULL值始终出现在ASC索引的开头和DESC索引的结尾。</target>
        </trans-unit>
        <trans-unit id="df615076dd2b352c1767b46fb626e9bea1df01d8" translate="yes" xml:space="preserve">
          <source>The Next instruction increments the cursor to point to the next element in the table pointed to by cursor P0, and if it was successful branches to P2 (6, the beginning of the loop body). The Close instruction closes cursor P1. It doesn't affect the temporary storage list because it isn't associated with cursor P1; it is instead a global working list (which can be saved with ListPush).</source>
          <target state="translated">Next指令增量游标指向游标P0指向的表中的下一个元素,如果成功则分支到P2(6,循环体的开始)。关闭指令关闭光标P1。它不影响临时存储列表,因为它不与游标P1相关联,而是一个全局工作列表(可以用ListPush保存)。</target>
        </trans-unit>
        <trans-unit id="ead51814a41f1aee68f72130d432c2d7adca2550" translate="yes" xml:space="preserve">
          <source>The Next-Generation Query Planner</source>
          <target state="translated">下一代查询规划器</target>
        </trans-unit>
        <trans-unit id="72bb3fb56f491dbfd70c567055e36bba4fdf8c24" translate="yes" xml:space="preserve">
          <source>The ODP ZIP archive contains four different XML files: content.xml, styles.xml, meta.xml, and settings.xml. Those four files define the slide layout, text content, and styling. This particular presentation contains 62 images, ranging from full-screen pictures to tiny icons, each stored as a separate file in the Pictures folder. The &quot;mimetype&quot; file contains a single line of text that says:</source>
          <target state="translated">ODP ZIP档案包含四个不同的XML文件:content.xml、style.xml、meta.xml和settings.xml。这四个文件定义了幻灯片布局、文本内容和样式。这个特定的演示文稿包含62张图片,从全屏图片到微小的图标,每张图片都作为一个单独的文件存储在图片文件夹中。&quot;mimetype &quot;文件包含一行文字,上面写着:。</target>
        </trans-unit>
        <trans-unit id="bd2fb71eee9ad290a0e9bebe4f7b07ef57d97050" translate="yes" xml:space="preserve">
          <source>The OFF journaling mode disables the rollback journal completely. No rollback journal is ever created and hence there is never a rollback journal to delete. The OFF journaling mode disables the atomic commit and rollback capabilities of SQLite. The &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command no longer works; it behaves in an undefined way. Applications must avoid using the &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command when the journal mode is OFF. If the application crashes in the middle of a transaction when the OFF journaling mode is set, then the database file will very likely &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;go corrupt&lt;/a&gt;. Without a journal, there is no way for a statement to unwind partially completed operations following a constraint error. This might also leave the database in a corrupted state. For example, if a duplicate entry causes a &lt;a href=&quot;lang_createindex&quot;&gt;CREATE UNIQUE INDEX&lt;/a&gt; statement to fail half-way through, it will leave behind a partially created, and hence corrupt, index. Because OFF journaling mode allows the database file to be corrupted using ordinary SQL, it is disabled when &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; is enabled.</source>
          <target state="translated">OFF日志记录模式完全禁用回滚日志记录。不会创建回滚日志，因此永远不会删除回滚日志。 OFF日志记录模式禁用SQLite的原子提交和回滚功能。该&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;命令不再有效;它的行为方式不确定。当日志模式为OFF时，应用程序必须避免使用&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;命令。如果在设置OFF日记模式的情况下应用程序在事务中间崩溃，则数据库文件很可能&lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;会损坏&lt;/a&gt;。没有日志，语句将无法在约束错误之后展开部分完成的操作。这也可能使数据库处于损坏状态。例如，如果重复条目导致&lt;a href=&quot;lang_createindex&quot;&gt;CREATE UNIQUE INDEX&lt;/a&gt;语句通过失败中途，它会留下部分创建的，因此腐败，索引。由于关闭日志模式允许使用普通的SQL被损坏的数据库文件，当它被禁用&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt;启用。</target>
        </trans-unit>
        <trans-unit id="374ba8e6eebafb57002a1dcdb7b0375a9e1ef0e6" translate="yes" xml:space="preserve">
          <source>The OFFSET clause, if it is present and has a positive value N, prevents the first N rows from being added to the recursive table. The first N rows are still processed by the recursive-select &amp;mdash; they just are not added to the recursive table. Rows are not counted toward fulfilling the LIMIT until all OFFSET rows have been skipped.</source>
          <target state="translated">OFFSET子句（如果存在）并且具有正值N，则防止将前N行添加到递归表中。前N行仍由递归选择处理-只是不将它们添加到递归表中。在跳过所有OFFSET行之前，不将行计为达到LIMIT。</target>
        </trans-unit>
        <trans-unit id="0b277e3e2e965c40320745de00278d14c1b4c238" translate="yes" xml:space="preserve">
          <source>The ON CONFLICT Clause</source>
          <target state="translated">ON CONFLICT条款</target>
        </trans-unit>
        <trans-unit id="549fba753f3ce9487855ba9f0e10547cd8338f25" translate="yes" xml:space="preserve">
          <source>The ON CONFLICT clause applies to &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;, &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt;, &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt;, and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints. The ON CONFLICT algorithm does not apply to &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY constraints&lt;/a&gt;. There are five conflict resolution algorithm choices: ROLLBACK, ABORT, FAIL, IGNORE, and REPLACE. The default conflict resolution algorithm is ABORT. This is what they mean:</source>
          <target state="translated">ON CONFLICT子句适用于&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;，&lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt;，&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt;和&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;约束。ON CONFLICT算法不适用于&lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY约束&lt;/a&gt;。有五个冲突解决算法选择：ROLLBACK，ABORT，FAIL，IGNORE和REPLACE。默认的冲突解决算法是ABORT。这是他们的意思：</target>
        </trans-unit>
        <trans-unit id="1bdda41615452e17b3f0971a7f023b71ba464bbb" translate="yes" xml:space="preserve">
          <source>The ON CONFLICT clause described here has been a part of SQLite since before version 3.0.0 (2004-06-18). The phrase &quot;ON CONFLICT&quot; is also part of &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt;, which is an extension to &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; added in version 3.24.0 (2018-06-04). Do not confuse these two separate uses of the &quot;ON CONFLICT&quot; phrase.</source>
          <target state="translated">自版本3.0.0（2004-06-18）以来，此处描述的ON CONFLICT子句已成为SQLite的一部分。短语&amp;ldquo; ON CONFLICT&amp;rdquo;也是&lt;a href=&quot;lang_upsert&quot;&gt;UPSERT的&lt;/a&gt;一部分，它是对3.24.0版（2018-06-04）中添加的&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;的扩展。不要混淆&amp;ldquo; ON CONFLICT&amp;rdquo;短语的这两种单独使用。</target>
        </trans-unit>
        <trans-unit id="cdcbfd707214ce0a425024950f0078c8093a672f" translate="yes" xml:space="preserve">
          <source>The ON CONFLICT clause is a non-standard extension specific to SQLite that can appear in many other SQL commands. It is given its own section in this document because it is not part of standard SQL and therefore might not be familiar.</source>
          <target state="translated">ON CONFLICT子句是SQLite特有的非标准扩展,可以出现在许多其他SQL命令中。在本文档中,它有自己的章节,因为它不是标准SQL的一部分,因此可能并不熟悉。</target>
        </trans-unit>
        <trans-unit id="0b1442e3d6081cb327542a1dfef2a119f6cc8762" translate="yes" xml:space="preserve">
          <source>The ON DELETE and ON UPDATE action associated with each foreign key in an SQLite database is one of &quot;NO ACTION&quot;, &quot;RESTRICT&quot;, &quot;SET NULL&quot;, &quot;SET DEFAULT&quot; or &quot;CASCADE&quot;. If an action is not explicitly specified, it defaults to &quot;NO ACTION&quot;.</source>
          <target state="translated">在SQLite数据库中,与每个外键相关联的ON DELETE和ON UPDATE操作是 &quot;NO ACTION&quot;、&quot;RESTRICT&quot;、&quot;SET NULL&quot;、&quot;SET DEFAULT &quot;或 &quot;CASCADE &quot;中的一个。如果没有明确指定某个操作,那么它默认为 &quot;NO ACTION&quot;。</target>
        </trans-unit>
        <trans-unit id="b8bcb1e455bfc6b4bbbd346c00653c4dfafc3869" translate="yes" xml:space="preserve">
          <source>The ON and USING clauses of an inner join are converted into additional terms of the WHERE clause prior to WHERE clause analysis described &lt;a href=&quot;#where_clause&quot;&gt;above in paragraph 2.0&lt;/a&gt;. Thus with SQLite, there is no computational advantage to use the newer SQL92 join syntax over the older SQL89 comma-join syntax. They both end up accomplishing exactly the same thing on inner joins.</source>
          <target state="translated">内部连接的ON和USING子句在&lt;a href=&quot;#where_clause&quot;&gt;上文第2.0节中&lt;/a&gt;所述的WHERE子句分析之前被转换为WHERE子句的附加项。因此，与较旧的SQL89逗号联接语法相比，对于SQLite，使用较新的SQL92连接语法没有计算优势。他们最终都在内部联接上完成了完全相同的事情。</target>
        </trans-unit>
        <trans-unit id="6bf1202b648eb0b4a5f050a8c6d05340c107e859" translate="yes" xml:space="preserve">
          <source>The ON and USING clauses of an inner join are converted into additional terms of the WHERE clause prior to WHERE clause analysis described above in paragraph 1.0. Thus with SQLite, there is no computational advantage to use the newer SQL92 join syntax over the older SQL89 comma-join syntax. They both end up accomplishing exactly the same thing on inner joins.</source>
          <target state="translated">内联接的ON和USING子句会在上面第1.0段描述的WHERE子句分析之前被转换为WHERE子句的附加项。因此,对于SQLite来说,使用较新的SQL92连接语法比使用较旧的SQL89逗号连接语法在计算上没有任何优势。它们最终在内部连接上都能完成完全相同的事情。</target>
        </trans-unit>
        <trans-unit id="bb4c3f3b3997cb8490367acdbc7718d009c8a562" translate="yes" xml:space="preserve">
          <source>The OR operator calculates the &lt;b&gt;union&lt;/b&gt; of two sets of documents.</source>
          <target state="translated">OR运算符可计算两组文档的&lt;b&gt;并&lt;/b&gt;集。</target>
        </trans-unit>
        <trans-unit id="4ba92a05446009b56fe03f1afc3e8240d551a35c" translate="yes" xml:space="preserve">
          <source>The ORDER BY LIMIT optimization is not valid unless the inner-most IN operator loop is actually used by the query plan. Fix for ticket &lt;a href=&quot;https://sqlite.org/src/info/0c4df46116e90f92&quot;&gt;0c4df46116e90f92&lt;/a&gt;.</source>
          <target state="translated">除非查询计划实际使用了最里面的IN运算符循环，否则ORDER BY LIMIT优化无效。修复&lt;a href=&quot;https://sqlite.org/src/info/0c4df46116e90f92&quot;&gt;故障&lt;/a&gt;单0c4df46116e90f92。</target>
        </trans-unit>
        <trans-unit id="7b8e2023ca7e681416d915e1d1b8f5b26d152e1f" translate="yes" xml:space="preserve">
          <source>The ORDER BY LIMIT optimization might have caused an infinite loop in the byte code of the prepared statement under very obscure circumstances, due to a confluence of minor defects in the query optimizer. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/9936b2fa443fec03ff25&quot;&gt;9936b2fa443fec03ff25&lt;/a&gt;</source>
          <target state="translated">由于查询优化器中的次要缺陷的汇合，在非常模糊的情况下，ORDER BY LIMIT优化可能会导致预准备语句的字节码中出现无限循环。修复票号&lt;a href=&quot;https://www.sqlite.org/src/info/9936b2fa443fec03ff25&quot;&gt;9936b2fa443fec03ff25&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b25ea5983496f08c601930c1bfec228ee9f65c25" translate="yes" xml:space="preserve">
          <source>The ORDER BY and LIMIT clauses on &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements are not supported. ORDER BY and LIMIT are not normally supported for &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; in any context but can be enabled for top-level statements using the &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; compile-time option. However, that compile-time option only applies to top-level &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements, not &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements within triggers.</source>
          <target state="translated">不支持&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;和&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;语句上的ORDER BY和LIMIT子句。在任何情况下，通常不支持&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;或&lt;a href=&quot;lang_delete&quot;&gt;DELETE的&lt;/a&gt; ORDER BY和LIMIT，但可以使用&lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt;编译时选项为顶级语句启用ORDER BY和LIMIT 。但是，该编译时选项仅适用于顶级&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;和&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;语句，不适用于触发器内的&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;和&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;语句。</target>
        </trans-unit>
        <trans-unit id="3cfee8a3cdd0f5ece05fc4719284d9ca35cb1ece" translate="yes" xml:space="preserve">
          <source>The ORDER BY clause</source>
          <target state="translated">ORDER BY条款</target>
        </trans-unit>
        <trans-unit id="30dc9fe3a4d009f8e23f54fc9886804eb6fd68d9" translate="yes" xml:space="preserve">
          <source>The ORDER BY clause on a DELETE statement is used only to determine which rows fall within the LIMIT. The order in which rows are deleted is arbitrary and is not influenced by the ORDER BY clause.</source>
          <target state="translated">在DELETE语句中的ORDER BY子句仅用于确定哪些记录属于LIMIT范围内。删除行的顺序是任意的,不受ORDER BY子句的影响。</target>
        </trans-unit>
        <trans-unit id="838347206eac0478c704f6fe626059a265388ac1" translate="yes" xml:space="preserve">
          <source>The ORDER BY clause on an UPDATE statement is used only to determine which rows fall within the LIMIT. The order in which rows are modified is arbitrary and is not influenced by the ORDER BY clause.</source>
          <target state="translated">UPDATE语句中的ORDER BY子句仅用于确定哪些记录在LIMIT范围内。修改行的顺序是任意的,不受ORDER BY子句的影响。</target>
        </trans-unit>
        <trans-unit id="db6946cde6c76ae16df632182494e97889b98107" translate="yes" xml:space="preserve">
          <source>The OS Interface - also called the &quot;VFS&quot; - is what makes SQLite portable across operating systems. Whenever any of the other modules in SQLite needs to communicate with the operating system, they invoke methods in the VFS. The VFS then invokes the operating-specific code needed to satisfy the request. Hence, porting SQLite to a new operating system is simply a matter of writing a new OS interface layer or &quot;VFS&quot;.</source>
          <target state="translated">OS接口--也被称为 &quot;VFS&quot;--是使SQLite可以跨操作系统移植的原因。每当SQLite中的任何其他模块需要与操作系统通信时,它们都会调用VFS中的方法。然后,VFS会调用满足请求所需的特定操作代码。因此,将SQLite移植到新的操作系统上,只需编写一个新的操作系统接口层或 &quot;VFS &quot;即可。</target>
        </trans-unit>
        <trans-unit id="61b9ed4bbd7c64412bf999ddb3735b90a9006325" translate="yes" xml:space="preserve">
          <source>The OS interface layer has been completely reworked:</source>
          <target state="translated">OS接口层已经完全改版。</target>
        </trans-unit>
        <trans-unit id="7db34215d6389d29f797bd445ad557bb97d4d35b" translate="yes" xml:space="preserve">
          <source>The OVER clause is required for &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt; and is prohibited otherwise. The DISTINCT keyword is only allowed in &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate functions&lt;/a&gt;. The FILTER clause may not appear on a &lt;a href=&quot;lang_corefunc&quot;&gt;simple function&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;windowfunctions&quot;&gt;窗口功能&lt;/a&gt;需要OVER子句，否则禁止使用OVER子句。DISTINCT关键字仅在&lt;a href=&quot;lang_aggfunc&quot;&gt;聚合函数中&lt;/a&gt;允许使用。FILTER子句可能不会出现在&lt;a href=&quot;lang_corefunc&quot;&gt;简单函数上&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="97086bd49779ce0aff6b3d28109cebe94640094e" translate="yes" xml:space="preserve">
          <source>The OpenDocument file format is used for office applications: word processors, spreadsheets, and presentations. It was originally designed for the OpenOffice suite but has since been incorporated into other desktop application suites. The OpenOffice application has been forked and renamed a few times. This author's primary use for OpenDocument is building slide presentations with either &lt;a href=&quot;https://www.neooffice.org/neojava/en/index.php&quot;&gt;NeoOffice&lt;/a&gt; on Mac, or &lt;a href=&quot;http://www.libreoffice.org/&quot;&gt;LibreOffice&lt;/a&gt; on Linux and Windows.</source>
          <target state="translated">OpenDocument文件格式用于办公应用程序：文字处理器，电子表格和演示文稿。它最初是为OpenOffice套件设计的，但此后已合并到其他桌面应用程序套件中。OpenOffice应用程序已被分叉并重命名了几次。作者对OpenDocument的主要用途是使用Mac 上的&lt;a href=&quot;https://www.neooffice.org/neojava/en/index.php&quot;&gt;NeoOffice&lt;/a&gt;或Linux和Windows上的&lt;a href=&quot;http://www.libreoffice.org/&quot;&gt;LibreOffice&lt;/a&gt;构建幻灯片演示。</target>
        </trans-unit>
        <trans-unit id="1f964251f7ea2be819f8a20dfdd0b0e36dbb1df3" translate="yes" xml:space="preserve">
          <source>The OpenDocument file format is used for office applications: word processors, spreadsheets, and presentations. It was originally designed for the OpenOffice suite but has since been incorporated into other desktop application suites. The OpenOffice application has been forked and renamed a few times. This author's primary use for OpenDocument is building slide presentations with either &lt;a href=&quot;https://www.neooffice.org/neojava/en/index.php&quot;&gt;NeoOffice&lt;/a&gt; on Mac, or &lt;a href=&quot;https://www.libreoffice.org/&quot;&gt;LibreOffice&lt;/a&gt; on Linux and Windows.</source>
          <target state="translated">OpenDocument文件格式用于办公应用程序：文字处理器，电子表格和演示文稿。它最初是为OpenOffice套件设计的，但此后已合并到其他桌面应用程序套件中。OpenOffice应用程序已被分叉并重命名了几次。作者对OpenDocument的主要用途是使用Mac上的&lt;a href=&quot;https://www.neooffice.org/neojava/en/index.php&quot;&gt;NeoOffice&lt;/a&gt;或Linux和Windows上的&lt;a href=&quot;https://www.libreoffice.org/&quot;&gt;LibreOffice&lt;/a&gt;构建幻灯片演示。</target>
        </trans-unit>
        <trans-unit id="a12f97809890d0843d3b379960cdb5a48586d66d" translate="yes" xml:space="preserve">
          <source>The P parameter in sqlite3_create_filename(D,J,W,N,P) should be an array of 2*N pointers to strings. Each pair of pointers in this array corresponds to a key and value for a query parameter. The P parameter may be a NULL pointer if N is zero. None of the 2*N pointers in the P array may be NULL pointers and key pointers should not be empty strings. None of the D, J, or W parameters to sqlite3_create_filename(D,J,W,N,P) may be NULL pointers, though they can be empty strings.</source>
          <target state="translated">sqlite3_create_filename(D,J,W,N,P)中的P参数应该是一个2*N的字符串指针数组。这个数组中的每一对指针都对应着一个查询参数的键和值。如果N为0,P参数可以是一个NULL指针。P数组中的2*N指针都不可以是NULL指针,键指针不应该是空字符串。sqlite3_create_filename(D,J,W,N,P)的D,J,W参数中没有一个可以是NULL指针,不过它们可以是空字符串。</target>
        </trans-unit>
        <trans-unit id="7e13d51d1ef218d337ca9fb917ffdb16cbc244df" translate="yes" xml:space="preserve">
          <source>The P1 cursor must be for a real table, not a pseudo-table. If P1 is not open then the behavior is undefined.</source>
          <target state="translated">P1游标必须是一个真实的表,而不是一个伪表。如果P1没有打开,那么这个行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="5b81ca2502b2715c59c443936643d2e3be1132fa" translate="yes" xml:space="preserve">
          <source>The P1 cursor must be for a real table, not a pseudo-table. P1 must have been opened prior to this opcode or the program will segfault.</source>
          <target state="translated">P1游标必须是一个真实的表,而不是一个伪表。P1必须在这个操作码之前被打开,否则程序会出现segfault。</target>
        </trans-unit>
        <trans-unit id="607ac7f84bdc4d441c6cb285c55a825dad256470" translate="yes" xml:space="preserve">
          <source>The P1 parameter is not actually used by this opcode. However, it is sometimes set to 1 instead of 0 as a hint to the command-line shell that this &lt;a href=&quot;opcode#Goto&quot;&gt;Goto&lt;/a&gt; is the bottom of a loop and that the lines from P2 down to the current line should be indented for EXPLAIN output.</source>
          <target state="translated">该操作码实际上未使用P1参数。但是，有时它设置为1而不是0，以提示命令行外壳程序此&lt;a href=&quot;opcode#Goto&quot;&gt;Goto&lt;/a&gt;是循环的底部，并且应该缩进从P2到当前行的行以进行EXPLAIN输出。</target>
        </trans-unit>
        <trans-unit id="28dbb0803ca5b349efaf91bc329608b765d512d1" translate="yes" xml:space="preserve">
          <source>The P3 argument of instruction 11 is of particular interest. The sort key is formed by prepending one character from P3 to each string and concatenating all the strings. The sort comparison function will look at this character to determine whether the sort order is ascending or descending, and whether to sort as a string or number. In this example, the first column should be sorted as a string in descending order so its prefix is &quot;D&quot; and the second column should sorted numerically in ascending order so its prefix is &quot;+&quot;. Ascending string sorting uses &quot;A&quot;, and descending numeric sorting uses &quot;-&quot;.</source>
          <target state="translated">指令11的P3参数特别值得关注。排序键是通过将P3中的一个字符预置到每个字符串中,并将所有的字符串连在一起形成的。排序比较函数将查看这个字符,以确定排序顺序是升序还是降序,以及是以字符串还是数字排序。在这个例子中,第一列应该按降序作为字符串排序,因此它的前缀是 &quot;D&quot;,第二列应该按升序进行数字排序,因此它的前缀是 &quot;+&quot;。升序字符串排序使用 &quot;A&quot;,降序数字排序使用&quot;-&quot;。</target>
        </trans-unit>
        <trans-unit id="55ff312bc89d3e83256edc55b23ecd77e64741ac" translate="yes" xml:space="preserve">
          <source>The P3 value is a hint to the btree implementation. If P3==1, that means P1 is an SQL index and that this instruction could have been omitted if that index had been unique. P3 is usually 0. P3 is always either 0 or 1.</source>
          <target state="translated">P3值是对btree实现的一个提示。如果P3==1,说明P1是一个SQL索引,如果该索引是唯一的,那么这条指令可以省略。P3通常为0,P3总是0或1。</target>
        </trans-unit>
        <trans-unit id="f0f52e542da01be92f32d06abf2506b4a2d4f31b" translate="yes" xml:space="preserve">
          <source>The P4 register values beginning with P3 form an unpacked index key that omits the PRIMARY KEY or ROWID. &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; this key value against the index that P1 is currently pointing to, ignoring the PRIMARY KEY or ROWID on the P1 index.</source>
          <target state="translated">以P3开头的P4寄存器值形成一个未打包的索引键，它忽略了PRIMARY KEY或ROWID。将此键值与P1当前指向的索引&lt;a href=&quot;opcode#Compare&quot;&gt;进行比较&lt;/a&gt;，而忽略P1索引上的PRIMARY KEY或ROWID。</target>
        </trans-unit>
        <trans-unit id="4c2c023857d26616de9f3d4b0976bd5072c920ee" translate="yes" xml:space="preserve">
          <source>The P4 register values beginning with P3 form an unpacked index key that omits the PRIMARY KEY. &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; this key value against the index that P1 is currently pointing to, ignoring the PRIMARY KEY or ROWID fields at the end.</source>
          <target state="translated">以P3开头的P4寄存器值形成一个未打包的索引键，而该索引键省略了PRIMARY KEY。将此键值与P1当前指向的索引&lt;a href=&quot;opcode#Compare&quot;&gt;进行比较&lt;/a&gt;，而忽略最后的PRIMARY KEY或ROWID字段。</target>
        </trans-unit>
        <trans-unit id="19d27257909a32ae5401b59e606c768db9ed4065" translate="yes" xml:space="preserve">
          <source>The P4 value may be either an integer (P4_INT32) or a pointer to a KeyInfo structure (P4_KEYINFO). If it is a pointer to a KeyInfo object, then table being opened must be an &lt;a href=&quot;fileformat2#btypes&quot;&gt;index b-tree&lt;/a&gt; where the KeyInfo object defines the content and collating sequence of that index b-tree. Otherwise, if P4 is an integer value, then the table being opened must be a &lt;a href=&quot;fileformat2#btypes&quot;&gt;table b-tree&lt;/a&gt; with a number of columns no less than the value of P4.</source>
          <target state="translated">P4值可以是整数（P4_INT32），也可以是指向KeyInfo结构的指针（P4_KEYINFO）。如果它是指向KeyInfo对象的指针，则打开的表必须是&lt;a href=&quot;fileformat2#btypes&quot;&gt;索引b树&lt;/a&gt;，其中KeyInfo对象定义该索引b树的内容和整理顺序。否则，如果P4是整数值，则打开的表必须是&lt;a href=&quot;fileformat2#btypes&quot;&gt;表b树&lt;/a&gt;，其列数不少于P4的值。</target>
        </trans-unit>
        <trans-unit id="21923e08794e63280a41a6b5f859992f400d98cc" translate="yes" xml:space="preserve">
          <source>The P5 arguments are taken from register P2 and its successors.</source>
          <target state="translated">P5参数取自寄存器P2及其后续的参数。</target>
        </trans-unit>
        <trans-unit id="6017964a6129b7a7e8f6a3da3f0784c73d2078ba" translate="yes" xml:space="preserve">
          <source>The P5 parameter can be a mask of the BTREE_* flags defined in btree.h. These flags control aspects of the operation of the btree. The BTREE_OMIT_JOURNAL and BTREE_SINGLE flags are added automatically.</source>
          <target state="translated">P5参数可以是btree.h中定义的BTREE_*标志的掩码,这些标志控制着btree的操作。BTREE_OMIT_JOURNAL和BTREE_SINGLE标志是自动添加的。</target>
        </trans-unit>
        <trans-unit id="3f1c0ff5695ef10ade1f6c3734423a4eb3077d3e" translate="yes" xml:space="preserve">
          <source>The PERSIST journaling mode prevents the rollback journal from being deleted at the end of each transaction. Instead, the header of the journal is overwritten with zeros. This will prevent other database connections from rolling the journal back. The PERSIST journaling mode is useful as an optimization on platforms where deleting or truncating a file is much more expensive than overwriting the first block of a file with zeros. See also: &lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;PRAGMA journal_size_limit&lt;/a&gt; and &lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT&lt;/a&gt;.</source>
          <target state="translated">PERSIST日志记录模式可防止在每个事务结束时删除回滚日志。而是，日记的标题被零覆盖。这将防止其他数据库连接回滚日志。 PERSIST日记模式在平台上的优化非常有用，在该平台上，删除或截断文件比用零覆盖文件的第一块要贵得多。另请参阅：&lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;PRAGMA &lt;/a&gt;&lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;journal_size_limit&lt;/a&gt;和SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT。</target>
        </trans-unit>
        <trans-unit id="161bece08ac2f5702ce5212ddbeeb1a41f2dbaee" translate="yes" xml:space="preserve">
          <source>The PLINK table holds parent-child relationships between check-ins. The TAGXREF table maps tags into check-ins. For reference, the relevant portions of the schemas for these two tables is shown here:</source>
          <target state="translated">PLINK表保存了签到之间的父子关系。TAGXREF表将标签映射到签入中。为了便于参考,这里显示了这两个表的模式的相关部分。</target>
        </trans-unit>
        <trans-unit id="e4bd8ba431ab4e0d31722f8db284b8bb979b0c36" translate="yes" xml:space="preserve">
          <source>The PRAGMA statement is an SQL extension specific to SQLite and used to modify the operation of the SQLite library or to query the SQLite library for internal (non-table) data. The PRAGMA statement is issued using the same interface as other SQLite commands (e.g. &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;) but is different in the following important respects:</source>
          <target state="translated">PRAGMA语句是特定于SQLite的SQL扩展，用于修改SQLite库的操作或查询SQLite库的内部（非表）数据。PRAGMA语句是使用与其他SQLite命令（例如&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;，&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;）相同的接口发出的，但在以下重要方面有所不同：</target>
        </trans-unit>
        <trans-unit id="c66b0cfca97f029db26ea6f18637a49f7fab6a97" translate="yes" xml:space="preserve">
          <source>The PRAGMA synchronous=off statement now disables syncing of the master journal file in addition to the normal rollback journals</source>
          <target state="translated">PRAGMA synchronous=off语句现在除了正常的回滚日记外,还禁用了主日记文件的同步。</target>
        </trans-unit>
        <trans-unit id="b37fa685a4763fe504598bdda8b4b2f3d3eef491" translate="yes" xml:space="preserve">
          <source>The PRIMARY KEY constraint for a rowid table (as long as it is not the true primary key or INTEGER PRIMARY KEY) is really the same thing as a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE constraint&lt;/a&gt;. Because it is not a true primary key, columns of the PRIMARY KEY are allowed to be NULL, in violation of all SQL standards.</source>
          <target state="translated">rowid表的PRIMARY KEY约束（只要它不是真正的主键或INTEGER PRIMARY KEY）实际上与&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE约束&lt;/a&gt;相同。因为它不是真正的主键，所以允许PRIMARY KEY的列为NULL，这违反了所有SQL标准。</target>
        </trans-unit>
        <trans-unit id="ebe8c7b0a4b69dc3800a6f41776c565d6842c281" translate="yes" xml:space="preserve">
          <source>The PRIMARY KEY values identifying the modified row,</source>
          <target state="translated">识别修改后的行的PRIMARY KEY值。</target>
        </trans-unit>
        <trans-unit id="90caad2286223b2e029c8d716238518e674a76d1" translate="yes" xml:space="preserve">
          <source>The Page Cache</source>
          <target state="translated">页面缓存</target>
        </trans-unit>
        <trans-unit id="1f5eb567adef7decaf2acc8e4aa86ec1481f2a20" translate="yes" xml:space="preserve">
          <source>The PostgreSQL and MySQL servers used were as delivered by default on RedHat 7.2. (PostgreSQL version 7.1.3 and MySQL version 3.23.41.) No effort was made to tune these engines. Note in particular the default MySQL configuration on RedHat 7.2 does not support transactions. Not having to support transactions gives MySQL a big speed advantage, but SQLite is still able to hold its own on most tests.</source>
          <target state="translated">所使用的PostgreSQL和MySQL服务器是在RedHat 7.2上默认提供的,(PostgreSQL版本为7.1.3,MySQL版本为3.23.41)。(PostgreSQL版本7.1.3和MySQL版本3.23.41。)我们没有努力调整这些引擎。请特别注意,RedHat 7.2上默认的MySQL配置不支持事务。不支持事务给MySQL带来了很大的速度优势,但SQLite仍然能够在大多数测试中保持自己的优势。</target>
        </trans-unit>
        <trans-unit id="3d04a38a1d2743c1862a6cfdba60ded14ba2896a" translate="yes" xml:space="preserve">
          <source>The PutIntKey instruction (also described during the discussion about INSERT) writes an entry into the database file whose data is the top of the stack and whose key is the next on the stack, and then pops the stack twice. The PutIntKey instruction will overwrite the data of an existing record with the same key, which is what we want here. Overwriting was not an issue with INSERT because with INSERT the key was generated by the NewRecno instruction which is guaranteed to provide a key that has not been used before.</source>
          <target state="translated">PutIntKey指令(在讨论INSERT的时候也有介绍)在数据库文件中写入一条数据是堆栈顶端的、键是堆栈下一个的条目,然后弹出堆栈两次。PutIntKey指令将覆盖现有的具有相同键的记录的数据,这正是我们在这里想要的。在INSERT中覆盖不是问题,因为在INSERT中,key是由NewRecno指令生成的,而NewRecno指令可以保证提供一个以前没有使用过的key。</target>
        </trans-unit>
        <trans-unit id="7408173a3218822a3bb6af7f7e3d86be256cefca" translate="yes" xml:space="preserve">
          <source>The QPSG is disabled by default. It can be enabled at compile-time using the &lt;a href=&quot;compile#enable_qpsg&quot;&gt;SQLITE_ENABLE_QPSG&lt;/a&gt; compile-time option, or at run-time by invoking &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt;,1,0).</source>
          <target state="translated">默认情况下，禁用QPSG。可以在编译时使用&lt;a href=&quot;compile#enable_qpsg&quot;&gt;SQLITE_ENABLE_QPSG&lt;/a&gt;编译时选项启用它，也可以在运行时通过调用&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt;，1,0）启用它。</target>
        </trans-unit>
        <trans-unit id="7ff5d03d1a40249005abd9682f890ac5af94c96e" translate="yes" xml:space="preserve">
          <source>The QPSG means that if all of your queries run efficiently during testing, and if your application does not change the schema, then SQLite will not suddenly decide to start using a different query plan, possibly causing a performance problem, after your application is released to users. If your application works in the lab, it will continue working the same way after deployment.</source>
          <target state="translated">QPSG意味着,如果你的所有查询都在测试期间有效地运行,如果你的应用程序不改变模式,那么在你的应用程序发布给用户后,SQLite不会突然决定开始使用不同的查询计划,可能导致性能问题。如果你的应用程序在实验室中工作,那么在部署后它将继续以同样的方式工作。</target>
        </trans-unit>
        <trans-unit id="e7c6137b874e291f7e936bf89d2438f289c1e9a2" translate="yes" xml:space="preserve">
          <source>The R-Tree concept originated with &lt;a href=&quot;http://www.baymoon.com/~tg2/&quot;&gt;Toni Guttman&lt;/a&gt;: &lt;em&gt;R-Trees: A Dynamic Index Structure for Spatial Searching&lt;/em&gt;, Proc. 1984 ACM SIGMOD International Conference on Management of Data, pp. 47-57. The implementation found in SQLite is a refinement of Guttman's original idea, commonly called &quot;R*Trees&quot;, that was described by Norbert Beckmann, Hans-Peter Kriegel, Ralf Schneider, Bernhard Seeger: &lt;em&gt;The R*-Tree: An Efficient and Robust Access Method for Points and Rectangles.&lt;/em&gt; SIGMOD Conference 1990: 322-331.</source>
          <target state="translated">R-Tree概念起源于&lt;a href=&quot;http://www.baymoon.com/~tg2/&quot;&gt;Toni Guttman&lt;/a&gt;：&lt;em&gt;R-Trees：用于空间搜索的动态索引结构&lt;/em&gt;，Proc。 1984年ACM SIGMOD国际数据管理会议，第47-57页。 SQLite中的实现是对Guttman最初想法的改进，通常称为&amp;ldquo; R * Trees&amp;rdquo;，Norbert Beckmann，Hans-Peter Kriegel，Ralf Schneider，Bernhard Seeger对此进行了描述：&lt;em&gt;R * -Tree：有效而稳健的访问点和矩形的方法。&lt;/em&gt; SIGMOD会议1990：322-331。</target>
        </trans-unit>
        <trans-unit id="5d3074807f0a652cf6707800a925f23953d72a9a" translate="yes" xml:space="preserve">
          <source>The RAISE() function</source>
          <target state="translated">RAISE()函数</target>
        </trans-unit>
        <trans-unit id="c69d2de0461d9e5577928a8a0c182e55c377b7ea" translate="yes" xml:space="preserve">
          <source>The RBU Extension</source>
          <target state="translated">浸会大学的扩展</target>
        </trans-unit>
        <trans-unit id="f271a1dcb4b99763d2ff19003d2b360191882c40" translate="yes" xml:space="preserve">
          <source>The RBU database table contains a single row for each target database row inserted, updated or deleted by the update. Populating the RBU database tables is described in &lt;a href=&quot;rbu#database_contents&quot;&gt;the following section&lt;/a&gt;.</source>
          <target state="translated">RBU数据库表为更新插入，更新或删除的每个目标数据库行包含一行。&lt;a href=&quot;rbu#database_contents&quot;&gt;下一节&lt;/a&gt;将介绍如何填充RBU数据库表。</target>
        </trans-unit>
        <trans-unit id="5b9dd90a4d99e081d94181c982214ebaab88f1ab" translate="yes" xml:space="preserve">
          <source>The RBU extension interface allows an application to apply an RBU update stored in an RBU database to an existing target database. The procedure is as follows:</source>
          <target state="translated">RBU 扩展接口允许应用程序将存储在 RBU 数据库中的 RBU 更新应用到现有的目标数据库中。程序如下:</target>
        </trans-unit>
        <trans-unit id="fb0cbd808e0878559e4326851133fccc2e2e33dd" translate="yes" xml:space="preserve">
          <source>The RBU extension is an add-on for SQLite designed for use with large SQLite database files on low-power devices at the edge of a network. RBU may be used for two separate tasks:</source>
          <target state="translated">RBU扩展是SQLite的一个附加组件,设计用于在网络边缘的低功耗设备上使用大型SQLite数据库文件。RBU可以用于两个独立的任务。</target>
        </trans-unit>
        <trans-unit id="dc51cf7dfcbe19fae28d177efed486cafebfaa37" translate="yes" xml:space="preserve">
          <source>The RBU extension is not enabled by default. To enable it, compile the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; with the &lt;a href=&quot;compile#enable_rbu&quot;&gt;SQLITE_ENABLE_RBU&lt;/a&gt; compile-time option.</source>
          <target state="translated">默认情况下，RBU扩展未启用。要启用它，请使用&lt;a href=&quot;compile#enable_rbu&quot;&gt;SQLITE_ENABLE_RBU&lt;/a&gt;编译时选项编译&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d487cd05415f0ab5a85f8a6d6877a414f0dad6c" translate="yes" xml:space="preserve">
          <source>The RBU update will not detect or prevent foreign key or CHECK constraint violations.</source>
          <target state="translated">RBU更新不会检测或防止外键或CHECK约束违规。</target>
        </trans-unit>
        <trans-unit id="593961271c55fed248c83e9d463fa6fd9e121437" translate="yes" xml:space="preserve">
          <source>The RBU update will not fire any triggers.</source>
          <target state="translated">RBU更新不会启动任何触发器。</target>
        </trans-unit>
        <trans-unit id="c6564cc776de2c808e8f2b66fc117a6728b91dc4" translate="yes" xml:space="preserve">
          <source>The REGEXP operator is a special syntax for the regexp() user function. No regexp() user function is defined by default and so use of the REGEXP operator will normally result in an error message. If an &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; named &quot;regexp&quot; is added at run-time, then the &quot;</source>
          <target state="translated">REGEXP运算符是regexp（）用户函数的一种特殊语法。默认情况下，没有定义regexp（）用户函数，因此使用REGEXP运算符通常会导致错误消息。如果在运行时添加了&lt;a href=&quot;appfunc&quot;&gt;应用程序定义的&lt;/a&gt;名为&amp;ldquo; regexp&amp;rdquo;的SQL函数，则&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="d8e251943a38b26d445d7abf3f883e482037ceab" translate="yes" xml:space="preserve">
          <source>The REGEXP operator is a special syntax for the regexp() user function. No regexp() user function is defined by default and so use of the REGEXP operator will normally result in an error message. If an &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL function&lt;/a&gt; named &quot;regexp&quot; is added at run-time, then the &quot;</source>
          <target state="translated">REGEXP运算符是regexp（）用户函数的特殊语法。默认情况下，没有定义regexp（）用户函数，因此使用REGEXP运算符通常会导致错误消息。如果在运行时添加了&lt;a href=&quot;c3ref/create_function&quot;&gt;应用程序定义的&lt;/a&gt;名为&amp;ldquo; regexp&amp;rdquo;的SQL函数，则&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="f6504d5094ffa58be5ab1ac79df65f0b1aba5e47" translate="yes" xml:space="preserve">
          <source>The REINDEX command is used to delete and recreate indices from scratch. This is useful when the definition of a collation sequence has changed, or when there are &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt; involving a function whose definition has changed.</source>
          <target state="translated">REINDEX命令用于从头开始删除和重新创建索引。当排序规则序列的定义已更改，或&lt;a href=&quot;expridx&quot;&gt;表达式的索引中&lt;/a&gt;包含涉及其定义已更改的函数的索引时，此功能很有用。</target>
        </trans-unit>
        <trans-unit id="5a60389a484988aa39c6d8ad03d71480c4d40ec6" translate="yes" xml:space="preserve">
          <source>The REINDEX command is used to delete and recreate indices from scratch. This is useful when the definition of a collation sequence has changed.</source>
          <target state="translated">REINDEX命令用于从头开始删除和重新创建索引。当一个整理序列的定义发生变化时,这很有用。</target>
        </trans-unit>
        <trans-unit id="26337c24aa4b0f0ab8be7c9f3c788f1a63917d77" translate="yes" xml:space="preserve">
          <source>The REINDEX command was added.</source>
          <target state="translated">增加了REINDEX命令。</target>
        </trans-unit>
        <trans-unit id="25bdb1a8b2079e760c4eabb862683c2777d36a53" translate="yes" xml:space="preserve">
          <source>The RELEASE command is like a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; for a SAVEPOINT. The RELEASE command causes all savepoints back to and including the most recent savepoint with a matching name to be removed from the transaction stack. The RELEASE of an inner transaction does not cause any changes to be written to the database file; it merely removes savepoints from the transaction stack such that it is no longer possible to ROLLBACK TO those savepoints. If a RELEASE command releases the outermost savepoint, so that the transaction stack becomes empty, then RELEASE is the same as &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;. The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; command may be used to release all savepoints and commit the transaction even if the transaction was originally started by a SAVEPOINT command instead of a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; command.</source>
          <target state="translated">RELEASE命令就像一个SAVEPOINT 的&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;。RELEASE命令使所有保存点回到并包括最近的保存点（具有匹配的名称）并从事务堆栈中删除。内部事务的释放不会导致将任何更改写入数据库文件。它仅从事务堆栈中删除保存点，从而不再可能回滚到这些保存点。如果RELEASE命令释放最外面的保存点，从而使事务堆栈为空，则RELEASE与&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;相同。该&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;命令可以用来释放所有保存点和提交事务，即使该交易最初是由一个SAVEPOINT命令，而不是一个开始&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="2ca08634243012d2e2bc4d0598e7fea902f6787a" translate="yes" xml:space="preserve">
          <source>The RELEASE command starts with the most recent addition to the transaction stack and releases savepoints backwards in time until it releases a savepoint with a matching savepoint-name. Prior savepoints, even savepoints with matching savepoint-names, are unchanged. If the RELEASE command causes the transaction stack to become empty (if the RELEASE command releases the outermost transaction from the stack) then the transaction commits.</source>
          <target state="translated">RELEASE命令从最近加入事务堆栈的保存点开始,并按时间顺序向后释放保存点,直到释放一个具有匹配保存点名称的保存点。之前的保存点,甚至是具有匹配保存点名的保存点,都不会改变。如果RELEASE命令导致事务堆栈变空(如果RELEASE命令从堆栈中释放最外层的事务),那么事务就会提交。</target>
        </trans-unit>
        <trans-unit id="00402a1bc7f00a30656be0c0b84db4535fdee37b" translate="yes" xml:space="preserve">
          <source>The RENAME COLUMN TO syntax changes the column-name of table table-name into new-column-name. The column name is changed both within the table definition itself and also within all indexes, triggers, and views that reference the column. If the column name change would result in a semantic ambiguity in a trigger or view, then the RENAME COLUMN fails with an error and no changes are applied.</source>
          <target state="translated">RENAME COLUMN TO语法将表table-name的列名改为new-column-name。列名既会在表定义中被改变,也会在引用该列的所有索引、触发器和视图中被改变。如果列名的改变会导致触发器或视图中的语义模糊,那么rename column就会以错误的方式失败,并且不会应用任何更改。</target>
        </trans-unit>
        <trans-unit id="4fd18ba9ff83bdc2461dca0a5dcb6bdcec775c80" translate="yes" xml:space="preserve">
          <source>The RENAME TO syntax changes the name of table-name to new-table-name. This command cannot be used to move a table between attached databases, only to rename a table within the same database. If the table being renamed has triggers or indices, then these remain attached to the table after it has been renamed.</source>
          <target state="translated">RENAME TO语法将表名改为new-table-name。这个命令不能用来在附加的数据库之间移动表,只能用来重命名同一数据库内的表。如果被重命名的表有触发器或索引,那么在表被重命名后,这些触发器或索引仍然附着在表上。</target>
        </trans-unit>
        <trans-unit id="802816683a1617052efa11363c7e7856de219468" translate="yes" xml:space="preserve">
          <source>The REPLACE command is an alias for the &quot;&lt;a href=&quot;lang_conflict&quot;&gt;INSERT OR REPLACE&lt;/a&gt;&quot; variant of the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; command. This alias is provided for compatibility other SQL database engines. See the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; command documentation for additional information.</source>
          <target state="translated">REPLACE命令是&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;命令的&amp;ldquo; &lt;a href=&quot;lang_conflict&quot;&gt;INSERT OR REPLACE&lt;/a&gt; &amp;rdquo;变体的别名。提供此别名是为了与其他SQL数据库引擎兼容。有关其他信息，请参见&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;命令文档。</target>
        </trans-unit>
        <trans-unit id="f900ded58f3c3fd3840ddc24eb90dbbf605e279b" translate="yes" xml:space="preserve">
          <source>The ROLLBACK TO command reverts the state of the database back to what it was just after the corresponding SAVEPOINT. Note that unlike that plain &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command (without the TO keyword) the ROLLBACK TO command does not cancel the transaction. Instead of cancelling the transaction, the ROLLBACK TO command restarts the transaction again at the beginning. All intervening SAVEPOINTs are canceled, however.</source>
          <target state="translated">ROLLBACK TO命令将数据库的状态恢复到对应的SAVEPOINT之后的状态。请注意，与普通的&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;命令（没有TO关键字）不同，ROLLBACK TO命令不会取消事务。ROLLBACK TO命令没有取消事务，而是从头开始重新启动事务。但是，所有中间的SAVEPOINT都被取消。</target>
        </trans-unit>
        <trans-unit id="cd447cb0f90571617cf670fb9ebcb0a187d10c25" translate="yes" xml:space="preserve">
          <source>The ROLLBACK command with a TO clause rolls back transactions going backwards in time back to the most recent SAVEPOINT with a matching name. The SAVEPOINT with the matching name remains on the transaction stack, but all database changes that occurred after that SAVEPOINT was created are rolled back. If the savepoint-name in a ROLLBACK TO command does not match any SAVEPOINT on the stack, then the ROLLBACK command fails with an error and leaves the state of the database unchanged.</source>
          <target state="translated">带有TO子句的ROLLBACK命令可以将事务向后滚动到最近的具有匹配名称的SAVEPOINT。具有匹配名称的SAVEPOINT仍然保留在事务堆栈中,但是在该SAVEPOINT创建之后发生的所有数据库变化都会被回滚。如果ROLLBACK TO命令中的savepoint-name与堆栈上的任何savepoint不匹配,那么ROLLBACK命令就会以错误的方式失败,并使数据库的状态保持不变。</target>
        </trans-unit>
        <trans-unit id="62a43e8d492ce5e858bd1d1f31b22f0ef1c5e90c" translate="yes" xml:space="preserve">
          <source>The ROWS and GROUPS frame types are similar in that they both determine the extent of a frame by counting relative to the current row. The difference is that ROWS counts individual rows and GROUPS counts peer groups. The RANGE frame type is different. The RANGE frame type determines the extent of a frame by looking for expression values that are within some band of values relative to the current row.</source>
          <target state="translated">ROWS和GROUPS帧类型类似,它们都是通过相对于当前行的计数来确定帧的范围。不同的是,ROWS计算单个行,GROUPS计算对等组。RANGE帧类型则不同。RANGE帧类型通过寻找相对于当前行的某个值带内的表达式值来确定帧的范围。</target>
        </trans-unit>
        <trans-unit id="6cd583a191932218eb3314e3e838d31fd080381b" translate="yes" xml:space="preserve">
          <source>The Robson proof applies separately to each of the memory allocators used by SQLite:</source>
          <target state="translated">Robson证明分别适用于SQLite使用的每个内存分配器。</target>
        </trans-unit>
        <trans-unit id="ebd8832f03de287c31f207b9169a825dcdfbcb2a" translate="yes" xml:space="preserve">
          <source>The RowSet object is optimized for the case where sets of integers are inserted in distinct phases, which each set contains no duplicates. Each set is identified by a unique P4 value. The first set must have P4==0, the final set must have P4==-1, and for all other sets must have P4&amp;gt;0.</source>
          <target state="translated">RowSet对象针对在不同阶段插入整数集的情况进行了优化，每个阶段均不包含重复项。每个集合由唯一的P4值标识。第一组必须具有P4 == 0，最后一组必须具有P4 ==-1，并且对于所有其他组，必须具有P4&amp;gt; 0。</target>
        </trans-unit>
        <trans-unit id="69b35696d5bc7e8c253762e4c23df59d339d7859" translate="yes" xml:space="preserve">
          <source>The SAVEPOINT command starts a new transaction with a name. The transaction names need not be unique. A SAVEPOINT can be started either within or outside of a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;...&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;. When a SAVEPOINT is the outer-most savepoint and it is not within a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;...&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; then the behavior is the same as BEGIN DEFERRED TRANSACTION.</source>
          <target state="translated">SAVEPOINT命令启动一个具有名称的新事务。事务名称不必唯一。可以在&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; ... &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT的&lt;/a&gt;内部或外部启动SAVEPOINT 。当SAVEPOINT是最外面的保存点并且不在&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; ... &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;内时，其行为与BEGIN DEFERRED TRANSACTION相同。</target>
        </trans-unit>
        <trans-unit id="ce13fbd458ee477db75220e11cabd929def8f2a4" translate="yes" xml:space="preserve">
          <source>The SCHEMA column is NULL, except for cases when the &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface is used to interrogate the ZIPVFS backend. As this only happens when the memstat.c module is compiled with -DSQLITE_ENABLE_ZIPVFS and when &lt;a href=&quot;https://www.hwaci.com/sw/sqlite/zipvfs.html&quot;&gt;ZIPVFS&lt;/a&gt; is in use, SCHEMA is usually NULL.</source>
          <target state="translated">SCHEMA 列为NULL，但使用&lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;接口查询ZIPVFS后端的情况除外。由于这只是发生在memstat.c模块编译-DSQLITE_ENABLE_ZIPVFS当&lt;a href=&quot;https://www.hwaci.com/sw/sqlite/zipvfs.html&quot;&gt;ZIPVFS&lt;/a&gt;在使用中，模式通常为NULL。</target>
        </trans-unit>
        <trans-unit id="c6115bd106a2add942203424bfde4ef5e373053a" translate="yes" xml:space="preserve">
          <source>The SELECT begins in a familiar fashion. First the column names are initialized and the table being queried is opened. Things become different beginning with instructions 5 and 6 where the index file is also opened. Instructions 7 and 8 make a key with the value of 50. The &lt;a href=&quot;opcode#MemStore&quot;&gt;MemStore&lt;/a&gt; instruction at 9 stores the index key in VDBE memory location 0. The VDBE memory is used to avoid having to fetch a value from deep in the stack, which can be done, but makes the program harder to generate. The following instruction &lt;a href=&quot;opcode#MoveTo&quot;&gt;MoveTo&lt;/a&gt; at address 10 pops the key off the stack and moves the index cursor to the first row of the index with that key. This initializes the cursor for use in the following loop.</source>
          <target state="translated">SELECT以熟悉的方式开始。首先，初始化列名，然后打开要查询的表。从指令5和6开始，情况也有所不同，其中也打开了索引文件。指令7和8生成一个值为50的&lt;a href=&quot;opcode#MemStore&quot;&gt;键。9&lt;/a&gt;处的MemStore指令将索引键存储在VDBE内存位置0中。VDBE内存用于避免从堆栈深处获取值，可以做到这一点。 ，但使程序难以生成。以下地址10处的&lt;a href=&quot;opcode#MoveTo&quot;&gt;MoveTo&lt;/a&gt;指令将键从堆栈中弹出，并使用该键将索引光标移动到索引的第一行。这将初始化游标以供在以下循环中使用。</target>
        </trans-unit>
        <trans-unit id="360db9d4f11a05425a6e0a615ab3f9ee4fa2dd3b" translate="yes" xml:space="preserve">
          <source>The SELECT statement above shows output of:</source>
          <target state="translated">上面的SELECT语句显示了以下的输出:</target>
        </trans-unit>
        <trans-unit id="7a0eced3e1981106cb4ea9f622f50ad79cd9e5a4" translate="yes" xml:space="preserve">
          <source>The SELECT statement is the most complicated command in the SQL language. To make the description easier to follow, some of the passages below describe the way the data returned by a SELECT statement is determined as a series of steps. It is important to keep in mind that this is purely illustrative - in practice neither SQLite nor any other SQL engine is required to follow this or any other specific process.</source>
          <target state="translated">SELECT语句是SQL语言中最复杂的命令。为了使描述更容易理解,下面的一些段落将SELECT语句返回的数据的确定方式描述为一系列步骤。需要记住的是,这纯粹是说明性的--在实际操作中,无论是SQLite还是任何其他SQL引擎都不需要遵循这个或任何其他具体过程。</target>
        </trans-unit>
        <trans-unit id="ecb8c3356a31e99d0c2a4414b1c0627a922137ba" translate="yes" xml:space="preserve">
          <source>The SELECT statement is used to query the database. The result of a SELECT is zero or more rows of data where each row has a fixed number of columns. A SELECT statement does not make any changes to the database.</source>
          <target state="translated">SELECT语句是用来查询数据库的。SELECT的结果是零行或多行数据,其中每行有固定的列数。SELECT语句不会对数据库进行任何修改。</target>
        </trans-unit>
        <trans-unit id="06f43e1f8274aa8dc54f915ee9dedc6e51d7565a" translate="yes" xml:space="preserve">
          <source>The SELECT statement on the left returns a single row since '0' and '0.0' are treated as numbers and are therefore indistinct. But the SELECT statement on the right returns two rows since 0 and 0.0 are treated a strings which are different.</source>
          <target state="translated">左边的SELECT语句返回一条记录,因为'0'和'0.0'被视为数字,因此是不一样的。但右边的SELECT语句返回两行,因为0和0.0被视为不同的字符串。</target>
        </trans-unit>
        <trans-unit id="e902534831ef4c318239e243a80c6ae4bb31b6d1" translate="yes" xml:space="preserve">
          <source>The SQL command &quot;BEGIN TRANSACTION&quot; (the TRANSACTION keyword is optional) is used to take SQLite out of autocommit mode. Note that the BEGIN command does not acquire any locks on the database. After a BEGIN command, a SHARED lock will be acquired when the first SELECT statement is executed. A RESERVED lock will be acquired when the first INSERT, UPDATE, or DELETE statement is executed. No EXCLUSIVE lock is acquired until either the memory cache fills up and must be spilled to disk or until the transaction commits. In this way, the system delays blocking read access to the file file until the last possible moment.</source>
          <target state="translated">SQL命令 &quot;BEGIN TRANSACTION&quot;(TRANSACTION关键字是可选的)用于使SQLite脱离自动提交模式。注意,BEGIN命令不会获取数据库上的任何锁。在BEGIN命令之后,当执行第一条SELECT语句时,将获得一个SHARED锁。当执行第一条INSERT、UPDATE或DELETE语句时,将获得一个RESOLED锁。在内存缓存填满而必须溢出到磁盘之前,或者在事务提交之前,都不会获得EXCLUSIVE锁。通过这种方式,系统将阻止对文件文件的读取访问延迟到最后可能的时刻。</target>
        </trans-unit>
        <trans-unit id="af8ff773b8faa66109f99e9e85b3a719b5cf7712" translate="yes" xml:space="preserve">
          <source>The SQL command &quot;COMMIT&quot; does not actually commit the changes to disk. It just turns autocommit back on. Then, at the conclusion of the command, the regular autocommit logic takes over and causes the actual commit to disk to occur. The SQL command &quot;ROLLBACK&quot; also operates by turning autocommit back on, but it also sets a flag that tells the autocommit logic to rollback rather than commit.</source>
          <target state="translated">SQL命令 &quot;COMMIT &quot;实际上并没有将更改提交到磁盘。它只是将自动提交重新开启。然后,在命令结束时,常规的自动提交逻辑接管并导致实际提交到磁盘。SQL命令 &quot;ROLLBACK &quot;也是通过重新开启自动提交来操作的,但是它也设置了一个标志,告诉自动提交逻辑要回滚而不是提交。</target>
        </trans-unit>
        <trans-unit id="1cddc0d667491d9249e7b156b49c099f6b89cdde" translate="yes" xml:space="preserve">
          <source>The SQL function creation interfaces may be called multiple times with the same function name. If two calls have the same function number but a different number of arguments, for example, then two variants of the SQL function will be registered, each taking a different number of arguments.</source>
          <target state="translated">SQL函数创建接口可以用同一个函数名多次调用。例如,如果两次调用的函数号相同,但参数数不同,那么将注册两个SQL函数的变体,每个变体的参数数不同。</target>
        </trans-unit>
        <trans-unit id="82504fd949554ebcdca052a7976082cbbc273023" translate="yes" xml:space="preserve">
          <source>The SQL fuzz generator tests are part of the TCL test suite. During a full test run, about 111.3 thousand fuzz SQL statements are generated and tested.</source>
          <target state="translated">SQL模糊生成器测试是TCL测试套件的一部分。在一个完整的测试过程中,大约有11.13万条模糊SQL语句被生成和测试。</target>
        </trans-unit>
        <trans-unit id="3044d65e21f066cf67f7a5007e05a25a7bcd19f9" translate="yes" xml:space="preserve">
          <source>The SQL language features several contexts where an expression is evaluated and the result converted to a boolean (true or false) value. These contexts are:</source>
          <target state="translated">SQL语言具有几个上下文,在这些上下文中,一个表达式被评估,结果被转换为布尔值(真或假)。这些上下文是:</target>
        </trans-unit>
        <trans-unit id="8b4f854d9a377d64ee6ebf1ef026f57adf3093a6" translate="yes" xml:space="preserve">
          <source>The SQL language is a &quot;standard&quot;. Even so, no two SQL database engines work exactly alike. Every SQL implementation has it own peculiarities and oddities, and SQLite is no exception to this rule.</source>
          <target state="translated">SQL语言是一种 &quot;标准&quot;。即便如此,没有两个SQL数据库引擎的工作方式是完全一样的。每个SQL实现都有自己的特点和怪异之处,SQLite也不例外。</target>
        </trans-unit>
        <trans-unit id="10de2fe05ef5e79065921e1cfe79576a9514e5b1" translate="yes" xml:space="preserve">
          <source>The SQL language is rich in keywords. Most SQL implementations do not allow keywords to be used as identifiers (the names of table or columns) unless they are enclosed in double-quotes. But SQLite is more flexible. Many keywords can be used as identifiers without needing to be quoted, as long as those keywords are used in a context where it is clear that they are intended to be an identifier.</source>
          <target state="translated">SQL语言中的关键字非常丰富。大多数SQL实现不允许将关键字作为标识符(表或列的名称)使用,除非用双引号括起来。但SQLite比较灵活。许多关键字可以作为标识符使用,而不需要加引号,只要这些关键字在使用时,清楚地知道它们是要作为标识符。</target>
        </trans-unit>
        <trans-unit id="a6afa95ef6a6482806d3030ee240e85ae2e39791" translate="yes" xml:space="preserve">
          <source>The SQL language is very powerful, and so it is always possible for malicious SQL inputs (or erroneous SQL inputs caused by an application bug) to submit SQL that runs for a very long time. To prevent this from becoming a denial-of-service attack, consider using the &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler()&lt;/a&gt; interface to invoke a callback periodically as each SQL statement runs, and have that callback return non-zero to abort the statement if the statement runs for too long. Alternatively, set a timer in a separate thread and invoke &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; when the timer goes off to prevent the SQL statement from running forever.</source>
          <target state="translated">SQL语言功能非常强大，因此恶意SQL输入（或由应用程序错误引起的错误SQL输入）总是有可能提交运行很长时间的SQL。为了防止这种情况成为拒绝服务攻击，请考虑使用&lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler（）&lt;/a&gt;接口在每个SQL语句运行时定期调用回调，并让该回调返回非零值以在语句运行时间过长时中止该语句。 。或者，在单独的线程中设置一个计时器，并在计时器关闭时调用&lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt（）&lt;/a&gt;，以防止SQL语句永远运行。</target>
        </trans-unit>
        <trans-unit id="48efb4a27989fcb1221b7de6665fb9fdbe5be779" translate="yes" xml:space="preserve">
          <source>The SQL language parser for SQLite is generated using a code-generator program called &quot;Lemon&quot;. The Lemon program reads a grammar of the input language and emits C-code to implement a parser for that language.</source>
          <target state="translated">SQLite的SQL语言解析器是通过一个名为 &quot;Lemon &quot;的代码生成器程序生成的。Lemon程序读取输入语言的语法,并发出C代码来实现该语言的解析器。</target>
        </trans-unit>
        <trans-unit id="3001af76a5af3b3d6822f17dc4d8570b011ad5be" translate="yes" xml:space="preserve">
          <source>The SQL output resulting from &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; is now modified to include the values of &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;.</source>
          <target state="translated">由&lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace（）&lt;/a&gt;生成的SQL输出现在已修改为包括&lt;a href=&quot;lang_expr#varparam&quot;&gt;绑定参数&lt;/a&gt;的值。</target>
        </trans-unit>
        <trans-unit id="677e1e6ba30ceb96b1361fef9b1a12b6f65a8d13" translate="yes" xml:space="preserve">
          <source>The SQL query in the example above uses less CPU than the first example in this section, but still has a non-obvious performance problem. SQLite satisfies this query by retrieving the value of the &quot;title&quot; column and matchinfo data from the FTS module for every row matched by the users query before it sorts and limits the results. Because of the way SQLite's virtual table interface works, retrieving the value of the &quot;title&quot; column requires loading the entire row from disk (including the &quot;content&quot; field, which may be quite large). This means that if the users query matches several thousand documents, many megabytes of &quot;title&quot; and &quot;content&quot; data may be loaded from disk into memory even though they will never be used for any purpose.</source>
          <target state="translated">上例中的SQL查询比本节第一个例子使用的CPU少,但仍然存在一个不明显的性能问题。SQLite在对结果进行排序和限制之前,先从FTS模块中检索用户查询所匹配的每一条记录的 &quot;title &quot;列的值和matchinfo数据,以此来满足这个查询。由于SQLite的虚拟表接口的工作方式,检索 &quot;title &quot;列的值需要从磁盘上加载整条记录(包括 &quot;content &quot;字段,它可能相当大)。这意味着,如果用户查询匹配了几千个文档,许多兆字节的 &quot;标题 &quot;和 &quot;内容 &quot;数据可能会从磁盘加载到内存中,即使它们永远不会被用于任何目的。</target>
        </trans-unit>
        <trans-unit id="44349eaec4c0440f46685e284dc3b9bdf9db6763" translate="yes" xml:space="preserve">
          <source>The SQL query in the following example block is one solution to this problem. In SQLite, when a &lt;a href=&quot;optoverview#flattening&quot;&gt;sub-query used in a join contains a LIMIT clause&lt;/a&gt;, the results of the sub-query are calculated and stored in temporary table before the main query is executed. This means that SQLite will load only the docid and matchinfo data for each row matching the users query into memory, determine the docid values corresponding to the ten most relevant documents, then load only the title and content information for those 10 documents only. Because both the matchinfo and docid values are gleaned entirely from the full-text index, this results in dramatically less data being loaded from the database into memory.</source>
          <target state="translated">以下示例块中的SQL查询是解决此问题的一种方法。在SQLite中，当联接中使用的&lt;a href=&quot;optoverview#flattening&quot;&gt;子查询包含LIMIT子句时&lt;/a&gt;，在执行主查询之前，将计算该子查询的结果并将其存储在临时表中。这意味着SQLite将仅将与用户查询匹配的每一行的docid和matchinfo数据加载到内存中，确定与十个最相关文档相对应的docid值，然后仅仅加载这十个文档的标题和内容信息。由于matchinfo和docid值均完全从全文索引中收集，因此导致从数据库加载到内存的数据大大减少。</target>
        </trans-unit>
        <trans-unit id="a5256c5c7d2eb97fecf26da60392ff96d1a9f664" translate="yes" xml:space="preserve">
          <source>The SQL standard requires double-quotes around identifiers and single-quotes around string literals. For example:</source>
          <target state="translated">SQL标准要求标识符周围用双引号,字符串字元周围用单引号。例如:</target>
        </trans-unit>
        <trans-unit id="7e7a261f0a3880c45baf726e85dad9e7315752c4" translate="yes" xml:space="preserve">
          <source>The SQL standard requires that a UNIQUE constraint be enforced even if one or more of the columns in the constraint are NULL, but SQLite does not do this. Isn't that a bug?</source>
          <target state="translated">SQL标准要求即使约束中的一列或多列为NULL,也要强制执行UNIQUE约束,但SQLite没有这样做。这不是一个bug吗?</target>
        </trans-unit>
        <trans-unit id="7a04eb23eef56ed5f467e10f54232c8a27c42d7f" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies a large number of keywords which may not be used as the names of tables, indices, columns, databases, user-defined functions, collations, virtual table modules, or any other named object. The list of keywords is so long that few people can remember them all. For most SQL code, your safest bet is to never use any English language word as the name of a user-defined object.</source>
          <target state="translated">SQL标准规定了大量的关键字,这些关键字不得用作表、索引、列、数据库、用户定义函数、整理、虚拟表模块或任何其他命名对象的名称。关键字的列表非常长,很少有人能全部记住。对于大多数SQL代码,你最安全的选择是永远不要使用任何英文单词作为用户定义对象的名称。</target>
        </trans-unit>
        <trans-unit id="f8004c4c668fddca439c94d74dc1d6f7c7684dbe" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies that single-quotes in strings are escaped by putting two single quotes in a row. SQL works like the Pascal programming language in this regard. Example:</source>
          <target state="translated">SQL标准规定,字符串中的单引号是通过在一行中加两个单引号来转义的。在这方面,SQL的工作原理与Pascal编程语言类似。例子</target>
        </trans-unit>
        <trans-unit id="59242cd06ef98d5456a2038bc8b7aff22753485f" translate="yes" xml:space="preserve">
          <source>The SQL statement is a UTF-8 string for sqlite3_prepare(). The sqlite3_prepare16() works the same way except that it expects a UTF-16 string as SQL input. Only the first SQL statement in the input string is compiled. The fifth parameter is filled in with a pointer to the next (uncompiled) SQLite statement in the input string, if any. The sqlite3_finalize() routine deallocates a prepared SQL statement. All prepared statements must be finalized before the database can be closed. The sqlite3_reset() routine resets a prepared SQL statement so that it can be executed again.</source>
          <target state="translated">sqlite3_prepare()的SQL语句是一个UTF-8的字符串。sqlite3_prepare16()的工作方式是一样的,只是它希望输入一个UTF-16的字符串作为SQL输入。只有输入字符串中的第一条SQL语句被编译。第五个参数被填入一个指向输入字符串中下一条(未编译)SQLite语句的指针,如果有的话。sqlite3_finalize()例程会重新分配一条准备好的SQL语句。在关闭数据库之前,所有准备好的语句必须被最终化。sqlite3_reset()例程重置一条已准备好的SQL语句,以便它可以再次执行。</target>
        </trans-unit>
        <trans-unit id="05506ce34afb730ccba4a9b42a033056b9bc26b4" translate="yes" xml:space="preserve">
          <source>The SQL statement may contain tokens of the form &quot;?&quot; or &quot;?nnn&quot; or &quot;:aaa&quot; where &quot;nnn&quot; is an integer and &quot;aaa&quot; is an identifier. Such tokens represent unspecified literal values (or &quot;wildcards&quot;) to be filled in later by the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind&lt;/a&gt; interface. Each wildcard has an associated number which is its sequence in the statement or the &quot;nnn&quot; in the case of a &quot;?nnn&quot; form. It is allowed for the same wildcard to occur more than once in the same SQL statement, in which case all instance of that wildcard will be filled in with the same value. Unbound wildcards have a value of NULL.</source>
          <target state="translated">SQL语句可以包含形式为&amp;ldquo;？&amp;rdquo;的令牌。或&amp;ldquo;？nnn&amp;rdquo;或&amp;ldquo;：aaa&amp;rdquo;，其中&amp;ldquo; nnn&amp;rdquo;是整数，&amp;ldquo; aaa&amp;rdquo;是标识符。这样的标记表示未指定的文字值（或&amp;ldquo;通配符&amp;rdquo;），稍后将由&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind&lt;/a&gt;接口填充。每个通配符都有一个关联的编号，该编号是其在语句中的顺序，对于&amp;ldquo;？nnn&amp;rdquo;形式则是&amp;ldquo; nnn&amp;rdquo;。允许同一通配符在同一SQL语句中出现多次，在这种情况下，该通配符的所有实例都将填充相同的值。未绑定的通配符的值为NULL。</target>
        </trans-unit>
        <trans-unit id="449ffcbd2d390b1586ef94ae6aaf64cdfbb6cfbd" translate="yes" xml:space="preserve">
          <source>The SQL statement supplied as the argument to the CREATE VIRTUAL TABLE statement is executed when the table is created. It must return either four or five columns. Each row returned describes one of the component tables. The first four columns are interpreted, from first to last, as:</source>
          <target state="translated">当表被创建时,作为CREATE VIRTUAL TABLE语句参数提供的SQL语句被执行。它必须返回四列或五列。返回的每一行都描述了一个组件表。前四列从第一列到最后一列解释为:。</target>
        </trans-unit>
        <trans-unit id="dd374f0003c79e47aa8712ac4ea58e570b4758d5" translate="yes" xml:space="preserve">
          <source>The SQL statements used to implement SQLite Archive operations make use of various &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt;. These extensions are all available in the &lt;a href=&quot;https://sqlite.org/src&quot;&gt;SQLite source tree&lt;/a&gt; in the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc&quot;&gt;ext/misc/ subfolder&lt;/a&gt;. The extensions needed for full SQLite Archive support include:</source>
          <target state="translated">用于实现SQLite Archive操作的SQL语句利用了各种&lt;a href=&quot;loadext&quot;&gt;可加载的扩展&lt;/a&gt;。这些扩展都可以在&lt;a href=&quot;https://sqlite.org/src/file/ext/misc&quot;&gt;ext / misc /子文件夹&lt;/a&gt;的&lt;a href=&quot;https://sqlite.org/src&quot;&gt;SQLite源代码树&lt;/a&gt;中找到。完整的SQLite Archive支持所需的扩展包括：</target>
        </trans-unit>
        <trans-unit id="cc6ae8d6fb78d715b5f8b26d43534dafb12ea942" translate="yes" xml:space="preserve">
          <source>The SQL syntax for custom queries is the same regardless of which interface, sqlite3_rtree_geometry_callback() or sqlite3_rtree_query_callback(), is used to register the SQL function. However, the newer query-style callbacks give the application greater control over how the query proceeds.</source>
          <target state="translated">无论使用sqlite3_rtree_geometry_callback()或sqlite3_rtree_query_callback()哪个接口来注册SQL函数,自定义查询的SQL语法都是一样的。然而,较新的查询式回调让应用程序对查询的进行有更大的控制权。</target>
        </trans-unit>
        <trans-unit id="f9308701d68c8225498cd757f7331dde6f73adc8" translate="yes" xml:space="preserve">
          <source>The SQL:1999 spec requires that the RECURSIVE keyword follow WITH in any WITH clause that includes a recursive common table expression. However, for compatibility with SqlServer and Oracle, SQLite does not enforce this rule.</source>
          <target state="translated">SQL:1999规范要求在任何包含递归通用表表达式的WITH子句中,RECURSIVE关键字都要跟在WITH后面。然而,为了与SqlServer和Oracle的兼容性,SQLite并不执行这一规则。</target>
        </trans-unit>
        <trans-unit id="b5ddf5e6785ea3822394b6d6a54fb42d4acd1778" translate="yes" xml:space="preserve">
          <source>The SQLITE_ABORT result code indicates that an operation was aborted prior to completion, usually be application request. See also: &lt;a href=&quot;rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;.</source>
          <target state="translated">SQLITE_ABORT结果代码指示操作在完成之前已中止，通常是应用程序请求。另请参见：&lt;a href=&quot;rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1613fab985744b29bc64a3b7d315d71db7102a20" translate="yes" xml:space="preserve">
          <source>The SQLITE_ABORT_ROLLBACK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; indicating that an SQL statement aborted because the transaction that was active when the SQL statement first started was rolled back. Pending write operations always fail with this error when a rollback occurs. A &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; will cause a pending read operation to fail only if the schema was changed within the transaction being rolled back.</source>
          <target state="translated">该SQLITE_ABORT_ROLLBACK错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;表明SQL语句中止，因为这是活跃的SQL语句时首先开始的事务回滚。回滚发生时，挂起的写操作始终会因此错误而失败。一个&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;会导致如果模式是内正在推出交易回改变挂起的读操作只有失败。</target>
        </trans-unit>
        <trans-unit id="9776b801900694be8692d527b6b6a5014611c72c" translate="yes" xml:space="preserve">
          <source>The SQLITE_AFF_MASK portion of P5 must be an affinity character - SQLITE_AFF_TEXT, SQLITE_AFF_INTEGER, and so forth. An attempt is made to coerce both inputs according to this affinity before the comparison is made. If the SQLITE_AFF_MASK is 0x00, then numeric affinity is used. Note that the affinity conversions are stored back into the input registers P1 and P3. So this opcode can cause persistent changes to registers P1 and P3.</source>
          <target state="translated">P5的SQLITE_AFF_MASK部分必须是一个亲和字符--SQLITE_AFF_TEXT、SQLITE_AFF_INTEGER等。在进行比较之前,会尝试根据这个亲和力来胁迫两个输入。如果SQLITE_AFF_MASK为0x00,则使用数字亲和力。需要注意的是,亲和力的转换会被存储回输入寄存器P1和P3中。所以这个操作码会导致寄存器P1和P3的持久性变化。</target>
        </trans-unit>
        <trans-unit id="dfa8cf2714776524ecdde2f427b30f632065e986" translate="yes" xml:space="preserve">
          <source>The SQLITE_AUTH error is returned when the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer callback&lt;/a&gt; indicates that an SQL statement being prepared is not authorized.</source>
          <target state="translated">当&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;授权者回调&lt;/a&gt;指示未授权正在准备的SQL语句时，将返回SQLITE_AUTH错误。</target>
        </trans-unit>
        <trans-unit id="a716819bd21e33b0b83c8f1def818df42717b54a" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY result code differs from &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; in that SQLITE_BUSY indicates a conflict with a separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;, probably in a separate process, whereas &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; indicates a conflict within the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; (or sometimes a database connection with a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;).</source>
          <target state="translated">SQLITE_BUSY结果代码与&lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED的&lt;/a&gt;不同之处在于，SQLITE_BUSY表示与单独的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;发生冲突（可能是在单独的进程中），而&lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;表示在同一&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接中&lt;/a&gt;发生冲突（或者有时是具有&lt;a href=&quot;sharedcache&quot;&gt;共享缓存&lt;/a&gt;的数据库连接）。</target>
        </trans-unit>
        <trans-unit id="6847ec78063b3fe6af5cc42bad60bb51ac404849" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY result code indicates that the database file could not be written (or in some cases read) because of concurrent activity by some other &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;, usually a database connection in a separate process.</source>
          <target state="translated">SQLITE_BUSY结果代码指示由于某些其他&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;（通常是单独过程中的数据库连接）的并发活动而无法写入（或在某些情况下读取）数据库文件。</target>
        </trans-unit>
        <trans-unit id="3cfe6b580ae13113f460c28fc71a7b4dbcf6c75a" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY_RECOVERY error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; that indicates that an operation could not continue because another process is busy recovering a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database file following a crash. The SQLITE_BUSY_RECOVERY error code only occurs on &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; databases.</source>
          <target state="translated">该SQLITE_BUSY_RECOVERY错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;指示的操作无法继续，因为另一个进程正忙于回收&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;的数据库文件崩溃之后。SQLITE_BUSY_RECOVERY错误代码仅在&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;数据库上出现。</target>
        </trans-unit>
        <trans-unit id="fc5599d49b00bbca3062bad1e4d863f9643aada6" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY_SNAPSHOT error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; that occurs on &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; databases when a database connection tries to promote a read transaction into a write transaction but finds that another &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; has already written to the database and thus invalidated prior reads.</source>
          <target state="translated">所述SQLITE_BUSY_SNAPSHOT错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;发生上&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;数据库，当数据库的连接尝试，以促进读事务成写事务但发现另一个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;已经写入数据库并因此无效之前读取。</target>
        </trans-unit>
        <trans-unit id="24c92b91edf3f7142a7dfa6604756c132d1f8004" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY_TIMEOUT error code indicates that a blocking Posix advisory file lock request in the VFS layer failed due to a timeout. Blocking Posix advisory locks are only available as a proprietary SQLite extension and even then are only supported if SQLite is compiled with the SQLITE_EANBLE_SETLK_TIMEOUT compile-time option.</source>
          <target state="translated">SQLITE_BUSY_TIMEOUT错误代码表示VFS层的阻塞Posix咨询文件锁请求因超时而失败。封锁Posix咨询文件锁只有作为专有的SQLite扩展才可以使用,即使如此,也只有在SQLite编译时使用SQLITE_EANBLE_SETLK_TIMEOUT编译时选项时才支持。</target>
        </trans-unit>
        <trans-unit id="9ff4a95f8927914c1763adf9045af4ab62d2f754" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN result code indicates that SQLite was unable to open a file. The file in question might be a primary database file or one of several &lt;a href=&quot;tempfiles&quot;&gt;temporary disk files&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CANTOPEN结果代码指示SQLite无法打开文件。有问题的文件可能是主数据库文件，也可能是几个&lt;a href=&quot;tempfiles&quot;&gt;临时磁盘文件之一&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="500408920c5afff76382c31e4489f9ce53192205" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_CONVPATH error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; used only by Cygwin &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; and indicating that the cygwin_conv_path() system call failed while trying to open a file. See also: &lt;a href=&quot;rescode#ioerr_convpath&quot;&gt;SQLITE_IOERR_CONVPATH&lt;/a&gt;</source>
          <target state="translated">该SQLITE_CANTOPEN_CONVPATH错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt;只由Cygwin的&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;和指示cygwin_conv_path（）系统调用，而试图打开一个文件失败。另请参阅：&lt;a href=&quot;rescode#ioerr_convpath&quot;&gt;SQLITE_IOERR_CONVPATH&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="55203070958c2991ba87f3b32bd40d536d90189a" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_DIRTYWAL result code is not used at this time.</source>
          <target state="translated">此时不使用SQLITE_CANTOPEN_DIRTYWAL结果代码。</target>
        </trans-unit>
        <trans-unit id="13b8dd7bacea04f63a2cb5fbae43d894d6332998" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_FULLPATH error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; indicating that a file open operation failed because the operating system was unable to convert the filename into a full pathname.</source>
          <target state="translated">该SQLITE_CANTOPEN_FULLPATH错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt;表示文件打开操作失败，因为操作系统无法将文件名转换成一个完整的路径名。</target>
        </trans-unit>
        <trans-unit id="c1b7e5d009e56aefb1e5fa74fb773f95be397ef4" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_ISDIR error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; indicating that a file open operation failed because the file is really a directory.</source>
          <target state="translated">该SQLITE_CANTOPEN_ISDIR错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt;表示文件打开操作失败，因为该文件实际上是目录。</target>
        </trans-unit>
        <trans-unit id="3ff11cefb3f88aae4a84bf8291076f3bac03ede6" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_NOTEMPDIR error code is no longer used.</source>
          <target state="translated">不再使用SQLITE_CANTOPEN_NOTEMPDIR错误代码。</target>
        </trans-unit>
        <trans-unit id="d8ae0720c2c5d2f9e9c8b29a355eb0cd10635524" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_SYMLINK result code is returned by the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; interface and its siblings when the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOFOLLOW&lt;/a&gt; flag is used and the database file is a symbolic link.</source>
          <target state="translated">当使用&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOFOLLOW&lt;/a&gt;标志并且数据库文件是符号链接时，&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;接口及其同级返回SQLITE_CANTOPEN_SYMLINK结果代码。</target>
        </trans-unit>
        <trans-unit id="06f769e27f147dfdd680f8a17a2bfe539caf9796" translate="yes" xml:space="preserve">
          <source>The SQLITE_CHECKPOINT_FULL, RESTART and TRUNCATE modes also obtain the exclusive &quot;writer&quot; lock on the database file. If the writer lock cannot be obtained immediately, and a busy-handler is configured, it is invoked and the writer lock retried until either the busy-handler returns 0 or the lock is successfully obtained. The busy-handler is also invoked while waiting for database readers as described above. If the busy-handler returns 0 before the writer lock is obtained or while waiting for database readers, the checkpoint operation proceeds from that point in the same way as SQLITE_CHECKPOINT_PASSIVE - checkpointing as many frames as possible without blocking any further. SQLITE_BUSY is returned in this case.</source>
          <target state="translated">SQLITE_CHECKPOINT_FULL、RESTART和TRUNCATE模式也会获得数据库文件上的专属 &quot;写手 &quot;锁。如果不能立即获得写入者锁,并且配置了忙处理程序,则会调用它并重新尝试写入者锁,直到忙处理程序返回0或成功获得锁。在等待数据库读取器的过程中,忙处理程序也会被调用,如上所述。如果忙处理程序在获得写入者锁之前或在等待数据库读取器时返回0,则检查点操作从该点开始以与SQLITE_CHECKPOINT_PASSIVE相同的方式进行--检查点尽可能多的帧,而不进一步阻塞。在这种情况下,会返回SQLITE_BUSY。</target>
        </trans-unit>
        <trans-unit id="5f7466fb166d62399d9f0072e0370315299af5b1" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_COVERING_INDEX_SCAN option takes a single integer argument which is interpreted as a boolean in order to enable or disable the use of covering indices for full table scans in the query optimizer. The default setting is determined by the &lt;a href=&quot;../compile#allow_covering_index_scan&quot;&gt;SQLITE_ALLOW_COVERING_INDEX_SCAN&lt;/a&gt; compile-time option, or is &quot;on&quot; if that compile-time option is omitted. The ability to disable the use of covering indices for full table scans is because some incorrectly coded legacy applications might malfunction when the optimization is enabled. Providing the ability to disable the optimization allows the older, buggy application code to work without change even with newer versions of SQLite.</source>
          <target state="translated">SQLITE_CONFIG_COVERING_INDEX_SCAN选项采用单个整数参数，该参数被解释为布尔值，以便为查询优化器中的全表扫描启用或禁用覆盖索引。默认设置由&lt;a href=&quot;../compile#allow_covering_index_scan&quot;&gt;SQLITE_ALLOW_COVERING_INDEX_SCAN&lt;/a&gt;编译时选项确定，如果省略该编译时选项，则为&amp;ldquo; on&amp;rdquo;。禁用对全表扫描使用覆盖索引的能力是因为启用优化后，某些编码错误的旧版应用程序可能会发生故障。提供禁用优化的功能，即使使用较新版本的SQLite，较旧且有错误的应用程序代码也可以正常工作。</target>
        </trans-unit>
        <trans-unit id="7d7ecdbc601a4823c2b08a2a5337606f8d30aa46" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_COVERING_INDEX_SCAN option takes a single integer argument which is interpreted as a boolean in order to enable or disable the use of covering indices for full table scans in the query optimizer. The default setting is determined by the &lt;a href=&quot;compile#allow_covering_index_scan&quot;&gt;SQLITE_ALLOW_COVERING_INDEX_SCAN&lt;/a&gt; compile-time option, or is &quot;on&quot; if that compile-time option is omitted. The ability to disable the use of covering indices for full table scans is because some incorrectly coded legacy applications might malfunction when the optimization is enabled. Providing the ability to disable the optimization allows the older, buggy application code to work without change even with newer versions of SQLite.</source>
          <target state="translated">SQLITE_CONFIG_COVERING_INDEX_SCAN选项采用单个整数参数，该参数被解释为布尔值，以便为查询优化器中的全表扫描启用或禁用覆盖索引。默认设置由&lt;a href=&quot;compile#allow_covering_index_scan&quot;&gt;SQLITE_ALLOW_COVERING_INDEX_SCAN&lt;/a&gt;编译时选项确定，如果省略该编译时选项，则为&amp;ldquo; on&amp;rdquo;。禁用对全表扫描使用覆盖索引的能力是因为启用优化后，某些编码错误的旧版应用程序可能会发生故障。提供禁用优化的功能，即使使用较新版本的SQLite，较旧且有错误的应用程序代码也可以正常工作。</target>
        </trans-unit>
        <trans-unit id="ff83d1ba90843c7f9c3dc720386b86f9f35e0379" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETMALLOC option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure. The &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure is filled with the currently defined memory allocation routines. This option can be used to overload the default memory allocation routines with a wrapper that simulations memory allocation failure or tracks memory usage, for example.</source>
          <target state="translated">SQLITE_CONFIG_GETMALLOC选项采用单个参数，该参数是指向&lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;结构实例的指针。该&lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;结构填充有当前定义的存储器分配例程。例如，此选项可用于通过包装器使默认内存分配例程过载，该包装器可模拟内存分配失败或跟踪内存使用情况。</target>
        </trans-unit>
        <trans-unit id="27c7cd5a1eddca0fbdae5b53b4edcfcd1711ca82" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETMALLOC option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure. The &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure is filled with the currently defined memory allocation routines. This option can be used to overload the default memory allocation routines with a wrapper that simulations memory allocation failure or tracks memory usage, for example.</source>
          <target state="translated">SQLITE_CONFIG_GETMALLOC选项采用单个参数，该参数是指向&lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;结构实例的指针。该&lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;结构填充有当前定义的存储器分配例程。例如，此选项可用于通过包装器使默认内存分配例程过载，该包装器可模拟内存分配失败或跟踪内存使用情况。</target>
        </trans-unit>
        <trans-unit id="be1078933a2f48f4ba63fb92d6b093d628661727" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETMUTEX option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure. The &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure is filled with the currently defined mutex routines. This option can be used to overload the default mutex allocation routines with a wrapper used to track mutex usage for performance profiling or testing, for example. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then the entire mutexing subsystem is omitted from the build and hence calls to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; with the SQLITE_CONFIG_GETMUTEX configuration option will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CONFIG_GETMUTEX选项采用单个参数，该参数是指向&lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt;结构实例的指针。该&lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt;结构充满了当前定义的互斥程序。例如，此选项可用于通过包装器重载默认的互斥量分配例程，该包装器用于跟踪互斥量的使用情况，以进行性能分析或测试。如果使用&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0的&lt;/a&gt;编译时选项编译SQLite，则整个生成子系统将被省略，因此使用SQLITE_CONFIG_GETMUTEX配置选项调用&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4910d5633ae70fa15de2ae4b340873caa0f78feb" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETMUTEX option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure. The &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure is filled with the currently defined mutex routines. This option can be used to overload the default mutex allocation routines with a wrapper used to track mutex usage for performance profiling or testing, for example. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then the entire mutexing subsystem is omitted from the build and hence calls to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; with the SQLITE_CONFIG_GETMUTEX configuration option will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CONFIG_GETMUTEX选项采用单个参数，该参数是指向&lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt;结构实例的指针。该&lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt;结构充满了当前定义的互斥程序。例如，此选项可用于通过包装器重载默认的互斥量分配例程，该包装器用于跟踪互斥量的使用情况，以进行性能分析或测试。如果使用&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0的&lt;/a&gt;编译时选项编译SQLite，则整个生成子系统将被省略，因此使用SQLITE_CONFIG_GETMUTEX配置选项调用&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;将返回&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="480ac6642108db12dacb128d029ff61248587e74" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETPCACHE2 option takes a single argument which is a pointer to an &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object. SQLite copies of the current page cache implementation into that object.</source>
          <target state="translated">SQLITE_CONFIG_GETPCACHE2选项采用单个参数，该参数是指向&lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt;对象的指针。当前页面缓存实现的SQLite副本到该对象中。</target>
        </trans-unit>
        <trans-unit id="d15656e2a537c4d062ffc1a4a28c224d21946fb5" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETPCACHE2 option takes a single argument which is a pointer to an &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object. SQLite copies of the current page cache implementation into that object.</source>
          <target state="translated">SQLITE_CONFIG_GETPCACHE2选项采用单个参数，该参数是指向&lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt;对象的指针。当前页面缓存实现的SQLite副本到该对象中。</target>
        </trans-unit>
        <trans-unit id="41bf906d256dc3dcf8d1b8d18fc31630de1f686b" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_HEAP option specifies a static memory buffer that SQLite will use for all of its dynamic memory allocation needs beyond those provided for by &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The SQLITE_CONFIG_HEAP option is only available if SQLite is compiled with either &lt;a href=&quot;compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; or &lt;a href=&quot;compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt; and returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if invoked otherwise. There are three arguments to SQLITE_CONFIG_HEAP: An 8-byte aligned pointer to the memory, the number of bytes in the memory buffer, and the minimum allocation size. If the first pointer (the memory pointer) is NULL, then SQLite reverts to using its default memory allocator (the system malloc() implementation), undoing any prior invocation of &lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;. If the memory pointer is not NULL then the alternative memory allocator is engaged to handle all of SQLites memory allocation needs. The first pointer (the memory pointer) must be aligned to an 8-byte boundary or subsequent behavior of SQLite will be undefined. The minimum allocation size is capped at 2**12. Reasonable values for the minimum allocation size are 2**5 through 2**8.</source>
          <target state="translated">SQLITE_CONFIG_HEAP选项指定一个静态内存缓冲区，SQLite将使用此静态内存缓冲区来满足&lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;所提供的所有动态内存分配需求。仅当使用&lt;a href=&quot;compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt;或&lt;a href=&quot;compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt;编译SQLite 并返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;时，SQLITE_CONFIG_HEAP选项才可用。 SQLITE_CONFIG_HEAP有三个参数：指向内存的8字节对齐指针，内存缓冲区中的字节数以及最小分配大小。如果第一个指针（内存指针）为NULL，则SQLite还原为使用其默认内存分配器（系统malloc（）实现），撤消任何先前对&lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC的&lt;/a&gt;调用。如果内存指针不为NULL，则使用备用内存分配器来处理所有SQLite内存分配需求。第一个指针（内存指针）必须与8字节边界对齐，否则SQLite的后续行为将不确定。最小分配大小上限为2 ** 12。最小分配大小的合理值是2 ** 5到2 ** 8。</target>
        </trans-unit>
        <trans-unit id="3fe54eb9feb326e6993f5e80b5d7f631fea68373" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_HEAP option specifies a static memory buffer that SQLite will use for all of its dynamic memory allocation needs beyond those provided for by &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The SQLITE_CONFIG_HEAP option is only available if SQLite is compiled with either &lt;a href=&quot;../compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; or &lt;a href=&quot;../compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt; and returns &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if invoked otherwise. There are three arguments to SQLITE_CONFIG_HEAP: An 8-byte aligned pointer to the memory, the number of bytes in the memory buffer, and the minimum allocation size. If the first pointer (the memory pointer) is NULL, then SQLite reverts to using its default memory allocator (the system malloc() implementation), undoing any prior invocation of &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;. If the memory pointer is not NULL then the alternative memory allocator is engaged to handle all of SQLites memory allocation needs. The first pointer (the memory pointer) must be aligned to an 8-byte boundary or subsequent behavior of SQLite will be undefined. The minimum allocation size is capped at 2**12. Reasonable values for the minimum allocation size are 2**5 through 2**8.</source>
          <target state="translated">SQLITE_CONFIG_HEAP选项指定一个静态内存缓冲区，SQLite将使用此静态内存缓冲区来满足&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;所提供的所有动态内存分配需求。仅当使用&lt;a href=&quot;../compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt;或&lt;a href=&quot;../compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt;编译SQLite 并返回&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;时，SQLITE_CONFIG_HEAP选项才可用。 SQLITE_CONFIG_HEAP有三个参数：指向内存的8字节对齐指针，内存缓冲区中的字节数以及最小分配大小。如果第一个指针（内存指针）为NULL，则SQLite还原为使用其默认内存分配器（系统malloc（）实现），撤消任何先前对&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC的&lt;/a&gt;调用。如果内存指针不为NULL，则使用备用内存分配器来处理所有SQLite内存分配需求。第一个指针（内存指针）必须与8字节边界对齐，否则SQLite的后续行为将不确定。最小分配大小上限为2 ** 12。最小分配大小的合理值是2 ** 5到2 ** 8。</target>
        </trans-unit>
        <trans-unit id="01d248a0a82b03a7f001692e75d24ae19d015766" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_LOG option is used to configure the SQLite global &lt;a href=&quot;../errlog&quot;&gt;error log&lt;/a&gt;. (The SQLITE_CONFIG_LOG option takes two arguments: a pointer to a function with a call signature of void(*)(void*,int,const char*), and a pointer to void. If the function pointer is not NULL, it is invoked by &lt;a href=&quot;log&quot;&gt;sqlite3_log()&lt;/a&gt; to process each logging event. If the function pointer is NULL, the &lt;a href=&quot;log&quot;&gt;sqlite3_log()&lt;/a&gt; interface becomes a no-op. The void pointer that is the second argument to SQLITE_CONFIG_LOG is passed through as the first parameter to the application-defined logger function whenever that function is invoked. The second parameter to the logger function is a copy of the first parameter to the corresponding &lt;a href=&quot;log&quot;&gt;sqlite3_log()&lt;/a&gt; call and is intended to be a &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result code&lt;/a&gt;. The third parameter passed to the logger is log message after formatting via &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt;. The SQLite logging interface is not reentrant; the logger function supplied by the application must not invoke any SQLite interface. In a multi-threaded application, the application-defined logger function must be threadsafe.</source>
          <target state="translated">SQLITE_CONFIG_LOG选项用于配置SQLite全局&lt;a href=&quot;../errlog&quot;&gt;错误日志&lt;/a&gt;。 （SQLITE_CONFIG_LOG选项具有两个参数：指向具有void（*）（void *，int，const char *）的调用签名的函数的指针，以及指向void的指针。如果函数指针不为NULL，则将其调用。通过&lt;a href=&quot;log&quot;&gt;sqlite3_log（）&lt;/a&gt;处理每个日志事件。如果函数指针为NULL，则&lt;a href=&quot;log&quot;&gt;sqlite3_log（）&lt;/a&gt;接口变为no-op。作为SQLITE_CONFIG_LOG的第二个参数的void指针作为第一个参数传递给应用程序定义的logger函数的第二个参数是第一个参数到相应的&lt;a href=&quot;log&quot;&gt;sqlite3_log（）&lt;/a&gt;调用的副本，旨在作为一个&lt;a href=&quot;../rescode&quot;&gt;结果代码&lt;/a&gt;或&lt;a href=&quot;../rescode#extrc&quot;&gt;扩展结果代码&lt;/a&gt;。传递给记录器的第三个参数是通过&lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;格式化后的日志消息。 SQLite日志记录接口不可重入；应用程序提供的记录器功能不得调用任何SQLite接口。在多线程应用程序中，应用程序定义的记录器功能必须是线程安全的。</target>
        </trans-unit>
        <trans-unit id="59e287bb60474979eb8cefde91438388d0375975" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_LOG option is used to configure the SQLite global &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt;. (The SQLITE_CONFIG_LOG option takes two arguments: a pointer to a function with a call signature of void(*)(void*,int,const char*), and a pointer to void. If the function pointer is not NULL, it is invoked by &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; to process each logging event. If the function pointer is NULL, the &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; interface becomes a no-op. The void pointer that is the second argument to SQLITE_CONFIG_LOG is passed through as the first parameter to the application-defined logger function whenever that function is invoked. The second parameter to the logger function is a copy of the first parameter to the corresponding &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; call and is intended to be a &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended result code&lt;/a&gt;. The third parameter passed to the logger is log message after formatting via &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt;. The SQLite logging interface is not reentrant; the logger function supplied by the application must not invoke any SQLite interface. In a multi-threaded application, the application-defined logger function must be threadsafe.</source>
          <target state="translated">SQLITE_CONFIG_LOG选项用于配置SQLite全局&lt;a href=&quot;errlog&quot;&gt;错误日志&lt;/a&gt;。 （SQLITE_CONFIG_LOG选项具有两个参数：指向具有void（*）（void *，int，const char *）的调用签名的函数的指针，以及指向void的指针。如果函数指针不为NULL，则将其调用。通过&lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log（）&lt;/a&gt;处理每个日志事件。如果函数指针为NULL，则&lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log（）&lt;/a&gt;接口变为no-op。作为SQLITE_CONFIG_LOG的第二个参数的void指针作为第一个参数传递给应用程序定义的logger函数的第二个参数是第一个参数到相应的&lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log（）&lt;/a&gt;调用的副本，旨在作为一个&lt;a href=&quot;rescode&quot;&gt;结果代码&lt;/a&gt;或&lt;a href=&quot;rescode#extrc&quot;&gt;扩展结果代码&lt;/a&gt;。传递给记录器的第三个参数是通过&lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;格式化后的日志消息。 SQLite日志记录接口不可重入；应用程序提供的记录器功能不得调用任何SQLite接口。在多线程应用程序中，应用程序定义的记录器功能必须是线程安全的。</target>
        </trans-unit>
        <trans-unit id="ab0156b86adc81defa456094d6dda8a22884243b" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_LOOKASIDE option takes two arguments that determine the default size of lookaside memory on each &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument is the size of each lookaside buffer slot and the second is the number of slots allocated to each database connection. SQLITE_CONFIG_LOOKASIDE sets the</source>
          <target state="translated">SQLITE_CONFIG_LOOKASIDE选项采用两个参数来确定每个&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;上后备存储器的默认大小。第一个参数是每个后备缓冲区插槽的大小，第二个参数是分配给每个数据库连接的插槽数。SQLITE_CONFIG_LOOKASIDE设置</target>
        </trans-unit>
        <trans-unit id="517e0ab9da5cb1067d00b2d40dff6d21a15492c5" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_LOOKASIDE option takes two arguments that determine the default size of lookaside memory on each &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument is the size of each lookaside buffer slot and the second is the number of slots allocated to each database connection. SQLITE_CONFIG_LOOKASIDE sets the</source>
          <target state="translated">SQLITE_CONFIG_LOOKASIDE选项采用两个参数来确定每个&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;上后备存储器的默认大小。第一个参数是每个后备缓冲区插槽的大小，第二个参数是分配给每个数据库连接的插槽数。SQLITE_CONFIG_LOOKASIDE设置</target>
        </trans-unit>
        <trans-unit id="5f5ea304960d2945164c69cf799e956ea26314e7" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MALLOC option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure. The argument specifies alternative low-level memory allocation routines to be used in place of the memory allocation routines built into SQLite. SQLite makes its own private copy of the content of the &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure before the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; call returns.</source>
          <target state="translated">SQLITE_CONFIG_MALLOC选项采用一个参数，该参数是指向&lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;结构实例的指针。该参数指定替代性的低级内存分配例程，以代替内置在SQLite中的内存分配例程。在&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;调用返回之前，SQLite对其&lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;结构的内容进行私有复制。</target>
        </trans-unit>
        <trans-unit id="212fa0cc6b6461ceacd5f53dcf7fed283b480c6d" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MALLOC option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure. The argument specifies alternative low-level memory allocation routines to be used in place of the memory allocation routines built into SQLite. SQLite makes its own private copy of the content of the &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure before the &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; call returns.</source>
          <target state="translated">SQLITE_CONFIG_MALLOC选项采用一个参数，该参数是指向&lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;结构实例的指针。该参数指定替代性的低级内存分配例程，以代替内置在SQLite中的内存分配例程。在&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;调用返回之前，SQLite对其&lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;结构的内容进行私有复制。</target>
        </trans-unit>
        <trans-unit id="a0f6142b40b1216838367535e150c109342d48bb" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MEMDB_MAXSIZE option accepts a single parameter &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; parameter which is the default maximum size for an in-memory database created using &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt;. This default maximum size can be adjusted up or down for individual databases using the &lt;a href=&quot;#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;file-control&lt;/a&gt;. If this configuration setting is never used, then the default maximum is determined by the &lt;a href=&quot;compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE&lt;/a&gt; compile-time option. If that compile-time option is not set, then the default maximum is 1073741824.</source>
          <target state="translated">SQLITE_CONFIG_MEMDB_MAXSIZE选项接受单个参数&lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt;参数，该参数是使用&lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize（）&lt;/a&gt;创建的内存数据库的默认最大大小。可以使用&lt;a href=&quot;#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT &lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;文件控件&lt;/a&gt;向上或向下调整单个数据库的默认最大大小。如果从不使用此配置设置，则默认最大值由&lt;a href=&quot;compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE&lt;/a&gt;编译时选项确定。如果未设置该编译时选项，则默认最大值为1073741824。</target>
        </trans-unit>
        <trans-unit id="81e7b78f6947d183a3f90000da914d03e1bc727e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MEMDB_MAXSIZE option accepts a single parameter &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; parameter which is the default maximum size for an in-memory database created using &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt;. This default maximum size can be adjusted up or down for individual databases using the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;file-control&lt;/a&gt;. If this configuration setting is never used, then the default maximum is determined by the &lt;a href=&quot;../compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE&lt;/a&gt; compile-time option. If that compile-time option is not set, then the default maximum is 1073741824.</source>
          <target state="translated">SQLITE_CONFIG_MEMDB_MAXSIZE选项接受单个参数&lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt;参数，该参数是使用&lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize（）&lt;/a&gt;创建的内存数据库的默认最大大小。可以使用&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT &lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;文件控件&lt;/a&gt;向上或向下调整单个数据库的默认最大大小。如果从不使用此配置设置，则默认最大值由&lt;a href=&quot;../compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE&lt;/a&gt;编译时选项确定。如果未设置该编译时选项，则默认最大值为1073741824。</target>
        </trans-unit>
        <trans-unit id="0f876ee04fb467dec2e88424ad542eb53469ec0b" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MEMSTATUS option takes single argument of type int, interpreted as a boolean, which enables or disables the collection of memory allocation statistics. When memory allocation statistics are disabled, the following SQLite interfaces become non-operational:</source>
          <target state="translated">SQLITE_CONFIG_MEMSTATUS选项取单一参数,类型为int,解释为布尔值,用于启用或禁用内存分配统计的收集。当禁用内存分配统计时,以下SQLite接口将无法操作。</target>
        </trans-unit>
        <trans-unit id="c9d36e0270700e44060555bf77969beca0ef1bb6" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MUTEX option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure. The argument specifies alternative low-level mutex routines to be used in place the mutex routines built into SQLite. SQLite makes a copy of the content of the &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure before the call to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; returns. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then the entire mutexing subsystem is omitted from the build and hence calls to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; with the SQLITE_CONFIG_MUTEX configuration option will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CONFIG_MUTEX选项采用单个参数，该参数是指向&lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt;结构实例的指针。该参数指定用于替代内置在SQLite中的互斥例程的其他低级互斥例程。在调用&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;返回之前，SQLite会复制&lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt;结构的内容。如果使用&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0的&lt;/a&gt;编译时选项编译SQLite，则整个生成子系统将被省略，因此使用SQLITE_CONFIG_MUTEX配置选项调用&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b773ada2ea4912cbbe3a1e1cebfe063f6d8a1c0" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MUTEX option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure. The argument specifies alternative low-level mutex routines to be used in place the mutex routines built into SQLite. SQLite makes a copy of the content of the &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure before the call to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; returns. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then the entire mutexing subsystem is omitted from the build and hence calls to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; with the SQLITE_CONFIG_MUTEX configuration option will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CONFIG_MUTEX选项采用单个参数，该参数是指向&lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt;结构实例的指针。该参数指定用于替代内置在SQLite中的互斥例程的其他低级互斥例程。在调用&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;返回之前，SQLite会复制&lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt;结构的内容。如果使用&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0的&lt;/a&gt;编译时选项编译SQLite，则整个生成子系统将被省略，因此使用SQLITE_CONFIG_MUTEX配置选项调用&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;将返回&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="09e3ca8fa4415d94f70fc44a6276555caf14748e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PAGECACHE option specifies a memory pool that SQLite can use for the database page cache with the default page cache implementation. This configuration option is a no-op if an application-define page cache implementation is loaded using the &lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;. There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem), the size of each page cache line (sz), and the number of cache lines (N). The sz argument should be the size of the largest database page (a power of two between 512 and 65536) plus some extra bytes for each page header. The number of extra bytes needed by the page header can be determined using &lt;a href=&quot;#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;. It is harmless, apart from the wasted memory, for the sz parameter to be larger than necessary. The pMem argument must be either a NULL pointer or a pointer to an 8-byte aligned block of memory of at least sz*N bytes, otherwise subsequent behavior is undefined. When pMem is not NULL, SQLite will strive to use the memory provided to satisfy page cache needs, falling back to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; if a page cache line is larger than sz bytes or if all of the pMem buffer is exhausted. If pMem is NULL and N is non-zero, then each database connection does an initial bulk allocation for page cache memory from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; sufficient for N cache lines if N is positive or of -1024*N bytes if N is negative, . If additional page cache memory is needed beyond what is provided by the initial allocation, then SQLite goes to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; separately for each additional cache line.</source>
          <target state="translated">SQLITE_CONFIG_PAGECACHE选项指定SQLite可用于具有默认页面缓存实现的数据库页面缓存的内存池。如果使用&lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;加载了应用程序定义的页面缓存实现，则此配置选项为no-op 。 SQLITE_CONFIG_PAGECACHE具有三个参数：指向8字节对齐内存（pMem）的指针，每页高速缓存行的大小（sz）和高速缓存行的数量（N）。 sz参数应为最大数据库页面的大小（512和65536之间的2的幂）加上每个页面标题的一些额外字节。页面标题所需的额外字节数可以使用&lt;a href=&quot;#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;确定。除了浪费的内存外，sz参数大于必需值是无害的。 pMem参数必须是NULL指针或指向至少sz * N字节的8字节对齐内存块的指针，否则未定义后续行为。当pMem不为NULL时，SQLite将努力使用提供的内存来满足页面缓存的需求，如果页面缓存行大于sz字节或所有pMem缓冲区都已用尽，则将使用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;。如果pMem为NULL且N为非零，则每个数据库连接都会从&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;对页面高速缓存进行初始批量分配如果N为正，则足以用于N个高速缓存行；如果N为负，则足以-1024 * N字节。如果除了初始分配所提供的内存之外，还需要其他页面缓存，则对于每个额外的缓存行，SQLite都会分别转到&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cc50296996fcaf95f25672cd009256aa14c36a0e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PAGECACHE option specifies a memory pool that SQLite can use for the database page cache with the default page cache implementation. This configuration option is a no-op if an application-define page cache implementation is loaded using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;. There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem), the size of each page cache line (sz), and the number of cache lines (N). The sz argument should be the size of the largest database page (a power of two between 512 and 65536) plus some extra bytes for each page header. The number of extra bytes needed by the page header can be determined using &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;. It is harmless, apart from the wasted memory, for the sz parameter to be larger than necessary. The pMem argument must be either a NULL pointer or a pointer to an 8-byte aligned block of memory of at least sz*N bytes, otherwise subsequent behavior is undefined. When pMem is not NULL, SQLite will strive to use the memory provided to satisfy page cache needs, falling back to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; if a page cache line is larger than sz bytes or if all of the pMem buffer is exhausted. If pMem is NULL and N is non-zero, then each database connection does an initial bulk allocation for page cache memory from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; sufficient for N cache lines if N is positive or of -1024*N bytes if N is negative, . If additional page cache memory is needed beyond what is provided by the initial allocation, then SQLite goes to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; separately for each additional cache line.</source>
          <target state="translated">SQLITE_CONFIG_PAGECACHE选项指定SQLite可用于具有默认页面缓存实现的数据库页面缓存的内存池。如果使用&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;加载了应用程序定义的页面缓存实现，则此配置选项为no-op 。 SQLITE_CONFIG_PAGECACHE具有三个参数：指向8字节对齐内存（pMem）的指针，每页高速缓存行的大小（sz）和高速缓存行的数量（N）。 sz参数应为最大数据库页面的大小（512和65536之间的2的幂）加上每个页面标题的一些额外字节。页面标题所需的额外字节数可以使用&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;确定。除了浪费的内存外，sz参数大于必需值是无害的。 pMem参数必须是NULL指针或指向至少sz * N字节的8字节对齐内存块的指针，否则未定义后续行为。当pMem不为NULL时，SQLite将努力使用提供的内存来满足页面缓存的需求，如果页面缓存行大于sz字节或所有pMem缓冲区都已用尽，则将使用&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;。如果pMem为NULL且N为非零，则每个数据库连接都会从&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;对页面高速缓存进行初始批量分配如果N为正，则足以用于N个高速缓存行；如果N为负，则足以-1024 * N字节。如果除了初始分配所提供的内存之外，还需要其他页面缓存，则对于每个额外的缓存行，SQLite都会分别转到&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="373c6de3bbf7db29ed258a5d09d9109fe9568cc5" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PAGECACHE option specifies a memory pool that SQLite can use for the database page cache with the default page cache implementation. This configuration option is a no-op if an application-defined page cache implementation is loaded using the &lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;. There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem), the size of each page cache line (sz), and the number of cache lines (N). The sz argument should be the size of the largest database page (a power of two between 512 and 65536) plus some extra bytes for each page header. The number of extra bytes needed by the page header can be determined using &lt;a href=&quot;#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;. It is harmless, apart from the wasted memory, for the sz parameter to be larger than necessary. The pMem argument must be either a NULL pointer or a pointer to an 8-byte aligned block of memory of at least sz*N bytes, otherwise subsequent behavior is undefined. When pMem is not NULL, SQLite will strive to use the memory provided to satisfy page cache needs, falling back to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; if a page cache line is larger than sz bytes or if all of the pMem buffer is exhausted. If pMem is NULL and N is non-zero, then each database connection does an initial bulk allocation for page cache memory from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; sufficient for N cache lines if N is positive or of -1024*N bytes if N is negative, . If additional page cache memory is needed beyond what is provided by the initial allocation, then SQLite goes to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; separately for each additional cache line.</source>
          <target state="translated">SQLITE_CONFIG_PAGECACHE选项指定SQLite可用于具有默认页面缓存实现的数据库页面缓存的内存池。如果使用&lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;加载了应用程序定义的页面缓存实现，则此配置选项为no-op 。 SQLITE_CONFIG_PAGECACHE包含三个参数：指向8字节对齐内存（pMem）的指针，每页高速缓存行的大小（sz）和高速缓存行的数量（N）。 sz参数应该是最大数据库页面的大小（512和65536之间的2的幂）加上每个页面标题的一些额外字节。页面标题所需的额外字节数可以使用&lt;a href=&quot;#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;确定。除了浪费的内存外，sz参数大于必需的值是无害的。 pMem参数必须是NULL指针或指向至少sz * N字节的8字节对齐内存块的指针，否则后续行为不确定。当pMem不为NULL时，SQLite将努力使用提供的内存来满足页面缓存的需求，如果页面缓存行大于sz字节或所有pMem缓冲区都用完了，SQLite会退回到&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;。如果pMem为NULL且N为非零，则每个数据库连接都会从&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;为页面高速缓存进行初始大容量分配如果N为正，则足以用于N个高速缓存行；如果N为负，则足以-1024 * N字节。如果除了初始分配所提供的内存之外，还需要其他页面缓存，则对于每个额外的缓存行，SQLite都会分别转到&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fe2e2404fd6d076f4a9442bd42821a9709933fc2" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PAGECACHE option specifies a memory pool that SQLite can use for the database page cache with the default page cache implementation. This configuration option is a no-op if an application-defined page cache implementation is loaded using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;. There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem), the size of each page cache line (sz), and the number of cache lines (N). The sz argument should be the size of the largest database page (a power of two between 512 and 65536) plus some extra bytes for each page header. The number of extra bytes needed by the page header can be determined using &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;. It is harmless, apart from the wasted memory, for the sz parameter to be larger than necessary. The pMem argument must be either a NULL pointer or a pointer to an 8-byte aligned block of memory of at least sz*N bytes, otherwise subsequent behavior is undefined. When pMem is not NULL, SQLite will strive to use the memory provided to satisfy page cache needs, falling back to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; if a page cache line is larger than sz bytes or if all of the pMem buffer is exhausted. If pMem is NULL and N is non-zero, then each database connection does an initial bulk allocation for page cache memory from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; sufficient for N cache lines if N is positive or of -1024*N bytes if N is negative, . If additional page cache memory is needed beyond what is provided by the initial allocation, then SQLite goes to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; separately for each additional cache line.</source>
          <target state="translated">SQLITE_CONFIG_PAGECACHE选项指定SQLite可用于具有默认页面缓存实现的数据库页面缓存的内存池。如果使用&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;加载了应用程序定义的页面缓存实现，则此配置选项为no-op 。 SQLITE_CONFIG_PAGECACHE包含三个参数：指向8字节对齐内存（pMem）的指针，每页高速缓存行的大小（sz）和高速缓存行的数量（N）。 sz参数应该是最大数据库页面的大小（512和65536之间的2的幂）加上每个页面标题的一些额外字节。页面标题所需的额外字节数可以使用&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;确定。除了浪费的内存外，sz参数大于必需的值是无害的。 pMem参数必须是NULL指针或指向至少sz * N字节的8字节对齐内存块的指针，否则后续行为不确定。当pMem不为NULL时，SQLite将努力使用提供的内存来满足页面缓存的需求，如果页面缓存行大于sz字节或所有pMem缓冲区都用完了，SQLite会退回到&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;。如果pMem为NULL且N为非零，则每个数据库连接都会从&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;为页面高速缓存进行初始大容量分配如果N为正，则足以用于N个高速缓存行；如果N为负，则足以-1024 * N字节。如果除了初始分配所提供的内存之外，还需要其他页面缓存，则对于每个额外的缓存行，SQLite都会分别转到&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1911f8a733a42d2b6026789f4ef363d83afb65d1" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PCACHE2 option takes a single argument which is a pointer to an &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object. This object specifies the interface to a custom page cache implementation. SQLite makes a copy of the &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object.</source>
          <target state="translated">SQLITE_CONFIG_PCACHE2选项采用单个参数，该参数是指向&lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt;对象的指针。该对象指定自定义页面缓存实现的接口。SQLite复制&lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="fe0c16b7c9692df379eddfaf23502a1d2deb56c4" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PCACHE2 option takes a single argument which is a pointer to an &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object. This object specifies the interface to a custom page cache implementation. SQLite makes a copy of the &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object.</source>
          <target state="translated">SQLITE_CONFIG_PCACHE2选项采用单个参数，该参数是指向&lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt;对象的指针。该对象指定自定义页面缓存实现的接口。SQLite复制&lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="8ecb0f208e89787f9a7f11980392d2014f2ef02a" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PCACHE_HDRSZ option takes a single parameter which is a pointer to an integer and writes into that integer the number of extra bytes per page required for each page in &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The amount of extra space required can change depending on the compiler, target platform, and SQLite version.</source>
          <target state="translated">SQLITE_CONFIG_PCACHE_HDRSZ选项采用一个参数，该参数是指向整数的指针，并将&lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE中&lt;/a&gt;每页所需的每页额外字节数写入该整数。所需的额外空间量可能会根据编译器，目标平台和SQLite版本而变化。</target>
        </trans-unit>
        <trans-unit id="efc57facbbb1ece8f5d6410e99a1c9a1fcbbbc32" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PCACHE_HDRSZ option takes a single parameter which is a pointer to an integer and writes into that integer the number of extra bytes per page required for each page in &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The amount of extra space required can change depending on the compiler, target platform, and SQLite version.</source>
          <target state="translated">SQLITE_CONFIG_PCACHE_HDRSZ选项采用一个参数，该参数是指向整数的指针，并将&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE中&lt;/a&gt;每页所需的每页额外字节数写入该整数。所需的额外空间量可能会根据编译器，目标平台和SQLite版本而变化。</target>
        </trans-unit>
        <trans-unit id="c693040f9e2e760d6e4cb06df98665a33285d6df" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PMASZ option takes a single parameter which is an unsigned integer and sets the &quot;Minimum PMA Size&quot; for the multithreaded sorter to that integer. The default minimum PMA Size is set by the &lt;a href=&quot;../compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt; compile-time option. New threads are launched to help with sort operations when multithreaded sorting is enabled (using the &lt;a href=&quot;../pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; command) and the amount of content to be sorted exceeds the page size times the minimum of the &lt;a href=&quot;../pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; setting and this value.</source>
          <target state="translated">SQLITE_CONFIG_PMASZ选项采用一个参数，该参数是无符号整数，并将多线程排序器的&amp;ldquo;最小PMA大小&amp;rdquo;设置为该整数。默认的最小PMA大小由&lt;a href=&quot;../compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt;编译时选项设置。当启用多线程排序（使用&lt;a href=&quot;../pragma#pragma_threads&quot;&gt;PRAGMAthreads&lt;/a&gt;命令）并且要排序的内容量超过页面&lt;a href=&quot;../pragma#pragma_cache_size&quot;&gt;大小乘&lt;/a&gt;以PRAGMA cache_size设置和该值的最小值时，将启动新线程来帮助进行排序操作。</target>
        </trans-unit>
        <trans-unit id="667ddbb0eaa86ffc653459dd23bacb289f6854a7" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PMASZ option takes a single parameter which is an unsigned integer and sets the &quot;Minimum PMA Size&quot; for the multithreaded sorter to that integer. The default minimum PMA Size is set by the &lt;a href=&quot;compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt; compile-time option. New threads are launched to help with sort operations when multithreaded sorting is enabled (using the &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; command) and the amount of content to be sorted exceeds the page size times the minimum of the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; setting and this value.</source>
          <target state="translated">SQLITE_CONFIG_PMASZ选项采用一个参数，该参数是无符号整数，并将多线程排序器的&amp;ldquo;最小PMA大小&amp;rdquo;设置为该整数。默认的最小PMA大小由&lt;a href=&quot;compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt;编译时选项设置。当启用多线程排序（使用&lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMAthreads&lt;/a&gt;命令）并且要排序的内容量超过页面&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;大小乘&lt;/a&gt;以PRAGMA cache_size设置和该值的最小值时，将启动新线程来帮助进行排序操作。</target>
        </trans-unit>
        <trans-unit id="109fdd8da62f03c0d4a96a618a19a71e802f905e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_SCRATCH option is no longer used.</source>
          <target state="translated">SQLITE_CONFIG_SCRATCH选项不再使用。</target>
        </trans-unit>
        <trans-unit id="29ca3b2106e1eec121b349f9609e0d465c220d3d" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_SMALL_MALLOC option takes single argument of type int, interpreted as a boolean, which if true provides a hint to SQLite that it should avoid large memory allocations if possible. SQLite will run faster if it is free to make large memory allocations, but some application might prefer to run slower in exchange for guarantees about memory fragmentation that are possible if large allocations are avoided. This hint is normally off.</source>
          <target state="translated">SQLITE_CONFIG_SMALL_MALLOC选项取类型为int的单参数,解释为布尔值,如果为true,则为SQLite提供一个提示,即如果可能的话,它应该避免大量的内存分配。如果SQLite可以自由地进行大的内存分配,它的运行速度会更快,但一些应用程序可能更愿意运行得慢一些,以换取关于内存碎片的保证,如果避免大的分配就有可能。这个提示通常是关闭的。</target>
        </trans-unit>
        <trans-unit id="05ddcc0bca5d82f48fed51db87e518d3912d859e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_SORTERREF_SIZE option accepts a single parameter of type (int) - the new value of the sorter-reference size threshold. Usually, when SQLite uses an external sort to order records according to an ORDER BY clause, all fields required by the caller are present in the sorted records. However, if SQLite determines based on the declared type of a table column that its values are likely to be very large - larger than the configured sorter-reference size threshold - then a reference is stored in each sorted record and the required column values loaded from the database as records are returned in sorted order. The default value for this option is to never use this optimization. Specifying a negative value for this option restores the default behaviour. This option is only available if SQLite is compiled with the &lt;a href=&quot;../compile#enable_sorter_references&quot;&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_CONFIG_SORTERREF_SIZE选项接受类型（int）的单个参数-排序器引用大小阈值的新值。通常，当SQLite使用外部排序根据ORDER BY子句对记录进行排序时，调用者所需的所有字段都将出现在排序的记录中。但是，如果SQLite根据表列的声明类型确定其值可能非常大-大于配置的排序器引用大小阈值-则将引用存储在每个排序记录中，并从其中加载所需的列值记录按排序顺序返回数据库。此选项的默认值是从不使用此优化。为此选项指定一个负值将恢复默认行为。仅当使用SQLite编译SQLite时，此选项才可用。&lt;a href=&quot;../compile#enable_sorter_references&quot;&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/a&gt;编译时选项。</target>
        </trans-unit>
        <trans-unit id="8e4676f31515701431b60d8c3fec0783441a3fad" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_SORTERREF_SIZE option accepts a single parameter of type (int) - the new value of the sorter-reference size threshold. Usually, when SQLite uses an external sort to order records according to an ORDER BY clause, all fields required by the caller are present in the sorted records. However, if SQLite determines based on the declared type of a table column that its values are likely to be very large - larger than the configured sorter-reference size threshold - then a reference is stored in each sorted record and the required column values loaded from the database as records are returned in sorted order. The default value for this option is to never use this optimization. Specifying a negative value for this option restores the default behaviour. This option is only available if SQLite is compiled with the &lt;a href=&quot;compile#enable_sorter_references&quot;&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_CONFIG_SORTERREF_SIZE选项接受类型（int）的单个参数-排序器引用大小阈值的新值。通常，当SQLite使用外部排序根据ORDER BY子句对记录进行排序时，调用者所需的所有字段都将出现在排序的记录中。但是，如果SQLite根据表列的声明类型确定其值可能非常大-大于配置的排序器引用大小阈值-则将引用存储在每个排序记录中，并从其中加载所需的列值记录按排序顺序返回数据库。此选项的默认值是从不使用此优化。为此选项指定一个负值将恢复默认行为。仅当使用SQLite编译SQLite时，此选项才可用。&lt;a href=&quot;compile#enable_sorter_references&quot;&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/a&gt;编译时选项。</target>
        </trans-unit>
        <trans-unit id="605f0b5884691b12b17ca06f9366cc2ade4cfd24" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_STMTJRNL_SPILL option takes a single parameter which becomes the &lt;a href=&quot;../tempfiles#stmtjrnl&quot;&gt;statement journal&lt;/a&gt; spill-to-disk threshold. &lt;a href=&quot;../tempfiles#stmtjrnl&quot;&gt;Statement journals&lt;/a&gt; are held in memory until their size (in bytes) exceeds this threshold, at which point they are written to disk. Or if the threshold is -1, statement journals are always held exclusively in memory. Since many statement journals never become large, setting the spill threshold to a value such as 64KiB can greatly reduce the amount of I/O required to support statement rollback. The default value for this setting is controlled by the &lt;a href=&quot;../compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_CONFIG_STMTJRNL_SPILL选项采用单个参数，该参数成为&lt;a href=&quot;../tempfiles#stmtjrnl&quot;&gt;语句日志&lt;/a&gt;溢出到磁盘的阈值。&lt;a href=&quot;../tempfiles#stmtjrnl&quot;&gt;语句日志&lt;/a&gt;会保留在内存中，直到它们的大小（以字节为单位）超过此阈值为止，此时它们将被写入磁盘。或者，如果阈值为-1，则语句日志始终仅保留在内存中。由于许多语句日志永远不会变大，因此将溢出阈值设置为64KiB之类的值可以大大减少支持语句回滚所需的I / O量。此设置的默认值由&lt;a href=&quot;../compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt;编译时选项控制。</target>
        </trans-unit>
        <trans-unit id="c96a7bbc95d6882993f7d0afda36dce9d7d4b5c0" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_STMTJRNL_SPILL option takes a single parameter which becomes the &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;statement journal&lt;/a&gt; spill-to-disk threshold. &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;Statement journals&lt;/a&gt; are held in memory until their size (in bytes) exceeds this threshold, at which point they are written to disk. Or if the threshold is -1, statement journals are always held exclusively in memory. Since many statement journals never become large, setting the spill threshold to a value such as 64KiB can greatly reduce the amount of I/O required to support statement rollback. The default value for this setting is controlled by the &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_CONFIG_STMTJRNL_SPILL选项采用单个参数，该参数成为&lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;语句日志&lt;/a&gt;溢出到磁盘的阈值。&lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;语句日志&lt;/a&gt;会保留在内存中，直到它们的大小（以字节为单位）超过此阈值为止，此时它们将被写入磁盘。或者，如果阈值为-1，则语句日志始终仅保留在内存中。由于许多语句日志永远不会变大，因此将溢出阈值设置为64KiB之类的值可以大大减少支持语句回滚所需的I / O量。此设置的默认值由&lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt;编译时选项控制。</target>
        </trans-unit>
        <trans-unit id="e7c94d69eb75e63340f2383ddf68d20c1d31a18d" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_URI option takes a single argument of type int. If non-zero, then URI handling is globally enabled. If the parameter is zero, then URI handling is globally disabled. If URI handling is globally enabled, all filenames passed to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt; or specified as part of &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; commands are interpreted as URIs, regardless of whether or not the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag is set when the database connection is opened. If it is globally disabled, filenames are only interpreted as URIs if the SQLITE_OPEN_URI flag is set when the database connection is opened. By default, URI handling is globally disabled. The default value may be changed by compiling with the &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; symbol defined.</source>
          <target state="translated">SQLITE_CONFIG_URI选项采用int类型的单个参数。如果非零，则全局启用URI处理。如果参数为零，则将全局禁用URI处理。如果全局启用了URI处理，则无论打开数据库连接时是否设置了&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;标志，传递给&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16（）&lt;/a&gt;或作为&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;命令的一部分指定的所有文件名都将解释为URI。。如果全局禁用它，则在打开数据库连接时设置了SQLITE_OPEN_URI标志时，仅将文件名解释为URI。默认情况下，URI处理是全局禁用的。可以通过使用&lt;a href=&quot;compile#use_uri&quot;&gt;&lt;/a&gt;定义了SQLITE_USE_URI符号。</target>
        </trans-unit>
        <trans-unit id="4ab4ffd66152d39e37a9eeebeb02a7852ae9ede8" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_URI option takes a single argument of type int. If non-zero, then URI handling is globally enabled. If the parameter is zero, then URI handling is globally disabled. If URI handling is globally enabled, all filenames passed to &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt; or specified as part of &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; commands are interpreted as URIs, regardless of whether or not the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag is set when the database connection is opened. If it is globally disabled, filenames are only interpreted as URIs if the SQLITE_OPEN_URI flag is set when the database connection is opened. By default, URI handling is globally disabled. The default value may be changed by compiling with the &lt;a href=&quot;../compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; symbol defined.</source>
          <target state="translated">SQLITE_CONFIG_URI选项采用int类型的单个参数。如果非零，则全局启用URI处理。如果参数为零，则将全局禁用URI处理。如果全局启用了URI处理，则无论打开数据库连接时是否设置了&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;标志，传递给&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;，&lt;a href=&quot;open&quot;&gt;sqlite3_open16（）&lt;/a&gt;或作为&lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;命令的一部分指定的所有文件名都将解释为URI。。如果全局禁用它，则在打开数据库连接时设置了SQLITE_OPEN_URI标志时，仅将文件名解释为URI。默认情况下，URI处理是全局禁用的。可以通过使用&lt;a href=&quot;../compile#use_uri&quot;&gt;&lt;/a&gt;定义了SQLITE_USE_URI符号。</target>
        </trans-unit>
        <trans-unit id="b4ea1f91dd128d45077ef6aab24be62cde2c08e4" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_WIN32_HEAPSIZE option is only available if SQLite is compiled for Windows with the &lt;a href=&quot;../compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt; pre-processor macro defined. SQLITE_CONFIG_WIN32_HEAPSIZE takes a 32-bit unsigned integer value that specifies the maximum size of the created heap.</source>
          <target state="translated">只有在为SQLite 定义了&lt;a href=&quot;../compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt;预处理程序宏的Windows编译SQLite时，SQLITE_CONFIG_WIN32_HEAPSIZE选项才可用。SQLITE_CONFIG_WIN32_HEAPSIZE采用32位无符号整数值，该值指定创建的堆的最大大小。</target>
        </trans-unit>
        <trans-unit id="55987e1e9f78159dc547356995af9fe3ce5c9817" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_WIN32_HEAPSIZE option is only available if SQLite is compiled for Windows with the &lt;a href=&quot;compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt; pre-processor macro defined. SQLITE_CONFIG_WIN32_HEAPSIZE takes a 32-bit unsigned integer value that specifies the maximum size of the created heap.</source>
          <target state="translated">只有在为Windows 定义了&lt;a href=&quot;compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt;预处理程序宏的情况下编译SQLite时，SQLITE_CONFIG_WIN32_HEAPSIZE选项才可用。SQLITE_CONFIG_WIN32_HEAPSIZE采用32位无符号整数值，该值指定创建的堆的最大大小。</target>
        </trans-unit>
        <trans-unit id="90354942dff120bb22a653ae9fa0d244342b89da" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT code can also be used as the return value from the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex()&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation. When xBestIndex() returns SQLITE_CONSTRAINT, that indicates that the particular combination of inputs submitted to xBestIndex() cannot result in a usable query plan and should not be given further consideration.</source>
          <target state="translated">SQLITE_CONSTRAINT代码也可以用作&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;实现的&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex（）&lt;/a&gt;方法的返回值。当xBestIndex（）返回SQLITE_CONSTRAINT时，这表示提交给xBestIndex（）的特定输入组合不能产生可用的查询计划，因此不应作进一步考虑。</target>
        </trans-unit>
        <trans-unit id="cd3afc5f9dc7b86d4db8138dda7591ba7ea2f042" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT error code means that an SQL constraint violation occurred while trying to process an SQL statement. Additional information about the failed constraint can be found by consulting the accompanying error message (returned via &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; or &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt;) or by looking at the &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CONSTRAINT错误代码表示在尝试处理SQL语句时发生了违反SQL约束的情况。有关失败约束的其他信息，可以通过查询附带的错误消息（通过&lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;或&lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg16（）返回&lt;/a&gt;）或通过查看&lt;a href=&quot;rescode#extrc&quot;&gt;扩展的错误代码来找到&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1402b83ad789cf26361c62d000ccad7aa66cb251" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_CHECK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt; failed.</source>
          <target state="translated">所述SQLITE_CONSTRAINT_CHECK错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;指示&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK约束&lt;/a&gt;失败。</target>
        </trans-unit>
        <trans-unit id="59f7b5e1d1fc684ffe767053e5ae405c247a79ff" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_COMMITHOOK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;c3ref/commit_hook&quot;&gt;commit hook callback&lt;/a&gt; returned non-zero that thus caused the SQL statement to be rolled back.</source>
          <target state="translated">所述SQLITE_CONSTRAINT_COMMITHOOK错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;指示&lt;a href=&quot;c3ref/commit_hook&quot;&gt;commit钩子回调&lt;/a&gt;返回非零，如此造成被回滚的SQL语句。</target>
        </trans-unit>
        <trans-unit id="c857f1295fd44fc161f41f3c36b1faa547511cbf" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_FOREIGNKEY error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; failed.</source>
          <target state="translated">该SQLITE_CONSTRAINT_FOREIGNKEY错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;指示&lt;a href=&quot;foreignkeys&quot;&gt;外键约束&lt;/a&gt;失败。</target>
        </trans-unit>
        <trans-unit id="fa48ddcf19118820df2cdaa1b78eb70d4071dd14" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_FUNCTION error code is not currently used by the SQLite core. However, this error code is available for use by extension functions.</source>
          <target state="translated">SQLITE_CONSTRAINT_FUNCTION错误代码目前不被SQLite核心使用。但是,这个错误代码可以被扩展函数使用。</target>
        </trans-unit>
        <trans-unit id="3c4481d9380cb514a86e596c21d0da6c70c2337c" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_NOTNULL error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL constraint&lt;/a&gt; failed.</source>
          <target state="translated">该SQLITE_CONSTRAINT_NOTNULL错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;指示&lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL约束&lt;/a&gt;失败。</target>
        </trans-unit>
        <trans-unit id="f3977e19203122b17dede1fa82c55227b6af2d00" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_PINNED error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that an &lt;a href=&quot;lang_createtrigger&quot;&gt;UPDATE trigger&lt;/a&gt; attempted do delete the row that was being updated in the middle of the update.</source>
          <target state="translated">该SQLITE_CONSTRAINT_PINNED错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;表明一个&lt;a href=&quot;lang_createtrigger&quot;&gt;UPDATE触发器&lt;/a&gt;试图做删除正在中间的更新更新的行。</target>
        </trans-unit>
        <trans-unit id="b921914ef5b1ae6eddb9ee04650c5c235d49ed11" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_PRIMARYKEY error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY constraint&lt;/a&gt; failed.</source>
          <target state="translated">所述SQLITE_CONSTRAINT_PRIMARYKEY错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;指示&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY约束&lt;/a&gt;失败。</target>
        </trans-unit>
        <trans-unit id="3d2416f0eb5c1e4932d96de2c633168fe0745690" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_ROWID error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; is not unique.</source>
          <target state="translated">所述SQLITE_CONSTRAINT_ROWID错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;指示&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;不是唯一的。</target>
        </trans-unit>
        <trans-unit id="d42ea811023ed01aef8eff1b26fe2bb9abe7bb95" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_TRIGGER error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtrigger#raise&quot;&gt;RAISE function&lt;/a&gt; within a &lt;a href=&quot;lang_createtrigger&quot;&gt;trigger&lt;/a&gt; fired, causing the SQL statement to abort.</source>
          <target state="translated">该SQLITE_CONSTRAINT_TRIGGER错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;指示&lt;a href=&quot;lang_createtrigger#raise&quot;&gt;RAISE功能&lt;/a&gt;一个内&lt;a href=&quot;lang_createtrigger&quot;&gt;触发&lt;/a&gt;开枪，导致SQL语句中止。</target>
        </trans-unit>
        <trans-unit id="360095776d45f4673d25e1354d178fe2a9b1bd8f" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_UNIQUE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE constraint&lt;/a&gt; failed.</source>
          <target state="translated">所述SQLITE_CONSTRAINT_UNIQUE错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;指示&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE约束&lt;/a&gt;失败。</target>
        </trans-unit>
        <trans-unit id="a2591670580b26a952a816bde9a68b915c405d78" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_VTAB error code is not currently used by the SQLite core. However, this error code is available for use by application-defined &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">SQLite内核当前未使用SQLITE_CONSTRAINT_VTAB错误代码。但是，此错误代码可供应用程序定义的&lt;a href=&quot;vtab&quot;&gt;虚拟表使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca22607c1bc11adbc4850780682a00fc2af063db" translate="yes" xml:space="preserve">
          <source>The SQLITE_CORRUPT result code indicates that the database file has been corrupted. See the &lt;a href=&quot;lockingv3#how_to_corrupt&quot;&gt;How To Corrupt Your Database Files&lt;/a&gt; for further discussion on how corruption can occur.</source>
          <target state="translated">SQLITE_CORRUPT结果代码指示数据库文件已损坏。有关&lt;a href=&quot;lockingv3#how_to_corrupt&quot;&gt;如何发生损坏&lt;/a&gt;的更多讨论，请参见如何损坏数据库文件。</target>
        </trans-unit>
        <trans-unit id="9c5271faefffc57a26de5d1e08a2704fbb68821b" translate="yes" xml:space="preserve">
          <source>The SQLITE_CORRUPT_INDEX result code means that SQLite detected an entry is or was missing from an index. This is a special case of the &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; error code that suggests that the problem might be resolved by running the &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; command, assuming no other problems exist elsewhere in the database file.</source>
          <target state="translated">SQLITE_CORRUPT_INDEX结果代码意味着SQLite检测到索引中存在或缺少条目。这是&lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt;错误代码的特例，它表示通过假设数据库文件中其他位置不存在其他问题，可以通过运行&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;命令来解决该问题。</target>
        </trans-unit>
        <trans-unit id="83192f645bf11cddd8fa598bcc30dab724111331" translate="yes" xml:space="preserve">
          <source>The SQLITE_CORRUPT_SEQUENCE result code means that the schema of the sqlite_sequence table is corrupt. The sqlite_sequence table is used to help implement the &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; feature. The sqlite_sequence table should have the following format:</source>
          <target state="translated">SQLITE_CORRUPT_SEQUENCE结果代码表示sqlite_sequence表的架构已损坏。sqlite_sequence表用于帮助实现&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;功能。sqlite_sequence表应采用以下格式：</target>
        </trans-unit>
        <trans-unit id="e605977504524c24f74112f64c7f554569d710cb" translate="yes" xml:space="preserve">
          <source>The SQLITE_CORRUPT_VTAB error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; used by &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;. A &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; might return SQLITE_CORRUPT_VTAB to indicate that content in the virtual table is corrupt.</source>
          <target state="translated">所述SQLITE_CORRUPT_VTAB错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt;通过使用&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;。一个&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;可能会返回SQLITE_CORRUPT_VTAB以指示虚表的内容已损坏。</target>
        </trans-unit>
        <trans-unit id="6f5aeac16ee13da96d49c9c69d5a1efa4f1ec4c7" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DEFENSIVE option activates or deactivates the &quot;defensive&quot; flag for a database connection. When the defensive flag is enabled, language features that allow ordinary SQL to deliberately corrupt the database file are disabled. The disabled features include but are not limited to the following:</source>
          <target state="translated">SQLITE_DBCONFIG_DEFENSIVE选项可以激活或停用数据库连接的 &quot;防御 &quot;标志。当启用防御性标志时,允许普通SQL故意破坏数据库文件的语言功能将被禁用。被禁用的功能包括但不限于以下内容。</target>
        </trans-unit>
        <trans-unit id="b1c89dddb1e567654969cbefc3cb66f653fb53df" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS option activates or deactivates the legacy &lt;a href=&quot;../quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DDL statements, such as CREATE TABLE and CREATE INDEX. The default value of this setting is determined by the &lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBCONFIG_DQS选项激活或停用DDL语句的旧的&lt;a href=&quot;../quirks#dblquote&quot;&gt;双引号字符串文字&lt;/a&gt;错误功能，例如CREATE TABLE和CREATE INDEX。此设置的默认值由&lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt;编译时选项确定。</target>
        </trans-unit>
        <trans-unit id="5fa9af190de834f94817db4398afc2b28f903d62" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS option activates or deactivates the legacy &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DDL statements, such as CREATE TABLE and CREATE INDEX. The default value of this setting is determined by the &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBCONFIG_DQS选项激活或停用DDL语句的旧的&lt;a href=&quot;quirks#dblquote&quot;&gt;双引号字符串文字&lt;/a&gt;错误功能，例如CREATE TABLE和CREATE INDEX。此设置的默认值由&lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt;编译时选项确定。</target>
        </trans-unit>
        <trans-unit id="7a4f8ed114b3f33c0656fd3fe462891e36a86bca" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS_DML option activates or deactivates the legacy &lt;a href=&quot;../quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DML statement only, that is DELETE, INSERT, SELECT, and UPDATE statements. The default value of this setting is determined by the &lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBCONFIG_DQS_DML选项仅针对DML语句（即DELETE，INSERT，SELECT和UPDATE语句）激活或停用旧的&lt;a href=&quot;../quirks#dblquote&quot;&gt;双引号字符串文字&lt;/a&gt;错误功能。此设置的默认值由&lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt;编译时选项确定。</target>
        </trans-unit>
        <trans-unit id="5ef07fd34a275a246ee518a98e66084fe0a55fad" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS_DML option activates or deactivates the legacy &lt;a href=&quot;../quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DML statements only, that is DELETE, INSERT, SELECT, and UPDATE statements. The default value of this setting is determined by the &lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBCONFIG_DQS_DML选项仅针对DML语句（即DELETE，INSERT，SELECT和UPDATE语句）激活或停用旧的&lt;a href=&quot;../quirks#dblquote&quot;&gt;双引号字符串文字&lt;/a&gt;错误功能。此设置的默认值由&lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt;编译时选项确定。</target>
        </trans-unit>
        <trans-unit id="b23b83b3528f7ad3365bcce16b9fcdca7b11634b" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS_DML option activates or deactivates the legacy &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DML statement only, that is DELETE, INSERT, SELECT, and UPDATE statements. The default value of this setting is determined by the &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBCONFIG_DQS_DML选项仅针对DML语句（即DELETE，INSERT，SELECT和UPDATE语句）激活或停用旧的&lt;a href=&quot;quirks#dblquote&quot;&gt;双引号字符串文字&lt;/a&gt;错误功能。此设置的默认值由&lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt;编译时选项确定。</target>
        </trans-unit>
        <trans-unit id="8485338d9edebd1879a88fb2aa42a3b5aaf70e71" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS_DML option activates or deactivates the legacy &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DML statements only, that is DELETE, INSERT, SELECT, and UPDATE statements. The default value of this setting is determined by the &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBCONFIG_DQS_DML选项仅针对DML语句（即DELETE，INSERT，SELECT和UPDATE语句）激活或停用旧的&lt;a href=&quot;quirks#dblquote&quot;&gt;双引号字符串文字&lt;/a&gt;错误功能。此设置的默认值由&lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt;编译时选项确定。</target>
        </trans-unit>
        <trans-unit id="763206f446e43106378de90da986cb3503647378" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_ENABLE_QPSG option activates or deactivates the &lt;a href=&quot;../queryplanner-ng#qpstab&quot;&gt;query planner stability guarantee&lt;/a&gt; (QPSG). When the QPSG is active, a single SQL query statement will always use the same algorithm regardless of values of &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;. The QPSG disables some query optimizations that look at the values of bound parameters, which can make some queries slower. But the QPSG has the advantage of more predictable behavior. With the QPSG active, SQLite will always use the same query plan in the field as was used during testing in the lab. The first argument to this setting is an integer which is 0 to disable the QPSG, positive to enable QPSG, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether the QPSG is disabled or enabled following this call.</source>
          <target state="translated">SQLITE_DBCONFIG_ENABLE_QPSG选项激活或禁用&lt;a href=&quot;../queryplanner-ng#qpstab&quot;&gt;查询计划程序稳定性保证&lt;/a&gt;（QPSG）。当QPSG处于活动状态时，单个SQL查询语句将始终使用相同的算法，而不管&lt;a href=&quot;../lang_expr#varparam&quot;&gt;绑定参数&lt;/a&gt;的值如何。 QPSG禁用某些查询优化，这些查询优化会查看绑定参数的值，这会使某些查询变慢。但是，QPSG具有行为更可预测的优势。在启用QPSG的情况下，SQLite将始终在字段中使用与实验室测试期间相同的查询计划。此设置的第一个参数是一个整数，该整数为0以禁用QPSG，为正数以启用QPSG，或者为负数以保持设置不变。第二个参数是指向整数的指针，该整数被写入0或1，以指示在此调用之后是禁用还是启用QPSG。</target>
        </trans-unit>
        <trans-unit id="e62faf35588a5d4eafe007180e96f2c0c110300b" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_ENABLE_QPSG option activates or deactivates the &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;query planner stability guarantee&lt;/a&gt; (QPSG). When the QPSG is active, a single SQL query statement will always use the same algorithm regardless of values of &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;. The QPSG disables some query optimizations that look at the values of bound parameters, which can make some queries slower. But the QPSG has the advantage of more predictable behavior. With the QPSG active, SQLite will always use the same query plan in the field as was used during testing in the lab. The first argument to this setting is an integer which is 0 to disable the QPSG, positive to enable QPSG, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether the QPSG is disabled or enabled following this call.</source>
          <target state="translated">SQLITE_DBCONFIG_ENABLE_QPSG选项激活或禁用&lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;查询计划程序稳定性保证&lt;/a&gt;（QPSG）。当QPSG处于活动状态时，单个SQL查询语句将始终使用相同的算法，而不管&lt;a href=&quot;lang_expr#varparam&quot;&gt;绑定参数&lt;/a&gt;的值如何。 QPSG禁用某些查询优化，这些查询优化会查看绑定参数的值，这会使某些查询变慢。但是，QPSG具有行为更可预测的优势。在启用QPSG的情况下，SQLite将始终在字段中使用与实验室测试期间相同的查询计划。此设置的第一个参数是一个整数，该整数为0以禁用QPSG，为正数以启用QPSG，或者为负数以保持设置不变。第二个参数是指向整数的指针，该整数被写入0或1，以指示在此调用之后是禁用还是启用QPSG。</target>
        </trans-unit>
        <trans-unit id="8bef3f5951097e41221958d251dd3bbb9ce96dee" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_LEGACY_ALTER_TABLE option activates or deactivates the legacy behavior of the &lt;a href=&quot;../lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; command such it behaves as it did prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_24_0.html&quot;&gt;version 3.24.0&lt;/a&gt; (2018-06-04). See the &quot;Compatibility Notice&quot; on the &lt;a href=&quot;../lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME documentation&lt;/a&gt; for additional information. This feature can also be turned on and off using the &lt;a href=&quot;../pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; statement.</source>
          <target state="translated">SQLITE_DBCONFIG_LEGACY_ALTER_TABLE选项激活或停用&lt;a href=&quot;../lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt;命令的旧行为，使其行为与&lt;a href=&quot;https://sqlite.org/releaselog/3_24_0.html&quot;&gt;3.24.0&lt;/a&gt;（2018-06-04）版本之前的行为相同。有关其他信息，请参见&lt;a href=&quot;../lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME文档&lt;/a&gt;上的&amp;ldquo;兼容性声明&amp;rdquo; 。也可以使用&lt;a href=&quot;../pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt;语句打开和关闭此功能。</target>
        </trans-unit>
        <trans-unit id="07c20d63d2e6b14f99d190fcacbd95a681ec8f6a" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_LEGACY_ALTER_TABLE option activates or deactivates the legacy behavior of the &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; command such it behaves as it did prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_24_0.html&quot;&gt;version 3.24.0&lt;/a&gt; (2018-06-04). See the &quot;Compatibility Notice&quot; on the &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME documentation&lt;/a&gt; for additional information. This feature can also be turned on and off using the &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; statement.</source>
          <target state="translated">SQLITE_DBCONFIG_LEGACY_ALTER_TABLE选项激活或停用&lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt;命令的旧行为，使其行为与&lt;a href=&quot;https://sqlite.org/releaselog/3_24_0.html&quot;&gt;3.24.0&lt;/a&gt;（2018-06-04）版本之前的行为相同。有关其他信息，请参见&lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME文档&lt;/a&gt;上的&amp;ldquo;兼容性声明&amp;rdquo; 。也可以使用&lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt;语句打开和关闭此功能。</target>
        </trans-unit>
        <trans-unit id="b56f76674dd3d27b6ff064c91089204d7b0e90fc" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_LEGACY_FILE_FORMAT option activates or deactivates the legacy file format flag. When activated, this flag causes all newly created database file to have a schema format version number (the 4-byte integer found at offset 44 into the database header) of 1. This in turn means that the resulting database file will be readable and writable by any SQLite version back to 3.0.0 (2004-06-18). Without this setting, newly created databases are generally not understandable by SQLite versions prior to 3.3.0 (2006-01-11). As these words are written, there is now scarcely any need to generated database files that are compatible all the way back to version 3.0.0, and so this setting is of little practical use, but is provided so that SQLite can continue to claim the ability to generate new database files that are compatible with version 3.0.0.</source>
          <target state="translated">SQLITE_DBCONFIG_LEGACY_FILE_FORMAT选项可以激活或停用遗留文件格式标志。当激活时,这个标志会使所有新创建的数据库文件的模式格式版本号(在数据库头偏移量44处找到的4字节整数)为1,这意味着生成的数据库文件可以被任何SQLite版本的3.0.0(2004-06-18)读和写。如果没有这个设置,新创建的数据库一般不能被3.3.0(2006-01-11)之前的SQLite版本理解。在写这些话的时候,现在几乎不需要生成一直兼容到3.0.0版本的数据库文件,所以这个设置没有什么实际用处,但提供这个设置是为了让SQLite可以继续宣称能够生成与3.0.0版本兼容的新数据库文件。</target>
        </trans-unit>
        <trans-unit id="609f392579cb3bfb47e8225e916b400815ceda24" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_TRUSTED_SCHEMA option tells SQLite to assume that database schemas are untainted by malicious content. When the SQLITE_DBCONFIG_TRUSTED_SCHEMA option is disabled, SQLite takes additional defensive steps to protect the application from harm including:</source>
          <target state="translated">SQLITE_DBCONFIG_TRUSTED_SCHEMA 选项告诉 SQLite 假设数据库模式没有受到恶意内容的污染。当禁用SQLITE_DBCONFIG_TRUSTED_SCHEMA选项时,SQLite会采取额外的防御措施来保护应用程序不受伤害,包括。</target>
        </trans-unit>
        <trans-unit id="6b8460a489883d4335645b0e8208feef234ba632" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_WRITABLE_SCHEMA option activates or deactivates the &quot;writable_schema&quot; flag. This has the same effect and is logically equivalent to setting &lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; or &lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=OFF&lt;/a&gt;. The first argument to this setting is an integer which is 0 to disable the writable_schema, positive to enable writable_schema, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether the writable_schema is enabled or disabled following this call.</source>
          <target state="translated">SQLITE_DBCONFIG_WRITABLE_SCHEMA选项激活或停用&amp;ldquo; writable_schema&amp;rdquo;标志。这具有相同的效果，并且在逻辑上等效于将&lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = ON&lt;/a&gt;或&lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = OFF&lt;/a&gt;设置为等效。此设置的第一个参数是整数，该整数为0以禁用writable_schema，为正数以启用writable_schema，或者为负数以使设置保持不变。第二个参数是指向整数的指针，该整数写入0或1，以指示此调用之后启用还是禁用writable_schema。</target>
        </trans-unit>
        <trans-unit id="46872dc1f07ab31c88fb7c7af6f4fae5ff78bc83" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_WRITABLE_SCHEMA option activates or deactivates the &quot;writable_schema&quot; flag. This has the same effect and is logically equivalent to setting &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=OFF&lt;/a&gt;. The first argument to this setting is an integer which is 0 to disable the writable_schema, positive to enable writable_schema, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether the writable_schema is enabled or disabled following this call.</source>
          <target state="translated">SQLITE_DBCONFIG_WRITABLE_SCHEMA选项激活或停用&amp;ldquo; writable_schema&amp;rdquo;标志。这具有相同的效果，并且在逻辑上等效于将&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = ON&lt;/a&gt;或&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = OFF&lt;/a&gt;设置为等效。此设置的第一个参数是整数，该整数为0以禁用writable_schema，为正数以启用writable_schema，或者为负数以使设置保持不变。第二个参数是指向整数的指针，该整数写入0或1，以指示此调用之后启用还是禁用writable_schema。</target>
        </trans-unit>
        <trans-unit id="6b85aa8ea894875435c445b85abe99205949918e" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE Virtual Table</source>
          <target state="translated">SQLITE_DBPAGE 虚拟表</target>
        </trans-unit>
        <trans-unit id="66cd1369214f0f32feaaff6ac1895398317fe842" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE extension implements an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt; that provides direct access to the underlying database file by interacting with the pager. SQLITE_DBPAGE is capable of both reading and writing any page of the database. Because interaction is through the pager layer, all changes are transactional.</source>
          <target state="translated">SQLITE_DBPAGE扩展实现了一个&lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;仅&lt;/a&gt;使用别名的虚拟表，该虚拟表通过与分页器进行交互来提供对基础数据库文件的直接访问。SQLITE_DBPAGE能够读取和写入数据库的任何页面。因为交互是通过寻呼机层进行的，所以所有更改都是事务性的。</target>
        </trans-unit>
        <trans-unit id="10bc6095f9cb7b42e8d331fa1d325222ae39eae9" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE extension is enabled in default builds of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;cli&quot;&gt;命令行shell的&lt;/a&gt;默认构建中启用了SQLITE_DBPAGE扩展。</target>
        </trans-unit>
        <trans-unit id="6759306b08f50bd9c66f3b5fb6678d1fa27bfe11" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE extension is included in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; though it is disabled by default. Use the &lt;a href=&quot;compile#enable_dbpage_vtab&quot;&gt;SQLITE_ENABLE_DBPAGE_VTAB&lt;/a&gt; compile-time option to enable the SQLITE_DBPAGE extension. The SQLITE_DBPAGE extension makes use of unpublished internal interfaces and is not run-time loadable. The only way to add SQLITE_DBPAGE to an application is to compile it in using the &lt;a href=&quot;compile#enable_dbpage_vtab&quot;&gt;SQLITE_ENABLE_DBPAGE_VTAB&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;amalgamation&quot;&gt;合并中&lt;/a&gt;包含SQLITE_DBPAGE扩展名，但默认情况下已禁用。使用&lt;a href=&quot;compile#enable_dbpage_vtab&quot;&gt;SQLITE_ENABLE_DBPAGE_VTAB&lt;/a&gt;编译时选项启用SQLITE_DBPAGE扩展。 SQLITE_DBPAGE扩展使用未发布的内部接口，并且不能在运行时加载。将SQLITE_DBPAGE添加到应用程序的唯一方法是使用&lt;a href=&quot;compile#enable_dbpage_vtab&quot;&gt;SQLITE_ENABLE_DBPAGE_VTAB&lt;/a&gt;编译时选项进行编译。</target>
        </trans-unit>
        <trans-unit id="29d747e639293b4d0174864bbfeb0a0f144170ea" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE table allows an application to view or replace the raw binary content of each page of the database file. No attempt is made to interpret the content of the page. Content is returned byte-for-byte as it appears on disk.</source>
          <target state="translated">SQLITE_DBPAGE表允许应用程序查看或替换数据库文件每个页面的原始二进制内容。不试图解释页面的内容。内容是按照磁盘上的内容逐字节返回的。</target>
        </trans-unit>
        <trans-unit id="f9b8d935ab9300d2651f69fa35d68c10b3cdb857" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE table can participate in a join just like any other table. Hence, to see the content of the first page to all connected database files, one might run a statement like this:</source>
          <target state="translated">SQLITE_DBPAGE表可以像其他表一样参与连接。因此,要查看所有连接的数据库文件的第一页内容,可以运行这样的语句。</target>
        </trans-unit>
        <trans-unit id="15d4ed3f8e0c537ab57736b4ad4d051438f525bd" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE table has one row for each page in the database file. SQLITE_DBPAGE allows pages to be read or to be overwritten. However the size of the database file cannot be changed. It is not possible to change the number of rows in the SQLITE_DBPAGE table by running DELETE or INSERT operations against that table.</source>
          <target state="translated">SQLITE_DBPAGE表对数据库文件中的每一页都有一行。SQLITE_DBPAGE表允许读取或覆盖页面。但是数据库文件的大小不能改变。通过对SQLITE_DBPAGE表进行DELETE或INSERT操作,无法改变该表的行数。</target>
        </trans-unit>
        <trans-unit id="74c5162b414c69b11a7519aa50aa6d53d70b24f0" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE table schema shown above is incomplete. There is a third &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden column&lt;/a&gt; named &quot;schema&quot; that determines which &lt;a href=&quot;lang_attach&quot;&gt;ATTACH-ed database&lt;/a&gt; should be read or written. Because the &quot;schema&quot; column is hidden, it can be used as a parameter when SQLITE_DBPAGE is invoked as a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt;.</source>
          <target state="translated">上面显示的SQLITE_DBPAGE表架构不完整。第三个&lt;a href=&quot;vtab#hiddencol&quot;&gt;隐藏的列&lt;/a&gt;名为&amp;ldquo; schema&amp;rdquo;，用于确定应读取或写入哪个&lt;a href=&quot;lang_attach&quot;&gt;ATTACH版本的数据库&lt;/a&gt;。由于&amp;ldquo; schema&amp;rdquo;列是隐藏的，因此在将SQLITE_DBPAGE作为&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;调用时，可以将其用作参数。</target>
        </trans-unit>
        <trans-unit id="518c52e0806550bfb6aa69b1fed15fbc4111a9ca" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE virtual table read/write table that provides direct access to the underlying disk file on a page-by-page basis. The virtual table appears to have a schema like this:</source>
          <target state="translated">SQLITE_DBPAGE虚拟表的读写表,提供了对底层磁盘文件逐页直接访问的功能。该虚拟表的模式似乎是这样的。</target>
        </trans-unit>
        <trans-unit id="c1930c1236dfcd2ca69ef991dff0ceab5ad493f1" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_FREEONCLOSE means that the database serialization in the P argument is held in memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and that SQLite should take ownership of this memory and automatically free it when it has finished using it. Without this flag, the caller is responsible for freeing any dynamically allocated memory.</source>
          <target state="translated">SQLITE_DESERIALIZE_FREEONCLOSE表示P参数中的数据库序列化保存在从&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;获得的内存中，并且SQLite应该拥有此内存的所有权，并在使用完该内存后自动释放它。如果没有此标志，则调用方负责释放任何动态分配的内存。</target>
        </trans-unit>
        <trans-unit id="76631b67d929ebcd295444bce3ec1691bb16c502" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_FREEONCLOSE means that the database serialization in the P argument is held in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and that SQLite should take ownership of this memory and automatically free it when it has finished using it. Without this flag, the caller is responsible for freeing any dynamically allocated memory.</source>
          <target state="translated">SQLITE_DESERIALIZE_FREEONCLOSE表示P参数中的数据库序列化保存在从&lt;a href=&quot;free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;获得的内存中，并且SQLite应该拥有此内存的所有权，并在使用完该内存后自动释放它。如果没有此标志，则调用方负责释放任何动态分配的内存。</target>
        </trans-unit>
        <trans-unit id="fffd4707786aad32f12960ea601bc8b62704db6b" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_READONLY flag means that the deserialized database should be treated as read-only.</source>
          <target state="translated">SQLITE_DESERIALIZE_READONLY标志意味着反序列化数据库应该被视为只读。</target>
        </trans-unit>
        <trans-unit id="684cad9c07969122877d4a208d11cefd54e63c00" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed to grow the size of the database using calls to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc64()&lt;/a&gt;. This flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used. Without this flag, the deserialized database cannot increase in size beyond the number of bytes specified by the M parameter.</source>
          <target state="translated">SQLITE_DESERIALIZE_RESIZEABLE标志意味着允许SQLite使用对&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc64（）的&lt;/a&gt;调用来增加数据库的大小。仅当还使用SQLITE_DESERIALIZE_FREEONCLOSE时，才应使用此标志。如果没有此标志，则反序列化数据库的大小不能增加到超过M参数指定的字节数。</target>
        </trans-unit>
        <trans-unit id="80121a4afb11422b1c8bfdaf5caf6ca8a41c2e89" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed to grow the size of the database using calls to &lt;a href=&quot;free&quot;&gt;sqlite3_realloc64()&lt;/a&gt;. This flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used. Without this flag, the deserialized database cannot increase in size beyond the number of bytes specified by the M parameter.</source>
          <target state="translated">SQLITE_DESERIALIZE_RESIZEABLE标志意味着允许SQLite使用对&lt;a href=&quot;free&quot;&gt;sqlite3_realloc64（）的&lt;/a&gt;调用来增加数据库的大小。仅当还使用SQLITE_DESERIALIZE_FREEONCLOSE时，才应使用此标志。如果没有此标志，则反序列化数据库的大小不能增加到超过M参数指定的字节数。</target>
        </trans-unit>
        <trans-unit id="19352bde546497cb9c8447fd1d7dfafe9e2fb83c" translate="yes" xml:space="preserve">
          <source>The SQLITE_DETERMINISTIC flag means that the new function always gives the same output when the input parameters are the same. The &lt;a href=&quot;../lang_corefunc#abs&quot;&gt;abs() function&lt;/a&gt; is deterministic, for example, but &lt;a href=&quot;../lang_corefunc#randomblob&quot;&gt;randomblob()&lt;/a&gt; is not. Functions must be deterministic in order to be used in certain contexts such as with the WHERE clause of &lt;a href=&quot;../partialindex&quot;&gt;partial indexes&lt;/a&gt; or in &lt;a href=&quot;../gencol&quot;&gt;generated columns&lt;/a&gt;. SQLite might also optimize deterministic functions by factoring them out of inner loops.</source>
          <target state="translated">SQLITE_DETERMINISTIC标志意味着当输入参数相同时，新函数始终提供相同的输出。的&lt;a href=&quot;../lang_corefunc#abs&quot;&gt;ABS（）函数&lt;/a&gt;是确定性的，例如，但&lt;a href=&quot;../lang_corefunc#randomblob&quot;&gt;randomblob（）&lt;/a&gt;不是。函数必须是确定性的，以便在某些上下文中使用，例如与&lt;a href=&quot;../partialindex&quot;&gt;部分索引&lt;/a&gt;的WHERE子句一起使用或在&lt;a href=&quot;../gencol&quot;&gt;生成的列中使用&lt;/a&gt;。 SQLite还可以通过将确定性函数从内部循环中分解出来来优化确定性函数。</target>
        </trans-unit>
        <trans-unit id="a94dcf703cfcb3aebcafb1d5511712f18433c467" translate="yes" xml:space="preserve">
          <source>The SQLITE_DETERMINISTIC flag means that the new function always gives the same output when the input parameters are the same. The &lt;a href=&quot;lang_corefunc#abs&quot;&gt;abs() function&lt;/a&gt; is deterministic, for example, but &lt;a href=&quot;lang_corefunc#randomblob&quot;&gt;randomblob()&lt;/a&gt; is not. Functions must be deterministic in order to be used in certain contexts such as with the WHERE clause of &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt; or in &lt;a href=&quot;gencol&quot;&gt;generated columns&lt;/a&gt;. SQLite might also optimize deterministic functions by factoring them out of inner loops.</source>
          <target state="translated">SQLITE_DETERMINISTIC标志意味着当输入参数相同时，新函数始终提供相同的输出。的&lt;a href=&quot;lang_corefunc#abs&quot;&gt;ABS（）函数&lt;/a&gt;是确定性的，例如，但&lt;a href=&quot;lang_corefunc#randomblob&quot;&gt;randomblob（）&lt;/a&gt;不是。函数必须是确定性的，以便在某些上下文中使用，例如与&lt;a href=&quot;partialindex&quot;&gt;部分索引&lt;/a&gt;的WHERE子句一起使用或在&lt;a href=&quot;gencol&quot;&gt;生成的列中使用&lt;/a&gt;。 SQLite还可以通过将确定性函数从内部循环中分解出来来优化确定性函数。</target>
        </trans-unit>
        <trans-unit id="a817ebcb8adde635efe8cf6f019a45cbccc77452" translate="yes" xml:space="preserve">
          <source>The SQLITE_DETERMINISTIC flag means that the new function will always maps the same inputs into the same output. The abs() function is deterministic, for example, but randomblob() is not.</source>
          <target state="translated">SQLITE_DETERMINISTIC标志意味着新函数将始终把相同的输入映射成相同的输出。例如,abs()函数是确定性的,但randomblob()不是。</target>
        </trans-unit>
        <trans-unit id="e7795e7dba3d35d408494ba100326feff56ac8bd" translate="yes" xml:space="preserve">
          <source>The SQLITE_DIRECTONLY flag means that the function may only be invoked from top-level SQL, and cannot be used in VIEWs or TRIGGERs nor in schema structures such as &lt;a href=&quot;../lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, &lt;a href=&quot;../lang_createtable#dfltval&quot;&gt;DEFAULT clauses&lt;/a&gt;, &lt;a href=&quot;../expridx&quot;&gt;expression indexes&lt;/a&gt;, &lt;a href=&quot;../partialindex&quot;&gt;partial indexes&lt;/a&gt;, or &lt;a href=&quot;../gencol&quot;&gt;generated columns&lt;/a&gt;. The SQLITE_DIRECTONLY flags is a security feature which is recommended for all &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, and especially for functions that have side-effects or that could potentially leak sensitive information.</source>
          <target state="translated">SQLITE_DIRECTONLY标志意味着该函数只能从顶级SQL调用，并且不能在VIEW或TRIGGER中或架构结构中使用，例如&lt;a href=&quot;../lang_createtable#ckconst&quot;&gt;CHECK约束&lt;/a&gt;，&lt;a href=&quot;../lang_createtable#dfltval&quot;&gt;DEFAULT子句&lt;/a&gt;，&lt;a href=&quot;../expridx&quot;&gt;表达式索引&lt;/a&gt;，&lt;a href=&quot;../partialindex&quot;&gt;部分索引&lt;/a&gt;或&lt;a href=&quot;../gencol&quot;&gt;生成的列&lt;/a&gt;。 SQLITE_DIRECTONLY标志是一项安全功能，建议所有&lt;a href=&quot;../appfunc&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;（尤其是具有副作用或可能泄漏敏感信息的函数）使用此标志。</target>
        </trans-unit>
        <trans-unit id="fbd921523501ad6603970193474c7602b6fd6ef1" translate="yes" xml:space="preserve">
          <source>The SQLITE_DIRECTONLY flag means that the function may only be invoked from top-level SQL, and cannot be used in VIEWs or TRIGGERs nor in schema structures such as &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;DEFAULT clauses&lt;/a&gt;, &lt;a href=&quot;expridx&quot;&gt;expression indexes&lt;/a&gt;, &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;, or &lt;a href=&quot;gencol&quot;&gt;generated columns&lt;/a&gt;. The SQLITE_DIRECTONLY flags is a security feature which is recommended for all &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, and especially for functions that have side-effects or that could potentially leak sensitive information.</source>
          <target state="translated">SQLITE_DIRECTONLY标志意味着该函数只能从顶级SQL调用，并且不能在VIEW或TRIGGER中或架构结构中使用，例如&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK约束&lt;/a&gt;，&lt;a href=&quot;lang_createtable#dfltval&quot;&gt;DEFAULT子句&lt;/a&gt;，&lt;a href=&quot;expridx&quot;&gt;表达式索引&lt;/a&gt;，&lt;a href=&quot;partialindex&quot;&gt;部分索引&lt;/a&gt;或&lt;a href=&quot;gencol&quot;&gt;生成的列&lt;/a&gt;。 SQLITE_DIRECTONLY标志是一项安全功能，建议所有&lt;a href=&quot;appfunc&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;（尤其是具有副作用或可能泄漏敏感信息的函数）使用此标志。</target>
        </trans-unit>
        <trans-unit id="8bfa7a3aa99efd025281e40fa4911eb7511574c2" translate="yes" xml:space="preserve">
          <source>The SQLITE_DIRECTONLY flag means that the function may only be invoked from top-level SQL, and cannot be used in VIEWs or TRIGGERs. This is a security feature which is recommended for all &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; that have side-effects. This flag prevents an attacker from adding triggers and views to a schema then tricking a high-privilege application into causing unintended side-effects while performing ordinary queries.</source>
          <target state="translated">SQLITE_DIRECTONLY标志意味着该函数只能从顶级SQL调用，而不能在VIEW或TRIGGER中使用。这是一项安全功能，建议所有具有副作用的&lt;a href=&quot;#sqlite3_create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;使用。此标志阻止攻击者向架构添加触发器和视图，然后欺骗高特权应用程序在执行普通查询时导致意外的副作用。</target>
        </trans-unit>
        <trans-unit id="ad5270c7d2917dccd93322da5fb7248f9aa949c0" translate="yes" xml:space="preserve">
          <source>The SQLITE_DIRECTONLY flag means that the function may only be invoked from top-level SQL, and cannot be used in VIEWs or TRIGGERs. This is a security feature which is recommended for all &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; that have side-effects. This flag prevents an attacker from adding triggers and views to a schema then tricking a high-privilege application into causing unintended side-effects while performing ordinary queries.</source>
          <target state="translated">SQLITE_DIRECTONLY标志意味着该函数只能从顶级SQL调用，而不能在VIEW或TRIGGER中使用。这是一项安全功能，建议所有具有副作用的&lt;a href=&quot;create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;使用。此标志阻止攻击者向架构添加触发器和视图，然后欺骗高特权应用程序在执行普通查询时导致意外的副作用。</target>
        </trans-unit>
        <trans-unit id="ec40aca0df374578f31a734ba1f44f72205f5695" translate="yes" xml:space="preserve">
          <source>The SQLITE_DONE result code indicates that an operation has completed. The SQLITE_DONE result code is most commonly seen as a return value from &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; indicating that the SQL statement has run to completion. But SQLITE_DONE can also be returned by other multi-step interfaces such as &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt;.</source>
          <target state="translated">SQLITE_DONE结果代码指示操作已完成。SQLITE_DONE结果代码通常被视为来自&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;的返回值，指示SQL语句已运行完毕。但是SQLITE_DONE也可以由其他多步接口（例如&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（））返回&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb790f9dfaacb5c859298fcd4607429394630f86" translate="yes" xml:space="preserve">
          <source>The SQLITE_EMPTY result code is not currently used.</source>
          <target state="translated">目前没有使用SQLITE_EMPTY结果代码。</target>
        </trans-unit>
        <trans-unit id="ae12a93b43b3b42e7d80f8bbf0372c74ffcd4aa7" translate="yes" xml:space="preserve">
          <source>The SQLITE_ENABLE_SELECTTRACE and SQLITE_ENABLE_WHERETRACE options are not documented in &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; document because they are not officially supported. What they do is activate the &quot;.selecttrace&quot; and &quot;.wheretrace&quot; dot-commands in the command-line shell, which provide low-level tracing output for the logic that generates code for SELECT statements and WHERE clauses, respectively.</source>
          <target state="translated">SQLITE_ENABLE_SELECTTRACE和SQLITE_ENABLE_WHERETRACE选项未在&lt;a href=&quot;compile&quot;&gt;编译时选项&lt;/a&gt;文档中记录，因为它们不受官方支持。它们的作用是激活命令行外壳中的&amp;ldquo; .selecttrace&amp;rdquo;和&amp;ldquo; .wheretrace&amp;rdquo;点命令，这两个命令分别为生成用于SELECT语句和WHERE子句的代码的逻辑提供低级跟踪输出。</target>
        </trans-unit>
        <trans-unit id="270e8d29bbaf2c173c8af4cf652d5609825ae163" translate="yes" xml:space="preserve">
          <source>The SQLITE_ERROR result code is a generic error code that is used when no other more specific error code is available.</source>
          <target state="translated">SQLITE_ERROR结果代码是一个通用的错误代码,在没有其他更具体的错误代码时使用。</target>
        </trans-unit>
        <trans-unit id="98c271c04ddb7b453a82bc99e0c9a2f05fc01521" translate="yes" xml:space="preserve">
          <source>The SQLITE_ERROR_MISSING_COLLSEQ result code means that an SQL statement could not be prepared because a collating sequence named in that SQL statement could not be located.</source>
          <target state="translated">SQLITE_ERROR_MISSING_COLLSEQ结果代码意味着,由于无法找到该SQL语句中命名的整理序列,所以无法准备一条SQL语句。</target>
        </trans-unit>
        <trans-unit id="ba8f59027948d8336d219d332d3588711710c0d1" translate="yes" xml:space="preserve">
          <source>The SQLITE_ERROR_RETRY is used internally to provoke &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; (or one of its sibling routines for creating prepared statements) to try again to prepare a statement that failed with an error on the previous attempt.</source>
          <target state="translated">SQLITE_ERROR_RETRY在内部用于引发&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;（或其用于创建准备好的语句的同级例程之一），以再次尝试准备失败的语句，该语句在上一次尝试中出错。</target>
        </trans-unit>
        <trans-unit id="ccb2dd2db61b6baf0b7083d2230974437265ca99" translate="yes" xml:space="preserve">
          <source>The SQLITE_ERROR_SNAPSHOT result code might be returned when attempting to start a read transaction on an historical version of the database by using the &lt;a href=&quot;c3ref/snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface. If the historical snapshot is no longer available, then the read transaction will fail with the SQLITE_ERROR_SNAPSHOT. This error code is only possible if SQLite is compiled with &lt;a href=&quot;compile#enable_snapshot&quot;&gt;-DSQLITE_ENABLE_SNAPSHOT&lt;/a&gt;.</source>
          <target state="translated">尝试通过使用&lt;a href=&quot;c3ref/snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;接口在数据库的历史版本上启动读取事务时，可能返回SQLITE_ERROR_SNAPSHOT结果代码。如果历史快照不再可用，则读取事务将失败，并显示SQLITE_ERROR_SNAPSHOT。仅当使用&lt;a href=&quot;compile#enable_snapshot&quot;&gt;-DSQLITE_ENABLE_SNAPSHOT&lt;/a&gt;编译SQLite时，才可能出现此错误代码。</target>
        </trans-unit>
        <trans-unit id="4cbfe2b69087f0c646cf57766f8596a36d37fac1" translate="yes" xml:space="preserve">
          <source>The SQLITE_EXTRA_DURABLE compile-time option that used to cause the default &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting to be EXTRA, rather than FULL. This option is no longer supported. Use &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS=3&lt;/a&gt; instead.</source>
          <target state="translated">SQLITE_EXTRA_DURABLE编译时选项用于使默认&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt;设置为EXTRA，而不是FULL。不再支持此选项。请改用&lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS = 3&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b13fb7c225046a481ec4f5c3de65895a35d5a534" translate="yes" xml:space="preserve">
          <source>The SQLITE_FORMAT error code is not currently used by SQLite.</source>
          <target state="translated">SQLITE_FORMAT错误代码目前没有被SQLite使用。</target>
        </trans-unit>
        <trans-unit id="26b0edcf7878a4f55c879fd1aba1c1f540342aa6" translate="yes" xml:space="preserve">
          <source>The SQLITE_FULL result code indicates that a write could not complete because the disk is full. Note that this error can occur when trying to write information into the main database file, or it can also occur when writing into &lt;a href=&quot;tempfiles&quot;&gt;temporary disk files&lt;/a&gt;.</source>
          <target state="translated">SQLITE_FULL结果代码指示由于磁盘已满而无法完成写入。请注意，在尝试将信息写入主数据库文件时，可能会发生此错误，或者在写入&lt;a href=&quot;tempfiles&quot;&gt;临时磁盘文件&lt;/a&gt;时，也可能会发生此错误。</target>
        </trans-unit>
        <trans-unit id="52c86e9943e29fd3d57282b842d9c3bedce88e03" translate="yes" xml:space="preserve">
          <source>The SQLITE_HISTORY environment variable, if it exists, specifies the name of the command-line editing history file</source>
          <target state="translated">如果存在SQLITE_HISTORY环境变量,它指定了命令行编辑历史文件的名称</target>
        </trans-unit>
        <trans-unit id="e10c2e4fcb65972fbd71d50bdb5c4ac5d88e54e7" translate="yes" xml:space="preserve">
          <source>The SQLITE_INNOCUOUS flag means that the function is unlikely to cause problems even if misused. An innocuous function should have no side effects and should not depend on any values other than its input parameters. The &lt;a href=&quot;../lang_corefunc#abs&quot;&gt;abs() function&lt;/a&gt; is an example of an innocuous function. The &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension() SQL function&lt;/a&gt; is not innocuous because of its side effects.</source>
          <target state="translated">SQLITE_INNOCUOUS标志意味着该函数即使被滥用也不太可能引起问题。一个无害的函数应该没有副作用，并且除了其输入参数外，不应该依赖于其他任何值。的&lt;a href=&quot;../lang_corefunc#abs&quot;&gt;ABS（）函数&lt;/a&gt;是一个函数无害的一个例子。由于有&lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;副作用，&lt;/a&gt;因此load_extension（）SQL函数不是无害的。</target>
        </trans-unit>
        <trans-unit id="a3a2b2609c215ba1aae8c191414849f564b054dd" translate="yes" xml:space="preserve">
          <source>The SQLITE_INNOCUOUS flag means that the function is unlikely to cause problems even if misused. An innocuous function should have no side effects and should not depend on any values other than its input parameters. The &lt;a href=&quot;lang_corefunc#abs&quot;&gt;abs() function&lt;/a&gt; is an example of an innocuous function. The &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension() SQL function&lt;/a&gt; is not innocuous because of its side effects.</source>
          <target state="translated">SQLITE_INNOCUOUS标志意味着该函数即使被滥用也不太可能引起问题。一个无害的函数应该没有副作用，并且除了其输入参数外，不应该依赖于其他任何值。的&lt;a href=&quot;lang_corefunc#abs&quot;&gt;ABS（）函数&lt;/a&gt;是一个函数无害的一个例子。由于有&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;副作用，&lt;/a&gt;因此load_extension（）SQL函数不是无害的。</target>
        </trans-unit>
        <trans-unit id="521e2762edbf8211c7cbb9d7bfb58da8a1f086c6" translate="yes" xml:space="preserve">
          <source>The SQLITE_INTERNAL result code indicates an internal malfunction. In a working version of SQLite, an application should never see this result code. If application does encounter this result code, it shows that there is a bug in the database engine.</source>
          <target state="translated">SQLITE_INTERNAL结果代码表示内部故障。在SQLite的工作版本中,应用程序不应该看到这个结果代码。如果应用程序确实遇到了这个结果代码,则表明数据库引擎中存在一个错误。</target>
        </trans-unit>
        <trans-unit id="b38d579654b4f1182c07a8a6f5867deba9d19d28" translate="yes" xml:space="preserve">
          <source>The SQLITE_INTERRUPT result code indicates that an operation was interrupted by the &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; interface. See also: &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;</source>
          <target state="translated">SQLITE_INTERRUPT结果代码指示操作被&lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt（）&lt;/a&gt;接口中断。另请参阅：&lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c1b9bcba49ffcf44baa9a43853834f3537e3646" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOCAP_ATOMIC property means that all writes of any size are atomic. The SQLITE_IOCAP_ATOMICnnn values mean that writes of blocks that are nnn bytes in size and are aligned to an address which is an integer multiple of nnn are atomic. The SQLITE_IOCAP_SAFE_APPEND value means that when data is appended to a file, the data is appended first then the size of the file is extended, never the other way around. The SQLITE_IOCAP_SEQUENTIAL property means that information is written to disk in the same order as calls to xWrite().</source>
          <target state="translated">SQLITE_IOCAP_ATOMIC 属性意味着任何大小的写入都是原子的。SQLITE_IOCAP_ATOMICnnn 值意味着大小为 nnn 字节的块的写入是原子的,并且对齐的地址是 nnn 的整数倍。SQLITE_IOCAP_SAFE_APPEND值是指当数据被追加到文件时,先追加数据,然后再扩展文件的大小,绝不能反过来。SQLITE_IOCAP_SEQUENTIAL属性意味着信息写入磁盘的顺序与调用xWrite()的顺序相同。</target>
        </trans-unit>
        <trans-unit id="6cfdb556dc4a2d2c3aee5156579c0505409a3242" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOCAP_ATOMIC property means that all writes of any size are atomic. The SQLITE_IOCAP_ATOMICnnn values mean that writes of blocks that are nnn bytes in size and are aligned to an address which is an integer multiple of nnn are atomic. The SQLITE_IOCAP_SAFE_APPEND value means that when data is appended to a file, the data is appended first then the size of the file is extended, never the other way around. The SQLITE_IOCAP_SEQUENTIAL property means that information is written to disk in the same order as calls to xWrite(). The SQLITE_IOCAP_POWERSAFE_OVERWRITE property means that after reboot following a crash or power loss, the only bytes in a file that were written at the application level might have changed and that adjacent bytes, even bytes within the same sector are guaranteed to be unchanged. The SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN flag indicates that a file cannot be deleted when open. The SQLITE_IOCAP_IMMUTABLE flag indicates that the file is on read-only media and cannot be changed even by processes with elevated privileges.</source>
          <target state="translated">SQLITE_IOCAP_ATOMIC 属性意味着任何大小的写入都是原子的。SQLITE_IOCAP_ATOMICnnn 值意味着大小为 nnn 字节的块的写入是原子的,并且对齐的地址是 nnn 的整数倍。SQLITE_IOCAP_SAFE_APPEND值是指当数据被追加到文件时,先追加数据,然后再扩展文件的大小,绝不能反过来。SQLITE_IOCAP_SEQUENTIAL属性意味着信息写入磁盘的顺序与调用xWrite()的顺序相同。SQLITE_IOCAP_POWERSAFE_OVERWRITE 属性意味着在崩溃或断电后重启后,文件中只有在应用层写入的字节可能发生了变化,相邻的字节,甚至同一扇区内的字节都保证不变。SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN标志表示文件打开后不能删除。SQLITE_IOCAP_IMMUTABLE标志表示文件是在只读介质上的,即使是具有高权限的进程也不能更改。</target>
        </trans-unit>
        <trans-unit id="d6e9041084560f5cee1cd0f7e8b2669a77b404b5" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOCAP_BATCH_ATOMIC property means that the underlying filesystem supports doing multiple write operations atomically when those write operations are bracketed by &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; and &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">SQLITE_IOCAP_BATCH_ATOMIC属性意味着当这些写操作由&lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;和&lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;括起来时，基础文件系统支持原子地执行多个写操作。</target>
        </trans-unit>
        <trans-unit id="7cb11acb1c9a7effbe4c566606f90f111aeaa51c" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOCAP_BATCH_ATOMIC property means that the underlying filesystem supports doing multiple write operations atomically when those write operations are bracketed by &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; and &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">SQLITE_IOCAP_BATCH_ATOMIC属性意味着当这些写操作由&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;和&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;括起来时，基础文件系统支持原子地执行多个写操作。</target>
        </trans-unit>
        <trans-unit id="abba910b15531d36f82588d451d0981d7b760afc" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR result code says that the operation could not finish because the operating system reported an I/O error.</source>
          <target state="translated">SQLITE_IOERR结果代码说,由于操作系统报告了一个I/O错误,操作无法完成。</target>
        </trans-unit>
        <trans-unit id="6217042802c9b2c3161cf544abc5162c5330d1de" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_ACCESS error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xAccess method on the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object.</source>
          <target state="translated">所述SQLITE_IOERR_ACCESS错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;指示在Xaccess文件方法内的I / O错误&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="e2437ab6f22990f68cc3c6b6ab11345e11bf39ab" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_ACCESS error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xClose method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">所述SQLITE_IOERR_ACCESS错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;指示在xClose方法内的I / O错误&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="5e0766e0ad5122ce2e894ae19847fb8e9f46607a" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_AUTH error code is a code reserved for use by extensions. It is not used by the SQLite core.</source>
          <target state="translated">SQLITE_IOERR_AUTH错误代码是一个保留给扩展使用的代码。它不被SQLite核心使用。</target>
        </trans-unit>
        <trans-unit id="58b4888a031f974ca3ca743e47debc76f950a161" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_BEGIN_ATOMIC error code indicates that the underlying operating system reported and error on the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; file-control. This only comes up when &lt;a href=&quot;compile#enable_atomic_write&quot;&gt;SQLITE_ENABLE_ATOMIC_WRITE&lt;/a&gt; is enabled and the database is hosted on a filesystem that supports atomic writes.</source>
          <target state="translated">SQLITE_IOERR_BEGIN_ATOMIC错误代码指示底层操作系统已报告并且&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;文件控件上存在错误。仅当启用&lt;a href=&quot;compile#enable_atomic_write&quot;&gt;SQLITE_ENABLE_ATOMIC_WRITE&lt;/a&gt;且数据库托管在支持原子写入的文件系统上时，才会出现此消息。</target>
        </trans-unit>
        <trans-unit id="d2cdfe432186a7333ec15fb6eebac01e4168d421" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_BLOCKED error code is no longer used.</source>
          <target state="translated">不再使用SQLITE_IOERR_BLOCKED错误代码。</target>
        </trans-unit>
        <trans-unit id="d52b5d2e176049b701cd38566a1ec537e178a582" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_CHECKRESERVEDLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xCheckReservedLock method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">所述SQLITE_IOERR_CHECKRESERVEDLOCK错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;指示在xCheckReservedLock方法内的I / O错误&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="75047d8232598430d959bcebd12e0cf939786ffa" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_COMMIT_ATOMIC error code indicates that the underlying operating system reported and error on the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; file-control. This only comes up when &lt;a href=&quot;compile#enable_atomic_write&quot;&gt;SQLITE_ENABLE_ATOMIC_WRITE&lt;/a&gt; is enabled and the database is hosted on a filesystem that supports atomic writes.</source>
          <target state="translated">SQLITE_IOERR_COMMIT_ATOMIC错误代码指示基础操作系统已报告并且&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;文件控件上存在错误。仅当启用&lt;a href=&quot;compile#enable_atomic_write&quot;&gt;SQLITE_ENABLE_ATOMIC_WRITE&lt;/a&gt;且数据库托管在支持原子写入的文件系统上时，才会出现此消息。</target>
        </trans-unit>
        <trans-unit id="0ad717c7b1ad0bbb8f95440fa25c68effa605b2e" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_CONVPATH error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; used only by Cygwin &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; and indicating that the cygwin_conv_path() system call failed. See also: &lt;a href=&quot;rescode#cantopen_convpath&quot;&gt;SQLITE_CANTOPEN_CONVPATH&lt;/a&gt;</source>
          <target state="translated">所述SQLITE_IOERR_CONVPATH错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;使用仅由Cygwin的&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;和指示cygwin_conv_path（）系统调用失败。另请参阅：&lt;a href=&quot;rescode#cantopen_convpath&quot;&gt;SQLITE_CANTOPEN_CONVPATH&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="13cb3347731704999ce485ae2e2aa6f881f8a33c" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_DATA error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; used only by &lt;a href=&quot;cksumvfs&quot;&gt;checksum VFS shim&lt;/a&gt; to indicate that the checksum on a page of the database file is incorrect.</source>
          <target state="translated">该SQLITE_IOERR_DATA错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;仅用于&lt;a href=&quot;cksumvfs&quot;&gt;校验和VFS垫片&lt;/a&gt;，以表明该数据库文件的页上的校验和不正确。</target>
        </trans-unit>
        <trans-unit id="a1351f2d6333fe014b3d2efb02bea78fd2458ea8" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_DELETE_NOENT error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating that the xDelete method on the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object failed because the file being deleted does not exist.</source>
          <target state="translated">所述SQLITE_IOERR_DELETE_NOENT错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;指示在所述xDelete方法&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象失败因为要删除的文件不存在。</target>
        </trans-unit>
        <trans-unit id="3d4ef8736b02588e9ecd702311e3b92f76c71f42" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_DIR_CLOSE error code is no longer used.</source>
          <target state="translated">SQLITE_IOERR_DIR_CLOSE错误代码不再使用。</target>
        </trans-unit>
        <trans-unit id="257039837e1e28ae4885f94438deef37c72bcb03" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_DIR_FSYNC error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to invoke fsync() on a directory. The unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; attempts to fsync() directories after creating or deleting certain files to ensure that those files will still appear in the filesystem following a power loss or system crash. This error code indicates a problem attempting to perform that fsync().</source>
          <target state="translated">所述SQLITE_IOERR_DIR_FSYNC错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;指示在一个I / O错误&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;层，而上的目录试图调用FSYNC（）。 UNIX &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;在创建或删除某些文件后尝试对fsync（）目录进行操作，以确保在断电或系统崩溃后，这些文件仍将出现在文件系统中。此错误代码指示尝试执行该fsync（）的问题。</target>
        </trans-unit>
        <trans-unit id="703a40890c81baa50195428ead914670c8029bb4" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_FSTAT error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to invoke fstat() (or the equivalent) on a file in order to determine information such as the file size or access permissions.</source>
          <target state="translated">所述SQLITE_IOERR_FSTAT错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;指示在一个I / O错误&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;层，同时为了确定的信息上的文件试图调用FSTAT（）（或等价物），诸如文件大小或访问权限。</target>
        </trans-unit>
        <trans-unit id="4411956ede5824f9653b6f7288932d4d59a1407a" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_FSYNC error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to flush previously written content out of OS and/or disk-control buffers and into persistent storage. In other words, this code indicates a problem with the fsync() system call in unix or the FlushFileBuffers() system call in windows.</source>
          <target state="translated">所述SQLITE_IOERR_FSYNC错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;指示在一个I / O错误&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;层而试图刷新先前写入的内容进行OS和/或磁盘的控制缓冲器，并进入持久存储。换句话说，此代码表示UNIX中的fsync（）系统调用或Windows中的FlushFileBuffers（）系统调用存在问题。</target>
        </trans-unit>
        <trans-unit id="1a80a6afbc34a7c330788ef9f803a0b5991e12c1" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_GETTEMPPATH error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating that the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; is unable to determine a suitable directory in which to place temporary files.</source>
          <target state="translated">所述SQLITE_IOERR_GETTEMPPATH错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;指示&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;是无法确定在其中放置临时文件合适的目录。</target>
        </trans-unit>
        <trans-unit id="cb09e15d8dd94c07c078d48b512a0e609b4a1ec7" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_LOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the advisory file locking logic. Usually an SQLITE_IOERR_LOCK error indicates a problem obtaining a &lt;a href=&quot;lockingv3#pending_lock&quot;&gt;PENDING lock&lt;/a&gt;. However it can also indicate miscellaneous locking errors on some of the specialized &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; used on Macs.</source>
          <target state="translated">所述SQLITE_IOERR_LOCK错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;指示在咨询文件锁定逻辑的I / O错误。通常，SQLITE_IOERR_LOCK错误指示获取&lt;a href=&quot;lockingv3#pending_lock&quot;&gt;PENDING锁时&lt;/a&gt;出现问题。但是，它也可能表示在Mac 上使用的某些专用&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;上的其他锁定错误。</target>
        </trans-unit>
        <trans-unit id="928b9fb773e51d9b98d4eea6c5ad41e7a120edb9" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_MMAP error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xFetch or xUnfetch methods on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to map or unmap part of the database file into the process address space.</source>
          <target state="translated">所述SQLITE_IOERR_MMAP错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;用于&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;指示一个I / O错误内对所述xFetch或xUnfetch方法&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;而试图映射或数据库文件到进程的地址空间的一部分去映射对象。</target>
        </trans-unit>
        <trans-unit id="f2e769d752ed0575abbf0db74e042a1d936197ca" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_NOMEM error code is sometimes returned by the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer to indicate that an operation could not be completed due to the inability to allocate sufficient memory. This error code is normally converted into &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; by the higher layers of SQLite before being returned to the application.</source>
          <target state="translated">&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;层有时会返回SQLITE_IOERR_NOMEM错误代码，以指示由于无法分配足够的内存而无法完成操作。该错误代码通常在返回到应用程序之前由更高级别的SQLite 转换为&lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8545169dd7924f6c6604c36309fb09b48638942a" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_READ error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to read from a file on disk. This error might result from a hardware malfunction or because a filesystem came unmounted while the file was open.</source>
          <target state="translated">所述SQLITE_IOERR_READ错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;指示在一个I / O错误&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;层，而试图从磁盘上的文件中读取。此错误可能是由于硬件故障或由于打开文件时卸载文件系统引起的。</target>
        </trans-unit>
        <trans-unit id="65ee87d5abb54374d1fb646d72a2b9a7d9725bd5" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_ROLLBACK_ATOMIC error code indicates that the underlying operating system reported and error on the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; file-control. This only comes up when &lt;a href=&quot;compile#enable_atomic_write&quot;&gt;SQLITE_ENABLE_ATOMIC_WRITE&lt;/a&gt; is enabled and the database is hosted on a filesystem that supports atomic writes.</source>
          <target state="translated">SQLITE_IOERR_ROLLBACK_ATOMIC错误代码指示底层操作系统已报告并且&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt;文件控件上存在错误。仅当启用&lt;a href=&quot;compile#enable_atomic_write&quot;&gt;SQLITE_ENABLE_ATOMIC_WRITE&lt;/a&gt;且数据库托管在支持原子写入的文件系统上时，才会出现此消息。</target>
        </trans-unit>
        <trans-unit id="1b973a2eb159aa040eee4609af08e2a1feaa8688" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SEEK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xRead or xWrite methods on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to seek a file descriptor to the beginning point of the file where the read or write is to occur.</source>
          <target state="translated">所述SQLITE_IOERR_SEEK错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;指示所述的xRead或xWrite方法内的I / O错误&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;而试图寻求一个文件描述符到所读出或写入是发生在文件的开头点对象。</target>
        </trans-unit>
        <trans-unit id="105abf471dd5b51825236d9c7cd0fbb3eb6cb7cd" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHMLOCK error code is no longer used.</source>
          <target state="translated">SQLITE_IOERR_SHMLOCK错误代码不再使用。</target>
        </trans-unit>
        <trans-unit id="19454e66c26708e9c7b0cf7de58d9fc407f5f14b" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHMMAP error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xShmMap method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to map a shared memory segment into the process address space.</source>
          <target state="translated">所述SQLITE_IOERR_SHMMAP错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;指示xShmMap方法在内的I / O错误&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;而试图映射的共享存储器段到进程地址空间物体。</target>
        </trans-unit>
        <trans-unit id="2dc7d56b93948bb563eb131a1d4f4001df7a785f" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHMOPEN error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xShmMap method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to open a new shared memory segment.</source>
          <target state="translated">所述SQLITE_IOERR_SHMOPEN错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;指示xShmMap方法在内的I / O错误&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;在尝试打开新的共享存储器段对象。</target>
        </trans-unit>
        <trans-unit id="38683c7c8ec002f5c2268623f613c65a832d0744" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHMSIZE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xShmMap method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to enlarge a &lt;a href=&quot;walformat#shm&quot;&gt;&quot;shm&quot; file&lt;/a&gt; as part of &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; transaction processing. This error may indicate that the underlying filesystem volume is out of space.</source>
          <target state="translated">所述SQLITE_IOERR_SHMSIZE错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;指示xShmMap方法在内的I / O错误&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;而试图放大一个对象&lt;a href=&quot;walformat#shm&quot;&gt;&amp;ldquo;SHM&amp;rdquo;文件&lt;/a&gt;作为其一部分&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;事务处理。该错误可能表明基础文件系统卷空间不足。</target>
        </trans-unit>
        <trans-unit id="9742197ad61d509380008ae49be67afbc4a5ec72" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHORT_READ error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating that a read attempt in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer was unable to obtain as many bytes as was requested. This might be due to a truncated file.</source>
          <target state="translated">所述SQLITE_IOERR_SHORT_READ错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;表明在读取尝试&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;层无法为被请求以获得尽可能多的字节。这可能是由于文件被截断了。</target>
        </trans-unit>
        <trans-unit id="11a04eeb47de957ef3978cba210956d9cb5d652c" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_TRUNCATE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to truncate a file to a smaller size.</source>
          <target state="translated">所述SQLITE_IOERR_TRUNCATE错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;指示在一个I / O错误&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;层在尝试将文件截断到较小尺寸。</target>
        </trans-unit>
        <trans-unit id="fea43ead41e3ee8f14dc4f738a5d86af22fa9867" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_UNLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within xDelete method on the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object.</source>
          <target state="translated">所述SQLITE_IOERR_UNLOCK错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;指示上xDelete方法内的I / O错误&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="0b74fa52836b69d8f9666b0cd822fdd7307145f4" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_UNLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within xLock method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to obtain a read lock.</source>
          <target state="translated">所述SQLITE_IOERR_UNLOCK错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;指示XLOCK方法内的I / O错误在&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;而试图得到一个读锁定对象。</target>
        </trans-unit>
        <trans-unit id="c346b35d66f482df6af0e3e742d33c4546a4dc99" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_UNLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within xUnlock method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">所述SQLITE_IOERR_UNLOCK错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;指示上xUnlock方法内的I / O错误&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="6113814aa478402ab154991dc3d13df0e7b55c87" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_VNODE error code is a code reserved for use by extensions. It is not used by the SQLite core.</source>
          <target state="translated">SQLITE_IOERR_VNODE错误代码是一个保留给扩展使用的代码。它不被SQLite核心使用。</target>
        </trans-unit>
        <trans-unit id="7f8d955a87bc68c4a0c5a3d4a1efee03acc84572" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_WRITE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to write into a file on disk. This error might result from a hardware malfunction or because a filesystem came unmounted while the file was open. This error should not occur if the filesystem is full as there is a separate error code (SQLITE_FULL) for that purpose.</source>
          <target state="translated">所述SQLITE_IOERR_WRITE错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;指示在一个I / O错误&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;层而试图写入到磁盘上的文件。此错误可能是由于硬件故障或由于打开文件时卸载文件系统引起的。如果文件系统已满，则不应发生此错误，因为为此有单独的错误代码（SQLITE_FULL）。</target>
        </trans-unit>
        <trans-unit id="81a8e9c53d139815a64f5839604fdd22fadaa0e7" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED result code differs from &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; in that SQLITE_LOCKED indicates a conflict on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; (or on a connection with a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;) whereas &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; indicates a conflict with a different database connection, probably in a different process.</source>
          <target state="translated">SQLITE_LOCKED结果代码与&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY的&lt;/a&gt;不同之处在于，SQLITE_LOCKED表示同一&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;（或与&lt;a href=&quot;sharedcache&quot;&gt;共享缓存&lt;/a&gt;的连接）上的冲突，而&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;表示与其他数据库连接的冲突（可能在不同的过程中）。</target>
        </trans-unit>
        <trans-unit id="a782dd7cfb6d09bfdc0225cdd7b256e70fd078f6" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED result code indicates that a write operation could not continue because of a conflict within the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; or a conflict with a different database connection that uses a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;.</source>
          <target state="translated">SQLITE_LOCKED结果代码指示由于同一&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;内的冲突或与使用&lt;a href=&quot;sharedcache&quot;&gt;共享缓存&lt;/a&gt;的其他数据库连接冲突而导致写操作无法继续。</target>
        </trans-unit>
        <trans-unit id="82a5261f187f8bb18f86e6b8f8f93ccb09c0a9f0" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED_SHARECACHE error code works very much like the &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error code except that SQLITE_LOCKED_SHARECACHE is for separate database connections that share a cache whereas SQLITE_BUSY is for the much more common case of separate database connections that do not share the same cache. Also, the &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt; and &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; interfaces do not help in resolving SQLITE_LOCKED_SHAREDCACHE conflicts.</source>
          <target state="translated">SQLITE_LOCKED_SHARECACHE错误代码的工作方式与&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;错误代码非常相似，不同之处在于SQLITE_LOCKED_SHARECACHE用于共享缓存的单独数据库连接，而SQLITE_BUSY用于更常见的不共享同一缓存的单独数据库连接。另外，&lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler（）&lt;/a&gt;和&lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;接口也无助于解决SQLITE_LOCKED_SHAREDCACHE冲突。</target>
        </trans-unit>
        <trans-unit id="43736bf56a426c4b58c2bec90f4d48ac9099897c" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED_SHAREDCACHE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; indicating that the locking conflict has occurred due to contention with a different &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; that happens to hold a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; with the database connection to which the error was returned. For example, if the other database connection is holding an &lt;a href=&quot;lockingv3#excl_lock&quot;&gt;exclusive lock&lt;/a&gt; on the database, then the database connection that receives this error will be unable to read or write any part of the database file unless it has the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; enabled.</source>
          <target state="translated">该SQLITE_LOCKED_SHAREDCACHE错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;指示锁定冲突发生因争用不同&lt;a href=&quot;c3ref/sqlite3&quot;&gt;的数据库连接&lt;/a&gt;，恰好持有&lt;a href=&quot;sharedcache&quot;&gt;共享缓存&lt;/a&gt;与到返回错误的数据库连接。例如，如果另一个数据库连接对数据库持有&lt;a href=&quot;lockingv3#excl_lock&quot;&gt;排他锁&lt;/a&gt;，则收到此错误的数据库连接将无法读取或写入数据库文件的任何部分，除非已启用&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted编译指示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="505ef007b21d3290ab23365bc989fb6e986ffd9d" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED_SHAREDCACHE result code indicates that access to an SQLite data record is blocked by another database connection that is using the same record in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;. When two or more database connections share the same cache and one of the connections is in the middle of modifying a record in that cache, then other connections are blocked from accessing that data while the modifications are on-going in order to prevent the readers from seeing a corrupt or partially completed change.</source>
          <target state="translated">SQLITE_LOCKED_SHAREDCACHE结果代码指示在&lt;a href=&quot;sharedcache&quot;&gt;共享缓存模式下&lt;/a&gt;，使用同一记录的另一个数据库连接阻止了对SQLite数据记录的访问。当两个或多个数据库连接共享相同的缓存，并且其中一个连接正在修改该缓存中的记录时，则在进行修改的同时，其他连接将被阻止访问该数据，以防止读取器看到已损坏或部分完成的更改。</target>
        </trans-unit>
        <trans-unit id="3cda10b684d70e57b826f0fa4c4df09ccba017aa" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED_VTAB result code is not used by the SQLite core, but it is available for use by extensions. Virtual table implementations can return this result code to indicate that they cannot complete the current operation because of locks held by other threads or processes.</source>
          <target state="translated">SQLITE_LOCKED_VTAB结果代码不被SQLite核心使用,但它可以被扩展使用。虚拟表实现可以返回这个结果代码来表示由于其他线程或进程持有锁而无法完成当前操作。</target>
        </trans-unit>
        <trans-unit id="e51cbf2f4ccfc41ba0ad01c890bead2935bfa934" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCK_EXCLUSIVE lock must be held by a connection that wants to transition into our out of WAL mode. Transitioning into WAL mode is, therefore, just like any other write transaction, since every write transaction in rollback mode requires the SQLITE_LOCK_EXCLUSIVE lock. If the database file is already in WAL mode (hence if the desire it to change it back into rollback mode) and if there are two or more connections to the database, then each of these connections will be holding an SQLITE_LOCK_SHARED lock. That means that the SQLITE_LOCK_EXCLUSIVE cannot be obtained, and the transition out of WAL mode will not be allowed. This prevents one connection from deleting WAL mode out from under another. It also means that the only way to move a database from WAL mode into rollback mode is to close all but one connection to the database.</source>
          <target state="translated">SQLITE_LOCK_EXCLUSIVE锁必须由一个想要过渡到我们的出WAL模式的连接持有。因此,过渡到WAL模式就像任何其他写事务一样,因为回滚模式下的每个写事务都需要SQLITE_LOCK_EXCLUSIVE锁。如果数据库文件已经处于WAL模式(因此如果希望它改回回滚模式),而且如果有两个或更多的连接到数据库,那么这些连接中的每一个都将持有一个SQLITE_LOCK_SHARED锁。这意味着无法获得SQLITE_LOCK_EXCLUSIVE,也就不允许过渡出WAL模式。这就防止了一个连接从另一个连接下删除WAL模式出来。这也意味着,将数据库从WAL模式转入回滚模式的唯一方法是关闭数据库的所有连接,但不是一个连接。</target>
        </trans-unit>
        <trans-unit id="bc70544c321ca8a14f098bcf8a7d9ab71f0f189a" translate="yes" xml:space="preserve">
          <source>The SQLITE_MAX_COLUMN compile-time parameter is used to set an upper bound on:</source>
          <target state="translated">SQLITE_MAX_COLUMN编译时参数用于设置上限。</target>
        </trans-unit>
        <trans-unit id="6525988f532e320cb712d12a43eb0921bdec4dc2" translate="yes" xml:space="preserve">
          <source>The SQLITE_MAX_EXPR_DEPTH parameter determines the maximum expression tree depth. If the value is 0, then no limit is enforced. The current implementation has a default value of 1000.</source>
          <target state="translated">SQLITE_MAX_EXPR_DEPTH参数决定了表达式树的最大深度。如果该值为0,则不执行限制。当前实现的默认值为1000。</target>
        </trans-unit>
        <trans-unit id="87bafa8316c35e0283e8d900b37b61b6cd965c07" translate="yes" xml:space="preserve">
          <source>The SQLITE_MAX_FUNCTION_ARG parameter determines the maximum number of parameters that can be passed to an SQL function. The default value of this limit is 100. SQLite should work with functions that have thousands of parameters. However, we suspect that anybody who tries to invoke a function with more than a few parameters is really trying to find security exploits in systems that use SQLite, not do useful work, and so for that reason we have set this parameter relatively low.</source>
          <target state="translated">SQLITE_MAX_FUNCTION_ARG参数决定了可以传递给一个SQL函数的最大参数数。这个限制的默认值是100。SQLite应该可以使用有数千个参数的函数。但是,我们怀疑,任何人试图调用一个参数多于几个的函数,其实是想在使用SQLite的系统中寻找安全漏洞,而不是做有用的工作,因此,出于这个原因,我们把这个参数设置得比较低。</target>
        </trans-unit>
        <trans-unit id="189922ac7fd95f7c9bc12f9ce7e9ab04f1adf79f" translate="yes" xml:space="preserve">
          <source>The SQLITE_MAX_PAGE_SIZE compile-time option is now silently ignored. The maximum page size is hard-coded at 65536 bytes.</source>
          <target state="translated">SQLITE_MAX_PAGE_SIZE 编译时选项现在被默默地忽略了。最大页面大小被硬编码为65536字节。</target>
        </trans-unit>
        <trans-unit id="862c9c40eeff1a20092e93732416f94a8f2c333f" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMDEBUG option causes an instrumented &lt;a href=&quot;malloc#memdebug&quot;&gt;debugging memory allocator&lt;/a&gt; to be used as the default memory allocator within SQLite. The instrumented memory allocator checks for misuse of dynamically allocated memory. Examples of misuse include using memory after it is freed, writing off the ends of a memory allocation, freeing memory not previously obtained from the memory allocator, or failing to initialize newly allocated memory.</source>
          <target state="translated">SQLITE_MEMDEBUG选项使检测到的&lt;a href=&quot;malloc#memdebug&quot;&gt;调试内存分配器&lt;/a&gt;用作SQLite中的默认内存分配器。检测的内存分配器检查动态分配的内存是否被滥用。滥用的示例包括释放内存后使用内存，注销内存分配的末尾，释放先前未从内存分配器获得的内存或无法初始化新分配的内存。</target>
        </trans-unit>
        <trans-unit id="d5d3984ec504895ac3fbb00da3cebcbba9dedbe7" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMSTAT Virtual Table</source>
          <target state="translated">SQLITE_MEMSTAT虚拟表</target>
        </trans-unit>
        <trans-unit id="21d4cb84411a45f761656443b3561b46a357ff18" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMSTAT extension implements an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt; that provides SQL access to the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; and &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interfaces.</source>
          <target state="translated">SQLITE_MEMSTAT扩展实现了一个&lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;仅&lt;/a&gt;使用别名的虚拟表，该表提供对&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64（）&lt;/a&gt;和&lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;接口的SQL访问。</target>
        </trans-unit>
        <trans-unit id="aad795204ac31f320600f752e689de3d922a2bd2" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMSTAT table appears to have the following schema:</source>
          <target state="translated">SQLITE_MEMSTAT表似乎有以下模式。</target>
        </trans-unit>
        <trans-unit id="c5c71018abf94b8f9efc3c61940d93dd9b424da6" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMSTAT virtual table is a read-only table that can be queried to determine performance characteristics (primarily the amount of memory being used) of the current instance of SQLite. The SQLITE_MEMSTATE table is essentially a wrapper around the C-language APIs &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; and &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt;. If the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/memstat.c&quot;&gt;memstat.c&lt;/a&gt; source file is compiled with the -DSQLITE_ENABLE_ZIPVFS option, then SQLITE_MEMSTAT will also do some &lt;a href=&quot;c3ref/file_control&quot;&gt;file-control&lt;/a&gt; calls to extract memory usage information about the &lt;a href=&quot;https://www.hwaci.com/sw/sqlite/zipvfs.html&quot;&gt;ZIPVFS&lt;/a&gt; subsystem, if that subsystem as been licensed, installed, and is in use.</source>
          <target state="translated">SQLITE_MEMSTAT虚拟表是一个只读表，可以查询该表以确定SQLite当前实例的性能特征（主要是正在使用的内存量）。 SQLITE_MEMSTATE表本质上是C语言API &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64（）&lt;/a&gt;和&lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;的包装。如果使用-DSQLITE_ENABLE_ZIPVFS选项编译了&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/memstat.c&quot;&gt;memstat.c&lt;/a&gt;源文件，则SQLITE_MEMSTAT还将执行一些&lt;a href=&quot;c3ref/file_control&quot;&gt;文件控制&lt;/a&gt;调用，以提取有关&lt;a href=&quot;https://www.hwaci.com/sw/sqlite/zipvfs.html&quot;&gt;ZIPVFS&lt;/a&gt;子系统的内存使用信息（如果该子系统已获得许可，已安装并正在使用）。</target>
        </trans-unit>
        <trans-unit id="3941fc28dfa25db6c38115ec794332d498f61a67" translate="yes" xml:space="preserve">
          <source>The SQLITE_MISMATCH error code indicates a datatype mismatch.</source>
          <target state="translated">SQLITE_MISMATCH错误代码表示数据类型不匹配。</target>
        </trans-unit>
        <trans-unit id="545fecc55ea90185cbbd63fd3b5f04d2c005fc32" translate="yes" xml:space="preserve">
          <source>The SQLITE_MISUSE return code might be returned if the application uses any SQLite interface in a way that is undefined or unsupported. For example, using a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; after that prepared statement has been &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt; might result in an SQLITE_MISUSE error.</source>
          <target state="translated">如果应用程序以未定义或不受支持的方式使用任何SQLite接口，则可能返回SQLITE_MISUSE返回代码。例如，在该准备好的语句&lt;a href=&quot;c3ref/finalize&quot;&gt;完成&lt;/a&gt;之后使用&lt;a href=&quot;c3ref/stmt&quot;&gt;准备&lt;/a&gt;好的语句可能会导致SQLITE_MISUSE错误。</target>
        </trans-unit>
        <trans-unit id="7378cf4ec519f0105a315e8c418689ed2c8b9d03" translate="yes" xml:space="preserve">
          <source>The SQLITE_MUTEX_APPDEF compile-time option is no longer supported. Alternative mutex implementations can now be added at run-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface with the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; verb. *** Potentially incompatible change ***</source>
          <target state="translated">不再支持SQLITE_MUTEX_APPDEF编译时选项。现在可以在运行时使用带有&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt;动词的&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;接口添加替代的互斥量实现。***可能不兼容的更改***</target>
        </trans-unit>
        <trans-unit id="b652223c3c3d5b396101734631bda4e93654d297" translate="yes" xml:space="preserve">
          <source>The SQLITE_MUTEX_APPDEF compile-time parameter is no longer recognized. As a replacement, alternative &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;mutex implementations&lt;/a&gt; may be created at runtime using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; with the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; operator and the &lt;a href=&quot;c3ref/mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; object.</source>
          <target state="translated">不再识别SQLITE_MUTEX_APPDEF编译时参数。作为替代，可以在运行时使用带有&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt;运算符和&lt;a href=&quot;c3ref/mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt;对象的&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;创建替代的&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;互斥锁实现&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2c0584076e7e10d1a5a608c7c90ebdabce289b7" translate="yes" xml:space="preserve">
          <source>The SQLITE_MUTEX_NOOP implementation is a set of routines that does no real locking and is appropriate for use in a single-threaded application. The SQLITE_MUTEX_PTHREADS and SQLITE_MUTEX_W32 implementations are appropriate for use on Unix and Windows.</source>
          <target state="translated">SQLITE_MUTEX_NOOP实现是一组没有真正锁定的例程,适合在单线程应用程序中使用。SQLITE_MUTEX_PTHREADS和SQLITE_MUTEX_W32实现适合在Unix和Windows上使用。</target>
        </trans-unit>
        <trans-unit id="8dd7fbf941fcd0cbf4106dee4f6ff2100d3cc081" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOLFS error can be returned on systems that do not support large files when the database grows to be larger than what the filesystem can handle. &quot;NOLFS&quot; stands for &quot;NO Large File Support&quot;.</source>
          <target state="translated">在不支持大文件的系统上,当数据库增长到超过文件系统所能处理的范围时,会返回SQLITE_NOLFS错误。&quot;NOLFS &quot;代表 &quot;NO Large File Support&quot;。</target>
        </trans-unit>
        <trans-unit id="1cda63147d327bf25d081e640b795908860d57cd" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOMEM result code indicates that SQLite was unable to allocate all the memory it needed to complete the operation. In other words, an internal call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt; has failed in a case where the memory being allocated was required in order to continue the operation.</source>
          <target state="translated">SQLITE_NOMEM结果代码指示SQLite无法分配完成操作所需的所有内存。换句话说，在需要分配内存以继续操作的情况下，对&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;或&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;的内部调用失败。</target>
        </trans-unit>
        <trans-unit id="90348aff38a7fe2d16e98097b8d995eefcd13821" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTFOUND result code is also used internally by the SQLite implementation, but those internal uses are not exposed to the application.</source>
          <target state="translated">SQLITE_NOTFOUND结果代码也被SQLite实现内部使用,但这些内部使用不会暴露给应用程序。</target>
        </trans-unit>
        <trans-unit id="04b892d49dde78c36512aea678380b1b3cb4740c" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTFOUND result code is used in two contexts. SQLITE_NOTFOUND can be returned by the &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface to indicate that the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write&quot;&gt;file control opcode&lt;/a&gt; passed as the third argument was not recognized by the underlying &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. SQLITE_NOTFOUND can also be returned by the xSetSystemCall() method of an &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object.</source>
          <target state="translated">SQLITE_NOTFOUND结果代码在两个上下文中使用。&lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;接口可以返回SQLITE_NOTFOUND，以指示基础&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;无法识别作为第三个参数传递的&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write&quot;&gt;文件控件操作码&lt;/a&gt;。&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的xSetSystemCall（）方法也可以返回SQLITE_NOTFOUND 。</target>
        </trans-unit>
        <trans-unit id="2006836e7cf841369d470c41165b6630c3c15ae9" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTICE result code is not returned by any C/C++ interface. However, SQLITE_NOTICE (or rather one of its &lt;a href=&quot;rescode#extrc&quot;&gt;extended error codes&lt;/a&gt;) is sometimes used as the first argument in an &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; callback to indicate that an unusual operation is taking place.</source>
          <target state="translated">任何C / C ++接口都不返回SQLITE_NOTICE结果代码。但是，有时SQLITE_NOTICE（或其&lt;a href=&quot;rescode#extrc&quot;&gt;扩展错误代码之一&lt;/a&gt;）在&lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log（）&lt;/a&gt;回调中用作第一个参数，以指示正在进行异常操作。</target>
        </trans-unit>
        <trans-unit id="02cb61634cf3f64c55c04a76d9ecf0d6931de129" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTICE_RECOVER_ROLLBACK result code is passed to the callback of &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; when a &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;hot journal&lt;/a&gt; is rolled back.</source>
          <target state="translated">当&lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;热日志&lt;/a&gt;回滚时，SQLITE_NOTICE_RECOVER_ROLLBACK结果代码将传递到&lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log（）&lt;/a&gt;的回调。</target>
        </trans-unit>
        <trans-unit id="f198e3499c541e2a07f04094a1095a33b4f9550d" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTICE_RECOVER_WAL result code is passed to the callback of &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; when a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database file is recovered.</source>
          <target state="translated">恢复&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;数据库文件时，将SQLITE_NOTICE_RECOVER_WAL结果代码传递到&lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log（）&lt;/a&gt;的回调。</target>
        </trans-unit>
        <trans-unit id="ee291eadebc9e5d4151fc8b157f062bbbf6ed568" translate="yes" xml:space="preserve">
          <source>The SQLITE_OK result code means that the operation was successful and that there were no errors. Most other result codes indicate an error.</source>
          <target state="translated">SQLITE_OK结果代码表示操作成功,没有错误。大多数其他结果代码表示一个错误。</target>
        </trans-unit>
        <trans-unit id="db1bbd15a81f09ee87a066e983ed6980b9d26517" translate="yes" xml:space="preserve">
          <source>The SQLITE_OK_LOAD_PERMANENTLY return code is useful to &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt; that register new &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;, for example.</source>
          <target state="translated">例如，SQLITE_OK_LOAD_PERMANENTLY返回代码对于注册新&lt;a href=&quot;vfs&quot;&gt;VFS的&lt;/a&gt;&lt;a href=&quot;loadext&quot;&gt;可加载扩展&lt;/a&gt;很有用。</target>
        </trans-unit>
        <trans-unit id="6becbabbe4a84dad21c1b1544eb673040cac46e2" translate="yes" xml:space="preserve">
          <source>The SQLITE_OMIT_* options are unsupported. By this we mean that an SQLITE_OMIT_* option that omits code from the build in the current release might become a no-op in the next release. Or the other way around: an SQLITE_OMIT_* that is a no-op in the current release might cause code to be excluded in the next release. Also, not all SQLITE_OMIT_* options are tested. Some SQLITE_OMIT_* options might cause SQLite to malfunction and/or provide incorrect answers.</source>
          <target state="translated">SQLITE_OMIT_*选项是不支持的。我们的意思是,在当前版本中省略了构建中的代码的 SQLITE_OMIT_*选项可能会在下一个版本中变成无选项。或者反过来说:一个在当前版本中是no-op的SQLITE_OMIT_*可能会在下一个版本中导致代码被排除。另外,并非所有的 SQLITE_OMIT_*选项都会被测试。一些SQLITE_OMIT_*选项可能会导致SQLite失灵和/或提供错误的答案。</target>
        </trans-unit>
        <trans-unit id="5d47886ed69e3788c34a2d6c9a632c5948855a34" translate="yes" xml:space="preserve">
          <source>The SQLITE_OMIT_MERGE_SORT option has been removed. The merge sorter is now a required component of SQLite.</source>
          <target state="translated">删除了 SQLITE_OMIT_MERGE_SORT 选项。合并分拣器现在是SQLite的必要组件。</target>
        </trans-unit>
        <trans-unit id="2ace5bda746aeaa5497bcf0c7e8c12395a91c1c1" translate="yes" xml:space="preserve">
          <source>The SQLITE_PERM result code indicates that the requested access mode for a newly created database could not be provided.</source>
          <target state="translated">SQLITE_PERM结果代码表示不能提供新创建的数据库的请求访问模式。</target>
        </trans-unit>
        <trans-unit id="57074805a6a2909f8660b15999da8d8adc66e584" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_NORMALIZE flag is a no-op. This flag used to be required for any prepared statement that wanted to use the &lt;a href=&quot;#sqlite3_expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface. However, the &lt;a href=&quot;#sqlite3_expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface is now available to all prepared statements, regardless of whether or not they use this flag.</source>
          <target state="translated">SQLITE_PREPARE_NORMALIZE标志是无操作的。以前，要使用&lt;a href=&quot;#sqlite3_expanded_sql&quot;&gt;sqlite3_normalized_sql（）&lt;/a&gt;接口的任何准备好的语句都需要使用此标志。但是，&lt;a href=&quot;#sqlite3_expanded_sql&quot;&gt;sqlite3_normalized_sql（）&lt;/a&gt;接口现在可用于所有准备好的语句，无论它们是否使用此标志。</target>
        </trans-unit>
        <trans-unit id="1ad4cab077701a7da0038bd41b3f79ceedfd12d8" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_NORMALIZE flag is a no-op. This flag used to be required for any prepared statement that wanted to use the &lt;a href=&quot;expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface. However, the &lt;a href=&quot;expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface is now available to all prepared statements, regardless of whether or not they use this flag.</source>
          <target state="translated">SQLITE_PREPARE_NORMALIZE标志是无操作的。以前，要使用&lt;a href=&quot;expanded_sql&quot;&gt;sqlite3_normalized_sql（）&lt;/a&gt;接口的任何准备好的语句都需要使用此标志。但是，&lt;a href=&quot;expanded_sql&quot;&gt;sqlite3_normalized_sql（）&lt;/a&gt;接口现在可用于所有准备好的语句，无论它们是否使用此标志。</target>
        </trans-unit>
        <trans-unit id="a0438ba55e3894ec50e9427fa15e7d877e35f842" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_NO_VTAB flag causes the SQL compiler to return an error (error code SQLITE_ERROR) if the statement uses any virtual tables.</source>
          <target state="translated">如果语句使用了任何虚拟表,SQLITE_PREPARE_NO_VTAB标志会导致SQL编译器返回一个错误(错误代码SQLITE_ERROR)。</target>
        </trans-unit>
        <trans-unit id="68c6b699083a20e7dac515dfb0a940a1d2fa1d0a" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_PERSISTENT flag is a hint to the query planner that the prepared statement will be retained for a long time and probably reused many times. Without this flag, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; assume that the prepared statement will be used just once or at most a few times and then destroyed using &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; relatively soon. The current implementation acts on this hint by avoiding the use of &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory&lt;/a&gt; so as not to deplete the limited store of lookaside memory. Future versions of SQLite may act on this hint differently.</source>
          <target state="translated">SQLITE_PREPARE_PERSISTENT标志向查询计划者提示已准备好的语句将保留很长时间，并且可能会多次重复使用。如果没有此标志，则&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;假定已准备好的语句将仅使用一次或最多使用几次，然后相对较快地使用&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;销毁。当前的实现方式通过避免使用&lt;a href=&quot;malloc#lookaside&quot;&gt;后备内存&lt;/a&gt;来避免这种情况发生，以免耗尽后备内存的有限存储。 SQLite的未来版本可能对此提示有所不同。</target>
        </trans-unit>
        <trans-unit id="799dbb7451dd41ca217be627d63018af5431d1bf" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_PERSISTENT flag is a hint to the query planner that the prepared statement will be retained for a long time and probably reused many times. Without this flag, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; assume that the prepared statement will be used just once or at most a few times and then destroyed using &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; relatively soon. The current implementation acts on this hint by avoiding the use of &lt;a href=&quot;../malloc#lookaside&quot;&gt;lookaside memory&lt;/a&gt; so as not to deplete the limited store of lookaside memory. Future versions of SQLite may act on this hint differently.</source>
          <target state="translated">SQLITE_PREPARE_PERSISTENT标志向查询计划者提示已准备好的语句将保留很长时间，并且可能会多次重复使用。如果没有此标志，则&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;和&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;假定已准备好的语句将仅使用一次或最多使用几次，然后相对较快地使用&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;销毁。当前的实现方式通过避免使用&lt;a href=&quot;../malloc#lookaside&quot;&gt;后备内存&lt;/a&gt;来避免这种情况发生，以免耗尽后备内存的有限存储。 SQLite的未来版本可能对此提示有所不同。</target>
        </trans-unit>
        <trans-unit id="2c11fb868fc472e55f703cb835b3c6a27d603969" translate="yes" xml:space="preserve">
          <source>The SQLITE_PROTOCOL result code indicates a problem with the file locking protocol used by SQLite. The SQLITE_PROTOCOL error is currently only returned when using &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; and attempting to start a new transaction. There is a race condition that can occur when two separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; both try to start a transaction at the same time in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. The loser of the race backs off and tries again, after a brief delay. If the same connection loses the locking race dozens of times over a span of multiple seconds, it will eventually give up and return SQLITE_PROTOCOL. The SQLITE_PROTOCOL error should appear in practice very, very rarely, and only when there are many separate processes all competing intensely to write to the same database.</source>
          <target state="translated">SQLITE_PROTOCOL结果代码指示SQLite使用的文件锁定协议有问题。当前仅在使用&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;并尝试启动新事务时返回SQLITE_PROTOCOL错误。当两个单独的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;都尝试在&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;同时启动事务时，可能会发生争用情况。短暂的延迟后，比赛的失败者退回并重试。如果同一连接在几秒钟的时间内失去了数十次锁定竞争，它将最终放弃并返回SQLITE_PROTOCOL。实际上，SQLITE_PROTOCOL错误应该非常非常少地出现，并且仅当有许多单独的进程都在激烈竞争以写入同一数据库时才出现。</target>
        </trans-unit>
        <trans-unit id="2290c0085d649d3364cd3e13fd796218538f0c97" translate="yes" xml:space="preserve">
          <source>The SQLITE_RANGE error indices that the parameter number argument to one of the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind&lt;/a&gt; routines or the column number in one of the &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column&lt;/a&gt; routines is out of range.</source>
          <target state="translated">所述SQLITE_RANGE错误索引，参数号参数传递给之一&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind&lt;/a&gt;例程或在一个列号&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column&lt;/a&gt;例程是超出范围。</target>
        </trans-unit>
        <trans-unit id="81db86b91239da795ab1877a821491920db31614" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY result code is returned when an attempt is made to alter some data for which the current database connection does not have write permission.</source>
          <target state="translated">当试图改变某些数据时,如果当前数据库连接没有写权限,则返回SQLITE_READONLY结果代码。</target>
        </trans-unit>
        <trans-unit id="20a2e61649ed0f39a9f887714e92e822fd9ead1d" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_CANTINIT result code originates in the xShmMap method of a &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to indicate that the shared memory region used by &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; exists buts its content is unreliable and unusable by the current process since the current process does not have write permission on the shared memory region. (The shared memory region for WAL mode is normally a file with a &quot;-wal&quot; suffix that is mmapped into the process space. If the current process does not have write permission on that file, then it cannot write into shared memory.)</source>
          <target state="translated">SQLITE_READONLY_CANTINIT结果代码源自&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;的xShmMap方法，以指示存在&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;使用的共享内存区域，但是其内容对于当前进程而言是不可靠且无法使用的，因为当前进程对共享内存区域没有写权限。（用于WAL模式的共享内存区域通常是一个带有&amp;ldquo; -wal&amp;rdquo;后缀的文件，该文件被映射到进程空间中。如果当前进程对该文件没有写权限，则它将无法写入共享内存。）</target>
        </trans-unit>
        <trans-unit id="8cc5d69c49bd0049fa508081d686d1a3ef3d0153" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_CANTLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;. The SQLITE_READONLY_CANTLOCK error code indicates that SQLite is unable to obtain a read lock on a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database because the shared-memory file associated with that database is read-only.</source>
          <target state="translated">所述SQLITE_READONLY_CANTLOCK错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;。SQLITE_READONLY_CANTLOCK错误代码指示SQLite无法获得&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;数据库上的读取锁，因为与该数据库关联的共享内存文件是只读的。</target>
        </trans-unit>
        <trans-unit id="19656bfe231a68e2b6cce42b55c5197d3d416be0" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_DBMOVED error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;. The SQLITE_READONLY_DBMOVED error code indicates that a database cannot be modified because the database file has been moved since it was opened, and so any attempt to modify the database might result in database corruption if the processes crashes because the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; would not be correctly named.</source>
          <target state="translated">所述SQLITE_READONLY_DBMOVED错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;。SQLITE_READONLY_DBMOVED错误代码指示无法修改数据库，因为数据库文件自打开以来已被移动，因此，如果进程崩溃（因为&lt;a href=&quot;lockingv3#rollback&quot;&gt;回滚日志&lt;/a&gt;无法正确命名），则任何修改数据库的尝试都可能导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="41ecb30affe77245ceb751ab6c0b2e9fce929efd" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_DIRECTORY result code indicates that the database is read-only because process does not have permission to create a journal file in the same directory as the database and the creation of a journal file is a prerequisite for writing.</source>
          <target state="translated">SQLITE_READONLY_DIRECTORY结果代码表示数据库是只读的,因为进程没有权限在与数据库相同的目录下创建日志文件,而创建日志文件是写入的前提条件。</target>
        </trans-unit>
        <trans-unit id="c2523ec31f0b9a2d33cf73109d61b1e043f8086c" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_RECOVERY error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;. The SQLITE_READONLY_RECOVERY error code indicates that a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database cannot be opened because the database file needs to be recovered and recovery requires write access but only read access is available.</source>
          <target state="translated">所述SQLITE_READONLY_RECOVERY错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;。SQLITE_READONLY_RECOVERY错误代码指示无法打开&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;数据库，因为需要恢复数据库文件，并且恢复需要写访问权限，但只有读访问权限可用。</target>
        </trans-unit>
        <trans-unit id="ba838fe9f900034dae5111194ba7ea1d5270d1c2" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_ROLLBACK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;. The SQLITE_READONLY_ROLLBACK error code indicates that a database cannot be opened because it has a &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;hot journal&lt;/a&gt; that needs to be rolled back but cannot because the database is readonly.</source>
          <target state="translated">所述SQLITE_READONLY_ROLLBACK错误代码是一个&lt;a href=&quot;rescode#pve&quot;&gt;扩展的错误代码&lt;/a&gt;为&lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;。SQLITE_READONLY_ROLLBACK错误代码指示无法打开数据库，因为该数据库具有需要回滚的&lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;热日志&lt;/a&gt;，但由于数据库为只读而无法打开。</target>
        </trans-unit>
        <trans-unit id="d25154fd2f20b85ded4823ebe97f48106c96d4d1" translate="yes" xml:space="preserve">
          <source>The SQLITE_ROW result code returned by &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; indicates that another row of output is available.</source>
          <target state="translated">&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;返回的SQLITE_ROW结果代码指示输出的另一行可用。</target>
        </trans-unit>
        <trans-unit id="1d91aee6732a465a4cc20090bf5eb9177f9e582c" translate="yes" xml:space="preserve">
          <source>The SQLITE_SCHEMA result code indicates that the database schema has changed. This result code can be returned from &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; for a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; that was generated using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;. If the database schema was changed by some other process in between the time that the statement was prepared and the time the statement was run, this error can result.</source>
          <target state="translated">SQLITE_SCHEMA结果代码指示数据库架构已更改。对于使用&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;或&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16（）&lt;/a&gt;生成的&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;，可以从&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;返回此结果代码。如果在准备该语句的时间与运行该语句的时间之间，数据库架构被其他进程更改，则可能导致此错误。</target>
        </trans-unit>
        <trans-unit id="bccaf372951fcf999b80b85d54115242255c5910" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT Virtual Table</source>
          <target state="translated">SQLITE_STMT虚拟表</target>
        </trans-unit>
        <trans-unit id="0210be179f988cfe689d56f75f4d1fa3e0b6bb8b" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT extension can also be loaded at run-time by compiling the extension into a shared library or DLL using the source code at &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/memstat.c&quot;&gt;https://sqlite.org/src/file/ext/misc/memstat.c&lt;/a&gt; and following the instructions for how to &lt;a href=&quot;loadext#build&quot;&gt;compile loadable extensions&lt;/a&gt;.</source>
          <target state="translated">通过使用&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/memstat.c&quot;&gt;https://sqlite.org/src/file/ext/misc/memstat.c上&lt;/a&gt;的源代码并遵循有关说明，可在运行时通过将扩展编译为共享库或DLL来在运行时加载SQLITE_STMT扩展。如何&lt;a href=&quot;loadext#build&quot;&gt;编译可加载的扩展&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c79456ebf36875bab38cefa2c6e55d9482f8dca7" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT extension implements an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt; that provides information about all &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">SQLITE_STMT扩展实现了一个&lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;仅&lt;/a&gt;提供别名的虚拟表，该表提供了与&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;关联的所有&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;的信息。</target>
        </trans-unit>
        <trans-unit id="514c2473199b17afc5dd1d8c02362217c121606a" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT extension is enabled in default builds of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;cli&quot;&gt;命令行shell的&lt;/a&gt;默认内部版本中启用了SQLITE_STMT扩展。</target>
        </trans-unit>
        <trans-unit id="e53abd5cd3368a9c18b0e2f006747b4e8c1e98ad" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT extension is included in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; though it is disabled by default. Use the &lt;a href=&quot;compile#enable_stmtvtab&quot;&gt;SQLITE_ENABLE_STMTVTAB&lt;/a&gt; compile-time option to enable the SQLITE_STMT extension. The SQLITE_STMT extension can also be loaded at run-time by compiling the extension into a shared library or DLL using the source code at &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/stmt.c&quot;&gt;https://sqlite.org/src/file/ext/misc/stmt.c&lt;/a&gt; and following the instructions for how to &lt;a href=&quot;loadext#build&quot;&gt;compile loadable extensions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;amalgamation&quot;&gt;合并中&lt;/a&gt;包含SQLITE_STMT扩展名，但默认情况下已禁用。使用&lt;a href=&quot;compile#enable_stmtvtab&quot;&gt;SQLITE_ENABLE_STMTVTAB&lt;/a&gt;编译时选项启用SQLITE_STMT扩展。通过使用&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/stmt.c&quot;&gt;https://sqlite.org/src/file/ext/misc/stmt.c上&lt;/a&gt;的源代码并按照有关说明的说明将扩展编译为共享库或DLL，也可以在运行时加载SQLITE_STMT扩展。如何&lt;a href=&quot;loadext#build&quot;&gt;编译可加载的扩展&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eff6d72f1420a16df254227915d0745e46f60ade" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT virtual table can also be used to access performance information about prepared statements, to aid in optimization an application. For example, to find out how much memory is being used by &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; that have never been used, one could run:</source>
          <target state="translated">SQLITE_STMT虚拟表还可以用于访问有关准备好的语句的性能信息，以帮助优化应用程序。例如，要找出从未使用过的&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;正在使用多少内存，可以运行以下语句：</target>
        </trans-unit>
        <trans-unit id="36a652edafe32e1a6a69623202e497c2b84971e5" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT virtual table is a read-only table that can be directly queried to access information about all prepared statements on the current database connection. For example:</source>
          <target state="translated">SQLITE_STMT虚拟表是一个只读表,可以直接查询访问当前数据库连接上所有准备好的语句的信息。例如</target>
        </trans-unit>
        <trans-unit id="c57e4bb46f13bf2108682321d36a64fbe9c7f037" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMTJRNL_SPILL compile-time option determines the default setting of the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt; start-time setting. That setting determines the size threshold above which &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;statement journals&lt;/a&gt; are moved from memory to disk.</source>
          <target state="translated">SQLITE_STMTJRNL_SPILL编译时选项确定&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt;开始时间设置的默认设置。该设置确定了大小阈值，超过该阈值后，&lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;语句日志&lt;/a&gt;将从内存移动到磁盘。</target>
        </trans-unit>
        <trans-unit id="53aa1b2835c1a75b5cdfb5b24f66527df47e52af" translate="yes" xml:space="preserve">
          <source>The SQLITE_SUBTYPE flag indicates to SQLite that a function may call &lt;a href=&quot;#sqlite3_value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; to inspect the sub-types of its arguments. Specifying this flag makes no difference for scalar or aggregate user functions. However, if it is not specified for a user-defined window function, then any sub-types belonging to arguments passed to the window function may be discarded before the window function is called (i.e. sqlite3_value_subtype() will always return 0).</source>
          <target state="translated">SQLITE_SUBTYPE标志向SQLite指示函数可以调用&lt;a href=&quot;#sqlite3_value_subtype&quot;&gt;sqlite3_value_subtype（）&lt;/a&gt;来检查其参数的子类型。指定此标志对于标量或聚合用户函数没有区别。但是，如果未为用户定义的窗口函数指定它，则在调用窗口函数之前，属于传递给窗口函数的参数的任何子类型都可以被丢弃（即sqlite3_value_subtype（）将始终返回0）。</target>
        </trans-unit>
        <trans-unit id="a9bfb18749058a748b6ef8d70f30272423e2e061" translate="yes" xml:space="preserve">
          <source>The SQLITE_SUBTYPE flag indicates to SQLite that a function may call &lt;a href=&quot;value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; to inspect the sub-types of its arguments. Specifying this flag makes no difference for scalar or aggregate user functions. However, if it is not specified for a user-defined window function, then any sub-types belonging to arguments passed to the window function may be discarded before the window function is called (i.e. sqlite3_value_subtype() will always return 0).</source>
          <target state="translated">SQLITE_SUBTYPE标志向SQLite指示函数可以调用&lt;a href=&quot;value_subtype&quot;&gt;sqlite3_value_subtype（）&lt;/a&gt;来检查其参数的子类型。指定此标志对于标量或聚合用户函数没有区别。但是，如果未为用户定义的窗口函数指定它，则在调用窗口函数之前，属于传递给窗口函数的参数的任何子类型都可以被丢弃（即sqlite3_value_subtype（）将始终返回0）。</target>
        </trans-unit>
        <trans-unit id="eebb912b265a126853dad1960970bce68414c982" translate="yes" xml:space="preserve">
          <source>The SQLITE_TMPDIR environment variable</source>
          <target state="translated">环境变量SQLITE_TMPDIR</target>
        </trans-unit>
        <trans-unit id="c73fb526ebe5bd57bd3e299a92027075f6d77195" translate="yes" xml:space="preserve">
          <source>The SQLITE_TOOBIG error code can also result when an oversized SQL statement is passed into one of the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; interfaces. The maximum length of an SQL statement defaults to a much smaller value of 1,000,000 bytes. The maximum SQL statement length can be set at compile-time using &lt;a href=&quot;limits#max_sql_length&quot;&gt;SQLITE_MAX_SQL_LENGTH&lt;/a&gt; or at run-time using &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitsqllength&quot;&gt;SQLITE_LIMIT_SQL_LENGTH&lt;/a&gt;,...).</source>
          <target state="translated">将超大的SQL语句传递到&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;接口之一时，也会导致SQLITE_TOOBIG错误代码。 SQL语句的最大长度默认小于1,000,000字节。可以在编译时使用&lt;a href=&quot;limits#max_sql_length&quot;&gt;SQLITE_MAX_SQL_LENGTH&lt;/a&gt;或在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitsqllength&quot;&gt;SQLITE_LIMIT_SQL_LENGTH&lt;/a&gt;等）设置最大SQL语句长度。</target>
        </trans-unit>
        <trans-unit id="95a063038fc4fca17964bc0777d759cfc88b33bd" translate="yes" xml:space="preserve">
          <source>The SQLITE_TOOBIG error code indicates that a string or BLOB was too large. The default maximum length of a string or BLOB in SQLite is 1,000,000,000 bytes. This maximum length can be changed at compile-time using the &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; compile-time option, or at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;,...) interface. The SQLITE_TOOBIG error results when SQLite encounters a string or BLOB that exceeds the compile-time or run-time limit.</source>
          <target state="translated">SQLITE_TOOBIG错误代码指示字符串或BLOB太大。 SQLite中字符串或BLOB的默认最大长度为1,000,000,000字节。可以在编译时使用&lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;编译时选项或在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;，...）接口更改此最大长度。当SQLite遇到超过编译时或运行时限制的字符串或BLOB时，将导致SQLITE_TOOBIG错误。</target>
        </trans-unit>
        <trans-unit id="21b792e942050acdb1f5297373f2dc87cd1c2f3b" translate="yes" xml:space="preserve">
          <source>The SQLITE_TXN_NONE state means that no transaction is currently pending.</source>
          <target state="translated">SQLITE_TXN_NONE状态表示当前没有事务待处理。</target>
        </trans-unit>
        <trans-unit id="e6b1b5323aef3d4f570cddc35ef43e00ece35f14" translate="yes" xml:space="preserve">
          <source>The SQLITE_TXN_READ state means that the database is currently in a read transaction. Content has been read from the database file but nothing in the database file has changed. The transaction state will advanced to SQLITE_TXN_WRITE if any changes occur and there are no other conflicting concurrent write transactions. The transaction state will revert to SQLITE_TXN_NONE following a &lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; or &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt;.</source>
          <target state="translated">SQLITE_TXN_READ状态表示数据库当前处于读取事务中。已从数据库文件读取内容，但数据库文件中的任何内容均未更改。如果发生任何更改并且没有其他冲突的并发写入事务，则事务状态将前进到SQLITE_TXN_WRITE。在&lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;或&lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt;之后，事务状态将恢复为SQLITE_TXN_NONE 。</target>
        </trans-unit>
        <trans-unit id="76de43351beee3cd86dc613ced7d55bb27bb8a53" translate="yes" xml:space="preserve">
          <source>The SQLITE_TXN_READ state means that the database is currently in a read transaction. Content has been read from the database file but nothing in the database file has changed. The transaction state will advanced to SQLITE_TXN_WRITE if any changes occur and there are no other conflicting concurrent write transactions. The transaction state will revert to SQLITE_TXN_NONE following a &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; or &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;.</source>
          <target state="translated">SQLITE_TXN_READ状态表示数据库当前处于读取事务中。已从数据库文件读取内容，但数据库文件中的任何内容均未更改。如果发生任何更改并且没有其他冲突的并发写入事务，则事务状态将前进到SQLITE_TXN_WRITE。在&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;或&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;之后，事务状态将恢复为SQLITE_TXN_NONE 。</target>
        </trans-unit>
        <trans-unit id="31facd60a75014e6e40e0899cca8355b7122d037" translate="yes" xml:space="preserve">
          <source>The SQLITE_TXN_WRITE state means that the database is currently in a write transaction. Content has been written to the database file but has not yet committed. The transaction state will change to to SQLITE_TXN_NONE at the next &lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; or &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt;.</source>
          <target state="translated">SQLITE_TXN_WRITE状态表示数据库当前处于写事务中。内容已写入数据库文件，但尚未提交。在下一个&lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;或&lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT时&lt;/a&gt;，事务状态将更改为SQLITE_TXN_NONE 。</target>
        </trans-unit>
        <trans-unit id="16039ec64bbea9ed0430524e82f519e254c5013d" translate="yes" xml:space="preserve">
          <source>The SQLITE_TXN_WRITE state means that the database is currently in a write transaction. Content has been written to the database file but has not yet committed. The transaction state will change to to SQLITE_TXN_NONE at the next &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; or &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;.</source>
          <target state="translated">SQLITE_TXN_WRITE状态表示数据库当前处于写事务中。内容已写入数据库文件，但尚未提交。在下一个&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;或&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT时&lt;/a&gt;，事务状态将更改为SQLITE_TXN_NONE 。</target>
        </trans-unit>
        <trans-unit id="b22248b709740e89a9f8d423ea84335819e1ee2a" translate="yes" xml:space="preserve">
          <source>The SQLITE_WARNING result code is not returned by any C/C++ interface. However, SQLITE_WARNING (or rather one of its &lt;a href=&quot;rescode#extrc&quot;&gt;extended error codes&lt;/a&gt;) is sometimes used as the first argument in an &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; callback to indicate that an unusual and possibly ill-advised operation is taking place.</source>
          <target state="translated">任何C / C ++接口都不返回SQLITE_WARNING结果代码。但是，有时将SQLITE_WARNING（或其&lt;a href=&quot;rescode#extrc&quot;&gt;扩展错误代码中的一个&lt;/a&gt;）用作&lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log（）&lt;/a&gt;回调中的第一个参数，以指示发生了异常且可能不明智的操作。</target>
        </trans-unit>
        <trans-unit id="bd54655a92d09c02b918de6e8114904fcbbd22b3" translate="yes" xml:space="preserve">
          <source>The SQLITE_WARNING_AUTOINDEX result code is passed to the callback of &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; whenever &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; is used. This can serve as a warning to application designers that the database might benefit from additional indexes.</source>
          <target state="translated">每当使用&lt;a href=&quot;optoverview#autoindex&quot;&gt;自动索引&lt;/a&gt;时，SQLITE_WARNING_AUTOINDEX结果代码将传递到&lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log（）&lt;/a&gt;的回调。这可以向应用程序设计者发出警告，即数据库可能会从附加索引中受益。</target>
        </trans-unit>
        <trans-unit id="c76259d82167d5f943a68fb0352bace5b64fab37" translate="yes" xml:space="preserve">
          <source>The SQLite Amalgamation</source>
          <target state="translated">SQLite的合并</target>
        </trans-unit>
        <trans-unit id="e5e12b48e05726457e7db136c89d439a466ab852" translate="yes" xml:space="preserve">
          <source>The SQLite Archive is a relatively new format. It was first described in in 2014. ZIP Archives and Tarballs, on the other hand, have been around for decades and are well-entrenched as standard formats. Most programmers know what a ZIP Archive or Tarball is, but if you say &quot;SQLite Archive&quot; you are more likely to get a reply of &quot;What?&quot; Tooling to process ZIP Archives and Tarballs is more likely to be installed on stock computers.</source>
          <target state="translated">SQLite档案是一种比较新的格式。它在2014年首次被描述。另一方面,ZIP Archive和Tarballs已经存在了几十年,并且作为标准格式已经根深蒂固。大多数程序员都知道ZIP Archive或Tarball是什么,但如果你说 &quot;SQLite Archive&quot;,你更有可能得到 &quot;什么?&quot;的回答。处理ZIP Archive和Tarballs的工具更有可能安装在库存计算机上。</target>
        </trans-unit>
        <trans-unit id="14b38e43f93cb1f6666b258c1070654e3f60d3ab" translate="yes" xml:space="preserve">
          <source>The SQLite Bytecode Engine</source>
          <target state="translated">SQLite字节码引擎</target>
        </trans-unit>
        <trans-unit id="60d2d0a8c73ed165c49cdebcf186c3bd62509aba" translate="yes" xml:space="preserve">
          <source>The SQLite OS Interface or &quot;VFS&quot;</source>
          <target state="translated">SQLite操作系统接口或 &quot;VFS&quot;</target>
        </trans-unit>
        <trans-unit id="67edc3d607c153611c830c05dc44105c120df169" translate="yes" xml:space="preserve">
          <source>The SQLite OS Interface or &amp;quot;VFS&amp;quot;</source>
          <target state="translated">SQLite OS接口或&amp;ldquo; VFS&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="eb768474c2c960b1f80b5ec4636fc5c556432ed7" translate="yes" xml:space="preserve">
          <source>The SQLite Query Optimizer Overview</source>
          <target state="translated">SQLite查询优化器概述</target>
        </trans-unit>
        <trans-unit id="656be9ece72b3b3c8af07774a0a4473889d5a0ca" translate="yes" xml:space="preserve">
          <source>The SQLite R*Tree Module</source>
          <target state="translated">SQLite R*Tree模块</target>
        </trans-unit>
        <trans-unit id="f7f3e9d21d121d5b3e8db61ea6e7dde70d17b4dd" translate="yes" xml:space="preserve">
          <source>The SQLite R*Tree module is implemented as a &lt;a href=&quot;c3ref/create_module&quot;&gt;virtual table&lt;/a&gt;. Each R*Tree index is a virtual table with an odd number of columns between 3 and 11. The first column is always a 64-bit signed integer primary key. The other columns are pairs, one pair per dimension, containing the minimum and maximum values for that dimension, respectively. A 1-dimensional R*Tree thus has 3 columns. A 2-dimensional R*Tree has 5 columns. A 3-dimensional R*Tree has 7 columns. A 4-dimensional R*Tree has 9 columns. And a 5-dimensional R*Tree has 11 columns. The SQLite R*Tree implementation does not support R*Trees wider than 5 dimensions.</source>
          <target state="translated">SQLite R * Tree模块被实现为&lt;a href=&quot;c3ref/create_module&quot;&gt;虚拟表&lt;/a&gt;。每个R * Tree索引都是一个虚拟表，其中的奇数列介于3和11之间。第一列始终是64位带符号整数主键。其他列为对，每个维度一对，分别包含该维度的最小值和最大值。一维R * Tree因此具有3列。二维R * Tree有5列。 3维R * Tree有7列。 4维R * Tree有9列。 5维R * Tree有11列。 SQLite R * Tree实现不支持宽度超过5维的R * Tree。</target>
        </trans-unit>
        <trans-unit id="d26287506df7d739659f92d570a45374e9d6b203" translate="yes" xml:space="preserve">
          <source>The SQLite Zipfile Module</source>
          <target state="translated">SQLite Zip文件模块</target>
        </trans-unit>
        <trans-unit id="2a322992d7eadef1cbb665cdba826abcbe8d4bc9" translate="yes" xml:space="preserve">
          <source>The SQLite approach of storing the schema as text has advantages for an embedded relational database. For one, it means that the schema takes up less space in the database file. This is important since a common SQLite usage pattern is to have many small, separate database files instead of putting everything in one big global database file, which is the usual approach for client/server database engines. Since the schema is duplicated in each separate database file, it is important to keep the schema representation compact.</source>
          <target state="translated">SQLite将模式存储为文本的方法对于嵌入式关系数据库来说有其优势。首先,它意味着模式在数据库文件中占用的空间较小。这一点很重要,因为一个常见的SQLite使用模式是有许多小的、独立的数据库文件,而不是把所有的东西都放在一个大的全局数据库文件中,这是客户/服务器数据库引擎的通常做法。由于模式在每个独立的数据库文件中都是重复的,所以保持模式的紧凑性非常重要。</target>
        </trans-unit>
        <trans-unit id="4156bb8a5bb8b9775d5b39350cba56f0d4323350" translate="yes" xml:space="preserve">
          <source>The SQLite code is broken up into multiple repositories, each described in a separate section below.</source>
          <target state="translated">SQLite代码被分解成多个存储库,每个存储库在下面的单独章节中描述。</target>
        </trans-unit>
        <trans-unit id="50c10f7a2161303f10be1e978ecf9c20c8b5ff8a" translate="yes" xml:space="preserve">
          <source>The SQLite community has been a kind, welcoming and well-mannered community since its inception nearly two decades ago. In that time many of the qualities we've worked hard to bring to our project - safety, consistency, usability and integrity among them - have become part of our community's culture as well. Much like the care and effort we've put into securing the longevity of SQLite, we'd like to do the same for that community by clarifying our goals and expectations for all involved. To that end the SQLite project has officially adopted the &lt;a href=&quot;https://www.mozilla.org/en-US/about/governance/policies/participation/&quot;&gt;Mozilla Community Participation Guidelines&lt;/a&gt; as its Code of Conduct with the exception that the reporting email address is changed to &lt;a href=&quot;mailto:codeofconduct@sqlite.org&quot;&gt;codeofconduct@sqlite.org&lt;/a&gt;. While we are not doing so in reaction to any current or ongoing issues, we believe that this will be a helpful part of maintaining the long-term sustainability of the project.</source>
          <target state="translated">自将近20年前成立以来，SQLite社区一直是一个友好，欢迎和礼貌的社区。那时，我们努力为项目带来的许多品质-安全性，一致性，可用性和完整性-也已成为我们社区文化的一部分。就像我们为确保SQLite的使用寿命所付出的努力和努力一样，我们希望通过阐明我们对所有相关人员的目标和期望，对该社区采取同样的措施。为此，SQLite项目已正式采用&lt;a href=&quot;https://www.mozilla.org/en-US/about/governance/policies/participation/&quot;&gt;Mozilla社区参与指南&lt;/a&gt;作为其行为准则，但报告电子邮件地址已更改为&lt;a href=&quot;mailto:codeofconduct@sqlite.org&quot;&gt;codeofconduct@sqlite.org。&lt;/a&gt;。尽管我们不对任何当前或持续存在的问题做出回应，但我们认为这将对保持项目的长期可持续性起到有益的作用。</target>
        </trans-unit>
        <trans-unit id="6e54c3c7cfbe74cbcff4d32cf11ceb85c2d59225" translate="yes" xml:space="preserve">
          <source>The SQLite core and its memory allocation subsystem provides the following capabilities:</source>
          <target state="translated">SQLite内核及其内存分配子系统提供了以下功能。</target>
        </trans-unit>
        <trans-unit id="4a8db7c1ed47d07dc8525eeb4fe9e3c2cadccf8a" translate="yes" xml:space="preserve">
          <source>The SQLite core calls the xBestIndex method when it is compiling a query that involves a virtual table. In other words, SQLite calls this method when it is running &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or the equivalent. By calling this method, the SQLite core is saying to the virtual table that it needs to access some subset of the rows in the virtual table and it wants to know the most efficient way to do that access. The xBestIndex method replies with information that the SQLite core can then use to conduct an efficient search of the virtual table.</source>
          <target state="translated">SQLite核心在编译涉及虚拟表的查询时会调用xBestIndex方法。换句话说，SQLite在运行&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;或等效版本时调用此方法。通过调用此方法，SQLite核心对虚拟表说，它需要访问虚拟表中某些行的子集，并且它想知道执行该访问的最有效方法。xBestIndex方法回复信息，SQLite核心随后可以使用这些信息进行有效的虚拟表搜索。</target>
        </trans-unit>
        <trans-unit id="0101337cc0cb6fad83f4b1e21e8fd59c6d10699a" translate="yes" xml:space="preserve">
          <source>The SQLite core communicates with the xBestIndex method by filling in certain fields of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure and passing a pointer to that structure into xBestIndex as the second parameter. The xBestIndex method fills out other fields of this structure which forms the reply. The &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure looks like this:</source>
          <target state="translated">通过填充&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;结构的某些字段并将指向该结构的指针作为第二个参数传递到xBestIndex中，SQLite核心与xBestIndex方法进行通信。xBestIndex方法填充了构成回复的此结构的其他字段。该&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;结构如下：</target>
        </trans-unit>
        <trans-unit id="d592f9a3c73be507b58cc4d8ef9e1e11527c40f2" translate="yes" xml:space="preserve">
          <source>The SQLite core contains 5665 &lt;code&gt;assert()&lt;/code&gt; statements that verify function preconditions and postconditions and loop invariants. Assert() is a macro which is a standard part of ANSI-C. The argument is a boolean value that is assumed to always be true. If the assertion is false, the program prints an error message and halts.</source>
          <target state="translated">SQLite核心包含5665个 &lt;code&gt;assert()&lt;/code&gt; 语句，用于验证函数的前提条件和后置条件以及循环不变式。Assert（）是宏，它是ANSI-C的标准部分。该参数是一个布尔值，假定始终为true。如果断言为假，程序将显示一条错误消息并暂停。</target>
        </trans-unit>
        <trans-unit id="7a7923d469bddb357e4bafd2e77a5357a3ce8703" translate="yes" xml:space="preserve">
          <source>The SQLite core contains 5855 &lt;code&gt;assert()&lt;/code&gt; statements that verify function preconditions and postconditions and loop invariants. Assert() is a macro which is a standard part of ANSI-C. The argument is a boolean value that is assumed to always be true. If the assertion is false, the program prints an error message and halts.</source>
          <target state="translated">SQLite核心包含5855条 &lt;code&gt;assert()&lt;/code&gt; 语句，这些语句验证函数的前提条件和后置条件以及循环不变量。Assert（）是一个宏，它是ANSI-C的标准部分。该参数是一个布尔值，假定始终为true。如果断言为假，程序将显示一条错误消息并暂停。</target>
        </trans-unit>
        <trans-unit id="8a046e08f75eaccd925ae647cf15c7aa3a8226b9" translate="yes" xml:space="preserve">
          <source>The SQLite core invokes the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsyncomitted&quot;&gt;SQLITE_FCNTL_SYNC_OMITTED&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;file control&lt;/a&gt; to the VFS in place of a call to xSync if the database has &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF.</source>
          <target state="translated">如果数据库的&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt;设置为OFF ，则SQLite核心&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsyncomitted&quot;&gt;将对&lt;/a&gt; VFS 调用SQLITE_FCNTL_SYNC_OMITTED &lt;a href=&quot;c3ref/file_control&quot;&gt;文件控件&lt;/a&gt;代替对xSync的调用。</target>
        </trans-unit>
        <trans-unit id="9454a146cdf6bd63746f75afc554dedcf8a89f3d" translate="yes" xml:space="preserve">
          <source>The SQLite core invokes this method in order to find the value for the N-th column of the current row. N is zero-based so the first column is numbered 0. The xColumn method may return its result back to SQLite using one of the following interface:</source>
          <target state="translated">SQLite核心调用这个方法是为了找到当前行的第N-列的值。N是基于零的,所以第一列的编号是0。 xColumn方法可以使用以下接口之一将其结果返回给SQLite。</target>
        </trans-unit>
        <trans-unit id="81909f2a4a51a96b134a34a4888c44983e2d76d3" translate="yes" xml:space="preserve">
          <source>The SQLite core uses these routines for thread synchronization. Though they are intended for internal use by SQLite, code that links against SQLite is permitted to use any of these routines.</source>
          <target state="translated">SQLite核心使用这些例程进行线程同步。虽然这些例程是供SQLite内部使用的,但允许针对SQLite进行链接的代码使用这些例程中的任何一个。</target>
        </trans-unit>
        <trans-unit id="922f1172309b4b736f1e305e3916cca7c4256be1" translate="yes" xml:space="preserve">
          <source>The SQLite core uses these three routines for all of its own internal memory allocation needs. &quot;Core&quot; in the previous sentence does not include operating-system specific &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt; implementation. The Windows VFS uses native malloc() and free() for some operations.</source>
          <target state="translated">SQLite内核将这三个例程用于其内部内存分配的所有需求。上一句话中的&amp;ldquo;核心&amp;rdquo;不包括特定于操作系统的&lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt;实现。Windows VFS对某些操作使用本机malloc（）和free（）。</target>
        </trans-unit>
        <trans-unit id="a9334c44f83a523ef26ab7a77c74c4218d746143" translate="yes" xml:space="preserve">
          <source>The SQLite core uses these three routines for all of its own internal memory allocation needs. &quot;Core&quot; in the previous sentence does not include operating-system specific &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementation. The Windows VFS uses native malloc() and free() for some operations.</source>
          <target state="translated">SQLite内核将这三个例程用于其内部内存分配的所有需求。上一句话中的&amp;ldquo;核心&amp;rdquo;不包括特定于操作系统的&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;实现。Windows VFS对某些操作使用本机malloc（）和free（）。</target>
        </trans-unit>
        <trans-unit id="c22d82769d3da3cfaaf7c30bf60dfe3d4e431d6a" translate="yes" xml:space="preserve">
          <source>The SQLite core uses these three routines for all of its own internal memory allocation needs. &quot;Core&quot; in the previous sentence does not include operating-system specific VFS implementation. The Windows VFS uses native malloc() and free() for some operations.</source>
          <target state="translated">SQLite核心使用这三个例程来满足自己内部所有的内存分配需求。前面一句话中的 &quot;核心 &quot;不包括操作系统特定的VFS实现。Windows VFS在某些操作上使用了原生的malloc()和free()。</target>
        </trans-unit>
        <trans-unit id="310e86b319144a9b8ab497d9dda0fd59a92fa402" translate="yes" xml:space="preserve">
          <source>The SQLite core will call &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; early. The auxiliary C code file can contain an implementation of sqlite3_initialize() that registers an appropriate VFS and also perhaps initializes an alternative mutex system (if mutexes are required) or does any memory allocation subsystem initialization that is required. The SQLite core never calls &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; but it is part of the official SQLite API and is not otherwise provided when compiled with -DSQLITE_OS_OTHER=1, so the auxiliary C code file should probably provide it for completeness.</source>
          <target state="translated">SQLite核心将尽早调用&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;。辅助C代码文件可以包含sqlite3_initialize（）的实现，该实现注册适当的VFS，还可能初始化备用的互斥锁系统（如果需要互斥锁）或进行所需的任何内存分配子系统初始化。SQLite核心从不调用&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown（），&lt;/a&gt;但它是官方SQLite API的一部分，并且在使用-DSQLITE_OS_OTHER = 1编译时未提供，因此辅助C代码文件可能应该提供完整性。</target>
        </trans-unit>
        <trans-unit id="a3389235261ef05c3ad08031ba3272b1839ea345" translate="yes" xml:space="preserve">
          <source>The SQLite core, including the unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;, has 100% branch test coverage under &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; in its default configuration as measured by &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt;. Extensions such as FTS3 and RTree are excluded from this analysis.</source>
          <target state="translated">由&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt;衡量，SQLite内核（包括unix &lt;a href=&quot;vfs&quot;&gt;VFS）&lt;/a&gt;在其默认配置下在&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;下具有100％的分支测试覆盖率。此分析不包括诸如FTS3和RTree的扩展。</target>
        </trans-unit>
        <trans-unit id="17a5dd9abfc2732f02a18eb851200b8dd4798d4e" translate="yes" xml:space="preserve">
          <source>The SQLite core, including the unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;, has 100% branch test coverage under &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; in its default configuration as measured by &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt;. Extensions such as FTS3 and RTree are excluded from this analysis.</source>
          <target state="translated">由&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt;衡量，SQLite内核（包括unix &lt;a href=&quot;vfs&quot;&gt;VFS）&lt;/a&gt;在其默认配置下在&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;下具有100％分支测试覆盖率。此分析不包括诸如FTS3和RTree的扩展。</target>
        </trans-unit>
        <trans-unit id="25f0f08e26b5d1ff28a9d0772acbc6ec5d4dc8bf" translate="yes" xml:space="preserve">
          <source>The SQLite database allows multiple simultaneous readers or a single writer but not both. If any process is writing to the database no other process is allows to read or write. If any process is reading the database other processes are allowed to read but not write. The entire database shared a single lock.</source>
          <target state="translated">SQLite数据库允许多个同时读取者或一个写入者,但不允许同时读取和写入。如果有任何进程向数据库写入,其他进程都不允许读或写。如果任何进程正在读取数据库,其他进程允许读取,但不允许写入。整个数据库共用一个锁。</target>
        </trans-unit>
        <trans-unit id="c9e7754ee2f8ef030d3e0c4851d0ab23e5bf681e" translate="yes" xml:space="preserve">
          <source>The SQLite database file (&quot;self2014.sqlar&quot;) is about a half percent smaller than the equivalent ODP file! How can this be? Apparently the ZIP archive generator logic in NeoOffice is not as efficient as it could be, because when the same pile-of-files is recompressed using the command-line &quot;zip&quot; utility, one gets a file (&quot;zip.odp&quot;) that is smaller still, by another half percent, as seen in the third line above. So, a well-written ZIP archive can be slightly smaller than the equivalent SQLite database, as one would expect. But the difference is slight. The key take-away is that an SQLite database is size-competitive with a ZIP archive.</source>
          <target state="translated">SQLite数据库文件(&quot;self2014.sqllar&quot;)比等效的ODP文件小了约一半! 这怎么可能?显然,NeoOffice中的ZIP归档文件生成器逻辑并不那么有效,因为当使用命令行的 &quot;zip &quot;工具对同样的一堆文件进行重新压缩时,得到的文件(&quot;zip.odp&quot;)仍然更小,又小了一半,如上文第三行所示。所以,正如人们所期望的那样,一个写得很好的ZIP归档文件可以比等效的SQLite数据库略小。但差别很小。关键的启示是,SQLite数据库与ZIP归档在大小上是有竞争力的。</target>
        </trans-unit>
        <trans-unit id="20b6f43ea15deb4c44a24b00c6944cb60a4b8d86" translate="yes" xml:space="preserve">
          <source>The SQLite database file format is also stable. All releases of SQLite version 3 can read and write database files created by the very first SQLite 3 release (version 3.0.0) going back to 2004-06-18. This is &quot;backwards compatibility&quot;. The developers promise to maintain backwards compatibility of the database file format for all future releases of SQLite 3. &quot;Forwards compatibility&quot; means that older releases of SQLite can also read and write databases created by newer releases. SQLite is usually, but not completely forwards compatible.</source>
          <target state="translated">SQLite数据库文件格式也很稳定。所有版本的SQLite 3都可以读写由第一个SQLite 3版本(3.0.0版本)创建的数据库文件,可以追溯到2004-06-18。这就是 &quot;向后兼容&quot;。开发者承诺,在SQLite 3的所有未来版本中,将保持数据库文件格式的向后兼容性。&quot;向后兼容 &quot;意味着旧版本的SQLite也可以读写新版本创建的数据库。SQLite通常是,但不是完全向后兼容的。</target>
        </trans-unit>
        <trans-unit id="0b9e7e4e72268ed8ff0aecd3bce3fa20aed32bae" translate="yes" xml:space="preserve">
          <source>The SQLite developers do not write CVEs. Any CVEs you find on SQLite are generated by third-parties, often without any input from the core developers. A common scenario is that someone will report a bug in SQLite, which will promptly be fixed, then weeks later a CVE for that bug will appear, unbeknownst to the developers.</source>
          <target state="translated">SQLite开发人员并不编写CVE。你在SQLite上找到的任何CVE都是由第三方生成的,通常没有核心开发人员的任何投入。一个常见的情况是,有人会报告SQLite中的一个bug,这个bug会立即被修复,然后几个星期后,这个bug会出现一个CVE,而开发者并不知道。</target>
        </trans-unit>
        <trans-unit id="a9896b9f0acf4d53bbeb650db03c052b65e4b39c" translate="yes" xml:space="preserve">
          <source>The SQLite developers use an on-line checklist to coordinate testing activity and to verify that all tests pass prior each SQLite release. &lt;a href=&quot;http://www.sqlite.org/checklists/index.html&quot;&gt;Past checklists&lt;/a&gt; are retained for historical reference. (The checklists are read-only for anonymous internet viewers, but developers can log in and update checklist items in their web browsers.) The use of checklists for SQLite testing and other development activities is inspired by</source>
          <target state="translated">SQLite开发人员使用在线检查表来协调测试活动并验证所有测试在每个SQLite版本之前均通过。保留&lt;a href=&quot;http://www.sqlite.org/checklists/index.html&quot;&gt;过去的清单&lt;/a&gt;以供历史参考。（清单对于匿名Internet查看器是只读的，但是开发人员可以在其Web浏览器中登录并更新清单项目。）清单清单用于SQLite测试和其他开发活动的灵感来自于</target>
        </trans-unit>
        <trans-unit id="ab91797e187d60ea01091238dc193eb80d33d37b" translate="yes" xml:space="preserve">
          <source>The SQLite developers use an on-line checklist to coordinate testing activity and to verify that all tests pass prior each SQLite release. &lt;a href=&quot;https://www.sqlite.org/checklists/index.html&quot;&gt;Past checklists&lt;/a&gt; are retained for historical reference. (The checklists are read-only for anonymous internet viewers, but developers can log in and update checklist items in their web browsers.) The use of checklists for SQLite testing and other development activities is inspired by</source>
          <target state="translated">SQLite开发人员使用在线检查表来协调测试活动并验证所有测试在每个SQLite版本之前均已通过。保留&lt;a href=&quot;https://www.sqlite.org/checklists/index.html&quot;&gt;过去的清单&lt;/a&gt;以供历史参考。（清单对于匿名Internet查看器是只读的，但是开发人员可以在其Web浏览器中登录并更新清单项目。）清单清单在SQLite测试和其他开发活动中的使用受到启发。</target>
        </trans-unit>
        <trans-unit id="9c957f8bdf8ce50dc09723537398c60a4991b0ad" translate="yes" xml:space="preserve">
          <source>The SQLite development team fixes bugs promptly, usually within hours of discovery. New releases of SQLite are issued if the bug seems likely to impact real-world applications.</source>
          <target state="translated">SQLite开发团队会及时修复错误,通常在发现后的几个小时内修复。如果错误似乎可能影响到现实世界的应用,则会发布新的SQLite版本。</target>
        </trans-unit>
        <trans-unit id="4f35e69a2395e538db8157dc3dbb68d5b6f19b6e" translate="yes" xml:space="preserve">
          <source>The SQLite file format is cross-platform. A database file written on one machine can be copied to and used on a different machine with a different architecture. Big-endian or little-endian, 32-bit or 64-bit does not matter. All machines use the same file format. Furthermore, the developers have pledged to keep the file format stable and backwards compatible, so newer versions of SQLite can read and write older database files.</source>
          <target state="translated">SQLite文件格式是跨平台的。在一台机器上编写的数据库文件可以复制到不同架构的机器上使用。大二烯或小二烯,32位或64位并不重要。所有机器都使用相同的文件格式。此外,开发者还承诺保持文件格式的稳定和向后兼容,所以新版本的SQLite可以读写旧版本的数据库文件。</target>
        </trans-unit>
        <trans-unit id="a470f0b14147aeef040dd5381d7be5b2946cd2d3" translate="yes" xml:space="preserve">
          <source>The SQLite interface elements can be grouped into three categories:</source>
          <target state="translated">SQLite接口元素可以分为三类。</target>
        </trans-unit>
        <trans-unit id="d2127d3816b52817dc6b4ce63d16e29894ba0878" translate="yes" xml:space="preserve">
          <source>The SQLite library consists of 102 files of C code (as of &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;Version 3.9.0&lt;/a&gt; - 2015-10-14) in the core with 32 additional files that implement the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;, &lt;a href=&quot;dbstat&quot;&gt;DBSTAT&lt;/a&gt;, &lt;a href=&quot;json1&quot;&gt;JSON1&lt;/a&gt;, and &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; extensions. Of the 102 main source files, about 75% are C code and about 25% are C header files. Most of these are &quot;source&quot; files in the sense that they are stored in the &lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;SQLite version control system&lt;/a&gt; and are edited manually in an ordinary text editor. But some of the C-language files are generated using scripts or auxiliary programs. For example, the &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=src/parse.y&quot;&gt;parse.y&lt;/a&gt; file contains an LALR(1) grammar of the SQL language which is compiled down into are parser in files &quot;parse.c&quot; and &quot;parse.h&quot; by the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt;.</source>
          <target state="translated">SQLite库在核心中包含102个C代码文件（&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;版本&lt;/a&gt;&lt;a href=&quot;fts5&quot;&gt;3.9.0-2015-10-14）&lt;/a&gt;，另外32个文件实现了&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;，FTS5，&lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;，&lt;a href=&quot;dbstat&quot;&gt;DBSTAT&lt;/a&gt;，&lt;a href=&quot;json1&quot;&gt;JSON1&lt;/a&gt;和&lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt;扩展。在102个主要源文件中，大约75％是C代码，大约25％是C头文件。从它们存储在&lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;SQLite版本控制系统中&lt;/a&gt;并在普通文本编辑器中手动编辑的意义上说，这些文件中的大多数都是&amp;ldquo;源&amp;rdquo;文件。但是某些C语言文件是使用脚本或辅助程序生成的。例如，&lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=src/parse.y&quot;&gt;parse.y&lt;/a&gt;该文件包含SQL语言的LALR（1）语法，该文件由&lt;a href=&quot;lemon&quot;&gt;Lemon解析器生成器&lt;/a&gt;编译为文件parse.c和parse.h中的解析器。</target>
        </trans-unit>
        <trans-unit id="7fdfec2d5c500b7ac74b77876e6dfdaa2cdecb05" translate="yes" xml:space="preserve">
          <source>The SQLite library exports the string constant named &lt;b&gt;sqlite_version&lt;/b&gt; which contains the version number of the library. The header file contains a macro SQLITE_VERSION with the same information. If desired, a program can compare the SQLITE_VERSION macro against the &lt;b&gt;sqlite_version&lt;/b&gt; string constant to verify that the version number of the header file and the library match.</source>
          <target state="translated">SQLite库导出名为&lt;b&gt;sqlite_version&lt;/b&gt;的字符串常量，其中包含该库的版本号。头文件包含具有相同信息的宏SQLITE_VERSION。如果需要，程序可以将SQLITE_VERSION宏与&lt;b&gt;sqlite_version&lt;/b&gt;字符串常量进行比较，以验证头文件的版本号和库是否匹配。</target>
        </trans-unit>
        <trans-unit id="3f89e1941b8b597af45ed78a7c716ad9e7232f89" translate="yes" xml:space="preserve">
          <source>The SQLite library is designed to be very easy to use from a &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;Tcl or Tcl/Tk&lt;/a&gt; script. SQLite began as a &lt;a href=&quot;http://www.tcl-lang.org/doc/tea/&quot;&gt;Tcl extension&lt;/a&gt; and the primary &lt;a href=&quot;testing&quot;&gt;test suite&lt;/a&gt; for SQLite is written in TCL. SQLite can be used with any programming language, but its connections to TCL run deep.</source>
          <target state="translated">SQLite库的设计使其非常易于从&lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;Tcl或Tcl / Tk&lt;/a&gt;脚本使用。 SQLite从&lt;a href=&quot;http://www.tcl-lang.org/doc/tea/&quot;&gt;Tcl扩展&lt;/a&gt;开始，SQLite 的主要&lt;a href=&quot;testing&quot;&gt;测试套件&lt;/a&gt;是用TCL编写的。 SQLite可以与任何编程语言一起使用，但是它与TCL的连接很深。</target>
        </trans-unit>
        <trans-unit id="f0e8965a9252a8aca8a477026acb0a17bd84805b" translate="yes" xml:space="preserve">
          <source>The SQLite library is designed to be very easy to use from a C or C++ program. This document gives an overview of the C/C++ programming interface.</source>
          <target state="translated">SQLite库被设计成非常容易从C或C++程序中使用。本文档给出了C/C++编程接口的概述。</target>
        </trans-unit>
        <trans-unit id="0602c28d1654d00a16d8fb7d7632cbb5225eb5e8" translate="yes" xml:space="preserve">
          <source>The SQLite library may need less RAM since it shares pages with the operating-system page cache and does not always need its own copy of working pages.</source>
          <target state="translated">SQLite库可能需要较少的RAM,因为它与操作系统页面缓存共享页面,并不总是需要自己的工作页面副本。</target>
        </trans-unit>
        <trans-unit id="b68ac5f0b4be242c75b75b113e85779b0d2d24fb" translate="yes" xml:space="preserve">
          <source>The SQLite library supplies the VDBE with a pointer to the callback function and the &lt;b&gt;pUserData&lt;/b&gt; pointer. (Both the callback and the user data were originally passed in as arguments to the &lt;b&gt;sqlite_exec()&lt;/b&gt; API function.) The job of the VDBE is to come up with values for &lt;b&gt;nColumn&lt;/b&gt;, &lt;b&gt;azData[]&lt;/b&gt;, and &lt;b&gt;azColumnName[]&lt;/b&gt;. &lt;b&gt;nColumn&lt;/b&gt; is the number of columns in the results, of course. &lt;b&gt;azColumnName[]&lt;/b&gt; is an array of strings where each string is the name of one of the result columns. &lt;b&gt;azData[]&lt;/b&gt; is an array of strings holding the actual data.</source>
          <target state="translated">SQLite库为VDBE提供了指向回调函数的指针和&lt;b&gt;pUserData&lt;/b&gt;指针。（回调和用户数据最初都是作为参数传递给&lt;b&gt;sqlite_exec（）&lt;/b&gt; API函数的。）VDBE的工作是为&lt;b&gt;nColumn&lt;/b&gt;，&lt;b&gt;azData []&lt;/b&gt;和&lt;b&gt;azColumnName []提供值&lt;/b&gt;。&lt;b&gt;当然，nColumn&lt;/b&gt;是结果中的列数。&lt;b&gt;azColumnName []&lt;/b&gt;是一个字符串数组，其中每个字符串都是结果列之一的名称。&lt;b&gt;azData []&lt;/b&gt;是保存实际数据的字符串数组。</target>
        </trans-unit>
        <trans-unit id="bec59993baf9ef121d8c6051be0842d34bbcc286" translate="yes" xml:space="preserve">
          <source>The SQLite library was compiled with &lt;a href=&quot;compile#use_uri&quot;&gt;-DSQLITE_USE_URI=1&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;compile#use_uri&quot;&gt;-DSQLITE_USE_URI = 1&lt;/a&gt;编译了SQLite库。</target>
        </trans-unit>
        <trans-unit id="e9d0a1ae4dbbafaabd699c25677e883038d9a262" translate="yes" xml:space="preserve">
          <source>The SQLite project provides a simple command-line program named &lt;b&gt;sqlite3&lt;/b&gt; (or &lt;b&gt;sqlite3.exe&lt;/b&gt; on Windows) that allows the user to manually enter and execute SQL statements against an SQLite database or against a &lt;a href=&quot;#zipdb&quot;&gt;ZIP archive&lt;/a&gt;. This document provides a brief introduction on how to use the &lt;b&gt;sqlite3&lt;/b&gt; program.</source>
          <target state="translated">SQLite项目提供了一个名为&lt;b&gt;sqlite3&lt;/b&gt;（或Windows上的&lt;b&gt;sqlite3.exe&lt;/b&gt;）的简单命令行程序，该程序允许用户针对SQLite数据库或&lt;a href=&quot;#zipdb&quot;&gt;ZIP存档&lt;/a&gt;手动输入和执行SQL语句。本文档简要介绍了如何使用&lt;b&gt;sqlite3&lt;/b&gt;程序。</target>
        </trans-unit>
        <trans-unit id="f3d928b1fc0f8261eeda1295ec9247d5985e38f7" translate="yes" xml:space="preserve">
          <source>The SQLite project provides a simple command-line program named &lt;b&gt;sqlite3&lt;/b&gt; (or &lt;b&gt;sqlite3.exe&lt;/b&gt; on Windows) that allows the user to manually enter and execute SQL statements against an SQLite database. This document provides a brief introduction on how to use the &lt;b&gt;sqlite3&lt;/b&gt; program.</source>
          <target state="translated">SQLite项目提供了一个名为&lt;b&gt;sqlite3&lt;/b&gt;（或Windows上的&lt;b&gt;sqlite3.exe&lt;/b&gt;）的简单命令行程序，该程序允许用户手动输入和执行针对SQLite数据库的SQL语句。本文档简要介绍了如何使用&lt;b&gt;sqlite3&lt;/b&gt;程序。</target>
        </trans-unit>
        <trans-unit id="c372f90b5ac62e99b6357128106b66701a0411a3" translate="yes" xml:space="preserve">
          <source>The SQLite query planner will consider using an index on an expression when the expression that is indexed appears in the WHERE clause or in the ORDER BY clause of a query,</source>
          <target state="translated">当被索引的表达式出现在查询的WHERE子句或ORDER BY子句中时,SQLite查询规划器会考虑对表达式使用索引。</target>
        </trans-unit>
        <trans-unit id="6dfbc1d18bbce16026bdcc86a5bffbbe6b1beb8b" translate="yes" xml:space="preserve">
          <source>The SQLite source code and the &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt; are stored together in a single repository. This one repository is all that is required to build the SQLite. The source repository is public and is readable by anonymous passers by on the internet.</source>
          <target state="translated">SQLite源代码和&lt;a href=&quot;testing#tcl&quot;&gt;TCL测试套件&lt;/a&gt;一起存储在单个存储库中。这一个存储库是构建SQLite所需的全部。源存储库是公共的，匿名传递者可以在Internet上读取它们。</target>
        </trans-unit>
        <trans-unit id="038ea963840df99a058067d40caa3b0cbd33dedb" translate="yes" xml:space="preserve">
          <source>The SQLite source code contains 1084 uses of the &lt;code&gt;testcase()&lt;/code&gt; macro.</source>
          <target state="translated">SQLite源代码包含 &lt;code&gt;testcase()&lt;/code&gt; 宏的1084个用法。</target>
        </trans-unit>
        <trans-unit id="1097f713df32cd3a870e17f648d7622d77d22cd2" translate="yes" xml:space="preserve">
          <source>The SQLite source code contains 992 uses of the &lt;code&gt;testcase()&lt;/code&gt; macro.</source>
          <target state="translated">SQLite源代码包含 &lt;code&gt;testcase()&lt;/code&gt; 宏的992个用法。</target>
        </trans-unit>
        <trans-unit id="200e89ebce3af8e9c7c026a8d18cac87a1da0318" translate="yes" xml:space="preserve">
          <source>The SQLite source code contains literally thousands of assert() statements used to verify internal assumptions and subroutine preconditions and postconditions. These assert() statements are normally turned off (they generate no code) since turning them on makes SQLite run approximately three times slower. But for testing and analysis, it is useful to turn the assert() statements on. The SQLITE_DEBUG compile-time option does this.</source>
          <target state="translated">SQLite源码中包含了数千条assert()语句,用于验证内部假设和子程序的前提条件和后置条件。这些 assert()语句通常是关闭的(它们不会产生代码),因为打开它们会使 SQLite 的运行速度慢大约三倍。但是对于测试和分析来说,打开 assert()语句是很有用的。SQLITE_DEBUG编译时选项就可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="7203161cfe6b6f33980e05611daeaed418ec5ae9" translate="yes" xml:space="preserve">
          <source>The SQLite source code contains multiple implementations of these mutex routines. An appropriate implementation is selected automatically at compile-time. The following implementations are available in the SQLite core:</source>
          <target state="translated">SQLite源代码中包含这些mutex例程的多种实现。在编译时,会自动选择一个合适的实现。以下是SQLite核心中的实现。</target>
        </trans-unit>
        <trans-unit id="519e11bf2b879a67e8b0e9134459d439da57e623" translate="yes" xml:space="preserve">
          <source>The SQLite source code includes several different memory allocation modules that can be selected at compile-time, or to a limited extent at start-time.</source>
          <target state="translated">SQLite源代码中包含了几个不同的内存分配模块,这些模块可以在编译时选择,或者在有限的程度上在启动时选择。</target>
        </trans-unit>
        <trans-unit id="b459704fa1dc2f133cc1300473552a0909311a3d" translate="yes" xml:space="preserve">
          <source>The SQLite source code provides multiple implementations of these APIs, suitable for varying environments. If SQLite is compiled with the SQLITE_THREADSAFE=0 flag then a no-op mutex implementation that is fast but does no real mutual exclusion is provided. That implementation is suitable for use in single-threaded applications or applications that only use SQLite in a single thread. Other real mutex implementations are provided based on the underlying operating system.</source>
          <target state="translated">SQLite源码提供了这些API的多种实现,适合不同的环境。如果SQLite在编译时使用SQLITE_THREADSAFE=0标志,那么就提供了一个无操作的互斥实现,它速度快,但没有真正的互斥。该实现适用于单线程应用或只在单线程中使用SQLite的应用。其他真正的互斥实现是基于底层操作系统提供的。</target>
        </trans-unit>
        <trans-unit id="4146cdfa0001cfa5a66203144506da17c3646968" translate="yes" xml:space="preserve">
          <source>The SQLite source tree actually contains multiple versions of the memory allocator. The default high-speed version found in the &quot;mem1.c&quot; source file is used for most builds. But if the SQLITE_MEMDEBUG flag is enabled, a separate memory allocator the &quot;mem2.c&quot; source file is used instead. The mem2.c allocator implements lots of hooks to do error checking and to simulate memory allocation failures for testing purposes. Both of these allocators use the malloc()/free() implementation in the standard C library.</source>
          <target state="translated">SQLite源码树实际上包含多个版本的内存分配器。在 &quot;mem1.c &quot;源文件中找到的默认高速版本被用于大多数构建。但是如果启用了SQLITE_MEMDEBUG标志,就会使用一个单独的内存分配器 &quot;mem2.c &quot;源文件来代替。mem2.c分配器实现了大量的钩子来进行错误检查,并为测试目的模拟内存分配失败。这两个分配器都使用标准C库中的malloc()/free()实现。</target>
        </trans-unit>
        <trans-unit id="4ba1f99040a37a507011c1205b1aef886c686eaf" translate="yes" xml:space="preserve">
          <source>The SQLite version identifier returned by the &lt;a href=&quot;lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id()&lt;/a&gt; SQL function and the &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt; C API and found in the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; macro is now a 64-digit SHA3-256 hash instead of a 40-digit SHA1 hash.</source>
          <target state="translated">由&lt;a href=&quot;lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id（）&lt;/a&gt; SQL函数和&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid（）&lt;/a&gt; C API返回并在&lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;宏中找到的SQLite版本标识符现在是64位SHA3-256哈希，而不是40位SHA1哈希。</target>
        </trans-unit>
        <trans-unit id="0c3d7b8c49e09915f93340abac558621318ffacf" translate="yes" xml:space="preserve">
          <source>The SQLite website (&lt;a href=&quot;https://www.sqlite.org/&quot;&gt;https://www.sqlite.org/&lt;/a&gt;) uses SQLite itself, of course, and as of this writing (2015) it handles about 400K to 500K HTTP requests per day, about 15-20% of which are dynamic pages touching the database. Dynamic content uses &lt;a href=&quot;np1queryprob&quot;&gt;about 200 SQL statements per webpage&lt;/a&gt;. This setup runs on a single VM that shares a physical server with 23 others and yet still keeps the load average below 0.1 most of the time.</source>
          <target state="translated">SQLite网站（&lt;a href=&quot;https://www.sqlite.org/&quot;&gt;https://www.sqlite.org/&lt;/a&gt;）当然使用SQLite本身，截至撰写本文（2015）时，它每天处理约40万至500K HTTP请求，其中约15-20％是动态的页面接触数据库。&lt;a href=&quot;np1queryprob&quot;&gt;每个网页的&lt;/a&gt;动态内容使用大约200条SQL语句。此设置在单个VM上运行，该VM与23个虚拟机共享一个物理服务器，但大多数情况下仍将平均负载保持在0.1以下。</target>
        </trans-unit>
        <trans-unit id="dc3cc55be8b0168568fc5c682e636d1909810e07" translate="yes" xml:space="preserve">
          <source>The SQLite-specific printf() supports a new flag (!) called the &quot;alternate-form-2&quot; flag. The alternate-form-2 flag changes the processing of floating-point conversions in subtle ways so that the output is always an SQL-compatible text representation of a floating-point number - something that is not possible to achieve with standard-library printf(). For string substitutions, the alternate-form-2 flag causes the width and precision to be measured in characters instead of bytes, which simplifies processing of strings containing multi-byte UTF8 characters.</source>
          <target state="translated">SQLite-specific printf()支持一个新的标志(!),称为 &quot;alternate-form-2 &quot;标志。alternate-form-2标志以微妙的方式改变了浮点转换的处理方式,因此输出的结果总是浮点数的SQL兼容文本表示--这是标准库printf()无法实现的。对于字符串替换,交替形式-2标志使宽度和精度以字符而不是以字节来衡量,这简化了对包含多字节UTF8字符的字符串的处理。</target>
        </trans-unit>
        <trans-unit id="ab1ef24a2c3d89dbbf816b75c5ebad085546d51d" translate="yes" xml:space="preserve">
          <source>The SUM function detects integer overflow and converts to accumulating an approximate result using floating point numbers</source>
          <target state="translated">SUM函数检测整数溢出,并转换为使用浮点数累积近似结果。</target>
        </trans-unit>
        <trans-unit id="9d27464a9b4c0f0bdd924575293003beb50c81e1" translate="yes" xml:space="preserve">
          <source>The SUM() function throws an error on integer overflow.</source>
          <target state="translated">SUM()函数在整数溢出时抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="d583a21e8e6e4ba4fbb7f5a178c04bb7372f87c1" translate="yes" xml:space="preserve">
          <source>The Schema Table</source>
          <target state="translated">模式表</target>
        </trans-unit>
        <trans-unit id="7cc003a9427832539005b297ca058e10476ece22" translate="yes" xml:space="preserve">
          <source>The Session Extension</source>
          <target state="translated">会话扩展</target>
        </trans-unit>
        <trans-unit id="0aa8192c55de05490d2622bfdb109c271f14a02d" translate="yes" xml:space="preserve">
          <source>The Spellfix1 Virtual Table</source>
          <target state="translated">Spellfix1虚拟表</target>
        </trans-unit>
        <trans-unit id="7366e749b34cc79e46fd62658a2ec13bee8b7b92" translate="yes" xml:space="preserve">
          <source>The T argument is the name of the target database file. The A argument is the name of the RBU database file. The S argument is the name of a &quot;state database&quot; used to store state information needed to resume the update after an interruption. The S argument can be NULL in which case the state information is stored in the RBU database in various tables whose names all begin with &quot;rbu_&quot;.</source>
          <target state="translated">T参数是目标数据库文件的名称。A 参数是 RBU 数据库文件的名称。S参数是 &quot;状态数据库 &quot;的名称,用于存储中断后恢复更新所需的状态信息。S参数可以是NULL,在这种情况下,状态信息被存储在RBU数据库中的各种表中,这些表的名字都以 &quot;rbu_&quot;开头。</target>
        </trans-unit>
        <trans-unit id="b1d051df5b386db985e4647bccdf4da6546279c0" translate="yes" xml:space="preserve">
          <source>The TCL bindings transfer data without necessarily doing a conversion to a string.</source>
          <target state="translated">TCL绑定传输数据,不一定要做转换为字符串。</target>
        </trans-unit>
        <trans-unit id="65bc381e62f8723019edd6efca853c02189bf80a" translate="yes" xml:space="preserve">
          <source>The TCL interface for SQLite is a small module that is added into the regular amalgamation. The result is a new amalgamated source file called &quot;&lt;b&gt;tclsqlite3.c&lt;/b&gt;&quot;. This single source file is all that is needed to generate a shared library that can be loaded into a standard &lt;a href=&quot;http://wiki.tcl-lang.org/2541&quot;&gt;tclsh&lt;/a&gt; or &lt;a href=&quot;http://wiki.tcl-lang.org/2364&quot;&gt;wish&lt;/a&gt; using the &lt;a href=&quot;http://wiki.tcl-lang.org/9830&quot;&gt;TCL load command&lt;/a&gt;, or to generate a standalone tclsh that comes with SQLite built in. A copy of the tcl amalgamation is included on the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; as a file in the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;TEA tarball&lt;/a&gt;.</source>
          <target state="translated">SQLite的TCL接口是一个很小的模块，已添加到常规合并中。结果是一个新的合并源文件，名为&amp;ldquo; &lt;b&gt;tclsqlite3.c&lt;/b&gt; &amp;rdquo;。生成共享库可以使用&lt;a href=&quot;http://wiki.tcl-lang.org/9830&quot;&gt;TCL load命令&lt;/a&gt;将其加载到标准&lt;a href=&quot;http://wiki.tcl-lang.org/2541&quot;&gt;tclsh&lt;/a&gt;或&lt;a href=&quot;http://wiki.tcl-lang.org/2364&quot;&gt;wish中&lt;/a&gt;，或生成内置SQLite的独立tclsh 所需的全部文件都是一个源文件。tcl合并的副本是包括在&lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;下载页面&lt;/a&gt;中的文件&lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;TEA压缩包&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f9e41f74fbcda169959b0e1c5ad24699dcf79aca" translate="yes" xml:space="preserve">
          <source>The TEMP database file is very similar to auxiliary database files added using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement, though with a few special properties. The TEMP database is always automatically deleted when the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is closed. The TEMP database always uses the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;synchronous=OFF&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode=PERSIST&lt;/a&gt; PRAGMA settings. And, the TEMP database cannot be used with &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; nor can another process &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; the TEMP database.</source>
          <target state="translated">TEMP数据库文件与使用&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;语句添加的辅助数据库文件非常相似，尽管具有一些特殊属性。关闭&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接后&lt;/a&gt;，TEMP数据库始终自动删除。 TEMP数据库始终使用&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;sync &lt;/a&gt;&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;= OFF&lt;/a&gt;和journal_mode = PERSIST PRAGMA设置。而且，临时数据库不能与使用&lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt;也可以在另一个进程&lt;a href=&quot;lang_attach&quot;&gt;连网&lt;/a&gt;的TEMP数据库。</target>
        </trans-unit>
        <trans-unit id="53f0498bc726c9a2250102fc1ce88dd0e04a9743" translate="yes" xml:space="preserve">
          <source>The TEMP or TEMPORARY keyword is removed if it occurs after the initial CREATE keyword.</source>
          <target state="translated">如果TEMP或TEMPORARY关键字出现在初始CREATE关键字之后,则会被删除。</target>
        </trans-unit>
        <trans-unit id="4b9ade3b04856b7f86ec94b71b3743aaff256ca8" translate="yes" xml:space="preserve">
          <source>The TEMP schema always has synchronous=OFF since the content of of TEMP is ephemeral and is not expected to survive a power outage. Attempts to change the synchronous setting for TEMP are silently ignored.</source>
          <target state="translated">由于TEMP的内容是短暂的,而且不能在断电后继续使用,所以TEMP模式的synchronous=OFF。试图改变TEMP的同步设置会被默默忽略。</target>
        </trans-unit>
        <trans-unit id="dd8090269fd066de5e15019d6f63ecc9dd8e6b9f" translate="yes" xml:space="preserve">
          <source>The TEMP_STORE and DEFAULT_TEMP_STORE pragmas now work.</source>
          <target state="translated">TEMP_STORE 和 DEFAULT_TEMP_STORE 实用工具现在可以使用了。</target>
        </trans-unit>
        <trans-unit id="5dbd6ac1d86267c3b2604d6573027830c458f6aa" translate="yes" xml:space="preserve">
          <source>The TH3 program generator is a TCL script named &quot;&lt;code&gt;mkth3.tcl&lt;/code&gt;&quot;. To generate a test program, one has merely to run this script and supply the names of files containing test modules and configurations on the command line. Test modules are files that use the &quot;&lt;code&gt;.test&lt;/code&gt;&quot; suffix and configurations are files that use the &quot;&lt;code&gt;.cfg&lt;/code&gt;&quot; suffix. A typical invocation of mkth3.tcl might look something like the following:</source>
          <target state="translated">TH3程序生成器是一个名为&amp;ldquo; &lt;code&gt;mkth3.tcl&lt;/code&gt; &amp;rdquo; 的TCL脚本。要生成测试程序，只需运行此脚本并在命令行上提供包含测试模块和配置的文件名。测试模块是使用&amp;ldquo; &lt;code&gt;.test&lt;/code&gt; &amp;rdquo;后缀的文件，而配置是使用&amp;ldquo; &lt;code&gt;.cfg&lt;/code&gt; &amp;rdquo;后缀的文件。mkth3.tcl的典型调用可能类似于以下内容：</target>
        </trans-unit>
        <trans-unit id="b8c8240b8bebcede58e6b71d1007e7276f3ab838" translate="yes" xml:space="preserve">
          <source>The TH3 repository also includes the &quot;multitest.tcl&quot; script, another TCL script used to automate TH3 testing on workstations. Multitest.tcl automatically compiles SQLite, then runs ./th3make repeatedly with a variety of alignments, and captures the output in a succinct summary screen. A typical multitest.tcl run generates output that looks like this:</source>
          <target state="translated">TH3资源库还包括 &quot;multitest.tcl &quot;脚本,这是另一个用于在工作站上自动测试TH3的TCL脚本。Multitest.tcl会自动编译SQLite,然后用各种排列方式反复运行./th3make,并在一个简洁的摘要屏幕上捕获输出。一个典型的multitest.tcl运行产生的输出是这样的。</target>
        </trans-unit>
        <trans-unit id="b6f9b2cda115a994b187cb0154afbb957f0c6ad7" translate="yes" xml:space="preserve">
          <source>The TH3 source tree contains a scripted name &quot;mutation-test.tcl&quot; that automates the process of &lt;a href=&quot;testing#mutationtests&quot;&gt;mutation testing&lt;/a&gt;.</source>
          <target state="translated">TH3源代码树包含一个脚本名称&amp;ldquo; mutation-test.tcl&amp;rdquo;，该名称可自动执行&lt;a href=&quot;testing#mutationtests&quot;&gt;突变测试&lt;/a&gt;过程。</target>
        </trans-unit>
        <trans-unit id="7cdfe00d64176fc80b6e066f8b6b12526ed3a13b" translate="yes" xml:space="preserve">
          <source>The TH3 test harness needs to run on embedded systems that do not necessarily have the ability to spawn child processes, so it uses an in-memory &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to simulate crashes. The in-memory &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; can be rigged to make a snapshot of the entire filesystem after a set number of I/O operations. Crash tests run in a loop. On each iteration of the loop, the point at which a snapshot is made is advanced until the SQLite operations being tested run to completion without ever hitting a snapshot. Within the loop, after the SQLite operation under test has completed, the filesystem is reverted to the snapshot and random file damage is introduced that is characteristic of the kinds of damage one expects to see following a power loss. Then the database is opened and checks are made to ensure that it is well-formed and that the transaction either ran to completion or was completely rolled back. The interior of the loop is repeated multiple times for each snapshot with different random damage each time.</source>
          <target state="translated">TH3测试工具需要在不一定具有生成子进程能力的嵌入式系统上运行，因此它使用内存中的&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;模拟崩溃。内存&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;可以操纵一定数量的I / O操作后制作整个文件系统的快照。崩溃测试循环运行。在循环的每次迭代中，制作快照的时间都会提前，直到要测试的SQLite操作运行完毕而不打快照。在循环中，被测SQLite操作完成后，文件系统将还原为快照，并引入了随机文件损坏，该损坏是人们在掉电后可能会看到的各种损坏的特征。然后，打开数据库并进行检查以确保其格式正确，并且该事务已完成或已完全回滚。对于每个快照，循环的内部重复多次，每次均具有不同的随机损坏。</target>
        </trans-unit>
        <trans-unit id="17fbf6e9083452ddac2fd083a957049cd4961ff8" translate="yes" xml:space="preserve">
          <source>The TMPDIR environment variable</source>
          <target state="translated">TMPDIR环境变量</target>
        </trans-unit>
        <trans-unit id="03b5c9a4012ba043f6ac023992fea614e9559aac" translate="yes" xml:space="preserve">
          <source>The TRUNCATE journaling mode commits transactions by truncating the rollback journal to zero-length instead of deleting it. On many systems, truncating a file is much faster than deleting the file since the containing directory does not need to be changed.</source>
          <target state="translated">TRUNCATE 日志模式通过将回滚日志截断为零长度而不是删除它来提交事务。在许多系统中,截断文件比删除文件要快得多,因为不需要改变包含的目录。</target>
        </trans-unit>
        <trans-unit id="8b6a576f2a0740b1d820bb0b389ef9405211a467" translate="yes" xml:space="preserve">
          <source>The Tcl interface to the SQLite library</source>
          <target state="translated">SQLite库的Tcl接口</target>
        </trans-unit>
        <trans-unit id="ea435d43ff01f7eaaaed2d71b4ee7a4a7d014eaf" translate="yes" xml:space="preserve">
          <source>The Tcl script language is used to help translate canonical source code into the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; and to manage testing. Tcl is not used directly by SQLite itself (unless requested by a compile-time option). End users of the SQLite amalgamation sources do not need Tcl.</source>
          <target state="translated">Tcl脚本语言用于帮助将规范的源代码转换为&lt;a href=&quot;amalgamation&quot;&gt;合并的文件&lt;/a&gt;并管理测试。Tcl不能直接由SQLite本身使用（除非编译时选项要求）。SQLite合并源的最终用户不需要Tcl。</target>
        </trans-unit>
        <trans-unit id="4ea1be33d0917718998fde5f34057649d7f00dc5" translate="yes" xml:space="preserve">
          <source>The Truncate Optimization</source>
          <target state="translated">截断式优化</target>
        </trans-unit>
        <trans-unit id="3d540f11b167e73decc4798633f81039fc8fd06e" translate="yes" xml:space="preserve">
          <source>The UINT Collating Sequence</source>
          <target state="translated">UINT整理序列</target>
        </trans-unit>
        <trans-unit id="99f583c0fd53b39d9c80671b9d84a8130da53c96" translate="yes" xml:space="preserve">
          <source>The UINT collating sequence is not a standard part of SQLite. It must be loaded as a separate extension. The source code to UINT is in the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/uint.c&quot;&gt;uint.c source file&lt;/a&gt; in the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc&quot;&gt;ext/misc/ folder&lt;/a&gt; of the SQLite source tree.</source>
          <target state="translated">UINT整理顺序不是SQLite的标准部分。它必须作为单独的扩展加载。UINT的源代码位于SQLite源树的&lt;a href=&quot;https://sqlite.org/src/file/ext/misc&quot;&gt;ext / misc /文件夹&lt;/a&gt;中的&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/uint.c&quot;&gt;uint.c源文件&lt;/a&gt;中。</target>
        </trans-unit>
        <trans-unit id="23e7f80ab844fa425934b5fe17e1623d4db7a7ce" translate="yes" xml:space="preserve">
          <source>The UINT collating sequence is not included in standard builds of the SQLite library, but it is loaded by default in the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;. This is typical of the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; which loads various extensions above and beyond what are available in the standard SQLite library.</source>
          <target state="translated">UINT整理序列不包括在SQLite库的标准内部版本中，但默认情况下会在&lt;a href=&quot;cli&quot;&gt;CLI中&lt;/a&gt;加载。这是典型的&lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;，它加载了各种扩展，超出了标准SQLite库中可用的扩展。</target>
        </trans-unit>
        <trans-unit id="324d9f9cbd074a1b691e1ceb95aebe8ed7a7d3f9" translate="yes" xml:space="preserve">
          <source>The UINT collating sequence works just like the default BINARY collating sequence for text, except that embedded strings of digits compare in numeric order.</source>
          <target state="translated">UINT整理序列的工作原理就像文本的默认BINARY整理序列一样,除了嵌入的数字字符串按数字顺序进行比较。</target>
        </trans-unit>
        <trans-unit id="0a4b72a7cee3e902b5abc5c6a3d97ab02173e940" translate="yes" xml:space="preserve">
          <source>The UINT collating sequences is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; for SQLite that implements a new collating sequence that compares text containing unsigned integers in numeric order.</source>
          <target state="translated">UINT整理序列是SQLite的&lt;a href=&quot;loadext&quot;&gt;可加载扩展&lt;/a&gt;，它实现了一个新的整理序列，该序列可以按数字顺序比较包含无符号整数的文本。</target>
        </trans-unit>
        <trans-unit id="663111ce13348e029be0eb29fd78279aef78534e" translate="yes" xml:space="preserve">
          <source>The UNION Virtual Table</source>
          <target state="translated">UNION虚拟表</target>
        </trans-unit>
        <trans-unit id="83a6780922b4732cbc0add9d73d09070752444e6" translate="yes" xml:space="preserve">
          <source>The UNION operator for compound queries is implemented by creating a transient index in a temporary file and storing the results of the left and right subquery in the transient index, discarding duplicates. After both subqueries have been evaluated, the transient index is walked from beginning to end to generate the final output.</source>
          <target state="translated">复合查询的UNION操作符是通过在临时文件中创建一个瞬时索引来实现的,并将左、右子查询的结果存储在瞬时索引中,丢弃重复的子查询。在两个子查询都被评估后,从头到尾走一遍瞬态索引,生成最终的输出。</target>
        </trans-unit>
        <trans-unit id="7930c62c86f89ebc6a986709239760afad2bba9f" translate="yes" xml:space="preserve">
          <source>The UNION virtual table (hereafter: &quot;union-vtab&quot;) is a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; that makes multiple independent &lt;a href=&quot;rowidtable&quot;&gt;rowid tables&lt;/a&gt; tables look like a single large table.</source>
          <target state="translated">UNION虚拟表（以下称&amp;ldquo; union-vtab&amp;rdquo;）是一个&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;，它使多个独立的&lt;a href=&quot;rowidtable&quot;&gt;rowid&lt;/a&gt;表表看起来像一个大表。</target>
        </trans-unit>
        <trans-unit id="16da95be83b926d661aef977fab4f723fc62a011" translate="yes" xml:space="preserve">
          <source>The UPDATE and DELETE statements are coded using a template that is very similar to the SELECT statement template. The main difference, of course, is that the end action is to modify the database rather than invoke a callback function. Because it modifies the database it will also use transactions. Let's begin by looking at a DELETE statement:</source>
          <target state="translated">UPDATE和DELETE语句使用的模板与SELECT语句模板非常相似。当然,主要的区别是,最终的操作是修改数据库,而不是调用回调函数。因为它修改数据库,所以也会使用事务。我们先来看一个DELETE语句。</target>
        </trans-unit>
        <trans-unit id="d012a450cb6e8a62342d872acae64f627c638672" translate="yes" xml:space="preserve">
          <source>The UPDATE statement was not working when the WHERE clause contained some terms that could be satisfied using indices and other terms that could not. Fixed.</source>
          <target state="translated">当WHERE子句中包含一些可以使用索引满足的术语和其他不能满足的术语时,UPDATE语句无法工作。已修正。</target>
        </trans-unit>
        <trans-unit id="33c2760fb2236b7ba6d326e49f2cb15eef8f0600" translate="yes" xml:space="preserve">
          <source>The UPDATE-FROM idea is an extension to SQL that allows an UPDATE statement to be driven by other tables in the database. The &quot;target&quot; table is the specific table that is being updated. With UPDATE-FROM you can join the target table against other tables in the database in order to help compute which rows need updating and what the new values should be on those rows. UPDATE-FROM is supported beginning in SQLite version 3.33.0 (2020-08-14).</source>
          <target state="translated">UPDATE-FROM思想是对SQL的一种扩展,它允许UPDATE语句由数据库中的其他表驱动。&quot;目标 &quot;表是被更新的特定表。通过UPDATE-FROM,你可以将目标表与数据库中的其他表联合起来,以帮助计算哪些行需要更新,以及这些行的新值应该是什么。从SQLite 3.33.0版本(2020-08-14)开始支持UPDATE-ROM。</target>
        </trans-unit>
        <trans-unit id="a45a66b4cdc4b1cad87f2ad44961d2b0a1e7cb34" translate="yes" xml:space="preserve">
          <source>The Use Of assert() In SQLite</source>
          <target state="translated">在SQLite中使用 assert()</target>
        </trans-unit>
        <trans-unit id="91cb86d3be85bb36d2918c344be4f7a7dbe55738" translate="yes" xml:space="preserve">
          <source>The VACUUM INTO command is transactional in the sense that the generated output database is a consistent snapshot of the original database. However, if the VACUUM INTO command is interrupted by an unplanned shutdown or power lose, then the generated output database might be incomplete and corrupt. Also, SQLite does not invoke fsync() or FlushFileBuffers() on the generated database to ensure that it has reached non-volatile storage before completing.</source>
          <target state="translated">VACUUM INTO 命令是事务性的,因为生成的输出数据库是原始数据库的一致快照。然而,如果VACUUM INTO命令被意外的关机或断电打断,那么生成的输出数据库可能是不完整的和损坏的。另外,SQLite不会在生成的数据库上调用fsync()或FlushFileBuffers(),以确保它在完成之前已经到达非易失性存储。</target>
        </trans-unit>
        <trans-unit id="122691010e5d737070edb247661b2776162b982c" translate="yes" xml:space="preserve">
          <source>The VACUUM INTO command works the same way except that it uses the file named on the INTO clause in place of the temporary database and omits the step of copying the vacuumed database back over top of the original database.</source>
          <target state="translated">VACUUM INTO命令的工作方式是一样的,只是它使用INTO子句上命名的文件来代替临时数据库,并且省略了将真空数据库复制回原始数据库之上的步骤。</target>
        </trans-unit>
        <trans-unit id="7b858ec9bacb824cb3d161c5dbed06b788759184" translate="yes" xml:space="preserve">
          <source>The VACUUM command may change the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWIDs&lt;/a&gt; of entries in any tables that do not have an explicit &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;.</source>
          <target state="translated">VACUUM命令可以更改没有显式&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY的&lt;/a&gt;任何表中条目的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="41696dc3c99878e16f90bac54782d308e462d0f3" translate="yes" xml:space="preserve">
          <source>The VACUUM command now works with the non-callback API</source>
          <target state="translated">VACUUM命令现在可以和非回调API一起使用。</target>
        </trans-unit>
        <trans-unit id="27866863317458114de851c82a30b86b318d52b6" translate="yes" xml:space="preserve">
          <source>The VACUUM command rebuilds the database file, repacking it into a minimal amount of disk space. There are several reasons an application might do this:</source>
          <target state="translated">VACUUM命令重建数据库文件,将其重新打包成最小的磁盘空间。一个应用程序可能会这样做有几个原因。</target>
        </trans-unit>
        <trans-unit id="9aa5f71406817eba130230946d703a26da25090a" translate="yes" xml:space="preserve">
          <source>The VACUUM command with an INTO clause is an alternative to the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt; for generating backup copies of a live database. The advantage of using VACUUM INTO is that the resulting backup database is minimal in size and hence the amount of filesystem I/O may be reduced. Also, all deleted content is purged from the backup, leaving behind no forensic traces. On the other hand, the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt; uses fewer CPU cycles and can be executed incrementally.</source>
          <target state="translated">带有INTO子句的VACUUM命令是&lt;a href=&quot;backup&quot;&gt;备用API&lt;/a&gt;的替代方法，用于生成实时数据库的备份副本。使用VACUUM INTO的优点在于，生成的备份数据库的大小最小，因此可以减少文件系统I / O的数量。此外，所有已删除的内容将从备份中清除，不留任何取证痕迹。另一方面，&lt;a href=&quot;backup&quot;&gt;备份API&lt;/a&gt;使用较少的CPU周期，并且可以增量执行。</target>
        </trans-unit>
        <trans-unit id="e0a189fd9e3d1e02aa0528451d9b2483299ef4e9" translate="yes" xml:space="preserve">
          <source>The VACUUM command works by copying the contents of the database into a temporary database file and then overwriting the original with the contents of the temporary file. When overwriting the original, a rollback journal or &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; WAL file is used just as it would be for any other database transaction. This means that when VACUUMing a database, as much as twice the size of the original database file is required in free disk space.</source>
          <target state="translated">VACUUM命令的工作方式是将数据库的内容复制到一个临时数据库文件中，然后用该临时文件的内容覆盖原始文件。覆盖原始文件时，将使用回滚日志或&lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt; WAL文件，就像处理任何其他数据库事务一样。这意味着在对数据库进行VACUUM时，所需的可用磁盘空间是原始数据库文件大小的两倍。</target>
        </trans-unit>
        <trans-unit id="778738485f953e3a9b76b31822d939e887b55074" translate="yes" xml:space="preserve">
          <source>The VALUE and HIWTR columns report the current value of the measure and its &quot;high-water mark&quot;. The high-water mark is the highest value ever seen for the measurement, at least since the last reset. The SQLITE_MEMSTAT virtual table does not provide a mechanism for resetting the high-water mark.</source>
          <target state="translated">VALUE(值)和HIWTR(高水位线)列报告测量值的当前值及其 &quot;高水位线&quot;。高水位线是测量的最高值,至少是自上次重置以来的最高值。SQLITE_MEMSTAT虚拟表不提供重置高水位标记的机制。</target>
        </trans-unit>
        <trans-unit id="1b2ece5b4ab8b91b62ace8f0cc0040f19a643253" translate="yes" xml:space="preserve">
          <source>The VALUES clause</source>
          <target state="translated">VALUES条款</target>
        </trans-unit>
        <trans-unit id="b8a859f7de071f48cff5a7fe9193dabc82e472c2" translate="yes" xml:space="preserve">
          <source>The VALUES clause of an INSERT can now contain expressions, including scalar SELECT clauses.</source>
          <target state="translated">INSERT的VALUES子句现在可以包含表达式,包括标量SELECT子句。</target>
        </trans-unit>
        <trans-unit id="222a8cea06637d3ca462a60582d77b6f51ecd46d" translate="yes" xml:space="preserve">
          <source>The VDBE code generated by the above statement looks like the following:</source>
          <target state="translated">上述语句生成的VDBE代码如下。</target>
        </trans-unit>
        <trans-unit id="914b54584037bedb35946860061828500f1bc504" translate="yes" xml:space="preserve">
          <source>The VDBE code generated for this query is as follows:</source>
          <target state="translated">本次查询生成的VDBE代码如下。</target>
        </trans-unit>
        <trans-unit id="44e862e51e63dc8e6d2cfc4ebc01e6bf18bd5d5d" translate="yes" xml:space="preserve">
          <source>The VDBE implements a virtual computer that runs a program in its virtual machine language. The goal of each program is to interrogate or change the database. Toward this end, the machine language that the VDBE implements is specifically designed to search, read, and modify databases.</source>
          <target state="translated">VDBE实现了一台虚拟计算机,用其虚拟机语言运行程序。每个程序的目标是查询或修改数据库。为此,VDBE实现的机器语言是专门设计用来搜索、读取和修改数据库的。</target>
        </trans-unit>
        <trans-unit id="2dceeabf6f031eb26374896fc49e25ce44afb511" translate="yes" xml:space="preserve">
          <source>The VDBE program generated for this SQL statement is as follows:</source>
          <target state="translated">该SQL语句生成的VDBE程序如下。</target>
        </trans-unit>
        <trans-unit id="80bc0b2de97d753f617c4eaf5d3c9b6776ea43cf" translate="yes" xml:space="preserve">
          <source>The VERSION table shown above has columns to record a check-in comment (presumably supplied by the user) and the time and date at which the File/Save action occurred. It also records the parent version to record the history of changes. Perhaps the manifest could be stored as a delta from the parent version, though typically the manifest will be small enough that storing a delta might be more trouble than it is worth. The SLIDE table also contains a derivedFrom column which could be used for delta encoding if it is determined that saving the slide content as a delta from its previous version is a worthwhile optimization.</source>
          <target state="translated">上图所示的版本表有一列记录签入注释(大概是由用户提供的)和文件/保存操作发生的时间和日期。它还记录了父版本,以记录更改的历史。也许清单可以作为父版本的delta存储,尽管通常清单会小到存储delta可能会比它的价值更麻烦。SLIDE表还包含一个derivedFrom列,如果确定将幻灯片内容保存为上一个版本的delta是一个值得优化的地方,那么这个列可以用于delta编码。</target>
        </trans-unit>
        <trans-unit id="1b59010289d2579bd6e51282e421f222dba65ae2" translate="yes" xml:space="preserve">
          <source>The VFS interface is sometimes extended by adding new methods onto the end. Each time such an extension occurs, the iVersion field is incremented. The iVersion value started out as 1 in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; on 2007-09-04, then increased to 2 with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; on 2010-07-21, and then increased to 3 with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;version 3.7.6&lt;/a&gt; on 2011-04-12. Additional fields may be appended to the sqlite3_vfs object and the iVersion value may increase again in future versions of SQLite. Note that due to an oversight, the structure of the sqlite3_vfs object changed in the transition from SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_9.html&quot;&gt;version 3.5.9&lt;/a&gt; to &lt;a href=&quot;https://sqlite.org/releaselog/3_6_0.html&quot;&gt;version 3.6.0&lt;/a&gt; on 2008-07-16 and yet the iVersion field was not increased.</source>
          <target state="translated">有时会通过在末尾添加新方法来扩展VFS接口。每次发生此类扩展时，iVersion字段都会增加。 iVersion值在2007-09-04的SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;3.5.0版本中&lt;/a&gt;从1开始，然后在2010-07-21的SQLite&lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;版本3.7.0中&lt;/a&gt;增加到2 ，然后在2011年的SQLite&lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;版本3.7.6中&lt;/a&gt;增加到3 。 -04-12。其他字段可能会附加到sqlite3_vfs对象，并且在将来的SQLite版本中iVersion值可能会再次增加。请注意，由于疏忽，sqlite3_vfs对象的结构在2008年7月16日从SQLite&lt;a href=&quot;https://sqlite.org/releaselog/3_5_9.html&quot;&gt;版本3.5.9&lt;/a&gt;过渡到&lt;a href=&quot;https://sqlite.org/releaselog/3_6_0.html&quot;&gt;版本3.6.0时发生&lt;/a&gt;了变化，但iVersion字段并未增加。</target>
        </trans-unit>
        <trans-unit id="0766456a2002e4475782706d0b0fb713540038a5" translate="yes" xml:space="preserve">
          <source>The VFS interface is sometimes extended by adding new methods onto the end. Each time such an extension occurs, the iVersion field is incremented. The iVersion value started out as 1 in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; on 2007-09-04, then increased to 2 with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; on 2010-07-21, and then increased to 3 with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;version 3.7.6&lt;/a&gt; on 2011-04-12. Additional fields may be appended to the sqlite3_vfs object and the iVersion value may increase again in future versions of SQLite. Note that the structure of the sqlite3_vfs object changes in the transition from SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_9.html&quot;&gt;version 3.5.9&lt;/a&gt; to &lt;a href=&quot;https://sqlite.org/releaselog/3_6_0.html&quot;&gt;version 3.6.0&lt;/a&gt; on 2008-07-16 and yet the iVersion field was not modified.</source>
          <target state="translated">有时会通过在末尾添加新方法来扩展VFS接口。每次发生此类扩展时，iVersion字段都会增加。 iVersion值在2007-09-04的SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;3.5.0版中&lt;/a&gt;从1开始，然后在2010-07-21的SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;3.7.0版中&lt;/a&gt;增加到2 ，然后在2011年的SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;3.7.6版中&lt;/a&gt;增加到3 。 -04-12。其他字段可能会附加到sqlite3_vfs对象，并且在将来的SQLite版本中iVersion值可能会再次增加。请注意，sqlite3_vfs对象的结构在2008年7月16日从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_9.html&quot;&gt;版本3.5.9&lt;/a&gt;过渡到&lt;a href=&quot;https://sqlite.org/releaselog/3_6_0.html&quot;&gt;版本3.6.0&lt;/a&gt;时发生了变化，但iVersion字段未修改。</target>
        </trans-unit>
        <trans-unit id="9428f4f61873bedbb7fa546ce9da2878f0f6b46f" translate="yes" xml:space="preserve">
          <source>The VFS specified by a URI has the highest priority. After that comes a VFS specified as the fourth argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The default VFS is used if no VFS is specified otherwise.</source>
          <target state="translated">URI指定的VFS具有最高优先级。之后，将一个VFS指定为&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;的第四个参数。如果未指定其他VFS，则使用默认VFS。</target>
        </trans-unit>
        <trans-unit id="59f617b8350433543bfe3f6503e9062a84ed6414" translate="yes" xml:space="preserve">
          <source>The Virtual Database Engine of SQLite</source>
          <target state="translated">SQLite的虚拟数据库引擎</target>
        </trans-unit>
        <trans-unit id="2fc007776417aa54116dbc71f8065ab7e3ac76ea" translate="yes" xml:space="preserve">
          <source>The Virtual Table Mechanism Of SQLite</source>
          <target state="translated">SQLite的虚拟表机制</target>
        </trans-unit>
        <trans-unit id="4a47770692c502c7c39564cd0fc7b210860b676a" translate="yes" xml:space="preserve">
          <source>The WAL approach inverts this. The original content is preserved in the database file and the changes are appended into a separate WAL file. A &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; occurs when a special record indicating a commit is appended to the WAL. Thus a COMMIT can happen without ever writing to the original database, which allows readers to continue operating from the original unaltered database while changes are simultaneously being committed into the WAL. Multiple transactions can be appended to the end of a single WAL file.</source>
          <target state="translated">WAL的方法反过来了。原始内容保留在数据库文件中，而更改将附加到单独的WAL文件中。甲&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;当指示一个提交一个特殊的记录被追加到WAL发生。因此，即使不写入原始数据库也可以发生COMMIT，这允许读者在更改同时提交到WAL的同时继续从原始未更改的数据库进行操作。可以将多个事务附加到单个WAL文件的末尾。</target>
        </trans-unit>
        <trans-unit id="82b1501dab1e647276daeb770adadd0f94b39bd1" translate="yes" xml:space="preserve">
          <source>The WAL file can optionally be truncated on a reset, but it need not be. Performance is usually a little better if the WAL is not truncated, since filesystems generally will overwrite an existing file faster than they will grow a file.</source>
          <target state="translated">WAL文件可以在重置时选择截断,但不必截断。如果WAL不被截断,性能通常会更好一些,因为文件系统通常会覆盖一个现有的文件,而不是增长一个文件。</target>
        </trans-unit>
        <trans-unit id="6ee114cc7fc43aace09ed2f31fdb137fc0cc57b0" translate="yes" xml:space="preserve">
          <source>The WAL file exists for as long as any &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; has the database open. Usually, the WAL file is deleted automatically when the last connection to the database closes. However, if the last process to have the database open exits without cleanly shutting down the database connection, or if the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;file control&lt;/a&gt; is used, then the WAL file might be retained on disk after all connections to the database have been closed. The WAL file is part of the persistent state of the database and should be kept with the database if the database is copied or moved. If a database file is separated from its WAL file, then transactions that were previously committed to the database might be lost, or the database file might become corrupted. The only safe way to remove a WAL file is to open the database file using one of the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; interfaces then immediately close the database using &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">只要任何&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;都打开了数据库，WAL文件就存在。通常，当与数据库的最后一个连接关闭时，WAL文件会自动删除。但是，如果退出数据库的最后一个进程退出而没有干净地关闭数据库连接，或者&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL &lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;文件控件&lt;/a&gt;使用WAL，则在关闭与数据库的所有连接之后，WAL文件可能会保留在磁盘上。 WAL文件是数据库持久状态的一部分，如果复制或移动了数据库，则WAL文件应与数据库一起保存。如果将数据库文件与其WAL文件分开，则先前提交给该数据库的事务可能会丢失，或者该数据库文件可能会损坏。删除WAL文件的唯一安全方法是使用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;接口之一打开数据库文件，然后立即使用&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;关闭数据库。</target>
        </trans-unit>
        <trans-unit id="79014b745cf0a5f8595085db33b3a7e639f66d1c" translate="yes" xml:space="preserve">
          <source>The WAL header is 32 bytes in size and consists of the following eight big-endian 32-bit unsigned integer values:</source>
          <target state="translated">WAL头大小为32字节,由以下8个32位无符号整数大段值组成。</target>
        </trans-unit>
        <trans-unit id="3ad8fc65cf4c28a6553ebe75589fa3de09b97b25" translate="yes" xml:space="preserve">
          <source>The WAL journal mode will be set on all connections to the same database file if it is set on any one connection.</source>
          <target state="translated">如果在任何一个连接上设置了WAL日志模式,则会在所有连接上设置为同一个数据库文件。</target>
        </trans-unit>
        <trans-unit id="c2da5fc09a01446274895178b9f5584cc12d72c9" translate="yes" xml:space="preserve">
          <source>The WAL journaling mode uses a &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; instead of a rollback journal to implement transactions. The WAL journaling mode is persistent; after being set it stays in effect across multiple database connections and after closing and reopening the database. A database in WAL journaling mode can only be accessed by SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21) or later.</source>
          <target state="translated">WAL 日记模式使用&lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt;而不是回滚日记来实现事务。WAL日记记录模式是持久的；设置后，它在多个数据库连接中有效，并且在关闭并重新打开数据库后仍然有效。WAL日记模式下的数据库只能由SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;3.7.0版&lt;/a&gt;（2010-07-21）或更高版本访问。</target>
        </trans-unit>
        <trans-unit id="bbeadb5beff9552e41ebfc0aed8339e43743fd64" translate="yes" xml:space="preserve">
          <source>The WAL-index format version number. Always 3007000.</source>
          <target state="translated">WAL-index格式版本号。总是3007000。</target>
        </trans-unit>
        <trans-unit id="a0470594be37c3f0ff60237d02ae37bf43150bc8" translate="yes" xml:space="preserve">
          <source>The WAL-index or &quot;shm&quot; file is used to coordinate access to the database by multiple clients, and as a cache to help clients quickly locate frames within the wal file.</source>
          <target state="translated">WAL-index或 &quot;shm &quot;文件用于协调多个客户端对数据库的访问,并作为缓存帮助客户端快速定位wal文件中的帧。</target>
        </trans-unit>
        <trans-unit id="3fa0bf716018ca8d2c184cf21d82cae1245d9415" translate="yes" xml:space="preserve">
          <source>The WAL_CKPT_LOCK is only locked exclusively. There is never a shared lock taken on WAL_CKPT_LOCK.</source>
          <target state="translated">WAL_CKPT_LOCK只是独家锁定。WAL_CKPT_LOCK上永远不会有共享锁。</target>
        </trans-unit>
        <trans-unit id="42d567271c4a4abf54f649e6218b2a342b7491c5" translate="yes" xml:space="preserve">
          <source>The WAL_RECOVER_LOCK is only locked exclusively. There is never a shared lock taken on WAL_RECOVER_LOCK.</source>
          <target state="translated">WAL_RECOVER_LOCK只是独家锁定。在WAL_RECOVER_LOCK上永远不会采取共享锁。</target>
        </trans-unit>
        <trans-unit id="f378361895c3312e72c176b00bbf1af957e8b29d" translate="yes" xml:space="preserve">
          <source>The WAL_WRITE_LOCK is only locked exclusively. There is never a shared lock taken on WAL_WRITE_LOCK.</source>
          <target state="translated">WAL_WRITE_LOCK只是独家锁定。在WAL_WRITE_LOCK上永远不会采取共享锁。</target>
        </trans-unit>
        <trans-unit id="cddb2fff96db0eb2561a8fa9288188bd61c4a17a" translate="yes" xml:space="preserve">
          <source>The WHERE clause is implemented by instructions 6 through 8. The job of the where clause is to skip the ListWrite if the WHERE condition is false. To this end, it jumps ahead to the Next instruction if the &quot;two&quot; column (extracted by the Column instruction) is greater than or equal to 50.</source>
          <target state="translated">WHERE子句由指令6到8实现。where子句的工作是,如果where条件为假,则跳过ListWrite。为此,如果 &quot;二 &quot;列(由Column指令提取)大于或等于50,它就跳转到Next指令。</target>
        </trans-unit>
        <trans-unit id="29f1ffc6e309ea1c4b2ff1d0678fe7459979e894" translate="yes" xml:space="preserve">
          <source>The WHERE clause on a query is broken up into &quot;terms&quot; where each term is separated from the others by an AND operator. If the WHERE clause is composed of constraints separate by the OR operator then the entire clause is considered to be a single &quot;term&quot; to which the &lt;a href=&quot;#or_opt&quot;&gt;OR-clause optimization&lt;/a&gt; is applied.</source>
          <target state="translated">查询中的WHERE子句分为&amp;ldquo;条款&amp;rdquo;，其中每个条款都由AND运算符隔开。如果WHERE子句由由OR运算符分隔的约束组成，则整个子句将被视为应用&lt;a href=&quot;#or_opt&quot;&gt;OR子句优化&lt;/a&gt;的单个&amp;ldquo;项&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="61aac901b9e999b70442566c55c7589fe615eca3" translate="yes" xml:space="preserve">
          <source>The WHERE clause on a query is broken up into &quot;terms&quot; where each term is separated from the others by an AND operator. If the WHERE clause is composed of constraints separated by the OR operator then the entire clause is considered to be a single &quot;term&quot; to which the &lt;a href=&quot;#or_opt&quot;&gt;OR-clause optimization&lt;/a&gt; is applied.</source>
          <target state="translated">查询中的WHERE子句分为&amp;ldquo;条款&amp;rdquo;，其中每个条款都由AND运算符分隔。如果WHERE子句由由OR运算符分隔的约束组成，则将整个子句视为对其应用&lt;a href=&quot;#or_opt&quot;&gt;OR子句优化&lt;/a&gt;的单个&amp;ldquo;术语&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="67af3225970c5961856bbb922d2677740529dd45" translate="yes" xml:space="preserve">
          <source>The WINDOW clause, when one is present, comes after any HAVING clause and before any ORDER BY.</source>
          <target state="translated">WINDOW子句,当有一个子句存在时,在任何HAVING子句之后,在任何ORDER BY之前。</target>
        </trans-unit>
        <trans-unit id="59f006cfccb1b0c07b582f38b2b03e476dd1faa4" translate="yes" xml:space="preserve">
          <source>The WITH Clause</source>
          <target state="translated">WITH条款</target>
        </trans-unit>
        <trans-unit id="49bb3b8074d7fe6469254452d39dc417f079e333" translate="yes" xml:space="preserve">
          <source>The WITH clause cannot be used within a &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;.</source>
          <target state="translated">WITH子句不能在&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER中使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="469f423bf145b329a62c79e892ff06f00b735aaa" translate="yes" xml:space="preserve">
          <source>The WITH clause must appear at the beginning of a top-level &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement or at the beginning of a subquery. The WITH clause cannot be prepended to the second or subsequent SELECT statement of a &lt;a href=&quot;lang_select#compound&quot;&gt;compound select&lt;/a&gt;.</source>
          <target state="translated">WITH子句必须出现在顶级&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句的开头或子查询的开头。WITH子句不能放在&lt;a href=&quot;lang_select#compound&quot;&gt;复合select&lt;/a&gt;的第二个或后续SELECT语句之前。</target>
        </trans-unit>
        <trans-unit id="0790118e4cc64a2949db095a0b8b9579da7d5654" translate="yes" xml:space="preserve">
          <source>The WITHOUT ROWID optimization is likely to be helpful for tables that have non-integer or composite (multi-column) PRIMARY KEYs and that do not store large strings or BLOBs.</source>
          <target state="translated">WITHOUT ROWID优化可能对那些有非整数或复合(多列)PRIMARY KEY,且不存储大字符串或BLOB的表有帮助。</target>
        </trans-unit>
        <trans-unit id="b74650aa10ba4b42e039edd4a2cc74f6b68fb08b" translate="yes" xml:space="preserve">
          <source>The WITHOUT ROWID syntax is an optimization. It provides no new capabilities. Anything that can be done using a WITHOUT ROWID table can also be done in exactly the same way, and exactly the same syntax, using an ordinary rowid table. The only advantage of a WITHOUT ROWID table is that it can sometimes use less disk space and/or perform a little faster than an ordinary rowid table.</source>
          <target state="translated">WITHOUT ROWID 语法是一种优化。它没有提供新的功能。任何可以用WITHOUT ROWID表完成的事情,也可以用普通的rowid表以完全相同的方式和语法完成。WITHOUT ROWID表的唯一优点是它有时可以比普通的rowid表使用更少的磁盘空间和/或执行更快一些。</target>
        </trans-unit>
        <trans-unit id="d5d979d02523b8b3c921a385853078f31581834f" translate="yes" xml:space="preserve">
          <source>The WITHOUT ROWID table that has the same structure as the t1bc index would look like this:</source>
          <target state="translated">与t1bc索引结构相同的WITHOUT ROWID表是这样的。</target>
        </trans-unit>
        <trans-unit id="ebd241bcb9edacf4c26a21a11fc0d3a7cc0b5d00" translate="yes" xml:space="preserve">
          <source>The X callback is invoked whenever any of the events identified by mask M occur. The integer return value from the callback is currently ignored, though this may change in future releases. Callback implementations should return zero to ensure future compatibility.</source>
          <target state="translated">每当掩码M标识的任何事件发生时,X回调就会被调用。目前,回调的整数返回值被忽略,但这在未来的版本中可能会改变。回调实现应该返回零,以确保未来的兼容性。</target>
        </trans-unit>
        <trans-unit id="d9560a5bff3ce71963e342a5450ede2debbbea82" translate="yes" xml:space="preserve">
          <source>The aConstraintUsage[] array contains one element for each of the nConstraint constraints in the inputs section of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure. The aConstraintUsage[] array is used by xBestIndex to tell the core how it is using the constraints.</source>
          <target state="translated">对于&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;结构的输入部分中的每个nConstraint约束，aConstraintUsage []数组包含一个元素。xBestIndex使用aConstraintUsage []数组来告诉核心如何使用约束。</target>
        </trans-unit>
        <trans-unit id="3276fd18c87b4e795759956677bbdc04f564672d" translate="yes" xml:space="preserve">
          <source>The aConstraint[] array contains information about all constraints that apply to the virtual table. But some of the constraints might not be usable because of the way tables are ordered in a join. The xBestIndex method must therefore only consider constraints that have an aConstraint[].usable flag which is true.</source>
          <target state="translated">aConstraint[]数组包含了适用于虚拟表的所有约束的信息。但是由于表在连接中的排序方式,有些约束可能是不可用的。因此,xBestIndex方法必须只考虑aConstraint[].usable标志为true的约束。</target>
        </trans-unit>
        <trans-unit id="08f35e14867214bff1de15c06eccca3a8c64a445" translate="yes" xml:space="preserve">
          <source>The aConstraint[] array records WHERE clause constraints of the form:</source>
          <target state="translated">aConstraint[]数组记录了WHERE子句约束的形式。</target>
        </trans-unit>
        <trans-unit id="aa76ffefd4dca402e0d001507eec1df576521017" translate="yes" xml:space="preserve">
          <source>The ability for the recursive-select to be a compound was added in &lt;a href=&quot;https://sqlite.org/releaselog/3_34_0.html&quot;&gt;version 3.34.0&lt;/a&gt; (2020-12-01). In earlier versions of SQLite, the recursive-select could only be a single simple SELECT statement.</source>
          <target state="translated">在&lt;a href=&quot;https://sqlite.org/releaselog/3_34_0.html&quot;&gt;版本3.34.0&lt;/a&gt;（2020-12-01）中添加了将递归选择作为化合物的功能。在早期版本的SQLite中，递归选择只能是单个简单的SELECT语句。</target>
        </trans-unit>
        <trans-unit id="cb4f46690b6dce470ed710606d550164c584726b" translate="yes" xml:space="preserve">
          <source>The ability to add &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, including aggregate and table-valued functions.</source>
          <target state="translated">添加&lt;a href=&quot;appfunc&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;（包括聚合函数和表值函数）的能力。</target>
        </trans-unit>
        <trans-unit id="201991425b66ed2865e7a91ab0511b280556125f" translate="yes" xml:space="preserve">
          <source>The ability to add &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;, including aggregate and table-valued functions.</source>
          <target state="translated">添加&lt;a href=&quot;c3ref/create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;（包括聚合函数和表值函数）的能力。</target>
        </trans-unit>
        <trans-unit id="a3094b48cb721d2768a7d14f0821434de8cd0a90" translate="yes" xml:space="preserve">
          <source>The ability to index expressions was added to SQLite with &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). A database that uses an index on expressions will not be usable by earlier versions of SQLite.</source>
          <target state="translated">索引表达式的功能已添加到&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;版本3.9.0&lt;/a&gt;（2015-10-14）的SQLite中。在早期版本的SQLite中将无法使用在表达式上使用索引的数据库。</target>
        </trans-unit>
        <trans-unit id="e647580ce3a971bdf9683f9f823fdf4aa9345057" translate="yes" xml:space="preserve">
          <source>The ability to store BLOBs in indexed columns.</source>
          <target state="translated">能够在索引列中存储BLOBs。</target>
        </trans-unit>
        <trans-unit id="2b4889307c133133bf332e84c716afd8e6689ea5" translate="yes" xml:space="preserve">
          <source>The ability to use keywords as identifiers promotes backwards compatibility. As new keywords are added, legacy schemas that just happen to use those keywords as table or column names continue to work. However, the ability to use a keyword as an identifier sometimes leads to surprising outcomes. For example:</source>
          <target state="translated">使用关键字作为标识符的能力促进了向后兼容性。随着新关键字的添加,刚好使用这些关键字作为表或列名的遗留模式可以继续工作。然而,使用关键字作为标识符的能力有时会导致令人惊讶的结果。例如</target>
        </trans-unit>
        <trans-unit id="4e7fcdb984584a84897317afa23740edc4a933b7" translate="yes" xml:space="preserve">
          <source>The above code creates a new table named &lt;b&gt;t1&lt;/b&gt; with columns &lt;b&gt;a&lt;/b&gt; and &lt;b&gt;b&lt;/b&gt;. What could be simpler?</source>
          <target state="translated">上面的代码使用&lt;b&gt;a&lt;/b&gt;和&lt;b&gt;b&lt;/b&gt;列创建了一个名为&lt;b&gt;t1&lt;/b&gt;的新表。有什么可能更简单？&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1e597cdc48d987ee3a37507f5f4f64e4eebc9821" translate="yes" xml:space="preserve">
          <source>The above command should be run from the MSVC Native Tools Command Prompt. If you have MSVC installed on your machine, you probably have multiple versions of this Command Prompt, for native builds for x86 and x64, and possibly also for cross-compiling to ARM. Use the appropriate Command Prompt depending on the desired DLL.</source>
          <target state="translated">上述命令应该从MSVC Native Tools命令提示符中运行。如果您的机器上安装了MSVC,您可能有多个版本的命令提示符,用于x86和x64的本地构建,也可能用于交叉编译到ARM。根据所需的 DLL,使用适当的命令提示符。</target>
        </trans-unit>
        <trans-unit id="40e5d3c82a1f28fca2d855ebabf947c2e6309d01" translate="yes" xml:space="preserve">
          <source>The above is all you really need to know in order to use SQLite in your C or C++ programs. There are other interface functions available (and described below) but we will begin by describing the core functions shown above.</source>
          <target state="translated">以上就是在C或C++程序中使用SQLite所需要了解的全部内容。还有其他的接口函数可以使用(下面会介绍),但我们将从描述上面所示的核心函数开始。</target>
        </trans-unit>
        <trans-unit id="e1d8b560084e958b9b180ef1ea3e4c34811a8e33" translate="yes" xml:space="preserve">
          <source>The above means that executing the 'merge' command with a negative parameter until the before and after difference in the return value of &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; is less than two optimizes the FTS index in the same way as the &lt;a href=&quot;fts5#the_optimize_command&quot;&gt;FTS5 optimize command&lt;/a&gt;. However, if a new b-tree is added to the FTS index while this process is ongoing, FTS5 will move the new b-tree to the same level as the existing b-trees and restart the merge. To avoid this, only the first call to 'merge' should specify a negative parameter. Each subsequent call to 'merge' should specify a positive value so that the merge started by the first call is run to completion even if new b-trees are added to the FTS index.</source>
          <target state="translated">上面的意思是执行一个带有负参数的'merge'命令直到&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;的返回值的前后差小于2时，以与&lt;a href=&quot;fts5#the_optimize_command&quot;&gt;FTS5优化命令&lt;/a&gt;相同的方式优化FTS索引。但是，如果在此过程进行中将新的b树添加到FTS索引中，则FTS5会将新的b树移动到与现有b树相同的级别，然后重新开始合并。为避免这种情况，只有第一次调用&amp;ldquo; merge&amp;rdquo;时才应指定否定参数。以后每次对&amp;ldquo; merge&amp;rdquo;的调用都应指定一个正值，这样即使将新的b树添加到FTS索引中，由第一个调用开始的合并也将运行到完成。</target>
        </trans-unit>
        <trans-unit id="a9200726c1128b95e04b731c9b7e036f2a699198" translate="yes" xml:space="preserve">
          <source>The above two assumptions may be interpreted to mean that if a system failure occurs after file truncation but before the truncated file is</source>
          <target state="translated">以上两个假设可以解释为,如果系统故障发生在文件截断之后,但在截断的文件被</target>
        </trans-unit>
        <trans-unit id="63e4faf9292fbb17cef84d7ffb499ec94358865c" translate="yes" xml:space="preserve">
          <source>The above will return something like this:</source>
          <target state="translated">上面会返回类似这样的东西。</target>
        </trans-unit>
        <trans-unit id="0861e077c18aeb6848f0b5c9c63fbc9c90c17596" translate="yes" xml:space="preserve">
          <source>The abs(X) function returns the absolute value of the numeric argument X. Abs(X) returns NULL if X is NULL. Abs(X) returns 0.0 if X is a string or blob that cannot be converted to a numeric value. If X is the integer -9223372036854775808 then abs(X) throws an integer overflow error since there is no equivalent positive 64-bit two complement value.</source>
          <target state="translated">如果X为NULL,则Abs(X)返回NULL。如果X是一个不能转换为数值的字符串或blob,则abs(X)返回0.0。如果X是整数-9223372036854775808,那么abs(X)会抛出一个整数溢出错误,因为不存在等价的64位正二补值。</target>
        </trans-unit>
        <trans-unit id="3eb517318225f5fe795733968275ce4a51bc681e" translate="yes" xml:space="preserve">
          <source>The absolute value of this integer argument is used as the (approximate) number of tokens to include in the returned text value. The maximum allowable absolute value is 64. The value of this argument is referred to as</source>
          <target state="translated">这个整数参数的绝对值被用来作为返回的文本值中包含的(近似)标记数量。最大允许的绝对值是64。这个参数的值被称为</target>
        </trans-unit>
        <trans-unit id="85ca4a9788c6f1b476159c0eeb6719f0a0122577" translate="yes" xml:space="preserve">
          <source>The acctchng_magnitude index is over the account number (&quot;acct_no&quot;) and on the absolute value of the amount. This index allows one to do efficient queries over the magnitude of a change to the account. For example, to list all changes to account number $xyz that are more than $100.00, one can say:</source>
          <target state="translated">acctchng_magnitude索引是关于账号(&quot;acct_no&quot;)和金额的绝对值。这个索引允许我们对账户变化的幅度进行有效的查询。例如,要列出账号$xyz的所有超过100.00美元的变化,可以这样说。</target>
        </trans-unit>
        <trans-unit id="5e14d586171fc852b529e7898dae84a1afce65ec" translate="yes" xml:space="preserve">
          <source>The acronym RBU stands for &quot;Resumable Bulk Update&quot;.</source>
          <target state="translated">RBU是 &quot;Resumable Bulk Update &quot;的缩写。</target>
        </trans-unit>
        <trans-unit id="cd26fea06f2a519581c858bc894c62df5370dfe9" translate="yes" xml:space="preserve">
          <source>The act of deleting a file is expensive on many systems. As an optimization, SQLite can be configured to truncate the journal file to zero bytes in length or overwrite the journal file header with zeros. In either case, the resulting journal file is no longer capable of rolling back and so the transaction still commits. Truncating a file to zero length, like deleting a file, is assumed to be an atomic operation from the point of view of a user process. Overwriting the header of the journal with zeros is not atomic, but if any part of the header is malformed the journal will not roll back. Hence, one can say that the commit occurs as soon as the header is sufficiently changed to make it invalid. Typically this happens as soon as the first byte of the header is zeroed.</source>
          <target state="translated">在许多系统中,删除文件的行为是昂贵的。作为一种优化,SQLite可以被配置为将日志文件截断为零字节长度,或者用零覆盖日志文件头。在这两种情况下,产生的日志文件都不再能够回滚,因此事务仍然会提交。将文件截断为零长度,就像删除文件一样,从用户进程的角度来看,假定是一个原子操作。用零覆盖日志头不是原子操作,但如果日志头的任何部分出现错误,日志就不会回滚。因此,可以说,只要头被充分改变,使其无效,就会发生提交。通常情况下,一旦头的第一个字节被清零,就会发生提交。</target>
        </trans-unit>
        <trans-unit id="eb72a7b6e0cde775aa0861a739588c085322d8b5" translate="yes" xml:space="preserve">
          <source>The action of the preupdate hook is similar to the &lt;a href=&quot;c3ref/update_hook&quot;&gt;update hook&lt;/a&gt; except that the callback is invoked before the change, not afterwards, and the preupdate hook interfaces are omitted unless this compile-time option is used.</source>
          <target state="translated">preupdate挂钩的操作与&lt;a href=&quot;c3ref/update_hook&quot;&gt;更新挂钩&lt;/a&gt;类似，不同之处在于，在更改之前（而不是之后）调用回调，并且除非使用此compile-time选项，否则将忽略preupdate挂钩接口。</target>
        </trans-unit>
        <trans-unit id="d730b41c0c65afc48bf2186d2e78971f79c0ae93" translate="yes" xml:space="preserve">
          <source>The actual remote head</source>
          <target state="translated">实际的遥控头</target>
        </trans-unit>
        <trans-unit id="d5942dd3b483843b4b3b13169967e9623c12cf60" translate="yes" xml:space="preserve">
          <source>The actual value of the automerge parameter determines the number of index segments merged simultaneously by an automatic inverted index merge. If the value is set to N, the system waits until there are at least N segments on a single level before beginning to incrementally merge them. Setting a lower value of N causes segments to be merged more quickly, which may speed up full-text queries and, if the workload contains UPDATE or DELETE operations as well as INSERTs, reduce the space on disk consumed by the full-text index. However, it also increases the amount of data written to disk.</source>
          <target state="translated">automerge参数的实际值决定了自动反向索引合并同时合并的索引段数。如果将该值设置为N,系统会等到单层至少有N个段时才开始递增合并。设置较低的N值会导致段更快地被合并,这可能会加快全文查询的速度,如果工作负载包含UPDATE或DELETE操作以及INSERT,则会减少全文索引消耗的磁盘空间。但是,这也会增加写入磁盘的数据量。</target>
        </trans-unit>
        <trans-unit id="fcad8bd16dfc8bbae32259b89340b3c09c02938b" translate="yes" xml:space="preserve">
          <source>The address of the cell in the parent frame is determined by adding the value of the P1 argument to the value of the P1 argument to the calling &lt;a href=&quot;opcode#Program&quot;&gt;Program&lt;/a&gt; instruction.</source>
          <target state="translated">通过将P1自变量的值与调用&lt;a href=&quot;opcode#Program&quot;&gt;程序&lt;/a&gt;指令的P1自变量的值相加，可以确定父帧中单元的地址。</target>
        </trans-unit>
        <trans-unit id="e600ae2c57bf2172dc311ec955786ffac68bdb53" translate="yes" xml:space="preserve">
          <source>The advantage of the table-valued function format is that the query can return just a subset of the PRAGMA columns, can include a WHERE clause, can use aggregate functions, and the table-valued function can be just one of several data sources in a join. For example, to get a list of all indexed columns in a schema, one could query:</source>
          <target state="translated">表值函数格式的优点是,查询可以只返回PRAGMA列的子集,可以包含WHERE子句,可以使用聚合函数,表值函数可以只是join中几个数据源之一。例如,要得到一个模式中所有索引列的列表,可以查询。</target>
        </trans-unit>
        <trans-unit id="d98ae93ba70e0ca59260993947a4e24c760765d2" translate="yes" xml:space="preserve">
          <source>The advantages of doing many smaller sorts instead of a single large sort are:</source>
          <target state="translated">做许多小的分类而不是单一的大分类的优点是:</target>
        </trans-unit>
        <trans-unit id="c2daf3580eecc6fcaa952d18c4522913579884b0" translate="yes" xml:space="preserve">
          <source>The advertised consequence of most CVEs is &quot;denial of service&quot;, typically by causing a crash through a NULL pointer dereference or a division by zero, or similar.</source>
          <target state="translated">大多数CVE的宣传后果是 &quot;拒绝服务&quot;,通常是通过NULL指针取消引用或除以零或类似的方式导致崩溃。</target>
        </trans-unit>
        <trans-unit id="15b97dc5f9d1078668a6ce572dccbfb387883173" translate="yes" xml:space="preserve">
          <source>The affinity of a column is determined by the declared type of the column, according to the following rules in the order shown:</source>
          <target state="translated">列的亲和力是由列的声明类型决定的,按照下列规则,按所示顺序排列。</target>
        </trans-unit>
        <trans-unit id="81c1ff1ba114ea49399c70cede12a7ccd08cc3d4" translate="yes" xml:space="preserve">
          <source>The affinity of the v1.x column will be the same as the affinity of t1.b (TEXT), since v1.x maps directly into t1.b. But columns v1.y and v1.z both have no affinity, since those columns map into expression a+c and 42, and expressions always have no affinity.</source>
          <target state="translated">v1.x列的亲和力将与t1.b(TEXT)的亲和力相同,因为v1.x直接映射到t1.b。但是v1.y和v1.z列都没有亲和力,因为这些列映射到表达式a+c和42,表达式总是没有亲和力。</target>
        </trans-unit>
        <trans-unit id="ab16418452d7d68b0bd05abd8cefe39ddc38000d" translate="yes" xml:space="preserve">
          <source>The aggregate functions shown below are available by default. Additional aggregate functions written in C may be added using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; API.</source>
          <target state="translated">默认情况下，以下所示的聚合函数可用。可以使用&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt; API 添加用C编写的其他聚合函数。</target>
        </trans-unit>
        <trans-unit id="084c900ab7b78b8fb14c15704a0ab2585c905626" translate="yes" xml:space="preserve">
          <source>The algorithm above works quite well for most cases, but there are exceptions. These exceptions can be dealt with by making additional entries in the virtual table using the &quot;soundslike&quot; column.</source>
          <target state="translated">上面的算法在大多数情况下都很好用,但也有例外。这些例外情况可以通过使用 &quot;soundslike &quot;列在虚拟表中增加条目来处理。</target>
        </trans-unit>
        <trans-unit id="db0be7814305eaba73945c0429fa38151c410e55" translate="yes" xml:space="preserve">
          <source>The algorithm specified in the OR clause of an INSERT or UPDATE overrides any algorithm specified in a CREATE TABLE. If no algorithm is specified anywhere, the ABORT algorithm is used.</source>
          <target state="translated">在INSERT或UPDATE的OR子句中指定的算法会覆盖在CREATE表中指定的任何算法。如果没有指定任何算法,那么就使用ABORT算法。</target>
        </trans-unit>
        <trans-unit id="8f1bb5e260f6d6940f8038960690efd8a13241e0" translate="yes" xml:space="preserve">
          <source>The algorithm used by memsys5 can be called &quot;power-of-two, first-fit&quot;. The sizes of all memory allocation requests are rounded up to a power of two and the request is satisfied by the first free slot in pBuf that is large enough. Adjacent freed allocations are coalesced using a buddy system. When used appropriately, this algorithm provides mathematical guarantees against fragmentation and breakdown, as described further &lt;a href=&quot;#nofrag&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">memsys5使用的算法可以称为&amp;ldquo;二乘幂，优先拟合&amp;rdquo;。所有内存分配请求的大小均四舍五入为2的幂，并且该请求由pBuf中足够大的第一个空闲插槽满足。使用伙伴系统合并相邻的释放分配。当适当地使用，这种算法提供了对破碎和击穿数学担保，进一步描述&lt;a href=&quot;#nofrag&quot;&gt;如下&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="91caf7e2c108fa5ca12a12fe7d7f1b642ba24d6e" translate="yes" xml:space="preserve">
          <source>The algorithm used by the sqlite3_blocking_prepare_v2() function is similar, except that step 4 (resetting the statement handle) is omitted.</source>
          <target state="translated">sqlite3_blocking_prepare_v2()函数使用的算法类似,只是省略了第4步(重置语句句柄)。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
