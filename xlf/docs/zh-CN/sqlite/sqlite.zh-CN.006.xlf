<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="e57ea0e26c7c063563f7c480ba3dfeaecea3cb15" translate="yes" xml:space="preserve">
          <source>An error. &quot;darkstar&quot; is not a recognized authority.</source>
          <target state="translated">一个错误。&quot;黑星 &quot;不是公认的权威。</target>
        </trans-unit>
        <trans-unit id="a9d782005fc023f48e522001d78e4867344c8d47" translate="yes" xml:space="preserve">
          <source>An error. &quot;readonly&quot; is not a valid option for the &quot;mode&quot; parameter.</source>
          <target state="translated">一个错误。&quot;readonly &quot;不是 &quot;模式 &quot;参数的有效选项。</target>
        </trans-unit>
        <trans-unit id="c1dc1f3ba0806333fcf879ed6122522e9f542e04" translate="yes" xml:space="preserve">
          <source>An example of an eponymous virtual table is the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;. To use the dbstat virtual table as an eponymous virtual table, simply query against the &quot;dbstat&quot; module name, as if it were an ordinary table. (Note that SQLite must be compiled with the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; option to include the dbstat virtual table in the build.)</source>
          <target state="translated">&lt;a href=&quot;dbstat&quot;&gt;dbstat虚拟表&lt;/a&gt;就是一个同名虚拟表的示例。要将dbstat虚拟表用作同义的虚拟表，只需查询&amp;ldquo; dbstat&amp;rdquo;模块名称，就好像它是普通表一样。（请注意，必须使用&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt;选项编译SQLite才能在构建中包括dbstat虚拟表。）</target>
        </trans-unit>
        <trans-unit id="d551629b2a32e687e6920a81c2f515bee137ebdf" translate="yes" xml:space="preserve">
          <source>An example use of hidden columns can be seen in the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; virtual table implementation, where every FTS virtual table contains an &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; that is used to pass information from the virtual table into &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt; and to the &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;FTS MATCH&lt;/a&gt; operator.</source>
          <target state="translated">在&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;虚拟表实现中可以看到使用隐藏列的示例，其中每个FTS虚拟表都包含一个&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS隐藏列&lt;/a&gt;，用于将信息从虚拟表传递到&lt;a href=&quot;fts3#snippet&quot;&gt;FTS辅助功能&lt;/a&gt;以及&lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;FTS MATCH&lt;/a&gt;运算符。</target>
        </trans-unit>
        <trans-unit id="9e17bf1221a1fb0282388819bb91b8a5c6ed013a" translate="yes" xml:space="preserve">
          <source>An example will help to clarify this concept. Consider the following query:</source>
          <target state="translated">一个例子将有助于澄清这个概念。考虑以下查询。</target>
        </trans-unit>
        <trans-unit id="0b97feb4054b223de8848c552e7e62e2eeabb327" translate="yes" xml:space="preserve">
          <source>An example: Suppose there are two database connections X and Y. X starts a read transaction using &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; followed by one or more &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. Then Y comes along and runs an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement to modify the database. X can subsequently do a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; against the records that Y modified but X will see the older unmodified entries because Y's changes are all invisible to X while X is holding a read transaction. If X wants to see the changes that Y made, then X must ends its read transaction and start a new one (by running &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; followed by another &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;.)</source>
          <target state="translated">一个示例：假设有两个数据库连接X和Y。X使用&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;和一个或多个&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句启动读取事务。然后，Y出现并运行&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;语句以修改数据库。 X随后可以对Y修改的记录进行&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;，但是X将看到较旧的未修改条目，因为X持有读取事务时，X都看不到Y的更改。如果X要查看Y所做的更改，则X必须结束其读取事务并开始一个新的事务（通过运行&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT，&lt;/a&gt;然后运行另一个&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8b6e6d373bf06dd9c8c05c43eca6f2690b8f93a5" translate="yes" xml:space="preserve">
          <source>An exclusive lock is held on WAL_WRITE_LOCK while adding new frame onto the end of a WAL file.</source>
          <target state="translated">在WAL文件的末尾添加新帧时,WAL_WRITE_LOCK上会有一个专属锁。</target>
        </trans-unit>
        <trans-unit id="472410dd7fa81690261e9f1011036ea0cbeb522e" translate="yes" xml:space="preserve">
          <source>An experimental module providing on-demand read-only access to multiple tables spread across multiple databases, via a single virtual table abstraction.</source>
          <target state="translated">一个实验性的模块,通过单一的虚拟表抽象,提供对分布在多个数据库的多个表的按需只读访问。</target>
        </trans-unit>
        <trans-unit id="667c5b4834a03d379059f491edab75c439a88d3e" translate="yes" xml:space="preserve">
          <source>An expression of the form &quot;CAST(</source>
          <target state="translated">形式为 &quot;CAST(</target>
        </trans-unit>
        <trans-unit id="818ecb03985da596f3eae278c34f7853ab10690e" translate="yes" xml:space="preserve">
          <source>An external content FTS4 table is created by setting the content option to the name of a table (or view, or virtual table) that may be queried by FTS4 to retrieve column values when required. If the nominated table does not exist, then an external content table behaves in the same way as a contentless table. For example:</source>
          <target state="translated">通过将内容选项设置为表(或视图或虚拟表)的名称来创建外部内容FTS4表,该表可在需要时由FTS4查询以检索列值。如果指定的表不存在,那么外部内容表的行为与无内容表相同。例如:</target>
        </trans-unit>
        <trans-unit id="2af47edb4534251424ba986a5ead5c83306505ff" translate="yes" xml:space="preserve">
          <source>An external content FTS5 table is created by setting the content option to the name of a table, virtual table or view (hereafter the &quot;content table&quot;) within the same database. Whenever column values are required by FTS5, it queries the content table as follows, with the rowid of the row for which values are required bound to the SQL variable:</source>
          <target state="translated">通过将内容选项设置为同一数据库中的表、虚拟表或视图(以下简称 &quot;内容表&quot;)的名称来创建外部内容FTS5表。每当FTS5需要列值时,它就会按如下方式查询内容表,并将需要值的行的rowid绑定到SQL变量中。</target>
        </trans-unit>
        <trans-unit id="d52b102f266b0f6f1ccf383a15555d761fab3f49" translate="yes" xml:space="preserve">
          <source>An fts4aux virtual table is constructed with one or two arguments. When used with a single argument, that argument is the unqualified name of the FTS table that it will be used to access. To access a table in a different database (for example, to create a TEMP fts4aux table that will access an FTS3 table in the MAIN database) use the two-argument form and give the name of the target database (ex: &quot;main&quot;) in the first argument and the name of the FTS3/4 table as the second argument. (The two-argument form of fts4aux was added for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;version 3.7.17&lt;/a&gt; (2013-05-20) and will throw an error in prior releases.) For example:</source>
          <target state="translated">fts4aux虚拟表由一个或两个参数构成。当与单个参数一起使用时，该参数是将用于访问的FTS表的非限定名称。要访问其他数据库中的表（例如，创建将访问MAIN数据库中的FTS3表的TEMP fts4aux表），请使用两个参数的形式并指定目标数据库的名称（例如：&amp;ldquo; main&amp;rdquo;）在第一个参数中，将FTS3 / 4表的名称作为第二个参数。 （为SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;3.7.17&lt;/a&gt;（2013-05-20）添加了fts4aux的两个参数形式，它将在以前的版本中引发错误。）例如：</target>
        </trans-unit>
        <trans-unit id="8c25046031c36326ccd0fd6dd82951cf50be0673" translate="yes" xml:space="preserve">
          <source>An fts5vocab table of type &quot;col&quot; contains one row for each distinct term/column combination in the associated FTS5 table. Table columns are as follows:</source>
          <target state="translated">类型为 &quot;col &quot;的fts5vocab表,在相关的fts5表中,每个不同的术语/列组合都包含一行。表列如下:</target>
        </trans-unit>
        <trans-unit id="7f04198cf656fcfcd60de51b84883a5a273fb8d3" translate="yes" xml:space="preserve">
          <source>An fts5vocab table of type &quot;instance&quot; contains one row for each term instance stored in the associated FTS index. Assuming the FTS5 table is created with the 'detail' option set to 'full', table columns are as follows:</source>
          <target state="translated">类型为 &quot;instance &quot;的fts5vocab表包含了存储在相关FTS索引中的每个术语实例的一行。假设创建FTS5表时将 &quot;详细 &quot;选项设置为 &quot;全&quot;,表列如下:</target>
        </trans-unit>
        <trans-unit id="e4f46cd06dd0edb512dbfe5bb420f25b92508728" translate="yes" xml:space="preserve">
          <source>An fts5vocab table of type &quot;row&quot; contains one row for each distinct term in the associated FTS5 table. The table columns are as follows:</source>
          <target state="translated">类型为 &quot;行 &quot;的fts5vocab表,在相关的fts5表中,每个不同的术语都有一行。该表的栏目如下:</target>
        </trans-unit>
        <trans-unit id="23fad742c743a6de68a81185ed3aba6fc3fafba0" translate="yes" xml:space="preserve">
          <source>An identifier for a table or column or variable.</source>
          <target state="translated">表、列或变量的标识符。</target>
        </trans-unit>
        <trans-unit id="0e5d44e56062277710f5511afeab18594a8851fc" translate="yes" xml:space="preserve">
          <source>An implementation of the Guttmann R*Tree spatial index idea.</source>
          <target state="translated">Guttmann R*Tree空间指数思想的实现。</target>
        </trans-unit>
        <trans-unit id="4bd28b3c3d3e6a39cb2320865c316342a20f3142" translate="yes" xml:space="preserve">
          <source>An implicit transaction (a transaction that is started automatically, not a transaction started by BEGIN) is committed automatically when the last active statement finishes. A statement finishes when its last cursor closes, which is guaranteed to happen when the prepared statement is &lt;a href=&quot;c3ref/reset&quot;&gt;reset&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt;. Some statements might &quot;finish&quot; for the purpose of transaction control prior to being reset or finalized, but there is no guarantee of this. The only way to ensure that a statement has &quot;finished&quot; is to invoke &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; on that statement. An open &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; used for incremental BLOB I/O also counts as an unfinished statement. The &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; finishes when it is &lt;a href=&quot;c3ref/blob_close&quot;&gt;closed&lt;/a&gt;.</source>
          <target state="translated">当最后一个活动语句完成时，将自动提交隐式事务（自动启动的事务，而不是由BEGIN启动的事务）。一条语句在其最后一个游标关闭时完成，这可以保证在&lt;a href=&quot;c3ref/reset&quot;&gt;重置&lt;/a&gt;或&lt;a href=&quot;c3ref/finalize&quot;&gt;终止&lt;/a&gt;准备好的语句时发生。某些语句可能会在重置或完成之前出于事务控制的目的而&amp;ldquo;完成&amp;rdquo;，但不能保证这一点。确保语句&amp;ldquo;完成&amp;rdquo;的唯一方法是在该语句上调用&lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;或&lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;。用于增量BLOB I / O 的打开的&lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt;也视为未完成的语句。该&lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt;&lt;a href=&quot;c3ref/blob_close&quot;&gt;关闭&lt;/a&gt;时完成。</target>
        </trans-unit>
        <trans-unit id="79074d6687b22dc4e17257f4e6cee62c251811c4" translate="yes" xml:space="preserve">
          <source>An important feature of transactional databases like SQLite is &quot;atomic commit&quot;. Atomic commit means that either all database changes within a single transaction occur or none of them occur. With atomic commit, it is as if many different writes to different sections of the database file occur instantaneously and simultaneously. Real hardware serializes writes to mass storage, and writing a single sector takes a finite amount of time. So it is impossible to truly write many different sectors of a database file simultaneously and/or instantaneously. But the atomic commit logic within SQLite makes it appear as if the changes for a transaction are all written instantaneously and simultaneously.</source>
          <target state="translated">SQLite等事务性数据库的一个重要特性是 &quot;原子提交&quot;。原子提交是指在一个事务中,要么发生所有的数据库变化,要么不发生任何变化。有了原子提交,就好比对数据库文件不同部分的许多不同写入瞬间同时发生。真正的硬件对大容量存储的写入是串行化的,而写一个扇区需要的时间是有限的。所以真正要同时和/或瞬间写入数据库文件的许多不同扇区是不可能的。但是SQLite内部的原子提交逻辑使得一个事务的变化看起来都是瞬时和同时写入的。</target>
        </trans-unit>
        <trans-unit id="52bb5c1058e3b07cc3eb83a0aae8a367e19c8fb8" translate="yes" xml:space="preserve">
          <source>An imposter table is a table that is attached to the same &lt;a href=&quot;fileformat2#btree&quot;&gt;b-tree&lt;/a&gt; as an index. An imposter table allows the content of an index to be queried or modified as if the index were an ordinary table.</source>
          <target state="translated">冒名顶替者表是与索引附加到同一&lt;a href=&quot;fileformat2#btree&quot;&gt;b树&lt;/a&gt;的表。冒名顶替者表允许查询或修改索引的内容，就像该索引是普通表一样。</target>
        </trans-unit>
        <trans-unit id="548d97f9737c13966b0384ddf7c4f5316897fe64" translate="yes" xml:space="preserve">
          <source>An index b-tree interior page</source>
          <target state="translated">索引b树内页</target>
        </trans-unit>
        <trans-unit id="75b00cd2ffa8d152bd911781465eeda8179c5b9f" translate="yes" xml:space="preserve">
          <source>An index b-tree leaf page</source>
          <target state="translated">一个索引b树叶页</target>
        </trans-unit>
        <trans-unit id="a23b6e554c4c927f47667a50d9e483703c1ef47e" translate="yes" xml:space="preserve">
          <source>An index is another table similar to the original &quot;fruitsforsale&quot; table but with the content (the fruit column in this case) stored in front of the rowid and with all rows in content order. &lt;a href=&quot;#fig4&quot;&gt;Figure 4&lt;/a&gt; gives a logical view of the Idx1 index. The &quot;fruit&quot; column is the primary key used to order the elements of the table and the &quot;rowid&quot; is the secondary key used to break the tie when two or more rows have the same &quot;fruit&quot;. In the example, the rowid has to be used as a tie-breaker for the &quot;Orange&quot; rows. Notice that since the rowid is always unique over all elements of the original table, the composite key of &quot;fruit&quot; followed by &quot;rowid&quot; will be unique over all elements of the index.</source>
          <target state="translated">索引是另一个与原始&amp;ldquo; fruitsforsale&amp;rdquo;表相似的表，但是内容（在这种情况下为&amp;ldquo;水果&amp;rdquo;列）存储在rowid的前面，并且所有行均按内容顺序排列。&lt;a href=&quot;#fig4&quot;&gt;图4&lt;/a&gt;给出了Idx1索引的逻辑视图。当两个或更多行具有相同的&amp;ldquo;水果&amp;rdquo;时，&amp;ldquo;水果&amp;rdquo;列是用于对表中的元素进行排序的主键，而&amp;ldquo;行&amp;rdquo;则是用于打破平局的辅助键。在该示例中，行标识必须用作&amp;ldquo;橙色&amp;rdquo;行的平局。请注意，由于rowid在原始表的所有元素上始终是唯一的，因此&amp;ldquo; fruit&amp;rdquo;后跟&amp;ldquo; rowid&amp;rdquo;的复合键在索引的所有元素上都是唯一的。</target>
        </trans-unit>
        <trans-unit id="3002819a06b87f2b28823dffe3c0b248534f6bf1" translate="yes" xml:space="preserve">
          <source>An instance of the snapshot object records the state of a &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt; database for some specific point in history.</source>
          <target state="translated">快照对象的实例记录了历史上某个特定点的&lt;a href=&quot;../wal&quot;&gt;WAL模式&lt;/a&gt;数据库的状态。</target>
        </trans-unit>
        <trans-unit id="ddc9cd2833d461982fd05cbb236027102f78db05" translate="yes" xml:space="preserve">
          <source>An instance of the snapshot object records the state of a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database for some specific point in history.</source>
          <target state="translated">快照对象的实例记录了历史上某个特定点的&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;数据库的状态。</target>
        </trans-unit>
        <trans-unit id="0ad16796bc17d538460c93b836ae5c8477d8c7e2" translate="yes" xml:space="preserve">
          <source>An instance of the sqlite3_str object contains a dynamically-sized string under construction.</source>
          <target state="translated">sqlite3_str对象的实例包含一个正在构建的动态大小的字符串。</target>
        </trans-unit>
        <trans-unit id="8f02269b16b7995873f0e98891ae8060c34bc231" translate="yes" xml:space="preserve">
          <source>An instance of the sqlite3_vfs object defines the interface between the SQLite core and the underlying operating system. The &quot;vfs&quot; in the name of the object stands for &quot;virtual file system&quot;. See the &lt;a href=&quot;../vfs&quot;&gt;VFS documentation&lt;/a&gt; for further information.</source>
          <target state="translated">sqlite3_vfs对象的实例定义SQLite核心与基础操作系统之间的接口。对象名称中的&amp;ldquo; vfs&amp;rdquo;代表&amp;ldquo;虚拟文件系统&amp;rdquo;。有关更多信息，请参见&lt;a href=&quot;../vfs&quot;&gt;VFS文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="986d34aa72070b33f262aa39aa661f9a7021ae8a" translate="yes" xml:space="preserve">
          <source>An instance of the sqlite3_vfs object defines the interface between the SQLite core and the underlying operating system. The &quot;vfs&quot; in the name of the object stands for &quot;virtual file system&quot;. See the &lt;a href=&quot;vfs&quot;&gt;VFS documentation&lt;/a&gt; for further information.</source>
          <target state="translated">sqlite3_vfs对象的实例定义SQLite核心与基础操作系统之间的接口。对象名称中的&amp;ldquo; vfs&amp;rdquo;代表&amp;ldquo;虚拟文件系统&amp;rdquo;。有关更多信息，请参见&lt;a href=&quot;vfs&quot;&gt;VFS文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f45b93bef69dcf39c21d4d46704ba221d046f871" translate="yes" xml:space="preserve">
          <source>An instance of this object acts as a cursor for iterating over the elements of a &lt;a href=&quot;../sessionintro#changeset&quot;&gt;changeset&lt;/a&gt; or &lt;a href=&quot;../sessionintro#changeset&quot;&gt;patchset&lt;/a&gt;.</source>
          <target state="translated">该对象的实例充当游标，用于迭代&lt;a href=&quot;../sessionintro#changeset&quot;&gt;变更集&lt;/a&gt;或&lt;a href=&quot;../sessionintro#changeset&quot;&gt;补丁集&lt;/a&gt;的元素。</target>
        </trans-unit>
        <trans-unit id="bf71b1083943f3e5851ab7a42bcd920407783dbc" translate="yes" xml:space="preserve">
          <source>An instance of this object acts as a cursor for iterating over the elements of a &lt;a href=&quot;sessionintro#changeset&quot;&gt;changeset&lt;/a&gt; or &lt;a href=&quot;sessionintro#changeset&quot;&gt;patchset&lt;/a&gt;.</source>
          <target state="translated">该对象的实例充当游标，用于迭代&lt;a href=&quot;sessionintro#changeset&quot;&gt;变更集&lt;/a&gt;或&lt;a href=&quot;sessionintro#changeset&quot;&gt;补丁集&lt;/a&gt;的元素。</target>
        </trans-unit>
        <trans-unit id="ab7e618ccd27967f90c1e650a28d3404240080d5" translate="yes" xml:space="preserve">
          <source>An instance of this object defines the interface between SQLite and low-level memory allocation routines.</source>
          <target state="translated">这个对象的实例定义了SQLite和低级内存分配例程之间的接口。</target>
        </trans-unit>
        <trans-unit id="a3b65debab7d2bc5f3be01481bf018b30e5f1a63" translate="yes" xml:space="preserve">
          <source>An instance of this object is a &lt;a href=&quot;../sessionintro&quot;&gt;session&lt;/a&gt; that can be used to record changes to a database.</source>
          <target state="translated">该对象的一个​​实例是一个&lt;a href=&quot;../sessionintro&quot;&gt;会话&lt;/a&gt;，可用于记录对数据库的更改。</target>
        </trans-unit>
        <trans-unit id="d288e209f1c35236167d79cd8408a6e6645c8dfe" translate="yes" xml:space="preserve">
          <source>An instance of this object is a &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; that can be used to record changes to a database.</source>
          <target state="translated">该对象的一个​​实例是一个&lt;a href=&quot;sessionintro&quot;&gt;会话&lt;/a&gt;，可用于记录对数据库的更改。</target>
        </trans-unit>
        <trans-unit id="1a8cd868b7a8f02ee212f8081b22f84902c700f2" translate="yes" xml:space="preserve">
          <source>An instance of this object represents a single SQL statement that has been compiled into binary form and is ready to be evaluated.</source>
          <target state="translated">这个对象的实例代表了一条已经被编译成二进制形式并准备好被评估的SQL语句。</target>
        </trans-unit>
        <trans-unit id="6ac15740a5e0d955ec96459bba2b236546957815" translate="yes" xml:space="preserve">
          <source>An instance of this object represents an open BLOB on which &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt; can be performed. Objects of this type are created by &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; and destroyed by &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; interfaces can be used to read or write small subsections of the BLOB. The &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface returns the size of the BLOB in bytes.</source>
          <target state="translated">该对象的一个​​实例代表一个打开的BLOB，可以在其上执行&lt;a href=&quot;#sqlite3_blob_open&quot;&gt;增量BLOB I / O。&lt;/a&gt;这种类型的目的是通过创建&lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open（）&lt;/a&gt;和通过破坏&lt;a href=&quot;#sqlite3_blob_close&quot;&gt;（）sqlite3_blob_close&lt;/a&gt;。所述&lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;接口可以用于读或写的BLOB的小分段。所述&lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;接口返回以字节为BLOB的大小。</target>
        </trans-unit>
        <trans-unit id="f3e12c7941ae7ce9acfd3af6cea2f4a94a2e0d5a" translate="yes" xml:space="preserve">
          <source>An instance of this object represents an open BLOB on which &lt;a href=&quot;blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt; can be performed. Objects of this type are created by &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; and destroyed by &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;. The &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; interfaces can be used to read or write small subsections of the BLOB. The &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface returns the size of the BLOB in bytes.</source>
          <target state="translated">该对象的一个​​实例代表一个打开的BLOB，可以在其上执行&lt;a href=&quot;blob_open&quot;&gt;增量BLOB I / O。&lt;/a&gt;这种类型的目的是通过创建&lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open（）&lt;/a&gt;和通过破坏&lt;a href=&quot;blob_close&quot;&gt;（）sqlite3_blob_close&lt;/a&gt;。所述&lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;和&lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;接口可以用于读或写的BLOB的小分段。所述&lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;接口返回以字节为BLOB的大小。</target>
        </trans-unit>
        <trans-unit id="d9c5d268a10fe06a59e3c7e963d5ed29fc68438c" translate="yes" xml:space="preserve">
          <source>An instance of this structure defines the low-level routines used to allocate and use mutexes.</source>
          <target state="translated">这个结构的实例定义了用于分配和使用mutexes的低级例程。</target>
        </trans-unit>
        <trans-unit id="7b02932da3aaeca2f83c028e321d42447d0835b5" translate="yes" xml:space="preserve">
          <source>An integer indicating the index of the FTS table column to read the text from. Columns are numbered from left to right starting at zero.</source>
          <target state="translated">一个整数,表示要读取文本的FTS表列的索引。从零开始,从左到右对列进行编号。</target>
        </trans-unit>
        <trans-unit id="c23d5e6e7614ceb92ef3b6de48759bd54ba26b48" translate="yes" xml:space="preserve">
          <source>An integer indicating the index of the FTS table column to select the returned text from. Columns are numbered from left to right starting at zero. A negative value indicates that the column should be automatically selected.</source>
          <target state="translated">一个整数,表示要选择返回文本的FTS表列的索引。从0开始,从左到右对列进行编号。负值表示应自动选择该列。</target>
        </trans-unit>
        <trans-unit id="c886c068ec97375a0540464685cf9e1ef166d731" translate="yes" xml:space="preserve">
          <source>An intensively used low-level library like SQLite needs to be fast. (And SQLite is fast, see &lt;a href=&quot;intern-v-extern-blob&quot;&gt;Internal Versus External BLOBs&lt;/a&gt; and &lt;a href=&quot;fasterthanfs&quot;&gt;35% Faster Than The Filesystem&lt;/a&gt; for example.)</source>
          <target state="translated">像SQLite这样被大量使用的低级库需要快速。（而且SQLite速度很快，例如，请参见&lt;a href=&quot;intern-v-extern-blob&quot;&gt;内部BLOB与外部BLOB&lt;/a&gt;和&lt;a href=&quot;fasterthanfs&quot;&gt;比文件系统快35％&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="02b10fc85927484bbd1851b4c4f858fb308385eb" translate="yes" xml:space="preserve">
          <source>An iterator is deleted using a call to the &lt;a href=&quot;session/sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt; API. If an error occured while iterating, an SQLite error code is returned (even if the same error code has already been returned by sqlite3changeset_next()). Or, if no error has occurred, SQLITE_OK is returned.</source>
          <target state="translated">使用对&lt;a href=&quot;session/sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize（）&lt;/a&gt; API 的调用可以删除迭代器。如果在迭代过程中发生错误，则将返回SQLite错误代码（即使sqlite3changeset_next（）已经返回了相同的错误代码）。或者，如果未发生任何错误，则返回SQLITE_OK。</target>
        </trans-unit>
        <trans-unit id="dd92a7436e987265ed18e3cd262b66e57b47ffd2" translate="yes" xml:space="preserve">
          <source>An ongoing RBU operation (either an update or a vacuum) does not interfere with read access to the database file.</source>
          <target state="translated">正在进行的 RBU 操作(无论是更新还是真空)不会影响对数据库文件的读取访问。</target>
        </trans-unit>
        <trans-unit id="98e9fb11f12f8a43c4c89d92d48bc4d12fa12b04" translate="yes" xml:space="preserve">
          <source>An operand of a comparison is considered to have an explicit collating function assignment (rule 1 above) if any subexpression of the operand uses the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;. Thus, if a &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt; is used anywhere in a comparision expression, the collating function defined by that operator is used for string comparison regardless of what table columns might be a part of that expression. If two or more &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt; subexpressions appear anywhere in a comparison, the left most explicit collating function is used regardless of how deeply the COLLATE operators are nested in the expression and regardless of how the expression is parenthesized.</source>
          <target state="translated">如果操作数的任何子表达式使用后缀&lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE运算符，&lt;/a&gt;则认为比较操作数具有显式整理函数分配（上述规则1）。因此，如果在比较表达式的任何地方使用&lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE运算符&lt;/a&gt;，则该运算符定义的整理函数将用于字符串比较，而不管该表达式中可能包含哪些表列。如果两个或多个&lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE运算符&lt;/a&gt;子表达式出现在比较中的任意位置，则无论最左侧的COLLATE运算符在表达式中嵌套的深度如何，以及如何在表达式中加上括号，都将使用最左边的排序规则函数。</target>
        </trans-unit>
        <trans-unit id="1841b8b7007b74c92e11286f08f070e4631c39a7" translate="yes" xml:space="preserve">
          <source>An ordinary common table expression works as if it were a &lt;a href=&quot;lang_createview&quot;&gt;view&lt;/a&gt; that exists for the duration of a single statement. Ordinary common table expressions are useful for factoring out subqueries and making the overall SQL statement easier to read and understand.</source>
          <target state="translated">普通的公用表表达式的工作方式就像是在单个语句期间存在的&lt;a href=&quot;lang_createview&quot;&gt;视图一样&lt;/a&gt;。普通的公共表表达式可用于分解子查询并使整个SQL语句更易于阅读和理解。</target>
        </trans-unit>
        <trans-unit id="c64f3df3f6dbd2c4ab332d741a98dc5f74fa4c01" translate="yes" xml:space="preserve">
          <source>An ordinary filename can usually be converted into an equivalent URI by the steps shown below. The one exception is that a relative windows pathname with a drive letter cannot be converted directly into a URI; it must be changed into an absolute pathname first.</source>
          <target state="translated">一个普通的文件名通常可以通过下面的步骤转换为一个等价的URI。唯一的例外是,一个带有驱动器字母的相对windows路径名不能直接转换为URI,必须先将其改为绝对路径名。</target>
        </trans-unit>
        <trans-unit id="76f1c5c7c31ea92a8b28f97d519413325cc7abf4" translate="yes" xml:space="preserve">
          <source>An overlay can be created by using the</source>
          <target state="translated">可以通过使用</target>
        </trans-unit>
        <trans-unit id="ace2a17ee0ffadfade85b391c6417dbd59dcd570" translate="yes" xml:space="preserve">
          <source>An rtree_i32 stores coordinates as 32-bit signed integers. But it still using floating point computations internally as part of the r-tree algorithm.</source>
          <target state="translated">rtree_i32将坐标存储为32位有符号的整数,但它内部仍然使用浮点计算作为r树算法的一部分。但它仍然在内部使用浮点计算作为r-tree算法的一部分。</target>
        </trans-unit>
        <trans-unit id="07cb8663d689220c5b11e75bcc91e43df5ab2f40" translate="yes" xml:space="preserve">
          <source>An sqlite3_changegroup object is used to combine two or more changesets (or patchsets) into a single changeset (or patchset). A single changegroup object may combine changesets or patchsets, but not both. The output is always in the same format as the input.</source>
          <target state="translated">sqlite3_changegroup对象用于将两个或多个变化集(或补丁集)组合成一个变化集(或补丁集)。一个单一的changegroup对象可以结合变化集或补丁集,但不能同时结合。输出总是与输入的格式相同。</target>
        </trans-unit>
        <trans-unit id="caf5ebeb61b12b4ca95cabbbacfd2a52d1e22645" translate="yes" xml:space="preserve">
          <source>An sqlite3_rebaser object is created by calling sqlite3rebaser_create().</source>
          <target state="translated">通过调用sqlite3rebaser_create()创建一个sqlite3_rebaser对象。</target>
        </trans-unit>
        <trans-unit id="2af9897fcfc348b6ea18f42888797de74b915c33" translate="yes" xml:space="preserve">
          <source>An sqlite3_value object may be either &quot;protected&quot; or &quot;unprotected&quot;. Some interfaces require a protected sqlite3_value. Other interfaces will accept either a protected or an unprotected sqlite3_value. Every interface that accepts sqlite3_value arguments specifies whether or not it requires a protected sqlite3_value. The &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt; interface can be used to construct a new protected sqlite3_value from an unprotected sqlite3_value.</source>
          <target state="translated">sqlite3_value对象可以是&amp;ldquo;受保护的&amp;rdquo;或&amp;ldquo;不受保护的&amp;rdquo;。某些接口需要受保护的sqlite3_value。其他接口将接受受保护或不受保护的sqlite3_value。每个接受sqlite3_value参数的接口都指定是否需要受保护的sqlite3_value。所述&lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup（）&lt;/a&gt;接口可用于从一个未保护sqlite3_value构造一个新的受保护sqlite3_value。</target>
        </trans-unit>
        <trans-unit id="7bf10bfa8716c343b3bd7ed7af7b661d4bbe7281" translate="yes" xml:space="preserve">
          <source>An sqlite3_value object may be either &quot;protected&quot; or &quot;unprotected&quot;. Some interfaces require a protected sqlite3_value. Other interfaces will accept either a protected or an unprotected sqlite3_value. Every interface that accepts sqlite3_value arguments specifies whether or not it requires a protected sqlite3_value. The &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt; interface can be used to construct a new protected sqlite3_value from an unprotected sqlite3_value.</source>
          <target state="translated">sqlite3_value对象可以是&amp;ldquo;受保护的&amp;rdquo;或&amp;ldquo;不受保护的&amp;rdquo;。某些接口需要受保护的sqlite3_value。其他接口将接受受保护或不受保护的sqlite3_value。每个接受sqlite3_value参数的接口都指定是否需要受保护的sqlite3_value。所述&lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup（）&lt;/a&gt;接口可用于从一个未保护sqlite3_value构造一个新的受保护sqlite3_value。</target>
        </trans-unit>
        <trans-unit id="9e4dafbd07992ae7ef4dffddcd1b4a5c5cb76207" translate="yes" xml:space="preserve">
          <source>An unconditional jump to address P2. The next instruction executed will be the one at index P2 from the beginning of the program.</source>
          <target state="translated">无条件跳转到地址P2。下一条执行的指令将是程序开始时索引P2处的指令。</target>
        </trans-unit>
        <trans-unit id="0ec2f338946c19a5c8db3e1991942cfffb1ac767" translate="yes" xml:space="preserve">
          <source>An unrelated (and minor) bug from Mark Muranwski fixed. The algorithm for figuring out where to put temporary files for a &quot;memory:&quot; database was not working quite right.</source>
          <target state="translated">修正了 Mark Muranwski 提出的一个无关紧要的错误。计算 &quot;memory:&quot;数据库临时文件放置位置的算法不太正确。</target>
        </trans-unit>
        <trans-unit id="a01e33f4dcdb6ba1ae9f34a97cf8f6deeedf1a8d" translate="yes" xml:space="preserve">
          <source>And</source>
          <target state="translated">And</target>
        </trans-unit>
        <trans-unit id="24a1091048c98405fcc66da02f4798476c96d7b9" translate="yes" xml:space="preserve">
          <source>And So Forth...</source>
          <target state="translated">然后...</target>
        </trans-unit>
        <trans-unit id="6d62766f3bc1a62b7bc2195312ea71e091c76d3c" translate="yes" xml:space="preserve">
          <source>And if there is an entry in that table where the key column exactly matches the name of parameter (including the initial &quot;?&quot;, &quot;$&quot;, &quot;:&quot;, or &quot;@&quot; character) then the parameter is assigned the value of the value column. If no entry exists, the parameter defaults to NULL.</source>
          <target state="translated">如果在该表中有一个条目,其中的键列与参数名称完全匹配(包括初始的&quot;?&quot;、&quot;$&quot;、&quot;:&quot;或&quot;@&quot;字符),那么参数将被分配到值列的值。如果不存在条目,参数默认为NULL。</target>
        </trans-unit>
        <trans-unit id="1613947ae46cd2f84a12cf24acc0820e1f9d0a46" translate="yes" xml:space="preserve">
          <source>And it is not really about just finding the descendents of a check-in from time to time. The fact that descendents are readily available in Fossil means that the information pervades the web pages provided by Fossil. One example: Every Fossil check-in information page (&lt;a href=&quot;https://www.sqlite.org/src/info/ec7addc87f97bcff&quot;&gt;example&lt;/a&gt;) shows a small &quot;Context&quot; graph of the immediate predecessor and successors to that check-in. This helps the user maintain better situational awareness, and it provides useful capabilities, such as the ability click forward to the next check-in in sequence. Another example: Fossil easily shows the context around a specific check-in (&lt;a href=&quot;https://www.sqlite.org/src/timeline?c=2018-03-16&amp;amp;n=10&quot;&gt;example&lt;/a&gt;) which again helps to promote situational awareness and a deeper understanding of what is happening in the code.</source>
          <target state="translated">这不只是要不时查找登机的后代。后代在化石中随时可用的事实意味着该信息遍及了化石提供的网页。一个示例：每个Fossil签入信息页面（&lt;a href=&quot;https://www.sqlite.org/src/info/ec7addc87f97bcff&quot;&gt;示例&lt;/a&gt;）都显示该签入的直接前任和后继的小&amp;ldquo;上下文&amp;rdquo;图。这有助于用户保持更好的态势感知，并提供有用的功能，例如依次单击前进到下一个签入的功能。另一个示例：Fossil轻松显示特定签入（&lt;a href=&quot;https://www.sqlite.org/src/timeline?c=2018-03-16&amp;amp;n=10&quot;&gt;示例&lt;/a&gt;）周围的上下文，这再次有助于提高态势感知和对代码中正在发生的事情的更深入了解。</target>
        </trans-unit>
        <trans-unit id="64a004639abb260000e8e73266aba33df3b4e343" translate="yes" xml:space="preserve">
          <source>And it is not really about just finding the descendents of a check-in from time to time. The fact that descendents are readily available in Fossil means that the information pervades the web pages provided by Fossil. One example: Every Fossil check-in information page (&lt;a href=&quot;https://www.sqlite.org/src/info/ec7addc87f97bcff&quot;&gt;example&lt;/a&gt;) shows a small &quot;Context&quot; graph of the immediate predecessor and successors to that check-in. This helps the user maintain better situational awareness, and it provides useful capabilities, such as the ability click forward to the next check-in in sequence. Another example: Fossil easily shows the context around a specific check-in (&lt;a href=&quot;https://www.sqlite.org/src/timeline?c=2018-03-16&amp;amp;n=10&quot;&gt;example&lt;/a&gt;) which again helps to promote situational awareness and a deeper understanding of what is happening in the code. There is a &lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/webpage-ex.md&quot;&gt;whole page of additional examples&lt;/a&gt; in the &lt;a href=&quot;https://fossil-scm.org/fossil&quot;&gt;Fossil documentation&lt;/a&gt;.</source>
          <target state="translated">这不只是要不时查找登机的后代。后代在化石中随时可用的事实意味着该信息遍及了化石提供的网页。一个示例：每个Fossil签入信息页面（&lt;a href=&quot;https://www.sqlite.org/src/info/ec7addc87f97bcff&quot;&gt;示例&lt;/a&gt;）都显示该签入的直接前任和后继的小&amp;ldquo;上下文&amp;rdquo;图。这有助于用户保持更好的态势感知，并提供有用的功能，例如依次单击前进到下一个签入的功能。另一个示例：Fossil轻松显示特定签入（&lt;a href=&quot;https://www.sqlite.org/src/timeline?c=2018-03-16&amp;amp;n=10&quot;&gt;示例&lt;/a&gt;）周围的上下文，这再次有助于提高态势感知和对代码中正在发生的事情的更深入了解。一&lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/webpage-ex.md&quot;&gt;整页的其他示例&lt;/a&gt;在&lt;a href=&quot;https://fossil-scm.org/fossil&quot;&gt;Fossil文档中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c2283cc542d600a5581e49e759263651d3636f77" translate="yes" xml:space="preserve">
          <source>And let the query be:</source>
          <target state="translated">而让查询。</target>
        </trans-unit>
        <trans-unit id="9f762e3b5086b03457eac0a8ca5ae39d999e5440" translate="yes" xml:space="preserve">
          <source>And many, many bug fixes...</source>
          <target state="translated">还有很多很多的错误修复......</target>
        </trans-unit>
        <trans-unit id="f247637664b32ff61f9705cffde6b438321ac676" translate="yes" xml:space="preserve">
          <source>And populated as if the target table were an ordinary SQLite table with no explicit PRIMARY KEY columns.</source>
          <target state="translated">并像目标表是普通的SQLite表一样填充,没有显式的PRIMARY KEY列。</target>
        </trans-unit>
        <trans-unit id="f9380c403c5923e40740011085ed6c0ba26458c2" translate="yes" xml:space="preserve">
          <source>And so forth. Basically any sequence of names optionally followed by one or two signed integers in parentheses will do.</source>
          <target state="translated">以此类推。基本上,任何名称序列都可以在括号里加上一个或两个带符号的整数。</target>
        </trans-unit>
        <trans-unit id="b0959960067ae4919fa2e1ea2e691b5f145968c7" translate="yes" xml:space="preserve">
          <source>And so forth. For ZIP archives and SQLite Archives, simply change the &quot;/tarball/&quot; element into either &quot;/zip/&quot; or &quot;/sqlar/&quot;, and maybe also change the name of the download file to have a &quot;.zip&quot; or &quot;.sqlar&quot; suffix.</source>
          <target state="translated">以此类推。对于ZIP归档和SQLite归档,只需将&quot;/tarball/&quot;元素改为&quot;/zip/&quot;或&quot;/sqlar/&quot;,也许还要将下载文件的名称改为&quot;.zip &quot;或&quot;.sqlar &quot;后缀。</target>
        </trans-unit>
        <trans-unit id="ba8077732ad2502900dddf709f29aa73b1a0f6b4" translate="yes" xml:space="preserve">
          <source>And so forth. There are 8 nodes in the TPC-H Q8 query, so this process repeats a total of 8 times. In the general case of a K-way join, the storage requirement is O(N) and the computation time is O(K*N), which is significantly faster than the O(2&lt;small&gt;&lt;sup&gt;K&lt;/sup&gt;&lt;/small&gt;) exact solution.</source>
          <target state="translated">依此类推。TPC-H Q8查询中有8个节点，因此此过程总共重复8次。在一般情况下，使用K向联接时，存储要求为O（N），计算时间为O（K * N），这比O（2 &lt;small&gt;&lt;sup&gt;K&lt;/sup&gt;&lt;/small&gt;）精确解要快得多。</target>
        </trans-unit>
        <trans-unit id="060f19a1ad677f74cc92295a75b3f1b018b239ae" translate="yes" xml:space="preserve">
          <source>And so forth....</source>
          <target state="translated">等等....</target>
        </trans-unit>
        <trans-unit id="5207dcf07042e825e2caf9ab6e9995854377e2d5" translate="yes" xml:space="preserve">
          <source>And the generated code looks like this:</source>
          <target state="translated">而生成的代码是这样的。</target>
        </trans-unit>
        <trans-unit id="2e512a9542a2e3dfd52435fac1d439e588ebcee9" translate="yes" xml:space="preserve">
          <source>And then you run the query:</source>
          <target state="translated">然后你运行查询。</target>
        </trans-unit>
        <trans-unit id="9ffeb8471359e0755ff7942bbfbee2106c5c7ff7" translate="yes" xml:space="preserve">
          <source>And, many more minor bug fixes and performance enhancements....</source>
          <target state="translated">而且,还有很多小的bug修复和性能提升......。</target>
        </trans-unit>
        <trans-unit id="a7e85233665c7566a60532bc230bb5ff92b64c2f" translate="yes" xml:space="preserve">
          <source>Anomaly tests are tests designed to verify the correct behavior of SQLite when something goes wrong. It is (relatively) easy to build an SQL database engine that behaves correctly on well-formed inputs on a fully functional computer. It is more difficult to build a system that responds sanely to invalid inputs and continues to function following system malfunctions. The anomaly tests are designed to verify the latter behavior.</source>
          <target state="translated">异常测试是为了验证SQLite在出错时的正确行为而设计的测试。在一台功能完备的计算机上,建立一个在格式良好的输入上表现正确的SQL数据库引擎是(相对)容易的。但要建立一个对无效输入做出合理响应并在系统故障后继续运行的系统则比较困难。异常测试是为了验证后一种行为而设计的。</target>
        </trans-unit>
        <trans-unit id="6f7ee88b419e1339ccb20dd6c8b4d7e9833eca0b" translate="yes" xml:space="preserve">
          <source>Another (safer) approach to creating an imposter table is to add an entry for the imposter table to SQLite's internal symbol table without updating the &quot;sqlite_master&quot; table on disk. That way, the imposter table exists in only a single database connection and is automatically removed whenever the schema is reloaded.</source>
          <target state="translated">创建冒名表的另一种(更安全的)方法是在SQLite的内部符号表中添加一个冒名表的条目,而不更新磁盘上的 &quot;sqlite_master &quot;表。这样一来,冒名表只存在于一个数据库连接中,每当重新加载模式时,冒名表就会被自动删除。</target>
        </trans-unit>
        <trans-unit id="213aaebee52481a980f7e74b2089b3f6c24d4183" translate="yes" xml:space="preserve">
          <source>Another (safer) approach to creating an imposter table is to add an entry for the imposter table to SQLite's internal symbol table without updating the &quot;sqlite_schema&quot; table on disk. That way, the imposter table exists in only a single database connection and is automatically removed whenever the schema is reloaded.</source>
          <target state="translated">另一种(更安全的)创建冒名表的方法是在不更新磁盘上的 &quot;sqlite_schema &quot;表的情况下,将冒名表的条目添加到SQLite的内部符号表中。这样,冒名表只存在于一个数据库连接中,每当重新加载模式时,冒名表就会被自动删除。</target>
        </trans-unit>
        <trans-unit id="0a256db65f829282a102ced1041e5c60bd3b39bb" translate="yes" xml:space="preserve">
          <source>Another approach is to initially disable the lookaside memory allocator:</source>
          <target state="translated">另一种方法是最初禁用lookaside内存分配器。</target>
        </trans-unit>
        <trans-unit id="3f1ebbc20dfee63c729fadf1742ea0910dca153a" translate="yes" xml:space="preserve">
          <source>Another approach is to translate the program source text into a tree of objects in memory. This tree is the &quot;executable&quot;. An interpret runs the executable by walking the tree. This is the technique used by MySQL, PostgreSQL, and SQL-Server.</source>
          <target state="translated">另一种方法是将程序源文本翻译成内存中的对象树。这棵树就是 &quot;可执行文件&quot;。解释者通过行走这棵树来运行可执行文件。这是MySQL、PostgreSQL和SQL-Server使用的技术。</target>
        </trans-unit>
        <trans-unit id="1f9265574f7b534649a1277b85f4934a02129bee" translate="yes" xml:space="preserve">
          <source>Another example is a virtual table that implements a full-text index. The xCreate method must create and initialize data structures to hold the dictionary and posting lists for that index. The xConnect method, on the other hand, only has to locate and use an existing dictionary and posting lists that were created by a prior xCreate call.</source>
          <target state="translated">另一个例子是一个实现全文索引的虚拟表。xCreate 方法必须创建和初始化数据结构,以便为该索引保存字典和发布列表。另一方面,xConnect 方法只需定位和使用先前的 xCreate 调用所创建的现有字典和发布列表。</target>
        </trans-unit>
        <trans-unit id="303e110b30c7b4642bb575628bce75a8b23bc25d" translate="yes" xml:space="preserve">
          <source>Another example of corruption caused by using a closed file descriptor was &lt;a href=&quot;https://code.facebook.com/posts/313033472212144/debugging-file-corruption-on-ios/&quot;&gt;reported by facebook engineers&lt;/a&gt; in a blog post on 2014-08-12.</source>
          <target state="translated">&lt;a href=&quot;https://code.facebook.com/posts/313033472212144/debugging-file-corruption-on-ios/&quot;&gt;Facebook工程师&lt;/a&gt;在2014-08-12的博客文章中报道了使用封闭文件描述符导致的另一个损坏示例。</target>
        </trans-unit>
        <trans-unit id="505afcae9498bd12848d3ae36d382e63fe35606f" translate="yes" xml:space="preserve">
          <source>Another example of this error was reported against &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; on 2019-07-11. A file descriptor would be opened for debugging output, but then closed and reopened by SQLite. But the debugging logic continued to write into the original file descriptor. See the &lt;a href=&quot;https://fossil-scm.org/forum/forumpost/c51b9a1169&quot;&gt;forum discussion&lt;/a&gt; for the bug report and a link to the fix.</source>
          <target state="translated">&lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt;于2019-07-11 报告了此错误的另一个示例。将打开文件描述符以调试输出，但随后由SQLite关闭并重新打开。但是调试逻辑继续写入原始文件描述符。有关错误报告，请参见&lt;a href=&quot;https://fossil-scm.org/forum/forumpost/c51b9a1169&quot;&gt;论坛讨论&lt;/a&gt;，并提供修复程序的链接。</target>
        </trans-unit>
        <trans-unit id="8183751698c287cb27407f9ba084d293db7c55bd" translate="yes" xml:space="preserve">
          <source>Another example: X starts a read transaction using &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; and &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;, then Y makes a changes to the database using &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;. Then X tries to make a change to the database using &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;. The attempt by X to escalate its transaction from a read transaction to a write transaction fails with an &lt;a href=&quot;rescode#busy_snapshot&quot;&gt;SQLITE_BUSY_SNAPSHOT&lt;/a&gt; error because the snapshot of the database being viewed by X is no longer the latest version of the database. If X were allowed to write, it would fork the history of the database file, which is something SQLite does not support. In order for X to write to the database, it must first release its snapshot (using &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; for example) then start a new transaction with a subsequent &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;.</source>
          <target state="translated">另一个示例：X使用&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;和&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;启动读取事务，然后Y使用&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;对数据库进行更改。然后X尝试使用&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;更改数据库。 X尝试将其事务从读取事务升级到写入事务的&lt;a href=&quot;rescode#busy_snapshot&quot;&gt;尝试&lt;/a&gt;失败，并出现SQLITE_BUSY_SNAPSHOT错误，因为X所查看的数据库快照不再是数据库的最新版本。如果允许X写入，它将分叉数据库文件的历史记录，这是SQLite不支持的。为了让X写入数据库，它必须首先释放其快照（例如，使用&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;），然后再启动一个新事务并随后进行&lt;a href=&quot;lang_transaction&quot;&gt;开始&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a1c30e5a209f39b6a21d890471cf09df8606ebc" translate="yes" xml:space="preserve">
          <source>Another flush must occur to make sure that all the database changes are written into nonvolatile storage. This is a critical step to ensure that the database will survive a power loss without damage. However, because of the inherent slowness of writing to disk or flash memory, this step together with the rollback journal file flush in section 3.7 above takes up most of the time required to complete a transaction commit in SQLite.</source>
          <target state="translated">必须进行另一次刷新,以确保所有的数据库更改都写入非易失性存储中。这是确保数据库在断电后不受损坏的关键步骤。然而,由于写入磁盘或闪存的固有速度较慢,这一步和上面3.7节中的回滚日志文件刷新一起,占用了SQLite中完成事务提交所需的大部分时间。</target>
        </trans-unit>
        <trans-unit id="6c301063883293bdf468d0623b6a6911c6d2293c" translate="yes" xml:space="preserve">
          <source>Another limitation of the histogram data is that it only applies to the left-most column on an index. Consider this scenario:</source>
          <target state="translated">直方图数据的另一个局限性是,它只适用于索引上最左边的一列。考虑一下这种情况。</target>
        </trans-unit>
        <trans-unit id="f21c319ab2ff434679be56b445eba4fa1aa43f87" translate="yes" xml:space="preserve">
          <source>Another macro used in conjunction with test coverage measurement is the &lt;code&gt;testcase()&lt;/code&gt; macro. The argument is a condition for which we want test cases that evaluate to both true and false. In non-coverage builds (that is to say, in release builds) the &lt;code&gt;testcase()&lt;/code&gt; macro is a no-op:</source>
          <target state="translated">与测试覆盖率测量结合使用的另一个宏是 &lt;code&gt;testcase()&lt;/code&gt; 宏。该参数是我们希望测试用例的评估结果为true和false的条件。在非覆盖版本中（也就是说，在发行版本中）， &lt;code&gt;testcase()&lt;/code&gt; 宏是禁止操作的：</target>
        </trans-unit>
        <trans-unit id="c493a994000d99e73cbc3f60d51dfc6589078021" translate="yes" xml:space="preserve">
          <source>Another manifestation of this problem is &lt;a href=&quot;shortnames#db83corrupt&quot;&gt;database corruption caused by inconsistent use of 8+3 filenames&lt;/a&gt;.</source>
          <target state="translated">此问题的另一种表现是&lt;a href=&quot;shortnames#db83corrupt&quot;&gt;由于不一致使用8 + 3文件名引起的数据库损坏&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="05b9d783d5cb2f59bb8b6ca5914b9575e677009e" translate="yes" xml:space="preserve">
          <source>Another optimization introduced in SQLite version 3.5.0 makes use of &quot;safe append&quot; behavior of the underlying disk. Recall that SQLite assumes that when data is appended to a file (specifically to the rollback journal) that the size of the file is increased first and that the content is written second. So if power is lost after the file size is increased but before the content is written, the file is left containing invalid &quot;garbage&quot; data. The xDeviceCharacteristics method of the VFS might, however, indicate that the filesystem implements &quot;safe append&quot; semantics. This means that the content is written before the file size is increased so that it is impossible for garbage to be introduced into the rollback journal by a power loss or system crash.</source>
          <target state="translated">SQLite 3.5.0版本中引入的另一个优化利用了底层磁盘的 &quot;安全追加 &quot;行为。回想一下,SQLite假设当数据被追加到一个文件(特别是回滚日志)时,文件的大小是先增加的,内容是后写入的。因此,如果在文件大小增加后,但在内容写入前断电,文件就会留下包含无效的 &quot;垃圾 &quot;数据。然而,VFS的xDeviceCharacteristics方法可能表明文件系统实现了 &quot;安全追加 &quot;语义。这意味着在文件大小增加之前就会写入内容,这样就不可能因为断电或系统崩溃而将垃圾引入回滚日志。</target>
        </trans-unit>
        <trans-unit id="7dad2e6d1e9648b82626f473ea27ecce5bb27928" translate="yes" xml:space="preserve">
          <source>Another option is to run &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt;. This command will cause SQLite to not wait on data to reach the disk surface, which will make write operations appear to be much faster. But if you lose power in the middle of a transaction, your database file might go corrupt.</source>
          <target state="translated">另一种选择是运行&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMAynchronized = OFF&lt;/a&gt;。此命令将导致SQLite不等待数据到达磁盘表面，这将使写入操作显得更快。但是，如果您在事务处理过程中断电，则数据库文件可能会损坏。</target>
        </trans-unit>
        <trans-unit id="0728346ee0767219b30d3313656a41918770666a" translate="yes" xml:space="preserve">
          <source>Another useful output mode is &quot;insert&quot;. In insert mode, the output is formatted to look like SQL INSERT statements. Use insert mode to generate text that can later be used to input data into a different database.</source>
          <target state="translated">另一个有用的输出模式是 &quot;插入&quot;。在插入模式下,输出的格式看起来像SQL INSERT语句。使用插入模式生成文本,以后可以用来将数据输入到不同的数据库中。</target>
        </trans-unit>
        <trans-unit id="603f11343da9306fc8345afa2052a80114bf6240" translate="yes" xml:space="preserve">
          <source>Another view of RELEASE is that it merges a named transaction into its parent transaction, so that the named transaction and its parent become the same transaction. After RELEASE, the named transaction and its parent will commit or rollback together, whatever their fate may be.</source>
          <target state="translated">RELEASE的另一种观点是,它将一个命名的事务合并到它的父事务中,这样命名的事务和它的父事务就成为同一个事务。在RELEASE之后,命名事务和它的父事务将一起提交或回滚,不管它们的命运如何。</target>
        </trans-unit>
        <trans-unit id="e8c0bf8ab4584514edb8368d18ba85e753fa2a2d" translate="yes" xml:space="preserve">
          <source>Another way to get the row change counts is to use the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; or &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces. There is a subtle different, though. When an INSERT, UPDATE, or DELETE is run against a view using an &lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF trigger&lt;/a&gt;, the count_changes pragma reports the number of rows in the view that fired the trigger, whereas &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; do not.</source>
          <target state="translated">获取行更改计数的另一种方法是使用&lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes（）&lt;/a&gt;或&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;接口。但是，有一个细微的不同。当使用&lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF触发器&lt;/a&gt;对视图运行INSERT，UPDATE或DELETE时，count_changes编译指示将报告触发该触发器的视图中的行数，而&lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes（）&lt;/a&gt;和&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;则不会。</target>
        </trans-unit>
        <trans-unit id="2d30986ae4eff5648d38ebb9d01b585109e2411f" translate="yes" xml:space="preserve">
          <source>Another way to think about the difference between rollback and write-ahead log is that in the rollback-journal approach, there are two primitive operations, reading and writing, whereas with a write-ahead log there are now three primitive operations: reading, writing, and checkpointing.</source>
          <target state="translated">回滚式日志和写式日志的另一种思路是,在回滚式日志方式中,有两个原始操作,即读和写,而写式日志现在有三个原始操作:读、写和检查点。</target>
        </trans-unit>
        <trans-unit id="7d0ac016e0a7d3c26e0cccd010f12ca2f8757e4c" translate="yes" xml:space="preserve">
          <source>Another, more automated, way to tell if a string value X contains embedded NUL characters is to use an expression like this:</source>
          <target state="translated">另一种更自动化的判断字符串值X是否包含内嵌的NUL字符的方法是使用类似这样的表达式。</target>
        </trans-unit>
        <trans-unit id="76c08af7521af2a346bb889060bcedbdd23dc992" translate="yes" xml:space="preserve">
          <source>Anticipated Future Enhancements</source>
          <target state="translated">预期的未来改进</target>
        </trans-unit>
        <trans-unit id="03cbea0705f9805750be00c459dd237de0396772" translate="yes" xml:space="preserve">
          <source>Any UTF-8 character or ISO8859 character can be used as part of an identifier.</source>
          <target state="translated">任何UTF-8字符或ISO8859字符都可以作为标识符的一部分。</target>
        </trans-unit>
        <trans-unit id="17ff5b973797aa52493296af8db3d0915fb38ed0" translate="yes" xml:space="preserve">
          <source>Any application can run an &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; query to get output similar to the above. However, indentation to show the loop structure is not generated by the SQLite core. The &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; contains extra logic for indenting loops. Also, the &quot;comment&quot; column in the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; output is only provided if SQLite is compiled with the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; options.</source>
          <target state="translated">任何应用程序都可以运行&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;查询以获取与上述类似的输出。但是，显示循环结构的缩进不是SQLite核心生成的。在&lt;a href=&quot;cli&quot;&gt;命令行shell&lt;/a&gt;包含缩进循环额外的逻辑。另外，仅当使用&lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt;选项编译SQLite时，才提供&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;输出中的&amp;ldquo;注释&amp;rdquo;列。</target>
        </trans-unit>
        <trans-unit id="5a8e347554cfc99745cad972098b020b8602be14" translate="yes" xml:space="preserve">
          <source>Any application state that can be recorded in a pile-of-files can also be recorded in an SQLite database with a simple key/value schema like this:</source>
          <target state="translated">任何可以记录在一堆文件中的应用状态也可以记录在SQLite数据库中,简单的键/值模式是这样的。</target>
        </trans-unit>
        <trans-unit id="c1ed6ff66cc7fc9ffd4cafbde2a3c28f229641fd" translate="yes" xml:space="preserve">
          <source>Any arguments following &quot;unicode61&quot; in the token specification are treated as a list of alternating option names and values. Unicode61 supports the following options:</source>
          <target state="translated">令牌规范中 &quot;unicode61 &quot;后面的任何参数都被视为交替的选项名称和值的列表。Unicode61支持以下选项。</target>
        </trans-unit>
        <trans-unit id="81df847e2da7c111d58995774268025f599b0ab5" translate="yes" xml:space="preserve">
          <source>Any column in an SQLite version 3 database, except an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column, may be used to store a value of any storage class.</source>
          <target state="translated">除了&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列之外，SQLite版本3数据库中的任何列均可用于存储任何存储类的值。</target>
        </trans-unit>
        <trans-unit id="d12d25e97784fac279be1123d4fbe17792ad0403" translate="yes" xml:space="preserve">
          <source>Any custom collation sequences used by indexes within the database being vacuumed are registered with both of the database handles returned by the sqlite3rbu_db() function.</source>
          <target state="translated">被吸尘的数据库中的索引使用的任何自定义整理序列都会被sqlite3rbu_db()函数返回的两个数据库句柄注册。</target>
        </trans-unit>
        <trans-unit id="151750db2f16a0f1a6b9b810158ada7a043bfbe4" translate="yes" xml:space="preserve">
          <source>Any database clients wishing to write to the database file while a backup is being created must wait until the shared lock is relinquished.</source>
          <target state="translated">任何希望在创建备份时向数据库文件写入的数据库客户端,必须等到共享锁被放弃。</target>
        </trans-unit>
        <trans-unit id="3870d6d9202c275acd1d8b0e06d905fc8afb745c" translate="yes" xml:space="preserve">
          <source>Any database name qualifier that occurs prior to the name of the object being created is removed.</source>
          <target state="translated">在创建对象名称之前出现的任何数据库名称限定词都会被删除。</target>
        </trans-unit>
        <trans-unit id="4255994cd14e9b872cd99b88c74cbf406ff9482f" translate="yes" xml:space="preserve">
          <source>Any index that includes the WHERE clause at the end is considered to be a partial index. Indexes that omit the WHERE clause (or indexes that are created by UNIQUE or PRIMARY KEY constraints inside of CREATE TABLE statements) are ordinary full indexes.</source>
          <target state="translated">任何在最后包含WHERE子句的索引都被认为是部分索引。省略WHERE子句的索引(或者在CREATE TABLE语句中由UNIQUE或PRIMARY KEY约束创建的索引)是普通的完全索引。</target>
        </trans-unit>
        <trans-unit id="b43d049b602d1fd2bf9a7b5bea3350eedf1f0673" translate="yes" xml:space="preserve">
          <source>Any number of calls to add() and output() may be made between the calls to new() and delete(), and in any order.</source>
          <target state="translated">在对new()和delete()的调用之间,可以对add()和output()进行任意次数的调用,且顺序不限。</target>
        </trans-unit>
        <trans-unit id="bdc7645ee06bfe979513e08246b74910b770d144" translate="yes" xml:space="preserve">
          <source>Any of the row values in the previous example could be replace by a subquery that returns three columns and the same answer would result. For example:</source>
          <target state="translated">前面例子中的任何一个行值都可以用一个返回三列的子查询来代替,结果也是一样的答案。例如:</target>
        </trans-unit>
        <trans-unit id="9ffe3efbd83a6aa86da6ab4b6abaf0209d6a58e2" translate="yes" xml:space="preserve">
          <source>Any one of the above test cases would provide 100% statement coverage but all three are required for 100% branch coverage. Generally speaking, 100% branch coverage implies 100% statement coverage, but the converse is not true. To reemphasize, the &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; test harness for SQLite provides the stronger form of test coverage - 100% branch test coverage.</source>
          <target state="translated">上述测试用例中的任何一个都将提供100％的语句覆盖率，但是这三个条件都是100％分支覆盖率所必需的。一般而言，100％的分支覆盖率意味着100％的语句覆盖率，但反之则不成立。再次强调，用于SQLite 的&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;测试工具提供了更强大的测试覆盖率形式-100％分支测试覆盖率。</target>
        </trans-unit>
        <trans-unit id="82138b97f6d9555464cfec51a14a23b82edbc037" translate="yes" xml:space="preserve">
          <source>Any operators applied to column names, including the no-op unary &quot;+&quot; operator, convert the column name into an expression which always has no affinity. Hence even if X and Y.Z are column names, the expressions +X and +Y.Z are not column names and have no affinity.</source>
          <target state="translated">任何应用于列名的运算符,包括无操作的单数 &quot;+&quot;运算符,都会将列名转换为一个表达式,而这个表达式总是没有亲和力。因此,即使X和Y.Z是列名,表达式+X和+Y.Z也不是列名,没有亲和力。</target>
        </trans-unit>
        <trans-unit id="7fd223421c2a13bbb89b12c2862d7c77ef4b363f" translate="yes" xml:space="preserve">
          <source>Any other value for the b-tree page type is an error.</source>
          <target state="translated">b-tree页面类型的任何其他值都是一个错误。</target>
        </trans-unit>
        <trans-unit id="784db6f9216a4d895c7e958df2f8f40ae24919c7" translate="yes" xml:space="preserve">
          <source>Any scalar expression may be used in the LIMIT clause, so long as it evaluates to an integer or a value that can be losslessly converted to an integer. If the expression evaluates to a NULL value or any other value that cannot be losslessly converted to an integer, an error is returned. If the LIMIT expression evaluates to a negative value, then there is no upper bound on the number of rows returned. Otherwise, the SELECT returns the first N rows of its result set only, where N is the value that the LIMIT expression evaluates to. Or, if the SELECT statement would return less than N rows without a LIMIT clause, then the entire result set is returned.</source>
          <target state="translated">任何标量表达式都可以在LIMIT子句中使用,只要它的值是一个整数或一个可以无损转换为整数的值。如果表达式的值是一个NULL值或任何其他不能无损转换为整数的值,则返回一个错误。如果LIMIT表达式的值为负值,那么返回的行数没有上限。否则,SELECT只返回其结果集的前N条记录,其中N是LIMIT表达式所评估的值。或者,如果SELECT语句在没有LIMIT子句的情况下,返回的行数少于N行,那么将返回整个结果集。</target>
        </trans-unit>
        <trans-unit id="680384b496ab63e99e152271be6ec34547a5e90a" translate="yes" xml:space="preserve">
          <source>Any time there is an error either compiling an SQL statement (using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or its siblings) or running an SQL statement (using &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;) that error is logged.</source>
          <target state="translated">每当编译SQL语句（使用&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或其同级）或运行SQL语句（使用&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;）时发生错误时，都会记录该错误。</target>
        </trans-unit>
        <trans-unit id="b0e18824fe4a70b0f37b9e0cb34aa95b757ca28e" translate="yes" xml:space="preserve">
          <source>Any valid query will work against an R*Tree index. But the R*Tree implementation is designed to make two kinds of queries especially efficient. First, queries against the primary key are efficient:</source>
          <target state="translated">任何有效的查询都可以针对R*Tree索引工作。但R*Tree的实现是为了使两种查询特别高效。首先,针对主键的查询是高效的。</target>
        </trans-unit>
        <trans-unit id="dafef79386ae39cfa702a14aae7666f057897932" translate="yes" xml:space="preserve">
          <source>Any value returned by the openclose function is ignored. If an invocation made before opening a database returns an error, then the database file is not opened and the error returned to the user. This is the only scenario in which swarmvtab will issue an &quot;open&quot; invocation without also eventually issuing a corresponding &quot;close&quot; call. If there are still databases open, &quot;close&quot; calls may be issued from within the eventual sqlite3_close() call on the applications database that deletes the temp schema in which the swarmvtab table resides.</source>
          <target state="translated">openclose函数返回的任何值都会被忽略。如果在打开数据库之前进行的调用返回一个错误,那么数据库文件就不会被打开,并将错误返回给用户。这是swarmvtab发出 &quot;open &quot;调用而最终不发出相应的 &quot;close &quot;调用的唯一情况。如果仍然有数据库被打开,那么 &quot;关闭 &quot;调用可能会从应用程序数据库上最终的sqlite3_close()调用中发出,删除swarmvtab表所在的临时模式。</target>
        </trans-unit>
        <trans-unit id="cdf9bbefc76982e17471539cdea1217f5e1e0119" translate="yes" xml:space="preserve">
          <source>Anywhere</source>
          <target state="translated">Anywhere</target>
        </trans-unit>
        <trans-unit id="e511dd65bb11704e83c08777789bf5ec195f3d28" translate="yes" xml:space="preserve">
          <source>Apart from the root node, the nodes that make up a single segment b-tree are always stored using a contiguous sequence of blockids. Furthermore, the nodes that make up a single level of the b-tree are themselves stored as a contiguous block, in b-tree order. The contiguous sequence of blockids used to store the b-tree leaves are allocated starting with the blockid value stored in the &quot;start_block&quot; column of the corresponding %_segdir row, and finishing at the blockid value stored in the &quot;leaves_end_block&quot; field of the same row. It is therefore possible to iterate through all the leaves of a segment b-tree, in key order, by traversing the %_segments table in blockid order from &quot;start_block&quot; to &quot;leaves_end_block&quot;.</source>
          <target state="translated">除了根节点之外,构成单段b树的节点总是使用连续的块序来存储。此外,构成b树单层的节点本身也是按照b树顺序作为一个连续的块来存储的。用于存储b树叶子的连续的blockid序列是从相应%_segdir行的 &quot;start_block &quot;列中存储的blockid值开始分配的,最后以同一行的&quot; leaves_end_block &quot;字段中存储的blockid值结束。因此,可以按照键的顺序,从 &quot;start_block &quot;到&quot; leaves_end_block &quot;按blockid顺序遍历%_segments表,来遍历一个段b树的所有叶子。</target>
        </trans-unit>
        <trans-unit id="f6f3127b3255a243139304b57a2de9b375a5b278" translate="yes" xml:space="preserve">
          <source>Appears in...</source>
          <target state="translated">出现在...</target>
        </trans-unit>
        <trans-unit id="cddd694c6980e8f63fe16956f1fed6f2e36dd876" translate="yes" xml:space="preserve">
          <source>Appending a new</source>
          <target state="translated">附加一个新的</target>
        </trans-unit>
        <trans-unit id="939a673334c7c748561f23a3fd21e4918a1efbc3" translate="yes" xml:space="preserve">
          <source>Appending a new page to the database file.</source>
          <target state="translated">在数据库文件中添加一个新的页面。</target>
        </trans-unit>
        <trans-unit id="dff26bc78571c36fbf9a79d63221a8d63c4781c9" translate="yes" xml:space="preserve">
          <source>Appendix A: Comparison with FTS3/4</source>
          <target state="translated">附录A:与FTS3/4的比较</target>
        </trans-unit>
        <trans-unit id="2f62ea77455407c6d86c7651d5f030af0222ec84" translate="yes" xml:space="preserve">
          <source>Appendix A: Search Application Tips</source>
          <target state="translated">附录A:搜索应用技巧</target>
        </trans-unit>
        <trans-unit id="f9f1d1188ea485eedb2325535cccc6c2b70da6fd" translate="yes" xml:space="preserve">
          <source>Appendix B: Shadow tables created by FTS5</source>
          <target state="translated">附录B:FTS5创建的影子表</target>
        </trans-unit>
        <trans-unit id="24139aab1ccfea9a0794fea103821cef5044dd2c" translate="yes" xml:space="preserve">
          <source>Application Defined Page Cache</source>
          <target state="translated">应用定义的页面缓存</target>
        </trans-unit>
        <trans-unit id="8c42705eec7c415a6997bd8c9d3dc65da77e4f55" translate="yes" xml:space="preserve">
          <source>Application Defined Page Cache.</source>
          <target state="translated">应用定义的页面缓存。</target>
        </trans-unit>
        <trans-unit id="557031cad0f1b2b54264afc9d96a7aba19827147" translate="yes" xml:space="preserve">
          <source>Application ID</source>
          <target state="translated">申请号</target>
        </trans-unit>
        <trans-unit id="871e1857983850d1454dd7c60ae50af733931a7a" translate="yes" xml:space="preserve">
          <source>Application Interface</source>
          <target state="translated">应用界面</target>
        </trans-unit>
        <trans-unit id="a6c10e408404322943e578d89c2bff7889c626f3" translate="yes" xml:space="preserve">
          <source>Application Porting Guide</source>
          <target state="translated">应用移植指南</target>
        </trans-unit>
        <trans-unit id="a768f98624703793f6acc4a427b7a53a61477bff" translate="yes" xml:space="preserve">
          <source>Application can invoke the &lt;a href=&quot;#sqlitefcntltempfilename&quot; id=&quot;sqlitefcntltempfilename&quot;&gt;SQLITE_FCNTL_TEMPFILENAME&lt;/a&gt; file-control to have SQLite generate a temporary filename using the same algorithm that is followed to generate temporary filenames for TEMP tables and other internal uses. The argument should be a char** which will be filled with the filename written into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The caller should invoke &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; on the result to avoid a memory leak.</source>
          <target state="translated">应用程序可以调用&lt;a href=&quot;#sqlitefcntltempfilename&quot; id=&quot;sqlitefcntltempfilename&quot;&gt;SQLITE_FCNTL_TEMPFILENAME&lt;/a&gt;文件控件，以使SQLite使用与生成TEMP表和其他内部使用的临时文件名相同的算法来生成临时文件名。参数应为char **，它将使用从&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;获得的写入内存的文件名填充。调用方应在结果上调用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;以避免内存泄漏。</target>
        </trans-unit>
        <trans-unit id="3350dbe5c54d126511b6c09afcd8f51bea6a199c" translate="yes" xml:space="preserve">
          <source>Application can invoke the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntltempfilename&quot; id=&quot;sqlitefcntltempfilename&quot;&gt;SQLITE_FCNTL_TEMPFILENAME&lt;/a&gt; file-control to have SQLite generate a temporary filename using the same algorithm that is followed to generate temporary filenames for TEMP tables and other internal uses. The argument should be a char** which will be filled with the filename written into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The caller should invoke &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; on the result to avoid a memory leak.</source>
          <target state="translated">应用程序可以调用&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntltempfilename&quot; id=&quot;sqlitefcntltempfilename&quot;&gt;SQLITE_FCNTL_TEMPFILENAME&lt;/a&gt;文件控件，以使SQLite使用与生成TEMP表和其他内部使用的临时文件名相同的算法来生成临时文件名。参数应为char **，它将使用从&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;获得的写入内存的文件名填充。调用方应在结果上调用&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;以避免内存泄漏。</target>
        </trans-unit>
        <trans-unit id="4f4e99a2282eb2e1c855827ddf5f64dd418ab8c7" translate="yes" xml:space="preserve">
          <source>Application code is allowed to modify the sqlite_sequence table, to add new rows, to delete rows, or to modify existing rows. However, application code cannot create the sqlite_sequence table if it does not already exist. Application code can delete all entries from the sqlite_sequence table, but application code cannot drop the sqlite_sequence table.</source>
          <target state="translated">应用程序代码可以修改sqlite_sequence表,添加新的记录,删除记录,或者修改现有的记录。但是,如果sqlite_sequence表还不存在,应用程序代码不能创建该表。应用程序代码可以删除sqlite_sequence表中的所有条目,但应用程序代码不能删除sqlite_sequence表。</target>
        </trans-unit>
        <trans-unit id="04ce787e0da35dc9f49592d7babca6adb18799a3" translate="yes" xml:space="preserve">
          <source>Application-Defined SQL Functions</source>
          <target state="translated">应用定义的SQL函数</target>
        </trans-unit>
        <trans-unit id="2e1cbe2a441c6c1937a6117a0a716b80ac62de18" translate="yes" xml:space="preserve">
          <source>Application-defined SQL functions can become security vulnerabilities if not carefully managed. Suppose, for example, an application defines a new &quot;system(X)&quot; SQL function that runs its argument X as a command and returns the integer result code. Perhaps the implementation is like this:</source>
          <target state="translated">如果不小心管理,应用程序定义的SQL函数可能成为安全漏洞。例如,假设一个应用程序定义了一个新的 &quot;system(X)&quot;SQL函数,该函数将其参数X作为命令运行,并返回整数结果代码。也许实现方式是这样的。</target>
        </trans-unit>
        <trans-unit id="263c551ee583a68f5c9b570a6b7af2da5afc58f1" translate="yes" xml:space="preserve">
          <source>Application-defined collating functions</source>
          <target state="translated">应用定义的整理功能</target>
        </trans-unit>
        <trans-unit id="cc72ed4369f2c8e42dc0e63912d4e3ec80d61b1d" translate="yes" xml:space="preserve">
          <source>Application-defined or custom SQL functions are created using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; family of interfaces. Custom SQL functions can be scalar functions, aggregate functions, or &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;. Custom SQL functions can have any number of arguments from 0 up to &lt;a href=&quot;limits#max_function_arg&quot;&gt;SQLITE_MAX_FUNCTION_ARG&lt;/a&gt;. The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface specifies callbacks that are invoked to carry out the processing for the new SQL function.</source>
          <target state="translated">应用程序定义的或自定义的SQL函数是使用&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;系列接口创建的。自定义SQL函数可以是标量函数，聚合函数或&lt;a href=&quot;windowfunctions&quot;&gt;窗口函数&lt;/a&gt;。自定义SQL函数可以具有从0到&lt;a href=&quot;limits#max_function_arg&quot;&gt;SQLITE_MAX_FUNCTION_ARG的&lt;/a&gt;任意数量的参数。所述&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;被调用该接口指定的回调进行处理为新的SQL函数。</target>
        </trans-unit>
        <trans-unit id="25d0ad5ca7051d2b57b94a5f5601d3d125282b43" translate="yes" xml:space="preserve">
          <source>Applications are not required to use either of these standard memory allocators. If SQLite is compiled with &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt; then no implementation for the &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; functions is provided. Instead, the application that links against SQLite must provide its own implementation of these functions. The application provided memory allocator is not required to use the malloc()/free() implementation in the standard C library. An embedded application might provide an alternative memory allocator that uses memory for a fixed memory pool set aside for the exclusive use of SQLite, for example.</source>
          <target state="translated">不需要应用程序使用这些标准内存分配器中的任何一个。如果使用&lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt;编译SQLite，则不会提供&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;，&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;和&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;函数的实现。相反，与SQLite链接的应用程序必须提供自己的这些功能的实现。应用程序提供的内存分配器不需要使用标准C库中的malloc（）/ free（）实现。例如，嵌入式应用程序可能会提供备用内存分配器，该内存分配器将内存用于固定内存池，而预留给SQLite专用。</target>
        </trans-unit>
        <trans-unit id="38446a7215f8f42cf45502d1b63067076b840788" translate="yes" xml:space="preserve">
          <source>Applications are strongly discouraged from using this global variable. It is required to set a temporary folder on Windows Runtime (WinRT). But for all other platforms, it is highly recommended that applications neither read nor write this variable. This global variable is a relic that exists for backwards compatibility of legacy applications and should be avoided in new projects.</source>
          <target state="translated">强烈建议应用程序不要使用这个全局变量。在Windows Runtime (WinRT)上,需要设置一个临时文件夹。但对于所有其他平台,强烈建议应用程序既不读也不写这个变量。这个全局变量是一个遗迹,它的存在是为了向后兼容遗留的应用程序,在新项目中应该避免使用。</target>
        </trans-unit>
        <trans-unit id="180a26d65b478f96354579f1533f98cb44ab9c69" translate="yes" xml:space="preserve">
          <source>Applications can activate foreign key enforcement at run-time using the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; statement. Or, foreign key enforcement can be activated at compile-time using the &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;-DSQLITE_DEFAULT_FOREIGN_KEYS=1&lt;/a&gt; compile-time option.</source>
          <target state="translated">应用程序可以在运行时使用&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt;语句激活外键强制。或者，可以使用&lt;a href=&quot;compile#default_foreign_keys&quot;&gt;-DSQLITE_DEFAULT_FOREIGN_KEYS = 1&lt;/a&gt;编译时选项在编译时激活外键强制。</target>
        </trans-unit>
        <trans-unit id="fa39f6b2c61405c17ac04b8c804d6f91045049fb" translate="yes" xml:space="preserve">
          <source>Applications can call sqlite3_vfs_register() at any time, though of course a VFS needs to be registered before it can be used. The first argument is a pointer to a customized VFS object that the application has prepared. The second argument is true to make the new VFS the default VFS so that it will be used by the legacy &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; APIs. If the new VFS is not the default, then you will probably have to use the new &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; API to use it. Note, however, that if a new VFS is the only VFS known to SQLite (if SQLite was compiled without its usual default VFS or if the precompiled default VFS was removed using &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_unregister()&lt;/a&gt;) then the new VFS automatically becomes the default VFS regardless of the makeDflt argument to &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;.</source>
          <target state="translated">应用程序可以随时调用sqlite3_vfs_register（），尽管当然需要先注册一个VFS，然后才能使用它。第一个参数是指向应用程序已准备好的自定义VFS对象的指针。第二个参数为true，以使新的VFS成为默认VFS，以便旧的&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;和&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt; API 将使用它。如果新的VFS不是默认的VFS，则可能必须使用新的&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt; API才能使用它。但是请注意，如果新的VFS是SQLite已知的唯一VFS（如果SQLite是在没有其通常的默认VFS的情况下编译的，或者使用&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_unregister（）&lt;/a&gt;删除了预编译的默认VFS ）），则无论&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;的makeDflt参数如何，新的VFS都会自动成为默认VFS 。</target>
        </trans-unit>
        <trans-unit id="b2aaaa457f07aa308713a42a915ad2852c0b39a0" translate="yes" xml:space="preserve">
          <source>Applications can chose to store dates and times in any of these formats and freely convert between formats using the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt;.</source>
          <target state="translated">应用程序可以选择以任何一种格式存储日期和时间，并使用内置的&lt;a href=&quot;lang_datefunc&quot;&gt;日期和时间功能&lt;/a&gt;在格式之间自由转换。</target>
        </trans-unit>
        <trans-unit id="ec145e5678c1f6c0fcbe32fd22a6afa6e15334a5" translate="yes" xml:space="preserve">
          <source>Applications can easily read or write SQLite Archives by linking against SQLite and including the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/sqlar.c&quot;&gt;ext/misc/sqlar.c&lt;/a&gt; extension to handle the compression and decompression. The sqlar.c extension creates two new SQL functions.</source>
          <target state="translated">通过链接到SQLite并包括&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/sqlar.c&quot;&gt;ext / misc / sqlar.c&lt;/a&gt;扩展来处理压缩和解压缩，应用程序可以轻松读取或写入SQLite存档。sqlar.c扩展创建了两个新的SQL函数。</target>
        </trans-unit>
        <trans-unit id="1918677709e2695b409a42649a05c8c68141d7b8" translate="yes" xml:space="preserve">
          <source>Applications can invoke the &lt;a href=&quot;#sqlitefcntltempfilename&quot; id=&quot;sqlitefcntltempfilename&quot;&gt;SQLITE_FCNTL_TEMPFILENAME&lt;/a&gt; file-control to have SQLite generate a temporary filename using the same algorithm that is followed to generate temporary filenames for TEMP tables and other internal uses. The argument should be a char** which will be filled with the filename written into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The caller should invoke &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; on the result to avoid a memory leak.</source>
          <target state="translated">应用程序可以调用&lt;a href=&quot;#sqlitefcntltempfilename&quot; id=&quot;sqlitefcntltempfilename&quot;&gt;SQLITE_FCNTL_TEMPFILENAME&lt;/a&gt;文件控件，以使SQLite使用与生成TEMP表和其他内部使用的临时文件名相同的算法来生成临时文件名。参数应为char **，其中将填充从&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;获得的写入内存的文件名。调用方应在结果上调用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;以避免内存泄漏。</target>
        </trans-unit>
        <trans-unit id="8946e0c0b189dd677211bd451c25bb7e538671e1" translate="yes" xml:space="preserve">
          <source>Applications can invoke the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntltempfilename&quot; id=&quot;sqlitefcntltempfilename&quot;&gt;SQLITE_FCNTL_TEMPFILENAME&lt;/a&gt; file-control to have SQLite generate a temporary filename using the same algorithm that is followed to generate temporary filenames for TEMP tables and other internal uses. The argument should be a char** which will be filled with the filename written into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The caller should invoke &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; on the result to avoid a memory leak.</source>
          <target state="translated">应用程序可以调用&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntltempfilename&quot; id=&quot;sqlitefcntltempfilename&quot;&gt;SQLITE_FCNTL_TEMPFILENAME&lt;/a&gt;文件控件，以使SQLite使用与生成TEMP表和其他内部使用的临时文件名相同的算法来生成临时文件名。参数应为char **，其中将填充从&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;获得的写入内存的文件名。调用方应在结果上调用&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;以避免内存泄漏。</target>
        </trans-unit>
        <trans-unit id="10c37b1dc4c015883a2357b3c09de919e0c79e2e" translate="yes" xml:space="preserve">
          <source>Applications can leverage the &lt;a href=&quot;fts3&quot;&gt;full-text search&lt;/a&gt; and &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; indexes and use triggers to implement an &lt;a href=&quot;undoredo&quot;&gt;automated undo/redo stack&lt;/a&gt;.</source>
          <target state="translated">应用程序可以利用&lt;a href=&quot;fts3&quot;&gt;全文本搜索&lt;/a&gt;和&lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;索引，并使用触发器来实现&lt;a href=&quot;undoredo&quot;&gt;自动的撤消/重做堆栈&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="42c37342832f86fc16406f3d6f977afed5099fdf" translate="yes" xml:space="preserve">
          <source>Applications can use the &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log(E,F,..)&lt;/a&gt; API to send new messages to the log, if desired, but this is discouraged. The &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; interface is intended for use by extensions only, not by applications.</source>
          <target state="translated">如果需要，应用程序可以使用&lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log（E，F，..）&lt;/a&gt; API将新消息发送到日志，但是不建议这样做。所述&lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log（）&lt;/a&gt;接口只，而不是由应用程序打算由扩展。</target>
        </trans-unit>
        <trans-unit id="5b11300864c54770f7c5f526b6116f644fe6e616" translate="yes" xml:space="preserve">
          <source>Applications need to receive a pointer to the &quot;fts5_api&quot; object in order to add extensions, such as custom tokenizers, to the &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; extension.</source>
          <target state="translated">应用程序需要接收一个指向&amp;ldquo; fts5_api&amp;rdquo;对象的指针，以便将扩展（例如自定义标记器）添加到&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="c62d5c6028bfae4c8b01799ff1a016b8e43ca22c" translate="yes" xml:space="preserve">
          <source>Applications should &lt;a href=&quot;#sqlite3_finalize&quot;&gt;finalize&lt;/a&gt; all &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;close&lt;/a&gt; all &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;#sqlite3backupfinish&quot;&gt;finish&lt;/a&gt; all &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects associated with the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object prior to attempting to close the object. If sqlite3_close_v2() is called on a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that still has outstanding &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handles&lt;/a&gt;, and/or &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects then it returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; and the deallocation of resources is deferred until all &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects are also destroyed.</source>
          <target state="translated">应用程序应在尝试关闭对象之前，&lt;a href=&quot;#sqlite3_finalize&quot;&gt;完成&lt;/a&gt;所有&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;，&lt;a href=&quot;#sqlite3_blob_close&quot;&gt;关闭&lt;/a&gt;所有&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄&lt;/a&gt;，并&lt;a href=&quot;#sqlite3backupfinish&quot;&gt;完成&lt;/a&gt;与&lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象关联的所有&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象。如果在仍具有未完成的&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;，&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB处理&lt;/a&gt;和/或&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;上调用sqlite3_close_v2（），则它将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;并将资源的释放推迟到所有&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;，&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB处理&lt;/a&gt;和&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象也被销毁。</target>
        </trans-unit>
        <trans-unit id="370f3cced4e036aaca81af4fa9e5c1fe46910ebe" translate="yes" xml:space="preserve">
          <source>Applications should &lt;a href=&quot;finalize&quot;&gt;finalize&lt;/a&gt; all &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;blob_close&quot;&gt;close&lt;/a&gt; all &lt;a href=&quot;blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;finish&lt;/a&gt; all &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects associated with the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object prior to attempting to close the object. If sqlite3_close_v2() is called on a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that still has outstanding &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;blob&quot;&gt;BLOB handles&lt;/a&gt;, and/or &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects then it returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; and the deallocation of resources is deferred until all &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects are also destroyed.</source>
          <target state="translated">应用程序应在尝试关闭对象之前，&lt;a href=&quot;finalize&quot;&gt;完成&lt;/a&gt;所有&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;，&lt;a href=&quot;blob_close&quot;&gt;关闭&lt;/a&gt;所有&lt;a href=&quot;blob&quot;&gt;BLOB句柄&lt;/a&gt;，并&lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;完成&lt;/a&gt;与&lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象关联的所有&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象。如果在仍具有未完成的&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;，&lt;a href=&quot;blob&quot;&gt;BLOB处理&lt;/a&gt;和/或&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;上调用sqlite3_close_v2（），则它将返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;并将资源的释放推迟到所有&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;，&lt;a href=&quot;blob&quot;&gt;BLOB处理&lt;/a&gt;和&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象也被销毁。</target>
        </trans-unit>
        <trans-unit id="11da7d835aa708827d0f44dfb12fe45f22493e9a" translate="yes" xml:space="preserve">
          <source>Applications that accept untrusted SQL inputs should take the following precautions:</source>
          <target state="translated">接受不受信任的SQL输入的应用程序应采取以下预防措施。</target>
        </trans-unit>
        <trans-unit id="f32733159fe9563d84f7da23f8a179d0a799e2a5" translate="yes" xml:space="preserve">
          <source>Applications that accept untrusted database files should do the following:</source>
          <target state="translated">接受不受信任的数据库文件的应用程序应做到以下几点。</target>
        </trans-unit>
        <trans-unit id="e886a51fcb81bff62e2c48396e856865668d639c" translate="yes" xml:space="preserve">
          <source>Applications that already use SQLite for other purposes can easily add support for SQLite Archives using a small extension (&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/sqlar.c&quot;&gt;https://sqlite.org/src/file/ext/misc/sqlar.c&lt;/a&gt;) to handle the compression and decompression of content. Even this tiny extension can be omitted if the files in the archive are uncompressed. In contrast, supporting ZIP Archives and/or Tarballs requires either separate libraries or lots of extra custom code, or sometimes both.</source>
          <target state="translated">已经将SQLite用于其他目的的应用程序可以使用一个小的扩展名（&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/sqlar.c&quot;&gt;https://sqlite.org/src/file/ext/misc/sqlar.c&lt;/a&gt;）轻松添加对SQLite Archives的支持，以处理内容的压缩和解压缩。如果存档中的文件未压缩，则即使是这个很小的扩展名也可以忽略。相反，支持ZIP存档和/或Tarball则需要单独的库或大量额外的自定义代码，或者有时两者都需要。</target>
        </trans-unit>
        <trans-unit id="77baa4279beeeafb725407d72ddb6fda70fe7b8a" translate="yes" xml:space="preserve">
          <source>Applications that desire more control can run &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize(0x03)&lt;/a&gt; to obtain a list of ANALYZE commands that SQLite thinks are appropriate to run, but without actually running those commands. If the returned set is non-empty, the application can then make a decision about whether or not to run the suggested ANALYZE commands, perhaps after prompting the user for guidance.</source>
          <target state="translated">希望获得更多控制的应用程序可以运行&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMAoptimize（0x03）&lt;/a&gt;以获得SQLite认为适合运行的ANALYZE命令列表，但无需实际运行这些命令。如果返回的集合是非空的，则应用程序可以在提示用户进行指导之后，决定是否运行建议的ANALYZE命令。</target>
        </trans-unit>
        <trans-unit id="9bb5bae5e54c915160fb76cb9810521459a0328b" translate="yes" xml:space="preserve">
          <source>Applications that implement their own memory allocator must provide implementation for the usual three allocation functions &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;. And they must also implement a fourth function:</source>
          <target state="translated">实现自己的内存分配器的应用程序必须为通常的三个分配函数&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;，&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;和&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）提供实现&lt;/a&gt;。并且它们还必须实现第四个功能：</target>
        </trans-unit>
        <trans-unit id="3276d7f69778b6a6958211df873305e75fc12066" translate="yes" xml:space="preserve">
          <source>Applications that need to process SQL from untrusted sources might also consider lowering resource limits using &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt; and limiting database size using the &lt;a href=&quot;pragma#pragma_max_page_count&quot;&gt;max_page_count&lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; in addition to using an authorizer.</source>
          <target state="translated">需要使用不受信任来源处理SQL的应用程序除了使用授权器之外，还可以考虑使用&lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;降低资源限制，并使用&lt;a href=&quot;pragma#pragma_max_page_count&quot;&gt;max_page_count &lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;限制数据库大小。</target>
        </trans-unit>
        <trans-unit id="354d6571e51ed32448c014f215aad54793f93f19" translate="yes" xml:space="preserve">
          <source>Applications that need to process SQL from untrusted sources might also consider lowering resource limits using &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt; and limiting database size using the &lt;a href=&quot;../pragma#pragma_max_page_count&quot;&gt;max_page_count&lt;/a&gt;&lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; in addition to using an authorizer.</source>
          <target state="translated">需要使用不受信任来源处理SQL的应用程序除了使用授权器之外，还可以考虑使用&lt;a href=&quot;limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;降低资源限制，并使用&lt;a href=&quot;../pragma#pragma_max_page_count&quot;&gt;max_page_count &lt;/a&gt;&lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;限制数据库大小。</target>
        </trans-unit>
        <trans-unit id="a8e172472dcda9eeff06e1a92573e0211e5da692" translate="yes" xml:space="preserve">
          <source>Applications that read or write SQLite database files of uncertain provenance should take precautions enumerated below.</source>
          <target state="translated">读取或写入出处不明的SQLite数据库文件的应用程序应采取以下列举的预防措施。</target>
        </trans-unit>
        <trans-unit id="20b510dde80120d96a00c84ffe0b865066e5c9f7" translate="yes" xml:space="preserve">
          <source>Applications that use SQLite can define custom SQL functions that call back into application code to compute their results. The custom SQL function implementations can be embedded in the application code itself, or can be &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt;.</source>
          <target state="translated">使用SQLite的应用程序可以定义自定义SQL函数，这些函数将回调到应用程序代码中以计算其结果。定制SQL函数实现可以嵌入在应用程序代码本身中，也可以是&lt;a href=&quot;loadext&quot;&gt;可加载的扩展&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="56219a273baff8fb63d4f640239c5a3823587f98" translate="yes" xml:space="preserve">
          <source>Applications using the split amalgamation simply compile against &quot;sqlite3-all.c&quot; instead of &quot;sqlite3.c&quot;. The two files work exactly the same. But with &quot;sqlite3-all.c&quot;, no single source file contains more than 32,767 lines of code, and so it is more convenient to use some debuggers. The downside of the split amalgamation is that it consists of 6 C source code files instead of just 1.</source>
          <target state="translated">使用分割合并法的应用程序只需针对 &quot;sqlite3-all.c &quot;而不是 &quot;sqlite3.c &quot;进行编译即可。这两个文件的工作原理完全一样。但使用 &quot;sqlite3-all.c &quot;时,单个源文件包含的代码都不会超过32767行,因此使用一些调试器比较方便。拆分合并的缺点是它由6个C源代码文件组成,而不是只有1个。</target>
        </trans-unit>
        <trans-unit id="1d0b5bb7dc63af158df007b2dc9a7b8099c0d304" translate="yes" xml:space="preserve">
          <source>Applications with long-lived databases that use complex queries should consider running the following commands just prior to closing each database connection:</source>
          <target state="translated">对于使用复杂查询的长寿命数据库的应用程序,应考虑在关闭每个数据库连接之前运行以下命令。</target>
        </trans-unit>
        <trans-unit id="514f9d7fb93d92d6765510a1359338148e757312" translate="yes" xml:space="preserve">
          <source>Apply A Changeset To A Database</source>
          <target state="translated">将一个变更集应用到数据库</target>
        </trans-unit>
        <trans-unit id="0f306fb05632f0f4db7dd5e5ff03c213825dd25d" translate="yes" xml:space="preserve">
          <source>Apply a changeset or patchset to a database. These functions attempt to update the &quot;main&quot; database attached to handle db with the changes found in the changeset passed via the second and third arguments.</source>
          <target state="translated">将一个变化集或补丁集应用到数据库中。这些函数试图用通过第二和第三个参数传递的变化集中发现的变化更新连接到handle db的 &quot;主 &quot;数据库。</target>
        </trans-unit>
        <trans-unit id="a7bf4a5600a606d3a4f075dab8912ba1aa9d1deb" translate="yes" xml:space="preserve">
          <source>Apply affinities to a range of P2 registers starting with P1.</source>
          <target state="translated">将亲和力应用到从P1开始的一系列P2寄存器中。</target>
        </trans-unit>
        <trans-unit id="d9053b57f5f861486073c17aece29454b87cf37a" translate="yes" xml:space="preserve">
          <source>Applying a changeset to a database is simpler than capturing a changeset. Usually, a single call to &lt;a href=&quot;session/sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, as depicted in the example code below, suffices.</source>
          <target state="translated">将变更集应用于数据库比捕获变更集更简单。通常，只需调用&lt;a href=&quot;session/sqlite3changeset_apply&quot;&gt;一次sqlite3changeset_apply（）&lt;/a&gt;（如下面的示例代码所示）就足够了。</target>
        </trans-unit>
        <trans-unit id="9d64c94c92e46add367d8f8d91e1e8dd6a71ae2e" translate="yes" xml:space="preserve">
          <source>Appropriate Uses For SQLite</source>
          <target state="translated">SQLite的适当用途</target>
        </trans-unit>
        <trans-unit id="7db317caf72bb7c9dbfdfdc313cade8bdb182e98" translate="yes" xml:space="preserve">
          <source>Approx. Date</source>
          <target state="translated">大约日期</target>
        </trans-unit>
        <trans-unit id="63a877b9c97333a0f773b586cf9b6ea0abe4710d" translate="yes" xml:space="preserve">
          <source>Approximately 25% better performance from the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展将&lt;/a&gt;性能提高约25％。</target>
        </trans-unit>
        <trans-unit id="1acd094f8de42870eb88cfeea3ebc197767f3b95" translate="yes" xml:space="preserve">
          <source>Architecture of SQLite</source>
          <target state="translated">SQLite的架构</target>
        </trans-unit>
        <trans-unit id="f076fb02f05c0b3b0347a8ec181af332464b574d" translate="yes" xml:space="preserve">
          <source>Are there any known size limits to SQLite databases?</source>
          <target state="translated">SQLite数据库有什么已知的大小限制吗?</target>
        </trans-unit>
        <trans-unit id="ce5e5792e97fe5c7861d6ae9b29cf5a25cc0e70a" translate="yes" xml:space="preserve">
          <source>Argument</source>
          <target state="translated">Argument</target>
        </trans-unit>
        <trans-unit id="c4d2bb6ff9ec16533c1c379a0a3c41d194bcc183" translate="yes" xml:space="preserve">
          <source>Argument T is the name of the database file to vacuum. Argument S is the name of a database in which the RBU module will save its state if the vacuum operation is suspended.</source>
          <target state="translated">参数T是要进行真空操作的数据库文件的名称。参数S是一个数据库的名称,如果真空操作暂停,RBU模块将在其中保存其状态。</target>
        </trans-unit>
        <trans-unit id="0059fb3429a6e57de6b5c01cc5ac92570ab99c32" translate="yes" xml:space="preserve">
          <source>Argument iVal must be greater than or equal to 0, and less than the number of columns in the table affected by the current change. Otherwise, &lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned and *ppValue is set to NULL.</source>
          <target state="translated">参数iVal必须大于或等于0，并且小于受当前更改影响的表中的列数。否则，返回&lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt;并将* ppValue设置为NULL。</target>
        </trans-unit>
        <trans-unit id="12689143ab00ad889ba38fb7f63c86273b0da663" translate="yes" xml:space="preserve">
          <source>Argument iVal must be greater than or equal to 0, and less than the number of columns in the table affected by the current change. Otherwise, &lt;a href=&quot;rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned and *ppValue is set to NULL.</source>
          <target state="translated">参数iVal必须大于或等于0，并且小于受当前更改影响的表中的列数。否则，返回&lt;a href=&quot;rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt;并将* ppValue设置为NULL。</target>
        </trans-unit>
        <trans-unit id="71b5b8ce6122da2fb2f466eddd7275074f8cc26d" translate="yes" xml:space="preserve">
          <source>Argument pIn must point to a buffer containing a changeset nIn bytes in size. This function allocates and populates a buffer with a copy of the changeset rebased according to the configuration of the rebaser object passed as the first argument. If successful, (*ppOut) is set to point to the new buffer containing the rebased changeset and (*pnOut) to its size in bytes and SQLITE_OK returned. It is the responsibility of the caller to eventually free the new buffer using sqlite3_free(). Otherwise, if an error occurs, (*ppOut) and (*pnOut) are set to zero and an SQLite error code returned.</source>
          <target state="translated">参数pIn必须指向一个包含大小为nIn字节的变化集的缓冲区。这个函数根据作为第一个参数传递的rebaser对象的配置,分配并填充一个缓冲区,其中包含一个基于变化集的副本。如果成功,(*ppOut)被设置为指向新的缓冲区,该缓冲区中包含了以字节为单位的变化集,(*pnOut)指向其大小,并返回SQLITE_OK。调用者有责任使用 sqlite3_free()最终释放新的缓冲区。否则,如果发生错误,(*ppOut)和(*pnOut)将被设置为0,并返回一个SQLite错误代码。</target>
        </trans-unit>
        <trans-unit id="1502f4d9bcf958ec2d3f9df8d5434c6f3fb95622" translate="yes" xml:space="preserve">
          <source>Argument pIn must point to a buffer containing a changeset nIn bytes in size. This function allocates and populates a buffer with a copy of the changeset rebased rebased according to the configuration of the rebaser object passed as the first argument. If successful, (*ppOut) is set to point to the new buffer containing the rebased changeset and (*pnOut) to its size in bytes and SQLITE_OK returned. It is the responsibility of the caller to eventually free the new buffer using sqlite3_free(). Otherwise, if an error occurs, (*ppOut) and (*pnOut) are set to zero and an SQLite error code returned.</source>
          <target state="translated">参数pIn必须指向一个包含大小为nIn字节的变化集的缓冲区。这个函数根据作为第一个参数传递的rebaser对象的配置,分配并填充一个缓冲区,其中包含一个变化集rebased的副本。如果成功的话,(*ppOut)将被设置为指向包含rebased变化集的新缓冲区,(*pnOut)将指向它的字节大小,并返回SQLITE_OK。调用者有责任使用 sqlite3_free()最终释放新的缓冲区。否则,如果发生错误,(*ppOut)和(*pnOut)将被设置为0,并返回一个SQLite错误代码。</target>
        </trans-unit>
        <trans-unit id="3273cfe93e49705347b0b90c1dbaf9e32a834424" translate="yes" xml:space="preserve">
          <source>Argument zFromDb must be the name of a database (&quot;main&quot;, &quot;temp&quot; etc.) attached to the same database handle as the session object that contains a table compatible with the table attached to the session by this function. A table is considered compatible if it:</source>
          <target state="translated">参数zFromDb必须是一个数据库的名称(&quot;main&quot;,&quot;temp &quot;等),该数据库与session对象连接在同一个数据库句柄上,它包含一个与本函数连接到session的表兼容的表。如果一个表被认为是兼容的,那么它</target>
        </trans-unit>
        <trans-unit id="c2dd08aa3192624f9fd5e4d0f584709c36b430c5" translate="yes" xml:space="preserve">
          <source>Arguments on the virtual table name are matched to &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden columns&lt;/a&gt; in order. The number of arguments can be less than the number of hidden columns, in which case the latter hidden columns are unconstrained. However, an error results if there are more arguments than there are hidden columns in the virtual table.</source>
          <target state="translated">虚拟表名称上的参数按顺序与&lt;a href=&quot;vtab#hiddencol&quot;&gt;隐藏列&lt;/a&gt;匹配。参数的数量可以小于隐藏列的数量，在这种情况下，后面的隐藏列不受限制。但是，如果参数多于虚拟表中的隐藏列，则会导致错误。</target>
        </trans-unit>
        <trans-unit id="90539d8182e17636548ae12105ee212ec9b16743" translate="yes" xml:space="preserve">
          <source>As SQLite developers edit the SQLite source code, they run the &lt;a href=&quot;https://sqlite.org/src/file/tool/speed-check.sh&quot;&gt;speed-check.sh&lt;/a&gt; shell script to track the performance impact of changes. This script compiles the speedtest1.c program, runs it under cachegrind, processes the cachegrind output using the &lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;cg_anno.tcl&lt;/a&gt; TCL script, then saves the results in a series of text files. Typical output from the speed-check.sh script looks like this:</source>
          <target state="translated">当SQLite开发人员编辑SQLite源代码时，他们运行&lt;a href=&quot;https://sqlite.org/src/file/tool/speed-check.sh&quot;&gt;speed-check.sh&lt;/a&gt; Shell脚本来跟踪更改对性能的影响。该脚本编译speedtest1.c程序，在cachegrind下运行，使用&lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;cg_anno.tcl&lt;/a&gt; TCL脚本处理cachegrind输出，然后将结果保存在一系列文本文件中。speed-check.sh脚本的典型输出如下所示：</target>
        </trans-unit>
        <trans-unit id="7ed7acd0a6e6b88f39315ac5d476eef951a2dd64" translate="yes" xml:space="preserve">
          <source>As a REAL value that is the fractional &lt;a href=&quot;https://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day number&lt;/a&gt;.</source>
          <target state="translated">作为REAL值，是分数&lt;a href=&quot;https://en.wikipedia.org/wiki/Julian_day&quot;&gt;儒略日数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4eeeee2e0c94cffee5c99d0db2b5529b4ec1659" translate="yes" xml:space="preserve">
          <source>As a TEXT string in the ISO-8601 format. Example: '2018-04-02 12:13:46'.</source>
          <target state="translated">作为ISO-8601格式的TEXT字符串。例如:'2018-04-02 12:13:46'。</target>
        </trans-unit>
        <trans-unit id="e71c00fe61fb07ca9e09493bb8ec226ec4260341" translate="yes" xml:space="preserve">
          <source>As a TEXT string in the ISO-8610 format. Example: '2018-04-02 12:13:46'.</source>
          <target state="translated">作为ISO-8610格式的TEXT字符串。例如:'2018-04-02 12:13:46'。</target>
        </trans-unit>
        <trans-unit id="1f5eb53c0fa9975ea0940d4a4405ff35765d1d45" translate="yes" xml:space="preserve">
          <source>As a performance optimization, reduce actions in the Lemon input grammar are allowed to contain comments of the form &quot;/*A-overwrites-Z*/&quot; to indicate that the semantic value &quot;A&quot; on the right-hand side of the rule is allowed to directly overwrite the semantic value &quot;Z&quot; on the left-hand side. This simple optimization reduces the number of stack operations in the push-down automaton used to parse the input grammar, and thus improve performance of the parser. It also makes the generated code a little smaller.</source>
          <target state="translated">作为一种性能优化,Lemon输入语法中的reduce动作允许包含&quot;/*A-覆盖-Z*/&quot;形式的注释,以表示允许规则右侧的语义值 &quot;A &quot;直接覆盖左侧的语义值 &quot;Z&quot;。这个简单的优化减少了用于解析输入语法的推倒式自动机的堆栈操作次数,从而提高了解析器的性能。同时也使生成的代码更小一些。</target>
        </trans-unit>
        <trans-unit id="7bcc1829db91ffdb7536f92aca2feacdc8bcb274" translate="yes" xml:space="preserve">
          <source>As an FTS5 bareword that is not &quot;AND&quot;, &quot;OR&quot; or &quot;NOT&quot; (case sensitive). An FTS5 bareword is a string of one or more consecutive characters that are all either:</source>
          <target state="translated">作为一个非 &quot;AND&quot;、&quot;OR &quot;或 &quot;NOT&quot;(区分大小写)的FTS5裸词。FTS5裸字是一个由一个或多个连续字符组成的字符串,这些字符都是:</target>
        </trans-unit>
        <trans-unit id="3f6cab6c41155dd3c9ab5be0d8403065e3d7dbaf" translate="yes" xml:space="preserve">
          <source>As an INTEGER number of seconds since 1970 (also known as &quot;unix time&quot;).</source>
          <target state="translated">作为1970年以来的INTEGER秒数(也称为 &quot;unix时间&quot;)。</target>
        </trans-unit>
        <trans-unit id="32bbd071581bca01328b9dfe1b573f6b34f404d8" translate="yes" xml:space="preserve">
          <source>As an alternative to step 3 above, the transaction may be rolled back. Transaction rollback is described in section</source>
          <target state="translated">作为上述步骤3的另一种选择,交易可以被回滚。交易回滚在第3节中描述。</target>
        </trans-unit>
        <trans-unit id="71c1a7847b731be97050a398f7845485ca21aaa1" translate="yes" xml:space="preserve">
          <source>As an example of how UPDATE-FROM can be useful, suppose you have a point-of-sale application that accumulates purchases in the SALES table. At the end of the day, you want to adjust the INVENTORY table according to the daily sales. To do this, you can run an UPDATE against the INVENTORY table that adjusts the quantity by the aggregated sales for the day. The statement would look like this:</source>
          <target state="translated">作为UPDATE-ROM如何有用的一个例子,假设你有一个销售点应用程序,它在SALES表中积累了购买量。在一天结束时,您想根据每天的销售情况调整INVENTORY表。要做到这一点,您可以对INVENTORY表运行UPDATE,根据当天的汇总销售额调整数量。语句的内容是这样的。</target>
        </trans-unit>
        <trans-unit id="131746c3b1aff392f599c85628677c24f8811860" translate="yes" xml:space="preserve">
          <source>As an example of the result table format, suppose a query result is as follows:</source>
          <target state="translated">作为结果表格式的一个例子,假设一个查询结果如下。</target>
        </trans-unit>
        <trans-unit id="592d95d98cfd4f715eed1be5091215e09168934a" translate="yes" xml:space="preserve">
          <source>As an example, consider a virtual table implementation that provides read-only access to existing comma-separated-value (CSV) files on disk. There is no backing store that needs to be created or initialized for such a virtual table (since the CSV files already exist on disk) so the xCreate and xConnect methods will be identical for that module.</source>
          <target state="translated">举个例子,考虑一个虚拟表的实现,它提供对磁盘上现有的逗号分隔值(CSV)文件的只读访问。对于这样的虚拟表,不需要创建或初始化后备存储(因为 CSV 文件已经存在于磁盘上),所以对于该模块,xCreate 和 xConnect 方法将是相同的。</target>
        </trans-unit>
        <trans-unit id="0e3486a0e62ced4a8499838d1b8b7393bbcb9f1f" translate="yes" xml:space="preserve">
          <source>As an example, consider creating a two-dimensional R*Tree index for use in spatial queries:</source>
          <target state="translated">举个例子,考虑创建一个用于空间查询的二维R*Tree索引。</target>
        </trans-unit>
        <trans-unit id="1f3a827b13a126faa4b33b0ce651746d14a8fc48" translate="yes" xml:space="preserve">
          <source>As an example, consider the following query:</source>
          <target state="translated">举个例子,考虑以下查询。</target>
        </trans-unit>
        <trans-unit id="22e02419a6c1aa60126918f747f9d30c0add3ddc" translate="yes" xml:space="preserve">
          <source>As an example, consider the following table that tracks dollar-amount changes on various &quot;accounts&quot;:</source>
          <target state="translated">举例来说,请看下表,该表跟踪各种 &quot;账户 &quot;的美元金额变化。</target>
        </trans-unit>
        <trans-unit id="9685f258b372a754415995a52cb6b9f9c3a80f7a" translate="yes" xml:space="preserve">
          <source>As an example, suppose someone (perhaps a customer) asks you: &quot;What ever became of that 'prefer-coroutine-sort-subquery' branch from two years ago?&quot; You might try to answer the query by consulting the history in your version control system, thusly:</source>
          <target state="translated">举个例子,假设有人(可能是客户)问你:&quot;两年前的那个'prefer-coroutine-sort-subquery'分支怎么了?&quot;两年前的那个'prefer -coroutine -sort -subquery'分支后来怎么样了?&quot; 你可以试着通过查阅版本控制系统中的历史记录来回答这个疑问,这样。</target>
        </trans-unit>
        <trans-unit id="34ff54cf6acce621207ec9ac9f6485fedf9ef893" translate="yes" xml:space="preserve">
          <source>As an example, the following graphic:</source>
          <target state="translated">举个例子,下面的图形。</target>
        </trans-unit>
        <trans-unit id="d8a7709446ce5823dd6ac2917092a6664f0dbd82" translate="yes" xml:space="preserve">
          <source>As an example, the following setup causes TCL to throw an error if an SQL statement contains an parameter that does not match any global TCL variable:</source>
          <target state="translated">举个例子,如果一个SQL语句包含的参数不符合任何全局TCL变量,下面的设置会导致TCL抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="0ed757795f16facadb1fc50b83304333bb04670f" translate="yes" xml:space="preserve">
          <source>As an example, the following table show the relative sizes for an SQLite Archive, a ZIP Archive, and a Tarball of the 1,743 files in the SQLite 3.22.0 source tree:</source>
          <target state="translated">作为一个例子,下面的表格显示了SQLite Archive、ZIP Archive和Tarball的1,743个文件在SQLite 3.22.0源代码树中的相对大小。</target>
        </trans-unit>
        <trans-unit id="9d15dfd61e0635160b8312b26c2789af818a9391" translate="yes" xml:space="preserve">
          <source>As an ordinary SQLite table, &quot;wordcount&quot; is implemented as two separate B-Trees. The main table uses the hidden rowid value as the key and stores the &quot;word&quot; and &quot;cnt&quot; columns as data. The &quot;TEXT PRIMARY KEY&quot; phrase of the CREATE TABLE statement causes the creation of an &lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;unique index&lt;/a&gt; on the &quot;word&quot; column. This index is a separate B-Tree that uses &quot;word&quot; and the &quot;rowid&quot; as the key and stores no data at all. Note that the complete text of every &quot;word&quot; is stored twice: once in the main table and again in the index.</source>
          <target state="translated">作为普通的SQLite表，&amp;ldquo; wordcount&amp;rdquo;被实现为两个单独的B树。主表使用隐藏的rowid值作为键，并将&amp;ldquo; word&amp;rdquo;和&amp;ldquo; cnt&amp;rdquo;列存储为数据。 CREATE TABLE语句的&amp;ldquo; TEXT PRIMARY KEY&amp;rdquo;短语导致在&amp;ldquo; word&amp;rdquo;列上创建&lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;唯一索引&lt;/a&gt;。该索引是一个单独的B树，它使用&amp;ldquo;单词&amp;rdquo;和&amp;ldquo; rowid&amp;rdquo;作为键，并且根本不存储任何数据。请注意，每个&amp;ldquo;单词&amp;rdquo;的全文均存储两次：一次在主表中，另一次在索引中。</target>
        </trans-unit>
        <trans-unit id="8276f7702973f7730b88b6137faf5d630b77f015" translate="yes" xml:space="preserve">
          <source>As before, SQLite does single binary search for the range of rows in the covering index that satisfy the WHERE clause, the scans that range from top to bottom to get the desired results. The rows that satisfy the WHERE clause are guaranteed to be adjacent since the WHERE clause is an equality constraint on the left-most column of the index. And by scanning the matching index rows from top to bottom, the output is guaranteed to be ordered by state since the state column is the very next column to the right of the fruit column. And so the resulting query is very efficient.</source>
          <target state="translated">和之前一样,SQLite对覆盖索引中满足WHERE子句的行的范围进行单二元搜索,即从上到下的扫描,以得到所需的结果。由于WHERE子句是对索引最左列的平等约束,所以保证满足WHERE子句的行是相邻的。而通过从上到下扫描匹配的索引行,保证输出的结果是按状态排序的,因为状态列是果列右边的最下一列。所以得出的查询效率非常高。</target>
        </trans-unit>
        <trans-unit id="15882cefbefb220ce1658791117147edd8cba359" translate="yes" xml:space="preserve">
          <source>As before, the Column instruction uses cursor P1 and pushes the data record in column P2 (1, column &quot;two&quot;) onto the stack. The Integer instruction pushes the value 50 onto the top of the stack. After these two instructions the stack looks like:</source>
          <target state="translated">与之前一样,Column指令使用光标P1,将P2列(1,&quot;二 &quot;列)中的数据记录推到堆栈上。整数指令将数值50推到堆栈的顶部。经过这两条指令后,堆栈的样子是这样的。</target>
        </trans-unit>
        <trans-unit id="6c0707574912e68bc0443d44af5e83d6ee57452b" translate="yes" xml:space="preserve">
          <source>As before, the second insert on the left will fail because the comparison will convert both strings into floating-point number first and the only difference in the strings is in the 20-th digit which exceeds the resolution of a 64-bit float. In contrast, the second insert on the right will work because in that case, the numbers being inserted are strings and are compared using memcmp().</source>
          <target state="translated">如前所述,左边的第二个插入将失败,因为比较将首先把两个字符串转换为浮点数,字符串的唯一区别在于超过64位浮点的分辨率的第20位。相反,右边的第二个插入会成功,因为在这种情况下,插入的数字是字符串,并使用memcmp()进行比较。</target>
        </trans-unit>
        <trans-unit id="021a9e62497cd6d1534e29c131c8485644cff8ee" translate="yes" xml:space="preserve">
          <source>As can be seen above, a single run of multitest.tcl invokes th3make dozens of times and takes between 12 and 24 CPU hours. The middle section of the output shows the arguments to each individual th3make run and the result and elapse time for that th3make. All build products and output for the separate th3make runs are captures in subdirectories for post-test analysis. The two-line summary at the bottom shows the total number of errors and tests over all th3make runs and the total elapse time, together with the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; information for the version of SQLite that was tested. This summary information is recorded in the &lt;a href=&quot;https://www.sqlite.org/checklists&quot;&gt;release checklist&lt;/a&gt; during final testing.</source>
          <target state="translated">从上面可以看出，单次运行multitest.tcl会调用th3make数十次，耗时12至24个CPU小时。输出的中间部分显示每个th3make运行的参数以及该th3make的结果和运行时间。单独的th3make运行的所有构建产品和输出都捕获在子目录中，以进行测试后分析。底部的两行摘要显示了所有th3make运行中的错误和测试总数，总运行时间，以及所测试SQLite版本的&lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;信息。在最终测试期间，此摘要信息记录在&lt;a href=&quot;https://www.sqlite.org/checklists&quot;&gt;发布清单&lt;/a&gt;中。</target>
        </trans-unit>
        <trans-unit id="a57eec57195e396346032e284f403497e2a6ca2c" translate="yes" xml:space="preserve">
          <source>As far as we can tell, the SQL language specification allows the use of manifest typing. Nevertheless, most other SQL database engines are statically typed and so some people feel that the use of manifest typing is a bug in SQLite. But the authors of SQLite feel very strongly that this is a feature. The use of manifest typing in SQLite is a deliberate design decision which has proven in practice to make SQLite more reliable and easier to use, especially when used in combination with dynamically typed programming languages such as Tcl and Python.</source>
          <target state="translated">据我们所知,SQL语言规范允许使用manifest类型。尽管如此,大多数其他的SQL数据库引擎都是静态类型化的,所以有些人觉得使用manifest类型化是SQLite的一个bug。但是,SQLite的作者们非常强烈地感觉到这是一个特性。在SQLite中使用manifest类型是一个深思熟虑的设计决定,实践证明,它使SQLite更可靠,更容易使用,特别是与Tcl和Python等动态类型的编程语言结合使用时。</target>
        </trans-unit>
        <trans-unit id="fc29e0fdbff3d25477a8e029f9259bac6f50556e" translate="yes" xml:space="preserve">
          <source>As for all other SQLite tables, virtual or otherwise, data is retrieved from FTS tables using a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement.</source>
          <target state="translated">对于所有其他SQLite表（虚拟表或其他表），使用&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句从FTS表中检索数据。</target>
        </trans-unit>
        <trans-unit id="e10a21db398e4cbe3920a0271ec03a17da9374a2" translate="yes" xml:space="preserve">
          <source>As in &lt;a href=&quot;#section_3_11&quot;&gt;section 3.11&lt;/a&gt;, the journal file might be truncated to zero length or its header might be overwritten with zeros as an optimization on systems where deleting a file is expensive. Either way, the journal is no longer hot after this step.</source>
          <target state="translated">如&lt;a href=&quot;#section_3_11&quot;&gt;3.11节&lt;/a&gt;所述，日志文件的长度可能会被截断为零，或者其头可能会被零覆盖，这是在删除文件的开销较大的系统上进行的优化。无论哪种方式，在此步骤之后，日记都不再热。</target>
        </trans-unit>
        <trans-unit id="4a052665302d7ed15dacb760a0e1d99f7e61c18a" translate="yes" xml:space="preserve">
          <source>As in the INSERT example, we push the database number P1 (0, the main database) onto the stack and use OpenWrite to open the cursor P1 on table P2 (base page 3, &quot;examp&quot;) for modification.</source>
          <target state="translated">和INSERT的例子一样,我们将数据库号P1(0,主数据库)推到堆栈上,用OpenWrite打开表P2(基页3,&quot;examp&quot;)上的游标P1进行修改。</target>
        </trans-unit>
        <trans-unit id="493b86f021b95461d337801ffc16a105b55e8b55" translate="yes" xml:space="preserve">
          <source>As in the SELECT example, the &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; instruction rewinds the cursor to the beginning of the table, readying it for use in the loop body.</source>
          <target state="translated">与SELECT示例中一样，&lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt;指令将光标后退到表的开头，以备在循环体中使用。</target>
        </trans-unit>
        <trans-unit id="164cc333da63b4862e96f8a93857b770263a0e06" translate="yes" xml:space="preserve">
          <source>As is the case for a</source>
          <target state="translated">如同</target>
        </trans-unit>
        <trans-unit id="ed24902923099bb89f817d03e0f964e2ddf3fe73" translate="yes" xml:space="preserve">
          <source>As its name implies, an R*Tree is organized as a tree. Each node of the tree is a bounding box. The root of the tree is a bounding box that encapsulates all elements of the tree. Beneath the root are a number of subtrees (typically 20 or more) each with their own smaller bounding boxes and each containing some subset of the R*Tree entries. The subtrees may have sub-subtrees, and so forth until finally one reaches the leaves of the tree which are the actual R*Tree entries.</source>
          <target state="translated">顾名思义,R*Tree的组织形式是一棵树。树的每一个节点都是一个边界框,树的根是一个边界框,封装了树的所有元素。树的根是一个边界框,封装了树的所有元素。在根的下面是一些子树(通常是20个或更多),每个子树都有自己较小的边界框,每个子树都包含R*Tree条目的一些子集。子树可以有子子树,以此类推,直到最后到达树的叶子,即实际的R*Tree条目。</target>
        </trans-unit>
        <trans-unit id="1329f3ec0fa61448c27dc490e807fec1b74fd581" translate="yes" xml:space="preserve">
          <source>As its name suggests, the &quot;close&quot; method to an SQLite database just closes the database. This has the side-effect of deleting the</source>
          <target state="translated">顾名思义,SQLite数据库的 &quot;关闭 &quot;方法只是关闭数据库。这样做的副作用是删除了数据库中的</target>
        </trans-unit>
        <trans-unit id="3b9e6df535e040569dafb3fcef3111ff226a3e67" translate="yes" xml:space="preserve">
          <source>As long as the buffer size is greater than zero, sqlite3_snprintf() guarantees that the buffer is always zero-terminated. The first parameter &quot;n&quot; is the total size of the buffer, including space for the zero terminator. So the longest string that can be completely written will be n-1 characters.</source>
          <target state="translated">只要缓冲区的大小大于零,sqlite3_snprintf()保证缓冲区总是零结束符。第一个参数 &quot;n &quot;是缓冲区的总大小,包括零结束符的空间。所以能完全写入的最长字符串将是n-1个字符。</target>
        </trans-unit>
        <trans-unit id="26ea5ee053d47ffa17dd452debb3d0d447e3ffce" translate="yes" xml:space="preserve">
          <source>As long as the input parameter is correct, these routines can only fail if an out-of-memory error occurs during a format conversion. Only the following subset of interfaces are subject to out-of-memory errors:</source>
          <target state="translated">只要输入参数正确,只有在格式转换过程中发生内存外错误时,这些例程才会失败。只有以下子集的接口会出现内存外错误。</target>
        </trans-unit>
        <trans-unit id="bc7938d9d029402b8371ec96dc41a03cdd95d8f8" translate="yes" xml:space="preserve">
          <source>As long as the input parameters are correct, these routines will only fail if an out-of-memory error occurs during a format conversion. Only the following subset of interfaces are subject to out-of-memory errors:</source>
          <target state="translated">只要输入参数正确,只有在格式转换过程中发生内存外错误时,这些例程才会失败。只有以下子集的接口会出现内存外错误。</target>
        </trans-unit>
        <trans-unit id="af3758ac84a3f79558343e605f45f43dad96f8ef" translate="yes" xml:space="preserve">
          <source>As new versions of SQLite are released, repeat steps 3.6 and 3.7 to add changes in the new release to the private branch. Additional private changes can be made on the private branch in between releases if desired.</source>
          <target state="translated">当SQLite的新版本发布时,重复步骤3.6和3.7,将新版本中的更改添加到私有分支中。如果需要的话,可以在两个版本之间的私有分支上进行额外的私有化修改。</target>
        </trans-unit>
        <trans-unit id="e442983efbc639e95659cc425a72881ca75f93d3" translate="yes" xml:space="preserve">
          <source>As noted above, there really is no such thing as a &quot;sqlite3_column()&quot; function in the SQLite API. Instead, what we here call &quot;sqlite3_column()&quot; is a place-holder for an entire family of functions that return a value from the result set in various data types. There are also routines in this family that return the size of the result (if it is a string or BLOB) and the number of columns in the result set.</source>
          <target state="translated">如上所述,在SQLite API中确实没有 &quot;sqlite3_column()&quot;函数这样的东西。相反,我们在这里所说的 &quot;sqlite3_column()&quot;是整个函数系列的占位符,这些函数从结果集中以各种数据类型返回一个值。在这个系列中,还有一些例程返回结果的大小(如果是字符串或BLOB)和结果集中的列数。</target>
        </trans-unit>
        <trans-unit id="f7f8a41bee17850d3fdbafd1837635d4f3b48596" translate="yes" xml:space="preserve">
          <source>As of 2017-03-12, you must use Fossil version 2.0 or later for the following instructions to work. The SQLite repository started using artifacts named using SHA3 hashes instead of SHA1 hashes on that date, and Fossil 2.0 or later is needed in order to understand the new SHA3 hashes. To find out what version of Fossil you are running, type &quot;fossil -v&quot;.</source>
          <target state="translated">自2017-03-12起,你必须使用Fossil 2.0或更高版本才能使用以下说明。SQLite仓库在该日开始使用使用SHA3哈希值而不是SHA1哈希值命名的工件,为了理解新的SHA3哈希值,需要使用Fossil 2.0或更高版本。要了解你正在运行的 Fossil 版本,请输入 &quot;fossil -v&quot;。</target>
        </trans-unit>
        <trans-unit id="46e28b72fbe9e739630682b02359c85a23e23fe2" translate="yes" xml:space="preserve">
          <source>As of 2018-05-19, the TH3 source tree consists and well over 500,000 lines of source code in 1709 separate files.</source>
          <target state="translated">截至2018-05-19,TH3源码树由和远远超过50万行的源码组成,分属1709个独立文件。</target>
        </trans-unit>
        <trans-unit id="32045934e18d7d7235684ae81bb4ad3e112f0c5b" translate="yes" xml:space="preserve">
          <source>As of 2019-03-20, there is now an &lt;a href=&quot;https://github.com/sqlite/sqlite&quot;&gt;official Git mirror&lt;/a&gt; of the SQLite sources on GitHub.</source>
          <target state="translated">截至2019年3月20日，GitHub上现已有一个&lt;a href=&quot;https://github.com/sqlite/sqlite&quot;&gt;正式的Git&lt;/a&gt; SQLite 镜像镜像。</target>
        </trans-unit>
        <trans-unit id="3e28505b65fc1d015c678e6ae0f3c3ddff268608" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;version 3.29.0&lt;/a&gt; (2019-07-10), the SQLite library consists of approximately 138.9 KSLOC of C code. (KSLOC means thousands of &quot;Source Lines Of Code&quot; or, in other words, lines of code excluding blank lines and comments.) By comparison, the project has 662 times as much test code and test scripts - 91946.2 KSLOC.</source>
          <target state="translated">从&lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;3.29.0版&lt;/a&gt;（2019-07-10）开始，SQLite库包含大约138.9 KSLOC的C代码。（KSLOC表示成千上万的&amp;ldquo;源代码行&amp;rdquo;，或换句话说，不含空行和注释的代码行。）相比之下，该项目的测试代码和测试脚本的数量是662倍-91946.2 KSLOC。</target>
        </trans-unit>
        <trans-unit id="2f1c2b6d73cf26867292aed34f667ddc2bada8a1" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_33_0.html&quot;&gt;version 3.33.0&lt;/a&gt; (2020-08-14), the SQLite library consists of approximately 143.4 KSLOC of C code. (KSLOC means thousands of &quot;Source Lines Of Code&quot; or, in other words, lines of code excluding blank lines and comments.) By comparison, the project has 640 times as much test code and test scripts - 91911.0 KSLOC.</source>
          <target state="translated">从&lt;a href=&quot;https://sqlite.org/releaselog/3_33_0.html&quot;&gt;版本3.33.0&lt;/a&gt;（2020-08-14）开始，SQLite库包含大约143.4 KSLOC的C代码。（KSLOC表示成千上万的&amp;ldquo;源代码行&amp;rdquo;，或者换句话说，不含空行和注释的代码行。）相比之下，该项目的测试代码和测试脚本的数量是640倍-91911.0 KSLOC。</target>
        </trans-unit>
        <trans-unit id="a53c8d218bf20b0261060ea362ee56f13c07c935" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt; (2009-10-14), SQLite supports &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt;. But enforcement of foreign key constraints is turned off by default (for backwards compatibility). To enable foreign key constraint enforcement, run &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=ON&lt;/a&gt; or compile with &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;-DSQLITE_DEFAULT_FOREIGN_KEYS=1&lt;/a&gt;.</source>
          <target state="translated">从&lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;3.6.19&lt;/a&gt;（2009-10-14）版本开始，SQLite支持&lt;a href=&quot;foreignkeys&quot;&gt;外键约束&lt;/a&gt;。但是默认情况下，外键约束的执行处于关闭状态（以实现向后兼容）。要启用外键约束实施，请运行&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys = ON&lt;/a&gt;或使用&lt;a href=&quot;compile#default_foreign_keys&quot;&gt;-DSQLITE_DEFAULT_FOREIGN_KEYS = 1进行&lt;/a&gt;编译。</target>
        </trans-unit>
        <trans-unit id="836b2728d9d516fbe942ba314e801009ae9980b0" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;version 3.7.6&lt;/a&gt; (2011-04-12), SQLite includes a new virtual table module called &quot;fts4aux&quot;, which can be used to inspect the full-text index of an existing FTS table directly. Despite its name, fts4aux works just as well with FTS3 tables as it does with FTS4 tables. Fts4aux tables are read-only. The only way to modify the contents of an fts4aux table is by modifying the contents of the associated FTS table. The fts4aux module is automatically included in all &lt;a href=&quot;fts3#compiling_and_enabling_fts3_and_fts4&quot;&gt;builds that include FTS&lt;/a&gt;.</source>
          <target state="translated">从&lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;版本3.7.6&lt;/a&gt;（2011-04-12）开始，SQLite包括一个名为&amp;ldquo; fts4aux&amp;rdquo;的新虚拟表模块，该模块可用于直接检查现有FTS表的全文索引。尽管名称如此，fts4aux在FTS3表上的工作效果与在FTS4表上一样好。 Fts4aux表是只读的。修改fts4aux表内容的唯一方法是修改关联的FTS表的内容。 fts4aux模块自动包含在所有&lt;a href=&quot;fts3#compiling_and_enabling_fts3_and_fts4&quot;&gt;包含FTS的构建中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d225f240bc36e795cb50632150d857ce4c4d78e" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), FTS5 is included as part of the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. If using one of the two autoconf build system, FTS5 is enabled by specifying the &quot;--enable-fts5&quot; option when running the configure script. (FTS5 is currently disabled by default for the source-tree configure script and enabled by default for the amalgamation configure script, but these defaults might change in the future.)</source>
          <target state="translated">从&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;3.9.0版&lt;/a&gt;（2015-10-14）开始，FTite5作为SQLite&lt;a href=&quot;amalgamation&quot;&gt;合并的&lt;/a&gt;一部分包含在内。如果使用两个autoconf构建系统之一，则在运行configure脚本时通过指定&amp;ldquo; --enable-fts5&amp;rdquo;选项来启用FTS5。（对于源树配置脚本，当前默认情况下禁用FTS5，对于合并配置脚本，默认情况下启用FTS5，但这些默认值将来可能会更改。）</target>
        </trans-unit>
        <trans-unit id="03eb89fc06866a1260f6276654306363ba727d94" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), FTS5 is included as part of the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. It is disabled by default. If using the two autoconf build system, it is enabled by specifying the &quot;--enable-fts5&quot; option when running the configure script.</source>
          <target state="translated">从&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;3.9.0版&lt;/a&gt;（2015-10-14）开始，FTite5作为SQLite &lt;a href=&quot;amalgamation&quot;&gt;合并的&lt;/a&gt;一部分包含在内。默认情况下禁用。如果使用两个autoconf构建系统，则在运行configure脚本时通过指定&amp;ldquo; --enable-fts5&amp;rdquo;选项来启用它。</target>
        </trans-unit>
        <trans-unit id="0cba18acfc338d803dd183b86646f960bc3ebd65" translate="yes" xml:space="preserve">
          <source>As of SQLite 3.16.0 (2017-01-02), the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; contains a dot-command &quot;.imposter&quot; that does all of the work of setting up a transient imposter table. Instead of making multiple calls to sqlite3_test_control() and figuring out and invoking a compatible CREATE TABLE statement, a transient imposter table can be constructed as follows:</source>
          <target state="translated">从SQLite 3.16.0（2017-01-02）开始，&lt;a href=&quot;cli&quot;&gt;命令行外壳&lt;/a&gt;包含点命令&amp;ldquo; .imposter&amp;rdquo;，该命令完成设置临时冒名顶替者表的所有工作。可以如下构造临时冒名顶替者表，而不是多次调用sqlite3_test_control（）并弄清楚并调用兼容的CREATE TABLE语句：</target>
        </trans-unit>
        <trans-unit id="98a2e1c87379924c2c171b5738373e64a2f944b7" translate="yes" xml:space="preserve">
          <source>As of SQLite 3.27.0 (2019-02-07) the use of a double-quoted string literal causes a warning message to be sent to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt;.</source>
          <target state="translated">从SQLite 3.27.0（2019-02-07）开始，使用双引号字符串文字会导致将警告消息发送到&lt;a href=&quot;errlog&quot;&gt;错误日志&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="477279c68e157e3c69007f56a275a12b81ee766f" translate="yes" xml:space="preserve">
          <source>As of SQLite 3.29.0 (2019-07-10) the use of double-quoted string literals can be disabled at run-time using the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsddl&quot;&gt;SQLITE_DBCONFIG_DQS_DDL&lt;/a&gt; and &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsdml&quot;&gt;SQLITE_DBCONFIG_DQS_DML&lt;/a&gt; actions to &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt;. The default settings can be altered at compile-time using the &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS=&lt;i&gt;N&lt;/i&gt;&lt;/a&gt; compile-time option. Application developers are encouraged to compile using -DSQLITE_DQS=0 in order to disable the double-quoted string literal misfeature by default. If that is not possible, then disable double-quoted string literals for individual database connections using C-code like this:</source>
          <target state="translated">从SQLite 3.29.0（2019-07-10）开始，可以在运行时使用对&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;的&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsddl&quot;&gt;SQLITE_DBCONFIG_DQS_DDL&lt;/a&gt;和&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsdml&quot;&gt;SQLITE_DBCONFIG_DQS_DML&lt;/a&gt;操作禁用双引号字符串文字。可以使用&lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS = &lt;/a&gt;&lt;i&gt;N&lt;/i&gt;编译时选项在编译时更改默认设置。鼓励应用程序开发人员使用-DSQLITE_DQS = 0进行编译，以默认情况下禁用双引号字符串文字错误功能。如果这不可能，则使用如下C代码为单个数据库连接禁用双引号字符串文字：&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="27ccd6edc0578e2c50724724d1f7e72fc2202881" translate="yes" xml:space="preserve">
          <source>As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;version 3.11.0&lt;/a&gt; (2016-02-15), the WAL file for a single transaction should be proportional in size to the transaction itself. Pages that are changed by the transaction should only be written into the WAL file once. However, with older versions of SQLite, the same page might be written into the WAL file multiple times if the transaction grows larger than the page cache.</source>
          <target state="translated">从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;版本3.11.0&lt;/a&gt;（2016-02-15）开始，单个事务的WAL文件的大小应与事务本身成比例。事务更改的页面仅应写入WAL文件一次。但是，对于旧版本的SQLite，如果事务增长到大于页面缓存，则同一页面可能多次写入WAL文件。</target>
        </trans-unit>
        <trans-unit id="9002d4afcf5621573059e14d645945f49cc82521" translate="yes" xml:space="preserve">
          <source>As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_1.html&quot;&gt;version 3.6.1&lt;/a&gt; (2008-08-06), the soft heap limit only applies to the general-purpose memory allocator. The soft heap limit does not know about or interact with the &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt; or the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt;. This deficiency will likely be addressed in a future release.</source>
          <target state="translated">从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_1.html&quot;&gt;版本3.6.1&lt;/a&gt;（2008-08-06）开始，软堆限制仅适用于通用内存分配器。软堆限制不了解页面&lt;a href=&quot;malloc#pagecache&quot;&gt;缓存内存分配器&lt;/a&gt;或&lt;a href=&quot;malloc#lookaside&quot;&gt;后备内存分配器&lt;/a&gt;或与之交互。在将来的发行版中可能会解决此缺陷。</target>
        </trans-unit>
        <trans-unit id="b175c36534eb0163084a39638e664737aba3d613" translate="yes" xml:space="preserve">
          <source>As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt;, the default setting for foreign key enforcement is OFF. However, that might change in a future release of SQLite. The default setting for foreign key enforcement can be specified at compile-time using the &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;SQLITE_DEFAULT_FOREIGN_KEYS&lt;/a&gt; preprocessor macro. To minimize future problems, applications should set the foreign key enforcement flag as required by the application and not depend on the default setting.</source>
          <target state="translated">从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;3.6.19版本开始&lt;/a&gt;，外键强制的默认设置为OFF。但是，这可能会在将来的SQLite版本中发生变化。可以在编译时使用&lt;a href=&quot;compile#default_foreign_keys&quot;&gt;SQLITE_DEFAULT_FOREIGN_KEYS&lt;/a&gt;预处理程序宏指定外键强制的默认设置。为了最大程度地减少将来的问题，应用程序应根据应用程序的要求设置外键强制标志，而不应依赖于默认设置。</target>
        </trans-unit>
        <trans-unit id="0e6461cc943c138056429ef3ecea61d0043a0402" translate="yes" xml:space="preserve">
          <source>As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), the &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt; utility is able to generate RBU databases representing the difference between two databases with identical schemas. For example, the following command:</source>
          <target state="translated">从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;版本3.9.0&lt;/a&gt;（2015-10-14）开始，&lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt;实用程序能够生成RBU数据库，该数据库表示具有相同架构的两个数据库之间的差异。例如，以下命令：</target>
        </trans-unit>
        <trans-unit id="dfbf6fd8aef52e316e037404ed7145e5b99ccf6d" translate="yes" xml:space="preserve">
          <source>As of SQLite version 3.21.0 (2017-10-24), the query planner will always prefer to use a co-routine to implement FROM-clause subqueries that contains an ORDER BY clause and that are not part of a join when the result set of the outer query is &quot;complex&quot;. This feature allows applications to shift expensive computations from before the sorter until after the sorter, which can result in faster operation. For example, consider this query:</source>
          <target state="translated">从SQLite 3.21.0版本(2017-10-24)开始,当外层查询的结果集是 &quot;复杂 &quot;的时候,查询规划器总是会优先使用一个协同程序来实现包含ORDER BY子句的FROM-clause子查询,并且这些子查询不属于连接。这个特性允许应用程序将昂贵的计算从分词器之前转移到分词器之后,这样可以提高操作速度。例如,考虑这个查询。</target>
        </trans-unit>
        <trans-unit id="242b46186535aea87c089fafc2bda700b6f5e078" translate="yes" xml:space="preserve">
          <source>As of SQLite version 3.22.0, the &quot;sqlite_stat1&quot; table is an exception to some of the rules above. In SQLite, the schema of sqlite_stat1 is:</source>
          <target state="translated">从SQLite 3.22.0版本开始,&quot;sqlite_stat1 &quot;表是上述一些规则的例外。在SQLite中,sqlite_stat1的模式是。</target>
        </trans-unit>
        <trans-unit id="5ddb98490083a7f2dc1ca2a3b26fa7d781b747ca" translate="yes" xml:space="preserve">
          <source>As of this writing (2017-07-13), the completion virtual table only looks for SQL keywords, and schema, table, and column names. The context contained in $wholeline is completely ignored. Future enhancements will try to return new completions taken from function and pragma names and other sources, as well as consider more context. The completion table should be considered a work-in-progress.</source>
          <target state="translated">截至目前(2017-07-13),完成虚拟表只查找SQL关键字,以及模式、表和列名。$wholeline中包含的上下文被完全忽略。未来的增强将尝试返回从函数和pragma名称和其他来源获取的新完备,以及考虑更多的上下文。完成表应该被认为是一个正在进行中的工作。</target>
        </trans-unit>
        <trans-unit id="b289cb5373e1ff5a5a0c905eb902dc91bdb7b556" translate="yes" xml:space="preserve">
          <source>As of this writing (2018-05-29) the only other recommended storage formats for datasets are XML, JSON, and CSV.</source>
          <target state="translated">截至本文撰写之时(2018-05-29),其他推荐的数据集存储格式只有XML、JSON和CSV。</target>
        </trans-unit>
        <trans-unit id="f2ad4e776d39a3ec2c252f71f4dae40cd1708a1c" translate="yes" xml:space="preserve">
          <source>As of this writing (2019-07-16), the SQLite developers have stopped using AFL for routine testing and instead are focused on running dbsqlfuzz. At least one instance of dbsqlfuzz is running on the latest SQLite source code at all times, in order to catch any new problems that might be introduced into the source tree as features are added and routine maintenance is performed.</source>
          <target state="translated">截至本文撰写之时(2019-07-16),SQLite开发人员已经停止使用AFL进行常规测试,而是专注于运行dbsqlfuzz。至少有一个dbsqlfuzz实例始终运行在最新的SQLite源代码上,以便在添加功能和进行日常维护时,捕捉到任何可能引入源代码树的新问题。</target>
        </trans-unit>
        <trans-unit id="c36686a25a23f2cfaee766f9bfb5607ad00a8413" translate="yes" xml:space="preserve">
          <source>As one might expect, the amount of data read from the database file is minimized by caching portions of the database file in main memory. Additionally, multiple updates to the database file that are part of the same</source>
          <target state="translated">正如人们所期望的那样,通过在主内存中缓存数据库文件的一部分,从数据库文件中读取的数据量被最小化。此外,对数据库文件的多次更新是同一个数据库文件的一部分。</target>
        </trans-unit>
        <trans-unit id="972efc3fd6678a6e105ba1a8f1aac17c41abd523" translate="yes" xml:space="preserve">
          <source>As part of opening a new</source>
          <target state="translated">作为开设一个新的</target>
        </trans-unit>
        <trans-unit id="9b40d60a44eca2b862c669b4ece8404effe70c95" translate="yes" xml:space="preserve">
          <source>As part of the query planning process, SQLite enumerates all usable combinations of indexes and WHERE-clause constraints. For certain pathological queries, the number of these index-and-constraint combinations can be very large, resulting in slow performance by the query planner. The SQLITE_QUERY_PLANNER_LIMIT value (in conjunction with the related &lt;a href=&quot;compile#query_planner_limit_incr&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT_INCR&lt;/a&gt; setting) limits the number of index-and-constraint combinations that the query planner will consider, in order to prevent the query planner from using excess CPU time. The default value for SQLITE_QUERY_PLANNER_LIMIT is set high enough so that is never reached for real-world queries. The query planner search limit only applies to queries that are deliberately crafted to use excess planning time.</source>
          <target state="translated">作为查询计划过程的一部分，SQLite枚举索引和WHERE子句约束的所有可用组合。对于某些病理查询，这些索引和约束组合的数量可能非常大，从而导致查询计划程序的性能降低。 SQLITE_QUERY_PLANNER_LIMIT值（与相关的&lt;a href=&quot;compile#query_planner_limit_incr&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT_INCR&lt;/a&gt;设置结合使用）限制了查询计划程序将考虑的索引和约束组合的数量，以防止查询计划程序使用过多的CPU时间。 SQLITE_QUERY_PLANNER_LIMIT的默认值设置得足够高，以至于现实世界中的查询永远无法达到。查询计划者搜索限制仅适用于故意使用多余计划时间的查询。</target>
        </trans-unit>
        <trans-unit id="69ee480d16c703172bf696c37d4bed26f84974f4" translate="yes" xml:space="preserve">
          <source>As part of the task of creating a new &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure, this method &lt;u&gt;must&lt;/u&gt; invoke &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; to tell the SQLite core about the columns and datatypes in the virtual table. The &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; API has the following prototype:</source>
          <target state="translated">作为创建新的&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;结构的任务的一部分，此方法&lt;u&gt;必须&lt;/u&gt;调用&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt;来告知SQLite核心虚拟表中的列和数据类型。该&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt; API的原型如下：</target>
        </trans-unit>
        <trans-unit id="c00876adc6de8fc473fb32b80195d17d4fda9f03" translate="yes" xml:space="preserve">
          <source>As pointed out in the previous paragraph, SQLite takes steps to work around the quirks of POSIX advisory locking. Part of that work-around involves keeping a global list (mutex protected) of open SQLite database files. But, if multiple copies of SQLite are linked into the same application, then there will be multiple instances of this global list. Database connections opened using one copy of the SQLite library will be unaware of database connections opened using the other copy, and will be unable to work around the POSIX advisory locking quirks. A &lt;code&gt;close()&lt;/code&gt; operation on one connection might unknowingly clear the locks on a different database connection, leading to database corruption.</source>
          <target state="translated">如前一段所述，SQLite采取了一些步骤来解决POSIX咨询锁定的怪癖。解决方法的一部分涉及保持打开的SQLite数据库文件的全局列表（互斥量受保护）。但是，如果将SQLite的多个副本链接到同一应用程序中，则此全局列表将有多个实例。使用SQLite库的一个副本打开的数据库连接将不知道使用另一副本打开的数据库连接，并且将无法解决POSIX咨询锁定怪癖。一个 &lt;code&gt;close()&lt;/code&gt; 方法的一个连接操作可能在不知不觉中清除不同的数据库连接上的锁，导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="d6d67b507fa18e45da7b000070cada26cbc7cde7" translate="yes" xml:space="preserve">
          <source>As recently as version 2.7.0, SQLite ran at about the same speed as MySQL on this test. But recent optimizations to SQLite have more than doubled speed of UPDATEs.</source>
          <target state="translated">最近的2.7.0版本,SQLite在这次测试中的运行速度和MySQL差不多。但最近对SQLite的优化使UPDATEs的速度提高了一倍多。</target>
        </trans-unit>
        <trans-unit id="9a13d6d8189152816b2ae81d060e78c812a6905c" translate="yes" xml:space="preserve">
          <source>As soon as the PENDING lock is released from the database file, other processes can begin reading the database again. In the current implementation, the RESERVED lock is also released, but that is not essential for correct operation.</source>
          <target state="translated">一旦数据库文件中的PENDING锁被释放,其他进程就可以再次开始读取数据库。在当前的实现中,reserved锁也会被释放,但这并不是正确操作的必要条件。</target>
        </trans-unit>
        <trans-unit id="555c3a9cda5a4b25e0cdbc43fe5e7c8c0b690222" translate="yes" xml:space="preserve">
          <source>As the last step in opening a</source>
          <target state="translated">作为开店的最后一步</target>
        </trans-unit>
        <trans-unit id="de5e740293d719649dc267008b44fcf5aaa20455" translate="yes" xml:space="preserve">
          <source>As we enter the interior of the second loop (at instruction 17) the stack contains a single integer which is the key of the record we want to modify. We are going to need to use this key twice: once to fetch the old value of the record and a second time to write back the revised record. So the first instruction is a Dup to make a duplicate of the key on the top of the stack. The Dup instruction will duplicate any element of the stack, not just the top element. You specify which element to duplication using the P1 operand. When P1 is 0, the top of the stack is duplicated. When P1 is 1, the next element down on the stack duplication. And so forth.</source>
          <target state="translated">当我们进入第二个循环的内部时(在指令17),堆栈中包含了一个单一的整数,这就是我们要修改的记录的键。我们需要使用这个键两次:一次是获取记录的旧值,第二次是写回修改后的记录。所以第一条指令是Dup,对栈顶的键进行复制。Dup指令将复制堆栈中的任何元素,而不仅仅是顶部元素。你可以用P1操作数指定要复制的元素。当P1为0时,复制堆栈顶部的元素。当P1为1时,复制堆栈下一个元素。以此类推。</target>
        </trans-unit>
        <trans-unit id="cf4c617d0371eb7d2e50bdeaba7f0656cfa12c47" translate="yes" xml:space="preserve">
          <source>As well as a list of columns, the module arguments passed to a CREATE VIRTUAL TABLE statement used to create an FTS table may be used to specify a &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt;. This is done by specifying a string of the form &quot;tokenize=&amp;lt;tokenizer name&amp;gt; &amp;lt;tokenizer args&amp;gt;&quot; in place of a column name, where &amp;lt;tokenizer name&amp;gt; is the name of the tokenizer to use and &amp;lt;tokenizer args&amp;gt; is an optional list of whitespace separated qualifiers to pass to the tokenizer implementation. A tokenizer specification may be placed anywhere in the column list, but at most one tokenizer declaration is allowed for each CREATE VIRTUAL TABLE statement. &lt;a href=&quot;fts3#tokenizer&quot;&gt;See below&lt;/a&gt; for a detailed description of using (and, if necessary, implementing) a tokenizer.</source>
          <target state="translated">除了列的列表之外，传递给用于创建FTS表的CREATE VIRTUAL TABLE语句的模块参数也可以用于指定&lt;a href=&quot;fts3#tokenizer&quot;&gt;标记器&lt;/a&gt;。通过指定形式为&amp;ldquo; tokenize = &amp;lt;tokenizer名称&amp;gt; &amp;lt;tokenizer args&amp;gt;&amp;rdquo;的字符串来代替列名，其中&amp;lt;tokenizer name&amp;gt;是要使用的令牌生成器的名称，而&amp;lt;tokenizer args&amp;gt;是可选的空格分隔的限定符列表，以传递给令牌生成器实现。标记符规范可以放在列列表中的任何位置，但是每个CREATE VIRTUAL TABLE语句最多允许一个标记符声明。&lt;a href=&quot;fts3#tokenizer&quot;&gt;有关&lt;/a&gt;使用（以及在必要时实施）标记器的详细说明，请参见下文。</target>
        </trans-unit>
        <trans-unit id="aba6435071ee404f8eb600e0af17ad3d0179b00e" translate="yes" xml:space="preserve">
          <source>As well as aggregate window functions, SQLite features a set of built-in window functions based on &lt;a href=&quot;https://www.postgresql.org/docs/10/static/functions-window.html&quot;&gt; those supported by PostgreSQL&lt;/a&gt;.</source>
          <target state="translated">除了聚合窗口函数外，SQLite还具有一组基于&lt;a href=&quot;https://www.postgresql.org/docs/10/static/functions-window.html&quot;&gt;PostgreSQL支持&lt;/a&gt;的内置窗口函数。</target>
        </trans-unit>
        <trans-unit id="4c2adc03d8772b0c49ef19569e284dd9591a16b0" translate="yes" xml:space="preserve">
          <source>As well as being set automatically as rows are inserted into database tables, the value returned by this function may be set explicitly by &lt;a href=&quot;#sqlite3_set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid()&lt;/a&gt;</source>
          <target state="translated">除了在将行插入数据库表中时自动设置之外，此函数返回的值可以由&lt;a href=&quot;#sqlite3_set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid（）&lt;/a&gt;显式设置。</target>
        </trans-unit>
        <trans-unit id="6da8075b78c1059d6422bee1d474218e1b6600d9" translate="yes" xml:space="preserve">
          <source>As well as being set automatically as rows are inserted into database tables, the value returned by this function may be set explicitly by &lt;a href=&quot;set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid()&lt;/a&gt;</source>
          <target state="translated">除了在将行插入数据库表中时自动设置之外，此函数返回的值可以由&lt;a href=&quot;set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid（）&lt;/a&gt;显式设置。</target>
        </trans-unit>
        <trans-unit id="0a715526e2153a56ee0a3cbcb2c8454333e9e1d8" translate="yes" xml:space="preserve">
          <source>As well as searching for all rows that contain a term, FTS5 allows the user to search for rows that contain:</source>
          <target state="translated">除了搜索包含一个术语的所有行外,FTS5还允许用户搜索包含以下内容的行:</target>
        </trans-unit>
        <trans-unit id="19f6e18c709ce14d58e4401d523e835813272b3a" translate="yes" xml:space="preserve">
          <source>As well as the &quot;simple&quot; tokenizer, the FTS source code features a tokenizer that uses the &lt;a href=&quot;http://tartarus.org/~martin/PorterStemmer/&quot;&gt;Porter Stemming algorithm&lt;/a&gt;. This tokenizer uses the same rules to separate the input document into terms including folding all terms into lower case, but also uses the Porter Stemming algorithm to reduce related English language words to a common root. For example, using the same input document as in the paragraph above, the porter tokenizer extracts the following tokens: &quot;right now thei veri frustrat&quot;. Even though some of these terms are not even English words, in some cases using them to build the full-text index is more useful than the more intelligible output produced by the simple tokenizer. Using the porter tokenizer, the document not only matches full-text queries such as &quot;MATCH 'Frustrated'&quot;, but also queries such as &quot;MATCH 'Frustration'&quot;, as the term &quot;Frustration&quot; is reduced by the Porter stemmer algorithm to &quot;frustrat&quot; - just as &quot;Frustrated&quot; is. So, when using the porter tokenizer, FTS is able to find not just exact matches for queried terms, but matches against similar English language terms. For more information on the Porter Stemmer algorithm, please refer to the page linked above.</source>
          <target state="translated">与&amp;ldquo;简单&amp;rdquo;标记器一样，FTS源代码还具有使用&lt;a href=&quot;http://tartarus.org/~martin/PorterStemmer/&quot;&gt;Porter Stemming算法&lt;/a&gt;的标记器。。该标记器使用相同的规则将输入文档分为多个术语，包括将所有术语折叠成小写，还使用Porter Stemming算法将相关的英语单词还原为一个通用词根。例如，使用与上段相同的输入文档，搬运程序令牌生成器将提取以下令牌：&amp;ldquo;现在，正确地挫败&amp;rdquo;。尽管这些术语中的某些甚至不是英语单词，但在某些情况下，使用它们来构建全文本索引比简单令牌生成器产生的更清晰的输出更有用。使用搬运程序令牌生成器，文档不仅匹配诸如&amp;ldquo; MATCH'Frustrated'&amp;rdquo;之类的全文查询，还匹配诸如&amp;ldquo; MATCH'Frustration'&amp;rdquo;之类的查询，称为术语&amp;ldquo; Frustration&amp;rdquo;由Porter stemmer算法将其减少为&amp;ldquo;受挫&amp;rdquo;-就像&amp;ldquo;受挫&amp;rdquo;一样。因此，当使用搬运程序令牌生成器时，FTS不仅可以找到查询词的完全匹配项，还可以找到与类似英语术语的匹配项。有关Porter Stemmer算法的更多信息，请参考上面链接的页面。</target>
        </trans-unit>
        <trans-unit id="1a61789aa5d130557923a501fdafd5067a0e8e78" translate="yes" xml:space="preserve">
          <source>As well as the &quot;simple&quot; tokenizer, the FTS source code features a tokenizer that uses the &lt;a href=&quot;https://tartarus.org/~martin/PorterStemmer/&quot;&gt;Porter Stemming algorithm&lt;/a&gt;. This tokenizer uses the same rules to separate the input document into terms including folding all terms into lower case, but also uses the Porter Stemming algorithm to reduce related English language words to a common root. For example, using the same input document as in the paragraph above, the porter tokenizer extracts the following tokens: &quot;right now thei veri frustrat&quot;. Even though some of these terms are not even English words, in some cases using them to build the full-text index is more useful than the more intelligible output produced by the simple tokenizer. Using the porter tokenizer, the document not only matches full-text queries such as &quot;MATCH 'Frustrated'&quot;, but also queries such as &quot;MATCH 'Frustration'&quot;, as the term &quot;Frustration&quot; is reduced by the Porter stemmer algorithm to &quot;frustrat&quot; - just as &quot;Frustrated&quot; is. So, when using the porter tokenizer, FTS is able to find not just exact matches for queried terms, but matches against similar English language terms. For more information on the Porter Stemmer algorithm, please refer to the page linked above.</source>
          <target state="translated">与&amp;ldquo;简单&amp;rdquo;标记器一样，FTS源代码还具有使用&lt;a href=&quot;https://tartarus.org/~martin/PorterStemmer/&quot;&gt;Porter Stemming算法&lt;/a&gt;的标记器。。该标记器使用相同的规则将输入文档分为多个术语，包括将所有术语折叠成小写，还使用Porter Stemming算法将相关的英语单词还原为一个通用词根。例如，使用与上段相同的输入文档，搬运程序令牌生成器将提取以下令牌：&amp;ldquo;现在，正确地挫败&amp;rdquo;。即使这些术语中的某些甚至不是英语单词，在某些情况下，使用它们来构建全文本索引也比简单令牌生成器产生的更清晰的输出更有用。使用搬运程序令牌生成器，文档不仅匹配诸如&amp;ldquo; MATCH'Frustrated'&amp;rdquo;之类的全文查询，还匹配诸如&amp;ldquo; MATCH'Frustration'&amp;rdquo;之类的查询，称为术语&amp;ldquo; Frustration&amp;rdquo;通过Porter stemmer算法将其减少为&amp;ldquo;受挫&amp;rdquo;-就像&amp;ldquo;受挫&amp;rdquo;一样。因此，在使用搬运程序令牌生成器时，FTS不仅可以找到查询词的完全匹配项，而且还可以找到与类似英语术语的匹配项。有关Porter Stemmer算法的更多信息，请参考上面链接的页面。</target>
        </trans-unit>
        <trans-unit id="03b7b3d7c7af14aee8c40f5a5eff47a557f13b7f" translate="yes" xml:space="preserve">
          <source>As well as the column values and rowid of a matching row, an application may use &lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;FTS5 auxiliary functions&lt;/a&gt; to retrieve extra information regarding the matched row. For example, an auxiliary function may be used to retrieve a copy of a column value for a matched row with all instances of the matched term surrounded by html &amp;lt;b&amp;gt;&amp;lt;/b&amp;gt; tags. Auxiliary functions are invoked in the same way as SQLite &lt;a href=&quot;lang_corefunc&quot;&gt;scalar functions&lt;/a&gt;, except that the name of the FTS5 table is specified as the first argument. For example:</source>
          <target state="translated">除了匹配行的列值和rowid，应用程序还可以使用&lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;FTS5辅助功能&lt;/a&gt;来检索有关匹配行的额外信息。例如，辅助功能可用于检索匹配行的列值的副本，其中匹配项的所有实例都被html &amp;lt;b&amp;gt; &amp;lt;/ b&amp;gt;标记包围。辅助函数的调用方式与SQLite &lt;a href=&quot;lang_corefunc&quot;&gt;标量函数&lt;/a&gt;相同，只是将FTS5表的名称指定为第一个参数。例如：</target>
        </trans-unit>
        <trans-unit id="5f0b425505ed4df313764b933ddda058638fd396" translate="yes" xml:space="preserve">
          <source>As well as the columns named by the user (or the &quot;content&quot; column if no module arguments were specified as part of the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement), each FTS table has a &quot;rowid&quot; column. The rowid of an FTS table behaves in the same way as the rowid column of an ordinary SQLite table, except that the values stored in the rowid column of an FTS table remain unchanged if the database is rebuilt using the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. For FTS tables, &quot;docid&quot; is allowed as an alias along with the usual &quot;rowid&quot;, &quot;oid&quot; and &quot;_oid_&quot; identifiers. Attempting to insert or update a row with a docid value that already exists in the table is an error, just as it would be with an ordinary SQLite table.</source>
          <target state="translated">除了用户命名的列（如果未在&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;语句的一部分中指定模块参数的情况下，也为&amp;ldquo;内容&amp;rdquo;列），每个FTS表都具有&amp;ldquo; rowid&amp;rdquo;列。 FTS表的rowid的行为与普通SQLite表的rowid列相同，不同之处在于，如果使用&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令重建数据库，则FTS表的rowid列中存储的值保持不变。对于FTS表，允许使用&amp;ldquo; docid&amp;rdquo;作为别名以及通常的&amp;ldquo; rowid&amp;rdquo;，&amp;ldquo; oid&amp;rdquo;和&amp;ldquo; _oid_&amp;rdquo;标识符。尝试使用表中已经存在的docid值插入或更新行是错误的，就像普通的SQLite表一样。</target>
        </trans-unit>
        <trans-unit id="8231b142308216452ffa1a9e5faf9c8e3f6c4c97" translate="yes" xml:space="preserve">
          <source>As well as the command option, each invocation of &quot;.ar&quot; may specify one or more modifier options. Some modifier options require an argument, some do not. The following modifier options are available:</source>
          <target state="translated">除了命令选项外,每次调用&quot;.ar &quot;都可以指定一个或多个修饰选项。有些修饰选项需要一个参数,有些则不需要。以下是可用的修饰符选项。</target>
        </trans-unit>
        <trans-unit id="11a7e6bcced1d592a4403e3d9c67fd5b0f5481cf" translate="yes" xml:space="preserve">
          <source>As well as the regular sqlite3changegroup_add() and sqlite3changegroup_output() functions, also available are the streaming versions sqlite3changegroup_add_strm() and sqlite3changegroup_output_strm().</source>
          <target state="translated">除了常规的sqlite3changegroup_add()和sqlite3changegroup_output()函数外,还有流式版本的sqlite3changegroup_add_strm()和sqlite3changegroup_output_strm()。</target>
        </trans-unit>
        <trans-unit id="c79aa6a7ac9fe81930f35128aa127b04b14a76a2" translate="yes" xml:space="preserve">
          <source>As with &quot;.tables&quot;, the &quot;.schema&quot; command shows the schema for all &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases. If you only want to see the schema for a single database (perhaps &quot;main&quot;) then you can add an argument to &quot;.schema&quot; to restrict its output:</source>
          <target state="translated">与&amp;ldquo; .tables&amp;rdquo;一样，&amp;ldquo;。schema&amp;rdquo;命令显示所有&lt;a href=&quot;lang_attach&quot;&gt;附加&lt;/a&gt;数据库的模式。如果只想查看单个数据库的架构（也许是&amp;ldquo; main&amp;rdquo;），则可以在&amp;ldquo; .schema&amp;rdquo;中添加参数以限制其输出：</target>
        </trans-unit>
        <trans-unit id="ea1906458c679a89c4cf89131d2ffd0b8ce0439a" translate="yes" xml:space="preserve">
          <source>As with all SQL syntax, the case of the keywords does not matter. One can write &quot;WITHOUT rowid&quot; or &quot;without rowid&quot; or &quot;WiThOuT rOwId&quot; and it will mean the same thing.</source>
          <target state="translated">和所有的SQL语法一样,关键字的大小写并不重要。我们可以写 &quot;WITHOUT rowid &quot;或 &quot;without rowid &quot;或 &quot;WiThOuT rOwId&quot;,它的意思是一样的。</target>
        </trans-unit>
        <trans-unit id="08e240ecd7ad7f6958c55717608dff9d30301be2" translate="yes" xml:space="preserve">
          <source>As with all other SQLite APIs, those whose names end with &quot;16&quot; return UTF-16 encoded strings and the other functions return UTF-8.</source>
          <target state="translated">与所有其他SQLite API一样,那些名字以 &quot;16 &quot;结尾的函数返回UTF-16编码的字符串,其他函数返回UTF-8。</target>
        </trans-unit>
        <trans-unit id="dad941d012cf3c0fecce4040017740b92b3cab9e" translate="yes" xml:space="preserve">
          <source>As with all virtual table types, it is not possible to create indices or triggers attached to FTS tables. Nor is it possible to use the ALTER TABLE command to add extra columns to FTS tables (although it is possible to use ALTER TABLE to rename an FTS table).</source>
          <target state="translated">与所有的虚拟表类型一样,不可能创建附加在FTS表上的索引或触发器。也不能使用ALTER TABLE命令为FTS表添加额外的列(尽管可以使用ALTER TABLE来重命名FTS表)。</target>
        </trans-unit>
        <trans-unit id="2c9244ac5b5d0550aa0d1fc8ca3aa52ca8dfaf6c" translate="yes" xml:space="preserve">
          <source>As with custom file formats, and unlike pure pile-of-file formats, a wrapped pile-of-files format is not as easy to edit, since usually the entire file must be rewritten in order to change any component part.</source>
          <target state="translated">与自定义文件格式一样,与纯粹的文件堆格式不同,封装的文件堆格式并不容易编辑,因为通常必须重写整个文件才能改变任何组件部分。</target>
        </trans-unit>
        <trans-unit id="236d7f982d31124f4b94b3c6bc8e43ed33b0fc4b" translate="yes" xml:space="preserve">
          <source>As with the output of the sqlite3session_changeset() and sqlite3session_patchset() functions, all changes related to a single table are grouped together in the output of this function. Tables appear in the same order as for the very first changeset added to the changegroup. If the second or subsequent changesets added to the changegroup contain changes for tables that do not appear in the first changeset, they are appended onto the end of the output changeset, again in the order in which they are first encountered.</source>
          <target state="translated">与 sqlite3session_changeset()和 sqlite3session_patchset()函数的输出一样,所有与单个表相关的变化都会在这个函数的输出中被分组。表的出现顺序与第一个添加到变更组的变更集的顺序相同。如果第二个或随后添加到变更组的变更集包含了不在第一个变更集中的表的变更,那么它们会被追加到输出变更集的末尾,同样是按照它们第一次出现的顺序。</target>
        </trans-unit>
        <trans-unit id="38abe488c2a235f79f98488263f0f24db0790ef4" translate="yes" xml:space="preserve">
          <source>As with unix, most of the code for the various Windows VFSes is shared.</source>
          <target state="translated">与unix一样,各种Windows VFSes的大部分代码都是共享的。</target>
        </trans-unit>
        <trans-unit id="ae23c67b5810fa3b2f8c5dc0de91ee63f46fa321" translate="yes" xml:space="preserve">
          <source>As you can see above, our simple insert statement is implemented in 12 instructions. The first 3 and last 2 instructions are a standard prologue and epilogue, so the real work is done in the middle 7 instructions. There are no jumps, so the program executes once through from top to bottom. Let's now look at each instruction in detail.</source>
          <target state="translated">如上图所示,我们的简单插入语句是在12条指令中实现的。前3条和最后2条指令是标准的序幕和尾声,所以真正的工作是在中间的7条指令中完成的。没有跳转,所以程序从上到下执行一次。现在我们来详细看看每条指令。</target>
        </trans-unit>
        <trans-unit id="5e7f8dc6fe3c7e8373b6401e629567228cb8e775" translate="yes" xml:space="preserve">
          <source>As you would expect, it is not possible to manipulate the database to a state that violates the foreign key constraint by deleting or updating rows in the</source>
          <target state="translated">正如你所期望的那样,不可能通过删除或更新外键约束中的行来操作数据库到违反外键约束的状态。</target>
        </trans-unit>
        <trans-unit id="d60ffe4ee5253e97c8077a55a44490538dd90ceb" translate="yes" xml:space="preserve">
          <source>Aside from those read operations described by H35070 and H21XXX, SQLite shall read data from the database file in aligned blocks of</source>
          <target state="translated">除了H35070和H21XXX所描述的那些读取操作外,SQLite应从数据库文件中读取数据,这些数据以对齐的块为单位。</target>
        </trans-unit>
        <trans-unit id="42e2846af72fd7f80a66045f0952619fc82cc85d" translate="yes" xml:space="preserve">
          <source>Assert() macros are disabled by compiling with the NDEBUG macro defined. In most systems, asserts are enabled by default. But in SQLite, the asserts are so numerous and are in such performance critical places, that the database engine runs about three times slower when asserts are enabled. Hence, the default (production) build of SQLite disables asserts. Assert statements are only enabled when SQLite is compiled with the SQLITE_DEBUG preprocessor macro defined.</source>
          <target state="translated">Assert()宏通过编译时定义的NDEBUG宏被禁用。在大多数系统中,断言是默认启用的。但是在SQLite中,断言的数量非常多,而且在性能关键的地方,当断言被启用时,数据库引擎的运行速度要慢三倍。因此,SQLite的默认(生产)构建是禁用断言的。只有当SQLite在编译时定义了SQLITE_DEBUG预处理程序宏时,才会启用断言语句。</target>
        </trans-unit>
        <trans-unit id="c350f30044b71a607c57f6c34de0b1ed5d9089b9" translate="yes" xml:space="preserve">
          <source>Assertion fault in FTS4. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d6ec09eccf68cfc&quot;&gt;d6ec09eccf68cfc&lt;/a&gt;</source>
          <target state="translated">FTS4中的断言错误。票证&lt;a href=&quot;https://www.sqlite.org/src/info/d6ec09eccf68cfc&quot;&gt;d6ec09eccf68cfc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ebc26a866ddd19c561f95f02b90e42c3048bf831" translate="yes" xml:space="preserve">
          <source>Assertion fault on queries involving expressions of the form &quot;x IN (?)&quot;. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/e39d032577&quot;&gt;e39d032577&lt;/a&gt;.</source>
          <target state="translated">涉及形式为&amp;ldquo; x IN（？）&amp;rdquo;的表达式的查询的断言错误。票务&lt;a href=&quot;http://www.sqlite.org/src/info/e39d032577&quot;&gt;e39d032577&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b09350595e5b1fc88b326f66d8663dd0c36c6199" translate="yes" xml:space="preserve">
          <source>Assertion fault on queries involving expressions of the form &quot;x IN (?)&quot;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/e39d032577&quot;&gt;e39d032577&lt;/a&gt;.</source>
          <target state="translated">涉及形式为&amp;ldquo; x IN（？）&amp;rdquo;的表达式的查询的断言错误。票证&lt;a href=&quot;https://www.sqlite.org/src/info/e39d032577&quot;&gt;e39d032577&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8c84e5f05e8b60b78b6a824b91605a18f1523027" translate="yes" xml:space="preserve">
          <source>Assertion fault when doing REPLACE on an index on an expression. Ticket &lt;a href=&quot;https://sqlite.org/src/info/dc3f932f5a147771&quot;&gt;dc3f932f5a147771&lt;/a&gt;</source>
          <target state="translated">在表达式的索引上执行REPLACE时，断言错误。门票&lt;a href=&quot;https://sqlite.org/src/info/dc3f932f5a147771&quot;&gt;DC3F932F5A147771&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14462bb4d8840870eeb8b473a0f255cc7e22e056" translate="yes" xml:space="preserve">
          <source>Assertion fault when doing an IN operator on a constant index. Ticket &lt;a href=&quot;https://sqlite.org/src/info/aa98619ad08ddcab&quot;&gt;aa98619ad08ddcab&lt;/a&gt;</source>
          <target state="translated">在常数索引上执行IN运算符时断言错误。门票&lt;a href=&quot;https://sqlite.org/src/info/aa98619ad08ddcab&quot;&gt;aa98619ad08ddcab&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6cea6f6a832fd7bbb6517d045402e777f939a795" translate="yes" xml:space="preserve">
          <source>Assigned the integer at offset 68 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt; as the &lt;a href=&quot;fileformat2#appid&quot;&gt;Application ID&lt;/a&gt; for when SQLite is used as an &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;. Added the &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; command to query and set the Application ID.</source>
          <target state="translated">将SQLite用作&lt;a href=&quot;appfileformat&quot;&gt;应用程序文件格式&lt;/a&gt;时，将&lt;a href=&quot;fileformat2#database_header&quot;&gt;数据库标头&lt;/a&gt;中偏移量68处的整数分配为&lt;a href=&quot;fileformat2#appid&quot;&gt;应用程序ID&lt;/a&gt;。添加了&lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt;命令以查询和设置应用程序ID。</target>
        </trans-unit>
        <trans-unit id="2dc2100f672c34160990cbf608240b0f61030c73" translate="yes" xml:space="preserve">
          <source>Assuming</source>
          <target state="translated">Assuming</target>
        </trans-unit>
        <trans-unit id="ea6dcdcecbe15c6b4677215943bc88e69426e6db" translate="yes" xml:space="preserve">
          <source>Assuming no errors have occurred, then after attempting to detect and roll back a</source>
          <target state="translated">假设没有发生任何错误,那么在尝试检测并回滚一个</target>
        </trans-unit>
        <trans-unit id="2d3766c3aab2fade58e514ea17fb6dc49420a581" translate="yes" xml:space="preserve">
          <source>Assuming statistics are enabled, the following routine can be used to access them:</source>
          <target state="translated">假设启用了统计功能,可以使用以下例程来访问它们。</target>
        </trans-unit>
        <trans-unit id="836ad82865d510ff9a297c7660cf9d810b0b4728" translate="yes" xml:space="preserve">
          <source>Assuming that after registering for an unlock-notify callback a database waits for the callback to be issued before taking any further action (a reasonable assumption), then using this API may cause the application to deadlock. For example, if connection X is waiting for connection Y's transaction to be concluded, and similarly connection Y is waiting on connection X's transaction, then neither connection will proceed and the system may remain deadlocked indefinitely.</source>
          <target state="translated">假设在注册解锁-通知回调后,数据库会等待回调发出后再采取任何进一步的行动(一个合理的假设),那么使用这个API可能会导致应用程序死锁。例如,如果连接X正在等待连接Y的事务结束,同样连接Y也在等待连接X的事务,那么两个连接都不会继续,系统可能会无限期地保持死锁状态。</target>
        </trans-unit>
        <trans-unit id="3ba1c75f29bb0c1b541e404f389344df8b7d3190" translate="yes" xml:space="preserve">
          <source>Assuming that any and all sectors in the transient state may be corrupted following a power or system failure is a very pessimistic approach. Some modern systems provide more sophisticated guarantees than this. SQLite allows the VFS implementation to specify at runtime that the current platform supports zero or more of the following properties:</source>
          <target state="translated">假设在电源或系统故障后,瞬态中的任何和所有部门都可能被破坏,这是一种非常悲观的做法。一些现代系统提供了比这更复杂的保证。SQLite允许VFS实现在运行时指定当前平台支持以下0个或多个属性。</target>
        </trans-unit>
        <trans-unit id="22e7a33261340b9207abc7f6240781daed2437d8" translate="yes" xml:space="preserve">
          <source>Assuming that customer records are stored in the &quot;customers&quot; table, and that order records are stored in the &quot;orders&quot; table, the following UPDATE trigger ensures that all associated orders are redirected when a customer changes his or her address:</source>
          <target state="translated">假设客户记录存储在 &quot;customers &quot;表中,订单记录存储在 &quot;orders &quot;表中,下面的UPDATE触发器可以确保当客户更改地址时,所有相关的订单都会被重定向。</target>
        </trans-unit>
        <trans-unit id="ff40c2070ad237bff82bd7bce4ef0b45898889d0" translate="yes" xml:space="preserve">
          <source>Assuming that the compile-time threading mode is not single-thread, then the threading mode can be changed during initialization using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface. The &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; verb puts SQLite into single-thread mode, the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; verb sets multi-thread mode, and the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt; verb sets serialized mode.</source>
          <target state="translated">假设编译时线程模式不是单线程，则可以在初始化期间使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;接口更改线程模式。该&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;动词放源码为单线程模式下，&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt;动词集多线程模式，&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt;动词序列模式集。</target>
        </trans-unit>
        <trans-unit id="5e4099134714457b667c5a0d0c91727935a69b43" translate="yes" xml:space="preserve">
          <source>Assuming that the first hidden column of &quot;tablevaluedfunc&quot; is &quot;param1&quot;, the query above is semantically equivalent to this:</source>
          <target state="translated">假设 &quot;tablevaluedfunc &quot;的第一个隐藏列是 &quot;param1&quot;,上面的查询在语义上等同于此。</target>
        </trans-unit>
        <trans-unit id="a392f90a65c67ef3276bb011e52cf4659579c18e" translate="yes" xml:space="preserve">
          <source>Assuming the changeset blob was created by one of the &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt;, &lt;a href=&quot;#sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat()&lt;/a&gt; or &lt;a href=&quot;#sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert()&lt;/a&gt; functions, all changes within the changeset that apply to a single table are grouped together. This means that when an application iterates through a changeset using an iterator created by this function, all changes that relate to a single table are visited consecutively. There is no chance that the iterator will visit a change the applies to table X, then one for table Y, and then later on visit another change for table X.</source>
          <target state="translated">假设变更集blob是由&lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert（）&lt;/a&gt;函数之一创建的，则变更集中的所有应用于单个表的更改都被分组在一起。这意味着，当应用程序使用此函数创建的迭代器迭代变更集时，将连续访问与单个表相关的所有更改。迭代器没有机会访问表X的更改，然后再访问表Y的更改，然后再访问表X的另一个更改。</target>
        </trans-unit>
        <trans-unit id="ae768e26e15e53e036c5e372149bd64f61fe40d5" translate="yes" xml:space="preserve">
          <source>Assuming the changeset blob was created by one of the &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt;, &lt;a href=&quot;sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat()&lt;/a&gt; or &lt;a href=&quot;sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert()&lt;/a&gt; functions, all changes within the changeset that apply to a single table are grouped together. This means that when an application iterates through a changeset using an iterator created by this function, all changes that relate to a single table are visited consecutively. There is no chance that the iterator will visit a change the applies to table X, then one for table Y, and then later on visit another change for table X.</source>
          <target state="translated">假设变更集blob是由&lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset（）&lt;/a&gt;，&lt;a href=&quot;sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat（）&lt;/a&gt;或&lt;a href=&quot;sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert（）&lt;/a&gt;函数之一创建的，则变更集中的所有应用于单个表的更改都被分组在一起。这意味着，当应用程序使用此函数创建的迭代器迭代变更集时，将连续访问与单个表相关的所有更改。迭代器没有机会访问表X的更改，然后再访问表Y的更改，然后再访问表X的另一个更改。</target>
        </trans-unit>
        <trans-unit id="ae27622bf93c5f8e58c667e3d2b3f8634b153cf3" translate="yes" xml:space="preserve">
          <source>Assuming the library is compiled with foreign key constraints enabled, it must still be enabled by the application at runtime, using the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; command. For example:</source>
          <target state="translated">假设在编译库时启用了外键约束，则应用程序仍必须在运行时使用&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt;命令启用该库。例如：</target>
        </trans-unit>
        <trans-unit id="4a1dda34c843a460a37b4389bc3fdea530b33452" translate="yes" xml:space="preserve">
          <source>Assuming the nominated table does exist, then its columns must be the same as or a superset of those defined for the FTS table. The external table must also be in the same database file as the FTS table. In other words, The external table cannot be in a different database file connected using &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; nor may one of the FTS table and the external content be in the TEMP database when the other is in a persistent database file such as MAIN.</source>
          <target state="translated">假设指定的表确实存在，则其列必须与为FTS表定义的列相同或超集。外部表还必须与FTS表位于同一数据库文件中。换句话说，外部表不能位于使用&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;连接的其他数据库文件中，FTS表和外部内容中的一个不能位于TEMP数据库中，而另一个位于诸如MAIN之类的持久数据库文件中。</target>
        </trans-unit>
        <trans-unit id="921866ee0046d5a80db64dfb8749244f24a09ba6" translate="yes" xml:space="preserve">
          <source>Assuming the table is not also a &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless table&lt;/a&gt;, the &lt;a href=&quot;#xInstCount&quot;&gt;xInstCount&lt;/a&gt;, &lt;a href=&quot;#xInst&quot;&gt;xInst&lt;/a&gt;, &lt;a href=&quot;#xPhraseFirst&quot;&gt;xPhraseFirst&lt;/a&gt; and &lt;a href=&quot;#xPhraseNext&quot;&gt;xPhraseNext&lt;/a&gt; are slower than usual. This is because instead of reading the required data directly from the FTS index they have to load and tokenize the document text on demand.</source>
          <target state="translated">假设该表也不是一个&lt;a href=&quot;#xInstCount&quot;&gt;无内容的&lt;/a&gt;&lt;a href=&quot;fts5#contentless_tables&quot;&gt;表&lt;/a&gt;，则xInstCount，&lt;a href=&quot;#xInst&quot;&gt;xInst&lt;/a&gt;，&lt;a href=&quot;#xPhraseFirst&quot;&gt;xPhraseFirst&lt;/a&gt;和&lt;a href=&quot;#xPhraseNext&quot;&gt;xPhraseNext&lt;/a&gt;会比平时慢。这是因为它们必须直接按需加载和标记文档文本，而不是直接从FTS索引中读取所需的数据。</target>
        </trans-unit>
        <trans-unit id="dc375c212f41b57083889574933fcd5e4987a611" translate="yes" xml:space="preserve">
          <source>Assuming the table is not also a contentless table, the &lt;a href=&quot;#xPhraseFirstColumn&quot;&gt;xPhraseFirstColumn&lt;/a&gt; and &lt;a href=&quot;#xPhraseNextColumn&quot;&gt;xPhraseNextColumn&lt;/a&gt; are slower than usual.</source>
          <target state="translated">假设该表也不是一个&lt;a href=&quot;#xPhraseFirstColumn&quot;&gt;无内容的&lt;/a&gt;表，则xPhraseFirstColumn和&lt;a href=&quot;#xPhraseNextColumn&quot;&gt;xPhraseNextColumn&lt;/a&gt;的速度将比平时慢。</target>
        </trans-unit>
        <trans-unit id="504be981e8ff80c0d63cd17a340b7f1cd587e84d" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O appears to give better responsiveness, but at a price. You lose the Durable property. With the default I/O backend of SQLite, once a write completes, you know that the information you wrote is safely on disk. With the asynchronous I/O, this is not the case. If your program crashes or if a power loss occurs after the database write but before the asynchronous write thread has completed, then the database change might never make it to disk and the next user of the database might not see your change.</source>
          <target state="translated">异步I/O似乎能提供更好的响应性,但也有代价。你失去了Durable属性。在SQLite的默认I/O后端,一旦写入完成,你就知道你所写的信息安全地保存在磁盘上。在异步I/O中,情况并非如此。如果你的程序崩溃了,或者在数据库写入之后但异步写入线程完成之前发生了断电,那么数据库的更改可能永远不会进入磁盘,数据库的下一个用户可能不会看到你的更改。</target>
        </trans-unit>
        <trans-unit id="2c26b5cd54f0029b1a3269b19cfe3a6ff6addbcc" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O works by creating an SQLite &lt;a href=&quot;c3ref/vfs&quot;&gt;VFS object&lt;/a&gt; and registering it with &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;. When files opened via this VFS are written to (using the vfs xWrite() method), the data is not written directly to disk, but is placed in the &quot;write-queue&quot; to be handled by the background thread.</source>
          <target state="translated">异步I / O通过创建SQLite &lt;a href=&quot;c3ref/vfs&quot;&gt;VFS对象&lt;/a&gt;并将其注册到&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）来工作&lt;/a&gt;。写入通过此VFS打开的文件时（使用vfs xWrite（）方法），数据不会直接写入磁盘，而是会放在&amp;ldquo;写入队列&amp;rdquo;中，由后台线程处理。</target>
        </trans-unit>
        <trans-unit id="4c91d5ce458c482219d3664734d8a556293b6cdf" translate="yes" xml:space="preserve">
          <source>At a shell or DOS prompt, enter: &quot;&lt;b&gt;sqlite3 test.db&lt;/b&gt;&quot;. This will create a new database named &quot;test.db&quot;. (You can use a different name if you like.)</source>
          <target state="translated">在shell或DOS提示符下，输入：&amp;ldquo; &lt;b&gt;sqlite3 test.db&lt;/b&gt; &amp;rdquo;。这将创建一个名为&amp;ldquo; test.db&amp;rdquo;的新数据库。（如果愿意，可以使用其他名称。）</target>
        </trans-unit>
        <trans-unit id="449f6270af54115e84fbbfac0ca3ab28ec064210" translate="yes" xml:space="preserve">
          <source>At about that same time, some avionics manufacturers were expressing interest in SQLite, which prompted the SQLite developers to design TH3 to support the rigorous testing standards of &lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt;.</source>
          <target state="translated">大约在同一时间，一些航空电子制造商表达了对SQLite的兴趣，这促使SQLite开发人员设计TH3以支持严格的&lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt;测试标准。</target>
        </trans-unit>
        <trans-unit id="d3fd57d066718d01302089d95d92c8454d1b5f4a" translate="yes" xml:space="preserve">
          <source>At any one time, a single table may have any number of active read-locks or a single active write lock. To read data a table, a connection must first obtain a read-lock. To write to a table, a connection must obtain a write-lock on that table. If a required table lock cannot be obtained, the query fails and SQLITE_LOCKED is returned to the caller.</source>
          <target state="translated">在任何时候,一个表可能有任意数量的活动读锁或一个活动写锁。要读取一个表的数据,一个连接必须首先获得一个读锁。要向一个表写入数据,一个连接必须获得该表的写锁。如果不能获得所需的表锁,则查询失败,SQLITE_LOCKED返回给调用者。</target>
        </trans-unit>
        <trans-unit id="b7a3b82c7cb7013957f0c0e0e4f1a6c43e18aa55" translate="yes" xml:space="preserve">
          <source>At any one time, a single table may have any number of active read-locks or a single active write lock. To read data from a table, a connection must first obtain a read-lock. To write to a table, a connection must obtain a write-lock on that table. If a required table lock cannot be obtained, the query fails and SQLITE_LOCKED is returned to the caller.</source>
          <target state="translated">在任何时候,一张表可能有任意数量的活动读锁或单一活动写锁。要从一个表读取数据,一个连接必须首先获得一个读锁。要向一个表写入数据,一个连接必须获得该表的写锁。如果不能获得所需的表锁,则查询失败,SQLITE_LOCKED返回给调用者。</target>
        </trans-unit>
        <trans-unit id="e2c8ad5daed2b52823fb4c80a495b310ef19384a" translate="yes" xml:space="preserve">
          <source>At any one time, each</source>
          <target state="translated">在任何时候,每个</target>
        </trans-unit>
        <trans-unit id="8560f4e49c6caa4d7228201f89aa3ea44ff72f5b" translate="yes" xml:space="preserve">
          <source>At any one time, the</source>
          <target state="translated">在任何时候,</target>
        </trans-unit>
        <trans-unit id="faefe425b3756bc94c56346d8a50b44d5ccda922" translate="yes" xml:space="preserve">
          <source>At any point in time, every page in the main database has a single use which is one of the following:</source>
          <target state="translated">在任何时候,主数据库中的每一个页面都有一个单一的用途,该用途属于以下情况之一。</target>
        </trans-unit>
        <trans-unit id="4998acdc6089555e0887c221354101b4a2253663" translate="yes" xml:space="preserve">
          <source>At first glance, the final two full-text queries in the example above seem to be syntactically incorrect, as there is a table name (&quot;mail&quot;) used as an SQL expression. The reason this is acceptable is that each FTS table actually has a &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;HIDDEN&lt;/a&gt; column with the same name as the table itself (in this case, &quot;mail&quot;). The value stored in this column is not meaningful to the application, but can be used as the left-hand operand to a MATCH operator. This special column may also be passed as an argument to the &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt;.</source>
          <target state="translated">乍一看，上面的示例中的最后两个全文查询在语法上似乎不正确，因为有一个表名（&amp;ldquo;邮件&amp;rdquo;）用作SQL表达式。可以接受的原因是，每个FTS表实际上都有一个&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;HIDDEN&lt;/a&gt;列，其名称与表本身相同（在本例中为&amp;ldquo; mail&amp;rdquo;）。存储在此列中的值对应用程序没有意义，但可以用作MATCH运算符的左侧操作数。该特殊列也可以作为参数传递给&lt;a href=&quot;fts3#snippet&quot;&gt;FTS辅助功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2f5836449640e20f49edf00efccee8083a6bcb35" translate="yes" xml:space="preserve">
          <source>At least szOsFile bytes of memory are allocated by SQLite to hold the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; structure passed as the third argument to xOpen. The xOpen method does not have to allocate the structure; it should just fill it in. Note that the xOpen method must set the sqlite3_file.pMethods to either a valid &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object or to NULL. xOpen must do this even if the open fails. SQLite expects that the sqlite3_file.pMethods element will be valid after xOpen returns regardless of the success or failure of the xOpen call.</source>
          <target state="translated">SQLite至少分配了szOsFile字节的内存，以保存作为第三个参数传递给xOpen 的&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt;结构。 xOpen方法不必分配结构。它应该只填写它。请注意，xOpen方法必须将sqlite3_file.pMethods设置为有效的&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象或设置为NULL。即使打开失败，xOpen也必须执行此操作。 SQLite希望无论xOpen调用成功与否，在xOpen返回之后sqlite3_file.pMethods元素都将有效。</target>
        </trans-unit>
        <trans-unit id="59514e13b273471c6ec6f5f109fedbde115ba166" translate="yes" xml:space="preserve">
          <source>At least szOsFile bytes of memory are allocated by SQLite to hold the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; structure passed as the third argument to xOpen. The xOpen method does not have to allocate the structure; it should just fill it in. Note that the xOpen method must set the sqlite3_file.pMethods to either a valid &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object or to NULL. xOpen must do this even if the open fails. SQLite expects that the sqlite3_file.pMethods element will be valid after xOpen returns regardless of the success or failure of the xOpen call.</source>
          <target state="translated">SQLite至少分配了szOsFile字节的内存，以保存作为第三个参数传递给xOpen 的&lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt;结构。 xOpen方法不必分配结构。它应该只填写它。请注意，xOpen方法必须将sqlite3_file.pMethods设置为有效的&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象或设置为NULL。即使打开失败，xOpen也必须执行此操作。 SQLite希望无论xOpen调用成功与否，在xOpen返回之后sqlite3_file.pMethods元素都将有效。</target>
        </trans-unit>
        <trans-unit id="5cf0c7d5d4e31a3622d3bed10cffc599203f902a" translate="yes" xml:space="preserve">
          <source>At most one connection to a single shared cache may open a write transaction at any one time. This may co-exist with any number of read transactions.</source>
          <target state="translated">在任何时候,最多只能有一个连接到单个共享缓存的连接可以打开一个写事务。这可能会与任何数量的读事务共存。</target>
        </trans-unit>
        <trans-unit id="2549fa7b8565911915cfbc5b3b9d42147224732f" translate="yes" xml:space="preserve">
          <source>At one point, &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; was sometimes licensed to third-parties. Such licensing no longer occurs. However, back when it was occurring, some of the TH3 test cases contained information that was sensitive and could not be released even to licensees. This sensitive information is stored in yet another repository.</source>
          <target state="translated">有时，&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;有时被许可给第三方。这样的许可不再发生。但是，当发生这种情况时，一些TH3测试用例包含的信息很敏感，甚至无法向被许可人发布。此敏感信息存储在另一个存储库中。</target>
        </trans-unit>
        <trans-unit id="4d936f8adee7e8e3dc2d8a9b26c4bae945a9dd4c" translate="yes" xml:space="preserve">
          <source>At present, there is only one option that may be configured using this function. (See &lt;a href=&quot;#sqlitevtabconstraintsupport&quot;&gt;SQLITE_VTAB_CONSTRAINT_SUPPORT&lt;/a&gt;.) Further options may be added in the future.</source>
          <target state="translated">当前，只能使用此功能配置一个选项。（请参阅&lt;a href=&quot;#sqlitevtabconstraintsupport&quot;&gt;SQLITE_VTAB_CONSTRAINT_SUPPORT&lt;/a&gt;。）将来可能会添加更多选项。</target>
        </trans-unit>
        <trans-unit id="e0662b7a2bebf7dce7d12510693eb67ca1548c61" translate="yes" xml:space="preserve">
          <source>At present, there is only one option that may be configured using this function. (See &lt;a href=&quot;c_vtab_constraint_support#sqlitevtabconstraintsupport&quot;&gt;SQLITE_VTAB_CONSTRAINT_SUPPORT&lt;/a&gt;.) Further options may be added in the future.</source>
          <target state="translated">当前，只能使用此功能配置一个选项。（请参阅&lt;a href=&quot;c_vtab_constraint_support#sqlitevtabconstraintsupport&quot;&gt;SQLITE_VTAB_CONSTRAINT_SUPPORT&lt;/a&gt;。）将来可能会添加更多选项。</target>
        </trans-unit>
        <trans-unit id="598f95760d8ef9fc04e0c94379f28c6b7cd53470" translate="yes" xml:space="preserve">
          <source>At the beginning of a cache spill, the status of the database connection is as shown in &lt;a href=&quot;#section_3_6&quot;&gt;step 3.6&lt;/a&gt;. Original page content has been saved in the rollback journal and modifications of the pages exist in user memory. To spill the cache, SQLite executes steps &lt;a href=&quot;#section_3_7&quot;&gt;3.7&lt;/a&gt; through &lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt;. In other words, the rollback journal is flushed to disk, an exclusive lock is acquired, and changes are written into the database. But the remaining steps are deferred until the transaction really commits. A new journal header is appended to the end of the rollback journal (in its own sector) and the exclusive database lock is retained, but otherwise processing returns to &lt;a href=&quot;#section_3_6&quot;&gt;step 3.6&lt;/a&gt;. When the transaction commits, or if another cache spill occurs, steps &lt;a href=&quot;#section_3_7&quot;&gt;3.7&lt;/a&gt; and &lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt; are repeated. (Step &lt;a href=&quot;#section_3_8&quot;&gt;3.8&lt;/a&gt; is omitted on second and subsequent passes since an exclusive database lock is already held due to the first pass.)</source>
          <target state="translated">在缓存溢出开始时，数据库连接的状态如&lt;a href=&quot;#section_3_6&quot;&gt;步骤3.6&lt;/a&gt;所示。原始页面内容已保存在回滚日志中，并且页面的修改存在于用户内存中。为了溢出缓存，SQLite执行步骤&lt;a href=&quot;#section_3_7&quot;&gt;3.7&lt;/a&gt;到&lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt;。换句话说，将回滚日志刷新到磁盘，获取排他锁，并将更改写入数据库。但是其余步骤将推迟到事务真正提交之前。将新的日志标头附加到回滚日志的末尾（在其自己的扇区中），并且保留独占数据库锁，但是否则处理返回到&lt;a href=&quot;#section_3_6&quot;&gt;步骤3.6&lt;/a&gt;。当事务提交时，或者如果发生另一个缓存溢出，则执行步骤&lt;a href=&quot;#section_3_7&quot;&gt;3.7&lt;/a&gt;和&lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt;重复。（由于第二遍及后续遍历已被排除，因此由于第一遍遍已拥有排他数据库锁，因此省略了步骤&lt;a href=&quot;#section_3_8&quot;&gt;3.8&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="a07c0967c09d3dbc3e32b1c4ad8479eec1c47ba2" translate="yes" xml:space="preserve">
          <source>At this point you are ready to type &quot;&lt;code&gt;./configure; make&lt;/code&gt;&quot; (or on Windows with MSVC, &quot;&lt;code&gt;nmake /f Makefile.msc&lt;/code&gt;&quot;).</source>
          <target state="translated">此时，您可以输入&amp;ldquo; &lt;code&gt;./configure; make&lt;/code&gt; &amp;rdquo;（或在具有MSVC的Windows上，输入&amp;ldquo; &lt;code&gt;nmake /f Makefile.msc&lt;/code&gt; &amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="5d9739e0c9d62ebb2f85f2435395edecdd3fc346" translate="yes" xml:space="preserve">
          <source>At this point, you can measure the amount of disk space used by the test1.db database and the space used by the test1.dir directory and all of its content. On a standard Ubuntu Linux desktop, the database file will be 1,024,512,000 bytes in size and the test1.dir directory will use 1,228,800,000 bytes of space (according to &quot;du -k&quot;), about 20% more than the database.</source>
          <target state="translated">此时,你可以测量test1.db数据库使用的磁盘空间和test1.dir目录及其所有内容使用的空间。在标准的Ubuntu Linux桌面上,数据库文件的大小为1,024,512,000字节,test1.dir目录将使用1,228,800,000字节的空间(根据 &quot;du -k&quot;),大约比数据库多20%。</target>
        </trans-unit>
        <trans-unit id="05593853b78d4288d0ab3317d42f66fcc3356044" translate="yes" xml:space="preserve">
          <source>At this point, you should understand the VDBE well enough to figure out on your own how the above program works. So we will not discuss it further in this text.</source>
          <target state="translated">此时,你应该对VDBE有了足够的了解,可以自己弄清楚上述程序的工作原理。所以,我们在本文中不再进一步讨论。</target>
        </trans-unit>
        <trans-unit id="7ed93611b051b3f2ce2f2e18dd2aa20d02819e82" translate="yes" xml:space="preserve">
          <source>At this point, you should understand the basics of how the VDBE writes to a database. Now let's look at how it does queries. We will use the following simple SELECT statement as our example:</source>
          <target state="translated">至此,你应该明白了VDBE如何向数据库写入的基本知识。现在我们来看看它是如何进行查询的。我们将使用下面简单的SELECT语句作为例子。</target>
        </trans-unit>
        <trans-unit id="ca131936c53e26b047834300b8b5909015686af9" translate="yes" xml:space="preserve">
          <source>At this time SQLite supports only FOR EACH ROW triggers, not FOR EACH STATEMENT triggers. Hence explicitly specifying FOR EACH ROW is optional. FOR EACH ROW implies that the SQL statements specified in the trigger may be executed (depending on the WHEN clause) for each database row being inserted, updated or deleted by the statement causing the trigger to fire.</source>
          <target state="translated">目前SQLite只支持FOR EACH ROW触发器,不支持FOR EACH STATEMENT触发器。因此,明确指定FOR EACH ROW是可选的。FOR EACH ROW意味着在触发器中指定的SQL语句可以被执行(取决于WHEN子句),对于每一条被触发器触发的语句插入、更新或删除的数据库行。</target>
        </trans-unit>
        <trans-unit id="9f2f2ddc27722f56f60ce157d4213f6b2caed0bd" translate="yes" xml:space="preserve">
          <source>At this writing, 2050 is still 34 years in the future. Nobody knows what will happen in that time, and we cannot absolutely promise that SQLite will be viable or useful that far out. But we can promise this: we plan as if we will be supporting SQLite until 2050. That long-term outlook affects our decisions in important ways.</source>
          <target state="translated">在写这篇文章时,2050年仍然是34年后的事情。没有人知道在那个时候会发生什么,我们也不能绝对保证SQLite在那么远的将来还能生存或有用。但我们可以承诺:我们的计划是,我们将支持SQLite到2050年。这种长期的展望会以重要的方式影响我们的决策。</target>
        </trans-unit>
        <trans-unit id="5dc594be0856868f818e54abe920fd51cc599639" translate="yes" xml:space="preserve">
          <source>Atomic Commit In SQLite</source>
          <target state="translated">SQLite中的原子提交</target>
        </trans-unit>
        <trans-unit id="2d4c9569233db52020accb44326c29045c8c4cce" translate="yes" xml:space="preserve">
          <source>Atomic Transactions</source>
          <target state="translated">原子交易</target>
        </trans-unit>
        <trans-unit id="01c8139f3cad23c8756bfadca13473ed3a8e76ee" translate="yes" xml:space="preserve">
          <source>Atomic commits for ATTACHed databases.</source>
          <target state="translated">ATTACHED数据库的原子提交。</target>
        </trans-unit>
        <trans-unit id="d81553de52fcfae8fe4cc1bad5f59236dea06c3f" translate="yes" xml:space="preserve">
          <source>Atomically releases the mutex and begins waiting for the asynchronous signal. When the signal arrives, continue.</source>
          <target state="translated">原子上释放mutex,开始等待异步信号。当信号到达时,继续。</target>
        </trans-unit>
        <trans-unit id="92dd7a0665a3434edc8f121885515c600f18e15b" translate="yes" xml:space="preserve">
          <source>Attach A Table To A Session Object</source>
          <target state="translated">将一个表附加到一个会话对象上</target>
        </trans-unit>
        <trans-unit id="4d752510d48bfeb2c136d1e65419fdd66d0835e6" translate="yes" xml:space="preserve">
          <source>Attempt To Free Heap Memory</source>
          <target state="translated">试图释放堆内存</target>
        </trans-unit>
        <trans-unit id="88ccf4926dcde2d4398cadb109fcd1c1c1205d36" translate="yes" xml:space="preserve">
          <source>Attempt to optimize the database. All schemas are optimized in the first two forms, and only the specified schema is optimized in the latter two.</source>
          <target state="translated">试图优化数据库。在前两种形式下,所有的模式都会被优化,在后两种形式下,只有指定的模式会被优化。</target>
        </trans-unit>
        <trans-unit id="72b5f89658d37542e4f2f47adfbbada66e9f74c3" translate="yes" xml:space="preserve">
          <source>Attempt to return the underlying operating system error code or error number that caused the most recent I/O error or failure to open a file. The return value is OS-dependent. For example, on unix systems, after &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt;, this interface could be called to get back the underlying &quot;errno&quot; that caused the problem, such as ENOSPC, EAUTH, EISDIR, and so forth.</source>
          <target state="translated">尝试返回导致最近的I / O错误或无法打开文件的基础操作系统错误代码或错误号。返回值取决于OS。例如，在UNIX系统上，在&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN之后&lt;/a&gt;，可以调用此接口以获取引起问题的基础&amp;ldquo; errno&amp;rdquo;，例如ENOSPC，EAUTH，EISDIR等。</target>
        </trans-unit>
        <trans-unit id="50dfefcf7c07518a2714e6179a3b3e2c44246560" translate="yes" xml:space="preserve">
          <source>Attempt to return the underlying operating system error code or error number that caused the most recent I/O error or failure to open a file. The return value is OS-dependent. For example, on unix systems, after &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; returns &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt;, this interface could be called to get back the underlying &quot;errno&quot; that caused the problem, such as ENOSPC, EAUTH, EISDIR, and so forth.</source>
          <target state="translated">尝试返回导致最近的I / O错误或无法打开文件的基础操作系统错误代码或错误号。返回值取决于OS。例如，在UNIX系统上，在&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;返回&lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN之后&lt;/a&gt;，可以调用此接口以获取引起问题的基础&amp;ldquo; errno&amp;rdquo;，例如ENOSPC，EAUTH，EISDIR等。</target>
        </trans-unit>
        <trans-unit id="316c0eb6ee34ebe2465e653e0615de6cea48d923" translate="yes" xml:space="preserve">
          <source>Attempting to read any column value except the rowid from a contentless FTS5 table returns an SQL NULL value.</source>
          <target state="translated">试图从一个无内容的FTS5表中读取除了rowid以外的任何列值都会返回一个SQL NULL值。</target>
        </trans-unit>
        <trans-unit id="759ff226aedc6e7693575bc9de2859284a195a00" translate="yes" xml:space="preserve">
          <source>Attempts to signal a waiting thread.</source>
          <target state="translated">试图向一个等待的线程发出信号。</target>
        </trans-unit>
        <trans-unit id="70c4d17e8ff8b4302eac4e4e2a0df21e83e7e1f7" translate="yes" xml:space="preserve">
          <source>Attribute to God, and not to self, whatever good you see in yourself.</source>
          <target state="translated">把你看到的自己的任何好处都归于神,而不是归于自己。</target>
        </trans-unit>
        <trans-unit id="825e25e0e089626089745a27ce2ef2c2c1ea38e6" translate="yes" xml:space="preserve">
          <source>Authorizer Action Codes</source>
          <target state="translated">授权人行动代码</target>
        </trans-unit>
        <trans-unit id="1592d27599a37fb2c21560009556822d633223ac" translate="yes" xml:space="preserve">
          <source>Authorizer Return Codes</source>
          <target state="translated">授权人回报代码</target>
        </trans-unit>
        <trans-unit id="8d4b099d8f18d61aaa97d7c1192205d9f09f6d1b" translate="yes" xml:space="preserve">
          <source>Authorizer callback now notified of ALTER TABLE ADD COLUMN commands</source>
          <target state="translated">授权者回调现在通知ALTER TABLE ADD COLUMN命令。</target>
        </trans-unit>
        <trans-unit id="f99108c69c3665b09cc818cd43a65b08e779b2ac" translate="yes" xml:space="preserve">
          <source>Auto-vacuuming is only possible if the database stores some additional information that allows each database page to be traced backwards to its referrer. Therefore, auto-vacuuming must be turned on before any tables are created. It is not possible to enable or disable auto-vacuum after a table has been created.</source>
          <target state="translated">只有当数据库存储了一些额外的信息,使每个数据库页面都可以追溯到它的引用者时,自动清空才有可能。因此,必须在创建任何表之前开启自动吸尘功能。在创建表后,不可能启用或禁用自动吸尘功能。</target>
        </trans-unit>
        <trans-unit id="20745b1bcf8af10b98b427193825b087099c77ec" translate="yes" xml:space="preserve">
          <source>AutoCommit</source>
          <target state="translated">AutoCommit</target>
        </trans-unit>
        <trans-unit id="356d8f675fe3749abf68433babe7ea3575fd985f" translate="yes" xml:space="preserve">
          <source>Autocheckpointing is enabled by default with an interval of 1000 or &lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt;.</source>
          <target state="translated">默认情况下，自动检查点的启用间隔为1000或&lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22f681c869bb1ea71c5ddca4b639af93b4fef9e9" translate="yes" xml:space="preserve">
          <source>Autoincrement now works for INSERT from a SELECT.</source>
          <target state="translated">现在,从SELECT中的INSERT可以自动增加。</target>
        </trans-unit>
        <trans-unit id="be6b6b970c4ffe43f44cd98c8c080e19e0935d7d" translate="yes" xml:space="preserve">
          <source>Automatic Creation Of Triggers</source>
          <target state="translated">自动创建触发器</target>
        </trans-unit>
        <trans-unit id="b08dba6041d7d4235968c19294ed55fda427f921" translate="yes" xml:space="preserve">
          <source>Automatic Undo/Redo Using SQLite</source>
          <target state="translated">使用SQLite自动撤销/重做</target>
        </trans-unit>
        <trans-unit id="e4c6cb294be7b858504d17f8ae3afc2b1d34ca14" translate="yes" xml:space="preserve">
          <source>Automatic Undo/Redo With SQLite</source>
          <target state="translated">使用SQLite自动撤销/重做</target>
        </trans-unit>
        <trans-unit id="21544829b41ef1983cd743adcc40b46678a3e3f5" translate="yes" xml:space="preserve">
          <source>Automatic caching of prepared statements in the TCL interface</source>
          <target state="translated">在TCL接口中自动缓存已准备好的语句。</target>
        </trans-unit>
        <trans-unit id="5c31289d03ed4b24b0edaf412e508ce77bc130da" translate="yes" xml:space="preserve">
          <source>Automatic indexing</source>
          <target state="translated">自动编制索引</target>
        </trans-unit>
        <trans-unit id="b33bad308a6a3f5703b3375cd2f0464df392fd4f" translate="yes" xml:space="preserve">
          <source>Automatically Load Statically Linked Extensions</source>
          <target state="translated">自动加载静态链接的扩展</target>
        </trans-unit>
        <trans-unit id="1866c31db7344041c61c845f3e6c7f6209984d28" translate="yes" xml:space="preserve">
          <source>Automatically Running ANALYZE</source>
          <target state="translated">自动运行ANALYZE</target>
        </trans-unit>
        <trans-unit id="4babc7f522c90b701f1e40024660f0e6d3fdb828" translate="yes" xml:space="preserve">
          <source>Automatically build binaries for Linux and Windows and put them on the website.</source>
          <target state="translated">自动构建Linux和Windows的二进制文件,并将它们放在网站上。</target>
        </trans-unit>
        <trans-unit id="b5a9f83671a7145cd855649b0b10c0da797dd48a" translate="yes" xml:space="preserve">
          <source>Automatically generated ROWIDs are now sequential.</source>
          <target state="translated">自动生成的ROWIDs现在是顺序的。</target>
        </trans-unit>
        <trans-unit id="33b507ce65fb930f163c0cce40902e91ce9a4aa2" translate="yes" xml:space="preserve">
          <source>Automatically intercepts the raw &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; output and reformats it into an ASCII-art graph.</source>
          <target state="translated">自动截取原始的&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;输出并将其重新格式化为ASCII图形。</target>
        </trans-unit>
        <trans-unit id="415678a6fe9db48ebfdb4a92834062e2d75ff761" translate="yes" xml:space="preserve">
          <source>Automatically running ANALYZE</source>
          <target state="translated">自动运行ANALYZE</target>
        </trans-unit>
        <trans-unit id="38a90bc3ee0845edb1d6db34dc8f58cfefb8e89a" translate="yes" xml:space="preserve">
          <source>Autovacuum support added</source>
          <target state="translated">增加了对自动真空的支持</target>
        </trans-unit>
        <trans-unit id="1e357312422cd5ec59a0a1ff553c35208f6f0981" translate="yes" xml:space="preserve">
          <source>Auxiliary Function Changes</source>
          <target state="translated">辅助功能变化</target>
        </trans-unit>
        <trans-unit id="2291a1b828f145bde8901e514ec4c748f1d3e7aa" translate="yes" xml:space="preserve">
          <source>Auxiliary columns are marked with a &quot;+&quot; symbol before the column name. Auxiliary columns must come after all of the coordinate boundary columns. There is a limit of no more than 100 auxiliary columns. The following example shows an r-tree table with auxiliary columns that is equivalent to the two tables &quot;demo_index&quot; and &quot;demo_data&quot; above:</source>
          <target state="translated">辅助列在列名前用 &quot;+&quot;号标记。辅助列必须排在所有坐标边界列之后。辅助列的数量限制为不超过100个。下面的例子显示了一个带有辅助列的r树表,相当于上面的两个表 &quot;demo_index &quot;和 &quot;demo_data&quot;。</target>
        </trans-unit>
        <trans-unit id="107b868f1f6fb032b0de401c1fdc39f9a1324503" translate="yes" xml:space="preserve">
          <source>Auxiliary columns in r-tree tables</source>
          <target state="translated">r树表中的辅助列</target>
        </trans-unit>
        <trans-unit id="6771e220703ae7d95117926a910b1882f3865ed2" translate="yes" xml:space="preserve">
          <source>Auxiliary function mapping</source>
          <target state="translated">辅助功能映射</target>
        </trans-unit>
        <trans-unit id="2a6030396538d218b7dda424404dbcc0322cf175" translate="yes" xml:space="preserve">
          <source>Auxiliary functions are similar to &lt;a href=&quot;lang_corefunc&quot;&gt;SQL scalar functions&lt;/a&gt;, except that they may only be used within full-text queries (those that use the MATCH operator) on an FTS5 table. Their results are calculated based not only on the arguments passed to them, but also on the current match and matched row. For example, an auxiliary function may return a numeric value indicating the accuracy of the match (see the &lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25()&lt;/a&gt; function), or a fragment of text from the matched row that contains one or more instances of the search terms (see the &lt;a href=&quot;fts5#the_snippet_function&quot;&gt;snippet()&lt;/a&gt; function).</source>
          <target state="translated">辅助函数与&lt;a href=&quot;lang_corefunc&quot;&gt;SQL标量函数&lt;/a&gt;相似，除了它们只能在FTS5表的全文查询（使用MATCH运算符的查询）中使用。它们的结果不仅基于传递给它们的参数进行计算，而且还基于当前的匹配项和匹配的行进行计算。例如，辅助函数可能会返回一个数字值，该值指示匹配的准确性（请参见&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25（）&lt;/a&gt;函数），或者返回包含一个或多个搜索字词实例的匹配行中的一段文本（请参见&lt;a href=&quot;fts5#the_snippet_function&quot;&gt;snippet（ ）&lt;/a&gt;功能）。</target>
        </trans-unit>
        <trans-unit id="ad21e0c1521884ee05b9ffda048d19b6293bf5a4" translate="yes" xml:space="preserve">
          <source>Available as a &lt;a href=&quot;amalgamation&quot;&gt;single ANSI-C source-code file&lt;/a&gt; that is &lt;a href=&quot;howtocompile&quot;&gt;easy to compile&lt;/a&gt; and hence is easy to add into a larger project.</source>
          <target state="translated">作为&lt;a href=&quot;amalgamation&quot;&gt;单个ANSI-C源代码文件提供&lt;/a&gt;，该文件&lt;a href=&quot;howtocompile&quot;&gt;易于编译&lt;/a&gt;，因此易于添加到较大的项目中。</target>
        </trans-unit>
        <trans-unit id="91da5ef1fa7e2e4b29d2c4baf5ea203498773356" translate="yes" xml:space="preserve">
          <source>Avoid a possible use-after-free error by deferring schema resets until after the query planner has finished running. Ticket &lt;a href=&quot;https://sqlite.org/src/info/be436a7f4587ce5&quot;&gt;be436a7f4587ce5&lt;/a&gt;</source>
          <target state="translated">通过将架构重置推迟到查询计划程序完成运行之后，来避免可能的&amp;ldquo;售后使用&amp;rdquo;错误。门票&lt;a href=&quot;https://sqlite.org/src/info/be436a7f4587ce5&quot;&gt;be436a7f4587ce5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1e3177c978c905dc59ea3eac3bcce9510d2af169" translate="yes" xml:space="preserve">
          <source>Avoid cache pages leaks following disk-full or I/O errors</source>
          <target state="translated">避免在磁盘满或I/O错误后出现缓存页泄露的情况。</target>
        </trans-unit>
        <trans-unit id="61ddd5eec59e56887e4ac83b6d688d5421fe618d" translate="yes" xml:space="preserve">
          <source>Avoid excess heap usage when copying expressions.</source>
          <target state="translated">复制表达式时,避免过多的堆使用。</target>
        </trans-unit>
        <trans-unit id="24ba1f7d7979447a7e96cb25e07064d86e5bb1c8" translate="yes" xml:space="preserve">
          <source>Avoid invoking the &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; callback multiple times when a statement is automatically reprepared due to &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; errors.</source>
          <target state="translated">当由于&lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt;错误而自动重新准备一条语句时，避免多次调用&lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace（）&lt;/a&gt;回调。</target>
        </trans-unit>
        <trans-unit id="7080f3e1eff1f709a6ca19cf689cc05b5715bf56" translate="yes" xml:space="preserve">
          <source>Avoid recomputing &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; and &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt; on unchanged columns in &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement.</source>
          <target state="translated">避免对&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;语句中未更改的列重新计算&lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt;和&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK约束&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b9f47e376b982a42c816c624a45b787e38257b92" translate="yes" xml:space="preserve">
          <source>Avoid resetting the schema of &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; connections when any one connection closes. Instead, wait for the last connection to close before resetting the schema.</source>
          <target state="translated">避免在任何一个连接关闭时重置&lt;a href=&quot;sharedcache&quot;&gt;共享缓存&lt;/a&gt;连接的架构。而是，等待最后一个连接关闭，然后再重置架构。</target>
        </trans-unit>
        <trans-unit id="d3426fcb94fc158c5d46e9b08cc237640ca2e54e" translate="yes" xml:space="preserve">
          <source>Avoid running foreign-key constraint checks on an UPDATE if none of the modified columns are associated with foreign keys.</source>
          <target state="translated">如果修改后的列都没有与外键相关联,则避免在UPDATE上运行外键约束检查。</target>
        </trans-unit>
        <trans-unit id="fc8f5db6ab5f0aaaf5afe5d9db180abf76160161" translate="yes" xml:space="preserve">
          <source>Avoid this step if possible, as it defeats one of the huge advantages of the whole SQL language concept, specifically that the application programmer does not need to get involved with query planning. If you do use CROSS JOIN, wait until late in your development cycle to do so, and comment the use of CROSS JOIN carefully so that you can take it out later if possible. Avoid using CROSS JOIN early in the development cycle as doing so is a premature optimization, which is well known to be &lt;a href=&quot;http://c2.com/cgi/wiki?PrematureOptimization&quot;&gt;the root of all evil&lt;/a&gt;.</source>
          <target state="translated">尽可能避免执行此步骤，因为它破坏了整个SQL语言概念的巨大优势之一，特别是应用程序程序员无需参与查询计划。如果您确实使用了CROSS JOIN，请等到开发周期的晚些时候再使用，并仔细注释一下CROSS JOIN的用法，以便以后可以撤消。避免在开发周期的早期使用CROSS JOIN，因为这样做是过早的优化，众所周知这是&lt;a href=&quot;http://c2.com/cgi/wiki?PrematureOptimization&quot;&gt;万恶之源&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d522f897af88e992f364f85aee2e8282258fc265" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary foreign key processing in UPDATE statements that do not touch the columns that are constrained by the foreign keys.</source>
          <target state="translated">避免在UPDATE语句中进行不必要的外键处理,因为这些语句不触及被外键约束的列。</target>
        </trans-unit>
        <trans-unit id="f0262f30f0e72ef13d068b5ef0d92433c9097800" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary invalidation of &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; handles when making changes to unrelated tables.</source>
          <target state="translated">对不相关的表进行更改时，请避免不必要的&lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt;句柄无效化。</target>
        </trans-unit>
        <trans-unit id="2faf372496683418fb5422fedd49afd1602aeb2d" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary loads of columns in an aggregate query that are not within an aggregate function and that are not part of the GROUP BY clause.</source>
          <target state="translated">避免聚合查询中不必要的列负载,这些列不在聚合函数内,也不是GROUP BY子句的一部分。</target>
        </trans-unit>
        <trans-unit id="0da85f25c4d81aabb9be26649b6528ed9da5a865" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary reparsing of the database schema.</source>
          <target state="translated">避免对数据库模式进行不必要的修补。</target>
        </trans-unit>
        <trans-unit id="31ab1c695488dd1d3fd9d54bae9338af8b817457" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary writes to the sqlite_sequence table when an &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; table is updated with an rowid that is less than the maximum.</source>
          <target state="translated">当用小于最大行数的行标识更新&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;表时，避免不必要地写入sqlite_sequence表。</target>
        </trans-unit>
        <trans-unit id="446e18ff4fd4514774047f13cdefc3e3875bc4b1" translate="yes" xml:space="preserve">
          <source>Avoid using a prepared statement for &quot;.stats on&quot; command of the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; after it has been closed by the &quot;.eqp full&quot; logicc. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7be932dfa60a8a6b3b26bcf76&quot;&gt;7be932dfa60a8a6b3b26bcf76&lt;/a&gt;.</source>
          <target state="translated">在由&amp;ldquo; .eqp full&amp;rdquo;逻辑关闭后，请避免对&lt;a href=&quot;cli&quot;&gt;CLI的&lt;/a&gt; &amp;ldquo; .stats on&amp;rdquo;命令使用准备好的语句。修复票证&lt;a href=&quot;https://www.sqlite.org/src/info/7be932dfa60a8a6b3b26bcf76&quot;&gt;7be932dfa60a8a6b3b26bcf76&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e234fd1edb94740adc1207ebef38597b49b7c1f2" translate="yes" xml:space="preserve">
          <source>Avoiding the use of low-numbered file descriptors is a defense against accidental database corruption. If a database file was opened using file descriptor 2, for example, and then an assert() failed and invoked write(2,...), that would likely cause database corruption by overwriting part of the database file with the assertion error message. Using only higher-valued file descriptors avoids this potential problem. The protection against using low-numbered file descriptors can be disabled by setting this compile-time option to 0.</source>
          <target state="translated">避免使用低编号的文件描述符是对意外数据库损坏的一种防御。例如,如果使用文件描述符2打开了一个数据库文件,然后assert()失败并调用write(2,...),那么很可能会用断言错误信息覆盖部分数据库文件,从而导致数据库损坏。只使用较高值的文件描述符可以避免这个潜在的问题。可以通过将这个编译时选项设置为0来禁止使用低编号的文件描述符。</target>
        </trans-unit>
        <trans-unit id="a4253b60bc870d118d832ba2a3c8eabe133ebeb0" translate="yes" xml:space="preserve">
          <source>Aways stores polygons using the binary format, which is faster and uses less space.</source>
          <target state="translated">Aways使用二进制格式存储多边形,速度更快,占用空间更小。</target>
        </trans-unit>
        <trans-unit id="209ebb59c54866e4ac4c2bdf04c9d0b7b4a958ec" translate="yes" xml:space="preserve">
          <source>B-Tree</source>
          <target state="translated">B-Tree</target>
        </trans-unit>
        <trans-unit id="b149afb9ac3420444ce1e62aefbcdead10e7e777" translate="yes" xml:space="preserve">
          <source>B-tree</source>
          <target state="translated">B-tree</target>
        </trans-unit>
        <trans-unit id="5b87dc158f4c367648401e86eddf1c6445bb5bf6" translate="yes" xml:space="preserve">
          <source>B-tree Cell Format</source>
          <target state="translated">B树单元格格式</target>
        </trans-unit>
        <trans-unit id="92950af5441bd3255130ef7a72cc86532e49b1e9" translate="yes" xml:space="preserve">
          <source>B-tree Page Header Format</source>
          <target state="translated">B-树页头格式</target>
        </trans-unit>
        <trans-unit id="90a72ea1d2706a588dd39ad58e7cba99ec26696d" translate="yes" xml:space="preserve">
          <source>BEFORE</source>
          <target state="translated">BEFORE</target>
        </trans-unit>
        <trans-unit id="3598517c826f1480a241800ce73f781ae2b1cd6a" translate="yes" xml:space="preserve">
          <source>BEGIN</source>
          <target state="translated">BEGIN</target>
        </trans-unit>
        <trans-unit id="4821edeb87e72ffadc6bc2dd7758d1af495e515f" translate="yes" xml:space="preserve">
          <source>BEGIN IMMEDIATE</source>
          <target state="translated">BEGIN IMMEDIATE</target>
        </trans-unit>
        <trans-unit id="8913dda08c8185748e987da82c484c6d35030cb9" translate="yes" xml:space="preserve">
          <source>BEGIN TRANSACTION</source>
          <target state="translated">开始交易</target>
        </trans-unit>
        <trans-unit id="51b1b0c3e98b1211a4bf44a668731efbeb0029e7" translate="yes" xml:space="preserve">
          <source>BEGIN;</source>
          <target state="translated">BEGIN;</target>
        </trans-unit>
        <trans-unit id="f8e3370718865431368fd54f746d7da4322cc582" translate="yes" xml:space="preserve">
          <source>BETWEEN</source>
          <target state="translated">BETWEEN</target>
        </trans-unit>
        <trans-unit id="2d0fe684054a53889de74128877e23cf3189b322" translate="yes" xml:space="preserve">
          <source>BIGINT</source>
          <target state="translated">BIGINT</target>
        </trans-unit>
        <trans-unit id="d05fb01e0b399387c3a28586f5fd296e2670d6a3" translate="yes" xml:space="preserve">
          <source>BINARY</source>
          <target state="translated">BINARY</target>
        </trans-unit>
        <trans-unit id="1ce04f29dadb9973458555f164627f66e504686e" translate="yes" xml:space="preserve">
          <source>BLOB</source>
          <target state="translated">BLOB</target>
        </trans-unit>
        <trans-unit id="21ca9d91ce78c58717f1f26654ca03e2a7b624ba" translate="yes" xml:space="preserve">
          <source>BLOB (a.k.a &quot;NONE&quot;)</source>
          <target state="translated">BLOB(又名 &quot;无&quot;)</target>
        </trans-unit>
        <trans-unit id="16304f06bca682f9f5ee4a2a62fcbf2abac5ed50" translate="yes" xml:space="preserve">
          <source>BLOB literals are string literals containing hexadecimal data and preceded by a single &quot;x&quot; or &quot;X&quot; character. Example: X'53514C697465'</source>
          <target state="translated">BLOB 字符是包含十六进制数据的字符串字符,前面有一个 &quot;x &quot;或 &quot;X &quot;字符。例如:X'53514C697465' X'53514C697465'</target>
        </trans-unit>
        <trans-unit id="fb465d6672ffe8826d619cf7ad2f842e941cbb22" translate="yes" xml:space="preserve">
          <source>BLOB size</source>
          <target state="translated">BLOB尺寸</target>
        </trans-unit>
        <trans-unit id="80845ed51d0eb2f39da54fe848593b51f5b7523f" translate="yes" xml:space="preserve">
          <source>BLOB support.</source>
          <target state="translated">支持BLOB。</target>
        </trans-unit>
        <trans-unit id="9bf36d55a66f6b65f2497e6f96eb9c688f9ee788" translate="yes" xml:space="preserve">
          <source>BLOB values (even serial types 12 and larger) sort last and in the order determined by memcmp().</source>
          <target state="translated">BLOB值(即使是12和更大的序列类型)最后排序,顺序由memcmp()决定。</target>
        </trans-unit>
        <trans-unit id="066ed32331b295c453ee3f4c55916aa0d7c725b0" translate="yes" xml:space="preserve">
          <source>BLOBs sort last</source>
          <target state="translated">BLOBs排序最后</target>
        </trans-unit>
        <trans-unit id="ab68d8e893a82cff70979ba20bec0023dbfe4be3" translate="yes" xml:space="preserve">
          <source>BOOLEAN</source>
          <target state="translated">BOOLEAN</target>
        </trans-unit>
        <trans-unit id="64c3f5e89864d5e803ba483fadc3c80068321744" translate="yes" xml:space="preserve">
          <source>BY</source>
          <target state="translated">BY</target>
        </trans-unit>
        <trans-unit id="987f01f766f58cd662fc3c685393d0d4667cbc0b" translate="yes" xml:space="preserve">
          <source>Back up cursor P1 so that it points to the previous key/data pair in its table or index. If there is no previous key/value pairs then fall through to the following instruction. But if the cursor backup was successful, jump immediately to P2.</source>
          <target state="translated">倒退光标P1,使其指向表或索引中的前一个键/数据对。如果没有之前的键/值对,那么就落到下面的指令。但如果游标备份成功,则立即跳转到P2。</target>
        </trans-unit>
        <trans-unit id="f09881dbbda2f40a1bff480104e690d3c9470795" translate="yes" xml:space="preserve">
          <source>Backport a &lt;a href=&quot;https://www.sqlite.org/src/info/c648539b52ca28c0&quot;&gt;simple query planner optimization&lt;/a&gt; that allows the IS operator to drive an index on a LEFT OUTER JOIN. No other changes from the &lt;a href=&quot;#version_3_9_2&quot;&gt;version 3.9.2&lt;/a&gt; baseline.</source>
          <target state="translated">向后移植&lt;a href=&quot;https://www.sqlite.org/src/info/c648539b52ca28c0&quot;&gt;简单的查询计划程序优化&lt;/a&gt;，该优化程序允许IS操作员在LEFT OUTER JOIN上驱动索引。与&lt;a href=&quot;#version_3_9_2&quot;&gt;3.9.2版&lt;/a&gt;基准相比没有其他更改。</target>
        </trans-unit>
        <trans-unit id="88c7762ebd772cef5a8b0f5dbf885740af02d796" translate="yes" xml:space="preserve">
          <source>Backup A: &lt;a href=&quot;https://www2.sqlite.org/docsrc&quot;&gt;https://www2.sqlite.org/docsrc&lt;/a&gt;</source>
          <target state="translated">备份A：&lt;a href=&quot;https://www2.sqlite.org/docsrc&quot;&gt;https&lt;/a&gt;：//www2.sqlite.org/docsrc</target>
        </trans-unit>
        <trans-unit id="3758d4866043fb72f7921be565221b2798bf18ec" translate="yes" xml:space="preserve">
          <source>Backup A: &lt;a href=&quot;https://www2.sqlite.org/src&quot;&gt;https://www2.sqlite.org/src&lt;/a&gt;</source>
          <target state="translated">备份A：&lt;a href=&quot;https://www2.sqlite.org/src&quot;&gt;https&lt;/a&gt;：//www2.sqlite.org/src</target>
        </trans-unit>
        <trans-unit id="5635a7bbe580f297d0f1cfe698eb39a60af249f7" translate="yes" xml:space="preserve">
          <source>Backup A: &lt;a href=&quot;https://www2.sqlite.org/th3&quot;&gt;https://www2.sqlite.org/th3&lt;/a&gt;</source>
          <target state="translated">备份A：&lt;a href=&quot;https://www2.sqlite.org/th3&quot;&gt;https&lt;/a&gt;：//www2.sqlite.org/th3</target>
        </trans-unit>
        <trans-unit id="354ff6f3afacd7c64aab0b45ca232e39fd5ab191" translate="yes" xml:space="preserve">
          <source>Backup B: &lt;a href=&quot;https://www3.sqlite.org/docsrc&quot;&gt;https://www3.sqlite.org/docsrc&lt;/a&gt;</source>
          <target state="translated">备份B：&lt;a href=&quot;https://www3.sqlite.org/docsrc&quot;&gt;https&lt;/a&gt;：//www3.sqlite.org/docsrc</target>
        </trans-unit>
        <trans-unit id="a437cf7f4394ac5ab3c8c6bf1f4decbf817f299c" translate="yes" xml:space="preserve">
          <source>Backup B: &lt;a href=&quot;https://www3.sqlite.org/src&quot;&gt;https://www3.sqlite.org/src&lt;/a&gt;</source>
          <target state="translated">备份B：&lt;a href=&quot;https://www3.sqlite.org/src&quot;&gt;https&lt;/a&gt;：//www3.sqlite.org/src</target>
        </trans-unit>
        <trans-unit id="06b0bc099757fb937c2145628c4ebe2caf89fed6" translate="yes" xml:space="preserve">
          <source>Backup B: &lt;a href=&quot;https://www3.sqlite.org/th3&quot;&gt;https://www3.sqlite.org/th3&lt;/a&gt;</source>
          <target state="translated">备份B：&lt;a href=&quot;https://www3.sqlite.org/th3&quot;&gt;https&lt;/a&gt;：//www3.sqlite.org/th3</target>
        </trans-unit>
        <trans-unit id="ad652023d4f99d0238bf9d42108eaead0a853d3a" translate="yes" xml:space="preserve">
          <source>Backup-filename</source>
          <target state="translated">Backup-filename</target>
        </trans-unit>
        <trans-unit id="8999e5aefef2d471c86fa4aebf649d22b2fddfc3" translate="yes" xml:space="preserve">
          <source>Backups on private servers</source>
          <target state="translated">私人服务器上的备份</target>
        </trans-unit>
        <trans-unit id="63591d4f03e6c8c8462a238e710f0f3cd900691f" translate="yes" xml:space="preserve">
          <source>Backwards compatibility constraints mean that SQLite is only able to store values that are NULL, integers, floating-point numbers, text, and BLOBs. It is not possible to add a sixth &quot;JSON&quot; type.</source>
          <target state="translated">向后兼容的限制意味着SQLite只能存储NULL、整数、浮点数、文本和BLOBs的值。不可能增加第六种 &quot;JSON &quot;类型。</target>
        </trans-unit>
        <trans-unit id="ac8e908309343005a016d54d23589bde15362521" translate="yes" xml:space="preserve">
          <source>Backwards compatibility note:</source>
          <target state="translated">向后兼容性说明。</target>
        </trans-unit>
        <trans-unit id="70457c51de59bc0303eae7ef527e14f90b80a187" translate="yes" xml:space="preserve">
          <source>Backwards-incompatible changes to some extensions in order to take advantage of the improved security offered by the new &lt;a href=&quot;bindptr&quot;&gt;pointer passing interfaces&lt;/a&gt;:</source>
          <target state="translated">对某些扩展的向后不兼容更改，以利用新的&lt;a href=&quot;bindptr&quot;&gt;指针传递接口&lt;/a&gt;提供的改进的安全性：</target>
        </trans-unit>
        <trans-unit id="af928fbbb6d75554958505ba9734eca9710f8051" translate="yes" xml:space="preserve">
          <source>Bad programmers worry about the code. Good programmers worry about data structures and their relationships.</source>
          <target state="translated">坏的程序员担心的是代码。好的程序员担心的是数据结构及其关系。</target>
        </trans-unit>
        <trans-unit id="d97ded08ec4df20e52b3ce05668bb0a2705fa978" translate="yes" xml:space="preserve">
          <source>Bare aggregate terms</source>
          <target state="translated">裸露的合计条款</target>
        </trans-unit>
        <trans-unit id="5e2b9b9d48fdc95bbb5af1e6353dd4395e3738d9" translate="yes" xml:space="preserve">
          <source>Based on the above, SQLite is designed around a model of the file-system whereby any sector of a file written to is considered to be in a transient state until after the file has been successfully</source>
          <target state="translated">基于上述,SQLite是围绕着文件系统的模型设计的,在文件被成功写入之前,文件的任何扇区都被认为是处于短暂的状态。</target>
        </trans-unit>
        <trans-unit id="2843b17c6eb4616657b580040fb118c722f6edb6" translate="yes" xml:space="preserve">
          <source>Be a help in times of trouble.</source>
          <target state="translated">在困难的时候做个帮手。</target>
        </trans-unit>
        <trans-unit id="d1a6a5570deb3a7eb7ea55daa060ee1c39dbe74c" translate="yes" xml:space="preserve">
          <source>Be a stranger to the world's ways.</source>
          <target state="translated">做一个不谙世事的人。</target>
        </trans-unit>
        <trans-unit id="7fe99077b2a420989db9a6580456c2197461f868" translate="yes" xml:space="preserve">
          <source>Be careful when using the &quot;.save&quot; command as it will overwrite any preexisting database files having the same name without prompting for confirmation. As with the &quot;.open&quot; command, you might want to use a full pathname with forward-slash directory separators to avoid ambiguity.</source>
          <target state="translated">使用&quot;.save &quot;命令时要小心,因为它将覆盖任何具有相同名称的现有数据库文件,而不会提示确认。和&quot;.open &quot;命令一样,你可能需要使用一个完整的路径名,并使用正斜线目录分隔符来避免歧义。</target>
        </trans-unit>
        <trans-unit id="131acb5be798f8713c6bbeeaf8a6813dbe81748d" translate="yes" xml:space="preserve">
          <source>Be in dread of hell.</source>
          <target state="translated">要对地狱有恐惧感。</target>
        </trans-unit>
        <trans-unit id="dbdb220ba30f3bde62d258265aacea82a8c9ef6a" translate="yes" xml:space="preserve">
          <source>Be not a detractor.</source>
          <target state="translated">不做损友。</target>
        </trans-unit>
        <trans-unit id="d18586b20264d29baf4b88bd2bdc140f64986d83" translate="yes" xml:space="preserve">
          <source>Be not a great eater.</source>
          <target state="translated">要不就是个大吃货。</target>
        </trans-unit>
        <trans-unit id="7c62076277d9f6b2639631bb528912ff4eff4ffa" translate="yes" xml:space="preserve">
          <source>Be not a grumbler.</source>
          <target state="translated">不要怨天尤人。</target>
        </trans-unit>
        <trans-unit id="288a450b2fc66179cb51c9c9d0a00b7f03fc2121" translate="yes" xml:space="preserve">
          <source>Be not addicted to wine.</source>
          <target state="translated">要不沉迷于酒。</target>
        </trans-unit>
        <trans-unit id="30d66a95d2dfd76a1e01a40e31a7daa8f6db0117" translate="yes" xml:space="preserve">
          <source>Be not drowsy.</source>
          <target state="translated">不要昏昏欲睡。</target>
        </trans-unit>
        <trans-unit id="c8f81046cf302e1b08a651f45ee31005254461af" translate="yes" xml:space="preserve">
          <source>Be not jealous, nor harbor envy.</source>
          <target state="translated">不要嫉妒,也不要怀有妒忌之心。</target>
        </trans-unit>
        <trans-unit id="6f5bf647a944160204f29d66b6480eda5640fcdc" translate="yes" xml:space="preserve">
          <source>Be not lazy.</source>
          <target state="translated">不要偷懒。</target>
        </trans-unit>
        <trans-unit id="1c899d6734a837258800bab2a2f7343b95199829" translate="yes" xml:space="preserve">
          <source>Be not proud.</source>
          <target state="translated">不要骄傲</target>
        </trans-unit>
        <trans-unit id="9305ebf69b60c3d882da16805b530bbf3e6f3d95" translate="yes" xml:space="preserve">
          <source>Bear persecution for justice's sake.</source>
          <target state="translated">为了正义而承受迫害。</target>
        </trans-unit>
        <trans-unit id="6ca5c28c37834244df00d49b68c2bef2606b1e1f" translate="yes" xml:space="preserve">
          <source>Because &quot;text&quot; columns have a different sort order from numeric, indices on &quot;text&quot; columns occur in a different order for version 2.7.0 and later database. Hence version 2.6.3 and earlier of SQLite will be unable to read a 2.7.0 or later database. But version 2.7.0 and later of SQLite will read earlier databases.</source>
          <target state="translated">由于 &quot;文本 &quot;列与数字列的排序顺序不同,2.7.0版本及以后版本的数据库在 &quot;文本 &quot;列上的索引顺序不同,因此,2.6.3及以前版本的SQLite将无法读取2.7.0或以后版本的数据库。因此,2.6.3及以前版本的SQLite将无法读取2.7.0或更高版本的数据库。但2.7.0及以后版本的SQLite可以读取早期的数据库。</target>
        </trans-unit>
        <trans-unit id="85eeb52404350645676cc7b1bb211e4acfd5ad5b" translate="yes" xml:space="preserve">
          <source>Because AUTOINCREMENT keyword changes the behavior of the ROWID selection algorithm, AUTOINCREMENT is not allowed on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables or on any table column other than INTEGER PRIMARY KEY. Any attempt to use AUTOINCREMENT on a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table or on a column other than the INTEGER PRIMARY KEY column results in an error.</source>
          <target state="translated">由于AUTOINCREMENT关键字更改了ROWID选择算法的行为，因此，在&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表或INTEGER PRIMARY KEY以外的任何表列上均不允许使用AUTOINCREMENT 。任何在&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表或INTEGER PRIMARY KEY列以外的列上使用AUTOINCREMENT的尝试都将导致错误。</target>
        </trans-unit>
        <trans-unit id="eeb868502c2d293980db003c26a1d7e59cde0343" translate="yes" xml:space="preserve">
          <source>Because FTS3 and FTS4 are virtual tables, The &lt;a href=&quot;compile#enable_fts3&quot;&gt;SQLITE_ENABLE_FTS3&lt;/a&gt; compile-time option is incompatible with the &lt;a href=&quot;compile#omit_virtualtable&quot;&gt;SQLITE_OMIT_VIRTUALTABLE&lt;/a&gt; option.</source>
          <target state="translated">由于FTS3和FTS4是虚拟表，因此&lt;a href=&quot;compile#enable_fts3&quot;&gt;SQLITE_ENABLE_FTS3&lt;/a&gt;编译时选项与&lt;a href=&quot;compile#omit_virtualtable&quot;&gt;SQLITE_OMIT_VIRTUALTABLE&lt;/a&gt;选项不兼容。</target>
        </trans-unit>
        <trans-unit id="4912d0649aa9ed8b2a285af375de29c2823b504b" translate="yes" xml:space="preserve">
          <source>Because Lemon is a program not normally found on development machines, the complete source code to Lemon (just one C file) is included in the SQLite distribution in the &quot;tool&quot; subdirectory.</source>
          <target state="translated">由于Lemon是一个在开发机器上不常见的程序,所以在SQLite发行版的 &quot;工具 &quot;子目录中包含了Lemon的完整源代码(只有一个C文件)。</target>
        </trans-unit>
        <trans-unit id="c877f3293b1082ca722e1e4a350d52f335812101" translate="yes" xml:space="preserve">
          <source>Because SQLite is flexible and forgiving with regard to datatypes, table columns can be created that have no specified datatype at all. For example:</source>
          <target state="translated">因为SQLite在数据类型方面是灵活和宽容的,所以可以创建完全没有指定数据类型的表列。比如说</target>
        </trans-unit>
        <trans-unit id="89b4ac6aceecf052168be7879566274bb4b65047" translate="yes" xml:space="preserve">
          <source>Because ZIP archives are optimized for storing big chunks of content, they encourage a style of programming where the entire document is read into memory at startup, all editing occurs in memory, then the entire document is written to disk during &quot;File/Save&quot;. OpenOffice and its descendants embrace that pattern.</source>
          <target state="translated">因为ZIP档案是为存储大块内容而优化的,它们鼓励一种编程风格,即整个文档在启动时被读入内存,所有的编辑都发生在内存中,然后在 &quot;文件/保存 &quot;期间将整个文档写入磁盘。OpenOffice和它的后代都接受了这种模式。</target>
        </trans-unit>
        <trans-unit id="1aef204394eb2f42a054518ac1383e25f6308e7c" translate="yes" xml:space="preserve">
          <source>Because allocations are all the same size, the memory allocator can operate much faster. The allocator need not bother with coalescing adjacent free slots or searching for a slot of an appropriate size. All unallocated memory slots can be stored on a linked list. Allocating consists of removing the first entry from the list. Deallocating is simply adding an entry to the beginning of the list.</source>
          <target state="translated">由于分配的大小都是一样的,所以内存分配器可以更快地运行。分配器不需要费心去凝聚相邻的空闲插槽,也不需要搜索一个适当大小的插槽。所有未分配的内存插槽都可以存储在一个链接列表上。分配包括从列表中删除第一个条目。Deallocating是简单地在列表的开头添加一个条目。</target>
        </trans-unit>
        <trans-unit id="8fe792a90bccd6800bd67f3f37ebbaabb1467610" translate="yes" xml:space="preserve">
          <source>Because an SQLite database is a single compact file in a &lt;a href=&quot;fileformat2&quot;&gt;well-defined cross-platform format&lt;/a&gt;, it is often used as a container for transferring content from one system to another. The sender gathers content into an SQLite database file, transfers that one file to the receiver, then the receiver uses SQL to extract the content as needed.</source>
          <target state="translated">由于SQLite数据库是具有&lt;a href=&quot;fileformat2&quot;&gt;定义良好的跨平台格式&lt;/a&gt;的单个压缩文件，因此它通常用作将内容从一个系统传输到另一个系统的容器。发送方将内容收集到一个SQLite数据库文件中，将该文件传输到接收方，然后接收方根据需要使用SQL提取内容。</target>
        </trans-unit>
        <trans-unit id="a4c1f92dc828402b18e6e117bb816b40d1c734ed" translate="yes" xml:space="preserve">
          <source>Because an SQLite database requires no administration, it works well in devices that must operate without expert human support. SQLite is a good fit for use in cellphones, set-top boxes, televisions, game consoles, cameras, watches, kitchen appliances, thermostats, automobiles, machine tools, airplanes, remote sensors, drones, medical devices, and robots: the &quot;internet of things&quot;.</source>
          <target state="translated">因为SQLite数据库不需要管理,所以它在那些必须在没有专家支持的情况下进行操作的设备中效果很好。SQLite非常适合用于手机、机顶盒、电视、游戏机、相机、手表、厨房电器、恒温器、汽车、机床、飞机、远程传感器、无人机、医疗设备和机器人:&quot;物联网&quot;。</target>
        </trans-unit>
        <trans-unit id="788be5cf964c9ee21f08ece0ea7377ef2e19234d" translate="yes" xml:space="preserve">
          <source>Because assert() can be and is commonly misused, some programming language theorists and designers look upon it with disfavor. For example, the designers of the &lt;a href=&quot;https://golang.org&quot;&gt;Go programming language&lt;/a&gt; intentionally &lt;a href=&quot;https://golang.org/doc/faq#assertions&quot;&gt;omit a built-in assert()&lt;/a&gt;. They feel that the harm caused by misuse of assert() outweighs the benefits of including it as a language built-in. The SQLite developers disagree. In fact, the original purpose of this article is to push back against the common notion that assert() is harmful. In our experience, SQLite would be much more difficult to develop, test, and maintain without assert().</source>
          <target state="translated">因为assert（）可以并且通常被滥用，所以一些编程语言理论家和设计人员不赞成使用它。例如，&lt;a href=&quot;https://golang.org&quot;&gt;Go编程语言&lt;/a&gt;的设计者有意&lt;a href=&quot;https://golang.org/doc/faq#assertions&quot;&gt;省略了内置的assert（）&lt;/a&gt;。他们认为滥用assert（）所造成的危害超过了将其作为内置语言包含在内的好处。 SQLite开发人员不同意。实际上，本文的最初目的是推翻assert（）是有害的这一普遍观念。根据我们的经验，如果没有assert（），SQLite的开发，测试和维护将更加困难。</target>
        </trans-unit>
        <trans-unit id="a6c8b76107dc390feb365087dd23a9e6847d8ec8" translate="yes" xml:space="preserve">
          <source>Because it does not have a central server to coordinate access, SQLite must close and reopen the database file, and thus invalidate its cache, for each transaction. In this test, each SQL statement is a separate transaction so the database file must be opened and closed and the cache must be flushed 1000 times. In spite of this, the asynchronous version of SQLite is still nearly as fast as MySQL. Notice how much slower the synchronous version is, however. SQLite calls &lt;b&gt;fsync()&lt;/b&gt; after each synchronous transaction to make sure that all data is safely on the disk surface before continuing. For most of the 13 seconds in the synchronous test, SQLite was sitting idle waiting on disk I/O to complete.</source>
          <target state="translated">因为它没有中央服务器来协调访问，所以SQLite必须关闭并重新打开数据库文件，从而使每个事务的缓存均无效。在此测试中，每个SQL语句都是一个单独的事务，因此必须打开和关闭数据库文件，并且必须将缓存刷新1000次。尽管如此，SQLite的异步版本仍然几乎与MySQL一样快。请注意，同步版本的速度要慢得多。 SQLite 在每个同步事务之后调用&lt;b&gt;fsync（）&lt;/b&gt;，以确保在继续操作之前所有数据都安全地位于磁盘表面上。在同步测试的13秒钟的大部分时间内，SQLite处于空闲状态，等待磁盘I / O完成。</target>
        </trans-unit>
        <trans-unit id="44c3dab6a322e3be0dd40f52ec50b7f7abadf611" translate="yes" xml:space="preserve">
          <source>Because it is a simulator, running a binary in Valgrind is slower than running it on native hardware. (To a first approximation, an application running in Valgrind on a workstation will perform about the same as it would running natively on a smartphone.) So it is impractical to run the full SQLite test suite through Valgrind. However, the veryquick tests and the coverage of the TH3 tests are run through Valgrind prior to every release.</source>
          <target state="translated">因为它是一个模拟器,在Valgrind中运行二进制文件比在本地硬件上运行要慢。(据初步估算,在工作站上运行Valgrind中的应用程序与在智能手机上运行原生应用程序的性能差不多)。因此,通过Valgrind运行完整的SQLite测试套件是不切实际的。然而,非常快速的测试和TH3测试的覆盖范围在每次发布之前都会通过Valgrind运行。</target>
        </trans-unit>
        <trans-unit id="2d7f244d51b1fc8bd92e3755f3ff4412ae2f2b57" translate="yes" xml:space="preserve">
          <source>Because it is simple to setup and use (installation is trivial: just copy the &lt;b&gt;sqlite3&lt;/b&gt; or &lt;b&gt;sqlite3.exe&lt;/b&gt; executable to the target machine and run it) SQLite makes a good database engine for use in teaching SQL. Students can easily create as many databases as they like and can email databases to the instructor for comments or grading. For more advanced students who are interested in studying how an RDBMS is implemented, the modular and well-commented and documented SQLite code can serve as a good basis.</source>
          <target state="translated">因为它易于设置和使用（安装非常简单：只需将&lt;b&gt;sqlite3&lt;/b&gt;或&lt;b&gt;sqlite3.exe&lt;/b&gt;可执行文件复制到目标计算机上并运行它），SQLite成为了一个很好的数据库引擎，可用于教授SQL。学生可以轻松地创建任意数量的数据库，并可以通过电子邮件将数据库发送给教师以进行评论或评分。对于对研究RDBMS的实现方式感兴趣的更高级的学生，模块化的，注释明确的和记录在案的SQLite代码可以作为良好的基础。</target>
        </trans-unit>
        <trans-unit id="4f8ea41ffd9236f49c6f3b48d5813c7ba03da82f" translate="yes" xml:space="preserve">
          <source>Because it reorganizes the entire FTS index, the optimize command can take a long time to run. The &lt;a href=&quot;fts5#the_merge_command&quot;&gt;FTS5 merge command&lt;/a&gt; can be used to divide the work of optimizing the FTS index into multiple steps. To do this:</source>
          <target state="translated">由于它重组了整个FTS索引，因此优化命令可能需要很长时间才能运行。所述&lt;a href=&quot;fts5#the_merge_command&quot;&gt;FTS5合并命令&lt;/a&gt;可以用来划分优化FTS索引成多个步骤的工作。去做这个：</target>
        </trans-unit>
        <trans-unit id="444393da5087c1cdc4456d5a26de8bf63b917b08" translate="yes" xml:space="preserve">
          <source>Because it stores extra information on disk in two new &lt;a href=&quot;fts3#*shadowtab&quot;&gt;shadow tables&lt;/a&gt; in order to support the performance optimizations and extra matchinfo() options, FTS4 tables may consume more disk space than the equivalent table created using FTS3. Usually the overhead is 1-2% or less, but may be as high as 10% if the documents stored in the FTS table are very small. The overhead may be reduced by specifying the directive &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;&quot;matchinfo=fts3&quot;&lt;/a&gt; as part of the FTS4 table declaration, but this comes at the expense of sacrificing some of the extra supported matchinfo() options.</source>
          <target state="translated">因为FTS4表将额外的信息存储在两个新的&lt;a href=&quot;fts3#*shadowtab&quot;&gt;影子表&lt;/a&gt;中的磁盘上以支持性能优化和额外的matchinfo（）选项，所以与使用FTS3创建的等效表相比，FTS4表可能消耗更多的磁盘空间。通常，开销为1-2％或更少，但是如果FTS表中存储的文档非常小，则开销可能高达10％。通过在FTS4表声明中指定指令&lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;&amp;ldquo; matchinfo = fts3&amp;rdquo;&lt;/a&gt;可以减少开销，但这是以牺牲某些额外支持的matchinfo（）选项为代价的。</target>
        </trans-unit>
        <trans-unit id="c9b96b15368e6c99132d7d8a67a04e723712af54" translate="yes" xml:space="preserve">
          <source>Because lookaside allocations are always the same size, the allocation and deallocation algorithms are very quick. There is no need to coalesce adjacent free slots or search for a slot of a particular size. Each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; maintains a singly-linked list of unused slots. Allocation requests simply pull the first element of this list. Deallocations simply push the element back onto the front of the list. Furthermore, each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is assumed to already be running in a single thread (there are mutexes already in place to enforce this) so no additional mutexing is required to serialize access to the lookaside slot freelist. Consequently, lookaside memory allocations and deallocations are very fast. In speed tests on Linux and Mac OS X workstations, SQLite has shown overall performance improvements as high as 10% and 15%, depending on the workload how and lookaside is configured.</source>
          <target state="translated">由于后备分配的大小始终相同，因此分配和释放算法很快。无需合并相邻的空闲插槽或搜索特定大小的插槽。每个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;维护一个未使用插槽的单链接列表。分配请求只是拉出该列表的第一个元素。取消分配只是将元素推回列表的前面。此外，每个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;假定已经在单个线程中运行（已经存在强制执行此操作的互斥锁），因此不需要其他的互斥即可序列化对后备插槽空闲列表的访问。因此，后备内存分配和释放非常快。在Linux和Mac OS X工作站上的速度测试中，SQLite已将总体性能提高了10％和15％，具体取决于工作负载的配置方式和后备方式。</target>
        </trans-unit>
        <trans-unit id="668e105a1044bfeea3b1760bf6f04ba2a54183c0" translate="yes" xml:space="preserve">
          <source>Because main-memory is a limited resource, the</source>
          <target state="translated">由于主内存是一种有限的资源,所以</target>
        </trans-unit>
        <trans-unit id="fdc0f2ea6af2e7d5aa2876f1718288d4bc691129" translate="yes" xml:space="preserve">
          <source>Because of continuing security concerns, the two-argument version of of the seldom-used and little-known &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; function is disabled unless SQLite is compiled with the &lt;a href=&quot;compile#enable_fts3_tokenizer&quot;&gt;SQLITE_ENABLE_FTS3_TOKENIZER&lt;/a&gt;.</source>
          <target state="translated">由于持续的安全问题，除非使用&lt;a href=&quot;compile#enable_fts3_tokenizer&quot;&gt;SQLITE_ENABLE_FTS3_TOKENIZER&lt;/a&gt;编译SQLite，否则将禁用很少使用且鲜为人知的&lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer（）&lt;/a&gt;函数的两个参数版本。</target>
        </trans-unit>
        <trans-unit id="f16662c44c98100b991163c6c6a9a2f0174c0613" translate="yes" xml:space="preserve">
          <source>Because of its past success, AFL became a standard part of the testing strategy for SQLite beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_8_10.html&quot;&gt;version 3.8.10&lt;/a&gt; (2015-05-07) until it was superseded by better fuzzers in &lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;version 3.29.0&lt;/a&gt; (2019-07-10).</source>
          <target state="translated">由于过去的成功，AFL从&lt;a href=&quot;https://sqlite.org/releaselog/3_8_10.html&quot;&gt;3.8.10&lt;/a&gt;（2015-05-07）版本开始成为SQLite测试策略的标准部分，直到被&lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;3.29.0&lt;/a&gt;（2019-07-10）版本中更好的模糊测试所取代。</target>
        </trans-unit>
        <trans-unit id="70e6d86d9770a8829aec592e59f4248ba67ce358" translate="yes" xml:space="preserve">
          <source>Because of its past success, AFL became a standard part of the testing strategy for SQLite beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_8_10.html&quot;&gt;version 3.8.10&lt;/a&gt; (2015-05-07). Both SQL statements and database files are fuzzed. Billions and billions of mutations have been tried, but AFL's instrumentation has narrowed them down to less than 50,000 test cases that cover all distinct behaviors. Newly discovered test cases are periodically captured and added to the &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt; where they can be rerun using the &quot;make fuzztest&quot; or &quot;make valgrindfuzz&quot; commands.</source>
          <target state="translated">由于其过去的成功，AFL从&lt;a href=&quot;https://sqlite.org/releaselog/3_8_10.html&quot;&gt;3.8.10版本&lt;/a&gt;（2015-05-07）开始成为SQLite测试策略的标准部分。 SQL语句和数据库文件都模糊不清。已经尝试了数十亿个突变，但是AFL的检测手段将其范围缩小到了50,000个以下的测试案例，这些案例涵盖了所有不同的行为。定期捕获新发现的测试用例，并将其添加到&lt;a href=&quot;testing#tcl&quot;&gt;TCL测试套件中&lt;/a&gt;，在其中可以使用&amp;ldquo; make fuzztest&amp;rdquo;或&amp;ldquo; make valgrindfuzz&amp;rdquo;命令重新运行它们。</target>
        </trans-unit>
        <trans-unit id="35a2bab974445beaebfdcb0d2e216e6aab6976e2" translate="yes" xml:space="preserve">
          <source>Because of security concerns, the two-argument fts3_tokenizer() feature was disabled beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;Version 3.11.0&lt;/a&gt; (2016-02-15) unless this compile-time option is used. &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;Version 3.12.0&lt;/a&gt; (2016-03-29) added the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;,1,0) interface that activates the two-argument version of &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; for a specific &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; at run-time.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;出于&lt;/a&gt;安全考虑，除非使用此编译时选项，否则从版本3.11.0（2016-02-15）开始禁用具有两个参数的fts3_tokenizer（）功能。&lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;版本3.12.0&lt;/a&gt;（2016-03-29）添加了&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;，1,0）接口，该&lt;a href=&quot;c3ref/sqlite3&quot;&gt;接口&lt;/a&gt;在运行时为特定数据库连接激活&lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer（）&lt;/a&gt;的两个参数版本。</target>
        </trans-unit>
        <trans-unit id="90667c0d2f4c3f9e700d1a02bf683d36a408bbd8" translate="yes" xml:space="preserve">
          <source>Because of the behaviors described above, programmers are encouraged to prefer AFTER triggers over BEFORE triggers.</source>
          <target state="translated">由于上述行为,我们鼓励程序员优先选择AFTER触发器而不是BEFORE触发器。</target>
        </trans-unit>
        <trans-unit id="428b411cc0640abd27f1cf3a950377d2c4b5358f" translate="yes" xml:space="preserve">
          <source>Because of the potential disadvantages, memory-mapped I/O is disabled by default. To activate memory-mapped I/O, use the &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;mmap_size pragma&lt;/a&gt; and set the mmap_size to some large number, usually 256MB or larger, depending on how much address space your application can spare. The rest is automatic. The &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; statement will be a silent no-op on systems that do not support memory-mapped I/O.</source>
          <target state="translated">由于潜在的缺点，默认情况下禁用内存映射的I / O。要激活内存映射的I / O，请使用&lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;mmap_size编译指示&lt;/a&gt;并将mmap_size设置为一个较大的数字，通常为256MB或更大，具体取决于应用程序可以保留多少地址空间。其余的是自动的。该&lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;声明将是不支持的系统无声无操作内存映射I / O。</target>
        </trans-unit>
        <trans-unit id="3b4a67ca1996129326c7f0bddce34637e22bf4f7" translate="yes" xml:space="preserve">
          <source>Because of these advantages, SQLite always tries to do a partial sort using an index even if a complete sort by index is not possible.</source>
          <target state="translated">由于这些优点,即使无法通过索引进行完全排序,SQLite也总是尝试使用索引进行部分排序。</target>
        </trans-unit>
        <trans-unit id="0aff0a8b5eb6e0fbec96bd0626840af7bfdbee19" translate="yes" xml:space="preserve">
          <source>Because resetting a database is destructive and irreversible, the process requires the use of this obscure API and multiple steps to help ensure that it does not happen by accident.</source>
          <target state="translated">因为重置数据库是具有破坏性和不可逆的,这个过程需要使用这个晦涩的API和多个步骤来帮助确保它不会发生意外。</target>
        </trans-unit>
        <trans-unit id="6b538eb844bddf9ea8a5b9a11872b1b61bfa979d" translate="yes" xml:space="preserve">
          <source>Because sorting can be expensive, SQLite works hard to convert ORDER BY clauses into no-ops. If SQLite determines that output will naturally appear in the order specified, then no sorting is done. So, for example, if you request the output in rowid order, no sorting will be done:</source>
          <target state="translated">因为排序的成本很高,所以SQLite努力将order by子句转换为无操作。如果SQLite确定输出将自然地按照指定的顺序出现,那么就不会进行排序。所以,例如,如果你要求输出按rowid顺序排列,就不会进行排序。</target>
        </trans-unit>
        <trans-unit id="b9e05ab9d98b3cd637f9791d810eeb3b04a00c42" translate="yes" xml:space="preserve">
          <source>Because the SQLite developers do not know whether the SQLITE_ENABLE_SORTER_REFERENCES option will help or hurt performance, it is disabled by default at this time (2018-05-04). It might be enabled by default in some future release, depending on what is learned about its impact on performance.</source>
          <target state="translated">由于SQLite开发人员不知道SQLITE_ENABLE_SORTER_REFERENCES选项对性能是有帮助还是有伤害,所以目前默认将其禁用(2018-05-04)。它可能会在未来的某个版本中默认启用,这取决于了解到的它对性能的影响。</target>
        </trans-unit>
        <trans-unit id="15ba7f227189763df8625f3bee22f683d880802a" translate="yes" xml:space="preserve">
          <source>Because the completion table is built into the command-line shell in order to provide for tab-completions, you can run test queries against the completion table directly in the command-line shell. Simply type a query such as the example shown above, filling in appropriate values for $prefix and $wholeline, and observe the output.</source>
          <target state="translated">因为完成表是建立在命令行shell中的,以便提供tab-completions,你可以直接在命令行shell中对完成表运行测试查询。简单地键入一个查询,如上图所示,为$prefix和$wholeline填入适当的值,然后观察输出。</target>
        </trans-unit>
        <trans-unit id="a8514da27bd50380cff29e01b5a61eb7772e130b" translate="yes" xml:space="preserve">
          <source>Because the content of leaf freelist pages is unimportant, SQLite avoids storing leaf freelist page content in the rollback journal in &lt;a href=&quot;#section_3_5&quot;&gt;step 3.5&lt;/a&gt; of the commit process. If a leaf freelist page is changed and that change does not get rolled back during a transaction recovery, the database is not harmed by the omission. Similarly, the content of a new freelist page is never written back into the database at &lt;a href=&quot;#section_3_9&quot;&gt;step 3.9&lt;/a&gt; nor read from the database at &lt;a href=&quot;#section_3_3&quot;&gt;step 3.3&lt;/a&gt;. These optimizations can greatly reduce the amount of I/O that occurs when making changes to a database file that contains free space.</source>
          <target state="translated">由于叶子自由列表页面的内容并不重要，因此SQLite避免在提交过程的&lt;a href=&quot;#section_3_5&quot;&gt;步骤3.5&lt;/a&gt;中将叶子自由列表页面的内容存储在回滚日志中。如果叶子自由列表页面已更改，并且在事务恢复期间该更改未回滚，则该数据库不会受到遗漏的损害。类似地，新的自由列表页面的内容在&lt;a href=&quot;#section_3_9&quot;&gt;步骤3.9&lt;/a&gt;永远不会写回到数据库中，也不会在&lt;a href=&quot;#section_3_3&quot;&gt;步骤3.3&lt;/a&gt;从数据库中读取。这些优化可以极大地减少对包含可用空间的数据库文件进行更改时发生的I / O数量。</target>
        </trans-unit>
        <trans-unit id="e09f5109878254b678ca47d639d75e4bf226a1da" translate="yes" xml:space="preserve">
          <source>Because the indexed documents themselves are usually much larger than the full-text index, the content option can be used to achieve significant space savings.</source>
          <target state="translated">由于索引的文档本身通常比全文索引大得多,因此使用内容选项可以大大节省空间。</target>
        </trans-unit>
        <trans-unit id="761cb8246ba69558ca8aeb80b8dbab8c62f5efed" translate="yes" xml:space="preserve">
          <source>Because the left-most column of the index does not appear in the WHERE clause of the query, one is tempted to conclude that the index is not usable here. But SQLite is able to use the index. Conceptually, SQLite uses the index as if the query were more like the following:</source>
          <target state="translated">由于索引最左边的列没有出现在查询的WHERE子句中,人们很容易得出索引在这里无法使用的结论。但是,SQLite是能够使用索引的。从概念上讲,SQLite使用索引的方式,就好比查询更像下面这样。</target>
        </trans-unit>
        <trans-unit id="927d6c5d36abace655d9d18c0cd78a8cd301ca2d" translate="yes" xml:space="preserve">
          <source>Because the left-most column of the index does not appear in the WHERE clause of the query, one is tempted to conclude that the index is not usable here. However, SQLite is able to use the index. Conceptually, SQLite uses the index as if the query were more like the following:</source>
          <target state="translated">因为索引最左边的列没有出现在查询的WHERE子句中,人们很容易得出索引在这里不能使用的结论。然而,SQLite是能够使用索引的。从概念上讲,SQLite使用索引的方式,就好比查询更像下面这样。</target>
        </trans-unit>
        <trans-unit id="d3bc49abdbbec51c89e15d286d4a875e6d32447c" translate="yes" xml:space="preserve">
          <source>Because the name of the schema table does not appear anywhere in the file format, the meaning of the database file is not changed if the application chooses to refer to the schema table by one of these alternative names.</source>
          <target state="translated">因为模式表的名称没有出现在文件格式的任何地方,所以如果应用程序选择用这些替代名称之一来引用模式表,数据库文件的含义不会改变。</target>
        </trans-unit>
        <trans-unit id="a128485eb3a76806acc833997f2bb0ca8f3bab85" translate="yes" xml:space="preserve">
          <source>Because the non-primary key &quot;old.*&quot; fields are omitted, no SQLITE_CHANGESET_DATA conflicts can be detected or reported if a patchset is passed to the sqlite3changeset_apply() API. Other conflict types work in the same way as for changesets.</source>
          <target state="translated">因为省略了非主键 &quot;old.*&quot;字段,所以如果补丁集被传递给 sqlite3changeset_apply()API,则不能检测或报告 SQLITE_CHANGESET_DATA 冲突。其他冲突类型的工作方式与改变集相同。</target>
        </trans-unit>
        <trans-unit id="2e558ba54b31e234aa1a29ff45d5a07a13c1806f" translate="yes" xml:space="preserve">
          <source>Because the pointer is passed in the t1 column of the t1 table as a BLOB (in older versions of SQLite), such a query would have shown the value of the pointer in hex. The attacker could then modify that pointer to try to get the snippet() function to modify memory in some other part of the application address space instead of the fts3cursor object it was supposed to be operating on:</source>
          <target state="translated">由于指针在t1表的t1列中以BLOB的形式传递(在SQLite的旧版本中),这样的查询会以十六进制显示指针的值。然后,攻击者可以修改该指针,试图让snippet()函数修改应用程序地址空间的其他部分的内存,而不是它应该操作的fts3cursor对象。</target>
        </trans-unit>
        <trans-unit id="72ea5223eef09f4a78746e1785e07a1242a94565" translate="yes" xml:space="preserve">
          <source>Because the same query could be written without the use of row values, row values do not provide new capabilities. However, many developers say that the row value format is easier to read, write, and debug.</source>
          <target state="translated">因为不使用行值也可以编写同样的查询,所以行值并没有提供新的功能。然而,许多开发人员表示,行值格式更容易读、写和调试。</target>
        </trans-unit>
        <trans-unit id="fc8629347e97d2900d75943390265d789337dab5" translate="yes" xml:space="preserve">
          <source>Because the session module uses the &lt;a href=&quot;../c3ref/preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; API, it is not possible for an application to register a pre-update hook on a database handle that has one or more session objects attached. Nor is it possible to create a session object attached to a database handle for which a pre-update hook is already defined. The results of attempting either of these things are undefined.</source>
          <target state="translated">由于会话模块使用&lt;a href=&quot;../c3ref/preupdate_count&quot;&gt;sqlite3_preupdate_hook（）&lt;/a&gt; API，因此应用程序无法在连接了一个或多个会话对象的数据库句柄上注册更新前挂钩。也无法创建连接到数据库句柄的会话对象，该会话对象已为其定义了更新前挂钩。尝试这些操作之一的结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="2d755c27985069d9c58f3f925b7f20c86ab3fc1d" translate="yes" xml:space="preserve">
          <source>Because the session module uses the &lt;a href=&quot;c3ref/preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; API, it is not possible for an application to register a pre-update hook on a database handle that has one or more session objects attached. Nor is it possible to create a session object attached to a database handle for which a pre-update hook is already defined. The results of attempting either of these things are undefined.</source>
          <target state="translated">由于会话模块使用&lt;a href=&quot;c3ref/preupdate_count&quot;&gt;sqlite3_preupdate_hook（）&lt;/a&gt; API，因此应用程序无法在连接了一个或多个会话对象的数据库句柄上注册更新前挂钩。也无法创建连接到数据库句柄的会话对象，该会话对象已为其定义了更新前挂钩。尝试这些操作之一的结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="adc547a5fb4644ceebfd077fa4efa0549df654d8" translate="yes" xml:space="preserve">
          <source>Because the shm file is not involved in recovery, the shm file does not need to be machine byte-order independent. Hence, numeric values in the shm file are written in the native byte order of the host computer, rather than being converted into a specific cross-platform byte order as is done with the main database file and the wal file.</source>
          <target state="translated">由于shm文件不参与恢复,shm文件不需要与机器字节顺序无关。因此,shm文件中的数值是按照主机的本机字节顺序写入的,而不是像主数据库文件和wal文件那样,转换成特定的跨平台字节顺序。</target>
        </trans-unit>
        <trans-unit id="57d0b82e26ee2d676d928a1d7402d5916fc2656a" translate="yes" xml:space="preserve">
          <source>Because the shm is only used to coordinate access between concurrent clients, the shm file is omitted if &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; is set, as an optimization. When &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; is set, SQLite uses heap memory in place of the memory-mapped shm file.</source>
          <target state="translated">由于shm仅用于协调并发客户端之间的访问，因此，如果设置了&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;独占锁定模式，&lt;/a&gt;则会将shm文件省略，以进行优化。当&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;独家锁定模式&lt;/a&gt;被设置时，SQLite使用堆存储器代替存储器映射SHM文件。</target>
        </trans-unit>
        <trans-unit id="2da09f02d441cbe1ccd49c9803ec08e4160143a9" translate="yes" xml:space="preserve">
          <source>Because there is no cross-platform way to specify 64-bit integer types SQLite includes typedefs for 64-bit signed and unsigned integers.</source>
          <target state="translated">因为没有跨平台的方式来指定64位整数类型,所以SQLite包含了64位有符号和无符号整数的类型定义。</target>
        </trans-unit>
        <trans-unit id="8871399a86a3489a9f90b012e36a01ad56791fa8" translate="yes" xml:space="preserve">
          <source>Before SQLite can write to a database, it must first read the database to see what is there already. Even if it is just appending new data, SQLite still has to read in the database schema from the &quot;&lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt;&quot; table so that it can know how to parse the INSERT statements and discover where in the database file the new information should be stored.</source>
          <target state="translated">在SQLite可以写入数据库之前，它必须首先读取数据库以查看已经存在的内容。即使只是附加新数据，SQLite仍然必须从&amp;ldquo; &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; &amp;rdquo;表中读取数据库模式，以便它知道如何解析INSERT语句并发现新信息应存储在数据库文件中的什么位置。</target>
        </trans-unit>
        <trans-unit id="7d5873520ec115c715db00ab0ac94f393f103400" translate="yes" xml:space="preserve">
          <source>Before SQLite can write to a database, it must first read the database to see what is there already. Even if it is just appending new data, SQLite still has to read in the database schema from the &lt;b&gt;sqlite_master&lt;/b&gt; table so that it can know how to parse the INSERT statements and discover where in the database file the new information should be stored.</source>
          <target state="translated">在SQLite可以写入数据库之前，它必须首先读取数据库以查看已经存在的内容。即使只是附加新数据，SQLite仍必须从&lt;b&gt;sqlite_master&lt;/b&gt;表中读取数据库架构，以便它可以知道如何解析INSERT语句并发现应将新信息存储在数据库文件中的什么位置。</target>
        </trans-unit>
        <trans-unit id="ccacc0177cbd2ba716b19132f920379d439772e2" translate="yes" xml:space="preserve">
          <source>Before a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement can be run, the module specified in that statement must be registered with the database connection. This is accomplished using either of the &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; interfaces:</source>
          <target state="translated">在运行&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;语句之前，必须在数据库连接中注册该语句中指定的模块。使用&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module（）&lt;/a&gt;或&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2（）&lt;/a&gt;接口可以完成此操作：</target>
        </trans-unit>
        <trans-unit id="c589001febca68c36ef8079ff9faca5b3d4efc6b" translate="yes" xml:space="preserve">
          <source>Before a new auxiliary function or tokenizer implementation may be registered with FTS5, an application must obtain a pointer to the &quot;fts5_api&quot; structure. There is one fts5_api structure for each database connection with which the FTS5 extension is registered. To obtain the pointer, the application invokes the SQL user-defined function fts5() with a single argument. That argument must be set to a pointer to a pointer to an fts5_api object using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; interface. The following example code demonstrates the technique:</source>
          <target state="translated">在向FTS5注册新的辅助功能或令牌生成器实现之前，应用程序必须获取指向&amp;ldquo; fts5_api&amp;rdquo;结构的指针。每个注册FTS5扩展名的数据库连接都有一个fts5_api结构。为了获取指针，应用程序使用单个参数调用SQL用户定义的函数fts5（）。必须使用&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;接口将该参数设置为指向fts5_api对象的指针的指针。下面的示例代码演示了该技术：</target>
        </trans-unit>
        <trans-unit id="6ae8b38a31b33865e805e86015a35fae53d45a85" translate="yes" xml:space="preserve">
          <source>Before any database pages may be modified within the</source>
          <target state="translated">在修改任何数据库页面之前,可以在</target>
        </trans-unit>
        <trans-unit id="2aafeb2e2bb5cf3269cb7e705f038008b263f110" translate="yes" xml:space="preserve">
          <source>Before any information-bearing page of the database is modified, the original unmodified content of that page is written into the rollback journal. If a transaction is interrupted and needs to be rolled back, the rollback journal can then be used to restore the database to its original state. Freelist leaf pages bear no information that would need to be restored on a rollback and so they are not written to the journal prior to modification, in order to reduce disk I/O.</source>
          <target state="translated">在修改数据库的任何信息页面之前,该页面的原始未修改内容会被写入回滚日志。如果一个事务被中断,需要回滚,那么可以使用回滚日志将数据库恢复到原始状态。自由列表叶页没有需要在回滚时恢复的信息,所以在修改前不写入日志,以减少磁盘I/O。</target>
        </trans-unit>
        <trans-unit id="e31e39238fffa8a7d3425c769271d3112873aa6f" translate="yes" xml:space="preserve">
          <source>Before calling this method, the SQLite core initializes an instance of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure with information about the query that it is currently trying to process. This information derives mainly from the WHERE clause and ORDER BY or GROUP BY clauses of the query, but also from any ON or USING clauses if the query is a join. The information that the SQLite core provides to the xBestIndex method is held in the part of the structure that is marked as &quot;Inputs&quot;. The &quot;Outputs&quot; section is initialized to zero.</source>
          <target state="translated">在调用此方法之前，SQLite核心使用有关当前正在尝试处理的查询的信息来初始化&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;结构的实例。此信息主要源自查询的WHERE子句和ORDER BY或GROUP BY子句，如果查询是联接，则还源自任何ON或USING子句。SQLite核心提供给xBestIndex方法的信息保存在标记为&amp;ldquo;输入&amp;rdquo;的结构部分中。&amp;ldquo;输出&amp;rdquo;部分初始化为零。</target>
        </trans-unit>
        <trans-unit id="29b6c291315b8e1fb3f265c15e369937b630aaf5" translate="yes" xml:space="preserve">
          <source>Before data may be read from a</source>
          <target state="translated">读取数据之前,可以从</target>
        </trans-unit>
        <trans-unit id="cae7b06f8fadf1f8b2bbb51c0629366481aebe32" translate="yes" xml:space="preserve">
          <source>Before entering a trigger program the value returned by sqlite3_changes() function is saved. After the trigger program has finished, the original value is restored.</source>
          <target state="translated">在进入触发程序之前,sqlite3_changes()函数返回的值会被保存。触发程序结束后,恢复原值。</target>
        </trans-unit>
        <trans-unit id="7968bdea3fbca698f15e058c3369cb48f81fd4ca" translate="yes" xml:space="preserve">
          <source>Before executing a statement that modifies the database schema (i.e. a CREATE or DROP TABLE statement), a connection must obtain a write-lock on</source>
          <target state="translated">在执行修改数据库模式的语句(例如CREATE或DROP TABLE语句)前,连接必须在</target>
        </trans-unit>
        <trans-unit id="64443a5dc257f480bf4a79d829dcae9017cc971a" translate="yes" xml:space="preserve">
          <source>Before making changes to any page of the database, the process writes the original content of that page into the rollback journal. Changes to pages are held in memory at first and are not written to the disk. The original database file remains unaltered, which means that other processes can continue to read the database.</source>
          <target state="translated">在对数据库的任何页面进行更改之前,进程会将该页面的原始内容写入回滚日志。对页面的更改首先保存在内存中,并不写入磁盘。原始数据库文件保持不变,这意味着其他进程可以继续读取数据库。</target>
        </trans-unit>
        <trans-unit id="ed294139e05d80e58de31e418d68f4cfaebeb6a7" translate="yes" xml:space="preserve">
          <source>Before making changes to the database, SQLite first obtains a &quot;reserved&quot; lock on the database file. A reserved lock is similar to a shared lock in that both a reserved lock and shared lock allow other processes to read from the database file. A single reserve lock can coexist with multiple shared locks from other processes. However, there can only be a single reserved lock on the database file. Hence only a single process can be attempting to write to the database at one time.</source>
          <target state="translated">在对数据库进行修改之前,SQLite首先会在数据库文件上获得一个 &quot;保留 &quot;锁。保留锁与共享锁类似,保留锁和共享锁都允许其他进程从数据库文件中读取。一个预留锁可以与其他进程的多个共享锁共存。但是,数据库文件上只能有一个单一的预留锁。因此,一次只能有一个进程试图向数据库写入。</target>
        </trans-unit>
        <trans-unit id="e0b64dbebb4ad46a9aeb1a098c15aadd4e3eaf44" translate="yes" xml:space="preserve">
          <source>Before modifying a database page within the</source>
          <target state="translated">在修改数据库页面之前,在</target>
        </trans-unit>
        <trans-unit id="98e0ccf77dc018ac7ea18b90477a40f1a7c510fa" translate="yes" xml:space="preserve">
          <source>Before opening a</source>
          <target state="translated">开业前</target>
        </trans-unit>
        <trans-unit id="6822a9cef8f0664c32cddfaac23e4bff41485b02" translate="yes" xml:space="preserve">
          <source>Before reading from a database file, SQLite always checks to see if that database file has a hot journal. If the file does have a hot journal, then the journal is rolled back before the file is read. In this way, we ensure that the database file is in a consistent state before it is read.</source>
          <target state="translated">在从数据库文件中读取之前,SQLite总会检查该数据库文件是否有热日志。如果该文件确实有一个热日志,那么在读取文件之前就会将该日志回滚。通过这种方式,我们可以确保数据库文件在被读取之前处于一致的状态。</target>
        </trans-unit>
        <trans-unit id="2ffabc9625263621654187c58d31675c59e6730d" translate="yes" xml:space="preserve">
          <source>Before the content of a page modified within the</source>
          <target state="translated">之前在页面内修改的内容。</target>
        </trans-unit>
        <trans-unit id="2a76187aef00ad8a5abadfac889a6b98dd1db2fb" translate="yes" xml:space="preserve">
          <source>Before the contents of the</source>
          <target state="translated">前的内容。</target>
        </trans-unit>
        <trans-unit id="5f97138118a317cbc3bf1e3e8dd4c6fd1edd23a0" translate="yes" xml:space="preserve">
          <source>Before we begin looking at this problem, let's briefly review how queries work in SQLite so that we will know what we are trying to accomplish. For each row in the result of a query, SQLite will invoke a callback function with the following prototype:</source>
          <target state="translated">在开始研究这个问题之前,我们先简单回顾一下SQLite中查询的工作原理,这样我们就会知道我们要达到的目的。对于查询结果中的每一条记录,SQLite会调用一个回调函数,其原型如下。</target>
        </trans-unit>
        <trans-unit id="5c00a0d3ea5cf97be2cbc8e0c749bfff4206bbf5" translate="yes" xml:space="preserve">
          <source>Begin a transaction on database P1 if a transaction is not already active. If P2 is non-zero, then a write-transaction is started, or if a read-transaction is already active, it is upgraded to a write-transaction. If P2 is zero, then a read-transaction is started.</source>
          <target state="translated">如果一个事务还没有活动,则在数据库P1上开始一个事务。如果P2为非零,则开始写事务,如果读事务已经激活,则将其升级为写事务。如果P2为零,则启动读事务。</target>
        </trans-unit>
        <trans-unit id="9e391262ae8640ac82ce60d3db590db1105525b3" translate="yes" xml:space="preserve">
          <source>Begin a transaction on database P1 if a transaction is not already active. If P2 is non-zero, then a write-transaction is started, or if a read-transaction is already active, it is upgraded to a write-transaction. If P2 is zero, then a read-transaction is started. If P2 is 2 or more then an exclusive transaction is started.</source>
          <target state="translated">如果一个事务还没有活动,则在数据库P1上开始一个事务。如果P2为非零,则开始写事务,如果读事务已经激活,则将其升级为写事务。如果P2为0,则启动读交易。如果P2为2或更多,则启动专属事务。</target>
        </trans-unit>
        <trans-unit id="2fd194a93ac6ccfaf40c7f7cd5a992cb067293a7" translate="yes" xml:space="preserve">
          <source>Begin adding lots of new documentation</source>
          <target state="translated">开始添加大量的新文件</target>
        </trans-unit>
        <trans-unit id="90c994ef269c7ca4806cc0aace7ca7e97ba28671" translate="yes" xml:space="preserve">
          <source>Begin by obtaining a copy of SQLite in whatever form you use it. The public SQLite you obtain should be as close to your private edited copy as possible. If your project uses the SQLite amalgamation, then get a copy of the amalgamation. If you use the preprocessed separate source files, get those instead. Put all the source files in the checkout directory created in the previous step.</source>
          <target state="translated">首先要获得一个SQLite的副本,无论你用什么形式。你获得的公共SQLite应该尽可能地接近你的私人编辑的副本。如果你的项目使用了SQLite的合集,那么就得到一份合集的副本。如果你使用的是预处理的独立源文件,就用这些来代替。把所有的源文件放在上一步创建的检查目录中。</target>
        </trans-unit>
        <trans-unit id="c95a84f6810e9547323b7d36381036499b6e85a2" translate="yes" xml:space="preserve">
          <source>Begin enforcing &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvdbeop&quot;&gt;SQLITE_LIMIT_VDBE_OP&lt;/a&gt;. This can be used, for example, to prevent excessively large prepared statements in systems that accept SQL queries from untrusted users.</source>
          <target state="translated">开始执行&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvdbeop&quot;&gt;SQLITE_LIMIT_VDBE_OP&lt;/a&gt;。例如，这可以用于防止在接受来自不受信任用户的SQL查询的系统中准备过多的语句。</target>
        </trans-unit>
        <trans-unit id="6b5e2f03338f65ea55efadd743c2073f0844124d" translate="yes" xml:space="preserve">
          <source>Begin every identifier with the letter &quot;Z&quot; as no SQL keywords start with &quot;Z&quot;.</source>
          <target state="translated">每个标识符都以字母 &quot;Z &quot;开头,因为没有SQL关键字以 &quot;Z &quot;开头。</target>
        </trans-unit>
        <trans-unit id="c7c9b7ac07f4b963268a3915518a82c60026c1c8" translate="yes" xml:space="preserve">
          <source>Begin writing documentation on the TCL interface.</source>
          <target state="translated">开始编写TCL接口的文档。</target>
        </trans-unit>
        <trans-unit id="d93624195948cab4e3c3cf8a06c4ba66150434ee" translate="yes" xml:space="preserve">
          <source>Begin writing the &lt;a href=&quot;vdbe&quot;&gt;VDBE tutorial&lt;/a&gt;.</source>
          <target state="translated">开始编写&lt;a href=&quot;vdbe&quot;&gt;VDBE教程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2891bac57361d1d80487ccfbba99ba09325df3b5" translate="yes" xml:space="preserve">
          <source>Beginning a Write Transaction</source>
          <target state="translated">开始写交易</target>
        </trans-unit>
        <trans-unit id="60eca843fdd7093ad8665839ef32416ade71c639" translate="yes" xml:space="preserve">
          <source>Beginning in 2016, a team of engineers at Google started the &lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSS Fuzz&lt;/a&gt; project. OSS Fuzz uses a AFL-style guided fuzzer running on Google's infrastructure. The Fuzzer automatically downloads the latest check-ins for participating projects, fuzzes them, and sends email to the developers reporting any problems. When a fix is checked in, the fuzzer automatically detects this and emails a confirmation to the developers.</source>
          <target state="translated">从2016年开始，Google的工程师团队启动了&lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSS Fuzz&lt;/a&gt;项目。OSS Fuzz使用在Google的基础架构上运行的AFL样式的指导性模糊器。Fuzzer会自动为参与的项目下载最新的签入内容，对它们进行模糊处理，然后向开发人员发送电子邮件，报告任何问题。检入修复程序后，模糊器将自动检测到此问题，并通过电子邮件将确认发送给开发人员。</target>
        </trans-unit>
        <trans-unit id="52ddec92a44c4044495e3a4272f88fb5bf0d2787" translate="yes" xml:space="preserve">
          <source>Beginning in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;version 3.15.0&lt;/a&gt; (2016-10-14), an assignment in the SET clause can be a &lt;a href=&quot;syntax/column-name-list&quot;&gt;parenthesized list of column names&lt;/a&gt; on the left and a &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; of the same size on the right.</source>
          <target state="translated">从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;版本3.15.0&lt;/a&gt;（2016-10-14）开始，SET子句中的赋值可以是左侧&lt;a href=&quot;syntax/column-name-list&quot;&gt;列名称&lt;/a&gt;的括号列表，右侧是相同大小的&lt;a href=&quot;rowvalue&quot;&gt;行值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8e0744464084ddf340ea6c6e0a24aad6d9c12c18" translate="yes" xml:space="preserve">
          <source>Beginning in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_4.html&quot;&gt;version 3.6.4&lt;/a&gt; (2008-10-15), the TRUNCATE journal mode is also supported:</source>
          <target state="translated">从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_4.html&quot;&gt;版本3.6.4&lt;/a&gt;（2008-10-15）开始，还支持TRUNCATE日志模式：</target>
        </trans-unit>
        <trans-unit id="6adac7327da12129344605aed8c6230ec2a45b5c" translate="yes" xml:space="preserve">
          <source>Beginning in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_4.html&quot;&gt;version 3.7.4&lt;/a&gt; (2010-12-07), WAL databases can be created, read, and written even if shared memory is unavailable as long as the &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; is set to EXCLUSIVE before the first attempted access. In other words, a process can interact with a WAL database without using shared memory if that process is guaranteed to be the only process accessing the database. This feature allows WAL databases to be created, read, and written by legacy &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; that lack the &quot;version 2&quot; shared-memory methods xShmMap, xShmLock, xShmBarrier, and xShmUnmap on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_4.html&quot;&gt;版本3.7.4&lt;/a&gt;（2010-12-07）开始，即使共享内存不可用，只要在首次尝试访问之前将&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt;设置为EXCLUSIVE ，就可以创建，读取和写入WAL数据库。换句话说，如果保证该进程是访问数据库的唯一进程，则该进程可以与WAL数据库进行交互而无需使用共享内存。此功能允许在&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象上缺少&amp;ldquo;版本2&amp;rdquo;共享内存方法xShmMap，xShmLock，xShmBarrier和xShmUnmap 的旧版&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;创建，读取和写入WAL数据库。</target>
        </trans-unit>
        <trans-unit id="0f100a899b26537fc63caa4230653ce9716130e4" translate="yes" xml:space="preserve">
          <source>Beginning in SQLite version 3.5.0, the new Virtual File System (VFS) interface contains a method named xDeviceCharacteristics which reports on special properties that the underlying mass storage device might have. Among the special properties that xDeviceCharacteristics might report is the ability of to do an atomic sector write.</source>
          <target state="translated">从SQLite 3.5.0版本开始,新的虚拟文件系统(VFS)接口包含一个名为xDeviceCharacteristics的方法,它报告了底层大容量存储设备可能具有的特殊属性。在xDeviceCharacteristics可能报告的特殊属性中,有一个是可以进行原子扇区写入的能力。</target>
        </trans-unit>
        <trans-unit id="dbe6df39f8d021809fb2ab3e47422b19fa74d670" translate="yes" xml:space="preserve">
          <source>Beginning in late 2018, SQLite has been fuzzed using a new proprietary fuzzer called &quot;dbsqlfuzz&quot;. Dbsqlfuzz is built using the &lt;a href=&quot;http://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt; framework of LLVM.</source>
          <target state="translated">从2018年末开始，SQLite已使用名为&amp;ldquo; dbsqlfuzz&amp;rdquo;的新专有模糊器进行模糊处理。Dbsqlfuzz使用LLVM 的&lt;a href=&quot;http://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt;框架构建。</target>
        </trans-unit>
        <trans-unit id="4a778da0c8fb845c41a15f84356940bc5e83e7d6" translate="yes" xml:space="preserve">
          <source>Beginning in late 2018, SQLite has been fuzzed using a new proprietary fuzzer called &quot;dbsqlfuzz&quot;. Dbsqlfuzz is built using the &lt;a href=&quot;https://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt; framework of LLVM.</source>
          <target state="translated">从2018年下半年开始，SQLite已使用名为&amp;ldquo; dbsqlfuzz&amp;rdquo;的新型专有模糊器进行模糊处理。Dbsqlfuzz使用LLVM的&lt;a href=&quot;https://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt;框架构建。</target>
        </trans-unit>
        <trans-unit id="a4f6d3a3a096224887296bd514258ca7ceae764c" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21), SQLite supports a new transaction control mechanism called &quot;&lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;&quot; or &quot;&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;&quot;. When a database is in WAL mode, all connections to that database must use the WAL. A particular database will use either a rollback journal or a WAL, but not both at the same time. The WAL is always located in the same directory as the database file and has the same name as the database file but with the string &quot;&lt;code&gt;-wal&lt;/code&gt;&quot; appended.</source>
          <target state="translated">从&lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;版本3.7.0&lt;/a&gt;（2010-07-21）开始，SQLite支持一种新的事务控制机制，称为&amp;ldquo; &lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt; &amp;rdquo;或&amp;ldquo; &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; &amp;rdquo;。当数据库处于WAL模式时，与该数据库的所有连接都必须使用WAL。特定的数据库将使用回滚日志或WAL，但不会同时使用两者。WAL始终与数据库文件位于同一目录中，并且与数据库文件具有相同的名称，但是附加了字符串&amp;ldquo; &lt;code&gt;-wal&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d9839d2cef57fa5d151a0ce9cbe15a6e0c36fbc7" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;version 3.7.17&lt;/a&gt; (2013-05-20), SQLite has the option of accessing disk content directly using memory-mapped I/O and the new xFetch() and xUnfetch() methods on &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;.</source>
          <target state="translated">从&lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;版本3.7.17&lt;/a&gt;（2013-05-20）开始，SQLite可以选择使用内存映射的I / O以及&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;上的新xFetch（）和xUnfetch（）方法直接访问磁盘内容。</target>
        </trans-unit>
        <trans-unit id="26a395622db69c8b77803fcd06e3a2c5d4cdefa3" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;version 3.7.7&lt;/a&gt; (2011-06-23), the SQLite database file argument to the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interfaces and to the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command can be specified either as an ordinary filename or as a Uniform Resource Identifier or URI. The advantage of using a URI filename is that query parameters on the URI can be used to control details of the newly created database connection. For example, an alternative &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; can be specified using a &quot;vfs=&quot; query parameter. Or the database can be opened read-only by using &quot;mode=ro&quot; as a query parameter.</source>
          <target state="translated">从&lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;版本3.7.7&lt;/a&gt;（2011-06-23）开始，可以将SQLite数据库文件参数&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;和&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;接口以及&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;命令指定为普通文件名或统一资源标识符或URI。使用URI文件名的优点是URI上的查询参数可用于控制新创建的数据库连接的详细信息。例如，可以使用&amp;ldquo; vfs =&amp;ldquo;查询参数来指定备用&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;。或者可以通过使用&amp;ldquo; mode = ro&amp;rdquo;作为查询参数以只读方式打开数据库。</target>
        </trans-unit>
        <trans-unit id="8b26610830584adfe4c3b1f430311725c505dc65" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14) SQLite uses &lt;a href=&quot;http://semver.org&quot;&gt;semantic versioning&lt;/a&gt;. Prior to that time, SQLite employed a version identifier that contained between two and four numbers.</source>
          <target state="translated">从&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;版本3.9.0&lt;/a&gt;（2015-10-14）开始，SQLite使用&lt;a href=&quot;http://semver.org&quot;&gt;语义版本控制&lt;/a&gt;。在此之前，SQLite使用的版本标识符包含两个到四个数字。</target>
        </trans-unit>
        <trans-unit id="e8a7a785dc79c6f97e7e9b629f10c98e7d6eaa12" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite 3.23.0 (2018-04-02), SQLite recognizes the identifiers &quot;TRUE&quot; and &quot;FALSE&quot; as boolean literals, if and only if those identifiers are not already used for some other meaning. If there already exists columns or tables or other objects named TRUE or FALSE, then for the sake of backwards compatibility, the TRUE and FALSE identifiers refer to those other objects, not to the boolean values.</source>
          <target state="translated">从SQLite 3.23.0(2018-04-02)开始,SQLite将标识符 &quot;TRUE &quot;和 &quot;FALSE &quot;识别为布尔字面,如果且仅当这些标识符还没有被用于其他含义时。如果已经存在名为 &quot;TRUE &quot;或 &quot;FALSE &quot;的列或表或其他对象,那么为了向后兼容,&quot;TRUE &quot;和 &quot;FALSE &quot;标识符指的是这些其他对象,而不是布尔值。</target>
        </trans-unit>
        <trans-unit id="e27a2a72ed98b30f89096b193da3e3a912285cdd" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;version 3.10.0&lt;/a&gt; (2016-01-06), the unix OS interface will attempt to resolve symbolic links and open the database file by its canonical name. Prior to version 3.10.0, opening a database file through a symbolic link was similar to opening a database file that had multiple hard links and resulted in undefined behavior.</source>
          <target state="translated">从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;版本3.10.0&lt;/a&gt;（2016-01-06）开始，Unix操作系统界面将尝试解析符号链接并按其规范名称打开数据库文件。在3.10.0之前的版本中，通过符号链接打开数据库文件类似于打开具有多个硬链接并导致未定义行为的数据库文件。</target>
        </trans-unit>
        <trans-unit id="669009bffd329a7525e12f992041efbc93a9e4fc" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_14.html&quot;&gt;version 3.14.0&lt;/a&gt; (2016-08-08), the CREATE TABLE statement that is passed into &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; may contain a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; clause. This is useful for cases where the virtual table rows cannot easily be mapped into unique integers. A CREATE TABLE statement that includes WITHOUT ROWID must define one or more columns as the PRIMARY KEY. Every column of the PRIMARY KEY must individually be NOT NULL and all columns for each row must be collectively unique.</source>
          <target state="translated">从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_14.html&quot;&gt;版本3.14.0&lt;/a&gt;（2016-08-08）开始，传递到&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt;的CREATE TABLE语句可能包含&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;子句。对于无法轻松将虚拟表行映射为唯一整数的情况，这很有用。包含WITHOUT ROWID的CREATE TABLE语句必须将一个或多个列定义为PRIMARY KEY。 PRIMARY KEY的每一列都必须分别为NOT NULL，并且每一行的所有列都必须共同唯一。</target>
        </trans-unit>
        <trans-unit id="914fd4075646f327da4b592c31312990facc6a8d" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;version 3.23.0&lt;/a&gt; (2018-04-02), SQLite also recognizes TRUE and FALSE keywords as aliases for integer values 1 and 0, respectively. This provides better compatibility with other SQL implementations. But to retain backwards compatibility, if there are columns named TRUE or FALSE, then the keywords are treated as identifiers referencing those columns, rather than BOOLEAN literals.</source>
          <target state="translated">从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;版本3.23.0&lt;/a&gt;（2018-04-02）开始，SQLite还将TRUE和FALSE关键字分别识别为整数值1和0的别名。这提供了与其他SQL实现的更好的兼容性。但是为了保持向后兼容性，如果存在名为TRUE或FALSE的列，则将关键字视为引用这些列的标识符，而不是BOOLEAN文字。</target>
        </trans-unit>
        <trans-unit id="67498fb6faa33682195156e0b1885f3794748cc2" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_31_0.html&quot;&gt;version 3.31.0&lt;/a&gt; (2020-01-22) the input F parameter can also be the name of a rollback journal file or WAL file in addition to the main database file. Prior to version 3.31.0, these routines would only work if F was the name of the main database file. When the F parameter is the name of the rollback journal or WAL file, it has access to all the same query parameters as were found on the main database file.</source>
          <target state="translated">从SQLite&lt;a href=&quot;https://sqlite.org/releaselog/3_31_0.html&quot;&gt;版本3.31.0&lt;/a&gt;（2020-01-22）开始，除了主数据库文件之外，输入F参数还可以是回滚日志文件或WAL文件的名称。在3.31.0之前的版本中，仅当F是主数据库文件的名称时，这些例程才有效。当F参数是回滚日志或WAL文件的名称时，它可以访问与在主数据库文件中找到的所有相同的查询参数。</target>
        </trans-unit>
        <trans-unit id="d9f2cb99d27921b6ac8152e7a3c891a53596352b" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;version 3.7.13&lt;/a&gt; (2012-06-11), shared cache can be used on &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt;, provided that the database is created using a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. For backwards compatibility, shared cache is always disable for in-memory databases if the unadorned name &quot;:memory:&quot; is used to open the database. Prior to version 3.7.13, shared cache was always disabled for in-memory databases regardless of the database name used, current system shared cache setting, or query parameters or flags.</source>
          <target state="translated">从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;版本3.7.13&lt;/a&gt;（2012-06-11）开始，可以&lt;a href=&quot;inmemorydb&quot;&gt;在内存数据库中&lt;/a&gt;使用共享缓存，前提是该数据库是使用&lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;创建的。为了向后兼容，如果使用未经修饰的名称&amp;ldquo;：memory：&amp;rdquo;来打开数据库，则始终禁用内存数据库的共享缓存。在3.7.13版之前，内存数据库中的共享缓存始终处于禁用状态，无论使用的数据库名称，当前系统共享的缓存设置，查询参数或标志如何。</target>
        </trans-unit>
        <trans-unit id="6365abc3c758d3309a8a458a1000945ef77510f8" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;version 3.7.13&lt;/a&gt; (2012-06-11), shared cache can be used on &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt;, provided that the database is created using a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. For backwards compatibility, shared cache is always disabled for in-memory databases if the unadorned name &quot;:memory:&quot; is used to open the database. Prior to version 3.7.13, shared cache was always disabled for in-memory databases regardless of the database name used, current system shared cache setting, or query parameters or flags.</source>
          <target state="translated">从SQLite&lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;版本3.7.13&lt;/a&gt;（2012-06-11）开始，可以&lt;a href=&quot;inmemorydb&quot;&gt;在内存数据库中&lt;/a&gt;使用共享缓存，前提是该数据库是使用&lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;创建的。为了向后兼容，如果使用未经修饰的名称&amp;ldquo;：memory：&amp;rdquo;打开数据库，则始终禁用内存数据库的共享缓存。在3.7.13版之前，内存数据库中的共享缓存始终被禁用，无论使用的数据库名称，当前系统共享的缓存设置，查询参数或标志如何。</target>
        </trans-unit>
        <trans-unit id="4d897fef3b918d90f462942b797bcba2f181cd38" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;version 3.7.17&lt;/a&gt; (2013-05-20), the unix OS interface will send SQLITE_WARNING messages to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; if a database file has multiple hard links.</source>
          <target state="translated">从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;版本3.7.17&lt;/a&gt;（2013-05-20）开始，如果数据库文件具有多个硬链接，则UNIX OS界面将向&lt;a href=&quot;errlog&quot;&gt;错误日志&lt;/a&gt;发送SQLITE_WARNING消息。</target>
        </trans-unit>
        <trans-unit id="7fa120398347f1152da8e84a3905c5d3c58c3466" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;version 3.7.17&lt;/a&gt; (2013-05-20), the unix OS interface will send SQLITE_WARNING messages to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; if a database file is unlinked while it is still in use.</source>
          <target state="translated">从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;版本3.7.17&lt;/a&gt;（2013-05-20）开始，如果在数据库文件仍处于使用状态时取消链接，则UNIX操作系统界面会将SQLITE_WARNING消息发送到&lt;a href=&quot;errlog&quot;&gt;错误日志&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8f4af8bd16f5f6dcf0575ed25d9da5ad7a3cecfc" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_3.html&quot;&gt;version 3.7.3&lt;/a&gt; (2010-10-08), the soft heap limit is enforced regardless of whether or not the &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is invoked. With &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;, the soft heap limit is enforced on every memory allocation. Without &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;, the soft heap limit is only enforced when memory is allocated by the page cache. Testing suggests that because the page cache is the predominate memory user in SQLite, most applications will achieve adequate soft heap limit enforcement without the use of &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_3.html&quot;&gt;版本3.7.3&lt;/a&gt;（2010-10-08）开始，无论是否调用&lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;编译时选项，都会强制执行软堆限制。使用&lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;，对每个内存分配都强制实施软堆限制。如果没有&lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;，则仅在页面缓存分配内存时才实施软堆限制。测试表明，由于页面缓存是SQLite中的主要内存用户，因此大多数应用程序无需使用&lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;即可实现足够的软堆限制。</target>
        </trans-unit>
        <trans-unit id="a0dfecc63fffa644348dc3e00941cc0dedd6014a" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_3.html&quot;&gt;version 3.7.3&lt;/a&gt; (2010-10-08), the soft heap limit is enforced regardless of whether or not the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is invoked. With &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;, the soft heap limit is enforced on every memory allocation. Without &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;, the soft heap limit is only enforced when memory is allocated by the page cache. Testing suggests that because the page cache is the predominate memory user in SQLite, most applications will achieve adequate soft heap limit enforcement without the use of &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_3.html&quot;&gt;版本3.7.3&lt;/a&gt;（2010-10-08）开始，无论是否调用&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;编译时选项，都会强制执行软堆限制。使用&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;，对每个内存分配都强制实施软堆限制。如果没有&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;，则仅在页面缓存分配内存时才实施软堆限制。测试表明，由于页面缓存是SQLite中的主要内存用户，因此大多数应用程序无需使用&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;即可实现足够的软堆限制。</target>
        </trans-unit>
        <trans-unit id="c179ab3e7d04af330c7efc2cec123a479ee926c3" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite version 3.24.0 (2018-06-04), r-tree tables can have auxiliary columns that store arbitrary data. Auxiliary columns can be used in place of secondary tables such as &quot;demo_data&quot;.</source>
          <target state="translated">从SQLite 3.24.0版本(2018-06-04)开始,r-tree表可以有辅助列来存储任意数据。辅助列可以用来代替辅助表,如 &quot;demo_data&quot;。</target>
        </trans-unit>
        <trans-unit id="e6d8128996ffada537e69bde476b38bfd6abdaaa" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite version 3.3.14 a mechanism has been added to try to reduce the needless rereading of data. In newer versions of SQLite, the data in the user-space pager cache is retained when the lock on the database file is released. Later, after the shared lock is acquired at the beginning of the next transaction, SQLite checks to see if any other process has modified the database file. If the database has been changed in any way since the lock was last released, the user-space cache is erased at that point. But commonly the database file is unchanged and the user-space cache can be retained, and some unnecessary read operations can be avoided.</source>
          <target state="translated">从SQLite 3.3.14版本开始,增加了一种机制,试图减少不必要的数据重读。在SQLite的新版本中,当数据库文件的锁被释放时,用户空间分页缓存中的数据会被保留。之后,在下一个事务开始时获得共享锁后,SQLite会检查是否有其他进程修改了数据库文件。如果自上次释放锁后,数据库有任何变化,此时用户空间缓存会被清除。但通常数据库文件没有变化,用户空间缓存可以保留,可以避免一些不必要的读操作。</target>
        </trans-unit>
        <trans-unit id="c39116a071141537c93dfcacc99b39343f685f47" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite version 3.31.0 (2020-01-22), lookaside supports two memory pools, each with a different size slot. The small-slot pool uses 128-byte slots and the large-slot pool uses whatever size is specified by &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;SQLITE_DBCONFIG_LOOKASIDE&lt;/a&gt; (defaulting to 1200 bytes). Splitting the pool in two like this allows memory allocations to be covered by lookaside more often while at the same time reducing per-database-connection heap usage from 120KB down to 48KB.</source>
          <target state="translated">从SQLite版本3.31.0（2020-01-22）开始，后备支持两个内存池，每个内存池具有不同的大小插槽。小插槽池使用128字节的插槽，大插槽池使用&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;SQLITE_DBCONFIG_LOOKASIDE&lt;/a&gt;指定的任何大小（默认为1200字节）。像这样将池分成两部分，可以使后备存储器更经常地覆盖内存分配，同时将每个数据库连接堆的使用量从120KB减少到48KB。</target>
        </trans-unit>
        <trans-unit id="635d1349e5a7c9b8fbfcde84b9ea3c1fb202bc64" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite version 3.31.0 (2020-01-22), the DBSTAT table has a new &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden column&lt;/a&gt; named &quot;aggregate&quot;, which if constrained to be TRUE will cause DBSTAT to generate one row per btree in the database, rather than one row per page. When running in aggregated mode, the &quot;path&quot;, &quot;pagetype&quot;, and &quot;pgoffset&quot; columns are always NULL and the &quot;pageno&quot; column holds the number of pages in the entire btree, rather than the number of the page that corresponds to the row.</source>
          <target state="translated">从SQLite版本3.31.0（2020-01-22）开始，DBSTAT表具有一个名为&amp;ldquo; aggregate&amp;rdquo;的新&lt;a href=&quot;vtab#hiddencol&quot;&gt;隐藏列&lt;/a&gt;，如果将其约束为TRUE，则它将导致DBSTAT在数据库中每btree生成一行，而不是一行每页行。在聚合模式下运行时，&amp;ldquo; path&amp;rdquo;，&amp;ldquo; pagetype&amp;rdquo;和&amp;ldquo; pgoffset&amp;rdquo;列始终为NULL，而&amp;ldquo; pageno&amp;rdquo;列保存整个btree中的页面数，而不是对应于btree的页面数。排。</target>
        </trans-unit>
        <trans-unit id="c0eba5a240e8bc3220e00f595afb167768fa6cb7" translate="yes" xml:space="preserve">
          <source>Beginning with release 3.25.0 (2018-09-15), references to the table within trigger bodies and view definitions are also renamed.</source>
          <target state="translated">从3.25.0版本(2018-09-15)开始,触发体和视图定义中对表的引用也被重新命名。</target>
        </trans-unit>
        <trans-unit id="d654ce8d1a877b686fbd470426c428e02c9409c6" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.2.0, SQLite no longer builds an index for an INTEGER PRIMARY KEY column. Instead, it uses that column as the actual B-Tree key for the main table.</source>
          <target state="translated">从2.2.0版本开始,SQLite不再为一个INTEGER PRIMARY KEY列建立索引,而是使用该列作为主表的实际B树键。相反,它使用该列作为主表的实际B树键。</target>
        </trans-unit>
        <trans-unit id="042e0229fee0d8bfed5724fa18cd980bad0c1945" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.3.0, SQLite supports some additional syntax (the &quot;ON CONFLICT&quot; clause) in the CREATE TABLE and CREATE INDEX statements that are stored in the SQLITE_MASTER table. If you create a database that contains this new syntax, then try to read that database using version 2.2.5 or earlier, the parser will not understand the new syntax and you will get an error. Otherwise, databases for 2.2.x and 2.3.x are interchangeable.</source>
          <target state="translated">从2.3.0版本开始,SQLite支持一些额外的语法(&quot;ON CONFLICT &quot;子句),这些语法存储在SQLITE_MASTER表中的CREATE TABLE和CREATE INDEX语句中。如果创建一个包含这种新语法的数据库,然后尝试使用2.2.5或更早的版本读取该数据库,解析器将不理解新语法,并得到一个错误。否则,2.2.x和2.3.x的数据库是可以互换的。</target>
        </trans-unit>
        <trans-unit id="d9bdf31e2f633cc8ef293e098f7f5d722da8a2a8" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.4.0, SQLite added support for views. Information about views is stored in the SQLITE_MASTER table. If an older version of SQLite attempts to read a database that contains VIEW information in the SQLITE_MASTER table, the parser will not understand the new syntax and initialization will fail. Also, the way SQLite keeps track of unused disk blocks in the database file changed slightly. If an older version of SQLite attempts to write a database that was previously written by version 2.4.0 or later, then it may leak disk blocks.</source>
          <target state="translated">从2.4.0版本开始,SQLite增加了对视图的支持。有关视图的信息存储在SQLITE_MASTER表中。如果旧版本的SQLite试图读取SQLITE_MASTER表中包含view信息的数据库,解析器将不理解新的语法,初始化将失败。另外,SQLite跟踪数据库文件中未使用的磁盘块的方式也略有改变。如果旧版本的SQLite试图写入之前由2.4.0或更高版本写入的数据库,那么它可能会泄漏磁盘块。</target>
        </trans-unit>
        <trans-unit id="413008ed4f165a3aca53c2fe0890bace8386a170" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.4.0, SQLite allows the SQL language to be extended with new functions implemented as C code. The following interface is used:</source>
          <target state="translated">从2.4.0版本开始,SQLite允许用C代码实现的新函数扩展SQL语言。使用的接口如下。</target>
        </trans-unit>
        <trans-unit id="8dad8b696b630a32cf19067fe14052c10b2bac25" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.5.0, SQLite added support for triggers. Information about triggers is stored in the SQLITE_MASTER table. If an older version of SQLite attempts to read a database that contains a CREATE TRIGGER in the SQLITE_MASTER table, the parser will not understand the new syntax and initialization will fail.</source>
          <target state="translated">从2.5.0版本开始,SQLite增加了对触发器的支持。有关触发器的信息存储在SQLITE_MASTER表中。如果旧版本的SQLite试图读取SQLITE_MASTER表中包含CREATE TRIGGER的数据库,解析器将不理解新的语法,初始化将失败。</target>
        </trans-unit>
        <trans-unit id="50c1ec93a00d0cbe5badad130d3d4fbd2db53937" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.7.0, SQLite understands two different datatypes: text and numeric. Text data sorts in memcmp() order. Numeric data sorts in numerical order if it looks like a number, or in memcmp() order if it does not.</source>
          <target state="translated">从2.7.0版本开始,SQLite可以理解两种不同的数据类型:文本和数字。文本数据按memcmp()顺序排序。数值数据如果看起来像一个数字,则按数字顺序排序,如果不像,则按memcmp()顺序排序。</target>
        </trans-unit>
        <trans-unit id="c06e002a374c4a8233bf3048a5c902a5ad629404" translate="yes" xml:space="preserve">
          <source>Beginning with version 3.5, SQLite obtains all of the heap memory it needs using the routines &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt;. These routines have existed in prior versions of SQLite, but SQLite has previously bypassed these routines and used its own memory allocator. This all changes in version 3.5.0.</source>
          <target state="translated">从3.5版开始，SQLite使用例程&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;，&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;和&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;获得所需的所有堆内存。这些例程已经存在于SQLite的早期版本中，但是SQLite以前已经绕过了这些例程，并使用了自己的内存分配器。所有这些在版本3.5.0中进行了更改。</target>
        </trans-unit>
        <trans-unit id="8cb8a180b3917332f0d153bfa0ea4cd9cfa4625e" translate="yes" xml:space="preserve">
          <source>Behavior when page is not already in cache</source>
          <target state="translated">当页面不在缓存中时的行为。</target>
        </trans-unit>
        <trans-unit id="8f48bb3f768498f6c1f4331bb2d5a6b0f760fe90" translate="yes" xml:space="preserve">
          <source>Below is a simple &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TCL program&lt;/a&gt; that demonstrates how to use the TCL interface to SQLite. The program executes the SQL statements given as the second argument on the database defined by the first argument. The commands to watch for are the &lt;b&gt;sqlite3&lt;/b&gt; command on line 7 which opens an SQLite database and creates a new object named &quot;&lt;b&gt;db&lt;/b&gt;&quot; to access that database, the use of the &lt;a href=&quot;tclsqlite#eval&quot;&gt;eval method&lt;/a&gt; on the &lt;b&gt;db&lt;/b&gt; object on line 8 to run SQL commands against the database, and the closing of the database connection on the last line of the script.</source>
          <target state="translated">下面是一个简单的&lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TCL程序&lt;/a&gt;，该程序演示了如何将TCL接口用于SQLite。程序在第一个参数定义的数据库上执行作为第二个参数给出的SQL语句。要监视的命令是第7行的&lt;b&gt;sqlite3&lt;/b&gt;命令，该命令打开一个SQLite数据库并创建一个名为&amp;ldquo; &lt;b&gt;db&lt;/b&gt; &amp;rdquo; 的新对象来访问该数据库，并在第8行的&lt;b&gt;db&lt;/b&gt;对象上使用&lt;a href=&quot;tclsqlite#eval&quot;&gt;eval方法&lt;/a&gt;对SQLite 运行SQL命令。数据库，并在脚本的最后一行关闭数据库连接。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="51e427c04349f8bec5760358d6c76a33f48f0315" translate="yes" xml:space="preserve">
          <source>Below is a simple C program that demonstrates how to use the &lt;a href=&quot;c3ref/intro&quot;&gt;C/C++ interface&lt;/a&gt; to SQLite. The name of a database is given by the first argument and the second argument is one or more SQL statements to execute against the database. The function calls to pay attention to here are the call to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; on line 22 which opens the database, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; on line 28 that executes SQL commands against the database, and &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; on line 33 that closes the database connection.</source>
          <target state="translated">下面是一个简单的C程序，演示了如何使用&lt;a href=&quot;c3ref/intro&quot;&gt;C / C ++接口&lt;/a&gt;连接SQLite。数据库的名称由第一个参数指定，第二个参数是要针对该数据库执行的一个或多个SQL语句。这里要注意的函数调用是第22行的&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;打开数据库的调用，第28行的&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;对数据库执行SQL命令，第33行的&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;关闭数据库连接。</target>
        </trans-unit>
        <trans-unit id="14ff95327015619a83afc17706ad74370a046f84" translate="yes" xml:space="preserve">
          <source>Benefits of SQLite As A File Format</source>
          <target state="translated">SQLite作为文件格式的好处</target>
        </trans-unit>
        <trans-unit id="616211207d8aaf668be94882f808c6f4c9f8f380" translate="yes" xml:space="preserve">
          <source>Benefits of using WITHOUT ROWID</source>
          <target state="translated">使用WITHOUT ROWID的好处</target>
        </trans-unit>
        <trans-unit id="115df5f31354f3b89a7926f5d6643866714998ab" translate="yes" xml:space="preserve">
          <source>Better Applications</source>
          <target state="translated">更好的应用</target>
        </trans-unit>
        <trans-unit id="4f38499da00d33476ac2d33142547447ccd5f2e2" translate="yes" xml:space="preserve">
          <source>Better detection and handling of corrupt database files.</source>
          <target state="translated">更好的检测和处理损坏的数据库文件。</target>
        </trans-unit>
        <trans-unit id="add6069aec6aedde19e26e2f4dc8b5d52557685c" translate="yes" xml:space="preserve">
          <source>Better error reporting when problems occur during the automatic 2.5.6 to 2.6.0 database format upgrade.</source>
          <target state="translated">在2.5.6到2.6.0数据库格式自动升级过程中出现问题时,更好地报告错误。</target>
        </trans-unit>
        <trans-unit id="5c0db7dca50a13779a4f0032e6c97723feb41348" translate="yes" xml:space="preserve">
          <source>Better handling of aggregate queries where the aggregate functions are contained within subqueries.</source>
          <target state="translated">更好地处理集合函数包含在子查询中的集合查询。</target>
        </trans-unit>
        <trans-unit id="da084dd71de733c50c5b48104f01706c6f95c252" translate="yes" xml:space="preserve">
          <source>Better labels on column names of the result.</source>
          <target state="translated">在结果的列名上有更好的标签。</target>
        </trans-unit>
        <trans-unit id="03681c8056a98d5199927eacf80bcf86a612f164" translate="yes" xml:space="preserve">
          <source>Better optimization of some IN operator expressions.</source>
          <target state="translated">更好地优化了一些in运算符表达式。</target>
        </trans-unit>
        <trans-unit id="591ea8e488260fd421c2b234d660007536c8a620" translate="yes" xml:space="preserve">
          <source>Better support for file locking so that two or more processes (or threads) can access the same database simultaneously. More work needed in this area, though.</source>
          <target state="translated">更好地支持文件锁定,使两个或多个进程(或线程)可以同时访问同一个数据库。不过,在这方面还需要做更多的工作。</target>
        </trans-unit>
        <trans-unit id="edfa329825b8b1d38ad9507f28f42ef4366de8b4" translate="yes" xml:space="preserve">
          <source>Between them, the contents of the &quot;level&quot; and &quot;idx&quot; fields define the relative age of the segment b-tree. The smaller the value stored in the &quot;level&quot; field, the more recently the segment b-tree was created. If two segment b-trees are of the same &quot;level&quot;, the segment with the larger value stored in the &quot;idx&quot; column is more recent. The PRIMARY KEY constraint on the %_segdir table prevents any two segments from having the same value for both the &quot;level&quot; and &quot;idx&quot; fields.</source>
          <target state="translated">在它们之间,&quot;level &quot;和 &quot;idx &quot;字段的内容定义了段b树的相对年龄。&quot;level &quot;字段中存储的值越小,段b树创建的时间越晚。如果两个段b树的 &quot;级别 &quot;相同,那么在 &quot;idx &quot;列中存储的值较大的段是最近创建的。%_segdir表的PRIMARY KEY约束可以防止任何两个段在 &quot;level &quot;和 &quot;idx &quot;字段中的值相同。</target>
        </trans-unit>
        <trans-unit id="3a826f46e213d85c4e2bac37d6cf8440b8e199d0" translate="yes" xml:space="preserve">
          <source>Beware of deleting persistent journal files by any other means since the journal file might be hot, in which case deleting it will corrupt the corresponding database file.</source>
          <target state="translated">小心通过任何其他方式删除持久性日志文件,因为日志文件可能是热的,在这种情况下,删除它将损坏相应的数据库文件。</target>
        </trans-unit>
        <trans-unit id="bb96cbd05d1971e3d28050245a8829dd6b6aafd2" translate="yes" xml:space="preserve">
          <source>Binary operators</source>
          <target state="translated">二进制运算符</target>
        </trans-unit>
        <trans-unit id="d2ac1eab329712a8a9c96ce99d077a92e950ad90" translate="yes" xml:space="preserve">
          <source>Bind values to &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; using the sqlite3_bind_*() interfaces.</source>
          <target state="translated">使用sqlite3_bind _ *（）接口将值绑定到&lt;a href=&quot;../lang_expr#varparam&quot;&gt;参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8d99e3f4d2a89e533a8c574a3feaf717d81ec03" translate="yes" xml:space="preserve">
          <source>Bind values to &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; using the sqlite3_bind_*() interfaces.</source>
          <target state="translated">使用sqlite3_bind _ *（）接口将值绑定到&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e1661e468dacca4fb2103651a60de473fcaf35b" translate="yes" xml:space="preserve">
          <source>Binding Values To Prepared Statements</source>
          <target state="translated">绑定值到准备好的报表</target>
        </trans-unit>
        <trans-unit id="416ca5a10db41c1cbc8b3d0b2abf3f34e937f4af" translate="yes" xml:space="preserve">
          <source>Bindings are not cleared by the &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; routine. Unbound parameters are interpreted as NULL.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;例程不会清除绑定。未绑定的参数被解释为NULL。</target>
        </trans-unit>
        <trans-unit id="712e7456596b23817bd39e4145191dbf11698c78" translate="yes" xml:space="preserve">
          <source>Bindings are not cleared by the &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; routine. Unbound parameters are interpreted as NULL.</source>
          <target state="translated">&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;例程不会清除绑定。未绑定的参数被解释为NULL。</target>
        </trans-unit>
        <trans-unit id="309af9e25956170a810f78e3c71afc45e9766ccf" translate="yes" xml:space="preserve">
          <source>BitAnd</source>
          <target state="translated">BitAnd</target>
        </trans-unit>
        <trans-unit id="0c26c52f02ad0e8a5ab4b7954c846a924ecffb7e" translate="yes" xml:space="preserve">
          <source>BitNot</source>
          <target state="translated">BitNot</target>
        </trans-unit>
        <trans-unit id="f64578ede789cb16c75f551e17bc358c839da2a7" translate="yes" xml:space="preserve">
          <source>BitOr</source>
          <target state="translated">BitOr</target>
        </trans-unit>
        <trans-unit id="c24315eb20cc1f5a565ec08f29abab31c0925f1a" translate="yes" xml:space="preserve">
          <source>Blob</source>
          <target state="translated">Blob</target>
        </trans-unit>
        <trans-unit id="d309b3faf2ef71b6ca2ba079fca1c0074e7599d4" translate="yes" xml:space="preserve">
          <source>Blob containing the root node of the segment b-tree.</source>
          <target state="translated">包含b树段根节点的Blob。</target>
        </trans-unit>
        <trans-unit id="d284e53d53a1c613b92c33b3c974704b23b2a857" translate="yes" xml:space="preserve">
          <source>Block until the unlock-notify callback is invoked by another thread.</source>
          <target state="translated">封锁,直到解锁通知回调被另一个线程调用。</target>
        </trans-unit>
        <trans-unit id="c9ac379f83771407fb1e0d78aaf3f7b5adc6706f" translate="yes" xml:space="preserve">
          <source>Boolean Expressions</source>
          <target state="translated">布尔表达式</target>
        </trans-unit>
        <trans-unit id="c4e413aea96ae1ca804567104303036969e3a88f" translate="yes" xml:space="preserve">
          <source>Boolean datatype</source>
          <target state="translated">布尔型数据类型</target>
        </trans-unit>
        <trans-unit id="cb72c24cf8f622cb6c601ea54b18c1fb6181c3db" translate="yes" xml:space="preserve">
          <source>Boolean expression</source>
          <target state="translated">布尔型表达式</target>
        </trans-unit>
        <trans-unit id="275cc7006db94d75505db825dc5542aed9bfc26c" translate="yes" xml:space="preserve">
          <source>Borland</source>
          <target state="translated">Borland</target>
        </trans-unit>
        <trans-unit id="2198db2aa3b167004c136853d6cdd281fb62f84a" translate="yes" xml:space="preserve">
          <source>Borland Interbase does not support CASE expressions.</source>
          <target state="translated">Borland Interbase不支持CASE表达式。</target>
        </trans-unit>
        <trans-unit id="ddec281bbecd09ca0988545c1af57dbffaa268c1" translate="yes" xml:space="preserve">
          <source>Both UPDATE statements do exactly the same thing. (They generate identical &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt;.) But the first form, the row value form, seems to make it clearer that the intent of the statement is to swap the values in columns A and B.</source>
          <target state="translated">这两个UPDATE语句执行的操作完全相同。（它们生成相同的&lt;a href=&quot;opcode&quot;&gt;字节码&lt;/a&gt;。）但是第一种形式，即行值形式，似乎更清楚了该语句的意图是交换A和B列中的值。</target>
        </trans-unit>
        <trans-unit id="1dfb4c7d44434c0c4d4db97610721023fe7e4509" translate="yes" xml:space="preserve">
          <source>Both forms of the CASE expression use lazy, or short-circuit, evaluation.</source>
          <target state="translated">CASE表达式的两种形式都使用了懒惰,或者说是短路评价。</target>
        </trans-unit>
        <trans-unit id="bb63583b07e5e464e63e50a8a4cb32ce2f9c5978" translate="yes" xml:space="preserve">
          <source>Both methods for loading an extension allow you to specify the name of an entry point for the extension. You can leave this argument blank - passing in a NULL pointer for the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; C-language interface or omitting the second argument for the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL interface - and the extension loader logic will attempt to figure out the entry point on its own. It will first try the generic extension name &quot;sqlite3_extension_init&quot;. If that does not work, it constructs a entry point using the template &quot;sqlite3_X_init&quot; where the X is replaced by the lowercase equivalent of every ASCII character in the filename after the last &quot;/&quot; and before the first following &quot;.&quot; omitting the first three characters if they happen to be &quot;lib&quot;. So, for example, if the filename is &quot;/usr/lib/libmathfunc-4.8.so&quot; the entry point name would be &quot;sqlite3_mathfunc_init&quot;. Or if the filename is &quot;./SpellFixExt.dll&quot; then the entry point would be called &quot;sqlite3_spellfixext_init&quot;.</source>
          <target state="translated">两种加载扩展的方法都允许您指定扩展的入口点名称。您可以将此参数保留为空白-为&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt; C语言接口传递NULL指针，或者为&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt;省略第二个参数SQL接口-扩展加载程序逻辑将尝试自行找出入口点。它将首先尝试使用通用扩展名&amp;ldquo; sqlite3_extension_init&amp;rdquo;。如果这样不起作用，它将使用模板&amp;ldquo; sqlite3_X_init&amp;rdquo;构造一个入口点，其中X替换为文件名中最后一个&amp;ldquo; /&amp;rdquo;之后和之后的第一个&amp;ldquo;&amp;rdquo;之前的每个ASCII字符的小写字母。如果前三个字符恰好是&amp;ldquo; lib&amp;rdquo;，则将其省略。因此，例如，如果文件名是&amp;ldquo; /usr/lib/libmathfunc-4.8.so&amp;rdquo;，则入口点名称将是&amp;ldquo; sqlite3_mathfunc_init&amp;rdquo;。或者，如果文件名是&amp;ldquo; ./SpellFixExt.dll&amp;rdquo;，则入口点将称为&amp;ldquo; sqlite3_spellfixext_init&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="8d91ab9fdfa652980c96ceff09049c0ea85b3c70" translate="yes" xml:space="preserve">
          <source>Both of the RBU functions may be accomplished using SQLite's built-in SQL commands - RBU update via a series of &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; and &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; commands within a single transaction, and RBU vacuum by a single &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. The RBU module provides the following advantages over these simpler approaches:</source>
          <target state="translated">这两个RBU功能都可以使用SQLite的内置SQL命令来完成-通过单个事务中的一系列&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;，&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;和&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;命令进行RBU更新，以及通过单个&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令进行RBU清理。与这些较简单的方法相比，RBU模块具有以下优点：</target>
        </trans-unit>
        <trans-unit id="e0f6600d4e5a9c39fa518762238ad90dd63b65fb" translate="yes" xml:space="preserve">
          <source>Both of the above example queries would work fine without the acctchng_magnitude index. The acctchng_magnitude index index merely helps the queries to run faster, especially on databases where there are many entries in the table for each account.</source>
          <target state="translated">如果没有acctchng_magnitude索引,上述两个例子查询都可以正常运行。acctchng_magnitude索引只是帮助查询运行得更快,特别是在数据库中,每个账户的表有很多条目。</target>
        </trans-unit>
        <trans-unit id="7a2132ed90a9ffb07d66917a3fc0b34d8d92cac4" translate="yes" xml:space="preserve">
          <source>Both the TCL and TH3 test harnesses automatically track system resources and report resource leaks on &lt;u&gt;every&lt;/u&gt; test run. No special configuration or setup is required. The test harnesses are especially vigilant with regard to memory leaks. If a change causes a memory leak, the test harnesses will recognize this quickly. SQLite is designed to never leak memory, even after an exception such as an OOM error or disk I/O error. The test harnesses are zealous to enforce this.</source>
          <target state="translated">TCL和TH3测试工具都会自动跟踪系统资源，并在&lt;u&gt;每次&lt;/u&gt;测试运行时报告资源泄漏。无需特殊配置或设置。测试工具特别注意内存泄漏。如果更改导致内存泄漏，则测试工具将迅速识别出这种情况。 SQLite的设计即使在发生OOM错误或磁盘I / O错误之类的异常后也不会泄漏内存。测试工具热衷于执行此操作。</target>
        </trans-unit>
        <trans-unit id="0ad3d82720f17203691deee7f5777d99c121ae33" translate="yes" xml:space="preserve">
          <source>Both the WHEN clause and the trigger actions may access elements of the row being inserted, deleted or updated using references of the form &quot;NEW.</source>
          <target state="translated">WHEN子句和触发操作都可以使用 &quot;NEW.WHEN &quot;形式的引用来访问被插入、删除或更新的行的元素。</target>
        </trans-unit>
        <trans-unit id="f093637993a88624b64eec10be0614efea759e81" translate="yes" xml:space="preserve">
          <source>Both the pointer and the pointer type parameter to the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; interfaces are &quot;owned&quot; by the caller. In other words, the caller is responsible for ensuring that both values remain valid until after the last access via &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;和&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;接口的指针和指针类型参数均由调用者&amp;ldquo;拥有&amp;rdquo;。换句话说，调用方负责确保两个值保持有效，直到通过&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;进行最后一次访问之后。</target>
        </trans-unit>
        <trans-unit id="d575a966c9a089363bea2d3980a3ff66687213c3" translate="yes" xml:space="preserve">
          <source>Both virtual tables are read-only &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual tables&lt;/a&gt;. You use them by mentioning them directly in the FROM clause of a SELECT statement. They both require a single argument which is the SQL statement to be analyzed. For example:</source>
          <target state="translated">这两个虚拟表都是只读的&lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;同义虚拟表&lt;/a&gt;。您可以通过在SELECT语句的FROM子句中直接提及它们来使用它们。它们都需要一个参数，即要分析的SQL语句。例如：</target>
        </trans-unit>
        <trans-unit id="2992a96404e75efb9d5d247c72b5e6d63bb4aa3e" translate="yes" xml:space="preserve">
          <source>Boundary value tests</source>
          <target state="translated">边界值测试</target>
        </trans-unit>
        <trans-unit id="3145fd01726b003b2b97b5a9fb483277f3a90dd2" translate="yes" xml:space="preserve">
          <source>Branch coverage in SQLite is currently measured using &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt; with the &quot;-b&quot; option. First the test program is compiled using options &quot;-g -fprofile-arcs -ftest-coverage&quot; and then the test program is run. Then &quot;gcov -b&quot; is run to generate a coverage report. The coverage report is verbose and inconvenient to read, so the gcov-generated report is processed using some simple scripts to put it into a more human-friendly format. This entire process is automated using scripts, of course.</source>
          <target state="translated">当前使用&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt;和-b选项测量SQLite中的分支覆盖率。首先使用选项&amp;ldquo; -g -fprofile-arcs -ftest-coverage&amp;rdquo;编译测试程序，然后运行测试程序。然后运行&amp;ldquo; gcov -b&amp;rdquo;以生成覆盖率报告。覆盖率报告冗长且不便阅读，因此使用一些简单的脚本处理了由gcov生成的报告，并将其转换为更人性化的格式。当然，整个过程是使用脚本自动进行的。</target>
        </trans-unit>
        <trans-unit id="c4adfe3c542d88432092f783bc046835df0fe815" translate="yes" xml:space="preserve">
          <source>Branch coverage is more rigorous than statement coverage. Branch coverage measures the number of machine-code branch instructions that are evaluated at least once on both directions.</source>
          <target state="translated">分支覆盖率比语句覆盖率更严格。分支覆盖率衡量的是在两个方向上至少被评估一次的机器码分支指令的数量。</target>
        </trans-unit>
        <trans-unit id="a22b75ea309c645c4530e03f4541cb259f2d61c7" translate="yes" xml:space="preserve">
          <source>Branch coverage is more strict. With branch coverage, each test and each subblock within the statement is considered separately. In order to achieve 100% branch coverage in the example above, there must be at least three test cases:</source>
          <target state="translated">分支覆盖比较严格。在分支覆盖的情况下,每个测试和语句内的每个子块都要单独考虑。为了达到上面例子中100%的分支覆盖率,必须至少有三个测试用例。</target>
        </trans-unit>
        <trans-unit id="97c730065aaff2da27316c3a4fdb27f33630fd48" translate="yes" xml:space="preserve">
          <source>Break out the &quot;Presentor Notes&quot; from each slide into a separate table, for easier access from third-party applications and/or scripts.</source>
          <target state="translated">将每张幻灯片中的 &quot;演示者笔记 &quot;分成一个单独的表格,以便于从第三方应用程序和/或脚本访问。</target>
        </trans-unit>
        <trans-unit id="c53bff6ff25ebaccf14a4078fdb0261d0ccc01ee" translate="yes" xml:space="preserve">
          <source>Break out the GDBM driver into a separate file in anticipation to added new drivers.</source>
          <target state="translated">将GDBM驱动程序分解成一个单独的文件,以期待增加新的驱动程序。</target>
        </trans-unit>
        <trans-unit id="282c5dfb378bb6abed7a208812bdb6a15f29a876" translate="yes" xml:space="preserve">
          <source>Bring the OS/2 porting layer up-to-date.</source>
          <target state="translated">将OS/2移植层更新。</target>
        </trans-unit>
        <trans-unit id="82e575ff594a72cfcaccd19ccbf9ad35b704bb47" translate="yes" xml:space="preserve">
          <source>Bring the processing of ORDER BY into compliance with the SQL standard for case where a result alias and a table column name are in conflict. Correct behavior is to prefer the result alias. Older versions of SQLite incorrectly picked the table column. (See ticket #2822.)</source>
          <target state="translated">在结果别名和表列名冲突的情况下,使ORDER BY的处理符合SQL标准。正确的行为是选择结果别名。旧版本的SQLite错误地选择了表列。(参见票据#2822。)</target>
        </trans-unit>
        <trans-unit id="4f04fd57f5bfebe96a862aebe73b135def3ab6df" translate="yes" xml:space="preserve">
          <source>Bug fix in the processing of the ORDER BY clause for GROUP BY queries</source>
          <target state="translated">修正在处理GROUP BY查询的ORDER BY子句时的错误。</target>
        </trans-unit>
        <trans-unit id="a725ca76655ec9003bb82b1a676029a85c0e7d07" translate="yes" xml:space="preserve">
          <source>Bug fix: &quot;SELECT count(*)&quot; was returning NULL for empty tables. Now it returns 0.</source>
          <target state="translated">错误修正:&quot;SELECT count(*)&quot;对空表返回NULL。现在它返回0。</target>
        </trans-unit>
        <trans-unit id="9e476047ffbbf1baca852a2317f6d224dd2d875a" translate="yes" xml:space="preserve">
          <source>Bug fix: Add in a mutex that was omitted from the previous release.</source>
          <target state="translated">错误修复。增加了上一个版本中遗漏的mutex。</target>
        </trans-unit>
        <trans-unit id="ab7e0eb1f7494f905f4da13b15772e1fb07bbe1e" translate="yes" xml:space="preserve">
          <source>Bug fix: An assertion was failing if &quot;PRAGMA full_column_names=ON;&quot; was set and you did a query that used a rowid, like this: &quot;SELECT rowid, * FROM ...&quot;.</source>
          <target state="translated">错误修正。如果设置了 &quot;PRAGMA full_column_names=ON;&quot;,并且你做了一个使用rowid的查询,比如:&quot;SELECT rowid,*FROM ...&quot;。</target>
        </trans-unit>
        <trans-unit id="421117f09c1ef6c1c766b17bffc8c48c0d11cebc" translate="yes" xml:space="preserve">
          <source>Bug fix: An assertion was failing when a temporary table with an index had the same name as a permanent table created by a separate process.</source>
          <target state="translated">错误修正。当一个带有索引的临时表与一个单独进程创建的永久表名称相同时,断言失败。</target>
        </trans-unit>
        <trans-unit id="0dceede8b9155b23f776e96cfdf9ce26f1c18497" translate="yes" xml:space="preserve">
          <source>Bug fix: An attempt to delete a single row of a table with a WHERE clause of &quot;ROWID=x&quot; when no such rowid exists was causing an error.</source>
          <target state="translated">错误修正。当表的WHERE子句 &quot;ROWID=x &quot;不存在时,试图删除该表的单行会导致错误。</target>
        </trans-unit>
        <trans-unit id="faaa0c6caea2e40fd936178cd8a1148168d7f164" translate="yes" xml:space="preserve">
          <source>Bug fix: Avoid a deadlock or crash if the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt;, &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;, and the SQLite Encryption Extension are all used at once.</source>
          <target state="translated">错误修复：如果同时使用&lt;a href=&quot;backup&quot;&gt;备份API&lt;/a&gt;，&lt;a href=&quot;sharedcache&quot;&gt;共享缓存&lt;/a&gt;和SQLite加密扩展，可以避免死锁或崩溃。</target>
        </trans-unit>
        <trans-unit id="c9851f7cc2ef1b47f1ede36a70787a28d8a73936" translate="yes" xml:space="preserve">
          <source>Bug fix: Avoid leaking memory on LIMIT and OFFSET clauses in deeply nested UNION ALL queries.</source>
          <target state="translated">错误修复。避免在深度嵌套的UNION ALL查询中,LIMIT和OFFSET子句泄漏内存。</target>
        </trans-unit>
        <trans-unit id="eb351871f180a85fd09c35dd04ce4b51eee599a0" translate="yes" xml:space="preserve">
          <source>Bug fix: Avoid segfault when using the &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt; inside of a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt; or &lt;a href=&quot;lang_createview&quot;&gt;view&lt;/a&gt; in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;.</source>
          <target state="translated">错误修复：在&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK约束中&lt;/a&gt;使用&lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE运算符&lt;/a&gt;或在&lt;a href=&quot;sharedcache&quot;&gt;共享缓存模式下&lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;查看&lt;/a&gt;时，避免出现段错误。</target>
        </trans-unit>
        <trans-unit id="a618ecebefb94412f1562472983ff94e3605eaab" translate="yes" xml:space="preserve">
          <source>Bug fix: Avoid various concurrency problems in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;.</source>
          <target state="translated">错误修复：避免在&lt;a href=&quot;sharedcache&quot;&gt;共享缓存模式下发生&lt;/a&gt;各种并发问题。</target>
        </trans-unit>
        <trans-unit id="633b128d954ff36563e10076bd92bfc7d4d254bc" translate="yes" xml:space="preserve">
          <source>Bug fix: Bare identifiers in ORDER BY clauses bind more tightly to output column names, but identifiers in expressions bind more tightly to input column names. Identifiers in GROUP BY clauses always prefer output column names, however.</source>
          <target state="translated">错误修正。ORDER BY子句中的裸标识符与输出列名结合得更紧密,但表达式中的标识符与输入列名结合得更紧密。然而,GROUP BY子句中的标识符总是倾向于输出列名。</target>
        </trans-unit>
        <trans-unit id="6a402a829e3faf4148ff927e5cc1ab64a56cfa4a" translate="yes" xml:space="preserve">
          <source>Bug fix: Column names in the result set were not being generated correctly for some (rather complex) VIEWs. This could cause a segfault under certain circumstances.</source>
          <target state="translated">错误修正。对于某些(相当复杂的)视图,结果集中的列名没有正确生成。在某些情况下,这可能会导致segfault。</target>
        </trans-unit>
        <trans-unit id="a6507d4034fca406ed1e6de7d9c69eb86666298e" translate="yes" xml:space="preserve">
          <source>Bug fix: Compute correct table names with the FULL_COLUMN_NAMES pragma is turned on.</source>
          <target state="translated">错误修正。开启FULL_COLUMN_NAMES pragma后,计算正确的表名。</target>
        </trans-unit>
        <trans-unit id="d170d4831a6701524951017930d51215c0de3ceb" translate="yes" xml:space="preserve">
          <source>Bug fix: Compute the correct answer for queries that contain an IS NOT NULL term in the WHERE clause and also contain an OR term in the WHERE clause and are compiled with &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;. &lt;a href=&quot;http://www.sqlite.org/src/info/4c86b126f2&quot;&gt;Ticket [4c86b126f2]&lt;/a&gt;</source>
          <target state="translated">错误修复：为在WHERE子句中包含IS NOT NULL项并且在WHERE子句中也包含OR项并使用&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;编译的查询计算正确答案。&lt;a href=&quot;http://www.sqlite.org/src/info/4c86b126f2&quot;&gt;门票[4c86b126f2]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cd687a21a635b7863c87339ca87e775aa679cddf" translate="yes" xml:space="preserve">
          <source>Bug fix: Compute the correct answer for queries that contain an IS NOT NULL term in the WHERE clause and also contain an OR term in the WHERE clause and are compiled with &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;. &lt;a href=&quot;https://www.sqlite.org/src/info/4c86b126f2&quot;&gt;Ticket [4c86b126f2]&lt;/a&gt;</source>
          <target state="translated">漏洞修复：为在WHERE子句中包含IS NOT NULL项并且在WHERE子句中包含OR项并使用&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;编译的查询计算正确答案。&lt;a href=&quot;https://www.sqlite.org/src/info/4c86b126f2&quot;&gt;门票[4c86b126f2]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e9fa36344bc0f04a7e81c8fa8066aa6b76c8c72" translate="yes" xml:space="preserve">
          <source>Bug fix: Correctly handle functions that appear in the WHERE clause of a join.</source>
          <target state="translated">错误修正。正确处理连接中WHERE子句中出现的函数。</target>
        </trans-unit>
        <trans-unit id="b19417477425f028b30221d15629f2e13bb03e35" translate="yes" xml:space="preserve">
          <source>Bug fix: Correctly handle terms in the WHERE clause of a join that do not contain a comparison operator.</source>
          <target state="translated">错误修正。正确处理连接的WHERE子句中不包含比较操作符的术语。</target>
        </trans-unit>
        <trans-unit id="f1c7035443112823f2488a80b27044cd7dc930ca" translate="yes" xml:space="preserve">
          <source>Bug fix: Creating and dropping a table all within a single transaction was not working.</source>
          <target state="translated">错误修复。在单一事务中创建和删除一个表的做法行不通。</target>
        </trans-unit>
        <trans-unit id="a65ee45495a64aa4ac7b00532e7dcdea10a45c93" translate="yes" xml:space="preserve">
          <source>Bug fix: DISTINCT now recognizes that a &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; and a blob of all 0x00 bytes are the same thing. &lt;a href=&quot;http://www.sqlite.org/src/info/fccbde530a&quot;&gt;Ticket [fccbde530a]&lt;/a&gt;</source>
          <target state="translated">错误修复：DISTINCT现在可以识别出一个&lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;0blob&lt;/a&gt;和一个全0x00字节的blob是同一件事。&lt;a href=&quot;http://www.sqlite.org/src/info/fccbde530a&quot;&gt;门票[fccbde530a]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fa5e4bc2c47220c375bd94c966132cb655e5fc42" translate="yes" xml:space="preserve">
          <source>Bug fix: DISTINCT now recognizes that a &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; and a blob of all 0x00 bytes are the same thing. &lt;a href=&quot;https://www.sqlite.org/src/info/fccbde530a&quot;&gt;Ticket [fccbde530a]&lt;/a&gt;</source>
          <target state="translated">错误修复：DISTINCT现在可以识别出一个&lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;0blob&lt;/a&gt;和一个全0x00字节的blob是同一件事。&lt;a href=&quot;https://www.sqlite.org/src/info/fccbde530a&quot;&gt;门票[fccbde530a]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e1c19457c6bcac61af13a07643a50b8996bac51" translate="yes" xml:space="preserve">
          <source>Bug fix: DROP TABLE followed by a CREATE TABLE with the same name all within a single transaction was causing a coredump.</source>
          <target state="translated">错误修复。DROP TABLE和CREATE TABLE之后的同名表在一个事务中会导致coredump.</target>
        </trans-unit>
        <trans-unit id="ba00de2c0632584e59e348681ca42b12b644bcbe" translate="yes" xml:space="preserve">
          <source>Bug fix: Database corruption can occur due to the optimization that was introduced in version 2.4.0 (check-in [410]). The problem should now be fixed. The use of versions 2.4.0 through 2.5.2 is not recommended.</source>
          <target state="translated">错误修正。由于在2.4.0版本中引入的优化,可能会发生数据库损坏(签入[410])。这个问题现在应该已经解决了。不建议使用2.4.0至2.5.2版本。</target>
        </trans-unit>
        <trans-unit id="bbe70e0c57d51f533365c58d207cdfb57683c5ef" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not allow a virtual table to cancel the ORDER BY clause unless all outer loops are guaranteed to return no more than one row result. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/ba82a4a41eac1&quot;&gt;ba82a4a41eac1&lt;/a&gt;.</source>
          <target state="translated">漏洞修复：除非保证所有外部循环都返回不超过一行的结果，否则不允许虚拟表取消ORDER BY子句。门票&lt;a href=&quot;http://www.sqlite.org/src/info/ba82a4a41eac1&quot;&gt;ba82a4a41eac1&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1cc18b5a28fcdf32cbf54723026bd95757797125" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not allow a virtual table to cancel the ORDER BY clause unless all outer loops are guaranteed to return no more than one row result. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/ba82a4a41eac1&quot;&gt;ba82a4a41eac1&lt;/a&gt;.</source>
          <target state="translated">漏洞修复：除非保证所有外部循环都返回不超过一行的结果，否则不允许虚拟表取消ORDER BY子句。门票&lt;a href=&quot;https://www.sqlite.org/src/info/ba82a4a41eac1&quot;&gt;ba82a4a41eac1&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c3b898a085ef4e9fd7492842026dc724b1316d2" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not attempt the subquery flattening optimization on queries that lack a FROM clause. To do so causes a segfault.</source>
          <target state="translated">错误修复。不要对缺乏FROM子句的查询尝试子查询扁平化优化。这样做会导致segfault。</target>
        </trans-unit>
        <trans-unit id="c7d832b024aa33f5c367340914044de719478c03" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not automatically remove the DISTINCT keyword from a SELECT that forms the right-hand side of an IN operator since it is necessary if the SELECT also contains a LIMIT. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/db87229497&quot;&gt;db87229497&lt;/a&gt;.</source>
          <target state="translated">错误修复：不要从构成IN运算符右侧的SELECT中自动删除DISTINCT关键字，因为如果SELECT也包含LIMIT，则很有必要。票证&lt;a href=&quot;http://www.sqlite.org/src/info/db87229497&quot;&gt;db87229497&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b613fbd42e65c294ec90bc48e2cacf69fa5bf2d7" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not automatically remove the DISTINCT keyword from a SELECT that forms the right-hand side of an IN operator since it is necessary if the SELECT also contains a LIMIT. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/db87229497&quot;&gt;db87229497&lt;/a&gt;.</source>
          <target state="translated">错误修复：不要从构成IN运算符右侧的SELECT中自动删除DISTINCT关键字，因为如果SELECT也包含LIMIT，则很有必要。票证&lt;a href=&quot;https://www.sqlite.org/src/info/db87229497&quot;&gt;db87229497&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4ec8b17071def3e40c2a66c3efc8f85f8fbeb60d" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not discard the DISTINCT as superfluous unless a subset of the result set is subject to a UNIQUE constraint &lt;em&gt;and&lt;/em&gt; it none of the columns in that subset can be NULL. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/385a5b56b9&quot;&gt;385a5b56b9&lt;/a&gt;.</source>
          <target state="translated">错误修复：不要将DISTINCT视为多余的，除非结果集的子集受到UNIQUE约束，&lt;em&gt;并且&lt;/em&gt;该子集中的任何列都不能为NULL。机票&lt;a href=&quot;http://www.sqlite.org/src/info/385a5b56b9&quot;&gt;385a5b56b9&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f84ca0e660367a041f8dca21a200d8ca5d8f8e8c" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not discard the DISTINCT as superfluous unless a subset of the result set is subject to a UNIQUE constraint &lt;em&gt;and&lt;/em&gt; it none of the columns in that subset can be NULL. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/385a5b56b9&quot;&gt;385a5b56b9&lt;/a&gt;.</source>
          <target state="translated">错误修复：不要将DISTINCT视为多余的，除非结果集的子集受到UNIQUE约束，&lt;em&gt;并且&lt;/em&gt;该子集中的任何列都不能为NULL。机票&lt;a href=&quot;https://www.sqlite.org/src/info/385a5b56b9&quot;&gt;385a5b56b9&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d122c8d80295b61ea78f7985674ee07265e9fe63" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not move WHERE clause terms inside OR expressions that are contained within an ON clause of a LEFT JOIN. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/f2369304e4&quot;&gt;f2369304e4&lt;/a&gt;</source>
          <target state="translated">漏洞修复：请勿在LEFT JOIN的ON子句中包含的OR表达式内移动WHERE子句项。门票&lt;a href=&quot;http://www.sqlite.org/src/info/f2369304e4&quot;&gt;f2369304e4&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="882c57714104eacf417d463ca1238dea40634a6d" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not move WHERE clause terms inside OR expressions that are contained within an ON clause of a LEFT JOIN. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f2369304e4&quot;&gt;f2369304e4&lt;/a&gt;</source>
          <target state="translated">错误修复：请勿在LEFT JOIN的ON子句中包含的OR表达式内移动WHERE子句项。门票&lt;a href=&quot;https://www.sqlite.org/src/info/f2369304e4&quot;&gt;f2369304e4&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2b3ae0e3595ba9969a417594021c4332e3d08633" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not optimize away an ORDER BY clause that has the same terms as a UNIQUE index unless those terms are also NOT NULL. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/2a5629202f&quot;&gt;2a5629202f&lt;/a&gt;.</source>
          <target state="translated">错误修复：不要优化与UNIQUE索引具有相同术语的ORDER BY子句，除非这些术语也不为NULL。票&lt;a href=&quot;http://www.sqlite.org/src/info/2a5629202f&quot;&gt;2a5629202f&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="12ab8658ddf95585fe781caf93bddaf3220a8fc8" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not optimize away an ORDER BY clause that has the same terms as a UNIQUE index unless those terms are also NOT NULL. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/2a5629202f&quot;&gt;2a5629202f&lt;/a&gt;.</source>
          <target state="translated">错误修复：不要优化与UNIQUE索引具有相同术语的ORDER BY子句，除非这些术语也不为NULL。机票&lt;a href=&quot;https://www.sqlite.org/src/info/2a5629202f&quot;&gt;2a5629202f&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6453e25436ce2c11dc1b6194ae2dc12f5ca5250" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not suppress the ORDER BY clause on a virtual table query if an IN constraint is used. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/f69b96e3076e&quot;&gt;f69b96e3076e&lt;/a&gt;.</source>
          <target state="translated">漏洞修复：如果使用IN约束，请不要在虚拟表查询上隐藏ORDER BY子句。机票&lt;a href=&quot;http://www.sqlite.org/src/info/f69b96e3076e&quot;&gt;f69b96e3076e&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1726c21611f3d5988771fb5e52d6115f2bcc60d" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not suppress the ORDER BY clause on a virtual table query if an IN constraint is used. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f69b96e3076e&quot;&gt;f69b96e3076e&lt;/a&gt;.</source>
          <target state="translated">漏洞修复：如果使用IN约束，请不要在虚拟表查询上隐藏ORDER BY子句。机票&lt;a href=&quot;https://www.sqlite.org/src/info/f69b96e3076e&quot;&gt;f69b96e3076e&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f89fece6f5c7d025fca0afff2d5506eaef79c01" translate="yes" xml:space="preserve">
          <source>Bug fix: Ensure that &quot;ORDER BY random()&quot; clauses do not get optimized out. &lt;a href=&quot;http://www.sqlite.org/src/info/65bdeb9739&quot;&gt;Ticket [65bdeb9739]&lt;/a&gt;</source>
          <target state="translated">错误修复：确保&amp;ldquo; ORDER BY random（）&amp;rdquo;子句不会被优化。&lt;a href=&quot;http://www.sqlite.org/src/info/65bdeb9739&quot;&gt;机票[65bdeb9739]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b6be8cd4e09eaa8fd9a342399eae3e67dfbbc0ab" translate="yes" xml:space="preserve">
          <source>Bug fix: Ensure that &quot;ORDER BY random()&quot; clauses do not get optimized out. &lt;a href=&quot;https://www.sqlite.org/src/info/65bdeb9739&quot;&gt;Ticket [65bdeb9739]&lt;/a&gt;</source>
          <target state="translated">错误修复：确保&amp;ldquo; ORDER BY random（）&amp;rdquo;子句不会被优化。&lt;a href=&quot;https://www.sqlite.org/src/info/65bdeb9739&quot;&gt;机票[65bdeb9739]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad5b813b289d7e750591bfb845e4ba940a74acee" translate="yes" xml:space="preserve">
          <source>Bug fix: Ensure the cached KeyInfo objects (an internal abstraction not visible to the application) do not go stale when operating in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; and frequently closing and reopening some database connections while leaving other database connections on the same shared cache open continuously. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/e4a18565a36884b00edf&quot;&gt;e4a18565a36884b00edf&lt;/a&gt;.</source>
          <target state="translated">错误修复：确保在&lt;a href=&quot;sharedcache&quot;&gt;共享缓存模式下操作&lt;/a&gt;并频繁关闭和重新打开某些数据库连接，同时使同一共享缓存上的其他数据库连接连续打开时，缓存的KeyInfo对象（对应用程序不可见的内部抽象）不会失效。票证&lt;a href=&quot;https://www.sqlite.org/src/info/e4a18565a36884b00edf&quot;&gt;e4a18565a36884b00edf&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1c94982c68fc72ac2f6ac980a3323226e84f8466" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix a 32-bit overflow problem on CREATE INDEX for databases larger than 16GB.</source>
          <target state="translated">错误修复。修正16GB以上数据库CREATE INDEX的32位溢出问题。</target>
        </trans-unit>
        <trans-unit id="b6580b5e5232c84824bf613c858acbb24fc5f483" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix a potential &lt;b&gt;database corruption bug&lt;/b&gt; in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; when one &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is closed while another is in the middle of a write transaction. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/e636a050b7&quot;&gt;e636a050b7&lt;/a&gt;</source>
          <target state="translated">Bug修复：修复潜在的&lt;b&gt;数据库损坏错误&lt;/b&gt;在&lt;a href=&quot;sharedcache&quot;&gt;共享缓存模式&lt;/a&gt;，当一个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;被关闭，而另一个是在写事务的中间。门票&lt;a href=&quot;http://www.sqlite.org/src/info/e636a050b7&quot;&gt;E636A050B7&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c8f2d7c3265ac4e7cc9ee2d87ca58cf5b4a39f5c" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix a potential &lt;b&gt;database corruption bug&lt;/b&gt; in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; when one &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is closed while another is in the middle of a write transaction. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/e636a050b7&quot;&gt;e636a050b7&lt;/a&gt;</source>
          <target state="translated">[修正]修正了一个潜在的&lt;b&gt;数据库损坏错误&lt;/b&gt;在&lt;a href=&quot;sharedcache&quot;&gt;共享缓存模式&lt;/a&gt;，当一个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;被关闭，而另一个是在写事务的中间。门票&lt;a href=&quot;https://www.sqlite.org/src/info/e636a050b7&quot;&gt;E636A050B7&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="28f644aa67590d02891787c2b2d9de10e303faef" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix an assertion failure that occurred when ROWID was a column in a SELECT statement on a view.</source>
          <target state="translated">错误修复。修正当ROWID是视图上SELECT语句中的一列时发生的断言失败。</target>
        </trans-unit>
        <trans-unit id="6de63655427b8362357e0b9729e0309dea102b68" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix an uninitialized variable in the VDBE that would could an assert failure.</source>
          <target state="translated">错误修复。修正了VDBE中一个未初始化的变量,会导致断言失败。</target>
        </trans-unit>
        <trans-unit id="15567e970418f92d21404d2b997ca55ed7870f2d" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix column default values expressions of the form &quot;DEFAULT(-(-9223372036854775808))&quot; so that they work correctly, initializing the column to a floating point value approximately equal to +9223372036854775808.0.</source>
          <target state="translated">错误修复。修正 &quot;DEFAULT(-(-9223372036854775808))&quot;形式的列缺省值表达式,使其正确工作,将列初始化为约等于+9223372036854775808.0的浮点值。</target>
        </trans-unit>
        <trans-unit id="b572be392d93fe8f8aa3c731cb70e9adb855b95a" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix the &lt;a href=&quot;lang_corefunc#char&quot;&gt;char()&lt;/a&gt; SQL function so that it returns an empty string rather than an &quot;out of memory&quot; error when called with zero arguments.</source>
          <target state="translated">错误修复：修复&lt;a href=&quot;lang_corefunc#char&quot;&gt;char（）&lt;/a&gt; SQL函数，以使其在使用零参数调用时返回空字符串，而不是&amp;ldquo;内存不足&amp;rdquo;错误。</target>
        </trans-unit>
        <trans-unit id="ec8ef57ae219363ebc2f9d36c425f7585ca571b1" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix the &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; command so that it does not cancel pending queries. This repairs a problem introduced in 3.7.11.</source>
          <target state="translated">错误修复：修复了&lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt;命令，使其不会取消挂起的查询。这修复了3.7.11中引入的问题。</target>
        </trans-unit>
        <trans-unit id="df416fd402ae79122987fd712ad3deeb5c8f5458" translate="yes" xml:space="preserve">
          <source>Bug fix: Generate correct column headers when a compound SELECT is used as a subquery.</source>
          <target state="translated">错误修正。当复合SELECT被用作子查询时,生成正确的列头。</target>
        </trans-unit>
        <trans-unit id="8607f97a039e79f9d7bbfb840d1dbfffbf0765f7" translate="yes" xml:space="preserve">
          <source>Bug fix: In the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; CSV import feature, do not end a field when an escaped double-quote occurs at the end of a CRLN line.</source>
          <target state="translated">错误修复：在&lt;a href=&quot;cli&quot;&gt;命令行Shell&lt;/a&gt; CSV导入功能中，当CRLN行的末尾出现转义的双引号时，请勿结束字段。</target>
        </trans-unit>
        <trans-unit id="d77f01bc12cfaa192da17d51a33bb2f997769b11" translate="yes" xml:space="preserve">
          <source>Bug fix: In the &lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt; tokenizer of &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;, treat all private code points as identifier symbols.</source>
          <target state="translated">错误修复：在&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;的&lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt;令牌生成器中，将所有私有代码点都视为标识符符号。</target>
        </trans-unit>
        <trans-unit id="fc0e959c372e361cf7f33ef8b8f20d674104ba00" translate="yes" xml:space="preserve">
          <source>Bug fix: Issue an error message if the 16-bit reference counter on a view overflows due to an overly complex query.</source>
          <target state="translated">错误修复。如果由于过于复杂的查询导致视图上的16位参考计数器溢出,会发出错误信息。</target>
        </trans-unit>
        <trans-unit id="796cd2d86e5fad8940076a58510533a97b2c56bf" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure &quot;rowid&quot; columns are correctly resolved in joins between normal tables and WITHOUT ROWID tables. &lt;a href=&quot;http://www.sqlite.org/src/info/c34d0557f7&quot;&gt;Ticket [c34d0557f7]&lt;/a&gt;</source>
          <target state="translated">错误修复：确保正常表和WITHOUT ROWID表之间的联接中的&amp;ldquo; rowid&amp;rdquo;列得到正确解析。&lt;a href=&quot;http://www.sqlite.org/src/info/c34d0557f7&quot;&gt;机票[c34d0557f7]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="130da33e2ad051b8740f6ed907ea222fbc760936" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure &quot;rowid&quot; columns are correctly resolved in joins between normal tables and WITHOUT ROWID tables. &lt;a href=&quot;https://www.sqlite.org/src/info/c34d0557f7&quot;&gt;Ticket [c34d0557f7]&lt;/a&gt;</source>
          <target state="translated">错误修复：确保正常表和WITHOUT ROWID表之间的联接中的&amp;ldquo; rowid&amp;rdquo;列已正确解析。&lt;a href=&quot;https://www.sqlite.org/src/info/c34d0557f7&quot;&gt;机票[c34d0557f7]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="adf0baa27394f8041aaae283cf02f3ee1bfa8b41" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements appear in &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; output.</source>
          <target state="translated">错误修复：确保&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;语句出现在&lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace（）&lt;/a&gt;输出中。</target>
        </trans-unit>
        <trans-unit id="2334a8bc658fa8a7b723fcf78436e06aa632b55a" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure an error is always reported when attempting to preform an operation that requires a &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; that is missing. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/0fc59f908b&quot;&gt;0fc59f908b&lt;/a&gt;</source>
          <target state="translated">错误修复：尝试执行需要缺少&lt;a href=&quot;datatype3#collation&quot;&gt;排序顺序&lt;/a&gt;的操作时，请确保始终报告错误。票证&lt;a href=&quot;http://www.sqlite.org/src/info/0fc59f908b&quot;&gt;0FC59F908B&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d8b01c3ac39895ed5adece1b3c66094a24c6beea" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure an error is always reported when attempting to preform an operation that requires a &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; that is missing. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/0fc59f908b&quot;&gt;0fc59f908b&lt;/a&gt;</source>
          <target state="translated">错误修复：尝试执行需要缺少&lt;a href=&quot;datatype3#collation&quot;&gt;排序顺序&lt;/a&gt;的操作时，请确保始终报告错误。票证&lt;a href=&quot;https://www.sqlite.org/src/info/0fc59f908b&quot;&gt;0fc59f908b&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7b7a3c06c81b08010533a335b71314ea1246750e" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure that NULL results from OP_Column are fully and completely NULL and do not have the MEM_Ephem bit set. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/094d39a4c95ee4&quot;&gt;094d39a4c95ee4&lt;/a&gt;.</source>
          <target state="translated">错误修复：确保OP_Column的NULL结果完全完全为NULL，并且未设置MEM_Ephem位。机票&lt;a href=&quot;http://www.sqlite.org/src/info/094d39a4c95ee4&quot;&gt;094d39a4c95ee4&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bbe9cc8cf4d0e37f68b76d98ac105047f3dcabc6" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure that NULL results from OP_Column are fully and completely NULL and do not have the MEM_Ephem bit set. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/094d39a4c95ee4&quot;&gt;094d39a4c95ee4&lt;/a&gt;.</source>
          <target state="translated">错误修复：确保OP_Column的NULL结果完全完全为NULL，并且未设置MEM_Ephem位。机票&lt;a href=&quot;https://www.sqlite.org/src/info/094d39a4c95ee4&quot;&gt;094d39a4c95ee4&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b6a649b8a7464f814f81388b6be52f54e12c25e" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure the journal file directory entry is committed to disk before writing the database file.</source>
          <target state="translated">错误修复。确保在写入数据库文件之前,日志文件目录条目已提交到磁盘。</target>
        </trans-unit>
        <trans-unit id="e185f43b49a3251f6e6597892c2f724efa586d32" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure the same temporary registers are not used in concurrent co-routines used to implement compound SELECT statements containing ORDER BY clauses, as such use can lead to incorrect answers. &lt;a href=&quot;http://www.sqlite.org/src/info/8c63ff0eca&quot;&gt;Ticket [8c63ff0eca]&lt;/a&gt;</source>
          <target state="translated">错误修复：确保用于实现包含ORDER BY子句的复合SELECT语句的并发协同例程中未使用相同的临时寄存器，因为这样使用会导致错误的答案。&lt;a href=&quot;http://www.sqlite.org/src/info/8c63ff0eca&quot;&gt;门票[8c63ff0eca]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="19fb768363345e80c516bffa6c071789c4c37aa6" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure the same temporary registers are not used in concurrent co-routines used to implement compound SELECT statements containing ORDER BY clauses, as such use can lead to incorrect answers. &lt;a href=&quot;https://www.sqlite.org/src/info/8c63ff0eca&quot;&gt;Ticket [8c63ff0eca]&lt;/a&gt;</source>
          <target state="translated">错误修复：确保用于实现包含ORDER BY子句的复合SELECT语句的并发协同例程中未使用相同的临时寄存器，因为这样使用会导致错误的答案。&lt;a href=&quot;https://www.sqlite.org/src/info/8c63ff0eca&quot;&gt;门票[8c63ff0eca]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="51326d84193d9019e013ecb68f17ddd96b5b7cd8" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure the schema is up-to-date prior to running pragmas table_info, index_list, index_info, and foreign_key_list.</source>
          <target state="translated">错误修复。在运行 pragmas table_info、index_list、index_info 和 foreign_key_list 之前,确保模式是最新的。</target>
        </trans-unit>
        <trans-unit id="21876ec37a821c06e59ab2273c8a26e3a12144f2" translate="yes" xml:space="preserve">
          <source>Bug fix: Makes sure the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer&lt;/a&gt; callback gets a valid pointer to the string &quot;ROWID&quot; for the column-name parameter when doing an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; that changes the rowid. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/0eb70d77cb05bb2272&quot;&gt;0eb70d77cb05bb2272&lt;/a&gt;</source>
          <target state="translated">错误修复：在执行更改行标识的&lt;a href=&quot;lang_update&quot;&gt;UPDATE时&lt;/a&gt;，请确保&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;授权者&lt;/a&gt;回调获得指向列名参数字符串&amp;ldquo; ROWID&amp;rdquo;的有效指针。门票&lt;a href=&quot;http://www.sqlite.org/src/info/0eb70d77cb05bb2272&quot;&gt;0eb70d77cb05bb2272&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9eb9470084b6b53829337f7c3a518a7d5c84c4cd" translate="yes" xml:space="preserve">
          <source>Bug fix: Makes sure the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer&lt;/a&gt; callback gets a valid pointer to the string &quot;ROWID&quot; for the column-name parameter when doing an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; that changes the rowid. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/0eb70d77cb05bb2272&quot;&gt;0eb70d77cb05bb2272&lt;/a&gt;</source>
          <target state="translated">错误修复：在执行更改行标识符的&lt;a href=&quot;lang_update&quot;&gt;UPDATE时&lt;/a&gt;，请确保&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;授权者&lt;/a&gt;回调获得指向列名称参数字符串&amp;ldquo; ROWID&amp;rdquo;的有效指针。门票&lt;a href=&quot;https://www.sqlite.org/src/info/0eb70d77cb05bb2272&quot;&gt;0eb70d77cb05bb2272&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fa2f91d43fa97f1a5999350e4addb5cbb3edaca1" translate="yes" xml:space="preserve">
          <source>Bug fix: Only consider AS names from the result set as candidates for resolving identifiers in the WHERE clause if there are no other matches. In the ORDER BY clause, AS names take priority over any column names. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/2500cdb9be05&quot;&gt;2500cdb9be05&lt;/a&gt;</source>
          <target state="translated">漏洞修复：如果没有其他匹配项，则仅将结果集中的AS名称视为WHERE子句中解析标识符的候选者。在ORDER BY子句中，AS名称优先于任何列名称。门票&lt;a href=&quot;http://www.sqlite.org/src/info/2500cdb9be05&quot;&gt;2500cdb9be05&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="58f04f5d7b31dd1e724d67ff2585d30c0f384c4f" translate="yes" xml:space="preserve">
          <source>Bug fix: Only consider AS names from the result set as candidates for resolving identifiers in the WHERE clause if there are no other matches. In the ORDER BY clause, AS names take priority over any column names. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/2500cdb9be05&quot;&gt;2500cdb9be05&lt;/a&gt;</source>
          <target state="translated">漏洞修复：如果没有其他匹配项，则仅将结果集中的AS名称视为WHERE子句中解析标识符的候选者。在ORDER BY子句中，AS名称优先于任何列名称。机票&lt;a href=&quot;https://www.sqlite.org/src/info/2500cdb9be05&quot;&gt;2500cdb9be05&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="141fde2a748db5215be1ecb9d4a778d891f1cb31" translate="yes" xml:space="preserve">
          <source>Bug fix: Passing in a NULL as the 3rd parameter to &lt;b&gt;sqlite_open()&lt;/b&gt; would sometimes cause a coredump.</source>
          <target state="translated">错误修复：将NULL作为第三个参数传递给&lt;b&gt;sqlite_open（）&lt;/b&gt;有时会导致核心转储。</target>
        </trans-unit>
        <trans-unit id="2ab06e54b175379ab13bc77c3e0d9c481bc0c496" translate="yes" xml:space="preserve">
          <source>Bug fix: Recognize that any column in the right-hand table of a LEFT JOIN can be NULL even if the column has a NOT NULL constraint. Do not apply optimizations that assume the column is never NULL. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7ed&lt;/a&gt;.</source>
          <target state="translated">错误修复：识别出LEFT JOIN右侧表中的任何列都可以为NULL，即使该列具有NOT NULL约束。不要应用假定列永远都不为NULL的优化。票证&lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7ed&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03f2e3e890c570259cec0056bb1e5602f41a8fe5" translate="yes" xml:space="preserve">
          <source>Bug fix: Repair a name-resolution error that can occur in sub-select statements contained within a TRIGGER. &lt;a href=&quot;http://www.sqlite.org/src/info/4ef7e3cfca&quot;&gt;Ticket [4ef7e3cfca]&lt;/a&gt;</source>
          <target state="translated">错误修复：修复TRIGGER中包含的子选择语句中可能发生的名称解析错误。&lt;a href=&quot;http://www.sqlite.org/src/info/4ef7e3cfca&quot;&gt;门票[4ef7e3cfca]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4a3f6c0dcdc18557c33cb4e32e61ccf63e51312a" translate="yes" xml:space="preserve">
          <source>Bug fix: Repair a name-resolution error that can occur in sub-select statements contained within a TRIGGER. &lt;a href=&quot;https://www.sqlite.org/src/info/4ef7e3cfca&quot;&gt;Ticket [4ef7e3cfca]&lt;/a&gt;</source>
          <target state="translated">错误修复：修复TRIGGER中包含的子选择语句中可能发生的名称解析错误。&lt;a href=&quot;https://www.sqlite.org/src/info/4ef7e3cfca&quot;&gt;门票[4ef7e3cfca]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="179d04a255aba0b12c6e57bf1304a5f158b18e87" translate="yes" xml:space="preserve">
          <source>Bug fix: SQL functions created using the TCL interface honor the &quot;nullvalue&quot; setting.</source>
          <target state="translated">错误修正。使用TCL接口创建的SQL函数尊重 &quot;nullvalue &quot;设置。</target>
        </trans-unit>
        <trans-unit id="0cd3dbb56d1124c2a6604fca7c97c5b4d246ad99" translate="yes" xml:space="preserve">
          <source>Bug fix: Sometimes arbitrary strings were passed to the callback function when the actual value of a column was NULL.</source>
          <target state="translated">错误修正。当一列的实际值为NULL时,有时会向回调函数传递任意字符串。</target>
        </trans-unit>
        <trans-unit id="e6069685c787f1f2374ad59005630cac33f83a18" translate="yes" xml:space="preserve">
          <source>Bug fix: The %c format in sqlite3_mprintf() is able to handle precisions greater than 70.</source>
          <target state="translated">错误修正。sqlite3_mprintf()中的%c格式可以处理大于70的精度。</target>
        </trans-unit>
        <trans-unit id="8545ae69eab7462c35ca27db0ca5feb48e882da0" translate="yes" xml:space="preserve">
          <source>Bug fix: The &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; gives an exit code of 0 when terminated using the &quot;.quit&quot; command.</source>
          <target state="translated">错误修复：使用&amp;ldquo; .quit&amp;rdquo;命令终止时，&lt;a href=&quot;cli&quot;&gt;命令行外壳&lt;/a&gt;将给出退出代码0。</target>
        </trans-unit>
        <trans-unit id="3c4dbfc44f9dd05912067f94c3eb5f1e8372f6d5" translate="yes" xml:space="preserve">
          <source>Bug fix: There was an incorrect assert() in pager.c. The real code was all correct (as far as is known) so everything should work OK if you compile with -DNDEBUG=1. When asserts are not disabled, there could be a fault.</source>
          <target state="translated">错误修正。pager.c中的assert()不正确,真实的代码都是正确的(就目前所知),所以如果你在编译时使用-DNDEBUG=1,一切都应该是正常的。当断言没有被禁用时,可能会出现故障。</target>
        </trans-unit>
        <trans-unit id="ad7bd89e49a8af821827d6b028e2e799f12e2e1e" translate="yes" xml:space="preserve">
          <source>Bug fix: Updates to tables containing an INTEGER PRIMARY KEY and an index could fail.</source>
          <target state="translated">错误修复。对包含INTEGER PRIMARY KEY和索引的表的更新可能失败。</target>
        </trans-unit>
        <trans-unit id="6b758d1f8710d23a2038913ec37dece3bec7abf6" translate="yes" xml:space="preserve">
          <source>Bug fix: Virtual tables now handle IS NOT NULL constraints correctly.</source>
          <target state="translated">错误修复。虚拟表现在可以正确处理IS NOT NULL约束。</target>
        </trans-unit>
        <trans-unit id="332e05b490c4cb7238853c006e2e916e2a9e4dbc" translate="yes" xml:space="preserve">
          <source>Bug fix: When a &lt;a href=&quot;lang_select#compound&quot;&gt;compound query&lt;/a&gt; that uses an ORDER BY clause with a &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, make sure that the sorting occurs according to the specified collation and that the comparisons associate with the compound query use the native collation. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/6709574d2a8d8&quot;&gt;6709574d2a8d8&lt;/a&gt;.</source>
          <target state="translated">漏洞修复：当使用ORDER BY子句和&lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE运算符&lt;/a&gt;的&lt;a href=&quot;lang_select#compound&quot;&gt;复合查询时&lt;/a&gt;，请确保根据指定的排序规则进行排序，并且与该复合查询相关联的比较使用本机排序规则。机票&lt;a href=&quot;http://www.sqlite.org/src/info/6709574d2a8d8&quot;&gt;6709574d2a8d8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="733105938dce575f5ca4370a8ea4145b473f6dc3" translate="yes" xml:space="preserve">
          <source>Bug fix: When a &lt;a href=&quot;lang_select#compound&quot;&gt;compound query&lt;/a&gt; that uses an ORDER BY clause with a &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, make sure that the sorting occurs according to the specified collation and that the comparisons associate with the compound query use the native collation. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6709574d2a8d8&quot;&gt;6709574d2a8d8&lt;/a&gt;.</source>
          <target state="translated">错误修复：当一个&lt;a href=&quot;lang_select#compound&quot;&gt;复合查询&lt;/a&gt;使用一个带有&lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE运算符&lt;/a&gt;的ORDER BY子句时，请确保排序是根据指定的排序规则进行的，并且确保与该复合查询关联的比较使用本机排序规则。机票&lt;a href=&quot;https://www.sqlite.org/src/info/6709574d2a8d8&quot;&gt;6709574d2a8d8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2cfdb97a345b3ce143f2abc5fd945ed42741b35a" translate="yes" xml:space="preserve">
          <source>Bug fix: allow a VACUUM (without segfaulting) on an empty database after setting the EMPTY_RESULT_CALLBACKS pragma.</source>
          <target state="translated">错误修正:在设置EMPTY_RESULT_CALLBACKS pragma后,允许在空数据库上进行VACUUM(无segfaulting)。</target>
        </trans-unit>
        <trans-unit id="1e76d1db13ab52fcac380bd0ae95fbf87bf5df38" translate="yes" xml:space="preserve">
          <source>Bug fix: an assertion was failing if the disk holding the database file became full or stopped accepting writes for some other reason. New tests were added to detect similar problems in the future.</source>
          <target state="translated">错误修复:如果存放数据库文件的磁盘满了或者因为其他原因停止接受写入,则断言失败。增加了新的测试,以便在未来检测类似的问题。</target>
        </trans-unit>
        <trans-unit id="f481a7837f1627a5d4384fe68dbbc8fae1d3d0ad" translate="yes" xml:space="preserve">
          <source>Bug fix: an obscure and relatively harmless bug was causing one of the tests to fail when gcc optimizations are turned on. This release fixes the problem.</source>
          <target state="translated">错误修复:当开启gcc优化时,一个不明显且相对无害的错误导致其中一个测试失败。这个版本修复了这个问题。</target>
        </trans-unit>
        <trans-unit id="1817a2a23947bcba57e850537b31bddd01fd4808" translate="yes" xml:space="preserve">
          <source>Bug fix: correctly evaluate a view of a view without segfaulting.</source>
          <target state="translated">错误修正:正确评估一个视图的视图,而不发生segfault。</target>
        </trans-unit>
        <trans-unit id="0bbfec3e6b5b062aa0e10ea3e3ec25c68f3b48e5" translate="yes" xml:space="preserve">
          <source>Bug fix: do not invoke the authorizer when reparsing the schema after a schema change.</source>
          <target state="translated">错误修复:在模式改变后重新解析模式时不调用授权者。</target>
        </trans-unit>
        <trans-unit id="ff59932ad9e1623e668bc5144d9efca6daa5ff06" translate="yes" xml:space="preserve">
          <source>Bug fix: if an integer value will not fit in a 32-bit int, store it in a double instead.</source>
          <target state="translated">错误修正:如果一个整数值不适合存放在32位的int中,就用double代替。</target>
        </trans-unit>
        <trans-unit id="09579acd43ac94145eab3e50236de9b1df09778c" translate="yes" xml:space="preserve">
          <source>Bug fix: incorrect VDBE code was being generated for the following circumstance: a query on an indexed table containing a WHERE clause with an IN operator that had a subquery on its right-hand side.</source>
          <target state="translated">错误修复:在以下情况下生成了不正确的VDBE代码:在一个索引表上进行查询,该表包含一个带有IN操作符的WHERE子句,该子句在其右侧有一个子查询。</target>
        </trans-unit>
        <trans-unit id="e8c1bb430eed1f84c250a2cbb94468adfcff9f43" translate="yes" xml:space="preserve">
          <source>Bug fix: prevent database corruption if you dropped a trigger that had the same name as a table.</source>
          <target state="translated">错误修正:如果你放弃了一个与表同名的触发器,防止数据库损坏。</target>
        </trans-unit>
        <trans-unit id="77f87bfdf4072c6e0867b3768c5f7d3818056770" translate="yes" xml:space="preserve">
          <source>Bug fix: repair a long-standing problem that could cause incorrect query results in a 3-way or larger join that compared INTEGER fields against TEXT fields in two or more places. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/fc7bd6358f&quot;&gt;fc7bd6358f&lt;/a&gt;</source>
          <target state="translated">错误修复：修复一个长期存在的问题，该问题可能导致在3向或更大连接中将INTEGER字段与TEXT字段在两个或多个位置进行比较的错误查询结果。门票&lt;a href=&quot;http://www.sqlite.org/src/info/fc7bd6358f&quot;&gt;FC7BD6358F&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1812a81c2bff544f1fbb09d9b4152f6dcbbe187c" translate="yes" xml:space="preserve">
          <source>Bug fix: repair a long-standing problem that could cause incorrect query results in a 3-way or larger join that compared INTEGER fields against TEXT fields in two or more places. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/fc7bd6358f&quot;&gt;fc7bd6358f&lt;/a&gt;</source>
          <target state="translated">错误修复：修复一个长期存在的问题，该问题可能导致在三向或更大连接中将INTEGER字段与两个或多个位置的TEXT字段进行比较的错误查询结果。门票&lt;a href=&quot;https://www.sqlite.org/src/info/fc7bd6358f&quot;&gt;FC7BD6358F&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c0e4c435db089ba66d14c6f426f1ca923c3e24a" translate="yes" xml:space="preserve">
          <source>Bug fix: the &lt;b&gt;sqlite_busy_timeout()&lt;/b&gt; function was delaying 1000 times too long before failing.</source>
          <target state="translated">错误修复：&lt;b&gt;sqlite_busy_timeout（）&lt;/b&gt;函数在失败之前延迟了1000次。</target>
        </trans-unit>
        <trans-unit id="1de9526f456e5138884e0e01586b12298617b6e1" translate="yes" xml:space="preserve">
          <source>Bug fixes</source>
          <target state="translated">错误修复</target>
        </trans-unit>
        <trans-unit id="9af1a1169b55646981d441c46e6271c5d4e76c17" translate="yes" xml:space="preserve">
          <source>Bug fixes and performance enhancements in the query optimizer</source>
          <target state="translated">查询优化器中的错误修复和性能提升。</target>
        </trans-unit>
        <trans-unit id="c92ef11c871ae07b2d656ca889c918e8054c9d2e" translate="yes" xml:space="preserve">
          <source>Bug fixes and speed improvements. Improved test coverage.</source>
          <target state="translated">错误修复和速度改进。提高了测试覆盖率。</target>
        </trans-unit>
        <trans-unit id="fa58e385720020fa0c169f308e1843b2e873b0c1" translate="yes" xml:space="preserve">
          <source>Bug fixes in fts1 and fts2 modules.</source>
          <target state="translated">fts1和fts2模块的错误修复。</target>
        </trans-unit>
        <trans-unit id="7084081296e3ad1cf8f7221181be2c129e0aee5c" translate="yes" xml:space="preserve">
          <source>Bug fixes in the TCL interface identified by Oleg Oleinick.</source>
          <target state="translated">修正了Oleg Oleinick指出的TCL接口中的错误。</target>
        </trans-unit>
        <trans-unit id="e8aa6f5aee0afe8811b93445b5db21495039c63d" translate="yes" xml:space="preserve">
          <source>Bug fixes in the experimental date/time functions.</source>
          <target state="translated">修正实验性日期/时间函数中的错误。</target>
        </trans-unit>
        <trans-unit id="b9c7777bb06388cb9dbb8f975e3fd09b2142a8c1" translate="yes" xml:space="preserve">
          <source>Bug fixes to date/time functions.</source>
          <target state="translated">修正日期/时间功能的错误。</target>
        </trans-unit>
        <trans-unit id="081661d86510940c54a252302be8551477973958" translate="yes" xml:space="preserve">
          <source>Bug fixes too numerous to mention (see the change log).</source>
          <target state="translated">错误修复太多,无法一一列举(参见变更日志)。</target>
        </trans-unit>
        <trans-unit id="54d964bde3b45008273493e091d5fc828d1a6056" translate="yes" xml:space="preserve">
          <source>Bug fixes:</source>
          <target state="translated">错误修复。</target>
        </trans-unit>
        <trans-unit id="a6d45e893c4329669744195bd786da10bdc76da3" translate="yes" xml:space="preserve">
          <source>Bug fixes: Correctly handle nested correlated subqueries used with indices in a WHERE clause.</source>
          <target state="translated">错误修正。正确处理在WHERE子句中使用指数的嵌套相关子查询。</target>
        </trans-unit>
        <trans-unit id="24673ce72a32d2ab5eb79f34d4f1d1eb683d14be" translate="yes" xml:space="preserve">
          <source>Bug fixes: Multiple problems in the legacy query optimizer were fixed by the move to &lt;a href=&quot;queryplanner-ng&quot;&gt;NGQP&lt;/a&gt;.</source>
          <target state="translated">错误修复：迁移到&lt;a href=&quot;queryplanner-ng&quot;&gt;NGQP&lt;/a&gt;修复了旧式查询优化器中的多个问题。</target>
        </trans-unit>
        <trans-unit id="58535f3c8aa73d70d81e761cda2cb8486c811f2f" translate="yes" xml:space="preserve">
          <source>Bugs are far less likely in SQLite than in custom-written file I/O code.</source>
          <target state="translated">在SQLite中出现BUG的可能性远远小于自定义编写的文件I/O代码。</target>
        </trans-unit>
        <trans-unit id="5a61f35b0599148f4a6890e52dcef0661cb0913e" translate="yes" xml:space="preserve">
          <source>Bugs in the FTS3/4 virtual table. (The &quot;integrity-check&quot; command was original conceived as part of the test suite for FTS3/4.)</source>
          <target state="translated">FTS3/4虚拟表的错误。(&quot;完整性检查 &quot;命令最初是作为FTS3/4测试套件的一部分而设计的)。</target>
        </trans-unit>
        <trans-unit id="8f202605eb190dddba6e0719369e8fd2b96ba2d8" translate="yes" xml:space="preserve">
          <source>Build the &quot;fts5.c&quot; target. Which also creates fts5.h.</source>
          <target state="translated">建立 &quot;fts5.c &quot;目标。也就是创建fts5.h。</target>
        </trans-unit>
        <trans-unit id="00497bbc4dcbda4f80e1ffef6721bc5a34a86a97" translate="yes" xml:space="preserve">
          <source>Building SQLite directly from individual source code files is certainly possible, but it is not recommended. For some specialized applications, it might be necessary to modify the build process in ways that cannot be done using just the prebuilt amalgamation source file downloaded from the website. For those situations, it is recommended that a customized amalgamation be built (as described &lt;a href=&quot;howtocompile#amal&quot;&gt;below&lt;/a&gt;) and used. In other words, even if a project requires building SQLite beginning with individual source files, it is still recommended that an amalgamation source file be used as an intermediate step.</source>
          <target state="translated">当然可以直接从单个源代码文件中构建SQLite，但是不建议这样做。对于某些专业应用程序，可能有必要以无法仅使用从网站下载的预构建合并源文件来完成的方式来修改构建过程。对于那些情况，则建议定制合并来构建（如所描述的&lt;a href=&quot;howtocompile#amal&quot;&gt;下面&lt;/a&gt;），并使用。换句话说，即使项目需要从单个源文件开始构建SQLite，仍建议将合并源文件用作中间步骤。</target>
        </trans-unit>
        <trans-unit id="0a71cb495d76b612c809648873b36b593c7393c1" translate="yes" xml:space="preserve">
          <source>Building a DLL</source>
          <target state="translated">建立一个DLL</target>
        </trans-unit>
        <trans-unit id="280b6f6ad70e8ba6e9e400ea3d8e0a9edc8b3677" translate="yes" xml:space="preserve">
          <source>Building shared libraries for Mac OS X and Windows is not nearly so simple, unfortunately. For those platforms it is best to use the configure script and makefile that is included with the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;TEA tarball&lt;/a&gt;.</source>
          <target state="translated">不幸的是，为Mac OS X和Windows构建共享库并不是那么简单。对于那些平台，最好使用&lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;TEA tarball&lt;/a&gt;随附的configure脚本和makefile 。</target>
        </trans-unit>
        <trans-unit id="22bc37f7023e946a78cac7bbfe5894c0db4b3f89" translate="yes" xml:space="preserve">
          <source>Building the amalgamation</source>
          <target state="translated">建立合并体</target>
        </trans-unit>
        <trans-unit id="baa9f6c7f9720c4460c1521a23a159ddd34e81a1" translate="yes" xml:space="preserve">
          <source>Built-In Scalar SQL Functions</source>
          <target state="translated">内置的标量SQL函数</target>
        </trans-unit>
        <trans-unit id="c2d49de15987506a3eaf80acc91b361f30b458bf" translate="yes" xml:space="preserve">
          <source>Built-in &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that return the results of &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements for use within ordinary SQL queries.</source>
          <target state="translated">内置&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;，可返回&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;语句的结果以在普通SQL查询中使用。</target>
        </trans-unit>
        <trans-unit id="78cbf7ad58abfcde67b880290a3fdb26ae265ea9" translate="yes" xml:space="preserve">
          <source>Built-in Aggregate Functions</source>
          <target state="translated">内置聚合功能</target>
        </trans-unit>
        <trans-unit id="fb80809ef25b3a813f862af2f128324a798b2745" translate="yes" xml:space="preserve">
          <source>Built-in functions may be overloaded by new application-defined functions.</source>
          <target state="translated">内置函数可能会被新的应用程序定义的函数重载。</target>
        </trans-unit>
        <trans-unit id="224b755bc066a07e060bb8deb0ae84ff72d8c6e6" translate="yes" xml:space="preserve">
          <source>Built-in window functions honor any PARTITION BY clause in the same way as aggregate window functions - each selected row is assigned to a partition and each partition is processed separately. The ways in which any ORDER BY clause affects each built-in window function is described below. Some of the window functions (rank(), dense_rank(), percent_rank() and ntile()) use the concept of &quot;peer groups&quot; (rows within the same partition that have the same values for all ORDER BY expressions). In these cases, it does not matter whether the frame-spec specifies ROWS, GROUPS, or RANGE. For the purposes of built-in window function processing, rows with the same values for all ORDER BY expressions are considered peers regardless of the frame type.</source>
          <target state="translated">内置窗口函数以与集合窗口函数相同的方式尊重任何PARTITION BY子句--将每条选定的行分配给一个分区,并分别处理每个分区。下面描述了任何ORDER BY子句影响每个内置窗口函数的方式。一些窗口函数(rank()、dense_rank()、percent_rank()和ntile())使用了 &quot;同行组 &quot;的概念(同一分区内的行,对所有ORDER BY表达式具有相同的值)。在这些情况下,不管frame-spec指定的是rows、groups还是range,都不重要。为了内置窗口函数处理的目的,无论框架类型如何,对所有ORDER BY表达式具有相同值的行都被认为是同行。</target>
        </trans-unit>
        <trans-unit id="5a25ccfc2ab6b23f400787b0cd05318c6367c6b9" translate="yes" xml:space="preserve">
          <source>Builtin window functions</source>
          <target state="translated">内置的窗口功能</target>
        </trans-unit>
        <trans-unit id="3fddbac5f0f5f0b32fe70d555580cce7a2b2229b" translate="yes" xml:space="preserve">
          <source>Bundle sqlite_encode_binary() and sqlite_decode_binary() with the library.</source>
          <target state="translated">将sqlite_encode_binary()和sqlite_decode_binary()捆绑在库中。</target>
        </trans-unit>
        <trans-unit id="f637663e6355164a78b8db75eb1fc4755242d81d" translate="yes" xml:space="preserve">
          <source>Bury the dead.</source>
          <target state="translated">埋葬死者。</target>
        </trans-unit>
        <trans-unit id="c86307059b070b415312a3a5cc51007f6e153433" translate="yes" xml:space="preserve">
          <source>But SQLite does use the declared type of a column as a hint that you prefer values in that format. So, for example, if a column is of type INTEGER and you try to insert a string into that column, SQLite will attempt to convert the string into an integer. If it can, it inserts the integer instead. If not, it inserts the string. This feature is called &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt;.</source>
          <target state="translated">但是SQLite确实使用列的声明类型作为提示，提示您更喜欢该格式的值。因此，例如，如果列的类型为INTEGER，而您尝试在该列中插入字符串，则SQLite会尝试将字符串转换为整数。如果可以，它将插入整数。如果没有，它将插入字符串。此功能称为&lt;a href=&quot;datatype3#affinity&quot;&gt;类型亲和力&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23199e0b44d24bd1ee4c96e22ea9bb3d1c2f67f4" translate="yes" xml:space="preserve">
          <source>But SQLite is built into the application. So if the data is on a separate device from the application, it is required that the higher bandwidth engine-to-disk link be across the network. This works, but it is suboptimal. Hence, it is usually better to select a client/server database engine when the data is on a separate device from the application.</source>
          <target state="translated">但是SQLite是内置在应用程序中的。所以,如果数据是在一个独立于应用程序的设备上,就需要较高带宽的引擎到磁盘的链接是跨网络的。这样做是可行的,但却是次优的。因此,当数据在与应用程序分开的设备上时,通常最好选择客户/服务器数据库引擎。</target>
        </trans-unit>
        <trans-unit id="09ce2891d1601356f9a03f1d38be77a08462a437" translate="yes" xml:space="preserve">
          <source>But an SQLite database is not limited to a simple key/value structure like a pile-of-files database. An SQLite database can have dozens or hundreds or thousands of different tables, with dozens or hundreds or thousands of fields per table, each with different datatypes and constraints and particular meanings, all cross-referencing each other, appropriately and automatically indexed for rapid retrieval, and all stored efficiently and compactly in a single disk file. And all of this structure is succinctly documented for humans by the SQL schema.</source>
          <target state="translated">但是一个SQLite数据库并不局限于像一堆文件数据库那样简单的键/值结构。一个SQLite数据库可以有几十张或几百张或几千张不同的表,每张表有几十个或几百个或几千个字段,每一个字段都有不同的数据类型和约束条件以及特定的含义,所有的表都可以相互交叉引用,并适当地自动建立索引,以便快速检索,而且所有的表都高效而紧凑地存储在一个磁盘文件中。而这一切结构都被SQL模式简洁地记录下来,供人参考。</target>
        </trans-unit>
        <trans-unit id="d929882a8a439200f669cf52bfce1643d73dfffb" translate="yes" xml:space="preserve">
          <source>But as with any query planner change, upgrading to the NGQP does carry a small risk of introducing performance regressions. The problem here is not that the NGQP is incorrect or buggy or inferior to the legacy query planner. Given reliable information about the selectivity of indexes, the NGQP should always pick a plan that is as good or better than before. The problem is that some applications may be using low-quality and low-selectivity indexes without having run &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;. The older query planners look at many fewer possible implementations for each query and so they may have stumbled over a good plan by stupid luck. The NGQP, on the other hand, looks at many more query plan possibilities, and it may choose a different query plan that works better in theory, assuming good indexes, but which gives a performance regression in practice, because of the shape of the data.</source>
          <target state="translated">但是，与任何查询计划程序更改一样，升级到NGQP确实会带来引入性能退化的风险。这里的问题不是NGQP不正确，有错误或不如旧查询计划器。给定有关索引选择性的可靠信息，NGQP应该始终选择比以前更好或更好的计划。问题是某些应用程序可能在不运行&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE的&lt;/a&gt;情况下使用了低质量和低选择性的索引。较老的查询计划者为每个查询查看的实现方式要少得多，因此他们可能因愚蠢的运气而错失了一个好的计划。另一方面，NGQP会考虑更多的查询计划可能性，并且它可能会选择一个其他的查询计划，该查询计划在理论上会更好（假设有良好的索引），但由于数据的形状，在实践中会导致性能下降。</target>
        </trans-unit>
        <trans-unit id="bcf6c11e8e6d47ec28df41f7ffce035dc6edbeac" translate="yes" xml:space="preserve">
          <source>But because the &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement does not change the database file directly, sqlite3_stmt_readonly() would still return true.</source>
          <target state="translated">但是由于&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;语句不会直接更改数据库文件，因此sqlite3_stmt_readonly（）仍将返回true。</target>
        </trans-unit>
        <trans-unit id="452ab026c840b3ee756da71d85f2e4c8edc72d0b" translate="yes" xml:space="preserve">
          <source>But because the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement does not change the database file directly, sqlite3_stmt_readonly() would still return true.</source>
          <target state="translated">但是由于&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句不会直接更改数据库文件，因此sqlite3_stmt_readonly（）仍将返回true。</target>
        </trans-unit>
        <trans-unit id="ff4e39f9bba0236549d62b5ae4b68b2eb0a104f9" translate="yes" xml:space="preserve">
          <source>But database engines like SQLite are usually not this way. The SQL scripts that are passed into SQLite come from the (trusted) application itself, not from an attacker. Sometimes applications contain bugs by which an external attacker can trick the application into sending SQL of the attackers design into the database engine. This is a separate bug in the application called an &lt;a href=&quot;https://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL Injection vulnerability&lt;/a&gt;. Since SQL text is executable code, an SQL Injection vulnerability is actually a special case of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Arbitrary_code_execution&quot;&gt;Remote Code Execution (RCE) vulnerability&lt;/a&gt;. An SQL Injection is perhaps not quite as bad as other kinds of RCEs because, while SQL is a powerful language, it is not as convenient for crafting an exploit as Python or shell script or raw machine code. Nevertheless, an SQL Injection is a serious problem.</source>
          <target state="translated">但是像SQLite这样的数据库引擎通常不是这种方式。传递到SQLite的SQL脚本来自（受信任的）应用程序本身，而不是来自攻击者。有时，应用程序包含一些错误，外部攻击者可以通过这些错误诱使应用程序将攻击者设计的SQL发送到数据库引擎中。这是应用程序中的一个独立错误，称为&lt;a href=&quot;https://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL注入漏洞&lt;/a&gt;。由于SQL文本是可执行代码，因此SQL注入漏洞实际上是&lt;a href=&quot;https://en.wikipedia.org/wiki/Arbitrary_code_execution&quot;&gt;远程执行代码（RCE）漏洞&lt;/a&gt;的特例。。SQL注入可能不如其他RCE那样糟糕，因为尽管SQL是一种功能强大的语言，但它不像Python或Shell脚本或原始机器代码那样方便地开发漏洞利用程序。但是，SQL注入是一个严重的问题。</target>
        </trans-unit>
        <trans-unit id="f3654dae88afc03c2b5b644ec401c70beb10ac13" translate="yes" xml:space="preserve">
          <source>But does this really save time? The number of steps in the &lt;a href=&quot;#fig16&quot;&gt;original indexless sort&lt;/a&gt; is proportional to NlogN since that is how much time it takes to sort N rows. But when we use Idx1 as shown here, we have to do N rowid lookups which take logN time each, so the total time of NlogN is the same!</source>
          <target state="translated">但这真的可以节省时间吗？&lt;a href=&quot;#fig16&quot;&gt;原始无索引排序&lt;/a&gt;的步骤数与NlogN成正比，因为那是对N行进行排序所花费的时间。但是，当我们使用此处所示的Idx1时，我们必须进行N个rowid查找，每次查找耗时logN，因此NlogN的总时间是相同的！</target>
        </trans-unit>
        <trans-unit id="d6fc31d48c09d06ad4b37abcbcf5f0dce6a8ec76" translate="yes" xml:space="preserve">
          <source>But from the point of view of the VDBE, a CREATE works pretty much like an INSERT and a DROP works like a DELETE. When the SQLite library opens to an existing database, the first thing it does is a SELECT to read the &quot;sql&quot; columns from all entries of the sqlite_master table. The &quot;sql&quot; column contains the complete SQL text of the CREATE statement that originally generated the index or table. This text is fed back into the SQLite parser and used to reconstruct the internal data structures describing the index or table.</source>
          <target state="translated">但从VDBE的角度来看,CREATE的工作原理和INSERT差不多,DROP的工作原理和DELETE差不多。当SQLite库打开一个现有的数据库时,首先要做的是一个SELECT,从sqlite_master表的所有条目中读取 &quot;sql &quot;列。&quot;sql &quot;列包含最初生成索引或表的CREATE语句的完整SQL文本。这个文本被反馈到SQLite解析器中,用于重建描述索引或表的内部数据结构。</target>
        </trans-unit>
        <trans-unit id="48911d596580c34107a4030f62db573e6c27c85f" translate="yes" xml:space="preserve">
          <source>But if SQLite wants to access a page of the database file and memory mapped I/O is enabled, it first calls the xFetch() method. The xFetch() method asks the operating system to return a pointer to the requested page, if possible. If the requested page has been or can be mapped into the application address space, then xFetch returns a pointer to that page for SQLite to use without having to copy anything. Skipping the copy step is what makes memory mapped I/O faster.</source>
          <target state="translated">但是如果SQLite想要访问数据库文件的某一页,并且启用了内存映射I/O,它首先会调用xFetch()方法。如果可能的话,xFetch()方法会要求操作系统返回一个指向请求页面的指针。如果请求的页面已经或可以映射到应用程序地址空间,那么xFetch就会返回一个指向该页面的指针,供SQLite使用,而无需复制任何东西。跳过复制步骤是使内存映射的I/O更快的原因。</target>
        </trans-unit>
        <trans-unit id="29180962652da325c9c8e705d40a3befafb60fff" translate="yes" xml:space="preserve">
          <source>But if a hacker is able to run arbitrary SQL, he might run a slightly different query, like this:</source>
          <target state="translated">但如果一个黑客能够运行任意SQL,他可能会运行一个稍微不同的查询,比如这样。</target>
        </trans-unit>
        <trans-unit id="42f14da1dea8e44296cffda380cd3db71f9a44b1" translate="yes" xml:space="preserve">
          <source>But if an attacker can already run arbitrary SQL, they do not need a bug to cause a denial of service. There are plenty of perfectly legal and valid SQL statements that will consume unlimited CPU, memory, and disk I/O in order to create a denial-of-service without requiring help from bugs.</source>
          <target state="translated">但如果攻击者已经可以运行任意SQL,他们就不需要bug来造成拒绝服务。有很多完全合法有效的SQL语句会无限制地消耗CPU、内存和磁盘I/O来制造拒绝服务,而不需要bug的帮助。</target>
        </trans-unit>
        <trans-unit id="560c7f07ebe8e7827f02303fd33e3696ffc6d5d9" translate="yes" xml:space="preserve">
          <source>But if the</source>
          <target state="translated">但如果</target>
        </trans-unit>
        <trans-unit id="a0cdbfa12f5d3945de1878cd75d88dc29371bd31" translate="yes" xml:space="preserve">
          <source>But if the EMPTY_RESULT_CALLBACKS pragma is ON, then the following is returned:</source>
          <target state="translated">但是如果EMPTY_RESULT_CALLBACKS pragma是ON,那么就会返回以下内容。</target>
        </trans-unit>
        <trans-unit id="3b2f2e220bf3a85ffdbd93e68cd80fcba741ecfe" translate="yes" xml:space="preserve">
          <source>But if the case_sensitive_like pragma is enabled as follows:</source>
          <target state="translated">但是如果启用了case_sensitive_like pragma,如下所示。</target>
        </trans-unit>
        <trans-unit id="917ffdb9308404a9f9ecbb2338ae37ba101af829" translate="yes" xml:space="preserve">
          <source>But if the i-th parameter is NULL we will get:</source>
          <target state="translated">但如果第i-th个参数是NULL,我们将得到。</target>
        </trans-unit>
        <trans-unit id="418b21f56edf736ac615f67f52f5ff8cd5de8694" translate="yes" xml:space="preserve">
          <source>But if we change the ORDER BY clause to add the &quot;DESC&quot; modifier, that will cause lower levels in the organization (with larger &quot;level&quot; values) to be processed first by the recursive-select, resulting in a depth-first search:</source>
          <target state="translated">但是如果我们改变ORDER BY子句,增加 &quot;DESC &quot;修饰符,就会导致组织中较低的级别(&quot;级别 &quot;值较大)先被递归选择处理,导致深度优先搜索。</target>
        </trans-unit>
        <trans-unit id="b73aaf5e4e2de9f2adc91308c0011207fcb7df2b" translate="yes" xml:space="preserve">
          <source>But in a coverage measuring build, the &lt;code&gt;testcase()&lt;/code&gt; macro generates code that evaluates the conditional expression in its argument. Then during analysis, a check is made to ensure tests exist that evaluate the conditional to both true and false. &lt;code&gt;Testcase()&lt;/code&gt; macros are used, for example, to help verify that boundary values are tested. For example:</source>
          <target state="translated">但是在覆盖率测量版本中， &lt;code&gt;testcase()&lt;/code&gt; 宏会生成用于评估其参数中条件表达式的代码。然后在分析过程中，将进行检查以确保存在将条件评估为真和假的测试。例如，使用 &lt;code&gt;Testcase()&lt;/code&gt; 宏来帮助验证是否已测试边界值。例如：</target>
        </trans-unit>
        <trans-unit id="6cba989629259efaf3551fd795674dc99bb4d48d" translate="yes" xml:space="preserve">
          <source>But in the following logically equivalent formulation of the same query, the substitution of &quot;CROSS JOIN&quot; for the &quot;,&quot; means that the order of tables must be N1, E, N2.</source>
          <target state="translated">但是在下面逻辑上等同的相同查询的表述中,用 &quot;CROSS JOIN &quot;代替&quot;,&quot;意味着表的顺序必须是N1,E,N2。</target>
        </trans-unit>
        <trans-unit id="2a172174425039b0a04cf59d0c65f9b7b37ef450" translate="yes" xml:space="preserve">
          <source>But the &quot;.tables&quot; command does more. It queries the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; table for all &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases, not just the primary database. And it arranges its output into neat columns.</source>
          <target state="translated">但是&amp;ldquo; .tables&amp;rdquo;命令的作用更多。它在&lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt;表中查询所有&lt;a href=&quot;lang_attach&quot;&gt;附加&lt;/a&gt;数据库，而不仅仅是主数据库。并将其输出排列到整齐的列中。</target>
        </trans-unit>
        <trans-unit id="07070136c4e43ff98642891d2498eeab4c61ffd9" translate="yes" xml:space="preserve">
          <source>But the &quot;.tables&quot; command does more. It queries the sqlite_master table for all &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases, not just the primary database. And it arranges its output into neat columns.</source>
          <target state="translated">但是&amp;ldquo; .tables&amp;rdquo;命令的作用更多。它在sqlite_master表中查询所有&lt;a href=&quot;lang_attach&quot;&gt;附加&lt;/a&gt;数据库，而不仅仅是主数据库。并将其输出排列到整齐的列中。</target>
        </trans-unit>
        <trans-unit id="cc1b6b83457a776880f02cbe1ed99910a24b8fb2" translate="yes" xml:space="preserve">
          <source>But the following declaration does not result in &quot;x&quot; being an alias for the rowid:</source>
          <target state="translated">但是下面的声明不会导致 &quot;x &quot;成为 rowid 的别名。</target>
        </trans-unit>
        <trans-unit id="2d13a39c7ff19d1a4a67287041174bb7cee527dd" translate="yes" xml:space="preserve">
          <source>But the next query can not use the partial index:</source>
          <target state="translated">但接下来的查询不能使用部分索引。</target>
        </trans-unit>
        <trans-unit id="4968c094e6119e8a687db966e94b26bef2ebe4a4" translate="yes" xml:space="preserve">
          <source>But the use of subtypes does nothing to prevent the value of a pointer from being read using SQL code like this:</source>
          <target state="translated">但是使用子类型并不能阻止使用这样的SQL代码读取指针的值。</target>
        </trans-unit>
        <trans-unit id="6310277e9a108b401d7850bc8ffad69350ce478c" translate="yes" xml:space="preserve">
          <source>But there are also disadvantages:</source>
          <target state="translated">但也有缺点。</target>
        </trans-unit>
        <trans-unit id="f1e940122523fbd2f68feec81164dcb25704b65b" translate="yes" xml:space="preserve">
          <source>But those routines are optional can can be omitted using a &lt;a href=&quot;compile#zero_malloc&quot;&gt;compile-time option&lt;/a&gt;.</source>
          <target state="translated">但是那些例程是可选的，可以使用&lt;a href=&quot;compile#zero_malloc&quot;&gt;compile-time option&lt;/a&gt;省略。</target>
        </trans-unit>
        <trans-unit id="b843ee326d7f7cdf5b63dd9bf52bb27bf7756e78" translate="yes" xml:space="preserve">
          <source>But what value to choose for N? One might try N=K. This makes the algorithm O(K&lt;small&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/small&gt;) which is actually still quite efficient, since the maximum value of K is 64 and K rarely exceeds 10. But that is not enough for the TPC-H Q8 problem. With N=8 on TPC-H Q8 the N3 algorithm finds the solution R-N1-C-O-L-S-N2-P with a cost of 29.78. That is a big improvement over NN, but it is still not optimal. N3 finds the optimal solution for TPC-H Q8 when N is 10 or greater.</source>
          <target state="translated">但是为N选择什么值呢？可以尝试N = K。这使得算法O（K &lt;small&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/small&gt;）实际上仍然非常有效，因为K的最大值为64，而K很少超过10。但这对于TPC-H Q8问题还不够。在TPC-H Q8上N = 8时，N3算法找到成本为29.78的解R-N1-COLS-N2-P。这是对NN的重大改进，但仍不是最佳选择。当N为10或更大时，N3找到TPC-H Q8的最佳解决方案。</target>
        </trans-unit>
        <trans-unit id="65129801103eda08bf342c707b068d5b768e6daf" translate="yes" xml:space="preserve">
          <source>But with SQLite, 200 or more SQL statement per webpage is not a problem.</source>
          <target state="translated">但如果使用SQLite,每个网页200条以上的SQL语句是不成问题的。</target>
        </trans-unit>
        <trans-unit id="36f51675b3471666e7cff23ca3ceb542e736b084" translate="yes" xml:space="preserve">
          <source>But, generally speaking, the more constraints that the R*Tree module has to work with, and the smaller the bounding box, the faster the results will come back.</source>
          <target state="translated">但一般来说,R*Tree模块要处理的约束条件越多,边界框越小,结果就越快。</target>
        </trans-unit>
        <trans-unit id="bb3dd504a4ceaa15395efbf567f6c35a7b699cba" translate="yes" xml:space="preserve">
          <source>By &quot;static string&quot;, we mean a zero-terminated array of bytes that is fixed and unchanging for the life of the program. In other words, the pointer type string should be a string constant. In contrast, a &quot;dynamic string&quot; is a zero-terminated array of bytes that is held in memory allocated from the heap, and which must be freed to avoid a memory leak. Do not use dynamic strings as the pointer type string.</source>
          <target state="translated">所谓 &quot;静态字符串&quot;,是指一个由字节组成的零结尾数组,在程序的生命周期内是固定不变的。换句话说,指针类型的字符串应该是一个字符串常量。与此相反,&quot;动态字符串 &quot;是一个零结束的字节数组,它被保存在从堆分配的内存中,并且必须释放它以避免内存泄漏。不要使用动态字符串作为指针类型的字符串。</target>
        </trans-unit>
        <trans-unit id="f606d9b23ace8996276bde7ccd24b4d280a3c7c4" translate="yes" xml:space="preserve">
          <source>By adding multiple synonyms for a single term to the FTS index. Using this method, when tokenizing document text, the tokenizer provides multiple synonyms for each token. So that when a document such as &quot;I won first place&quot; is tokenized, entries are added to the FTS index for &quot;i&quot;, &quot;won&quot;, &quot;first&quot;, &quot;1st&quot; and &quot;place&quot;.</source>
          <target state="translated">通过为一个术语添加多个同义词到FTS索引中。使用这种方法,当对文档文本进行标记化时,标记化器为每个标记提供多个同义词。因此,当对 &quot;我赢得了第一名 &quot;这样的文档进行标记化时,&quot;i&quot;、&quot;won&quot;、&quot;first&quot;、&quot;1st &quot;和 &quot;place &quot;的条目会被添加到FTS索引中。</target>
        </trans-unit>
        <trans-unit id="80b3f84643451df0998b16a1d70d04019fc8e45c" translate="yes" xml:space="preserve">
          <source>By combining location data and related information into the same table, auxiliary columns can provide a cleaner model and reduce the need to joins. For example, the earlier &lt;a href=&quot;#diquery&quot;&gt;join between demo_index and demo_data&lt;/a&gt; can now be written as a simple query, like this:</source>
          <target state="translated">通过将位置数据和相关信息合并到同一表中，辅助列可以提供更简洁的模型并减少连接的需要。例如，现在可以将&lt;a href=&quot;#diquery&quot;&gt;demo_index和demo_data之间&lt;/a&gt;的早期连接编写为简单查询，如下所示：</target>
        </trans-unit>
        <trans-unit id="e37637c9870320bdf8cbf8ef62058290a2f74da5" translate="yes" xml:space="preserve">
          <source>By configuring a callback to be invoked the first time each table is written to that indicates to the session module whether or not changes on the table should be monitored.</source>
          <target state="translated">通过配置一个回调,在每张表第一次写入时都会被调用,该回调向会话模块指示是否应该监控表的变化。</target>
        </trans-unit>
        <trans-unit id="06b847c7709546cccdb0e536dbda4965ee6a96e1" translate="yes" xml:space="preserve">
          <source>By contrast, if foreign key errors can be recognized simply by looking at the definition of the child table and without having to consult the parent table definition, then the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement for the child table fails. Because the error occurs during a schema change, this is a DDL error. Foreign key DDL errors are reported regardless of whether or not foreign key constraints are enabled when the table is created.</source>
          <target state="translated">相反，如果仅通过查看子表的定义就可以识别外键错误，而不必查阅父表的定义，则子表的&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句将失败。因为该错误发生在架构更改期间，所以这是DDL错误。无论创建表时是否启用了外键约束，都会报告外键DDL错误。</target>
        </trans-unit>
        <trans-unit id="aedeaa844f352e8e17d5cb589064ea1e4109a539" translate="yes" xml:space="preserve">
          <source>By default a session object does not monitor changes on any database table. Before it does so it must be configured. There are three ways to configure the set of tables to monitor changes on:</source>
          <target state="translated">默认情况下,会话对象不会监控任何数据库表的变化。在它这样做之前,必须对它进行配置。有三种方法可以配置要监控变化的表集。</target>
        </trans-unit>
        <trans-unit id="55442bbcc7ceaf84de94fa28a3aed619ae9955e0" translate="yes" xml:space="preserve">
          <source>By default, &quot;unicode61&quot; attempts to remove diacritics from Latin script characters. This behaviour can be overridden by adding the tokenizer argument &quot;remove_diacritics=0&quot;. For example:</source>
          <target state="translated">默认情况下,&quot;unicode61 &quot;会尝试从拉丁字母字符中移除标点符号。这种行为可以通过添加 tokenizer 参数 &quot;remove_diacritics=0&quot; 来重写。例如</target>
        </trans-unit>
        <trans-unit id="7302d3f42259627d0861634979d66a761d287cd5" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are considered to be non-deterministic. However, if the 4th parameter to &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt; is OR-ed with &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;, then SQLite will treat that function as if it were deterministic.</source>
          <target state="translated">默认情况下，&lt;a href=&quot;appfunc&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;被认为是不确定的。但是，如果&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2（）&lt;/a&gt;的第4个参数与&lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC进行&lt;/a&gt;或运算，则SQLite将把该函数视为确定性函数。</target>
        </trans-unit>
        <trans-unit id="be3a7476bfd030e836d226174214b4408b10de5a" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are considered to be non-deterministic. However, if the 4th parameter to &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt; is OR-ed with &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;, then SQLite will treat that function as if it were deterministic.</source>
          <target state="translated">默认情况下，&lt;a href=&quot;c3ref/create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;被认为是不确定的。但是，如果将&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2（）&lt;/a&gt;的第4个参数与&lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC进行&lt;/a&gt;或运算，则SQLite将把该函数视为确定性函数。</target>
        </trans-unit>
        <trans-unit id="53685ae8370637562174590d6e02187741d1cecd" translate="yes" xml:space="preserve">
          <source>By default, ANALYZE does a full scan of every index. This can be slow for large databases. So beginning with SQLite version 3.32.0 (2020-05-22), the &lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;PRAGMA analysis_limit&lt;/a&gt; command can be used to limit the amount of scanning performed by ANALYZE, and thus help ANALYZE to run faster, even on very large database files. We call this running an &quot;approximate ANALYZE&quot;.</source>
          <target state="translated">默认情况下，ANALYZE对每个索引进行完整扫描。对于大型数据库，这可能会很慢。因此，从SQLite版本3.32.0（2020-05-22）开始，&lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;PRAGMA analysis_limit&lt;/a&gt;命令可用于限制ANALYZE执行的扫描量，从而帮助ANALYZE更快地运行，即使在非常大的数据库文件上也是如此。我们称此为&amp;ldquo;近似分析&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="78cc7d781eb449f29366e3574bdcdf238af76b02" translate="yes" xml:space="preserve">
          <source>By default, FTS queries (those that use the MATCH operator) consider only those rows with the languageid column set to 0. To query for rows with other languageid values, a constraint of the form &quot;</source>
          <target state="translated">默认情况下,FTS查询(那些使用MATCH操作符的查询)只考虑那些将languageid列设置为0的记录。 要查询具有其他languageid值的记录,需要一个形式为&quot;&quot;的约束条件。</target>
        </trans-unit>
        <trans-unit id="a4ce99b6ecd6b9193290236a519a16ace8c29ade" translate="yes" xml:space="preserve">
          <source>By default, FTS3/4 occasionally merges together two or more of the b-trees that make up its full-text index within an INSERT, UPDATE or DELETE statement executed by the user. This means that any operation on an FTS3/4 table may turn out to be surprisingly slow, as FTS3/4 may unpredictably choose to merge together two or more large b-trees within it. FTS5 uses incremental merging by default, which limits the amount of processing that may take place within any given INSERT, UPDATE or DELETE operation.</source>
          <target state="translated">默认情况下,FTS3/4偶尔会在用户执行的INSERT、UPDATE或DELETE语句中合并两个或更多构成其全文索引的b树。这意味着对FTS3/4表的任何操作都可能会变得出奇的慢,因为FTS3/4可能会不可预知地选择将其中的两个或更多的大b树合并在一起。FTS5默认使用增量合并,这限制了在任何给定的INSERT、UPDATE或DELETE操作中可能发生的处理量。</target>
        </trans-unit>
        <trans-unit id="f6e0aaa9f2f3d9d7bf351208161c2a3a5ac7e955" translate="yes" xml:space="preserve">
          <source>By default, FTS5 full-text searches are case-independent. Like any other SQL query that does not contain an ORDER BY clause, the example above returns results in an arbitrary order. To sort results by relevance (most to least relevant), an ORDER BY may be added to a full-text query as follows:</source>
          <target state="translated">默认情况下,FTS5全文搜索是不分大小写的。像任何其他不包含ORDER BY子句的SQL查询一样,上面的例子以任意顺序返回结果。要按相关性(从最相关到最不相关)对结果进行排序,可以在全文查询中添加一个ORDER BY,如下所示。</target>
        </trans-unit>
        <trans-unit id="9bae9dce645a20ac5b291708dfb54aa225ce0774" translate="yes" xml:space="preserve">
          <source>By default, FTS5 maintains a single index recording the location of each token instance within the document set. This means that querying for complete tokens is fast, as it requires a single lookup, but querying for a prefix token can be slow, as it requires a range scan. For example, to query for the prefix token &quot;abc*&quot; requires a range scan of all tokens greater than or equal to &quot;abc&quot; and less than &quot;abd&quot;.</source>
          <target state="translated">默认情况下,FTS5 维护一个单一索引,记录文档集内每个标记实例的位置。这意味着查询完整令牌的速度很快,因为它只需要一次查找,但查询前缀令牌的速度可能很慢,因为它需要范围扫描。例如,查询前缀标记 &quot;abc*&quot;需要对所有大于或等于 &quot;abc &quot;且小于 &quot;abd &quot;的标记进行范围扫描。</target>
        </trans-unit>
        <trans-unit id="ff82a6b03b77139ee1bba47d5624340bd5b1daef" translate="yes" xml:space="preserve">
          <source>By default, SQLite assumes that all data uses a fixed-size 8-bit character (iso8859). But if you give the --enable-utf8 option to the configure script, then the library assumes UTF-8 variable sized characters. This makes a difference for the LIKE and GLOB operators and the LENGTH() and SUBSTR() functions. The static string &lt;b&gt;sqlite_encoding&lt;/b&gt; will be set to either &quot;UTF-8&quot; or &quot;iso8859&quot; to indicate how the library was compiled. In addition, the &lt;b&gt;sqlite.h&lt;/b&gt; header file will define one of the macros &lt;b&gt;SQLITE_UTF8&lt;/b&gt; or &lt;b&gt;SQLITE_ISO8859&lt;/b&gt;, as appropriate.</source>
          <target state="translated">默认情况下，SQLite假定所有数据都使用固定大小的8位字符（iso8859）。但是，如果将--enable-utf8选项提供给configure脚本，则该库将采用UTF-8可变大小的字符。这对LIKE和GLOB运算符以及LENGTH（）和SUBSTR（）函数有所不同。静态字符串&lt;b&gt;sqlite_encoding&lt;/b&gt;将设置为&amp;ldquo; UTF-8&amp;rdquo;或&amp;ldquo; iso8859&amp;rdquo;，以指示如何编译该库。另外，&lt;b&gt;sqlite.h&lt;/b&gt;头文件将根据需要定义宏&lt;b&gt;SQLITE_UTF8&lt;/b&gt;或&lt;b&gt;SQLITE_ISO8859之一&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="cbc8ea1232230a6d65d66bdbfc39e47fe8c9edc5" translate="yes" xml:space="preserve">
          <source>By default, SQLite assumes that an operating system call to write a range of bytes will not damage or alter any bytes outside of that range even if a power loss or OS crash occurs during that write. We call this the &quot;&lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt;&quot; property. Prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_7_9.html&quot;&gt;version 3.7.9&lt;/a&gt; (2011-11-01), SQLite did not assume powersafe overwrite. But with the standard sector size increasing from 512 to 4096 bytes on most disk drives, it has become necessary to assume powersafe overwrite in order to maintain historical performance levels and so powersafe overwrite is assumed by default in recent versions of SQLite. The assumption of powersafe overwrite property can be disabled at compile-time or a run-time if desired. See the &lt;a href=&quot;psow&quot;&gt;powersafe overwrite documentation&lt;/a&gt; for further details.</source>
          <target state="translated">默认情况下，SQLite假定操作系统调用写入一个字节范围不会损坏或更改该范围之外的任何字节，即使在该写入过程中发生断电或操作系统崩溃。我们将其称为&amp;ldquo; &lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt; &amp;rdquo;属性。在&lt;a href=&quot;https://sqlite.org/releaselog/3_7_9.html&quot;&gt;版本3.7.9&lt;/a&gt;（2011-11-01）之前，SQLite并未假定Powersafe覆盖。但是，随着大多数磁盘驱动器上的标准扇区大小从512字节增加到4096字节，为了保持历史性能水平，有必要进行powersafe覆盖，因此在最新版本的SQLite中默认采用powersafe覆盖。如果需要，可以在编译时或运行时禁用对powersafe覆盖属性的假设。有关更多详细信息，请参见&lt;a href=&quot;psow&quot;&gt;powersafe覆盖文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f018eca355fa9ae5d020ba88bd8ea21f258703c5" translate="yes" xml:space="preserve">
          <source>By default, SQLite does a checkpoint automatically when the WAL file reaches a threshold size of 1000 pages. (The &lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt; compile-time option can be used to specify a different default.) Applications using WAL do not have to do anything in order to for these checkpoints to occur. But if they want to, applications can adjust the automatic checkpoint threshold. Or they can turn off the automatic checkpoints and run checkpoints during idle moments or in a separate thread or process.</source>
          <target state="translated">默认情况下，当WAL文件达到​​1000页的阈值大小时，SQLite自动执行一个检查点。 （&lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt;编译时选项可用于指定其他默认值。）使用WAL的应用程序不必执行任何操作即可出现这些检查点。但是如果需要，应用程序可以调整自动检查点阈值。或者，他们可以在空闲时或在单独的线程或进程中关闭自动检查点并运行检查点。</target>
        </trans-unit>
        <trans-unit id="c47d73038962ba3e0484234ad47892e41a6eccb3" translate="yes" xml:space="preserve">
          <source>By default, SQLite keeps statistics on its memory usage. These statistics are useful in helping to determine how much memory an application really needs. The statistics can also be used in high-reliability system to determine if the memory usage is coming close to or exceeding the limits of the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt; and hence that the memory allocation subsystem is liable to breakdown.</source>
          <target state="translated">默认情况下，SQLite会保留有关其内存使用情况的统计信息。这些统计信息有助于确定应用程序真正需要多少内存。该统计信息还可用于高可靠性系统中，以确定内存使用情况是否接近或超过&lt;a href=&quot;malloc#nofrag&quot;&gt;Robson证明&lt;/a&gt;的限制，因此内存分配子系统易于崩溃。</target>
        </trans-unit>
        <trans-unit id="45a42d60e1bd3a274255ba5930fab23192de66e7" translate="yes" xml:space="preserve">
          <source>By default, SQLite obtains the memory it needs for objects and cache from the malloc()/free() implementation of the standard library. There is also on-going work with experimental memory allocators that satisfy all memory requests from a single fixed memory buffer handed to SQLite at application start. Additional information on these experimental memory allocators will be provided in a future revision of this document.</source>
          <target state="translated">默认情况下,SQLite从标准库的malloc()/free()实现中获取对象和缓存所需的内存。目前还在进行实验性内存分配器的工作,这些内存分配器可以满足应用程序启动时交给SQLite的一个固定内存缓冲区的所有内存请求。关于这些实验性内存分配器的其他信息将在本文档的未来修订版中提供。</target>
        </trans-unit>
        <trans-unit id="f1f4239650661b10de63616260d0037b2cc6746e" translate="yes" xml:space="preserve">
          <source>By default, SQLite uses the malloc(), realloc(), and free() routines from the standard C library for its memory allocation needs. These routines are surrounded by a thin wrapper that also provides a &quot;memsize()&quot; function that will return the size of an existing allocation. The memsize() function is needed to keep an accurate count of the number of bytes of outstanding memory; memsize() determines how many bytes to remove from the outstanding count when an allocation is freed. The default allocator implements memsize() by always allocating 8 extra bytes on each malloc() request and storing the size of the allocation in that 8-byte header.</source>
          <target state="translated">默认情况下,SQLite使用标准C库中的malloc()、realloc()和free()例程来满足其内存分配需求。这些例程被一个薄薄的封装器包围,该封装器还提供了一个 &quot;memsize()&quot;函数,该函数将返回现有分配的大小。memsize()函数需要准确地统计未分配内存的字节数;memsize()决定当一个分配被释放时,要从未分配计数中删除多少字节。默认的分配器实现memsize()的方法是,在每次malloc()请求时,总是额外分配8个字节,并将分配的大小存储在这8个字节的头中。</target>
        </trans-unit>
        <trans-unit id="ac7bf7e7f400c7dac01c89761055dce039c96113" translate="yes" xml:space="preserve">
          <source>By default, SQLite will automatically checkpoint whenever a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; occurs that causes the WAL file to be 1000 pages or more in size, or when the last database connection on a database file closes. The default configuration is intended to work well for most applications. But programs that want more control can force a checkpoint using the &lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;wal_checkpoint pragma&lt;/a&gt; or by calling the &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; C interface. The automatic checkpoint threshold can be changed or automatic checkpointing can be completely disabled using the &lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; or by calling the &lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint()&lt;/a&gt; C interface. A program can also use &lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; to register a callback to be invoked whenever any transaction commits to the WAL. This callback can then invoke &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; or &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; based on whatever criteria it thinks is appropriate. (The automatic checkpoint mechanism is implemented as a simple wrapper around &lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt;.)</source>
          <target state="translated">默认情况下，只要发生&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;导致WAL文件的大小为1000页或更多，或者关闭数据库文件的最后一个数据库连接，SQLite就会自动检查点。默认配置适用于大多数应用程序。但是，需要更多控制的程序可以使用&lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;wal_checkpoint编译指示&lt;/a&gt;或调用&lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint（）&lt;/a&gt; C接口来强制执行检查点。可以使用&lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint编译指示&lt;/a&gt;或调用&lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint（）&lt;/a&gt; C接口来更改自动检查点阈值或完全禁用自动检查点。程序也可以使用&lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;注册一个回调，以便在任何事务提交到WAL时被调用。然后，此回调可以根据其认为合适的标准来调用&lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint（）&lt;/a&gt;或&lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;。（自动检查点机制被实现为&lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;的简单包装器。）</target>
        </trans-unit>
        <trans-unit id="dfe31588b0add6c729f8eab371bfea7925cb6297" translate="yes" xml:space="preserve">
          <source>By default, VACUUM only works only on the main database. &lt;a href=&quot;lang_attach&quot;&gt;Attached databases&lt;/a&gt; can be vacuumed by appending the appropriate schema-name to the VACUUM statement.</source>
          <target state="translated">默认情况下，VACUUM仅在主数据库上起作用。通过将适当的架构名称附加到VACUUM语句，可以清理&lt;a href=&quot;lang_attach&quot;&gt;附加的数据库&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="609f717a6d90d2816632d1db2908a5d9109c172f" translate="yes" xml:space="preserve">
          <source>By default, coordinates are stored in an R*Tree using 32-bit floating point values. When a coordinate cannot be exactly represented by a 32-bit floating point number, the lower-bound coordinates are rounded down and the upper-bound coordinates are rounded up. Thus, bounding boxes might be slightly larger than specified, but will never be any smaller. This is exactly what is desired for doing the more common &quot;overlapping&quot; queries where the application wants to find every entry in the R*Tree that overlaps a query bounding box. Rounding the entry bounding boxes outward might cause a few extra entries to appears in an overlapping query if the edge of the entry bounding box corresponds to an edge of the query bounding box. But the overlapping query will never miss a valid table entry.</source>
          <target state="translated">默认情况下,坐标使用32位浮点值存储在R*Tree中,当一个坐标不能用32位浮点数精确表示时,下界坐标向下取整,上界坐标向上取整。当一个坐标不能用32位浮点数精确表示时,下界坐标向下舍入,上界坐标向上舍入。因此,边界框可能比指定的略大,但绝不会小。这正是做比较常见的 &quot;重叠 &quot;查询所需要的,在这种情况下,应用程序希望在R*Tree中找到与查询边界框重叠的每个条目。如果条目边界框的边缘与查询边界框的边缘相对应,将条目边界框向外舍入可能会导致重叠查询中出现一些额外的条目。但重叠查询绝不会漏掉一个有效的表项。</target>
        </trans-unit>
        <trans-unit id="199efd35071a0aa576610e8f4fe7005becc87773" translate="yes" xml:space="preserve">
          <source>By default, diacritics are removed from all Latin script characters. This means, for example, that &quot;A&quot;, &quot;a&quot;, &quot;&amp;Agrave;&quot;, &quot;&amp;agrave;&quot;, &quot;&amp;Acirc;&quot; and &quot;&amp;acirc;&quot; are all considered to be equivalent.</source>
          <target state="translated">默认情况下，变音符号将从所有拉丁脚本字符中删除。例如，这意味着&amp;ldquo; A&amp;rdquo;，&amp;ldquo; a&amp;rdquo;，&amp;ldquo;&amp;Agrave;&amp;rdquo;，&amp;ldquo;&amp;agrave;&amp;rdquo;，&amp;ldquo;&amp;Acirc;&amp;rdquo;和&amp;ldquo;&amp;acirc;&amp;rdquo;都被认为是等效的。</target>
        </trans-unit>
        <trans-unit id="bb034dd2f0250c21e84e164917272d1dc5842d40" translate="yes" xml:space="preserve">
          <source>By default, differences in the schema or content of virtual tables are not reported on.</source>
          <target state="translated">默认情况下,虚拟表的模式或内容的差异不会被报告。</target>
        </trans-unit>
        <trans-unit id="b77f26d39d106302cf0e476c578f7ebf5e3ef7c7" translate="yes" xml:space="preserve">
          <source>By default, each INSERT statement is its own transaction. But if you surround multiple INSERT statements with &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;...&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; then all the inserts are grouped into a single transaction. The time needed to commit the transaction is amortized over all the enclosed insert statements and so the time per insert statement is greatly reduced.</source>
          <target state="translated">默认情况下，每个INSERT语句都是其自己的事务。但是，如果用&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; ... &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;包围多个INSERT语句，则所有插入都被分组为一个事务。提交事务所需的时间在所有随附的insert语句中摊销，因此大大减少了每个insert语句的时间。</target>
        </trans-unit>
        <trans-unit id="6a7a241c9fa980ec6fabd179e76034fe7898c1e2" translate="yes" xml:space="preserve">
          <source>By default, each column is between 1 and 10 characters wide, depending on the column header name and the width of the first column of data. Data that is too wide to fit in a column is truncated. Use the &quot;.width&quot; dot-command to adjust column widths, like this:</source>
          <target state="translated">默认情况下,每列的宽度在1到10个字符之间,取决于列头名称和第一列数据的宽度。太宽的数据如果不能容纳在一列中,就会被截断。使用&quot;.width &quot;点命令来调整列宽,像这样。</target>
        </trans-unit>
        <trans-unit id="5e4318cdb175f91c3caf7375a2080f232459374d" translate="yes" xml:space="preserve">
          <source>By default, every row in SQLite has a special column, usually called the &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;&quot;, that uniquely identifies that row within the table. However if the phrase &quot;WITHOUT ROWID&quot; is added to the end of a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement, then the special &quot;rowid&quot; column is omitted. There are sometimes space and performance advantages to omitting the rowid.</source>
          <target state="translated">默认情况下，SQLite中的每一行都有一个特殊的列，通常称为&amp;ldquo; &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; &amp;rdquo;，用于唯一标识表中的该行。但是，如果将短语&amp;ldquo; WITHOUT ROWID&amp;rdquo;添加到&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句的末尾，则将省略特殊的&amp;ldquo; rowid&amp;rdquo;列。有时，省略rowid具有空间和性能优势。</target>
        </trans-unit>
        <trans-unit id="d6ef17af0abc70adef74ccbccb6e7ada9c1f618f" translate="yes" xml:space="preserve">
          <source>By default, kvtest runs the database I/O measurements all within a single transaction. Use the --multitrans option to run each blob read or write in a separate transaction. The --multitrans option makes SQLite much slower, and uncompetitive with direct disk I/O. This option proves, yet again, that to get the most performance out of SQLite, you should group as much database interaction as possible within a single transaction.</source>
          <target state="translated">默认情况下,kvtest 在一个事务中运行所有的数据库 I/O 测量。使用--multitrans选项可以在一个单独的事务中运行每个blob的读或写。--multitrans选项使SQLite的运行速度大大降低,而且与直接的磁盘I/O相比没有竞争力。这个选项再次证明,要想从SQLite中获得最大的性能,你应该将尽可能多的数据库交互集中在一个事务中。</target>
        </trans-unit>
        <trans-unit id="a027e685d0b82e63c37ab615c6c8b1bef894cf6d" translate="yes" xml:space="preserve">
          <source>By default, sqldiff attempts to process all non-virtual tables within the two databases provided to it. If any table appears in one database but not the other, or if any table has a slightly different schema in one database it is an error. The &quot;--table&quot; option may be useful if this causes a problem</source>
          <target state="translated">默认情况下,sqldiff会尝试处理提供给它的两个数据库中的所有非虚拟表。如果任何表出现在一个数据库中,而不是在另一个数据库中,或者任何表在一个数据库中的模式略有不同,都是一个错误。如果这导致了问题,&quot;-table &quot;选项可能会有用。</target>
        </trans-unit>
        <trans-unit id="46b22419bd1a4fd00ad28b08bf067b6f9f4f5e90" translate="yes" xml:space="preserve">
          <source>By default, sqlite3 sends query results to standard output. You can change this using the &quot;.output&quot; and &quot;.once&quot; commands. Just put the name of an output file as an argument to .output and all subsequent query results will be written to that file. Or use the .once command instead of .output and output will only be redirected for the single next command before reverting to the console. Use .output with no arguments to begin writing to standard output again. For example:</source>
          <target state="translated">默认情况下,sqlite3将查询结果发送到标准输出。你可以使用&quot;.output &quot;和&quot;.once &quot;命令来改变这一点。只需将输出文件的名称作为.output的参数,所有后续的查询结果将被写入该文件。或者使用.once命令代替.output,输出将只被重定向为单一的下一条命令,然后再恢复到控制台。使用没有参数的.output又开始写到标准输出。例如</target>
        </trans-unit>
        <trans-unit id="e508a45fb514da22df2b29ba2714c0232eb3c718" translate="yes" xml:space="preserve">
          <source>By default, swarmvtab attempts to limit the number of simultaneously open databases to nine. This parameter allows that limit to be changed. For example, to create a swarmvtab table that may hold up to 30 databases open simultaneously:</source>
          <target state="translated">默认情况下,swarmvtab 会将同时打开的数据库数量限制为 9 个。这个参数允许改变这个限制。例如,创建一个可以同时打开 30 个数据库的 swarmvtab 表。</target>
        </trans-unit>
        <trans-unit id="aac34cb1103bf35fa437aa535e48e93e51a7d344" translate="yes" xml:space="preserve">
          <source>By default, the &quot;.expert&quot; command recommends indexes based on the query and database schema alone. This is similar to the way the &lt;a href=&quot;optoverview&quot;&gt;SQLite query planner&lt;/a&gt; selects indexes for queries if the user has not run the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command on the database to generate data distribution statistics.</source>
          <target state="translated">默认情况下，&amp;ldquo;。expert&amp;rdquo;命令仅根据查询和数据库模式推荐索引。如果用户没有在数据库上运行&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令来生成数据分布统计信息，则这类似于&lt;a href=&quot;optoverview&quot;&gt;SQLite查询计划器&lt;/a&gt;为查询选择索引的方式。</target>
        </trans-unit>
        <trans-unit id="79e59781472aaf1cab549c7756351e991a52f37c" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface will automatically invoke &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; to reset the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; if necessary. This compile-time option changes that behavior so that &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; will return &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; if it called again after returning anything other than &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, or &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; unless there was an intervening call to &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt;.</source>
          <target state="translated">默认情况下，必要时&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;接口将自动调用&lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;以重置&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;。此编译时选项会更改该行为，以便&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;如果在返回&lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;，&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;或&lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;以外的任何值后再次调用，则它将返回&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;，除非对&lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;进行了中间调用。</target>
        </trans-unit>
        <trans-unit id="b8f030cbd6427054daf45dea55ca6b9a3924a3dd" translate="yes" xml:space="preserve">
          <source>By default, the SQLite core double checks all constraints on each row of the virtual table that it receives. If such a check is redundant, the xBestFilter method can suppress that double-check by setting aConstraintUsage[].omit.</source>
          <target state="translated">默认情况下,SQLite核心会对接收到的虚拟表的每一行的所有约束进行双重检查。如果这种检查是多余的,xBestFilter方法可以通过设置aConstraintUsage[].省略来抑制这种双重检查。</target>
        </trans-unit>
        <trans-unit id="fa0f172004db89e74c2b903c6ed15681a8554ce0" translate="yes" xml:space="preserve">
          <source>By default, the output of EXPLAIN QUERY PLAN commands does not include output for any operations performed by trigger programs. This option is used to set or clear (the default) a flag that governs this behavior. The first parameter passed to this operation is an integer - positive to enable output for trigger programs, or zero to disable it, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether output-for-triggers has been disabled - 0 if it is not disabled, 1 if it is.</source>
          <target state="translated">默认情况下,EXPLAIN QUERY PLAN命令的输出不包括触发程序执行的任何操作的输出。这个选项用于设置或清除(默认情况下)一个管理这种行为的标志。传递给该操作的第一个参数是一个整数--正值表示启用触发程序的输出,零值表示禁用,负值表示保持设置不变。第二个参数是一个指向整数的指针,将0或1写入其中,以表示是否禁用了触发程序的输出--如果没有禁用则为0,如果禁用则为1。</target>
        </trans-unit>
        <trans-unit id="d45ac6e349cce0d243d17d663e9e87155d75add6" translate="yes" xml:space="preserve">
          <source>By default, the porter tokenizer operates as a wrapper around the default tokenizer (unicode61). Or, if one or more extra arguments are added to the &quot;tokenize&quot; option following &quot;porter&quot;, they are treated as a specification for the underlying tokenizer that the porter stemmer uses. For example:</source>
          <target state="translated">默认情况下,porter tokenizer 是作为默认 tokenizer (unicode61)的封装器来运行的。或者,如果在 &quot;porter &quot;后面的 &quot;tokenize &quot;选项中添加了一个或多个额外的参数,它们将被视为porter stemmer使用的底层tokenizer的规范。例如</target>
        </trans-unit>
        <trans-unit id="923e8b64eceb6502080849392eadafdbb5ce98eb" translate="yes" xml:space="preserve">
          <source>By default, the sessions module streaming interfaces attempt to input and output data in approximately 1 KiB chunks. This operand may be used to set and query the value of this configuration setting. The pointer passed as the second argument must point to a value of type (int). If this value is greater than 0, it is used as the new streaming data chunk size for both input and output. Before returning, the (int) value pointed to by pArg is set to the final value of the streaming interface chunk size.</source>
          <target state="translated">默认情况下,会话模块流媒体接口试图以大约1KiB的块数输入和输出数据。这个操作数可以用来设置和查询这个配置设置的值。作为第二个参数传递的指针必须指向一个类型为(int)的值。如果这个值大于0,它将被用作输入和输出的新流媒体数据块大小。在返回之前,pArg指向的(int)值被设置为流媒体接口分块大小的最终值。</target>
        </trans-unit>
        <trans-unit id="ed67e473742eb7c111c47a0cfdbbdb68f21a394b" translate="yes" xml:space="preserve">
          <source>By default, the shell is now in &quot;auto-explain&quot; mode. The output of &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; commands is automatically formatted.</source>
          <target state="translated">默认情况下，外壳现在处于&amp;ldquo;自动解释&amp;rdquo;模式。&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;命令的输出将自动格式化。</target>
        </trans-unit>
        <trans-unit id="52d930b9eee7711ba25f4fd9b5cbc893a2bf348f" translate="yes" xml:space="preserve">
          <source>By default, the spellfix1 table returns no more than 20 results. (It might return less than 20 if there were fewer good matches.) You can change the upper bound on the number of returned rows by adding a &quot;top=N&quot; term to the WHERE clause of your query, where N is the new maximum. For example, to see the 5 best matches:</source>
          <target state="translated">默认情况下,spellfix1表返回的结果不会超过20条。(如果好的匹配结果较少,它可能会返回少于 20 条。)你可以通过在查询的 WHERE 子句中添加一个 &quot;top=N &quot;项来改变返回行数的上限,其中 N 是新的最大值。例如,要查看5个最佳匹配项。</target>
        </trans-unit>
        <trans-unit id="801f0fef23ca30c740bc98f388b5820b01c0a8aa" translate="yes" xml:space="preserve">
          <source>By default, there is a single row in the DBSTAT table for each btree page the database file. Each row provides information about the space utilization of that one page of the database. However, if the hidden column &quot;aggregate&quot; is TRUE, then results are aggregated and there is a single row in the DBSTAT table for each btree in the database, providing information about space utilization across the entire btree.</source>
          <target state="translated">默认情况下,数据库文件中的每一个btree页在DBSTAT表中都有一行。每一行都提供了这一页数据库的空间利用率的信息。但是,如果隐藏的列 &quot;aggregated &quot;为TRUE,那么结果就会被聚合,数据库中的每一个btree在DBSTAT表中都有一条单行,提供整个btree的空间利用率信息。</target>
        </trans-unit>
        <trans-unit id="fa387565dd5968c7d1760a2e2262809354a9a035" translate="yes" xml:space="preserve">
          <source>By enclosing it in double quotes (&quot;). Within a string, any embedded double quote characters may be escaped SQL-style - by adding a second double-quote character.</source>
          <target state="translated">用双引号(&quot;)括起来。在一个字符串中,任何嵌入的双引号字符都可以通过添加第二个双引号字符进行SQL式转义。</target>
        </trans-unit>
        <trans-unit id="84617083eaab12542d0a6d482dc6332adeedf772" translate="yes" xml:space="preserve">
          <source>By explicitly specifying tables using one call to &lt;a href=&quot;session/sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; for each table, or</source>
          <target state="translated">通过使用每个表对&lt;a href=&quot;session/sqlite3session_attach&quot;&gt;sqlite3session_attach（）的&lt;/a&gt;调用来显式指定表，或者</target>
        </trans-unit>
        <trans-unit id="7ec7970e0cfef9d2d98bfdb89f93e1b8b4b4b117" translate="yes" xml:space="preserve">
          <source>By invoking the xCheckReservedLock() method of the file-handle opened on the database file, SQLite checks if some other connection holds a</source>
          <target state="translated">通过调用在数据库文件上打开的文件柄的xCheckReservedLock()方法,SQLite检查其他连接是否持有</target>
        </trans-unit>
        <trans-unit id="e392907538e008d1f980f80b5391101815ed2a70" translate="yes" xml:space="preserve">
          <source>By mapping all synonyms to a single token. In this case, the In the above example, this means that the tokenizer returns the same token for inputs &quot;first&quot; and &quot;1st&quot;. Say that token is in fact &quot;first&quot;, so that when the user inserts the document &quot;I won 1st place&quot; entries are added to the index for tokens &quot;i&quot;, &quot;won&quot;, &quot;first&quot; and &quot;place&quot;. If the user then queries for '1st + place', the tokenizer substitutes &quot;first&quot; for &quot;1st&quot; and the query works as expected.</source>
          <target state="translated">通过将所有的同义词映射到一个标记。在这个例子中,在上面的例子中,这意味着tokenizer为输入 &quot;first &quot;和 &quot;1st &quot;返回相同的token。假设这个标记实际上是 &quot;第一&quot;,那么当用户插入文档 &quot;I won 1st place &quot;时,&quot;i&quot;、&quot;won&quot;、&quot;first &quot;和 &quot;place &quot;的标记将被添加到索引中。如果用户查询 &quot;1st+place&quot;,tokenizer就会将 &quot;first &quot;替换为 &quot;1st&quot;,然后查询就会如期进行。</target>
        </trans-unit>
        <trans-unit id="d6c6c3e21f2551827a19fdcc87eccf2596523e84" translate="yes" xml:space="preserve">
          <source>By mapping all synonyms to a single token. In this case, using the above example, this means that the tokenizer returns the same token for inputs &quot;first&quot; and &quot;1st&quot;. Say that token is in fact &quot;first&quot;, so that when the user inserts the document &quot;I won 1st place&quot; entries are added to the index for tokens &quot;i&quot;, &quot;won&quot;, &quot;first&quot; and &quot;place&quot;. If the user then queries for '1st + place', the tokenizer substitutes &quot;first&quot; for &quot;1st&quot; and the query works as expected.</source>
          <target state="translated">通过将所有的同义词映射到一个标记。在本例中,使用上面的例子,这意味着tokenizer为输入 &quot;first &quot;和 &quot;1st &quot;返回相同的token。假设这个标记实际上是 &quot;first&quot;,那么当用户插入文档 &quot;I won 1st place &quot;时,标记 &quot;i&quot;、&quot;won&quot;、&quot;first &quot;和 &quot;place &quot;的条目将被添加到索引中。如果用户查询 &quot;1st+place&quot;,tokenizer就会将 &quot;first &quot;替换为 &quot;1st&quot;,然后查询就会如期进行。</target>
        </trans-unit>
        <trans-unit id="f19cb00f7026582f508ec895d006b5124a9aeb30" translate="yes" xml:space="preserve">
          <source>By querying the index for all synonyms of each query term separately. In this case, when tokenizing query text, the tokenizer may provide multiple synonyms for a single term within the document. FTS5 then queries the index for each synonym individually. For example, faced with the query:</source>
          <target state="translated">通过在索引中分别查询每个查询词的所有同义词。在这种情况下,当对查询文本进行标记化时,标记化器可能会为文档中的一个术语提供多个同义词。然后,FTS5分别查询每个同义词的索引。例如,面对查询。</target>
        </trans-unit>
        <trans-unit id="55b05786af4043a1be86d71e95ee1411780e7ee4" translate="yes" xml:space="preserve">
          <source>By setting it to an empty string to create a contentless FTS5 table. In this case FTS5 assumes that the original column values are unavailable to it when processing queries. Full-text queries and some auxiliary functions can still be used, but no column values apart from the rowid may be read from the table.</source>
          <target state="translated">通过将其设置为空字符串来创建一个无内容的FTS5表。在这种情况下,FTS5在处理查询时,假定原始列值对它来说是不可用的。全文查询和一些辅助函数仍然可以使用,但是除了rowid之外,不能从表中读取任何列值。</target>
        </trans-unit>
        <trans-unit id="61a66a14e7dcfe0861d93ec30802747dfb7523a1" translate="yes" xml:space="preserve">
          <source>By setting it to the name of a database object (table, virtual table or view) that may be queried by FTS5 at any time to retrieve the column values. This is known as an &quot;external content&quot; table. In this case all FTS5 functionality may be used, but it is the responsibility of the user to ensure that the contents of the full-text index are consistent with the named database object. If they are not, query results may be unpredictable.</source>
          <target state="translated">通过将其设置为数据库对象(表、虚拟表或视图)的名称,FTS5可随时查询该对象以检索列值。这就是所谓的 &quot;外部内容 &quot;表。在这种情况下,可以使用FTS5的所有功能,但用户有责任确保全文索引的内容与命名的数据库对象一致。如果不一致,查询结果可能无法预测。</target>
        </trans-unit>
        <trans-unit id="b65e88a6a0b747d6c1e54c4edd9925d09b470f08" translate="yes" xml:space="preserve">
          <source>By specifying that all tables in the database should be monitored for changes using a call to &lt;a href=&quot;session/sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; with a NULL argument, or</source>
          <target state="translated">通过使用带有NULL参数的&lt;a href=&quot;session/sqlite3session_attach&quot;&gt;sqlite3session_attach（）&lt;/a&gt;调用来指定应监视数据库中的所有表的更改，或者</target>
        </trans-unit>
        <trans-unit id="63f834f4a2da63acc54bc935f1fd1ad5ded1c97a" translate="yes" xml:space="preserve">
          <source>By the time &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; is invoked by wait_for_unlock_notify(), it is possible that the blocking connection that prevented the sqlite3_step() or sqlite3_prepare_v2() call from succeeding has already finished its transaction. In this case, the unlock-notify callback is invoked immediately, before &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; returns. Or, it is possible that the unlock-notify callback is invoked by a second thread after &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; is called but before the thread starts waiting to be asynchronously signaled.</source>
          <target state="translated">到wait_for_unlock_notify（）调用&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）时&lt;/a&gt;，阻止sqlite3_step（）或sqlite3_prepare_v2（）调用成功的阻塞连接可能已经完成了其事务。在这种情况下，在&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;返回之前，将立即调用unlock-notify回调。或者，有可能在调用&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;之后但在线程开始等待异步信号通知之前，第二个线程调用unlock-notify回调。</target>
        </trans-unit>
        <trans-unit id="294016815718412ee0c20270b6745c8ced5712e1" translate="yes" xml:space="preserve">
          <source>By using its own built-in implementation, SQLite guarantees that the output will be the same on all platforms and in all LOCALEs. This is important for consistency and for testing. It would be problematic if one machine gave and answer of &quot;5.25e+08&quot; and another gave an answer of &quot;5.250e+008&quot;. Both answers are correct, but it is better when SQLite always gives the same answer.</source>
          <target state="translated">通过使用自己的内置实现,SQLite保证在所有平台和所有LOCALE中的输出都是一样的。这对于一致性和测试来说是很重要的。如果一台机器给出的答案是 &quot;5.25e+08&quot;,而另一台机器给出的答案是 &quot;5.250e+008&quot;,那就有问题了。这两种答案都是正确的,但最好是SQLite总是给出相同的答案。</target>
        </trans-unit>
        <trans-unit id="478bcd9433faa7931ee1c7c1b62ccda2a8f4f8e8" translate="yes" xml:space="preserve">
          <source>By using standard SQL expressions in the WHERE clause of a SELECT query, a programmer can query for all R*Tree entries that intersect with or are contained within a particular bounding-box. Custom R*Tree queries, using the MATCH operator in the WHERE clause of a SELECT, allow the programmer to query for the set of R*Tree entries that intersect any arbitrary region or shape, not just a box. This capability is useful, for example, in computing the subset of objects in the R*Tree that are visible from a camera positioned in 3-D space.</source>
          <target state="translated">通过在SELECT查询的WHERE子句中使用标准的SQL表达式,程序员可以查询与特定的边界框相交或包含在边界框内的所有R*Tree条目。自定义R*Tree查询,在SELECT的WHERE子句中使用MATCH运算符,允许程序员查询与任何任意区域或形状相交的R*Tree条目集,而不仅仅是一个盒子。例如,这种功能在计算R*Tree中从定位在三维空间的摄像机中可以看到的对象子集时非常有用。</target>
        </trans-unit>
        <trans-unit id="89a11056dc1624db725c970738aa5aaf2b86e420" translate="yes" xml:space="preserve">
          <source>Byte offset</source>
          <target state="translated">字节偏移</target>
        </trans-unit>
        <trans-unit id="3552062ee633a28da0a78f6b8da0963926758e2e" translate="yes" xml:space="preserve">
          <source>Byte offset to the start of the page</source>
          <target state="translated">到页首的字节偏移</target>
        </trans-unit>
        <trans-unit id="40c37d34180ee81abeec6396f466a7bf1d1f2f45" translate="yes" xml:space="preserve">
          <source>Bytecode Engine</source>
          <target state="translated">字节码引擎</target>
        </trans-unit>
        <trans-unit id="e7d87e87cd071442d28d7e11c0a34595a73b4b95" translate="yes" xml:space="preserve">
          <source>Bytecode and tables_used are &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; built into SQLite that access information about &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;. Both bytecode and tables_used operate as &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;. They take a single required argument which is either the text of an SQL statement, or a pointer to an existing prepared statement. The bytecode function returns one row of result for each &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; operation in the prepared statement. The tables_used function returns one row for each persistent btree (either a table or an index) accessed by the prepared statement.</source>
          <target state="translated">Bytecode和table_used是SQLite内置的&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;，用于访问有关&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句的&lt;/a&gt;信息。字节码和table_used都可以用作&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;。它们采用一个必需的参数，该参数可以是SQL语句的文本，也可以是指向现有的准备好的语句的指针。字节码函数为准备好的语句中的每个&lt;a href=&quot;opcode&quot;&gt;字节码&lt;/a&gt;操作返回一行结果。 table_used函数为由prepared语句访问的每个持久性btree（表或索引）返回一行。</target>
        </trans-unit>
        <trans-unit id="8e5fdab92dece79d7629d6d901687613ddc6ab5a" translate="yes" xml:space="preserve">
          <source>Bytes</source>
          <target state="translated">Bytes</target>
        </trans-unit>
        <trans-unit id="6e99d2b1b3cf05d1cb901ea3f769e34d773ba90a" translate="yes" xml:space="preserve">
          <source>Bytes 12-15 of the</source>
          <target state="translated">第12-15字节的</target>
        </trans-unit>
        <trans-unit id="89a9bc1f87191389726b0ed1804032da963a975c" translate="yes" xml:space="preserve">
          <source>Bytes 16-19 of the</source>
          <target state="translated">字节16-19的</target>
        </trans-unit>
        <trans-unit id="24778eba404891c29eb268fa4b3c469a05e3f5af" translate="yes" xml:space="preserve">
          <source>Bytes 20-23 of the</source>
          <target state="translated">第20-23字节的</target>
        </trans-unit>
        <trans-unit id="5e820fc3c84f6f51bd1f6afe4e8dd983524446cf" translate="yes" xml:space="preserve">
          <source>Bytes 24-27 of the</source>
          <target state="translated">字节24-27的</target>
        </trans-unit>
        <trans-unit id="eb167d60299b524eb07991d2141957c03c9ee5cd" translate="yes" xml:space="preserve">
          <source>Bytes 8-11 of the</source>
          <target state="translated">字节8-11的</target>
        </trans-unit>
        <trans-unit id="a3587157a4089ec8301b2d0f784b91a32e9749e3" translate="yes" xml:space="preserve">
          <source>Bytes of unused &quot;reserved&quot; space at the end of each page. Usually 0.</source>
          <target state="translated">每页末尾未使用的 &quot;保留 &quot;空间的字节数。通常为0。</target>
        </trans-unit>
        <trans-unit id="99c76b931cbafaf267cc3e2ad6a25e46605efcf6" translate="yes" xml:space="preserve">
          <source>Bytes of useful payload on the current page or btree</source>
          <target state="translated">当前页面或btree中有用的有效载荷的字节数。</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="4f3cd44d015b24e6fbf168b36aa5120966aaf5ed" translate="yes" xml:space="preserve">
          <source>C API Requirements Document.</source>
          <target state="translated">C API需求文档。</target>
        </trans-unit>
        <trans-unit id="e9a1acddb6f4bd40edd805612e996267e826e064" translate="yes" xml:space="preserve">
          <source>C Interface</source>
          <target state="translated">C接口</target>
        </trans-unit>
        <trans-unit id="d5efbb98716c6e33e7f3412795c630f8a8a66abd" translate="yes" xml:space="preserve">
          <source>C Interface: Session Module</source>
          <target state="translated">C接口。会话模块</target>
        </trans-unit>
        <trans-unit id="444516d338383f2d17d8f93aa996b6cd1762c79a" translate="yes" xml:space="preserve">
          <source>C is a great language for writing fast code. C is sometimes described as &quot;portable assembly language&quot;. It enables to developers to code as close to the underlying hardware as possible while still remaining portable across platforms.</source>
          <target state="translated">C语言是一种非常适合编写快速代码的语言。C语言有时被描述为 &quot;可移植的汇编语言&quot;。它使开发人员能够在尽可能接近底层硬件的情况下编写代码,同时又能保持跨平台的可移植性。</target>
        </trans-unit>
        <trans-unit id="58790293552f75d17353d3ee29e85a197a62dcbb" translate="yes" xml:space="preserve">
          <source>C-language Interface Specification for SQLite</source>
          <target state="translated">SQLite的C语言接口规范</target>
        </trans-unit>
        <trans-unit id="1ac091b19baa70bc10c3d1156fe018d4a8f6ef6b" translate="yes" xml:space="preserve">
          <source>C-style comments are now accepted by the tokenizer.</source>
          <target state="translated">现在tokenizer可以接受C风格的注释。</target>
        </trans-unit>
        <trans-unit id="d4948b1f21c9b5ee92aa9e005ab2ec94317e417f" translate="yes" xml:space="preserve">
          <source>C-style comments begin with &quot;/*&quot; and extend up to and including the next &quot;*/&quot; character pair or until the end of input, whichever comes first. C-style comments can span multiple lines.</source>
          <target state="translated">C式注释以&quot;/*&quot;开头,一直延伸到并包括下一个 &quot;*/&quot;字符对或直到输入结束,以先到者为准。C型注释可以跨越多行。</target>
        </trans-unit>
        <trans-unit id="e693971cd8c5db36eaa639a8f7f4320b5c7557fd" translate="yes" xml:space="preserve">
          <source>C/C++ Interface For SQLite Version 3</source>
          <target state="translated">SQLite的C/C++接口第3版</target>
        </trans-unit>
        <trans-unit id="b7c9ebb838da580ee5ce0a6b6d3fb9492aadd0cf" translate="yes" xml:space="preserve">
          <source>C/C++ Interface For SQLite Version 3 (old)</source>
          <target state="translated">C/C++接口的SQLite第3版(旧)。</target>
        </trans-unit>
        <trans-unit id="629369eadf6dbb7e5f1900a3d284a7d0ebdf8449" translate="yes" xml:space="preserve">
          <source>CASCADE</source>
          <target state="translated">CASCADE</target>
        </trans-unit>
        <trans-unit id="55c417bda058d7601349aeb7556e3d8607c77f5d" translate="yes" xml:space="preserve">
          <source>CASE</source>
          <target state="translated">CASE</target>
        </trans-unit>
        <trans-unit id="24e95e83710f86d66debac57b5addb22a9ce7983" translate="yes" xml:space="preserve">
          <source>CASE WHEN x=w1 THEN r1 WHEN x=w2 THEN r2 ELSE r3 END</source>
          <target state="translated">CASE WHEN x=w1 THEN r1 WHEN x=w2 THEN r2 ELSE r3 END</target>
        </trans-unit>
        <trans-unit id="fcb688501c6a701cda488771d9ab7d2ba8fccbb2" translate="yes" xml:space="preserve">
          <source>CASE expression</source>
          <target state="translated">CASE表达</target>
        </trans-unit>
        <trans-unit id="c688feeff7f51b86a16bfff0e478b5a113fd0c4a" translate="yes" xml:space="preserve">
          <source>CASE x WHEN w1 THEN r1 WHEN w2 THEN r2 ELSE r3 END</source>
          <target state="translated">CASE x WHEN w1 THEN r1 WHEN w2 THEN r2 ELSE r3 END</target>
        </trans-unit>
        <trans-unit id="274ad8f8387ab7001d3681011456578f35fd9e46" translate="yes" xml:space="preserve">
          <source>CAST</source>
          <target state="translated">CAST</target>
        </trans-unit>
        <trans-unit id="bc9630c4f8bc64a9ad87f06d690b75d5f8954d78" translate="yes" xml:space="preserve">
          <source>CAST expressions</source>
          <target state="translated">CAST表达式</target>
        </trans-unit>
        <trans-unit id="2bab9f8d26cc3165f0ac936b287a5e9381a51aad" translate="yes" xml:space="preserve">
          <source>CAST operator</source>
          <target state="translated">CAST操作员</target>
        </trans-unit>
        <trans-unit id="57c58f87e406bfa72b5233a68e16e6ce57b58a9a" translate="yes" xml:space="preserve">
          <source>CHANGESET_CONFLICT is passed as the second argument to the conflict handler while processing an INSERT change if the operation would result in duplicate primary key values.</source>
          <target state="translated">CHANGESET_CONFLICT作为冲突处理程序的第二个参数被传递给处理INSERT更改的过程中,如果该操作会导致主键值的重复。</target>
        </trans-unit>
        <trans-unit id="49279edf04879138e2ca01fe4da87f165bb8a556" translate="yes" xml:space="preserve">
          <source>CHAR</source>
          <target state="translated">CHAR</target>
        </trans-unit>
        <trans-unit id="ec67cd542d6d42f84f8aea6727411112c2a9eee5" translate="yes" xml:space="preserve">
          <source>CHARACTER(20)</source>
          <target state="translated">CHARACTER(20)</target>
        </trans-unit>
        <trans-unit id="d37267cb2995cccac2283009e1ea4f3a6dd37db3" translate="yes" xml:space="preserve">
          <source>CHECK</source>
          <target state="translated">CHECK</target>
        </trans-unit>
        <trans-unit id="7c8e71cdac81d935a110e970f2e16db27f75d5ec" translate="yes" xml:space="preserve">
          <source>CHECK constraint</source>
          <target state="translated">CHECK constraint</target>
        </trans-unit>
        <trans-unit id="91f48f96fc5990f4b552ae5c63dd0114792c0da9" translate="yes" xml:space="preserve">
          <source>CHECK constraints</source>
          <target state="translated">CHECK constraints</target>
        </trans-unit>
        <trans-unit id="6c581d4e90f448ac099620dc82b1bf15e3863e36" translate="yes" xml:space="preserve">
          <source>CHECK constraints use conflict resolution algorithms correctly.</source>
          <target state="translated">CHECK约束条件正确使用冲突解决算法。</target>
        </trans-unit>
        <trans-unit id="700b401ca52b1bd3071dc838bf11be9cdb19fc5f" translate="yes" xml:space="preserve">
          <source>CLI</source>
          <target state="translated">CLI</target>
        </trans-unit>
        <trans-unit id="eb02003c667c1e9ee2fcede2fd0524e495d8ec1b" translate="yes" xml:space="preserve">
          <source>CLOB</source>
          <target state="translated">CLOB</target>
        </trans-unit>
        <trans-unit id="28248452f38e0300dc7c45ab12fbe5d41f97e047" translate="yes" xml:space="preserve">
          <source>COLLATE</source>
          <target state="translated">COLLATE</target>
        </trans-unit>
        <trans-unit id="093c8ab0d477c98bad008d7426a58810ce1d5c6c" translate="yes" xml:space="preserve">
          <source>COLLATE binary</source>
          <target state="translated">COLLATE二进制</target>
        </trans-unit>
        <trans-unit id="114fac2d95aa36c73c87444e3e119061a6c497e8" translate="yes" xml:space="preserve">
          <source>COLLATE operator</source>
          <target state="translated">COLLATE操作员</target>
        </trans-unit>
        <trans-unit id="d517243e2eae9452e340645d614bbcb6cbc92a5f" translate="yes" xml:space="preserve">
          <source>COLLATE uint</source>
          <target state="translated">COLLATE uint</target>
        </trans-unit>
        <trans-unit id="d59db8880904cdfee22d4bdd9e5cb72c42fae180" translate="yes" xml:space="preserve">
          <source>COLUMN</source>
          <target state="translated">COLUMN</target>
        </trans-unit>
        <trans-unit id="17e4d773881595e83eed7274990576cb3c33d081" translate="yes" xml:space="preserve">
          <source>COMMIT</source>
          <target state="translated">COMMIT</target>
        </trans-unit>
        <trans-unit id="b8bace9ba33552e80165d3ede409bac3b53e9442" translate="yes" xml:space="preserve">
          <source>COMMIT TRANSACTION</source>
          <target state="translated">委托交易</target>
        </trans-unit>
        <trans-unit id="5be9cfb9ef50ef7a3f4855f3a3912ced47c9cd37" translate="yes" xml:space="preserve">
          <source>COMMIT;</source>
          <target state="translated">COMMIT;</target>
        </trans-unit>
        <trans-unit id="716a4859cb65ba79cf0a75301f937ee8dd84b958" translate="yes" xml:space="preserve">
          <source>CONFLICT</source>
          <target state="translated">CONFLICT</target>
        </trans-unit>
        <trans-unit id="eb44b374436f71b41c8c59982685ea220ef821e2" translate="yes" xml:space="preserve">
          <source>CONSTRAINT</source>
          <target state="translated">CONSTRAINT</target>
        </trans-unit>
        <trans-unit id="cabc2219177d43a5c1d71e3003445f83b9a7195f" translate="yes" xml:space="preserve">
          <source>CREATE</source>
          <target state="translated">CREATE</target>
        </trans-unit>
        <trans-unit id="4dfe073e739c382b273bdf0f1bdd27e7f10f38af" translate="yes" xml:space="preserve">
          <source>CREATE INDEX</source>
          <target state="translated">CREATE INDEX</target>
        </trans-unit>
        <trans-unit id="d5c16f75a09033a1e8f65102b202f3992bcbc039" translate="yes" xml:space="preserve">
          <source>CREATE INDEX i2a ON t2(a);</source>
          <target state="translated">CREATE INDEX i2a ON t2(a);</target>
        </trans-unit>
        <trans-unit id="219d80e293971a20fc410c1cb42fe81ee5be3296" translate="yes" xml:space="preserve">
          <source>CREATE INDEX i2b ON t2(b);</source>
          <target state="translated">CREATE INDEX i2b ON t2(b);</target>
        </trans-unit>
        <trans-unit id="015ef83633db6629be0b04929a85c6e8362366cf" translate="yes" xml:space="preserve">
          <source>CREATE INDEX i3 ON t3(c);</source>
          <target state="translated">CREATE INDEX i3 ON t3(c);</target>
        </trans-unit>
        <trans-unit id="979ae29e43d609d39c91f43b7d2c9c6f0170c84c" translate="yes" xml:space="preserve">
          <source>CREATE TABLE</source>
          <target state="translated">CREATE TABLE</target>
        </trans-unit>
        <trans-unit id="61fe1c0db27d323fd657d34129f0370eddfd6b9e" translate="yes" xml:space="preserve">
          <source>CREATE TABLE ... AS SELECT Statements</source>
          <target state="translated">CREATE TABLE ...AS SELECT 语句</target>
        </trans-unit>
        <trans-unit id="fdc5603516a1557309c21e74d5f3a300d7053f48" translate="yes" xml:space="preserve">
          <source>CREATE TABLE AS</source>
          <target state="translated">CREATE TABLE AS</target>
        </trans-unit>
        <trans-unit id="5c1879760c0ac0151021a298b71fc43dd31ae043" translate="yes" xml:space="preserve">
          <source>CREATE TABLE Statement</source>
          <target state="translated">CREATE TABLE Statement</target>
        </trans-unit>
        <trans-unit id="ef4e542d71b6fc791055be2754c8bba0c238f3b8" translate="yes" xml:space="preserve">
          <source>CREATE TABLE and DROP TABLE now work correctly as prepared statements.</source>
          <target state="translated">CREATE TABLE和DROP TABLE现在可以作为准备好的语句正确使用。</target>
        </trans-unit>
        <trans-unit id="6a035b079a1ff283fd14f7d5c5ea363c26b68cda" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(a INTEGER, b INTEGER, c VARCHAR(100));</source>
          <target state="translated">CREATE TABLE t1(a INTEGER,b INTEGER,c VARCHAR(100))。</target>
        </trans-unit>
        <trans-unit id="4619a9be564e2fbde661edf547e025b44154bc1f" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(a, b PRIMARY KEY);</source>
          <target state="translated">CREATE TABLE t1(a,b PRIMARY KEY);</target>
        </trans-unit>
        <trans-unit id="7b5a4e879f5838c381c1aaf9522123d8eb51ef28" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(a, b UNIQUE);</source>
          <target state="translated">CREATE TABLE t1(a,b UNIQUE);</target>
        </trans-unit>
        <trans-unit id="472c250359f0aac3ac59d709bce28e56fc427ab7" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(a, b);</source>
          <target state="translated">CREATE TABLE t1(a,b);</target>
        </trans-unit>
        <trans-unit id="b180c72a56f1e353661ad8a8bf096de1e31921fa" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(c1 VARIANT);</source>
          <target state="translated">CREATE TABLE t1(c1 VARIANT)。</target>
        </trans-unit>
        <trans-unit id="6c723a031c86a4c7b06f2a3f8d60439c8dcf6107" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t2(a INTEGER, b INTEGER, c VARCHAR(100));</source>
          <target state="translated">CREATE TABLE t2(a INTEGER,b INTEGER,c VARCHAR(100))。</target>
        </trans-unit>
        <trans-unit id="ffb49dd96e70cfeec18ece99b548162395148801" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t3(a INTEGER, b INTEGER, c VARCHAR(100));</source>
          <target state="translated">CREATE TABLE t3(a INTEGER,b INTEGER,c VARCHAR(100))。</target>
        </trans-unit>
        <trans-unit id="cf6418466d171e86053f358e78bdbbeb775f1f4f" translate="yes" xml:space="preserve">
          <source>CREATE TRIGGER</source>
          <target state="translated">创建触发器</target>
        </trans-unit>
        <trans-unit id="4862717c14fde4c95f9fc018bad5f1bcdf240d46" translate="yes" xml:space="preserve">
          <source>CREATE UNIQUE INDEX t1b ON t1(b);</source>
          <target state="translated">CREATE UNIQUE INDEX t1b ON t1(b);</target>
        </trans-unit>
        <trans-unit id="c6d65be0664c12895eed3811d312f2344a61a809" translate="yes" xml:space="preserve">
          <source>CREATE VIEW</source>
          <target state="translated">创建视图</target>
        </trans-unit>
        <trans-unit id="d37bcac589dd2e6a2d9d1fe15b402952fac86edd" translate="yes" xml:space="preserve">
          <source>CREATE VIRTUAL TABLE</source>
          <target state="translated">CREATE VIRTUAL TABLE</target>
        </trans-unit>
        <trans-unit id="3fed731b971838462d00ae70d200fd38b7750b9e" translate="yes" xml:space="preserve">
          <source>CREATE and DROP</source>
          <target state="translated">CREATE和DROP</target>
        </trans-unit>
        <trans-unit id="7ea4fbcff919d74664df2b3abbe9c64927134ca1" translate="yes" xml:space="preserve">
          <source>CROSS</source>
          <target state="translated">CROSS</target>
        </trans-unit>
        <trans-unit id="23cb1ba2135af54bb7f9dc4ac628c8c16b1274c8" translate="yes" xml:space="preserve">
          <source>CSV export</source>
          <target state="translated">CSV导出</target>
        </trans-unit>
        <trans-unit id="41b55f7f4ea3b51535ca8d9719be622b0aa72549" translate="yes" xml:space="preserve">
          <source>CSV import</source>
          <target state="translated">CSV导入</target>
        </trans-unit>
        <trans-unit id="17e29dae877981f4c14c3c548258e66edf22daf5" translate="yes" xml:space="preserve">
          <source>CSV output from the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; now always uses CRNL for the row separator and avoids inserting CR in front of NLs contained in data.</source>
          <target state="translated">现在，&lt;a href=&quot;cli&quot;&gt;命令行外壳程序的&lt;/a&gt; CSV输出始终将CRNL用作行分隔符，并避免在数据中包含的NL前面插入CR。</target>
        </trans-unit>
        <trans-unit id="e6303ccf1ceff324ad3a408b48244faf8b681b0a" translate="yes" xml:space="preserve">
          <source>CURRENT</source>
          <target state="translated">CURRENT</target>
        </trans-unit>
        <trans-unit id="988c655ab1a28987e3b7f4aa07b43ec2f252df71" translate="yes" xml:space="preserve">
          <source>CURRENT_DATE</source>
          <target state="translated">CURRENT_DATE</target>
        </trans-unit>
        <trans-unit id="2c91dc4d76138fb01afa917b2a5880a2ce68218e" translate="yes" xml:space="preserve">
          <source>CURRENT_TIME</source>
          <target state="translated">CURRENT_TIME</target>
        </trans-unit>
        <trans-unit id="b12c7ec3f538b492b9b7b22b81788480777716ca" translate="yes" xml:space="preserve">
          <source>CURRENT_TIME, CURRENT_DATE, and CURRENT_TIMESTAMP added</source>
          <target state="translated">增加了 CURRENT_TIME、CURRENT_DATE 和 CURRENT_TIMESTAMP。</target>
        </trans-unit>
        <trans-unit id="a5fb7adeaa54144ee5b07100bdd633a9a88f29b3" translate="yes" xml:space="preserve">
          <source>CURRENT_TIMESTAMP</source>
          <target state="translated">CURRENT_TIMESTAMP</target>
        </trans-unit>
        <trans-unit id="65e385d9a3fe24f8571de75d22a480cc4676d324" translate="yes" xml:space="preserve">
          <source>CVE Number</source>
          <target state="translated">CVE编号</target>
        </trans-unit>
        <trans-unit id="356e8d51d92a4a7c252e86ea6fe14e667fc3ae1e" translate="yes" xml:space="preserve">
          <source>CVE-2019-19317</source>
          <target state="translated">CVE-2019-19317</target>
        </trans-unit>
        <trans-unit id="99f9264fe966c3479910c5d0ba83460e6e3729ad" translate="yes" xml:space="preserve">
          <source>CVE-2019-19923</source>
          <target state="translated">CVE-2019-19923</target>
        </trans-unit>
        <trans-unit id="eebebbb796152888eb988cbad61ced631a21ff64" translate="yes" xml:space="preserve">
          <source>CVE-2019-19924</source>
          <target state="translated">CVE-2019-19924</target>
        </trans-unit>
        <trans-unit id="9070593189adb897b13efec120fbe18b3b48119d" translate="yes" xml:space="preserve">
          <source>CVE-2019-19925</source>
          <target state="translated">CVE-2019-19925</target>
        </trans-unit>
        <trans-unit id="b944efa961d3a4a65106baa20c05ed67ed3d8528" translate="yes" xml:space="preserve">
          <source>CVE-2019-19926</source>
          <target state="translated">CVE-2019-19926</target>
        </trans-unit>
        <trans-unit id="23620708a776d0f4b23595664d860f1eb18db80f" translate="yes" xml:space="preserve">
          <source>CVE-2019-19959</source>
          <target state="translated">CVE-2019-19959</target>
        </trans-unit>
        <trans-unit id="9c19ca22b3ff09cd11be29de3092bac5ecbb6f72" translate="yes" xml:space="preserve">
          <source>CVE-2019-20218</source>
          <target state="translated">CVE-2019-20218</target>
        </trans-unit>
        <trans-unit id="f84119bb7976cd5a8c8919e495a1ea188c8d01ce" translate="yes" xml:space="preserve">
          <source>CVE-2020-11655</source>
          <target state="translated">CVE-2020-11655</target>
        </trans-unit>
        <trans-unit id="24bf60a79a1bdc939cd96a195c263490e183d008" translate="yes" xml:space="preserve">
          <source>CVE-2020-11656</source>
          <target state="translated">CVE-2020-11656</target>
        </trans-unit>
        <trans-unit id="b3458c87a366a597752314c96918a11badac6df6" translate="yes" xml:space="preserve">
          <source>CVE-2020-13434</source>
          <target state="translated">CVE-2020-13434</target>
        </trans-unit>
        <trans-unit id="0c64280d7ac694f06901161e2e4192059c94030d" translate="yes" xml:space="preserve">
          <source>CVE-2020-13435</source>
          <target state="translated">CVE-2020-13435</target>
        </trans-unit>
        <trans-unit id="d2142032cb8f67d47c0f692a8f43b0da8ba3dbb4" translate="yes" xml:space="preserve">
          <source>CVE-2020-13630</source>
          <target state="translated">CVE-2020-13630</target>
        </trans-unit>
        <trans-unit id="01b180dcf9513183380ef259d2b0841c4e7f77b3" translate="yes" xml:space="preserve">
          <source>CVE-2020-13631</source>
          <target state="translated">CVE-2020-13631</target>
        </trans-unit>
        <trans-unit id="2f01c703b75f4b1f7d0a5171ce82a9de250b7508" translate="yes" xml:space="preserve">
          <source>CVE-2020-13632</source>
          <target state="translated">CVE-2020-13632</target>
        </trans-unit>
        <trans-unit id="5d08b8e084f6c27e8e4b3ed9ca47f1f1232dd879" translate="yes" xml:space="preserve">
          <source>CVE-2020-13871</source>
          <target state="translated">CVE-2020-13871</target>
        </trans-unit>
        <trans-unit id="d794882b16e5e67f67cae72af337733774cdf3d1" translate="yes" xml:space="preserve">
          <source>CVE-2020-15358</source>
          <target state="translated">CVE-2020-15358</target>
        </trans-unit>
        <trans-unit id="e199336a03380b560a1ec76506edbffac71e2c63" translate="yes" xml:space="preserve">
          <source>CVE-2020-6405</source>
          <target state="translated">CVE-2020-6405</target>
        </trans-unit>
        <trans-unit id="e0e462c2ba637997a01ca062b46b08478eaea02c" translate="yes" xml:space="preserve">
          <source>CVE-2020-9327</source>
          <target state="translated">CVE-2020-9327</target>
        </trans-unit>
        <trans-unit id="58cc14935f8aae029bbfb78904497935571ef45e" translate="yes" xml:space="preserve">
          <source>CVEs (&quot;Common Vulnerabilities and Exposures&quot;) are reports of software bugs that might allow a system to be hacked. The idea behind CVEs is sound. They provide a common naming scheme whereby software bugs that might compromise information security can be easily tracked.</source>
          <target state="translated">CVEs(&quot;常见漏洞和暴露&quot;)是关于软件漏洞的报告,这些漏洞可能使系统被黑客攻击。CVEs背后的理念是正确的。它们提供了一个共同的命名方案,使人们可以很容易地追踪到可能危及信息安全的软件漏洞。</target>
        </trans-unit>
        <trans-unit id="51c92beb8c02d63e98c12b62c29e821871eee1bb" translate="yes" xml:space="preserve">
          <source>CVEs about SQLite probably do not apply to your use of SQLite.</source>
          <target state="translated">关于SQLite的CVE可能不适用于你对SQLite的使用。</target>
        </trans-unit>
        <trans-unit id="2e3affda4e192cdf66e451e6d423b53be2042240" translate="yes" xml:space="preserve">
          <source>CVEs are a low-quality source of information about bugs in SQLite that are likely to affect most applications.</source>
          <target state="translated">CVEs是关于SQLite中可能影响大多数应用程序的错误的低质量信息来源。</target>
        </trans-unit>
        <trans-unit id="97154728871232f8ec1e18c7f99aae1f66258be4" translate="yes" xml:space="preserve">
          <source>Cache Validation</source>
          <target state="translated">缓存验证</target>
        </trans-unit>
        <trans-unit id="243348169a35fc01acf2950edac2a8317e1d5705" translate="yes" xml:space="preserve">
          <source>Cache sharing is enabled and disabled for an entire process. This is a change as of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04). In prior versions of SQLite, sharing was enabled or disabled for each thread separately.</source>
          <target state="translated">在整个过程中启用和禁用缓存共享。这是SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;3.5.0&lt;/a&gt;（2007-09-04）版本的更改。在早期版本的SQLite中，分别为每个线程启用或禁用共享。</target>
        </trans-unit>
        <trans-unit id="dfad78f93ed55c3b8305d2de17eb36b19e276c8b" translate="yes" xml:space="preserve">
          <source>Call sqlite3_reset() on the statement handle. Since an SQLITE_LOCKED error may only occur on the first call to sqlite3_step() (it is not possible for one call to sqlite3_step() to return SQLITE_ROW and then the next SQLITE_LOCKED), the statement handle may be reset at this point without affecting the results of the query from the point of view of the caller. If sqlite3_reset() were not called at this point, the next call to sqlite3_step() would return SQLITE_MISUSE.</source>
          <target state="translated">在语句句柄上调用sqlite3_reset()。由于只有在第一次调用sqlite3_step()时才可能发生SQLITE_LOCKED错误(不可能一次调用sqlite3_step()返回SQLITE_ROW,然后下一次调用SQLITE_LOCKED),所以此时可以重置语句句柄,而不影响从调用者角度看查询的结果。如果此时没有调用sqlite3_reset(),那么下一次调用sqlite3_step()将返回SQLITE_MISUSE。</target>
        </trans-unit>
        <trans-unit id="e7253d4d62ac064583560f235c4dc54e68e830f1" translate="yes" xml:space="preserve">
          <source>Call sqlite3_step() on the supplied statement handle. If the call returns anything other than SQLITE_LOCKED, then return this value to the caller. Otherwise, continue.</source>
          <target state="translated">在提供的语句句柄上调用 sqlite3_step()。如果调用返回的不是SQLITE_LOCKED,那么就把这个值返回给调用者。否则,继续。</target>
        </trans-unit>
        <trans-unit id="ac89c336f7b9f31230fa306e89f0a63e33ec5741" translate="yes" xml:space="preserve">
          <source>Call sqlite3rbu_close(X) to destroy the sqlite3rbu object pointer. If sqlite3rbu_step(X) has been called enough times to completely apply the update to the target database, then the RBU database is marked as fully applied. Otherwise, the state of the RBU update application is saved in the state database (or in the RBU database if the name of the state database file in sqlite3rbu_open() is NULL) for later resumption of the update.</source>
          <target state="translated">调用 sqlite3rbu_close(X)来销毁 sqlite3rbu 对象指针。如果sqlite3rbu_step(X)已经被调用了足够多的次数,将更新完全应用到目标数据库中,那么RBU数据库被标记为完全应用。否则,RBU更新应用的状态将保存在状态数据库中(如果sqlite3rbu_open()中的状态数据库文件名为NULL,则保存在RBU数据库中),以便以后恢复更新。</target>
        </trans-unit>
        <trans-unit id="d6ff8f2da317158463526f6a07fed19920a5822f" translate="yes" xml:space="preserve">
          <source>Call the table named by the &lt;a href=&quot;syntax/cte-table-name&quot;&gt;cte-table-name&lt;/a&gt; in a recursive common table expression the &quot;recursive table&quot;. In the &lt;a href=&quot;syntax/recursive-cte&quot;&gt;recursive-cte&lt;/a&gt; bubble diagram above, the recursive table must appear exactly once in the FROM clause of each top-level SELECT statement in the recursive-select and must not appear anywhere else in either the initial-select or the recursive-select, including subqueries. The initial-select may be a &lt;a href=&quot;lang_select#compound&quot;&gt;compound select&lt;/a&gt;, but it may not include an ORDER BY, LIMIT, or OFFSET. The recursive-select may also be a &lt;a href=&quot;lang_select#compound&quot;&gt;compound select&lt;/a&gt; with the restriction that all elements of that compound must be separated by the same UNION or UNION ALL operator that separates initial-select from recursive-select. The recursive-select is allowed to include an ORDER BY, LIMIT, and/or OFFSET but may not use &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate functions&lt;/a&gt; or &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;.</source>
          <target state="translated">在递归公用表表达式中将由&lt;a href=&quot;syntax/cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;命名的表称为&amp;ldquo;递归表&amp;rdquo;。在上面的&lt;a href=&quot;syntax/recursive-cte&quot;&gt;递归cte&lt;/a&gt;气泡图中，递归表必须在递归选择中的每个顶级SELECT语句的FROM子句中恰好出现一次，并且不得在初始选择或递归选择中的其他任何地方出现，包括子查询。初始选择可以是&lt;a href=&quot;lang_select#compound&quot;&gt;复合选择&lt;/a&gt;，但可能不包括ORDER BY，LIMIT或OFFSET。递归选择也可以是&lt;a href=&quot;lang_select#compound&quot;&gt;复合选择&lt;/a&gt;限制条件是该化合物的所有元素必须由将初始选择与递归选择分开的同一个UNION或UNION ALL运算符分隔。递归选择允许包含ORDER BY，LIMIT和/或OFFSET，但不得使用&lt;a href=&quot;lang_aggfunc&quot;&gt;聚合函数&lt;/a&gt;或&lt;a href=&quot;windowfunctions&quot;&gt;窗口函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4cfaf571c0396d88e7a8a5942129605eebc5000" translate="yes" xml:space="preserve">
          <source>Call the table named by the &lt;a href=&quot;syntax/cte-table-name&quot;&gt;cte-table-name&lt;/a&gt; in a recursive common table expression the &quot;recursive table&quot;. In the &lt;a href=&quot;syntax/recursive-cte&quot;&gt;recursive-cte&lt;/a&gt; bubble diagram above, the recursive table must appear exactly once in the FROM clause of the recursive-select and must not appear anywhere else in either the initial-select or the recursive-select, including subqueries. The initial-select may be a &lt;a href=&quot;lang_select#compound&quot;&gt;compound select&lt;/a&gt;, but it may not include an ORDER BY, LIMIT, or OFFSET. The recursive-select must be a simple select, not a compound. The recursive-select is allowed to include an ORDER BY, LIMIT, and/or OFFSET.</source>
          <target state="translated">在递归公用表表达式中将由&lt;a href=&quot;syntax/cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;命名的表称为&amp;ldquo;递归表&amp;rdquo;。在上面的&lt;a href=&quot;syntax/recursive-cte&quot;&gt;递归cte&lt;/a&gt;气泡图中，递归表必须在递归选择的FROM子句中恰好出现一次，并且不得在初始选择或递归选择（包括子查询）中的任何其他位置出现。初始选择可以是&lt;a href=&quot;lang_select#compound&quot;&gt;复合选择&lt;/a&gt;，但可能不包括ORDER BY，LIMIT或OFFSET。递归选择必须是简单选择，而不是复合选择。递归选择允许包括ORDER BY，LIMIT和/或OFFSET。</target>
        </trans-unit>
        <trans-unit id="42fb639b7313463881ed7d9bae34cc709237f03b" translate="yes" xml:space="preserve">
          <source>Callback</source>
          <target state="translated">Callback</target>
        </trans-unit>
        <trans-unit id="fc3110a84b56463b6ac2be236d2d0ee212bb9db8" translate="yes" xml:space="preserve">
          <source>Calling sqlite3_auto_extension(X) with an entry point X that is already on the list of automatic extensions is a harmless no-op. No entry point will be called more than once for each database connection that is opened.</source>
          <target state="translated">用已经在自动扩展列表中的入口点X调用sqlite3_auto_extension(X)是无伤大雅的不操作。每打开一个数据库连接,都不会超过一次调用入口点。</target>
        </trans-unit>
        <trans-unit id="fdd02e84dcaceaea19448095c3e09a162e5292ae" translate="yes" xml:space="preserve">
          <source>Calling sqlite3_free() with a pointer previously returned by sqlite3_malloc() or sqlite3_realloc() releases that memory so that it might be reused. The sqlite3_free() routine is a no-op if is called with a NULL pointer. Passing a NULL pointer to sqlite3_free() is harmless. After being freed, memory should neither be read nor written. Even reading previously freed memory might result in a segmentation fault or other severe error. Memory corruption, a segmentation fault, or other severe error might result if sqlite3_free() is called with a non-NULL pointer that was not obtained from sqlite3_malloc() or sqlite3_realloc().</source>
          <target state="translated">用一个之前被sqlite3_malloc()或sqlite3_realloc()返回的指针调用sqlite3_free(),释放该内存,使其可以被重新使用。如果用一个NULL指针调用sqlite3_free()例程,那么sqlite3_free()例程就是一个no-op。将一个NULL指针传递给sqlite3_free()是无害的。内存被释放后,既不能读也不能写。即使读取之前释放的内存,也可能导致分段故障或其他严重错误。如果调用sqlite3_free()时使用一个非NULL指针,而这个指针不是从sqlite3_malloc()或sqlite3_realloc()获得的,那么可能会导致内存损坏、分段故障或其他严重的错误。</target>
        </trans-unit>
        <trans-unit id="3358427e1a8ed1bea8f5a2ad2f5555efabc90a34" translate="yes" xml:space="preserve">
          <source>Calling this function with an argument that is not a NULL pointer or an open blob handle results in undefined behaviour. Calling this routine with a null pointer (such as would be returned by a failed call to &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt;) is a harmless no-op. Otherwise, if this function is passed a valid open blob handle, the values returned by the sqlite3_errcode() and sqlite3_errmsg() functions are set before returning.</source>
          <target state="translated">用非NULL指针或开放的Blob句柄作为参数调用此函数将导致未定义的行为。用空指针调用该例程（例如，对&lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open（）&lt;/a&gt;的失败调用将返回该例程）是无害的操作。否则，如果传递了有效的打开Blob句柄，则将在返回之前设置sqlite3_errcode（）和sqlite3_errmsg（）函数返回的值。</target>
        </trans-unit>
        <trans-unit id="508bbd8f844cc227cec9347e436cbdd9ffc04285" translate="yes" xml:space="preserve">
          <source>Calling this function with an argument that is not a NULL pointer or an open blob handle results in undefined behaviour. Calling this routine with a null pointer (such as would be returned by a failed call to &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt;) is a harmless no-op. Otherwise, if this function is passed a valid open blob handle, the values returned by the sqlite3_errcode() and sqlite3_errmsg() functions are set before returning.</source>
          <target state="translated">用非NULL指针或开放的Blob句柄作为参数调用此函数将导致未定义的行为。用空指针调用该例程（例如，对&lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open（）&lt;/a&gt;的失败调用将返回该例程）是无害的操作。否则，如果传递了有效的打开Blob句柄，则将在返回之前设置sqlite3_errcode（）和sqlite3_errmsg（）函数返回的值。</target>
        </trans-unit>
        <trans-unit id="64d7627e8fc4bb3206a4244a29e5baede1745ef4" translate="yes" xml:space="preserve">
          <source>Calling this routine with an argument less than or equal to zero turns off all busy handlers.</source>
          <target state="translated">调用这个例程时,参数小于或等于零,会关闭所有的忙处理程序。</target>
        </trans-unit>
        <trans-unit id="f8f92cf7b8aea43c60bffe0c687691a21c0c3628" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_CONSTRAINT_SUPPORT,X) are supported, where X is an integer. If X is zero, then the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; whose &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; or &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method invoked &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; does not support constraints. In this configuration (which is the default) if a call to the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, then the entire statement is rolled back as if &lt;a href=&quot;lang_conflict&quot;&gt;OR ABORT&lt;/a&gt; had been specified as part of the users SQL statement, regardless of the actual ON CONFLICT mode specified.</source>
          <target state="translated">支持以&lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;（db，SQLITE_VTAB_CONSTRAINT_SUPPORT，X）形式进行的调用，其中X是整数。如果X为零，则其&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;或&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;方法调用&lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config（）&lt;/a&gt;的&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;不支持约束。在此配置（默认设置）中，如果对&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法的调用返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;，则将回滚整个语句，就像已将&lt;a href=&quot;lang_conflict&quot;&gt;OR ABORT&lt;/a&gt;指定为用户SQL语句的一部分一样，无论指定了实际的ON CONFLICT模式如何。</target>
        </trans-unit>
        <trans-unit id="34ad152047e6215f524688d715005c8597525fd4" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_DIRECTONLY) from within the the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; methods of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implmentation prohibits that virtual table from being used from within triggers and views.</source>
          <target state="translated">在&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;实现的&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;或&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;方法中，以&lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;（db，SQLITE_VTAB_DIRECTONLY）形式进行的调用禁止在触发器和视图中使用该虚拟表。</target>
        </trans-unit>
        <trans-unit id="8b0bba808ff71be3f5e68d5dc5e9c1b43f075395" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_INNOCUOUS) from within the the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; methods of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implmentation identify that virtual table as being safe to use from within triggers and views. Conceptually, the SQLITE_VTAB_INNOCUOUS tag means that the virtual table can do no serious harm even if it is controlled by a malicious hacker. Developers should avoid setting the SQLITE_VTAB_INNOCUOUS flag unless absolutely necessary.</source>
          <target state="translated">从&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;实现的&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;或&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;方法内部调用形式为&lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;（db，SQLITE_VTAB_INNOCUOUS）的形式，可以将该虚拟表安全地用于触发器和视图中。从概念上讲，SQLITE_VTAB_INNOCUOUS标记意味着即使虚拟表受到恶意黑客的控制，也不会造成严重危害。除非绝对必要，否则开发人员应避免设置SQLITE_VTAB_INNOCUOUS标志。</target>
        </trans-unit>
        <trans-unit id="9cd59c58ce5ea212cbfa095730fc7d7c0c018f0a" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_CONSTRAINT_SUPPORT,X) are supported, where X is an integer. If X is zero, then the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; whose &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; or &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method invoked &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; does not support constraints. In this configuration (which is the default) if a call to the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method returns &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, then the entire statement is rolled back as if &lt;a href=&quot;../lang_conflict&quot;&gt;OR ABORT&lt;/a&gt; had been specified as part of the users SQL statement, regardless of the actual ON CONFLICT mode specified.</source>
          <target state="translated">支持以&lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;（db，SQLITE_VTAB_CONSTRAINT_SUPPORT，X）形式进行的调用，其中X是整数。如果X为零，则其&lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;或&lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;方法调用&lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config（）&lt;/a&gt;的&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;不支持约束。在此配置（默认设置）中，如果对&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法的调用返回&lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;，则将回滚整个语句，就像已将&lt;a href=&quot;../lang_conflict&quot;&gt;OR ABORT&lt;/a&gt;指定为用户SQL语句的一部分一样，无论指定了实际的ON CONFLICT模式如何。</target>
        </trans-unit>
        <trans-unit id="0d15b922d29010ebd3f4c6c25124e15853e06a0d" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_DIRECTONLY) from within the the &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; methods of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implmentation prohibits that virtual table from being used from within triggers and views.</source>
          <target state="translated">在&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;实现的&lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;或&lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;方法中，以&lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;（db，SQLITE_VTAB_DIRECTONLY）形式进行的调用禁止在触发器和视图中使用该虚拟表。</target>
        </trans-unit>
        <trans-unit id="015012a4348dd0949483c59bb10d1f9a584347cd" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_INNOCUOUS) from within the the &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; methods of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implmentation identify that virtual table as being safe to use from within triggers and views. Conceptually, the SQLITE_VTAB_INNOCUOUS tag means that the virtual table can do no serious harm even if it is controlled by a malicious hacker. Developers should avoid setting the SQLITE_VTAB_INNOCUOUS flag unless absolutely necessary.</source>
          <target state="translated">从&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;实现的&lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;或&lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;方法内部调用形式为&lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;（db，SQLITE_VTAB_INNOCUOUS）的形式，可以将该虚拟表安全地用于触发器和视图中。从概念上讲，SQLITE_VTAB_INNOCUOUS标记意味着即使虚拟表受到恶意黑客的控制，也不会造成严重危害。除非绝对必要，否则开发人员应避免设置SQLITE_VTAB_INNOCUOUS标志。</target>
        </trans-unit>
        <trans-unit id="86477778aa30209993df2ed08e9c32fc5e63a6fa" translate="yes" xml:space="preserve">
          <source>Calls to sqlite3_db_config() return SQLITE_OK if and only if the call is considered successful.</source>
          <target state="translated">对sqlite3_db_config()的调用只有在调用被认为成功的情况下才返回SQLITE_OK。</target>
        </trans-unit>
        <trans-unit id="98e68b9f843bbc24802b164860be76398c7c74b1" translate="yes" xml:space="preserve">
          <source>Can I use SQLite in my commercial product without paying royalties?</source>
          <target state="translated">我可以在我的商业产品中使用SQLite而不支付专利费吗?</target>
        </trans-unit>
        <trans-unit id="a99feeb9b762e6e46c563375f506a5cca89929e5" translate="yes" xml:space="preserve">
          <source>Can multiple applications or multiple instances of the same application access a single database file at the same time?</source>
          <target state="translated">多个应用程序或同一应用程序的多个实例能否同时访问一个数据库文件?</target>
        </trans-unit>
        <trans-unit id="1d85ae4c67a45ca5f093c8517be6998fccbe1b6b" translate="yes" xml:space="preserve">
          <source>Cancel Automatic Extension Loading</source>
          <target state="translated">取消自动延期加载</target>
        </trans-unit>
        <trans-unit id="0f1e2a9d130c394f768ce03af8c9cfdba772362c" translate="yes" xml:space="preserve">
          <source>Capture Changes Using Triggers</source>
          <target state="translated">使用触发器捕捉变化</target>
        </trans-unit>
        <trans-unit id="8d319a418b8f56b5238017081c3f614d4e2d2c3a" translate="yes" xml:space="preserve">
          <source>Carray($PTR,$N) is a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; with a single column (named &quot;value&quot;) and zero or more rows. The &quot;value&quot; of each row in the carray() is taken from a C-language array that is $N elements long. $PTR is a pointer to the beginning of the array. In this way, the carray() function provides a convenient mechanism to bind C-language arrays to SQL queries.</source>
          <target state="translated">Carray（$ PTR，$ N）是一个&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;，具有单列（名为&amp;ldquo;值&amp;rdquo;）和零或更多行。carray（）中每一行的&amp;ldquo;值&amp;rdquo;取自C语言数组，该数组的长度为$ N个元素。$ PTR是指向数组开头的指针。这样，carray（）函数提供了一种方便的机制，可将C语言数组绑定到SQL查询。</target>
        </trans-unit>
        <trans-unit id="8ca8f785460175b7036192ab46ae5e23b46c1c04" translate="yes" xml:space="preserve">
          <source>Carray() is a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; with a single column (named &quot;value&quot;) and zero or more rows. The &quot;value&quot; of each row in the carray() is taken from a C-language array supplied by the application via &lt;a href=&quot;c3ref/bind_blob&quot;&gt;parameter binding&lt;/a&gt;. In this way, the carray() function provides a convenient mechanism to bind C-language arrays to SQL queries.</source>
          <target state="translated">Carray（）是一个&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;，具有单列（称为&amp;ldquo;值&amp;rdquo;）和零行或更多行。carray（）中每一行的&amp;ldquo;值&amp;rdquo;取自应用程序通过&lt;a href=&quot;c3ref/bind_blob&quot;&gt;参数绑定&lt;/a&gt;提供的C语言数组。通过这种方式，carray（）函数提供了一种方便的机制来将C语言数组绑定到SQL查询。</target>
        </trans-unit>
        <trans-unit id="8c3b32ddf313031d687668680d0df3a761eedc08" translate="yes" xml:space="preserve">
          <source>Case-folding is only performed for ASCII characters. So while &quot;A&quot; and &quot;a&quot; are considered to be equivalent, &quot;&amp;Atilde;&quot; and &quot;&amp;atilde;&quot; are distinct.</source>
          <target state="translated">大小写折叠仅针对ASCII字符执行。因此，虽然&amp;ldquo; A&amp;rdquo;和&amp;ldquo; a&amp;rdquo;被认为是等效的，但&amp;ldquo;&amp;Atilde;&amp;rdquo;和&amp;ldquo;&amp;atilde;&amp;rdquo;却是不同的。</target>
        </trans-unit>
        <trans-unit id="ddb2cf0a81747a42bb2a318554bfc6f3310b70d2" translate="yes" xml:space="preserve">
          <source>Case-insensitive matching of Unicode characters does not work.</source>
          <target state="translated">不区分大小写的Unicode字符匹配不起作用。</target>
        </trans-unit>
        <trans-unit id="4a24bc7f7fc1b1e11b0cb6ad38cd14985ad78efd" translate="yes" xml:space="preserve">
          <source>Cases in which the underlying content table has an explicit INTEGER PRIMARY KEY column are slightly more difficult, as the text values stored in the rbu_control column are slightly different for the FTS index and its underlying content table. For the underlying content table, a character must be included in any rbu_control text values for the explicit IPK, but for the FTS table itself, which has an implicit rowid, it should not. This is inconvenient, but can be solved using a more complicated view, as follows:</source>
          <target state="translated">底层内容表有一个显式的INTEGER PRIMARY KEY列的情况稍微有点困难,因为对于FTS索引和它的底层内容表来说,存储在rbu_control列中的文本值略有不同。对于底层内容表来说,在任何rbu_control文本值中都必须包含一个显式IPK的字符,但是对于FTS表本身来说,它有一个隐式的rowid,不应该包含。这一点很不方便,但可以使用更复杂的视图来解决,如下所示。</target>
        </trans-unit>
        <trans-unit id="6d2fbd5980d329d5d6af3be31953582204f59e3e" translate="yes" xml:space="preserve">
          <source>Cases where a query against a WAL-mode database can return &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; include the following:</source>
          <target state="translated">针对WAL模式数据库的查询可以返回&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY的情况&lt;/a&gt;包括：</target>
        </trans-unit>
        <trans-unit id="15a2b7aaa72451fad3138411af4836bb6aea25de" translate="yes" xml:space="preserve">
          <source>Cases where the page-sizes of database pInMemory and zFilename are different could be handled better.</source>
          <target state="translated">当数据库pInMemory和zFilename的页面大小不同时,可以更好的处理。</target>
        </trans-unit>
        <trans-unit id="60745aef336b682ec827697b3e47b80c7d7555b3" translate="yes" xml:space="preserve">
          <source>Cast</source>
          <target state="translated">Cast</target>
        </trans-unit>
        <trans-unit id="8e96ef594fff82e127e63864e75e54aa6b53b266" translate="yes" xml:space="preserve">
          <source>Casting a REAL or INTEGER value to NUMERIC is a no-op, even if a real value could be losslessly converted to an integer.</source>
          <target state="translated">将REAL或INTEGER值转为NUMERIC是不可能的,即使实值可以无损地转换为整数。</target>
        </trans-unit>
        <trans-unit id="383678fdbb040838c4ceb85e8d73bcffcce4db9f" translate="yes" xml:space="preserve">
          <source>Casting a TEXT or BLOB value into NUMERIC yields either an INTEGER or a REAL result. If the input text looks like an integer (there is no decimal point nor exponent) and the value is small enough to fit in a 64-bit signed integer, then the result will be INTEGER. Input text that looks like floating point (there is a decimal point and/or an exponent) and the text describes a value that can be losslessly converted back and forth between IEEE 754 64-bit float and a 51-bit signed integer, then the result is INTEGER. (In the previous sentence, a 51-bit integer is specified since that is one bit less than the length of the mantissa of an IEEE 754 64-bit float and thus provides a 1-bit of margin for the text-to-float conversion operation.) Any text input that describes a value outside the range of a 64-bit signed integer yields a REAL result.</source>
          <target state="translated">将 TEXT 或 BLOB 值投射到 NUMERIC 中会产生 INTEGER 或 REAL 结果。如果输入的文本看起来像一个整数(没有小数点也没有指数),并且值小到足以容纳一个 64 位有符号的整数,那么结果将是 INTEGER。输入的文本看起来像浮点数(有小数点和/或指数),并且文本描述的值可以在IEEE 754 64位浮点数和51位有符号整数之间无损地来回转换,那么结果就是INTEGER。在前一句中,指定了51位整数,因为它比IEEE 754 64位浮点数的尾数长度少一位,因此为文本到浮点数的转换操作提供了1位的余量)。任何描述64位有符号整数范围外的文本输入都会产生一个REAL结果。</target>
        </trans-unit>
        <trans-unit id="6f9cada34f4e450b6e71343e035a2f6e0689a6ef" translate="yes" xml:space="preserve">
          <source>Casting a value to a type-name with no affinity causes the value to be converted into a BLOB. Casting to a BLOB consists of first casting the value to TEXT in the &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;encoding&lt;/a&gt; of the database connection, then interpreting the resulting byte sequence as a BLOB instead of as TEXT.</source>
          <target state="translated">将值强制转换为没有亲缘关系的类型名称会导致该值转换为BLOB。转换为BLOB的过程包括：首先在数据库连接的&lt;a href=&quot;pragma#pragma_encoding&quot;&gt;编码&lt;/a&gt;中将值转换为TEXT ，然后将结果字节序列解释为BLOB而不是TEXT。</target>
        </trans-unit>
        <trans-unit id="6fddff049ee62a8963c9618826e1a03cc952e4f9" translate="yes" xml:space="preserve">
          <source>Casting an INTEGER or REAL value into TEXT renders the value as if via &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; except that the resulting TEXT uses the &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;encoding&lt;/a&gt; of the database connection.</source>
          <target state="translated">将INTEGER或REAL值强制转换为TEXT会像通过&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;一样呈现该值，除了所得的TEXT使用数据库连接的&lt;a href=&quot;pragma#pragma_encoding&quot;&gt;编码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9659870b130effaa595b44d09c6d4264711f682a" translate="yes" xml:space="preserve">
          <source>Casual readers are not expected to understand all of these rules. A key take-away from this section is that the rules for determining if query flatting is safe or unsafe are subtle and complex. There have been multiple bugs over the years caused by over-aggressive query flattening. On the other hand, performance of complex queries and/or queries involving views tends to suffer if query flattening is more conservative.</source>
          <target state="translated">不希望普通读者理解所有这些规则。从本节中得到的一个关键启示是,判断查询扁平化是安全还是不安全的规则是微妙而复杂的。多年来,已经出现了多个由过于激进的查询扁平化引起的bug。另一方面,如果查询扁平化比较保守,复杂查询和/或涉及视图的查询的性能往往会受到影响。</target>
        </trans-unit>
        <trans-unit id="250b5faac42b62665141b9500e3ff0cde556b9c8" translate="yes" xml:space="preserve">
          <source>Casual readers are not expected to understand all of these rules. A key take-away from this section is that the rules for determining when query flatting is safe and when it is unsafe are subtle and complex. There have been multiple bugs over the years caused by over-aggressive query flattening. On the other hand, performance of complex queries and/or queries involving views tends to suffer if query flattening is more conservative.</source>
          <target state="translated">我们不希望普通读者理解所有这些规则。本节的一个关键要点是,判断查询扁平化何时安全、何时不安全的规则是微妙而复杂的。多年来,已经有多个由过度激进的查询扁平化引起的bug。另一方面,如果查询扁平化比较保守,复杂查询和/或涉及视图的查询的性能往往会受到影响。</target>
        </trans-unit>
        <trans-unit id="8907a1b62f0f750985eefc9ce844fea83efeb9a9" translate="yes" xml:space="preserve">
          <source>Cause precompiled statements to expire. When an expired statement is executed using sqlite3_step() it will either automatically reprepare itself (if it was originally created using sqlite3_prepare_v2()) or it will fail with SQLITE_SCHEMA.</source>
          <target state="translated">导致预编译的语句过期。当使用 sqlite3_step()执行过期语句时,它将自动重新编译(如果它最初是使用 sqlite3_prepare_v2()创建的),或者用 SQLITE_SCHEMA 失败。</target>
        </trans-unit>
        <trans-unit id="a305305010fac4c32d5e753f973a3552e1f13215" translate="yes" xml:space="preserve">
          <source>Causes the customer.cust_addr field to be updated for a specific customer entry that has customer.cust_id equal to the $cust_id parameter. Note how the values assigned to the view are made available as field in the special &quot;NEW&quot; table within the trigger body.</source>
          <target state="translated">使customer.cust_addr字段为特定的客户条目更新,其customer.cust_id等于$cust_id参数。请注意,分配给视图的值是如何在触发器主体内的 &quot;NEW &quot;表中作为字段提供的。</target>
        </trans-unit>
        <trans-unit id="dbad4a6e3280246beefd6847d2978b258b3988cb" translate="yes" xml:space="preserve">
          <source>Cautions On The Use Of BEFORE triggers</source>
          <target state="translated">使用BEFORE触发器的注意事项</target>
        </trans-unit>
        <trans-unit id="b150cf72e99af84282f28eb7200853b8c0ee4cf4" translate="yes" xml:space="preserve">
          <source>Caveats And Bugs</source>
          <target state="translated">注意事项和错误</target>
        </trans-unit>
        <trans-unit id="ff583586588dbe1c7f2b18104da572d7a5f33f25" translate="yes" xml:space="preserve">
          <source>Celebrating the SQLite &quot;</source>
          <target state="translated">庆祝SQLite &quot;</target>
        </trans-unit>
        <trans-unit id="59bd6eed6ef43faee3a8233d127e632eb210e7f2" translate="yes" xml:space="preserve">
          <source>Cell content is stored in the cell content region of the b-tree page. SQLite strives to place cells as far toward the end of the b-tree page as it can, in order to leave space for future growth of the cell pointer array. The area in between the last cell pointer array entry and the beginning of the first cell is the unallocated region.</source>
          <target state="translated">单元格内容存储在b-tree页的单元格内容区域。SQLite力求将单元格尽可能地放在b-tree页的最后,以便为单元格指针数组的未来增长留出空间。最后一个单元格指针数组条目和第一个单元格开始之间的区域是未分配区域。</target>
        </trans-unit>
        <trans-unit id="3b0cca36895145060f4680c61a83b1cba94677a3" translate="yes" xml:space="preserve">
          <source>Cell format summary</source>
          <target state="translated">单元格式摘要</target>
        </trans-unit>
        <trans-unit id="7ba571bb64ab9af59eb4c60e06ccece4c22b6946" translate="yes" xml:space="preserve">
          <source>Cell payload</source>
          <target state="translated">电池有效载荷</target>
        </trans-unit>
        <trans-unit id="4467e902ad5ceab8af5cb553065bb45a1d9e0f01" translate="yes" xml:space="preserve">
          <source>Change &lt;a href=&quot;cli#arinsup&quot;&gt;--update option&lt;/a&gt; in the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt; so that it skips files that are already in the archive and are unchanged. Add the new --insert option that works like --update used to work.</source>
          <target state="translated">更改&lt;a href=&quot;cli#sqlar&quot;&gt;.archive命令&lt;/a&gt;中的&lt;a href=&quot;cli#arinsup&quot;&gt;--update选项&lt;/a&gt;，以使其跳过归档中已存在且未更改的文件。添加新的--insert选项，其工作方式与--update一样。</target>
        </trans-unit>
        <trans-unit id="f2cdcfee54f6e63221834526df456ae33f4748c1" translate="yes" xml:space="preserve">
          <source>Change &lt;a href=&quot;compile#default_pcache_initsz&quot;&gt;SQLITE_DEFAULT_PCACHE_INITSZ&lt;/a&gt; from 100 to 20, for improved performance.</source>
          <target state="translated">将&lt;a href=&quot;compile#default_pcache_initsz&quot;&gt;SQLITE_DEFAULT_PCACHE_INITSZ&lt;/a&gt;从100 更改为20，以提高性能。</target>
        </trans-unit>
        <trans-unit id="89533c2ad87297c6b1814e96c92819fffab5d853" translate="yes" xml:space="preserve">
          <source>Change both unix and windows &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; to report a sector size of 4096 instead of the old default of 512.</source>
          <target state="translated">更改unix和Windows &lt;a href=&quot;vfs&quot;&gt;VFS，&lt;/a&gt;以报告扇区大小为4096，而不是原来的默认值512。</target>
        </trans-unit>
        <trans-unit id="a9b62dcab530abf089ef055d542c538c769edd17" translate="yes" xml:space="preserve">
          <source>Change counter</source>
          <target state="translated">更改计数器</target>
        </trans-unit>
        <trans-unit id="78284963454462cded2891e165a76967ce7ebecf" translate="yes" xml:space="preserve">
          <source>Change in Default Page Size in SQLite Version 3.12.0</source>
          <target state="translated">SQLite 3.12.0版本中默认页面大小的改变</target>
        </trans-unit>
        <trans-unit id="8ef7213e575119b9063a9829bf0081766983433e" translate="yes" xml:space="preserve">
          <source>Change log</source>
          <target state="translated">更改日志</target>
        </trans-unit>
        <trans-unit id="a9b88ee2ce690ee5c74f615e035bfd14907be3b4" translate="yes" xml:space="preserve">
          <source>Change tclsqlite.c to use the Tcl_Obj interface</source>
          <target state="translated">修改tclsqlite.c,使用Tcl_Obj接口。</target>
        </trans-unit>
        <trans-unit id="c9502e13b89a0e998e0002cc9dd2ac28edd6e8ea" translate="yes" xml:space="preserve">
          <source>Change the &lt;a href=&quot;lemon&quot;&gt;Lemon&lt;/a&gt; source code to avoid calling C-library functions that OpenBSD considers dangerous. (Ex: sprintf).</source>
          <target state="translated">更改&lt;a href=&quot;lemon&quot;&gt;Lemon&lt;/a&gt;源代码，以避免调用OpenBSD认为危险的C库函数。（例如：sprintf）。</target>
        </trans-unit>
        <trans-unit id="5d77baa02e54aeb22b238c0441152b1e5304decd" translate="yes" xml:space="preserve">
          <source>Change the &lt;a href=&quot;tempfiles#tempdir&quot;&gt;temporary directory search algorithm&lt;/a&gt; on Unix to allow directories with write and execute permission, but without read permission, to serve as temporary directories. Apply this same standard to the &quot;.&quot; fallback directory.</source>
          <target state="translated">在Unix上更改&lt;a href=&quot;tempfiles#tempdir&quot;&gt;临时目录搜索算法&lt;/a&gt;，以允许具有写和执行权限但没有读权限的目录用作临时目录。将相同的标准应用于&amp;ldquo;。&amp;rdquo; 后备目录。</target>
        </trans-unit>
        <trans-unit id="ddfd791371cc9a6cd54b126954447b1ad9112604" translate="yes" xml:space="preserve">
          <source>Change the &lt;b&gt;sqlite&lt;/b&gt; program so that it can read databases for which it lacks write permission. (It used to refuse all access if it could not write.)</source>
          <target state="translated">更改&lt;b&gt;sqlite&lt;/b&gt;程序，以便它可以读取缺少写许可权的数据库。（它曾经拒绝所有无法写入的访问。）</target>
        </trans-unit>
        <trans-unit id="cbf993184d73b432fd33a6a4967c4e16c588f384" translate="yes" xml:space="preserve">
          <source>Change the code so that version 2.1.1 databases that were rendered unreadable by the above bug can be read by this version of the library even though the SQLITE_MASTER table is (slightly) corrupted.</source>
          <target state="translated">修改代码,使因上述bug而无法读取的2.1.1版本的数据库可以被这个版本的库读取,即使SQLITE_MASTER表已经(略微)损坏。</target>
        </trans-unit>
        <trans-unit id="1b2c3ec73b516454d30b27549240c5be169d57e9" translate="yes" xml:space="preserve">
          <source>Change the datatype of SrcList.nSrc from type u8 to type int to work around an issue in the C compiler on AIX.</source>
          <target state="translated">将SrcList.nSrc的数据类型从u8型改为int型,以解决AIX上C编译器的问题。</target>
        </trans-unit>
        <trans-unit id="03b6774f351d6b79789eab0049e6b7dfa776c60c" translate="yes" xml:space="preserve">
          <source>Change the format of data records so that records up to 16MB in size can be stored.</source>
          <target state="translated">改变数据记录的格式,使记录的大小可以达到16MB。</target>
        </trans-unit>
        <trans-unit id="cb9d727fc495b196f0a9e9dcf746f3b21fc8137d" translate="yes" xml:space="preserve">
          <source>Change the format of indices to allow for better query optimization.</source>
          <target state="translated">改变索引的格式,以便更好地优化查询。</target>
        </trans-unit>
        <trans-unit id="5c9b7b0951ce0a0f4a0c1e9e79102e0b6bc620be" translate="yes" xml:space="preserve">
          <source>Change the format of indices to correct a design flaw the originated with version 2.1.0. *** This is an incompatible file format change *** When version 2.6.0 or later of the library attempts to open a database file created by version 2.5.6 or earlier, it will automatically and irreversibly convert the file format. &lt;b&gt;Make backup copies of older database files before opening them with version 2.6.0 of the library.&lt;/b&gt;</source>
          <target state="translated">更改索引格式，以纠正源于版本2.1.0的设计缺陷。***这是不兼容的文件格式更改***当库的版本2.6.0或更高版本尝试打开由版本2.5.6或更早版本创建的数据库文件时，它将自动且不可逆地转换文件格式。&lt;b&gt;在使用库的版本2.6.0打开旧数据库文件之前，请对其进行备份。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b18ff5a16f7817612045bc810baefbc9f406946f" translate="yes" xml:space="preserve">
          <source>Change the journal mode of database P1 to P3. P3 must be one of the PAGER_JOURNALMODE_XXX values. If changing between the various rollback modes (delete, truncate, persist, off and memory), this is a simple operation. No IO is required.</source>
          <target state="translated">将数据库P1的日记模式改为P3。P3必须是PAGER_JOURNALMODE_XXX值之一。如果在各种回滚模式(删除、截断、持久化、关闭和内存)之间改变,这是一个简单的操作。不需要IO。</target>
        </trans-unit>
        <trans-unit id="6a5f740ae4d06bae054615ec1ed93d10f35a1f54" translate="yes" xml:space="preserve">
          <source>Change the makefile so that it no longer requires GNUmake extensions</source>
          <target state="translated">修改makefile,使其不再需要GNUmake扩展。</target>
        </trans-unit>
        <trans-unit id="1b024f79cb0f34e36e5e78085bb24625608ab395" translate="yes" xml:space="preserve">
          <source>Change the name of new_X to X using: ALTER TABLE new_X RENAME TO X.</source>
          <target state="translated">将new_X的名称改为X。ALTER TABLE new_X RENAME TO X。</target>
        </trans-unit>
        <trans-unit id="0f9e3a306b4bd9af67f4b8c1e8cb9e151f5fea94" translate="yes" xml:space="preserve">
          <source>Change the name of the sanity_check PRAGMA to &lt;b&gt;integrity_check&lt;/b&gt; and make it available in all compiles.</source>
          <target state="translated">将sanity_check PRAGMA的名称更改为&lt;b&gt;完整性&lt;/b&gt; _check，并使其在所有编译中均可用。</target>
        </trans-unit>
        <trans-unit id="a87afe8ac8040316feb3c86d9f29d7a0de41424f" translate="yes" xml:space="preserve">
          <source>Change the round() function to return REAL instead of TEXT.</source>
          <target state="translated">将round()函数改为返回REAL而不是TEXT。</target>
        </trans-unit>
        <trans-unit id="4cc900222ca19ab1e3c50fea1f145e841c36bab9" translate="yes" xml:space="preserve">
          <source>Change the schema parser so that it will error out if any of the type, name, and tbl_name columns of the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master table&lt;/a&gt; have been corrupted and the database connection is not in &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;writable_schema&lt;/a&gt; mode.</source>
          <target state="translated">更改架构分析器，以便在&lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master表的&lt;/a&gt;任何类型，名称和tbl_name列已损坏并且数据库连接未处于&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;writable_schema&lt;/a&gt;模式时将出错。</target>
        </trans-unit>
        <trans-unit id="8e16078deadbe9f7e3e1b2c9c9d590cfec88a614" translate="yes" xml:space="preserve">
          <source>Change the schema parser so that it will error out if any of the type, name, and tbl_name columns of the &lt;a href=&quot;schematab&quot;&gt;sqlite_master table&lt;/a&gt; have been corrupted and the database connection is not in &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;writable_schema&lt;/a&gt; mode.</source>
          <target state="translated">更改架构分析器，以便在&lt;a href=&quot;schematab&quot;&gt;sqlite_master表的&lt;/a&gt;任何类型，名称和tbl_name列已损坏并且数据库连接未处于&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;writable_schema&lt;/a&gt;模式下时将出错。</target>
        </trans-unit>
        <trans-unit id="8cf246de2a9b8a88c663c6913b8ed3a48191818d" translate="yes" xml:space="preserve">
          <source>Change the table_info pragma so that it returns NULL for the default value if there is no default value</source>
          <target state="translated">修改 table_info pragma,使其在没有默认值的情况下返回 NULL。</target>
        </trans-unit>
        <trans-unit id="b05df024c90267a155027a34482c97ed1e176816" translate="yes" xml:space="preserve">
          <source>Change the tclsqlite &quot;eval&quot; method to return a list of results if no callback script is specified.</source>
          <target state="translated">修改tclsqlite &quot;eval &quot;方法,如果没有指定回调脚本,则返回结果列表。</target>
        </trans-unit>
        <trans-unit id="17fc584f1b3f79a52638c936555356d72a9a526e" translate="yes" xml:space="preserve">
          <source>Change the unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to be tolerant of read() system calls that return less then the full number of requested bytes.</source>
          <target state="translated">将unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;更改为可以容忍read（）系统调用，该系统调用返回的内容少于所请求字节的总数。</target>
        </trans-unit>
        <trans-unit id="a542a095188ddcc6129238423271833568a2c07f" translate="yes" xml:space="preserve">
          <source>Change the way SUM() handles NULL values in order to comply with the SQL standard</source>
          <target state="translated">改变SUM()处理NULL值的方式,以符合SQL标准。</target>
        </trans-unit>
        <trans-unit id="5b5328bf106285a23dec346b5145893a33e1e8c9" translate="yes" xml:space="preserve">
          <source>Change the xFileControl() methods on all built-in VFSes to return &lt;a href=&quot;rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; instead of &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; for an unrecognized operation code.</source>
          <target state="translated">更改所有内置VFS上的xFileControl（）方法以针对无法识别的操作代码返回&lt;a href=&quot;rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;而不是&lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eca73e726e881b6d471428b557f6268ef3f59ed9" translate="yes" xml:space="preserve">
          <source>Change to use strncmp() or the equivalent instead of memcmp() when comparing non-zero-terminated strings.</source>
          <target state="translated">当比较非零结尾的字符串时,改用strncmp()或等价物代替memcmp()。</target>
        </trans-unit>
        <trans-unit id="5514a8922a61fec2577edc11821f533a39d0a9ca" translate="yes" xml:space="preserve">
          <source>Changed the comparison function so that numbers in exponential notation (ex: 1.234e+05) sort in numerical order.</source>
          <target state="translated">修改了比较函数,使指数符号的数字(如:1.234e+05)按数字顺序排序。</target>
        </trans-unit>
        <trans-unit id="df02ed3983d83060874d040fa7eb3a189bd673c0" translate="yes" xml:space="preserve">
          <source>Changed the default configuration of the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; from 500 slots of 128 bytes each into 125 slots of 512 bytes each.</source>
          <target state="translated">将&lt;a href=&quot;malloc#lookaside&quot;&gt;后备内存分配器&lt;/a&gt;的默认配置从每个128个字节的500个插槽更改为每个512个字节的125个插槽。</target>
        </trans-unit>
        <trans-unit id="7e34599469a327d2e948bcc9862b0322f2e510f5" translate="yes" xml:space="preserve">
          <source>Changed the defined behavior for the &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt; when floating point values greater than +9223372036854775807 are cast into into integers so that the result is the largest possible integer, +9223372036854775807, instead of the smallest possible integer, -9223372036854775808. After this change, CAST(9223372036854775809.0 as INT) yields +9223372036854775807 instead of -9223372036854775808. &lt;b&gt;&lt;big&gt;&amp;larr;&lt;/big&gt; Potentially Incompatible Change!&lt;/b&gt;</source>
          <target state="translated">当大于+9223372036854775807的浮点值转换为整数时，更改了&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST表达式的&lt;/a&gt;已定义行为，以便结果是最大可能的整数+922337203685477575807，而不是最小可能的整数-9223372036854775808。进行此更改之后，CAST（9223372036854775809.0作为INT）产生+9223372036854775807而不是-9223372036854775808。&lt;b&gt;&lt;big&gt;&amp;larr;&lt;/big&gt;潜在不兼容的更改！&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8caa23815a1a8b1a9c4e9cdf79d42cbf41197489" translate="yes" xml:space="preserve">
          <source>Changed the print format for floating point values from &quot;%g&quot; to &quot;%.15g&quot;.</source>
          <target state="translated">将浮点数的打印格式从&quot;%g &quot;改为&quot;%.15g&quot;。</target>
        </trans-unit>
        <trans-unit id="24a6e547edd1d04eb53e9f5fe5f292726e669a13" translate="yes" xml:space="preserve">
          <source>Changed the prototype of the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface in a way that is backwards compatible but which might cause warnings in new builds of applications that use that interface.</source>
          <target state="translated">以向后兼容的方式更改了&lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;接口的原型，但可能会在使用该接口的新版本应用程序中引起警告。</target>
        </trans-unit>
        <trans-unit id="f51c4a6bf59ab3184542658dacdac319c7bb7606" translate="yes" xml:space="preserve">
          <source>Changed the signature of the xDlSym method of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object in a way that is backwards compatible but which might cause compiler warnings.</source>
          <target state="translated">以向后兼容但可能会引起编译器警告的方式更改了&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的xDlSym方法的签名。</target>
        </trans-unit>
        <trans-unit id="09eb09203ab84e8c2e6e475c70c299202b24c3d8" translate="yes" xml:space="preserve">
          <source>Changegroup Handle</source>
          <target state="translated">变更组手柄</target>
        </trans-unit>
        <trans-unit id="11562ffd183a3f8082c848cac1f5dad1ab2f2843" translate="yes" xml:space="preserve">
          <source>Changes In SQLite Version 3.7.10</source>
          <target state="translated">SQLite 3.7.10版本中的变化</target>
        </trans-unit>
        <trans-unit id="2995749ac68f24f9806cbd53a3147e4763d74488" translate="yes" xml:space="preserve">
          <source>Changes are made to the database by executing SQL statements. The session object records these changes.</source>
          <target state="translated">通过执行SQL语句对数据库进行更改。会话对象记录了这些变化。</target>
        </trans-unit>
        <trans-unit id="3feb747c2cf9c224527b83786a30acbbf79e8f1b" translate="yes" xml:space="preserve">
          <source>Changes are not recorded for individual rows that have NULL values stored in one or more of their PRIMARY KEY columns.</source>
          <target state="translated">对于在一个或多个PRIMARY KEY列中存储有NULL值的个别行,不记录更改。</target>
        </trans-unit>
        <trans-unit id="5ba7ed905184ce22787b0029a4544681dc28b3db" translate="yes" xml:space="preserve">
          <source>Changes are not recorded for rows that have NULL values stored in one or more of their PRIMARY KEY columns. If such a row is inserted or deleted, no corresponding change is present in the changesets returned by this function. If an existing row with one or more NULL values stored in PRIMARY KEY columns is updated so that all PRIMARY KEY columns are non-NULL, only an INSERT is appears in the changeset. Similarly, if an existing row with non-NULL PRIMARY KEY values is updated so that one or more of its PRIMARY KEY columns are set to NULL, the resulting changeset contains a DELETE change only.</source>
          <target state="translated">对于在一个或多个PRIMARY KEY列中存储有NULL值的行,不记录更改。如果这样的行被插入或删除,那么在这个函数返回的变化集中就不会出现相应的变化。如果一条在PRIMARY KEY列中存储了一个或多个NULL值的现有记录被更新,使所有PRIMARY KEY列都是非NULL,那么在变化集中只出现一个INSERT。同样的,如果更新一条现有的PRIMARY KEY值为非NULL的记录,使它的一个或多个PRIMARY KEY列被设置为NULL,那么产生的变化集只包含一个DELETE的变化。</target>
        </trans-unit>
        <trans-unit id="f6e50ec4a352fdec5ac39c386ca001416ca1e482" translate="yes" xml:space="preserve">
          <source>Changes can only be recorded for tables that have a PRIMARY KEY explicitly defined as part of their CREATE TABLE statement. It does not matter if the PRIMARY KEY is an &quot;INTEGER PRIMARY KEY&quot; (rowid alias) or not. The PRIMARY KEY may consist of a single column, or may be a composite key.</source>
          <target state="translated">只有那些在CREATE TABLE语句中明确定义了PRIMARY KEY的表才能记录更改。不管PRIMARY KEY是否是 &quot;INTEGER PRIMARY KEY&quot;(rowid别名)。PRIMARY KEY可以由一列组成,也可以是一个复合键。</target>
        </trans-unit>
        <trans-unit id="c0acee58dba4e45c8d5f0399ec1f0d4976436ff2" translate="yes" xml:space="preserve">
          <source>Changes made as part of &lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; are included in the count, but those made as part of REPLACE constraint resolution are not. Changes to a view that are intercepted by INSTEAD OF triggers are not counted.</source>
          <target state="translated">作为&lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;外键动作的&lt;/a&gt;一部分所做的更改包括在计数中，但作为REPLACE约束解析的一部分所做的更改不包括在内。被INSTEAD OF触发器拦截的视图更改不计算在内。</target>
        </trans-unit>
        <trans-unit id="b4615c7abb16118eca044200ca3ffb2d42e109f3" translate="yes" xml:space="preserve">
          <source>Changes made as part of &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; are included in the count, but those made as part of REPLACE constraint resolution are not. Changes to a view that are intercepted by INSTEAD OF triggers are not counted.</source>
          <target state="translated">作为&lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;外键动作的&lt;/a&gt;一部分所做的更改包括在计数中，但作为REPLACE约束解析的一部分所做的更改不包括在内。被INSTEAD OF触发器拦截的视图更改不计算在内。</target>
        </trans-unit>
        <trans-unit id="1e424444f79aa5098cffaecbf261fdab95101506" translate="yes" xml:space="preserve">
          <source>Changes made in one database connection are invisible to all other database connections prior to commit.</source>
          <target state="translated">在提交前,在一个数据库连接中所做的更改对所有其他数据库连接是不可见的。</target>
        </trans-unit>
        <trans-unit id="f8bcc1bfedf61a4d6d2302f5aebd841ed0c31154" translate="yes" xml:space="preserve">
          <source>Changes to CREATE VIRTUAL TABLE statements</source>
          <target state="translated">对CREATE VIRTUAL TABLE语句的修改</target>
        </trans-unit>
        <trans-unit id="39b78ad4f8a76dbe4baff285b9df3d3da0888670" translate="yes" xml:space="preserve">
          <source>Changes to SELECT statements</source>
          <target state="translated">对SELECT语句的修改</target>
        </trans-unit>
        <trans-unit id="220e3088537dbb26a066213f366f942dc49c0e70" translate="yes" xml:space="preserve">
          <source>Changes to a view that are intercepted by &lt;a href=&quot;../lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF triggers&lt;/a&gt; are not counted. The value returned by sqlite3_changes() immediately after an INSERT, UPDATE or DELETE statement run on a view is always zero. Only changes made to real tables are counted.</source>
          <target state="translated">被&lt;a href=&quot;../lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF触发器&lt;/a&gt;拦截的视图更改不计算在内。在视图上运行INSERT，UPDATE或DELETE语句后，sqlite3_changes（）返回的值始终为零。仅计算对实际表所做的更改。</target>
        </trans-unit>
        <trans-unit id="5d6b66157c1ebd92a27f45e6d4f023a3d4bc6e87" translate="yes" xml:space="preserve">
          <source>Changes to a view that are intercepted by &lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF triggers&lt;/a&gt; are not counted. The value returned by sqlite3_changes() immediately after an INSERT, UPDATE or DELETE statement run on a view is always zero. Only changes made to real tables are counted.</source>
          <target state="translated">被&lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF触发器&lt;/a&gt;拦截的视图更改不计算在内。在视图上运行INSERT，UPDATE或DELETE语句后，sqlite3_changes（）返回的值始终为零。仅计算对实际表所做的更改。</target>
        </trans-unit>
        <trans-unit id="3ac2cb6fb5d947302cd716dd294d872e94891de1" translate="yes" xml:space="preserve">
          <source>Changes to comments.</source>
          <target state="translated">对意见的修改:</target>
        </trans-unit>
        <trans-unit id="c84397dcd0da39654544ab29ddec3a05373f0685" translate="yes" xml:space="preserve">
          <source>Changes to compile-time options:</source>
          <target state="translated">修改编译时选项。</target>
        </trans-unit>
        <trans-unit id="101e26bd8ffca056c8adaec28f53e8804617dcdd" translate="yes" xml:space="preserve">
          <source>Changes to rows that do not already appear in the changegroup are simply copied into it. Or, if both the new changeset and the changegroup contain changes that apply to a single row, the final contents of the changegroup depends on the type of each change, as follows:</source>
          <target state="translated">对未出现在变更组中的行的变更将被简单地复制到变更组中。或者,如果新的变更集和变更组都包含了适用于单行的变更,那么变更组的最终内容取决于每个变更的类型,如下所示:</target>
        </trans-unit>
        <trans-unit id="3fc8393d45e2f151d9e20c436cc969f753e757c8" translate="yes" xml:space="preserve">
          <source>Changes to some test scripts so that they work on Windows in addition to Unix.</source>
          <target state="translated">对一些测试脚本进行了修改,使其除了在Unix上工作外,还能在Windows上工作。</target>
        </trans-unit>
        <trans-unit id="e4c26ff789d743fb895c4925c581702e142ed6c8" translate="yes" xml:space="preserve">
          <source>Changes to support 64-bit architectures.</source>
          <target state="translated">支持64位架构的变化。</target>
        </trans-unit>
        <trans-unit id="0e15c1197ceca55511517525b0c74a6a5dfd3ac1" translate="yes" xml:space="preserve">
          <source>Changes to the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object</source>
          <target state="translated">对&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的更改</target>
        </trans-unit>
        <trans-unit id="062c3354f76067d89f734b31e5b499c574c81bb7" translate="yes" xml:space="preserve">
          <source>Changes to the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; to help it work better when compiled using MSVC.</source>
          <target state="translated">对&lt;a href=&quot;lemon&quot;&gt;Lemon解析器生成器&lt;/a&gt;进行了更改，以帮助使用MSVC进行编译时更好地工作。</target>
        </trans-unit>
        <trans-unit id="d0bc6551b6a2c8af14e74911872297e41927e492" translate="yes" xml:space="preserve">
          <source>Changes to the FULL_COLUMN_NAMES pragma to help out the ODBC driver.</source>
          <target state="translated">对 FULL_COLUMN_NAMES pragma 进行了修改,以帮助 ODBC 驱动程序。</target>
        </trans-unit>
        <trans-unit id="7e96fb7803c57c4c013f472a7a7b6294655eae95" translate="yes" xml:space="preserve">
          <source>Changes to the OS-layer interface: mutexes must now be recursive.</source>
          <target state="translated">对操作系统层接口的修改:mutexes现在必须是递归的。</target>
        </trans-unit>
        <trans-unit id="32f6cdea79e8215becbb15cf7bd7e55cdcee90d2" translate="yes" xml:space="preserve">
          <source>Changes within a patchset are ordered in the same way as for changesets generated by the sqlite3session_changeset() function (i.e. all changes for a single table are grouped together, tables appear in the order in which they were attached to the session object).</source>
          <target state="translated">修补集中的更改与sqlite3session_changeset()函数生成的更改集的排序方式相同(也就是说,一个表的所有更改都被归为一组,表按照它们被附加到会话对象的顺序出现)。</target>
        </trans-unit>
        <trans-unit id="da04970767ae72464882ac8a4e16564000ecf171" translate="yes" xml:space="preserve">
          <source>Changes within the local changeset are rebased as follows:</source>
          <target state="translated">本地变更集内的变更按以下方式重新计算。</target>
        </trans-unit>
        <trans-unit id="3a336eee124955ea62ce9395beedef4d114ca005" translate="yes" xml:space="preserve">
          <source>Changeset Generation</source>
          <target state="translated">变化集的产生</target>
        </trans-unit>
        <trans-unit id="83360005f23e00ab75cb5a31e370b474e7cda3dd" translate="yes" xml:space="preserve">
          <source>Changeset Iterator Handle</source>
          <target state="translated">变更集迭代器手柄</target>
        </trans-unit>
        <trans-unit id="e80a51a4aaef4428a67700502b5f7dc75dbd4588" translate="yes" xml:space="preserve">
          <source>Changesets may only be applied to databases that contain tables matching the above three criteria as stored in the changeset.</source>
          <target state="translated">变更集只能应用于包含与上述三个标准相匹配的表的数据库,这些表存储在变更集中。</target>
        </trans-unit>
        <trans-unit id="ac1c3813780e3748f7f89bcb8cde7110310ebb74" translate="yes" xml:space="preserve">
          <source>Changing Filesystems</source>
          <target state="translated">更改文件系统</target>
        </trans-unit>
        <trans-unit id="5f75f4f19ef2482e0ee092a7ab747ab2b4de6353" translate="yes" xml:space="preserve">
          <source>Changing the &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version&lt;/a&gt; while other database connections are open.</source>
          <target state="translated">在打开其他数据库连接的同时更改&lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9851972ccfb6ddbbe4682022996c0b7f4c61ad78" translate="yes" xml:space="preserve">
          <source>Changing the data_store_directory setting is &lt;u&gt;not&lt;/u&gt; threadsafe. Never change the data_store_directory setting if another thread within the application is running any SQLite interface at the same time. Doing so results in undefined behavior. Changing the data_store_directory setting writes to the &lt;a href=&quot;c3ref/data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; global variable and that global variable is not protected by a mutex.</source>
          <target state="translated">更改data_store_directory设置&lt;u&gt;不是&lt;/u&gt;线程安全的。如果应用程序中的另一个线程正在同时运行任何SQLite接口，则切勿更改data_store_directory设置。这样做会导致未定义的行为。更改data_store_directory设置将写入&lt;a href=&quot;c3ref/data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt;全局变量，并且该全局变量不受互斥锁的保护。</target>
        </trans-unit>
        <trans-unit id="430a2be1381002d87b9b8ff73223fcbf66c5e87f" translate="yes" xml:space="preserve">
          <source>Changing the foreign_keys setting affects the execution of all statements prepared using the database connection, including those prepared before the setting was changed. Any existing statements prepared using the legacy &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface may fail with an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error after the foreign_keys setting is changed.</source>
          <target state="translated">更改foreign_keys设置会影响使用数据库连接准备的所有语句的执行，包括更改设置之前准备的语句。更改foreign_keys设置后，使用旧版&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;接口准备的任何现有语句都可能因&lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt;错误而失败。</target>
        </trans-unit>
        <trans-unit id="e64e5108f8dce99580f41bdd628fb1a43e13fc20" translate="yes" xml:space="preserve">
          <source>Changing the recursive_triggers setting affects the execution of all statements prepared using the database connection, including those prepared before the setting was changed. Any existing statements prepared using the legacy &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface may fail with an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error after the recursive_triggers setting is changed.</source>
          <target state="translated">更改recursive_triggers设置会影响使用数据库连接准备的所有语句的执行，包括更改设置之前准备的语句。更改recursive_triggers设置后，使用旧版&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;接口准备的任何现有语句都可能因&lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt;错误而失败。</target>
        </trans-unit>
        <trans-unit id="859510e9fde4ba7098039dc9d57957c57590e8ad" translate="yes" xml:space="preserve">
          <source>Changing the temp_store_directory setting is &lt;u&gt;not&lt;/u&gt; threadsafe. Never change the temp_store_directory setting if another thread within the application is running any SQLite interface at the same time. Doing so results in undefined behavior. Changing the temp_store_directory setting writes to the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable and that global variable is not protected by a mutex.</source>
          <target state="translated">更改temp_store_directory设置&lt;u&gt;不是&lt;/u&gt;线程安全的。如果应用程序中的另一个线程正在同时运行任何SQLite接口，则切勿更改temp_store_directory设置。这样做会导致未定义的行为。更改temp_store_directory设置将写入&lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;全局变量，并且该全局变量不受互斥锁的保护。</target>
        </trans-unit>
        <trans-unit id="4a3e8791cfca3d884c74337ea57def9c05ece108" translate="yes" xml:space="preserve">
          <source>Changing the value of this variable while a database connection is open can result in a corrupt database.</source>
          <target state="translated">当数据库连接打开时,改变这个变量的值会导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="ee9946c82d4a077c5be79e3015a3d2479d9fcaf2" translate="yes" xml:space="preserve">
          <source>Character</source>
          <target state="translated">Character</target>
        </trans-unit>
        <trans-unit id="cea842266549b8d9e4991a72c7996837bc0ff6f1" translate="yes" xml:space="preserve">
          <source>Characters in the matchinfo format string are processed from left to right. Each character in the format string causes one or more 32-bit unsigned integer values to be added to the returned array. The &quot;values&quot; column in the following table contains the number of integer values appended to the output buffer for each supported format string character. In the formula given,</source>
          <target state="translated">matchinfo格式字符串中的字符从左到右处理。格式字符串中的每个字符都会导致一个或多个32位无符号整数值被添加到返回的数组中。下表中的 &quot;值 &quot;列包含了每个支持的格式字符串字符附加到输出缓冲区的整数值的数量。在给出的公式中。</target>
        </trans-unit>
        <trans-unit id="901d44a58ef0c59ab99643a19134ba47c238ad29" translate="yes" xml:space="preserve">
          <source>Chart 1: SQLite read latency relative to direct filesystem reads.</source>
          <target state="translated">图1:相对于文件系统直接读取的SQLite读取延迟。</target>
        </trans-unit>
        <trans-unit id="27276d4efc029611aba60cde7d26cce5f51fc924" translate="yes" xml:space="preserve">
          <source>Chart 2: SQLite read latency relative to direct filesystem reads.</source>
          <target state="translated">图2:相对于文件系统直接读取的SQLite读取延迟。</target>
        </trans-unit>
        <trans-unit id="9b63c13706e018a965e9ad083cf8558f0ea7a319" translate="yes" xml:space="preserve">
          <source>Chart 3: SQLite read latency relative to direct filesystem reads.</source>
          <target state="translated">图3:相对于文件系统直接读取的SQLite读取延迟。</target>
        </trans-unit>
        <trans-unit id="d2affd8c541db58f31c69f6910d1f00260d88617" translate="yes" xml:space="preserve">
          <source>Chart 4: SQLite write latency relative to direct filesystem writes.</source>
          <target state="translated">图4:SQLite写延迟相对于文件系统直接写入。</target>
        </trans-unit>
        <trans-unit id="3ac7623b08d5a3f0968ebaaaf80eef331d89a328" translate="yes" xml:space="preserve">
          <source>Chart 5: SQLite write latency relative to direct filesystem writes.</source>
          <target state="translated">图5:SQLite写延迟相对于文件系统直接写入。</target>
        </trans-unit>
        <trans-unit id="145b22ca4b4508601bd80ce10219fd8d551a1cef" translate="yes" xml:space="preserve">
          <source>Chastise the body.</source>
          <target state="translated">责备身体。</target>
        </trans-unit>
        <trans-unit id="0018d2d0130bb05c6b042cf37fbaadc3d3c580d7" translate="yes" xml:space="preserve">
          <source>Check local (non foreign key) constraints,</source>
          <target state="translated">检查本地(非外键)约束。</target>
        </trans-unit>
        <trans-unit id="b2b621da54eb725e76b59b6aa64ddca11509ebb6" translate="yes" xml:space="preserve">
          <source>Check the cursor P1 to see if it is currently pointing at a NULL row. If it is, then set register P3 to NULL and jump immediately to P2. If P1 is not on a NULL row, then fall through without making any changes.</source>
          <target state="translated">检查光标P1是否当前指向一个NULL行,如果是,则将寄存器P3设置为NULL,并立即跳到P2。如果是,则将寄存器P3设置为NULL,并立即跳转到P2。如果P1不在NULL行上,那么就不做任何改变而跳过。</target>
        </trans-unit>
        <trans-unit id="09e577018637d04e97c17b023b39748cce6a0852" translate="yes" xml:space="preserve">
          <source>Check the value in register P3. If it is NULL then &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; using parameter P1, P2, and P4 as if this were a &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; instruction. If the value in register P3 is not NULL, then this routine is a no-op. The P5 parameter should be 1.</source>
          <target state="translated">检查寄存器P3中的值。如果是NULL，则&lt;a href=&quot;opcode#Halt&quot;&gt;暂停&lt;/a&gt;使用参数P1，P2和P4仿佛这是一个&lt;a href=&quot;opcode#Halt&quot;&gt;暂停&lt;/a&gt;指令。如果寄存器P3中的值不为NULL，则此例程为空操作。P5参数应为1。</target>
        </trans-unit>
        <trans-unit id="853e2972eec38f585243beee1676c957c81ad890" translate="yes" xml:space="preserve">
          <source>Check to see if the database file has a hot journal. If the file does not have a hot journal, we are done. Return immediately. If there is a hot journal, that journal must be rolled back by the subsequent steps of this algorithm.</source>
          <target state="translated">检查数据库文件是否有热日志。如果文件没有热日志,我们就结束了。立即返回。如果有热日志,则必须通过该算法的后续步骤回滚该日志。</target>
        </trans-unit>
        <trans-unit id="a2f036a3bd46936cd9d2c40c2e45e1005b34f3dd" translate="yes" xml:space="preserve">
          <source>Checklist For Choosing The Right Database Engine</source>
          <target state="translated">选择正确的数据库引擎的检查表</target>
        </trans-unit>
        <trans-unit id="812e4bd3b7c47c7f81d4167d8aab871141a8c91b" translate="yes" xml:space="preserve">
          <source>Checklists</source>
          <target state="translated">Checklists</target>
        </trans-unit>
        <trans-unit id="5cb9afc05957645058216dd6772ded2e46522ec1" translate="yes" xml:space="preserve">
          <source>Checkpoint</source>
          <target state="translated">Checkpoint</target>
        </trans-unit>
        <trans-unit id="6c8f9631542e10f31e77b7a465542d388b6decdb" translate="yes" xml:space="preserve">
          <source>Checkpoint Information and Locks</source>
          <target state="translated">检查站信息和锁</target>
        </trans-unit>
        <trans-unit id="2a00fbbeacd66d1129876c4f2a120582b60dcc8f" translate="yes" xml:space="preserve">
          <source>Checkpoint Mode Values</source>
          <target state="translated">检查站模式值</target>
        </trans-unit>
        <trans-unit id="f8b00f7fe2c53994a3c2e16e9fff90f46c54af6d" translate="yes" xml:space="preserve">
          <source>Checkpoint a database</source>
          <target state="translated">检查点数据库</target>
        </trans-unit>
        <trans-unit id="37924a2fe97c6ebb27cab5b2e8b0b2d0894bd2b5" translate="yes" xml:space="preserve">
          <source>Checkpoint as many frames as possible without waiting for any database readers or writers to finish, then sync the database file if all frames in the log were checkpointed. The &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler callback&lt;/a&gt; is never invoked in the SQLITE_CHECKPOINT_PASSIVE mode. On the other hand, passive mode might leave the checkpoint unfinished if there are concurrent readers or writers.</source>
          <target state="translated">在不等待任何数据库读取器或写入器完成的情况下，尽可能多地检查点框架，然后如果日志中的所有框架都被检查点，则同步数据库文件。在&lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;繁忙的处理程序回调&lt;/a&gt;是从来没有在SQLITE_CHECKPOINT_PASSIVE模式调用。另一方面，如果同时存在读取器或写入器，则被动模式可能会使检查点未完成。</target>
        </trans-unit>
        <trans-unit id="65bebe73feb47e6a7a12e61f091ce204dad0258a" translate="yes" xml:space="preserve">
          <source>Checkpoint as many frames as possible without waiting for any database readers or writers to finish, then sync the database file if all frames in the log were checkpointed. The &lt;a href=&quot;busy_handler&quot;&gt;busy-handler callback&lt;/a&gt; is never invoked in the SQLITE_CHECKPOINT_PASSIVE mode. On the other hand, passive mode might leave the checkpoint unfinished if there are concurrent readers or writers.</source>
          <target state="translated">在不等待任何数据库读取器或写入器完成的情况下，尽可能多地检查点框架，然后如果日志中的所有框架都被检查点，则同步数据库文件。在&lt;a href=&quot;busy_handler&quot;&gt;繁忙的处理程序回调&lt;/a&gt;是从来没有在SQLITE_CHECKPOINT_PASSIVE模式调用。另一方面，如果同时存在读取器或写入器，则被动模式可能会使检查点未完成。</target>
        </trans-unit>
        <trans-unit id="11999bbd94b14ea8ec845c4fcad50ea24f0a3d45" translate="yes" xml:space="preserve">
          <source>Checkpoint as many frames as possible without waiting for any database readers or writers to finish. Sync the db file if all frames in the log are checkpointed. This mode is the same as calling the &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; C interface. The &lt;a href=&quot;c3ref/busy_handler&quot;&gt;busy-handler callback&lt;/a&gt; is never invoked in this mode.</source>
          <target state="translated">检查点尽可能多的帧，而无需等待任何数据库读取器或写入器完成。如果日志中的所有框架都已检查点，则同步数据库文件。此模式与调用&lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint（）&lt;/a&gt; C接口相同。在&lt;a href=&quot;c3ref/busy_handler&quot;&gt;繁忙的处理程序回调&lt;/a&gt;是从来没有在这种模式下调用。</target>
        </trans-unit>
        <trans-unit id="4db6d205b349663d744b71f2a117e634b9469124" translate="yes" xml:space="preserve">
          <source>Checkpoint database P1. This is a no-op if P1 is not currently in WAL mode. Parameter P2 is one of SQLITE_CHECKPOINT_PASSIVE, FULL, RESTART, or TRUNCATE. Write 1 or 0 into mem[P3] if the checkpoint returns SQLITE_BUSY or not, respectively. Write the number of pages in the WAL after the checkpoint into mem[P3+1] and the number of pages in the WAL that have been checkpointed after the checkpoint completes into mem[P3+2]. However on an error, mem[P3+1] and mem[P3+2] are initialized to -1.</source>
          <target state="translated">检查点数据库P1。如果P1当前不在WAL模式下,这是一个无操作。参数P2是SQLITE_CHECKPOINT_PASSIVE、FULL、RESTART或TRUNCATE中的一个。如果检查点分别返回SQLITE_BUSY或不返回,则向mem[P3]中写入1或0。将检查点后WAL中的页数写入mem[P3+1],将检查点完成后WAL中被检查的页数写入mem[P3+2]。但是在错误时,mem[P3+1]和mem[P3+2]被初始化为-1。</target>
        </trans-unit>
        <trans-unit id="c93c7ed9eb6c55536fc1fa5a09dd161c7c872485" translate="yes" xml:space="preserve">
          <source>Checkpoint sequence number</source>
          <target state="translated">检查点序列号</target>
        </trans-unit>
        <trans-unit id="73420aa2c87505947c6412ba6601937a69b34e0a" translate="yes" xml:space="preserve">
          <source>Checkpointing does require sync operations in order to avoid the possibility of database corruption following a power loss or hard reboot. The WAL must be synced to persistent storage prior to moving content from the WAL into the database and the database file must by synced prior to resetting the WAL. Checkpoint also requires more seeking. The checkpointer makes an effort to do as many sequential page writes to the database as it can (the pages are transferred from WAL to database in ascending order) but even then there will typically be many seek operations interspersed among the page writes. These factors combine to make checkpoints slower than write transactions.</source>
          <target state="translated">检查点确实需要进行同步操作,以避免断电或硬重启后数据库损坏的可能性。在将内容从WAL移入数据库之前,必须将WAL同步到持久存储中,在重置WAL之前,必须通过同步数据库文件。检查点也需要更多的寻求。Checkpointer会努力向数据库进行尽可能多的顺序页面写入(页面从WAL按升序传输到数据库),但即使这样,通常也会在页面写入中穿插许多寻求操作。这些因素综合起来,使得检查点的速度比写事务慢。</target>
        </trans-unit>
        <trans-unit id="13a5691b3271955325bfbd27f548fc8c0c82dfae" translate="yes" xml:space="preserve">
          <source>Checkpoints initiated by this mechanism are &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;PASSIVE&lt;/a&gt;.</source>
          <target state="translated">通过此机制启动的检查点为&lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;PASSIVE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab8c79d054f22aac4eeb01b5ef4d71f862efa21c" translate="yes" xml:space="preserve">
          <source>Checkpoints initiated by this mechanism are &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;PASSIVE&lt;/a&gt;.</source>
          <target state="translated">通过此机制启动的检查点为&lt;a href=&quot;wal_checkpoint_v2&quot;&gt;PASSIVE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="df9b91c031577503e347c145ff1b0094db4452ef" translate="yes" xml:space="preserve">
          <source>Checks if the &quot;fired&quot; flag has been set. If so, the unlock-notify callback has already been invoked. Release the mutex and continue.</source>
          <target state="translated">检查是否已经设置了 &quot;fireed &quot;标志,如果是,则解锁-通知回调已经被调用。如果是,则解锁通知回调已经被调用。释放mutex并继续。</target>
        </trans-unit>
        <trans-unit id="d8fcd1cd020581d6d23f7d74cd403fc559263ad5" translate="yes" xml:space="preserve">
          <source>Checksum</source>
          <target state="translated">Checksum</target>
        </trans-unit>
        <trans-unit id="c2d50b4086a2009c1329398de62782c1b322789e" translate="yes" xml:space="preserve">
          <source>Checksum of the last frame in the WAL file.</source>
          <target state="translated">WAL文件中最后一帧的校验和。</target>
        </trans-unit>
        <trans-unit id="36775ac61bbdc09836e15e4ec7e669eae516b3d3" translate="yes" xml:space="preserve">
          <source>Checksum-1: Cumulative checksum up through and including this page</source>
          <target state="translated">Checksum-1:截至并包括本页面的累计校验。</target>
        </trans-unit>
        <trans-unit id="0f0241436226dd5ad15b784282d744ddcaf53796" translate="yes" xml:space="preserve">
          <source>Checksum-1: First part of a checksum on the first 24 bytes of header</source>
          <target state="translated">Checksum-1:头24个字节的第一部分校验和。</target>
        </trans-unit>
        <trans-unit id="25d65b4024e29fd560da0ace1eb3f77896847390" translate="yes" xml:space="preserve">
          <source>Checksum-2: Second half of the cumulative checksum.</source>
          <target state="translated">校验-2:累计校验的后半部分。</target>
        </trans-unit>
        <trans-unit id="abcb92542826823bd4a635495c66df0db032424c" translate="yes" xml:space="preserve">
          <source>Checksum-2: Second part of the checksum on the first 24 bytes of header</source>
          <target state="translated">Checksum-2:头24个字节的第二部分校验和。</target>
        </trans-unit>
        <trans-unit id="f67c2d32dbe70d2749477ec3873f70b148c33e3f" translate="yes" xml:space="preserve">
          <source>Checksumming only works on databases that have a &lt;a href=&quot;fileformat2#resbyte&quot;&gt;reserve bytes&lt;/a&gt; value of exactly 8. The default value for reserve-bytes is 0. Hence, newly created database files will omit the checksum by default. To create a database that includes a checksum, change the reserve-bytes value to 8 by running code similar to this:</source>
          <target state="translated">校验和仅适用于&lt;a href=&quot;fileformat2#resbyte&quot;&gt;保留字节&lt;/a&gt;值恰好为8的数据库。保留字节的默认值为0。因此，默认情况下，新创建的数据库文件将忽略校验和。要创建一个包含校验和的数据库，请通过运行类似于以下代码的方式将保留字节的值更改为8：</target>
        </trans-unit>
        <trans-unit id="2e6fc2f66d5cb19af415e45034e0124b71cc4cce" translate="yes" xml:space="preserve">
          <source>Cherrypick fixes for other obscure problems found since the 3.30.0 release</source>
          <target state="translated">Cherrypick修复了3.30.0发布后发现的其他不明显的问题。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
