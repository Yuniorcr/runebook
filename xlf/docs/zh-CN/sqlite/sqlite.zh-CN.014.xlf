<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="3c516f46aa712315eea6584868cd627c02de7056" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt;, &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;.</source>
          <target state="translated">另请参见：&lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt;，&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f01472d4da0f8e936c195c67175f791d08d0adbf" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;</source>
          <target state="translated">另请参阅：&lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d54723288e675ac0abb24e0dd779375fca23df6b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;pragma#pragma_table_xinfo&quot;&gt;PRAGMA table_xinfo&lt;/a&gt;</source>
          <target state="translated">另请参阅：&lt;a href=&quot;pragma#pragma_table_xinfo&quot;&gt;PRAGMA table_xinfo&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bfa2363ed594f2b2eede2b270349dfc67d7ebc18" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;pragma#syntax&quot;&gt;pragma.html#syntax&lt;/a&gt;</source>
          <target state="translated">另请参阅：&lt;a href=&quot;pragma#syntax&quot;&gt;pragma.html＃syntax&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8a4951221a904acb6ba86986765efc2037a09378" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;printf&quot;&gt;built-in printf()&lt;/a&gt;, &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;printf&quot;&gt;内置printf（）&lt;/a&gt;，&lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf（）SQL函数&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="99bd38c265a6fb23dc830f7fe8c080eded5d7a07" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;release_memory&quot;&gt;sqlite3_release_memory（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98b434bc0d8b8d185283486c42d9be672854146f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;rescode#busy_recovery&quot;&gt;SQLITE_BUSY_RECOVERY&lt;/a&gt; and &lt;a href=&quot;rescode#busy_snapshot&quot;&gt;SQLITE_BUSY_SNAPSHOT&lt;/a&gt;.</source>
          <target state="translated">另请参见：&lt;a href=&quot;rescode#busy_recovery&quot;&gt;SQLITE_BUSY_RECOVERY&lt;/a&gt;和&lt;a href=&quot;rescode#busy_snapshot&quot;&gt;SQLITE_BUSY_SNAPSHOT&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7299f9082103db8b34938e68ec91bd133f202916" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;reset_auto_extension&quot;&gt;sqlite3_reset_auto_extension()&lt;/a&gt; and &lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension()&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;reset_auto_extension&quot;&gt;sqlite3_reset_auto_extension（）&lt;/a&gt;和&lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fa3c9ecf5456096c4af70cc1a45db8215c53ecad" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;status&quot;&gt;sqlite3_status()&lt;/a&gt; and &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt;.</source>
          <target state="translated">另请参见：&lt;a href=&quot;status&quot;&gt;sqlite3_status（）&lt;/a&gt;和&lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="81c9581d614ee93295a05913a13ce83a1c537800" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;status&quot;&gt;sqlite3_status()&lt;/a&gt; and &lt;a href=&quot;stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt;.</source>
          <target state="translated">另请参见：&lt;a href=&quot;status&quot;&gt;sqlite3_status（）&lt;/a&gt;和&lt;a href=&quot;stmt_status&quot;&gt;sqlite3_stmt_status（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="51bddd2f47aedb88c82ed00196f1d5f18d63b931" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;stmt_scanstatus_reset&quot;&gt;sqlite3_stmt_scanstatus_reset()&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;stmt_scanstatus_reset&quot;&gt;sqlite3_stmt_scanstatus_reset（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5f9c8eaf62fde3d86c43f634a7ab02bd2fa6122" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob()&lt;/a&gt;.</source>
          <target state="translated">另请参见：&lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0933bf0a406419507f269f3297ab20733c0130b5" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike()&lt;/a&gt;.</source>
          <target state="translated">另请参见：&lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="673270029c9264ee605b8c3d4c2fd772ac5ed2ec" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f7a6a573f1a49c137144c2c0c0b973878be6af5b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;update_hook&quot;&gt;sqlite3_update_hook()&lt;/a&gt;</source>
          <target state="translated">另请参见：&lt;a href=&quot;update_hook&quot;&gt;sqlite3_update_hook（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7b9de33ebd0cee270413e31ceb4bf9982bf25845" translate="yes" xml:space="preserve">
          <source>See also: SQL functions &lt;a href=&quot;../lang_corefunc#sqlite_compileoption_used&quot;&gt;sqlite_compileoption_used()&lt;/a&gt; and &lt;a href=&quot;../lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get()&lt;/a&gt; and the &lt;a href=&quot;../pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;.</source>
          <target state="translated">另请参见：SQL函数&lt;a href=&quot;../lang_corefunc#sqlite_compileoption_used&quot;&gt;sqlite_compileoption_used（）&lt;/a&gt;和&lt;a href=&quot;../lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get（）&lt;/a&gt;以及&lt;a href=&quot;../pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="83dccf87582bc1362c408c238feac4693c82e492" translate="yes" xml:space="preserve">
          <source>See also: SQL functions &lt;a href=&quot;lang_corefunc#sqlite_compileoption_used&quot;&gt;sqlite_compileoption_used()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get()&lt;/a&gt; and the &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;.</source>
          <target state="translated">另请参见：SQL函数&lt;a href=&quot;lang_corefunc#sqlite_compileoption_used&quot;&gt;sqlite_compileoption_used（）&lt;/a&gt;和&lt;a href=&quot;lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get（）&lt;/a&gt;以及&lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="61cca4e5d339d369ec47f24cb61df5080a8fe143" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">有关其他信息，请参见&lt;a href=&quot;../threadsafe&quot;&gt;线程模式&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="6f095aa19ffa800ceddf0ec91e83f4521ad7e3e5" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;../uri&quot;&gt;URI filename&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">有关其他信息，请参见&lt;a href=&quot;../uri&quot;&gt;URI文件名&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="14bd56e01493d3e179ad29ee876d123ae68f7d39" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;assert&quot;&gt;Use Of assert in SQLite&lt;/a&gt; document for additional information about how SQLite uses assert().</source>
          <target state="translated">有关&lt;a href=&quot;assert&quot;&gt;SQLite&lt;/a&gt;如何使用assert（）的其他信息，请参见SQLite文档中的Use assert。</target>
        </trans-unit>
        <trans-unit id="b7c31bb847b7fb9dd4bac9cc5dd5dc1c96846800" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;autoinc&quot;&gt;SQLite AUTOINCREMENT documentation&lt;/a&gt; for detailed instructions on what AUTOINCREMENT does and does not do in SQLite.</source>
          <target state="translated">请参阅&lt;a href=&quot;autoinc&quot;&gt;SQLite AUTOINCREMENT文档&lt;/a&gt;以获取有关在SQLite中执行和不执行AUTOINCREMENT的详细说明。</target>
        </trans-unit>
        <trans-unit id="53b783989abda8014ea3d71299fadcaac3ac76a4" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;datatype3&quot;&gt;Datatypes in SQLite Version 3&lt;/a&gt; document for a detailed discussion of the type system in SQLite.</source>
          <target state="translated">有关&lt;a href=&quot;datatype3&quot;&gt;SQLite中&lt;/a&gt;类型系统的详细讨论，请参见SQLite Version 3文档中的数据类型。</target>
        </trans-unit>
        <trans-unit id="b929f22f98901beb9b1139bf55e5ff321f37875f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;howtocompile&quot;&gt;How To Compile SQLite&lt;/a&gt; document for instructions and hints on how to compile the program shown above.</source>
          <target state="translated">有关&lt;a href=&quot;howtocompile&quot;&gt;如何编译&lt;/a&gt;上面显示的程序的说明和提示，请参阅&amp;ldquo; 如何编译SQLite&amp;rdquo;文档。</target>
        </trans-unit>
        <trans-unit id="d23d8904a4dd8b2f59b61ec1f1d5eb8f80e47737" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; documentation for additional information on aspects of using SQLite in a multithreaded environment.</source>
          <target state="translated">有关在多线程环境中使用SQLite的其他信息，请参见&lt;a href=&quot;threadsafe&quot;&gt;线程模式&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="a87fd9fe2045f5442c46fbc8912602fdbac0e8ba" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">有关其他信息，请参见&lt;a href=&quot;threadsafe&quot;&gt;线程模式&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="30f1bf85315b67413bef1d018f3d407e1c5b8c20" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">有关其他信息，请参见&lt;a href=&quot;uri&quot;&gt;URI文件名&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="86902a781e00345ab7ead57f5c2f261448269986" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;vtablist&quot;&gt;list of virtual tables&lt;/a&gt; page for a longer list of actual virtual table implementations.</source>
          <target state="translated">有关实际虚拟表实现的详细&lt;a href=&quot;vtablist&quot;&gt;列表，&lt;/a&gt;请参见虚拟表列表页面。</target>
        </trans-unit>
        <trans-unit id="bd6efac597cb0708970fe4961b56a3edc46475fe" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;whentouse&quot;&gt;Appropriate Uses For SQLite&lt;/a&gt; document for additional information.</source>
          <target state="translated">有关其他信息，请参见&lt;a href=&quot;whentouse&quot;&gt;SQLite&lt;/a&gt;的适当用法。</target>
        </trans-unit>
        <trans-unit id="07ba693c1bca5dde244a27275e6109ebcc9602e4" translate="yes" xml:space="preserve">
          <source>See the separate &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt; documentation for the additional trailing syntax that can cause an INSERT to behave as an UPDATE if the INSERT would otherwise violate a uniqueness constraint. The &lt;a href=&quot;lang_upsert&quot;&gt;upsert clause&lt;/a&gt; is not allowed on an &quot;INSERT ... DEFAULT VALUES&quot;.</source>
          <target state="translated">有关其他尾随语法，请参阅单独的&lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt;文档，如果该INSERT否则会违反唯一性约束，则这些附加语法可能导致INSERT充当UPDATE。该&lt;a href=&quot;lang_upsert&quot;&gt;UPSERT条款&lt;/a&gt;不允许在一个&amp;ldquo;INSERT ...默认值&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="939683e9d52824a9f73508cf71bd83e60abff90a" translate="yes" xml:space="preserve">
          <source>See xPhraseFirst above.</source>
          <target state="translated">见上文xPhraseFirst。</target>
        </trans-unit>
        <trans-unit id="4a932238dbfaf0b21024ff5809159c0de781840d" translate="yes" xml:space="preserve">
          <source>See xPhraseFirstColumn above.</source>
          <target state="translated">见上文xPhraseFirstColumn。</target>
        </trans-unit>
        <trans-unit id="9f853fa8d7ff147b89090825d00dc78b2f44a321" translate="yes" xml:space="preserve">
          <source>SeekEnd</source>
          <target state="translated">SeekEnd</target>
        </trans-unit>
        <trans-unit id="9fadfc9b512132149df920b10f206da2333bd9fa" translate="yes" xml:space="preserve">
          <source>SeekGE</source>
          <target state="translated">SeekGE</target>
        </trans-unit>
        <trans-unit id="1087f36e7b18281af36dad7cdbb8cd08b7115d15" translate="yes" xml:space="preserve">
          <source>SeekGT</source>
          <target state="translated">SeekGT</target>
        </trans-unit>
        <trans-unit id="460ea4a32fd1274da2db98168e01568ac9ce63a6" translate="yes" xml:space="preserve">
          <source>SeekHit</source>
          <target state="translated">SeekHit</target>
        </trans-unit>
        <trans-unit id="0b4f0d008f842f314db6efb3fa8c1e4f9ad7e37b" translate="yes" xml:space="preserve">
          <source>SeekLE</source>
          <target state="translated">SeekLE</target>
        </trans-unit>
        <trans-unit id="5c9e6758b219b2706a95d7da88c60ef0eba6fe03" translate="yes" xml:space="preserve">
          <source>SeekLT</source>
          <target state="translated">SeekLT</target>
        </trans-unit>
        <trans-unit id="141e7ed653901b0f647fda720472fc6667150f0c" translate="yes" xml:space="preserve">
          <source>SeekRowid</source>
          <target state="translated">SeekRowid</target>
        </trans-unit>
        <trans-unit id="a6f10a001bc16f4e4dec6480df4d69d414ad8be5" translate="yes" xml:space="preserve">
          <source>SeekScan</source>
          <target state="translated">SeekScan</target>
        </trans-unit>
        <trans-unit id="c6ed6b18512dd3401d381c337b03a01488f90762" translate="yes" xml:space="preserve">
          <source>Segment B-Tree Interior Node Format</source>
          <target state="translated">B段树内部节点格式</target>
        </trans-unit>
        <trans-unit id="cc806c94f6fb1d331e8fb663d9d4f7e22793356b" translate="yes" xml:space="preserve">
          <source>Segment B-Tree Leaf Node Format</source>
          <target state="translated">B段树叶节点格式</target>
        </trans-unit>
        <trans-unit id="fe4aff672a9c860addca0cf569e240d57055e4c7" translate="yes" xml:space="preserve">
          <source>Segment b-trees are prefix-compressed b+-trees. There is one segment b-tree for each row in the %_segdir table (see above). The root node of the segment b-tree is stored as a blob in the &quot;root&quot; field of the corresponding row of the %_segdir table. All other nodes (if any exist) are stored in the &quot;blob&quot; column of the %_segments table. Nodes within the %_segments table are identified by the integer value in the blockid field of the corresponding row. The following table describes the fields of the %_segdir table:</source>
          <target state="translated">分段b树是前缀压缩的b+树。在%_segdir表中,每一行都有一个b段树(见上文)。分段b树的根节点以blob的形式存储在%_segdir表中相应行的 &quot;root &quot;字段中。所有其他的节点(如果有的话)都存储在%_segments表的 &quot;blob &quot;列中。%_segments表中的节点由相应行的blockid字段中的整数值来标识。下表描述了%_segdir表的字段。</target>
        </trans-unit>
        <trans-unit id="982d848bdbaf7ffda27f7d8aca752c82359ccf6f" translate="yes" xml:space="preserve">
          <source>Segment btree</source>
          <target state="translated">分段btree</target>
        </trans-unit>
        <trans-unit id="40bf8b12088788ad70716eb1793e4cf249c09782" translate="yes" xml:space="preserve">
          <source>Separate INTEGER and REAL affinity</source>
          <target state="translated">分开INTEGER和REAL亲和力。</target>
        </trans-unit>
        <trans-unit id="ba899678ef1e0fdd6b5eb799ee7abdd42cf175bf" translate="yes" xml:space="preserve">
          <source>Separating a database from its journal</source>
          <target state="translated">将数据库与其日志分离</target>
        </trans-unit>
        <trans-unit id="5c8f4e0e1a2281faf562976c2410f76c3d8fbc95" translate="yes" xml:space="preserve">
          <source>Sequence</source>
          <target state="translated">Sequence</target>
        </trans-unit>
        <trans-unit id="841936f1610c7b00e43fa53fbf75fb9b11abf32f" translate="yes" xml:space="preserve">
          <source>SequenceTest</source>
          <target state="translated">SequenceTest</target>
        </trans-unit>
        <trans-unit id="e12fccff7a8e896ad7cfa282736ffc4187cd7eaa" translate="yes" xml:space="preserve">
          <source>Serial Type</source>
          <target state="translated">串行类型</target>
        </trans-unit>
        <trans-unit id="307ffd15fed4aa8193a8701f2970a48ccbc74bb4" translate="yes" xml:space="preserve">
          <source>Serial Type Codes Of The Record Format</source>
          <target state="translated">记录格式的序列类型代码</target>
        </trans-unit>
        <trans-unit id="b61faef97a33774dc6199c619a4461fc18672af3" translate="yes" xml:space="preserve">
          <source>Serial type</source>
          <target state="translated">串行类型</target>
        </trans-unit>
        <trans-unit id="44bc81d8890afcfb324491bf1c0f95cb6563d3cc" translate="yes" xml:space="preserve">
          <source>Serialize a database</source>
          <target state="translated">序列化数据库</target>
        </trans-unit>
        <trans-unit id="90c4f08f792523112df74bc852026385bd4f8127" translate="yes" xml:space="preserve">
          <source>Session Object Handle</source>
          <target state="translated">会话对象句柄</target>
        </trans-unit>
        <trans-unit id="67e2e54aa75dbe4ba2529dc4e44d334d5c33427e" translate="yes" xml:space="preserve">
          <source>Session objects created using this function should be deleted using the &lt;a href=&quot;#sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt; function before the database handle that they are attached to is itself closed. If the database handle is closed before the session object is deleted, then the results of calling any session module function, including &lt;a href=&quot;#sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt; on the session object are undefined.</source>
          <target state="translated">使用此函数创建的会话对象应该在&lt;a href=&quot;#sqlite3session_delete&quot;&gt;关闭与其关联&lt;/a&gt;的数据库句柄之前使用sqlite3session_delete（）函数删除。如果在删除会话对象之前关闭数据库句柄，则未定义调用任何会话模块函数（包括会话对象上的&lt;a href=&quot;#sqlite3session_delete&quot;&gt;sqlite3session_delete（））&lt;/a&gt;的结果。</target>
        </trans-unit>
        <trans-unit id="36d7089db75a5bb06f2dd690097a4896b0ce0449" translate="yes" xml:space="preserve">
          <source>Session objects created using this function should be deleted using the &lt;a href=&quot;sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt; function before the database handle that they are attached to is itself closed. If the database handle is closed before the session object is deleted, then the results of calling any session module function, including &lt;a href=&quot;sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt; on the session object are undefined.</source>
          <target state="translated">使用此函数创建的会话对象应该在&lt;a href=&quot;sqlite3session_delete&quot;&gt;关闭与其关联&lt;/a&gt;的数据库句柄之前使用sqlite3session_delete（）函数删除。如果在删除会话对象之前关闭数据库句柄，则未定义调用任何会话模块函数（包括会话对象上的&lt;a href=&quot;sqlite3session_delete&quot;&gt;sqlite3session_delete（））&lt;/a&gt;的结果。</target>
        </trans-unit>
        <trans-unit id="ea1b131b3c13e62fbcb2b7e1d8113240624fdfe2" translate="yes" xml:space="preserve">
          <source>Session objects must be deleted before the database handle to which they are attached is closed. Refer to the documentation for &lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt; for details.</source>
          <target state="translated">在关闭会话对象所连接的数据库句柄之前，必须将其删除。有关详细信息，请参考&lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create（）&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="8a0df1e5a24e2b0c00b060a82e0a73f3246a4f51" translate="yes" xml:space="preserve">
          <source>Session objects must be deleted before the database handle to which they are attached is closed. Refer to the documentation for &lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt; for details.</source>
          <target state="translated">在关闭会话对象所连接的数据库句柄之前，必须将其删除。有关详细信息，请参考&lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create（）&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="6adb93a894674d02e091209977b242c152440ac9" translate="yes" xml:space="preserve">
          <source>Set *pnInst to the total number of occurrences of all phrases within the query within the current row. Return SQLITE_OK if successful, or an error code (i.e. SQLITE_NOMEM) if an error occurs.</source>
          <target state="translated">将*pnInst设置为当前行内查询中所有短语的总出现次数。如果查询成功,返回SQLITE_OK,如果出现错误,返回错误代码(即SQLITE_NOMEM)。</target>
        </trans-unit>
        <trans-unit id="efdec671fc0ce8bcb4bdb00d3f437085821cf12c" translate="yes" xml:space="preserve">
          <source>Set A Busy Timeout</source>
          <target state="translated">设置忙碌超时</target>
        </trans-unit>
        <trans-unit id="b1a0dded912756ecf2b97f232c897007421fbf5d" translate="yes" xml:space="preserve">
          <source>Set Or Clear the Indirect Change Flag</source>
          <target state="translated">设置或清除间接变化标志</target>
        </trans-unit>
        <trans-unit id="3a493136e0eeea58ea401cab071add271017a5ae" translate="yes" xml:space="preserve">
          <source>Set a table filter on a Session Object</source>
          <target state="translated">在会话对象上设置一个表格过滤器</target>
        </trans-unit>
        <trans-unit id="732b690730c3e6587386dab945ec7951b556c520" translate="yes" xml:space="preserve">
          <source>Set a table filter on a Session Object.</source>
          <target state="translated">在会话对象上设置表格过滤器。</target>
        </trans-unit>
        <trans-unit id="1ac264a53518ed313b058a0a099912f2a35d826a" translate="yes" xml:space="preserve">
          <source>Set an upper bound on the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt;,N) setting that determines the maximum number of auxiliary threads that a single &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; will use to aid with CPU-intensive computations (mostly sorting). See also the &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; options.</source>
          <target state="translated">在&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt;，N）设置上设置一个上限，该上限确定单个&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;将用于协助CPU密集型计算（主要是排序）的最大辅助线程数。另请参见&lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="92f46b19209e84ffdca742022b56dfdca2dfb583" translate="yes" xml:space="preserve">
          <source>Set register P1 to have the value NULL as seen by the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; instruction, but do not free any string or blob memory associated with the register, so that if the value was a string or blob that was previously copied using &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt;, the copies will continue to be valid.</source>
          <target state="translated">如&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;指令所示，将寄存器P1的值设置为NULL ，但不要释放与该寄存器关联的任何字符串或Blob内存，因此，如果该值是先前使用&lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt;复制的字符串或Blob，则复制将继续是有效的。</target>
        </trans-unit>
        <trans-unit id="cd7e5b09719a46bb1ffbc4c18faade6d76d5478d" translate="yes" xml:space="preserve">
          <source>Set the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag. This prevents ordinary SQL statements from deliberately corrupting the database file. SQLite should be proof against attacks that involve both malicious SQL inputs and a maliciously corrupted database file at the same time. Nevertheless, denying a script-only attacker access to corrupt database inputs provides an extra layer of defense.</source>
          <target state="translated">设置&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt;标志。这样可以防止普通的SQL语句故意损坏数据库文件。SQLite应该证明不会同时受到恶意SQL输入和恶意破坏的数据库文件的攻击。但是，拒绝仅脚本攻击者访问损坏的数据库输入可提供额外的防御层。</target>
        </trans-unit>
        <trans-unit id="241b76cbed3f5655045e8aff832d7f03205ef4fe" translate="yes" xml:space="preserve">
          <source>Set the Last Insert Rowid value</source>
          <target state="translated">设置最后插入的Rowid值</target>
        </trans-unit>
        <trans-unit id="3a9eaa4fc5302f500031c0b5a5700811aa0eb0fe" translate="yes" xml:space="preserve">
          <source>Set the Last Insert Rowid value.</source>
          <target state="translated">设置最后插入的Rowid值。</target>
        </trans-unit>
        <trans-unit id="5a5c894fd85a90ba517e62438c5aff9b40ab8cb2" translate="yes" xml:space="preserve">
          <source>Set the SQLITE_DBCONFIG_RESET_DATABASE flag and then run &lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; in order to reset a database back to an empty database with no schema and no content. The following process works even for a badly corrupted database file:</source>
          <target state="translated">设置SQLITE_DBCONFIG_RESET_DATABASE标志，然后运行&lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;以便将数据库重置回没有模式且没有内容的空数据库。以下过程甚至适用于严重损坏的数据库文件：</target>
        </trans-unit>
        <trans-unit id="5453fe3bee790f9b36f9a933f54e5899bdab502e" translate="yes" xml:space="preserve">
          <source>Set the SQLITE_DBCONFIG_RESET_DATABASE flag and then run &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; in order to reset a database back to an empty database with no schema and no content. The following process works even for a badly corrupted database file:</source>
          <target state="translated">设置SQLITE_DBCONFIG_RESET_DATABASE标志，然后运行&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;以便将数据库重置回没有模式且没有内容的空数据库。以下过程甚至适用于严重损坏的数据库文件：</target>
        </trans-unit>
        <trans-unit id="61c4c40f9a1bb5c18ccdd11c74e4b4fffa0d66f4" translate="yes" xml:space="preserve">
          <source>Set the database auto-commit flag to P1 (1 or 0). If P2 is true, roll back any currently active btree transactions. If there are any active VMs (apart from this one), then a ROLLBACK fails. A COMMIT fails if there are active writing VMs or active VMs that use shared cache.</source>
          <target state="translated">将数据库自动提交标志设置为P1(1或0)。如果P2为真,则回滚任何当前活动的btree事务。如果有任何活动的虚拟机(除了这个虚拟机),那么ROLLBACK失败。如果有活动的写虚拟机或使用共享缓存的活动虚拟机,则commit失败。</target>
        </trans-unit>
        <trans-unit id="d6cb86bbec6abe009ef2b13054a8bf71fb971e51" translate="yes" xml:space="preserve">
          <source>Set the default size limit (in bytes) for in-memory databases created using &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt;. This is just the default. The limit can be changed at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemdbmaxsize&quot;&gt;SQLITE_CONFIG_MEMDB_MAXSIZE&lt;/a&gt;,N) or at run-time for individual databases using the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;file-control&lt;/a&gt;. If no default is specified, 1073741824 is used.</source>
          <target state="translated">设置使用&lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize（）&lt;/a&gt;创建的内存数据库的默认大小限制（以字节为单位）。这只是默认设置。可以在开始时使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemdbmaxsize&quot;&gt;SQLITE_CONFIG_MEMDB_MAXSIZE&lt;/a&gt;，N）更改限制，也可以在运行时使用&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT &lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;文件控件&lt;/a&gt;为单个数据库更改限制。如果未指定默认值，则使用1073741824。</target>
        </trans-unit>
        <trans-unit id="866d8eaf3728a827f036375926469bd93bf88bea" translate="yes" xml:space="preserve">
          <source>Set the permutation used by the &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; operator in the next instruction. The permutation is stored in the P4 operand.</source>
          <target state="translated">设置使用的置换&lt;a href=&quot;opcode#Compare&quot;&gt;比较&lt;/a&gt;中的下一个指令操作。排列存储在P4操作数中。</target>
        </trans-unit>
        <trans-unit id="ffc497dd2e0254996f63fed1801e825a18a0d70e" translate="yes" xml:space="preserve">
          <source>Set the seekHit flag on cursor P1 to the value in P2. The seekHit flag is used by the &lt;a href=&quot;opcode#IfNoHope&quot;&gt;IfNoHope&lt;/a&gt; opcode.</source>
          <target state="translated">将光标P1上的seekHit标志设置为P2中的值。seekHit标志由&lt;a href=&quot;opcode#IfNoHope&quot;&gt;IfNoHope&lt;/a&gt;操作码使用。</target>
        </trans-unit>
        <trans-unit id="f917c903736a886e2bae7dda91eb93f9fc5b88f2" translate="yes" xml:space="preserve">
          <source>Set up a process-wide &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt;.</source>
          <target state="translated">设置整个过程的&lt;a href=&quot;errlog&quot;&gt;错误日志&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f899229bce65615b9a9aafe730afb3055fc1d664" translate="yes" xml:space="preserve">
          <source>Set up register P1 so that it will &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt; to the coroutine located at address P3.</source>
          <target state="translated">设置寄存器P1使之&lt;a href=&quot;opcode#Yield&quot;&gt;屈服&lt;/a&gt;到位于地址P3的协同程序。</target>
        </trans-unit>
        <trans-unit id="c422fe10a5573aa6ba7e50d9c77e20ca08878af0" translate="yes" xml:space="preserve">
          <source>SetCookie</source>
          <target state="translated">SetCookie</target>
        </trans-unit>
        <trans-unit id="01b3682b02999bc0d6273ad2e8a1ce7b60079442" translate="yes" xml:space="preserve">
          <source>Sets the &quot;fired&quot; flag to true.</source>
          <target state="translated">将 &quot;fire &quot;标志设置为 &quot;true&quot;。</target>
        </trans-unit>
        <trans-unit id="5f1906e535428a6ef107759522f33ae96d47ce23" translate="yes" xml:space="preserve">
          <source>Sets the default size of the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; memory pool to N entries of SZ bytes each. This setting can be modified at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt;) and/or as each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is opened using &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db, &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;SQLITE_DBCONFIG_LOOKASIDE&lt;/a&gt;).</source>
          <target state="translated">将&lt;a href=&quot;malloc#lookaside&quot;&gt;后备内存分配器&lt;/a&gt;内存池的默认大小设置为每个SZ字节N个条目。可以在启动时使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt;）和/或在使用&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;SQLITE_DBCONFIG_LOOKASIDE&lt;/a&gt;）打开每个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;时修改此设置。</target>
        </trans-unit>
        <trans-unit id="f8f949c67297579c935535017d3f831289e19ac6" translate="yes" xml:space="preserve">
          <source>Setting &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; can cause the database to go corrupt if there is an operating-system crash or power failure, though this setting is safe from damage due to application crashes.</source>
          <target state="translated">如果存在操作系统崩溃或电源故障，则将&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt;设置为OFF会导致数据库损坏，尽管此设置可以防止由于应用程序崩溃而损坏。</target>
        </trans-unit>
        <trans-unit id="aefdd1b85748c7d4a0d551399e2edc72cd30afa6" translate="yes" xml:space="preserve">
          <source>Setting &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; and then changing the database schema using DML statements can render the database completely unreadable, if not done carefully.</source>
          <target state="translated">设置&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = ON&lt;/a&gt;，然后使用DML语句更改数据库模式可能会使数据库完全不可读，即使不小心的话。</target>
        </trans-unit>
        <trans-unit id="3fa000f3c0976d971f291c1208857c79532870ca" translate="yes" xml:space="preserve">
          <source>Setting The Result Of An SQL Function</source>
          <target state="translated">设置SQL函数的结果</target>
        </trans-unit>
        <trans-unit id="1d4603c6597b76da3d906d68cccdecf5180cbe08" translate="yes" xml:space="preserve">
          <source>Setting The Subtype Of An SQL Function</source>
          <target state="translated">设置一个SQL函数的子类型</target>
        </trans-unit>
        <trans-unit id="16955fa7b436cf8874edb738f171a4d0ef509182" translate="yes" xml:space="preserve">
          <source>Setting fullfsync on a Mac will guarantee that data really does get pushed out to the disk platter on a flush. But the implementation of fullfsync involves resetting the disk controller. And so not only is it profoundly slow, it also slows down other unrelated disk I/O. So its use is not recommended.</source>
          <target state="translated">在Mac上设置fullfsync,可以保证数据真的会在刷新时被推送到磁盘盘片上。但是实现fullfsync需要重新设置磁盘控制器。所以不仅速度极慢,还会拖慢其他无关的磁盘I/O。所以不建议使用它。</target>
        </trans-unit>
        <trans-unit id="3eaa36d1b6e824ce1fa2d9dd603bd95da85fa485" translate="yes" xml:space="preserve">
          <source>Setting the automerge parameter to a non-zero value enables automatic incremental merging. This causes SQLite to do a small amount of inverted index merging after every INSERT operation. The amount of merging performed is designed so that the FTS3/4 table never reaches a point where it has 16 segments at the same level and hence has to do a large merge in order to complete an insert. In other words, automatic incremental merging is designed to prevent spiky INSERT performance.</source>
          <target state="translated">将automerge参数设置为非零值,可以实现自动增量合并。这使得SQLite在每次INSERT操作后都会进行少量的反向索引合并。执行的合并量被设计为使FTS3/4表永远不会达到在同一层次上有16个段的地步,因此必须进行大量的合并才能完成一次插入操作。换句话说,自动增量合并的设计是为了防止insert性能出现尖峰。</target>
        </trans-unit>
        <trans-unit id="56f5ba775f4860afdbeef1efdf08d68cd3228bad" translate="yes" xml:space="preserve">
          <source>Setting the heap limits to zero disables the heap limiter mechanism.</source>
          <target state="translated">将堆限制设置为零,可以禁用堆限制器机制。</target>
        </trans-unit>
        <trans-unit id="d964c814943dd4cc633ef0ee8d21d48eb3735ca0" translate="yes" xml:space="preserve">
          <source>Setting this compile-time option prevents SQLite from being fully testable. Branch test coverage drops from 100% down to about 95%.</source>
          <target state="translated">设置这个编译时选项,会使SQLite无法完全测试。分支测试覆盖率从100%下降到95%左右。</target>
        </trans-unit>
        <trans-unit id="00f0e8d6420ed50a38c6973317964bc318233512" translate="yes" xml:space="preserve">
          <source>Several new C-level objects are used by the virtual table implementation:</source>
          <target state="translated">虚拟表的实现使用了几个新的C级对象。</target>
        </trans-unit>
        <trans-unit id="1b7d1cf980e975f4a1d8be50f6af0bb46a6caa32" translate="yes" xml:space="preserve">
          <source>Several obscure, unrelated bugs were found and fixed while implemented the integer primary key change of the previous bullet.</source>
          <target state="translated">在实现上一弹的整数主键变化时,发现并修复了几个不明显、不相关的bug。</target>
        </trans-unit>
        <trans-unit id="659f95a669a94f909d4f9c9e95d9d907e1cbadfa" translate="yes" xml:space="preserve">
          <source>Shadow tables are read/write by default. Shadow tables only become read-only when the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag is set using &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt;. Shadow tables need to be read/write by default in order to maintain backwards compatibility. For example, the SQL text generated by the &lt;a href=&quot;cli#dump&quot;&gt;.dump&lt;/a&gt; command of the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; writes directly into shadow tables.</source>
          <target state="translated">影子表默认为读/写。仅当使用&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;设置&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt;标志时，影子表才变为只读。默认情况下，影子表需要读取/写入，以保持向后兼容性。例如，由&lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;的&lt;a href=&quot;cli#dump&quot;&gt;.dump&lt;/a&gt;命令生成的SQL文本直接写入影子表。</target>
        </trans-unit>
        <trans-unit id="19452421c69c545e0b50fcc00a18251f53c4e9f4" translate="yes" xml:space="preserve">
          <source>Shared cache is disabled by default. But this might change in future releases of SQLite. Applications that care about shared cache setting should set it explicitly.</source>
          <target state="translated">默认情况下,共享缓存是被禁用的。但在未来的SQLite版本中可能会改变。关心共享缓存设置的应用程序应该明确地设置它。</target>
        </trans-unit>
        <trans-unit id="8e41d50ebd1af2b3254810c6333341257c85989e" translate="yes" xml:space="preserve">
          <source>Shared cache is disabled by default. It is recommended that it stay that way. In other words, do not use this routine. This interface continues to be provided for historical compatibility, but its use is discouraged. Any use of shared cache is discouraged. If shared cache must be used, it is recommended that shared cache only be enabled for individual database connections using the &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface with the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; flag.</source>
          <target state="translated">默认情况下禁用共享缓存。建议保持这种状态。换句话说，不要使用此例程。继续提供此接口是为了实现历史兼容性，但不建议使用此接口。不鼓励使用共享缓存。如果必须使用共享缓存，建议仅使用带有&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;标志的&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;接口为单个数据库连接启用共享缓存。</target>
        </trans-unit>
        <trans-unit id="016f63b1afdc35c75766700d01c855e2a30457a4" translate="yes" xml:space="preserve">
          <source>Shared cache is disabled by default. It is recommended that it stay that way. In other words, do not use this routine. This interface continues to be provided for historical compatibility, but its use is discouraged. Any use of shared cache is discouraged. If shared cache must be used, it is recommended that shared cache only be enabled for individual database connections using the &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface with the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; flag.</source>
          <target state="translated">默认情况下禁用共享缓存。建议保持这种状态。换句话说，不要使用此例程。继续提供此接口是为了实现历史兼容性，但不建议使用此接口。不鼓励使用共享缓存。如果必须使用共享缓存，建议仅使用带有&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;标志的&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;接口为单个数据库连接启用共享缓存。</target>
        </trans-unit>
        <trans-unit id="f477f800bdd5ba8c256608dea929d26bc988f65b" translate="yes" xml:space="preserve">
          <source>Shared libraries or DLLs can be used as &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt; to SQLite.</source>
          <target state="translated">共享库或DLL可用作SQLite的&lt;a href=&quot;loadext&quot;&gt;可加载扩展&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6f715dc89839324b877f33d62ebb39393f6ca50" translate="yes" xml:space="preserve">
          <source>Shared-cache locks are released when a database connection concludes its current transaction, either by committing it or rolling it back.</source>
          <target state="translated">当数据库连接结束其当前事务时,共享缓存锁就会被释放,无论是通过提交还是回滚。</target>
        </trans-unit>
        <trans-unit id="1a3aca3d24b83cc38a4313e0315e88bcb9c21c92" translate="yes" xml:space="preserve">
          <source>Shared-cache mode changes the semantics of the locking model in some cases. The details are described by this document. A basic understanding of the normal SQLite locking model (see &lt;a href=&quot;lockingv3&quot;&gt;File Locking And Concurrency In SQLite Version 3&lt;/a&gt; for details) is assumed.</source>
          <target state="translated">在某些情况下，共享缓存模式会更改锁定模型的语义。本文档介绍了详细信息。假定对基本的SQLite锁定模型有基本的了解（有关详细信息，请参见&lt;a href=&quot;lockingv3&quot;&gt;SQLite版本3中的文件锁定和并发&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0a3f80e6eca574b532dbb5d0c3d9a7766e7bf84a" translate="yes" xml:space="preserve">
          <source>Shared-cache mode is enabled on a per-process basis. Using the C interface, the following API can be used to globally enable or disable shared-cache mode:</source>
          <target state="translated">共享缓存模式是在每个进程的基础上启用的。使用C接口,可以使用以下API来全局启用或禁用共享缓存模式。</target>
        </trans-unit>
        <trans-unit id="f42662308d376fb67628511d59d090985566d2ae" translate="yes" xml:space="preserve">
          <source>Shared-memory files</source>
          <target state="translated">共享内存文件</target>
        </trans-unit>
        <trans-unit id="c7114e495e770e3a02bbb164bf55e1f96da4aecc" translate="yes" xml:space="preserve">
          <source>Shift the integer value in register P2 to the left by the number of bits specified by the integer in register P1. Store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">将寄存器P2中的整数值向左移位,移位的位数由寄存器P1中的整数指定。将结果存储在寄存器P3中,如果任一输入为NULL,则结果为NULL。如果任一输入为NULL,则结果为NULL。</target>
        </trans-unit>
        <trans-unit id="1886429e3c21f6dfa5e69e0091250e86426fb4f9" translate="yes" xml:space="preserve">
          <source>Shift the integer value in register P2 to the right by the number of bits specified by the integer in register P1. Store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">将寄存器P2中的整数值向右移位,移位的位数由寄存器P1中的整数指定。将结果存储在寄存器P3中,如果任一输入为NULL,则结果为NULL。如果任一输入为NULL,则结果为NULL。</target>
        </trans-unit>
        <trans-unit id="62341f589b9d3a0d923d18a2b4e7f7f2edda894e" translate="yes" xml:space="preserve">
          <source>ShiftLeft</source>
          <target state="translated">ShiftLeft</target>
        </trans-unit>
        <trans-unit id="2310b475647d9a4e74a4f5d5a47bfb27340ee08b" translate="yes" xml:space="preserve">
          <source>ShiftRight</source>
          <target state="translated">ShiftRight</target>
        </trans-unit>
        <trans-unit id="c8723bf8dd0f924a9f0d00bc2ddb22a9562a76b1" translate="yes" xml:space="preserve">
          <source>Shifting a negative number.</source>
          <target state="translated">移动一个负数。</target>
        </trans-unit>
        <trans-unit id="8f0ca083402d5eb462b696e15e581aaadbeb113a" translate="yes" xml:space="preserve">
          <source>Shifting an N-bit integer by more than N bits.</source>
          <target state="translated">将一个N位整数移位超过N位。</target>
        </trans-unit>
        <trans-unit id="37dcc04149816924636682bd712a1a49f1dcb38f" translate="yes" xml:space="preserve">
          <source>Shifting by a negative amount.</source>
          <target state="translated">以负数移动。</target>
        </trans-unit>
        <trans-unit id="d224675e61816beeffff3a83b33b759da2cf9109" translate="yes" xml:space="preserve">
          <source>Short answer: A column declared &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; will autoincrement.</source>
          <target state="translated">简短答案：声明为&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY的&lt;/a&gt;列将自动递增。</target>
        </trans-unit>
        <trans-unit id="66f7bc664b9d82f0b84142732a02328bc0cdf8d0" translate="yes" xml:space="preserve">
          <source>Show ASCII-art abstract syntax tree diagrams using the &quot;.selecttrace&quot; and &quot;.wheretrace&quot; commands in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; when compiled with &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;, SQLITE_ENABLE_SELECTTRACE, and SQLITE_ENABLE_WHERETRACE. Also provide the sqlite3TreeViewExpr() and sqlite3TreeViewSelect() entry points that can be invoked from with the debugger to show the parse tree when stopped at a breakpoint.</source>
          <target state="translated">在使用&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;，SQLITE_ENABLE_SELECTTRACE和SQLITE_ENABLE_WHERETRACE 编译时，在&lt;a href=&quot;cli&quot;&gt;命令行外壳中&lt;/a&gt;使用&amp;ldquo; .selecttrace&amp;rdquo;和&amp;ldquo; .wheretrace&amp;rdquo;命令显示ASCII艺术抽象语法树图。还提供sqlite3TreeViewExpr（）和sqlite3TreeViewSelect（）入口点，可以在调试器处从其调用它们，以显示在断点处停止时的解析树。</target>
        </trans-unit>
        <trans-unit id="29bd1b65a367359ac801580f0f164ea797beea79" translate="yes" xml:space="preserve">
          <source>Show how many rows have changed on each table, but do not show the actual changes</source>
          <target state="translated">显示每个表中有多少行发生了变化,但不显示实际变化。</target>
        </trans-unit>
        <trans-unit id="45c704a81c82ee8bb0729ae9984ab0b0befba88f" translate="yes" xml:space="preserve">
          <source>Show me your flowcharts and conceal your tables, and I shall continue to be mystified. Show me your tables, and I won't usually need your flowcharts; they'll be obvious.</source>
          <target state="translated">给我看你的流程图,把你的表格藏起来,我就会继续感到神秘。给我看你的表格,我通常就不需要你的流程图了,它们会很明显。</target>
        </trans-unit>
        <trans-unit id="eadcf1db0ff39fb6bc0246ade4beb9b3e9027520" translate="yes" xml:space="preserve">
          <source>Show only differences in the schema not the table content</source>
          <target state="translated">只显示模式中的差异,不显示表的内容。</target>
        </trans-unit>
        <trans-unit id="584527d924d04a23c5c08d9fd085c97f73f6da07" translate="yes" xml:space="preserve">
          <source>Show only the differences in content for TABLE, not for the entire database</source>
          <target state="translated">只显示TABLE的内容差异,不显示整个数据库的内容差异。</target>
        </trans-unit>
        <trans-unit id="c2688d3833edc37bfcee14b5515c2bff49005d0c" translate="yes" xml:space="preserve">
          <source>Show the SQL that would be run to carry out the archive operation, but do not actually change anything.</source>
          <target state="translated">显示将运行的SQL来进行归档操作,但实际上并没有改变任何东西。</target>
        </trans-unit>
        <trans-unit id="f2d6599ba5b081fd8b2869046769b3cd08250edc" translate="yes" xml:space="preserve">
          <source>Shun arrogance.</source>
          <target state="translated">顺从傲慢。</target>
        </trans-unit>
        <trans-unit id="df3f4b6cc3b45148ff40b29aba7af47fbd10c1fd" translate="yes" xml:space="preserve">
          <source>Signed integer overflow. (Signed integer overflow does &lt;u&gt;not&lt;/u&gt; necessarily wrap around, as most people expect.)</source>
          <target state="translated">有符号整数溢出。（签名整数溢出并&lt;u&gt;没有&lt;/u&gt;必然环绕，因为大多数人的期待。）</target>
        </trans-unit>
        <trans-unit id="2e226f8ddc66c1a463dcf0a7c345c529980f966b" translate="yes" xml:space="preserve">
          <source>Silent &quot;d&quot; in words beginning with &quot;dj&quot;: djinn, Djikarta</source>
          <target state="translated">以 &quot;dj &quot;开头的词中无声的 &quot;d&quot;:djinn、Djikarta。</target>
        </trans-unit>
        <trans-unit id="aada0dd0ffeee0e21804c55732d58986c7fd3694" translate="yes" xml:space="preserve">
          <source>Silent &quot;g&quot; in words beginning with &quot;gn&quot;: gnarly, gnome, gnat</source>
          <target state="translated">以 &quot;gn &quot;开头的单词中的 &quot;g&quot;:gnarly、gnome、gnat。</target>
        </trans-unit>
        <trans-unit id="fbaa2ec88597d6e84d9f667ee669d561de7dec36" translate="yes" xml:space="preserve">
          <source>Silent &quot;k&quot; in words beginning with &quot;kn&quot;: knight, Knuthson</source>
          <target state="translated">以 &quot;kn &quot;开头的单词中的无声 &quot;k&quot;:knight,Knuthson。</target>
        </trans-unit>
        <trans-unit id="0f8ddc119a87ce25d1a07a2270fa7ab759fe3699" translate="yes" xml:space="preserve">
          <source>Silent &quot;p&quot; in words beginning with &quot;pn&quot;: pneumonia, pneumatic</source>
          <target state="translated">以 &quot;pn &quot;开头的词中无声的 &quot;p&quot;:pneumonia,气动的。</target>
        </trans-unit>
        <trans-unit id="9fea8d13746b11fa947fbc609fcc6f58d06a7902" translate="yes" xml:space="preserve">
          <source>Silent &quot;p&quot; in words beginning with &quot;ps&quot;: psalm, psyche</source>
          <target state="translated">以 &quot;ps &quot;开头的词中无声的 &quot;p&quot;:psalm,psyche。</target>
        </trans-unit>
        <trans-unit id="f17200036eeba29904ebeaabba7f7630872e60fd" translate="yes" xml:space="preserve">
          <source>Silent &quot;p&quot; in words beginning with &quot;pt&quot;: pterodactyl, ptolemaic</source>
          <target state="translated">以 &quot;pt &quot;开头的词中无声的 &quot;p&quot;:翼手龙、托勒密语</target>
        </trans-unit>
        <trans-unit id="9d3bc03d8343d400c82a4a71a8abb03ff87c2249" translate="yes" xml:space="preserve">
          <source>Similarly, SQLite allows you to store a 2000-character string into a column of type VARCHAR(50). Other SQL implementations would either throw an error or truncate the string. SQLite stores the entire 2000-character string with no loss of information and without complaint.</source>
          <target state="translated">同样,SQLite允许你将一个2000个字符的字符串存储到一个类型为VARCHAR(50)的列中。其他的SQL实现要么会抛出一个错误,要么会截断这个字符串。SQLite存储了整个2000个字符的字符串,没有任何信息损失,而且毫无怨言。</target>
        </trans-unit>
        <trans-unit id="8b91c3fa499f0d4214317846c7c43d756cfd2b0a" translate="yes" xml:space="preserve">
          <source>Similarly, a</source>
          <target state="translated">同样,a</target>
        </trans-unit>
        <trans-unit id="5bca9444f10a42e6ae3d406bbcd7ca872ce4cd02" translate="yes" xml:space="preserve">
          <source>Similarly, in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, the write-ahead log file is not truncated following a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;. Instead, SQLite reuses the existing file for subsequent WAL entries since overwriting is faster than appending.</source>
          <target state="translated">类似地，在&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;，预写日志文件不会在&lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint之后&lt;/a&gt;被截断。相反，由于重写比附加操作快，因此SQLite会将现有文件重用于后续的WAL条目。</target>
        </trans-unit>
        <trans-unit id="bac336a356dc6f108086c2da32cf914ab388438e" translate="yes" xml:space="preserve">
          <source>Similarly, streaming API functions that return changesets (or patchsets) return them in chunks by way of a callback function instead of via a pointer to a single large buffer. In this case, a pair of parameters such as:</source>
          <target state="translated">同样,返回变化集(或补丁集)的流式API函数通过回调函数的方式而不是通过指向一个大缓冲区的指针来分块返回。在这种情况下,一对参数,如。</target>
        </trans-unit>
        <trans-unit id="7d579b15000cacebe667c23c91900124e0021ffe" translate="yes" xml:space="preserve">
          <source>Similarly, the following expressions have historically evaluated to TRUE when in fact NULL is also the correct answer here:</source>
          <target state="translated">类似地,下面的表达式历来被评价为 &quot;true&quot;,而实际上这里的正确答案也是NULL。</target>
        </trans-unit>
        <trans-unit id="8de10619f1c2dbf3cc29b124beee52534207f387" translate="yes" xml:space="preserve">
          <source>Simple Queries</source>
          <target state="translated">简单查询</target>
        </trans-unit>
        <trans-unit id="c820f89b614c85cd10dd51d0186cb9a23cd537b4" translate="yes" xml:space="preserve">
          <source>Simple SELECT</source>
          <target state="translated">简单的SELECT</target>
        </trans-unit>
        <trans-unit id="2b5e01ecfaf01cf9d6fed2afce17a1e2ec85faaa" translate="yes" xml:space="preserve">
          <source>Simple Select Processing</source>
          <target state="translated">简单的选择处理</target>
        </trans-unit>
        <trans-unit id="25bc3effd8fab2177bf75bccfaba476dd31d7e03" translate="yes" xml:space="preserve">
          <source>Simple fts queries</source>
          <target state="translated">简单的fts查询</target>
        </trans-unit>
        <trans-unit id="d21c97069116b510ca5fd5d37452e567c518b5ee" translate="yes" xml:space="preserve">
          <source>Simple, easy to use &lt;a href=&quot;cintro&quot;&gt;API&lt;/a&gt;.</source>
          <target state="translated">简单易用的&lt;a href=&quot;cintro&quot;&gt;API&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="20a696ed001fc7792dc03669a107ef6867be06cf" translate="yes" xml:space="preserve">
          <source>Simplified Application Development</source>
          <target state="translated">简化应用开发</target>
        </trans-unit>
        <trans-unit id="75e092657cf7286e756d1dede51480e5230b9edf" translate="yes" xml:space="preserve">
          <source>Simplify the design of the VDBE by restricting the number of sorters and lists to 1. In practice, no more than one sorter and one list was ever used anyhow.</source>
          <target state="translated">简化VDBE的设计,将分拣器和列表的数量限制为1,实际上,无论如何都不会使用超过一个分拣器和一个列表。</target>
        </trans-unit>
        <trans-unit id="89151b192ec38384818e48383b1951487fe9cb56" translate="yes" xml:space="preserve">
          <source>Simply replace</source>
          <target state="translated">只需更换</target>
        </trans-unit>
        <trans-unit id="de0928c2b632719ec80087729ff90db61c097100" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://sqlite.org/releaselog/3_13_0.html&quot;&gt;version 3.13.0&lt;/a&gt; (2016-05-18), the session extension has been included in the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; source distribution. By default, the session extension is disabled. To enable it, build with the following compiler switches:</source>
          <target state="translated">自&lt;a href=&quot;https://sqlite.org/releaselog/3_13_0.html&quot;&gt;版本3.13.0&lt;/a&gt;（2016-05-18）起，会话扩展已包含在SQLite &lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;源分发中。默认情况下，会话扩展是禁用的。要启用它，请使用以下编译器开关进行构建：</target>
        </trans-unit>
        <trans-unit id="eaa37de22579abc7084228906dd483ab965aacfb" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04), SQLite has supported an interface called the &lt;a href=&quot;c3ref/vfs&quot;&gt;virtual file system&lt;/a&gt; or &quot;VFS&quot;. This object is somewhat misnamed since it is really an interface to the whole underlying operating system, not just the filesystem.</source>
          <target state="translated">从&lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;版本3.5.0&lt;/a&gt;（2007-09-04）开始，SQLite支持一种称为&lt;a href=&quot;c3ref/vfs&quot;&gt;虚拟文件系统&lt;/a&gt;或&amp;ldquo; VFS&amp;rdquo; 的接口。这个对象的名称有些错误，因为它实际上是整个底层操作系统的接口，而不仅仅是文件系统。</target>
        </trans-unit>
        <trans-unit id="c659e6cde59a26a5cc98604eaf1a60217b6d7297" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;version 3.6.18&lt;/a&gt; (2009-09-11), SQLite source code has been stored in the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil configuration management system&lt;/a&gt;. The SQLITE_SOURCE_ID macro evaluates to a string which identifies a particular check-in of SQLite within its configuration management system. The SQLITE_SOURCE_ID string contains the date and time of the check-in (UTC) and a SHA1 or SHA3-256 hash of the entire source tree. If the source code has been edited in any way since it was last checked in, then the last four hexadecimal digits of the hash may be modified.</source>
          <target state="translated">从&lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;3.6.18版&lt;/a&gt;（2009-09-11）开始，SQLite源代码已存储在&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil配置管理系统中&lt;/a&gt;。 SQLITE_SOURCE_ID宏计算得出一个字符串，该字符串标识SQLite在其配置管理系统中的特定签入。 SQLITE_SOURCE_ID字符串包含签入（UTC）的日期和时间以及整个源树的SHA1或SHA3-256哈希。如果自从上次签入以来已对源代码进行了任何编辑，则可以修改哈希的最后四个十六进制数字。</target>
        </trans-unit>
        <trans-unit id="bde8c10aa2c3a82fb7235b00f685cbcc6334e9b8" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;version 3.6.18&lt;/a&gt; (2009-09-11), SQLite source code has been stored in the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil configuration management system&lt;/a&gt;. The SQLITE_SOURCE_ID macro evaluates to a string which identifies a particular check-in of SQLite within its configuration management system. The SQLITE_SOURCE_ID string contains the date and time of the check-in (UTC) and a SHA1 or SHA3-256 hash of the entire source tree. If the source code has been edited in any way since it was last checked in, then the last four hexadecimal digits of the hash may be modified.</source>
          <target state="translated">从&lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;3.6.18版&lt;/a&gt;（2009-09-11）开始，SQLite源代码已存储在&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil配置管理系统中&lt;/a&gt;。 SQLITE_SOURCE_ID宏评估为一个字符串，该字符串标识SQLite在其配置管理系统中的特定签入。 SQLITE_SOURCE_ID字符串包含签入（UTC）的日期和时间以及整个源树的SHA1或SHA3-256哈希。如果自从上次签入以来已对源代码进行了任何编辑，则可以修改哈希的最后四个十六进制数字。</target>
        </trans-unit>
        <trans-unit id="6ef82de3319be0d75e458ab4416694f2f8299790" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21), SQLite also supports &quot;&lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;&quot;. In WAL mode, changes are not written to the original database file. Instead, changes go into a separate &quot;write-ahead log&quot; or &quot;WAL&quot; file. Later, after the transaction commits, those changes will be moved from the WAL file back into the original database in an operation called &quot;checkpoint&quot;. WAL mode is enabled by running &quot;&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=WAL&lt;/a&gt;&quot;.</source>
          <target state="translated">从&lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;版本3.7.0&lt;/a&gt;（2010-07-21）开始，SQLite还支持&amp;ldquo; &lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt; &amp;rdquo;。在WAL模式下，更改不会写入原始数据库文件。而是将更改保存到单独的&amp;ldquo;预写日志&amp;rdquo;或&amp;ldquo; WAL&amp;rdquo;文件中。稍后，在提交事务之后，这些更改将通过称为&amp;ldquo;检查点&amp;rdquo;的操作从WAL文件移回到原始数据库中。通过运行&amp;ldquo; &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = WAL&lt;/a&gt; &amp;rdquo; 来启用WAL模式。</target>
        </trans-unit>
        <trans-unit id="974a12d011bbc97d586f22e505d00eff41958058" translate="yes" xml:space="preserve">
          <source>Since SQLite always interprets any filename that does not begin with &quot;&lt;code&gt;file:&lt;/code&gt;&quot; as an ordinary filename regardless of the URI setting, and because it is very unusual to have an actual file begin with &quot;&lt;code&gt;file:&lt;/code&gt;&quot;, it is safe for most applications to enable URI processing even if URI filenames are not currently being used.</source>
          <target state="translated">由于SQLite始终将不以&amp;ldquo; &lt;code&gt;file:&lt;/code&gt; &amp;rdquo; 开头的任何文件名都解释为普通文件名，而不管URI设置如何，并且因为以&amp;ldquo; &lt;code&gt;file:&lt;/code&gt; &amp;rdquo; 开头的实际文件是非常不寻常的，所以对于大多数应用程序来说，这样做是安全的即使当前未使用URI文件名，也可以启用URI处理。</target>
        </trans-unit>
        <trans-unit id="6787bde414a9d9d049df11f55e9b93b41be95c03" translate="yes" xml:space="preserve">
          <source>Since SQLite databases are ordinary disk files, any malfunction in the filesystem can corrupt the database. Filesystems in modern operating systems are very reliable, but errors do still occur. For example, on 2013-10-01 the SQLite database that holds the &lt;a href=&quot;http://wiki.tcl-lang.org/&quot;&gt;Wiki for Tcl/Tk&lt;/a&gt; went corrupt a few days after the host computer was moved to a dodgy build of the (linux) kernel that had issues in the filesystem layer. In that event, the filesystem eventually became so badly corrupted that the machine was unusable, but the earliest symptom of trouble was the corrupted SQLite database.</source>
          <target state="translated">由于SQLite数据库是普通磁盘文件，因此文件系统中的任何故障都可能损坏数据库。现代操作系统中的文件系统非常可靠，但是仍然会发生错误。例如，2013年10月1日，在将主机移动到文件系统有问题的（linux）内核的狡猾版本之后几天，保存&lt;a href=&quot;http://wiki.tcl-lang.org/&quot;&gt;Tcl / Tk Wiki&lt;/a&gt;的SQLite数据库损坏。在那种情况下，文件系统最终会变得严重损坏，以致该机器无法使用，但是最早的故障症状是损坏的SQLite数据库。</target>
        </trans-unit>
        <trans-unit id="c695a2f51c4b24da3c2784ee7cd9c9755809b7df" translate="yes" xml:space="preserve">
          <source>Since SQLite reads and writes an ordinary disk file, the only access permissions that can be applied are the normal file access permissions of the underlying operating system. The GRANT and REVOKE commands commonly found on client/server RDBMSes are not implemented because they would be meaningless for an embedded database engine.</source>
          <target state="translated">由于SQLite读写的是普通的磁盘文件,所以唯一可以应用的访问权限是底层操作系统的普通文件访问权限。客户端/服务器RDBMSes上常见的GRANT和REVOKE命令没有实现,因为它们对于嵌入式数据库引擎来说毫无意义。</target>
        </trans-unit>
        <trans-unit id="59abdbce3144e8f85a07a8dfceb62a241d9b0167" translate="yes" xml:space="preserve">
          <source>Since an SQLite database is a more general format (it is designed to do much more than simply store a bunch of files) it is not as compact as either the ZIP Archive or Tarball formats. An SQLite Archive is usually about 1% larger than the equivalent ZIP Archive. Tarballs are compressed as a single unit rather than compressing each file separately as is done by both SQLite and ZIP Archives. For these reason, Tarballs tend to be smaller than either ZIP or SQLite Archives.</source>
          <target state="translated">由于SQLite数据库是一种更通用的格式(它的设计目的不仅仅是存储一堆文件),它不如ZIP Archive或Tarball格式紧凑。一个SQLite存档通常比同等的ZIP存档大1%。Tarballs被压缩为一个单一的单元,而不是像SQLite和ZIP Archive那样分别压缩每个文件。由于这些原因,Tarballs往往比ZIP或SQLite存档小。</target>
        </trans-unit>
        <trans-unit id="4194b98c5f98c8eb76bc03b04a9e6fbf66db418a" translate="yes" xml:space="preserve">
          <source>Since database zFilename is a file on disk, then it may be accessed externally by another process. This means that when the call to sqlite3_backup_step() attempts to read from or write data to it, it may fail to obtain the required file lock. If this happens, this implementation will fail, returning SQLITE_BUSY immediately. The solution would be to register a busy-handler callback or timeout with &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; pFile using &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt; or &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; as soon as it is opened. If it fails to obtain a required lock immediately, &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; uses any registered busy-handler callback or timeout in the same way as &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; does.</source>
          <target state="translated">由于数据库zFilename是磁盘上的文件，因此可以由另一个进程从外部访问它。这意味着当对sqlite3_backup_step（）的调用尝试从中读取数据或向其中写入数据时，它可能无法获取所需的文件锁。如果发生这种情况，则此实现将失败，立即返回SQLITE_BUSY。解决方案是在打开&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt; pFile后立即使用&lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler（）&lt;/a&gt;或&lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;注册繁忙处理程序回调或超时。如果未能立即获得所需的锁，则&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（）&lt;/a&gt;使用任何已注册的忙处理程序回调或超时，其方式与&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;或&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）相同&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="689371fa0cc7aa87af9ab6ee0314efa8f5ddaa1a" translate="yes" xml:space="preserve">
          <source>Since its inception on 2000-05-29, SQLite has been implemented in generic C. C was and continues to be the best language for implementing a software library like SQLite. There are no plans to recode SQLite in any other programming language at this time.</source>
          <target state="translated">自2000-05-29成立以来,SQLite一直是用通用C语言实现的,C语言曾经是并将继续是实现像SQLite这样的软件库的最佳语言。目前还没有计划用任何其他编程语言重新编码SQLite。</target>
        </trans-unit>
        <trans-unit id="e237e23641bdbe1625752d920a811e88f9bea9fa" translate="yes" xml:space="preserve">
          <source>Since the &quot;t2&quot; imposter table is a form of database corruption, the manual approach to creating imposter tables is not recommended. Actually, any use of imposter tables is discouraged for all but expert developers, but manually created imposter tables are especially discouraged because they are permanent.</source>
          <target state="translated">由于 &quot;t2 &quot;冒名表是数据库腐败的一种形式,所以不建议采用手工创建冒名表的方法。实际上,除了专家级开发人员外,不鼓励使用任何冒名表,但特别不鼓励手动创建冒名表,因为它们是永久性的。</target>
        </trans-unit>
        <trans-unit id="0cc48f0c85bdbc88acc6ded1a2b33b3cefbcc949" translate="yes" xml:space="preserve">
          <source>Since the SQLite database file format was designed (in 2003) the default &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page size&lt;/a&gt; for new databases has been 1024 bytes. This was a reasonable choice in 2003. But on modern hardware, a 4096 byte page is a faster and better choice. So, beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;version 3.12.0&lt;/a&gt; (2016-03-29)) the default page size for new database files has been increased to 4096 bytes.</source>
          <target state="translated">由于SQLite数据库文件格式是在2003年设计的，因此新数据库的默认&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;页面大小&lt;/a&gt;为1024字节。在2003年，这是一个合理的选择。但是在现代硬件上，4096字节的页是一个更快，更好的选择。因此，从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;版本3.12.0&lt;/a&gt;（2016-03-29）开始，新数据库文件的默认页面大小已增加到4096字节。</target>
        </trans-unit>
        <trans-unit id="054ac08de64845448b2fb9281541e1391100a214" translate="yes" xml:space="preserve">
          <source>Since the actions of &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; are determined to some extent by prior queries that have been evaluated on the same database connection, it is recommended that &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; be deferred until the database connection is closing and has thus had an opportunity to accumulate as much usage information as possible. It is also reasonable to set a timer to run &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; every few hours, or every few days, for database connections that stay open for a long time.</source>
          <target state="translated">由于&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA Optimize&lt;/a&gt;的操作在某种程度上是由在同一数据库连接上评估过的先前查询确定的，因此建议将&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA Optimize&lt;/a&gt;推迟到数据库连接关闭之前，从而有机会积累尽可能多的使用情况信息。尽可能。对于长时间保持打开状态的数据库连接，设置计时器每隔几小时或每隔几天运行一次&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA Optimize&lt;/a&gt;也很合理。</target>
        </trans-unit>
        <trans-unit id="a35c2dbd798622212a3da41545074117af9096bd" translate="yes" xml:space="preserve">
          <source>Since the index is used to look up values in the table, it is important that the index and table be kept consistent. Now that there is an index on the examp table, we will have to update that index whenever data is inserted, deleted, or changed in the examp table. Remember the first example above where we were able to insert a new row into the &quot;examp&quot; table using 12 VDBE instructions. Now that this table is indexed, 19 instructions are required. The SQL statement is this:</source>
          <target state="translated">由于索引是用来查询表中的值的,所以保持索引和表的一致性很重要。既然在examp表上有一个索引,那么每当在examp表中插入、删除或更改数据时,我们就必须更新该索引。还记得上面第一个例子,我们能够使用12条VDBE指令在 &quot;examp &quot;表中插入一条新的记录。现在这个表被索引了,需要19条指令。SQL语句是这样的。</target>
        </trans-unit>
        <trans-unit id="792d86f988c7b4533a9df91cbaad2f47d8254db5" translate="yes" xml:space="preserve">
          <source>Since the information is stored in the table in rowid order, SQLite can find the correct row using a binary search. If the table contains N element, the time required to look up the desired row is proportional to logN rather than being proportional to N as in a full table scan. If the table contains 10 million elements, that means the query will be on the order of N/logN or about 1 million times faster.</source>
          <target state="translated">由于信息是按照rowid顺序存储在表中的,所以SQLite可以使用二进制搜索找到正确的行。如果表中包含N个元素,那么查询所需行的时间与logN成正比,而不是像全表扫描那样与N成正比。如果表中包含1000万个元素,那就意味着查询的速度将在N/logN的顺序上,也就是大约100万倍。</target>
        </trans-unit>
        <trans-unit id="f5b0a5f9338e5d6f0eb6749a38c57ac37eadf9c5" translate="yes" xml:space="preserve">
          <source>Since the information is stored in the table in rowid order, SQLite can find the correct row using a binary search. If the table contains N elements, the time required to look up the desired row is proportional to logN rather than being proportional to N as in a full table scan. If the table contains 10 million elements, that means the query will be on the order of N/logN or about 1 million times faster.</source>
          <target state="translated">由于信息是按照rowid顺序存储在表中的,所以SQLite可以使用二进制搜索找到正确的行。如果表包含N个元素,那么查找所需行所需的时间与logN成正比,而不是像全表扫描那样与N成正比。如果表包含1000万个元素,这意味着查询的速度将在N/logN的顺序上,或者说大约快100万倍。</target>
        </trans-unit>
        <trans-unit id="94ff8f1fdae75cff7dbf44bfb613a96fb3fe71f5" translate="yes" xml:space="preserve">
          <source>Since this document was first written, the canonical SQLite source code has been moved from the venerable CVS system into a Fossil repository at &lt;a href=&quot;http://www.sqlite.org/src&quot;&gt;http://www.sqlite.org/src&lt;/a&gt;. This means that if you are working with canonical SQLite source code (as opposed to the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; source code files, sqlite3.c and sqlite3.h) then you can create a private repository simply by cloning the official repository:</source>
          <target state="translated">自该文档首次编写以来，规范的SQLite源代码已从古老的CVS系统移至位于&lt;a href=&quot;http://www.sqlite.org/src&quot;&gt;http://www.sqlite.org/src&lt;/a&gt;的Fossil存储库中。这意味着，如果您使用的是规范的SQLite源代码（与&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;源代码文件sqlite3.c和sqlite3.h 相反），则只需克隆官方存储库即可创建私有存储库：</target>
        </trans-unit>
        <trans-unit id="b099e40d5135d32fbddb7b54b1e0fec56c9ea4c7" translate="yes" xml:space="preserve">
          <source>Since this document was first written, the canonical SQLite source code has been moved from the venerable CVS system into a Fossil repository at &lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;http://www.sqlite.org/src&lt;/a&gt;. This means that if you are working with canonical SQLite source code (as opposed to the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; source code files, sqlite3.c and sqlite3.h) then you can create a private repository simply by cloning the official repository:</source>
          <target state="translated">自该文档首次编写以来，规范的SQLite源代码已从古老的CVS系统移至位于&lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;http://www.sqlite.org/src&lt;/a&gt;的Fossil存储库中。这意味着，如果您正在使用规范的SQLite源代码（与&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;源代码文件sqlite3.c和sqlite3.h相反），则只需克隆官方存储库即可创建私有存储库：</target>
        </trans-unit>
        <trans-unit id="8b7c178a22b32f8642c754bb0ef6c8c8f9f96539" translate="yes" xml:space="preserve">
          <source>Since this document was originally written some of the database engines tested have been updated and users have been kind enough to send in corrections to the chart below. The original data showed a wide variety of behaviors, but over time the range of behaviors has converged toward the PostgreSQL/Oracle model. The only significant difference is that Informix and MS-SQL both treat NULLs as indistinct in a UNIQUE column.</source>
          <target state="translated">自本文档最初撰写以来,一些被测试的数据库引擎已经更新,用户也很友好地发来了对下图的更正。原始数据显示了各种各样的行为,但随着时间的推移,行为范围已经向PostgreSQL/Oracle模型靠拢。唯一显著的区别是Informix和MS-SQL都将NULLs视为UNIQUE列中的不确定值。</target>
        </trans-unit>
        <trans-unit id="a988ba929d7a7d98790e14aa91b1b4ee801c28ea" translate="yes" xml:space="preserve">
          <source>Since this interface is expected to be rarely used, it is only available if SQLite is compiled using the &lt;a href=&quot;../compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">由于预计很少使用此接口，因此仅当使用&lt;a href=&quot;../compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt;编译时选项编译SQLite时，此接口才可用。</target>
        </trans-unit>
        <trans-unit id="fc8856dbc189b149adcf35c14f2c019d6ca39cd2" translate="yes" xml:space="preserve">
          <source>Since this interface is expected to be rarely used, it is only available if SQLite is compiled using the &lt;a href=&quot;compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">由于预计很少使用此接口，因此仅当使用&lt;a href=&quot;compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt;编译时选项编译SQLite时，此接口才可用。</target>
        </trans-unit>
        <trans-unit id="69653584b18a40e580d58b62294b4d01dca91c5b" translate="yes" xml:space="preserve">
          <source>Since undefined and implementation-defined behavior is non-portable and can easily lead to incorrect answers, SQLite works very hard to avoid it. For example, when adding two integer column values together as part of an SQL statement, SQLite does not simply add them together using the C-language &quot;+&quot; operator. Instead, it first checks to make sure the addition will not overflow, and if it will, it does the addition using floating point instead.</source>
          <target state="translated">由于未定义和实现定义的行为是不可移植的,很容易导致错误的答案,所以SQLite非常努力地避免这种情况。例如,当把两个整数列的值加在一起作为SQL语句的一部分时,SQLite不会简单地使用C语言的 &quot;+&quot;操作符把它们加在一起。相反,它首先检查确保加法不会溢出,如果会溢出,则使用浮点运算进行加法。</target>
        </trans-unit>
        <trans-unit id="9a1c7258f48d87f5562218d2ba5ba3886293704d" translate="yes" xml:space="preserve">
          <source>Single-File Documents</source>
          <target state="translated">单一档案文件</target>
        </trans-unit>
        <trans-unit id="7fd14cfbad52780046ab174d1c92328e62738415" translate="yes" xml:space="preserve">
          <source>Single-file Cross-platform Database</source>
          <target state="translated">单文件跨平台数据库</target>
        </trans-unit>
        <trans-unit id="71d9f86ea2562e67aa07344919bbe26526606087" translate="yes" xml:space="preserve">
          <source>Situations Where A Client/Server RDBMS May Work Better</source>
          <target state="translated">客户端/服务器RDBMS可能会更好的情况下。</target>
        </trans-unit>
        <trans-unit id="7606f77965da29221827e7ce60dd2a6316522a70" translate="yes" xml:space="preserve">
          <source>Situations Where SQLite Works Well</source>
          <target state="translated">SQLite工作良好的情况</target>
        </trans-unit>
        <trans-unit id="b7152342a267362add3c0d7f69f720f7a9c76c9e" translate="yes" xml:space="preserve">
          <source>Size</source>
          <target state="translated">Size</target>
        </trans-unit>
        <trans-unit id="23dd62e305cc04b400ea8b167918d45e391e1599" translate="yes" xml:space="preserve">
          <source>Size Of The SQLite Library</source>
          <target state="translated">SQLite库的大小</target>
        </trans-unit>
        <trans-unit id="23aa6e811d60088ebfe23efb308861aa99dcc44c" translate="yes" xml:space="preserve">
          <source>Size in bytes</source>
          <target state="translated">字节大小</target>
        </trans-unit>
        <trans-unit id="866e161f09886804ed95702c5f38517afa748243" translate="yes" xml:space="preserve">
          <source>Size of a disk sector assumed by the process that wrote this journal.</source>
          <target state="translated">编写本日记的过程所假设的磁盘扇区大小。</target>
        </trans-unit>
        <trans-unit id="d67d90ae080b2ba6443535a1ba1538cce623c7a0" translate="yes" xml:space="preserve">
          <source>Size of associated data in bytes after it has been uncompressed (an integer).</source>
          <target state="translated">相关数据被解压后的字节大小(一个整数)。</target>
        </trans-unit>
        <trans-unit id="af19d643ee98cb7aaa5189e1e80bb15629e35fe6" translate="yes" xml:space="preserve">
          <source>Size of pages in this journal.</source>
          <target state="translated">本刊的版面大小。</target>
        </trans-unit>
        <trans-unit id="594a08e2bfa114e1b1b2dd2a2473b57fc253e650" translate="yes" xml:space="preserve">
          <source>Size of the database file in pages.</source>
          <target state="translated">数据库文件的大小,以页为单位。</target>
        </trans-unit>
        <trans-unit id="57e816514d2bd056545721fc5901b1263c953939" translate="yes" xml:space="preserve">
          <source>Size of the database file in pages. The &quot;in-header database size&quot;.</source>
          <target state="translated">数据库文件的大小,以页为单位。标题内数据库大小&quot;。</target>
        </trans-unit>
        <trans-unit id="80dfcf68ced67397f8e69446b796772d4e573bd1" translate="yes" xml:space="preserve">
          <source>Skip NULL entries on range queries in &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/tktview/4baa46491212947&quot;&gt;4baa46491212947&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expridx&quot;&gt;在表达式的索引中&lt;/a&gt;跳过范围查询中的NULL条目。修复票&lt;a href=&quot;https://www.sqlite.org/src/tktview/4baa46491212947&quot;&gt;4baa46491212947&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8597bf03434e274cab90656bf57bce61497b541d" translate="yes" xml:space="preserve">
          <source>Skip over leading spaces in text to numeric conversions.</source>
          <target state="translated">跳过文本到数字转换中的前导空格。</target>
        </trans-unit>
        <trans-unit id="44c1dff190859dd795700849185006cec261ef11" translate="yes" xml:space="preserve">
          <source>Small code &lt;a href=&quot;footprint&quot;&gt;footprint&lt;/a&gt;: less than 600KiB fully configured or much less with optional features omitted.</source>
          <target state="translated">代码&lt;a href=&quot;footprint&quot;&gt;占用&lt;/a&gt;量少：完全配置的内存不到600KiB，而省略了可选功能则更少。</target>
        </trans-unit>
        <trans-unit id="2d43535873c35c636399ec243f6c8a56398f45fc" translate="yes" xml:space="preserve">
          <source>Small edits only overwrite the parts of the file that change, reducing write time and wear on SSD drives.</source>
          <target state="translated">小规模的编辑只会覆盖文件中改变的部分,减少写入时间和SSD硬盘的磨损。</target>
        </trans-unit>
        <trans-unit id="15cb3011196ef5ecfa387e72a64b6b9858775898" translate="yes" xml:space="preserve">
          <source>Smaller documents</source>
          <target state="translated">较小的文件</target>
        </trans-unit>
        <trans-unit id="6085ef2b0d377636644056b25b8388fdb9315be1" translate="yes" xml:space="preserve">
          <source>Snapshots of official releases of SQLite source code can often be obtained directly from the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; of the SQLite website. Even if the specific version desired is not listed on the download page, the naming conventions are fairly clear and so programmers can often guess the name of an historical release and download it that way.</source>
          <target state="translated">官方SQLite源代码的快照通常可以直接从SQLite网站的&lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;下载页面&lt;/a&gt;获得。即使下载页面上未列出所需的特定版本，命名约定也相当清楚，因此程序员经常可以猜测历史版本的名称并以这种方式下载。</target>
        </trans-unit>
        <trans-unit id="7745ac392b119ee893e25a699e3cdf853f08cced" translate="yes" xml:space="preserve">
          <source>So as not to open security holes in older applications that are unprepared to deal with &lt;a href=&quot;../loadext&quot;&gt;extension loading&lt;/a&gt;, and as a means of disabling &lt;a href=&quot;../loadext&quot;&gt;extension loading&lt;/a&gt; while evaluating user-entered SQL, the following API is provided to turn the &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; mechanism on and off.</source>
          <target state="translated">为了避免在尚未准备好处理&lt;a href=&quot;../loadext&quot;&gt;扩展加载的&lt;/a&gt;较旧应用程序中打开安全漏洞，并且作为在评估用户输入的SQL时禁用&lt;a href=&quot;../loadext&quot;&gt;扩展加载的&lt;/a&gt;一种方式，提供了以下API以打开和关闭&lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;机制。</target>
        </trans-unit>
        <trans-unit id="38b1dd3b3f9a942c8b562e364d61d2076822b07d" translate="yes" xml:space="preserve">
          <source>So as not to open security holes in older applications that are unprepared to deal with &lt;a href=&quot;loadext&quot;&gt;extension loading&lt;/a&gt;, and as a means of disabling &lt;a href=&quot;loadext&quot;&gt;extension loading&lt;/a&gt; while evaluating user-entered SQL, the following API is provided to turn the &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; mechanism on and off.</source>
          <target state="translated">为了避免在尚未准备好处理&lt;a href=&quot;loadext&quot;&gt;扩展加载的&lt;/a&gt;较旧应用程序中打开安全漏洞，并且作为在评估用户输入的SQL时禁用&lt;a href=&quot;loadext&quot;&gt;扩展加载的&lt;/a&gt;一种方式，提供了以下API以打开和关闭&lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;机制。</target>
        </trans-unit>
        <trans-unit id="16d0e08c9c27f821bc14542d2dfda5e1d13ecd69" translate="yes" xml:space="preserve">
          <source>So in the vast majority of cases, applications need not worry about the WAL file at all. SQLite will automatically take care of it. But it is possible to get SQLite into a state where the WAL file will grow without bound, causing excess disk space usage and slow queries speeds. The following bullets enumerate some of the ways that this can happen and how to avoid them.</source>
          <target state="translated">所以在绝大多数情况下,应用程序根本不需要担心WAL文件。SQLite会自动处理它。但也有可能让SQLite进入一种状态,WAL文件会无限制地增长,造成磁盘空间使用量过大,查询速度缓慢。下面小编列举了一些可能发生这种情况的方法以及如何避免。</target>
        </trans-unit>
        <trans-unit id="e294517ccb0b92866adadbcc46dbbe368da638fb" translate="yes" xml:space="preserve">
          <source>So instead of going by the standards documents, various popular SQL engines were tested to see how they handle NULLs. The idea was to make SQLite work like all the other engines. An SQL test script was developed and run by volunteers on various SQL RDBMSes and the results of those tests were used to deduce how each engine processed NULL values. The original tests were run in May of 2002. A copy of the test script is found at the end of this document.</source>
          <target state="translated">因此,我们没有按照标准文档去做,而是对各种流行的SQL引擎进行了测试,看看它们是如何处理NULL的。我们的想法是让SQLite像其他引擎一样工作。志愿者们开发了一个SQL测试脚本,并在不同的SQL RDBMSes上运行,测试结果被用来推断每个引擎如何处理NULL值。最初的测试是在2002年5月进行的。测试脚本的副本在本文件的最后。</target>
        </trans-unit>
        <trans-unit id="cb3fd38b2086ae5409a50744fd4fc4e629f9ceb9" translate="yes" xml:space="preserve">
          <source>So let your take-away be this: read/write latency for SQLite is competitive with read/write latency of individual files on disk. Often SQLite is faster. Sometimes SQLite is almost as fast. Either way, this article disproves the common assumption that a relational database must be slower than direct filesystem I/O.</source>
          <target state="translated">所以让你的收获是:SQLite的读写延迟与磁盘上单个文件的读写延迟是有竞争力的。通常SQLite更快。有时SQLite几乎一样快。无论哪种情况,这篇文章都推翻了关系型数据库一定比直接文件系统I/O慢的常见假设。</target>
        </trans-unit>
        <trans-unit id="4e14f136c4639ca69349a007ce6b5be7651832a1" translate="yes" xml:space="preserve">
          <source>So that</source>
          <target state="translated">所以</target>
        </trans-unit>
        <trans-unit id="ed811e71ef3d05d3652d347ba0eec5bc9cfd6daf" translate="yes" xml:space="preserve">
          <source>So the implementation of DELETE is really in two loops. The first loop (instructions 5 through 11) locates the records that are to be deleted and saves their keys onto a temporary list, and the second loop (instructions 16 through 19) uses the key list to delete the records one by one.</source>
          <target state="translated">所以DELETE的实现其实就是两个循环。第一个循环(指令5到11)定位要删除的记录,并将它们的键保存到一个临时列表中,第二个循环(指令16到19)使用键列表逐一删除记录。</target>
        </trans-unit>
        <trans-unit id="c4f70ed30e8ca5ddd05ca39e32d9f73108273525" translate="yes" xml:space="preserve">
          <source>So then, instead of storing all content for all slides in a single oversized XML file (&quot;content.xml&quot;), suppose there was a separate table for storing the content of each slide separately. The table schema might look something like this:</source>
          <target state="translated">那么,与其将所有幻灯片的所有内容存储在一个超大的XML文件(&quot;content.xml&quot;)中,不如假设有一个单独的表来分别存储每张幻灯片的内容。这个表的模式可能是这样的。</target>
        </trans-unit>
        <trans-unit id="21a527776b915968f528d88d96579bf0b2cfc459" translate="yes" xml:space="preserve">
          <source>So which query plan is better? It turns out that the answer depends on what kind of data is found in the node and edge tables.</source>
          <target state="translated">那么哪种查询方案更好呢?原来,答案取决于节点表和边缘表中的数据是什么样的。</target>
        </trans-unit>
        <trans-unit id="15a7d8b50c8c0de15e18cf6f21d9c00564463215" translate="yes" xml:space="preserve">
          <source>So with this simple change, the ODP file now stores not just the most recent edit to the presentation, but a history of all historic edits. The user would normally want to see just the most recent edition of the presentation, but if desired, the user can now go backwards in time to see historical versions of the same presentation.</source>
          <target state="translated">因此,通过这个简单的改变,ODP文件现在不仅存储了最近对演示文稿的编辑,还存储了所有历史编辑的历史。用户通常只想看到演示文稿的最新版本,但如果需要的话,用户现在可以向后看同一演示文稿的历史版本。</target>
        </trans-unit>
        <trans-unit id="1b3d75a6fea634203c91a87ee6d0199704a76d2e" translate="yes" xml:space="preserve">
          <source>So you can see that depending on how the data is structured in the table, either query plan 1 or query plan 2 might be better. Which plan does SQLite choose by default? As of version 3.6.18, without running &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;, SQLite will choose option 2. But if the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command is run in order to gather statistics, a different choice might be made if the statistics indicate that the alternative is likely to run faster.</source>
          <target state="translated">因此，您可以看到，根据表中数据的结构，查询计划1或查询计划2可能更好。默认情况下，SQLite选择哪种计划？从3.6.18版本开始，在不运行&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE的情况下&lt;/a&gt;，SQLite将选择选项2。但是，如果运行&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令以收集统计信息，则如果统计信息表明替代方法可能运行得更快，则可能会做出其他选择。</target>
        </trans-unit>
        <trans-unit id="a928bb1185074b6024b0f391bb34b87d559742b4" translate="yes" xml:space="preserve">
          <source>So you can see that depending on how the data is structured in the table, either query plan 1 or query plan 2 might be better. Which plan does SQLite choose by default? As of version 3.6.18, without running &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;, SQLite will choose option 2. If the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command is run in order to gather statistics, a different choice might be made if the statistics indicate that the alternative is likely to run faster.</source>
          <target state="translated">因此，您可以看到，根据表中数据的结构，查询计划1或查询计划2可能更好。默认情况下，SQLite选择哪种计划？从3.6.18版本开始，在不运行&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE的情况下&lt;/a&gt;，SQLite将选择选项2。如果运行&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令以收集统计信息，则在统计信息表明替代方法可能运行得更快的情况下，可能会做出其他选择。</target>
        </trans-unit>
        <trans-unit id="ae83e266982fd9b4e55366971516ab44ce25fd32" translate="yes" xml:space="preserve">
          <source>So, SQLite is able to do one or two large and complex queries, or it can do many smaller and simpler queries. Both are efficient. An application can use either or both techniques, depending on what works best for the situation at hand.</source>
          <target state="translated">所以,SQLite能够做一两个大型复杂的查询,也可以做很多小型简单的查询。这两种方式都很高效。一个应用程序可以使用这两种技术中的一种,也可以使用这两种技术,这取决于什么最适合当前的情况。</target>
        </trans-unit>
        <trans-unit id="bac7c0c462d374d0c622ef9a876ba7c2814954d0" translate="yes" xml:space="preserve">
          <source>So, for example, Android applications written in Java are able to invoke SQLite (through an adaptor). Maybe it would have been more convenient for Android if SQLite had been coded in Java as that would make the interface simpler. However, on iPhone applications are coded in Objective-C or Swift, neither of which have the ability to call libraries written in Java. Thus, SQLite would be unusable on iPhones had it been written in Java.</source>
          <target state="translated">所以,比如说,用Java编写的Android应用程序能够调用SQLite(通过适配器)。如果SQLite用Java编码,也许对Android来说会更方便,因为这样会使界面更简单。然而,在iPhone上,应用程序是用Objective-C或Swift编码的,这两种语言都不能调用用Java编写的库。因此,如果SQLite是用Java编写的,那么在iPhone上就无法使用。</target>
        </trans-unit>
        <trans-unit id="74dbcba5ce1ee9e465ff4640af1328df3383d188" translate="yes" xml:space="preserve">
          <source>So, for example, if you read on Wikipedia that the encoding for the minimum positive binary64 value is 0x0000000000000001, then you can find the corresponding floating point value like this:</source>
          <target state="translated">所以,举个例子,如果你在维基百科上读到最小正二进制64值的编码是0x0000000000000001,那么你可以这样找到对应的浮点值。</target>
        </trans-unit>
        <trans-unit id="2a08fae7d5439605099534f2303acb989c7de8df" translate="yes" xml:space="preserve">
          <source>So, for example, if you wanted to see the compression efficiency (expressed as the size of the compressed content relative to the original uncompressed file size) for all files in the ZIP archive, sorted from most compressed to least compressed, you could run a query like this:</source>
          <target state="translated">因此,举例来说,如果你想查看ZIP压缩包中所有文件的压缩效率(用压缩内容相对于原始未压缩文件大小的大小来表示),从压缩程度最高的到压缩程度最低的排序,你可以运行这样一个查询。</target>
        </trans-unit>
        <trans-unit id="181a0af408b7a72e62f37951390087a73f4bc42a" translate="yes" xml:space="preserve">
          <source>So, for example, suppose a multi-thread process has two or more threads with separate SQLite database connections to the same database file. Then a third thread comes along and wants to read something out of that same database file on its own, without using the SQLite library. The third thread does an &lt;code&gt;open()&lt;/code&gt;, a &lt;code&gt;read()&lt;/code&gt; and then a &lt;code&gt;close()&lt;/code&gt;. One would think this would be harmless. But the &lt;code&gt;close()&lt;/code&gt; system call caused the locks held on the database by all the other threads to be dropped. Those other threads have no way of knowing that their locks have just been trashed (POSIX does not provide any mechanism to determine this) and so they keep on running under the assumption that their locks are still valid. This can lead to two or more threads or processes trying to write to the database at the same time, resulting in database corruption.</source>
          <target state="translated">因此，例如，假设一个多线程进程具有两个或多个线程，这些线程具有到同一数据库文件的单独SQLite数据库连接。然后出现第三个线程，并希望自己从同一数据库文件中读取某些内容，而不使用SQLite库。第三个线程执行 &lt;code&gt;open()&lt;/code&gt; ， &lt;code&gt;read()&lt;/code&gt; 然后执行 &lt;code&gt;close()&lt;/code&gt; 。有人会认为这将是无害的。但是 &lt;code&gt;close()&lt;/code&gt; 系统调用导致所有其他线程保留在数据库上的锁被删除。这些其他线程无法知道它们的锁刚刚被破坏了（POSIX没有提供任何机制来确定这一点），因此它们在假定锁仍然有效的情况下继续运行。这可能导致两个或多个线程或进程尝试同时写入数据库，从而导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="e67704da7c1255179aaf24e0803cc78b548dbe91" translate="yes" xml:space="preserve">
          <source>So, for example, suppose an application runs one query against an R-Tree like this:</source>
          <target state="translated">因此,举例来说,假设一个应用程序对R树运行一个查询,就像这样。</target>
        </trans-unit>
        <trans-unit id="7734444a7a6faac12d5a5f4324148513ca147ad7" translate="yes" xml:space="preserve">
          <source>So, for example, to move a polygon by some amount DX, DY without changing its shape, use:</source>
          <target state="translated">因此,例如,要在不改变多边形形状的情况下,将多边形移动一定量的DX、DY,使用。</target>
        </trans-unit>
        <trans-unit id="e378604952476e70a532691c0957173825ab1905" translate="yes" xml:space="preserve">
          <source>So, in most real systems, an index should be created on the child key columns of each foreign key constraint. The child key index does not have to be (and usually will not be) a UNIQUE index. Returning again to the example in section 1, the complete database schema for efficient implementation of the foreign key constraint might be:</source>
          <target state="translated">所以,在大多数实际系统中,应该在每个外键约束的子键列上创建一个索引。子键索引不一定是(通常也不会是)UNIQUE索引。再次回到第1节的例子,高效实现外键约束的完整数据库模式可能是:。</target>
        </trans-unit>
        <trans-unit id="ae3d493e7575fd35c2f366541da3ece2a1661c2d" translate="yes" xml:space="preserve">
          <source>So-called &quot;REAL&quot; or floating point values are stored in the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE 754&lt;/a&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;Binary-64&lt;/a&gt; format. This gives a range of positive values between approximately 1.7976931348623157e+308 and 4.9406564584124654e-324 with an equivalent range of negative values. A binary64 can also be 0.0 (and -0.0), positive and negative infinity and &quot;NaN&quot; or &quot;Not-a-Number&quot;. Floating point values are approximate.</source>
          <target state="translated">所谓的&amp;ldquo; REAL&amp;rdquo;或浮点值以&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE 754 &lt;/a&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;Binary-64&lt;/a&gt;格式存储。这会给出大约1.7976931348623157e + 308和4.9406564584124654654e-324之间的正值范围，并具有等效的负值范围。 binary64也可以是0.0（和-0.0），正负无穷大以及&amp;ldquo; NaN&amp;rdquo;或&amp;ldquo;非数字&amp;rdquo;。浮点值是近似值。</target>
        </trans-unit>
        <trans-unit id="a3db788b7daff3a78000d452682744db386479ec" translate="yes" xml:space="preserve">
          <source>SoftNull</source>
          <target state="translated">SoftNull</target>
        </trans-unit>
        <trans-unit id="36455d32e1724499e8736ccea81ccd08b26881c3" translate="yes" xml:space="preserve">
          <source>Solve Sudoku puzzles</source>
          <target state="translated">解决数独难题</target>
        </trans-unit>
        <trans-unit id="ea9361715e601f0c6bb314bde2f85f47f8bc5402" translate="yes" xml:space="preserve">
          <source>Some &quot;safe&quot; languages (ex: Go) dislike the use of assert(). But the use of assert() is a vital part of keeping SQLite maintainable. The lack of assert() in Go is a show-stopper as far as the developers of SQLite are concerned. See the &lt;a href=&quot;assert&quot;&gt;The Use Of assert() In SQLite&lt;/a&gt; article for additional information.</source>
          <target state="translated">一些&amp;ldquo;安全&amp;rdquo;语言（例如：Go）不喜欢使用assert（）。但是使用assert（）是保持SQLite可维护性的重要组成部分。就SQLite开发人员而言，Go中缺少assert（）无疑是一个阻碍。有关其他信息，请参见&lt;a href=&quot;assert&quot;&gt;在SQLite中使用assert（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82877b639e06578b26b7b6487eda6b76c0a0e3c6" translate="yes" xml:space="preserve">
          <source>Some &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements do their work during sqlite3_prepare() rather than during sqlite3_step(). Those PRAGMA statements are unaffected by EXPLAIN. They operate the same with or without the EXPLAIN prefix. The set of PRAGMA statements that are unaffected by EXPLAIN can vary from one release to the next. Some PRAGMA statements operate during sqlite3_prepare() depending on their arguments. For consistent results, avoid using EXPLAIN on PRAGMA statements.</source>
          <target state="translated">一些&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;语句在sqlite3_prepare（）期间而不是在sqlite3_step（）期间工作。这些PRAGMA语句不受EXPLAIN的影响。无论使用或不使用EXPLAIN前缀，它们的操作相同。不受EXPLAIN影响的PRAGMA语句集在一个版本与下一个版本之间可能有所不同。某些PRAGMA语句根据其参数在sqlite3_prepare（）期间运行。为了获得一致的结果，请避免在PRAGMA语句上使用EXPLAIN。</target>
        </trans-unit>
        <trans-unit id="5732042dba5cf74de37a47838012719f36ee8111" translate="yes" xml:space="preserve">
          <source>Some Example Triggers</source>
          <target state="translated">一些实例触发器</target>
        </trans-unit>
        <trans-unit id="e2da6518510111d1ca6bc33d2d1e98dff9548bb8" translate="yes" xml:space="preserve">
          <source>Some SQL database engines provide non-standard &quot;hint&quot; mechanisms which can be used to give the query optimizer clues about what indices it should use for a particular statement. The INDEX BY clause of SQLite is &lt;em&gt;not&lt;/em&gt; a hinting mechanism and it should not be used as such. The INDEXED BY clause does not give the optimizer hints about which index to use; it gives the optimizer a requirement of which index to use. If the query optimizer is unable to use the index specified by the INDEX BY clause, then the query will fail with an error.</source>
          <target state="translated">一些SQL数据库引擎提供了非标准的&amp;ldquo;提示&amp;rdquo;机制，该机制可用于为查询优化器提供有关特定语句应使用哪些索引的线索。 SQLite的INDEX BY子句&lt;em&gt;不是&lt;/em&gt;提示机制，因此不应如此使用。 INDEXED BY子句不会为优化器提供有关使用哪个索引的提示。它为优化器提供了使用哪个索引的要求。如果查询优化器无法使用INDEX BY子句指定的索引，则查询将失败并显示错误。</target>
        </trans-unit>
        <trans-unit id="fbf443b96f0d9f6eac4bc80a9c5c544e6d64bd31" translate="yes" xml:space="preserve">
          <source>Some commentators say that SQLite is &quot;weakly typed&quot; and that other SQL databases are &quot;strongly typed&quot;. We consider these terms to be inaccurate and pejorative. We prefer to say that SQLite is &quot;flexibly typed&quot; and that other SQL databases are &quot;rigidly typed&quot;.</source>
          <target state="translated">有些评论者说,SQLite是 &quot;弱类型&quot;,而其他SQL数据库是 &quot;强类型&quot;。我们认为这些术语是不准确的,是贬义的。我们更倾向于说SQLite是 &quot;柔性类型&quot;,而其他SQL数据库是 &quot;刚性类型&quot;。</target>
        </trans-unit>
        <trans-unit id="ffa0bb5b46a56bce712735328de2ecfd7898dd9a" translate="yes" xml:space="preserve">
          <source>Some devices are compelled to use an older filesystem with 8+3 filename restrictions for backwards compatibility, or due to other non-technical factors. In such situations, SQLite can be coerced into using auxiliary files that fit the 8+3 pattern as follows:</source>
          <target state="translated">有些设备为了向后兼容,或者由于其他非技术因素,不得不使用有8+3文件名限制的旧文件系统。在这种情况下,可以胁迫SQLite使用符合8+3模式的辅助文件,具体如下。</target>
        </trans-unit>
        <trans-unit id="a1a4bdb9a86e43ef62782dbb2803e2ef7fef0a7a" translate="yes" xml:space="preserve">
          <source>Some example, cost table entries:</source>
          <target state="translated">一些例子,成本表条目。</target>
        </trans-unit>
        <trans-unit id="9234854e8f0cb7e3b23fa0273a95bcc8f4a8eaf9" translate="yes" xml:space="preserve">
          <source>Some examples will help illustrate the difference:</source>
          <target state="translated">一些例子将有助于说明两者的区别。</target>
        </trans-unit>
        <trans-unit id="31941b285d3264077d66c50c29fee18d7a8c1f66" translate="yes" xml:space="preserve">
          <source>Some freelist pages contain critical data; specifically the locations of other freelist pages. But most freelist pages contain nothing useful. These latter freelist pages are called &quot;leaf&quot; pages. We are free to modify the content of a leaf freelist page in the database without changing the meaning of the database in any way.</source>
          <target state="translated">一些自由职业者页面包含关键数据,特别是其他自由职业者页面的位置。但大多数自由列表页面不包含任何有用的内容。这些后一种自由列表页面被称为 &quot;叶子 &quot;页面。我们可以在不改变数据库意义的前提下,自由修改数据库中自由列表页的内容。</target>
        </trans-unit>
        <trans-unit id="6d4f98671a50a0a922d51c622597741cdfcd893a" translate="yes" xml:space="preserve">
          <source>Some future versions of SQLite may change to enable this feature by default.</source>
          <target state="translated">SQLite未来的一些版本可能会改变,以默认方式启用此功能。</target>
        </trans-unit>
        <trans-unit id="2f4d80fea07d79c2b9292b009b4bc9dc70c5c271" translate="yes" xml:space="preserve">
          <source>Some heightened security settings (&lt;a href=&quot;#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema=OFF&lt;/a&gt;) disable the use of SQL functions inside views and triggers and in schema structures such as &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;DEFAULT clauses&lt;/a&gt;, &lt;a href=&quot;expridx&quot;&gt;expression indexes&lt;/a&gt;, &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;, and &lt;a href=&quot;gencol&quot;&gt;generated columns&lt;/a&gt; unless the function is tagged with SQLITE_INNOCUOUS. Most built-in functions are innocuous. Developers are advised to avoid using the SQLITE_INNOCUOUS flag for application-defined functions unless the function has been carefully audited and found to be free of potentially security-adverse side-effects and information-leaks.</source>
          <target state="translated">某些增强的安全设置（&lt;a href=&quot;#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;和PRAGMAtrusted_schema &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;= OFF&lt;/a&gt;）禁止在视图和触发器内部以及架构结构中使用SQL函数，例如&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK约束&lt;/a&gt;，&lt;a href=&quot;lang_createtable#dfltval&quot;&gt;DEFAULT子句&lt;/a&gt;，&lt;a href=&quot;expridx&quot;&gt;表达式索引&lt;/a&gt;，&lt;a href=&quot;partialindex&quot;&gt;部分索引&lt;/a&gt;和&lt;a href=&quot;gencol&quot;&gt;生成的列，&lt;/a&gt;除非使用SQLITE_INNOCUOUS标记了该函数。大多数内置函数是无害的。建议开发人员避免对应用程序定义的函数使用SQLITE_INNOCUOUS标志，除非对该函数进行了仔细的审核并且发现没有潜在的不利于安全的副作用和信息泄漏。</target>
        </trans-unit>
        <trans-unit id="94760af1d8102735e05f237c89411fff0859308d" translate="yes" xml:space="preserve">
          <source>Some heightened security settings (&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt; and &lt;a href=&quot;../pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema=OFF&lt;/a&gt;) disable the use of SQL functions inside views and triggers and in schema structures such as &lt;a href=&quot;../lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, &lt;a href=&quot;../lang_createtable#dfltval&quot;&gt;DEFAULT clauses&lt;/a&gt;, &lt;a href=&quot;../expridx&quot;&gt;expression indexes&lt;/a&gt;, &lt;a href=&quot;../partialindex&quot;&gt;partial indexes&lt;/a&gt;, and &lt;a href=&quot;../gencol&quot;&gt;generated columns&lt;/a&gt; unless the function is tagged with SQLITE_INNOCUOUS. Most built-in functions are innocuous. Developers are advised to avoid using the SQLITE_INNOCUOUS flag for application-defined functions unless the function has been carefully audited and found to be free of potentially security-adverse side-effects and information-leaks.</source>
          <target state="translated">某些增强的安全设置（&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;和PRAGMAtrusted_schema &lt;a href=&quot;../pragma#pragma_trusted_schema&quot;&gt;= OFF&lt;/a&gt;）禁止在视图和触发器内部以及架构结构中使用SQL函数，例如&lt;a href=&quot;../lang_createtable#ckconst&quot;&gt;CHECK约束&lt;/a&gt;，&lt;a href=&quot;../lang_createtable#dfltval&quot;&gt;DEFAULT子句&lt;/a&gt;，&lt;a href=&quot;../expridx&quot;&gt;表达式索引&lt;/a&gt;，&lt;a href=&quot;../partialindex&quot;&gt;部分索引&lt;/a&gt;和&lt;a href=&quot;../gencol&quot;&gt;生成的列，&lt;/a&gt;除非使用SQLITE_INNOCUOUS标记了该函数。大多数内置函数是无害的。建议开发人员避免对应用程序定义的函数使用SQLITE_INNOCUOUS标志，除非对该函数进行了仔细的审核并且发现没有潜在的不利于安全的副作用和信息泄漏。</target>
        </trans-unit>
        <trans-unit id="1bc7150370b1275da7b22e0b3c0daa34955ce5a3" translate="yes" xml:space="preserve">
          <source>Some limits can be changed at run-time on a per-connection basis using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface with one of the &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;limit categories&lt;/a&gt; defined for that interface. Run-time limits are designed for applications that have multiple databases, some of which are for internal use only and others which can be influenced or controlled by potentially hostile external agents. For example, a web browser application might use an internal database to track historical page views but have one or more separate databases that are created and controlled by javascript applications that are downloaded from the internet. The &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface allows internal databases managed by trusted code to be unconstrained while simultaneously placing tight limitations on databases created or controlled by untrusted external code in order to help prevent a denial of service attack.</source>
          <target state="translated">某些限制可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;接口在每个连接的基础上更改，该接口具有为该接口定义的&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;限制类别&lt;/a&gt;之一。运行时限制是针对具有多个数据库的应用程序而设计的，其中一些仅供内部使用，而其他则可能受到潜在敌对外部代理的影响或控制。例如，Web浏览器应用程序可能使用内部数据库来跟踪历史页面浏览量，但具有一个或多个单独的数据库，这些数据库由从互联网下载的javascript应用程序创建和控制。该&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;接口允许不受约束的代码管理的内部数据库不受约束，同时对不受信任的外部代码创建或控制的数据库设置严格的限制，以帮助防止拒绝服务攻击。</target>
        </trans-unit>
        <trans-unit id="27f0f8e3878344df85d2a4246c11bee1e47d7640" translate="yes" xml:space="preserve">
          <source>Some older versions of Linux used the LinuxThreads library for thread support. LinuxThreads is similar to Pthreads, but is subtly different with respect to handling of POSIX advisory locks. SQLite versions 2.2.3 through 3.6.23 recognized that LinuxThreads were being used at runtime and took appropriate action to work around the non-standard behavior of LinuxThreads. But most modern Linux implementations make use of the newer, and correct, NPTL implementation of Pthreads. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21), the use of NPTL is assumed. No checks are made. Hence, recent versions of SQLite will subtly malfunction and may corrupt database files if used in multi-threaded application that run on older linux systems that make use of LinuxThreads.</source>
          <target state="translated">一些旧版本的Linux使用LinuxThreads库提供线程支持。 LinuxThreads与Pthreads类似，但是在处理POSIX咨询锁方面有细微的不同。 SQLite版本2.2.3到3.6.23意识到运行时正在使用LinuxThreads，并采取了适当的措施来解决LinuxThreads的非标准行为。但是，大多数现代Linux实现都使用Pthreads的更新且正确的NPTL实现。从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;版本3.7.0&lt;/a&gt;（2010-07-21）开始，假定使用NPTL。不进行检查。因此，如果在使用LinuxThreads的较旧linux系统上运行的多线程应用程序中使用SQLite，则最新版本的SQLite可能会出现一些故障，并可能损坏数据库文件。</target>
        </trans-unit>
        <trans-unit id="0bef87b7bc572b2934b8ea6d4c58c70ed7dd3633" translate="yes" xml:space="preserve">
          <source>Some older versions of SQLite (prior to version 2.4.0) would show decreasing performance after a sequence of DELETEs followed by new INSERTs. As this test shows, the problem has now been resolved.</source>
          <target state="translated">一些旧版本的SQLite(在2.4.0版本之前)在一连串的DELETEs和新的INSERTs之后会出现性能下降。正如这个测试所显示的,这个问题现在已经解决了。</target>
        </trans-unit>
        <trans-unit id="4b536a604954c308bdf6df6ee3bb8ed7c841aa8c" translate="yes" xml:space="preserve">
          <source>Some opcodes are self-altering. For example, the &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode (which is always the first opcode in every bytecode program) increments its P1 operand. Subsequent &lt;a href=&quot;opcode#Once&quot;&gt;Once&lt;/a&gt; opcodes compare their P1 operands to the P1 value for the &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode in order to determine if the one-time initialization code that follows should be skipped. Another example is the &lt;a href=&quot;opcode#String8&quot;&gt;String8&lt;/a&gt; opcode which converts its P4 operand from UTF-8 into the correct database string encoding, then converts itself into a &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; opcode.</source>
          <target state="translated">有些操作码会自动更改。例如，&lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt;操作码（始终是每个字节码程序中的第一个操作码）都会递增其P1操作数。随后的&lt;a href=&quot;opcode#Once&quot;&gt;一次&lt;/a&gt;操作码将其P1操作数与&lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt;操作码的P1值进行比较，以确定是否应跳过后面的一次性初始化代码。另一个示例是&lt;a href=&quot;opcode#String8&quot;&gt;String8&lt;/a&gt;操作码，它将其P4操作数从UTF-8转换为正确的数据库字符串编码，然后将自身转换为&lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt;操作码。</target>
        </trans-unit>
        <trans-unit id="52125a8361f282383783887e4dc2c4cfed4a215d" translate="yes" xml:space="preserve">
          <source>Some opcodes are self-altering. For example, the &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode (which is always the first opcode run a bytecode program) increments its P1 operand. Subsequent &lt;a href=&quot;opcode#Once&quot;&gt;Once&lt;/a&gt; opcodes compare their P1 operands to the P1 value for the &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode in order to determine if the one-time initialization code that follows should be skipped. Another example is the &lt;a href=&quot;opcode#String8&quot;&gt;String8&lt;/a&gt; opcode which converts its P4 operand from UTF-8 into the correct database string encoding, then converts itself into a &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; opcode.</source>
          <target state="translated">有些操作码会自动更改。例如，&lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt;操作码（始终是运行字节码程序的第一个操作码）递增其P1操作数。随后的&lt;a href=&quot;opcode#Once&quot;&gt;一次&lt;/a&gt;操作码将其P1操作数与&lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt;操作码的P1值进行比较，以确定是否应跳过后面的一次性初始化代码。另一个示例是&lt;a href=&quot;opcode#String8&quot;&gt;String8&lt;/a&gt;操作码，它将其P4操作数从UTF-8转换为正确的数据库字符串编码，然后将自身转换为&lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt;操作码。</target>
        </trans-unit>
        <trans-unit id="426e64b4a66f4f7807aa6667039b81573979fe2a" translate="yes" xml:space="preserve">
          <source>Some opcodes use all five operands. Some opcodes use one or two. Some opcodes use none of the operands.</source>
          <target state="translated">有些操作码使用全部五个操作码。有些操作码使用一个或两个操作码。有些操作码不使用任何操作数。</target>
        </trans-unit>
        <trans-unit id="18b335ac36fb2d38cd00024b326c89df9316f364" translate="yes" xml:space="preserve">
          <source>Some or all of these restrictions may be removed in the future.</source>
          <target state="translated">未来可能会取消部分或全部限制。</target>
        </trans-unit>
        <trans-unit id="b476a9e69a79b5371957fc7b1a40c95e375aeff4" translate="yes" xml:space="preserve">
          <source>Some other SQL database engines advise developers to store blobs in separate files and then store the filename in the database. In that case, where the database must first be consulted to find the filename before opening and reading the file, simply storing the entire blob in the database gives much faster read and write performance with SQLite. See the &lt;a href=&quot;intern-v-extern-blob&quot;&gt;Internal Versus External BLOBs&lt;/a&gt; article for more information.</source>
          <target state="translated">其他一些SQL数据库引擎建议开发人员将blob存储在单独的文件中，然后将文件名存储在数据库中。在那种情况下，在打开和读取文件之前必须先查询数据库以查找文件名，只需将整个Blob存储在数据库中就可以使用SQLite更快地实现读写性能。有关更多信息，请参见&lt;a href=&quot;intern-v-extern-blob&quot;&gt;内部与外部BLOB&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e94448e3ce0b80c02ec3cf58a3a89e81bfc4e794" translate="yes" xml:space="preserve">
          <source>Some other database constraint, for example a UNIQUE or CHECK constraint, may be violated when the new row is inserted.</source>
          <target state="translated">当插入新的记录时,可能会违反其他数据库约束,例如UNIQUE或CHECK约束。</target>
        </trans-unit>
        <trans-unit id="d87a22bd6e23f0cc806f999949a67d71c38a0517" translate="yes" xml:space="preserve">
          <source>Some other database constraint, for example a UNIQUE or CHECK constraint, may be violated when the row is updated.</source>
          <target state="translated">其他一些数据库约束,例如UNIQUE或CHECK约束,可能在更新行时被违反。</target>
        </trans-unit>
        <trans-unit id="a803eb726af2b55f4a3a45a5ec6b4038451fda8a" translate="yes" xml:space="preserve">
          <source>Some other ways in which FTS5 differs from FTS3/4 are:</source>
          <target state="translated">FTS5与FTS3/4的其他一些不同之处是:</target>
        </trans-unit>
        <trans-unit id="e2d6bed42aa0aeee6bb3a36da7e69907ed2fed99" translate="yes" xml:space="preserve">
          <source>Some people say that we should eliminate all warnings because benign warnings mask real warnings that might arise in future changes. This is true enough. But in reply, the developers observe that all warnings have already been fixed in the builds used for SQLite development (various versions of GCC, MSVC, and clang). Compiler warnings usually only arise from compilers or compile-time options that the SQLite developers do not use themselves.</source>
          <target state="translated">有些人说,我们应该消除所有的警告,因为良性的警告掩盖了未来变化中可能出现的真实警告。这倒是真的。但在回答中,开发人员观察到,所有的警告都已经在用于SQLite开发的构建中(各种版本的GCC、MSVC和clang)得到了修复。编译器警告通常只产生于编译器或编译时的选项,而SQLite开发者自己并没有使用。</target>
        </trans-unit>
        <trans-unit id="8711937cd8478cc6ecffffaffa9bef747431485f" translate="yes" xml:space="preserve">
          <source>Some people view RELEASE as the equivalent of COMMIT for a SAVEPOINT. This is an acceptable point of view as long as one remembers that the changes committed by an inner transaction might later be undone by a rollback in an outer transaction.</source>
          <target state="translated">有些人认为RELEASE相当于SAVEPOINT的COMMIT。这是一个可以接受的观点,只要我们记住一个内部事务所提交的更改可能会在以后被外部事务的回滚所撤销。</target>
        </trans-unit>
        <trans-unit id="0c7ab5e876e4a01802f6862f91dcb4e0c53f5563" translate="yes" xml:space="preserve">
          <source>Some pragmas take effect during the SQL compilation stage, not the execution stage. This means if using the C-language &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;, &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;, &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; API (or similar in a wrapper interface), the pragma may run during the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; call, not during the &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call as normal SQL statements do. Or the pragma might run during sqlite3_step() just like normal SQL statements. Whether or not the pragma runs during sqlite3_prepare() or sqlite3_step() depends on the pragma and on the specific release of SQLite.</source>
          <target state="translated">有些编译指示在SQL编译阶段而不是执行阶段生效。这意味着，如果使用C语言&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;，&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;，&lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt; API（或在包装程序接口中类似），则编译指示可能在&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;调用期间运行，而不是在&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;调用期间运行，就像普通的SQL一样声明呢。否则，杂注可能会在sqlite3_step（）期间运行，就像正常的SQL语句一样。编译指示是否在sqlite3_prepare（）或sqlite3_step（）期间运行取决于编译指示和SQLite的特定版本。</target>
        </trans-unit>
        <trans-unit id="16b35f88ff5fdb19b220d3f1fb964fe543a7595b" translate="yes" xml:space="preserve">
          <source>Some programmers cannot imagine developing a complex system like SQLite in a language that is not &quot;object oriented&quot;. So why is SQLite not coded in C++ or Java?</source>
          <target state="translated">有些程序员无法想象用一种不是 &quot;面向对象 &quot;的语言来开发像SQLite这样的复杂系统。那么,为什么SQLite没有用C++或Java来编码呢?</target>
        </trans-unit>
        <trans-unit id="b34c6a5bd79eb90989f1ccbc7f5ec2a47398a0d5" translate="yes" xml:space="preserve">
          <source>Some query parameters are interpreted by the SQLite core and used to modify the characteristics of the new connection. All query parameters are always passed through into the xOpen method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; even if they are previously read and interpreted by the SQLite core.</source>
          <target state="translated">一些查询参数由SQLite核心解释，并用于修改新连接的特征。即使所有查询参数先前都是由SQLite核心读取和解释的，也始终传递到&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;的xOpen方法中。</target>
        </trans-unit>
        <trans-unit id="dfe466f14dd2cc6407106f618ec85911c7fcc3f4" translate="yes" xml:space="preserve">
          <source>Some readers might be reluctant to consider SQLite as an application file format because they have been inculcated with the idea that all SQL database schemas must be factored into third normal form and store only small primitive data types such as strings and integers. Certainly relational theory is important and designers should strive to understand it. But, as demonstrated above, it is often quite acceptable to store complex information as XML or JSON in text fields of a database. Do what works, not what your database professor said you ought to do.</source>
          <target state="translated">有些读者可能不愿意考虑将SQLite作为一种应用文件格式,因为他们已经被灌输了这样的思想:所有的SQL数据库模式都必须保理成第三种正常形式,并且只存储小的原始数据类型,如字符串和整数。当然,关系理论是很重要的,设计者应该努力理解它。但是,正如上面所展示的,在数据库的文本字段中以XML或JSON的形式存储复杂的信息往往是很容易接受的。做有效的事情,而不是你的数据库教授说你应该做什么。</target>
        </trans-unit>
        <trans-unit id="da24c123adee2fd8a84517f276f1059ec16db37d" translate="yes" xml:space="preserve">
          <source>Some readers might resist using SQLite as an application file format due to prior exposure to enterprise SQL databases and the caveats and limitations of those other systems. For example, many enterprise database engines advise against storing large strings or BLOBs in the database and instead suggest that large strings and BLOBs be stored as separate files and the filename stored in the database. But SQLite is not like that. Any column of an SQLite database can hold a string or BLOB up to about a gigabyte in size. And for strings and BLOBs of 100 kilobytes or less, &lt;a href=&quot;intern-v-extern-blob&quot;&gt;I/O performance is better&lt;/a&gt; than using separate files.</source>
          <target state="translated">一些读者可能会拒绝使用SQLite作为应用程序文件格式，这是由于先前曾接触过企业SQL数据库以及其他系统的警告和限制。例如，许多企业数据库引擎建议不要在数据库中存储大字符串或BLOB，而建议将大字符串和BLOB作为单独的文件存储，而文件名则存储在数据库中。但是SQLite不是那样的。 SQLite数据库的任何列都可以容纳最大约1 GB的字符串或BLOB。对于100 KB或更小的字符串和BLOB，&lt;a href=&quot;intern-v-extern-blob&quot;&gt;I / O性能&lt;/a&gt;要比使用单独的文件更好。</target>
        </trans-unit>
        <trans-unit id="4623126273e781b93958cb9c59802c9b42b20a62" translate="yes" xml:space="preserve">
          <source>Some sanity checking code was removed from the inner loop of vdbe.c to help the library to run a little faster. The code is only removed if you compile with -DNDEBUG.</source>
          <target state="translated">从vdbe.c的内部循环中删除了一些理智性检查代码,以帮助库运行得更快一些。只有当你使用-DNDEBUG编译时,这些代码才会被删除。</target>
        </trans-unit>
        <trans-unit id="fdb2b13b24f119a63e7d35aeab7a0a13260e1127" translate="yes" xml:space="preserve">
          <source>Some systems (for example, Windows 95) do not support the operation implemented by sqlite3_mutex_try(). On those systems, sqlite3_mutex_try() will always return SQLITE_BUSY. The SQLite core only ever uses sqlite3_mutex_try() as an optimization so this is acceptable behavior.</source>
          <target state="translated">有些系统(例如,Windows 95)不支持由 sqlite3_mutex_try()实现的操作。在这些系统上,sqlite3_mutex_try()将总是返回SQLITE_BUSY。SQLite核心只使用sqlite3_mutex_try()作为优化,所以这是可以接受的行为。</target>
        </trans-unit>
        <trans-unit id="3594c70c212410200cff937ed0dc1d8804fee77c" translate="yes" xml:space="preserve">
          <source>Some virtual table implementations (ex: &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, and &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;) make use of real (non-virtual) database tables to store content. For example, when content is inserted into the FTS3 virtual table, the data is ultimately stored in real tables named &quot;%_content&quot;, &quot;%_segdir&quot;, &quot;%_segments&quot;, &quot;%_stat&quot;, and &quot;%_docsize&quot; where &quot;%&quot; is the name of the original virtual table. This auxiliary real tables that store content for a virtual table are called &quot;shadow tables&quot;. See (&lt;a href=&quot;fts3#*shadowtab&quot;&gt;1&lt;/a&gt;), (&lt;a href=&quot;fts5#appendix_b&quot;&gt;2&lt;/a&gt;), and (&lt;a href=&quot;rtree#xshadow&quot;&gt;3&lt;/a&gt;) for additional information.</source>
          <target state="translated">一些虚拟表实现（例如：&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;，&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;和&lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;）利用真实（非虚拟）数据库表来存储内容。例如，将内容插入FTS3虚拟表时，数据最终存储在名为&amp;ldquo;％_content&amp;rdquo;，&amp;ldquo;％_ segdir&amp;rdquo;，&amp;ldquo;％_ segments&amp;rdquo;，&amp;ldquo;％_ stat&amp;rdquo;和&amp;ldquo;％_docsize&amp;rdquo;的真实表中，其中&amp;ldquo;％&amp;rdquo; &amp;rdquo;是原始虚拟表的名称。存储虚拟表内容的辅助实际表称为&amp;ldquo;影子表&amp;rdquo;。有关更多信息，请参见（&lt;a href=&quot;fts3#*shadowtab&quot;&gt;1&lt;/a&gt;），（&lt;a href=&quot;fts5#appendix_b&quot;&gt;2&lt;/a&gt;）和（&lt;a href=&quot;rtree#xshadow&quot;&gt;3&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ac3c1999dd15ec935e4c05fd2cbb35a8f0236c55" translate="yes" xml:space="preserve">
          <source>Some virtual table implementations may INSERT rows into rowid tables as part of committing a transaction (e.g. to flush data accumulated in memory to disk). In this case subsequent calls to this function return the rowid associated with these internal INSERT operations, which leads to unintuitive results. Virtual table implementations that do write to rowid tables in this way can avoid this problem by restoring the original rowid value using &lt;a href=&quot;#sqlite3_set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid()&lt;/a&gt; before returning control to the user.</source>
          <target state="translated">一些虚拟表实现可能将行插入行标识符表中，作为提交事务的一部分（例如，将存储在内存中的数据刷新到磁盘上）。在这种情况下，对该函数的后续调用将返回与这些内部INSERT操作关联的rowid，这将导致不直观的结果。通过向用户返回控制权之前使用&lt;a href=&quot;#sqlite3_set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid（）&lt;/a&gt;恢复原始rowid值，确实以这种方式写入rowid表的虚拟表实现可以避免此问题。</target>
        </trans-unit>
        <trans-unit id="bf0309e04b01e09dca18924e050475fbb9284235" translate="yes" xml:space="preserve">
          <source>Some virtual table implementations may INSERT rows into rowid tables as part of committing a transaction (e.g. to flush data accumulated in memory to disk). In this case subsequent calls to this function return the rowid associated with these internal INSERT operations, which leads to unintuitive results. Virtual table implementations that do write to rowid tables in this way can avoid this problem by restoring the original rowid value using &lt;a href=&quot;set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid()&lt;/a&gt; before returning control to the user.</source>
          <target state="translated">一些虚拟表实现可能将行插入行标识符表中，作为提交事务的一部分（例如，将存储在内存中的数据刷新到磁盘上）。在这种情况下，对该函数的后续调用将返回与这些内部INSERT操作关联的rowid，这将导致不直观的结果。通过向用户返回控制权之前使用&lt;a href=&quot;set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid（）&lt;/a&gt;恢复原始rowid值，确实以这种方式写入rowid表的虚拟表实现可以避免此问题。</target>
        </trans-unit>
        <trans-unit id="37863aa03861c512ad1c77afb4b6689cfad7493b" translate="yes" xml:space="preserve">
          <source>Some virtual tables exist automatically in the &quot;main&quot; schema of every database connection in which their module is registered, even without a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. Such virtual tables are called &quot;eponymous virtual tables&quot;. To use an eponymous virtual table, simply use the module name as if it were a table. Eponymous virtual tables exist in the &quot;main&quot; schema only, so they will not work if prefixed with a different schema name.</source>
          <target state="translated">即使没有&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;语句，某些虚拟表也会自动存在于其模块已注册到的每个数据库连接的&amp;ldquo;主&amp;rdquo;模式中。这样的虚拟表被称为&amp;ldquo;同名虚拟表&amp;rdquo;。要使用同名的虚拟表，只需像使用表一样使用模块名称即可。同义的虚拟表仅存在于&amp;ldquo;主&amp;rdquo;模式中，因此如果以不同的模式名称作为前缀，则它们将不起作用。</target>
        </trans-unit>
        <trans-unit id="0235dde661a1106f01332ba53a569381817a7286" translate="yes" xml:space="preserve">
          <source>Someone (or some process) might rename the database file but fail to also rename its associated journal.</source>
          <target state="translated">有人(或某些进程)可能会重命名数据库文件,但没有同时重命名其相关的日志。</target>
        </trans-unit>
        <trans-unit id="4532d3d7be4feca574a6f6430b43e863945ec230" translate="yes" xml:space="preserve">
          <source>Sometimes &lt;b&gt;sqlite_exec()&lt;/b&gt; would return SQLITE_PROTOCOL when it should have returned SQLITE_BUSY.</source>
          <target state="translated">有时&lt;b&gt;sqlite_exec（）&lt;/b&gt;在应返回SQLITE_BUSY时会返回SQLITE_PROTOCOL。</target>
        </trans-unit>
        <trans-unit id="dc0c06ae51aa05a33354304329c9c25f09e5959c" translate="yes" xml:space="preserve">
          <source>Sometimes SQLite uses compile-time evaluatable assert() statements. Consider the code at &lt;a href=&quot;https://sqlite.org/src/artifact/c1e97e4c6f?ln=2130-2138&quot;&gt;https://sqlite.org/src/artifact/c1e97e4c6f?ln=2130-2138&lt;/a&gt;. Four assert() statements verify the values for compile-time constants so that the reader can quickly check the validity of the if-statement that follows, without having to look up the constant values in a separate header file.</source>
          <target state="translated">有时，SQLite使用可编译时可评估的assert（）语句。考虑以下代码，&lt;a href=&quot;https://sqlite.org/src/artifact/c1e97e4c6f?ln=2130-2138&quot;&gt;网址&lt;/a&gt;为https://sqlite.org/src/artifact/c1e97e4c6f?ln=2130-2138。四个assert（）语句验证编译时常量的值，以便读者可以快速检查后面的if语句的有效性，而不必在单独的头文件中查找常量值。</target>
        </trans-unit>
        <trans-unit id="e72dc8159e740969eabd99a1be0aa498a87e7c0f" translate="yes" xml:space="preserve">
          <source>Sometimes a LEFT JOIN can be completely omitted from a query without changing the result. This can happen if all of the following are true:</source>
          <target state="translated">有时,LEFT JOIN可以从查询中完全省略而不改变结果。如果以下情况全部为真,就会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="3f8fa5c7b1abe4111bb41632dd1fff37e6c00e99" translate="yes" xml:space="preserve">
          <source>Sometimes a LEFT JOIN can be converted into an ordinary JOIN, if there are terms in the WHERE clause that guarantee that the two joins will give identical results. In particular, if any column in the right-hand table of the LEFT JOIN must be non-NULL in order for the WHERE clause to be true, then the LEFT JOIN is demoted to an ordinary JOIN.</source>
          <target state="translated">有时,如果在WHERE子句中有条款保证两个联接的结果完全相同,那么LEFT JOIN就可以转换为普通JOIN。特别是,如果LEFT JOIN右侧表中的任何一列必须是非NULL才能使WHERE子句为真,那么LEFT JOIN就会降级为普通JOIN。</target>
        </trans-unit>
        <trans-unit id="f090235439a288798f47de0b5a65b1ea028dc3f6" translate="yes" xml:space="preserve">
          <source>Sometimes a power failure will cause a filesystem to be corrupted such that recently changed filenames are forgotten and the file is moved into a &quot;/lost+found&quot; directory. When that happens, the hot journal will not be found and recovery will not occur. SQLite tries to prevent this by opening and syncing the directory containing the rollback journal at the same time it syncs the journal file itself. However, the movement of files into /lost+found can be caused by unrelated processes creating unrelated files in the same directory as the main database file. And since this is out from under the control of SQLite, there is nothing that SQLite can do to prevent it. If you are running on a system that is vulnerable to this kind of filesystem namespace corruption (most modern journalling filesystems are immune, we believe) then you might want to consider putting each SQLite database file in its own private subdirectory.</source>
          <target state="translated">有时,断电会导致文件系统损坏,以至于最近更改的文件名被遗忘,文件被移动到&quot;/lost+found &quot;目录中。当发生这种情况时,将找不到热日志,也就无法恢复。SQLite试图通过在同步日志文件本身的同时打开并同步包含回滚日志的目录来防止这种情况。但是,文件移动到/lost+found中,可能是由于不相关的进程与主数据库文件在同一目录下创建了不相关的文件。而且由于这是从SQLite的控制范围内出来的,所以SQLite也无法阻止。如果你运行的系统容易受到这种文件系统命名空间损坏的影响(我们相信,大多数现代的日记文件系统都是免疫的),那么你可能要考虑将每个SQLite数据库文件放在自己的私有子目录中。</target>
        </trans-unit>
        <trans-unit id="3f9f858786d7c98364aee861ef2804edc03f7313" translate="yes" xml:space="preserve">
          <source>Sometimes applications encounter this error even though there is an abundance of primary disk space because the error occurs when writing into &lt;a href=&quot;tempfiles&quot;&gt;temporary disk files&lt;/a&gt; on a system where temporary files are stored on a separate partition with much less space that the primary disk.</source>
          <target state="translated">有时，即使存在大量的主磁盘空间，应用程序也会遇到此错误，因为在将临时文件存储在单独的分区上的系统上写入&lt;a href=&quot;tempfiles&quot;&gt;临时磁盘文件&lt;/a&gt;时，会发生此错误，而临时文件存储在比主磁盘少的空间上。</target>
        </trans-unit>
        <trans-unit id="fff8b7e3376a922064133232ffd6552acd46f238" translate="yes" xml:space="preserve">
          <source>Sometimes compile-time assert() statements are used to verify that SQLite has been correctly compiled. For example, the code at &lt;a href=&quot;https://sqlite.org/src/artifact/c1e97e4c6f?ln=157&quot;&gt;https://sqlite.org/src/artifact/c1e97e4c6f?ln=157&lt;/a&gt; verifies that the SQLITE_PTRSIZE preprocessor macro is set correctly for the target architecture.</source>
          <target state="translated">有时使用编译时assert（）语句来验证SQLite是否已正确编译。例如，&lt;a href=&quot;https://sqlite.org/src/artifact/c1e97e4c6f?ln=157&quot;&gt;https&lt;/a&gt;：//sqlite.org/src/artifact/c1e97e4c6f？ln = 157上的代码可验证是否为目标体系结构正确设置了SQLITE_PTRSIZE预处理程序宏。</target>
        </trans-unit>
        <trans-unit id="d7e0873ee1e2576915056da7a06e2b494b2dd17f" translate="yes" xml:space="preserve">
          <source>Sometimes only part of an ORDER BY clause can be satisfied using indexes. Consider, for example, the following query:</source>
          <target state="translated">有时,使用索引只能满足ORDER BY子句的一部分。例如,考虑以下查询。</target>
        </trans-unit>
        <trans-unit id="08e9765fc44bda2fdb0012e4541cc28a30458938" translate="yes" xml:space="preserve">
          <source>Sometimes operating systems will exhibit non-standard behavior which can lead to problems. Sometimes this non-standard behavior is deliberate, and sometimes it is a mistake in the implementation. But in any event, if the operating performs differently from they way SQLite expects it to perform, the possibility of database corruption exists.</source>
          <target state="translated">有时操作系统会表现出非标准的行为,从而导致问题。有时这种非标准行为是故意的,有时则是实现中的错误。但无论如何,如果操作系统的执行方式与SQLite期望的执行方式不同,数据库损坏的可能性就存在。</target>
        </trans-unit>
        <trans-unit id="60f1e4ae24175645a79034bd7c885a1e7d0f09d3" translate="yes" xml:space="preserve">
          <source>Sometimes the use of row values just makes the SQL easier to read and write. Consider the following two UPDATE statements:</source>
          <target state="translated">有时使用行值只是让SQL更容易读写。考虑以下两条UPDATE语句。</target>
        </trans-unit>
        <trans-unit id="24e2bab9e04a22b3a6d58f84b00743d3fb69e859" translate="yes" xml:space="preserve">
          <source>Sometimes when this error code is encountered, the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; routine will convert the error into &lt;a href=&quot;rescode#error_retry&quot;&gt;SQLITE_ERROR_RETRY&lt;/a&gt; and try again to prepare the SQL statement using a different query plan that does not require the use of the unknown collating sequence.</source>
          <target state="translated">有时，当遇到此错误代码时，&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;例程会将错误转换为&lt;a href=&quot;rescode#error_retry&quot;&gt;SQLITE_ERROR_RETRY，&lt;/a&gt;然后再次尝试使用不需要使用未知整理顺序的其他查询计划来准备SQL语句。</target>
        </trans-unit>
        <trans-unit id="adc4e96a478be02a8147b100bd68113f38b89f80" translate="yes" xml:space="preserve">
          <source>Sort</source>
          <target state="translated">Sort</target>
        </trans-unit>
        <trans-unit id="5601af90fba7fe38466b58c08c018711849b8855" translate="yes" xml:space="preserve">
          <source>Sort order</source>
          <target state="translated">排序顺序</target>
        </trans-unit>
        <trans-unit id="74ab25d1e3d8ae1cb528685baf2d71b92460809e" translate="yes" xml:space="preserve">
          <source>SorterCompare</source>
          <target state="translated">SorterCompare</target>
        </trans-unit>
        <trans-unit id="e274ec5d63c6eab4a322b40fa92da953e269dcf5" translate="yes" xml:space="preserve">
          <source>SorterData</source>
          <target state="translated">SorterData</target>
        </trans-unit>
        <trans-unit id="84dc5b8de2832faa332b637acd50721fb4db3efe" translate="yes" xml:space="preserve">
          <source>SorterInsert</source>
          <target state="translated">SorterInsert</target>
        </trans-unit>
        <trans-unit id="2737748d72de05dcf6eba2817820522a4badd0ec" translate="yes" xml:space="preserve">
          <source>SorterNext</source>
          <target state="translated">SorterNext</target>
        </trans-unit>
        <trans-unit id="efe2a2f235ed328025a0db49a289c00d154bb3ba" translate="yes" xml:space="preserve">
          <source>SorterOpen</source>
          <target state="translated">SorterOpen</target>
        </trans-unit>
        <trans-unit id="58a2d7ee050bba205b0d21e366ed8ecfcceedf59" translate="yes" xml:space="preserve">
          <source>SorterSort</source>
          <target state="translated">SorterSort</target>
        </trans-unit>
        <trans-unit id="7dadfa55de2cffb43bdf1a8f139a4a743a9af71b" translate="yes" xml:space="preserve">
          <source>Sorting is accomplished by writing records into a sorting index, then rewinding that index and playing it back from beginning to end. We use the &lt;a href=&quot;opcode#Sort&quot;&gt;Sort&lt;/a&gt; opcode instead of &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; to do the rewinding so that the global variable will be incremented and regression tests can determine whether or not the optimizer is correctly optimizing out sorts.</source>
          <target state="translated">排序是通过将记录写入排序索引中，然后倒回该索引并从头到尾播放来完成的。我们使用&lt;a href=&quot;opcode#Sort&quot;&gt;Sort&lt;/a&gt;操作码而不是&lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt;进行倒带，以便全局变量将递增，并且回归测试可以确定优化器是否正确地优化了排序。</target>
        </trans-unit>
        <trans-unit id="94c08b606385251adc6f9a4723f760124243a4d3" translate="yes" xml:space="preserve">
          <source>Sorting subsets of the result</source>
          <target state="translated">对结果的子集进行排序</target>
        </trans-unit>
        <trans-unit id="516e89309d994acf5d94c4a4907b3ff4a8e53a80" translate="yes" xml:space="preserve">
          <source>Source Of Data In A Query Result</source>
          <target state="translated">查询结果中的数据来源</target>
        </trans-unit>
        <trans-unit id="cfbc658da4e64bd6eef7ec70eab5adab3d14a41a" translate="yes" xml:space="preserve">
          <source>Source code for several useful extensions can be found in the &lt;a href=&quot;http://www.sqlite.org/src/tree?name=ext/misc&amp;amp;ci=trunk&quot;&gt;ext/misc&lt;/a&gt; subdirectory of the SQLite source tree. You can use these extensions as-is, or as a basis for creating your own custom extensions to address your own particular needs.</source>
          <target state="translated">可以在SQLite源代码树的&lt;a href=&quot;http://www.sqlite.org/src/tree?name=ext/misc&amp;amp;ci=trunk&quot;&gt;ext / misc&lt;/a&gt;子目录中找到一些有用的扩展的源代码。您可以按原样使用这些扩展，也可以将其作为创建自己的自定义扩展以解决自己的特定需求的基础。</target>
        </trans-unit>
        <trans-unit id="950fc9d085d8682e69cc0123aa548c93074cdbe7" translate="yes" xml:space="preserve">
          <source>Source code for several useful extensions can be found in the &lt;a href=&quot;https://www.sqlite.org/src/tree?name=ext/misc&amp;amp;ci=trunk&quot;&gt;ext/misc&lt;/a&gt; subdirectory of the SQLite source tree. You can use these extensions as-is, or as a basis for creating your own custom extensions to address your own particular needs.</source>
          <target state="translated">可以在SQLite源树的&lt;a href=&quot;https://www.sqlite.org/src/tree?name=ext/misc&amp;amp;ci=trunk&quot;&gt;ext / misc&lt;/a&gt;子目录中找到一些有用的扩展的源代码。您可以按原样使用这些扩展，也可以将其作为创建自己的自定义扩展来满足自己的特定需求的基础。</target>
        </trans-unit>
        <trans-unit id="64243b8fe27d8786b74ebe9ad360b0c831315629" translate="yes" xml:space="preserve">
          <source>Sources are in the &lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;public domain&lt;/a&gt;. Use for any purpose.</source>
          <target state="translated">来源是&lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;公共领域的&lt;/a&gt;。用于任何目的。</target>
        </trans-unit>
        <trans-unit id="bdb7e396773f80244c6756a8ac8a3ba107260e6f" translate="yes" xml:space="preserve">
          <source>Spatial indices using &lt;a href=&quot;rtree&quot;&gt;R-Trees&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;rtree&quot;&gt;R树的&lt;/a&gt;空间索引</target>
        </trans-unit>
        <trans-unit id="7f329318e826b6123bdadb48df921310c8b500b7" translate="yes" xml:space="preserve">
          <source>Speak no useless words or words that move to laughter.</source>
          <target state="translated">不说无用的话,也不说让人动容的话语。</target>
        </trans-unit>
        <trans-unit id="9cda32c171792b8ebd4697561ad451beebb8dd76" translate="yes" xml:space="preserve">
          <source>Special INSERT operates can be used to issue commands to FTS3 and FTS4 tables. Every FTS3 and FTS4 has a hidden, read-only column which is the same name as the table itself. INSERTs into this hidden column are interpreted as commands to the FTS3/4 table. For a table with the name &quot;xyz&quot; the following commands are supported:</source>
          <target state="translated">特殊的INSERT操作可以用来向FTS3和FTS4表发出命令。每个FTS3和FTS4表都有一个隐藏的、只读的列,其名称与表本身相同。对这个隐藏列的INSERT被解释为对FTS3/4表的命令。对于名称为 &quot;xyz &quot;的表,支持以下命令。</target>
        </trans-unit>
        <trans-unit id="5c62a06b3206449dc4ac80333e6db0c204db7ba5" translate="yes" xml:space="preserve">
          <source>Special processing occurs when the aggregate function is either &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;min()&lt;/a&gt; or &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;max()&lt;/a&gt;. Example:</source>
          <target state="translated">当聚合函数为&lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;min（）&lt;/a&gt;或&lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;max（）&lt;/a&gt;时，将进行特殊处理。例：</target>
        </trans-unit>
        <trans-unit id="6937900c4a39aa0fb125a152dfd5d62be4f8822d" translate="yes" xml:space="preserve">
          <source>Special sqlite_stat1 Handling</source>
          <target state="translated">特殊 sqlite_stat1 处理</target>
        </trans-unit>
        <trans-unit id="1e4c6816e6235fac1910f655a4449098f3bab054" translate="yes" xml:space="preserve">
          <source>Special versions of the SQLite amalgamation that do work with a predetermined set of SQLITE_OMIT_* options can be generated. To do so, make a copy of the Makefile.linux-gcc makefile template in the canonical source code distribution. Change the name of your copy to simply &quot;Makefile&quot;. Then edit &quot;Makefile&quot; to set up appropriate compile-time options. Then type:</source>
          <target state="translated">可以生成特殊版本的SQLite amalgamation,这些版本的SQLite amalgamation确实可以与一组预定的SQLITE_OMIT_*选项一起工作。要做到这一点,请在规范的源代码发行版中制作一份Makefile.linux-gcc makefile模板的副本。将副本的名称改为 &quot;Makefile&quot;。然后编辑 &quot;Makefile &quot;来设置适当的编译时选项。然后输入</target>
        </trans-unit>
        <trans-unit id="348842ed415067bf469c3c07cbca8231199b183f" translate="yes" xml:space="preserve">
          <source>Specialized applications for which the default implementation of shared memory is unacceptable can devise alternative methods via a custom &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. For example, if it is known that a particular database will only be accessed by threads within a single process, the wal-index can be implemented using heap memory instead of true shared memory.</source>
          <target state="translated">不能接受共享内存的默认实现的特殊应用程序可以通过自定义&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;设计替代方法。例如，如果已知特定数据库仅由单个进程中的线程访问，则可以使用堆内存而不是真正的共享内存来实现wal-index。</target>
        </trans-unit>
        <trans-unit id="a647b0621c3756491eb85db442ab54ae4811cd09" translate="yes" xml:space="preserve">
          <source>Specific pragma statements may be removed and others added in future releases of SQLite. There is no guarantee of backwards compatibility.</source>
          <target state="translated">在未来的SQLite版本中,可能会删除特定的pragma语句,并添加其他语句。不保证向后的兼容性。</target>
        </trans-unit>
        <trans-unit id="32a894085a5589da14805f40b5e5ec42d34bdb30" translate="yes" xml:space="preserve">
          <source>Specify an alternative malloc implementation using the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; verb with the &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; object.</source>
          <target state="translated">使用带有&lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;对象的&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;动词指定替代的malloc实现。</target>
        </trans-unit>
        <trans-unit id="7969816e7b05b7f6c6da58d9c3d55a797859dc5f" translate="yes" xml:space="preserve">
          <source>Specify an alternative mutex implementation using the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; verb with the &lt;a href=&quot;c3ref/mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; object.</source>
          <target state="translated">使用带有&lt;a href=&quot;c3ref/mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt;对象的&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt;动词来指定备用互斥体实现。</target>
        </trans-unit>
        <trans-unit id="e7d9e8c303af8fa2eba928e74e37e3e2d5b8ccc2" translate="yes" xml:space="preserve">
          <source>Specify an application-defined page cache.</source>
          <target state="translated">指定应用程序定义的页面缓存。</target>
        </trans-unit>
        <trans-unit id="675036f344331d67d2ac3929e1284013b1817b31" translate="yes" xml:space="preserve">
          <source>Specifying a new page size does not change the page size immediately. Instead, the new page size is remembered and is used to set the page size when the database is first created, if it does not already exist when the page_size pragma is issued, or at the next &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command that is run on the same database connection while not in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">指定新的页面大小不会立即更改页面大小。相反，新的页面大小会被记住，并在首次创建数据库时，如果在发出page_size编译指示时或在同一数据库连接上运行的下一个&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令尚不存在时用于设置页面大小不处于&lt;a href=&quot;wal&quot;&gt;WAL模式时&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dfdc7dcd44b7642ef54261a530f0a8d271e92800" translate="yes" xml:space="preserve">
          <source>Specifying an explicit value for the rowid field as part of an INSERT statement is not supported. Any value supplied is ignored.</source>
          <target state="translated">不支持为rowid字段指定一个显式值作为INSERT语句的一部分。任何提供的值都会被忽略。</target>
        </trans-unit>
        <trans-unit id="ff83e10cd15a3b1a3684d12025d600161e1e03fe" translate="yes" xml:space="preserve">
          <source>Specifying an unknown parameter in the query component of a URI is not an error. Future versions of SQLite might understand additional query parameters. See &quot;&lt;a href=&quot;../uri#coreqp&quot;&gt;query parameters with special meaning to SQLite&lt;/a&gt;&quot; for additional information.</source>
          <target state="translated">在URI的查询组件中指定未知参数不是错误。SQLite的未来版本可能会了解其他查询参数。有关更多信息，请参见&amp;ldquo; &lt;a href=&quot;../uri#coreqp&quot;&gt;对SQLite具有特殊含义的查询参数&lt;/a&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ca08c5f93bc177c41e9e1cbac8bb1b05f691f402" translate="yes" xml:space="preserve">
          <source>Specifying an unknown parameter in the query component of a URI is not an error. Future versions of SQLite might understand additional query parameters. See &quot;&lt;a href=&quot;uri#coreqp&quot;&gt;query parameters with special meaning to SQLite&lt;/a&gt;&quot; for additional information.</source>
          <target state="translated">在URI的查询组件中指定未知参数不是错误。SQLite的未来版本可能会了解其他查询参数。有关更多信息，请参见&amp;ldquo; &lt;a href=&quot;uri#coreqp&quot;&gt;对SQLite具有特殊含义的查询参数&lt;/a&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b5466deac546a32beeffc729c74a6e5fd300f895" translate="yes" xml:space="preserve">
          <source>Specifying three arguments when creating an fts5vocab table in any database other than &quot;temp&quot; results in an error.</source>
          <target state="translated">当在 &quot;temp &quot;以外的任何数据库中创建fts5vocab表时,指定三个参数会导致错误。</target>
        </trans-unit>
        <trans-unit id="076b62c1c3d09beab9691ee6f442faa2e62ef7a7" translate="yes" xml:space="preserve">
          <source>Speed improvements</source>
          <target state="translated">提高速度</target>
        </trans-unit>
        <trans-unit id="65d5a13bd4511e6816f18d10b6fcf53288c30d62" translate="yes" xml:space="preserve">
          <source>Speed improvements and library footprint reductions.</source>
          <target state="translated">提高速度,减少图书馆足迹。</target>
        </trans-unit>
        <trans-unit id="886fdbf5bb356c1170f6be819f95ecf4cc1461e3" translate="yes" xml:space="preserve">
          <source>Speed improvements in the VDBE.</source>
          <target state="translated">VDBE的速度提高。</target>
        </trans-unit>
        <trans-unit id="67d42db811b80e228f8d1a0a01dc2cacac3b1009" translate="yes" xml:space="preserve">
          <source>Speed improvements in the btree and pager layers.</source>
          <target state="translated">提高btree和pager层的速度。</target>
        </trans-unit>
        <trans-unit id="0da1385bd95c04e2cef432911cc39014873cc087" translate="yes" xml:space="preserve">
          <source>Speed improvements: Do not do synchronous updates on TEMP tables.</source>
          <target state="translated">速度改进。不对腾博会登录表进行同步更新。</target>
        </trans-unit>
        <trans-unit id="77d342a78b198923e433b8a1315c81a6ffbf9833" translate="yes" xml:space="preserve">
          <source>Split amalgamation</source>
          <target state="translated">分离式合并</target>
        </trans-unit>
        <trans-unit id="1dac9d1634f1fa754c9cb08212550ad68bf6b1f7" translate="yes" xml:space="preserve">
          <source>Split the pager subsystem into separate pager and pcache subsystems.</source>
          <target state="translated">将寻呼机子系统拆分为单独的寻呼机和pcache子系统。</target>
        </trans-unit>
        <trans-unit id="1bb46447f9362d79f903651b48710b55ec51dd8a" translate="yes" xml:space="preserve">
          <source>Splitting content into smaller pieces also helps File/Save operations to go faster. Instead of having to write back the content of all pages when doing a File/Save, the application only has to write back those pages that have actually changed.</source>
          <target state="translated">将内容分割成更小的片段也有助于File/Save操作的速度。在进行文件/保存时,应用程序不必回写所有页面的内容,而只需要回写那些实际发生变化的页面。</target>
        </trans-unit>
        <trans-unit id="f0b1c55ba41f5df4c296b1603dd8662a874ad05f" translate="yes" xml:space="preserve">
          <source>SqlExec</source>
          <target state="translated">SqlExec</target>
        </trans-unit>
        <trans-unit id="21ba7365f757b4f24cbf08b5870a91de5cd965d8" translate="yes" xml:space="preserve">
          <source>Sqldiff --rbu</source>
          <target state="translated">Sqldiff --rbu</target>
        </trans-unit>
        <trans-unit id="785ca9526809c90e3417966be7d5844fd2a0c5c8" translate="yes" xml:space="preserve">
          <source>Stability</source>
          <target state="translated">Stability</target>
        </trans-unit>
        <trans-unit id="d96e5b2dd07c1733b2b013bd82922c22baade37d" translate="yes" xml:space="preserve">
          <source>Stable</source>
          <target state="translated">Stable</target>
        </trans-unit>
        <trans-unit id="ed9cb8071fd38e38b556df67e342f21ef7bd62db" translate="yes" xml:space="preserve">
          <source>Stable interfaces will be maintained indefinitely in a backwards compatible way. An application that uses only stable interfaces should always be able to relink against a newer version of SQLite without any changes.</source>
          <target state="translated">稳定的接口将以向后兼容的方式无限期地被维护。一个只使用稳定接口的应用程序应该总是能够在不做任何改变的情况下重新链接到一个较新版本的SQLite。</target>
        </trans-unit>
        <trans-unit id="9d69ca23f60003536eb90ef7c1a45510967cd2a5" translate="yes" xml:space="preserve">
          <source>Stale file descriptor</source>
          <target state="translated">陈旧的文件描述符</target>
        </trans-unit>
        <trans-unit id="aaf4ee63c814f2ac7a90ca00e168f99ba47070e5" translate="yes" xml:space="preserve">
          <source>Standard File Control Opcodes</source>
          <target state="translated">标准文件控制操作码</target>
        </trans-unit>
        <trans-unit id="0271f691eaa2014cfdc1f8a7ed1187c67c1f03ee" translate="yes" xml:space="preserve">
          <source>Standard Query Syntax Precedence</source>
          <target state="translated">标准查询语法优先</target>
        </trans-unit>
        <trans-unit id="62af2c2f7d7a242deb88ffff88441215850f0cf0" translate="yes" xml:space="preserve">
          <source>Standard builds include the default &quot;unix&quot; or &quot;win32&quot; VFSes. But if you use the -DOS_OTHER=1 compile-time option, then SQLite is built without a default VFS. In that case, the application must register at least one VFS prior to calling &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;. This is the approach that embedded applications should use. Rather than modifying the SQLite source to insert an alternative OS layer as was done in prior releases of SQLite, instead compile an unmodified SQLite source file (preferably the amalgamation) with the -DOS_OTHER=1 option, then invoke &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; to define the interface to the underlying filesystem prior to creating any database connections.</source>
          <target state="translated">标准版本包括默认的&amp;ldquo; unix&amp;rdquo;或&amp;ldquo; win32&amp;rdquo; VFS。但是，如果使用-DOS_OTHER = 1编译时选项，则将在没有默认VFS的情况下构建SQLite。在这种情况下，应用程序必须在调用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;之前至少注册一个VFS 。这是嵌入式应用程序应使用的方法。与其像以前版本的SQLite一样修改SQLite源以插入备用OS层，而是使用-DOS_OTHER = 1选项编译未修改的SQLite源文件（最好是合并），然后调用&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;定义接口创建任何数据库连接之前，请先连接到基础文件系统。</target>
        </trans-unit>
        <trans-unit id="f4bb77fea34e91bf036ddd54845284d1cf9ef7e7" translate="yes" xml:space="preserve">
          <source>Standard builds of SQLite for Unix or Windows come with a single VFS named &quot;unix&quot; or &quot;win32&quot;, as appropriate. This one VFS is also the default. So if you are using the legacy open functions, everything will continue to operate as it has before. The change is that an application now has the flexibility of adding new VFS modules to implement a customized OS layer. The &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; API can be used to tell SQLite about one or more application-defined VFS modules:</source>
          <target state="translated">适用于Unix或Windows的SQLite的标准构建带有一个名为&amp;ldquo; unix&amp;rdquo;或&amp;ldquo; win32&amp;rdquo;的VFS（视情况而定）。该VFS也是默认的。因此，如果您使用的是旧式开放功能，则所有内容将继续像以前一样运行。更改是，应用程序现在可以灵活地添加新的VFS模块，以实现自定义的OS层。所述&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt; API可用于告诉SQLite的关于一个或多个应用程序定义的VFS模块：</target>
        </trans-unit>
        <trans-unit id="d9cadaed061bc7503c3155b4851296844f6b19b6" translate="yes" xml:space="preserve">
          <source>Start a read transaction on an historical snapshot</source>
          <target state="translated">在历史快照上启动一个读取事务</target>
        </trans-unit>
        <trans-unit id="789445bbe2e230b404b0877611cb047ff79a2a8a" translate="yes" xml:space="preserve">
          <source>Start a transaction.</source>
          <target state="translated">开始交易。</target>
        </trans-unit>
        <trans-unit id="5ad3ad0c5dcdfd16f6c5507085aa11afef993658" translate="yes" xml:space="preserve">
          <source>Start the &lt;b&gt;sqlite3&lt;/b&gt; program by typing &quot;sqlite3&quot; at the command prompt, optionally followed by the name the file that holds the SQLite database (or &lt;a href=&quot;#zipdb&quot;&gt;ZIP archive&lt;/a&gt;). If the named file does not exist, a new database file with the given name will be created automatically. If no database file is specified on the command-line, a temporary database is created, then deleted when the &quot;sqlite3&quot; program exits.</source>
          <target state="translated">通过在命令提示符下键入&amp;ldquo; sqlite3&amp;rdquo;来启动&lt;b&gt;sqlite3&lt;/b&gt;程序，还可以在其后跟随一个名称，该名称用于保存SQLite数据库（或&lt;a href=&quot;#zipdb&quot;&gt;ZIP存档&lt;/a&gt;）。如果命名文件不存在，将自动创建具有给定名称的新数据库文件。如果在命令行上未指定数据库文件，则会创建一个临时数据库，然后在退出&amp;ldquo; sqlite3&amp;rdquo;程序时将其删除。</target>
        </trans-unit>
        <trans-unit id="b65d3b5410040822706753355b83a262ca2b3805" translate="yes" xml:space="preserve">
          <source>Start the &lt;b&gt;sqlite3&lt;/b&gt; program by typing &quot;sqlite3&quot; at the command prompt, optionally followed by the name the file that holds the SQLite database. If the named file does not exist, a new database file with the given name will be created automatically. If no database file is specified on the command-line, a temporary database is created, then deleted when the &quot;sqlite3&quot; program exits.</source>
          <target state="translated">通过在命令提示符下键入&amp;ldquo; sqlite3&amp;rdquo;来启动&lt;b&gt;sqlite3&lt;/b&gt;程序，还可以在其后跟随一个名称，该名称用于保存SQLite数据库。如果命名文件不存在，将自动创建具有给定名称的新数据库文件。如果在命令行上未指定数据库文件，则会创建一个临时数据库，然后在退出&amp;ldquo; sqlite3&amp;rdquo;程序时将其删除。</target>
        </trans-unit>
        <trans-unit id="9eb60319509fec567263f40a7e8bf18c02dfd219" translate="yes" xml:space="preserve">
          <source>Starting with &lt;a href=&quot;https://sqlite.org/releaselog/3_3_0.html&quot;&gt;version 3.3.0&lt;/a&gt; (2006-01-11), SQLite includes a special &quot;shared-cache&quot; mode (disabled by default) intended for use in embedded servers. If shared-cache mode is enabled and a thread establishes multiple connections to the same database, the connections share a single data and schema cache. This can significantly reduce the quantity of memory and IO required by the system.</source>
          <target state="translated">从&lt;a href=&quot;https://sqlite.org/releaselog/3_3_0.html&quot;&gt;版本3.3.0&lt;/a&gt;（2006-01-11）开始，SQLite包括一种特殊的&amp;ldquo;共享缓存&amp;rdquo;模式（默认情况下禁用），旨在用于嵌入式服务器。如果启用了共享缓存模式，并且线程建立了到同一数据库的多个连接，则这些连接共享单个数据和架构缓存。这样可以大大减少系统所需的内存和IO数量。</target>
        </trans-unit>
        <trans-unit id="023a31bfb8ddab03b504852064e49a20e7d9d830" translate="yes" xml:space="preserve">
          <source>Startup time is reduced by allowing the application to read in only the content shown for the initial screen. This largely eliminates the need to show a progress bar when opening a new document. The document just pops up immediately, further enhancing the user experience.</source>
          <target state="translated">通过允许应用程序只读取初始屏幕显示的内容,减少了启动时间。这在很大程度上消除了打开新文档时显示进度条的需要。文档只是立即弹出,进一步提升了用户体验。</target>
        </trans-unit>
        <trans-unit id="ec7c6f024748b0b4ca685edf7c9c36a22ff2bd48" translate="yes" xml:space="preserve">
          <source>Statement Rollback</source>
          <target state="translated">声明回滚</target>
        </trans-unit>
        <trans-unit id="b1c7b81be5c9efcc042ff8389d0cd187913125cb" translate="yes" xml:space="preserve">
          <source>Statement Transactions</source>
          <target state="translated">报表交易</target>
        </trans-unit>
        <trans-unit id="a90f613a0e148cacdfc6a3c9d8b61b95e2acb93e" translate="yes" xml:space="preserve">
          <source>Statement journal</source>
          <target state="translated">报表期刊</target>
        </trans-unit>
        <trans-unit id="eb1040e934c3b0c196798a9d1961f27355d86e45" translate="yes" xml:space="preserve">
          <source>Statement journals</source>
          <target state="translated">报表期刊</target>
        </trans-unit>
        <trans-unit id="ff8ba443e0e2998259e771cf2ecb0604dd034de1" translate="yes" xml:space="preserve">
          <source>Static analysis has not been helpful in finding bugs in SQLite. Static analysis has found a few bugs in SQLite, but those are the exceptions. More bugs have been introduced into SQLite while trying to get it to compile without warnings than have been found by static analysis.</source>
          <target state="translated">静态分析对发现SQLite中的bug没有帮助。静态分析在SQLite中发现了一些bug,但那是例外。比起静态分析发现的错误,更多的错误被引入到SQLite中,而试图让它在编译时不发出警告。</target>
        </trans-unit>
        <trans-unit id="680999abb1389f8c322acbd6c1aa5dbe84be6521" translate="yes" xml:space="preserve">
          <source>Static analysis means analyzing source code at compile-time to check for correctness. Static analysis includes compiler warning messages and more in-depth analysis engines such as the &lt;a href=&quot;http://clang-analyzer.llvm.org/&quot;&gt;Clang Static Analyzer&lt;/a&gt;. SQLite compiles without warnings on GCC and Clang using the -Wall and -Wextra flags on Linux and Mac and on MSVC on Windows. No valid warnings are generated by the Clang Static Analyzer tool &quot;scan-build&quot; either (though recent versions of clang seem to generate many false-positives.) Nevertheless, some warnings might be generated by other static analyzers. Users are encouraged not to stress over these warnings and to instead take solace in the intense testing of SQLite described above.</source>
          <target state="translated">静态分析意味着在编译时分析源代码以检查正确性。静态分析包括编译器警告消息和更深入的分析引擎，例如&lt;a href=&quot;http://clang-analyzer.llvm.org/&quot;&gt;Clang Static Analyzer&lt;/a&gt;。在Linux和Mac以及Windows的MSVC上，使用-Wall和-Wextra标志在GCC和Clang上进行SQLite编译时不会发出警告。 Clang静态分析器工具&amp;ldquo; scan-build&amp;rdquo;也不会生成任何有效的警告（尽管最新版本的clang似乎会生成许多误报。）但是，其他静态分析器可能会生成一些警告。鼓励用户不要对这些警告施加压力，而应在上述SQLite的严格测试中寻求安慰。</target>
        </trans-unit>
        <trans-unit id="a8a7d3c3c3020e91e0baa9412b077479decb0556" translate="yes" xml:space="preserve">
          <source>Static analysis means analyzing source code at compile-time to check for correctness. Static analysis includes compiler warning messages and more in-depth analysis engines such as the &lt;a href=&quot;https://clang-analyzer.llvm.org/&quot;&gt;Clang Static Analyzer&lt;/a&gt;. SQLite compiles without warnings on GCC and Clang using the -Wall and -Wextra flags on Linux and Mac and on MSVC on Windows. No valid warnings are generated by the Clang Static Analyzer tool &quot;scan-build&quot; either (though recent versions of clang seem to generate many false-positives.) Nevertheless, some warnings might be generated by other static analyzers. Users are encouraged not to stress over these warnings and to instead take solace in the intense testing of SQLite described above.</source>
          <target state="translated">静态分析意味着在编译时分析源代码以检查其正确性。静态分析包括编译器警告消息和更深入的分析引擎，例如&lt;a href=&quot;https://clang-analyzer.llvm.org/&quot;&gt;Clang Static Analyzer&lt;/a&gt;。在Linux和Mac以及Windows的MSVC上，SQLite使用-Wall和-Wextra标志在GCC和Clang上进行编译时不会发出警告。 Clang静态分析器工具&amp;ldquo; scan-build&amp;rdquo;也不会生成任何有效的警告（尽管最新版本的clang似乎会生成许多误报。）但是，其他静态分析器可能会生成一些警告。鼓励用户不要对这些警告施加压力，而应在上述SQLite的严格测试中寻求安慰。</target>
        </trans-unit>
        <trans-unit id="5e49731cc0b88e4893c23ef28a83ddda3bfb212a" translate="yes" xml:space="preserve">
          <source>Statistics gathered by ANALYZE are not automatically updated as the content of the database changes. If the content of the database changes significantly, or if the database schema changes, then one should consider rerunning the ANALYZE command in order to update the statistics.</source>
          <target state="translated">ANALYZE收集的统计数据不会随着数据库内容的变化而自动更新。如果数据库的内容发生了很大的变化,或者数据库的模式发生了变化,那么应该考虑重新运行ANALYZE命令来更新统计数据。</target>
        </trans-unit>
        <trans-unit id="06d77b9bb2436857be2774ccf495a6735714ef3f" translate="yes" xml:space="preserve">
          <source>Statistics might not be available for all loops in all statements. In cases where there exist loops with no available statistics, this function behaves as if the loop did not exist - it returns non-zero and leave the variable that pOut points to unchanged.</source>
          <target state="translated">在所有的语句中,可能并不是所有的循环都有统计数据。在存在没有可用统计数据的循环的情况下,这个函数的行为就像循环不存在一样--它返回非零,并保持pOut指向的变量不变。</target>
        </trans-unit>
        <trans-unit id="bc97dbd639562aa95bfaa677d2f8dc3487a559db" translate="yes" xml:space="preserve">
          <source>Stats pragma</source>
          <target state="translated">统计学原理</target>
        </trans-unit>
        <trans-unit id="df542e628beff2a0b73ed1e479f1091511d9cd6a" translate="yes" xml:space="preserve">
          <source>Status Of A Dynamic String</source>
          <target state="translated">动态字符串的状态</target>
        </trans-unit>
        <trans-unit id="6872312ea81433049bd70deac565b5d633fd6998" translate="yes" xml:space="preserve">
          <source>Status Parameters</source>
          <target state="translated">状态参数</target>
        </trans-unit>
        <trans-unit id="2adc22e7dbafa333d0e47ced61c20bab368c7387" translate="yes" xml:space="preserve">
          <source>Status Parameters for database connections</source>
          <target state="translated">数据库连接的状态参数</target>
        </trans-unit>
        <trans-unit id="8499ef2845b7984472eeaa5eec92eef3c3ddc5e1" translate="yes" xml:space="preserve">
          <source>Status Parameters for prepared statements</source>
          <target state="translated">准备好的报表的状态参数</target>
        </trans-unit>
        <trans-unit id="f04daddc4070fdc058ac9e443c8962cff2f5d578" translate="yes" xml:space="preserve">
          <source>Sticky &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; or &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; errors in the pager are reset when a new transaction is started.</source>
          <target state="translated">启动新事务时，将重置寻呼机中的粘性&lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;或&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;错误。</target>
        </trans-unit>
        <trans-unit id="dd4fde80455d82361972cd992928272cdd38d544" translate="yes" xml:space="preserve">
          <source>Storage class</source>
          <target state="translated">存储类</target>
        </trans-unit>
        <trans-unit id="0adf951cb70d6bfcdd293ee933bb14acec2e8923" translate="yes" xml:space="preserve">
          <source>Storage space for &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects.</source>
          <target state="translated">&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;对象的存储空间。</target>
        </trans-unit>
        <trans-unit id="fbf3f676fb55796ce1a966642440eafe303dfddd" translate="yes" xml:space="preserve">
          <source>Storage used for</source>
          <target state="translated">用于储存</target>
        </trans-unit>
        <trans-unit id="7a5447c3e2de40c5c68aa31375241b98a076167c" translate="yes" xml:space="preserve">
          <source>Store an &lt;a href=&quot;undoredo&quot;&gt;automated undo/redo stack&lt;/a&gt; in a database table so that Undo could go back into prior edit sessions.</source>
          <target state="translated">将&lt;a href=&quot;undoredo&quot;&gt;自动撤消/重做堆栈存储&lt;/a&gt;在数据库表中，以便撤消可以返回到先前的编辑会话。</target>
        </trans-unit>
        <trans-unit id="a49a369d4dc034b2ddab0ef35e3bc0a19be08a8f" translate="yes" xml:space="preserve">
          <source>Store in register P2 an integer which is the key of the table entry that P1 is currently point to.</source>
          <target state="translated">在寄存器P2中存储一个整数,这个整数是P1当前指向的表项的键。</target>
        </trans-unit>
        <trans-unit id="867b15696e9fa5010d6dcd54eb51b1ee5a1a7a9e" translate="yes" xml:space="preserve">
          <source>Store in register P3 the value of the P2-th column of the current row of the virtual-table of cursor P1.</source>
          <target state="translated">在寄存器P3中存储游标P1的虚拟表当前行的P2-th列的值。</target>
        </trans-unit>
        <trans-unit id="c36766981b9139e0da225001d40b99095efc88b9" translate="yes" xml:space="preserve">
          <source>Store in register r[P3] the byte offset into the database file that is the start of the payload for the record at which that cursor P1 is currently pointing.</source>
          <target state="translated">在寄存器r[P3]中存储进入数据库文件的字节偏移量,该偏移量是该游标P1当前所指向的记录的有效载荷的开始。</target>
        </trans-unit>
        <trans-unit id="30c620766d52d9f14ee6085868bffd5fb7f16c25" translate="yes" xml:space="preserve">
          <source>Store new polygons in the table using ordinary INSERT statements:</source>
          <target state="translated">使用普通INSERT语句在表中存储新的多边形。</target>
        </trans-unit>
        <trans-unit id="e312586c7080f660b8a13dd56528c07ac821e623" translate="yes" xml:space="preserve">
          <source>Store the maximum page count after the change in register P2.</source>
          <target state="translated">在寄存器P2中存储变化后的最大页数。</target>
        </trans-unit>
        <trans-unit id="4a03a2e19022832dfb9661ede226d69d6b142a41" translate="yes" xml:space="preserve">
          <source>Store the number of entries (an integer value) in the table or index opened by cursor P1 in register P2</source>
          <target state="translated">将游标P1打开的表或索引中的条目数(一个整数值)存储在寄存器P2中。</target>
        </trans-unit>
        <trans-unit id="8f97ad7b80660d239651ee854a82a3871ca04288" translate="yes" xml:space="preserve">
          <source>Store the number of entries (an integer value) in the table or index opened by cursor P1 in register P2.</source>
          <target state="translated">将游标P1打开的表或索引中的条目数(一个整数值)存储在寄存器P2中。</target>
        </trans-unit>
        <trans-unit id="640b00f8e936acd9d22458864812f703b6f037f6" translate="yes" xml:space="preserve">
          <source>Store the statement journal in the temporary file directory instead of collocated with the database file.</source>
          <target state="translated">将报表日志存储在临时文件目录下,而不是与数据库文件合用。</target>
        </trans-unit>
        <trans-unit id="25a1d24f343a9c4193ce3147697d66befd80ac3b" translate="yes" xml:space="preserve">
          <source>Storing the schema a text also makes the &lt;a href=&quot;fileformat2&quot;&gt;SQLite database file format&lt;/a&gt; easier to define, document, and understand. This helps make SQLite database files a &lt;a href=&quot;locrsf&quot;&gt;recommended storage format&lt;/a&gt; for long-term archiving of data.</source>
          <target state="translated">存储模式文本还可以使&lt;a href=&quot;fileformat2&quot;&gt;SQLite数据库文件格式&lt;/a&gt;更易于定义，记录和理解。这有助于使SQLite数据库文件成为&lt;a href=&quot;locrsf&quot;&gt;推荐的存储格式，&lt;/a&gt;以便长期存档数据。</target>
        </trans-unit>
        <trans-unit id="6734d41851e3e8e6c6cbda317484954f124d2cf8" translate="yes" xml:space="preserve">
          <source>Storing the schema as text also makes the &lt;a href=&quot;fileformat2&quot;&gt;SQLite database file format&lt;/a&gt; easier to define, document, and understand. This helps make SQLite database files a &lt;a href=&quot;locrsf&quot;&gt;recommended storage format&lt;/a&gt; for long-term archiving of data.</source>
          <target state="translated">将模式存储为文本还可以使&lt;a href=&quot;fileformat2&quot;&gt;SQLite数据库文件格式&lt;/a&gt;更易于定义，记录和理解。这有助于使SQLite数据库文件成为&lt;a href=&quot;locrsf&quot;&gt;推荐的存储格式，&lt;/a&gt;以便长期存档数据。</target>
        </trans-unit>
        <trans-unit id="9347ad87d0fbebdfc89e77280c0ab0e8462e84d1" translate="yes" xml:space="preserve">
          <source>Storing the schema as text rather than as parsed tables also give flexibility to the implementation. Since the internal parse of the schema is regenerated each time the database is opened, the internal representation of the schema can change from one release to the next. This is important, as sometimes new features require enhancements to the internal schema representation. Changing the internal schema representation would be much more difficult if the schema representation was exposed in the database file. So, in other words, storing the schema as text helps maintain backwards compatibility, and helps ensure that older database files can be read and written by newer versions of SQLite.</source>
          <target state="translated">将模式存储为文本而不是解析表,也给实施带来了灵活性。由于每次打开数据库时,模式的内部解析都会重新生成,所以模式的内部表示可以从一个版本到下一个版本发生变化。这一点很重要,因为有时新功能需要增强内部模式表示。如果在数据库文件中暴露出模式表示,改变内部模式表示将更加困难。所以,换句话说,将模式存储为文本有助于保持向后的兼容性,并有助于确保较旧的数据库文件可以被较新版本的SQLite读取和写入。</target>
        </trans-unit>
        <trans-unit id="275b8884950b47fafacc5239216411e5afbdc454" translate="yes" xml:space="preserve">
          <source>Streaming Versions of API functions</source>
          <target state="translated">API函数的流式版本</target>
        </trans-unit>
        <trans-unit id="1cda8a5c429d321cd55319d79be9050795d95668" translate="yes" xml:space="preserve">
          <source>Streaming Versions of API functions.</source>
          <target state="translated">API函数的流式版本。</target>
        </trans-unit>
        <trans-unit id="41b71513a74ee80684014356a0159868598a4ea7" translate="yes" xml:space="preserve">
          <source>Streaming function</source>
          <target state="translated">流动功能</target>
        </trans-unit>
        <trans-unit id="c76c18624ee750ab230cd2529398af4c90203056" translate="yes" xml:space="preserve">
          <source>Strengthen defenses against deliberately corrupted database files.</source>
          <target state="translated">加强对故意破坏数据库文件的防御。</target>
        </trans-unit>
        <trans-unit id="70d422bf6680eb42d320cae6dd4ad922e3705a6b" translate="yes" xml:space="preserve">
          <source>Strictly speaking, the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object is not required since the convenience wrapper interfaces, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec&lt;/a&gt; or &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table&lt;/a&gt;, can be used and these convenience wrappers encapsulate and hide the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object. Nevertheless, an understanding of &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; is needed to make full use of SQLite.</source>
          <target state="translated">严格来讲，不需要&lt;a href=&quot;c3ref/stmt&quot;&gt;准备的语句&lt;/a&gt;对象，因为可以使用便捷包装器接口&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec&lt;/a&gt;或&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table&lt;/a&gt;，并且这些便捷包装器封装并隐藏&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;对象。但是，需要充分了解&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;才能充分利用SQLite。</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="f631842398197770725f42465ce9be3bb217fe7f" translate="yes" xml:space="preserve">
          <source>String Comparison</source>
          <target state="translated">字符串比较</target>
        </trans-unit>
        <trans-unit id="bca91d4c03b6524119c1475d05b8b5503e052ba2" translate="yes" xml:space="preserve">
          <source>String Globbing</source>
          <target state="translated">字符串球化</target>
        </trans-unit>
        <trans-unit id="d8c2dabd43b3a0fa081659375ff18075de8cb9f3" translate="yes" xml:space="preserve">
          <source>String LIKE Matching</source>
          <target state="translated">字符串LIKE匹配</target>
        </trans-unit>
        <trans-unit id="dfab1bcbfa804d1a74a7282da9ab4ff5c5353c70" translate="yes" xml:space="preserve">
          <source>String8</source>
          <target state="translated">String8</target>
        </trans-unit>
        <trans-unit id="add2080ddbdcd32891495b46eb567565fc93baa2" translate="yes" xml:space="preserve">
          <source>Strings returned by sqlite3_column_text() and sqlite3_column_text16(), even empty strings, are always zero-terminated. The return value from sqlite3_column_blob() for a zero-length BLOB is a NULL pointer.</source>
          <target state="translated">sqlite3_column_text()和 sqlite3_column_text16()返回的字符串,即使是空字符串,也总是以零结尾。sqlite3_column_blob()返回的零长度BLOB值是一个NULL指针。</target>
        </trans-unit>
        <trans-unit id="109fcef442d10303df5f7d59d40936a03977dfcb" translate="yes" xml:space="preserve">
          <source>Strings that include any other characters must be quoted. Characters that are not currently allowed in barewords, are not quote characters and do not currently serve any special purpose in FTS5 query expressions may at some point in the future be allowed in barewords or used to implement new query functionality. This means that queries that are currently syntax errors because they include such a character outside of a quoted string may be interpreted differently by some future version of FTS5.</source>
          <target state="translated">包含任何其他字符的字符串必须加引号。目前在裸词中不允许使用的字符,不是引号字符,并且目前在FTS5查询表达式中没有任何特殊用途的字符,可能会在未来的某个时候被允许使用在裸词中,或者用来实现新的查询功能。这意味着,目前因为在引号字符串之外包含这样的字符而出现语法错误的查询,可能会被FTS5的某些未来版本以不同的方式解释。</target>
        </trans-unit>
        <trans-unit id="0b6945b8df636a6d934a512accf12a8b76fc6265" translate="yes" xml:space="preserve">
          <source>Studies show that many applications already use SQLite as a container object. For example, &lt;a href=&quot;https://odin.cse.buffalo.edu/papers/2015/TPCTC-sqlite-final.pdf&quot;&gt;Kennedy&lt;/a&gt; (no relation to the &lt;a href=&quot;https://sqlite.org/crew.html#dan&quot;&gt;SQLite developer&lt;/a&gt;) reports that 14% of Android applications never write to their SQLite databases. It is believed that these applications are downloading entire databases from the cloud and then using the information locally as needed. In other words, the applications are using SQLite not so much as a database but as a queryable wire-transfer format.</source>
          <target state="translated">研究表明，许多应用程序已经使用SQLite作为容器对象。例如，&lt;a href=&quot;https://odin.cse.buffalo.edu/papers/2015/TPCTC-sqlite-final.pdf&quot;&gt;Kennedy&lt;/a&gt;（与&lt;a href=&quot;https://sqlite.org/crew.html#dan&quot;&gt;SQLite开发人员&lt;/a&gt;无关）报告说，有14％的Android应用程序从未写入其SQLite数据库。据信，这些应用程序正在从云下载整个数据库，然后根据需要在本地使用信息。换句话说，应用程序使用SQLite的不仅仅是数据库，而是可查询的电汇格式。</target>
        </trans-unit>
        <trans-unit id="bbd17ca7716d1959474368eb0c63e1ad9ad957be" translate="yes" xml:space="preserve">
          <source>Subqueries</source>
          <target state="translated">Subqueries</target>
        </trans-unit>
        <trans-unit id="9a235eb288a64671965312f5d0ad9f1b72cd84b6" translate="yes" xml:space="preserve">
          <source>Subqueries might also need to be materialized when they appear in the FROM clause of a SELECT statement. For example:</source>
          <target state="translated">当子查询出现在SELECT语句的FROM子句中时,也可能需要将其具体化。例如:</target>
        </trans-unit>
        <trans-unit id="79095639cf2544d3073712b3f47816fbf8b20418" translate="yes" xml:space="preserve">
          <source>Subquery Expressions</source>
          <target state="translated">子查询表达式</target>
        </trans-unit>
        <trans-unit id="14de4f03d3cdec3c98a5016002bc81eb0292385c" translate="yes" xml:space="preserve">
          <source>Subquery co-routines</source>
          <target state="translated">子查询联合程序</target>
        </trans-unit>
        <trans-unit id="1d0025e26a750eaf886e5b666d451246677ab333" translate="yes" xml:space="preserve">
          <source>Substitution Type</source>
          <target state="translated">替换类型</target>
        </trans-unit>
        <trans-unit id="8ef51098d2d0844a5ec23726b4f7a7d03aa49015" translate="yes" xml:space="preserve">
          <source>Substrings consisting of fewer than 3 unicode characters do not match any rows when used with a full-text query. If a LIKE or GLOB pattern does not contain at least one sequence of non-wildcard unicode characters, FTS5 falls back to a linear scan of the entire table.</source>
          <target state="translated">当与全文查询一起使用时,由少于3个unicode字符组成的子字符串不会匹配任何行。如果一个LIKE或GLOB模式不包含至少一个非万字符的单码字符序列,FTS5就会回到对整个表格的线性扫描。</target>
        </trans-unit>
        <trans-unit id="ae5f61e523ef194692c08eae320b323a03f8bb9b" translate="yes" xml:space="preserve">
          <source>Subtract</source>
          <target state="translated">Subtract</target>
        </trans-unit>
        <trans-unit id="b2b6c0ca0db2f38dd797d319d2f786a2af93e034" translate="yes" xml:space="preserve">
          <source>Subtract 200 from X.</source>
          <target state="translated">从X中减去200。</target>
        </trans-unit>
        <trans-unit id="351c38b73ce6b309921bfd5c87f12ea777d4a4ac" translate="yes" xml:space="preserve">
          <source>Subtract the value in register P1 from the value in register P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">从寄存器P2中减去寄存器P1中的值,并将结果存储在寄存器P3中,如果其中一个输入为NULL,则结果为NULL。如果任一输入为NULL,则结果为NULL。</target>
        </trans-unit>
        <trans-unit id="b3ad01aa557050dded853fc788b3484598298d39" translate="yes" xml:space="preserve">
          <source>Such a line of C code might generate a dozen separate machine code instructions. If any one of those instructions is ever evaluated, then we say that the statement has been tested. So, for example, it might be the case that the conditional expression is always false and the &quot;d&quot; variable is never incremented. Even so, statement coverage counts this line of code as having been tested.</source>
          <target state="translated">这样一行C代码可能会产生十几条独立的机器代码指令。如果这些指令中的任何一条被评估过,那么我们就说这个语句已经被测试过了。例如,条件表达式可能总是为假,而 &quot;d &quot;变量从未被递增。即便如此,语句覆盖率也会将这行代码算作已经被测试过。</target>
        </trans-unit>
        <trans-unit id="a042ce9ca13e4d4ddb750a0fe77ea337b1cdceb1" translate="yes" xml:space="preserve">
          <source>Such a virtual table has the same columns as the table-valued function described in the previous section. It may be read from using a SELECT statement in the same way as the table-valued function can.</source>
          <target state="translated">这样一个虚拟表的列数与上一节中描述的表值函数相同。可以用与表值函数相同的方式,用SELECT语句读取虚拟表。</target>
        </trans-unit>
        <trans-unit id="da045363c8fb916c7bdb60bedab8cb85e2f1f5a1" translate="yes" xml:space="preserve">
          <source>Such advanced searches are requested by providing a more complicated FTS5 query string as the text to the right of the MATCH operator (or = operator, or as the first argument to a table-valued function syntax). The full query syntax is &lt;a href=&quot;fts5#full_text_query_syntax&quot;&gt;described here&lt;/a&gt;.</source>
          <target state="translated">通过提供更复杂的FTS5查询字符串作为MATCH运算符（或=运算符，或作为表值函数语法的第一个参数）右边的文本来请求此类高级搜索。完整的查询语法&lt;a href=&quot;fts5#full_text_query_syntax&quot;&gt;在此处描述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0936ee6227b30512f2222702e2254d11d72a242" translate="yes" xml:space="preserve">
          <source>Such criticism would be well-founded for a traditional client/server database engine, such as MySQL, PostgreSQL, or SQL Server. In a client/server database, each SQL statement requires a message round-trip from the application to the database server and back to the application. Doing over 200 round-trip messages, sequentially, can be a serious performance drag. This is sometimes called the &quot;N+1 Query Problem&quot; or the &quot;N+1 Select Problem&quot; and it is an anti-pattern.</source>
          <target state="translated">对于传统的客户/服务器数据库引擎,如MySQL、PostgreSQL或SQL Server,这样的批评是很有道理的。在客户/服务器数据库中,每条SQL语句都需要从应用程序到数据库服务器再到应用程序的消息往返。依次进行超过200次的消息往返,会严重拖累性能。这有时被称为 &quot;N+1查询问题 &quot;或 &quot;N+1选择问题&quot;,它是一种反模式。</target>
        </trans-unit>
        <trans-unit id="f834acdfa0c7dab757f2bc4e26b1966eff963a52" translate="yes" xml:space="preserve">
          <source>Suggested Uses For SQLite:</source>
          <target state="translated">建议使用SQLite。</target>
        </trans-unit>
        <trans-unit id="f08f43d3c61d6c426d33128ee0c38e51fb6aad20" translate="yes" xml:space="preserve">
          <source>Suggested compile-time options include:</source>
          <target state="translated">建议的编译时选项包括:</target>
        </trans-unit>
        <trans-unit id="3d1a384ea1042be63f3032ea726e70fc4a04f311" translate="yes" xml:space="preserve">
          <source>Suggests completions for partially-entered words during interactive SQL input. Used by the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; to help implement tab-completion.</source>
          <target state="translated">在交互式SQL输入过程中建议部分输入的单词的补全。通过使用&lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;，以帮助实现制表完成。</target>
        </trans-unit>
        <trans-unit id="adca4d21f8bf7900f73ede68196274afd881f1d7" translate="yes" xml:space="preserve">
          <source>Sum() will throw an &quot;integer overflow&quot; exception if all inputs are integers or NULL and an integer overflow occurs at any point during the computation. Total() never throws an integer overflow.</source>
          <target state="translated">如果所有的输入都是整数或NULL,并且在计算过程中的任何一点发生整数溢出,Sum()将抛出一个 &quot;整数溢出 &quot;异常。Total()不会产生整数溢出。</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="1a7bd9ebcad37a0dd711dfc793fa96bb5022047c" translate="yes" xml:space="preserve">
          <source>Summary of Technical Differences</source>
          <target state="translated">技术差异摘要</target>
        </trans-unit>
        <trans-unit id="4c599c4f8f2ffb798c4263cf7f6e473784c4d396" translate="yes" xml:space="preserve">
          <source>Super-journals</source>
          <target state="translated">Super-journals</target>
        </trans-unit>
        <trans-unit id="ab2e3b9850b401306a39a3a804f43e7d4f55c01f" translate="yes" xml:space="preserve">
          <source>Support for &quot;:AAA&quot; style bind parameter names.</source>
          <target state="translated">支持&quot;:AAA &quot;风格的绑定参数名称。</target>
        </trans-unit>
        <trans-unit id="8b45bd25a3b604a0eccba69e7087834ecb582853" translate="yes" xml:space="preserve">
          <source>Support for &lt;a href=&quot;lang_update#upfrom&quot;&gt;UPDATE FROM&lt;/a&gt; following the PostgreSQL syntax.</source>
          <target state="translated">支持遵循PostgreSQL语法的&lt;a href=&quot;lang_update#upfrom&quot;&gt;UPDATE FROM&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e333e85b28ab7b57a0a5c9131f54f806015a6221" translate="yes" xml:space="preserve">
          <source>Support for ALTER TABLE ... RENAME TABLE ... added</source>
          <target state="translated">支持ALTER TABLE ...重命名表......的支持</target>
        </trans-unit>
        <trans-unit id="3251d36ace39f64a5ddca9143a5668b65028289f" translate="yes" xml:space="preserve">
          <source>Support for TCL variable names embedded in SQL statements in the TCL bindings.</source>
          <target state="translated">支持在TCL绑定的SQL语句中嵌入TCL变量名。</target>
        </trans-unit>
        <trans-unit id="4c4e649b2faf6e7dd28f3f288044f754a9767c05" translate="yes" xml:space="preserve">
          <source>Support for UTF-16.</source>
          <target state="translated">支持UTF-16。</target>
        </trans-unit>
        <trans-unit id="49ef276ba874be88caa55a5b3e4a37db519f9394" translate="yes" xml:space="preserve">
          <source>Support for UTF-8 and ISO8859 characters in column and table names.</source>
          <target state="translated">在列名和表名中支持UTF-8和ISO8859字符。</target>
        </trans-unit>
        <trans-unit id="78dc81c2a8faafa4c84493782b19c441e17956a6" translate="yes" xml:space="preserve">
          <source>Support for UTF-8 and UTF-16</source>
          <target state="translated">支持UTF-8和UTF-16</target>
        </trans-unit>
        <trans-unit id="1e1164bc2160d30de5ee08ec06fc2a323f2028fc" translate="yes" xml:space="preserve">
          <source>Support for both UTF-8 and UTF-16 text.</source>
          <target state="translated">支持UTF-8和UTF-16文本。</target>
        </trans-unit>
        <trans-unit id="bf37e2ec021b62a6c46ffa2eb125d86eb07ffbc5" translate="yes" xml:space="preserve">
          <source>Support for correlated subqueries added.</source>
          <target state="translated">增加对相关子查询的支持。</target>
        </trans-unit>
        <trans-unit id="ec9173b8e288c70be66cdbfa81d0ba7ad6705c9c" translate="yes" xml:space="preserve">
          <source>Support for full text search using the FTS1 module (beta)</source>
          <target state="translated">支持使用FTS1模块进行全文检索(beta版)</target>
        </trans-unit>
        <trans-unit id="09344ff56160150e5ec18eb5a71ba2f29a6312fc" translate="yes" xml:space="preserve">
          <source>Support for internationalization including UTF-8, UTF-16, and user defined collating sequences.</source>
          <target state="translated">支持国际化,包括UTF-8、UTF-16和用户定义的整理序列。</target>
        </trans-unit>
        <trans-unit id="091e86f3d19a27b9089ddce8c418dcc49fd9c304" translate="yes" xml:space="preserve">
          <source>Support for non-ASCII characters in win95 filenames</source>
          <target state="translated">支持win95文件名中的非ASCII字符。</target>
        </trans-unit>
        <trans-unit id="cfddf0106ec96c94ef54d4e7b75188870573ef30" translate="yes" xml:space="preserve">
          <source>Support for the EXISTS clause added.</source>
          <target state="translated">增加对EXISTS条款的支持。</target>
        </trans-unit>
        <trans-unit id="21d1badc676c125ad5e671e3ae8383a4753e9f6c" translate="yes" xml:space="preserve">
          <source>Support for the diagnostic functions sqlite3_compileoption_used() and sqlite3_compileoption_get() may be omitted by specifying the &lt;a href=&quot;../compile#omit_compileoption_diags&quot;&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/a&gt; option at compile time.</source>
          <target state="translated">通过在编译时指定&lt;a href=&quot;../compile#omit_compileoption_diags&quot;&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/a&gt;选项，可以省略对诊断功能sqlite3_compileoption_used（）和sqlite3_compileoption_get（）的支持。</target>
        </trans-unit>
        <trans-unit id="ceaebbe4250e5e44fc85c0a7be72215c2fc6b3df" translate="yes" xml:space="preserve">
          <source>Support for the diagnostic functions sqlite3_compileoption_used() and sqlite3_compileoption_get() may be omitted by specifying the &lt;a href=&quot;compile#omit_compileoption_diags&quot;&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/a&gt; option at compile time.</source>
          <target state="translated">通过在编译时指定&lt;a href=&quot;compile#omit_compileoption_diags&quot;&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/a&gt;选项，可以省略对诊断功能sqlite3_compileoption_used（）和sqlite3_compileoption_get（）的支持。</target>
        </trans-unit>
        <trans-unit id="e227243100baec383101a5e3e5550db71fb48de1" translate="yes" xml:space="preserve">
          <source>Support operators IS TRUE, IS FALSE, IS NOT TRUE, and IS NOT FALSE.</source>
          <target state="translated">支持操作者为 &quot;真&quot;、&quot;假&quot;、&quot;非真 &quot;和 &quot;非假&quot;。</target>
        </trans-unit>
        <trans-unit id="8b76c3512f29a884a102a942cd3b81fe8d384ace" translate="yes" xml:space="preserve">
          <source>Supported unary prefix operators are these:</source>
          <target state="translated">支持的单利前缀运算符有这些。</target>
        </trans-unit>
        <trans-unit id="14453b6f0216ab7b03129623da62580288e5db4c" translate="yes" xml:space="preserve">
          <source>Supports terabyte-sized databases and gigabyte-sized strings and blobs. (See &lt;a href=&quot;limits&quot;&gt;limits.html&lt;/a&gt;.)</source>
          <target state="translated">支持兆字节大小的数据库以及千兆字节大小的字符串和Blob。（请参阅&lt;a href=&quot;limits&quot;&gt;limits.html&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="f2a1709933364d69e93326e81a6775d317d15202" translate="yes" xml:space="preserve">
          <source>Suppose N=4. Then for the TPC-H Q8 graph, the first step finds the four shortest paths to visit any single node in the graph:</source>
          <target state="translated">假设N=4。那么对于TPC-H Q8图,第一步找到访问图中任意单个节点的四条最短路径。</target>
        </trans-unit>
        <trans-unit id="61fbb5bff735b0969304e1938310f741780fb8bb" translate="yes" xml:space="preserve">
          <source>Suppose SQLite is used as the &lt;a href=&quot;appfileformat&quot;&gt;application file format&lt;/a&gt; for a particular design application. Two users, Alice and Bob, each start with a baseline design that is about a gigabyte in size. They work all day, in parallel, each making their own customizations and tweaks to the design. At the end of the day, they would like to merge their changes together into a single unified design.</source>
          <target state="translated">假设将SQLite用作特定设计应用程序的&lt;a href=&quot;appfileformat&quot;&gt;应用程序文件格式&lt;/a&gt;。两个用户Alice和Bob分别以基线设计开始，该基线设计的大小约为1G。他们整天并行工作，各自对设计进行自定义和调整。最终，他们希望将所做的更改合并到一个统一的设计中。</target>
        </trans-unit>
        <trans-unit id="ef94f961eb3bb04314c719aa5da9edd146e885d3" translate="yes" xml:space="preserve">
          <source>Suppose an application wants to display a list of contacts in alphabetical order by lastname, firstname, in a scrolling window that can only show 7 contacts at a time. Initialize the scrolling window to the first 7 entries is easy:</source>
          <target state="translated">假设一个应用程序想在一个滚动窗口中按姓、名的字母顺序显示联系人列表,但一次只能显示7个联系人。初始化滚动窗口到前7个条目很容易。</target>
        </trans-unit>
        <trans-unit id="56904d3ea47369b0068186e8a39203c8a5f870c3" translate="yes" xml:space="preserve">
          <source>Suppose each entry in the BIG table is a JSON object with a '$.id' field that is a unique identifier and a '$.partlist' field that can be a deeply nested object. You want to find the id of every entry that contains one or more references to uuid '6fa5181e-5721-11e5-a04e-57f3d7b32808' anywhere in its '$.partlist'.</source>
          <target state="translated">假设BIG表中的每个条目都是一个JSON对象,其'$.id'字段是一个唯一的标识符,而'$.partlist'字段可以是一个深度嵌套的对象。你想找到在'$.partlist'中任何地方包含一个或多个uuid'6fa5181e-5721-11e5-a04e-57f3d7b32808'引用的每个条目的id。</target>
        </trans-unit>
        <trans-unit id="01636cb9299568d887d10674105e44b34b08d5bf" translate="yes" xml:space="preserve">
          <source>Suppose that after a while (about a month, usually) a new version of SQLite is released: 3.6.16. You will want to incorporate this new public version of SQLite into your repository in the public branch (the trunk). To do this, first change your repository over to the trunk:</source>
          <target state="translated">假设过了一段时间(通常是一个月左右),SQLite的新版本发布了。3.6.16.你将会想把这个新的 SQLite 公共版本纳入到你的公共分支(主干)仓库中。要做到这一点,首先将你的版本库改成 trunk。</target>
        </trans-unit>
        <trans-unit id="cede4c6f59f784278daddf56ee62d38bbe080c9a" translate="yes" xml:space="preserve">
          <source>Suppose that in addition to the index on &quot;fruit&quot; there was also an index on &quot;state&quot;.</source>
          <target state="translated">假设除了 &quot;水果 &quot;的指数外,还有一个 &quot;状态 &quot;的指数。</target>
        </trans-unit>
        <trans-unit id="66f9ffa5f1e3c7efa56791a73580d03426c293ab" translate="yes" xml:space="preserve">
          <source>Suppose the &lt;a href=&quot;http://en.wikipedia.org/wiki/OpenDocument&quot;&gt;OpenDocument&lt;/a&gt; file format, and specifically the &quot;ODP&quot; OpenDocument Presentation format, were built around SQLite. Benefits would include:</source>
          <target state="translated">假设围绕SQLite构建了&lt;a href=&quot;http://en.wikipedia.org/wiki/OpenDocument&quot;&gt;OpenDocument&lt;/a&gt;文件格式，特别是&amp;ldquo; ODP&amp;rdquo; OpenDocument Presentation格式。好处包括：</target>
        </trans-unit>
        <trans-unit id="3afce37c04a00289ab78d43ef00f88c83b7ff381" translate="yes" xml:space="preserve">
          <source>Suppose the &lt;a href=&quot;https://en.wikipedia.org/wiki/OpenDocument&quot;&gt;OpenDocument&lt;/a&gt; file format, and specifically the &quot;ODP&quot; OpenDocument Presentation format, were built around SQLite. Benefits would include:</source>
          <target state="translated">假设围绕SQLite构建了&lt;a href=&quot;https://en.wikipedia.org/wiki/OpenDocument&quot;&gt;OpenDocument&lt;/a&gt;文件格式，特别是&amp;ldquo; ODP&amp;rdquo; OpenDocument Presentation格式。好处包括：</target>
        </trans-unit>
        <trans-unit id="5a6796b2c9a16b027d38641aa802a501818a470f" translate="yes" xml:space="preserve">
          <source>Suppose the SQLite source tree is stored in a directory named &quot;sqlite&quot;. Plan to construct the amalgamation in a parallel directory named (for example) &quot;bld&quot;. First construct an appropriate Makefile by either running the configure script at the top of the SQLite source tree, or by making a copy of one of the template Makefiles at the top of the source tree. Then hand edit this Makefile to include the desired compile-time options. Finally run:</source>
          <target state="translated">假设SQLite源树存储在一个名为 &quot;sqlite &quot;的目录中。计划在一个名为(例如)&quot;bld &quot;的并行目录中构造合并。首先通过运行SQLite源树顶部的configure脚本,或者复制源树顶部的一个模板Makefile来构建一个合适的Makefile。然后手工编辑这个 Makefile,以包含所需的编译时选项。最后运行。</target>
        </trans-unit>
        <trans-unit id="0b1da1daf13d7c26fba356306203b171fd80d646" translate="yes" xml:space="preserve">
          <source>Suppose the application normally does a query against table TAB1 when it starts up. If an attacker can gain access to the database file and modify the schema like this:</source>
          <target state="translated">假设应用程序在启动时,通常对表TAB1进行查询。如果攻击者能够获得数据库文件的访问权限,并像这样修改模式。</target>
        </trans-unit>
        <trans-unit id="3af5f7045e9a9cbdbcc9c95551ce4e94ea5602be" translate="yes" xml:space="preserve">
          <source>Suppose the demo_data.boundary field holds some proprietary data description of a complex two-dimensional boundary for an object and suppose that the application has used the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface to created application-defined functions &quot;contained_in&quot; and &quot;overlaps&quot; accepting two demo_data.boundary objects and return true or false. One may assume that &quot;contained_in&quot; and &quot;overlaps&quot; are relatively slow functions that we do not want to invoke too frequently. Then an efficient way to find the name of all objects located within the North Carolina 12th District, one may be to run a query like this:</source>
          <target state="translated">假设demo_data.boundary字段保存了对象的复杂二维边界的一些专有数据描述，并且假定应用程序已使用&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;接口创建了接受两个demo_data的应用程序定义函数&amp;ldquo; contained_in&amp;rdquo;和&amp;ldquo; overlaps&amp;rdquo;。边界对象并返回true或false。可以假设&amp;ldquo; contained_in&amp;rdquo;和&amp;ldquo; overlaps&amp;rdquo;是相对较慢的函数，我们不想太频繁地调用它们。然后一种有效的方法来查找位于北卡罗来纳州第十二区的所有对象的名称，一种方法是运行如下查询：</target>
        </trans-unit>
        <trans-unit id="be9cbf4654b2bfbdcf1b2bf833bfb8cf7cccef29" translate="yes" xml:space="preserve">
          <source>Suppose the initial sequence of non-wildcard characters on the right-hand side of the LIKE or GLOB operator is</source>
          <target state="translated">假设LIKE或GLOB运算符右侧的非通配符初始序列是</target>
        </trans-unit>
        <trans-unit id="15341cf73e257c233d78d57ae1e295622b133b68" translate="yes" xml:space="preserve">
          <source>Suppose the power loss occurred during &lt;a href=&quot;#section_3_10&quot;&gt;step 3.10&lt;/a&gt; above, while the database changes were being written to disk. After power is restored, the situation might be something like what is shown to the right. We were trying to change three pages of the database file but only one page was successfully written. Another page was partially written and a third page was not written at all.</source>
          <target state="translated">假设在将数据库更改写入磁盘时，在上述&lt;a href=&quot;#section_3_10&quot;&gt;步骤3.10中&lt;/a&gt;发生了断电。恢复电源后，情况可能类似于右图所示。我们试图更改数据库文件的三页，但仅成功写入了一页。写了另一页，根本没有写第三页。</target>
        </trans-unit>
        <trans-unit id="502f7a3363de6f918e427baeeb23c0fbeb554eda" translate="yes" xml:space="preserve">
          <source>Suppose the table &quot;CREATE TABLE user(name,phone)&quot; stores zero or more phone numbers as a JSON array object in the user.phone field. To find all users who have any phone number with a 704 area code:</source>
          <target state="translated">假设表 &quot;CREATE TABLE user(name,phone)&quot;在user.phone字段中以JSON数组对象的形式存储了0个或多个电话号码。要找到所有拥有704区号的电话号码的用户。</target>
        </trans-unit>
        <trans-unit id="d5297ab1e192fe178acfe6ab94a19f582b117e15" translate="yes" xml:space="preserve">
          <source>Suppose the term that is being spell-corrected is X. To limit the search space, X is converted to a k2-like key using the equivalent of:</source>
          <target state="translated">假设被拼写修正的术语是X,为了限制搜索空间,X用等价的方式转换为k2类键。</target>
        </trans-unit>
        <trans-unit id="b244116e469acf86fbb0e19b53f1d8598b689446" translate="yes" xml:space="preserve">
          <source>Suppose there is a site hosting a database in state S0. And that modifications are made that move that database to state S1 and a changeset recorded (the &quot;local&quot; changeset). Then, a changeset based on S0 is received from another site (the &quot;remote&quot; changeset) and applied to the database. The database is then in state (S1+&quot;remote&quot;), where the exact state depends on any conflict resolution decisions (OMIT or REPLACE) made while applying &quot;remote&quot;. Rebasing a changeset is to update it to take those conflict resolution decisions into account, so that the same conflicts do not have to be resolved elsewhere in the network.</source>
          <target state="translated">假设有一个网站在S0状态下托管一个数据库。而修改后,数据库被移动到状态S1,并记录了一个变化集(&quot;本地 &quot;变化集)。然后,从另一个站点接收到一个基于S0的变更集(&quot;远程 &quot;变更集),并应用到数据库中。然后,数据库处于状态(S1+&quot;远程&quot;),具体状态取决于应用 &quot;远程 &quot;时做出的任何冲突解决决定(OMIT或REPLACE)。重放一个变化集就是更新它,把这些冲突解决决策考虑进去,这样就不用在网络的其他地方解决同样的冲突了。</target>
        </trans-unit>
        <trans-unit id="7ead91310400eb3c0d2b88fd20fde2e0225bdf31" translate="yes" xml:space="preserve">
          <source>Suppose we have a table X1 defined as follows:</source>
          <target state="translated">假设我们有一个表X1,定义如下。</target>
        </trans-unit>
        <trans-unit id="538e32b0b37a9243b789f735088e6724ac330912" translate="yes" xml:space="preserve">
          <source>Suppose we want to find the prices of all kinds of oranges sorted in order of the state where they are grown. The query is this:</source>
          <target state="translated">假设我们想找到各种橙子的价格,按照橙子生长的状态排序。查询的内容是这样的。</target>
        </trans-unit>
        <trans-unit id="064cebf29367ccdae2597fb8c1cb7630379e90ac" translate="yes" xml:space="preserve">
          <source>Suppose we want to know the order number, product number, and quantity for any item in which the product number and quantity match the product number and quantity of any item in order number 365:</source>
          <target state="translated">假设我们想知道订单号、产品号和数量,其中产品号和数量与订单号365中任何商品的产品号和数量相匹配。</target>
        </trans-unit>
        <trans-unit id="8ecaf2920105d29b9c57f7494b3c969303781606" translate="yes" xml:space="preserve">
          <source>Suppose you have an undirected graph where each node is identified by an integer and edges are defined by a table like this:</source>
          <target state="translated">假设你有一个非定向图,其中每个节点由一个整数标识,而边则由这样的表定义。</target>
        </trans-unit>
        <trans-unit id="465043a8fd6b7a4a4148ce99421e90822984188c" translate="yes" xml:space="preserve">
          <source>Suppose you want to look up the price of peaches. The query would be as follows:</source>
          <target state="translated">假设你想查询桃子的价格。查询方法如下:</target>
        </trans-unit>
        <trans-unit id="5cde9a11c3caa7425e0b0c2c0bc60b2a242f9c61" translate="yes" xml:space="preserve">
          <source>Surprisingly, using SQLite in place of ZIP makes the presentation file smaller. Really. One would think that a relational database file would be larger than a ZIP archive, but at least in the case of NeoOffice that is not so. The following is an actual screen-scrape showing the sizes of the same NeoOffice presentation, both in its original ZIP archive format as generated by NeoOffice (self2014.odp), and as repacked as an SQLite database using the &lt;a href=&quot;http://www.sqlite.org/sqlar/doc/trunk/README.md&quot;&gt;SQLAR&lt;/a&gt; utility:</source>
          <target state="translated">令人惊讶的是，使用SQLite代替ZIP可以使演示文件更小。真。有人会认为关系数据库文件会比ZIP归档文件大，但至少在NeoOffice情况下不是这样。以下是实际的屏幕截图，显示了同一NeoOffice演示文稿的大小，它们的原始ZIP存档格式由NeoOffice（self2014.odp）生成，并使用&lt;a href=&quot;http://www.sqlite.org/sqlar/doc/trunk/README.md&quot;&gt;SQLAR&lt;/a&gt;实用程序重新打包为SQLite数据库：</target>
        </trans-unit>
        <trans-unit id="399595a78d6a05cc21ce3af04c57307d7598c91a" translate="yes" xml:space="preserve">
          <source>Surprisingly, using SQLite in place of ZIP makes the presentation file smaller. Really. One would think that a relational database file would be larger than a ZIP archive, but at least in the case of NeoOffice that is not so. The following is an actual screen-scrape showing the sizes of the same NeoOffice presentation, both in its original ZIP archive format as generated by NeoOffice (self2014.odp), and as repacked as an SQLite database using the &lt;a href=&quot;https://www.sqlite.org/sqlar/doc/trunk/README.md&quot;&gt;SQLAR&lt;/a&gt; utility:</source>
          <target state="translated">出乎意料的是，使用SQLite代替ZIP可以使演示文稿文件更小。真的。有人会认为关系数据库文件会比ZIP归档文件大，但至少在NeoOffice情况下不是这样。以下是实际的屏幕截图，显示了同一NeoOffice演示文稿的大小，其大小由NeoOffice（self2014.odp）生成的原始ZIP存档格式，以及使用&lt;a href=&quot;https://www.sqlite.org/sqlar/doc/trunk/README.md&quot;&gt;SQLAR&lt;/a&gt;实用程序重新打包为SQLite数据库的大小：</target>
        </trans-unit>
        <trans-unit id="055c319b3692b1bab785599b3ba80b0068542bb5" translate="yes" xml:space="preserve">
          <source>Suspend Execution For A Short Time</source>
          <target state="translated">短时间内暂停执行</target>
        </trans-unit>
        <trans-unit id="7bdfc376d6f876239b6de7abf665805218ef476e" translate="yes" xml:space="preserve">
          <source>Swap the program counter with the value in register P1. This has the effect of yielding to a coroutine.</source>
          <target state="translated">将程序计数器与寄存器P1中的值交换。这样做的效果是让位于一个coroutine。</target>
        </trans-unit>
        <trans-unit id="6cb264ae88f7fbec3546350312b9af582b1fc481" translate="yes" xml:space="preserve">
          <source>Swapping journal files between two different databases.</source>
          <target state="translated">在两个不同的数据库之间交换日志文件。</target>
        </trans-unit>
        <trans-unit id="e8485294b019aa85fdb1a929771cba23d5593c45" translate="yes" xml:space="preserve">
          <source>Swarmvtab Virtual Table</source>
          <target state="translated">Swarmvtab 虚拟表</target>
        </trans-unit>
        <trans-unit id="01d32f35e7401403e071bd64f5c3b26a4e4dc5be" translate="yes" xml:space="preserve">
          <source>Swarmvtab context</source>
          <target state="translated">Swarmvtab上下文</target>
        </trans-unit>
        <trans-unit id="875cb081d7d2e461450da0199489f1266311e3ff" translate="yes" xml:space="preserve">
          <source>Swarmvtab efficiently handles range and equality constraints on the rowid (or other INTEGER PRIMARY KEY) field only. If a query does not contain such a constraint, then swarmvtab finds the results by opening each database in turn and linearly scanning the component table. Which generates a correct result, but is often slow.</source>
          <target state="translated">swarmvtab只有效地处理rowid(或其他INTEGER PRIMARY KEY)字段上的范围和平等约束。如果一个查询不包含这样的约束,那么swarmvtab通过依次打开每个数据库并线性扫描组件表来查找结果。这样产生的结果是正确的,但往往很慢。</target>
        </trans-unit>
        <trans-unit id="85aa4db2e47035bd4c2140f56e8799ea09c7ae90" translate="yes" xml:space="preserve">
          <source>Swarmvtab virtual tables must be created in the temp schema. Attempting to create a swarmvtab in the main or an attached database is an error.</source>
          <target state="translated">Swarmvtab 虚拟表必须在 temp 模式中创建。试图在主数据库或附加数据库中创建swarmvtab是一个错误。</target>
        </trans-unit>
        <trans-unit id="d0d92527f493460a8c4ce6ccbbd585c5ead2d11f" translate="yes" xml:space="preserve">
          <source>Synchronization Type Flags</source>
          <target state="translated">同步类型标志</target>
        </trans-unit>
        <trans-unit id="a7e6b31b20f1d4434bcadd521f6861e2f3378f97" translate="yes" xml:space="preserve">
          <source>Synchronous pragma</source>
          <target state="translated">同步语法</target>
        </trans-unit>
        <trans-unit id="4ae6fa22bc9918cf39eb8d8cef197a88e78982e8" translate="yes" xml:space="preserve">
          <source>Syncing</source>
          <target state="translated">Syncing</target>
        </trans-unit>
        <trans-unit id="c66891a446af4f02e4055198cbfa371561a78fd4" translate="yes" xml:space="preserve">
          <source>Syncing the Journal File</source>
          <target state="translated">同步日志文件</target>
        </trans-unit>
        <trans-unit id="009e70db897489dd37e3be6570164d0a836b9c76" translate="yes" xml:space="preserve">
          <source>Syntactically, generated columns are designated using a &quot;GENERATED ALWAYS&quot; &lt;a href=&quot;syntax/column-constraint&quot;&gt;column-constraint&lt;/a&gt;. For example:</source>
          <target state="translated">语法上，使用&amp;ldquo; GENERATED ALWAYS&amp;rdquo; &lt;a href=&quot;syntax/column-constraint&quot;&gt;column-constraint&lt;/a&gt;指定生成的列。例如：</target>
        </trans-unit>
        <trans-unit id="17aba038fa3266b07efa450a91b91b1e792d66c5" translate="yes" xml:space="preserve">
          <source>Syntax Diagrams</source>
          <target state="translated">语法图</target>
        </trans-unit>
        <trans-unit id="33bbfae733b0f97c3ea72475efb5dfbb61ebe1e1" translate="yes" xml:space="preserve">
          <source>Syntax Diagrams For SQLite</source>
          <target state="translated">SQLite的语法图</target>
        </trans-unit>
        <trans-unit id="70a8fcc6fa01af0d580c320ddb0e42484905e68e" translate="yes" xml:space="preserve">
          <source>Syntax Restrictions On UPDATE, DELETE, and INSERT Statements Within Triggers</source>
          <target state="translated">对触发器内UPDATE、DELETE和INSERT语句的语法限制。</target>
        </trans-unit>
        <trans-unit id="34b408d97f8998a54cd64e9461c53dd4d1067b38" translate="yes" xml:space="preserve">
          <source>System Failure Related Assumptions</source>
          <target state="translated">系统故障相关假设</target>
        </trans-unit>
        <trans-unit id="ba2da263deb1258b36edfe6f11f1b761d86b8d6d" translate="yes" xml:space="preserve">
          <source>Systems designers report success using SQLite as a data store on server applications running in the datacenter, or in other words, using SQLite as the underlying storage engine for an application-specific database server.</source>
          <target state="translated">系统设计人员报告说,在数据中心运行的服务器应用程序上成功地使用SQLite作为数据存储,或者换句话说,使用SQLite作为特定应用程序数据库服务器的底层存储引擎。</target>
        </trans-unit>
        <trans-unit id="7244bff04e9f7001cbde5e129092d3ed31f1946c" translate="yes" xml:space="preserve">
          <source>Systems that run automatic backups in the background might try to make a backup copy of an SQLite database file while it is in the middle of a transaction. The backup copy then might contain some old and some new content, and thus be corrupt.</source>
          <target state="translated">在后台运行自动备份的系统可能会试图在SQLite数据库文件处于事务处理过程中时为其制作一个备份副本。然后,备份副本可能包含一些旧的和一些新的内容,因此会损坏。</target>
        </trans-unit>
        <trans-unit id="a4394edb00669dc4429b903f672c10ae13c95e90" translate="yes" xml:space="preserve">
          <source>TABLE</source>
          <target state="translated">TABLE</target>
        </trans-unit>
        <trans-unit id="2ba83e39946a4ce4cedf8d25757aa5972284aa54" translate="yes" xml:space="preserve">
          <source>TABLENAME</source>
          <target state="translated">TABLENAME</target>
        </trans-unit>
        <trans-unit id="4ff4bacb6a130128f6603752138b57217ef9b6fa" translate="yes" xml:space="preserve">
          <source>TBD...</source>
          <target state="translated">TBD...</target>
        </trans-unit>
        <trans-unit id="e44916ac43724313d53ca25dbe2f20ee993ff6ec" translate="yes" xml:space="preserve">
          <source>TBD: More information about the header</source>
          <target state="translated">TBD:更多关于标题的信息</target>
        </trans-unit>
        <trans-unit id="cdd060df603a64a7bee550bbc1c098580b231ab0" translate="yes" xml:space="preserve">
          <source>TCL interface authorizer method</source>
          <target state="translated">TCL接口授权方法</target>
        </trans-unit>
        <trans-unit id="aa517168bae4e2e388a6074b5a96fe2e5afc293f" translate="yes" xml:space="preserve">
          <source>TCL interface backup method</source>
          <target state="translated">TCL接口备份方式</target>
        </trans-unit>
        <trans-unit id="a29047291bb3d39d19d4b03699cb7f433f5736f2" translate="yes" xml:space="preserve">
          <source>TCL interface bind_fallback method</source>
          <target state="translated">TCL接口bind_fallback方法</target>
        </trans-unit>
        <trans-unit id="1c5ad56544d8041c9b02f88d11a25782f14e4c9f" translate="yes" xml:space="preserve">
          <source>TCL interface busy method</source>
          <target state="translated">TCL接口忙法</target>
        </trans-unit>
        <trans-unit id="6e4d989bf3b3b512cc61d500b0cb58cfc259ca59" translate="yes" xml:space="preserve">
          <source>TCL interface cache method</source>
          <target state="translated">TCL接口缓存方法</target>
        </trans-unit>
        <trans-unit id="f25b192d00bf0645e7eae602ec160016f797e6ac" translate="yes" xml:space="preserve">
          <source>TCL interface changes method</source>
          <target state="translated">TCL接口变更方法</target>
        </trans-unit>
        <trans-unit id="33f884ed1b8425d04cb3811d2ea16b66af480340" translate="yes" xml:space="preserve">
          <source>TCL interface close method</source>
          <target state="translated">TCL接口关闭方法</target>
        </trans-unit>
        <trans-unit id="96c5f46c7769b7e1d49b804ecba806907889a771" translate="yes" xml:space="preserve">
          <source>TCL interface collate method</source>
          <target state="translated">TCL接口整理法</target>
        </trans-unit>
        <trans-unit id="2332befec61c50669cde60f3b1533591736f6a66" translate="yes" xml:space="preserve">
          <source>TCL interface collation_needed method</source>
          <target state="translated">TCL 接口 collation_needed 方法。</target>
        </trans-unit>
        <trans-unit id="8cd4b4c1ed1732eb767f776cef0372d6c6cd1054" translate="yes" xml:space="preserve">
          <source>TCL interface commit_hook method</source>
          <target state="translated">TCL 接口 commit_hook 方法</target>
        </trans-unit>
        <trans-unit id="0157c2d923f1a0bec3d0245febd3f5035181a5aa" translate="yes" xml:space="preserve">
          <source>TCL interface complete method</source>
          <target state="translated">TCL接口完成方法</target>
        </trans-unit>
        <trans-unit id="c09e584a42654f26d29ff74df19ed9ca909905e4" translate="yes" xml:space="preserve">
          <source>TCL interface config method</source>
          <target state="translated">TCL接口配置方法</target>
        </trans-unit>
        <trans-unit id="b70df1b7dc237a292692ace288ac2eb93a3bcef2" translate="yes" xml:space="preserve">
          <source>TCL interface copy method</source>
          <target state="translated">TCL接口复制方法</target>
        </trans-unit>
        <trans-unit id="347f513a80d88ab334df317b8f83092d3ee26571" translate="yes" xml:space="preserve">
          <source>TCL interface deserialize method</source>
          <target state="translated">TCL接口反序列化方法</target>
        </trans-unit>
        <trans-unit id="0aa7225f1cfbaa7982110594b19739c6dbdfb9ac" translate="yes" xml:space="preserve">
          <source>TCL interface enable_load_extension method</source>
          <target state="translated">TCL 接口 enable_load_extension 方法。</target>
        </trans-unit>
        <trans-unit id="64987beca677d7a4b95b820f3bed800e413b8cde" translate="yes" xml:space="preserve">
          <source>TCL interface errorcode method</source>
          <target state="translated">TCL接口错误代码方法</target>
        </trans-unit>
        <trans-unit id="2189980d19fa911ed2ea4bb8d946cfdc55a53bc7" translate="yes" xml:space="preserve">
          <source>TCL interface eval method</source>
          <target state="translated">TCL接口评价方法</target>
        </trans-unit>
        <trans-unit id="f1bf6449a26eb7b025248f0b61a91066e3c39b49" translate="yes" xml:space="preserve">
          <source>TCL interface exists method</source>
          <target state="translated">TCL接口存在方法</target>
        </trans-unit>
        <trans-unit id="648b3c74c3afc3cad32dadd0965691c51538573c" translate="yes" xml:space="preserve">
          <source>TCL interface function method</source>
          <target state="translated">TCL接口功能方法</target>
        </trans-unit>
        <trans-unit id="4d842678586502cd1c46097c8ca3621079c38b98" translate="yes" xml:space="preserve">
          <source>TCL interface incrblob method</source>
          <target state="translated">TCL接口的incrblob方法</target>
        </trans-unit>
        <trans-unit id="066821d02e0db49a10a7937ff6d8bc5c5b5055c7" translate="yes" xml:space="preserve">
          <source>TCL interface interrupt method</source>
          <target state="translated">TCL接口中断方式</target>
        </trans-unit>
        <trans-unit id="f2e3158832088a3ccb54fc358c6461aace750451" translate="yes" xml:space="preserve">
          <source>TCL interface last_insert_rowid method</source>
          <target state="translated">TCL接口 last_insert_rowid方法</target>
        </trans-unit>
        <trans-unit id="50f8a5afc729daeaa27f3e057a6884d99bd7f622" translate="yes" xml:space="preserve">
          <source>TCL interface nullvalue method</source>
          <target state="translated">TCL接口nullvalue方法</target>
        </trans-unit>
        <trans-unit id="e0711044ae2edb8698df1518d744c5b6309e1ba0" translate="yes" xml:space="preserve">
          <source>TCL interface onecolumn method</source>
          <target state="translated">TCL接口onecolumn方法</target>
        </trans-unit>
        <trans-unit id="7eb062b4a3cda7b5c21d07e42888d6f537605587" translate="yes" xml:space="preserve">
          <source>TCL interface profile method</source>
          <target state="translated">TCL接口配置文件方法</target>
        </trans-unit>
        <trans-unit id="4bd65df2fc14e08847cf659f886e3675b02fd603" translate="yes" xml:space="preserve">
          <source>TCL interface progress method</source>
          <target state="translated">TCL接口进度法</target>
        </trans-unit>
        <trans-unit id="24560fa957755f945fd0a996100a7a50130fe691" translate="yes" xml:space="preserve">
          <source>TCL interface restore method</source>
          <target state="translated">TCL接口还原方法</target>
        </trans-unit>
        <trans-unit id="2c81f806023d5b1efa791fd568b8a71993cb3fc8" translate="yes" xml:space="preserve">
          <source>TCL interface rollback_hook method</source>
          <target state="translated">TCL接口rollback_hook方法</target>
        </trans-unit>
        <trans-unit id="5d16200e0392f874424c9d693d564e213809df7d" translate="yes" xml:space="preserve">
          <source>TCL interface serialize method</source>
          <target state="translated">TCL接口序列化方法</target>
        </trans-unit>
        <trans-unit id="8ad2308cc6d8c87dd4d39e3a54c207bf26684239" translate="yes" xml:space="preserve">
          <source>TCL interface status method</source>
          <target state="translated">TCL接口状态方法</target>
        </trans-unit>
        <trans-unit id="149cac088a8935337f35ceed17575a182fb384dd" translate="yes" xml:space="preserve">
          <source>TCL variable substitution</source>
          <target state="translated">TCL变量替换</target>
        </trans-unit>
        <trans-unit id="def1cac8277b55b62d6889e51352a77e3186587b" translate="yes" xml:space="preserve">
          <source>TEMP</source>
          <target state="translated">TEMP</target>
        </trans-unit>
        <trans-unit id="c02f25e228aca3bb6f42e48160b40dd55194b2cc" translate="yes" xml:space="preserve">
          <source>TEMP Triggers on Non-TEMP Tables</source>
          <target state="translated">非腾博会登录表的腾博会登录触发器</target>
        </trans-unit>
        <trans-unit id="8d43ca29f9403615d1a5c8f0da40adcdae819802" translate="yes" xml:space="preserve">
          <source>TEMP databases</source>
          <target state="translated">腾博会登录数据库</target>
        </trans-unit>
        <trans-unit id="0c21d62a74809c85ca0475d94b6c298ee066de4e" translate="yes" xml:space="preserve">
          <source>TEMP tables and indices</source>
          <target state="translated">腾博会登录表和指数</target>
        </trans-unit>
        <trans-unit id="df7db63622b3659c5ca6d357417169e72078f0bc" translate="yes" xml:space="preserve">
          <source>TEMP triggers on non-TEMP tables</source>
          <target state="translated">非腾博会登录表的腾博会登录触发器</target>
        </trans-unit>
        <trans-unit id="2ec4186ff6dd054f66dc48342664cc916e7cee64" translate="yes" xml:space="preserve">
          <source>TEMPORARY</source>
          <target state="translated">TEMPORARY</target>
        </trans-unit>
        <trans-unit id="7d4e42ef9d04a046b5679f952cb0b6b5c498c73c" translate="yes" xml:space="preserve">
          <source>TEXT</source>
          <target state="translated">TEXT</target>
        </trans-unit>
        <trans-unit id="6e2d2a0b927ccbcb0059d0c7ba90d9609187d08f" translate="yes" xml:space="preserve">
          <source>TH3</source>
          <target state="translated">TH3</target>
        </trans-unit>
        <trans-unit id="f0b11e9a80109508da2e3cbd3b7a0a8827845799" translate="yes" xml:space="preserve">
          <source>TH3 achieves 100% branch test coverage (and 100% &lt;a href=&quot;https://en.wikipedia.org/wiki/Modified_condition/decision_coverage&quot;&gt;MC/DC&lt;/a&gt;) over the SQLite core. (Test coverage of extensions such as FTS and RTREE is less than 100%).</source>
          <target state="translated">TH3 在SQLite核心上实现了100％的分支测试覆盖率（和100％的&lt;a href=&quot;https://en.wikipedia.org/wiki/Modified_condition/decision_coverage&quot;&gt;MC / DC&lt;/a&gt;）。 （FTS和RTREE等扩展的测试覆盖率小于100％）。</target>
        </trans-unit>
        <trans-unit id="b39ec8bc0fe82988bb1da1f05fc2de8eb41887fa" translate="yes" xml:space="preserve">
          <source>TH3 checks SQLite's response to out-of-memory errors, disk I/O errors, and power loss during transaction commit.</source>
          <target state="translated">TH3检查SQLite在事务提交过程中对内存外错误、磁盘I/O错误和断电的响应。</target>
        </trans-unit>
        <trans-unit id="055f71da54f782f8f65239fd4fb6b9c021760b69" translate="yes" xml:space="preserve">
          <source>TH3 comes with additional TCL scripts that help automate the testing process on workstations. The &quot;th3make&quot; script automatically runs &quot;mkth3.tcl&quot; and &quot;gcc&quot; and then runs the resulting test program and checks the results. Arguments to th3make include all of the &quot;*.test&quot; test modules and &quot;*.cfg&quot; configurations that are to be included in the test. Additional options to th3make can cause the test program to be compiled using different compilers (GCC, Clang, MSVC), to use different output verbosity levels, to run the test program under valgrind, to check the output for coverage using gcov, and so forth. The th3make script also accepts &quot;*.rc&quot; filenames as arguments. These *.rc files are just collections of other arguments that are commonly used together for a single purpose. For example, the &quot;quick.rc&quot; file contains a set of eight arguments to th3make that run a fast (3-minute) full-coverage test. This allows the operator to type &quot;./th3make quick.rc&quot; as a short-cut to typing out all of the required command-line options. The following are a few of the more than 40 available *.rc files:</source>
          <target state="translated">TH3自带额外的TCL脚本,有助于在工作站上自动完成测试过程。th3make &quot;脚本会自动运行 &quot;mkth3.tcl &quot;和 &quot;gcc&quot;,然后运行生成的测试程序并检查结果。th3make的参数包括所有的 &quot;*.test &quot;测试模块和 &quot;*.cfg &quot;配置,这些配置将被包含在测试中。其他选项可以使测试程序使用不同的编译器 (GCC,Clang,MSVC)进行编译,使用不同的输出 verbosity 级别,在 valgrind 下运行测试程序,使用 gcov 检查输出的覆盖率,等等。th3make脚本也接受 &quot;*.rc &quot;文件名作为参数。这些*.rc文件只是其他参数的集合,它们通常被用于一个单一的目的。例如,&quot;quick.rc &quot;文件包含了th3make运行快速(3分钟)全覆盖测试的八个参数。这使得操作者可以键入&quot;./th3make quick.rc &quot;作为键入所有所需命令行选项的捷径。下面是40多个可用的*.rc文件中的几个。</target>
        </trans-unit>
        <trans-unit id="a2a05ad4acef3c330bf37c9357e657e9ed2af845" translate="yes" xml:space="preserve">
          <source>TH3 exercises SQLite in a variety of run-time configurations (UTF8 vs UTF16, different pages sizes, varying journal modes, etc.)</source>
          <target state="translated">TH3在各种运行时配置中练习SQLite(UTF8与UTF16,不同的页面大小,不同的日记模式等)。</target>
        </trans-unit>
        <trans-unit id="f8e21da8c02749a044b3aef819f8092fd00ef786" translate="yes" xml:space="preserve">
          <source>TH3 is a test program generator. The output of TH3 is a program implemented in C-code and intended to be linked against the SQLite library under test. The generated test program is compiled and run on the target platform in order to verify correct operation of SQLite on that platform.</source>
          <target state="translated">TH3是一个测试程序生成器。TH3的输出是一个用C代码实现的程序,目的是针对被测试的SQLite库进行链接。生成的测试程序被编译并在目标平台上运行,以验证SQLite在该平台上的正确操作。</target>
        </trans-unit>
        <trans-unit id="35be3734cb33090a9156032bab76a3246a8875be" translate="yes" xml:space="preserve">
          <source>TH3 is able to run on embedded platforms that lack the support infrastructure of workstations.</source>
          <target state="translated">TH3能够在缺乏工作站支持基础设施的嵌入式平台上运行。</target>
        </trans-unit>
        <trans-unit id="924274e45e00b2de29022bcd422e62f257c51552" translate="yes" xml:space="preserve">
          <source>TH3 originated from an effort to test SQLite on &lt;a href=&quot;https://en.wikipedia.org/wiki/Symbian&quot;&gt;SymbianOS&lt;/a&gt;. Prior to TH3, all SQLite tests were run using the &lt;a href=&quot;http://www.tcl.tk/&quot;&gt;TCL&lt;/a&gt; script language, but TCL would not (easily) compile on SymbianOS which made testing difficult. The first attempt to remedy this problem was the &quot;TH1&quot; (Test Harness #1) scripting language - a reimplementation of parts of the TCL language in a more portable form that would compile and run on SymbianOS, and that was sufficient to run the SQLite tests. TH1 did not survive as a standard testing tool for SQLite, but it did find continued service as a scripting language used to customize the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; version control system. There was also a &quot;Test Harness #2&quot; which was an attempt to create a simple scripting language using operator prefix notation to drive tests. TH3 was the third attempt.</source>
          <target state="translated">TH3源于在&lt;a href=&quot;https://en.wikipedia.org/wiki/Symbian&quot;&gt;SymbianOS&lt;/a&gt;上测试SQLite的努力。在TH3之前，所有SQLite测试都是使用&lt;a href=&quot;http://www.tcl.tk/&quot;&gt;TCL&lt;/a&gt;脚本语言运行的，但是TCL无法（轻松地）在SymbianOS上编译，这使测试变得困难。解决此问题的第一个尝试是使用&amp;ldquo; TH1&amp;rdquo;（测试工具＃1）脚本语言-以更可移植的形式重新实现TCL语言的某些部分，这些部分将在SymbianOS上编译并运行，并且足以运行SQLite。测试。 TH1不能作为SQLite的标准测试工具幸免于难，但它确实找到了持续服务作为用于自定义&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt;的脚本语言。版本控制系统。还有一个&amp;ldquo; Test Harness＃2&amp;rdquo;，它试图使用操作符前缀表示法来创建一种简单的脚本语言来进行测试。TH3是第三次尝试。</target>
        </trans-unit>
        <trans-unit id="4c264425d6a132c02585028ee4d147fc5a2051e5" translate="yes" xml:space="preserve">
          <source>TH3 originated from an effort to test SQLite on &lt;a href=&quot;https://en.wikipedia.org/wiki/Symbian&quot;&gt;SymbianOS&lt;/a&gt;. Prior to TH3, all SQLite tests were run using the &lt;a href=&quot;https://www.tcl.tk/&quot;&gt;TCL&lt;/a&gt; script language, but TCL would not (easily) compile on SymbianOS which made testing difficult. The first attempt to remedy this problem was the &quot;TH1&quot; (Test Harness #1) scripting language - a reimplementation of parts of the TCL language in a more portable form that would compile and run on SymbianOS, and that was sufficient to run the SQLite tests. TH1 did not survive as a standard testing tool for SQLite, but it did find continued service as a scripting language used to customize the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; version control system. There was also a &quot;Test Harness #2&quot; which was an attempt to create a simple scripting language using operator prefix notation to drive tests. TH3 was the third attempt.</source>
          <target state="translated">TH3源于在&lt;a href=&quot;https://en.wikipedia.org/wiki/Symbian&quot;&gt;SymbianOS&lt;/a&gt;上测试SQLite的努力。在TH3之前，所有SQLite测试都是使用&lt;a href=&quot;https://www.tcl.tk/&quot;&gt;TCL&lt;/a&gt;脚本语言运行的，但是TCL无法（轻松地）在SymbianOS上编译，这使测试变得困难。解决此问题的第一个尝试是使用&amp;ldquo; TH1&amp;rdquo;（测试线束＃1）脚本语言-以更可移植的形式重新实现TCL语言的某些部分，这些部分将在SymbianOS上编译并运行，并且足以运行SQLite。测试。 TH1不能作为SQLite的标准测试工具幸免于难，但它确实找到了持续服务作为用于自定义&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt;的脚本语言。版本控制系统。还有一个&amp;ldquo; Test Harness＃2&amp;rdquo;，它试图使用运算符前缀表示法来创建一种简单的脚本语言来进行测试。TH3是第三次尝试。</target>
        </trans-unit>
        <trans-unit id="2607d86f3f95561abb29b75d3920751195896dbd" translate="yes" xml:space="preserve">
          <source>TH3 tests SQLite in an as-deployed configuration using only published and documented interfaces. In other words, TH3 tests the compiled object code, not the source code, thus verifying that no problems were introduced by compiler bugs. &quot;Test what you fly and fly what you test.&quot;</source>
          <target state="translated">TH3只使用已发布和记录的接口在已部署的配置中测试SQLite。换句话说,TH3测试的是编译后的对象代码,而不是源代码,从而验证编译器的bug没有引入问题。&quot;飞什么测试什么,飞什么测试什么&quot;。</target>
        </trans-unit>
        <trans-unit id="c87cfbcfb0ff68ef8b8fa0759657744ff88b88af" translate="yes" xml:space="preserve">
          <source>TH3 was originally written for validation testing only, but has subsequently been used for development testing and debugging as well, and has proven very helpful in those roles. A full-coverage test takes less than five minutes on a workstation and hence serves as a fast regression test during day-to-day maintenance of the SQLite code base.</source>
          <target state="translated">TH3最初只是为验证测试而编写的,但后来也被用于开发测试和调试,并被证明在这些作用上非常有用。一个全覆盖测试在工作站上只需要不到5分钟的时间,因此在SQLite代码库的日常维护过程中可以作为快速回归测试。</target>
        </trans-unit>
        <trans-unit id="bd7f8a83e07337beedb291a476a0abdb89ed6b4f" translate="yes" xml:space="preserve">
          <source>THEN</source>
          <target state="translated">THEN</target>
        </trans-unit>
        <trans-unit id="2c1d90a10bc6577f471f3c2c8cd6836385b31b82" translate="yes" xml:space="preserve">
          <source>TIES</source>
          <target state="translated">TIES</target>
        </trans-unit>
        <trans-unit id="4fe5a3682f8029783789ec9b3abba10f67f03ffa" translate="yes" xml:space="preserve">
          <source>TINYINT</source>
          <target state="translated">TINYINT</target>
        </trans-unit>
        <trans-unit id="15f51444be75bc88e935c57ef2ee7477dc73a64e" translate="yes" xml:space="preserve">
          <source>TO</source>
          <target state="translated">TO</target>
        </trans-unit>
        <trans-unit id="cd4fd03fe967437fff9a9133b579cdd5421577a6" translate="yes" xml:space="preserve">
          <source>TODO:  Add something about checking the page-cache first etc.</source>
          <target state="translated">TODO:增加一些关于先检查页面缓存的内容等。</target>
        </trans-unit>
        <trans-unit id="7fb66aab7e490b4f8a5b13b306c51e116175236a" translate="yes" xml:space="preserve">
          <source>TODO:  After sections 4 and 5 are finished, come back here and see if we can add a list of state items associated with each database connection to make things easier to understand. i.e each database connection has a file handle, a set of entries in the page cache, an expected page size etc.</source>
          <target state="translated">TODO:在第4和第5节完成后,回到这里,看看我们是否可以添加一个与每个数据库连接相关联的状态项目列表,以使事情更容易理解.即每个数据库连接都有一个文件句柄,页面缓存中的一组条目,预期的页面大小等。</target>
        </trans-unit>
        <trans-unit id="4dc847eb4b63db6446f6040c4f09bb7ba16604ab" translate="yes" xml:space="preserve">
          <source>TODO:  After this document is ready, make the vocabulary consistent and then add a glossary here.</source>
          <target state="translated">TODO:在这个文档准备好后,使词汇一致,然后在这里增加一个词汇表。</target>
        </trans-unit>
        <trans-unit id="f4e2201a943d83ad82ae3edd3d70f87d9d34b73f" translate="yes" xml:space="preserve">
          <source>TODO:  Describe the parameters set to configure the page cache limits.</source>
          <target state="translated">TODO:描述配置页面缓存限制的参数设置。</target>
        </trans-unit>
        <trans-unit id="30bb6265750b23e36fff26fba218f095577396da" translate="yes" xml:space="preserve">
          <source>TODO:  Expand on and explain the above a bit.</source>
          <target state="translated">TODO:对上述内容进行扩展和解释一下。</target>
        </trans-unit>
        <trans-unit id="55f19663a5c44b6305b426b72aadfc9a70eb894d" translate="yes" xml:space="preserve">
          <source>TODO:  Introduce the following sub-sections.</source>
          <target state="translated">建议:介绍以下各小节:</target>
        </trans-unit>
        <trans-unit id="593039ec1c1939952bb9949b2bcbe1140a495e60" translate="yes" xml:space="preserve">
          <source>TODO:  Is the shared lock held after committing a</source>
          <target state="translated">TODO:在提交了共享锁之后,共享锁是否会被保留?</target>
        </trans-unit>
        <trans-unit id="c4a151926d0634538ee91af79c910ea2132025f5" translate="yes" xml:space="preserve">
          <source>TODO:  Master journal file pointers?</source>
          <target state="translated">TODO:主日志文件指针?</target>
        </trans-unit>
        <trans-unit id="2c459077da83b75d52b821b2b77b9e73be290e1e" translate="yes" xml:space="preserve">
          <source>TODO:  Requirements describing the way in which the configuration parameters are used. About LRU etc.</source>
          <target state="translated">待办事项。要求描述配置参数的使用方式。关于LRU等。</target>
        </trans-unit>
        <trans-unit id="f7e945f52e85f69c533b2d7abf6ea281ed104013" translate="yes" xml:space="preserve">
          <source>TODO:  System requirement references for the above points.</source>
          <target state="translated">待办事项:上述各点的系统要求参考。</target>
        </trans-unit>
        <trans-unit id="840394002935b6f4d9da99212e26895929cd86d7" translate="yes" xml:space="preserve">
          <source>TODO:  What happens if the exclusive lock cannot be obtained? It is not possible for the attempt to upgrade from a reserved to a pending lock to fail.</source>
          <target state="translated">TODO:如果无法获得专属锁会怎样?从保留锁升级到待定锁的尝试不可能失败。</target>
        </trans-unit>
        <trans-unit id="6714ad8471919f57bc47d379c3524d08542a02be" translate="yes" xml:space="preserve">
          <source>TODO:  Why a 16 byte block? Why not 4? (something to do with encrypted databases).</source>
          <target state="translated">TODO:为什么是16字节的块?为什么不是4字节?(与加密的数据库有关)。</target>
        </trans-unit>
        <trans-unit id="2e614c97a332a0295344a53ea5da2a36633b1954" translate="yes" xml:space="preserve">
          <source>TPC-H Q8 is an eight-way join. As observed above, the main task of the query planner is to figure out the best nesting order of the eight loops in order to minimize the work needed to complete the join. A simplified model of this problem for the case of TPC-H Q8 is shown by the following diagram:</source>
          <target state="translated">TPC-H Q8是一个八路连接。如上所述,查询规划器的主要任务是找出八个循环的最佳嵌套顺序,以使完成连接所需的工作量最小。对于TPC-H Q8的情况,这个问题的简化模型由下图所示。</target>
        </trans-unit>
        <trans-unit id="bac722ed74faff65da62171d3c4183479a271d1f" translate="yes" xml:space="preserve">
          <source>TRANSACTION</source>
          <target state="translated">TRANSACTION</target>
        </trans-unit>
        <trans-unit id="c162c076dc07a546449be9e07aa7a5c312ecbfe1" translate="yes" xml:space="preserve">
          <source>TRIGGER</source>
          <target state="translated">TRIGGER</target>
        </trans-unit>
        <trans-unit id="74303786eb95ccd75228db361d37b804576e18e6" translate="yes" xml:space="preserve">
          <source>TRUNCATE</source>
          <target state="translated">TRUNCATE</target>
        </trans-unit>
        <trans-unit id="dc45fdb7de43a003177f8df9ee10d01f58f57a58" translate="yes" xml:space="preserve">
          <source>Table B-Tree Interior Cell (header 0x05):</source>
          <target state="translated">表B树内部单元(头0x05)。</target>
        </trans-unit>
        <trans-unit id="984abe18431413aca60298750d5de10b6d8716c4" translate="yes" xml:space="preserve">
          <source>Table B-Tree Interior Cell:</source>
          <target state="translated">表B-树内部单元。</target>
        </trans-unit>
        <trans-unit id="94d19a21f457eb5da8f03166c4dbc3a6ef641531" translate="yes" xml:space="preserve">
          <source>Table B-Tree Leaf Cell (header 0x0d):</source>
          <target state="translated">表B-树叶单元(头0x0d)。</target>
        </trans-unit>
        <trans-unit id="31beedcdbc76a09dd63a101eacf4e15dc87e80c5" translate="yes" xml:space="preserve">
          <source>Table B-Tree Leaf Cell:</source>
          <target state="translated">表B-树叶细胞。</target>
        </trans-unit>
        <trans-unit id="cdad59a82a2e26e2fc2225d0629f7733aef385c4" translate="yes" xml:space="preserve">
          <source>Table Column Names</source>
          <target state="translated">表列名称</target>
        </trans-unit>
        <trans-unit id="1225362d8c3c05de317acf9684ffe2e1a7649c08" translate="yes" xml:space="preserve">
          <source>Table Interior (0x05)</source>
          <target state="translated">表格内部(0x05)</target>
        </trans-unit>
        <trans-unit id="de156b09866349ad52b0a535e8144a86d129a154" translate="yes" xml:space="preserve">
          <source>Table Leaf (0x0d)</source>
          <target state="translated">表叶(0x0d)</target>
        </trans-unit>
        <trans-unit id="c27c7c360e130231f97ba874c98e3448dd648d35" translate="yes" xml:space="preserve">
          <source>Table Name</source>
          <target state="translated">表名</target>
        </trans-unit>
        <trans-unit id="6a975d3ec2f404cfb761b1314fc6745ca72f942e" translate="yes" xml:space="preserve">
          <source>Table b-tree</source>
          <target state="translated">表b树</target>
        </trans-unit>
        <trans-unit id="92db13efcb630c92ecf1220fd763e9d0e237c97e" translate="yes" xml:space="preserve">
          <source>Table name</source>
          <target state="translated">表名</target>
        </trans-unit>
        <trans-unit id="8fce71f88d0ac569b970cf1bcd57a56acf400366" translate="yes" xml:space="preserve">
          <source>Table name quoting works correctly for the &lt;a href=&quot;cli#csv&quot;&gt;.import&lt;/a&gt; dot-command.</source>
          <target state="translated">表名引用对于&lt;a href=&quot;cli#csv&quot;&gt;.import&lt;/a&gt;点命令正确起作用。</target>
        </trans-unit>
        <trans-unit id="cf3467c6281e0ea2be2b55952d6893e3fbba049d" translate="yes" xml:space="preserve">
          <source>Table or index entries that are out of sequence</source>
          <target state="translated">表或索引条目失序</target>
        </trans-unit>
        <trans-unit id="70aee3388a925e7cbb0852fe8dcdd4c402a95fd1" translate="yes" xml:space="preserve">
          <source>Table zTable does not exist within database zDb,</source>
          <target state="translated">表zTable在数据库zDb中不存在。</target>
        </trans-unit>
        <trans-unit id="8886ec4df0da407409b6e2c6457e09d78592c0c0" translate="yes" xml:space="preserve">
          <source>Table zTable is a WITHOUT ROWID table,</source>
          <target state="translated">表zTable是一个WITHOUT ROWID表。</target>
        </trans-unit>
        <trans-unit id="053f4c073c904977c9ac1e40ab060f8397a0907f" translate="yes" xml:space="preserve">
          <source>Table-name must already exists as a table. File-name must exist, and each row must contain the same number of columns as defined in the table. If a line in the file contains more or less than the number of columns defined, the copy method rollbacks any inserts, and returns an error.</source>
          <target state="translated">表名必须已经作为一个表存在。文件名必须存在,并且每一行必须包含与表中定义的相同数量的列。如果文件中的一行包含的列数超过或少于定义的列数,复制方法将回滚任何插入,并返回一个错误。</target>
        </trans-unit>
        <trans-unit id="aea731c8e5cbf2292cf08d50a7760fa0d709eb35" translate="yes" xml:space="preserve">
          <source>Table-valued Functions In The FROM Clause</source>
          <target state="translated">FROM子句中的表值函数</target>
        </trans-unit>
        <trans-unit id="fc3ba8bea68a8b6f73ff90024cfd6082eaf4a791" translate="yes" xml:space="preserve">
          <source>Table-valued functions</source>
          <target state="translated">表值函数</target>
        </trans-unit>
        <trans-unit id="b503117e6dd30a0beff0cc1ab7fb7d005000dd03" translate="yes" xml:space="preserve">
          <source>Table-valued functions exist only for PRAGMAs that return results and that have no side-effects.</source>
          <target state="translated">表值函数只存在于返回结果且没有副作用的PRAGMA中。</target>
        </trans-unit>
        <trans-unit id="f155ed85208e2d25c37ff0660af9e88e0ce41331" translate="yes" xml:space="preserve">
          <source>Table-valued functions exist only for built-in PRAGMAs, not for PRAGMAs defined using the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control.</source>
          <target state="translated">表值函数仅适用于内置PRAGMA，不适用于使用&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;文件控件定义的PRAGMA。</target>
        </trans-unit>
        <trans-unit id="81ea5c3f4a86eb9511e7fd13ab5c2a7a105f6e9f" translate="yes" xml:space="preserve">
          <source>TableLock</source>
          <target state="translated">TableLock</target>
        </trans-unit>
        <trans-unit id="c52e87aa9f54904a290a1ea1125feb8f0b12b884" translate="yes" xml:space="preserve">
          <source>Tables are removed using the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; statement.</source>
          <target state="translated">使用&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;语句删除表。</target>
        </trans-unit>
        <trans-unit id="5bee9f4ba2588a4abe8a5e77c961e698fb909d93" translate="yes" xml:space="preserve">
          <source>Tables created using CREATE TABLE AS are initially populated with the rows of data returned by the SELECT statement. Rows are assigned contiguously ascending &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; values, starting with 1, in the &lt;a href=&quot;lang_select#orderby&quot;&gt;order&lt;/a&gt; that they are returned by the SELECT statement.</source>
          <target state="translated">使用CREATE TABLE AS创建的表最初会填充SELECT语句返回的数据行。按SELECT语句返回的&lt;a href=&quot;lang_select#orderby&quot;&gt;顺序&lt;/a&gt;，行从1开始连续分配给&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="0b08405f06556bfc4a2cd40880fee5d5df353fe5" translate="yes" xml:space="preserve">
          <source>Tables created using the &quot;CREATE TEMP TABLE&quot; syntax are only visible to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; in which the &quot;CREATE TEMP TABLE&quot; statement is originally evaluated. These TEMP tables, together with any associated indices, triggers, and views, are collectively stored in a separate temporary database file that is created as soon as the first &quot;CREATE TEMP TABLE&quot; statement is seen. This separate temporary database file also has an associated rollback journal. The temporary database file used to store TEMP tables is deleted automatically when the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is closed using &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">使用&amp;ldquo; CREATE TEMP TABLE&amp;rdquo;语法创建的表仅对最初评估&amp;ldquo; CREATE TEMP TABLE&amp;rdquo;语句的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;可见。这些TEMP表以及所有关联的索引，触发器和视图一起存储在单独的临时数据库文件中，该文件在看到第一个&amp;ldquo; CREATE TEMP TABLE&amp;rdquo;语句后即创建。此单独的临时数据库文件还具有关联的回滚日志。使用&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;关闭&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;时，将自动删除用于存储TEMP表的临时数据库文件。</target>
        </trans-unit>
        <trans-unit id="398c675fc2fa417398cf9f153388d4a182136954" translate="yes" xml:space="preserve">
          <source>Tables in an attached database can be referred to using the syntax</source>
          <target state="translated">可以使用以下语法来引用所附数据库中的表</target>
        </trans-unit>
        <trans-unit id="230baa2e574ece0e6ffe7c574dcbbb9cd18fff76" translate="yes" xml:space="preserve">
          <source>Tables with names of the form &quot;sqlite_statN&quot; where N is an integer. Such tables store database statistics gathered by the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command and used by the query planner to help determine the best algorithm to use for each query.</source>
          <target state="translated">名称格式为&amp;ldquo; sqlite_statN&amp;rdquo;的表，其中N为整数。这样的表存储由&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令收集并由查询计划者使用的数据库统计信息，以帮助确定用于每个查询的最佳算法。</target>
        </trans-unit>
        <trans-unit id="6dbeddaf590f294decd7c12cd9b3ac14168d3997" translate="yes" xml:space="preserve">
          <source>Take advantage of the atomic-write capabilities in the &lt;a href=&quot;https://en.wikipedia.org/wiki/F2FS&quot;&gt;F2FS filesystem&lt;/a&gt; when available, for greatly reduced transaction overhead. This currently requires the &lt;a href=&quot;compile#enable_batch_atomic_write&quot;&gt;SQLITE_ENABLE_BATCH_ATOMIC_WRITE&lt;/a&gt; compile-time option.</source>
          <target state="translated">充分利用&lt;a href=&quot;https://en.wikipedia.org/wiki/F2FS&quot;&gt;F2FS文件系统&lt;/a&gt;中的原子写入功能，以大大减少事务开销。当前，这需要&lt;a href=&quot;compile#enable_batch_atomic_write&quot;&gt;SQLITE_ENABLE_BATCH_ATOMIC_WRITE&lt;/a&gt;编译时选项。</target>
        </trans-unit>
        <trans-unit id="acf997da6bf4365bf440bc3ad9c07d7d7925e743" translate="yes" xml:space="preserve">
          <source>Take into account the fact WHERE clause terms that cannot be used with indices still probably reduce the number of output rows.</source>
          <target state="translated">考虑到WHERE子句不能与索引一起使用,仍然可能减少输出行数。</target>
        </trans-unit>
        <trans-unit id="c2975a6466c6b11f1519a6c8652f37b3cef0c265" translate="yes" xml:space="preserve">
          <source>Take the bit-wise AND of the values in register P1 and P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">对寄存器P1和P2中的值进行位与位之间的 AND运算,并将结果存储在寄存器P3中。如果任一输入为NULL,则结果为NULL。</target>
        </trans-unit>
        <trans-unit id="23882df60c1b18a8b147b1926280887dfe7acb8a" translate="yes" xml:space="preserve">
          <source>Take the bit-wise OR of the values in register P1 and P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">对寄存器P1和P2中的值进行位宽OR,并将结果存储在寄存器P3中。如果任一输入为NULL,则结果为NULL。</target>
        </trans-unit>
        <trans-unit id="6a0b05dea29609663a6574c364045bd831c5b261" translate="yes" xml:space="preserve">
          <source>Take the logical AND of the values in registers P1 and P2 and write the result into register P3.</source>
          <target state="translated">取寄存器P1和P2中的值的逻辑AND,并将结果写入寄存器P3中。</target>
        </trans-unit>
        <trans-unit id="9fe2090d6b7e599d38b33eca83b4b2c09d8a131d" translate="yes" xml:space="preserve">
          <source>Take the logical OR of the values in register P1 and P2 and store the answer in register P3.</source>
          <target state="translated">取寄存器P1和P2中的值的逻辑OR,将答案存储在寄存器P3中。</target>
        </trans-unit>
        <trans-unit id="86743ec77172a00f99a2bc089314b61779948598" translate="yes" xml:space="preserve">
          <source>Taking into consideration all of the above, the SQLite developers recommend compiling SQLite using GCC-7 with the -Os optimization setting.</source>
          <target state="translated">考虑到以上所有情况,SQLite开发人员建议使用GCC-7,在-Os优化设置下编译SQLite。</target>
        </trans-unit>
        <trans-unit id="76c9ad6f3798c330d93462b6d6a9dc1c1bbb0620" translate="yes" xml:space="preserve">
          <source>Tarball</source>
          <target state="translated">Tarball</target>
        </trans-unit>
        <trans-unit id="81919e9867e82f4145f1c83ee343766917076a71" translate="yes" xml:space="preserve">
          <source>Tcl Interface</source>
          <target state="translated">Tcl接口</target>
        </trans-unit>
        <trans-unit id="5962096d8eee555590e081b0968ff7c28d5fa0d8" translate="yes" xml:space="preserve">
          <source>Tcl command. Here is an example of opening and then immediately closing a database:</source>
          <target state="translated">Tcl命令。下面是一个打开然后立即关闭数据库的例子。</target>
        </trans-unit>
        <trans-unit id="30d70929c5f61502f6c778af83fbc14057a6c36d" translate="yes" xml:space="preserve">
          <source>Tcl interface allows BLOB values to be transferred to user-defined functions</source>
          <target state="translated">Tcl接口允许将BLOB值转移到用户定义的函数中。</target>
        </trans-unit>
        <trans-unit id="82fe9aa4119c1f18902f153a0d50a82f529e5cfb" translate="yes" xml:space="preserve">
          <source>Tcl variable names can appear in the SQL statement of the second argument in any position where it is legal to put a string or number literal. The value of the variable is substituted for the variable name. If the variable does not exist a NULL values is used. For example:</source>
          <target state="translated">Tcl变量名可以出现在第二个参数的SQL语句中,在任何合法的位置放入一个字符串或数字文字。变量的值被替换为变量名。如果变量不存在,则使用NULL值。例如,在SQL语句中,变量的值被替换为变量名。</target>
        </trans-unit>
        <trans-unit id="2087e1ec9a4eee3edea091cbf4ce24dad9709230" translate="yes" xml:space="preserve">
          <source>Technical and Design Documentation</source>
          <target state="translated">技术和设计文件</target>
        </trans-unit>
        <trans-unit id="b6d6d722a0223fd3e9343b1f4796db6a665b091d" translate="yes" xml:space="preserve">
          <source>Temporary Databases</source>
          <target state="translated">临时数据库</target>
        </trans-unit>
        <trans-unit id="6035a1db7f899a29bfadee59c52d9c07fdd98c4f" translate="yes" xml:space="preserve">
          <source>Temporary Files Used By SQLite</source>
          <target state="translated">SQLite使用的临时文件</target>
        </trans-unit>
        <trans-unit id="9fb2a1ec0fce944f3e17c8ab4b4f05b81d7ac8a9" translate="yes" xml:space="preserve">
          <source>Temporary directory search algorithm</source>
          <target state="translated">临时目录搜索算法</target>
        </trans-unit>
        <trans-unit id="72f84f0ca9f1ad9f151e46cd589374308dcbfc81" translate="yes" xml:space="preserve">
          <source>Temporary files are always stored in memory regardless of the setting of the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">无论&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;的设置如何，临时文件总是存储在内存中。</target>
        </trans-unit>
        <trans-unit id="92a5156680aa1ea2c11db1f65a26abbd9db39a63" translate="yes" xml:space="preserve">
          <source>Temporary files are always stored on disk regardless of the setting of the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">无论&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;的设置如何，临时文件总是存储在磁盘上。</target>
        </trans-unit>
        <trans-unit id="7777ca8353568841ffb0454d79b2cf5d09f1f51b" translate="yes" xml:space="preserve">
          <source>Temporary files are now automatically deleted by the operating system when closed. There are no more dangling temporary files on a program crash. (If the OS crashes, fsck will delete the file after reboot under Unix. I do not know what happens under Windows.)</source>
          <target state="translated">临时文件现在会在关闭时被操作系统自动删除。程序崩溃时不再有悬空的临时文件。(如果操作系统崩溃,在Unix下,fsck会在重启后删除文件。我不知道在Windows下会怎样)。)</target>
        </trans-unit>
        <trans-unit id="96da9e1a1910e6d40a0e879229d60b3a31a1bf7a" translate="yes" xml:space="preserve">
          <source>Temporary files are stored in memory by default but this can be overridden by the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">默认情况下，临时文件存储在内存中，但是可以由&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;覆盖。</target>
        </trans-unit>
        <trans-unit id="11e15117ca75e55537b6f5f3dded721aee297def" translate="yes" xml:space="preserve">
          <source>Temporary files are stored on disk by default but this can be overridden by the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">默认情况下，临时文件存储在磁盘上，但是可以由&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;覆盖。</target>
        </trans-unit>
        <trans-unit id="7500f7d38f84089cbb32d6695814260f35c022d2" translate="yes" xml:space="preserve">
          <source>Temporary journal files are created as part of transaction control, but those extra files are not part of the steady-state database.</source>
          <target state="translated">临时日志文件是作为事务控制的一部分创建的,但这些额外的文件不是稳态数据库的一部分。</target>
        </trans-unit>
        <trans-unit id="455a1e08ff236bc4fc37f10c45a4f1a9d962e921" translate="yes" xml:space="preserve">
          <source>Temporary tables</source>
          <target state="translated">临时表格</target>
        </trans-unit>
        <trans-unit id="4dff3aa4061b74df07e184cd766c027d8d0851b5" translate="yes" xml:space="preserve">
          <source>Terminate the sqlite3 program by typing your system End-Of-File character (usually a Control-D). Use the interrupt character (usually a Control-C) to stop a long-running SQL statement.</source>
          <target state="translated">通过键入系统的End-Of-File字符(通常是Control-D)来终止sqlite3程序。使用中断字符(通常是Control-C)来停止一条长时间运行的SQL语句。</target>
        </trans-unit>
        <trans-unit id="f859f91a5306999f44ef0e2194daef49cbdeb611" translate="yes" xml:space="preserve">
          <source>Terminating a read-only transaction.</source>
          <target state="translated">终止一个只读交易。</target>
        </trans-unit>
        <trans-unit id="46428866c7ab286d2c6ac557b2373b6b72377ee3" translate="yes" xml:space="preserve">
          <source>Terms of the ORDER BY clause that is part of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement may be assigned a collating sequence using the &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, in which case the specified collating function is used for sorting. Otherwise, if the expression sorted by an ORDER BY clause is a column, then the collating sequence of the column is used to determine sort order. If the expression is not a column and has no COLLATE clause, then the BINARY collating sequence is used.</source>
          <target state="translated">可以使用&lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE运算符&lt;/a&gt;为作为&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句一部分的ORDER BY子句的术语分配整理序列，在这种情况下，将使用指定的整理函数进行排序。否则，如果按ORDER BY子句排序的表达式是一列，则使用该列的整理顺序来确定排序顺序。如果表达式不是列，并且没有COLLATE子句，则使用BINARY排序序列。</target>
        </trans-unit>
        <trans-unit id="fcd7a264ae14d824015af364fb3c10f3c2a51f9d" translate="yes" xml:space="preserve">
          <source>Terms of the WHERE clause can be manually disqualified for use with indexes by prepending a unary &lt;b&gt;+&lt;/b&gt; operator to the column name. The unary &lt;b&gt;+&lt;/b&gt; is a no-op and will not generate any byte code in the prepared statement. However, the unary &lt;b&gt;+&lt;/b&gt; operator will prevent the term from constraining an index. So, in the example above, if the query were rewritten as:</source>
          <target state="translated">通过在列名前添加一元&lt;b&gt;+&lt;/b&gt;运算符，可以手动取消WHERE子句的条件，使其不能与索引一起使用。一元&lt;b&gt;+&lt;/b&gt;是空操作，不会在准备好的语句中生成任何字节码。但是，一元&lt;b&gt;+&lt;/b&gt;运算符将阻止该术语限制索引。因此，在上面的示例中，如果查询被重写为：</target>
        </trans-unit>
        <trans-unit id="1cb252ee8cea482226d27c4a24f04af58befef27" translate="yes" xml:space="preserve">
          <source>Terms of the WHERE clause can be manually disqualified for use with indices by prepending a unary *+* operator to the column name. The unary *+* is a no-op and will not generate any byte code in the prepared statement. But the unary *+* operator will prevent the term from constraining an index. So, in the example above, if the query were rewritten as:</source>
          <target state="translated">WHERE子句的条款可以通过在列名前加上单数*+*操作符来手动取消索引的使用资格。单元*+*是一个无操作符,不会在准备好的语句中产生任何字节代码。但是,单利*+*操作符会阻止该项对索引的约束。所以,在上面的例子中,如果将查询改写为。</target>
        </trans-unit>
        <trans-unit id="db8a7aee242ffd686d07e20367e523410ddf047e" translate="yes" xml:space="preserve">
          <source>Test 10: 25000 text UPDATEs with an index</source>
          <target state="translated">测试10:25000个带有索引的文本UPDATE。</target>
        </trans-unit>
        <trans-unit id="aacbc05d861c7b90deae327687214123e261d5d7" translate="yes" xml:space="preserve">
          <source>Test 11: INSERTs from a SELECT</source>
          <target state="translated">测试11:从SELECT中插入的内容</target>
        </trans-unit>
        <trans-unit id="aca64bdf90089bb1a7f070072ce5ba7eb929e0ca" translate="yes" xml:space="preserve">
          <source>Test 12: DELETE without an index</source>
          <target state="translated">测试12:不带索引的DELETE</target>
        </trans-unit>
        <trans-unit id="24752c37e60c377f791b489053904e7999992109" translate="yes" xml:space="preserve">
          <source>Test 13: DELETE with an index</source>
          <target state="translated">测试13:带索引的DELETE</target>
        </trans-unit>
        <trans-unit id="00cb0edebe54a9c5c407d066d9fcba0da202194b" translate="yes" xml:space="preserve">
          <source>Test 14: A big INSERT after a big DELETE</source>
          <target state="translated">测试14:大DELETE后的大INSERT</target>
        </trans-unit>
        <trans-unit id="8033466c1d65a1a2a0c68dc77e0e42697e35f88b" translate="yes" xml:space="preserve">
          <source>Test 15: A big DELETE followed by many small INSERTs</source>
          <target state="translated">测试15:一个大的DELETE之后是许多小的INSERTs</target>
        </trans-unit>
        <trans-unit id="391b748d4bf30ad6ba35b1537b20fb9263b9be11" translate="yes" xml:space="preserve">
          <source>Test 16: DROP TABLE</source>
          <target state="translated">测试16:DROP表</target>
        </trans-unit>
        <trans-unit id="700f1cfb18cec62b7bd8f4bd15b16b69774b094a" translate="yes" xml:space="preserve">
          <source>Test 1: 1000 INSERTs</source>
          <target state="translated">测试1:1000次插入</target>
        </trans-unit>
        <trans-unit id="a74380705222d36f436d75c90099251831b68c6d" translate="yes" xml:space="preserve">
          <source>Test 2: 25000 INSERTs in a transaction</source>
          <target state="translated">测试2:一个事务中的25000个INSERT。</target>
        </trans-unit>
        <trans-unit id="d01c89b36c5ea1e456013c3cc10174d42005deaa" translate="yes" xml:space="preserve">
          <source>Test 3: 25000 INSERTs into an indexed table</source>
          <target state="translated">测试3:在索引表中插入25000个INSERTs。</target>
        </trans-unit>
        <trans-unit id="5150380a9467a7720fe9216afc4866b3aea9f992" translate="yes" xml:space="preserve">
          <source>Test 4: 100 SELECTs without an index</source>
          <target state="translated">测试4:100个没有索引的SELECTs。</target>
        </trans-unit>
        <trans-unit id="2d07089542c5b6e56dea3631a868016dd2267c55" translate="yes" xml:space="preserve">
          <source>Test 5: 100 SELECTs on a string comparison</source>
          <target state="translated">测试5:在字符串比较上进行100个SELECTs。</target>
        </trans-unit>
        <trans-unit id="1ee313e9981650c288efefb71dc3528b68b2a91a" translate="yes" xml:space="preserve">
          <source>Test 6: Creating an index</source>
          <target state="translated">测试6:创建索引</target>
        </trans-unit>
        <trans-unit id="e0797e7844f18b5e63c9d2f6207a7266e87d829e" translate="yes" xml:space="preserve">
          <source>Test 7: 5000 SELECTs with an index</source>
          <target state="translated">测试7:5000个带指数的SELECTs。</target>
        </trans-unit>
        <trans-unit id="fccbfc70f55db2b38d057e5e2decb47d90df070e" translate="yes" xml:space="preserve">
          <source>Test 8: 1000 UPDATEs without an index</source>
          <target state="translated">测试8:1000次没有索引的UPDATE。</target>
        </trans-unit>
        <trans-unit id="47ad12d810778d98e72de67605dc988105d4b09b" translate="yes" xml:space="preserve">
          <source>Test 9: 25000 UPDATEs with an index</source>
          <target state="translated">测试9:25000次UPDATEs,有一个指数。</target>
        </trans-unit>
        <trans-unit id="18a302ee283ea042f30ca2cb852a2846f97c9413" translate="yes" xml:space="preserve">
          <source>Test Code</source>
          <target state="translated">测试代码</target>
        </trans-unit>
        <trans-unit id="fbcf57d6160711801ae44b031c459127add7faaa" translate="yes" xml:space="preserve">
          <source>Test Environment</source>
          <target state="translated">测试环境</target>
        </trans-unit>
        <trans-unit id="a76dd0a3dd495aa45fe2a39614c44782afcb01ca" translate="yes" xml:space="preserve">
          <source>Test For Auto-Commit Mode</source>
          <target state="translated">测试自动提交模式</target>
        </trans-unit>
        <trans-unit id="c05597ed0dba53dda21d6b294858039879f34b2b" translate="yes" xml:space="preserve">
          <source>Test To See If The Library Is Threadsafe</source>
          <target state="translated">测试库是否是线程安全的</target>
        </trans-unit>
        <trans-unit id="02446da6bfd0c0c261b870c2d7a5bfb426f2969d" translate="yes" xml:space="preserve">
          <source>Test data unavailable.</source>
          <target state="translated">测试数据不可用。</target>
        </trans-unit>
        <trans-unit id="a364e52356a7ca07cff67161e3755ffa1a5b6b19" translate="yes" xml:space="preserve">
          <source>Test if a changeset has recorded any changes</source>
          <target state="translated">测试一个变化集是否记录了任何变化</target>
        </trans-unit>
        <trans-unit id="0687fd76855654ace6e8592132670b232e8466bb" translate="yes" xml:space="preserve">
          <source>Test if a changeset has recorded any changes.</source>
          <target state="translated">测试一个变化集是否记录了任何变化。</target>
        </trans-unit>
        <trans-unit id="975278e4cf4ae85f07454f0bd57ddce6fc5bd9a5" translate="yes" xml:space="preserve">
          <source>Testcase macros are also used when two or more cases of a switch statement go to the same block of code, to make sure that the code was reached for all cases:</source>
          <target state="translated">当一个switch语句的两个或多个case进入同一个代码块时,也会使用testcase宏,以确保所有case的代码都被达成。</target>
        </trans-unit>
        <trans-unit id="c5d38ba7cbc400f9b209719e16e540214a64776c" translate="yes" xml:space="preserve">
          <source>Testing Interface</source>
          <target state="translated">测试界面</target>
        </trans-unit>
        <trans-unit id="8adc754de4730d9303e4e9dfdc04c11250d45d3c" translate="yes" xml:space="preserve">
          <source>Testing Interface Operation Codes</source>
          <target state="translated">测试接口操作代码</target>
        </trans-unit>
        <trans-unit id="61b27896db003bc4e45807f83422aff3b0ba8af9" translate="yes" xml:space="preserve">
          <source>Testing of both source code and object code</source>
          <target state="translated">源代码和对象代码的测试</target>
        </trans-unit>
        <trans-unit id="e1859263f675753d24029e449e12bbca3196f641" translate="yes" xml:space="preserve">
          <source>Testing on multiple platforms and with multiple compilers</source>
          <target state="translated">在多个平台上进行测试,并使用多个编译器。</target>
        </trans-unit>
        <trans-unit id="c9efb9d787a1a844d9d75c706c96b2d104de210f" translate="yes" xml:space="preserve">
          <source>Text Encodings</source>
          <target state="translated">文本编码</target>
        </trans-unit>
        <trans-unit id="104683d616e58eaef10d6dc4873ecdc3df7b2908" translate="yes" xml:space="preserve">
          <source>Text encoding</source>
          <target state="translated">文本编码</target>
        </trans-unit>
        <trans-unit id="e12c4eeb80ad1f4c53769014c35b62416e040202" translate="yes" xml:space="preserve">
          <source>Text files read by the COPY command can now have line terminators of LF, CRLF, or CR.</source>
          <target state="translated">通过COPY命令读取的文本文件现在可以使用LF、CRLF或CR作为行结束符。</target>
        </trans-unit>
        <trans-unit id="cc9a8c0f2eca40d02a98349a624352ec809c4662" translate="yes" xml:space="preserve">
          <source>Text is appended to the sqlite3_str object using various methods, such as &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendf()&lt;/a&gt;.</source>
          <target state="translated">使用各种方法（例如&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendf（））&lt;/a&gt;将文本附加到sqlite3_str对象。</target>
        </trans-unit>
        <trans-unit id="3f06b000ef5df2cf2524013049769bc8b85cadef" translate="yes" xml:space="preserve">
          <source>Text is appended to the sqlite3_str object using various methods, such as &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendf()&lt;/a&gt;.</source>
          <target state="translated">使用各种方法（例如&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendf（））&lt;/a&gt;将文本附加到sqlite3_str对象。</target>
        </trans-unit>
        <trans-unit id="65ebd99ce12ebe199710e41e33f5f3620f55ed7a" translate="yes" xml:space="preserve">
          <source>Text values (odd serial types 13 and larger) sort after numeric values in the order determined by the columns &lt;a href=&quot;datatype3#collation&quot;&gt;collating function&lt;/a&gt;.</source>
          <target state="translated">文本值（奇数串行类型13和更大）按列&lt;a href=&quot;datatype3#collation&quot;&gt;排序函数&lt;/a&gt;确定的顺序在数字值之后排序。</target>
        </trans-unit>
        <trans-unit id="beca9771feb98f615524a1df72482f4458f93607" translate="yes" xml:space="preserve">
          <source>Text values come after numerics</source>
          <target state="translated">文本值在数字之后</target>
        </trans-unit>
        <trans-unit id="938716cf9d2d773dc94de020d7864e49e44b2b9d" translate="yes" xml:space="preserve">
          <source>Th functionality described in this section may be integrated into other applications or tools using the &lt;a href=&quot;http://www.sqlite.org/src/dir?ci=trunk&amp;amp;name=ext/expert&quot;&gt; SQLite expert extension&lt;/a&gt; code.</source>
          <target state="translated">使用&lt;a href=&quot;http://www.sqlite.org/src/dir?ci=trunk&amp;amp;name=ext/expert&quot;&gt;SQLite专家扩展&lt;/a&gt;代码，本节中描述的功能可以集成到其他应用程序或工具中。</target>
        </trans-unit>
        <trans-unit id="60ce50a49fab2debe76004dae03d373ca41cf229" translate="yes" xml:space="preserve">
          <source>Th functionality described in this section may be integrated into other applications or tools using the &lt;a href=&quot;https://www.sqlite.org/src/dir?ci=trunk&amp;amp;name=ext/expert&quot;&gt; SQLite expert extension&lt;/a&gt; code.</source>
          <target state="translated">使用&lt;a href=&quot;https://www.sqlite.org/src/dir?ci=trunk&amp;amp;name=ext/expert&quot;&gt;SQLite专家扩展&lt;/a&gt;代码，本节中描述的功能可以集成到其他应用程序或工具中。</target>
        </trans-unit>
        <trans-unit id="5401c7212b5c2e26aee89d6b33a167be2b97f64d" translate="yes" xml:space="preserve">
          <source>That command only works as written on Windows. The equivalent line on a Mac would be:</source>
          <target state="translated">这条命令只在Windows上按写的方式工作。在Mac上的对应行是</target>
        </trans-unit>
        <trans-unit id="5b3c3c06cd257877a1f47703881aa426e835ba23" translate="yes" xml:space="preserve">
          <source>That last command is the same &quot;ui&quot; command that we ran before. It starts a mini-webserver running and points your web browser at it. But this time we didn't have to specify the repository file because we are located inside a checkout and so fossil can figure out the repository for itself. If you want to type in the repository filename as the second argument, you can. But it is optional.</source>
          <target state="translated">最后一条命令就是我们之前运行的 &quot;ui &quot;命令。它开始运行一个迷你服务器,并将你的网络浏览器指向它。但这次我们不用指定仓库文件,因为我们位于一个checkout里面,所以fossil可以自己找出仓库。如果你想输入版本库文件名作为第二个参数,你可以。但它是可选的。</target>
        </trans-unit>
        <trans-unit id="a5f3f833bc87b1f8e923756ce16d0960d01c9cad" translate="yes" xml:space="preserve">
          <source>That number is very close to 47.49, but it is not exact. It is a little too big. If we reduce M by one to 6683623321994526 so that we have the next smaller possible binary64 value, we get:</source>
          <target state="translated">这个数字非常接近47.49,但并不准确。它有点太大了。如果我们把M减一为6683623321994526,这样我们就有了下一个更小的可能的二进制64值,我们得到:</target>
        </trans-unit>
        <trans-unit id="3ec5cf39a76e0d09154e1a51128f437190f411ce" translate="yes" xml:space="preserve">
          <source>That said, there are a number of things that external programs or bugs in your hardware or OS can do to corrupt a database file. See &lt;a href=&quot;howtocorrupt&quot;&gt;How To Corrupt An SQLite Database File&lt;/a&gt; for further information.</source>
          <target state="translated">就是说，硬件或操作系统中的外部程序或错误可以通过多种方式破坏数据库文件。有关更多信息，请参见&lt;a href=&quot;howtocorrupt&quot;&gt;如何损坏SQLite数据库文件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ac09579911e9129dbe219b67c0bf67a294beccfa" translate="yes" xml:space="preserve">
          <source>That statement is ambiguous, having at least two possible interpretations:</source>
          <target state="translated">这句话含糊不清,至少有两种可能的解释。</target>
        </trans-unit>
        <trans-unit id="c679c2a5140d95b7fe5e7a9c937890448e4790a5" translate="yes" xml:space="preserve">
          <source>That there are the same number of entries in the %_parent table as there are non-leaf cells in the r-tree structure, and that there is a non-leaf cell that corresponds to each entry in the %_parent table.</source>
          <target state="translated">%_parent表中的条目数与r树结构中的非叶单元数相同,并且%_parent表中的每个条目都有一个非叶单元对应。</target>
        </trans-unit>
        <trans-unit id="9bc14fa3c4653db3dfe511c9da292c9e32677da7" translate="yes" xml:space="preserve">
          <source>That there are the same number of entries in the %_rowid table as there are leaf cells in the r-tree structure, and that there is a leaf cell that corresponds to each entry in the %_rowid table.</source>
          <target state="translated">表示%_rowid表中的条目数与r树结构中的叶子单元数相同,并且%_rowid表中的每个条目都有一个叶子单元对应。</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="c3fcc1dd87de9c9ad15a933b970c62ff1decbfcb" translate="yes" xml:space="preserve">
          <source>The &quot;%&quot; in the name of each shadow table is replaced by the name of the R*Tree virtual table. So, if the name of the R*Tree table is &quot;xyz&quot; then the three shadow tables would be &quot;xyz_node&quot;, &quot;xyz_parent&quot;, and &quot;xyz_rowid&quot;.</source>
          <target state="translated">每个影子表名称中的&quot;%&quot;会被R*Tree虚拟表的名称所代替。因此,如果R*Tree表的名称是 &quot;xyz&quot;,那么三个影子表将是 &quot;xyz_node&quot;、&quot;xyz_parent &quot;和 &quot;xyz_rowid&quot;。</target>
        </trans-unit>
        <trans-unit id="c0ac1d4dc22d0f78dbeef0512926462de5ac6f42" translate="yes" xml:space="preserve">
          <source>The &quot;-1&quot; term at the start of the formula is not found in most implementations of the BM25 algorithm. Without it, a better match is assigned a numerically higher BM25 score. Since the default sorting order is &quot;ascending&quot;, this means that appending &quot;ORDER BY bm25(fts)&quot; to a query would cause results to be returned in order from worst to best. The &quot;DESC&quot; keyword would be required in order to return the best matches first. In order to avoid this pitfall, the FTS5 implementation of BM25 multiplies the result by -1 before returning it, ensuring that better matches are assigned numerically lower scores.</source>
          <target state="translated">公式开头的&quot;-1 &quot;项在BM25算法的大多数实现中都不存在。如果没有这个词,一个更好的匹配度会被分配一个更高的BM25分数。由于默认的排序顺序是 &quot;升序&quot;,这意味着在查询中添加 &quot;ORDER BY bm25(fts)&quot;将导致结果按照从最差到最好的顺序返回。为了先返回最好的匹配结果,需要使用 &quot;DESC &quot;关键字。为了避免这个缺陷,BM25的FTS5实现在返回结果之前将结果乘以-1,确保较好的匹配结果在数字上被分配较低的分数。</target>
        </trans-unit>
        <trans-unit id="e8a8a21328c61527fb3df55781ac56d188f8d80f" translate="yes" xml:space="preserve">
          <source>The &quot;.archive&quot; dot-command and the &quot;-A&quot; command-line option provide built-in support for the &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive format&lt;/a&gt;. The interface is similar to that of the &quot;tar&quot; command on unix systems. Each invocation of the &quot;.ar&quot; command must specify a single command option. The following commands are available for &quot;.archive&quot;:</source>
          <target state="translated">&amp;ldquo; .archive&amp;rdquo;点命令和&amp;ldquo; -A&amp;rdquo;命令行选项提供对&lt;a href=&quot;sqlar&quot;&gt;SQLite存档格式的&lt;/a&gt;内置支持。该接口类似于unix系统上的&amp;ldquo; tar&amp;rdquo;命令。每次对&amp;ldquo; .ar&amp;rdquo;命令的调用都必须指定一个命令选项。以下命令可用于&amp;ldquo; .archive&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="83487a27f6e8c5a3e4b3ee1c0c3210033e4ad993" translate="yes" xml:space="preserve">
          <source>The &quot;.breakpoint&quot; command in the CLI does nothing but invoke the procedure named &quot;test_breakpoint()&quot;, which is a no-op.</source>
          <target state="translated">CLI中的&quot;.breakpoint &quot;命令除了调用名为 &quot;test_breakpoint()&quot;的存储过程外,没有任何作用。</target>
        </trans-unit>
        <trans-unit id="469a3442411a65b2a429f963b79791f612ed7d6e" translate="yes" xml:space="preserve">
          <source>The &quot;.databases&quot; command shows a list of all databases open in the current connection. There will always be at least 2. The first one is &quot;main&quot;, the original database opened. The second is &quot;temp&quot;, the database used for temporary tables. There may be additional databases listed for databases attached using the ATTACH statement. The first output column is the name the database is attached with, and the second column is the filename of the external file.</source>
          <target state="translated">&quot;.databases &quot;命令显示了当前连接中打开的所有数据库的列表。第一个是 &quot;main&quot;,也就是原来打开的数据库,第二个是 &quot;temp&quot;,用于临时表的数据库。第二个是 &quot;temp&quot;,用于临时表的数据库。对于使用ATTACH语句连接的数据库,可能会有额外的数据库列出。第一个输出列是用数据库附加的名称,第二个列是外部文件的文件名。</target>
        </trans-unit>
        <trans-unit id="d20a2da5a51f1af193930a68e8670b4b6926e994" translate="yes" xml:space="preserve">
          <source>The &quot;.databases&quot; command shows a list of all databases open in the current connection. There will always be at least 2. The first one is &quot;main&quot;, the original database opened. The second is &quot;temp&quot;, the database used for temporary tables. There may be additional databases listed for databases attached using the ATTACH statement. The first output column is the name the database is attached with, and the second result column is the filename of the external file. There may be a third result column which will be either &quot;'r/o'&quot; or &quot;'r/w'&quot; depending of if the database file is read-only or read-write. And there might be fourth result column showing the result of &lt;a href=&quot;c3ref/txn_state&quot;&gt;sqlite3_txn_state()&lt;/a&gt; for that database file.</source>
          <target state="translated">&amp;ldquo; .databases&amp;rdquo;命令显示在当前连接中打开的所有数据库的列表。总会有至少2个。第一个是&amp;ldquo; main&amp;rdquo;，原始数据库已打开。第二个是&amp;ldquo;临时&amp;rdquo;，用于临时表的数据库。对于使用ATTACH语句附加的数据库，可能还会列出其他数据库。第一个输出列是数据库附加的名称，第二个结果列是外部文件的文件名。根据数据库文件是只读文件还是读写文件，可能会有第三个结果列将为&amp;ldquo;'r / o'&amp;rdquo;或&amp;ldquo;'r / w'&amp;rdquo;。并且可能会有第四结果列显示该数据库文件的&lt;a href=&quot;c3ref/txn_state&quot;&gt;sqlite3_txn_state（）&lt;/a&gt;的结果。</target>
        </trans-unit>
        <trans-unit id="ee926b57bed300f9a7e5c92f6be433c508e9bcc7" translate="yes" xml:space="preserve">
          <source>The &quot;.dump&quot; output from the shell does not work if there are embedded newlines anywhere in the data. This is an old bug that was carried forward from version 1.0. To fix it, the &quot;.dump&quot; output no longer uses the COPY command. It instead generates INSERT statements.</source>
          <target state="translated">如果数据中存在内嵌的换行符,shell的&quot;.dump &quot;输出就无法使用。这是一个从1.0版本延续下来的老问题。为了解决这个问题,&quot;.dump &quot;的输出不再使用COPY命令,而是生成INSERT语句。它将生成INSERT语句。</target>
        </trans-unit>
        <trans-unit id="1b85291d31b07e89b01fbd9925959d88473c2a10" translate="yes" xml:space="preserve">
          <source>The &quot;.excel&quot; command is an alias for &quot;.once -x&quot;. It does exactly the same thing.</source>
          <target state="translated">&quot;.excel &quot;命令是&quot;.once -x &quot;的别名。它的作用是完全一样的。</target>
        </trans-unit>
        <trans-unit id="9686c64857b56634cf1d980b549835b7a48ecb3c" translate="yes" xml:space="preserve">
          <source>The &quot;.excel&quot; command is really an alias for &quot;.once -x&quot;. The -x option to .once causes it to writes results as CSV into a temporary file that is named with a &quot;.csv&quot; suffix, then invoke the systems default handler for CSV files.</source>
          <target state="translated">&quot;.excel &quot;命令实际上是&quot;.once -x &quot;的别名。.excel命令的-x选项会将结果以CSV的形式写入一个后缀为&quot;.csv &quot;的临时文件中,然后调用系统默认的CSV文件处理程序。</target>
        </trans-unit>
        <trans-unit id="a0ea244938baaf074aedf53e702eadce70d483bf" translate="yes" xml:space="preserve">
          <source>The &quot;.expert&quot; command accepts the following options:</source>
          <target state="translated">&quot;.expert &quot;命令接受以下选项:</target>
        </trans-unit>
        <trans-unit id="62869dd914f2d45ca628931082045505cc0aa98c" translate="yes" xml:space="preserve">
          <source>The &quot;.expert&quot; command is issued first, followed by the SQL query on a separate line. For example, consider the following session:</source>
          <target state="translated">先发出&quot;.expert &quot;命令,然后在单独的一行上进行SQL查询。例如,考虑以下会话。</target>
        </trans-unit>
        <trans-unit id="bf73e6ae296e826f7923e0357132694890491637" translate="yes" xml:space="preserve">
          <source>The &quot;.fullschema&quot; dot-command works like the &quot;.schema&quot; command in that it displays the entire database schema. But &quot;.fullschema&quot; also includes dumps of the statistics tables &quot;sqlite_stat1&quot;, &quot;sqlite_stat3&quot;, and &quot;sqlite_stat4&quot;, if they exist. The &quot;.fullschema&quot; command normally provides all of the information needed to exactly recreate a query plan for a specific query. When reporting suspected problems with the SQLite query planner to the SQLite development team, developers are requested to provide the complete &quot;.fullschema&quot; output as part of the trouble report. Note that the sqlite_stat3 and sqlite_stat4 tables contain samples of index entries and so might contain sensitive data, so do not send the &quot;.fullschema&quot; output of a proprietary database over a public channel.</source>
          <target state="translated">&quot;.fullschema &quot;点命令的工作原理和&quot;.schema &quot;命令一样,它显示整个数据库的模式。但是&quot;.fullschema &quot;还包括统计表 &quot;sqlite_stat1&quot;、&quot;sqlite_stat3 &quot;和 &quot;sqlite_stat4 &quot;的转储,如果它们存在的话。&quot;.fullschema &quot;命令通常提供了为特定查询准确地重新创建查询计划所需的所有信息。当向SQLite开发团队报告SQLite查询计划器的可疑问题时,要求开发人员提供完整的&quot;.fullschema &quot;输出作为故障报告的一部分。需要注意的是,sqlite_stat3和sqlite_stat4表包含索引项的样本,因此可能包含敏感数据,所以不要通过公共渠道发送专有数据库的&quot;.fullschema &quot;输出。</target>
        </trans-unit>
        <trans-unit id="8c41f773b4bec069e65cdeb1f84472339fd67927" translate="yes" xml:space="preserve">
          <source>The &quot;.genfkey&quot; operator has been removed from the &lt;a href=&quot;cli&quot;&gt;Command Line Interface&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo; .genfkey&amp;rdquo;运算符已&lt;a href=&quot;cli&quot;&gt;从命令行界面中&lt;/a&gt;删除。</target>
        </trans-unit>
        <trans-unit id="6da1e8e52719870c46e4714e803817bbb945c7a2" translate="yes" xml:space="preserve">
          <source>The &quot;.indexes&quot; command works in a similar way to list all of the indexes. If the &quot;.indexes&quot; command is given an argument which is the name of a table, then it shows just indexes on that table.</source>
          <target state="translated">&quot;.indexes &quot;命令的工作方式类似于列出所有的索引。如果给&quot;.indexes &quot;命令的参数是一个表的名称,那么它只显示该表的索引。</target>
        </trans-unit>
        <trans-unit id="332e81eb83bf30c51e9f2eb4830d160fd5e91b60" translate="yes" xml:space="preserve">
          <source>The &quot;.load&quot; command with one argument invokes sqlite3_load_extension() with the zProc parameter set to NULL, causing SQLite to first look for an entry point named &quot;sqlite3_extension_init&quot; and then &quot;sqlite3_X_init&quot; where &quot;X&quot; is derived from the filename. If your extension has an entry point with a different name, simply supply that name as the second argument. For example:</source>
          <target state="translated">带有一个参数的&quot;.load &quot;命令在zProc参数设置为NULL的情况下调用sqlite3_load_extension(),使SQLite首先寻找一个名为 &quot;sqlite3_extension_init &quot;的入口点,然后再寻找 &quot;sqlite3_X_init&quot;,其中 &quot;X &quot;是由文件名衍生出来的。如果你的扩展有一个不同名称的入口点,只需提供该名称作为第二个参数。例如:&quot;Sqlite3_X_init&quot;,其中 &quot;X &quot;来源于文件名。</target>
        </trans-unit>
        <trans-unit id="7e0f642688db88c440c3786a62b2e62ab2274b87" translate="yes" xml:space="preserve">
          <source>The &quot;.parameter&quot; command exists to simplify managing this table. The &quot;.parameter init&quot; command (often abbreviated as just &quot;.param init&quot;) creates the temp.sqlite_parameters table if it does not already exist. The &quot;.param list&quot; command shows all entries in the temp.sqlite_parameters table. The &quot;.param clear&quot; command drops the temp.sqlite_parameters table. The &quot;.param set KEY VALUE&quot; and &quot;.param unset KEY&quot; commands create or delete entries from the temp.sqlite_parameters table.</source>
          <target state="translated">&quot;.parameter &quot;命令的存在是为了简化对这个表的管理。如果temp.sqlite_parameters表还不存在,那么&quot;.parameter init &quot;命令(通常缩写为&quot;.param init&quot;)将创建该表。&quot;.param list &quot;命令显示temp.sqlite_parameters表中的所有条目。&quot;.param clear &quot;命令会删除temp.sqlite_parameters表。&quot;.param set KEY VALUE &quot;和&quot;.param unset KEY &quot;命令从 temp.sqlite_parameters 表中创建或删除条目。</target>
        </trans-unit>
        <trans-unit id="37cba1b3643d5235ea4e515f4ee004481495d64b" translate="yes" xml:space="preserve">
          <source>The &quot;.read&quot; command takes a single argument which is (usually) the name of a file from which to read input text.</source>
          <target state="translated">&quot;.read &quot;命令只有一个参数,(通常)是读取输入文本的文件名。</target>
        </trans-unit>
        <trans-unit id="7b54f6bbb126d4f3d8cbe5461cc017452178177b" translate="yes" xml:space="preserve">
          <source>The &quot;.read&quot; command temporarily stops reading from the keyboard and instead takes its input from the file named. Upon reaching the end of the file, input reverts back to the keyboard. The script file may contain dot-commands, just like ordinary interactive input.</source>
          <target state="translated">&quot;.read &quot;命令暂时停止从键盘上读取数据,而是从名为&quot;.read &quot;的文件中获取输入。当到达文件的末端时,输入又回到键盘。脚本文件可以包含点命令,就像普通的交互式输入一样。</target>
        </trans-unit>
        <trans-unit id="789a156efc523de5bfce09730a51219cae2ec0c9" translate="yes" xml:space="preserve">
          <source>The &quot;.schema&quot; command can be augmented with the &quot;--indent&quot; option, in which case it tries to reformat the various CREATE statements of the schema so that they are more easily readable by humans.</source>
          <target state="translated">&quot;.schema &quot;命令可以用&quot;--indent &quot;选项来增强,在这种情况下,它试图对模式的各种CREATE语句进行重新格式化,使它们更容易被人类阅读。</target>
        </trans-unit>
        <trans-unit id="754968254f462d66877df03c1c7cd51953693cab" translate="yes" xml:space="preserve">
          <source>The &quot;.schema&quot; command is roughly the same as setting list mode, then entering the following query:</source>
          <target state="translated">&quot;.schema &quot;命令与设置列表模式大致相同,然后输入以下查询。</target>
        </trans-unit>
        <trans-unit id="7428559526f83a5c56d268af9889807faae2685e" translate="yes" xml:space="preserve">
          <source>The &quot;.schema&quot; command shows the complete schema for the database, or for a single table if an optional tablename argument is provided:</source>
          <target state="translated">&quot;.schema &quot;命令显示了数据库的完整模式,如果提供了一个可选的tablename参数,则显示单个表的模式。</target>
        </trans-unit>
        <trans-unit id="52ace065300c40138c37799338bd3ec51aca18df" translate="yes" xml:space="preserve">
          <source>The &quot;.schema&quot; command shows the structure of virtual tables.</source>
          <target state="translated">&quot;.schema &quot;命令显示了虚拟表的结构。</target>
        </trans-unit>
        <trans-unit id="73bcba8970e82dc921d7f4ec8db20bb33cbfb0a3" translate="yes" xml:space="preserve">
          <source>The &quot;.selftest --init&quot; command creates the selftest table if it does not already exists, then appends entries that check the SHA3 hash of the content of all tables. Subsequent runs of &quot;.selftest&quot; will verify that the database has not been changed in any way. To generates tests to verify that a subset of the tables are unchanged, simply run &quot;.selftest --init&quot; then &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; the selftest rows that refer to tables that are not constant.</source>
          <target state="translated">如果&amp;ldquo; .selftest --init&amp;rdquo;命令尚不存在，则会创建该表，然后追加检查所有表内容的SHA3哈希的条目。随后的&amp;ldquo; .selftest&amp;rdquo;运行将验证数据库没有任何更改。要生成测试以验证表的子集未更改，只需运行&amp;ldquo; .selftest --init&amp;rdquo;，然后&lt;a href=&quot;lang_delete&quot;&gt;删除&lt;/a&gt;引用非恒定表的自测行。</target>
        </trans-unit>
        <trans-unit id="b23d6efbb796b87124747de656b1313433a59a58" translate="yes" xml:space="preserve">
          <source>The &quot;.selftest&quot; command attempts to verify that a database is intact and is not corrupt. The .selftest command looks for a table in schema named &quot;selftest&quot; and defined as follows:</source>
          <target state="translated">&quot;.selftest &quot;命令试图验证一个数据库是否完好无损。.selftest命令在模式中寻找一个名为 &quot;selftest &quot;的表,定义如下:</target>
        </trans-unit>
        <trans-unit id="da3394cbf6e430093bb273dc53c5c24290fb42a2" translate="yes" xml:space="preserve">
          <source>The &quot;.sha3sum&quot; command is implemented with the help of the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/shathree.c&quot;&gt;extension function &quot;sha3_query()&quot;&lt;/a&gt; that is included with the command-line shell.</source>
          <target state="translated">&amp;ldquo; .sha3sum&amp;rdquo;命令是借助命令行外壳附带的&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/shathree.c&quot;&gt;扩展功能&amp;ldquo; sha3_query（）&amp;rdquo;&lt;/a&gt;实现的。</target>
        </trans-unit>
        <trans-unit id="49607863a0b317eaa9e0bb0334b35c6b17a96a09" translate="yes" xml:space="preserve">
          <source>The &quot;.sha3sum&quot; command supports options &quot;--sha3-224&quot;, &quot;--sha3-256&quot;, &quot;--sha3-384&quot;, and &quot;--sha3-512&quot; to define which variety of SHA3 to use for the hash. The default is SHA3-256.</source>
          <target state="translated">&quot;.sha3sum &quot;命令支持&quot;--sha3-224&quot;、&quot;--sha3-256&quot;、&quot;--sha3-384 &quot;和&quot;--sha3-512 &quot;等选项来定义散列使用的SHA3的种类。默认为SHA3-256。</target>
        </trans-unit>
        <trans-unit id="e496b68fde3cba7a6d3e4d071d1b64676cd89817" translate="yes" xml:space="preserve">
          <source>The &quot;.sha3sum&quot; command takes a single optional argument which is a &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern. If this option is present, only tables whose names match the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern will be hashed.</source>
          <target state="translated">&amp;ldquo; .sha3sum&amp;rdquo;命令采用单个可选参数，该参数是&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;模式。如果存在此选项，则仅对名称与&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;模式匹配的表进行哈希处理。</target>
        </trans-unit>
        <trans-unit id="b0e55e4c460c47133735d47238f402c87368287c" translate="yes" xml:space="preserve">
          <source>The &quot;.sha3sum&quot; dot-command computes a &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-3&quot;&gt;SHA3&lt;/a&gt; hash of the &lt;em&gt;content&lt;/em&gt; of the database. To be clear, the hash is computed over the database content, not its representation on disk. This means, for example, that a &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; or similar data-preserving transformation does not change the hash.</source>
          <target state="translated">&amp;ldquo; .sha3sum&amp;rdquo;点命令可计算数据库&lt;em&gt;内容&lt;/em&gt;的&lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-3&quot;&gt;SHA3&lt;/a&gt;哈希。明确地说，哈希是根据数据库内容而不是磁盘上的表示来计算的。例如，这意味着&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;或类似的保留数据的转换不会更改哈希。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d2252b9e19709b03f7ab086b59b1a77291173bd1" translate="yes" xml:space="preserve">
          <source>The &quot;.tables&quot; command is similar to setting list mode then executing the following query:</source>
          <target state="translated">&quot;.tables &quot;命令类似于设置列表模式,然后执行以下查询。</target>
        </trans-unit>
        <trans-unit id="9eda9619ee5cbc80757e21696103e58ade470ff1" translate="yes" xml:space="preserve">
          <source>The &quot;.width&quot; command in the example above sets the width of the first column to 12 and the width of the second column to 6. All other column widths were unaltered. You can give as many arguments to &quot;.width&quot; as necessary to specify the widths of as many columns as are in your query results.</source>
          <target state="translated">上例中的&quot;.width &quot;命令将第一列的宽度设置为12,第二列的宽度设置为6。所有其他列的宽度都没有改变。你可以根据需要给&quot;.width &quot;指定查询结果中任意多列的宽度。</target>
        </trans-unit>
        <trans-unit id="8d28508cd52964017863df7d9bff1bae6f7b1b73" translate="yes" xml:space="preserve">
          <source>The &quot;1&quot; at the end of the name for the json1 extension is deliberate. The designers anticipate that there will be future incompatible JSON extensions building upon the lessons learned from json1. Once sufficient experience is gained, some kind of JSON extension might be folded into the SQLite core. For now, JSON support remains an extension.</source>
          <target state="translated">json1扩展名称末尾的 &quot;1 &quot;是故意的。设计者们预计,在吸取json1的经验教训的基础上,将来会有不兼容的JSON扩展。一旦积累了足够的经验,某种JSON扩展可能会被折叠到SQLite核心中。目前,JSON支持仍然是一种扩展。</target>
        </trans-unit>
        <trans-unit id="ec1a7b1bff513b8dc885dad8096593de50c679b9" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;a href=&quot;cli#csv&quot;&gt;.import&lt;/a&gt;&quot; command ignores an initial UTF-8 BOM.</source>
          <target state="translated">&amp;ldquo; &lt;a href=&quot;cli#csv&quot;&gt;.import&lt;/a&gt; &amp;rdquo;命令将忽略初始的UTF-8 BOM。</target>
        </trans-unit>
        <trans-unit id="39a3b12173588647fa6bbe9bfdec68cffc6ff3a2" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt;&quot; must be a &lt;a href=&quot;lang_select#compound&quot;&gt;compound select&lt;/a&gt; where the right-most &lt;a href=&quot;syntax/compound-operator&quot;&gt;compound-operator&lt;/a&gt; is either UNION or UNION ALL.</source>
          <target state="translated">&amp;ldquo; &lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt; &amp;rdquo;必须是&lt;a href=&quot;lang_select#compound&quot;&gt;复合选择&lt;/a&gt;，其中最右边的&lt;a href=&quot;syntax/compound-operator&quot;&gt;复合运算符&lt;/a&gt;为UNION或UNION ALL。</target>
        </trans-unit>
        <trans-unit id="1b29ebb01e08ccb759bf391547ff1f9bffd4a349" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt;&quot; must be a &lt;a href=&quot;lang_select#compound&quot;&gt;compound select&lt;/a&gt;. That is to say, the CTE body must be two or more individual SELECT statements separated by compound operators like UNION, UNION ALL, INTERSECT, or EXCEPT.</source>
          <target state="translated">&amp;ldquo; &lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt; &amp;rdquo;必须是&lt;a href=&quot;lang_select#compound&quot;&gt;复合select&lt;/a&gt;。也就是说，CTE主体必须是两个或多个单独的SELECT语句，这些语句由复合运算符（如UNION，UNION ALL，INTERSECT或EXCEPT）分隔。</target>
        </trans-unit>
        <trans-unit id="6e1ee86a4eb35dd217941c49a4c1f826afe5d0c7" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt;&quot; syntax diagram above attempts to show as much of the SELECT statement syntax as possible in a single diagram, because some readers find that helpful. The following &quot;&lt;a href=&quot;syntax/factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&quot; is an alternative syntax diagrams that expresses the same syntax but tries to break the syntax down into smaller chunks.</source>
          <target state="translated">上面的&amp;ldquo; &lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt; &amp;rdquo;语法图试图在单个图中显示尽可能多的SELECT语句语法，因为有些读者发现这样做很有帮助。下面的&amp;ldquo; &lt;a href=&quot;syntax/factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt; &amp;rdquo;是表示相同语法但试图将语法分解为较小块的替代语法图。</target>
        </trans-unit>
        <trans-unit id="9f631ef63bea49256ea8a2d7bafc4554c3faedfb" translate="yes" xml:space="preserve">
          <source>The &quot;Application ID&quot; set by &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt;设置的&amp;ldquo;应用程序ID&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="f7f5d1070df133cbc828d184fa205995550d45fd" translate="yes" xml:space="preserve">
          <source>The &quot;CREATE TABLE&quot; command is used to create a new table in an SQLite database. A CREATE TABLE command specifies the following attributes of the new table:</source>
          <target state="translated">&quot;CREATE TABLE &quot;命令用于在SQLite数据库中创建一个新表。CREATE TABLE命令指定新表的以下属性。</target>
        </trans-unit>
        <trans-unit id="07114418ccb01065c3be30aab50b4df2c4bf363e" translate="yes" xml:space="preserve">
          <source>The &quot;GENERATED ALWAYS&quot; keywords at the beginning of the constraint and the &quot;VIRTUAL&quot; or &quot;STORED&quot; keyword at the end are all optional. Only the &quot;AS&quot; keyword and the parenthesized expression are required. If the trailing &quot;VIRTUAL&quot; or &quot;STORED&quot; keyword is omitted, then VIRTUAL is the default. Hence, the example statement above could be simplified to just:</source>
          <target state="translated">约束开头的 &quot;GENERATED ALWAYS &quot;关键字和结尾的 &quot;VIRTUAL &quot;或 &quot;STORED &quot;关键字都是可选的。只有 &quot;AS &quot;关键字和括号内的表达式是必须的。如果省略了后面的 &quot;VIRTUAL &quot;或 &quot;STORED &quot;关键字,则默认为VIRTUAL。因此,上面的示例语句可以简化为只。</target>
        </trans-unit>
        <trans-unit id="5736b1f20cbfd4541c75d144c2bb263b3a789707" translate="yes" xml:space="preserve">
          <source>The &quot;INDEXED BY index-name&quot; phrase specifies that the named index must be used in order to look up values on the preceding table. If index-name does not exist or cannot be used for the query, then the preparation of the SQL statement fails. The &quot;NOT INDEXED&quot; clause specifies that no index shall be used when accessing the preceding table, including implied indices create by UNIQUE and PRIMARY KEY constraints. However, the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; can still be used to look up entries even when &quot;NOT INDEXED&quot; is specified.</source>
          <target state="translated">&amp;ldquo; INDEXED BY index-name&amp;rdquo;短语指定必须使用命名索引才能在上表中查找值。如果index-name不存在或不能用于查询，则SQL语句的准备失败。&amp;ldquo; NOT INDEXED&amp;rdquo;子句指定访问上表时不使用索引，包括由UNIQUE和PRIMARY KEY约束创建的隐式索引。但是，即使指定了&amp;ldquo; NOT INDEXED&amp;rdquo; ，&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;仍可用于查找条目。</target>
        </trans-unit>
        <trans-unit id="21fa27bc6e581b8fb060c98b51ebafd394898e71" translate="yes" xml:space="preserve">
          <source>The &quot;INSERT INTO</source>
          <target state="translated">的 &quot;INSERT INTO</target>
        </trans-unit>
        <trans-unit id="3c67e89c578626f4a5845690f5e802d46290edfe" translate="yes" xml:space="preserve">
          <source>The &quot;ORDER BY 2&quot; (which means the same as &quot;ORDER BY under_alice.level+1&quot;) causes higher levels in the organization chart (with smaller &quot;level&quot; values) to be processed first, resulting in a breadth-first search. The output is:</source>
          <target state="translated">ORDER BY 2&quot;(意思和 &quot;ORDER BY under_alice.level+1 &quot;一样)会使组织结构图中较高的级别(&quot;级别 &quot;值较小)先被处理,从而实现广度优先搜索。输出的结果是:</target>
        </trans-unit>
        <trans-unit id="f957a1348139bb0e4f79cd1d2fbd5306c674fbde" translate="yes" xml:space="preserve">
          <source>The &quot;ORDER BY checkin.mtime DESC&quot; term in the recursive-select makes the query run much faster by preventing it from following branches that merge checkins from long ago. The ORDER BY forces the recursive-select to focus on the most recent checkins, the ones we want. Without the ORDER BY on the recursive-select, one would be forced to compute the complete set of thousands of ancestors, sort them all by mtime, then take the top twenty. The ORDER BY essentially sets up a priority queue that forces the recursive query to look at the most recent ancestors first, allowing the use of a LIMIT clause to restrict the scope of the query to just the checkins of interest.</source>
          <target state="translated">递归选择中的 &quot;ORDER BY checkin.mtime DESC &quot;一词,可以防止它跟随合并很久以前的签入的分支,从而使查询运行得更快。ORDER BY 迫使递归选择集中在最近的checkin上,也就是我们想要的那些。如果没有递归选择的 ORDER BY,我们将被迫计算出成千上万个祖先的完整集合,按 mtime 排序,然后取前二十名。ORDER BY本质上是设置了一个优先级队列,强制递归查询先看最近的祖先,允许使用LIMIT子句将查询范围限制在感兴趣的checkins上。</target>
        </trans-unit>
        <trans-unit id="05aec33569483f3dc1a8463df38060dbf53e2c35" translate="yes" xml:space="preserve">
          <source>The &quot;PRAGMA cache_spill=</source>
          <target state="translated">PRAGMA cache_spill=&quot;。</target>
        </trans-unit>
        <trans-unit id="1a0a062742c0bea5342163f23635fff0e75751fe" translate="yes" xml:space="preserve">
          <source>The &quot;PRAGMA data_version&quot; command provides an indication that the database file has been modified. Interactive programs that hold database content in memory or that display database content on-screen can use the PRAGMA data_version command to determine if they need to flush and reload their memory or update the screen display.</source>
          <target state="translated">&quot;PRAGMA data_version &quot;命令提供了数据库文件被修改的指示。在内存中保存数据库内容或在屏幕上显示数据库内容的交互式程序可以使用 &quot;PRAGMA data_version &quot;命令来确定是否需要刷新和重新加载内存或更新屏幕显示。</target>
        </trans-unit>
        <trans-unit id="51c212d19062433a8ddb99b497e81dcefb5db939" translate="yes" xml:space="preserve">
          <source>The &quot;PRAGMA data_version&quot; value is a local property of each database connection and so values returned by two concurrent invocations of &quot;PRAGMA data_version&quot; on separate database connections are often different even though the underlying database is identical. It is only meaningful to compare the &quot;PRAGMA data_version&quot; values returned by the same database connection at two different points in time.</source>
          <target state="translated">&quot;PRAGMA data_version &quot;值是每个数据库连接的本地属性,因此在不同的数据库连接上同时调用 &quot;PRAGMA data_version &quot;返回的值通常是不同的,即使底层数据库是相同的。比较同一数据库连接在两个不同时间点上返回的 &quot;PRAGMA data_version &quot;值才有意义。</target>
        </trans-unit>
        <trans-unit id="03965d42503dca17ab62ff9cad1d8a5c3c8ffdbb" translate="yes" xml:space="preserve">
          <source>The &quot;Page Count&quot; - The number of pages in the next segment of the journal, or -1 to mean all content to the end of the file</source>
          <target state="translated">&quot;页数&quot;--下一段日记的页数,或-1表示所有内容到文件结束。</target>
        </trans-unit>
        <trans-unit id="48c6586de090c3bc2e13cc3b6a2a69ed36fa59fa" translate="yes" xml:space="preserve">
          <source>The &quot;USING TEMP B-TREE&quot; clause in the above output indicates that a temporary b-tree structure is used to implement the UNION of the results of the two sub-selects. An alternative method of computing a compound is to run each subquery as a co-routine, arrange for their outputs to appear in sorted order, and merge the results together. When the query planner chooses this latter approach, the EXPLAIN QUERY PLAN output looks like this:</source>
          <target state="translated">上述输出中的 &quot;USING TEMP B-TREE &quot;子句表示使用临时b-树结构来实现两个子选择结果的UNION。另一种计算复合的方法是将每个子查询作为一个联合程序运行,安排它们的输出按排序顺序出现,并将结果合并在一起。当查询规划器选择后一种方法时,EXPLAIN QUERY PLAN的输出结果是这样的。</target>
        </trans-unit>
        <trans-unit id="a9bff9645401cb328b5613b5233bf3e5ba1e2eb1" translate="yes" xml:space="preserve">
          <source>The &quot;alternate-form-2&quot; flag (&quot;!&quot;) on the &lt;a href=&quot;printf&quot;&gt;built-in printf&lt;/a&gt; implementation now causes string substitutions to measure the width and precision in characters instead of bytes.</source>
          <target state="translated">&lt;a href=&quot;printf&quot;&gt;内置printf&lt;/a&gt;实现中的&amp;ldquo; alternate-form-2&amp;rdquo;标志（&amp;ldquo;！&amp;rdquo;）现在导致字符串替换以字符而不是字节来度量宽度和精度。</target>
        </trans-unit>
        <trans-unit id="e4319cae606348ce23e782f966b47ff645421643" translate="yes" xml:space="preserve">
          <source>The &quot;atom&quot; column is the SQL value corresponding to primitive elements - elements other than JSON arrays and objects. The &quot;atom&quot; column is NULL for a JSON array or object. The &quot;value&quot; column is the same as the &quot;atom&quot; column for primitive JSON elements but takes on the text JSON value for arrays and objects.</source>
          <target state="translated">&quot;atom &quot;列是对应于基元的SQL值--JSON数组和对象以外的元素。对于JSON数组或对象来说,&quot;atom &quot;列是NULL。&quot;value &quot;列与原始JSON元素的 &quot;atom &quot;列相同,但对于数组和对象来说,则采用文本JSON值。</target>
        </trans-unit>
        <trans-unit id="cb8a5773e6c48280d7fe42741f8b4a093d392533" translate="yes" xml:space="preserve">
          <source>The &quot;authorizer&quot; method</source>
          <target state="translated">&quot;authorizer &quot;方法</target>
        </trans-unit>
        <trans-unit id="d2039edadf3792f44d9f55f1e52e41e045647126" translate="yes" xml:space="preserve">
          <source>The &quot;authorizer&quot; method provides access to the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer&lt;/a&gt; C/C++ interface. The argument to authorizer is the name of a procedure that is called when SQL statements are being compiled in order to authorize certain operations. The callback procedure takes 5 arguments which describe the operation being coded. If the callback returns the text string &quot;SQLITE_OK&quot;, then the operation is allowed. If it returns &quot;SQLITE_IGNORE&quot;, then the operation is silently disabled. If the return is &quot;SQLITE_DENY&quot; then the compilation fails with an error.</source>
          <target state="translated">&amp;ldquo;授权者&amp;rdquo;方法提供对&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer&lt;/a&gt; C / C ++接口的访问。 authorizer的参数是在编译SQL语句以授权某些操作时调用的过程的名称。回调过程采用5个参数，描述正在编码的操作。如果回调返回文本字符串&amp;ldquo; SQLITE_OK&amp;rdquo;，则允许该操作。如果返回&amp;ldquo; SQLITE_IGNORE&amp;rdquo;，则该操作将被静默禁用。如果返回为&amp;ldquo; SQLITE_DENY&amp;rdquo;，则编译将失败并显示错误。</target>
        </trans-unit>
        <trans-unit id="d780e49acdf2e828a0e7b0580dfd96aff50cee2e" translate="yes" xml:space="preserve">
          <source>The &quot;automerge=N&quot; command (where N is an integer between 0 and 15, inclusive) is used to configure an FTS3/4 tables &quot;automerge&quot; parameter, which controls automatic incremental inverted index merging. The default automerge value for new tables is 0, meaning that automatic incremental merging is completely disabled. If the value of the automerge parameter is modified using the &quot;automerge=N&quot; command, the new parameter value is stored persistently in the database and is used by all subsequently established database connections.</source>
          <target state="translated">&quot;automerge=N &quot;命令(其中N是0到15之间的整数,包含在内)用于配置FTS3/4表的 &quot;automerge &quot;参数,该参数控制自动增量反向索引合并。新表的默认automerge值为0,即完全禁用自动增量合并。如果使用 &quot;automerge=N &quot;命令修改了automerge参数的值,新的参数值就会持久地存储在数据库中,并被随后建立的所有数据库连接使用。</target>
        </trans-unit>
        <trans-unit id="35cc018cff76ce7093039d6d69782515b8dd9cbd" translate="yes" xml:space="preserve">
          <source>The &quot;backup&quot; method</source>
          <target state="translated">&quot;备份 &quot;方法</target>
        </trans-unit>
        <trans-unit id="c005edd2de62803b18a4eb1743378927a517fad5" translate="yes" xml:space="preserve">
          <source>The &quot;backup&quot; method makes a backup copy of a live database. The command syntax is like this:</source>
          <target state="translated">&quot;backup &quot;方法对实时数据库进行备份。命令的语法是这样的。</target>
        </trans-unit>
        <trans-unit id="7652bc7646799c25c956b30319f71b75ca9a3e80" translate="yes" xml:space="preserve">
          <source>The &quot;bind_fallback&quot; method</source>
          <target state="translated">bind_fallback &quot;方法</target>
        </trans-unit>
        <trans-unit id="e31d9979cf6770ea07cdb2b87a23b0343179e30e" translate="yes" xml:space="preserve">
          <source>The &quot;bind_fallback&quot; method gives the application control over how to handle parameter binding when no TCL variable matches the parameter name.</source>
          <target state="translated">&quot;bind_fallback &quot;方法让应用程序可以控制如何在没有TCL变量与参数名匹配时处理参数绑定。</target>
        </trans-unit>
        <trans-unit id="d6fd78a195f0dd5acebc1e5d408aa889656042c4" translate="yes" xml:space="preserve">
          <source>The &quot;bind_fallback&quot; method has a single optional argument. If the argument is an empty string, then the bind_fallback is cancelled and the default behavior is restored. If the argument is a non-empty string, then the argument is a TCL command (usually the name of a proc) to invoke whenever an SQL parameter is seen that does not match any TCL variable. If the &quot;bind_fallback&quot; method is given no arguments, then the current bind_fallback command is returned.</source>
          <target state="translated">bind_fallback &quot;方法有一个可选的参数。如果参数是一个空字符串,那么bind_fallback就会被取消,恢复默认行为。如果参数是非空字符串,那么参数是一个TCL命令(通常是一个proc的名字),每当看到一个不匹配任何TCL变量的SQL参数时就会调用。如果 &quot;bind_fallback &quot;方法没有给定参数,那么将返回当前的bind_fallback命令。</target>
        </trans-unit>
        <trans-unit id="50a08084b4de7b3f67549ffe53d83ec728fa3cca" translate="yes" xml:space="preserve">
          <source>The &quot;busy&quot; method</source>
          <target state="translated">忙 &quot;法</target>
        </trans-unit>
        <trans-unit id="94cabb870539d2659c509ca5d30b8de78ce6a143" translate="yes" xml:space="preserve">
          <source>The &quot;busy&quot; method, like &quot;timeout&quot;, only comes into play when the database is locked. But the &quot;busy&quot; method gives the programmer much more control over what action to take. The &quot;busy&quot; method specifies a callback Tcl procedure that is invoked whenever SQLite tries to open a locked database. A single integer argument is appended to the callback before it is invoke. The argument is the number of prior calls to the busy callback for the current locking event. It is intended that the callback will do some other useful work for a short while (such as service GUI events) then return so that the lock can be tried again. The callback procedure should return &quot;0&quot; if it wants SQLite to try again to open the database and should return &quot;1&quot; if it wants SQLite to abandon the current operation.</source>
          <target state="translated">&quot;忙 &quot;方法和 &quot;超时 &quot;一样,只有在数据库被锁定时才会发挥作用。但 &quot;忙 &quot;方法让程序员对采取什么行动有更多的控制权。&quot;busy &quot;方法指定了一个回调的Tcl存储过程,每当SQLite试图打开一个锁定的数据库时,该存储过程就会被调用。在调用之前,一个单一的整数参数被附加到回调过程中。这个参数是当前锁定事件对busy回调的先前调用次数。它的目的是,回调将在短时间内做一些其他有用的工作(例如服务GUI事件),然后返回,以便可以再次尝试锁定。如果希望SQLite再次尝试打开数据库,回调过程应该返回 &quot;0&quot;,如果希望SQLite放弃当前操作,应该返回 &quot;1&quot;。</target>
        </trans-unit>
        <trans-unit id="806dbf019d18a933c45ea06755b6a277743f61ae" translate="yes" xml:space="preserve">
          <source>The &quot;cache&quot; method</source>
          <target state="translated">缓存 &quot;方法</target>
        </trans-unit>
        <trans-unit id="6c5d5ba4e30c1f02fb732b5f9e013dee90e5777d" translate="yes" xml:space="preserve">
          <source>The &quot;changes&quot; method</source>
          <target state="translated">&quot;变化 &quot;方法</target>
        </trans-unit>
        <trans-unit id="94441f79eee4930e4324a3b4a4acbce248260c58" translate="yes" xml:space="preserve">
          <source>The &quot;changes&quot; method returns an integer which is the number of rows in the database that were inserted, deleted, and/or modified by the most recent &quot;eval&quot; method.</source>
          <target state="translated">&quot;changes &quot;方法返回一个整数,它是数据库中被最近的 &quot;eval &quot;方法插入、删除和/或修改的行数。</target>
        </trans-unit>
        <trans-unit id="b6c35aac78db7a1383140bebe49b233115675bec" translate="yes" xml:space="preserve">
          <source>The &quot;checksum_verification&quot; pragma will always respond with &quot;0&quot; if the database file does not have a &lt;a href=&quot;fileformat2#resbyte&quot;&gt;reserve bytes&lt;/a&gt; value of 8. The pragma will return no rows at all if the cksumvfs extension is not loaded.</source>
          <target state="translated">如果数据库文件的&lt;a href=&quot;fileformat2#resbyte&quot;&gt;保留字节&lt;/a&gt;值不为8，则&amp;ldquo; checksum_verification&amp;rdquo;编译指示将始终以&amp;ldquo; 0&amp;rdquo;响应。如果未加载cksumvfs扩展名，则编译指示将根本不返回任何行。</target>
        </trans-unit>
        <trans-unit id="1066b4da2db6b6f62f1cb1a75e51624adbe905f6" translate="yes" xml:space="preserve">
          <source>The &quot;checksum_verification&quot; pragma will return &quot;1&quot; (true) or &quot;0&quot; (false) if checksum verification is enabled or disabled, respectively. &quot;Verification&quot; in this context means the feature that causes SQLITE_IOERR_DATA errors if a checksum mismatch is detected while reading. Checksums are always kept up-to-date as long as the &lt;a href=&quot;fileformat2#resbyte&quot;&gt;reserve bytes&lt;/a&gt; value of the database is 8, regardless of the setting of this pragma. Checksum verification can be disabled (for example) to do forensic analysis of a database that has previously reported a checksum error.</source>
          <target state="translated">如果分别启用或禁用校验和验证，则&amp;ldquo; checksum_verification&amp;rdquo;编译指示将返回&amp;ldquo; 1&amp;rdquo;（真）或&amp;ldquo; 0&amp;rdquo;（假）。在这种情况下，&amp;ldquo;验证&amp;rdquo;表示如果在读取时检测到校验和不匹配，则会导致SQLITE_IOERR_DATA错误的功能。只要数据库的&lt;a href=&quot;fileformat2#resbyte&quot;&gt;保留字节&lt;/a&gt;值为8，校验和就始终保持最新状态，而与该编译指示的设置无关。可以禁用校验和验证（例如）以对以前报告校验和错误的数据库进行取证分析。</target>
        </trans-unit>
        <trans-unit id="a3fc353d826f676e72487db0fd8f37052f9b16c1" translate="yes" xml:space="preserve">
          <source>The &quot;close&quot; method</source>
          <target state="translated">&quot;关闭 &quot;方法</target>
        </trans-unit>
        <trans-unit id="b78db738260018e26bc56c431d7e164adb66bba3" translate="yes" xml:space="preserve">
          <source>The &quot;collate&quot; method</source>
          <target state="translated">&quot;整理 &quot;方法</target>
        </trans-unit>
        <trans-unit id="3be1a86e589629a9a881a6da512b2ad6b5f62c78" translate="yes" xml:space="preserve">
          <source>The &quot;collation_needed&quot; method</source>
          <target state="translated">&quot;ollation_needed &quot;方法</target>
        </trans-unit>
        <trans-unit id="b61e2a7799abe39106586491c34d057a3c163117" translate="yes" xml:space="preserve">
          <source>The &quot;column&quot; mode is a tabular output format. Other tabular output formats are &quot;box&quot;, &quot;markdown&quot;, and &quot;table&quot;:</source>
          <target state="translated">&quot;列 &quot;模式是一种表格输出格式。其他的表格输出格式有 &quot;框&quot;、&quot;标记 &quot;和 &quot;表&quot;。</target>
        </trans-unit>
        <trans-unit id="6c32eeacd0b85ddcdef7035930e1a8c64bfad10b" translate="yes" xml:space="preserve">
          <source>The &quot;column&quot; mode is a tabular output format. Other tabular output formats as &quot;box&quot;, &quot;markdown&quot;, and &quot;table&quot;:</source>
          <target state="translated">&quot;列 &quot;模式是一种表格输出格式。其他的表格输出格式为 &quot;方框&quot;、&quot;标记 &quot;和 &quot;表格&quot;。</target>
        </trans-unit>
        <trans-unit id="1035634e0e0ea333e6f8d753c7fa7091a7d755db" translate="yes" xml:space="preserve">
          <source>The &quot;column&quot; output mode automatically expands columns to contain the longest output row and automatically turns &quot;.header&quot; on if it has not been previously set.</source>
          <target state="translated">&quot;列 &quot;输出模式会自动展开列以包含最长的输出行,如果之前没有设置,则自动开启&quot;.头&quot;。</target>
        </trans-unit>
        <trans-unit id="30f6089837a9332235ef1f677d9e2936edf51cae" translate="yes" xml:space="preserve">
          <source>The &quot;columns&quot; of a &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; or FROM-clause subquery are really the expressions in the result set of the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement that implements the VIEW or subquery. Thus, the affinity for columns of a VIEW or subquery are determined by the expression affinity rules above. Consider an example:</source>
          <target state="translated">&lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt;或FROM子句的&amp;ldquo;列&amp;rdquo; 实际上是实现VIEW或子查询的&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句的结果集中的表达式。因此，对于VIEW或子查询的列的亲和力由上面的表达式亲和力规则确定。考虑一个例子：</target>
        </trans-unit>
        <trans-unit id="6efc033d7171b4cae5dcc026d731d1abc23f16f8" translate="yes" xml:space="preserve">
          <source>The &quot;commit_hook&quot; method</source>
          <target state="translated">&quot;commit_hook &quot;方法</target>
        </trans-unit>
        <trans-unit id="075f9fcec0c51906d7830312bd2ffff7ac323743" translate="yes" xml:space="preserve">
          <source>The &quot;complete&quot; method</source>
          <target state="translated">&quot;完整 &quot;方法</target>
        </trans-unit>
        <trans-unit id="36202288005d888ee9c02c9332ba422aac36a5b3" translate="yes" xml:space="preserve">
          <source>The &quot;complete&quot; method is useful when building interactive applications in order to know when the user has finished entering a line of SQL code. This is really just an interface to the &lt;a href=&quot;c3ref/complete&quot;&gt;&lt;b&gt;sqlite3_complete()&lt;/b&gt;&lt;/a&gt; C function.</source>
          <target state="translated">在构建交互式应用程序时，&amp;ldquo;完成&amp;rdquo;方法很有用，以便知道用户何时输入了一行SQL代码。这实际上只是&lt;a href=&quot;c3ref/complete&quot;&gt;&lt;b&gt;sqlite3_complete（）&lt;/b&gt;&lt;/a&gt; C函数的接口。</target>
        </trans-unit>
        <trans-unit id="cb6d6b519cc240799d0eae2497f1b956b7749126" translate="yes" xml:space="preserve">
          <source>The &quot;complete&quot; method takes a string of supposed SQL as its only argument. It returns TRUE if the string is a complete statement of SQL and FALSE if there is more to be entered.</source>
          <target state="translated">&quot;complete &quot;方法将一个假定的SQL字符串作为唯一的参数。如果该字符串是一个完整的SQL语句,则返回TRUE,如果还有更多的SQL语句要输入,则返回FALSE。</target>
        </trans-unit>
        <trans-unit id="46bbc7a4eaf4d4f9fe40b357ef388a365c9285df" translate="yes" xml:space="preserve">
          <source>The &quot;config&quot; method</source>
          <target state="translated">配置 &quot;方法</target>
        </trans-unit>
        <trans-unit id="d8bb4ff8aef62d6cb6272264cef7cda239984bc9" translate="yes" xml:space="preserve">
          <source>The &quot;config&quot; method queries or changes certain configuration settings for the database connection using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface. Run this method with no arguments to get a TCL list of available configuration settings and their current values:</source>
          <target state="translated">&amp;ldquo; config&amp;rdquo;方法使用&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;接口查询或更改数据库连接的某些配置设置。不带任何参数运行此方法以获取可用配置设置及其当前值的TCL列表：</target>
        </trans-unit>
        <trans-unit id="b266e6a044670a6e3a5e4102b0820031cb7ab393" translate="yes" xml:space="preserve">
          <source>The &quot;configure&quot; scripts should now automatically configure Unix systems for large file support. Improved error messages for when large files are encountered and large file support is disabled.</source>
          <target state="translated">configure &quot;脚本现在应该自动配置Unix系统的大文件支持。改进了遇到大文件和禁用大文件支持时的错误信息。</target>
        </trans-unit>
        <trans-unit id="577865d2c9835070772d4e94f47615cadfb2baec" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the T parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="translated">由T参数指向的&amp;ldquo; const char *&amp;rdquo;变量将被设置为一个零终止的UTF-8字符串，其中包含第X个循环的&lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;描述。</target>
        </trans-unit>
        <trans-unit id="2be51d012e0d49a380524a8121847e82af3226bf" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the T parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="translated">由T参数指向的&amp;ldquo; const char *&amp;rdquo;变量将被设置为一个零终止的UTF-8字符串，其中包含第X个循环的&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;描述。</target>
        </trans-unit>
        <trans-unit id="bac7414b87b280f152adca2a25c602ba20600788" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the T parameter will be set to a zero-terminated UTF-8 string containing the name of the index or table used for the X-th loop.</source>
          <target state="translated">T参数指向的 &quot;const char *&quot;变量将被设置为一个以零结尾的UTF-8字符串,其中包含用于X-th循环的索引或表的名称。</target>
        </trans-unit>
        <trans-unit id="220e93adf7fc69205c340c5757886c63862916b5" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the V parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="translated">V参数指向的&amp;ldquo; const char *&amp;rdquo;变量将被设置为一个零终止的UTF-8字符串，其中包含第X个循环的&lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;描述。</target>
        </trans-unit>
        <trans-unit id="fcb2cfe6186a4a9c1039f7ec3e694a12e936a2d7" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the V parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="translated">V参数指向的&amp;ldquo; const char *&amp;rdquo;变量将被设置为一个零终止的UTF-8字符串，其中包含第X个循环的&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;描述。</target>
        </trans-unit>
        <trans-unit id="6993ddaa2434f289adeb086aed7ae04476a60ad7" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the V parameter will be set to a zero-terminated UTF-8 string containing the name of the index or table used for the X-th loop.</source>
          <target state="translated">V参数指向的 &quot;const char *&quot;变量将被设置为一个以零结尾的UTF-8字符串,其中包含用于X-th循环的索引或表的名称。</target>
        </trans-unit>
        <trans-unit id="8aae3497dac443e109983b1c00a5960530139406" translate="yes" xml:space="preserve">
          <source>The &quot;content&quot; option, used to make the FTS5 table an &lt;a href=&quot;fts5#external_content_and_contentless_tables&quot;&gt;external content or contentless table&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo;内容&amp;rdquo;选项，用于使FTS5表成为&lt;a href=&quot;fts5#external_content_and_contentless_tables&quot;&gt;外部内容表或无内容表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6c79f409b23d48e87e77e61ee87998224597bc3" translate="yes" xml:space="preserve">
          <source>The &quot;content_rowid&quot; option, used to set the rowid field of an &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content table&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo; content_rowid&amp;rdquo;选项，用于设置&lt;a href=&quot;fts5#external_content_tables&quot;&gt;外部内容表&lt;/a&gt;的rowid字段。</target>
        </trans-unit>
        <trans-unit id="39cd9c81e20b57d6b78e1af2643005b4d6ac3fb3" translate="yes" xml:space="preserve">
          <source>The &quot;copy&quot; method</source>
          <target state="translated">&quot;复制 &quot;方法</target>
        </trans-unit>
        <trans-unit id="983ea0fee26b9222536bfed9a0514ad997e9a0a2" translate="yes" xml:space="preserve">
          <source>The &quot;copy&quot; method copies data from a file into a table. It returns the number of rows processed successfully from the file. The syntax of the copy method looks like this:</source>
          <target state="translated">复制 &quot;方法将数据从文件复制到表中。它返回从文件中成功处理的行数。复制方法的语法是这样的。</target>
        </trans-unit>
        <trans-unit id="dc3e7bd12c41305b3fc796bf145f478af20ae557" translate="yes" xml:space="preserve">
          <source>The &quot;cost&quot; here is logarithmic. With nested loops, the work is multiplied, not added. But it is customary to think of graphs with additive weights and so the graph shows the logarithm of the various costs. The graph shows a cost advantage of S being inside of L of about 6.87, but this translates into the query running about 963 times faster when S loop is inside of the L loop rather than being outside of it.</source>
          <target state="translated">这里的 &quot;成本 &quot;是对数的。对于嵌套循环,工作是乘法,而不是加法。但习惯上认为图形的权重是加法的,所以图中显示的是各种成本的对数。图中显示S在L内的成本优势约为6.87,但这相当于当S循环在L循环内而不是在L循环外时,查询运行速度约为963倍。</target>
        </trans-unit>
        <trans-unit id="350bdd92630f61bca90b3168c90039a63f7ced5e" translate="yes" xml:space="preserve">
          <source>The &quot;csv&quot; mode option in the shell puts strings inside double-quotes.</source>
          <target state="translated">shell中的 &quot;csv &quot;模式选项将字符串放在双引号内。</target>
        </trans-unit>
        <trans-unit id="1f521a5c994d919d955260e93be15342970bdf26" translate="yes" xml:space="preserve">
          <source>The &quot;db&quot; parameter is a pointer to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. The &quot;main&quot; argument is the name of the schema in which the imposter table is to be created. The &quot;1&quot; argument enables the imposter table mechanism. &quot;tnum&quot; is the root page of the index that the imposter table should mirror.</source>
          <target state="translated">&amp;ldquo; db&amp;rdquo;参数是指向&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;的指针。&amp;ldquo; main&amp;rdquo;参数是要在其中创建冒名顶替者表的架构的名称。参数&amp;ldquo; 1&amp;rdquo;启用冒名顶替者表机制。&amp;ldquo; tnum&amp;rdquo;是冒名顶替者表应镜像的索引的根页。</target>
        </trans-unit>
        <trans-unit id="1d7867d45fc6532563a6e0e1052f994086d7d4d3" translate="yes" xml:space="preserve">
          <source>The &quot;deserialize&quot; method</source>
          <target state="translated">反序列化 &quot;方法</target>
        </trans-unit>
        <trans-unit id="6f372f07e9e348fc01623f3016d82e06dd84212c" translate="yes" xml:space="preserve">
          <source>The &quot;deserialize&quot; method takes a TCL byte-array that contains an SQLite database file and adds it to the database connection. The syntax is:</source>
          <target state="translated">&quot;反序列化 &quot;方法获取一个包含SQLite数据库文件的TCL字节数组,并将其添加到数据库连接中。其语法是:</target>
        </trans-unit>
        <trans-unit id="37b478850c0ef98b47e5a07304d319496a735ccd" translate="yes" xml:space="preserve">
          <source>The &quot;docid&quot; alias does not exist. Applications must use &quot;rowid&quot; instead.</source>
          <target state="translated">docid &quot;别名不存在。应用程序必须使用 &quot;rowid &quot;代替。</target>
        </trans-unit>
        <trans-unit id="13cca21a87502057869d942479f833e57c886177" translate="yes" xml:space="preserve">
          <source>The &quot;double&quot; variable pointed to by the T parameter will be set to the query planner's estimate for the average number of rows output from each iteration of the X-th loop. If the query planner's estimates was accurate, then this value will approximate the quotient NVISIT/NLOOP and the product of this value for all prior loops with the same SELECTID will be the NLOOP value for the current loop.</source>
          <target state="translated">T参数指向的 &quot;double &quot;变量将被设置为查询规划器对X-th循环每次迭代输出的平均行数的估计值。如果查询规划者的估计是准确的,那么这个值将近似于商数NVISIT/NLOOP,而所有具有相同SELECTID的先前循环的这个值的乘积将是当前循环的NLOOP值。</target>
        </trans-unit>
        <trans-unit id="ac86dc9fb240d8b577961e6fb339b312a7e8b6d2" translate="yes" xml:space="preserve">
          <source>The &quot;double&quot; variable pointed to by the V parameter will be set to the query planner's estimate for the average number of rows output from each iteration of the X-th loop. If the query planner's estimates was accurate, then this value will approximate the quotient NVISIT/NLOOP and the product of this value for all prior loops with the same SELECTID will be the NLOOP value for the current loop.</source>
          <target state="translated">V参数指向的 &quot;double &quot;变量将被设置为查询规划器对X-th循环每次迭代输出的平均行数的估计值。如果查询规划者的估计是准确的,那么这个值将近似于商数NVISIT/NLOOP,而所有具有相同SELECTID的先前循环的这个值的乘积将是当前循环的NLOOP值。</target>
        </trans-unit>
        <trans-unit id="91b47ab7441632c19a646d6f3d2e70bb71a8af6b" translate="yes" xml:space="preserve">
          <source>The &quot;ellipses&quot; text.</source>
          <target state="translated">省略号 &quot;的文字。</target>
        </trans-unit>
        <trans-unit id="785dfb0eb14780fdc8609d7c7187bbcbf0dfe81b" translate="yes" xml:space="preserve">
          <source>The &quot;enable_load_extension&quot; method</source>
          <target state="translated">enable_load_extension &quot;方法。</target>
        </trans-unit>
        <trans-unit id="24181470839fe75a380a1959898a8b67107aab1a" translate="yes" xml:space="preserve">
          <source>The &quot;end match&quot; text.</source>
          <target state="translated">&quot;结束比赛 &quot;的文字。</target>
        </trans-unit>
        <trans-unit id="a4952b422a3c809d77afa1776609a2750c092857" translate="yes" xml:space="preserve">
          <source>The &quot;errorcode&quot; method</source>
          <target state="translated">错误代码 &quot;方法</target>
        </trans-unit>
        <trans-unit id="79f7c0ddb2f3a3e97f9983c467d9c601808c789a" translate="yes" xml:space="preserve">
          <source>The &quot;eval&quot; method</source>
          <target state="translated">评价 &quot;方法</target>
        </trans-unit>
        <trans-unit id="da370283ad69c2823d6201a69b7d1765374cb685" translate="yes" xml:space="preserve">
          <source>The &quot;eval&quot; method described &lt;a href=&quot;#eval&quot;&gt;above&lt;/a&gt; keeps a cache of &lt;a href=&quot;c3ref/prepare&quot;&gt;prepared statements&lt;/a&gt; for recently evaluated SQL commands. The &quot;cache&quot; method is used to control this cache. The first form of this command is:</source>
          <target state="translated">&lt;a href=&quot;#eval&quot;&gt;上面&lt;/a&gt;描述的&amp;ldquo; eval&amp;rdquo;方法为最近评估的SQL命令保留了&lt;a href=&quot;c3ref/prepare&quot;&gt;准备好的语句&lt;/a&gt;的缓存。&amp;ldquo;缓存&amp;rdquo;方法用于控制此缓存。该命令的第一种形式是：</target>
        </trans-unit>
        <trans-unit id="221bab33d21ea69f4dd52f3f0492767cb572de7f" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; method</source>
          <target state="translated">&quot;存在 &quot;方法</target>
        </trans-unit>
        <trans-unit id="efdfc3e12d096d22035e667cf9f9a8fa50dec02d" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; method is often used to test for the existence of rows in a table. For example:</source>
          <target state="translated">&quot;exist &quot;方法通常用于测试表中是否存在行。例如:</target>
        </trans-unit>
        <trans-unit id="64883f01f5bafd4c69a4447377f37fc6c44868cb" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; method is similar to &quot;onecolumn&quot; and &quot;eval&quot; in that it executes SQL statements. The difference is that the &quot;exists&quot; method always returns a boolean value which is TRUE if a query in the SQL statement it executes returns one or more rows and FALSE if the SQL returns an empty set.</source>
          <target state="translated">&quot;exists &quot;方法与 &quot;onecolumn &quot;和 &quot;eval &quot;方法类似,它执行的是SQL语句。不同的是,&quot;exes &quot;方法总是返回一个布尔值,如果它执行的SQL语句中的查询返回一条或多条记录,那么这个布尔值就是 &quot;true&quot;,如果SQL返回的是一个空集,那么这个布尔值就是 &quot;false&quot;。</target>
        </trans-unit>
        <trans-unit id="2fa39980ca4c6c390fc0963b907ef032a2115a04" translate="yes" xml:space="preserve">
          <source>The &quot;family&quot; table is similar to the earlier &quot;org&quot; table except that now there are two parents to each member. We want to know all living ancestors of Alice, from oldest to youngest. An ordinary common table expression, &quot;parent_of&quot;, is defined first. That ordinary CTE is a view that can be used to find all parents of any individual. That ordinary CTE is then used in the &quot;ancestor_of_alice&quot; recursive CTE. The recursive CTE is then used in the final query:</source>
          <target state="translated">&quot;家庭 &quot;表与早先的 &quot;org &quot;表相似,只是现在每个成员有两个父母。我们想知道Alice的所有活着的祖先,从最大的到最小的。首先定义一个普通的普通表表达式 &quot;parent_of&quot;。该普通CTE是一个视图,可以用来查找任何个体的所有父母。然后,该普通CTE被用于 &quot;祖先_of_alice &quot;递归CTE中。然后在最后的查询中使用递归CTE。</target>
        </trans-unit>
        <trans-unit id="e0decf38085a4ffc55fce2f25b175fd346628c61" translate="yes" xml:space="preserve">
          <source>The &quot;fast&quot; setting for secure_delete (added circa 2017-08-01) is an intermediate setting in between &quot;on&quot; and &quot;off&quot;. When secure_delete is set to &quot;fast&quot;, SQLite will overwrite deleted content with zeros only if doing so does not increase the amount of I/O. In other words, the &quot;fast&quot; setting uses more CPU cycles but does not use more I/O. This has the effect of purging all old content from &lt;a href=&quot;fileformat2#btree&quot;&gt;b-tree pages&lt;/a&gt;, but leaving forensic traces on &lt;a href=&quot;fileformat2#freelist&quot;&gt;freelist pages&lt;/a&gt;.</source>
          <target state="translated">secure_delete的&amp;ldquo;快速&amp;rdquo;设置（大约于2017-08-01添加）是介于&amp;ldquo;开&amp;rdquo;和&amp;ldquo;关&amp;rdquo;之间的中间设置。当secure_delete设置为&amp;ldquo; fast&amp;rdquo;时，SQLite仅在不增加I / O数量的情况下，才会用零覆盖已删除的内容。换句话说，&amp;ldquo;快速&amp;rdquo;设置使用更多的CPU周期，但不使用更多的I / O。这具有清除&lt;a href=&quot;fileformat2#btree&quot;&gt;b树页面中&lt;/a&gt;所有旧内容的作用，但将取证痕迹留在&lt;a href=&quot;fileformat2#freelist&quot;&gt;自由列表页面上&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5e5534bc0599c1bf3dbead2d2f44bed70807ce6" translate="yes" xml:space="preserve">
          <source>The &quot;fsync()&quot; that occurs after the header is written in a WAL reset now uses the sync settings for checkpoints. This means it will use a &quot;fullfsync&quot; on macs if &lt;a href=&quot;pragma#pragma_checkpoint_fullfsync&quot;&gt;PRAGMA checkpoint_fullfsync&lt;/a&gt; set on.</source>
          <target state="translated">现在，在WAL重置中写入标头后出现的&amp;ldquo; fsync（）&amp;rdquo;现在将同步设置用于检查点。这意味着，如果&lt;a href=&quot;pragma#pragma_checkpoint_fullfsync&quot;&gt;PRAGMA checkpoint_fullfsync&lt;/a&gt;设置为on ，它将在Mac上使用&amp;ldquo; fullfsync&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="80417a09b17dfee14228d5c4ecb3ba63e1360a53" translate="yes" xml:space="preserve">
          <source>The &quot;fts3tokenize&quot; virtual table can be used to directly access any tokenizer. The following SQL demonstrates how to create an instance of the fts3tokenize virtual table:</source>
          <target state="translated">fts3tokenize &quot;虚拟表可用于直接访问任何 tokenizer。下面的 SQL 演示了如何创建 fts3tokenize 虚拟表的实例。</target>
        </trans-unit>
        <trans-unit id="6cdf37fe2751376d1b848056d4ec78cc31cd8173" translate="yes" xml:space="preserve">
          <source>The &quot;fullkey&quot; column is a text path that uniquely identifies the current row element within the original JSON string. The complete key to the true top-level element is returned even if an alternative starting point is provided by the &quot;root&quot; argument.</source>
          <target state="translated">fullkey &quot;列是一个文本路径,在原始JSON字符串中唯一标识当前行元素。即使 &quot;root &quot;参数提供了另一个起点,也会返回真正的顶级元素的完整键。</target>
        </trans-unit>
        <trans-unit id="81485590afed062476035ea78c2df833a07ce15c" translate="yes" xml:space="preserve">
          <source>The &quot;function&quot; method</source>
          <target state="translated">&quot;函数 &quot;方法</target>
        </trans-unit>
        <trans-unit id="982021b0dd51770755c9c9e39c1c765e77fbdd84" translate="yes" xml:space="preserve">
          <source>The &quot;function&quot; method accepts the following options:</source>
          <target state="translated">&quot;函数 &quot;方法接受以下选项:</target>
        </trans-unit>
        <trans-unit id="e581fe2aa68e5275a553b3adbf390b762a9e4053" translate="yes" xml:space="preserve">
          <source>The &quot;function&quot; method registers new SQL functions with the SQLite engine. The arguments are the name of the new SQL function and a TCL command that implements that function. Arguments to the function are appended to the TCL command before it is invoked.</source>
          <target state="translated">function &quot;方法在SQLite引擎中注册新的SQL函数。参数是新SQL函数的名称和实现该函数的TCL命令。在调用函数之前,函数的参数被附加到TCL命令中。</target>
        </trans-unit>
        <trans-unit id="ff9f7422b3d2ef0edf475eeb60798d293ddec7bd" translate="yes" xml:space="preserve">
          <source>The &quot;fuzzershell.c&quot; program is used to run some &lt;a href=&quot;#fuzztesting&quot;&gt;fuzz tests&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo; fuzzershell.c&amp;rdquo;程序用于运行一些&lt;a href=&quot;#fuzztesting&quot;&gt;模糊测试&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7c4947473658b4ae028d7e71df03314bb5d6e009" translate="yes" xml:space="preserve">
          <source>The &quot;iScanStatusOp&quot; parameter determines which status information to return. The &quot;iScanStatusOp&quot; must be one of the &lt;a href=&quot;#SQLITE_SCANSTAT_EST&quot;&gt;scanstatus options&lt;/a&gt; or the behavior of this interface is undefined. The requested measurement is written into a variable pointed to by the &quot;pOut&quot; parameter. Parameter &quot;idx&quot; identifies the specific loop to retrieve statistics for. Loops are numbered starting from zero. If idx is out of range - less than zero or greater than or equal to the total number of loops used to implement the statement - a non-zero value is returned and the variable that pOut points to is unchanged.</source>
          <target state="translated">&amp;ldquo; iScanStatusOp&amp;rdquo;参数确定要返回的状态信息。&amp;ldquo; iScanStatusOp&amp;rdquo;必须是&lt;a href=&quot;#SQLITE_SCANSTAT_EST&quot;&gt;scanstatus选项&lt;/a&gt;之一，否则此接口的行为未定义。所请求的测量值将写入&amp;ldquo; pOut&amp;rdquo;参数指向的变量中。参数&amp;ldquo; idx&amp;rdquo;标识要为其检索统计信息的特定循环。循环从零开始编号。如果idx超出范围-小于零或大于或等于用于执行该语句的循环总数-则返回非零值，并且pOut指向的变量不变。</target>
        </trans-unit>
        <trans-unit id="82b3487c37966e4df98f8fc69e59c76eae09190d" translate="yes" xml:space="preserve">
          <source>The &quot;iScanStatusOp&quot; parameter determines which status information to return. The &quot;iScanStatusOp&quot; must be one of the &lt;a href=&quot;c_scanstat_est&quot;&gt;scanstatus options&lt;/a&gt; or the behavior of this interface is undefined. The requested measurement is written into a variable pointed to by the &quot;pOut&quot; parameter. Parameter &quot;idx&quot; identifies the specific loop to retrieve statistics for. Loops are numbered starting from zero. If idx is out of range - less than zero or greater than or equal to the total number of loops used to implement the statement - a non-zero value is returned and the variable that pOut points to is unchanged.</source>
          <target state="translated">&amp;ldquo; iScanStatusOp&amp;rdquo;参数确定要返回的状态信息。&amp;ldquo; iScanStatusOp&amp;rdquo;必须是&lt;a href=&quot;c_scanstat_est&quot;&gt;scanstatus选项&lt;/a&gt;之一，否则此接口的行为未定义。所请求的测量值将写入&amp;ldquo; pOut&amp;rdquo;参数指向的变量中。参数&amp;ldquo; idx&amp;rdquo;标识要为其检索统计信息的特定循环。循环从零开始编号。如果idx超出范围-小于零或大于或等于用于执行该语句的循环总数-则返回非零值，并且pOut指向的变量不变。</target>
        </trans-unit>
        <trans-unit id="5abd56a3f33aa682cb5beed98f5ecb39cbd50edd" translate="yes" xml:space="preserve">
          <source>The &quot;id&quot; column is an integer that identifies a specific JSON element within the complete JSON string. The &quot;id&quot; integer is an internal housekeeping number, the computation of which might change in future releases. The only guarantee is that the &quot;id&quot; column will be different for every row.</source>
          <target state="translated">&quot;id &quot;列是一个整数,用于标识完整JSON字符串中的一个特定JSON元素。id &quot;整数是一个内部的内务管理数字,它的计算方法可能会在未来的版本中发生变化。唯一能保证的是,&quot;id &quot;列对每一行都是不同的。</target>
        </trans-unit>
        <trans-unit id="ca8669e4db9525865c9346904ab8bb3b3eb055a9" translate="yes" xml:space="preserve">
          <source>The &quot;incrblob&quot; method</source>
          <target state="translated">&quot;incrblob &quot;方法</target>
        </trans-unit>
        <trans-unit id="8d184fd38641411539a264597b11e40c38841938" translate="yes" xml:space="preserve">
          <source>The &quot;index&quot; or staging area</source>
          <target state="translated">&quot;指数 &quot;或中转区</target>
        </trans-unit>
        <trans-unit id="c6e7f631fc9ab8b7e2eecdc6301a632079a07cf7" translate="yes" xml:space="preserve">
          <source>The &quot;input&quot; CTE defines the input puzzle. The &quot;digits&quot; CTE defines a table that holds all digits between 1 and 9. The work of solving the puzzle is undertaken by the &quot;x&quot; CTE. An entry in x(s,ind) means that the 81-character string &quot;s&quot; is a valid sudoku puzzle (it has no conflicts) and that the first unknown character is at position &quot;ind&quot;, or ind==0 if all character positions are filled in. The goal, then, is to compute entries for &quot;x&quot; with an &quot;ind&quot; of 0.</source>
          <target state="translated">输入 &quot;CTE定义了输入谜题。数字 &quot;CTE定义了一个表格,这个表格包含了1到9之间的所有数字。解谜的工作由 &quot;x &quot;CTE承担。x(s,ind)中的一个条目意味着81个字符的字符串 &quot;s &quot;是一个有效的数独谜题(它没有冲突),并且第一个未知字符位于 &quot;ind &quot;的位置,如果所有字符的位置都被填满,则ind==0。那么,我们的目标是计算出 &quot;ind &quot;为0的 &quot;x &quot;的条目。</target>
        </trans-unit>
        <trans-unit id="b6cb46f4a227f8313e332f23912dfe269a430a8c" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the T parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="translated">T参数指向的&amp;ldquo; int&amp;rdquo;变量将被设置为第X个循环的&amp;ldquo; select-id&amp;rdquo;。select-id标识循环属于哪个查询或子查询。主查询的选择ID为零。select-id与&lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;查询的第一列中输出的值相同。</target>
        </trans-unit>
        <trans-unit id="fd32578e68672fbb14bf7b3a04807a29e7c2c005" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the T parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="translated">T参数指向的&amp;ldquo; int&amp;rdquo;变量将被设置为第X个循环的&amp;ldquo; select-id&amp;rdquo;。select-id标识循环属于哪个查询或子查询。主查询的选择ID为零。select-id与&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;查询的第一列中输出的值相同。</target>
        </trans-unit>
        <trans-unit id="b8f1457987df7641bcada911e2bfe80eb91e9f5b" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the V parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="translated">V参数指向的&amp;ldquo; int&amp;rdquo;变量将在第X个循环中设置为&amp;ldquo; select-id&amp;rdquo;。 select-id标识循环属于哪个查询或子查询。主查询的选择ID为零。 select-id与&lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;查询的第一列中输出的值相同。</target>
        </trans-unit>
        <trans-unit id="d0b31808af87fb1ca4f0d10efd9a5ba2a54012dd" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the V parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="translated">V参数指向的&amp;ldquo; int&amp;rdquo;变量将在第X个循环中设置为&amp;ldquo; select-id&amp;rdquo;。 select-id标识循环属于哪个查询或子查询。主查询的选择ID为零。 select-id与&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;查询的第一列中输出的值相同。</target>
        </trans-unit>
        <trans-unit id="c47984da42c27787f28bd87d963296a6ecc85d38" translate="yes" xml:space="preserve">
          <source>The &quot;integrity-check&quot; command causes SQLite to read and verify the accuracy of all inverted indices in an FTS3/4 table by comparing those inverted indices against the original content. The &quot;integrity-check&quot; command silently succeeds if the inverted indices are all ok, but will fail with an SQLITE_CORRUPT error if any problems are found.</source>
          <target state="translated">&quot;integrity-check &quot;命令使SQLite读取并验证FTS3/4表中所有倒置索引的准确性,方法是将这些倒置索引与原始内容进行比较。如果倒置索引都没有问题,&quot;integrity-check &quot;命令就会默默地成功,但如果发现任何问题,就会以SQLITE_CORRUPT错误失败。</target>
        </trans-unit>
        <trans-unit id="d1ee1009fc8d7ceb03381f3a07a84d688fe06706" translate="yes" xml:space="preserve">
          <source>The &quot;integrity-check&quot; command is similar in concept to &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;. In a working system, the &quot;integrity-command&quot; should always be successful. Possible causes of integrity-check failures include:</source>
          <target state="translated">&amp;ldquo; integrity-check&amp;rdquo;命令在概念上与&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;相似。在工作系统中，&amp;ldquo;完整性命令&amp;rdquo;应始终成功。完整性检查失败的可能原因包括：</target>
        </trans-unit>
        <trans-unit id="9351b7e4831f50f0cddfc49da3ef44df26240c27" translate="yes" xml:space="preserve">
          <source>The &quot;interrupt&quot; method</source>
          <target state="translated">中断 &quot;方法</target>
        </trans-unit>
        <trans-unit id="1b5c7fcb603da939ee7df1123931389580f03242" translate="yes" xml:space="preserve">
          <source>The &quot;interrupt&quot; method invokes the &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; interface, causing any pending queries to halt.</source>
          <target state="translated">&amp;ldquo; interrupt&amp;rdquo;方法调用&lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt（）&lt;/a&gt;接口，从而导致所有待处理的查询都暂停。</target>
        </trans-unit>
        <trans-unit id="33827ff37e59286ea63b18a3b491ccd55fa35d36" translate="yes" xml:space="preserve">
          <source>The &quot;isInit&quot; flag. 1 when the shm file has been initialized.</source>
          <target state="translated">isInit &quot;标志。当shm文件已被初始化时为1。</target>
        </trans-unit>
        <trans-unit id="27d80d07107f3dd674071f8dcb5d66e927b93ae8" translate="yes" xml:space="preserve">
          <source>The &quot;isolation&quot; property of a database determines when changes made to the database by one operation become visible to other concurrent operations.</source>
          <target state="translated">数据库的 &quot;隔离 &quot;属性决定了一个操作对数据库所做的更改何时会对其他并发操作可见。</target>
        </trans-unit>
        <trans-unit id="ca6207f3c60486460fc150891b4e2b2ff184348d" translate="yes" xml:space="preserve">
          <source>The &quot;key&quot; column is the integer array index for elements of a JSON array and the text label for elements of a JSON object. The key column is NULL in all other cases.</source>
          <target state="translated">&quot;key &quot;列是JSON数组元素的整数组索引和JSON对象元素的文本标签。在所有其他情况下,&quot;key &quot;列为NULL。</target>
        </trans-unit>
        <trans-unit id="f06bf7b5c9acc6e224eb6aebb494891b0b016a3d" translate="yes" xml:space="preserve">
          <source>The &quot;last_insert_rowid&quot; method</source>
          <target state="translated">&quot;last_insert_rowid &quot;方法。</target>
        </trans-unit>
        <trans-unit id="b6bbfdca82da26696ded7dc7b5667ad95fba9734" translate="yes" xml:space="preserve">
          <source>The &quot;last_insert_rowid&quot; method returns an integer which is the ROWID of the most recently inserted database row.</source>
          <target state="translated">last_insert_rowid &quot;方法返回一个整数,这个整数是最近插入的数据库行的ROWID。</target>
        </trans-unit>
        <trans-unit id="7284b909bd501ff8419335375b9cbd82855b5cf7" translate="yes" xml:space="preserve">
          <source>The &quot;localtime&quot; modifier (12) assumes the time string to its left is in Universal Coordinated Time (UTC) and adjusts the time string so that it displays localtime. If &quot;localtime&quot; follows a time that is not UTC, then the behavior is undefined. The &quot;utc&quot; modifier is the opposite of &quot;localtime&quot;. &quot;utc&quot; assumes that the string to its left is in the local timezone and adjusts that string to be in UTC. If the prior string is not in localtime, then the result of &quot;utc&quot; is undefined.</source>
          <target state="translated">&quot;localtime &quot;修饰符(12)假定其左侧的时间串是在世界协调时间(UTC),并调整时间串,使其显示当地时间。如果 &quot;localtime &quot;后面的时间不是UTC,那么行为是未定义的。utc &quot;修饰符与 &quot;localtime &quot;相反。&quot;utc &quot;假设其左边的字符串是在本地时区,并将该字符串调整为UTC。如果前面的字符串不在localtime中,那么 &quot;utc &quot;的结果是未定义的。</target>
        </trans-unit>
        <trans-unit id="530c1a71b17edaa5c5193f0fc9e4ad1fed032d5d" translate="yes" xml:space="preserve">
          <source>The &quot;localtime&quot; modifier (12) assumes the time value to its left is in Universal Coordinated Time (UTC) and adjusts that time value so that it is in localtime. If &quot;localtime&quot; follows a time that is not UTC, then the behavior is undefined. The &quot;utc&quot; modifier is the opposite of &quot;localtime&quot;. &quot;utc&quot; assumes that the time value to its left is in the local timezone and adjusts that time value to be in UTC. If the time to the left is not in localtime, then the result of &quot;utc&quot; is undefined.</source>
          <target state="translated">&quot;localtime &quot;修饰符(12)假定其左边的时间值是在世界协调时间(UTC),并调整该时间值,使其在本地时间。如果 &quot;localtime &quot;跟随的时间不是UTC,那么行为是未定义的。utc &quot;修饰符与 &quot;localtime &quot;相反。&quot;utc &quot;假设其左边的时间值在本地时区,并将该时间值调整为UTC。如果左边的时间不在本地时区,那么 &quot;utc &quot;的结果是未定义的。</target>
        </trans-unit>
        <trans-unit id="15b3080063f65f5e859c8cbf90675f21f18f1993" translate="yes" xml:space="preserve">
          <source>The &quot;lost_and_found&quot; table contains one row for each orphaned row recovered from the database. Additionally, there is one row for each recovered index entry that cannot be attributed to any SQL index. This is because, in an SQLite database, the same format is used to store SQL index entries and WITHOUT ROWID table entries.</source>
          <target state="translated">&quot;lost_and_found &quot;表包含了从数据库中恢复的每一条孤儿行的一条记录。此外,每一个恢复的索引条目都有一行,不能归属于任何SQL索引。这是因为,在SQLite数据库中,使用相同的格式来存储SQL索引项和without ROWID表项。</target>
        </trans-unit>
        <trans-unit id="9b9bb88fb1467415e1fd0ce3e886e98f2fabd9f8" translate="yes" xml:space="preserve">
          <source>The &quot;main&quot; argument to dbstat is default schema for which information is to be provided. The default is &quot;main&quot;, and so the use of &quot;main&quot; in the example above is redundant. For any particular query, the schema can be changed by specifying the alternative schema as a function argument to the virtual table name in the FROM clause of the query. (See further discussion of &lt;a href=&quot;lang_select#tabfunc1&quot;&gt;table-valued functions in the FROM clause&lt;/a&gt; for more details.)</source>
          <target state="translated">dbstat的&amp;ldquo; main&amp;rdquo;参数是要为其提供信息的默认模式。默认值为&amp;ldquo; main&amp;rdquo;，因此在上面的示例中使用&amp;ldquo; main&amp;rdquo;是多余的。对于任何特定的查询，可以通过在查询的FROM子句中将备用模式指定为虚拟表名称的函数参数来更改模式。（有关更多详细信息，请参见&lt;a href=&quot;lang_select#tabfunc1&quot;&gt;FROM子句中&lt;/a&gt;对表值函数的进一步讨论。）</target>
        </trans-unit>
        <trans-unit id="09862758c2c346b79031222c95f1cc2f0ca91ec9" translate="yes" xml:space="preserve">
          <source>The &quot;make&quot; utility, or optionally &quot;nmake&quot; on Windows.</source>
          <target state="translated">&quot;make &quot;工具,或Windows上的 &quot;nmake &quot;选项。</target>
        </trans-unit>
        <trans-unit id="658c3f95d62bc63b68f3b7aa685ee8fbc83d8cde" translate="yes" xml:space="preserve">
          <source>The &quot;matchinfo=fts3&quot; option is not available. The &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;columnsize=0&quot;&lt;/a&gt; option is equivalent.</source>
          <target state="translated">&amp;ldquo; matchinfo = fts3&amp;rdquo;选项不可用。所述&lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&amp;ldquo;columnsize = 0&amp;rdquo;&lt;/a&gt;选项等价。</target>
        </trans-unit>
        <trans-unit id="d99f30c2d0e908e2cc3022d7fdccaca904765bb1" translate="yes" xml:space="preserve">
          <source>The &quot;merge&quot; command attempts to apply all the changes between circles (1) and (4) to the files in the local checkout. Note that circle (5) has not been created yet. You will need to run the &quot;commit&quot; to create circle (5).</source>
          <target state="translated">合并 &quot;命令试图将圆圈(1)和圆圈(4)之间的所有变化应用到本地结帐的文件中。请注意,圆圈(5)还没有被创建,你需要运行 &quot;提交 &quot;来创建圆圈(5)。你需要运行 &quot;提交 &quot;来创建圆圈(5)。</target>
        </trans-unit>
        <trans-unit id="9e41a414a4991da0955ad788ff392c91737d8599" translate="yes" xml:space="preserve">
          <source>The &quot;merge=X,Y&quot; command (where X and Y are integers) causes SQLite to do a limited amount of work toward merging the various inverted index b-trees of an FTS3/4 table together into one large b-tree. The X value is the target number of &quot;blocks&quot; to be merged, and Y is the minimum number of b-tree segments on a level required before merging will be applied to that level. The value of Y should be between 2 and 16 with a recommended value of 8. The value of X can be any positive integer but values on the order of 100 to 300 are recommended.</source>
          <target state="translated">&quot;merge=X,Y &quot;命令(其中X和Y是整数)会使SQLite做有限的工作,争取将FTS3/4表的各个倒置索引b树合并在一起,成为一个大的b树。X值是要合并的 &quot;块 &quot;的目标数量,Y是在某一级别上所需的b树段的最小数量,然后才会对该级别进行合并。Y的值应该在2到16之间,推荐值为8。X的值可以是任何正整数,但推荐值在100到300之间。</target>
        </trans-unit>
        <trans-unit id="7feb211cc64d1d7531c5d948598d752876b7262d" translate="yes" xml:space="preserve">
          <source>The &quot;missing&quot; parameter allows the user to specify the name of a &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database if it finds that the required database file is not present on disk. This provides the application with an opportunity to retrieve the required database from a remote source before swarmvtab attempts to open it. The only argument passed to the &quot;missing&quot; function is the name or URI that identifies the database being opened. Assuming:</source>
          <target state="translated">如果用户发现磁盘上没有所需的数据库文件，则&amp;ldquo; missing&amp;rdquo;参数允许用户指定&lt;a href=&quot;appfunc&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;的名称，该函数将在swarmvtab打开数据库之前被调用。这为应用程序提供了在swarmvtab尝试打开数据库之前从远程源检索所需数据库的机会。传递给&amp;ldquo;缺少&amp;rdquo;功能的唯一参数是标识正在打开的数据库的名称或URI。假设：</target>
        </trans-unit>
        <trans-unit id="9e3f77712e8ba4f79aa6578b325009e072dd171a" translate="yes" xml:space="preserve">
          <source>The &quot;missing&quot; parameter allows the user to specify the name of a &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database if it finds that the required database file is not present on disk. This provides the application with an opportunity to retrieve the required database from a remote source before swarmvtab attempts to open it. The only argument passed to the &quot;missing&quot; function is the name or URI that identifies the database being opened. Assuming:</source>
          <target state="translated">如果用户发现磁盘上没有所需的数据库文件，则&amp;ldquo; missing&amp;rdquo;参数允许用户指定&lt;a href=&quot;c3ref/create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;的名称，该函数将在swarmvtab打开数据库之前被调用。这为应用程序提供了在swarmvtab尝试打开数据库之前从远程源检索所需数据库的机会。传递给&amp;ldquo;缺少&amp;rdquo;功能的唯一参数是标识正在打开的数据库的名称或URI。假设：</target>
        </trans-unit>
        <trans-unit id="6f3a9546b734b773233219e3ac894021d9c4aea3" translate="yes" xml:space="preserve">
          <source>The &quot;mmap_size&quot; is the maximum number of bytes of the database file that SQLite will try to map into the process address space at one time. The mmap_size applies separately to each database file, so the total amount of process address space that could potentially be used is the mmap_size times the number of open database files.</source>
          <target state="translated">&quot;mmap_size &quot;是SQLite一次尝试映射到进程地址空间的数据库文件的最大字节数。mmap_size分别适用于每个数据库文件,所以可能使用的进程地址空间总量是mmap_size乘以打开的数据库文件数。</target>
        </trans-unit>
        <trans-unit id="d05f6ca4b8375a55040cbbe82e13d67e18ad454c" translate="yes" xml:space="preserve">
          <source>The &quot;mptester.c&quot; program is a stress test for multiple processes concurrently reading and writing a single database.</source>
          <target state="translated">&quot;mptester.c &quot;程序是对多个进程并发读写单个数据库的压力测试。</target>
        </trans-unit>
        <trans-unit id="aceceab4037b5385ba92b29e0b20a81e94146ade" translate="yes" xml:space="preserve">
          <source>The &quot;nullvalue&quot; method</source>
          <target state="translated">nullvalue &quot;方法</target>
        </trans-unit>
        <trans-unit id="e3321ce8b4cd40cd33c761004ca598eb073646da" translate="yes" xml:space="preserve">
          <source>The &quot;nullvalue&quot; method changes the representation for NULL returned as result of the &quot;eval&quot; method.</source>
          <target state="translated">nullvalue &quot;方法改变了作为 &quot;eval &quot;方法结果返回的NULL的表示方法。</target>
        </trans-unit>
        <trans-unit id="afd7b6ac7a6da46e476f310a277a91923a4e7d04" translate="yes" xml:space="preserve">
          <source>The &quot;nullvalue&quot; method is useful to differ between NULL and empty column values as Tcl lacks a NULL representation. The default representation for NULL values is an empty string.</source>
          <target state="translated">&quot;nullvalue &quot;方法对于区分NULL值和空列值很有用,因为Tcl缺乏NULL表示法。NULL值的默认表示方法是一个空字符串。</target>
        </trans-unit>
        <trans-unit id="0c64f6777879373881c2c98b6dbc2b30411e222a" translate="yes" xml:space="preserve">
          <source>The &quot;onecolumn&quot; method</source>
          <target state="translated">&quot;onecolumn &quot;方法</target>
        </trans-unit>
        <trans-unit id="3506b602f0b2580a68e5b060067cc065e54d9b3f" translate="yes" xml:space="preserve">
          <source>The &quot;onecolumn&quot; method works like &quot;&lt;a href=&quot;#eval&quot;&gt;eval&lt;/a&gt;&quot; in that it evaluates the SQL query statement given as its argument. The difference is that &quot;onecolumn&quot; returns a single element which is the first column of the first row of the query result.</source>
          <target state="translated">&amp;ldquo; onecolumn&amp;rdquo;方法的工作方式类似于&amp;ldquo; &lt;a href=&quot;#eval&quot;&gt;eval&lt;/a&gt; &amp;rdquo;，因为它评估作为参数给出的SQL查询语句。区别在于&amp;ldquo; onecolumn&amp;rdquo;返回单个元素，该元素是查询结果第一行的第一列。</target>
        </trans-unit>
        <trans-unit id="a0182d08456ee166091bc283f720fe1e714fcddc" translate="yes" xml:space="preserve">
          <source>The &quot;onoff&quot; parameter is true to enable the tracking of memory statistics and false to disable statistics tracking.</source>
          <target state="translated">&quot;onoff &quot;参数为真则启用内存统计跟踪,为假则禁用统计跟踪。</target>
        </trans-unit>
        <trans-unit id="e1f82fa30a955dc30a2b143e423d5902467689c7" translate="yes" xml:space="preserve">
          <source>The &quot;openclose&quot; parameter allows the user to specify the name of a &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database, and again just after it closes one. The first argument passed to the open close function is the filename or URI identifying the database to be opened or just recently closed (the same value returned in the leftmost column of the SQL statement provided to the CREATE VIRTUAL TABLE command). The second argument is integer value 0 when the function is invoked before opening a database, and 1 when it is invoked after one is closed. For example, if:</source>
          <target state="translated">&amp;ldquo; openclose&amp;rdquo;参数允许用户指定&lt;a href=&quot;appfunc&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;的名称，该函数将在swarmvtab打开数据库之前以及在关闭数据库之后再次调用。传递给open close函数的第一个参数是文件名或URI，该文件名或URI标识要打开或刚关闭的数据库（与提供给CREATE VIRTUAL TABLE命令的SQL语句的最左列中返回的值相同）。第二个参数是整数值，在打开数据库之前调用该函数时为0，而在一个数据库关闭后调用该函数时为1。例如，如果：</target>
        </trans-unit>
        <trans-unit id="3c453be3bed80a3f6062f894d9c91b09f2a405f4" translate="yes" xml:space="preserve">
          <source>The &quot;openclose&quot; parameter allows the user to specify the name of a &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database, and again just after it closes one. The first argument passed to the open close function is the filename or URI identifying the database to be opened or just recently closed (the same value returned in the leftmost column of the SQL statement provided to the CREATE VIRTUAL TABLE command). The second argument is integer value 0 when the function is invoked before opening a database, and 1 when it is invoked after one is closed. For example, if:</source>
          <target state="translated">&amp;ldquo; openclose&amp;rdquo;参数允许用户指定&lt;a href=&quot;c3ref/create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;的名称，该函数将在swarmvtab打开数据库之前以及在关闭数据库之后再次调用。传递给open close函数的第一个参数是文件名或URI，用于标识要打开或刚关闭的数据库（在CREATE VIRTUAL TABLE命令提供的SQL语句的最左列中返回的值相同）。第二个参数是整数值，在打开数据库之前调用该函数时为0，而在一个数据库关闭后调用该函数时为1。例如，如果：</target>
        </trans-unit>
        <trans-unit id="e12d49df2a6244cc1bdf5cf47d59be2df870804d" translate="yes" xml:space="preserve">
          <source>The &quot;optimize&quot; command causes FTS3/4 to merge together all of its inverted index b-trees into one large and complete b-tree. Doing an optimize will make subsequent queries run faster since there are fewer b-trees to search, and it may reduce disk usage by coalescing redundant entries. However, for a large FTS table, running optimize can be as expensive as running &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;. The optimize command essentially has to read and write the entire FTS table, resulting in a large transaction.</source>
          <target state="translated">&amp;ldquo;优化&amp;rdquo;命令使FTS3 / 4将所有其反向索引b树合并到一个完整的大b树中。由于搜索的b树较少，因此进行优化将使后续查询运行更快，并且可能通过合并冗余条目来减少磁盘使用。但是，对于大型FTS表，运行优化可能与运行&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;一样昂贵。最优化命令本质上必须读取和写入整个FTS表，从而导致大量事务。</target>
        </trans-unit>
        <trans-unit id="8d4ccdc372ee3d695bbd6a513c0e6e7c13353814" translate="yes" xml:space="preserve">
          <source>The &quot;order&quot; option may be set to either &quot;DESC&quot; or &quot;ASC&quot; (in upper or lower case). If it is set to &quot;DESC&quot;, then FTS4 stores its data in such a way as to optimize returning results in descending order by docid. If it is set to &quot;ASC&quot; (the default), then the data structures are optimized for returning results in ascending order by docid. In other words, if many of the queries run against the FTS4 table use &quot;ORDER BY docid DESC&quot;, then it may improve performance to add the &quot;order=desc&quot; option to the CREATE VIRTUAL TABLE statement.</source>
          <target state="translated">order &quot;选项可以设置为 &quot;DESC &quot;或 &quot;ASC&quot;(大写或小写)。如果它被设置为 &quot;DESC&quot;,那么FTS4存储数据的方式将优化为按docid降序返回结果。如果它被设置为 &quot;ASC&quot;(默认),那么数据结构将被优化为按docid升序返回结果。换句话说,如果许多针对FTS4表的查询使用 &quot;ORDER BY docid DESC&quot;,那么在CREATE VIRTUAL TABLE语句中添加 &quot;order=desc &quot;选项可能会提高性能。</target>
        </trans-unit>
        <trans-unit id="a820cd844c9df8619832ad41e29de304a643e275" translate="yes" xml:space="preserve">
          <source>The &quot;pBuf&quot; parameter is a pointer to memory space that will be used for the lookaside memory pool. If pBuf is NULL, then SQLite will obtain its own space for the memory pool using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The &quot;sz&quot; and &quot;cnt&quot; parameters are the size of each lookaside slot and the number of slots, respectively. If pBuf is not NULL, then it must point to at least sz*cnt bytes of memory.</source>
          <target state="translated">&amp;ldquo; pBuf&amp;rdquo;参数是指向将用于后备内存池的内存空间的指针。如果pBuf为NULL，则SQLite将使用&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;获得其自身的内存池空间。 &amp;ldquo; sz&amp;rdquo;和&amp;ldquo; cnt&amp;rdquo;参数分别是每个后备插槽的大小和插槽数。如果pBuf不为NULL，则它必须至少指向存储器的sz * cnt字节。</target>
        </trans-unit>
        <trans-unit id="96f961210acaa75affae517c15c72d34812d54b4" translate="yes" xml:space="preserve">
          <source>The &quot;parent&quot; column is always NULL for json_each(). For json_tree(), the &quot;parent&quot; column is the &quot;id&quot; integer for the parent of the current element, or NULL for the top-level JSON element or the element identified by the root path in the second argument.</source>
          <target state="translated">对于json_each(),&quot;parent &quot;列总是NULL。对于json_tree(),&quot;parent &quot;列是当前元素的父元素的 &quot;id &quot;整数,对于顶层JSON元素或第二个参数中根路径标识的元素则为NULL。</target>
        </trans-unit>
        <trans-unit id="f4a41ee583b00942417f0c8c5f788e416b5fcd33" translate="yes" xml:space="preserve">
          <source>The &quot;path&quot; column describes the path taken from the root node of the btree structure to each page. The &quot;path&quot; of the root node itself is '/'. The &quot;path&quot; for the left-most child page of the root of a btree page is '/000/'. (Btrees store content ordered from left to right so the pages to the left have smaller keys than the pages to the right.) The next to left-most child of the root page is '/001', and so on, each sibling page identified by a 3-digit hex value. The children of the 451st left-most sibling have paths such as '/1c2/000/, '/1c2/001/' etc. Overflow pages are specified by appending a '+' character and a six-digit hexadecimal value to the path to the cell they are linked from. For example, the three overflow pages in a chain linked from the left-most cell of the 450th child of the root page are identified by the paths:</source>
          <target state="translated">path &quot;一栏描述了从btree结构的根节点到每一页的路径。根节点本身的 &quot;路径 &quot;是'/'。btree页面根节点最左边的子页面的 &quot;路径 &quot;是'/000/'。(Btrees存储内容的顺序是从左到右,所以左边的页面比右边的页面键值小。)根页面的下一个最左边的子页是'/001',以此类推,每个兄弟页面用一个3位的十六进制值来标识。最左451个兄弟姐妹的子页的路径为'/1c2/000/、'/1c2/001/'等。溢出页的指定方法是在它们所链接的单元格的路径上附加一个'+'字符和一个六位数的十六进制值。例如,从根页面第450个子页面的最左边单元格链接的链中的三个溢出页面由路径确定。</target>
        </trans-unit>
        <trans-unit id="91195df7be82f506dcfbeb2cd0a2c8ea2909dc1a" translate="yes" xml:space="preserve">
          <source>The &quot;path&quot; column describes the path taken from the root node of the btree structure to each page. The &quot;path&quot; of the root node itself is '/'. The &quot;path&quot; is NULL when &quot;aggregate&quot; is TRUE. The &quot;path&quot; for the left-most child page of the root of a btree page is '/000/'. (Btrees store content ordered from left to right so the pages to the left have smaller keys than the pages to the right.) The next to left-most child of the root page is '/001', and so on, each sibling page identified by a 3-digit hex value. The children of the 451st left-most sibling have paths such as '/1c2/000/, '/1c2/001/' etc. Overflow pages are specified by appending a '+' character and a six-digit hexadecimal value to the path to the cell they are linked from. For example, the three overflow pages in a chain linked from the left-most cell of the 450th child of the root page are identified by the paths:</source>
          <target state="translated">path &quot;一栏描述了从btree结构的根节点到每一页的路径。根节点本身的 &quot;路径 &quot;是'/'。当 &quot;aggregated &quot;为TRUE时,&quot;path &quot;为NULL。btree页面根节点最左边的子页面的 &quot;路径 &quot;是'/000/'。(Btrees存储内容的顺序是从左到右,所以左边的页面比右边的页面键值小。)根页面的下一个最左边的子页是'/001',以此类推,每个兄弟页面用一个3位的十六进制值来标识。最左451个兄弟姐妹的子页的路径为'/1c2/000/、'/1c2/001/'等。溢出页的指定方法是在它们所链接的单元格的路径上附加一个'+'字符和一个六位数的十六进制值。例如,从根页面第450个子页面的最左边单元格链接的链中的三个溢出页面由路径确定。</target>
        </trans-unit>
        <trans-unit id="2306ed00f4707f3494099d14093fb57dc4cef952" translate="yes" xml:space="preserve">
          <source>The &quot;path&quot; column is the path to the array or object container the holds the current row, or the path to the current row in the case where the iteration starts on a primitive type and thus only provides a single row of output.</source>
          <target state="translated">&quot;路径 &quot;列是指向持有当前行的数组或对象容器的路径,或者在迭代开始于基元类型的情况下,指向当前行的路径,因此只提供单行输出。</target>
        </trans-unit>
        <trans-unit id="9d4d6b26f49abb4a72a1bbdb1337cbe3b3abe73d" translate="yes" xml:space="preserve">
          <source>The &quot;pointer type&quot; in the last parameter to &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;, and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; is used to prevent pointers intended for one extension from being redirected to a different extension. For example, without the use of pointer types, an attacker could still get access to pointer information in a system that included both the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; and the &lt;a href=&quot;carray&quot;&gt;CARRAY extension&lt;/a&gt; using SQL like this:</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;，&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;和&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;的最后一个参数中的&amp;ldquo;指针类型&amp;rdquo; 用于防止将用于一个扩展的指针重定向到另一个扩展。例如，在不使用指针类型的情况下，攻击者仍可以使用SQL 来访问包含&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;和&lt;a href=&quot;carray&quot;&gt;CARRAY扩展名&lt;/a&gt;的系统中的指针信息，如下所示：</target>
        </trans-unit>
        <trans-unit id="adee741afd091308ea52b91bf986798eb9c23f39" translate="yes" xml:space="preserve">
          <source>The &quot;pointer type&quot; string which is the last parameter to each of the pointer-passing interfaces should be a distinct, application-specific string literal that appears directly in the API call. The pointer type should not be a parameter passed in from a higher-level function.</source>
          <target state="translated">作为每个指针传递接口的最后一个参数的 &quot;指针类型 &quot;字符串,应该是直接出现在API调用中的一个独特的、特定于应用程序的字符串文字。指针类型不应该是上级函数传递过来的参数。</target>
        </trans-unit>
        <trans-unit id="87d3095f178983c8a04814005e7e058687741b3d" translate="yes" xml:space="preserve">
          <source>The &quot;prefix&quot; option, used to add &lt;a href=&quot;fts5#prefix_indexes&quot;&gt;prefix indexes&lt;/a&gt; to an FTS5 table.</source>
          <target state="translated">&amp;ldquo;前缀&amp;rdquo;选项，用于将&lt;a href=&quot;fts5#prefix_indexes&quot;&gt;前缀索引&lt;/a&gt;添加到FTS5表中。</target>
        </trans-unit>
        <trans-unit id="007337419b82fead3e9a4bb4ea6d17cd18d879d3" translate="yes" xml:space="preserve">
          <source>The &quot;price of California oranges&quot; query was made more efficient through the use of a two-column index. But SQLite can do even better with a three-column index that also includes the &quot;price&quot; column:</source>
          <target state="translated">&quot;加州橙子的价格 &quot;查询通过使用两列索引提高了效率。但如果使用三列索引,其中还包括 &quot;价格 &quot;列,SQLite可以做得更好。</target>
        </trans-unit>
        <trans-unit id="57afc82684ba8294d6cce9305c290f392e265962" translate="yes" xml:space="preserve">
          <source>The &quot;profile&quot; method</source>
          <target state="translated">&quot;配置文件 &quot;方法</target>
        </trans-unit>
        <trans-unit id="a6a8d9f9ad6e3aababd749d5fdde2d82848ad996" translate="yes" xml:space="preserve">
          <source>The &quot;progress&quot; method</source>
          <target state="translated">&quot;进度 &quot;法</target>
        </trans-unit>
        <trans-unit id="588545c2f185476e9dee998a1b045a9b0c16cc70" translate="yes" xml:space="preserve">
          <source>The &quot;quote&quot; output mode honors &quot;.separator&quot;</source>
          <target state="translated">&quot;引号 &quot;输出模式尊重&quot;.分隔符&quot;</target>
        </trans-unit>
        <trans-unit id="d98ea4147c812e538b99bc21f1f6a4e8e90abfe0" translate="yes" xml:space="preserve">
          <source>The &quot;rbu_control&quot; column may also be set to integer value 2 for an INSERT. In this case, the new row silently replaces any existing row that has the same primary key values. This is equivalent to a DELETE followed by an INSERT with the same primary key values. It is not the same as an SQL REPLACE command, as in that case the new row may replace any conflicting rows (i.e. those that conflict due to UNIQUE constraints or indexes), not just those with conflicting primary keys.</source>
          <target state="translated">&quot;rbu_control &quot;列也可以设置为INSERT的整数值2。在这种情况下,新的记录会默默地替换任何具有相同主键值的现有记录。这相当于一个DELETE之后是一个具有相同主键值的INSERT。它与SQL REPLACE命令不同,因为在这种情况下,新行可以替换任何冲突的记录(即那些由于UNIQUE约束或索引而导致冲突的记录),而不仅仅是那些主键冲突的记录。</target>
        </trans-unit>
        <trans-unit id="a26e076f35ba0ef194f00cabb02d8f0d110dbd9a" translate="yes" xml:space="preserve">
          <source>The &quot;rebuild&quot; command causes SQLite to discard the entire FTS3/4 table and then rebuild it again from original text. The concept is similar to &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;, only that it applies to an FTS3/4 table instead of an ordinary index.</source>
          <target state="translated">&amp;ldquo;重建&amp;rdquo;命令使SQLite放弃整个FTS3 / 4表，然后从原始文本重新重建它。该概念类似于&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;，只是它适用于FTS3 / 4表而不是普通索引。</target>
        </trans-unit>
        <trans-unit id="9dfe3ef5f9d0e5aefda4d198135af7dfc82b7ad7" translate="yes" xml:space="preserve">
          <source>The &quot;rebuild&quot; command should be run whenever the implementation of a custom tokenizer changes, so that all content can be retokenized. The &quot;rebuild&quot; command is also useful when using the &lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4 content option&lt;/a&gt; after changes have been made to the original content table.</source>
          <target state="translated">每当自定义标记生成器的实现发生更改时，都应运行&amp;ldquo; rebuild&amp;rdquo;命令，以便可以重新标记所有内容。在对原始内容表进行更改之后使用&lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4内容选项&lt;/a&gt;时，&amp;ldquo;重建&amp;rdquo;命令也很有用。</target>
        </trans-unit>
        <trans-unit id="c9e0f27230c23e1210b0f85831927b9fb4ed65b1" translate="yes" xml:space="preserve">
          <source>The &quot;restore&quot; method</source>
          <target state="translated">&quot;还原 &quot;方法</target>
        </trans-unit>
        <trans-unit id="24c21c10984afe5581e89897013fce4a408ba45f" translate="yes" xml:space="preserve">
          <source>The &quot;restore&quot; method copies the content from a separate database file into the current database connection, overwriting any preexisting content. The command syntax is like this:</source>
          <target state="translated">&quot;还原 &quot;方法将单独的数据库文件中的内容复制到当前的数据库连接中,覆盖任何已存在的内容。命令的语法是这样的。</target>
        </trans-unit>
        <trans-unit id="9587ea916bf4a39318094206a7a32f2bcdfaa5ba" translate="yes" xml:space="preserve">
          <source>The &quot;rollback_hook&quot; method</source>
          <target state="translated">&quot;rollback_hook &quot;方法</target>
        </trans-unit>
        <trans-unit id="e00d488bea46afaaecd75512057a1c66d8fe6370" translate="yes" xml:space="preserve">
          <source>The &quot;score&quot; for a comparison is the edit distance between the pattern and the word, adjusted down by the base-2 logarithm of the word rank. For example, a match with distance 100 but rank 1000 would have a score of 122 (= 100 - log2(1000) + 32) whereas a match with distance 100 with a rank of 1 would have a score of 131 (100 - log2(1) + 32). (NB: The constant 32 is added to each score to keep it from going negative in case the edit distance is zero.) In this way, frequently used words get a slightly lower cost which tends to move them toward the top of the list of alternative spellings.</source>
          <target state="translated">比对的 &quot;分数 &quot;是模式和单词之间的编辑距离,通过单词等级的基数-2对数向下调整。例如,一个距离为100但等级为1000的匹配,得分为122 (=100-log2(1000)+32),而一个距离为100但等级为1的匹配,得分为131 (100-log2(1)+32)。(注:常数32被加到每个分数上,以防止在编辑距离为零的情况下出现负数。)这样一来,经常使用的词就会得到一个略低的成本,从而使它们在备选拼写列表中名列前茅。</target>
        </trans-unit>
        <trans-unit id="5c73b0b5b1beb7568fc6d18b01b575dea3734b9a" translate="yes" xml:space="preserve">
          <source>The &quot;serialize&quot; method</source>
          <target state="translated">序列化 &quot;方法</target>
        </trans-unit>
        <trans-unit id="3d89d42c3828f01cc4451e3643a15ed26533dc51" translate="yes" xml:space="preserve">
          <source>The &quot;serialize&quot; method creates a BLOB which is a complete copy of an underlying database. The syntax is like this:</source>
          <target state="translated">&quot;序列化 &quot;方法创建了一个BLOB,它是底层数据库的完整副本。语法是这样的。</target>
        </trans-unit>
        <trans-unit id="d8ecb1d818748f027a6df9d4ecf31fdb4abf6802" translate="yes" xml:space="preserve">
          <source>The &quot;size&quot; of a row value is the number of scalar values the row value contains. The size of a row value is always at least 2. A row value with a single column is just a scalar value. A row value with no columns is a syntax error.</source>
          <target state="translated">行值的 &quot;大小 &quot;是指行值所包含的标量值的数量,行值的大小总是至少为2。一个行值的大小总是至少为2。 一个有单列的行值只是一个标量值。一个没有列的行值是一个语法错误。</target>
        </trans-unit>
        <trans-unit id="5edd5de6e6f1cc913259bc478dccfe21c6a5d5fb" translate="yes" xml:space="preserve">
          <source>The &quot;speedtest1.c&quot; program estimates the performance of SQLite under a typical workload.</source>
          <target state="translated">&quot;speedtest1.c &quot;程序估计了SQLite在典型工作负载下的性能。</target>
        </trans-unit>
        <trans-unit id="94d1e1fa50bdc62251cad63515806a616cb08e98" translate="yes" xml:space="preserve">
          <source>The &quot;spellfix1&quot; term is the name of the spellfix module and must be entered as shown. The &quot;demo&quot; term is the name of the virtual table you will be creating and can be altered to suit the needs of your application. The virtual table is initially empty. In order for the virtual table to be useful, you will need to populate it with your vocabulary. Suppose you have a list of words in a table named &quot;big_vocabulary&quot;. Then do this:</source>
          <target state="translated">spellfix1 &quot;一词是spellfix模块的名称,必须如图所示输入。&quot;demo &quot;项是您将要创建的虚拟表的名称,可以根据您的应用程序的需要进行修改。虚拟表最初是空的。为了使虚拟表有用,您需要用您的词汇来填充它。假设你在一个名为 &quot;big_vocabulary &quot;的表中有一个单词列表。那么可以这样做。</target>
        </trans-unit>
        <trans-unit id="1f251add4c0609e09930cd5b2e1c244e554f6696" translate="yes" xml:space="preserve">
          <source>The &quot;sqlite3.c&quot; code file contains default implementations of a VFS and of the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; functions that are appropriate for Unix, Windows, and OS/2. To prevent one of these default components from being loaded when sqlite3.c is compiled, it is necessary to add the following compile-time option:</source>
          <target state="translated">&amp;ldquo; sqlite3.c&amp;rdquo;代码文件包含VFS的默认实现以及适用于Unix，Windows和OS / 2 的&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;和&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;函数的默认实现。为了防止在编译sqlite3.c时加载这些默认组件之一，有必要添加以下编译时选项：</target>
        </trans-unit>
        <trans-unit id="d25afe467d47fff3cdb66b829147595e777d2e30" translate="yes" xml:space="preserve">
          <source>The &quot;sqlite3.c&quot; make target will automatically construct the regular &quot;&lt;b&gt;sqlite3.c&lt;/b&gt;&quot; amalgamation source file, its header file &quot;&lt;b&gt;sqlite3.h&lt;/b&gt;&quot;, and the &quot;&lt;b&gt;tclsqlite3.c&lt;/b&gt;&quot; amalgamation source file that includes the TCL interface. Afterwards, the needed files can be copied into project directories and compiled according to the procedures outlined above.</source>
          <target state="translated">&amp;ldquo; sqlite3.c&amp;rdquo;生成目标将自动构造常规的&amp;ldquo; &lt;b&gt;sqlite3.c&lt;/b&gt; &amp;rdquo;合并源文件，其头文件&amp;ldquo; &lt;b&gt;sqlite3.h&lt;/b&gt; &amp;rdquo;和包含TCL接口的&amp;ldquo; &lt;b&gt;tclsqlite3.c&lt;/b&gt; &amp;rdquo;合并源文件。然后，可以将所需的文件复制到项目目录中，并根据上述过程进行编译。</target>
        </trans-unit>
        <trans-unit id="66d4d7e86561a6b1d54c81eff00582173909b3a6" translate="yes" xml:space="preserve">
          <source>The &quot;sqlite3_analyzer.exe&quot; utility program, available as source code in the SQLite source tree or as a precompiled binary on the &lt;a href=&quot;http://www.sqlite.org/download.html&quot;&gt;SQLite Download page&lt;/a&gt;, can be used to measure the average sizes of table rows in an existing SQLite database.</source>
          <target state="translated">&amp;ldquo; sqlite3_analyzer.exe&amp;rdquo;实用程序可以在SQLite源代码树中作为源代码使用，也可以在&lt;a href=&quot;http://www.sqlite.org/download.html&quot;&gt;SQLite下载页面&lt;/a&gt;上作为预编译的二进制文件使用，可用于测量现有SQLite数据库中表行的平均大小。</target>
        </trans-unit>
        <trans-unit id="a9d37ec09106220f475c04bb945df6d0783856ec" translate="yes" xml:space="preserve">
          <source>The &quot;sqlite3_analyzer.exe&quot; utility program, available as source code in the SQLite source tree or as a precompiled binary on the &lt;a href=&quot;https://www.sqlite.org/download.html&quot;&gt;SQLite Download page&lt;/a&gt;, can be used to measure the average sizes of table rows in an existing SQLite database.</source>
          <target state="translated">&amp;ldquo; sqlite3_analyzer.exe&amp;rdquo;实用程序可以在SQLite源代码树中作为源代码使用，也可以在&lt;a href=&quot;https://www.sqlite.org/download.html&quot;&gt;SQLite下载页面&lt;/a&gt;上作为预编译的二进制文件使用，可用于测量现有SQLite数据库中表行的平均大小。</target>
        </trans-unit>
        <trans-unit id="ff30531d333139aba53fa40d0cdd26055103901a" translate="yes" xml:space="preserve">
          <source>The &quot;start match&quot; text.</source>
          <target state="translated">开始匹配 &quot;的文字。</target>
        </trans-unit>
        <trans-unit id="b039029daf858be6adbac43c34475b31375cdd36" translate="yes" xml:space="preserve">
          <source>The &quot;start of&quot; modifiers (7 through 9) shift the date backwards to the beginning of the current month, year or day.</source>
          <target state="translated">&quot;开始 &quot;修饰符(7到9)将日期向后移到当前月份、年份或日期的开始。</target>
        </trans-unit>
        <trans-unit id="05b5d073f83b249218dde4220e351fdb9c81957d" translate="yes" xml:space="preserve">
          <source>The &quot;state&quot; index works just like the &quot;fruit&quot; index in that it is a new table with an extra column in front of the rowid and sorted by that extra column as the primary key. The only difference is that in Idx2, the first column is &quot;state&quot; instead of &quot;fruit&quot; as it is with Idx1. In our example data set, there is more redundancy in the &quot;state&quot; column and so they are more duplicate entries. The ties are still resolved using the rowid.</source>
          <target state="translated">状态 &quot;索引的工作原理和 &quot;水果 &quot;索引一样,它是一个新表,在 rowid 前面多了一列,并以这一列作为主键进行排序。唯一不同的是,在Idx2中,第一列是 &quot;state &quot;而不是像Idx1那样的 &quot;fruit&quot;。在我们的示例数据集中,&quot;状态 &quot;列有更多的冗余,因此它们有更多的重复条目。并列的情况还是用rowid来解决。</target>
        </trans-unit>
        <trans-unit id="cf055db4baca803941f56b418b3f79cd69d69f75" translate="yes" xml:space="preserve">
          <source>The &quot;status&quot; method</source>
          <target state="translated">&quot;状态 &quot;方法</target>
        </trans-unit>
        <trans-unit id="4cb7bc19f02c001a06f5cf0e9a288feeb79d31b6" translate="yes" xml:space="preserve">
          <source>The &quot;swarmvtab&quot; virtual table allows the user to query a large number of tables (hereafter &quot;component&quot; tables) with similar schemas but distinct ranges of rowid values as if they were a single database table. The tables may be (and usually are) located in different databases. Swarmvtab tables are read-only.</source>
          <target state="translated">&quot;swarmvtab &quot;虚拟表允许用户查询大量的表(以下简称 &quot;组件 &quot;表),这些表具有类似的模式,但其rowid值的范围不同,就像它们是一个单一的数据库表一样。这些表可能(通常也是)位于不同的数据库中。Swarmvtab表是只读的。</target>
        </trans-unit>
        <trans-unit id="dab19bcea20e3ab7d9ecf3510719cf0224e13f4a" translate="yes" xml:space="preserve">
          <source>The &quot;sz&quot; parameter is the size in bytes of each lookaside slot. The &quot;cnt&quot; parameter is the total number of lookaside memory slots per database connection. The total amount of lookaside memory allocated to each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is sz*cnt bytes.</source>
          <target state="translated">&amp;ldquo; sz&amp;rdquo;参数是每个后备插槽的大小（以字节为单位）。&amp;ldquo; cnt&amp;rdquo;参数是每个数据库连接的后备内存插槽总数。分配给每个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;的后备内存总量为sz * cnt字节。</target>
        </trans-unit>
        <trans-unit id="21cc2584b07fb547745b9d5684016c88291d98ce" translate="yes" xml:space="preserve">
          <source>The &quot;sz=NNN&quot; argument (where NNN represents a sequence of 1 or more digits) means that the average row size over all records of the table or index is NNN bytes per row. The SQLite query planner might use the estimated row size information provided by the &quot;sz=NNN&quot; token to help it choose smaller tables and indexes that require less disk I/O.</source>
          <target state="translated">&quot;sz=NNN &quot;参数(其中NNN代表1个或多个数字的序列)意味着表或索引的所有记录的平均行大小为每行NNN字节。SQLite查询规划器可能会使用 &quot;sz=NNN &quot;标记提供的估计行大小信息来帮助它选择需要较少磁盘I/O的较小表和索引。</target>
        </trans-unit>
        <trans-unit id="1f5faa11cc0f3cca617edc23b678832f22fc7469" translate="yes" xml:space="preserve">
          <source>The &quot;temp&quot; database (in which TEMP tables and indices are stored) and &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt; always uses exclusive locking mode. The locking mode of temp and &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt; cannot be changed. All other databases use the normal locking mode by default and are affected by this pragma.</source>
          <target state="translated">&amp;ldquo; temp&amp;rdquo;数据库​​（存储TEMP表和索引的&lt;a href=&quot;inmemorydb&quot;&gt;数据库&lt;/a&gt;）和内存数据库始终使用互斥锁定模式。临时&lt;a href=&quot;inmemorydb&quot;&gt;数据库&lt;/a&gt;和内存数据库的锁定模式无法更改。默认情况下，所有其他数据库都使用普通锁定模式，并且受此编译指示的影响。</target>
        </trans-unit>
        <trans-unit id="8cb92fbf85091b767df43e1863c69aa8515916b3" translate="yes" xml:space="preserve">
          <source>The &quot;test1.dir&quot; directory created above puts all the blobs into a single folder. It was conjectured that some operating systems would perform poorly when a single directory contains 100,000 objects. To test this, the kvtest program can also store the blobs in a hierarchy of folders with no more than 100 files and/or subdirectories per folder. The alternative on-disk representation of the blobs can be created using the --tree command-line option to the &quot;export&quot; command, like this:</source>
          <target state="translated">上面创建的 &quot;test1.dir &quot;目录将所有的blobs放到一个文件夹中。据推测,当单个目录包含100,000个对象时,一些操作系统的性能会很差。为了测试这一点,kvtest程序也可以将blobs存储在文件夹的层次结构中,每个文件夹中的文件和/或子目录不超过100个。可以使用 &quot;export &quot;命令的--tree命令行选项来创建blobs的另一种磁盘表示方式,就像这样。</target>
        </trans-unit>
        <trans-unit id="9e8c625e743111097d3b7602f25647d8fd5f0deb" translate="yes" xml:space="preserve">
          <source>The &quot;th3&quot; binary is run and the output checked for errors.</source>
          <target state="translated">运行 &quot;th3 &quot;二进制,检查输出是否有错误。</target>
        </trans-unit>
        <trans-unit id="405706da87374261dc84d98a92672d2aa3e6824d" translate="yes" xml:space="preserve">
          <source>The &quot;threadtest3.c&quot; program is a stress test for multiple threads using SQLite simultaneously.</source>
          <target state="translated">&quot;threadtest3.c &quot;程序是对多个线程同时使用SQLite进行压力测试。</target>
        </trans-unit>
        <trans-unit id="c2ea8ab5c5050c4a238a6302498853dd2f689e62" translate="yes" xml:space="preserve">
          <source>The &quot;three&quot; column -- the key to the bucket</source>
          <target state="translated">&quot;三 &quot;栏--桶的钥匙</target>
        </trans-unit>
        <trans-unit id="4fa8abbe4c1763e70302352dd8c5a5a17e072b27" translate="yes" xml:space="preserve">
          <source>The &quot;timeout&quot; method</source>
          <target state="translated">超时 &quot;方法</target>
        </trans-unit>
        <trans-unit id="7d44f83daf7e28e3193a3ecca21e30ba205796c2" translate="yes" xml:space="preserve">
          <source>The &quot;timeout&quot; method is used to control how long the SQLite library will wait for locks to clear before giving up on a database transaction. The default timeout is 0 millisecond. (In other words, the default behavior is not to wait at all.)</source>
          <target state="translated">&quot;超时 &quot;方法用于控制SQLite库在放弃数据库事务之前等待锁清除的时间。默认的超时是0毫秒。换句话说,默认的行为是完全不等待)。</target>
        </trans-unit>
        <trans-unit id="7ac730ff83376aab14adb2a2686e6b4272b35baf" translate="yes" xml:space="preserve">
          <source>The &quot;tokenize&quot; option, used to configure a &lt;a href=&quot;fts5#tokenizers&quot;&gt;custom tokenizer&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo; tokenize&amp;rdquo;选项，用于配置&lt;a href=&quot;fts5#tokenizers&quot;&gt;自定义标记器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5924f14d286c018a59c3ed95d3124a43c86bfc19" translate="yes" xml:space="preserve">
          <source>The &quot;total_changes&quot; method</source>
          <target state="translated">&quot;total_changes &quot;方法</target>
        </trans-unit>
        <trans-unit id="67201b01d24a416fed46b29f515a9e7ed51080c3" translate="yes" xml:space="preserve">
          <source>The &quot;total_changes&quot; method returns an integer which is the number of rows in the database that were inserted, deleted, and/or modified since the current database connection was first opened.</source>
          <target state="translated">&quot;total_changes &quot;方法返回一个整数,这个整数是自当前数据库连接首次打开以来在数据库中插入、删除和/或修改的行数。</target>
        </trans-unit>
        <trans-unit id="7e6156617165c2bee31d2c34a55e3df2f7ee7cbc" translate="yes" xml:space="preserve">
          <source>The &quot;trace&quot; method</source>
          <target state="translated">&quot;跟踪 &quot;方法</target>
        </trans-unit>
        <trans-unit id="b2906df9327952a977291763abf36d4cd7917ee1" translate="yes" xml:space="preserve">
          <source>The &quot;trace&quot; method registers a callback that is invoked as each SQL statement is compiled. The text of the SQL is appended as a single string to the command before it is invoked. This can be used (for example) to keep a log of all SQL operations that an application performs.</source>
          <target state="translated">&quot;trace &quot;方法注册了一个回调,它在每条SQL语句被编译时被调用。SQL的文本在被调用之前作为一个单一的字符串附加到命令中。这可以用来(例如)保存应用程序执行的所有SQL操作的日志。</target>
        </trans-unit>
        <trans-unit id="ce50004a13c3fcabcb6ebda341338c2b6ecfb280" translate="yes" xml:space="preserve">
          <source>The &quot;trace_v2&quot; method</source>
          <target state="translated">trace_v2 &quot;方法</target>
        </trans-unit>
        <trans-unit id="2fe37d0c891dddf24c1d50f2d3327a7f07cf31d0" translate="yes" xml:space="preserve">
          <source>The &quot;trace_v2&quot; method registers a callback that is invoked as each SQL statement is compiled. The syntax is as follows:</source>
          <target state="translated">trace_v2 &quot;方法注册了一个回调,这个回调会在每条SQL语句被编译时被调用。语法如下。</target>
        </trans-unit>
        <trans-unit id="e9e9294106d107e583dc783efd0d04b347f737f9" translate="yes" xml:space="preserve">
          <source>The &quot;transaction&quot; method</source>
          <target state="translated">&quot;交易 &quot;方法</target>
        </trans-unit>
        <trans-unit id="839415a25e55cb5e0ba1d1d3bedbc6f8468c1f73" translate="yes" xml:space="preserve">
          <source>The &quot;transaction&quot; method is used to execute a TCL script inside an SQLite database transaction. The transaction is committed when the script completes, or it rolls back if the script fails. If the transaction occurs within another transaction (even one that is started manually using BEGIN) it is a no-op.</source>
          <target state="translated">&quot;transaction &quot;方法用于在SQLite数据库事务中执行TCL脚本。当脚本完成时,事务就会被提交,如果脚本失败,事务就会回滚。如果事务发生在另一个事务中(即使是一个使用BEGIN手动启动的事务),它就是一个no-op。</target>
        </trans-unit>
        <trans-unit id="378f72a23dc895cffd3910e611b45425aeb46721" translate="yes" xml:space="preserve">
          <source>The &quot;type&quot; column is an SQL text value taken from ('null', 'true', 'false', 'integer', 'real', 'text', 'array', 'object') according to the type of the current JSON element.</source>
          <target state="translated">&quot;type &quot;列是根据当前JSON元素的类型从('null'、'true'、'false'、'integer'、'real'、'text'、'array'、'object')中提取的SQL文本值。</target>
        </trans-unit>
        <trans-unit id="135f2f5e5d2c30f651d7adf36038240ab6497277" translate="yes" xml:space="preserve">
          <source>The &quot;typical&quot; workload is generated by the &lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt; program in the canonical SQLite source tree. This program strives to exercise the SQLite library in a way that is typical of real-world applications. Of course, every application is different, and so no test program can exactly mirror the behavior of all applications.</source>
          <target state="translated">&amp;ldquo;典型&amp;rdquo;工作负载是由标准SQLite源树中的&lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt;程序生成的。该程序努力以实际应用程序中常见的方式使用SQLite库。当然，每个应用程序都是不同的，因此没有测试程序可以完全反映所有应用程序的行为。</target>
        </trans-unit>
        <trans-unit id="27bfc78b4ec7e83cf7c09ae529723bb27ae007c2" translate="yes" xml:space="preserve">
          <source>The &quot;ui&quot; command will cause fossil to run a miniature built-in webserver and to launch your web-browser pointing at that webserver. You can use your web-browser to configure your project in various ways. See the instructions on the fossil website for additional information.</source>
          <target state="translated">ui &quot;命令会使化石运行一个微型内置的web服务器,并启动指向该web服务器的web浏览器。你可以用你的浏览器来配置你的项目。更多的信息请参考化石网站上的说明。</target>
        </trans-unit>
        <trans-unit id="d78919ab60690742844f0ae8327639ff7f7b254a" translate="yes" xml:space="preserve">
          <source>The &quot;unicode61&quot; tokenizer is available beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;version 3.7.13&lt;/a&gt; (2012-06-11). Unicode61 works very much like &quot;simple&quot; except that it does simple unicode case folding according to rules in Unicode Version 6.1 and it recognizes unicode space and punctuation characters and uses those to separate tokens. The simple tokenizer only does case folding of ASCII characters and only recognizes ASCII space and punctuation characters as token separators.</source>
          <target state="translated">从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;版本3.7.13&lt;/a&gt;（2012-06-11）开始可以使用&amp;ldquo; unicode61&amp;rdquo;令牌生成器。 Unicode61的工作方式与&amp;ldquo;简单&amp;rdquo;非常相似，不同之处在于，它按照Unicode版本6.1中的规则进行简单的unicase大小写折叠，并且可以识别unicode空间和标点符号，并使用它们来分隔标记。简单的令牌生成器仅对ASCII字符进行大小写折叠，并且仅将ASCII空间和标点符号识别为令牌分隔符。</target>
        </trans-unit>
        <trans-unit id="d6180590d39510270d29b1019046f6c7b0cbc137" translate="yes" xml:space="preserve">
          <source>The &quot;unixepoch&quot; modifier (11) only works if it immediately follows a time value in the DDDDDDDDDD format. This modifier causes the DDDDDDDDDD to be interpreted not as a Julian day number as it normally would be, but as &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix Time&lt;/a&gt; - the number of seconds since 1970. If the &quot;unixepoch&quot; modifier does not follow a time value of the form DDDDDDDDDD which expresses the number of seconds since 1970 or if other modifiers separate the &quot;unixepoch&quot; modifier from prior DDDDDDDDDD then the behavior is undefined. For SQLite versions before 3.16.0 (2017-01-02), the &quot;unixepoch&quot; modifier only works for dates between 0000-01-01 00:00:00 and 5352-11-01 10:52:47 (unix times of -62167219200 through 106751991167).</source>
          <target state="translated">&amp;ldquo; unixepoch&amp;rdquo;修饰符（11）仅在紧随DDDDDDDDDD格式的时间值后才起作用。此修饰符使DDDDDDDDDD不再像通常那样解释为儒略日数，而是解释为&lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix时间&lt;/a&gt;-自1970年以来的秒数。如果&amp;ldquo; unixepoch&amp;rdquo;修饰符未遵循表示为DDDDDDDDDD形式的时间值自1970年以来的秒数，或者如果其他修饰符将&amp;ldquo; unixepoch&amp;rdquo;修饰符与先前的DDDDDDDDDD分开，则该行为是不确定的。对于3.16.0（2017-01-02）之前的SQLite版本，&amp;ldquo; unixepoch&amp;rdquo;修饰符仅适用于0000-01-01 00:00:00和5352-11-01 10:52:47之间的日期（ -62167219200至106751991167）。</target>
        </trans-unit>
        <trans-unit id="53568b33d00330dcebc8eb48a597c612134f3558" translate="yes" xml:space="preserve">
          <source>The &quot;unixepoch&quot; modifier (11) only works if it immediately follows a timestring in the DDDDDDDDDD format. This modifier causes the DDDDDDDDDD to be interpreted not as a Julian day number as it normally would be, but as &lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix Time&lt;/a&gt; - the number of seconds since 1970. If the &quot;unixepoch&quot; modifier does not follow a timestring of the form DDDDDDDDDD which expresses the number of seconds since 1970 or if other modifiers separate the &quot;unixepoch&quot; modifier from prior DDDDDDDDDD then the behavior is undefined. For SQLite versions before 3.16.0 (2017-01-02), the &quot;unixepoch&quot; modifier only works for dates between 0000-01-01 00:00:00 and 5352-11-01 10:52:47 (unix times of -62167219200 through 106751991167).</source>
          <target state="translated">&amp;ldquo; unixepoch&amp;rdquo;修饰符（11）仅在紧随DDDDDDDDDD格式的时间字符串之后才起作用。此修饰符使DDDDDDDDDD不再像通常那样解释为儒略日数，而是解释为&lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix时间&lt;/a&gt; -自1970年以来的秒数。如果&amp;ldquo; unixepoch&amp;rdquo;修饰符未遵循DDDDDDDDDD形式的时间字符串，则该字符串表示自1970年以来的秒数，或者如果其他修饰符将&amp;ldquo; unixepoch&amp;rdquo;修饰符与先前的DDDDDDDDDD分开，则该行为是不确定的。对于3.16.0（2017-01-02）之前的SQLite版本，&amp;ldquo; unixepoch&amp;rdquo;修饰符仅适用于0000-01-01 00:00:00到5352-11-01 10:52:47之间的日期（ -62167219200至106751991167）。</target>
        </trans-unit>
        <trans-unit id="9a380264abb876efbc0e0abf2e6a2f4c233a20b1" translate="yes" xml:space="preserve">
          <source>The &quot;unlock_notify&quot; method</source>
          <target state="translated">&quot;unlock_notify &quot;方法</target>
        </trans-unit>
        <trans-unit id="a59aa60915a8fc6bc6f97fdfa3c585be19ca1408" translate="yes" xml:space="preserve">
          <source>The &quot;update_hook&quot; method</source>
          <target state="translated">update_hook &quot;方法</target>
        </trans-unit>
        <trans-unit id="ad1e96bd97056b4fb89ac4a9d66b380d5f0978cd" translate="yes" xml:space="preserve">
          <source>The &quot;usable size&quot; of a database page is the page size specified by the 2-byte integer at offset 16 in the header less the &quot;reserved&quot; space size recorded in the 1-byte integer at offset 20 in the header. The usable size of a page might be an odd number. However, the usable size is not allowed to be less than 480. In other words, if the page size is 512, then the reserved space size cannot exceed 32.</source>
          <target state="translated">数据库页面的 &quot;可用大小 &quot;是由页眉偏移量16中的2字节整数指定的页面大小减去页眉偏移量20中的1字节整数中记录的 &quot;保留 &quot;空间大小。一个页面的可用大小可能是一个奇数。但是,可用的大小不允许小于480。换句话说,如果页面大小是512,那么保留的空间大小不能超过32。</target>
        </trans-unit>
        <trans-unit id="0117a41a4edb11977b96c0bfbaf5ae135dd4dc28" translate="yes" xml:space="preserve">
          <source>The &quot;user version&quot; as read and set by the &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma&lt;/a&gt;.</source>
          <target state="translated">由&lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma&lt;/a&gt;读取和设置的&amp;ldquo;用户版本&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="4f1221e2090e85cfaa0707db328c83c8e04e4462" translate="yes" xml:space="preserve">
          <source>The &quot;verb&quot; argument determines what statistic is accessed. There are &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;various verbs&lt;/a&gt; defined. The list is expected to grow as the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt; interface matures. The current value the selected parameter is written into integer &quot;current&quot; and the highest historical value is written into integer &quot;highwater&quot;. If resetflag is true, then the high-water mark is reset down to the current value after the call returns.</source>
          <target state="translated">&amp;ldquo;动词&amp;rdquo;参数确定要访问的统计信息。有&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;不同的动词&lt;/a&gt;定义。随着&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status（）&lt;/a&gt;接口的成熟，该列表有望增长。所选参数的当前值写入整数&amp;ldquo; current&amp;rdquo;，最高历史值写入整数&amp;ldquo; highwater&amp;rdquo;。如果resetflag为true，则在调用返回后将高水位标记重置为当前值。</target>
        </trans-unit>
        <trans-unit id="fa357090791a4202ebbb1affe438340a7edf58ef" translate="yes" xml:space="preserve">
          <source>The &quot;version&quot; method</source>
          <target state="translated">&quot;版本 &quot;方法</target>
        </trans-unit>
        <trans-unit id="cd6ed1a853164caf36a9ec472723c210aaf3324f" translate="yes" xml:space="preserve">
          <source>The &quot;wal_hook&quot; method</source>
          <target state="translated">&quot;wal_hook &quot;方法</target>
        </trans-unit>
        <trans-unit id="13953b9d13af87a94ab5c5d6a6cf14aaf24d8b07" translate="yes" xml:space="preserve">
          <source>The &quot;weekday&quot; modifier advances the date forward, if necessary, to the next date where the weekday number is N. Sunday is 0, Monday is 1, and so forth. If the date is already on the desired weekday, the &quot;weekday&quot; modifier leaves the date unchanged.</source>
          <target state="translated">如果需要,&quot;星期几 &quot;修饰符将日期向前推进到下一个日期,其中星期几是N,星期日是0,星期一是1,以此类推。如果日期已经在所需的工作日,&quot;星期几 &quot;修饰符将日期保持不变。</target>
        </trans-unit>
        <trans-unit id="fc5b825d3bb551c0ffab90d4aebeaa4b072d1ccb" translate="yes" xml:space="preserve">
          <source>The $nExtCode extended result codes are &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="translated">$ nExtCode扩展结果代码&lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;在sqlite3.h&lt;/a&gt;中定义，并按字母顺序在下面列出：</target>
        </trans-unit>
        <trans-unit id="d7c45544c374d408b5b737fa2b109d54d1a57530" translate="yes" xml:space="preserve">
          <source>The $nPrimCode result codes are &lt;a href=&quot;c3ref/c_abort&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="translated">$ nPrimCode结果代码&lt;a href=&quot;c3ref/c_abort&quot;&gt;在sqlite3.h&lt;/a&gt;中定义，并按字母顺序在下面列出：</target>
        </trans-unit>
        <trans-unit id="3ab512eff5b3fb377f299e58700487486d503855" translate="yes" xml:space="preserve">
          <source>The $prefix parameter may be NULL, in which case the prefix is deduced from $wholeline. Or, the $wholeline parameter may be NULL or omitted if context information is unavailable or if context-aware completion is not desired.</source>
          <target state="translated">参数$prefix可以是NULL,在这种情况下,前缀是由$wholeline推导出来的。或者,如果上下文信息不可用或不需要上下文感知的完成,$wholeline参数可以是NULL或省略。</target>
        </trans-unit>
        <trans-unit id="02bbc5a1a7e84666a4d4dd0cec4c28449ae27a6f" translate="yes" xml:space="preserve">
          <source>The %_content table contains the unadulterated data inserted by the user into the FTS virtual table by the user. If the user does not explicitly supply a &quot;docid&quot; value when inserting records, one is selected automatically by the system.</source>
          <target state="translated">%_content表中包含了用户插入到FTS虚拟表中的用户未掺杂的数据。如果用户在插入记录时没有明确提供一个 &quot;docid &quot;值,系统会自动选择一个。</target>
        </trans-unit>
        <trans-unit id="7ff27a5cb67628299a86678a48c0336fb247a12c" translate="yes" xml:space="preserve">
          <source>The %_stat and %_docsize tables are only created if the FTS table uses the FTS4 module, not FTS3. Furthermore, the %_docsize table is omitted if the FTS4 table is created with the &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;&quot;matchinfo=fts3&quot;&lt;/a&gt; directive specified as part of the CREATE VIRTUAL TABLE statement. If they are created, the schema of the two tables is as follows:</source>
          <target state="translated">仅当FTS表使用FTS4模块而不是FTS3时才创建％_stat和％_docsize表。此外，如果FTS4表是使用在CREATE VIRTUAL TABLE语句中指定的&lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;&amp;ldquo; matchinfo = fts3&amp;rdquo;&lt;/a&gt;指令创建的，则省略％_docsize表。如果创建它们，则两个表的架构如下：</target>
        </trans-unit>
        <trans-unit id="c824e78a5796a4ada97aea7265fbe991ac4b8766" translate="yes" xml:space="preserve">
          <source>The %q and %Q substitutions are SQLite enhancements, not found in most other printf() implementations.</source>
          <target state="translated">%q和%Q的替换是SQLite的增强功能,在大多数其他printf()实现中都没有。</target>
        </trans-unit>
        <trans-unit id="38a9fc3133aa73e0b29b95de437699b671e4c4f6" translate="yes" xml:space="preserve">
          <source>The %s substitution is universal, but the %z substitution is an SQLite enhancement, not found in other printf() implementations.</source>
          <target state="translated">%s的替换是通用的,但%z的替换是SQLite的增强,在其他printf()的实现中没有。</target>
        </trans-unit>
        <trans-unit id="4b87f6c99821c5908fd04958d29e2e7c01fcfa39" translate="yes" xml:space="preserve">
          <source>The %w substitution is an SQLite enhancements, not found in most other printf() implementations.</source>
          <target state="translated">%w替换是SQLite的一个增强功能,在大多数其他printf()实现中都没有。</target>
        </trans-unit>
        <trans-unit id="05ed0c85ed4fa11e23eab78d700cba29a96e54ed" translate="yes" xml:space="preserve">
          <source>The '%' character is used in requirement H35300 to represent the modulo operator, just as it is in programming languages such as C, Java and Javascript.</source>
          <target state="translated">在要求H35300中,'%'字符用来表示模数运算符,就像在C、Java和Javascript等编程语言中一样。</target>
        </trans-unit>
        <trans-unit id="e9354cba92715c3a8151b0bdbb532432be7bdd61" translate="yes" xml:space="preserve">
          <source>The 'crisismerge' option is similar to 'automerge', in that it determines how and how often the component b-trees that make up the full-text index are merged together. Once there exist</source>
          <target state="translated">crisismerge &quot;选项与 &quot;automerge &quot;类似,它决定了构成全文索引的b树组件合并的方式和频率。一旦存在</target>
        </trans-unit>
        <trans-unit id="139c169421eec1791495afdd3b65ecbf6f7f8622" translate="yes" xml:space="preserve">
          <source>The *+* operator on the *x* column will prevent that term from constraining an index. This would force the use of the ex2i2 index.</source>
          <target state="translated">在*x*列上的*+*操作符将阻止该项约束索引。这将强制使用ex2i2索引。</target>
        </trans-unit>
        <trans-unit id="fe65d357eb360ea29fe1d68436790805aab233d0" translate="yes" xml:space="preserve">
          <source>The *pHighwater parameter records the deepest parser stack. The *pCurrent value is undefined. The *pHighwater value is only meaningful if SQLite is compiled with &lt;a href=&quot;../compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt;.</source>
          <target state="translated">* pHighwater参数记录最深的解析器堆栈。* pCurrent值是不确定的。* pHighwater值仅在使用&lt;a href=&quot;../compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt;编译SQLite时才有意义。</target>
        </trans-unit>
        <trans-unit id="c1ea66787615c66d86376977b69791f61618b2a2" translate="yes" xml:space="preserve">
          <source>The *pHighwater parameter records the deepest parser stack. The *pCurrent value is undefined. The *pHighwater value is only meaningful if SQLite is compiled with &lt;a href=&quot;compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt;.</source>
          <target state="translated">* pHighwater参数记录最深的解析器堆栈。* pCurrent值是不确定的。* pHighwater值仅在使用&lt;a href=&quot;compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt;编译SQLite时才有意义。</target>
        </trans-unit>
        <trans-unit id="6a0209d4ffca3af22d05eab8c450129e95986f2c" translate="yes" xml:space="preserve">
          <source>The --blob-api option on the database read test causes kvtest to use the &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; feature of SQLite to load the content of the blobs, rather than running pure SQL statements. This helps SQLite to run a little faster on read tests. You can omit that option to compare the performance of SQLite running SQL statements. In that case, the SQLite still out-performs direct reads, though by not as much as when using &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;. The --blob-api option is ignored for tests that read from individual disk files.</source>
          <target state="translated">数据库读取测试中的--blob-api选项使kvtest使用SQLite 的&lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;功能来加载blob的内容，而不是运行纯SQL语句。这有助于SQLite在读取测试上更快地运行。您可以省略该选项以比较运行SQL语句的SQLite的性能。在那种情况下，尽管与使用&lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read（）相比&lt;/a&gt;，SQLite的性能仍然好于直接读取。从单个磁盘文件读取的测试将忽略--blob-api选项。</target>
        </trans-unit>
        <trans-unit id="aeee09a9fb263d7d0932e1687159faa31b022fff" translate="yes" xml:space="preserve">
          <source>The --deserialize option associated with opening a new database cause the database file to be read into memory and accessed using the &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; API. This simplifies running tests on a database without modifying the file on disk.</source>
          <target state="translated">与打开新数据库关联的--deserialize选项导致将数据库文件读入内存并使用&lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize（）&lt;/a&gt; API 访问。这简化了在数据库上运行测试，而无需修改磁盘上的文件。</target>
        </trans-unit>
        <trans-unit id="ce432c27aa93648ce455d1142365434d4a1eea96" translate="yes" xml:space="preserve">
          <source>The --init option reports an error if the file named as its argument cannot be opened. The --init option also now honors the --bail option.</source>
          <target state="translated">如果作为参数的文件无法打开,-init 选项会报告一个错误。现在,--init选项还支持--bail选项。</target>
        </trans-unit>
        <trans-unit id="11d3b8386b1e3ccb1cc08c05d6ada4438f0769ba" translate="yes" xml:space="preserve">
          <source>The --primarykey flag changes the pairing algorithm slightly so that the schema-declared &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; is always used for pairing, even on tables that have a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;. This is often a better choice for finding differences, however it can lead to missed differences in the case of rows that have one or more PRIMARY KEY columns set to NULL.</source>
          <target state="translated">--primarykey标志会稍微更改配对算法，以便即使在具有&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid的&lt;/a&gt;表上，也始终使用模式声明的&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;进行配对。这通常是查找差异的更好选择，但是在行中将一个或多个PRIMARY KEY列设置为NULL的情况下，可能会导致丢失差异。</target>
        </trans-unit>
        <trans-unit id="5cd46599c902c6e8fdb69c21ede0585852a486b3" translate="yes" xml:space="preserve">
          <source>The --update and --insert commands work like --create command, except that they do not delete the current archive before commencing. New versions of files silently replace existing files with the same names, but otherwise the initial contents of the archive (if any) remain intact.</source>
          <target state="translated">--update和--insert命令的工作原理与--create命令一样,只是在开始之前不删除当前的存档。新版本的文件会默默地用相同的名字替换现有的文件,但除此之外,档案的初始内容(如果有的话)保持不变。</target>
        </trans-unit>
        <trans-unit id="92d15467647a321ed86c3b0d4ddfb73a9334e61d" translate="yes" xml:space="preserve">
          <source>The -ldl library is needed to support dynamic loading, the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface and the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension() SQL function&lt;/a&gt;. If these features are not required, then they can be omitted using &lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt; compile-time option:</source>
          <target state="translated">需要-ldl库来支持动态加载，&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;接口和&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（）SQL函数&lt;/a&gt;。如果不需要这些功能，则可以使用&lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt;编译时选项将其省略：</target>
        </trans-unit>
        <trans-unit id="ff976c7e2e67ea0658ecbf1774cc0a53bba77580" translate="yes" xml:space="preserve">
          <source>The .selftest command reads the rows of the selftest table in selftest.tno order. For each 'memo' row, it writes the text in 'cmd' to the output. For each 'run' row, it runs the 'cmd' text as SQL and compares the result to the value in 'ans', and shows an error message if the results differ.</source>
          <target state="translated">.selftest 命令按照 selftest.tno 的顺序读取 selftest 表的行。对于每一条'备忘录'行,它将'cmd'中的文本写入输出。对于每一条'run'行,它将'cmd'文本作为SQL运行,并将结果与'ans'中的值进行比较,如果结果不同,则显示错误信息。</target>
        </trans-unit>
        <trans-unit id="12dcfb8a7c514a22ec8efe2151085ef4fd8b43ec" translate="yes" xml:space="preserve">
          <source>The 100-byte database file header (found on page 1 only)</source>
          <target state="translated">100字节的数据库文件头(仅在第1页中找到)。</target>
        </trans-unit>
        <trans-unit id="a17caaa0027df54644d9d8d5e0706c4b71db11b0" translate="yes" xml:space="preserve">
          <source>The 100-byte database file header is found only on page 1, which is always a table b-tree page. All other b-tree pages in the database file omit this 100-byte header.</source>
          <target state="translated">100字节的数据库文件头只出现在第1页,它总是表b树页。数据库文件中的所有其他b树页都省略了这100字节的页眉。</target>
        </trans-unit>
        <trans-unit id="3b6884cf3226327e79dce3b07ec790a620af6f29" translate="yes" xml:space="preserve">
          <source>The 12-step &lt;a href=&quot;lang_altertable#otheralter&quot;&gt;generalized ALTER TABLE procedure&lt;/a&gt; above will work even if the schema change causes the information stored in the table to change. So the full 12-step procedure above is appropriate for dropping a column, changing the order of columns, adding or removing a UNIQUE constraint or PRIMARY KEY, adding CHECK or FOREIGN KEY or NOT NULL constraints, or changing the datatype for a column, for example. However, a simpler and faster procedure can optionally be used for some changes that do no affect the on-disk content in any way. The following simpler procedure is appropriate for removing CHECK or FOREIGN KEY or NOT NULL constraints, or adding, removing, or changing default values on a column.</source>
          <target state="translated">即使架构更改导致表中存储的信息发生更改，上面的12个步骤的&lt;a href=&quot;lang_altertable#otheralter&quot;&gt;通用ALTER TABLE过程&lt;/a&gt;也将起作用。因此，上述完整的12个步骤的步骤适用于删除列，更改列的顺序，添加或删除UNIQUE约束或PRIMARY KEY，添加CHECK或FOREIGN KEY或NOT NULL约束或更改列的数据类型，例。但是，可以选择更简单，更快速的过程进行某些更改，这些更改不会以任何方式影响磁盘上的内容。下面的简单过程适用于删除CHECK或FOREIGN KEY或NOT NULL约束，或在列上添加，删除或更改默认值。</target>
        </trans-unit>
        <trans-unit id="2e3276be673e6a294c05cbdaa0d3884fdd5a279f" translate="yes" xml:space="preserve">
          <source>The 1st parameter, &lt;b&gt;context&lt;/b&gt;, is a pointer to an opaque object that describes the content from which the SQL function was invoked. This context point becomes the first parameter to many other routines that the function implement might to invoke, including:</source>
          <target state="translated">第一个参数&lt;b&gt;context&lt;/b&gt;是指向不透明对象的指针，该对象描述了从中调用SQL函数的内容。该上下文点成为函数实现可能调用的许多其他例程的第一个参数，包括：</target>
        </trans-unit>
        <trans-unit id="2e86ab7971614c6f24df9cffe9f9872849aa09c9" translate="yes" xml:space="preserve">
          <source>The 2nd and 3rd arguments to the scalar SQL function implemenetation, &lt;b&gt;argc&lt;/b&gt; and &lt;b&gt;argv&lt;/b&gt;, are the number of arguments to the SQL function itself and the values for each argument of the SQL function. Argument values can be of any datatype and are thus stored in instances of the &lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt; object. Specific C-language values can be extracted from this object using the &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value() family of interfaces&lt;/a&gt;.</source>
          <target state="translated">标量SQL函数实现的第二个和第三个参数&lt;b&gt;argc&lt;/b&gt;和&lt;b&gt;argv&lt;/b&gt;是SQL函数本身的参数数量以及SQL函数每个参数的值。参数值可以是任何数据类型，因此存储在&lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt;对象的实例中。可以使用&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value（）系列接口&lt;/a&gt;从此对象中提取特定的C语言值。</target>
        </trans-unit>
        <trans-unit id="3229fe36f5dbdb9bc16916270b8799663f2b4b3a" translate="yes" xml:space="preserve">
          <source>The 2nd argument to the sqlite3_exec() callback function is the number of columns in the result. The 3rd argument to the sqlite3_exec() callback is an array of pointers to strings obtained as if from &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, one for each column. If an element of a result row is NULL then the corresponding string pointer for the sqlite3_exec() callback is a NULL pointer. The 4th argument to the sqlite3_exec() callback is an array of pointers to strings where each entry represents the name of corresponding result column as obtained from &lt;a href=&quot;#sqlite3_column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_exec（）回调函数的第二个参数是结果中的列数。sqlite3_exec（）回调的第三个参数是一个数组指针，该数组指向从&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text（）&lt;/a&gt;获得的字符串，每列一个。如果结果行的元素为NULL，则sqlite3_exec（）回调的相应字符串指针为NULL指针。sqlite3_exec（）回调的第4个参数是一个指向字符串的指针数组，其中每个条目表示从&lt;a href=&quot;#sqlite3_column_name&quot;&gt;sqlite3_column_name（）&lt;/a&gt;获得的相应结果列的名称。</target>
        </trans-unit>
        <trans-unit id="f8004ad0fbc670903554e47567c2e9bf84a736bf" translate="yes" xml:space="preserve">
          <source>The 2nd argument to the sqlite3_exec() callback function is the number of columns in the result. The 3rd argument to the sqlite3_exec() callback is an array of pointers to strings obtained as if from &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, one for each column. If an element of a result row is NULL then the corresponding string pointer for the sqlite3_exec() callback is a NULL pointer. The 4th argument to the sqlite3_exec() callback is an array of pointers to strings where each entry represents the name of corresponding result column as obtained from &lt;a href=&quot;column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_exec（）回调函数的第二个参数是结果中的列数。sqlite3_exec（）回调的第三个参数是一个数组指针，该数组指向从&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text（）&lt;/a&gt;获得的字符串，每列一个。如果结果行的元素为NULL，则sqlite3_exec（）回调的相应字符串指针为NULL指针。sqlite3_exec（）回调的第4个参数是一个指向字符串的指针数组，其中每个条目表示从&lt;a href=&quot;column_name&quot;&gt;sqlite3_column_name（）&lt;/a&gt;获得的相应结果列的名称。</target>
        </trans-unit>
        <trans-unit id="1fbe9436fd9db92826bf0f5761a30ba124b84870" translate="yes" xml:space="preserve">
          <source>The 31 result codes are &lt;a href=&quot;c3ref/c_abort&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="translated">31个结果代码&lt;a href=&quot;c3ref/c_abort&quot;&gt;在sqlite3.h&lt;/a&gt;中定义，并按字母顺序列出如下：</target>
        </trans-unit>
        <trans-unit id="de71717ad00d5c6da7753059b7611f9841b1d459" translate="yes" xml:space="preserve">
          <source>The 32-bit integer value P1 is written into register P2.</source>
          <target state="translated">32位整数值P1被写入寄存器P2中。</target>
        </trans-unit>
        <trans-unit id="0fa6dc01b797fc02e2f48692d3a39f9204d77ab0" translate="yes" xml:space="preserve">
          <source>The 32-bit unsigned integer at offset 128 in the WAL-index header is called the &quot;nBackfill&quot;. this field holds the number of frames in the WAL file which have been copied back into the main database.</source>
          <target state="translated">WAL-index头中偏移量128处的32位无符号整数称为 &quot;nBackfill&quot;,该字段保存了WAL文件中被复制回主数据库的帧数。</target>
        </trans-unit>
        <trans-unit id="e3de01c332227a39275dbc5888bb606fa2949671" translate="yes" xml:space="preserve">
          <source>The 32-bit unsigned integer at offset 16 (and repeated at offset 64) is the number of valid frames in the WAL. Because WAL frame are numbered starting with 1, mxFrame is also the index of the last valid commit frame in the WAL. A commit frame is a frame that has a non-zero &quot;size of database&quot; value in bytes 4 through 7 of the frame header, and that indicates the end of a transaction.</source>
          <target state="translated">偏移量16的32位无符号整数(在偏移量64处重复)是WAL中有效帧的数量,由于WAL帧是以1开始编号的,所以mxFrame也是WAL中最后一个有效提交帧的索引。因为WAL帧是从1开始编号的,所以mxFrame也是WAL中最后一个有效提交帧的索引。提交帧是指帧头字节4到7中 &quot;数据库大小 &quot;值为非零的帧,它表示一个事务的结束。</target>
        </trans-unit>
        <trans-unit id="ae0f85b04e7fa9cc6d6fac1b8bbc475f7f896833" translate="yes" xml:space="preserve">
          <source>The 35% figure is based on running tests on every machine that the author has easily at hand. Some reviewers of this article report that SQLite has higher latency than direct I/O on their systems. We do not yet understand the difference. We also see indications that SQLite does not perform as well as direct I/O when experiments are run using a cold filesystem cache.</source>
          <target state="translated">35%这个数字是基于在笔者手头容易掌握的每一台机器上运行测试得出的。本文的一些审稿人报告说,在他们的系统上,SQLite的延迟比直接I/O高。我们还不明白其中的区别。我们还看到有迹象表明,当使用冷文件系统缓存运行实验时,SQLite的性能不如直接I/O。</target>
        </trans-unit>
        <trans-unit id="99484295a38d44d61a5164088be45dfe447bd6fb" translate="yes" xml:space="preserve">
          <source>The 3rd parameter of the built-in SUBSTR() function is now optional.</source>
          <target state="translated">内置SUBSTR()函数的第3个参数现在是可选的。</target>
        </trans-unit>
        <trans-unit id="b03a25a4d8213505aa58b43a2a9ec61a89d8bd66" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 28 into the header stores the size of the database file in pages. If this in-header datasize size is not valid (see the next paragraph), then the database size is computed by looking at the actual size of the database file. Older versions of SQLite ignored the in-header database size and used the actual file size exclusively. Newer versions of SQLite use the in-header database size if it is available but fall back to the actual file size if the in-header database size is not valid.</source>
          <target state="translated">头部偏移量28处的4字节大字节整数以页为单位存储数据库文件的大小。如果头中的数据大小无效(见下一段),那么数据库大小是通过查看数据库文件的实际大小来计算的。旧版本的SQLite忽略了头内数据库大小,只使用实际文件大小。较新版本的SQLite在有头数据库大小的情况下会使用头数据库大小,但如果头数据库大小无效,则会回到实际文件大小。</target>
        </trans-unit>
        <trans-unit id="ef2a0b06932c2dcd259f9b038635b5911a22f5bb" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 56 determines the encoding used for all text strings stored in the database. A value of 1 means UTF-8. A value of 2 means UTF-16le. A value of 3 means UTF-16be. No other values are allowed. The sqlite3.h header file defines C-preprocessor macros SQLITE_UTF8 as 1, SQLITE_UTF16LE as 2, and SQLITE_UTF16BE as 3, to use in place of the numeric codes for the text encoding.</source>
          <target state="translated">偏移量56处的4字节大字节整数,决定了数据库中存储的所有文本字符串的编码。值为1表示UTF-8,值为2表示UTF-16le。值为2表示UTF-16le,值为3表示UTF-16be。值为3表示UTF-16be。不允许使用其他值。sqlite3.h头文件定义了C-预处理程序宏SQLITE_UTF8为1,SQLITE_UTF16LE为2,SQLITE_UTF16BE为3,用来代替文本编码的数字代码。</target>
        </trans-unit>
        <trans-unit id="59780a9139eaaa69dc8ff8373215df2d27399d4a" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 60 is the user version which is set and queried by the &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma&lt;/a&gt;. The user version is not used by SQLite.</source>
          <target state="translated">偏移量60处的4字节big-endian整数是用户版本，由&lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma&lt;/a&gt;设置和查询。SQLite不使用用户版本。</target>
        </trans-unit>
        <trans-unit id="b59b6e739385a58f0bfd59ff19b74ae1c97b3ca9" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 68 is an &quot;Application ID&quot; that can be set by the &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; command in order to identify the database as belonging to or associated with a particular application. The application ID is intended for database files used as an &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;. The application ID can be used by utilities such as &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file(1)&lt;/a&gt; to determine the specific file type rather than just reporting &quot;SQLite3 Database&quot;. A list of assigned application IDs can be seen by consulting the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt; file in the SQLite source repository.</source>
          <target state="translated">偏移量68处的4字节大尾数整数是&amp;ldquo;应用程序ID&amp;rdquo;，可以通过&lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt;命令设置该命令，以将数据库标识为属于特定应用程序或与特定应用程序相关联。该应用程序ID用于用作&lt;a href=&quot;appfileformat&quot;&gt;应用程序文件格式的&lt;/a&gt;数据库文件。诸如&lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file（1）之&lt;/a&gt;类的实用程序可以使用该应用程序ID 来确定特定的文件类型，而不仅仅是报告&amp;ldquo; SQLite3数据库&amp;rdquo;。通过查询SQLite源存储库中的&lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt;文件，可以看到已分配的应用程序ID的列表。</target>
        </trans-unit>
        <trans-unit id="38784fbab26020d518650e3bc21dc48be395b9c0" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 68 is an &quot;Application ID&quot; that can be set by the &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; command in order to identify the database as belonging to or associated with a particular application. The application ID is intended for database files used as an &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;. The application ID can be used by utilities such as &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file(1)&lt;/a&gt; to determine the specific file type rather than just reporting &quot;SQLite3 Database&quot;. A list of assigned application IDs can be seen by consulting the &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt; file in the SQLite source repository.</source>
          <target state="translated">偏移量68处的4字节大尾数整数是&amp;ldquo;应用程序ID&amp;rdquo;，可以通过&lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt;命令设置该命令，以将数据库标识为属于特定应用程序或与特定应用程序相关联。该应用程序ID用于用作&lt;a href=&quot;appfileformat&quot;&gt;应用程序文件格式的&lt;/a&gt;数据库文件。诸如&lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file（1）之&lt;/a&gt;类的实用程序可以使用该应用程序ID来确定特定的文件类型，而不仅仅是报告&amp;ldquo; SQLite3数据库&amp;rdquo;。通过查询SQLite源存储库中的&lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt;文件，可以看到已分配的应用程序ID的列表。</target>
        </trans-unit>
        <trans-unit id="07f0a53720eada7bca96ab5b1af017ecee35257f" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 96 stores the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; value for the SQLite library that most recently modified the database file. The 4-byte big-endian integer at offset 92 is the value of the &lt;a href=&quot;fileformat2#chngctr&quot;&gt;change counter&lt;/a&gt; when the version number was stored. The integer at offset 92 indicates which transaction the version number is valid for and is sometimes called the &quot;version-valid-for number&quot;.</source>
          <target state="translated">偏移量为96的4字节big-endian整数存储最近修改数据库文件的SQLite库的&lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;值。偏移量92处的4字节大尾数整数是存储版本号时&lt;a href=&quot;fileformat2#chngctr&quot;&gt;更改计数器&lt;/a&gt;的值。偏移量92处的整数表示版本号对哪个交易有效，有时称为&amp;ldquo;版本有效号&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b2d1137ce6ac9536674089958f7183c5cef074dd" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian signed integer at offset 48 is the suggested cache size in pages for the database file. The value is a suggestion only and SQLite is under no obligation to honor it. The absolute value of the integer is used as the suggested size. The suggested cache size can be set using the &lt;a href=&quot;pragma#pragma_default_cache_size&quot;&gt;default_cache_size pragma&lt;/a&gt;.</source>
          <target state="translated">偏移量48处的4字节big-endian带符号整数是数据库文件在页面中建议的高速缓存大小。该值仅是一个建议，SQLite没有义务兑现它。整数的绝对值用作建议的大小。可以使用&lt;a href=&quot;pragma#pragma_default_cache_size&quot;&gt;default_cache_size pragma&lt;/a&gt;设置建议的缓存大小。</target>
        </trans-unit>
        <trans-unit id="53d2cb69bc07058d95cd55a2bf0ace6be99d3312" translate="yes" xml:space="preserve">
          <source>The 4th parameter as more recently be extended with additional flag bits to convey additional information about the function. The additional bits include:</source>
          <target state="translated">第4个参数最近被扩展为附加的标志位,以传递有关函数的附加信息。额外的位包括:</target>
        </trans-unit>
        <trans-unit id="4a28f7f4f27954a38f3fd9a37598b5ec1312b94e" translate="yes" xml:space="preserve">
          <source>The 61 extended result codes are &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;在sqlite3.h&lt;/a&gt;中定义了61个扩展结果代码，并按字母顺序在下面列出：</target>
        </trans-unit>
        <trans-unit id="297d64bcfea641daf22ef24136ed89bff8802a91" translate="yes" xml:space="preserve">
          <source>The 71 extended result codes are &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="translated">71个扩展结果代码&lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;在sqlite3.h&lt;/a&gt;中定义，并按字母顺序在下面列出：</target>
        </trans-unit>
        <trans-unit id="7632ae3463f74e8bc40ebd99c8e14ebcad0e1acf" translate="yes" xml:space="preserve">
          <source>The 8 or 12 byte b-tree page header</source>
          <target state="translated">8个或12个字节的b-tree页面头。</target>
        </trans-unit>
        <trans-unit id="f5b2d0b06ac8eecacdf1f9fc8ceb4463be132806" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; flag means the file should be deleted when it is closed. The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; will be set for TEMP databases and their journals, transient databases, and subjournals.</source>
          <target state="translated">该&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt;标志意味着当它关闭该文件应予删除。该&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt;将为TEMP数据库及其期刊，短暂的数据库，并subjournals进行设置。</target>
        </trans-unit>
        <trans-unit id="113a719d1e8937c17801bea84f7fbfbe80a9d62b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; flag is always used in conjunction with the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; flag, which are both directly analogous to the O_EXCL and O_CREAT flags of the POSIX open() API. The SQLITE_OPEN_EXCLUSIVE flag, when paired with the SQLITE_OPEN_CREATE, is used to indicate that file should always be created, and that it is an error if it already exists. It is</source>
          <target state="translated">所述&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt;标志总是与一起使用&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;标志，这两者都是直接类似于POSIX打开（）API的O_EXCL和O_CREAT标志。当与SQLITE_OPEN_CREATE配对使用时，SQLITE_OPEN_EXCLUSIVE标志用于指示应始终创建文件，如果该文件已经存在则为错误。它是</target>
        </trans-unit>
        <trans-unit id="81aa4d01093839a3328717a25027872953f919a8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; C preprocessor macro in the sqlite3.h header evaluates to a string literal that is the SQLite version in the format &quot;X.Y.Z&quot; where X is the major version number (always 3 for SQLite3) and Y is the minor version number and Z is the release number. The &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; C preprocessor macro resolves to an integer with the value (X*1000000 + Y*1000 + Z) where X, Y, and Z are the same numbers used in &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;. The SQLITE_VERSION_NUMBER for any given release of SQLite will also be larger than the release from which it is derived. Either Y will be held constant and Z will be incremented or else Y will be incremented and Z will be reset to zero.</source>
          <target state="translated">sqlite3.h标头中的&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; C预处理程序宏求值为字符串文字，该字符串文字是格式为&amp;ldquo; XYZ&amp;rdquo;的SQLite版本，其中X为主要版本号（对于SQLite3始终为3），Y为次要版本号，Z为发布编号。所述&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; C预处理宏解析为一个整数，其值为（X * 1000000 + Y * 1000 + Z），其中X，Y，和Z是在所使用的相同的数字&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;。任何给定版本的SQLite的SQLITE_VERSION_NUMBER也将大于其派生版本。 Y将保持不变，Z将递增，否则Y将递增，Z将重置为零。</target>
        </trans-unit>
        <trans-unit id="f3c03446112462ee2b9d55caa1b76200b09c27b3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#dbsqlfuzz&quot;&gt;&lt;b&gt;dbsqlfuzz&lt;/b&gt;&lt;/a&gt; engine is a proprietary fuzz tester. Other &lt;a href=&quot;testing#fuzztesting&quot;&gt;fuzzers for SQLite&lt;/a&gt; mutate either the SQL inputs or the database file. Dbsqlfuzz mutates both the SQL and the database file at the same time, and is thus able to reach new error states. Dbsqlfuzz is built using the &lt;a href=&quot;http://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt; framework of LLVM with a custom mutator. Starting from 236 seed files, the dbsqlfuzz fuzzer has examined many tens of millions of mutations, resulting in 63493 distinct test cases that form the basis of each new fuzzing session. Dbsqlfuzz helps ensure that SQLite is robust against attack via malicious SQL or database inputs.</source>
          <target state="translated">该&lt;a href=&quot;#dbsqlfuzz&quot;&gt;&lt;b&gt;dbsqlfuzz&lt;/b&gt;&lt;/a&gt;引擎是一种专有的模糊测试。&lt;a href=&quot;testing#fuzztesting&quot;&gt;SQLite的&lt;/a&gt;其他模糊器会更改SQL输入或数据库文件。Dbsqlfuzz同时更改SQL和数据库文件，因此能够达到新的错误状态。Dbsqlfuzz是使用LLVM的&lt;a href=&quot;http://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt;框架和自定义变量构建的。从236个种子文件开始，dbsqlfuzz模糊测试器已经检查了数千万个突变，从而产生了63493个不同的测试用例，这些测试用例构成了每个新的模糊测试会话的基础。Dbsqlfuzz帮助确保SQLite具有强大的抵御恶意SQL或数据库输入的攻击的能力。</target>
        </trans-unit>
        <trans-unit id="bd9c9b7b18b9277de9026053f84f4ad8b81cc8b1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#dbsqlfuzz&quot;&gt;&lt;b&gt;dbsqlfuzz&lt;/b&gt;&lt;/a&gt; engine is a proprietary fuzz tester. Other &lt;a href=&quot;testing#fuzztesting&quot;&gt;fuzzers for SQLite&lt;/a&gt; mutate either the SQL inputs or the database file. Dbsqlfuzz mutates both the SQL and the database file at the same time, and is thus able to reach new error states. Dbsqlfuzz is built using the &lt;a href=&quot;https://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt; framework of LLVM with a custom mutator. Starting from 236 seed files, the dbsqlfuzz fuzzer has examined many tens of millions of mutations, resulting in 63493 distinct test cases that form the basis of each new fuzzing session. Dbsqlfuzz helps ensure that SQLite is robust against attack via malicious SQL or database inputs.</source>
          <target state="translated">该&lt;a href=&quot;#dbsqlfuzz&quot;&gt;&lt;b&gt;dbsqlfuzz&lt;/b&gt;&lt;/a&gt;引擎是一种专有的模糊测试。&lt;a href=&quot;testing#fuzztesting&quot;&gt;SQLite的&lt;/a&gt;其他模糊器会更改SQL输入或数据库文件。Dbsqlfuzz同时更改SQL和数据库文件，因此能够达到新的错误状态。Dbsqlfuzz是使用LLVM的&lt;a href=&quot;https://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt;框架和自定义变量构建的。从236个种子文件开始，dbsqlfuzz模糊测试器已经检查了数千万个突变，从而产生了63493个不同的测试用例，这些测试用例构成了每个新的模糊测试会话的基础。Dbsqlfuzz帮助确保SQLite具有强大的抵御恶意SQL或数据库输入的攻击的能力。</target>
        </trans-unit>
        <trans-unit id="f1c75916c07cfb8eae73aa66b68a34bf29c22777" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; pointer D in a call to &lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt(D,S)&lt;/a&gt; must refer to an open database connection and in particular must not be a NULL pointer.</source>
          <target state="translated">调用&lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt（D，S）时&lt;/a&gt;的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;指针D 必须引用打开的数据库连接，并且尤其不能为NULL指针。</target>
        </trans-unit>
        <trans-unit id="5bf64bb75c15b60e54d733e7fb04737bfbdcc130" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object itself is partially threadsafe. Multiple threads may safely make multiple concurrent calls to sqlite3_backup_step(). However, the sqlite3_backup_remaining() and sqlite3_backup_pagecount() APIs are not strictly speaking threadsafe. If they are invoked at the same time as another thread is invoking sqlite3_backup_step() it is possible that they return invalid values.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象本身是部分线程。多个线程可以安全地同时调用sqlite3_backup_step（）。但是，严格说来，sqlite3_backup_remaining（）和sqlite3_backup_pagecount（）API并不是线程安全的。如果在另一个线程调用sqlite3_backup_step（）的同时调用它们，则可能返回无效值。</target>
        </trans-unit>
        <trans-unit id="7b899c2433d199dbb7815bdf0ba2afb729910cf1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_zeroblob()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_zeroblob()&lt;/a&gt; interfaces and the built-in &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; SQL function may be used to create a zero-filled blob to read or write using the incremental-blob interface.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_zeroblob（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_zeroblob（）&lt;/a&gt;接口和内置在&lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; SQL函数可以被用来创建一个零填充的斑点使用增量-Blob接口来读取或写入。</target>
        </trans-unit>
        <trans-unit id="243b1f5a94daea2d7cb3ce8a6e46d2fc0337bddb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; interface unregisters the initialization routine X that was registered using a prior call to &lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension(X)&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; routine returns 1 if initialization routine X was successfully unregistered and it returns 0 if X was not on the list of initialization routines.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension（X）&lt;/a&gt;接口注销这是使用于现有呼叫登记的初始化例程X &lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension（X） &lt;/a&gt;。该&lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension（X）&lt;/a&gt;例程返回1，如果初始化程序X是成功注销，并将其返回0，如果X不是初始化程序的列表中。</target>
        </trans-unit>
        <trans-unit id="4d9c76fa5b1b1ce93415a995c6d4d84ffeb6d357" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;, ...) interface can register an alternative page cache implementation by passing in an instance of the sqlite3_pcache_methods2 structure. In many applications, most of the heap memory allocated by SQLite is used for the page cache. By implementing a custom page cache using this API, an application can better control the amount of memory consumed by SQLite, the way in which that memory is allocated and released, and the policies used to determine exactly which parts of a database file are cached and for how long.</source>
          <target state="translated">该&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;，...）接口可以通过传递sqlite3_pcache_methods2结构的一个实例注册一个替代页面缓存实现。在许多应用程序中，SQLite分配的大部分堆内存都用于页面缓存。通过使用此API实现自定义页面缓存，应用程序可以更好地控制SQLite消耗的内存量，分配和释放该内存的方式，以及用于确切确定要缓存数据库文件的哪些部分的策略以及多长时间。</target>
        </trans-unit>
        <trans-unit id="5d45a04d8212fde9c0874120a3960331ca779f2b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface makes a direct call to the xFileControl method for the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object associated with a particular database identified by the second argument. The name of the database is &quot;main&quot; for the main database or &quot;temp&quot; for the TEMP database, or the name that appears after the AS keyword for databases that are added using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL command. A NULL pointer can be used in place of &quot;main&quot; to refer to the main database file. The third and fourth parameters to this routine are passed directly through to the second and third parameters of the xFileControl method. The return value of the xFileControl method becomes the return value of this routine.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;接口使得所述xFileControl方法的直接调用&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象与由第二个参数识别一个特定的数据库相关联。对于主数据库，数据库名称为&amp;ldquo; main&amp;rdquo;，对于TEMP数据库，数据库名称为&amp;ldquo; temp&amp;rdquo;，对于使用&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL命令添加的数据库，名称为AS关键字之后。可以使用NULL指针代替&amp;ldquo; main&amp;rdquo;来引用主数据库文件。此例程的第三和第四参数直接传递给xFileControl方法的第二和第三参数。 xFileControl方法的返回值成为该例程的返回值。</target>
        </trans-unit>
        <trans-unit id="1190e60391b896900656c0ed0c45b80a24b61942" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of rows examined by all iterations of the X-th loop.</source>
          <target state="translated">T参数指向的&lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt;变量将设置为第X次循环的所有迭代检查的总行数。</target>
        </trans-unit>
        <trans-unit id="68df0918aa353458edcd2a2adfa1d6ea97cffd5f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of times that the X-th loop has run.</source>
          <target state="translated">由T参数指向的&lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt;变量将设置为第X个循环运行的总次数。</target>
        </trans-unit>
        <trans-unit id="a4d4c03ef6c7fed4df5e7b2b60cea13e3845bb99" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the V parameter will be set to the total number of rows examined by all iterations of the X-th loop.</source>
          <target state="translated">V参数指向的&lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt;变量将设置为第X次循环的所有迭代检查的总行数。</target>
        </trans-unit>
        <trans-unit id="950c7d09e714f7025b91b049ed110aaf3de8d496" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the V parameter will be set to the total number of times that the X-th loop has run.</source>
          <target state="translated">V参数指向的&lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt;变量将设置为第X个循环运行的总次数。</target>
        </trans-unit>
        <trans-unit id="5e18bfb46029f881a46fabedb7acfaf5c4cc5dda" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; interface writes a message into the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; established by the &lt;a href=&quot;#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; option to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt;. If logging is enabled, the zFormat string and subsequent arguments are used with &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to generate the final output string.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log（）&lt;/a&gt;接口将消息写入到&lt;a href=&quot;errlog&quot;&gt;错误日志&lt;/a&gt;由既定&lt;a href=&quot;#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt;选项&lt;a href=&quot;#sqlite3_config&quot;&gt;（）sqlite3_config&lt;/a&gt;。如果启用了日志记录，则zFormat字符串和后续参数与&lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;一起使用以生成最终输出字符串。</target>
        </trans-unit>
        <trans-unit id="a8d3a9c5e86973d6925c26336eb4b86036d70cb6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; routine returns the number of bytes of memory currently outstanding (malloced but not freed). The &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; routine returns the maximum value of &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; since the high-water mark was last reset. The values returned by &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; include any overhead added by SQLite in its implementation of &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, but not overhead added by the any underlying system library routines that &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; may call.</source>
          <target state="translated">该&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;例程返回字节的内存目前优秀（malloced但不释放）的数量。该&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;例程返回的最大值&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;以来的高水位标记最后复位。&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;返回的值包括SQLite在实现&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）时&lt;/a&gt;添加的任何开销，但不包括&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;可能调用的任何基础系统库例程添加的开销。</target>
        </trans-unit>
        <trans-unit id="dc30f41b86e312b265eb4e71d4d9a6acf99b0d1b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt; interface takes a single argument which is one of these integer constants.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc（）&lt;/a&gt;接口采用单个参数，它是这些整数常数之一。</target>
        </trans-unit>
        <trans-unit id="895178f8a3d57626d41012b259bf092ebaa065ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count(D)&lt;/a&gt; interface returns the number of columns in the row that is being inserted, updated, or deleted.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count（d）&lt;/a&gt;接口返回正在被插入，更新或删除的行中的列数。</target>
        </trans-unit>
        <trans-unit id="92f98e455bc2921056f5d6b0ffb541ab9df1ffaf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth(D)&lt;/a&gt; interface returns 0 if the preupdate callback was invoked as a result of a direct insert, update, or delete operation; or 1 for inserts, updates, or deletes invoked by top-level triggers; or 2 for changes resulting from triggers called by top-level triggers; and so forth.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth（d）&lt;/a&gt;接口返回0，如果更新前的回调被调用作为直接插入，更新或删除操作的结果; 或1表示由顶级触发器调用的插入，更新或删除；或2表示由顶级触发器调用的触发器引起的更改；等等。</target>
        </trans-unit>
        <trans-unit id="e08d4a7c0ce7457f9dab2dfa8af96af8deafb79d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; interface registers a callback function that is invoked prior to each &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operation on a database table. At most one preupdate hook may be registered at a time on a single &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;; each call to &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; overrides the previous setting. The preupdate hook is disabled by invoking &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; with a NULL pointer as the second parameter. The third parameter to &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; is passed through as the first parameter to callbacks.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook（）&lt;/a&gt;接口寄存器，每当之前调用的回调函数&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;，&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;，和&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;上的数据库表的操作。在一个&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;上一次最多可以注册一个preupdate挂钩;每次调用&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook（）都会&lt;/a&gt;覆盖先前的设置。通过使用带有NULL指针作为第二个参数的&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook（）&lt;/a&gt;来禁用preupdate挂钩。&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook（）&lt;/a&gt;的第三个参数作为第一个参数传递给回调。</target>
        </trans-unit>
        <trans-unit id="76ad44c525d8f71caf7bed2b7e946c3d8c4e4d51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row after it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_INSERT and SQLITE_UPDATE preupdate callbacks; if it is used by an SQLITE_DELETE callback then the behavior is undefined. The &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new（d，N，P）&lt;/a&gt;接口写为P指针的&lt;a href=&quot;#sqlite3_value&quot;&gt;保护sqlite3_value&lt;/a&gt;包含表行的第N列的值被更新后。 N参数必须比列数少0到1之间，否则行为将是不确定的。只能在SQLITE_INSERT和SQLITE_UPDATE预更新回调中使用；如果它由SQLITE_DELETE回调使用，则该行为未定义。当preupdate回调返回时，P指向的&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;将被销毁。</target>
        </trans-unit>
        <trans-unit id="1c708fa87b4305f6c6c7b152f77487e32500d735" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth()&lt;/a&gt; interfaces provide additional information about a preupdate event. These routines may only be called from within a preupdate callback. Invoking any of these routines from outside of a preupdate callback or with a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; pointer that is different from the one supplied to the preupdate callback results in undefined and probably undesirable behavior.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old（） &lt;/a&gt;，&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new（） &lt;/a&gt;，&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count（） &lt;/a&gt;，和&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth（）&lt;/a&gt;接口提供关于更新前的事件的其他信息。这些例程只能在更新前的回调中调用。从预更新回调之外或使用与提供给预更新回调的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;指针不同的数据库连接指针来调用这些例程中的任何一个都会导致未定义的行为，并且可能是不良行为。</target>
        </trans-unit>
        <trans-unit id="62645acd92fc3d494d833d1a2acf99fc550b25a1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row before it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_UPDATE and SQLITE_DELETE preupdate callbacks; if it is used by an SQLITE_INSERT callback then the behavior is undefined. The &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old（d，N，P）&lt;/a&gt;接口写为P指针的&lt;a href=&quot;#sqlite3_value&quot;&gt;保护sqlite3_value&lt;/a&gt;包含表行的第N列的值被更新之前。N参数必须比列数少0到1之间，否则行为将是不确定的。只能在SQLITE_UPDATE和SQLITE_DELETE预更新回调中使用；如果它由SQLITE_INSERT回调使用，则该行为是未定义的。当preupdate回调返回时，P指向的&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;将被销毁。</target>
        </trans-unit>
        <trans-unit id="73b2a32ae166fcb0b54e0a6a66b0c37e428124e0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface does not change the values of any &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; on the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（S）&lt;/a&gt;接口不改变任何的值&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;绑定&lt;/a&gt;在&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备的语句&lt;/a&gt; S.</target>
        </trans-unit>
        <trans-unit id="24aaeaf525c4a02afa566b3b6fde01711f410b96" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface resets the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S back to the beginning of its program.</source>
          <target state="translated">该&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（S）&lt;/a&gt;接口重置&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的声明&lt;/a&gt; S回其计划的开始。</target>
        </trans-unit>
        <trans-unit id="5ec7f66ae2478b5bf1fba7004c6f9eca0c47bbe3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;authorizer callback function&lt;/a&gt; must return either &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; or one of these two constants in order to signal SQLite whether or not the action is permitted. See the &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;authorizer documentation&lt;/a&gt; for additional information.</source>
          <target state="translated">该&lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;授权回调函数&lt;/a&gt;必须返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;以信号SQLite的动作是否被允许或这两个常量之一。有关其他信息，请参见&lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;授权者文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="de889cb07b2c7dd83d04327e082d9b8afd75421b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface registers a callback function that is invoked to authorize certain SQL statement actions. The second parameter to the callback is an integer code that specifies what action is being authorized. These are the integer action codes that the authorizer callback may be passed.</source>
          <target state="translated">该&lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;接口寄存器被调用以授权某些SQL语句操作的回调函数。回调的第二个参数是整数代码，用于指定要授权的操作。这些是授权者回调可以传递的整数操作代码。</target>
        </trans-unit>
        <trans-unit id="b20fbf1dd1eb586565d476c6ea4477e75271549a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object returned from a successful call to &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; must be freed using &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; to avoid a memory leak.</source>
          <target state="translated">成功调用&lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get（）&lt;/a&gt;返回的&lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt;对象必须使用&lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free（）&lt;/a&gt;释放，以避免内存泄漏。</target>
        </trans-unit>
        <trans-unit id="775754ed627fe2a2cc8e3c07dc04d7c2771ef634" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; interface is only available when the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free（）&lt;/a&gt;的接口时仅可&lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt;用于编译时选择。</target>
        </trans-unit>
        <trans-unit id="14be7fcf3129f0807a23ee14219023eee52d1a02" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free(P)&lt;/a&gt; interface destroys &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; P. The application must eventually free every &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object using this routine to avoid a memory leak.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free（P）&lt;/a&gt;接口破阵&lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; P.应用程序必须最终释放每&lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt;使用此程序以避免内存泄漏对象。</target>
        </trans-unit>
        <trans-unit id="3c246e9ef7aa9d8e18a838b47761936cd8a2acc5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; interface is only available when the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get（）&lt;/a&gt;的接口时仅可&lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt;用于编译时选择。</target>
        </trans-unit>
        <trans-unit id="2146a577e5e49a77b490e29aca2d82e371ec702c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface attempts to make a new &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object that records the current state of schema S in database connection D. On success, the &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface writes a pointer to the newly created &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object into *P and returns SQLITE_OK. If there is not already a read-transaction open on schema S when this function is called, one is opened automatically.</source>
          <target state="translated">该&lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get（d，S，P）&lt;/a&gt;接口尝试建立一个新&lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt;对象，记录模式S的数据库连接D.如果成功了当前的状态，&lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get（d，S，P）&lt;/a&gt;接口写入指针到新创建的&lt;a href=&quot;#sqlite3_snapshot&quot;&gt;将sqlite3_snapshot&lt;/a&gt;对象转换为* P并返回SQLITE_OK。如果在调用此函数时在模式S上尚未打开读取事务，则会自动打开该事务。</target>
        </trans-unit>
        <trans-unit id="efd7fc3c3c9a64e738f23c02f6e6fbe25f03ae8e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface is only available when the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;的接口时仅可&lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt;用于编译时选择。</target>
        </trans-unit>
        <trans-unit id="b4e3c98131317b43afc18d358e2869af93b46671" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; interface either starts a new read transaction or upgrades an existing one for schema S of &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D such that the read transaction refers to historical &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;snapshot&lt;/a&gt; P, rather than the most recent change to the database. The &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface returns SQLITE_OK on success or an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if it fails.</source>
          <target state="translated">该&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open（d，S，P）&lt;/a&gt;接口或者开始一个新的读事务或升级现有的架构的小号&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; d使得读事务是指历史&lt;a href=&quot;#sqlite3_snapshot&quot;&gt;快照&lt;/a&gt; P，而不是最近的更改到数据库。所述&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;接口返回成功或适当SQLITE_OK &lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;，如果它失败。</target>
        </trans-unit>
        <trans-unit id="83d565fd5c1ee3cccc1b5c10ce8ef575521cca40" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_append(X,S,N)&lt;/a&gt; method appends exactly N bytes from string S onto the end of the &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X. N must be non-negative. S must contain at least N non-zero bytes of content. To append a zero-terminated string in its entirety, use the &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall()&lt;/a&gt; method instead.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_append（X，S，N）&lt;/a&gt;方法附加恰好从串S N字节到的端&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;对象X. N必须是非负的。S必须包含至少N个非零字节的内容。要完整地附加一个以零结尾的字符串，请改用&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall（）&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="6917c29880e6eab55b32466b3048653ea9692486" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall(X,S)&lt;/a&gt; method appends the complete content of zero-terminated string S onto the end of &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall（X，S）&lt;/a&gt;方法附加零终止的字符串S的完整内容到的端&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;对象X.</target>
        </trans-unit>
        <trans-unit id="8658941f24fcaee032cb73b6958282aac488a0c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendchar(X,N,C)&lt;/a&gt; method appends N copies of the single-byte character C onto the end of &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X. This method can be used, for example, to add whitespace indentation.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendchar（X，N，C）&lt;/a&gt;方法追加单字节字符的C N份到的端&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;对象X.，可以使用此方法，例如，添加空格缩进。</target>
        </trans-unit>
        <trans-unit id="5cf4ff61e78e32620c83211a0d5e1e3795abc7df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendf(X,F,...)&lt;/a&gt; and &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_vappendf(X,F,V)&lt;/a&gt; interfaces uses the &lt;a href=&quot;printf&quot;&gt;built-in printf&lt;/a&gt; functionality of SQLite to append formatted text onto the end of &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendf（X，F，...）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_vappendf（X，F，V）&lt;/a&gt;接口使用&lt;a href=&quot;printf&quot;&gt;内置的printf&lt;/a&gt;的SQLite的功能来格式化文本追加到的末尾&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;对象X.</target>
        </trans-unit>
        <trans-unit id="efc22c6c47d48b515ed10c7b3b7ca6cc54142437" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_reset(X)&lt;/a&gt; method resets the string under construction inside &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X back to zero bytes in length.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_reset（X）&lt;/a&gt;方法重置在建字符串里面&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;长度对象X回零个字节。</target>
        </trans-unit>
        <trans-unit id="7f1ec747ece71d77c655f9a07fae8cab37f0a797" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; method returns the current length, in bytes, of the dynamic string under construction in &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X. The length returned by &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; does not include the zero-termination byte.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length（X）&lt;/a&gt;方法返回的当前长度，以字节为单位，正在建设中的动态字符串的&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;对象X.由返回的长度&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length（X）&lt;/a&gt;不包括零终止字节。</target>
        </trans-unit>
        <trans-unit id="abad991ae0af361a9313d8cfba4c5223a9d4a389" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; method returns a pointer to the current content of the dynamic string under construction in X. The value returned by &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; is managed by the sqlite3_str object X and might be freed or altered by any subsequent method on the same &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object. Applications must not used the pointer returned &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; after any subsequent method call on the same object. Applications may change the content of the string returned by &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; as long as they do not write into any bytes outside the range of 0 to &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; and do not read or write any byte after any subsequent sqlite3_str method call.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value（X）&lt;/a&gt;方法返回指向在建X.动态串由返回的值的当前内容&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value（X）&lt;/a&gt;是由sqlite3_str对象X管理，并且可能由任何随后的方法在相同的被释放的或改变的&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;对象。在同一对象上进行任何后续方法调用之后，应用程序都不得使用返回的&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value（X）&lt;/a&gt;指针。应用程序可以更改&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value（X）&lt;/a&gt;返回的字符串的内容，只要它们不写入0到&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length（X）&lt;/a&gt;范围之外的任何字节，并且在后续任何sqlite3_str方法调用之后不读取或写入任何字节。</target>
        </trans-unit>
        <trans-unit id="9ed76b8571c1160c10dee5527b0d46210f6deae9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface destroys the sqlite3_str object X and returns a pointer to a memory buffer obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; that contains the constructed string. The calling application should pass the returned value to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; to avoid a memory leak. The &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface may return a NULL pointer if any errors were encountered during construction of the string. The &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface will also return a NULL pointer if the string in &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X is zero bytes long.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish（X）&lt;/a&gt;的界面破坏sqlite3_str对象X，并返回一个指针，从缓冲器得到的存储器&lt;a href=&quot;#sqlite3_free&quot;&gt;（）sqlite3_malloc64&lt;/a&gt;包含构造的字符串。调用应用程序应将返回的值传递给&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（），&lt;/a&gt;以避免内存泄漏。该&lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish（X）&lt;/a&gt;接口可返回NULL指针，如果施工字符串的过程中遇到的任何错误。如果&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;对象X中的字符串的长度为零字节，则&lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish（X）&lt;/a&gt;接口还将返回NULL指针。</target>
        </trans-unit>
        <trans-unit id="1a8bb7e6f2617ebce878cf41863558873c56dd1a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface allocates and initializes a new &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object. To avoid memory leaks, the object returned by &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt; must be freed by a subsequent call to &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new（d）&lt;/a&gt;接口分配和初始化一个新&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;对象。为了避免内存泄漏，必须通过随后调用&lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish（X）&lt;/a&gt;来释放&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;返回的对象。</target>
        </trans-unit>
        <trans-unit id="283dcdc6097ac99a155d31e274b76b664e287d7e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface always returns a pointer to a valid &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object, though in the event of an out-of-memory error the returned object might be a special singleton that will silently reject new text, always return SQLITE_NOMEM from &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode()&lt;/a&gt;, always return 0 for &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length()&lt;/a&gt;, and always return NULL from &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;. It is always safe to use the value returned by &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; as the sqlite3_str parameter to any of the other &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; methods.</source>
          <target state="translated">该&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new（d）&lt;/a&gt;接口总是返回一个指向一个有效的&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;对象，虽然在内存不足，错误的情况下返回的对象可能是一个特殊的单，将默默地拒绝新的文字，总是从返回SQLITE_NOMEM &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode（）&lt;/a&gt;，对于&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length（）&lt;/a&gt;总是返回0 ，而对于&lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish（X）&lt;/a&gt;总是返回NULL 。将&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new（D）&lt;/a&gt;返回的值用作其他任何&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;方法的sqlite3_str参数始终是安全的。</target>
        </trans-unit>
        <trans-unit id="47a765f2716bbd0a7165479eb04c6ad3833cfd2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern P. The definition of &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern matching used in &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; is the same as for the &quot;X GLOB P&quot; operator in the SQL dialect understood by SQLite. The &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; function is case sensitive.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob（P，X）&lt;/a&gt;接口返回零当且仅当序列X的匹配&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;图案P上的定义&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;中使用图案匹配&lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob（P，X）&lt;/a&gt;是与用于在所述&amp;ldquo;X GLOB P&amp;rdquo;算子SQLite可以理解的SQL方言。所述&lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob（P，X）&lt;/a&gt;函数是大小写敏感的。</target>
        </trans-unit>
        <trans-unit id="95615e5c78fed3ee43eff0e7b082843f593e6a31" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; APIs allow applications and extensions to compare the contents of two buffers containing UTF-8 strings in a case-independent fashion, using the same definition of &quot;case independence&quot; that SQLite uses internally when comparing identifiers.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp（）&lt;/a&gt; API允许应用程序和扩展，以比较两种含在壳体无关的方式UTF-8字符串两个缓冲区的内容，使用&amp;ldquo;的情况下独立&amp;rdquo;的是比较的SQLite标识符时，在内部使用的相同的定义。</target>
        </trans-unit>
        <trans-unit id="51d8a3ef92ef4d7b314975584d8072e9206e198e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function matches Unicode characters, though only ASCII characters are case folded.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike（P，X，E）&lt;/a&gt;函数匹配Unicode字符，虽然只有ASCII字符区分折叠。</target>
        </trans-unit>
        <trans-unit id="485ac31bffb8ac065daf3ba2a8161fbdf5039efd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern P with escape character E. The definition of &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern matching used in &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; is the same as for the &quot;X LIKE P ESCAPE E&quot; operator in the SQL dialect understood by SQLite. For &quot;X LIKE P&quot; without the ESCAPE clause, set the E parameter of &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; to 0. As with the LIKE operator, the &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function is case insensitive - equivalent upper and lower case ASCII characters match one another.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike（P，X，E）&lt;/a&gt;接口返回零当且仅当序列X匹配&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;用转义字符E的定义图案P &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;中使用的模式匹配&lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike（P，X，E）&lt;/a&gt;是相同的SQLite可以理解的SQL方言中的&amp;ldquo; X LIKE P ESCAPE E&amp;rdquo;运算符。对于不带ESCAPE子句的&amp;ldquo; X LIKE P&amp;rdquo;，请将&lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike（P，X，E）&lt;/a&gt;的E参数设置为0。与LIKE运算符一样，&lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike（P，X，E）&lt;/a&gt;函数不区分大小写-等效的上和下小写ASCII字符相互匹配。</target>
        </trans-unit>
        <trans-unit id="67cdd83f23b0c9baf88d22cb2f2c082de3577118" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes(D)&lt;/a&gt; interface only reports the number of rows that changed due to SQL statement run against database connection D. Any changes by other database connections are ignored. To detect changes against a database file from other database connections use the &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command or the &lt;a href=&quot;#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;file control&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes（d）&lt;/a&gt;接口只报告改变由于SQL语句的运行对数据库连接D.其他数据库连接的任何改变都将被忽略的行数。要检测来自其他数据库连接的数据库文件的更改，请使用&lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt;命令或&lt;a href=&quot;#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION &lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;文件控件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2dc4153435020e41ac99ab2b5b83d08f27b98c68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint(D,N)&lt;/a&gt; is a wrapper around &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; that causes any database on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D to automatically &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; after committing a transaction if there are N or more frames in the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; file. Passing zero or a negative value as the nFrame parameter disables automatic checkpoints entirely.</source>
          <target state="translated">该&lt;a href=&quot;#sqlite3_wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint（d，N）&lt;/a&gt;是围绕一个包装&lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;引起的任何数据库&lt;a href=&quot;#sqlite3&quot;&gt;的数据库连接&lt;/a&gt; d自动&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;提交事务后，如果有N帧以上的&lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt;文件。作为nFrame参数传递零或负值将完全禁用自动检查点。</target>
        </trans-unit>
        <trans-unit id="9142f5b65b53643523fc33889c4ba6acff8188e5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; function is used to register a callback that is invoked each time data is committed to a database in wal mode.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;函数是用来注册时调用每次数据致力于在沃尔玛模式的数据库中的回调。</target>
        </trans-unit>
        <trans-unit id="fdbc2004b6063417b2874cd07563f5073fb2461b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connection's busy-handler callback. The argument is of type (void**) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connection's busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.</source>
          <target state="translated">该&lt;a href=&quot;#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt;文件控制可通过SQLite的它是为了提供一个自定义的VFS能够访问连接繁忙的处理程序回调打开后不久，数据库文件句柄调用。参数的类型为（void **）-两个（void *）值的数组。第一个（void *）实际上指向类型为（int（*）（void *））的函数。为了调用连接的busy-handler，应使用数组中的第二个（void *）作为唯一参数来调用此函数。如果返回非零值，则应重试该操作。如果返回零，则自定义VFS应该放弃当前操作。</target>
        </trans-unit>
        <trans-unit id="0804c63302651c02a306eb7ec9ff35797d83276d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connections busy-handler callback. The argument is of type (void **) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connections busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.</source>
          <target state="translated">该&lt;a href=&quot;#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt;文件控制可通过SQLite的它是为了提供一个自定义的VFS能够访问连接忙处理程序回调打开后不久，数据库文件句柄调用。参数的类型为（void **）-两个（void *）值的数组。第一个（void *）实际上指向类型为（int（*）（void *））的函数。为了调用连接busy-handler，应使用数组中的第二个（void *）作为唯一参数来调用此函数。如果返回非零值，则应重试该操作。如果返回零，则自定义VFS应该放弃当前操作。</target>
        </trans-unit>
        <trans-unit id="e16ec9bd7cc655e1fcca3234a2d80781961dcf25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlchunksize&quot; id=&quot;sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZE&lt;/a&gt; opcode is used to request that the VFS extends and truncates the database file in chunks of a size specified by the user. The fourth argument to &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; should point to an integer (type int) containing the new chunk-size to use for the nominated database. Allocating database file space in large chunks (say 1MB at a time), may reduce file-system fragmentation and improve performance on some systems.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlitefcntlchunksize&quot; id=&quot;sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZE&lt;/a&gt;操作码被用来请求该VFS延伸并截断在由用户指定的尺寸的块中的数据库文件。&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;的第四个参数应指向一个整数（类型为int），该整数包含要用于提名数据库的新块大小。将数据库文件空间大块地分配（例如一次分配1MB）可以减少文件系统的碎片并提高某些系统上的性能。</target>
        </trans-unit>
        <trans-unit id="55799a140d15462e73ef05abf1db855a8aa627ae" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlckptdone&quot; id=&quot;sqlitefcntlckptdone&quot;&gt;SQLITE_FCNTL_CKPT_DONE&lt;/a&gt; opcode is invoked from within a checkpoint in wal mode after the client has finished copying pages from the wal file to the database file, but before the *-shm file is updated to record the fact that the pages have been checkpointed.</source>
          <target state="translated">该&lt;a href=&quot;#sqlitefcntlckptdone&quot; id=&quot;sqlitefcntlckptdone&quot;&gt;SQLITE_FCNTL_CKPT_DONE&lt;/a&gt;操作码是从沃尔玛模式检查点的客户端从沃尔玛文件到数据库文件复制完成后的页面中调用，但* -shm文件被更新，以记录的网页已设置检查点的事实面前。</target>
        </trans-unit>
        <trans-unit id="23adb4e434c478e58b40c24db57f497a0e6e59c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlckptstart&quot; id=&quot;sqlitefcntlckptstart&quot;&gt;SQLITE_FCNTL_CKPT_START&lt;/a&gt; opcode is invoked from within a checkpoint in wal mode before the client starts to copy pages from the wal file to the database file.</source>
          <target state="translated">该&lt;a href=&quot;#sqlitefcntlckptstart&quot; id=&quot;sqlitefcntlckptstart&quot;&gt;SQLITE_FCNTL_CKPT_START&lt;/a&gt;客户端开始从沃尔玛文件到数据库文件复制页面之前操作码是从沃尔玛模式关卡中调用。</target>
        </trans-unit>
        <trans-unit id="196a41f980c38337225c4ba413e0b1dc0b2b471a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot; id=&quot;sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be performed atomically. This file control returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if and only if the writes were all performed successfully and have been committed to persistent storage. Regardless of whether or not it is successful, this file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_COMMIT_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot; id=&quot;sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;操作码会导致所有的写操作，因为以前的成功调用&lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;以原子执行。当且仅当所有写入均已成功执行且已提交到持久性存储时，此文件控件才返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;。无论是否成功，此文件控件都会使文件描述符脱离批写模式，因此所有后续写操作都是独立的。如果没有事先成功调用SQLITE_FCNTL_BEGIN_ATOMIC_WRITE，SQLite将永远不会调用&lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed7c39458516ed31456486d668f266799517f0b4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlcommitphasetwo&quot; id=&quot;sqlitefcntlcommitphasetwo&quot;&gt;SQLITE_FCNTL_COMMIT_PHASETWO&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS after a transaction has been committed immediately but before the database is unlocked. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">该&lt;a href=&quot;#sqlitefcntlcommitphasetwo&quot; id=&quot;sqlitefcntlcommitphasetwo&quot;&gt;SQLITE_FCNTL_COMMIT_PHASETWO&lt;/a&gt;操作码SQLite内部生成并发送至VFS之后事务已立即提交，但数据库被解锁之前。不需要此信号的VFS应静默忽略此操作码。应用程序不应使用此操作码调用&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;，因为这样做可能会破坏需要它的专用VFS的运行。</target>
        </trans-unit>
        <trans-unit id="a6067fb898268faa568cf0d8b727509a1e63a822" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The &quot;data version&quot; for the pager is written into the pointer. The &quot;data version&quot; changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface responds to internal changes only and omits changes made by other database connections. The &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command provide a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.</source>
          <target state="translated">该&lt;a href=&quot;#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt;操作码用以检测更改的数据库文件。该参数是一个指向32位无符号整数的指针。寻呼机的&amp;ldquo;数据版本&amp;rdquo;被写入指针。每当对相应的数据库文件进行任何更改时，&amp;ldquo;数据版本&amp;rdquo;都会更改，或者通过同一数据库连接上的SQL语句，或者通过可能在其他进程中由单独的数据库连接提交的事务来更改。该&lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;接口，可用于查找如果连接上的任何数据库已更改，但是该接口响应在TEMP变化以及主并没有提供一种机制来检测对仅MAIN。另外，&lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;接口仅响应内部更改，而忽略其他数据库连接所做的更改。的&lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt;命令提供一种机制来检测变化的发生是由于其他数据库连接的单个附加的数据库，但是省略通过改变在其上它被称为数据库连接实现。此文件控件是检测内部或外部发生的更改以及与特定附加数据库关联的更改的唯一机制。</target>
        </trans-unit>
        <trans-unit id="e9a73ef11b02c7c1ef7f3e1f806173140bf3d029" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The &quot;data version&quot; for the pager is written into the pointer. The &quot;data version&quot; changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface responds to internal changes only and omits changes made by other database connections. The &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command provides a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.</source>
          <target state="translated">该&lt;a href=&quot;#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt;操作码用以检测更改的数据库文件。该参数是指向32位无符号整数的指针。寻呼机的&amp;ldquo;数据版本&amp;rdquo;被写入指针。每当对相应的数据库文件进行任何更改时，&amp;ldquo;数据版本&amp;rdquo;都会更改，或者通过同一数据库连接上的SQL语句，或者通过可能在其他进程中由单独的数据库连接提交的事务来更改。该&lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;接口，可用于查找如果连接上的任何数据库已更改，但是该接口响应在TEMP变化以及主并没有提供一种机制来检测对仅MAIN。另外，&lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;接口仅响应内部更改，而忽略其他数据库连接所做的更改。的&lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt;命令提供了一种机制来检测变化的发生是由于其他数据库连接的单个附加的数据库，但是省略通过改变在其上它被称为数据库连接实现。此文件控件是检测内部或外部发生的更改以及与特定附加数据库关联的更改的唯一机制。</target>
        </trans-unit>
        <trans-unit id="c45a2fa29af05eafc8a58031e6a08762e72b9ebb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlfilepointer&quot; id=&quot;sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with a particular database connection. See also &lt;a href=&quot;#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlitefcntlfilepointer&quot; id=&quot;sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt;操作码被用来获得一个指针&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt;与特定的数据库连接相关联的对象。另请参见&lt;a href=&quot;#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="32fc3ec6f9212eb93de60bbea8de22f4f5c0720b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlhasmoved&quot; id=&quot;sqlitefcntlhasmoved&quot;&gt;SQLITE_FCNTL_HAS_MOVED&lt;/a&gt; file control interprets its argument as a pointer to an integer and it writes a boolean into that integer depending on whether or not the file has been renamed, moved, or deleted since it was first opened.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlitefcntlhasmoved&quot; id=&quot;sqlitefcntlhasmoved&quot;&gt;SQLITE_FCNTL_HAS_MOVED&lt;/a&gt;文件控制解释它的参数的指针为一个整数，并将其写入一个布尔值到根据文件是否不是整数已被重命名，移动或删除，因为它第一次打开。</target>
        </trans-unit>
        <trans-unit id="961fafabf95f8005cd6aacb0ba427c7a66f5ca95" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntljournalpointer&quot; id=&quot;sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with the journal file (either the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; or the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;) for a particular database connection. See also &lt;a href=&quot;#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlitefcntljournalpointer&quot; id=&quot;sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt;操作码被用来获得一个指针&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt;与轴颈文件（或者相关联的对象&lt;a href=&quot;lockingv3#rollback&quot;&gt;回滚日志&lt;/a&gt;或&lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt;特定数据库连接）。另请参见&lt;a href=&quot;#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3359a645510d53c409e1e871158229645d3789b4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntllockstate&quot; id=&quot;sqlitefcntllockstate&quot;&gt;SQLITE_FCNTL_LOCKSTATE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to write the current state of the lock (one of &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;, &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt;, &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt;) into an integer that the pArg argument points to. This capability is used during testing and is only available when the SQLITE_TEST compile-time option is used.</source>
          <target state="translated">该&lt;a href=&quot;#sqlitefcntllockstate&quot; id=&quot;sqlitefcntllockstate&quot;&gt;SQLITE_FCNTL_LOCKSTATE&lt;/a&gt;操作码用于调试。此操作码使xFileControl方法将锁的当前状态（&lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt;，&lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;，&lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt;，&lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt;或&lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_EXCLUSIVE之一&lt;/a&gt;）写入pArg参数指向的整数。此功能在测试期间使用，并且仅在使用SQLITE_TEST编译时选项时可用。</target>
        </trans-unit>
        <trans-unit id="413d8e1b0a9fd900669cb69e73b3dca110ff8c2c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; opcode causes attempts to obtain a file lock using the xLock or xShmLock methods of the VFS to wait for up to M milliseconds before failing, where M is the single unsigned integer parameter.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt;操作码会导致尝试获得使用VFS的XLOCK或xShmLock方法等待多达M个毫秒失败，其中M是单个的无符号整数的参数前的文件锁。</target>
        </trans-unit>
        <trans-unit id="15909a890c9f03d44aa2dc2921d58c760b545e1a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; opcode is used to configure a VFS to block for up to M milliseconds before failing when attempting to obtain a file lock using the xLock or xShmLock methods of the VFS. The parameter is a pointer to a 32-bit signed integer that contains the value that M is to be set to. Before returning, the 32-bit signed integer is overwritten with the previous value of M.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt;操作码用于配置一个VFS到块多达M个毫秒试图获得使用VFS的XLOCK或xShmLock方法文件锁时失效之前。该参数是指向32位带符号整数的指针，该整数包含M设置为的值。返回之前，32位带符号整数将被先前的M值覆盖。</target>
        </trans-unit>
        <trans-unit id="98a69e4da16c0af72de938b51b675221a8706b54" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlmmapsize&quot; id=&quot;sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt; file control is used to query or set the maximum number of bytes that will be used for memory-mapped I/O. The argument is a pointer to a value of type sqlite3_int64 that is an advisory maximum number of bytes in the file to memory map. The pointer is overwritten with the old value. The limit is not changed if the value originally pointed to is negative, and so the current limit can be queried by passing in a pointer to a negative number. This file-control is used internally to implement &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlitefcntlmmapsize&quot; id=&quot;sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt;文件控制用于查询或设置将被用于的最大字节数目的存储器映射I / O。该参数是一个指向sqlite3_int64类型的值的指针，该值是文件到内存映射中建议的最大字节数。指针将被旧值覆盖。如果最初指向的值是负数，则限制不会更改，因此可以通过将指针传递给负数来查询当前限制。此文件控件在内部用于实现&lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d526543f15c2ce77f0461ecf7fe44c9004bea17a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntloverwrite&quot; id=&quot;sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITE&lt;/a&gt; opcode is invoked by SQLite after opening a write transaction to indicate that, unless it is rolled back for some reason, the entire database file will be overwritten by the current transaction. This is used by VACUUM operations.</source>
          <target state="translated">该&lt;a href=&quot;#sqlitefcntloverwrite&quot; id=&quot;sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITE&lt;/a&gt;操作码被打开的SQLite写事务，以表明，除非它被回退由于某些原因后调用，整个数据库文件将被覆盖当前事务。 VACUUM操作使用它。</target>
        </trans-unit>
        <trans-unit id="5ebd2a70a799339bb0872257764cf8c08eda9ecd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlpersistwal&quot; id=&quot;sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; opcode is used to set or query the persistent &lt;a href=&quot;wal&quot;&gt;Write Ahead Log&lt;/a&gt; setting. By default, the auxiliary write ahead log (&lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt;) and shared memory files used for transaction control are automatically deleted when the latest connection to the database closes. Setting persistent WAL mode causes those files to persist after close. Persisting the files is useful when other processes that do not have write permission on the directory containing the database file want to read the database file, as the WAL and shared memory files must exist in order for the database to be readable. The fourth parameter to &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable persistent WAL mode or 1 to enable persistent WAL mode. If the integer is -1, then it is overwritten with the current WAL persistence setting.</source>
          <target state="translated">该&lt;a href=&quot;#sqlitefcntlpersistwal&quot; id=&quot;sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;操作码是用来设置或查询持续&lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt;设置。默认情况下，与数据库的最新连接关闭时，将自动删除用于事务控制的辅助&lt;a href=&quot;wal#walfile&quot;&gt;预&lt;/a&gt;写日志（WAL文件）和共享内存文件。设置持久性WAL模式会导致这些文件在关闭后继续存在。当对包含数据库文件的目录没有写权限的其他进程想要读取数据库文件时，持久保留文件非常有用，因为必须存在WAL和共享内存文件才能使数据库可读。&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;的第四个参数这个操作码应该是一个指向整数的指针。该整数是0以禁用持久WAL模式，或为1以启用持久WAL模式。如果整数为-1，则将使用当前的WAL持久性设置覆盖它。</target>
        </trans-unit>
        <trans-unit id="fdccf2fe8da7ee0d8c5941a2ea211306829a9588" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlpowersafeoverwrite&quot; id=&quot;sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; opcode is used to set or query the persistent &quot;powersafe-overwrite&quot; or &quot;PSOW&quot; setting. The PSOW setting determines the &lt;a href=&quot;#SQLITE_IOCAP_ATOMIC&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; bit of the xDeviceCharacteristics methods. The fourth parameter to &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable zero-damage mode or 1 to enable zero-damage mode. If the integer is -1, then it is overwritten with the current zero-damage mode setting.</source>
          <target state="translated">该&lt;a href=&quot;#sqlitefcntlpowersafeoverwrite&quot; id=&quot;sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt;操作码是用来设置或查询老大难&amp;ldquo;powersafe重写&amp;rdquo;或&amp;ldquo;PSOW&amp;rdquo;设置。PSOW设置确定xDeviceCharacteristics方法的&lt;a href=&quot;#SQLITE_IOCAP_ATOMIC&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt;位。此操作码的&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;的第四个参数应为指向整数的指针。该整数是0以禁用零损坏模式，或为1以启用零损坏模式。如果整数为-1，则将使用当前的零损坏模式设置覆盖它。</target>
        </trans-unit>
        <trans-unit id="7f192c2e63c8633453fa1eae93e0c07df64cf07f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlrbu&quot; id=&quot;sqlitefcntlrbu&quot;&gt;SQLITE_FCNTL_RBU&lt;/a&gt; opcode is implemented by the special VFS used by the RBU extension only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="translated">该&lt;a href=&quot;#sqlitefcntlrbu&quot; id=&quot;sqlitefcntlrbu&quot;&gt;SQLITE_FCNTL_RBU&lt;/a&gt;操作码是由只有RBU扩展使用了特殊的VFS实现。所有其他VFS应该为此操作码返回SQLITE_NOTFOUND。</target>
        </trans-unit>
        <trans-unit id="dbf9a50cfd48cde386829709800477dc50bcc565" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot; id=&quot;sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be rolled back. This file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot; id=&quot;sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt;操作码会导致所有的写操作，因为以前的成功调用&lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;回滚。此文件控件使文件描述符脱离批写模式，因此所有后续写操作都是独立的。如果没有事先成功调用SQLITE_FCNTL_BEGIN_ATOMIC_WRITE，SQLite将永远不会调用&lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a3dd434f5b5d6086654ad44e0af5b3fa3e940b9d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsizehint&quot; id=&quot;sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt; opcode is used by SQLite to give the VFS layer a hint of how large the database file will grow to be during the current transaction. This hint is not guaranteed to be accurate but it is often close. The underlying VFS might choose to preallocate database file space based on this hint in order to help writes to the database file run faster.</source>
          <target state="translated">该&lt;a href=&quot;#sqlitefcntlsizehint&quot; id=&quot;sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt;操作码使用的SQLite给予VFS层的数据库文件将如何大发展是当前交易中的提示。此提示不能保证准确，但通常很接近。底层VFS可能会基于此提示选择预分配数据库文件空间，以帮助更快地写入数据库文件。</target>
        </trans-unit>
        <trans-unit id="97cd9ce5f443d3219025ca93221b345486932d73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsizelimit&quot; id=&quot;sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt; opcode is used by in-memory VFS that implements &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; to set an upper bound on the size of the in-memory database. The argument is a pointer to a &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt;. If the integer pointed to is negative, then it is filled in with the current limit. Otherwise the limit is set to the larger of the value of the integer pointed to and the current database size. The integer pointed to is set to the new limit.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlitefcntlsizelimit&quot; id=&quot;sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt;操作码所使用的内存VFS实现&lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize（）&lt;/a&gt;来设置上界内存数据库的大小。该参数是一个指向&lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt;的指针。如果所指向的整数是负数，则将其填充为当前限制。否则，将限制设置为所指向的整数的值和当前数据库大小中的较大者。指向的整数设置为新的限制。</target>
        </trans-unit>
        <trans-unit id="3a6ee4f80c9cf2b24ebb8343bd1162955c7d2500" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions master-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt;操作码SQLite内部产生并立即XSYNC方法上的数据库文件描述符调用之前发送到VFS。或者，如果未调用xSync方法，因为用户已使用PRAGMAynchronous &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;= OFF&lt;/a&gt;配置了SQLite，则它将代替xSync方法被调用。在大多数情况下，与此文件控件一起传递的指针参数为NULL。但是，如果将数据库文件作为多数据库提交的一部分进行同步，则该参数指向一个以空字符结尾的字符串，其中包含事务主日志文件名。不需要此信号的VFS应静默忽略此操作码。应用程序不应调用&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt; 这样做可能会破坏需要它的专用VFS的运行。</target>
        </trans-unit>
        <trans-unit id="5178975b67a8618a8b0176ac061e8db0d71f5de9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions super-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt;操作码SQLite内部产生并立即XSYNC方法上的数据库文件描述符调用之前发送到VFS。或者，如果未调用xSync方法，因为用户已使用PRAGMAynchronous &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;= OFF&lt;/a&gt;配置了SQLite，则它将代替xSync方法被调用。在大多数情况下，与此文件控件一起传递的指针参数为NULL。但是，如果数据库文件作为多数据库提交的一部分进行同步，则该参数指向一个以nul终止的字符串，其中包含事务超级日志文件名。不需要此信号的VFS应静默忽略此操作码。应用程序不应调用&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt; 这样做可能会破坏确实需要它的专用VFS的运行。</target>
        </trans-unit>
        <trans-unit id="105a39338a53cf76076319343b91a58b713c591f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntltrace&quot; id=&quot;sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE&lt;/a&gt; file control provides advisory information to the VFS about what the higher layers of the SQLite stack are doing. This file control is used by some VFS activity tracing &lt;a href=&quot;vfs#shim&quot;&gt;shims&lt;/a&gt;. The argument is a zero-terminated string. Higher layers in the SQLite stack may generate instances of this file control if the &lt;a href=&quot;compile#use_fcntl_trace&quot;&gt;SQLITE_USE_FCNTL_TRACE&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">该&lt;a href=&quot;#sqlitefcntltrace&quot; id=&quot;sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE&lt;/a&gt;文件控制提供咨询信息，以什么SQLite的栈的高层正在做的VFS。一些VFS活动跟踪&lt;a href=&quot;vfs#shim&quot;&gt;补片&lt;/a&gt;使用此文件控件。参数是一个以零结尾的字符串。如果启用了&lt;a href=&quot;compile#use_fcntl_trace&quot;&gt;SQLITE_USE_FCNTL_TRACE&lt;/a&gt;编译时选项，则SQLite堆栈中的较高层可能会生成此文件控件的实例。</target>
        </trans-unit>
        <trans-unit id="10a39c75085aed62eed16a6bd93eb299fac8af13" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlvfsname&quot; id=&quot;sqlitefcntlvfsname&quot;&gt;SQLITE_FCNTL_VFSNAME&lt;/a&gt; opcode can be used to obtain the names of all &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; in the VFS stack. The names are of all VFS shims and the final bottom-level VFS are written into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and the result is stored in the char* variable that the fourth parameter of &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; points to. The caller is responsible for freeing the memory when done. As with all file-control actions, there is no guarantee that this will actually do anything. Callers should initialize the char* variable to a NULL pointer in case this file-control is not implemented. This file-control is intended for diagnostic use only.</source>
          <target state="translated">该&lt;a href=&quot;#sqlitefcntlvfsname&quot; id=&quot;sqlitefcntlvfsname&quot;&gt;SQLITE_FCNTL_VFSNAME&lt;/a&gt;操作码可用于获取所有的名字&lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;在VFS栈。名称是所有VFS填充的名称，最终的底层VFS将写入从&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;获得的内存中，并将结果存储在&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;的第四个参数指向的char *变量中。完成后，调用方负责释放内存。与所有文件控制操作一样，不能保证此操作实际上会做任何事情。如果未实现此文件控件，则调用者应将char *变量初始化为NULL指针。此文件控件仅用于诊断用途。</target>
        </trans-unit>
        <trans-unit id="a0de6e2585567c94a4d2150e4d89a4457d85ed27" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlvfspointer&quot; id=&quot;sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt; opcode finds a pointer to the top-level &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; currently in use. The argument X in sqlite3_file_control(db,SQLITE_FCNTL_VFS_POINTER,X) must be of type &quot;&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; **&quot;. This opcodes will set *X to a pointer to the top-level VFS. When there are multiple VFS shims in the stack, this opcode finds the upper-most shim only.</source>
          <target state="translated">该&lt;a href=&quot;#sqlitefcntlvfspointer&quot; id=&quot;sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt;操作码找到一个指向顶层&lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;当前正在使用。sqlite3_file_control（db，SQLITE_FCNTL_VFS_POINTER，X）中的参数X必须为&amp;ldquo; &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; **&amp;rdquo; 类型。该操作码会将* X设置为指向顶级VFS的指针。当堆栈中有多个VFS垫片时，此操作码仅查找最上方的垫片。</target>
        </trans-unit>
        <trans-unit id="6fb5c486ab423108118235eb419e942dcdffc3fc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwalblock&quot; id=&quot;sqlitefcntlwalblock&quot;&gt;SQLITE_FCNTL_WAL_BLOCK&lt;/a&gt; is a signal to the VFS layer that it might be advantageous to block on the next WAL lock if the lock is not immediately available. The WAL subsystem issues this signal during rare circumstances in order to fix a problem with priority inversion. Applications should &lt;em&gt;not&lt;/em&gt; use this file-control.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlitefcntlwalblock&quot; id=&quot;sqlitefcntlwalblock&quot;&gt;SQLITE_FCNTL_WAL_BLOCK&lt;/a&gt;是一个信号到VFS层，如果锁不是立即可用，可能有利的是在下一WAL锁块。WAL子系统在极少数情况下会发出此信号，以解决优先级反转的问题。应用程序应该&lt;em&gt;不&lt;/em&gt;使用此文件控制。</target>
        </trans-unit>
        <trans-unit id="2324c4dab632501938725b9d6af72b57f5294994" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwin32avretry&quot; id=&quot;sqlitefcntlwin32avretry&quot;&gt;SQLITE_FCNTL_WIN32_AV_RETRY&lt;/a&gt; opcode is used to configure automatic retry counts and intervals for certain disk I/O operations for the windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; in order to provide robustness in the presence of anti-virus programs. By default, the windows VFS will retry file read, file write, and file delete operations up to 10 times, with a delay of 25 milliseconds before the first retry and with the delay increasing by an additional 25 milliseconds with each subsequent retry. This opcode allows these two values (10 retries and 25 milliseconds of delay) to be adjusted. The values are changed for all database connections within the same process. The argument is a pointer to an array of two integers where the first integer is the new retry count and the second integer is the delay. If either integer is negative, then the setting is not changed but instead the prior value of that setting is written into the array entry, allowing the current retry settings to be interrogated. The zDbName parameter is ignored.</source>
          <target state="translated">该&lt;a href=&quot;#sqlitefcntlwin32avretry&quot; id=&quot;sqlitefcntlwin32avretry&quot;&gt;SQLITE_FCNTL_WIN32_AV_RETRY&lt;/a&gt;操作码用于配置某些磁盘自动重试次数和时间间隔为Windows I / O操作&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;为了在存在防病毒程序的情况下提供强大的功能。默认情况下，Windows VFS将重试文件读取，文件写入和文件删除操作最多10次，第一次重试之前的延迟为25毫秒，而每次后续重试的延迟都会增加25毫秒。此操作码允许调整这两个值（重试10次和延迟25毫秒）。对于同一过程中的所有数据库连接，将更改这些值。参数是一个指向两个整数的数组的指针，其中第一个整数是新的重试计数，第二个整数是延迟。如果任一整数为负，则不更改设置，而是将该设置的先前值写入数组条目，从而可以查询当前重试设置。zDbName参数将被忽略。</target>
        </trans-unit>
        <trans-unit id="257792bb90d40cbd5be070de917b57c36a5f9cd9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwin32gethandle&quot; id=&quot;sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE&lt;/a&gt; opcode can be used to obtain the underlying native file handle associated with a file handle. This file control interprets its argument as a pointer to a native file handle and writes the resulting value there.</source>
          <target state="translated">所述&lt;a href=&quot;#sqlitefcntlwin32gethandle&quot; id=&quot;sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE&lt;/a&gt;操作码可被用于获得与文件句柄相关联的底层本地文件句柄。该文件控件将其参数解释为指向本机文件句柄的指针，并将结果值写入该文件句柄。</target>
        </trans-unit>
        <trans-unit id="774ea185734630483687c4bdf35dc5a0169545c2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwin32sethandle&quot; id=&quot;sqlitefcntlwin32sethandle&quot;&gt;SQLITE_FCNTL_WIN32_SET_HANDLE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to swap the file handle with the one pointed to by the pArg argument. This capability is used during testing and only needs to be supported when SQLITE_TEST is defined.</source>
          <target state="translated">该&lt;a href=&quot;#sqlitefcntlwin32sethandle&quot; id=&quot;sqlitefcntlwin32sethandle&quot;&gt;SQLITE_FCNTL_WIN32_SET_HANDLE&lt;/a&gt;操作码用于调试。此操作码使xFileControl方法将文件句柄与pArg参数指向的文件句柄交换。此功能在测试期间使用，仅在定义SQLITE_TEST时才需要支持。</target>
        </trans-unit>
        <trans-unit id="6d8e8025bf5df9df0de6e9fce45f3dc3f3a1832f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlzipvfs&quot; id=&quot;sqlitefcntlzipvfs&quot;&gt;SQLITE_FCNTL_ZIPVFS&lt;/a&gt; opcode is implemented by zipvfs only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="translated">该&lt;a href=&quot;#sqlitefcntlzipvfs&quot; id=&quot;sqlitefcntlzipvfs&quot;&gt;SQLITE_FCNTL_ZIPVFS&lt;/a&gt;操作码仅由zipvfs实现。所有其他VFS应该为此操作码返回SQLITE_NOTFOUND。</target>
        </trans-unit>
        <trans-unit id="2a84f41bb71a501decc458aa53d2eb6f639dc064" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option can be used to limit the length of &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt; expansion in the output of sqlite3_trace().</source>
          <target state="translated">所述&lt;a href=&quot;../compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt;编译时选项可用于限制所长度&lt;a href=&quot;../lang_expr#varparam&quot;&gt;绑定参数&lt;/a&gt;在sqlite3_trace的输出扩展（）。</target>
        </trans-unit>
        <trans-unit id="a6d12472a003010a0b08bc4775382d299187ba70" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option limits the size of bound parameter expansions. The &lt;a href=&quot;../compile#omit_trace&quot;&gt;SQLITE_OMIT_TRACE&lt;/a&gt; compile-time option causes sqlite3_expanded_sql() to always return NULL.</source>
          <target state="translated">所述&lt;a href=&quot;../compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt;编译时选项限制结合的参数扩展的大小。该&lt;a href=&quot;../compile#omit_trace&quot;&gt;SQLITE_OMIT_TRACE&lt;/a&gt;时间编译选项的原因sqlite3_expanded_sql（）总是返回NULL。</target>
        </trans-unit>
        <trans-unit id="7fbc9bba97b7220d8d7ecc905032c6bd233e87c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; should be avoided.</source>
          <target state="translated">所述&lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory编译指示&lt;/a&gt;可以修改此变量并且导致其指向从获得存储器&lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;。此外，&lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt;始终假定此变量指向的任何字符串都保存在从&lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;获得的内存中，并且pragma可以尝试使用&lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;释放该内存。因此，如果直接修改此变量，则应将其设置为NULL或指向从&lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;获得的内存，否则应避免使用&lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory编译指示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f9eb53bad0c35cc3dcade82b9f30796bebe98ba9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt; statement.</source>
          <target state="translated">该&lt;a href=&quot;../pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = OFF&lt;/a&gt;声明。</target>
        </trans-unit>
        <trans-unit id="4683a2e9a942c25fe816aae1882f9a79405f5686" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; should be avoided. Except when requested by the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, SQLite does not free the memory that sqlite3_temp_directory points to. If the application wants that memory to be freed, it must do so itself, taking care to only do so after all &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; objects have been destroyed.</source>
          <target state="translated">所述&lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory编译指示&lt;/a&gt;可以修改此变量并且导致其指向从获得存储器&lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;。此外，&lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;始终假定此变量指向的任何字符串都保存在从&lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;获得的内存中，并且pragma可以尝试使用&lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;释放该内存。因此，如果直接修改此变量，则应将其设为NULL或指向从&lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;获得的内存，否则应避免使用&lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory杂注&lt;/a&gt;。除非&lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory编译指示有&lt;/a&gt;要求，SQLite不会释放sqlite3_temp_directory指向的内存。如果应用程序希望释放该内存，则它必须自己释放内存，只有在销毁所有&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;对象之后才注意这样做。</target>
        </trans-unit>
        <trans-unit id="d082fe94995359849591e8be7fa905999e11458e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; can be used to invoke this interface from SQL.</source>
          <target state="translated">该&lt;a href=&quot;../pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint编译&lt;/a&gt;可以被用来调用从SQL此接口。</target>
        </trans-unit>
        <trans-unit id="2688b20853de688f9667ff56467cd11f77df2163" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_wal_checkpoint&quot;&gt;PRAGMA wal_checkpoint&lt;/a&gt; command can be used to invoke this interface from SQL.</source>
          <target state="translated">的&lt;a href=&quot;../pragma#pragma_wal_checkpoint&quot;&gt;PRAGMA wal_checkpoint&lt;/a&gt;命令可以被用来调用从SQL此接口。</target>
        </trans-unit>
        <trans-unit id="3d14328a2609f4c2f2e647906b7ed9c9b0a6470e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; statement.</source>
          <target state="translated">该&lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = ON&lt;/a&gt;语句。</target>
        </trans-unit>
        <trans-unit id="3c456ed19efa854514b7975cbb780401189b8da5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex&amp;gt;0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and is not checked again by SQLite.</source>
          <target state="translated">该&lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;方法必须填写aConstraintUsage []用什么参数传递给xFilter信息。如果argvIndex&amp;gt; 0，则将评估相应aConstraint []的右侧，并成为argv中的第argvIndex个条目。如果aConstraintUsage []。omit为true，则假定该约束已由虚拟表完全处理，并且SQLite不再对其进行检查。</target>
        </trans-unit>
        <trans-unit id="589ad4da98fc55a8cd1077ee9df3a71f69ad38f8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex&amp;gt;0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and might not be checked again by the byte code. The aConstraintUsage[].omit flag is an optimization hint. When the omit flag is left in its default setting of false, the constraint will always be checked separately in byte code. If the omit flag is change to true, then the constraint may or may not be checked in byte code. In other words, when the omit flag is true there is no guarantee that the constraint will not be checked again using byte code.</source>
          <target state="translated">该&lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;方法必须填写aConstraintUsage []用什么参数传递给xFilter信息。如果argvIndex&amp;gt; 0，则将评估相应aConstraint []的右侧，并成为argv中的第argvIndex个条目。如果aConstraintUsage []。omit为true，则假定该约束已由虚拟表完全处理，并且字节码可能不会再次对其进行检查。 aConstraintUsage []。omit标志是一个优化提示。当省略标志保留为默认设置false时，将始终以字节码单独检查约束。如果省略标志更改为true，则可以以字节码检查约束，也可以不以字节码检查约束。换句话说，当省略标志为true时，不能保证不会使用字节码再次检查约束。</target>
        </trans-unit>
        <trans-unit id="52eaec5cfbc452ed9aad230504ada3c60f5e208b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of a &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt; call this interface to declare the format (the names and datatypes of the columns) of the virtual tables they implement.</source>
          <target state="translated">&lt;a href=&quot;module&quot;&gt;虚拟表模块&lt;/a&gt;的&lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;和&lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;方法调用此接口以声明它们实现的虚拟表的格式（列的名称和数据类型）。</target>
        </trans-unit>
        <trans-unit id="bcf8720fcb25c1b9008caa098927de8f2ece3d5e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit&lt;/a&gt; document describes how SQLite implements transactions.</source>
          <target state="translated">该&lt;a href=&quot;atomiccommit&quot;&gt;原子提交&lt;/a&gt;文档描述工具如何SQLite的交易。</target>
        </trans-unit>
        <trans-unit id="eabaf2d0ed146df6465d7c01128019f3ef60888d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;atomiccommit&quot;&gt;atomic update capabilities&lt;/a&gt; of SQLite allow small incremental changes to be safely written into the document. This reduces total disk I/O and improves File/Save performance, enhancing the user experience.</source>
          <target state="translated">SQLite 的&lt;a href=&quot;atomiccommit&quot;&gt;原子更新功能&lt;/a&gt;允许将小的增量更改安全地写入文档中。这样可以减少总的磁盘I / O，并提高文件/保存性能，从而改善用户体验。</target>
        </trans-unit>
        <trans-unit id="08525d9bc082ee31e91cdcebab98cc6662084121" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; feature in SQLite works differently than it does in MySQL. This often causes confusion for people who initially learned SQL on MySQL and then start using SQLite, and expect the two systems to work identically.</source>
          <target state="translated">SQLite中的&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;功能与MySQL中的功能不同。这通常会使最初在MySQL上学习SQL然后又开始使用SQLite并期望这两个系统工作相同的人们感到困惑。</target>
        </trans-unit>
        <trans-unit id="bc38744c25dba895f9fced962c1bfedae8b7cde9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object itself is partially threadsafe. Multiple threads may safely make multiple concurrent calls to sqlite3_backup_step(). However, the sqlite3_backup_remaining() and sqlite3_backup_pagecount() APIs are not strictly speaking threadsafe. If they are invoked at the same time as another thread is invoking sqlite3_backup_step() it is possible that they return invalid values.</source>
          <target state="translated">所述&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象本身是部分线程。多个线程可以安全地同时调用sqlite3_backup_step（）。但是，严格说来，sqlite3_backup_remaining（）和sqlite3_backup_pagecount（）API并不是线程安全的。如果在另一个线程调用sqlite3_backup_step（）的同时调用它们，则可能返回无效值。</target>
        </trans-unit>
        <trans-unit id="218098ad11bde6e156b4a9f8e57ca75e25354cce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_zeroblob()&lt;/a&gt; and &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_zeroblob()&lt;/a&gt; interfaces and the built-in &lt;a href=&quot;../lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; SQL function may be used to create a zero-filled blob to read or write using the incremental-blob interface.</source>
          <target state="translated">所述&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_zeroblob（）&lt;/a&gt;和&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_zeroblob（）&lt;/a&gt;接口和内置在&lt;a href=&quot;../lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; SQL函数可以被用来创建一个零填充的斑点使用增量-Blob接口来读取或写入。</target>
        </trans-unit>
        <trans-unit id="c7e4db04e283ee079f91c197314578446dc39a21" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt; routine is used only in the implementations of aggregate and window functions. Scalar functions may not use &lt;a href=&quot;c3ref/aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;. The &lt;a href=&quot;c3ref/aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt; function is included in the interface list only for completeness.</source>
          <target state="translated">所述&lt;a href=&quot;c3ref/aggregate_context&quot;&gt;sqlite3_aggregate_context（）&lt;/a&gt;例程用于仅在聚集体和窗函数的实现。标量函数不能使用&lt;a href=&quot;c3ref/aggregate_context&quot;&gt;sqlite3_aggregate_context（）&lt;/a&gt;。该&lt;a href=&quot;c3ref/aggregate_context&quot;&gt;sqlite3_aggregate_context（）&lt;/a&gt;函数包含在仅用于补充接口列表。</target>
        </trans-unit>
        <trans-unit id="54f66c39b1fdccfb02fbdb0dd7e08e6474fe1802" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm()&lt;/a&gt; interface, which has been deprecated and undocumented for 8 years, is changed into a no-op.</source>
          <target state="translated">所述&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm（）&lt;/a&gt;接口，它已被弃用，无证8年，被改变为无操作。</target>
        </trans-unit>
        <trans-unit id="3cbc1814be35648af44f26835e6f82841778c411" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm&lt;/a&gt; routine is used to register a callback on memory allocation events. This routine registers or clears a callback that fires when the amount of memory allocated exceeds iThreshold. Only a single callback can be registered at a time. Each call to &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm()&lt;/a&gt; overwrites the previous callback. The callback is disabled by setting xCallback to a NULL pointer.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm&lt;/a&gt;例程用于注册的内存分配事件的回调。此例程注册或清除在分配的内存量超过iThreshold时触发的回调。一次只能注册一个回调。每次调用&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm（）都会&lt;/a&gt;覆盖之前的回调。通过将xCallback设置为NULL指针来禁用回调。</target>
        </trans-unit>
        <trans-unit id="fc7e34038a904f7366dde6ee090a8282d84ade6e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_thread_cleanup()&lt;/a&gt; interface has become a no-op.</source>
          <target state="translated">所述&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_thread_cleanup（）&lt;/a&gt;接口已经成为一个无操作。</target>
        </trans-unit>
        <trans-unit id="ac435cb36a069024ddc4f4287c8ff0d76c80af5c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;Online Backup API&lt;/a&gt; was created to address these concerns. The online backup API allows the contents of one database to be copied into another database, overwriting the original contents of the target database. The copy operation may be done incrementally, in which case the source database does not need to be locked for the duration of the copy, only for the brief periods of time when it is actually being read from. This allows other database users to continue uninterrupted while a backup of an online database is made.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;在线备份API&lt;/a&gt;是为了解决这些问题。在线备份API允许将一个数据库的内容复制到另一个数据库中，从而覆盖目标数据库的原始内容。复制操作可以增量方式进行，在这种情况下，在复制期间不需要锁定源数据库，而仅在实际读取源数据库的短暂时间段内将其锁定。这样，在进行联机数据库备份时，其他数据库用户可以继续不间断地运行。</target>
        </trans-unit>
        <trans-unit id="563d98f5bc61682f67da5d25a1062884fd2fdf5d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; interface does &lt;u&gt;not&lt;/u&gt; work for a union-vtab. BLOB content must be read from the union-vtab using ordinary SQL statements.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/blob_open&quot;&gt;sqlite3_blob_open（）&lt;/a&gt;接口并&lt;u&gt;没有&lt;/u&gt;对工会工作vtab。必须使用常规SQL语句从union-vtab中读取BLOB内容。</target>
        </trans-unit>
        <trans-unit id="b9d5c3998902d7d51338a9f7531152bceea38f9d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt;&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer callback&lt;/a&gt; is invoked once with a column name that is an empty string for every table referenced in a query from which no columns are extracted.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_READ &lt;/a&gt;&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;授权回调&lt;/a&gt;被调用一次与列名是在从没有列被提取的查询中引用的每个表一个空字符串。</target>
        </trans-unit>
        <trans-unit id="a68ee8ce42ad40a73650dbfe088fcf3e1c842ed0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt; run-time option and the &lt;a href=&quot;compile#enable_qpsg&quot;&gt;SQLITE_ENABLE_QPSG&lt;/a&gt; compile-time option enable the &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;query planner stability guarantee&lt;/a&gt;. See also ticket &lt;a href=&quot;https://www.sqlite.org/src/info/892fc34f173e99d8&quot;&gt;892fc34f173e99d8&lt;/a&gt;</source>
          <target state="translated">该&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt;运行时间选项和&lt;a href=&quot;compile#enable_qpsg&quot;&gt;SQLITE_ENABLE_QPSG&lt;/a&gt;编译时选项来启用&lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;查询规划的稳定性保证&lt;/a&gt;。另请参阅票证&lt;a href=&quot;https://www.sqlite.org/src/info/892fc34f173e99d8&quot;&gt;892fc34f173e99d8&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ba2430856bd9775a861cef9dfde7c36d65a2cc4c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; bit means that all writes to this device are atomic in the sense that either the entire write occurs or none of it occurs. The other &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;i&gt;nnn&lt;/i&gt;&lt;/a&gt; values indicate that writes of aligned blocks of the indicated size are atomic. &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SAFE_APPEND&lt;/a&gt; means that when extending a file with new data, the new data is written first and then the file size is updated. So if a power failure occurs, there is no chance that the file might have been extended with randomness. The &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SEQUENTIAL&lt;/a&gt; bit means that all writes occur in the order that they are issued and are not reordered by the underlying file system.</source>
          <target state="translated">所述&lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt;位装置，所有写入该设备是在要么整个写操作发生的意义上原子或它没有一个发生。其他&lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC &lt;i&gt;nnn&lt;/i&gt;&lt;/a&gt;值指示对指定大小的对齐块的写操作是原子的。&lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SAFE_APPEND&lt;/a&gt;表示在使用新数据扩展文件时，首先写入新数据，然后更新文件大小。因此，如果发生电源故障，则不可能随机扩展文件。该&lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SEQUENTIAL&lt;/a&gt;位意味着所有的写操作发生在它们被发出，而不是由底层文件系统重新排序的顺序。</target>
        </trans-unit>
        <trans-unit id="9a653d67bd1da50ffe32f058a08a81d4f6edcd9e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; flag means the file should be deleted when it is closed. This will always be set for TEMP databases and journals and for subjournals. The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; flag means the file should be opened for exclusive access. This flag is set for all files except for the main database file. The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; structure passed as the third argument to xOpen is allocated by the caller. xOpen just fills it in. The caller allocates a minimum of szOsFile bytes for the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; structure.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt;标志意味着当它关闭该文件应予删除。将始终为TEMP数据库和日记以及子期刊设置此设置。该&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt;标志意味着该文件应以独占访问打开。为除主数据库文件以外的所有文件设置此标志。作为第三个参数传递给xOpen 的&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;结构由调用方分配。 xOpen只是填充它。调用方为&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;结构分配最少的szOsFile字节。</target>
        </trans-unit>
        <trans-unit id="229110ee7251c5cf9b125b0ef0813a6c6ba215fe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; and &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flags to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; can also be used to adjust the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; of individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; at run-time.</source>
          <target state="translated">&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;的&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;和&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;标志还可用于在运行时调整各个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;的&lt;a href=&quot;threadsafe&quot;&gt;线程模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="966cc2ea77fca46efeb8c4289b4a653605ed43e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; option was added to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;选项被添加到&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="abc999536061a5d7a156494c35b1ed191a9effbf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_type()&lt;/a&gt; function returns the datatype for the value in the Nth column. The return value is one of these:</source>
          <target state="translated">所述&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_type（）&lt;/a&gt;函数返回在第N列中的值的数据类型。返回值是以下之一：</target>
        </trans-unit>
        <trans-unit id="cffa274dabb801c01eb4f4986ad5f8726b7dca26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt; function returns the number of columns in the results set. sqlite3_column_count() can be called at any time after &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count()&lt;/a&gt; works similarly to &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt; except that it only works following &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. If the previous call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; returned SQLITE_DONE or an error code, then &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count()&lt;/a&gt; will return 0 whereas &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt; will continue to return the number of columns in the result set.</source>
          <target state="translated">所述&lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count（）&lt;/a&gt;函数返回的结果集的列数。在sqlite3_prepare_v2（）之后可以随时调用&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_column_count（）&lt;/a&gt;。&lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count（）&lt;/a&gt;与&lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count（）&lt;/a&gt;相似，但仅在&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）之后&lt;/a&gt;起作用。如果先前对&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）的&lt;/a&gt;调用返回了SQLITE_DONE或错误代码，则&lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count（）&lt;/a&gt;将返回0，而&lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count（）&lt;/a&gt;将继续返回结果集中的列数。</target>
        </trans-unit>
        <trans-unit id="df909dfd5bdc309e3368846cb0f8c21a5731a3d2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface is used to make global, process-wide configuration changes for SQLite. The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface must be called before any &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; are created. The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface allows the programmer to do things like:</source>
          <target state="translated">所述&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;接口是用来制造用于SQLite的全球性的，过程范围的配置变化。在创建任何&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;之前，必须调用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;接口。该&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;接口允许程序员在做这样的事情：</target>
        </trans-unit>
        <trans-unit id="7eb7ccb56d39b4e4c7e512ab71314c715b6ea1d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;,1) interfaces was invoked at start-time.</source>
          <target state="translated">所述&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;，1）的接口是在起动时调用。</target>
        </trans-unit>
        <trans-unit id="faa946b5075b7749c61a0c77f6eb5fe8e812f89c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt; routine returns a pointer to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; object.</source>
          <target state="translated">所述&lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle（）&lt;/a&gt;例程返回一个指向&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="00c837fffcba80492d406ed18ba293449ca9513c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt; interface is used to create new &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt; for sorting text. The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; interface is used to register new &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementations. The &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface creates new &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collat​​ion（）&lt;/a&gt;接口被用来创建新的&lt;a href=&quot;datatype3#collation&quot;&gt;整理序列&lt;/a&gt;进行排序文本。所述&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module（）&lt;/a&gt;接口用于登记新的&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;的实现。该&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;接口创建新&lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="965853485ed37d427cfb8a0c73c9695bbb338f24" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; family of interfaces is used to create new custom SQL functions. Each member of this family is a wrapper around a common core. All family members accomplish the same thing; they merely have different calling signatures.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;系列接口用于创建新的自定义SQL函数。这个家庭的每个成员都是围绕着一个共同核心的包装。所有家庭成员都完成同一件事；它们只是具有不同的呼叫签名。</target>
        </trans-unit>
        <trans-unit id="a4c521e07609cbfdb8d566dab7163fc87d422895" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; family of interfaces now return &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; instead of &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; when passed invalid parameter combinations.</source>
          <target state="translated">当传递无效的参数组合时，&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;系列接口现在返回&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;而不是&lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="caf6561662b932f66438111d53034fa55d79a49d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface can be used to override the like() function and thereby change the operation of the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator. When overriding the like() function, it may be important to override both the two and three argument versions of the like() function. Otherwise, different code may be called to implement the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator depending on whether or not an ESCAPE clause was specified.</source>
          <target state="translated">所述&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;接口可用于覆盖等（）函数，从而改变的操作&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;运算符。覆盖like（）函数时，同时覆盖like（）函数的两个和三个参数版本可能很重要。否则，根据是否指定了ESCAPE子句，可以调用不同的代码来实现&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;运算符。</target>
        </trans-unit>
        <trans-unit id="a6b630ee12d42fc4528bfc71d36f585a36895111" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface creates new SQL functions - either scalar or aggregate. The new function implementation typically makes use of the following additional interfaces:</source>
          <target state="translated">该&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;接口创建新的SQL功能-无论是标量或集合。新功能的实现通常利用以下附加接口：</target>
        </trans-unit>
        <trans-unit id="99635893a7742a2b0a9430ca501d241e5f7023c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; and &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; interfaces return SQLITE_MISUSE on any attempt to overload or replace a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; module. The destructor is always called in this case, in accordance with historical and current documentation.</source>
          <target state="translated">如果尝试重载或替换&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;模块，则&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module（）&lt;/a&gt;和&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2（）&lt;/a&gt;接口将返回SQLITE_MISUSE 。在这种情况下，根据历史和当前文档始终会调用析构函数。</target>
        </trans-unit>
        <trans-unit id="0e7c498dc9b696b8a3e4e1f8ce0b76687320b809" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; and &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; routines associates a module name with an &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; structure and a separate client data that is specific to each module. The only difference between the two create_module methods is that the _v2 method includes an extra parameter that specifies a destructor for client data pointer. The module structure is what defines the behavior of a virtual table. The module structure looks like this:</source>
          <target state="translated">所述&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module（）&lt;/a&gt;和&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2（）&lt;/a&gt;例程相关联的模块名称与一个&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt;结构和特定于每个模块的单独客户机数据。这两个create_module方法之间的唯一区别是_v2方法包括一个额外的参数，该参数指定客户端数据指针的析构函数。模块结构定义了虚拟表的行为。模块结构如下所示：</target>
        </trans-unit>
        <trans-unit id="ea2068b9a7520d6dd4dead5bbb83fc7b95e63987" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatusdeferredfks&quot;&gt;SQLITE_DBSTATUS_DEFERRED_FKS&lt;/a&gt;,...) C-language interface can be used during a transaction to determine if there are deferred and unresolved foreign key constraints.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status&lt;/a&gt;（DB，&lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatusdeferredfks&quot;&gt;SQLITE_DBSTATUS_DEFERRED_FKS&lt;/a&gt;，...）C语言界面，可以在交易期间使用，以确定是否有延迟和未解决的外键约束。</target>
        </trans-unit>
        <trans-unit id="5d823f649e66e357a40f8457ae11a89f890b8312" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; interface now applies to all threads within a process, not to just the one thread in which it was run.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）&lt;/a&gt;接口现在适用于所有线程的过程中，不只是在它被运行一个线程。</target>
        </trans-unit>
        <trans-unit id="dc8c7487a7241b1b53f75118a25cdfbd803a1bd5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; function works much as it did in SQLite version 2. Zero or more SQL statements specified in the second parameter are compiled and executed. Query results are returned to a callback routine.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（） &lt;/a&gt;，因为它在SQLite的版本2.零或在第二个参数中指定多个SQL语句没有被编译并执行功能工作起来。查询结果返回到回调例程。</target>
        </trans-unit>
        <trans-unit id="060e03cab55fa6e258498e740c2441a904ee6a9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; interface is a convenience wrapper that carries out all four of the above steps with a single function call. A callback function passed into &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; is used to process each row of the result set. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; is another convenience wrapper that does all four of the above steps. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; interface differs from &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; in that it stores the results of queries in heap memory rather than invoking a callback.</source>
          <target state="translated">的&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;接口是一个方便的包装，其执行与一个函数调用上述步骤全部四个。传递给&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）的&lt;/a&gt;回调函数用于处理结果集的每一行。所述&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;是另一种方便的包装，做上述步骤全部四个。所述&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;从接口不同&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（），&lt;/a&gt;它存储在堆存储器的查询的结果，而不是调用的回调。</target>
        </trans-unit>
        <trans-unit id="c55eb24f412d567a8152cd959c8adf08902c2ff0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface works on any prepared statement created using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;. It is no longer necessary to use &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; with &lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparenormalize&quot;&gt;SQLITE_PREPARE_NORMALIZE&lt;/a&gt; in order to use &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql（）&lt;/a&gt;使用创建的任何准备好的声明中接口的工作原理&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3（） &lt;/a&gt;。它不再需要使用&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;与&lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparenormalize&quot;&gt;SQLITE_PREPARE_NORMALIZE&lt;/a&gt;以使用&lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b367904a5b319d97004324430003a01cf6b1ae72" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object represents an open file. The xOpen method of &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; constructs an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object when the file is opened. The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; keeps track of the state of the file while it is opened.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;对象代表一个打开的文件。打开文件时，&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;的xOpen方法构造一个&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;对象。该&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;保持它被打开，而跟踪文件的状态。</target>
        </trans-unit>
        <trans-unit id="64a6d4c58c9877ecd1b62378eb5e65c884bd0f45" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface can be used to set an upper bound on the total amount of outstanding memory that the general-purpose memory allocator for SQLite will allow to be outstanding at one time. If attempts are made to allocate more memory than specified by the soft heap limit, then SQLite will first attempt to free cache memory before continuing with the allocation request. The soft heap limit mechanism only works if &lt;a href=&quot;malloc#memstatus&quot;&gt;memory statistics&lt;/a&gt; are enabled and it works best if the SQLite library is compiled with the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option.</source>
          <target state="translated">所述&lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64（）&lt;/a&gt;接口可用于设置上界未完成的存储器的总量，对于SQLite的通用内存分配器将允许一次未完成的。如果尝试分配的内存超出了软堆限制所指定的数量，则SQLite将首先尝试释放缓存内存，然后再继续分配请求。软堆限制机制仅在启用了&lt;a href=&quot;malloc#memstatus&quot;&gt;内存统计信息的&lt;/a&gt;情况下才有效，并且如果使用&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;编译时选项编译SQLite库，则其效果最佳。</target>
        </trans-unit>
        <trans-unit id="b30882c8710d7d3a10831e6a935d755bd7e25652" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure is used to pass information into and out of the xBestIndex method of the module that implements a virtual table.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;结构用于传递信息流入和流出所述模块实现的虚拟表的xBestIndex方法。</target>
        </trans-unit>
        <trans-unit id="c68c89f6fed7e1292abcc19abd161e51c2b5b49a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; interface can be called to explicitly initialize the SQLite subsystem. The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; interface is called automatically when invoking certain interfaces so the use of &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; is not required, but it is recommended.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;接口，可称为明确初始化SQLite的子系统。该&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;调用某些接口时，所以使用的界面，自动调用&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;不是必需的，但建议。</target>
        </trans-unit>
        <trans-unit id="086866a1ce9981846c47e35c1af526651c7809af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; interface causes SQLite to release any system resources (memory allocations, mutexes, open file handles) that might have been allocated by &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;接口使SQLite的释放可能已被分配的任何系统资源（内存分配，互斥，打开的文件句柄）&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18eeb48351b373543379c24e8aba67998ec2d5d9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; interface frees all mutexes under windows.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;接口释放Windows下所有互斥。</target>
        </trans-unit>
        <trans-unit id="f14f29a4830a0488c9f404caad392cc8f7efd81d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; routine can be called for a different thread</source>
          <target state="translated">该&lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt（）&lt;/a&gt;程序可以要求不同的线程</target>
        </trans-unit>
        <trans-unit id="78920df495dd4dfe901c1e207965f56317d12fca" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object holds the methods used to interact with an open file. Each &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; contains a pointer to an &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object that is appropriate for the file it represents. The &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object contains methods to do things such as read and write from the file, to truncate the file, to flush any changes to persistent storage, to find the size of the file, to lock and unlock the file, and to close file and destroy the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象包含用于交互与打开的文件的方法。每个&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;包含一个指向&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象的指针，该对象适合于它所代表的文件。该&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象包含的方法做事情，如从文件读取和写入，截断文件，将刷新到永久存储的任何变化，找到该文件的大小，锁定和解锁文件，并关闭文件和销毁&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="899386dff25e21c6b737c3d54a2f1045b6441f0a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object is a structure that contains pointers to methods for reading, writing, and otherwise dealing with files. This object is defined as follows:</source>
          <target state="translated">该&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象是包含指向方法阅读，写作，并以其他方式处理文件的结构。该对象定义如下：</target>
        </trans-unit>
        <trans-unit id="1277e9425f23dd50c872910508a38720a4c40a0c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt; function tries to detect if the source code has been modified from what is checked into version control and if there are modifications, the last four characters of the version hash are shown as &quot;alt1&quot; or &quot;alt2&quot;. The objective is to detect accidental and/or careless edits. A forger can subvert this feature.</source>
          <target state="translated">所述&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid（）&lt;/a&gt;函数尝试检测如果源代码已经从什么签入版本控制改性，如果有改进，则版本散列的最后四个字符被显示为&amp;ldquo;ALT1&amp;rdquo;或&amp;ldquo;ALT2&amp;rdquo;。目的是检测意外和/或粗心的编辑。伪造者可以破坏此功能。</target>
        </trans-unit>
        <trans-unit id="e51a6d9f987aab5062f7ef525db57b1e02273eb7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface loads an &lt;a href=&quot;loadext&quot;&gt;extension&lt;/a&gt; into a single database connection. The default behavior is for that extension to be automatically unloaded when the database connection closes. However, if the extension entry point returns SQLITE_OK_LOAD_PERMANENTLY instead of SQLITE_OK, then the extension remains loaded into the process address space after the database connection closes. In other words, the xDlClose methods of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is not called for the extension when the database connection closes.</source>
          <target state="translated">所述&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;界面载荷的&lt;a href=&quot;loadext&quot;&gt;扩展&lt;/a&gt;成一个单一的数据库连接。默认行为是在数据库连接关闭时自动卸载该扩展名。但是，如果扩展入口点返回SQLITE_OK_LOAD_PERMANENTLY而不是SQLITE_OK，则在数据库连接关闭后，扩展将保持加载到进程地址空间中。换句话说，当数据库连接关闭时，不会为扩展名调用&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的xDlClose方法。</target>
        </trans-unit>
        <trans-unit id="e180768903c106d7d176b62ab434360e88ec87ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interfaces are deprecated. The equivalent functionality is now available through &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;和&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;接口已被弃用。现在可以通过&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status（）&lt;/a&gt;获得等效的功能。</target>
        </trans-unit>
        <trans-unit id="46ea088bdd6bab93bd39ac4df39be5b9d52d9d73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interfaces, the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64&lt;/a&gt;(&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;) interface, and the &lt;a href=&quot;compile#max_memory&quot;&gt;SQLITE_MAX_MEMORY&lt;/a&gt; compile-time option are all non-functional when memory usage tracking is disabled.</source>
          <target state="translated">禁用内存使用情况跟踪时，&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;和&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;接口，&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64&lt;/a&gt;（&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;）接口和&lt;a href=&quot;compile#max_memory&quot;&gt;SQLITE_MAX_MEMORY&lt;/a&gt;编译时选项均不起作用。</target>
        </trans-unit>
        <trans-unit id="8f1193a5998521b29a68d3af0690b60d457381cf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; structure defines a module object used to implement a virtual table. Think of a module as a class from which one can construct multiple virtual tables having similar properties. For example, one might have a module that provides read-only access to comma-separated-value (CSV) files on disk. That one module can then be used to create several virtual tables where each virtual table refers to a different CSV file.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt;结构定义了用于实现虚拟表的模块对象。将模块视为一类，从中可以构造具有相似属性的多个虚拟表。例如，可能有一个模块可以提供对磁盘上逗号分隔值（CSV）文件的只读访问。然后，可以使用该模块创建几个虚拟表，其中每个虚拟表都引用一个不同的CSV文件。</target>
        </trans-unit>
        <trans-unit id="26e5c834aec9a24795809e8d9018891e41492180" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_enter()&lt;/a&gt; attempts to enter the mutex and blocks if another threads is already there. &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_try()&lt;/a&gt; attempts to enter and returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success or &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if another thread is already there. &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave()&lt;/a&gt; exits a mutex. The mutex is held until the number of exits matches the number of entrances. If &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave()&lt;/a&gt; is called on a mutex that the thread is not currently holding, then the behavior is undefined. If any routine is called for a deallocated mutex, then the behavior is undefined.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_enter（）&lt;/a&gt;试图进入互斥和块，如果另一个线程已经存在。&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_try（）&lt;/a&gt;试图进入并返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;成功或&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;如果另一个线程已经存在。&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave（）&lt;/a&gt;退出互斥量。互斥锁将保持到出口数量与入口数量匹配为止。如果在线程当前不持有的互斥对象上调用&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave（）&lt;/a&gt;，则行为未定义。如果为释放的互斥量调用了任何例程，则该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="6f27ad8fcfe5b9da304436aec019b4cf39a32876" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_free()&lt;/a&gt; routine should be used to deallocate a non-static mutex. If a static mutex is passed to this routine then the behavior is undefined.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_free（）&lt;/a&gt;例行应该用于删除非静态互斥。如果将静态互斥锁传递给此例程，则该行为是不确定的。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
