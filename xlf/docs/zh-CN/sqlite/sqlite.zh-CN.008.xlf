<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="4297ce915073f569ab40d9b2eef2a6a433c9c771" translate="yes" xml:space="preserve">
          <source>Fix a long-standing bug in the byte-code engine that can cause a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; command report as success when in fact it failed to commit. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/810dc8038872e212&quot;&gt;810dc8038872e212&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e421af2a92eeb75b68bc6dee75d2cded7fea49f" translate="yes" xml:space="preserve">
          <source>Fix a long-standing bug in the query planner that caused incorrect results on a LEFT JOIN where the left-hand table is a subquery and the join constraint is a bare column name coming from the left-hand subquery. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/2df0107b&quot;&gt;2df0107b&lt;/a&gt;.</source>
          <target state="translated">修复了查询计划器中的一个长期错误，该错误在LEFT JOIN上导致错误的结果，在LEFT JOIN上，左表是子查询，而联接约束是来自左子查询的裸列名称。门票&lt;a href=&quot;https://www.sqlite.org/src/info/2df0107b&quot;&gt;2df0107b&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5fd66bb0d12f0c4694325a08e38b8332a42b240a" translate="yes" xml:space="preserve">
          <source>Fix a long-standing bug in the storage engine that would (very rarely) cause a spurious report of an SQLITE_CORRUPT error but which was otherwise harmless. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/6bfb98dfc0c&quot;&gt;6bfb98dfc0c&lt;/a&gt;.</source>
          <target state="translated">修复了存储引擎中的一个长期存在的错误，该错误（很少）会导致伪造的SQLITE_CORRUPT错误报告，但否则不会造成损害。票证&lt;a href=&quot;http://www.sqlite.org/src/info/6bfb98dfc0c&quot;&gt;6bfb98dfc0c&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="71423e6b2d68869ba9f90d3de52635f50c9c7337" translate="yes" xml:space="preserve">
          <source>Fix a long-standing problem in &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables that was reported a few hours after the 3.8.11 release.</source>
          <target state="translated">修正了长期存在的问题&lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes（）&lt;/a&gt;为&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;已报告几个小时3.8.11发布后的表。</target>
        </trans-unit>
        <trans-unit id="29e8d63f91df6bbd58bdb3b0c96b08a128597488" translate="yes" xml:space="preserve">
          <source>Fix a long-standing problem wherein a corrupt schema on the &lt;a href=&quot;fileformat2#seqtab&quot;&gt;sqlite_sequence&lt;/a&gt; table used by &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; can lead to a crash. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d8dc2b3a58cd5dc29&quot;&gt;d8dc2b3a58cd5dc2918a1&lt;/a&gt;</source>
          <target state="translated">修复了一个长期存在的问题，其中&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;使用的&lt;a href=&quot;fileformat2#seqtab&quot;&gt;sqlite_sequence&lt;/a&gt;表上的架构损坏可能导致崩溃。门票&lt;a href=&quot;https://www.sqlite.org/src/info/d8dc2b3a58cd5dc29&quot;&gt;d8dc2b3a58cd5dc2918a1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d123dda0b40a993f6ee01005258efb1310831bb" translate="yes" xml:space="preserve">
          <source>Fix a memory allocation error in the new ADD COLUMN comment.</source>
          <target state="translated">修正新的ADD COLUMN注释中的内存分配错误。</target>
        </trans-unit>
        <trans-unit id="557f85fef49a7d6b5ef7280b85eaabf9d86a9cbc" translate="yes" xml:space="preserve">
          <source>Fix a memory leak that can occur following a disk I/O error.</source>
          <target state="translated">修复磁盘I/O错误后可能发生的内存泄漏。</target>
        </trans-unit>
        <trans-unit id="b2e50e850f4bad5e2b888790e4a27dda05de65d0" translate="yes" xml:space="preserve">
          <source>Fix a memory leak that can occur following a failure to open error in the &lt;a href=&quot;csv&quot;&gt;CSV virtual table&lt;/a&gt;</source>
          <target state="translated">修复在&lt;a href=&quot;csv&quot;&gt;CSV虚拟表中&lt;/a&gt;无法打开错误后可能发生的内存泄漏</target>
        </trans-unit>
        <trans-unit id="08e2d33c27f7ca8760cc5e591fecb5972898df17" translate="yes" xml:space="preserve">
          <source>Fix a memory leak that occurred when sqlite_open() failed.</source>
          <target state="translated">修复sqlite_open()失败时发生的内存泄漏。</target>
        </trans-unit>
        <trans-unit id="475ca6beba2ec99949495af6c237c0b95d23fba9" translate="yes" xml:space="preserve">
          <source>Fix a missing &quot;sync&quot; that when omitted could lead to database corruption if a power failure or OS crash occurred just as a ROLLBACK operation was finishing.</source>
          <target state="translated">修复了一个缺失的 &quot;同步&quot;,如果在ROLLBACK操作刚刚结束时发生断电或操作系统崩溃,可能会导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="dd148f4d09fd6cc6bad30b19733a82972a2cebe0" translate="yes" xml:space="preserve">
          <source>Fix a naming conflict between sqlite.h and sqlite3.h.</source>
          <target state="translated">修正 sqlite.h 和 sqlite3.h 之间的命名冲突。</target>
        </trans-unit>
        <trans-unit id="86cbab0ce9e871e04d98798d23ca791be9552d16" translate="yes" xml:space="preserve">
          <source>Fix a parser bug that prevented the use of parentheses around table-valued functions.</source>
          <target state="translated">修复了一个解析器错误,防止在表值函数周围使用括号。</target>
        </trans-unit>
        <trans-unit id="1ea82017fb31c1e817b4ca5fcdba2b68c62a7e38" translate="yes" xml:space="preserve">
          <source>Fix a performance bug in the pager cache, ticket #3844</source>
          <target state="translated">修复了一个寻呼机缓存的性能问题,票号3844。</target>
        </trans-unit>
        <trans-unit id="0b4a31de7ab7e54e3e4f0e6dd796fb43aef54770" translate="yes" xml:space="preserve">
          <source>Fix a performance regression on LEFT JOIN (see ticket #3015) that was mistakenly introduced in &lt;a href=&quot;#version_3_5_8&quot;&gt;version 3.5.8&lt;/a&gt;.</source>
          <target state="translated">修复&lt;a href=&quot;#version_3_5_8&quot;&gt;3.5.8版&lt;/a&gt;中错误引入的LEFT JOIN的性能回归（请参见故障单＃3015）。</target>
        </trans-unit>
        <trans-unit id="51a1cd95a4c2ce3fd6ef13919dca1d81326877a9" translate="yes" xml:space="preserve">
          <source>Fix a performance regression related to the query planner enhancements of version 3.7.0.</source>
          <target state="translated">修正与3.7.0版本的查询规划器改进有关的性能回归。</target>
        </trans-unit>
        <trans-unit id="59850e50fa6095504ef5b88efd743956885d3a6e" translate="yes" xml:space="preserve">
          <source>Fix a possible infinite loop on VACUUM for corrupt database files. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/27754b74ddf64&quot;&gt;27754b74ddf64&lt;/a&gt;</source>
          <target state="translated">修复了VACUUM上可能损坏数据库文件的无限循环的问题。入住&lt;a href=&quot;https://www.sqlite.org/src/info/27754b74ddf64&quot;&gt;27754b74ddf64&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="16de14f899013ff24b7caea8ce7237c3023ffe3c" translate="yes" xml:space="preserve">
          <source>Fix a possible segfault with DELETE when table is a &lt;a href=&quot;rowidtable&quot;&gt;rowid table&lt;/a&gt; with an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; and the WHERE clause contains a OR and the table has one or more indexes that are able to trigger the OR optimization, but none of the indexes reference any table columns other than the INTEGER PRIMARY KEY. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/16c9801ceba49&quot;&gt;16c9801ceba49&lt;/a&gt;.</source>
          <target state="translated">当表是具有&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;的&lt;a href=&quot;rowidtable&quot;&gt;Rowid表&lt;/a&gt;且WHERE子句包含OR且表具有一个或多个能够触发OR优化的索引但没有索引引用任何表列时，使用DELETE修复可能的段错误除了整数主键。机票&lt;a href=&quot;https://www.sqlite.org/src/info/16c9801ceba49&quot;&gt;16c9801ceba49&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d502547575294f85b69c2db2bf60e7be17520a7d" translate="yes" xml:space="preserve">
          <source>Fix a potential 32-bit integer overflow problem in the &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;c3ref/blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; interfaces.</source>
          <target state="translated">修复了&lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;和&lt;a href=&quot;c3ref/blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;接口中潜在的32位整数溢出问题。</target>
        </trans-unit>
        <trans-unit id="86abca115efafefa4d8227ca90c204f72ac25973" translate="yes" xml:space="preserve">
          <source>Fix a potential buffer overread that could result when trying to search a corrupt database file.</source>
          <target state="translated">修复了在搜索损坏的数据库文件时可能导致的缓冲区超读。</target>
        </trans-unit>
        <trans-unit id="e6cf1ce475579b639fd9a6e590dcc754d75c144f" translate="yes" xml:space="preserve">
          <source>Fix a potential database corruption bug that can occur if version 3.7.0 and version 3.6.23.1 alternately write to the same database file. &lt;a href=&quot;http://www.sqlite.org/src/info/51ae9cad317a1&quot;&gt; Ticket [51ae9cad317a1]&lt;/a&gt;</source>
          <target state="translated">修复了3.7.0版和3.6.23.1版交替写入同一数据库文件时可能发生的数据库损坏错误。&lt;a href=&quot;http://www.sqlite.org/src/info/51ae9cad317a1&quot;&gt;门票[51ae9cad317a1]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2326ddb13e351e1098f9d7af1605ec053a972e00" translate="yes" xml:space="preserve">
          <source>Fix a potential database corruption problem on Unix caused by the fact that all POSIX advisory locks are cleared whenever you close() a file. The work around it to embargo all close() calls while locks are outstanding.</source>
          <target state="translated">修复了Unix上一个潜在的数据库损坏问题,这个问题是由每当你关闭()一个文件时,所有POSIX咨询锁都会被清除。绕过它的工作是在锁尚未清除时禁止所有close()调用。</target>
        </trans-unit>
        <trans-unit id="3c1404201cf0f45ed7d26fb3ee3e025fabad8654" translate="yes" xml:space="preserve">
          <source>Fix a potential integer overflow problem when compiling a particular horrendous common table expression. This was another problem discovered by OSSFuzz. Check-in &lt;a href=&quot;https://sqlite.org/src/info/6ee8cb6ae5&quot;&gt;6ee8cb6ae5&lt;/a&gt;.</source>
          <target state="translated">修复了在编译特定的可怕公用表表达式时可能出现的整数溢出问题。这是OSSFuzz发现的另一个问题。入住&lt;a href=&quot;https://sqlite.org/src/info/6ee8cb6ae5&quot;&gt;6ee8cb6ae5&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fa021a738435d20102aefd6ba8aa9227f2196bfd" translate="yes" xml:space="preserve">
          <source>Fix a potential memory leak in &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; processing. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/2df6bbf1b8ca8&quot;&gt;2df6bbf1b8ca8&lt;/a&gt;</source>
          <target state="translated">修复&lt;a href=&quot;rowvalue&quot;&gt;行值&lt;/a&gt;处理中潜在的内存泄漏。入住&lt;a href=&quot;https://www.sqlite.org/src/info/2df6bbf1b8ca8&quot;&gt;2df6bbf1b8ca8&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d59a5b1204741917d207d0911c7f5b60cccb2e8" translate="yes" xml:space="preserve">
          <source>Fix a potential memory leak in the new &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; interface. Ticket &lt;a href=&quot;https://sqlite.org/src/info/7486aa54b968e9b5&quot;&gt;7486aa54b968e9b5&lt;/a&gt;.</source>
          <target state="translated">修复新的&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;接口中的潜在内存泄漏。机票&lt;a href=&quot;https://sqlite.org/src/info/7486aa54b968e9b5&quot;&gt;7486aa54b968e9b5&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c9b94c0ee4da7edac18db1b27719d5740439e09" translate="yes" xml:space="preserve">
          <source>Fix a potential out-of-bound read when querying a corrupt database file, a problem detected by Natalie Silvanovich of Google Project Zero. Check-in &lt;a href=&quot;https://sqlite.org/src/info/04925dee41a21f&quot;&gt;04925dee41a21f&lt;/a&gt;.</source>
          <target state="translated">修复了查询损坏的数据库文件时可能发生的越界读取的问题，该问题由Google Project Zero的Natalie Silvanovich检测到。入住&lt;a href=&quot;https://sqlite.org/src/info/04925dee41a21f&quot;&gt;04925dee41a21f&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94450756c5f997edafdb983263e971e139725961" translate="yes" xml:space="preserve">
          <source>Fix a potential segfault in complex recursive triggers, resulting from a bug in the OP_Once opcode introduced as part of a performance optimization in version 3.15.0. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/06796225f59c057c&quot;&gt;06796225f59c057c&lt;/a&gt;</source>
          <target state="translated">修复了复杂递归触发器中的潜在段错误，该错误是由于3.15.0版性能优化中引入的OP_Once操作码中的错误而导致的。机票&lt;a href=&quot;https://www.sqlite.org/src/info/06796225f59c057c&quot;&gt;06796225f59c057c&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9c23851f526115afe862ef20f590dcfe854957d3" translate="yes" xml:space="preserve">
          <source>Fix a potential segfault when destroying locks on WinCE in a multi-threaded environment.</source>
          <target state="translated">修复了多线程环境下在WinCE上销毁锁时的潜在segfault。</target>
        </trans-unit>
        <trans-unit id="c5254d73f95694f4312acfaaba5e2519c7f711c7" translate="yes" xml:space="preserve">
          <source>Fix a problem in &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; that can result in a corrupt database containing two or more rows with the same &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f68dc596c4e6018d&quot;&gt;f68dc596c4e6018d&lt;/a&gt;.</source>
          <target state="translated">修复了&lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt;中的一个问题，该问题可能导致包含两个或多个具有相同&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid的&lt;/a&gt;行的数据库损坏。修复票证&lt;a href=&quot;https://www.sqlite.org/src/info/f68dc596c4e6018d&quot;&gt;f68dc596c4e6018d&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cce51ec3d9eafc83d9bef6eb168bd83fba551391" translate="yes" xml:space="preserve">
          <source>Fix a problem in &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; that was causing a subsequent &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; to behave suboptimally.</source>
          <target state="translated">修复&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA完整性检查&lt;/a&gt;中的一个问题，该问题导致随后的&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;表现欠佳。</target>
        </trans-unit>
        <trans-unit id="e2ab7efe53f641d1c01e53f622fc41a617719096" translate="yes" xml:space="preserve">
          <source>Fix a problem in CSV import in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; where if the leftmost field of the first row in the CSV file was both zero bytes in size and unquoted no data would be imported.</source>
          <target state="translated">修复了&lt;a href=&quot;cli&quot;&gt;命令行外壳&lt;/a&gt; CSV导入中的问题，如果CSV文件中第一行的最左侧字段的大小均为零字节且未加引号，则不会导入任何数据。</target>
        </trans-unit>
        <trans-unit id="b8e5e51fd7781a4a270ea3403c1d91e18539fa5d" translate="yes" xml:space="preserve">
          <source>Fix a problem in FTS4 where the left-most column that contained the &lt;a href=&quot;fts3#fts4notindexed&quot;&gt;notindexed column&lt;/a&gt; name as a prefix was not indexed rather than the column whose name matched exactly.</source>
          <target state="translated">修复了FTS4中的一个问题，该问题包含未索引的&lt;a href=&quot;fts3#fts4notindexed&quot;&gt;列&lt;/a&gt;名称作为前缀的最左边的列，而不是其名称完全匹配的列，未被索引。</target>
        </trans-unit>
        <trans-unit id="ed16f1842283c33640adef4111628a226934ccb4" translate="yes" xml:space="preserve">
          <source>Fix a problem in the &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; interface that could cause problems for the &lt;a href=&quot;json1&quot;&gt;json1&lt;/a&gt; extension under obscure circumstances. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f45ac567eaa9f9&quot;&gt;f45ac567eaa9f9&lt;/a&gt;.</source>
          <target state="translated">修复&lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype（）&lt;/a&gt;接口中的问题，该问题在晦涩的情况下可能导致&lt;a href=&quot;json1&quot;&gt;json1&lt;/a&gt;扩展出现问题。修复票务&lt;a href=&quot;https://www.sqlite.org/src/info/f45ac567eaa9f9&quot;&gt;f45ac567eaa9f9&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7871f6059f0a9d8ae6199f7ed5e914925c1946d3" translate="yes" xml:space="preserve">
          <source>Fix a problem in the query planner that results when a row-value expression is used with a PRIMARY KEY with redundant columns. Ticket &lt;a href=&quot;https://sqlite.org/src/info/1a84668dcfdebaf12415d&quot;&gt;1a84668dcfdebaf12415d&lt;/a&gt;</source>
          <target state="translated">修复了将行值表达式与带有冗余列的PRIMARY KEY一起使用时在查询计划程序中导致的问题。门票&lt;a href=&quot;https://sqlite.org/src/info/1a84668dcfdebaf12415d&quot;&gt;1a84668dcfdebaf12415d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ee14ad300b53edffc750ba4ada032439baf8cf04" translate="yes" xml:space="preserve">
          <source>Fix a problem in the virtual table commit mechanism that was causing a crash in FTS3. Ticket #3497.</source>
          <target state="translated">修正虚拟表提交机制中导致FTS3崩溃的问题。Ticket #3497.</target>
        </trans-unit>
        <trans-unit id="367c86dcc3176132b397b28f7554be7148358015" translate="yes" xml:space="preserve">
          <source>Fix a problem that was causing excess memory usage with large &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; transactions in win32 systems.</source>
          <target state="translated">修复了导致Win32系统中的大型&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;事务导致过多内存使用的问题。</target>
        </trans-unit>
        <trans-unit id="e4c5c3190d6e5398a03cc1624a8ad085afe03197" translate="yes" xml:space="preserve">
          <source>Fix a problem that was causing poor performance when many thousands of SQL statements were executed by a single sqlite_exec() call.</source>
          <target state="translated">修复了当一个sqlite_exec()调用执行成千上万条SQL语句时导致性能不佳的问题。</target>
        </trans-unit>
        <trans-unit id="d6546ef65a68047eca9a74f928d58465048048f8" translate="yes" xml:space="preserve">
          <source>Fix a problem that will corrupt the database file if you drop a table from the main database that has a TEMP index.</source>
          <target state="translated">修复了一个问题,如果从主数据库中删除一个有TEMP索引的表,会损坏数据库文件。</target>
        </trans-unit>
        <trans-unit id="6a895d74574faf7c3e5b7c17bfc4a1aebd1bd35a" translate="yes" xml:space="preserve">
          <source>Fix a problem that will corrupt the indices on a table if you do an INSERT OR REPLACE or an UPDATE OR REPLACE on a table that contains an INTEGER PRIMARY KEY plus one or more indices.</source>
          <target state="translated">修复了一个问题,如果你对一个包含INTEGER PRIMARY KEY加上一个或多个索引的表进行INSERT或REPLACE或UPDATE或REPLACE,会损坏表的索引。</target>
        </trans-unit>
        <trans-unit id="fa339d6b0d5c93a4f64854920f80fba0a5a92e67" translate="yes" xml:space="preserve">
          <source>Fix a problem where &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;PRAGMA count_changes&lt;/a&gt; was causing incorrect results for updates on tables with triggers</source>
          <target state="translated">修复了&lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;PRAGMA count_changes&lt;/a&gt;导致使用触发器更新表的结果不正确的问题</target>
        </trans-unit>
        <trans-unit id="2367f688e4ee0ae00d13a38bb5c62a10fab4c4f9" translate="yes" xml:space="preserve">
          <source>Fix a problem with 3-way joins that do not use indices</source>
          <target state="translated">修正一个不使用索引的3向连接的问题。</target>
        </trans-unit>
        <trans-unit id="fc131893314d3ec5912c469546ad607795fe252a" translate="yes" xml:space="preserve">
          <source>Fix a problem with &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; which could cause transactions to silently rollback if the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt; is set very small (less than 10) and SQLite comes under memory pressure.</source>
          <target state="translated">修复了&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;的问题，如果将&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt;设置得非常小（小于10）并且SQLite处于内存压力下，则可能导致事务以静默方式回滚。</target>
        </trans-unit>
        <trans-unit id="1f2f150e12c534df43b52ade585282148590c894" translate="yes" xml:space="preserve">
          <source>Fix a problem with VACUUM on databases from which tables containing AUTOINCREMENT have been dropped.</source>
          <target state="translated">修复了数据库中包含AUTOINCREMENT表的VACUUM的问题。</target>
        </trans-unit>
        <trans-unit id="e98ac2eb09507917a285747f2d5bd3a4164f2534" translate="yes" xml:space="preserve">
          <source>Fix a problem with string memory management in the VDBE</source>
          <target state="translated">修正VDBE中字符串内存管理的问题</target>
        </trans-unit>
        <trans-unit id="1c1c998fb53575b975370a5727818e77b27c3b5a" translate="yes" xml:space="preserve">
          <source>Fix a problem with the &lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;LEFT JOIN strength reduction optimization&lt;/a&gt; in which the optimization was being applied inappropriately due to an IS NOT NULL operator. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/5948e09b8c415bc45d&quot;&gt;5948e09b8c415bc45d&lt;/a&gt;.</source>
          <target state="translated">修复了&lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;LEFT JOIN强度降低优化&lt;/a&gt;的问题，该问题由于IS NOT NULL运算符而不适当地应用了该优化。机票&lt;a href=&quot;https://www.sqlite.org/src/info/5948e09b8c415bc45d&quot;&gt;5948e09b8c415bc45d&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3e42c3e04422e8992158af198fdedf65d8a494b4" translate="yes" xml:space="preserve">
          <source>Fix a problem with the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; on &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d96eba87698a428c1d&quot;&gt;d96eba87698a428c1d&lt;/a&gt;.</source>
          <target state="translated">修正了该问题&lt;a href=&quot;optoverview#or_opt&quot;&gt;或优化&lt;/a&gt;的&lt;a href=&quot;expridx&quot;&gt;表达式索引&lt;/a&gt;。票证&lt;a href=&quot;https://www.sqlite.org/src/info/d96eba87698a428c1d&quot;&gt;d96eba87698a428c1d&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a552a20d99699b5fa85e0ed7fb142721053399d9" translate="yes" xml:space="preserve">
          <source>Fix a problem with the multi-row one-pass DELETE optimization that was causing it to compute incorrect answers with a self-referential subquery in the WHERE clause. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/dc6ebeda9396087&quot;&gt;dc6ebeda9396087&lt;/a&gt;</source>
          <target state="translated">修复了多行单遍DELETE优化问题，该问题导致它使用WHERE子句中的自引用子查询来计算错误答案。修复票证&lt;a href=&quot;https://www.sqlite.org/src/info/dc6ebeda9396087&quot;&gt;dc6ebeda9396087&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="070ed03b719700575899432a2c98f057535dbcc4" translate="yes" xml:space="preserve">
          <source>Fix a problem with the new &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt; implementation that caused a malfunction when complicated expressions involving window functions were used inside of a view.</source>
          <target state="translated">修复了新的&lt;a href=&quot;windowfunctions&quot;&gt;窗口函数&lt;/a&gt;实现的问题，当在视图内部使用涉及窗口函数的复杂表达式时，该问题会导致故障。</target>
        </trans-unit>
        <trans-unit id="ef0924214b0eb9fe23d46afbb07aaf1261d67d0a" translate="yes" xml:space="preserve">
          <source>Fix a problem with the sort order when comparing upper-case strings against characters greater than 'Z' but less than 'a'.</source>
          <target state="translated">修复了在比较大写字符串与大于'Z'但小于'a'的字符时的排序顺序问题。</target>
        </trans-unit>
        <trans-unit id="5e753a491c25e8edb1492253042a4e79f112f875" translate="yes" xml:space="preserve">
          <source>Fix a problem with the use of &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt; used within &lt;a href=&quot;lang_expr#cosub&quot;&gt;correlated subqueries&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d0866b26f83e9c55e3&quot;&gt;d0866b26f83e9c55e3&lt;/a&gt;</source>
          <target state="translated">解决在&lt;a href=&quot;lang_expr#cosub&quot;&gt;相关子查询中&lt;/a&gt;使用&lt;a href=&quot;windowfunctions&quot;&gt;窗口函数&lt;/a&gt;的问题。门票&lt;a href=&quot;https://www.sqlite.org/src/info/d0866b26f83e9c55e3&quot;&gt;D0866B26F83E9C55E3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="551f44e055f1b2367c902fea7be697c804fc97a8" translate="yes" xml:space="preserve">
          <source>Fix a problem with using the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt; on an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/b850dd159918af56&quot;&gt;b850dd159918af56&lt;/a&gt;.</source>
          <target state="translated">解决了在&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;上使用&lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE优化&lt;/a&gt;的问题。入住&lt;a href=&quot;https://www.sqlite.org/src/info/b850dd159918af56&quot;&gt;b850dd159918af56&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="293886e1e2fac8f6d1689e1a0e83ac48f4add2fd" translate="yes" xml:space="preserve">
          <source>Fix a query planner bug involving a LEFT JOIN with a BETWEEN or LIKE/GLOB constraint and then another INNER JOIN to the right that involves an OR constraint.</source>
          <target state="translated">修复了一个查询规划器的错误,涉及到一个带有BETWEEN或LIKE/GLOB约束的LEFT JOIN,然后在右边又有一个涉及OR约束的INNER JOIN。</target>
        </trans-unit>
        <trans-unit id="8ff17cc556a87f30aa15241b1ac5c7a361de91a4" translate="yes" xml:space="preserve">
          <source>Fix a query planner bug that could result in a segfault when querying tables with a UNIQUE or PRIMARY KEY constraint with more than four columns.</source>
          <target state="translated">修复了一个查询规划器的bug,当查询带有UNIQUE或PRIMARY KEY约束的表时,如果表的列数超过4列,则可能导致segfault。</target>
        </trans-unit>
        <trans-unit id="9fb45458b64cd84ba2a2f30a7bfee1435ad64176" translate="yes" xml:space="preserve">
          <source>Fix a query planner bug that might cause a table to be scanned in the wrong direction (thus reversing the order of output) when a DESC index is used to implement the ORDER BY clause on a query that has an identical GROUP BY clause. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/ba7cbfaedc7e6&quot;&gt;ba7cbfaedc7e6&lt;/a&gt;.</source>
          <target state="translated">修复了查询计划程序错误，当使用DESC索引在具有相同GROUP BY子句的查询上实现ORDER BY子句时，可能会导致表扫描方向错误（从而反转输出顺序）。门票&lt;a href=&quot;http://www.sqlite.org/src/info/ba7cbfaedc7e6&quot;&gt;ba7cbfaedc7e6&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="09bdfd52ac4cb9f3c70abc6d5f401e62168b1225" translate="yes" xml:space="preserve">
          <source>Fix a query planner problem that could result in an incorrect answer due to the use of &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; in subqueries in the FROM clause of a correlated scalar subqueries. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/8a2adec1&quot;&gt;8a2adec1&lt;/a&gt;.</source>
          <target state="translated">修复了一个查询计划程序问题，该问题可能由于在相关标量子查询的FROM子句中的子查询中使用&lt;a href=&quot;optoverview#autoindex&quot;&gt;自动索引&lt;/a&gt;而导致错误的答案。修复票&lt;a href=&quot;https://www.sqlite.org/src/info/8a2adec1&quot;&gt;8a2adec1&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3db45cb5a06554ceffd3c2fab04e67abb9573838" translate="yes" xml:space="preserve">
          <source>Fix a race condition in AUTOVACUUM that can lead to corrupt databases</source>
          <target state="translated">修复AUTOVACUUM中可能导致数据库损坏的竞赛条件。</target>
        </trans-unit>
        <trans-unit id="96a8e915a1becae62cd060b6c6ea6fdc08fd0da2" translate="yes" xml:space="preserve">
          <source>Fix a race condition in test_async.c.</source>
          <target state="translated">修正了test_async.c中的一个竞赛条件。</target>
        </trans-unit>
        <trans-unit id="625e5e94c16544ff24dd9e860382b39ea7c80a87" translate="yes" xml:space="preserve">
          <source>Fix a segfault that can occur for queries that use table-valued functions in an IN or EXISTS subquery. Ticket &lt;a href=&quot;https://sqlite.org/src/info/b899b6042f97f5&quot;&gt;b899b6042f97f5&lt;/a&gt;</source>
          <target state="translated">修复了在IN或EXISTS子查询中使用表值函数的查询可能发生的段错误。门票&lt;a href=&quot;https://sqlite.org/src/info/b899b6042f97f5&quot;&gt;b899b6042f97f5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a280dd5a4ba61a6ed5b8a4172311dcec663fd176" translate="yes" xml:space="preserve">
          <source>Fix a serious bug in the INSERT command which was causing data to go into the wrong columns if the data source was a SELECT and the INSERT clauses specified its columns in some order other than the default.</source>
          <target state="translated">修复了INSERT命令中的一个严重错误,如果数据源是SELECT,并且INSERT子句指定了其列的顺序,而不是默认的顺序,则会导致数据进入错误的列。</target>
        </trans-unit>
        <trans-unit id="a11d09fcf4c5c4f534bed3e95aeaedc75d2eadb8" translate="yes" xml:space="preserve">
          <source>Fix a strange (but valid) C declaration that was causing problems for QNX. No logical changes.</source>
          <target state="translated">修复了一个奇怪的(但有效的)C 语言声明,它给 QNX 带来了问题。无逻辑变化。</target>
        </trans-unit>
        <trans-unit id="7c6a164c4c1dd8fe7b071d0ade9de88fbde73880" translate="yes" xml:space="preserve">
          <source>Fix a typos in the sqlite3ext.h header file that prevented the &lt;a href=&quot;c3ref/stmt_isexplain&quot;&gt;sqlite3_stmt_isexplain()&lt;/a&gt; and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_frombind()&lt;/a&gt; interfaces from being called from &lt;a href=&quot;loadext&quot;&gt;run-time loadable extensions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a54239aed950f147b9530647f9884464a8a7700" translate="yes" xml:space="preserve">
          <source>Fix a use-after-free that can occur when SQLite is compiled with -DSQLITE_HAS_CODEC.</source>
          <target state="translated">修正当SQLite使用-DSQLITE_HAS_CODEC编译时可能发生的use-after-free。</target>
        </trans-unit>
        <trans-unit id="65b8ad24259b51f708505579d558096b74643e0f" translate="yes" xml:space="preserve">
          <source>Fix an 64-bit alignment bug on HP/UX and Sparc</source>
          <target state="translated">修正HP/UX和Sparc上的64位对齐错误。</target>
        </trans-unit>
        <trans-unit id="8d3940a154d321cca0d2eb2aa13ea157138409fd" translate="yes" xml:space="preserve">
          <source>Fix an &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; issue in which the 'optimize' command could cause index corruption.</source>
          <target state="translated">修复了&amp;ldquo;优化&amp;rdquo;命令可能导致索引损坏的&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;问题。</target>
        </trans-unit>
        <trans-unit id="cf27be06b87f8658f160d75e065a66b3575cb593" translate="yes" xml:space="preserve">
          <source>Fix an &lt;a href=&quot;http://www.sqlite.org/src/info/5e10420e8d&quot;&gt; old and very obscure bug&lt;/a&gt; that can lead to corruption of the database &lt;a href=&quot;fileformat2#freelist&quot;&gt;free-page list&lt;/a&gt; when &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; is used.</source>
          <target state="translated">修复了一个&lt;a href=&quot;http://www.sqlite.org/src/info/5e10420e8d&quot;&gt;古老且非常模糊的错误&lt;/a&gt;，该错误可能在使用&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;增量式&lt;/a&gt;&lt;a href=&quot;fileformat2#freelist&quot;&gt;真空&lt;/a&gt;时导致数据库空闲页列表损坏。</target>
        </trans-unit>
        <trans-unit id="2b834d02e62a3f123a1b8d14a7dd0d0f55d7a363" translate="yes" xml:space="preserve">
          <source>Fix an alignment problem on 64-bit machines</source>
          <target state="translated">修正64位机器上的对齐问题</target>
        </trans-unit>
        <trans-unit id="22b28f14aad0849b7f089af3e0ae2de83c9cc448" translate="yes" xml:space="preserve">
          <source>Fix an assertion failure that occurred when deleting all rows of a table with the &quot;count_changes&quot; pragma turned on.</source>
          <target state="translated">修正在开启 &quot;count_changes &quot;pragma的情况下,删除表的所有行时发生的断言失败。</target>
        </trans-unit>
        <trans-unit id="24c083d9fe654c2c6b13e8a4783ebdcf071478d1" translate="yes" xml:space="preserve">
          <source>Fix an assertion fault that can occur when updating the NULL value of a field at the end of a table that was added using &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ADD COLUMN&lt;/a&gt;.</source>
          <target state="translated">修复了在使用&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ADD COLUMN&lt;/a&gt;添加的表的末尾更新字段的NULL值时可能发生的断言错误。</target>
        </trans-unit>
        <trans-unit id="24c0b7a3124e531d424b372570a621483ca0c334" translate="yes" xml:space="preserve">
          <source>Fix an assertion fault that could occur following &lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;PRAGMA reverse_unordered_selects&lt;/a&gt;. Ticket &lt;a href=&quot;https://sqlite.org/src/info/cb91bf4290c211d&quot;&gt;cb91bf4290c211d&lt;/a&gt;</source>
          <target state="translated">修复了&lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;PRAGMA reverse_unordered_selects之后&lt;/a&gt;可能发生的断言错误。门票&lt;a href=&quot;https://sqlite.org/src/info/cb91bf4290c211d&quot;&gt;cb91bf4290c211d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="28b592fe11bf16075b14f304072980cfa741f4d3" translate="yes" xml:space="preserve">
          <source>Fix an assertion fault that occurred on deeply nested views.</source>
          <target state="translated">修复深度嵌套的视图发生的断言故障。</target>
        </trans-unit>
        <trans-unit id="5a204d98c949cf8975212c05340c51bd92e0547a" translate="yes" xml:space="preserve">
          <source>Fix an assertion fault that was coming up when the expression in an index-on-expressions is really a constant. Ticket &lt;a href=&quot;https://sqlite.org/src/info/aa98619ad08ddca&quot;&gt;aa98619ad08ddca&lt;/a&gt;</source>
          <target state="translated">修复当表达式索引中的表达式确实是常量时出现的断言错误。门票&lt;a href=&quot;https://sqlite.org/src/info/aa98619ad08ddca&quot;&gt;AA98619AD08DDCA&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5edfc637acd59a3db220a001c5781ab4bd7de9b5" translate="yes" xml:space="preserve">
          <source>Fix an index corruption issue introduced by &lt;a href=&quot;#version_3_8_7&quot;&gt;version 3.8.7&lt;/a&gt;. An index with a TEXT key can be corrupted by an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; into the corresponding table if the table has two nested triggers that convert the key value to INTEGER and back to TEXT again. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/34cd55d68e0e6e7c9a0711aab81a2ee3c354b4c0&quot;&gt;34cd55d68e0&lt;/a&gt;</source>
          <target state="translated">修复了&lt;a href=&quot;#version_3_8_7&quot;&gt;版本3.8.7&lt;/a&gt;引入的索引损坏问题。如果表具有两个嵌套的触发器，这些触发器将键值转换为INTEGER并再次返回到TEXT，则&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;可以将带有TEXT键的索引破坏到相应的表中。门票&lt;a href=&quot;https://www.sqlite.org/src/info/34cd55d68e0e6e7c9a0711aab81a2ee3c354b4c0&quot;&gt;34cd55d68e0&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8eeeaac39b440e493474edfe8a18c8edd3970590" translate="yes" xml:space="preserve">
          <source>Fix an infinite-loop in the query planner that could occur on malformed &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt;.</source>
          <target state="translated">修复查询计划器中可能在格式不正确的&lt;a href=&quot;lang_with&quot;&gt;公用表表达式&lt;/a&gt;上发生的无限循环。</target>
        </trans-unit>
        <trans-unit id="e7f2f6913b7c03deeb2b6b41e2ed3b92c354b90f" translate="yes" xml:space="preserve">
          <source>Fix an internal code generator problem that was causing some &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operations to no-op. Ticket &lt;a href=&quot;https://sqlite.org/src/info/ef360601&quot;&gt;ef360601&lt;/a&gt;</source>
          <target state="translated">修复了一个内部代码生成器问题，该问题导致某些&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;操作变为无操作。门票&lt;a href=&quot;https://sqlite.org/src/info/ef360601&quot;&gt;ef360601&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="337ef48955d3bd9a0a84bd4a9dd181f41e6cabab" translate="yes" xml:space="preserve">
          <source>Fix an issue in the fsdir(PATH) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; to the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/fileio.c&quot;&gt;fileio.c&lt;/a&gt; extension, that caused a segfault if the fsdir() table was used as the inner table of a join. Problem reported on the mailing list and fixed by check-in &lt;a href=&quot;https://www.sqlite.org/src/info/7ce4e71c1b7251be&quot;&gt;7ce4e71c1b7251be&lt;/a&gt;</source>
          <target state="translated">将fsdir（PATH）&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数中&lt;/a&gt;的问题修复为&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/fileio.c&quot;&gt;fileio.c&lt;/a&gt;扩展名，如果将fsdir（）表用作联接的内部表，则会导致segfault。问题已在邮件列表中报告并由签入&lt;a href=&quot;https://www.sqlite.org/src/info/7ce4e71c1b7251be&quot;&gt;7ce4e71c1b7251be解决&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f2b91637b2c2c39f1dab693ce0e485fd3cd7d63" translate="yes" xml:space="preserve">
          <source>Fix an issue with incorrect sharing of VDBE temporary registers between co-routines that could cause incorrect query results in obscure cases. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d06a25c84454a&quot;&gt;d06a25c84454a&lt;/a&gt;.</source>
          <target state="translated">修复了在例程之间不正确共享VDBE临时寄存器的问题，这种情况在晦涩的情况下可能导致错误的查询结果。机票&lt;a href=&quot;https://www.sqlite.org/src/info/d06a25c84454a&quot;&gt;d06a25c84454a&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7c984a9789b89b098bf54d9a87bf8ad24379596a" translate="yes" xml:space="preserve">
          <source>Fix an obscure and relatively harmless problem that might have caused a resource leak following an I/O error.</source>
          <target state="translated">修复了一个不明显的、相对无害的问题,这个问题可能在I/O错误后造成资源泄漏。</target>
        </trans-unit>
        <trans-unit id="9af5e2e7bb886d04f6d1d3a91c18b1bcfc2e680c" translate="yes" xml:space="preserve">
          <source>Fix an obscure bug that can cause database corruption under the following unusual circumstances: A large INSERT or UPDATE statement which is part of an even larger transaction fails due to a uniqueness constraint but the containing transaction commits.</source>
          <target state="translated">修复了一个不明显的bug,在以下不寻常的情况下会导致数据库损坏。一个大的INSERT或UPDATE语句是一个更大的事务的一部分,由于唯一性约束而失败,但包含的事务提交。</target>
        </trans-unit>
        <trans-unit id="0096a0fca1b6b43797d06b363272bd306cbf7ce9" translate="yes" xml:space="preserve">
          <source>Fix an obscure bug that can cause database corruption under the following unusual circumstances: A large INSERT or UPDATE statement which is part of an even larger transaction fails due to a uniqueness contraint but the containing transaction commits.</source>
          <target state="translated">修复了一个不明显的bug,在以下不寻常的情况下会导致数据库损坏。一个大的INSERT或UPDATE语句是一个更大的事务的一部分,由于唯一性缺陷而失败,但包含的事务却提交了。</target>
        </trans-unit>
        <trans-unit id="ce8d90d9be96ff29e6eda51d841a97e900370a1d" translate="yes" xml:space="preserve">
          <source>Fix an obscure memory leak in &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;. Ticket &lt;a href=&quot;https://sqlite.org/src/info/7486aa54b968e9b&quot;&gt;7486aa54b968e9b&lt;/a&gt;</source>
          <target state="translated">修复&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）中&lt;/a&gt;晦涩的内存泄漏。机票&lt;a href=&quot;https://sqlite.org/src/info/7486aa54b968e9b&quot;&gt;7486aa54b968e9b&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9faef411a2ddeadaf79ebd73389c10f7af52120" translate="yes" xml:space="preserve">
          <source>Fix an obscure segfault in UTF-8 to UTF-16 conversions</source>
          <target state="translated">修正UTF-8到UTF-16转换中的一个不明显的segfault。</target>
        </trans-unit>
        <trans-unit id="b5c1f0802c64a77b99076bfc9059cf131dd55807" translate="yes" xml:space="preserve">
          <source>Fix an off-by-one error that caused quoted empty string at the end of a CRNL-terminated line of CSV input to be misread by the command-line shell.</source>
          <target state="translated">修复了一个逐个错误,导致命令行 shell 误读 CSV 输入的 CRNL 结尾处引用的空字符串。</target>
        </trans-unit>
        <trans-unit id="30b0fd93ee02b86cc24f6cc7bd2523397f033eee" translate="yes" xml:space="preserve">
          <source>Fix an optimizer bug involving subqueries in a compound SELECT that has both an ORDER BY and a LIMIT clause. Ticket #2339.</source>
          <target state="translated">修正一个优化器错误,涉及到一个复合 SELECT 中的子查询,该子查询同时具有 ORDER BY 和 LIMIT 子句。Ticket #2339.</target>
        </trans-unit>
        <trans-unit id="683ed4e4563f819c0aec9579fc2147e259103b73" translate="yes" xml:space="preserve">
          <source>Fix an optimizer bug that could have caused some unusual LEFT OUTER JOINs to give incorrect results.</source>
          <target state="translated">修复了一个优化器错误,该错误可能会导致一些不寻常的LEFT OUTER JOINs给出不正确的结果。</target>
        </trans-unit>
        <trans-unit id="762e5ec5f054c66d660a449bf35057af7025d512" translate="yes" xml:space="preserve">
          <source>Fix an uninitialized variable in pager.c which could (with a probability of about 1 in 4 billion) result in a corrupted database.</source>
          <target state="translated">修正 pager.c 中一个未初始化的变量,这个变量可能会导致数据库损坏(概率约为 40 亿分之一)。</target>
        </trans-unit>
        <trans-unit id="4ff50f16c16225e491f827922f36f0a1b00ee9e8" translate="yes" xml:space="preserve">
          <source>Fix another bug in the IS NULL optimization that was added in version 3.3.9.</source>
          <target state="translated">修正3.3.9版本中新增的IS NULL优化中的另一个bug。</target>
        </trans-unit>
        <trans-unit id="e8f06a6dcd8a035bb10d1fb00994a8c1617f3e5c" translate="yes" xml:space="preserve">
          <source>Fix another bug in the implementation of the new &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; API. We'll get it right eventually...</source>
          <target state="translated">修复了新的&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt; API 的实现中的另一个错误。我们最终会正确的...</target>
        </trans-unit>
        <trans-unit id="6f129ae803d9883975a2438f98f71935a3f57c27" translate="yes" xml:space="preserve">
          <source>Fix bugs in pager.c that could lead to database corruption if two processes both try to recover a hot journal at the same instant</source>
          <target state="translated">修正pager.c中的bug,如果两个进程同时试图恢复一个热日志,可能会导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="e51c167c962ab37e883d84e10e98aee9dad05d15" translate="yes" xml:space="preserve">
          <source>Fix bugs in the implementation of the new &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; API that can lead to segfaults.</source>
          <target state="translated">修复了新的&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt; API 的实现中的错误，该错误可能导致段错误。</target>
        </trans-unit>
        <trans-unit id="15b10b87ff343116def15b81c85457d634788432" translate="yes" xml:space="preserve">
          <source>Fix bugs that can (rarely) lead to incorrect query results when the CAST or OR operators are used in the WHERE clause of a query.</source>
          <target state="translated">修复当在查询的WHERE子句中使用CAST或OR运算符时,可能(很少)导致错误的查询结果的错误。</target>
        </trans-unit>
        <trans-unit id="3d935fe3f3737292749bd1972d56f443d7c93968" translate="yes" xml:space="preserve">
          <source>Fix byte alignment problems on 64-bit architectures.</source>
          <target state="translated">修复64位架构上的字节对齐问题。</target>
        </trans-unit>
        <trans-unit id="7bca40ab59e8b9695f58ea94f5115e8c80d7a7c3" translate="yes" xml:space="preserve">
          <source>Fix commenting errors and improve the comments generated on &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; listings when the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">当使用&lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt;编译时选项时，修复注释错误并改进在&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;列表上生成的注释。</target>
        </trans-unit>
        <trans-unit id="f6a563b99fee018f87bcc6d45b57949ce6d02874" translate="yes" xml:space="preserve">
          <source>Fix data races that might occur under stress when running with many threads in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; where some of the threads are opening and closing connections.</source>
          <target state="translated">修复了在&lt;a href=&quot;sharedcache&quot;&gt;共享缓存模式&lt;/a&gt;下使用许多线程运行某些线程正在打开和关闭连接时，在压力下可能发生的数据争用问题。</target>
        </trans-unit>
        <trans-unit id="3810fcb3cfb91e5274e7723b80500a70b2e4eef7" translate="yes" xml:space="preserve">
          <source>Fix data structure alignment issues on Sparc. Ticket #3777.</source>
          <target state="translated">修正 Sparc 上的数据结构对齐问题。票号3777。</target>
        </trans-unit>
        <trans-unit id="a7f89cd0a1f20da8469d2ab54509c35e86684ab3" translate="yes" xml:space="preserve">
          <source>Fix editline support in the command-line shell.</source>
          <target state="translated">修正命令行shell中的编辑行支持。</target>
        </trans-unit>
        <trans-unit id="87d44c2123224749ec741fa602897daad30b0e0b" translate="yes" xml:space="preserve">
          <source>Fix for a bug in the ORDER BY optimizer that was introduced in &lt;a href=&quot;#version_3_7_15&quot;&gt;version 3.7.15&lt;/a&gt; which would sometimes optimize out the sorting step when in fact the sort was required. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/a179fe7465&quot;&gt;a179fe7465&lt;/a&gt;</source>
          <target state="translated">修复了&lt;a href=&quot;#version_3_7_15&quot;&gt;3.7.15版&lt;/a&gt;中引入的ORDER BY优化器中的错误，该错误有时会在实际上需要排序时优化排序步骤。机票&lt;a href=&quot;http://www.sqlite.org/src/info/a179fe7465&quot;&gt;A179FE7465&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0a782f7686d7d9707b5dc5190d2cb994db1da8ac" translate="yes" xml:space="preserve">
          <source>Fix for a bug in the SELECT DISTINCT logic that was introduced by the prior version.</source>
          <target state="translated">修正了上一版本引入的SELECT DISTINCT逻辑中的一个错误。</target>
        </trans-unit>
        <trans-unit id="293d91bd4dad89365956202fbbdc05193695a217" translate="yes" xml:space="preserve">
          <source>Fix for another problem (unrelated to the one fixed in 2.1.4) that sometimes causes &lt;b&gt;sqlite_exec()&lt;/b&gt; to return SQLITE_PROTOCOL unnecessarily. This time the bug was in the POSIX locking code and should not effect Windows users.</source>
          <target state="translated">解决了另一个问题（与2.1.4中修复的问题无关），该问题有时会导致&lt;b&gt;sqlite_exec（）&lt;/b&gt;不必要地返回SQLITE_PROTOCOL。这次，该错误位于POSIX锁定代码中，并且不会影响Windows用户。</target>
        </trans-unit>
        <trans-unit id="692cc3acdf11cc382c710566eb5e8d41ae9a76e6" translate="yes" xml:space="preserve">
          <source>Fix inconsistent integer to floating-point comparison operations that could result in a corrupt index if the index is created on a table column that contains both large integers and floating point values of similar magnitude. Ticket &lt;a href=&quot;https://www.sqlite.org/src/tktview?name=38a97a87a6&quot;&gt;38a97a87a6&lt;/a&gt;.</source>
          <target state="translated">将不一致的整数修复为浮点比较操作，如果在包含大整数和相似大小的浮点值的表列上创建索引，则可能导致索引损坏。机票&lt;a href=&quot;https://www.sqlite.org/src/tktview?name=38a97a87a6&quot;&gt;38a97a87a6&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cbe4713574b5e7e1bf3ea574e5968f7da369b174" translate="yes" xml:space="preserve">
          <source>Fix incorrect result with complex OR-connected WHERE and STAT4. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/ec32177c99ccac2&quot;&gt;ec32177c99ccac2&lt;/a&gt;</source>
          <target state="translated">使用复杂的或连接的WHERE和STAT4修复错误的结果。门票&lt;a href=&quot;https://www.sqlite.org/src/info/ec32177c99ccac2&quot;&gt;ec32177c99ccac2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="32ba32659ea655886bad57a0dd08fbe5d98856b9" translate="yes" xml:space="preserve">
          <source>Fix locking behavior under Windows</source>
          <target state="translated">修正Windows下的锁定行为</target>
        </trans-unit>
        <trans-unit id="1f35665eab7b4eb2d565f64daa7ab9de3e2952ac" translate="yes" xml:space="preserve">
          <source>Fix many obscure problems discovered while &lt;a href=&quot;testing#fuzztesting&quot;&gt;SQL fuzzing&lt;/a&gt;.</source>
          <target state="translated">修复&lt;a href=&quot;testing#fuzztesting&quot;&gt;SQL模糊测试时&lt;/a&gt;发现的许多晦涩问题。</target>
        </trans-unit>
        <trans-unit id="8e786cb80b44d5b0bc787df47e982713af4c0ff9" translate="yes" xml:space="preserve">
          <source>Fix many potential segfaults that could be caused by malicious SQL statements.</source>
          <target state="translated">修复许多可能由恶意SQL语句引起的潜在segfaults。</target>
        </trans-unit>
        <trans-unit id="0ab2336b4ec301e575c6d8af5dd4486d9002cf92" translate="yes" xml:space="preserve">
          <source>Fix memory leaks that used to occur after a malloc() failure.</source>
          <target state="translated">修复过去在malloc()失败后发生的内存泄漏。</target>
        </trans-unit>
        <trans-unit id="6b6c482ed533b8d025b0b530bd86fd284d9ab805" translate="yes" xml:space="preserve">
          <source>Fix memory size tracking so that it works even if SQLite uses more than 2GiB of memory.</source>
          <target state="translated">修复内存大小跟踪,使其在SQLite使用超过2GiB的内存时也能工作。</target>
        </trans-unit>
        <trans-unit id="83c4e0c639eeed5339ef3f3550050703ea306329" translate="yes" xml:space="preserve">
          <source>Fix minor issues with the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;.</source>
          <target state="translated">修复&lt;a href=&quot;dbstat&quot;&gt;dbstat虚拟表的&lt;/a&gt;小问题。</target>
        </trans-unit>
        <trans-unit id="6d8fc1c13727f748ff40e9e6be94b0b7005ead11" translate="yes" xml:space="preserve">
          <source>Fix misbehavior of the FTS5 xBestIndex method. Ticket &lt;a href=&quot;https://sqlite.org/src/info/2b8aed9f7c9e61e8&quot;&gt;2b8aed9f7c9e61e8&lt;/a&gt;.</source>
          <target state="translated">修复FTS5 xBestIndex方法的不良行为。票证&lt;a href=&quot;https://sqlite.org/src/info/2b8aed9f7c9e61e8&quot;&gt;2b8aed9f7c9e61e8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d6aeb35ac1eb7c66584445cf87b55f99254ca966" translate="yes" xml:space="preserve">
          <source>Fix more bugs in the LEFT JOIN &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7fde638e94287d2c&quot;&gt;7fde638e94287d2c&lt;/a&gt;.</source>
          <target state="translated">修复LEFT JOIN展&lt;a href=&quot;optoverview#flattening&quot;&gt;平优化&lt;/a&gt;中的更多错误。机票&lt;a href=&quot;https://www.sqlite.org/src/info/7fde638e94287d2c&quot;&gt;7fde638e94287d2c&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1506d1bb252e85d5b0e36b68a46cf1665d4a7c8f" translate="yes" xml:space="preserve">
          <source>Fix more problems with rollback. Enhance the test suite to exercise the rollback logic extensively in order to prevent any future problems.</source>
          <target state="translated">修正更多回滚的问题。加强测试套件,广泛地练习回滚逻辑,以防止任何未来的问题。</target>
        </trans-unit>
        <trans-unit id="3fb27e5b00960417518969df0f918d06f25d9624" translate="yes" xml:space="preserve">
          <source>Fix multiple bugs that can occur following a malloc() failure.</source>
          <target state="translated">修复malloc()失败后可能出现的多个bug。</target>
        </trans-unit>
        <trans-unit id="8252f0ee7c2b56c6e1d2a3ae12fb9ec74fcaf061" translate="yes" xml:space="preserve">
          <source>Fix obscure crash bugs found by &lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;american fuzzy lop&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/a59ae93ee990a55&quot;&gt;a59ae93ee990a55&lt;/a&gt;.</source>
          <target state="translated">修复&lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;美国模糊fuzzy&lt;/a&gt;发现的晦涩的崩溃错误。门票&lt;a href=&quot;https://www.sqlite.org/src/info/a59ae93ee990a55&quot;&gt;a59ae93ee990a55&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="029dc6c7c9dc876556264390601510f43467cb42" translate="yes" xml:space="preserve">
          <source>Fix other minor problems with using small soft heap limits.</source>
          <target state="translated">修复使用小软堆限制的其他小问题。</target>
        </trans-unit>
        <trans-unit id="2953bbeca888101c80fba41134554ee3b46a5872" translate="yes" xml:space="preserve">
          <source>Fix portability problems for MinGW/MSYS.</source>
          <target state="translated">修正MinGW/MSYS的可移植性问题。</target>
        </trans-unit>
        <trans-unit id="46269c4cd0e4bb26c3e434c946d6ad61c56e3d22" translate="yes" xml:space="preserve">
          <source>Fix potential corruption in &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt; due to automatic datatype conversions. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/343634942dd54ab&quot;&gt;343634942dd54ab&lt;/a&gt;</source>
          <target state="translated">修复由于自动数据类型转换而导致&lt;a href=&quot;expridx&quot;&gt;表达式索引中&lt;/a&gt;潜在的损坏。机票&lt;a href=&quot;https://www.sqlite.org/src/info/343634942dd54ab&quot;&gt;343634942dd54ab&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e4b60b2ce1e9e806c6a1d1ab2efe5b7b8417ffc" translate="yes" xml:space="preserve">
          <source>Fix problems found on 64-bit systems.</source>
          <target state="translated">修复64位系统上发现的问题。</target>
        </trans-unit>
        <trans-unit id="07f0a4d00027e8a55978e27f100b7e116a031b97" translate="yes" xml:space="preserve">
          <source>Fix problems with the handling of ORDER BY expressions on compound SELECT statements in subqueries.</source>
          <target state="translated">修正子查询中复合SELECT语句的ORDER BY表达式的处理问题。</target>
        </trans-unit>
        <trans-unit id="3f1665257f79bd93e546dd7e3d88c5139efb7056" translate="yes" xml:space="preserve">
          <source>Fix rare false-positives in &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; when run on a database connection with &lt;a href=&quot;lang_attach&quot;&gt;attached databases&lt;/a&gt;. Ticket &lt;a href=&quot;https://sqlite.org/src/info/a4e06e75a9ab61a12&quot;&gt;a4e06e75a9ab61a12&lt;/a&gt;</source>
          <target state="translated">当在具有&lt;a href=&quot;lang_attach&quot;&gt;附加数据库&lt;/a&gt;的数据库连接上运行时，修复&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check中&lt;/a&gt;罕见的假阳性。门票&lt;a href=&quot;https://sqlite.org/src/info/a4e06e75a9ab61a12&quot;&gt;a4e06e75a9ab61a12&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="715572171eb76d3d2c9de665f3a896a9b21d3581" translate="yes" xml:space="preserve">
          <source>Fix several important bugs in the new ATTACH and DETACH commands.</source>
          <target state="translated">修复了新的ATTACH和DETACH命令中的几个重要错误。</target>
        </trans-unit>
        <trans-unit id="ddb3a4c421a408022b093da748a9383a9c659be4" translate="yes" xml:space="preserve">
          <source>Fix several nuisance bugs.</source>
          <target state="translated">修复几个扰人的BUG。</target>
        </trans-unit>
        <trans-unit id="893a9bc034bf998aa3ff5b40cdc26495f66e42a9" translate="yes" xml:space="preserve">
          <source>Fix table rename feature so that it also updates references to the renamed table in &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt; and &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt;.</source>
          <target state="translated">修复表重命名功能，以便它还可以在&lt;a href=&quot;lang_createtrigger&quot;&gt;触发器&lt;/a&gt;和&lt;a href=&quot;lang_createview&quot;&gt;视图中&lt;/a&gt;更新对重命名表的引用。</target>
        </trans-unit>
        <trans-unit id="6c93787ec12e369e67cea4716187fa506565c4de" translate="yes" xml:space="preserve">
          <source>Fix the &quot;.import&quot; command of the shell so that it ignores \r characters at the end of lines.</source>
          <target state="translated">修正shell的&quot;.import &quot;命令,使其忽略行末的\r字符。</target>
        </trans-unit>
        <trans-unit id="efa608a017df9d7fa42cace30fce54f90785e7c6" translate="yes" xml:space="preserve">
          <source>Fix the &quot;.read&quot; command in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; so that it understands that its input is not interactive.</source>
          <target state="translated">修复&lt;a href=&quot;cli&quot;&gt;命令行外壳中&lt;/a&gt;的&amp;ldquo; .read&amp;rdquo;命令，以使其了解其输入不是交互式的。</target>
        </trans-unit>
        <trans-unit id="7dd018e621c55cac03b1d82cf14914c81075f182" translate="yes" xml:space="preserve">
          <source>Fix the --enable-threadsafe option on the configure script</source>
          <target state="translated">修正配置脚本中的--enable-threadsafe选项。</target>
        </trans-unit>
        <trans-unit id="4f27e177384472d9d1a0c017bbab8f18de27d2fa" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/db_readonly&quot;&gt;sqlite3_db_readonly()&lt;/a&gt; interface so that it returns true if the database is read-only due to the file format write version number being too large.</source>
          <target state="translated">修复&lt;a href=&quot;c3ref/db_readonly&quot;&gt;sqlite3_db_readonly（）&lt;/a&gt;接口，如果数据库由于文件格式写入版本号太大而为只读，则返回true。</target>
        </trans-unit>
        <trans-unit id="bec6839af346a0afcfd8b6b2618aee85250ace7f" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interfaces so that they actually do provide a 64-bit answer.</source>
          <target state="translated">修复&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;和&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;接口，以便它们确实提供64位答案。</target>
        </trans-unit>
        <trans-unit id="9ba95583c49ccb4f7efb59b2718e52202fa58e8d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/stmt_busy&quot;&gt;sqlite3_stmt_busy()&lt;/a&gt; interface so that it gives the correct answer for &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; statements that have been stepped but never reset.</source>
          <target state="translated">修复&lt;a href=&quot;c3ref/stmt_busy&quot;&gt;sqlite3_stmt_busy（）&lt;/a&gt;接口，以便为已步进但从未重置的&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;语句提供正确答案。</target>
        </trans-unit>
        <trans-unit id="0d8b77554fdfe7204548bebac009120f0ab4ce5d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; interface so that it is disabled if either the callback or the mask arguments are zero, in accordance with the documentation.</source>
          <target state="translated">修复&lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;接口，以便根据文档，如果回调或mask参数为零，则将其禁用。</target>
        </trans-unit>
        <trans-unit id="956e98f8a5992e566b23150a8321e220d594d919" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt; interface so that it correctly translates content generated by &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob()&lt;/a&gt; into a string of all 0x00 characters. This is a long-standing issue discovered after the 3.16.1 release by &lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSS-Fuzz&lt;/a&gt;</source>
          <target state="translated">修复&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_text（）&lt;/a&gt;接口，以便它正确地将&lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob（）&lt;/a&gt;生成的内容转换为所有0x00字符的字符串。这是&lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSS-Fuzz&lt;/a&gt;在3.16.1版本发布后发现的一个长期问题</target>
        </trans-unit>
        <trans-unit id="56c77cb746417e9f9c249b6c4c57b8b0bd6b303c" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; so that it builds with -DSQLITE_UNTESTABLE</source>
          <target state="translated">修复&lt;a href=&quot;cli&quot;&gt;CLI，&lt;/a&gt;以便使用-DSQLITE_UNTESTABLE进行构建</target>
        </trans-unit>
        <trans-unit id="2ac07a1bdc161b16f3469a85c1d0b7329721b6d7" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;cli#fileio&quot;&gt;readfile()&lt;/a&gt; function so that it returns an empty BLOB rather than throwing an out-of-memory error when reading an empty file.</source>
          <target state="translated">修复&lt;a href=&quot;cli#fileio&quot;&gt;readfile（）&lt;/a&gt;函数，使其在读取空文件时返回空的BLOB，而不是抛出内存不足错误。</target>
        </trans-unit>
        <trans-unit id="403d90d10026656bd2341e3610eb64ec19d4191d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;cli#fileio&quot;&gt;writefile()&lt;/a&gt; function so that when it creates new directories along the path of a new file, it gives them umask permissions rather than the same permissions as the file.</source>
          <target state="translated">修复&lt;a href=&quot;cli#fileio&quot;&gt;writefile（）&lt;/a&gt;函数，以便当它沿着新文件的路径创建新目录时，会为其赋予umask权限，而不是与文件相同的权限。</target>
        </trans-unit>
        <trans-unit id="c637b1ba45c5e9182867d4d4a220fb33c1f49c9d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/eval.c&quot;&gt;eval.c&lt;/a&gt; extension so that it works with &lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt;PRAGMA empty_result_callbacks=ON&lt;/a&gt;.</source>
          <target state="translated">修复&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/eval.c&quot;&gt;eval.c&lt;/a&gt;扩展名，使其与&lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt;PRAGMA empty_result_callbacks = ON一起使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="742c65bbfe2ba6c5ffb22d31b0549c4b28db3ce5" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;json1#jeach&quot;&gt;json_each()&lt;/a&gt; function so that it returns valid results on its &quot;fullkey&quot; column when the input is a simple value rather than an array or object.</source>
          <target state="translated">修复&lt;a href=&quot;json1#jeach&quot;&gt;json_each（）&lt;/a&gt;函数，以便当输入是简单值而不是数组或对象时，它在其&amp;ldquo; fullkey&amp;rdquo;列上返回有效结果。</target>
        </trans-unit>
        <trans-unit id="6faddebbbfb3cf6bd640c7723cc149f43cca6d2e" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command so that it does not corrupt &lt;a href=&quot;lang_createindex#descidx&quot;&gt;descending indexes&lt;/a&gt; when adding a column to a &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy file format&lt;/a&gt; database. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f68bf68513a1c15f&quot;&gt;f68bf68513a1c15f&lt;/a&gt;</source>
          <target state="translated">修复&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;命令，以便在将列添加到&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;旧文件格式&lt;/a&gt;数据库时不会破坏&lt;a href=&quot;lang_createindex#descidx&quot;&gt;降序索引&lt;/a&gt;。门票&lt;a href=&quot;https://www.sqlite.org/src/info/f68bf68513a1c15f&quot;&gt;f68bf68513a1c15f&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="02f53a9fc9d770e6300288b8428f8e92433fe895" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_altertable#altertabmvcol&quot;&gt;ALTER TABLE RENAME COLUMN&lt;/a&gt; command so that it works for tables that have redundant UNIQUE constraints. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/bc8d94f0fbd633fd9a&quot;&gt;bc8d94f0fbd633fd9a&lt;/a&gt;</source>
          <target state="translated">修复&lt;a href=&quot;lang_altertable#altertabmvcol&quot;&gt;ALTER TABLE RENAME COLUMN&lt;/a&gt;命令，使其适用于具有冗余UNIQUE约束的表。门票&lt;a href=&quot;https://www.sqlite.org/src/info/bc8d94f0fbd633fd9a&quot;&gt;bc8d94f0fbd633fd9a&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="97c52dd1e73a0efdc1a5a635f402eb42bf6e057e" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command so that it adds correct samples for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables in the &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; table. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/b2fa5424e6fcb15&quot;&gt;b2fa5424e6fcb15&lt;/a&gt;.</source>
          <target state="translated">修复&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令，以便为&lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;表中的&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表添加正确的样本。机票&lt;a href=&quot;http://www.sqlite.org/src/info/b2fa5424e6fcb15&quot;&gt;b2fa5424e6fcb15&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d872c8e6bb3c85572831647367d9180d6f56948" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command so that it computes statistics on tables whose names begin with &quot;sqlite&quot;. Check-in &lt;a href=&quot;https://sqlite.org/src/info/0249d9aecf69948d&quot;&gt;0249d9aecf69948d&lt;/a&gt;</source>
          <target state="translated">修复&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令，以便它计算名称以&amp;ldquo; sqlite&amp;rdquo;开头的表的统计信息。入住&lt;a href=&quot;https://sqlite.org/src/info/0249d9aecf69948d&quot;&gt;0249d9aecf69948d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bc9460bbb01c2af9870b809ff07c3b2b7356fe99" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; command so that it is no longer able to sneak a NULL value into a NOT NULL column even if the NOT NULL column has a default value of NULL. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/e6f1f2e34dceeb1ed6&quot;&gt;e6f1f2e34dceeb1ed6&lt;/a&gt;</source>
          <target state="translated">修复&lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt;命令，以便即使NOT NULL列的默认值为NULL，也无法再将NULL值潜入NOT NULL列。门票&lt;a href=&quot;https://www.sqlite.org/src/info/e6f1f2e34dceeb1ed6&quot;&gt;e6f1f2e34dceeb1ed6&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0d54e2533360cb4659b717a0226d2d7a1dbf1bbf" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; statement for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables that lack secondary indexes so that it works correctly with triggers and foreign keys. This was a new bug caused by performance optimizations added in version 3.16.0. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/30027b613b4&quot;&gt;30027b613b4&lt;/a&gt;</source>
          <target state="translated">修复缺少二级索引的&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表的&lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt;语句，以便它可以与触发器和外键一起正常使用。这是由3.16.0版中添加的性能优化引起的新错误。机票&lt;a href=&quot;https://www.sqlite.org/src/info/30027b613b4&quot;&gt;30027b613b4&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d509397fe960e4575a2e26f651dde6ff90b84a19" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command so that it spills excess content to disk rather than holding everything in memory, and possible causing an out-of-memory error for larger database files. This fixes an issue introduced by version 3.15.0.</source>
          <target state="translated">修复&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令，以便将多余的内容溢出到磁盘上，而不是将所有内容都保存在内存中，并可能导致较大的数据库文件出现内存不足错误。这解决了3.15.0版引入的问题。</target>
        </trans-unit>
        <trans-unit id="b036730fcf1ecafecf0573d1d74619be57162b96" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;optoverview#flattening&quot;&gt;query flattener&lt;/a&gt; so that it works on queries that contain subqueries that use &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f09fcd17810f65f717&quot;&gt;709fcd17810f65f717&lt;/a&gt;</source>
          <target state="translated">修复&lt;a href=&quot;optoverview#flattening&quot;&gt;查询拼合器&lt;/a&gt;，使其可用于包含使用&lt;a href=&quot;windowfunctions&quot;&gt;窗口函数的&lt;/a&gt;子查询的查询。机票&lt;a href=&quot;https://www.sqlite.org/src/info/f09fcd17810f65f717&quot;&gt;709fcd17810f65f717&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a295aba8a2bc4b671641db0bf3a60e0d6006706" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; so that it always ignores subplans that do not use an index.</source>
          <target state="translated">修复&lt;a href=&quot;optoverview#or_opt&quot;&gt;OR优化，&lt;/a&gt;以便它始终忽略不使用索引的子计划。</target>
        </trans-unit>
        <trans-unit id="69a683f5bb13785c6e99f6455ca83c519f9c2e7d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; so that it works correctly when the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; is used on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/8fd39115d8f46&quot;&gt;8fd39115d8f46&lt;/a&gt;</source>
          <target state="translated">修复&lt;a href=&quot;optoverview#skipscan&quot;&gt;跳过扫描优化，&lt;/a&gt;以便在对&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表使用&lt;a href=&quot;optoverview#or_opt&quot;&gt;OR优化&lt;/a&gt;时正确运行。门票&lt;a href=&quot;https://www.sqlite.org/src/info/8fd39115d8f46&quot;&gt;8fd39115d8f46&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d64c703876098dc69084f33c7133d65be1531802" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; command so that it works correctly with foreign keys on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">修复&lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt;命令，以便它可以与&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表上的外键一起正常使用。</target>
        </trans-unit>
        <trans-unit id="0d608a4f7657ad4f577e7889d266b51e07ca7fe6" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;series&quot;&gt;generate_series&lt;/a&gt; virtual table so that it correctly returns no rows if any of its constraints are NULL.</source>
          <target state="translated">修复&lt;a href=&quot;series&quot;&gt;generate_series&lt;/a&gt;虚拟表，以使其在任何约束为NULL的情况下都不会正确返回任何行。</target>
        </trans-unit>
        <trans-unit id="16b43b19be563d99895b6b7aa73c97080f1c15c0" translate="yes" xml:space="preserve">
          <source>Fix the REPLACE() function so that it returns NULL if the second argument is an empty string. Ticket #2324.</source>
          <target state="translated">修正 REPLACE()函数,使其在第二个参数为空字符串时返回 NULL。Ticket #2324.</target>
        </trans-unit>
        <trans-unit id="b71b83145fe1ea70f5f98014557a62cf7f2c2ec4" translate="yes" xml:space="preserve">
          <source>Fix the TCL interface so that the &quot;nullvalue&quot; setting is honored for TCL implementations of SQL functions.</source>
          <target state="translated">修正TCL接口,使 &quot;nullvalue &quot;的设置在TCL实现SQL函数时得到尊重。</target>
        </trans-unit>
        <trans-unit id="681e860e148ced87ec9dd7b3cfb9b43a75c2065d" translate="yes" xml:space="preserve">
          <source>Fix the behavior of &lt;a href=&quot;c3ref/column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt; for queries that use the &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt; so that the result is consistent with other queries that do not use that optimization, and with PostgreSQL, MySQL, and SQLServer. Ticket &lt;a href=&quot;https://sqlite.org/src/info/de3403bf5ae&quot;&gt;de3403bf5ae&lt;/a&gt;.</source>
          <target state="translated">修复&lt;a href=&quot;c3ref/column_name&quot;&gt;sqlite3_column_name（）&lt;/a&gt;对于使用&lt;a href=&quot;optoverview#flattening&quot;&gt;扁平化优化的&lt;/a&gt;查询的行为，以使结果与不使用该优化的其他查询以及PostgreSQL，MySQL和SQLServer一致。门票&lt;a href=&quot;https://sqlite.org/src/info/de3403bf5ae&quot;&gt;de3403bf5ae&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e2fb92f8546f34175b1dda79777c363dd68d103" translate="yes" xml:space="preserve">
          <source>Fix the behavior of comparison operators (ex: &quot;&lt;b&gt;&amp;amp;lt&lt;/b&gt;&quot;, &quot;&lt;b&gt;==&lt;/b&gt;&quot;, etc.) so that they are consistent with the order of entries in an index.</source>
          <target state="translated">修复比较运算符的行为（例如：&amp;ldquo; &lt;b&gt;＆lt&lt;/b&gt; &amp;rdquo;，&amp;ldquo; &lt;b&gt;==&lt;/b&gt; &amp;rdquo;等），以使其与索引中条目的顺序一致。</target>
        </trans-unit>
        <trans-unit id="a6cdb1736bb68b0b3c4ede9fdba04199758b7855" translate="yes" xml:space="preserve">
          <source>Fix the behavior of comparison operators (ex: &quot;&lt;b&gt;&amp;lt;&lt;/b&gt;&quot;, &quot;&lt;b&gt;==&lt;/b&gt;&quot;, etc.) so that they are consistent with the order of entries in an index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8e8cd65707752281f4a6188d7da381520e451a" translate="yes" xml:space="preserve">
          <source>Fix the behavior of typeof() and length() on virtual tables. Ticket &lt;a href=&quot;https://sqlite.org/src/info/69d642332d25aa3b7315a6d385&quot;&gt;69d642332d25aa3b7315a6d385&lt;/a&gt;</source>
          <target state="translated">修复虚拟表上typeof（）和length（）的行为。门票&lt;a href=&quot;https://sqlite.org/src/info/69d642332d25aa3b7315a6d385&quot;&gt;69d642332d25aa3b7315a6d385&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df05e2dc4f6d16d80624e7984c8465e501af7d3b" translate="yes" xml:space="preserve">
          <source>Fix the build so that it works with -DSQLITE_OMIT_WAL.</source>
          <target state="translated">修复构建,使其与-DSQLITE_OMIT_WAL一起工作。</target>
        </trans-unit>
        <trans-unit id="2766a0c67ddd6ed7f5aaccb304bc1ba6ad153261" translate="yes" xml:space="preserve">
          <source>Fix the built-in printf logic so that it prints &quot;NaN&quot; not &quot;Inf&quot; for floating-point NaNs. Ticket #2345</source>
          <target state="translated">修正内置的 printf 逻辑,使其对浮点 NaNs 打印 &quot;NaN &quot;而不是 &quot;Inf&quot;。Ticket #2345</target>
        </trans-unit>
        <trans-unit id="5bfcd9ce8f5df54205f92dd3b6c0521e656224b0" translate="yes" xml:space="preserve">
          <source>Fix the bytecode generator to deal with a subquery in the FROM clause that is itself a UNION ALL where one side of the UNION ALL is a view that contains an ORDER BY. This is a long-standing issue that was discovered after the release of 3.16.1. See ticket &lt;a href=&quot;https://www.sqlite.org/src/info/190c2507&quot;&gt;190c2507&lt;/a&gt;.</source>
          <target state="translated">修复字节码生成器，以处理FROM子句中的子查询，该子句本身就是UNION ALL，其中UNION ALL的一侧是包含ORDER BY的视图。这是一个长期存在的问题，在3.16.1版本发布后就被发现。请参阅票证&lt;a href=&quot;https://www.sqlite.org/src/info/190c2507&quot;&gt;190c2507&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d203309fb6041974c7687fc93bbf99d6e93873bc" translate="yes" xml:space="preserve">
          <source>Fix the code generator for expressions of the form &quot;x IN (SELECT...)&quot; where the SELECT statement on the RHS is a correlated subquery. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/5e3c886796e5512e&quot;&gt;5e3c886796e5512e&lt;/a&gt;.</source>
          <target state="translated">修复代码生成器，以生成&amp;ldquo; x IN（SELECT ...）&amp;rdquo;形式的表达式，其中RHS上的SELECT语句是相关子查询。机票&lt;a href=&quot;https://www.sqlite.org/src/info/5e3c886796e5512e&quot;&gt;5e3c886796e5512e&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="13a43d34f4444938ebdb413873a4acf48769174e" translate="yes" xml:space="preserve">
          <source>Fix the configure script for the amalgamation so that the --readline option works again on Raspberry PIs.</source>
          <target state="translated">修正amalgamation的configure脚本,使--readline选项在Raspberry PIs上重新工作。</target>
        </trans-unit>
        <trans-unit id="0dffaab8602b04f745c3456ad0e79054b8bf2a09" translate="yes" xml:space="preserve">
          <source>Fix the function prototype for the open(2) system call to agree with POSIX. Without this fix, pthreads does not work correctly on NetBSD.</source>
          <target state="translated">修正 open(2)系统调用的函数原型,使其与 POSIX 兼容。如果没有这个修正,pthreads 在 NetBSD 上无法正常工作。</target>
        </trans-unit>
        <trans-unit id="0cdcb447680d92da840bf449347a30236662eba4" translate="yes" xml:space="preserve">
          <source>Fix the locking mechanism yet again to prevent &lt;b&gt;sqlite_exec()&lt;/b&gt; from returning SQLITE_PROTOCOL unnecessarily. This time the bug was a race condition in the locking code. This change affects both POSIX and Windows users.</source>
          <target state="translated">再次修复锁定机制，以防止&lt;b&gt;sqlite_exec（）&lt;/b&gt;不必要地返回SQLITE_PROTOCOL。这次错误是锁定代码中的竞争条件。此更改会影响POSIX和Windows用户。</target>
        </trans-unit>
        <trans-unit id="007c6c873e32f4b431e8ac6f01127288ee55c964" translate="yes" xml:space="preserve">
          <source>Fix the min() and max() optimizer so that it works when the FROM clause consists of a subquery.</source>
          <target state="translated">修正min()和max()优化器,使其在FROM子句包含子查询时也能工作。</target>
        </trans-unit>
        <trans-unit id="b12f6e9f1f8f67709743497fbebb71ef8c53459f" translate="yes" xml:space="preserve">
          <source>Fix the parser to accept valid &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; syntax. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7310e2fb3d046a5&quot;&gt;7310e2fb3d046a5&lt;/a&gt;</source>
          <target state="translated">修复解析器以接受有效的&lt;a href=&quot;rowvalue&quot;&gt;行值&lt;/a&gt;语法。门票&lt;a href=&quot;https://www.sqlite.org/src/info/7310e2fb3d046a5&quot;&gt;7310e2fb3d046a5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="13f421298ab97922575edd88af10f5d60d0152b2" translate="yes" xml:space="preserve">
          <source>Fix the query optimizer to correctly handle constant expressions in the ON clause of a LEFT JOIN. Ticket #2403</source>
          <target state="translated">修正查询优化器,以正确处理LEFT JOIN的ON子句中的常量表达式。Ticket #2403</target>
        </trans-unit>
        <trans-unit id="40584ba785f1b7ac57821c3d2f85216f2b32614c" translate="yes" xml:space="preserve">
          <source>Fix the query optimizer to handle rowid comparisons to NULL correctly. Ticket #2404</source>
          <target state="translated">修正查询优化器正确处理rowid比较为NULL的问题。Ticket #2404</target>
        </trans-unit>
        <trans-unit id="dfa9a47acf25a2f05ea48c9410e4c4747561d320" translate="yes" xml:space="preserve">
          <source>Fix the query planner so that IS and IS NULL operators are able to drive an index on a LEFT OUTER JOIN.</source>
          <target state="translated">修正查询规划器,使IS和IS NULL操作符能够在LEFT OUTER JOIN上驱动索引。</target>
        </trans-unit>
        <trans-unit id="5653a698bc06b9d4be42b0c1c2f59e7a1e2b1d3a" translate="yes" xml:space="preserve">
          <source>Fix the query planner so that it knows not to use &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexes&lt;/a&gt; on the right table of LEFT JOIN if the WHERE clause uses the &lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS operator&lt;/a&gt;. Fix for &lt;a href=&quot;https://sqlite.org/src/info/ce68383bf6aba&quot;&gt;ce68383bf6aba&lt;/a&gt;.</source>
          <target state="translated">修复查询计划程序，以便如果WHERE子句使用&lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS运算符&lt;/a&gt;，则它不知道在LEFT JOIN的右表上不使用&lt;a href=&quot;optoverview#autoindex&quot;&gt;自动索引&lt;/a&gt;。修复&lt;a href=&quot;https://sqlite.org/src/info/ce68383bf6aba&quot;&gt;ce68383bf6aba&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f099fcbe9d8c0841133d0c1acb48be9e9aec8aff" translate="yes" xml:space="preserve">
          <source>Fix the query planner so that it takes into account dependencies in the arguments to table-valued functions in subexpressions in the WHERE clause. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/80177f0c226ff54&quot;&gt;80177f0c226ff54&lt;/a&gt;</source>
          <target state="translated">修复查询计划程序，以便它考虑到WHERE子句中子表达式中表值函数的参数的依赖性。门票&lt;a href=&quot;https://www.sqlite.org/src/info/80177f0c226ff54&quot;&gt;80177f0c226ff54&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c51036bc7729aa3fd5a9f1ed633c206de4f498ea" translate="yes" xml:space="preserve">
          <source>Fix the query planner so that it works correctly for IS NOT NULL operators in the ON clause of a LEFT JOIN with the SQLITE_ENABLE_STAT4 compile-time option. &lt;a href=&quot;https://sqlite.org/src/info/65eb38f6e46de8c75e188a17ec&quot;&gt;65eb38f6e46de8c75e188a17ec&lt;/a&gt;</source>
          <target state="translated">修复查询计划程序，使其对于带有SQLITE_ENABLE_STAT4编译时选项的LEFT JOIN的ON子句中的IS NOT NULL运算符正确运行。&lt;a href=&quot;https://sqlite.org/src/info/65eb38f6e46de8c75e188a17ec&quot;&gt;65eb38f6e46de8c75e188a17ec&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2e67f4820003d691c4c8b5a0ce32d382b50cc512" translate="yes" xml:space="preserve">
          <source>Fix the regression test suite so that it works with Tcl8.5</source>
          <target state="translated">修正回归测试套件,使其能与Tcl8.5一起使用。</target>
        </trans-unit>
        <trans-unit id="6d468d38a1ed912125e5b1192b25781bdc29bb56" translate="yes" xml:space="preserve">
          <source>Fix the schema parser so that it interprets certain (obscure and ill-formed) CREATE TABLE statements the same as legacy. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/ac661962a2aeab3c331&quot;&gt;ac661962a2aeab3c331&lt;/a&gt;</source>
          <target state="translated">修复模式分析器，以使其解释与旧版相同的某些（模糊且格式错误的）CREATE TABLE语句。机票&lt;a href=&quot;https://www.sqlite.org/src/info/ac661962a2aeab3c331&quot;&gt;AC661962A2AEAB3C331的&lt;/a&gt;修复</target>
        </trans-unit>
        <trans-unit id="29c5cfa4d69ee4c85bc560fdea69b6008202a144" translate="yes" xml:space="preserve">
          <source>Fix to UPDATE triggers on TEMP tables.</source>
          <target state="translated">修复TEMP表的UPDATE触发器。</target>
        </trans-unit>
        <trans-unit id="8ac8e543b0bc738b6dc67d65d9b587bde27a9189" translate="yes" xml:space="preserve">
          <source>Fix to the --rbu option of &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt;.</source>
          <target state="translated">固定到的--rbu选项&lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dce0daf2e8b6a6a74ce23add5bf251c814f89da9" translate="yes" xml:space="preserve">
          <source>Fix two bugs in the locking protocol. (One was masking the other.)</source>
          <target state="translated">修复锁定协议中的两个bug。(一个是掩盖了另一个。)</target>
        </trans-unit>
        <trans-unit id="140466bf745b30af0254a8472b1f139b069fbb53" translate="yes" xml:space="preserve">
          <source>Fix two bugs, which when combined might result in incorrect query results. Both bugs were harmless by themselves; only when they team up do they cause problems. Ticket #3581.</source>
          <target state="translated">修复两个bug,这两个bug结合起来可能会导致不正确的查询结果。这两个bug本身是无害的,只有当它们联合起来才会导致问题。Ticket #3581.</target>
        </trans-unit>
        <trans-unit id="e9669895532c079b8fe44ba1553500c34f15f036" translate="yes" xml:space="preserve">
          <source>Fix two long-standing bugs that allow malicious SQL statements to crash the process that is running SQLite. These bugs were announced by a third-party approximately 24 hours after the 3.32.0 release but are not specific to the 3.32.0 release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6b3c2eac5340186aa60ec6ef1bd320d9af1b4cf" translate="yes" xml:space="preserve">
          <source>Fix two problems in the new &lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;LEFT JOIN strength reduction optimization&lt;/a&gt;. Tickets &lt;a href=&quot;https://sqlite.org/src/info/1e39b966ae9ee739&quot;&gt;1e39b966ae9ee739&lt;/a&gt; and &lt;a href=&quot;https://sqlite.org/src/info/fac496b61722daf2&quot;&gt;fac496b61722daf2&lt;/a&gt;.</source>
          <target state="translated">解决了新的&lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;LEFT JOIN强度降低优化&lt;/a&gt;中的两个问题。门票&lt;a href=&quot;https://sqlite.org/src/info/1e39b966ae9ee739&quot;&gt;1e39b966ae9ee739&lt;/a&gt;和&lt;a href=&quot;https://sqlite.org/src/info/fac496b61722daf2&quot;&gt;fac496b61722daf2&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce60dbf83ec6124a3874f74bb112313a53e7aca8" translate="yes" xml:space="preserve">
          <source>Fix type coercion rules for the IN operator</source>
          <target state="translated">修正IN操作符的类型胁迫规则。</target>
        </trans-unit>
        <trans-unit id="1ef59214b1b8979108ab36722686dbe71717d826" translate="yes" xml:space="preserve">
          <source>Fix typos in documentation.</source>
          <target state="translated">修正文档中的错别字。</target>
        </trans-unit>
        <trans-unit id="c5df6889e7873170528ac5b7149060416fb8a48c" translate="yes" xml:space="preserve">
          <source>Fix typos in the documentation</source>
          <target state="translated">修正文档中的错别字</target>
        </trans-unit>
        <trans-unit id="a8caeeab6423273de2d0f3b9037854eda089993c" translate="yes" xml:space="preserve">
          <source>Fix uninitialized variables causing malfunctions for various obscure queries</source>
          <target state="translated">修正未初始化变量导致各种晦涩的查询故障的问题</target>
        </trans-unit>
        <trans-unit id="334faf48b2d08d39ac3f83df69ba4313064d2eca" translate="yes" xml:space="preserve">
          <source>Fix various documentation typos</source>
          <target state="translated">修正各种文件中的错别字</target>
        </trans-unit>
        <trans-unit id="bfc06020350fd18063be73e1e193870b6478ef89" translate="yes" xml:space="preserve">
          <source>Fix various other minor test script problems.</source>
          <target state="translated">修复其他各种小的测试脚本问题。</target>
        </trans-unit>
        <trans-unit id="04a80b08dce7f337318b3de8005ba6821f9088b9" translate="yes" xml:space="preserve">
          <source>Fix warning messages in VC++ 7.0. (Patches from nicolas352001)</source>
          <target state="translated">修正VC++7.0中的警告信息。(补丁来自nicolas352001)</target>
        </trans-unit>
        <trans-unit id="e356e2b704a2e01de653ed2ebbf706f69ff2717e" translate="yes" xml:space="preserve">
          <source>Fixed &lt;b&gt;sqlite.h&lt;/b&gt; so that it is usable from C++</source>
          <target state="translated">修复了&lt;b&gt;sqlite.h，&lt;/b&gt;以便可以从C ++使用</target>
        </trans-unit>
        <trans-unit id="79e373e30e82498299cb604bd835209f11c2361f" translate="yes" xml:space="preserve">
          <source>Fixed a bug in the &quot;copy&quot; method of the TCL interface.</source>
          <target state="translated">修正了TCL接口中 &quot;复制 &quot;方法的一个错误。</target>
        </trans-unit>
        <trans-unit id="c148872cc8b9ab806e9be600a6bc5019b39f4b73" translate="yes" xml:space="preserve">
          <source>Fixed a bug in the processing of LEFT OUTER JOIN</source>
          <target state="translated">修正了处理LEFT OUTER JOIN时的一个BUG</target>
        </trans-unit>
        <trans-unit id="8958f58770783b2b2d9b98f41e760b01637c6fbf" translate="yes" xml:space="preserve">
          <source>Fixed a bug in the query planner that caused performance regressions relative to 3.6.23.1 on some complex joins.</source>
          <target state="translated">修正了查询规划器中的一个bug,该bug导致一些复杂连接的性能相对于3.6.23.1有所下降。</target>
        </trans-unit>
        <trans-unit id="ce57a2f7dac9c404f24a8b0780affccd90fd36f4" translate="yes" xml:space="preserve">
          <source>Fixed a bug that caused database corruption when an &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; is rolled back in an in-memory database. Ticket #3761.</source>
          <target state="translated">修正了一个导致数据库损坏时的错误&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt;在内存数据库回滚。机票＃3761。</target>
        </trans-unit>
        <trans-unit id="47075269c498ed42295ff1e4b7548fb034943cbd" translate="yes" xml:space="preserve">
          <source>Fixed a bug that was causing updates to fail inside of transactions when the database contained a temporary table.</source>
          <target state="translated">修正了当数据库包含临时表时,在事务中导致更新失败的错误。</target>
        </trans-unit>
        <trans-unit id="479bbff8b43af13fac5ef791395960b4f803b850" translate="yes" xml:space="preserve">
          <source>Fixed a critical bug in the &lt;a href=&quot;https://www.sqlite.org/see/doc/trunk/www/readme.wiki&quot;&gt;SQLite Encryption Extension&lt;/a&gt; that could cause the database to become unreadable and unrecoverable if a &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command changed the size of the encryption nonce.</source>
          <target state="translated">修复了&lt;a href=&quot;https://www.sqlite.org/see/doc/trunk/www/readme.wiki&quot;&gt;SQLite加密扩展&lt;/a&gt;中的一个严重错误，如果&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令更改了加密随机数的大小，该错误可能导致数据库变得不可读和不可恢复。</target>
        </trans-unit>
        <trans-unit id="59729403a0ff39e62d5592f59ad0496bc74d3cb0" translate="yes" xml:space="preserve">
          <source>Fixed a typo in the OS/2 backend.</source>
          <target state="translated">修正了OS/2后台的一个印刷错误。</target>
        </trans-unit>
        <trans-unit id="639269284376af975435d947ede551d59f7c8a90" translate="yes" xml:space="preserve">
          <source>Fixed an off-by-one error that was causing a coredump in the '%q' format directive of the new &lt;b&gt;sqlite_..._printf()&lt;/b&gt; routines.</source>
          <target state="translated">修复了导致新的&lt;b&gt;sqlite _..._ printf（）&lt;/b&gt;例程的'％q'格式指令发生核心转储的一次性错误。</target>
        </trans-unit>
        <trans-unit id="2f93f642c24bc3ca9d72401aa0c30d511f868145" translate="yes" xml:space="preserve">
          <source>Fixed lots of spelling errors in the source-code comments</source>
          <target state="translated">修正了源代码注释中的大量拼写错误。</target>
        </trans-unit>
        <trans-unit id="fd59e954365ccfc713ffa89ef7eee7b8910b50c3" translate="yes" xml:space="preserve">
          <source>Fixed naming conflicts so that versions 2.8 and 3.0 can be linked and used together in the same ANSI-C source file.</source>
          <target state="translated">修正了命名冲突,使 2.8 和 3.0 版本可以在同一个 ANSI-C 源文件中链接并一起使用。</target>
        </trans-unit>
        <trans-unit id="8dc0276046c4c36ea547c5cf770bbba66b28361f" translate="yes" xml:space="preserve">
          <source>Fixed performance problems and potential stack overflows when creating &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt; from multi-row VALUES clauses with hundreds of thousands of rows.</source>
          <target state="translated">从具有成千上万行的多行VALUES子句创建&lt;a href=&quot;lang_createview&quot;&gt;视图&lt;/a&gt;时，修复了性能问题和潜在的堆栈溢出。</target>
        </trans-unit>
        <trans-unit id="48a5b411b131a16a7c3a81ff9ffe341d205ab7e3" translate="yes" xml:space="preserve">
          <source>Fixed some instances where &lt;b&gt;sqlite_exec()&lt;/b&gt; was returning the wrong error code.</source>
          <target state="translated">修复了&lt;b&gt;sqlite_exec（）&lt;/b&gt;返回错误错误代码的某些情况。</target>
        </trans-unit>
        <trans-unit id="d2abd59d7529d7221419b75d94eed0ee9277c4cd" translate="yes" xml:space="preserve">
          <source>Fixed the &quot;.dump&quot; command in the command-line shell to show indices, triggers and views again.</source>
          <target state="translated">修正了命令行shell中的&quot;.dump &quot;命令,以再次显示指数、触发器和视图。</target>
        </trans-unit>
        <trans-unit id="923cc8fbcaf6842679b5f1e15d6df83e508e85ec" translate="yes" xml:space="preserve">
          <source>Fixed the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; so that &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces and the &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; return the correct values.</source>
          <target state="translated">修复了&lt;a href=&quot;lang_delete#truncateopt&quot;&gt;截断优化，&lt;/a&gt;以便&lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes（）&lt;/a&gt;和&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;接口以及&lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes编译指示&lt;/a&gt;返回正确的值。</target>
        </trans-unit>
        <trans-unit id="9e28c4773e158241fde9583f9f170c5ef9db0282" translate="yes" xml:space="preserve">
          <source>Fixed the operator precedence for the ~ operator.</source>
          <target state="translated">修正了~运算符的运算符优先性。</target>
        </trans-unit>
        <trans-unit id="7effc13b7d809cd0670d65239ee3df045defba54" translate="yes" xml:space="preserve">
          <source>Fixes for various minor bugs.</source>
          <target state="translated">修复了各种小错误。</target>
        </trans-unit>
        <trans-unit id="6db891bdea0dad81fb2181f92e7eface672bbf02" translate="yes" xml:space="preserve">
          <source>Fixes for various other compiler warnings and minor problems associated with obscure configurations.</source>
          <target state="translated">修正了其他各种编译器警告和与晦涩配置相关的小问题。</target>
        </trans-unit>
        <trans-unit id="2582d7cc3520de6113cfebc05a4c0c40c10d2aea" translate="yes" xml:space="preserve">
          <source>Fixes to the rollback and locking behavior</source>
          <target state="translated">对回滚和锁定行为的修正</target>
        </trans-unit>
        <trans-unit id="300a0178f58415dda787e9c4b1d46e58f9cdc26d" translate="yes" xml:space="preserve">
          <source>FkCounter</source>
          <target state="translated">FkCounter</target>
        </trans-unit>
        <trans-unit id="a7826ae0da180dcf999c042085ef7ac58cfd77ff" translate="yes" xml:space="preserve">
          <source>FkIfZero</source>
          <target state="translated">FkIfZero</target>
        </trans-unit>
        <trans-unit id="a774409a00c21de377cf8ed5c6a56b8547973042" translate="yes" xml:space="preserve">
          <source>Flag</source>
          <target state="translated">Flag</target>
        </trans-unit>
        <trans-unit id="502eddf598188b96c0b40f89e8492bff9de3fa43" translate="yes" xml:space="preserve">
          <source>Flags For File Open Operations</source>
          <target state="translated">文件打开操作的标志</target>
        </trans-unit>
        <trans-unit id="9e0bdeb766ef28db46f01b095bdb326b4da9f972" translate="yes" xml:space="preserve">
          <source>Flags consist of zero or more characters that immediately follow the &quot;%&quot; that introduces the substitution. The various flags and their meanings are as follows:</source>
          <target state="translated">标志由紧跟在&quot;%&quot;后面的零个或多个字符组成,引入替换。各种标志及其含义如下:</target>
        </trans-unit>
        <trans-unit id="e52973142fb5309e0599d0aece55b28093c55ec5" translate="yes" xml:space="preserve">
          <source>Flags for sqlite3_deserialize()</source>
          <target state="translated">sqlite3_deserialize()的标志。</target>
        </trans-unit>
        <trans-unit id="763319af81f124ab801773d718a34a5b48132717" translate="yes" xml:space="preserve">
          <source>Flags for sqlite3_serialize</source>
          <target state="translated">sqlite3_serialize的标志。</target>
        </trans-unit>
        <trans-unit id="f15088d96e03c231ed7711a618b87a23e40d38d1" translate="yes" xml:space="preserve">
          <source>Flags for sqlite3changeset_apply_v2</source>
          <target state="translated">sqlite3changeset_apply_v2的标志。</target>
        </trans-unit>
        <trans-unit id="9c6b7b2401c21ffe043e97decac28ab2c77bcf8f" translate="yes" xml:space="preserve">
          <source>Flags for sqlite3changeset_start_v2</source>
          <target state="translated">sqlite3changeset_start_v2的标志。</target>
        </trans-unit>
        <trans-unit id="8565c5e3d19dd91c15d8aea38675feb62cbfe94b" translate="yes" xml:space="preserve">
          <source>Flags for the xAccess VFS method</source>
          <target state="translated">xAccess VFS方法的标志。</target>
        </trans-unit>
        <trans-unit id="caa91d141d9230cced8ac027e0837943663b4e27" translate="yes" xml:space="preserve">
          <source>Flags for the xShmLock VFS method</source>
          <target state="translated">xShmLock VFS方法的标志。</target>
        </trans-unit>
        <trans-unit id="a4c5b52302ff6c09b0d29efa63650e0dd9711b0a" translate="yes" xml:space="preserve">
          <source>Flexible typing is considered a feature of SQLite, not a bug. Nevertheless, we recognize that this feature does sometimes cause confusion and pain for developers who are acustomed to working with other databases that are more judgemental with regard to data types. In retrospect, perhaps it would have been better if SQLite had merely implemented an ANY datatype so that developers could explicitly state when they wanted to use flexible typing, rather than making flexible typing the default. But that is not something that can be changed now without breaking the millions of applications and trillions of database files that already use SQLite's flexible typing feature.</source>
          <target state="translated">灵活的类型被认为是SQLite的一个特性,而不是一个错误。然而,我们认识到这个特性有时确实会给那些习惯于使用其他数据库的开发人员带来困惑和痛苦,因为这些数据库对数据类型的判断力更强。回想起来,如果SQLite仅仅实现了ANY数据类型,让开发人员可以明确地说明什么时候要使用灵活的类型,而不是将灵活的类型作为默认值,也许会更好。但这不是现在可以改变的,否则就会破坏已经使用SQLite灵活键入功能的数百万应用程序和数万亿数据库文件。</target>
        </trans-unit>
        <trans-unit id="f7fca84542efdc71814460460268fade242aaf16" translate="yes" xml:space="preserve">
          <source>Flexible typing is considered a feature of SQLite, not a bug. Nevertheless, we recognize that this feature does sometimes cause confusion and pain for developers who are acustomed to working with other databases that are more judgmental with regard to data types. In retrospect, perhaps it would have been better if SQLite had merely implemented an ANY datatype so that developers could explicitly state when they wanted to use flexible typing, rather than making flexible typing the default. But that is not something that can be changed now without breaking the millions of applications and trillions of database files that already use SQLite's flexible typing feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595acd952f7adef405182868a3f64d0a5da38dfd" translate="yes" xml:space="preserve">
          <source>Flock locking style. This is used for file-systems that do not support POSIX locking style. Locks are obtained and released using the flock() system call.</source>
          <target state="translated">群集锁定方式。这用于不支持POSIX锁定方式的文件系统。使用flock()系统调用获得和释放锁。</target>
        </trans-unit>
        <trans-unit id="c57073033af4c5995ecd6e60b89e343929d9d2c9" translate="yes" xml:space="preserve">
          <source>Flush all database file changes to the disk. Wait for those changes to actually be written onto the disk surface.</source>
          <target state="translated">将所有数据库文件的更改刷新到磁盘上。等待这些更改真正写到磁盘表面。</target>
        </trans-unit>
        <trans-unit id="de39ff51371c017e6227bb21dd0f83307b8a58ff" translate="yes" xml:space="preserve">
          <source>Flush caches to disk mid-transaction</source>
          <target state="translated">在交易中途将缓存刷新到磁盘。</target>
        </trans-unit>
        <trans-unit id="f57e8f8a92192df5f1207764618acfad2559efdf" translate="yes" xml:space="preserve">
          <source>Follow these steps to create your own virtual table:</source>
          <target state="translated">按照这些步骤来创建你自己的虚拟表格。</target>
        </trans-unit>
        <trans-unit id="95cf2c9a54fa89f9d97591c92b0397a9def66730" translate="yes" xml:space="preserve">
          <source>Following a successful call to this function, it is the responsibility of the caller to eventually free the buffer that *ppChangeset points to using &lt;a href=&quot;../c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">成功调用此函数后，调用者有责任最终使用&lt;a href=&quot;../c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放* ppChangeset指向的缓冲区。</target>
        </trans-unit>
        <trans-unit id="94243dad6fb7fd03cdf4ccdea9ad8045597be29a" translate="yes" xml:space="preserve">
          <source>Following a successful call to this function, it is the responsibility of the caller to eventually free the buffer that *ppChangeset points to using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">成功调用此函数后，调用者有责任最终使用&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放* ppChangeset指向的缓冲区。</target>
        </trans-unit>
        <trans-unit id="6ecbb1f3edb4dd34a3fdff354068e2c4ff752166" translate="yes" xml:space="preserve">
          <source>Following a system recovery, if a device sector is deemed to be untrustworthy as defined by A21008 and neither A21011 or A21012 apply to the range of bytes written, then no assumption can be made about the content of the sector following recovery. It is assumed that it is possible for such a sector to be written correctly, not written at all, populated with garbage data or any combination thereof.</source>
          <target state="translated">在系统恢复后,如果一个设备扇区被认为是A21008所定义的不可信的,而且A21011或A21012都不适用于写入的字节范围,那么就不能对恢复后扇区的内容作出任何假设。假设这样的扇区有可能被正确写入,也有可能根本没有写入,也有可能被垃圾数据填满,或者是这几种情况的任意组合。</target>
        </trans-unit>
        <trans-unit id="1945818b9ff5e13872866426c7d8f1fe8a043f70" translate="yes" xml:space="preserve">
          <source>Following the header is the array of coordinate pairs. Each coordinate is a 32-bit floating point number. The use of 32-bit floating point values for coordinates means that any point on the earth's surface can be mapped with a resolution of approximately 2.5 meters. Higher resolutions are of course possible if the map is restricted to a single continent or country. Note that the resolution of coordinates in the geopoly module is similar in magnitude to daily movement of points on the earth's surface due to tidal forces.</source>
          <target state="translated">头部后面是坐标对的数组。每个坐标都是一个32位浮点数。使用32位浮点值作为坐标,意味着地球表面的任何一点都可以用大约2.5米的分辨率进行测绘。当然,如果地图仅限于一个大陆或国家,则可以有更高的分辨率。请注意,地缘模块中坐标的分辨率与地球表面各点因潮汐力而产生的日常移动幅度相似。</target>
        </trans-unit>
        <trans-unit id="581c115a7d0dc8fd1981c305296d4c558b5b086c" translate="yes" xml:space="preserve">
          <source>Following the single big &quot;timeline&quot; query, there are additional queries for each timeline element. Fossil is using the &quot;N+1 Query&quot; pattern rather than trying to grab all the information in as few queries as possible. But that is ok because there is no unnecessary IPC overhead. At the bottom of each timeline page, Fossil shows approximately how long it took to generate the page. For a 50-entry timeline, the latency is usually less than 25 milliseconds. Profiling shows that few of those milliseconds were spent inside the database engine.</source>
          <target state="translated">在单个大的 &quot;时间线 &quot;查询之后,每个时间线元素都有额外的查询。Fossil使用的是 &quot;N+1查询 &quot;模式,而不是试图在尽可能少的查询中抓取所有信息。但这是可以的,因为没有不必要的IPC开销。在每个时间线页面的底部,Fossil显示了生成该页面所花费的大约时间。对于一个50个条目的时间线,延迟通常小于25毫秒。剖析显示,这些毫秒中很少有花在数据库引擎内部的。</target>
        </trans-unit>
        <trans-unit id="19775ac9542956e84e3786d1a483a9c9a75b880c" translate="yes" xml:space="preserve">
          <source>For BLOBs smaller than 100KB, reads are faster when the BLOBs are stored directly in the database file. For BLOBs larger than 100KB, reads from a separate file are faster.</source>
          <target state="translated">对于小于100KB的BLOBs,当BLOBs直接存储在数据库文件中时,读取速度会更快。对于大于100KB的BLOB,从单独的文件中读取会更快。</target>
        </trans-unit>
        <trans-unit id="395ae193aa1eadd77633da6e02ed51db87786473" translate="yes" xml:space="preserve">
          <source>For SQLite</source>
          <target state="translated">对于SQLite</target>
        </trans-unit>
        <trans-unit id="f3c131948733abd40fff7115bdc1ab412d61d9a8" translate="yes" xml:space="preserve">
          <source>For SQLite version 2.6.3 and earlier, all values used the numeric datatype. The text datatype appears in version 2.7.0 and later. In the sequel it is assumed that you are using version 2.7.0 or later of SQLite.</source>
          <target state="translated">对于SQLite 2.6.3和更早的版本,所有的值都使用数字数据类型。文本数据类型出现在2.7.0及以后的版本中。在后面的内容中,假设你使用的是2.7.0或更高版本的SQLite。</target>
        </trans-unit>
        <trans-unit id="942453851992f474fda1456f6f181f26cf640d20" translate="yes" xml:space="preserve">
          <source>For SQLite versions prior to 3.24.0 (2018-06-04), the only information that an R*Tree index stores about an object is its integer ID and its bounding box. Additional information needs to be stored in separate tables and related to the R*Tree index using the primary key. For the example above, one might create an auxiliary table as follows:</source>
          <target state="translated">对于3.24.0(2018-06-04)之前的SQLite版本,R*Tree索引存储的关于对象的唯一信息是其整数ID和其边界框。其他信息需要存储在单独的表中,并使用主键与R*Tree索引相关。对于上面的例子,可以创建一个辅助表,如下所示。</target>
        </trans-unit>
        <trans-unit id="50f58131252372876ea89c95a887df9a9f6004ed" translate="yes" xml:space="preserve">
          <source>For UTF-16 databases, when using the &quot;simple&quot; tokenizer, it is possible to use malformed unicode strings to cause the &lt;a href=&quot;#integcheck&quot;&gt;integrity-check special command&lt;/a&gt; to falsely report corruption, or for &lt;a href=&quot;#snippet&quot;&gt;auxiliary functions&lt;/a&gt; to return incorrect results. More specifically, the bug can be triggered by any of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a64fca4030b56c7de05a5fe2b410b314416229df" translate="yes" xml:space="preserve">
          <source>For UTF16 input text to the sqlite3_result_text16(), sqlite3_result_text16be(), sqlite3_result_text16le(), and sqlite3_result_text64() routines, if the text contains invalid UTF16 characters, the invalid characters might be converted into the unicode replacement character, U+FFFD.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b4a9ef398b6737e332f74269051f6a928aaf6c" translate="yes" xml:space="preserve">
          <source>For a &lt;b&gt;DELETE&lt;/b&gt; change, the payload consists of the PRIMARY KEY fields only. The original values of other fields are not stored as part of a patchset.</source>
          <target state="translated">对于&lt;b&gt;DELETE&lt;/b&gt;更改，有效负载仅包含PRIMARY KEY字段。其他字段的原始值不存储为补丁集的一部分。</target>
        </trans-unit>
        <trans-unit id="bad0ea706b018c5833dc966db96c3bbf3f0b2138" translate="yes" xml:space="preserve">
          <source>For a JOIN or INNER JOIN or CROSS JOIN, there is no difference between a constraint expression in the WHERE clause and one in the ON clause. However, for a LEFT JOIN or LEFT OUTER JOIN, the difference is very important. In a LEFT JOIN, the extra NULL row for the right-hand table is added after ON clause processing but before WHERE clause processing. A constraint of the form &quot;left.x=right.y&quot; in an ON clause will therefore allow through the added all-NULL rows of the right table. But if that same constraint is in the WHERE clause a NULL in &quot;right.y&quot; will prevent the expression &quot;left.x=right.y&quot; from being true, and thus exclude that row from the output.</source>
          <target state="translated">对于 JOIN 或 INNER JOIN 或 CROSS JOIN,WHERE 子句中的约束表达式和 ON 子句中的约束表达式没有区别。然而,对于LEFT JOIN或LEFT OUTER JOIN,两者的区别非常重要。在LEFT JOIN中,右侧表的额外NULL行是在ON子句处理之后,但在WHERE子句处理之前添加的。因此,在ON子句中的 &quot;left.x=right.y &quot;形式的约束将允许通过右侧表的额外全NULL行。但如果同样的约束条件在WHERE子句中,&quot;right.y &quot;中的NULL将阻止表达式 &quot;left.x=right.y &quot;为真,从而将该行从输出中排除。</target>
        </trans-unit>
        <trans-unit id="2837a8bb64314525a9077bf3440c2ed144dbb1b8" translate="yes" xml:space="preserve">
          <source>For a LEFT OUTER JOIN the situation is more complex. The following two queries are not equivalent:</source>
          <target state="translated">对于LEFT OUTER JOIN来说,情况就比较复杂了。以下两个查询并不等同。</target>
        </trans-unit>
        <trans-unit id="ad715a95908c984b7542ffaa9563f1288257e6ce" translate="yes" xml:space="preserve">
          <source>For a SELECT query that uses the full-text index, the offsets() function returns a text value containing a series of space-separated integers. For each term in each &lt;a href=&quot;#matchable&quot;&gt;phrase match&lt;/a&gt; of the current row, there are four integers in the returned list. Each set of four integers is interpreted as follows:</source>
          <target state="translated">对于使用全文索引的SELECT查询，offsets（）函数将返回一个文本值，该文本值包含一系列以空格分隔的整数。对于当前行的每个&lt;a href=&quot;#matchable&quot;&gt;短语匹配&lt;/a&gt;中的每个术语，返回列表中有四个整数。每组四个整数解释如下：</target>
        </trans-unit>
        <trans-unit id="6eca1d9c3f6f9db89f4bb4081945f8167605d308" translate="yes" xml:space="preserve">
          <source>For a command of the form &quot;REINDEX</source>
          <target state="translated">对于 &quot;REINDEX &quot;这种形式的命令,可以通过以下方式进行处理</target>
        </trans-unit>
        <trans-unit id="06d5551761da6c159b879a307caa21c04cdacf8a" translate="yes" xml:space="preserve">
          <source>For a commit involving multiple databases and a master journal, if the various databases were on different disk volumes and a power failure occurs during the commit, then when the machine comes back up the disks might be remounted with different names. Or some disks might not be mounted at all. When this happens the individual file journals and the master journal might not be able to find each other. The worst outcome from this scenario is that the commit ceases to be atomic. Some databases might be rolled back and others might not. All databases will continue to be self-consistent. To defend against this problem, keep all databases on the same disk volume and/or remount disks using exactly the same names after a power failure.</source>
          <target state="translated">对于一个涉及多个数据库和主日志的提交,如果不同的数据库在不同的磁盘卷上,而在提交过程中发生了断电,那么当机器恢复时,这些磁盘可能会以不同的名称重新挂载。或者有些磁盘可能根本就没有被挂载。在这种情况下,各个文件日志和主日志可能无法找到对方。这种情况下,最坏的结果是提交不再是原子性的。一些数据库可能会被回滚,而另一些数据库可能不会。所有的数据库将继续保持自一致。为了防御这个问题,在断电后,将所有数据库保持在同一个磁盘卷上,和/或使用完全相同的名字重新挂载磁盘。</target>
        </trans-unit>
        <trans-unit id="e40bdd6eb01aba5fc405b17e2bcc433fd88a3c9f" translate="yes" xml:space="preserve">
          <source>For a commit involving multiple databases and a super-journal, if the various databases were on different disk volumes and a power failure occurs during the commit, then when the machine comes back up the disks might be remounted with different names. Or some disks might not be mounted at all. When this happens the individual file journals and the super-journal might not be able to find each other. The worst outcome from this scenario is that the commit ceases to be atomic. Some databases might be rolled back and others might not. All databases will continue to be self-consistent. To defend against this problem, keep all databases on the same disk volume and/or remount disks using exactly the same names after a power failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb9e9e569c28385b62c9d2cc5d8fba70bcf036db" translate="yes" xml:space="preserve">
          <source>For a directory entry, any value inserted into this field is ignored. Otherwise, if it is set to 0, then the file data or symbolic link target is stored as is in the zip archive and the compression method set to 0. If it is set to 8, then the file data or link target is compressed using deflate compression before it is stored and the compression method set to 8. Finally, if a NULL value is written to this field, the zipfile module automatically decides whether or not to compress the data before storing it.</source>
          <target state="translated">对于一个目录条目,插入到这个字段的任何值都会被忽略。否则,如果设置为0,那么文件数据或符号链接目标将按原样存储在zip压缩包中,压缩方式设置为0;如果设置为8,那么文件数据或链接目标将在存储前使用deflate压缩,压缩方式设置为8。最后,如果将NULL值写入该字段,则zipfile模块会自动决定是否在存储前对数据进行压缩。</target>
        </trans-unit>
        <trans-unit id="60b588cb6440e5757b3bffacb57c3da76e66f360" translate="yes" xml:space="preserve">
          <source>For a listing of the available dot commands, you can enter &quot;.help&quot; with no arguments. Or enter &quot;.help TOPIC&quot; for detailed information about TOPIC. The list of available dot-commands follows:</source>
          <target state="translated">要想获得可用的点阵命令列表,可以输入&quot;.help&quot;,但没有参数。或者输入&quot;.help TOPIC &quot;来获取有关 TOPIC 的详细信息。可用的点阵命令列表如下。</target>
        </trans-unit>
        <trans-unit id="d4baaae0b83211d05bdb6a6f17481963667e90c7" translate="yes" xml:space="preserve">
          <source>For a program that uses an SQLite database as its &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;, when a new database instance is first created the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command is ineffective because the database contain no data from which to gather statistics. In that case, one could construct a large prototype database containing typical data during development and run the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command on this prototype database to gather statistics, then save the prototype statistics as part of the application. After deployment, when the application goes to create a new database file, it can run the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command in order to create the statistics tables, then copy the precomputed statistics obtained from the prototype database into these new statistics tables. In that way, statistics from large working data sets can be preloaded into newly created application files.</source>
          <target state="translated">对于使用SQLite数据库作为其&lt;a href=&quot;appfileformat&quot;&gt;应用程序文件格式的程序&lt;/a&gt;，当首次创建新的数据库实例时，&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令无效，因为该数据库不包含用于收集统计信息的数据。在那种情况下，可以在开发期间构建一个包含典型数据的大型原型数据库，然后在该原型数据库上运行&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令以收集统计信息，然后将原型统计信息保存为应用程序的一部分。部署后，当应用程序要创建新的数据库文件时，它可以运行&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令以创建统计信息表，然后将从原型数据库获得的预先计算的统计信息复制到这些新的统计信息表中。这样，可以将大型工作数据集中的统计信息预加载到新创建的应用程序文件中。</target>
        </trans-unit>
        <trans-unit id="a94574556e6541171dc1e77628bd7786ebcc44a5" translate="yes" xml:space="preserve">
          <source>For a row-value &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt;, the left-hand side (hereafter &quot;LHS&quot;) can be either a parenthesized list of values or a subquery with multiple columns. But the right-hand side (hereafter &quot;RHS&quot;) must be a subquery expression.</source>
          <target state="translated">对于行值&lt;a href=&quot;lang_expr#in_op&quot;&gt;IN运算符&lt;/a&gt;，左侧（以下称&amp;ldquo; LHS&amp;rdquo;）可以是带括号的值列表，也可以是具有多列的子查询。但是，右侧（以下简称&amp;ldquo; RHS&amp;rdquo;）必须是子查询表达式。</target>
        </trans-unit>
        <trans-unit id="1f6b45d36586c69d55b8983f8d799c1d8e89a8c6" translate="yes" xml:space="preserve">
          <source>For a string value X, the length(X) function returns the number of characters (not bytes) in X prior to the first NUL character. Since SQLite strings do not normally contain NUL characters, the length(X) function will usually return the total number of characters in the string X. For a blob value X, length(X) returns the number of bytes in the blob. If X is NULL then length(X) is NULL. If X is numeric then length(X) returns the length of a string representation of X.</source>
          <target state="translated">对于字符串值X,length(X)函数返回X中第一个NUL字符之前的字符数(不是字节数)。由于SQLite字符串通常不包含NUL字符,所以length(X)函数通常会返回字符串X中的字符总数。对于blob值X,length(X)返回blob中的字节数。如果X是NULL,那么length(X)就是NULL。如果X是数字型,那么length(X)返回X的字符串表示的长度。</target>
        </trans-unit>
        <trans-unit id="d7e042b4a217a46e364221bac2287b2e16ce5e8f" translate="yes" xml:space="preserve">
          <source>For added readability, also set &quot;.echo on&quot; so that the output contains the original SQL text.</source>
          <target state="translated">为了增加可读性,还可以设置&quot;.echo on&quot;,使输出包含原始SQL文本。</target>
        </trans-unit>
        <trans-unit id="464bd448fbdde2a69f1880b4aadf91dc5c60e76e" translate="yes" xml:space="preserve">
          <source>For additional information on how the SQLite library functions, the reader is directed to look at the SQLite source code directly. If you understand the material in this article, you should not have much difficulty in following the sources. Serious students of the internals of SQLite will probably also want to make a careful study of the VDBE opcodes as documented &lt;a href=&quot;opcode&quot;&gt;here&lt;/a&gt;. Most of the opcode documentation is extracted from comments in the source code using a script so you can also get information about the various opcodes directly from the &lt;b&gt;vdbe.c&lt;/b&gt; source file. If you have successfully read this far, you should have little difficulty understanding the rest.</source>
          <target state="translated">有关SQLite库如何工作的其他信息，请读者直接查看SQLite源代码。如果您了解本文中的内容，那么在遵循原始资料方面应该不会有太多困难。认真学习SQLite内部知识的学生可能也希望仔细研究&lt;a href=&quot;opcode&quot;&gt;此处&lt;/a&gt;记录的VDBE操作码。大多数操作码文档都是使用脚本从源代码中的注释中提取的，因此您也可以直接从&lt;b&gt;vdbe.c&lt;/b&gt;源文件中获取有关各种操作码的信息。如果您已经成功阅读了此书，那么理解其余内容应该没有什么困难。</target>
        </trans-unit>
        <trans-unit id="5cc0c6c827845b6d255c4013e6ccd3c888188ba4" translate="yes" xml:space="preserve">
          <source>For aggregate functions, the &lt;b&gt;xStep&lt;/b&gt; callback is invoked once for each row in the result and then &lt;b&gt;xFinalize&lt;/b&gt; is invoked at the end to compute a final answer. The xStep routine can use the &lt;b&gt;sqlite_aggregate_context()&lt;/b&gt; interface to allocate memory that will be unique to that particular instance of the SQL function. This memory will be automatically deleted after xFinalize is called. The &lt;b&gt;sqlite_aggregate_count()&lt;/b&gt; routine can be used to find out how many rows of data were passed to the aggregate. The xFinalize callback should invoke one of the &lt;b&gt;sqlite_set_result_...&lt;/b&gt; interfaces to set the final result of the aggregate.</source>
          <target state="translated">对于聚合函数，&lt;b&gt;将对&lt;/b&gt;结果中的每一行调用一次&lt;b&gt;xStep&lt;/b&gt;回调，然后在最后调用&lt;b&gt;xFinalize&lt;/b&gt;来计算最终答案。 xStep例程可以使用&lt;b&gt;sqlite_aggregate_context（）&lt;/b&gt;接口分配对于该SQL函数的特定实例唯一的内存。调用xFinalize后，该内存将被自动删除。该&lt;b&gt;sqlite_aggregate_count（）&lt;/b&gt;程序可以用来找出多行数据是如何被传递到骨料。 xFinalize回调应调用&lt;b&gt;sqlite_set_result _...&lt;/b&gt;接口之一以设置聚合的最终结果。</target>
        </trans-unit>
        <trans-unit id="4a2b8e655022b370f7bf1cade1de14d9df62358a" translate="yes" xml:space="preserve">
          <source>For all of these errors, SQLite attempts to undo just the one statement it was working on and leave changes from prior statements within the same transaction intact and continue with the transaction. However, depending on the statement being evaluated and the point at which the error occurs, it might be necessary for SQLite to rollback and cancel the entire transaction. An application can tell which course of action SQLite took by using the &lt;a href=&quot;c3ref/get_autocommit&quot;&gt;sqlite3_get_autocommit()&lt;/a&gt; C-language interface.</source>
          <target state="translated">对于所有这些错误，SQLite尝试仅撤消其正在处理的一个语句，并保留同一事务中先前语句的更改不变，然后继续进行事务。但是，根据要评估的语句和发生错误的时间点，SQLite可能有必要回滚并取消整个事务。应用程序可以通过使用&lt;a href=&quot;c3ref/get_autocommit&quot;&gt;sqlite3_get_autocommit（）&lt;/a&gt; C语言接口来判断SQLite采取了哪种行动。</target>
        </trans-unit>
        <trans-unit id="edd867afbc99c464b46e982c8bdb271f01de00a1" translate="yes" xml:space="preserve">
          <source>For all versions of SQLite up to and including 3.6.23.1, a call to &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; was required after sqlite3_step() returned anything other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; before any subsequent invocation of sqlite3_step(). Failure to reset the prepared statement using &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; would result in an &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt; return from sqlite3_step(). But after &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;version 3.6.23.1&lt;/a&gt; (2010-03-26, sqlite3_step() began calling &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; automatically in this circumstance rather than returning &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. This is not considered a compatibility break because any application that ever receives an SQLITE_MISUSE error is broken by definition. The &lt;a href=&quot;compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt; compile-time option can be used to restore the legacy behavior.</source>
          <target state="translated">对于SQLite的所有版本直至并包括3.6.23.1，将呼叫&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;是sqlite3_step后需要（）返回以外的任何&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; sqlite3_step的任何后续调用之前（）。无法使用&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;重置准备好的语句将导致从sqlite3_step（）返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;。但是在&lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;版本3.6.23.1&lt;/a&gt;（2010-03-26）之后，sqlite3_step（）在这种情况下开始自动调用&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;而不是返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;，这不认为是兼容性破坏，因为任何收到SQLITE_MISUSE错误的应用程序都会被定义破坏该&lt;a href=&quot;compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt;可以使用compile-time选项还原旧的行为。</target>
        </trans-unit>
        <trans-unit id="c8ec8a08c58f886e596c21082f16011397cbdb2b" translate="yes" xml:space="preserve">
          <source>For all versions of SQLite up to and including 3.6.23.1, a call to &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; was required after sqlite3_step() returned anything other than &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; before any subsequent invocation of sqlite3_step(). Failure to reset the prepared statement using &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; would result in an &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; return from sqlite3_step(). But after &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;version 3.6.23.1&lt;/a&gt; (2010-03-26, sqlite3_step() began calling &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; automatically in this circumstance rather than returning &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. This is not considered a compatibility break because any application that ever receives an SQLITE_MISUSE error is broken by definition. The &lt;a href=&quot;../compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt; compile-time option can be used to restore the legacy behavior.</source>
          <target state="translated">对于SQLite的所有版本直至并包括3.6.23.1，将呼叫&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;是sqlite3_step后需要（）返回以外的任何&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; sqlite3_step的任何后续调用之前（）。无法使用&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;重置准备好的语句将导致从sqlite3_step（）返回&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;。但是在&lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;版本3.6.23.1&lt;/a&gt;（2010-03-26）之后，sqlite3_step（）在这种情况下开始自动调用&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;而不是返回&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;，这不认为是兼容性破坏，因为任何收到SQLITE_MISUSE错误的应用程序都会被定义破坏该&lt;a href=&quot;../compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt;可以使用compile-time选项还原旧的行为。</target>
        </trans-unit>
        <trans-unit id="cb3ef573edb29303f7422a9886c28f0ac60f646d" translate="yes" xml:space="preserve">
          <source>For allocators other than &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;, all memory allocations are of the same size. Hence, &lt;b&gt;n&lt;/b&gt;=1 and therefore &lt;b&gt;N&lt;/b&gt;=&lt;b&gt;M&lt;/b&gt;. In other words, the memory pool need be no larger than the largest amount of memory in use at any given moment.</source>
          <target state="translated">对于除&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;之外的分配器，所有内存分配大小均相同。因此，&lt;b&gt;&amp;Ntilde;&lt;/b&gt; = 1，因此&lt;b&gt;&amp;Ntilde;&lt;/b&gt; = &lt;b&gt;中号&lt;/b&gt;。换句话说，内存池不必大于任何给定时刻正在使用的最大内存量。</target>
        </trans-unit>
        <trans-unit id="a2e786b5782b352cf04ddbf2d2c01d46af6ed148" translate="yes" xml:space="preserve">
          <source>For an &lt;b&gt;UPDATE&lt;/b&gt; change, the payload consists of the PRIMARY KEY fields and the new values of modified fields only. The original values of modified fields are not stored as part of a patchset.</source>
          <target state="translated">对于&lt;b&gt;UPDATE&lt;/b&gt;更改，有效负载仅由PRIMARY KEY字段和修改字段的新值组成。修改后的字段的原始值不存储为补丁集的一部分。</target>
        </trans-unit>
        <trans-unit id="87c8bcb65c916a4e76edf02935c7238f192ed71f" translate="yes" xml:space="preserve">
          <source>For an UPDATE or DELETE operation on a &lt;a href=&quot;../rowidtable&quot;&gt;rowid table&lt;/a&gt;, the sixth parameter passed to the preupdate callback is the initial &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row being modified or deleted. For an INSERT operation on a rowid table, or any operation on a WITHOUT ROWID table, the value of the sixth parameter is undefined. For an INSERT or UPDATE on a rowid table the seventh parameter is the final rowid value of the row being inserted or updated. The value of the seventh parameter passed to the callback function is not defined for operations on WITHOUT ROWID tables, or for INSERT operations on rowid tables.</source>
          <target state="translated">对于对&lt;a href=&quot;../rowidtable&quot;&gt;rowid表&lt;/a&gt;的UPDATE或DELETE操作，传递给preupdate回调的第六个参数是要修改或删除的行的初始&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。对于对rowid表的INSERT操作或对WITHOUT ROWID表的任何操作，第六个参数的值是未定义的。对于在rowid表上进行INSERT或UPDATE，第七个参数是要插入或更新的行的最终rowid值。没有为WITHOUT ROWID表上的操作或对rowid表上的INSERT操作定义传递给回调函数的第七个参数的值。</target>
        </trans-unit>
        <trans-unit id="3fa74a389b030ce220f00901508abe1120507900" translate="yes" xml:space="preserve">
          <source>For an UPDATE or DELETE operation on a &lt;a href=&quot;rowidtable&quot;&gt;rowid table&lt;/a&gt;, the sixth parameter passed to the preupdate callback is the initial &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row being modified or deleted. For an INSERT operation on a rowid table, or any operation on a WITHOUT ROWID table, the value of the sixth parameter is undefined. For an INSERT or UPDATE on a rowid table the seventh parameter is the final rowid value of the row being inserted or updated. The value of the seventh parameter passed to the callback function is not defined for operations on WITHOUT ROWID tables, or for INSERT operations on rowid tables.</source>
          <target state="translated">对于对&lt;a href=&quot;rowidtable&quot;&gt;rowid表&lt;/a&gt;的UPDATE或DELETE操作，传递给preupdate回调的第六个参数是要修改或删除的行的初始&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。对于对rowid表的INSERT操作或对WITHOUT ROWID表的任何操作，第六个参数的值是未定义的。对于在rowid表上进行INSERT或UPDATE，第七个参数是要插入或更新的行的最终rowid值。没有为WITHOUT ROWID表上的操作或对rowid表上的INSERT操作定义传递给回调函数的第七个参数的值。</target>
        </trans-unit>
        <trans-unit id="6babaeb551e0ac84ca65632772689ec35209b982" translate="yes" xml:space="preserve">
          <source>For an example of an INSTEAD OF trigger, consider the following schema:</source>
          <target state="translated">对于INSTEAD OF触发器的例子,请考虑以下模式。</target>
        </trans-unit>
        <trans-unit id="1cb2ec7dc6172161d64c33e9d01d6ab6fb648efe" translate="yes" xml:space="preserve">
          <source>For an expression, the datatype of the result is often determined by the outermost operator. For example, arithmetic operators (&quot;+&quot;, &quot;*&quot;, &quot;%&quot;) always return a numeric results. The string concatenation operator (&quot;||&quot;) returns a text result. And so forth. If you are ever in doubt about the datatype of an expression you can use the special &lt;b&gt;typeof()&lt;/b&gt; SQL function to determine what the datatype is. For example:</source>
          <target state="translated">对于表达式，结果的数据类型通常由最外面的运算符确定。例如，算术运算符（&amp;ldquo; +&amp;rdquo;，&amp;ldquo; *&amp;rdquo;，&amp;ldquo;％&amp;rdquo;）始终返回数字结果。字符串串联运算符（&amp;ldquo; ||&amp;rdquo;）返回文本结果。依此类推。如果您对表达式的数据类型有疑问，可以使用特殊的&lt;b&gt;typeof（）&lt;/b&gt; SQL函数来确定数据类型是什么。例如：</target>
        </trans-unit>
        <trans-unit id="8771671648f56259c0348d58066fbd244a9f5761" translate="yes" xml:space="preserve">
          <source>For an inner join, the two queries above would be identical. But special processing applies to the ON and USING clauses of an OUTER join: specifically, the constraints in an ON or USING clause do not apply if the right table of the join is on a null row, but the constraints do apply in the WHERE clause. The net effect is that putting the ON or USING clause expressions for a LEFT JOIN in the WHERE clause effectively converts the query to an ordinary INNER JOIN - albeit an inner join that runs more slowly.</source>
          <target state="translated">对于一个内部连接,上面的两个查询将是相同的。但是特殊的处理适用于OUTER join的ON和USING子句:具体来说,如果联接的右表是空行,那么ON或USING子句中的约束就不适用,但是在WHERE子句中约束就适用。净效果是,将LEFT JOIN的ON或USING子句表达式放在WHERE子句中,有效地将查询转换为普通的INNER JOIN--尽管是运行速度更慢的内部连接。</target>
        </trans-unit>
        <trans-unit id="a4c04f89a73080a41ad80cd0704141b22ed403a6" translate="yes" xml:space="preserve">
          <source>For an ordinary on-disk database file, the serialization is just a copy of the disk file. For an in-memory database or a &quot;TEMP&quot; database, the serialization is the same sequence of bytes which would be written to disk if that database where backed up to disk.</source>
          <target state="translated">对于普通的磁盘数据库文件,序列化只是磁盘文件的拷贝。对于内存数据库或 &quot;TEMP &quot;数据库来说,序列化是与该数据库备份到磁盘时写入磁盘的字节序列相同。</target>
        </trans-unit>
        <trans-unit id="363689c9e649bf1c45ea48634a5a7f396dccdc2a" translate="yes" xml:space="preserve">
          <source>For any given SQL statement, there might be hundreds or thousands or even millions of different algorithms of performing the operation. All of these algorithms will get the correct answer, though some will run faster than others. The query planner is an &lt;a href=&quot;https://en.wikipedia.org/wiki/Artificial_intelligence&quot;&gt;AI&lt;/a&gt; that tries to pick the fastest and most efficient algorithm for each SQL statement.</source>
          <target state="translated">对于任何给定的SQL语句，可能会有成百上千甚至上百万个执行该操作的不同算法。所有这些算法都会得到正确的答案，尽管有些算法的运行速度会比其他算法快。查询计划程序是一种&lt;a href=&quot;https://en.wikipedia.org/wiki/Artificial_intelligence&quot;&gt;AI&lt;/a&gt;，它试图为每个SQL语句选择最快，最高效的算法。</target>
        </trans-unit>
        <trans-unit id="20178a76e031f6e0dd46cd965f669f77257d11d8" translate="yes" xml:space="preserve">
          <source>For any given query, the fact that the OR-clause optimization described here can be used does not guarantee that it will be used. SQLite uses a cost-based query planner that estimates the CPU and disk I/O costs of various competing query plans and chooses the plan that it thinks will be the fastest. If there are many OR terms in the WHERE clause or if some of the indices on individual OR-clause subterms are not very selective, then SQLite might decide that it is faster to use a different query algorithm, or even a full-table scan. Application developers can use the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; prefix on a statement to get a high-level overview of the chosen query strategy.</source>
          <target state="translated">对于任何给定的查询，可以使用此处描述的OR子句优化的事实并不能保证一定会使用它。 SQLite使用基于成本的查询计划程序来估算各种竞争查询计划的CPU和磁盘I / O成本，并选择它认为最快的计划。如果WHERE子句中有很多OR项，或者单个OR子句的某些索引的选择性不是很高，则SQLite可能会决定使用其他查询算法甚至进行全表扫描的速度更快。应用程序开发人员可以在语句上使用&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;前缀来获得所选查询策略的高级概述。</target>
        </trans-unit>
        <trans-unit id="16c7cb0ca5e5ce3a2a0070ff33c0953ef0a2395f" translate="yes" xml:space="preserve">
          <source>For any historical version of SQLite, the source tree can be obtained from the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; version control system, either downloading a tarball or ZIP archive for a specific version, or by cloning the entire project history.</source>
          <target state="translated">对于任何SQLite的历史版本，都可以从&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt;版本控制系统中获取源代码树，可以下载特定版本的tarball或ZIP归档文件，也可以克隆整个项目历史记录。</target>
        </trans-unit>
        <trans-unit id="6136d5ebef73dfa5b00893d194ed16a2a41f54ee" translate="yes" xml:space="preserve">
          <source>For auxiliary columns, only the name of the column matters. The &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; is ignored. Constraints such as NOT NULL, UNIQUE, REFERENCES, or CHECK are also ignored. However, future versions of SQLite might start paying attention to the type affinity and constraints, so users of auxiliary columns are advised to leave both blank, to avoid future compatibility problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f9906eb0f1f05679eef0c31ffe0e8cfcb13adf" translate="yes" xml:space="preserve">
          <source>For backwards compatibility with older versions of SQLite that lack the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; interface, the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; interface is called automatically upon entry to certain key interfaces such as &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;, and &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;. The overhead of invoking &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; automatically in this way may be omitted by building SQLite with the SQLITE_OMIT_AUTOINIT C-preprocessor macro. When built using SQLITE_OMIT_AUTOINIT, SQLite will not automatically initialize itself and the application is required to invoke &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; directly prior to beginning use of the SQLite library.</source>
          <target state="translated">为了与缺少&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;接口的SQLite的旧版本向后兼容，在进入某些关键接口（例如&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;和&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;）时，会自动调用&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;接口。通过使用SQLITE_OMIT_AUTOINIT C预处理程序宏构建SQLite，可以省去以这种方式自动调用&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;的开销。使用SQLITE_OMIT_AUTOINIT构建时，SQLite不会自动初始化自身，并且要求应用程序直接在开始使用SQLite库之前调用&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2d1531a5da60e68beb6877ebc84583e140b012b5" translate="yes" xml:space="preserve">
          <source>For best security, do not use this method unless truly needed, and run &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema=OFF&lt;/a&gt; or the &quot;&lt;a href=&quot;#config&quot;&gt;db config trusted_schema 0&lt;/a&gt;&quot; method &lt;u&gt;before&lt;/u&gt; invoking this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2a0d57a438475dac09b9669a68b59949b61514" translate="yes" xml:space="preserve">
          <source>For best security, the &lt;a href=&quot;#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag is recommended for all application-defined SQL functions that do not need to be used inside of triggers, view, CHECK constraints, or other elements of the database schema. This flags is especially recommended for SQL functions that have side effects or reveal internal application state. Without this flag, an attacker might be able to modify the schema of a database file to include invocations of the function with parameters chosen by the attacker, which the application will then execute when the database file is opened and read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a82f5f85ed3a810b5bb82f46aed446a44b2ed973" translate="yes" xml:space="preserve">
          <source>For best security, the &lt;a href=&quot;c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag is recommended for all application-defined SQL functions that do not need to be used inside of triggers, view, CHECK constraints, or other elements of the database schema. This flags is especially recommended for SQL functions that have side effects or reveal internal application state. Without this flag, an attacker might be able to modify the schema of a database file to include invocations of the function with parameters chosen by the attacker, which the application will then execute when the database file is opened and read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad7a915b64d6fe6bb79ac5b4ba72d86b2b8e4dad" translate="yes" xml:space="preserve">
          <source>For bitmask tests, &lt;code&gt;testcase()&lt;/code&gt; macros are used to verify that every bit of the bitmask affects the outcome. For example, in the following block of code, the condition is true if the mask contains either of two bits indicating either a MAIN_DB or a TEMP_DB is being opened. The &lt;code&gt;testcase()&lt;/code&gt; macros that precede the if statement verify that both cases are tested:</source>
          <target state="translated">对于位掩码测试，使用 &lt;code&gt;testcase()&lt;/code&gt; 宏来验证位掩码的每一位都会影响结果。例如，在下面的代码块中，如果掩码包含两个位中的任何一个，则表明打开了MAIN_DB或TEMP_DB，该条件为true。该 &lt;code&gt;testcase()&lt;/code&gt; 宏先于if语句验证这两种情况下进行测试：</target>
        </trans-unit>
        <trans-unit id="1eab60de14b7b002b878e809e16b0c4001fb65d3" translate="yes" xml:space="preserve">
          <source>For both text and numeric values, NULL sorts before any other value. A comparison of any value against NULL using operators like &quot;&amp;lt;&quot; or &quot;&amp;gt;=&quot; is always false.</source>
          <target state="translated">对于文本值和数字值，NULL都排在其他任何值之前。使用&amp;ldquo; &amp;lt;&amp;rdquo;或&amp;ldquo; =&amp;rdquo;之类的运算符将任何值与NULL进行比较始终为false。</target>
        </trans-unit>
        <trans-unit id="0001dc558eb2ab6e42a7bb8e2fadd29ee6f23dde" translate="yes" xml:space="preserve">
          <source>For brevity, the diagrams in this section are simplified from those that came before. Blue color still signifies original content and pink still signifies new content. But the individual pages in the rollback journal and the database file are not shown and we are not making the distinction between information in the operating system cache and information that is on disk. All of these factors still apply in a multi-file commit scenario. They just take up a lot of space in the diagrams and they do not add any new information, so they are omitted here.</source>
          <target state="translated">为了简洁起见,本节的图是在前面的图基础上简化而成的。蓝色依然表示原始内容,粉色依然表示新内容。但是回滚日志和数据库文件中的各个页面没有显示出来,我们也没有区分操作系统缓存中的信息和磁盘上的信息。在多文件提交的情况下,所有这些因素仍然适用。只是它们在图中占用了很多空间,而且也没有增加任何新的信息,所以这里省略了。</target>
        </trans-unit>
        <trans-unit id="4e31069a755a0df659f64899fd564b4a8cf6e824" translate="yes" xml:space="preserve">
          <source>For command-line usage, add the short style command-line options immediately following the &quot;-A&quot;, without an intervening space. All subsequent arguments are considered to be part of the .archive command. For example, the following commands are equivalent:</source>
          <target state="translated">对于命令行的使用,请在&quot;-A &quot;之后立即添加短样式的命令行选项,中间不要有空格。所有后续参数都被认为是.archive命令的一部分。例如,以下命令是等价的。</target>
        </trans-unit>
        <trans-unit id="b9d0d974a63b482f33f7f36907a5721a5611077f" translate="yes" xml:space="preserve">
          <source>For commit records, the size of the database file in pages after the commit. For all other records, zero.</source>
          <target state="translated">对于提交记录,提交后数据库文件的大小,以页为单位。对于所有其他记录,为零。</target>
        </trans-unit>
        <trans-unit id="e91c377baed35ec4162bb3c1ca2f7aeb4671aa6f" translate="yes" xml:space="preserve">
          <source>For compatibility with older &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementations, this flag is turned on temporarily while the &lt;a href=&quot;vtab#xrename&quot;&gt;sqlite3_module.xRename&lt;/a&gt; method is being run. The value of this flag is restore after the &lt;a href=&quot;vtab#xrename&quot;&gt;sqlite3_module.xRename&lt;/a&gt; method finishes.</source>
          <target state="translated">为了与较旧的&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;实现兼容，在运行&lt;a href=&quot;vtab#xrename&quot;&gt;sqlite3_module.xRename&lt;/a&gt;方法时，将暂时打开此标志。在&lt;a href=&quot;vtab#xrename&quot;&gt;sqlite3_module.xRename&lt;/a&gt;方法完成后，将还原此标志的值。</target>
        </trans-unit>
        <trans-unit id="da9484ca4033054fc98b8e99fd5bf556ff20f8cb" translate="yes" xml:space="preserve">
          <source>For completeness, some of the higher level formatting information contains in the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; document and elsewhere is replicated here, when it pertains to WAL mode processing.</source>
          <target state="translated">为了完整起见，当涉及WAL模式处理时，&lt;a href=&quot;fileformat2&quot;&gt;文件格式&lt;/a&gt;文档中包含的某些更高级别的格式化信息以及其他内容将在此处复制。</target>
        </trans-unit>
        <trans-unit id="e99fbef35a40e331c478cf6f191e30ae20bee3b1" translate="yes" xml:space="preserve">
          <source>For correct operation of the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt;, make a copy of the &lt;a href=&quot;https://zlib.net&quot;&gt;zlib source code&lt;/a&gt; into the compat/zlib subdirectory of the source tree and compile this way:</source>
          <target state="translated">为了使&lt;a href=&quot;cli#sqlar&quot;&gt;.archive命令&lt;/a&gt;正确运行，请将&lt;a href=&quot;https://zlib.net&quot;&gt;zlib源代码&lt;/a&gt;的副本复制到源树的compat / zlib子目录中，并通过以下方式进行编译：</target>
        </trans-unit>
        <trans-unit id="a28c51fc9c57d328cc18317fd43208e2e391d0d1" translate="yes" xml:space="preserve">
          <source>For device-local storage with low writer concurrency and less than a terabyte of content, SQLite is almost always a better solution. SQLite is fast and reliable and it requires no configuration or maintenance. It keeps thing simple. SQLite &quot;just works&quot;.</source>
          <target state="translated">对于写手并发率较低、内容少于TB的设备本地存储,SQLite几乎总是更好的解决方案。SQLite快速可靠,而且不需要配置或维护。它让事情变得简单。SQLite &quot;就是好用&quot;。</target>
        </trans-unit>
        <trans-unit id="72afef4549faaf3eb91dc5ed7c4f9e5ba9217a77" translate="yes" xml:space="preserve">
          <source>For device-local storage with low writer concurrency and less than a terabyte of content, SQLite is almost always a better solution. SQLite is fast and reliable and it requires no configuration or maintenance. It keeps things simple. SQLite &quot;just works&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14026abb0078c30fcbc6bf88b3e2948c23e3f5c6" translate="yes" xml:space="preserve">
          <source>For doclists for which the term appears in more than one column of the FTS virtual table, term-offset lists within the doclist are stored in column number order. This ensures that the term-offset list associated with column 0 (if any) is always first, allowing the first two fields of the term-offset list to be omitted in this case.</source>
          <target state="translated">对于术语出现在 FTS 虚拟表中一列以上的文档列表,文档列表中的术语偏移列表按列号顺序存储。这确保了与第0列相关联的术语偏移列表(如果有的话)总是排在第一位,在这种情况下,允许省略术语偏移列表的前两个字段。</target>
        </trans-unit>
        <trans-unit id="89b4ec40df531b5b987432b4a7fed5ea5b3e27ac" translate="yes" xml:space="preserve">
          <source>For each DELETE change, the function checks if the target database contains a row with the same primary key value (or values) as the original row values stored in the changeset. If it does, and the values stored in all non-primary key columns also match the values stored in the changeset the row is deleted from the target database.</source>
          <target state="translated">对于每一个DELETE更改,该函数检查目标数据库是否包含一条与更改集中存储的原始行值具有相同主键值(或值)的行。如果确实如此,并且所有非主键列中存储的值也与变化集中存储的值相匹配,则该行将从目标数据库中删除。</target>
        </trans-unit>
        <trans-unit id="1fb2d165bb57742263f5c19d2ad3dc7e863bddd8" translate="yes" xml:space="preserve">
          <source>For each FTS virtual table in a database, three to five real (non-virtual) tables are created to store the underlying data. These real tables are called &quot;shadow tables&quot;. The real tables are named &quot;%_content&quot;, &quot;%_segdir&quot;, &quot;%_segments&quot;, &quot;%_stat&quot;, and &quot;%_docsize&quot;, where &quot;%&quot; is replaced by the name of the FTS virtual table.</source>
          <target state="translated">对于数据库中的每一个FTS虚拟表,都会创建三到五个真实(非虚拟)表来存储基础数据。这些实表被称为 &quot;影子表&quot;。实表的名称为&quot;%_content&quot;、&quot;%_segdir&quot;、&quot;%_segments&quot;、&quot;%_stat &quot;和&quot;%_docsize&quot;,其中&quot;%&quot;由FTS虚拟表的名称代替。</target>
        </trans-unit>
        <trans-unit id="ca14bfe0c8ef783300da3fae2f2faf6123712788" translate="yes" xml:space="preserve">
          <source>For each INSERT change, an attempt is made to insert the new row into the database. If the changeset row contains fewer fields than the database table, the trailing fields are populated with their default values.</source>
          <target state="translated">对于每一个INSERT更改,都会尝试将新的行插入到数据库中。如果更改集行包含的字段比数据库表少,那么后面的字段将用它们的默认值填充。</target>
        </trans-unit>
        <trans-unit id="af26a43594c40c8d5075b1d213281d1a0d5d674e" translate="yes" xml:space="preserve">
          <source>For each UPDATE change, the function checks if the target database contains a row with the same primary key value (or values) as the original row values stored in the changeset. If it does, and the values stored in all modified non-primary key columns also match the values stored in the changeset the row is updated within the target database.</source>
          <target state="translated">对于每一个UPDATE更改,该函数检查目标数据库是否包含了一条与更改集中存储的原始行值具有相同主键值(或值)的行。如果确实如此,并且所有修改后的非主键列中存储的值也与改变集中存储的值相匹配,则该行在目标数据库中被更新。</target>
        </trans-unit>
        <trans-unit id="4c2b6b338ac313921ef720ea9cbd33ced2c0a043" translate="yes" xml:space="preserve">
          <source>For each UPDATE change, the old.* and new.* values are exchanged.</source>
          <target state="translated">对于每一次UPDATE更改,旧.*和新.*值都会被交换。</target>
        </trans-unit>
        <trans-unit id="d2a86ead2de9a7fdab60caec05b45cc30754d41b" translate="yes" xml:space="preserve">
          <source>For each cell in the r-tree structure (%_node table), that:</source>
          <target state="translated">对于r树结构(%_节点表)中的每个单元格,该。</target>
        </trans-unit>
        <trans-unit id="44564b0e8d37eeca09117cb0ce5677dfdd15f643" translate="yes" xml:space="preserve">
          <source>For each change for which there is a compatible table, an attempt is made to modify the table contents according to the UPDATE, INSERT or DELETE change. If a change cannot be applied cleanly, the conflict handler function passed as the fifth argument to sqlite3changeset_apply() may be invoked. A description of exactly when the conflict handler is invoked for each type of change is below.</source>
          <target state="translated">对于每一个有兼容表的变化,都会尝试根据UPDATE、INSERT或DELETE变化来修改表的内容。如果一个变化不能被干净地应用,那么作为 sqlite3changeset_apply()的第五个参数传递的冲突处理函数可能被调用。下面描述了冲突处理程序在什么时候被调用,对每一种类型的变更的具体说明。</target>
        </trans-unit>
        <trans-unit id="fabf5b0df1d79746c4d3b0f7c3d3e26095a89ed6" translate="yes" xml:space="preserve">
          <source>For each column in a row of the result, the name of that column is used as an index in to array and the value of the column is stored in the corresponding array entry. (Caution: If two or more columns in the result set of a query have the same name, then the last column with that name will overwrite prior values and earlier columns with the same name will be inaccessible.) The special array index * is used to store a list of column names in the order that they appear.</source>
          <target state="translated">对于结果行中的每一列,该列的名称作为数组的索引,并将该列的值存储在相应的数组条目中。(注意。如果查询结果集中有两列或更多列的名称相同,那么最后一列的名称将覆盖之前的值,而之前的同名列将无法访问)。)特殊的数组索引*用于按列名出现的顺序存储列名列表。</target>
        </trans-unit>
        <trans-unit id="c334738444e4ad47d383e7911a76c91bc19cd2c6" translate="yes" xml:space="preserve">
          <source>For each column, the average number of tokens in the text values stored in the column (considering all rows in the FTS4 table). This value is only available when querying FTS4 tables, not FTS3.</source>
          <target state="translated">对于每一列,存储在该列的文本值中的平均令牌数(考虑到FTS4表中的所有行)。这个值只有在查询FTS4表时才有,而不是FTS3表。</target>
        </trans-unit>
        <trans-unit id="7a8f829d184d100e174a5aa5857d53deb24e800d" translate="yes" xml:space="preserve">
          <source>For each column, the length of the longest subsequence of phrase matches that the column value has in common with the query text. For example, if a table column contains the text 'a b c d e' and the query is 'a c &quot;d e&quot;', then the length of the longest common subsequence is 2 (phrase &quot;c&quot; followed by phrase &quot;d e&quot;).</source>
          <target state="translated">对于每一列,列值与查询文本共同的最长子序列短语匹配的长度。例如,如果一个表列包含文本 &quot;a b c d e&quot;,而查询是 &quot;a c &quot;d e&quot;&quot;,那么最长的共同子序列的长度是2(短语 &quot;c &quot;后面是短语 &quot;d e&quot;)。</target>
        </trans-unit>
        <trans-unit id="a1353b0cd18d624357976b5c201f2ed175d084b1" translate="yes" xml:space="preserve">
          <source>For each column, the length of the value stored in the current row of the FTS4 table, in tokens. This value is only available when querying FTS4 tables, not FTS3. And only if the &quot;matchinfo=fts3&quot; directive was not specified as part of the &quot;CREATE VIRTUAL TABLE&quot; statement used to create the FTS4 table.</source>
          <target state="translated">对于每一列来说,存储在FTS4表当前行中的值的长度,以令牌为单位。这个值只有在查询FTS4表时才有,而不是FTS3表。而且只有当 &quot;matchinfo=fts3 &quot;指令没有被指定为用于创建FTS4表的 &quot;CREATE VIRTUAL TABLE &quot;语句的一部分时,才可以使用。</target>
        </trans-unit>
        <trans-unit id="6e8b6483ba6be5818f8c523c79ce85a1e7ccc3ba" translate="yes" xml:space="preserve">
          <source>For each distinct combination of a phrase and table column, the following three values:</source>
          <target state="translated">对于每一个不同的短语和表列组合,以下三个值:</target>
        </trans-unit>
        <trans-unit id="cf92fe281dadfcf306551aea2a8a2fccc4c37192" translate="yes" xml:space="preserve">
          <source>For each distinct combination of a phrase and table column, the number of usable phrase matches that appear in the column. This is usually identical to the first value in each set of three returned by the &lt;a href=&quot;fts3#matchinfo-x&quot; id=&quot;matchinfo-y&quot;&gt;matchinfo 'x' flag&lt;/a&gt;. However, the number of hits reported by the 'y' flag is zero for any phrase that is part of a sub-expression that does not match the current row. This makes a difference for expressions that contain AND operators that are descendants of OR operators. For example, consider the expression:</source>
          <target state="translated">对于短语和表格列的每个不同组合，列中出现的可用短语匹配数。通常与&lt;a href=&quot;fts3#matchinfo-x&quot; id=&quot;matchinfo-y&quot;&gt;matchinfo'x'标志&lt;/a&gt;返回的每三个一组中的第一个值相同。但是，对于属于与当前行不匹配的子表达式一部分的任何短语，&amp;ldquo; y&amp;rdquo;标志报告的命中数为零。这对于包含作为OR运算符后代的AND运算符的表达式有所不同。例如，考虑以下表达式：</target>
        </trans-unit>
        <trans-unit id="fffbd38440022e9244e6e0693275b0d19d1857ad" translate="yes" xml:space="preserve">
          <source>For each modified table, a changeset includes the following:</source>
          <target state="translated">对于每个修改后的表格,变更集包括以下内容:</target>
        </trans-unit>
        <trans-unit id="a24f08d30b83fb31d42fefd2e7c6a4eb2dab4115" translate="yes" xml:space="preserve">
          <source>For each pair of columns identified by a USING clause, the column from the right-hand dataset is omitted from the joined dataset. This is the only difference between a USING clause and its equivalent ON constraint.</source>
          <target state="translated">对于USING子句确定的每一对列,右侧数据集中的列会从加入的数据集中省略。这是USING子句和其等价的ON约束之间的唯一区别。</target>
        </trans-unit>
        <trans-unit id="9c5c3e6a930debab2d5dd5b538d4a23999481e17" translate="yes" xml:space="preserve">
          <source>For each primary key recorded as a result of an INSERT operation, the sessions module checks if there is a row with a matching primary key still in the table. If so, an INSERT change is added to the changeset.</source>
          <target state="translated">对于作为INSERT操作结果而记录的每个主键,会话模块会检查表中是否仍有一条与主键匹配的记录。如果有,则会将一个INSERT更改添加到更改集中。</target>
        </trans-unit>
        <trans-unit id="829855e999389ecdd1577f6b633317b639cef854" translate="yes" xml:space="preserve">
          <source>For each primary key recorded as a result of an UPDATE or DELETE operation, the sessions module also checks for a row with a matching primary key within the table. If one can be found, but one or more of the non-PRIMARY KEY fields does not match the original recorded value, an UPDATE is added to the changeset. Or, if there is no row at all with the specified primary key, a DELETE is added to the changeset. If the row does exist but none of the non-PRIMARY KEY fields have been modified, no change is added to the changeset.</source>
          <target state="translated">对于作为UPDATE或DELETE操作的结果而记录的每个主键,会话模块也会检查表内是否有匹配主键的行。如果可以找到一个,但一个或多个非主键字段与原始记录的值不匹配,则会将UPDATE添加到更改集中。或者,如果根本就没有指定主键的记录,那么一个DELETE将被添加到变化集中。如果该行确实存在,但非主键字段都没有被修改,则不会向更改集添加任何更改。</target>
        </trans-unit>
        <trans-unit id="d07e7398b3da8e6434d5c2443839062a6f35040b" translate="yes" xml:space="preserve">
          <source>For each record generated by an insert, the database is queried for a row with a matching primary key. If one is found, an INSERT change is added to the changeset. If no such row is found, no change is added to the changeset.</source>
          <target state="translated">对于插入生成的每一条记录,数据库都会被查询到一条具有匹配主键的记录。如果找到了,就会在变化集中添加INSERT变化。如果没有找到这样的记录,则不会在变化集中添加任何变化。</target>
        </trans-unit>
        <trans-unit id="9651a17487870ac448b95f61451215a9e031bca7" translate="yes" xml:space="preserve">
          <source>For each record generated by an update or delete, the database is queried for a row with a matching primary key. If such a row is found and one or more of the non-primary key fields have been modified from their original values, an UPDATE change is added to the changeset. Or, if no such row is found in the table, a DELETE change is added to the changeset. If there is a row with a matching primary key in the database, but all fields contain their original values, no change is added to the changeset.</source>
          <target state="translated">对于更新或删除所产生的每一条记录,数据库都会被查询到一条具有匹配主键的记录。如果找到了这样的一行,并且一个或多个非主键字段已经从它们的原始值中被修改,则会向变更集添加UPDATE变更。或者,如果在表中没有找到这样的记录,那么一个DELETE变更将被添加到变更集中。如果在数据库中有一条与主键相匹配的记录,但是所有的字段都包含了它们的原始值,那么就不会对更改集添加任何更改。</target>
        </trans-unit>
        <trans-unit id="1d85944e801be901ece01bab4a06681779097370" translate="yes" xml:space="preserve">
          <source>For each record in the first table, do:</source>
          <target state="translated">对于第一张表中的每条记录,要:</target>
        </trans-unit>
        <trans-unit id="db1b960f818a6af8cfaa2c24a19e780d2703af81" translate="yes" xml:space="preserve">
          <source>For each record in the second table do:</source>
          <target state="translated">对于第二张表中的每一条记录,都要:</target>
        </trans-unit>
        <trans-unit id="07832e91f880502fa8c96087f4d7417bdd043461" translate="yes" xml:space="preserve">
          <source>For each record in the table, do:</source>
          <target state="translated">对于表中的每一条记录,要做到:</target>
        </trans-unit>
        <trans-unit id="87586acdd8d3aae53c73008136985fcb94271fa7" translate="yes" xml:space="preserve">
          <source>For each row (primary key) that exists in both tables, but features different non-PK values in each, an UPDATE record is added to the session.</source>
          <target state="translated">对于存在于两个表中,但在每个表中具有不同的非PK值的每一行(主键),都会向会话添加一条UPDATE记录。</target>
        </trans-unit>
        <trans-unit id="6b65ebd60d0a165260cae83ea942ac1bc3113efb" translate="yes" xml:space="preserve">
          <source>For each row (primary key) that exists in the to-table but not in the from-table, a DELETE record is added to the session object.</source>
          <target state="translated">对于存在于to-table中但不存在于from-table中的每一条记录(主键),会向session对象添加一条DELETE记录。</target>
        </trans-unit>
        <trans-unit id="9d14fe0322a1c66d129265052088ccffec38ab12" translate="yes" xml:space="preserve">
          <source>For each row (primary key) that exists in the to-table but not in the from-table, an INSERT record is added to the session object.</source>
          <target state="translated">对于存在于to-table中但不存在于from-table中的每一条记录(主键),都会向session对象添加一条INSERT记录。</target>
        </trans-unit>
        <trans-unit id="cf4da03b9da8c161d1cf42bd495a3368247989f4" translate="yes" xml:space="preserve">
          <source>For each row in the FTS table, the %_docsize table contains a corresponding row with the same &quot;docid&quot; value. The &quot;size&quot; field contains a blob consisting of</source>
          <target state="translated">对于FTS表中的每一条记录,%_docsize表中都包含一条对应的具有相同 &quot;docid &quot;值的记录。&quot;size &quot;字段包含一个由以下内容组成的blob</target>
        </trans-unit>
        <trans-unit id="a8c233269c53521f30c5ffc0bf77144b7402512d" translate="yes" xml:space="preserve">
          <source>For each row to DELETE from the target database as part of the RBU update, the corresponding data_% table should contain a single record with the &quot;rbu_control&quot; column set to contain integer value 1. The real primary key values of the row to delete should be stored in the corresponding columns of the data_% table. The values stored in the other columns are not used.</source>
          <target state="translated">作为 RBU 更新的一部分,对于要从目标数据库中 DELETE 的每一条记录,相应的 data_% 表应该包含一条记录,&quot;rbu_control &quot;列设置为包含整数值 1。要删除的行的真实主键值应该存储在data_%表的相应列中。存储在其他列中的值不被使用。</target>
        </trans-unit>
        <trans-unit id="6a5706b24e2b237dcb339a0ad1090fb73a23781f" translate="yes" xml:space="preserve">
          <source>For each row to INSERT into the target database as part of the RBU update, the corresponding data_% table should contain a single record with the &quot;rbu_control&quot; column set to contain integer value 0. The other columns should be set to the values that make up the new record to insert.</source>
          <target state="translated">对于作为 RBU 更新的一部分而要 INSERT 到目标数据库中的每一条记录,相应的 data_% 表应该包含一条记录,&quot;rbu_control &quot;列设置为包含整数值 0。其他列应设置为构成要插入的新记录的值。</target>
        </trans-unit>
        <trans-unit id="34669c17538b482482cba6957b264502d60d1060" translate="yes" xml:space="preserve">
          <source>For each row to UPDATE from the target database as part of the RBU update, the corresponding data_% table should contain a single record with the &quot;rbu_control&quot; column set to contain a value of type text. The real primary key values identifying the row to update should be stored in the corresponding columns of the data_% table row, as should the new values of all columns being update. The text value in the &quot;rbu_control&quot; column must contain the same number of characters as there are columns in the target database table, and must consist entirely of 'x' and '.' characters (or in some special cases 'd' - see below). For each column that is being updated, the corresponding character is set to 'x'. For those that remain as they are, the corresponding character of the rbu_control value should be set to '.'. For example, given the tables above, the update statement:</source>
          <target state="translated">作为 RBU 更新的一部分,对于要从目标数据库中 UPDATE 的每一条记录,相应的 data_% 表应该包含一条单条记录,&quot;rbu_control &quot;列设置为包含一个类型为文本的值。确定要更新的行的真实主键值应该存储在data_%表行的相应列中,所有被更新的列的新值也应该存储在其中。&quot;rbu_control &quot;列中的文本值必须包含与目标数据库表中的列相同数量的字符,并且必须完全由'x'和'.'字符组成(或者在某些特殊情况下是'd'--见下文)。对于每一个被更新的列,对应的字符都设置为'x'。对于那些保持原样的列,rbu_control值的相应字符应设置为'.'。例如,给定上面的表格,更新语句。</target>
        </trans-unit>
        <trans-unit id="a430b6812c406e37a693a08685ab05caa617b118" translate="yes" xml:space="preserve">
          <source>For each such constraint, the aConstraint[].iColumn field indicates which column appears on the left-hand side of the constraint. The first column of the virtual table is column 0. The rowid of the virtual table is column -1. The aConstraint[].op field indicates which operator is used. The SQLITE_INDEX_CONSTRAINT_* constants map integer constants into operator values. Columns occur in the order they were defined by the call to &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; in the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; or &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method. Hidden columns are counted when determining the column index.</source>
          <target state="translated">对于每个这样的约束，aConstraint []。iColumn字段指示哪一列出现在约束的左侧。虚拟表的第一列是列0。虚拟表的rowid是列-1。 aConstraint []。op字段指示使用哪个运算符。 SQLITE_INDEX_CONSTRAINT_ *常数将整数常数映射为运算符值。列按照在&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;或&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;方法中对&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt;的调用所定义的顺序出现。确定列索引时，将对隐藏的列进行计数。</target>
        </trans-unit>
        <trans-unit id="f5aad29ac204438525f336e09bd7bc093d292717" translate="yes" xml:space="preserve">
          <source>For each table in the target database that will be modified by the update, a corresponding table is created within the RBU database. The RBU database table schema is not the same as that of the target database, but is derived from it as &lt;a href=&quot;rbu#database_tables&quot;&gt;described below&lt;/a&gt;.</source>
          <target state="translated">对于目标数据库中将通过更新进行修改的每个表，都会在RBU数据库中创建一个对应的表。RBU数据库表架构与目标数据库的架构不同，但如下&lt;a href=&quot;rbu#database_tables&quot;&gt;所述&lt;/a&gt;是从其派生的。</target>
        </trans-unit>
        <trans-unit id="f11dacd70a0954440fff36de5fbb6ca308465c38" translate="yes" xml:space="preserve">
          <source>For each table in the target database, the RBU database should contain a table named &quot;data&amp;lt;</source>
          <target state="translated">对于目标数据库中的每个表，RBU数据库应包含一个名为&amp;ldquo; data &amp;lt;</target>
        </trans-unit>
        <trans-unit id="42f788bf7b6ac170ed8ce05feddfec2cba592bef" translate="yes" xml:space="preserve">
          <source>For each table read by the query, the output of EXPLAIN QUERY PLAN includes a record for which the value in the &quot;detail&quot; column begins with either &quot;SCAN&quot; or &quot;SEARCH&quot;. &quot;SCAN&quot; is used for a full-table scan, including cases where SQLite iterates through all records in a table in an order defined by an index. &quot;SEARCH&quot; indicates that only a subset of the table rows are visited. Each SCAN or SEARCH record includes the following information:</source>
          <target state="translated">对于查询读取的每个表,EXPLAIN QUERY PLAN的输出包括一条记录,该记录的 &quot;详细 &quot;列中的值以 &quot;SCAN &quot;或 &quot;SEARCH &quot;开头。&quot;SCAN &quot;用于全表扫描,包括SQLite按照索引定义的顺序遍历表中所有记录的情况。&quot;SEARCH &quot;表示只访问表行的子集。每个SCAN或SEARCH记录都包括以下信息。</target>
        </trans-unit>
        <trans-unit id="ecba2625cd566548c3eee164f8360eb376f2aaad" translate="yes" xml:space="preserve">
          <source>For each table that is not excluded by the filter callback, this function tests that the target database contains a compatible table. A table is considered compatible if all of the following are true:</source>
          <target state="translated">对于每个没有被过滤器回调排除的表,这个函数测试目标数据库是否包含一个兼容表。如果以下情况全部为真,则认为一个表是兼容的。</target>
        </trans-unit>
        <trans-unit id="a67fb3e6d59fc22a676badf1b731424e48e59895" translate="yes" xml:space="preserve">
          <source>For each term in a document, the FTS index maintained by FTS5 stores the rowid of the document, the column number of the column that contains the term and the offset of the term within the column value. The &quot;detail&quot; option may be used to omit some of this information. This reduces the space that the index consumes within the database file, but also reduces the capability and efficiency of the system.</source>
          <target state="translated">对于文档中的每个术语,由FTS5维护的FTS索引存储了文档的行号、包含术语的列号以及术语在列值中的偏移量。可以使用 &quot;详细 &quot;选项来省略其中的一些信息。这样可以减少索引在数据库文件中占用的空间,但也降低了系统的能力和效率。</target>
        </trans-unit>
        <trans-unit id="ec159e8f6dc1a68285f736b240d086ca832050e3" translate="yes" xml:space="preserve">
          <source>For each term present in the FTS table, there are between 2 and N+1 rows in the fts4aux table, where N is the number of user-defined columns in the associated FTS table. An fts4aux table always has the same four columns, as follows, from left to right:</source>
          <target state="translated">对于FTS表中的每一个术语,fts4aux表中有2至N+1行,其中N是相关FTS表中用户定义的列数。fts4aux表的四列总是相同的,从左到右如下:</target>
        </trans-unit>
        <trans-unit id="2bdf0037f493d99e63f11ef023d4ede2161885e4" translate="yes" xml:space="preserve">
          <source>For each token in the input string, the supplied callback xToken() must be invoked. The first argument to it should be a copy of the pointer passed as the second argument to xTokenize(). The third and fourth arguments are a pointer to a buffer containing the token text, and the size of the token in bytes. The 4th and 5th arguments are the byte offsets of the first byte of and first byte immediately following the text from which the token is derived within the input.</source>
          <target state="translated">对于输入字串中的每一个token,都必须调用回调xToken(),它的第一个参数应该是xTokenize()的第二个参数所传递的指针的副本。它的第一个参数应该是传递给xTokenize()的第二个参数的指针的副本,第三个和第四个参数是指向包含token文本的缓冲区的指针,以及token的大小。第三个和第四个参数是指向包含token文本的缓冲区的指针,以及token的字节数。第4个和第5个参数是输入中令牌文字的第一个字节和紧接着的第一个字节的字节偏移量。</target>
        </trans-unit>
        <trans-unit id="77d69c67e1a2a185641c2031933b357307710ee5" translate="yes" xml:space="preserve">
          <source>For each token in the text fragment that is part of a phrase match, the &quot;start match&quot; text is inserted into the fragment before the token, and the &quot;end match&quot; text is inserted immediately after it.</source>
          <target state="translated">对于文本片段中属于短语匹配的每个标记,&quot;开始匹配 &quot;的文本插入到标记之前的片段中,而 &quot;结束匹配 &quot;的文本则紧随其后插入。</target>
        </trans-unit>
        <trans-unit id="4d08b18694ad651bc6411787c4cb9cda3d56703c" translate="yes" xml:space="preserve">
          <source>For embedded systems, consider compiling SQLite with the &lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt; option and then providing SQLite with a fixed chunk of memory to use as its heap via the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;) interface. This will prevent malicious SQL from executing a denial-of-service attack by using an excessive amount of memory. If (say) 5 MB of memory is provided for SQLite to use, once that much has been consumed, SQLite will start returning SQLITE_NOMEM errors rather than soaking up memory needed by other parts of the application. This also sandboxes SQLite's memory so that a write-after-free error in some other part of the application will not cause problems for SQLite, or vice versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c5274d9826ac0360165a29a3e66a8506f1ab799" translate="yes" xml:space="preserve">
          <source>For every successful call to this method, the SQLite core will later invoke the &lt;a href=&quot;vtab#xclose&quot;&gt;xClose&lt;/a&gt; method to destroy the allocated cursor.</source>
          <target state="translated">对于此方法的每次成功调用，SQLite核心稍后都会调用&lt;a href=&quot;vtab#xclose&quot;&gt;xClose&lt;/a&gt;方法来销毁分配的游标。</target>
        </trans-unit>
        <trans-unit id="c6c48664cbefae23df70df3591300d92263e5f4c" translate="yes" xml:space="preserve">
          <source>For example to find the highest paid employee:</source>
          <target state="translated">比如要找工资最高的员工。</target>
        </trans-unit>
        <trans-unit id="2479f1e642da058be56d1001ffac81d069a0ba6c" translate="yes" xml:space="preserve">
          <source>For example, a &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; statement cannot be run while another thread is reading from that table on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; because dropping the table would delete the table out from under the concurrent reader.</source>
          <target state="translated">例如，当另一个线程正在同一&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;上从该表读取数据时，不能运行&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;语句，因为删除该表会从并发阅读器下面删除该表。</target>
        </trans-unit>
        <trans-unit id="6761f7f398c5e173f6115ef00ea11329cb9f3d54" translate="yes" xml:space="preserve">
          <source>For example, a query like the following might be used to find all R*Tree entries that overlap with a circle centered a 45.3,22.9 with a radius of 5.0:</source>
          <target state="translated">例如,像下面这样的查询可以用来查找所有与半径为5.0、以45.3、22.9为中心的圆重合的R*Tree条目。</target>
        </trans-unit>
        <trans-unit id="42fbeb339bf81a5c29e36447b781a19ea1d40440" translate="yes" xml:space="preserve">
          <source>For example, adding an &quot;ON UPDATE CASCADE&quot; clause to the foreign key as shown below enhances the example schema from section 1 to allow the user to update the artistid (the parent key of the foreign key constraint) column without breaking referential integrity:</source>
          <target state="translated">例如,在外键中添加一个 &quot;ON UPDATE CASCADE &quot;子句,如下图所示,增强了第1节中的示例模式,允许用户在不破坏引用完整性的情况下更新 artistid(外键约束的父键)列。</target>
        </trans-unit>
        <trans-unit id="68a7b041107b28bf1e4e9feea5241e1ae83cb4f3" translate="yes" xml:space="preserve">
          <source>For example, as currently implemented, if writes are happening at a steady stream that exceeds the I/O capability of the background writer thread, the queue of pending write operations will grow without bound. If this goes on for long enough, the host system could run out of memory. A more sophisticated module could to keep track of the quantity of pending writes and stop accepting new write requests when the queue of pending writes grows too large.</source>
          <target state="translated">例如,按照目前的实现方式,如果写操作以稳定的流发生,超过了后台写线程的I/O能力,那么待写操作的队列就会无限制地增长。如果这种情况持续的时间足够长,主机系统可能会耗尽内存。一个更复杂的模块可以跟踪待写数量,并在待写队列增长过大时停止接受新的写请求。</target>
        </trans-unit>
        <trans-unit id="74530ffba7f866870009106e3c8e5c0a0af944ca" translate="yes" xml:space="preserve">
          <source>For example, given the database schema:</source>
          <target state="translated">例如,给定数据库模式:</target>
        </trans-unit>
        <trans-unit id="c7f52cca71f3aa80082462a01861b0a720f46594" translate="yes" xml:space="preserve">
          <source>For example, if a prepared statement is created using the SQL text &quot;SELECT $abc,:xyz&quot; and if parameter $abc is bound to integer 2345 and parameter :xyz is unbound, then sqlite3_sql() will return the original string, &quot;SELECT $abc,:xyz&quot; but sqlite3_expanded_sql() will return &quot;SELECT 2345,NULL&quot;.</source>
          <target state="translated">例如,如果使用SQL文本 &quot;SELECT $abc,:xyz &quot;创建一条准备好的语句,如果参数$abc绑定为整数2345,而参数:xyz未绑定,那么sqlite3_sql()将返回原始字符串 &quot;SELECT $abc,:xyz&quot;,但sqlite3_expanded_sql()将返回 &quot;SELECT 2345,NULL&quot;。</target>
        </trans-unit>
        <trans-unit id="06bed93067ff2c82141c677c5fde8b31f46e4d93" translate="yes" xml:space="preserve">
          <source>For example, if both the local and remote changesets contain an INSERT of the same key on &quot;CREATE TABLE t1(a PRIMARY KEY, b)&quot;:</source>
          <target state="translated">例如,如果本地和远程的变化集都包含了 &quot;CREATE TABLE t1(a PRIMARY KEY,b)&quot;上的同一个键的INSERT。</target>
        </trans-unit>
        <trans-unit id="336ff6fc840939163a24ab8fbcfd1876f5d7462b" translate="yes" xml:space="preserve">
          <source>For example, if each of the 517430 documents in the &quot;&lt;a href=&quot;http://www.cs.cmu.edu/~enron/&quot;&gt;Enron E-Mail Dataset&lt;/a&gt;&quot; is inserted into both an FTS table and an ordinary SQLite table created using the following SQL script:</source>
          <target state="translated">例如，如果&amp;ldquo; &lt;a href=&quot;http://www.cs.cmu.edu/~enron/&quot;&gt;安然电子邮件数据集&lt;/a&gt; &amp;rdquo; 中的每个517430文档都插入到FTS表和使用以下SQL脚本创建的普通SQLite表中：</target>
        </trans-unit>
        <trans-unit id="9af2b0a0be2507f901ab349b61afc42441edaa60" translate="yes" xml:space="preserve">
          <source>For example, if nCol is the number of columns in the table, to determine if phrase p is present in column c:</source>
          <target state="translated">例如,如果nCol是表中的列数,判断短语p是否存在于列c中。</target>
        </trans-unit>
        <trans-unit id="4ff402b57bb3c7de072fb37615e2f1f44b822435" translate="yes" xml:space="preserve">
          <source>For example, if process A is in the middle of a large write transaction and at the same time process B attempts to start a new write transaction, process B will get back an SQLITE_BUSY result because SQLite only supports one writer at a time. Process B will need to wait for process A to finish its transaction before starting a new transaction. The &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; and &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt; interfaces and the &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;busy_timeout pragma&lt;/a&gt; are available to process B to help it deal with SQLITE_BUSY errors.</source>
          <target state="translated">例如，如果进程A在大型写事务中，并且进程B同时尝试启动新的写事务，则进程B将返回SQLITE_BUSY结果，因为SQLite一次仅支持一个写程序。进程B将需要等待进程A完成其事务，然后才能开始新事务。该&lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;和&lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler（）&lt;/a&gt;接口和&lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;busy_timeout编译&lt;/a&gt;可用来，以帮助它处理SQLITE_BUSY错误进程B。</target>
        </trans-unit>
        <trans-unit id="d347b5f74f99e1b9952eb3244ae0159feff20d3e" translate="yes" xml:space="preserve">
          <source>For example, if the</source>
          <target state="translated">例如,如果</target>
        </trans-unit>
        <trans-unit id="c3622449954a6635d6d6221d72610b7472bd6c7b" translate="yes" xml:space="preserve">
          <source>For example, if the aConstraint[3].argvIndex is set to 1, then when xFilter is called, the argv[0] passed to xFilter will have the EXPR value of the aConstraint[3] constraint.</source>
          <target state="translated">例如,如果将aConstraint[3].argvIndex设置为1,那么当xFilter被调用时,传递给xFilter的argv[0]将具有aConstraint[3]约束的EXPR值。</target>
        </trans-unit>
        <trans-unit id="7f637c26bc4431eea662487596dfe6901f17e071" translate="yes" xml:space="preserve">
          <source>For example, if the following SQL is passed to &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt;:</source>
          <target state="translated">例如，如果将以下SQL传递给&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="9d9a182c3de2bb26679903dabe753f3a90f09588" translate="yes" xml:space="preserve">
          <source>For example, if you have a table column declared to be of type &quot;INTEGER&quot; and you try to insert a string, the column will look at the text string and see if it looks like a number. If the string does look like a number it is converted into a number and into an integer if the number does not have a fractional part, and stored that way. But if the string is not a well-formed number it is still stored as a string. A column with a type of &quot;TEXT&quot; tries to convert numbers into an ASCII-Text representation before storing them. But BLOBs are stored in TEXT columns as BLOBs because you cannot in general convert a BLOB into text.</source>
          <target state="translated">例如,如果你有一个表列声明类型为 &quot;INTEGER&quot;,你尝试插入一个字符串,该列将查看文本字符串,看看它是否看起来像一个数字。如果字符串看起来确实像一个数字,它就会被转换成一个数字,如果这个数字没有小数部分,就会转换成一个整数,并以这种方式存储。但如果字符串不是一个格式良好的数字,它仍然会被存储为一个字符串。类型为 &quot;TEXT &quot;的列在存储前会尝试将数字转换为ASCII-文本表示。但BLOB在TEXT列中是作为BLOB存储的,因为一般情况下不能将BLOB转换为文本。</target>
        </trans-unit>
        <trans-unit id="2e8d78d9a4a4ef5a078d77893775dee024ca144a" translate="yes" xml:space="preserve">
          <source>For example, in gdb, to see the complete hierarchy of an Expr node (that is to say, the Expr node and all of its children), given a pointer &quot;pExpr&quot; to that node, type:</source>
          <target state="translated">例如,在gdb中,要查看一个Expr节点的完整层次结构(也就是说,Expr节点及其所有子节点),给定一个指向该节点的指针 &quot;pExpr&quot;,类型。</target>
        </trans-unit>
        <trans-unit id="65de8cd85e7f9352044ea42fa34fc26263f7d653" translate="yes" xml:space="preserve">
          <source>For example, in the following call to json_object(), the</source>
          <target state="translated">例如,在以下对json_object()的调用中,在</target>
        </trans-unit>
        <trans-unit id="376c3a63c2d900eda2a882017f3f3a33aef34667" translate="yes" xml:space="preserve">
          <source>For example, information about the columns in an index can be read using the &lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_info pragma&lt;/a&gt; as follows:</source>
          <target state="translated">例如，可以使用&lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_info杂指令&lt;/a&gt;读取有关索引中列的信息，如下所示：</target>
        </trans-unit>
        <trans-unit id="6bccea8458a0de711e349540a29ecfcb98a65f40" translate="yes" xml:space="preserve">
          <source>For example, let the index be</source>
          <target state="translated">例如,让指数为</target>
        </trans-unit>
        <trans-unit id="3da423bea60d2f28b9bd6c6b606ccc9294140d5b" translate="yes" xml:space="preserve">
          <source>For example, many words of Greek origin begin with letters &quot;ps&quot; where the &quot;p&quot; is silent. Ex: psalm, pseudonym, psoriasis, psyche. In another example, many Scottish surnames can be spelled with an initial &quot;Mac&quot; or &quot;Mc&quot;. Thus, &quot;MacKay&quot; and &quot;McKay&quot; are both pronounced the same.</source>
          <target state="translated">例如,许多源自希腊的单词以字母 &quot;ps &quot;开头,其中 &quot;p &quot;是无声的。例:psalm,pseudonym,psoriasis,psyche。又如,许多苏格兰的姓氏可以用首字母 &quot;Mac &quot;或 &quot;Mc &quot;来拼写。因此,&quot;MacKay &quot;和 &quot;McKay &quot;的发音都是一样的。</target>
        </trans-unit>
        <trans-unit id="20083fcfe31a171e687fd7f98763b1bd15a6a1ec" translate="yes" xml:space="preserve">
          <source>For example, say the SQL statement returns the following data when executed:</source>
          <target state="translated">例如,假设SQL语句执行时返回以下数据。</target>
        </trans-unit>
        <trans-unit id="2fbaaa7d12d4edb21ff19c0963b0289115f32a55" translate="yes" xml:space="preserve">
          <source>For example, suppose an additional database is attached to the database connection using a statement like this:</source>
          <target state="translated">例如,假设使用这样的语句在数据库连接上附加一个额外的数据库。</target>
        </trans-unit>
        <trans-unit id="81c47bbba7e6d3bcfa83f9d58601629924b27df8" translate="yes" xml:space="preserve">
          <source>For example, suppose the input word is &quot;Paskagula&quot;. The phonetic key is &quot;BACACALA&quot; which is then truncated to 4 characters &quot;BACA&quot;. The edit distance is then run on the 4980 entries (out of 272,597 entries total) of the vocabulary whose k2 values begin with BACA, yielding &quot;Pascagoula&quot; as the best match.</source>
          <target state="translated">例如,假设输入的单词是 &quot;Paskagula&quot;,那么拼音键就是 &quot;BACACALA&quot;,然后截断4个字符 &quot;BACA&quot;。语音键是 &quot;BACACALA&quot;,然后截断为4个字符 &quot;BACA&quot;。然后在词汇库中的4980个词条(总共272,597个词条中)上运行编辑距离,其k2值以BACA开头,得出 &quot;Pascagoula &quot;为最佳匹配。</target>
        </trans-unit>
        <trans-unit id="bd462d6a706c77e5432cc4b960d8cc42361a6e96" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a database of the members of a large organization where each person is assigned to a particular &quot;team&quot;. Each team has a &quot;leader&quot; who is also a member of that team. The table might look something like this:</source>
          <target state="translated">例如,假设你有一个大型组织成员的数据库,每个人被分配到一个特定的 &quot;团队&quot;。每个团队都有一个 &quot;领导者&quot;,他也是该团队的成员。这个表可能看起来像这样。</target>
        </trans-unit>
        <trans-unit id="2d2ab8533e293c8a84090c9b6694f2a969c007bb" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a table named &quot;t1&quot; with columns names &quot;a&quot;, &quot;b&quot;, and &quot;c&quot; and that you want to delete column &quot;c&quot; from this table. The following steps illustrate how this could be done:</source>
          <target state="translated">例如,假设你有一个名为 &quot;t1 &quot;的表,其列名为 &quot;a&quot;、&quot;b &quot;和 &quot;c&quot;,你想从这个表中删除列 &quot;c&quot;。下面的步骤说明了如何做到这一点。</target>
        </trans-unit>
        <trans-unit id="e8c74e845df3aa4e4554ece864cf2478aa417801" translate="yes" xml:space="preserve">
          <source>For example, suppose you wanted undo/redo on a class (table) that looks like this:</source>
          <target state="translated">例如,假设你想在一个类(表)上进行撤消/重做,它看起来像这样。</target>
        </trans-unit>
        <trans-unit id="c888ac7552fad64c94327f4d9dde6c1939c79ffa" translate="yes" xml:space="preserve">
          <source>For example, the &quot;generate_series&quot; extension (located in the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/series.c&quot;&gt;ext/misc/series.c&lt;/a&gt; file in the &lt;a href=&quot;http://www.sqlite.org/src/tree?ci=trunk&quot;&gt;source tree&lt;/a&gt;) implements an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; with the following schema:</source>
          <target state="translated">例如，&amp;ldquo; generate_series&amp;rdquo;扩展名（位于&lt;a href=&quot;http://www.sqlite.org/src/tree?ci=trunk&quot;&gt;源树&lt;/a&gt;的&lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/series.c&quot;&gt;ext / misc / series.c&lt;/a&gt;文件中）使用以下模式实现了&lt;a href=&quot;vtab#epovtab&quot;&gt;同名虚拟表&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="a41d4a0a2c571159c4d3d9a9bcfe397816127e93" translate="yes" xml:space="preserve">
          <source>For example, the first argument to the &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt; function is supposed to be a special column of the FTS3 table that contains a pointer to an fts3cursor object that contains information about the current full text search match. That pointer was formerly passed as a BLOB. For example, if the FTS3 table is named &quot;t1&quot; and has a column named &quot;cx&quot;, one might write:</source>
          <target state="translated">例如，&lt;a href=&quot;fts3#snippet&quot;&gt;snippet（）&lt;/a&gt;函数的第一个参数应该是FTS3表的特殊列，其中包含指向fts3cursor对象的指针，该对象包含有关当前全文本搜索匹配的信息。该指针以前是作为BLOB传递的。例如，如果FTS3表的名称为&amp;ldquo; t1&amp;rdquo;，并且有一列的名称为&amp;ldquo; cx&amp;rdquo;，则可能会这样写：</target>
        </trans-unit>
        <trans-unit id="a1719c0fad0c46d95494599fc76472814afb3096" translate="yes" xml:space="preserve">
          <source>For example, the following EXPLAIN QUERY PLAN command operates on a SELECT statement that is implemented by performing a full-table scan on table t1:</source>
          <target state="translated">例如,下面的EXPLAIN QUERY PLAN命令对SELECT语句进行操作,该语句通过对表t1进行全表扫描来实现。</target>
        </trans-unit>
        <trans-unit id="f54bfe9858a294d74efc1029b390f83e76127bc5" translate="yes" xml:space="preserve">
          <source>For example, the following JSON describes an isosceles triangle, sitting on the X axis and with an area of 0.5:</source>
          <target state="translated">例如,以下JSON描述了一个等腰三角形,位于X轴上,面积为0.5。</target>
        </trans-unit>
        <trans-unit id="83a6fbeea816f56be60daf62a9ac68c383f63398" translate="yes" xml:space="preserve">
          <source>For example, the following code implements a collating sequence called &quot;NOCASE&quot; that sorts in text order without regard to case:</source>
          <target state="translated">例如,下面的代码实现了一个名为 &quot;NOCASE &quot;的整理序列,它不考虑大小写,按文本顺序进行排序。</target>
        </trans-unit>
        <trans-unit id="9c27a0d3845f1eceb95943662637d42bbbaddf2a" translate="yes" xml:space="preserve">
          <source>For example, the following statement is valid in SQLite:</source>
          <target state="translated">例如,以下语句在SQLite中有效。</target>
        </trans-unit>
        <trans-unit id="c949165d26ebc110da68da66e13bc86685e04c18" translate="yes" xml:space="preserve">
          <source>For example, the values NULL, 0.0, 0, 'english' and '0' are all considered to be false. Values 1, 1.0, 0.1, -0.1 and '1english' are considered to be true.</source>
          <target state="translated">例如,值NULL、0.0、0、'english'和'0'都被认为是假的。值1、1.0、0.1、-0.1和'1english'被认为是真。</target>
        </trans-unit>
        <trans-unit id="a80abcae23d48d4d5c71b5964b931b771a14df0d" translate="yes" xml:space="preserve">
          <source>For example, this row:</source>
          <target state="translated">比如说,这一行。</target>
        </trans-unit>
        <trans-unit id="f0774215613f5a93e554bf719be214f376054f20" translate="yes" xml:space="preserve">
          <source>For example, to avoid adding the contents of the &quot;uuid&quot; field to the FTS index:</source>
          <target state="translated">例如,为了避免将 &quot;uuid &quot;字段的内容添加到FTS索引中。</target>
        </trans-unit>
        <trans-unit id="e25e9fcbc6cbbe4aa86a860fba9ee3e23406906c" translate="yes" xml:space="preserve">
          <source>For example, to create a new SQLite database named &quot;ex1&quot; with a single table named &quot;tbl1&quot;, you might do this:</source>
          <target state="translated">例如,要创建一个名为 &quot;ex1 &quot;的新SQLite数据库,其中有一个名为 &quot;tbl1 &quot;的单表,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="0a8b8eec2dca22f4460d3c1b6d1607de62d83c18" translate="yes" xml:space="preserve">
          <source>For example, to create an archive containing two text files, &quot;a.txt&quot; and &quot;b.txt&quot;, containing the text &quot;abc&quot; and &quot;123&quot; respectively:</source>
          <target state="translated">例如,创建一个包含两个文本文件的档案,&quot;a.txt &quot;和 &quot;b.txt&quot;,分别包含文本 &quot;abc &quot;和 &quot;123&quot;。</target>
        </trans-unit>
        <trans-unit id="e1c45bec4422b2834e5d74273014f0905a33b70e" translate="yes" xml:space="preserve">
          <source>For example, to inspect the contents of zip archive &quot;test.zip&quot; from the current directory:</source>
          <target state="translated">例如,要检查当前目录下的压缩包 &quot;test.zip &quot;的内容。</target>
        </trans-unit>
        <trans-unit id="460920e6960fc9166bdf09c3d3e3d2d1b9cb1172" translate="yes" xml:space="preserve">
          <source>For example, to optimize the full-text index for an FTS table named &quot;docs&quot;:</source>
          <target state="translated">例如,优化名为 &quot;docs &quot;的FTS表的全文索引。</target>
        </trans-unit>
        <trans-unit id="8112859719fda223d11dd9ecc671a2d731113a48" translate="yes" xml:space="preserve">
          <source>For example, to see a list of the tables in the database, you can enter &quot;.tables&quot;.</source>
          <target state="translated">例如,要查看数据库中的表的列表,可以输入&quot;.tables&quot;。</target>
        </trans-unit>
        <trans-unit id="3403f20bef06b9f62c829264d38a448f07fbf25f" translate="yes" xml:space="preserve">
          <source>For example, using the tables created above:</source>
          <target state="translated">例如,使用上面创建的表格。</target>
        </trans-unit>
        <trans-unit id="8baebd4e0fce8f0dca8a23890fbbeb7b6c6bd6f4" translate="yes" xml:space="preserve">
          <source>For example, when a document containing the text &quot;Right now, they're very frustrated.&quot;, the terms extracted from the document and added to the full-text index are, in order, &quot;right now they re very frustrated&quot;. Such a document would match a full-text query such as &quot;MATCH 'Frustrated'&quot;, as the simple tokenizer transforms the term in the query to lowercase before searching the full-text index.</source>
          <target state="translated">例如,当文档中包含 &quot;Right now,they're very frustrated.&quot;时,从文档中提取并添加到全文索引中的术语依次为 &quot;right now they're very frustrated&quot;。这样的文档将与 &quot;MATCH 'Frustrated'&quot;这样的全文查询相匹配,因为在搜索全文索引之前,简单的tokenizer将查询中的术语转换为小写。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="0dc693a709e03c8a242ebc99f829d5a5f0d7f07e" translate="yes" xml:space="preserve">
          <source>For examples of how the SQLite C/C++ interface can be used, refer to the source code for the &lt;b&gt;sqlite&lt;/b&gt; program in the file &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src/shell.c&lt;/a&gt; of the source tree. Additional information about sqlite is available at &lt;a href=&quot;cli&quot;&gt;cli.html&lt;/a&gt;. See also the sources to the Tcl interface for SQLite in the source file &lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;src/tclsqlite.c&lt;/a&gt;.</source>
          <target state="translated">有关如何使用SQLite C / C ++接口的示例，请参考源树的&lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src / shell.c&lt;/a&gt;文件中&lt;b&gt;sqlite&lt;/b&gt;程序的源代码。有关sqlite的其他信息，请访问&lt;a href=&quot;cli&quot;&gt;cli.html&lt;/a&gt;。另请参见源文件&lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;src / tclsqlite.c中&lt;/a&gt; SQLite的Tcl接口的源代码。</target>
        </trans-unit>
        <trans-unit id="db416b5f222a1960fcc408837e83b440afa98ccd" translate="yes" xml:space="preserve">
          <source>For floating-point substitutions (%e, %E, %f, %g, %G) the precision specifies the number of digits to display to the right of the decimal point.</source>
          <target state="translated">对于浮点替换(%e,%E,%f,%g,%G),精度指定显示在小数点右边的位数。</target>
        </trans-unit>
        <trans-unit id="cf9d217953f034811d5791d9759455b504d70d86" translate="yes" xml:space="preserve">
          <source>For full prefix support, method (3) may be preferred. In this case, because the index contains entries for both &quot;first&quot; and &quot;1st&quot;, prefix queries such as 'fi*' or '1s*' will match correctly. However, because extra entries are added to the FTS index, this method uses more space within the database.</source>
          <target state="translated">对于完全的前缀支持,方法(3)可能是首选。在这种情况下,由于索引包含了 &quot;first &quot;和 &quot;1st &quot;的条目,所以像 &quot;fi*&quot;或 &quot;1s*&quot;这样的前缀查询将正确匹配。然而,由于额外的条目被添加到FTS索引中,这种方法在数据库中使用了更多的空间。</target>
        </trans-unit>
        <trans-unit id="af625b5ec940a13ac3f0b796c61917d55c083bf9" translate="yes" xml:space="preserve">
          <source>For functions that accept &quot;</source>
          <target state="translated">对于接受&quot;</target>
        </trans-unit>
        <trans-unit id="8e0c304ceb8d93d914d671ff91751c10ea1ee104" translate="yes" xml:space="preserve">
          <source>For functions that accept JSON as their first argument, that argument can be a JSON object, array, number, string, or null. SQLite numeric values and NULL values are interpreted as JSON numbers and nulls, respectively. SQLite text values can be understood as JSON objects, arrays, or strings. If an SQLite text value that is not a well-formed JSON object, array, or string is passed into json1 function, that function will usually throw an error. (Exceptions to this rule are &lt;a href=&quot;json1#jvalid&quot;&gt;json_valid()&lt;/a&gt; and &lt;a href=&quot;json1#jquote&quot;&gt;json_quote()&lt;/a&gt;.)</source>
          <target state="translated">对于将JSON作为第一个参数的函数，该参数可以是JSON对象，数组，数字，字符串或null。 SQLite数字值和NULL值分别解释为JSON数字和null。 SQLite文本值可以理解为JSON对象，数组或字符串。如果将不是格式正确的JSON对象，数组或字符串的SQLite文本值传递给json1函数，则该函数通常会引发错误。 （此规则的例外是&lt;a href=&quot;json1#jvalid&quot;&gt;json_valid（）&lt;/a&gt;和&lt;a href=&quot;json1#jquote&quot;&gt;json_quote（）&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="f4454df1a142f9ac3cdff944002d68d2bfdcbcbb" translate="yes" xml:space="preserve">
          <source>For functions that accept PATH arguments, that PATH must be well-formed or else the function will throw an error. A well-formed PATH is a text value that begins with exactly one '$' character followed by zero or more instances of &quot;.</source>
          <target state="translated">对于接受PATH参数的函数,PATH必须是格式良好的,否则函数将抛出一个错误。一个格式良好的PATH是一个文本值,它的开头是一个'$'字符,后面是零个或多个&quot;.</target>
        </trans-unit>
        <trans-unit id="8848d7d3d9820023afd4f5c595baf809ffcb7c92" translate="yes" xml:space="preserve">
          <source>For general use in cases where the workload contains few UPDATE or DELETE operations, a good choice for automerge is 8. If the workload contains many UPDATE or DELETE commands, or if query speed is a concern, it may be advantageous to reduce automerge to 2.</source>
          <target state="translated">如果工作负载中包含很少的UPDATE或DELETE操作,那么automerge的最佳选择是8。如果工作负载中包含很多UPDATE或DELETE命令,或者担心查询速度,那么将automerge减少到2可能会更好。</target>
        </trans-unit>
        <trans-unit id="bf5110604d852a2448723644607996c9499bf3c7" translate="yes" xml:space="preserve">
          <source>For historic compatibility, the C-language interfaces return primary result codes by default. The extended result code for the most recent error can be retrieved using the &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_extended_errcode()&lt;/a&gt; interface. The &lt;a href=&quot;c3ref/extended_result_codes&quot;&gt;sqlite3_extended_result_codes()&lt;/a&gt; interface can be used to put a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; into a mode where it returns the extended result codes instead of the primary result codes.</source>
          <target state="translated">为了实现历史兼容性，默认情况下，C语言接口返回主要结果代码。可以使用&lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_extended_errcode（）&lt;/a&gt;接口检索最新错误的扩展结果代码。所述&lt;a href=&quot;c3ref/extended_result_codes&quot;&gt;sqlite3_extended_result_codes（）&lt;/a&gt;接口可用于把一个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;到那里返回扩展结果代码，而不是主要结果代码的模式。</target>
        </trans-unit>
        <trans-unit id="17b53a99ea41c50893270b0043884f065027650e" translate="yes" xml:space="preserve">
          <source>For historical reasons, and for efficiency, all sorting is currently done in memory.</source>
          <target state="translated">由于历史原因,也为了提高效率,目前所有的排序都在内存中进行。</target>
        </trans-unit>
        <trans-unit id="eeed22fa30af9d54901acfbf4c1ce1f017feb462" translate="yes" xml:space="preserve">
          <source>For integer substitutions (%d, %i, %x, %X, %o, and %p) the precision specifies minimum number of digits to display. Leading zeros are added if necessary, to expand the output to the minimum number of digits.</source>
          <target state="translated">对于整数替换(%d,%i,%x,%X,%o,and %p),精度指定了要显示的最小位数。如有必要,会添加前导零,以将输出扩大到最小的数字数。</target>
        </trans-unit>
        <trans-unit id="6f753dacad85542947673dd8fa7db3bccc0a7592" translate="yes" xml:space="preserve">
          <source>For maximum reliability and for robustness against database corruption, SQLite should always be run with its default synchronous setting of FULL.</source>
          <target state="translated">为了获得最大的可靠性和防止数据库损坏的稳健性,SQLite应该始终以其默认的同步设置FULL运行。</target>
        </trans-unit>
        <trans-unit id="489e54409f8b7e0829c336efb96f4282b5ccf13a" translate="yes" xml:space="preserve">
          <source>For more details, refer to the comments in &lt;a href=&quot;http://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h&quot;&gt;header file sqlite3rbu.h&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;http://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h&quot;&gt;头文件sqlite3rbu.h中&lt;/a&gt;的注释。</target>
        </trans-unit>
        <trans-unit id="4e6f70ecf49e4210656602d693e569fcb03d8193" translate="yes" xml:space="preserve">
          <source>For most applications, the recommended method for building SQLite is to use &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt; code file, &lt;b&gt;sqlite3.c&lt;/b&gt;, and its corresponding header file &lt;b&gt;sqlite3.h&lt;/b&gt;. The sqlite3.c code file should compile and run on any unix, Windows system without any changes or special compiler options. Most applications can simply include the sqlite3.c file together with the other C code files that make up the application, compile them all together, and have working and well configured version of SQLite.</source>
          <target state="translated">对于大多数应用程序，建议的构建SQLite的方法是使用&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;代码文件&lt;b&gt;sqlite3.c&lt;/b&gt;及其对应的头文件&lt;b&gt;sqlite3.h&lt;/b&gt;。 sqlite3.c代码文件应可以在任何UNIX Windows系统上编译并运行，而无需进行任何更改或特殊的编译器选项。大多数应用程序可以简单地将sqlite3.c文件以及其他组成应用程序的C代码文件包括在内，一起编译它们，并具有运行良好且配置良好的SQLite版本。</target>
        </trans-unit>
        <trans-unit id="99e3c9a88b32764d83bb0da10699b12fcd9a531f" translate="yes" xml:space="preserve">
          <source>For most applications, upgrading from the legacy query planner to the NGQP requires little thought or effort. Simply replace the older SQLite version with the newer version of SQLite and recompile and the application will run faster. There are no API changes nor modifications to compilation procedures.</source>
          <target state="translated">对于大多数应用程序来说,从传统的查询规划器升级到NGQP几乎不需要考虑或努力。只需将旧版SQLite替换为新版SQLite并重新编译,应用程序就会运行得更快。不需要改变API,也不需要修改编译过程。</target>
        </trans-unit>
        <trans-unit id="0efe87a820fa8cd327d2f74d3e3f1deb32107fb9" translate="yes" xml:space="preserve">
          <source>For most cases, it is true that potential attackers have no way of injecting arbitrary SQL, and so most uses of SQLite are immune to the attack above. But there are some notable exceptions. To wit:</source>
          <target state="translated">对于大多数情况下,潜在的攻击者确实没有办法注入任意的SQL,因此SQLite的大多数使用都可以免疫上述攻击。但也有一些明显的例外。即</target>
        </trans-unit>
        <trans-unit id="c86754da6df36988096aed27dea948d5f58eceba" translate="yes" xml:space="preserve">
          <source>For most non-trivial SQL databases, the key to performance is creating the right SQL indexes. In this context &quot;the right SQL indexes&quot; means those that cause the queries that an application needs to optimize run fast. The &quot;.expert&quot; command can assist with this by proposing indexes that might assist with specific queries, were they present in the database.</source>
          <target state="translated">对于大多数非平凡的SQL数据库,性能的关键是创建正确的SQL索引。在这里,&quot;正确的SQL索引 &quot;指的是那些能使应用程序需要优化的查询快速运行的索引。&quot;.expert &quot;命令可以通过提出可能有助于特定查询的索引(如果它们存在于数据库中的话)来帮助实现这一点。</target>
        </trans-unit>
        <trans-unit id="e0fd582fdc761484a0a0ca3bb5f583aafab7cdf5" translate="yes" xml:space="preserve">
          <source>For most purposes, SQLite can be built just fine using the default compilation options. However, if required, the compile-time options documented below can be used to &lt;a href=&quot;#omitfeatures&quot;&gt;omit SQLite features&lt;/a&gt; (resulting in a &lt;a href=&quot;footprint&quot;&gt;smaller compiled library size&lt;/a&gt;) or to change the &lt;a href=&quot;#defaults&quot;&gt;default values&lt;/a&gt; of some parameters.</source>
          <target state="translated">对于大多数用途，可以使用默认编译选项很好地构建SQLite。但是，如果需要，下面介绍的编译时选项可用于&lt;a href=&quot;#omitfeatures&quot;&gt;省略SQLite功能&lt;/a&gt;（导致&lt;a href=&quot;footprint&quot;&gt;较小的编译库大小&lt;/a&gt;）或更改某些参数的&lt;a href=&quot;#defaults&quot;&gt;默认值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="932b2392df531ace28cd032a80948aba14e668af" translate="yes" xml:space="preserve">
          <source>For much of its history SQLite has been focused on 100% MC/DC testing. Resistance to fuzzing attacks only became a concern with the introduction of AFL in 2014. For a while there, fuzzers were finding many problems in SQLite. In more recent years, the testing strategy of SQLite has evolved to place more emphasis on fuzz testing. We still maintain 100% MC/DC of the core SQLite code, but most testing CPU cycles are now devoted to fuzzing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be3d8fa3ad8b3f16b5f81b3d35db241bab90e030" translate="yes" xml:space="preserve">
          <source>For multi-threaded applications that are careful about how they manage threads, SQLite supports an alternative run-time configuration that is half way between not using any mutexes and the default situation of mutexing everything in sight. This in-the-middle mutex alignment can be established as follows:</source>
          <target state="translated">对于那些小心翼翼地管理线程的多线程应用程序来说,SQLite支持一种替代性的运行时配置,这种配置介于不使用任何mutexes和默认的将所有看到的东西都mutexes的情况之间。这种中间的mutex对齐方式可以建立如下。</target>
        </trans-unit>
        <trans-unit id="5bfaf72720042391e9725050a2097ea765a5277e" translate="yes" xml:space="preserve">
          <source>For newer applications, FTS4 is recommended; though if compatibility with older versions of SQLite is important, then FTS3 will usually serve just as well.</source>
          <target state="translated">对于较新的应用程序,建议使用FTS4;但如果与旧版本的SQLite的兼容性很重要,那么FTS3通常也同样适用。</target>
        </trans-unit>
        <trans-unit id="74f1cec569d928f5163be03c8f3a97d88c4bb5d9" translate="yes" xml:space="preserve">
          <source>For non-TEMP triggers, the table to be modified or queried must exist in the same database as the table or view to which the trigger is attached. TEMP triggers are not subject to the same-database rule. A TEMP trigger is allowed to query or modify any table in any &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed database.</source>
          <target state="translated">对于非TEMP触发器，要修改或查询的表必须与触发器附加到的表或视图位于同一数据库中。TEMP触发器不受同一数据库规则的约束。允许TEMP触发器查询或修改任何&lt;a href=&quot;lang_attach&quot;&gt;ATTACH版本的&lt;/a&gt;数据库中的任何表。</target>
        </trans-unit>
        <trans-unit id="eaf4afda655b698c5089cf162bb3637b1ddce067" translate="yes" xml:space="preserve">
          <source>For numeric data, this situation is more complex. If both inputs look like well-formed numbers, then they are converted into floating point values using &lt;b&gt;atof()&lt;/b&gt; and compared numerically. If one input is not a well-formed number but the other is, then the number is considered to be less than the non-number. If neither inputs is a well-formed number, then &lt;b&gt;strcmp()&lt;/b&gt; is used to do the comparison.</source>
          <target state="translated">对于数字数据，这种情况更为复杂。如果两个输入都看起来像格式正确的数字，则可以使用&lt;b&gt;atof（）&lt;/b&gt;将它们转换为浮点值并进行数值比较。如果一个输入不是格式正确的数字，而另一个是格式正确的数字，则认为该数字小于该非数字。如果两个输入都不是格式正确的数字，则使用&lt;b&gt;strcmp（）&lt;/b&gt;进行比较。</target>
        </trans-unit>
        <trans-unit id="11d66790f63457992337a522f75d0ba8c19d49c3" translate="yes" xml:space="preserve">
          <source>For ordinary FTS3/FTS4 queries, the search tree depth is approximately the base-2 logarithm of the number of terms in the right-hand side of the MATCH operator. However, for &lt;a href=&quot;fts3#phrase&quot;&gt;phrase queries&lt;/a&gt; and &lt;a href=&quot;fts3#near&quot;&gt;NEAR queries&lt;/a&gt; the search tree depth is linear in the number of right-hand side terms. So the default depth limit of 12 is sufficient for up to 4095 ordinary terms on a MATCH, it is only sufficient for 11 or 12 phrase or NEAR terms. Even so, the default is more than enough for most application.</source>
          <target state="translated">对于普通的FTS3 / FTS4查询，搜索树深度大约是MATCH运算符右侧的项数的以2为底的对数。但是，对于&lt;a href=&quot;fts3#phrase&quot;&gt;短语查询&lt;/a&gt;和&lt;a href=&quot;fts3#near&quot;&gt;NEAR查询&lt;/a&gt;，搜索树的深度在右侧术语的数量上是线性的。因此，默认深度限制12足以匹配MATCH上的4095个普通术语，仅足以满足11或12个短语或NEAR术语。即使这样，对于大多数应用程序而言，默认值也绰绰有余。</target>
        </trans-unit>
        <trans-unit id="87e6be4eb608f1997fb25355e4537ee88db28dd4" translate="yes" xml:space="preserve">
          <source>For performance measurement, SQLite is compiled in approximately the same way as it would be for use in production systems. The compile-time configuration is &quot;approximate&quot; in the sense that every production use of SQLite is different. Compile-time options used by one system are not necessarily the same as those used by others. The key point is that options that significantly impact the generated machine code are avoided. For example, the -DSQLITE_DEBUG option is omitted because that option inserts thousands of assert() statements in the middle of performance critical sections of the SQLite library. The -pg option (on GCC) is omitted because it causes the compiler to emit extra probabilistic performance measuring code which interferes with actual performance measurements.</source>
          <target state="translated">对于性能测量,SQLite的编译方式与在生产系统中使用的方式大致相同。编译时的配置是 &quot;近似 &quot;的,因为SQLite的每个生产用途都是不同的。一个系统使用的编译时选项不一定与其他系统使用的相同。关键的一点是,要避免使用对生成的机器代码有重大影响的选项。例如,-DSQLITE_DEBUG选项被省略了,因为该选项在SQLite库的性能关键部分中间插入了成千上万条assert()语句。省略了-pg选项(在GCC上),因为它会导致编译器发出额外的概率性能测量代码,干扰实际的性能测量。</target>
        </trans-unit>
        <trans-unit id="f448cd989ab34ec0bc46f3d775e49bf2cb96fd96" translate="yes" xml:space="preserve">
          <source>For performance measurements, the -Os option is used (optimize for size) rather than -O2 because the -O2 option creates so much code movement that it is difficult to associate specific CPU instructions to C source code lines.</source>
          <target state="translated">对于性能测量,使用-Os选项(优化大小)而不是-O2,因为-O2选项会产生大量的代码移动,很难将特定的CPU指令与C源代码行关联起来。</target>
        </trans-unit>
        <trans-unit id="5c184bd0f5295912e4ff3123f4057a4db6895161" translate="yes" xml:space="preserve">
          <source>For performance reasons, it is advantageous to &lt;b&gt;minimize the quantity of data read and written&lt;/b&gt; to and from the file-system.</source>
          <target state="translated">出于性能原因，将&lt;b&gt;读写&lt;/b&gt;文件系统&lt;b&gt;的数据量减&lt;/b&gt;到&lt;b&gt;最少&lt;/b&gt;是有利的。</target>
        </trans-unit>
        <trans-unit id="07b863ed3fe569c9ef5b6a594040618449a6d03c" translate="yes" xml:space="preserve">
          <source>For programs that have a lot of data that must be sifted and sorted in diverse ways, it is often easier and quicker to load the data into an in-memory SQLite database and use queries with joins and ORDER BY clauses to extract the data in the form and order needed rather than to try to code the same operations manually. Using an SQL database internally in this way also gives the program greater flexibility since new columns and indices can be added without having to recode every query.</source>
          <target state="translated">对于有很多数据必须以不同方式进行筛选和排序的程序来说,将数据加载到内存中的SQLite数据库中,并使用带有连接和ORDER BY子句的查询,以所需的形式和顺序提取数据,而不是试图手动编写相同的操作代码,这往往更容易和更快。以这种方式在内部使用SQL数据库,还可以给程序带来更大的灵活性,因为可以添加新的列和索引,而不必重新编写每个查询。</target>
        </trans-unit>
        <trans-unit id="9dd6714e0fb0a2d212f83820882b4bc1eae38324" translate="yes" xml:space="preserve">
          <source>For queries that use OR expressions, or those that use LIMIT or return many rows, the 'y' matchinfo option may be faster than 'x'.</source>
          <target state="translated">对于使用OR表达式的查询,或者使用LIMIT或返回多条记录的查询,&quot;y &quot;matchinfo选项可能比 &quot;x &quot;更快。</target>
        </trans-unit>
        <trans-unit id="0c9ccc0a52d5200b9388c921b60acbab7d6fb34e" translate="yes" xml:space="preserve">
          <source>For queries, extract results by calling &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; in between two calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">对于查询，通过调用提取结果&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column（）&lt;/a&gt;两次调用之间&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5bf18084dc0d97ae369c3088b48ef4a87de7f25" translate="yes" xml:space="preserve">
          <source>For reading database files that are unusually high-risk, such as database files that are received from remote machines, and possibly from anonymous contributors, the following extra precautions might be justified. These added defenses come with performance costs, however, and so may not be appropriate in every situation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85d9929e5f003ec622c68d9ac564cf73c6c4c155" translate="yes" xml:space="preserve">
          <source>For reading existing zip archives, the Zipfile module provides a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; that accepts a single argument. If the argument is a text value, then it is a path to a zip archive to read from the file-system. Or, if the argument is an SQL blob, then it is the zip archive data itself.</source>
          <target state="translated">为了读取现有的zip存档，Zipfile模块提供了一个&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;，该函数接受单个参数。如果参数是文本值，则它是要从文件系统读取的zip存档的路径。或者，如果参数是SQL Blob，则它是zip归档数据本身。</target>
        </trans-unit>
        <trans-unit id="9867027f324defd1a582c5a9d9007cb8936fd6ce" translate="yes" xml:space="preserve">
          <source>For reasons of backwards compatibility, the &quot;automerge=1&quot; command sets the automerge parameter to 8, not 1 (a value of 1 would make no sense anyway, as merging data from a single segment is a no-op).</source>
          <target state="translated">出于向后兼容性的考虑,&quot;automerge=1 &quot;命令将automerge参数设置为8,而不是1(1的值无论如何都是没有意义的,因为从一个片段中合并数据是不可能的)。</target>
        </trans-unit>
        <trans-unit id="a23d1c74ece13b6a1e6d02aa92a4e6d015b8a626" translate="yes" xml:space="preserve">
          <source>For regular functions, the &lt;b&gt;xFunc&lt;/b&gt; callback is invoked once for each function call. The implementation of xFunc should call one of the &lt;b&gt;sqlite_set_result_...&lt;/b&gt; interfaces to return its result. The &lt;b&gt;sqlite_user_data()&lt;/b&gt; routine can be used to retrieve the &lt;b&gt;pUserData&lt;/b&gt; pointer that was passed in when the function was registered.</source>
          <target state="translated">对于常规函数，每个函数调用都会调用一次&lt;b&gt;xFunc&lt;/b&gt;回调。xFunc的实现应调用&lt;b&gt;sqlite_set_result _...&lt;/b&gt;接口之一以返回其结果。所述&lt;b&gt;sqlite_user_data（）&lt;/b&gt;例行程序可用于检索&lt;b&gt;pUserData&lt;/b&gt;这是当被登记的功能传入指针。</target>
        </trans-unit>
        <trans-unit id="d0ed67ff8b79adf22c16c2b1f3556a389aea4a01" translate="yes" xml:space="preserve">
          <source>For resilience when confronted with historical SQL statements, SQLite will sometimes bend the quoting rules above:</source>
          <target state="translated">为了在面对历史SQL语句时的弹性,SQLite有时会弯曲上面的引用规则。</target>
        </trans-unit>
        <trans-unit id="e7eae9c3102a4115cf6fa58568800e787b48e7a4" translate="yes" xml:space="preserve">
          <source>For security reasons, extension loaded is turned off by default and must be enabled by a prior call to &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt;.</source>
          <target state="translated">出于安全原因，加载的扩展名默认情况下处于关闭状态，并且必须通过事先调用&lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）&lt;/a&gt;来启用。</target>
        </trans-unit>
        <trans-unit id="c4880044a5796d62d55405bede28ef5f4f52805b" translate="yes" xml:space="preserve">
          <source>For security reasons, extension loading is turned off by default. In order to use either the C-language or SQL extension loading functions, one must first enable extension loading using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;,1,NULL) C-language API in your application.</source>
          <target state="translated">出于安全原因，扩展加载默认情况下处于关闭状态。为了使用C语言或SQL扩展加载功能，必须首先在应用程序中使用&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;，1，NULL）C语言API 启用扩展加载。</target>
        </trans-unit>
        <trans-unit id="90f079fcf7344dc268fa3af2372e90f48b6aca40" translate="yes" xml:space="preserve">
          <source>For security reasons, it is recommended that applications first set &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema=OFF&lt;/a&gt; or run the &quot;&lt;a href=&quot;#config&quot;&gt;db config trusted_schema 0&lt;/a&gt;&quot; method before using this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92cbc8f2d6b97260523c5a56f27aa3c653ce65fe" translate="yes" xml:space="preserve">
          <source>For signed numeric substitutions, include a &quot;+&quot; sign before positive numbers. A &quot;-&quot; sign always appears before negative numbers regardless of flag settings.</source>
          <target state="translated">对于有符号的数字替换,在正数前加入 &quot;+&quot;号。无论标志设置如何,&quot;-&quot;号总是出现在负数前。</target>
        </trans-unit>
        <trans-unit id="0a389ef1f84e1f5ea12705422f16f304415d7e84" translate="yes" xml:space="preserve">
          <source>For signed numeric substitutions, prepend a single space before positive numbers.</source>
          <target state="translated">对于有符号的数字替换,在正数前加一个空格。</target>
        </trans-unit>
        <trans-unit id="8361cfb2d567750344a1d16c228e8f02d706a6ad" translate="yes" xml:space="preserve">
          <source>For simple queries against a single table with few indexes, there is usually an obvious choice for the best algorithm. But for larger and more complex queries, such as multi-way joins with many indexes and subqueries, there can be hundreds, thousands, or millions of reasonable algorithms for computing the result. The job of the query planner is to choose the single &quot;best&quot; query plan from this multitude of possibilities.</source>
          <target state="translated">对于针对一张索引少的单表的简单查询,通常会有一个明显的最佳算法选择。但是对于较大和较复杂的查询,例如有许多索引和子查询的多路连接,可能会有数百、数千或数百万种合理的算法来计算结果。查询规划器的工作就是从这众多的可能性中选择一个 &quot;最佳 &quot;的查询计划。</target>
        </trans-unit>
        <trans-unit id="a9d77b186d3d3bf7ae8219371bcb8b76fedae519" translate="yes" xml:space="preserve">
          <source>For small databases and modern CPUs, there is usually no reason not to pass &quot;--sample 100&quot;. However, gathering data distribution statistics can be expensive for large database tables. If the operation is too slow, try passing a smaller value for the --sample option.</source>
          <target state="translated">对于小型数据库和现代CPU,通常没有理由不通过&quot;--sample 100&quot;。但是,对于大型数据库表来说,收集数据分布统计的费用可能很高。如果操作太慢,可以尝试为--sample选项传递一个较小的值。</target>
        </trans-unit>
        <trans-unit id="a4a24ddee4d5daf8ddd5ba8dfd7d48787ebb03b7" translate="yes" xml:space="preserve">
          <source>For string substitutions (%s, %z, %q, %Q, or %w) the precision is the number of byte or character used from the argument. The number is bytes by default but is characters if the &quot;!&quot; flag is present. If there is no precision, then the entire string is substituted. Examples: &quot;%.3s&quot; substitutes the first 3 bytes of the argument string. &quot;%!.3s&quot; substitutes the first three characters of the argument string.</source>
          <target state="translated">对于字符串替换(%s,%z,%q,%Q,或 %w),精度是参数中使用的字节数或字符数。默认情况下是字节数,但如果有&quot;!&quot;标志,则是字符数。如果没有精度,则用整个字符串代替。例如:&quot;%.3s &quot;代替了参数中的字符。&quot;%.3s&quot; 替换参数字符串的前3个字节。&quot;%!.3s &quot;替换参数字符串的前三个字符。</target>
        </trans-unit>
        <trans-unit id="e7573ff9c5daeb6537cacfee96e59061a43495a3" translate="yes" xml:space="preserve">
          <source>For subprograms, there is a bitmask in the VdbeFrame that determines whether or not the jump should be taken. The bitmask is necessary because the self-altering code trick does not work for recursive triggers.</source>
          <target state="translated">对于子程序,在VdbeFrame中有一个位掩码来决定是否应该采取跳转。位掩码是必要的,因为自改代码技巧对递归触发器不起作用。</target>
        </trans-unit>
        <trans-unit id="1ef6b92612835372e131287be2c793df5805bcf9" translate="yes" xml:space="preserve">
          <source>For table columns, the datatype is determined by the type declaration of the CREATE TABLE statement. The datatype is text if and only if the type declaration contains one or more of the following strings:</source>
          <target state="translated">对于表列,数据类型由CREATE TABLE语句的类型声明决定。如果且仅当类型声明包含以下一个或多个字符串时,数据类型是文本。</target>
        </trans-unit>
        <trans-unit id="7117d5cbbb5730360ccac5d30c1470b52beef293" translate="yes" xml:space="preserve">
          <source>For testing on embedded systems, the mkth3.tcl script and the compiler steps shown above are performed on an ordinary workstation using a cross-compiler, then the resulting test program is transferred onto the device to be run.</source>
          <target state="translated">对于嵌入式系统的测试,mkth3.tcl脚本和上面所示的编译步骤是在普通工作站上使用交叉编译器进行的,然后将得到的测试程序转移到要运行的设备上。</target>
        </trans-unit>
        <trans-unit id="d2eb4ede923268e657583d146fd6fd411d8b52aa" translate="yes" xml:space="preserve">
          <source>For the --insert command, all files listed are inserted into the archive. For the --update command, files are only inserted if they do not previously exist in the archive, or if their &quot;mtime&quot; or &quot;mode&quot; is different from what is currently in the archive.</source>
          <target state="translated">对于--insert命令,所有列出的文件都会被插入到归档中。对于--update命令,只有当文件以前不存在于归档中,或者它们的 &quot;mtime &quot;或 &quot;mode &quot;与当前归档中的文件不同时,才会被插入。</target>
        </trans-unit>
        <trans-unit id="0d9d2265812b12b9762e700ccc4ceb3931ebf930" translate="yes" xml:space="preserve">
          <source>For the C-language interfaces, the argument is an integer which is interpreted as a character. For the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; the argument is a string from which the first character is extracted and displayed.</source>
          <target state="translated">对于C语言接口，该参数是一个整数，它被解释为字符。对于&lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf（）SQL函数，&lt;/a&gt;自变量是一个字符串，将从中提取并显示第一个字符。</target>
        </trans-unit>
        <trans-unit id="c95ceb997c597a8e6a21b33cbd1c20d5ac14d94b" translate="yes" xml:space="preserve">
          <source>For the GLOB operator, the column must be indexed using the built-in BINARY collating sequence.</source>
          <target state="translated">对于GLOB操作符,必须使用内置的BINARY整理序列对列进行索引。</target>
        </trans-unit>
        <trans-unit id="8b7943406433a1489b27536ff1cedb40c6a83fc4" translate="yes" xml:space="preserve">
          <source>For the LIKE operator, if &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like&lt;/a&gt; mode is enabled then the column must indexed using BINARY collating sequence, or if &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like&lt;/a&gt; mode is disabled then the column must indexed using built-in NOCASE collating sequence.</source>
          <target state="translated">对于LIKE运算符，如果启用&lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like&lt;/a&gt;模式，则该列必须使用BINARY排序序列进行索引；或者，如果禁用&lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like&lt;/a&gt;模式，则该列必须使用内置的NOCASE排序序列进行索引。</target>
        </trans-unit>
        <trans-unit id="394b73aae0d0953d9f85a4d75a67f00c2d16e226" translate="yes" xml:space="preserve">
          <source>For the SELECT statement above, the optimizer can use the ex2i1 index to lookup rows of ex2 that contain x=5 and then test each row against the y=6 term. Or it can use the ex2i2 index to lookup rows of ex2 that contain y=6 then test each of those rows against the x=5 term.</source>
          <target state="translated">对于上面的SELECT语句,优化器可以使用ex2i1索引来查找ex2中包含x=5的记录,然后根据y=6项来测试每一条记录。或者使用ex2i2索引来查找ex2中包含y=6的行,然后根据x=5项来测试每一条行。</target>
        </trans-unit>
        <trans-unit id="6880a2956aa62196c20844c37991ebf1c9cc0265" translate="yes" xml:space="preserve">
          <source>For the character substitution (%c) a precision N greater than 1 causes the character to be repeated N times. This is a non-standard extension found only in SQLite.</source>
          <target state="translated">对于字符替换(%c),精度N大于1会导致该字符重复N次。这是一个只在SQLite中才有的非标准扩展。</target>
        </trans-unit>
        <trans-unit id="cbfa8c438ab75aa5b53746b3a61a2493fdc0fcad" translate="yes" xml:space="preserve">
          <source>For the common case where we want the busy callback to sleep, the SQLite library provides a convenience routine &lt;b&gt;sqlite_busy_timeout&lt;/b&gt;. The first argument to &lt;b&gt;sqlite_busy_timeout&lt;/b&gt; is a pointer to an open SQLite database and the second argument is a number of milliseconds. After &lt;b&gt;sqlite_busy_timeout&lt;/b&gt; has been executed, the SQLite library will wait for the lock to clear for at least the number of milliseconds specified before it returns SQLITE_BUSY. Specifying zero milliseconds for the timeout restores the default behavior.</source>
          <target state="translated">对于我们希望繁忙的回调进入睡眠状态的常见情况，SQLite库提供了一个便捷例程&lt;b&gt;sqlite_busy_timeout&lt;/b&gt;。&lt;b&gt;sqlite_busy_timeout&lt;/b&gt;的第一个参数是指向打开的SQLite数据库的指针，第二个参数是毫秒数。之后&lt;b&gt;sqlite_busy_timeout&lt;/b&gt;已执行，SQLite库将等待锁定清除它返回SQLITE_BUSY之前指定的毫秒数量最少。为超时指定零毫秒将恢复默认行为。</target>
        </trans-unit>
        <trans-unit id="77995af2794868d5e3e1a545ee53f68c9abf9c9a" translate="yes" xml:space="preserve">
          <source>For the index above and WHERE clause like this:</source>
          <target state="translated">对于上面的索引和WHERE子句这样。</target>
        </trans-unit>
        <trans-unit id="bb541928f8f21ef53252b3fcd58c0333fdfa446f" translate="yes" xml:space="preserve">
          <source>For the most part, ordinary rowid tables and WITHOUT ROWID tables are interchangeable. But there are some additional restrictions on WITHOUT ROWID tables that do not apply to ordinary rowid tables:</source>
          <target state="translated">在大多数情况下,普通rowid表和without rowid表是可以互换的。但是对于WITHOUT ROWID表还有一些额外的限制,这些限制并不适用于普通的rowid表。</target>
        </trans-unit>
        <trans-unit id="bee902327ddee3eaa34014db30d1eb9d18663957" translate="yes" xml:space="preserve">
          <source>For the purpose of computing window functions, the result set of a query is divided into one or more &quot;partitions&quot;. A partition consists of all rows that have the same value for all terms of the PARTITION BY clause in the window-defn. If there is no PARTITION BY clause, then the entire result set of the query is a single partition. Window-function processing is performed separately for each partition.</source>
          <target state="translated">为了计算窗口函数,查询的结果集被划分为一个或多个 &quot;分区&quot;。一个分区由对window-defn中的PARTITION BY子句的所有条款具有相同值的所有行组成。如果没有partition by子句,那么整个查询的结果集就是一个分区。对每个分区分别进行窗口函数处理。</target>
        </trans-unit>
        <trans-unit id="b3fd877f7b6778afbc1e68eb5017d97a2b27eeb2" translate="yes" xml:space="preserve">
          <source>For the purpose of the &lt;b&gt;sqlite_complete&lt;/b&gt; function, an SQL statement is complete if it ends in a semicolon.</source>
          <target state="translated">就&lt;b&gt;sqlite_complete&lt;/b&gt;函数而言，如果SQL语句以分号结尾，则它是完整的。</target>
        </trans-unit>
        <trans-unit id="3bdae1911eb2b3c855db66c9e8e796a26c988410" translate="yes" xml:space="preserve">
          <source>For the purposes of determining duplicate rows for the results of compound SELECT operators, NULL values are considered equal to other NULL values and distinct from all non-NULL values. The collation sequence used to compare two text values is determined as if the columns of the left and right-hand SELECT statements were the left and right-hand operands of the equals (=) operator, except that greater precedence is not assigned to a collation sequence specified with the postfix COLLATE operator. No affinity transformations are applied to any values when comparing rows as part of a compound SELECT.</source>
          <target state="translated">为了确定复合SELECT操作符结果的重复行,NULL值被认为与其他NULL值相等,并与所有非NULL值不同。用于比较两个文本值的整理序列的确定,就像左手和右手SELECT语句的列是等于(=)操作符的左手和右手操作符一样,只是不给用后缀COLLATE操作符指定的整理序列分配更大的优先权。当比较行作为复合SELECT的一部分时,不对任何值应用亲和力转换。</target>
        </trans-unit>
        <trans-unit id="593804fd692754b9bd9050d15e0853bf78663ff7" translate="yes" xml:space="preserve">
          <source>For the purposes of determining validity, leading and trailing whitespace on JSON inputs is ignored. Interior whitespace is also ignored, in accordance with the JSON spec. These routines accept exactly the &lt;a href=&quot;http://www.rfc-editor.org/rfc/rfc7159.txt&quot;&gt;rfc-7159 JSON syntax&lt;/a&gt; &amp;mdash; no more and no less.</source>
          <target state="translated">为了确定有效性，将忽略JSON输入上的前导和尾随空格。根据JSON规范，内部空格也将被忽略。这些例程完全接受&lt;a href=&quot;http://www.rfc-editor.org/rfc/rfc7159.txt&quot;&gt;rfc-7159 JSON语法&lt;/a&gt; -不多也不少。</target>
        </trans-unit>
        <trans-unit id="4f71629a5f8d309dcb7934e2a9e496e90193e44f" translate="yes" xml:space="preserve">
          <source>For the purposes of sorting rows, values are compared in the same way as for &lt;a href=&quot;datatype3#comparisons&quot;&gt;comparison expressions&lt;/a&gt;. The collation sequence used to compare two text values is determined as follows:</source>
          <target state="translated">为了对行进行排序，将以与&lt;a href=&quot;datatype3#comparisons&quot;&gt;比较表达式&lt;/a&gt;相同的方式比较值。用于比较两个文本值的排序规则序列确定如下：</target>
        </trans-unit>
        <trans-unit id="15ea441aee0df5dfef81b948679ce855bde68d24" translate="yes" xml:space="preserve">
          <source>For the purposes of the previous four items, two database connections that use the same &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; and which enable &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted&lt;/a&gt; are considered to be the same database connection, not separate database connections.</source>
          <target state="translated">出于前面四项的目的，使用相同&lt;a href=&quot;sharedcache&quot;&gt;共享缓存&lt;/a&gt;并启用&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted的&lt;/a&gt;两个数据库连接被视为同一数据库连接，而不是单独的数据库连接。</target>
        </trans-unit>
        <trans-unit id="206270d8fd15072121eb3d0a56144d865640f2b5" translate="yes" xml:space="preserve">
          <source>For the purposes of the previous two paragraphs, two database connections that have the same &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; and which have enabled &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted&lt;/a&gt; are considered to be the same database connection.</source>
          <target state="translated">出于前两段的目的，两个具有相同&lt;a href=&quot;sharedcache&quot;&gt;共享缓存&lt;/a&gt;并启用&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted&lt;/a&gt;的数据库连接被视为同一数据库连接。</target>
        </trans-unit>
        <trans-unit id="a17e59e38b9d3bf2b2df3849089638f1437b4d1e" translate="yes" xml:space="preserve">
          <source>For the purposes of this API, a transaction is said to have been rolled back if an explicit &quot;ROLLBACK&quot; statement is executed, or an error or constraint causes an implicit rollback to occur. The rollback callback is not invoked if a transaction is automatically rolled back because the database connection is closed.</source>
          <target state="translated">在这个API中,如果一个显式的 &quot;ROLLBACK &quot;语句被执行,或者一个错误或约束导致一个隐式的回滚发生,那么一个事务就被称为已经回滚。如果一个事务因为数据库连接被关闭而自动回滚,那么回滚回调将不会被调用。</target>
        </trans-unit>
        <trans-unit id="57f69f1f3e95239c1d08d8e626c461a431a40ba6" translate="yes" xml:space="preserve">
          <source>For the purposes of this pragma, the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command is considered a schema change, since &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; will usual alter the &quot;rootpage&quot; values for entries in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master table&lt;/a&gt;.</source>
          <target state="translated">就此编译指示而言，将&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令视为架构更改，因为&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;通常会更改&lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master表中&lt;/a&gt;条目的&amp;ldquo; rootpage&amp;rdquo;值。</target>
        </trans-unit>
        <trans-unit id="a9b750853d344854f9aa1e24acbcd47fcdfc4ad1" translate="yes" xml:space="preserve">
          <source>For the purposes of this pragma, the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command is considered a schema change, since &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; will usual alter the &quot;rootpage&quot; values for entries in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e03b6c7391fbf0bc56188a8c09cd4a7c0b4cdfb" translate="yes" xml:space="preserve">
          <source>For the purposes of this routine, an &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; is considered to be successful even if it is subsequently rolled back.</source>
          <target state="translated">就此例程而言，即使随后将其回滚，也认为&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;成功。</target>
        </trans-unit>
        <trans-unit id="4c58e719af76025bd3937a17763f87efc5e13c1f" translate="yes" xml:space="preserve">
          <source>For the purposes of this routine, an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; is considered to be successful even if it is subsequently rolled back.</source>
          <target state="translated">就此例程而言，即使随后将其回滚，也认为&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;成功。</target>
        </trans-unit>
        <trans-unit id="105a62f9f913b7c3c03726a4a42a2b6ed86624fa" translate="yes" xml:space="preserve">
          <source>For the purposes of unique indices, all NULL values are considered different from all other NULL values and are thus unique. This is one of the two possible interpretations of the SQL-92 standard (the language in the standard is ambiguous). The interpretation used by SQLite is the same and is the interpretation followed by PostgreSQL, MySQL, Firebird, and Oracle. Informix and Microsoft SQL Server follow the other interpretation of the standard, which is that all NULL values are equal to one another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="713e891998daa01c37d2616d81cfb2bf2962ac1e" translate="yes" xml:space="preserve">
          <source>For the right-hand table of a LEFT JOIN, compute the values of expressions directly rather than loading precomputed values out of an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt; as the expression index might not contain the correct value. Ticket &lt;a href=&quot;https://sqlite.org/src/info/7fa8049685b50b5aeb0c2&quot;&gt;7fa8049685b50b5aeb0c2&lt;/a&gt;</source>
          <target state="translated">对于LEFT JOIN的右侧表，直接计算表达式的值，而不是从&lt;a href=&quot;expridx&quot;&gt;表达式索引中&lt;/a&gt;加载预先计算的值，因为表达式索引可能不包含正确的值。机票&lt;a href=&quot;https://sqlite.org/src/info/7fa8049685b50b5aeb0c2&quot;&gt;7fa8049685b50b5aeb0c2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5c9ca201b99a3489f4b36f53a1d0536e05b123a3" translate="yes" xml:space="preserve">
          <source>For the second case, when the table already exists, every row of the CSV file, including the first row, is assumed to be actual content. If the CSV file contains an initial row of column labels, that row will be read as data and inserted into the table. To avoid this, make sure that table does not previously exist.</source>
          <target state="translated">对于第二种情况,当表已经存在时,CSV文件的每一行,包括第一行,都被假定为实际内容。如果CSV文件中包含列标签的初始行,该行将被作为数据读取并插入到表中。为了避免这种情况,请确保该表之前不存在。</target>
        </trans-unit>
        <trans-unit id="7bf6df3d98c9980bb0d46166ad84f0bd8834c9ba" translate="yes" xml:space="preserve">
          <source>For the second case, when the table already exists, every row of the CSV file, including the first row, is assumed to be actual content. If the CSV file contains an initial row of column labels, you can cause the .import command to skip that initial row using the &quot;--skip 1&quot; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d66c18babb7715bc31a6fed2788e6b8d32bfce2" translate="yes" xml:space="preserve">
          <source>For the sqlite3_result_text16(), sqlite3_result_text16le(), and sqlite3_result_text16be() routines, and for sqlite3_result_text64() when the encoding is not UTF8, if the input UTF16 begins with a byte-order mark (BOM, U+FEFF) then the BOM is removed from the string and the rest of the string is interpreted according to the byte-order specified by the BOM. The byte-order specified by the BOM at the beginning of the text overrides the byte-order specified by the interface procedure. So, for example, if sqlite3_result_text16le() is invoked with text that begins with bytes 0xfe, 0xff (a big-endian byte-order mark) then the first two bytes of input are skipped and the remaining input is interpreted as UTF16BE text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="814f69ac0546d66f0db75207e5064bf283a12829" translate="yes" xml:space="preserve">
          <source>For these reasons, many complex queries may use less memory and run faster using FTS5.</source>
          <target state="translated">由于这些原因,许多复杂的查询可能使用较少的内存,并使用FTS5运行得更快。</target>
        </trans-unit>
        <trans-unit id="7fe943bac7177b3cc26bc016acdb488812414486" translate="yes" xml:space="preserve">
          <source>For these substitutions, the precision is the number of bytes or characters taken from the argument, not the number of bytes or characters that are written into the output.</source>
          <target state="translated">对于这些替换,精度是指从参数中抽取的字节或字符数,而不是写入输出的字节或字符数。</target>
        </trans-unit>
        <trans-unit id="ddecb7fc6ac9ebf678a969f318e2c93050dc15ef" translate="yes" xml:space="preserve">
          <source>For this first experiment, nothing else about the file format is changed. The OpenDocument is still a pile-of-files, only now each file is a row in an SQLite database rather than an entry in a ZIP archive. This simple change does not use the power of a relational database. Even so, this simple change shows some improvements.</source>
          <target state="translated">在第一次实验中,文件格式没有任何其他变化。OpenDocument仍然是一堆文件,只是现在每个文件都是SQLite数据库中的一行,而不是ZIP存档中的一个条目。这个简单的变化并没有使用关系数据库的力量。即便如此,这个简单的变化还是显示出了一些改进。</target>
        </trans-unit>
        <trans-unit id="fbfd34ac3082b66cb73eae2395605bfffd9afee2" translate="yes" xml:space="preserve">
          <source>For this form, the &amp;lt;expr&amp;gt; does not have to be an integer. It can evaluate to a real number as long as it is constant and non-negative.</source>
          <target state="translated">对于这种形式，&amp;lt;expr&amp;gt;不必为整数。只要它是常数且为非负数，它就可以计算为实数。</target>
        </trans-unit>
        <trans-unit id="752d2cd19688f392b69d1efc9ea4707b6423ad4e" translate="yes" xml:space="preserve">
          <source>For this particular UPDATE test, MySQL is consistently five or ten times slower than PostgreSQL and SQLite. I do not know why. MySQL is normally a very fast engine. Perhaps this problem has been addressed in later versions of MySQL.</source>
          <target state="translated">在这个特殊的UPDATE测试中,MySQL的速度始终比PostgreSQL和SQLite慢五到十倍。我不知道为什么。MySQL通常是一个非常快的引擎。也许这个问题在MySQL的以后版本中已经解决了。</target>
        </trans-unit>
        <trans-unit id="9db0e6302461b7556c4838a4a6492fc335414fcc" translate="yes" xml:space="preserve">
          <source>For usage hints and a summary of all options, simply give the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; the -A option with no additional arguments:</source>
          <target state="translated">有关用法提示和所有选项的摘要，只需为&lt;a href=&quot;cli&quot;&gt;CLI提供&lt;/a&gt; -A选项即可，不带其他参数：</target>
        </trans-unit>
        <trans-unit id="c9239816897eb996f78a6efe04536d4eaf0b8d55" translate="yes" xml:space="preserve">
          <source>Force the value in register P1 to be an integer. If the value in P1 is not an integer and cannot be converted into an integer without data loss, then jump immediately to P2, or if P2==0 raise an SQLITE_MISMATCH exception.</source>
          <target state="translated">强制寄存器P1中的值是一个整数。如果P1中的值不是整数,并且不能在不丢失数据的情况下转换为整数,则立即跳转到P2,或者如果P2==0,则引发一个SQLITE_MISMATCH异常。</target>
        </trans-unit>
        <trans-unit id="e1652af1b46a8724b09c6398e58d043cf684e88e" translate="yes" xml:space="preserve">
          <source>Force the value in register P1 to be the type defined by P2.</source>
          <target state="translated">强制寄存器P1中的值为P2定义的类型。</target>
        </trans-unit>
        <trans-unit id="c3788028d350f50070224e2ffa767d1574a8ab2d" translate="yes" xml:space="preserve">
          <source>Foreign Key Constraints</source>
          <target state="translated">外键约束</target>
        </trans-unit>
        <trans-unit id="8ea9876246ba7c653355a0ce27076bc76b4c8469" translate="yes" xml:space="preserve">
          <source>Foreign key ON DELETE and ON UPDATE clauses are used to configure actions that take place when deleting rows from the parent table (ON DELETE), or modifying the parent key values of existing rows (ON UPDATE). A single foreign key constraint may have different actions configured for ON DELETE and ON UPDATE. Foreign key actions are similar to triggers in many ways.</source>
          <target state="translated">外键ON DELETE和ON UPDATE子句用于配置从父表中删除行(ON DELETE)或修改现有行的父键值(ON UPDATE)时发生的操作。一个外键约束可以为ON DELETE和ON UPDATE配置不同的操作。外键操作在很多方面与触发器类似。</target>
        </trans-unit>
        <trans-unit id="474365badbb1f3b57e5eb366037b4f712db8f5d1" translate="yes" xml:space="preserve">
          <source>Foreign key actions</source>
          <target state="translated">国外关键行动</target>
        </trans-unit>
        <trans-unit id="d3465e4f63b19b36c358f39673e35fd218b96287" translate="yes" xml:space="preserve">
          <source>Foreign key constraints are disabled by default (for backwards compatibility), so must be enabled separately for each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. (Note, however, that future releases of SQLite might change so that foreign key constraints enabled by default. Careful developers will not make any assumptions about whether or not foreign keys are enabled by default but will instead enable or disable them as necessary.) The application can also use a &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; statement to determine if foreign keys are currently enabled. The following command-line session demonstrates this:</source>
          <target state="translated">默认情况下，外键约束是禁用的（为了向后兼容），因此必须分别为每个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;启用外键约束。（但是请注意，SQLite的未来版本可能会更改，从而默认情况下会启用外键约束。谨慎的开发人员不会对默认情况下是否启用外键做出任何假设，而是根据需要启用或禁用它们。）应用程序还可以使用&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt;语句来确定当前是否启用了外键。以下命令行会话对此进行了演示：</target>
        </trans-unit>
        <trans-unit id="fadb49ecb31870fa195b79a63507d69332246c87" translate="yes" xml:space="preserve">
          <source>Foreign key constraints are enabled</source>
          <target state="translated">启用外键约束</target>
        </trans-unit>
        <trans-unit id="ce28942b103c42389428127f519c6795e562c011" translate="yes" xml:space="preserve">
          <source>Format 1 is understood by all versions of SQLite back to &lt;a href=&quot;https://sqlite.org/releaselog/3_0_0.html&quot;&gt;version 3.0.0&lt;/a&gt; (2004-06-18).</source>
          <target state="translated">回到&lt;a href=&quot;https://sqlite.org/releaselog/3_0_0.html&quot;&gt;版本3.0.0&lt;/a&gt;（2004-06-18），SQLite的所有版本都可以理解格式1 。</target>
        </trans-unit>
        <trans-unit id="bb846b850c6fa3ff33f8d13f455d688d28aa22d8" translate="yes" xml:space="preserve">
          <source>Format 2 adds the ability of rows within the same table to have a varying number of columns, in order to support the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; functionality. Support for reading and writing format 2 was added in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_1_3.html&quot;&gt;version 3.1.3&lt;/a&gt; on 2005-02-20.</source>
          <target state="translated">格式2增加了同一表中的行具有可变数量的列的能力，以支持&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt;功能。在2005-02-20的SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_1_3.html&quot;&gt;版本3.1.3中&lt;/a&gt;添加了对读写格式2的支持。</target>
        </trans-unit>
        <trans-unit id="e74a0202e30c00da07d8e3f647ad619d797750ee" translate="yes" xml:space="preserve">
          <source>Format 3 adds the ability of extra columns added by &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; to have non-NULL default values. This capability was added in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_1_4.html&quot;&gt;version 3.1.4&lt;/a&gt; on 2005-03-11.</source>
          <target state="translated">格式3增加了&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt;添加的额外列以具有非NULL默认值的功能。此功能已在2005-03-11的SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_1_4.html&quot;&gt;版本3.1.4中&lt;/a&gt;添加。</target>
        </trans-unit>
        <trans-unit id="6f87214a5c89d4a264dcabc8b3ff76d0ecb7e6ab" translate="yes" xml:space="preserve">
          <source>Format 4 causes SQLite to respect the &lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC keyword&lt;/a&gt; on index declarations. (The DESC keyword is ignored in indexes for formats 1, 2, and 3.) Format 4 also adds two new boolean record type values (&lt;a href=&quot;fileformat2#serialtype&quot;&gt;serial types&lt;/a&gt; 8 and 9). Support for format 4 was added in SQLite 3.3.0 on 2006-01-10.</source>
          <target state="translated">格式4导致SQLite 在索引声明中遵守&lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC关键字&lt;/a&gt;。（格式1、2和3的索引中忽略了DESC关键字。）格式4还添加了两个新的布尔记录类型值（&lt;a href=&quot;fileformat2#serialtype&quot;&gt;串行类型&lt;/a&gt; 8和9）。在2006-01-10的SQLite 3.3.0中添加了对格式4的支持。</target>
        </trans-unit>
        <trans-unit id="d2e4ea8f983e7648b4500b3c2517f1581f43edb0" translate="yes" xml:space="preserve">
          <source>Formats 2 through 10 may be optionally followed by a timezone indicator of the form &quot;</source>
          <target state="translated">格式2至10后面可选择加上&quot;&quot;的时区指示符。</target>
        </trans-unit>
        <trans-unit id="ff2a0eb4d03de61d70053787eab6804fcec445da" translate="yes" xml:space="preserve">
          <source>Formatted String Printing Functions</source>
          <target state="translated">格式化字符串打印功能</target>
        </trans-unit>
        <trans-unit id="73cdbab7825af4beabbe4e8fccce8b346886e89f" translate="yes" xml:space="preserve">
          <source>Fossil gives me peace of mind that I have everything ... synced to the server with a single command.... I never get this peace of mind with git.</source>
          <target state="translated">Fossil让我安心,因为我有所有的东西......只需一个命令就能同步到服务器上......。我从来没有在git上得到这样的安心。</target>
        </trans-unit>
        <trans-unit id="968f45bf8ccf7ca67b780b2bdd22df3354350003" translate="yes" xml:space="preserve">
          <source>Fossil is a completely stand-alone program, so install it simply by putting the &quot;fossil&quot; or &quot;fossil.exe&quot; executable someplace on your $PATH or %PATH%. After you have Fossil installed, do this:</source>
          <target state="translated">Fossil是一个完全独立的程序,所以只要把 &quot;fossil &quot;或 &quot;fossil.exe &quot;可执行文件放在$PATH或%PATH%的某个地方就可以安装了。当你安装好Fossil后,请这样做。</target>
        </trans-unit>
        <trans-unit id="94257cd970f113fc11ecc5cc6011f7bfff67e319" translate="yes" xml:space="preserve">
          <source>Fossil is easy to install and use. Here are the steps for unix. (Windows is similar.)</source>
          <target state="translated">Fossil很容易安装和使用。以下是unix的安装步骤。(Windows也是类似的。)</target>
        </trans-unit>
        <trans-unit id="233904fc6b6c8ee70d33af66e4cb04bfc0af5c1f" translate="yes" xml:space="preserve">
          <source>Fossil vs. Git</source>
          <target state="translated">Fossil vs.Git</target>
        </trans-unit>
        <trans-unit id="bbba84135de6b052c2210e74e0cc5b2a9d359ddb" translate="yes" xml:space="preserve">
          <source>Found</source>
          <target state="translated">Found</target>
        </trans-unit>
        <trans-unit id="71c33b1cffd26b04e4533bd5c542bd8028125150" translate="yes" xml:space="preserve">
          <source>Four independently developed test harnesses</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9521a3d73988a064707ebf1e7a52b3d8155b49c" translate="yes" xml:space="preserve">
          <source>Frame boundary</source>
          <target state="translated">框架边界</target>
        </trans-unit>
        <trans-unit id="77433082b8e51b0f02140d5bb2ad80c6960db0b1" translate="yes" xml:space="preserve">
          <source>Frame type</source>
          <target state="translated">框架类型</target>
        </trans-unit>
        <trans-unit id="6e84d556b35797f261b67f9c140d77ba6a16046e" translate="yes" xml:space="preserve">
          <source>Free Memory Used By A Database Connection</source>
          <target state="translated">数据库连接使用的自由内存</target>
        </trans-unit>
        <trans-unit id="c3f00513ee103316a9c102f8d540f97f3d93a05d" translate="yes" xml:space="preserve">
          <source>Freelist leaf pages contain no information. SQLite avoids reading or writing freelist leaf pages in order to reduce disk I/O.</source>
          <target state="translated">自由列表叶页不包含任何信息。SQLite为了减少磁盘I/O,避免读取或写入自由列表叶页。</target>
        </trans-unit>
        <trans-unit id="71c292b702c9c6ddbea2af4ccdda270456dc5dd4" translate="yes" xml:space="preserve">
          <source>Frequent inserts, updates, and deletes can cause the database file to become fragmented - where data for a single table or index is scattered around the database file. Running VACUUM ensures that each table and index is largely stored contiguously within the database file. In some cases, VACUUM may also reduce the number of partially filled pages in the database, reducing the size of the database file further.</source>
          <target state="translated">频繁的插入、更新和删除可能会导致数据库文件变得支离破碎--单个表或索引的数据分散在数据库文件中。运行VACUUM可以确保每张表和索引在很大程度上连续地存储在数据库文件中。在某些情况下,VACUUM还可以减少数据库中部分填充页的数量,进一步减少数据库文件的大小。</target>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="translated">常问问题</target>
        </trans-unit>
        <trans-unit id="4dca8789d725335eabc320e5fd334c48abe46050" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;, extensions can be loaded using the &quot;.load&quot; dot-command. For example:</source>
          <target state="translated">从&lt;a href=&quot;cli&quot;&gt;命令行壳&lt;/a&gt;，扩展可以使用&amp;ldquo;.load&amp;rdquo;点命令被装载。例如：</target>
        </trans-unit>
        <trans-unit id="9622d74f0a066cde3991b933210f9d9f6547b468" translate="yes" xml:space="preserve">
          <source>From the point of view of a single process, a database file can be in one of five locking states:</source>
          <target state="translated">从单个进程的角度来看,一个数据库文件可以处于五种锁定状态之一。</target>
        </trans-unit>
        <trans-unit id="f2bf6ce9c451768f240ac82fe10e69d266839161" translate="yes" xml:space="preserve">
          <source>From the point of view of the uppers layers of the SQLite stack, each open database file uses exactly one VFS. But in practice, a particular VFS might just be a thin wrapper around another VFS that does the real work. We call a wrapper VFS a &quot;shim&quot;.</source>
          <target state="translated">从SQLite堆栈上层的角度来看,每个打开的数据库文件正好使用一个VFS。但在实践中,一个特定的VFS可能只是另一个做真正工作的VFS的薄包装。我们把一个包装器VFS称为 &quot;shim&quot;。</target>
        </trans-unit>
        <trans-unit id="b51b364d89abfa3baa92bcc31eb6e45de7419ef6" translate="yes" xml:space="preserve">
          <source>From the users point of view, FTS tables are similar to ordinary SQLite tables in many ways. Data may be added to, modified within and removed from FTS tables using the INSERT, UPDATE and DELETE commands just as it may be with ordinary tables. Similarly, the SELECT command may be used to query data. The following list summarizes the differences between FTS and ordinary tables:</source>
          <target state="translated">从用户的角度来看,FTS表在很多方面与普通的SQLite表相似。可以使用INSERT、UPDATE和DELETE命令在FTS表中添加、修改和删除数据,就像在普通表中一样。同样,SELECT命令也可以用来查询数据。下面的列表总结了FTS表和普通表之间的区别。</target>
        </trans-unit>
        <trans-unit id="27c4a8e9b8642a933f67723d0e4be1b9a0f44d80" translate="yes" xml:space="preserve">
          <source>From this we get the following output</source>
          <target state="translated">由此,我们得到以下输出</target>
        </trans-unit>
        <trans-unit id="2180268f2a9a9fda782b57bf8e01a18a029a7a96" translate="yes" xml:space="preserve">
          <source>Fulfill God's commandments daily in your deeds.</source>
          <target state="translated">在你的行为中每天履行上帝的诫命。</target>
        </trans-unit>
        <trans-unit id="b471a096b84cc0494684e033a051e31af5d4baaa" translate="yes" xml:space="preserve">
          <source>Fulfill not the desires of the flesh; hate your own will.</source>
          <target state="translated">不要满足肉体的欲望,恨自己的意志。</target>
        </trans-unit>
        <trans-unit id="c55154da9bee9185f44dff21df8abc2c3aabdcae" translate="yes" xml:space="preserve">
          <source>Full unicode case folding is supported in SQLite if it is compiled with the &lt;a href=&quot;compile#enable_icu&quot;&gt;-DSQLITE_ENABLE_ICU&lt;/a&gt; option and linked against the &lt;a href=&quot;http://site.icu-project.org/&quot;&gt;International Components for Unicode&lt;/a&gt; library.</source>
          <target state="translated">如果使用&lt;a href=&quot;compile#enable_icu&quot;&gt;-DSQLITE_ENABLE_ICU&lt;/a&gt;选项编译并与&lt;a href=&quot;http://site.icu-project.org/&quot;&gt;Unicode国际组件&lt;/a&gt;库链接，则SQLite支持完全Unicode大小写折叠。</target>
        </trans-unit>
        <trans-unit id="90b0c8025a15a6f38263adcf72861e6ab67a9305" translate="yes" xml:space="preserve">
          <source>Full-Featured SQL</source>
          <target state="translated">全功能的SQL</target>
        </trans-unit>
        <trans-unit id="9e0f1c37b71547a59fac0e69533c4df840ff38fe" translate="yes" xml:space="preserve">
          <source>Full-Text Search</source>
          <target state="translated">全文检索</target>
        </trans-unit>
        <trans-unit id="369603a7ebe96771eca2b1d07435e9996bd963f3" translate="yes" xml:space="preserve">
          <source>Full-text search</source>
          <target state="translated">全文检索</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="9365da4d7427ae049cd7228599ffdbf56ca765df" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt; is called to clean up resources allocated by &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt;.</source>
          <target state="translated">调用函数&lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish（）&lt;/a&gt;清理由&lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init（）&lt;/a&gt;分配的资源。</target>
        </trans-unit>
        <trans-unit id="6ee739a58d0601e439d67d32ce677eb6f284f6f0" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; is called to create an &lt;a href=&quot;c3ref/backup&quot;&gt;sqlite3_backup&lt;/a&gt; object to copy data between the two databases (either from a file and into the in-memory database, or vice-versa).</source>
          <target state="translated">调用函数&lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init（）&lt;/a&gt;创建一个&lt;a href=&quot;c3ref/backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象，以在两个数据库之间复制数据（从文件复制到内存数据库，反之亦然）。</target>
        </trans-unit>
        <trans-unit id="3518bc62cbd77290edb8df852902f3d26b669db7" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; is called to create an &lt;a href=&quot;c3ref/backup&quot;&gt;sqlite3_backup&lt;/a&gt; object to copy data from database pDb to the backup database file identified by zFilename.</source>
          <target state="translated">调用函数&lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init（）&lt;/a&gt;创建一个&lt;a href=&quot;c3ref/backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象，以将数据从数据库pDb复制到zFilename标识的备份数据库文件。</target>
        </trans-unit>
        <trans-unit id="391bd2c3bef8e5815ac8dc9e143dc5e9f29edc4b" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; is called with a parameter of 5 to copy 5 pages of database pDb to the backup database (file zFilename).</source>
          <target state="translated">使用参数5调用函数&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（）&lt;/a&gt;可以将数据库pDb的5页复制到备份数据库（文件zFilename）。</target>
        </trans-unit>
        <trans-unit id="38d0016fe914d4211802e56c1b039ba739bf3a21" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; is called with a parameter of &lt;code&gt;-1&lt;/code&gt; to copy the entire source database to the destination.</source>
          <target state="translated">使用参数 &lt;code&gt;-1&lt;/code&gt; 调用函数&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（）&lt;/a&gt;可以将整个源数据库复制到目标。</target>
        </trans-unit>
        <trans-unit id="a019467e942226e7593baeafe04451d52208ddbd" translate="yes" xml:space="preserve">
          <source>Function Auxiliary Data</source>
          <target state="translated">功能辅助数据</target>
        </trans-unit>
        <trans-unit id="95b0294dd891e754097881615649b65fc6ba31c5" translate="yes" xml:space="preserve">
          <source>Function Flags</source>
          <target state="translated">功能标志</target>
        </trans-unit>
        <trans-unit id="17555700d9f22f47c91cbb0e6dcdac3a03a90e07" translate="yes" xml:space="preserve">
          <source>Function implementations use the following APIs to acquire context and to report results:</source>
          <target state="translated">函数实现使用以下API来获取上下文并报告结果。</target>
        </trans-unit>
        <trans-unit id="7db899803172ac5c12cb30190a927b06044d501c" translate="yes" xml:space="preserve">
          <source>Function sqlite3_backup_step(B,N) will copy up to N pages between the source and destination databases specified by &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object B. If N is negative, all remaining source pages are copied. If sqlite3_backup_step(B,N) successfully copies N pages and there are still more pages to be copied, then the function returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;. If sqlite3_backup_step(B,N) successfully finishes copying all pages from source to destination, then it returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. If an error occurs while running sqlite3_backup_step(B,N), then an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned. As well as &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, a call to sqlite3_backup_step() may return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt;, or an &lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt; extended error code.</source>
          <target state="translated">函数sqlite3_backup_step（B，N）将在&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象B 指定的源数据库和目标数据库之间最多复制N个页面。如果N为负，则将复制所有剩余的源页面。如果sqlite3_backup_step（B，N）成功复制了N页，并且还有更多页面要复制，则该函数返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;。如果sqlite3_backup_step（B，N）成功完成了将所有页面从源复制到目标的操作，则返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;。如果在运行sqlite3_backup_step（B，N）时发生&lt;a href=&quot;rescode&quot;&gt;错误，&lt;/a&gt;则返回错误代码。与&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;和&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE一样&lt;/a&gt;，对sqlite3_backup_step（）的调用也可能返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;扩展错误代码。</target>
        </trans-unit>
        <trans-unit id="9255837a8368562d39b56b025c25a117e386acd6" translate="yes" xml:space="preserve">
          <source>Function sqlite3_backup_step(B,N) will copy up to N pages between the source and destination databases specified by &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object B. If N is negative, all remaining source pages are copied. If sqlite3_backup_step(B,N) successfully copies N pages and there are still more pages to be copied, then the function returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;. If sqlite3_backup_step(B,N) successfully finishes copying all pages from source to destination, then it returns &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. If an error occurs while running sqlite3_backup_step(B,N), then an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned. As well as &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; and &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, a call to sqlite3_backup_step() may return &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;, &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;, or an &lt;a href=&quot;../rescode#ioerr_access&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt; extended error code.</source>
          <target state="translated">函数sqlite3_backup_step（B，N）将在&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象B 指定的源数据库和目标数据库之间最多复制N个页面。如果N为负，则将复制所有剩余的源页面。如果sqlite3_backup_step（B，N）成功复制了N页，并且还有更多页面要复制，则该函数返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。如果sqlite3_backup_step（B，N）成功完成了将所有页面从源复制到目标的操作，则返回&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;。如果在运行sqlite3_backup_step（B，N）时发生&lt;a href=&quot;../rescode&quot;&gt;错误，&lt;/a&gt;则返回错误代码。与&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;和&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE一样&lt;/a&gt;，对sqlite3_backup_step（）的调用也可能返回&lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;，&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;，&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;，&lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;或&lt;a href=&quot;../rescode#ioerr_access&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;扩展错误代码。</target>
        </trans-unit>
        <trans-unit id="02506e4ca51a17167d74a2f8b901e6d46a621915" translate="yes" xml:space="preserve">
          <source>Function sqlite3rbu_step() is called on the RBU handle until either the RBU vacuum is finished, an error occurs or the application wishes to suspend the RBU vacuum.</source>
          <target state="translated">函数 sqlite3rbu_step()在 RBU 句柄上被调用,直到 RBU 真空结束、发生错误或应用程序希望暂停 RBU 真空。</target>
        </trans-unit>
        <trans-unit id="c29dbde42f9e09b5fa1fe9e874978bd60461ca23" translate="yes" xml:space="preserve">
          <source>Function0</source>
          <target state="translated">Function0</target>
        </trans-unit>
        <trans-unit id="885fce7082ac7fe77b80dbde8d190b12ddbee6ea" translate="yes" xml:space="preserve">
          <source>Functionality Testing</source>
          <target state="translated">功能测试</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="5a1198fbca49df3b9353761343f6ab00ba7526e3" translate="yes" xml:space="preserve">
          <source>Functions:</source>
          <target state="translated">Functions:</target>
        </trans-unit>
        <trans-unit id="1ddc4309220e5ca80653bda487622cf643ea376d" translate="yes" xml:space="preserve">
          <source>Fundamental Datatypes</source>
          <target state="translated">基本数据类型</target>
        </trans-unit>
        <trans-unit id="f728c83ebd508ddfa64fa9b670d3c24c116a1c08" translate="yes" xml:space="preserve">
          <source>Further performance improves can be made by using the &lt;a href=&quot;mmap&quot;&gt;memory-mapped I/O&lt;/a&gt; feature of SQLite. In the next chart, the entire 1GB database file is memory mapped and blobs are read (in random order) using the &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; interface. With these optimizations, SQLite is twice as fast as Android or MacOS-X and over 10 times faster than Windows.</source>
          <target state="translated">通过使用SQLite 的&lt;a href=&quot;mmap&quot;&gt;内存映射I / O&lt;/a&gt;功能，可以进一步提高性能。在下一张图表中，整个1GB数据库文件都进行了内存映射，并使用&lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;接口读取了blob（以随机顺序）。通过这些优化，SQLite的速度是Android或MacOS-X的两倍，是Windows的十倍以上。</target>
        </trans-unit>
        <trans-unit id="215d209e37d2a11fed7e914dfee16f71ee55be90" translate="yes" xml:space="preserve">
          <source>Further suppose that column x contains values spread out between 0 and 1,000,000 and column y contains values that span between 0 and 1,000. In that scenario, the range constraint on column x should reduce the search space by a factor of 10,000 whereas the range constraint on column y should reduce the search space by a factor of only 10. So the ex2i1 index should be preferred.</source>
          <target state="translated">进一步假设x列包含的值分布在0到1,000,000之间,y列包含的值在0到1,000之间。在这种情况下,列x的范围约束应该减少10,000倍的搜索空间,而列y的范围约束应该只减少10倍的搜索空间。所以,应该首选ex2i1索引。</target>
        </trans-unit>
        <trans-unit id="09aabcfb38f7cb10806136de02a602b19c076fd6" translate="yes" xml:space="preserve">
          <source>Further to keeping &lt;b&gt;n&lt;/b&gt; small, one desires to keep the size of the largest memory allocations under control. Large requests to the general-purpose memory allocator might come from several sources:</source>
          <target state="translated">除了使&lt;b&gt;n&lt;/b&gt;较小之外，还希望将最大内存分配的大小保持在可控制的范围内。对通用内存分配器的大请求可能来自以下几个来源：</target>
        </trans-unit>
        <trans-unit id="4a74f247651044b2313a36316a7929616b6d570a" translate="yes" xml:space="preserve">
          <source>Furthermore, a single SQLite database holding 10-kilobyte blobs uses about 20% less disk space than storing the blobs in individual files.</source>
          <target state="translated">此外,与在单个文件中存储blobs相比,单个SQLite数据库持有10-kilobyte blobs所使用的磁盘空间减少了20%。</target>
        </trans-unit>
        <trans-unit id="8bd50359d3a17558a2d398e2f44b82ca134e4e80" translate="yes" xml:space="preserve">
          <source>Future releases may add new output columns and may change the order of legacy columns. Further detail about the meaning of each column in the SQLITE_STMT virtual table is provided below:</source>
          <target state="translated">未来的版本可能会增加新的输出列,也可能会改变传统列的顺序。下面将进一步详细介绍SQLITE_STMT虚拟表中各列的含义。</target>
        </trans-unit>
        <trans-unit id="6831b46470717c86c7d25cb9cedff9f9bee20302" translate="yes" xml:space="preserve">
          <source>Future releases of SQLite might enable those interfaces by default and instead offer an SQLITE_OMIT_DESERIALIZE option to leave them out.</source>
          <target state="translated">SQLite未来的版本可能会默认启用这些接口,而提供一个SQLITE_OMIT_DESERIALIZE选项来不使用它们。</target>
        </trans-unit>
        <trans-unit id="69eed414fd6ede90f6e232a4b640df2129c7213e" translate="yes" xml:space="preserve">
          <source>Future versions of SQLite may extend the list of errors which might cause automatic transaction rollback. Future versions of SQLite might change the error response. In particular, we may choose to simplify the interface in future versions of SQLite by causing the errors above to force an unconditional rollback.</source>
          <target state="translated">SQLite的未来版本可能会扩展可能导致自动事务回滚的错误列表。未来版本的SQLite可能会改变错误响应。特别是,我们可能会选择在未来版本的SQLite中简化接口,使上述错误强制进行无条件回滚。</target>
        </trans-unit>
        <trans-unit id="b0b58ce3a5e420ed148b6052399ca3a065dfe3cb" translate="yes" xml:space="preserve">
          <source>Future versions of SQLite might enable the batch-atomic-write capability by default, at which point this compile-time option will become superfluous.</source>
          <target state="translated">未来的SQLite版本可能会默认启用批处理原子写入功能,这时这个编译时选项将变得多余。</target>
        </trans-unit>
        <trans-unit id="75a65696cc2dd88673f048a8e620acbe3511d286" translate="yes" xml:space="preserve">
          <source>Fuzz testing and &lt;a href=&quot;testing#mcdc&quot;&gt;100% MC/DC testing&lt;/a&gt; are in tension with one another. That is to say, code tested to 100% MC/DC will tend to be more vulnerable to problems found by fuzzing and code that performs well during fuzz testing will tend to have (much) less than 100% MC/DC. This is because MC/DC testing discourages &lt;a href=&quot;testing#defcode&quot;&gt;defensive code&lt;/a&gt; with unreachable branches, but without defensive code, a fuzzer is more likely to find a path that causes problems. MC/DC testing seems to work well for building code that is robust during typical normal use, whereas fuzz testing is good for building code that is robust against malicious attack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aac4860a695a884103c23bef4fe10cea8ac21a0" translate="yes" xml:space="preserve">
          <source>Fuzz tests</source>
          <target state="translated">模糊测试</target>
        </trans-unit>
        <trans-unit id="cbf13864eb622e042fd70afc25b332a98febed1d" translate="yes" xml:space="preserve">
          <source>GCC-7 generates binaries that are smaller and faster than GCC-5, though the difference is not that great.</source>
          <target state="translated">GCC-7生成的二进制文件比GCC-5更小,速度更快,虽然差别不大。</target>
        </trans-unit>
        <trans-unit id="82cb2940a14f458fe56d211dffdcd12595e8b940" translate="yes" xml:space="preserve">
          <source>GENERATED</source>
          <target state="translated">GENERATED</target>
        </trans-unit>
        <trans-unit id="3c1c8852a41864ea17cea1296e10f38e7d36f590" translate="yes" xml:space="preserve">
          <source>GIT - Git source code repository</source>
          <target state="translated">GIT-Git源码库</target>
        </trans-unit>
        <trans-unit id="801660e770a91f34fb13ac91a9b5cbd2d98c6d3a" translate="yes" xml:space="preserve">
          <source>GLOB</source>
          <target state="translated">GLOB</target>
        </trans-unit>
        <trans-unit id="ea5a383494f81c4f464965d03bf916c41d68ced5" translate="yes" xml:space="preserve">
          <source>GROUP</source>
          <target state="translated">GROUP</target>
        </trans-unit>
        <trans-unit id="992f3cd91fffb522eba0b5e27b68c643f2967283" translate="yes" xml:space="preserve">
          <source>GROUP BY now considers NULLs to be equal again, as it should</source>
          <target state="translated">GROUP BY现在认为NULLs又是相等的,因为它应该是</target>
        </trans-unit>
        <trans-unit id="1f8969d436579977f5b13e27e290ffdb25736672" translate="yes" xml:space="preserve">
          <source>GROUPS</source>
          <target state="translated">GROUPS</target>
        </trans-unit>
        <trans-unit id="47abf252888b506642430a87f17ad2e364853ea7" translate="yes" xml:space="preserve">
          <source>GROUPS frames</source>
          <target state="translated">集团框架</target>
        </trans-unit>
        <trans-unit id="5023fde21a93efcc45f3ef1278a03020db274d7f" translate="yes" xml:space="preserve">
          <source>Ge</source>
          <target state="translated">Ge</target>
        </trans-unit>
        <trans-unit id="5f5383c13d2f60a6733afafdeaf91505cfcc253b" translate="yes" xml:space="preserve">
          <source>Generalized ALTER TABLE procedure</source>
          <target state="translated">通用ALTER TABLE程序</target>
        </trans-unit>
        <trans-unit id="200f1a824c74356136271be8f5cec761b8361890" translate="yes" xml:space="preserve">
          <source>Generalized the IS and IS NOT operators to take arbitrary expressions on their right-hand side.</source>
          <target state="translated">归纳了IS和IS NOT运算符,在其右侧取任意表达式。</target>
        </trans-unit>
        <trans-unit id="b3419155244f27d32ab3d7f4be3add6bd08da9d5" translate="yes" xml:space="preserve">
          <source>Generally speaking, there are three separate subsystems within SQLite that can be modified or overridden at compile-time. The mutex subsystem is used to serialize access to SQLite resources that are shared among threads. The memory allocation subsystem is used to allocate memory required by SQLite objects and for the database cache. Finally, the &lt;a href=&quot;c3ref/vfs&quot;&gt;Virtual File System&lt;/a&gt; subsystem is used to provide a portable interface between SQLite and the underlying operating system and especially the file system. We call these three subsystems the &quot;interface&quot; subsystems of SQLite.</source>
          <target state="translated">一般来说，SQLite中有三个独立的子系统，可以在编译时对其进行修改或覆盖。互斥锁子系统用于序列化对线程之间共享的SQLite资源的访问。内存分配子系统用于分配SQLite对象所需的内存以及数据库缓存。最后，&lt;a href=&quot;c3ref/vfs&quot;&gt;虚拟文件系统&lt;/a&gt;子系统用于在SQLite与底层操作系统（尤其是文件系统）之间提供可移植的接口。我们将这三个子系统称为SQLite的&amp;ldquo;接口&amp;rdquo;子系统。</target>
        </trans-unit>
        <trans-unit id="03b11aad395b9bb3b854450c1f0acff0112439bd" translate="yes" xml:space="preserve">
          <source>Generate A Changeset From A Session Object</source>
          <target state="translated">从一个会话对象生成一个变更集</target>
        </trans-unit>
        <trans-unit id="771f6c81129288bd0dca35edc653f4896b8a38b9" translate="yes" xml:space="preserve">
          <source>Generate A Patchset From A Session Object</source>
          <target state="translated">从一个会话对象生成一个补丁集</target>
        </trans-unit>
        <trans-unit id="c543fcc61a656cc087657032229c13b299493cc4" translate="yes" xml:space="preserve">
          <source>Generate all multiples of 5 less than or equal to 100:</source>
          <target state="translated">生成所有小于或等于100的5的倍数。</target>
        </trans-unit>
        <trans-unit id="79e208b13cb09ea92286261229fb60357b5683cd" translate="yes" xml:space="preserve">
          <source>Generate the 20 random integer values:</source>
          <target state="translated">生成20个随机整数值。</target>
        </trans-unit>
        <trans-unit id="46614740c9601066a8714b11664b1eb75a5a0bb4" translate="yes" xml:space="preserve">
          <source>Generating the results of a simple SELECT statement is presented as a four step process in the description below:</source>
          <target state="translated">生成一个简单的SELECT语句的结果在下面的描述中以四个步骤的方式呈现。</target>
        </trans-unit>
        <trans-unit id="0060bdc4470d529ca18bce37edc0d7a0701d9b10" translate="yes" xml:space="preserve">
          <source>Geopoly</source>
          <target state="translated">Geopoly</target>
        </trans-unit>
        <trans-unit id="c4340d254981277ce14859ec23653c0dac4e3963" translate="yes" xml:space="preserve">
          <source>Geopoly operates on &quot;simple&quot; polygons - that is, polygons for which the boundary does not intersect itself. Geopoly thus extends the capabilities of the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; which can only deal with rectangular areas. On the other hand, the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; is able to handle between 1 and 5 coordinate dimensions, whereas Geopoly is restricted to 2-dimensional shapes only.</source>
          <target state="translated">Geopoly在&amp;ldquo;简单&amp;rdquo;多边形上运行-即，其边界自身不相交的多边形。因此，Geopoly扩展了&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展&lt;/a&gt;的功能，该功能仅可处理矩形区域。另一方面，&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展&lt;/a&gt;能够处理1到5个坐标维度，而Geopoly仅限于二维形状。</target>
        </trans-unit>
        <trans-unit id="6dd9a0429b5e12a110f96aed0989c67466586ea1" translate="yes" xml:space="preserve">
          <source>Geopoly stores all polygons internally using a binary format. A binary polygon consists of a 4-byte header following by an array of coordinate pairs in which each dimension of each coordinate is a 32-bit floating point number.</source>
          <target state="translated">Geopoly 内部使用二进制格式存储所有多边形。一个二进制多边形由一个 4 字节的头和一个坐标对数组组成,每个坐标的每个维度都是一个 32 位浮点数。</target>
        </trans-unit>
        <trans-unit id="230fd79e9ac234b116998f305ec36a626773a0c1" translate="yes" xml:space="preserve">
          <source>Get a copy of the prebuilt binaries for your machine, or get a copy of the sources and compile them yourself. Visit the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download&lt;/a&gt; page for more information.</source>
          <target state="translated">获取适用于您计算机的预编译二进制文件的副本，或者获取源代码的副本并自己进行编译。访问&lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;下载&lt;/a&gt;页面以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="f22b4172b2caeb752e5b6845137b0e1c3132162f" translate="yes" xml:space="preserve">
          <source>Get a new integer record number (a.k.a &quot;rowid&quot;) used as the key to a table. The record number is not previously used as a key in the database table that cursor P1 points to. The new record number is written written to register P2.</source>
          <target state="translated">获取一个新的整数记录号(又名 &quot;rowid&quot;)作为表的键。在游标P1所指向的数据库表中,这个记录号之前没有被用作键。新的记录号将被写入寄存器P2中。</target>
        </trans-unit>
        <trans-unit id="2c8ad3eda2ae8758b9937a69c2cdf3d37bc6a82b" translate="yes" xml:space="preserve">
          <source>Get extension loading working on Cygwin.</source>
          <target state="translated">在Cygwin上实现扩展加载工作。</target>
        </trans-unit>
        <trans-unit id="70d300a9221d054ecf73f3a432c241cce5538fb1" translate="yes" xml:space="preserve">
          <source>Get the SQLITE_ENABLE_LOCKING_STYLE macro working again on Mac OS X.</source>
          <target state="translated">让SQLITE_ENABLE_LOCKING_STYLE宏在Mac OS X上重新工作。</target>
        </trans-unit>
        <trans-unit id="191ab3ffcff8c3d125f02fa19cf1b4772a774563" translate="yes" xml:space="preserve">
          <source>Get the library working correctly when compiled with GCC option &quot;-fstrict-aliasing&quot;.</source>
          <target state="translated">当使用GCC选项&quot;-fstrict-aliasing &quot;编译时,获得库的正确工作。</target>
        </trans-unit>
        <trans-unit id="e33fe52a421a08f566920837d8eaa9b7577c26cc" translate="yes" xml:space="preserve">
          <source>Git allows you to go backwards in time easily. Given the latest check-in on a branch, Git lets you see all the ancestors of that check-in. But Git makes it difficult to move in the other direction. Given some historical check-in, it is quite challenging in Git to find out what came next. It can be done, but it is sufficiently difficult that people rarely do it. Common interfaces for Git, such as GitHub, do not support the ability.</source>
          <target state="translated">Git可以让你轻松地进行时间上的追溯。给定一个分支上最新的签入,Git可以让你看到该签入的所有祖先。但Git让你很难向另一个方向移动。给定一些历史签入,在Git中找出下一个签入是相当有挑战性的。它可以做到,但难度很大,人们很少这样做。Git的常见接口,如GitHub,不支持这种能力。</target>
        </trans-unit>
        <trans-unit id="b6fbc2ab6d8b00135f72a297ae81133b9c538d92" translate="yes" xml:space="preserve">
          <source>Git commands (and/or options on commands) for moving and comparing content between all of these locations.</source>
          <target state="translated">Git 命令(和/或命令的选项)用于在所有这些位置之间移动和比较内容。</target>
        </trans-unit>
        <trans-unit id="913e20aa0e82cacccbed30743753b5fea41f9dd9" translate="yes" xml:space="preserve">
          <source>Git is complex software. One needs an installer of some kind to put Git on a developer workstation, or to upgrade to a newer version of Git. Setting up a Git server is non-trivial, and so most users have to use a third-party service such as GitHub or GitLab, and thus introduce additional (unnecessary) dependencies into the project.</source>
          <target state="translated">Git是一个复杂的软件。人们需要某种安装程序来将Git放在开发者工作站上,或者升级到Git的较新版本。设置一个Git服务器并不容易,因此大多数用户不得不使用第三方服务,如GitHub或GitLab,从而为项目引入额外的(不必要的)依赖。</target>
        </trans-unit>
        <trans-unit id="ee613d9b4f6dfc0f80be0bd2cfff2ea77808bbb6" translate="yes" xml:space="preserve">
          <source>Git keeps the complete DAG of the check-in sequence. But branch tags are local information that is not synced and not retained once a branch closes. This makes review of historical branches tedious.</source>
          <target state="translated">Git会保留完整的签入序列DAG。但是分支标签是本地信息,一旦分支关闭就不会同步,也不会保留。这样一来,对历史分支的复查就显得十分繁琐。</target>
        </trans-unit>
        <trans-unit id="48b3160f0b763f1616179debce43562e664f02d9" translate="yes" xml:space="preserve">
          <source>GitHub and GitLab offer nothing comparable. The closest I have found is the &lt;a href=&quot;https://github.com/sqlite/sqlite/network&quot;&gt;network&lt;/a&gt;, which is slow to render (unless it is already cached), does not offer nearly as much details, and scarcely works on mobile. The &lt;a href=&quot;https://github.com/sqlite/sqlite/commits/master&quot;&gt;commits&lt;/a&gt; view of GitHub provides more detail, renders quickly, and works on mobile, but only shows a single branch at a time, so I cannot easily know if I've seen all of the recent changes. And even if GitHub/GitLab did offer better interfaces, both are third-party services. They are not a core part of Git. Hence, using them introduces yet another dependency into the project.</source>
          <target state="translated">GitHub和GitLab没有提供可比的东西。我发现的最接近的&lt;a href=&quot;https://github.com/sqlite/sqlite/network&quot;&gt;网络&lt;/a&gt;是渲染速度慢的网络（除非已被缓存），没有提供几乎一样多的细节，并且几乎无法在移动设备上工作。GitHub 的&lt;a href=&quot;https://github.com/sqlite/sqlite/commits/master&quot;&gt;commits&lt;/a&gt;视图提供了更多细节，快速呈现并可以在移动设备上运行，但是一次只显示一个分支，所以我不容易知道我是否看到了所有最近的更改。即使GitHub / GitLab确实提供了更好的界面，但它们都是第三方服务。它们不是Git的核心部分。因此，使用它们会在项目中引入另一个依赖性。</target>
        </trans-unit>
        <trans-unit id="ba7606fea498a9e876c11c77be2a94dc96cb33f9" translate="yes" xml:space="preserve">
          <source>Given a page number P and a maximum WAL frame index M, return the largest WAL frame index for page P that does not exceed M, or return NULL if there are no frames for page P that do not exceed M.</source>
          <target state="translated">给定页码P和最大WAL帧索引M,返回P页不超过M的最大WAL帧索引,如果P页没有不超过M的帧,则返回NULL。</target>
        </trans-unit>
        <trans-unit id="d4a9375f517c74831802a20b14cf1be5743c9399" translate="yes" xml:space="preserve">
          <source>Given a single SQL statement, there might be dozens, hundreds, or even thousands of ways to implement that statement, depending on the complexity of the statement itself and of the underlying database schema. The task of the query planner is to select an algorithm from among the many choices that provides the answer with a minimum of disk I/O and CPU overhead.</source>
          <target state="translated">给定一条SQL语句,根据语句本身和底层数据库模式的复杂程度,可能有几十种、几百种甚至上千种方法来实现该语句。查询规划器的任务是在众多选择中选择一种算法,以最少的磁盘I/O和CPU开销提供答案。</target>
        </trans-unit>
        <trans-unit id="f6bcca46f0f74a9ae01ce42d9f7404d2419d51ad" translate="yes" xml:space="preserve">
          <source>Given all of the information above, the job of the xBestIndex method it to figure out the best way to search the virtual table.</source>
          <target state="translated">鉴于以上所有信息,xBestIndex方法的工作是找出搜索虚拟表的最佳方式。</target>
        </trans-unit>
        <trans-unit id="3214b13dd0b542c059230864a7a5bcd2b12ab804" translate="yes" xml:space="preserve">
          <source>Given an input string X, this routine attempts to determine the dominant script of that input and returns the ISO-15924 numeric code for that script. The current implementation understands the following scripts:</source>
          <target state="translated">给定一个输入字符串X,这个例程试图确定该输入的主导脚本,并返回该脚本的ISO-15924数字代码。当前的实现可以理解以下脚本。</target>
        </trans-unit>
        <trans-unit id="c57b59e0dd1b427eb5c7b60fabfb8b9d76033a70" translate="yes" xml:space="preserve">
          <source>Given the definition of X1 above, the following expressions have historically evaluated to FALSE in SQLite, though the correct answer is actually NULL:</source>
          <target state="translated">考虑到上面X1的定义,下面的表达式在SQLite中历来被评价为FALSE,尽管正确答案实际上是NULL。</target>
        </trans-unit>
        <trans-unit id="bd2ada8cc33bdc4785b371a48d725c0e9ca58446" translate="yes" xml:space="preserve">
          <source>Given the new multi-column Idx3 index, it is now possible for SQLite to find the price of California oranges using only 2 binary searches:</source>
          <target state="translated">鉴于新的多列Idx3索引,现在SQLite只需使用2个二进制搜索就可以找到加州橙子的价格。</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="617490ec40d56766edf8aff111990bee9834d1c1" translate="yes" xml:space="preserve">
          <source>Gosub</source>
          <target state="translated">Gosub</target>
        </trans-unit>
        <trans-unit id="0a9ffc4a328e6d21b11f3b8312d08e5b413aec49" translate="yes" xml:space="preserve">
          <source>Goto</source>
          <target state="translated">Goto</target>
        </trans-unit>
        <trans-unit id="1dee13ac09a18c736a85fb7212501ca3f0535655" translate="yes" xml:space="preserve">
          <source>Gt</source>
          <target state="translated">Gt</target>
        </trans-unit>
        <trans-unit id="60f4e65b35154fc853b0c67ac464ba87691c1af9" translate="yes" xml:space="preserve">
          <source>Guard your tongue against evil and depraved speech.</source>
          <target state="translated">警惕你的舌头,防止邪恶和堕落的言论。</target>
        </trans-unit>
        <trans-unit id="3472b7100ee6c34d2c985ec6e738e904962356df" translate="yes" xml:space="preserve">
          <source>HAVING</source>
          <target state="translated">HAVING</target>
        </trans-unit>
        <trans-unit id="a4c7ee9ba5c961273e153da9b6004699add74ac0" translate="yes" xml:space="preserve">
          <source>HH:MM</source>
          <target state="translated">HH:MM</target>
        </trans-unit>
        <trans-unit id="4a05a9c514dbbe7b13aeee7ffbbac9804dba7f74" translate="yes" xml:space="preserve">
          <source>HH:MM:SS</source>
          <target state="translated">HH:MM:SS</target>
        </trans-unit>
        <trans-unit id="4fe76e489c6dd906a0f1a9c53aab6e472da095e8" translate="yes" xml:space="preserve">
          <source>HH:MM:SS.SSS</source>
          <target state="translated">HH:MM:SS.SSS</target>
        </trans-unit>
        <trans-unit id="65f5a5cdef2d1220d932d3711961b5f933bef00b" translate="yes" xml:space="preserve">
          <source>HHHHHHHH</source>
          <target state="translated">HHHHHHHH</target>
        </trans-unit>
        <trans-unit id="cbc6ab8d850f8cff446447123804da23a703c293" translate="yes" xml:space="preserve">
          <source>Halt</source>
          <target state="translated">Halt</target>
        </trans-unit>
        <trans-unit id="c9efb4e35e5411aedaf0542890d4f34de7fdc553" translate="yes" xml:space="preserve">
          <source>HaltIfNull</source>
          <target state="translated">HaltIfNull</target>
        </trans-unit>
        <trans-unit id="eda901a16a2ed9d0d0e178d305fa51f41c885dd9" translate="yes" xml:space="preserve">
          <source>Has the same PRIMARY KEY definition.</source>
          <target state="translated">具有相同的primary key定义。</target>
        </trans-unit>
        <trans-unit id="7b3c15bec716c58e30bb9a01cc52d490760b69bf" translate="yes" xml:space="preserve">
          <source>Has the same name,</source>
          <target state="translated">有相同的名字。</target>
        </trans-unit>
        <trans-unit id="96ee9d0e4b354db6f1aac2ad6a31abd4bc3e74ca" translate="yes" xml:space="preserve">
          <source>Has the same set of columns declared in the same order, and</source>
          <target state="translated">拥有相同顺序声明的同一组列,并且。</target>
        </trans-unit>
        <trans-unit id="71024d7461751155928cb62c4bbb4edb8155f4cb" translate="yes" xml:space="preserve">
          <source>Hate no one.</source>
          <target state="translated">不恨任何人。</target>
        </trans-unit>
        <trans-unit id="f5e9b1bebb569eb2b57a7ab4d85d0681e37d4262" translate="yes" xml:space="preserve">
          <source>Having SQLite take ownership of the type strings would impose a performance cost on all applications, even applications that do not use the pointer-passing interfaces. SQLite passes values around as instances of the &lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt; object. That object has a destructor, which because of the fact that sqlite3_value objects are used for nearly everything, is invoked frequently. If the destructor needs to check to see if there is a pointer type string that needs to be freed, that is a few extra CPU cycles that need to be burned on each call to the destructor. Those cycles add up. We would be willing to bear the cost of the extra CPU cycles if pointer-passing was a commonly used programming paradigm, but pointer-passing is rare, and so it seems unwise to impose a run-time cost on billions and billions of applications that do not use pointer passing just for convenience of a few applications that do.</source>
          <target state="translated">让SQLite拥有类型字符串的所有权会给所有应用程序带来性能损失，即使是不使用指针传递接口的应用程序也是如此。 SQLite传递值作为&lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value的&lt;/a&gt;实例目的。该对象具有析构函数，由于sqlite3_value对象几乎用于所有对象，因此会频繁调用该析构函数。如果析构函数需要检查是否有指针类型的字符串需要释放，那么每次对析构函数的调用都需要消耗一些额外的CPU周期。这些周期加起来。如果指针传递是一种常用的编程范例，我们将愿意承担额外的CPU周期的代价，但是指针传递很少见，因此将数十亿美元的应用程序的运行时成本强加于不要仅仅为了方便一些应用程序使用指针传递。</target>
        </trans-unit>
        <trans-unit id="3880fcd08d24da661937a86693cfca26882a3b4e" translate="yes" xml:space="preserve">
          <source>Hazards of upgrading to the NGQP</source>
          <target state="translated">升级到国家质检总局的危害。</target>
        </trans-unit>
        <trans-unit id="5050e4d38d7df11eb3b253f0629fcc46c260dc76" translate="yes" xml:space="preserve">
          <source>Header string: 0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7</source>
          <target state="translated">头部字符串。0xd9、0xd5、0x05、0xf9、0x20、0xa1、0x63、0xd7。</target>
        </trans-unit>
        <trans-unit id="4bc19fb4af9f917cd00992c6391f45202ff0d0ec" translate="yes" xml:space="preserve">
          <source>Hence, a good rule of thumb is that your database schema should never contain two indices where one index is a prefix of the other. Drop the index with fewer columns. SQLite will still be able to do efficient lookups with the longer index.</source>
          <target state="translated">因此,一个好的经验法则是,你的数据库模式永远不应该包含两个索引,其中一个索引是另一个索引的前缀。丢掉少列的索引。SQLite仍然能够用较长的索引进行有效的查找。</target>
        </trans-unit>
        <trans-unit id="e3f076946ec3be55b66dffc59ab395c4e63eeb8f" translate="yes" xml:space="preserve">
          <source>Hence, by adding extra &quot;output&quot; columns onto the end of an index, one can avoid having to reference the original table and thereby cut the number of binary searches for a query in half. This is a constant-factor improvement in performance (roughly a doubling of the speed). But on the other hand, it is also just a refinement; A two-fold performance increase is not nearly as dramatic as the one-million-fold increase seen when the table was first indexed. And for most queries, the difference between 1 microsecond and 2 microseconds is unlikely to be noticed.</source>
          <target state="translated">因此,通过在索引的末尾添加额外的 &quot;输出 &quot;列,可以避免引用原始表,从而将查询的二进制搜索次数减少一半。这对性能的提升是一个恒定的因素(大约是速度的一倍)。但另一方面,这也只是一种改进,两倍的性能提升还不如第一次索引表时百万倍的提升来得显著。而且对于大多数查询来说,1微秒和2微秒之间的差异不太可能被注意到。</target>
        </trans-unit>
        <trans-unit id="b665f7a53251e88b80c18ae95a6e2a7570ff2c9e" translate="yes" xml:space="preserve">
          <source>Hence, in comparison to other approaches, the use of an SQLite database as an application file format has compelling advantages. Here are a few of these advantages, enumerated and expounded:</source>
          <target state="translated">因此,与其他方法相比,使用SQLite数据库作为应用文件格式具有引人注目的优势。以下是对这些优势的一些列举和阐述。</target>
        </trans-unit>
        <trans-unit id="39e8db1d33a3457396e45de0c0793052727a641e" translate="yes" xml:space="preserve">
          <source>Hence, the content encoding for a WITHOUT ROWID table is the same as the content encoding for an ordinary rowid table, except that the order of the columns is rearranged so that PRIMARY KEY columns come first, and the content is used as the key in an index b-tree rather than as the data in a table b-tree. The special encoding rules for columns with REAL affinity apply to WITHOUT ROWID tables the same as they do with rowid tables.</source>
          <target state="translated">因此,WITHOUT ROWID表的内容编码与普通rowid表的内容编码是一样的,只是重新安排了列的顺序,使primary KEY列排在前面,内容被用作索引b树中的键而不是表b树中的数据。具有REAL亲和力的列的特殊编码规则适用于without rowid表,与适用于rowid表一样。</target>
        </trans-unit>
        <trans-unit id="999cfa83416c7b736dc3f3dfa6e7f25b9ba6e98f" translate="yes" xml:space="preserve">
          <source>Here again, version 2.7.0 of SQLite used to run at about the same speed as MySQL. But now version 2.7.6 is over two times faster than MySQL and over twenty times faster than PostgreSQL.</source>
          <target state="translated">这里再说一下,以前2.7.0版本的SQLite运行速度和MySQL差不多。但现在2.7.6版本比MySQL快了2倍多,比PostgreSQL快了20多倍。</target>
        </trans-unit>
        <trans-unit id="c79a9d1055558ef2d9992c6424392d62b259c2a6" translate="yes" xml:space="preserve">
          <source>Here are some existing and postulated uses for virtual tables:</source>
          <target state="translated">以下是虚拟表的一些现有的和假定的用途。</target>
        </trans-unit>
        <trans-unit id="f0580ad7def68334eac7c2c033faae47fa33aa31" translate="yes" xml:space="preserve">
          <source>Here are the syntax details:</source>
          <target state="translated">下面是详细的语法。</target>
        </trans-unit>
        <trans-unit id="c84ee5f5403083ecda923ec1470b2d4f31fd0f00" translate="yes" xml:space="preserve">
          <source>Here is a complete template extension that you can copy/paste to get started:</source>
          <target state="translated">这里是一个完整的模板扩展,你可以复制/粘贴开始。</target>
        </trans-unit>
        <trans-unit id="537d394cf0d1eecb92a9cbe8efc7e1a703bdd18e" translate="yes" xml:space="preserve">
          <source>Here is a query that computes the average height over everyone in Alice's organization, including Alice:</source>
          <target state="translated">下面是一个查询,计算包括爱丽丝在内的爱丽丝组织中所有人的平均身高。</target>
        </trans-unit>
        <trans-unit id="dd42feed9698b376dcb10e9aa54e385c734b65a6" translate="yes" xml:space="preserve">
          <source>Here is a query to show the tree structure in a breadth-first pattern:</source>
          <target state="translated">下面是一个以广度优先模式显示树结构的查询。</target>
        </trans-unit>
        <trans-unit id="b68ea20ab0a8004dffe949b080033114856a05ba" translate="yes" xml:space="preserve">
          <source>Here is a simple example of omitting a LEFT JOIN:</source>
          <target state="translated">下面是一个省略LEFT JOIN的简单例子。</target>
        </trans-unit>
        <trans-unit id="22d888f42ada11de3c14b5860a924536cf19b222" translate="yes" xml:space="preserve">
          <source>Here is a slightly different way to describe the aPgno values: If you think of all aPgno values as a contiguous array, then the database page number stored in the i-th frame of the WAL file is stored in aPgno[i]. Of course, aPgno is not a contiguous array. The first 4062 entries are on the first 32768-byte unit of the shm file and subsequent values are in 4096 entry chunks in later units of the shm file.</source>
          <target state="translated">这里有一种稍微不同的方式来描述aPgno值。如果你把所有的aPgno值看作是一个连续的数组,那么存储在WAL文件第i-th帧中的数据库页码就存储在aPgno[i]中.当然,aPgno不是一个连续数组。前4062个条目在shm文件的第一个32768字节的单元上,后续的值在shm文件后面的4096个条目块中。</target>
        </trans-unit>
        <trans-unit id="eeed83aeb26a72a7167e0caa92d0a130551072b7" translate="yes" xml:space="preserve">
          <source>Here is a summary of what the core interfaces do:</source>
          <target state="translated">下面是核心接口的工作总结。</target>
        </trans-unit>
        <trans-unit id="8a2373a91d98c2486bbd1ed6e2138a7e77394ed5" translate="yes" xml:space="preserve">
          <source>Here is a variation on the previous example:</source>
          <target state="translated">这里是上一个例子的变化。</target>
        </trans-unit>
        <trans-unit id="1319ba3fc57ef36ac27efdbc47123bdd4cb7f431" translate="yes" xml:space="preserve">
          <source>Here is an alternative description of the same computation:</source>
          <target state="translated">下面是对同样计算的另一种描述。</target>
        </trans-unit>
        <trans-unit id="44eacff0724c9f996876f69099ca0b2726a97ade" translate="yes" xml:space="preserve">
          <source>Here is an alternative way of describing the hash look-up algorithm: Start with h = (P * 383)%8192 and look at aHash[h] and subsequent entries, wrapping around to zero when h reaches 8192, until finding an entry with aHash[h]==0. All aPgno entries having a page number of P will have an index that is one of the aHash[h] values thusly computed. But not all the computed aHash[h] values will meet the matching criteria, so you must check them independently. The speed advantage comes about because normally this set of h values is very small.</source>
          <target state="translated">下面是描述哈希查找算法的另一种方式。从h=(P*383)%8192开始看aHash[h]和随后的条目,当h达到8192时绕到0,直到找到一个aHash[h]==0的条目。 所有页码为P的aPgno条目的索引都是这样计算出来的aHash[h]值之一。但是并不是所有计算出来的aHash[h]值都能满足匹配标准,所以你必须单独检查它们。速度上的优势是因为通常这组h值非常小。</target>
        </trans-unit>
        <trans-unit id="1a49c4bb8c6fe24c99e1160edbe5f45003dd833d" translate="yes" xml:space="preserve">
          <source>Here is an example using the built-in row_number() window function:</source>
          <target state="translated">下面是一个使用内置row_number()窗口函数的例子。</target>
        </trans-unit>
        <trans-unit id="1ed2d64e0577782df2f1f708b1c461ee5ebea46a" translate="yes" xml:space="preserve">
          <source>Here is what is going to happen: The first SELECT statement will construct rows of the result and save each row as the key of an entry in the transient table. The data for each entry in the transient table is a never used so we fill it in with an empty string. The second SELECT statement also constructs rows, but the rows constructed by the second SELECT are removed from the transient table. That is why we want the rows to be stored in the key of the SQLite file instead of in the data -- so they can be easily located and deleted.</source>
          <target state="translated">下面是将要发生的事情。第一条SELECT语句将构造结果的行 并将每行保存为瞬时表中一个条目的键。瞬时表中每个条目的数据都是一个从未使用过的,所以我们用一个空字符串来填充。第二条SELECT语句也会构造行,但第二条SELECT构造的行会从瞬时表中删除。这就是为什么我们要将行存储在SQLite文件的key中,而不是数据中--这样就可以很容易地找到和删除它们。</target>
        </trans-unit>
        <trans-unit id="7a844050eead2e7f9a21cd042c8a0efba1c399bc" translate="yes" xml:space="preserve">
          <source>Here is what the program must do. First it has to locate all of the records in the table &quot;examp&quot; that are to be deleted. This is done using a loop very much like the loop used in the SELECT examples above. Once all records have been located, then we can go back through and delete them one by one. Note that we cannot delete each record as soon as we find it. We have to locate all records first, then go back and delete them. This is because the SQLite database backend might change the scan order after a delete operation. And if the scan order changes in the middle of the scan, some records might be visited more than once and other records might not be visited at all.</source>
          <target state="translated">下面是程序必须做的事情。首先,它必须找到 &quot;examp &quot;表中所有要删除的记录。这是用一个循环来完成的,很像上面SELECT例子中使用的循环。一旦找到了所有的记录,那么我们就可以回过头来一条一条地删除它们。需要注意的是,我们不能一找到每一条记录就马上删除。我们必须先找到所有的记录,然后再回过头来删除它们。这是因为SQLite数据库后台在进行删除操作后,可能会改变扫描顺序。而如果扫描顺序在扫描过程中发生变化,有些记录可能会被访问不止一次,而有些记录可能根本就没有被访问。</target>
        </trans-unit>
        <trans-unit id="6ed0e64b4172a16a9716e7e75ddd35007c4f6e5a" translate="yes" xml:space="preserve">
          <source>Here is what you do to start experimenting with SQLite without having to do a lot of tedious reading and configuration:</source>
          <target state="translated">下面就是开始实验使用SQLite的方法,而不需要做很多繁琐的阅读和配置。</target>
        </trans-unit>
        <trans-unit id="c11a956fd1daf361e07b9a2963b5331668a6cb09" translate="yes" xml:space="preserve">
          <source>Here the apostrophe has been escaped and the SQL statement is well-formed. When generating SQL on-the-fly from data that might contain a single-quote character ('), it is always a good idea to use the SQLite printf routines and the %q formatting option instead of &lt;b&gt;sprintf&lt;/b&gt;.</source>
          <target state="translated">此处撇号已转义，并且SQL语句格式正确。从可能包含单引号字符（'）的数据即时生成SQL时，始终最好使用SQLite printf例程和％q格式化选项而不是&lt;b&gt;sprintf&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="53844b42e0f15c4e9c92f326da701e5edff51b64" translate="yes" xml:space="preserve">
          <source>Here the inequalities are on columns x and y which are not the left-most index columns. Hence, the histogram data which is collected no left-most column of indices is useless in helping to choose between the range constraints on columns x and y.</source>
          <target state="translated">这里的不等式是在x和y列上,而这两列不是最左边的索引列。因此,收集到的没有最左索引列的直方图数据对于帮助选择x和y列的范围约束是没有用的。</target>
        </trans-unit>
        <trans-unit id="54b1a90f72334cf67c79da3608b8cff7cc194a79" translate="yes" xml:space="preserve">
          <source>Hexadecimal</source>
          <target state="translated">Hexadecimal</target>
        </trans-unit>
        <trans-unit id="f3f781093bc605abee81ccbeb636a20f530bbe5d" translate="yes" xml:space="preserve">
          <source>Hexadecimal integer literals</source>
          <target state="translated">十六进制整数字数</target>
        </trans-unit>
        <trans-unit id="35e13960711ca47c62471d92f2b4029ee7852496" translate="yes" xml:space="preserve">
          <source>Hexadecimal integer literals follow the C-language notation of &quot;0x&quot; or &quot;0X&quot; followed by hexadecimal digits. For example, 0x1234 means the same as 4660 and 0x8000000000000000 means the same as -9223372036854775808. Hexadecimal integer literals are interpreted as 64-bit two's-complement integers and are thus limited to sixteen significant digits of precision. Support for hexadecimal integers was added to SQLite version 3.8.6 (2014-08-15). For backwards compatibility, the &quot;0x&quot; hexadecimal integer notation is only understood by the SQL language parser, not by the type conversions routines. String variables that contain text formatted like hexadecimal integers are not interpreted as hexadecimal integers when coercing the string value into an integer due to a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt; or for a &lt;a href=&quot;datatype3#affinity&quot;&gt;column affinity&lt;/a&gt; transformation or prior to performing a numeric operation or for any other run-time conversions. When coercing a string value in the format of a hexadecimal integer into an integer value, the conversion process stops when the 'x' character is seen so the resulting integer value is always zero. SQLite only understands the hexadecimal integer notation when it appears in the SQL statement text, not when it appears as part of the content of the database.</source>
          <target state="translated">十六进制整数文字遵循C语言符号&amp;ldquo; 0x&amp;rdquo;或&amp;ldquo; 0X&amp;rdquo;，后跟十六进制数字。例如，0x1234表示与4660相同，0x8000000000000000表示与-9223372036854775808相同。十六进制整数文字被解释为64位二进制补码整数，因此限制为精度的16个有效数字。 SQLite版本3.8.6（2014-08-15）已添加对十六进制整数的支持。为了向后兼容，SQL语言解析器只能理解&amp;ldquo; 0x&amp;rdquo;十六进制整数符号，类型转换例程不能理解。由于&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST表达式&lt;/a&gt;或&lt;a href=&quot;datatype3#affinity&quot;&gt;列相似性而将字符串值强制转换为整数时，包含格式如十六进制整数的文本的字符串变量不会解释为十六进制整数&lt;/a&gt;转换，执行数字运算之前或进行任何其他运行时转换。当将十六进制整数格式的字符串值强制转换为整数值时，当看到&amp;ldquo; x&amp;rdquo;字符时转换过程将停止，因此结果整数值始终为零。当SQLite出现在SQL语句文本中时，SQLite仅理解十六进制整数表示法，而当它作为数据库内容的一部分出现时，则不理解。</target>
        </trans-unit>
        <trans-unit id="4413e5afdd76b08f7a57f3501dcd353af75c6909" translate="yes" xml:space="preserve">
          <source>Hexadecimal integers</source>
          <target state="translated">十六进制整数</target>
        </trans-unit>
        <trans-unit id="34ad49fd08b5d8ebfe6309e8a94dbdda68560346" translate="yes" xml:space="preserve">
          <source>Hidden column</source>
          <target state="translated">隐藏栏</target>
        </trans-unit>
        <trans-unit id="47adea5ce487ea3890476b37d1c95b4a2f866391" translate="yes" xml:space="preserve">
          <source>Hidden columns are not included in the expansion of a &quot;*&quot; expression in the result set of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;, and</source>
          <target state="translated">&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;的结果集中的&amp;ldquo; *&amp;rdquo;表达式的扩展中不包含隐藏的列，并且</target>
        </trans-unit>
        <trans-unit id="20096dd8d3b8c2cfd4d3a69c38df377eed777771" translate="yes" xml:space="preserve">
          <source>Hidden columns are not included in the implicit column-list used by an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement that lacks an explicit column-list.</source>
          <target state="translated">缺少显式列列表的&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;语句使用的隐式列列表中不包含隐藏列。</target>
        </trans-unit>
        <trans-unit id="b7668a93e533ae2c015270865d5e714d07d437f1" translate="yes" xml:space="preserve">
          <source>Hidden columns are not listed in the dataset returned by &quot;&lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt;&quot;,</source>
          <target state="translated">隐藏的列未在&amp;ldquo; &lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt; &amp;rdquo; 返回的数据集中列出，</target>
        </trans-unit>
        <trans-unit id="c4cf7b97c327f9d39106315e4a050c0b0f137cef" translate="yes" xml:space="preserve">
          <source>Hierarchical Query Examples</source>
          <target state="translated">层次化查询示例</target>
        </trans-unit>
        <trans-unit id="62ae978c372dd625e1ad5bee3c09efecd27ef87c" translate="yes" xml:space="preserve">
          <source>High Reliability</source>
          <target state="translated">高可靠性</target>
        </trans-unit>
        <trans-unit id="5b43fa59ed80a4a74e2345ca9a7be4d00498a5de" translate="yes" xml:space="preserve">
          <source>High-Level Query Language</source>
          <target state="translated">高级查询语言</target>
        </trans-unit>
        <trans-unit id="f0be6eee61b3f35036173bb461da267d072410b3" translate="yes" xml:space="preserve">
          <source>High-security Value</source>
          <target state="translated">高安全性价值</target>
        </trans-unit>
        <trans-unit id="d4e0f8e3d3d0dc08399c35d69b24eda9dfffeab6" translate="yes" xml:space="preserve">
          <source>Higher level logic within SQLite will normally intercept the error code and create a temporary in-memory shared memory region so that the current process can at least read the content of the database. This result code should not reach the application interface layer.</source>
          <target state="translated">SQLite内部的高层逻辑通常会拦截错误代码,并创建一个临时的内存共享区域,以便当前进程至少可以读取数据库的内容。这个结果代码不应该到达应用接口层。</target>
        </trans-unit>
        <trans-unit id="8ec8e6f8b27cff894766ae4e4215e6f333126ae8" translate="yes" xml:space="preserve">
          <source>Highest precedence (tightest grouping).</source>
          <target state="translated">最高优先级(最紧密的分组)。</target>
        </trans-unit>
        <trans-unit id="9d8bc8b9f1a6b46c231d4505eec0f99894497892" translate="yes" xml:space="preserve">
          <source>Hint: applications can generate globally unique identifiers using this function together with &lt;a href=&quot;lang_corefunc#hex&quot;&gt;hex()&lt;/a&gt; and/or &lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower()&lt;/a&gt; like this:</source>
          <target state="translated">提示：应用程序可以使用此函数以及&lt;a href=&quot;lang_corefunc#hex&quot;&gt;hex（）&lt;/a&gt;和/或&lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower（）&lt;/a&gt;来生成全局唯一标识符，如下所示：</target>
        </trans-unit>
        <trans-unit id="13895cc550db90756c2c44f981469cdd85261a1d" translate="yes" xml:space="preserve">
          <source>Hints for Debugging SQLite</source>
          <target state="translated">调试SQLite的提示</target>
        </trans-unit>
        <trans-unit id="6b205a779ffaeec5fb12feda7165de7c06e54bbe" translate="yes" xml:space="preserve">
          <source>Historical test cases from &lt;a href=&quot;testing#aflfuzz&quot;&gt;AFL&lt;/a&gt;, &lt;a href=&quot;testing#ossfuzz&quot;&gt;OSS Fuzz&lt;/a&gt;, and &lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz&lt;/a&gt; are collected in a set of database files in the main SQLite source tree and then rerun by the &quot;fuzzcheck&quot; utility program whenever one runs &quot;make test&quot;. Fuzzcheck only runs a few thousand &quot;interesting&quot; cases out of the hundreds of millions of cases that the various fuzzers have examined over the years. &quot;Interesting&quot; cases are cases that exhibit previously unseen behavior. Actual bugs found by fuzzers are always included among the interesting test cases, but most of the cases run by fuzzcheck were never actual bugs.</source>
          <target state="translated">来自&lt;a href=&quot;testing#aflfuzz&quot;&gt;AFL&lt;/a&gt;，&lt;a href=&quot;testing#ossfuzz&quot;&gt;OSS Fuzz&lt;/a&gt;和&lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz的&lt;/a&gt;历史测试用例收集在主SQLite源树中的一组数据库文件中，然后每当运行&amp;ldquo; make test&amp;rdquo;时由&amp;ldquo; fuzzcheck&amp;rdquo;实用程序重新运行。多年来，各种模糊测试人员检查的亿万个案例中，Fuzzcheck仅运行了数千个&amp;ldquo;有趣&amp;rdquo;案例。 &amp;ldquo;有趣&amp;rdquo;的案例是表现出以前看不见的行为的案例。模糊测试人员发现的实际错误始终包含在有趣的测试用例中，但是fuzzcheck运行的大多数情况绝不是实际错误。</target>
        </trans-unit>
        <trans-unit id="67fec9a6d19b7573beec194f9c1e57c883f7bff1" translate="yes" xml:space="preserve">
          <source>Historically, backups (copies) of SQLite databases have been created using the following method:</source>
          <target state="translated">从历史上看,SQLite数据库的备份(副本)是通过以下方法创建的。</target>
        </trans-unit>
        <trans-unit id="a7796946d81b3e384b117135d383fc5e5877941f" translate="yes" xml:space="preserve">
          <source>Historically, the bytecode engine in SQLite is called the &quot;Virtual DataBase Engine&quot; or &quot;VDBE&quot;. This website uses the terms &quot;bytecode engine&quot;, &quot;VDBE&quot;, &quot;virtual machine&quot;, and &quot;bytecode virtual machine&quot; interchangeably, as they all mean the same thing.</source>
          <target state="translated">历史上,SQLite中的字节码引擎被称为 &quot;虚拟数据库引擎 &quot;或 &quot;VDBE&quot;。本网站交替使用术语 &quot;字节码引擎&quot;、&quot;VDBE&quot;、&quot;虚拟机 &quot;和 &quot;字节码虚拟机&quot;,因为它们的意思都一样。</target>
        </trans-unit>
        <trans-unit id="186352c9ed4b1d5538fac7c967930c7dfb52b78f" translate="yes" xml:space="preserve">
          <source>Historically, the return value from xFindFunction() was either zero or one. Zero means that the function is not overloaded and one means that it is overload. The ability to return values of &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or greater was added in version 3.25.0 (2018-09-15). If xFindFunction returns &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or greater, than means that the function takes two arguments and the function can be used as a boolean in the WHERE clause of a query and that the virtual table is able to exploit that function to speed up the query result. When xFindFunction returns &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or larger, the value returned becomes the sqlite3_index_info.aConstraint.op value for one of the constraints passed into &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex()&lt;/a&gt; and the second argument becomes the value corresponding to that constraint that is passed to &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter()&lt;/a&gt;. This enables the xBestIndex()/xFilter implementations to use the function to speed its search.</source>
          <target state="translated">从历史上看，xFindFunction（）的返回值是零或一。零表示该函数未过载，而一则表示该函数过载。在版本3.25.0（2018-09-15）中添加了返回&lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt;或更大值的功能。如果xFindFunction返回&lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt;或更大，则表示该函数带有两个参数，并且该函数可用作查询的WHERE子句中的布尔值，并且虚拟表能够利用该函数来加快查询结果。当xFindFunction返回&lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt;或更大值时，返回的值将成为传递给&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex（）&lt;/a&gt;的约束之一的sqlite3_index_info.aConstraint.op值。第二个参数成为与传递给&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter（）的&lt;/a&gt;约束相对应的值。这使xBestIndex（）/ xFilter实现可以使用该函数加快其搜索速度。</target>
        </trans-unit>
        <trans-unit id="48f87256a37f996b34f071b6b4ef5f1805966dbd" translate="yes" xml:space="preserve">
          <source>Historically, this was not considered a threat. The argument was that if a hostile agent is able to inject arbitrary SQL text into the application, then that agent is already in full control of the application, so letting the hostile agent forge a pointer does not give the agent any new capability.</source>
          <target state="translated">历史上,这并不被认为是一种威胁。其论点是,如果一个敌对代理能够将任意SQL文本注入到应用程序中,那么该代理已经完全控制了应用程序,所以让敌对代理伪造一个指针并不会给代理带来任何新的能力。</target>
        </trans-unit>
        <trans-unit id="bfbddd574d4f950742d8e5d7a49607c23d347f95" translate="yes" xml:space="preserve">
          <source>Honor all.</source>
          <target state="translated">尊敬所有的人。</target>
        </trans-unit>
        <trans-unit id="645a5172c51f2105b78cb24101222af4c2581b31" translate="yes" xml:space="preserve">
          <source>Honor the &lt;a href=&quot;c3ref/c_deserialize_freeonclose&quot;&gt;SQLITE_DESERIALIZE_READONLY&lt;/a&gt; flag, which was previously described in the documentation, but was previously a no-op.</source>
          <target state="translated">荣誉&lt;a href=&quot;c3ref/c_deserialize_freeonclose&quot;&gt;SQLITE_DESERIALIZE_READONLY&lt;/a&gt;标志，这是以前的文件中所描述的，但以前是一个空操作。</target>
        </trans-unit>
        <trans-unit id="2fff26aa56e0db9e63e42ae6a74896b210340408" translate="yes" xml:space="preserve">
          <source>Honor the ORDER BY and LIMIT clause of a SELECT even if the result set is used for an INSERT.</source>
          <target state="translated">即使结果集被用于INSERT,也要尊重SELECT的ORDER BY和LIMIT子句。</target>
        </trans-unit>
        <trans-unit id="972205ef02943c809b85189066f29ea5a922b1d8" translate="yes" xml:space="preserve">
          <source>Host parameter names can begin with '@' for compatibility with SQL Server.</source>
          <target state="translated">主机参数名可以以'@'开头,以便与SQL Server兼容。</target>
        </trans-unit>
        <trans-unit id="2107ab6c47208816e9f85a68b6f666b821dd323b" translate="yes" xml:space="preserve">
          <source>Hot Journal Detection</source>
          <target state="translated">热门期刊检测</target>
        </trans-unit>
        <trans-unit id="387adc1437f284bb8f7d821272256c3791f7c532" translate="yes" xml:space="preserve">
          <source>Hot Journal Rollback</source>
          <target state="translated">热门期刊回滚</target>
        </trans-unit>
        <trans-unit id="51a2396551270d6b1b9b0daa06c843f02294bf7a" translate="yes" xml:space="preserve">
          <source>Hot journal files</source>
          <target state="translated">热门日志文件</target>
        </trans-unit>
        <trans-unit id="33f85488d44d0b31b265f227edf83b283232673c" translate="yes" xml:space="preserve">
          <source>Hot journal rollback</source>
          <target state="translated">热期刊回滚</target>
        </trans-unit>
        <trans-unit id="72b9d3b59a2cd3c6b5726c2ec8f20f5cbd8fc2c8" translate="yes" xml:space="preserve">
          <source>How &lt;a href=&quot;queryplanner&quot;&gt;indexing&lt;/a&gt; works.</source>
          <target state="translated">&lt;a href=&quot;queryplanner&quot;&gt;索引&lt;/a&gt;如何工作。</target>
        </trans-unit>
        <trans-unit id="de544e283cfebc5d70d3d7b590e023e13a9bf879" translate="yes" xml:space="preserve">
          <source>How Memory-Mapped I/O Works</source>
          <target state="translated">内存映射I/O如何工作</target>
        </trans-unit>
        <trans-unit id="56b803311ab7e3e616ef538b11ad7fad3dcd0741" translate="yes" xml:space="preserve">
          <source>How SQLite Is Tested</source>
          <target state="translated">SQLite是如何被测试的</target>
        </trans-unit>
        <trans-unit id="f0b874a1265664f2f8c8240dcb0a141334e57668" translate="yes" xml:space="preserve">
          <source>How To Compile SQLite</source>
          <target state="translated">如何编译SQLite</target>
        </trans-unit>
        <trans-unit id="bac0366a300ac4acaffdcf4c3d4ee83a4619271d" translate="yes" xml:space="preserve">
          <source>How To Corrupt</source>
          <target state="translated">如何腐败</target>
        </trans-unit>
        <trans-unit id="07961a03bdae1448ec20af2c6389f109c109cecd" translate="yes" xml:space="preserve">
          <source>How To Corrupt An SQLite Database File</source>
          <target state="translated">如何破坏一个SQLite数据库文件</target>
        </trans-unit>
        <trans-unit id="ac75035a65466ee12d9ad12dabe0ea72bf4078bd" translate="yes" xml:space="preserve">
          <source>How To Corrupt Your Database Files</source>
          <target state="translated">如何破坏你的数据库文件</target>
        </trans-unit>
        <trans-unit id="6c4dc04d73e3b62534455f3b1b128df4687ca99e" translate="yes" xml:space="preserve">
          <source>How To Download Canonical SQLite Source Code</source>
          <target state="translated">如何下载Canonical SQLite源码</target>
        </trans-unit>
        <trans-unit id="023a32566bba30a34815129fd5e3cc90c1e899ca" translate="yes" xml:space="preserve">
          <source>How VACUUM works</source>
          <target state="translated">VACUUM如何工作</target>
        </trans-unit>
        <trans-unit id="996ef93cbabdf3a445d79226e8fa6d9c24a881f0" translate="yes" xml:space="preserve">
          <source>How are the syntax diagrams (a.k.a. &quot;railroad&quot; diagrams) for SQLite generated?</source>
          <target state="translated">SQLite的语法图(也就是 &quot;铁路 &quot;图)是如何生成的?</target>
        </trans-unit>
        <trans-unit id="fc0899650d804dfcac8dc2104606bf9268efcf1e" translate="yes" xml:space="preserve">
          <source>How collation is determined</source>
          <target state="translated">如何确定整理</target>
        </trans-unit>
        <trans-unit id="9a3218133ebd28240c94b4e7364a4f7e2e221ee5" translate="yes" xml:space="preserve">
          <source>How do I add or delete columns from an existing table in SQLite.</source>
          <target state="translated">如何在SQLite中从现有的表中添加或删除列。</target>
        </trans-unit>
        <trans-unit id="30aeec19cd6396142e3416e018900e8041d11cdb" translate="yes" xml:space="preserve">
          <source>How do I create an AUTOINCREMENT field?</source>
          <target state="translated">如何创建一个AUTOINCREMENT字段?</target>
        </trans-unit>
        <trans-unit id="a6cedc80b4e8057201d930bd24da72e7284f5f18" translate="yes" xml:space="preserve">
          <source>How do I list all tables/indices contained in an SQLite database</source>
          <target state="translated">如何列出SQLite数据库中的所有表/索引?</target>
        </trans-unit>
        <trans-unit id="94a002c7d3ab3f319a7a958c2ffad735eae889c1" translate="yes" xml:space="preserve">
          <source>How do I use a string literal that contains an embedded single-quote (') character?</source>
          <target state="translated">如何使用包含嵌入式单引号(')字符的字符串文字?</target>
        </trans-unit>
        <trans-unit id="df2742c7cfd9e0aab79b47f5b91d0027a0daa0fc" translate="yes" xml:space="preserve">
          <source>How many executable files are in the archive?</source>
          <target state="translated">档案中有多少个可执行文件?</target>
        </trans-unit>
        <trans-unit id="463cdf2e00bc03ffb0a58ce75a36b28173bad1d1" translate="yes" xml:space="preserve">
          <source>How vacuum works</source>
          <target state="translated">真空如何工作</target>
        </trans-unit>
        <trans-unit id="c2ebee163b547a5e69c6b8f18b3ce7ade428f296" translate="yes" xml:space="preserve">
          <source>However, client/server database engines (such as PostgreSQL, MySQL, or Oracle) usually support a higher level of concurrency and allow multiple processes to be writing to the same database at the same time. This is possible in a client/server database because there is always a single well-controlled server process available to coordinate access. If your application has a need for a lot of concurrency, then you should consider using a client/server database. But experience suggests that most applications need much less concurrency than their designers imagine.</source>
          <target state="translated">然而,客户/服务器数据库引擎(如PostgreSQL、MySQL或Oracle)通常支持更高层次的并发性,并允许多个进程同时向同一数据库写入。这在客户/服务器数据库中是可能的,因为总是有一个控制良好的服务器进程来协调访问。如果你的应用程序有大量并发的需求,那么你应该考虑使用客户/服务器数据库。但经验表明,大多数应用程序所需要的并发性比其设计者所想象的要小得多。</target>
        </trans-unit>
        <trans-unit id="a6ddbe53650906819e58dd27910958633c3e2cfa" translate="yes" xml:space="preserve">
          <source>However, for a &quot;contained-within&quot; style query, rounding the bounding boxes outward might cause some entries to be excluded from the result set if the edge of the entry bounding box corresponds to the edge of the query bounding box. To guard against this, applications should expand their contained-within query boxes slightly (by 0.000012%) by rounding down the lower coordinates and rounding up the top coordinates, in each dimension.</source>
          <target state="translated">然而,对于 &quot;包含-包围 &quot;风格的查询,如果条目包围盒的边缘与查询包围盒的边缘相对应,那么向外舍入包围盒可能会导致一些条目被排除在结果集中。为了防止这种情况发生,应用程序应该在每个维度上,通过四舍五入下层坐标和四舍五入上层坐标的方式,稍微扩大其包含在其中的查询框(0.000012%)。</target>
        </trans-unit>
        <trans-unit id="036059da8b4b48b5c802bde550324a35ba2a35da" translate="yes" xml:space="preserve">
          <source>However, highly tuned and specialized applications may want or need to replace some of SQLite's built-in system interfaces with alternative implementations more suitable for the needs of the application. SQLite is designed to be easily reconfigured at compile-time to meet the specific needs of individual projects. Among the compile-time configuration options for SQLite are these:</source>
          <target state="translated">然而,高度调整和专业化的应用程序可能希望或需要用更适合应用程序需求的替代实现来替换SQLite的一些内置系统接口。SQLite被设计成可以在编译时轻松地重新配置,以满足各个项目的特定需求。在SQLite的编译时配置选项中,有这些。</target>
        </trans-unit>
        <trans-unit id="9070a26476fc8018912ec09ceeee6b8f4a55c4f3" translate="yes" xml:space="preserve">
          <source>However, if a</source>
          <target state="translated">然而,如果一个</target>
        </trans-unit>
        <trans-unit id="96aad563dbeff373bd60c0d93a4ac2c049bba808" translate="yes" xml:space="preserve">
          <source>However, if a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation creates real tables (sometimes referred to as &quot;shadow&quot; tables) within the database to store its data in, then sqldiff.exe does calculate the difference between these. This can have surprising effects if the resulting SQL script is then run on a database that is not</source>
          <target state="translated">但是，如果&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;实现在数据库中创建实际表（有时称为&amp;ldquo;影子&amp;rdquo;表）以存储其数据，则sqldiff.exe会计算两者之间的差。如果生成的SQL脚本随后在非SQL Server数据库上运行，则会产生令人惊讶的效果。</target>
        </trans-unit>
        <trans-unit id="90ac212208b638040cc57dde761531e1857cf547" translate="yes" xml:space="preserve">
          <source>However, if a database has many concurrent overlapping readers and there is always at least one active reader, then no checkpoints will be able to complete and hence the WAL file will grow without bound.</source>
          <target state="translated">但是,如果一个数据库有很多并发的重叠读者,而且总是有至少一个活跃的读者,那么就没有检查点能够完成,因此WAL文件将无限制地增长。</target>
        </trans-unit>
        <trans-unit id="908b33a654e5b5eaa50e924611f16debc0d52007" translate="yes" xml:space="preserve">
          <source>However, if in-memory database pInMemory has just been opened (and is therefore completely empty) before being passed to function loadOrSaveDb(), then it is still possible to change its page size using an SQLite &quot;PRAGMA page_size&quot; command. Function loadOrSaveDb() could detect this case, and attempt to set the page-size of the in-memory database to the page-size of database zFilename before invoking the online backup API functions.</source>
          <target state="translated">但是,如果内存数据库pInMemory在被传递给函数loadOrSaveDb()之前刚刚被打开(因此是完全空的),那么仍然可以使用SQLite &quot;PRAGMA page_size &quot;命令改变其页面大小。函数loadOrSaveDb()可以检测到这种情况,并试图在调用在线备份API函数之前,将内存数据库的页面大小设置为数据库zFilename的页面大小。</target>
        </trans-unit>
        <trans-unit id="9282d84ef089a46651581dc23d9984a0b853a197" translate="yes" xml:space="preserve">
          <source>However, the application must guarantee that the destination &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is not passed to any other API (by any thread) after sqlite3_backup_init() is called and before the corresponding call to sqlite3_backup_finish(). SQLite does not currently check to see if the application incorrectly accesses the destination &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and so no error code is reported, but the operations may malfunction nevertheless. Use of the destination database connection while a backup is in progress might also also cause a mutex deadlock.</source>
          <target state="translated">但是，应用程序必须确保在调用sqlite3_backup_init（）之后和对sqlite3_backup_finish（）的相应调用之前，不会将目标&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;传递给任何其他API（通过任何线程）。SQLite当前不检查应用程序是否错误地访问了目标&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;，因此未报告任何错误代码，但是操作仍然可能会出错。在备份过程中使用目标数据库连接也可能会导致互斥锁死锁。</target>
        </trans-unit>
        <trans-unit id="6bd67d83c5ac9c5a6146085621d60822aa5f256c" translate="yes" xml:space="preserve">
          <source>However, the application must guarantee that the destination &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is not passed to any other API (by any thread) after sqlite3_backup_init() is called and before the corresponding call to sqlite3_backup_finish(). SQLite does not currently check to see if the application incorrectly accesses the destination &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and so no error code is reported, but the operations may malfunction nevertheless. Use of the destination database connection while a backup is in progress might also also cause a mutex deadlock.</source>
          <target state="translated">但是，应用程序必须确保在调用sqlite3_backup_init（）之后和对sqlite3_backup_finish（）的相应调用之前，不会将目标&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;传递给任何其他API（通过任何线程）。SQLite当前不检查应用程序是否错误地访问了目标&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;，因此未报告任何错误代码，但是操作仍然可能会出错。在备份过程中使用目标数据库连接也可能会导致互斥锁死锁。</target>
        </trans-unit>
        <trans-unit id="2051ec90af96c4dbbb12c8a2bb3921b04fb0a7f2" translate="yes" xml:space="preserve">
          <source>However, the b-tree for a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table is in the same format as an index b-tree. Thus, an index b-tree can be accessed as if it were a WITHOUT ROWID table.</source>
          <target state="translated">但是，&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表的b树与索引b树的格式相同。因此，索引b树可以像是WITHOUT ROWID表一样被访问。</target>
        </trans-unit>
        <trans-unit id="bdab598cbadf7cd7b2bb8bc0bda2ecbe3c4ceb3a" translate="yes" xml:space="preserve">
          <source>Hundreds of virtual tables that publish various aspects of the host computer, such as the process table, user lists, active network connections, and so forth. OsQuery is a separate project, started by Facebook, hosted on &lt;a href=&quot;https://github.com/facebook/osquery&quot;&gt;GitHub&lt;/a&gt;, and intended for security analysis and intrusion detection OsQuery is not a part of the SQLite project, but is included in this list because it demonstrates how the SQL language and the SQLite virtual table mechanism can be leveraged to provide elegant solutions to important real-world problems.</source>
          <target state="translated">数百个虚拟表发布了主机的各个方面，例如进程表，用户列表，活动的网络连接等。 OsQuery是一个单独的项目，由Facebook启动，托管在&lt;a href=&quot;https://github.com/facebook/osquery&quot;&gt;GitHub上&lt;/a&gt;，用于安全分析和入侵检测OsQuery不是SQLite项目的一部分，但包含在此列表中，因为它演示了SQL语言和SQLite虚拟表的方式。可以利用该机制为重要的现实问题提供完善的解决方案。</target>
        </trans-unit>
        <trans-unit id="6d245e7140689124e74b20cb072465076d95b006" translate="yes" xml:space="preserve">
          <source>I accidentally deleted some important information from my SQLite database. How can I recover it?</source>
          <target state="translated">我不小心删除了SQLite数据库中的一些重要信息。如何恢复?</target>
        </trans-unit>
        <trans-unit id="dc9c3207dff5659b4c310cd90f15260ed36f68c7" translate="yes" xml:space="preserve">
          <source>I am told that Git users commonly install third-party graphical viewers for Git, many of which do a better job of showing recent activity on the project. That is great, but these are still more third-party applications that must be installed and managed separately. Many are platform-specific. (One of the better ones, &lt;a href=&quot;https://gitup.co/&quot;&gt;GitUp&lt;/a&gt;, only works on Mac, for example.) All require that you first sync your local repository then bring up their graphical interface on your desktop. And even with all that, I still cannot see what I typically want to see without multiple clicks. Checking on project status from a phone while away from the office is not an option.</source>
          <target state="translated">有人告诉我，Git用户通常会为Git安装第三方图形查看器，其中许多在显示项目近期活动方面做得更好。很好，但是这些仍然是更多第三方应用程序，必须分别安装和管理。许多是特定于平台的。 （例如，更好的&lt;a href=&quot;https://gitup.co/&quot;&gt;GitUp之一&lt;/a&gt;仅适用于Mac。）所有这些都要求您首先同步本地存储库，然后在桌面上启动其图形界面。即使有所有这些，如果没有多次单击，我仍然看不到我通常希望看到的内容。不在办公室时，无法通过电话检查项目状态。</target>
        </trans-unit>
        <trans-unit id="a5d8bfaba744d8865014e1b5776daef69b8ba64a" translate="yes" xml:space="preserve">
          <source>I am told that the default PostgreSQL configuration in RedHat 7.3 is unnecessarily conservative (it is designed to work on a machine with 8MB of RAM) and that PostgreSQL could be made to run a lot faster with some knowledgeable configuration tuning. Matt Sergeant reports that he has tuned his PostgreSQL installation and rerun the tests shown below. His results show that PostgreSQL and MySQL run at about the same speed. For Matt's results, visit</source>
          <target state="translated">我被告知,RedHat 7.3中默认的PostgreSQL配置是不必要的保守(它被设计为工作在一台内存为8MB的机器上),PostgreSQL可以通过一些知识性的配置调整来使其运行得更快。Matt Sergeant报告说,他已经调整了PostgreSQL的安装,并重新运行了下面的测试。他的结果显示,PostgreSQL和MySQL的运行速度差不多。关于Matt的结果,请访问</target>
        </trans-unit>
        <trans-unit id="c4b4aed72c495e6b69cc90a12c1002093ba09a73" translate="yes" xml:space="preserve">
          <source>I deleted a lot of data but the database file did not get any smaller. Is this a bug?</source>
          <target state="translated">我删除了很多数据,但是数据库文件并没有变小。这是一个错误吗?</target>
        </trans-unit>
        <trans-unit id="30c131b4d60b85b44b7c7e76894246c9eeed47f8" translate="yes" xml:space="preserve">
          <source>I get a compiler error if I use the SQLITE_OMIT_... compile-time options when building SQLite.</source>
          <target state="translated">如果我在构建SQLite时使用SQLITE_OMIT_...编译时的选项,我得到一个编译器错误。</target>
        </trans-unit>
        <trans-unit id="96380689d1c266e443557fac220e162eb248fe7f" translate="yes" xml:space="preserve">
          <source>I get some compiler warnings when I compile SQLite. Isn't this a problem? Doesn't it indicate poor code quality?</source>
          <target state="translated">我在编译SQLite的时候收到一些编译器警告。这难道不是一个问题吗?是不是说明代码质量不好?</target>
        </trans-unit>
        <trans-unit id="b0631d514fcfd330a2105540a0b813b7c7b65c3f" translate="yes" xml:space="preserve">
          <source>I/O error testing is similar in concept to OOM testing; I/O errors are simulated and checks are made to verify that SQLite responds correctly to the simulated errors. I/O errors are simulated in both the TCL and TH3 test harnesses by inserting a new &lt;a href=&quot;c3ref/vfs&quot;&gt;Virtual File System object&lt;/a&gt; that is specially rigged to simulate an I/O error after a set number of I/O operations. As with OOM error testing, the I/O error simulators can be set to fail just once, or to fail continuously after the first failure. Tests are run in a loop, slowly increasing the point of failure until the test case runs to completion without error. The loop is run twice, once with the I/O error simulator set to simulate only a single failure and a second time with it set to fail all I/O operations after the first failure.</source>
          <target state="translated">I / O错误测试的概念与OOM测试类似；模拟I / O错误，并进行检查以验证SQLite对模拟错误是否正确响应。通过插入一个新的&lt;a href=&quot;c3ref/vfs&quot;&gt;虚拟文件系统对象&lt;/a&gt;（在经过一定数量的I / O操作后专门模拟I / O错误），可以在TCL和TH3测试工具中模拟I / O错误。与OOM错误测试一样，可以将I / O错误模拟器设置为仅失败一次，或在首次失败后连续失败。测试以循环方式运行，缓慢增加故障点，直到测试用例运行无误为止。该循环运行两次，一次将I / O错误模拟器设置为仅模拟单个故障，第二次将循环设置为在第一次故障后使所有I / O操作失败。</target>
        </trans-unit>
        <trans-unit id="7e39c1a666c2fd143f11a87457de9e9888317484" translate="yes" xml:space="preserve">
          <source>I/O error testing seeks to verify that SQLite responds sanely to failed I/O operations. I/O errors might result from a full disk drive, malfunctioning disk hardware, network outages when using a network file system, system configuration or permission changes that occur in the middle of an SQL operation, or other hardware or operating system malfunctions. Whatever the cause, it is important that SQLite be able to respond correctly to these errors and I/O error testing seeks to verify that it does.</source>
          <target state="translated">I/O错误测试旨在验证SQLite是否对失败的I/O操作做出了理智的响应。I/O错误可能是由于磁盘驱动器满载、磁盘硬件故障、使用网络文件系统时的网络中断、在SQL操作中间发生的系统配置或权限更改,或其他硬件或操作系统故障造成的。不管是什么原因,重要的是SQLite能够正确地响应这些错误,I/O错误测试旨在验证它是否正确。</target>
        </trans-unit>
        <trans-unit id="8d8651647c9490ad914b1a9a6e6d44929ce46c04" translate="yes" xml:space="preserve">
          <source>I/O error tests</source>
          <target state="translated">I/O错误测试</target>
        </trans-unit>
        <trans-unit id="35d92e9f60aece05bafa666d5e6093c27b070d38" translate="yes" xml:space="preserve">
          <source>I/O errors in the OS-interface generate error logging events. The message to these events gives the line number in the source code where the error originated and the filename associated with the event when there is a corresponding file.</source>
          <target state="translated">OS-接口中的I/O错误会产生错误日志事件。这些事件的信息给出了源代码中错误起源的行号,以及在有相应文件时与事件相关联的文件名。</target>
        </trans-unit>
        <trans-unit id="d998ed8c49ae368254ded62fce1c76a6c0d44f30" translate="yes" xml:space="preserve">
          <source>I/O performance is measured using the &lt;a href=&quot;https://www.sqlite.org/src/file/test/kvtest.c&quot;&gt;kvtest.c&lt;/a&gt; program from the SQLite source tree. To compile this test program, first gather the kvtest.c source file into a directory with the &lt;a href=&quot;amalgamation&quot;&gt;SQLite amalgamation&lt;/a&gt; source files &quot;sqlite3.c&quot; and &quot;sqlite3.h&quot;. Then on unix, run a command like the following:</source>
          <target state="translated">使用SQLite源代码树中的&lt;a href=&quot;https://www.sqlite.org/src/file/test/kvtest.c&quot;&gt;kvtest.c&lt;/a&gt;程序测量I / O性能。要编译此测试程序，请首先将kvtest.c源文件收集到包含&lt;a href=&quot;amalgamation&quot;&gt;SQLite合并&lt;/a&gt;源文件&amp;ldquo; sqlite3.c&amp;rdquo;和&amp;ldquo; sqlite3.h&amp;rdquo;的目录中。然后在UNIX上，运行如下命令：</target>
        </trans-unit>
        <trans-unit id="e779dca751c9ced361a0eadbe7916be59d02dc09" translate="yes" xml:space="preserve">
          <source>I/O performance varies widely depending on operating system and hardware. Make your own measurements before drawing conclusions.</source>
          <target state="translated">I/O性能因操作系统和硬件不同而有很大差异。在得出结论之前,请自己进行测量。</target>
        </trans-unit>
        <trans-unit id="267e452e4d048aacef682e30a9d368c22e7501e4" translate="yes" xml:space="preserve">
          <source>IDF(q&lt;sub&gt;i&lt;/sub&gt;)</source>
          <target state="translated">IDF(q&lt;sub&gt;i&lt;/sub&gt;)</target>
        </trans-unit>
        <trans-unit id="7be63e2881f7da8faa393bfe0ce4667f10916b66" translate="yes" xml:space="preserve">
          <source>IF</source>
          <target state="translated">IF</target>
        </trans-unit>
        <trans-unit id="235cae5b9c97fbc3364fb92af44d64b71392dbb2" translate="yes" xml:space="preserve">
          <source>IF EXISTS and IF NOT EXISTS clauses on CREATE/DROP TABLE/INDEX.</source>
          <target state="translated">关于CREATE/DROP TABLE/INDEX的IF EXISTS和IF NOT EXISTS子句。</target>
        </trans-unit>
        <trans-unit id="c9226f99dd645a71848cf0585c15059d7de868f4" translate="yes" xml:space="preserve">
          <source>IGNORE</source>
          <target state="translated">IGNORE</target>
        </trans-unit>
        <trans-unit id="8ae3e8381a64e36db57a5344790db89d7de90954" translate="yes" xml:space="preserve">
          <source>IMMEDIATE</source>
          <target state="translated">IMMEDIATE</target>
        </trans-unit>
        <trans-unit id="3b63a4da1415c242da17f132d0e00d086153fa66" translate="yes" xml:space="preserve">
          <source>IMMEDIATE cause the database connection to start a new write immediately, without waiting for a write statement. The BEGIN IMMEDIATE might fail with &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if another write transaction is already active on another database connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f94ea3de1605903ae5123660f5457eb8bd32e9f" translate="yes" xml:space="preserve">
          <source>IMMEDIATE cause the database connection to start a new write immediately, without waiting for a writes statement. The BEGIN IMMEDIATE might fail with &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if another write transaction is already active on another database connection.</source>
          <target state="translated">IMMEDIATE使数据库连接立即开始新的写操作，而无需等待writes语句。如果另一个写连接在另一个数据库连接上已经处于活动状态，则BEGIN IMMEDIATE可能会失败并显示&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4db76ad8831e1ebbbc52031b1ae484c99975878" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to include crashing the application). The estimatedRows field should therefore only be used if &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f10a7701656ba82f20f9690db33f263b9944c35" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to include crashing the application). The estimatedRows field should therefore only be used if &lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac8fb933cd53d38ff3f25855409c3725df641570" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to included crashing the application). The estimatedRows field should therefore only be used if &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.</source>
          <target state="translated">重要说明：SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;版本3.8.2&lt;/a&gt;（2013-12-06）的EstimatedRows字段已添加到sqlite3_index_info结构中。如果将虚拟表扩展名与3.8.2之前的SQLite版本一起使用，则尝试读取或写入estimatedRows字段的结果是不确定的（但可能会导致应用程序崩溃）。因此，仅当&lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion_number（）&lt;/a&gt;返回的值大于或等于3008002时，才应使用estimatedRows字段。类似地，为&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;版本3.9.0&lt;/a&gt;（2015-10-14）添加了idxFlags字段。因此，只有在sqlite3_libversion_number（）返回的值大于或等于3009000时，才可以使用它。</target>
        </trans-unit>
        <trans-unit id="f7788b148a07ca2844906ea43293afae622f959f" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to included crashing the application). The estimatedRows field should therefore only be used if &lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.</source>
          <target state="translated">重要说明：SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;版本3.8.2&lt;/a&gt;（2013-12-06）的EstimatedRows字段已添加到sqlite3_index_info结构中。如果将虚拟表扩展名与3.8.2之前的SQLite版本一起使用，则尝试读取或写入estimatedRows字段的结果是不确定的（但可能会导致应用程序崩溃）。因此，仅当&lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion_number（）&lt;/a&gt;返回的值大于或等于3008002时，才应使用estimatedRows字段。类似地，为&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;版本3.9.0&lt;/a&gt;（2015-10-14）添加了idxFlags字段。因此，只有在sqlite3_libversion_number（）返回的值大于或等于3009000时，才可以使用它。</target>
        </trans-unit>
        <trans-unit id="6fca55ca3c828a46bfe96a10e69f572b61ce540c" translate="yes" xml:space="preserve">
          <source>IN</source>
          <target state="translated">IN</target>
        </trans-unit>
        <trans-unit id="9e93d8e547641024337c9f88c37aeeb56b09cfd4" translate="yes" xml:space="preserve">
          <source>IN operator</source>
          <target state="translated">IN操作员</target>
        </trans-unit>
        <trans-unit id="2704c1d8c3fc215c38ee176f6cc30e434a22b7d7" translate="yes" xml:space="preserve">
          <source>INDEX</source>
          <target state="translated">INDEX</target>
        </trans-unit>
        <trans-unit id="d34941b7cef935d2b4b0705a24e87fad9ef16cef" translate="yes" xml:space="preserve">
          <source>INDEXED</source>
          <target state="translated">INDEXED</target>
        </trans-unit>
        <trans-unit id="0a477a77f065212096e980b210eda0227cabf37c" translate="yes" xml:space="preserve">
          <source>INDEXED BY</source>
          <target state="translated">INDEXED BY</target>
        </trans-unit>
        <trans-unit id="fd4d2f0d5aa850e30c0830c19e27d0fa4c65c7a7" translate="yes" xml:space="preserve">
          <source>INITIALLY</source>
          <target state="translated">INITIALLY</target>
        </trans-unit>
        <trans-unit id="88d86d54436967d4b4599d22d53c2a3db38390e6" translate="yes" xml:space="preserve">
          <source>INNER</source>
          <target state="translated">INNER</target>
        </trans-unit>
        <trans-unit id="c20ea07e32d25c072a65368c234d6f5a88f4521a" translate="yes" xml:space="preserve">
          <source>INSERT</source>
          <target state="translated">INSERT</target>
        </trans-unit>
        <trans-unit id="06c4e866c3ade62ba74b04b1ef54dce90603c067" translate="yes" xml:space="preserve">
          <source>INSERT Changes</source>
          <target state="translated">INSERT 更改</target>
        </trans-unit>
        <trans-unit id="4e7c6a59e9c103dd735d95fe84726b20fe104acf" translate="yes" xml:space="preserve">
          <source>INSERT INTO demo2(command) VALUES(&quot;reset&quot;);</source>
          <target state="translated">INSERT INTO demo2(command)VALUES(&quot;reset&quot;)。</target>
        </trans-unit>
        <trans-unit id="ed9844477a7bb01e976b863376804eb769331989" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 SELECT b,a,c FROM t2;</source>
          <target state="translated">INSERT INTO t1 SELECT b,a,c FROM t2;</target>
        </trans-unit>
        <trans-unit id="767dcfed1e7a66d267a3220fbe439232373351ee" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(1,10719,'ten thousand seven hundred nineteen');</source>
          <target state="translated">INSERT INTO t1 VALUES(1,10719,'ten thousand seven hundred nineteen')。</target>
        </trans-unit>
        <trans-unit id="a30ee5b0b970fc276bf5d3453cfa994508fd0177" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(1,13153,'thirteen thousand one hundred fifty three');</source>
          <target state="translated">INSERT INTO t1 VALUES(1,13153,'一万三千一百五十三')。</target>
        </trans-unit>
        <trans-unit id="4bc6de27aceadc240c8dd43059a82f9a9561379b" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(1000,94142,'ninety four thousand one hundred forty two');</source>
          <target state="translated">INSERT INTO t1 VALUES(1000,94142,'九万四千一百四十二')。</target>
        </trans-unit>
        <trans-unit id="62d9636f68aa675dabacb22b938d9f2be06b55e0" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(11999,72836,'seventy two thousand eight hundred thirty six');</source>
          <target state="translated">INSERT INTO t1 VALUES(11999,72836,'七万二千八百三十六')。</target>
        </trans-unit>
        <trans-unit id="f0fbe2df8c33450eafb90fd96d71291641e02aa4" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(12000,64231,'sixty four thousand two hundred thirty one');</source>
          <target state="translated">INSERT INTO t1 VALUES(12000,64231,'六万四千二百三十一')。</target>
        </trans-unit>
        <trans-unit id="31a76630ad88d2e05dde2c415d8576db8ec6caf9" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(2,75560,'seventy five thousand five hundred sixty');</source>
          <target state="translated">INSERT INTO t1 VALUES(2,75560,'七万五千五百六十')。</target>
        </trans-unit>
        <trans-unit id="215d5732ce27fd223582c712aaa4660a83a173d4" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(998,66289,'sixty six thousand two hundred eighty nine');</source>
          <target state="translated">INSERT INTO t1 VALUES(998,66289,'六万六千二百八十九')。</target>
        </trans-unit>
        <trans-unit id="4b533e1d2a14d2013c249801c64abee1873ad0e7" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(999,24322,'twenty four thousand three hundred twenty two');</source>
          <target state="translated">INSERT INTO t1 VALUES(999,24322,'二十四万三千二百二')。</target>
        </trans-unit>
        <trans-unit id="c97d31d96ba9608129ccb018853e9ea9cb6076d1" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 SELECT * FROM t1;</source>
          <target state="translated">INSERT INTO t2 SELECT*FROM t1;</target>
        </trans-unit>
        <trans-unit id="18573be7d634b7266c9f3fabe6799c0e9de399b2" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 SELECT b,a,c FROM t1;</source>
          <target state="translated">INSERT INTO t2 SELECT b,a,c FROM t1;</target>
        </trans-unit>
        <trans-unit id="6654bc4310d1eef443b5f0f2c1641262634e1e66" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 VALUES(1,59672,'fifty nine thousand six hundred seventy two');</source>
          <target state="translated">INSERT INTO t2 VALUES(1,59672,'五万九千六百七十二')。</target>
        </trans-unit>
        <trans-unit id="94d1d27ed943c864c7cfd96715bf162e7beab100" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 VALUES(24999,89569,'eighty nine thousand five hundred sixty nine');</source>
          <target state="translated">INSERT INTO t2 VALUES(24999,89569,'八万九千五百六十九')。</target>
        </trans-unit>
        <trans-unit id="253860cdd49bceb80fa941fa6a7a8aa222a2af3e" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 VALUES(25000,94666,'ninety four thousand six hundred sixty six');</source>
          <target state="translated">INSERT INTO t2 VALUES(25000,94666,'九万四千六百六十六')。</target>
        </trans-unit>
        <trans-unit id="0e8f253b1b555988f2df4dcb60865d19307f1b0c" translate="yes" xml:space="preserve">
          <source>INSERT INTO t3 VALUES(24999,88509,'eighty eight thousand five hundred nine');</source>
          <target state="translated">INSERT INTO t3 VALUES(24999,88509,'八万八千五百九')。</target>
        </trans-unit>
        <trans-unit id="00be643bf7f738dedf700c9b2a35f10694c7941a" translate="yes" xml:space="preserve">
          <source>INSERT INTO t3 VALUES(25000,84791,'eighty four thousand seven hundred ninety one');</source>
          <target state="translated">INSERT INTO t3 VALUES(25000,84791,'八万四千七百九十一')。</target>
        </trans-unit>
        <trans-unit id="eb2365c71aa4f9cd4a1bfec486fd83fcbdda7977" translate="yes" xml:space="preserve">
          <source>INSERT INTO tab1 VALUES(?,?,?);</source>
          <target state="translated">INSERT INTO tab1 VALUES(?,?,?)。</target>
        </trans-unit>
        <trans-unit id="0666a7f2affc6b3653a4c2bdf54c9b4bb98361ed" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('automerge=N');</source>
          <target state="translated">INSERT INTO xyz(xyz)VALUES('automerge=N')。</target>
        </trans-unit>
        <trans-unit id="4e8b9a8e297bede64cc05b119a6cea847e694a59" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('integrity-check');</source>
          <target state="translated">INSERT INTO xyz(xyz)VALUES('完整性检查')。</target>
        </trans-unit>
        <trans-unit id="f5e0d229ccc9b20df140de91fa55ac169f3840fe" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('merge=X,Y');</source>
          <target state="translated">INSERT INTO xyz(xyz)VALUES('merge=X,Y')。</target>
        </trans-unit>
        <trans-unit id="5af88d4a59ba50ff893198ed67ae451d74a117e2" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('optimize');</source>
          <target state="translated">INSERT INTO xyz(xyz)VALUES('优化')。</target>
        </trans-unit>
        <trans-unit id="13f47444da210de43c60aab402a316dfe2becb56" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('rebuild');</source>
          <target state="translated">INSERT INTO xyz(xyz)VALUES('rebuild')。</target>
        </trans-unit>
        <trans-unit id="631e931c19e40aa3da1ce6f0902d43d9a508af25" translate="yes" xml:space="preserve">
          <source>INSERT and UPDATE statements now always apply &lt;a href=&quot;datatype3#affinity&quot;&gt;column affinity&lt;/a&gt; before computing &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;. This bug fix could, in theory, cause problems for legacy databases with unorthodox CHECK constraints the require the input type for an INSERT is different from the declared column type. See ticket &lt;a href=&quot;https://sqlite.org/src/info/86ba67afafded936&quot;&gt;86ba67afafded936&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f103f7920401a2a0647c3f2159a7c89eabff571" translate="yes" xml:space="preserve">
          <source>INSERT is really slow - I can only do few dozen INSERTs per second</source>
          <target state="translated">INSERT真的很慢--我每秒钟只能做几十个INSERT。</target>
        </trans-unit>
        <trans-unit id="62d1399645f66158b7511abeddf89f395dea5fde" translate="yes" xml:space="preserve">
          <source>INSERT runs a little faster when the source is a SELECT statement.</source>
          <target state="translated">当源是SELECT语句时,INSERT的运行速度会更快一些。</target>
        </trans-unit>
        <trans-unit id="aeb597e62b4ad26deac5b62c60062c710ea90371" translate="yes" xml:space="preserve">
          <source>INSTEAD</source>
          <target state="translated">INSTEAD</target>
        </trans-unit>
        <trans-unit id="2300ac39d09a99728ae682403c03797ee8da658b" translate="yes" xml:space="preserve">
          <source>INSTEAD OF trigger</source>
          <target state="translated">而不是触发</target>
        </trans-unit>
        <trans-unit id="d8374d53c837e126cb6abc0132fba2a1f9a3a9c8" translate="yes" xml:space="preserve">
          <source>INSTEAD OF triggers</source>
          <target state="translated">而不是触发器</target>
        </trans-unit>
        <trans-unit id="793985cddb68d46ef51b688aecf85864c9e06813" translate="yes" xml:space="preserve">
          <source>INT</source>
          <target state="translated">INT</target>
        </trans-unit>
        <trans-unit id="a3a0ec55e3e26ee54417c786dfad5d709ecb7c40" translate="yes" xml:space="preserve">
          <source>INT2</source>
          <target state="translated">INT2</target>
        </trans-unit>
        <trans-unit id="021a30ffe1ce8750cb57ce941d7fb3d04090b37c" translate="yes" xml:space="preserve">
          <source>INT8</source>
          <target state="translated">INT8</target>
        </trans-unit>
        <trans-unit id="0fe37e40e5dab3ac411c2ddca6d21991e811acfa" translate="yes" xml:space="preserve">
          <source>INTEGER</source>
          <target state="translated">INTEGER</target>
        </trans-unit>
        <trans-unit id="e3752510d6a9d0fb8f3974168ca6bea1a562a9ac" translate="yes" xml:space="preserve">
          <source>INTEGER PRIMARY KEY columns can be used to implement the equivalent of AUTOINCREMENT. If you try to insert a NULL into an INTEGER PRIMARY KEY column, the column will actually be filled with an integer that is one greater than the largest key already in the table. Or if the largest key is 2147483647, then the column will be filled with a random integer. Either way, the INTEGER PRIMARY KEY column will be assigned a unique integer. You can retrieve this integer using the &lt;b&gt;sqlite_last_insert_rowid()&lt;/b&gt; API function or using the &lt;b&gt;last_insert_rowid()&lt;/b&gt; SQL function in a subsequent SELECT statement.</source>
          <target state="translated">INTEGER PRIMARY KEY列可用于实现等效的AUTOINCREMENT。如果您尝试将NULL插入INTEGER PRIMARY KEY列，则该列实际上将填充一个整数，该整数比表中已有的最大键大1。或者，如果最大键为2147483647，则该列将填充一个随机整数。无论哪种方式，都将为INTEGER PRIMARY KEY列分配一个唯一的整数。您可以使用&lt;b&gt;sqlite_last_insert_rowid（）&lt;/b&gt; API函数或在后续的SELECT语句中使用&lt;b&gt;last_insert_rowid（）&lt;/b&gt; SQL函数来检索此整数。</target>
        </trans-unit>
        <trans-unit id="6f436e25f27f33e27c6053472309a17baa61d133" translate="yes" xml:space="preserve">
          <source>INTERFACE</source>
          <target state="translated">INTERFACE</target>
        </trans-unit>
        <trans-unit id="3230de938114213aa9c2d1e95f291cad51ede171" translate="yes" xml:space="preserve">
          <source>INTERSECT</source>
          <target state="translated">INTERSECT</target>
        </trans-unit>
        <trans-unit id="ce45b16212fe00c28d1a00de9cdfe954aa5bdc83" translate="yes" xml:space="preserve">
          <source>INTO</source>
          <target state="translated">INTO</target>
        </trans-unit>
        <trans-unit id="ec4a2a5056d72d8e03345caaebf4607d163e6dd7" translate="yes" xml:space="preserve">
          <source>IS</source>
          <target state="translated">IS</target>
        </trans-unit>
        <trans-unit id="819809f7649d3da66fd65a40dff83509ed2b98d0" translate="yes" xml:space="preserve">
          <source>IS NOT</source>
          <target state="translated">是不</target>
        </trans-unit>
        <trans-unit id="437390c0773d23a0b0e272480ef7204b356f23ad" translate="yes" xml:space="preserve">
          <source>IS operator</source>
          <target state="translated">IS运营商</target>
        </trans-unit>
        <trans-unit id="4e93120a53b25e7642cc15924ececcc7c79ac693" translate="yes" xml:space="preserve">
          <source>ISNULL</source>
          <target state="translated">ISNULL</target>
        </trans-unit>
        <trans-unit id="c8c6b6fe3176986c9e57f2648e139dfd273d0908" translate="yes" xml:space="preserve">
          <source>Ideally, all changes for an entire write transaction are buffered in the page cache until the end of the transaction. When the user commits the transaction, all changes are applied to the database file in the most efficient way possible, taking into account the assumptions enumerated in section</source>
          <target state="translated">理想情况下,整个写事务的所有变化都会被缓冲在页面缓存中,直到事务结束。当用户提交事务时,所有的更改都会以最有效的方式应用到数据库文件中,同时考虑到第3节中列举的假设。</target>
        </trans-unit>
        <trans-unit id="3aa28748de853653631eccc0d256aed420f0eed1" translate="yes" xml:space="preserve">
          <source>Ideally, applications should &lt;a href=&quot;#sqlite3_finalize&quot;&gt;finalize&lt;/a&gt; all &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;close&lt;/a&gt; all &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;#sqlite3backupfinish&quot;&gt;finish&lt;/a&gt; all &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects associated with the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object prior to attempting to close the object. If the database connection is associated with unfinalized prepared statements, BLOB handlers, and/or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements, unclosed BLOB handlers, and/or unfinished sqlite3_backups, it returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; regardless, but instead of deallocating the database connection immediately, it marks the database connection as an unusable &quot;zombie&quot; and makes arrangements to automatically deallocate the database connection after all prepared statements are finalized, all BLOB handles are closed, and all backups have finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a04cc62fe27e532be18f141495602f090fc2e2" translate="yes" xml:space="preserve">
          <source>Ideally, applications should &lt;a href=&quot;finalize&quot;&gt;finalize&lt;/a&gt; all &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;blob_close&quot;&gt;close&lt;/a&gt; all &lt;a href=&quot;blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;finish&lt;/a&gt; all &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects associated with the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object prior to attempting to close the object. If the database connection is associated with unfinalized prepared statements, BLOB handlers, and/or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements, unclosed BLOB handlers, and/or unfinished sqlite3_backups, it returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; regardless, but instead of deallocating the database connection immediately, it marks the database connection as an unusable &quot;zombie&quot; and makes arrangements to automatically deallocate the database connection after all prepared statements are finalized, all BLOB handles are closed, and all backups have finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6acc0ba610f36525f417357719583f041f6f89df" translate="yes" xml:space="preserve">
          <source>Identify all methods for important objects in the interface documentation. (&lt;a href=&quot;c3ref/context&quot;&gt;example&lt;/a&gt;)</source>
          <target state="translated">在接口文档中标识重要对象的所有方法。（&lt;a href=&quot;c3ref/context&quot;&gt;示例&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="b22904746b6da6e6da1cdf65a007a3a92ddeb189" translate="yes" xml:space="preserve">
          <source>IdxDelete</source>
          <target state="translated">IdxDelete</target>
        </trans-unit>
        <trans-unit id="366f895979adef772b50f0a751ee770dc166bab5" translate="yes" xml:space="preserve">
          <source>IdxGE</source>
          <target state="translated">IdxGE</target>
        </trans-unit>
        <trans-unit id="267d8b7b66c2e63c7420b46c7edd1ef118e13442" translate="yes" xml:space="preserve">
          <source>IdxGT</source>
          <target state="translated">IdxGT</target>
        </trans-unit>
        <trans-unit id="bdc0a8ea07737acbd00822ec9e49840776244c14" translate="yes" xml:space="preserve">
          <source>IdxInsert</source>
          <target state="translated">IdxInsert</target>
        </trans-unit>
        <trans-unit id="ba9bc003fbf28927e55ed674e6312a7b981c1435" translate="yes" xml:space="preserve">
          <source>IdxLE</source>
          <target state="translated">IdxLE</target>
        </trans-unit>
        <trans-unit id="11ede54300baae62726a3150e6c2f825098c4577" translate="yes" xml:space="preserve">
          <source>IdxLT</source>
          <target state="translated">IdxLT</target>
        </trans-unit>
        <trans-unit id="c82f35a450e8e6ba85d6a5ba639866e8424ba8d9" translate="yes" xml:space="preserve">
          <source>IdxRowid</source>
          <target state="translated">IdxRowid</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="7194c23292e4ec0e7bfbbaa15bc21cc90107f2f5" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object V was initialized using &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_pointer(S,I,P,X,D)&lt;/a&gt; or &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_pointer(C,P,X,D)&lt;/a&gt; and if X and Y are strings that compare equal according to strcmp(X,Y), then sqlite3_value_pointer(V,Y) will return the pointer P. Otherwise, sqlite3_value_pointer(V,Y) returns a NULL. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">如果&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;对象V是使用&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_pointer（S，I，P，X，D）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_pointer（C，P，X，D）&lt;/a&gt;初始化的，并且X和Y是根据strcmp（X，Y）比较相等的字符串，则sqlite3_value_pointer（V，Y）将返回指针P。否则，sqlite3_value_pointer（V，Y）返回NULL。 sqlite3_bind_pointer（）例程是为SQLite 3.20.0添加的&lt;a href=&quot;bindptr&quot;&gt;指针传递接口的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="6f26b5b5b34df807b99862702ef8a28042e009ca" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../uri&quot;&gt;URI filename&lt;/a&gt; interpretation is enabled, and the filename argument begins with &quot;file:&quot;, then the filename is interpreted as a URI. URI filename interpretation is enabled if the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag is set in the third argument to sqlite3_open_v2(), or if it has been enabled globally using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; option with the &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; method or by the &lt;a href=&quot;../compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; compile-time option. URI filename interpretation is turned off by default, but future releases of SQLite might enable URI filename interpretation by default. See &quot;&lt;a href=&quot;../uri&quot;&gt;URI filenames&lt;/a&gt;&quot; for additional information.</source>
          <target state="translated">如果启用了&lt;a href=&quot;../uri&quot;&gt;URI文件名&lt;/a&gt;解释，并且filename参数以&amp;ldquo; file：&amp;rdquo;开头，则文件名将解释为URI。如果在sqlite3_open_v2（）的第三个参数中设置了&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;标志，或者已使用带有&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;方法的&lt;a href=&quot;c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;选项或通过&lt;a href=&quot;../compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt;编译时选项全局启用了URI文件名解释，则启用URI文件名解释。 URI文件名解释默认情况下处于关闭状态，但是SQLite的未来版本可能默认情况下启用URI文件名解释。有关更多信息，请参见&amp;ldquo; &lt;a href=&quot;../uri&quot;&gt;URI文件名&lt;/a&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="05071756ec11a7890791b184fe1e16795132ff77" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; are &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;enabled&lt;/a&gt; and a column with a &lt;a href=&quot;syntax/foreign-key-clause&quot;&gt;REFERENCES clause&lt;/a&gt; is added, the column must have a default value of NULL.</source>
          <target state="translated">如果&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;启用&lt;/a&gt;了&lt;a href=&quot;foreignkeys&quot;&gt;外键约束&lt;/a&gt;，并且添加了带有&lt;a href=&quot;syntax/foreign-key-clause&quot;&gt;REFERENCES子句&lt;/a&gt;的列，则该列的默认值必须为NULL。</target>
        </trans-unit>
        <trans-unit id="4f1ff78b03ab38bd9d7bc0c0b70bf71a047d9c7f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; are enabled, a DROP TABLE command performs an implicit &lt;a href=&quot;lang_delete&quot;&gt;DELETE FROM&lt;/a&gt; command before removing the table from the database schema. Any triggers attached to the table are dropped from the database schema before the implicit DELETE FROM is executed, so this cannot cause any triggers to fire. By contrast, an implicit DELETE FROM does cause any configured &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; to take place. If the implicit DELETE FROM executed as part of a DROP TABLE command violates any immediate foreign key constraints, an error is returned and the table is not dropped. If the implicit DELETE FROM causes any deferred foreign key constraints to be violated, and the violations still exist when the transaction is committed, an error is returned at the time of commit.</source>
          <target state="translated">如果启用了&lt;a href=&quot;foreignkeys&quot;&gt;外键约束，&lt;/a&gt;则DROP TABLE命令会在从数据库模式中删除表之前执行隐式的&lt;a href=&quot;lang_delete&quot;&gt;DELETE FROM&lt;/a&gt;命令。在执行隐式DELETE FROM之前，将从数据库架构中删除任何附加到表的触发器，因此这不会导致触发任何触发器。相比之下，隐式DELETE FROM确实会导致任何已配置的&lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;外键动作&lt;/a&gt;发生。如果作为DROP TABLE命令的一部分执行的隐式DELETE FROM违反任何立即外键约束，则将返回错误，并且不会删除该表。如果隐式DELETE FROM导致违反了任何延迟的外键约束，并且在提交事务时仍然存在冲突，则在提交时返回错误。</target>
        </trans-unit>
        <trans-unit id="5f1e27999e2bb2ba42de86bd45d31998c0603f29" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt; is set to OFF (thus disabling the rollback journal file) then the behavior of the ROLLBACK command is undefined.</source>
          <target state="translated">如果&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt;设置为OFF（从而禁用回滚日志文件），则ROLLBACK命令的行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="ff29cd60491f93076673fb75bedc0744960c9309" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;EXCLUSIVE locking mode&lt;/a&gt; is set prior to the first WAL-mode database access, then SQLite never attempts to call any of the shared-memory methods and hence no shared-memory wal-index is ever created. In that case, the database connection remains in EXCLUSIVE mode as long as the journal mode is WAL; attempts to change the locking mode using &quot;&lt;code&gt;PRAGMA locking_mode=NORMAL;&lt;/code&gt;&quot; are no-ops. The only way to change out of EXCLUSIVE locking mode is to first change out of WAL journal mode.</source>
          <target state="translated">如果在第一次WAL模式数据库访问之前设置了&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;EXCLUSIVE锁定模式&lt;/a&gt;，则SQLite绝不会尝试调用任何共享内存方法，因此将永远不会创建共享内存wal-index。在这种情况下，只要日志模式为WAL，数据库连接就保持为EXCLUSIVE模式。尝试使用&amp;ldquo; &lt;code&gt;PRAGMA locking_mode=NORMAL;&lt;/code&gt; &amp;rdquo; 更改锁定模式是无操作。退出EXCLUSIVE锁定模式的唯一方法是首先退出WAL日志模式。</target>
        </trans-unit>
        <trans-unit id="53ecc95d367e022d4f668ded862caf4b37a61a3f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; interpretation is enabled, and the filename argument begins with &quot;file:&quot;, then the filename is interpreted as a URI. URI filename interpretation is enabled if the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag is set in the third argument to sqlite3_open_v2(), or if it has been enabled globally using the &lt;a href=&quot;#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; option with the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; method or by the &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; compile-time option. URI filename interpretation is turned off by default, but future releases of SQLite might enable URI filename interpretation by default. See &quot;&lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt;&quot; for additional information.</source>
          <target state="translated">如果启用了&lt;a href=&quot;uri&quot;&gt;URI文件名&lt;/a&gt;解释，并且filename参数以&amp;ldquo; file：&amp;rdquo;开头，则文件名将解释为URI。如果在sqlite3_open_v2（）的第三个参数中设置了&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;标志，或者已使用带有&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;方法的&lt;a href=&quot;#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;选项或通过&lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt;编译时选项全局启用了URI文件名解释，则启用URI文件名解释。 URI文件名解释默认情况下处于关闭状态，但是SQLite的未来版本可能默认情况下启用URI文件名解释。有关更多信息，请参见&amp;ldquo; &lt;a href=&quot;uri&quot;&gt;URI文件名&lt;/a&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0b1cbecea1bfc84769a23d468c11c6578d2f04c8" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object V was initialized using &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_pointer(S,I,P,X,D)&lt;/a&gt; or &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_pointer(C,P,X,D)&lt;/a&gt; and if X and Y are strings that compare equal according to strcmp(X,Y), then sqlite3_value_pointer(V,Y) will return the pointer P. Otherwise, sqlite3_value_pointer(V,Y) returns a NULL. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">如果&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;对象V是使用&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_pointer（S，I，P，X，D）&lt;/a&gt;或&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_pointer（C，P，X，D）&lt;/a&gt;初始化的，并且X和Y是根据strcmp（X，Y）比较相等的字符串，则sqlite3_value_pointer（V，Y）将返回指针P。否则，sqlite3_value_pointer（V，Y）返回NULL。 sqlite3_bind_pointer（）例程是为SQLite 3.20.0添加的&lt;a href=&quot;../bindptr&quot;&gt;指针传递接口的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="efa51497a7f80ea6cb0e82aee000934c754a4257" translate="yes" xml:space="preserve">
          <source>If A&amp;lt;B THEN B&amp;gt;A.</source>
          <target state="translated">如果A &amp;lt;B然后B&amp;gt; A。</target>
        </trans-unit>
        <trans-unit id="af85ab5198e03592c9a1e93f75055ff7f7b4d432" translate="yes" xml:space="preserve">
          <source>If A&amp;lt;B and B&amp;lt;C then A&amp;lt;C.</source>
          <target state="translated">如果A &amp;lt;B且B &amp;lt;C，则A &amp;lt;C。</target>
        </trans-unit>
        <trans-unit id="ee7bb0a19c51474ba2d6ea010cd538d977b0b7a6" translate="yes" xml:space="preserve">
          <source>If A==B and B==C then A==C.</source>
          <target state="translated">如果A==B,B==C,那么A==C。</target>
        </trans-unit>
        <trans-unit id="ad62f244096def890ab26a681e8f0120126f5af5" translate="yes" xml:space="preserve">
          <source>If A==B then B==A.</source>
          <target state="translated">如果A==B,那么B==A。</target>
        </trans-unit>
        <trans-unit id="215c914a1a9a516e367b5ac91682005ac659922c" translate="yes" xml:space="preserve">
          <source>If AUTOVACUUM is enabled then it is possible that another root page might be moved into the newly deleted root page in order to keep all root pages contiguous at the beginning of the database. The former value of the root page that moved - its value before the move occurred - is stored in register P2. If no page movement was required (because the table being dropped was already the last one in the database) then a zero is stored in register P2. If AUTOVACUUM is disabled then a zero is stored in register P2.</source>
          <target state="translated">如果启用了AUTOVACUUM,那么就有可能将另一个根页移动到新删除的根页中,以便在数据库开始时保持所有根页的连续。移动的根页的前值--移动发生前的值--存储在寄存器P2中。如果不需要移动页面(因为被删除的表已经是数据库中的最后一个表),那么在寄存器P2中存储一个零。如果AUTOVACUUM被禁用,那么在寄存器P2中存储一个零。</target>
        </trans-unit>
        <trans-unit id="ed950ba22e4eb6cfb3232df6ec7b67b59a4df463" translate="yes" xml:space="preserve">
          <source>If CHANGESET_REPLACE is returned by an SQLITE_CHANGESET_CONFLICT conflict handler, then the conflicting row is removed from the database and a second attempt to apply the change is made. If this second attempt fails, the original row is restored to the database before continuing.</source>
          <target state="translated">如果CHANGESET_REPLACE被SQLITE_CHANGESET_CONFLICT冲突处理程序返回,那么冲突的记录将被从数据库中删除,并进行第二次尝试应用更改。如果第二次尝试失败,那么在继续应用之前,会将原来的记录恢复到数据库中。</target>
        </trans-unit>
        <trans-unit id="30467096b4dd78c0d45cf667e992ae71e7009c64" translate="yes" xml:space="preserve">
          <source>If CHANGESET_REPLACE is returned by an SQLITE_CHANGESET_DATA conflict handler, then the conflicting row is either updated or deleted, depending on the type of change.</source>
          <target state="translated">如果CHANGESET_REPLACE被SQLITE_CHANGESET_DATA冲突处理程序返回,那么根据变化的类型,冲突的记录将被更新或删除。</target>
        </trans-unit>
        <trans-unit id="1a6c0fd79d5064239e68ae7d0df720319dab8e2b" translate="yes" xml:space="preserve">
          <source>If F is a NULL pointer, then sqlite3_uri_parameter(F,P) returns NULL and sqlite3_uri_boolean(F,P,B) returns B. If F is not a NULL pointer and is not a database file pathname pointer that SQLite passed into the xOpen VFS method, then the behavior of this routine is undefined and probably undesirable.</source>
          <target state="translated">如果F是一个NULL指针,那么sqlite3_uri_parameter(F,P)返回NULL,sqlite3_uri_boolean(F,P,B)返回B.如果F不是一个NULL指针,也不是SQLite传递到xOpen VFS方法中的数据库文件路径名指针,那么这个例程的行为是没有定义的,可能是不可取的。</target>
        </trans-unit>
        <trans-unit id="7f60624c5c0f9adef9d93c9ed8179bc298264376" translate="yes" xml:space="preserve">
          <source>If F is a NULL pointer, then sqlite3_uri_parameter(F,P) returns NULL and sqlite3_uri_boolean(F,P,B) returns B. If F is not a NULL pointer and is not a database file pathname pointer that the SQLite core passed into the xOpen VFS method, then the behavior of this routine is undefined and probably undesirable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4646f7a7f8236532256725ec4112b997f511c7d6" translate="yes" xml:space="preserve">
          <source>If F is a suitable filename (as described in the previous paragraph) and if P is the name of the query parameter, then sqlite3_uri_parameter(F,P) returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F. If P is a query parameter of F and it has no explicit value, then sqlite3_uri_parameter(F,P) returns a pointer to an empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9276605b0b0a889bb4c7aa5fcec85c6fc6240625" translate="yes" xml:space="preserve">
          <source>If F is the database filename pointer passed into the xOpen() method of a VFS implementation when the flags parameter to xOpen() has one or more of the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; or &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_MAIN_DB&lt;/a&gt; bits set and P is the name of the query parameter, then sqlite3_uri_parameter(F,P) returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F. If P is a query parameter of F has no explicit value, then sqlite3_uri_parameter(F,P) returns a pointer to an empty string.</source>
          <target state="translated">如果F是在xOpen（）的flags参数设置了一个或多个&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;或&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_MAIN_DB&lt;/a&gt;位且P是查询参数的名称时传递给VFS实现的xOpen（）方法的数据库文件名指针，则P为查询参数的名称，则sqlite3_uri_parameter（ F，P）返回P参数的值（如果存在）或NULL指针（如果P没有作为F的查询参数出现）。如果P是F的查询参数没有显式值，则sqlite3_uri_parameter（F，P）返回一个指向空字符串的指针。</target>
        </trans-unit>
        <trans-unit id="8ba138ee3e59443a69735dbcd87f0f8269dd9564" translate="yes" xml:space="preserve">
          <source>If F is the database filename pointer passed into the xOpen() method of a VFS implementation when the flags parameter to xOpen() has one or more of the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; or &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_MAIN_DB&lt;/a&gt; bits set and P is the name of the query parameter, then sqlite3_uri_parameter(F,P) returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F. If P is a query parameter of F has no explicit value, then sqlite3_uri_parameter(F,P) returns a pointer to an empty string.</source>
          <target state="translated">如果F是在xOpen（）的flags参数设置了一个或多个&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;或&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_MAIN_DB&lt;/a&gt;位且P是查询参数的名称时传递给VFS实现的xOpen（）方法的数据库文件名指针，则P为查询参数的名称，则sqlite3_uri_parameter（ F，P）返回P参数的值（如果存在）或NULL指针（如果P没有作为F的查询参数出现）。如果P是F的查询参数没有显式值，则sqlite3_uri_parameter（F，P）返回一个指向空字符串的指针。</target>
        </trans-unit>
        <trans-unit id="96db4246a2920821a0342bd0eb3ee7ac297124f4" translate="yes" xml:space="preserve">
          <source>If F is the name of an sqlite database file, journal file, or WAL file passed by the SQLite core into the VFS, or if F is a database filename obtained from &lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then sqlite3_filename_journal(F) returns the name of the corresponding rollback journal file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5222d2f3de406b301b9d249247c656c5b47394f" translate="yes" xml:space="preserve">
          <source>If F is the name of an sqlite database file, journal file, or WAL file passed by the SQLite core into the VFS, then sqlite3_filename_database(F) returns the name of the corresponding database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbbd8f58db83b28c968f4a1fd0df5ad504ea9fa0" translate="yes" xml:space="preserve">
          <source>If F is the name of an sqlite database file, journal file, or WAL file that was passed by the SQLite core into the VFS, or if F is a database filename obtained from &lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then sqlite3_filename_wal(F) returns the name of the corresponding WAL file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="298246b211caead4a1410b71d74279a5d314bec4" translate="yes" xml:space="preserve">
          <source>If FILE is a ZIP archive rather than an SQLite Archive, the &quot;.archive&quot; command and the &quot;-A&quot; command-line option still work. This is accomplished using of the &lt;a href=&quot;zipfile&quot;&gt;zipfile&lt;/a&gt; extension. Hence, the following commands are roughly equivalent, differing only in output formatting:</source>
          <target state="translated">如果FILE是ZIP存档而不是SQLite存档，则&amp;ldquo; .archive&amp;rdquo;命令和&amp;ldquo; -A&amp;rdquo;命令行选项仍然有效。这是使用&lt;a href=&quot;zipfile&quot;&gt;zipfile&lt;/a&gt;扩展名完成的。因此，以下命令大致等效，仅在输出格式上有所不同：</target>
        </trans-unit>
        <trans-unit id="d860543f88997bfbcee9b4b76e89b05bba6e3e47" translate="yes" xml:space="preserve">
          <source>If M is -1 in the initial journal header, then the number of page records that follow is computed by computing how many page records will fit in the available space of the remainder of the journal file.</source>
          <target state="translated">如果初始日记头中的M为-1,那么接下来的页记录数是通过计算日记文件剩余的可用空间能容纳多少页记录来计算的。</target>
        </trans-unit>
        <trans-unit id="9d3a57a4870ed12272e250deed6ea841c224df1b" translate="yes" xml:space="preserve">
          <source>If NORMAL locking mode is in effect for the first WAL-mode database access, then the shared-memory wal-index is created. This means that the underlying VFS must support the &quot;version 2&quot; shared-memory. If the VFS does not support shared-memory methods, then the attempt to open a database that is already in WAL mode, or the attempt convert a database into WAL mode, will fail. As long as exactly one connection is using a shared-memory wal-index, the locking mode can be changed freely between NORMAL and EXCLUSIVE. It is only when the shared-memory wal-index is omitted, when the locking mode is EXCLUSIVE prior to the first WAL-mode database access, that the locking mode is stuck in EXCLUSIVE.</source>
          <target state="translated">如果第一次WAL模式的数据库访问采用NORMAL锁定模式,那么就会创建共享内存wal-index,这意味着底层VFS必须支持 &quot;版本2 &quot;共享内存。这意味着底层VFS必须支持 &quot;版本2 &quot;的共享内存。如果VFS不支持共享内存方法,那么尝试打开一个已经处于WAL模式的数据库,或者尝试将一个数据库转换为WAL模式,都会失败。只要正好有一个连接在使用共享内存wal-index,锁定模式就可以在normal和exclusive之间自由切换。只有当省略了共享内存wal-index,在第一次WAL模式数据库访问之前锁定模式为EXCLUSIVE时,锁定模式才会停留在EXCLUSIVE。</target>
        </trans-unit>
        <trans-unit id="084a98d24eb789b16e0f410999491d6ca6f68655" translate="yes" xml:space="preserve">
          <source>If NULL is inserted into the mode column, then the mode of the new archive entry is automatically set to either 33188 (-rw-r--r--) or 16877 (drwxr-xr-x), depending on whether or not the values specified for columns &quot;sz&quot;, &quot;data&quot; and &quot;rawdata&quot; indicate that the new entry is a directory.</source>
          <target state="translated">如果在模式列中插入 NULL,那么新归档条目的模式将自动设置为 33188 (-rw-r--r--)或 16877 (drwxr-xr-x),这取决于为 &quot;sz&quot;、&quot;data &quot;和 &quot;rawdata &quot;列指定的值是否表明新条目是一个目录。</target>
        </trans-unit>
        <trans-unit id="4101f8cb88698edd15d7c951de1289b2d8eaa71c" translate="yes" xml:space="preserve">
          <source>If NULL is inserted into the mtime column, then the timestamp of the new entry is set to the current time. Otherwise, the specified value is interpreted as an integer and used as is.</source>
          <target state="translated">如果在mtime列中插入NULL,那么新条目的时间戳将被设置为当前时间。否则,指定的值被解释为整数,并按原样使用。</target>
        </trans-unit>
        <trans-unit id="43806989f629698fba47d7f7a7bc8a167120b2e8" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_area(P) returns the area enclosed by that polygon. If P is not a polygon, geopoly_area(P) returns NULL.</source>
          <target state="translated">如果P是一个多边形,那么geopoly_area(P)返回该多边形所包围的面积。如果P不是多边形,geopoly_area(P)返回NULL。</target>
        </trans-unit>
        <trans-unit id="7923fadf3f55cd9b6d47a16ad18e97575f464043" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_bbox(P) returns a new polygon that is the smallest (axis-aligned) rectangle completely enclosing P. If P is not a polygon, geopoly_bbox(P) returns NULL.</source>
          <target state="translated">如果 P 是一个多边形,那么 geopoly_bbox(P)返回一个新的多边形,这个多边形是完全包围 P 的最小(轴对齐)的矩形。</target>
        </trans-unit>
        <trans-unit id="231cf86fd88561789cf32053e3b5a58ac30a1c90" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_blob(P) returns the binary encoding of that polygon as a BLOB. If P is not a polygon, geopoly_blob(P) returns NULL.</source>
          <target state="translated">如果P是一个多边形,那么geopoly_blob(P)返回该多边形的二进制编码为BLOB。如果P不是多边形,geopoly_blob(P)返回NULL。</target>
        </trans-unit>
        <trans-unit id="85466629c4fd74bf6816a1cb264ff5557384a47f" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_contains_point(P,X,Y) returns a non-zero integer if and only if the coordinate X,Y is inside or on the boundary of the polygon P. If P is not a polygon, geopoly_contains_point(P,X,Y) returns NULL.</source>
          <target state="translated">如果P是一个多边形,那么geopoly_contains_point(P,X,Y)返回一个非零整数,前提是坐标X,Y在多边形P的内部或边界上。如果P不是多边形,geopoly_contains_point(P,X,Y)返回NULL。</target>
        </trans-unit>
        <trans-unit id="01d01cedd541548c033da5a76ae2b943d566e364" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_json(P) returns the GeoJSON representation of that polygon as a TEXT string. If P is not a polygon, geopoly_json(P) returns NULL.</source>
          <target state="translated">如果P是一个多边形,那么geopoly_json(P)以TEXT字符串的形式返回该多边形的GeoJSON表示。如果P不是多边形,geopoly_json(P)返回NULL。</target>
        </trans-unit>
        <trans-unit id="4d96f5fac84b02e3eed71829015c2301166a1102" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_svg(P,...) returns a text string which is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;Scalable Vector Graphics (SVG)&lt;/a&gt; representation of that polygon. If there is more one argument, then second and subsequent arguments are added as attributes to each SVG glyph. For example:</source>
          <target state="translated">如果P是多边形，则geopoly_svg（P，...）返回一个文本字符串，该字符串是该多边形的&lt;a href=&quot;https://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;可缩放矢量图形（SVG）&lt;/a&gt;表示形式。如果有多个自变量，则将第二个和后续自变量作为属性添加到每个SVG字形。例如：</target>
        </trans-unit>
        <trans-unit id="8bf89c8791c7886430f52d199af4522be0892c2c" translate="yes" xml:space="preserve">
          <source>If P is not a polygon, geopoly_svg(P,...) returns NULL.</source>
          <target state="translated">如果P不是多边形,geopoly_svg(P,...)返回NULL。</target>
        </trans-unit>
        <trans-unit id="8d6c1d000f406140de377a0a6166c3f4f4ee6ecf" translate="yes" xml:space="preserve">
          <source>If P&amp;gt;X and K&amp;gt;X then the first M bytes of P are stored on the btree page and the remaining P-M bytes are stored on overflow pages.</source>
          <target state="translated">如果P&amp;gt; X和K&amp;gt; X，则P的前M个字节存储在btree页上，其余PM个字节存储在溢出页上。</target>
        </trans-unit>
        <trans-unit id="40c35ab59089c6d8a3b822955c4be859755a9e2b" translate="yes" xml:space="preserve">
          <source>If P&amp;gt;X and K&amp;lt;=X then the first K bytes of P are stored on the btree page and the remaining P-K bytes are stored on overflow pages.</source>
          <target state="translated">如果P&amp;gt; X并且K &amp;lt;= X，则P的前K个字节存储在btree页上，其余PK字节存储在溢出页上。</target>
        </trans-unit>
        <trans-unit id="fa33ffa92f81891eff9dffa21d7e8d38e3faa786" translate="yes" xml:space="preserve">
          <source>If P&amp;lt;=X then all P bytes of payload are stored directly on the btree page without overflow.</source>
          <target state="translated">如果P &amp;lt;= X，则所有有效载荷的P个字节均直接存储在btree页上，而不会发生溢出。</target>
        </trans-unit>
        <trans-unit id="a69350651a4faef3f95c007babd7352f8f77d85e" translate="yes" xml:space="preserve">
          <source>If P1 and P2 are both polygons, then the geopoly_overlap(P1,P2) function returns a non-zero integer if there is any overlap between P1 and P2, or it returns zero if P1 and P2 completely disjoint. If either P1 or P2 is not a polygon, this routine returns NULL.</source>
          <target state="translated">如果P1和P2都是多边形,那么geopoly_overlap(P1,P2)函数在P1和P2之间有任何重叠时返回一个非零的整数,或者在P1和P2完全不相交时返回零。如果P1或P2不是多边形,这个例程返回NULL。</target>
        </trans-unit>
        <trans-unit id="3222b98590b837273b0d4239ca32f6bb0d30ac83" translate="yes" xml:space="preserve">
          <source>If P1 and P2 are both polygons, then the geopoly_within(P1,P2) function returns a non-zero integer if P1 is completely contained within P2, or it returns zero if any part of P1 is outside of P2. If P1 and P2 are the same polygon, this routine returns non-zero. If either P1 or P2 is not a polygon, this routine returns NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd9f5db9ef38463d2501fa9dc6b70e3f4750a4f2" translate="yes" xml:space="preserve">
          <source>If P1 and P2 are both polygons, then the geopoly_within(P1,P2) function returns a non-zero integer if P2 is completely contained within P1, or it returns zero if any part of P2 is outside of P1. If P1 and P2 are the same polygon, this routine returns non-zero. If either P1 or P2 is not a polygon, this routine returns NULL.</source>
          <target state="translated">如果P1和P2都是多边形,那么如果P2完全包含在P1内,geopoly_within(P1,P2)函数返回一个非零整数,如果P2的任何部分在P1之外,则返回零。如果P1和P2是同一个多边形,这个例程返回非零。如果P1或P2不是一个多边形,这个例程返回NULL。</target>
        </trans-unit>
        <trans-unit id="4157b5ffd90247cfe9008c1ae67666efa84d2bdb" translate="yes" xml:space="preserve">
          <source>If P1 is 0, then all SQL statements become expired. If P1 is non-zero, then only the currently executing statement is expired.</source>
          <target state="translated">如果P1为0,那么所有的SQL语句都会过期。如果P1为非零,那么只有当前执行的语句过期。</target>
        </trans-unit>
        <trans-unit id="7196e8103cc1b57f49e64f9cffafd04bf56cea94" translate="yes" xml:space="preserve">
          <source>If P1 is non-zero, then the jump is taken if the database constraint-counter is zero (the one that counts deferred constraint violations). If P1 is zero, the jump is taken if the statement constraint-counter is zero (immediate foreign key constraint violations).</source>
          <target state="translated">如果P1为非零,那么如果数据库约束计数器为零(计算延迟约束违反的那个),就会进行跳转。如果P1为零,那么如果语句约束计数器为零(即时外键约束违反),则进行跳转。</target>
        </trans-unit>
        <trans-unit id="e76da0aa98d442426a710c17ffdd5c83f500e5de" translate="yes" xml:space="preserve">
          <source>If P1 is not zero, then it is a register that a subsequent min() or max() aggregate will set to 1 if the current row is not the minimum or maximum. The P1 register is initialized to 0 by this instruction.</source>
          <target state="translated">如果P1不为0,那么它是一个寄存器,如果当前行不是最小行或最大行,那么后续的min()或max()集合将设置为1。该指令将P1寄存器初始化为0。</target>
        </trans-unit>
        <trans-unit id="12e05de4c2b1f6e3dffb8fed2e435034a63c1753" translate="yes" xml:space="preserve">
          <source>If P2 is 0, then SQL statements are expired immediately. If P2 is 1, then running SQL statements are allowed to continue to run to completion. The P2==1 case occurs when a CREATE INDEX or similar schema change happens that might help the statement run faster but which does not affect the correctness of operation.</source>
          <target state="translated">如果P2为0,则SQL语句立即过期。如果P2为1,则允许正在运行的SQL语句继续运行至完成。P2==1的情况发生在发生CREATE INDEX或类似的模式变化时,这种变化可能会帮助语句运行得更快,但并不影响操作的正确性。</target>
        </trans-unit>
        <trans-unit id="b95c82eece8cdb232cd3c969e9f714560a3483ed" translate="yes" xml:space="preserve">
          <source>If P2 is not zero, jump to instruction P2.</source>
          <target state="translated">如果P2不为零,则跳转到指令P2。</target>
        </trans-unit>
        <trans-unit id="624ae34f34a46b97a6ede8c6928e2854d808cc50" translate="yes" xml:space="preserve">
          <source>If P2 is not zero, then it is a register holding a string which is the file into which the result of vacuum should be written. When P2 is zero, the vacuum overwrites the original database.</source>
          <target state="translated">如果P2不为零,那么它是一个持有字符串的寄存器,这个字符串是真空结果应该写入的文件。当P2为零时,真空会覆盖原来的数据库。</target>
        </trans-unit>
        <trans-unit id="7f685a86b5e506b77efdf72c9ec8070a39f8b40d" translate="yes" xml:space="preserve">
          <source>If P2 is the SCHEMA_VERSION cookie (cookie number 1) then the internal schema version is set to P3-P5. The &quot;PRAGMA schema_version=N&quot; statement has P5 set to 1, so that the internal schema version will be different from the database schema version, resulting in a schema reset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4101c4124c3fe6e483990efc85814b11a364af14" translate="yes" xml:space="preserve">
          <source>If P2!=0 then the coroutine implementation immediately follows this opcode. So jump over the coroutine implementation to address P2.</source>
          <target state="translated">如果P2!=0,那么coroutine实现紧接着这个操作码。所以跳过coroutine实现来寻址P2。</target>
        </trans-unit>
        <trans-unit id="95acd6cd81e68312a7b3f200adb71394407e2187" translate="yes" xml:space="preserve">
          <source>If P2==1 then no insert is performed. argv[0] is the rowid of a row to delete.</source>
          <target state="translated">如果P2==1,则不执行插入操作。 argv[0]是要删除的记录的rowid。</target>
        </trans-unit>
        <trans-unit id="4b3305a3179f27393cd2b3c6dff28468fd2e27f2" translate="yes" xml:space="preserve">
          <source>If P3 is not zero and the content of register P3 is equal to P5, then the datatype of the register P2 is converted to BLOB. The content is the same sequence of bytes, it is merely interpreted as a BLOB instead of a string, as if it had been CAST. In other words:</source>
          <target state="translated">如果P3不为零,并且寄存器P3的内容等于P5,那么寄存器P2的数据类型就被转换为BLOB。内容是相同的字节序列,只是被解释为BLOB而不是字符串,就像被CAST一样。换句话说。</target>
        </trans-unit>
        <trans-unit id="7b12a88585bcaf8799451da77eaddd8eae80e136" translate="yes" xml:space="preserve">
          <source>If P3 is not zero, then it is an address to jump to if an SQLITE_CORRUPT error is encountered.</source>
          <target state="translated">如果P3不为零,那么它是遇到SQLITE_CORRUPT错误时跳转的地址。</target>
        </trans-unit>
        <trans-unit id="c8b8a297f15c969bf51cec7bd085ee38d68f8af2" translate="yes" xml:space="preserve">
          <source>If P3!=0 then the content of the P2 register is unsuitable for use in OP_Result and any OP_Result will invalidate the P2 register content. The P2 register content is invalidated by opcodes like &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt; or by any use of another cursor pointing to the same table.</source>
          <target state="translated">如果P3！= 0，则P2寄存器的内容不适合在OP_Result中使用，任何OP_Result都会使P2寄存器的内容无效。P2寄存器的内容会被&lt;a href=&quot;opcode#Function&quot;&gt;功能&lt;/a&gt;（如Function）之类的操作码或指向该表的另一个游标的任何使用所无效。</target>
        </trans-unit>
        <trans-unit id="f0e377e900f9f81e14b13484040277f239153040" translate="yes" xml:space="preserve">
          <source>If P3!=0 then this opcode is allowed to make an ephemeral pointer into the database page. That means that the content of the output register will be invalidated as soon as the cursor moves - including moves caused by other cursors that &quot;save&quot; the current cursors position in order that they can write to the same table. If P3==0 then a copy of the data is made into memory. P3!=0 is faster, but P3==0 is safer.</source>
          <target state="translated">如果P3!=0,那么这个操作码被允许做一个短暂的指针进入数据库页面。这意味着一旦光标移动,输出寄存器的内容就会失效--包括其他光标引起的移动,这些光标 &quot;保存 &quot;了当前光标的位置,以便它们能够写入同一个表。如果P3==0,那么就会将数据复制到内存中。P3!=0更快,但P3==0更安全。</target>
        </trans-unit>
        <trans-unit id="261dff5d4c60a753fca80ceb7a30b1ccde835d53" translate="yes" xml:space="preserve">
          <source>If P3&amp;gt;0 then P3 is a register in the root frame of this VDBE that holds the largest previously generated record number. No new record numbers are allowed to be less than this value. When this value reaches its maximum, an SQLITE_FULL error is generated. The P3 register is updated with the ' generated record number. This P3 mechanism is used to help implement the AUTOINCREMENT feature.</source>
          <target state="translated">如果P3&amp;gt; 0，则P3是此VDBE根帧中的一个寄存器，该寄存器保存了以前最大的记录编号。不允许新的记录号小于该值。当该值达到最大值时，将生成SQLITE_FULL错误。用生成的记录号更新P3寄存器。此P3机制用于帮助实现AUTOINCREMENT功能。</target>
        </trans-unit>
        <trans-unit id="b537aafa079e151774c7dbac498d69a9800ce496" translate="yes" xml:space="preserve">
          <source>If P3==0 and P4==0 then r[P2] := r[P1] IS TRUE</source>
          <target state="translated">如果P3==0,P4==0,则r[P2]:=r[P1]IS TRUE。</target>
        </trans-unit>
        <trans-unit id="4abb01d048e9054de1718b2c97d7bca8f72ca3fd" translate="yes" xml:space="preserve">
          <source>If P3==0 and P4==1 then r[P2] := r[P1] IS NOT TRUE</source>
          <target state="translated">如果P3==0,P4==1,则r[P2]:=r[P1]IS NOT TRUE。</target>
        </trans-unit>
        <trans-unit id="dffd9f3f7dcda52e1f25f401261075e7728503f3" translate="yes" xml:space="preserve">
          <source>If P3==0, then an exact count is obtained, which involves visiting every btree page of the table. But if P3 is non-zero, an estimate is returned based on the current cursor position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f5592c3dfac53b5b17bcf906b1b3d9b28a160a" translate="yes" xml:space="preserve">
          <source>If P3==1 and P4==0 then r[P2] := r[P1] IS NOT FALSE</source>
          <target state="translated">如果P3==1,P4==0,那么r[P2]:=r[P1]IS NOT FALSE。</target>
        </trans-unit>
        <trans-unit id="ec92d66dd345ec321132b256dce88d1a72413c5f" translate="yes" xml:space="preserve">
          <source>If P3==1 and P4==1 then r[P2] := r[P1] IS FALSE</source>
          <target state="translated">如果P3==1,P4==1,那么r[P2]:=r[P1]IS FALSE。</target>
        </trans-unit>
        <trans-unit id="ec8063043e0a9cad56cc57c55e1e58a5f2b9e719" translate="yes" xml:space="preserve">
          <source>If P4 is NULL then all index fields have the affinity BLOB.</source>
          <target state="translated">如果P4为NULL,那么所有的索引字段都有亲和力BLOB。</target>
        </trans-unit>
        <trans-unit id="0409d4d0ae010acb4eb82b5c67e7d26a4e78a377" translate="yes" xml:space="preserve">
          <source>If P4 is not NULL then it points to a Table object. In this case either the update or pre-update hook, or both, may be invoked. The P1 cursor must have been positioned using &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; prior to invoking this opcode in this case. Specifically, if one is configured, the pre-update hook is invoked if P4 is not NULL. The update-hook is invoked if one is configured, P4 is not NULL, and the OPFLAG_NCHANGE flag is set in P2.</source>
          <target state="translated">如果P4不为NULL，则它指向Table对象。在这种情况下，可以调用更新钩子或更新钩子，或两者都被调用。在这种情况下，在调用此操作码之前，必须已使用&lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt;定位了P1光标。具体来说，如果配置了一个，则如果P4不为NULL，则调用更新前挂钩。如果配置了一个，P4不为NULL，并且在P2中设置了OPFLAG_NCHANGE标志，则调用更新挂钩。</target>
        </trans-unit>
        <trans-unit id="833039fcfc9ba1341a8bac648d6011bebc9ef640" translate="yes" xml:space="preserve">
          <source>If P4 is not null then it is an error message string.</source>
          <target state="translated">如果P4不为空,那么它就是一个错误信息字符串。</target>
        </trans-unit>
        <trans-unit id="323b07c0a29678efca20be714e85be9034012831" translate="yes" xml:space="preserve">
          <source>If P4 is not zero, then it is the number of values in the unpacked key of reg(P2). In that case, P3 is the index of the first register for the unpacked key. The availability of the unpacked key can sometimes be an optimization.</source>
          <target state="translated">如果P4不为零,那么它就是reg(P2)的解包键的值数。在这种情况下,P3是解包键的第一个寄存器的索引。解包键的可用性有时也是一种优化。</target>
        </trans-unit>
        <trans-unit id="7f6b94d7be2c05fd8f0bc6b7de40e344824f8d5b" translate="yes" xml:space="preserve">
          <source>If P4==0 then register P3 holds a blob constructed by &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;. If P4&amp;gt;0 then register P3 is the first of P4 registers that form an unpacked record.</source>
          <target state="translated">如果P4 == 0，则寄存器P3包含由&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;构造的blob。如果P4&amp;gt; 0，则寄存器P3是构成未打包记录的P4寄存器中的第一个。</target>
        </trans-unit>
        <trans-unit id="ea0d786e8193b3191b8e71dcd7cd40efa9daf92e" translate="yes" xml:space="preserve">
          <source>If P5 has the OPFLAG_APPEND bit set, that is a hint to the b-tree layer that this insert is likely to be an append.</source>
          <target state="translated">如果P5设置了OPFLAG_APPEND位,那就是提示b树层,这个插入很可能是一个追加。</target>
        </trans-unit>
        <trans-unit id="b63e95392a3322ead1cda4df48bfef1df78fcfb5" translate="yes" xml:space="preserve">
          <source>If P5 has the OPFLAG_NCHANGE bit set, then the change counter is incremented by this instruction. If the OPFLAG_NCHANGE bit is clear, then the change counter is unchanged.</source>
          <target state="translated">如果P5的OPFLAG_NCHANGE位被设置,那么变化计数器就会被该指令递增。如果OPFLAG_NCHANGE位被清除,那么变化计数器不变。</target>
        </trans-unit>
        <trans-unit id="1ea732c0486f9121ffc851f241dea7753a429516" translate="yes" xml:space="preserve">
          <source>If P5 has the OPFLAG_PERMUTE bit set, then the order of comparison is determined by the most recent &lt;a href=&quot;opcode#Permutation&quot;&gt;Permutation&lt;/a&gt; operator. If the OPFLAG_PERMUTE bit is clear, then register are compared in sequential order.</source>
          <target state="translated">如果P5的OPFLAG_PERMUTE位置1，则比较顺序由最新的&lt;a href=&quot;opcode#Permutation&quot;&gt;置换&lt;/a&gt;运算符确定。如果OPFLAG_PERMUTE位清零，则按顺序比较寄存器。</target>
        </trans-unit>
        <trans-unit id="d566e20d0304652ba9b826870e3331951b73f1a1" translate="yes" xml:space="preserve">
          <source>If P5 is non-zero, then recursive program invocation is enabled.</source>
          <target state="translated">如果P5为非零,则启用递归程序调用。</target>
        </trans-unit>
        <trans-unit id="8cc4989073012226802ebb0b0b0287d0ebbc4c24" translate="yes" xml:space="preserve">
          <source>If P5 is not zero and P4 is NULL, then everything after the &quot;:&quot; is omitted.</source>
          <target state="translated">如果P5不为零,且P4为NULL,则省略&quot;:&quot;后的所有内容。</target>
        </trans-unit>
        <trans-unit id="6140b6bc786ef6328163c583ea74afbbf1b0203f" translate="yes" xml:space="preserve">
          <source>If P5 is not zero, the check is done on the auxiliary database file, not the main database file.</source>
          <target state="translated">如果P5不为零,则对辅助数据库文件进行检查,而不是主数据库文件。</target>
        </trans-unit>
        <trans-unit id="4031180a3fa926570f402abdb205aa9088ecbac2" translate="yes" xml:space="preserve">
          <source>If P5 is not zero, then raise an SQLITE_CORRUPT_INDEX error if no matching index entry is found. This happens when running an UPDATE or DELETE statement and the index entry to be updated or deleted is not found. For some uses of &lt;a href=&quot;opcode#IdxDelete&quot;&gt;IdxDelete&lt;/a&gt; (example: the EXCEPT operator) it does not matter that no matching entry is found. For those cases, P5 is zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f3d5e8ef0f60d316b59356518575a2f176eb4d7" translate="yes" xml:space="preserve">
          <source>If P5 is positive and the jump is taken, then event counter number P5-1 in the prepared statement is incremented.</source>
          <target state="translated">如果P5为正值,并且采取了跳转,那么准备好的语句中的事件计数器号P5-1就会递增。</target>
        </trans-unit>
        <trans-unit id="e77300f272721b16413737d1f5909b28a7b7a6ee" translate="yes" xml:space="preserve">
          <source>If P5 is set, then all released registers have their type set to MEM_Undefined so that any subsequent attempt to read the released register (before it is reinitialized) will generate an assertion fault.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d64a234f707179617701bb23c32b6ab90539344" translate="yes" xml:space="preserve">
          <source>If P5!=0 then this opcode also checks the schema cookie against P3 and the schema generation counter against P4. The cookie changes its value whenever the database schema changes. This operation is used to detect when that the cookie has changed and that the current process needs to reread the schema. If the schema cookie in P3 differs from the schema cookie in the database header or if the schema generation counter in P4 differs from the current generation counter, then an SQLITE_SCHEMA error is raised and execution halts. The sqlite3_step() wrapper function might then reprepare the statement and rerun it from the beginning.</source>
          <target state="translated">如果P5!=0,那么这个操作码也会对照P3检查schema cookie,对照P4检查schema生成计数器。每当数据库模式发生变化时,cookie就会改变其值。这个操作是用来检测什么时候该cookie已经改变,当前进程需要重新读取模式。如果P3中的模式cookie与数据库头中的模式cookie不同,或者P4中的模式生成计数器与当前的生成计数器不同,那么就会引发SQLITE_SCHEMA错误,并停止执行。sqlite3_step()封装函数可能会重新准备语句,并从头开始重新运行。</target>
        </trans-unit>
        <trans-unit id="79b8df381ad1ae2bdf21bac462376aead762296f" translate="yes" xml:space="preserve">
          <source>If RBU is used to update a large BLOB value within a target database, it may be more efficient to store a patch or delta that can be used to modify the existing BLOB instead of an entirely new value within the RBU database. RBU allows deltas to be specified in two ways:</source>
          <target state="translated">如果在目标数据库中使用 RBU 更新一个大的 BLOB 值,那么在 RBU 数据库中存储一个可用于修改现有 BLOB 的补丁或 delta 而不是一个全新的值可能会更有效。RBU允许以两种方式指定delta。</target>
        </trans-unit>
        <trans-unit id="f32404d913415ab312a2d32bca5267050dc55433" translate="yes" xml:space="preserve">
          <source>If SQLITE_DEFAULT_WAL_SYNCHRONOUS differs from SQLITE_DEFAULT_SYNCHRONOUS, and if the application has not modified the synchronous setting for the database file using the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; statement, then the synchronous setting is changed to value defined by SQLITE_DEFAULT_WAL_SYNCHRONOUS when the database connection switches into WAL mode for the first time. If the SQLITE_DEFAULT_WAL_SYNCHRONOUS value is not overridden at compile-time, then it will always be the same as &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt; and so no automatic synchronous setting changes will ever occur.</source>
          <target state="translated">如果SQLITE_DEFAULT_WAL_SYNCHRONOUS与SQLITE_DEFAULT_SYNCHRONOUS不同，并且如果应用程序未使用&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt;语句修改数据库文件的同步设置，则当数据库连接首次切换到WAL模式时，同步设置将更改为SQLITE_DEFAULT_WAL_SYNCHRONOUS定义的值。如果在编译时未覆盖SQLITE_DEFAULT_WAL_SYNCHRONOUS值，则它将始终与&lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt;相同，因此将不会发生自动同步设置更改。</target>
        </trans-unit>
        <trans-unit id="35daf76480440bed2a0456819e4a2256b8e77c1e" translate="yes" xml:space="preserve">
          <source>If SQLITE_NULLEQ is set in P5 then the result of comparison is always either true or false and is never NULL. If both operands are NULL then the result of comparison is true. If either operand is NULL then the result is false. If neither operand is NULL the result is the same as it would be if the SQLITE_NULLEQ flag were omitted from P5.</source>
          <target state="translated">如果在P5中设置了SQLITE_NULLEQ,那么比较的结果总是true或false,永远不会是NULL。如果两个操作数都是NULL,那么比较的结果是true。如果两个操作数都是NULL,那么比较的结果是false。如果两个操作数都不是NULL,那么结果和P5中省略SQLITE_NULLEQ标志的结果是一样的。</target>
        </trans-unit>
        <trans-unit id="b5e1e68a469214facd1d655d6dbff18739ace55a" translate="yes" xml:space="preserve">
          <source>If SQLite discovers that the sqlite_sequence table has any other format, it returns the SQLITE_CORRUPT_SEQUENCE error.</source>
          <target state="translated">如果SQLite发现sqlite_sequence表有任何其他格式,就会返回SQLITE_CORRUPT_SEQUENCE错误。</target>
        </trans-unit>
        <trans-unit id="015569a0e55d69ecf2d3dec3d6ece8f0bde61846" translate="yes" xml:space="preserve">
          <source>If SQLite ever returns SQLITE_MISUSE from any interface, that means that the application is incorrectly coded and needs to be fixed. Do not ship an application that sometimes returns SQLITE_MISUSE from a standard SQLite interface because that application contains potentially serious bugs.</source>
          <target state="translated">如果SQLite曾经从任何接口返回SQLITE_MISUSE,这意味着该应用程序的编码不正确,需要修复。不要发布一个有时从标准SQLite接口返回SQLITE_MISUSE的应用程序,因为该应用程序包含潜在的严重错误。</target>
        </trans-unit>
        <trans-unit id="60b69a270887c8a40e3999f62767f4e29079be3d" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the parser_trace pragma can be used to turn on tracing for the SQL parser used internally by SQLite. This feature is used for debugging SQLite itself.</source>
          <target state="translated">如果已使用&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;编译时选项编译了SQLite ，则可以使用parser_trace编译指示为SQLite内部使用的SQL解析器打开跟踪。此功能用于调试SQLite本身。</target>
        </trans-unit>
        <trans-unit id="3e93855bd0fdb13d2772a4cf88fefeb516093bf0" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the vdbe_addoptrace pragma can be used to cause a complete VDBE opcodes to be displayed as they are created during code generation. This feature is used for debugging SQLite itself. See the &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE documentation&lt;/a&gt; for more information.</source>
          <target state="translated">如果使用&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;编译时选项编译了SQLite ，则可以使用vdbe_addoptrace编译指示在代码生成期间创建完整的VDBE操作码时显示它们。此功能用于调试SQLite本身。有关更多信息，请参见&lt;a href=&quot;vdbe#trace&quot;&gt;VDBE文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed1cfc408ef29e4c5084ed94c91a1453ae1e7d68" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the vdbe_debug pragma is a shorthand for three other debug-only pragmas: vdbe_addoptrace, vdbe_listing, and vdbe_trace. This feature is used for debugging SQLite itself. See the &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE documentation&lt;/a&gt; for more information.</source>
          <target state="translated">如果使用&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;编译时选项编译了SQLite ，则vdbe_debug编译指示是其他三个仅调试编译指示的简写：vdbe_addoptrace，vdbe_listing和vdbe_trace。此功能用于调试SQLite本身。有关更多信息，请参见&lt;a href=&quot;vdbe#trace&quot;&gt;VDBE文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e32eb3dd2a790d29e0b70974d295922571079df" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the vdbe_listing pragma can be used to cause a complete listing of the virtual machine opcodes to appear on standard output as each statement is evaluated. With listing is on, the entire content of a program is printed just prior to beginning execution. The statement executes normally after the listing is printed. This feature is used for debugging SQLite itself. See the &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE documentation&lt;/a&gt; for more information.</source>
          <target state="translated">如果已经使用&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;编译时选项编译了SQLite ，则可以使用vdbe_listing编译指示使虚拟机操作码的完整列表出现在标准输出中，并评估每个语句。启用清单后，程序的全部内容就在开始执行之前被打印出来。列表打印后，该语句正常执行。此功能用于调试SQLite本身。有关更多信息，请参见&lt;a href=&quot;vdbe#trace&quot;&gt;VDBE文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cefc8fedb890f68ef15ff1358f045bdc3b72901b" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the vdbe_trace pragma can be used to cause virtual machine opcodes to be printed on standard output as they are evaluated. This feature is used for debugging SQLite. See the &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE documentation&lt;/a&gt; for more information.</source>
          <target state="translated">如果已使用&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;编译时选项编译了SQLite ，则可以使用vdbe_trace编译指示在评估虚拟机操作码时将其打印在标准输出上。此功能用于调试SQLite。有关更多信息，请参见&lt;a href=&quot;vdbe#trace&quot;&gt;VDBE文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5153e53873f4aff61d1f8d367f68545fed69c0e7" translate="yes" xml:space="preserve">
          <source>If SQLite has not been initialized using &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; prior to invoking sqlite3_complete16() then sqlite3_initialize() is invoked automatically by sqlite3_complete16(). If that initialization fails, then the return value from sqlite3_complete16() will be non-zero regardless of whether or not the input SQL is complete.</source>
          <target state="translated">如果在调用&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_complete16（）&lt;/a&gt;之前未使用sqlite3_initialize（）初始化SQLite，则sqlite3_complete16（）将自动调用sqlite3_initialize（）。如果该初始化失败，则无论输入SQL是否完成，sqlite3_complete16（）的返回值都将为非零。</target>
        </trans-unit>
        <trans-unit id="3c965f677e7c54456f9a69dea9325df1caaec3d9" translate="yes" xml:space="preserve">
          <source>If SQLite has not been initialized using &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; prior to invoking sqlite3_complete16() then sqlite3_initialize() is invoked automatically by sqlite3_complete16(). If that initialization fails, then the return value from sqlite3_complete16() will be non-zero regardless of whether or not the input SQL is complete.</source>
          <target state="translated">如果在调用&lt;a href=&quot;initialize&quot;&gt;sqlite3_complete16（）&lt;/a&gt;之前未使用sqlite3_initialize（）初始化SQLite，则sqlite3_complete16（）将自动调用sqlite3_initialize（）。如果该初始化失败，则无论输入SQL是否完成，sqlite3_complete16（）的返回值都将为非零。</target>
        </trans-unit>
        <trans-unit id="6d6bbb3059e334920732ba9450708b663008dcc7" translate="yes" xml:space="preserve">
          <source>If SQLite is built with the &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; compile-time option then the syntax of the UPDATE statement is extended with optional ORDER BY and LIMIT clauses as follows:</source>
          <target state="translated">如果使用&lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt;编译时选项构建SQLite ，则UPDATE语句的语法将通过可选的ORDER BY和LIMIT子句进行扩展，如下所示：</target>
        </trans-unit>
        <trans-unit id="44ff2e47de1d4a52252bdf0898ff4b68826c3d7a" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled for Windows with the &lt;a href=&quot;compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt; compile-time option, then a different, thin wrapper is used around HeapAlloc(), HeapReAlloc(), and HeapFree(). The thin wrapper uses the configured SQLite heap, which will be different from the default process heap if the &lt;a href=&quot;compile#win32_heap_create&quot;&gt;SQLITE_WIN32_HEAP_CREATE&lt;/a&gt; compile-time option is used. In addition, when an allocation is made or freed, HeapValidate() will be called if SQLite is compiled with assert() enabled and the &lt;a href=&quot;compile#win32_malloc_validate&quot;&gt;SQLITE_WIN32_MALLOC_VALIDATE&lt;/a&gt; compile-time option.</source>
          <target state="translated">如果使用Windows &lt;a href=&quot;compile#win32_malloc&quot;&gt;SQLite_WIN32_MALLOC&lt;/a&gt;编译时选项为Windows编译了SQLite ，则在HeapAlloc（），HeapReAlloc（）和HeapFree（）周围使用不同的瘦包装器。精简包装使用配置的SQLite堆，如果使用&lt;a href=&quot;compile#win32_heap_create&quot;&gt;SQLITE_WIN32_HEAP_CREATE&lt;/a&gt;编译时选项，则它将与默认进程堆不同。另外，在分配或释放分配时，如果在启用assert（）和&lt;a href=&quot;compile#win32_malloc_validate&quot;&gt;SQLITE_WIN32_MALLOC_VALIDATE&lt;/a&gt;编译时选项的情况下编译SQLite，则将调用HeapValidate（）。</target>
        </trans-unit>
        <trans-unit id="517e1af932491e30c32e06c4fd9e534300edd652" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with &lt;a href=&quot;compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; then another zero-malloc memory allocator, similar to memsys5, is included in the source tree. The memsys3 allocator, like memsys5, must be activated by a call to &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;,...). Memsys3 uses the memory buffer supplied as its source for all memory allocations. The difference between memsys3 and memsys5 is that memsys3 uses a different memory allocation algorithm that seems to work well in practice, but which does not provide mathematical guarantees against memory fragmentation and breakdown. Memsys3 was a predecessor to memsys5. The SQLite developers now believe that memsys5 is superior to memsys3 and that all applications that need a zero-malloc memory allocator should use memsys5 in preference to memsys3. Memsys3 is considered both experimental and deprecated and will likely be removed from the source tree in a future release of SQLite.</source>
          <target state="translated">如果使用&lt;a href=&quot;compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt;编译SQLite ，则源树中将包含另一个类似于memsys5的零malloc内存分配器。与memsys5一样，memsys3分配器必须通过调用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;，...）。 Memsys3使用提供的内存缓冲区作为所有内存分配的源。 memsys3和memsys5之间的区别在于memsys3使用了一种不同的内存分配算法，该算法在实践中似乎可以很好地工作，但是不能为防止内存碎片和崩溃提供数学保证。 Memsys3是memsys5的前身。现在，SQLite开发人员认为memsys5优于memsys3，并且所有需要零malloc内存分配器的应用程序都应优先使用memsys5而不是memsys3。 Memsys3被认为是实验性的，不建议使用，在将来的SQLite版本中可能会从源树中删除。</target>
        </trans-unit>
        <trans-unit id="a20ff9c15584045a4ca98d16d24d41c5ba218767" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; compile-time option, then the syntax of the DELETE statement is extended by the addition of optional ORDER BY and LIMIT clauses:</source>
          <target state="translated">如果使用&lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt;编译时选项编译SQLite ，则通过添加可选的ORDER BY和LIMIT子句来扩展DELETE语句的语法：</target>
        </trans-unit>
        <trans-unit id="0e66b56024c7560826b0783e73206c696c2fa3db" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; compile-time option, then a different, heavy wrapper is used around system malloc(), realloc(), and free(). The heavy wrapper allocates around 100 bytes of extra space with each allocation. The extra space is used to place sentinel values at both ends of the allocation returned to the SQLite core. When an allocation is freed, these sentinels are checked to make sure the SQLite core did not overrun the buffer in either direction. When the system library is GLIBC, the heavy wrapper also makes use of the GNU backtrace() function to examine the stack and record the ancestor functions of the malloc() call. When running the SQLite test suite, the heavy wrapper also records the name of the current test case. These latter two features are useful for tracking down the source of memory leaks detected by the test suite.</source>
          <target state="translated">如果SQLite是使用&lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt;编译的编译时选项，然后在系统malloc（），realloc（）和free（）周围使用不同的繁重包装器。繁重的包装器每次分配都会分配大约100个字节的额外空间。多余的空间用于将哨兵值放置在返回到SQLite核心的分配的两端。释放分配后，将检查这些标记以确保SQLite内核没有在任一方向上溢出缓冲区。当系统库为GLIBC时，繁重的包装器还利用GNU backtrace（）函数检查堆栈并记录malloc（）调用的祖先函数。当运行SQLite测试套件时，繁重的包装器还会记录当前测试用例的名称。后两个功能对于跟踪测试套件检测到的内存泄漏源很有用。</target>
        </trans-unit>
        <trans-unit id="bdb5f255b340a7c8ea5f9ec1a27271eaa4afef49" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the &lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt; option, then the &lt;a href=&quot;malloc#defaultalloc&quot;&gt;default memory allocator&lt;/a&gt; is omitted and replaced by a stub memory allocator that never allocates any memory. Any calls to the stub memory allocator will report back that no memory is available.</source>
          <target state="translated">如果使用&lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt;选项编译SQLite ，则&lt;a href=&quot;malloc#defaultalloc&quot;&gt;默认内存分配器将&lt;/a&gt;被省略，并由一个从不分配任何内存的存根内存分配器代替。对存根内存分配器的任何调用都将报告没有可用的内存。</target>
        </trans-unit>
        <trans-unit id="a81969949fdea82f85b5652d9dfeed54c87f7d37" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the SQLITE_MUTEX_APPDEF preprocessor macro defined (with &quot;-DSQLITE_MUTEX_APPDEF=1&quot;), then no mutex implementation is included with the library. In this case the application must supply a custom mutex implementation using the &lt;a href=&quot;#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; option of the sqlite3_config() function before calling sqlite3_initialize() or any other public sqlite3_ function that calls sqlite3_initialize().</source>
          <target state="translated">如果使用定义的SQLITE_MUTEX_APPDEF预处理程序宏（&amp;ldquo; -DSQLITE_MUTEX_APPDEF = 1&amp;rdquo;）编译SQLite，则该库不包含互斥量实现。在这种情况下，应用程序必须在调用sqlite3_initialize（）或任何其他调用sqlite3_initialize（）的公共sqlite3_函数之前，使用sqlite3_config（）函数的&lt;a href=&quot;#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt;选项提供自定义互斥体实现。</target>
        </trans-unit>
        <trans-unit id="3612fbeb4e5912d3519c058afb830d2ca96819e8" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the SQLITE_MUTEX_APPDEF preprocessor macro defined (with &quot;-DSQLITE_MUTEX_APPDEF=1&quot;), then no mutex implementation is included with the library. In this case the application must supply a custom mutex implementation using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; option of the sqlite3_config() function before calling sqlite3_initialize() or any other public sqlite3_ function that calls sqlite3_initialize().</source>
          <target state="translated">如果使用定义的SQLITE_MUTEX_APPDEF预处理程序宏（&amp;ldquo; -DSQLITE_MUTEX_APPDEF = 1&amp;rdquo;）编译SQLite，则该库不包含互斥量实现。在这种情况下，应用程序必须在调用sqlite3_initialize（）或任何其他调用sqlite3_initialize（）的公共sqlite3_函数之前，使用sqlite3_config（）函数的&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt;选项提供自定义互斥体实现。</target>
        </trans-unit>
        <trans-unit id="3e4d7ea4d24bcad6503f112a75cb8cf3b594762c" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the THREADSAFE preprocessor macro set to 1, then it is safe to use SQLite from two or more threads of the same process at the same time. But each thread should have its own &lt;b&gt;sqlite*&lt;/b&gt; pointer returned from &lt;b&gt;sqlite_open&lt;/b&gt;. It is never safe for two or more threads to access the same &lt;b&gt;sqlite*&lt;/b&gt; pointer at the same time.</source>
          <target state="translated">如果在THREADSAFE预处理器宏设置为1的情况下编译SQLite，则可以安全地从同一进程的两个或多个线程中同时使用SQLite。但是每个线程都应该从&lt;b&gt;sqlite_open&lt;/b&gt;返回自己的&lt;b&gt;sqlite *&lt;/b&gt;指针。两个或多个线程同时访问同一&lt;b&gt;sqlite *&lt;/b&gt;指针永远是不安全的。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="710dfc358000c04c6f29b5a8b9d1e58f09170c01" translate="yes" xml:space="preserve">
          <source>If SQLite is working with multiple databases at the same time (using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command) then each database has its own rollback journal. But there is also a separate aggregate journal called the &lt;em&gt;master journal&lt;/em&gt;. The master journal does not contain page data used for rolling back changes. Instead the master journal contains the names of the individual database rollback journals for each of the ATTACHed databases. Each of the individual database rollback journals also contain the name of the master journal. If there are no ATTACHed databases (or if none of the ATTACHed database is participating in the current transaction) no master journal is created and the normal rollback journal contains an empty string in the place normally reserved for recording the name of the master journal.</source>
          <target state="translated">如果SQLite同时使用多个数据库（使用&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;命令），则每个数据库都有其自己的回滚日志。但是，还有一个单独的汇总日志称为&lt;em&gt;主日志&lt;/em&gt;。主日志不包含用于回滚更改的页面数据。而是，主日志包含每个ATTACHed数据库的各个数据库回滚日志的名称。每个单独的数据库回滚日志还包含主日志的名称。如果没有ATTACHed数据库（或者没有ATTACHed数据库参与当前事务），则不会创建主日志，并且正常回滚日志在通常保留用于记录主日志名称的位置包含一个空字符串。</target>
        </trans-unit>
        <trans-unit id="e3d682297850435cbed4a4f23333530d1946cfd2" translate="yes" xml:space="preserve">
          <source>If SQLite is working with multiple databases at the same time (using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command) then each database has its own rollback journal. But there is also a separate aggregate journal called the &lt;em&gt;super-journal&lt;/em&gt;. The super-journal does not contain page data used for rolling back changes. Instead the super-journal contains the names of the individual database rollback journals for each of the ATTACHed databases. Each of the individual database rollback journals also contain the name of the super-journal. If there are no ATTACHed databases (or if none of the ATTACHed database is participating in the current transaction) no super-journal is created and the normal rollback journal contains an empty string in the place normally reserved for recording the name of the super-journal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5896c61835dd6f9792c99d8e8f334dcf5e7f29e5" translate="yes" xml:space="preserve">
          <source>If SQLite needs a page-cache entry that is larger than &quot;sz&quot; bytes or if it needs more than N entries, it falls back to using the general-purpose memory allocator.</source>
          <target state="translated">如果SQLite需要一个大于 &quot;sz &quot;字节的页缓存条目,或者需要超过N个条目,它就会退回到使用通用内存分配器。</target>
        </trans-unit>
        <trans-unit id="4aa68767277ee1001967243f3227f1d8f761e4eb" translate="yes" xml:space="preserve">
          <source>If SQLite recognizes a table as a shadow table, and if the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag is set, then the shadow table is read-only for ordinary SQL statements. The shadow table can still be written, but only by SQL that is invoked from within one of the methods of some virtual table implementation.</source>
          <target state="translated">如果SQLite将表识别为影子表，并且设置了&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt;标志，则影子表对于普通SQL语句是只读的。影子表仍然可以写入，但是只能由从某些虚拟表实现的方法之一中调用的SQL编写。</target>
        </trans-unit>
        <trans-unit id="c334cbe953204cf334f3f0300d4576308ac4cfdc" translate="yes" xml:space="preserve">
          <source>If URI filenames are recognized when the database connection is originally opened, then URI filenames will also be recognized on &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statements. Similarly, if URI filenames are not recognized when the database connection is first opened, they will not be recognized by &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;.</source>
          <target state="translated">如果最初打开数据库连接时识别URI文件名，则URI文件名也将在&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;语句中识别。同样，如果首次打开数据库连接时未识别URI文件名，那么&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;不会识别它们。</target>
        </trans-unit>
        <trans-unit id="20f2ccdd4e7b5b66dd50ba0f757be7113d0c9526" translate="yes" xml:space="preserve">
          <source>If W is AND-connected terms and X is OR-connected terms and if any term of W appears as a term of X, then the partial index is usable.</source>
          <target state="translated">如果W是AND连接项,X是OR连接项,如果W的任何项出现在X的项中,那么部分索引是可用的。</target>
        </trans-unit>
        <trans-unit id="5ee5624c5ac84e77c145fe142470f12976a4d91a" translate="yes" xml:space="preserve">
          <source>If X is a memory allocation previously obtained from sqlite3_malloc(), sqlite3_malloc64(), sqlite3_realloc(), or sqlite3_realloc64(), then sqlite3_msize(X) returns the size of that memory allocation in bytes. The value returned by sqlite3_msize(X) might be larger than the number of bytes requested when X was allocated. If X is a NULL pointer then sqlite3_msize(X) returns zero. If X points to something that is not the beginning of memory allocation, or if it points to a formerly valid memory allocation that has now been freed, then the behavior of sqlite3_msize(X) is undefined and possibly harmful.</source>
          <target state="translated">如果X是之前从sqlite3_malloc()、sqlite3_malloc64()、sqlite3_realloc()或sqlite3_realloc64()获得的内存分配,那么sqlite3_msize(X)以字节为单位返回该内存分配的大小。sqlite3_msize(X)返回的值可能大于X被分配时请求的字节数。如果X是一个NULL指针,那么sqlite3_msize(X)返回0。如果X指向的不是内存分配的开始,或者指向一个以前有效的内存分配,但现在已经被释放,那么sqlite3_msize(X)的行为是未定义的,可能是有害的。</target>
        </trans-unit>
        <trans-unit id="b1b66964d31ddb28c71bf027a0d38468bda02bb0" translate="yes" xml:space="preserve">
          <source>If X is greater than or equal to zero, go back to step 3.</source>
          <target state="translated">如果X大于或等于零,则回到步骤3。</target>
        </trans-unit>
        <trans-unit id="b3fb68847c867d6e5aec8b5513dabb7e57278079" translate="yes" xml:space="preserve">
          <source>If X is non-zero, then the virtual table implementation guarantees that if &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; returns &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, it will do so before any modifications to internal or persistent data structures have been made. If the &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is ABORT, FAIL, IGNORE or ROLLBACK, SQLite is able to roll back a statement or database transaction, and abandon or continue processing the current SQL statement as appropriate. If the ON CONFLICT mode is REPLACE and the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method returns &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, SQLite handles this as if the ON CONFLICT mode had been ABORT.</source>
          <target state="translated">如果X为非零值，则虚拟表实现将保证，如果&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;返回&lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;，它将在对内部或持久数据结构进行任何修改之前这样做。如果&lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;模式为ABORT，FAIL，IGNORE或ROLLBACK，则SQLite可以回滚语句或数据库事务，并根据需要放弃或继续处理当前SQL语句。如果ON CONFLICT模式为REPLACE，并且&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法返回&lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;，则SQLite 会将其处理为ON CONFLICT模式为ABORT。</target>
        </trans-unit>
        <trans-unit id="c0b29678a870c29e379cb0f8c76e93d5c6f694fd" translate="yes" xml:space="preserve">
          <source>If X is non-zero, then the virtual table implementation guarantees that if &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, it will do so before any modifications to internal or persistent data structures have been made. If the &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is ABORT, FAIL, IGNORE or ROLLBACK, SQLite is able to roll back a statement or database transaction, and abandon or continue processing the current SQL statement as appropriate. If the ON CONFLICT mode is REPLACE and the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, SQLite handles this as if the ON CONFLICT mode had been ABORT.</source>
          <target state="translated">如果X为非零值，则虚拟表实现将保证，如果&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;，它将在对内部或持久数据结构进行任何修改之前这样做。如果&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;模式为ABORT，FAIL，IGNORE或ROLLBACK，则SQLite可以回滚语句或数据库事务，并根据需要放弃或继续处理当前SQL语句。如果ON CONFLICT模式为REPLACE，并且&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;，则SQLite 会将其处理为ON CONFLICT模式为ABORT。</target>
        </trans-unit>
        <trans-unit id="30772a96ac944f5d807fde7afed09facbb4c72a3" translate="yes" xml:space="preserve">
          <source>If X is the name of a rollback or WAL-mode journal file that is passed into the xOpen method of &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;, then sqlite3_database_file_object(X) returns a pointer to the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object that represents the main database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90405f680f9fd6c0b9fd6e8fd54aba076154778a" translate="yes" xml:space="preserve">
          <source>If X starts a transaction that will initially only read but X knows it will eventually want to write and does not want to be troubled with possible SQLITE_BUSY_SNAPSHOT errors that arise because another connection jumped ahead of it in line, then X can issue &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; to start its transaction instead of just an ordinary BEGIN. The &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; command goes ahead and starts a write transaction, and thus blocks all other writers. If the &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; operation succeeds, then no subsequent operations in that transaction will ever fail with an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error.</source>
          <target state="translated">如果X启动的事务最初只读取，但X知道它最终将要写入并且不希望由于另一个连接跳到该行之前而引起的SQLITE_BUSY_SNAPSHOT错误，则X可以发出&lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt;来启动它的交易，而不仅仅是普通的BEGIN。将&lt;a href=&quot;lang_transaction#immediate&quot;&gt;立即开始&lt;/a&gt;命令前进并开始写事务，从而阻止所有其他作家。如果&lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt;操作成功，则该事务中的任何后续操作都不会因&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;错误而失败。</target>
        </trans-unit>
        <trans-unit id="0eea241e4d0bdc37c50e93c325fbb23bd791a257" translate="yes" xml:space="preserve">
          <source>If a &quot;*&quot; character follows a string within an FTS expression, then the final token extracted from the string is marked as a &lt;b&gt;prefix token&lt;/b&gt;. As you might expect, a prefix token matches any document token of which it is a prefix. For example, the first two queries in the following block will match any document that contains the token &quot;one&quot; immediately followed by the token &quot;two&quot; and then any token that begins with &quot;thr&quot;.</source>
          <target state="translated">如果FTS表达式中的字符串&lt;b&gt;后面&lt;/b&gt;跟随&amp;ldquo; *&amp;rdquo;字符，则将从字符串中提取的最终标记标记为&lt;b&gt;前缀标记&lt;/b&gt;。如您所料，前缀标记会匹配任何以其为前缀的文档标记。例如，以下块中的前两个查询将匹配包含令牌&amp;ldquo; one&amp;rdquo;的任何文档，紧随其后的是令牌&amp;ldquo; two&amp;rdquo;，然后是任何以&amp;ldquo; thr&amp;rdquo;开头的令牌。</target>
        </trans-unit>
        <trans-unit id="3fc71a5654e7dbcda099553445308929a409041e" translate="yes" xml:space="preserve">
          <source>If a &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; SQL command is executed, and the same database connection currently has one or more actively executing SELECT statements, then SQLITE_LOCKED is returned. If &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; is called in this case, then the specified callback will be invoked immediately. Re-attempting the &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; statement will return another SQLITE_LOCKED error. In the implementation of sqlite3_blocking_step() shown to the left, this could cause an infinite loop.</source>
          <target state="translated">如果执行了&amp;ldquo; DROP TABLE&amp;rdquo;或&amp;ldquo; DROP INDEX&amp;rdquo; SQL命令，并且当前同一数据库连接中有一个或多个正在主动执行的SELECT语句，则返回SQLITE_LOCKED。如果在这种情况下调用&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;，则将立即调用指定的回调。重新尝试&amp;ldquo; DROP TABLE&amp;rdquo;或&amp;ldquo; DROP INDEX&amp;rdquo;语句将返回另一个SQLITE_LOCKED错误。在左侧所示的sqlite3_blocking_step（）的实现中，这可能会导致无限循环。</target>
        </trans-unit>
        <trans-unit id="12bc34a5236123febe1cd1188da174890c26f97b" translate="yes" xml:space="preserve">
          <source>If a &quot;^&quot; character appears immediately before a phrase that is not part of a NEAR query, then that phrase only matches a document only if it starts at the first token in a column. The &quot;^&quot; syntax may be combined with a &lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;column filter&lt;/a&gt;, but may not be inserted into the middle of a phrase.</source>
          <target state="translated">如果不属于NEAR查询的短语之前出现&amp;ldquo; ^&amp;rdquo;字符，则仅当该短语从列中的第一个标记开始时，该短语才与文档匹配。 &amp;ldquo; ^&amp;rdquo;语法可以与&lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;列过滤器&lt;/a&gt;结合使用，但不能插入短语的中间。</target>
        </trans-unit>
        <trans-unit id="73147d85cef7d3f5b1649d52c7fae3bdc6d30054" translate="yes" xml:space="preserve">
          <source>If a &quot;create file&quot; operation is executed by SQLite, and then the created file</source>
          <target state="translated">如果SQLite执行了 &quot;创建文件 &quot;操作,那么所创建的文件</target>
        </trans-unit>
        <trans-unit id="84d99b586ac4808874504752037c1f68b1dc681c" translate="yes" xml:space="preserve">
          <source>If a &quot;truncate file&quot; operation is executed by SQLite, and then the truncated file</source>
          <target state="translated">如果SQLite执行了 &quot;截断文件 &quot;操作,那么截断后的文件</target>
        </trans-unit>
        <trans-unit id="a177cd3b97251df1bda061d91a729d6e25be393e" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../wal#walfile&quot;&gt;WAL file&lt;/a&gt; remains on disk after all database connections close (either through the use of the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;file control&lt;/a&gt; or because the last process to have the database opened exited without calling &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;) and a new connection is subsequently opened on that database and &lt;a href=&quot;../wal#walfile&quot;&gt;WAL file&lt;/a&gt;, the &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface will only be able to open the last transaction added to the WAL file even though the WAL file contains other valid transactions.</source>
          <target state="translated">如果&lt;a href=&quot;../wal#walfile&quot;&gt;WAL文件&lt;/a&gt;在所有数据库连接关闭后仍保留在磁盘上（通过使用&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL &lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;文件控件，&lt;/a&gt;或者因为退出打开数据库的最后一个过程而未调用&lt;a href=&quot;close&quot;&gt;sqlite3_close（）&lt;/a&gt;退出），并且随后在该数据库上打开了新连接，并且&lt;a href=&quot;../wal#walfile&quot;&gt;WAL文件&lt;/a&gt;，&lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;接口将仅能打开添加到WAL文件中的最后一个事务，即使WAL文件包含其他有效事务也是如此。</target>
        </trans-unit>
        <trans-unit id="ce5e78d94d5947b9e328c1516e3f265b0f48637a" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; is generated from &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; then the statement is automatically re-prepared if the schema changes, up to &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; times (default: 50). The &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface will only return SQLITE_SCHEMA back to the application if the failure persists after these many retries.</source>
          <target state="translated">如果从&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;生成了一条&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句，&lt;/a&gt;则如果架构发生更改，该语句将自动重新准备，最多&lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt;次（默认值：50）。在&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;接口将只返回SQLITE_SCHEMA返回给应用程序，如果这些多次重试后故障仍然存在。</target>
        </trans-unit>
        <trans-unit id="3249186023e31b2ef81a917670edb42184c4e1e6" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; operation occurs on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as a pending read or write, then the pending read or write may fail with an SQLITE_ABORT or &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; error.</source>
          <target state="translated">如果在与未完成的读取或写入相同的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;上发生&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;操作，则未完成的读取或写入可能会失败，并显示SQLITE_ABORT或&lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt;错误。</target>
        </trans-unit>
        <trans-unit id="a092e1c1463db0502720c4f04f6df73156ddbd46" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt; remains on disk after all database connections close (either through the use of the &lt;a href=&quot;#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;file control&lt;/a&gt; or because the last process to have the database opened exited without calling &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;) and a new connection is subsequently opened on that database and &lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt;, the &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface will only be able to open the last transaction added to the WAL file even though the WAL file contains other valid transactions.</source>
          <target state="translated">如果&lt;a href=&quot;wal#walfile&quot;&gt;WAL文件&lt;/a&gt;在所有数据库连接关闭后仍保留在磁盘上（通过使用&lt;a href=&quot;#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL &lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;文件控件，&lt;/a&gt;或者因为退出打开数据库的最后一个过程而未调用&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close（）&lt;/a&gt;退出），并且随后在该数据库上打开了新连接，并且&lt;a href=&quot;wal#walfile&quot;&gt;WAL文件&lt;/a&gt;，&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;接口将仅能打开添加到WAL文件中的最后一个事务，即使WAL文件包含其他有效事务也是如此。</target>
        </trans-unit>
        <trans-unit id="fa0658f406309a7c36c783a199e98aa7bfe2c3be" translate="yes" xml:space="preserve">
          <source>If a BEFORE UPDATE or BEFORE DELETE trigger modifies or deletes a row that was to have been updated or deleted, then the result of the subsequent update or delete operation is undefined. Furthermore, if a BEFORE trigger modifies or deletes a row, then it is undefined whether or not AFTER triggers that would have otherwise run on those rows will in fact run.</source>
          <target state="translated">如果一个BEFORE UPDATE或BEFORE DELETE触发器修改或删除了一条本来要更新或删除的记录,那么后续的更新或删除操作的结果就没有定义。此外,如果一个BEFORE触发器修改或删除了一条记录,那么本应在这些记录上运行的AFTER触发器是否会实际运行是未定义的。</target>
        </trans-unit>
        <trans-unit id="a3ab52a71f2c1fab71f9f4f7d4dd870ab7b02c55" translate="yes" xml:space="preserve">
          <source>If a COMMIT statement (or the RELEASE of a transaction SAVEPOINT) fails because the database is currently in a state that violates a deferred foreign key constraint and there are currently &lt;a href=&quot;lang_savepoint&quot;&gt;nested savepoints&lt;/a&gt;, the nested savepoints remain open.</source>
          <target state="translated">如果COMMIT语句（或事务SAVEPOINT的RELEASE）由于数据库当前处于违反延迟的外键约束的状态而失败，并且当前存在&lt;a href=&quot;lang_savepoint&quot;&gt;嵌套保存点&lt;/a&gt;，则该嵌套保存点保持打开状态。</target>
        </trans-unit>
        <trans-unit id="4862567128635ae0bf91b3eee8827f7e081e0187" translate="yes" xml:space="preserve">
          <source>If a DELETE statement has a LIMIT clause, the maximum number of rows that will be deleted is found by evaluating the accompanying expression and casting it to an integer value. If the result of the evaluating the LIMIT clause cannot be losslessly converted to an integer value, it is an error. A negative LIMIT value is interpreted as &quot;no limit&quot;. If the DELETE statement also has an OFFSET clause, then it is similarly evaluated and cast to an integer value. Again, it is an error if the value cannot be losslessly converted to an integer. If there is no OFFSET clause, or the calculated integer value is negative, the effective OFFSET value is zero.</source>
          <target state="translated">如果一个DELETE语句有一个LIMIT子句,那么通过评估附带的表达式并将其转换为一个整数值,就可以找到将被删除的最大行数。如果评估LIMIT子句的结果不能无损地转换为一个整数值,则是一个错误。LIMIT负值被解释为 &quot;没有限制&quot;。如果DELETE语句也有一个OFFSET子句,那么它同样会被评估并投向一个整数值。同样,如果该值不能无损地转换为一个整数,则是一个错误。如果没有OFFSET子句,或者计算出的整数值为负值,那么有效的OFFSET值为零。</target>
        </trans-unit>
        <trans-unit id="a8ebe41fb4265f7abee56db5ee7b5c4f78f4ea2f" translate="yes" xml:space="preserve">
          <source>If a FILTER clause is provided, then only rows for which the</source>
          <target state="translated">如果提供了一个FILTER子句,那么,只有符合以下条件的记录才可以使用</target>
        </trans-unit>
        <trans-unit id="94816fac33b04eac89bfe331f82f9493ef356c93" translate="yes" xml:space="preserve">
          <source>If a FROM clause is specified, the data on which a simple SELECT query operates comes from the one or more tables or subqueries (SELECT statements in parentheses) specified following the FROM keyword. A subquery specified in the table-or-subquery following the FROM clause in a simple SELECT statement is handled as if it was a table containing the data returned by executing the subquery statement. Each column of the subquery has the &lt;a href=&quot;datatype3#collation&quot;&gt;collation sequence&lt;/a&gt; and &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; of the corresponding expression in the subquery statement.</source>
          <target state="translated">如果指定了FROM子句，则执行简单SELECT查询的数据来自在FROM关键字之后指定的一个或多个表或子查询（括号中的SELECT语句）。在简单的SELECT语句中，在FROM子句之后的表或子查询中指定的子查询，将被视为是包含执行子查询语句所返回的数据的表。子查询的每一列都具有子查询语句中相应表达式的&lt;a href=&quot;datatype3#collation&quot;&gt;排序规则序列&lt;/a&gt;和&lt;a href=&quot;datatype3#affinity&quot;&gt;相似性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="257e2a863a3526135a72b7350cb70ec4620d0ce5" translate="yes" xml:space="preserve">
          <source>If a HAVING clause is specified, it is evaluated once for each group of rows as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. If the result of evaluating the HAVING clause is false, the group is discarded. If the HAVING clause is an aggregate expression, it is evaluated across all rows in the group. If a HAVING clause is a non-aggregate expression, it is evaluated with respect to an arbitrarily selected row from the group. The HAVING expression may refer to values, even aggregate functions, that are not in the result.</source>
          <target state="translated">如果指定了HAVING子句，则将它作为&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;布尔表达式&lt;/a&gt;对每组行求值一次。如果评估HAVING子句的结果为false，则丢弃该组。如果HAVING子句是一个聚合表达式，则会在组中的所有行中对其求值。如果HAVING子句是非聚合表达式，则针对该组中任意选择的行对其求值。 HAVING表达式可以引用不在结果中的值，甚至是聚合函数。</target>
        </trans-unit>
        <trans-unit id="30445e74b001ab802719baf4ad36071ade7519f0" translate="yes" xml:space="preserve">
          <source>If a LIMIT clause is present, it might be possible to avoid scanning the entire table.</source>
          <target state="translated">如果存在LIMIT子句,可能会避免扫描整个表。</target>
        </trans-unit>
        <trans-unit id="948b4ac14d2baa3362d0ca28f059b73564c6f3e7" translate="yes" xml:space="preserve">
          <source>If a Linux &lt;a href=&quot;http://en.wikipedia.org/wiki/Ext3&quot;&gt;ext3&lt;/a&gt; filesystem is mounted without the &quot;barrier=1&quot; option in the &lt;a href=&quot;http://en.wikipedia.org/wiki/fstab&quot;&gt;/etc/fstab&lt;/a&gt; and the disk drive write cache is enabled then filesystem corruption can occur following a power loss or OS crash. Whether or not corruption can occur depends on the details of the disk control hardware; corruption is more likely with inexpensive consumer-grade disks and less of a problem for enterprise-class storage devices with advanced features such as non-volatile write caches. Various ext3 experts &lt;a href=&quot;http://www.redhat.com/archives/ext3-users/2010-July/msg00001.html&quot;&gt; confirm this behavior&lt;/a&gt;. We are told that most Linux distributions do not use barrier=1 and do not disable the write cache so most Linux distributions are vulnerable to this problem. Note that this is an operating system and hardware issue and that there is nothing that SQLite can do to work around it. &lt;a href=&quot;http://ozlabs.org/~rusty/index.cgi/tech/2009-10-20.html&quot;&gt; Other database engines&lt;/a&gt; have also run into this same problem.</source>
          <target state="translated">如果在&lt;a href=&quot;http://en.wikipedia.org/wiki/fstab&quot;&gt;/ etc / fstab中&lt;/a&gt;不带&amp;ldquo; barrier = 1&amp;rdquo;选项的情况下挂载Linux &lt;a href=&quot;http://en.wikipedia.org/wiki/Ext3&quot;&gt;ext3&lt;/a&gt;文件系统，并且启用了磁盘驱动器写缓存，则在断电或操作系统崩溃后，文件系统可能会损坏。是否会发生损坏取决于磁盘控制硬件的详细信息。廉价的消费级磁盘更容易造成损坏，而对于具有高级功能（如非易失性写缓存）的企业级存储设备而言，问题就更少了。各种ext3专家都&lt;a href=&quot;http://www.redhat.com/archives/ext3-users/2010-July/msg00001.html&quot;&gt;证实了这种现象&lt;/a&gt;。我们被告知，大多数Linux发行版不使用barrier = 1，并且不禁用写缓存，因此大多数Linux发行版都容易受到此问题的影响。请注意，这是一个操作系统和硬件问题，SQLite无法解决该问题。&lt;a href=&quot;http://ozlabs.org/~rusty/index.cgi/tech/2009-10-20.html&quot;&gt;其他数据库引擎&lt;/a&gt;也遇到了同样的问题。</target>
        </trans-unit>
        <trans-unit id="99b0a8e8602a0a06983153315092cfd9796ad41e" translate="yes" xml:space="preserve">
          <source>If a NOT NULL constraint is specified, then the column must have a default value other than NULL.</source>
          <target state="translated">如果指定了NOT NULL约束,那么列的默认值必须是NULL以外的值。</target>
        </trans-unit>
        <trans-unit id="55be5a331b8cf28f9f746d3f7eb6341aa17eff02" translate="yes" xml:space="preserve">
          <source>If a SELECT query contains an ORDER BY, GROUP BY or DISTINCT clause, SQLite may need to use a temporary b-tree structure to sort the output rows. Or, it might &lt;a href=&quot;queryplanner#sorting&quot;&gt;use an index&lt;/a&gt;. Using an index is almost always much more efficient than performing a sort. If a temporary b-tree is required, a record is added to the EXPLAIN QUERY PLAN output with the &quot;detail&quot; field set to a string value of the form &quot;USE TEMP B-TREE FOR xxx&quot;, where xxx is one of &quot;ORDER BY&quot;, &quot;GROUP BY&quot; or &quot;DISTINCT&quot;. For example:</source>
          <target state="translated">如果SELECT查询包含ORDER BY，GROUP BY或DISTINCT子句，则SQLite可能需要使用临时的b树结构对输出行进行排序。或者，它可能&lt;a href=&quot;queryplanner#sorting&quot;&gt;使用index&lt;/a&gt;。使用索引几乎总是比执行排序更有效率。如果需要临时b树，则将记录添加到EXPLAIN QUERY PLAN输出中，并将&amp;ldquo;详细信息&amp;rdquo;字段设置为形式为&amp;ldquo; USE TEMP B-TREE FOR xxx&amp;rdquo;的字符串值，其中xxx是&amp;ldquo; ORDER&amp;rdquo;之一BY&amp;rdquo;，&amp;ldquo; GROUP BY&amp;rdquo;或&amp;ldquo; DISTINCT&amp;rdquo;。例如：</target>
        </trans-unit>
        <trans-unit id="5b44dbe4fb9e1c6ef0606b8af702048ca0e438cc" translate="yes" xml:space="preserve">
          <source>If a SELECT statement that returns more than one row does not have an ORDER BY clause, the order in which the rows are returned is undefined. Or, if a SELECT statement does have an ORDER BY clause, then the list of expressions attached to the ORDER BY determine the order in which rows are returned to the user.</source>
          <target state="translated">如果一个返回多条记录的SELECT语句没有ORDER BY子句,那么返回记录的顺序就没有定义。或者,如果一个SELECT语句确实有一个ORDER BY子句,那么附加在ORDER BY上的表达式列表决定了返回给用户的行的顺序。</target>
        </trans-unit>
        <trans-unit id="1b3cef981ef6c33ad4faa712cdaf3b903f15861f" translate="yes" xml:space="preserve">
          <source>If a UNION operator connects the initial-select with the recursive-select, then only add rows to the queue if no identical row has been previously added to the queue. Repeated rows are discarded before being added to the queue even if the repeated rows have already been extracted from the queue by the recursion step. If the operator is UNION ALL, then all rows generated by both the initial-select and the recursive-select are always added to the queue even if they are repeats. When determining if a row is repeated, NULL values compare equal to one another and not equal to any other value.</source>
          <target state="translated">如果一个UNION操作符将初始选择和递归选择连接起来,那么只有当之前没有相同的行被添加到队列中时,才会将行添加到队列中。即使重复的记录已经被递归步骤从队列中提取出来,重复的记录也会在被添加到队列之前被丢弃。如果操作符是UNION ALL,那么所有由初始选择和递归选择产生的记录总是被添加到队列中,即使它们是重复的。在确定某行是否重复时,NULL值相互比较相等,而不等于任何其他值。</target>
        </trans-unit>
        <trans-unit id="56d92b47e4081e5a6e548ebb6f898e186d052899" translate="yes" xml:space="preserve">
          <source>If a WHEN clause is supplied, the SQL statements specified are only executed if the WHEN clause is true. If no WHEN clause is supplied, the SQL statements are executed every time the trigger fires.</source>
          <target state="translated">如果提供了WHEN子句,那么只有当WHEN子句为真时才会执行指定的SQL语句。如果没有提供WHEN子句,则每次触发器触发时都会执行SQL语句。</target>
        </trans-unit>
        <trans-unit id="85a070271019d9b24039a7b30649256cb4c49fd9" translate="yes" xml:space="preserve">
          <source>If a WHERE clause is specified, the WHERE expression is evaluated for each row in the input data as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. Only rows for which the WHERE clause expression evaluates to true are included from the dataset before continuing. Rows are excluded from the result if the WHERE clause evaluates to either false or NULL.</source>
          <target state="translated">如果指定了WHERE子句，则对输入数据中的每一行都将WHERE表达式作为&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;布尔表达式求值&lt;/a&gt;。在继续之前，数据集中仅包含WHERE子句表达式的评估结果为true的行。如果WHERE子句的计算结果为false或NULL，则从结果中排除行。</target>
        </trans-unit>
        <trans-unit id="99314068471e46954e8f897765afda682981e6bc" translate="yes" xml:space="preserve">
          <source>If a build of SQLite does not include the FTS modules, then any attempt to prepare an SQL statement to create an FTS3 or FTS4 table or to drop or access an existing FTS table in any way will fail. The error message returned will be similar to &quot;no such module: ftsN&quot; (where N is either 3 or 4).</source>
          <target state="translated">如果构建的SQLite不包括FTS模块,那么任何试图编写SQL语句来创建FTS3或FTS4表或以任何方式删除或访问现有FTS表的尝试都将失败。返回的错误信息将类似于 &quot;no such module:ftsN&quot;(其中N是3或4)。</target>
        </trans-unit>
        <trans-unit id="c07dc39ee71e6a6e8537165278b706aabd6e81bd" translate="yes" xml:space="preserve">
          <source>If a call to sqlite3_step() that attempts to write to a database table returns SQLITE_LOCKED, then more than one other connection may be holding a read-lock on the database table in question. In this case SQLite simply selects one of those other connections arbitrarily and issues the unlock-notify callback when that connection's transaction is finished. Whether the call to sqlite3_step() was blocked by one or many connections, when the corresponding unlock-notify callback is issued it is not guaranteed that the required lock is available, only that it may be.</source>
          <target state="translated">如果调用sqlite3_step()试图对数据库表进行写入,并返回SQLITE_LOCKED,那么可能会有多个其他连接对相关数据库表持有读锁。在这种情况下,SQLite只需任意选择其中一个连接,并在该连接的事务完成后发出解锁通知回调。无论对sqlite3_step()的调用是被一个或多个连接所阻挡,当相应的解锁-通知回调被发出时,并不能保证所需的锁是可用的,只能保证它可能是可用的。</target>
        </trans-unit>
        <trans-unit id="12e866adc40a794d5a50cd7647771628a0fe472b" translate="yes" xml:space="preserve">
          <source>If a character specified as part of the argument to &quot;tokenchars=&quot; is considered to be a token character by default, it is ignored. This is true even if it has been marked as a separator by an earlier &quot;separators=&quot; option. Similarly, if a character specified as part of a &quot;separators=&quot; option is treated as a separator character by default, it is ignored. If multiple &quot;tokenchars=&quot; or &quot;separators=&quot; options are specified, all are processed. For example:</source>
          <target state="translated">如果作为 &quot;tokenchars=&quot;参数的一部分而指定的字符,默认情况下被认为是标记字符,则会被忽略。即使它已经被之前的 &quot;separators=&quot;选项标记为分隔符,也会被忽略。同样地,如果 &quot;separators=&quot;选项中指定的字符默认被视为分隔符,则会被忽略。如果指定了多个 &quot;tokenchars=&quot;或 &quot;separators=&quot;选项,则会处理所有的选项。例如</target>
        </trans-unit>
        <trans-unit id="4047a69992390b90bb1e651abb363899dad3ce20" translate="yes" xml:space="preserve">
          <source>If a collating function fails any of the above constraints and that collating function is registered and used, then the behavior of SQLite is undefined.</source>
          <target state="translated">如果一个整理函数没有通过上述任何一个约束条件,并且该整理函数被注册和使用,那么SQLite的行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="4a25d30fe6f01a94e32b9a3c4b8ab96f2806f18f" translate="yes" xml:space="preserve">
          <source>If a column datatype contains the special keyword &quot;HIDDEN&quot; (in any combination of upper and lower case letters) then that keyword it is omitted from the column datatype name and the column is marked as a hidden column internally. A hidden column differs from a normal column in three respects:</source>
          <target state="translated">如果一个列数据类型包含特殊的关键字 &quot;HIDDEN&quot;(大写和小写字母的任意组合),那么该关键字就会从列数据类型名称中省略,该列在内部被标记为隐藏列。隐藏列与普通列有三个方面的不同。</target>
        </trans-unit>
        <trans-unit id="4a3060f5f06633a8fd81221c196cda03a0efe5c5" translate="yes" xml:space="preserve">
          <source>If a column filter specification is preceded by a &quot;-&quot; character, then it is interpreted as a list of column not to match against. For example:</source>
          <target state="translated">如果列过滤规范前面有一个&quot;-&quot;字符,那么它将被解释为一个不匹配的列列表。例如:&quot;-&quot;字头,则解释为不与之匹配的列列表。</target>
        </trans-unit>
        <trans-unit id="4784be250e1d29a9c62d93440a67186e8f2d433e" translate="yes" xml:space="preserve">
          <source>If a column has the type INTEGER PRIMARY KEY AUTOINCREMENT then a slightly different ROWID selection algorithm is used. The ROWID chosen for the new row is at least one larger than the largest ROWID that has ever before existed in that same table. If the table has never before contained any data, then a ROWID of 1 is used. If the largest possible ROWID has previously been inserted, then new INSERTs are not allowed and any attempt to insert a new row will fail with an SQLITE_FULL error. Only ROWID values from previous transactions that were committed are considered. ROWID values that were rolled back are ignored and can be reused.</source>
          <target state="translated">如果一列的类型是INTEGER PRIMARY KEY AUTOINCREMENT,那么就会使用稍微不同的ROWID选择算法。新行所选择的ROWID至少要比同一表中以前存在的最大ROWID大一个。如果该表之前从未包含过任何数据,那么就使用1的ROWID。如果之前已经插入了最大的ROWID,那么不允许插入新的INSERT,任何插入新行的尝试都会以SQLITE_FULL错误失败。只考虑以前提交的事务中的ROWID值。被回滚的ROWID值会被忽略,并且可以重复使用。</target>
        </trans-unit>
        <trans-unit id="85779fa11fd249fc0a9433b1c9e912b143d1abd7" translate="yes" xml:space="preserve">
          <source>If a column-name list follows the view-name, then that list determines the names of the columns for the view. If the column-name list is omitted, then the names of the columns in the view are derived from the names of the result-set columns in the &lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt;. The use of column-name list is recommended. Or, if column-name list is omitted, then the result columns in the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement that defines the view should have well-defined names using the &quot;&lt;a href=&quot;syntax/result-column&quot;&gt;AS column-alias&lt;/a&gt;&quot; syntax. SQLite allows you to create views that depend on automatically generated column names, but you should avoid using them since the rules used to generate column names are not a defined part of the interface and might change in future releases of SQLite.</source>
          <target state="translated">如果列名称列表紧随视图名称，则该列表将确定视图的列名称。如果省略了列名列表，则视图中的列名是从&lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt中&lt;/a&gt;结果集列的名称派生的。建议使用列名列表。或者，如果省略了列名列表，那么使用&amp;ldquo; &lt;a href=&quot;syntax/result-column&quot;&gt;AS column-alias&lt;/a&gt; &amp;rdquo;语法，定义视图的&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句中的结果列应具有定义明确的名称。 SQLite允许您创建依赖于自动生成的列名的视图，但是您应避免使用它们，因为用于生成列名的规则不是接口的已定义部分，并且在将来的SQLite版本中可能会更改。</target>
        </trans-unit>
        <trans-unit id="7f7aaafed42977493a2413f4303512821df4e3b2" translate="yes" xml:space="preserve">
          <source>If a conflict handler returns this value no special action is taken. The change that caused the conflict is not applied. The session module continues to the next change in the changeset.</source>
          <target state="translated">如果冲突处理程序返回这个值,则不会采取任何特殊行动。引起冲突的变更不会被应用。会话模块将继续进行更改集中的下一个更改。</target>
        </trans-unit>
        <trans-unit id="a40b2d39f56dad1b134a26af2fe2ae696281adc1" translate="yes" xml:space="preserve">
          <source>If a covering index can be used for a query, then the multiple rowid lookups can be avoided and the cost of the query drops dramatically.</source>
          <target state="translated">如果可以使用覆盖索引进行查询,那么就可以避免多次的rowid查找,查询的成本就会大幅下降。</target>
        </trans-unit>
        <trans-unit id="653b4381ff1ad3607fbc3061d7b4f5d80ed74deb" translate="yes" xml:space="preserve">
          <source>If a crash or power failure occurs and results in a hot journal but that journal is deleted, the next process to open the database will not know that it contains changes that need to be rolled back. The rollback will not occur and the database will be left in an inconsistent state. Rollback journals might be deleted for any number of reasons:</source>
          <target state="translated">如果发生崩溃或断电,并导致热日志,但该日志被删除,下一个打开数据库的进程将不知道它包含需要回滚的更改。回滚将不会发生,数据库将处于不一致的状态。回滚日记可能因为任何原因被删除。</target>
        </trans-unit>
        <trans-unit id="dbc53ced19579b45a05b723b3063167292a44232" translate="yes" xml:space="preserve">
          <source>If a crash or power loss does occur and a hot journal is left on the disk, it is essential that the original database file and the hot journal remain on disk with their original names until the database file is opened by another SQLite process and rolled back. During recovery at &lt;a href=&quot;#section_4_2&quot;&gt;step 4.2&lt;/a&gt; SQLite locates the hot journal by looking for a file in the same directory as the database being opened and whose name is derived from the name of the file being opened. If either the original database file or the hot journal have been moved or renamed, then the hot journal will not be seen and the database will not be rolled back.</source>
          <target state="translated">如果确实发生崩溃或断电，并且磁盘上保留有热日志，则必须将原始数据库文件和热日志以其原始名称保留在磁盘上，直到该数据库文件被另一个SQLite进程打开并回滚为止。 。在&lt;a href=&quot;#section_4_2&quot;&gt;步骤4.2的&lt;/a&gt;恢复过程中，SQLite通过在与要打开的数据库相同的目录中查找文件来查找热日志，并且该文件的名称源自要打开的文件的名称。如果原始数据库文件或热日志已被移动或重命名，则将不会看到热日志，并且不会回滚数据库。</target>
        </trans-unit>
        <trans-unit id="fb8183919d1fc07417b2707b8092ba7a7a08090d" translate="yes" xml:space="preserve">
          <source>If a crash or power loss occurs in the middle of a transaction, then the rollback journal file is left on disk. The next time another application attempts to open the database file, it notices the presence of the abandoned rollback journal (we call it a &quot;hot journal&quot; in this circumstance) and uses the information in the journal to restore the database to its state prior to the start of the incomplete transaction. This is how SQLite implements atomic commit.</source>
          <target state="translated">如果在交易过程中发生崩溃或断电,那么回滚日志文件就会被留在磁盘上。下一次当另一个应用程序试图打开数据库文件时,它就会注意到被遗弃的回滚日志的存在(在这种情况下,我们称它为 &quot;热日志&quot;),并使用日志中的信息将数据库恢复到未完成事务开始前的状态。这就是SQLite实现原子提交的方式。</target>
        </trans-unit>
        <trans-unit id="ac9f0e2592a2df4c51e939a4b5d49b41b7d7ebcb" translate="yes" xml:space="preserve">
          <source>If a database connection is opened with the &quot;-uri 1&quot; option, then &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; are honored by the &quot;backup&quot; and &quot;restore&quot; commands.</source>
          <target state="translated">如果使用&amp;ldquo; -uri 1&amp;rdquo;选项打开了数据库连接，则&amp;ldquo;备份&amp;rdquo;和&amp;ldquo;恢复&amp;rdquo;命令将使用&lt;a href=&quot;uri&quot;&gt;URI文件名&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d5923feff2a2aef8fc7abf4f600aff34fc785066" translate="yes" xml:space="preserve">
          <source>If a database connection is operating in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; or in &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;persistent journal mode&lt;/a&gt; (PRAGMA journal_mode=persist) then after committing a transaction the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; file may remain in the file-system. This increases performance for subsequent transactions since overwriting an existing file is faster than append to a file, but it also consumes file-system space. After a large transaction (e.g. a &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;), the rollback journal file may consume a very large amount of space.</source>
          <target state="translated">如果数据库连接以&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;排他锁定模式&lt;/a&gt;或&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;持久日志模式&lt;/a&gt;（PRAGMA journal_mode = persist）运行，则在提交事务后，&lt;a href=&quot;lockingv3#rollback&quot;&gt;回滚日志&lt;/a&gt;文件可能会保留在文件系统中。由于覆盖现有文件比添加到文件要快，因此可以提高后续事务的性能，但同时也会占用文件系统空间。在进行大量事务（例如&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;）之后，回滚日志文件可能会占用大量空间。</target>
        </trans-unit>
        <trans-unit id="5f55f04439258c2d344a35f29269aa9db3e5202b" translate="yes" xml:space="preserve">
          <source>If a database file is accessed using 8+3 naming rather than the default long filename, then it must be consistently accessed using 8+3 naming by every database connection every time it is opened, or else there is a risk of database corruption. The auxiliary &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; and &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; files are essential to SQLite for being about to recover from a crash. If an application is using 8+3 names and crashes, then the information needed to safely recover from the crash is stored in files with the &quot;&lt;code&gt;.nal&lt;/code&gt;&quot; or &quot;&lt;code&gt;.wal&lt;/code&gt;&quot; extension. If the next application to open the database does not specify the &quot;&lt;code&gt;8_3_names=1&lt;/code&gt;&quot; URI parameter, then SQLite will use the long filenames to try to locate the rollback journal or write-ahead log files. It will not find them, since they were saved using 8+3 names by the application that crashed, and hence the database will not be properly recovered and will likely go corrupt.</source>
          <target state="translated">如果使用8 + 3命名而不是默认的长文件名来访问数据库文件，则每次打开数据库时，每个数据库连接都必须使用8 + 3命名来一致地访问该文件，否则存在数据库损坏的风险。辅助&lt;a href=&quot;lockingv3#rollback&quot;&gt;回滚日志&lt;/a&gt;和&lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt;文件对于要从崩溃中恢复的SQLite至关重要。如果应用程序使用8 + 3名称且崩溃，则从崩溃中安全恢复所需的信息将存储在扩展名为&amp;ldquo; &lt;code&gt;.nal&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;.wal&lt;/code&gt; &amp;rdquo;的文件中。如果下一个打开数据库的应用程序未指定&amp;ldquo; &lt;code&gt;8_3_names=1&lt;/code&gt; &amp;ldquo; URI参数，然后SQLite将使用长文件名来尝试查找回滚日志或预写日志文件。找不到它们，因为崩溃的应用程序使用8 + 3名称保存了它们，因此数据库将无法正确恢复，并且可能会损坏。</target>
        </trans-unit>
        <trans-unit id="bd70a20b8f5f47bbbe011a3bee3a583fecc50caa" translate="yes" xml:space="preserve">
          <source>If a database is written by SQLite version 3.7.0 or later and then written again by SQLite version 3.6.23 or earlier in such a way as to make the size of the database file decrease, then the next time that SQLite version 3.7.0 access the database file, it might report that the database file is corrupt. The database file is not really corrupt, however. Version 3.7.0 was simply being overly zealous in its corruption detection.</source>
          <target state="translated">如果一个数据库是由SQLite 3.7.0或更高版本编写的,然后再由SQLite 3.6.23或更早版本编写,这样使数据库文件的大小减小,那么下次SQLite 3.7.0版本访问数据库文件时,可能会报告数据库文件损坏。但是,数据库文件并不是真的损坏了。3.7.0版本只是在检测损坏时过于热心。</target>
        </trans-unit>
        <trans-unit id="c0e8b12ff7ad15986137c5d5f01f4e0ef949a4a6" translate="yes" xml:space="preserve">
          <source>If a database were originally created using SQLite version 3.7.0, then written by SQLite version 3.6.23.1 such that the size of the database file increased, then written again by SQLite version 3.7.0, the database file could go corrupt.</source>
          <target state="translated">如果一个数据库最初是用SQLite 3.7.0版本创建的,然后用SQLite 3.6.23.1版本写入,使数据库文件的大小增加,然后再用SQLite 3.7.0版本写入,数据库文件可能会损坏。</target>
        </trans-unit>
        <trans-unit id="f7f861f58b781638426cc97ad65bbe6addfa6a62" translate="yes" xml:space="preserve">
          <source>If a keyword in double quotes (ex: &lt;b&gt;&quot;key&quot;&lt;/b&gt; or &lt;b&gt;&quot;glob&quot;&lt;/b&gt;) is used in a context where it cannot be resolved to an identifier but where a string literal is allowed, then the token is understood to be a string literal instead of an identifier.</source>
          <target state="translated">如果在无法将其解析为标识符但允许使用字符串文字的情况下使用双引号引起来的关键字（例如：&lt;b&gt;&amp;ldquo; key&amp;rdquo;&lt;/b&gt;或&lt;b&gt;&amp;ldquo; glob&amp;rdquo;&lt;/b&gt;），则该令牌应理解为字符串文字，而不是标识符。</target>
        </trans-unit>
        <trans-unit id="ff734731d1dd61e745b8c19a93e379fd051ea7fb" translate="yes" xml:space="preserve">
          <source>If a keyword in single quotes (ex: &lt;b&gt;'key'&lt;/b&gt; or &lt;b&gt;'glob'&lt;/b&gt;) is used in a context where an identifier is allowed but where a string literal is not allowed, then the token is understood to be an identifier instead of a string literal.</source>
          <target state="translated">如果在允许标识符但不允许使用字符串文字的上下文中使用单引号引起来的关键字（例如：&lt;b&gt;'key'&lt;/b&gt;或&lt;b&gt;'glob'&lt;/b&gt;），则将令牌理解为标识符而不是字符串文字。</target>
        </trans-unit>
        <trans-unit id="fd8582b07f28c43cf6305e6462fb4a6db23b8ea7" translate="yes" xml:space="preserve">
          <source>If a matchable phrase is part of a series of phrases connected by NEAR operators in the FTS query expression, then each phrase match must be sufficiently close to other phrase matches of the relevant types to satisfy the NEAR condition.</source>
          <target state="translated">如果一个可匹配的短语是FTS查询表达式中由NEAR运算符连接的一系列短语的一部分,那么每个短语匹配必须与相关类型的其他短语匹配足够接近,以满足NEAR条件。</target>
        </trans-unit>
        <trans-unit id="a2a6d03cae632eedbf962d2919113c9e0642d81c" translate="yes" xml:space="preserve">
          <source>If a memory allocation error occurs, sqlite3_create_filename() might return a NULL pointer. The memory obtained from sqlite3_create_filename(X) must be released by a corresponding call to sqlite3_free_filename(Y).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ba62507a795aad87688bd7a66b598560ff99c0" translate="yes" xml:space="preserve">
          <source>If a named virtual table that uses the dbstat module is desired, then the recommended way to create an instance of the dbstat virtual table is as follows:</source>
          <target state="translated">如果需要使用dbstat模块的命名虚拟表,那么推荐的创建dbstat虚拟表实例的方法如下。</target>
        </trans-unit>
        <trans-unit id="f0a2ba4a4cc7d08c018b4dbe8137dc10439214b7" translate="yes" xml:space="preserve">
          <source>If a numeric literal has a decimal point or an exponentiation clause or if its magnitude is less than -9223372036854775808 or greater than 9223372036854775807, then it is a floating point literal. Otherwise is it is an integer literal. The &quot;E&quot; character that begins the exponentiation clause of a floating point literal can be either upper or lower case. The &quot;.&quot; character is always used as the decimal point even if the locale setting specifies &quot;,&quot; for this role - the use of &quot;,&quot; for the decimal point would result in syntactic ambiguity.</source>
          <target state="translated">如果一个数字文字有小数点或指数子句,或者如果它的大小小于-9223372036854775808或大于9223372036854775807,那么它就是一个浮点文字。否则就是一个整数文字。浮点文字的指数子句开头的 &quot;E &quot;字符可以是大写或小写。&quot;.&quot;字符总是被用作小数点,即使locale设置指定了&quot;,&quot;--使用&quot;,&quot;来表示小数点会导致语法上的歧义。</target>
        </trans-unit>
        <trans-unit id="8cf3813aebca15b6b5e1583aeffa06f6925412e6" translate="yes" xml:space="preserve">
          <source>If a page contains no cells (which is only possible for a root page of a table that contains no rows) then the offset to the cell content area will equal the page size minus the bytes of reserved space. If the database uses a 65536-byte page size and the reserved space is zero (the usual value for reserved space) then the cell content offset of an empty page wants to be 65536. However, that integer is too large to be stored in a 2-byte unsigned integer, so a value of 0 is used in its place.</source>
          <target state="translated">如果一个页面不包含任何单元格(只有对于一个不包含行的表的根页面才有可能),那么单元格内容区域的偏移量将等于页面大小减去保留空间的字节。如果数据库使用65536字节的页面大小,而预留空间为零(预留空间的通常值),那么空页面的单元格内容偏移量想为65536。但是,这个整数太大,无法存储在2字节的无符号整数中,所以用0的值来代替。</target>
        </trans-unit>
        <trans-unit id="c99e07bc95c7e7eeb5ce8d8ce056128a45cab0ab" translate="yes" xml:space="preserve">
          <source>If a parameter name begins with a &quot;:&quot;, then it is assumed to be a value to bind to the SQL statement before executing it. The value is always bound as text. It is an error if the specified SQL parameter does not exist. For example:</source>
          <target state="translated">如果一个参数名以&quot;:&quot;开头,那么它被认为是一个值,要在执行SQL语句之前绑定到它。该值总是被绑定为文本。如果指定的SQL参数不存在,则是一个错误。例如:&quot;:&quot;。</target>
        </trans-unit>
        <trans-unit id="a3a6677c34d1c31ace005a4fa6f3930c2040066e" translate="yes" xml:space="preserve">
          <source>If a power failure or operating system crash occurs at this point, the transaction will not rollback when the system reboots even though there are rollback journals present. The difference is the master journal pathname in the header of the rollback journal. Upon restart, SQLite only considers a journal to be hot and will only playback the journal if there is no master journal filename in the header (which is the case for a single-file commit) or if the master journal file still exists on disk.</source>
          <target state="translated">如果此时发生断电或操作系统崩溃,即使有回滚日记存在,系统重启时事务也不会回滚。不同的是回滚日记头中的主日记路径名。重启后,SQLite只认为日志是热的,只有当头中没有主日志文件名时(单文件提交时是这样),或者主日志文件在磁盘上仍然存在时,才会回滚日志。</target>
        </trans-unit>
        <trans-unit id="df0966ae095afce680bcbe564721893f2e27c89b" translate="yes" xml:space="preserve">
          <source>If a power failure or operating system crash occurs at this point, the transaction will not rollback when the system reboots even though there are rollback journals present. The difference is the super-journal pathname in the header of the rollback journal. Upon restart, SQLite only considers a journal to be hot and will only playback the journal if there is no super-journal filename in the header (which is the case for a single-file commit) or if the super-journal file still exists on disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f031e4113363c1780559d56fb503c736f7031cb4" translate="yes" xml:space="preserve">
          <source>If a power failure or operating system failure occurs while copying the database file the backup database may be corrupted following system recovery.</source>
          <target state="translated">如果在复制数据库文件时发生断电或操作系统故障,系统恢复后,备份数据库可能会损坏。</target>
        </trans-unit>
        <trans-unit id="d63fd60747c59caf947d214389cf965d0e528d08" translate="yes" xml:space="preserve">
          <source>If a query contains an ORDER BY clause with multiple terms, it might be that SQLite can use indices to cause rows to come out in the order of some prefix of the terms in the ORDER BY but that later terms in the ORDER BY are not satisfied. In that case, SQLite does block sorting. Suppose the ORDER BY clause has four terms and the natural order of the query results in rows appearing in order of the first two terms. As each row is output by the query engine and enters the sorter, the outputs in the current row corresponding to the first two terms of the ORDER BY are compared against the previous row. If they have changed, the current sort is finished and output and a new sort is started. This results in a slightly faster sort. But the bigger advantages are that many fewer rows need to be held in memory, reducing memory requirements, and outputs can begin to appear before the core query has run to completion.</source>
          <target state="translated">如果一个查询中包含有多个术语的ORDER BY子句,可能是SQLite可以使用索引使行按照ORDER BY中术语的某个前缀的顺序出来,但是ORDER BY中后面的术语不满足。在这种情况下,SQLite会进行阻塞排序。假设ORDER BY子句有四个术语,而查询的自然顺序导致行按前两个术语的顺序出现。当每一条行被查询引擎输出并进入排序器时,当前行中对应ORDER BY前两个术语的输出与前一行进行比较。如果它们发生了变化,则当前排序结束并输出,开始新的排序。这样一来,排序的速度会稍快一些。但更大的优点是,需要在内存中保存的行少了很多,减少了对内存的要求,而且在核心查询运行完成之前就可以开始出现输出。</target>
        </trans-unit>
        <trans-unit id="ec318f6e2d2904b05a3f02946f0559cc8fefaa28" translate="yes" xml:space="preserve">
          <source>If a query contains no aggregate functions at all, then a GROUP BY clause can be added as a substitute for the DISTINCT ON clause. In other words, output rows are filtered so that only one row is shown for each distinct set of values in the GROUP BY clause. If two or more output rows would have otherwise had the same set of values for the GROUP BY columns, then one of the rows is chosen arbitrarily. (SQLite supports DISTINCT but not DISTINCT ON, whose functionality is provided instead by GROUP BY.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdf63c23188158127b26cd2c4807de45ccf6dea6" translate="yes" xml:space="preserve">
          <source>If a query contains no aggregate functions at all, then a GROUP BY clause can be added as a substitute of DISTINCT ON clause. In other words, output rows are filtered so that only one row is shows for each distinct set of values in the GROUP BY clause. If two or more output rows would have otherwise had the same set of values for the GROUP BY columns, then one of the rows is chosen arbitrarily.</source>
          <target state="translated">如果一个查询完全不包含聚合函数,那么可以添加一个GROUP BY子句来代替DISTINCT ON子句。换句话说,输出行会被过滤,因此GROUP BY子句中的每一个不同的值集只显示一条行。如果两条或两条以上的输出行在GROUP BY子句中的值是相同的,那么任意选择其中一条行。</target>
        </trans-unit>
        <trans-unit id="cab66c0bca9a377eb02b4b0ac5090404c2d874c0" translate="yes" xml:space="preserve">
          <source>If a read/write client invokes &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;) prior to shutdown, then at shutdown a checkpoint is still run, but the shm file and wal file are not deleted. This allows subsequent read-only clients to connect to and read the database.</source>
          <target state="translated">如果读/写客户端在关闭之前调用&lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt;（&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;），则在关闭时仍会运行检查点，但不会删除shm文件和wal文件。这使后续的只读客户端可以连接并读取数据库。</target>
        </trans-unit>
        <trans-unit id="337133b7d09a387cf87665a4c7d79ff39c533386" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the modified non-primary key fields contains a value different from an original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. Since UPDATE changes only contain values for non-primary key fields that are to be modified, only those fields need to match the original values to avoid the SQLITE_CHANGESET_DATA conflict-handler callback.</source>
          <target state="translated">如果找到具有匹配的主键值的行，但是一个或多个修改后的非主键字段包含的值与存储在变更集中的原始行值不同，则使用&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt;作为第二个参数来调用冲突处理程序函数。由于UPDATE更改仅包含要修改的非主键字段的值，因此只有那些字段需要与原始值匹配，以避免SQLITE_CHANGESET_DATA冲突处理程序回调。</target>
        </trans-unit>
        <trans-unit id="35c7138a2b7260bc49d6f60cf430df710c00202b" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the modified non-primary key fields contains a value different from an original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. Since UPDATE changes only contain values for non-primary key fields that are to be modified, only those fields need to match the original values to avoid the SQLITE_CHANGESET_DATA conflict-handler callback.</source>
          <target state="translated">如果找到具有匹配的主键值的行，但是一个或多个修改后的非主键字段包含的值与存储在变更集中的原始行值不同，则使用&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt;作为第二个参数来调用冲突处理程序函数。由于UPDATE更改仅包含要修改的非主键字段的值，因此只有那些字段需要与原始值匹配，以避免SQLITE_CHANGESET_DATA冲突处理程序回调。</target>
        </trans-unit>
        <trans-unit id="1b234b4b89cfdd9943a23340845cb2723771c58a" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the non-primary key fields contains a value different from the original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. If the database table has more columns than are recorded in the changeset, only the values of those non-primary key fields are compared against the current database contents - any trailing database table columns are ignored.</source>
          <target state="translated">如果找到具有匹配的主键值的行，但是一个或多个非主键字段包含的值与存储在变更集中的原始行值不同，则使用&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt;作为第二个参数来调用冲突处理程序函数。如果数据库表中的列数多于更改集中记录的列数，则仅将那些非主键字段的值与当前数据库内容进行比较-忽略任何尾随的数据库表列。</target>
        </trans-unit>
        <trans-unit id="ca3b8d6b7470e9a00b63341bcac487b0076109fe" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the non-primary key fields contains a value different from the original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. If the database table has more columns than are recorded in the changeset, only the values of those non-primary key fields are compared against the current database contents - any trailing database table columns are ignored.</source>
          <target state="translated">如果找到具有匹配的主键值的行，但是一个或多个非主键字段包含的值与存储在变更集中的原始行值不同，则使用&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt;作为第二个参数来调用冲突处理程序函数。如果数据库表中的列数多于更改集中记录的列数，则仅将那些非主键字段的值与当前数据库内容进行比较-忽略任何尾随的数据库表列。</target>
        </trans-unit>
        <trans-unit id="e400ae567f256dbdcc0abe528516e66e2c791942" translate="yes" xml:space="preserve">
          <source>If a schema name is specified as part of an object reference, it must be either &quot;main&quot;, or &quot;temp&quot; or the schema-name of an attached database. Like other SQL identifiers, schema names are case-insensitive. If a schema name is specified, then only that one schema is searched for the named object.</source>
          <target state="translated">如果模式名被指定为对象引用的一部分,那么它必须是 &quot;main&quot;,或者 &quot;temp&quot;,或者是附加数据库的模式名。像其他SQL标识符一样,模式名是不区分大小写的。如果指定了一个模式名,那么只有那个模式会被搜索到。</target>
        </trans-unit>
        <trans-unit id="a287d9b64545db85e7dfa26422162809454f183b" translate="yes" xml:space="preserve">
          <source>If a schema-name is specified, it must be either &quot;main&quot;, &quot;temp&quot;, or the name of an &lt;a href=&quot;lang_attach&quot;&gt;attached database&lt;/a&gt;. In this case the new table is created in the named database. If the &quot;TEMP&quot; or &quot;TEMPORARY&quot; keyword occurs between the &quot;CREATE&quot; and &quot;TABLE&quot; then the new table is created in the temp database. It is an error to specify both a schema-name and the TEMP or TEMPORARY keyword, unless the schema-name is &quot;temp&quot;. If no schema name is specified and the TEMP keyword is not present then the table is created in the main database.</source>
          <target state="translated">如果指定了架构名称，则它必须是&amp;ldquo; main&amp;rdquo;，&amp;ldquo; temp&amp;rdquo;或&lt;a href=&quot;lang_attach&quot;&gt;附加数据库&lt;/a&gt;的名称。在这种情况下，新表将在命名数据库中创建。如果在&amp;ldquo; CREATE&amp;rdquo;和&amp;ldquo; TABLE&amp;rdquo;之间出现&amp;ldquo; TEMP&amp;rdquo;或&amp;ldquo; TEMPORARY&amp;rdquo;关键字，则将在temp数据库中创建新表。同时指定架构名称和TEMP或TEMPORARY关键字是错误的，除非架构名称为&amp;ldquo; temp&amp;rdquo;。如果未指定架构名称且TEMP关键字不存在，则会在主数据库中创建表。</target>
        </trans-unit>
        <trans-unit id="d186fac3c43b0ebe9fb52f2e0bcd9b8dc9321942" translate="yes" xml:space="preserve">
          <source>If a schema-name is specified, then the view is created in the specified database. It is an error to specify both a schema-name and the TEMP keyword on a VIEW, unless the schema-name is &quot;temp&quot;. If no schema name is specified, and the TEMP keyword is not present, the VIEW is created in the main database.</source>
          <target state="translated">如果指定了schema-name,那么视图就会在指定的数据库中创建。如果在VIEW上同时指定了模式名和TEMP关键字,则是错误的,除非模式名是 &quot;temp&quot;。如果没有指定模式名,也没有使用TEMP关键字,则在主数据库中创建VIEW。</target>
        </trans-unit>
        <trans-unit id="5a3b25f9ef77a5c2a55ede994e4212a6c3bae634" translate="yes" xml:space="preserve">
          <source>If a search token (on the right-hand side of the MATCH operator) in &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; begins with &quot;^&quot; then that token must be the first in its field of the document. &lt;b&gt;** Potentially Incompatible Change **&lt;/b&gt;</source>
          <target state="translated">如果&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4中&lt;/a&gt;的搜索令牌（在MATCH运算符的右侧）以&amp;ldquo; ^&amp;rdquo;开头，则该令牌必须是其文档字段中的第一个。&lt;b&gt;**可能不兼容的更改**&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e0b0e745b5660b6e63d47617f06b59c6fe2aec60" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;#sqlite3_changes&quot;&gt;sqlite3_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">如果在运行&lt;a href=&quot;#sqlite3_changes&quot;&gt;sqlite3_changes（）时，&lt;/a&gt;一个单独的线程在同一数据库连接上进行了更改，则返回的值是不可预测的，并且没有意义。</target>
        </trans-unit>
        <trans-unit id="e161385bf705ff3ca3325998e8904218252e0a24" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">如果在运行&lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes（）时，&lt;/a&gt;一个单独的线程在同一数据库连接上进行了更改，则返回的值是不可预测的，并且没有意义。</target>
        </trans-unit>
        <trans-unit id="48949b30f7cc8dfe518df452770028dcf8268e04" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;changes&quot;&gt;sqlite3_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">如果在运行&lt;a href=&quot;changes&quot;&gt;sqlite3_changes（）时，&lt;/a&gt;一个单独的线程在同一数据库连接上进行了更改，则返回的值是不可预测的，并且没有意义。</target>
        </trans-unit>
        <trans-unit id="e69017ebf8db42f4c918537142f058b4e1e4b99c" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">如果在运行&lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes（）时，&lt;/a&gt;一个单独的线程在同一数据库连接上进行了更改，则返回的值是不可预测的，并且没有意义。</target>
        </trans-unit>
        <trans-unit id="67e0dff317f2ea719a9272889d4afc4730b1b5fc" translate="yes" xml:space="preserve">
          <source>If a separate thread performs a new &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; on the same database connection while the &lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function is running and thus changes the last insert &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, then the value returned by &lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; is unpredictable and might not equal either the old or the new last insert &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">如果在运行&lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt;函数时一个单独的线程在同一数据库连接上执行新的&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;，从而更改了最后一个插入&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;，则&lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt;返回的值是不可预测的，并且可能不等于旧的或新的last插入&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f8a05ae1d1d14adcdf537d4865ddc934cf60a0a4" translate="yes" xml:space="preserve">
          <source>If a separate thread performs a new &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; on the same database connection while the &lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function is running and thus changes the last insert &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, then the value returned by &lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; is unpredictable and might not equal either the old or the new last insert &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">如果在运行&lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt;函数时一个单独的线程在同一数据库连接上执行新的&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;，从而更改了最后一个插入&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;，则&lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt;返回的值是不可预测的，并且可能不等于旧的或新的last插入&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c0a40f4902327b395568a304aa57a5c4039b9e5" translate="yes" xml:space="preserve">
          <source>If a single database file has multiple links (either hard or soft links) then that is just another way of saying that the file has multiple names. If two or more processes open the database using different names, then they will use different rollback journals and WAL files. That means that if one process crashes, the other process will be unable to recover the transaction in progress because it will be looking in the wrong place for the appropriate journal.</source>
          <target state="translated">如果一个数据库文件有多个链接(无论是硬链接还是软链接),那么这只是文件有多个名字的另一种说法。如果两个或多个进程使用不同的名称打开数据库,那么它们将使用不同的回滚日记和WAL文件。这意味着,如果一个进程崩溃,另一个进程将无法恢复正在进行的事务,因为它将在错误的地方寻找合适的日志。</target>
        </trans-unit>
        <trans-unit id="54992194ecdfbf1a36948d0111a0401fc51b1ec9" translate="yes" xml:space="preserve">
          <source>If a single row is affected by more than one operation within a session, then the change is considered indirect if all operations meet the criteria for an indirect change above, or direct otherwise.</source>
          <target state="translated">如果一条记录在一个会话中受到一个以上操作的影响,那么如果所有的操作都符合上述间接更改的标准,那么该更改被认为是间接的,否则就是直接的。</target>
        </trans-unit>
        <trans-unit id="8aed35bc8fc658c89e5539bc9b828e9558656314" translate="yes" xml:space="preserve">
          <source>If a statement modifies the contents of the database so that an immediate foreign key constraint is in violation at the conclusion the statement, an exception is thrown and the effects of the statement are reverted. By contrast, if a statement modifies the contents of the database such that a deferred foreign key constraint is violated, the violation is not reported immediately. Deferred foreign key constraints are not checked until the transaction tries to &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;. For as long as the user has an open transaction, the database is allowed to exist in a state that violates any number of deferred foreign key constraints. However, &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; will fail as long as foreign key constraints remain in violation.</source>
          <target state="translated">如果一条语句修改了数据库的内容，从而在该语句结束时违反了立即外键约束，则将引发异常，并还原该语句的作用。相反，如果一条语句修改了数据库的内容，从而违反了延迟的外键约束，则不会立即报告该违反。在事务尝试&lt;a href=&quot;lang_transaction&quot;&gt;提交&lt;/a&gt;之前，不检查延迟的外键约束。只要用户有未清交易，就允许数据库以违反任何数量的延迟外键约束的状态存在。但是，只要仍然违反外键约束，&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;就会失败。</target>
        </trans-unit>
        <trans-unit id="4a9fe68ac2f3c48ea32a43f2c5cf9be89d342ee4" translate="yes" xml:space="preserve">
          <source>If a subquery cannot be &lt;a href=&quot;optoverview#flattening&quot;&gt;flattened&lt;/a&gt; into the outer query, it might still be possible to enhance performance by &quot;pushing down&quot; WHERE clause terms from the outer query into the subquery. Consider an example:</source>
          <target state="translated">如果不能将子查询展&lt;a href=&quot;optoverview#flattening&quot;&gt;平&lt;/a&gt;到外部查询中，则仍然有可能通过将WHERE子句项从外部查询&amp;ldquo;推入&amp;rdquo;子查询中来提高性能。考虑一个例子：</target>
        </trans-unit>
        <trans-unit id="cfbdc72faddc3dd92eaf2d66d72d9166e0ce65e3" translate="yes" xml:space="preserve">
          <source>If a system failure occurs at any time after a &quot;delete file&quot; operation (call to the VFS xDelete() method) returns successfully, it is assumed that the file-system will not contain the deleted file following system recovery.</source>
          <target state="translated">如果在 &quot;删除文件 &quot;操作(调用VFS xDelete()方法)成功返回后的任何时候发生系统故障,则假设在系统恢复后,文件系统将不包含删除的文件。</target>
        </trans-unit>
        <trans-unit id="c32e1e0b557aefde59c28d931cf3e5d6733099fd" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during a &quot;delete file&quot; operation, it is assumed that following system recovery the file-system will either contain the file being deleted in the state it was in before the operation was attempted, or not contain the file at all. It is assumed that it is not possible for the file to have become corrupted purely as a result of a failure occurring during a &quot;delete file&quot; operation.</source>
          <target state="translated">如果在 &quot;删除文件 &quot;操作中发生系统故障,假定在系统恢复后,文件系统将以尝试操作前的状态包含被删除的文件,或者根本不包含该文件。假设文件不可能纯粹由于 &quot;删除文件 &quot;操作期间发生的故障而损坏。</target>
        </trans-unit>
        <trans-unit id="91f96ef24748138cdd82c09ceabe7f648ae9cf43" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;create file&quot; operation, but before the created file has been</source>
          <target state="translated">如果在 &quot;创建文件 &quot;操作期间或之后,但在所创建的文件尚未被</target>
        </trans-unit>
        <trans-unit id="1fcfee495c57582bc4c6e63019680717056464ec" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;truncate file&quot; operation, but before the truncated file has been</source>
          <target state="translated">如果在 &quot;截断文件 &quot;操作期间或之后,但在截断的文件被截断之前,发生系统故障。</target>
        </trans-unit>
        <trans-unit id="e3c60bc044d7ebf2be0e926e292ed7263d6ed54a" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;write file&quot; operation that causes the file to grow, but before the corresponding file has been</source>
          <target state="translated">如果在 &quot;写文件 &quot;操作期间或之后发生系统故障,导致文件增长,但在相应的文件被</target>
        </trans-unit>
        <trans-unit id="0de8e98595413448f2b535870f8da207b8048237" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;write file&quot; operation, but before the corresponding file has been</source>
          <target state="translated">如果在 &quot;写文件 &quot;操作期间或之后,但在相应的文件被写入之前,发生系统故障。</target>
        </trans-unit>
        <trans-unit id="12d84c274c03171c71b26275c99f75f3392362a6" translate="yes" xml:space="preserve">
          <source>If a system failure occurs on a system that supports the</source>
          <target state="translated">如果支持该系统的系统发生系统故障。</target>
        </trans-unit>
        <trans-unit id="70f739b455c168080412690c97f5940222b8f766" translate="yes" xml:space="preserve">
          <source>If a system supports</source>
          <target state="translated">如果一个系统支持</target>
        </trans-unit>
        <trans-unit id="ec9800aa0fd4fbf6e94d5e57566c8304e2f2782b" translate="yes" xml:space="preserve">
          <source>If a system supports the</source>
          <target state="translated">如果一个系统支持</target>
        </trans-unit>
        <trans-unit id="16f55a3959edd0a92c0395b9cf4c3468da074f4f" translate="yes" xml:space="preserve">
          <source>If a table contains a column of type &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, then that column becomes an alias for the ROWID. You can then access the ROWID using any of four different names, the original three names described above or the name given to the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column. All these names are aliases for one another and work equally well in any context.</source>
          <target state="translated">如果表包含&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;类型的列，则该列将成为ROWID的别名。然后，您可以使用以下四个不同的名称中的任何一个来访问ROWID，上述三个原始名称或为&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列指定的名称。所有这些名称都是彼此的别名，并且在任何情况下都可以很好地工作。</target>
        </trans-unit>
        <trans-unit id="a73b6736040e74c7d625fd213eca9757c75eee19" translate="yes" xml:space="preserve">
          <source>If a table has a single column primary key and the declared type of that column is &quot;INTEGER&quot; and the table is not a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, then the column is known as an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;. See &lt;a href=&quot;lang_createtable#rowid&quot;&gt;below&lt;/a&gt; for a description of the special properties and behaviors associated with an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;.</source>
          <target state="translated">如果表具有单个列主键，并且该列的声明类型为&amp;ldquo; INTEGER&amp;rdquo;，并且该表不是&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表，则该列称为&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;。有关与&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;关联的特殊属性和行为的说明，请参见&lt;a href=&quot;lang_createtable#rowid&quot;&gt;下文&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5e353db8a7a970978b864076f23349bbe29b3cd1" translate="yes" xml:space="preserve">
          <source>If a term in X is of the form &quot;z IS NOT NULL&quot; and if a term in W is a comparison operator on &quot;z&quot; other than &quot;IS&quot;, then those terms match.</source>
          <target state="translated">如果X中的术语是 &quot;z IS NOT NULL &quot;的形式,如果W中的术语是 &quot;IS &quot;以外的 &quot;z &quot;的比较运算符,那么这些术语是匹配的。</target>
        </trans-unit>
        <trans-unit id="d7704041f8ff8a11a4c662eef3d671025a3e5ebe" translate="yes" xml:space="preserve">
          <source>If a term of the WHERE clause is of the following form:</source>
          <target state="translated">如果WHERE子句的术语是以下形式:</target>
        </trans-unit>
        <trans-unit id="e5d671a1040d0448cbcd3997833359da102571a4" translate="yes" xml:space="preserve">
          <source>If a transaction involves multiple databases, then a more complex commit sequence is used, as follows:</source>
          <target state="translated">如果一个事务涉及多个数据库,那么就会使用更复杂的提交序列,如下所示。</target>
        </trans-unit>
        <trans-unit id="1b08d45fd51c4591fce14d3b424e9dccc579bef5" translate="yes" xml:space="preserve">
          <source>If a transaction is aborted due to an application crash, an operating system crash, or a hardware power failure or crash, then the database may be left in an inconsistent state. The next time SQLite attempts to open the database file, the presence of the rollback journal file will be detected and the journal will be automatically played back to restore the database to its state at the start of the incomplete transaction.</source>
          <target state="translated">如果由于应用程序崩溃、操作系统崩溃或硬件电源故障或崩溃而导致事务中止,那么数据库可能会处于不一致的状态。下次SQLite试图打开数据库文件时,将检测到回滚日志文件的存在,并自动回放日志,将数据库恢复到未完成事务开始时的状态。</target>
        </trans-unit>
        <trans-unit id="b139c7ece8944c0ce3ad448cfb0c14ea14a36c67" translate="yes" xml:space="preserve">
          <source>If a write-transaction is open on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D when the &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk. A dirty page may be in use if a database cursor created by an active SQL statement is reading from it, or if it is page 1 of a database file (page 1 is always &quot;in use&quot;). The &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface flushes caches for all schemas - &quot;main&quot;, &quot;temp&quot;, and any &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases.</source>
          <target state="translated">如果在调用&lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush（D）&lt;/a&gt;接口时在&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上打开了写入事务，则分页器高速缓存中当前未使用的所有脏页都将写到磁盘中。如果正在读取活动SQL语句创建的数据库游标，或者它是数据库文件的第1页（第1页始终为&amp;ldquo;使用中&amp;rdquo;），则可能正在使用脏页。所述&lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush（d）&lt;/a&gt;接口刷新用于所有模式的高速缓存- &amp;ldquo;主&amp;rdquo;，&amp;ldquo;TEMP&amp;rdquo;，以及任何&lt;a href=&quot;lang_attach&quot;&gt;附接&lt;/a&gt;的数据库。</target>
        </trans-unit>
        <trans-unit id="94598ac271e5cdca4a0d9c950ece2e2fde3c85ae" translate="yes" xml:space="preserve">
          <source>If a write-transaction is open on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D when the &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk. A dirty page may be in use if a database cursor created by an active SQL statement is reading from it, or if it is page 1 of a database file (page 1 is always &quot;in use&quot;). The &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface flushes caches for all schemas - &quot;main&quot;, &quot;temp&quot;, and any &lt;a href=&quot;../lang_attach&quot;&gt;attached&lt;/a&gt; databases.</source>
          <target state="translated">如果在调用&lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush（D）&lt;/a&gt;接口时在&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上打开了写入事务，则分页器高速缓存中当前未使用的所有脏页都将写到磁盘中。如果正在读取活动SQL语句创建的数据库游标，或者它是数据库文件的第1页（第1页始终为&amp;ldquo;使用中&amp;rdquo;），则可能正在使用脏页。所述&lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush（d）&lt;/a&gt;接口刷新用于所有模式的高速缓存- &amp;ldquo;主&amp;rdquo;，&amp;ldquo;TEMP&amp;rdquo;，以及任何&lt;a href=&quot;../lang_attach&quot;&gt;附接&lt;/a&gt;的数据库。</target>
        </trans-unit>
        <trans-unit id="9d687ea67d2673f11d5b429c0195a169c2caa77a" translate="yes" xml:space="preserve">
          <source>If a write-transaction is started and the Vdbe.usesStmtJournal flag is true (this flag is set if the Vdbe may modify more than one row and may throw an ABORT exception), a statement transaction may also be opened. More specifically, a statement transaction is opened iff the database connection is currently not in autocommit mode, or if there are other active statements. A statement transaction allows the changes made by this VDBE to be rolled back after an error without having to roll back the entire transaction. If no error is encountered, the statement transaction will automatically commit when the VDBE halts.</source>
          <target state="translated">如果一个写事务被启动,并且Vdbe.usesStmtJournal标志为真(如果Vdbe可能修改多条记录,并且可能抛出ABORT异常,则设置该标志),一个语句事务也可能被打开。更具体地说,如果数据库连接当前没有处于自动提交模式,或者有其他活动的语句,语句事务就会被打开。语句事务允许在出错后回滚该VDBE所做的更改,而不必回滚整个事务。如果没有遇到错误,当VDBE停止时,语句事务将自动提交。</target>
        </trans-unit>
        <trans-unit id="7e874d6b40d57619d9fa5fb8dd75a92de53ed059" translate="yes" xml:space="preserve">
          <source>If all three of the steps enumerated above are executed successfully, then it is safe to modify the content of the</source>
          <target state="translated">如果上面列举的三个步骤都能成功执行,那么就可以安全地对</target>
        </trans-unit>
        <trans-unit id="8a9cfb8256efd43eaa74ef64ff226cfbf427865f" translate="yes" xml:space="preserve">
          <source>If an &quot;ALTER TABLE ... RENAME TO&quot; command is used to rename a table that is the parent table of one or more foreign key constraints, the definitions of the foreign key constraints are modified to refer to the parent table by its new name. The text of the child CREATE TABLE statement or statements stored in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt; are modified to reflect the new parent table name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76124bb023821e31ac6f5cbf1f8b54083a3ec643" translate="yes" xml:space="preserve">
          <source>If an &quot;ALTER TABLE ... RENAME TO&quot; command is used to rename a table that is the parent table of one or more foreign key constraints, the definitions of the foreign key constraints are modified to refer to the parent table by its new name. The text of the child CREATE TABLE statement or statements stored in the sqlite_master table are modified to reflect the new parent table name.</source>
          <target state="translated">如果使用 &quot;ALTER TABLE ...RENAME TO &quot;命令用来重命名一个表,而这个表是一个或多个外键约束条件的父表,那么外键约束条件的定义就会被修改为用它的新名称来引用父表。子CREATE TABLE语句或存储在sqlite_master表中的语句的文本被修改为反映新的父表名。</target>
        </trans-unit>
        <trans-unit id="7603e9a69b7a72c62bbc679327133633953ff9aa" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is destroyed while a transaction is open, the transaction is automatically rolled back.</source>
          <target state="translated">如果在打开事务时销毁了&lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象，则该事务将自动回滚。</target>
        </trans-unit>
        <trans-unit id="53a3481d0fa9e30b2f0d27a6044ee94e1a62bb9b" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; occurs within a trigger then this routine will return the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the inserted row as long as the trigger is running. Once the trigger program ends, the value returned by this routine reverts to what it was before the trigger was fired.</source>
          <target state="translated">如果在触发器内发生&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;，则只要触发器正在运行，此例程将返回插入行的&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。触发器程序结束后，此例程返回的值将还原为触发触发器之前的值。</target>
        </trans-unit>
        <trans-unit id="877e1b4a7430ba11b48b32c5598ad0c65dc34442" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; occurs within a trigger then this routine will return the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the inserted row as long as the trigger is running. Once the trigger program ends, the value returned by this routine reverts to what it was before the trigger was fired.</source>
          <target state="translated">如果在触发器内发生&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;，则只要触发器正在运行，此例程将返回插入行的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。触发器程序结束后，此例程返回的值将还原为触发触发器之前的值。</target>
        </trans-unit>
        <trans-unit id="b95cb40fc8352b696796b3bff79e2f006b1ce07a" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is destroyed while a transaction is open, the transaction is automatically rolled back.</source>
          <target state="translated">如果在打开事务时销毁了&lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象，则该事务将自动回滚。</target>
        </trans-unit>
        <trans-unit id="9f62d9384e44621989efc3c00f1a3ba721b2e39d" translate="yes" xml:space="preserve">
          <source>If an FTS5 table is configured with columnsize=0 but is not a &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless table&lt;/a&gt;, the xColumnSize API function still works, but runs much more slowly. In this case, instead of reading the value to return directly from the database, it reads the text value itself and count the tokens within it on demand.</source>
          <target state="translated">如果FTS5表配置为columnize = 0，但不是无内容&lt;a href=&quot;fts5#contentless_tables&quot;&gt;表&lt;/a&gt;，则xColumnSize API函数仍然有效，但运行速度要慢得多。在这种情况下，它不是读取值直接从数据库返回，而是读取文本值本身并根据需要对其中的令牌进行计数。</target>
        </trans-unit>
        <trans-unit id="a593df8166351f80d07eb58cb262614d9dbc8634" translate="yes" xml:space="preserve">
          <source>If an INSERT statement attempts to insert a NULL value into a rowid or integer primary key column, the system chooses an integer value to use as the rowid automatically. A detailed description of how this is done is provided &lt;a href=&quot;autoinc&quot;&gt;separately&lt;/a&gt;.</source>
          <target state="translated">如果INSERT语句尝试将NULL值插入到rowid或整数主键列中，则系统会自动选择一个整数值用作rowid。&lt;a href=&quot;autoinc&quot;&gt;单独&lt;/a&gt;提供了有关此操作的详细说明。</target>
        </trans-unit>
        <trans-unit id="ba4158b1467dce3a1f2ceab9abb8de00b0fe4463" translate="yes" xml:space="preserve">
          <source>If an ORDER BY clause is present, it determines the order in which rows are extracted from the queue in step 2a. If there is no ORDER BY clause, then the order in which rows are extracted is undefined. (In the current implementation, the queue becomes a FIFO if the ORDER BY clause is omitted, but applications should not depend on that fact since it might change.)</source>
          <target state="translated">如果存在ORDER BY子句,它决定了在步骤2a中从队列中提取行的顺序。如果没有ORDER BY子句,那么提取行的顺序是没有定义的。(在当前的实现中,如果省略了ORDER BY子句,队列就会变成一个FIFO,但是应用程序不应该依赖于这个事实,因为它可能会改变。)</target>
        </trans-unit>
        <trans-unit id="22141c686821647d4155d6b151a8d8fa154cd1a8" translate="yes" xml:space="preserve">
          <source>If an SQL operation is very nearly finished at the time when sqlite3_interrupt() is called, then it might not have an opportunity to be interrupted and might continue to completion.</source>
          <target state="translated">如果一个SQL操作在调用sqlite3_interrupt()时已经非常接近完成,那么它可能没有机会被中断,可能会继续完成。</target>
        </trans-unit>
        <trans-unit id="923eabd2cf996c975383b0dccd3e5fb8dc063dde" translate="yes" xml:space="preserve">
          <source>If an SQL statement is limited to be a million bytes in length, then obviously you will not be able to insert multi-million byte strings by embedding them as literals inside of INSERT statements. But you should not do that anyway. Use host &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; for your data. Prepare short SQL statements like this:</source>
          <target state="translated">如果一个SQL语句的长度限制为一百万个字节，那么很显然，您无法通过将它们作为文字嵌入到INSERT语句中来插入数百万个字节的字符串。但是无论如何，您都不应这样做。对数据使用主机&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;。准备像这样的简短SQL语句：</target>
        </trans-unit>
        <trans-unit id="a519000750401db43c985f6fefc862d71c74bede" translate="yes" xml:space="preserve">
          <source>If an SQL table is created using the &quot;WITHOUT ROWID&quot; clause at the end of its CREATE TABLE statement, then that table is a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and uses a different on-disk representation. A WITHOUT ROWID table uses an index b-tree rather than a table b-tree for storage. The key for each entry in the WITHOUT ROWID b-tree is a record composed of the columns of the PRIMARY KEY followed by all remaining columns of the table. The primary key columns appear in the order they they were declared in the PRIMARY KEY clause and the remaining columns appear in the order they occur in the CREATE TABLE statement.</source>
          <target state="translated">如果在其CREATE TABLE语句的末尾使用&amp;ldquo; WITHOUT ROWID&amp;rdquo;子句创建了SQL表，则该表是&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表，并使用不同的磁盘表示形式。WITHOUT ROWID表使用索引b树而不是表b树进行存储。WITHOUT ROWID b树中每个条目的键都是一条记录，该记录由PRIMARY KEY的各列组成，后面是表的所有其余列。主键列按它们在PRIMARY KEY子句中声明的顺序显示，其余列按它们在CREATE TABLE语句中出现的顺序显示。</target>
        </trans-unit>
        <trans-unit id="7a1f15ef308e23ec2fc80a29e25882265ebf0786" translate="yes" xml:space="preserve">
          <source>If an UPDATE statement attempts to set an integer primary key or rowid column to a NULL or blob value, or to a string or real value that cannot be losslessly converted to an integer, a &quot;datatype mismatch&quot; error occurs and the statement is aborted. If an INSERT statement attempts to insert a blob value, or a string or real value that cannot be losslessly converted to an integer into an integer primary key or rowid column, a &quot;datatype mismatch&quot; error occurs and the statement is aborted.</source>
          <target state="translated">如果一条UPDATE语句试图将一个整数主键或rowid列设置为NULL或blob值,或者设置为一个无法无损转换为整数的字符串或实值,那么就会发生 &quot;数据类型不匹配 &quot;错误,并中止该语句。如果INSERT语句试图将一个blob值,或者一个不能无损转换为整数的字符串或实值插入到一个整数主键或rowid列中,就会发生 &quot;数据类型不匹配 &quot;错误,语句被中止。</target>
        </trans-unit>
        <trans-unit id="284b34da69fbf9cd89926df318af7634184253b9" translate="yes" xml:space="preserve">
          <source>If an UPDATE statement has a LIMIT clause, the maximum number of rows that will be updated is found by evaluating the accompanying expression and casting it to an integer value. A negative value is interpreted as &quot;no limit&quot;.</source>
          <target state="translated">如果UPDATE语句有一个LIMIT子句,则通过评估所附的表达式并将其转换为一个整数值来找到将被更新的最大行数。负值被解释为 &quot;没有限制&quot;。</target>
        </trans-unit>
        <trans-unit id="35654cca0e06875d8f71c06cdb825a502007ac27" translate="yes" xml:space="preserve">
          <source>If an application issues a SELECT statement on a single table like &quot;</source>
          <target state="translated">如果一个应用程序在单个表上发出一个SELECT语句,如&quot;</target>
        </trans-unit>
        <trans-unit id="3c9847a3fc8345f21ef2aae877b6da29936db6dc" translate="yes" xml:space="preserve">
          <source>If an application puts SQLite in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; using the pragma:</source>
          <target state="translated">如果应用程序使用编译指示将SQLite置于&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;独占锁定模式&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="16930c87a89e5aa4dacec21b97a534c286412312" translate="yes" xml:space="preserve">
          <source>If an application using asynchronous IO executes transactions in quick succession, other database users may be effectively locked out of the database. This is because when a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; is executed, a database lock is established immediately. But when the corresponding COMMIT or ROLLBACK occurs, the lock is not released until the relevant part of the write-queue has been flushed through. As a result, if a COMMIT is followed by a BEGIN before the write-queue is flushed through, the database is never unlocked,preventing other processes from accessing the database.</source>
          <target state="translated">如果使用异步IO的应用程序快速连续执行事务，则可能会将其他数据库用户有效地锁定在数据库之外。这是因为执行&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN时&lt;/a&gt;会立即建立数据库锁定。但是，当发生相应的COMMIT或ROLLBACK时，直到刷新了写入队列的相关部分，该锁才会释放。因此，如果在刷新写入队列之前在COMMIT之后跟随BEGIN，则数据库永远不会解锁，从而防止了其他进程访问数据库。</target>
        </trans-unit>
        <trans-unit id="dec67a679cc10b4fb4ca0df679f1b42a8a809bf0" translate="yes" xml:space="preserve">
          <source>If an attempt to acquire a</source>
          <target state="translated">如果试图获得</target>
        </trans-unit>
        <trans-unit id="ae2dad7a2ac6f9639d4f707a82a9b585c9a56bd8" translate="yes" xml:space="preserve">
          <source>If an attempt to upgrade to an</source>
          <target state="translated">如果试图升级到一个</target>
        </trans-unit>
        <trans-unit id="0f4ee50fd2b5b886cf93345554e2cb331273f09d" translate="yes" xml:space="preserve">
          <source>If an error (e.g. an OOM condition) occurs within this function, the auxiliary data is set to NULL and an error code returned. If the xDelete parameter was not NULL, it is invoked on the auxiliary data pointer before returning.</source>
          <target state="translated">如果该函数内发生错误(如OOM条件),则将辅助数据设为NULL,并返回错误代码。如果xDelete参数不是NULL,则在返回前对辅助数据指针进行调用。</target>
        </trans-unit>
        <trans-unit id="8045cc0ef3fd13ca44d5e4369a94674b9f7300cd" translate="yes" xml:space="preserve">
          <source>If an error occurs in any of the three main backup API routines then the &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; and &lt;a href=&quot;c3ref/errcode&quot;&gt;message&lt;/a&gt; are attached to the destination &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. Additionally, if &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; encounters an error, then the &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned by both the &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; call itself, and by the subsequent call to &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt;. So a call to &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt; does not overwrite an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; stored in the destination &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; by &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt;. This feature is used in the example code to reduce amount of error handling required. The return values of the &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; and &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt; calls are ignored and the error code indicating the success or failure of the copy operation collected from the destination &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; afterward.</source>
          <target state="translated">如果这三个主要备份API例程中的任何一个发生错误，则&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;和&lt;a href=&quot;c3ref/errcode&quot;&gt;消息&lt;/a&gt;将附加到目标&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;。此外，如果&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（）&lt;/a&gt;遇到一个错误，则该&lt;a href=&quot;rescode&quot;&gt;错误码&lt;/a&gt;是由两个返回&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（）&lt;/a&gt;调用自身通过到后续呼叫，并&lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish（） &lt;/a&gt;。因此，调用&lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish（）&lt;/a&gt;不会覆盖由&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（）&lt;/a&gt;存储在目标&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接中&lt;/a&gt;的&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。。示例代码中使用了此功能，以减少所需的错误处理量。&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（）&lt;/a&gt;和&lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish（）&lt;/a&gt;调用的返回值将被忽略，并且此后指示从目标&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;收集的复制操作成功或失败的错误代码。</target>
        </trans-unit>
        <trans-unit id="e8416d9f169797cd1d1df3d689a0f3981d1e1914" translate="yes" xml:space="preserve">
          <source>If an error occurs while evaluating the SQL statements passed into sqlite3_exec(), then execution of the current statement stops and subsequent statements are skipped. If the 5th parameter to sqlite3_exec() is not NULL then any error message is written into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and passed back through the 5th parameter. To avoid memory leaks, the application should invoke &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; on error message strings returned through the 5th parameter of sqlite3_exec() after the error message string is no longer needed. If the 5th parameter to sqlite3_exec() is not NULL and no errors occur, then sqlite3_exec() sets the pointer in its 5th parameter to NULL before returning.</source>
          <target state="translated">如果在评估传递给sqlite3_exec（）的SQL语句时发生错误，则当前语句的执行将停止，随后的语句将被跳过。如果sqlite3_exec（）的第5个参数不为NULL，则任何错误消息都会写入从&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;获得的内存中，并通过第5个参数传递回去。为避免内存泄漏，应用程序应在不再需要错误消息字符串之后，对通过sqlite3_exec（）的第5个参数返回的错误消息字符串调用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;。如果sqlite3_exec（）的第5个参数不为NULL并且没有错误发生，则sqlite3_exec（）将其第5个参数中的指针设置为NULL，然后再返回。</target>
        </trans-unit>
        <trans-unit id="67c739deca1fc659fe9011cffdf430f71e9a737b" translate="yes" xml:space="preserve">
          <source>If an error occurs while evaluating the SQL statements passed into sqlite3_exec(), then execution of the current statement stops and subsequent statements are skipped. If the 5th parameter to sqlite3_exec() is not NULL then any error message is written into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and passed back through the 5th parameter. To avoid memory leaks, the application should invoke &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; on error message strings returned through the 5th parameter of sqlite3_exec() after the error message string is no longer needed. If the 5th parameter to sqlite3_exec() is not NULL and no errors occur, then sqlite3_exec() sets the pointer in its 5th parameter to NULL before returning.</source>
          <target state="translated">如果在评估传递给sqlite3_exec（）的SQL语句时发生错误，则当前语句的执行将停止，随后的语句将被跳过。如果sqlite3_exec（）的第5个参数不为NULL，则任何错误消息都会写入从&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;获得的内存中，并通过第5个参数传递回去。为避免内存泄漏，应用程序应在不再需要错误消息字符串之后，对通过sqlite3_exec（）的第5个参数返回的错误消息字符串调用&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;。如果sqlite3_exec（）的第5个参数不为NULL并且没有错误发生，则sqlite3_exec（）将其第5个参数中的指针设置为NULL，然后再返回。</target>
        </trans-unit>
        <trans-unit id="194a0b44e46a56e474b265407cd79a961ab1ee3b" translate="yes" xml:space="preserve">
          <source>If an error occurs within sqlite3_backup_init(D,N,S,M), then NULL is returned and an error code and error message are stored in the destination &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D. The error code and message for the failed call to sqlite3_backup_init() can be retrieved using the &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;, and/or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; functions. A successful call to sqlite3_backup_init() returns a pointer to an &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object. The &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object may be used with the sqlite3_backup_step() and sqlite3_backup_finish() functions to perform the specified backup operation.</source>
          <target state="translated">如果在sqlite3_backup_init（D，N，S，M）中发生错误，则返回NULL，并且错误代码和错误消息存储在目标&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D中。失败调用sqlite3_backup_init（）的错误代码和消息可以可以使用&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;和/或&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16（）&lt;/a&gt;函数进行检索。成功调用sqlite3_backup_init（）会返回一个指向&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象的指针。所述&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象可以与sqlite3_backup_step（）和sqlite3_backup_finish（）函数被用于执行指定的备份操作。</target>
        </trans-unit>
        <trans-unit id="1200818faf5a8fe2f6854c6a6851d33b2f623b3d" translate="yes" xml:space="preserve">
          <source>If an error occurs within sqlite3_backup_init(D,N,S,M), then NULL is returned and an error code and error message are stored in the destination &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D. The error code and message for the failed call to sqlite3_backup_init() can be retrieved using the &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt;, &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;, and/or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; functions. A successful call to sqlite3_backup_init() returns a pointer to an &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object. The &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object may be used with the sqlite3_backup_step() and sqlite3_backup_finish() functions to perform the specified backup operation.</source>
          <target state="translated">如果在sqlite3_backup_init（D，N，S，M）中发生错误，则返回NULL，并且错误代码和错误消息存储在目标&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D中。失败调用sqlite3_backup_init（）的错误代码和消息可以可以使用&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;，&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;和/或&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16（）&lt;/a&gt;函数进行检索。成功调用sqlite3_backup_init（）会返回一个指向&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象的指针。所述&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象可以与sqlite3_backup_step（）和sqlite3_backup_finish（）函数被用于执行指定的备份操作。</target>
        </trans-unit>
        <trans-unit id="100ded69e0a780b44961df68d1032c0e7c075797" translate="yes" xml:space="preserve">
          <source>If an error occurs, an SQLite error code is returned and the output variables (*pnData) and (*ppData) are set to 0. Otherwise, SQLITE_OK is returned and the output variables are set to the size of and a pointer to the output buffer, respectively. In this case it is the responsibility of the caller to eventually free the buffer using a call to sqlite3_free().</source>
          <target state="translated">如果发生错误,返回SQLite错误代码,并将输出变量(*pnData)和(*ppData)设置为0,否则返回SQLITE_OK,并将输出变量分别设置为输出缓冲区的大小和指针。在这种情况下,调用者有责任使用对sqlite3_free()的调用最终释放缓冲区。</target>
        </trans-unit>
        <trans-unit id="622e26e115262f02ac7f60da2462323cdc540b9f" translate="yes" xml:space="preserve">
          <source>If an error occurs, an SQLite error code is returned. Possible error codes include SQLITE_CORRUPT (if the changeset buffer is corrupt) or SQLITE_NOMEM.</source>
          <target state="translated">如果发生错误,将返回一个SQLite错误代码。可能的错误代码包括SQLITE_CORRUPT(如果变化集缓冲区损坏)或SQLITE_NOMEM。</target>
        </trans-unit>
        <trans-unit id="e455ebdd54ae8a16893e6de74ee6f1db7c5e35d7" translate="yes" xml:space="preserve">
          <source>If an error was encountered within a call to an sqlite3changeset_xxx() function (for example an &lt;a href=&quot;../rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; in &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; or an &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; in &lt;a href=&quot;sqlite3changeset_new&quot;&gt;sqlite3changeset_new()&lt;/a&gt;) then an error code corresponding to that error is returned by this function. Otherwise, SQLITE_OK is returned. This is to allow the following pattern (pseudo-code):</source>
          <target state="translated">如果已到sqlite3changeset_xxx（）函数的调用（例如一个内遇到一个错误&lt;a href=&quot;../rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt;在&lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）&lt;/a&gt;或&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;在&lt;a href=&quot;sqlite3changeset_new&quot;&gt;sqlite3changeset_new（） &lt;/a&gt;），则对应于该错误的错误代码由该函数返回。否则，返回SQLITE_OK。这是为了允许以下模式（伪代码）：</target>
        </trans-unit>
        <trans-unit id="1bc5bca387ff960fe9687401573a47507a4fa49f" translate="yes" xml:space="preserve">
          <source>If an error was encountered within a call to an sqlite3changeset_xxx() function (for example an &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; in &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; or an &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; in &lt;a href=&quot;#sqlite3changeset_new&quot;&gt;sqlite3changeset_new()&lt;/a&gt;) then an error code corresponding to that error is returned by this function. Otherwise, SQLITE_OK is returned. This is to allow the following pattern (pseudo-code):</source>
          <target state="translated">如果已到sqlite3changeset_xxx（）函数的调用（例如一个内遇到一个错误&lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt;在&lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）&lt;/a&gt;或&lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;在&lt;a href=&quot;#sqlite3changeset_new&quot;&gt;sqlite3changeset_new（） &lt;/a&gt;），则对应于该错误的错误代码由该函数返回。否则，返回SQLITE_OK。这是为了允许以下模式（伪代码）：</target>
        </trans-unit>
        <trans-unit id="1b680ceb7d64040ce2b6564485c5ca5b1c9689a0" translate="yes" xml:space="preserve">
          <source>If an fts5vocab table is created in the temp database, it may be associated with an FTS5 table in any attached database. In order to attach the fts5vocab table to an FTS5 table located in a database other than &quot;temp&quot;, the name of the database is inserted before the FTS5 table name in the CREATE VIRTUAL TABLE arguments. For example:</source>
          <target state="translated">如果在临时数据库中创建了fts5vocab表,那么它可以与任何附加数据库中的FTS5表相关联。为了将fts5vocab表关联到位于 &quot;temp &quot;以外的数据库中的FTS5表,在CREATE VIRTUAL TABLE参数中的FTS5表名之前插入数据库的名称。例如</target>
        </trans-unit>
        <trans-unit id="3334fd5a8f49d3b3b23387e0ded39340f08eab83" translate="yes" xml:space="preserve">
          <source>If an index is available on the ORDER BY column, that index can be used for sorting. Consider the request for all items sorted by &quot;fruit&quot;:</source>
          <target state="translated">如果ORDER BY列上有一个索引,那么该索引就可以用于排序。考虑要求对所有物品按 &quot;水果 &quot;排序。</target>
        </trans-unit>
        <trans-unit id="7ff3ecb138d9749f1bf1bb734a03098e601b851c" translate="yes" xml:space="preserve">
          <source>If an index is created using a statement like this:</source>
          <target state="translated">如果使用这样的语句创建一个索引。</target>
        </trans-unit>
        <trans-unit id="19ed5776fff64746115879da20e80724a2114442" translate="yes" xml:space="preserve">
          <source>If an instance-list grows so large that it exceeds the &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; limit, FTS3/4 is unable to handle it. FTS5 does not have this problem.</source>
          <target state="translated">如果实例列表太大而超过了&lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;限制，则FTS3 / 4无法处理它。FTS5没有此问题。</target>
        </trans-unit>
        <trans-unit id="e669868d5fcfe552cb1dbbc9c2998f5505f629e6" translate="yes" xml:space="preserve">
          <source>If an interface fails with SQLITE_MISUSE, that means the interface was invoked incorrectly by the application. In that case, the error code and message may or may not be set.</source>
          <target state="translated">如果一个接口出现SQLITE_MISUSE失败,这意味着该接口被应用程序错误地调用。在这种情况下,错误代码和消息可能会被设置,也可能不会。</target>
        </trans-unit>
        <trans-unit id="582fb0780f4838faf9f9c1524bd108b2fc64370c" translate="yes" xml:space="preserve">
          <source>If an out-of-memory error occurs, then the return value from these routines is the same as if the column had contained an SQL NULL value. Valid SQL NULL returns can be distinguished from out-of-memory errors by invoking the &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; immediately after the suspect return value is obtained and before any other SQLite interface is called on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">如果发生内存不足错误，则这些例程的返回值与列包含SQL NULL值的返回值相同。通过在获取可疑返回值之后并且在同一&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;上调用任何其他SQLite接口之前立即调用&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（），&lt;/a&gt;可以将有效的SQL NULL返回与内存不足错误区分开。</target>
        </trans-unit>
        <trans-unit id="5851016a3fb15ec26147b80722e832005884d3e4" translate="yes" xml:space="preserve">
          <source>If an out-of-memory error occurs, then the return value from these routines is the same as if the column had contained an SQL NULL value. Valid SQL NULL returns can be distinguished from out-of-memory errors by invoking the &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; immediately after the suspect return value is obtained and before any other SQLite interface is called on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">如果发生内存不足错误，则这些例程的返回值与列包含SQL NULL值的返回值相同。通过在获取可疑返回值之后并且在同一&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;上调用任何其他SQLite接口之前立即调用&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（），&lt;/a&gt;可以将有效的SQL NULL返回与内存不足错误区分开。</target>
        </trans-unit>
        <trans-unit id="53a860ff4ceaa780f514879a263f3e2bd7a64b45" translate="yes" xml:space="preserve">
          <source>If an sqlite3_exec() callback returns non-zero, the sqlite3_exec() routine returns SQLITE_ABORT without invoking the callback again and without running any subsequent SQL statements.</source>
          <target state="translated">如果一个sqlite3_exec()回调返回非零,sqlite3_exec()例程将返回SQLITE_ABORT,而不会再次调用回调,也不会运行任何后续的SQL语句。</target>
        </trans-unit>
        <trans-unit id="86f2a1856f49f287cef6815b989e3bcfc9f7c019" translate="yes" xml:space="preserve">
          <source>If an update is only partially applied to the target database by the time sqlite3rbu_close() is called, state information is saved within the state database if it exists, or otherwise in the RBU database. This allows subsequent processes to automatically resume the RBU update from where it left off. If state information is stored in the RBU database, it can be removed by dropping all tables whose names begin with &quot;rbu_&quot;.</source>
          <target state="translated">如果在调用sqlite3rbu_close()时,更新只是部分应用到目标数据库,那么状态信息会被保存在状态数据库中(如果它存在的话),或者保存在 RBU 数据库中。这使得后续的进程可以自动地从它离开的地方重新开始 RBU 更新。如果状态信息保存在 RBU 数据库中,可以通过删除所有名称以 &quot;rbu_&quot;开头的表来删除。</target>
        </trans-unit>
        <trans-unit id="bd175412c5f187514ee87168844f1bedfa975635" translate="yes" xml:space="preserve">
          <source>If an xToken() callback returns any value other than SQLITE_OK, then the tokenization should be abandoned and the xTokenize() method should immediately return a copy of the xToken() return value. Or, if the input buffer is exhausted, xTokenize() should return SQLITE_OK. Finally, if an error occurs with the xTokenize() implementation itself, it may abandon the tokenization and return any error code other than SQLITE_OK or SQLITE_DONE.</source>
          <target state="translated">如果xToken()回调返回SQLITE_OK以外的任何值,那么应该放弃token化,xTokenize()方法应该立即返回xToken()返回值的副本。或者,如果输入缓冲区已经用完,xTokenize()应该返回SQLITE_OK。最后,如果xTokenize()实现本身发生错误,它可能会放弃token化,并返回SQLITE_OK或SQLITE_DONE以外的任何错误代码。</target>
        </trans-unit>
        <trans-unit id="0be452758cf5838f411f1a08b26770962254070e" translate="yes" xml:space="preserve">
          <source>If and only if the previously described conversion of OR to an IN operator does not work, the second OR-clause optimization is attempted. Suppose the OR clause consists of multiple subterms as follows:</source>
          <target state="translated">如果且仅当前面描述的OR转换为IN操作符不起作用时,才会尝试第二个OR子句优化。假设OR子句由以下多个子项组成。</target>
        </trans-unit>
        <trans-unit id="1d92fd7f31be8d1f3061a17050b41ab1479f4bcd" translate="yes" xml:space="preserve">
          <source>If another database connection has the database mode open in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; then all queries against the database will return &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. Both Chrome and Firefox open their database files in exclusive locking mode, so attempts to read Chrome or Firefox databases while the applications are running will run into this problem, for example.</source>
          <target state="translated">如果另一个数据库连接以&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;独占锁定&lt;/a&gt;模式打开了数据库模式，则对数据库的所有查询都将返回&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;。Chrome和Firefox均以独占锁定模式打开其数据库文件，因此，例如，在应用程序运行时尝试读取Chrome或Firefox数据库的尝试将遇到此问题。</target>
        </trans-unit>
        <trans-unit id="52c07a908a81f106b3dd1bc1b1492081c7a35d47" translate="yes" xml:space="preserve">
          <source>If another thread changes the autocommit status of the database connection while this routine is running, then the return value is undefined.</source>
          <target state="translated">如果在这个例程运行时,另一个线程改变了数据库连接的自动提交状态,那么返回值是未定义的。</target>
        </trans-unit>
        <trans-unit id="8503a498072091f7cabc2db6a10e976de9bc12b1" translate="yes" xml:space="preserve">
          <source>If another thread or process writes to the source database while this function is sleeping, then SQLite detects this and usually restarts the backup process when sqlite3_backup_step() is next called. There is one exception to this rule: If the source database is not an in-memory database, and the write is performed from within the same process as the backup operation and uses the same database handle (pDb), then the destination database (the one opened using connection pFile) is automatically updated along with the source. The backup process may then be continued after the sqlite3_sleep() call returns as if nothing had happened.</source>
          <target state="translated">如果另一个线程或进程在该函数睡眠时向源数据库写入,那么SQLite会检测到这一点,通常会在下一次调用sqlite3_backup_step()时重新启动备份进程。这个规则有一个例外:如果源数据库不是内存数据库,并且写入是在与备份操作相同的进程中进行的,并且使用了相同的数据库句柄(pDb),那么目标数据库(使用连接pFile打开的数据库)将与源数据库一起自动更新。在调用sqlite3_sleep()返回后,备份过程可以继续进行,就像什么都没有发生一样。</target>
        </trans-unit>
        <trans-unit id="b9f8be087686590dab771595e5bd54b7d246dba5" translate="yes" xml:space="preserve">
          <source>If any errors are encountered during compilation, an error message is written into memory obtained from &lt;b&gt;malloc&lt;/b&gt; and the 5th parameter is made to point to that memory. If the 5th parameter is NULL, then no error message is generated. If the 5th parameter is not NULL, then the calling function should dispose of the memory containing the error message by calling &lt;b&gt;sqlite_freemem&lt;/b&gt;.</source>
          <target state="translated">如果在编译过程中遇到任何错误，则会将错误消息写入从&lt;b&gt;malloc&lt;/b&gt;获得的&lt;b&gt;内存中&lt;/b&gt;，并使第5个参数指向该内存。如果第5个参数为NULL，则不会生成任何错误消息。如果第5个参数不为NULL，则调用函数应通过调用&lt;b&gt;sqlite_freemem&lt;/b&gt;处置包含错误消息的&lt;b&gt;内存&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="83125f64332cc16259858298cfafac27aca598bf" translate="yes" xml:space="preserve">
          <source>If any of the special-case entries shows above are omitted, then the value of 100 is used for insertion and deletion and 150 is used for substitution. To disable the default insertion, deletion, and/or substitution set their respective cost to 10000 or more.</source>
          <target state="translated">如果省略了上述任何一个特殊大小写条目,那么插入和删除时使用100的值,替换时使用150的值。如果要禁用默认的插入、删除和/或替换,请将它们各自的成本设置为10000或更多。</target>
        </trans-unit>
        <trans-unit id="8b09289d91105f4036d96455156f97ad8f84efdf" translate="yes" xml:space="preserve">
          <source>If any of the sqlite3_bind_*() routines are called with a NULL pointer for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; or with a prepared statement for which &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; has been called more recently than &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, then the call will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. If any sqlite3_bind_() routine is passed a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that has been finalized, the result is undefined and probably harmful.</source>
          <target state="translated">如果使用sqlite3_bind _ *（）例程中的任何一个调用了带预&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备语句&lt;/a&gt;的NULL指针，或者使用了比&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;最近调用了&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）的预&lt;/a&gt;准备语句，则该调用将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;。如果将任何sqlite3_bind_（）例程传递给已完成的&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;，则结果是不确定的，可能有害。</target>
        </trans-unit>
        <trans-unit id="4d6ffdf1dd2e882d0d92b18297a217958bf3b943" translate="yes" xml:space="preserve">
          <source>If any of the sqlite3_bind_*() routines are called with a NULL pointer for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; or with a prepared statement for which &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; has been called more recently than &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, then the call will return &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. If any sqlite3_bind_() routine is passed a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that has been finalized, the result is undefined and probably harmful.</source>
          <target state="translated">如果使用sqlite3_bind _ *（）例程中的任何一个调用了带预&lt;a href=&quot;stmt&quot;&gt;准备语句&lt;/a&gt;的NULL指针，或者使用了比&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;最近调用了&lt;a href=&quot;step&quot;&gt;sqlite3_step（）的预&lt;/a&gt;准备语句，则该调用将返回&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;。如果将任何sqlite3_bind_（）例程传递给已完成的&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;，则结果是不确定的，可能有害。</target>
        </trans-unit>
        <trans-unit id="ecc451199e804c2d9bbaab7eeb8ae7260c861c03" translate="yes" xml:space="preserve">
          <source>If any of these options are defined, then the same set of SQLITE_OMIT_* options must also be defined when using the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; tool to generate the parse.c file and when compiling the 'mkkeywordhash' tool which generates the keywordhash.h file. Because of this, these options may only be used when the library is built from canonical source, not from the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. Some SQLITE_OMIT_* options might work, or appear to work, when used with the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. But this is not guaranteed. In general, always compile from canonical sources in order to take advantage of SQLITE_OMIT_* options.</source>
          <target state="translated">如果定义了这些选项中的任何一个，则在使用&lt;a href=&quot;lemon&quot;&gt;Lemon解析器生成器&lt;/a&gt;工具生成parse.c文件时，以及在编译用于生成keywordhash.h文件的&amp;ldquo; mkkeywordhash&amp;rdquo;工具时，也必须定义相同的SQLITE_OMIT_ *选项集。因此，仅当从规范来源（而不是从&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;）构建库时，才可以使用这些选项。有些SQLITE_OMIT_ *选项可能会奏效，或者出现工作，与使用时&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;。但这不能保证。通常，为了利用SQLITE_OMIT_ *选项，请始终从规范源进行编译。</target>
        </trans-unit>
        <trans-unit id="066af8ac5653f5f78e3e77b86a9535152f8106eb" translate="yes" xml:space="preserve">
          <source>If any other constraint violation occurs while applying a change (i.e. a UNIQUE, CHECK or NOT NULL constraint), the conflict handler is invoked with CHANGESET_CONSTRAINT as the second argument.</source>
          <target state="translated">如果在应用变更时发生任何其他约束的违反(例如UNIQUE、CHECK或NOT NULL约束),冲突处理程序会被调用,第二个参数是CHANGESET_CONSTRAINT。</target>
        </trans-unit>
        <trans-unit id="c1ffcbd8edc1e59c920bc1e42ef8ae6a08f1c489" translate="yes" xml:space="preserve">
          <source>If any other error occurs while flushing dirty pages to disk (for example an IO error or out-of-memory condition), then processing is abandoned and an SQLite &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned to the caller immediately.</source>
          <target state="translated">如果在将脏页刷新到磁盘时发生任何其他错误（例如IO错误或内存不足的情况），则将放弃处理并将SQLite &lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;立即返回给调用者。</target>
        </trans-unit>
        <trans-unit id="547159ba42f3dd194cd2ac6c73df9dfb51226b89" translate="yes" xml:space="preserve">
          <source>If any other error occurs while flushing dirty pages to disk (for example an IO error or out-of-memory condition), then processing is abandoned and an SQLite &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned to the caller immediately.</source>
          <target state="translated">如果在将脏页刷新到磁盘时发生任何其他错误（例如IO错误或内存不足的情况），则将放弃处理并将SQLite &lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;立即返回给调用者。</target>
        </trans-unit>
        <trans-unit id="ed9a42f661215804821abb386ff5f31ffa1294e2" translate="yes" xml:space="preserve">
          <source>If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method will return an appropriate error code. The &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; following any out-of-memory error, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; if the size of the dynamic string exceeds &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if there have been no errors.</source>
          <target state="translated">如果在sqlite3_str X中构造动态字符串时发生任何先前的错误，则&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode（X）&lt;/a&gt;方法将返回适当的错误代码。所述&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode（X）&lt;/a&gt;方法返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;以下存储器外的任何误差，或者&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt;如果动态字符串的大小超过&lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;，或&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;如果出现了任何错误。</target>
        </trans-unit>
        <trans-unit id="2797997123bd9f48d4b03d213989316f5ee2db3a" translate="yes" xml:space="preserve">
          <source>If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method will return an appropriate error code. The &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method returns &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; following any out-of-memory error, or &lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; if the size of the dynamic string exceeds &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;, or &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if there have been no errors.</source>
          <target state="translated">如果在sqlite3_str X中构造动态字符串时发生任何先前的错误，则&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode（X）&lt;/a&gt;方法将返回适当的错误代码。所述&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode（X）&lt;/a&gt;方法返回&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;以下存储器外的任何误差，或者&lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt;如果动态字符串的大小超过&lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;，或&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;如果出现了任何错误。</target>
        </trans-unit>
        <trans-unit id="8cf62e1e5822970ab1a0772544bba1f6a9886bdb" translate="yes" xml:space="preserve">
          <source>If any views refer to table X in a way that is affected by the schema change, then drop those views using &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; and recreate them with whatever changes are necessary to accommodate the schema change using &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;.</source>
          <target state="translated">如果有任何视图以受架构更改影响的方式引用表X，则使用&lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt;删除这些视图，并使用&lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;进行必要的更改以重新创建它们以适应架构更改。</target>
        </trans-unit>
        <trans-unit id="f4bcba20e82a98be0954f7a995f190f8be3b9e76" translate="yes" xml:space="preserve">
          <source>If argument P3 is non-zero, then it indicates that the sorter may assume that a stable sort considering the first P3 fields of each key is sufficient to produce the required results.</source>
          <target state="translated">如果参数P3为非零,则表示排序器可以假设考虑每个键的前P3字段的稳定排序足以产生所需结果。</target>
        </trans-unit>
        <trans-unit id="35693c95846989c47eb6a922b6389598e5e5c2ef" translate="yes" xml:space="preserve">
          <source>If argument pnCol is not NULL, then *pnCol is set to the number of columns in the table.</source>
          <target state="translated">如果参数pnCol不是NULL,那么*pnCol被设置为表中的列数。</target>
        </trans-unit>
        <trans-unit id="6eebf7ee5a909998cdac6e1af93d8bf0c4b9e6a9" translate="yes" xml:space="preserve">
          <source>If argument pzTab is not NULL, then *pzTab is set to point to a nul-terminated utf-8 encoded string containing the name of the table affected by the current change. The buffer remains valid until either sqlite3changeset_next() is called on the iterator or until the conflict-handler function returns. If pnCol is not NULL, then *pnCol is set to the number of columns in the table affected by the change. If pbIndirect is not NULL, then *pbIndirect is set to true (1) if the change is an indirect change, or false (0) otherwise. See the documentation for &lt;a href=&quot;#sqlite3session_indirect&quot;&gt;sqlite3session_indirect()&lt;/a&gt; for a description of direct and indirect changes. Finally, if pOp is not NULL, then *pOp is set to one of &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the type of change that the iterator currently points to.</source>
          <target state="translated">如果参数pzTab不为NULL，则* pzTab设置为指向以nul终止的utf-8编码的字符串，该字符串包含受当前更改影响的表的名称。缓冲区保持有效，直到在迭代器上调用sqlite3changeset_next（）或冲突处理程序函数返回为止。如果pnCol不为NULL，则* pnCol设置为表中受更改影响的列数。如果pbIndirect不为NULL，则如果更改是间接更改，则* pbIndirect设置为true（1），否则设置为false（0）。有关直接和间接更改的说明，请参见&lt;a href=&quot;#sqlite3session_indirect&quot;&gt;sqlite3session_indirect（）&lt;/a&gt;的文档。最后，如果pOp不为NULL，则* pOp设置为&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;，&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;或&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE之一&lt;/a&gt;，具体取决于迭代器当前指向的更改类型。</target>
        </trans-unit>
        <trans-unit id="eeb423ada7e3f3af8ece536280a90cde13ccf0f0" translate="yes" xml:space="preserve">
          <source>If argument pzTab is not NULL, then *pzTab is set to point to a nul-terminated utf-8 encoded string containing the name of the table affected by the current change. The buffer remains valid until either sqlite3changeset_next() is called on the iterator or until the conflict-handler function returns. If pnCol is not NULL, then *pnCol is set to the number of columns in the table affected by the change. If pbIndirect is not NULL, then *pbIndirect is set to true (1) if the change is an indirect change, or false (0) otherwise. See the documentation for &lt;a href=&quot;sqlite3session_indirect&quot;&gt;sqlite3session_indirect()&lt;/a&gt; for a description of direct and indirect changes. Finally, if pOp is not NULL, then *pOp is set to one of &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the type of change that the iterator currently points to.</source>
          <target state="translated">如果参数pzTab不为NULL，则* pzTab设置为指向以nul终止的utf-8编码的字符串，该字符串包含受当前更改影响的表的名称。缓冲区保持有效，直到在迭代器上调用sqlite3changeset_next（）或冲突处理程序函数返回为止。如果pnCol不为NULL，则* pnCol设置为表中受更改影响的列数。如果pbIndirect不为NULL，则如果更改是间接更改，则* pbIndirect设置为true（1），否则设置为false（0）。有关直接和间接更改的说明，请参见&lt;a href=&quot;sqlite3session_indirect&quot;&gt;sqlite3session_indirect（）&lt;/a&gt;的文档。最后，如果pOp不为NULL，则* pOp设置为&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;，&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;或&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE之一&lt;/a&gt;，具体取决于迭代器当前指向的更改类型。</target>
        </trans-unit>
        <trans-unit id="012db9d404feeb7b242a5f104e807e9ebcf5e6cc" translate="yes" xml:space="preserve">
          <source>If argument zTab is not NULL, then it is the name of a table to attach to the session object passed as the first argument. All subsequent changes made to the table while the session object is enabled will be recorded. See documentation for &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; for further details.</source>
          <target state="translated">如果参数zTab不为NULL，则它是要附加到作为第一个参数传递的会话对象上的表的名称。启用会话对象后，对该表所做的所有后续更改将被记录。有关更多详细信息，请参见&lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset（）的&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="1874355cfa55a648a95d55d6cc4ad4d5d5a5435f" translate="yes" xml:space="preserve">
          <source>If argument zTab is not NULL, then it is the name of a table to attach to the session object passed as the first argument. All subsequent changes made to the table while the session object is enabled will be recorded. See documentation for &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; for further details.</source>
          <target state="translated">如果参数zTab不为NULL，则它是要附加到作为第一个参数传递的会话对象上的表的名称。启用会话对象后，对该表所做的所有后续更改将被记录。有关更多详细信息，请参见&lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset（）的&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="21fcaf7a804fb18a6bdf460073dabd9a55d816ad" translate="yes" xml:space="preserve">
          <source>If both SQLITE_STOREP2 and SQLITE_KEEPNULL flags are set then the content of r[P2] is only changed if the new value is NULL or 0 (false). In other words, a prior r[P2] value will not be overwritten by 1 (true).</source>
          <target state="translated">如果同时设置了SQLITE_STOREP2和SQLITE_KEEPNULL标志,那么只有当新的值是NULL或0(false)时,r[P2]的内容才会改变。换句话说,之前的r[P2]值不会被1(true)覆盖。</target>
        </trans-unit>
        <trans-unit id="f091230c98fc9fb42f84687fff668e2e8782487e" translate="yes" xml:space="preserve">
          <source>If both SQLITE_STOREP2 and SQLITE_KEEPNULL flags are set then the content of r[P2] is only changed if the new value is NULL or 1 (true). In other words, a prior r[P2] value will not be overwritten by 0 (false).</source>
          <target state="translated">如果同时设置了SQLITE_STOREP2和SQLITE_KEEPNULL标志,那么r[P2]的内容只有在新的值是NULL或1(true)时才会被改变。换句话说,之前的r[P2]值不会被0(false)覆盖。</target>
        </trans-unit>
        <trans-unit id="b35b42f8226135f60e30979149548acecdb3cd9a" translate="yes" xml:space="preserve">
          <source>If both pragmas &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt; are OFF then case (2) applies.</source>
          <target state="translated">如果编译指示&lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt;均为OFF，则情况（2）适用。</target>
        </trans-unit>
        <trans-unit id="c1ea5de7bdcea197233ed39232910d2d33159cd2" translate="yes" xml:space="preserve">
          <source>If certain kinds of errors occur on a statement within a multi-statement transaction (errors including &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_FULL&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;, and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;) then the transaction might be rolled back automatically. The only way to find out whether SQLite automatically rolled back the transaction after an error is to use this function.</source>
          <target state="translated">如果多语句事务中的语句上发生某些类型的错误（包括&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_FULL&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;和&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_INTERRUPT的错误&lt;/a&gt;），则该事务可能会自动回滚。找出错误后SQLite是否自动回滚事务的唯一方法是使用此功能。</target>
        </trans-unit>
        <trans-unit id="063cf3d6b1f8d89a285c8317271a90d08b9bd66c" translate="yes" xml:space="preserve">
          <source>If certain kinds of errors occur on a statement within a multi-statement transaction (errors including &lt;a href=&quot;../rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;, &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;, &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, and &lt;a href=&quot;../rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;) then the transaction might be rolled back automatically. The only way to find out whether SQLite automatically rolled back the transaction after an error is to use this function.</source>
          <target state="translated">如果多语句事务中的语句上发生某些类型的错误（包括&lt;a href=&quot;../rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;，&lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;，&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;，&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;和&lt;a href=&quot;../rescode#interrupt&quot;&gt;SQLITE_INTERRUPT的错误&lt;/a&gt;），则该事务可能会自动回滚。找出错误后SQLite是否自动回滚事务的唯一方法是使用此功能。</target>
        </trans-unit>
        <trans-unit id="65b57925e204e3ebe11c23e15127d898a0e33ca6" translate="yes" xml:space="preserve">
          <source>If certain kinds of errors occur within a transaction, the transaction may or may not be rolled back automatically. The errors that can cause an automatic rollback include:</source>
          <target state="translated">如果在一个交易中发生了某些类型的错误,该交易可能会或不会自动回滚。可能导致自动回滚的错误包括:</target>
        </trans-unit>
        <trans-unit id="debbf4ee0f449f15f2b2fad59057f8a4eccd847a" translate="yes" xml:space="preserve">
          <source>If changes occur on the same database connection after a query starts running but before the query completes, then it is undefined whether or not the query will see those changes.</source>
          <target state="translated">如果在查询开始运行后,但在查询完成之前,同一个数据库连接上发生了变化,那么查询是否会看到这些变化是没有定义的。</target>
        </trans-unit>
        <trans-unit id="92abf58210ebaa6ec510b645429d6e91e6ca04d8" translate="yes" xml:space="preserve">
          <source>If changes occur on the same database connection after a query starts running but before the query completes, then the query might return a changed row more than once, or it might return a row that was previously deleted.</source>
          <target state="translated">如果在查询开始运行后,但在查询完成之前,同一数据库连接上发生了变化,那么查询可能会不止一次地返回一条已更改的记录,或者可能会返回一条之前被删除的记录。</target>
        </trans-unit>
        <trans-unit id="437112dad4bafb7626f6351c41b7b34b2abfaca6" translate="yes" xml:space="preserve">
          <source>If changing into or out of WAL mode the procedure is more complicated.</source>
          <target state="translated">如果进入或退出WAL模式,程序就比较复杂。</target>
        </trans-unit>
        <trans-unit id="f754396c33d700ad2fd9dbdfe823fd9ae27672f4" translate="yes" xml:space="preserve">
          <source>If column names are explicitly provided for the FTS table as part of the CREATE VIRTUAL TABLE statement, then a datatype name may be optionally specified for each column. This is pure syntactic sugar, the supplied typenames are not used by FTS or the SQLite core for any purpose. The same applies to any constraints specified along with an FTS column name - they are parsed but not used or recorded by the system in any way.</source>
          <target state="translated">如果作为CREATE VIRTUAL TABLE语句的一部分,为FTS表显式地提供了列名,那么可以为每一列选择性地指定一个数据类型名。这是纯粹的语法糖,提供的类型名不会被FTS或SQLite核心用于任何目的。同样的道理也适用于与FTS列名一起指定的任何约束--它们会被解析,但不会被系统以任何方式使用或记录。</target>
        </trans-unit>
        <trans-unit id="4ec154d4b803f19da5aae8c26059349f5ffc0b8b" translate="yes" xml:space="preserve">
          <source>If conflict is with a remote UPDATE and the resolution is OMIT, then the old.* values are rebased using the new.* values in the remote change. Or, if the resolution is REPLACE, then the change is copied into the rebased changeset with updates to columns also updated by the conflicting remote UPDATE removed. If this means no columns would be updated, the change is omitted.</source>
          <target state="translated">如果与远程UPDATE冲突,并且解决方法是OMIT,那么旧的.*值将使用远程变化中的新的.*值进行重基。或者,如果解决方法是REPLACE,那么更改会被复制到重新建立的更改集中,同时删除被冲突的远程UPDATE更新的列的更新。如果这意味着没有列会被更新,那么这个改变就被省略了。</target>
        </trans-unit>
        <trans-unit id="eacad9fb0a3ce1ea1edfa735ab3f942dbf9e8cd8" translate="yes" xml:space="preserve">
          <source>If cursor P1 is an index, then the content is the key of the row. If cursor P2 is a table, then the content extracted is the data.</source>
          <target state="translated">如果光标P1是一个索引,那么内容就是该行的键。如果光标P2是表,那么提取的内容就是数据。</target>
        </trans-unit>
        <trans-unit id="ecd4bc0795e5315c7b840830ae1ae10db7944fd7" translate="yes" xml:space="preserve">
          <source>If cursor P1 is not open, jump to instruction P2. Otherwise, fall through.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e0c624719d0c72631b398ea85cd293212feef6" translate="yes" xml:space="preserve">
          <source>If cursor P1 refers to an SQL table (B-Tree that uses integer keys), use the value in register P3 as a key. If cursor P1 refers to an SQL index, then P3 is the first in an array of P4 registers that are used as an unpacked index key.</source>
          <target state="translated">如果游标P1指向一个SQL表(使用整数键的B-Tree),那么使用寄存器P3中的值作为键。如果游标P1指向一个SQL索引,那么P3是P4寄存器数组中的第一个,作为未打包的索引键使用。</target>
        </trans-unit>
        <trans-unit id="eed3ade81291c8b1e43812aa13b2f866776f9f36" translate="yes" xml:space="preserve">
          <source>If cursor P1 refers to an SQL table (B-Tree that uses integer keys), use the value in register P3 as the key. If cursor P1 refers to an SQL index, then P3 is the first in an array of P4 registers that are used as an unpacked index key.</source>
          <target state="translated">如果游标P1指向一个SQL表(使用整数键的B-Tree),那么使用寄存器P3中的值作为键。如果游标P1指向一个SQL索引,那么P3是P4寄存器数组中的第一个,作为未打包的索引键使用。</target>
        </trans-unit>
        <trans-unit id="bde1d5766ee802e72c51189e7fb68596781976ad" translate="yes" xml:space="preserve">
          <source>If cursor P1 was previously moved via &lt;a href=&quot;opcode#DeferredSeek&quot;&gt;DeferredSeek&lt;/a&gt;, complete that seek operation now, without further delay. If the cursor seek has already occurred, this instruction is a no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a382b280888652763d650554446d773be05c07" translate="yes" xml:space="preserve">
          <source>If data is of type &lt;b&gt;text&lt;/b&gt; then the comparison is determined by the standard C data comparison functions &lt;b&gt;memcmp()&lt;/b&gt; or &lt;b&gt;strcmp()&lt;/b&gt;. The comparison looks at bytes from two inputs one by one and returns the first non-zero difference. Strings are '\000' terminated so shorter strings sort before longer strings, as you would expect.</source>
          <target state="translated">如果数据是&lt;b&gt;文本&lt;/b&gt;类型的，则比较由标准C数据比较函数&lt;b&gt;memcmp（）&lt;/b&gt;或&lt;b&gt;strcmp（）确定&lt;/b&gt;。比较将逐个查看来自两个输入的字节，然后返回第一个非零差异。字符串以'\ 000'结尾，因此，较短的字符串将排在较长的字符串之前，这与您期望的一样。</target>
        </trans-unit>
        <trans-unit id="0120d2592940874456695d5517c48510978290bc" translate="yes" xml:space="preserve">
          <source>If database zDb is the name of an attached database that is not in WAL mode, SQLITE_OK is returned and both *pnLog and *pnCkpt set to -1. If zDb is not NULL (or a zero length string) and is not the name of any attached database, SQLITE_ERROR is returned to the caller.</source>
          <target state="translated">如果数据库zDb是一个非WAL模式的附加数据库的名称,则返回SQLITE_OK,并将*pnLog和*pnCkpt都设置为-1。如果zDb不是NULL(或零长度字符串),也不是任何附加数据库的名称,则返回SQLITE_ERROR给调用者。</target>
        </trans-unit>
        <trans-unit id="ed9f3d01c8cb63f65cf1f8cb1ada863d801c5821" translate="yes" xml:space="preserve">
          <source>If defined, support for sub-selects and the IN() operator are omitted.</source>
          <target state="translated">如果定义了,则省略对子选择和IN()运算符的支持。</target>
        </trans-unit>
        <trans-unit id="5f4710e921e7c9706b1a7d0affff80c102083b4a" translate="yes" xml:space="preserve">
          <source>If desired, you can verify the new database by running this command:</source>
          <target state="translated">如果需要,你可以通过运行这个命令来验证新的数据库。</target>
        </trans-unit>
        <trans-unit id="d0b0b6a44b8709f88072f86b2bad9194c580b896" translate="yes" xml:space="preserve">
          <source>If either P1 or P2 is 0 (false) then the result is 0 even if the other input is NULL. A NULL and true or two NULLs give a NULL output.</source>
          <target state="translated">如果P1或P2为0(false),那么即使其他输入为NULL,结果也是0。NULL和true或两个NULL都是NULL输出。</target>
        </trans-unit>
        <trans-unit id="0c5f4e14888f22c44de9608417d3500cbb09c876" translate="yes" xml:space="preserve">
          <source>If either P1 or P2 is nonzero (true) then the result is 1 (true) even if the other input is NULL. A NULL and false or two NULLs give a NULL output.</source>
          <target state="translated">如果P1或P2为非零(真),那么即使其他输入为NULL,结果也是1(真)。NULL和false或两个NULL会得到一个NULL输出。</target>
        </trans-unit>
        <trans-unit id="f718f36fc0872a36f2f90015ef098011701953fd" translate="yes" xml:space="preserve">
          <source>If either P3 or the sorter contains a NULL in one of their significant fields (not counting the P4 fields at the end which are ignored) then the comparison is assumed to be equal.</source>
          <target state="translated">如果P3或分拣器的一个重要字段中含有NULL(不包括末尾被忽略的P4字段),则假设比较结果是相等的。</target>
        </trans-unit>
        <trans-unit id="cb70cc2d7081446ae1bd92c809ed77dcb6489c40" translate="yes" xml:space="preserve">
          <source>If either X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; or X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt; are non-numeric, then the boundary is the first row for which the expression &quot;X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; IS X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt;&quot; is true.</source>
          <target state="translated">如果X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt;或X &lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt;是非数字的，则边界是表达式&amp;ldquo; X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; IS X &lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt; &amp;rdquo;为真的第一行。</target>
        </trans-unit>
        <trans-unit id="40afda50342c1866ef5c9245fe131f4faa8b196a" translate="yes" xml:space="preserve">
          <source>If either operand has an explicit collating function assignment using the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, then the explicit collating function is used for comparison, with precedence to the collating function of the left operand.</source>
          <target state="translated">如果两个操作数都使用后缀&lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE运算符&lt;/a&gt;进行了显式整理功能分配，则该显式整理功能将用于比较，并优先于左操作数的整理功能。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
