<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="e46597fb97bef96ee5f73107f8febfe136670bc8" translate="yes" xml:space="preserve">
          <source>Extending FTS5</source>
          <target state="translated">扩展FTS5</target>
        </trans-unit>
        <trans-unit id="a0ff53d7fc1bead66589841e525ef8e976444aff" translate="yes" xml:space="preserve">
          <source>Extension loading is off by default. Call the sqlite3_enable_load_extension() routine with onoff==1 to turn extension loading on and call it with onoff==0 to turn it back off again.</source>
          <target state="translated">扩展加载默认是关闭的。用onoff==1调用sqlite3_enable_load_extension()例程打开扩展加载,用onoff==0调用该例程再次关闭扩展加载。</target>
        </trans-unit>
        <trans-unit id="46936b46e05c0cd15e06014bbbef567350675181" translate="yes" xml:space="preserve">
          <source>Extension loading must be enabled using &lt;a href=&quot;#sqlite3_enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;,1,NULL) prior to calling this API, otherwise an error will be returned.</source>
          <target state="translated">在调用此API之前，必须使用&lt;a href=&quot;#sqlite3_enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（db，&lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;，1，NULL）启用扩展加载。否则，将返回错误。</target>
        </trans-unit>
        <trans-unit id="f1dcae90e84eec9a78eefca273aa7a82ae9fd130" translate="yes" xml:space="preserve">
          <source>Extension loading must be enabled using &lt;a href=&quot;enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; or &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;,1,NULL) prior to calling this API, otherwise an error will be returned.</source>
          <target state="translated">在调用此API之前，必须使用&lt;a href=&quot;enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）&lt;/a&gt;或&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（db，&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;，1，NULL）启用扩展加载。否则，将返回错误。</target>
        </trans-unit>
        <trans-unit id="114e41de65bbb502416914ca4249318756eb8953" translate="yes" xml:space="preserve">
          <source>Extension loading supported added to WinCE</source>
          <target state="translated">在WinCE中增加了对扩展加载的支持</target>
        </trans-unit>
        <trans-unit id="656bcfe284e2da39c77d4fdab55b16ad3c654719" translate="yes" xml:space="preserve">
          <source>Extensions</source>
          <target state="translated">Extensions</target>
        </trans-unit>
        <trans-unit id="439b09ab192ef3f4c9a45dd3f23cf364759dd991" translate="yes" xml:space="preserve">
          <source>Extensions can also be statically linked with the application. The code template shown below will work just as well as a statically linked extension as it does as a run-time loadable extension except that you should give the entry point function (&quot;sqlite3_extension_init&quot;) a different name to avoid name collisions if your application contains two or more extensions.</source>
          <target state="translated">扩展也可以与应用程序进行静态链接。下图所示的代码模板和静态链接的扩展和运行时可加载的扩展一样好用,只是你应该给入口点函数(&quot;sqlite3_extension_init&quot;)一个不同的名字,以避免在你的应用程序包含两个或更多扩展的情况下出现名字冲突。</target>
        </trans-unit>
        <trans-unit id="a4e4d34ecd0944488461a920456725f4890a8840" translate="yes" xml:space="preserve">
          <source>Extensive use of assert() and run-time checks</source>
          <target state="translated">广泛使用assert()和运行时检查。</target>
        </trans-unit>
        <trans-unit id="b4ced57f2686552cf070ac8fb509a5077ec27fda" translate="yes" xml:space="preserve">
          <source>External content fts4 tables</source>
          <target state="translated">外部内容FTS4表</target>
        </trans-unit>
        <trans-unit id="47b818c2e14f39f43b217d0ea891f065e303f7e1" translate="yes" xml:space="preserve">
          <source>Externally, from the point of view of another process or thread, two or more &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; using a shared-cache appear as a single connection. The locking protocol used to arbitrate between multiple shared-caches or regular database users is described elsewhere.</source>
          <target state="translated">从外部看，从另一个进程或线程的角度来看，使用共享缓存的两个或多个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;显示为单个连接。其他位置介绍了用于在多个共享缓存或常规数据库用户之间进行仲裁的锁定协议。</target>
        </trans-unit>
        <trans-unit id="45e62225b6f82210cf1454638e84d31967235d1d" translate="yes" xml:space="preserve">
          <source>Extra sanity checking added to ALTER TABLE in the 3.25.0 release sometimes raises a false-positive when the table being modified has a trigger that updates a virtual table. The false-positive caused the ALTER TABLE to rollback, thus leaving the schema unchanged. Ticket &lt;a href=&quot;https://sqlite.org/src/info/b41031ea2b537237&quot;&gt;b41031ea2b537237&lt;/a&gt;.</source>
          <target state="translated">当要修改的表具有更新虚拟表的触发器时，在3.25.0版本中添加到ALTER TABLE的额外的完整性检查有时会引发假阳性。误报使ALTER TABLE回滚，从而使架构保持不变。机票&lt;a href=&quot;https://sqlite.org/src/info/b41031ea2b537237&quot;&gt;b41031ea2b537237&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d5c6615073da0f312632e0d30300116c3bbca0ac" translate="yes" xml:space="preserve">
          <source>Extract Metadata About A Column Of A Table</source>
          <target state="translated">提取表中某列的元数据。</target>
        </trans-unit>
        <trans-unit id="40f3078b8961fbdb3a6f635e86be2acec27a1a53" translate="yes" xml:space="preserve">
          <source>Extract a single row from the queue.</source>
          <target state="translated">从队列中提取单行。</target>
        </trans-unit>
        <trans-unit id="b4ae32f698bcf0fdc018ba41b1247fb34c34af21" translate="yes" xml:space="preserve">
          <source>Extract an entry from the SQLite Archive using code like this:</source>
          <target state="translated">使用这样的代码从SQLite Archive中提取一个条目。</target>
        </trans-unit>
        <trans-unit id="3e003c081f655906879284f1f4c7714e31b1d65b" translate="yes" xml:space="preserve">
          <source>Extract files from the archive (either to the current working directory or to the directory specified by a --directory option). If there are no arguments following the options all files are extracted from the archive. Or, if there are arguments, they are the names of files to extract from the archive. Any specified directories are extracted recursively. It is an error if any specified files are not part of the archive.</source>
          <target state="translated">从存档中提取文件(提取到当前工作目录或由--directory选项指定的目录)。如果选项后面没有参数,所有文件都会从归档中提取。或者,如果有参数,则是要从归档中提取的文件的名称。任何指定的目录都会递归提取。如果任何指定的文件不是存档的一部分,则会出现错误。</target>
        </trans-unit>
        <trans-unit id="baa0742d96de2a24f07eed1535bac071a9075c95" translate="yes" xml:space="preserve">
          <source>Extract specified files from archive.</source>
          <target state="translated">从存档中提取指定的文件。</target>
        </trans-unit>
        <trans-unit id="eb5c6d1fcf0a608f318e463de8632f84451eaf7b" translate="yes" xml:space="preserve">
          <source>Extract the smallest value from the RowSet object in P1 and put that value into register P3. Or, if RowSet object P1 is initially empty, leave P3 unchanged and jump to instruction P2.</source>
          <target state="translated">从P1中的RowSet对象中提取最小的值,并将该值放入寄存器P3中。或者,如果RowSet对象P1初始为空,则保持P3不变,跳转到指令P2。</target>
        </trans-unit>
        <trans-unit id="cb48b3c8d042e92b7e20ea89ce79dc8cd5654367" translate="yes" xml:space="preserve">
          <source>F = M &amp;amp;times 2&lt;sup&gt;&lt;small&gt;E&lt;/small&gt;&lt;/sup&gt;</source>
          <target state="translated">F = M＆times 2 &lt;sup&gt;&lt;small&gt;E&lt;/small&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="fd6a5ecb0c6d5148842ac5a363fcb56a58341f32" translate="yes" xml:space="preserve">
          <source>FAIL</source>
          <target state="translated">FAIL</target>
        </trans-unit>
        <trans-unit id="c4aa9e5944607518b7369e543fb9270849797108" translate="yes" xml:space="preserve">
          <source>FILENAME</source>
          <target state="translated">FILENAME</target>
        </trans-unit>
        <trans-unit id="edc5934c34a6fd02ae10fbbb8d31675eb97581a4" translate="yes" xml:space="preserve">
          <source>FILTER</source>
          <target state="translated">FILTER</target>
        </trans-unit>
        <trans-unit id="7af1ca696458c2f9d5d612be97316bdd154f68d5" translate="yes" xml:space="preserve">
          <source>FILTER clause on aggregate functions</source>
          <target state="translated">聚合函数的FILTER子句</target>
        </trans-unit>
        <trans-unit id="2f20f7ce5f89c0638962299aea08b6280742c461" translate="yes" xml:space="preserve">
          <source>FIRST</source>
          <target state="translated">FIRST</target>
        </trans-unit>
        <trans-unit id="cd98ae36981ee80a267c314ec60000c7f9d30870" translate="yes" xml:space="preserve">
          <source>FLOAT</source>
          <target state="translated">FLOAT</target>
        </trans-unit>
        <trans-unit id="f0de6c8aaa3f89b4cf230209af3f19827539e319" translate="yes" xml:space="preserve">
          <source>FOLLOWING</source>
          <target state="translated">FOLLOWING</target>
        </trans-unit>
        <trans-unit id="cffc20d5a5a0383f3e7092a7ee2056120936485b" translate="yes" xml:space="preserve">
          <source>FOR</source>
          <target state="translated">FOR</target>
        </trans-unit>
        <trans-unit id="2042a19d7f5fa71037019431093347e65589675e" translate="yes" xml:space="preserve">
          <source>FOR EACH ROW triggers are supported but not FOR EACH STATEMENT triggers.</source>
          <target state="translated">支持FOR EACH ROW触发,但不支持FOR EACH STATEMENT触发。</target>
        </trans-unit>
        <trans-unit id="8b1916dfa796728075ee31b5fa8961f1bc7e880d" translate="yes" xml:space="preserve">
          <source>FOREIGN</source>
          <target state="translated">FOREIGN</target>
        </trans-unit>
        <trans-unit id="8e7f00cffd27676bd86f7a41b4fecf304cf6d5a6" translate="yes" xml:space="preserve">
          <source>FROM</source>
          <target state="translated">FROM</target>
        </trans-unit>
        <trans-unit id="2f6d94dfca2abdb4f6ae16ec59fb3d9a744ddcf9" translate="yes" xml:space="preserve">
          <source>FROM clause</source>
          <target state="translated">FROM条款</target>
        </trans-unit>
        <trans-unit id="c3523014e1653c50ece1aec52c268066744db929" translate="yes" xml:space="preserve">
          <source>FTS Doclist Entry Format</source>
          <target state="translated">FTS文件清单条目格式</target>
        </trans-unit>
        <trans-unit id="08c36c5cc18ab85c9bd2f90b127a0b924d5fe23e" translate="yes" xml:space="preserve">
          <source>FTS MATCH</source>
          <target state="translated">FTS MATCH</target>
        </trans-unit>
        <trans-unit id="394841e4a088a4ee61fc03c94e00b990fb5862ce" translate="yes" xml:space="preserve">
          <source>FTS does not expose a C-function that users call to register new tokenizer types with a database handle. Instead, the pointer must be encoded as an SQL blob value and passed to FTS through the SQL engine by evaluating a special scalar function, &quot;fts3_tokenizer()&quot;. The fts3_tokenizer() function may be called with one or two arguments, as follows:</source>
          <target state="translated">FTS没有公开一个C函数,用户可以调用它来注册数据库句柄的新tokenizer类型。取而代之的是,指针必须被编码为一个SQL blob值,并通过SQL引擎评估一个特殊的标量函数 &quot;fts3_tokenizer()&quot;传递给FTS。fts3_tokenizer()函数可以用一个或两个参数来调用,如下所示。</target>
        </trans-unit>
        <trans-unit id="871df7406acd230826350d29ce0b56fe491442c2" translate="yes" xml:space="preserve">
          <source>FTS hidden column</source>
          <target state="translated">FTS隐藏栏</target>
        </trans-unit>
        <trans-unit id="9610893255d0800ca1fe04deb4a339e0ca00a5ac" translate="yes" xml:space="preserve">
          <source>FTS is primarily designed to support Boolean full-text queries - queries to find the set of documents that match a specified criteria. However, many (most?) search applications require that results are somehow ranked in order of &quot;relevance&quot;, where &quot;relevance&quot; is defined as the likelihood that the user who performed the search is interested in a specific element of the returned set of documents. When using a search engine to find documents on the world wide web, the user expects that the most useful, or &quot;relevant&quot;, documents will be returned as the first page of results, and that each subsequent page contains progressively less relevant results. Exactly how a machine can determine document relevance based on a users query is a complicated problem and the subject of much ongoing research.</source>
          <target state="translated">FTS主要是为了支持布尔全文查询--寻找符合指定标准的文档集的查询。然而,许多(大多数?)搜索应用要求搜索结果以某种方式按 &quot;相关性 &quot;排序,其中 &quot;相关性 &quot;被定义为执行搜索的用户对返回的文档集的特定元素感兴趣的可能性。当使用搜索引擎在万维网上查找文档时,用户期望最有用的,或者说是 &quot;相关 &quot;的文档会作为第一页的结果被返回,而随后的每一页包含的相关结果会逐渐减少。究竟机器如何根据用户的查询来确定文档的相关性,是一个复杂的问题,也是很多人正在研究的课题。</target>
        </trans-unit>
        <trans-unit id="3731cc0c94681dc32e8f394a102a540e99e93832" translate="yes" xml:space="preserve">
          <source>FTS queries are made up of &lt;b&gt;phrases&lt;/b&gt;. A phrase is an ordered list of one or more tokens. A string is transformed into a phrase by passing it to the FTS table tokenizer. Two phrases can be concatenated into a single large phrase using the &quot;+&quot; operator. For example, assuming the tokenizer module being used tokenizes the input &quot;one.two.three&quot; to three separate tokens, the following four queries all specify the same phrase:</source>
          <target state="translated">FTS查询由&lt;b&gt;短语组成&lt;/b&gt;。短语是一个或多个标记的有序列表。通过将字符串传递给FTS表令牌生成器，可以将其转换为短语。可以使用&amp;ldquo; +&amp;rdquo;运算符将两个词组连接成一个大词组。例如，假设使用的令牌生成器模块将输入&amp;ldquo; one.two.three&amp;rdquo;令牌化为三个单独的令牌，则以下四个查询都指定相同的短语：</target>
        </trans-unit>
        <trans-unit id="6821ce9a3c01802eb530b20fed455de131a72213" translate="yes" xml:space="preserve">
          <source>FTS query set operations using the standard query syntax are similar, but not identical, to set operations with the enhanced query syntax. There are four differences, as follows:</source>
          <target state="translated">使用标准查询语法的FTS查询集操作与使用增强型查询语法的集操作相似,但不完全相同。有以下四个区别:</target>
        </trans-unit>
        <trans-unit id="8d5ddc324f0381333b7d8ab01fe249ad01bbcbd2" translate="yes" xml:space="preserve">
          <source>FTS shadow tables</source>
          <target state="translated">FTS影子表</target>
        </trans-unit>
        <trans-unit id="61a39fa7b32dd985e153046de08304dc64e8d6b3" translate="yes" xml:space="preserve">
          <source>FTS tables are populated using &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements in the same way as ordinary SQLite tables are.</source>
          <target state="translated">使用&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;，&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;和&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;语句填充FTS表，方式与普通SQLite表相同。</target>
        </trans-unit>
        <trans-unit id="bc9a6013954064cd8ee09b12f022677a1b34ded3" translate="yes" xml:space="preserve">
          <source>FTS tables can be queried efficiently using SELECT statements of two different forms:</source>
          <target state="translated">使用两种不同形式的SELECT语句可以有效地查询FTS表。</target>
        </trans-unit>
        <trans-unit id="b3449cd4ca843dc92a8fce9d9f69a617812f743d" translate="yes" xml:space="preserve">
          <source>FTS tables may be dropped from the database using an ordinary &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; statement. For example:</source>
          <target state="translated">可以使用普通的&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;语句从数据库中删除FTS表。例如：</target>
        </trans-unit>
        <trans-unit id="2700f1653c678e15c1bd610ec75cb2942cb94697" translate="yes" xml:space="preserve">
          <source>FTS tables permit the special alias &quot;docid&quot; to be used to refer to the rowid column supported by all &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">FTS表允许使用特殊别名&amp;ldquo; docid&amp;rdquo;来引用所有&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;支持的rowid列。</target>
        </trans-unit>
        <trans-unit id="bf9928f2d9fa4acc06aa91c08ff21df91f62f1a4" translate="yes" xml:space="preserve">
          <source>FTS tables support three basic query types:</source>
          <target state="translated">FTS表支持三种基本查询类型。</target>
        </trans-unit>
        <trans-unit id="8b6242cfa0a61ee3e024d8795a95dd14b9db1c27" translate="yes" xml:space="preserve">
          <source>FTS varints, where</source>
          <target state="translated">FTS变位,其中</target>
        </trans-unit>
        <trans-unit id="f3461ddc90d1b1bb49207af48336b7bdd5813a5d" translate="yes" xml:space="preserve">
          <source>FTS1 and FTS2 are obsolete full-text search modules for SQLite. There are known issues with these older modules and their use should be avoided. Portions of the original FTS3 code were contributed to the SQLite project by Scott Hess of &lt;a href=&quot;http://www.google.com&quot;&gt;Google&lt;/a&gt;. It is now developed and maintained as part of SQLite.</source>
          <target state="translated">FTS1和FTS2是SQLite的过时全文搜索模块。这些较旧的模块存在已知问题，应避免使用它们。FTS3原始代码的一部分由&lt;a href=&quot;http://www.google.com&quot;&gt;Google&lt;/a&gt;的Scott Hess贡献给SQLite项目。现在，它已作为SQLite的一部分进行开发和维护。</target>
        </trans-unit>
        <trans-unit id="5dd76d02bef804bbf7536a86c58437d1c1e78eb7" translate="yes" xml:space="preserve">
          <source>FTS1 and FTS2 are obsolete full-text search modules for SQLite. There are known issues with these older modules and their use should be avoided. Portions of the original FTS3 code were contributed to the SQLite project by Scott Hess of &lt;a href=&quot;https://www.google.com&quot;&gt;Google&lt;/a&gt;. It is now developed and maintained as part of SQLite.</source>
          <target state="translated">FTS1和FTS2是SQLite的过时全文搜索模块。这些较旧的模块存在已知问题，应避免使用它们。 FTS3原始代码的一部分由&lt;a href=&quot;https://www.google.com&quot;&gt;Google&lt;/a&gt;的Scott Hess贡献给SQLite项目。现在，它已作为SQLite的一部分进行开发和维护。</target>
        </trans-unit>
        <trans-unit id="1227d1d0e63a5f4033dc141b8e43a11fd703a6d3" translate="yes" xml:space="preserve">
          <source>FTS3 Doclist Format</source>
          <target state="translated">FTS3文件清单格式</target>
        </trans-unit>
        <trans-unit id="bd1845e541762d35542373f8b784685a38b78c4a" translate="yes" xml:space="preserve">
          <source>FTS3 and FTS4 are SQLite virtual table modules that allows users to perform full-text searches on a set of documents. The most common (and effective) way to describe full-text searches is &quot;what Google, Yahoo, and Bing do with documents placed on the World Wide Web&quot;. Users input a term, or series of terms, perhaps connected by a binary operator or grouped together into a phrase, and the full-text query system finds the set of documents that best matches those terms considering the operators and groupings the user has specified. This article describes the deployment and usage of FTS3 and FTS4.</source>
          <target state="translated">FTS3和FTS4是SQLite虚拟表模块,允许用户对一组文档进行全文检索。描述全文搜索的最常见(也是最有效)的方式是 &quot;Google、Yahoo和Bing对放在万维网上的文档所做的事情&quot;。用户输入一个术语或一系列术语,也许是由一个二进制运算符连接起来的,或者是组合成一个短语,全文查询系统考虑到用户指定的运算符和分组,找到最符合这些术语的文档集。本文介绍了FTS3和FTS4的部署和使用。</target>
        </trans-unit>
        <trans-unit id="2683586e321c0b59cc4d1a5e41224dd20c9ed2e6" translate="yes" xml:space="preserve">
          <source>FTS3 and FTS4 are nearly identical. They share most of their code in common, and their interfaces are the same. The differences are:</source>
          <target state="translated">FTS3和FTS4几乎完全相同。它们有大部分共同的代码,它们的接口也是一样的。不同之处是:</target>
        </trans-unit>
        <trans-unit id="4e0f1a099853f641286d63551373f3ebb76f4701" translate="yes" xml:space="preserve">
          <source>FTS3 now uses the SQLite memory allocator exclusively. The FTS3 amalgamation can now be appended to the SQLite amalgamation to generate a super-amalgamation containing both.</source>
          <target state="translated">FTS3现在只使用SQLite内存分配器。FTS3的合并现在可以附加到SQLite的合并中,生成一个包含两者的超级合并。</target>
        </trans-unit>
        <trans-unit id="fb71b9894746fceb2a158c4dac52d9809ff6d0b7" translate="yes" xml:space="preserve">
          <source>FTS3/4 searches for matches in column &quot;b&quot;. However, FTS5 always returns zero rows, as results are first filtered for column &quot;b&quot;, then for column &quot;a&quot;, leaving no results. In other words, in FTS3/4 the inner filter overrides the outer, in FTS5 both filters are applied.</source>
          <target state="translated">FTS3/4在 &quot;b &quot;列中搜索匹配结果。然而,FTS5总是返回零行,因为结果首先对 &quot;b &quot;列进行过滤,然后对 &quot;a &quot;列进行过滤,没有结果。换句话说,在FTS3/4中,内部过滤器覆盖了外部过滤器,而在FTS5中,两个过滤器都被应用。</target>
        </trans-unit>
        <trans-unit id="ccbc625cc55863d7fe3ac35f55545f99e8b1be2a" translate="yes" xml:space="preserve">
          <source>FTS4</source>
          <target state="translated">FTS4</target>
        </trans-unit>
        <trans-unit id="8786db1911020bf22ede0fe9cbdf66389f4b98ba" translate="yes" xml:space="preserve">
          <source>FTS4 &amp;quot;automerge&amp;quot; command</source>
          <target state="translated">FTS4&amp;ldquo;自动合并&amp;rdquo;命令</target>
        </trans-unit>
        <trans-unit id="aac4be036956f48255e0d6a56b2b96b9a3a7bf30" translate="yes" xml:space="preserve">
          <source>FTS4 &amp;quot;integrity-check&amp;quot; command</source>
          <target state="translated">FTS4&amp;ldquo;完整性检查&amp;rdquo;命令</target>
        </trans-unit>
        <trans-unit id="3e393440930d32160e1b70d7854d6b3e86395412" translate="yes" xml:space="preserve">
          <source>FTS4 &amp;quot;merge&amp;quot; command</source>
          <target state="translated">FTS4&amp;ldquo;合并&amp;rdquo;命令</target>
        </trans-unit>
        <trans-unit id="2f19e99c766323f7614141b53880d300ea6c45ba" translate="yes" xml:space="preserve">
          <source>FTS4 &amp;quot;optimize&amp;quot; command</source>
          <target state="translated">FTS4&amp;ldquo;优化&amp;rdquo;命令</target>
        </trans-unit>
        <trans-unit id="16282f5426f5b372e11b86b4a630da10231c0bdc" translate="yes" xml:space="preserve">
          <source>FTS4 &amp;quot;rebuild&amp;quot; command</source>
          <target state="translated">FTS4&amp;ldquo;重建&amp;rdquo;命令</target>
        </trans-unit>
        <trans-unit id="5b2494033f24cbb7e8c72c46a490b02e62651c82" translate="yes" xml:space="preserve">
          <source>FTS4 commands</source>
          <target state="translated">FTS4命令</target>
        </trans-unit>
        <trans-unit id="0c1d30cc05eabb84e3570704f5ba49de5062577f" translate="yes" xml:space="preserve">
          <source>FTS4 contains query performance optimizations that may significantly improve the performance of full-text queries that contain terms that are very common (present in a large percentage of table rows).</source>
          <target state="translated">FTS4包含查询性能优化,可能会显著提高包含非常常见的术语(存在于很大比例的表行中)的全文查询的性能。</target>
        </trans-unit>
        <trans-unit id="d8950f7d9a329b6960f5d82c8a9a9464deeb6901" translate="yes" xml:space="preserve">
          <source>FTS4 content option</source>
          <target state="translated">FTS4内容选项</target>
        </trans-unit>
        <trans-unit id="554686d6fd7046880b40fd6cb96c9c17cf19ab25" translate="yes" xml:space="preserve">
          <source>FTS4 currently supports the following options:</source>
          <target state="translated">FTS4目前支持以下选项:</target>
        </trans-unit>
        <trans-unit id="eb472151c42f03d5056f225e17206b4a82d9df17" translate="yes" xml:space="preserve">
          <source>FTS4 is an enhancement to FTS3. FTS3 has been available since SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04) The enhancements for FTS4 were added with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_4.html&quot;&gt;version 3.7.4&lt;/a&gt; (2010-12-07).</source>
          <target state="translated">FTS4是FTS3的增强。从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;版本3.5.0&lt;/a&gt;（2007-09-04）开始，FTS3已可用。SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_4.html&quot;&gt;版本3.7.4&lt;/a&gt;（2010-12-07）已添加了FTS4的增强功能。</target>
        </trans-unit>
        <trans-unit id="5a6f7ed8cfe09bc9d715086a316aa5b99dca8f26" translate="yes" xml:space="preserve">
          <source>FTS4 matchinfo option</source>
          <target state="translated">FTS4匹配信息选项</target>
        </trans-unit>
        <trans-unit id="ec86c19747f79c1717c8a28fff23b033761dd3af" translate="yes" xml:space="preserve">
          <source>FTS4 notindexed option</source>
          <target state="translated">FTS4非指数化选项</target>
        </trans-unit>
        <trans-unit id="3e921ff34e95c42951dd8942a87973c753d70b40" translate="yes" xml:space="preserve">
          <source>FTS4 options</source>
          <target state="translated">FTS4选项</target>
        </trans-unit>
        <trans-unit id="a8e5f2af307655877187a150141826300d8144ef" translate="yes" xml:space="preserve">
          <source>FTS4 order option</source>
          <target state="translated">FTS4订单选项</target>
        </trans-unit>
        <trans-unit id="0fcb2dc93f56e71321e87c9db23359db95b4597d" translate="yes" xml:space="preserve">
          <source>FTS4 prefix option</source>
          <target state="translated">FTS4前缀选项</target>
        </trans-unit>
        <trans-unit id="9f408dd4fbd9084cc1391c0787ebb851e43d8032" translate="yes" xml:space="preserve">
          <source>FTS4 provides hooks (the compress and uncompress &lt;a href=&quot;fts3#fts4_options&quot;&gt;options&lt;/a&gt;) allowing data to be stored in a compressed form, reducing disk usage and IO.</source>
          <target state="translated">FTS4提供了挂钩（compress和uncompress &lt;a href=&quot;fts3#fts4_options&quot;&gt;选项&lt;/a&gt;），允许以压缩形式存储数据，从而减少了磁盘使用量和IO。</target>
        </trans-unit>
        <trans-unit id="49e9a9493f878486091dc5a71a19bcb1643da350" translate="yes" xml:space="preserve">
          <source>FTS4 supports some additional options that may used with the &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; function.</source>
          <target state="translated">FTS4支持可以与&lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo（）&lt;/a&gt;函数一起使用的一些其他选项。</target>
        </trans-unit>
        <trans-unit id="9f9c68e145499981bd93dd9ae5117fc5a005e534" translate="yes" xml:space="preserve">
          <source>FTS5 CREATE TABLE Options</source>
          <target state="translated">FTS5 CREATE TABLE Options</target>
        </trans-unit>
        <trans-unit id="d1c8affa7e60f64c262e7fdd55ec797b1bab87fd" translate="yes" xml:space="preserve">
          <source>FTS5 NEAR queries</source>
          <target state="translated">FTS5近距离查询</target>
        </trans-unit>
        <trans-unit id="d7ec5657125d3bf4aacc13991c9460fc5d972d0a" translate="yes" xml:space="preserve">
          <source>FTS5 Phrases</source>
          <target state="translated">FTS5短语</target>
        </trans-unit>
        <trans-unit id="87402b926513de360c56f04763fc517af198769a" translate="yes" xml:space="preserve">
          <source>FTS5 Strings</source>
          <target state="translated">FTS5字符串</target>
        </trans-unit>
        <trans-unit id="25a9630f6e782a26d91f9d01bab6d7816eedadf3" translate="yes" xml:space="preserve">
          <source>FTS5 assumes the xToken() callback is invoked for each token in the order that they occur within the input text.</source>
          <target state="translated">FTS5假设xToken()回调是按照每个标记在输入文本中出现的顺序来调用的。</target>
        </trans-unit>
        <trans-unit id="6ee357a064955e82ef52a7f67451c8f96221cc76" translate="yes" xml:space="preserve">
          <source>FTS5 automerge option</source>
          <target state="translated">FTS5自动融合选项</target>
        </trans-unit>
        <trans-unit id="8b00066098ce68d28b3e4f3e2eea468156ce3b4a" translate="yes" xml:space="preserve">
          <source>FTS5 auxiliary functions</source>
          <target state="translated">FTS5辅助功能</target>
        </trans-unit>
        <trans-unit id="f636824fff3c89108bb6a6caaee243fe0ae7c3de" translate="yes" xml:space="preserve">
          <source>FTS5 bm25</source>
          <target state="translated">FTS5 bm25</target>
        </trans-unit>
        <trans-unit id="3e8211ca81e9935211f036b4875d83e57947df67" translate="yes" xml:space="preserve">
          <source>FTS5 boolean operators</source>
          <target state="translated">FTS5 布尔运算符</target>
        </trans-unit>
        <trans-unit id="8eea6a235e1824fe97bdfc433bcbc6776c8b413a" translate="yes" xml:space="preserve">
          <source>FTS5 building</source>
          <target state="translated">FTS5大楼</target>
        </trans-unit>
        <trans-unit id="201e3277761032e31d737c13966e94ec59b4d709" translate="yes" xml:space="preserve">
          <source>FTS5 column filters</source>
          <target state="translated">FTS5列式过滤器</target>
        </trans-unit>
        <trans-unit id="8b51c99cf722e03849ae872d3bdcf8914350160e" translate="yes" xml:space="preserve">
          <source>FTS5 columnsize option</source>
          <target state="translated">FTS5列大小选项</target>
        </trans-unit>
        <trans-unit id="2a3bc16c2e24994a713981c1e36673961773504f" translate="yes" xml:space="preserve">
          <source>FTS5 content option</source>
          <target state="translated">FTS5内容选项</target>
        </trans-unit>
        <trans-unit id="9da11bdeb5ddec8fb2dc657759b537387eb1a485" translate="yes" xml:space="preserve">
          <source>FTS5 contentless tables</source>
          <target state="translated">FTS5无内容表</target>
        </trans-unit>
        <trans-unit id="0a96f4a3d0cdf45a1dbfb08a0f7e83e739c0cadb" translate="yes" xml:space="preserve">
          <source>FTS5 creates the following shadow tables. In each case the actual table name is based on the name of the FTS5 virtual table (in the following table, replace &amp;lt;name&amp;gt; with the name of the virtual table to find the actual shadow table name).</source>
          <target state="translated">FTS5创建以下影子表。在每种情况下，实际的表名均基于FTS5虚拟表的名称（在下表中，将&amp;lt;name&amp;gt;替换为虚拟表的名称以找到实际的影子表名）。</target>
        </trans-unit>
        <trans-unit id="3c4abdc52bf6e849d3002e382b92df797ff1ab0b" translate="yes" xml:space="preserve">
          <source>FTS5 custom auxiliary functions</source>
          <target state="translated">FTS5自定义辅助功能</target>
        </trans-unit>
        <trans-unit id="f3a9fa0f7b5a65182346584a71270e7b4709456d" translate="yes" xml:space="preserve">
          <source>FTS5 delete command</source>
          <target state="translated">FTS5删除命令</target>
        </trans-unit>
        <trans-unit id="de949a81f2d5b9c5a7a688724578dc7fdd75bc6d" translate="yes" xml:space="preserve">
          <source>FTS5 delete-all command</source>
          <target state="translated">FTS5删除所有命令</target>
        </trans-unit>
        <trans-unit id="adeb29e0c699543c103b6fb895630a33d9731d1c" translate="yes" xml:space="preserve">
          <source>FTS5 detail option</source>
          <target state="translated">FTS5详细选项</target>
        </trans-unit>
        <trans-unit id="e2ac950517e98e9c43a54ed519912d5bd79b58f7" translate="yes" xml:space="preserve">
          <source>FTS5 external content tables</source>
          <target state="translated">FTS5外部内容表</target>
        </trans-unit>
        <trans-unit id="e0c1249bfb2f56baeacb4cde9dabe2ee955a0b16" translate="yes" xml:space="preserve">
          <source>FTS5 features APIs allowing it to be extended by:</source>
          <target state="translated">FTS5的API允许通过以下方式进行扩展:</target>
        </trans-unit>
        <trans-unit id="e1bd5d1681b612815e17fb206b574b31c2a015b2" translate="yes" xml:space="preserve">
          <source>FTS5 features an API allowing users to create custom auxiliary functions for advanced ranking and text processing applications. The special &quot;rank&quot; column may be mapped to a custom auxiliary function so that adding &quot;ORDER BY rank&quot; to a query works as expected.</source>
          <target state="translated">FTS5具有一个API,允许用户为高级排名和文本处理应用创建自定义辅助函数。特殊的 &quot;rank &quot;列可以被映射到一个自定义的辅助函数,这样在查询中添加 &quot;ORDER BY rank &quot;就可以按照预期的方式工作。</target>
        </trans-unit>
        <trans-unit id="ee4cd24096e0f7f16f8d144ea2b9d21bbd9f59b7" translate="yes" xml:space="preserve">
          <source>FTS5 features three built-in tokenizer modules, described in subsequent sections:</source>
          <target state="translated">FTS5内置了三个令牌器模块,将在后续章节中介绍。</target>
        </trans-unit>
        <trans-unit id="8d2889e6384a3c8e1420d76ca5051341eea0da68" translate="yes" xml:space="preserve">
          <source>FTS5 has no matchinfo() or offsets() function, and the snippet() function is not as fully-featured as in FTS3/4. However, since FTS5 does provide an API allowing applications to create &lt;a href=&quot;fts5#_custom_auxiliary_functions_api_reference_&quot;&gt;custom auxiliary functions&lt;/a&gt;, any required functionality may be implemented within the application code.</source>
          <target state="translated">FTS5没有matchinfo（）或offsets（）函数，并且snippet（）函数的功能不如FTS3 / 4中的完整。但是，由于FTS5确实提供了允许应用程序创建&lt;a href=&quot;fts5#_custom_auxiliary_functions_api_reference_&quot;&gt;自定义辅助功能&lt;/a&gt;的API ，因此可以在应用程序代码内实现任何必需的功能。</target>
        </trans-unit>
        <trans-unit id="2430fd05563889b52091adbdad5f91fa066de359" translate="yes" xml:space="preserve">
          <source>FTS5 highlight</source>
          <target state="translated">FTS5亮点</target>
        </trans-unit>
        <trans-unit id="b07e20076c08544369fcb149755dcf6772db3bb0" translate="yes" xml:space="preserve">
          <source>FTS5 initial token</source>
          <target state="translated">FTS5初始令牌</target>
        </trans-unit>
        <trans-unit id="10930556ab62d8a86d41116bc36d163e953e4188" translate="yes" xml:space="preserve">
          <source>FTS5 initial token queries</source>
          <target state="translated">FTS5初始令牌查询</target>
        </trans-unit>
        <trans-unit id="ce2ec7726aba85424bd14c5bd9d4baeef31bcd11" translate="yes" xml:space="preserve">
          <source>FTS5 is able to load instance-lists into memory incrementally in order to reduce memory usage and peak allocation size. FTS3/4 very often loads entire instance-lists into memory.</source>
          <target state="translated">FTS5能够以增量方式将实例列表加载到内存中,以减少内存使用和峰值分配大小。FTS3/4经常将整个实例列表加载到内存中。</target>
        </trans-unit>
        <trans-unit id="24a7aee460cc3d419d5ebe70c577eedfa6e8a962" translate="yes" xml:space="preserve">
          <source>FTS5 is an SQLite &lt;a href=&quot;c3ref/module&quot;&gt;virtual table module&lt;/a&gt; that provides &lt;a href=&quot;http://en.wikipedia.org/wiki/Full_text_search&quot;&gt;full-text search&lt;/a&gt; functionality to database applications. In their most elementary form, full-text search engines allow the user to efficiently search a large collection of documents for the subset that contain one or more instances of a search term. The search functionality provided to world wide web users by &lt;a href=&quot;https://sqlite.org/www.google.com&quot;&gt;Google&lt;/a&gt; is, among other things, a full-text search engine, as it allows users to search for all documents on the web that contain, for example, the term &quot;fts5&quot;.</source>
          <target state="translated">FTS5是一个SQLite &lt;a href=&quot;c3ref/module&quot;&gt;虚拟表模块&lt;/a&gt;，它为数据库应用程序提供&lt;a href=&quot;http://en.wikipedia.org/wiki/Full_text_search&quot;&gt;全文本搜索&lt;/a&gt;功能。全文搜索引擎以其最基本的形式允许用户有效地搜索大量文档，以查找包含一个或多个搜索项实例的子集。&lt;a href=&quot;https://sqlite.org/www.google.com&quot;&gt;Google&lt;/a&gt;提供给万维网用户的搜索功能尤其是全文搜索引擎，因为它允许用户搜索网络上包含例如&amp;ldquo; fts5&amp;rdquo;一词的所有文档。</target>
        </trans-unit>
        <trans-unit id="f34c6cc3c296d29e810f53e6d4fd41a1b0f185eb" translate="yes" xml:space="preserve">
          <source>FTS5 is an SQLite &lt;a href=&quot;c3ref/module&quot;&gt;virtual table module&lt;/a&gt; that provides &lt;a href=&quot;https://en.wikipedia.org/wiki/Full_text_search&quot;&gt;full-text search&lt;/a&gt; functionality to database applications. In their most elementary form, full-text search engines allow the user to efficiently search a large collection of documents for the subset that contain one or more instances of a search term. The search functionality provided to world wide web users by &lt;a href=&quot;https://sqlite.org/www.google.com&quot;&gt;Google&lt;/a&gt; is, among other things, a full-text search engine, as it allows users to search for all documents on the web that contain, for example, the term &quot;fts5&quot;.</source>
          <target state="translated">FTS5是一个SQLite&lt;a href=&quot;c3ref/module&quot;&gt;虚拟表模块&lt;/a&gt;，可为数据库应用程序提供&lt;a href=&quot;https://en.wikipedia.org/wiki/Full_text_search&quot;&gt;全文本搜索&lt;/a&gt;功能。全文搜索引擎以其最基本的形式，使用户可以有效地搜索大量文档，以查找包含一个或多个搜索项实例的子集。&lt;a href=&quot;https://sqlite.org/www.google.com&quot;&gt;Google&lt;/a&gt;提供给万维网用户的搜索功能尤其是全文搜索引擎，因为它允许用户搜索网络上包含例如&amp;ldquo; fts5&amp;rdquo;一词的所有文档。</target>
        </trans-unit>
        <trans-unit id="4b943e17490b34630708f8d92456b4e737500a29" translate="yes" xml:space="preserve">
          <source>FTS5 is similar to FTS3/4 in that the primary task of each is to maintain an index mapping from each unique token to a list of instances of that token within a set of documents, where each instance is identified by the document in which it appears and its position within that document. For example:</source>
          <target state="translated">FTS5与FTS3/4类似,每个FTS5的主要任务是维护一个索引映射,从每个独特的标记到一组文档中该标记的实例列表,其中每个实例由其出现的文档及其在该文档中的位置识别。例如:</target>
        </trans-unit>
        <trans-unit id="28789443285151cf93711bf777483eb22fd17981" translate="yes" xml:space="preserve">
          <source>FTS5 merge command</source>
          <target state="translated">FTS5合并命令</target>
        </trans-unit>
        <trans-unit id="615a85fe47554c2ae2e2da14f5e902ed33d73731" translate="yes" xml:space="preserve">
          <source>FTS5 optimize command</source>
          <target state="translated">FTS5优化命令</target>
        </trans-unit>
        <trans-unit id="0ce341b86f3ce708df224781d2c7103f5bb5cb9f" translate="yes" xml:space="preserve">
          <source>FTS5 pgsz option</source>
          <target state="translated">FTS5 pgsz选项</target>
        </trans-unit>
        <trans-unit id="69f712ff2bf8e4e1182aeec1e88d322127cc20b1" translate="yes" xml:space="preserve">
          <source>FTS5 prefix indexes</source>
          <target state="translated">FTS5前缀指数</target>
        </trans-unit>
        <trans-unit id="d94afa813a3fa1122708228da577f46e957ec4ac" translate="yes" xml:space="preserve">
          <source>FTS5 prefix queries</source>
          <target state="translated">FTS5前缀查询</target>
        </trans-unit>
        <trans-unit id="0810946526a1ee798bc7d04dda47aae0cf4f5bff" translate="yes" xml:space="preserve">
          <source>FTS5 provides three built-in auxiliary functions:</source>
          <target state="translated">FTS5提供了三种内置的辅助功能。</target>
        </trans-unit>
        <trans-unit id="ee68dd31a5ed538aa8658c76a53f216b8b87606d" translate="yes" xml:space="preserve">
          <source>FTS5 query syntax</source>
          <target state="translated">FTS5查询语法</target>
        </trans-unit>
        <trans-unit id="bc64d420a66889ad745e1a7998f24fa51307a32d" translate="yes" xml:space="preserve">
          <source>FTS5 rank configuration option</source>
          <target state="translated">FTS5等级配置选项</target>
        </trans-unit>
        <trans-unit id="29f161e2893c38b239a94eada76933f8fd836ec6" translate="yes" xml:space="preserve">
          <source>FTS5 rebuild command</source>
          <target state="translated">FTS5重建命令</target>
        </trans-unit>
        <trans-unit id="71972928748ce21ebd6e0c8734df3ca11afc7431" translate="yes" xml:space="preserve">
          <source>FTS5 recognizes unicode separator characters and case equivalence by default. This is also possible using FTS3/4, but must be explicitly enabled.</source>
          <target state="translated">FTS5 默认情况下识别 unicode 分隔符和大小写相等。使用FTS3/4也可以这样做,但必须明确启用。</target>
        </trans-unit>
        <trans-unit id="f5d20fca7e87996d8a27e365e915ea0b186b5b3d" translate="yes" xml:space="preserve">
          <source>FTS5 snippet</source>
          <target state="translated">FTS5片段</target>
        </trans-unit>
        <trans-unit id="6aaed4eadfc76dccddf726837795395ef54278b6" translate="yes" xml:space="preserve">
          <source>FTS5 supports &quot;ORDER BY rank&quot; for returning results in order of decreasing relevancy.</source>
          <target state="translated">FTS5支持 &quot;ORDER BY rank&quot;,按照相关性递减的顺序返回结果。</target>
        </trans-unit>
        <trans-unit id="6c856c0c41fabc630035575245017f6b0ffd0166" translate="yes" xml:space="preserve">
          <source>FTS5 tables that use the trigram tokenizer also support indexed GLOB and LIKE pattern matching. For example:</source>
          <target state="translated">使用三角符号器的FTS5表还支持索引GLOB和LIKE模式匹配。例如:</target>
        </trans-unit>
        <trans-unit id="36651526ac3e1214a373d0abfdc9f70652ada481" translate="yes" xml:space="preserve">
          <source>FTS5 tokenizers</source>
          <target state="translated">FTS5记名器</target>
        </trans-unit>
        <trans-unit id="8341dd226aacac05e80dcb41438a608e9db2f1da" translate="yes" xml:space="preserve">
          <source>FTS5 usermerge option</source>
          <target state="translated">FTS5 usermerge选项</target>
        </trans-unit>
        <trans-unit id="cc0a745dcfb4d3d66417f75affb8f4b428e7e18f" translate="yes" xml:space="preserve">
          <source>FULL</source>
          <target state="translated">FULL</target>
        </trans-unit>
        <trans-unit id="e0c9bbc8c02d4f1e95081807f3b26672caeb6804" translate="yes" xml:space="preserve">
          <source>FUNCTION( column, EXPR)</source>
          <target state="translated">FUNCTION(column,EXPR)</target>
        </trans-unit>
        <trans-unit id="7c2813bf7bc45de9a6c2f51c171413c9b3b7a03d" translate="yes" xml:space="preserve">
          <source>Factor constant subexpressions in inner loops out to the initialization code in prepared statements.</source>
          <target state="translated">将内循环中的常量子表达式因子出到准备语句中的初始化代码中。</target>
        </trans-unit>
        <trans-unit id="7437a8ac9a8406d5a28deac54292a2ceb4305a26" translate="yes" xml:space="preserve">
          <source>Factor out identifier resolution procedures into separate files.</source>
          <target state="translated">将标识符解析程序分解成单独的文件。</target>
        </trans-unit>
        <trans-unit id="23a5e3f76b07073c425aca79699c202f18528c62" translate="yes" xml:space="preserve">
          <source>Failed attempts to open new read-transactions return SQLITE_LOCKED to the caller. If the caller then calls &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; to register for an unlock-notify callback, the blocking connection is the connection that currently has an open write-transaction on the shared-cache. This prevents writer-starvation since if no new read-transactions may be opened and assuming all existing read-transactions are eventually concluded, the writer will eventually have an opportunity to obtain the required write-lock.</source>
          <target state="translated">打开新的读取事务的尝试失败会将SQLITE_LOCKED返回给调用方。如果调用方随后调用&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;进行解锁通知回调的注册，则阻塞连接是当前在共享缓存上具有打开的写事务的连接。因为如果没有新的读取事务可能被打开并且假设所有现有的读取事务最终都结束了，那么写入程序将最终有机会获得所需的写入锁定，从而避免了写入程序的匮乏。</target>
        </trans-unit>
        <trans-unit id="45820057fbefcc63da006715ab061339bc73301e" translate="yes" xml:space="preserve">
          <source>Failing to obtain the lock on database file zFilename (an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error) could be handled, and</source>
          <target state="translated">未能获取数据库文件zFilename的锁定失败（&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;错误），并且</target>
        </trans-unit>
        <trans-unit id="1678e559c36d96e0e24b4bf5c5d0bd9f149e7c92" translate="yes" xml:space="preserve">
          <source>Failure Related Assumption Details</source>
          <target state="translated">故障相关的假设细节</target>
        </trans-unit>
        <trans-unit id="ba06062b405462213e6604c055442e995f85ca44" translate="yes" xml:space="preserve">
          <source>Failure to specify the schema name on the target table could result in the TEMP trigger being reattached to a table with the same name in another database whenever any schema change occurs.</source>
          <target state="translated">如果没有在目标表上指定模式名称,每当发生任何模式变化时,TEMP触发器可能会被重新连接到另一个数据库中具有相同名称的表。</target>
        </trans-unit>
        <trans-unit id="895d510880d653fd769826cbd799948f90030c9e" translate="yes" xml:space="preserve">
          <source>Fall through to next instruction if the two records compare equal to each other. &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; to P2 if they are different.</source>
          <target state="translated">如果两个记录彼此相等，则进入下一条指令。如果它们不同，则&lt;a href=&quot;opcode#Jump&quot;&gt;跳到&lt;/a&gt; P2。</target>
        </trans-unit>
        <trans-unit id="ff9f81a83e1ed8b26c152684da1b756c9d34df23" translate="yes" xml:space="preserve">
          <source>Fall through to the next instruction the first time this opcode is encountered on each invocation of the byte-code program. &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; to P2 on the second and all subsequent encounters during the same invocation.</source>
          <target state="translated">在每次调用字节码程序时首次遇到此操作码时，请转到下一条指令。在同一调用期间的第二次以及所有后续相遇时&lt;a href=&quot;opcode#Jump&quot;&gt;跳转&lt;/a&gt;到P2。</target>
        </trans-unit>
        <trans-unit id="4825fc22947a286ddae403117f576f82370ef403" translate="yes" xml:space="preserve">
          <source>Fast: In some cases, SQLite is &lt;a href=&quot;fasterthanfs&quot;&gt;faster than direct filesystem I/O&lt;/a&gt;</source>
          <target state="translated">快速：在某些情况下，SQLite &lt;a href=&quot;fasterthanfs&quot;&gt;比直接文件系统I / O更快&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e1334839ab66bd155133d078aded782ef422dd14" translate="yes" xml:space="preserve">
          <source>Faster :memory: databases</source>
          <target state="translated">更快:内存:数据库</target>
        </trans-unit>
        <trans-unit id="6e8eee224def4d229de11ee50227cab6e1bdb960" translate="yes" xml:space="preserve">
          <source>Faster File/Save times</source>
          <target state="translated">更快的文件/保存时间</target>
        </trans-unit>
        <trans-unit id="af9f30a3eb7e4943da2c701a139b322bec0ba86e" translate="yes" xml:space="preserve">
          <source>Faster response to &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt;.</source>
          <target state="translated">对&lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt（）的&lt;/a&gt;响应速度更快。</target>
        </trans-unit>
        <trans-unit id="edc218e97488ebdb256b1041d5517e07adce2150" translate="yes" xml:space="preserve">
          <source>Faster startup times</source>
          <target state="translated">更快的启动时间</target>
        </trans-unit>
        <trans-unit id="da9010a26d80b6d161eaff2cb859c264dae9c0df" translate="yes" xml:space="preserve">
          <source>Fear the Day of Judgment.</source>
          <target state="translated">惧怕审判日。</target>
        </trans-unit>
        <trans-unit id="fc338f87a058158eb824b53705961801516a9460" translate="yes" xml:space="preserve">
          <source>Features</source>
          <target state="translated">Features</target>
        </trans-unit>
        <trans-unit id="9e2b53b61c236af80dd718fde93d4b9af8e005d4" translate="yes" xml:space="preserve">
          <source>Features Of SQLite</source>
          <target state="translated">SQLite的特点</target>
        </trans-unit>
        <trans-unit id="3ce33d56c9e73c091a03d2b7bb8be75cf523ee79" translate="yes" xml:space="preserve">
          <source>Few real-world applications meet either of these preconditions, and hence few real-world applications are vulnerable, even if they use older and unpatched versions of SQLite.</source>
          <target state="translated">很少有真实世界的应用程序满足上述任何一个先决条件,因此很少有真实世界的应用程序是脆弱的,即使它们使用旧的和未打补丁的SQLite版本。</target>
        </trans-unit>
        <trans-unit id="7734fa2f4379d4b84b96b38bcc052442966db7ae" translate="yes" xml:space="preserve">
          <source>Fewer &quot;stat()&quot; system calls issued by the unix VFS.</source>
          <target state="translated">减少unix VFS发出的 &quot;stat()&quot;系统调用。</target>
        </trans-unit>
        <trans-unit id="1f20e66b17a6eb7c2baf1ab68337d91eaf6f4f80" translate="yes" xml:space="preserve">
          <source>Figure</source>
          <target state="translated">Figure</target>
        </trans-unit>
        <trans-unit id="ffe01d11556dbe8fb0084465da7b06965d66e721" translate="yes" xml:space="preserve">
          <source>Figure  - Journal Header Format</source>
          <target state="translated">图-日志标题格式</target>
        </trans-unit>
        <trans-unit id="6dd00e92177e26bc00059a7fff1dc42d87cc45a9" translate="yes" xml:space="preserve">
          <source>Figure  - Journal Record Format</source>
          <target state="translated">图-日志记录格式</target>
        </trans-unit>
        <trans-unit id="714f8199965743ce58b8c530d296fe8dcfb36f8a" translate="yes" xml:space="preserve">
          <source>Figure  - Master Journal Pointer Format</source>
          <target state="translated">图-主日志指针格式</target>
        </trans-unit>
        <trans-unit id="246929a593cb90f02eac87b3dc7c028c9874b4e7" translate="yes" xml:space="preserve">
          <source>Figure  - Virtual File System (VFS) Adaptor</source>
          <target state="translated">图-虚拟文件系统(VFS)适配器</target>
        </trans-unit>
        <trans-unit id="ef3c148391912886e200c8da65ce231cc75c34aa" translate="yes" xml:space="preserve">
          <source>Figure 1</source>
          <target state="translated">图1</target>
        </trans-unit>
        <trans-unit id="e68cc6e58a7e19aad2d3433eb96a9f19c166acb7" translate="yes" xml:space="preserve">
          <source>Figure 1 depicts an example runtime configuration where three database connections have been established. Connection 1 is a normal SQLite database connection. Connections 2 and 3 share a cache The normal locking protocol is used to serialize database access between connection 1 and the shared cache. The internal protocol used to serialize (or not, see &quot;Read-Uncommitted Isolation Mode&quot; below) access to the shared-cache by connections 2 and 3 is described in the remainder of this section.</source>
          <target state="translated">图1描述了一个建立了三个数据库连接的运行时配置示例。连接1是一个正常的SQLite数据库连接。连接2和3共享一个缓存 正常的锁定协议用于序列化连接1和共享缓存之间的数据库访问。用于序列化(或不序列化,请参见下面的 &quot;读-未提交的隔离模式&quot;)连接2和3对共享缓存的访问的内部协议将在本节剩余部分中描述。</target>
        </trans-unit>
        <trans-unit id="27b584f16a8fb3cbea584ae7660b5b6f5a1f97be" translate="yes" xml:space="preserve">
          <source>Figure 11: Lookup Using A Two-Column Index</source>
          <target state="translated">图11:使用双列索引进行查找</target>
        </trans-unit>
        <trans-unit id="afbf37b6ddde714b1aee4d493a305e7aec4b7955" translate="yes" xml:space="preserve">
          <source>Figure 12: Single-Column Lookup On A Multi-Column Index</source>
          <target state="translated">图12:在多列索引上进行单列查找。</target>
        </trans-unit>
        <trans-unit id="bfe311ddb5bb13bd814b1479a18292b808e35f4e" translate="yes" xml:space="preserve">
          <source>Figure 13: A Covering Index</source>
          <target state="translated">图13:覆盖指数</target>
        </trans-unit>
        <trans-unit id="0f9e51f13e0722b260820ee18156800089697691" translate="yes" xml:space="preserve">
          <source>Figure 14: Query Using A Covering Index</source>
          <target state="translated">图 14:使用覆盖索引的查询</target>
        </trans-unit>
        <trans-unit id="2ef4e6f6f7129fc9eb3442eaf5e3eb7840ee5ed8" translate="yes" xml:space="preserve">
          <source>Figure 15: Query With OR Constraints</source>
          <target state="translated">图15:带有OR约束的查询</target>
        </trans-unit>
        <trans-unit id="9dbf47b46e66a5e14af2bbf54935aa2349fe876c" translate="yes" xml:space="preserve">
          <source>Figure 16: Sorting Without An Index</source>
          <target state="translated">图16:无索引排序</target>
        </trans-unit>
        <trans-unit id="8a9044fcbca9b5d94795e41004b37d420b391046" translate="yes" xml:space="preserve">
          <source>Figure 17: Sorting By Rowid</source>
          <target state="translated">图17:按行数排序</target>
        </trans-unit>
        <trans-unit id="ad71a17d48a17e81b6db9cdde1ddbd164b95a57f" translate="yes" xml:space="preserve">
          <source>Figure 18: Sorting With An Index</source>
          <target state="translated">图18:使用索引进行排序</target>
        </trans-unit>
        <trans-unit id="83303d63b04c50c35fd21eb87917f7a1e0531bb0" translate="yes" xml:space="preserve">
          <source>Figure 19: Sorting With A Covering Index</source>
          <target state="translated">图19:使用覆盖指数进行排序。</target>
        </trans-unit>
        <trans-unit id="1eb023f1f91c9b2ae1bfb426a8d21e82d3676214" translate="yes" xml:space="preserve">
          <source>Figure 1: A Two-Column Index</source>
          <target state="translated">图1:双列索引</target>
        </trans-unit>
        <trans-unit id="f2ec4384a71d1b2a7bf7e591672d01dfa91b2162" translate="yes" xml:space="preserve">
          <source>Figure 1: Logical Layout Of Table &quot;FruitsForSale&quot;</source>
          <target state="translated">图1:&quot;FruitsForSale &quot;表的逻辑布局。</target>
        </trans-unit>
        <trans-unit id="3115657a64816c0a2981b799ec021faf2a045c40" translate="yes" xml:space="preserve">
          <source>Figure 20: Search And Sort By Multi-Column Index</source>
          <target state="translated">图20:按多列索引搜索和排序</target>
        </trans-unit>
        <trans-unit id="ca0d5e8c58a01b4bec0a2aa6734f55660d0f996c" translate="yes" xml:space="preserve">
          <source>Figure 21: Search And Sort By Covering Index</source>
          <target state="translated">图21:按覆盖指数搜索和排序</target>
        </trans-unit>
        <trans-unit id="bf1fef781061b6dd79cd2df384db7483037947d7" translate="yes" xml:space="preserve">
          <source>Figure 22: Partial Sort By Index</source>
          <target state="translated">图22:按索引部分排序</target>
        </trans-unit>
        <trans-unit id="3dfec33f32a225432d9d762a93ef2ded86f5829e" translate="yes" xml:space="preserve">
          <source>Figure 2: Full Table Scan</source>
          <target state="translated">图2:全表扫描</target>
        </trans-unit>
        <trans-unit id="b5b1774246aed49a8ebf5fcffbb1777db907fc2a" translate="yes" xml:space="preserve">
          <source>Figure 3: Lookup By Rowid</source>
          <target state="translated">图3:通过Rowid查找</target>
        </trans-unit>
        <trans-unit id="f4281cc98081d9724bc4fbb0552509706b21eb97" translate="yes" xml:space="preserve">
          <source>Figure 4: An Index On The Fruit Column</source>
          <target state="translated">图4:水果柱上的指数。</target>
        </trans-unit>
        <trans-unit id="bbeb4d21244b30dfdb1099da94e7d4dd047e2c7a" translate="yes" xml:space="preserve">
          <source>Figure 5: Indexed Lookup For The Price Of Peaches</source>
          <target state="translated">图5:桃子价格的指数化查询。</target>
        </trans-unit>
        <trans-unit id="6a315683f4774663431b2a906642f3e76145398c" translate="yes" xml:space="preserve">
          <source>Figure 6: Indexed Lookup For The Price Of Oranges</source>
          <target state="translated">图6:橙子价格的指数化查询。</target>
        </trans-unit>
        <trans-unit id="dfdf259371133aceb6bd0b874516d463fa04f42d" translate="yes" xml:space="preserve">
          <source>Figure 7: Indexed Lookup Of California Oranges</source>
          <target state="translated">图7:加州橙子的索引查询。</target>
        </trans-unit>
        <trans-unit id="92a03063612532a1d589fdacb42ff17999f75c21" translate="yes" xml:space="preserve">
          <source>Figure 8: Index On The State Column</source>
          <target state="translated">图8:状态栏的索引</target>
        </trans-unit>
        <trans-unit id="a53d9c7f8b5017e0dc6c43dacf62cc0f65431691" translate="yes" xml:space="preserve">
          <source>Figure 9: Indexed Lookup Of California Oranges</source>
          <target state="translated">图9:加州橙子的索引查询。</target>
        </trans-unit>
        <trans-unit id="2c3cafa4db3f3e1e51b3dff4303502dbe42b7a89" translate="yes" xml:space="preserve">
          <source>File</source>
          <target state="translated">File</target>
        </trans-unit>
        <trans-unit id="45f5aee1359a1f0a38b0b02e4a511dce99e49684" translate="yes" xml:space="preserve">
          <source>File Format Changes in SQLite</source>
          <target state="translated">SQLite中的文件格式变化</target>
        </trans-unit>
        <trans-unit id="997dfbd003e85872d78fb79873d52c3f6038b0bf" translate="yes" xml:space="preserve">
          <source>File Format Requirements Document.</source>
          <target state="translated">文件格式要求文件。</target>
        </trans-unit>
        <trans-unit id="893d9354b59056d10fe8938361fc3dad5acc8613" translate="yes" xml:space="preserve">
          <source>File I/O functions</source>
          <target state="translated">文件I/O功能</target>
        </trans-unit>
        <trans-unit id="83b27b5146777b1e521f460dd5156dedea19d489" translate="yes" xml:space="preserve">
          <source>File Locking And Concurrency In SQLite Version 3</source>
          <target state="translated">SQLite中的文件锁定和并发性 第3版</target>
        </trans-unit>
        <trans-unit id="e6d2f4a1bd6f8ec04bd3bff2e90651e6dff9e651" translate="yes" xml:space="preserve">
          <source>File Locking Levels</source>
          <target state="translated">文件锁定级别</target>
        </trans-unit>
        <trans-unit id="b4b1a33b7414dd35f3915ec557e071d0004461f4" translate="yes" xml:space="preserve">
          <source>File change counter.</source>
          <target state="translated">文件更改计数器。</target>
        </trans-unit>
        <trans-unit id="273f16fa62df833bbd05d3addaa12db905e02445" translate="yes" xml:space="preserve">
          <source>File format changed back to what it was for alpha-1</source>
          <target state="translated">文件格式改回alpha-1的格式。</target>
        </trans-unit>
        <trans-unit id="ea05c62c22362e1dcec83363ef37fc1782a17fc0" translate="yes" xml:space="preserve">
          <source>File format read version. 1 for legacy; 2 for &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;.</source>
          <target state="translated">文件格式读取版本。1表示旧版；&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;为2 。</target>
        </trans-unit>
        <trans-unit id="cf2b8a30295b32fb0155c82d480f8bc862559e2b" translate="yes" xml:space="preserve">
          <source>File format version number was being stored in sqlite_master.tcl multiple times. This was harmless, but unnecessary. It is now fixed.</source>
          <target state="translated">文件格式版本号在 sqlite_master.tcl 中被多次存储。这是无害的,但没有必要。现在已经解决了这个问题。</target>
        </trans-unit>
        <trans-unit id="982769b547928ee3535e252a5941715d91d57b18" translate="yes" xml:space="preserve">
          <source>File format version numbers</source>
          <target state="translated">文件格式版本号</target>
        </trans-unit>
        <trans-unit id="0b3c4b00be4af4f91b01dd7144c1c1ec467e2e45" translate="yes" xml:space="preserve">
          <source>File format version. Currently 3007000.</source>
          <target state="translated">文件格式版本。目前3007000。</target>
        </trans-unit>
        <trans-unit id="56015cfe642c5b994cf8d2813e8f1eb0075f0f7d" translate="yes" xml:space="preserve">
          <source>File format write version. 1 for legacy; 2 for &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;.</source>
          <target state="translated">文件格式写版本。1表示旧版；&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;为2 。</target>
        </trans-unit>
        <trans-unit id="cc8f9db86cdc23665fd1d6d5d0232d3c76fe3eae" translate="yes" xml:space="preserve">
          <source>File locking states</source>
          <target state="translated">文件锁定状态</target>
        </trans-unit>
        <trans-unit id="faefc7760d28988aa893bf9bd1d51b407d9db702" translate="yes" xml:space="preserve">
          <source>File name/path for the zip file record.</source>
          <target state="translated">zip文件记录的文件名/路径。</target>
        </trans-unit>
        <trans-unit id="8b246c552e3af3ea9fddc5a1ee446e8ed647f009" translate="yes" xml:space="preserve">
          <source>File-locking may be disabled at runtime using the sqlite3async_control() API (see below). This may improve performance when an NFS or other network file-system, as the synchronous round-trips to the server be required to establish file locks are avoided. However, if multiple connections attempt to access the same database file when file-locking is disabled, application crashes and database corruption is a likely outcome.</source>
          <target state="translated">文件锁定可以在运行时使用sqlite3async_control()API禁用(见下文)。这可能会提高NFS或其他网络文件系统的性能,因为避免了建立文件锁所需的同步往返服务器。但是,如果在文件锁定被禁用时,多个连接试图访问同一个数据库文件,那么很可能会导致应用程序崩溃和数据库损坏。</target>
        </trans-unit>
        <trans-unit id="2fe8dc7f14d4a14002d5ac56394cd98f360d2487" translate="yes" xml:space="preserve">
          <source>Files in the &quot;src/&quot; folder of the source tree whose names begin with &lt;b&gt;test&lt;/b&gt; are for testing only and are not included in a standard build of the library.</source>
          <target state="translated">源树的&amp;ldquo; src /&amp;rdquo;文件夹中名称以&lt;b&gt;test&lt;/b&gt;开头的文件仅用于测试，不包含在库的标准内部版本中。</target>
        </trans-unit>
        <trans-unit id="54710e28b3c95eb3ec7f0c24ed47099f7d873d00" translate="yes" xml:space="preserve">
          <source>Filesystem corruption</source>
          <target state="translated">文件系统损坏</target>
        </trans-unit>
        <trans-unit id="ae3cccd1ea022e8c58ec99f097af4626efe1d332" translate="yes" xml:space="preserve">
          <source>Filesystem corruption following a power failure might cause the journal to be renamed or deleted.</source>
          <target state="translated">断电后的文件系统损坏可能会导致期刊被重新命名或删除。</target>
        </trans-unit>
        <trans-unit id="570dc6b1cc29b82976bf6615ecf9b8e4538664c3" translate="yes" xml:space="preserve">
          <source>Finalize A Changeset Iterator</source>
          <target state="translated">最终确定一个变化集迭代器</target>
        </trans-unit>
        <trans-unit id="3c0d51279d82c302cafb15142125c52a7d750035" translate="yes" xml:space="preserve">
          <source>Finalize A Dynamic String</source>
          <target state="translated">最终确定一个动态字符串</target>
        </trans-unit>
        <trans-unit id="9fb3423ac93edd814553ea43b04e3501220dde99" translate="yes" xml:space="preserve">
          <source>Finally use &quot;adb shell&quot; to get a shell prompt on the Android device, cd into the /data/local/tmp directory, and begin running the tests as with any other unix host.</source>
          <target state="translated">最后使用 &quot;adb shell &quot;在Android设备上获取shell提示符,cd到/data/local/tmp目录下,和其他unix主机一样开始运行测试。</target>
        </trans-unit>
        <trans-unit id="b793b4c7037146e44c6ebbd985a0e8b5eea1bc2d" translate="yes" xml:space="preserve">
          <source>Finally,</source>
          <target state="translated">Finally,</target>
        </trans-unit>
        <trans-unit id="c3292d9cdfaf21af565aba3eaafc880851d476eb" translate="yes" xml:space="preserve">
          <source>Finally, a column filter for a single column may be specified by using the column name as the LHS of a MATCH operator (instead of the usual table name). For example:</source>
          <target state="translated">最后,可以通过使用列名作为MATCH操作符的LHS(而不是通常的表名)来指定单列的列过滤器。例如:</target>
        </trans-unit>
        <trans-unit id="2ff8d306702ac4434540ba1522c8c4827f58460b" translate="yes" xml:space="preserve">
          <source>Finally, if &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; have been enabled, then the alternative VFS can be specified using the &quot;vfs=&quot; parameter on the URI. This technique works with &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and when a new database is &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed to an existing database connection. For example:</source>
          <target state="translated">最后，如果启用了&lt;a href=&quot;uri&quot;&gt;URI文件名&lt;/a&gt;，则可以使用URI上的&amp;ldquo; vfs =&amp;ldquo;参数来指定备用VFS。这种技术与工程&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（） &lt;/a&gt;，&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（） &lt;/a&gt;，&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（） &lt;/a&gt;，并在新的数据库&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; -ed到现有的数据库连接。例如：</target>
        </trans-unit>
        <trans-unit id="91a5114fdd772d39d541271854872b37789c9cfc" translate="yes" xml:space="preserve">
          <source>Finally, if the value specified for this column is not an integer or a NULL, then it is assumed to be a UNIX permissions string similar to those output by the &quot;ls -l&quot; command (e.g. &quot;-rw-r--r--&quot;, &quot;drwxr-xr-x&quot; etc.). In this case, if the string cannot be parsed it is an error.</source>
          <target state="translated">最后,如果为这一列指定的值不是一个整数或NULL,那么它被认为是一个UNIX权限字符串,类似于 &quot;ls -l &quot;命令输出的值(例如&quot;-rw-r--r--&quot;,&quot;drwxr-xr-x &quot;等)。在这种情况下,如果该字符串不能被解析,则是一个错误。</target>
        </trans-unit>
        <trans-unit id="d4cbf63195ca844a0574b0b67606533ae4726399" translate="yes" xml:space="preserve">
          <source>Finally, let us reiterate that this essay is a thought experiment. The OpenDocument format is well-established and already well-designed. Nobody really believes that OpenDocument should be changed to use SQLite as its container instead of ZIP. Nor is this article a criticism of OpenDocument for not choosing SQLite as its container since OpenDocument predates SQLite. Rather, the point of this article is to use OpenDocument as a concrete example of how SQLite can be used to build better application file formats for future projects.</source>
          <target state="translated">最后,让我们重申,这篇论文是一个思想实验。OpenDocument的格式已经很成熟了,而且已经设计得很好,没有人认为应该改变OpenDocument的格式,使用SQLite作为它的容器。没有人真的认为应该把OpenDocument改成使用SQLite而不是ZIP作为其容器。本文也不是批评OpenDocument没有选择SQLite作为它的容器,因为OpenDocument早于SQLite。相反,本文的目的是将OpenDocument作为一个具体的例子,说明如何使用SQLite为未来的项目构建更好的应用文件格式。</target>
        </trans-unit>
        <trans-unit id="073894d80c5b6bf878448685b3b14eeafe3f2f87" translate="yes" xml:space="preserve">
          <source>Finally, sqlite3rbu_close() is called to close the RBU handle. If the application stopped calling sqlite3rbu_step() before either the vacuum finished or an error occurred, the state of the vacuum is saved in the state database so that it may be resumed later on.</source>
          <target state="translated">最后,调用sqlite3rbu_close()来关闭RBU句柄。如果应用程序在真空结束或发生错误之前停止调用sqlite3rbu_step(),那么真空的状态将被保存在状态数据库中,以便以后可以恢复。</target>
        </trans-unit>
        <trans-unit id="aa4a29ee7b183a9cf65e440601eae0ebf5e26ecb" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;b&gt;journal magic&lt;/b&gt; field always contains a well-known 8-byte string value; the same value stored in the first 8 bytes of a</source>
          <target state="translated">最后，&lt;b&gt;日志魔术&lt;/b&gt;字段始终包含一个众所周知的8字节字符串值；存储在a的前8个字节中的相同值</target>
        </trans-unit>
        <trans-unit id="4ff8914525afcbdf833ba762265c55d01cd645be" translate="yes" xml:space="preserve">
          <source>Finally, the decimal extension provides the &quot;decimal&quot; collating sequences that compares decimal text strings in numeric order.</source>
          <target state="translated">最后,十进制扩展提供了 &quot;十进制 &quot;整理序列,按数字顺序比较十进制文本字符串。</target>
        </trans-unit>
        <trans-unit id="8605914ae34d83e606a255958e7dd2026ebd2652" translate="yes" xml:space="preserve">
          <source>Finally, the following requirements describe step 5 of the above procedure in more detail.</source>
          <target state="translated">最后,以下要求更详细地描述了上述程序的第五步。</target>
        </trans-unit>
        <trans-unit id="a60f2db9df368ccf37180701e9147b70fddeaf82" translate="yes" xml:space="preserve">
          <source>Finally, we observe that the instrumented memory allocator and the memory leak detector both work over the entire SQLite test suite and the &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt; provides over 99% statement test coverage and that the &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; test harness provides &lt;a href=&quot;testing#coverage&quot;&gt;100% branch test coverage&lt;/a&gt; with no leak leaks. This is strong evidence that dynamic memory allocation is used correctly everywhere within SQLite.</source>
          <target state="translated">最后，我们观察到检测到的内存分配器和内存泄漏检测器都可以在整个SQLite测试套件中工作，&lt;a href=&quot;testing#tcl&quot;&gt;TCL测试套件&lt;/a&gt;提供了超过99％的语句测试覆盖率，并且&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;测试工具提供了&lt;a href=&quot;testing#coverage&quot;&gt;100％的分支测试覆盖率&lt;/a&gt;而没有泄漏泄漏。这有力的证据表明，动态内存分配在SQLite中的任何地方都可以正确使用。</target>
        </trans-unit>
        <trans-unit id="545769c2d22b47615aaec611ab60b4390f1d36ac" translate="yes" xml:space="preserve">
          <source>Find The Database Handle Of A Prepared Statement</source>
          <target state="translated">查找已准备好的报表的数据库句柄。</target>
        </trans-unit>
        <trans-unit id="7a1eb68de891c44654407116abb98e458fc1bd5d" translate="yes" xml:space="preserve">
          <source>Find all check-ins with the $trunk tag and test each one to see if it is a child of $ckid.</source>
          <target state="translated">找到所有带有$trunk标签的签到,并测试每一个签到是否是$ckid的子代。</target>
        </trans-unit>
        <trans-unit id="0ed342ba1f36533ca8947f53603f475b54647d31" translate="yes" xml:space="preserve">
          <source>Find all children of check-in $ckid and test each one to see if it has the $trunk tag.</source>
          <target state="translated">找到check-in $ckid的所有子代,并测试每个子代是否有$trunk标签。</target>
        </trans-unit>
        <trans-unit id="e070eff936a49d2ff08648583ffdfb004cab42c4" translate="yes" xml:space="preserve">
          <source>Find the name of every customer whose account number is an even multiple of 100 between 10000 and 20000.</source>
          <target state="translated">找出账号是100的偶数倍,在10000和20000之间的每个客户的名字。</target>
        </trans-unit>
        <trans-unit id="da3dcd15d290d67e8d58f666d8051f5d819612a5" translate="yes" xml:space="preserve">
          <source>Find the next available sequence number for cursor P1. Write the sequence number into register P2. The sequence number on the cursor is incremented after this instruction.</source>
          <target state="translated">找到游标P1的下一个可用序列号。将序列号写入寄存器P2中。在这条指令之后,游标上的序列号是递增的。</target>
        </trans-unit>
        <trans-unit id="241d2c67f0e7de4a78cfc1411341e1cf4add0d41" translate="yes" xml:space="preserve">
          <source>Find the next prepared statement</source>
          <target state="translated">找到下一份准备好的发言稿</target>
        </trans-unit>
        <trans-unit id="6b89ff41f23972efdb7d4d4d2879439750317194" translate="yes" xml:space="preserve">
          <source>FindFrame(P,M): Given a page number P and a maximum WAL frame index M, return the largest WAL frame index for page P that does not exceed M, or return NULL if there are no frames for page P that do not exceed M.</source>
          <target state="translated">FindFrame(P,M)。给定页码P和最大WAL帧索引M,返回不超过M的P页最大WAL帧索引,如果P页没有不超过M的帧,则返回NULL。</target>
        </trans-unit>
        <trans-unit id="8c22258580b7042e2985fb2531773f63cce4fbd9" translate="yes" xml:space="preserve">
          <source>Finding The Subtype Of SQL Values</source>
          <target state="translated">寻找SQL值的子类型</target>
        </trans-unit>
        <trans-unit id="66cbda77dfc7ac64a5cc57c477b9363b8fe8ac68" translate="yes" xml:space="preserve">
          <source>Finish the &lt;a href=&quot;vdbe&quot;&gt;VDBE tutorial&lt;/a&gt;.</source>
          <target state="translated">完成&lt;a href=&quot;vdbe&quot;&gt;VDBE教程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db0389416175cfda557f294261cdfae0b0e04b4e" translate="yes" xml:space="preserve">
          <source>FinishSeek</source>
          <target state="translated">FinishSeek</target>
        </trans-unit>
        <trans-unit id="e427d7820cf1b8e5b50925cc386518036005e42d" translate="yes" xml:space="preserve">
          <source>Firebird</source>
          <target state="translated">Firebird</target>
        </trans-unit>
        <trans-unit id="74b23cbe57ab08ce3fe7d8464a6e1321304083eb" translate="yes" xml:space="preserve">
          <source>First Improvement: Replace ZIP with SQLite</source>
          <target state="translated">第一次改进。用SQLite代替ZIP</target>
        </trans-unit>
        <trans-unit id="dab25715d81345a4dd48b6f14dd00623e0e7e7b5" translate="yes" xml:space="preserve">
          <source>First copy of the WAL Index Information</source>
          <target state="translated">WAL索引信息的第一份</target>
        </trans-unit>
        <trans-unit id="3fac2c84e2a48e8615e59439a4315e88bc22133f" translate="yes" xml:space="preserve">
          <source>First of all, love the Lord God with your whole heart, your whole soul, and your whole strength.</source>
          <target state="translated">首先,要全心、全意、全力爱主神。</target>
        </trans-unit>
        <trans-unit id="c3afbcc4f52445143bcb3400b71a71870fa31be7" translate="yes" xml:space="preserve">
          <source>Five &quot;read marks&quot;. Each read mark is a 32-bit unsigned integer (4 bytes).</source>
          <target state="translated">五个 &quot;读取标记&quot;。每个读取标记是一个32位无符号整数(4个字节)。</target>
        </trans-unit>
        <trans-unit id="ff744b4cca49b05e1cc47f0cdb68b5f181f74d45" translate="yes" xml:space="preserve">
          <source>Five out of nine columns in the ftsdocs table are updated. Two of the modified columns, &quot;idxed&quot; and &quot;name&quot;, can be updated independently of the query. But the three columns &quot;label&quot;, &quot;url&quot;, and &quot;mtime&quot; all require a join query against the &quot;event&quot; and &quot;blob&quot; tables. Without row values, the equivalent UPDATE would require that the join be repeated three times, once for each column to be updated.</source>
          <target state="translated">ftsdocs表中9个列中有5个列得到更新。其中两列修改后的 &quot;idxed &quot;和 &quot;name &quot;可以独立更新查询。但是 &quot;label&quot;、&quot;url &quot;和 &quot;mtime &quot;这三列都需要对 &quot;event &quot;和 &quot;blob &quot;表进行连接查询。在没有行值的情况下,等价的UPDATE需要重复三次联接查询,每列更新一次。</target>
        </trans-unit>
        <trans-unit id="99a423164819c464ad91761b94c3e9df171d91a1" translate="yes" xml:space="preserve">
          <source>Fix</source>
          <target state="translated">Fix</target>
        </trans-unit>
        <trans-unit id="7ce2ceb8be9681b5e40d9c6e6b6dcd07ce10b64b" translate="yes" xml:space="preserve">
          <source>Fix 1-second round-off errors in the strftime() function</source>
          <target state="translated">修正strftime()函数中的1秒取整错误。</target>
        </trans-unit>
        <trans-unit id="be669a2be115c3851827688d94d0394bca0b79ab" translate="yes" xml:space="preserve">
          <source>Fix &lt;a href=&quot;http://www.sqlite.org/src/info/25ee812710&quot;&gt;a bug&lt;/a&gt; causing &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;PRAGMA case_sensitive_like&lt;/a&gt; statements compiled using sqlite3_prepare() to fail with an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error.</source>
          <target state="translated">修复&lt;a href=&quot;http://www.sqlite.org/src/info/25ee812710&quot;&gt;了一个错误，该错误&lt;/a&gt;导致使用sqlite3_prepare（）编译的&lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;PRAGMA case_sensitive_like&lt;/a&gt;语句失败，并出现&lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt;错误。</target>
        </trans-unit>
        <trans-unit id="e8265e2fdb9b8761b939ee47825c38858fb1ca92" translate="yes" xml:space="preserve">
          <source>Fix &lt;a href=&quot;http://www.sqlite.org/src/info/5d863f876e&quot;&gt;a bug&lt;/a&gt; involving frequent changes in and out of WAL mode and VACUUM that could (in theory) cause database corruption.</source>
          <target state="translated">修复&lt;a href=&quot;http://www.sqlite.org/src/info/5d863f876e&quot;&gt;了&lt;/a&gt;涉及频繁进出WAL模式和VACUUM 的错误（理论上可能导致数据库损坏）的错误。</target>
        </trans-unit>
        <trans-unit id="f72a703d4acf0d611ae8259932f411f39fb30a96" translate="yes" xml:space="preserve">
          <source>Fix &lt;a href=&quot;https://www.sqlite.org/src/info/25ee812710&quot;&gt;a bug&lt;/a&gt; causing &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;PRAGMA case_sensitive_like&lt;/a&gt; statements compiled using sqlite3_prepare() to fail with an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error.</source>
          <target state="translated">修复&lt;a href=&quot;https://www.sqlite.org/src/info/25ee812710&quot;&gt;了一个错误，该错误&lt;/a&gt;导致使用sqlite3_prepare（）编译的&lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;PRAGMA case_sensitive_like&lt;/a&gt;语句&lt;a href=&quot;rescode#schema&quot;&gt;因SQLITE_SCHEMA&lt;/a&gt;错误而失败。</target>
        </trans-unit>
        <trans-unit id="ebc77e483d528e448f7c07a6053ed8b19bc0c295" translate="yes" xml:space="preserve">
          <source>Fix &lt;a href=&quot;https://www.sqlite.org/src/info/5d863f876e&quot;&gt;a bug&lt;/a&gt; involving frequent changes in and out of WAL mode and VACUUM that could (in theory) cause database corruption.</source>
          <target state="translated">修复&lt;a href=&quot;https://www.sqlite.org/src/info/5d863f876e&quot;&gt;了&lt;/a&gt;涉及频繁进出WAL模式和VACUUM的错误（理论上可能会导致数据库损坏）的错误。</target>
        </trans-unit>
        <trans-unit id="6db1b858dadb915c24c32523f41d2befabc2cef1" translate="yes" xml:space="preserve">
          <source>Fix &lt;a href=&quot;json1&quot;&gt;the json1 extension&lt;/a&gt; so that it does &lt;u&gt;not&lt;/u&gt; recognize ASCII form-feed as a whitespace character, in order to comply with RFC-7159. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/57eec374ae1d0a1d&quot;&gt;57eec374ae1d0a1d&lt;/a&gt;</source>
          <target state="translated">修复&lt;a href=&quot;json1&quot;&gt;的json1扩展&lt;/a&gt;，使得它&lt;u&gt;不&lt;/u&gt;承认ASCII换页的空白字符，以符合RFC-7159。机票&lt;a href=&quot;https://www.sqlite.org/src/info/57eec374ae1d0a1d&quot;&gt;57eec374ae1d0a1d的&lt;/a&gt;修复</target>
        </trans-unit>
        <trans-unit id="653e1fa5387c0ecff27de328ef34374bea516dcd" translate="yes" xml:space="preserve">
          <source>Fix &lt;a href=&quot;lang_createtable#createtabas&quot;&gt;CREATE TABLE AS&lt;/a&gt; so that columns of type TEXT never end up holding an INT value. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f2ad7de056ab1dc9200&quot;&gt;f2ad7de056ab1dc9200&lt;/a&gt;</source>
          <target state="translated">修复&lt;a href=&quot;lang_createtable#createtabas&quot;&gt;CREATE TABLE AS，&lt;/a&gt;以使TEXT类型的列永远不会保持INT值。门票&lt;a href=&quot;https://www.sqlite.org/src/info/f2ad7de056ab1dc9200&quot;&gt;f2ad7de056ab1dc9200&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="091608f8d0d4066f12489a0e4488600c5939f66b" translate="yes" xml:space="preserve">
          <source>Fix &lt;a href=&quot;lang_createtable#createtabas&quot;&gt;CREATE TABLE AS&lt;/a&gt; so that it does not leave NULL entries in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master table&lt;/a&gt; if the SELECT statement on the right-hand side aborts with an error. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/873cae2b6e25b&quot;&gt;873cae2b6e25b&lt;/a&gt;</source>
          <target state="translated">修复&lt;a href=&quot;lang_createtable#createtabas&quot;&gt;CREATE TABLE AS，&lt;/a&gt;以便如果右侧的SELECT语句因错误中止而不会在&lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master表中&lt;/a&gt;保留NULL条目。机票&lt;a href=&quot;https://www.sqlite.org/src/info/873cae2b6e25b&quot;&gt;873cae2b6e25b&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a5bfd890a6d0bc32b97f04e691e6798fb4c63141" translate="yes" xml:space="preserve">
          <source>Fix &lt;a href=&quot;lang_createtable#createtabas&quot;&gt;CREATE TABLE AS&lt;/a&gt; so that it does not leave NULL entries in the &lt;a href=&quot;schematab&quot;&gt;sqlite_master table&lt;/a&gt; if the SELECT statement on the right-hand side aborts with an error. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/873cae2b6e25b&quot;&gt;873cae2b6e25b&lt;/a&gt;</source>
          <target state="translated">修复&lt;a href=&quot;lang_createtable#createtabas&quot;&gt;CREATE TABLE AS，&lt;/a&gt;以便如果右侧的SELECT语句因错误中止而不会在&lt;a href=&quot;schematab&quot;&gt;sqlite_master表中&lt;/a&gt;保留NULL条目。机票&lt;a href=&quot;https://www.sqlite.org/src/info/873cae2b6e25b&quot;&gt;873cae2b6e25b&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ac8940c23a1d170f8aa53744c8aaeb1be9b1ef6c" translate="yes" xml:space="preserve">
          <source>Fix &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt; so that they inherit column datatypes from the table that they are defined against, when possible.</source>
          <target state="translated">修复&lt;a href=&quot;lang_createview&quot;&gt;视图，&lt;/a&gt;以便在可能时从定义表继承列数据类型。</target>
        </trans-unit>
        <trans-unit id="80e2c4478889733dabe7d26f6bdb0764a5389b93" translate="yes" xml:space="preserve">
          <source>Fix VACUUM so that it works with AUTOINCREMENT.</source>
          <target state="translated">修正VACUUM,使其与AUTOINCREMENT一起工作。</target>
        </trans-unit>
        <trans-unit id="c07848937a890999ea4da3f0e665f2c7a3794556" translate="yes" xml:space="preserve">
          <source>Fix VDBE stack overflow problems with INSTEAD OF triggers and NULLs in IN operators.</source>
          <target state="translated">修复IN操作符中INSTADE OF触发器和NULLs的VDBE堆栈溢出问题。</target>
        </trans-unit>
        <trans-unit id="55121f8a7129cf78265426bfd91d90add437aa1d" translate="yes" xml:space="preserve">
          <source>Fix a #define that prevented &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; from compiling</source>
          <target state="translated">修复#define，阻止&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;编译</target>
        </trans-unit>
        <trans-unit id="13e6ad7999531a4c075a28adfff4eeebc2c1045e" translate="yes" xml:space="preserve">
          <source>Fix a 16-month-old bug in the query planner that could generate incorrect results when a scalar subquery attempts to use the &lt;a href=&quot;queryplanner#partialsort&quot;&gt;block sorting&lt;/a&gt; optimization. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/cb3aa0641d9a4&quot;&gt;cb3aa0641d9a4&lt;/a&gt;.</source>
          <target state="translated">修复了查询计划器中一个16个月大的错误，当标量子查询尝试使用&lt;a href=&quot;queryplanner#partialsort&quot;&gt;块排序&lt;/a&gt;优化时，该错误可能会生成错误的结果。票证&lt;a href=&quot;https://www.sqlite.org/src/info/cb3aa0641d9a4&quot;&gt;cb3aa0641d9a4&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce67b37c5c15e62d47883a4360d92e7b7a4edca0" translate="yes" xml:space="preserve">
          <source>Fix a 32-bit integer overflow problem that could result in corrupt indices in a database if large negative numbers (less than -2147483648) were inserted into an indexed numeric column.</source>
          <target state="translated">修复了一个32位整数溢出的问题,如果将大的负数(小于-2147483648)插入到索引的数字列中,可能会导致数据库中的索引损坏。</target>
        </trans-unit>
        <trans-unit id="a4f159ffac47049907d64d00a20c1c1b2dcba7ac" translate="yes" xml:space="preserve">
          <source>Fix a &lt;a href=&quot;datatype3#affinity&quot;&gt;column affinity&lt;/a&gt; problem with the &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt;. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/9a8b09f8e6&quot;&gt;9a8b09f8e6&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;lang_expr#in_op&quot;&gt;IN运算符&lt;/a&gt;修复&lt;a href=&quot;datatype3#affinity&quot;&gt;列关联性&lt;/a&gt;问题。票&lt;a href=&quot;http://www.sqlite.org/src/info/9a8b09f8e6&quot;&gt;9a8b09f8e6&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5351f3fc9cc93f2587f9ef5863d337267a456acf" translate="yes" xml:space="preserve">
          <source>Fix a &lt;a href=&quot;datatype3#affinity&quot;&gt;column affinity&lt;/a&gt; problem with the &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/9a8b09f8e6&quot;&gt;9a8b09f8e6&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;lang_expr#in_op&quot;&gt;IN运算符&lt;/a&gt;修复&lt;a href=&quot;datatype3#affinity&quot;&gt;列亲和力&lt;/a&gt;问题。票&lt;a href=&quot;https://www.sqlite.org/src/info/9a8b09f8e6&quot;&gt;9a8b09f8e6&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c700ca4bfcd722334b41ae90cb174f21fd61403d" translate="yes" xml:space="preserve">
          <source>Fix a &lt;a href=&quot;http://www.sqlite.org/src/info/b7c8682cc1&quot;&gt;bug&lt;/a&gt; introduced in &lt;a href=&quot;#version_3_7_10&quot;&gt;version 3.7.10&lt;/a&gt; that might cause a LEFT JOIN to be incorrectly converted into an INNER JOIN if the WHERE clause indexable terms connected by OR.</source>
          <target state="translated">修复了&lt;a href=&quot;#version_3_7_10&quot;&gt;版本3.7.10&lt;/a&gt;中引入的&lt;a href=&quot;http://www.sqlite.org/src/info/b7c8682cc1&quot;&gt;错误&lt;/a&gt;，如果WHERE子句可索引的术语由OR连接，则该错误可能导致LEFT JOIN被错误地转换为INNER JOIN。</target>
        </trans-unit>
        <trans-unit id="bd18b536dcd5b258edde9f083108e654fded1fef" translate="yes" xml:space="preserve">
          <source>Fix a &lt;a href=&quot;https://www.sqlite.org/src/info/b7c8682cc1&quot;&gt;bug&lt;/a&gt; introduced in &lt;a href=&quot;#version_3_7_10&quot;&gt;version 3.7.10&lt;/a&gt; that might cause a LEFT JOIN to be incorrectly converted into an INNER JOIN if the WHERE clause indexable terms connected by OR.</source>
          <target state="translated">修复了&lt;a href=&quot;#version_3_7_10&quot;&gt;版本3.7.10&lt;/a&gt;中引入的&lt;a href=&quot;https://www.sqlite.org/src/info/b7c8682cc1&quot;&gt;错误&lt;/a&gt;，如果WHERE子句可索引的术语由OR连接，则该错误可能导致LEFT JOIN被错误地转换为INNER JOIN。</target>
        </trans-unit>
        <trans-unit id="1b3da353b2f72b307d534809a0843fba3651f875" translate="yes" xml:space="preserve">
          <source>Fix a NULL pointer dereference in ATTACH/DETACH following a maliciously constructed syntax error. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/2f1b168ab4d4844&quot;&gt;2f1b168ab4d4844&lt;/a&gt;.</source>
          <target state="translated">在恶意构造的语法错误之后，修复ATTACH / DETACH中的NULL指针取消引用。门票&lt;a href=&quot;https://www.sqlite.org/src/info/2f1b168ab4d4844&quot;&gt;2f1b168ab4d4844&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="17fc4210b6dfacb182d91554ad786d32ff022dca" translate="yes" xml:space="preserve">
          <source>Fix a NULL-pointer dereference/crash that could occurs when a transitive WHERE clause references a non-existent collating sequence. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/e8d439c77685eca6&quot;&gt;e8d439c77685eca6&lt;/a&gt;.</source>
          <target state="translated">修复了当传递WHERE子句引用不存在的整理序列时可能发生的NULL指针取消引用/崩溃。票证&lt;a href=&quot;https://www.sqlite.org/src/info/e8d439c77685eca6&quot;&gt;e8d439c77685eca6&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2d9ac49b0e2e7ef5de936abd680dc68a27fa30a0" translate="yes" xml:space="preserve">
          <source>Fix a backwards compatibility problem in version 3.12.0 and 3.12.1: Columns declared as &lt;code&gt;&quot;INTEGER&quot; PRIMARY KEY&lt;/code&gt; (with quotes around the datatype keyword) were not being recognized as an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, which resulted in an incompatible database file. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7d7525cb01b68&quot;&gt;7d7525cb01b68&lt;/a&gt;</source>
          <target state="translated">修复了3.12.0和3.12.1版中的向后兼容性问题：声明为 &lt;code&gt;&quot;INTEGER&quot; PRIMARY KEY&lt;/code&gt; （带有datatype关键字的引号）的列未被识别为&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;，这导致数据库文件不兼容。机票&lt;a href=&quot;https://www.sqlite.org/src/info/7d7525cb01b68&quot;&gt;7d7525cb01b68&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2a0318a8c44e81fefd0856134a5f3fbaa5501b8f" translate="yes" xml:space="preserve">
          <source>Fix a blunder in the Unix mutex implementation that can lead to deadlock on multithreaded systems.</source>
          <target state="translated">修正了Unix mutex实现中的一个错误,该错误可能导致多线程系统的死锁。</target>
        </trans-unit>
        <trans-unit id="be0de15ce56f51daac8ff3913d5b4688f8feba74" translate="yes" xml:space="preserve">
          <source>Fix a boundary condition error introduced by version 3.12.0 that can result in a crash during heavy &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; usage. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7f7f8026eda38&quot;&gt;7f7f8026eda38&lt;/a&gt;.</source>
          <target state="translated">修复了3.12.0版本引入的边界条件错误，该错误可能在大量使用&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT时&lt;/a&gt;导致崩溃。机票&lt;a href=&quot;https://www.sqlite.org/src/info/7f7f8026eda38&quot;&gt;7f7f8026eda38&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="be5dcc6b578060cb5dc3ca4c23baedea5a1b2470" translate="yes" xml:space="preserve">
          <source>Fix a buffer overread that might occur if &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; is used to query a corrupt database file.</source>
          <target state="translated">修复了在使用&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;查询损坏的数据库文件时可能发生的缓冲区溢出。</target>
        </trans-unit>
        <trans-unit id="ca2f1fb1d0cfb02ea2efcffdd2e281055a42ff0e" translate="yes" xml:space="preserve">
          <source>Fix a buffer-overrun problem in &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; which occurs when a string without a zero-terminator is passed to &quot;%.*s&quot;.</source>
          <target state="translated">修复了&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）中&lt;/a&gt;的缓冲区溢出问题，该问题在不带零终止符的字符串传递给&amp;ldquo;％。* s&amp;rdquo;时发生。</target>
        </trans-unit>
        <trans-unit id="fb7444fa62b4ee35a92c0c428d8d337f76386f0f" translate="yes" xml:space="preserve">
          <source>Fix a bug (discovered by OSSFuzz) that causes an assertion fault if certain dodgy CREATE TABLE declarations are used. Ticket &lt;a href=&quot;https://sqlite.org/src/info/bc115541132dad136&quot;&gt;bc115541132dad136&lt;/a&gt;</source>
          <target state="translated">如果使用某些狡猾的CREATE TABLE声明，请修复导致断言错误的错误（由OSSFuzz发现）。门票&lt;a href=&quot;https://sqlite.org/src/info/bc115541132dad136&quot;&gt;bc115541132dad136&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e41d5ca51e4539e3e6f67be481f8af26cda08c2" translate="yes" xml:space="preserve">
          <source>Fix a bug (present since &lt;a href=&quot;#version_3_9_0&quot;&gt;version 3.9.0&lt;/a&gt;) that can cause the &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operation to miss rows if &lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;PRAGMA reverse_unordered_selects&lt;/a&gt; is turned on. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/a306e56ff68b8fa5&quot;&gt;a306e56ff68b8fa5&lt;/a&gt;</source>
          <target state="translated">修复了一个错误（自&lt;a href=&quot;#version_3_9_0&quot;&gt;3.9.0版开始&lt;/a&gt;存在），如果打开了&lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;PRAGMA reverse_unordered_selects，&lt;/a&gt;则可能导致&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;操作丢失行。门票&lt;a href=&quot;https://www.sqlite.org/src/info/a306e56ff68b8fa5&quot;&gt;a306e56ff68b8fa5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="54d44af51dd9a421c7ecd0eded2acf535ab0d495" translate="yes" xml:space="preserve">
          <source>Fix a bug (present since version 3.7.13) that could result in database corruption on windows if two or more processes try to access the same database file at the same time and immediately after third process crashed in the middle of committing to that same file. See ticket &lt;a href=&quot;http://www.sqlite.org/src/info/7ff3120e4f&quot;&gt;7ff3120e4f&lt;/a&gt; for further information.</source>
          <target state="translated">修复了一个错误（自3.7.13版本以来存在），如果两个或多个进程尝试同时访问同一数据库文件，并且在提交同一文件的中间第三个进程崩溃后立即尝试访问同一数据库文件，则该错误可能导致Windows上的数据库损坏。有关更多信息，请参见票证&lt;a href=&quot;http://www.sqlite.org/src/info/7ff3120e4f&quot;&gt;7ff3120e4f&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="836cc1fa7ac3e3036f72a55890d3a439d7321c66" translate="yes" xml:space="preserve">
          <source>Fix a bug (present since version 3.7.13) that could result in database corruption on windows if two or more processes try to access the same database file at the same time and immediately after third process crashed in the middle of committing to that same file. See ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7ff3120e4f&quot;&gt;7ff3120e4f&lt;/a&gt; for further information.</source>
          <target state="translated">修复了一个错误（自3.7.13版本以来存在），如果两个或多个进程尝试同时访问同一数据库文件，并且在提交同一文件的中间第三个进程崩溃后立即尝试访问同一数据库文件，则该错误可能导致Windows上的数据库损坏。有关更多信息，请参见票证&lt;a href=&quot;https://www.sqlite.org/src/info/7ff3120e4f&quot;&gt;7ff3120e4f&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="52cd073d277867a6532709b039582ead6364202d" translate="yes" xml:space="preserve">
          <source>Fix a bug (ticket #2273) that could cause a segfault when the IN operator is used one one term of a two-column index and the right-hand side of the IN operator contains a NULL.</source>
          <target state="translated">修正了一个bug(ticket #2273),当IN操作符用于两列索引中的一个术语,并且IN操作符的右侧包含一个NULL时,可能会导致一个segfault。</target>
        </trans-unit>
        <trans-unit id="1b4373a8bed1703d94011bbf7b01bd3bd2002f0a" translate="yes" xml:space="preserve">
          <source>Fix a bug (ticket #2913) that prevented virtual tables from working in a LEFT JOIN. The problem was introduced into shortly before the 3.5.5 release.</source>
          <target state="translated">修正了一个错误(ticket #2913),防止虚拟表在LEFT JOIN中工作。这个问题是在3.5.5发布前不久引入的。</target>
        </trans-unit>
        <trans-unit id="e9815ddc115669106a2e918a17fe2c7f8f2e58b3" translate="yes" xml:space="preserve">
          <source>Fix a bug (ticket #2927) in the register allocation for compound selects - introduced by the new VM code in version 3.5.5.</source>
          <target state="translated">修正复合选择的寄存器分配中的一个错误(ticket #2927)--由3.5.5版本的新VM代码引入。</target>
        </trans-unit>
        <trans-unit id="0251ebbb4578c3eee40a3a6252b33652a004ab77" translate="yes" xml:space="preserve">
          <source>Fix a bug (ticket #3929) that occasionally causes INSERT or UPDATE operations to fail on an indexed table that has a self-modifying trigger.</source>
          <target state="translated">修复了一个bug(ticket #3929),该bug偶尔会导致在有自修改触发器的索引表上的INSERT或UPDATE操作失败。</target>
        </trans-unit>
        <trans-unit id="d3832aaea84b1f718a1bb048238cd8a3bc9bc19d" translate="yes" xml:space="preserve">
          <source>Fix a bug (ticket &lt;a href=&quot;http://www.sqlite.org/src/info/4c86b126f2&quot;&gt;4c86b126f2&lt;/a&gt;) that causes rows to go missing on some queries with OR clauses and IS NOT NULL operators in the WHERE clause, when the &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; or &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time options are used.</source>
          <target state="translated">修复了使用&lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt;或&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;编译时选项时，导致在带有OR子句和WHERE子句中的IS NOT NULL运算符的某些查询中行丢失的错误（票&lt;a href=&quot;http://www.sqlite.org/src/info/4c86b126f2&quot;&gt;4c86b126f2&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5cf57837bbedc091bf1a9a8a86eff54c1cbf0549" translate="yes" xml:space="preserve">
          <source>Fix a bug (ticket &lt;a href=&quot;https://sqlite.org/www.sqlite.org/src/tktview/d02e1406a58ea02d&quot;&gt;[d02e1406a58ea02d]]&lt;/a&gt;) that causes a segfault on a LEFT JOIN that includes an OR in the ON clause.</source>
          <target state="translated">修复导致在LEFT JOIN上出现段错误（在ON子句中包含OR）的错误（票证&lt;a href=&quot;https://sqlite.org/www.sqlite.org/src/tktview/d02e1406a58ea02d&quot;&gt;[d02e1406a58ea02d]]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="150bcf2022457384fa67a29e77f678763b594e30" translate="yes" xml:space="preserve">
          <source>Fix a bug (ticket &lt;a href=&quot;https://www.sqlite.org/src/info/2326c258d02ead33&quot;&gt;2326c258d02ead33&lt;/a&gt;) that can lead to incorrect results if the qualifying constraint of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; appears in the ON clause of a LEFT JOIN.</source>
          <target state="translated">修复了如果&lt;a href=&quot;partialindex&quot;&gt;部分索引&lt;/a&gt;的限定约束出现在LEFT JOIN的ON子句中的错误（票号&lt;a href=&quot;https://www.sqlite.org/src/info/2326c258d02ead33&quot;&gt;2326c258d02ead33&lt;/a&gt;），该错误可能导致错误的结果。</target>
        </trans-unit>
        <trans-unit id="43a22a89003f228058fa1a009d11fcb5fe8ec742" translate="yes" xml:space="preserve">
          <source>Fix a bug (ticket &lt;a href=&quot;https://www.sqlite.org/src/info/4c86b126f2&quot;&gt;4c86b126f2&lt;/a&gt;) that causes rows to go missing on some queries with OR clauses and IS NOT NULL operators in the WHERE clause, when the &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; or &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time options are used.</source>
          <target state="translated">修复了一个错误（票证&lt;a href=&quot;https://www.sqlite.org/src/info/4c86b126f2&quot;&gt;4c86b126f2&lt;/a&gt;），当使用&lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt;或&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;编译时选项时，该错误会导致某些带有OR子句和WHERE子句中的IS NOT NULL运算符的查询丢失行。</target>
        </trans-unit>
        <trans-unit id="1a970cab6c15ff586a60a11ea992ea839f10ae97" translate="yes" xml:space="preserve">
          <source>Fix a bug &lt;a href=&quot;http://www.sqlite.org/src/info/c2ad16f997ee9c&quot;&gt;(ticket c2ad16f997)&lt;/a&gt; in the 3.7.12 release that can cause a segfault for certain obscure nested aggregate queries.</source>
          <target state="translated">修复了3.7.12版本中的错误&lt;a href=&quot;http://www.sqlite.org/src/info/c2ad16f997ee9c&quot;&gt;（票号c2ad16f997）&lt;/a&gt;，该错误可能导致某些晦涩的嵌套聚合查询出现段错误。</target>
        </trans-unit>
        <trans-unit id="ccbd844b931e6112d05f0ebe7513aeaacf25e44e" translate="yes" xml:space="preserve">
          <source>Fix a bug &lt;a href=&quot;https://www.sqlite.org/src/info/c2ad16f997ee9c&quot;&gt;(ticket c2ad16f997)&lt;/a&gt; in the 3.7.12 release that can cause a segfault for certain obscure nested aggregate queries.</source>
          <target state="translated">修复了3.7.12版本中的错误&lt;a href=&quot;https://www.sqlite.org/src/info/c2ad16f997ee9c&quot;&gt;（&lt;/a&gt;故障单c2ad16f997），该错误可能导致某些晦涩的嵌套聚合查询出现段错误。</target>
        </trans-unit>
        <trans-unit id="51ba96e9b687649d1638a02359c366ad11eb2427" translate="yes" xml:space="preserve">
          <source>Fix a bug associated with &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; that can lead to database corruption. The bug was introduced in &lt;a href=&quot;#version_3_16_0&quot;&gt;version 3.16.0&lt;/a&gt; (2017-01-02). Ticket &lt;a href=&quot;https://sqlite.org/src/info/fda22108&quot;&gt;fda22108&lt;/a&gt;.</source>
          <target state="translated">修复了与&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;相关的错误，该错误可能导致数据库损坏。该错误是在&lt;a href=&quot;#version_3_16_0&quot;&gt;3.16.0版&lt;/a&gt;（2017-01-02）中引入的。机票&lt;a href=&quot;https://sqlite.org/src/info/fda22108&quot;&gt;fda22108&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4b307eb453950463be890be400bcb57bcc52631d" translate="yes" xml:space="preserve">
          <source>Fix a bug causing a crash when a &lt;a href=&quot;windowfunctions&quot;&gt;window function&lt;/a&gt; is misused. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/4feb3159c6bc3f7e33959&quot;&gt;4feb3159c6bc3f7e33959&lt;/a&gt;.</source>
          <target state="translated">修复了滥用&lt;a href=&quot;windowfunctions&quot;&gt;窗口功能&lt;/a&gt;时导致崩溃的错误。机票&lt;a href=&quot;https://www.sqlite.org/src/info/4feb3159c6bc3f7e33959&quot;&gt;4feb3159c6bc3f7e33959&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cee5afa83d7f05f4fb0199eac752e1fa6d08e720" translate="yes" xml:space="preserve">
          <source>Fix a bug concerning the use of &lt;a href=&quot;rowvalue&quot;&gt;row values&lt;/a&gt; within &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt; (see ticket &lt;a href=&quot;https://www.sqlite.org/src/info/8c9458e7&quot;&gt;8c9458e7&lt;/a&gt;) that was in version 3.15.0 but was not reported until moments after the 3.16.0 release was published.</source>
          <target state="translated">修复了有关在&lt;a href=&quot;lang_createtrigger&quot;&gt;触发器中&lt;/a&gt;使用&lt;a href=&quot;rowvalue&quot;&gt;行值&lt;/a&gt;的错误（请参见&lt;a href=&quot;https://www.sqlite.org/src/info/8c9458e7&quot;&gt;故障&lt;/a&gt;单8c9458e7），该错误在3.15.0版本中，但是直到3.16.0版本发布后才报告。</target>
        </trans-unit>
        <trans-unit id="71975cabda8207d03e62b70b052c839461a12d21" translate="yes" xml:space="preserve">
          <source>Fix a bug effecting DELETE and UPDATE statements that changed more than 40960 rows.</source>
          <target state="translated">修复了一个影响DELETE和UPDATE语句的错误,这些语句改变了超过40960行。</target>
        </trans-unit>
        <trans-unit id="c19062438eee134d4fd76768c8b829db307bd8b6" translate="yes" xml:space="preserve">
          <source>Fix a bug in 3.7.6 that only appears if the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt; file control is used with a build of SQLite that makes use of the HAVE_POSIX_FALLOCATE compile-time option and which has SQLITE_ENABLE_LOCKING_MODE turned off.</source>
          <target state="translated">修复了3.7.6中的错误，该错误仅在&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt;文件控件与使用HAVE_POSIX_FALLOCATE编译时选项且已关闭SQLITE_ENABLE_LOCKING_MODE的SQLite版本一起使用时才会出现。</target>
        </trans-unit>
        <trans-unit id="58bd3a61dd215f4dc0de8f7e4c69f4281129c76a" translate="yes" xml:space="preserve">
          <source>Fix a bug in &lt;a href=&quot;#version_3_6_12&quot;&gt;version 3.6.12&lt;/a&gt; that causes a segfault that when inserting into a table using a DEFAULT value where there is a function as part of the DEFAULT value expression. Ticket #3791.</source>
          <target state="translated">修复了&lt;a href=&quot;#version_3_6_12&quot;&gt;3.6.12版中的&lt;/a&gt;一个错误，该错误会导致segfault，该错误在使用DEFAULT值插入到表中时存在，该函数中有一个函数是DEFAULT值表达式的一部分。机票＃3791。</target>
        </trans-unit>
        <trans-unit id="12af322bb1c5c6e90dac936b110cd29e40c242c1" translate="yes" xml:space="preserve">
          <source>Fix a bug in &lt;a href=&quot;#version_3_6_12&quot;&gt;version 3.6.12&lt;/a&gt; that causes a segfault when running a count(*) on the sqlite_master table of an empty database. Ticket #3774.</source>
          <target state="translated">修复了&lt;a href=&quot;#version_3_6_12&quot;&gt;3.6.12版中的&lt;/a&gt;一个错误，该错误在空数据库的sqlite_master表上运行count（*）时会导致段错误。机票编号3774。</target>
        </trans-unit>
        <trans-unit id="8c7bed4eabe4f021221bdbe53bf5d864f6a114c5" translate="yes" xml:space="preserve">
          <source>Fix a bug in &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; that was causing it to sometimes fail to print an SQL statement if that statement needed to be re-prepared. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/11d5aa455e0d98f3c1e6a08&quot;&gt;11d5aa455e0d98f3c1e6a08&lt;/a&gt;</source>
          <target state="translated">修复了&lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace（）&lt;/a&gt;中的一个错误，如果该错误需要重新准备，该错误有时会导致它无法打印SQL语句。门票&lt;a href=&quot;http://www.sqlite.org/src/info/11d5aa455e0d98f3c1e6a08&quot;&gt;11d5aa455e0d98f3c1e6a08&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="23c398d81ff922efbc1c7aba42f0dbfeb2f5382d" translate="yes" xml:space="preserve">
          <source>Fix a bug in &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; that was causing it to sometimes fail to print an SQL statement if that statement needed to be re-prepared. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/11d5aa455e0d98f3c1e6a08&quot;&gt;11d5aa455e0d98f3c1e6a08&lt;/a&gt;</source>
          <target state="translated">修复了&lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace（）&lt;/a&gt;中的一个错误，如果该错误需要重新准备，该错误有时会导致它无法打印SQL语句。门票&lt;a href=&quot;https://www.sqlite.org/src/info/11d5aa455e0d98f3c1e6a08&quot;&gt;11d5aa455e0d98f3c1e6a08&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52d2997db72cd3a48af4f7a4ac02cf3d05df11b7" translate="yes" xml:space="preserve">
          <source>Fix a bug in &lt;a href=&quot;lang_aggfunc#groupconcat&quot;&gt;group_concat()&lt;/a&gt;, ticket #3841</source>
          <target state="translated">修复&lt;a href=&quot;lang_aggfunc#groupconcat&quot;&gt;group_concat（）&lt;/a&gt;故障单＃3841中的错误</target>
        </trans-unit>
        <trans-unit id="ee7b9b5fa7ce3740b16e9a62ff83417f288103a2" translate="yes" xml:space="preserve">
          <source>Fix a bug in &lt;a href=&quot;lang_createindex&quot;&gt;CREATE UNIQUE INDEX&lt;/a&gt;, introduced when &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; support added in version 3.8.2, that allows a non-unique NOT NULL column to be given a UNIQUE index. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/9a6daf340df99ba93c&quot;&gt;9a6daf340df99ba93c&lt;/a&gt;</source>
          <target state="translated">修复了&lt;a href=&quot;lang_createindex&quot;&gt;CREATE UNIQUE INDEX中的&lt;/a&gt;一个错误，该错误在3.8.2版中添加了&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;支持时引入，该错误允许为非唯一的NOT NULL列赋予UNIQUE索引。门票&lt;a href=&quot;http://www.sqlite.org/src/info/9a6daf340df99ba93c&quot;&gt;9a6daf340df99ba93c&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bf6a8e1e14b9248f4d1a62ac39fc2f79b3e2008f" translate="yes" xml:space="preserve">
          <source>Fix a bug in &lt;a href=&quot;lang_createindex&quot;&gt;CREATE UNIQUE INDEX&lt;/a&gt;, introduced when &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; support added in version 3.8.2, that allows a non-unique NOT NULL column to be given a UNIQUE index. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/9a6daf340df99ba93c&quot;&gt;9a6daf340df99ba93c&lt;/a&gt;</source>
          <target state="translated">修复了&lt;a href=&quot;lang_createindex&quot;&gt;CREATE UNIQUE INDEX中的&lt;/a&gt;一个错误，该错误是在3.8.2版中添加了&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;支持时引入的，该错误允许为非唯一的NOT NULL列赋予UNIQUE索引。门票&lt;a href=&quot;https://www.sqlite.org/src/info/9a6daf340df99ba93c&quot;&gt;9a6daf340df99ba93c&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c0f89fd8501d868e0cf1692fe6c2c59b7af31e92" translate="yes" xml:space="preserve">
          <source>Fix a bug in &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; that can lead to database corruptio if two processes are connected to the database at the same time and one VACUUMs then the other then modifies the database.</source>
          <target state="translated">修复了&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;中的错误，如果两个进程同时连接到数据库，而一个VACUUM，然后另一个进程随后修改了数据库，则可能导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="f19b1530d0c7e58f2b87f9576dc8b2e836f21fd1" translate="yes" xml:space="preserve">
          <source>Fix a bug in &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;, introduced in the previous release, that can cause an incorrect results for queries that use the rowid of the R-Tree on the left-hand side of an &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt;. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/d2889096e7bdeac6&quot;&gt;d2889096e7bdeac6&lt;/a&gt;.</source>
          <target state="translated">修复了先前版本中引入的&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展中&lt;/a&gt;的错误，该错误可能导致使用&lt;a href=&quot;lang_expr#in_op&quot;&gt;IN运算符&lt;/a&gt;左侧的R-Tree的rowid的查询的结果不正确。票证&lt;a href=&quot;http://www.sqlite.org/src/info/d2889096e7bdeac6&quot;&gt;d2889096e7bdeac6&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a32704cc30888ba18c70f054befab6a1b3898ff7" translate="yes" xml:space="preserve">
          <source>Fix a bug in &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;, introduced in the previous release, that can cause an incorrect results for queries that use the rowid of the R-Tree on the left-hand side of an &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d2889096e7bdeac6&quot;&gt;d2889096e7bdeac6&lt;/a&gt;.</source>
          <target state="translated">修复了先前版本中引入的&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展&lt;/a&gt;中的一个错误，该错误可能导致使用&lt;a href=&quot;lang_expr#in_op&quot;&gt;IN运算符&lt;/a&gt;左侧的R-Tree的rowid的查询的结果不正确。票证&lt;a href=&quot;https://www.sqlite.org/src/info/d2889096e7bdeac6&quot;&gt;d2889096e7bdeac6&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e9932e1bb4a31444134a7372fbfdfb3c865e3fba" translate="yes" xml:space="preserve">
          <source>Fix a bug in &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation that causes a crash if an &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; table is &lt;a href=&quot;lang_droptable&quot;&gt;dropped&lt;/a&gt; inside a transaction and a &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; occurs afterwards.</source>
          <target state="translated">修正了一个错误&lt;a href=&quot;vtab&quot;&gt;虚表&lt;/a&gt;的实现，会导致系统崩溃如果&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;表被&lt;a href=&quot;lang_droptable&quot;&gt;丢弃&lt;/a&gt;在事务内和&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;之后发生。</target>
        </trans-unit>
        <trans-unit id="51aaba302afca30eafb8d628825b7a74d833e817" translate="yes" xml:space="preserve">
          <source>Fix a bug in &lt;b&gt;CREATE TEMPORARY TABLE&lt;/b&gt; which was causing the table to be initially allocated in the main database file instead of in the separate temporary file. This bug could cause the library to suffer an assertion failure and it could cause &quot;page leaks&quot; in the main database file.</source>
          <target state="translated">修复了&lt;b&gt;CREATE TEMPORARY TABLE中的&lt;/b&gt;一个错误，该错误导致该表最初分配在主数据库文件中，而不是在单独的临时文件中。此错误可能导致库遭受断言失败，并且可能导致主数据库文件中的&amp;ldquo;页面泄漏&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="463c4702a2f65488e2ffd92dbf1a4aa6269d0eb8" translate="yes" xml:space="preserve">
          <source>Fix a bug in ASCII-to-float conversion that causes slow performance and incorrect results when converting numbers with ridiculously large exponents.</source>
          <target state="translated">修复了ASCII到浮点数转换中的一个错误,该错误会在转换指数大得离谱的数字时导致性能缓慢和结果不正确。</target>
        </trans-unit>
        <trans-unit id="4c4bce3264601fae2f025bed0d43c0268a99d3c6" translate="yes" xml:space="preserve">
          <source>Fix a bug in LEFT OUTER JOIN</source>
          <target state="translated">修正LEFT OUTER JOIN中的一个错误</target>
        </trans-unit>
        <trans-unit id="88cb3ba799e20b9ecbe117ccfd853b21e199cf11" translate="yes" xml:space="preserve">
          <source>Fix a bug in SELECT that occurs when a compound SELECT is used as a subquery in the FROM of a SELECT.</source>
          <target state="translated">修正SELECT中的一个BUG,当在SELECT的FROM中使用复合SELECT作为子查询时,会出现这个BUG。</target>
        </trans-unit>
        <trans-unit id="4a083d6c3036b42a4c0efc997cf20ef0d02f9455" translate="yes" xml:space="preserve">
          <source>Fix a bug in VACUUM and UNIQUE indices.</source>
          <target state="translated">修复了VACUUM和UNIQUE指数的一个错误。</target>
        </trans-unit>
        <trans-unit id="7f833cb1ccdd0e046fb058717b1c7c3e8a6a93cd" translate="yes" xml:space="preserve">
          <source>Fix a bug in WHERE clauses of the form (rowid</source>
          <target state="translated">修复了WHERE子句中的一个错误,该子句的形式是(rowid)。</target>
        </trans-unit>
        <trans-unit id="4b37ff9629cc27cedfa263e877ae5948961807f2" translate="yes" xml:space="preserve">
          <source>Fix a bug in Windows locking code so that locks work correctly when simultaneously accessed by Win95 and WinNT systems.</source>
          <target state="translated">修复Windows锁定代码中的一个错误,使Win95和WinNT系统同时访问时,锁能正确工作。</target>
        </trans-unit>
        <trans-unit id="c6465c2fd0a22ca7d523a1361542f1e8ac2184b4" translate="yes" xml:space="preserve">
          <source>Fix a bug in aggregate functions for VIEWs.</source>
          <target state="translated">修正VIEWs集合函数中的一个错误。</target>
        </trans-unit>
        <trans-unit id="ea88e4155c22c256804a9df119ef6c90513e2203" translate="yes" xml:space="preserve">
          <source>Fix a bug in autovacuum that could cause database corruption if a CREATE UNIQUE INDEX fails because of a constraint violation. This problem only occurs if the new autovacuum feature introduced in version 3.1 is turned on.</source>
          <target state="translated">修复了autovacuum中的一个bug,如果CREATE UNIQUE INDEX因违反约束条件而失败,可能会导致数据库损坏。这个问题只有在3.1版本中引入的新的自动真空功能被打开时才会发生。</target>
        </trans-unit>
        <trans-unit id="0a378ba86069bf3761c418cd389173a889e823d3" translate="yes" xml:space="preserve">
          <source>Fix a bug in how the IN operator handles NULLs in subqueries. The bug was introduced by the previous release.</source>
          <target state="translated">修复了IN操作符在子查询中处理NULLs的一个bug。这个错误是由上一个版本引入的。</target>
        </trans-unit>
        <trans-unit id="a112d7c17f6c64f21968d448b366da95b043faa4" translate="yes" xml:space="preserve">
          <source>Fix a bug in that would cause a null pointer to be dereferenced if a column with a DEFAULT that is an aggregate function tried to usee its DEFAULT. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/3a88d85f36704eebe1&quot;&gt;3a88d85f36704eebe1&lt;/a&gt;</source>
          <target state="translated">修复了以下错误：如果具有DEFAULT的列（是聚合函数）试图使用其DEFAULT，则会导致空指针被取消引用。机票&lt;a href=&quot;http://www.sqlite.org/src/info/3a88d85f36704eebe1&quot;&gt;3a88d85f36704eebe1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="868d1ec1de13b4f7d7dbb700346c2aeac7a5ea82" translate="yes" xml:space="preserve">
          <source>Fix a bug in that would cause a null pointer to be dereferenced if a column with a DEFAULT that is an aggregate function tried to usee its DEFAULT. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/3a88d85f36704eebe1&quot;&gt;3a88d85f36704eebe1&lt;/a&gt;</source>
          <target state="translated">修复了以下问题：如果具有DEFAULT的列（是聚合函数）尝试使用其DEFAULT，则会导致空指针被取消引用。机票&lt;a href=&quot;https://www.sqlite.org/src/info/3a88d85f36704eebe1&quot;&gt;3a88d85f36704eebe1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dce4995a552b14017cf9c95aedef49ecc7e0fcc0" translate="yes" xml:space="preserve">
          <source>Fix a bug in the &quot;expr IN ()&quot; operator.</source>
          <target state="translated">修正 &quot;expr IN ()&quot;操作符中的一个错误。</target>
        </trans-unit>
        <trans-unit id="3794a44c73175a8cc1f66ea61529235aef7d447e" translate="yes" xml:space="preserve">
          <source>Fix a bug in the &quot;table_info&quot; pragma&quot;</source>
          <target state="translated">修复了 &quot;table_info &quot;pragma中的一个错误&quot;</target>
        </trans-unit>
        <trans-unit id="c46340ccacfe48d973d04aab053595f54cf0a1ae" translate="yes" xml:space="preserve">
          <source>Fix a bug in the 'start of ...' modifiers for the &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6097cb92745327a1&quot;&gt;6097cb92745327a1&lt;/a&gt;</source>
          <target state="translated">修复了&lt;a href=&quot;lang_datefunc&quot;&gt;日期和时间函数&lt;/a&gt;的&amp;ldquo; ...开始&amp;rdquo;修饰符中的错误。机票&lt;a href=&quot;https://www.sqlite.org/src/info/6097cb92745327a1&quot;&gt;6097cb92745327a1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="047f4b2943991074c70108eded61dc0dd05be0b9" translate="yes" xml:space="preserve">
          <source>Fix a bug in the &lt;a href=&quot;c3ref/backup&quot;&gt;sqlite3_backup&lt;/a&gt; implementation that can lead to a corrupt backup database. Ticket #3858.</source>
          <target state="translated">修复了&lt;a href=&quot;c3ref/backup&quot;&gt;sqlite3_backup&lt;/a&gt;实现中的一个错误，该错误可能导致备份数据库损坏。机票＃3858。</target>
        </trans-unit>
        <trans-unit id="1aae6b9bfc01515c152e99bd1e5ab1e6f3636945" translate="yes" xml:space="preserve">
          <source>Fix a bug in the &lt;a href=&quot;optoverview#flattening&quot;&gt;query flattener&lt;/a&gt; that might cause a segfault for nested queries that use the new &lt;a href=&quot;lang_aggfunc#aggfilter&quot;&gt;FILTER clause on aggregate functions&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/1079ad19993d13fa&quot;&gt;1079ad19993d13fa&lt;/a&gt;</source>
          <target state="translated">修复了&lt;a href=&quot;optoverview#flattening&quot;&gt;查询拼合&lt;/a&gt;器中的错误，该错误可能导致&lt;a href=&quot;lang_aggfunc#aggfilter&quot;&gt;对聚合函数&lt;/a&gt;使用新的FILTER子句的嵌套查询出现段错误。门票&lt;a href=&quot;https://www.sqlite.org/src/info/1079ad19993d13fa&quot;&gt;1079ad19993d13fa&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f17cdc3977288de667446f3b87cd5b853f5d5e34" translate="yes" xml:space="preserve">
          <source>Fix a bug in the &lt;a href=&quot;optoverview#minmax&quot;&gt; min()/max() optimization&lt;/a&gt; when applied to descending indices.</source>
          <target state="translated">修复了将&lt;a href=&quot;optoverview#minmax&quot;&gt;min（）/ max（）优化&lt;/a&gt;应用于降序索引时的错误。</target>
        </trans-unit>
        <trans-unit id="df21276a9ba4f70e8b56ddb1521cb4531a3918b1" translate="yes" xml:space="preserve">
          <source>Fix a bug in the &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; implementation that might result in an incorrect answer if a partial index is used in a subquery or in a &lt;a href=&quot;lang_createview&quot;&gt;view&lt;/a&gt;. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/98d973b8f5&quot;&gt;98d973b8f5&lt;/a&gt;.</source>
          <target state="translated">修复了&lt;a href=&quot;partialindex&quot;&gt;部分索引&lt;/a&gt;实现中的错误，如果在子查询或&lt;a href=&quot;lang_createview&quot;&gt;视图中&lt;/a&gt;使用了部分索引，该错误可能会导致错误的答案。机票&lt;a href=&quot;http://www.sqlite.org/src/info/98d973b8f5&quot;&gt;98d973b8f5&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3dd5de9092b5d0dc122214fb132fd2e5d5db50b9" translate="yes" xml:space="preserve">
          <source>Fix a bug in the &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; implementation that might result in an incorrect answer if a partial index is used in a subquery or in a &lt;a href=&quot;lang_createview&quot;&gt;view&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/98d973b8f5&quot;&gt;98d973b8f5&lt;/a&gt;.</source>
          <target state="translated">修复了&lt;a href=&quot;partialindex&quot;&gt;部分索引&lt;/a&gt;实现中的错误，如果在子查询或&lt;a href=&quot;lang_createview&quot;&gt;视图中&lt;/a&gt;使用了部分索引，则该错误可能导致错误的答案。机票&lt;a href=&quot;https://www.sqlite.org/src/info/98d973b8f5&quot;&gt;98d973b8f5&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5bb0056e629f96818c6e4e0e13be98af5234d969" translate="yes" xml:space="preserve">
          <source>Fix a bug in the &lt;b&gt;-separator&lt;/b&gt; command-line option to the &lt;b&gt;sqlite&lt;/b&gt; command.</source>
          <target state="translated">将&lt;b&gt;-separator&lt;/b&gt;命令行选项中的错误修复为&lt;b&gt;sqlite&lt;/b&gt;命令。</target>
        </trans-unit>
        <trans-unit id="d6bed961ccdc56f2047390095f85abd5dbafe7d0" translate="yes" xml:space="preserve">
          <source>Fix a bug in the &lt;b&gt;sqlite&lt;/b&gt; shell program that was causing a coredump when the output mode was &quot;column&quot; and the first row of data contained a NULL.</source>
          <target state="translated">修复了&lt;b&gt;sqlite&lt;/b&gt; shell程序中的一个错误，该错误在输出模式为&amp;ldquo; column&amp;rdquo;且数据的第一行包含NULL时导致了核心转储。</target>
        </trans-unit>
        <trans-unit id="a7ee300f0b9aa623b87a2f7c0becbea03f86667f" translate="yes" xml:space="preserve">
          <source>Fix a bug in the GLOB operator that was preventing it from working with upper-case letters.</source>
          <target state="translated">修复了GLOB操作符中的一个错误,使其无法使用大写字母。</target>
        </trans-unit>
        <trans-unit id="a793203fc0cd2f8d82f6bb2c04af0a35278a79a3" translate="yes" xml:space="preserve">
          <source>Fix a bug in the IN operator that was introduced by an attempted optimization in version 3.27.0. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/df46dfb631f75694&quot;&gt;df46dfb631f75694&lt;/a&gt;</source>
          <target state="translated">修复了IN运算符在3.27.0版中尝试优化所引入的错误。门票&lt;a href=&quot;https://www.sqlite.org/src/info/df46dfb631f75694&quot;&gt;df46dfb631f75694&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a2b2aae8dc76f1b662e734a37e06cc3bb736c0a2" translate="yes" xml:space="preserve">
          <source>Fix a bug in the IS NULL optimization that was added in version 3.3.9 - the bug was causing incorrect results on certain LEFT JOINs that included in the WHERE clause an IS NULL constraint for the right table of the LEFT JOIN.</source>
          <target state="translated">修复了3.3.9版本中新增的IS NULL优化中的一个bug--该bug导致某些LEFT JOIN的结果不正确,因为在WHERE子句中包含了LEFT JOIN右侧表的IS NULL约束。</target>
        </trans-unit>
        <trans-unit id="32b2ca59c98e57defc81fa337a98f052b51fdc62" translate="yes" xml:space="preserve">
          <source>Fix a bug in the LEFT JOIN &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/cad1ab4cb7b0fc&quot;&gt;cad1ab4cb7b0fc&lt;/a&gt;.</source>
          <target state="translated">修复了LEFT JOIN展&lt;a href=&quot;optoverview#flattening&quot;&gt;平优化中&lt;/a&gt;的错误。票证&lt;a href=&quot;https://www.sqlite.org/src/info/cad1ab4cb7b0fc&quot;&gt;cad1ab4cb7b0fc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="38685e288bff59c882db6ca759d7bfb29309f44e" translate="yes" xml:space="preserve">
          <source>Fix a bug in the LIKE optimizer that occurs when the last character before the first wildcard is an upper-case &quot;Z&quot;</source>
          <target state="translated">修正LIKE优化器中的一个错误,当第一个通配符前的最后一个字符是大写的 &quot;Z &quot;时,会出现这个错误。</target>
        </trans-unit>
        <trans-unit id="c45bdef943497947610b6f15bb60f3f8c0bf760c" translate="yes" xml:space="preserve">
          <source>Fix a bug in the NEAR operator of &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; when applied to subfields. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/38b1ae018f&quot;&gt;38b1ae018f&lt;/a&gt;.</source>
          <target state="translated">修复了应用于子字段时&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;的NEAR运算符中的错误。机票&lt;a href=&quot;http://www.sqlite.org/src/info/38b1ae018f&quot;&gt;38b1ae018f&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="279a9ecf1e9223c6192456afb0a92448d8f06626" translate="yes" xml:space="preserve">
          <source>Fix a bug in the NEAR operator of &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; when applied to subfields. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/38b1ae018f&quot;&gt;38b1ae018f&lt;/a&gt;.</source>
          <target state="translated">修复了应用于子字段时&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;的NEAR运算符中的错误。门票&lt;a href=&quot;https://www.sqlite.org/src/info/38b1ae018f&quot;&gt;38b1ae018f&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fbe8c363630fb44f795b5ddd0d6782543a6fe85a" translate="yes" xml:space="preserve">
          <source>Fix a bug in the ORDER BY clause optimizer for joins where the left-most table in the join is constrained by a UNIQUE index.</source>
          <target state="translated">修复了联接的ORDER BY子句优化器中的一个bug,当联接中最左边的表被一个UNIQUE索引限制时,这个bug就会出现。</target>
        </trans-unit>
        <trans-unit id="aa7ce008f89c153b1eace05cd426c962ecd2e761" translate="yes" xml:space="preserve">
          <source>Fix a bug in the ORDER BY logic that was introduced in version 2.7.0</source>
          <target state="translated">修复了2.7.0版本中引入的ORDER BY逻辑中的一个错误。</target>
        </trans-unit>
        <trans-unit id="23821f33e4999e66f2f0641e1828f40a34f1ba2d" translate="yes" xml:space="preserve">
          <source>Fix a bug in the RTRIM collating sequence.</source>
          <target state="translated">修正RTRIM整理序列中的一个错误。</target>
        </trans-unit>
        <trans-unit id="f7f484abe5d349b673cad3a8de0d61afd71cebdb" translate="yes" xml:space="preserve">
          <source>Fix a bug in the SQLITE_SECURE_DELETE option that was causing Firefox crashes. Make arrangements to always test SQLITE_SECURE_DELETE prior to each release.</source>
          <target state="translated">修复了SQLITE_SECURE_DELETE选项中导致Firefox崩溃的一个错误。安排在每次发布前测试SQLITE_SECURE_DELETE。</target>
        </trans-unit>
        <trans-unit id="6940928d96820acfbcbd9f40b16f8c38b9024a13" translate="yes" xml:space="preserve">
          <source>Fix a bug in the VDBE code generator that caused crashes when doing an INSERT INTO ... SELECT statement where the number of columns being inserted is larger than the number of columns in the destination table. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/e9654505cfda9&quot;&gt;e9654505cfd&lt;/a&gt;</source>
          <target state="translated">修复了VDBE代码生成器中的一个错误，该错误在执行INSERT INTO ... SELECT语句时导致崩溃，该语句插入的列数大于目标表中的列数。机票&lt;a href=&quot;http://www.sqlite.org/src/info/e9654505cfda9&quot;&gt;e9654505cfd&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc495c3be2be30cf58cc4abcb7d9ebf94c6545aa" translate="yes" xml:space="preserve">
          <source>Fix a bug in the VDBE code generator that caused crashes when doing an INSERT INTO ... SELECT statement where the number of columns being inserted is larger than the number of columns in the destination table. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/e9654505cfda9&quot;&gt;e9654505cfd&lt;/a&gt;</source>
          <target state="translated">修复了VDBE代码生成器中的一个错误，该错误在执行INSERT INTO ... SELECT语句时导致崩溃，该语句插入的列数大于目标表中的列数。机票&lt;a href=&quot;https://www.sqlite.org/src/info/e9654505cfda9&quot;&gt;e9654505cfd&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a77d823ed51c71db80398e891bdd02b6519c7cf3" translate="yes" xml:space="preserve">
          <source>Fix a bug in the b-tree delete algorithm that seems like it might be able to cause database corruption. The bug was first introduced in &lt;a href=&quot;#version_3_6_6&quot;&gt;version 3.6.6&lt;/a&gt; by check-in [5899] on 2008-11-13.</source>
          <target state="translated">修复了b树删除算法中似乎可能导致数据库损坏的错误。该错误由2008年11月13日签到[5899] 首次在&lt;a href=&quot;#version_3_6_6&quot;&gt;版本3.6.6中&lt;/a&gt;引入。</target>
        </trans-unit>
        <trans-unit id="1f2e950889f0b3e1a67070b1b57e16286bf69c2d" translate="yes" xml:space="preserve">
          <source>Fix a bug in the b-tree logic that can result in incorrect duplicate answers for IN operator queries. Ticket &lt;a href=&quot;https://sqlite.org/src/info/61fe9745&quot;&gt;61fe9745&lt;/a&gt;</source>
          <target state="translated">修复了b树逻辑中的一个错误，该错误可能导致IN运算符查询的重复答案不正确。门票&lt;a href=&quot;https://sqlite.org/src/info/61fe9745&quot;&gt;61fe9745&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f057be07a38c5126040dd7ba0d2e89c56925fd1" translate="yes" xml:space="preserve">
          <source>Fix a bug in the b-tree subsystem that could sometimes cause the first row of a table to be repeated during a database scan.</source>
          <target state="translated">修复b-tree子系统中的一个bug,该bug有时会导致数据库扫描过程中表的第一行重复。</target>
        </trans-unit>
        <trans-unit id="3878c223944534bca090e7e00dd247a414b7a6aa" translate="yes" xml:space="preserve">
          <source>Fix a bug in the code generator that can cause incorrect results if two or more &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; are joined and the virtual table used in outer loop of the join has an &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt; constraint.</source>
          <target state="translated">修复了代码生成器中的错误，如果两个或多个&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;被联接并且联接的外循环中使用的虚拟表具有&lt;a href=&quot;lang_expr#in_op&quot;&gt;IN运算符&lt;/a&gt;约束，则该错误可能导致错误的结果。</target>
        </trans-unit>
        <trans-unit id="ecc69c155beef2c0a01905468a8453d4d607f81a" translate="yes" xml:space="preserve">
          <source>Fix a bug in the configure script.</source>
          <target state="translated">修正配置脚本中的一个错误。</target>
        </trans-unit>
        <trans-unit id="e769bec58aa8644f68bd5d7d1bfe1cc29fa2dac6" translate="yes" xml:space="preserve">
          <source>Fix a bug in the fts3 snippet() function causing it to omit leading separator characters from snippets that begin with the first token in a column.</source>
          <target state="translated">修正fts3 snippet()函数中的一个bug,该bug会导致从以列中第一个标记开始的snippets中省略前导分隔符。</target>
        </trans-unit>
        <trans-unit id="2545295866be036cf8499a7ef858658efd552656" translate="yes" xml:space="preserve">
          <source>Fix a bug in the handling of &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; errors that could lead to database corruption. Ticket #2686.</source>
          <target state="translated">修复了&lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;错误处理中的一个错误，该错误可能导致数据库损坏。机票＃2686。</target>
        </trans-unit>
        <trans-unit id="9e5c8f1eaffe30d733afa2edd14eb7426ae21825" translate="yes" xml:space="preserve">
          <source>Fix a bug in the handling of UTF16 codepoint 0xE000</source>
          <target state="translated">修正处理UTF16代码点0xE000的错误。</target>
        </trans-unit>
        <trans-unit id="4c6d887f63dbb405c7a71cd63e8fbd9d52e03a50" translate="yes" xml:space="preserve">
          <source>Fix a bug in the locking protocol.</source>
          <target state="translated">修复锁定协议中的一个错误。</target>
        </trans-unit>
        <trans-unit id="6f0cf8c78b30d2944aa061b217d1b3f9efdadbb3" translate="yes" xml:space="preserve">
          <source>Fix a bug in the offsets() function of &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;</source>
          <target state="translated">修复&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;的offsets（）函数中的错误</target>
        </trans-unit>
        <trans-unit id="6a7fee3c78838e4aef23ba9632b4dc89c4818959" translate="yes" xml:space="preserve">
          <source>Fix a bug in the optimization that attempts to omit unused LEFT JOINs</source>
          <target state="translated">修正优化中的一个错误,即试图省略未使用的LEFT JOINs。</target>
        </trans-unit>
        <trans-unit id="5b06586dcca4e61d320a961a9e47d8eb276b85a7" translate="yes" xml:space="preserve">
          <source>Fix a bug in the page cache that can lead database corruption following a rollback. This bug was first introduced in &lt;a href=&quot;#version_3_6_4&quot;&gt;version 3.6.4&lt;/a&gt;.</source>
          <target state="translated">修复了页面缓存中的一个错误，该错误在回滚后可能导致数据库损坏。此错误最早在&lt;a href=&quot;#version_3_6_4&quot;&gt;3.6.4版本中&lt;/a&gt;引入。</target>
        </trans-unit>
        <trans-unit id="a46e1e49b7340ac0ed74db8ca87feecde1f4308f" translate="yes" xml:space="preserve">
          <source>Fix a bug in the query optimizer: an adverse interaction between the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; and the optimization that tries to use values read directly from an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt; instead of recomputing the expression. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/4e8e4857d32d401f&quot;&gt;4e8e4857d32d401f&lt;/a&gt;</source>
          <target state="translated">修复查询优化器中的一个错误：&lt;a href=&quot;optoverview#or_opt&quot;&gt;OR优化&lt;/a&gt;与试图使用直接从&lt;a href=&quot;expridx&quot;&gt;表达式索引&lt;/a&gt;读取的值而不是重新计算表达式的优化之间的不利相互作用。门票&lt;a href=&quot;https://www.sqlite.org/src/info/4e8e4857d32d401f&quot;&gt;4e8e4857d32d401f&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2f3e2194be3728297cf8e6d4eddf0e2da5b578f9" translate="yes" xml:space="preserve">
          <source>Fix a bug in the sorting logic, present since version 3.8.4, that can cause output to appear in the wrong order on queries that contains an ORDER BY clause, a LIMIT clause, and that have approximately 60 or more columns in the result set. Ticket &lt;a href=&quot;https://www.sqlite.org/src/tktview?name=f97c4637102a3ae72b79&quot;&gt;f97c4637102a3ae72b79&lt;/a&gt;.</source>
          <target state="translated">修复了自版本3.8.4起出现的排序逻辑中的错误，该错误可能导致输出在包含ORDER BY子句，LIMIT子句且结果集中具有约60个或更多列的查询上以错误的顺序显示。机票&lt;a href=&quot;https://www.sqlite.org/src/tktview?name=f97c4637102a3ae72b79&quot;&gt;f97c4637102a3ae72b79&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="961b61911dc711c8f8610e6dbfb97dc726ab74a3" translate="yes" xml:space="preserve">
          <source>Fix a bug introduced in 3.3.14 that caused a rollback of CREATE TEMP TABLE to leave the database connection wedged.</source>
          <target state="translated">修正了在 3.3.14 中引入的一个 Bug,这个 Bug 会导致在回滚 CREATE TEMP TABLE 时,数据库连接被卡住。</target>
        </trans-unit>
        <trans-unit id="7dafd437c5fe093f21f82604a02e45e665b33614" translate="yes" xml:space="preserve">
          <source>Fix a bug introduced in 3.6.18 that can lead to a segfault when an attempt is made to write on a read-only database.</source>
          <target state="translated">修正了3.6.18中引入的一个bug,当试图在只读数据库中写入时,可能会导致segfault。</target>
        </trans-unit>
        <trans-unit id="3e91e6207d38fe47800880c516d9f8186320c567" translate="yes" xml:space="preserve">
          <source>Fix a bug introduced in the previous release that can cause a segfault while generating code for complex WHERE clauses.</source>
          <target state="translated">修正上一版本中引入的一个错误,该错误可能会在生成复杂WHERE子句的代码时导致segfault。</target>
        </trans-unit>
        <trans-unit id="4cbb196a2e1220a7bdeefef09bd59463fa0805e1" translate="yes" xml:space="preserve">
          <source>Fix a bug that can cause database corruption if a VACUUM (or autovacuum) fails and is rolled back on a database that is larger than 1GiB</source>
          <target state="translated">修复了一个bug,如果VACUUM(或自动真空)失败,并在大于1GiB的数据库上回滚,会导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="8fcffb46aac4ff97bedf3b9e6f64e13ea5d224e0" translate="yes" xml:space="preserve">
          <source>Fix a bug that can lead to database corruption if an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error occurs in the middle of an explicit transaction and that transaction is later committed. Ticket #2409.</source>
          <target state="translated">修复了以下错误：如果在显式事务的中间发生&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;错误，并且随后又提交了该事务，则可能导致数据库损坏。机票＃2409。</target>
        </trans-unit>
        <trans-unit id="f0062262db2ebf6b0dc42f784bd0016892cca702" translate="yes" xml:space="preserve">
          <source>Fix a bug that can lead to database corruption if autovacuum mode is on and a malloc() failure follows a CREATE TABLE or CREATE INDEX statement which itself follows a cache overflow inside a transaction. See ticket #2418.</source>
          <target state="translated">修复了一个错误,如果自动真空模式开启,并且在CREATE TABLE或CREATE INDEX语句后出现malloc()失败,可能会导致数据库损坏,而该语句本身在事务中出现缓存溢出。请参见 ticket #2418。</target>
        </trans-unit>
        <trans-unit id="57d88d579c18e5b4924089be5a9ae175983b00fb" translate="yes" xml:space="preserve">
          <source>Fix a bug that can lead to database corruption if there are two open connections to the same database and one connection does a VACUUM and the second makes some change to the database.</source>
          <target state="translated">修复了一个bug,如果有两个打开的连接到同一个数据库,一个连接做了VACUUM,第二个连接对数据库做了一些改变,可能会导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="235d3ce4d5053a3a3ebb175799b3496bb1e2bca5" translate="yes" xml:space="preserve">
          <source>Fix a bug that caused &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; values to be truncated when inserted into a table that uses an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/bb4bdb9f7f654b0bb9&quot;&gt;bb4bdb9f7f654b0bb9&lt;/a&gt;</source>
          <target state="translated">修复了一个错误，该错误导致在插入使用&lt;a href=&quot;expridx&quot;&gt;表达式索引&lt;/a&gt;的表时，&lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt;值被截断。门票&lt;a href=&quot;https://www.sqlite.org/src/info/bb4bdb9f7f654b0bb9&quot;&gt;bb4bdb9f7f654b0bb9&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96f87f69bef7402ec8819762f3097cf3cb4bc0c8" translate="yes" xml:space="preserve">
          <source>Fix a bug that caused &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; to fail if the &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; was engaged.</source>
          <target state="translated">修复了一个错误，如果使用&lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes编译指示&lt;/a&gt;会导致&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;失败。</target>
        </trans-unit>
        <trans-unit id="22063eb55417c5408e7943413ae415aaa6bc0f18" translate="yes" xml:space="preserve">
          <source>Fix a bug that caused VACUUM to fail if NULLs appeared in a UNIQUE column.</source>
          <target state="translated">修复了在UNIQUE列中出现NULLs时导致VACUUM失败的错误。</target>
        </trans-unit>
        <trans-unit id="b01b0578c2bd5ee379e0164996215a5a9e5cafe9" translate="yes" xml:space="preserve">
          <source>Fix a bug that caused an extra NULL row to be returned when a descending query was interrupted by a change to the database.</source>
          <target state="translated">修复了一个错误,当数据库发生变化而中断降序查询时,会返回一条额外的NULL记录。</target>
        </trans-unit>
        <trans-unit id="071533ebdec27c28688ac540bc6a87af7b306521" translate="yes" xml:space="preserve">
          <source>Fix a bug that causes incorrect results in aggregate queries that use multiple aggregate functions whose arguments contain complicated expressions that differ only in the case of string literals contained within those expressions.</source>
          <target state="translated">修复一个错误,该错误会导致在使用多个集合函数的集合查询中出现不正确的结果,这些集合函数的参数包含复杂的表达式,而这些表达式中包含的字符串字面值仅有不同。</target>
        </trans-unit>
        <trans-unit id="e234d8c8772201f75d48e658f96b976e70db46a8" translate="yes" xml:space="preserve">
          <source>Fix a bug that could (rarely) cause the database to become unreadable after a DROP TABLE due to corruption to the SQLITE_MASTER table.</source>
          <target state="translated">修复了一个错误,由于SQLITE_MASTER表的损坏,在DROP TABLE之后,可能(很少)导致数据库变得不可读。</target>
        </trans-unit>
        <trans-unit id="4d0709824aa035da84b355852a499807973fe8eb" translate="yes" xml:space="preserve">
          <source>Fix a bug that could cause database corruption when inserting record into tables with around 125 columns.</source>
          <target state="translated">修正在125列左右的表中插入记录时可能导致数据库损坏的错误。</target>
        </trans-unit>
        <trans-unit id="a150aeb08b356b152ddea42ccaf4421a6b9641d1" translate="yes" xml:space="preserve">
          <source>Fix a bug that could cause index corruption when an attempt to delete rows of a table is blocked by a pending query.</source>
          <target state="translated">修复了一个错误,当试图删除表的行时,可能会导致索引损坏。</target>
        </trans-unit>
        <trans-unit id="3e8b7620d6c7d85e18e5166d221c692cea660029" translate="yes" xml:space="preserve">
          <source>Fix a bug that might cause duplicate output rows when an IN operator is used in the WHERE clause. Ticket &lt;a href=&quot;https://sqlite.org/src/info/61fe9745&quot;&gt;61fe9745&lt;/a&gt;.</source>
          <target state="translated">修复了在WHERE子句中使用IN运算符时可能导致输出行重复的错误。门票&lt;a href=&quot;https://sqlite.org/src/info/61fe9745&quot;&gt;61fe9745&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1129d4f4c65ec87058e64f0efea0bacc49cf4128" translate="yes" xml:space="preserve">
          <source>Fix a bug that prevent &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... RENAME&lt;/a&gt; from working on some virtual tables in a database with a UTF16 encoding.</source>
          <target state="translated">修复了一个阻止&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... RENAME&lt;/a&gt;无法以UTF16编码处理数据库中某些虚拟表的错误。</target>
        </trans-unit>
        <trans-unit id="219da8cf0cf50a7385bd113afe9758749614f5f4" translate="yes" xml:space="preserve">
          <source>Fix a bug that prevented the &lt;a href=&quot;pragma#pragma_page_count&quot;&gt;page_count&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;quick_check&lt;/a&gt; pragmas from working correctly if their names were capitalized.</source>
          <target state="translated">修复了一个错误，该错误会导致&lt;a href=&quot;pragma#pragma_page_count&quot;&gt;page_count&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;quick_check&lt;/a&gt;编译指示的名称大写时无法正常工作。</target>
        </trans-unit>
        <trans-unit id="cdefb813daa0922ae7c9b101c4e520cb5ad8e08f" translate="yes" xml:space="preserve">
          <source>Fix a bug that was causing the optimizer to miss an OR optimization opportunity</source>
          <target state="translated">修复了一个导致优化器错失OR优化机会的bug</target>
        </trans-unit>
        <trans-unit id="3ee4681350e42b37480225b05e910c31df54b667" translate="yes" xml:space="preserve">
          <source>Fix a bug that was causing the precompiled binary of SQLITE.EXE to report &quot;out of memory&quot; under Windows 98.</source>
          <target state="translated">修复了在Windows 98下导致预编译的SQLITE.EXE二进制文件报告 &quot;内存不足 &quot;的错误。</target>
        </trans-unit>
        <trans-unit id="b4696dc19dc4ef79e67cd457b6f5dd7958efb5b4" translate="yes" xml:space="preserve">
          <source>Fix a bug that will might corrupt the rollback journal if a power failure or external program halt occurs in the middle of a COMMIT. The corrupt journal can lead to database corruption when it is rolled back.</source>
          <target state="translated">修正了一个错误,如果在COMMIT过程中发生断电或外部程序停止,回滚日志可能会损坏。当回滚时,日志损坏可能会导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="8fe26500762fc616cee225a47a0d139acf639f85" translate="yes" xml:space="preserve">
          <source>Fix a bug which could cause database corruption during a rollback. This bugs was introduced in version 2.4.0 by the freelist optimization of checkin [410].</source>
          <target state="translated">修复了一个在回滚时可能导致数据库损坏的bug。这个bug是在2.4.0版本中由checkin[410]的自由列表优化引入的。</target>
        </trans-unit>
        <trans-unit id="968c6618094d057d35f26f676f0f017e389d2400" translate="yes" xml:space="preserve">
          <source>Fix a bug which prevented deferred foreign key constraints from being enforced when &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; was not called by one statement with a failed foreign key constraint prior to another statement with foreign key constraints running.</source>
          <target state="translated">修复了一个错误，该错误导致在运行带有外键约束的另一条语句之前，未通过失败的外键约束的一条语句调用&lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize（）时&lt;/a&gt;，无法实施延迟的外键约束。</target>
        </trans-unit>
        <trans-unit id="a9887b88380d05a17b65b1ccb749514ab2085ef9" translate="yes" xml:space="preserve">
          <source>Fix a bug which was causing the UPDATE command to fail on systems where &quot;malloc(0)&quot; returns NULL. The problem does not appear on Windows, Linux, or HPUX but does cause the library to fail on QNX.</source>
          <target state="translated">修复了一个 Bug,该 Bug 导致在 &quot;malloc(0)&quot;返回 NULL 的系统上,UPDATE 命令失效。该问题不会出现在 Windows、Linux 或 HPUX 上,但会导致库在 QNX 上失效。</target>
        </trans-unit>
        <trans-unit id="c1055cb4316f59caf76e0609241062a76fd13540" translate="yes" xml:space="preserve">
          <source>Fix a bug, introduced in &lt;a href=&quot;#version_3_7_15&quot;&gt;version 3.7.15&lt;/a&gt;, that causes a segfault if the AS name of a result column of a SELECT statement is used as a logical term in the WHERE clause. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/a7b7803e8d1e869&quot;&gt;a7b7803e8d1e869&lt;/a&gt;.</source>
          <target state="translated">修复了&lt;a href=&quot;#version_3_7_15&quot;&gt;3.7.15版中&lt;/a&gt;引入的错误，如果SELECT语句的结果列的AS名称用作WHERE子句中的逻辑术语，则该错误会导致段错误。门票&lt;a href=&quot;http://www.sqlite.org/src/info/a7b7803e8d1e869&quot;&gt;a7b7803e8d1e869&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d69c38cad9f7046cef8722a31405ade18b327ce" translate="yes" xml:space="preserve">
          <source>Fix a bug, introduced in &lt;a href=&quot;#version_3_7_15&quot;&gt;version 3.7.15&lt;/a&gt;, that causes a segfault if the AS name of a result column of a SELECT statement is used as a logical term in the WHERE clause. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/a7b7803e8d1e869&quot;&gt;a7b7803e8d1e869&lt;/a&gt;.</source>
          <target state="translated">修复了&lt;a href=&quot;#version_3_7_15&quot;&gt;3.7.15版中&lt;/a&gt;引入的错误，如果SELECT语句的结果列的AS名称用作WHERE子句中的逻辑术语，则该错误会导致段错误。门票&lt;a href=&quot;https://www.sqlite.org/src/info/a7b7803e8d1e869&quot;&gt;a7b7803e8d1e869&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8e34d4a301d86656b94178e76078ea4244568334" translate="yes" xml:space="preserve">
          <source>Fix a bug, introduced in &lt;a href=&quot;#version_3_7_15&quot;&gt;version 3.7.15&lt;/a&gt;, that causes an ORDER BY clause to be optimized out of a three-way join when the ORDER BY is actually required. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/598f5f7596b055&quot;&gt;598f5f7596b055&lt;/a&gt;</source>
          <target state="translated">修复了&lt;a href=&quot;#version_3_7_15&quot;&gt;版本3.7.15中&lt;/a&gt;引入的错误，该错误导致在实际需要ORDER BY时，可以从三向联接中优化ORDER BY子句。机票&lt;a href=&quot;http://www.sqlite.org/src/info/598f5f7596b055&quot;&gt;598f5f7596b055&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ae152beeb6de0d22a7c7c2881e903dc70f09e3ae" translate="yes" xml:space="preserve">
          <source>Fix a bug, introduced in &lt;a href=&quot;#version_3_7_15&quot;&gt;version 3.7.15&lt;/a&gt;, that causes an ORDER BY clause to be optimized out of a three-way join when the ORDER BY is actually required. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/598f5f7596b055&quot;&gt;598f5f7596b055&lt;/a&gt;</source>
          <target state="translated">修复了&lt;a href=&quot;#version_3_7_15&quot;&gt;版本3.7.15中&lt;/a&gt;引入的错误，该错误导致在实际需要ORDER BY时，可以从三向联接中优化ORDER BY子句。机票&lt;a href=&quot;https://www.sqlite.org/src/info/598f5f7596b055&quot;&gt;598f5f7596b055&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb89133b15e7a026f1baf9b7fe301f81fe1d3d95" translate="yes" xml:space="preserve">
          <source>Fix a byte alignment problem on 64-bit Sparc machines.</source>
          <target state="translated">修复64位Sparc机器上的字节对齐问题。</target>
        </trans-unit>
        <trans-unit id="6473e2522b76dc29f2ba1c3b0d9873c89f59958f" translate="yes" xml:space="preserve">
          <source>Fix a cache coherency problem that could lead to database corruption. Ticket #3584.</source>
          <target state="translated">修复一个可能导致数据库损坏的缓存一致性问题。票号3584。</target>
        </trans-unit>
        <trans-unit id="f481ad2c49e362e89cd9792732a32d8df98fae76" translate="yes" xml:space="preserve">
          <source>Fix a case (present since 3.8.0 - 2013-08-26) where OR-connected terms in the ON clause of a LEFT JOIN might cause incorrect results. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/34a579141b2c5ac&quot;&gt;34a579141b2c5ac&lt;/a&gt;.</source>
          <target state="translated">修复一种情况（自3.8.0-2013-08-26开始），在这种情况下，LEFT JOIN的ON子句中的OR连接项可能会导致错误的结果。机票&lt;a href=&quot;https://www.sqlite.org/src/info/34a579141b2c5ac&quot;&gt;34a579141b2c5ac&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a50086fd665b1844f9cbf74b7aa34cea2f9e72f" translate="yes" xml:space="preserve">
          <source>Fix a case where the use of &lt;a href=&quot;rowvalue&quot;&gt;row values&lt;/a&gt; in the ON clause of a LEFT JOIN might cause incorrect results. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/fef4bb4bd9185ec8f&quot;&gt;fef4bb4bd9185ec8f&lt;/a&gt;.</source>
          <target state="translated">修复了在LEFT JOIN的ON子句中使用&lt;a href=&quot;rowvalue&quot;&gt;行值&lt;/a&gt;可能导致错误结果的情况。门票&lt;a href=&quot;https://www.sqlite.org/src/info/fef4bb4bd9185ec8f&quot;&gt;fef4bb4bd9185ec8f&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="850a9a02fc22a5dd385d30f0d1ad0aee11fcbb3d" translate="yes" xml:space="preserve">
          <source>Fix a code generator bug introduced in &lt;a href=&quot;#version_3_6_14&quot;&gt;version 3.6.14&lt;/a&gt;. This bug can cause incorrect query results under obscure circumstances. Ticket #3879.</source>
          <target state="translated">修复了&lt;a href=&quot;#version_3_6_14&quot;&gt;3.6.14版本中&lt;/a&gt;引入的代码生成器错误。在模糊的情况下，此错误可能导致错误的查询结果。机票编号3879。</target>
        </trans-unit>
        <trans-unit id="7a882216b94af4a2070d74e5a8f2213bc7c7e6d4" translate="yes" xml:space="preserve">
          <source>Fix a code generator bug that occurs when the left-hand side of an IN operator is constant and the right-hand side is a SELECT statement</source>
          <target state="translated">修正一个代码生成器的错误,当IN操作符的左侧是常数,而右侧是SELECT语句时,会发生这个错误。</target>
        </trans-unit>
        <trans-unit id="9f3aff5bff9f1047fcb33e054774693e6c093317" translate="yes" xml:space="preserve">
          <source>Fix a configuration problem for HPUX.</source>
          <target state="translated">修复HPUX的配置问题。</target>
        </trans-unit>
        <trans-unit id="c2e54ff806a6902137c2c4fd9a054e09b463f65d" translate="yes" xml:space="preserve">
          <source>Fix a configuration program for WinNT.</source>
          <target state="translated">修正一个WinNT的配置程序。</target>
        </trans-unit>
        <trans-unit id="23af7692a6ff84f6d023153258d882cbb37a308d" translate="yes" xml:space="preserve">
          <source>Fix a couple of problems associated with running an UPDATE or DELETE on a &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; with a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; in the WHERE clause.</source>
          <target state="translated">修复了一些与在WHERE子句中具有&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;的&lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt;上运行UPDATE或DELETE相关的问题。</target>
        </trans-unit>
        <trans-unit id="250b9893a36b233fbf22987bf8f6ae81bb4e4fd3" translate="yes" xml:space="preserve">
          <source>Fix a crash that can occur following an out-of-memory condition in the built-in &lt;a href=&quot;lang_corefunc#instr&quot;&gt;instr()&lt;/a&gt; function.</source>
          <target state="translated">修复了内置&lt;a href=&quot;lang_corefunc#instr&quot;&gt;instr（）&lt;/a&gt;函数中由于内存不足而导致的崩溃。</target>
        </trans-unit>
        <trans-unit id="7bf5e6293bb28bf946bc8a30fe12004cac2b4090" translate="yes" xml:space="preserve">
          <source>Fix a critical bug in UPDATE or DELETE that occurs when an OR REPLACE clause or a trigger causes rows in the same table to be deleted as side effects. (See ticket #2832.) The most likely result of this bug is a segmentation fault, though database corruption is a possibility.</source>
          <target state="translated">修复UPDATE或DELETE中的一个严重错误,当OR REPLACE子句或触发器导致同一张表中的行作为副作用被删除时,会发生这个错误。(参见 ticket #2832。)这个错误最可能的结果是分段故障,但数据库损坏也是可能的。</target>
        </trans-unit>
        <trans-unit id="b9fcf5056d43d3f414de5f5ffa794d580179047a" translate="yes" xml:space="preserve">
          <source>Fix a critical bug introduced into 2.8.0 which could cause database corruption.</source>
          <target state="translated">修复了2.8.0中引入的一个可能导致数据库损坏的严重错误。</target>
        </trans-unit>
        <trans-unit id="6104ea2315fdf5ec79a2a34465e1d850ba0d687d" translate="yes" xml:space="preserve">
          <source>Fix a database corruption bug that might occur if a ROLLBACK command is executed in &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto-vacuum mode&lt;/a&gt; and a very small &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit&lt;/a&gt; is set. Ticket #2565.</source>
          <target state="translated">修复了在&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;自动真空模式下&lt;/a&gt;执行ROLLBACK命令并设置了非常小的&lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit时&lt;/a&gt;可能发生的数据库损坏错误。机票＃2565。</target>
        </trans-unit>
        <trans-unit id="549a524d06c92ebec7e6ffb1582d9efa4f972e29" translate="yes" xml:space="preserve">
          <source>Fix a faulty assert() statement discovered by OSSFuzz. Ticket &lt;a href=&quot;https://sqlite.org/src/info/cb91bf4290c211d&quot;&gt;cb91bf4290c211d&lt;/a&gt;</source>
          <target state="translated">修复OSSFuzz发现的错误assert（）语句。门票&lt;a href=&quot;https://sqlite.org/src/info/cb91bf4290c211d&quot;&gt;cb91bf4290c211d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8894e23611b9543c06bdf188b997836d648e35ed" translate="yes" xml:space="preserve">
          <source>Fix a faulty assert() statement. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/369d57fb8e5ccdff06f1&quot;&gt;369d57fb8e5ccdff06f1&lt;/a&gt;</source>
          <target state="translated">修复错误的assert（）语句。机票&lt;a href=&quot;http://www.sqlite.org/src/info/369d57fb8e5ccdff06f1&quot;&gt;369d57fb8e5ccdff06f1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8235e04e5467a5832387dc39f6749cfce32c0614" translate="yes" xml:space="preserve">
          <source>Fix a faulty assert() statement. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/369d57fb8e5ccdff06f1&quot;&gt;369d57fb8e5ccdff06f1&lt;/a&gt;</source>
          <target state="translated">修复错误的assert（）语句。机票&lt;a href=&quot;https://www.sqlite.org/src/info/369d57fb8e5ccdff06f1&quot;&gt;369d57fb8e5ccdff06f1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="636e1cdce08fa0db48343c6add77567a882165ff" translate="yes" xml:space="preserve">
          <source>Fix a few bugs discovered while adding test cases</source>
          <target state="translated">修正在添加测试用例时发现的一些错误</target>
        </trans-unit>
        <trans-unit id="acf902b397dd2f6810f6423a62c7af2c0994b48b" translate="yes" xml:space="preserve">
          <source>Fix a harmless TSAN warning associated with the &lt;a href=&quot;c3ref/db_readonly&quot;&gt;sqlite3_db_readonly()&lt;/a&gt; interface.</source>
          <target state="translated">修复与&lt;a href=&quot;c3ref/db_readonly&quot;&gt;sqlite3_db_readonly（）&lt;/a&gt;接口关联的无害TSAN警告。</target>
        </trans-unit>
        <trans-unit id="81f5e5474510cb05b9499ec918f7ec055d5a9376" translate="yes" xml:space="preserve">
          <source>Fix a harmless compiler warning that was causing problems for VS2013.</source>
          <target state="translated">修复了一个无害的编译器警告,该警告导致了VS2013的问题。</target>
        </trans-unit>
        <trans-unit id="2655086c46a997c2b6b5f7afcdb8bc73a701e203" translate="yes" xml:space="preserve">
          <source>Fix a harmless reference to an uninitialized virtual machine register. Ticket &lt;a href=&quot;https://sqlite.org/src/info/093420fc0eb7cba7&quot;&gt;093420fc0eb7cba7&lt;/a&gt;.</source>
          <target state="translated">修复对未初始化的虚拟机寄存器的无害引用。机票&lt;a href=&quot;https://sqlite.org/src/info/093420fc0eb7cba7&quot;&gt;093420fc0eb7cba7&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="34aba552e98280ade2ad01a58c129c559bbb6622" translate="yes" xml:space="preserve">
          <source>Fix a harmless warning in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; on some versions of MSVC.</source>
          <target state="translated">在某些版本的MSVC上的&lt;a href=&quot;cli&quot;&gt;命令行外壳中&lt;/a&gt;修复无害警告。</target>
        </trans-unit>
        <trans-unit id="ddbae4bd36201745ce6091bd306e15a27174abe7" translate="yes" xml:space="preserve">
          <source>Fix a locking problem on multi-threaded Linux implementations.</source>
          <target state="translated">修复多线程Linux实现上的锁定问题。</target>
        </trans-unit>
        <trans-unit id="0f1b59f0eebd0deebb37ffe61aff53f12ea768f8" translate="yes" xml:space="preserve">
          <source>Fix a locking race condition in Windows that can occur when two or more processes attempt to recover the same &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;hot journal&lt;/a&gt; at the same time.</source>
          <target state="translated">修复了Windows中的一个锁定竞争状态，当两个或多个进程试图同时恢复同一&lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;热日志&lt;/a&gt;时可能发生这种情况。</target>
        </trans-unit>
        <trans-unit id="17e68593b4791e7bd7d4208e13b7223230a1abc9" translate="yes" xml:space="preserve">
          <source>Fix a long-standing bug in INSERT INTO ... SELECT ... statements where the SELECT is compound.</source>
          <target state="translated">修复了INSERT INTO ...SELECT ...语句中的长期错误,其中SELECT是复合的。</target>
        </trans-unit>
        <trans-unit id="fd962c6fc1c64a845409232765bfdaeb36f664fe" translate="yes" xml:space="preserve">
          <source>Fix a long-standing bug in RAISE(IGNORE) as used in BEFORE triggers.</source>
          <target state="translated">修复BEFORE触发器中使用的RAISE(IGNORE)中长期存在的BUG。</target>
        </trans-unit>
        <trans-unit id="5983823f14e9a5e5ea15cf21202053241c588d81" translate="yes" xml:space="preserve">
          <source>Fix a long-standing bug in the &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt; that would recognize UTF16 characters as digits even if their most-significant-byte was not zero. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/689137afb6da41&quot;&gt;689137afb6da41&lt;/a&gt;.</source>
          <target state="translated">修复了&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST表达式&lt;/a&gt;中的一个长期存在的错误，该错误将UTF16字符识别为数字，即使它们的最高有效字节不为零。机票&lt;a href=&quot;http://www.sqlite.org/src/info/689137afb6da41&quot;&gt;689137afb6da41&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1db81609dcce63e9c8dd2cb60747d1c780bb8959" translate="yes" xml:space="preserve">
          <source>Fix a long-standing bug in the &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt; that would recognize UTF16 characters as digits even if their most-significant-byte was not zero. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/689137afb6da41&quot;&gt;689137afb6da41&lt;/a&gt;.</source>
          <target state="translated">修复了&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST表达式&lt;/a&gt;中的一个长期存在的错误，该错误会将UTF16字符识别为数字，即使它们的最高有效字节不为零。机票&lt;a href=&quot;https://www.sqlite.org/src/info/689137afb6da41&quot;&gt;689137afb6da41&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4297ce915073f569ab40d9b2eef2a6a433c9c771" translate="yes" xml:space="preserve">
          <source>Fix a long-standing bug in the byte-code engine that can cause a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; command report as success when in fact it failed to commit. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/810dc8038872e212&quot;&gt;810dc8038872e212&lt;/a&gt;</source>
          <target state="translated">修复了字节码引擎中的一个长期存在的错误，该错误在提交失败时可能导致&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;命令报告成功。机票&lt;a href=&quot;https://www.sqlite.org/src/info/810dc8038872e212&quot;&gt;810dc8038872e212&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1e421af2a92eeb75b68bc6dee75d2cded7fea49f" translate="yes" xml:space="preserve">
          <source>Fix a long-standing bug in the query planner that caused incorrect results on a LEFT JOIN where the left-hand table is a subquery and the join constraint is a bare column name coming from the left-hand subquery. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/2df0107b&quot;&gt;2df0107b&lt;/a&gt;.</source>
          <target state="translated">修复了查询计划器中的一个长期错误，该错误在LEFT JOIN上导致错误的结果，在LEFT JOIN上，左表是子查询，而联接约束是来自左子查询的裸列名称。门票&lt;a href=&quot;https://www.sqlite.org/src/info/2df0107b&quot;&gt;2df0107b&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5fd66bb0d12f0c4694325a08e38b8332a42b240a" translate="yes" xml:space="preserve">
          <source>Fix a long-standing bug in the storage engine that would (very rarely) cause a spurious report of an SQLITE_CORRUPT error but which was otherwise harmless. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/6bfb98dfc0c&quot;&gt;6bfb98dfc0c&lt;/a&gt;.</source>
          <target state="translated">修复了存储引擎中的一个长期存在的错误，该错误（很少）会导致伪造的SQLITE_CORRUPT错误报告，但否则不会造成损害。票证&lt;a href=&quot;http://www.sqlite.org/src/info/6bfb98dfc0c&quot;&gt;6bfb98dfc0c&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f926c45ffb1db1d0be58ba427da0bd78bbf7180" translate="yes" xml:space="preserve">
          <source>Fix a long-standing bug in the storage engine that would (very rarely) cause a spurious report of an SQLITE_CORRUPT error but which was otherwise harmless. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6bfb98dfc0c&quot;&gt;6bfb98dfc0c&lt;/a&gt;.</source>
          <target state="translated">修复了存储引擎中的一个长期存在的错误，该错误（很少）会导致虚假报告SQLITE_CORRUPT错误，但该错误无害。票证&lt;a href=&quot;https://www.sqlite.org/src/info/6bfb98dfc0c&quot;&gt;6bfb98dfc0c&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="71423e6b2d68869ba9f90d3de52635f50c9c7337" translate="yes" xml:space="preserve">
          <source>Fix a long-standing problem in &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables that was reported a few hours after the 3.8.11 release.</source>
          <target state="translated">修正了长期存在的问题&lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes（）&lt;/a&gt;为&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;已报告几个小时3.8.11发布后的表。</target>
        </trans-unit>
        <trans-unit id="29e8d63f91df6bbd58bdb3b0c96b08a128597488" translate="yes" xml:space="preserve">
          <source>Fix a long-standing problem wherein a corrupt schema on the &lt;a href=&quot;fileformat2#seqtab&quot;&gt;sqlite_sequence&lt;/a&gt; table used by &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; can lead to a crash. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d8dc2b3a58cd5dc29&quot;&gt;d8dc2b3a58cd5dc2918a1&lt;/a&gt;</source>
          <target state="translated">修复了一个长期存在的问题，其中&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;使用的&lt;a href=&quot;fileformat2#seqtab&quot;&gt;sqlite_sequence&lt;/a&gt;表上的架构损坏可能导致崩溃。门票&lt;a href=&quot;https://www.sqlite.org/src/info/d8dc2b3a58cd5dc29&quot;&gt;d8dc2b3a58cd5dc2918a1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d123dda0b40a993f6ee01005258efb1310831bb" translate="yes" xml:space="preserve">
          <source>Fix a memory allocation error in the new ADD COLUMN comment.</source>
          <target state="translated">修正新的ADD COLUMN注释中的内存分配错误。</target>
        </trans-unit>
        <trans-unit id="557f85fef49a7d6b5ef7280b85eaabf9d86a9cbc" translate="yes" xml:space="preserve">
          <source>Fix a memory leak that can occur following a disk I/O error.</source>
          <target state="translated">修复磁盘I/O错误后可能发生的内存泄漏。</target>
        </trans-unit>
        <trans-unit id="b2e50e850f4bad5e2b888790e4a27dda05de65d0" translate="yes" xml:space="preserve">
          <source>Fix a memory leak that can occur following a failure to open error in the &lt;a href=&quot;csv&quot;&gt;CSV virtual table&lt;/a&gt;</source>
          <target state="translated">修复在&lt;a href=&quot;csv&quot;&gt;CSV虚拟表中&lt;/a&gt;无法打开错误后可能发生的内存泄漏</target>
        </trans-unit>
        <trans-unit id="08e2d33c27f7ca8760cc5e591fecb5972898df17" translate="yes" xml:space="preserve">
          <source>Fix a memory leak that occurred when sqlite_open() failed.</source>
          <target state="translated">修复sqlite_open()失败时发生的内存泄漏。</target>
        </trans-unit>
        <trans-unit id="475ca6beba2ec99949495af6c237c0b95d23fba9" translate="yes" xml:space="preserve">
          <source>Fix a missing &quot;sync&quot; that when omitted could lead to database corruption if a power failure or OS crash occurred just as a ROLLBACK operation was finishing.</source>
          <target state="translated">修复了一个缺失的 &quot;同步&quot;,如果在ROLLBACK操作刚刚结束时发生断电或操作系统崩溃,可能会导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="dd148f4d09fd6cc6bad30b19733a82972a2cebe0" translate="yes" xml:space="preserve">
          <source>Fix a naming conflict between sqlite.h and sqlite3.h.</source>
          <target state="translated">修正 sqlite.h 和 sqlite3.h 之间的命名冲突。</target>
        </trans-unit>
        <trans-unit id="86cbab0ce9e871e04d98798d23ca791be9552d16" translate="yes" xml:space="preserve">
          <source>Fix a parser bug that prevented the use of parentheses around table-valued functions.</source>
          <target state="translated">修复了一个解析器错误,防止在表值函数周围使用括号。</target>
        </trans-unit>
        <trans-unit id="1ea82017fb31c1e817b4ca5fcdba2b68c62a7e38" translate="yes" xml:space="preserve">
          <source>Fix a performance bug in the pager cache, ticket #3844</source>
          <target state="translated">修复了一个寻呼机缓存的性能问题,票号3844。</target>
        </trans-unit>
        <trans-unit id="0b4a31de7ab7e54e3e4f0e6dd796fb43aef54770" translate="yes" xml:space="preserve">
          <source>Fix a performance regression on LEFT JOIN (see ticket #3015) that was mistakenly introduced in &lt;a href=&quot;#version_3_5_8&quot;&gt;version 3.5.8&lt;/a&gt;.</source>
          <target state="translated">修复&lt;a href=&quot;#version_3_5_8&quot;&gt;3.5.8版&lt;/a&gt;中错误引入的LEFT JOIN的性能回归（请参见故障单＃3015）。</target>
        </trans-unit>
        <trans-unit id="51a1cd95a4c2ce3fd6ef13919dca1d81326877a9" translate="yes" xml:space="preserve">
          <source>Fix a performance regression related to the query planner enhancements of version 3.7.0.</source>
          <target state="translated">修正与3.7.0版本的查询规划器改进有关的性能回归。</target>
        </trans-unit>
        <trans-unit id="59850e50fa6095504ef5b88efd743956885d3a6e" translate="yes" xml:space="preserve">
          <source>Fix a possible infinite loop on VACUUM for corrupt database files. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/27754b74ddf64&quot;&gt;27754b74ddf64&lt;/a&gt;</source>
          <target state="translated">修复了VACUUM上可能损坏数据库文件的无限循环的问题。入住&lt;a href=&quot;https://www.sqlite.org/src/info/27754b74ddf64&quot;&gt;27754b74ddf64&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="16de14f899013ff24b7caea8ce7237c3023ffe3c" translate="yes" xml:space="preserve">
          <source>Fix a possible segfault with DELETE when table is a &lt;a href=&quot;rowidtable&quot;&gt;rowid table&lt;/a&gt; with an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; and the WHERE clause contains a OR and the table has one or more indexes that are able to trigger the OR optimization, but none of the indexes reference any table columns other than the INTEGER PRIMARY KEY. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/16c9801ceba49&quot;&gt;16c9801ceba49&lt;/a&gt;.</source>
          <target state="translated">当表是具有&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;的&lt;a href=&quot;rowidtable&quot;&gt;Rowid表&lt;/a&gt;且WHERE子句包含OR且表具有一个或多个能够触发OR优化的索引但没有索引引用任何表列时，使用DELETE修复可能的段错误除了整数主键。机票&lt;a href=&quot;https://www.sqlite.org/src/info/16c9801ceba49&quot;&gt;16c9801ceba49&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d502547575294f85b69c2db2bf60e7be17520a7d" translate="yes" xml:space="preserve">
          <source>Fix a potential 32-bit integer overflow problem in the &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;c3ref/blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; interfaces.</source>
          <target state="translated">修复了&lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;和&lt;a href=&quot;c3ref/blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;接口中潜在的32位整数溢出问题。</target>
        </trans-unit>
        <trans-unit id="86abca115efafefa4d8227ca90c204f72ac25973" translate="yes" xml:space="preserve">
          <source>Fix a potential buffer overread that could result when trying to search a corrupt database file.</source>
          <target state="translated">修复了在搜索损坏的数据库文件时可能导致的缓冲区超读。</target>
        </trans-unit>
        <trans-unit id="e6cf1ce475579b639fd9a6e590dcc754d75c144f" translate="yes" xml:space="preserve">
          <source>Fix a potential database corruption bug that can occur if version 3.7.0 and version 3.6.23.1 alternately write to the same database file. &lt;a href=&quot;http://www.sqlite.org/src/info/51ae9cad317a1&quot;&gt; Ticket [51ae9cad317a1]&lt;/a&gt;</source>
          <target state="translated">修复了3.7.0版和3.6.23.1版交替写入同一数据库文件时可能发生的数据库损坏错误。&lt;a href=&quot;http://www.sqlite.org/src/info/51ae9cad317a1&quot;&gt;门票[51ae9cad317a1]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="abab7db5d66a2ed74635b710826696b058d2996c" translate="yes" xml:space="preserve">
          <source>Fix a potential database corruption bug that can occur if version 3.7.0 and version 3.6.23.1 alternately write to the same database file. &lt;a href=&quot;https://www.sqlite.org/src/info/51ae9cad317a1&quot;&gt; Ticket [51ae9cad317a1]&lt;/a&gt;</source>
          <target state="translated">修复了3.7.0版和3.6.23.1版交替写入同一数据库文件时可能发生的数据库损坏错误。&lt;a href=&quot;https://www.sqlite.org/src/info/51ae9cad317a1&quot;&gt;门票[51ae9cad317a1]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2326ddb13e351e1098f9d7af1605ec053a972e00" translate="yes" xml:space="preserve">
          <source>Fix a potential database corruption problem on Unix caused by the fact that all POSIX advisory locks are cleared whenever you close() a file. The work around it to embargo all close() calls while locks are outstanding.</source>
          <target state="translated">修复了Unix上一个潜在的数据库损坏问题,这个问题是由每当你关闭()一个文件时,所有POSIX咨询锁都会被清除。绕过它的工作是在锁尚未清除时禁止所有close()调用。</target>
        </trans-unit>
        <trans-unit id="3c1404201cf0f45ed7d26fb3ee3e025fabad8654" translate="yes" xml:space="preserve">
          <source>Fix a potential integer overflow problem when compiling a particular horrendous common table expression. This was another problem discovered by OSSFuzz. Check-in &lt;a href=&quot;https://sqlite.org/src/info/6ee8cb6ae5&quot;&gt;6ee8cb6ae5&lt;/a&gt;.</source>
          <target state="translated">修复了在编译特定的可怕公用表表达式时可能出现的整数溢出问题。这是OSSFuzz发现的另一个问题。入住&lt;a href=&quot;https://sqlite.org/src/info/6ee8cb6ae5&quot;&gt;6ee8cb6ae5&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fa021a738435d20102aefd6ba8aa9227f2196bfd" translate="yes" xml:space="preserve">
          <source>Fix a potential memory leak in &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; processing. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/2df6bbf1b8ca8&quot;&gt;2df6bbf1b8ca8&lt;/a&gt;</source>
          <target state="translated">修复&lt;a href=&quot;rowvalue&quot;&gt;行值&lt;/a&gt;处理中潜在的内存泄漏。入住&lt;a href=&quot;https://www.sqlite.org/src/info/2df6bbf1b8ca8&quot;&gt;2df6bbf1b8ca8&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d59a5b1204741917d207d0911c7f5b60cccb2e8" translate="yes" xml:space="preserve">
          <source>Fix a potential memory leak in the new &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; interface. Ticket &lt;a href=&quot;https://sqlite.org/src/info/7486aa54b968e9b5&quot;&gt;7486aa54b968e9b5&lt;/a&gt;.</source>
          <target state="translated">修复新的&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;接口中的潜在内存泄漏。机票&lt;a href=&quot;https://sqlite.org/src/info/7486aa54b968e9b5&quot;&gt;7486aa54b968e9b5&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c9b94c0ee4da7edac18db1b27719d5740439e09" translate="yes" xml:space="preserve">
          <source>Fix a potential out-of-bound read when querying a corrupt database file, a problem detected by Natalie Silvanovich of Google Project Zero. Check-in &lt;a href=&quot;https://sqlite.org/src/info/04925dee41a21f&quot;&gt;04925dee41a21f&lt;/a&gt;.</source>
          <target state="translated">修复了查询损坏的数据库文件时可能发生的越界读取的问题，该问题由Google Project Zero的Natalie Silvanovich检测到。入住&lt;a href=&quot;https://sqlite.org/src/info/04925dee41a21f&quot;&gt;04925dee41a21f&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94450756c5f997edafdb983263e971e139725961" translate="yes" xml:space="preserve">
          <source>Fix a potential segfault in complex recursive triggers, resulting from a bug in the OP_Once opcode introduced as part of a performance optimization in version 3.15.0. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/06796225f59c057c&quot;&gt;06796225f59c057c&lt;/a&gt;</source>
          <target state="translated">修复了复杂递归触发器中的潜在段错误，该错误是由于3.15.0版性能优化中引入的OP_Once操作码中的错误而导致的。机票&lt;a href=&quot;https://www.sqlite.org/src/info/06796225f59c057c&quot;&gt;06796225f59c057c&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9c23851f526115afe862ef20f590dcfe854957d3" translate="yes" xml:space="preserve">
          <source>Fix a potential segfault when destroying locks on WinCE in a multi-threaded environment.</source>
          <target state="translated">修复了多线程环境下在WinCE上销毁锁时的潜在segfault。</target>
        </trans-unit>
        <trans-unit id="443a0ce289230895426238fb258ebff7aa33cf14" translate="yes" xml:space="preserve">
          <source>Fix a potential use-after-free bug when processing a a subquery with both a correlated WHERE clause and a &quot;HAVING 0&quot; clause and where the parent query is an aggregate.</source>
          <target state="translated">修正了一个潜在的使用后自由的错误,当处理一个子查询时,同时使用相关的WHERE子句和 &quot;HAVING 0 &quot;子句,而父查询是一个集合。</target>
        </trans-unit>
        <trans-unit id="c5254d73f95694f4312acfaaba5e2519c7f711c7" translate="yes" xml:space="preserve">
          <source>Fix a problem in &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; that can result in a corrupt database containing two or more rows with the same &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f68dc596c4e6018d&quot;&gt;f68dc596c4e6018d&lt;/a&gt;.</source>
          <target state="translated">修复了&lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt;中的一个问题，该问题可能导致包含两个或多个具有相同&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid的&lt;/a&gt;行的数据库损坏。修复票证&lt;a href=&quot;https://www.sqlite.org/src/info/f68dc596c4e6018d&quot;&gt;f68dc596c4e6018d&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cce51ec3d9eafc83d9bef6eb168bd83fba551391" translate="yes" xml:space="preserve">
          <source>Fix a problem in &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; that was causing a subsequent &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; to behave suboptimally.</source>
          <target state="translated">修复&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA完整性检查&lt;/a&gt;中的一个问题，该问题导致随后的&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;表现欠佳。</target>
        </trans-unit>
        <trans-unit id="e2ab7efe53f641d1c01e53f622fc41a617719096" translate="yes" xml:space="preserve">
          <source>Fix a problem in CSV import in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; where if the leftmost field of the first row in the CSV file was both zero bytes in size and unquoted no data would be imported.</source>
          <target state="translated">修复了&lt;a href=&quot;cli&quot;&gt;命令行外壳&lt;/a&gt; CSV导入中的问题，如果CSV文件中第一行的最左侧字段的大小均为零字节且未加引号，则不会导入任何数据。</target>
        </trans-unit>
        <trans-unit id="b8e5e51fd7781a4a270ea3403c1d91e18539fa5d" translate="yes" xml:space="preserve">
          <source>Fix a problem in FTS4 where the left-most column that contained the &lt;a href=&quot;fts3#fts4notindexed&quot;&gt;notindexed column&lt;/a&gt; name as a prefix was not indexed rather than the column whose name matched exactly.</source>
          <target state="translated">修复了FTS4中的一个问题，该问题包含未索引的&lt;a href=&quot;fts3#fts4notindexed&quot;&gt;列&lt;/a&gt;名称作为前缀的最左边的列，而不是其名称完全匹配的列，未被索引。</target>
        </trans-unit>
        <trans-unit id="ed16f1842283c33640adef4111628a226934ccb4" translate="yes" xml:space="preserve">
          <source>Fix a problem in the &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; interface that could cause problems for the &lt;a href=&quot;json1&quot;&gt;json1&lt;/a&gt; extension under obscure circumstances. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f45ac567eaa9f9&quot;&gt;f45ac567eaa9f9&lt;/a&gt;.</source>
          <target state="translated">修复&lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype（）&lt;/a&gt;接口中的问题，该问题在晦涩的情况下可能导致&lt;a href=&quot;json1&quot;&gt;json1&lt;/a&gt;扩展出现问题。修复票务&lt;a href=&quot;https://www.sqlite.org/src/info/f45ac567eaa9f9&quot;&gt;f45ac567eaa9f9&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7871f6059f0a9d8ae6199f7ed5e914925c1946d3" translate="yes" xml:space="preserve">
          <source>Fix a problem in the query planner that results when a row-value expression is used with a PRIMARY KEY with redundant columns. Ticket &lt;a href=&quot;https://sqlite.org/src/info/1a84668dcfdebaf12415d&quot;&gt;1a84668dcfdebaf12415d&lt;/a&gt;</source>
          <target state="translated">修复了将行值表达式与带有冗余列的PRIMARY KEY一起使用时在查询计划程序中导致的问题。门票&lt;a href=&quot;https://sqlite.org/src/info/1a84668dcfdebaf12415d&quot;&gt;1a84668dcfdebaf12415d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ee14ad300b53edffc750ba4ada032439baf8cf04" translate="yes" xml:space="preserve">
          <source>Fix a problem in the virtual table commit mechanism that was causing a crash in FTS3. Ticket #3497.</source>
          <target state="translated">修正虚拟表提交机制中导致FTS3崩溃的问题。Ticket #3497.</target>
        </trans-unit>
        <trans-unit id="367c86dcc3176132b397b28f7554be7148358015" translate="yes" xml:space="preserve">
          <source>Fix a problem that was causing excess memory usage with large &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; transactions in win32 systems.</source>
          <target state="translated">修复了导致Win32系统中的大型&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;事务导致过多内存使用的问题。</target>
        </trans-unit>
        <trans-unit id="e4c5c3190d6e5398a03cc1624a8ad085afe03197" translate="yes" xml:space="preserve">
          <source>Fix a problem that was causing poor performance when many thousands of SQL statements were executed by a single sqlite_exec() call.</source>
          <target state="translated">修复了当一个sqlite_exec()调用执行成千上万条SQL语句时导致性能不佳的问题。</target>
        </trans-unit>
        <trans-unit id="d6546ef65a68047eca9a74f928d58465048048f8" translate="yes" xml:space="preserve">
          <source>Fix a problem that will corrupt the database file if you drop a table from the main database that has a TEMP index.</source>
          <target state="translated">修复了一个问题,如果从主数据库中删除一个有TEMP索引的表,会损坏数据库文件。</target>
        </trans-unit>
        <trans-unit id="6a895d74574faf7c3e5b7c17bfc4a1aebd1bd35a" translate="yes" xml:space="preserve">
          <source>Fix a problem that will corrupt the indices on a table if you do an INSERT OR REPLACE or an UPDATE OR REPLACE on a table that contains an INTEGER PRIMARY KEY plus one or more indices.</source>
          <target state="translated">修复了一个问题,如果你对一个包含INTEGER PRIMARY KEY加上一个或多个索引的表进行INSERT或REPLACE或UPDATE或REPLACE,会损坏表的索引。</target>
        </trans-unit>
        <trans-unit id="fa339d6b0d5c93a4f64854920f80fba0a5a92e67" translate="yes" xml:space="preserve">
          <source>Fix a problem where &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;PRAGMA count_changes&lt;/a&gt; was causing incorrect results for updates on tables with triggers</source>
          <target state="translated">修复了&lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;PRAGMA count_changes&lt;/a&gt;导致使用触发器更新表的结果不正确的问题</target>
        </trans-unit>
        <trans-unit id="2367f688e4ee0ae00d13a38bb5c62a10fab4c4f9" translate="yes" xml:space="preserve">
          <source>Fix a problem with 3-way joins that do not use indices</source>
          <target state="translated">修正一个不使用索引的3向连接的问题。</target>
        </trans-unit>
        <trans-unit id="fc131893314d3ec5912c469546ad607795fe252a" translate="yes" xml:space="preserve">
          <source>Fix a problem with &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; which could cause transactions to silently rollback if the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt; is set very small (less than 10) and SQLite comes under memory pressure.</source>
          <target state="translated">修复了&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;的问题，如果将&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt;设置得非常小（小于10）并且SQLite处于内存压力下，则可能导致事务以静默方式回滚。</target>
        </trans-unit>
        <trans-unit id="1f2f150e12c534df43b52ade585282148590c894" translate="yes" xml:space="preserve">
          <source>Fix a problem with VACUUM on databases from which tables containing AUTOINCREMENT have been dropped.</source>
          <target state="translated">修复了数据库中包含AUTOINCREMENT表的VACUUM的问题。</target>
        </trans-unit>
        <trans-unit id="e98ac2eb09507917a285747f2d5bd3a4164f2534" translate="yes" xml:space="preserve">
          <source>Fix a problem with string memory management in the VDBE</source>
          <target state="translated">修正VDBE中字符串内存管理的问题</target>
        </trans-unit>
        <trans-unit id="1c1c998fb53575b975370a5727818e77b27c3b5a" translate="yes" xml:space="preserve">
          <source>Fix a problem with the &lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;LEFT JOIN strength reduction optimization&lt;/a&gt; in which the optimization was being applied inappropriately due to an IS NOT NULL operator. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/5948e09b8c415bc45d&quot;&gt;5948e09b8c415bc45d&lt;/a&gt;.</source>
          <target state="translated">修复了&lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;LEFT JOIN强度降低优化&lt;/a&gt;的问题，该问题由于IS NOT NULL运算符而不适当地应用了该优化。机票&lt;a href=&quot;https://www.sqlite.org/src/info/5948e09b8c415bc45d&quot;&gt;5948e09b8c415bc45d&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3e42c3e04422e8992158af198fdedf65d8a494b4" translate="yes" xml:space="preserve">
          <source>Fix a problem with the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; on &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d96eba87698a428c1d&quot;&gt;d96eba87698a428c1d&lt;/a&gt;.</source>
          <target state="translated">修正了该问题&lt;a href=&quot;optoverview#or_opt&quot;&gt;或优化&lt;/a&gt;的&lt;a href=&quot;expridx&quot;&gt;表达式索引&lt;/a&gt;。票证&lt;a href=&quot;https://www.sqlite.org/src/info/d96eba87698a428c1d&quot;&gt;d96eba87698a428c1d&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a552a20d99699b5fa85e0ed7fb142721053399d9" translate="yes" xml:space="preserve">
          <source>Fix a problem with the multi-row one-pass DELETE optimization that was causing it to compute incorrect answers with a self-referential subquery in the WHERE clause. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/dc6ebeda9396087&quot;&gt;dc6ebeda9396087&lt;/a&gt;</source>
          <target state="translated">修复了多行单遍DELETE优化问题，该问题导致它使用WHERE子句中的自引用子查询来计算错误答案。修复票证&lt;a href=&quot;https://www.sqlite.org/src/info/dc6ebeda9396087&quot;&gt;dc6ebeda9396087&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="070ed03b719700575899432a2c98f057535dbcc4" translate="yes" xml:space="preserve">
          <source>Fix a problem with the new &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt; implementation that caused a malfunction when complicated expressions involving window functions were used inside of a view.</source>
          <target state="translated">修复了新的&lt;a href=&quot;windowfunctions&quot;&gt;窗口函数&lt;/a&gt;实现的问题，当在视图内部使用涉及窗口函数的复杂表达式时，该问题会导致故障。</target>
        </trans-unit>
        <trans-unit id="ef0924214b0eb9fe23d46afbb07aaf1261d67d0a" translate="yes" xml:space="preserve">
          <source>Fix a problem with the sort order when comparing upper-case strings against characters greater than 'Z' but less than 'a'.</source>
          <target state="translated">修复了在比较大写字符串与大于'Z'但小于'a'的字符时的排序顺序问题。</target>
        </trans-unit>
        <trans-unit id="5e753a491c25e8edb1492253042a4e79f112f875" translate="yes" xml:space="preserve">
          <source>Fix a problem with the use of &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt; used within &lt;a href=&quot;lang_expr#cosub&quot;&gt;correlated subqueries&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d0866b26f83e9c55e3&quot;&gt;d0866b26f83e9c55e3&lt;/a&gt;</source>
          <target state="translated">解决在&lt;a href=&quot;lang_expr#cosub&quot;&gt;相关子查询中&lt;/a&gt;使用&lt;a href=&quot;windowfunctions&quot;&gt;窗口函数&lt;/a&gt;的问题。门票&lt;a href=&quot;https://www.sqlite.org/src/info/d0866b26f83e9c55e3&quot;&gt;D0866B26F83E9C55E3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="551f44e055f1b2367c902fea7be697c804fc97a8" translate="yes" xml:space="preserve">
          <source>Fix a problem with using the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt; on an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/b850dd159918af56&quot;&gt;b850dd159918af56&lt;/a&gt;.</source>
          <target state="translated">解决了在&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;上使用&lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE优化&lt;/a&gt;的问题。入住&lt;a href=&quot;https://www.sqlite.org/src/info/b850dd159918af56&quot;&gt;b850dd159918af56&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="293886e1e2fac8f6d1689e1a0e83ac48f4add2fd" translate="yes" xml:space="preserve">
          <source>Fix a query planner bug involving a LEFT JOIN with a BETWEEN or LIKE/GLOB constraint and then another INNER JOIN to the right that involves an OR constraint.</source>
          <target state="translated">修复了一个查询规划器的错误,涉及到一个带有BETWEEN或LIKE/GLOB约束的LEFT JOIN,然后在右边又有一个涉及OR约束的INNER JOIN。</target>
        </trans-unit>
        <trans-unit id="8ff17cc556a87f30aa15241b1ac5c7a361de91a4" translate="yes" xml:space="preserve">
          <source>Fix a query planner bug that could result in a segfault when querying tables with a UNIQUE or PRIMARY KEY constraint with more than four columns.</source>
          <target state="translated">修复了一个查询规划器的bug,当查询带有UNIQUE或PRIMARY KEY约束的表时,如果表的列数超过4列,则可能导致segfault。</target>
        </trans-unit>
        <trans-unit id="9fb45458b64cd84ba2a2f30a7bfee1435ad64176" translate="yes" xml:space="preserve">
          <source>Fix a query planner bug that might cause a table to be scanned in the wrong direction (thus reversing the order of output) when a DESC index is used to implement the ORDER BY clause on a query that has an identical GROUP BY clause. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/ba7cbfaedc7e6&quot;&gt;ba7cbfaedc7e6&lt;/a&gt;.</source>
          <target state="translated">修复了查询计划程序错误，当使用DESC索引在具有相同GROUP BY子句的查询上实现ORDER BY子句时，可能会导致表扫描方向错误（从而反转输出顺序）。门票&lt;a href=&quot;http://www.sqlite.org/src/info/ba7cbfaedc7e6&quot;&gt;ba7cbfaedc7e6&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0214b71f2b88d71a696471dedb921ca7799163ff" translate="yes" xml:space="preserve">
          <source>Fix a query planner bug that might cause a table to be scanned in the wrong direction (thus reversing the order of output) when a DESC index is used to implement the ORDER BY clause on a query that has an identical GROUP BY clause. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/ba7cbfaedc7e6&quot;&gt;ba7cbfaedc7e6&lt;/a&gt;.</source>
          <target state="translated">修复了查询计划程序错误，当使用DESC索引在具有相同GROUP BY子句的查询上实现ORDER BY子句时，该错误可能导致表扫描方向错误（从而反转输出顺序）。门票&lt;a href=&quot;https://www.sqlite.org/src/info/ba7cbfaedc7e6&quot;&gt;ba7cbfaedc7e6&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="09bdfd52ac4cb9f3c70abc6d5f401e62168b1225" translate="yes" xml:space="preserve">
          <source>Fix a query planner problem that could result in an incorrect answer due to the use of &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; in subqueries in the FROM clause of a correlated scalar subqueries. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/8a2adec1&quot;&gt;8a2adec1&lt;/a&gt;.</source>
          <target state="translated">修复了一个查询计划程序问题，该问题可能由于在相关标量子查询的FROM子句中的子查询中使用&lt;a href=&quot;optoverview#autoindex&quot;&gt;自动索引&lt;/a&gt;而导致错误的答案。修复票&lt;a href=&quot;https://www.sqlite.org/src/info/8a2adec1&quot;&gt;8a2adec1&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3db45cb5a06554ceffd3c2fab04e67abb9573838" translate="yes" xml:space="preserve">
          <source>Fix a race condition in AUTOVACUUM that can lead to corrupt databases</source>
          <target state="translated">修复AUTOVACUUM中可能导致数据库损坏的竞赛条件。</target>
        </trans-unit>
        <trans-unit id="96a8e915a1becae62cd060b6c6ea6fdc08fd0da2" translate="yes" xml:space="preserve">
          <source>Fix a race condition in test_async.c.</source>
          <target state="translated">修正了test_async.c中的一个竞赛条件。</target>
        </trans-unit>
        <trans-unit id="625e5e94c16544ff24dd9e860382b39ea7c80a87" translate="yes" xml:space="preserve">
          <source>Fix a segfault that can occur for queries that use table-valued functions in an IN or EXISTS subquery. Ticket &lt;a href=&quot;https://sqlite.org/src/info/b899b6042f97f5&quot;&gt;b899b6042f97f5&lt;/a&gt;</source>
          <target state="translated">修复了在IN或EXISTS子查询中使用表值函数的查询可能发生的段错误。门票&lt;a href=&quot;https://sqlite.org/src/info/b899b6042f97f5&quot;&gt;b899b6042f97f5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a280dd5a4ba61a6ed5b8a4172311dcec663fd176" translate="yes" xml:space="preserve">
          <source>Fix a serious bug in the INSERT command which was causing data to go into the wrong columns if the data source was a SELECT and the INSERT clauses specified its columns in some order other than the default.</source>
          <target state="translated">修复了INSERT命令中的一个严重错误,如果数据源是SELECT,并且INSERT子句指定了其列的顺序,而不是默认的顺序,则会导致数据进入错误的列。</target>
        </trans-unit>
        <trans-unit id="a11d09fcf4c5c4f534bed3e95aeaedc75d2eadb8" translate="yes" xml:space="preserve">
          <source>Fix a strange (but valid) C declaration that was causing problems for QNX. No logical changes.</source>
          <target state="translated">修复了一个奇怪的(但有效的)C 语言声明,它给 QNX 带来了问题。无逻辑变化。</target>
        </trans-unit>
        <trans-unit id="7c6a164c4c1dd8fe7b071d0ade9de88fbde73880" translate="yes" xml:space="preserve">
          <source>Fix a typos in the sqlite3ext.h header file that prevented the &lt;a href=&quot;c3ref/stmt_isexplain&quot;&gt;sqlite3_stmt_isexplain()&lt;/a&gt; and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_frombind()&lt;/a&gt; interfaces from being called from &lt;a href=&quot;loadext&quot;&gt;run-time loadable extensions&lt;/a&gt;.</source>
          <target state="translated">修复了sqlite3ext.h头文件中的拼写错误，该错字阻止了&lt;a href=&quot;c3ref/stmt_isexplain&quot;&gt;sqlite3_stmt_isexplain（）&lt;/a&gt;和&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_frombind（）&lt;/a&gt;接口从&lt;a href=&quot;loadext&quot;&gt;可运行时的可扩展扩展中&lt;/a&gt;调用。</target>
        </trans-unit>
        <trans-unit id="0a54239aed950f147b9530647f9884464a8a7700" translate="yes" xml:space="preserve">
          <source>Fix a use-after-free that can occur when SQLite is compiled with -DSQLITE_HAS_CODEC.</source>
          <target state="translated">修正当SQLite使用-DSQLITE_HAS_CODEC编译时可能发生的use-after-free。</target>
        </trans-unit>
        <trans-unit id="65b8ad24259b51f708505579d558096b74643e0f" translate="yes" xml:space="preserve">
          <source>Fix an 64-bit alignment bug on HP/UX and Sparc</source>
          <target state="translated">修正HP/UX和Sparc上的64位对齐错误。</target>
        </trans-unit>
        <trans-unit id="8d3940a154d321cca0d2eb2aa13ea157138409fd" translate="yes" xml:space="preserve">
          <source>Fix an &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; issue in which the 'optimize' command could cause index corruption.</source>
          <target state="translated">修复了&amp;ldquo;优化&amp;rdquo;命令可能导致索引损坏的&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;问题。</target>
        </trans-unit>
        <trans-unit id="cf27be06b87f8658f160d75e065a66b3575cb593" translate="yes" xml:space="preserve">
          <source>Fix an &lt;a href=&quot;http://www.sqlite.org/src/info/5e10420e8d&quot;&gt; old and very obscure bug&lt;/a&gt; that can lead to corruption of the database &lt;a href=&quot;fileformat2#freelist&quot;&gt;free-page list&lt;/a&gt; when &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; is used.</source>
          <target state="translated">修复了一个&lt;a href=&quot;http://www.sqlite.org/src/info/5e10420e8d&quot;&gt;古老且非常模糊的错误&lt;/a&gt;，该错误可能在使用&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;增量式&lt;/a&gt;&lt;a href=&quot;fileformat2#freelist&quot;&gt;真空&lt;/a&gt;时导致数据库空闲页列表损坏。</target>
        </trans-unit>
        <trans-unit id="976a88b3ae3bc0e8f40568844bac2a27fb4d2b5d" translate="yes" xml:space="preserve">
          <source>Fix an &lt;a href=&quot;https://www.sqlite.org/src/info/5e10420e8d&quot;&gt; old and very obscure bug&lt;/a&gt; that can lead to corruption of the database &lt;a href=&quot;fileformat2#freelist&quot;&gt;free-page list&lt;/a&gt; when &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; is used.</source>
          <target state="translated">修正了一个&lt;a href=&quot;https://www.sqlite.org/src/info/5e10420e8d&quot;&gt;旧很不起眼的错误&lt;/a&gt;，可以导致数据库损坏&lt;a href=&quot;fileformat2#freelist&quot;&gt;的自由页列表&lt;/a&gt;时&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt;使用。</target>
        </trans-unit>
        <trans-unit id="2b834d02e62a3f123a1b8d14a7dd0d0f55d7a363" translate="yes" xml:space="preserve">
          <source>Fix an alignment problem on 64-bit machines</source>
          <target state="translated">修正64位机器上的对齐问题</target>
        </trans-unit>
        <trans-unit id="22b28f14aad0849b7f089af3e0ae2de83c9cc448" translate="yes" xml:space="preserve">
          <source>Fix an assertion failure that occurred when deleting all rows of a table with the &quot;count_changes&quot; pragma turned on.</source>
          <target state="translated">修正在开启 &quot;count_changes &quot;pragma的情况下,删除表的所有行时发生的断言失败。</target>
        </trans-unit>
        <trans-unit id="24c083d9fe654c2c6b13e8a4783ebdcf071478d1" translate="yes" xml:space="preserve">
          <source>Fix an assertion fault that can occur when updating the NULL value of a field at the end of a table that was added using &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ADD COLUMN&lt;/a&gt;.</source>
          <target state="translated">修复了在使用&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ADD COLUMN&lt;/a&gt;添加的表的末尾更新字段的NULL值时可能发生的断言错误。</target>
        </trans-unit>
        <trans-unit id="24c0b7a3124e531d424b372570a621483ca0c334" translate="yes" xml:space="preserve">
          <source>Fix an assertion fault that could occur following &lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;PRAGMA reverse_unordered_selects&lt;/a&gt;. Ticket &lt;a href=&quot;https://sqlite.org/src/info/cb91bf4290c211d&quot;&gt;cb91bf4290c211d&lt;/a&gt;</source>
          <target state="translated">修复了&lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;PRAGMA reverse_unordered_selects之后&lt;/a&gt;可能发生的断言错误。门票&lt;a href=&quot;https://sqlite.org/src/info/cb91bf4290c211d&quot;&gt;cb91bf4290c211d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="28b592fe11bf16075b14f304072980cfa741f4d3" translate="yes" xml:space="preserve">
          <source>Fix an assertion fault that occurred on deeply nested views.</source>
          <target state="translated">修复深度嵌套的视图发生的断言故障。</target>
        </trans-unit>
        <trans-unit id="5a204d98c949cf8975212c05340c51bd92e0547a" translate="yes" xml:space="preserve">
          <source>Fix an assertion fault that was coming up when the expression in an index-on-expressions is really a constant. Ticket &lt;a href=&quot;https://sqlite.org/src/info/aa98619ad08ddca&quot;&gt;aa98619ad08ddca&lt;/a&gt;</source>
          <target state="translated">修复当表达式索引中的表达式确实是常量时出现的断言错误。门票&lt;a href=&quot;https://sqlite.org/src/info/aa98619ad08ddca&quot;&gt;AA98619AD08DDCA&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5edfc637acd59a3db220a001c5781ab4bd7de9b5" translate="yes" xml:space="preserve">
          <source>Fix an index corruption issue introduced by &lt;a href=&quot;#version_3_8_7&quot;&gt;version 3.8.7&lt;/a&gt;. An index with a TEXT key can be corrupted by an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; into the corresponding table if the table has two nested triggers that convert the key value to INTEGER and back to TEXT again. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/34cd55d68e0e6e7c9a0711aab81a2ee3c354b4c0&quot;&gt;34cd55d68e0&lt;/a&gt;</source>
          <target state="translated">修复了&lt;a href=&quot;#version_3_8_7&quot;&gt;版本3.8.7&lt;/a&gt;引入的索引损坏问题。如果表具有两个嵌套的触发器，这些触发器将键值转换为INTEGER并再次返回到TEXT，则&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;可以将带有TEXT键的索引破坏到相应的表中。门票&lt;a href=&quot;https://www.sqlite.org/src/info/34cd55d68e0e6e7c9a0711aab81a2ee3c354b4c0&quot;&gt;34cd55d68e0&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8eeeaac39b440e493474edfe8a18c8edd3970590" translate="yes" xml:space="preserve">
          <source>Fix an infinite-loop in the query planner that could occur on malformed &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt;.</source>
          <target state="translated">修复查询计划器中可能在格式不正确的&lt;a href=&quot;lang_with&quot;&gt;公用表表达式&lt;/a&gt;上发生的无限循环。</target>
        </trans-unit>
        <trans-unit id="e7f2f6913b7c03deeb2b6b41e2ed3b92c354b90f" translate="yes" xml:space="preserve">
          <source>Fix an internal code generator problem that was causing some &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operations to no-op. Ticket &lt;a href=&quot;https://sqlite.org/src/info/ef360601&quot;&gt;ef360601&lt;/a&gt;</source>
          <target state="translated">修复了一个内部代码生成器问题，该问题导致某些&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;操作变为无操作。门票&lt;a href=&quot;https://sqlite.org/src/info/ef360601&quot;&gt;ef360601&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="337ef48955d3bd9a0a84bd4a9dd181f41e6cabab" translate="yes" xml:space="preserve">
          <source>Fix an issue in the fsdir(PATH) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; to the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/fileio.c&quot;&gt;fileio.c&lt;/a&gt; extension, that caused a segfault if the fsdir() table was used as the inner table of a join. Problem reported on the mailing list and fixed by check-in &lt;a href=&quot;https://www.sqlite.org/src/info/7ce4e71c1b7251be&quot;&gt;7ce4e71c1b7251be&lt;/a&gt;</source>
          <target state="translated">将fsdir（PATH）&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数中&lt;/a&gt;的问题修复为&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/fileio.c&quot;&gt;fileio.c&lt;/a&gt;扩展名，如果将fsdir（）表用作联接的内部表，则会导致segfault。问题已在邮件列表中报告并由签入&lt;a href=&quot;https://www.sqlite.org/src/info/7ce4e71c1b7251be&quot;&gt;7ce4e71c1b7251be解决&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f2b91637b2c2c39f1dab693ce0e485fd3cd7d63" translate="yes" xml:space="preserve">
          <source>Fix an issue with incorrect sharing of VDBE temporary registers between co-routines that could cause incorrect query results in obscure cases. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d06a25c84454a&quot;&gt;d06a25c84454a&lt;/a&gt;.</source>
          <target state="translated">修复了在例程之间不正确共享VDBE临时寄存器的问题，这种情况在晦涩的情况下可能导致错误的查询结果。机票&lt;a href=&quot;https://www.sqlite.org/src/info/d06a25c84454a&quot;&gt;d06a25c84454a&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7c984a9789b89b098bf54d9a87bf8ad24379596a" translate="yes" xml:space="preserve">
          <source>Fix an obscure and relatively harmless problem that might have caused a resource leak following an I/O error.</source>
          <target state="translated">修复了一个不明显的、相对无害的问题,这个问题可能在I/O错误后造成资源泄漏。</target>
        </trans-unit>
        <trans-unit id="9af5e2e7bb886d04f6d1d3a91c18b1bcfc2e680c" translate="yes" xml:space="preserve">
          <source>Fix an obscure bug that can cause database corruption under the following unusual circumstances: A large INSERT or UPDATE statement which is part of an even larger transaction fails due to a uniqueness constraint but the containing transaction commits.</source>
          <target state="translated">修复了一个不明显的bug,在以下不寻常的情况下会导致数据库损坏。一个大的INSERT或UPDATE语句是一个更大的事务的一部分,由于唯一性约束而失败,但包含的事务提交。</target>
        </trans-unit>
        <trans-unit id="0096a0fca1b6b43797d06b363272bd306cbf7ce9" translate="yes" xml:space="preserve">
          <source>Fix an obscure bug that can cause database corruption under the following unusual circumstances: A large INSERT or UPDATE statement which is part of an even larger transaction fails due to a uniqueness contraint but the containing transaction commits.</source>
          <target state="translated">修复了一个不明显的bug,在以下不寻常的情况下会导致数据库损坏。一个大的INSERT或UPDATE语句是一个更大的事务的一部分,由于唯一性缺陷而失败,但包含的事务却提交了。</target>
        </trans-unit>
        <trans-unit id="ce8d90d9be96ff29e6eda51d841a97e900370a1d" translate="yes" xml:space="preserve">
          <source>Fix an obscure memory leak in &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;. Ticket &lt;a href=&quot;https://sqlite.org/src/info/7486aa54b968e9b&quot;&gt;7486aa54b968e9b&lt;/a&gt;</source>
          <target state="translated">修复&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）中&lt;/a&gt;晦涩的内存泄漏。机票&lt;a href=&quot;https://sqlite.org/src/info/7486aa54b968e9b&quot;&gt;7486aa54b968e9b&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9faef411a2ddeadaf79ebd73389c10f7af52120" translate="yes" xml:space="preserve">
          <source>Fix an obscure segfault in UTF-8 to UTF-16 conversions</source>
          <target state="translated">修正UTF-8到UTF-16转换中的一个不明显的segfault。</target>
        </trans-unit>
        <trans-unit id="b5c1f0802c64a77b99076bfc9059cf131dd55807" translate="yes" xml:space="preserve">
          <source>Fix an off-by-one error that caused quoted empty string at the end of a CRNL-terminated line of CSV input to be misread by the command-line shell.</source>
          <target state="translated">修复了一个逐个错误,导致命令行 shell 误读 CSV 输入的 CRNL 结尾处引用的空字符串。</target>
        </trans-unit>
        <trans-unit id="30b0fd93ee02b86cc24f6cc7bd2523397f033eee" translate="yes" xml:space="preserve">
          <source>Fix an optimizer bug involving subqueries in a compound SELECT that has both an ORDER BY and a LIMIT clause. Ticket #2339.</source>
          <target state="translated">修正一个优化器错误,涉及到一个复合 SELECT 中的子查询,该子查询同时具有 ORDER BY 和 LIMIT 子句。Ticket #2339.</target>
        </trans-unit>
        <trans-unit id="683ed4e4563f819c0aec9579fc2147e259103b73" translate="yes" xml:space="preserve">
          <source>Fix an optimizer bug that could have caused some unusual LEFT OUTER JOINs to give incorrect results.</source>
          <target state="translated">修复了一个优化器错误,该错误可能会导致一些不寻常的LEFT OUTER JOINs给出不正确的结果。</target>
        </trans-unit>
        <trans-unit id="762e5ec5f054c66d660a449bf35057af7025d512" translate="yes" xml:space="preserve">
          <source>Fix an uninitialized variable in pager.c which could (with a probability of about 1 in 4 billion) result in a corrupted database.</source>
          <target state="translated">修正 pager.c 中一个未初始化的变量,这个变量可能会导致数据库损坏(概率约为 40 亿分之一)。</target>
        </trans-unit>
        <trans-unit id="4ff50f16c16225e491f827922f36f0a1b00ee9e8" translate="yes" xml:space="preserve">
          <source>Fix another bug in the IS NULL optimization that was added in version 3.3.9.</source>
          <target state="translated">修正3.3.9版本中新增的IS NULL优化中的另一个bug。</target>
        </trans-unit>
        <trans-unit id="e8f06a6dcd8a035bb10d1fb00994a8c1617f3e5c" translate="yes" xml:space="preserve">
          <source>Fix another bug in the implementation of the new &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; API. We'll get it right eventually...</source>
          <target state="translated">修复了新的&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt; API 的实现中的另一个错误。我们最终会正确的...</target>
        </trans-unit>
        <trans-unit id="6f129ae803d9883975a2438f98f71935a3f57c27" translate="yes" xml:space="preserve">
          <source>Fix bugs in pager.c that could lead to database corruption if two processes both try to recover a hot journal at the same instant</source>
          <target state="translated">修正pager.c中的bug,如果两个进程同时试图恢复一个热日志,可能会导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="e51c167c962ab37e883d84e10e98aee9dad05d15" translate="yes" xml:space="preserve">
          <source>Fix bugs in the implementation of the new &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; API that can lead to segfaults.</source>
          <target state="translated">修复了新的&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt; API 的实现中的错误，该错误可能导致段错误。</target>
        </trans-unit>
        <trans-unit id="15b10b87ff343116def15b81c85457d634788432" translate="yes" xml:space="preserve">
          <source>Fix bugs that can (rarely) lead to incorrect query results when the CAST or OR operators are used in the WHERE clause of a query.</source>
          <target state="translated">修复当在查询的WHERE子句中使用CAST或OR运算符时,可能(很少)导致错误的查询结果的错误。</target>
        </trans-unit>
        <trans-unit id="3d935fe3f3737292749bd1972d56f443d7c93968" translate="yes" xml:space="preserve">
          <source>Fix byte alignment problems on 64-bit architectures.</source>
          <target state="translated">修复64位架构上的字节对齐问题。</target>
        </trans-unit>
        <trans-unit id="7bca40ab59e8b9695f58ea94f5115e8c80d7a7c3" translate="yes" xml:space="preserve">
          <source>Fix commenting errors and improve the comments generated on &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; listings when the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">当使用&lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt;编译时选项时，修复注释错误并改进在&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;列表上生成的注释。</target>
        </trans-unit>
        <trans-unit id="f6a563b99fee018f87bcc6d45b57949ce6d02874" translate="yes" xml:space="preserve">
          <source>Fix data races that might occur under stress when running with many threads in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; where some of the threads are opening and closing connections.</source>
          <target state="translated">修复了在&lt;a href=&quot;sharedcache&quot;&gt;共享缓存模式&lt;/a&gt;下使用许多线程运行某些线程正在打开和关闭连接时，在压力下可能发生的数据争用问题。</target>
        </trans-unit>
        <trans-unit id="3810fcb3cfb91e5274e7723b80500a70b2e4eef7" translate="yes" xml:space="preserve">
          <source>Fix data structure alignment issues on Sparc. Ticket #3777.</source>
          <target state="translated">修正 Sparc 上的数据结构对齐问题。票号3777。</target>
        </trans-unit>
        <trans-unit id="4842d931b22261ebda7c5513443dde9410770e54" translate="yes" xml:space="preserve">
          <source>Fix documentation typos</source>
          <target state="translated">修正文件中的错别字</target>
        </trans-unit>
        <trans-unit id="a7f89cd0a1f20da8469d2ab54509c35e86684ab3" translate="yes" xml:space="preserve">
          <source>Fix editline support in the command-line shell.</source>
          <target state="translated">修正命令行shell中的编辑行支持。</target>
        </trans-unit>
        <trans-unit id="87d44c2123224749ec741fa602897daad30b0e0b" translate="yes" xml:space="preserve">
          <source>Fix for a bug in the ORDER BY optimizer that was introduced in &lt;a href=&quot;#version_3_7_15&quot;&gt;version 3.7.15&lt;/a&gt; which would sometimes optimize out the sorting step when in fact the sort was required. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/a179fe7465&quot;&gt;a179fe7465&lt;/a&gt;</source>
          <target state="translated">修复了&lt;a href=&quot;#version_3_7_15&quot;&gt;3.7.15版&lt;/a&gt;中引入的ORDER BY优化器中的错误，该错误有时会在实际上需要排序时优化排序步骤。机票&lt;a href=&quot;http://www.sqlite.org/src/info/a179fe7465&quot;&gt;A179FE7465&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="389bb83024331c8ba38e7c75af9bee20e48f7afd" translate="yes" xml:space="preserve">
          <source>Fix for a bug in the ORDER BY optimizer that was introduced in &lt;a href=&quot;#version_3_7_15&quot;&gt;version 3.7.15&lt;/a&gt; which would sometimes optimize out the sorting step when in fact the sort was required. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/a179fe7465&quot;&gt;a179fe7465&lt;/a&gt;</source>
          <target state="translated">修复了&lt;a href=&quot;#version_3_7_15&quot;&gt;版本3.7.15&lt;/a&gt;中引入的ORDER BY优化器中的错误，该错误有时会优化排序步骤，而实际上是需要排序的。机票&lt;a href=&quot;https://www.sqlite.org/src/info/a179fe7465&quot;&gt;A179FE7465&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0a782f7686d7d9707b5dc5190d2cb994db1da8ac" translate="yes" xml:space="preserve">
          <source>Fix for a bug in the SELECT DISTINCT logic that was introduced by the prior version.</source>
          <target state="translated">修正了上一版本引入的SELECT DISTINCT逻辑中的一个错误。</target>
        </trans-unit>
        <trans-unit id="293d91bd4dad89365956202fbbdc05193695a217" translate="yes" xml:space="preserve">
          <source>Fix for another problem (unrelated to the one fixed in 2.1.4) that sometimes causes &lt;b&gt;sqlite_exec()&lt;/b&gt; to return SQLITE_PROTOCOL unnecessarily. This time the bug was in the POSIX locking code and should not effect Windows users.</source>
          <target state="translated">解决了另一个问题（与2.1.4中修复的问题无关），该问题有时会导致&lt;b&gt;sqlite_exec（）&lt;/b&gt;不必要地返回SQLITE_PROTOCOL。这次，该错误位于POSIX锁定代码中，并且不会影响Windows用户。</target>
        </trans-unit>
        <trans-unit id="692cc3acdf11cc382c710566eb5e8d41ae9a76e6" translate="yes" xml:space="preserve">
          <source>Fix inconsistent integer to floating-point comparison operations that could result in a corrupt index if the index is created on a table column that contains both large integers and floating point values of similar magnitude. Ticket &lt;a href=&quot;https://www.sqlite.org/src/tktview?name=38a97a87a6&quot;&gt;38a97a87a6&lt;/a&gt;.</source>
          <target state="translated">将不一致的整数修复为浮点比较操作，如果在包含大整数和相似大小的浮点值的表列上创建索引，则可能导致索引损坏。机票&lt;a href=&quot;https://www.sqlite.org/src/tktview?name=38a97a87a6&quot;&gt;38a97a87a6&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cbe4713574b5e7e1bf3ea574e5968f7da369b174" translate="yes" xml:space="preserve">
          <source>Fix incorrect result with complex OR-connected WHERE and STAT4. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/ec32177c99ccac2&quot;&gt;ec32177c99ccac2&lt;/a&gt;</source>
          <target state="translated">使用复杂的或连接的WHERE和STAT4修复错误的结果。门票&lt;a href=&quot;https://www.sqlite.org/src/info/ec32177c99ccac2&quot;&gt;ec32177c99ccac2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="32ba32659ea655886bad57a0dd08fbe5d98856b9" translate="yes" xml:space="preserve">
          <source>Fix locking behavior under Windows</source>
          <target state="translated">修正Windows下的锁定行为</target>
        </trans-unit>
        <trans-unit id="1f35665eab7b4eb2d565f64daa7ab9de3e2952ac" translate="yes" xml:space="preserve">
          <source>Fix many obscure problems discovered while &lt;a href=&quot;testing#fuzztesting&quot;&gt;SQL fuzzing&lt;/a&gt;.</source>
          <target state="translated">修复&lt;a href=&quot;testing#fuzztesting&quot;&gt;SQL模糊测试时&lt;/a&gt;发现的许多晦涩问题。</target>
        </trans-unit>
        <trans-unit id="8e786cb80b44d5b0bc787df47e982713af4c0ff9" translate="yes" xml:space="preserve">
          <source>Fix many potential segfaults that could be caused by malicious SQL statements.</source>
          <target state="translated">修复许多可能由恶意SQL语句引起的潜在segfaults。</target>
        </trans-unit>
        <trans-unit id="0ab2336b4ec301e575c6d8af5dd4486d9002cf92" translate="yes" xml:space="preserve">
          <source>Fix memory leaks that used to occur after a malloc() failure.</source>
          <target state="translated">修复过去在malloc()失败后发生的内存泄漏。</target>
        </trans-unit>
        <trans-unit id="6b6c482ed533b8d025b0b530bd86fd284d9ab805" translate="yes" xml:space="preserve">
          <source>Fix memory size tracking so that it works even if SQLite uses more than 2GiB of memory.</source>
          <target state="translated">修复内存大小跟踪,使其在SQLite使用超过2GiB的内存时也能工作。</target>
        </trans-unit>
        <trans-unit id="83c4e0c639eeed5339ef3f3550050703ea306329" translate="yes" xml:space="preserve">
          <source>Fix minor issues with the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;.</source>
          <target state="translated">修复&lt;a href=&quot;dbstat&quot;&gt;dbstat虚拟表的&lt;/a&gt;小问题。</target>
        </trans-unit>
        <trans-unit id="578421d576815ab64b5fb214050ae5771736d5b2" translate="yes" xml:space="preserve">
          <source>Fix minor problems in extensions.</source>
          <target state="translated">修复扩展中的小问题。</target>
        </trans-unit>
        <trans-unit id="6d8fc1c13727f748ff40e9e6be94b0b7005ead11" translate="yes" xml:space="preserve">
          <source>Fix misbehavior of the FTS5 xBestIndex method. Ticket &lt;a href=&quot;https://sqlite.org/src/info/2b8aed9f7c9e61e8&quot;&gt;2b8aed9f7c9e61e8&lt;/a&gt;.</source>
          <target state="translated">修复FTS5 xBestIndex方法的不良行为。票证&lt;a href=&quot;https://sqlite.org/src/info/2b8aed9f7c9e61e8&quot;&gt;2b8aed9f7c9e61e8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d6aeb35ac1eb7c66584445cf87b55f99254ca966" translate="yes" xml:space="preserve">
          <source>Fix more bugs in the LEFT JOIN &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7fde638e94287d2c&quot;&gt;7fde638e94287d2c&lt;/a&gt;.</source>
          <target state="translated">修复LEFT JOIN展&lt;a href=&quot;optoverview#flattening&quot;&gt;平优化&lt;/a&gt;中的更多错误。机票&lt;a href=&quot;https://www.sqlite.org/src/info/7fde638e94287d2c&quot;&gt;7fde638e94287d2c&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1506d1bb252e85d5b0e36b68a46cf1665d4a7c8f" translate="yes" xml:space="preserve">
          <source>Fix more problems with rollback. Enhance the test suite to exercise the rollback logic extensively in order to prevent any future problems.</source>
          <target state="translated">修正更多回滚的问题。加强测试套件,广泛地练习回滚逻辑,以防止任何未来的问题。</target>
        </trans-unit>
        <trans-unit id="3fb27e5b00960417518969df0f918d06f25d9624" translate="yes" xml:space="preserve">
          <source>Fix multiple bugs that can occur following a malloc() failure.</source>
          <target state="translated">修复malloc()失败后可能出现的多个bug。</target>
        </trans-unit>
        <trans-unit id="8252f0ee7c2b56c6e1d2a3ae12fb9ec74fcaf061" translate="yes" xml:space="preserve">
          <source>Fix obscure crash bugs found by &lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;american fuzzy lop&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/a59ae93ee990a55&quot;&gt;a59ae93ee990a55&lt;/a&gt;.</source>
          <target state="translated">修复&lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;美国模糊fuzzy&lt;/a&gt;发现的晦涩的崩溃错误。门票&lt;a href=&quot;https://www.sqlite.org/src/info/a59ae93ee990a55&quot;&gt;a59ae93ee990a55&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="029dc6c7c9dc876556264390601510f43467cb42" translate="yes" xml:space="preserve">
          <source>Fix other minor problems with using small soft heap limits.</source>
          <target state="translated">修复使用小软堆限制的其他小问题。</target>
        </trans-unit>
        <trans-unit id="2953bbeca888101c80fba41134554ee3b46a5872" translate="yes" xml:space="preserve">
          <source>Fix portability problems for MinGW/MSYS.</source>
          <target state="translated">修正MinGW/MSYS的可移植性问题。</target>
        </trans-unit>
        <trans-unit id="46269c4cd0e4bb26c3e434c946d6ad61c56e3d22" translate="yes" xml:space="preserve">
          <source>Fix potential corruption in &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt; due to automatic datatype conversions. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/343634942dd54ab&quot;&gt;343634942dd54ab&lt;/a&gt;</source>
          <target state="translated">修复由于自动数据类型转换而导致&lt;a href=&quot;expridx&quot;&gt;表达式索引中&lt;/a&gt;潜在的损坏。机票&lt;a href=&quot;https://www.sqlite.org/src/info/343634942dd54ab&quot;&gt;343634942dd54ab&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e4b60b2ce1e9e806c6a1d1ab2efe5b7b8417ffc" translate="yes" xml:space="preserve">
          <source>Fix problems found on 64-bit systems.</source>
          <target state="translated">修复64位系统上发现的问题。</target>
        </trans-unit>
        <trans-unit id="07f0a4d00027e8a55978e27f100b7e116a031b97" translate="yes" xml:space="preserve">
          <source>Fix problems with the handling of ORDER BY expressions on compound SELECT statements in subqueries.</source>
          <target state="translated">修正子查询中复合SELECT语句的ORDER BY表达式的处理问题。</target>
        </trans-unit>
        <trans-unit id="3f1665257f79bd93e546dd7e3d88c5139efb7056" translate="yes" xml:space="preserve">
          <source>Fix rare false-positives in &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; when run on a database connection with &lt;a href=&quot;lang_attach&quot;&gt;attached databases&lt;/a&gt;. Ticket &lt;a href=&quot;https://sqlite.org/src/info/a4e06e75a9ab61a12&quot;&gt;a4e06e75a9ab61a12&lt;/a&gt;</source>
          <target state="translated">当在具有&lt;a href=&quot;lang_attach&quot;&gt;附加数据库&lt;/a&gt;的数据库连接上运行时，修复&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check中&lt;/a&gt;罕见的假阳性。门票&lt;a href=&quot;https://sqlite.org/src/info/a4e06e75a9ab61a12&quot;&gt;a4e06e75a9ab61a12&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="715572171eb76d3d2c9de665f3a896a9b21d3581" translate="yes" xml:space="preserve">
          <source>Fix several important bugs in the new ATTACH and DETACH commands.</source>
          <target state="translated">修复了新的ATTACH和DETACH命令中的几个重要错误。</target>
        </trans-unit>
        <trans-unit id="ddb3a4c421a408022b093da748a9383a9c659be4" translate="yes" xml:space="preserve">
          <source>Fix several nuisance bugs.</source>
          <target state="translated">修复几个扰人的BUG。</target>
        </trans-unit>
        <trans-unit id="893a9bc034bf998aa3ff5b40cdc26495f66e42a9" translate="yes" xml:space="preserve">
          <source>Fix table rename feature so that it also updates references to the renamed table in &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt; and &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt;.</source>
          <target state="translated">修复表重命名功能，以便它还可以在&lt;a href=&quot;lang_createtrigger&quot;&gt;触发器&lt;/a&gt;和&lt;a href=&quot;lang_createview&quot;&gt;视图中&lt;/a&gt;更新对重命名表的引用。</target>
        </trans-unit>
        <trans-unit id="6c93787ec12e369e67cea4716187fa506565c4de" translate="yes" xml:space="preserve">
          <source>Fix the &quot;.import&quot; command of the shell so that it ignores \r characters at the end of lines.</source>
          <target state="translated">修正shell的&quot;.import &quot;命令,使其忽略行末的\r字符。</target>
        </trans-unit>
        <trans-unit id="efa608a017df9d7fa42cace30fce54f90785e7c6" translate="yes" xml:space="preserve">
          <source>Fix the &quot;.read&quot; command in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; so that it understands that its input is not interactive.</source>
          <target state="translated">修复&lt;a href=&quot;cli&quot;&gt;命令行外壳中&lt;/a&gt;的&amp;ldquo; .read&amp;rdquo;命令，以使其了解其输入不是交互式的。</target>
        </trans-unit>
        <trans-unit id="7dd018e621c55cac03b1d82cf14914c81075f182" translate="yes" xml:space="preserve">
          <source>Fix the --enable-threadsafe option on the configure script</source>
          <target state="translated">修正配置脚本中的--enable-threadsafe选项。</target>
        </trans-unit>
        <trans-unit id="4f27e177384472d9d1a0c017bbab8f18de27d2fa" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/db_readonly&quot;&gt;sqlite3_db_readonly()&lt;/a&gt; interface so that it returns true if the database is read-only due to the file format write version number being too large.</source>
          <target state="translated">修复&lt;a href=&quot;c3ref/db_readonly&quot;&gt;sqlite3_db_readonly（）&lt;/a&gt;接口，如果数据库由于文件格式写入版本号太大而为只读，则返回true。</target>
        </trans-unit>
        <trans-unit id="bec6839af346a0afcfd8b6b2618aee85250ace7f" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interfaces so that they actually do provide a 64-bit answer.</source>
          <target state="translated">修复&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;和&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;接口，以便它们确实提供64位答案。</target>
        </trans-unit>
        <trans-unit id="9ba95583c49ccb4f7efb59b2718e52202fa58e8d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/stmt_busy&quot;&gt;sqlite3_stmt_busy()&lt;/a&gt; interface so that it gives the correct answer for &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; statements that have been stepped but never reset.</source>
          <target state="translated">修复&lt;a href=&quot;c3ref/stmt_busy&quot;&gt;sqlite3_stmt_busy（）&lt;/a&gt;接口，以便为已步进但从未重置的&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;语句提供正确答案。</target>
        </trans-unit>
        <trans-unit id="0d8b77554fdfe7204548bebac009120f0ab4ce5d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; interface so that it is disabled if either the callback or the mask arguments are zero, in accordance with the documentation.</source>
          <target state="translated">修复&lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;接口，以便根据文档，如果回调或mask参数为零，则将其禁用。</target>
        </trans-unit>
        <trans-unit id="956e98f8a5992e566b23150a8321e220d594d919" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt; interface so that it correctly translates content generated by &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob()&lt;/a&gt; into a string of all 0x00 characters. This is a long-standing issue discovered after the 3.16.1 release by &lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSS-Fuzz&lt;/a&gt;</source>
          <target state="translated">修复&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_text（）&lt;/a&gt;接口，以便它正确地将&lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob（）&lt;/a&gt;生成的内容转换为所有0x00字符的字符串。这是&lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSS-Fuzz&lt;/a&gt;在3.16.1版本发布后发现的一个长期问题</target>
        </trans-unit>
        <trans-unit id="56c77cb746417e9f9c249b6c4c57b8b0bd6b303c" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; so that it builds with -DSQLITE_UNTESTABLE</source>
          <target state="translated">修复&lt;a href=&quot;cli&quot;&gt;CLI，&lt;/a&gt;以便使用-DSQLITE_UNTESTABLE进行构建</target>
        </trans-unit>
        <trans-unit id="2ac07a1bdc161b16f3469a85c1d0b7329721b6d7" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;cli#fileio&quot;&gt;readfile()&lt;/a&gt; function so that it returns an empty BLOB rather than throwing an out-of-memory error when reading an empty file.</source>
          <target state="translated">修复&lt;a href=&quot;cli#fileio&quot;&gt;readfile（）&lt;/a&gt;函数，使其在读取空文件时返回空的BLOB，而不是抛出内存不足错误。</target>
        </trans-unit>
        <trans-unit id="403d90d10026656bd2341e3610eb64ec19d4191d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;cli#fileio&quot;&gt;writefile()&lt;/a&gt; function so that when it creates new directories along the path of a new file, it gives them umask permissions rather than the same permissions as the file.</source>
          <target state="translated">修复&lt;a href=&quot;cli#fileio&quot;&gt;writefile（）&lt;/a&gt;函数，以便当它沿着新文件的路径创建新目录时，会为其赋予umask权限，而不是与文件相同的权限。</target>
        </trans-unit>
        <trans-unit id="c637b1ba45c5e9182867d4d4a220fb33c1f49c9d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/eval.c&quot;&gt;eval.c&lt;/a&gt; extension so that it works with &lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt;PRAGMA empty_result_callbacks=ON&lt;/a&gt;.</source>
          <target state="translated">修复&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/eval.c&quot;&gt;eval.c&lt;/a&gt;扩展名，使其与&lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt;PRAGMA empty_result_callbacks = ON一起使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="742c65bbfe2ba6c5ffb22d31b0549c4b28db3ce5" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;json1#jeach&quot;&gt;json_each()&lt;/a&gt; function so that it returns valid results on its &quot;fullkey&quot; column when the input is a simple value rather than an array or object.</source>
          <target state="translated">修复&lt;a href=&quot;json1#jeach&quot;&gt;json_each（）&lt;/a&gt;函数，以便当输入是简单值而不是数组或对象时，它在其&amp;ldquo; fullkey&amp;rdquo;列上返回有效结果。</target>
        </trans-unit>
        <trans-unit id="6faddebbbfb3cf6bd640c7723cc149f43cca6d2e" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command so that it does not corrupt &lt;a href=&quot;lang_createindex#descidx&quot;&gt;descending indexes&lt;/a&gt; when adding a column to a &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy file format&lt;/a&gt; database. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f68bf68513a1c15f&quot;&gt;f68bf68513a1c15f&lt;/a&gt;</source>
          <target state="translated">修复&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;命令，以便在将列添加到&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;旧文件格式&lt;/a&gt;数据库时不会破坏&lt;a href=&quot;lang_createindex#descidx&quot;&gt;降序索引&lt;/a&gt;。门票&lt;a href=&quot;https://www.sqlite.org/src/info/f68bf68513a1c15f&quot;&gt;f68bf68513a1c15f&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="02f53a9fc9d770e6300288b8428f8e92433fe895" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_altertable#altertabmvcol&quot;&gt;ALTER TABLE RENAME COLUMN&lt;/a&gt; command so that it works for tables that have redundant UNIQUE constraints. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/bc8d94f0fbd633fd9a&quot;&gt;bc8d94f0fbd633fd9a&lt;/a&gt;</source>
          <target state="translated">修复&lt;a href=&quot;lang_altertable#altertabmvcol&quot;&gt;ALTER TABLE RENAME COLUMN&lt;/a&gt;命令，使其适用于具有冗余UNIQUE约束的表。门票&lt;a href=&quot;https://www.sqlite.org/src/info/bc8d94f0fbd633fd9a&quot;&gt;bc8d94f0fbd633fd9a&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="97c52dd1e73a0efdc1a5a635f402eb42bf6e057e" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command so that it adds correct samples for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables in the &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; table. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/b2fa5424e6fcb15&quot;&gt;b2fa5424e6fcb15&lt;/a&gt;.</source>
          <target state="translated">修复&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令，以便为&lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;表中的&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表添加正确的样本。机票&lt;a href=&quot;http://www.sqlite.org/src/info/b2fa5424e6fcb15&quot;&gt;b2fa5424e6fcb15&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d0b3c3ffc2f29b68f2012d7739022532f7c7c972" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command so that it adds correct samples for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables in the &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; table. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/b2fa5424e6fcb15&quot;&gt;b2fa5424e6fcb15&lt;/a&gt;.</source>
          <target state="translated">修复&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令，以便为&lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;表中的&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表添加正确的样本。票证&lt;a href=&quot;https://www.sqlite.org/src/info/b2fa5424e6fcb15&quot;&gt;b2fa5424e6fcb15&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d872c8e6bb3c85572831647367d9180d6f56948" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command so that it computes statistics on tables whose names begin with &quot;sqlite&quot;. Check-in &lt;a href=&quot;https://sqlite.org/src/info/0249d9aecf69948d&quot;&gt;0249d9aecf69948d&lt;/a&gt;</source>
          <target state="translated">修复&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令，以便它计算名称以&amp;ldquo; sqlite&amp;rdquo;开头的表的统计信息。入住&lt;a href=&quot;https://sqlite.org/src/info/0249d9aecf69948d&quot;&gt;0249d9aecf69948d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bc9460bbb01c2af9870b809ff07c3b2b7356fe99" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; command so that it is no longer able to sneak a NULL value into a NOT NULL column even if the NOT NULL column has a default value of NULL. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/e6f1f2e34dceeb1ed6&quot;&gt;e6f1f2e34dceeb1ed6&lt;/a&gt;</source>
          <target state="translated">修复&lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt;命令，以便即使NOT NULL列的默认值为NULL，也无法再将NULL值潜入NOT NULL列。门票&lt;a href=&quot;https://www.sqlite.org/src/info/e6f1f2e34dceeb1ed6&quot;&gt;e6f1f2e34dceeb1ed6&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0d54e2533360cb4659b717a0226d2d7a1dbf1bbf" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; statement for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables that lack secondary indexes so that it works correctly with triggers and foreign keys. This was a new bug caused by performance optimizations added in version 3.16.0. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/30027b613b4&quot;&gt;30027b613b4&lt;/a&gt;</source>
          <target state="translated">修复缺少二级索引的&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表的&lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt;语句，以便它可以与触发器和外键一起正常使用。这是由3.16.0版中添加的性能优化引起的新错误。机票&lt;a href=&quot;https://www.sqlite.org/src/info/30027b613b4&quot;&gt;30027b613b4&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d509397fe960e4575a2e26f651dde6ff90b84a19" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command so that it spills excess content to disk rather than holding everything in memory, and possible causing an out-of-memory error for larger database files. This fixes an issue introduced by version 3.15.0.</source>
          <target state="translated">修复&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令，以便将多余的内容溢出到磁盘上，而不是将所有内容都保存在内存中，并可能导致较大的数据库文件出现内存不足错误。这解决了3.15.0版引入的问题。</target>
        </trans-unit>
        <trans-unit id="b036730fcf1ecafecf0573d1d74619be57162b96" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;optoverview#flattening&quot;&gt;query flattener&lt;/a&gt; so that it works on queries that contain subqueries that use &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f09fcd17810f65f717&quot;&gt;709fcd17810f65f717&lt;/a&gt;</source>
          <target state="translated">修复&lt;a href=&quot;optoverview#flattening&quot;&gt;查询拼合器&lt;/a&gt;，使其可用于包含使用&lt;a href=&quot;windowfunctions&quot;&gt;窗口函数的&lt;/a&gt;子查询的查询。机票&lt;a href=&quot;https://www.sqlite.org/src/info/f09fcd17810f65f717&quot;&gt;709fcd17810f65f717&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a295aba8a2bc4b671641db0bf3a60e0d6006706" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; so that it always ignores subplans that do not use an index.</source>
          <target state="translated">修复&lt;a href=&quot;optoverview#or_opt&quot;&gt;OR优化，&lt;/a&gt;以便它始终忽略不使用索引的子计划。</target>
        </trans-unit>
        <trans-unit id="69a683f5bb13785c6e99f6455ca83c519f9c2e7d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; so that it works correctly when the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; is used on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/8fd39115d8f46&quot;&gt;8fd39115d8f46&lt;/a&gt;</source>
          <target state="translated">修复&lt;a href=&quot;optoverview#skipscan&quot;&gt;跳过扫描优化，&lt;/a&gt;以便在对&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表使用&lt;a href=&quot;optoverview#or_opt&quot;&gt;OR优化&lt;/a&gt;时正确运行。门票&lt;a href=&quot;https://www.sqlite.org/src/info/8fd39115d8f46&quot;&gt;8fd39115d8f46&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d64c703876098dc69084f33c7133d65be1531802" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; command so that it works correctly with foreign keys on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">修复&lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt;命令，以便它可以与&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表上的外键一起正常使用。</target>
        </trans-unit>
        <trans-unit id="0d608a4f7657ad4f577e7889d266b51e07ca7fe6" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;series&quot;&gt;generate_series&lt;/a&gt; virtual table so that it correctly returns no rows if any of its constraints are NULL.</source>
          <target state="translated">修复&lt;a href=&quot;series&quot;&gt;generate_series&lt;/a&gt;虚拟表，以使其在任何约束为NULL的情况下都不会正确返回任何行。</target>
        </trans-unit>
        <trans-unit id="16b43b19be563d99895b6b7aa73c97080f1c15c0" translate="yes" xml:space="preserve">
          <source>Fix the REPLACE() function so that it returns NULL if the second argument is an empty string. Ticket #2324.</source>
          <target state="translated">修正 REPLACE()函数,使其在第二个参数为空字符串时返回 NULL。Ticket #2324.</target>
        </trans-unit>
        <trans-unit id="b71b83145fe1ea70f5f98014557a62cf7f2c2ec4" translate="yes" xml:space="preserve">
          <source>Fix the TCL interface so that the &quot;nullvalue&quot; setting is honored for TCL implementations of SQL functions.</source>
          <target state="translated">修正TCL接口,使 &quot;nullvalue &quot;的设置在TCL实现SQL函数时得到尊重。</target>
        </trans-unit>
        <trans-unit id="681e860e148ced87ec9dd7b3cfb9b43a75c2065d" translate="yes" xml:space="preserve">
          <source>Fix the behavior of &lt;a href=&quot;c3ref/column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt; for queries that use the &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt; so that the result is consistent with other queries that do not use that optimization, and with PostgreSQL, MySQL, and SQLServer. Ticket &lt;a href=&quot;https://sqlite.org/src/info/de3403bf5ae&quot;&gt;de3403bf5ae&lt;/a&gt;.</source>
          <target state="translated">修复&lt;a href=&quot;c3ref/column_name&quot;&gt;sqlite3_column_name（）&lt;/a&gt;对于使用&lt;a href=&quot;optoverview#flattening&quot;&gt;扁平化优化的&lt;/a&gt;查询的行为，以使结果与不使用该优化的其他查询以及PostgreSQL，MySQL和SQLServer一致。门票&lt;a href=&quot;https://sqlite.org/src/info/de3403bf5ae&quot;&gt;de3403bf5ae&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e2fb92f8546f34175b1dda79777c363dd68d103" translate="yes" xml:space="preserve">
          <source>Fix the behavior of comparison operators (ex: &quot;&lt;b&gt;&amp;amp;lt&lt;/b&gt;&quot;, &quot;&lt;b&gt;==&lt;/b&gt;&quot;, etc.) so that they are consistent with the order of entries in an index.</source>
          <target state="translated">修复比较运算符的行为（例如：&amp;ldquo; &lt;b&gt;＆lt&lt;/b&gt; &amp;rdquo;，&amp;ldquo; &lt;b&gt;==&lt;/b&gt; &amp;rdquo;等），以使其与索引中条目的顺序一致。</target>
        </trans-unit>
        <trans-unit id="a6cdb1736bb68b0b3c4ede9fdba04199758b7855" translate="yes" xml:space="preserve">
          <source>Fix the behavior of comparison operators (ex: &quot;&lt;b&gt;&amp;lt;&lt;/b&gt;&quot;, &quot;&lt;b&gt;==&lt;/b&gt;&quot;, etc.) so that they are consistent with the order of entries in an index.</source>
          <target state="translated">修复比较运算符的行为（例如：&amp;ldquo; &lt;b&gt;&amp;lt;&lt;/b&gt; &amp;rdquo;，&amp;ldquo; &lt;b&gt;==&lt;/b&gt; &amp;rdquo;等），以使其与索引中条目的顺序一致。</target>
        </trans-unit>
        <trans-unit id="6a8e8cd65707752281f4a6188d7da381520e451a" translate="yes" xml:space="preserve">
          <source>Fix the behavior of typeof() and length() on virtual tables. Ticket &lt;a href=&quot;https://sqlite.org/src/info/69d642332d25aa3b7315a6d385&quot;&gt;69d642332d25aa3b7315a6d385&lt;/a&gt;</source>
          <target state="translated">修复虚拟表上typeof（）和length（）的行为。门票&lt;a href=&quot;https://sqlite.org/src/info/69d642332d25aa3b7315a6d385&quot;&gt;69d642332d25aa3b7315a6d385&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df05e2dc4f6d16d80624e7984c8465e501af7d3b" translate="yes" xml:space="preserve">
          <source>Fix the build so that it works with -DSQLITE_OMIT_WAL.</source>
          <target state="translated">修复构建,使其与-DSQLITE_OMIT_WAL一起工作。</target>
        </trans-unit>
        <trans-unit id="2766a0c67ddd6ed7f5aaccb304bc1ba6ad153261" translate="yes" xml:space="preserve">
          <source>Fix the built-in printf logic so that it prints &quot;NaN&quot; not &quot;Inf&quot; for floating-point NaNs. Ticket #2345</source>
          <target state="translated">修正内置的 printf 逻辑,使其对浮点 NaNs 打印 &quot;NaN &quot;而不是 &quot;Inf&quot;。Ticket #2345</target>
        </trans-unit>
        <trans-unit id="5bfcd9ce8f5df54205f92dd3b6c0521e656224b0" translate="yes" xml:space="preserve">
          <source>Fix the bytecode generator to deal with a subquery in the FROM clause that is itself a UNION ALL where one side of the UNION ALL is a view that contains an ORDER BY. This is a long-standing issue that was discovered after the release of 3.16.1. See ticket &lt;a href=&quot;https://www.sqlite.org/src/info/190c2507&quot;&gt;190c2507&lt;/a&gt;.</source>
          <target state="translated">修复字节码生成器，以处理FROM子句中的子查询，该子句本身就是UNION ALL，其中UNION ALL的一侧是包含ORDER BY的视图。这是一个长期存在的问题，在3.16.1版本发布后就被发现。请参阅票证&lt;a href=&quot;https://www.sqlite.org/src/info/190c2507&quot;&gt;190c2507&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d203309fb6041974c7687fc93bbf99d6e93873bc" translate="yes" xml:space="preserve">
          <source>Fix the code generator for expressions of the form &quot;x IN (SELECT...)&quot; where the SELECT statement on the RHS is a correlated subquery. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/5e3c886796e5512e&quot;&gt;5e3c886796e5512e&lt;/a&gt;.</source>
          <target state="translated">修复代码生成器，以生成&amp;ldquo; x IN（SELECT ...）&amp;rdquo;形式的表达式，其中RHS上的SELECT语句是相关子查询。机票&lt;a href=&quot;https://www.sqlite.org/src/info/5e3c886796e5512e&quot;&gt;5e3c886796e5512e&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="13a43d34f4444938ebdb413873a4acf48769174e" translate="yes" xml:space="preserve">
          <source>Fix the configure script for the amalgamation so that the --readline option works again on Raspberry PIs.</source>
          <target state="translated">修正amalgamation的configure脚本,使--readline选项在Raspberry PIs上重新工作。</target>
        </trans-unit>
        <trans-unit id="0dffaab8602b04f745c3456ad0e79054b8bf2a09" translate="yes" xml:space="preserve">
          <source>Fix the function prototype for the open(2) system call to agree with POSIX. Without this fix, pthreads does not work correctly on NetBSD.</source>
          <target state="translated">修正 open(2)系统调用的函数原型,使其与 POSIX 兼容。如果没有这个修正,pthreads 在 NetBSD 上无法正常工作。</target>
        </trans-unit>
        <trans-unit id="0cdcb447680d92da840bf449347a30236662eba4" translate="yes" xml:space="preserve">
          <source>Fix the locking mechanism yet again to prevent &lt;b&gt;sqlite_exec()&lt;/b&gt; from returning SQLITE_PROTOCOL unnecessarily. This time the bug was a race condition in the locking code. This change affects both POSIX and Windows users.</source>
          <target state="translated">再次修复锁定机制，以防止&lt;b&gt;sqlite_exec（）&lt;/b&gt;不必要地返回SQLITE_PROTOCOL。这次错误是锁定代码中的竞争条件。此更改会影响POSIX和Windows用户。</target>
        </trans-unit>
        <trans-unit id="007c6c873e32f4b431e8ac6f01127288ee55c964" translate="yes" xml:space="preserve">
          <source>Fix the min() and max() optimizer so that it works when the FROM clause consists of a subquery.</source>
          <target state="translated">修正min()和max()优化器,使其在FROM子句包含子查询时也能工作。</target>
        </trans-unit>
        <trans-unit id="b12f6e9f1f8f67709743497fbebb71ef8c53459f" translate="yes" xml:space="preserve">
          <source>Fix the parser to accept valid &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; syntax. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7310e2fb3d046a5&quot;&gt;7310e2fb3d046a5&lt;/a&gt;</source>
          <target state="translated">修复解析器以接受有效的&lt;a href=&quot;rowvalue&quot;&gt;行值&lt;/a&gt;语法。门票&lt;a href=&quot;https://www.sqlite.org/src/info/7310e2fb3d046a5&quot;&gt;7310e2fb3d046a5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="13f421298ab97922575edd88af10f5d60d0152b2" translate="yes" xml:space="preserve">
          <source>Fix the query optimizer to correctly handle constant expressions in the ON clause of a LEFT JOIN. Ticket #2403</source>
          <target state="translated">修正查询优化器,以正确处理LEFT JOIN的ON子句中的常量表达式。Ticket #2403</target>
        </trans-unit>
        <trans-unit id="40584ba785f1b7ac57821c3d2f85216f2b32614c" translate="yes" xml:space="preserve">
          <source>Fix the query optimizer to handle rowid comparisons to NULL correctly. Ticket #2404</source>
          <target state="translated">修正查询优化器正确处理rowid比较为NULL的问题。Ticket #2404</target>
        </trans-unit>
        <trans-unit id="dfa9a47acf25a2f05ea48c9410e4c4747561d320" translate="yes" xml:space="preserve">
          <source>Fix the query planner so that IS and IS NULL operators are able to drive an index on a LEFT OUTER JOIN.</source>
          <target state="translated">修正查询规划器,使IS和IS NULL操作符能够在LEFT OUTER JOIN上驱动索引。</target>
        </trans-unit>
        <trans-unit id="5653a698bc06b9d4be42b0c1c2f59e7a1e2b1d3a" translate="yes" xml:space="preserve">
          <source>Fix the query planner so that it knows not to use &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexes&lt;/a&gt; on the right table of LEFT JOIN if the WHERE clause uses the &lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS operator&lt;/a&gt;. Fix for &lt;a href=&quot;https://sqlite.org/src/info/ce68383bf6aba&quot;&gt;ce68383bf6aba&lt;/a&gt;.</source>
          <target state="translated">修复查询计划程序，以便如果WHERE子句使用&lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS运算符&lt;/a&gt;，则它不知道在LEFT JOIN的右表上不使用&lt;a href=&quot;optoverview#autoindex&quot;&gt;自动索引&lt;/a&gt;。修复&lt;a href=&quot;https://sqlite.org/src/info/ce68383bf6aba&quot;&gt;ce68383bf6aba&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f099fcbe9d8c0841133d0c1acb48be9e9aec8aff" translate="yes" xml:space="preserve">
          <source>Fix the query planner so that it takes into account dependencies in the arguments to table-valued functions in subexpressions in the WHERE clause. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/80177f0c226ff54&quot;&gt;80177f0c226ff54&lt;/a&gt;</source>
          <target state="translated">修复查询计划程序，以便它考虑到WHERE子句中子表达式中表值函数的参数的依赖性。门票&lt;a href=&quot;https://www.sqlite.org/src/info/80177f0c226ff54&quot;&gt;80177f0c226ff54&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c51036bc7729aa3fd5a9f1ed633c206de4f498ea" translate="yes" xml:space="preserve">
          <source>Fix the query planner so that it works correctly for IS NOT NULL operators in the ON clause of a LEFT JOIN with the SQLITE_ENABLE_STAT4 compile-time option. &lt;a href=&quot;https://sqlite.org/src/info/65eb38f6e46de8c75e188a17ec&quot;&gt;65eb38f6e46de8c75e188a17ec&lt;/a&gt;</source>
          <target state="translated">修复查询计划程序，使其对于带有SQLITE_ENABLE_STAT4编译时选项的LEFT JOIN的ON子句中的IS NOT NULL运算符正确运行。&lt;a href=&quot;https://sqlite.org/src/info/65eb38f6e46de8c75e188a17ec&quot;&gt;65eb38f6e46de8c75e188a17ec&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2e67f4820003d691c4c8b5a0ce32d382b50cc512" translate="yes" xml:space="preserve">
          <source>Fix the regression test suite so that it works with Tcl8.5</source>
          <target state="translated">修正回归测试套件,使其能与Tcl8.5一起使用。</target>
        </trans-unit>
        <trans-unit id="6d468d38a1ed912125e5b1192b25781bdc29bb56" translate="yes" xml:space="preserve">
          <source>Fix the schema parser so that it interprets certain (obscure and ill-formed) CREATE TABLE statements the same as legacy. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/ac661962a2aeab3c331&quot;&gt;ac661962a2aeab3c331&lt;/a&gt;</source>
          <target state="translated">修复模式分析器，以使其解释与旧版相同的某些（模糊且格式错误的）CREATE TABLE语句。机票&lt;a href=&quot;https://www.sqlite.org/src/info/ac661962a2aeab3c331&quot;&gt;AC661962A2AEAB3C331的&lt;/a&gt;修复</target>
        </trans-unit>
        <trans-unit id="29c5cfa4d69ee4c85bc560fdea69b6008202a144" translate="yes" xml:space="preserve">
          <source>Fix to UPDATE triggers on TEMP tables.</source>
          <target state="translated">修复TEMP表的UPDATE触发器。</target>
        </trans-unit>
        <trans-unit id="8ac8e543b0bc738b6dc67d65d9b587bde27a9189" translate="yes" xml:space="preserve">
          <source>Fix to the --rbu option of &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt;.</source>
          <target state="translated">固定到的--rbu选项&lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dce0daf2e8b6a6a74ce23add5bf251c814f89da9" translate="yes" xml:space="preserve">
          <source>Fix two bugs in the locking protocol. (One was masking the other.)</source>
          <target state="translated">修复锁定协议中的两个bug。(一个是掩盖了另一个。)</target>
        </trans-unit>
        <trans-unit id="140466bf745b30af0254a8472b1f139b069fbb53" translate="yes" xml:space="preserve">
          <source>Fix two bugs, which when combined might result in incorrect query results. Both bugs were harmless by themselves; only when they team up do they cause problems. Ticket #3581.</source>
          <target state="translated">修复两个bug,这两个bug结合起来可能会导致不正确的查询结果。这两个bug本身是无害的,只有当它们联合起来才会导致问题。Ticket #3581.</target>
        </trans-unit>
        <trans-unit id="e9669895532c079b8fe44ba1553500c34f15f036" translate="yes" xml:space="preserve">
          <source>Fix two long-standing bugs that allow malicious SQL statements to crash the process that is running SQLite. These bugs were announced by a third-party approximately 24 hours after the 3.32.0 release but are not specific to the 3.32.0 release.</source>
          <target state="translated">修复两个长期存在的bug,允许恶意SQL语句使运行SQLite的进程崩溃。这些bug是在3.32.0版本发布后约24小时由第三方公布的,但并不是3.32.0版本特有的。</target>
        </trans-unit>
        <trans-unit id="c6b3c2eac5340186aa60ec6ef1bd320d9af1b4cf" translate="yes" xml:space="preserve">
          <source>Fix two problems in the new &lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;LEFT JOIN strength reduction optimization&lt;/a&gt;. Tickets &lt;a href=&quot;https://sqlite.org/src/info/1e39b966ae9ee739&quot;&gt;1e39b966ae9ee739&lt;/a&gt; and &lt;a href=&quot;https://sqlite.org/src/info/fac496b61722daf2&quot;&gt;fac496b61722daf2&lt;/a&gt;.</source>
          <target state="translated">解决了新的&lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;LEFT JOIN强度降低优化&lt;/a&gt;中的两个问题。门票&lt;a href=&quot;https://sqlite.org/src/info/1e39b966ae9ee739&quot;&gt;1e39b966ae9ee739&lt;/a&gt;和&lt;a href=&quot;https://sqlite.org/src/info/fac496b61722daf2&quot;&gt;fac496b61722daf2&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce60dbf83ec6124a3874f74bb112313a53e7aca8" translate="yes" xml:space="preserve">
          <source>Fix type coercion rules for the IN operator</source>
          <target state="translated">修正IN操作符的类型胁迫规则。</target>
        </trans-unit>
        <trans-unit id="1ef59214b1b8979108ab36722686dbe71717d826" translate="yes" xml:space="preserve">
          <source>Fix typos in documentation.</source>
          <target state="translated">修正文档中的错别字。</target>
        </trans-unit>
        <trans-unit id="c5df6889e7873170528ac5b7149060416fb8a48c" translate="yes" xml:space="preserve">
          <source>Fix typos in the documentation</source>
          <target state="translated">修正文档中的错别字</target>
        </trans-unit>
        <trans-unit id="a8caeeab6423273de2d0f3b9037854eda089993c" translate="yes" xml:space="preserve">
          <source>Fix uninitialized variables causing malfunctions for various obscure queries</source>
          <target state="translated">修正未初始化变量导致各种晦涩的查询故障的问题</target>
        </trans-unit>
        <trans-unit id="334faf48b2d08d39ac3f83df69ba4313064d2eca" translate="yes" xml:space="preserve">
          <source>Fix various documentation typos</source>
          <target state="translated">修正各种文件中的错别字</target>
        </trans-unit>
        <trans-unit id="bfc06020350fd18063be73e1e193870b6478ef89" translate="yes" xml:space="preserve">
          <source>Fix various other minor test script problems.</source>
          <target state="translated">修复其他各种小的测试脚本问题。</target>
        </trans-unit>
        <trans-unit id="04a80b08dce7f337318b3de8005ba6821f9088b9" translate="yes" xml:space="preserve">
          <source>Fix warning messages in VC++ 7.0. (Patches from nicolas352001)</source>
          <target state="translated">修正VC++7.0中的警告信息。(补丁来自nicolas352001)</target>
        </trans-unit>
        <trans-unit id="e356e2b704a2e01de653ed2ebbf706f69ff2717e" translate="yes" xml:space="preserve">
          <source>Fixed &lt;b&gt;sqlite.h&lt;/b&gt; so that it is usable from C++</source>
          <target state="translated">修复了&lt;b&gt;sqlite.h，&lt;/b&gt;以便可以从C ++使用</target>
        </trans-unit>
        <trans-unit id="79e373e30e82498299cb604bd835209f11c2361f" translate="yes" xml:space="preserve">
          <source>Fixed a bug in the &quot;copy&quot; method of the TCL interface.</source>
          <target state="translated">修正了TCL接口中 &quot;复制 &quot;方法的一个错误。</target>
        </trans-unit>
        <trans-unit id="c148872cc8b9ab806e9be600a6bc5019b39f4b73" translate="yes" xml:space="preserve">
          <source>Fixed a bug in the processing of LEFT OUTER JOIN</source>
          <target state="translated">修正了处理LEFT OUTER JOIN时的一个BUG</target>
        </trans-unit>
        <trans-unit id="8958f58770783b2b2d9b98f41e760b01637c6fbf" translate="yes" xml:space="preserve">
          <source>Fixed a bug in the query planner that caused performance regressions relative to 3.6.23.1 on some complex joins.</source>
          <target state="translated">修正了查询规划器中的一个bug,该bug导致一些复杂连接的性能相对于3.6.23.1有所下降。</target>
        </trans-unit>
        <trans-unit id="ce57a2f7dac9c404f24a8b0780affccd90fd36f4" translate="yes" xml:space="preserve">
          <source>Fixed a bug that caused database corruption when an &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; is rolled back in an in-memory database. Ticket #3761.</source>
          <target state="translated">修正了一个导致数据库损坏时的错误&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt;在内存数据库回滚。机票＃3761。</target>
        </trans-unit>
        <trans-unit id="47075269c498ed42295ff1e4b7548fb034943cbd" translate="yes" xml:space="preserve">
          <source>Fixed a bug that was causing updates to fail inside of transactions when the database contained a temporary table.</source>
          <target state="translated">修正了当数据库包含临时表时,在事务中导致更新失败的错误。</target>
        </trans-unit>
        <trans-unit id="479bbff8b43af13fac5ef791395960b4f803b850" translate="yes" xml:space="preserve">
          <source>Fixed a critical bug in the &lt;a href=&quot;https://www.sqlite.org/see/doc/trunk/www/readme.wiki&quot;&gt;SQLite Encryption Extension&lt;/a&gt; that could cause the database to become unreadable and unrecoverable if a &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command changed the size of the encryption nonce.</source>
          <target state="translated">修复了&lt;a href=&quot;https://www.sqlite.org/see/doc/trunk/www/readme.wiki&quot;&gt;SQLite加密扩展&lt;/a&gt;中的一个严重错误，如果&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令更改了加密随机数的大小，该错误可能导致数据库变得不可读和不可恢复。</target>
        </trans-unit>
        <trans-unit id="59729403a0ff39e62d5592f59ad0496bc74d3cb0" translate="yes" xml:space="preserve">
          <source>Fixed a typo in the OS/2 backend.</source>
          <target state="translated">修正了OS/2后台的一个印刷错误。</target>
        </trans-unit>
        <trans-unit id="639269284376af975435d947ede551d59f7c8a90" translate="yes" xml:space="preserve">
          <source>Fixed an off-by-one error that was causing a coredump in the '%q' format directive of the new &lt;b&gt;sqlite_..._printf()&lt;/b&gt; routines.</source>
          <target state="translated">修复了导致新的&lt;b&gt;sqlite _..._ printf（）&lt;/b&gt;例程的'％q'格式指令发生核心转储的一次性错误。</target>
        </trans-unit>
        <trans-unit id="2f93f642c24bc3ca9d72401aa0c30d511f868145" translate="yes" xml:space="preserve">
          <source>Fixed lots of spelling errors in the source-code comments</source>
          <target state="translated">修正了源代码注释中的大量拼写错误。</target>
        </trans-unit>
        <trans-unit id="fd59e954365ccfc713ffa89ef7eee7b8910b50c3" translate="yes" xml:space="preserve">
          <source>Fixed naming conflicts so that versions 2.8 and 3.0 can be linked and used together in the same ANSI-C source file.</source>
          <target state="translated">修正了命名冲突,使 2.8 和 3.0 版本可以在同一个 ANSI-C 源文件中链接并一起使用。</target>
        </trans-unit>
        <trans-unit id="8dc0276046c4c36ea547c5cf770bbba66b28361f" translate="yes" xml:space="preserve">
          <source>Fixed performance problems and potential stack overflows when creating &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt; from multi-row VALUES clauses with hundreds of thousands of rows.</source>
          <target state="translated">从具有成千上万行的多行VALUES子句创建&lt;a href=&quot;lang_createview&quot;&gt;视图&lt;/a&gt;时，修复了性能问题和潜在的堆栈溢出。</target>
        </trans-unit>
        <trans-unit id="48a5b411b131a16a7c3a81ff9ffe341d205ab7e3" translate="yes" xml:space="preserve">
          <source>Fixed some instances where &lt;b&gt;sqlite_exec()&lt;/b&gt; was returning the wrong error code.</source>
          <target state="translated">修复了&lt;b&gt;sqlite_exec（）&lt;/b&gt;返回错误错误代码的某些情况。</target>
        </trans-unit>
        <trans-unit id="d2abd59d7529d7221419b75d94eed0ee9277c4cd" translate="yes" xml:space="preserve">
          <source>Fixed the &quot;.dump&quot; command in the command-line shell to show indices, triggers and views again.</source>
          <target state="translated">修正了命令行shell中的&quot;.dump &quot;命令,以再次显示指数、触发器和视图。</target>
        </trans-unit>
        <trans-unit id="923cc8fbcaf6842679b5f1e15d6df83e508e85ec" translate="yes" xml:space="preserve">
          <source>Fixed the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; so that &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces and the &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; return the correct values.</source>
          <target state="translated">修复了&lt;a href=&quot;lang_delete#truncateopt&quot;&gt;截断优化，&lt;/a&gt;以便&lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes（）&lt;/a&gt;和&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;接口以及&lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes编译指示&lt;/a&gt;返回正确的值。</target>
        </trans-unit>
        <trans-unit id="9e28c4773e158241fde9583f9f170c5ef9db0282" translate="yes" xml:space="preserve">
          <source>Fixed the operator precedence for the ~ operator.</source>
          <target state="translated">修正了~运算符的运算符优先性。</target>
        </trans-unit>
        <trans-unit id="7effc13b7d809cd0670d65239ee3df045defba54" translate="yes" xml:space="preserve">
          <source>Fixes for various minor bugs.</source>
          <target state="translated">修复了各种小错误。</target>
        </trans-unit>
        <trans-unit id="6db891bdea0dad81fb2181f92e7eface672bbf02" translate="yes" xml:space="preserve">
          <source>Fixes for various other compiler warnings and minor problems associated with obscure configurations.</source>
          <target state="translated">修正了其他各种编译器警告和与晦涩配置相关的小问题。</target>
        </trans-unit>
        <trans-unit id="2582d7cc3520de6113cfebc05a4c0c40c10d2aea" translate="yes" xml:space="preserve">
          <source>Fixes to the rollback and locking behavior</source>
          <target state="translated">对回滚和锁定行为的修正</target>
        </trans-unit>
        <trans-unit id="300a0178f58415dda787e9c4b1d46e58f9cdc26d" translate="yes" xml:space="preserve">
          <source>FkCounter</source>
          <target state="translated">FkCounter</target>
        </trans-unit>
        <trans-unit id="a7826ae0da180dcf999c042085ef7ac58cfd77ff" translate="yes" xml:space="preserve">
          <source>FkIfZero</source>
          <target state="translated">FkIfZero</target>
        </trans-unit>
        <trans-unit id="a774409a00c21de377cf8ed5c6a56b8547973042" translate="yes" xml:space="preserve">
          <source>Flag</source>
          <target state="translated">Flag</target>
        </trans-unit>
        <trans-unit id="502eddf598188b96c0b40f89e8492bff9de3fa43" translate="yes" xml:space="preserve">
          <source>Flags For File Open Operations</source>
          <target state="translated">文件打开操作的标志</target>
        </trans-unit>
        <trans-unit id="9e0bdeb766ef28db46f01b095bdb326b4da9f972" translate="yes" xml:space="preserve">
          <source>Flags consist of zero or more characters that immediately follow the &quot;%&quot; that introduces the substitution. The various flags and their meanings are as follows:</source>
          <target state="translated">标志由紧跟在&quot;%&quot;后面的零个或多个字符组成,引入替换。各种标志及其含义如下:</target>
        </trans-unit>
        <trans-unit id="e52973142fb5309e0599d0aece55b28093c55ec5" translate="yes" xml:space="preserve">
          <source>Flags for sqlite3_deserialize()</source>
          <target state="translated">sqlite3_deserialize()的标志。</target>
        </trans-unit>
        <trans-unit id="763319af81f124ab801773d718a34a5b48132717" translate="yes" xml:space="preserve">
          <source>Flags for sqlite3_serialize</source>
          <target state="translated">sqlite3_serialize的标志。</target>
        </trans-unit>
        <trans-unit id="f15088d96e03c231ed7711a618b87a23e40d38d1" translate="yes" xml:space="preserve">
          <source>Flags for sqlite3changeset_apply_v2</source>
          <target state="translated">sqlite3changeset_apply_v2的标志。</target>
        </trans-unit>
        <trans-unit id="9c6b7b2401c21ffe043e97decac28ab2c77bcf8f" translate="yes" xml:space="preserve">
          <source>Flags for sqlite3changeset_start_v2</source>
          <target state="translated">sqlite3changeset_start_v2的标志。</target>
        </trans-unit>
        <trans-unit id="8565c5e3d19dd91c15d8aea38675feb62cbfe94b" translate="yes" xml:space="preserve">
          <source>Flags for the xAccess VFS method</source>
          <target state="translated">xAccess VFS方法的标志。</target>
        </trans-unit>
        <trans-unit id="caa91d141d9230cced8ac027e0837943663b4e27" translate="yes" xml:space="preserve">
          <source>Flags for the xShmLock VFS method</source>
          <target state="translated">xShmLock VFS方法的标志。</target>
        </trans-unit>
        <trans-unit id="a4c5b52302ff6c09b0d29efa63650e0dd9711b0a" translate="yes" xml:space="preserve">
          <source>Flexible typing is considered a feature of SQLite, not a bug. Nevertheless, we recognize that this feature does sometimes cause confusion and pain for developers who are acustomed to working with other databases that are more judgemental with regard to data types. In retrospect, perhaps it would have been better if SQLite had merely implemented an ANY datatype so that developers could explicitly state when they wanted to use flexible typing, rather than making flexible typing the default. But that is not something that can be changed now without breaking the millions of applications and trillions of database files that already use SQLite's flexible typing feature.</source>
          <target state="translated">灵活的类型被认为是SQLite的一个特性,而不是一个错误。然而,我们认识到这个特性有时确实会给那些习惯于使用其他数据库的开发人员带来困惑和痛苦,因为这些数据库对数据类型的判断力更强。回想起来,如果SQLite仅仅实现了ANY数据类型,让开发人员可以明确地说明什么时候要使用灵活的类型,而不是将灵活的类型作为默认值,也许会更好。但这不是现在可以改变的,否则就会破坏已经使用SQLite灵活键入功能的数百万应用程序和数万亿数据库文件。</target>
        </trans-unit>
        <trans-unit id="f7fca84542efdc71814460460268fade242aaf16" translate="yes" xml:space="preserve">
          <source>Flexible typing is considered a feature of SQLite, not a bug. Nevertheless, we recognize that this feature does sometimes cause confusion and pain for developers who are acustomed to working with other databases that are more judgmental with regard to data types. In retrospect, perhaps it would have been better if SQLite had merely implemented an ANY datatype so that developers could explicitly state when they wanted to use flexible typing, rather than making flexible typing the default. But that is not something that can be changed now without breaking the millions of applications and trillions of database files that already use SQLite's flexible typing feature.</source>
          <target state="translated">灵活的类型被认为是SQLite的一个特性,而不是一个错误。然而,我们认识到这个特性有时确实会给那些习惯于使用其他数据库的开发人员带来困惑和痛苦,因为这些数据库对数据类型的判断力更强。回想起来,如果SQLite仅仅实现了ANY数据类型,让开发人员可以明确地说明什么时候要使用灵活类型,而不是将灵活类型作为默认值,也许会更好。但这不是现在可以改变的,否则就会破坏已经使用SQLite灵活键入功能的数百万应用程序和数万亿数据库文件。</target>
        </trans-unit>
        <trans-unit id="cbfba25d0250d74cb72b3ec89534cd1cbcf21211" translate="yes" xml:space="preserve">
          <source>Floating Point Numbers</source>
          <target state="translated">浮点数</target>
        </trans-unit>
        <trans-unit id="5313cf765977fac30e9d1af597f3d35ce5c16d92" translate="yes" xml:space="preserve">
          <source>Floating Pointer Numbers</source>
          <target state="translated">浮动指针数</target>
        </trans-unit>
        <trans-unit id="595acd952f7adef405182868a3f64d0a5da38dfd" translate="yes" xml:space="preserve">
          <source>Flock locking style. This is used for file-systems that do not support POSIX locking style. Locks are obtained and released using the flock() system call.</source>
          <target state="translated">群集锁定方式。这用于不支持POSIX锁定方式的文件系统。使用flock()系统调用获得和释放锁。</target>
        </trans-unit>
        <trans-unit id="c57073033af4c5995ecd6e60b89e343929d9d2c9" translate="yes" xml:space="preserve">
          <source>Flush all database file changes to the disk. Wait for those changes to actually be written onto the disk surface.</source>
          <target state="translated">将所有数据库文件的更改刷新到磁盘上。等待这些更改真正写到磁盘表面。</target>
        </trans-unit>
        <trans-unit id="de39ff51371c017e6227bb21dd0f83307b8a58ff" translate="yes" xml:space="preserve">
          <source>Flush caches to disk mid-transaction</source>
          <target state="translated">在交易中途将缓存刷新到磁盘。</target>
        </trans-unit>
        <trans-unit id="f57e8f8a92192df5f1207764618acfad2559efdf" translate="yes" xml:space="preserve">
          <source>Follow these steps to create your own virtual table:</source>
          <target state="translated">按照这些步骤来创建你自己的虚拟表格。</target>
        </trans-unit>
        <trans-unit id="95cf2c9a54fa89f9d97591c92b0397a9def66730" translate="yes" xml:space="preserve">
          <source>Following a successful call to this function, it is the responsibility of the caller to eventually free the buffer that *ppChangeset points to using &lt;a href=&quot;../c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">成功调用此函数后，调用者有责任最终使用&lt;a href=&quot;../c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放* ppChangeset指向的缓冲区。</target>
        </trans-unit>
        <trans-unit id="94243dad6fb7fd03cdf4ccdea9ad8045597be29a" translate="yes" xml:space="preserve">
          <source>Following a successful call to this function, it is the responsibility of the caller to eventually free the buffer that *ppChangeset points to using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">成功调用此函数后，调用者有责任最终使用&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放* ppChangeset指向的缓冲区。</target>
        </trans-unit>
        <trans-unit id="6ecbb1f3edb4dd34a3fdff354068e2c4ff752166" translate="yes" xml:space="preserve">
          <source>Following a system recovery, if a device sector is deemed to be untrustworthy as defined by A21008 and neither A21011 or A21012 apply to the range of bytes written, then no assumption can be made about the content of the sector following recovery. It is assumed that it is possible for such a sector to be written correctly, not written at all, populated with garbage data or any combination thereof.</source>
          <target state="translated">在系统恢复后,如果一个设备扇区被认为是A21008所定义的不可信的,而且A21011或A21012都不适用于写入的字节范围,那么就不能对恢复后扇区的内容作出任何假设。假设这样的扇区有可能被正确写入,也有可能根本没有写入,也有可能被垃圾数据填满,或者是这几种情况的任意组合。</target>
        </trans-unit>
        <trans-unit id="1945818b9ff5e13872866426c7d8f1fe8a043f70" translate="yes" xml:space="preserve">
          <source>Following the header is the array of coordinate pairs. Each coordinate is a 32-bit floating point number. The use of 32-bit floating point values for coordinates means that any point on the earth's surface can be mapped with a resolution of approximately 2.5 meters. Higher resolutions are of course possible if the map is restricted to a single continent or country. Note that the resolution of coordinates in the geopoly module is similar in magnitude to daily movement of points on the earth's surface due to tidal forces.</source>
          <target state="translated">头部后面是坐标对的数组。每个坐标都是一个32位浮点数。使用32位浮点值作为坐标,意味着地球表面的任何一点都可以用大约2.5米的分辨率进行测绘。当然,如果地图仅限于一个大陆或国家,则可以有更高的分辨率。请注意,地缘模块中坐标的分辨率与地球表面各点因潮汐力而产生的日常移动幅度相似。</target>
        </trans-unit>
        <trans-unit id="581c115a7d0dc8fd1981c305296d4c558b5b086c" translate="yes" xml:space="preserve">
          <source>Following the single big &quot;timeline&quot; query, there are additional queries for each timeline element. Fossil is using the &quot;N+1 Query&quot; pattern rather than trying to grab all the information in as few queries as possible. But that is ok because there is no unnecessary IPC overhead. At the bottom of each timeline page, Fossil shows approximately how long it took to generate the page. For a 50-entry timeline, the latency is usually less than 25 milliseconds. Profiling shows that few of those milliseconds were spent inside the database engine.</source>
          <target state="translated">在单个大的 &quot;时间线 &quot;查询之后,每个时间线元素都有额外的查询。Fossil使用的是 &quot;N+1查询 &quot;模式,而不是试图在尽可能少的查询中抓取所有信息。但这是可以的,因为没有不必要的IPC开销。在每个时间线页面的底部,Fossil显示了生成该页面所花费的大约时间。对于一个50个条目的时间线,延迟通常小于25毫秒。剖析显示,这些毫秒中很少有花在数据库引擎内部的。</target>
        </trans-unit>
        <trans-unit id="19775ac9542956e84e3786d1a483a9c9a75b880c" translate="yes" xml:space="preserve">
          <source>For BLOBs smaller than 100KB, reads are faster when the BLOBs are stored directly in the database file. For BLOBs larger than 100KB, reads from a separate file are faster.</source>
          <target state="translated">对于小于100KB的BLOBs,当BLOBs直接存储在数据库文件中时,读取速度会更快。对于大于100KB的BLOB,从单独的文件中读取会更快。</target>
        </trans-unit>
        <trans-unit id="fe2cb0762ccc50d4f8dea08212f37ddd53624fef" translate="yes" xml:space="preserve">
          <source>For Binary64, M is a 53-bit integer and E is an 11-bit integer that is offset so that represents a range of values between -1074 and +972, inclusive.</source>
          <target state="translated">对于Binary64,M是一个53位的整数,E是一个11位的整数,它的偏移量使其代表的值范围在-1074和+972之间,包括在内。</target>
        </trans-unit>
        <trans-unit id="aa4adf09521eb69ba62c1a93da0b562f247aec24" translate="yes" xml:space="preserve">
          <source>For Binary64, M is a 53-bit integer and E is an 11-bit integer that offset so that represents a range of values between -1074 and +972, inclusive.</source>
          <target state="translated">对于Binary64来说,M是一个53位的整数,E是一个11位的整数,偏移量如此,代表的值范围在-1074和+972之间,包括。</target>
        </trans-unit>
        <trans-unit id="395ae193aa1eadd77633da6e02ed51db87786473" translate="yes" xml:space="preserve">
          <source>For SQLite</source>
          <target state="translated">对于SQLite</target>
        </trans-unit>
        <trans-unit id="f3c131948733abd40fff7115bdc1ab412d61d9a8" translate="yes" xml:space="preserve">
          <source>For SQLite version 2.6.3 and earlier, all values used the numeric datatype. The text datatype appears in version 2.7.0 and later. In the sequel it is assumed that you are using version 2.7.0 or later of SQLite.</source>
          <target state="translated">对于SQLite 2.6.3和更早的版本,所有的值都使用数字数据类型。文本数据类型出现在2.7.0及以后的版本中。在后面的内容中,假设你使用的是2.7.0或更高版本的SQLite。</target>
        </trans-unit>
        <trans-unit id="942453851992f474fda1456f6f181f26cf640d20" translate="yes" xml:space="preserve">
          <source>For SQLite versions prior to 3.24.0 (2018-06-04), the only information that an R*Tree index stores about an object is its integer ID and its bounding box. Additional information needs to be stored in separate tables and related to the R*Tree index using the primary key. For the example above, one might create an auxiliary table as follows:</source>
          <target state="translated">对于3.24.0(2018-06-04)之前的SQLite版本,R*Tree索引存储的关于对象的唯一信息是其整数ID和其边界框。其他信息需要存储在单独的表中,并使用主键与R*Tree索引相关。对于上面的例子,可以创建一个辅助表,如下所示。</target>
        </trans-unit>
        <trans-unit id="50f58131252372876ea89c95a887df9a9f6004ed" translate="yes" xml:space="preserve">
          <source>For UTF-16 databases, when using the &quot;simple&quot; tokenizer, it is possible to use malformed unicode strings to cause the &lt;a href=&quot;#integcheck&quot;&gt;integrity-check special command&lt;/a&gt; to falsely report corruption, or for &lt;a href=&quot;#snippet&quot;&gt;auxiliary functions&lt;/a&gt; to return incorrect results. More specifically, the bug can be triggered by any of the following:</source>
          <target state="translated">对于UTF-16数据库，当使用&amp;ldquo;简单&amp;rdquo;令牌生成器时，可能会使用格式错误的unicode字符串，导致&lt;a href=&quot;#integcheck&quot;&gt;完整性检查特殊命令&lt;/a&gt;错误地报告损坏，或者使&lt;a href=&quot;#snippet&quot;&gt;辅助功能&lt;/a&gt;返回不正确的结果。更具体地说，该错误可由以下任何一种触发：</target>
        </trans-unit>
        <trans-unit id="a64fca4030b56c7de05a5fe2b410b314416229df" translate="yes" xml:space="preserve">
          <source>For UTF16 input text to the sqlite3_result_text16(), sqlite3_result_text16be(), sqlite3_result_text16le(), and sqlite3_result_text64() routines, if the text contains invalid UTF16 characters, the invalid characters might be converted into the unicode replacement character, U+FFFD.</source>
          <target state="translated">对于输入到sqlite3_result_text16()、sqlite3_result_text16be()、sqlite3_result_text16le()和sqlite3_result_text64()例程的UTF16文本,如果文本中包含无效的UTF16字符,则无效字符可能会被转换为unicode替换字符U+FFFD。</target>
        </trans-unit>
        <trans-unit id="55b4a9ef398b6737e332f74269051f6a928aaf6c" translate="yes" xml:space="preserve">
          <source>For a &lt;b&gt;DELETE&lt;/b&gt; change, the payload consists of the PRIMARY KEY fields only. The original values of other fields are not stored as part of a patchset.</source>
          <target state="translated">对于&lt;b&gt;DELETE&lt;/b&gt;更改，有效负载仅包含PRIMARY KEY字段。其他字段的原始值不存储为补丁集的一部分。</target>
        </trans-unit>
        <trans-unit id="bad0ea706b018c5833dc966db96c3bbf3f0b2138" translate="yes" xml:space="preserve">
          <source>For a JOIN or INNER JOIN or CROSS JOIN, there is no difference between a constraint expression in the WHERE clause and one in the ON clause. However, for a LEFT JOIN or LEFT OUTER JOIN, the difference is very important. In a LEFT JOIN, the extra NULL row for the right-hand table is added after ON clause processing but before WHERE clause processing. A constraint of the form &quot;left.x=right.y&quot; in an ON clause will therefore allow through the added all-NULL rows of the right table. But if that same constraint is in the WHERE clause a NULL in &quot;right.y&quot; will prevent the expression &quot;left.x=right.y&quot; from being true, and thus exclude that row from the output.</source>
          <target state="translated">对于 JOIN 或 INNER JOIN 或 CROSS JOIN,WHERE 子句中的约束表达式和 ON 子句中的约束表达式没有区别。然而,对于LEFT JOIN或LEFT OUTER JOIN,两者的区别非常重要。在LEFT JOIN中,右侧表的额外NULL行是在ON子句处理之后,但在WHERE子句处理之前添加的。因此,在ON子句中的 &quot;left.x=right.y &quot;形式的约束将允许通过右侧表的额外全NULL行。但如果同样的约束条件在WHERE子句中,&quot;right.y &quot;中的NULL将阻止表达式 &quot;left.x=right.y &quot;为真,从而将该行从输出中排除。</target>
        </trans-unit>
        <trans-unit id="2837a8bb64314525a9077bf3440c2ed144dbb1b8" translate="yes" xml:space="preserve">
          <source>For a LEFT OUTER JOIN the situation is more complex. The following two queries are not equivalent:</source>
          <target state="translated">对于LEFT OUTER JOIN来说,情况就比较复杂了。以下两个查询并不等同。</target>
        </trans-unit>
        <trans-unit id="ad715a95908c984b7542ffaa9563f1288257e6ce" translate="yes" xml:space="preserve">
          <source>For a SELECT query that uses the full-text index, the offsets() function returns a text value containing a series of space-separated integers. For each term in each &lt;a href=&quot;#matchable&quot;&gt;phrase match&lt;/a&gt; of the current row, there are four integers in the returned list. Each set of four integers is interpreted as follows:</source>
          <target state="translated">对于使用全文索引的SELECT查询，offsets（）函数将返回一个文本值，该文本值包含一系列以空格分隔的整数。对于当前行的每个&lt;a href=&quot;#matchable&quot;&gt;短语匹配&lt;/a&gt;中的每个术语，返回列表中有四个整数。每组四个整数解释如下：</target>
        </trans-unit>
        <trans-unit id="6eca1d9c3f6f9db89f4bb4081945f8167605d308" translate="yes" xml:space="preserve">
          <source>For a command of the form &quot;REINDEX</source>
          <target state="translated">对于 &quot;REINDEX &quot;这种形式的命令,可以通过以下方式进行处理</target>
        </trans-unit>
        <trans-unit id="06d5551761da6c159b879a307caa21c04cdacf8a" translate="yes" xml:space="preserve">
          <source>For a commit involving multiple databases and a master journal, if the various databases were on different disk volumes and a power failure occurs during the commit, then when the machine comes back up the disks might be remounted with different names. Or some disks might not be mounted at all. When this happens the individual file journals and the master journal might not be able to find each other. The worst outcome from this scenario is that the commit ceases to be atomic. Some databases might be rolled back and others might not. All databases will continue to be self-consistent. To defend against this problem, keep all databases on the same disk volume and/or remount disks using exactly the same names after a power failure.</source>
          <target state="translated">对于一个涉及多个数据库和主日志的提交,如果不同的数据库在不同的磁盘卷上,而在提交过程中发生了断电,那么当机器恢复时,这些磁盘可能会以不同的名称重新挂载。或者有些磁盘可能根本就没有被挂载。在这种情况下,各个文件日志和主日志可能无法找到对方。这种情况下,最坏的结果是提交不再是原子性的。一些数据库可能会被回滚,而另一些数据库可能不会。所有的数据库将继续保持自一致。为了防御这个问题,在断电后,将所有数据库保持在同一个磁盘卷上,和/或使用完全相同的名字重新挂载磁盘。</target>
        </trans-unit>
        <trans-unit id="e40bdd6eb01aba5fc405b17e2bcc433fd88a3c9f" translate="yes" xml:space="preserve">
          <source>For a commit involving multiple databases and a super-journal, if the various databases were on different disk volumes and a power failure occurs during the commit, then when the machine comes back up the disks might be remounted with different names. Or some disks might not be mounted at all. When this happens the individual file journals and the super-journal might not be able to find each other. The worst outcome from this scenario is that the commit ceases to be atomic. Some databases might be rolled back and others might not. All databases will continue to be self-consistent. To defend against this problem, keep all databases on the same disk volume and/or remount disks using exactly the same names after a power failure.</source>
          <target state="translated">对于一个涉及多个数据库和一个超级期刊的提交,如果不同的数据库在不同的磁盘卷上,而在提交过程中发生了断电,那么当机器恢复时,这些磁盘可能会以不同的名称重新挂载。或者有些磁盘可能根本就没有被挂载。在这种情况下,各个文件日志和超级日志可能无法找到对方。这种情况下,最坏的结果是提交不再是原子性的。一些数据库可能会被回滚,而其他数据库可能不会。所有的数据库将继续保持自一致。为了防御这个问题,在断电后,将所有数据库保持在同一个磁盘卷上,和/或使用完全相同的名字重新挂载磁盘。</target>
        </trans-unit>
        <trans-unit id="bb9e9e569c28385b62c9d2cc5d8fba70bcf036db" translate="yes" xml:space="preserve">
          <source>For a directory entry, any value inserted into this field is ignored. Otherwise, if it is set to 0, then the file data or symbolic link target is stored as is in the zip archive and the compression method set to 0. If it is set to 8, then the file data or link target is compressed using deflate compression before it is stored and the compression method set to 8. Finally, if a NULL value is written to this field, the zipfile module automatically decides whether or not to compress the data before storing it.</source>
          <target state="translated">对于一个目录条目,插入到这个字段的任何值都会被忽略。否则,如果设置为0,那么文件数据或符号链接目标将按原样存储在zip压缩包中,压缩方式设置为0;如果设置为8,那么文件数据或链接目标将在存储前使用deflate压缩,压缩方式设置为8。最后,如果将NULL值写入该字段,则zipfile模块会自动决定是否在存储前对数据进行压缩。</target>
        </trans-unit>
        <trans-unit id="60b588cb6440e5757b3bffacb57c3da76e66f360" translate="yes" xml:space="preserve">
          <source>For a listing of the available dot commands, you can enter &quot;.help&quot; with no arguments. Or enter &quot;.help TOPIC&quot; for detailed information about TOPIC. The list of available dot-commands follows:</source>
          <target state="translated">要想获得可用的点阵命令列表,可以输入&quot;.help&quot;,但没有参数。或者输入&quot;.help TOPIC &quot;来获取有关 TOPIC 的详细信息。可用的点阵命令列表如下。</target>
        </trans-unit>
        <trans-unit id="d4baaae0b83211d05bdb6a6f17481963667e90c7" translate="yes" xml:space="preserve">
          <source>For a program that uses an SQLite database as its &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;, when a new database instance is first created the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command is ineffective because the database contain no data from which to gather statistics. In that case, one could construct a large prototype database containing typical data during development and run the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command on this prototype database to gather statistics, then save the prototype statistics as part of the application. After deployment, when the application goes to create a new database file, it can run the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command in order to create the statistics tables, then copy the precomputed statistics obtained from the prototype database into these new statistics tables. In that way, statistics from large working data sets can be preloaded into newly created application files.</source>
          <target state="translated">对于使用SQLite数据库作为其&lt;a href=&quot;appfileformat&quot;&gt;应用程序文件格式的程序&lt;/a&gt;，当首次创建新的数据库实例时，&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令无效，因为该数据库不包含用于收集统计信息的数据。在那种情况下，可以在开发期间构建一个包含典型数据的大型原型数据库，然后在该原型数据库上运行&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令以收集统计信息，然后将原型统计信息保存为应用程序的一部分。部署后，当应用程序要创建新的数据库文件时，它可以运行&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令以创建统计信息表，然后将从原型数据库获得的预先计算的统计信息复制到这些新的统计信息表中。这样，可以将大型工作数据集中的统计信息预加载到新创建的应用程序文件中。</target>
        </trans-unit>
        <trans-unit id="a94574556e6541171dc1e77628bd7786ebcc44a5" translate="yes" xml:space="preserve">
          <source>For a row-value &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt;, the left-hand side (hereafter &quot;LHS&quot;) can be either a parenthesized list of values or a subquery with multiple columns. But the right-hand side (hereafter &quot;RHS&quot;) must be a subquery expression.</source>
          <target state="translated">对于行值&lt;a href=&quot;lang_expr#in_op&quot;&gt;IN运算符&lt;/a&gt;，左侧（以下称&amp;ldquo; LHS&amp;rdquo;）可以是带括号的值列表，也可以是具有多列的子查询。但是，右侧（以下简称&amp;ldquo; RHS&amp;rdquo;）必须是子查询表达式。</target>
        </trans-unit>
        <trans-unit id="1f6b45d36586c69d55b8983f8d799c1d8e89a8c6" translate="yes" xml:space="preserve">
          <source>For a string value X, the length(X) function returns the number of characters (not bytes) in X prior to the first NUL character. Since SQLite strings do not normally contain NUL characters, the length(X) function will usually return the total number of characters in the string X. For a blob value X, length(X) returns the number of bytes in the blob. If X is NULL then length(X) is NULL. If X is numeric then length(X) returns the length of a string representation of X.</source>
          <target state="translated">对于字符串值X,length(X)函数返回X中第一个NUL字符之前的字符数(不是字节数)。由于SQLite字符串通常不包含NUL字符,所以length(X)函数通常会返回字符串X中的字符总数。对于blob值X,length(X)返回blob中的字节数。如果X是NULL,那么length(X)就是NULL。如果X是数字型,那么length(X)返回X的字符串表示的长度。</target>
        </trans-unit>
        <trans-unit id="d7e042b4a217a46e364221bac2287b2e16ce5e8f" translate="yes" xml:space="preserve">
          <source>For added readability, also set &quot;.echo on&quot; so that the output contains the original SQL text.</source>
          <target state="translated">为了增加可读性,还可以设置&quot;.echo on&quot;,使输出包含原始SQL文本。</target>
        </trans-unit>
        <trans-unit id="464bd448fbdde2a69f1880b4aadf91dc5c60e76e" translate="yes" xml:space="preserve">
          <source>For additional information on how the SQLite library functions, the reader is directed to look at the SQLite source code directly. If you understand the material in this article, you should not have much difficulty in following the sources. Serious students of the internals of SQLite will probably also want to make a careful study of the VDBE opcodes as documented &lt;a href=&quot;opcode&quot;&gt;here&lt;/a&gt;. Most of the opcode documentation is extracted from comments in the source code using a script so you can also get information about the various opcodes directly from the &lt;b&gt;vdbe.c&lt;/b&gt; source file. If you have successfully read this far, you should have little difficulty understanding the rest.</source>
          <target state="translated">有关SQLite库如何工作的其他信息，请读者直接查看SQLite源代码。如果您了解本文中的内容，那么在遵循原始资料方面应该不会有太多困难。认真学习SQLite内部知识的学生可能也希望仔细研究&lt;a href=&quot;opcode&quot;&gt;此处&lt;/a&gt;记录的VDBE操作码。大多数操作码文档都是使用脚本从源代码中的注释中提取的，因此您也可以直接从&lt;b&gt;vdbe.c&lt;/b&gt;源文件中获取有关各种操作码的信息。如果您已经成功阅读了此书，那么理解其余内容应该没有什么困难。</target>
        </trans-unit>
        <trans-unit id="5cc0c6c827845b6d255c4013e6ccd3c888188ba4" translate="yes" xml:space="preserve">
          <source>For aggregate functions, the &lt;b&gt;xStep&lt;/b&gt; callback is invoked once for each row in the result and then &lt;b&gt;xFinalize&lt;/b&gt; is invoked at the end to compute a final answer. The xStep routine can use the &lt;b&gt;sqlite_aggregate_context()&lt;/b&gt; interface to allocate memory that will be unique to that particular instance of the SQL function. This memory will be automatically deleted after xFinalize is called. The &lt;b&gt;sqlite_aggregate_count()&lt;/b&gt; routine can be used to find out how many rows of data were passed to the aggregate. The xFinalize callback should invoke one of the &lt;b&gt;sqlite_set_result_...&lt;/b&gt; interfaces to set the final result of the aggregate.</source>
          <target state="translated">对于聚合函数，&lt;b&gt;将对&lt;/b&gt;结果中的每一行调用一次&lt;b&gt;xStep&lt;/b&gt;回调，然后在最后调用&lt;b&gt;xFinalize&lt;/b&gt;来计算最终答案。 xStep例程可以使用&lt;b&gt;sqlite_aggregate_context（）&lt;/b&gt;接口分配对于该SQL函数的特定实例唯一的内存。调用xFinalize后，该内存将被自动删除。该&lt;b&gt;sqlite_aggregate_count（）&lt;/b&gt;程序可以用来找出多行数据是如何被传递到骨料。 xFinalize回调应调用&lt;b&gt;sqlite_set_result _...&lt;/b&gt;接口之一以设置聚合的最终结果。</target>
        </trans-unit>
        <trans-unit id="4a2b8e655022b370f7bf1cade1de14d9df62358a" translate="yes" xml:space="preserve">
          <source>For all of these errors, SQLite attempts to undo just the one statement it was working on and leave changes from prior statements within the same transaction intact and continue with the transaction. However, depending on the statement being evaluated and the point at which the error occurs, it might be necessary for SQLite to rollback and cancel the entire transaction. An application can tell which course of action SQLite took by using the &lt;a href=&quot;c3ref/get_autocommit&quot;&gt;sqlite3_get_autocommit()&lt;/a&gt; C-language interface.</source>
          <target state="translated">对于所有这些错误，SQLite尝试仅撤消其正在处理的一个语句，并保留同一事务中先前语句的更改不变，然后继续进行事务。但是，根据要评估的语句和发生错误的时间点，SQLite可能有必要回滚并取消整个事务。应用程序可以通过使用&lt;a href=&quot;c3ref/get_autocommit&quot;&gt;sqlite3_get_autocommit（）&lt;/a&gt; C语言接口来判断SQLite采取了哪种行动。</target>
        </trans-unit>
        <trans-unit id="edd867afbc99c464b46e982c8bdb271f01de00a1" translate="yes" xml:space="preserve">
          <source>For all versions of SQLite up to and including 3.6.23.1, a call to &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; was required after sqlite3_step() returned anything other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; before any subsequent invocation of sqlite3_step(). Failure to reset the prepared statement using &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; would result in an &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt; return from sqlite3_step(). But after &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;version 3.6.23.1&lt;/a&gt; (2010-03-26, sqlite3_step() began calling &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; automatically in this circumstance rather than returning &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. This is not considered a compatibility break because any application that ever receives an SQLITE_MISUSE error is broken by definition. The &lt;a href=&quot;compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt; compile-time option can be used to restore the legacy behavior.</source>
          <target state="translated">对于SQLite的所有版本直至并包括3.6.23.1，将呼叫&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;是sqlite3_step后需要（）返回以外的任何&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; sqlite3_step的任何后续调用之前（）。无法使用&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;重置准备好的语句将导致从sqlite3_step（）返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;。但是在&lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;版本3.6.23.1&lt;/a&gt;（2010-03-26）之后，sqlite3_step（）在这种情况下开始自动调用&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;而不是返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;，这不认为是兼容性破坏，因为任何收到SQLITE_MISUSE错误的应用程序都会被定义破坏该&lt;a href=&quot;compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt;可以使用compile-time选项还原旧的行为。</target>
        </trans-unit>
        <trans-unit id="c8ec8a08c58f886e596c21082f16011397cbdb2b" translate="yes" xml:space="preserve">
          <source>For all versions of SQLite up to and including 3.6.23.1, a call to &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; was required after sqlite3_step() returned anything other than &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; before any subsequent invocation of sqlite3_step(). Failure to reset the prepared statement using &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; would result in an &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; return from sqlite3_step(). But after &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;version 3.6.23.1&lt;/a&gt; (2010-03-26, sqlite3_step() began calling &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; automatically in this circumstance rather than returning &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. This is not considered a compatibility break because any application that ever receives an SQLITE_MISUSE error is broken by definition. The &lt;a href=&quot;../compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt; compile-time option can be used to restore the legacy behavior.</source>
          <target state="translated">对于SQLite的所有版本直至并包括3.6.23.1，将呼叫&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;是sqlite3_step后需要（）返回以外的任何&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; sqlite3_step的任何后续调用之前（）。无法使用&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;重置准备好的语句将导致从sqlite3_step（）返回&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;。但是在&lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;版本3.6.23.1&lt;/a&gt;（2010-03-26）之后，sqlite3_step（）在这种情况下开始自动调用&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;而不是返回&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;，这不认为是兼容性破坏，因为任何收到SQLITE_MISUSE错误的应用程序都会被定义破坏该&lt;a href=&quot;../compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt;可以使用compile-time选项还原旧的行为。</target>
        </trans-unit>
        <trans-unit id="cb3ef573edb29303f7422a9886c28f0ac60f646d" translate="yes" xml:space="preserve">
          <source>For allocators other than &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;, all memory allocations are of the same size. Hence, &lt;b&gt;n&lt;/b&gt;=1 and therefore &lt;b&gt;N&lt;/b&gt;=&lt;b&gt;M&lt;/b&gt;. In other words, the memory pool need be no larger than the largest amount of memory in use at any given moment.</source>
          <target state="translated">对于除&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;之外的分配器，所有内存分配大小均相同。因此，&lt;b&gt;&amp;Ntilde;&lt;/b&gt; = 1，因此&lt;b&gt;&amp;Ntilde;&lt;/b&gt; = &lt;b&gt;中号&lt;/b&gt;。换句话说，内存池不必大于任何给定时刻正在使用的最大内存量。</target>
        </trans-unit>
        <trans-unit id="a2e786b5782b352cf04ddbf2d2c01d46af6ed148" translate="yes" xml:space="preserve">
          <source>For an &lt;b&gt;UPDATE&lt;/b&gt; change, the payload consists of the PRIMARY KEY fields and the new values of modified fields only. The original values of modified fields are not stored as part of a patchset.</source>
          <target state="translated">对于&lt;b&gt;UPDATE&lt;/b&gt;更改，有效负载仅由PRIMARY KEY字段和修改字段的新值组成。修改后的字段的原始值不存储为补丁集的一部分。</target>
        </trans-unit>
        <trans-unit id="75e11d20a0da5a9f23b4badfcd48941683f1de15" translate="yes" xml:space="preserve">
          <source>For an UPDATE or DELETE operation on a &lt;a href=&quot;../rowidtable&quot;&gt;rowid table&lt;/a&gt;, the sixth parameter passed to the preupdate callback is the initial &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row being modified or deleted. For an INSERT operation on a rowid table, or any operation on a WITHOUT ROWID table, the value of the sixth parameter is undefined. For an INSERT or UPDATE on a rowid table the seventh parameter is the final rowid value of the row being inserted or updated. The value of the seventh parameter passed to the callback function is not defined for operations on WITHOUT ROWID tables, or for DELETE operations on rowid tables.</source>
          <target state="translated">对于对&lt;a href=&quot;../rowidtable&quot;&gt;rowid表&lt;/a&gt;的UPDATE或DELETE操作，传递给preupdate回调的第六个参数是要修改或删除的行的初始&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。对于对rowid表的INSERT操作或对WITHOUT ROWID表的任何操作，第六个参数的值是未定义的。对于在rowid表上进行INSERT或UPDATE，第七个参数是要插入或更新的行的最终rowid值。没有为WITHOUT ROWID表上的操作或对rowid表上的DELETE操作定义传递给回调函数的第七个参数的值。</target>
        </trans-unit>
        <trans-unit id="87c8bcb65c916a4e76edf02935c7238f192ed71f" translate="yes" xml:space="preserve">
          <source>For an UPDATE or DELETE operation on a &lt;a href=&quot;../rowidtable&quot;&gt;rowid table&lt;/a&gt;, the sixth parameter passed to the preupdate callback is the initial &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row being modified or deleted. For an INSERT operation on a rowid table, or any operation on a WITHOUT ROWID table, the value of the sixth parameter is undefined. For an INSERT or UPDATE on a rowid table the seventh parameter is the final rowid value of the row being inserted or updated. The value of the seventh parameter passed to the callback function is not defined for operations on WITHOUT ROWID tables, or for INSERT operations on rowid tables.</source>
          <target state="translated">对于对&lt;a href=&quot;../rowidtable&quot;&gt;rowid表&lt;/a&gt;的UPDATE或DELETE操作，传递给preupdate回调的第六个参数是要修改或删除的行的初始&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。对于对rowid表的INSERT操作或对WITHOUT ROWID表的任何操作，第六个参数的值是未定义的。对于在rowid表上进行INSERT或UPDATE，第七个参数是要插入或更新的行的最终rowid值。没有为WITHOUT ROWID表上的操作或对rowid表上的INSERT操作定义传递给回调函数的第七个参数的值。</target>
        </trans-unit>
        <trans-unit id="806a227d8b999dc681976c5588806bdde7c2cc58" translate="yes" xml:space="preserve">
          <source>For an UPDATE or DELETE operation on a &lt;a href=&quot;rowidtable&quot;&gt;rowid table&lt;/a&gt;, the sixth parameter passed to the preupdate callback is the initial &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row being modified or deleted. For an INSERT operation on a rowid table, or any operation on a WITHOUT ROWID table, the value of the sixth parameter is undefined. For an INSERT or UPDATE on a rowid table the seventh parameter is the final rowid value of the row being inserted or updated. The value of the seventh parameter passed to the callback function is not defined for operations on WITHOUT ROWID tables, or for DELETE operations on rowid tables.</source>
          <target state="translated">对于对&lt;a href=&quot;rowidtable&quot;&gt;rowid表&lt;/a&gt;的UPDATE或DELETE操作，传递给preupdate回调的第六个参数是要修改或删除的行的初始&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。对于对rowid表的INSERT操作或对WITHOUT ROWID表的任何操作，第六个参数的值是未定义的。对于在rowid表上进行INSERT或UPDATE，第七个参数是要插入或更新的行的最终rowid值。没有为WITHOUT ROWID表上的操作或对rowid表上的DELETE操作定义传递给回调函数的第七个参数的值。</target>
        </trans-unit>
        <trans-unit id="3fa74a389b030ce220f00901508abe1120507900" translate="yes" xml:space="preserve">
          <source>For an UPDATE or DELETE operation on a &lt;a href=&quot;rowidtable&quot;&gt;rowid table&lt;/a&gt;, the sixth parameter passed to the preupdate callback is the initial &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row being modified or deleted. For an INSERT operation on a rowid table, or any operation on a WITHOUT ROWID table, the value of the sixth parameter is undefined. For an INSERT or UPDATE on a rowid table the seventh parameter is the final rowid value of the row being inserted or updated. The value of the seventh parameter passed to the callback function is not defined for operations on WITHOUT ROWID tables, or for INSERT operations on rowid tables.</source>
          <target state="translated">对于对&lt;a href=&quot;rowidtable&quot;&gt;rowid表&lt;/a&gt;的UPDATE或DELETE操作，传递给preupdate回调的第六个参数是要修改或删除的行的初始&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。对于对rowid表的INSERT操作或对WITHOUT ROWID表的任何操作，第六个参数的值是未定义的。对于在rowid表上进行INSERT或UPDATE，第七个参数是要插入或更新的行的最终rowid值。没有为WITHOUT ROWID表上的操作或对rowid表上的INSERT操作定义传递给回调函数的第七个参数的值。</target>
        </trans-unit>
        <trans-unit id="6babaeb551e0ac84ca65632772689ec35209b982" translate="yes" xml:space="preserve">
          <source>For an example of an INSTEAD OF trigger, consider the following schema:</source>
          <target state="translated">对于INSTEAD OF触发器的例子,请考虑以下模式。</target>
        </trans-unit>
        <trans-unit id="1cb2ec7dc6172161d64c33e9d01d6ab6fb648efe" translate="yes" xml:space="preserve">
          <source>For an expression, the datatype of the result is often determined by the outermost operator. For example, arithmetic operators (&quot;+&quot;, &quot;*&quot;, &quot;%&quot;) always return a numeric results. The string concatenation operator (&quot;||&quot;) returns a text result. And so forth. If you are ever in doubt about the datatype of an expression you can use the special &lt;b&gt;typeof()&lt;/b&gt; SQL function to determine what the datatype is. For example:</source>
          <target state="translated">对于表达式，结果的数据类型通常由最外面的运算符确定。例如，算术运算符（&amp;ldquo; +&amp;rdquo;，&amp;ldquo; *&amp;rdquo;，&amp;ldquo;％&amp;rdquo;）始终返回数字结果。字符串串联运算符（&amp;ldquo; ||&amp;rdquo;）返回文本结果。依此类推。如果您对表达式的数据类型有疑问，可以使用特殊的&lt;b&gt;typeof（）&lt;/b&gt; SQL函数来确定数据类型是什么。例如：</target>
        </trans-unit>
        <trans-unit id="bfd2bf6338afe19ae0ee07cbe5d01f99a9e21507" translate="yes" xml:space="preserve">
          <source>For an external content table, the contents of the index are only compared to the contents of the external content table if the value specified for the rank column is 1.</source>
          <target state="translated">对于外部内容表来说,只有当为rank列指定的值为1时,才会将索引的内容与外部内容表的内容进行比较。</target>
        </trans-unit>
        <trans-unit id="8771671648f56259c0348d58066fbd244a9f5761" translate="yes" xml:space="preserve">
          <source>For an inner join, the two queries above would be identical. But special processing applies to the ON and USING clauses of an OUTER join: specifically, the constraints in an ON or USING clause do not apply if the right table of the join is on a null row, but the constraints do apply in the WHERE clause. The net effect is that putting the ON or USING clause expressions for a LEFT JOIN in the WHERE clause effectively converts the query to an ordinary INNER JOIN - albeit an inner join that runs more slowly.</source>
          <target state="translated">对于一个内部连接,上面的两个查询将是相同的。但是特殊的处理适用于OUTER join的ON和USING子句:具体来说,如果联接的右表是空行,那么ON或USING子句中的约束就不适用,但是在WHERE子句中约束就适用。净效果是,将LEFT JOIN的ON或USING子句表达式放在WHERE子句中,有效地将查询转换为普通的INNER JOIN--尽管是运行速度更慢的内部连接。</target>
        </trans-unit>
        <trans-unit id="1a4ee070dfc412248ab193b2f24fbdc7e7faab95" translate="yes" xml:space="preserve">
          <source>For an inner join, the two queries above would be identical. However, special processing applies to the ON and USING clauses of an OUTER join: specifically, the constraints in an ON or USING clause do not apply if the right table of the join is on a null row, but the constraints do apply in the WHERE clause. The net effect is that putting the ON or USING clause expressions for a LEFT JOIN in the WHERE clause effectively converts the query to an ordinary INNER JOIN - albeit an inner join that runs more slowly.</source>
          <target state="translated">对于一个内部连接,上面的两个查询将是相同的。然而,特殊的处理适用于OUTER join的ON和USING子句:具体来说,如果连接的右表是空行,那么ON或USING子句中的约束就不适用,但在WHERE子句中约束就适用。净效果是,将LEFT JOIN的ON或USING子句表达式放在WHERE子句中,有效地将查询转换为普通的INNER JOIN--尽管是运行速度更慢的内部连接。</target>
        </trans-unit>
        <trans-unit id="a4c04f89a73080a41ad80cd0704141b22ed403a6" translate="yes" xml:space="preserve">
          <source>For an ordinary on-disk database file, the serialization is just a copy of the disk file. For an in-memory database or a &quot;TEMP&quot; database, the serialization is the same sequence of bytes which would be written to disk if that database where backed up to disk.</source>
          <target state="translated">对于普通的磁盘数据库文件,序列化只是磁盘文件的拷贝。对于内存数据库或 &quot;TEMP &quot;数据库来说,序列化是与该数据库备份到磁盘时写入磁盘的字节序列相同。</target>
        </trans-unit>
        <trans-unit id="363689c9e649bf1c45ea48634a5a7f396dccdc2a" translate="yes" xml:space="preserve">
          <source>For any given SQL statement, there might be hundreds or thousands or even millions of different algorithms of performing the operation. All of these algorithms will get the correct answer, though some will run faster than others. The query planner is an &lt;a href=&quot;https://en.wikipedia.org/wiki/Artificial_intelligence&quot;&gt;AI&lt;/a&gt; that tries to pick the fastest and most efficient algorithm for each SQL statement.</source>
          <target state="translated">对于任何给定的SQL语句，可能会有成百上千甚至上百万个执行该操作的不同算法。所有这些算法都会得到正确的答案，尽管有些算法的运行速度会比其他算法快。查询计划程序是一种&lt;a href=&quot;https://en.wikipedia.org/wiki/Artificial_intelligence&quot;&gt;AI&lt;/a&gt;，它试图为每个SQL语句选择最快，最高效的算法。</target>
        </trans-unit>
        <trans-unit id="3653947a3bb3191399b5c8b60ea9ad5b81135d77" translate="yes" xml:space="preserve">
          <source>For any given query, the fact that the OR-clause optimization described here can be used does not guarantee that it will be used. SQLite uses a cost-based query planner that estimates the CPU and disk I/O costs of various competing query plans and chooses the plan that it thinks will be the fastest. If there are many OR terms in the WHERE clause or if some of the indexes on individual OR-clause subterms are not very selective, then SQLite might decide that it is faster to use a different query algorithm, or even a full-table scan. Application developers can use the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; prefix on a statement to get a high-level overview of the chosen query strategy.</source>
          <target state="translated">对于任何给定的查询，可以使用此处描述的&amp;ldquo;或&amp;rdquo;子句优化的事实并不能保证一定会使用它。 SQLite使用基于成本的查询计划程序来估算各种竞争查询计划的CPU和磁盘I / O成本，并选择它认为最快的计划。如果WHERE子句中有许多OR项，或者个别OR子句子项上的某些索引不是非常有选择性，则SQLite可能会决定使用其他查询算法甚至进行全表扫描的速度更快。应用程序开发人员可以在语句上使用&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;前缀来获得所选查询策略的高级概述。</target>
        </trans-unit>
        <trans-unit id="20178a76e031f6e0dd46cd965f669f77257d11d8" translate="yes" xml:space="preserve">
          <source>For any given query, the fact that the OR-clause optimization described here can be used does not guarantee that it will be used. SQLite uses a cost-based query planner that estimates the CPU and disk I/O costs of various competing query plans and chooses the plan that it thinks will be the fastest. If there are many OR terms in the WHERE clause or if some of the indices on individual OR-clause subterms are not very selective, then SQLite might decide that it is faster to use a different query algorithm, or even a full-table scan. Application developers can use the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; prefix on a statement to get a high-level overview of the chosen query strategy.</source>
          <target state="translated">对于任何给定的查询，可以使用此处描述的OR子句优化的事实并不能保证一定会使用它。 SQLite使用基于成本的查询计划程序来估算各种竞争查询计划的CPU和磁盘I / O成本，并选择它认为最快的计划。如果WHERE子句中有很多OR项，或者单个OR子句的某些索引的选择性不是很高，则SQLite可能会决定使用其他查询算法甚至进行全表扫描的速度更快。应用程序开发人员可以在语句上使用&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;前缀来获得所选查询策略的高级概述。</target>
        </trans-unit>
        <trans-unit id="16c7cb0ca5e5ce3a2a0070ff33c0953ef0a2395f" translate="yes" xml:space="preserve">
          <source>For any historical version of SQLite, the source tree can be obtained from the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; version control system, either downloading a tarball or ZIP archive for a specific version, or by cloning the entire project history.</source>
          <target state="translated">对于任何SQLite的历史版本，都可以从&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt;版本控制系统中获取源代码树，可以下载特定版本的tarball或ZIP归档文件，也可以克隆整个项目历史记录。</target>
        </trans-unit>
        <trans-unit id="a968f00ccfcf7f74b71aeeaabd2ebd15db485e2f" translate="yes" xml:space="preserve">
          <source>For any historical version of SQLite, the source tree can be obtained from the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; version control system, either downloading a tarball or ZIP archive for a specific version, or by cloning the entire project history.</source>
          <target state="translated">对于任何历史版本的SQLite，都可以从&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt;版本控制系统中获取源代码树，可以下载特定版本的tarball或ZIP存档，也可以克隆整个项目历史记录。</target>
        </trans-unit>
        <trans-unit id="6136d5ebef73dfa5b00893d194ed16a2a41f54ee" translate="yes" xml:space="preserve">
          <source>For auxiliary columns, only the name of the column matters. The &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; is ignored. Constraints such as NOT NULL, UNIQUE, REFERENCES, or CHECK are also ignored. However, future versions of SQLite might start paying attention to the type affinity and constraints, so users of auxiliary columns are advised to leave both blank, to avoid future compatibility problems.</source>
          <target state="translated">对于辅助列，仅列名很重要。该&lt;a href=&quot;datatype3#affinity&quot;&gt;类型的亲和力&lt;/a&gt;被忽略。诸如NOT NULL，UNIQUE，REFERENCES或CHECK之类的约束也将被忽略。但是，SQLite的未来版本可能会开始注意类型的亲和力和约束，因此建议辅助列的用户将两者都留为空白，以避免将来出现兼容性问题。</target>
        </trans-unit>
        <trans-unit id="38f9906eb0f1f05679eef0c31ffe0e8cfcb13adf" translate="yes" xml:space="preserve">
          <source>For backwards compatibility with older versions of SQLite that lack the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; interface, the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; interface is called automatically upon entry to certain key interfaces such as &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;, and &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;. The overhead of invoking &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; automatically in this way may be omitted by building SQLite with the SQLITE_OMIT_AUTOINIT C-preprocessor macro. When built using SQLITE_OMIT_AUTOINIT, SQLite will not automatically initialize itself and the application is required to invoke &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; directly prior to beginning use of the SQLite library.</source>
          <target state="translated">为了与缺少&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;接口的SQLite的旧版本向后兼容，在进入某些关键接口（例如&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;和&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;）时，会自动调用&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;接口。通过使用SQLITE_OMIT_AUTOINIT C预处理程序宏构建SQLite，可以省去以这种方式自动调用&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;的开销。使用SQLITE_OMIT_AUTOINIT构建时，SQLite不会自动初始化自身，并且要求应用程序直接在开始使用SQLite库之前调用&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2d1531a5da60e68beb6877ebc84583e140b012b5" translate="yes" xml:space="preserve">
          <source>For best security, do not use this method unless truly needed, and run &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema=OFF&lt;/a&gt; or the &quot;&lt;a href=&quot;#config&quot;&gt;db config trusted_schema 0&lt;/a&gt;&quot; method &lt;u&gt;before&lt;/u&gt; invoking this method.</source>
          <target state="translated">为了获得最佳安全性，除非确实需要，否则不要使用此方法，并&lt;u&gt;在&lt;/u&gt;调用此方法&lt;u&gt;之前&lt;/u&gt;运行&lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMAtrusted_schema = OFF&lt;/a&gt;或&amp;ldquo; &lt;a href=&quot;#config&quot;&gt;db config trust_schema 0&lt;/a&gt; &amp;rdquo;方法。&lt;u&gt;&lt;/u&gt;</target>
        </trans-unit>
        <trans-unit id="9c2a0d57a438475dac09b9669a68b59949b61514" translate="yes" xml:space="preserve">
          <source>For best security, the &lt;a href=&quot;#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag is recommended for all application-defined SQL functions that do not need to be used inside of triggers, view, CHECK constraints, or other elements of the database schema. This flags is especially recommended for SQL functions that have side effects or reveal internal application state. Without this flag, an attacker might be able to modify the schema of a database file to include invocations of the function with parameters chosen by the attacker, which the application will then execute when the database file is opened and read.</source>
          <target state="translated">为了获得最佳安全性，建议对不需要在触发器，视图，CHECK约束或数据库架构的其他元素内使用的所有应用程序定义的SQL函数建议使用&lt;a href=&quot;#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;标志。对于具有副作用或显示内部应用程序状态的SQL函数，特别推荐使用此标志。如果没有此标志，攻击者可能能够修改数据库文件的架构，以包含具有攻击者选择的参数的函数调用，然后在打开和读取数据库文件时应用程序将执行该调用。</target>
        </trans-unit>
        <trans-unit id="a82f5f85ed3a810b5bb82f46aed446a44b2ed973" translate="yes" xml:space="preserve">
          <source>For best security, the &lt;a href=&quot;c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag is recommended for all application-defined SQL functions that do not need to be used inside of triggers, view, CHECK constraints, or other elements of the database schema. This flags is especially recommended for SQL functions that have side effects or reveal internal application state. Without this flag, an attacker might be able to modify the schema of a database file to include invocations of the function with parameters chosen by the attacker, which the application will then execute when the database file is opened and read.</source>
          <target state="translated">为了获得最佳安全性，建议对不需要在触发器，视图，CHECK约束或数据库架构的其他元素内使用的所有应用程序定义的SQL函数建议使用&lt;a href=&quot;c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;标志。对于具有副作用或显示内部应用程序状态的SQL函数，特别推荐使用此标志。如果没有此标志，攻击者可能能够修改数据库文件的架构，以包含具有攻击者选择的参数的函数调用，然后在打开和读取数据库文件时应用程序将执行该调用。</target>
        </trans-unit>
        <trans-unit id="ad7a915b64d6fe6bb79ac5b4ba72d86b2b8e4dad" translate="yes" xml:space="preserve">
          <source>For bitmask tests, &lt;code&gt;testcase()&lt;/code&gt; macros are used to verify that every bit of the bitmask affects the outcome. For example, in the following block of code, the condition is true if the mask contains either of two bits indicating either a MAIN_DB or a TEMP_DB is being opened. The &lt;code&gt;testcase()&lt;/code&gt; macros that precede the if statement verify that both cases are tested:</source>
          <target state="translated">对于位掩码测试，使用 &lt;code&gt;testcase()&lt;/code&gt; 宏来验证位掩码的每一位都会影响结果。例如，在下面的代码块中，如果掩码包含两个位中的任何一个，则表明打开了MAIN_DB或TEMP_DB，该条件为true。该 &lt;code&gt;testcase()&lt;/code&gt; 宏先于if语句验证这两种情况下进行测试：</target>
        </trans-unit>
        <trans-unit id="1eab60de14b7b002b878e809e16b0c4001fb65d3" translate="yes" xml:space="preserve">
          <source>For both text and numeric values, NULL sorts before any other value. A comparison of any value against NULL using operators like &quot;&amp;lt;&quot; or &quot;&amp;gt;=&quot; is always false.</source>
          <target state="translated">对于文本值和数字值，NULL都排在其他任何值之前。使用&amp;ldquo; &amp;lt;&amp;rdquo;或&amp;ldquo; =&amp;rdquo;之类的运算符将任何值与NULL进行比较始终为false。</target>
        </trans-unit>
        <trans-unit id="0001dc558eb2ab6e42a7bb8e2fadd29ee6f23dde" translate="yes" xml:space="preserve">
          <source>For brevity, the diagrams in this section are simplified from those that came before. Blue color still signifies original content and pink still signifies new content. But the individual pages in the rollback journal and the database file are not shown and we are not making the distinction between information in the operating system cache and information that is on disk. All of these factors still apply in a multi-file commit scenario. They just take up a lot of space in the diagrams and they do not add any new information, so they are omitted here.</source>
          <target state="translated">为了简洁起见,本节的图是在前面的图基础上简化而成的。蓝色依然表示原始内容,粉色依然表示新内容。但是回滚日志和数据库文件中的各个页面没有显示出来,我们也没有区分操作系统缓存中的信息和磁盘上的信息。在多文件提交的情况下,所有这些因素仍然适用。只是它们在图中占用了很多空间,而且也没有增加任何新的信息,所以这里省略了。</target>
        </trans-unit>
        <trans-unit id="4e31069a755a0df659f64899fd564b4a8cf6e824" translate="yes" xml:space="preserve">
          <source>For command-line usage, add the short style command-line options immediately following the &quot;-A&quot;, without an intervening space. All subsequent arguments are considered to be part of the .archive command. For example, the following commands are equivalent:</source>
          <target state="translated">对于命令行的使用,请在&quot;-A &quot;之后立即添加短样式的命令行选项,中间不要有空格。所有后续参数都被认为是.archive命令的一部分。例如,以下命令是等价的。</target>
        </trans-unit>
        <trans-unit id="b9d0d974a63b482f33f7f36907a5721a5611077f" translate="yes" xml:space="preserve">
          <source>For commit records, the size of the database file in pages after the commit. For all other records, zero.</source>
          <target state="translated">对于提交记录,提交后数据库文件的大小,以页为单位。对于所有其他记录,为零。</target>
        </trans-unit>
        <trans-unit id="e91c377baed35ec4162bb3c1ca2f7aeb4671aa6f" translate="yes" xml:space="preserve">
          <source>For compatibility with older &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementations, this flag is turned on temporarily while the &lt;a href=&quot;vtab#xrename&quot;&gt;sqlite3_module.xRename&lt;/a&gt; method is being run. The value of this flag is restore after the &lt;a href=&quot;vtab#xrename&quot;&gt;sqlite3_module.xRename&lt;/a&gt; method finishes.</source>
          <target state="translated">为了与较旧的&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;实现兼容，在运行&lt;a href=&quot;vtab#xrename&quot;&gt;sqlite3_module.xRename&lt;/a&gt;方法时，将暂时打开此标志。在&lt;a href=&quot;vtab#xrename&quot;&gt;sqlite3_module.xRename&lt;/a&gt;方法完成后，将还原此标志的值。</target>
        </trans-unit>
        <trans-unit id="da9484ca4033054fc98b8e99fd5bf556ff20f8cb" translate="yes" xml:space="preserve">
          <source>For completeness, some of the higher level formatting information contains in the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; document and elsewhere is replicated here, when it pertains to WAL mode processing.</source>
          <target state="translated">为了完整起见，当涉及WAL模式处理时，&lt;a href=&quot;fileformat2&quot;&gt;文件格式&lt;/a&gt;文档中包含的某些更高级别的格式化信息以及其他内容将在此处复制。</target>
        </trans-unit>
        <trans-unit id="e99fbef35a40e331c478cf6f191e30ae20bee3b1" translate="yes" xml:space="preserve">
          <source>For correct operation of the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt;, make a copy of the &lt;a href=&quot;https://zlib.net&quot;&gt;zlib source code&lt;/a&gt; into the compat/zlib subdirectory of the source tree and compile this way:</source>
          <target state="translated">为了使&lt;a href=&quot;cli#sqlar&quot;&gt;.archive命令&lt;/a&gt;正确运行，请将&lt;a href=&quot;https://zlib.net&quot;&gt;zlib源代码&lt;/a&gt;的副本复制到源树的compat / zlib子目录中，并通过以下方式进行编译：</target>
        </trans-unit>
        <trans-unit id="a28c51fc9c57d328cc18317fd43208e2e391d0d1" translate="yes" xml:space="preserve">
          <source>For device-local storage with low writer concurrency and less than a terabyte of content, SQLite is almost always a better solution. SQLite is fast and reliable and it requires no configuration or maintenance. It keeps thing simple. SQLite &quot;just works&quot;.</source>
          <target state="translated">对于写手并发率较低、内容少于TB的设备本地存储,SQLite几乎总是更好的解决方案。SQLite快速可靠,而且不需要配置或维护。它让事情变得简单。SQLite &quot;就是好用&quot;。</target>
        </trans-unit>
        <trans-unit id="72afef4549faaf3eb91dc5ed7c4f9e5ba9217a77" translate="yes" xml:space="preserve">
          <source>For device-local storage with low writer concurrency and less than a terabyte of content, SQLite is almost always a better solution. SQLite is fast and reliable and it requires no configuration or maintenance. It keeps things simple. SQLite &quot;just works&quot;.</source>
          <target state="translated">对于写手并发率较低、内容少于TB的设备本地存储,SQLite几乎总是更好的解决方案。SQLite快速可靠,而且不需要配置或维护。它让事情变得简单。SQLite &quot;就是好用&quot;。</target>
        </trans-unit>
        <trans-unit id="14026abb0078c30fcbc6bf88b3e2948c23e3f5c6" translate="yes" xml:space="preserve">
          <source>For doclists for which the term appears in more than one column of the FTS virtual table, term-offset lists within the doclist are stored in column number order. This ensures that the term-offset list associated with column 0 (if any) is always first, allowing the first two fields of the term-offset list to be omitted in this case.</source>
          <target state="translated">对于术语出现在 FTS 虚拟表中一列以上的文档列表,文档列表中的术语偏移列表按列号顺序存储。这确保了与第0列相关联的术语偏移列表(如果有的话)总是排在第一位,在这种情况下,允许省略术语偏移列表的前两个字段。</target>
        </trans-unit>
        <trans-unit id="89b4ec40df531b5b987432b4a7fed5ea5b3e27ac" translate="yes" xml:space="preserve">
          <source>For each DELETE change, the function checks if the target database contains a row with the same primary key value (or values) as the original row values stored in the changeset. If it does, and the values stored in all non-primary key columns also match the values stored in the changeset the row is deleted from the target database.</source>
          <target state="translated">对于每一个DELETE更改,该函数检查目标数据库是否包含一条与更改集中存储的原始行值具有相同主键值(或值)的行。如果确实如此,并且所有非主键列中存储的值也与变化集中存储的值相匹配,则该行将从目标数据库中删除。</target>
        </trans-unit>
        <trans-unit id="1fb2d165bb57742263f5c19d2ad3dc7e863bddd8" translate="yes" xml:space="preserve">
          <source>For each FTS virtual table in a database, three to five real (non-virtual) tables are created to store the underlying data. These real tables are called &quot;shadow tables&quot;. The real tables are named &quot;%_content&quot;, &quot;%_segdir&quot;, &quot;%_segments&quot;, &quot;%_stat&quot;, and &quot;%_docsize&quot;, where &quot;%&quot; is replaced by the name of the FTS virtual table.</source>
          <target state="translated">对于数据库中的每一个FTS虚拟表,都会创建三到五个真实(非虚拟)表来存储基础数据。这些实表被称为 &quot;影子表&quot;。实表的名称为&quot;%_content&quot;、&quot;%_segdir&quot;、&quot;%_segments&quot;、&quot;%_stat &quot;和&quot;%_docsize&quot;,其中&quot;%&quot;由FTS虚拟表的名称代替。</target>
        </trans-unit>
        <trans-unit id="ca14bfe0c8ef783300da3fae2f2faf6123712788" translate="yes" xml:space="preserve">
          <source>For each INSERT change, an attempt is made to insert the new row into the database. If the changeset row contains fewer fields than the database table, the trailing fields are populated with their default values.</source>
          <target state="translated">对于每一个INSERT更改,都会尝试将新的行插入到数据库中。如果更改集行包含的字段比数据库表少,那么后面的字段将用它们的默认值填充。</target>
        </trans-unit>
        <trans-unit id="af26a43594c40c8d5075b1d213281d1a0d5d674e" translate="yes" xml:space="preserve">
          <source>For each UPDATE change, the function checks if the target database contains a row with the same primary key value (or values) as the original row values stored in the changeset. If it does, and the values stored in all modified non-primary key columns also match the values stored in the changeset the row is updated within the target database.</source>
          <target state="translated">对于每一个UPDATE更改,该函数检查目标数据库是否包含了一条与更改集中存储的原始行值具有相同主键值(或值)的行。如果确实如此,并且所有修改后的非主键列中存储的值也与改变集中存储的值相匹配,则该行在目标数据库中被更新。</target>
        </trans-unit>
        <trans-unit id="4c2b6b338ac313921ef720ea9cbd33ced2c0a043" translate="yes" xml:space="preserve">
          <source>For each UPDATE change, the old.* and new.* values are exchanged.</source>
          <target state="translated">对于每一次UPDATE更改,旧.*和新.*值都会被交换。</target>
        </trans-unit>
        <trans-unit id="d2a86ead2de9a7fdab60caec05b45cc30754d41b" translate="yes" xml:space="preserve">
          <source>For each cell in the r-tree structure (%_node table), that:</source>
          <target state="translated">对于r树结构(%_节点表)中的每个单元格,该。</target>
        </trans-unit>
        <trans-unit id="44564b0e8d37eeca09117cb0ce5677dfdd15f643" translate="yes" xml:space="preserve">
          <source>For each change for which there is a compatible table, an attempt is made to modify the table contents according to the UPDATE, INSERT or DELETE change. If a change cannot be applied cleanly, the conflict handler function passed as the fifth argument to sqlite3changeset_apply() may be invoked. A description of exactly when the conflict handler is invoked for each type of change is below.</source>
          <target state="translated">对于每一个有兼容表的变化,都会尝试根据UPDATE、INSERT或DELETE变化来修改表的内容。如果一个变化不能被干净地应用,那么作为 sqlite3changeset_apply()的第五个参数传递的冲突处理函数可能被调用。下面描述了冲突处理程序在什么时候被调用,对每一种类型的变更的具体说明。</target>
        </trans-unit>
        <trans-unit id="fabf5b0df1d79746c4d3b0f7c3d3e26095a89ed6" translate="yes" xml:space="preserve">
          <source>For each column in a row of the result, the name of that column is used as an index in to array and the value of the column is stored in the corresponding array entry. (Caution: If two or more columns in the result set of a query have the same name, then the last column with that name will overwrite prior values and earlier columns with the same name will be inaccessible.) The special array index * is used to store a list of column names in the order that they appear.</source>
          <target state="translated">对于结果行中的每一列,该列的名称作为数组的索引,并将该列的值存储在相应的数组条目中。(注意。如果查询结果集中有两列或更多列的名称相同,那么最后一列的名称将覆盖之前的值,而之前的同名列将无法访问)。)特殊的数组索引*用于按列名出现的顺序存储列名列表。</target>
        </trans-unit>
        <trans-unit id="c334738444e4ad47d383e7911a76c91bc19cd2c6" translate="yes" xml:space="preserve">
          <source>For each column, the average number of tokens in the text values stored in the column (considering all rows in the FTS4 table). This value is only available when querying FTS4 tables, not FTS3.</source>
          <target state="translated">对于每一列,存储在该列的文本值中的平均令牌数(考虑到FTS4表中的所有行)。这个值只有在查询FTS4表时才有,而不是FTS3表。</target>
        </trans-unit>
        <trans-unit id="7a8f829d184d100e174a5aa5857d53deb24e800d" translate="yes" xml:space="preserve">
          <source>For each column, the length of the longest subsequence of phrase matches that the column value has in common with the query text. For example, if a table column contains the text 'a b c d e' and the query is 'a c &quot;d e&quot;', then the length of the longest common subsequence is 2 (phrase &quot;c&quot; followed by phrase &quot;d e&quot;).</source>
          <target state="translated">对于每一列,列值与查询文本共同的最长子序列短语匹配的长度。例如,如果一个表列包含文本 &quot;a b c d e&quot;,而查询是 &quot;a c &quot;d e&quot;&quot;,那么最长的共同子序列的长度是2(短语 &quot;c &quot;后面是短语 &quot;d e&quot;)。</target>
        </trans-unit>
        <trans-unit id="a1353b0cd18d624357976b5c201f2ed175d084b1" translate="yes" xml:space="preserve">
          <source>For each column, the length of the value stored in the current row of the FTS4 table, in tokens. This value is only available when querying FTS4 tables, not FTS3. And only if the &quot;matchinfo=fts3&quot; directive was not specified as part of the &quot;CREATE VIRTUAL TABLE&quot; statement used to create the FTS4 table.</source>
          <target state="translated">对于每一列来说,存储在FTS4表当前行中的值的长度,以令牌为单位。这个值只有在查询FTS4表时才有,而不是FTS3表。而且只有当 &quot;matchinfo=fts3 &quot;指令没有被指定为用于创建FTS4表的 &quot;CREATE VIRTUAL TABLE &quot;语句的一部分时,才可以使用。</target>
        </trans-unit>
        <trans-unit id="6e8b6483ba6be5818f8c523c79ce85a1e7ccc3ba" translate="yes" xml:space="preserve">
          <source>For each distinct combination of a phrase and table column, the following three values:</source>
          <target state="translated">对于每一个不同的短语和表列组合,以下三个值:</target>
        </trans-unit>
        <trans-unit id="cf92fe281dadfcf306551aea2a8a2fccc4c37192" translate="yes" xml:space="preserve">
          <source>For each distinct combination of a phrase and table column, the number of usable phrase matches that appear in the column. This is usually identical to the first value in each set of three returned by the &lt;a href=&quot;fts3#matchinfo-x&quot; id=&quot;matchinfo-y&quot;&gt;matchinfo 'x' flag&lt;/a&gt;. However, the number of hits reported by the 'y' flag is zero for any phrase that is part of a sub-expression that does not match the current row. This makes a difference for expressions that contain AND operators that are descendants of OR operators. For example, consider the expression:</source>
          <target state="translated">对于短语和表格列的每个不同组合，列中出现的可用短语匹配数。通常与&lt;a href=&quot;fts3#matchinfo-x&quot; id=&quot;matchinfo-y&quot;&gt;matchinfo'x'标志&lt;/a&gt;返回的每三个一组中的第一个值相同。但是，对于属于与当前行不匹配的子表达式一部分的任何短语，&amp;ldquo; y&amp;rdquo;标志报告的命中数为零。这对于包含作为OR运算符后代的AND运算符的表达式有所不同。例如，考虑以下表达式：</target>
        </trans-unit>
        <trans-unit id="fffbd38440022e9244e6e0693275b0d19d1857ad" translate="yes" xml:space="preserve">
          <source>For each modified table, a changeset includes the following:</source>
          <target state="translated">对于每个修改后的表格,变更集包括以下内容:</target>
        </trans-unit>
        <trans-unit id="a24f08d30b83fb31d42fefd2e7c6a4eb2dab4115" translate="yes" xml:space="preserve">
          <source>For each pair of columns identified by a USING clause, the column from the right-hand dataset is omitted from the joined dataset. This is the only difference between a USING clause and its equivalent ON constraint.</source>
          <target state="translated">对于USING子句确定的每一对列,右侧数据集中的列会从加入的数据集中省略。这是USING子句和其等价的ON约束之间的唯一区别。</target>
        </trans-unit>
        <trans-unit id="9c5c3e6a930debab2d5dd5b538d4a23999481e17" translate="yes" xml:space="preserve">
          <source>For each primary key recorded as a result of an INSERT operation, the sessions module checks if there is a row with a matching primary key still in the table. If so, an INSERT change is added to the changeset.</source>
          <target state="translated">对于作为INSERT操作结果而记录的每个主键,会话模块会检查表中是否仍有一条与主键匹配的记录。如果有,则会将一个INSERT更改添加到更改集中。</target>
        </trans-unit>
        <trans-unit id="829855e999389ecdd1577f6b633317b639cef854" translate="yes" xml:space="preserve">
          <source>For each primary key recorded as a result of an UPDATE or DELETE operation, the sessions module also checks for a row with a matching primary key within the table. If one can be found, but one or more of the non-PRIMARY KEY fields does not match the original recorded value, an UPDATE is added to the changeset. Or, if there is no row at all with the specified primary key, a DELETE is added to the changeset. If the row does exist but none of the non-PRIMARY KEY fields have been modified, no change is added to the changeset.</source>
          <target state="translated">对于作为UPDATE或DELETE操作的结果而记录的每个主键,会话模块也会检查表内是否有匹配主键的行。如果可以找到一个,但一个或多个非主键字段与原始记录的值不匹配,则会将UPDATE添加到更改集中。或者,如果根本就没有指定主键的记录,那么一个DELETE将被添加到变化集中。如果该行确实存在,但非主键字段都没有被修改,则不会向更改集添加任何更改。</target>
        </trans-unit>
        <trans-unit id="d07e7398b3da8e6434d5c2443839062a6f35040b" translate="yes" xml:space="preserve">
          <source>For each record generated by an insert, the database is queried for a row with a matching primary key. If one is found, an INSERT change is added to the changeset. If no such row is found, no change is added to the changeset.</source>
          <target state="translated">对于插入生成的每一条记录,数据库都会被查询到一条具有匹配主键的记录。如果找到了,就会在变化集中添加INSERT变化。如果没有找到这样的记录,则不会在变化集中添加任何变化。</target>
        </trans-unit>
        <trans-unit id="9651a17487870ac448b95f61451215a9e031bca7" translate="yes" xml:space="preserve">
          <source>For each record generated by an update or delete, the database is queried for a row with a matching primary key. If such a row is found and one or more of the non-primary key fields have been modified from their original values, an UPDATE change is added to the changeset. Or, if no such row is found in the table, a DELETE change is added to the changeset. If there is a row with a matching primary key in the database, but all fields contain their original values, no change is added to the changeset.</source>
          <target state="translated">对于更新或删除所产生的每一条记录,数据库都会被查询到一条具有匹配主键的记录。如果找到了这样的一行,并且一个或多个非主键字段已经从它们的原始值中被修改,则会向变更集添加UPDATE变更。或者,如果在表中没有找到这样的记录,那么一个DELETE变更将被添加到变更集中。如果在数据库中有一条与主键相匹配的记录,但是所有的字段都包含了它们的原始值,那么就不会对更改集添加任何更改。</target>
        </trans-unit>
        <trans-unit id="1d85944e801be901ece01bab4a06681779097370" translate="yes" xml:space="preserve">
          <source>For each record in the first table, do:</source>
          <target state="translated">对于第一张表中的每条记录,要:</target>
        </trans-unit>
        <trans-unit id="db1b960f818a6af8cfaa2c24a19e780d2703af81" translate="yes" xml:space="preserve">
          <source>For each record in the second table do:</source>
          <target state="translated">对于第二张表中的每一条记录,都要:</target>
        </trans-unit>
        <trans-unit id="07832e91f880502fa8c96087f4d7417bdd043461" translate="yes" xml:space="preserve">
          <source>For each record in the table, do:</source>
          <target state="translated">对于表中的每一条记录,要做到:</target>
        </trans-unit>
        <trans-unit id="87586acdd8d3aae53c73008136985fcb94271fa7" translate="yes" xml:space="preserve">
          <source>For each row (primary key) that exists in both tables, but features different non-PK values in each, an UPDATE record is added to the session.</source>
          <target state="translated">对于存在于两个表中,但在每个表中具有不同的非PK值的每一行(主键),都会向会话添加一条UPDATE记录。</target>
        </trans-unit>
        <trans-unit id="6b65ebd60d0a165260cae83ea942ac1bc3113efb" translate="yes" xml:space="preserve">
          <source>For each row (primary key) that exists in the to-table but not in the from-table, a DELETE record is added to the session object.</source>
          <target state="translated">对于存在于to-table中但不存在于from-table中的每一条记录(主键),会向session对象添加一条DELETE记录。</target>
        </trans-unit>
        <trans-unit id="9d14fe0322a1c66d129265052088ccffec38ab12" translate="yes" xml:space="preserve">
          <source>For each row (primary key) that exists in the to-table but not in the from-table, an INSERT record is added to the session object.</source>
          <target state="translated">对于存在于to-table中但不存在于from-table中的每一条记录(主键),都会向session对象添加一条INSERT记录。</target>
        </trans-unit>
        <trans-unit id="cf4da03b9da8c161d1cf42bd495a3368247989f4" translate="yes" xml:space="preserve">
          <source>For each row in the FTS table, the %_docsize table contains a corresponding row with the same &quot;docid&quot; value. The &quot;size&quot; field contains a blob consisting of</source>
          <target state="translated">对于FTS表中的每一条记录,%_docsize表中都包含一条对应的具有相同 &quot;docid &quot;值的记录。&quot;size &quot;字段包含一个由以下内容组成的blob</target>
        </trans-unit>
        <trans-unit id="a8c233269c53521f30c5ffc0bf77144b7402512d" translate="yes" xml:space="preserve">
          <source>For each row to DELETE from the target database as part of the RBU update, the corresponding data_% table should contain a single record with the &quot;rbu_control&quot; column set to contain integer value 1. The real primary key values of the row to delete should be stored in the corresponding columns of the data_% table. The values stored in the other columns are not used.</source>
          <target state="translated">作为 RBU 更新的一部分,对于要从目标数据库中 DELETE 的每一条记录,相应的 data_% 表应该包含一条记录,&quot;rbu_control &quot;列设置为包含整数值 1。要删除的行的真实主键值应该存储在data_%表的相应列中。存储在其他列中的值不被使用。</target>
        </trans-unit>
        <trans-unit id="6a5706b24e2b237dcb339a0ad1090fb73a23781f" translate="yes" xml:space="preserve">
          <source>For each row to INSERT into the target database as part of the RBU update, the corresponding data_% table should contain a single record with the &quot;rbu_control&quot; column set to contain integer value 0. The other columns should be set to the values that make up the new record to insert.</source>
          <target state="translated">对于作为 RBU 更新的一部分而要 INSERT 到目标数据库中的每一条记录,相应的 data_% 表应该包含一条记录,&quot;rbu_control &quot;列设置为包含整数值 0。其他列应设置为构成要插入的新记录的值。</target>
        </trans-unit>
        <trans-unit id="34669c17538b482482cba6957b264502d60d1060" translate="yes" xml:space="preserve">
          <source>For each row to UPDATE from the target database as part of the RBU update, the corresponding data_% table should contain a single record with the &quot;rbu_control&quot; column set to contain a value of type text. The real primary key values identifying the row to update should be stored in the corresponding columns of the data_% table row, as should the new values of all columns being update. The text value in the &quot;rbu_control&quot; column must contain the same number of characters as there are columns in the target database table, and must consist entirely of 'x' and '.' characters (or in some special cases 'd' - see below). For each column that is being updated, the corresponding character is set to 'x'. For those that remain as they are, the corresponding character of the rbu_control value should be set to '.'. For example, given the tables above, the update statement:</source>
          <target state="translated">作为 RBU 更新的一部分,对于要从目标数据库中 UPDATE 的每一条记录,相应的 data_% 表应该包含一条单条记录,&quot;rbu_control &quot;列设置为包含一个类型为文本的值。确定要更新的行的真实主键值应该存储在data_%表行的相应列中,所有被更新的列的新值也应该存储在其中。&quot;rbu_control &quot;列中的文本值必须包含与目标数据库表中的列相同数量的字符,并且必须完全由'x'和'.'字符组成(或者在某些特殊情况下是'd'--见下文)。对于每一个被更新的列,对应的字符都设置为'x'。对于那些保持原样的列,rbu_control值的相应字符应设置为'.'。例如,给定上面的表格,更新语句。</target>
        </trans-unit>
        <trans-unit id="a430b6812c406e37a693a08685ab05caa617b118" translate="yes" xml:space="preserve">
          <source>For each such constraint, the aConstraint[].iColumn field indicates which column appears on the left-hand side of the constraint. The first column of the virtual table is column 0. The rowid of the virtual table is column -1. The aConstraint[].op field indicates which operator is used. The SQLITE_INDEX_CONSTRAINT_* constants map integer constants into operator values. Columns occur in the order they were defined by the call to &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; in the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; or &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method. Hidden columns are counted when determining the column index.</source>
          <target state="translated">对于每个这样的约束，aConstraint []。iColumn字段指示哪一列出现在约束的左侧。虚拟表的第一列是列0。虚拟表的rowid是列-1。 aConstraint []。op字段指示使用哪个运算符。 SQLITE_INDEX_CONSTRAINT_ *常数将整数常数映射为运算符值。列按照在&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;或&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;方法中对&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt;的调用所定义的顺序出现。确定列索引时，将对隐藏的列进行计数。</target>
        </trans-unit>
        <trans-unit id="f5aad29ac204438525f336e09bd7bc093d292717" translate="yes" xml:space="preserve">
          <source>For each table in the target database that will be modified by the update, a corresponding table is created within the RBU database. The RBU database table schema is not the same as that of the target database, but is derived from it as &lt;a href=&quot;rbu#database_tables&quot;&gt;described below&lt;/a&gt;.</source>
          <target state="translated">对于目标数据库中将通过更新进行修改的每个表，都会在RBU数据库中创建一个对应的表。RBU数据库表架构与目标数据库的架构不同，但如下&lt;a href=&quot;rbu#database_tables&quot;&gt;所述&lt;/a&gt;是从其派生的。</target>
        </trans-unit>
        <trans-unit id="f11dacd70a0954440fff36de5fbb6ca308465c38" translate="yes" xml:space="preserve">
          <source>For each table in the target database, the RBU database should contain a table named &quot;data&amp;lt;</source>
          <target state="translated">对于目标数据库中的每个表，RBU数据库应包含一个名为&amp;ldquo; data &amp;lt;</target>
        </trans-unit>
        <trans-unit id="42f788bf7b6ac170ed8ce05feddfec2cba592bef" translate="yes" xml:space="preserve">
          <source>For each table read by the query, the output of EXPLAIN QUERY PLAN includes a record for which the value in the &quot;detail&quot; column begins with either &quot;SCAN&quot; or &quot;SEARCH&quot;. &quot;SCAN&quot; is used for a full-table scan, including cases where SQLite iterates through all records in a table in an order defined by an index. &quot;SEARCH&quot; indicates that only a subset of the table rows are visited. Each SCAN or SEARCH record includes the following information:</source>
          <target state="translated">对于查询读取的每个表,EXPLAIN QUERY PLAN的输出包括一条记录,该记录的 &quot;详细 &quot;列中的值以 &quot;SCAN &quot;或 &quot;SEARCH &quot;开头。&quot;SCAN &quot;用于全表扫描,包括SQLite按照索引定义的顺序遍历表中所有记录的情况。&quot;SEARCH &quot;表示只访问表行的子集。每个SCAN或SEARCH记录都包括以下信息。</target>
        </trans-unit>
        <trans-unit id="ecba2625cd566548c3eee164f8360eb376f2aaad" translate="yes" xml:space="preserve">
          <source>For each table that is not excluded by the filter callback, this function tests that the target database contains a compatible table. A table is considered compatible if all of the following are true:</source>
          <target state="translated">对于每个没有被过滤器回调排除的表,这个函数测试目标数据库是否包含一个兼容表。如果以下情况全部为真,则认为一个表是兼容的。</target>
        </trans-unit>
        <trans-unit id="a67fb3e6d59fc22a676badf1b731424e48e59895" translate="yes" xml:space="preserve">
          <source>For each term in a document, the FTS index maintained by FTS5 stores the rowid of the document, the column number of the column that contains the term and the offset of the term within the column value. The &quot;detail&quot; option may be used to omit some of this information. This reduces the space that the index consumes within the database file, but also reduces the capability and efficiency of the system.</source>
          <target state="translated">对于文档中的每个术语,由FTS5维护的FTS索引存储了文档的行号、包含术语的列号以及术语在列值中的偏移量。可以使用 &quot;详细 &quot;选项来省略其中的一些信息。这样可以减少索引在数据库文件中占用的空间,但也降低了系统的能力和效率。</target>
        </trans-unit>
        <trans-unit id="ec159e8f6dc1a68285f736b240d086ca832050e3" translate="yes" xml:space="preserve">
          <source>For each term present in the FTS table, there are between 2 and N+1 rows in the fts4aux table, where N is the number of user-defined columns in the associated FTS table. An fts4aux table always has the same four columns, as follows, from left to right:</source>
          <target state="translated">对于FTS表中的每一个术语,fts4aux表中有2至N+1行,其中N是相关FTS表中用户定义的列数。fts4aux表的四列总是相同的,从左到右如下:</target>
        </trans-unit>
        <trans-unit id="2bdf0037f493d99e63f11ef023d4ede2161885e4" translate="yes" xml:space="preserve">
          <source>For each token in the input string, the supplied callback xToken() must be invoked. The first argument to it should be a copy of the pointer passed as the second argument to xTokenize(). The third and fourth arguments are a pointer to a buffer containing the token text, and the size of the token in bytes. The 4th and 5th arguments are the byte offsets of the first byte of and first byte immediately following the text from which the token is derived within the input.</source>
          <target state="translated">对于输入字串中的每一个token,都必须调用回调xToken(),它的第一个参数应该是xTokenize()的第二个参数所传递的指针的副本。它的第一个参数应该是传递给xTokenize()的第二个参数的指针的副本,第三个和第四个参数是指向包含token文本的缓冲区的指针,以及token的大小。第三个和第四个参数是指向包含token文本的缓冲区的指针,以及token的字节数。第4个和第5个参数是输入中令牌文字的第一个字节和紧接着的第一个字节的字节偏移量。</target>
        </trans-unit>
        <trans-unit id="77d69c67e1a2a185641c2031933b357307710ee5" translate="yes" xml:space="preserve">
          <source>For each token in the text fragment that is part of a phrase match, the &quot;start match&quot; text is inserted into the fragment before the token, and the &quot;end match&quot; text is inserted immediately after it.</source>
          <target state="translated">对于文本片段中属于短语匹配的每个标记,&quot;开始匹配 &quot;的文本插入到标记之前的片段中,而 &quot;结束匹配 &quot;的文本则紧随其后插入。</target>
        </trans-unit>
        <trans-unit id="4d08b18694ad651bc6411787c4cb9cda3d56703c" translate="yes" xml:space="preserve">
          <source>For embedded systems, consider compiling SQLite with the &lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt; option and then providing SQLite with a fixed chunk of memory to use as its heap via the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;) interface. This will prevent malicious SQL from executing a denial-of-service attack by using an excessive amount of memory. If (say) 5 MB of memory is provided for SQLite to use, once that much has been consumed, SQLite will start returning SQLITE_NOMEM errors rather than soaking up memory needed by other parts of the application. This also sandboxes SQLite's memory so that a write-after-free error in some other part of the application will not cause problems for SQLite, or vice versa.</source>
          <target state="translated">对于嵌入式系统，请考虑使用&lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt;选项编译SQLite，然后通过&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;）接口为SQLite提供固定的内存块以用作其堆。这将防止恶意SQL通过使用过多的内存来执行拒绝服务攻击。如果（例如）提供了5 MB的内存供SQLite使用，那么一旦消耗了这么多内存，SQLite将开始返回SQLITE_NOMEM错误，而不是占用应用程序其他部分所需的内存。这也将SQLite的内存沙箱化，以使应用程序其他部分的写后写错误不会对SQLite造成问题，反之亦然。</target>
        </trans-unit>
        <trans-unit id="4c5274d9826ac0360165a29a3e66a8506f1ab799" translate="yes" xml:space="preserve">
          <source>For every successful call to this method, the SQLite core will later invoke the &lt;a href=&quot;vtab#xclose&quot;&gt;xClose&lt;/a&gt; method to destroy the allocated cursor.</source>
          <target state="translated">对于此方法的每次成功调用，SQLite核心稍后都会调用&lt;a href=&quot;vtab#xclose&quot;&gt;xClose&lt;/a&gt;方法来销毁分配的游标。</target>
        </trans-unit>
        <trans-unit id="c6c48664cbefae23df70df3591300d92263e5f4c" translate="yes" xml:space="preserve">
          <source>For example to find the highest paid employee:</source>
          <target state="translated">比如要找工资最高的员工。</target>
        </trans-unit>
        <trans-unit id="2479f1e642da058be56d1001ffac81d069a0ba6c" translate="yes" xml:space="preserve">
          <source>For example, a &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; statement cannot be run while another thread is reading from that table on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; because dropping the table would delete the table out from under the concurrent reader.</source>
          <target state="translated">例如，当另一个线程正在同一&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;上从该表读取数据时，不能运行&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;语句，因为删除该表会从并发阅读器下面删除该表。</target>
        </trans-unit>
        <trans-unit id="6761f7f398c5e173f6115ef00ea11329cb9f3d54" translate="yes" xml:space="preserve">
          <source>For example, a query like the following might be used to find all R*Tree entries that overlap with a circle centered a 45.3,22.9 with a radius of 5.0:</source>
          <target state="translated">例如,像下面这样的查询可以用来查找所有与半径为5.0、以45.3、22.9为中心的圆重合的R*Tree条目。</target>
        </trans-unit>
        <trans-unit id="42fbeb339bf81a5c29e36447b781a19ea1d40440" translate="yes" xml:space="preserve">
          <source>For example, adding an &quot;ON UPDATE CASCADE&quot; clause to the foreign key as shown below enhances the example schema from section 1 to allow the user to update the artistid (the parent key of the foreign key constraint) column without breaking referential integrity:</source>
          <target state="translated">例如,在外键中添加一个 &quot;ON UPDATE CASCADE &quot;子句,如下图所示,增强了第1节中的示例模式,允许用户在不破坏引用完整性的情况下更新 artistid(外键约束的父键)列。</target>
        </trans-unit>
        <trans-unit id="68a7b041107b28bf1e4e9feea5241e1ae83cb4f3" translate="yes" xml:space="preserve">
          <source>For example, as currently implemented, if writes are happening at a steady stream that exceeds the I/O capability of the background writer thread, the queue of pending write operations will grow without bound. If this goes on for long enough, the host system could run out of memory. A more sophisticated module could to keep track of the quantity of pending writes and stop accepting new write requests when the queue of pending writes grows too large.</source>
          <target state="translated">例如,按照目前的实现方式,如果写操作以稳定的流发生,超过了后台写线程的I/O能力,那么待写操作的队列就会无限制地增长。如果这种情况持续的时间足够长,主机系统可能会耗尽内存。一个更复杂的模块可以跟踪待写数量,并在待写队列增长过大时停止接受新的写请求。</target>
        </trans-unit>
        <trans-unit id="74530ffba7f866870009106e3c8e5c0a0af944ca" translate="yes" xml:space="preserve">
          <source>For example, given the database schema:</source>
          <target state="translated">例如,给定数据库模式:</target>
        </trans-unit>
        <trans-unit id="c7f52cca71f3aa80082462a01861b0a720f46594" translate="yes" xml:space="preserve">
          <source>For example, if a prepared statement is created using the SQL text &quot;SELECT $abc,:xyz&quot; and if parameter $abc is bound to integer 2345 and parameter :xyz is unbound, then sqlite3_sql() will return the original string, &quot;SELECT $abc,:xyz&quot; but sqlite3_expanded_sql() will return &quot;SELECT 2345,NULL&quot;.</source>
          <target state="translated">例如,如果使用SQL文本 &quot;SELECT $abc,:xyz &quot;创建一条准备好的语句,如果参数$abc绑定为整数2345,而参数:xyz未绑定,那么sqlite3_sql()将返回原始字符串 &quot;SELECT $abc,:xyz&quot;,但sqlite3_expanded_sql()将返回 &quot;SELECT 2345,NULL&quot;。</target>
        </trans-unit>
        <trans-unit id="06bed93067ff2c82141c677c5fde8b31f46e4d93" translate="yes" xml:space="preserve">
          <source>For example, if both the local and remote changesets contain an INSERT of the same key on &quot;CREATE TABLE t1(a PRIMARY KEY, b)&quot;:</source>
          <target state="translated">例如,如果本地和远程的变化集都包含了 &quot;CREATE TABLE t1(a PRIMARY KEY,b)&quot;上的同一个键的INSERT。</target>
        </trans-unit>
        <trans-unit id="336ff6fc840939163a24ab8fbcfd1876f5d7462b" translate="yes" xml:space="preserve">
          <source>For example, if each of the 517430 documents in the &quot;&lt;a href=&quot;http://www.cs.cmu.edu/~enron/&quot;&gt;Enron E-Mail Dataset&lt;/a&gt;&quot; is inserted into both an FTS table and an ordinary SQLite table created using the following SQL script:</source>
          <target state="translated">例如，如果&amp;ldquo; &lt;a href=&quot;http://www.cs.cmu.edu/~enron/&quot;&gt;安然电子邮件数据集&lt;/a&gt; &amp;rdquo; 中的每个517430文档都插入到FTS表和使用以下SQL脚本创建的普通SQLite表中：</target>
        </trans-unit>
        <trans-unit id="222fc77f6c6ce0e830f1e02e033d3b69e1488c52" translate="yes" xml:space="preserve">
          <source>For example, if each of the 517430 documents in the &quot;&lt;a href=&quot;https://www.cs.cmu.edu/~enron/&quot;&gt;Enron E-Mail Dataset&lt;/a&gt;&quot; is inserted into both an FTS table and an ordinary SQLite table created using the following SQL script:</source>
          <target state="translated">例如，如果&amp;ldquo;&lt;a href=&quot;https://www.cs.cmu.edu/~enron/&quot;&gt;安然电子邮件数据集&lt;/a&gt;&amp;rdquo;中的每个517430文档都插入到FTS表和使用以下SQL脚本创建的普通SQLite表中：</target>
        </trans-unit>
        <trans-unit id="9af2b0a0be2507f901ab349b61afc42441edaa60" translate="yes" xml:space="preserve">
          <source>For example, if nCol is the number of columns in the table, to determine if phrase p is present in column c:</source>
          <target state="translated">例如,如果nCol是表中的列数,判断短语p是否存在于列c中。</target>
        </trans-unit>
        <trans-unit id="4ff402b57bb3c7de072fb37615e2f1f44b822435" translate="yes" xml:space="preserve">
          <source>For example, if process A is in the middle of a large write transaction and at the same time process B attempts to start a new write transaction, process B will get back an SQLITE_BUSY result because SQLite only supports one writer at a time. Process B will need to wait for process A to finish its transaction before starting a new transaction. The &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; and &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt; interfaces and the &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;busy_timeout pragma&lt;/a&gt; are available to process B to help it deal with SQLITE_BUSY errors.</source>
          <target state="translated">例如，如果进程A在大型写事务中，并且进程B同时尝试启动新的写事务，则进程B将返回SQLITE_BUSY结果，因为SQLite一次仅支持一个写程序。进程B将需要等待进程A完成其事务，然后才能开始新事务。该&lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;和&lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler（）&lt;/a&gt;接口和&lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;busy_timeout编译&lt;/a&gt;可用来，以帮助它处理SQLITE_BUSY错误进程B。</target>
        </trans-unit>
        <trans-unit id="d347b5f74f99e1b9952eb3244ae0159feff20d3e" translate="yes" xml:space="preserve">
          <source>For example, if the</source>
          <target state="translated">例如,如果</target>
        </trans-unit>
        <trans-unit id="c3622449954a6635d6d6221d72610b7472bd6c7b" translate="yes" xml:space="preserve">
          <source>For example, if the aConstraint[3].argvIndex is set to 1, then when xFilter is called, the argv[0] passed to xFilter will have the EXPR value of the aConstraint[3] constraint.</source>
          <target state="translated">例如,如果将aConstraint[3].argvIndex设置为1,那么当xFilter被调用时,传递给xFilter的argv[0]将具有aConstraint[3]约束的EXPR值。</target>
        </trans-unit>
        <trans-unit id="7f637c26bc4431eea662487596dfe6901f17e071" translate="yes" xml:space="preserve">
          <source>For example, if the following SQL is passed to &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt;:</source>
          <target state="translated">例如，如果将以下SQL传递给&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="9d9a182c3de2bb26679903dabe753f3a90f09588" translate="yes" xml:space="preserve">
          <source>For example, if you have a table column declared to be of type &quot;INTEGER&quot; and you try to insert a string, the column will look at the text string and see if it looks like a number. If the string does look like a number it is converted into a number and into an integer if the number does not have a fractional part, and stored that way. But if the string is not a well-formed number it is still stored as a string. A column with a type of &quot;TEXT&quot; tries to convert numbers into an ASCII-Text representation before storing them. But BLOBs are stored in TEXT columns as BLOBs because you cannot in general convert a BLOB into text.</source>
          <target state="translated">例如,如果你有一个表列声明类型为 &quot;INTEGER&quot;,你尝试插入一个字符串,该列将查看文本字符串,看看它是否看起来像一个数字。如果字符串看起来确实像一个数字,它就会被转换成一个数字,如果这个数字没有小数部分,就会转换成一个整数,并以这种方式存储。但如果字符串不是一个格式良好的数字,它仍然会被存储为一个字符串。类型为 &quot;TEXT &quot;的列在存储前会尝试将数字转换为ASCII-文本表示。但BLOB在TEXT列中是作为BLOB存储的,因为一般情况下不能将BLOB转换为文本。</target>
        </trans-unit>
        <trans-unit id="2e8d78d9a4a4ef5a078d77893775dee024ca144a" translate="yes" xml:space="preserve">
          <source>For example, in gdb, to see the complete hierarchy of an Expr node (that is to say, the Expr node and all of its children), given a pointer &quot;pExpr&quot; to that node, type:</source>
          <target state="translated">例如,在gdb中,要查看一个Expr节点的完整层次结构(也就是说,Expr节点及其所有子节点),给定一个指向该节点的指针 &quot;pExpr&quot;,类型。</target>
        </trans-unit>
        <trans-unit id="65de8cd85e7f9352044ea42fa34fc26263f7d653" translate="yes" xml:space="preserve">
          <source>For example, in the following call to json_object(), the</source>
          <target state="translated">例如,在以下对json_object()的调用中,在</target>
        </trans-unit>
        <trans-unit id="376c3a63c2d900eda2a882017f3f3a33aef34667" translate="yes" xml:space="preserve">
          <source>For example, information about the columns in an index can be read using the &lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_info pragma&lt;/a&gt; as follows:</source>
          <target state="translated">例如，可以使用&lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_info杂指令&lt;/a&gt;读取有关索引中列的信息，如下所示：</target>
        </trans-unit>
        <trans-unit id="6bccea8458a0de711e349540a29ecfcb98a65f40" translate="yes" xml:space="preserve">
          <source>For example, let the index be</source>
          <target state="translated">例如,让指数为</target>
        </trans-unit>
        <trans-unit id="3da423bea60d2f28b9bd6c6b606ccc9294140d5b" translate="yes" xml:space="preserve">
          <source>For example, many words of Greek origin begin with letters &quot;ps&quot; where the &quot;p&quot; is silent. Ex: psalm, pseudonym, psoriasis, psyche. In another example, many Scottish surnames can be spelled with an initial &quot;Mac&quot; or &quot;Mc&quot;. Thus, &quot;MacKay&quot; and &quot;McKay&quot; are both pronounced the same.</source>
          <target state="translated">例如,许多源自希腊的单词以字母 &quot;ps &quot;开头,其中 &quot;p &quot;是无声的。例:psalm,pseudonym,psoriasis,psyche。又如,许多苏格兰的姓氏可以用首字母 &quot;Mac &quot;或 &quot;Mc &quot;来拼写。因此,&quot;MacKay &quot;和 &quot;McKay &quot;的发音都是一样的。</target>
        </trans-unit>
        <trans-unit id="20083fcfe31a171e687fd7f98763b1bd15a6a1ec" translate="yes" xml:space="preserve">
          <source>For example, say the SQL statement returns the following data when executed:</source>
          <target state="translated">例如,假设SQL语句执行时返回以下数据。</target>
        </trans-unit>
        <trans-unit id="2fbaaa7d12d4edb21ff19c0963b0289115f32a55" translate="yes" xml:space="preserve">
          <source>For example, suppose an additional database is attached to the database connection using a statement like this:</source>
          <target state="translated">例如,假设使用这样的语句在数据库连接上附加一个额外的数据库。</target>
        </trans-unit>
        <trans-unit id="81c47bbba7e6d3bcfa83f9d58601629924b27df8" translate="yes" xml:space="preserve">
          <source>For example, suppose the input word is &quot;Paskagula&quot;. The phonetic key is &quot;BACACALA&quot; which is then truncated to 4 characters &quot;BACA&quot;. The edit distance is then run on the 4980 entries (out of 272,597 entries total) of the vocabulary whose k2 values begin with BACA, yielding &quot;Pascagoula&quot; as the best match.</source>
          <target state="translated">例如,假设输入的单词是 &quot;Paskagula&quot;,那么拼音键就是 &quot;BACACALA&quot;,然后截断4个字符 &quot;BACA&quot;。语音键是 &quot;BACACALA&quot;,然后截断为4个字符 &quot;BACA&quot;。然后在词汇库中的4980个词条(总共272,597个词条中)上运行编辑距离,其k2值以BACA开头,得出 &quot;Pascagoula &quot;为最佳匹配。</target>
        </trans-unit>
        <trans-unit id="bd462d6a706c77e5432cc4b960d8cc42361a6e96" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a database of the members of a large organization where each person is assigned to a particular &quot;team&quot;. Each team has a &quot;leader&quot; who is also a member of that team. The table might look something like this:</source>
          <target state="translated">例如,假设你有一个大型组织成员的数据库,每个人被分配到一个特定的 &quot;团队&quot;。每个团队都有一个 &quot;领导者&quot;,他也是该团队的成员。这个表可能看起来像这样。</target>
        </trans-unit>
        <trans-unit id="2d2ab8533e293c8a84090c9b6694f2a969c007bb" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a table named &quot;t1&quot; with columns names &quot;a&quot;, &quot;b&quot;, and &quot;c&quot; and that you want to delete column &quot;c&quot; from this table. The following steps illustrate how this could be done:</source>
          <target state="translated">例如,假设你有一个名为 &quot;t1 &quot;的表,其列名为 &quot;a&quot;、&quot;b &quot;和 &quot;c&quot;,你想从这个表中删除列 &quot;c&quot;。下面的步骤说明了如何做到这一点。</target>
        </trans-unit>
        <trans-unit id="e8c74e845df3aa4e4554ece864cf2478aa417801" translate="yes" xml:space="preserve">
          <source>For example, suppose you wanted undo/redo on a class (table) that looks like this:</source>
          <target state="translated">例如,假设你想在一个类(表)上进行撤消/重做,它看起来像这样。</target>
        </trans-unit>
        <trans-unit id="c888ac7552fad64c94327f4d9dde6c1939c79ffa" translate="yes" xml:space="preserve">
          <source>For example, the &quot;generate_series&quot; extension (located in the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/series.c&quot;&gt;ext/misc/series.c&lt;/a&gt; file in the &lt;a href=&quot;http://www.sqlite.org/src/tree?ci=trunk&quot;&gt;source tree&lt;/a&gt;) implements an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; with the following schema:</source>
          <target state="translated">例如，&amp;ldquo; generate_series&amp;rdquo;扩展名（位于&lt;a href=&quot;http://www.sqlite.org/src/tree?ci=trunk&quot;&gt;源树&lt;/a&gt;的&lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/series.c&quot;&gt;ext / misc / series.c&lt;/a&gt;文件中）使用以下模式实现了&lt;a href=&quot;vtab#epovtab&quot;&gt;同名虚拟表&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="920bdbd542734e5cedbecb73c3763d3f53b57988" translate="yes" xml:space="preserve">
          <source>For example, the &quot;generate_series&quot; extension (located in the &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/series.c&quot;&gt;ext/misc/series.c&lt;/a&gt; file in the &lt;a href=&quot;https://www.sqlite.org/src/tree?ci=trunk&quot;&gt;source tree&lt;/a&gt;) implements an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; with the following schema:</source>
          <target state="translated">例如，&amp;ldquo; generate_series&amp;rdquo;扩展名（位于&lt;a href=&quot;https://www.sqlite.org/src/tree?ci=trunk&quot;&gt;源树&lt;/a&gt;的&lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/series.c&quot;&gt;ext / misc / series.c&lt;/a&gt;文件中）使用以下模式实现了&lt;a href=&quot;vtab#epovtab&quot;&gt;同名虚拟表&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="a41d4a0a2c571159c4d3d9a9bcfe397816127e93" translate="yes" xml:space="preserve">
          <source>For example, the first argument to the &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt; function is supposed to be a special column of the FTS3 table that contains a pointer to an fts3cursor object that contains information about the current full text search match. That pointer was formerly passed as a BLOB. For example, if the FTS3 table is named &quot;t1&quot; and has a column named &quot;cx&quot;, one might write:</source>
          <target state="translated">例如，&lt;a href=&quot;fts3#snippet&quot;&gt;snippet（）&lt;/a&gt;函数的第一个参数应该是FTS3表的特殊列，其中包含指向fts3cursor对象的指针，该对象包含有关当前全文本搜索匹配的信息。该指针以前是作为BLOB传递的。例如，如果FTS3表的名称为&amp;ldquo; t1&amp;rdquo;，并且有一列的名称为&amp;ldquo; cx&amp;rdquo;，则可能会这样写：</target>
        </trans-unit>
        <trans-unit id="a1719c0fad0c46d95494599fc76472814afb3096" translate="yes" xml:space="preserve">
          <source>For example, the following EXPLAIN QUERY PLAN command operates on a SELECT statement that is implemented by performing a full-table scan on table t1:</source>
          <target state="translated">例如,下面的EXPLAIN QUERY PLAN命令对SELECT语句进行操作,该语句通过对表t1进行全表扫描来实现。</target>
        </trans-unit>
        <trans-unit id="f54bfe9858a294d74efc1029b390f83e76127bc5" translate="yes" xml:space="preserve">
          <source>For example, the following JSON describes an isosceles triangle, sitting on the X axis and with an area of 0.5:</source>
          <target state="translated">例如,以下JSON描述了一个等腰三角形,位于X轴上,面积为0.5。</target>
        </trans-unit>
        <trans-unit id="83a6fbeea816f56be60daf62a9ac68c383f63398" translate="yes" xml:space="preserve">
          <source>For example, the following code implements a collating sequence called &quot;NOCASE&quot; that sorts in text order without regard to case:</source>
          <target state="translated">例如,下面的代码实现了一个名为 &quot;NOCASE &quot;的整理序列,它不考虑大小写,按文本顺序进行排序。</target>
        </trans-unit>
        <trans-unit id="9c27a0d3845f1eceb95943662637d42bbbaddf2a" translate="yes" xml:space="preserve">
          <source>For example, the following statement is valid in SQLite:</source>
          <target state="translated">例如,以下语句在SQLite中有效。</target>
        </trans-unit>
        <trans-unit id="c949165d26ebc110da68da66e13bc86685e04c18" translate="yes" xml:space="preserve">
          <source>For example, the values NULL, 0.0, 0, 'english' and '0' are all considered to be false. Values 1, 1.0, 0.1, -0.1 and '1english' are considered to be true.</source>
          <target state="translated">例如,值NULL、0.0、0、'english'和'0'都被认为是假的。值1、1.0、0.1、-0.1和'1english'被认为是真。</target>
        </trans-unit>
        <trans-unit id="a80abcae23d48d4d5c71b5964b931b771a14df0d" translate="yes" xml:space="preserve">
          <source>For example, this row:</source>
          <target state="translated">比如说,这一行。</target>
        </trans-unit>
        <trans-unit id="f0774215613f5a93e554bf719be214f376054f20" translate="yes" xml:space="preserve">
          <source>For example, to avoid adding the contents of the &quot;uuid&quot; field to the FTS index:</source>
          <target state="translated">例如,为了避免将 &quot;uuid &quot;字段的内容添加到FTS索引中。</target>
        </trans-unit>
        <trans-unit id="e25e9fcbc6cbbe4aa86a860fba9ee3e23406906c" translate="yes" xml:space="preserve">
          <source>For example, to create a new SQLite database named &quot;ex1&quot; with a single table named &quot;tbl1&quot;, you might do this:</source>
          <target state="translated">例如,要创建一个名为 &quot;ex1 &quot;的新SQLite数据库,其中有一个名为 &quot;tbl1 &quot;的单表,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="0a8b8eec2dca22f4460d3c1b6d1607de62d83c18" translate="yes" xml:space="preserve">
          <source>For example, to create an archive containing two text files, &quot;a.txt&quot; and &quot;b.txt&quot;, containing the text &quot;abc&quot; and &quot;123&quot; respectively:</source>
          <target state="translated">例如,创建一个包含两个文本文件的档案,&quot;a.txt &quot;和 &quot;b.txt&quot;,分别包含文本 &quot;abc &quot;和 &quot;123&quot;。</target>
        </trans-unit>
        <trans-unit id="e1c45bec4422b2834e5d74273014f0905a33b70e" translate="yes" xml:space="preserve">
          <source>For example, to inspect the contents of zip archive &quot;test.zip&quot; from the current directory:</source>
          <target state="translated">例如,要检查当前目录下的压缩包 &quot;test.zip &quot;的内容。</target>
        </trans-unit>
        <trans-unit id="460920e6960fc9166bdf09c3d3e3d2d1b9cb1172" translate="yes" xml:space="preserve">
          <source>For example, to optimize the full-text index for an FTS table named &quot;docs&quot;:</source>
          <target state="translated">例如,优化名为 &quot;docs &quot;的FTS表的全文索引。</target>
        </trans-unit>
        <trans-unit id="8112859719fda223d11dd9ecc671a2d731113a48" translate="yes" xml:space="preserve">
          <source>For example, to see a list of the tables in the database, you can enter &quot;.tables&quot;.</source>
          <target state="translated">例如,要查看数据库中的表的列表,可以输入&quot;.tables&quot;。</target>
        </trans-unit>
        <trans-unit id="3403f20bef06b9f62c829264d38a448f07fbf25f" translate="yes" xml:space="preserve">
          <source>For example, using the tables created above:</source>
          <target state="translated">例如,使用上面创建的表格。</target>
        </trans-unit>
        <trans-unit id="8baebd4e0fce8f0dca8a23890fbbeb7b6c6bd6f4" translate="yes" xml:space="preserve">
          <source>For example, when a document containing the text &quot;Right now, they're very frustrated.&quot;, the terms extracted from the document and added to the full-text index are, in order, &quot;right now they re very frustrated&quot;. Such a document would match a full-text query such as &quot;MATCH 'Frustrated'&quot;, as the simple tokenizer transforms the term in the query to lowercase before searching the full-text index.</source>
          <target state="translated">例如,当文档中包含 &quot;Right now,they're very frustrated.&quot;时,从文档中提取并添加到全文索引中的术语依次为 &quot;right now they're very frustrated&quot;。这样的文档将与 &quot;MATCH 'Frustrated'&quot;这样的全文查询相匹配,因为在搜索全文索引之前,简单的tokenizer将查询中的术语转换为小写。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="0dc693a709e03c8a242ebc99f829d5a5f0d7f07e" translate="yes" xml:space="preserve">
          <source>For examples of how the SQLite C/C++ interface can be used, refer to the source code for the &lt;b&gt;sqlite&lt;/b&gt; program in the file &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src/shell.c&lt;/a&gt; of the source tree. Additional information about sqlite is available at &lt;a href=&quot;cli&quot;&gt;cli.html&lt;/a&gt;. See also the sources to the Tcl interface for SQLite in the source file &lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;src/tclsqlite.c&lt;/a&gt;.</source>
          <target state="translated">有关如何使用SQLite C / C ++接口的示例，请参考源树的&lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src / shell.c&lt;/a&gt;文件中&lt;b&gt;sqlite&lt;/b&gt;程序的源代码。有关sqlite的其他信息，请访问&lt;a href=&quot;cli&quot;&gt;cli.html&lt;/a&gt;。另请参见源文件&lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;src / tclsqlite.c中&lt;/a&gt; SQLite的Tcl接口的源代码。</target>
        </trans-unit>
        <trans-unit id="db416b5f222a1960fcc408837e83b440afa98ccd" translate="yes" xml:space="preserve">
          <source>For floating-point substitutions (%e, %E, %f, %g, %G) the precision specifies the number of digits to display to the right of the decimal point.</source>
          <target state="translated">对于浮点替换(%e,%E,%f,%g,%G),精度指定显示在小数点右边的位数。</target>
        </trans-unit>
        <trans-unit id="cf9d217953f034811d5791d9759455b504d70d86" translate="yes" xml:space="preserve">
          <source>For full prefix support, method (3) may be preferred. In this case, because the index contains entries for both &quot;first&quot; and &quot;1st&quot;, prefix queries such as 'fi*' or '1s*' will match correctly. However, because extra entries are added to the FTS index, this method uses more space within the database.</source>
          <target state="translated">对于完全的前缀支持,方法(3)可能是首选。在这种情况下,由于索引包含了 &quot;first &quot;和 &quot;1st &quot;的条目,所以像 &quot;fi*&quot;或 &quot;1s*&quot;这样的前缀查询将正确匹配。然而,由于额外的条目被添加到FTS索引中,这种方法在数据库中使用了更多的空间。</target>
        </trans-unit>
        <trans-unit id="af625b5ec940a13ac3f0b796c61917d55c083bf9" translate="yes" xml:space="preserve">
          <source>For functions that accept &quot;</source>
          <target state="translated">对于接受&quot;</target>
        </trans-unit>
        <trans-unit id="8e0c304ceb8d93d914d671ff91751c10ea1ee104" translate="yes" xml:space="preserve">
          <source>For functions that accept JSON as their first argument, that argument can be a JSON object, array, number, string, or null. SQLite numeric values and NULL values are interpreted as JSON numbers and nulls, respectively. SQLite text values can be understood as JSON objects, arrays, or strings. If an SQLite text value that is not a well-formed JSON object, array, or string is passed into json1 function, that function will usually throw an error. (Exceptions to this rule are &lt;a href=&quot;json1#jvalid&quot;&gt;json_valid()&lt;/a&gt; and &lt;a href=&quot;json1#jquote&quot;&gt;json_quote()&lt;/a&gt;.)</source>
          <target state="translated">对于将JSON作为第一个参数的函数，该参数可以是JSON对象，数组，数字，字符串或null。 SQLite数字值和NULL值分别解释为JSON数字和null。 SQLite文本值可以理解为JSON对象，数组或字符串。如果将不是格式正确的JSON对象，数组或字符串的SQLite文本值传递给json1函数，则该函数通常会引发错误。 （此规则的例外是&lt;a href=&quot;json1#jvalid&quot;&gt;json_valid（）&lt;/a&gt;和&lt;a href=&quot;json1#jquote&quot;&gt;json_quote（）&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="f4454df1a142f9ac3cdff944002d68d2bfdcbcbb" translate="yes" xml:space="preserve">
          <source>For functions that accept PATH arguments, that PATH must be well-formed or else the function will throw an error. A well-formed PATH is a text value that begins with exactly one '$' character followed by zero or more instances of &quot;.</source>
          <target state="translated">对于接受PATH参数的函数,PATH必须是格式良好的,否则函数将抛出一个错误。一个格式良好的PATH是一个文本值,它的开头是一个'$'字符,后面是零个或多个&quot;.</target>
        </trans-unit>
        <trans-unit id="8848d7d3d9820023afd4f5c595baf809ffcb7c92" translate="yes" xml:space="preserve">
          <source>For general use in cases where the workload contains few UPDATE or DELETE operations, a good choice for automerge is 8. If the workload contains many UPDATE or DELETE commands, or if query speed is a concern, it may be advantageous to reduce automerge to 2.</source>
          <target state="translated">如果工作负载中包含很少的UPDATE或DELETE操作,那么automerge的最佳选择是8。如果工作负载中包含很多UPDATE或DELETE命令,或者担心查询速度,那么将automerge减少到2可能会更好。</target>
        </trans-unit>
        <trans-unit id="bf5110604d852a2448723644607996c9499bf3c7" translate="yes" xml:space="preserve">
          <source>For historic compatibility, the C-language interfaces return primary result codes by default. The extended result code for the most recent error can be retrieved using the &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_extended_errcode()&lt;/a&gt; interface. The &lt;a href=&quot;c3ref/extended_result_codes&quot;&gt;sqlite3_extended_result_codes()&lt;/a&gt; interface can be used to put a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; into a mode where it returns the extended result codes instead of the primary result codes.</source>
          <target state="translated">为了实现历史兼容性，默认情况下，C语言接口返回主要结果代码。可以使用&lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_extended_errcode（）&lt;/a&gt;接口检索最新错误的扩展结果代码。所述&lt;a href=&quot;c3ref/extended_result_codes&quot;&gt;sqlite3_extended_result_codes（）&lt;/a&gt;接口可用于把一个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;到那里返回扩展结果代码，而不是主要结果代码的模式。</target>
        </trans-unit>
        <trans-unit id="17b53a99ea41c50893270b0043884f065027650e" translate="yes" xml:space="preserve">
          <source>For historical reasons, and for efficiency, all sorting is currently done in memory.</source>
          <target state="translated">由于历史原因,也为了提高效率,目前所有的排序都在内存中进行。</target>
        </trans-unit>
        <trans-unit id="a0dd02bd233ae7478e084f2a9720533a34049740" translate="yes" xml:space="preserve">
          <source>For historical reference, the complete history for the source code to this document is available in the SQLite Documentation source repository: &lt;a href=&quot;https://www.sqlite.org/docsrc/finfo/pages/codeofconduct.in&quot;&gt; https://www.sqlite.org/docsrc/finfo/pages/codeofconduct.in&lt;/a&gt;</source>
          <target state="translated">作为历史参考，可在SQLite文档源存储库中找到本文档源代码的完整历史记录：&lt;a href=&quot;https://www.sqlite.org/docsrc/finfo/pages/codeofconduct.in&quot;&gt;https&lt;/a&gt; : //www.sqlite.org/docsrc/finfo/pages/codeofconduct.in</target>
        </trans-unit>
        <trans-unit id="eeed22fa30af9d54901acfbf4c1ce1f017feb462" translate="yes" xml:space="preserve">
          <source>For integer substitutions (%d, %i, %x, %X, %o, and %p) the precision specifies minimum number of digits to display. Leading zeros are added if necessary, to expand the output to the minimum number of digits.</source>
          <target state="translated">对于整数替换(%d,%i,%x,%X,%o,and %p),精度指定了要显示的最小位数。如有必要,会添加前导零,以将输出扩大到最小的数字数。</target>
        </trans-unit>
        <trans-unit id="6f753dacad85542947673dd8fa7db3bccc0a7592" translate="yes" xml:space="preserve">
          <source>For maximum reliability and for robustness against database corruption, SQLite should always be run with its default synchronous setting of FULL.</source>
          <target state="translated">为了获得最大的可靠性和防止数据库损坏的稳健性,SQLite应该始终以其默认的同步设置FULL运行。</target>
        </trans-unit>
        <trans-unit id="489e54409f8b7e0829c336efb96f4282b5ccf13a" translate="yes" xml:space="preserve">
          <source>For more details, refer to the comments in &lt;a href=&quot;http://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h&quot;&gt;header file sqlite3rbu.h&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;http://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h&quot;&gt;头文件sqlite3rbu.h中&lt;/a&gt;的注释。</target>
        </trans-unit>
        <trans-unit id="782ac5621650f8b61659b985f4abaa00301a1747" translate="yes" xml:space="preserve">
          <source>For more details, refer to the comments in &lt;a href=&quot;https://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h&quot;&gt;header file sqlite3rbu.h&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;https://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h&quot;&gt;头文件sqlite3rbu.h中&lt;/a&gt;的注释。</target>
        </trans-unit>
        <trans-unit id="4e6f70ecf49e4210656602d693e569fcb03d8193" translate="yes" xml:space="preserve">
          <source>For most applications, the recommended method for building SQLite is to use &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt; code file, &lt;b&gt;sqlite3.c&lt;/b&gt;, and its corresponding header file &lt;b&gt;sqlite3.h&lt;/b&gt;. The sqlite3.c code file should compile and run on any unix, Windows system without any changes or special compiler options. Most applications can simply include the sqlite3.c file together with the other C code files that make up the application, compile them all together, and have working and well configured version of SQLite.</source>
          <target state="translated">对于大多数应用程序，建议的构建SQLite的方法是使用&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;代码文件&lt;b&gt;sqlite3.c&lt;/b&gt;及其对应的头文件&lt;b&gt;sqlite3.h&lt;/b&gt;。 sqlite3.c代码文件应可以在任何UNIX Windows系统上编译并运行，而无需进行任何更改或特殊的编译器选项。大多数应用程序可以简单地将sqlite3.c文件以及其他组成应用程序的C代码文件包括在内，一起编译它们，并具有运行良好且配置良好的SQLite版本。</target>
        </trans-unit>
        <trans-unit id="99e3c9a88b32764d83bb0da10699b12fcd9a531f" translate="yes" xml:space="preserve">
          <source>For most applications, upgrading from the legacy query planner to the NGQP requires little thought or effort. Simply replace the older SQLite version with the newer version of SQLite and recompile and the application will run faster. There are no API changes nor modifications to compilation procedures.</source>
          <target state="translated">对于大多数应用程序来说,从传统的查询规划器升级到NGQP几乎不需要考虑或努力。只需将旧版SQLite替换为新版SQLite并重新编译,应用程序就会运行得更快。不需要改变API,也不需要修改编译过程。</target>
        </trans-unit>
        <trans-unit id="0efe87a820fa8cd327d2f74d3e3f1deb32107fb9" translate="yes" xml:space="preserve">
          <source>For most cases, it is true that potential attackers have no way of injecting arbitrary SQL, and so most uses of SQLite are immune to the attack above. But there are some notable exceptions. To wit:</source>
          <target state="translated">对于大多数情况下,潜在的攻击者确实没有办法注入任意的SQL,因此SQLite的大多数使用都可以免疫上述攻击。但也有一些明显的例外。即</target>
        </trans-unit>
        <trans-unit id="c86754da6df36988096aed27dea948d5f58eceba" translate="yes" xml:space="preserve">
          <source>For most non-trivial SQL databases, the key to performance is creating the right SQL indexes. In this context &quot;the right SQL indexes&quot; means those that cause the queries that an application needs to optimize run fast. The &quot;.expert&quot; command can assist with this by proposing indexes that might assist with specific queries, were they present in the database.</source>
          <target state="translated">对于大多数非平凡的SQL数据库,性能的关键是创建正确的SQL索引。在这里,&quot;正确的SQL索引 &quot;指的是那些能使应用程序需要优化的查询快速运行的索引。&quot;.expert &quot;命令可以通过提出可能有助于特定查询的索引(如果它们存在于数据库中的话)来帮助实现这一点。</target>
        </trans-unit>
        <trans-unit id="e0fd582fdc761484a0a0ca3bb5f583aafab7cdf5" translate="yes" xml:space="preserve">
          <source>For most purposes, SQLite can be built just fine using the default compilation options. However, if required, the compile-time options documented below can be used to &lt;a href=&quot;#omitfeatures&quot;&gt;omit SQLite features&lt;/a&gt; (resulting in a &lt;a href=&quot;footprint&quot;&gt;smaller compiled library size&lt;/a&gt;) or to change the &lt;a href=&quot;#defaults&quot;&gt;default values&lt;/a&gt; of some parameters.</source>
          <target state="translated">对于大多数用途，可以使用默认编译选项很好地构建SQLite。但是，如果需要，下面介绍的编译时选项可用于&lt;a href=&quot;#omitfeatures&quot;&gt;省略SQLite功能&lt;/a&gt;（导致&lt;a href=&quot;footprint&quot;&gt;较小的编译库大小&lt;/a&gt;）或更改某些参数的&lt;a href=&quot;#defaults&quot;&gt;默认值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="932b2392df531ace28cd032a80948aba14e668af" translate="yes" xml:space="preserve">
          <source>For much of its history SQLite has been focused on 100% MC/DC testing. Resistance to fuzzing attacks only became a concern with the introduction of AFL in 2014. For a while there, fuzzers were finding many problems in SQLite. In more recent years, the testing strategy of SQLite has evolved to place more emphasis on fuzz testing. We still maintain 100% MC/DC of the core SQLite code, but most testing CPU cycles are now devoted to fuzzing.</source>
          <target state="translated">在历史的大部分时间里,SQLite一直专注于100%的MC/DC测试。在2014年引入AFL后,对模糊攻击的抵抗力才成为人们关注的问题。在那里的一段时间里,模糊者在SQLite中发现了很多问题。最近几年,SQLite的测试策略已经发展到更加重视模糊测试。我们仍然保持了SQLite核心代码100%的MC/DC,但现在大部分测试CPU周期都投入到了模糊测试中。</target>
        </trans-unit>
        <trans-unit id="be3d8fa3ad8b3f16b5f81b3d35db241bab90e030" translate="yes" xml:space="preserve">
          <source>For multi-threaded applications that are careful about how they manage threads, SQLite supports an alternative run-time configuration that is half way between not using any mutexes and the default situation of mutexing everything in sight. This in-the-middle mutex alignment can be established as follows:</source>
          <target state="translated">对于那些小心翼翼地管理线程的多线程应用程序来说,SQLite支持一种替代性的运行时配置,这种配置介于不使用任何mutexes和默认的将所有看到的东西都mutexes的情况之间。这种中间的mutex对齐方式可以建立如下。</target>
        </trans-unit>
        <trans-unit id="5bfaf72720042391e9725050a2097ea765a5277e" translate="yes" xml:space="preserve">
          <source>For newer applications, FTS4 is recommended; though if compatibility with older versions of SQLite is important, then FTS3 will usually serve just as well.</source>
          <target state="translated">对于较新的应用程序,建议使用FTS4;但如果与旧版本的SQLite的兼容性很重要,那么FTS3通常也同样适用。</target>
        </trans-unit>
        <trans-unit id="74f1cec569d928f5163be03c8f3a97d88c4bb5d9" translate="yes" xml:space="preserve">
          <source>For non-TEMP triggers, the table to be modified or queried must exist in the same database as the table or view to which the trigger is attached. TEMP triggers are not subject to the same-database rule. A TEMP trigger is allowed to query or modify any table in any &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed database.</source>
          <target state="translated">对于非TEMP触发器，要修改或查询的表必须与触发器附加到的表或视图位于同一数据库中。TEMP触发器不受同一数据库规则的约束。允许TEMP触发器查询或修改任何&lt;a href=&quot;lang_attach&quot;&gt;ATTACH版本的&lt;/a&gt;数据库中的任何表。</target>
        </trans-unit>
        <trans-unit id="eaf4afda655b698c5089cf162bb3637b1ddce067" translate="yes" xml:space="preserve">
          <source>For numeric data, this situation is more complex. If both inputs look like well-formed numbers, then they are converted into floating point values using &lt;b&gt;atof()&lt;/b&gt; and compared numerically. If one input is not a well-formed number but the other is, then the number is considered to be less than the non-number. If neither inputs is a well-formed number, then &lt;b&gt;strcmp()&lt;/b&gt; is used to do the comparison.</source>
          <target state="translated">对于数字数据，这种情况更为复杂。如果两个输入都看起来像格式正确的数字，则可以使用&lt;b&gt;atof（）&lt;/b&gt;将它们转换为浮点值并进行数值比较。如果一个输入不是格式正确的数字，而另一个是格式正确的数字，则认为该数字小于该非数字。如果两个输入都不是格式正确的数字，则使用&lt;b&gt;strcmp（）&lt;/b&gt;进行比较。</target>
        </trans-unit>
        <trans-unit id="11d66790f63457992337a522f75d0ba8c19d49c3" translate="yes" xml:space="preserve">
          <source>For ordinary FTS3/FTS4 queries, the search tree depth is approximately the base-2 logarithm of the number of terms in the right-hand side of the MATCH operator. However, for &lt;a href=&quot;fts3#phrase&quot;&gt;phrase queries&lt;/a&gt; and &lt;a href=&quot;fts3#near&quot;&gt;NEAR queries&lt;/a&gt; the search tree depth is linear in the number of right-hand side terms. So the default depth limit of 12 is sufficient for up to 4095 ordinary terms on a MATCH, it is only sufficient for 11 or 12 phrase or NEAR terms. Even so, the default is more than enough for most application.</source>
          <target state="translated">对于普通的FTS3 / FTS4查询，搜索树深度大约是MATCH运算符右侧的项数的以2为底的对数。但是，对于&lt;a href=&quot;fts3#phrase&quot;&gt;短语查询&lt;/a&gt;和&lt;a href=&quot;fts3#near&quot;&gt;NEAR查询&lt;/a&gt;，搜索树的深度在右侧术语的数量上是线性的。因此，默认深度限制12足以匹配MATCH上的4095个普通术语，仅足以满足11或12个短语或NEAR术语。即使这样，对于大多数应用程序而言，默认值也绰绰有余。</target>
        </trans-unit>
        <trans-unit id="87e6be4eb608f1997fb25355e4537ee88db28dd4" translate="yes" xml:space="preserve">
          <source>For performance measurement, SQLite is compiled in approximately the same way as it would be for use in production systems. The compile-time configuration is &quot;approximate&quot; in the sense that every production use of SQLite is different. Compile-time options used by one system are not necessarily the same as those used by others. The key point is that options that significantly impact the generated machine code are avoided. For example, the -DSQLITE_DEBUG option is omitted because that option inserts thousands of assert() statements in the middle of performance critical sections of the SQLite library. The -pg option (on GCC) is omitted because it causes the compiler to emit extra probabilistic performance measuring code which interferes with actual performance measurements.</source>
          <target state="translated">对于性能测量,SQLite的编译方式与在生产系统中使用的方式大致相同。编译时的配置是 &quot;近似 &quot;的,因为SQLite的每个生产用途都是不同的。一个系统使用的编译时选项不一定与其他系统使用的相同。关键的一点是,要避免使用对生成的机器代码有重大影响的选项。例如,-DSQLITE_DEBUG选项被省略了,因为该选项在SQLite库的性能关键部分中间插入了成千上万条assert()语句。省略了-pg选项(在GCC上),因为它会导致编译器发出额外的概率性能测量代码,干扰实际的性能测量。</target>
        </trans-unit>
        <trans-unit id="f448cd989ab34ec0bc46f3d775e49bf2cb96fd96" translate="yes" xml:space="preserve">
          <source>For performance measurements, the -Os option is used (optimize for size) rather than -O2 because the -O2 option creates so much code movement that it is difficult to associate specific CPU instructions to C source code lines.</source>
          <target state="translated">对于性能测量,使用-Os选项(优化大小)而不是-O2,因为-O2选项会产生大量的代码移动,很难将特定的CPU指令与C源代码行关联起来。</target>
        </trans-unit>
        <trans-unit id="5c184bd0f5295912e4ff3123f4057a4db6895161" translate="yes" xml:space="preserve">
          <source>For performance reasons, it is advantageous to &lt;b&gt;minimize the quantity of data read and written&lt;/b&gt; to and from the file-system.</source>
          <target state="translated">出于性能原因，将&lt;b&gt;读写&lt;/b&gt;文件系统&lt;b&gt;的数据量减&lt;/b&gt;到&lt;b&gt;最少&lt;/b&gt;是有利的。</target>
        </trans-unit>
        <trans-unit id="07b863ed3fe569c9ef5b6a594040618449a6d03c" translate="yes" xml:space="preserve">
          <source>For programs that have a lot of data that must be sifted and sorted in diverse ways, it is often easier and quicker to load the data into an in-memory SQLite database and use queries with joins and ORDER BY clauses to extract the data in the form and order needed rather than to try to code the same operations manually. Using an SQL database internally in this way also gives the program greater flexibility since new columns and indices can be added without having to recode every query.</source>
          <target state="translated">对于有很多数据必须以不同方式进行筛选和排序的程序来说,将数据加载到内存中的SQLite数据库中,并使用带有连接和ORDER BY子句的查询,以所需的形式和顺序提取数据,而不是试图手动编写相同的操作代码,这往往更容易和更快。以这种方式在内部使用SQL数据库,还可以给程序带来更大的灵活性,因为可以添加新的列和索引,而不必重新编写每个查询。</target>
        </trans-unit>
        <trans-unit id="9dd6714e0fb0a2d212f83820882b4bc1eae38324" translate="yes" xml:space="preserve">
          <source>For queries that use OR expressions, or those that use LIMIT or return many rows, the 'y' matchinfo option may be faster than 'x'.</source>
          <target state="translated">对于使用OR表达式的查询,或者使用LIMIT或返回多条记录的查询,&quot;y &quot;matchinfo选项可能比 &quot;x &quot;更快。</target>
        </trans-unit>
        <trans-unit id="0c9ccc0a52d5200b9388c921b60acbab7d6fb34e" translate="yes" xml:space="preserve">
          <source>For queries, extract results by calling &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; in between two calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">对于查询，通过调用提取结果&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column（）&lt;/a&gt;两次调用之间&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5bf18084dc0d97ae369c3088b48ef4a87de7f25" translate="yes" xml:space="preserve">
          <source>For reading database files that are unusually high-risk, such as database files that are received from remote machines, and possibly from anonymous contributors, the following extra precautions might be justified. These added defenses come with performance costs, however, and so may not be appropriate in every situation:</source>
          <target state="translated">对于读取异常高风险的数据库文件,例如从远程机器上接收的数据库文件,以及可能来自匿名贡献者的数据库文件,以下额外的预防措施可能是合理的。然而,这些额外的防御措施是有性能代价的,因此可能并不适合在所有情况下使用。</target>
        </trans-unit>
        <trans-unit id="85d9929e5f003ec622c68d9ac564cf73c6c4c155" translate="yes" xml:space="preserve">
          <source>For reading existing zip archives, the Zipfile module provides a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; that accepts a single argument. If the argument is a text value, then it is a path to a zip archive to read from the file-system. Or, if the argument is an SQL blob, then it is the zip archive data itself.</source>
          <target state="translated">为了读取现有的zip存档，Zipfile模块提供了一个&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;，该函数接受单个参数。如果参数是文本值，则它是要从文件系统读取的zip存档的路径。或者，如果参数是SQL Blob，则它是zip归档数据本身。</target>
        </trans-unit>
        <trans-unit id="9867027f324defd1a582c5a9d9007cb8936fd6ce" translate="yes" xml:space="preserve">
          <source>For reasons of backwards compatibility, the &quot;automerge=1&quot; command sets the automerge parameter to 8, not 1 (a value of 1 would make no sense anyway, as merging data from a single segment is a no-op).</source>
          <target state="translated">出于向后兼容性的考虑,&quot;automerge=1 &quot;命令将automerge参数设置为8,而不是1(1的值无论如何都是没有意义的,因为从一个片段中合并数据是不可能的)。</target>
        </trans-unit>
        <trans-unit id="a23d1c74ece13b6a1e6d02aa92a4e6d015b8a626" translate="yes" xml:space="preserve">
          <source>For regular functions, the &lt;b&gt;xFunc&lt;/b&gt; callback is invoked once for each function call. The implementation of xFunc should call one of the &lt;b&gt;sqlite_set_result_...&lt;/b&gt; interfaces to return its result. The &lt;b&gt;sqlite_user_data()&lt;/b&gt; routine can be used to retrieve the &lt;b&gt;pUserData&lt;/b&gt; pointer that was passed in when the function was registered.</source>
          <target state="translated">对于常规函数，每个函数调用都会调用一次&lt;b&gt;xFunc&lt;/b&gt;回调。xFunc的实现应调用&lt;b&gt;sqlite_set_result _...&lt;/b&gt;接口之一以返回其结果。所述&lt;b&gt;sqlite_user_data（）&lt;/b&gt;例行程序可用于检索&lt;b&gt;pUserData&lt;/b&gt;这是当被登记的功能传入指针。</target>
        </trans-unit>
        <trans-unit id="d0ed67ff8b79adf22c16c2b1f3556a389aea4a01" translate="yes" xml:space="preserve">
          <source>For resilience when confronted with historical SQL statements, SQLite will sometimes bend the quoting rules above:</source>
          <target state="translated">为了在面对历史SQL语句时的弹性,SQLite有时会弯曲上面的引用规则。</target>
        </trans-unit>
        <trans-unit id="e7eae9c3102a4115cf6fa58568800e787b48e7a4" translate="yes" xml:space="preserve">
          <source>For security reasons, extension loaded is turned off by default and must be enabled by a prior call to &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt;.</source>
          <target state="translated">出于安全原因，加载的扩展名默认情况下处于关闭状态，并且必须通过事先调用&lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）&lt;/a&gt;来启用。</target>
        </trans-unit>
        <trans-unit id="c4880044a5796d62d55405bede28ef5f4f52805b" translate="yes" xml:space="preserve">
          <source>For security reasons, extension loading is turned off by default. In order to use either the C-language or SQL extension loading functions, one must first enable extension loading using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;,1,NULL) C-language API in your application.</source>
          <target state="translated">出于安全原因，扩展加载默认情况下处于关闭状态。为了使用C语言或SQL扩展加载功能，必须首先在应用程序中使用&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;，1，NULL）C语言API 启用扩展加载。</target>
        </trans-unit>
        <trans-unit id="90f079fcf7344dc268fa3af2372e90f48b6aca40" translate="yes" xml:space="preserve">
          <source>For security reasons, it is recommended that applications first set &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema=OFF&lt;/a&gt; or run the &quot;&lt;a href=&quot;#config&quot;&gt;db config trusted_schema 0&lt;/a&gt;&quot; method before using this method.</source>
          <target state="translated">出于安全原因，建议应用程序在使用此方法之前先设置&lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMAtrusted_schema = OFF&lt;/a&gt;或运行&amp;ldquo; &lt;a href=&quot;#config&quot;&gt;db config trust_schema 0&lt;/a&gt; &amp;rdquo;方法。</target>
        </trans-unit>
        <trans-unit id="92cbc8f2d6b97260523c5a56f27aa3c653ce65fe" translate="yes" xml:space="preserve">
          <source>For signed numeric substitutions, include a &quot;+&quot; sign before positive numbers. A &quot;-&quot; sign always appears before negative numbers regardless of flag settings.</source>
          <target state="translated">对于有符号的数字替换,在正数前加入 &quot;+&quot;号。无论标志设置如何,&quot;-&quot;号总是出现在负数前。</target>
        </trans-unit>
        <trans-unit id="0a389ef1f84e1f5ea12705422f16f304415d7e84" translate="yes" xml:space="preserve">
          <source>For signed numeric substitutions, prepend a single space before positive numbers.</source>
          <target state="translated">对于有符号的数字替换,在正数前加一个空格。</target>
        </trans-unit>
        <trans-unit id="8361cfb2d567750344a1d16c228e8f02d706a6ad" translate="yes" xml:space="preserve">
          <source>For simple queries against a single table with few indexes, there is usually an obvious choice for the best algorithm. But for larger and more complex queries, such as multi-way joins with many indexes and subqueries, there can be hundreds, thousands, or millions of reasonable algorithms for computing the result. The job of the query planner is to choose the single &quot;best&quot; query plan from this multitude of possibilities.</source>
          <target state="translated">对于针对一张索引少的单表的简单查询,通常会有一个明显的最佳算法选择。但是对于较大和较复杂的查询,例如有许多索引和子查询的多路连接,可能会有数百、数千或数百万种合理的算法来计算结果。查询规划器的工作就是从这众多的可能性中选择一个 &quot;最佳 &quot;的查询计划。</target>
        </trans-unit>
        <trans-unit id="a9d77b186d3d3bf7ae8219371bcb8b76fedae519" translate="yes" xml:space="preserve">
          <source>For small databases and modern CPUs, there is usually no reason not to pass &quot;--sample 100&quot;. However, gathering data distribution statistics can be expensive for large database tables. If the operation is too slow, try passing a smaller value for the --sample option.</source>
          <target state="translated">对于小型数据库和现代CPU,通常没有理由不通过&quot;--sample 100&quot;。但是,对于大型数据库表来说,收集数据分布统计的费用可能很高。如果操作太慢,可以尝试为--sample选项传递一个较小的值。</target>
        </trans-unit>
        <trans-unit id="a4a24ddee4d5daf8ddd5ba8dfd7d48787ebb03b7" translate="yes" xml:space="preserve">
          <source>For string substitutions (%s, %z, %q, %Q, or %w) the precision is the number of byte or character used from the argument. The number is bytes by default but is characters if the &quot;!&quot; flag is present. If there is no precision, then the entire string is substituted. Examples: &quot;%.3s&quot; substitutes the first 3 bytes of the argument string. &quot;%!.3s&quot; substitutes the first three characters of the argument string.</source>
          <target state="translated">对于字符串替换(%s,%z,%q,%Q,或 %w),精度是参数中使用的字节数或字符数。默认情况下是字节数,但如果有&quot;!&quot;标志,则是字符数。如果没有精度,则用整个字符串代替。例如:&quot;%.3s &quot;代替了参数中的字符。&quot;%.3s&quot; 替换参数字符串的前3个字节。&quot;%!.3s &quot;替换参数字符串的前三个字符。</target>
        </trans-unit>
        <trans-unit id="e7573ff9c5daeb6537cacfee96e59061a43495a3" translate="yes" xml:space="preserve">
          <source>For subprograms, there is a bitmask in the VdbeFrame that determines whether or not the jump should be taken. The bitmask is necessary because the self-altering code trick does not work for recursive triggers.</source>
          <target state="translated">对于子程序,在VdbeFrame中有一个位掩码来决定是否应该采取跳转。位掩码是必要的,因为自改代码技巧对递归触发器不起作用。</target>
        </trans-unit>
        <trans-unit id="1ef6b92612835372e131287be2c793df5805bcf9" translate="yes" xml:space="preserve">
          <source>For table columns, the datatype is determined by the type declaration of the CREATE TABLE statement. The datatype is text if and only if the type declaration contains one or more of the following strings:</source>
          <target state="translated">对于表列,数据类型由CREATE TABLE语句的类型声明决定。如果且仅当类型声明包含以下一个或多个字符串时,数据类型是文本。</target>
        </trans-unit>
        <trans-unit id="7117d5cbbb5730360ccac5d30c1470b52beef293" translate="yes" xml:space="preserve">
          <source>For testing on embedded systems, the mkth3.tcl script and the compiler steps shown above are performed on an ordinary workstation using a cross-compiler, then the resulting test program is transferred onto the device to be run.</source>
          <target state="translated">对于嵌入式系统的测试,mkth3.tcl脚本和上面所示的编译步骤是在普通工作站上使用交叉编译器进行的,然后将得到的测试程序转移到要运行的设备上。</target>
        </trans-unit>
        <trans-unit id="d2eb4ede923268e657583d146fd6fd411d8b52aa" translate="yes" xml:space="preserve">
          <source>For the --insert command, all files listed are inserted into the archive. For the --update command, files are only inserted if they do not previously exist in the archive, or if their &quot;mtime&quot; or &quot;mode&quot; is different from what is currently in the archive.</source>
          <target state="translated">对于--insert命令,所有列出的文件都会被插入到归档中。对于--update命令,只有当文件以前不存在于归档中,或者它们的 &quot;mtime &quot;或 &quot;mode &quot;与当前归档中的文件不同时,才会被插入。</target>
        </trans-unit>
        <trans-unit id="0d9d2265812b12b9762e700ccc4ceb3931ebf930" translate="yes" xml:space="preserve">
          <source>For the C-language interfaces, the argument is an integer which is interpreted as a character. For the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; the argument is a string from which the first character is extracted and displayed.</source>
          <target state="translated">对于C语言接口，该参数是一个整数，它被解释为字符。对于&lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf（）SQL函数，&lt;/a&gt;自变量是一个字符串，将从中提取并显示第一个字符。</target>
        </trans-unit>
        <trans-unit id="c95ceb997c597a8e6a21b33cbd1c20d5ac14d94b" translate="yes" xml:space="preserve">
          <source>For the GLOB operator, the column must be indexed using the built-in BINARY collating sequence.</source>
          <target state="translated">对于GLOB操作符,必须使用内置的BINARY整理序列对列进行索引。</target>
        </trans-unit>
        <trans-unit id="8b7943406433a1489b27536ff1cedb40c6a83fc4" translate="yes" xml:space="preserve">
          <source>For the LIKE operator, if &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like&lt;/a&gt; mode is enabled then the column must indexed using BINARY collating sequence, or if &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like&lt;/a&gt; mode is disabled then the column must indexed using built-in NOCASE collating sequence.</source>
          <target state="translated">对于LIKE运算符，如果启用&lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like&lt;/a&gt;模式，则该列必须使用BINARY排序序列进行索引；或者，如果禁用&lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like&lt;/a&gt;模式，则该列必须使用内置的NOCASE排序序列进行索引。</target>
        </trans-unit>
        <trans-unit id="7cdf83f29334dcdbf7d2cd2ebb95d78257ea8367" translate="yes" xml:space="preserve">
          <source>For the LIKE, GLOB, REGEXP, and MATCH operators, the aConstraint[].iColumn value is the virtual table column that is the left operand of the operator. However, if these operators are expressed as function calls instead of operators, then the aConstraint[].iColumn value references the virtual table column that is the second argument to that function:</source>
          <target state="translated">对于LIKE、GLOB、REGEXP和MATCH运算符,aConstraint[].iColumn值是作为运算符左操作数的虚拟表列。但是,如果将这些运算符表示为函数调用而不是运算符,那么aConstraint[].iColumn的值就会引用作为该函数第二个参数的虚拟表列。</target>
        </trans-unit>
        <trans-unit id="394b73aae0d0953d9f85a4d75a67f00c2d16e226" translate="yes" xml:space="preserve">
          <source>For the SELECT statement above, the optimizer can use the ex2i1 index to lookup rows of ex2 that contain x=5 and then test each row against the y=6 term. Or it can use the ex2i2 index to lookup rows of ex2 that contain y=6 then test each of those rows against the x=5 term.</source>
          <target state="translated">对于上面的SELECT语句,优化器可以使用ex2i1索引来查找ex2中包含x=5的记录,然后根据y=6项来测试每一条记录。或者使用ex2i2索引来查找ex2中包含y=6的行,然后根据x=5项来测试每一条行。</target>
        </trans-unit>
        <trans-unit id="6880a2956aa62196c20844c37991ebf1c9cc0265" translate="yes" xml:space="preserve">
          <source>For the character substitution (%c) a precision N greater than 1 causes the character to be repeated N times. This is a non-standard extension found only in SQLite.</source>
          <target state="translated">对于字符替换(%c),精度N大于1会导致该字符重复N次。这是一个只在SQLite中才有的非标准扩展。</target>
        </trans-unit>
        <trans-unit id="cbfa8c438ab75aa5b53746b3a61a2493fdc0fcad" translate="yes" xml:space="preserve">
          <source>For the common case where we want the busy callback to sleep, the SQLite library provides a convenience routine &lt;b&gt;sqlite_busy_timeout&lt;/b&gt;. The first argument to &lt;b&gt;sqlite_busy_timeout&lt;/b&gt; is a pointer to an open SQLite database and the second argument is a number of milliseconds. After &lt;b&gt;sqlite_busy_timeout&lt;/b&gt; has been executed, the SQLite library will wait for the lock to clear for at least the number of milliseconds specified before it returns SQLITE_BUSY. Specifying zero milliseconds for the timeout restores the default behavior.</source>
          <target state="translated">对于我们希望繁忙的回调进入睡眠状态的常见情况，SQLite库提供了一个便捷例程&lt;b&gt;sqlite_busy_timeout&lt;/b&gt;。&lt;b&gt;sqlite_busy_timeout&lt;/b&gt;的第一个参数是指向打开的SQLite数据库的指针，第二个参数是毫秒数。之后&lt;b&gt;sqlite_busy_timeout&lt;/b&gt;已执行，SQLite库将等待锁定清除它返回SQLITE_BUSY之前指定的毫秒数量最少。为超时指定零毫秒将恢复默认行为。</target>
        </trans-unit>
        <trans-unit id="77995af2794868d5e3e1a545ee53f68c9abf9c9a" translate="yes" xml:space="preserve">
          <source>For the index above and WHERE clause like this:</source>
          <target state="translated">对于上面的索引和WHERE子句这样。</target>
        </trans-unit>
        <trans-unit id="bb541928f8f21ef53252b3fcd58c0333fdfa446f" translate="yes" xml:space="preserve">
          <source>For the most part, ordinary rowid tables and WITHOUT ROWID tables are interchangeable. But there are some additional restrictions on WITHOUT ROWID tables that do not apply to ordinary rowid tables:</source>
          <target state="translated">在大多数情况下,普通rowid表和without rowid表是可以互换的。但是对于WITHOUT ROWID表还有一些额外的限制,这些限制并不适用于普通的rowid表。</target>
        </trans-unit>
        <trans-unit id="bee902327ddee3eaa34014db30d1eb9d18663957" translate="yes" xml:space="preserve">
          <source>For the purpose of computing window functions, the result set of a query is divided into one or more &quot;partitions&quot;. A partition consists of all rows that have the same value for all terms of the PARTITION BY clause in the window-defn. If there is no PARTITION BY clause, then the entire result set of the query is a single partition. Window-function processing is performed separately for each partition.</source>
          <target state="translated">为了计算窗口函数,查询的结果集被划分为一个或多个 &quot;分区&quot;。一个分区由对window-defn中的PARTITION BY子句的所有条款具有相同值的所有行组成。如果没有partition by子句,那么整个查询的结果集就是一个分区。对每个分区分别进行窗口函数处理。</target>
        </trans-unit>
        <trans-unit id="b3fd877f7b6778afbc1e68eb5017d97a2b27eeb2" translate="yes" xml:space="preserve">
          <source>For the purpose of the &lt;b&gt;sqlite_complete&lt;/b&gt; function, an SQL statement is complete if it ends in a semicolon.</source>
          <target state="translated">就&lt;b&gt;sqlite_complete&lt;/b&gt;函数而言，如果SQL语句以分号结尾，则它是完整的。</target>
        </trans-unit>
        <trans-unit id="3bdae1911eb2b3c855db66c9e8e796a26c988410" translate="yes" xml:space="preserve">
          <source>For the purposes of determining duplicate rows for the results of compound SELECT operators, NULL values are considered equal to other NULL values and distinct from all non-NULL values. The collation sequence used to compare two text values is determined as if the columns of the left and right-hand SELECT statements were the left and right-hand operands of the equals (=) operator, except that greater precedence is not assigned to a collation sequence specified with the postfix COLLATE operator. No affinity transformations are applied to any values when comparing rows as part of a compound SELECT.</source>
          <target state="translated">为了确定复合SELECT操作符结果的重复行,NULL值被认为与其他NULL值相等,并与所有非NULL值不同。用于比较两个文本值的整理序列的确定,就像左手和右手SELECT语句的列是等于(=)操作符的左手和右手操作符一样,只是不给用后缀COLLATE操作符指定的整理序列分配更大的优先权。当比较行作为复合SELECT的一部分时,不对任何值应用亲和力转换。</target>
        </trans-unit>
        <trans-unit id="593804fd692754b9bd9050d15e0853bf78663ff7" translate="yes" xml:space="preserve">
          <source>For the purposes of determining validity, leading and trailing whitespace on JSON inputs is ignored. Interior whitespace is also ignored, in accordance with the JSON spec. These routines accept exactly the &lt;a href=&quot;http://www.rfc-editor.org/rfc/rfc7159.txt&quot;&gt;rfc-7159 JSON syntax&lt;/a&gt; &amp;mdash; no more and no less.</source>
          <target state="translated">为了确定有效性，将忽略JSON输入上的前导和尾随空格。根据JSON规范，内部空格也将被忽略。这些例程完全接受&lt;a href=&quot;http://www.rfc-editor.org/rfc/rfc7159.txt&quot;&gt;rfc-7159 JSON语法&lt;/a&gt; -不多也不少。</target>
        </trans-unit>
        <trans-unit id="66fadb13539872e5bcc66e0aa3867fed051fd232" translate="yes" xml:space="preserve">
          <source>For the purposes of determining validity, leading and trailing whitespace on JSON inputs is ignored. Interior whitespace is also ignored, in accordance with the JSON spec. These routines accept exactly the &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7159.txt&quot;&gt;rfc-7159 JSON syntax&lt;/a&gt; &amp;mdash; no more and no less.</source>
          <target state="translated">为了确定有效性，将忽略JSON输入上的前导和尾随空格。根据JSON规范，内部空格也将被忽略。这些例程完全接受&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7159.txt&quot;&gt;rfc-7159 JSON语法&lt;/a&gt;-不多也不少。</target>
        </trans-unit>
        <trans-unit id="4f71629a5f8d309dcb7934e2a9e496e90193e44f" translate="yes" xml:space="preserve">
          <source>For the purposes of sorting rows, values are compared in the same way as for &lt;a href=&quot;datatype3#comparisons&quot;&gt;comparison expressions&lt;/a&gt;. The collation sequence used to compare two text values is determined as follows:</source>
          <target state="translated">为了对行进行排序，将以与&lt;a href=&quot;datatype3#comparisons&quot;&gt;比较表达式&lt;/a&gt;相同的方式比较值。用于比较两个文本值的排序规则序列确定如下：</target>
        </trans-unit>
        <trans-unit id="15ea441aee0df5dfef81b948679ce855bde68d24" translate="yes" xml:space="preserve">
          <source>For the purposes of the previous four items, two database connections that use the same &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; and which enable &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted&lt;/a&gt; are considered to be the same database connection, not separate database connections.</source>
          <target state="translated">出于前面四项的目的，使用相同&lt;a href=&quot;sharedcache&quot;&gt;共享缓存&lt;/a&gt;并启用&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted的&lt;/a&gt;两个数据库连接被视为同一数据库连接，而不是单独的数据库连接。</target>
        </trans-unit>
        <trans-unit id="206270d8fd15072121eb3d0a56144d865640f2b5" translate="yes" xml:space="preserve">
          <source>For the purposes of the previous two paragraphs, two database connections that have the same &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; and which have enabled &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted&lt;/a&gt; are considered to be the same database connection.</source>
          <target state="translated">出于前两段的目的，两个具有相同&lt;a href=&quot;sharedcache&quot;&gt;共享缓存&lt;/a&gt;并启用&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted&lt;/a&gt;的数据库连接被视为同一数据库连接。</target>
        </trans-unit>
        <trans-unit id="a17e59e38b9d3bf2b2df3849089638f1437b4d1e" translate="yes" xml:space="preserve">
          <source>For the purposes of this API, a transaction is said to have been rolled back if an explicit &quot;ROLLBACK&quot; statement is executed, or an error or constraint causes an implicit rollback to occur. The rollback callback is not invoked if a transaction is automatically rolled back because the database connection is closed.</source>
          <target state="translated">在这个API中,如果一个显式的 &quot;ROLLBACK &quot;语句被执行,或者一个错误或约束导致一个隐式的回滚发生,那么一个事务就被称为已经回滚。如果一个事务因为数据库连接被关闭而自动回滚,那么回滚回调将不会被调用。</target>
        </trans-unit>
        <trans-unit id="57f69f1f3e95239c1d08d8e626c461a431a40ba6" translate="yes" xml:space="preserve">
          <source>For the purposes of this pragma, the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command is considered a schema change, since &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; will usual alter the &quot;rootpage&quot; values for entries in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master table&lt;/a&gt;.</source>
          <target state="translated">就此编译指示而言，将&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令视为架构更改，因为&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;通常会更改&lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master表中&lt;/a&gt;条目的&amp;ldquo; rootpage&amp;rdquo;值。</target>
        </trans-unit>
        <trans-unit id="a9b750853d344854f9aa1e24acbcd47fcdfc4ad1" translate="yes" xml:space="preserve">
          <source>For the purposes of this pragma, the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command is considered a schema change, since &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; will usual alter the &quot;rootpage&quot; values for entries in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt;.</source>
          <target state="translated">出于此编译指示的目的，&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令被视为架构更改，因为&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;通常会更改&lt;a href=&quot;schematab&quot;&gt;sqlite_schema表中&lt;/a&gt;条目的&amp;ldquo; rootpage&amp;rdquo;值。</target>
        </trans-unit>
        <trans-unit id="4e03b6c7391fbf0bc56188a8c09cd4a7c0b4cdfb" translate="yes" xml:space="preserve">
          <source>For the purposes of this routine, an &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; is considered to be successful even if it is subsequently rolled back.</source>
          <target state="translated">就此例程而言，即使随后将其回滚，也认为&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;成功。</target>
        </trans-unit>
        <trans-unit id="4c58e719af76025bd3937a17763f87efc5e13c1f" translate="yes" xml:space="preserve">
          <source>For the purposes of this routine, an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; is considered to be successful even if it is subsequently rolled back.</source>
          <target state="translated">就此例程而言，即使随后将其回滚，也认为&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;成功。</target>
        </trans-unit>
        <trans-unit id="105a62f9f913b7c3c03726a4a42a2b6ed86624fa" translate="yes" xml:space="preserve">
          <source>For the purposes of unique indices, all NULL values are considered different from all other NULL values and are thus unique. This is one of the two possible interpretations of the SQL-92 standard (the language in the standard is ambiguous). The interpretation used by SQLite is the same and is the interpretation followed by PostgreSQL, MySQL, Firebird, and Oracle. Informix and Microsoft SQL Server follow the other interpretation of the standard, which is that all NULL values are equal to one another.</source>
          <target state="translated">为了唯一索引的目的,所有的NULL值都被认为与所有其他NULL值不同,因此是唯一的。这是SQL-92标准的两种可能的解释之一(标准中的语言是模糊的)。SQLite使用的解释是相同的,也是PostgreSQL、MySQL、Firebird和Oracle遵循的解释。Informix和Microsoft SQL Server遵循的是标准的另一种解释,即所有的NULL值都是彼此相等的。</target>
        </trans-unit>
        <trans-unit id="713e891998daa01c37d2616d81cfb2bf2962ac1e" translate="yes" xml:space="preserve">
          <source>For the right-hand table of a LEFT JOIN, compute the values of expressions directly rather than loading precomputed values out of an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt; as the expression index might not contain the correct value. Ticket &lt;a href=&quot;https://sqlite.org/src/info/7fa8049685b50b5aeb0c2&quot;&gt;7fa8049685b50b5aeb0c2&lt;/a&gt;</source>
          <target state="translated">对于LEFT JOIN的右侧表，直接计算表达式的值，而不是从&lt;a href=&quot;expridx&quot;&gt;表达式索引中&lt;/a&gt;加载预先计算的值，因为表达式索引可能不包含正确的值。机票&lt;a href=&quot;https://sqlite.org/src/info/7fa8049685b50b5aeb0c2&quot;&gt;7fa8049685b50b5aeb0c2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5c9ca201b99a3489f4b36f53a1d0536e05b123a3" translate="yes" xml:space="preserve">
          <source>For the second case, when the table already exists, every row of the CSV file, including the first row, is assumed to be actual content. If the CSV file contains an initial row of column labels, that row will be read as data and inserted into the table. To avoid this, make sure that table does not previously exist.</source>
          <target state="translated">对于第二种情况,当表已经存在时,CSV文件的每一行,包括第一行,都被假定为实际内容。如果CSV文件中包含列标签的初始行,该行将被作为数据读取并插入到表中。为了避免这种情况,请确保该表之前不存在。</target>
        </trans-unit>
        <trans-unit id="7bf6df3d98c9980bb0d46166ad84f0bd8834c9ba" translate="yes" xml:space="preserve">
          <source>For the second case, when the table already exists, every row of the CSV file, including the first row, is assumed to be actual content. If the CSV file contains an initial row of column labels, you can cause the .import command to skip that initial row using the &quot;--skip 1&quot; option.</source>
          <target state="translated">对于第二种情况,当表已经存在时,CSV文件中的每一行,包括第一行,都被假定为实际内容。如果CSV文件包含了第一行的列标签,可以使用&quot;--skip 1 &quot;选项使.import命令跳过第一行。</target>
        </trans-unit>
        <trans-unit id="5d66c18babb7715bc31a6fed2788e6b8d32bfce2" translate="yes" xml:space="preserve">
          <source>For the sqlite3_result_text16(), sqlite3_result_text16le(), and sqlite3_result_text16be() routines, and for sqlite3_result_text64() when the encoding is not UTF8, if the input UTF16 begins with a byte-order mark (BOM, U+FEFF) then the BOM is removed from the string and the rest of the string is interpreted according to the byte-order specified by the BOM. The byte-order specified by the BOM at the beginning of the text overrides the byte-order specified by the interface procedure. So, for example, if sqlite3_result_text16le() is invoked with text that begins with bytes 0xfe, 0xff (a big-endian byte-order mark) then the first two bytes of input are skipped and the remaining input is interpreted as UTF16BE text.</source>
          <target state="translated">对于sqlite3_result_text16()、sqlite3_result_text16le()和sqlite3_result_text16be()例程,以及编码不是UTF8的sqlite3_result_text64()例程,如果输入的UTF16以字节顺序标记(BOM,U+FEFF)开始,那么BOM将从字符串中删除,字符串的其余部分将按照BOM指定的字节顺序进行解释。文本开头的BOM指定的字节顺序会覆盖接口过程指定的字节顺序。因此,例如,如果调用 sqlite3_result_text16le()的文本是以字节 0xfe、0xff(一个大字节序标记)开始的,那么输入的前两个字节将被跳过,其余的输入将被解释为 UTF16BE 文本。</target>
        </trans-unit>
        <trans-unit id="77a61f653acaf4b4de362b5353f3b1f15917923e" translate="yes" xml:space="preserve">
          <source>For the two- and three-argument versions of carray(), the first argument is a pointer to an array. Since pointer values cannot be specified directly in SQL, the first argument must be a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that is bound to a pointer value using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; interface using a pointer-type of &quot;carray&quot;. The second argument is the number of elements in the array. The optional third argument is a string that determines the datatype of the elements in the C-language array. Allowed values for the third argument are:</source>
          <target state="translated">对于carray（）的两个和三个参数版本，第一个参数是指向数组的指针。由于指针值不能直接在SQL中指定，第一个参数必须是一个&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;绑定到使用该指针值&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;接口使用指针型&amp;ldquo;CARRAY&amp;rdquo;的。第二个参数是数组中元素的数量。可选的第三个参数是一个字符串，用于确定C语言数组中元素的数据类型。第三个参数的允许值为：</target>
        </trans-unit>
        <trans-unit id="814f69ac0546d66f0db75207e5064bf283a12829" translate="yes" xml:space="preserve">
          <source>For these reasons, many complex queries may use less memory and run faster using FTS5.</source>
          <target state="translated">由于这些原因,许多复杂的查询可能使用较少的内存,并使用FTS5运行得更快。</target>
        </trans-unit>
        <trans-unit id="7fe943bac7177b3cc26bc016acdb488812414486" translate="yes" xml:space="preserve">
          <source>For these substitutions, the precision is the number of bytes or characters taken from the argument, not the number of bytes or characters that are written into the output.</source>
          <target state="translated">对于这些替换,精度是指从参数中抽取的字节或字符数,而不是写入输出的字节或字符数。</target>
        </trans-unit>
        <trans-unit id="ddecb7fc6ac9ebf678a969f318e2c93050dc15ef" translate="yes" xml:space="preserve">
          <source>For this first experiment, nothing else about the file format is changed. The OpenDocument is still a pile-of-files, only now each file is a row in an SQLite database rather than an entry in a ZIP archive. This simple change does not use the power of a relational database. Even so, this simple change shows some improvements.</source>
          <target state="translated">在第一次实验中,文件格式没有任何其他变化。OpenDocument仍然是一堆文件,只是现在每个文件都是SQLite数据库中的一行,而不是ZIP存档中的一个条目。这个简单的变化并没有使用关系数据库的力量。即便如此,这个简单的变化还是显示出了一些改进。</target>
        </trans-unit>
        <trans-unit id="fbfd34ac3082b66cb73eae2395605bfffd9afee2" translate="yes" xml:space="preserve">
          <source>For this form, the &amp;lt;expr&amp;gt; does not have to be an integer. It can evaluate to a real number as long as it is constant and non-negative.</source>
          <target state="translated">对于这种形式，&amp;lt;expr&amp;gt;不必为整数。只要它是常数且为非负数，它就可以计算为实数。</target>
        </trans-unit>
        <trans-unit id="752d2cd19688f392b69d1efc9ea4707b6423ad4e" translate="yes" xml:space="preserve">
          <source>For this particular UPDATE test, MySQL is consistently five or ten times slower than PostgreSQL and SQLite. I do not know why. MySQL is normally a very fast engine. Perhaps this problem has been addressed in later versions of MySQL.</source>
          <target state="translated">在这个特殊的UPDATE测试中,MySQL的速度始终比PostgreSQL和SQLite慢五到十倍。我不知道为什么。MySQL通常是一个非常快的引擎。也许这个问题在MySQL的以后版本中已经解决了。</target>
        </trans-unit>
        <trans-unit id="9db0e6302461b7556c4838a4a6492fc335414fcc" translate="yes" xml:space="preserve">
          <source>For usage hints and a summary of all options, simply give the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; the -A option with no additional arguments:</source>
          <target state="translated">有关用法提示和所有选项的摘要，只需为&lt;a href=&quot;cli&quot;&gt;CLI提供&lt;/a&gt; -A选项即可，不带其他参数：</target>
        </trans-unit>
        <trans-unit id="c9239816897eb996f78a6efe04536d4eaf0b8d55" translate="yes" xml:space="preserve">
          <source>Force the value in register P1 to be an integer. If the value in P1 is not an integer and cannot be converted into an integer without data loss, then jump immediately to P2, or if P2==0 raise an SQLITE_MISMATCH exception.</source>
          <target state="translated">强制寄存器P1中的值是一个整数。如果P1中的值不是整数,并且不能在不丢失数据的情况下转换为整数,则立即跳转到P2,或者如果P2==0,则引发一个SQLITE_MISMATCH异常。</target>
        </trans-unit>
        <trans-unit id="e1652af1b46a8724b09c6398e58d043cf684e88e" translate="yes" xml:space="preserve">
          <source>Force the value in register P1 to be the type defined by P2.</source>
          <target state="translated">强制寄存器P1中的值为P2定义的类型。</target>
        </trans-unit>
        <trans-unit id="c3788028d350f50070224e2ffa767d1574a8ab2d" translate="yes" xml:space="preserve">
          <source>Foreign Key Constraints</source>
          <target state="translated">外键约束</target>
        </trans-unit>
        <trans-unit id="8ea9876246ba7c653355a0ce27076bc76b4c8469" translate="yes" xml:space="preserve">
          <source>Foreign key ON DELETE and ON UPDATE clauses are used to configure actions that take place when deleting rows from the parent table (ON DELETE), or modifying the parent key values of existing rows (ON UPDATE). A single foreign key constraint may have different actions configured for ON DELETE and ON UPDATE. Foreign key actions are similar to triggers in many ways.</source>
          <target state="translated">外键ON DELETE和ON UPDATE子句用于配置从父表中删除行(ON DELETE)或修改现有行的父键值(ON UPDATE)时发生的操作。一个外键约束可以为ON DELETE和ON UPDATE配置不同的操作。外键操作在很多方面与触发器类似。</target>
        </trans-unit>
        <trans-unit id="474365badbb1f3b57e5eb366037b4f712db8f5d1" translate="yes" xml:space="preserve">
          <source>Foreign key actions</source>
          <target state="translated">国外关键行动</target>
        </trans-unit>
        <trans-unit id="d3465e4f63b19b36c358f39673e35fd218b96287" translate="yes" xml:space="preserve">
          <source>Foreign key constraints are disabled by default (for backwards compatibility), so must be enabled separately for each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. (Note, however, that future releases of SQLite might change so that foreign key constraints enabled by default. Careful developers will not make any assumptions about whether or not foreign keys are enabled by default but will instead enable or disable them as necessary.) The application can also use a &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; statement to determine if foreign keys are currently enabled. The following command-line session demonstrates this:</source>
          <target state="translated">默认情况下，外键约束是禁用的（为了向后兼容），因此必须分别为每个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;启用外键约束。（但是请注意，SQLite的未来版本可能会更改，从而默认情况下会启用外键约束。谨慎的开发人员不会对默认情况下是否启用外键做出任何假设，而是根据需要启用或禁用它们。）应用程序还可以使用&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt;语句来确定当前是否启用了外键。以下命令行会话对此进行了演示：</target>
        </trans-unit>
        <trans-unit id="fadb49ecb31870fa195b79a63507d69332246c87" translate="yes" xml:space="preserve">
          <source>Foreign key constraints are enabled</source>
          <target state="translated">启用外键约束</target>
        </trans-unit>
        <trans-unit id="ce28942b103c42389428127f519c6795e562c011" translate="yes" xml:space="preserve">
          <source>Format 1 is understood by all versions of SQLite back to &lt;a href=&quot;https://sqlite.org/releaselog/3_0_0.html&quot;&gt;version 3.0.0&lt;/a&gt; (2004-06-18).</source>
          <target state="translated">回到&lt;a href=&quot;https://sqlite.org/releaselog/3_0_0.html&quot;&gt;版本3.0.0&lt;/a&gt;（2004-06-18），SQLite的所有版本都可以理解格式1 。</target>
        </trans-unit>
        <trans-unit id="bb846b850c6fa3ff33f8d13f455d688d28aa22d8" translate="yes" xml:space="preserve">
          <source>Format 2 adds the ability of rows within the same table to have a varying number of columns, in order to support the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; functionality. Support for reading and writing format 2 was added in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_1_3.html&quot;&gt;version 3.1.3&lt;/a&gt; on 2005-02-20.</source>
          <target state="translated">格式2增加了同一表中的行具有可变数量的列的能力，以支持&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt;功能。在2005-02-20的SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_1_3.html&quot;&gt;版本3.1.3中&lt;/a&gt;添加了对读写格式2的支持。</target>
        </trans-unit>
        <trans-unit id="e74a0202e30c00da07d8e3f647ad619d797750ee" translate="yes" xml:space="preserve">
          <source>Format 3 adds the ability of extra columns added by &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; to have non-NULL default values. This capability was added in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_1_4.html&quot;&gt;version 3.1.4&lt;/a&gt; on 2005-03-11.</source>
          <target state="translated">格式3增加了&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt;添加的额外列以具有非NULL默认值的功能。此功能已在2005-03-11的SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_1_4.html&quot;&gt;版本3.1.4中&lt;/a&gt;添加。</target>
        </trans-unit>
        <trans-unit id="6f87214a5c89d4a264dcabc8b3ff76d0ecb7e6ab" translate="yes" xml:space="preserve">
          <source>Format 4 causes SQLite to respect the &lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC keyword&lt;/a&gt; on index declarations. (The DESC keyword is ignored in indexes for formats 1, 2, and 3.) Format 4 also adds two new boolean record type values (&lt;a href=&quot;fileformat2#serialtype&quot;&gt;serial types&lt;/a&gt; 8 and 9). Support for format 4 was added in SQLite 3.3.0 on 2006-01-10.</source>
          <target state="translated">格式4导致SQLite 在索引声明中遵守&lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC关键字&lt;/a&gt;。（格式1、2和3的索引中忽略了DESC关键字。）格式4还添加了两个新的布尔记录类型值（&lt;a href=&quot;fileformat2#serialtype&quot;&gt;串行类型&lt;/a&gt; 8和9）。在2006-01-10的SQLite 3.3.0中添加了对格式4的支持。</target>
        </trans-unit>
        <trans-unit id="d2e4ea8f983e7648b4500b3c2517f1581f43edb0" translate="yes" xml:space="preserve">
          <source>Formats 2 through 10 may be optionally followed by a timezone indicator of the form &quot;</source>
          <target state="translated">格式2至10后面可选择加上&quot;&quot;的时区指示符。</target>
        </trans-unit>
        <trans-unit id="ff2a0eb4d03de61d70053787eab6804fcec445da" translate="yes" xml:space="preserve">
          <source>Formatted String Printing Functions</source>
          <target state="translated">格式化字符串打印功能</target>
        </trans-unit>
        <trans-unit id="73cdbab7825af4beabbe4e8fccce8b346886e89f" translate="yes" xml:space="preserve">
          <source>Fossil gives me peace of mind that I have everything ... synced to the server with a single command.... I never get this peace of mind with git.</source>
          <target state="translated">Fossil让我安心,因为我有所有的东西......只需一个命令就能同步到服务器上......。我从来没有在git上得到这样的安心。</target>
        </trans-unit>
        <trans-unit id="968f45bf8ccf7ca67b780b2bdd22df3354350003" translate="yes" xml:space="preserve">
          <source>Fossil is a completely stand-alone program, so install it simply by putting the &quot;fossil&quot; or &quot;fossil.exe&quot; executable someplace on your $PATH or %PATH%. After you have Fossil installed, do this:</source>
          <target state="translated">Fossil是一个完全独立的程序,所以只要把 &quot;fossil &quot;或 &quot;fossil.exe &quot;可执行文件放在$PATH或%PATH%的某个地方就可以安装了。当你安装好Fossil后,请这样做。</target>
        </trans-unit>
        <trans-unit id="94257cd970f113fc11ecc5cc6011f7bfff67e319" translate="yes" xml:space="preserve">
          <source>Fossil is easy to install and use. Here are the steps for unix. (Windows is similar.)</source>
          <target state="translated">Fossil很容易安装和使用。以下是unix的安装步骤。(Windows也是类似的。)</target>
        </trans-unit>
        <trans-unit id="233904fc6b6c8ee70d33af66e4cb04bfc0af5c1f" translate="yes" xml:space="preserve">
          <source>Fossil vs. Git</source>
          <target state="translated">Fossil vs.Git</target>
        </trans-unit>
        <trans-unit id="bbba84135de6b052c2210e74e0cc5b2a9d359ddb" translate="yes" xml:space="preserve">
          <source>Found</source>
          <target state="translated">Found</target>
        </trans-unit>
        <trans-unit id="71c33b1cffd26b04e4533bd5c542bd8028125150" translate="yes" xml:space="preserve">
          <source>Four independently developed test harnesses</source>
          <target state="translated">四个独立开发的测试线束</target>
        </trans-unit>
        <trans-unit id="a9521a3d73988a064707ebf1e7a52b3d8155b49c" translate="yes" xml:space="preserve">
          <source>Frame boundary</source>
          <target state="translated">框架边界</target>
        </trans-unit>
        <trans-unit id="77433082b8e51b0f02140d5bb2ad80c6960db0b1" translate="yes" xml:space="preserve">
          <source>Frame type</source>
          <target state="translated">框架类型</target>
        </trans-unit>
        <trans-unit id="6e84d556b35797f261b67f9c140d77ba6a16046e" translate="yes" xml:space="preserve">
          <source>Free Memory Used By A Database Connection</source>
          <target state="translated">数据库连接使用的自由内存</target>
        </trans-unit>
        <trans-unit id="c3f00513ee103316a9c102f8d540f97f3d93a05d" translate="yes" xml:space="preserve">
          <source>Freelist leaf pages contain no information. SQLite avoids reading or writing freelist leaf pages in order to reduce disk I/O.</source>
          <target state="translated">自由列表叶页不包含任何信息。SQLite为了减少磁盘I/O,避免读取或写入自由列表叶页。</target>
        </trans-unit>
        <trans-unit id="71c292b702c9c6ddbea2af4ccdda270456dc5dd4" translate="yes" xml:space="preserve">
          <source>Frequent inserts, updates, and deletes can cause the database file to become fragmented - where data for a single table or index is scattered around the database file. Running VACUUM ensures that each table and index is largely stored contiguously within the database file. In some cases, VACUUM may also reduce the number of partially filled pages in the database, reducing the size of the database file further.</source>
          <target state="translated">频繁的插入、更新和删除可能会导致数据库文件变得支离破碎--单个表或索引的数据分散在数据库文件中。运行VACUUM可以确保每张表和索引在很大程度上连续地存储在数据库文件中。在某些情况下,VACUUM还可以减少数据库中部分填充页的数量,进一步减少数据库文件的大小。</target>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="translated">常问问题</target>
        </trans-unit>
        <trans-unit id="4dca8789d725335eabc320e5fd334c48abe46050" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;, extensions can be loaded using the &quot;.load&quot; dot-command. For example:</source>
          <target state="translated">从&lt;a href=&quot;cli&quot;&gt;命令行壳&lt;/a&gt;，扩展可以使用&amp;ldquo;.load&amp;rdquo;点命令被装载。例如：</target>
        </trans-unit>
        <trans-unit id="6903644a3137edfb56bf4bdd853677416b4353b6" translate="yes" xml:space="preserve">
          <source>From the CLI, use the &quot;.filectrl reserve_bytes 8&quot; command, followed by &quot;VACUUM;&quot;.</source>
          <target state="translated">从CLI中,使用&quot;.filectrl reserve_bytes 8 &quot;命令,然后是 &quot;VACUUM;&quot;。</target>
        </trans-unit>
        <trans-unit id="ff5ff3b531fe7fa32b7f8abc7b75b72320738d38" translate="yes" xml:space="preserve">
          <source>From the point of view of SQL, STORED and VIRTUAL columns are almost exactly the same. Queries against either class of generated column produce the same results. The only functional difference is that one cannot add new STORED columns using the &lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;ALTER TABLE ADD COLUMN&lt;/a&gt; command. Only VIRTUAL columns can be added using ALTER TABLE.</source>
          <target state="translated">从SQL的角度来看，STORED和VIRTUAL列几乎完全相同。对任一类生成的列的查询都会产生相同的结果。唯一的功能差异是，不能使用&lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;ALTER TABLE ADD COLUMN&lt;/a&gt;命令添加新的STORED列。使用ALTER TABLE只能添加VIRTUAL列。</target>
        </trans-unit>
        <trans-unit id="9622d74f0a066cde3991b933210f9d9f6547b468" translate="yes" xml:space="preserve">
          <source>From the point of view of a single process, a database file can be in one of five locking states:</source>
          <target state="translated">从单个进程的角度来看,一个数据库文件可以处于五种锁定状态之一。</target>
        </trans-unit>
        <trans-unit id="f2bf6ce9c451768f240ac82fe10e69d266839161" translate="yes" xml:space="preserve">
          <source>From the point of view of the uppers layers of the SQLite stack, each open database file uses exactly one VFS. But in practice, a particular VFS might just be a thin wrapper around another VFS that does the real work. We call a wrapper VFS a &quot;shim&quot;.</source>
          <target state="translated">从SQLite堆栈上层的角度来看,每个打开的数据库文件正好使用一个VFS。但在实践中,一个特定的VFS可能只是另一个做真正工作的VFS的薄包装。我们把一个包装器VFS称为 &quot;shim&quot;。</target>
        </trans-unit>
        <trans-unit id="b51b364d89abfa3baa92bcc31eb6e45de7419ef6" translate="yes" xml:space="preserve">
          <source>From the users point of view, FTS tables are similar to ordinary SQLite tables in many ways. Data may be added to, modified within and removed from FTS tables using the INSERT, UPDATE and DELETE commands just as it may be with ordinary tables. Similarly, the SELECT command may be used to query data. The following list summarizes the differences between FTS and ordinary tables:</source>
          <target state="translated">从用户的角度来看,FTS表在很多方面与普通的SQLite表相似。可以使用INSERT、UPDATE和DELETE命令在FTS表中添加、修改和删除数据,就像在普通表中一样。同样,SELECT命令也可以用来查询数据。下面的列表总结了FTS表和普通表之间的区别。</target>
        </trans-unit>
        <trans-unit id="27c4a8e9b8642a933f67723d0e4be1b9a0f44d80" translate="yes" xml:space="preserve">
          <source>From this we get the following output</source>
          <target state="translated">由此,我们得到以下输出</target>
        </trans-unit>
        <trans-unit id="2180268f2a9a9fda782b57bf8e01a18a029a7a96" translate="yes" xml:space="preserve">
          <source>Fulfill God's commandments daily in your deeds.</source>
          <target state="translated">在你的行为中每天履行上帝的诫命。</target>
        </trans-unit>
        <trans-unit id="b471a096b84cc0494684e033a051e31af5d4baaa" translate="yes" xml:space="preserve">
          <source>Fulfill not the desires of the flesh; hate your own will.</source>
          <target state="translated">不要满足肉体的欲望,恨自己的意志。</target>
        </trans-unit>
        <trans-unit id="c55154da9bee9185f44dff21df8abc2c3aabdcae" translate="yes" xml:space="preserve">
          <source>Full unicode case folding is supported in SQLite if it is compiled with the &lt;a href=&quot;compile#enable_icu&quot;&gt;-DSQLITE_ENABLE_ICU&lt;/a&gt; option and linked against the &lt;a href=&quot;http://site.icu-project.org/&quot;&gt;International Components for Unicode&lt;/a&gt; library.</source>
          <target state="translated">如果使用&lt;a href=&quot;compile#enable_icu&quot;&gt;-DSQLITE_ENABLE_ICU&lt;/a&gt;选项编译并与&lt;a href=&quot;http://site.icu-project.org/&quot;&gt;Unicode国际组件&lt;/a&gt;库链接，则SQLite支持完全Unicode大小写折叠。</target>
        </trans-unit>
        <trans-unit id="90b0c8025a15a6f38263adcf72861e6ab67a9305" translate="yes" xml:space="preserve">
          <source>Full-Featured SQL</source>
          <target state="translated">全功能的SQL</target>
        </trans-unit>
        <trans-unit id="9e0f1c37b71547a59fac0e69533c4df840ff38fe" translate="yes" xml:space="preserve">
          <source>Full-Text Search</source>
          <target state="translated">全文检索</target>
        </trans-unit>
        <trans-unit id="369603a7ebe96771eca2b1d07435e9996bd963f3" translate="yes" xml:space="preserve">
          <source>Full-text search</source>
          <target state="translated">全文检索</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="9365da4d7427ae049cd7228599ffdbf56ca765df" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt; is called to clean up resources allocated by &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt;.</source>
          <target state="translated">调用函数&lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish（）&lt;/a&gt;清理由&lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init（）&lt;/a&gt;分配的资源。</target>
        </trans-unit>
        <trans-unit id="6ee739a58d0601e439d67d32ce677eb6f284f6f0" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; is called to create an &lt;a href=&quot;c3ref/backup&quot;&gt;sqlite3_backup&lt;/a&gt; object to copy data between the two databases (either from a file and into the in-memory database, or vice-versa).</source>
          <target state="translated">调用函数&lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init（）&lt;/a&gt;创建一个&lt;a href=&quot;c3ref/backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象，以在两个数据库之间复制数据（从文件复制到内存数据库，反之亦然）。</target>
        </trans-unit>
        <trans-unit id="3518bc62cbd77290edb8df852902f3d26b669db7" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; is called to create an &lt;a href=&quot;c3ref/backup&quot;&gt;sqlite3_backup&lt;/a&gt; object to copy data from database pDb to the backup database file identified by zFilename.</source>
          <target state="translated">调用函数&lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init（）&lt;/a&gt;创建一个&lt;a href=&quot;c3ref/backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象，以将数据从数据库pDb复制到zFilename标识的备份数据库文件。</target>
        </trans-unit>
        <trans-unit id="391bd2c3bef8e5815ac8dc9e143dc5e9f29edc4b" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; is called with a parameter of 5 to copy 5 pages of database pDb to the backup database (file zFilename).</source>
          <target state="translated">使用参数5调用函数&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（）&lt;/a&gt;可以将数据库pDb的5页复制到备份数据库（文件zFilename）。</target>
        </trans-unit>
        <trans-unit id="38d0016fe914d4211802e56c1b039ba739bf3a21" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; is called with a parameter of &lt;code&gt;-1&lt;/code&gt; to copy the entire source database to the destination.</source>
          <target state="translated">使用参数 &lt;code&gt;-1&lt;/code&gt; 调用函数&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（）&lt;/a&gt;可以将整个源数据库复制到目标。</target>
        </trans-unit>
        <trans-unit id="a019467e942226e7593baeafe04451d52208ddbd" translate="yes" xml:space="preserve">
          <source>Function Auxiliary Data</source>
          <target state="translated">功能辅助数据</target>
        </trans-unit>
        <trans-unit id="95b0294dd891e754097881615649b65fc6ba31c5" translate="yes" xml:space="preserve">
          <source>Function Flags</source>
          <target state="translated">功能标志</target>
        </trans-unit>
        <trans-unit id="17555700d9f22f47c91cbb0e6dcdac3a03a90e07" translate="yes" xml:space="preserve">
          <source>Function implementations use the following APIs to acquire context and to report results:</source>
          <target state="translated">函数实现使用以下API来获取上下文并报告结果。</target>
        </trans-unit>
        <trans-unit id="7db899803172ac5c12cb30190a927b06044d501c" translate="yes" xml:space="preserve">
          <source>Function sqlite3_backup_step(B,N) will copy up to N pages between the source and destination databases specified by &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object B. If N is negative, all remaining source pages are copied. If sqlite3_backup_step(B,N) successfully copies N pages and there are still more pages to be copied, then the function returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;. If sqlite3_backup_step(B,N) successfully finishes copying all pages from source to destination, then it returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. If an error occurs while running sqlite3_backup_step(B,N), then an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned. As well as &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, a call to sqlite3_backup_step() may return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt;, or an &lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt; extended error code.</source>
          <target state="translated">函数sqlite3_backup_step（B，N）将在&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象B 指定的源数据库和目标数据库之间最多复制N个页面。如果N为负，则将复制所有剩余的源页面。如果sqlite3_backup_step（B，N）成功复制了N页，并且还有更多页面要复制，则该函数返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;。如果sqlite3_backup_step（B，N）成功完成了将所有页面从源复制到目标的操作，则返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;。如果在运行sqlite3_backup_step（B，N）时发生&lt;a href=&quot;rescode&quot;&gt;错误，&lt;/a&gt;则返回错误代码。与&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;和&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE一样&lt;/a&gt;，对sqlite3_backup_step（）的调用也可能返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;扩展错误代码。</target>
        </trans-unit>
        <trans-unit id="9255837a8368562d39b56b025c25a117e386acd6" translate="yes" xml:space="preserve">
          <source>Function sqlite3_backup_step(B,N) will copy up to N pages between the source and destination databases specified by &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object B. If N is negative, all remaining source pages are copied. If sqlite3_backup_step(B,N) successfully copies N pages and there are still more pages to be copied, then the function returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;. If sqlite3_backup_step(B,N) successfully finishes copying all pages from source to destination, then it returns &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. If an error occurs while running sqlite3_backup_step(B,N), then an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned. As well as &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; and &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, a call to sqlite3_backup_step() may return &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;, &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;, or an &lt;a href=&quot;../rescode#ioerr_access&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt; extended error code.</source>
          <target state="translated">函数sqlite3_backup_step（B，N）将在&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;对象B 指定的源数据库和目标数据库之间最多复制N个页面。如果N为负，则将复制所有剩余的源页面。如果sqlite3_backup_step（B，N）成功复制了N页，并且还有更多页面要复制，则该函数返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。如果sqlite3_backup_step（B，N）成功完成了将所有页面从源复制到目标的操作，则返回&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;。如果在运行sqlite3_backup_step（B，N）时发生&lt;a href=&quot;../rescode&quot;&gt;错误，&lt;/a&gt;则返回错误代码。与&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;和&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE一样&lt;/a&gt;，对sqlite3_backup_step（）的调用也可能返回&lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;，&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;，&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;，&lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;或&lt;a href=&quot;../rescode#ioerr_access&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;扩展错误代码。</target>
        </trans-unit>
        <trans-unit id="02506e4ca51a17167d74a2f8b901e6d46a621915" translate="yes" xml:space="preserve">
          <source>Function sqlite3rbu_step() is called on the RBU handle until either the RBU vacuum is finished, an error occurs or the application wishes to suspend the RBU vacuum.</source>
          <target state="translated">函数 sqlite3rbu_step()在 RBU 句柄上被调用,直到 RBU 真空结束、发生错误或应用程序希望暂停 RBU 真空。</target>
        </trans-unit>
        <trans-unit id="c29dbde42f9e09b5fa1fe9e874978bd60461ca23" translate="yes" xml:space="preserve">
          <source>Function0</source>
          <target state="translated">Function0</target>
        </trans-unit>
        <trans-unit id="885fce7082ac7fe77b80dbde8d190b12ddbee6ea" translate="yes" xml:space="preserve">
          <source>Functionality Testing</source>
          <target state="translated">功能测试</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="5a1198fbca49df3b9353761343f6ab00ba7526e3" translate="yes" xml:space="preserve">
          <source>Functions:</source>
          <target state="translated">Functions:</target>
        </trans-unit>
        <trans-unit id="1ddc4309220e5ca80653bda487622cf643ea376d" translate="yes" xml:space="preserve">
          <source>Fundamental Datatypes</source>
          <target state="translated">基本数据类型</target>
        </trans-unit>
        <trans-unit id="f728c83ebd508ddfa64fa9b670d3c24c116a1c08" translate="yes" xml:space="preserve">
          <source>Further performance improves can be made by using the &lt;a href=&quot;mmap&quot;&gt;memory-mapped I/O&lt;/a&gt; feature of SQLite. In the next chart, the entire 1GB database file is memory mapped and blobs are read (in random order) using the &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; interface. With these optimizations, SQLite is twice as fast as Android or MacOS-X and over 10 times faster than Windows.</source>
          <target state="translated">通过使用SQLite 的&lt;a href=&quot;mmap&quot;&gt;内存映射I / O&lt;/a&gt;功能，可以进一步提高性能。在下一张图表中，整个1GB数据库文件都进行了内存映射，并使用&lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;接口读取了blob（以随机顺序）。通过这些优化，SQLite的速度是Android或MacOS-X的两倍，是Windows的十倍以上。</target>
        </trans-unit>
        <trans-unit id="215d209e37d2a11fed7e914dfee16f71ee55be90" translate="yes" xml:space="preserve">
          <source>Further suppose that column x contains values spread out between 0 and 1,000,000 and column y contains values that span between 0 and 1,000. In that scenario, the range constraint on column x should reduce the search space by a factor of 10,000 whereas the range constraint on column y should reduce the search space by a factor of only 10. So the ex2i1 index should be preferred.</source>
          <target state="translated">进一步假设x列包含的值分布在0到1,000,000之间,y列包含的值在0到1,000之间。在这种情况下,列x的范围约束应该减少10,000倍的搜索空间,而列y的范围约束应该只减少10倍的搜索空间。所以,应该首选ex2i1索引。</target>
        </trans-unit>
        <trans-unit id="09aabcfb38f7cb10806136de02a602b19c076fd6" translate="yes" xml:space="preserve">
          <source>Further to keeping &lt;b&gt;n&lt;/b&gt; small, one desires to keep the size of the largest memory allocations under control. Large requests to the general-purpose memory allocator might come from several sources:</source>
          <target state="translated">除了使&lt;b&gt;n&lt;/b&gt;较小之外，还希望将最大内存分配的大小保持在可控制的范围内。对通用内存分配器的大请求可能来自以下几个来源：</target>
        </trans-unit>
        <trans-unit id="4a74f247651044b2313a36316a7929616b6d570a" translate="yes" xml:space="preserve">
          <source>Furthermore, a single SQLite database holding 10-kilobyte blobs uses about 20% less disk space than storing the blobs in individual files.</source>
          <target state="translated">此外,与在单个文件中存储blobs相比,单个SQLite数据库持有10-kilobyte blobs所使用的磁盘空间减少了20%。</target>
        </trans-unit>
        <trans-unit id="8bd50359d3a17558a2d398e2f44b82ca134e4e80" translate="yes" xml:space="preserve">
          <source>Future releases may add new output columns and may change the order of legacy columns. Further detail about the meaning of each column in the SQLITE_STMT virtual table is provided below:</source>
          <target state="translated">未来的版本可能会增加新的输出列,也可能会改变传统列的顺序。下面将进一步详细介绍SQLITE_STMT虚拟表中各列的含义。</target>
        </trans-unit>
        <trans-unit id="6831b46470717c86c7d25cb9cedff9f9bee20302" translate="yes" xml:space="preserve">
          <source>Future releases of SQLite might enable those interfaces by default and instead offer an SQLITE_OMIT_DESERIALIZE option to leave them out.</source>
          <target state="translated">SQLite未来的版本可能会默认启用这些接口,而提供一个SQLITE_OMIT_DESERIALIZE选项来不使用它们。</target>
        </trans-unit>
        <trans-unit id="69eed414fd6ede90f6e232a4b640df2129c7213e" translate="yes" xml:space="preserve">
          <source>Future versions of SQLite may extend the list of errors which might cause automatic transaction rollback. Future versions of SQLite might change the error response. In particular, we may choose to simplify the interface in future versions of SQLite by causing the errors above to force an unconditional rollback.</source>
          <target state="translated">SQLite的未来版本可能会扩展可能导致自动事务回滚的错误列表。未来版本的SQLite可能会改变错误响应。特别是,我们可能会选择在未来版本的SQLite中简化接口,使上述错误强制进行无条件回滚。</target>
        </trans-unit>
        <trans-unit id="b0b58ce3a5e420ed148b6052399ca3a065dfe3cb" translate="yes" xml:space="preserve">
          <source>Future versions of SQLite might enable the batch-atomic-write capability by default, at which point this compile-time option will become superfluous.</source>
          <target state="translated">未来的SQLite版本可能会默认启用批处理原子写入功能,这时这个编译时选项将变得多余。</target>
        </trans-unit>
        <trans-unit id="75a65696cc2dd88673f048a8e620acbe3511d286" translate="yes" xml:space="preserve">
          <source>Fuzz testing and &lt;a href=&quot;testing#mcdc&quot;&gt;100% MC/DC testing&lt;/a&gt; are in tension with one another. That is to say, code tested to 100% MC/DC will tend to be more vulnerable to problems found by fuzzing and code that performs well during fuzz testing will tend to have (much) less than 100% MC/DC. This is because MC/DC testing discourages &lt;a href=&quot;testing#defcode&quot;&gt;defensive code&lt;/a&gt; with unreachable branches, but without defensive code, a fuzzer is more likely to find a path that causes problems. MC/DC testing seems to work well for building code that is robust during typical normal use, whereas fuzz testing is good for building code that is robust against malicious attack.</source>
          <target state="translated">模糊测试和&lt;a href=&quot;testing#mcdc&quot;&gt;100％MC / DC测试&lt;/a&gt;相互矛盾。也就是说，经过100％MC / DC测试的代码将更容易受到模糊测试发现的问题的影响，而在模糊测试过程中执行良好的代码往往具有（远远）少于100％MC / DC的代码。这是因为MC / DC测试会阻止具有无法到达的分支的&lt;a href=&quot;testing#defcode&quot;&gt;防御代码&lt;/a&gt;，但如果没有防御代码，则模糊测试者更有可能找到引起问题的路径。 MC / DC测试对于在常规正常使用期间构建健壮的代码似乎效果很好，而模糊测试对于构建可抵抗恶意攻击的健壮代码非常有用。</target>
        </trans-unit>
        <trans-unit id="7aac4860a695a884103c23bef4fe10cea8ac21a0" translate="yes" xml:space="preserve">
          <source>Fuzz tests</source>
          <target state="translated">模糊测试</target>
        </trans-unit>
        <trans-unit id="cbf13864eb622e042fd70afc25b332a98febed1d" translate="yes" xml:space="preserve">
          <source>GCC-7 generates binaries that are smaller and faster than GCC-5, though the difference is not that great.</source>
          <target state="translated">GCC-7生成的二进制文件比GCC-5更小,速度更快,虽然差别不大。</target>
        </trans-unit>
        <trans-unit id="82cb2940a14f458fe56d211dffdcd12595e8b940" translate="yes" xml:space="preserve">
          <source>GENERATED</source>
          <target state="translated">GENERATED</target>
        </trans-unit>
        <trans-unit id="3c1c8852a41864ea17cea1296e10f38e7d36f590" translate="yes" xml:space="preserve">
          <source>GIT - Git source code repository</source>
          <target state="translated">GIT-Git源码库</target>
        </trans-unit>
        <trans-unit id="801660e770a91f34fb13ac91a9b5cbd2d98c6d3a" translate="yes" xml:space="preserve">
          <source>GLOB</source>
          <target state="translated">GLOB</target>
        </trans-unit>
        <trans-unit id="1c7b7596d6e95628f77205b04009e825c56ebd5f" translate="yes" xml:space="preserve">
          <source>GLOB(</source>
          <target state="translated">GLOB(</target>
        </trans-unit>
        <trans-unit id="ea5a383494f81c4f464965d03bf916c41d68ced5" translate="yes" xml:space="preserve">
          <source>GROUP</source>
          <target state="translated">GROUP</target>
        </trans-unit>
        <trans-unit id="992f3cd91fffb522eba0b5e27b68c643f2967283" translate="yes" xml:space="preserve">
          <source>GROUP BY now considers NULLs to be equal again, as it should</source>
          <target state="translated">GROUP BY现在认为NULLs又是相等的,因为它应该是</target>
        </trans-unit>
        <trans-unit id="1f8969d436579977f5b13e27e290ffdb25736672" translate="yes" xml:space="preserve">
          <source>GROUPS</source>
          <target state="translated">GROUPS</target>
        </trans-unit>
        <trans-unit id="47abf252888b506642430a87f17ad2e364853ea7" translate="yes" xml:space="preserve">
          <source>GROUPS frames</source>
          <target state="translated">集团框架</target>
        </trans-unit>
        <trans-unit id="5023fde21a93efcc45f3ef1278a03020db274d7f" translate="yes" xml:space="preserve">
          <source>Ge</source>
          <target state="translated">Ge</target>
        </trans-unit>
        <trans-unit id="5f5383c13d2f60a6733afafdeaf91505cfcc253b" translate="yes" xml:space="preserve">
          <source>Generalized ALTER TABLE procedure</source>
          <target state="translated">通用ALTER TABLE程序</target>
        </trans-unit>
        <trans-unit id="200f1a824c74356136271be8f5cec761b8361890" translate="yes" xml:space="preserve">
          <source>Generalized the IS and IS NOT operators to take arbitrary expressions on their right-hand side.</source>
          <target state="translated">归纳了IS和IS NOT运算符,在其右侧取任意表达式。</target>
        </trans-unit>
        <trans-unit id="b3419155244f27d32ab3d7f4be3add6bd08da9d5" translate="yes" xml:space="preserve">
          <source>Generally speaking, there are three separate subsystems within SQLite that can be modified or overridden at compile-time. The mutex subsystem is used to serialize access to SQLite resources that are shared among threads. The memory allocation subsystem is used to allocate memory required by SQLite objects and for the database cache. Finally, the &lt;a href=&quot;c3ref/vfs&quot;&gt;Virtual File System&lt;/a&gt; subsystem is used to provide a portable interface between SQLite and the underlying operating system and especially the file system. We call these three subsystems the &quot;interface&quot; subsystems of SQLite.</source>
          <target state="translated">一般来说，SQLite中有三个独立的子系统，可以在编译时对其进行修改或覆盖。互斥锁子系统用于序列化对线程之间共享的SQLite资源的访问。内存分配子系统用于分配SQLite对象所需的内存以及数据库缓存。最后，&lt;a href=&quot;c3ref/vfs&quot;&gt;虚拟文件系统&lt;/a&gt;子系统用于在SQLite与底层操作系统（尤其是文件系统）之间提供可移植的接口。我们将这三个子系统称为SQLite的&amp;ldquo;接口&amp;rdquo;子系统。</target>
        </trans-unit>
        <trans-unit id="03b11aad395b9bb3b854450c1f0acff0112439bd" translate="yes" xml:space="preserve">
          <source>Generate A Changeset From A Session Object</source>
          <target state="translated">从一个会话对象生成一个变更集</target>
        </trans-unit>
        <trans-unit id="771f6c81129288bd0dca35edc653f4896b8a38b9" translate="yes" xml:space="preserve">
          <source>Generate A Patchset From A Session Object</source>
          <target state="translated">从一个会话对象生成一个补丁集</target>
        </trans-unit>
        <trans-unit id="c543fcc61a656cc087657032229c13b299493cc4" translate="yes" xml:space="preserve">
          <source>Generate all multiples of 5 less than or equal to 100:</source>
          <target state="translated">生成所有小于或等于100的5的倍数。</target>
        </trans-unit>
        <trans-unit id="79e208b13cb09ea92286261229fb60357b5683cd" translate="yes" xml:space="preserve">
          <source>Generate the 20 random integer values:</source>
          <target state="translated">生成20个随机整数值。</target>
        </trans-unit>
        <trans-unit id="9dcf1fb2a5619d507a1603ea13343b634907fbb2" translate="yes" xml:space="preserve">
          <source>Generated Columns</source>
          <target state="translated">生成的栏目</target>
        </trans-unit>
        <trans-unit id="3b3deb85df4120a8071cbc650ea3ae19018a4333" translate="yes" xml:space="preserve">
          <source>Generated column support was added with SQLite version 3.31.0 (2020-01-22). If an earlier version of SQLite attempts to read a database file that contains a generated column in its schema, then that earlier version will perceive the generated column syntax as an error and will report that the database schema is corrupt.</source>
          <target state="translated">SQLite 3.31.0版本(2020-01-22)增加了对生成列的支持。如果早期版本的SQLite试图读取在其模式中包含生成列的数据库文件,那么该早期版本将把生成列语法视为错误,并报告数据库模式已损坏。</target>
        </trans-unit>
        <trans-unit id="c59ac7eefe310c7eaf8ae1fb3f3e6b896d5ce55b" translate="yes" xml:space="preserve">
          <source>Generated columns (also sometimes called &quot;computed columns&quot;) are columns of a table whose values are a function of other columns in the same row. Generated columns can be read, but their values can not be directly written. The only way to change the value of a generated columns is to modify the values of the other columns used to calculate the generated column.</source>
          <target state="translated">生成列(有时也称为 &quot;计算列&quot;)是表的列,其值是同一行中其他列的函数。生成的列可以被读取,但其值不能直接写入。改变生成列的值的唯一方法是修改用于计算生成列的其他列的值。</target>
        </trans-unit>
        <trans-unit id="613988a16b967b99c8a2f926ff4d13b7eddfac88" translate="yes" xml:space="preserve">
          <source>Generated columns can be either VIRTUAL or STORED. The value of a VIRTUAL column is computed when read, whereas the value of a STORED column is computed when the row is written. STORED columns take up space in the database file, whereas VIRTUAL columns use more CPU cycles when being read.</source>
          <target state="translated">生成的列可以是VIRTUAL或STORED。VIRTUAL列的值是在读取时计算的,而STORED列的值是在写入行时计算的。STORED列会占用数据库文件的空间,而VIRTUAL列在读取时则会消耗更多的CPU周期。</target>
        </trans-unit>
        <trans-unit id="0fde6a8fefb61e82381c1e844ca8702bbbc5ba1c" translate="yes" xml:space="preserve">
          <source>Generated columns can have a datatype. SQLite attempts to transform the result of the generating expression into that datatype using the same &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; rules as for ordinary columns.</source>
          <target state="translated">生成的列可以具有数据类型。SQLite尝试使用与普通列相同的&lt;a href=&quot;datatype3#affinity&quot;&gt;相似性&lt;/a&gt;规则将生成表达式的结果转换为该数据类型。</target>
        </trans-unit>
        <trans-unit id="e1d6649f6ec01140193b6e648ec42a6a867ba587" translate="yes" xml:space="preserve">
          <source>Generated columns can occur anywhere in the table definition. Generated columns can be interspersed among ordinary columns. It not necessary to put generated columns at the end of the list of columns in the table definition, as is shown in the examples above.</source>
          <target state="translated">生成的列可以出现在表定义中的任何地方。生成的列可以穿插在普通列中。在表定义中,不一定要把生成列放在列列表的最后,如上面的例子所示。</target>
        </trans-unit>
        <trans-unit id="9875bfbfef5aba511d2dd9b6e525a5c3e0f9c8f2" translate="yes" xml:space="preserve">
          <source>Generated columns can participate in indexes, just like ordinary columns.</source>
          <target state="translated">生成的列可以像普通列一样参与索引。</target>
        </trans-unit>
        <trans-unit id="b522a1b95a8f0aac208b624ac7b6724dbe6c7ead" translate="yes" xml:space="preserve">
          <source>Generated columns may have NOT NULL, CHECK, and UNIQUE constraints, and foreign key constraints, just like ordinary columns.</source>
          <target state="translated">生成的列可以有NOT NULL、CHECK、UNIQUE约束和外键约束,就像普通列一样。</target>
        </trans-unit>
        <trans-unit id="e05f34af704863b4507d2249a94ca054ec8257fa" translate="yes" xml:space="preserve">
          <source>Generated columns may not be used as part of the &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;. (Future versions of SQLite might relax this constraint for STORED columns.)</source>
          <target state="translated">生成的列不能用作&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY的&lt;/a&gt;一部分。（SQLite的未来版本可能会放宽对STORED列的此约束。）</target>
        </trans-unit>
        <trans-unit id="ba0525985bb25123382021b46e1798312b30907c" translate="yes" xml:space="preserve">
          <source>Generated columns may not have a &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default value&lt;/a&gt; (they may not use the &quot;DEFAULT&quot; clause). The value of a generated column is always the value specified by the expression that follows the &quot;AS&quot; keyword.</source>
          <target state="translated">生成的列可能没有&lt;a href=&quot;lang_createtable#dfltval&quot;&gt;默认值&lt;/a&gt;（它们可能不使用&amp;ldquo; DEFAULT&amp;rdquo;子句）。生成的列的值始终是&amp;ldquo; AS&amp;rdquo;关键字后面的表达式所指定的值。</target>
        </trans-unit>
        <trans-unit id="46614740c9601066a8714b11664b1eb75a5a0bb4" translate="yes" xml:space="preserve">
          <source>Generating the results of a simple SELECT statement is presented as a four step process in the description below:</source>
          <target state="translated">生成一个简单的SELECT语句的结果在下面的描述中以四个步骤的方式呈现。</target>
        </trans-unit>
        <trans-unit id="0060bdc4470d529ca18bce37edc0d7a0701d9b10" translate="yes" xml:space="preserve">
          <source>Geopoly</source>
          <target state="translated">Geopoly</target>
        </trans-unit>
        <trans-unit id="c4340d254981277ce14859ec23653c0dac4e3963" translate="yes" xml:space="preserve">
          <source>Geopoly operates on &quot;simple&quot; polygons - that is, polygons for which the boundary does not intersect itself. Geopoly thus extends the capabilities of the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; which can only deal with rectangular areas. On the other hand, the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; is able to handle between 1 and 5 coordinate dimensions, whereas Geopoly is restricted to 2-dimensional shapes only.</source>
          <target state="translated">Geopoly在&amp;ldquo;简单&amp;rdquo;多边形上运行-即，其边界自身不相交的多边形。因此，Geopoly扩展了&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展&lt;/a&gt;的功能，该功能仅可处理矩形区域。另一方面，&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展&lt;/a&gt;能够处理1到5个坐标维度，而Geopoly仅限于二维形状。</target>
        </trans-unit>
        <trans-unit id="6dd9a0429b5e12a110f96aed0989c67466586ea1" translate="yes" xml:space="preserve">
          <source>Geopoly stores all polygons internally using a binary format. A binary polygon consists of a 4-byte header following by an array of coordinate pairs in which each dimension of each coordinate is a 32-bit floating point number.</source>
          <target state="translated">Geopoly 内部使用二进制格式存储所有多边形。一个二进制多边形由一个 4 字节的头和一个坐标对数组组成,每个坐标的每个维度都是一个 32 位浮点数。</target>
        </trans-unit>
        <trans-unit id="230fd79e9ac234b116998f305ec36a626773a0c1" translate="yes" xml:space="preserve">
          <source>Get a copy of the prebuilt binaries for your machine, or get a copy of the sources and compile them yourself. Visit the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download&lt;/a&gt; page for more information.</source>
          <target state="translated">获取适用于您计算机的预编译二进制文件的副本，或者获取源代码的副本并自己进行编译。访问&lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;下载&lt;/a&gt;页面以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="f22b4172b2caeb752e5b6845137b0e1c3132162f" translate="yes" xml:space="preserve">
          <source>Get a new integer record number (a.k.a &quot;rowid&quot;) used as the key to a table. The record number is not previously used as a key in the database table that cursor P1 points to. The new record number is written written to register P2.</source>
          <target state="translated">获取一个新的整数记录号(又名 &quot;rowid&quot;)作为表的键。在游标P1所指向的数据库表中,这个记录号之前没有被用作键。新的记录号将被写入寄存器P2中。</target>
        </trans-unit>
        <trans-unit id="2c8ad3eda2ae8758b9937a69c2cdf3d37bc6a82b" translate="yes" xml:space="preserve">
          <source>Get extension loading working on Cygwin.</source>
          <target state="translated">在Cygwin上实现扩展加载工作。</target>
        </trans-unit>
        <trans-unit id="70d300a9221d054ecf73f3a432c241cce5538fb1" translate="yes" xml:space="preserve">
          <source>Get the SQLITE_ENABLE_LOCKING_STYLE macro working again on Mac OS X.</source>
          <target state="translated">让SQLITE_ENABLE_LOCKING_STYLE宏在Mac OS X上重新工作。</target>
        </trans-unit>
        <trans-unit id="191ab3ffcff8c3d125f02fa19cf1b4772a774563" translate="yes" xml:space="preserve">
          <source>Get the library working correctly when compiled with GCC option &quot;-fstrict-aliasing&quot;.</source>
          <target state="translated">当使用GCC选项&quot;-fstrict-aliasing &quot;编译时,获得库的正确工作。</target>
        </trans-unit>
        <trans-unit id="e33fe52a421a08f566920837d8eaa9b7577c26cc" translate="yes" xml:space="preserve">
          <source>Git allows you to go backwards in time easily. Given the latest check-in on a branch, Git lets you see all the ancestors of that check-in. But Git makes it difficult to move in the other direction. Given some historical check-in, it is quite challenging in Git to find out what came next. It can be done, but it is sufficiently difficult that people rarely do it. Common interfaces for Git, such as GitHub, do not support the ability.</source>
          <target state="translated">Git可以让你轻松地进行时间上的追溯。给定一个分支上最新的签入,Git可以让你看到该签入的所有祖先。但Git让你很难向另一个方向移动。给定一些历史签入,在Git中找出下一个签入是相当有挑战性的。它可以做到,但难度很大,人们很少这样做。Git的常见接口,如GitHub,不支持这种能力。</target>
        </trans-unit>
        <trans-unit id="b6fbc2ab6d8b00135f72a297ae81133b9c538d92" translate="yes" xml:space="preserve">
          <source>Git commands (and/or options on commands) for moving and comparing content between all of these locations.</source>
          <target state="translated">Git 命令(和/或命令的选项)用于在所有这些位置之间移动和比较内容。</target>
        </trans-unit>
        <trans-unit id="d8963f02fe19b4d06a85e3dcd904a4019a8389bd" translate="yes" xml:space="preserve">
          <source>Git has commands (and/or options on commands) for moving and comparing content between all of these locations.</source>
          <target state="translated">Git有一些命令(和/或命令的选项)用于在所有这些位置之间移动和比较内容。</target>
        </trans-unit>
        <trans-unit id="913e20aa0e82cacccbed30743753b5fea41f9dd9" translate="yes" xml:space="preserve">
          <source>Git is complex software. One needs an installer of some kind to put Git on a developer workstation, or to upgrade to a newer version of Git. Setting up a Git server is non-trivial, and so most users have to use a third-party service such as GitHub or GitLab, and thus introduce additional (unnecessary) dependencies into the project.</source>
          <target state="translated">Git是一个复杂的软件。人们需要某种安装程序来将Git放在开发者工作站上,或者升级到Git的较新版本。设置一个Git服务器并不容易,因此大多数用户不得不使用第三方服务,如GitHub或GitLab,从而为项目引入额外的(不必要的)依赖。</target>
        </trans-unit>
        <trans-unit id="ee613d9b4f6dfc0f80be0bd2cfff2ea77808bbb6" translate="yes" xml:space="preserve">
          <source>Git keeps the complete DAG of the check-in sequence. But branch tags are local information that is not synced and not retained once a branch closes. This makes review of historical branches tedious.</source>
          <target state="translated">Git会保留完整的签入序列DAG。但是分支标签是本地信息,一旦分支关闭就不会同步,也不会保留。这样一来,对历史分支的复查就显得十分繁琐。</target>
        </trans-unit>
        <trans-unit id="48b3160f0b763f1616179debce43562e664f02d9" translate="yes" xml:space="preserve">
          <source>GitHub and GitLab offer nothing comparable. The closest I have found is the &lt;a href=&quot;https://github.com/sqlite/sqlite/network&quot;&gt;network&lt;/a&gt;, which is slow to render (unless it is already cached), does not offer nearly as much details, and scarcely works on mobile. The &lt;a href=&quot;https://github.com/sqlite/sqlite/commits/master&quot;&gt;commits&lt;/a&gt; view of GitHub provides more detail, renders quickly, and works on mobile, but only shows a single branch at a time, so I cannot easily know if I've seen all of the recent changes. And even if GitHub/GitLab did offer better interfaces, both are third-party services. They are not a core part of Git. Hence, using them introduces yet another dependency into the project.</source>
          <target state="translated">GitHub和GitLab没有提供可比的东西。我发现的最接近的&lt;a href=&quot;https://github.com/sqlite/sqlite/network&quot;&gt;网络&lt;/a&gt;是渲染速度慢的网络（除非已被缓存），没有提供几乎一样多的细节，并且几乎无法在移动设备上工作。GitHub 的&lt;a href=&quot;https://github.com/sqlite/sqlite/commits/master&quot;&gt;commits&lt;/a&gt;视图提供了更多细节，快速呈现并可以在移动设备上运行，但是一次只显示一个分支，所以我不容易知道我是否看到了所有最近的更改。即使GitHub / GitLab确实提供了更好的界面，但它们都是第三方服务。它们不是Git的核心部分。因此，使用它们会在项目中引入另一个依赖性。</target>
        </trans-unit>
        <trans-unit id="ba7606fea498a9e876c11c77be2a94dc96cb33f9" translate="yes" xml:space="preserve">
          <source>Given a page number P and a maximum WAL frame index M, return the largest WAL frame index for page P that does not exceed M, or return NULL if there are no frames for page P that do not exceed M.</source>
          <target state="translated">给定页码P和最大WAL帧索引M,返回P页不超过M的最大WAL帧索引,如果P页没有不超过M的帧,则返回NULL。</target>
        </trans-unit>
        <trans-unit id="d4a9375f517c74831802a20b14cf1be5743c9399" translate="yes" xml:space="preserve">
          <source>Given a single SQL statement, there might be dozens, hundreds, or even thousands of ways to implement that statement, depending on the complexity of the statement itself and of the underlying database schema. The task of the query planner is to select an algorithm from among the many choices that provides the answer with a minimum of disk I/O and CPU overhead.</source>
          <target state="translated">给定一条SQL语句,根据语句本身和底层数据库模式的复杂程度,可能有几十种、几百种甚至上千种方法来实现该语句。查询规划器的任务是在众多选择中选择一种算法,以最少的磁盘I/O和CPU开销提供答案。</target>
        </trans-unit>
        <trans-unit id="f6bcca46f0f74a9ae01ce42d9f7404d2419d51ad" translate="yes" xml:space="preserve">
          <source>Given all of the information above, the job of the xBestIndex method it to figure out the best way to search the virtual table.</source>
          <target state="translated">鉴于以上所有信息,xBestIndex方法的工作是找出搜索虚拟表的最佳方式。</target>
        </trans-unit>
        <trans-unit id="3214b13dd0b542c059230864a7a5bcd2b12ab804" translate="yes" xml:space="preserve">
          <source>Given an input string X, this routine attempts to determine the dominant script of that input and returns the ISO-15924 numeric code for that script. The current implementation understands the following scripts:</source>
          <target state="translated">给定一个输入字符串X,这个例程试图确定该输入的主导脚本,并返回该脚本的ISO-15924数字代码。当前的实现可以理解以下脚本。</target>
        </trans-unit>
        <trans-unit id="c57b59e0dd1b427eb5c7b60fabfb8b9d76033a70" translate="yes" xml:space="preserve">
          <source>Given the definition of X1 above, the following expressions have historically evaluated to FALSE in SQLite, though the correct answer is actually NULL:</source>
          <target state="translated">考虑到上面X1的定义,下面的表达式在SQLite中历来被评价为FALSE,尽管正确答案实际上是NULL。</target>
        </trans-unit>
        <trans-unit id="bd2ada8cc33bdc4785b371a48d725c0e9ca58446" translate="yes" xml:space="preserve">
          <source>Given the new multi-column Idx3 index, it is now possible for SQLite to find the price of California oranges using only 2 binary searches:</source>
          <target state="translated">鉴于新的多列Idx3索引,现在SQLite只需使用2个二进制搜索就可以找到加州橙子的价格。</target>
        </trans-unit>
        <trans-unit id="714218fdde4fe7d7be9eadee91280223710df08f" translate="yes" xml:space="preserve">
          <source>Gives this result:</source>
          <target state="translated">给出了这样的结果。</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="677bbfd4560708b5b46c776feea9c65346f13863" translate="yes" xml:space="preserve">
          <source>Going in the other direction, the 2-argument version of ieee754() takes the M and E values and converts them into the corresponding F value:</source>
          <target state="translated">从另一个方向看,ieee754()的2参数版本将M和E值转换成相应的F值。</target>
        </trans-unit>
        <trans-unit id="617490ec40d56766edf8aff111990bee9834d1c1" translate="yes" xml:space="preserve">
          <source>Gosub</source>
          <target state="translated">Gosub</target>
        </trans-unit>
        <trans-unit id="0a9ffc4a328e6d21b11f3b8312d08e5b413aec49" translate="yes" xml:space="preserve">
          <source>Goto</source>
          <target state="translated">Goto</target>
        </trans-unit>
        <trans-unit id="4ee406a38010979b9234f48162e3d5db5fbf600e" translate="yes" xml:space="preserve">
          <source>Grey-hat hackers are rewarded based on the number and severity of CVEs that they write. This results in a proliferation of CVEs that have minor impact, or no impact at all, but which make exaggerated impact claims.</source>
          <target state="translated">灰帽黑客根据他们编写的CVE的数量和严重程度获得奖励。这导致影响较小或根本没有影响,但却夸大影响的CVE泛滥。</target>
        </trans-unit>
        <trans-unit id="1dee13ac09a18c736a85fb7212501ca3f0535655" translate="yes" xml:space="preserve">
          <source>Gt</source>
          <target state="translated">Gt</target>
        </trans-unit>
        <trans-unit id="60f4e65b35154fc853b0c67ac464ba87691c1af9" translate="yes" xml:space="preserve">
          <source>Guard your tongue against evil and depraved speech.</source>
          <target state="translated">警惕你的舌头,防止邪恶和堕落的言论。</target>
        </trans-unit>
        <trans-unit id="3472b7100ee6c34d2c985ec6e738e904962356df" translate="yes" xml:space="preserve">
          <source>HAVING</source>
          <target state="translated">HAVING</target>
        </trans-unit>
        <trans-unit id="a4c7ee9ba5c961273e153da9b6004699add74ac0" translate="yes" xml:space="preserve">
          <source>HH:MM</source>
          <target state="translated">HH:MM</target>
        </trans-unit>
        <trans-unit id="4a05a9c514dbbe7b13aeee7ffbbac9804dba7f74" translate="yes" xml:space="preserve">
          <source>HH:MM:SS</source>
          <target state="translated">HH:MM:SS</target>
        </trans-unit>
        <trans-unit id="4fe76e489c6dd906a0f1a9c53aab6e472da095e8" translate="yes" xml:space="preserve">
          <source>HH:MM:SS.SSS</source>
          <target state="translated">HH:MM:SS.SSS</target>
        </trans-unit>
        <trans-unit id="65f5a5cdef2d1220d932d3711961b5f933bef00b" translate="yes" xml:space="preserve">
          <source>HHHHHHHH</source>
          <target state="translated">HHHHHHHH</target>
        </trans-unit>
        <trans-unit id="cbc6ab8d850f8cff446447123804da23a703c293" translate="yes" xml:space="preserve">
          <source>Halt</source>
          <target state="translated">Halt</target>
        </trans-unit>
        <trans-unit id="c9efb4e35e5411aedaf0542890d4f34de7fdc553" translate="yes" xml:space="preserve">
          <source>HaltIfNull</source>
          <target state="translated">HaltIfNull</target>
        </trans-unit>
        <trans-unit id="eda901a16a2ed9d0d0e178d305fa51f41c885dd9" translate="yes" xml:space="preserve">
          <source>Has the same PRIMARY KEY definition.</source>
          <target state="translated">具有相同的primary key定义。</target>
        </trans-unit>
        <trans-unit id="7b3c15bec716c58e30bb9a01cc52d490760b69bf" translate="yes" xml:space="preserve">
          <source>Has the same name,</source>
          <target state="translated">有相同的名字。</target>
        </trans-unit>
        <trans-unit id="96ee9d0e4b354db6f1aac2ad6a31abd4bc3e74ca" translate="yes" xml:space="preserve">
          <source>Has the same set of columns declared in the same order, and</source>
          <target state="translated">拥有相同顺序声明的同一组列,并且。</target>
        </trans-unit>
        <trans-unit id="71024d7461751155928cb62c4bbb4edb8155f4cb" translate="yes" xml:space="preserve">
          <source>Hate no one.</source>
          <target state="translated">不恨任何人。</target>
        </trans-unit>
        <trans-unit id="f5e9b1bebb569eb2b57a7ab4d85d0681e37d4262" translate="yes" xml:space="preserve">
          <source>Having SQLite take ownership of the type strings would impose a performance cost on all applications, even applications that do not use the pointer-passing interfaces. SQLite passes values around as instances of the &lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt; object. That object has a destructor, which because of the fact that sqlite3_value objects are used for nearly everything, is invoked frequently. If the destructor needs to check to see if there is a pointer type string that needs to be freed, that is a few extra CPU cycles that need to be burned on each call to the destructor. Those cycles add up. We would be willing to bear the cost of the extra CPU cycles if pointer-passing was a commonly used programming paradigm, but pointer-passing is rare, and so it seems unwise to impose a run-time cost on billions and billions of applications that do not use pointer passing just for convenience of a few applications that do.</source>
          <target state="translated">让SQLite拥有类型字符串的所有权会给所有应用程序带来性能损失，即使是不使用指针传递接口的应用程序也是如此。 SQLite传递值作为&lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value的&lt;/a&gt;实例目的。该对象具有析构函数，由于sqlite3_value对象几乎用于所有对象，因此会频繁调用该析构函数。如果析构函数需要检查是否有指针类型的字符串需要释放，那么每次对析构函数的调用都需要消耗一些额外的CPU周期。这些周期加起来。如果指针传递是一种常用的编程范例，我们将愿意承担额外的CPU周期的代价，但是指针传递很少见，因此将数十亿美元的应用程序的运行时成本强加于不要仅仅为了方便一些应用程序使用指针传递。</target>
        </trans-unit>
        <trans-unit id="3880fcd08d24da661937a86693cfca26882a3b4e" translate="yes" xml:space="preserve">
          <source>Hazards of upgrading to the NGQP</source>
          <target state="translated">升级到国家质检总局的危害。</target>
        </trans-unit>
        <trans-unit id="5050e4d38d7df11eb3b253f0629fcc46c260dc76" translate="yes" xml:space="preserve">
          <source>Header string: 0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7</source>
          <target state="translated">头部字符串。0xd9、0xd5、0x05、0xf9、0x20、0xa1、0x63、0xd7。</target>
        </trans-unit>
        <trans-unit id="4bc19fb4af9f917cd00992c6391f45202ff0d0ec" translate="yes" xml:space="preserve">
          <source>Hence, a good rule of thumb is that your database schema should never contain two indices where one index is a prefix of the other. Drop the index with fewer columns. SQLite will still be able to do efficient lookups with the longer index.</source>
          <target state="translated">因此,一个好的经验法则是,你的数据库模式永远不应该包含两个索引,其中一个索引是另一个索引的前缀。丢掉少列的索引。SQLite仍然能够用较长的索引进行有效的查找。</target>
        </trans-unit>
        <trans-unit id="6591dd5f9b2e18fe91ad7d4be038693c79e5eb3d" translate="yes" xml:space="preserve">
          <source>Hence, as far as the xBestIndex() method is concerned, the following two forms are equivalent:</source>
          <target state="translated">因此,就xBestIndex()方法而言,以下两种形式是等价的。</target>
        </trans-unit>
        <trans-unit id="e3f076946ec3be55b66dffc59ab395c4e63eeb8f" translate="yes" xml:space="preserve">
          <source>Hence, by adding extra &quot;output&quot; columns onto the end of an index, one can avoid having to reference the original table and thereby cut the number of binary searches for a query in half. This is a constant-factor improvement in performance (roughly a doubling of the speed). But on the other hand, it is also just a refinement; A two-fold performance increase is not nearly as dramatic as the one-million-fold increase seen when the table was first indexed. And for most queries, the difference between 1 microsecond and 2 microseconds is unlikely to be noticed.</source>
          <target state="translated">因此,通过在索引的末尾添加额外的 &quot;输出 &quot;列,可以避免引用原始表,从而将查询的二进制搜索次数减少一半。这对性能的提升是一个恒定的因素(大约是速度的一倍)。但另一方面,这也只是一种改进,两倍的性能提升还不如第一次索引表时百万倍的提升来得显著。而且对于大多数查询来说,1微秒和2微秒之间的差异不太可能被注意到。</target>
        </trans-unit>
        <trans-unit id="b665f7a53251e88b80c18ae95a6e2a7570ff2c9e" translate="yes" xml:space="preserve">
          <source>Hence, in comparison to other approaches, the use of an SQLite database as an application file format has compelling advantages. Here are a few of these advantages, enumerated and expounded:</source>
          <target state="translated">因此,与其他方法相比,使用SQLite数据库作为应用文件格式具有引人注目的优势。以下是对这些优势的一些列举和阐述。</target>
        </trans-unit>
        <trans-unit id="39e8db1d33a3457396e45de0c0793052727a641e" translate="yes" xml:space="preserve">
          <source>Hence, the content encoding for a WITHOUT ROWID table is the same as the content encoding for an ordinary rowid table, except that the order of the columns is rearranged so that PRIMARY KEY columns come first, and the content is used as the key in an index b-tree rather than as the data in a table b-tree. The special encoding rules for columns with REAL affinity apply to WITHOUT ROWID tables the same as they do with rowid tables.</source>
          <target state="translated">因此,WITHOUT ROWID表的内容编码与普通rowid表的内容编码是一样的,只是重新安排了列的顺序,使primary KEY列排在前面,内容被用作索引b树中的键而不是表b树中的数据。具有REAL亲和力的列的特殊编码规则适用于without rowid表,与适用于rowid表一样。</target>
        </trans-unit>
        <trans-unit id="6cf16ad236074311fc9ce3546d776bb7fd65051f" translate="yes" xml:space="preserve">
          <source>Hence, the mere fact that an attacker has a way to inject and run arbitrary SQL is in and of itself a denial-of-service attack. That the arbitrary SQL might also tickle a bug in SQLite and cause a crash is not a new vulnerability.</source>
          <target state="translated">因此,仅仅是攻击者有办法注入和运行任意SQL这个事实本身就是一种拒绝服务攻击。任意SQL也可能勾起SQLite中的一个bug并导致崩溃,这并不是一个新的漏洞。</target>
        </trans-unit>
        <trans-unit id="999cfa83416c7b736dc3f3dfa6e7f25b9ba6e98f" translate="yes" xml:space="preserve">
          <source>Here again, version 2.7.0 of SQLite used to run at about the same speed as MySQL. But now version 2.7.6 is over two times faster than MySQL and over twenty times faster than PostgreSQL.</source>
          <target state="translated">这里再说一下,以前2.7.0版本的SQLite运行速度和MySQL差不多。但现在2.7.6版本比MySQL快了2倍多,比PostgreSQL快了20多倍。</target>
        </trans-unit>
        <trans-unit id="c79a9d1055558ef2d9992c6424392d62b259c2a6" translate="yes" xml:space="preserve">
          <source>Here are some existing and postulated uses for virtual tables:</source>
          <target state="translated">以下是虚拟表的一些现有的和假定的用途。</target>
        </trans-unit>
        <trans-unit id="f0580ad7def68334eac7c2c033faae47fa33aa31" translate="yes" xml:space="preserve">
          <source>Here are the syntax details:</source>
          <target state="translated">下面是详细的语法。</target>
        </trans-unit>
        <trans-unit id="c84ee5f5403083ecda923ec1470b2d4f31fd0f00" translate="yes" xml:space="preserve">
          <source>Here is a complete template extension that you can copy/paste to get started:</source>
          <target state="translated">这里是一个完整的模板扩展,你可以复制/粘贴开始。</target>
        </trans-unit>
        <trans-unit id="537d394cf0d1eecb92a9cbe8efc7e1a703bdd18e" translate="yes" xml:space="preserve">
          <source>Here is a query that computes the average height over everyone in Alice's organization, including Alice:</source>
          <target state="translated">下面是一个查询,计算包括爱丽丝在内的爱丽丝组织中所有人的平均身高。</target>
        </trans-unit>
        <trans-unit id="dd42feed9698b376dcb10e9aa54e385c734b65a6" translate="yes" xml:space="preserve">
          <source>Here is a query to show the tree structure in a breadth-first pattern:</source>
          <target state="translated">下面是一个以广度优先模式显示树结构的查询。</target>
        </trans-unit>
        <trans-unit id="f6aca36ca5ac667923339aff9445154b53da6d98" translate="yes" xml:space="preserve">
          <source>Here is a real-world example of using a graph query against a directed graph: A version control system (VCS) will typically store the evolving versions of a project as a directed acyclic graph (DAG). Call each version of the project a &quot;checkin&quot;. A single checkin can have zero or more parents. Most checkins (except the first) have a single parent, but in the case of a merge, a checkin might have two or three or more parents. A schema to keep track of checkins and the order in which they occur might look something like this:</source>
          <target state="translated">这里是一个针对有向图使用图查询的实际例子。版本控制系统(VCS)通常会将一个项目的演变版本存储为一个有向无环图(DAG)。将项目的每个版本称为 &quot;checkin&quot;。单个checkin可以有零个或多个父版本。大多数的checkin(除了第一个版本)都只有一个父版本,但是在合并的情况下,一个checkin可能有两个、三个或者更多的父版本。追踪签到和签到顺序的模式可能是这样的:</target>
        </trans-unit>
        <trans-unit id="b68ea20ab0a8004dffe949b080033114856a05ba" translate="yes" xml:space="preserve">
          <source>Here is a simple example of omitting a LEFT JOIN:</source>
          <target state="translated">下面是一个省略LEFT JOIN的简单例子。</target>
        </trans-unit>
        <trans-unit id="22d888f42ada11de3c14b5860a924536cf19b222" translate="yes" xml:space="preserve">
          <source>Here is a slightly different way to describe the aPgno values: If you think of all aPgno values as a contiguous array, then the database page number stored in the i-th frame of the WAL file is stored in aPgno[i]. Of course, aPgno is not a contiguous array. The first 4062 entries are on the first 32768-byte unit of the shm file and subsequent values are in 4096 entry chunks in later units of the shm file.</source>
          <target state="translated">这里有一种稍微不同的方式来描述aPgno值。如果你把所有的aPgno值看作是一个连续的数组,那么存储在WAL文件第i-th帧中的数据库页码就存储在aPgno[i]中.当然,aPgno不是一个连续数组。前4062个条目在shm文件的第一个32768字节的单元上,后续的值在shm文件后面的4096个条目块中。</target>
        </trans-unit>
        <trans-unit id="eeed83aeb26a72a7167e0caa92d0a130551072b7" translate="yes" xml:space="preserve">
          <source>Here is a summary of what the core interfaces do:</source>
          <target state="translated">下面是核心接口的工作总结。</target>
        </trans-unit>
        <trans-unit id="8a2373a91d98c2486bbd1ed6e2138a7e77394ed5" translate="yes" xml:space="preserve">
          <source>Here is a variation on the previous example:</source>
          <target state="translated">这里是上一个例子的变化。</target>
        </trans-unit>
        <trans-unit id="1319ba3fc57ef36ac27efdbc47123bdd4cb7f431" translate="yes" xml:space="preserve">
          <source>Here is an alternative description of the same computation:</source>
          <target state="translated">下面是对同样计算的另一种描述。</target>
        </trans-unit>
        <trans-unit id="44eacff0724c9f996876f69099ca0b2726a97ade" translate="yes" xml:space="preserve">
          <source>Here is an alternative way of describing the hash look-up algorithm: Start with h = (P * 383)%8192 and look at aHash[h] and subsequent entries, wrapping around to zero when h reaches 8192, until finding an entry with aHash[h]==0. All aPgno entries having a page number of P will have an index that is one of the aHash[h] values thusly computed. But not all the computed aHash[h] values will meet the matching criteria, so you must check them independently. The speed advantage comes about because normally this set of h values is very small.</source>
          <target state="translated">下面是描述哈希查找算法的另一种方式。从h=(P*383)%8192开始看aHash[h]和随后的条目,当h达到8192时绕到0,直到找到一个aHash[h]==0的条目。 所有页码为P的aPgno条目的索引都是这样计算出来的aHash[h]值之一。但是并不是所有计算出来的aHash[h]值都能满足匹配标准,所以你必须单独检查它们。速度上的优势是因为通常这组h值非常小。</target>
        </trans-unit>
        <trans-unit id="1a49c4bb8c6fe24c99e1160edbe5f45003dd833d" translate="yes" xml:space="preserve">
          <source>Here is an example using the built-in row_number() window function:</source>
          <target state="translated">下面是一个使用内置row_number()窗口函数的例子。</target>
        </trans-unit>
        <trans-unit id="1ed2d64e0577782df2f1f708b1c461ee5ebea46a" translate="yes" xml:space="preserve">
          <source>Here is what is going to happen: The first SELECT statement will construct rows of the result and save each row as the key of an entry in the transient table. The data for each entry in the transient table is a never used so we fill it in with an empty string. The second SELECT statement also constructs rows, but the rows constructed by the second SELECT are removed from the transient table. That is why we want the rows to be stored in the key of the SQLite file instead of in the data -- so they can be easily located and deleted.</source>
          <target state="translated">下面是将要发生的事情。第一条SELECT语句将构造结果的行 并将每行保存为瞬时表中一个条目的键。瞬时表中每个条目的数据都是一个从未使用过的,所以我们用一个空字符串来填充。第二条SELECT语句也会构造行,但第二条SELECT构造的行会从瞬时表中删除。这就是为什么我们要将行存储在SQLite文件的key中,而不是数据中--这样就可以很容易地找到和删除它们。</target>
        </trans-unit>
        <trans-unit id="7a844050eead2e7f9a21cd042c8a0efba1c399bc" translate="yes" xml:space="preserve">
          <source>Here is what the program must do. First it has to locate all of the records in the table &quot;examp&quot; that are to be deleted. This is done using a loop very much like the loop used in the SELECT examples above. Once all records have been located, then we can go back through and delete them one by one. Note that we cannot delete each record as soon as we find it. We have to locate all records first, then go back and delete them. This is because the SQLite database backend might change the scan order after a delete operation. And if the scan order changes in the middle of the scan, some records might be visited more than once and other records might not be visited at all.</source>
          <target state="translated">下面是程序必须做的事情。首先,它必须找到 &quot;examp &quot;表中所有要删除的记录。这是用一个循环来完成的,很像上面SELECT例子中使用的循环。一旦找到了所有的记录,那么我们就可以回过头来一条一条地删除它们。需要注意的是,我们不能一找到每一条记录就马上删除。我们必须先找到所有的记录,然后再回过头来删除它们。这是因为SQLite数据库后台在进行删除操作后,可能会改变扫描顺序。而如果扫描顺序在扫描过程中发生变化,有些记录可能会被访问不止一次,而有些记录可能根本就没有被访问。</target>
        </trans-unit>
        <trans-unit id="6ed0e64b4172a16a9716e7e75ddd35007c4f6e5a" translate="yes" xml:space="preserve">
          <source>Here is what you do to start experimenting with SQLite without having to do a lot of tedious reading and configuration:</source>
          <target state="translated">下面就是开始实验使用SQLite的方法,而不需要做很多繁琐的阅读和配置。</target>
        </trans-unit>
        <trans-unit id="c11a956fd1daf361e07b9a2963b5331668a6cb09" translate="yes" xml:space="preserve">
          <source>Here the apostrophe has been escaped and the SQL statement is well-formed. When generating SQL on-the-fly from data that might contain a single-quote character ('), it is always a good idea to use the SQLite printf routines and the %q formatting option instead of &lt;b&gt;sprintf&lt;/b&gt;.</source>
          <target state="translated">此处撇号已转义，并且SQL语句格式正确。从可能包含单引号字符（'）的数据即时生成SQL时，始终最好使用SQLite printf例程和％q格式化选项而不是&lt;b&gt;sprintf&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="c4c69c76db0b3b90fd64c09410acc3d4871de2e2" translate="yes" xml:space="preserve">
          <source>Here the inequalities are on columns x and y which are not the left-most index columns. Hence, the histogram data which is collected no left-most column of indexes is useless in helping to choose between the range constraints on columns x and y.</source>
          <target state="translated">这里的不等式是在x和y列上,而这两列不是最左边的索引列。因此,收集到的没有最左索引列的直方图数据对于帮助选择x和y列的范围约束是没有用的。</target>
        </trans-unit>
        <trans-unit id="53844b42e0f15c4e9c92f326da701e5edff51b64" translate="yes" xml:space="preserve">
          <source>Here the inequalities are on columns x and y which are not the left-most index columns. Hence, the histogram data which is collected no left-most column of indices is useless in helping to choose between the range constraints on columns x and y.</source>
          <target state="translated">这里的不等式是在x和y列上,而这两列不是最左边的索引列。因此,收集到的没有最左索引列的直方图数据对于帮助选择x和y列的范围约束是没有用的。</target>
        </trans-unit>
        <trans-unit id="54b1a90f72334cf67c79da3608b8cff7cc194a79" translate="yes" xml:space="preserve">
          <source>Hexadecimal</source>
          <target state="translated">Hexadecimal</target>
        </trans-unit>
        <trans-unit id="f3f781093bc605abee81ccbeb636a20f530bbe5d" translate="yes" xml:space="preserve">
          <source>Hexadecimal integer literals</source>
          <target state="translated">十六进制整数字数</target>
        </trans-unit>
        <trans-unit id="35e13960711ca47c62471d92f2b4029ee7852496" translate="yes" xml:space="preserve">
          <source>Hexadecimal integer literals follow the C-language notation of &quot;0x&quot; or &quot;0X&quot; followed by hexadecimal digits. For example, 0x1234 means the same as 4660 and 0x8000000000000000 means the same as -9223372036854775808. Hexadecimal integer literals are interpreted as 64-bit two's-complement integers and are thus limited to sixteen significant digits of precision. Support for hexadecimal integers was added to SQLite version 3.8.6 (2014-08-15). For backwards compatibility, the &quot;0x&quot; hexadecimal integer notation is only understood by the SQL language parser, not by the type conversions routines. String variables that contain text formatted like hexadecimal integers are not interpreted as hexadecimal integers when coercing the string value into an integer due to a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt; or for a &lt;a href=&quot;datatype3#affinity&quot;&gt;column affinity&lt;/a&gt; transformation or prior to performing a numeric operation or for any other run-time conversions. When coercing a string value in the format of a hexadecimal integer into an integer value, the conversion process stops when the 'x' character is seen so the resulting integer value is always zero. SQLite only understands the hexadecimal integer notation when it appears in the SQL statement text, not when it appears as part of the content of the database.</source>
          <target state="translated">十六进制整数文字遵循C语言符号&amp;ldquo; 0x&amp;rdquo;或&amp;ldquo; 0X&amp;rdquo;，后跟十六进制数字。例如，0x1234表示与4660相同，0x8000000000000000表示与-9223372036854775808相同。十六进制整数文字被解释为64位二进制补码整数，因此限制为精度的16个有效数字。 SQLite版本3.8.6（2014-08-15）已添加对十六进制整数的支持。为了向后兼容，SQL语言解析器只能理解&amp;ldquo; 0x&amp;rdquo;十六进制整数符号，类型转换例程不能理解。由于&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST表达式&lt;/a&gt;或&lt;a href=&quot;datatype3#affinity&quot;&gt;列相似性而将字符串值强制转换为整数时，包含格式如十六进制整数的文本的字符串变量不会解释为十六进制整数&lt;/a&gt;转换，执行数字运算之前或进行任何其他运行时转换。当将十六进制整数格式的字符串值强制转换为整数值时，当看到&amp;ldquo; x&amp;rdquo;字符时转换过程将停止，因此结果整数值始终为零。当SQLite出现在SQL语句文本中时，SQLite仅理解十六进制整数表示法，而当它作为数据库内容的一部分出现时，则不理解。</target>
        </trans-unit>
        <trans-unit id="4413e5afdd76b08f7a57f3501dcd353af75c6909" translate="yes" xml:space="preserve">
          <source>Hexadecimal integers</source>
          <target state="translated">十六进制整数</target>
        </trans-unit>
        <trans-unit id="34ad49fd08b5d8ebfe6309e8a94dbdda68560346" translate="yes" xml:space="preserve">
          <source>Hidden column</source>
          <target state="translated">隐藏栏</target>
        </trans-unit>
        <trans-unit id="47adea5ce487ea3890476b37d1c95b4a2f866391" translate="yes" xml:space="preserve">
          <source>Hidden columns are not included in the expansion of a &quot;*&quot; expression in the result set of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;, and</source>
          <target state="translated">&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;的结果集中的&amp;ldquo; *&amp;rdquo;表达式的扩展中不包含隐藏的列，并且</target>
        </trans-unit>
        <trans-unit id="20096dd8d3b8c2cfd4d3a69c38df377eed777771" translate="yes" xml:space="preserve">
          <source>Hidden columns are not included in the implicit column-list used by an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement that lacks an explicit column-list.</source>
          <target state="translated">缺少显式列列表的&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;语句使用的隐式列列表中不包含隐藏列。</target>
        </trans-unit>
        <trans-unit id="b7668a93e533ae2c015270865d5e714d07d437f1" translate="yes" xml:space="preserve">
          <source>Hidden columns are not listed in the dataset returned by &quot;&lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt;&quot;,</source>
          <target state="translated">隐藏的列未在&amp;ldquo; &lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt; &amp;rdquo; 返回的数据集中列出，</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
