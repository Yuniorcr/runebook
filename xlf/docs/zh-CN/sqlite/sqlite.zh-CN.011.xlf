<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="e5c2df06ba96ff92a5b489615f6b10abd3bf147f" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;&amp;times;N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;&amp;times;N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="2c0a1bee57f9f58fc50d516a0bf15f88caa7689c" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="a9d371451b6909ac85117130b9153a96499a362c" translate="yes" xml:space="preserve">
          <source>NAME</source>
          <target state="translated">NAME</target>
        </trans-unit>
        <trans-unit id="5b0ac1bba3d09af88af51314ab9e3274563ae94b" translate="yes" xml:space="preserve">
          <source>NATIVE CHARACTER(70)</source>
          <target state="translated">本土人物(70)</target>
        </trans-unit>
        <trans-unit id="7b0c42d6ea58612c19c7961351b229254674e033" translate="yes" xml:space="preserve">
          <source>NATURAL</source>
          <target state="translated">NATURAL</target>
        </trans-unit>
        <trans-unit id="ea1a1d896196c614eb971163bd79e6b0f3ccbe73" translate="yes" xml:space="preserve">
          <source>NB: This extension is deprecated. [WAL mode] is recommended as a replacement.</source>
          <target state="translated">NB:这个扩展已经过时了,建议用[WAL模式]代替。推荐使用[WAL模式]作为替代。</target>
        </trans-unit>
        <trans-unit id="9829174ea4702c19a86b2f2d0ae072ffd5bcdee0" translate="yes" xml:space="preserve">
          <source>NCHAR(55)</source>
          <target state="translated">NCHAR(55)</target>
        </trans-unit>
        <trans-unit id="b7fe5d20802ca2aca87db42d4b7dae9f148c0ed7" translate="yes" xml:space="preserve">
          <source>NEAR queries</source>
          <target state="translated">近距离查询</target>
        </trans-unit>
        <trans-unit id="ad140e1560939f826df416c1e0d8f81eaa5dd26a" translate="yes" xml:space="preserve">
          <source>NEAR queries are not available.</source>
          <target state="translated">近距离查询不可用。</target>
        </trans-unit>
        <trans-unit id="9bbceb6fd3a09583f532267c802c583270b6ed37" translate="yes" xml:space="preserve">
          <source>NEVER(X)</source>
          <target state="translated">NEVER(X)</target>
        </trans-unit>
        <trans-unit id="97b77dd54bade796fe382680ffda0d54d204b7ea" translate="yes" xml:space="preserve">
          <source>NEW and OLD references are valid</source>
          <target state="translated">新的和旧的引用都是有效的</target>
        </trans-unit>
        <trans-unit id="a82d81a38474e7a2f1b05be86c3d0ec157924da9" translate="yes" xml:space="preserve">
          <source>NEW references are valid</source>
          <target state="translated">新的参考资料有效</target>
        </trans-unit>
        <trans-unit id="aa7b193ecb5f5e8127c45d86d672c669b4ad311a" translate="yes" xml:space="preserve">
          <source>NNN</source>
          <target state="translated">NNN</target>
        </trans-unit>
        <trans-unit id="cf99bc0053e83f8041fe548005de7972be838e08" translate="yes" xml:space="preserve">
          <source>NNN days</source>
          <target state="translated">NNN天</target>
        </trans-unit>
        <trans-unit id="33c4ffa6e43390375c0bf9b4e04eedef73776044" translate="yes" xml:space="preserve">
          <source>NNN hours</source>
          <target state="translated">NNN小时</target>
        </trans-unit>
        <trans-unit id="4dc2b6e588bcda89bc862d480bc0a6894df9769a" translate="yes" xml:space="preserve">
          <source>NNN minutes</source>
          <target state="translated">NNN分钟</target>
        </trans-unit>
        <trans-unit id="bf0082b4c02bd0d30ff30874661f393df82750f4" translate="yes" xml:space="preserve">
          <source>NNN months</source>
          <target state="translated">NNN月</target>
        </trans-unit>
        <trans-unit id="afb2dbb2fb0e9adb5cd092d7e7b6d3ffb78523de" translate="yes" xml:space="preserve">
          <source>NNN years</source>
          <target state="translated">NNN年</target>
        </trans-unit>
        <trans-unit id="b58c197b751c5ed1962a3c0390de8c10bb4951b3" translate="yes" xml:space="preserve">
          <source>NNN.NNNN seconds</source>
          <target state="translated">NNN.NNNN秒</target>
        </trans-unit>
        <trans-unit id="a0509b7780628bd9d9abc7eb8a2163477341053a" translate="yes" xml:space="preserve">
          <source>NO</source>
          <target state="translated">NO</target>
        </trans-unit>
        <trans-unit id="05fdd36e7692e52033451b07ec66dff9eb7e55c8" translate="yes" xml:space="preserve">
          <source>NOCASE</source>
          <target state="translated">NOCASE</target>
        </trans-unit>
        <trans-unit id="0654a028e5aea48c8fbb09871b8f397a186c883b" translate="yes" xml:space="preserve">
          <source>NONE</source>
          <target state="translated">NONE</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="13e8b0dd0b366e8464e50db4ffa83a38db17f5c0" translate="yes" xml:space="preserve">
          <source>NOT EXISTS operator</source>
          <target state="translated">NOT EXISIS操作者</target>
        </trans-unit>
        <trans-unit id="c251201ede2fa823c20c38c57254fd75c17ce421" translate="yes" xml:space="preserve">
          <source>NOT IN operator</source>
          <target state="translated">不在运营商</target>
        </trans-unit>
        <trans-unit id="f4a4efddb03a7d76572898f7eabe1ea34a780b2f" translate="yes" xml:space="preserve">
          <source>NOT NULL constraint</source>
          <target state="translated">非空约束</target>
        </trans-unit>
        <trans-unit id="6ff7e3eeee65666114a7a3854176937e0d8c1522" translate="yes" xml:space="preserve">
          <source>NOT NULL constraints are honored.</source>
          <target state="translated">NOT NULL限制被尊重。</target>
        </trans-unit>
        <trans-unit id="c462e8fc3e502ae6d5489c34ffa0054b7073578f" translate="yes" xml:space="preserve">
          <source>NOTHING</source>
          <target state="translated">NOTHING</target>
        </trans-unit>
        <trans-unit id="d6a7f5abac5bd9faa0bac9e8bb7907ab9f614941" translate="yes" xml:space="preserve">
          <source>NOTNULL</source>
          <target state="translated">NOTNULL</target>
        </trans-unit>
        <trans-unit id="545dacd66301f165f41f75a11471135695f4dede" translate="yes" xml:space="preserve">
          <source>NUL Characters In Strings</source>
          <target state="translated">NUL 字符串</target>
        </trans-unit>
        <trans-unit id="4771b572fc1de8c483abeb1a95a1bc516fa56a87" translate="yes" xml:space="preserve">
          <source>NUL characters (ASCII code 0x00 and Unicode \u0000) may appear in the middle of strings in SQLite. This can lead to unexpected behavior. See the &quot;&lt;a href=&quot;nulinstr&quot;&gt;NUL characters in strings&lt;/a&gt;&quot; document for further information.</source>
          <target state="translated">在SQLite中，字符串的中间可能会出现NUL字符（ASCII代码0x00和Unicode \ u0000）。这可能导致意外的行为。有关更多信息，请参见&amp;ldquo;&lt;a href=&quot;nulinstr&quot;&gt;字符串中的NUL字符&lt;/a&gt;&amp;rdquo;文档。</target>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="0d475d854a2a7eeffd82e1a01f92ca65e566328f" translate="yes" xml:space="preserve">
          <source>NULL Handling in SQLite</source>
          <target state="translated">SQLite中的NULL处理</target>
        </trans-unit>
        <trans-unit id="7fac7bb3c1a767adbbac557d34135fb142c688ca" translate="yes" xml:space="preserve">
          <source>NULL Handling in SQLite Versus Other Database Engines</source>
          <target state="translated">SQLite中的NULL处理与其他数据库引擎的比较</target>
        </trans-unit>
        <trans-unit id="248ab3abcb099e69f2fef53b64e651576012c852" translate="yes" xml:space="preserve">
          <source>NULL values (serial type 0) sort first.</source>
          <target state="translated">NULL值(序列类型0)先排序。</target>
        </trans-unit>
        <trans-unit id="a1efa1e3b6119cae6664d71bdefea57f479d6ebf" translate="yes" xml:space="preserve">
          <source>NULL values are now reported to the callback as a NULL pointer rather than an empty string.</source>
          <target state="translated">NULL值现在会以NULL指针而不是空字符串的形式报告给回调。</target>
        </trans-unit>
        <trans-unit id="743ef19013396d7d94a24cacbb830235275be9c8" translate="yes" xml:space="preserve">
          <source>NULLS</source>
          <target state="translated">NULLS</target>
        </trans-unit>
        <trans-unit id="fc81819cf87d3384597c4ae67d1976d82323a9b0" translate="yes" xml:space="preserve">
          <source>NULLS LAST</source>
          <target state="translated">NULLS LAST</target>
        </trans-unit>
        <trans-unit id="8280c934b3178b2afed2c01f955aab5fe7295999" translate="yes" xml:space="preserve">
          <source>NULLs sort first</source>
          <target state="translated">NULLs优先排序</target>
        </trans-unit>
        <trans-unit id="58ad270de77802cc63222e273fa800c4b248cdd7" translate="yes" xml:space="preserve">
          <source>NUMERIC</source>
          <target state="translated">NUMERIC</target>
        </trans-unit>
        <trans-unit id="024959fd2d5e8c9c205a2098591019699ae29143" translate="yes" xml:space="preserve">
          <source>NVARCHAR(100)</source>
          <target state="translated">NVARCHAR(100)</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="daa5b774be0bfcbd2e2835e6bd0980fb6e06778a" translate="yes" xml:space="preserve">
          <source>Name Of A Host Parameter</source>
          <target state="translated">主机参数名称</target>
        </trans-unit>
        <trans-unit id="cb9e33f6b09bb7fe5d38a783b74c6905b2f43077" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Database Files</source>
          <target state="translated">保存数据库文件的文件夹名称</target>
        </trans-unit>
        <trans-unit id="7749c218b18b42cbe27f3f870da40b8d3d708ba1" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Temporary Files</source>
          <target state="translated">保存临时文件的文件夹名称</target>
        </trans-unit>
        <trans-unit id="fbb9c33e0412f25c0e798fd22a36fd452bd92012" translate="yes" xml:space="preserve">
          <source>Name of default collation sequence</source>
          <target state="translated">默认整理序列的名称</target>
        </trans-unit>
        <trans-unit id="4e3a9de996d9196b59f293d51cf53aa5b2a8a36e" translate="yes" xml:space="preserve">
          <source>Named window-defn clauses may also be added to a SELECT statement using a WINDOW clause and then referred to by name within window function invocations. For example, the following SELECT statement contains two named window-defs clauses, &quot;win1&quot; and &quot;win2&quot;:</source>
          <target state="translated">也可以使用WINDOW子句将命名的window-defn子句添加到SELECT语句中,然后在window函数调用中通过名称来引用。例如,下面的SELECT语句包含两个命名的window-defs子句,&quot;win1 &quot;和 &quot;win2&quot;。</target>
        </trans-unit>
        <trans-unit id="02aead4c6c683a05b1c0ebf7ea825cf0f6d1b06c" translate="yes" xml:space="preserve">
          <source>Naming Changes</source>
          <target state="translated">命名变更</target>
        </trans-unit>
        <trans-unit id="f736bf35e196e5f8a2152cf612783a7b401c2cad" translate="yes" xml:space="preserve">
          <source>Ne</source>
          <target state="translated">Ne</target>
        </trans-unit>
        <trans-unit id="28477357de69f5526193889fda40ed45cd101a03" translate="yes" xml:space="preserve">
          <source>Nearly all systems have the ability to call libraries written in C. This is not true of other implementation languages.</source>
          <target state="translated">几乎所有的系统都能调用用C语言编写的库,其他实现语言则不然。</target>
        </trans-unit>
        <trans-unit id="a37e5d1459b64bbf0f387b130668f0c8c4924e69" translate="yes" xml:space="preserve">
          <source>Negative numbers in the &quot;.width&quot; command cause right-alignment</source>
          <target state="translated">&quot;.width &quot;命令中的负数会导致右对齐。</target>
        </trans-unit>
        <trans-unit id="fec37acea6ebcef8454c4fc958c0b8f34d2b8c80" translate="yes" xml:space="preserve">
          <source>Nested transactions using &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;, &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt;, and &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK TO&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;，&lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt;和&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK TO的&lt;/a&gt;嵌套事务</target>
        </trans-unit>
        <trans-unit id="9c791dcaae3666d9984fccf3b99d9aec11d78e88" translate="yes" xml:space="preserve">
          <source>Never despair of God's mercy.</source>
          <target state="translated">千万不要对上帝的仁慈绝望。</target>
        </trans-unit>
        <trans-unit id="56cdefb3df5828b1fdbe0c79de688ed68de09460" translate="yes" xml:space="preserve">
          <source>Never tag an application-defined SQL function with &lt;a href=&quot;c3ref/c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt; unless you really need to and you have checked the implementation closely and are certain that it can do no harm even if it falls under the control of an attacker.</source>
          <target state="translated">除非确实需要，否则不要用&lt;a href=&quot;c3ref/c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt;标记应用程序定义的SQL函数，并且您已经仔细检查了实现，并确定即使受到攻击者的控制，它也不会造成任何危害。</target>
        </trans-unit>
        <trans-unit id="cb1f0a8ca1cbcde19e25e6a553a1aa4154cf9c78" translate="yes" xml:space="preserve">
          <source>Nevertheless, application developers are admonished to monitor the state of the memory allocation subsystems and raise alarms when memory usage approaches or exceeds Robson limits. In this way, the application will provide operators with abundant warning well in advance of failure. The &lt;a href=&quot;malloc#memstatus&quot;&gt;memory statistics&lt;/a&gt; interfaces of SQLite provide the application with all the mechanism necessary to complete the monitoring portion of this task.</source>
          <target state="translated">但是，建议应用程序开发人员监视内存分配子系统的状态，并在内存使用率接近或超过Robson限制时发出警报。这样，该应用程序将在发生故障之前为操作员提供大量警告。SQLite 的&lt;a href=&quot;malloc#memstatus&quot;&gt;内存统计信息&lt;/a&gt;接口为应用程序提供了完成此任务的监视部分所需的所有机制。</target>
        </trans-unit>
        <trans-unit id="b14d2dd89e46e860f7449a61cc79bde67323500f" translate="yes" xml:space="preserve">
          <source>Nevertheless, bugs happen. If you are writing an application that sends untrusted SQL inputs or database files to SQLite, there are additional steps you can take to help reduce the attack surface and prevent zero-day exploits caused by undetected bugs.</source>
          <target state="translated">尽管如此,错误还是发生了。如果你正在编写一个向SQLite发送不受信任的SQL输入或数据库文件的应用程序,你可以采取一些额外的措施来帮助减少攻击面,并防止由未检测到的bug引起的零日漏洞。</target>
        </trans-unit>
        <trans-unit id="fe8f48a38c1ee2d5e1ec0b569c50eb0f4be22e0d" translate="yes" xml:space="preserve">
          <source>Nevertheless, integer overflow in the computation of memory allocation sizes is a concern that SQLite would like to deal with. To prevent problems, all SQLite internal memory allocations occur using thin wrapper functions that take a signed 64-bit integer size parameter. The SQLite source code is audited to ensure that all size computations are carried out using 64-bit signed integers as well. SQLite will refuse to allocate more than about 2GB of memory at one go. (In common use, SQLite seldom ever allocates more than about 8KB of memory at a time so a 2GB allocation limit is not a burden.) So the 64-bit size parameter provides lots of headroom for detecting overflows. The same audit that verifies that all size computations are done as 64-bit signed integers also verifies that it is impossible to overflow a 64-bit integer during the computation.</source>
          <target state="translated">尽管如此,在计算内存分配大小时的整数溢出是SQLite希望处理的问题。为了防止出现问题,所有的SQLite内部内存分配都是使用瘦包装函数来进行的,这些瘦包装函数取一个64位有符号的整数大小参数。SQLite源码经过审计,确保所有大小计算也使用64位有符号的整数进行。SQLite会拒绝一次性分配超过约2GB的内存。(在通常的使用中,SQLite很少会一次分配超过8KB左右的内存,所以2GB的分配限制并不是一个负担)。所以64位大小参数为检测溢出提供了很大的空间。同样的审计也验证了所有大小计算都是以64位有符号整数的方式进行的,也验证了64位整数在计算过程中不可能溢出。</target>
        </trans-unit>
        <trans-unit id="e49fc674e296beca34786edd4c2b299863546a78" translate="yes" xml:space="preserve">
          <source>Nevertheless, no software is 100% perfect. There have been a few historical bugs in SQLite (now fixed) that could cause database corruption. And there may be yet a few more that remain undiscovered. Because of the extensive testing and widespread use of SQLite, bugs that result in database corruption tend to be very obscure. The likelihood of an application encountering an SQLite bug is small. To illustrate this, an account is given below of all database-corruption bugs found in SQLite during the four-year period from 2009-04-01 to 2013-04-15. This account should give the reader an intuitive sense of the kinds of bugs in SQLite that manage to slip through testing procedures and make it into a release.</source>
          <target state="translated">尽管如此,没有任何软件是100%完美的。在SQLite中曾出现过一些历史性的错误(现在已经修复),可能会导致数据库损坏。而且可能还有一些未被发现的错误。由于SQLite的广泛测试和广泛使用,导致数据库损坏的bug往往是非常隐蔽的。一个应用程序遇到SQLite bug的可能性很小。为了说明这一点,下面对2009-04-01至2013-04-15这四年期间在SQLite中发现的所有数据库损坏bug进行了说明。这个说明应该能让读者直观地了解到SQLite中哪些类型的bug会设法通过测试程序溜走,并将其发布到版本中。</target>
        </trans-unit>
        <trans-unit id="0116882452ef2d4b8e1293a906b669874cb29ba7" translate="yes" xml:space="preserve">
          <source>New &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_...&lt;/a&gt; compile-time options added</source>
          <target state="translated">添加了新的&lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT _...&lt;/a&gt;编译时选项</target>
        </trans-unit>
        <trans-unit id="75836f6f6b6f280ffed2e7c97c8de38d49f8b36b" translate="yes" xml:space="preserve">
          <source>New Change</source>
          <target state="translated">新变化</target>
        </trans-unit>
        <trans-unit id="519eb3711af9fb8ce8d81cf7983b569f9b988fc0" translate="yes" xml:space="preserve">
          <source>New File Format</source>
          <target state="translated">新文件格式</target>
        </trans-unit>
        <trans-unit id="05a025f4bcdcce620e0b66e603b7b96a2aa62567" translate="yes" xml:space="preserve">
          <source>New HH:MM:SS modifier to the built-in date/time functions.</source>
          <target state="translated">为内置的日期/时间函数添加新的HH:MM:SS修饰符。</target>
        </trans-unit>
        <trans-unit id="35afb195f0b01edb4e7140e0f143cfa5913617eb" translate="yes" xml:space="preserve">
          <source>New VFSes are registered with sqlite3_vfs_register(). Each new VFS becomes the default VFS if the makeDflt flag is set. The same VFS can be registered multiple times without injury. To make an existing VFS into the default VFS, register it again with the makeDflt flag set. If two different VFSes with the same name are registered, the behavior is undefined. If a VFS is registered with a name that is NULL or an empty string, then the behavior is undefined.</source>
          <target state="translated">新的VFSes用sqlite3_vfs_register()注册。如果makeDflt标志被设置,每个新的VFS都会成为默认的VFS。同一个VFS可以被注册多次而不会受到伤害。要使一个现有的VFS成为默认的VFS,需要在makeDflt标志被设置的情况下再次注册它。如果注册了两个同名的不同VFS,行为是未定义的。如果注册的VFS的名称是NULL或空字符串,那么行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="9e6d8977d2335274bf96388fe98628d1d0b7e083" translate="yes" xml:space="preserve">
          <source>New applications should always invoke &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; instead of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;. The older &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; is retained for backwards compatibility. But &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; provides a much better interface.</source>
          <target state="translated">新应用程序应始终调用&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;而不是&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;。保留较旧的&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;是为了向后兼容。但是&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;提供了一个更好的接口。</target>
        </trans-unit>
        <trans-unit id="741f30a581517ffe6e7dcd8b6f50643914279724" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">将来的SQLite版本中可能会添加新的配置选项。现有的配置选项可能会中断。应用程序应检查来自&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;的返回码，以确保该调用有效。所述&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;接口将返回一个非零&lt;a href=&quot;rescode&quot;&gt;的错误代码&lt;/a&gt;，如果一个中断或不支持的配置选项被调用。</target>
        </trans-unit>
        <trans-unit id="dfd7ca29d835fc9c4dbb0540c0bcc6f89fdaa393" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">将来的SQLite版本中可能会添加新的配置选项。现有的配置选项可能会中断。应用程序应检查来自&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;的返回码，以确保调用能够正常进行。所述&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;接口将返回一个非零&lt;a href=&quot;rescode&quot;&gt;的错误代码&lt;/a&gt;，如果一个中断或不支持的配置选项被调用。</target>
        </trans-unit>
        <trans-unit id="290c5a063c07711b910fa8250f0c45e5e6c8d5a9" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">将来的SQLite版本中可能会添加新的配置选项。现有的配置选项可能会中断。应用程序应检查来自&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;的返回码，以确保该调用有效。所述&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;接口将返回一个非零&lt;a href=&quot;../rescode&quot;&gt;的错误代码&lt;/a&gt;，如果一个中断或不支持的配置选项被调用。</target>
        </trans-unit>
        <trans-unit id="bef0fe1db7b5b12623a7cb6dd11860448e032b3e" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">将来的SQLite版本中可能会添加新的配置选项。现有的配置选项可能会中断。应用程序应检查来自&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;的返回码，以确保调用能够正常进行。所述&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;接口将返回一个非零&lt;a href=&quot;../rescode&quot;&gt;的错误代码&lt;/a&gt;，如果一个中断或不支持的配置选项被调用。</target>
        </trans-unit>
        <trans-unit id="b448decebb78010dbfebbde65087fb4a352a7ae8" translate="yes" xml:space="preserve">
          <source>New database files created by SQLite use format 4 by default. The &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt; can be used to cause SQLite to create new database files using format 1. The format version number can be made to default to 1 instead of 4 by setting &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt;=1 at compile-time.</source>
          <target state="translated">默认情况下，SQLite创建的新数据库文件使用格式4。该&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format编译指示&lt;/a&gt;可以用来引起的SQLite通过设置使用格式1来创建新的数据库文件的格式的版本号可以以默认被制成1代替4- &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt;在编译时间= 1。</target>
        </trans-unit>
        <trans-unit id="7fae2a2a8fa480fb532533df6e47c596e4029933" translate="yes" xml:space="preserve">
          <source>New error codes may be added in future versions of SQLite.</source>
          <target state="translated">在未来的SQLite版本中可能会添加新的错误代码。</target>
        </trans-unit>
        <trans-unit id="02a2eef012a8248fed2ec4a5f4418e441dee6267" translate="yes" xml:space="preserve">
          <source>New extensions:</source>
          <target state="translated">新的分机。</target>
        </trans-unit>
        <trans-unit id="c375e60e4ec3e7a7421f6f6fc9277a408ea2286e" translate="yes" xml:space="preserve">
          <source>New file format that is 25% to 35% smaller for typical use.</source>
          <target state="translated">新的文件格式,对于典型的使用来说,体积缩小了25%到35%。</target>
        </trans-unit>
        <trans-unit id="fd04fa0f053215d42b7f8b539b38e361266bd4c9" translate="yes" xml:space="preserve">
          <source>New flags may be added in future releases of SQLite.</source>
          <target state="translated">在未来的SQLite版本中可能会添加新的标志。</target>
        </trans-unit>
        <trans-unit id="609f25b82bb11b34abf866257917b5188d15ee70" translate="yes" xml:space="preserve">
          <source>New interface &lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt; that returns the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; handle that has invoked an application-defined SQL function.</source>
          <target state="translated">新接口&lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle（）&lt;/a&gt;返回已调用应用程序定义的SQL函数的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;句柄。</target>
        </trans-unit>
        <trans-unit id="97e454a0ee0ddbdb1207081ac8f340c9145f813d" translate="yes" xml:space="preserve">
          <source>New interface &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; allows size and length limits to be set on a per-connection basis and at run-time.</source>
          <target state="translated">新接口&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;允许在每个连接的基础上和在运行时设置大小和长度限制。</target>
        </trans-unit>
        <trans-unit id="351a6ce815b5dd18ffcf850d512cce2a33e3cd28" translate="yes" xml:space="preserve">
          <source>New interface: sqlite3_bind_parameter_index()</source>
          <target state="translated">新接口:sqlite3_bind_parameter_index()</target>
        </trans-unit>
        <trans-unit id="ff421fae0557a39a0bd809f33195e163ee4bb7ae" translate="yes" xml:space="preserve">
          <source>New interfaces added to the test_quota.c add-on module.</source>
          <target state="translated">test_quota.c附加模块中增加了新的接口。</target>
        </trans-unit>
        <trans-unit id="ae3613412d28080958e2d37e217b087b523b9aae" translate="yes" xml:space="preserve">
          <source>New internal schema objects names, always beginning with &quot;sqlite_&quot;, may be added to the SQLite file format in future releases.</source>
          <target state="translated">新的内部模式对象名称,总是以 &quot;sqlite_&quot;开头,可能会在未来的版本中加入SQLite文件格式。</target>
        </trans-unit>
        <trans-unit id="26bcef71ccfa90b2e0cbb123ce577eb05e69bad7" translate="yes" xml:space="preserve">
          <source>New memory allocators do not have to be part of the SQLite source tree nor included in the sqlite3.c &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. Individual applications can supply their own memory allocators to SQLite at start-time.</source>
          <target state="translated">新的内存分配器不必是SQLite源树的一部分，也不必包含在sqlite3.c &lt;a href=&quot;amalgamation&quot;&gt;合并中&lt;/a&gt;。各个应用程序可以在启动时向SQLite提供其自己的内存分配器。</target>
        </trans-unit>
        <trans-unit id="5e4800161f51168ad45c54c49952a916eb4c7f5a" translate="yes" xml:space="preserve">
          <source>New options to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; for configuring auxiliary memory usage: --pagecache, --lookaside, and --scratch.</source>
          <target state="translated">用于配置辅助内存使用的&lt;a href=&quot;cli&quot;&gt;命令行外壳的&lt;/a&gt;新选项：--pagecache，--lookaside和--scratch。</target>
        </trans-unit>
        <trans-unit id="33b435c4ed8f9927e4700fe7e7aeadeae900e749" translate="yes" xml:space="preserve">
          <source>New query optimizations:</source>
          <target state="translated">新的查询优化。</target>
        </trans-unit>
        <trans-unit id="27a96e272ba4064e97b901622de6fb30f7bc2a07" translate="yes" xml:space="preserve">
          <source>New run-time limit categories may be added in future releases.</source>
          <target state="translated">在未来的版本中可能会增加新的运行时间限制类别。</target>
        </trans-unit>
        <trans-unit id="aa7ba8a90d79e3949a9a92f1f6dd6361b3924b13" translate="yes" xml:space="preserve">
          <source>New status parameters may be added from time to time.</source>
          <target state="translated">新的状态参数可能会不时增加。</target>
        </trans-unit>
        <trans-unit id="8001d5465bcc215e617045ec61b342b4c0fbe511" translate="yes" xml:space="preserve">
          <source>New tests added to the test suite.</source>
          <target state="translated">新测试添加到测试套件中。</target>
        </trans-unit>
        <trans-unit id="19df796618ecb880621a1ff2386886f64457fe9e" translate="yes" xml:space="preserve">
          <source>New text tokens may be added to the end of the stat column in future enhancements to SQLite. For compatibility, unrecognized tokens at the end of the stat column are silently ignored.</source>
          <target state="translated">在未来对SQLite的增强中,新的文本标记可能会被添加到统计列的结尾。出于兼容性考虑,统计列末尾未识别的标记将被默默忽略。</target>
        </trans-unit>
        <trans-unit id="d23050a62d4b2ebb32c827e3e8678911cb996090" translate="yes" xml:space="preserve">
          <source>New tracing constants may be added in future releases.</source>
          <target state="translated">在未来的版本中可能会添加新的跟踪常数。</target>
        </trans-unit>
        <trans-unit id="8ec81cf9bf3ff78a39346bf7439447032b8bc32c" translate="yes" xml:space="preserve">
          <source>New verbs may be added in future releases of SQLite. Existing verbs might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface will return a non-zero error code if a discontinued or unsupported verb is invoked.</source>
          <target state="translated">将来的SQLite版本中可能会添加新的动词。现有的动词可能会中断。应用程序应检查来自&lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;的返回码，以确保该调用有效。所述&lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;如果一个中断或不支持的动词被调用接口将返回非零错误代码。</target>
        </trans-unit>
        <trans-unit id="6997236519e17b29acb8e0c21015208012814bff" translate="yes" xml:space="preserve">
          <source>New verbs may be added in future releases of SQLite. Existing verbs might be discontinued. Applications should check the return code from &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface will return a non-zero error code if a discontinued or unsupported verb is invoked.</source>
          <target state="translated">将来的SQLite版本中可能会添加新的动词。现有的动词可能会中断。应用程序应检查来自&lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;的返回码，以确保该调用有效。所述&lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;如果一个中断或不支持的动词被调用接口将返回非零错误代码。</target>
        </trans-unit>
        <trans-unit id="b162b6ee72989cc021180a9aa2d3a7a0e2b57826" translate="yes" xml:space="preserve">
          <source>New zip archives may be constructed entirely within memory using the zipfile() aggregate function. Each row visited by the aggregate function adds an entry to the zip archive. The value returned is a blob containing the entire archive image.</source>
          <target state="translated">新的压缩包可以使用 zipfile()aggregate 函数完全在内存中构建。聚合函数所访问的每一行都会给zip存档添加一个条目。返回的值是一个包含整个存档图像的blob。</target>
        </trans-unit>
        <trans-unit id="e327377c14f6ddd81b93544df605d7203e2995e8" translate="yes" xml:space="preserve">
          <source>NewRowid</source>
          <target state="translated">NewRowid</target>
        </trans-unit>
        <trans-unit id="6975bed1eebd03a852e5aa6a11d0f144cd34ff6e" translate="yes" xml:space="preserve">
          <source>Newer disk drives have begun using 4096 byte sectors however. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16), the SQLite development team experimented with changes xSectorSize to report 4096 bytes as the blast radius. This had the effect of increasing write overhead on many databases. For a database with a &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; of 1024 (a very common choice) making a change to a single page in the database now requires SQLite to backup three other adjacent pages to the rollback journal, whereas formerly it only had to backup the one page that was changing. In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, each transaction had to be padded out to the next 4096-byte boundary in the WAL file, rather than the next 512-byte boundary, resulting in thousands of extra bytes being written per transaction.</source>
          <target state="translated">但是，较新的磁盘驱动器已开始使用4096字节的扇区。从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;版本3.7.10&lt;/a&gt;（2012-01-16）开始，SQLite开发团队进行了实验，对xSectorSize进行了更改，以将4096字节报告为爆炸半径。这样的结果是增加了许多数据库的写开销。对于&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt;为1024（一个非常常见的选择）的数据库，现在更改到数据库中的单个页面需要SQLite将其他三个相邻页面备份到回滚日志中，而以前只需要备份一个在改变。在&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;，必须将每个事务填充到WAL文件中的下一个4096字节边界，而不是下一个512字节边界，从而导致每个事务写入数千个额外的字节。</target>
        </trans-unit>
        <trans-unit id="bc981983e7f547dc62e19a1e383acfe00782a6d5" translate="yes" xml:space="preserve">
          <source>Next</source>
          <target state="translated">Next</target>
        </trans-unit>
        <trans-unit id="bc1189b8a3e7e2b908b403ea79a8eb14b14bcd47" translate="yes" xml:space="preserve">
          <source>Next, make copies of all the blobs into individual files in a directory using a command like this:</source>
          <target state="translated">接下来,使用这样的命令将所有的 blobs 复制到目录中的各个文件中。</target>
        </trans-unit>
        <trans-unit id="73f7cfb7746314674a12b8d200b36135947e050b" translate="yes" xml:space="preserve">
          <source>Next, move the resulting kvtest-android executable to the Android device:</source>
          <target state="translated">接下来,将生成的kvtest-android可执行文件移动到Android设备上。</target>
        </trans-unit>
        <trans-unit id="21d2b394790e7b47b83f7c9d1daa6c55ee3c0c16" translate="yes" xml:space="preserve">
          <source>Next, suppose that you want to look up the price of not just any orange, but specifically California-grown oranges. The appropriate query would be as follows:</source>
          <target state="translated">接下来,假设你想查询的不是任何橙子的价格,而是特别想查询加州种植的橙子的价格。适当的查询方式如下。</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="dad2991d263e4aa51578f91e92e9777428d9762b" translate="yes" xml:space="preserve">
          <source>No (Note 1)</source>
          <target state="translated">否(注1)</target>
        </trans-unit>
        <trans-unit id="b4f66722cbcf69861e819a02ca8d6803b779fcd3" translate="yes" xml:space="preserve">
          <source>No Isolation Between Operations On The Same Database Connection</source>
          <target state="translated">同一数据库连接上的操作之间没有隔离。</target>
        </trans-unit>
        <trans-unit id="8dae863821cb04b5484c9a0e7717d726d350b9bd" translate="yes" xml:space="preserve">
          <source>No application file I/O code to write and debug.</source>
          <target state="translated">不需要编写和调试应用文件I/O代码。</target>
        </trans-unit>
        <trans-unit id="95ec05297c8cafc96feb998f4af109f4728d5530" translate="yes" xml:space="preserve">
          <source>No change</source>
          <target state="translated">无变化</target>
        </trans-unit>
        <trans-unit id="7f2ff41fbbf4963dea6c3e81c6aa743e95c596b5" translate="yes" xml:space="preserve">
          <source>No current or conflicting row information is provided. The only function it is possible to call on the supplied sqlite3_changeset_iter handle is sqlite3changeset_fk_conflicts().</source>
          <target state="translated">没有提供当前或冲突的行信息。唯一可以在提供的sqlite3_changeset_iter句柄上调用的函数是sqlite3changeset_fk_conflicts()。</target>
        </trans-unit>
        <trans-unit id="7c5c383086cc31c41ab2122a84d0a48706ccfc11" translate="yes" xml:space="preserve">
          <source>No error is raised if a width or precision exceeds SQLITE_PRINTF_PRECISION_LIMIT. Instead, the large width or precision is silently truncated.</source>
          <target state="translated">如果宽度或精度超过SQLITE_PRINTF_PRECISION_LIMIT,则不会出现错误。取而代之的是,大的宽度或精度被默默地截断。</target>
        </trans-unit>
        <trans-unit id="662adfcee595804e0d0a40f3427892366f101024" translate="yes" xml:space="preserve">
          <source>No error messages are generated if an unknown pragma is issued. Unknown pragmas are simply ignored. This means if there is a typo in a pragma statement the library does not inform the user of the fact.</source>
          <target state="translated">如果发出了未知的pragma,不会产生错误信息。未知pragma会被直接忽略。这意味着如果一个pragma语句中出现了错别字,库不会通知用户这个事实。</target>
        </trans-unit>
        <trans-unit id="36386488a9bfa58ff6f23801ec174053b73ed777" translate="yes" xml:space="preserve">
          <source>No locking style. If none of the above can be supported, this locking style is used. No database locking mechanism is used. When this system is used it is not safe for a single database to be accessed by multiple clients.</source>
          <target state="translated">无锁定方式。如果以上都不能支持,则采用这种锁定方式。不使用数据库锁定机制。使用该系统时,单个数据库被多个客户端访问是不安全的。</target>
        </trans-unit>
        <trans-unit id="7b15426333f8adb77f306aae95c84b204b379d14" translate="yes" xml:space="preserve">
          <source>No locks are held on the database. The database may be neither read nor written. Any internally cached data is considered suspect and subject to verification against the database file before being used. Other processes can read or write the database as their own locking states permit. This is the default state.</source>
          <target state="translated">数据库上没有锁。数据库既不能读也不能写。任何内部缓存的数据都被认为是可疑的,在使用前要对数据库文件进行核查。其他进程可以在自己的锁定状态允许的情况下,读取或写入数据库。这是默认状态。</target>
        </trans-unit>
        <trans-unit id="589cdf57b87436c5bbc074aa5e48b70f3f3363e1" translate="yes" xml:space="preserve">
          <source>No longer in use.</source>
          <target state="translated">不再使用。</target>
        </trans-unit>
        <trans-unit id="7375825a734eee4acde64dd3de9ae4b6f89db26c" translate="yes" xml:space="preserve">
          <source>No longer used.</source>
          <target state="translated">不再使用。</target>
        </trans-unit>
        <trans-unit id="1cff8c4990053d03c141cc08cc6f740585898fb6" translate="yes" xml:space="preserve">
          <source>No one is required to follow The Rule, to know The Rule, or even to think that The Rule is a good idea. The Founder of SQLite believes that anyone who follows The Rule will live a happier and more productive life, but individuals are free to dispute or ignore that advice if they wish.</source>
          <target state="translated">没有人被要求遵守The Rule,了解The Rule,甚至认为The Rule是个好主意。SQLite的创始人认为,任何遵守The Rule的人都会过得更快乐、更有成就感,但个人可以根据自己的意愿对这一建议提出异议或置之不理。</target>
        </trans-unit>
        <trans-unit id="a4226fa0e8cf6311cf2613fee3e52c99bd81b607" translate="yes" xml:space="preserve">
          <source>No other processes can change the database so there is never a need to check the change counter and clear the user-space cache at the beginning of a transaction.</source>
          <target state="translated">没有其他进程可以更改数据库,所以永远不需要在事务开始时检查更改计数器和清除用户空间缓存。</target>
        </trans-unit>
        <trans-unit id="6b5b494aee4d1b7c43eaf07044f46f3778af61cd" translate="yes" xml:space="preserve">
          <source>No other writes may occur on the target database while the RBU update is being applied. A read-lock is held on the target database to prevent this.</source>
          <target state="translated">在应用 RBU 更新时,目标数据库上不得发生其他写操作。为了防止这种情况,目标数据库上有一个读锁。</target>
        </trans-unit>
        <trans-unit id="3943b575617ba52cb8729616c676b13dc34b8e79" translate="yes" xml:space="preserve">
          <source>No reads or writes occur except within a transaction. Any command that accesses the database (basically, any SQL command, except a few &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements) will automatically start a transaction if one is not already in effect. Automatically started transactions are committed when the last SQL statement finishes.</source>
          <target state="translated">除在事务内外，不会发生读取或写入。如果一个数据库尚未生效，那么任何访问数据库的命令（基本上是任何SQL命令，除了几个&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;语句除外）都将自动启动一个事务。最后一条SQL语句完成时，将提交自动启动的事务。</target>
        </trans-unit>
        <trans-unit id="2a9bc5ebe3cc4eba5a484c518ae347f8a47ccd50" translate="yes" xml:space="preserve">
          <source>No table in a union-vtab may contain entries that are outside of the rowid bounds established by the</source>
          <target state="translated">在union-vtab中,任何表都不能包含不在由</target>
        </trans-unit>
        <trans-unit id="7d5b25b567984a7a4091e940273bfff96cd2fed3" translate="yes" xml:space="preserve">
          <source>No. When you delete information from an SQLite database, the unused disk space is added to an internal &quot;free-list&quot; and is reused the next time you insert data. The disk space is not lost. But neither is it returned to the operating system.</source>
          <target state="translated">当你从SQLite数据库中删除信息时,未使用的磁盘空间会被添加到一个内部的 &quot;自由列表 &quot;中,并在下次插入数据时重新使用。磁盘空间不会丢失。但也不会返还给操作系统。</target>
        </trans-unit>
        <trans-unit id="d4e9f5ef9057ec35a6f3d638ab0a7b961dadfa79" translate="yes" xml:space="preserve">
          <source>NoConflict</source>
          <target state="translated">NoConflict</target>
        </trans-unit>
        <trans-unit id="66290ce3e3466df1560e431a1eebe9e205ef9f1e" translate="yes" xml:space="preserve">
          <source>Non-ASCII range characters (i.e. unicode codepoints greater than 127), or</source>
          <target state="translated">非ASCII码范围的字符(即大于127的unicode码点),或</target>
        </trans-unit>
        <trans-unit id="1bc1387523b6d25784112f80a2990511e6a57420" translate="yes" xml:space="preserve">
          <source>Non-Vista Windows platforms only support one set of DST rules. Vista only supports two. Therefore, on these platforms, historical DST calculations will be incorrect. For example, in the US, in 2007 the DST rules changed. Non-Vista Windows platforms apply the new 2007 DST rules to all previous years as well. Vista does somewhat better getting results correct back to 1986, when the rules were also changed.</source>
          <target state="translated">非Vista的Windows平台只支持一套DST规则。Vista 只支持两套。因此,在这些平台上,历史上的DST计算将是不正确的。例如,在美国,2007 年的 DST 规则发生了变化。非Vista的Windows平台将2007年新的DST规则应用于之前的所有年份。Vista平台在正确计算1986年的结果方面做得更好,因为当时的规则也发生了变化。</target>
        </trans-unit>
        <trans-unit id="b1b833538f0549b7c8aca0acf47c1aa5ac7f2fac" translate="yes" xml:space="preserve">
          <source>Non-deterministic functions might give different answers on each invocation, even if the arguments are always the same. The following are examples of non-deterministic functions:</source>
          <target state="translated">非确定性函数可能会在每次调用时给出不同的答案,即使参数总是相同。以下是非确定性函数的例子。</target>
        </trans-unit>
        <trans-unit id="cf3ad9f318d5d17809c32f85aa54a78cb4cda991" translate="yes" xml:space="preserve">
          <source>Non-streaming equivalent</source>
          <target state="translated">非流式等价物</target>
        </trans-unit>
        <trans-unit id="1d0d5248c3c8dbbb61313817bba98f17697e01b6" translate="yes" xml:space="preserve">
          <source>Non-streaming functions that accept changesets (or patchsets) as input require that the entire changeset be stored in a single buffer in memory. Similarly, those that return a changeset or patchset do so by returning a pointer to a single large buffer allocated using sqlite3_malloc(). Normally this is convenient. However, if an application running in a low-memory environment is required to handle very large changesets, the large contiguous memory allocations required can become onerous.</source>
          <target state="translated">接受变化集(或补丁集)作为输入的非流函数要求整个变化集被存储在内存中的一个缓冲区中。类似的,那些返回变化集或补丁集的函数通过返回一个指针到一个用sqlite3_malloc()分配的大缓冲区。通常这很方便。然而,如果一个在低内存环境中运行的应用程序需要处理非常大的变化集,那么所需的大的连续内存分配就会变得很麻烦。</target>
        </trans-unit>
        <trans-unit id="09f7070838a5d668002d389cd9b3fec752e6c30d" translate="yes" xml:space="preserve">
          <source>None of the safe programming languages existed for the first 10 years of SQLite's existence. SQLite could be recoded in Go or Rust, but doing so would probably introduce far more bugs than would be fixed, and it seems also likely to result in slower code.</source>
          <target state="translated">在SQLite存在的前10年,没有一种安全的编程语言存在。SQLite可以用Go或Rust重新编码,但这样做可能会引入更多的bug,而不是修复的bug,而且似乎也可能导致代码更慢。</target>
        </trans-unit>
        <trans-unit id="9b9f34e057f76ac2b419477d464548015d8ef844" translate="yes" xml:space="preserve">
          <source>None of the xSavepoint(), xRelease(), or xRollbackTo() methods will ever be called except in between calls to xBegin() and either xCommit() or xRollback().</source>
          <target state="translated">除了在调用xBegin()和xCommit()或xRollbackTo()之间,xSavepoint()、xRelease()或xRollbackTo()方法都不会被调用。</target>
        </trans-unit>
        <trans-unit id="a1fe0caa1d6e9f3e9dd7087ae4f2a9ea810cd170" translate="yes" xml:space="preserve">
          <source>Noop</source>
          <target state="translated">Noop</target>
        </trans-unit>
        <trans-unit id="2bbfb9d52741dbc3a4ff03abc70ca82cb8e2f1bc" translate="yes" xml:space="preserve">
          <source>Normal functions specify only xFunc and leave xStep and xFinal set to NULL. Aggregate functions specify xStep and xFinal and leave xFunc set to NULL. There is no separate sqlite3_create_aggregate() API.</source>
          <target state="translated">普通函数只指定xFunc,并将xStep和xFinal设置为NULL。Aggregate函数只指定xStep和xFinal,并将xFunc设置为NULL。没有单独的 sqlite3_create_aggregate()API。</target>
        </trans-unit>
        <trans-unit id="8feff5d8988d2d3b3f82fe7920cdb81d5ba04e3a" translate="yes" xml:space="preserve">
          <source>Normal meaning</source>
          <target state="translated">正常意义</target>
        </trans-unit>
        <trans-unit id="e304219719d389c0ea46b9c98590f2134fb67330" translate="yes" xml:space="preserve">
          <source>Normally, FTS5 maintains a special backing table within the database that stores the size of each column value in tokens inserted into the main FTS5 table in a separate table. This backing table is used by the &lt;a href=&quot;#xColumnSize&quot;&gt;xColumnSize&lt;/a&gt;&lt;a&gt; API function, which is in turn used by the built-in &lt;/a&gt;&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25 ranking function&lt;/a&gt; (and is likely to be useful to other ranking functions as well).</source>
          <target state="translated">通常，FTS5在数据库内维护一个特殊的备用表，该表将每个列值的大小存储在插入到单独表中的主FTS5表中的令牌中。该支持表由&lt;a href=&quot;#xColumnSize&quot;&gt;xColumnSize &lt;/a&gt;&lt;a&gt;API函数&lt;/a&gt;使用，而xColumnSize API函数又由内置&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25排名函数使用&lt;/a&gt;（并且可能对其他排名函数也很有用）。</target>
        </trans-unit>
        <trans-unit id="866b49d7e3deb743a545b4433375afa6debe3327" translate="yes" xml:space="preserve">
          <source>Normally, NULL SQL results are stored in the array using the &lt;a href=&quot;#nullvalue&quot;&gt;nullvalue&lt;/a&gt; setting. However, if the &lt;b&gt;-withoutnulls&lt;/b&gt; option is used, then NULL SQL values cause the corresponding array element to be unset instead.</source>
          <target state="translated">通常情况下，NULL SQL结果存储使用在阵列中&lt;a href=&quot;#nullvalue&quot;&gt;NullValue属性&lt;/a&gt;设置。但是，如果使用&lt;b&gt;-withoutnulls&lt;/b&gt;选项，则NULL SQL值将导致未设置相应的数组元素。</target>
        </trans-unit>
        <trans-unit id="d1f5712d735a4022fc9c1482cc2c46055815935d" translate="yes" xml:space="preserve">
          <source>Normally, SQLite assumes that if a power failure occurs while updating any portion of a sector then the contents of the entire device sector is suspect following recovery. After writing to any part of a sector within a file, it is assumed that the modified sector contents are held in a volatile buffer somewhere within the system (main memory, disk cache etc.). SQLite does not assume that the updated data has reached the persistent storage media, until after it has successfully</source>
          <target state="translated">通常情况下,SQLite假设在更新扇区任何部分时发生断电,那么恢复后整个设备扇区的内容都是可疑的。在对文件内的扇区的任何部分进行写入后,假设修改后的扇区内容被保存在系统内的某个易失性缓冲区(主内存、磁盘缓存等)。SQLite不会假设更新后的数据已经到达了持久性存储介质,直到它成功地实现了</target>
        </trans-unit>
        <trans-unit id="e5b528fefcff05064efc30021e7a7579eaaad4d2" translate="yes" xml:space="preserve">
          <source>Normally, a token or token prefix query is matched against the FTS table column specified as the left-hand side of the MATCH operator. Or, if the special column with the same name as the FTS table itself is specified, against all columns. This may be overridden by specifying a column-name followed by a &quot;:&quot; character before a basic term query. There may be space between the &quot;:&quot; and the term to query for, but not between the column-name and the &quot;:&quot; character. For example:</source>
          <target state="translated">通常情况下,令牌或令牌前缀查询会与MATCH操作符左侧指定的FTS表列进行匹配。或者,如果指定了与FTS表本身同名的特殊列,则与所有列匹配。这可以通过在基本术语查询前指定列名后跟一个&quot;:&quot;字符来覆盖。在&quot;:&quot;和要查询的术语之间可以有空格,但在列名和&quot;:&quot;字符之间不能有空格。例如:&quot;:&quot;字样。</target>
        </trans-unit>
        <trans-unit id="bf4491e66772ed8b491e6908438d7924fa774545" translate="yes" xml:space="preserve">
          <source>Normally, an SQL index references columns of a table. But an index can also be formed on expressions involving table columns.</source>
          <target state="translated">通常情况下,SQL索引会引用表的列,但也可以在涉及表列的表达式上形成索引。但是索引也可以在涉及表列的表达式上形成。</target>
        </trans-unit>
        <trans-unit id="39e8cea13d3d48550994e6ce4ac623d3130ee592" translate="yes" xml:space="preserve">
          <source>Normally, fossil will modify all the files in your checkout when switching between the private and the public branches. But at this point, the files are identical in both branches so not modifications need to be made.</source>
          <target state="translated">一般情况下,化石在私有分支和公共分支之间切换时,会修改你结账中的所有文件。但此时,两个分支中的文件是相同的,所以不需要修改。</target>
        </trans-unit>
        <trans-unit id="d3d92a3c721eaacd534b06f545203c90c257b9b9" translate="yes" xml:space="preserve">
          <source>Normally, full-text queries are case-insensitive. However, this is dependent on the specific &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt; used by the FTS table being queried. Refer to the section on &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizers&lt;/a&gt; for details.</source>
          <target state="translated">通常，全文查询不区分大小写。但是，这取决于要查询的FTS表使用的特定&lt;a href=&quot;fts3#tokenizer&quot;&gt;标记&lt;/a&gt;器。有关详细信息，请参阅关于分&lt;a href=&quot;fts3#tokenizer&quot;&gt;词器&lt;/a&gt;的部分。</target>
        </trans-unit>
        <trans-unit id="63e53b72fdcc0af9b1c300c26469b45178a485e4" translate="yes" xml:space="preserve">
          <source>Normally, the FTS module maintains an inverted index of all terms in all columns of the table. This option is used to specify the name of a column for which entries should not be added to the index. Multiple &quot;notindexed&quot; options may be used to specify that multiple columns should be omitted from the index. For example:</source>
          <target state="translated">通常情况下,FTS模块会对表中所有列的所有术语进行倒置索引。这个选项用来指定不应该在索引中添加条目的列名。可以使用多个 &quot;notindexed &quot;选项来指定从索引中省略多个列。例如:&quot;notindexed &quot;选项用于指定多个列的名称,这些列不应被添加到索引中。</target>
        </trans-unit>
        <trans-unit id="ebe2262110ee72155bb934332e4fc5587e66a440" translate="yes" xml:space="preserve">
          <source>Normally, the database &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and whether or not the database supports &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; must be configured before the database file is actually created. However, when not in &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; mode, the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and/or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; properties of an existing database may be changed by using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and/or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;pragma auto_vacuum&lt;/a&gt; pragmas and then immediately VACUUMing the database. When in &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; mode, only the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; support property can be changed using VACUUM.</source>
          <target state="translated">通常，必须在实际创建数据库文件之前配置数据库的&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt;以及数据库是否支持&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;。但是，当不在&lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt;模式下时，可以使用&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt;和/或&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;pragma auto_vacuum&lt;/a&gt;编译指示来更改现有数据库的&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt;和/或&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;属性，然后立即对数据库进行VACUUM。在&lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt;模式下，只能使用VACUUM更改&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;支持属性。</target>
        </trans-unit>
        <trans-unit id="5df62864e283fb4361bad80921bbac8b7ec57013" translate="yes" xml:space="preserve">
          <source>Normally, when SQLite writes to a database file, it waits until the write operation is finished before returning control to the calling application. Since writing to the file-system is usually very slow compared with CPU bound operations, this can be a performance bottleneck. The asynchronous I/O backend is an extension that causes SQLite to perform all write requests using a separate thread running in the background. Although this does not reduce the overall system resources (CPU, disk bandwidth etc.), it does allow SQLite to return control to the caller quickly even when writing to the database.</source>
          <target state="translated">通常情况下,当SQLite向数据库文件写入时,它会等到写入操作完成后才将控制权返回给调用应用程序。由于向文件系统写操作与CPU绑定的操作相比,通常非常慢,这可能是一个性能瓶颈。异步I/O后端是一个扩展,它使SQLite使用一个单独的线程在后台运行来执行所有的写请求。虽然这并没有减少整体的系统资源(CPU、磁盘带宽等),但它允许SQLite即使在向数据库写入时也能快速将控制权返回给调用者。</target>
        </trans-unit>
        <trans-unit id="b810f7b8c9c4b12cca67db5205f27d6d0477e848" translate="yes" xml:space="preserve">
          <source>Normally, when a row is inserted into an FTS5 table, as well as the various full-text index entries and other data a copy of the row is stored in a private table managed by the FTS5 module. When column values are requested from the FTS5 table by the user or by an auxiliary function implementation, they are read from this private table. The &quot;content&quot; option may be used to create an FTS5 table that stores only FTS full-text index entries. Because the column values themselves are usually much larger than the associated full-text index entries, this can save significant database space.</source>
          <target state="translated">通常情况下,当一行插入到FTS5表中时,以及各种全文索引条目和其他数据,该行的副本被存储在FTS5模块管理的私有表中。当用户或辅助功能实现从FTS5表中请求列值时,它们将从这个私有表中读取。&quot;内容 &quot;选项可以用来创建一个只存储FTS全文索引项的FTS5表。由于列值本身通常比相关的全文索引条目大得多,因此可以节省大量的数据库空间。</target>
        </trans-unit>
        <trans-unit id="ca1dd39379254ab3f3c73dbffb0d03d628b27d20" translate="yes" xml:space="preserve">
          <source>Not</source>
          <target state="translated">Not</target>
        </trans-unit>
        <trans-unit id="5927a7e485b2adcf5a36cf65c4801a2eed120fcc" translate="yes" xml:space="preserve">
          <source>Not all applications meet these conditions. Fortunately, the NGQP will still usually find good query plans, even without these conditions. However, cases do arise (rarely) where performance regressions can occur.</source>
          <target state="translated">并非所有的应用都符合这些条件。幸运的是,即使没有这些条件,NGQP通常仍然会找到好的查询计划。然而,确实会出现(很少)性能倒退的情况。</target>
        </trans-unit>
        <trans-unit id="6938024f626f02a7276620a318f6367169f62576" translate="yes" xml:space="preserve">
          <source>Not all test cases can be handled this way. Some test cases check to verify that the optimizations really are reducing the amount of computation by counting the number of disk accesses, sort operations, full-scan steps, or other processing steps that occur during queries. Those test cases will appear to fail when optimizations are disabled. But the majority of test cases simply check that the correct answer was obtained, and all of those cases can be run successfully with and without the optimizations, in order to show that the optimizations do not cause malfunctions.</source>
          <target state="translated">并非所有的测试用例都可以这样处理。有些测试用例通过计算查询过程中发生的磁盘访问次数、排序操作、全扫描步骤或其他处理步骤来检查验证优化是否真的减少了计算量。当优化被禁用时,这些测试用例会出现失败。但大多数测试用例只是检查是否得到了正确的答案,所有这些用例都可以在有优化和没有优化的情况下成功运行,以表明优化不会导致故障。</target>
        </trans-unit>
        <trans-unit id="d047995ecc6203bb86f7cef3de1f0a2b4fa5dba8" translate="yes" xml:space="preserve">
          <source>Not ever decimal number with fewer than 16 significant digits can be represented exactly as a binary64 number. In fact, most decimal numbers with digits to the right of the decimal point lack an exact binary64 equivalent. For example, if you have a database column that is intended to hold an item price in dollars and cents, the only cents value that can be exactly represented are 0.00, 0.25, 0.50, and 0.75. Any other numbers to the right of the decimal point result in an approximation. If you provide a &quot;price&quot; value of 47.49, that number will be represented in binary64 as:</source>
          <target state="translated">并非所有少于16位有意义的十进制数都能精确地表示为二进制64数。事实上,大多数小数点右边有数字的十进制数都缺乏一个精确的二进制64等价数。例如,如果您有一个数据库列,打算用美元和美分来表示一个项目的价格,那么唯一可以精确表示的美分值是0.00、0.25、0.50和0.75。小数点右边的任何其他数字都是近似值。如果你提供的 &quot;价格 &quot;值是47.49,那么这个数字在二进制64中就会被表示为。</target>
        </trans-unit>
        <trans-unit id="ef42529ee731ef3b3603a24c66a4c6f388b99dce" translate="yes" xml:space="preserve">
          <source>Not every decimal number with fewer than 16 significant digits can be represented exactly as a binary64 number. In fact, most decimal numbers with digits to the right of the decimal point lack an exact binary64 equivalent. For example, if you have a database column that is intended to hold an item price in dollars and cents, the only cents value that can be exactly represented are 0.00, 0.25, 0.50, and 0.75. Any other numbers to the right of the decimal point result in an approximation. If you provide a &quot;price&quot; value of 47.49, that number will be represented in binary64 as:</source>
          <target state="translated">并非每一个少于16位有意义的十进制数都可以精确地表示为二进制64数。事实上,大多数小数点右边有数字的十进制数都缺乏一个精确的二进制64等价数。例如,如果你有一个数据库列,打算用美元和美分来表示一个项目的价格,那么唯一可以精确表示的美分值是0.00、0.25、0.50和0.75。小数点右边的任何其他数字都是近似值。如果你提供的 &quot;价格 &quot;值是47.49,那么这个数字在二进制64中就会被表示为。</target>
        </trans-unit>
        <trans-unit id="593dbd15d49368a738585302a9107baf925136df" translate="yes" xml:space="preserve">
          <source>Not shown in the example above is that there are also &lt;a href=&quot;fts5#fts5_table_creation_and_initialization&quot;&gt;various options&lt;/a&gt; that may be provided to FTS5 as part of the CREATE VIRTUAL TABLE statement to configure various aspects of the new table. These may be used to modify the way in which the FTS5 table extracts terms from documents and queries, to create extra indexes on disk to speed up prefix queries, or to create an FTS5 table that acts as an index on content stored elsewhere.</source>
          <target state="translated">在上面的示例中未显示的是，还有一些&lt;a href=&quot;fts5#fts5_table_creation_and_initialization&quot;&gt;选项&lt;/a&gt;可以作为CREATE VIRTUAL TABLE语句的一部分提供给FTS5，以配置新表的各个方面。这些可用于修改FTS5表从文档和查询中提取术语的方式，在磁盘上创建额外的索引以加快前缀查询的速度，或用于创建FTS5表作为对其他位置存储的内容的索引。</target>
        </trans-unit>
        <trans-unit id="edbfab21e07e4e0dbe02fb875980c40bdd52ad0f" translate="yes" xml:space="preserve">
          <source>NotExists</source>
          <target state="translated">NotExists</target>
        </trans-unit>
        <trans-unit id="6f05e7cc9203f83829c08dcc46fafe9db426763f" translate="yes" xml:space="preserve">
          <source>NotFound</source>
          <target state="translated">NotFound</target>
        </trans-unit>
        <trans-unit id="85c73c74f4b29a9fb7ba8d0a5bc532eb27f0866a" translate="yes" xml:space="preserve">
          <source>NotNull</source>
          <target state="translated">NotNull</target>
        </trans-unit>
        <trans-unit id="7884a1030f088443b3e65dc8c7d9c833c3f14209" translate="yes" xml:space="preserve">
          <source>Nota bene:</source>
          <target state="translated">Nota bene:</target>
        </trans-unit>
        <trans-unit id="59ab81d7ff99620547d7c60a07878ec16f88cba0" translate="yes" xml:space="preserve">
          <source>Note also that when adding a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt;, the CHECK constraint is not tested against preexisting rows of the table. This can result in a table that contains data that is in violation of the CHECK constraint. Future versions of SQLite might change to validate CHECK constraints as they are added.</source>
          <target state="translated">还要注意，在添加&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK约束时&lt;/a&gt;，不会针对表的现有行测试CHECK约束。这可能导致表中包含违反CHECK约束的数据。将来的SQLite版本可能会更改以验证添加时的CHECK约束。</target>
        </trans-unit>
        <trans-unit id="63cff68b4cc8b6d1593b377ca2761e4a780c9aef" translate="yes" xml:space="preserve">
          <source>Note that &quot;monotonically increasing&quot; does not imply that the ROWID always increases by exactly one. One is the usual increment. However, if an insert fails due to (for example) a uniqueness constraint, the ROWID of the failed insertion attempt might not be reused on subsequent inserts, resulting in gaps in the ROWID sequence. AUTOINCREMENT guarantees that automatically chosen ROWIDs will be increasing but not that they will be sequential.</source>
          <target state="translated">请注意,&quot;单调递增 &quot;并不意味着ROWID总是正好增加1。1是通常的增量。但是,如果由于(例如)唯一性约束导致插入失败,那么失败的插入尝试的ROWID可能不会在后续的插入中被重复使用,导致ROWID序列出现空白。AUTOINCREMENT保证自动选择的ROWID会不断增加,但不保证它们是有顺序的。</target>
        </trans-unit>
        <trans-unit id="4308667a324be6565f7e88fc7a4b19a7777f66dd" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">请注意，&lt;a href=&quot;#sqlite3_create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;或&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;可能会间接影响数据库的副作用。例如，如果应用程序定义了调用&lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;的函数&amp;ldquo; eval（）&amp;rdquo; ，则以下SQL语句将通过副作用更改数据库文件：</target>
        </trans-unit>
        <trans-unit id="2de1256b9fbe19c405bb475cc7365f640da5726d" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">请注意，&lt;a href=&quot;../appfunc&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;或&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;可能会间接影响数据库的副作用。例如，如果应用程序定义了调用&lt;a href=&quot;exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;的函数&amp;ldquo; eval（）&amp;rdquo; ，则以下SQL语句将通过副作用更改数据库文件：</target>
        </trans-unit>
        <trans-unit id="2a8f4592d0e17a85103883247d0a4447a3744957" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are by default considered non-deterministic and may not be used in a CREATE INDEX statement unless the &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is used when the function is registered.</source>
          <target state="translated">请注意，默认情况下，&lt;a href=&quot;appfunc&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;被认为是不确定的，除非在注册函数时使用&lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;标志，否则不得在CREATE INDEX语句中使用该函数。</target>
        </trans-unit>
        <trans-unit id="1de4b11ed42096116749429497dc130939876ea1" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">请注意，&lt;a href=&quot;appfunc&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;或&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;可能会间接影响数据库的副作用。例如，如果应用程序定义了调用&lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;的函数&amp;ldquo; eval（）&amp;rdquo; ，则以下SQL语句将通过副作用更改数据库文件：</target>
        </trans-unit>
        <trans-unit id="aa33906842475ccf0659a59159f766bfacc10e93" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are by default considered non-deterministic and may not be used in a CREATE INDEX statement unless the &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is used when the function is registered.</source>
          <target state="translated">请注意，默认情况下，&lt;a href=&quot;c3ref/create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;被认为是不确定的，除非在注册函数时使用&lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;标志，否则不得在CREATE INDEX语句中使用该函数。</target>
        </trans-unit>
        <trans-unit id="5f9e6d6d8a3bf2c6d2a7e519940c1c6c58742f80" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">请注意，&lt;a href=&quot;create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;或&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;可能会间接影响数据库的副作用。例如，如果应用程序定义了调用&lt;a href=&quot;exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;的函数&amp;ldquo; eval（）&amp;rdquo; ，则以下SQL语句将通过副作用更改数据库文件：</target>
        </trans-unit>
        <trans-unit id="f679875d06130633120a14b47faa759dd16975f1" translate="yes" xml:space="preserve">
          <source>Note that Idx3 contains all the same information as the original &lt;a href=&quot;#fig3&quot;&gt;Idx1&lt;/a&gt;. And so if we have Idx3, we do not really need Idx1 any more. The &quot;price of peaches&quot; query can be satisfied using Idx3 by simply ignoring the &quot;state&quot; column of Idx3:</source>
          <target state="translated">请注意，Idx3包含与原始&lt;a href=&quot;#fig3&quot;&gt;Idx1&lt;/a&gt;相同的所有信息。因此，如果我们拥有Idx3，我们将不再真正需要Idx1。只需忽略Idx3的&amp;ldquo;状态&amp;rdquo;列，就可以使用Idx3满足&amp;ldquo;桃子的价格&amp;rdquo;查询：</target>
        </trans-unit>
        <trans-unit id="8e97b2bc14d77a13e225d171f50b67e2004fff89" translate="yes" xml:space="preserve">
          <source>Note that MinGW generates 32-bit DLLs only. There is a separate MinGW64 project that can be used to generate 64-bit DLLs. Presumably the command-line syntax is similar. Also note that recent versions of MSVC generate DLLs that will not work on WinXP and earlier versions of Windows. So for maximum compatibility of your generated DLL, MinGW is recommended. A good rule-of-thumb is to generate 32-bit DLLs using MinGW and 64-bit DLLs using MSVC.</source>
          <target state="translated">请注意,MinGW只生成32位DLL。有一个单独的MinGW64项目可以用来生成64位DLL。大概命令行语法是类似的。还需要注意的是,MSVC的最新版本生成的DLL不能在WinXP和早期版本的Windows上工作。所以为了使你生成的DLL具有最大的兼容性,建议使用MinGW。一个好的经验法则是使用MinGW生成32位DLL,使用MSVC生成64位DLL。</target>
        </trans-unit>
        <trans-unit id="103d786acd07e894276011f9fe0ff0e5d6f3f4da" translate="yes" xml:space="preserve">
          <source>Note that SQLITE_IGNORE is also used as a &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">请注意，SQLITE_IGNORE也用作从&lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;接口返回的&lt;a href=&quot;#SQLITE_FAIL&quot;&gt;冲突解决模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82cf9ab6c420a3c604d44b14992c4f512d1f4c35" translate="yes" xml:space="preserve">
          <source>Note that SQLITE_IGNORE is also used as a &lt;a href=&quot;c_fail&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">请注意，SQLITE_IGNORE也用作从&lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;接口返回的&lt;a href=&quot;c_fail&quot;&gt;冲突解决模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63e763dca84d9237a89baecc3d0c141975e41415" translate="yes" xml:space="preserve">
          <source>Note that SQLite allows the number of reserve-bytes to be increased but not decreased. So if a database file already has a reserve-bytes value greater than 8, there is no way to activate checksumming on that database, other than to dump and restore the database file. Note also that other extensions might also make use of the reserve-bytes. Checksumming will be incompatible with those other extensions.</source>
          <target state="translated">请注意,SQLite允许增加而不是减少储备字节数。因此,如果一个数据库文件的 reserve-bytes 值已经大于 8,那么除了转储和恢复数据库文件之外,没有办法在该数据库上激活校验和。还要注意的是,其他扩展也可能会使用 reserve-bytes。Checksumming将与这些其他扩展不兼容。</target>
        </trans-unit>
        <trans-unit id="bd4aaf9aa187deca337c2af0406d2d0e3c9d07f4" translate="yes" xml:space="preserve">
          <source>Note that SQLite allows the parenthesized list of scalar values on the right-hand side of an IN or NOT IN operator to be an empty list but most other SQL database database engines and the SQL92 standard require the list to contain at least one element.</source>
          <target state="translated">请注意,SQLite允许IN或NOT IN操作符右侧的标量值的括号列表是一个空列表,但大多数其他SQL数据库数据库引擎和SQL92标准要求该列表至少包含一个元素。</target>
        </trans-unit>
        <trans-unit id="069a48733ca46d6fc20e074068d69739ed664b2b" translate="yes" xml:space="preserve">
          <source>Note that SQLite automatically adds the appropriate extension suffix (&quot;.dll&quot; on windows, &quot;.dylib&quot; on Mac, &quot;.so&quot; on most other unixes) to the extension filename. It is generally a good idea to specify the full pathname of the extension.</source>
          <target state="translated">请注意,SQLite会自动在扩展名中添加适当的扩展名后缀(在windows下为&quot;.dll&quot;,在Mac上为&quot;.dylib&quot;,在大多数其他unixes上为&quot;.so&quot;)。一般来说,指定扩展名的完整路径名是个好主意。</target>
        </trans-unit>
        <trans-unit id="878abfb73c8f4fd7637bff37205a9854afa6975b" translate="yes" xml:space="preserve">
          <source>Note that SQLite comes with several &lt;a href=&quot;../malloc#altalloc&quot;&gt;built-in memory allocators&lt;/a&gt; that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.</source>
          <target state="translated">请注意，SQLite附带了几个&lt;a href=&quot;../malloc#altalloc&quot;&gt;内置的内存分配器&lt;/a&gt;，它们完全适合绝大多数应用程序，并且该对象仅对极少数具有特殊内存分配要求的应用程序有用。在测试SQLite期间，也使用此对象，以指定模拟内存不足条件的备用内存分配器，以验证SQLite是否可以从此类条件正常恢复。</target>
        </trans-unit>
        <trans-unit id="8a9932e44739c8fef89cbf2d998599f354bb604b" translate="yes" xml:space="preserve">
          <source>Note that SQLite comes with several &lt;a href=&quot;malloc#altalloc&quot;&gt;built-in memory allocators&lt;/a&gt; that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.</source>
          <target state="translated">请注意，SQLite附带了几个&lt;a href=&quot;malloc#altalloc&quot;&gt;内置的内存分配器&lt;/a&gt;，它们完全适合绝大多数应用程序，并且该对象仅对极少数具有特殊内存分配要求的应用程序有用。在测试SQLite期间，也使用此对象，以指定模拟内存不足条件的备用内存分配器，以验证SQLite是否可以从此类条件正常恢复。</target>
        </trans-unit>
        <trans-unit id="f1f541cbfa03c47b900f800f3f8afdec05b49044" translate="yes" xml:space="preserve">
          <source>Note that SQLite does not enforce the PRIMARY KEY for a WITHOUT ROWID virtual table. Enforcement is the responsibility of the underlying virtual table implementation. But SQLite does assume that the PRIMARY KEY constraint is valid - that the identified columns really are UNIQUE and NOT NULL - and it uses that assumption to optimize queries against the virtual table.</source>
          <target state="translated">请注意,SQLite不强制执行without ROWID虚拟表的PRIMARY KEY。执行是底层虚拟表实现的责任。但是SQLite确实假设PRIMARY KEY约束是有效的,即所确定的列确实是UNIQUE而非NULL,并且它使用该假设来优化对虚拟表的查询。</target>
        </trans-unit>
        <trans-unit id="d3bdb4d9a8050dadd7145a64b6065f6da75ef0eb" translate="yes" xml:space="preserve">
          <source>Note that SQLite must believe whatever the operating system and hardware tell it about the status of sync requests. There is no way for SQLite to detect that either is lying and that writes might be occurring out-of-order. However, SQLite in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is far more forgiving of out-of-order writes than in the default rollback journal modes. In WAL mode, the only time that a failed sync operation can cause database corruption is during a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operation. A sync failure during a COMMIT might result in loss of durability but not in a corrupt database file. Hence, one line of defense against database corruption due to failed sync operations is to use SQLite in WAL mode and to checkpoint as infrequently as possible.</source>
          <target state="translated">请注意，无论操作系统和硬件如何告知SQLite，SQLite都必须相信同步请求的状态。 SQLite无法检测到两者都在说谎，并且写操作可能是乱序发生的。但是，与默认回滚日志模式相比，&lt;a href=&quot;wal&quot;&gt;WAL模式下的&lt;/a&gt; SQLite 更能容忍无序写入。在WAL模式下，失败的同步操作可能导致数据库损坏的唯一时间是在&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;操作期间。 COMMIT期间的同步失败可能会导致持久性损失，但不会导致数据库文件损坏。因此，防止由于同步操作失败而导致数据库损坏的一道防线是在WAL模式下使用SQLite并尽可能不频繁地检查点。</target>
        </trans-unit>
        <trans-unit id="a2fee544cde41af143fe81786b7190276086b344" translate="yes" xml:space="preserve">
          <source>Note that SQLite uses b-trees, which are a sorted data structure, so indices can be used when the WHERE clause of the SELECT statement contains tests for equality or inequality. Queries like the following can use an index if it is available:</source>
          <target state="translated">请注意,SQLite使用b树,b树是一种排序的数据结构,所以当SELECT语句的WHERE子句包含平等或不平等的测试时,可以使用索引。像下面这样的查询,如果有索引,就可以使用索引。</target>
        </trans-unit>
        <trans-unit id="5081483bfc5c0173b67743dd4507d0595797d951" translate="yes" xml:space="preserve">
          <source>Note that a declared type of &quot;FLOATING POINT&quot; would give INTEGER affinity, not REAL affinity, due to the &quot;INT&quot; at the end of &quot;POINT&quot;. And the declared type of &quot;STRING&quot; has an affinity of NUMERIC, not TEXT.</source>
          <target state="translated">请注意,声明的 &quot;FLOATING POINT &quot;类型会给出INTEGER亲和力,而不是REAL亲和力,因为 &quot;POINT &quot;的末尾有 &quot;INT&quot;。而声明的 &quot;STRING &quot;类型的亲和力是NUMERIC,而不是TEXT。</target>
        </trans-unit>
        <trans-unit id="6008db09d7c79dcc3b84a140fc5e215929e6ce79" translate="yes" xml:space="preserve">
          <source>Note that a transformation that flips the polygon might cause the order of vertexes to be reversed. In other words, the transformation might cause the vertexes to circulate in clockwise order instead of counter-clockwise. This can be corrected by sending the result through the &lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw()&lt;/a&gt; function after transformation.</source>
          <target state="translated">请注意，翻转多边形的转换可能导致顶点顺序颠倒。换句话说，该变换可能导致顶点以顺时针方向而不是逆时针方向循环。可以通过在转换后通过&lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw（）&lt;/a&gt;函数发送结果来纠正此问题。</target>
        </trans-unit>
        <trans-unit id="3eb1501d271603c6953bfb8ef829d45c83d17e8d" translate="yes" xml:space="preserve">
          <source>Note that an inner transaction might commit (using the RELEASE command) but then later have its work undone by a ROLLBACK in an outer transaction. A power failure or program crash or OS crash will cause the outer-most transaction to rollback, undoing all changes that have occurred within that outer transaction, even changes that have supposedly been &quot;committed&quot; by the RELEASE command. Content is not actually committed on the disk until the outermost transaction commits.</source>
          <target state="translated">请注意,一个内部事务可能会提交(使用RELEASE命令),但随后会被外部事务中的ROLLBACK命令撤销。断电、程序崩溃或操作系统崩溃都会导致最外层的事务回滚,从而撤销在该外层事务中发生的所有更改,甚至包括那些被RELEASE命令 &quot;提交 &quot;的更改。在最外层事务提交之前,磁盘上的内容并没有实际提交。</target>
        </trans-unit>
        <trans-unit id="7c93fd99fb4687ad2997daf3b6769cc616b7c58e" translate="yes" xml:space="preserve">
          <source>Note that conflict resolutions from multiple remote changesets are combined on a per-field basis, not per-row. This means that in the case of multiple remote UPDATE operations, some fields of a single local change may be rebased for REPLACE while others are rebased for OMIT.</source>
          <target state="translated">请注意,来自多个远程更改集的冲突解决是在每个字段的基础上合并的,而不是每个行。这意味着,在多个远程UPDATE操作的情况下,单个本地变更的一些字段可能会被重新基于REPLACE,而其他字段会被重新基于OMIT。</target>
        </trans-unit>
        <trans-unit id="e3af7101a58299023cb05d90e0fc88f9fa63608b" translate="yes" xml:space="preserve">
          <source>Note that conversions between UTF-16be and UTF-16le are always done in place and do not invalidate a prior pointer, though of course the content of the buffer that the prior pointer points to will have been modified. Other kinds of conversion are done in place when it is possible, but sometime it is not possible and in those cases prior pointers are invalidated.</source>
          <target state="translated">请注意,UTF-16be和UTF-16le之间的转换总是在原地进行的,不会使先前的指针无效,当然先前指针指向的缓冲区的内容会被修改。其他类型的转换在可能的情况下会在原地进行,但有时不可能,在这种情况下,先前的指针会失效。</target>
        </trans-unit>
        <trans-unit id="f0c5f85c046ed0d0d783a57a522950f881e39de3" translate="yes" xml:space="preserve">
          <source>Note that deleting records from a zip archive does not reclaim the space used within the archive - it merely removes an entry from the archives &quot;Central Directory Structure&quot;, making the entry inaccessible. One way to work around this inefficiency is to create a new zip archive based on the contents of the edited archive. For example, after editing the archive accessed via virtual table temp.zzz:</source>
          <target state="translated">请注意,从 zip 存档中删除记录并不能收回存档中使用的空间--它只是从存档的 &quot;中央目录结构 &quot;中删除了一个条目,使得该条目无法访问。绕过这种低效率的一种方法是根据已编辑的归档内容创建一个新的 zip 归档。例如,在编辑了通过虚拟表 temp.zzz 访问的归档后。</target>
        </trans-unit>
        <trans-unit id="710cdb120286dd832bd6798397cffbb5dfeed9ef" translate="yes" xml:space="preserve">
          <source>Note that different operating systems use different filename suffixes for their shared libraries. Windows use &quot;.dll&quot;, Mac uses &quot;.dylib&quot;, and most unixes other than mac use &quot;.so&quot;. If you want to make your code portable, you can omit the suffix from the shared library filename and the appropriate suffix will be added automatically by the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface.</source>
          <target state="translated">请注意，不同的操作系统为其共享库使用不同的文件名后缀。Windows使用&amp;ldquo; .dll&amp;rdquo;，Mac使用&amp;ldquo; .dylib&amp;rdquo;，除Mac之外的大多数Unix使用&amp;ldquo; .so&amp;rdquo;。如果要使代码可移植，则可以从共享库文件名中省略后缀，并且适当的后缀将由&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;接口自动添加。</target>
        </trans-unit>
        <trans-unit id="c12e1242a0c93cb2f83528b0161fb89fb73eac90" translate="yes" xml:space="preserve">
          <source>Note that each 32768-byte unit of the shm file has its own aHash and aPgno arrays. The aHash array for a single unit is only helpful in finding aPgno entries in that same unit. The overall FindFrame(P,M) function needs to do hash lookups beginning with the latest unit and working backwards to the oldest unit until it finds an answer.</source>
          <target state="translated">请注意,shm文件中每个32768字节的单元都有自己的aHash和aPgno数组。单个单元的aHash数组只对查找同一单元的aPgno条目有帮助。整体的FindFrame(P,M)函数需要从最新的单元开始进行哈希查找,并向后查找最老的单元,直到找到答案。</target>
        </trans-unit>
        <trans-unit id="30f49c0b1079064845cadc4000f3f0cbc4ba7f9a" translate="yes" xml:space="preserve">
          <source>Note that enabling FTS3 also makes FTS4 available. There is not a separate SQLITE_ENABLE_FTS4 compile-time option. A build of SQLite either supports both FTS3 and FTS4 or it supports neither.</source>
          <target state="translated">请注意,启用FTS3也会使FTS4可用。没有单独的SQLITE_ENABLE_FTS4编译时选项。一个SQLite的构建要么同时支持FTS3和FTS4,要么两者都不支持。</target>
        </trans-unit>
        <trans-unit id="665e7a6fdd40011f21f13b4109b67442ccc2792c" translate="yes" xml:space="preserve">
          <source>Note that except for a few corner-case differences detailed above, WITHOUT ROWID tables and rowid tables work the same. They both generate the same answers given the same SQL statements. So it is a simple matter to run experiments on an application, late in the development cycle, to test whether or not the use of WITHOUT ROWID tables will be helpful. A good strategy is to simply not worry about WITHOUT ROWID until near the end of product development, then go back and run tests to see if adding WITHOUT ROWID to tables with non-integer PRIMARY KEYs helps or hurts performance, and retaining the WITHOUT ROWID only in those cases where it helps.</source>
          <target state="translated">请注意,除了上面详述的一些角码差异外,WITHOUT ROWID表和rowid表的工作原理是一样的。给予相同的SQL语句,它们都会产生相同的答案。因此,在开发周期的后期,在应用程序上运行实验,测试使用without rowid表是否会有帮助,是一件很简单的事情。一个好的策略是,在产品开发接近尾声之前,干脆不担心WITHOUT ROWID的问题,然后回过头来运行测试,看看在具有非整数PRIMARY KEY的表上添加WITHOUT ROWID是帮助还是伤害性能,只有在那些有帮助的情况下才保留WITHOUT ROWID。</target>
        </trans-unit>
        <trans-unit id="bde5b3e09fe9bd78baf5c5b8cf655c1d83bf9828" translate="yes" xml:space="preserve">
          <source>Note that geopoly uses a traditional right-handed cartesian coordinate system with the origin at the lower left, whereas SVG uses a left-handed coordinate system with the origin at the upper left. The geopoly_svg() routine makes no attempt to transform the coordinate system, so the displayed images are shown in mirror image and rotated. If that is undesirable, the geopoly_xform() routine can be used to transform the output from cartesian to SVG coordinates prior to passing the polygons into geopoly_svg().</source>
          <target state="translated">请注意,geopoly使用传统的右手卡提斯坐标系,原点在左下方,而SVG使用左手坐标系,原点在左上方。geopoly_svg()例程没有尝试转换坐标系,所以显示的图像是以镜像和旋转的方式显示的。如果不希望出现这种情况,可以使用geopoly_xform()例程在将多边形传入geopoly_svg()之前,将输出从卡提斯坐标转换为SVG坐标。</target>
        </trans-unit>
        <trans-unit id="98a440c913714baad6d711ca1c482bbb8e3fece7" translate="yes" xml:space="preserve">
          <source>Note that if a non-deterministic function is tagged with &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; and if that function ends up being used in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; or in an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;, then when the function begins to return different answers, the associated index may become corrupt. If an SQL function is nearly deterministic (which is to say, if it only rarely changes, like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;) and it is used in an index that becomes corrupt, the corruption can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="translated">请注意，如果使用&lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;标记了不确定性函数，并且该函数最终在&lt;a href=&quot;partialindex&quot;&gt;部分索引&lt;/a&gt;的WHERE子句或&lt;a href=&quot;expridx&quot;&gt;表达式索引中使用&lt;/a&gt;，则当该函数开始返回不同的答案时，关联的索引可能会损坏。如果SQL函数几乎是确定性的（也就是说，如果它很少改变，例如&lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version（）&lt;/a&gt;），并且在已损坏的索引中使用它，则可以通过运行&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;来修复损坏。</target>
        </trans-unit>
        <trans-unit id="c13f9095e78ebed2a9c8d270bb63e3a9b47c70fe" translate="yes" xml:space="preserve">
          <source>Note that if a non-deterministic function is tagged with &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; and if that function ends up being used in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; or in an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;, then when the function begins to return different answers, the associated index may become corrupt. If an SQL function is nearly deterministic (which is to say, if it only rarely changes, like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;) and it is used in an index that becomes corrupt, the corruption can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="translated">请注意，如果使用&lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;标记了不确定性函数，并且该函数最终在&lt;a href=&quot;partialindex&quot;&gt;部分索引&lt;/a&gt;的WHERE子句或&lt;a href=&quot;expridx&quot;&gt;表达式索引中使用&lt;/a&gt;，则当该函数开始返回不同的答案时，关联的索引可能会损坏。如果SQL函数几乎是确定性的（也就是说，如果它很少改变，例如&lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version（）&lt;/a&gt;），并且在已损坏的索引中使用它，则可以通过运行&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;来修复该损坏。</target>
        </trans-unit>
        <trans-unit id="3e7ef1f945a3c3a6083df7d03b59a24fcefb7fd0" translate="yes" xml:space="preserve">
          <source>Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc() returns a different mutex on every call. For the static mutex types, the same mutex is returned on every call that has the same type number.</source>
          <target state="translated">请注意,如果使用了动态mutex参数之一(SQLITE_MUTEX_FAST或SQLITE_MUTEX_RECURSIVE),那么sqlite3_mutex_alloc()在每次调用时都会返回一个不同的mutex。对于静态的mutex类型,在每次调用时都会返回相同类型号的mutex。</target>
        </trans-unit>
        <trans-unit id="1c50891c113debf231642ee8d937768c49d352cf" translate="yes" xml:space="preserve">
          <source>Note that if you do not include the &quot;langid=N&quot; term in the WHERE clause, the search will be against language 0 (English in the example above.) All spellfix1 searches are against a single language id. There is no way to search all languages at once.</source>
          <target state="translated">请注意,如果你没有在WHERE子句中包含 &quot;langid=N&quot;,那么搜索将针对语言0(在上面的例子中是英语)。没有办法同时搜索所有语言。</target>
        </trans-unit>
        <trans-unit id="67f33837baeec763fa57cef78587afa10292c83d" translate="yes" xml:space="preserve">
          <source>Note that in most cases, SQLite will only use a single index for each table in the FROM clause of a query. The second OR-clause optimization described here is the exception to that rule. With an OR-clause, a different index might be used for each subterm in the OR-clause.</source>
          <target state="translated">请注意,在大多数情况下,SQLite只会为查询的FROM子句中的每个表使用一个索引。这里介绍的第二个OR-clause优化是这个规则的例外。对于OR-clause,可能会为OR-clause中的每个子项使用不同的索引。</target>
        </trans-unit>
        <trans-unit id="63fa9dab5a3c38f244560b4ee3d5231308f8ad59" translate="yes" xml:space="preserve">
          <source>Note that in order for the special &quot;:memory:&quot; name to apply and to create a pure in-memory database, there must be no additional text in the filename. Thus, a disk-based database can be created in a file by prepending a pathname, like this: &quot;./:memory:&quot;.</source>
          <target state="translated">请注意,为了使特殊的&quot;:memory:&quot;名称适用,并创建一个纯内存数据库,文件名中必须没有额外的文本。因此,可以在文件中通过预先添加一个路径名来创建基于磁盘的数据库,比如这样。&quot;./:内存:&quot;.</target>
        </trans-unit>
        <trans-unit id="1b52e107709738a3260fec8ebd98ff46511f5c58" translate="yes" xml:space="preserve">
          <source>Note that in the diagram above, we showed the private edits as a single commit. This was for clarity of presentation only. There is nothing to stop you from doing dozens or hundreds of separate tiny changes and committing each separately. In fact, making many small changes is the preferred way to work. The only reason for doing all the changes in a single commit is that it makes the diagram easier to draw.</source>
          <target state="translated">请注意,在上图中,我们将私人编辑显示为一次提交。这只是为了清晰地展示。没有什么能阻止你做几十个或几百个单独的小改动,并分别提交。事实上,做许多小改动是首选的工作方式。在一次提交中完成所有修改的唯一原因是,这样可以使图更容易绘制。</target>
        </trans-unit>
        <trans-unit id="705b7526443ed2af20dbc38ecc0ad5be9f1ce9d9" translate="yes" xml:space="preserve">
          <source>Note that in this design, the tokenizer calls the parser. People who are familiar with YACC and BISON may be accustomed to doing things the other way around &amp;mdash; having the parser call the tokenizer. Having the tokenizer call the parser is better, though, because it can be made threadsafe and it runs faster.</source>
          <target state="translated">请注意，在此设计中，令牌生成器调用解析器。熟悉YACC和BISON的人可能习惯于以相反的方式进行操作-让解析器调用令牌生成器。但是，让分词器调用解析器会更好，因为可以将其设置为线程安全的，并且运行速度更快。</target>
        </trans-unit>
        <trans-unit id="819e65339172e5dc379cf7c2c3439c1fadf7ced3" translate="yes" xml:space="preserve">
          <source>Note that infix functions (&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;, &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;, &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;, and &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;) reverse the order of their arguments. So &quot;like(A,B)&quot; is equivalent to &quot;B like A&quot;. For the form &quot;B like A&quot; the B term is considered the first argument to the function. But for &quot;like(A,B)&quot; the A term is considered the first argument.</source>
          <target state="translated">请注意，中缀函数（&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;，&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;，&lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;和&lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;）反转其参数的顺序。因此，&amp;ldquo; like（A，B）&amp;rdquo;等效于&amp;ldquo; B like A&amp;rdquo;。对于形式为&amp;ldquo;像A一样的B&amp;rdquo;，将B项视为函数的第一个参数。但是对于&amp;ldquo; like（A，B）&amp;rdquo;，A项被认为是第一个参数。</target>
        </trans-unit>
        <trans-unit id="020c1f099f137d5df05ab667d59b055f8f6ad42a" translate="yes" xml:space="preserve">
          <source>Note that infix functions (&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;, &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;, &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;, and &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;) reverse the order of their arguments. So &quot;like(A,B)&quot; would normally work the same as &quot;B like A&quot;. However, xFindFunction() always looks a the left-most argument, not the first logical argument. Hence, for the form &quot;B like A&quot;, SQLite looks at the left operand &quot;B&quot; and if that operand is a virtual table column it invokes the xFindFunction() method on that virtual table. But if the form &quot;like(A,B)&quot; is used instead, then SQLite checks the A term to see if it is column of a virtual table and if so it invokes the xFindFunction() method for the virtual table of column A.</source>
          <target state="translated">请注意，中缀函数（&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;，&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;，&lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;和&lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;）反转其参数的顺序。因此，&amp;ldquo; like（A，B）&amp;rdquo;通常与&amp;ldquo; B like A&amp;rdquo;相同。但是，xFindFunction（）始终看起来是最左边的参数，而不是第一个逻辑参数。因此，对于形式&amp;ldquo; B像A&amp;rdquo;的SQLite，它将查看左侧的操作数&amp;ldquo; B&amp;rdquo;，如果该操作数是虚拟表列，它将在该虚拟表上调用xFindFunction（）方法。但是，如果改为使用形式&amp;ldquo; like（A，B）&amp;rdquo;，则SQLite会检查A项以查看其是否为虚拟表的列，如果是，则为A列的虚拟表调用xFindFunction（）方法。</target>
        </trans-unit>
        <trans-unit id="35589dde916482f10a4613056291243d802b1cc4" translate="yes" xml:space="preserve">
          <source>Note that it is important to set the &quot;mode&quot; to &quot;csv&quot; before running the &quot;.import&quot; command. This is necessary to prevent the command-line shell from trying to interpret the input file text as some other format.</source>
          <target state="translated">请注意,在运行&quot;.import &quot;命令之前,必须将 &quot;mode &quot;设置为 &quot;csv&quot;。这对于防止命令行shell试图将输入文件文本解释为其他格式是必要的。</target>
        </trans-unit>
        <trans-unit id="aab0f603b95c5838db66d31fe53b5c5afd66afd1" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary for all coordinates in an R*Tree index to be constrained in order for the index search to be efficient. One might, for example, want to query all objects that overlap with the 35th parallel:</source>
          <target state="translated">请注意,为了使索引搜索效率高,并不一定要对 R*Tree 索引中的所有坐标进行约束。例如,人们可能希望查询所有与第35条平行线重叠的对象。</target>
        </trans-unit>
        <trans-unit id="750004cbbcdb4b09f134058116396d2802e69e0a" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary to quote the $bigstring value. That happens automatically. If $bigstring is a large string or binary object, this technique is not only easier to write, it is also much more efficient since it avoids making a copy of the content of $bigstring.</source>
          <target state="translated">请注意,不需要引用$bigstring的值。这是自动发生的。如果$bigstring是一个大的字符串或二进制对象,这种技术不仅更容易写,而且更有效率,因为它避免了复制$bigstring的内容。</target>
        </trans-unit>
        <trans-unit id="aedf129a94b2c6ea4cf41bd3da4352659cc6bb37" translate="yes" xml:space="preserve">
          <source>Note that it is perfectly safe for two or more threads to access the same SQLite database file using the SQLite library. The unix drivers for SQLite know about the POSIX advisory locking quirks and work around them. This problem only arises when a thread tries to bypass the SQLite library and read the database file directly.</source>
          <target state="translated">请注意,两个或多个线程使用SQLite库访问同一个SQLite数据库文件是完全安全的。SQLite的unix驱动程序知道POSIX咨询锁定的怪癖,并能绕过它们。只有当一个线程试图绕过SQLite库,直接读取数据库文件时,才会出现这个问题。</target>
        </trans-unit>
        <trans-unit id="af76f7d3a1b3eb149d8a26a0e9299bf38c7c0401" translate="yes" xml:space="preserve">
          <source>Note that it is very important that the database filename have some kind of extension. If there is no extension, then SQLite creates auxiliary filenames by appending to the base name of the file. Thus, a database named &quot;&lt;code&gt;db01&lt;/code&gt;&quot; would have a &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; file named &quot;&lt;code&gt;db01-journal&lt;/code&gt;&quot;. And as this filename has no extension to shorten to 3 characters, it will be used as-is, and will violate 8+3 naming rules.</source>
          <target state="translated">请注意，数据库文件名具有某种扩展名非常重要。如果没有扩展名，则SQLite会通过附加到文件的基本名称来创建辅助文件名。因此，一个名为&amp;ldquo; &lt;code&gt;db01&lt;/code&gt; &amp;rdquo; 的数据库将具有一个名为&amp;ldquo; &lt;code&gt;db01-journal&lt;/code&gt; &amp;rdquo; 的&lt;a href=&quot;lockingv3#rollback&quot;&gt;回滚日志&lt;/a&gt;文件。并且由于该文件名没有扩展名，不能缩短到3个字符，因此将按原样使用，并且会违反8 + 3命名规则。</target>
        </trans-unit>
        <trans-unit id="19eeeefb37e5b82a70fbf6a86a847157f005c210" translate="yes" xml:space="preserve">
          <source>Note that prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), SQLite did not check the xCreate method for NULL before invoking it. So if an eponymous-only virtual table is registered with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_11_1.html&quot;&gt;version 3.8.11.1&lt;/a&gt; (2015-07-29) or earlier and a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; command is attempted against that virtual table module, a jump to a NULL pointer will occur, resulting in a crash.</source>
          <target state="translated">请注意，在&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;版本3.9.0&lt;/a&gt;（2015-10-14）之前，SQLite在调用xCreate方法之前未检查其是否为NULL。因此，如果在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_11_1.html&quot;&gt;版本3.8.11.1&lt;/a&gt;（2015-07-29）或更早版本中注册了仅具名的虚拟表，并且对该虚拟表模块尝试了&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;命令，则会发生跳转到NULL指针的情况，从而导致崩溃</target>
        </trans-unit>
        <trans-unit id="7cb63274cd75ba4167c68c8885d57c07e7241aab" translate="yes" xml:space="preserve">
          <source>Note that running SQLite with gcov is not a test of SQLite &amp;mdash; it is a test of the test suite. The gcov run does not test SQLite because the -fprofile-args and -ftest-coverage options cause the compiler to generate different code. The gcov run merely verifies that the test suite provides 100% branch test coverage. The gcov run is a test of the test - a meta-test.</source>
          <target state="translated">请注意，使用gcov运行SQLite并不是对SQLite的测试，而是对测试套件的测试。gcov运行不会测试SQLite，因为-fprofile-args和-ftest-coverage选项使编译器生成不同的代码。gcov运行仅验证测试套件是否提供100％的分支测试覆盖率。gcov运行是测试的测试-元测试。</target>
        </trans-unit>
        <trans-unit id="5a5f0aee350ad05534eee4c24d91d936725afa91" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; constant is also used as a potential return value from the &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; callback and that &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt; is also a &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt;.</source>
          <target state="translated">请注意，&lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;常量也用作&lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;回调的潜在返回值，并且&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;也是&lt;a href=&quot;rescode&quot;&gt;结果代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4daa0a4c8ffbaa8c905b7b2b472738ae1e277cf" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces do not count INSTEAD OF trigger firings, but the &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; does count INSTEAD OF trigger firing.</source>
          <target state="translated">请注意，&lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes（）&lt;/a&gt;和&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;接口不计算INSTEAD OF触发器触发，但是&lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes编译指示&lt;/a&gt;确实计算INSTEAD OF触发器触发。</target>
        </trans-unit>
        <trans-unit id="f4f048e66a09e44bfda0411919740620eea7756a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; constant is also used as a potential return value from the &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; callback and that &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; is also a &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt;.</source>
          <target state="translated">请注意，&lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;常量也用作&lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;回调的潜在返回值，并且&lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;也是&lt;a href=&quot;../rescode&quot;&gt;结果代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="732e678676cbad83be2195f0c9cbdf90bfcdfbeb" translate="yes" xml:space="preserve">
          <source>Note that the DO UPDATE clause acts only on the single row that experienced the constraint error during INSERT. It is not necessary to include a WHERE clause that restrictions the action to that one row. The only use for the WHERE clause at the end of the DO UPDATE is to optionally change the DO UPDATE into a no-op depending on the original and/or new values. For example:</source>
          <target state="translated">请注意,DO UPDATE子句只作用于在INSERT过程中发生约束错误的那一条记录。没有必要包含一个WHERE子句,将操作限制在这一条记录上。在DO UPDATE结尾的WHERE子句的唯一用途是根据原始值和/或新的值,选择性地将DO UPDATE改为no-op。例如</target>
        </trans-unit>
        <trans-unit id="9e431af898d8e365308f86b50efb344365dfb157" translate="yes" xml:space="preserve">
          <source>Note that the SQLITE_TEXT constant was also used in SQLite version 2 for a completely different meaning. Software that links against both SQLite version 2 and SQLite version 3 should use SQLITE3_TEXT, not SQLITE_TEXT.</source>
          <target state="translated">请注意,SQLITE_TEXT常量在SQLite版本2中也使用过,意义完全不同。同时针对SQLite版本2和SQLite版本3进行链接的软件应该使用SQLITE3_TEXT,而不是SQLITE_TEXT。</target>
        </trans-unit>
        <trans-unit id="db7397560741b34c84d7c7b13b86a2bbf792ba5b" translate="yes" xml:space="preserve">
          <source>Note that the SQLite parser will not always generate code to use an index, even if it is possible to do so. The following queries will not currently use the index:</source>
          <target state="translated">请注意,SQLite解析器不会总是生成使用索引的代码,即使可以这样做。以下查询目前不会使用索引。</target>
        </trans-unit>
        <trans-unit id="021cca6e0a1bc313b828c0c99864715910f5cf3d" translate="yes" xml:space="preserve">
          <source>Note that the UNION ALL operator for compound queries does not use transient indices by itself (though of course the right and left subqueries of the UNION ALL might use transient indices depending on how they are composed.)</source>
          <target state="translated">请注意,复合查询的UNION ALL操作符本身并不使用瞬时索引(当然,UNION ALL的左右子查询可能会使用瞬时索引,这取决于它们是如何组成的)。</target>
        </trans-unit>
        <trans-unit id="0676f5b60fd19b027ecab9b9999e5b7f746d671c" translate="yes" xml:space="preserve">
          <source>Note that the authorizer callback is invoked only during &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants. Authorization is not performed during statement evaluation in &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;, unless as stated in the previous paragraph, sqlite3_step() invokes sqlite3_prepare_v2() to reprepare a statement after a schema change.</source>
          <target state="translated">请注意，仅在&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;或其变体期间调用授权者回调。在&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;中的语句评估期间不会执行授权，除非如前一段所述，否则sqlite3_step（）会在架构更改后调用sqlite3_prepare_v2（）来重新声明语句。</target>
        </trans-unit>
        <trans-unit id="f1e28776761e0bfe4431c21ae77ea6373668b8fc" translate="yes" xml:space="preserve">
          <source>Note that the authorizer callback is invoked only during &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants. Authorization is not performed during statement evaluation in &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;, unless as stated in the previous paragraph, sqlite3_step() invokes sqlite3_prepare_v2() to reprepare a statement after a schema change.</source>
          <target state="translated">请注意，仅在&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;或其变体期间调用授权者回调。在&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;中的语句评估期间不会执行授权，除非如前一段所述，否则sqlite3_step（）会在架构更改后调用sqlite3_prepare_v2（）来重新声明语句。</target>
        </trans-unit>
        <trans-unit id="ac6d36a8492877c1ea3743d0c173020c27937cf2" translate="yes" xml:space="preserve">
          <source>Note that the character encoding mechanism used by SQLite cannot be changed at run-time. This is a compile-time option only. The &lt;b&gt;sqlite_encoding&lt;/b&gt; character string just tells you how the library was compiled.</source>
          <target state="translated">请注意，SQLite使用的字符编码机制无法在运行时更改。这仅是编译时选项。该&lt;b&gt;sqlite_encoding&lt;/b&gt;字符串只是告诉你该库是如何被编译。</target>
        </trans-unit>
        <trans-unit id="7febee2154ade1b2d3219ad0df6d8ce2b6d91690" translate="yes" xml:space="preserve">
          <source>Note that the checksums in the rollback journal are not necessary if the synchronous setting is FULL. We only depend on the checksums when synchronous is lowered to NORMAL. Nevertheless, the checksums never hurt and so they are included in the rollback journal regardless of the synchronous setting.</source>
          <target state="translated">请注意,如果同步设置为FULL,则不需要回滚日志中的校验和。只有当同步设置为NORMAL时,我们才需要用到校验和。尽管如此,校验和值不会有任何影响,因此无论同步设置如何,校验和值都会被包含在回滚日志中。</target>
        </trans-unit>
        <trans-unit id="808239b91162b2ff74019b785a2c4443032a884a" translate="yes" xml:space="preserve">
          <source>Note that the command-line shell program has already enabled extension loading for you (by calling the &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface as part of its setup) so the command above works without any special switches, setup, or other complications.</source>
          <target state="translated">请注意，命令行Shell程序已经为您启用了扩展加载（通过在安装过程中调用&lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）&lt;/a&gt;接口作为其安装的一部分），因此上述命令可以正常运行，而无需任何特殊的开关，安装或其他复杂操作。</target>
        </trans-unit>
        <trans-unit id="6e9cc72c28987333ade7d6e3571128f51c3b46dd" translate="yes" xml:space="preserve">
          <source>Note that the destructor function D is for the pointer value P, not for the type string T. The type string T should be a static string with an infinite lifetime.</source>
          <target state="translated">需要注意的是,析产函数D是针对指针值P的,而不是针对类型字符串T的,类型字符串T应该是一个寿命无限的静态字符串。</target>
        </trans-unit>
        <trans-unit id="4cfa4e46e35f2a19630aea45991cffe3dd621ecd" translate="yes" xml:space="preserve">
          <source>Note that the integer key is one greater than the largest key that was in the table just prior to the insert. The new key will be unique over all keys currently in the table, but it might overlap with keys that have been previously deleted from the table. To create keys that are unique over the lifetime of the table, add the &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; keyword to the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; declaration. Then the key chosen will be one more than the largest key that has ever existed in that table. If the largest possible key has previously existed in that table, then the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error code.</source>
          <target state="translated">请注意，整数键比插入之前表中的最大键大一。新键在表中当前的所有键上都是唯一的，但是它可能与以前从表中删除的键重叠。要创建在表的生命周期内唯一的键，请将&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;关键字添加到&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;声明中。这样，所选密钥将比该表中曾经存在的最大密钥多一。如果该表中先前已存在最大的可能密钥，则&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;将失败，并显示&lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;错误代码。</target>
        </trans-unit>
        <trans-unit id="228b63ead1b7d1b62a8c83539d4e8ab64da2dc4c" translate="yes" xml:space="preserve">
          <source>Note that the journal_mode for an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; is either MEMORY or OFF and can not be changed to a different value. An attempt to change the journal_mode of an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; to any setting other than MEMORY or OFF is ignored. Note also that the journal_mode cannot be changed while a transaction is active.</source>
          <target state="translated">请注意，&lt;a href=&quot;inmemorydb&quot;&gt;内存数据库&lt;/a&gt;的journal_mode为MEMORY或OFF，并且不能更改为其他值。将&lt;a href=&quot;inmemorydb&quot;&gt;内存数据库&lt;/a&gt;的journal_mode更改为除MEMORY或OFF以外的任何设置的尝试都将被忽略。还请注意，事务处于活动状态时，不能更改journal_mode。</target>
        </trans-unit>
        <trans-unit id="1150442b82dfad6909e59c690e94911009ab738b" translate="yes" xml:space="preserve">
          <source>Note that the list of routines above is conceptual rather than actual. Many of these routines come in multiple versions. For example, the list above shows a single routine named &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; when in fact there are three separate routines that accomplish the same thing in slightly different ways: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The list mentions &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; when in fact no such routine exists. The &quot;sqlite3_column()&quot; shown in the list is a placeholder for an entire family of routines that extra column data in various datatypes.</source>
          <target state="translated">请注意，上面的例程列表是概念性的，而不是实际的。其中许多例程有多个版本。例如，上面的列表显示了一个名为&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）的&lt;/a&gt;例程，而实际上有三个单独的例程以略有不同的方式完成同一件事：&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;和&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;。该列表提到了&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column（）&lt;/a&gt;，而实际上不存在这样的例程。列表中显示的&amp;ldquo; sqlite3_column（）&amp;rdquo;是整个例程系列的占位符，这些例程会在各种数据类型中额外增加列数据。</target>
        </trans-unit>
        <trans-unit id="4fdc00a153b8f8752a20bfd3564af15ee4f88900" translate="yes" xml:space="preserve">
          <source>Note that the memory leak detection logic continues to work even when the OOM overlay is being used. This verifies that SQLite does not leak memory even when it encounters memory allocation errors. Note also that the OOM overlay can work with any underlying memory allocator, including the instrumented memory allocator that checks for memory allocation misuse. In this way it is verified that OOM errors do not induce other kinds of memory usage errors.</source>
          <target state="translated">请注意,即使在使用OOM覆盖时,内存泄漏检测逻辑也会继续工作。这就验证了SQLite即使在遇到内存分配错误时也不会泄漏内存。还请注意,OOM覆盖可以与任何底层内存分配器一起工作,包括检查内存分配错误的工具化内存分配器。通过这种方式可以验证OOM错误不会诱发其他类型的内存使用错误。</target>
        </trans-unit>
        <trans-unit id="a2673a9d4ca364b864416763c5f28c9b8fac9ff0" translate="yes" xml:space="preserve">
          <source>Note that the number of keywords understood by SQLite can depend on compile-time options. For example, &quot;VACUUM&quot; is not a keyword if SQLite is compiled with the &lt;a href=&quot;../compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; option. Also, new keywords may be added to future releases of SQLite.</source>
          <target state="translated">请注意，SQLite可以理解的关键字数量可能取决于编译时选项。例如，如果使用&lt;a href=&quot;../compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt;选项编译SQLite，则&amp;ldquo; VACUUM&amp;rdquo;不是关键字。此外，新的关键字可能会添加到SQLite的未来版本中。</target>
        </trans-unit>
        <trans-unit id="2d91b980ac2f1529b090c5eabcb20ce64f838c85" translate="yes" xml:space="preserve">
          <source>Note that the number of keywords understood by SQLite can depend on compile-time options. For example, &quot;VACUUM&quot; is not a keyword if SQLite is compiled with the &lt;a href=&quot;compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; option. Also, new keywords may be added to future releases of SQLite.</source>
          <target state="translated">请注意，SQLite可以理解的关键字数量可能取决于编译时选项。例如，如果使用&lt;a href=&quot;compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt;选项编译SQLite，则&amp;ldquo; VACUUM&amp;rdquo;不是关键字。此外，新的关键字可能会添加到SQLite的未来版本中。</target>
        </trans-unit>
        <trans-unit id="4aca65a78510b061ab1efe777d7b5b2943653a08" translate="yes" xml:space="preserve">
          <source>Note that the order of the rules for determining column affinity is important. A column whose declared type is &quot;CHARINT&quot; will match both rules 1 and 2 but the first rule takes precedence and so the column affinity will be INTEGER.</source>
          <target state="translated">请注意,确定列亲和力的规则顺序很重要。一个声明类型为 &quot;CHARINT &quot;的列将同时符合规则1和规则2,但第一条规则优先,因此列的亲和性将是INTEGER。</target>
        </trans-unit>
        <trans-unit id="1d73e69c69eafce89c99fd09f5dcbc2e6299190a" translate="yes" xml:space="preserve">
          <source>Note that the primary result code is always a part of the extended result code. Given a full 32-bit extended result code, the application can always find the corresponding primary result code merely by extracting the least significant 8 bits of the extended result code.</source>
          <target state="translated">请注意,主结果代码总是扩展结果代码的一部分。给定一个完整的32位扩展结果代码,应用程序总是可以通过提取扩展结果代码中最不重要的8位来找到相应的主要结果代码。</target>
        </trans-unit>
        <trans-unit id="299082c757bfbc2b1a98c9af13620cc48c49d3d4" translate="yes" xml:space="preserve">
          <source>Note that the program for this SELECT query didn't contain the Transaction and Commit instructions used in the INSERT example. Because the SELECT is a read operation that doesn't alter the database, it doesn't require a transaction.</source>
          <target state="translated">请注意,这个SELECT查询的程序没有包含INSERT例子中使用的Transaction和Commit指令。因为SELECT是一个不改变数据库的读操作,所以它不需要事务。</target>
        </trans-unit>
        <trans-unit id="f586476195ef53b793699f052ad1af05d3a6c8e4" translate="yes" xml:space="preserve">
          <source>Note that the readfile(X) and writefile(X,Y) functions are extension functions and are not built into the core SQLite library. These routines are available as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; in the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext/misc/fileio.c&lt;/a&gt; source file in the &lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;SQLite source code repositories&lt;/a&gt;.</source>
          <target state="translated">请注意，readfile（X）和writefile（X，Y）函数是扩展函数，并且未内置在核心SQLite库中。这些例程在&lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;SQLite源代码存储库&lt;/a&gt;中的&lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext / misc / fileio.c&lt;/a&gt;源文件中可用作&lt;a href=&quot;loadext&quot;&gt;可加载扩展&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="672e23ac6cc2cc98d9511ab1e12385a015260590" translate="yes" xml:space="preserve">
          <source>Note that the readfile(X) and writefile(X,Y) functions are extension functions and are not built into the core SQLite library. These routines are available as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; in the &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext/misc/fileio.c&lt;/a&gt; source file in the &lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;SQLite source code repositories&lt;/a&gt;.</source>
          <target state="translated">请注意，readfile（X）和writefile（X，Y）函数是扩展函数，并且未内置在核心SQLite库中。这些例程可作为&lt;a href=&quot;loadext&quot;&gt;可加载扩展名&lt;/a&gt;在&lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;SQLite源代码存储库&lt;/a&gt;中的&lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext / misc / fileio.c&lt;/a&gt;源文件中使用。</target>
        </trans-unit>
        <trans-unit id="64553501493418021ca0b221dddc1b5aa622fbc2" translate="yes" xml:space="preserve">
          <source>Note that the result from casting any non-BLOB value into a BLOB and the result from casting any BLOB value into a non-BLOB value may be different depending on whether the database &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;encoding&lt;/a&gt; is UTF-8, UTF-16be, or UTF-16le.</source>
          <target state="translated">请注意，根据数据库&lt;a href=&quot;pragma#pragma_encoding&quot;&gt;编码&lt;/a&gt;是UTF-8，UTF-16be还是UTF-16le ，将任何非BLOB值转换为BLOB的结果以及将任何BLOB值转换为非BLOB的结果可能会有所不同。。</target>
        </trans-unit>
        <trans-unit id="e984670ffac060fe0c3430de1a1c23ffe29028d1" translate="yes" xml:space="preserve">
          <source>Note that the sqlite3changeset_apply_v2() API is still &lt;b&gt;experimental&lt;/b&gt; and therefore subject to change.</source>
          <target state="translated">请注意，sqlite3changeset_apply_v2（）API仍处于&lt;b&gt;试验阶段&lt;/b&gt;，因此可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="a04165c5ad09a6b0ad2414206038c2e65d87aa51" translate="yes" xml:space="preserve">
          <source>Note that the sqlite3changeset_start_v2() API is still &lt;b&gt;experimental&lt;/b&gt; and therefore subject to change.</source>
          <target state="translated">请注意，sqlite3changeset_start_v2（）API仍处于&lt;b&gt;试验阶段&lt;/b&gt;，因此可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="6c55c88c2dea7079ec802efa3e99479f764ecf7e" translate="yes" xml:space="preserve">
          <source>Note that the unary *+* operator also removes &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; from an expression, and in some cases this can cause subtle changes in the meaning of an expression. In the example above, if column *x* has &lt;a href=&quot;datatype3#affinity&quot;&gt;TEXT affinity&lt;/a&gt; then the comparison &quot;x=5&quot; will be done as text. But the *+* operator removes the affinity. So the comparison &quot;+x=5&quot; will compare the text in column *x* with the numeric value 5 and will always be false.</source>
          <target state="translated">请注意，一元* + *运算符还会从表达式中删除&lt;a href=&quot;datatype3#affinity&quot;&gt;类型相似性&lt;/a&gt;，在某些情况下，这可能导致表达式含义发生细微变化。在上面的示例中，如果列* x *具有&lt;a href=&quot;datatype3#affinity&quot;&gt;TEXT关联性，&lt;/a&gt;则比较&amp;ldquo; x = 5&amp;rdquo;将作为文本完成。但是* + *运算符会删除相似性。因此，比较&amp;ldquo; + x = 5&amp;rdquo;会将* x *列中的文本与数值5进行比较，并且始终为false。</target>
        </trans-unit>
        <trans-unit id="d81068a6cb6b3b6084654f5758e6e2d51e7af994" translate="yes" xml:space="preserve">
          <source>Note that the unary &lt;b&gt;+&lt;/b&gt; operator also removes &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; from an expression, and in some cases this can cause subtle changes in the meaning of an expression. In the example above, if column &lt;b&gt;x&lt;/b&gt; has &lt;a href=&quot;datatype3#affinity&quot;&gt;TEXT affinity&lt;/a&gt; then the comparison &quot;x=5&quot; will be done as text. The &lt;b&gt;+&lt;/b&gt; operator removes the affinity. So the comparison &quot;&lt;b&gt;+x=5&lt;/b&gt;&quot; will compare the text in column &lt;b&gt;x&lt;/b&gt; with the numeric value 5 and will always be false.</source>
          <target state="translated">请注意，一元&lt;b&gt;+&lt;/b&gt;运算符还会从表达式中删除&lt;a href=&quot;datatype3#affinity&quot;&gt;类型相似性&lt;/a&gt;，在某些情况下，这可能导致表达式含义的细微变化。在上面的示例中，如果列&lt;b&gt;x&lt;/b&gt;具有&lt;a href=&quot;datatype3#affinity&quot;&gt;TEXT关联，&lt;/a&gt;则比较&amp;ldquo; x = 5&amp;rdquo;将作为文本完成。的&lt;b&gt;+&lt;/b&gt;操作者除去亲和性。因此，比较&amp;ldquo; &lt;b&gt;+ x = 5&lt;/b&gt; &amp;rdquo;会将&lt;b&gt;x&lt;/b&gt;列中的文本与数值5进行比较，并且始终为false。</target>
        </trans-unit>
        <trans-unit id="c990d58c5d0bc49b39ec476dafbb19955404bbcd" translate="yes" xml:space="preserve">
          <source>Note that there are paths through the syntax diagrams that are not allowed in practice. Some examples:</source>
          <target state="translated">请注意,在语法图中,有些路径在实践中是不允许的。以下是一些例子:</target>
        </trans-unit>
        <trans-unit id="96acc3ff45ab0c01a0b94c0892486dbb72afce32" translate="yes" xml:space="preserve">
          <source>Note that there are two variations of the equals and not equals operators. Equals can be either</source>
          <target state="translated">注意,等号和不等号运算符有两种变化。等号可以是</target>
        </trans-unit>
        <trans-unit id="a67d64fb18ca2294fb42994c6d74eeb61ff03be8" translate="yes" xml:space="preserve">
          <source>Note that this is only a thought experiment. We are not suggesting that OpenDocument be changed. Nor is this article a criticism of the current OpenDocument design. The point of this essay is to suggest ways to improve future file format designs.</source>
          <target state="translated">请注意,这只是一个思想实验。我们并不是建议改变OpenDocument。本文也不是对当前OpenDocument设计的批评。本文的目的是提出改进未来文件格式设计的方法。</target>
        </trans-unit>
        <trans-unit id="99c1505807d577ab62bcd4edbb24d5f3cd06e9f6" translate="yes" xml:space="preserve">
          <source>Note that this problem only occurs if the attempt to acquire the lock resulted in an I/O error. If the lock is simply not granted (because some other thread or process is already holding a conflicting lock) then no corruption will ever occur. We are not aware of any operating systems that will fail with an I/O error while attempting to get a file lock on shared memory. So this is a theoretical problem rather than a real problem. Needless to say, this problem has never been observed in the wild. The problem was discovered while doing stress testing of SQLite in a test harness that simulates I/O errors.</source>
          <target state="translated">请注意,只有在试图获取锁的过程中导致I/O错误时才会出现这个问题。如果锁只是没有被授予(因为其他线程或进程已经持有一个冲突的锁),那么永远不会发生损坏。我们不知道有任何操作系统会在尝试获取共享内存上的文件锁时出现I/O错误而失败。因此,这是一个理论问题,而不是一个真正的问题。不用说,这个问题从未在野外观察到过。这个问题是在模拟I/O错误的测试线束中对SQLite进行压力测试时发现的。</target>
        </trans-unit>
        <trans-unit id="ebff595e74a177f5fa63d87902cc62cb3ce02f96" translate="yes" xml:space="preserve">
          <source>Note that this routine returns zero on a match and non-zero if the strings do not match, the same as &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">请注意，此例程在匹配时返回零，在字符串不匹配时返回非零，与&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp（）相同&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d629b76283bd20b6edf31050b7b9b764c009820" translate="yes" xml:space="preserve">
          <source>Note that this routine returns zero on a match and non-zero if the strings do not match, the same as &lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">请注意，此例程在匹配时返回零，在字符串不匹配时返回非零，与&lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp（）&lt;/a&gt;和&lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp（）相同&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c810fa4c8943f66ac3d34092b7e767d31528340e" translate="yes" xml:space="preserve">
          <source>Note that triggers are automatically dropped when the associated table is dropped.</source>
          <target state="translated">请注意,当关联的表被删除时,触发器会自动被删除。</target>
        </trans-unit>
        <trans-unit id="d606f23ac3535efbf11c3a7516392c25071ecf15" translate="yes" xml:space="preserve">
          <source>Note that when SQLite is compiled with SQLITE_THREADSAFE=0, the code to make SQLite threadsafe is omitted from the build. When this occurs, it is impossible to change the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; at start-time or run-time.</source>
          <target state="translated">请注意，当使用SQLITE_THREADSAFE = 0编译SQLite时，构建过程中将省略使SQLite线程安全的代码。发生这种情况时，不可能在启动时或运行时更改&lt;a href=&quot;threadsafe&quot;&gt;线程模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="32708b7e6e76296f6dad18be6a6d369658183e8b" translate="yes" xml:space="preserve">
          <source>Note that when the SQLITE_DBCONFIG_LEGACY_FILE_FORMAT setting is on, the &lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will fail with an obscure error when attempting to process a table with generated columns and a descending index. This is not considered a bug since SQLite versions 3.3.0 and earlier do not support either generated columns or decending indexes.</source>
          <target state="translated">请注意，当启用SQLITE_DBCONFIG_LEGACY_FILE_FORMAT设置时，&lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令将在尝试处理具有生成的列和降序索引的表时失败，并显示模糊错误。由于SQLite 3.3.0和更早版本不支持生成的列或降序的索引，因此不将其视为错误。</target>
        </trans-unit>
        <trans-unit id="3822538f7b251248e21c02ba82556fd2e3a92957" translate="yes" xml:space="preserve">
          <source>Note that when the SQLITE_DBCONFIG_LEGACY_FILE_FORMAT setting is on, the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will fail with an obscure error when attempting to process a table with generated columns and a descending index. This is not considered a bug since SQLite versions 3.3.0 and earlier do not support either generated columns or decending indexes.</source>
          <target state="translated">请注意，当启用SQLITE_DBCONFIG_LEGACY_FILE_FORMAT设置时，&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令将在尝试处理具有生成的列和降序索引的表时失败，并显示模糊错误。由于SQLite 3.3.0和更早版本不支持生成的列或降序的索引，因此不将其视为错误。</target>
        </trans-unit>
        <trans-unit id="789391b5c680547fd2d7df978b13d5bea4b6c611" translate="yes" xml:space="preserve">
          <source>Note that when the right-hand side of a LIKE or GLOB operator is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and the statement is prepared using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; then the statement is automatically reparsed and recompiled on the first &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call of each run if the binding to the right-hand side parameter has changed since the previous run. This reparse and recompile is essentially the same action that occurs following a schema change. The recompile is necessary so that the query planner can examine the new value bound to the right-hand side of the LIKE or GLOB operator and determine whether or not to employ the optimization described above.</source>
          <target state="translated">请注意，如果LIKE或GLOB运算符的右侧是&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数，&lt;/a&gt;并且使用&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;准备了该语句，则在每次运行的第一个&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;调用中，该语句将自动重新分析和重新编译。自上次运行以来，与右侧参数的绑定已更改。这种重新解析和重新编译本质上是与架构更改后发生的相同操作。重新编译是必需的，以便查询计划者可以检查绑定到LIKE或GLOB运算符右侧的新值，并确定是否采用上述优化方法。</target>
        </trans-unit>
        <trans-unit id="7aca89c620a18b6fdc63e568bea908a626dcadff" translate="yes" xml:space="preserve">
          <source>Note that when type conversions occur, pointers returned by prior calls to sqlite3_column_blob(), sqlite3_column_text(), and/or sqlite3_column_text16() may be invalidated. Type conversions and pointer invalidations might occur in the following cases:</source>
          <target state="translated">请注意,当类型转换发生时,之前调用sqlite3_column_blob()、sqlite3_column_text()和/或sqlite3_column_text16()返回的指针可能会失效。在以下情况下,可能会发生类型转换和指针无效的情况。</target>
        </trans-unit>
        <trans-unit id="1368e4859dec1f8b656ae1f17b0c284cfecc238a" translate="yes" xml:space="preserve">
          <source>Note that with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to NORMAL, the checkpoint is the only operation to issue an I/O barrier or sync operation (fsync() on unix or FlushFileBuffers() on windows). If an application therefore runs checkpoint in a separate thread or process, the main thread or process that is doing database queries and updates will never block on a sync operation. This helps to prevent &quot;latch-up&quot; in applications running on a busy disk drive. The downside to this configuration is that transactions are no longer durable and might rollback following a power failure or hard reset.</source>
          <target state="translated">请注意，在&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt;设置为NORMAL的情况下，检查点是唯一发出I / O屏障或同步操作的操作（unix上的fsync（）或Windows上的FlushFileBuffers（））。因此，如果应用程序在单独的线程或进程中运行检查点，则执行数据库查询和更新的主线程或进程将永远不会阻塞同步操作。这有助于防止在繁忙的磁盘驱动器上运行的应用程序中出现&amp;ldquo;闩锁&amp;rdquo;。此配置的缺点是事务不再持久，并且可能在电源故障或硬重置后回滚。</target>
        </trans-unit>
        <trans-unit id="8da0c032621fbb18df4dc03aaa124440bc316a57" translate="yes" xml:space="preserve">
          <source>Note that with ANALYZE the cost estimates are better aligned with reality and algorithm-1 is selected by both NN and N3.</source>
          <target state="translated">需要注意的是,使用analyze时,成本估算与实际情况比较吻合,NN和N3都选择了算法-1。</target>
        </trans-unit>
        <trans-unit id="695e607ef01e6db075031ffa227e23ca60904541" translate="yes" xml:space="preserve">
          <source>Note that xBestIndex will always be called before &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;, since the idxNum and idxStr outputs from xBestIndex are required inputs to xFilter. However, there is no guarantee that xFilter will be called following a successful xBestIndex.</source>
          <target state="translated">请注意，xBestIndex将始终在&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;之前调用，因为xBestIndex的idxNum和idxStr输出是xFilter的必需输入。但是，不能保证成功执行xBestIndex之后将调用xFilter。</target>
        </trans-unit>
        <trans-unit id="d227a38478007bafe1c5681fa0c0259f1628a846" translate="yes" xml:space="preserve">
          <source>Note the &quot;temp.&quot; qualifier before the virtual table name (&quot;stat&quot;). This qualifier causes the virtual table to be temporary - to only exist for the duration of the current database connection. This is the recommended approach.</source>
          <target state="translated">请注意虚拟表名称(&quot;stat&quot;)前的 &quot;temp.&quot;限定词。这个限定词会导致虚拟表是临时的--只在当前数据库连接期间存在。这是推荐的方法。</target>
        </trans-unit>
        <trans-unit id="984a9d35869a9cec59e40e09a2d60d76afb99304" translate="yes" xml:space="preserve">
          <source>Note the last bullet in particular. The destructor X in sqlite3_set_auxdata(C,N,P,X) might be called immediately, before the sqlite3_set_auxdata() interface even returns. Hence sqlite3_set_auxdata() should be called near the end of the function implementation and the function implementation should not make any use of P after sqlite3_set_auxdata() has been called.</source>
          <target state="translated">请特别注意最后一项。sqlite3_set_auxdata(C,N,P,X)中的析构器X可能会在 sqlite3_set_auxdata()接口返回之前立即被调用。因此,sqlite3_set_auxdata()应该在函数实现接近尾声的时候调用,并且在调用了sqlite3_set_auxdata()之后,函数实现不应该对P进行任何使用。</target>
        </trans-unit>
        <trans-unit id="be13ad345e0dba5ca596ce6f7266fdf09fc32236" translate="yes" xml:space="preserve">
          <source>Note the use of the &lt;a href=&quot;lang_corefunc#quote&quot;&gt;quote() SQL function&lt;/a&gt; in these triggers. The quote() function converts its argument into a form that is appropriate for inclusion in an SQL statement. Numeric values come through unchanged. Single quotes are added before and after strings and any internal single quotes are escaped. BLOB values are rendered using SQL-standard hexadecimal BLOB notation. The use of the quote() function ensures that the SQL statements used to undo and redo are always safe from SQL injection.</source>
          <target state="translated">注意在这些触发器中使用&lt;a href=&quot;lang_corefunc#quote&quot;&gt;quote（）SQL函数&lt;/a&gt;。quote（）函数将其参数转换为适合包含在SQL语句中的形式。数值不变。在字符串前后添加单引号，并且转义任何内部单引号。BLOB值使用SQL标准十六进制BLOB表示法呈现。使用quote（）函数可确保用于撤消和重做的SQL语句始终对SQL注入安全。</target>
        </trans-unit>
        <trans-unit id="044b3a09040052b2232feb80c6848441318257d4" translate="yes" xml:space="preserve">
          <source>Note the warnings on the &quot;estimatedRows&quot;, &quot;idxFlags&quot;, and colUsed fields. These fields were added with SQLite versions 3.8.2, 3.9.0, and 3.10.0, respectively. Any extension that reads or writes these fields must first check that the version of the SQLite library in use is greater than or equal to appropriate version - perhaps comparing the value returned from &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; against constants 3008002, 3009000, and/or 3010000. The result of attempting to access these fields in an sqlite3_index_info structure created by an older version of SQLite are undefined.</source>
          <target state="translated">请注意&amp;ldquo; estimatedRows&amp;rdquo;，&amp;ldquo; idxFlags&amp;rdquo;和colUsed字段上的警告。这些字段分别与SQLite版本3.8.2、3.9.0和3.10.0一起添加。读取或写入这些字段的任何扩展都必须首先检查所使用的SQLite库的版本是否大于或等于适当的版本-也许将&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number（）&lt;/a&gt;返回的值与常量3008002、3009000和/或3010000进行比较。尝试访问由较旧版本的SQLite创建的sqlite3_index_info结构中的这些字段的结果未定义。</target>
        </trans-unit>
        <trans-unit id="49bc1f28a1c9c886ae8bd63cbcbb27c797246229" translate="yes" xml:space="preserve">
          <source>Note: Functions marked with &quot;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;&quot; are &lt;a href=&quot;capi3ref&quot;&gt;experimental&lt;/a&gt; and functions whose names are &lt;s&gt;struck through&lt;/s&gt; are &lt;a href=&quot;capi3ref&quot;&gt;deprecated&lt;/a&gt;.</source>
          <target state="translated">注意：标有&amp;ldquo;功能&lt;small&gt;&lt;i&gt;（EXP）&lt;/i&gt;&lt;/small&gt; &amp;rdquo;的&lt;a href=&quot;capi3ref&quot;&gt;实验性&lt;/a&gt;和功能，其名称是&lt;s&gt;通过撞击&lt;/s&gt;被&lt;a href=&quot;capi3ref&quot;&gt;弃用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="66ee76f5066068620f09c7e62f4bb8c158c87cf7" translate="yes" xml:space="preserve">
          <source>Note: Functions marked with &quot;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;&quot; are &lt;a href=&quot;experimental&quot;&gt;experimental&lt;/a&gt; and functions whose names are &lt;s&gt;struck through&lt;/s&gt; are &lt;a href=&quot;experimental&quot;&gt;deprecated&lt;/a&gt;.</source>
          <target state="translated">注意：标有&amp;ldquo;功能&lt;small&gt;&lt;i&gt;（EXP）&lt;/i&gt;&lt;/small&gt; &amp;rdquo;的&lt;a href=&quot;experimental&quot;&gt;实验性&lt;/a&gt;和功能，其名称是&lt;s&gt;通过撞击&lt;/s&gt;被&lt;a href=&quot;experimental&quot;&gt;弃用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03b148e28fde4df0887542e9d88b598d5e8f42db" translate="yes" xml:space="preserve">
          <source>Note: Sections 2.0 and 3.0 of this article were added in response to comments on &lt;a href=&quot;https://news.ycombinator.com/item?id=16585120&quot;&gt;Hacker News&lt;/a&gt; and &lt;a href=&quot;https://www.reddit.com/r/programming/comments/84fzoc/why_is_sqlite_coded_in_c/&quot;&gt;Reddit&lt;/a&gt;.</source>
          <target state="translated">注意：添加了本文的第2.0节和第3.0节，以响应对&lt;a href=&quot;https://news.ycombinator.com/item?id=16585120&quot;&gt;Hacker News&lt;/a&gt;和&lt;a href=&quot;https://www.reddit.com/r/programming/comments/84fzoc/why_is_sqlite_coded_in_c/&quot;&gt;Reddit的&lt;/a&gt;评论。</target>
        </trans-unit>
        <trans-unit id="85e051b1f236f895d99d48916ab5fd667388aec3" translate="yes" xml:space="preserve">
          <source>Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; with &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;.</source>
          <target state="translated">注意：此方法在MacOS X 10.7和iOS版本5.0上被禁用，并且将始终返回SQLITE_MISUSE。在这些系统上，应通过&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;和&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;通过数据库的每个连接启用共享缓存模式。</target>
        </trans-unit>
        <trans-unit id="ddf57deb38e4651cb3981116d2b9ec03a6feb885" translate="yes" xml:space="preserve">
          <source>Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; with &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;.</source>
          <target state="translated">注意：此方法在MacOS X 10.7和iOS版本5.0上被禁用，并且将始终返回SQLITE_MISUSE。在这些系统上，应通过&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;和&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;通过数据库的每个连接启用共享缓存模式。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="b7c62ae6be1885d1c5a81f6a7886c67b36419ed4" translate="yes" xml:space="preserve">
          <source>Notes on the &lt;a href=&quot;optoverview&quot;&gt;query optimizer&lt;/a&gt;.</source>
          <target state="translated">有关&lt;a href=&quot;optoverview&quot;&gt;查询优化器的说明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="bb5c89c5cb4409cab6ee44d716c6d95feaaddc62" translate="yes" xml:space="preserve">
          <source>Notice how the LIKE operator is implemented. It is a user-defined function in SQLite, so the address of its function definition is specified in P3. The operand P1 is the number of function arguments for it to take from the stack. In this case the LIKE() function takes 2 arguments. The arguments are taken off the stack in reverse order (right-to-left), so the pattern to match is the top stack element, and the next element is the data to compare. The return value is pushed onto the stack.</source>
          <target state="translated">注意LIKE操作符是如何实现的。在SQLite中,它是一个用户定义的函数,所以在P3中指定了它的函数定义地址。操作数P1是它要从堆栈中获取的函数参数数。在本例中,LIKE()函数需要2个参数。参数从堆栈中以相反的顺序(从右到左)取下,所以要匹配的模式是堆栈最上面的元素,下一个元素是要比较的数据。返回值被推到堆栈上。</target>
        </trans-unit>
        <trans-unit id="5255c6a9b36d606aac6af8d3dbbceadb0d1f9b02" translate="yes" xml:space="preserve">
          <source>Notice how the query above works: The R*Tree index runs in the outer loop to find entries that are contained within the bounding box of longitude -81..-79.6 and latitude 35.0..36.2. For each object identifier found, SQLite looks up the corresponding entry in the demo_data table. It then uses the boundary field from the demo_data table as a parameter to the contained_in() function and if that function returns true, the objname field from the demo_data table is returned as the next row of query result.</source>
          <target state="translated">注意上面的查询是如何工作的。R*Tree索引在外循环中运行,以查找包含在经度-81...-79.6和纬度35.0...36.2的边界框内的条目。对于找到的每个对象标识符,SQLite都会在demo_data表中查找相应的条目。然后,它将demo_data表中的边界字段作为con contained_in()函数的参数,如果该函数返回true,则将demo_data表中的objname字段作为下一行查询结果返回。</target>
        </trans-unit>
        <trans-unit id="3b7384e004cca4a56bb485375c44be1a10c5774f" translate="yes" xml:space="preserve">
          <source>Notice that all other date and time functions can be expressed in terms of strftime():</source>
          <target state="translated">注意,所有其他的日期和时间函数都可以用strftime()来表示。</target>
        </trans-unit>
        <trans-unit id="a0897fe8cedb04900939c7986a4c19ddb9b29972" translate="yes" xml:space="preserve">
          <source>Notice that dividing up the content into smaller pieces using an SQLite table gives flexibility to the implementation. The application can choose to read all content into memory at startup. Or it can read just a few pages into memory and keep the rest on disk. Or it can read just single page into memory at a time. And different versions of the application can make different choices without having to make any changes to the file format. Such options are not available when all content is in a single big XML file in a ZIP archive.</source>
          <target state="translated">请注意,使用SQLite表将内容划分为更小的部分,这为实现提供了灵活性。应用程序可以选择在启动时将所有内容读入内存。或者它可以只将几个页面读取到内存中,并将其余的内容保存在磁盘上。或者它可以每次只将单页内容读入内存。而且不同版本的应用程序可以做出不同的选择,而不需要对文件格式进行任何修改。当所有的内容都在ZIP档案中的一个大的XML文件中时,这样的选项是不可用的。</target>
        </trans-unit>
        <trans-unit id="8b6637336242d861c3d1aedafa06202a9a576add" translate="yes" xml:space="preserve">
          <source>Notice that the &quot;host&quot; value for the &quot;dummy&quot; record is NULL so the result[] array contains a NULL pointer at that slot.</source>
          <target state="translated">注意,&quot;dummy &quot;记录的 &quot;host &quot;值是NULL,所以结果[]数组在该槽中包含一个NULL指针。</target>
        </trans-unit>
        <trans-unit id="81da02d10ebbcf526492f91d32dd8afa2884d608" translate="yes" xml:space="preserve">
          <source>Notice that the parameters to functions are now pointers to sqlite3_value structures instead of pointers to strings as in SQLite version 2.X. The following routines are used to extract useful information from these &quot;values&quot;:</source>
          <target state="translated">请注意,现在函数的参数是指向 sqlite3_value 结构的指针,而不是像 SQLite 2.X 版本那样指向字符串的指针,以下例程用于从这些 &quot;值 &quot;中提取有用的信息。</target>
        </trans-unit>
        <trans-unit id="45ef496d245754f1f4daa860e31545d9feaf1aea" translate="yes" xml:space="preserve">
          <source>Notice that the shared lock is on the operating system disk cache, not on the disk itself. File locks really are just flags within the operating system kernel, usually. (The details depend on the specific OS layer interface.) Hence, the lock will instantly vanish if the operating system crashes or if there is a power loss. It is usually also the case that the lock will vanish if the process that created the lock exits.</source>
          <target state="translated">注意,共享锁是在操作系统的磁盘缓存上,而不是在磁盘本身。文件锁其实只是操作系统内核内的标志,通常。(具体细节取决于具体的操作系统层接口。)因此,如果操作系统崩溃或断电,锁会立即消失。通常情况下,如果创建锁的进程退出,锁也会消失。</target>
        </trans-unit>
        <trans-unit id="f8f4b80268c40011630e5371241e6ab982124215" translate="yes" xml:space="preserve">
          <source>Notice that the tokens in the result set from the fts3tokenize virtual table have been transformed according to the rules of the tokenizer. Since this example used the &quot;porter&quot; tokenizer, the &quot;This&quot; token was converted into &quot;thi&quot;. If the original text of the token is desired, it can be retrieved using the &quot;start&quot; and &quot;end&quot; columns with the &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr()&lt;/a&gt; function. For example:</source>
          <target state="translated">请注意，fts3tokenize虚拟表的结果集中的令牌已根据令牌生成器的规则进行了转换。由于此示例使用了&amp;ldquo; porter&amp;rdquo;标记器，因此&amp;ldquo; This&amp;rdquo;标记被转换为&amp;ldquo; thi&amp;rdquo;。如果需要令牌的原始文本，则可以使用&lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr（）&lt;/a&gt;函数的&amp;ldquo; start&amp;rdquo;和&amp;ldquo; end&amp;rdquo;列来检索令牌。例如：</target>
        </trans-unit>
        <trans-unit id="af54971d34d4b499061179fcac4a7f0e1fee4c0f" translate="yes" xml:space="preserve">
          <source>Notice the similarity between the ListRead and Next instructions. Both operations work according to this rule:</source>
          <target state="translated">注意ListRead和Next指令之间的相似性。这两个操作都是按照这个规则工作的。</target>
        </trans-unit>
        <trans-unit id="7cec2e96076ffe89a48a9bb0d641ff84dbe2e0a2" translate="yes" xml:space="preserve">
          <source>Notice too that there is a tradeoff between average read performance and average write performance. To maximize the read performance, one wants to keep the WAL as small as possible and hence run checkpoints frequently, perhaps as often as every COMMIT. To maximize write performance, one wants to amortize the cost of each checkpoint over as many writes as possible, meaning that one wants to run checkpoints infrequently and let the WAL grow as large as possible before each checkpoint. The decision of how often to run checkpoints may therefore vary from one application to another depending on the relative read and write performance requirements of the application. The default strategy is to run a checkpoint once the WAL reaches 1000 pages and this strategy seems to work well in test applications on workstations, but other strategies might work better on different platforms or for different workloads.</source>
          <target state="translated">还要注意的是,在平均读性能和平均写性能之间有一个权衡。为了最大限度地提高读性能,我们希望尽可能地保持WAL小,因此要频繁地运行检查点,可能和每次COMMIT一样频繁。为了最大限度地提高写性能,我们希望将每个检查点的成本摊到尽可能多的写中,这意味着我们希望不频繁地运行检查点,并在每个检查点之前让WAL尽可能地增长。因此,根据应用程序的相对读写性能要求,决定运行检查点的频率可能因应用程序而异。默认的策略是一旦WAL达到1000页就运行一个检查点,这个策略在工作站上的测试应用中似乎很好,但其他策略在不同的平台上或对于不同的工作负载可能会更好。</target>
        </trans-unit>
        <trans-unit id="d969bb722b85b5d0915700d40ff32bef3f77944d" translate="yes" xml:space="preserve">
          <source>Now compiles on MSVC++6 again</source>
          <target state="translated">现在又可以在MSVC++6上编译了</target>
        </trans-unit>
        <trans-unit id="6c31ef81ebda278449acfecbdc59bc58b62b9f81" translate="yes" xml:space="preserve">
          <source>Now compiles on Solaris and OpenBSD and other Unix variants that lack the fdatasync() function</source>
          <target state="translated">现在可以在Solaris和OpenBSD以及其他缺乏fdatasync()函数的Unix变体上编译。</target>
        </trans-unit>
        <trans-unit id="d8eeae1a57da5c7c1fc46f998bfb914d868defe3" translate="yes" xml:space="preserve">
          <source>Now consider a query to find the names of everyone in the organization that is 180cm tall or taller:</source>
          <target state="translated">现在考虑一个查询,以找到组织中身高180cm以上的每个人的名字。</target>
        </trans-unit>
        <trans-unit id="cace99b617f1285adb8e73b73b38a21bf398149e" translate="yes" xml:space="preserve">
          <source>Now consider the case where M and N are both 3500. Alice nodes are abundant. But suppose each of these nodes is connected by only one or two edges. In this case, option 2 is preferred. With option 2, the outer loop still has to run 3500 times, but the middle loop only runs once or twice for each outer loop and the inner loop will only run once for each middle loop, if at all. So the total number of iterations of the inner loop is around 7000. Option 1, on the other hand, has to run both its outer loop and its middle loop 3500 times each, resulting in 12 million iterations of the middle loop. Thus in the second scenario, option 2 is nearly 2000 times faster than option 1.</source>
          <target state="translated">现在考虑M和N都是3500的情况。爱丽丝节点很多。但假设这些节点中的每一个节点都只由一条或两条边连接。在这种情况下,方案2是首选。如果采用方案2,外循环仍然要运行3500次,但是中循环每一次外循环只运行一到两次,而内循环每一次中循环只运行一次,如果有的话。所以内循环的总迭代次数在7000次左右。而方案一,它的外循环和中循环各要运行3500次,因此中循环的迭代次数为1200万次。因此在第二种情况下,方案2比方案1快了近2000倍。</target>
        </trans-unit>
        <trans-unit id="51646e1329ed662a99db388949416fd2e9a42dfe" translate="yes" xml:space="preserve">
          <source>Now consider the case where M and N are both 3500. Alice nodes are abundant. This time suppose each of these nodes is connected by only one or two edges. Now option 2 is preferred. With option 2, the outer loop still has to run 3500 times, but the middle loop only runs once or twice for each outer loop and the inner loop will only run once for each middle loop, if at all. So the total number of iterations of the inner loop is around 7000. Option 1, on the other hand, has to run both its outer loop and its middle loop 3500 times each, resulting in 12 million iterations of the middle loop. Thus in the second scenario, option 2 is nearly 2000 times faster than option 1.</source>
          <target state="translated">现在考虑M和N都是3500的情况。爱丽丝节点很多。这次假设这些节点中的每一个节点都只由一条或两条边连接。现在首选方案2。在方案2下,外循环仍然要运行3500次,但中循环每一次外循环只运行一两次,而内循环每一次中循环只运行一次,如果有的话。所以内循环的总迭代次数在7000次左右。而方案一,它的外循环和中循环各要运行3500次,因此中循环的迭代次数为1200万次。因此在第二种情况下,方案2比方案1快了近2000倍。</target>
        </trans-unit>
        <trans-unit id="ddfe6464a41b67622d5429681d09c2e30ec73502" translate="yes" xml:space="preserve">
          <source>Now it is time to make the private, custom modifications to SQLite which are the whole point of this exercise. Switch to the private branch (if you are not already there) using the &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot; command, then bring up the source files in your text editor and make whatever changes you want to make. Once you have finished making changes, commit those changes using this command:</source>
          <target state="translated">现在是时候对SQLite进行私有的，自定义的修改了，这是本练习的重点。使用&amp;ldquo; &lt;code&gt;fossil update private&lt;/code&gt; &amp;rdquo;命令切换到私有分支（如果您还没有的话），然后在文本编辑器中调出源文件并进行任何您想进行的更改。完成更改后，请使用以下命令提交这些更改：</target>
        </trans-unit>
        <trans-unit id="421feb72f2bd97fb759d08871988b6f039784dca" translate="yes" xml:space="preserve">
          <source>Now let's look at how this index will be used. Consider the following query:</source>
          <target state="translated">现在我们来看看如何使用这个索引。考虑下面的查询。</target>
        </trans-unit>
        <trans-unit id="470c0db4772f894a123be1434e95e5d5a6304ade" translate="yes" xml:space="preserve">
          <source>Now suppose the user.phone field contains plain text if the user has only a single phone number and a JSON array if the user has multiple phone numbers. The same question is posed: &quot;Which users have a phone number in the 704 area code?&quot; But now the json_each() function can only be called for those users that have two or more phone numbers since json_each() requires well-formed JSON as its first argument:</source>
          <target state="translated">现在假设如果用户只有一个电话号码,则user.phone字段包含纯文本,如果用户有多个电话号码,则包含一个JSON数组。提出同样的问题。&quot;哪些用户有704区号的电话号码?&quot; 但现在json_each()函数只能调用那些有两个或多个电话号码的用户,因为json_each()需要格式良好的JSON作为第一个参数。</target>
        </trans-unit>
        <trans-unit id="f22ea5fd82bf1b044f7951c4c771bd645f73f8d1" translate="yes" xml:space="preserve">
          <source>Now that the public and private branches are different, you can run the &quot;&lt;code&gt;fossil update trunk&lt;/code&gt;&quot; and &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot; commands and see that fossil really does change the files in the checkout as you switch back and forth between branches.</source>
          <target state="translated">现在，公共分支机构和私有分支机构不同，您可以运行&amp;ldquo; &lt;code&gt;fossil update trunk&lt;/code&gt; &amp;rdquo;和&amp;ldquo; &lt;code&gt;fossil update private&lt;/code&gt; &amp;rdquo;命令，并看到在分支之间来回切换时，化石确实确实改变了结帐中的文件。</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="5b7d454836a77f93829b713b5a5d0e3045934959" translate="yes" xml:space="preserve">
          <source>Null-indicator is an optional string that indicates a column value is null. The default is an empty string. Note that column-separator and null-indicator are optional positional arguments; if null-indicator is specified, a column-separator argument must be specified and precede the null-indicator argument.</source>
          <target state="translated">Null-indicator是一个可选的字符串,表示列值为空。默认值是一个空字符串。请注意,列分隔符和null-indicator是可选的位置参数;如果指定了null-indicator,则必须指定列分隔符参数,并在null-indicator参数之前使用。</target>
        </trans-unit>
        <trans-unit id="a37aacd80c708abde1a03c3d5afe5b13fd00cfc3" translate="yes" xml:space="preserve">
          <source>NullRow</source>
          <target state="translated">NullRow</target>
        </trans-unit>
        <trans-unit id="eb0f5a21c19313cdefd12cf556538964ec1b60c1" translate="yes" xml:space="preserve">
          <source>Number Of Columns In A Result Set</source>
          <target state="translated">结果集中的列数</target>
        </trans-unit>
        <trans-unit id="29a85c89c3b665d61a62026778cb1a84d89e00ac" translate="yes" xml:space="preserve">
          <source>Number Of SQL Parameters</source>
          <target state="translated">SQL参数数量</target>
        </trans-unit>
        <trans-unit id="a780fc260fcaca2d5e967db2577edefc7720d5d2" translate="yes" xml:space="preserve">
          <source>Number of WAL frames that have already been backfilled into the database by prior checkpoints</source>
          <target state="translated">已被以前的检查站回填到数据库中的WAL帧的数量。</target>
        </trans-unit>
        <trans-unit id="2a37475de2d92c9f14f2ea5c38819cea5766eaa7" translate="yes" xml:space="preserve">
          <source>Number of WAL frames that have attempted to be backfilled but which might not have been backfilled successfully.</source>
          <target state="translated">试图回填但可能没有成功回填的WAL框架的数量。</target>
        </trans-unit>
        <trans-unit id="3b125f191573ae8fecea26a8fd5c1f85866a1737" translate="yes" xml:space="preserve">
          <source>Number of bytes of payload</source>
          <target state="translated">有效载荷的字节数</target>
        </trans-unit>
        <trans-unit id="3bacc7e3374d56ead644519a8de907aa11ddb984" translate="yes" xml:space="preserve">
          <source>Number of cells on the current page or btree</source>
          <target state="translated">当前页面或btree中的单元格数量。</target>
        </trans-unit>
        <trans-unit id="93e4ee2802912bc9542ff03c865140e0975aff48" translate="yes" xml:space="preserve">
          <source>Number of columns in a result set</source>
          <target state="translated">结果集中的列数</target>
        </trans-unit>
        <trans-unit id="2b00ff36e6009d3918fa275ec909bb841ed966c0" translate="yes" xml:space="preserve">
          <source>Number of valid and committed frames in the WAL file.</source>
          <target state="translated">WAL文件中的有效和已提交的帧数。</target>
        </trans-unit>
        <trans-unit id="ff84d5af979f34eb1211b7993c06c6a08d3a99e3" translate="yes" xml:space="preserve">
          <source>Number-of-pages</source>
          <target state="translated">Number-of-pages</target>
        </trans-unit>
        <trans-unit id="2f32b7f17e88cd173c751d8cdc7e8c19cbcaed9f" translate="yes" xml:space="preserve">
          <source>Numeric and text types make a difference for the DISTINCT keyword too:</source>
          <target state="translated">数字和文本类型对DISTINCT关键字也有影响。</target>
        </trans-unit>
        <trans-unit id="c37c2e33a0fa0b90c0fc1ac3254fa39cce3fa242" translate="yes" xml:space="preserve">
          <source>Numeric values (serial types 1 through 9) sort after NULLs and in numeric order.</source>
          <target state="translated">数字值(序列类型1至9)在NULLs之后按数字顺序排序。</target>
        </trans-unit>
        <trans-unit id="16bebfa71033ff1ade58c6f0e6b14f281dfaba25" translate="yes" xml:space="preserve">
          <source>Numeric values sort next in numerical order</source>
          <target state="translated">数字值按数字顺序排序。</target>
        </trans-unit>
        <trans-unit id="0f5fd79254e55ff1fbee2cde5598536b3ec7dea6" translate="yes" xml:space="preserve">
          <source>Numerous bug fixes and documentation updates.</source>
          <target state="translated">大量的错误修复和文档更新。</target>
        </trans-unit>
        <trans-unit id="dc11c061204c46d3ddd7e450955d3893423efff5" translate="yes" xml:space="preserve">
          <source>Numerous code optimizations, specially optimizations designed to make the code footprint smaller.</source>
          <target state="translated">大量的代码优化,特别是为了使代码占用更小而设计的优化。</target>
        </trans-unit>
        <trans-unit id="1608a6f49ab43b4c01022e79721183478aa81607" translate="yes" xml:space="preserve">
          <source>Numerous minor bug fixes</source>
          <target state="translated">大量的小错误修复</target>
        </trans-unit>
        <trans-unit id="59f5ab25bf1e5a211679172dc18a637343443a9e" translate="yes" xml:space="preserve">
          <source>Numerous other performance enhancements</source>
          <target state="translated">众多其他性能的提升</target>
        </trans-unit>
        <trans-unit id="957b6bbcded8f49f8684b4d5e7a64d7f3a67b7a1" translate="yes" xml:space="preserve">
          <source>OCELOT</source>
          <target state="translated">OCELOT</target>
        </trans-unit>
        <trans-unit id="7481b4b2758d96d6c2ef2af6709c88460dc01560" translate="yes" xml:space="preserve">
          <source>ODP - The Open Document presentation format used by OpenOffice and others</source>
          <target state="translated">ODP-OpenOffice和其他机构使用的开放文档演示格式。</target>
        </trans-unit>
        <trans-unit id="2a2888f26efa625ef4871988ca874037d8ea156c" translate="yes" xml:space="preserve">
          <source>ODT - The Open Document format used by OpenOffice and others</source>
          <target state="translated">ODT-OpenOffice和其他机构使用的开放文档格式。</target>
        </trans-unit>
        <trans-unit id="0cf81c47abad8b8dc52569f7edcc1b5b2d3511f9" translate="yes" xml:space="preserve">
          <source>OF</source>
          <target state="translated">OF</target>
        </trans-unit>
        <trans-unit id="acd2081fe0965992b6934d49ae30eed38ac749e0" translate="yes" xml:space="preserve">
          <source>OFFSET</source>
          <target state="translated">OFFSET</target>
        </trans-unit>
        <trans-unit id="4f963961751f0891a23f93bba4882f74f0ade805" translate="yes" xml:space="preserve">
          <source>OFFSET clause ignored on queries without a FROM clause. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</source>
          <target state="translated">对于没有FROM子句的查询，将忽略OFFSET子句。门票&lt;a href=&quot;http://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da4ccf2c7bbe14dbe10f95677bd45e189a9ba8cb" translate="yes" xml:space="preserve">
          <source>OFFSET clause ignored on queries without a FROM clause. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</source>
          <target state="translated">没有FROM子句的查询将忽略OFFSET子句。门票&lt;a href=&quot;https://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80f83fb7443c61c317b946841f59c0be3182f095" translate="yes" xml:space="preserve">
          <source>OFFSET gives the correct answer. However, OFFSET requires time proportional to the offset value. What really happens with &quot;LIMIT x OFFSET y&quot; is that SQLite computes the query as &quot;LIMIT x+y&quot; and discards the first y values without returning them to the application. So as the window scrolls down toward the bottom of a long list, and the y value becomes larger and larger, successive offset computations take more and more time.</source>
          <target state="translated">OFFSET给出了正确答案。但是,OFFSET需要的时间与偏移值成正比。&quot;LIMIT x OFFSET y &quot;真正发生的情况是,SQLite将查询计算为 &quot;LIMIT x+y&quot;,并丢弃第一个y值,而不将其返回给应用程序。所以随着窗口向长列表的底部滚动,y值越来越大,连续的偏移计算需要的时间越来越多。</target>
        </trans-unit>
        <trans-unit id="9c108e42d4ae43fd2c4c857619aacef018184aee" translate="yes" xml:space="preserve">
          <source>OLD references are valid</source>
          <target state="translated">旧的参考资料有效</target>
        </trans-unit>
        <trans-unit id="387d7a59dbaaef002e0f9ac69ecd4443b9c5cef2" translate="yes" xml:space="preserve">
          <source>ON</source>
          <target state="translated">ON</target>
        </trans-unit>
        <trans-unit id="32bb503cc80e713ad933b48ce9053610aae7664e" translate="yes" xml:space="preserve">
          <source>ON CONFLICT clause</source>
          <target state="translated">关于冲突条款</target>
        </trans-unit>
        <trans-unit id="c13d037157d8eb7ac7ee7af0a3380941dabf2fa2" translate="yes" xml:space="preserve">
          <source>OOM testing is accomplished by simulating OOM errors. SQLite allows an application to substitute an alternative malloc() implementation using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;,...) interface. The TCL and TH3 test harnesses are both capable of inserting a modified version of malloc() that can be rigged to fail after a certain number of allocations. These instrumented mallocs can be set to fail only once and then start working again, or to continue failing after the first failure. OOM tests are done in a loop. On the first iteration of the loop, the instrumented malloc is rigged to fail on the first allocation. Then some SQLite operation is carried out and checks are done to make sure SQLite handled the OOM error correctly. Then the time-to-failure counter on the instrumented malloc is increased by one and the test is repeated. The loop continues until the entire operation runs to completion without ever encountering a simulated OOM failure. Tests like this are run twice, once with the instrumented malloc set to fail only once, and again with the instrumented malloc set to fail continuously after the first failure.</source>
          <target state="translated">OOM测试是通过模拟OOM错误来完成的。 SQLite允许应用程序使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;替代替代的malloc（）实现，...）界面。 TCL和TH3测试工具都能够插入修改后的malloc（）版本，该版本可以操纵一定数量的分配后失败。可以将这些检测到的malloc设置为仅失败一次，然后再次开始工作，或者在第一次失败后继续失败。 OOM测试是循环完成的。在循环的第一次迭代中，检测到的malloc被装配为在第一次分配时失败。然后执行一些SQLite操作并进行检查以确保SQLite正确处理了OOM错误。然后，已检测的malloc上的故障时间计数器增加一，并重复测试。循环一直进行到整个操作完成为止，而不会遇到模拟的OOM故障。这样的测试运行两次，一次将设置的malloc设置为仅失败一次，而再次将设置的malloc设置为在首次失败后连续失败。</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="683e61c81d390d130002106c2c28e827414b7056" translate="yes" xml:space="preserve">
          <source>ORDER</source>
          <target state="translated">ORDER</target>
        </trans-unit>
        <trans-unit id="2164bde64d5e67a9aad0e7c0543250365dc40e72" translate="yes" xml:space="preserve">
          <source>ORDER BY</source>
          <target state="translated">排序方式</target>
        </trans-unit>
        <trans-unit id="e4ec6dd8b3c32fb2c490ae23010139de3ea19166" translate="yes" xml:space="preserve">
          <source>ORDER BY and GROUP BY now use bounded memory</source>
          <target state="translated">ORDER BY和GROUP BY现在使用有界内存。</target>
        </trans-unit>
        <trans-unit id="f9252c387c5a364e0aa75e161fd6ca4b31550d60" translate="yes" xml:space="preserve">
          <source>ORDER BY ignored if the query has an identical GROUP BY. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;b75a9ca6b0&lt;/a&gt;</source>
          <target state="translated">如果查询具有相同的GROUP BY，则忽略ORDER BY。门票&lt;a href=&quot;http://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;b75a9ca6b0&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4c80a022ba8a937ff7b06aa241ba59238ca58957" translate="yes" xml:space="preserve">
          <source>ORDER BY ignored if the query has an identical GROUP BY. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;b75a9ca6b0&lt;/a&gt;</source>
          <target state="translated">如果查询具有相同的GROUP BY，则忽略ORDER BY。门票&lt;a href=&quot;https://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;b75a9ca6b0&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d00407a3fb0d8ad7b8bcf4535e5d986d53520d0" translate="yes" xml:space="preserve">
          <source>ORDER BY works on subselects</source>
          <target state="translated">ORDER BY适用于子选择</target>
        </trans-unit>
        <trans-unit id="fb1eb08d2d3f0a79b8449be8ce9ee77050e088a5" translate="yes" xml:space="preserve">
          <source>OS Interface</source>
          <target state="translated">操作系统接口</target>
        </trans-unit>
        <trans-unit id="7ea1a5ba1dffba576fe0a188bb466f1a65ef5c2d" translate="yes" xml:space="preserve">
          <source>OS Interface File Virtual Methods Object</source>
          <target state="translated">操作系统接口文件虚拟方法对象</target>
        </trans-unit>
        <trans-unit id="2fdd9f0dd04e20b2da0185c9864ac62e0fd49b33" translate="yes" xml:space="preserve">
          <source>OS Interface Object</source>
          <target state="translated">操作系统接口对象</target>
        </trans-unit>
        <trans-unit id="e502b880ac4721322e02bb29b5215f15ab6c97e9" translate="yes" xml:space="preserve">
          <source>OS Interface Open File Handle</source>
          <target state="translated">操作系统界面打开文件手柄</target>
        </trans-unit>
        <trans-unit id="1bea0dbc1c9e6f1262f42405074e1a4e5f89e1c4" translate="yes" xml:space="preserve">
          <source>OSS Fuzz no longer finds historical bugs in SQLite. But it is still running and does occasionally find issues in new development check-ins. Examples: &lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=c422afb507dc8757&quot;&gt;[1]&lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=0a2eb949f8a759e5&quot;&gt;[2]&lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=62f2235adf796c72&quot;&gt;[3]&lt;/a&gt;.</source>
          <target state="translated">OSS Fuzz不再在SQLite中发现历史错误。但是它仍在运行，偶尔会在新开发签入中发现问题。示例：&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=c422afb507dc8757&quot;&gt;[1] &lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=0a2eb949f8a759e5&quot;&gt;[2] &lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=62f2235adf796c72&quot;&gt;[3]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dee9889ad644e6e58468f0ff85f3a57aa76cfbd9" translate="yes" xml:space="preserve">
          <source>OTHERS</source>
          <target state="translated">OTHERS</target>
        </trans-unit>
        <trans-unit id="a032f6607e24aa99492871d19a553d714048e163" translate="yes" xml:space="preserve">
          <source>OUTER</source>
          <target state="translated">OUTER</target>
        </trans-unit>
        <trans-unit id="cc11826689203b888f22525a7551a5472c324526" translate="yes" xml:space="preserve">
          <source>OVER</source>
          <target state="translated">OVER</target>
        </trans-unit>
        <trans-unit id="829a2c0005fc7d37eb660c0d5cde206b5192f790" translate="yes" xml:space="preserve">
          <source>Obey in all things the commands of those whom God has placed in authority over you even though they (which God forbid) should act otherwise, mindful of the Lord's precept, &quot;Do what they say, but not what they do.&quot;</source>
          <target state="translated">凡事都要听从上帝派给你们的掌权者的命令,即使他们(上帝所不允许的)有别的行为,也要注意主的戒律:&quot;照他们所说的去做,而不是照他们所做的去做&quot;。</target>
        </trans-unit>
        <trans-unit id="a21a5206c75e38db5a2f38df79e6283758ee658a" translate="yes" xml:space="preserve">
          <source>Object-Oriented Design</source>
          <target state="translated">面向对象的设计</target>
        </trans-unit>
        <trans-unit id="898a9f4f224c827df0fb00ecec65822c23a3936e" translate="yes" xml:space="preserve">
          <source>Object-Oriented is a design pattern, not a programming language. You can do object-oriented programming in any language you want, including assembly language. Some languages (ex: C++ or Java) make object-oriented easier. But you can still do object-oriented programming in languages like C.</source>
          <target state="translated">面向对象是一种设计模式,而不是一种编程语言。你可以用任何你想要的语言进行面向对象编程,包括汇编语言。有些语言(如:C++或Java)让面向对象变得更容易。但你仍然可以用C语言等语言来做面向对象的编程。</target>
        </trans-unit>
        <trans-unit id="1e6159d8c90870c6430155592639731dac8033a3" translate="yes" xml:space="preserve">
          <source>Object-oriented is not the only valid design pattern. Many programmers have been taught to think purely in terms of objects. And, to be fair, objects are often a good way to decompose a problem. But objects are not the only way, and are not always the best way to decompose a problem. Sometimes good old procedural code is easier to write, easier to maintain and understand, and faster than object-oriented code.</source>
          <target state="translated">面向对象不是唯一有效的设计模式。许多程序员被教导要纯粹从对象的角度来思考问题。而且,公平地说,对象通常是分解问题的好方法。但对象并不是唯一的方式,也不总是分解问题的最佳方式。有时候,老式的程序化代码比面向对象的代码更容易写,更容易维护和理解,而且速度更快。</target>
        </trans-unit>
        <trans-unit id="ea838bb1557d80ce2bdbf51816fc7a1525503976" translate="yes" xml:space="preserve">
          <source>Objects:</source>
          <target state="translated">Objects:</target>
        </trans-unit>
        <trans-unit id="3a36347e6c9b66b32ae45cd886e8708db38d062b" translate="yes" xml:space="preserve">
          <source>Obscure bug fix on triggers (&lt;a href=&quot;http://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt;).</source>
          <target state="translated">触发器的模糊错误修复（&lt;a href=&quot;http://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d0994929eda2b0503d9117c72035600d8833ef50" translate="yes" xml:space="preserve">
          <source>Obscure bug fix on triggers (&lt;a href=&quot;https://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt;).</source>
          <target state="translated">对触发器的模糊错误修复（&lt;a href=&quot;https://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="06705e47733fa2d26527ca5b13fe92c1b7ca1944" translate="yes" xml:space="preserve">
          <source>Obsolete Documents</source>
          <target state="translated">过时文件</target>
        </trans-unit>
        <trans-unit id="adcd55329b6153adb94eaf8a12d01ba2bc7cea95" translate="yes" xml:space="preserve">
          <source>Obtain A Composite Changeset From A Changegroup</source>
          <target state="translated">从变更组中获取复合变更组</target>
        </trans-unit>
        <trans-unit id="f036e380a093cadb7b7384e4b591b8c75c1ba145" translate="yes" xml:space="preserve">
          <source>Obtain Aggregate Function Context</source>
          <target state="translated">获取聚合函数上下文</target>
        </trans-unit>
        <trans-unit id="e79fb280b93973e6bfe3f8e79ba72b5b038ba1fa" translate="yes" xml:space="preserve">
          <source>Obtain Conflicting Row Values From A Changeset Iterator</source>
          <target state="translated">从Changeset迭代器中获取冲突的行值。</target>
        </trans-unit>
        <trans-unit id="d4c8c29e25fb3ccc649578fec3be2c67a658b123" translate="yes" xml:space="preserve">
          <source>Obtain The Current Operation From A Changeset Iterator</source>
          <target state="translated">从变化集迭代器中获取当前操作。</target>
        </trans-unit>
        <trans-unit id="7ada95f817f8fc624dbadc0c0f495b244a8d38b3" translate="yes" xml:space="preserve">
          <source>Obtain The Primary Key Definition Of A Table</source>
          <target state="translated">获取表的主键定义</target>
        </trans-unit>
        <trans-unit id="2f0f8596ef7c82c2d68f88fe0c2c42b22b20b24e" translate="yes" xml:space="preserve">
          <source>Obtain Values For URI Parameters</source>
          <target state="translated">获取URI参数的值</target>
        </trans-unit>
        <trans-unit id="e719cf57b48331ec73c3d09816f240ac71d990d4" translate="yes" xml:space="preserve">
          <source>Obtain a PENDING lock and then an EXCLUSIVE lock on the database file. If other processes still have SHARED locks, the writer might have to wait until those SHARED locks clear before it is able to obtain an EXCLUSIVE lock.</source>
          <target state="translated">在数据库文件上获得一个PENDING锁,然后再获得一个EXCLUSIVE锁。如果其他进程仍有共享锁,写作者可能要等到这些共享锁清除后才能获得EXCLUSIVE锁。</target>
        </trans-unit>
        <trans-unit id="c4c184719398e2fd529d288f83e902aa72fdd7b4" translate="yes" xml:space="preserve">
          <source>Obtain a buffer containing a changeset (or patchset) representing the current contents of the changegroup. If the inputs to the changegroup were themselves changesets, the output is a changeset. Or, if the inputs were patchsets, the output is also a patchset.</source>
          <target state="translated">获得一个缓冲区,其中包含一个代表变化组当前内容的变化集(或补丁集)。如果输入到changegroup的内容本身就是变化集,那么输出就是一个变化集。或者,如果输入是补丁集,输出也是一个补丁集。</target>
        </trans-unit>
        <trans-unit id="0ad736b5bee2570f5cbf619854f8b97d9b6134d1" translate="yes" xml:space="preserve">
          <source>Obtain a changeset containing changes to the tables attached to the session object passed as the first argument. If successful, set *ppChangeset to point to a buffer containing the changeset and *pnChangeset to the size of the changeset in bytes before returning SQLITE_OK. If an error occurs, set both *ppChangeset and *pnChangeset to zero and return an SQLite error code.</source>
          <target state="translated">获取一个包含对作为第一个参数传递的会话对象所附表的更改的更改集。如果成功,在返回SQLITE_OK之前,将*ppChangeset设置为指向一个包含变化集的缓冲区,将*pnChangeset设置为变化集的字节数。如果发生错误,将*ppChangeset和*pnChangeset都设置为0,并返回一个SQLite错误代码。</target>
        </trans-unit>
        <trans-unit id="4304c4d08f4f900e2ab1ec29540131e8bf87ae39" translate="yes" xml:space="preserve">
          <source>Obtain a lock on a particular table. This instruction is only used when the shared-cache feature is enabled.</source>
          <target state="translated">获得特定表的锁。该指令仅在启用共享缓存功能时使用。</target>
        </trans-unit>
        <trans-unit id="35cc8c81bb0ab78babd3f65cb1b473a29bd69034" translate="yes" xml:space="preserve">
          <source>Obtain an EXCLUSIVE lock on the database file and make sure all memory changes have been written to the database file using the algorithm of steps 1-3 above.</source>
          <target state="translated">获得数据库文件上的EXCLUSIVE锁,并确保所有的内存变化都被写入数据库文件,使用上述步骤1-3的算法。</target>
        </trans-unit>
        <trans-unit id="edc981514ab58076de28ce864d46ccc2641ec1d0" translate="yes" xml:space="preserve">
          <source>Obtain new.* Values From A Changeset Iterator</source>
          <target state="translated">从变化集迭代器中获取new.*值。</target>
        </trans-unit>
        <trans-unit id="c31b9f4e355939157fe39f17fcb0e54282736c63" translate="yes" xml:space="preserve">
          <source>Obtain old.* Values From A Changeset Iterator</source>
          <target state="translated">从Changeset迭代器中获取old.*值。</target>
        </trans-unit>
        <trans-unit id="d399842fa2ae120f608cae0543637da5b44e2b8c" translate="yes" xml:space="preserve">
          <source>Obtain the latest SQLite code from fossil.</source>
          <target state="translated">从fossil中获取最新的SQLite代码。</target>
        </trans-unit>
        <trans-unit id="9ed23644c9e9a46df1cd037be0519be726230e11" translate="yes" xml:space="preserve">
          <source>Obtaining SQL Values</source>
          <target state="translated">获取SQL值</target>
        </trans-unit>
        <trans-unit id="ffe740a4611067b4b4dd0b5b7a28183003203956" translate="yes" xml:space="preserve">
          <source>Obtaining the</source>
          <target state="translated">获取</target>
        </trans-unit>
        <trans-unit id="a8fbf19c89308087d70d289986f946de344868c9" translate="yes" xml:space="preserve">
          <source>Obtains the mutex.</source>
          <target state="translated">获取mutex。</target>
        </trans-unit>
        <trans-unit id="974debb0f023f79fb3eec2db47da68008b639181" translate="yes" xml:space="preserve">
          <source>Occasionally, a serious problem is found and a small &quot;patch&quot; release must be made against a regular maintenance release. Patch are distinct from maintenance releases in that the number of lines of code changed from the previous release is very small. Every effort is made to avoid patch releases by making sure that maintenance releases are bug free.</source>
          <target state="translated">偶尔会发现一个严重的问题,必须针对常规的维护版本发布一个小的 &quot;补丁 &quot;版本。补丁与维护版本的不同之处在于,与上一个版本相比,补丁所修改的代码行数非常少。我们尽一切努力避免发布补丁,确保维护版本没有错误。</target>
        </trans-unit>
        <trans-unit id="10b7fae72f94602297b15a7cf850a8e1ee7b4b31" translate="yes" xml:space="preserve">
          <source>Of course, ANALYZE only works effectively if you have a significant amount of content in your database in the first place. When creating a new database that you expect to accumulate a lot of data, you can run the command &quot;ANALYZE sqlite_master&quot; to create the SQLITE_STAT1 table, then prepopulate the SQLITE_STAT1 table (using ordinary INSERT statements) with content that describes a typical database for your application - perhaps content that you extracted after running ANALYZE on a well-populated template database in the lab.</source>
          <target state="translated">当然,只有当你的数据库中首先有大量的内容时,ANALYZE才会有效地发挥作用。当创建一个新的数据库时,你期望积累大量的数据,你可以运行命令 &quot;ANALYZE sqlite_master &quot;来创建SQLITE_STAT1表,然后在SQLITE_STAT1表中预先填充描述你的应用程序的典型数据库的内容(使用普通的INSERT语句)--也许是你在实验室中在一个填充良好的模板数据库上运行ANALYZE后提取的内容。</target>
        </trans-unit>
        <trans-unit id="3d4796f0a34c568634b9634297a83ac77168e0e1" translate="yes" xml:space="preserve">
          <source>Of course, ANALYZE only works effectively if you have a significant amount of content in your database in the first place. When creating a new database that you expect to accumulate a lot of data, you can run the command &quot;ANALYZE sqlite_schema&quot; to create the SQLITE_STAT1 table, then prepopulate the SQLITE_STAT1 table (using ordinary INSERT statements) with content that describes a typical database for your application - perhaps content that you extracted after running ANALYZE on a well-populated template database in the lab.</source>
          <target state="translated">当然,只有当你的数据库中首先有大量的内容时,ANALYZE才会有效地发挥作用。当创建一个新的数据库时,你期望积累大量的数据,你可以运行命令 &quot;ANALYZE sqlite_schema &quot;来创建SQLITE_STAT1表,然后在SQLITE_STAT1表中预先填充描述你的应用程序的典型数据库的内容(使用普通的INSERT语句)--也许是你在实验室中在一个填充良好的模板数据库上运行ANALYZE后提取的内容。</target>
        </trans-unit>
        <trans-unit id="79c23fc170f4a6f6a03298037f6a0ed97740fe0f" translate="yes" xml:space="preserve">
          <source>Of course, an error may occur while attempting any of the 4 steps enumerated above. If this happens, then the</source>
          <target state="translated">当然,在尝试上述4个步骤中的任何一个步骤时,都可能发生错误。如果发生这种情况,那么</target>
        </trans-unit>
        <trans-unit id="4144a21a0e5e7b5ef89db325c2463b409501b64d" translate="yes" xml:space="preserve">
          <source>Of course, an ordinary SQLite table will also do a query against its integer primary key efficiently, so the previous is no big deal. The real reason for using an R*Tree is so that you can efficiently do inequality queries against the coordinate ranges. To find all elements of the index that are contained within the vicinity of Charlotte, North Carolina, one might do:</source>
          <target state="translated">当然,普通的SQLite表也会针对它的整数主键进行高效的查询,所以前面的内容也没什么大不了的。使用R*Tree的真正原因是为了可以高效地针对坐标范围做不等式查询。如果要找到索引中所有包含在北卡罗来纳州夏洛特市附近的元素,可以这样做。</target>
        </trans-unit>
        <trans-unit id="ad9000f84241cbe168fcf9edea5a309a2f41cf64" translate="yes" xml:space="preserve">
          <source>Of course, it is also possible that it does exist following system recovery.</source>
          <target state="translated">当然,也有可能是系统恢复后确实存在。</target>
        </trans-unit>
        <trans-unit id="7a79fe7e88cf76ed8c1ab2e6617de9596ed474d8" translate="yes" xml:space="preserve">
          <source>Of course, it is usually not possible to atomically apply all the changes required by a</source>
          <target state="translated">当然,通常不可能原子化地应用一个项目所需的所有变化。</target>
        </trans-unit>
        <trans-unit id="03e6ead3b1dad229ee29b568087a8cd4aada1c2d" translate="yes" xml:space="preserve">
          <source>Of course, not every language fits neatly into one of the above catagories. This applies to both SQL database engines and more familiar imperative programming languages. Javascript is famous for using a hybrid execution model, where the code is initially compiled into a tree of objects, but might be further translating (using just-in-time compilation) down into more efficient bytecode or machine code, as a means of boosting performance.</source>
          <target state="translated">当然,并不是每一种语言都能整齐划一地归入上述的某一类别。这既适用于SQL数据库引擎,也适用于更熟悉的命令式编程语言。Javascript以使用混合执行模式而闻名,在这种模式下,代码最初被编译成一棵对象树,但可能会被进一步翻译(使用及时编译)为更高效的字节码或机器代码,作为提升性能的一种手段。</target>
        </trans-unit>
        <trans-unit id="b8a4fe5b2fe5db1f855a348ab89c3de5aa545089" translate="yes" xml:space="preserve">
          <source>Of course, one wants to eventually transfer all the transactions that are appended in the WAL file back into the original database. Moving the WAL file transactions back into the database is called a &quot;</source>
          <target state="translated">当然,人们希望最终能将WAL文件中追加的所有事务转移回原数据库中。将WAL文件中的事务转移回数据库的过程称为&quot;</target>
        </trans-unit>
        <trans-unit id="a8d7cb464eb0b5300b1a2a71635654f684270965" translate="yes" xml:space="preserve">
          <source>Of course, ordering the output of a query by rowid is seldom useful. Usually one wants to order the output by some other column.</source>
          <target state="translated">当然,用rowid来排序查询的输出是很少有用的。通常,我们希望通过其他列来对输出进行排序。</target>
        </trans-unit>
        <trans-unit id="178df5e8851c3ac34f7dcea098e85da7dbfe235b" translate="yes" xml:space="preserve">
          <source>Of course, substitute the desired index and imposter table names in place of the &quot;t1bc&quot; and &quot;t2&quot; shown in the example. The &quot;.imposter&quot; command reads the schema of the &quot;t1bc&quot; index, uses that information to construct a compatible CREATE TABLE statement for the imposter table, then makes all the necessary calls to create the transient imposter table automatically.</source>
          <target state="translated">当然,用所需的索引和冒名表的名字来代替例子中的 &quot;t1bc &quot;和 &quot;t2&quot;。&quot;.imposter &quot;命令读取 &quot;t1bc &quot;索引的模式,使用该信息为冒名表构造一个兼容的CREATE TABLE语句,然后进行所有必要的调用,自动创建瞬时冒名表。</target>
        </trans-unit>
        <trans-unit id="116444cf2f220a0caf732f16ffb5a2f69fd9321c" translate="yes" xml:space="preserve">
          <source>Of course, the two queries above are not entirely equivalent. For example the LIKE query matches rows that contain terms such as &quot;linuxophobe&quot; or &quot;EnterpriseLinux&quot; (as it happens, the Enron E-Mail Dataset does not actually contain any such terms), whereas the MATCH query on the FTS3 table selects only those rows that contain &quot;linux&quot; as a discrete token. Both searches are case-insensitive. The FTS3 table consumes around 2006 MB on disk compared to just 1453 MB for the ordinary table. Using the same hardware configuration used to perform the SELECT queries above, the FTS3 table took just under 31 minutes to populate, versus 25 for the ordinary table.</source>
          <target state="translated">当然,上述两个查询并不完全等同。例如LIKE查询会匹配包含 &quot;linuxophobe &quot;或 &quot;EnterpriseLinux &quot;等术语的行(恰好安然E-Mail数据集实际上并不包含任何此类术语),而FTS3表的MATCH查询则只选择包含 &quot;linux &quot;这一离散标记的行。两种搜索都是不区分大小写的。FTS3表在磁盘上的消耗量约为2006MB,而普通表的消耗量仅为1453MB。使用相同的硬件配置来执行上面的SELECT查询,FTS3表的填充只需要不到31分钟,而普通表则需要25分钟。</target>
        </trans-unit>
        <trans-unit id="68b0ebb94fca52bc2076d132ead5c0f0cef17ce0" translate="yes" xml:space="preserve">
          <source>Of course, users would prefer code that is both robust in normal use and resistant to malicious attack. The SQLite developers are dedicated to providing that. The purpose of this section is merely to point out that doing both at the same time is hard.</source>
          <target state="translated">当然,用户更希望代码既能在正常使用时健壮,又能抵抗恶意攻击。SQLite开发人员致力于提供这种服务。本节的目的只是想指出,同时做到这两点是很难的。</target>
        </trans-unit>
        <trans-unit id="e6778acfecc08483f487870a27c4e0b19bb8701d" translate="yes" xml:space="preserve">
          <source>Of course, your mileage may vary depending on hardware, filesystem, and operating system. Double-check these figures on target hardware before committing to a particular design.</source>
          <target state="translated">当然,根据硬件、文件系统和操作系统的不同,您的里程数可能会有所不同。在进行特定设计之前,请仔细检查目标硬件上的这些数据。</target>
        </trans-unit>
        <trans-unit id="315230e941921effe51cc9ebfa05403b855f0476" translate="yes" xml:space="preserve">
          <source>Of these changes, only 1a and 2a through 2c are incompatibilities in any formal sense. But users who have previously made custom modifications to the SQLite source (for example to add a custom OS layer for embedded hardware) might find that these changes have a larger impact. On the other hand, an important goal of these changes is to make it much easier to customize SQLite for use on different operating systems.</source>
          <target state="translated">在这些改动中,只有1a和2a到2c是任何形式意义上的不兼容。但是,之前对SQLite源码进行过自定义修改(例如为嵌入式硬件添加自定义操作系统层)的用户可能会发现,这些改动的影响较大。另一方面,这些改动的一个重要目标是使定制SQLite在不同操作系统上的使用更加容易。</target>
        </trans-unit>
        <trans-unit id="e3de5ab0ca4c69dbf00e86d2558843e8d806bb49" translate="yes" xml:space="preserve">
          <source>Off</source>
          <target state="translated">Off</target>
        </trans-unit>
        <trans-unit id="ce667716547fa82bc8795ad7ef205e9410193ed0" translate="yes" xml:space="preserve">
          <source>Offset</source>
          <target state="translated">Offset</target>
        </trans-unit>
        <trans-unit id="58190317f4f075103c701ab1719a5146c7d71c8f" translate="yes" xml:space="preserve">
          <source>OffsetLimit</source>
          <target state="translated">OffsetLimit</target>
        </trans-unit>
        <trans-unit id="1ab3ac50fee719ce4797840a2df9f8c5ee707c03" translate="yes" xml:space="preserve">
          <source>Older versions of SQLite could not read a WAL-mode database that was read-only. In other words, write access was required in order to read a WAL-mode database. This constraint was relaxed beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;version 3.22.0&lt;/a&gt; (2018-01-22).</source>
          <target state="translated">较旧版本的SQLite无法读取只读的WAL模式数据库。换句话说，为了读取WAL模式数据库，需要写访问权限。从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;3.22.0&lt;/a&gt;（2018-01-22）开始，此约束已放松。</target>
        </trans-unit>
        <trans-unit id="28b3eeca1402aeadaf4db2bf8f6d2403ee957bf0" translate="yes" xml:space="preserve">
          <source>Older versions of firebird omits all NULLs from SELECT DISTINCT and from UNION.</source>
          <target state="translated">旧版本的firebird在SELECT DISTINCT和UNION中省略了所有的NULLs。</target>
        </trans-unit>
        <trans-unit id="8bfe5e60a5daf11fac21979e5a4fa9643a76bc3b" translate="yes" xml:space="preserve">
          <source>Omit all use of &quot;awk&quot; in the makefiles, to make building easier for MSVC users.</source>
          <target state="translated">在makefile中省略所有的 &quot;awk&quot;,以方便MSVC用户的开发。</target>
        </trans-unit>
        <trans-unit id="bf4d0857bd27f59258be5d9b1e12776a9ff94992" translate="yes" xml:space="preserve">
          <source>Omitted parameters take on default values. STEP defaults to 1. END defaults to 9223372036854775807. START defaults to 0.</source>
          <target state="translated">省略的参数采用默认值。STEP默认为1。END默认为9223372036854775807。START默认为0。</target>
        </trans-unit>
        <trans-unit id="e0049a66519cae71159800bb77a35007bc2d76d3" translate="yes" xml:space="preserve">
          <source>On</source>
          <target state="translated">On</target>
        </trans-unit>
        <trans-unit id="0e46092ad025ac57fb1677f1d311680029cda2c1" translate="yes" xml:space="preserve">
          <source>On Android, we are told, there are many services that will blindly run arbitrary SQL that is passed to them by untrustworthy apps that have been downloaded from dodgy corners of the internet. Android services are suppose to be more guarded about running SQL from unvetted sources. This author does not have any specific examples to the contrary, but he has heard rumors that they exist. Even if all Android services are more careful and properly vet all the SQL they run, it would be difficult to audit them all in order to verify that they are safe. Hence, security-minded people are keen to ensure that no exploits are possible by passing arbitrary SQL text.</source>
          <target state="translated">据悉,在安卓系统上,有很多服务会盲目运行从互联网可疑角落下载的不值得信任的应用程序传递给他们的任意SQL。Android服务对于运行来自未经审核的SQL应该是比较警惕的。笔者没有任何具体的例子可以证明,但也听到过存在这种情况的传言。即使所有的Android服务都比较谨慎,对其运行的所有SQL进行适当的审核,也很难对所有的SQL进行审核,以验证它们是否安全。因此,有安全意识的人非常希望通过传递任意的SQL文本来确保没有漏洞的可能。</target>
        </trans-unit>
        <trans-unit id="26c3af907230190631617dbb8e5acb92e9854301" translate="yes" xml:space="preserve">
          <source>On Linux and other unix systems you will need to enter something like:</source>
          <target state="translated">在Linux和其他unix系统上,你需要输入类似这样的内容。</target>
        </trans-unit>
        <trans-unit id="1273deeaf4de08300113723f337bae0ec716c243" translate="yes" xml:space="preserve">
          <source>On Win32, do not return an error when attempting to delete a file that does not exist.</source>
          <target state="translated">在Win32上,当试图删除一个不存在的文件时,不要返回错误。</target>
        </trans-unit>
        <trans-unit id="b2b2f36a4fafa25d031c2e6870c72d35c487959e" translate="yes" xml:space="preserve">
          <source>On Windows systems, folders are searched in the following order:</source>
          <target state="translated">在Windows系统中,文件夹的搜索顺序如下。</target>
        </trans-unit>
        <trans-unit id="9d83a99bbbc3869a446954149b390c5195af03a3" translate="yes" xml:space="preserve">
          <source>On Windows with MSVC, use nmake with the Makefile.msc:</source>
          <target state="translated">在使用MSVC的Windows中,使用nmake与Makefile.msc。</target>
        </trans-unit>
        <trans-unit id="e51bd18dd2b65a7e346c37ac44c1031b3f3942d7" translate="yes" xml:space="preserve">
          <source>On Windows, enter:</source>
          <target state="translated">在Windows上,输入。</target>
        </trans-unit>
        <trans-unit id="aacb79e6ea038d7e3cda09880e0781239b1e3933" translate="yes" xml:space="preserve">
          <source>On a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;, the WAL is first flushed to persistent storage using the xSync method of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;VFS&lt;/a&gt;. Then valid content of the WAL is transferred into the database file. Finally, the database is flushed to persistent storage using another xSync method call. The xSync operations serve as write barriers - all writes launched before the xSync must complete before any write that launches after the xSync begins.</source>
          <target state="translated">在&lt;a href=&quot;wal#ckpt&quot;&gt;检查点上&lt;/a&gt;，首先使用&lt;a href=&quot;c3ref/io_methods&quot;&gt;VFS&lt;/a&gt;的xSync方法将WAL刷新到持久性存储中。然后，将WAL的有效内容传输到数据库文件中。最后，使用另一个xSync方法调用将数据库刷新到持久性存储。xSync操作充当写障碍-在xSync开始后启动的所有写操作之前，必须先完成在xSync之前启动的所有写操作。</target>
        </trans-unit>
        <trans-unit id="ea7fd316bd0a1ed7abbfd63a2c9be9dcb14966c5" translate="yes" xml:space="preserve">
          <source>On a DISTINCT query that uses an index, try to skip ahead to the next distinct entry using the index rather than stepping through rows, when an appropriate index is available.</source>
          <target state="translated">在使用索引的DISTINCT查询中,当有合适的索引时,尝试使用索引跳转到下一个不同的条目,而不是跳过行。</target>
        </trans-unit>
        <trans-unit id="439b4340c2826997b9311dbcdfa182caed0bc968" translate="yes" xml:space="preserve">
          <source>On a traditional spinning disk, a sector is the minimum unit of transfer in both directions, both reading and writing. On flash memory, however, the minimum size of a read is typically much smaller than a minimum write. SQLite is only concerned with the minimum write amount and so for the purposes of this article, when we say &quot;sector&quot; we mean the minimum amount of data that can be written to mass storage in a single go.</source>
          <target state="translated">在传统的旋转磁盘上,一个扇区是读写两个方向的最小传输单位。但在闪存上,读的最小量通常比写的最小量小得多。SQLite只关心最小的写入量,所以在本文中,当我们说 &quot;扇区 &quot;时,我们指的是一次可以写入大容量存储的最小数据量。</target>
        </trans-unit>
        <trans-unit id="4d25766d7605da89f0dc45ce4758796da7aaedb1" translate="yes" xml:space="preserve">
          <source>On an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, if the ROWID or INTEGER PRIMARY KEY column is not explicitly given a value, then it will be filled automatically with an unused integer, usually one more than the largest ROWID currently in use. This is true regardless of whether or not the AUTOINCREMENT keyword is used.</source>
          <target state="translated">在&lt;a href=&quot;lang_insert&quot;&gt;INSERT上&lt;/a&gt;，如果未明确为ROWID或INTEGER PRIMARY KEY列提供值，则它将自动用未使用的整数填充，该整数通常比当前使用的最大ROWID多一。无论是否使用AUTOINCREMENT关键字，都是如此。</target>
        </trans-unit>
        <trans-unit id="ebef8439735d14eb6033471fd2e7d318b20febc6" translate="yes" xml:space="preserve">
          <source>On an UPSERT when the order of constraint checks is rearranged, ensure that the affinity transformations on the inserted content occur before any of the constraint checks. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/79cad5e4b2e219dd197242e9e&quot;&gt;79cad5e4b2e219dd197242e9e&lt;/a&gt;.</source>
          <target state="translated">在UPSERT上，如果重新排列了约束检查的顺序，请确保对插入内容的亲和力转换发生在任何约束检查之前。修复票&lt;a href=&quot;https://www.sqlite.org/src/info/79cad5e4b2e219dd197242e9e&quot;&gt;79cad5e4b2e219dd197242e9e的问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a7e67fba14e6027ea80edde2148e2473e22f15f" translate="yes" xml:space="preserve">
          <source>On each call to undo::undo or undo::redo, the undo/redo module automatically invokes methods status_refresh and reload_all in all toplevel namespaces. These methods should be defined to reconstruct the display or otherwise update the state of the program based on the undone/redone changes to the database.</source>
          <target state="translated">在每次调用 undo::undo 或 undo::redo 时,undo/redo 模块会自动调用所有 toplevel 命名空间中的方法 status_refresh 和 reload_all。这些方法应该被定义为重建显示或以其他方式根据数据库的未做/重做更改来更新程序的状态。</target>
        </trans-unit>
        <trans-unit id="51efe73d5459fecda0ebf237f9f8f384ca5daf31" translate="yes" xml:space="preserve">
          <source>On embedded systems with synchronous filesystems, TRUNCATE results in slower behavior than PERSIST. The commit operation is the same speed. But subsequent transactions are slower following a TRUNCATE because it is faster to overwrite existing content than to append to the end of a file. New journal file entries will always be appended following a TRUNCATE but will usually overwrite with PERSIST.</source>
          <target state="translated">在有同步文件系统的嵌入式系统中,TRUNCATE的行为比PERSIST慢。提交操作的速度是一样的。但是在TRUNCATE之后,后续的事务处理速度会变慢,因为覆盖现有内容比追加到文件末尾要快。新的日志文件条目总是在TRUNCATE之后追加,但通常会被PERSIST覆盖。</target>
        </trans-unit>
        <trans-unit id="cff1aa0bee9c89492d085449129eae77e72bb5fa" translate="yes" xml:space="preserve">
          <source>On most systems, the malloc() system call returns a buffer that is aligned to an 8-byte boundary. But on some systems (ex: windows) malloc() returns 4-byte aligned pointer. This compile-time option must be used on systems that return 4-byte aligned pointers from malloc().</source>
          <target state="translated">在大多数系统中,malloc()系统调用会返回一个对齐到8字节边界的缓冲区。但在某些系统上(如:windows),malloc()会返回4字节对齐的指针。在从malloc()返回4字节对齐指针的系统上必须使用这个编译时选项。</target>
        </trans-unit>
        <trans-unit id="87f5be0e7a33503458f9f1fc5e662122708d06fc" translate="yes" xml:space="preserve">
          <source>On newer versions of SQLite, a WAL-mode database on read-only media, or a WAL-mode database that lacks write permission, can still be read as long as one or more of the following conditions are met:</source>
          <target state="translated">在新版本的SQLite上,只要满足以下一个或多个条件,在只读介质上的WAL模式数据库,或者缺乏写权限的WAL模式数据库,仍然可以被读取。</target>
        </trans-unit>
        <trans-unit id="0a3b32dd2c0c0446522505f738b73e43600ba9ad" translate="yes" xml:space="preserve">
          <source>On startup, the &lt;b&gt;sqlite3&lt;/b&gt; program will show a brief banner message then prompt you to enter SQL. Type in SQL statements (terminated by a semicolon), press &quot;Enter&quot; and the SQL will be executed.</source>
          <target state="translated">在启动时，&lt;b&gt;sqlite3&lt;/b&gt;程序将显示一条简短的标语消息，然后提示您输入SQL。输入SQL语句（以分号终止），然后按&amp;ldquo; Enter&amp;rdquo;，将执行SQL。</target>
        </trans-unit>
        <trans-unit id="a6133c9cbc7fd01002e1fd8f131c7ef4a48f7b82" translate="yes" xml:space="preserve">
          <source>On startup, the application first decides which version it wants to display. Since the versionId will naturally increase in time and one would normally want to see the latest version, an appropriate query might be:</source>
          <target state="translated">在启动时,应用程序首先决定要显示哪个版本。由于versionId会随着时间的推移而自然增加,通常人们会希望看到最新的版本,因此一个合适的查询可能是:。</target>
        </trans-unit>
        <trans-unit id="d2a06dc722811f829dbda8827b08f5f0b5f36ae8" translate="yes" xml:space="preserve">
          <source>On success, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; is returned and the new &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; is stored in *ppBlob. Otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned and, unless the error code is SQLITE_MISUSE, *ppBlob is set to NULL. This means that, provided the API is not misused, it is always safe to call &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt; on *ppBlob after this function it returns.</source>
          <target state="translated">成功后，将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;并将新的&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄&lt;/a&gt;存储在* ppBlob中。否则，将返回&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;，除非错误代码为SQLITE_MISUSE，否则* ppBlob设置为NULL。这意味着，只要不滥用该API，在返回该函数后，始终可以在* ppBlob上调用&lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close（）&lt;/a&gt;始终是安全的。</target>
        </trans-unit>
        <trans-unit id="749e0ca8bebcf0ea981a3b5d51013a9a74a29d29" translate="yes" xml:space="preserve">
          <source>On success, &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; is returned and the new &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; is stored in *ppBlob. Otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned and, unless the error code is SQLITE_MISUSE, *ppBlob is set to NULL. This means that, provided the API is not misused, it is always safe to call &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt; on *ppBlob after this function it returns.</source>
          <target state="translated">成功后，将返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;并将新的&lt;a href=&quot;blob&quot;&gt;BLOB句柄&lt;/a&gt;存储在* ppBlob中。否则，将返回&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;，除非错误代码为SQLITE_MISUSE，否则* ppBlob设置为NULL。这意味着，只要不滥用该API，在返回该函数后，始终可以在* ppBlob上调用&lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close（）&lt;/a&gt;始终是安全的。</target>
        </trans-unit>
        <trans-unit id="65eaebdd334ea618570d91e4458e0eb1b208375f" translate="yes" xml:space="preserve">
          <source>On success, &lt;b&gt;sqlite_compile&lt;/b&gt; returns SQLITE_OK. Otherwise and error code is returned.</source>
          <target state="translated">成功时，&lt;b&gt;sqlite_compile&lt;/b&gt;返回SQLITE_OK。否则，将返回错误代码。</target>
        </trans-unit>
        <trans-unit id="3e9b1d8e369d082b964c508c283e64eea1e0560c" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_read() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned.</source>
          <target state="translated">成功时，sqlite3_blob_read（）返回SQLITE_OK。否则，将返回&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;或&lt;a href=&quot;../rescode#extrc&quot;&gt;扩展错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e81bdc76837634caa6cec9a7812e38a822384af4" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_read() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned.</source>
          <target state="translated">成功时，sqlite3_blob_read（）返回SQLITE_OK。否则，将返回&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;或&lt;a href=&quot;rescode#extrc&quot;&gt;扩展错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00223380eeb8684c87e10d42630c25143e83fb7d" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_write() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned. Unless SQLITE_MISUSE is returned, this function sets the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">成功时，sqlite3_blob_write（）返回SQLITE_OK。否则，将返回&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;或&lt;a href=&quot;../rescode#extrc&quot;&gt;扩展错误代码&lt;/a&gt;。除非返回SQLITE_MISUSE，否则此函数将设置可通过&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;和&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;及相关函数访问的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;错误代码和消息。</target>
        </trans-unit>
        <trans-unit id="e1d8319a0f054e12945ffdcd496271dbacaf81a2" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_write() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned. Unless SQLITE_MISUSE is returned, this function sets the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">成功时，sqlite3_blob_write（）返回SQLITE_OK。否则，将返回&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;或&lt;a href=&quot;rescode#extrc&quot;&gt;扩展错误代码&lt;/a&gt;。除非返回SQLITE_MISUSE，否则此函数将设置可通过&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;及相关函数访问的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;错误代码和消息。</target>
        </trans-unit>
        <trans-unit id="8609e89a9e3f181cc9bf01d1a6238ab2d0959ed4" translate="yes" xml:space="preserve">
          <source>On success, the sqlite3_prepare() family of routines return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;; otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">成功后，sqlite3_prepare（）例程系列将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;；否则返回&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3e16251e40927c67fe655d2518e028082c6fa9b3" translate="yes" xml:space="preserve">
          <source>On success, the sqlite3_prepare() family of routines return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;; otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">成功后，sqlite3_prepare（）例程系列将返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;；否则返回&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="79e4255a03a365ba20cd0884b8ee349e3d935179" translate="yes" xml:space="preserve">
          <source>On the Mac, you can set this pragma:</source>
          <target state="translated">在Mac上,你可以设置这个pragma。</target>
        </trans-unit>
        <trans-unit id="69a450284be9205b76c2e066c35f545c5c025beb" translate="yes" xml:space="preserve">
          <source>On the other hand, a database engine that uses a server can provide better protection from bugs in the client application - stray pointers in a client cannot corrupt memory on the server. And because a server is a single persistent process, it is able control database access with more precision, allowing for finer grain locking and better concurrency.</source>
          <target state="translated">另一方面,使用服务器的数据库引擎可以提供更好的保护,防止客户端应用中的bug--客户端中的游离指针无法破坏服务器上的内存。而且由于服务器是一个单一的持久化进程,它能够更精确地控制数据库的访问,从而实现更细粒度的锁定和更好的并发性。</target>
        </trans-unit>
        <trans-unit id="84736c128a35123ea022380e6a3900484bf1a802" translate="yes" xml:space="preserve">
          <source>On the other hand, a database engine that uses a server can provide better protection from bugs in the client application - stray pointers in a client cannot corrupt memory on the server. And because a server is a single persistent process, it is able to control database access with more precision, allowing for finer-grained locking and better concurrency.</source>
          <target state="translated">另一方面,使用服务器的数据库引擎可以提供更好的保护,防止客户端应用中的错误--客户端中的游离指针无法破坏服务器上的内存。而且由于服务器是一个单一的持久化进程,它能够更精确地控制数据库访问,从而实现更细粒度的锁定和更好的并发性。</target>
        </trans-unit>
        <trans-unit id="71cbc82c664fd1caf1a677d0c65b18293805a90f" translate="yes" xml:space="preserve">
          <source>On the other hand, an RBU Vacuum uses more CPU than a regular SQLite VACUUM - in one test as much as five times as much. For this reason, an RBU Vacuum is often significantly slower than an SQLite VACUUM under the same conditions.</source>
          <target state="translated">另一方面,RBU真空比普通的SQLite VACUUM使用更多的CPU--在一项测试中高达5倍。出于这个原因,在相同的条件下,RBU真空往往比SQLite VACUUM慢得多。</target>
        </trans-unit>
        <trans-unit id="2ec9b50cf6f067a94359ec578926c021dba81fa8" translate="yes" xml:space="preserve">
          <source>On the other hand, dropping tables is not a very common operation so if SQLite takes a little longer, that is not seen as a big problem.</source>
          <target state="translated">另一方面,丢表并不是一个很常见的操作,所以如果SQLite需要的时间长一点,也不会被视为一个大问题。</target>
        </trans-unit>
        <trans-unit id="b75edbc4ccb51b3a0effc26ec943821968d21e88" translate="yes" xml:space="preserve">
          <source>On the other hand, if the result of the subquery must be scanned multiple times (because, for example, it is just one table in a join) then it is better to use a transient table to remember the entire result of the subquery, in order to avoid computing the subquery more than once.</source>
          <target state="translated">另一方面,如果子查询的结果必须多次扫描(因为,例如,它只是join中的一张表),那么最好使用瞬时表来记住子查询的全部结果,以避免多次计算子查询。</target>
        </trans-unit>
        <trans-unit id="4cb26bb6bd2845585001f514df8ac5e23d3a9784" translate="yes" xml:space="preserve">
          <source>On the other hand, read performance deteriorates as the WAL file grows in size since each reader must check the WAL file for the content and the time needed to check the WAL file is proportional to the size of the WAL file. The wal-index helps find content in the WAL file much faster, but performance still falls off with increasing WAL file size. Hence, to maintain good read performance it is important to keep the WAL file size down by running checkpoints at regular intervals.</source>
          <target state="translated">另一方面,随着WAL文件大小的增加,读取性能变差,因为每个读者必须检查WAL文件的内容,而检查WAL文件所需的时间与WAL文件的大小成正比。wal-index有助于更快地找到WAL文件中的内容,但随着WAL文件大小的增加,性能还是会下降。因此,为了保持良好的读取性能,通过定期运行检查点来降低WAL文件的大小非常重要。</target>
        </trans-unit>
        <trans-unit id="9a0c49cb1cedb27f90f5b843b5321b6c2675c041" translate="yes" xml:space="preserve">
          <source>On the stack display, most entries are shown with a prefix that tells the datatype of that stack entry. Integers begin with &quot;&lt;code&gt;i:&lt;/code&gt;&quot;. Floating point values begin with &quot;&lt;code&gt;r:&lt;/code&gt;&quot;. (The &quot;r&quot; stands for &quot;real-number&quot;.) Strings begin with either &quot;&lt;code&gt;s:&lt;/code&gt;&quot;, &quot;&lt;code&gt;t:&lt;/code&gt;&quot;, &quot;&lt;code&gt;e:&lt;/code&gt;&quot; or &quot;&lt;code&gt;z:&lt;/code&gt;&quot;. The difference among the string prefixes is caused by how their memory is allocated. The z: strings are stored in memory obtained from &lt;b&gt;malloc()&lt;/b&gt;. The t: strings are statically allocated. The e: strings are ephemeral. All other strings have the s: prefix. This doesn't make any difference to you, the observer, but it is vitally important to the VDBE since the z: strings need to be passed to &lt;b&gt;free()&lt;/b&gt; when they are popped to avoid a memory leak. Note that only the first 10 characters of string values are displayed and that binary values (such as the result of the MakeRecord instruction) are treated as strings. The only other datatype that can be stored on the VDBE stack is a NULL, which is display without prefix as simply &quot;&lt;code&gt;NULL&lt;/code&gt;&quot;. If an integer has been placed on the stack as both an integer and a string, its prefix is &quot;&lt;code&gt;si:&lt;/code&gt;&quot;.</source>
          <target state="translated">在堆栈显示中，大多数条目都显示有前缀，以告诉该堆栈条目的数据类型。整数以&amp;ldquo; &lt;code&gt;i:&lt;/code&gt; &amp;rdquo; 开头。浮点值以&amp;ldquo; &lt;code&gt;r:&lt;/code&gt; &amp;rdquo; 开头。 （&amp;ldquo; r&amp;rdquo;代表&amp;ldquo;实数&amp;rdquo;。）字符串以&amp;ldquo; &lt;code&gt;s:&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;t:&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;e:&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;z:&lt;/code&gt; &amp;rdquo; 开头。字符串前缀之间的差异是由它们的内存分配方式引起的。 z：字符串存储在从&lt;b&gt;malloc（）&lt;/b&gt;获得的&lt;b&gt;内存中&lt;/b&gt;。 t：字符串是静态分配的。 e：字符串是短暂的。所有其他字符串都带有s：前缀。观察者，这对您没有任何影响，但是对于VDBE来说至关重要，因为z：字符串需要传递给&lt;b&gt;&lt;/b&gt;弹出它们时的&lt;b&gt;free（）&lt;/b&gt;以避免内存泄漏。请注意，仅显示字符串值的前10个字符，并且将二进制值（例如MakeRecord指令的结果）视为字符串。可以存储在VDBE堆栈上的唯一其他数据类型是NULL，它不带前缀显示为简单的&amp;ldquo; &lt;code&gt;NULL&lt;/code&gt; &amp;rdquo;。如果整数同时作为整数和字符串放置在堆栈中，则其前缀为&amp;ldquo; &lt;code&gt;si:&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e3336bd71adcf37ccf53527f3a1cc4855eac8894" translate="yes" xml:space="preserve">
          <source>On unix systems (or on Windows using cygwin or mingw+msys) the command typically looks something like this:</source>
          <target state="translated">在unix系统上(或者在Windows系统上使用cygwin或mingw+msys),命令通常看起来像这样。</target>
        </trans-unit>
        <trans-unit id="287d1cbba1056569ceaf042e45ed9558181651a7" translate="yes" xml:space="preserve">
          <source>On unix, if a symlink to a database file is opened, then the corresponding journal files are based on the actual filename, not the symlink name.</source>
          <target state="translated">在unix上,如果打开了数据库文件的符号链接,那么对应的日志文件是基于实际的文件名,而不是符号链接名。</target>
        </trans-unit>
        <trans-unit id="6c70d0e29a89e83eef274cc81c5528ba689d997c" translate="yes" xml:space="preserve">
          <source>On unix-like systems, directories are searched in the following order:</source>
          <target state="translated">在类似unix的系统中,目录的搜索顺序如下。</target>
        </trans-unit>
        <trans-unit id="db7db60b91e81d2d39614db0d3144dc3caa85aa5" translate="yes" xml:space="preserve">
          <source>On windows only, convert all &quot;&lt;code&gt;\&lt;/code&gt;&quot; characters into &quot;&lt;code&gt;/&lt;/code&gt;&quot;.</source>
          <target state="translated">仅在Windows上，将所有&amp;ldquo; &lt;code&gt;\&lt;/code&gt; &amp;rdquo;字符转换为&amp;ldquo; &lt;code&gt;/&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="aa996bed689bb081c327fe76624367885c13654f" translate="yes" xml:space="preserve">
          <source>On windows only, if the filename begins with a drive letter, prepend a single &quot;&lt;code&gt;/&lt;/code&gt;&quot; character.</source>
          <target state="translated">仅在Windows上，如果文件名以驱动器号开头，请在前面加上一个&amp;ldquo; &lt;code&gt;/&lt;/code&gt; &amp;rdquo;字符。</target>
        </trans-unit>
        <trans-unit id="d9c768782ea8653d485fb3b7f5aba21cb2ca7bf3" translate="yes" xml:space="preserve">
          <source>Once</source>
          <target state="translated">Once</target>
        </trans-unit>
        <trans-unit id="87f26aaf5f6994f877b899775d955216fa5722f5" translate="yes" xml:space="preserve">
          <source>Once a</source>
          <target state="translated">每年一次</target>
        </trans-unit>
        <trans-unit id="8464198c181050b3c7b7af3b57436c91d71a13de" translate="yes" xml:space="preserve">
          <source>Once a VFS has been registered, it should never be modified. If a change in behavior is required, a new VFS should be registered. The application could, perhaps, use &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; to locate the old VFS, make a copy of the old VFS into a new &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object, make the desired modifications to the new VFS, unregister the old VFS, then register the new VFS in its place. Existing database connections would continue to use the old VFS even after it is unregistered, but new database connections would use the new VFS.</source>
          <target state="translated">一旦注册了VFS，就永远不能对其进行修改。如果需要更改行为，则应注册一个新的VFS。该应用程序可能使用&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find（）&lt;/a&gt;定位旧的VFS，将旧的VFS的副本复制到新的&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象中，对新的VFS进行所需的修改，取消注册旧的VFS，然后在其中注册新的VFS。地点。即使已注销，现有的数据库连接也将继续使用旧的VFS，但是新的数据库连接将使用新的VFS。</target>
        </trans-unit>
        <trans-unit id="55b2eace4f6d572184649196769be324d9ec08aa" translate="yes" xml:space="preserve">
          <source>Once a connection obtains a table lock, it is not released until the current transaction (read or write) is concluded.</source>
          <target state="translated">一旦连接获得了表锁,在当前事务(读或写)结束之前,它不会被释放。</target>
        </trans-unit>
        <trans-unit id="5e4e9f1432dcf3c9b2a4412dec01ffd3ea3a631b" translate="yes" xml:space="preserve">
          <source>Once a process obtains an exclusive lock, it is permitted to write to the database file. It then proceeds to read the original content of pages out of the rollback journal and write that content back to where it came from in the database file. Recall that the header of the rollback journal records the original size of the database file prior to the start of the aborted transaction. SQLite uses this information to truncate the database file back to its original size in cases where the incomplete transaction caused the database to grow. At the end of this step, the database should be the same size and contain the same information as it did before the start of the aborted transaction.</source>
          <target state="translated">一旦一个进程获得了独占锁,它就被允许向数据库文件写入。然后,它从回滚日志中读取页面的原始内容,并将这些内容写回数据库文件中的原处。回想一下,回滚日志的页眉记录了中止事务开始之前数据库文件的原始大小。在不完整事务导致数据库增长的情况下,SQLite使用该信息将数据库文件截断回其原始大小。在这一步骤结束时,数据库的大小应该与中止事务开始前的大小相同,包含的信息也相同。</target>
        </trans-unit>
        <trans-unit id="b42ea281b3fc7c07c016d5e3f2cf18291c599ca4" translate="yes" xml:space="preserve">
          <source>Once a table has been attached to a session object, the session object records the primary key values of all new rows inserted into the table. It also records the original primary key and other column values of any deleted or updated rows. For each unique primary key value, data is only recorded once - the first time a row with said primary key is inserted, updated or deleted in the lifetime of the session.</source>
          <target state="translated">一旦表被附加到会话对象上,会话对象就会记录插入到表中的所有新行的主键值。它还记录任何被删除或更新的行的原始主键和其他列值。对于每个唯一的主键值,数据只记录一次--在会话的生命周期中,第一次插入、更新或删除带有所述主键的行时。</target>
        </trans-unit>
        <trans-unit id="9c0b7ad6ff995bbd9fed309a9d73615d47bfa0e5" translate="yes" xml:space="preserve">
          <source>Once a transaction has been opened, reading data from a database connection is a simple operation. Using the xRead() method of the file-handle open on the database file, the required database file pages are read one at a time. SQLite never reads partial pages and always uses a single call to xRead() for each required page.</source>
          <target state="translated">一旦事务被打开,从数据库连接中读取数据是一个简单的操作。使用数据库文件上打开的文件柄的xRead()方法,一次读取所需的数据库文件页。SQLite从不读取部分页面,总是对每个所需页面使用一次对xRead()的调用。</target>
        </trans-unit>
        <trans-unit id="511dc23c3f8ad619f86fc49e5ac60cacc5f4cbfc" translate="yes" xml:space="preserve">
          <source>Once a virtual table has been created, it can be used like any other table with the exceptions noted above and imposed by specific virtual table implementations. A virtual table is destroyed using the ordinary &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; syntax.</source>
          <target state="translated">一旦创建了虚拟表，就可以像其他任何表一样使用该表，但上面提到的例外情况除外，并由特定的虚拟表实现实施。使用普通的&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;语法销毁虚拟表。</target>
        </trans-unit>
        <trans-unit id="c3f695a7b377f8d655c6f7bd1deb78c481aa015e" translate="yes" xml:space="preserve">
          <source>Once again, practical implementations will likely subclass this structure to add additional private fields.</source>
          <target state="translated">再次,实际的实现可能会对这个结构进行子类化,以增加额外的私有字段。</target>
        </trans-unit>
        <trans-unit id="44317a76e0c4f1b6b3d16db84fa92562885dc8a9" translate="yes" xml:space="preserve">
          <source>Once again, the SQL statements generate identical bytecode and thus do exactly the same job in exactly the same way. But the second form is made easier for humans to read by grouping the query parameters together into a single row value rather than scattering them across the WHERE clause.</source>
          <target state="translated">再一次,SQL语句生成的字节码完全相同,因此以完全相同的方式完成了相同的工作。但第二种形式通过将查询参数归纳为一个单一的行值,而不是将它们分散在WHERE子句中,使人类更容易阅读。</target>
        </trans-unit>
        <trans-unit id="d645ca4d6b0e5bfa41d1d0e06bb9cd91ff636156" translate="yes" xml:space="preserve">
          <source>Once all rollback journal files have been flushed to disk, it is safe to begin updating database files. We have to obtain an exclusive lock on all database files before writing the changes. After all the changes are written, it is important to flush the changes to disk so that they will be preserved in the event of a power failure or operating system crash.</source>
          <target state="translated">当所有回滚日志文件被刷新到磁盘后,就可以安全地开始更新数据库文件了。在写入更改之前,我们必须获得所有数据库文件的专属锁。在所有的更改写完后,必须将更改冲到磁盘上,这样在断电或操作系统崩溃时,这些更改就会被保存下来。</target>
        </trans-unit>
        <trans-unit id="73fcb528effe6301ec78591adf7629a8ed98b913" translate="yes" xml:space="preserve">
          <source>Once an SQLite database is open, it can be controlled using methods of the</source>
          <target state="translated">一旦一个SQLite数据库被打开,就可以通过使用</target>
        </trans-unit>
        <trans-unit id="1676ac6920d27f0701cc052fe7ff5982a44cea9d" translate="yes" xml:space="preserve">
          <source>Once an encoding has been set for a database, it cannot be changed.</source>
          <target state="translated">一旦为数据库设置了编码,就不能更改。</target>
        </trans-unit>
        <trans-unit id="1f61d0c0dc743205cfd592b973902a4df3bd2139" translate="yes" xml:space="preserve">
          <source>Once an exclusive lock is held, we know that no other processes are reading from the database file and it is safe to write changes into the database file. Usually those changes only go as far as the operating systems disk cache and do not make it all the way to mass storage.</source>
          <target state="translated">一旦独占锁被持有,我们就知道没有其他进程从数据库文件中读取,向数据库文件写入更改是安全的。通常这些更改只到操作系统的磁盘缓存,不会一直到大容量存储。</target>
        </trans-unit>
        <trans-unit id="8d6da848ac7743477288c842a221e398489c8a06" translate="yes" xml:space="preserve">
          <source>Once any conversions have taken place, and neither value is NULL, the values are compared. If both values are blobs then memcmp() is used to determine the results of the comparison. If both values are text, then the appropriate collating function specified in P4 is used to do the comparison. If P4 is not specified then memcmp() is used to compare text string. If both values are numeric, then a numeric comparison is used. If the two values are of different types, then numbers are considered less than strings and strings are considered less than blobs.</source>
          <target state="translated">一旦发生了任何转换,并且两个值都不是NULL,就会对这些值进行比较。如果两个值都是blobs,那么就用memcmp()来确定比较的结果,如果两个值都是文本,那么就用P4中指定的整理函数进行比较。如果两个值都是文本,则使用P4中指定的适当的整理函数进行比较。如果没有指定P4,那么就用memcmp()来比较文本字符串,如果两个值都是数字,那么就用P4中指定的整理函数来比较。如果两个值都是数值,则使用数值比较。如果两个值的类型不同,那么数字被认为小于字符串,字符串被认为小于blobs。</target>
        </trans-unit>
        <trans-unit id="4b170c45b3f098d917697616ac86ca3f213bd255" translate="yes" xml:space="preserve">
          <source>Once everything is ready, run the &quot;&lt;code&gt;fossil commit&lt;/code&gt;&quot; command to check in the changes. This creates circle (4) in the diagram above.</source>
          <target state="translated">一切准备就绪后，请运行&amp;ldquo; &lt;code&gt;fossil commit&lt;/code&gt; &amp;rdquo;命令以检查更改。这将在上图中创建圆（4）。</target>
        </trans-unit>
        <trans-unit id="89efbd20c0a9cf3f9851965660941121b8a57cbc" translate="yes" xml:space="preserve">
          <source>Once one is comfortable with the concept of storing each slide separately, it is a small step to support versioning of the presentation. Consider the following schema:</source>
          <target state="translated">一旦人们对单独存储每张幻灯片的概念感到满意,那么支持演示文稿的版本化就是一小步。考虑以下模式。</target>
        </trans-unit>
        <trans-unit id="05be8dd08c1c90f1df285706af044dc836d0d98a" translate="yes" xml:space="preserve">
          <source>Once populated, there are three ways to execute a full-text query against the contents of an FTS5 table:</source>
          <target state="translated">一旦填充,有三种方法可以针对FTS5表的内容执行全文查询。</target>
        </trans-unit>
        <trans-unit id="e7dc51406db9bf51bbe6620c6512b34c3f0e8f5e" translate="yes" xml:space="preserve">
          <source>Once the dirty page being purged is writable, it is simply written into the database file.</source>
          <target state="translated">一旦被清除的脏页可以写,就会简单地写入数据库文件中。</target>
        </trans-unit>
        <trans-unit id="821430ef05c1ab204de759a3df24102ae4261d90" translate="yes" xml:space="preserve">
          <source>Once the input data from the FROM clause has been filtered by the WHERE clause expression (if any), the set of result rows for the simple SELECT are calculated. Exactly how this is done depends on whether the simple SELECT is an aggregate or non-aggregate query, and whether or not a GROUP BY clause was specified.</source>
          <target state="translated">一旦来自FROM子句的输入数据被WHERE子句表达式(如果有的话)过滤,简单SELECT的结果行集就会被计算出来。具体如何计算取决于简单的SELECT是集合查询还是非集合查询,以及是否指定了GROUP BY子句。</target>
        </trans-unit>
        <trans-unit id="79336569e93b2e9d0a83cc5e0a929d5ce48d2824" translate="yes" xml:space="preserve">
          <source>Once the project repository is created, create an open checkout of the project by moving to the directory where you want to keep all of the project source code and typing:</source>
          <target state="translated">一旦项目仓库被创建,通过移动到你想保存所有项目源代码的目录并键入,创建一个项目的开放检查。</target>
        </trans-unit>
        <trans-unit id="c4e9c9ce3f592c90096798d4d198a8b0474086e9" translate="yes" xml:space="preserve">
          <source>Once the spellfix1 extension is loaded, an instance of the spellfix1 virtual table is created like this:</source>
          <target state="translated">一旦spellfix1扩展被加载,spellfix1虚拟表的实例就会像这样创建。</target>
        </trans-unit>
        <trans-unit id="8513b43854c13df7657753be614db748baf13f7a" translate="yes" xml:space="preserve">
          <source>Once the test program is generated, it is run with no arguments to perform the tests. Progress information as well as error diagnostics appear on standard output. (Alternative output arrangements can be made using a compile-time option for embedded devices that lack a standard output channel.) The program returns zero if there are no errors and non-zero if any problems were detected.</source>
          <target state="translated">一旦测试程序生成,它将在没有参数的情况下运行,以执行测试。进度信息以及错误诊断出现在标准输出上。(对于缺乏标准输出通道的嵌入式设备,可以使用编译时选项进行替代输出安排)。如果没有错误,程序返回零,如果检测到任何问题,则返回非零。</target>
        </trans-unit>
        <trans-unit id="bd0d76b14cf548de7ba347b074f1a4d3fbd73686" translate="yes" xml:space="preserve">
          <source>Once the virtual table is created, it can be queried as follows:</source>
          <target state="translated">一旦创建了虚拟表,就可以进行如下查询。</target>
        </trans-unit>
        <trans-unit id="1f76d0dc14ccffaabe0506021b655e9b2d8e3d76" translate="yes" xml:space="preserve">
          <source>Once you locate a specific version, click on the hyperlink for that version to see the &quot;Check-in Information Page&quot;. Then click on either the &quot;Tarball&quot; link or the &quot;ZIP archive&quot; link to download the complete source tree.</source>
          <target state="translated">一旦你找到了一个特定的版本,点击该版本的超链接,就可以看到 &quot;签到信息页&quot;。然后点击 &quot;Tarball &quot;链接或 &quot;ZIP archive &quot;链接,下载完整的源代码树。</target>
        </trans-unit>
        <trans-unit id="5d89aa77c530c282e22378ce0f5d708e01a8b4fb" translate="yes" xml:space="preserve">
          <source>One approach to this query is to use the fruit='Orange' term of the WHERE clause to find all rows dealing with oranges, then filter those rows by rejecting any that are from states other than California. This process is shown by &lt;a href=&quot;#fig7&quot;&gt;figure 7&lt;/a&gt; above. This is a perfectly reasonable approach in most cases. Yes, the database engine did have to do an extra binary search for the Florida orange row that was later rejected, so it was not as efficient as we might hope, though for many applications it is efficient enough.</source>
          <target state="translated">此查询的一种方法是使用WHERE子句的fruit ='Orange'术语查找涉及橙子的所有行，然后通过拒绝来自加利福尼亚州以外州的任何行来过滤这些行。上面的&lt;a href=&quot;#fig7&quot;&gt;图7&lt;/a&gt;显示了此过程。在大多数情况下，这是一种完全合理的方法。是的，数据库引擎确实必须对后来被拒绝的佛罗里达橙行进行额外的二进制搜索，因此它的效率不如我们希望的那样，尽管对于许多应用程序来说，它的效率已足够。</target>
        </trans-unit>
        <trans-unit id="83e48e323326e14265bd89807dc478da45112a98" translate="yes" xml:space="preserve">
          <source>One can also provide comma-separated arguments to the module following the module name:</source>
          <target state="translated">我们也可以在模块名称后面为模块提供逗号分隔的参数。</target>
        </trans-unit>
        <trans-unit id="c99a07ebdfa971a90b20da9b4561b5f49cd6023c" translate="yes" xml:space="preserve">
          <source>One can also set the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; into automatic EXPLAIN QUERY PLAN mode using the &quot;.eqp on&quot; command:</source>
          <target state="translated">也可以使用&amp;ldquo; .eqp on&amp;rdquo;命令将&lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;设置为自动EXPLAIN QUERY PLAN模式：</target>
        </trans-unit>
        <trans-unit id="efbb187108974c009f143234a98d6989ff9c9ac6" translate="yes" xml:space="preserve">
          <source>One can also think of savepoints as &quot;marks&quot; in the transaction timeline. In this view, the SAVEPOINT command creates a new mark, the ROLLBACK TO command rewinds the timeline back to a point just after the named mark, and the RELEASE command erases marks from the timeline without actually making any changes to the database.</source>
          <target state="translated">我们也可以把保存点看作是事务时间轴上的 &quot;标记&quot;。在这个视图中,SAVEPOINT命令创建了一个新的标记,ROLLBACK TO命令将时间轴倒退到命名标记之后的一个点,而RELEASE命令则从时间轴上删除了标记,而实际上并没有对数据库做任何改变。</target>
        </trans-unit>
        <trans-unit id="3d55d95e5af6d3d744fa5a934dc2cc27683084a3" translate="yes" xml:space="preserve">
          <source>One can explicitly change out of WAL mode using a pragma such as this:</source>
          <target state="translated">可以使用类似这样的pragma明确地改变WAL模式。</target>
        </trans-unit>
        <trans-unit id="5812082b2084545c8ed5d26ce266777d4a58efe5" translate="yes" xml:space="preserve">
          <source>One can see how the OR-by-UNION technique could also be leveraged to use multiple indices on queries where the WHERE clause has terms connected by AND, by using an intersect operator in place of union. Many SQL database engines will do just that. But the performance gain over using just a single index is slight and so SQLite does not implement that technique at this time. However, a future version SQLite might be enhanced to support AND-by-INTERSECT.</source>
          <target state="translated">我们可以看到OR-by-UNION技术是如何被利用的,在WHERE子句的术语由AND连接的查询中,通过使用一个intersect操作符来代替union,来使用多个索引。许多SQL数据库引擎都会这样做。但与只使用单个索引相比,性能的提升是微乎其微的,所以SQLite目前没有实现这种技术。不过,未来的版本SQLite可能会增强对AND-by-INTERSECT的支持。</target>
        </trans-unit>
        <trans-unit id="18266c8f1da4ccb3784663f1422488207a89b45d" translate="yes" xml:space="preserve">
          <source>One cannot create a trigger on a virtual table.</source>
          <target state="translated">不能在虚拟表上创建一个触发器。</target>
        </trans-unit>
        <trans-unit id="08c14fea12c1a91b86b4eb3020bc8d201daa13d9" translate="yes" xml:space="preserve">
          <source>One cannot create additional indices on a virtual table. (Virtual tables can have indices but that must be built into the virtual table implementation. Indices cannot be added separately using &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statements.)</source>
          <target state="translated">不能在虚拟表上创建其他索引。（虚拟表可以具有索引，但是必须将其内置到虚拟表实现中。不能使用&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;语句单独添加索引。）</target>
        </trans-unit>
        <trans-unit id="d3b50c178c087fb42ad06f0aba999c85b1ef895b" translate="yes" xml:space="preserve">
          <source>One cannot easily view, change, or extract the content of an OpenDocument presentation using generic tools. The only reasonable way to view or edit an OpenDocument document is to open it up using an application that is specifically designed to read or write OpenDocument (read: LibreOffice or one of its cousins). The situation could be worse. One can extract and view individual images (say) from a presentation using just the &quot;zip&quot; archiver tool. But it is not reasonable try to extract the text from a slide. Remember that all content is stored in a single &quot;context.xml&quot; file. That file is XML, so it is a text file. But it is not a text file that can be managed with an ordinary text editor. For the example presentation above, the content.xml file consist of exactly two lines. The first line of the file is just:</source>
          <target state="translated">人们无法使用通用工具轻松查看、更改或提取OpenDocument演示文稿的内容。唯一合理的查看或编辑OpenDocument文档的方法是使用专门为读写OpenDocument而设计的应用程序打开它(读:LibreOffice或它的一个兄弟)。情况可能更糟。人们可以使用 &quot;zip &quot;存档工具从演示文稿中提取和查看单个图像(比如)。但从幻灯片中提取文本是不合理的。请记住,所有的内容都存储在一个单一的 &quot;context.xml &quot;文件中。该文件是XML,所以它是一个文本文件。但它不是一个文本文件,可以用普通的文本编辑器来管理。对于上面的例子演示,content.xml文件正好由两行组成。文件的第一行只是。</target>
        </trans-unit>
        <trans-unit id="8b60832325e280604faf68cf7c5149fd06825525" translate="yes" xml:space="preserve">
          <source>One cannot run &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; commands against a virtual table.</source>
          <target state="translated">无法对虚拟表运行&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="8229271a498b58a8b73749061ba175879d5bffff" translate="yes" xml:space="preserve">
          <source>One difference between Next and ListRead is their idea of a &quot;thing&quot;. The &quot;things&quot; for the Next instruction are records in a database file. &quot;Things&quot; for ListRead are integer keys in a list. Another difference is whether to jump or fall through if there is no next &quot;thing&quot;. In this case, Next falls through, and ListRead jumps. Later on, we will see other looping instructions (NextIdx and SortNext) that operate using the same principle.</source>
          <target state="translated">Next和ListRead的一个区别是它们对 &quot;事物 &quot;的概念。Next指令的 &quot;事物 &quot;是数据库文件中的记录。ListRead的 &quot;东西 &quot;是一个列表中的整数键。另一个区别是,如果没有下一个 &quot;事物&quot;,是跳转还是跌过。在这种情况下,Next落空,ListRead跳转。后面我们会看到其他的循环指令(NextIdx和SortNext),它们的操作原理是一样的。</target>
        </trans-unit>
        <trans-unit id="0e2add845dd3757fedbc712aca0fdd2b6ebca768" translate="yes" xml:space="preserve">
          <source>One example of this occurred circa 2013-08-30 on the canonical repository for the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt;. In that event, file descriptor 2 (standard error) was being erroneously closed (by &lt;a href=&quot;http://www.stunnel.org/&quot;&gt;stunnel&lt;/a&gt;, we suspect) prior to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; so that the file descriptor used for the repository database file was 2. Later, an application bug caused an assert() statement to emit an error message by invoking write(2,...). But since file descriptor 2 was now connected to a database file, the error message overwrote part of the database. To guard against this kind of problem, SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;version 3.8.1&lt;/a&gt; (2013-10-17) and later refuse to use low-numbered file descriptors for database files. (See &lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; for additional information.)</source>
          <target state="translated">其中一个示例发生在2013年8月30日左右的&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt;规范存储库中。在那种情况下，文件描述符2（标准错误）在&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;之前被错误地关闭了（我们怀疑是&lt;a href=&quot;http://www.stunnel.org/&quot;&gt;stunnel &lt;/a&gt;），因此用于存储库数据库文件的文件描述符为2。后来，一个应用程序错误引起了assert（ ）语句通过调用write（2，...）发出错误消息。但是由于文件描述符2现在已连接到数据库文件，因此错误消息覆盖了数据库的一部分。为防止此类问题，SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;版本3.8.1&lt;/a&gt;（2013-10-17）及更高版本拒绝为数据库文件使用低编号的文件描述符。（请参见&lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; 有关其他信息。）</target>
        </trans-unit>
        <trans-unit id="2800173ae3677a256fd77a10d7d4ad92a56413c2" translate="yes" xml:space="preserve">
          <source>One example of this occurred circa 2013-08-30 on the canonical repository for the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt;. In that event, file descriptor 2 (standard error) was being erroneously closed (by &lt;a href=&quot;https://www.stunnel.org/&quot;&gt;stunnel&lt;/a&gt;, we suspect) prior to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; so that the file descriptor used for the repository database file was 2. Later, an application bug caused an assert() statement to emit an error message by invoking write(2,...). But since file descriptor 2 was now connected to a database file, the error message overwrote part of the database. To guard against this kind of problem, SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;version 3.8.1&lt;/a&gt; (2013-10-17) and later refuse to use low-numbered file descriptors for database files. (See &lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; for additional information.)</source>
          <target state="translated">其中一个示例发生在2013年8月30日左右的&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt;规范存储库中。在那种情况下，文件描述符2（标准错误）在&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;之前被错误地关闭（通过&lt;a href=&quot;https://www.stunnel.org/&quot;&gt;stunnel&lt;/a&gt;，我们怀疑），因此用于存储库数据库文件的文件描述符为2。后来，一个应用程序错误导致assert（ ）语句通过调用write（2，...）发出错误消息。但是由于文件描述符2现在已连接到数据库文件，因此错误消息覆盖了数据库的一部分。为了防止此类问题，SQLite&lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;版本3.8.1&lt;/a&gt;（2013-10-17）及更高版本拒绝为数据库文件使用低编号的文件描述符。（请参见&lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; 有关其他信息。）</target>
        </trans-unit>
        <trans-unit id="f155185b09ba1b186403646b80d41d02e18f29b2" translate="yes" xml:space="preserve">
          <source>One exception to the typelessness of SQLite is a column whose type is INTEGER PRIMARY KEY. (And you must use &quot;INTEGER&quot; not &quot;INT&quot;. A column of type INT PRIMARY KEY is typeless just like any other.) INTEGER PRIMARY KEY columns must contain a 32-bit signed integer. Any attempt to insert non-integer data will result in an error.</source>
          <target state="translated">SQLite的无类型性的一个例外是一个类型为INTEGER PRIMARY KEY的列。(而且你必须使用 &quot;INTEGER &quot;而不是 &quot;INT&quot;。类型为INT PRIMARY KEY的列和其他列一样是无类型的)。)INTEGER PRIMARY KEY列必须包含一个32位有符号的整数。任何插入非整数数据的尝试都会导致错误。</target>
        </trans-unit>
        <trans-unit id="c476dc0c19b1ad151c922c972d11950866ac1040" translate="yes" xml:space="preserve">
          <source>One fuzzing researcher of particular note is &lt;a href=&quot;https://www.manuelrigger.at/&quot;&gt;Manuel Rigger&lt;/a&gt;, currently (as this paragraph is written on 2019-12-21) at &lt;a href=&quot;https://ethz.ch/en.html&quot;&gt;ETH Zurich&lt;/a&gt;. Most fuzzers only look for assertion faults, crashes, undefined behavior (UB), or other easily detected anomalies. Dr. Rigger's fuzzers, on the other hand, are able to find cases where SQLite computes an incorrect answer. Rigger has found &lt;a href=&quot;https://www.sqlite.org/src/timeline?y=t&amp;amp;u=mrigger&amp;amp;n=all&quot;&gt;many such cases&lt;/a&gt;. Most of these finds are fairly obscure corner cases involving type conversions and affinity transformations, and a good number of the finds are against unreleased features. Nevertheless, his finds are still important as they are real bugs, and the SQLite developers are grateful to be able to identify and fix the underlying problems. Rigger's work is currently unpublished. When it is released, it could be as influential as Zalewski's invention of AFL and profile-guided fuzzing.</source>
          <target state="translated">特别令人关注的一个令人困惑的研究员是&lt;a href=&quot;https://www.manuelrigger.at/&quot;&gt;曼努埃尔&amp;middot;里格&lt;/a&gt;（Manuel Rigger），目前（本段写于2019-12-21）在&lt;a href=&quot;https://ethz.ch/en.html&quot;&gt;苏黎世联邦理工学院&lt;/a&gt;。大多数模糊测试器仅查找断言错误，崩溃，未定义行为（UB）或其他容易检测到的异常。另一方面，Rigger博士的模糊处理程序能够发现SQLite计算出错误答案的情况。瑞格（Rigger）发现了&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=t&amp;amp;u=mrigger&amp;amp;n=all&quot;&gt;很多这样的情况&lt;/a&gt;。这些发现中的大多数都是相当模糊的角落案例，涉及类型转换和亲和力转换，并且很多发现都针对未发布的功能。但是，他的发现仍然很重要，因为它们是真正的错误，并且SQLite开发人员很感激能够识别并解决潜在的问题。 Rigger的工作目前尚未公开。当它发布时，它的影响力可能与Zalewski发明的AFL和配置文件引导的模糊测试一样有影响力。</target>
        </trans-unit>
        <trans-unit id="a6bf8910e6414d0165fef0d30b0886bc0f8d4329" translate="yes" xml:space="preserve">
          <source>One implication of the above is that if a change is made and then unmade within a single session (for example if a row is inserted and then deleted again), the sessions module does not report any change at all. Or if a row is updated multiple times within the same session, all updates are coalesced into a single update within any changeset or patchset blob.</source>
          <target state="translated">上面的一个含义是,如果在一个会话中进行了更改,然后又取消了更改(例如,如果一行被插入,然后又被删除),会话模块根本不会报告任何更改。或者,如果一行在同一个会话中被更新了多次,那么所有的更新都会在任何变化集或补丁集blob中被合并成一个单一的更新。</target>
        </trans-unit>
        <trans-unit id="fc9f38831587103a404686b12cd389ecfbf1fe12" translate="yes" xml:space="preserve">
          <source>One might argue that it is ok, in this era of multi-gigabyte desktops, to read the entire document into memory. But it is not ok. For one, the amount of memory used far exceeds the (compressed) file size on disk. So a 50MB presentation might take 200MB or more RAM. That still is not a problem if one only edits a single document at a time. But when working on a talk, this author will typically have 10 or 15 different presentations up all at the same time (to facilitate copy/paste of slides from past presentation) and so gigabytes of memory are required. Add in an open web browser or two and a few other desktop apps, and suddenly the disk is whirling and the machine is swapping. And even having just a single document is a problem when working on an inexpensive Chromebook retrofitted with Ubuntu. Using less memory is always better.</source>
          <target state="translated">也许有人会说,在这个多千兆字节的台式机时代,把整个文件读到内存中是可以的。但这是不行的。首先,使用的内存量远远超过了磁盘上的(压缩)文件大小。所以一个50MB的演示文稿可能要占用200MB甚至更多的内存。如果一次只编辑一个文件,这还是没有问题的。但是在做演讲时,本作者通常会有10个或15个不同的演示文稿同时出现(以方便复制/粘贴过去演示文稿中的幻灯片),因此需要千兆内存。再加上一两个打开的网页浏览器和其他一些桌面应用,突然间磁盘就呼呼作响,机器也在不停地交换。而在一台加装了Ubuntu的廉价Chromebook上工作时,即使只有一个文档也是个问题。使用更少的内存总是更好。</target>
        </trans-unit>
        <trans-unit id="f44cc341ba0d29ec39fe1d9113cc5db69afebdc7" translate="yes" xml:space="preserve">
          <source>One might want to provide other &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; such as &lt;a href=&quot;compile#enable_fts4&quot;&gt;-DSQLITE_ENABLE_FTS4&lt;/a&gt; or &lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt; for full-text search, &lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; for the R*Tree search engine extension, &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; to include &lt;a href=&quot;json1&quot;&gt;JSON SQL functions&lt;/a&gt;, or &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;-DSQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; for the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;. In order to see extra commentary in &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; listings, add the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; option. On unix systems, add -DHAVE_USLEEP=1 if the host machine supports the usleep() system call. Add -DHAVE_READLINE and the -lreadline and -lncurses libraries to get command-line editing support. One might also want to specify some compiler optimization switches. (The precompiled CLI available for download from the SQLite website uses &quot;-Os&quot;.) There are countless possible variations here. A command to compile a full-featured shell might look something like this:</source>
          <target state="translated">可能需要提供其他&lt;a href=&quot;compile&quot;&gt;编译时选项，&lt;/a&gt;例如&lt;a href=&quot;compile#enable_fts4&quot;&gt;-DSQLITE_ENABLE_FTS4&lt;/a&gt;或&lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt;用于全文搜索，&lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt;用于R * Tree搜索引擎扩展，&lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt;包括&lt;a href=&quot;json1&quot;&gt;JSON SQL函数&lt;/a&gt;，或&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;-DSQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt;用于&lt;a href=&quot;dbstat&quot;&gt;dbstat&lt;/a&gt;。为了在&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;列表中查看更多评论，请添加&lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt;选项。在Unix系统上，如果主机支持usleep（）系统调用，请添加-DHAVE_USLEEP = 1。添加-DHAVE_READLINE以及-lreadline和-inccurses库以获得命令行编辑支持。可能还需要指定一些编译器优化开关。 （可从SQLite网站下载的预编译CLI使用&amp;ldquo; -Os&amp;rdquo;。）这里有无数可能的变化。编译全功能shell的命令可能类似于以下内容：</target>
        </trans-unit>
        <trans-unit id="6a02d032d7380123e8a5e72e863e1054c5bd48cb" translate="yes" xml:space="preserve">
          <source>One minor downside of splitting content into smaller pieces is that compression does not work as well on shorter texts and so the size of the document might increase. But as the bulk of the document space is used to store images, a small reduction in the compression efficiency of the text content will hardly be noticeable, and is a small price to pay for an improved user experience.</source>
          <target state="translated">将内容分割成小块的一个小缺点是,压缩在较短的文本上效果不佳,因此文档的大小可能会增加。但是,由于文档空间的大部分用于存储图像,文本内容压缩效率的小幅下降几乎不会被察觉,这是为改善用户体验而付出的小代价。</target>
        </trans-unit>
        <trans-unit id="b297ff44d76535e06e20e05a05458aba9a18af0a" translate="yes" xml:space="preserve">
          <source>One of the 10 decimal digit ASCII characters, or</source>
          <target state="translated">10个十进制字符中的一个ASCII字符或</target>
        </trans-unit>
        <trans-unit id="67403b0cb5390fcf0c705699aeb495a2edb6d96b" translate="yes" xml:space="preserve">
          <source>One of the 52 upper and lower case ASCII characters, or</source>
          <target state="translated">52个大写和小写ASCII字符中的一个,即</target>
        </trans-unit>
        <trans-unit id="cff101187bdbe5720613db95b3564ea1057f17a1" translate="yes" xml:space="preserve">
          <source>One of the &lt;a href=&quot;different&quot;&gt;distinctive features&lt;/a&gt; of SQLite is that a database consists of a single disk file. This simplifies the use of SQLite since moving or backing up a database is a simple as copying a single file. It also makes SQLite appropriate for use as an &lt;a href=&quot;whentouse#appfileformat&quot;&gt;application file format&lt;/a&gt;. But while a complete database is held in a single disk file, SQLite does make use of many temporary files during the course of processing a database.</source>
          <target state="translated">SQLite 的&lt;a href=&quot;different&quot;&gt;独特功能&lt;/a&gt;之一是数据库由单个磁盘文件组成。因为移动或备份数据库就像复制单个文件一样简单，所以这简化了SQLite的使用。它还使SQLite适合用作&lt;a href=&quot;whentouse#appfileformat&quot;&gt;应用程序文件格式&lt;/a&gt;。但是，虽然完整的数据库保存在单个磁盘文件中，但SQLite确实在处理数据库的过程中使用了许多临时文件。</target>
        </trans-unit>
        <trans-unit id="e5c91de459561e96de8f3e9e77eaa61509cd18a7" translate="yes" xml:space="preserve">
          <source>One of the ALL or DISTINCT keywords may follow the SELECT keyword in a simple SELECT statement. If the simple SELECT is a SELECT ALL, then the entire set of result rows are returned by the SELECT. If neither ALL or DISTINCT are present, then the behavior is as if ALL were specified. If the simple SELECT is a SELECT DISTINCT, then duplicate rows are removed from the set of result rows before it is returned. For the purposes of detecting duplicate rows, two NULL values are considered to be equal. The &lt;a href=&quot;datatype3#colrules&quot;&gt;usual rules&lt;/a&gt; apply for selecting a collation sequence to compare text values.</source>
          <target state="translated">在简单的SELECT语句中，ALL或DISTINCT关键字之一可以紧跟SELECT关键字。如果简单SELECT是SELECT ALL，则SELECT返回整个结果行集。如果ALL或DISTINCT都不存在，则行为就像指定了ALL。如果简单的SELECT是SELECT DISTINCT，则在返回结果行之前，将从结果行集中删除重复的行。为了检测重复的行，两个NULL值被认为是相等的。在&lt;a href=&quot;datatype3#colrules&quot;&gt;通常的规则&lt;/a&gt;适用于选择归类序列比较文本值。</target>
        </trans-unit>
        <trans-unit id="148ba6e1c7e039de60e4599c768cf9921948e4c8" translate="yes" xml:space="preserve">
          <source>One of the advantages of hosting code generator tools as part of the project is that the tools can be optimized to serve specific needs of the overall project. Lemon has benefited from this effect. Over the years, the Lemon parser generator has been extended and enhanced to provide new capabilities and improved performance to SQLite. A few of the specific enhancements to Lemon that are specifically designed for use by SQLite include:</source>
          <target state="translated">作为项目的一部分托管代码生成器工具的优势之一是,可以优化工具以服务于整个项目的特定需求。Lemon就得益于这种效果。多年来,Lemon解析器生成器一直在扩展和增强,以向SQLite提供新的功能和改进的性能。Lemon专门为SQLite使用而设计的一些具体增强功能包括:。</target>
        </trans-unit>
        <trans-unit id="66a50c77336f3c9a6df53cb2e7363aee5a52fbbd" translate="yes" xml:space="preserve">
          <source>One of the interesting features of the VFS interface is that SQLite can support multiple VFSes at the same time. Each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; has to choose a single VFS for its use when the connection is first opened using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. But if a process contains multiple &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; each can choose a different VFS. VFSes can be added at run-time using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface.</source>
          <target state="translated">VFS界面有趣的功能之一是SQLite可以同时支持多个VFS。在首次使用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;打开连接时，每个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;都必须选择一个VFS供其使用。但是，如果一个进程包含多个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接，则&lt;/a&gt;每个进程都可以选择不同的VFS。可以在运行时使用&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;接口添加VFS 。</target>
        </trans-unit>
        <trans-unit id="f1c2a440e7d12be65f7ff95454bfa77307c4b02e" translate="yes" xml:space="preserve">
          <source>One of the many reports that Fossil makes available is a timeline of changes to a single branch showing all merges in and out of that branch. See &lt;a href=&quot;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&lt;/a&gt; for a typical example of such a report. Generating such a report normally takes just a few milliseconds. But after upgrading to the NGQP we noticed that this one report was taking closer to 10 seconds for the trunk of the repository.</source>
          <target state="translated">Fossil提供的众多报告之一是对单个分支进行更改的时间表，其中显示了该分支内外的所有合并。有关此类报告的典型示例，请参见&lt;a href=&quot;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&lt;/a&gt;。生成此类报告通常只需几毫秒。但是在升级到NGQP之后，我们注意到该报告对存储库主干的花费接近10秒。</target>
        </trans-unit>
        <trans-unit id="2bf1094093ae892a1e0164d69250728d7ebf09d8" translate="yes" xml:space="preserve">
          <source>One of the many reports that Fossil makes available is a timeline of changes to a single branch showing all merges in and out of that branch. See &lt;a href=&quot;https://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&lt;/a&gt; for a typical example of such a report. Generating such a report normally takes just a few milliseconds. But after upgrading to the NGQP we noticed that this one report was taking closer to 10 seconds for the trunk of the repository.</source>
          <target state="translated">Fossil提供的众多报告之一是对单个分支进行更改的时间表，其中显示了该分支内外的所有合并。有关此类报告的典型示例，请参见&lt;a href=&quot;https://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&lt;/a&gt;。生成此类报告通常只需几毫秒。但是在升级到NGQP之后，我们注意到该报告对存储库主干的花费接近10秒。</target>
        </trans-unit>
        <trans-unit id="16f929fd09cef7d1acb11b165614f8e6f651a35f" translate="yes" xml:space="preserve">
          <source>One of the things that SQLite does to ensure that transactions are atomic across system crashes and power failures is to write all changes into the rollback journal file prior to changing the database. The TCL test harness contains an alternative &lt;a href=&quot;vfs&quot;&gt;OS backend&lt;/a&gt; implementation that helps to verify this is occurring correctly. The &quot;journal-test VFS&quot; monitors all disk I/O traffic between the database file and rollback journal, checking to make sure that nothing is written into the database file which has not first been written and synced to the rollback journal. If any discrepancies are found, an assertion fault is raised.</source>
          <target state="translated">SQLite为确保事务在系统崩溃和电源故障时是原子性的，要做的一件事是在更改数据库之前将所有更改写入回滚日志文件。 TCL测试工具包含一个可选的&lt;a href=&quot;vfs&quot;&gt;OS后端&lt;/a&gt;实现，有助于验证此操作是否正确发生。 &amp;ldquo; journal-test VFS&amp;rdquo;监视数据库文件和回滚日志之间的所有磁盘I / O流量，检查以确保没有任何内容写入数据库文件，而该文件尚未被首先写入并同步到回滚日志。如果发现任何差异，则会引发断言错误。</target>
        </trans-unit>
        <trans-unit id="8702bf42f5b52e2937e5261eb8fe5e53cb025817" translate="yes" xml:space="preserve">
          <source>One or more indexes of the table are currently unanalyzed &lt;em&gt;or&lt;/em&gt; the number of rows in the table has increased by 25 times or more since the last time ANALYZE was run.</source>
          <target state="translated">自上次运行ANALYZE以来，当前未对表的一个或多个索引进行分析，&lt;em&gt;或者&lt;/em&gt;表中的行数增加了25倍或更多。</target>
        </trans-unit>
        <trans-unit id="feb2e1f55ecdbf77cec780482429b500004b78e4" translate="yes" xml:space="preserve">
          <source>One or more of the SELECT statements in the compound must be non-recursive.</source>
          <target state="translated">复合中的一个或多个SELECT语句必须是非递归的。</target>
        </trans-unit>
        <trans-unit id="ea6d64ad5a0fa81894775a5275ad8d5ac847fedc" translate="yes" xml:space="preserve">
          <source>One or more of the individual SELECT statements that make up the compound must be &quot;recursive&quot;. A SELECT statement is a recursive if its FROM clause contains exactly one reference to the the CTE table (the table named on the left-hand side of the AS clause).</source>
          <target state="translated">组成化合物的一个或多个SELECT语句必须是 &quot;递归 &quot;的。如果一个SELECT语句的FROM子句正好包含一个对CTE表(AS子句左侧命名的表)的引用,那么这个语句就是递归的。</target>
        </trans-unit>
        <trans-unit id="c07477cd0e5dcf04189629377d839b6d5b58ba89" translate="yes" xml:space="preserve">
          <source>One or more transactions must have been written to the current wal file since it was created on disk (by any connection). This means that a snapshot cannot be taken on a wal mode database with no wal file immediately after it is first opened. At least one transaction must be written to it first.</source>
          <target state="translated">自从当前的wal文件在磁盘上创建以来,必须有一个或多个事务被写入该文件(通过任何连接)。这意味着不能在第一次打开没有wal文件的wal模式数据库后立即进行快照。必须先向它写入至少一个事务。</target>
        </trans-unit>
        <trans-unit id="b839504f0d97f30339eb42940d7178a50aed3e9b" translate="yes" xml:space="preserve">
          <source>One solution is to add an SQL foreign key constraint to the database schema to enforce the relationship between the</source>
          <target state="translated">一种解决方案是在数据库模式中添加一个SQL外键约束,以强制执行与</target>
        </trans-unit>
        <trans-unit id="9e9e9e6d05419e1f1b802f612d5f17adfe32fb1a" translate="yes" xml:space="preserve">
          <source>One solution to this problem is to change SQLite to do an exhaustive search for the best path. But an exhaustive search requires time proportional to K! (where K is the number of tables in the join) and so when you get beyond a 10-way join, the time to run &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; becomes very large.</source>
          <target state="translated">解决此问题的一种方法是更改​​SQLite，以详尽搜索最佳路径。但是穷举搜索需要与K成正比的时间！（其中K是联接中的表数），因此当您超出10路&lt;a href=&quot;c3ref/prepare&quot;&gt;联接&lt;/a&gt;时，运行sqlite3_prepare（）的时间将变得非常大。</target>
        </trans-unit>
        <trans-unit id="3ea27e906845c470414940dc542a3a724c62dba9" translate="yes" xml:space="preserve">
          <source>One technique for avoiding a full table scan is to do lookups by rowid (or by the equivalent &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;). To lookup the price of peaches, one would query for the entry with a rowid of 4:</source>
          <target state="translated">避免全表扫描的一种技术是按rowid（或等效的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;）进行查找。要查询桃子的价格，可以查询rowid为4的条目：</target>
        </trans-unit>
        <trans-unit id="9d59b48161b2263d40d4491d1bb939a7b7f92e6e" translate="yes" xml:space="preserve">
          <source>One user of both Git and Fossil &lt;a href=&quot;https://news.ycombinator.com/item?id=16806955&quot;&gt;writes in HN&lt;/a&gt;:</source>
          <target state="translated">Git和Fossil的一个用户都&lt;a href=&quot;https://news.ycombinator.com/item?id=16806955&quot;&gt;在HN中写道&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="75f64ba853c8246c4f074dd74725d9448e0221f8" translate="yes" xml:space="preserve">
          <source>One verification technique used on SQLite is to run an entire test suite twice, once with optimizations left on and a second time with optimizations turned off, and verify that the same output is obtained both times. This shows that the optimizations do not introduce errors.</source>
          <target state="translated">在SQLite上使用的一种验证技术是,将整个测试套件运行两次,一次是在优化保持开启的情况下,第二次是在优化关闭的情况下,验证两次得到的输出是否相同。这表明优化不会引入错误。</target>
        </trans-unit>
        <trans-unit id="1193850e31c2f1f6fdd8ba5f6d6a21ba1025f991" translate="yes" xml:space="preserve">
          <source>One very simple scheme might be to count the number of instances of the users search terms in each result document. Those documents that contain many instances of the terms are considered more relevant than those with a small number of instances of each term. In an FTS application, the number of term instances in each result could be determined by counting the number of integers in the return value of the &lt;a href=&quot;fts3#offsets&quot;&gt;offsets&lt;/a&gt; function. The following example shows a query that could be used to obtain the ten most relevant results for a query entered by the user:</source>
          <target state="translated">一种非常简单的方案可能是计算每个结果文档中用户搜索词的实例数。那些包含多个术语实例的文档被认为比每个术语具有少量实例的文档更相关。在FTS应用程序中，可以通过对&lt;a href=&quot;fts3#offsets&quot;&gt;offsets&lt;/a&gt;函数的返回值中的整数进行计数来确定每个结果中的术语实例数。以下示例显示了一个查询，该查询可用于获取用户输入的查询的十个最相关的结果：</target>
        </trans-unit>
        <trans-unit id="ef8241368a545dcfd4804f314c3279bd316a6040" translate="yes" xml:space="preserve">
          <source>One way around this problem is to check the extended error code returned by an sqlite3_step() call. If there is a blocking connection, then the extended error code is set to SQLITE_LOCKED_SHAREDCACHE. Otherwise, in the special &quot;DROP TABLE/INDEX&quot; case, the extended error code is just SQLITE_LOCKED.</source>
          <target state="translated">解决这个问题的一个方法是检查 sqlite3_step()调用返回的扩展错误代码。如果存在阻塞连接,那么扩展错误代码就被设置为SQLITE_LOCKED_SHAREDCACHE。否则,在特殊的 &quot;DROP TABLE/INDEX &quot;情况下,扩展错误代码只是SQLITE_LOCKED。</target>
        </trans-unit>
        <trans-unit id="acee115381c0c09c4f7ee9640610c7e8117858b5" translate="yes" xml:space="preserve">
          <source>One way to compute FindFrame(P,M) would be to scan the aPgno array starting with the M-th entry and working backwards towards the beginning and return J where aPgno[J]==P. Such an algorithm would work, and it would be faster than searching the whole WAL file for the latest frame with page number P. But the search can be made much faster still by using the aHash structure.</source>
          <target state="translated">计算FindFrame(P,M)的一种方法是扫描aPgno数组,从第M个条目开始,向后退,返回J,其中aPgno[J]==P。这样的算法是可行的,而且比搜索整个WAL文件中最新的页数P的帧要快得多。</target>
        </trans-unit>
        <trans-unit id="43ce70174605b98e2611ee3fa62c55d5c3b3d847" translate="yes" xml:space="preserve">
          <source>One way to create an imposter table is to directly edit the sqlite_master table to insert a new row that describes the table. For example, suppose the schema is like this:</source>
          <target state="translated">创建冒牌表的一种方法是直接编辑sqlite_master表,插入一条新的描述表的记录。例如,假设模式是这样的。</target>
        </trans-unit>
        <trans-unit id="84cd9c4bdeae83b60aa9ede1d4ab69d156255724" translate="yes" xml:space="preserve">
          <source>One way to create an imposter table is to directly edit the sqlite_schema table to insert a new row that describes the table. For example, suppose the schema is like this:</source>
          <target state="translated">创建冒牌表的一种方法是直接编辑sqlite_schema表,插入一条新的描述表的记录。例如,假设模式是这样的。</target>
        </trans-unit>
        <trans-unit id="5371a62fb713016b88bf9cbe1ee3e53f088627a9" translate="yes" xml:space="preserve">
          <source>One way to use sqlite3 in a shell script is to use &quot;echo&quot; or &quot;cat&quot; to generate a sequence of commands in a file, then invoke sqlite3 while redirecting input from the generated command file. This works fine and is appropriate in many circumstances. But as an added convenience, sqlite3 allows a single SQL command to be entered on the command line as a second argument after the database name. When the sqlite3 program is launched with two arguments, the second argument is passed to the SQLite library for processing, the query results are printed on standard output in list mode, and the program exits. This mechanism is designed to make sqlite3 easy to use in conjunction with programs like &quot;awk&quot;. For example:</source>
          <target state="translated">在shell脚本中使用sqlite3的一种方法是使用 &quot;echo &quot;或 &quot;cat &quot;在一个文件中生成一个命令序列,然后调用sqlite3,同时从生成的命令文件中重定向输入。这样做很好,在很多情况下都是合适的。但是作为一种额外的方便,sqlite3允许在命令行中输入一条SQL命令作为数据库名称后的第二个参数。当sqlite3程序以两个参数启动时,第二个参数被传给SQLite库进行处理,查询结果以列表模式打印在标准输出上,然后程序退出。这种机制的设计是为了使sqlite3与 &quot;awk &quot;等程序结合使用,非常方便。例如</target>
        </trans-unit>
        <trans-unit id="c9f164cc934fc44dc3087a408a43d581d45a004f" translate="yes" xml:space="preserve">
          <source>One would get the same answer without the use of the R*Tree index using the following simpler query:</source>
          <target state="translated">如果不使用R*Tree索引,使用以下更简单的查询也能得到同样的答案。</target>
        </trans-unit>
        <trans-unit id="17f5a4fe2f5c62ecd81776d246b8c0c725190c25" translate="yes" xml:space="preserve">
          <source>One-Step Query Execution Interface</source>
          <target state="translated">一步式查询执行界面</target>
        </trans-unit>
        <trans-unit id="aa3d3adac784c0d74a31276058a965e9e8ca9895" translate="yes" xml:space="preserve">
          <source>Online Backup API</source>
          <target state="translated">在线备份API</target>
        </trans-unit>
        <trans-unit id="84ecd14ddbadabe468f63832d803f2392f405f33" translate="yes" xml:space="preserve">
          <source>Online Backup API.</source>
          <target state="translated">在线备份API。</target>
        </trans-unit>
        <trans-unit id="df4435ab96f572a5ddc0d0575dab3a2326c426c1" translate="yes" xml:space="preserve">
          <source>Online Backup Object</source>
          <target state="translated">在线备份对象</target>
        </trans-unit>
        <trans-unit id="cf333df0d0137378797eeac3fd91be937936f09b" translate="yes" xml:space="preserve">
          <source>Only CPU cycle counts are being measured here. CPU cycle counts are a good proxy for energy consumption, but do not necessary correlate well with real-world timings. Time spent doing I/O is not reflected in the CPU cycle counts, and I/O time predominates in many SQLite usage scenarios.</source>
          <target state="translated">这里只测量CPU周期数。CPU周期数是能源消耗的良好代表,但并不一定与现实世界的时间有很好的相关性。做I/O的时间并没有反映在CPU周期数中,而I/O时间在许多SQLite使用场景中占主导地位。</target>
        </trans-unit>
        <trans-unit id="d5604491374c9f17a80675ca75c6861a336b77e6" translate="yes" xml:space="preserve">
          <source>Only a single authorizer can be in place on a database connection at a time. Each call to sqlite3_set_authorizer overrides the previous call. Disable the authorizer by installing a NULL callback. The authorizer is disabled by default.</source>
          <target state="translated">一个数据库连接上一次只能有一个授权者。每次调用sqlite3_set_authorizer都会覆盖之前的调用。通过安装一个NULL回调来禁用授权器。默认情况下,授权器是被禁用的。</target>
        </trans-unit>
        <trans-unit id="478d5d49691bd8c6240a1fe276d18045c9e67957" translate="yes" xml:space="preserve">
          <source>Only a single progress handler may be defined at one time per &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;; setting a new progress handler cancels the old one. Setting parameter X to NULL disables the progress handler. The progress handler is also disabled by setting N to a value less than 1.</source>
          <target state="translated">每个&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;一次只能定义一个进度处理程序；设置新的进度处理程序将取消旧的进度处理程序。将参数X设置为NULL将禁用进度处理程序。通过将N设置为小于1的值，也会禁用进度处理程序。</target>
        </trans-unit>
        <trans-unit id="94e56a9c57047e711c69e819b360a3dd7e101263" translate="yes" xml:space="preserve">
          <source>Only a single progress handler may be defined at one time per &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;; setting a new progress handler cancels the old one. Setting parameter X to NULL disables the progress handler. The progress handler is also disabled by setting N to a value less than 1.</source>
          <target state="translated">每个&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;一次只能定义一个进度处理程序；设置新的进度处理程序将取消旧的进度处理程序。将参数X设置为NULL将禁用进度处理程序。通过将N设置为小于1的值，也会禁用进度处理程序。</target>
        </trans-unit>
        <trans-unit id="7036e4ebe3282d4cd750dee2b265f33019cf27cb" translate="yes" xml:space="preserve">
          <source>Only changes made directly by the INSERT, UPDATE or DELETE statement are considered - auxiliary changes caused by &lt;a href=&quot;../lang_createtrigger&quot;&gt;triggers&lt;/a&gt;, &lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; or &lt;a href=&quot;../lang_replace&quot;&gt;REPLACE&lt;/a&gt; constraint resolution are not counted.</source>
          <target state="translated">仅考虑由INSERT，UPDATE或DELETE语句直接进行的更改- 不计算由&lt;a href=&quot;../lang_createtrigger&quot;&gt;触发器&lt;/a&gt;，&lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;外键操作&lt;/a&gt;或&lt;a href=&quot;../lang_replace&quot;&gt;REPLACE&lt;/a&gt;约束解析引起的辅助更改。</target>
        </trans-unit>
        <trans-unit id="c27ab9dbf00600e9d93b4dae249b72bd85740109" translate="yes" xml:space="preserve">
          <source>Only changes made directly by the INSERT, UPDATE or DELETE statement are considered - auxiliary changes caused by &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt;, &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; or &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; constraint resolution are not counted.</source>
          <target state="translated">仅考虑由INSERT，UPDATE或DELETE语句直接进行的更改- 不计算由&lt;a href=&quot;lang_createtrigger&quot;&gt;触发器&lt;/a&gt;，&lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;外键操作&lt;/a&gt;或&lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt;约束解析引起的辅助更改。</target>
        </trans-unit>
        <trans-unit id="9ca2d95ecc0496343a0233bd681510ca318c6946" translate="yes" xml:space="preserve">
          <source>Only columns a and b of the index would be usable. The d column would not be usable because column c is not constrained and there can be no gaps in the set of columns that usable by the index.</source>
          <target state="translated">只有索引的a列和b列是可用的。d列不能用,因为c列没有约束,而且在索引可用的列集中不能有空隙。</target>
        </trans-unit>
        <trans-unit id="05736f4fee6c4c67dfd5428743f05e710b55053c" translate="yes" xml:space="preserve">
          <source>Only columns a, b, and c of the index would be usable. The d column would not be usable because it occurs to the right of c and c is constrained only by inequalities.</source>
          <target state="translated">只有索引的a、b和c列是可用的。d列不能用,因为它出现在c的右边,而c只受不等式的限制。</target>
        </trans-unit>
        <trans-unit id="6822d83fba844c52182b6e2b1305124432ab29b8" translate="yes" xml:space="preserve">
          <source>Only create &lt;a href=&quot;tempfiles#masterjrnl&quot;&gt;master journal&lt;/a&gt; files if two or more attached databases are all modified, do not have &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF, and do not have the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; set to OFF, MEMORY, or WAL.</source>
          <target state="translated">仅当两个或多个附加数据库都被修改，没有将&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt;设置为OFF，也没有将&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt;设置为OFF，MEMORY或WAL时，才创建&lt;a href=&quot;tempfiles#masterjrnl&quot;&gt;主日记&lt;/a&gt;文件。</target>
        </trans-unit>
        <trans-unit id="9d1635246b5aeaad6de58e92e5095276c845c10a" translate="yes" xml:space="preserve">
          <source>Only create &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;statement journal&lt;/a&gt; files when their size exceeds a threshold. Otherwise the journal is held in memory and no I/O occurs. The threshold can be configured at compile-time using &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; or at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt;).</source>
          <target state="translated">仅在其大小超过阈值时创建&lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;语句日记&lt;/a&gt;文件。否则，日记将保留在内存中，并且不会发生I / O。可在编译时使用&lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt;或在启动时使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt;）配置阈值。</target>
        </trans-unit>
        <trans-unit id="55a00a3777e2ad8aeddbe2020e521d24210ef62b" translate="yes" xml:space="preserve">
          <source>Only create &lt;a href=&quot;tempfiles#superjrnl&quot;&gt;master journal&lt;/a&gt; files if two or more attached databases are all modified, do not have &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF, and do not have the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; set to OFF, MEMORY, or WAL.</source>
          <target state="translated">仅当两个或多个附加数据库都被修改，&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt;设置为OFF且&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt;设置为OFF，MEMORY或WAL时，才创建&lt;a href=&quot;tempfiles#superjrnl&quot;&gt;主日记&lt;/a&gt;文件。</target>
        </trans-unit>
        <trans-unit id="04951ae9e91c50e633618b0424f4870112bf6e2c" translate="yes" xml:space="preserve">
          <source>Only create master journal files if two or more attached databases are all modified, do not have &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF, and do not have the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; set to OFF, MEMORY, or WAL.</source>
          <target state="translated">仅当两个或多个附加数据库都被修改，&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt;设置为OFF且&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt;设置为OFF，MEMORY或WAL时，才创建主日记文件。</target>
        </trans-unit>
        <trans-unit id="610003d6616c61d3e569880b1cf6337a8bfaac43" translate="yes" xml:space="preserve">
          <source>Only rows of the table for which the WHERE clause evaluates to true are included in the index. If the WHERE clause expression evaluates to NULL or to false for some rows of the table, then those rows are omitted from the index.</source>
          <target state="translated">只有WHERE子句评价为true的表的行才会被包含在索引中。如果表的某些行的WHERE子句表达式评价为NULL或false,那么这些行将从索引中被省略。</target>
        </trans-unit>
        <trans-unit id="255e530c466468dcdf3e2dbc7217cf60c632c517" translate="yes" xml:space="preserve">
          <source>Only terms of the vocabulary with a matching langid are searched. Hence, the same table can contain entries from multiple languages and only the requested language will be used. The default langid is 0.</source>
          <target state="translated">只搜索词汇中具有匹配 langid 的词汇。因此,同一个表可以包含多种语言的词条,并且只使用所要求的语言。默认的langid为0。</target>
        </trans-unit>
        <trans-unit id="2ece13f71abf0bca8da38ece8f95957b023f2f28" translate="yes" xml:space="preserve">
          <source>Only the &quot;ll&quot; length modifier ever makes a difference for SQLite. And it only makes a difference when using the C-language interfaces.</source>
          <target state="translated">只有 &quot;ll &quot;长度修饰符对SQLite有影响。而且只有在使用C语言接口的时候才会有所区别。</target>
        </trans-unit>
        <trans-unit id="85148a6237828ed28c44695045ab73ff06e6fcad" translate="yes" xml:space="preserve">
          <source>Only the RENAME TABLE, ADD COLUMN, and RENAME COLUMN variants of the ALTER TABLE command are supported. Other kinds of ALTER TABLE operations such as DROP COLUMN, ALTER COLUMN, ADD CONSTRAINT, and so forth are omitted.</source>
          <target state="translated">只支持ALTER TABLE命令的RENAME TABLE、ADD COLUMN和RENAME COLUMN变体。其他类型的ALTER TABLE操作,如DROP COLUMN、ALTER COLUMN、ADD CONSTRAINT等都被省略。</target>
        </trans-unit>
        <trans-unit id="718ea1282b5847e8c3e9e8f8d5345c6ee50c38cc" translate="yes" xml:space="preserve">
          <source>Only the implicit version of the AND operator is supported. Specifying the string &quot;AND&quot; as part of a standard query syntax query is interpreted as a term query for the set of documents containing the term &quot;and&quot;.</source>
          <target state="translated">仅支持隐式版本的AND运算符。指定字符串 &quot;AND &quot;作为标准查询语法查询的一部分,会被解释为对包含术语 &quot;and &quot;的文档集的术语查询。</target>
        </trans-unit>
        <trans-unit id="1eda18e73564838ddd329dd3f15abb7d2f114fbe" translate="yes" xml:space="preserve">
          <source>Only the three core routines described in section 1.0 are required to use SQLite. But there are many other functions that provide useful interfaces. These extended routines are as follows:</source>
          <target state="translated">使用SQLite只需要1.0节中描述的三个核心例程。但还有许多其他函数提供了有用的接口。这些扩展例程如下。</target>
        </trans-unit>
        <trans-unit id="97073c710caef6e8b97ed50f7242027a83850af5" translate="yes" xml:space="preserve">
          <source>Only unsigned integers are recognized. Plus and minus signs are ignored. Decimal points and exponential notation are ignored.</source>
          <target state="translated">只识别无符号整数。忽略加号和减号。忽略小数点和指数符号。</target>
        </trans-unit>
        <trans-unit id="9ddd9d23f19b01af8d3915a7bfd11c89aef2d1d4" translate="yes" xml:space="preserve">
          <source>Only use indexes-on-expressions to optimize ORDER BY or GROUP BY if the COLLATE is correct. Ticket &lt;a href=&quot;https://sqlite.org/src/info/e20dd54ab0e4383&quot;&gt;e20dd54ab0e4383&lt;/a&gt;</source>
          <target state="translated">如果COLLATE正确，则仅使用基于表达式的索引来优化ORDER BY或GROUP BY。门票&lt;a href=&quot;https://sqlite.org/src/info/e20dd54ab0e4383&quot;&gt;e20dd54ab0e4383&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c74dd7ced7cd4ea8002b3c96a9b1ecdff66b1e59" translate="yes" xml:space="preserve">
          <source>Opcode Name</source>
          <target state="translated">操作码名称</target>
        </trans-unit>
        <trans-unit id="1682c59856887894432baf4bb39e98c21d42d731" translate="yes" xml:space="preserve">
          <source>Opcode definitions</source>
          <target state="translated">操作码定义</target>
        </trans-unit>
        <trans-unit id="313411b9bd1b97b8fcd666d91d350cb8e6bed0d1" translate="yes" xml:space="preserve">
          <source>Open A BLOB For Incremental I/O</source>
          <target state="translated">打开一个增量I/O的BLOB。</target>
        </trans-unit>
        <trans-unit id="beb2e15e058a69d62502daa1bdfb1095abeb86de" translate="yes" xml:space="preserve">
          <source>Open a cursor into the table to be queried.</source>
          <target state="translated">打开光标进入要查询的表。</target>
        </trans-unit>
        <trans-unit id="7e8e851c144078264ee423ec854e116a3d7fdff4" translate="yes" xml:space="preserve">
          <source>Open a new cursor P1 that points to the same ephemeral table as cursor P2. The P2 cursor must have been opened by a prior &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt; opcode. Only ephemeral cursors may be duplicated.</source>
          <target state="translated">打开一个新的光标P1，它指向与光标P2相同的临时表。P2游标必须已由先前的&lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt;操作码打开。仅临时光标可以重复。</target>
        </trans-unit>
        <trans-unit id="57454cf77dc40f8ad1e1086dd9c199e6c88ed771" translate="yes" xml:space="preserve">
          <source>Open a new cursor P1 to a transient table. The cursor is always opened read/write even if the main database is read-only. The ephemeral table is deleted automatically when the cursor is closed.</source>
          <target state="translated">打开一个新游标P1到瞬时表。即使主数据库是只读,游标也总是被打开读/写。当游标关闭时,暂存表会被自动删除。</target>
        </trans-unit>
        <trans-unit id="545bc19bf66be6511144aed187f1840c5a4278d1" translate="yes" xml:space="preserve">
          <source>Open a new cursor that points to a fake table that contains a single row of data. The content of that one row is the content of memory register P2. In other words, cursor P1 becomes an alias for the MEM_Blob content contained in register P2.</source>
          <target state="translated">打开一个新的游标,该游标指向一个假表,该表中包含了一行数据。这一行的内容就是内存寄存器P2的内容。换句话说,游标P1成为寄存器P2中包含的MEM_Blob内容的别名。</target>
        </trans-unit>
        <trans-unit id="135ddb8c48350a0a78c4aa223b6b8ae16522c7fd" translate="yes" xml:space="preserve">
          <source>Open a read-only cursor for the database table whose root page is P2 in a database file. The database file is determined by P3. P3==0 means the main database, P3==1 means the database used for temporary tables, and P3&amp;gt;1 means used the corresponding attached database. Give the new cursor an identifier of P1. The P1 values need not be contiguous but all P1 values should be small integers. It is an error for P1 to be negative.</source>
          <target state="translated">在数据库文件中为根表为P2的数据库表打开一个只读游标。数据库文件由P3确定。P3 == 0表示主数据库，P3 == 1表示用于临时表的数据库，P3&amp;gt; 1表示使用相应的附加数据库。给新光标一个标识符P1。P1值不必是连续的，但所有P1值都应该是小整数。P1为负是错误的。</target>
        </trans-unit>
        <trans-unit id="84089bd01646e44fd57253086466eec04ccae47a" translate="yes" xml:space="preserve">
          <source>Open a read/write cursor named P1 on the table or index whose root page is P2 (or whose root page is held in register P2 if the OPFLAG_P2ISREG bit is set in P5 - see below).</source>
          <target state="translated">在表或索引上打开一个名为P1的读/写游标,该游标的根页是P2(如果在P5中设置了OPFLAG_P2ISREG位,则其根页被保存在寄存器P2中--见下文)。</target>
        </trans-unit>
        <trans-unit id="4063448157b3ab2686e1495793b9571ba748ea89" translate="yes" xml:space="preserve">
          <source>Open an RBU handle using the sqlite3rbu_open(T,A,S) function.</source>
          <target state="translated">使用 sqlite3rbu_open(T,A,S)函数打开一个 RBU 句柄。</target>
        </trans-unit>
        <trans-unit id="596a83fa51ee88b7bacaba491d0bd9269153f384" translate="yes" xml:space="preserve">
          <source>Open database connections using the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interfaces, as normal. Ordinary database files (without a checksum) will operate normally. Databases with checksums will return an SQLITE_IOERR_DATA error if a page is encountered that contains an invalid checksum.</source>
          <target state="translated">照常使用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;或&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;接口打开数据库连接。普通数据库文件（无校验和）将正常运行。如果遇到包含无效校验和的页面，则具有校验和的数据库将返回SQLITE_IOERR_DATA错误。</target>
        </trans-unit>
        <trans-unit id="6423cf77a906b294f7ccb82649c19b9b21d337a4" translate="yes" xml:space="preserve">
          <source>Open file &quot;/home/fred/data.db&quot;. Use the special VFS &quot;unix-dotfile&quot; that uses dot-files in place of posix advisory locking.</source>
          <target state="translated">打开文件&quot;/home/fred/data.db&quot;。使用特殊的VFS &quot;unix-dotfile&quot;,它使用点文件来代替posix咨询锁定。</target>
        </trans-unit>
        <trans-unit id="d23dfc68fcbe2b64c96946a59f2391f88d879ada" translate="yes" xml:space="preserve">
          <source>Open file &quot;data.db&quot; in the current directory for read-only access. Regardless of whether or not shared-cache mode is enabled by default, use a private cache.</source>
          <target state="translated">打开当前目录下的文件 &quot;data.db &quot;进行只读访问。无论默认情况下是否启用共享缓存模式,都要使用私有缓存。</target>
        </trans-unit>
        <trans-unit id="32023375b26a0776fe1660f78af585c47d78b01e" translate="yes" xml:space="preserve">
          <source>Open the database file &quot;/home/fred/data.db&quot;.</source>
          <target state="translated">打开数据库文件&quot;/home/fred/data.db&quot;。</target>
        </trans-unit>
        <trans-unit id="b140126e4bb0c579baba79fa4b78910264cad628" translate="yes" xml:space="preserve">
          <source>Open the database file and obtain a SHARED lock. If the SHARED lock cannot be obtained, fail immediately and return SQLITE_BUSY.</source>
          <target state="translated">打开数据库文件,获取一个SHARED锁。如果不能获得SHARED锁,则立即失败并返回SQLITE_BUSY。</target>
        </trans-unit>
        <trans-unit id="1fdbee3b0460b37f393d93c476774730b651cdaf" translate="yes" xml:space="preserve">
          <source>Open the file &quot;data.db&quot; in the current directory.</source>
          <target state="translated">打开当前目录下的文件 &quot;data.db&quot;。</target>
        </trans-unit>
        <trans-unit id="e305cdc0a6e58d2992d00df36114935a966f06eb" translate="yes" xml:space="preserve">
          <source>Open two cursors, one to each of the two tables being queried.</source>
          <target state="translated">打开两个游标,分别指向被查询的两个表。</target>
        </trans-unit>
        <trans-unit id="db8828ea77768020acda7b34e1bdcfb01f4a650b" translate="yes" xml:space="preserve">
          <source>Open, release or rollback the savepoint named by parameter P4, depending on the value of P1. To open a new savepoint set P1==0 (SAVEPOINT_BEGIN). To release (commit) an existing savepoint set P1==1 (SAVEPOINT_RELEASE). To rollback an existing savepoint set P1==2 (SAVEPOINT_ROLLBACK).</source>
          <target state="translated">根据P1的值,打开、释放或回滚由参数P4命名的保存点。要打开一个新的保存点,设置P1==0 (SAVEPOINT_BEGIN)。要释放(提交)一个现有的保存点,设置 P1==1 (SAVEPOINT_RELEASE)。要回滚现有的保存点,设置 P1==2 (SAVEPOINT_ROLLBACK)。</target>
        </trans-unit>
        <trans-unit id="e54c6e14fb4a075fa699ffdaaaf395ff313982e8" translate="yes" xml:space="preserve">
          <source>OpenAutoindex</source>
          <target state="translated">OpenAutoindex</target>
        </trans-unit>
        <trans-unit id="4102c59c0ab3f6e830e46718de359a59f628ee07" translate="yes" xml:space="preserve">
          <source>OpenDup</source>
          <target state="translated">OpenDup</target>
        </trans-unit>
        <trans-unit id="ad5bdfbe38582d74f4e2d987d0014c4a061fc0bc" translate="yes" xml:space="preserve">
          <source>OpenEphemeral</source>
          <target state="translated">OpenEphemeral</target>
        </trans-unit>
        <trans-unit id="4a5d4d0e6cf7c26b571b8ed8b7d9e91f5a55707c" translate="yes" xml:space="preserve">
          <source>OpenPseudo</source>
          <target state="translated">OpenPseudo</target>
        </trans-unit>
        <trans-unit id="321f145cb1e3470cc293ca452256220e4b476cbf" translate="yes" xml:space="preserve">
          <source>OpenRead</source>
          <target state="translated">OpenRead</target>
        </trans-unit>
        <trans-unit id="3894e594709a936290c9439b10b580db3b56e3b5" translate="yes" xml:space="preserve">
          <source>OpenWrite</source>
          <target state="translated">OpenWrite</target>
        </trans-unit>
        <trans-unit id="10f17177db5db183ce11fbbf98483043f8f93d13" translate="yes" xml:space="preserve">
          <source>Openclose callback</source>
          <target state="translated">开闭回调</target>
        </trans-unit>
        <trans-unit id="f1ba5b2c8dba45952ee1dd4e3e5587becf1e4832" translate="yes" xml:space="preserve">
          <source>Opening A New Database Connection</source>
          <target state="translated">打开一个新的数据库连接</target>
        </trans-unit>
        <trans-unit id="8bea067fa84f98eb8cb08b76d377cd2759d84a48" translate="yes" xml:space="preserve">
          <source>Opening a New Connection</source>
          <target state="translated">打开一个新的连接</target>
        </trans-unit>
        <trans-unit id="0fcdc2f790b5b05c0b11e1b00c614a1147af7a65" translate="yes" xml:space="preserve">
          <source>Opening a Read-Only Transaction</source>
          <target state="translated">打开一个只读交易</target>
        </trans-unit>
        <trans-unit id="8c328ea219e123938753dd011cc218695e36770e" translate="yes" xml:space="preserve">
          <source>Opening a connection.</source>
          <target state="translated">打开一个连接。</target>
        </trans-unit>
        <trans-unit id="0a848c1fa6f5b691a8b43871dbf9920b32a63f8f" translate="yes" xml:space="preserve">
          <source>Opening a new database connection is a two-step process:</source>
          <target state="translated">打开一个新的数据库连接是一个两步走的过程。</target>
        </trans-unit>
        <trans-unit id="60a2e026abe5554a6164ccf369d3bdb712d462a6" translate="yes" xml:space="preserve">
          <source>Opening a read-only transaction.</source>
          <target state="translated">开启一个只读交易。</target>
        </trans-unit>
        <trans-unit id="d0a97ec8f1b3b761b48ba3f0b5793b7b063cf28e" translate="yes" xml:space="preserve">
          <source>Opening a read-write transaction.</source>
          <target state="translated">开启读写交易。</target>
        </trans-unit>
        <trans-unit id="5bef4a855a587c7ae88d0d6e7fbc4f0cf1d92d9c" translate="yes" xml:space="preserve">
          <source>Opening a statement transaction.</source>
          <target state="translated">开立报表交易。</target>
        </trans-unit>
        <trans-unit id="5f6fc2590106eab5d853e4838b574315ff3651ac" translate="yes" xml:space="preserve">
          <source>Operand P1 must be 0x7fffffff and P2 must positive.</source>
          <target state="translated">操作数P1必须是0x7fffffff,P2必须是正数。</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="653e79b2411d60c991c837c40648dc99da326979" translate="yes" xml:space="preserve">
          <source>Optimization: When doing an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; on a table with &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, do not update the expression indexes if they do not refer to any of the columns of the table being updated.</source>
          <target state="translated">优化：在具有&lt;a href=&quot;expridx&quot;&gt;表达式索引&lt;/a&gt;的表上执行&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;时，如果表达式索引未引用要更新的表的任何列，则不要更新表达式索引。</target>
        </trans-unit>
        <trans-unit id="a794f9704b3031ad0771d79793775c086e03f157" translate="yes" xml:space="preserve">
          <source>Optimizations to the sqlite_mprintf() routine.</source>
          <target state="translated">对sqlite_mprintf()例程进行优化。</target>
        </trans-unit>
        <trans-unit id="088089a3961fc329e20285999528f0da0604b13a" translate="yes" xml:space="preserve">
          <source>Optimize the &lt;a href=&quot;lang_corefunc#typeof&quot;&gt;typeof()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#length&quot;&gt;length()&lt;/a&gt; SQL functions so that they avoid unnecessary reading of database content from disk.</source>
          <target state="translated">优化&lt;a href=&quot;lang_corefunc#typeof&quot;&gt;typeof（）&lt;/a&gt;和&lt;a href=&quot;lang_corefunc#length&quot;&gt;length（）&lt;/a&gt; SQL函数，以便避免不必要地从磁盘读取数据库内容。</target>
        </trans-unit>
        <trans-unit id="89ea4f0e94546aba0e6576de32f5af050f08375b" translate="yes" xml:space="preserve">
          <source>Optimizer does a better job of using indices to satisfy ORDER BY clauses that sort on the integer primary key</source>
          <target state="translated">优化器在使用指数来满足ORDER BY子句,对整数主键进行排序方面做得比较好。</target>
        </trans-unit>
        <trans-unit id="d859dd72c637fafc6319ca0f4f6cb8c1fd01736f" translate="yes" xml:space="preserve">
          <source>Optimizer enhancement: &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; are automatically re-compiled when a binding on the RHS of a LIKE operator changes or when any range constraint changes under &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;.</source>
          <target state="translated">优化程序的增强：当LIKE运算符的RHS上的绑定发生更改或&lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;下的任何范围约束发生更改时，&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;将自动重新编译。</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="6120d3ea8f989e319fa4157b88a6894abd99ea8b" translate="yes" xml:space="preserve">
          <source>Option 1:</source>
          <target state="translated">选择1:</target>
        </trans-unit>
        <trans-unit id="787636b9cef675727f97423a49f2d6e8aeb5b354" translate="yes" xml:space="preserve">
          <source>Option 2:</source>
          <target state="translated">备选方案2:</target>
        </trans-unit>
        <trans-unit id="620a38bc45cce1e89bad8abed95cee233ec74ca8" translate="yes" xml:space="preserve">
          <source>Optional LIMIT and ORDER BY Clauses</source>
          <target state="translated">可选的限制和排序条款</target>
        </trans-unit>
        <trans-unit id="4a8101f15dc88fa6899984a679049286645dada8" translate="yes" xml:space="preserve">
          <source>Optional LIMIT and ORDER BY clauses</source>
          <target state="translated">可选LIMIT和ORDER BY条款</target>
        </trans-unit>
        <trans-unit id="147fccad2acf5d54cf4c9bd90959d2b685bb12a8" translate="yes" xml:space="preserve">
          <source>Optional READ UNCOMMITTED isolation (instead of the default isolation level of SERIALIZABLE) and table level locking when database connections share a common cache.</source>
          <target state="translated">当数据库连接共享一个公共缓存时,可选择READ UNCOMMITTED隔离(而不是默认的SERIALIZABLE隔离级别)和表级锁定。</target>
        </trans-unit>
        <trans-unit id="99e39e3c25d749e303cfb0392ac6108be81a9ed0" translate="yes" xml:space="preserve">
          <source>Optionally, a &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt; constraint.</source>
          <target state="translated">（可选）&lt;a href=&quot;gencol&quot;&gt;生成的列&lt;/a&gt;约束。</target>
        </trans-unit>
        <trans-unit id="f3c4d258c19e0b0e32f1a0047f810a58bf67a8d7" translate="yes" xml:space="preserve">
          <source>Optionally, a PRIMARY KEY for the table. Both single column and composite (multiple column) primary keys are supported.</source>
          <target state="translated">可选地,表的主键。同时支持单列和复合(多列)主键。</target>
        </trans-unit>
        <trans-unit id="afb65b09ecb1abf655b3870806d0d663e9055759" translate="yes" xml:space="preserve">
          <source>Options understood by the &lt;b&gt;sqlite3&lt;/b&gt; command include:</source>
          <target state="translated">&lt;b&gt;sqlite3&lt;/b&gt;命令可理解的选项包括：</target>
        </trans-unit>
        <trans-unit id="e72184f55cc026514b7160d78c3c5aef63c2a050" translate="yes" xml:space="preserve">
          <source>Or</source>
          <target state="translated">Or</target>
        </trans-unit>
        <trans-unit id="1a5a89789f35d1adc160640f07b04eccb062e675" translate="yes" xml:space="preserve">
          <source>Or consider these identical queries:</source>
          <target state="translated">或者考虑这些相同的查询。</target>
        </trans-unit>
        <trans-unit id="16127303ea06cc226e15f6d081becfc0853f54f2" translate="yes" xml:space="preserve">
          <source>Or go the other way:</source>
          <target state="translated">或者走另一条路。</target>
        </trans-unit>
        <trans-unit id="aa8e4bd6460fbb4edd20d4ab7cc84cb756c25fa7" translate="yes" xml:space="preserve">
          <source>Or on Windows with MSVC:</source>
          <target state="translated">或者在Windows上使用MSVC。</target>
        </trans-unit>
        <trans-unit id="65cc0e4d32009c846d3d67b851864fc0e2100eac" translate="yes" xml:space="preserve">
          <source>Or optimization</source>
          <target state="translated">或优化</target>
        </trans-unit>
        <trans-unit id="fbfd8b5435e1bb1225c27564f4e61467d6052b3a" translate="yes" xml:space="preserve">
          <source>Or perhaps the application would rather use the most recent checkinTime:</source>
          <target state="translated">或者,也许应用程序更愿意使用最近的checkinTime。</target>
        </trans-unit>
        <trans-unit id="2a55f1def49ba2cf28edd04aebe0ae914d6adc01" translate="yes" xml:space="preserve">
          <source>Or this:</source>
          <target state="translated">或者这个。</target>
        </trans-unit>
        <trans-unit id="4adffe1f4f67467b27dd86bae1fcc140644a1e80" translate="yes" xml:space="preserve">
          <source>Or to be extra safe with a database and to force SQLite to assume the database lacks powersafe overwrite, open it using</source>
          <target state="translated">或者为了更加安全地使用数据库,并迫使SQLite认为数据库缺乏权力安全覆盖,使用</target>
        </trans-unit>
        <trans-unit id="cb4a4efee56406c1c1e484f479dafaa1ce0d3fdd" translate="yes" xml:space="preserve">
          <source>Or using &lt;a href=&quot;cli#fileio&quot;&gt;file I/O functions&lt;/a&gt;, you can extract elements of the ZIP archive:</source>
          <target state="translated">或使用&lt;a href=&quot;cli#fileio&quot;&gt;文件I / O功能&lt;/a&gt;，您可以提取ZIP归档文件的元素：</target>
        </trans-unit>
        <trans-unit id="beb6e4abd1b3ea2eadafe45050288632422b5468" translate="yes" xml:space="preserve">
          <source>Or,</source>
          <target state="translated">Or,</target>
        </trans-unit>
        <trans-unit id="66d567cd524d8ab999d4e199670d77fab66ce1bc" translate="yes" xml:space="preserve">
          <source>Or, from the SQLite shell tool (the &lt;a href=&quot;cli#fileio&quot;&gt;readfile()&lt;/a&gt; function reads the contents of a file from the file-system and returns it as a blob):</source>
          <target state="translated">或者，从SQLite Shell工具（&lt;a href=&quot;cli#fileio&quot;&gt;readfile（）&lt;/a&gt;函数从文件系统读取文件的内容并将其作为Blob返回）：</target>
        </trans-unit>
        <trans-unit id="5555ca89e43c2c41b68ce29dd846f696f04f9021" translate="yes" xml:space="preserve">
          <source>Or, if argument zTab is NULL, then changes are recorded for all tables in the database. If additional tables are added to the database (by executing &quot;CREATE TABLE&quot; statements) after this call is made, changes for the new tables are also recorded.</source>
          <target state="translated">或者,如果参数zTab为NULL,则记录数据库中所有表的变化。如果在这个调用之后,在数据库中增加了额外的表(通过执行 &quot;CREATE TABLE &quot;语句),那么新表的变化也会被记录下来。</target>
        </trans-unit>
        <trans-unit id="0aca97133f8a0b1812de40afe8dc2efdb01e49c8" translate="yes" xml:space="preserve">
          <source>Or, if double-quoted string literals are disabled by default, but need to be selectively enabled for some historical database connections, that can be done using the same C-code as shown above except with the third parameter changed from 0 to 1.</source>
          <target state="translated">或者,如果默认情况下双引号字符串字元是被禁用的,但需要为某些历史数据库连接选择性地启用,可以使用如上图所示的相同的C代码来实现,只是第三个参数从0改为1。</target>
        </trans-unit>
        <trans-unit id="322edc10740abf86eb6c1728491b5451dec39f1d" translate="yes" xml:space="preserve">
          <source>Or, if sqlite3.c is compiled using some other build system, by arranging for the SQLITE_ENABLE_FTS5 pre-processor symbol to be defined.</source>
          <target state="translated">或者,如果 sqlite3.c 是使用其他的编译系统编译的,那么可以安排定义 SQLITE_ENABLE_FTS5 预处理器符号。</target>
        </trans-unit>
        <trans-unit id="658f77f8eef94489e4209dc1e50f66504ceb72eb" translate="yes" xml:space="preserve">
          <source>Or, if the argument attached to the REINDEX identifies a specific database table, then all indices attached to the database table are rebuilt. If it identifies a specific database index, then just that index is recreated.</source>
          <target state="translated">或者,如果REINDEX所附加的参数标识了一个特定的数据库表,那么所有附加在数据库表上的索引都会被重建。如果它标识的是一个特定的数据库索引,那么就只重建该索引。</target>
        </trans-unit>
        <trans-unit id="60a5aae7483ffe81235af01c0cffa5d4ff23cd22" translate="yes" xml:space="preserve">
          <source>Or, if the table is also a &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless table&lt;/a&gt;, then the following apply:</source>
          <target state="translated">或者，如果该表也是一个&lt;a href=&quot;fts5#contentless_tables&quot;&gt;无内容的表&lt;/a&gt;，则适用以下条件：</target>
        </trans-unit>
        <trans-unit id="aa1077574bb502a8689f667cb965b8e30b1c1e85" translate="yes" xml:space="preserve">
          <source>Or, if using the autoconf build system, pass the --enable-session option to the configure script.</source>
          <target state="translated">或者,如果使用autoconf构建系统,将--enable-session选项传递给configure脚本。</target>
        </trans-unit>
        <trans-unit id="0ff802a22b003329b02ab696a2c315faad2a0e85" translate="yes" xml:space="preserve">
          <source>Or, multiple presentations could be stored within the same document.</source>
          <target state="translated">或者,可以在同一文档中存储多个演示文稿。</target>
        </trans-unit>
        <trans-unit id="d354f2e196d0e9cdbbdd8e5133631fe7bd7c69f7" translate="yes" xml:space="preserve">
          <source>Or, the same content can be read using:</source>
          <target state="translated">或者,同样的内容可以使用阅读。</target>
        </trans-unit>
        <trans-unit id="e7aee41fb363d46e588ad49a1b5591b283e863a6" translate="yes" xml:space="preserve">
          <source>Or, to list all changes to one particular account ($xyz) in order of decreasing magnitude, one can write:</source>
          <target state="translated">或者,如果要按递减顺序列出一个特定账户($xyz)的所有变化,我们可以写道。</target>
        </trans-unit>
        <trans-unit id="8a1681e612a2025087b703fdf1f8f617e506b053" translate="yes" xml:space="preserve">
          <source>Oracle</source>
          <target state="translated">Oracle</target>
        </trans-unit>
        <trans-unit id="6e8727d6e68eed5d20f3fa889a8e8b2bd24438db" translate="yes" xml:space="preserve">
          <source>Orders of magnitude performance improvement for &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; on very large tables.</source>
          <target state="translated">在非常大的表上，&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX的&lt;/a&gt;性能提高了几个数量级。</target>
        </trans-unit>
        <trans-unit id="6ce3fb54d989f83f97843b164388df9c55d52716" translate="yes" xml:space="preserve">
          <source>Ordinary Common Table Expressions</source>
          <target state="translated">普通通用表表达式</target>
        </trans-unit>
        <trans-unit id="628b6d597a836775d3c57cc85ac20362e62df83f" translate="yes" xml:space="preserve">
          <source>Ordinary SQL statements are free-form, and can be spread across multiple lines, and can have whitespace and comments anywhere. Dot-commands are more restrictive:</source>
          <target state="translated">普通SQL语句是自由格式的,可以横跨多行,可以在任何地方有空格和注释。点命令的限制性较强。</target>
        </trans-unit>
        <trans-unit id="410efca163172750b4e7d07d3df715195f75df04" translate="yes" xml:space="preserve">
          <source>Ordinary common table expressions</source>
          <target state="translated">普通常用表格表达式</target>
        </trans-unit>
        <trans-unit id="d3bfeb484e7ad7fe55b8281bb0d45da13e3151eb" translate="yes" xml:space="preserve">
          <source>Original content of the page prior to the start of the transaction</source>
          <target state="translated">交易开始前页面的原始内容。</target>
        </trans-unit>
        <trans-unit id="53583b5aa5fa79b35a37fe615fa3d9b1eece6568" translate="yes" xml:space="preserve">
          <source>Other C-libraries that process complex structured inputs will routinely be asked to deal with unvetted inputs from untrusted sources. Libraries like libjpeg, or libzip, or OpenSSL are handed input streams that come directly from potentially hostile agents.</source>
          <target state="translated">其他处理复杂结构化输入的C库会经常被要求处理来自不受信任来源的未经审核的输入。像libjpeg,或libzip,或OpenSSL这样的库,会被直接从潜在的敌对代理那里得到输入流。</target>
        </trans-unit>
        <trans-unit id="220b92a9851d65e3f5763bc585c592d7a14215e7" translate="yes" xml:space="preserve">
          <source>Other Issues</source>
          <target state="translated">其他问题</target>
        </trans-unit>
        <trans-unit id="286c105cf7e1fc8242c5f069e4037b0e5e35102f" translate="yes" xml:space="preserve">
          <source>Other SQL database engines tend to store data as a large collection of files. Often these files are in a standard location that only the database engine itself can access. This makes the data more secure, but also makes it harder to access. Some SQL database engines provide the option of writing directly to disk and bypassing the filesystem all together. This provides added performance, but at the cost of considerable setup and maintenance complexity.</source>
          <target state="translated">其他SQL数据库引擎往往将数据存储为一个大的文件集合。通常这些文件都在一个标准的位置,只有数据库引擎本身可以访问。这使得数据更加安全,但也使得数据更难被访问。一些SQL数据库引擎提供了直接写入磁盘并完全绕过文件系统的选项。这提供了额外的性能,但代价是相当大的设置和维护复杂性。</target>
        </trans-unit>
        <trans-unit id="5210f14e159e526b00e7b67ae5e00a7489e472f8" translate="yes" xml:space="preserve">
          <source>Other and more complex extensions can be found in subfolders under &lt;a href=&quot;https://www.sqlite.org/src/file/ext&quot;&gt;ext/&lt;/a&gt; other than ext/misc/.</source>
          <target state="translated">其他和更复杂的扩展名可以在&lt;a href=&quot;https://www.sqlite.org/src/file/ext&quot;&gt;ext /&lt;/a&gt;下的子文件夹中找到，而不是ext / misc /。</target>
        </trans-unit>
        <trans-unit id="a5885d7d219a9dd314e80ea53c10a7870f48702f" translate="yes" xml:space="preserve">
          <source>Other compile-time options such as using -O3 instead of -Os or using &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=0&lt;/a&gt; and/or some of the other &lt;a href=&quot;compile#rcmd&quot;&gt;recommended compile-time options&lt;/a&gt; might help SQLite to run even faster relative to direct filesystem reads.</source>
          <target state="translated">其他编译时选项（例如，使用-O3代替&lt;a href=&quot;compile#threadsafe&quot;&gt;-O&lt;/a&gt;或使用-DSQLITE_THREADSAFE = 0）和/或其他一些&lt;a href=&quot;compile#rcmd&quot;&gt;建议的编译时选项&lt;/a&gt;可能有助于SQLite相对于直接文件系统读取更快地运行。</target>
        </trans-unit>
        <trans-unit id="68a8c532629b4cb41be7b1e40786ac6ad241781e" translate="yes" xml:space="preserve">
          <source>Other database engines may run great once you get them going. But doing the initial installation and configuration can often be intimidating.</source>
          <target state="translated">其他的数据库引擎一旦你开始使用,可能会运行得很好。但进行初始安装和配置往往会让人望而生畏。</target>
        </trans-unit>
        <trans-unit id="0d3a3415efe071d534d2ab15cd7fe976055daeb3" translate="yes" xml:space="preserve">
          <source>Other entries in the cost table specific transforms for particular characters. The cost of specific transforms should be less than the default costs, or else the default costs will take precedence and the specific transforms will never be used.</source>
          <target state="translated">成本表中的其他条目是针对特定字符的特定变换。特定变形的成本应该小于默认成本,否则默认成本将优先,特定变形将永远不会被使用。</target>
        </trans-unit>
        <trans-unit id="0ac3c9882a4b70189ad1bfa57e91f5a096b4d423" translate="yes" xml:space="preserve">
          <source>Other examples:</source>
          <target state="translated">其他例子:</target>
        </trans-unit>
        <trans-unit id="cae24656c6711756dea7bb8cd35f3afb8c810eb8" translate="yes" xml:space="preserve">
          <source>Other experimental memory allocators might be added in future releases of SQLite. One may anticipate that these will be called memsys7, memsys8, and so forth.</source>
          <target state="translated">其他实验性的内存分配器可能会在未来的SQLite版本中加入。我们可以预计这些将被称为memsys7、memsys8等等。</target>
        </trans-unit>
        <trans-unit id="10c1a85e8f6e1ba9ad67291c0e509d27f0146a7c" translate="yes" xml:space="preserve">
          <source>Other important bug fixes</source>
          <target state="translated">其他重要的错误修复</target>
        </trans-unit>
        <trans-unit id="eafff73d48037ade49167d838ce6e1b6a891fb16" translate="yes" xml:space="preserve">
          <source>Other information fields of the sqlite3_rtree_query_info structure are available for use by the xQueryFunc callback, if desired. The iRowid field is the rowid (the first of the 3 to 11 columns in the R*Tree) for the element being considered. iRowid is only valid for leaves. The eParentWithin and rParentScore values are copies of the eWithin and rScore values from the containing subtree of the current row. The anQueue field is an array of mxLevel+1 unsigned integers that tell the current number of elements in the priority queue at each level.</source>
          <target state="translated">sqlite3_rtree_query_info结构的其他信息字段可以被xQueryFunc回调使用,如果需要的话。iRowid字段是被考虑的元素的rowid(R*Tree中3到11列中的第一列),iRowid只对叶子有效。eParentWithin和rParentScore值是当前行的包含子树的eWithin和rScore值的副本。anQueue字段是一个mxLevel+1的无符号整数数组,它告诉了每个级别的优先级队列中当前的元素数量。</target>
        </trans-unit>
        <trans-unit id="ac116740090073aa7d395dd931c8587b7e5ed819" translate="yes" xml:space="preserve">
          <source>Other kinds of constraints may be used and will work, but other constraints will be checked individually for each row and will not be optimized (at least not initially). All constraint checking is completely automatic regardless of whether or not optimization occurs. The optimization referred to in this bullet point is a performance consideration only. The same result is obtained regardless of whether or not the query is optimized.</source>
          <target state="translated">可以使用其他种类的约束条件,并且可以工作,但是其他约束条件将对每一行进行单独检查,并且不会进行优化(至少在最初不会)。无论是否发生优化,所有的约束条件检查都是完全自动的。本要点中提到的优化仅仅是性能方面的考虑。无论查询是否优化,都会得到同样的结果。</target>
        </trans-unit>
        <trans-unit id="aea1c45528f91c41cd64bff7bc4b9fe5c5d9e390" translate="yes" xml:space="preserve">
          <source>Other languages like Java, Perl, Python, and TCL typically translate the program source text into bytecode. This bytecode is then run through an interpreter that reads the bytecode and carries out the desired operations. SQLite uses this bytecode approach. If you preceed any SQL statement with the &quot;&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;&quot; keyword in SQLite, it will show you the bytecode that is generated rather than run the bytecode.</source>
          <target state="translated">其他语言，例如Java，Perl，Python和TCL，通常会将程序源文本转换为字节码。然后，该字节码通过解释器运行，该解释器读取该字节码并执行所需的操作。SQLite使用此字节码方法。如果您在SQLite中使用&amp;ldquo; &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; &amp;rdquo;关键字开头的任何SQL语句，它将向您显示所生成的字节码，而不是运行该字节码。</target>
        </trans-unit>
        <trans-unit id="808f70785d1ef92ea5c6148eaa9481e6d0e14aa1" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt; and &lt;a href=&quot;../rescode&quot;&gt;Result Codes&lt;/a&gt;.</source>
          <target state="translated">其他列表：&lt;a href=&quot;constlist&quot;&gt;常量&lt;/a&gt;和&lt;a href=&quot;funclist&quot;&gt;函数&lt;/a&gt;以及&lt;a href=&quot;../rescode&quot;&gt;结果代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="254b17e4c2182837b7ef0fdd5b3824e226f2c5a8" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt;.</source>
          <target state="translated">其他列表：&lt;a href=&quot;constlist&quot;&gt;常量&lt;/a&gt;和&lt;a href=&quot;funclist&quot;&gt;函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f2e591c11c09005f92f16a4e53401bee7662b02" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt; and &lt;a href=&quot;../rescode&quot;&gt;Result Codes&lt;/a&gt;</source>
          <target state="translated">其他列表：&lt;a href=&quot;constlist&quot;&gt;常量&lt;/a&gt;和&lt;a href=&quot;objlist&quot;&gt;对象&lt;/a&gt;以及&lt;a href=&quot;../rescode&quot;&gt;结果代码&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="710d410006003e6c96fa23b1a96739384d30f239" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt;.</source>
          <target state="translated">其他列表：&lt;a href=&quot;constlist&quot;&gt;常量&lt;/a&gt;和&lt;a href=&quot;objlist&quot;&gt;对象&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc0c16f3fd55dac69e3748a6c043c6447d6ab575" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt; and &lt;a href=&quot;../rescode&quot;&gt;Result Codes&lt;/a&gt;.</source>
          <target state="translated">其他列表：&lt;a href=&quot;objlist&quot;&gt;对象&lt;/a&gt;和&lt;a href=&quot;funclist&quot;&gt;函数&lt;/a&gt;以及&lt;a href=&quot;../rescode&quot;&gt;结果代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce8676972cf44ad111328d5252187ad79820f8b7" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt;.</source>
          <target state="translated">其他列表：&lt;a href=&quot;objlist&quot;&gt;对象&lt;/a&gt;和&lt;a href=&quot;funclist&quot;&gt;函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e05129b6c75ff832aa70dbb2deb9f7c3bddb6dc" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes</source>
          <target state="translated">其他小错误修复</target>
        </trans-unit>
        <trans-unit id="d4fc03a4fb1eb22ede8954ef99eea86a034ae6d2" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and documentation enhancements</source>
          <target state="translated">其他小的错误修复和文档增强</target>
        </trans-unit>
        <trans-unit id="890b3d475caba8d5bd7557f9c475d8af3c752a15" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and documentation enhancements.</source>
          <target state="translated">其他小的bug修复和文档增强。</target>
        </trans-unit>
        <trans-unit id="aa1b8c87b3d167a75e9df291742b29d3051fb50c" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and performance enhancements.</source>
          <target state="translated">其他小错误修复和性能提升。</target>
        </trans-unit>
        <trans-unit id="0fa68e95547b847335553befa0f2cb7b67624587" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and performance optimizations.</source>
          <target state="translated">其他小的错误修复和性能优化。</target>
        </trans-unit>
        <trans-unit id="1057a4540e5ed3386909678e9ca548cf6300a507" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes in preparation for the first stable release of version 3.3</source>
          <target state="translated">其他小的错误修复,为3.3版本的第一个稳定版本做准备。</target>
        </trans-unit>
        <trans-unit id="f58ff693cc659b1eb66fa3445ac112f3a975e0d7" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes.</source>
          <target state="translated">其他小BUG的修复。</target>
        </trans-unit>
        <trans-unit id="3d1e22329a4cb1219246e265a7a252a723c9d5fa" translate="yes" xml:space="preserve">
          <source>Other minor changes and enhancements.</source>
          <target state="translated">其他小的变化和改进。</target>
        </trans-unit>
        <trans-unit id="251ead6fb529a54fa107bbdc4f76c0af651e9179" translate="yes" xml:space="preserve">
          <source>Other minor compiler-warning fixes and whatnot.</source>
          <target state="translated">其他小的编译器警告修复之类的。</target>
        </trans-unit>
        <trans-unit id="deee6da4efcaf54f2a7bee650d4c13bb508dfa45" translate="yes" xml:space="preserve">
          <source>Other minor documentation and makefile changes and bug fixes.</source>
          <target state="translated">其他小的文档和makefile修改以及bug修复。</target>
        </trans-unit>
        <trans-unit id="031aa8e8c99846cb30787089a75b424566d207ca" translate="yes" xml:space="preserve">
          <source>Other minor tweaks to improve the quality of &lt;a href=&quot;opcode&quot;&gt;VDBE&lt;/a&gt; code.</source>
          <target state="translated">其他一些小的调整，以提高&lt;a href=&quot;opcode&quot;&gt;VDBE&lt;/a&gt;代码的质量。</target>
        </trans-unit>
        <trans-unit id="8b05e7277715773ceabf87f5e50fad5de6b24dd9" translate="yes" xml:space="preserve">
          <source>Other miscellaneous bug fixes</source>
          <target state="translated">其他杂项错误修复</target>
        </trans-unit>
        <trans-unit id="5d73e7d5d87f0b601b3cbf8f19cc97602a0f29c4" translate="yes" xml:space="preserve">
          <source>Other miscellaneous bug fixes.</source>
          <target state="translated">其他杂七杂八的bug修复。</target>
        </trans-unit>
        <trans-unit id="4b8124041770cac5d89ae555b4ac03153c37ffc1" translate="yes" xml:space="preserve">
          <source>Other miscellaneous enhancements such as loop unrolling.</source>
          <target state="translated">其他杂项增强功能,如循环开卷。</target>
        </trans-unit>
        <trans-unit id="6f62eac50d6703d3917c9f2154f9f77dce98abcd" translate="yes" xml:space="preserve">
          <source>Other miscellaneous micro-optimizations for improved performance and reduced memory usage.</source>
          <target state="translated">其他杂项微优化,以提高性能和减少内存使用。</target>
        </trans-unit>
        <trans-unit id="26485a453cc99f6d07c9ad5f2979b799b10596af" translate="yes" xml:space="preserve">
          <source>Other miscellaneous minor bug fixes.</source>
          <target state="translated">其他杂七杂八的小bug修复。</target>
        </trans-unit>
        <trans-unit id="583fac43540a1c8647f7a52c63c6d87ee3c57112" translate="yes" xml:space="preserve">
          <source>Other miscellaneous performance enhancements.</source>
          <target state="translated">其他杂项性能提升。</target>
        </trans-unit>
        <trans-unit id="d5335cc4f60749bd941dc9764ef3c6855a7a176b" translate="yes" xml:space="preserve">
          <source>Other more familiar database engines run great once you get them going. But doing the initial installation and configuration can be intimidatingly complex.</source>
          <target state="translated">其他更熟悉的数据库引擎一旦你开始使用,就会运行得很好。但进行初始安装和配置可能会很复杂,令人望而生畏。</target>
        </trans-unit>
        <trans-unit id="d62a6e61f5dec5bfc458e9cb92c78c02e716a2af" translate="yes" xml:space="preserve">
          <source>Other output modes include &quot;html&quot;, &quot;json&quot;, and &quot;tcl&quot;. Try these yourself to see what they do.</source>
          <target state="translated">其他输出模式包括 &quot;html&quot;、&quot;json &quot;和 &quot;tcl&quot;。自己试试这些模式,看看它们的作用。</target>
        </trans-unit>
        <trans-unit id="453575f6d5ccd906017a354a3747a73c275dcbf4" translate="yes" xml:space="preserve">
          <source>Other pages that talk about Fossil and Git include:</source>
          <target state="translated">其他谈论Fossil和Git的页面包括。</target>
        </trans-unit>
        <trans-unit id="1691c79ed589685ad615d8d10ce5d4a24f7887ad" translate="yes" xml:space="preserve">
          <source>Other performance improvements. Uses about &lt;a href=&quot;cpu&quot;&gt;6.5% fewer CPU cycles&lt;/a&gt;.</source>
          <target state="translated">其他性能改进。&lt;a href=&quot;cpu&quot;&gt;减少&lt;/a&gt;约6.5％的CPU周期。</target>
        </trans-unit>
        <trans-unit id="53a9f15c17fc6f690db9ec48e6c595c7787f86a9" translate="yes" xml:space="preserve">
          <source>Other performance optimizations:</source>
          <target state="translated">其他性能优化。</target>
        </trans-unit>
        <trans-unit id="a62bf7250068b9b0c4a25d2045a53dbb9795b912" translate="yes" xml:space="preserve">
          <source>Other programming languages sometimes claim to be &quot;as fast as C&quot;. But no other language claims to be faster than C for general-purpose programming, because none are.</source>
          <target state="translated">其他编程语言有时会声称自己 &quot;和C一样快&quot;。但没有任何一种语言声称比C语言的通用编程速度快,因为没有一种语言是这样的。</target>
        </trans-unit>
        <trans-unit id="400864fb9a5435081d0153c603d26034407232fd" translate="yes" xml:space="preserve">
          <source>Other relation database engines also implement UPDATE-FROM, but because the construct is not part of the SQL standards, each product implements UPDATE-FROM differently. The SQLite implementation strives to be compatible with PostgreSQL. The SQL Server and MySQL implementations of the same idea work a little differently.</source>
          <target state="translated">其他关系型数据库引擎也实现了UPDATE-FROM,但由于该构造不是SQL标准的一部分,所以每个产品实现UPDATE-FROM的方式不同。SQLite的实现力求与PostgreSQL兼容。SQL Server和MySQL对同一思想的实现工作方式有些不同。</target>
        </trans-unit>
        <trans-unit id="b724fba24bcbd81609e47345dfce9dfa38bb53b6" translate="yes" xml:space="preserve">
          <source>Other similar tree-display routines include:</source>
          <target state="translated">其他类似的树形显示例程包括:</target>
        </trans-unit>
        <trans-unit id="eb0b09bd0abc9cbcebf776931eb89745e9f2f6c6" translate="yes" xml:space="preserve">
          <source>Other small bug fixes and optimizations.</source>
          <target state="translated">其他小bug的修复和优化。</target>
        </trans-unit>
        <trans-unit id="ce257a3574985ec3c0e88eff4d14f53603f86d62" translate="yes" xml:space="preserve">
          <source>Other systems sometimes use assert(X) in a way that is similar to the use of ALWAYS(X) or NEVER(X) in SQLite. Developers will add an assert(X) as a &lt;a href=&quot;https://blog.regehr.org/archives/1576&quot;&gt;tacit acknowledgement that they do not fully believe that X is always true&lt;/a&gt;. We believe that this use of assert(X) is wrong and violates the intent and purpose of having assert(X) available in C in the first place. An assert(X) should not be seen as a safety-net or top-rope used to guard against mistakes. Nor is assert(X) appropriate for defense-in-depth. An ALWAYS(X) or NEVER(X) macro, or something similar, should be used in those cases because ALWAYS(X) or NEVER(X) will be followed by code to actually deal with the problem when the programmers reasoning turns out to be wrong. Since the code that follows ALWAYS(X) or NEVER(X) is untested, it should be something very simple, like a &quot;return&quot; statement, that is easily verified by inspection.</source>
          <target state="translated">其他系统有时以与SQLite中ALWAYS（X）或NEVER（X）相似的方式使用assert（X）。开发人员将添加一个assert（X）作为&lt;a href=&quot;https://blog.regehr.org/archives/1576&quot;&gt;默认确认，即他们不完全相信X始终为真&lt;/a&gt;。我们认为assert（X）的这种使用是错误的，并且首先违反了在C中使用assert（X）的意图和目的。assert（X）不应被视为用于防止错误的安全网或顶级绳索。assert（X）也不适用于纵深防御。在这种情况下，应使用ALWAYS（X）或NEVER（X）宏或类似的东西，因为当程序员推理出结果时，ALWAYS（X）或NEVER（X）后面将跟随代码来实际处理该问题。是错的。由于ALWAYS（X）或NEVER（X）之后的代码未经测试，因此应该很简单，例如&amp;ldquo; return&amp;rdquo;语句，可以很容易地通过检查进行验证。</target>
        </trans-unit>
        <trans-unit id="34d2c9c7d77d063050411b9cf0d5ad05916eb325" translate="yes" xml:space="preserve">
          <source>Otherwise, an expression has no affinity.</source>
          <target state="translated">否则,一个表情就没有亲和力。</target>
        </trans-unit>
        <trans-unit id="6917a7f5da3062b0cb87b819a1b98dde64d2060e" translate="yes" xml:space="preserve">
          <source>Otherwise, if no error occurs, &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush()&lt;/a&gt; returns SQLITE_OK.</source>
          <target state="translated">否则，如果未发生错误，则&lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush（）&lt;/a&gt;返回SQLITE_OK。</target>
        </trans-unit>
        <trans-unit id="63ffff1a975b81be129a4faecffea464b53159fd" translate="yes" xml:space="preserve">
          <source>Otherwise, if no error occurs, &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush()&lt;/a&gt; returns SQLITE_OK.</source>
          <target state="translated">否则，如果未发生错误，则&lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush（）&lt;/a&gt;返回SQLITE_OK。</target>
        </trans-unit>
        <trans-unit id="f4554128dd35917d0080717168dbd2c249f00b56" translate="yes" xml:space="preserve">
          <source>Otherwise, if the ORDER BY expression is a column or an alias of an expression that is a column, then the default collation sequence for the column is used.</source>
          <target state="translated">否则,如果ORDER BY表达式是一列或表达式的别名是一列,则使用该列的默认整理序列。</target>
        </trans-unit>
        <trans-unit id="7e53078a08397e14f15e969e1f704be9f2cd8b70" translate="yes" xml:space="preserve">
          <source>Otherwise, if the ORDER BY expression is an alias to an expression that has been assigned a collation sequence using the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, then the collation sequence assigned to the aliased expression is used.</source>
          <target state="translated">否则，如果ORDER BY表达式是已使用后缀&lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE运算符&lt;/a&gt;分配了排序规则序列的表达式的别名，则将使用分配给别名表达式的排序规则序列。</target>
        </trans-unit>
        <trans-unit id="16e19790e123dd698bb68d8acfc3c250ddf0f26c" translate="yes" xml:space="preserve">
          <source>Otherwise, if the ORDER BY expression is any other expression, it is evaluated and the returned value used to order the output rows. If the SELECT statement is a simple SELECT, then an ORDER BY may contain any arbitrary expressions. However, if the SELECT is a compound SELECT, then ORDER BY expressions that are not aliases to output columns must be exactly the same as an expression used as an output column.</source>
          <target state="translated">否则,如果ORDER BY表达式是任何其他表达式,则会对其进行评估,并使用返回的值对输出行进行排序。如果SELECT语句是一个简单的SELECT,那么ORDER BY可以包含任何任意的表达式。但是,如果SELECT是一个复合SELECT,那么不是输出列别名的ORDER BY表达式必须与用作输出列的表达式完全相同。</target>
        </trans-unit>
        <trans-unit id="74d7943e809a432b89e323d15537e7de75d402f8" translate="yes" xml:space="preserve">
          <source>Otherwise, no affinity is applied and both operands are compared as is.</source>
          <target state="translated">否则,不采用亲和力,两个操作数按原样比较。</target>
        </trans-unit>
        <trans-unit id="ace2ae60f4f3efb9070beb6a2fed407ad7cd8e65" translate="yes" xml:space="preserve">
          <source>Otherwise, r[P2] is set to the sum of r[P1] and r[P3].</source>
          <target state="translated">否则,r[P2]设为r[P1]和r[P3]之和。</target>
        </trans-unit>
        <trans-unit id="c9d8794c47ac5fbe000cffe629c489a9791ed713" translate="yes" xml:space="preserve">
          <source>Otherwise, the &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt; collation sequence is used.</source>
          <target state="translated">否则，将使用&lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt;排序规则序列。</target>
        </trans-unit>
        <trans-unit id="35b896906bdef712969f9e7297c680f9a2e53cd3" translate="yes" xml:space="preserve">
          <source>Otherwise, the BINARY collating function is used for comparison.</source>
          <target state="translated">否则,采用BINARY整理函数进行比较。</target>
        </trans-unit>
        <trans-unit id="638ab872140702484af1c059aebc57de13dbd98b" translate="yes" xml:space="preserve">
          <source>Otherwise, the affinity is NUMERIC.</source>
          <target state="translated">否则,亲和力就是NUMERIC。</target>
        </trans-unit>
        <trans-unit id="cfc6f8803bf4c712ac864728c4305aa6942d9a6a" translate="yes" xml:space="preserve">
          <source>Otherwise, the value inserted into this field is the file contents for a regular file, or the target of a symbolic link.</source>
          <target state="translated">否则,插入该字段的值是普通文件的文件内容,或符号链接的目标。</target>
        </trans-unit>
        <trans-unit id="cb91e52cc1b3ca8f3f684e2966f8d4c11f3cb0b5" translate="yes" xml:space="preserve">
          <source>Otherwise, this API returns a negative value if P1 refers to an older snapshot than P2, zero if the two handles refer to the same database snapshot, and a positive value if P1 is a newer snapshot than P2.</source>
          <target state="translated">否则,如果P1指的是比P2更老的快照,这个API返回负值;如果两个句柄指的是同一个数据库快照,则返回零;如果P1是比P2新的快照,则返回正值。</target>
        </trans-unit>
        <trans-unit id="afebc4d098577eaf408f5312d05f2e55f910ee39" translate="yes" xml:space="preserve">
          <source>Our goal is to make the content you store in SQLite today as easily accessible to your grandchildren as it is to you.</source>
          <target state="translated">我们的目标是让你今天存储在SQLite中的内容能够像你的孙子一样容易访问。</target>
        </trans-unit>
        <trans-unit id="3edd7f9a4b0d8d87dc9885a06cb59a66ad8766a5" translate="yes" xml:space="preserve">
          <source>Out of memory (OOM) error conditions generate error logging events with the SQLITE_NOMEM error code and a message that says how many bytes of memory were requested by the failed allocation.</source>
          <target state="translated">Out of memory (OOM)错误条件会产生错误日志事件,其中包含SQLITE_NOMEM错误代码和一条消息,说明失败的分配请求了多少字节的内存。</target>
        </trans-unit>
        <trans-unit id="3eb43b3eb70e7d12a47e5820876f3c296dc05bc2" translate="yes" xml:space="preserve">
          <source>Out-of-memory tests</source>
          <target state="translated">记忆外测试</target>
        </trans-unit>
        <trans-unit id="c1bf191f6ccc359ad8a3c05c295f7fe8cef84ae3" translate="yes" xml:space="preserve">
          <source>Outlandish Recursive Query Examples</source>
          <target state="translated">离奇的递归查询示例</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="1bd1112bbbb687e4d808e79cb404cc3ec423a23a" translate="yes" xml:space="preserve">
          <source>Output Change</source>
          <target state="translated">输出变化</target>
        </trans-unit>
        <trans-unit id="0c51e370c031f37870509dc46422ce61ca6e1f16" translate="yes" xml:space="preserve">
          <source>Output columns from the index_info pragma are as follows:</source>
          <target state="translated">index_info pragma的输出列如下。</target>
        </trans-unit>
        <trans-unit id="8383ea0f1fb51fe84444b17104e0dd18b8f3f3b4" translate="yes" xml:space="preserve">
          <source>Output columns from the index_list pragma are as follows:</source>
          <target state="translated">index_list pragma的输出列如下。</target>
        </trans-unit>
        <trans-unit id="bc6e58f2bacd5891df7b631d05c18328e75e62f4" translate="yes" xml:space="preserve">
          <source>Output columns from the index_xinfo pragma are as follows:</source>
          <target state="translated">index_xinfo pragma的输出列如下。</target>
        </trans-unit>
        <trans-unit id="d1088854d972e4ceb1796db8756ad3486790779d" translate="yes" xml:space="preserve">
          <source>Output infinity as 1e999 in the &quot;.dump&quot; command of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;cli&quot;&gt;命令行shell&lt;/a&gt;的&amp;ldquo; .dump&amp;rdquo;命令中将无穷大输出为1e999 。</target>
        </trans-unit>
        <trans-unit id="17e008cf652984308f7573376fc6932528a013cf" translate="yes" xml:space="preserve">
          <source>Output rows can be returned to the application as each small sort completes, and well before the table scan is complete.</source>
          <target state="translated">在每个小排序完成时,以及在表扫描完成之前,可以将输出行返回给应用程序。</target>
        </trans-unit>
        <trans-unit id="b785807667b898e4c7f09b3ee44afccba51a9945" translate="yes" xml:space="preserve">
          <source>Outputs an SQL script to create an RBU database which, if used to update database t1.db, patches it so that its contents are identical to that of database t2.db.</source>
          <target state="translated">输出一个SQL脚本来创建一个RBU数据库,如果用来更新数据库t1.db,则对其进行修补,使其内容与数据库t2.db相同。</target>
        </trans-unit>
        <trans-unit id="25a352aa2e3e3671bf4d083fdd886df3d305e826" translate="yes" xml:space="preserve">
          <source>Over 100 separate source files are concatenated into a single large files of C-code named &quot;sqlite3.c&quot; and called &quot;the amalgamation&quot;. The amalgamation contains everything an application needs to embed SQLite. The amalgamation file is more than 220,000 lines long and over 7.5 megabytes in size (as of 2018-11-24).</source>
          <target state="translated">超过100个独立的源文件被合并到一个名为 &quot;sqlite3.c &quot;的C代码大文件中,被称为 &quot;amalgamation&quot;。amalgamation包含了应用程序嵌入SQLite所需的一切。amalgamation文件长达22万多行,大小超过7.5兆字节(截至2018-11-24)。</target>
        </trans-unit>
        <trans-unit id="6f2a6be035cf5a02d68b5e9127156e17d6b333b6" translate="yes" xml:space="preserve">
          <source>Overflow page</source>
          <target state="translated">溢出页面</target>
        </trans-unit>
        <trans-unit id="26c78f2170e31758038f3bb0a52b3d4d222f938f" translate="yes" xml:space="preserve">
          <source>Overload A Function For A Virtual Table</source>
          <target state="translated">虚拟表的功能过载</target>
        </trans-unit>
        <trans-unit id="007c99e63ddccff493d60c3cf9732ab7365f22fb" translate="yes" xml:space="preserve">
          <source>Override other operating system interfaces such as calls to obtain Zulu or local time.</source>
          <target state="translated">覆盖其他操作系统接口,如调用获取祖鲁时间或本地时间。</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="46880b89366d47b3659d0ee6bf4c167da19b6968" translate="yes" xml:space="preserve">
          <source>Overview Documents</source>
          <target state="translated">概述文件</target>
        </trans-unit>
        <trans-unit id="04e78b5fd19361d42f0880283437d8302448583e" translate="yes" xml:space="preserve">
          <source>Overwrite if already exists?</source>
          <target state="translated">如果已经存在,则覆盖?</target>
        </trans-unit>
        <trans-unit id="9ada09a735411e9de190da46810d6bab2f578abd" translate="yes" xml:space="preserve">
          <source>Overwriting a database file with another without also deleting any hot journal associated with the original database.</source>
          <target state="translated">用另一个数据库文件覆盖一个数据库文件,同时不删除与原数据库相关联的任何热日志。</target>
        </trans-unit>
        <trans-unit id="bcfd518ec9aac14be70cb40d43cadb15da01978e" translate="yes" xml:space="preserve">
          <source>Overwritting a journal file with a different journal file.</source>
          <target state="translated">用不同的日志文件覆盖日志文件。</target>
        </trans-unit>
        <trans-unit id="f6202fa6f9727ecd28cda41b586c4f17db3f9662" translate="yes" xml:space="preserve">
          <source>P (cost: 7.71)</source>
          <target state="translated">P(费用:7.71)</target>
        </trans-unit>
        <trans-unit id="80d8eec7d81f7a0324484c1ac454ead7da895c4f" translate="yes" xml:space="preserve">
          <source>P1 can be either an ordinary table or a virtual table. There used to be a separate OP_VRowid opcode for use with virtual tables, but this one opcode now works for both table types.</source>
          <target state="translated">P1可以是一个普通表,也可以是一个虚拟表。过去有一个单独的OP_VRowid操作码用于虚拟表,但现在这个操作码对两种表类型都适用。</target>
        </trans-unit>
        <trans-unit id="84bf22352f6da5dd236d64694b38dd6696254f42" translate="yes" xml:space="preserve">
          <source>P1 contains the address of the memory cell that contains the first memory cell in an array of values used as arguments to the sub-program. P2 contains the address to jump to if the sub-program throws an IGNORE exception using the RAISE() function. Register P3 contains the address of a memory cell in this (the parent) VM that is used to allocate the memory required by the sub-vdbe at runtime.</source>
          <target state="translated">P1包含包含作为子程序参数的值数组中第一个内存单元的内存单元的地址。P2包含子程序使用RAISE()函数抛出IGNORE异常时要跳转的地址。寄存器P3包含此(父)VM中一个内存单元的地址,该内存单元用于在运行时分配子vdbe所需的内存。</target>
        </trans-unit>
        <trans-unit id="bbb7c16489d0b290a1227473f0d5f4da2b7691cc" translate="yes" xml:space="preserve">
          <source>P1 is a 32-bit bitmask indicating whether or not each argument to the function was determined to be constant at compile time. If the first argument was constant then bit 0 of P1 is set. This is used to determine whether meta data associated with a user function argument using the sqlite3_set_auxdata() API may be safely retained until the next invocation of this opcode.</source>
          <target state="translated">P1是一个32位的位掩码,表示函数的每个参数在编译时是否被确定为常数。如果第一个参数是常数,那么P1的0位就会被设置。这用于确定是否可以安全地保留与使用sqlite3_set_auxdata()API的用户函数参数相关联的元数据,直到下一次调用这个操作码。</target>
        </trans-unit>
        <trans-unit id="ce2db3e033bf07aaa2aac0e6df082aac39175194" translate="yes" xml:space="preserve">
          <source>P1 is a boolean flag. If it is set to true and the xUpdate call is successful, then the value returned by sqlite3_last_insert_rowid() is set to the value of the rowid for the row just inserted.</source>
          <target state="translated">P1是一个布尔标志。如果它被设置为true,并且xUpdate调用成功,那么sqlite3_last_insert_rowid()返回的值将被设置为刚刚插入的行的rowid值。</target>
        </trans-unit>
        <trans-unit id="ab3846ffb469791c7c875a7d6e64699955c09eb4" translate="yes" xml:space="preserve">
          <source>P1 is a cursor opened using &lt;a href=&quot;opcode#VOpen&quot;&gt;VOpen&lt;/a&gt;. P2 is an address to jump to if the filtered result set is empty.</source>
          <target state="translated">P1是使用&lt;a href=&quot;opcode#VOpen&quot;&gt;VOpen&lt;/a&gt;打开的游标。如果过滤结果集为空，则P2是要跳转到的地址。</target>
        </trans-unit>
        <trans-unit id="99e16bb5285cdf74213efcd911112d0254cc888f" translate="yes" xml:space="preserve">
          <source>P1 is a register in the root frame of this VM (the root frame is different from the current frame if this instruction is being executed within a sub-program). Set the value of register P1 to the maximum of its current value and the value in register P2.</source>
          <target state="translated">P1是本虚拟机根帧中的一个寄存器(如果本指令在子程序内执行,则根帧与当前帧不同)。将寄存器P1的值设为其当前值和寄存器P2中值的最大值。</target>
        </trans-unit>
        <trans-unit id="17a3ab4e084c4ae225f4e64b76426d06344fe074" translate="yes" xml:space="preserve">
          <source>P1 is a sorter cursor. If the sequence counter is currently zero, jump to P2. Regardless of whether or not the jump is taken, increment the the sequence value.</source>
          <target state="translated">P1是分拣器光标。如果序列计数器当前为零,则跳转到P2。无论是否进行了跳转,都要对序列值进行递增。</target>
        </trans-unit>
        <trans-unit id="f9ac2a8e79b4d0f70e9cfe08c3c644453f11b20b" translate="yes" xml:space="preserve">
          <source>P1 is a sorter cursor. This instruction compares a prefix of the record blob in register P3 against a prefix of the entry that the sorter cursor currently points to. Only the first P4 fields of r[P3] and the sorter record are compared.</source>
          <target state="translated">P1是一个分拣机游标。这条指令将寄存器P3中的记录blob的前缀与分拣机游标当前指向的条目的前缀进行比较。只有r[P3]的前P4字段和分拣机记录被比较。</target>
        </trans-unit>
        <trans-unit id="d14bcdd4246c685563dd290988090774223c445f" translate="yes" xml:space="preserve">
          <source>P1 is an open index cursor and P3 is a cursor on the corresponding table. This opcode does a deferred seek of the P3 table cursor to the row that corresponds to the current row of P1.</source>
          <target state="translated">P1是一个开放的索引游标,P3是对应表的游标。这个操作码对P3表的游标进行延时查找,查找到与P1当前行相对应的行。</target>
        </trans-unit>
        <trans-unit id="86c484d0a40d444e4dc0b4d443a06296772d4391" translate="yes" xml:space="preserve">
          <source>P1 is the index of a cursor open on an SQL table btree (with integer keys). If register P3 does not contain an integer or if P1 does not contain a record with rowid P3 then jump immediately to P2. Or, if P2 is 0, raise an SQLITE_CORRUPT error. If P1 does contain a record with rowid P3 then leave the cursor pointing at that record and fall through to the next instruction.</source>
          <target state="translated">P1是在SQL表树上打开的游标的索引(带整数键)。如果寄存器P3不包含一个整数,或者如果P1不包含一个行号为P3的记录,则立即跳转到P2。或者,如果P2为0,则引发一个SQLITE_CORRUPT错误。如果P1确实包含了一条记录,其行号为P3,那么让光标指向这条记录,然后跳转到下一条指令。</target>
        </trans-unit>
        <trans-unit id="be17250db9325023bb6814cabfbf543abfa5ba67" translate="yes" xml:space="preserve">
          <source>P1 is the index of a cursor open on an SQL table btree (with integer keys). P3 is an integer rowid. If P1 does not contain a record with rowid P3 then jump immediately to P2. Or, if P2 is 0, raise an SQLITE_CORRUPT error. If P1 does contain a record with rowid P3 then leave the cursor pointing at that record and fall through to the next instruction.</source>
          <target state="translated">P1是在SQL表btree上打开的游标的索引(有整数键)。P3是一个整数行id。如果P1不包含一个行号为P3的记录,则立即跳转到P2。或者,如果P2为0,则引发一个SQLITE_CORRUPT错误。如果P1确实包含了一条记录,其行号为P3,那么让光标指向这条记录,然后跳转到下一条指令。</target>
        </trans-unit>
        <trans-unit id="35a6c564ff4d581152e9a1f876d9eb72d2af48f4" translate="yes" xml:space="preserve">
          <source>P1 is the index of the database file on which the transaction is started. Index 0 is the main database file and index 1 is the file used for temporary tables. Indices of 2 or more are used for attached databases.</source>
          <target state="translated">P1是事务启动所依据的数据库文件的索引,索引0是主数据库文件,索引1是用于临时表的文件。索引0是主数据库文件,索引1是用于临时表的文件。指数为2或2以上的是用于附属数据库的。</target>
        </trans-unit>
        <trans-unit id="b9198f15e439eca54714083fc1fc6d108cc42915" translate="yes" xml:space="preserve">
          <source>P1 is the index of the database in sqlite3.aDb[] of the database on which the lock is acquired. A readlock is obtained if P3==0 or a write lock if P3==1.</source>
          <target state="translated">P1是获得锁的数据库在sqlite3.aDb[]中的索引。如果P3==0则获得读锁,如果P3==1则获得写锁。</target>
        </trans-unit>
        <trans-unit id="1fcd6d3417638283143894ac28a56d5766856870" translate="yes" xml:space="preserve">
          <source>P1 is the memory location that is the accumulator for an aggregate or window function. Execute the finalizer function for an aggregate and store the result in P1.</source>
          <target state="translated">P1是内存位置,是一个集合函数或窗口函数的累加器。执行集合函数的定标函数,并将结果存储在P1中。</target>
        </trans-unit>
        <trans-unit id="9564a9171b616f080f45aeeeeb50a759cf2543a9" translate="yes" xml:space="preserve">
          <source>P1 is the result code returned by sqlite3_exec(), sqlite3_reset(), or sqlite3_finalize(). For a normal halt, this should be SQLITE_OK (0). For errors, it can be some other value. If P1!=0 then P2 will determine whether or not to rollback the current transaction. Do not rollback if P2==OE_Fail. Do the rollback if P2==OE_Rollback. If P2==OE_Abort, then back out all changes that have occurred during this execution of the VDBE, but do not rollback the transaction.</source>
          <target state="translated">P1是sqlite3_exec()、sqlite3_reset()或sqlite3_finalize()返回的结果代码。对于正常的停止,它应该是SQLITE_OK (0)。对于错误,可以是其他的值。如果P1!=0,那么P2将决定是否回滚当前事务。如果P2==OE_Fail,则不要回滚。如果P2==OE_Rollback,则进行回滚。如果P2==OE_Abort,则回滚本次执行VDBE期间发生的所有变化,但不回滚事务。</target>
        </trans-unit>
        <trans-unit id="dcea1649c96ae08171a24407e2519d717994383c" translate="yes" xml:space="preserve">
          <source>P1 must be a valid b-tree cursor.</source>
          <target state="translated">P1必须是一个有效的b树游标。</target>
        </trans-unit>
        <trans-unit id="05f5c83f3b169019c8e82a0eaf11fb45a16518b4" translate="yes" xml:space="preserve">
          <source>P1 must be a valid b-tree cursor. P2 must be a boolean value, either 0 or 1.</source>
          <target state="translated">P1必须是一个有效的b-tree游标,P2必须是一个布尔值,可以是0或1。P2必须是一个布尔值,可以是0或1。</target>
        </trans-unit>
        <trans-unit id="05f600aab9b18602c22139c66a31c7458bbfad3f" translate="yes" xml:space="preserve">
          <source>P1 must not be pseudo-table. It has to be a real table with multiple rows.</source>
          <target state="translated">P1不能是伪表。它必须是一个真正的多行表。</target>
        </trans-unit>
        <trans-unit id="f93c0802a39924cff1b00e9015e9aa33f54938f7" translate="yes" xml:space="preserve">
          <source>P2 contains the root-page of the table to lock.</source>
          <target state="translated">P2包含要锁定的表的根页。</target>
        </trans-unit>
        <trans-unit id="9ce77455e05f3264d5bb123f4f714e82dd11c666" translate="yes" xml:space="preserve">
          <source>P2 is a register that holds the name of a virtual table in database P1. Call the xCreate method for that table.</source>
          <target state="translated">P2是一个寄存器,存放数据库P1中的一个虚拟表的名称。调用该表的xCreate方法。</target>
        </trans-unit>
        <trans-unit id="be0d49dbe18b5a0cf012a9f8a24be16667dd4219" translate="yes" xml:space="preserve">
          <source>P2 is the column number for the argument to the sqlite_offset() function. This opcode does not use P2 itself, but the P2 value is used by the code generator. The P1, P2, and P3 operands to this opcode are the same as for &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt;.</source>
          <target state="translated">P2是sqlite_offset（）函数的参数的列号。该操作码本身不使用P2，但是代码生成器使用P2值。此操作码的P1，P2和P3操作数与&lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="b9b9294fefdd80f907d449f8b026a50941891877" translate="yes" xml:space="preserve">
          <source>P2 is the number of arguments that the step function takes and P4 is a pointer to the FuncDef for this function. The P2 argument is not used by this opcode. It is only there to disambiguate functions that can take varying numbers of arguments. The P4 argument is only needed for the case where the step function was not previously called.</source>
          <target state="translated">P2是步进函数所取的参数数,P4是指向该函数FuncDef的指针。P2参数不被这个操作码使用。它只是为了区分可以接受不同数量参数的函数。P4参数只在之前没有调用step函数的情况下才需要。</target>
        </trans-unit>
        <trans-unit id="3bd7cc65ffe04a6cbb96320f3dfb05bef13a6003" translate="yes" xml:space="preserve">
          <source>P2 is the number of columns in the ephemeral table. The cursor points to a BTree table if P4==0 and to a BTree index if P4 is not 0. If P4 is not NULL, it points to a KeyInfo structure that defines the format of keys in the index.</source>
          <target state="translated">P2为历时表的列数。如果P4==0,则光标指向一个BTree表,如果P4不是0,则指向一个BTree索引。如果P4不是NULL,则指向一个KeyInfo结构,该结构定义了索引中键的格式。</target>
        </trans-unit>
        <trans-unit id="d43bd5b8560de02b50e24570db7ff928128725ba" translate="yes" xml:space="preserve">
          <source>P2=='A' &amp;rarr; BLOB</source>
          <target state="translated">P2 =='A'&amp;rarr;BLOB</target>
        </trans-unit>
        <trans-unit id="549df038ddec37fc17c85e7dccfd3d0f7eac490b" translate="yes" xml:space="preserve">
          <source>P2=='B' &amp;rarr; TEXT</source>
          <target state="translated">P2 =='B'&amp;rarr;文本</target>
        </trans-unit>
        <trans-unit id="3eb880697f1f955293bf5968bad5752ba9e6c36d" translate="yes" xml:space="preserve">
          <source>P2=='C' &amp;rarr; NUMERIC</source>
          <target state="translated">P2 =='C'&amp;rarr;数值</target>
        </trans-unit>
        <trans-unit id="11082965a2f3470ce5a9187e0cfe05f51096d4b9" translate="yes" xml:space="preserve">
          <source>P2=='D' &amp;rarr; INTEGER</source>
          <target state="translated">P2 =='D'&amp;rarr;整数</target>
        </trans-unit>
        <trans-unit id="8d3f310a6285b7cb02844a9cd70fd245db85edd2" translate="yes" xml:space="preserve">
          <source>P2=='E' &amp;rarr; REAL</source>
          <target state="translated">P2 =='E'&amp;rarr;实数</target>
        </trans-unit>
        <trans-unit id="12d088ae7e89df349fe37f3d37cf8b1ca4c09b3a" translate="yes" xml:space="preserve">
          <source>P3 = P2 || P1</source>
          <target state="translated">P3=P2 || P1</target>
        </trans-unit>
        <trans-unit id="3a22c873357ee7f56f10d2e038f148e48353f460" translate="yes" xml:space="preserve">
          <source>P3 is the number of fields in the records that will be stored by the pseudo-table.</source>
          <target state="translated">P3是伪表将存储的记录中的字段数。</target>
        </trans-unit>
        <trans-unit id="fa5df0db7433454e4380316b1e3b9bfe2adbea6f" translate="yes" xml:space="preserve">
          <source>P4 contains a pointer to the name of the table being locked. This is only used to generate an error message if the lock cannot be obtained.</source>
          <target state="translated">P4包含一个指向被锁定的表名的指针。只有在无法获得锁定时,才会产生错误信息。</target>
        </trans-unit>
        <trans-unit id="3f5b2dbcd76db7494d70506eccc181bd880869ce" translate="yes" xml:space="preserve">
          <source>P4 is a KeyInfo structure that defines collating sequences and sort orders for the comparison. The permutation applies to registers only. The KeyInfo elements are used sequentially.</source>
          <target state="translated">P4是一个KeyInfo结构,它定义了用于比较的整理序列和排序顺序。置换只适用于寄存器。KeyInfo元素按顺序使用。</target>
        </trans-unit>
        <trans-unit id="6e63a14f434c9d816b03aebb21b25ccfa99f1b42" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a 64-bit floating point value. Write that value into register P2.</source>
          <target state="translated">P4是指向一个64位浮点值的指针。将该值写入寄存器P2中。</target>
        </trans-unit>
        <trans-unit id="006b4d737b2fe81d322403675fc01054f9eaddfd" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a 64-bit integer value. Write that value into register P2.</source>
          <target state="translated">P4是指向一个64位整数值的指针。将该值写入寄存器P2。</target>
        </trans-unit>
        <trans-unit id="93432616419a7361a72b061b65e02339a1738910" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a CollSeq object. If the next call to a user function or aggregate calls sqlite3GetFuncCollSeq(), this collation sequence will be returned. This is used by the built-in min(), max() and nullif() functions.</source>
          <target state="translated">P4是一个指向CollSeq对象的指针。如果下一次调用用户函数或集合时调用sqlite3GetFuncCollSeq(),将返回这个整理序列。这被内置的min()、max()和nullif()函数使用。</target>
        </trans-unit>
        <trans-unit id="d80240e61957d32e7437d69346afb9ca3c15eca9" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a virtual table object, an sqlite3_vtab structure. P1 is a cursor number. This opcode opens a cursor to the virtual table and stores that cursor in P1.</source>
          <target state="translated">P4是指向一个虚拟表对象的指针,是一个sqlite3_vtab结构。P1是一个游标号。这个操作码打开了一个指向虚拟表的游标,并将该游标存储在P1中。</target>
        </trans-unit>
        <trans-unit id="0dbffabc54d98d6801900e6ab537de5e2bcdd805" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a virtual table object, an sqlite3_vtab structure. This opcode invokes the corresponding xRename method. The value in register P1 is passed as the zName argument to the xRename method.</source>
          <target state="translated">P4是指向一个虚拟表对象的指针,是一个sqlite3_vtab结构。这个操作码调用了相应的xRename方法,寄存器P1中的值作为xRename方法的zName参数。寄存器P1中的值作为zName参数传递给xRename方法。</target>
        </trans-unit>
        <trans-unit id="8c184e85a48a476ce012fdb53452bec6f0cb31bc" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a virtual table object, an sqlite3_vtab structure. This opcode invokes the corresponding xUpdate method. P2 values are contiguous memory cells starting at P3 to pass to the xUpdate invocation. The value in register (P3+P2-1) corresponds to the p2th element of the argv array passed to xUpdate.</source>
          <target state="translated">P4是指向一个虚拟表对象的指针,是一个sqlite3_vtab结构。这个操作码调用了相应的xUpdate方法,P2值是从P3开始的连续内存单元,传递给xUpdate调用。P2值是从P3开始的连续内存单元,传递给xUpdate调用。寄存器(P3+P2-1)中的值对应于传递给xUpdate的argv数组的第p2个元素。</target>
        </trans-unit>
        <trans-unit id="ad1bbf355e84d3c7a49f4b2d106cdd6317b07ee3" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to the VM containing the trigger program.</source>
          <target state="translated">P4是指向包含触发程序的VM的指针。</target>
        </trans-unit>
        <trans-unit id="f47594ef27452803fbd06eb33f15569fa2ff24ae" translate="yes" xml:space="preserve">
          <source>P4 is a string that is P2 characters long. The N-th character of the string indicates the column affinity that should be used for the N-th memory cell in the range.</source>
          <target state="translated">P4是一个长为P2字符的字符串。字符串的第N个字符表示该范围内的第N个内存单元格应该使用的列亲和力。</target>
        </trans-unit>
        <trans-unit id="990f075b203cf5ad046ffef4a8c3f52f5d8e8021" translate="yes" xml:space="preserve">
          <source>P4 is always of type P4_ADVANCE. The function pointer points to sqlite3BtreeNext().</source>
          <target state="translated">P4总是类型为P4_ADVANCE。函数指针指向sqlite3BtreeNext()。</target>
        </trans-unit>
        <trans-unit id="33ef9db58085779c3fa7810a9ac7b841027b65e6" translate="yes" xml:space="preserve">
          <source>P4 is always of type P4_ADVANCE. The function pointer points to sqlite3BtreePrevious().</source>
          <target state="translated">P4总是类型为P4_ADVANCE。函数指针指向sqlite3BtreePrevious()。</target>
        </trans-unit>
        <trans-unit id="d1b9c8ecf53ced9f246c4b6e555cd6111c1ca23e" translate="yes" xml:space="preserve">
          <source>P4 is either NULL or a string that was generated by the xBestIndex method of the module. The interpretation of the P4 string is left to the module implementation.</source>
          <target state="translated">P4是NULL或由模块的xBestIndex方法生成的字符串。P4字符串的解释由模块执行。</target>
        </trans-unit>
        <trans-unit id="c28c1dcafe0312975199fcb1fcfbb17e24dd7d0c" translate="yes" xml:space="preserve">
          <source>P4 is the name of a virtual table in database P1. Call the xDestroy method of that table.</source>
          <target state="translated">P4是数据库P1中一个虚拟表的名称。调用该表的xDestroy方法。</target>
        </trans-unit>
        <trans-unit id="b1c200e3bc2517ade0a0775a576b9a6ce0d06b98" translate="yes" xml:space="preserve">
          <source>P4 may be a pointer to an sqlite3_vtab structure. If so, call the xBegin method for that table.</source>
          <target state="translated">P4可能是一个指向sqlite3_vtab结构的指针。如果是这样的话,调用该表的xBegin方法。</target>
        </trans-unit>
        <trans-unit id="946a7239230e3ec0a9c66885447aaf26ad8bc930" translate="yes" xml:space="preserve">
          <source>P4 may be a string that is P2 characters long. The N-th character of the string indicates the column affinity that should be used for the N-th field of the index key.</source>
          <target state="translated">P4可以是一个长为P2字符的字符串。字符串的第N个字符表示索引键的第N个字段应该使用的列亲和力。</target>
        </trans-unit>
        <trans-unit id="69adfac261137322671a1ca5cef4f8a650bcfbae" translate="yes" xml:space="preserve">
          <source>P4 may be an array of integers (type P4_INTARRAY) containing one entry for each column in the P3 table. If array entry a(i) is non-zero, then reading column a(i)-1 from cursor P3 is equivalent to performing the deferred seek and then reading column i from P1. This information is stored in P3 and used to redirect reads against P3 over to P1, thus possibly avoiding the need to seek and read cursor P3.</source>
          <target state="translated">P4可以是一个整数数组(类型为P4_INTARRAY),包含P3表中每一列的一个条目。如果数组条目a(i)是非零,那么从游标P3中读取列a(i)-1相当于执行延迟查找,然后从P1中读取列i。这个信息存储在P3中,用于将对P3的读取重定向到P1,从而可能避免寻找和读取游标P3。</target>
        </trans-unit>
        <trans-unit id="2b3aae431e84b9e296011557b13fc95c59d8a3fe" translate="yes" xml:space="preserve">
          <source>P4 points to a blob of data P1 bytes long. Store this blob in register P2.</source>
          <target state="translated">P4指向一个P1字节长的数据blob。将此blob存储在寄存器P2中。</target>
        </trans-unit>
        <trans-unit id="5f1f77c01d77787acda0ee06f04f3dd3dab581c9" translate="yes" xml:space="preserve">
          <source>P4 points to a nul terminated UTF-8 string. This opcode is transformed into a &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; opcode before it is executed for the first time. During this transformation, the length of string P4 is computed and stored as the P1 parameter.</source>
          <target state="translated">P4指向以零终止的UTF-8字符串。该操作码在首次执行之前会转换为&lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt;操作码。在此转换过程中，将计算字符串P4的长度并将其存储为P1参数。</target>
        </trans-unit>
        <trans-unit id="8c8ae2d7e0dfc4268ff56cfc9e2e47a67fc1ddaf" translate="yes" xml:space="preserve">
          <source>P5 is a value between 0 and 4, inclusive, that modifies the P4 string.</source>
          <target state="translated">P5是一个介于0到4之间(含)的值,用于修改P4字符串。</target>
        </trans-unit>
        <trans-unit id="e03c8fcb835da321a7966f8a1cfc9fb80046f7b0" translate="yes" xml:space="preserve">
          <source>P5 is the error actions (OE_Replace, OE_Fail, OE_Ignore, etc) to apply in the case of a constraint failure on an insert or update.</source>
          <target state="translated">P5是在插入或更新的约束失败的情况下,应用的错误操作(OE_Replace、OE_Fail、OE_Ignore等)。</target>
        </trans-unit>
        <trans-unit id="b092db6b7249be33e50e9f2a75c65696bf56d25e" translate="yes" xml:space="preserve">
          <source>P5 ought to be set on every call to this opcode. However, there are places in the code generator will release registers before their are used, under the (valid) assumption that the registers will not be reallocated for some other purpose before they are used and hence are safe to release.</source>
          <target state="translated">P5应该在每次调用该操作码时被设置。然而,在代码生成器中,有一些地方会在使用前释放寄存器,前提是(有效的)假设这些寄存器在使用前不会被重新分配用于其他目的,因此可以安全释放。</target>
        </trans-unit>
        <trans-unit id="d23183b7ef6b3cfee6722e9cab664f9eba24c080" translate="yes" xml:space="preserve">
          <source>PARTITION</source>
          <target state="translated">PARTITION</target>
        </trans-unit>
        <trans-unit id="7c423f3264effc4f744de4e6255ff034137bcc1e" translate="yes" xml:space="preserve">
          <source>PASSIVE</source>
          <target state="translated">PASSIVE</target>
        </trans-unit>
        <trans-unit id="418f304013689ba52fc7c27eebb7dcb9d2ced563" translate="yes" xml:space="preserve">
          <source>PDF - Portable Document Format from Adobe</source>
          <target state="translated">PDF-Adobe公司的便携式文档格式</target>
        </trans-unit>
        <trans-unit id="0a7b38b716933a39c0bca66f229cd6d52f0c1271" translate="yes" xml:space="preserve">
          <source>PENDING</source>
          <target state="translated">PENDING</target>
        </trans-unit>
        <trans-unit id="5a61e634ec49d3919b83a13434809a009040ffa1" translate="yes" xml:space="preserve">
          <source>PLAN</source>
          <target state="translated">PLAN</target>
        </trans-unit>
        <trans-unit id="4b01f0d6c5bf45bcaa85e117787de16b76894b18" translate="yes" xml:space="preserve">
          <source>POSIX locking style. This is the default locking style and the style used by other (non Mac OS X) Unixes. Locks are obtained and released using the fcntl() system call.</source>
          <target state="translated">POSIX 锁定风格,这是默认的锁定风格,也是其他(非 Mac OS X)Unix 使用的风格。这是默认的锁定方式,也是其他Unix(非Mac OS X)使用的方式。使用fcntl()系统调用获得和释放锁。</target>
        </trans-unit>
        <trans-unit id="304e41f1b7440f605b6d901a3f56679fe5127675" translate="yes" xml:space="preserve">
          <source>PPT - Microsoft PowerPoint presentations</source>
          <target state="translated">PPT-微软PowerPoint演示文稿</target>
        </trans-unit>
        <trans-unit id="eb3b3e1144fc0ba039acb3375dbf811550aeb6d8" translate="yes" xml:space="preserve">
          <source>PRAGMA</source>
          <target state="translated">PRAGMA</target>
        </trans-unit>
        <trans-unit id="2031386335ef51b174ad3b83ba1c813522943aeb" translate="yes" xml:space="preserve">
          <source>PRAGMA Statements</source>
          <target state="translated">PRAGMA声明</target>
        </trans-unit>
        <trans-unit id="dd8e7015522cfd4dcf823317fdfa144e1ffa8793" translate="yes" xml:space="preserve">
          <source>PRAGMA application_id</source>
          <target state="translated">PRAGMA application_id</target>
        </trans-unit>
        <trans-unit id="4272fe5aa2578d44c85ef586cbdb481255d6ef40" translate="yes" xml:space="preserve">
          <source>PRAGMA auto_vacuum</source>
          <target state="translated">PRAGMA auto_vacuum</target>
        </trans-unit>
        <trans-unit id="ecdb75c7d78bb2d218243fd805db4a0952130227" translate="yes" xml:space="preserve">
          <source>PRAGMA automatic_index</source>
          <target state="translated">PRAGMA automatic_index</target>
        </trans-unit>
        <trans-unit id="06f21794e50e9014cbc68dddc08b0afe728a2339" translate="yes" xml:space="preserve">
          <source>PRAGMA busy_timeout</source>
          <target state="translated">PRAGMA busy_timeout</target>
        </trans-unit>
        <trans-unit id="0079a2a1c563d3a80935f663efd9c2f3f214bd31" translate="yes" xml:space="preserve">
          <source>PRAGMA cache_size</source>
          <target state="translated">PRAGMA cache_size</target>
        </trans-unit>
        <trans-unit id="53830be86cc01d9861a99c96b4baf9389520d439" translate="yes" xml:space="preserve">
          <source>PRAGMA cache_spill</source>
          <target state="translated">PRAGMA cache_spill</target>
        </trans-unit>
        <trans-unit id="c62c55dc2230d9ef14955c77928155e6ec4c7ae3" translate="yes" xml:space="preserve">
          <source>PRAGMA case_sensitive_like</source>
          <target state="translated">PRAGMA case_sensitive_like。</target>
        </trans-unit>
        <trans-unit id="629aac38c33c9e2128ff55cc2623e94247525dd5" translate="yes" xml:space="preserve">
          <source>PRAGMA cell_size_check</source>
          <target state="translated">PRAGMA cell_size_check</target>
        </trans-unit>
        <trans-unit id="f7a6fea31875d2709fc8636382fa71e3e405a8bd" translate="yes" xml:space="preserve">
          <source>PRAGMA checkpoint_fullfsync</source>
          <target state="translated">PRAGMA checkpoint_fullfsync.</target>
        </trans-unit>
        <trans-unit id="c3bb771e91f755dbbaf486313dfb86863abb68c6" translate="yes" xml:space="preserve">
          <source>PRAGMA collation_list</source>
          <target state="translated">PRAGMA collation_list</target>
        </trans-unit>
        <trans-unit id="03029df867e6189d3cb8be071de311b5adc094ca" translate="yes" xml:space="preserve">
          <source>PRAGMA command syntax</source>
          <target state="translated">PRAGMA命令的语法</target>
        </trans-unit>
        <trans-unit id="41b472d1fbef46bb9f050319914604b6fc2ba68d" translate="yes" xml:space="preserve">
          <source>PRAGMA compile_options</source>
          <target state="translated">PRAGMA compile_options</target>
        </trans-unit>
        <trans-unit id="c654b246f7037e0f8929e3e045a813d87f20921d" translate="yes" xml:space="preserve">
          <source>PRAGMA count_changes</source>
          <target state="translated">PRAGMA count_changes</target>
        </trans-unit>
        <trans-unit id="e558ad585b01cc3a4aa52bb53490182d9eacc4e8" translate="yes" xml:space="preserve">
          <source>PRAGMA data_store_directory</source>
          <target state="translated">PRAGMA data_store_directory</target>
        </trans-unit>
        <trans-unit id="9a7e5a694b84807a56ec0b72b64b9c9c84d92f92" translate="yes" xml:space="preserve">
          <source>PRAGMA data_version</source>
          <target state="translated">PRAGMA data_version</target>
        </trans-unit>
        <trans-unit id="71f193736d432d273c489df59218224a1bd26bb0" translate="yes" xml:space="preserve">
          <source>PRAGMA database_list</source>
          <target state="translated">PRAGMA database_list</target>
        </trans-unit>
        <trans-unit id="d2b0abac3ff561286d0f244f1229dbe0d7c413ba" translate="yes" xml:space="preserve">
          <source>PRAGMA default_cache_size</source>
          <target state="translated">PRAGMA default_cache_size</target>
        </trans-unit>
        <trans-unit id="baa9b0985d524aa3c28f49ac66dec16e57647a96" translate="yes" xml:space="preserve">
          <source>PRAGMA defer_foreign_keys</source>
          <target state="translated">PRAGMA defer_foreign_keys.</target>
        </trans-unit>
        <trans-unit id="5a13b54115c31e192bafba5863e3b69f614ae8e0" translate="yes" xml:space="preserve">
          <source>PRAGMA empty_result_callbacks</source>
          <target state="translated">PRAGMA empty_result_callbacks。</target>
        </trans-unit>
        <trans-unit id="464f0c2fc86d3a8263fffd42239b50d53989d1da" translate="yes" xml:space="preserve">
          <source>PRAGMA encoding</source>
          <target state="translated">PRAGMA编码</target>
        </trans-unit>
        <trans-unit id="5a35e091ec7521a831d067bdc90ecb017a359b26" translate="yes" xml:space="preserve">
          <source>PRAGMA foreign_key_check</source>
          <target state="translated">PRAGMA foreign_key_check</target>
        </trans-unit>
        <trans-unit id="4f9cabaf50d87f897238e4cfca01cbf9a956476a" translate="yes" xml:space="preserve">
          <source>PRAGMA foreign_key_list</source>
          <target state="translated">PRAGMA foreign_key_list</target>
        </trans-unit>
        <trans-unit id="c26430dedacc940c37179bc2ab043a40726e60aa" translate="yes" xml:space="preserve">
          <source>PRAGMA foreign_keys</source>
          <target state="translated">PRAGMA foreign_keys</target>
        </trans-unit>
        <trans-unit id="f6f4d8a618687004328fc80c2fe129e8548fb446" translate="yes" xml:space="preserve">
          <source>PRAGMA freelist_count</source>
          <target state="translated">PRAGMA freelist_count</target>
        </trans-unit>
        <trans-unit id="a1a0446b52b0c9481ab686d03b259ad5f54f8cce" translate="yes" xml:space="preserve">
          <source>PRAGMA full_column_names</source>
          <target state="translated">PRAGMA full_column_names</target>
        </trans-unit>
        <trans-unit id="19952a9490a74b7cefcba8ae3ffcd4c6cd36c908" translate="yes" xml:space="preserve">
          <source>PRAGMA fullfsync</source>
          <target state="translated">PRAGMA fullfsync</target>
        </trans-unit>
        <trans-unit id="9b4ca9a487733d7c417ae8784f57aa1ed11b34f0" translate="yes" xml:space="preserve">
          <source>PRAGMA fullfsync=ON;</source>
          <target state="translated">PRAGMA fullfsync=ON。</target>
        </trans-unit>
        <trans-unit id="327858b59b9cfef735d94d93f6b85bcef5690111" translate="yes" xml:space="preserve">
          <source>PRAGMA function</source>
          <target state="translated">PRAGMA功能</target>
        </trans-unit>
        <trans-unit id="2a0bacb7b9cc513abddcbbe743f428bab68dfa8c" translate="yes" xml:space="preserve">
          <source>PRAGMA function_list</source>
          <target state="translated">PRAGMA function_list</target>
        </trans-unit>
        <trans-unit id="e837cb07b592292e4ed84f750d66cb314f82a9c5" translate="yes" xml:space="preserve">
          <source>PRAGMA functions</source>
          <target state="translated">PRAGMA职能</target>
        </trans-unit>
        <trans-unit id="f7e42e33fd73efd0a92d36f4ff6b3819913f9bc4" translate="yes" xml:space="preserve">
          <source>PRAGMA ignore_check_constraints</source>
          <target state="translated">PRAGMA ignore_check_constraints.</target>
        </trans-unit>
        <trans-unit id="cd58bb64e6b2a173c5b581b0cb503c85da1dbd24" translate="yes" xml:space="preserve">
          <source>PRAGMA incremental_vacuum</source>
          <target state="translated">PRAGMA incremental_vacuum(增量式真空)</target>
        </trans-unit>
        <trans-unit id="652aaaf1f9e0a84122b69d9954ec064ee9d02a48" translate="yes" xml:space="preserve">
          <source>PRAGMA index_info</source>
          <target state="translated">PRAGMA index_info</target>
        </trans-unit>
        <trans-unit id="125af8cf007c5ae9f4a12bfd4e392de5088aeebd" translate="yes" xml:space="preserve">
          <source>PRAGMA index_list</source>
          <target state="translated">PRAGMA index_list</target>
        </trans-unit>
        <trans-unit id="2da953925bb8a4bec48afa57978cfa755a68b864" translate="yes" xml:space="preserve">
          <source>PRAGMA index_xinfo</source>
          <target state="translated">PRAGMA index_xinfo</target>
        </trans-unit>
        <trans-unit id="a0a681b89ba9014d636bfe01c90f033d409952e9" translate="yes" xml:space="preserve">
          <source>PRAGMA integrity_check</source>
          <target state="translated">PRAGMA integrity_check</target>
        </trans-unit>
        <trans-unit id="47cd2260e4aae51e91f7618b4491c7a57dbd31aa" translate="yes" xml:space="preserve">
          <source>PRAGMA integrity_check does not find &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt; errors. Use the &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; command for to find errors in FOREIGN KEY constraints.</source>
          <target state="translated">PRAGMA integrity_check找不到&lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt;错误。使用&lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt;命令查找FOREIGN KEY约束中的错误。</target>
        </trans-unit>
        <trans-unit id="fed086b5dc8e5ae4d059caf4aa86921613ca6bce" translate="yes" xml:space="preserve">
          <source>PRAGMA integrity_check does not find &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt; errors. Use the &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; command to find errors in FOREIGN KEY constraints.</source>
          <target state="translated">PRAGMA integrity_check找不到&lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt;错误。使用&lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt;命令查找FOREIGN KEY约束中的错误。</target>
        </trans-unit>
        <trans-unit id="0e40c9bb92f26ef5f07d9f3367463e8597505eee" translate="yes" xml:space="preserve">
          <source>PRAGMA journal_mode</source>
          <target state="translated">PRAGMA log_mode</target>
        </trans-unit>
        <trans-unit id="0dc7949f2c37427da3286461ab0d99c192b23454" translate="yes" xml:space="preserve">
          <source>PRAGMA journal_size_limit</source>
          <target state="translated">PRAGMA journal_size_limit</target>
        </trans-unit>
        <trans-unit id="1d1d61ff55f21546bb199472fc5fb09c63e7801f" translate="yes" xml:space="preserve">
          <source>PRAGMA legacy_alter_table</source>
          <target state="translated">PRAGMA legacy_alter_table</target>
        </trans-unit>
        <trans-unit id="1d7e28dc08cc03a9bb08dd39291f00ea3a00d6ce" translate="yes" xml:space="preserve">
          <source>PRAGMA legacy_file_format</source>
          <target state="translated">PRAGMA legacy_file_format.</target>
        </trans-unit>
        <trans-unit id="e05eb926ae67395e18a7ff48872e6bf6de93826e" translate="yes" xml:space="preserve">
          <source>PRAGMA locking_mode</source>
          <target state="translated">PRAGMA locking_mode</target>
        </trans-unit>
        <trans-unit id="a71f8b9f21a1c76ece9dc64397bce57f203e4519" translate="yes" xml:space="preserve">
          <source>PRAGMA max_page_count</source>
          <target state="translated">PRAGMA max_page_count</target>
        </trans-unit>
        <trans-unit id="3aba9ed125640a69838f81731ba34ebdf094d76a" translate="yes" xml:space="preserve">
          <source>PRAGMA mmap_size</source>
          <target state="translated">PRAGMA mmap_size</target>
        </trans-unit>
        <trans-unit id="c29ccc2a4945dfe06f8af7b8b574f07e8a513dc7" translate="yes" xml:space="preserve">
          <source>PRAGMA module_list</source>
          <target state="translated">PRAGMA模块列表</target>
        </trans-unit>
        <trans-unit id="ed5cd9ca526909b51a8497a39931b7a730a4b534" translate="yes" xml:space="preserve">
          <source>PRAGMA optimize</source>
          <target state="translated">PRAGMA优化</target>
        </trans-unit>
        <trans-unit id="9618d59586d55b1fe7cf6403a08d5878deeff0b2" translate="yes" xml:space="preserve">
          <source>PRAGMA page_count</source>
          <target state="translated">PRAGMA page_count</target>
        </trans-unit>
        <trans-unit id="73b1778335144273f1b55bbda71292b3236c2f7c" translate="yes" xml:space="preserve">
          <source>PRAGMA page_size</source>
          <target state="translated">PRAGMA page_size</target>
        </trans-unit>
        <trans-unit id="0c33d6f9f55335baef42453f3966f2ae2790fe21" translate="yes" xml:space="preserve">
          <source>PRAGMA parser_trace</source>
          <target state="translated">PRAGMA parser_trace</target>
        </trans-unit>
        <trans-unit id="987c5140e9a3de6520e0e9a5de928a2bd5f2af7c" translate="yes" xml:space="preserve">
          <source>PRAGMA synchronous=FULL;</source>
          <target state="translated">PRAGMA synchronous=FULL;</target>
        </trans-unit>
        <trans-unit id="c40b0db1ea40d45cf9c01804a3ada577b8b752ae" translate="yes" xml:space="preserve">
          <source>PRAGMA temp_store_directory = ''</source>
          <target state="translated">PRAGMA temp_store_directory=''。</target>
        </trans-unit>
        <trans-unit id="0662bf3087347b5b0ecf25fecad0c21f9bfb340d" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_addoptrace</source>
          <target state="translated">PRAGMA vdbe_addoptrace .</target>
        </trans-unit>
        <trans-unit id="ed607acfa6bacfc2bc133e1d2e829c3c31c8a51c" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_debug</source>
          <target state="translated">PRAGMA vdbe_debug。</target>
        </trans-unit>
        <trans-unit id="f5251eb4d3acd0707857877ee684d1bef0e741e2" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_listing</source>
          <target state="translated">PRAGMA vdbe_listing</target>
        </trans-unit>
        <trans-unit id="319d369f27e5d322702e5eca965b605f26e48c8b" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_trace</source>
          <target state="translated">PRAGMA vdbe_trace</target>
        </trans-unit>
        <trans-unit id="f0a71878598fa251896a1bb5f07402743f02c1c6" translate="yes" xml:space="preserve">
          <source>PRAGMAs that return results and that have no side-effects can be accessed from ordinary &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements as &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;. For each participating PRAGMA, the corresponding table-valued function has the same name as the PRAGMA with a 7-character &quot;pragma_&quot; prefix. The PRAGMA argument and schema, if any, are passed as arguments to the table-valued function.</source>
          <target state="translated">可以从普通&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句作为&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;访问返回结果且没有副作用的PRAGMA 。对于每个参与的PRAGMA，对应的表值函数的名称与PRAGMA的名称相同，前缀为7个字符。PRAGMA参数和模式（如果有的话）作为参数传递给表值函数。</target>
        </trans-unit>
        <trans-unit id="f5e246fc197bcab96dcc71246fd51e046d154a6b" translate="yes" xml:space="preserve">
          <source>PRECEDING</source>
          <target state="translated">PRECEDING</target>
        </trans-unit>
        <trans-unit id="ed15de08f42371953d12d6c433f3d7a83e50d659" translate="yes" xml:space="preserve">
          <source>PRIMARY</source>
          <target state="translated">PRIMARY</target>
        </trans-unit>
        <trans-unit id="5d81ed20f739b911f425c9e71391691185dad6d3" translate="yes" xml:space="preserve">
          <source>PRIMARY KEY constraint</source>
          <target state="translated">第一主键约束</target>
        </trans-unit>
        <trans-unit id="fcdd367db6d48a1ca9ffb0132d54992dd930544d" translate="yes" xml:space="preserve">
          <source>Page 1 and the Expected Page Size</source>
          <target state="translated">第1页和预期的页面大小</target>
        </trans-unit>
        <trans-unit id="626d2e810cbdab389ce5499e79846105d079da1c" translate="yes" xml:space="preserve">
          <source>Page 1 of a database file is the root page of a table b-tree that holds a special table named &quot;&lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt;&quot;. This b-tree is known as the &quot;schema table&quot; since it stores the complete database schema. The structure of the sqlite_schema table is as if it had been created using the following SQL:</source>
          <target state="translated">数据库文件的第1页是表b-树的根页，其中包含一个名为&amp;ldquo; &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; &amp;rdquo;的特殊表。该b树被称为&amp;ldquo;模式表&amp;rdquo;，因为它存储了完整的数据库模式。sqlite_schema表的结构就像是使用以下SQL创建的：</target>
        </trans-unit>
        <trans-unit id="e0da1c304b873d5c4bfe7eb2116e8b2b93162178" translate="yes" xml:space="preserve">
          <source>Page 1 of a database file is the root page of a table b-tree that holds a special table named &quot;sqlite_master&quot; (or &quot;sqlite_temp_master&quot; in the case of a TEMP database) which stores the complete database schema. The structure of the sqlite_master table is as if it had been created using the following SQL:</source>
          <target state="translated">数据库文件的第1页是表b-tree的根页,其中存放着一个名为 &quot;sqlite_master&quot;(在TEMP数据库中为 &quot;sqlite_temp_master&quot;)的特殊表,该表存储着完整的数据库模式。sqlite_master表的结构就像使用下面的SQL创建的一样。</target>
        </trans-unit>
        <trans-unit id="bb98169c72c2e0218852294c4088a714e55ae813" translate="yes" xml:space="preserve">
          <source>Page Cache</source>
          <target state="translated">页面缓存</target>
        </trans-unit>
        <trans-unit id="111e3d8b941451e6256ee0ce1fa5b2560f773697" translate="yes" xml:space="preserve">
          <source>Page Cache Algorithms</source>
          <target state="translated">页面缓存算法</target>
        </trans-unit>
        <trans-unit id="51e73b0787f74035c32eccb9bca14aa82436008b" translate="yes" xml:space="preserve">
          <source>Page Cache Configuration</source>
          <target state="translated">页面缓存配置</target>
        </trans-unit>
        <trans-unit id="91dcdd907d00efb6c274aa541e77d89ded5b848c" translate="yes" xml:space="preserve">
          <source>Page cache memory allocations that overflow into the general-purpose memory allocator.</source>
          <target state="translated">页缓存内存分配,溢出到通用内存分配器。</target>
        </trans-unit>
        <trans-unit id="8b08ca42225d56c2d889ece253767100d76e7c2a" translate="yes" xml:space="preserve">
          <source>Page number</source>
          <target state="translated">页数</target>
        </trans-unit>
        <trans-unit id="ad392683af791420db4e7324c20464059ce3492a" translate="yes" xml:space="preserve">
          <source>Page number of first overflow page</source>
          <target state="translated">第一个溢出页的页数</target>
        </trans-unit>
        <trans-unit id="6e528c19af566e5c19716241accd44732b15c3f1" translate="yes" xml:space="preserve">
          <source>Page number of left child</source>
          <target state="translated">左边孩子的页数</target>
        </trans-unit>
        <trans-unit id="1d20e1ca269b0f7a9ac2bdd34ee817b875d0828b" translate="yes" xml:space="preserve">
          <source>Page number of the first freelist trunk page.</source>
          <target state="translated">第一个自由列表主干页的页码。</target>
        </trans-unit>
        <trans-unit id="2f6078feea4fe70e006a40f0bbe8960bf8454aee" translate="yes" xml:space="preserve">
          <source>Pagecache memory allocator</source>
          <target state="translated">Pagecache内存分配器</target>
        </trans-unit>
        <trans-unit id="7a89afd5ef39a4cff0b861ab314756ac6e516da0" translate="yes" xml:space="preserve">
          <source>Pagecount</source>
          <target state="translated">Pagecount</target>
        </trans-unit>
        <trans-unit id="2a084ba7d77808cea5a5f8f9c1ab34ab55b7585a" translate="yes" xml:space="preserve">
          <source>Pager and btree subsystems removed. These will be used in a follow-on SQL server library named &quot;SQLus&quot;.</source>
          <target state="translated">删除了Pager和btree子系统。这些系统将在后续的SQL服务器库 &quot;SQLus &quot;中使用。</target>
        </trans-unit>
        <trans-unit id="d03660f900d198f933a03da740944dbf17018900" translate="yes" xml:space="preserve">
          <source>Pager subsystem added but not yet used.</source>
          <target state="translated">增加了寻呼机子系统,但还没有使用。</target>
        </trans-unit>
        <trans-unit id="70384aa891f4780133eb9e575d0bd72469e20f4e" translate="yes" xml:space="preserve">
          <source>Pages are numbered beginning with 1. The maximum page number is 2147483646 (2&lt;sup&gt;&lt;small&gt;31&lt;/small&gt;&lt;/sup&gt; - 2). The minimum size SQLite database is a single 512-byte page. The maximum size database would be 2147483646 pages at 65536 bytes per page or 140,737,488,224,256 bytes (about 140 terabytes). Usually SQLite will hit the maximum file size limit of the underlying filesystem or disk hardware long before it hits its own internal size limit.</source>
          <target state="translated">页编号以1开始的最大页数量是2147483646（2 &lt;sup&gt;&lt;small&gt;31&lt;/small&gt;&lt;/sup&gt; - 2）。最小大小的SQLite数据库是一个512字节的页面。数据库的最大大小为2147483646页，每页65536字节，即140,737,488,224,256字节（约140 TB）。通常，SQLite在达到自己的内部大小限制之前，将达到基础文件系统或磁盘硬件的最大文件大小限制。</target>
        </trans-unit>
        <trans-unit id="a6bf70b89378b1b3ed63fb1aa677ec02aea17bdf" translate="yes" xml:space="preserve">
          <source>Pages are numbered beginning with 1. The maximum page number is 4294967294 (2&lt;sup&gt;&lt;small&gt;32&lt;/small&gt;&lt;/sup&gt; - 2). The minimum size SQLite database is a single 512-byte page. The maximum size database would be 2147483646 pages at 65536 bytes per page or 281,474,976,579,584 bytes (about 281 terabytes). Usually SQLite will hit the maximum file size limit of the underlying filesystem or disk hardware long before it hits its own internal size limit.</source>
          <target state="translated">页编号以1开始的最大页数量是4294967294（2 &lt;sup&gt;&lt;small&gt;32&lt;/small&gt;&lt;/sup&gt; - 2）。最小大小的SQLite数据库是一个512字节的页面。数据库的最大大小为2147483646页，每页65536字节，即281,474,976,579,584字节（约281 TB）。通常，SQLite在达到自己的内部大小限制之前，将达到基础文件系统或磁盘硬件的最大文件大小限制。</target>
        </trans-unit>
        <trans-unit id="0f332eeefd007bb0043ccb46738196508c6a602b" translate="yes" xml:space="preserve">
          <source>Param</source>
          <target state="translated">Param</target>
        </trans-unit>
        <trans-unit id="f699f295e5ae4ac633cfa18437fed38d028b3fdb" translate="yes" xml:space="preserve">
          <source>Parameter</source>
          <target state="translated">Parameter</target>
        </trans-unit>
        <trans-unit id="8b81f4321a39e53a61cf8fbe1b4d654902c2cd89" translate="yes" xml:space="preserve">
          <source>Parameter P4 may point to a Table structure, or may be NULL. If it is not NULL, then the update-hook (sqlite3.xUpdateCallback) is invoked following a successful insert.</source>
          <target state="translated">参数P4可以指向一个表结构,也可以是NULL。如果参数P4不是NULL,那么在成功插入后会调用更新钩子(sqlite3.xUpdateCallback)。</target>
        </trans-unit>
        <trans-unit id="a5652d036064588f8b6a1cd35001bca04abb6577" translate="yes" xml:space="preserve">
          <source>Parameter zDb is not the filename that contains the database, but rather the symbolic name of the database. For attached databases, this is the name that appears after the AS keyword in the &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. For the main database file, the database name is &quot;main&quot;. For TEMP tables, the database name is &quot;temp&quot;.</source>
          <target state="translated">参数zDb不是包含数据库的文件名，而是数据库的符号名称。对于附加的数据库，这是在&lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;语句中的AS关键字之后显示的名称。对于主数据库文件，数据库名称为&amp;ldquo; main&amp;rdquo;。对于TEMP表，数据库名称为&amp;ldquo; temp&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6b3dbfca494676dd202b93efd1413416a69fb138" translate="yes" xml:space="preserve">
          <source>Parameter zDb is not the filename that contains the database, but rather the symbolic name of the database. For attached databases, this is the name that appears after the AS keyword in the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. For the main database file, the database name is &quot;main&quot;. For TEMP tables, the database name is &quot;temp&quot;.</source>
          <target state="translated">参数zDb不是包含数据库的文件名，而是数据库的符号名称。对于附加的数据库，这是在&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;语句中的AS关键字之后显示的名称。对于主数据库文件，数据库名称为&amp;ldquo; main&amp;rdquo;。对于TEMP表，数据库名称为&amp;ldquo; temp&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="799e97b7e20fea27a8af5b85f72a1e45ff70f20e" translate="yes" xml:space="preserve">
          <source>Parameters can be either named or unnamed. An unnamed parameter is a single question mark (&quot;?&quot;). Named parameters are a &quot;?&quot; followed immediately by a number (ex: &quot;?15&quot; or &quot;?123&quot;) or one of the characters &quot;$&quot;, &quot;:&quot;, or &quot;@&quot; followed by an alphanumeric name (ex: &quot;$var1&quot;, &quot;:xyz&quot;, &quot;@bingo&quot;).</source>
          <target state="translated">参数可以是命名的,也可以是未命名的。未命名的参数是一个问号(&quot;?&quot;)。已命名的参数是一个&quot;?&quot;,后面紧跟着一个数字(例如:&quot;?15 &quot;或&quot;?123&quot;),或者&quot;$&quot;、&quot;:&quot;或&quot;@&quot;中的一个字符,后面跟着一个字母数字名称(例如:&quot;$var1&quot;、&quot;:xyz&quot;、&quot;@bingo&quot;)。</target>
        </trans-unit>
        <trans-unit id="8cba5f18115ee2b196f01cd67b537bb6b53bf7ec" translate="yes" xml:space="preserve">
          <source>Parameters that are not assigned values using &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; are treated as NULL. The &lt;a href=&quot;c3ref/bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; interface can be used to translate a symbolic parameter name into its equivalent numeric index.</source>
          <target state="translated">未使用&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind（）&lt;/a&gt;分配值的参数被视为NULL。所述&lt;a href=&quot;c3ref/bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index（）&lt;/a&gt;接口可用于一个符号参数名称翻译成它的等效数字索引。</target>
        </trans-unit>
        <trans-unit id="4de5d1891af8779fc1d212b882aca704731f9909" translate="yes" xml:space="preserve">
          <source>Parent and child keys must have the same cardinality. In SQLite, if any of the child key columns (in this case songartist and songalbum) are NULL, then there is no requirement for a corresponding row in the parent table.</source>
          <target state="translated">父键和子键必须具有相同的cardinality。在SQLite中,如果任何一个子键列(在本例中songartist和songalbum)是NULL,那么就不需要在父表中有对应的记录。</target>
        </trans-unit>
        <trans-unit id="f4093b4053e6e304b33edcd1e545c7ac44407405" translate="yes" xml:space="preserve">
          <source>Parent table</source>
          <target state="translated">母表</target>
        </trans-unit>
        <trans-unit id="4e28259727cc9bea774f5aa837a0a46e7e8f6e3d" translate="yes" xml:space="preserve">
          <source>Parentheses around the column name are ignored. Hence if X and Y.Z are column names, then (X) and (Y.Z) are also considered column names and have the affinity of the corresponding columns.</source>
          <target state="translated">列名周围的括号会被忽略。因此,如果X和Y.Z是列名,那么(X)和(Y.Z)也被认为是列名,具有相应列的亲和力。</target>
        </trans-unit>
        <trans-unit id="e9b3806832484c8806fbc046fab28912aa2aa64c" translate="yes" xml:space="preserve">
          <source>Parenthesis are not supported.</source>
          <target state="translated">不支持括号。</target>
        </trans-unit>
        <trans-unit id="75d39bc816f04be94a422f23dd0120a1ebf6cf81" translate="yes" xml:space="preserve">
          <source>Parenthesis may be used to group expressions in order to modify operator precedence in the usual ways. For example:</source>
          <target state="translated">可以用括号将表达式分组,以便用通常的方式修改运算符的优先性。例如:</target>
        </trans-unit>
        <trans-unit id="a5d92895b79471a4a9fa3ce0a6ffdf64945a6880" translate="yes" xml:space="preserve">
          <source>Parse (but do not implement) foreign keys.</source>
          <target state="translated">解析(但不执行)外键。</target>
        </trans-unit>
        <trans-unit id="c98796aa2add46f2617d36d2c94c638a1c0df012" translate="yes" xml:space="preserve">
          <source>ParseSchema</source>
          <target state="translated">ParseSchema</target>
        </trans-unit>
        <trans-unit id="1b3cf5033ed01a4fcbff3f2957e66cfe44af45a9" translate="yes" xml:space="preserve">
          <source>Parser</source>
          <target state="translated">Parser</target>
        </trans-unit>
        <trans-unit id="e5dde1d1ec704f9acd81aeb949908d6d48dedf9c" translate="yes" xml:space="preserve">
          <source>Parser detects and reports automaton stack overflow.</source>
          <target state="translated">解析器检测并报告自动机栈溢出。</target>
        </trans-unit>
        <trans-unit id="de7186ac205c0a4d05d1b7e13d0477c901e264d5" translate="yes" xml:space="preserve">
          <source>Parsing Ambiguity</source>
          <target state="translated">解析模糊性</target>
        </trans-unit>
        <trans-unit id="6893b79566df0f4ab433d9b0d800d95d1637ec25" translate="yes" xml:space="preserve">
          <source>Partial Indexes</source>
          <target state="translated">部分索引</target>
        </trans-unit>
        <trans-unit id="b83a6d7f720f864139ebf6cd22707c1309f4af67" translate="yes" xml:space="preserve">
          <source>Partial index causes assertion fault on UPDATE OR REPLACE. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/2ea3e9fe63&quot;&gt;2ea3e9fe63&lt;/a&gt;</source>
          <target state="translated">部分索引导致UPDATE或REPLACE上的断言错误。门票&lt;a href=&quot;http://www.sqlite.org/src/info/2ea3e9fe63&quot;&gt;2ea3e9fe63&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74f02a08dcb98cd96d7cf448a85669448cde0119" translate="yes" xml:space="preserve">
          <source>Partial index causes assertion fault on UPDATE OR REPLACE. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/2ea3e9fe63&quot;&gt;2ea3e9fe63&lt;/a&gt;</source>
          <target state="translated">部分索引会导致UPDATE或REPLACE上的断言错误。门票&lt;a href=&quot;https://www.sqlite.org/src/info/2ea3e9fe63&quot;&gt;2ea3e9fe63&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92e7c6c4dccd56837450920de775aa91130dc6eb" translate="yes" xml:space="preserve">
          <source>Partial indexes</source>
          <target state="translated">部分指数</target>
        </trans-unit>
        <trans-unit id="a6b00209f988aae401d1637e4d3a48cf480b87b9" translate="yes" xml:space="preserve">
          <source>Partial indexes have been supported in SQLite since &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26).</source>
          <target state="translated">自&lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;3.8.0版&lt;/a&gt;（2013-08-26）起，SQLite已支持部分索引。</target>
        </trans-unit>
        <trans-unit id="2c653f2abbb32f0888ba48000a6d19c0a678be3c" translate="yes" xml:space="preserve">
          <source>Partial sorting by index</source>
          <target state="translated">按指数进行部分排序</target>
        </trans-unit>
        <trans-unit id="8e7b279371a7a0621eac24aac6019fdbd06fb946" translate="yes" xml:space="preserve">
          <source>Partially or fully disable the use of mutexes using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;, &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;，&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt;和&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt;部分或完全禁用互斥锁。</target>
        </trans-unit>
        <trans-unit id="322d75c78f20c6c69dad6d4668258bee1cff55cf" translate="yes" xml:space="preserve">
          <source>Pass information about !=, IS, IS NOT, NOT NULL, and IS NULL constraints into the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of virtual tables.</source>
          <target state="translated">将有关！=，IS，IS NOT，NOT NULL和IS NULL约束的信息&lt;a href=&quot;vtab#xbestindex&quot;&gt;传递&lt;/a&gt;到虚拟表的xBestIndex方法中。</target>
        </trans-unit>
        <trans-unit id="87139427c07163b54b934cac2e589a5477f5abd2" translate="yes" xml:space="preserve">
          <source>Passing around pointers as if they were integers or BLOBs is easy, effective, and works well in an environment where the application components are all friendly toward one another. However, passing pointers as integers and BLOBs allows hostile SQL text to forge invalid pointers that can carry out mischief.</source>
          <target state="translated">把指针当作整数或BLOB来传递是很容易的,很有效的,而且在应用程序组件之间都很友好的环境中也很好用。然而,将指针当作整数和BLOB传递,可以让敌对的SQL文本伪造无效的指针,从而进行恶作剧。</target>
        </trans-unit>
        <trans-unit id="3138de58b357feeff45cc3442a6fef1e07764789" translate="yes" xml:space="preserve">
          <source>Passing zero to this function disables the session. Passing a value greater than zero enables it. Passing a value less than zero is a no-op, and may be used to query the current state of the session.</source>
          <target state="translated">传递0到这个函数,将禁用会话。传递一个大于零的值可以启用会话。传递一个小于零的值是无操作,可以用来查询会话的当前状态。</target>
        </trans-unit>
        <trans-unit id="590be09d7533f1bdecea251bf8fa20c21692381c" translate="yes" xml:space="preserve">
          <source>Patch releases may or may not have a release checklist, depending on the issue. This is a judgement call by the project leader.</source>
          <target state="translated">根据问题的不同,补丁发布可能有也可能没有发布检查表。这是由项目负责人做出的判断。</target>
        </trans-unit>
        <trans-unit id="6943c09e1bab506ed4d4e77bf277765f2ba43e9d" translate="yes" xml:space="preserve">
          <source>Patches from Christian Werner to improve ODBC compatibility and to fix a bug in the round() function.</source>
          <target state="translated">来自 Christian Werner 的补丁,改善了 ODBC 的兼容性,并修复了 round()函数中的一个错误。</target>
        </trans-unit>
        <trans-unit id="2e7fec23d54bbd8979f0f75ea726578cd4ba06c0" translate="yes" xml:space="preserve">
          <source>Pay close attention to the last sentence in the previous paragraph:</source>
          <target state="translated">密切注意上一段的最后一句话。</target>
        </trans-unit>
        <trans-unit id="c30415eacc6a59446974b716eff56cf28219815d" translate="yes" xml:space="preserve">
          <source>Payload</source>
          <target state="translated">Payload</target>
        </trans-unit>
        <trans-unit id="2cd642b895a9277d90f1edb51ac2e97d29897374" translate="yes" xml:space="preserve">
          <source>Payload, either table b-tree data or index b-tree keys, is always in the &quot;record format&quot;. The record format defines a sequence of values corresponding to columns in a table or index. The record format specifies the number of columns, the datatype of each column, and the content of each column.</source>
          <target state="translated">有效载荷,无论是表b树数据还是索引b树键,都是 &quot;记录格式&quot;。记录格式定义了表或索引中列对应的值序列。记录格式指定了列的数量、每列的数据类型以及每列的内容。</target>
        </trans-unit>
        <trans-unit id="e74a4343f3025ea9dd8df608f45f6bce992f0d7e" translate="yes" xml:space="preserve">
          <source>Pending statements no longer block &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;. Instead, the pending statement will return SQLITE_ABORT upon next access after the ROLLBACK.</source>
          <target state="translated">待处理语句不再阻止&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;。相反，挂起的语句将在ROLLBACK之后的下一次访问时返回SQLITE_ABORT。</target>
        </trans-unit>
        <trans-unit id="4737507de6ca940161ab97310c9c1d96280bacd6" translate="yes" xml:space="preserve">
          <source>People often wonder why SQLite does not use the &lt;a href=&quot;https://git-scm.org&quot;&gt;Git&lt;/a&gt; version control system like everybody else. This article attempts to answer that question. Also, in &lt;a href=&quot;#getthecode&quot;&gt;section 3&lt;/a&gt;, this article provides hints to Git users about how they can easily access the SQLite source code.</source>
          <target state="translated">人们常常想知道为什么SQLite不像其他人那样使用&lt;a href=&quot;https://git-scm.org&quot;&gt;Git&lt;/a&gt;版本控制系统。本文试图回答这个问题。另外，在&lt;a href=&quot;#getthecode&quot;&gt;第3节中&lt;/a&gt;，本文向Git用户提供了有关如何轻松访问SQLite源代码的提示。</target>
        </trans-unit>
        <trans-unit id="a859905b933e3207fdf46d957c4ccc640fdf48ae" translate="yes" xml:space="preserve">
          <source>People who understand SQL can employ the &lt;a href=&quot;cli&quot;&gt;sqlite3 command-line shell&lt;/a&gt; (or various third-party SQLite access programs) to analyze large datasets. Raw data can be imported from CSV files, then that data can be sliced and diced to generate a myriad of summary reports. More complex analysis can be done using simple scripts written in Tcl or Python (both of which come with SQLite built-in) or in R or other languages using readily available adaptors. Possible uses include website log analysis, sports statistics analysis, compilation of programming metrics, and analysis of experimental results. Many bioinformatics researchers use SQLite in this way.</source>
          <target state="translated">了解SQL的人可以使用&lt;a href=&quot;cli&quot;&gt;sqlite3命令行外壳程序&lt;/a&gt;（或各种第三方SQLite访问程序）来分析大型数据集。可以从CSV文件中导入原始数据，然后可以对该数据进行切片和切块以生成大量的摘要报告。可以使用用Tcl或Python（两者均内置SQLite）或用R或其他语言编写的简单脚本（使用现成的适配器）进行更复杂的分析。可能的用途包括网站日志分析，体育统计分析，编程指标汇编以及实验结果分析。许多生物信息学研究人员以这种方式使用SQLite。</target>
        </trans-unit>
        <trans-unit id="deda64204144c5cb8a53d34e5d28a353e9faf513" translate="yes" xml:space="preserve">
          <source>Perform a single step of the incremental vacuum procedure on the P1 database. If the vacuum has finished, jump to instruction P2. Otherwise, fall through to the next instruction.</source>
          <target state="translated">在P1数据库上执行增量真空程序的一个步骤。如果真空程序已经完成,则跳转到指令P2。否则,跳转到下一条指令。</target>
        </trans-unit>
        <trans-unit id="54eef71ea08bf2a0291b4730516048fec290cbbf" translate="yes" xml:space="preserve">
          <source>Perform any required foreign key actions,</source>
          <target state="translated">执行任何必要的外键操作。</target>
        </trans-unit>
        <trans-unit id="94e7748396990532238f46b792b6a833a4e68178" translate="yes" xml:space="preserve">
          <source>Perform some &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; operations in a single pass instead of in two passes.</source>
          <target state="translated">一次执行而不是两次执行一些&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;操作。</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="0b4045b439e29414aaf2009ad15f476795f21a79" translate="yes" xml:space="preserve">
          <source>Performance Related Assumptions</source>
          <target state="translated">与业绩有关的假设</target>
        </trans-unit>
        <trans-unit id="5539b01935cddeb466afb8949c00cacfd4174474" translate="yes" xml:space="preserve">
          <source>Performance can be improved and the size reduced by enabling &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=0&lt;/a&gt;, &lt;a href=&quot;compile#default_memstatus&quot;&gt;-DSQLITE_DEFAULT_MEMSTATUS=0&lt;/a&gt;, &lt;a href=&quot;compile#default_wal_synchronous&quot;&gt;-DSQLITE_DEFAULT_WAL_SYNCHRONOUS=1&lt;/a&gt;, &lt;a href=&quot;compile#like_doesnt_match_blobs&quot;&gt;-DSQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/a&gt;, &lt;a href=&quot;limits#max_expr_depth&quot;&gt;-DSQLITE_MAX_EXPR_DEPTH=0&lt;/a&gt;, &lt;a href=&quot;compile#omit_decltype&quot;&gt;-DSQLITE_OMIT_DECLTYPE&lt;/a&gt;, &lt;a href=&quot;compile#omit_deprecated&quot;&gt;-DSQLITE_OMIT_DEPRECATED&lt;/a&gt;, &lt;a href=&quot;compile#omit_progress_callback&quot;&gt;-DSQLITE_OMIT_PROGRESS_CALLBACK&lt;/a&gt;, &lt;a href=&quot;compile#omit_shared_cache&quot;&gt;-DSQLITE_OMIT_SHARED_CACHE&lt;/a&gt;, and &lt;a href=&quot;compile#use_alloca&quot;&gt;-DSQLITE_USE_ALLOCA&lt;/a&gt;. All these options together result in about a 3.5% performance increase and a 3.0% size reduction.</source>
          <target state="translated">性能可以提高，尺寸通过使减小&lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 0&lt;/a&gt;，&lt;a href=&quot;compile#default_memstatus&quot;&gt;-DSQLITE_DEFAULT_MEMSTATUS = 0&lt;/a&gt;，&lt;a href=&quot;compile#default_wal_synchronous&quot;&gt;-DSQLITE_DEFAULT_WAL_SYNCHRONOUS = 1&lt;/a&gt;，&lt;a href=&quot;compile#like_doesnt_match_blobs&quot;&gt;-DSQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/a&gt;，&lt;a href=&quot;limits#max_expr_depth&quot;&gt;-DSQLITE_MAX_EXPR_DEPTH = 0&lt;/a&gt;，&lt;a href=&quot;compile#omit_decltype&quot;&gt;-DSQLITE_OMIT_DECLTYPE&lt;/a&gt;，&lt;a href=&quot;compile#omit_deprecated&quot;&gt;-DSQLITE_OMIT_DEPRECATED&lt;/a&gt;，&lt;a href=&quot;compile#omit_progress_callback&quot;&gt;-DSQLITE_OMIT_PROGRESS_CALLBACK&lt;/a&gt;，&lt;a href=&quot;compile#omit_shared_cache&quot;&gt;-DSQLITE_OMIT_SHARED_CACHE&lt;/a&gt;，和&lt;a href=&quot;compile#use_alloca&quot;&gt;-DSQLITE_USE_ALLOCA&lt;/a&gt;。所有这些选项共同导致大约3.5％的性能提高和3.0％的尺寸减小。</target>
        </trans-unit>
        <trans-unit id="1860a0dfdb81986d4ea2f6eb535ec453b85d5fe2" translate="yes" xml:space="preserve">
          <source>Performance does not always increase with memory-mapped I/O. In fact, it is possible to construct test cases where performance is reduced by the use of memory-mapped I/O.</source>
          <target state="translated">性能并不总是随着内存映射的I/O而增加。事实上,有可能构建出因使用内存映射的I/O而降低性能的测试用例。</target>
        </trans-unit>
        <trans-unit id="61bd66ed39fd686f0ca14a86562254f51520b57c" translate="yes" xml:space="preserve">
          <source>Performance enhancement: Reengineer the internal routines used to interpret and render variable-length integers.</source>
          <target state="translated">提高性能。重新设计用于解释和呈现可变长度整数的内部程序。</target>
        </trans-unit>
        <trans-unit id="cea233e3b9eddbf52457c8a5a182ae23ce06f170" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the &lt;a href=&quot;lemon&quot;&gt;Lemon&lt;/a&gt;-generated parser</source>
          <target state="translated">&lt;a href=&quot;lemon&quot;&gt;Lemon&lt;/a&gt;生成的解析器中的性能增强</target>
        </trans-unit>
        <trans-unit id="c2ed78164f58cda3689de3af94b6683e701f4012" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the VDBE, especially to the OP_Column opcode.</source>
          <target state="translated">增强了VDBE的性能,尤其是OP_Column操作码。</target>
        </trans-unit>
        <trans-unit id="3e83f7e02f169f16c4ce4c1bf1daf1d4f6a2d0dd" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the parser.</source>
          <target state="translated">提高解析器的性能。</target>
        </trans-unit>
        <trans-unit id="1553d9684987d03c293eb61361d1bad6eb661140" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the sorter used by ORDER BY and CREATE INDEX.</source>
          <target state="translated">增强了ORDER BY和CREATE INDEX使用的分拣器的性能。</target>
        </trans-unit>
        <trans-unit id="d07c917b16f3c5d3172eade92a68d5375afe8a41" translate="yes" xml:space="preserve">
          <source>Performance enhancements on some corner cases of COUNT(*).</source>
          <target state="translated">对COUNT(*)的一些角落情况进行了性能提升。</target>
        </trans-unit>
        <trans-unit id="2136335adf2e68388f67bd194f29e528095a22d7" translate="yes" xml:space="preserve">
          <source>Performance enhancements through reductions in disk I/O:</source>
          <target state="translated">通过减少磁盘I/O来提高性能。</target>
        </trans-unit>
        <trans-unit id="f10f9c4b246cd76bbc82d16d809b97086003c9dc" translate="yes" xml:space="preserve">
          <source>Performance enhancements to tree balancing logic in the B-Tree layer.</source>
          <target state="translated">对B树层的树平衡逻辑进行性能提升。</target>
        </trans-unit>
        <trans-unit id="c1957e5fe4e4a95d607424db9c544dbfb2c9f147" translate="yes" xml:space="preserve">
          <source>Performance enhancements.</source>
          <target state="translated">性能增强。</target>
        </trans-unit>
        <trans-unit id="fd543174849447437d626cec826158c9d3d9aa89" translate="yes" xml:space="preserve">
          <source>Performance improvement: Constant subexpressions are factored out of loops.</source>
          <target state="translated">提高性能。常量子表达式从循环中扣除。</target>
        </trans-unit>
        <trans-unit id="6267206177784b60f0b03bc62ec213be82afcde6" translate="yes" xml:space="preserve">
          <source>Performance improvement: Results of OP_Column are reused rather than issuing multiple OP_Column opcodes.</source>
          <target state="translated">提高性能。OP_Column的结果被重复使用,而不是发出多个OP_Column操作码。</target>
        </trans-unit>
        <trans-unit id="865a67eeabea312b0a75ae22ab67eb186cfe013a" translate="yes" xml:space="preserve">
          <source>Performance improvement: The OP_IdxDelete opcode uses unpacked records, obviating the need for one OP_MakeRecord opcode call for each index record deleted.</source>
          <target state="translated">性能改进。OP_IdxDelete操作码使用未打包的记录,避免了对每个被删除的索引记录进行一次OP_MakeRecord操作码调用。</target>
        </trans-unit>
        <trans-unit id="78e2db7e7f2b2267a1830af4b4a2ed0ba33c683b" translate="yes" xml:space="preserve">
          <source>Performance improvements for &quot;count(*)&quot; queries.</source>
          <target state="translated">提高 &quot;count(*)&quot;查询的性能。</target>
        </trans-unit>
        <trans-unit id="6efb6a4d8f17dc824c346d05f15cd7b2b88dcf5d" translate="yes" xml:space="preserve">
          <source>Performance improvements for &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;, &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt;.</source>
          <target state="translated">对&lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;，&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;，&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;，&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA完整性检查&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA快速检查的&lt;/a&gt;性能进行了改进。</target>
        </trans-unit>
        <trans-unit id="c7ba2d57a08f2fc705e0114aa7d1ce0a8358e340" translate="yes" xml:space="preserve">
          <source>Performance improvements for &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt;, especially in cases where the number of free pages is greater than what will fit on a single trunk page of the freelist.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMAcremental_vacuum的&lt;/a&gt;性能改进，特别是在空闲页面数大于空闲列表单个主干页面容纳的页面数的情况下。</target>
        </trans-unit>
        <trans-unit id="ca9c11fd98f734889e089bb0e89c4f23dda7fe58" translate="yes" xml:space="preserve">
          <source>Performance improvements in the LEMON-generated parser.</source>
          <target state="translated">LEMON生成的解析器的性能改进。</target>
        </trans-unit>
        <trans-unit id="a14e5b6d4c4866ac4384c7883a92dffe274c0fdc" translate="yes" xml:space="preserve">
          <source>Performance improvements in the parser, pager, and WHERE clause code generator.</source>
          <target state="translated">改进了解析器、分页器和WHERE子句代码生成器的性能。</target>
        </trans-unit>
        <trans-unit id="4775771a833741ba344ee91f202aad2d4ccd4444" translate="yes" xml:space="preserve">
          <source>Performance improvements in the query optimizer.</source>
          <target state="translated">查询优化器的性能提升。</target>
        </trans-unit>
        <trans-unit id="db2c756a058cad6c443215c62bd837d8ebcd7c86" translate="yes" xml:space="preserve">
          <source>Performance improvements. The library is now much faster.</source>
          <target state="translated">性能改进。该库现在速度更快。</target>
        </trans-unit>
        <trans-unit id="7776d02639084ffcec06b8eee5d8080752868819" translate="yes" xml:space="preserve">
          <source>Performance measurements are done with a single compiler (gcc 5.4.0), optimization setting (-Os), and on a single platform (Ubuntu 16.04 LTS on x64). The performance of other compilers and processors may vary.</source>
          <target state="translated">性能测量是在单一编译器(gcc 5.4.0)、优化设置(-Os)和单一平台(x64上的Ubuntu 16.04 LTS)上完成的。其他编译器和处理器的性能可能会有所不同。</target>
        </trans-unit>
        <trans-unit id="4313721e53c3870801c269d394561df5830ac670" translate="yes" xml:space="preserve">
          <source>Performance optimizations targeting a specific use case from a single high-profile user of SQLite. A 12% reduction in the number of CPU operations is achieved (as measured by Valgrind). Actual performance improvements in practice may vary depending on workload. Changes include:</source>
          <target state="translated">针对SQLite的一个高知名度用户的特定用例进行性能优化。实现了CPU操作次数减少12%(由Valgrind测量)。实际的性能提升可能会因工作负载的不同而有所不同。变化包括</target>
        </trans-unit>
        <trans-unit id="aafc19be49f715a88d989d3b462949b02cf65924" translate="yes" xml:space="preserve">
          <source>Performance problems can often be resolved, even late in the development cycle, using &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, avoiding costly redesign, rewrite, and retest efforts.</source>
          <target state="translated">使用&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;甚至在开发周期的后期，通常就可以解决性能问题，从而避免了昂贵的重新设计，重写和重新测试工作。</target>
        </trans-unit>
        <trans-unit id="80d748ed593bda4d15f97528a4a48c139940ad2c" translate="yes" xml:space="preserve">
          <source>Performance was measured by running speedtest1 using cachegrind and observing the &quot;I refs&quot; output.</source>
          <target state="translated">通过使用cachegrind运行speedtest1并观察 &quot;I refs &quot;的输出来测量性能。</target>
        </trans-unit>
        <trans-unit id="fd932d13fa7bed8f3a51946f0c1cded4ce734cc8" translate="yes" xml:space="preserve">
          <source>Performance was measured using the &lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt; utility program, which attempts to mimic a typical workload for SQLite. Options to the test runs are:</source>
          <target state="translated">使用&lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt;实用程序测量了性能，该实用程序试图模仿SQLite的典型工作负载。测试运行的选项包括：</target>
        </trans-unit>
        <trans-unit id="306df6900907956d3250e5c6b9116143f3e59d56" translate="yes" xml:space="preserve">
          <source>Perhaps you are referring to the following statement from SQL92:</source>
          <target state="translated">也许你指的是SQL92中的以下语句。</target>
        </trans-unit>
        <trans-unit id="dc174949d4e077b47c1979929b03d9b696ed5987" translate="yes" xml:space="preserve">
          <source>Permit SELECT statements without a FROM clause.</source>
          <target state="translated">允许不带FROM子句的SELECT语句。</target>
        </trans-unit>
        <trans-unit id="6cbfe59727ef5993727b847bb5705e98e92cb339" translate="yes" xml:space="preserve">
          <source>Permutation</source>
          <target state="translated">Permutation</target>
        </trans-unit>
        <trans-unit id="4fce736ea498cc616300b0a192c1d1da1b783f4c" translate="yes" xml:space="preserve">
          <source>Permuted Title Index</source>
          <target state="translated">弯曲的标题索引</target>
        </trans-unit>
        <trans-unit id="d33cf936053187794d74699260279a0a85c60b95" translate="yes" xml:space="preserve">
          <source>Persistent loadable extensions</source>
          <target state="translated">永久性可加载扩展</target>
        </trans-unit>
        <trans-unit id="cda60e78224642430ac8ecc50f20cf5762fbe57b" translate="yes" xml:space="preserve">
          <source>Phrase and NEAR queries may not span multiple columns within a row.</source>
          <target state="translated">词组和near查询不能在一行中跨越多列。</target>
        </trans-unit>
        <trans-unit id="8867fcbca825b3aa1d7306421a378db86e201e5f" translate="yes" xml:space="preserve">
          <source>Phrase queries</source>
          <target state="translated">词组查询</target>
        </trans-unit>
        <trans-unit id="a363180d8d104ea58876b6a7416ecc65d37a83bd" translate="yes" xml:space="preserve">
          <source>Phrase queries are not available.</source>
          <target state="translated">词组查询不可用。</target>
        </trans-unit>
        <trans-unit id="c2d36c2214269a55cf08fe15db0efb7f6b50dc52" translate="yes" xml:space="preserve">
          <source>Phrases and NEAR groups may also be connected by &lt;b&gt;implicit AND operators&lt;/b&gt;. For simplicity, these are not shown in the BNF grammar above. Essentially, any sequence of phrases or NEAR groups (including those restricted to matching specified columns) separated only by whitespace are handled as if there were an implicit AND operator between each pair of phrases or NEAR groups. Implicit AND operators are never inserted after or before an expression enclosed in parenthesis. For example:</source>
          <target state="translated">短语和NEAR组也可以通过&lt;b&gt;隐式AND运算符&lt;/b&gt;连接。为简单起见，以上BNF语法中未显示这些内容。本质上，仅由空格分隔的短语或NEAR组的任何序列（包括限于匹配指定列的序列）的处理方式就像在每对短语或NEAR组之间存在隐式AND运算符一样。隐式AND运算符永远不会插入括号内的表达式之后或之前。例如：</target>
        </trans-unit>
        <trans-unit id="c324bfc69bd8b1bd8095017021f5a91e3ea40b2c" translate="yes" xml:space="preserve">
          <source>Phrases and NEAR groups may be arranged into expressions using &lt;b&gt;boolean operators&lt;/b&gt;. In order of precedence, from highest (tightest grouping) to lowest (loosest grouping), the operators are:</source>
          <target state="translated">可以使用&lt;b&gt;布尔运算符&lt;/b&gt;将短语和NEAR组安排到表达式中。从高（最紧密的分组）到最低（最松的分组）的优先顺序，操作员是：</target>
        </trans-unit>
        <trans-unit id="3ae7ce4ac376e04456d5e49b6ed2413b1a3d558b" translate="yes" xml:space="preserve">
          <source>Picking the nested order of the various loops</source>
          <target state="translated">挑选各种循环的嵌套顺序。</target>
        </trans-unit>
        <trans-unit id="e6557cb061d60a980305721118e117b8668196a9" translate="yes" xml:space="preserve">
          <source>Picking the nesting order is generally the more challenging problem. Once the nesting order of the join is established, the choice of indexes for each loop is normally obvious.</source>
          <target state="translated">选取嵌套顺序一般是比较有挑战性的问题。一旦确定了join的嵌套顺序,每个循环的索引选择通常是显而易见的。</target>
        </trans-unit>
        <trans-unit id="48838d5eebf4e016bae8e0582e9b79166631f842" translate="yes" xml:space="preserve">
          <source>Pinning (reading) a database page.</source>
          <target state="translated">锁定(读取)数据库页面。</target>
        </trans-unit>
        <trans-unit id="e786fb34d40222929b9ef3bd84afa78c0fc799e8" translate="yes" xml:space="preserve">
          <source>Plays better with virus scanners on Windows</source>
          <target state="translated">在Windows上更好地播放病毒扫描程序</target>
        </trans-unit>
        <trans-unit id="0ba6acad031749dfc1ea19f37cf3cf3ba6821875" translate="yes" xml:space="preserve">
          <source>Please pay particular attention to the fact that the pointer returned from &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_blob()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; can be invalidated by a subsequent call to &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes16()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt;.</source>
          <target state="translated">请特别注意的是，从指针返回的事实&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_blob（） &lt;/a&gt;，&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text（） &lt;/a&gt;，或&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16（）&lt;/a&gt;可以通过后续调用无效以&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes（） &lt;/a&gt;，&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes16（） &lt;/a&gt;，&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text（） &lt;/a&gt;，或&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7ae91e82ac5caaf87714c26921fb437ec0209ebd" translate="yes" xml:space="preserve">
          <source>Please pay particular attention to the fact that the pointer returned from &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_blob()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; can be invalidated by a subsequent call to &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes16()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt;.</source>
          <target state="translated">请特别注意的是，从指针返回的事实&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_blob（） &lt;/a&gt;，&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text（） &lt;/a&gt;，或&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16（）&lt;/a&gt;可以通过后续调用无效以&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes（） &lt;/a&gt;，&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes16（） &lt;/a&gt;，&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text（） &lt;/a&gt;，或&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82e80b8ed5a5ef5a7f7f84502fd344efe74ab819" translate="yes" xml:space="preserve">
          <source>Plug some memory leaks that use to occur if malloc() failed. We have been and continue to be memory leak free as long as malloc() works.</source>
          <target state="translated">堵住一些过去在malloc()失败时发生的内存泄漏。只要malloc()能正常工作,我们就不会出现内存泄漏。</target>
        </trans-unit>
        <trans-unit id="9885c5aa124b354814a6a44123b3e909495fe046" translate="yes" xml:space="preserve">
          <source>Pointer Passing Interfaces</source>
          <target state="translated">指针传递接口</target>
        </trans-unit>
        <trans-unit id="59e3eae717dea15b934265a0c37302cf590a5714" translate="yes" xml:space="preserve">
          <source>Pointer leak</source>
          <target state="translated">指针泄漏</target>
        </trans-unit>
        <trans-unit id="893d8abe3b1d2dc513b4dcba9c2db9ee48da24a6" translate="yes" xml:space="preserve">
          <source>Pointer map or ptrmap pages are extra pages inserted into the database to make the operation of &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; modes more efficient. Other page types in the database typically have pointers from parent to child. For example, an interior b-tree page contains pointers to its child b-tree pages and an overflow chain has a pointer from earlier to later links in the chain. A ptrmap page contains linkage information going in the opposite direction, from child to parent.</source>
          <target state="translated">指针映射或ptrmap页面是插入数据库中的额外页面，以使&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;增量&lt;/a&gt;_vacuum模式的操作更加有效。数据库中的其他页面类型通常具有从父级到子级的指针。例如，内部b树页面包含指向其子b树页面的指针，并且溢出链具有从链中较早的链接到后来的链接的指针。一个ptrmap页面包含从子级到父级的相反方向的链接信息。</target>
        </trans-unit>
        <trans-unit id="d9fb370b0a40e2e2f19446936bcadb07206247ac" translate="yes" xml:space="preserve">
          <source>Pointer types</source>
          <target state="translated">指针类型</target>
        </trans-unit>
        <trans-unit id="1091e0ac6927998f6cf6d184bfe2c9b9dcea6870" translate="yes" xml:space="preserve">
          <source>Pointer types are static strings, which ideally should be string literals embedded directly in the SQLite API call, not parameters passed in from other functions. Consideration was given to using integer values as the pointer type, but static strings provides a much larger name space which reduces the chance of accidental type-name collisions between unrelated extensions.</source>
          <target state="translated">指针类型是静态字符串,理想情况下应该是直接嵌入到SQLite API调用中的字符串字面,而不是从其他函数传递进来的参数。考虑使用整数值作为指针类型,但静态字符串提供了更大的名称空间,这减少了不相关扩展之间类型名称意外碰撞的机会。</target>
        </trans-unit>
        <trans-unit id="3b1d288532e92abf21814dda987180d6353e6315" translate="yes" xml:space="preserve">
          <source>Pointer values generated by &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; cannot be read by pure SQL. Hence, it is not possible for SQL to leak the value of pointers.</source>
          <target state="translated">由&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;和&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;生成的指针值不能由纯SQL读取。因此，SQL不可能泄漏指针的值。</target>
        </trans-unit>
        <trans-unit id="362edd7f45230e1071baa348e5b8aa0beef2dc87" translate="yes" xml:space="preserve">
          <source>Pointer values must flow directly from their producer into their consumer, with no intermediate operators or functions. Any transformation of a pointer value destroys the pointer and transforms the value into an ordinary SQL NULL.</source>
          <target state="translated">指针值必须直接从其生产者流向其消费者,没有中间操作符或函数。对指针值的任何转换都会破坏指针,并将该值转换为普通的SQL NULL。</target>
        </trans-unit>
        <trans-unit id="d40a766f8bf600e29b3ebb06afc3c66d8eb2275c" translate="yes" xml:space="preserve">
          <source>Pointer values read by &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; cannot be generated by pure SQL. Hence, it is not possible for SQL to forge pointers.</source>
          <target state="translated">&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;读取的指针值不能由纯SQL生成。因此，SQL无法伪造指针。</target>
        </trans-unit>
        <trans-unit id="074017050c52f59774a49045cefb3a8e55469503" translate="yes" xml:space="preserve">
          <source>Pointers should &lt;u&gt;never&lt;/u&gt; be exchanged by encoding them as some other SQL datatype, such as integers or BLOBs. Instead, use the interfaces designed to facilitate secure pointer passing: &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;, and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;.</source>
          <target state="translated">&lt;u&gt;永远不要&lt;/u&gt;通过将指针编码为其他SQL数据类型（例如整数或BLOB）来交换指针。而是使用旨在促进安全指针传递的接口：&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;，&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;和&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3758fcfa626c0aaafd8e85f7ec0b94d37eb1b41f" translate="yes" xml:space="preserve">
          <source>Porting SQLite To New Operating Systems</source>
          <target state="translated">将SQLite移植到新的操作系统上</target>
        </trans-unit>
        <trans-unit id="492619cf72b9410d05b5a1fac306af0804a5c47b" translate="yes" xml:space="preserve">
          <source>Position cursor P1 at the end of the btree for the purpose of appending a new entry onto the btree.</source>
          <target state="translated">将光标P1放置在btree的末端,以便在btree上添加新的条目。</target>
        </trans-unit>
        <trans-unit id="24fd6c2d1150de6a47543209150ff4c2a2d3104f" translate="yes" xml:space="preserve">
          <source>PostgreSQL</source>
          <target state="translated">PostgreSQL</target>
        </trans-unit>
        <trans-unit id="a6c78fee1df30606dfc4f598f623eca0d1354255" translate="yes" xml:space="preserve">
          <source>PostgreSQL:</source>
          <target state="translated">PostgreSQL:</target>
        </trans-unit>
        <trans-unit id="957feaeb06e5a65656c3283c9c7193ebcf008b45" translate="yes" xml:space="preserve">
          <source>Postpone I/O associated with TEMP files for as long as possible, with the hope that the I/O can ultimately be avoided completely.</source>
          <target state="translated">尽可能推迟与腾博会登录文件相关的I/O,希望最终能够完全避免I/O。</target>
        </trans-unit>
        <trans-unit id="1bdd037a51c3dae4c27aa3b443867933947439ca" translate="yes" xml:space="preserve">
          <source>Powersafe Overwrite</source>
          <target state="translated">Powersafe覆写</target>
        </trans-unit>
        <trans-unit id="10329807f69720bd141eb1a12685730b2cfaf4cd" translate="yes" xml:space="preserve">
          <source>Pragma list</source>
          <target state="translated">Pragma清单</target>
        </trans-unit>
        <trans-unit id="c984aa3372c91f167c3b8d4c0c9f9715c82d4221" translate="yes" xml:space="preserve">
          <source>Pragma statements supported by SQLite</source>
          <target state="translated">SQLite支持的Pragma语句</target>
        </trans-unit>
        <trans-unit id="4a80a5f45da767ce7271bd5ac307890ba0ff78a6" translate="yes" xml:space="preserve">
          <source>Pragmas whose names are &lt;s&gt;struck through&lt;/s&gt; are deprecated. Do not use them. They exist for historical compatibility.</source>
          <target state="translated">编译指示他们的名字被&lt;s&gt;删除线&lt;/s&gt;已被弃用。不要使用它们。存在它们是为了历史兼容性。</target>
        </trans-unit>
        <trans-unit id="36fd60583248a73e8dcb8aeb3b04450519f9ddea" translate="yes" xml:space="preserve">
          <source>Pray for your enemies in the love of Christ.</source>
          <target state="translated">在基督的爱中为你的敌人祷告。</target>
        </trans-unit>
        <trans-unit id="1d437b581e9dcd72eb07665e29677b9a7ea18988" translate="yes" xml:space="preserve">
          <source>Prefer nothing more than the love of Christ.</source>
          <target state="translated">最喜欢的莫过于基督的爱。</target>
        </trans-unit>
        <trans-unit id="6b85b242b16c8eaf303d30b62e8918e8c764ab9e" translate="yes" xml:space="preserve">
          <source>Prefix indexes may be used to optimize &lt;a href=&quot;fts3#termprefix&quot;&gt;prefix queries&lt;/a&gt; in two cases. If the query is for a prefix of N bytes, then a prefix index created with &quot;prefix=N&quot; provides the best optimization. Or, if no &quot;prefix=N&quot; index is available, a &quot;prefix=N+1&quot; index may be used instead. Using a &quot;prefix=N+1&quot; index is less efficient than a &quot;prefix=N&quot; index, but is better than no prefix index at all.</source>
          <target state="translated">在两种情况下，前缀索引可用于优化&lt;a href=&quot;fts3#termprefix&quot;&gt;前缀查询&lt;/a&gt;。如果查询的前缀为N个字节，则使用&amp;ldquo; prefix = N&amp;rdquo;创建的前缀索引将提供最佳的优化。或者，如果没有&amp;ldquo; prefix = N&amp;rdquo;索引可用，则可以改用&amp;ldquo; prefix = N + 1&amp;rdquo;索引。使用&amp;ldquo; prefix = N + 1&amp;rdquo;索引比&amp;ldquo; prefix = N&amp;rdquo;索引效率低，但比根本没有前缀索引要好。</target>
        </trans-unit>
        <trans-unit id="f58acbef3b4f1545b36db43fdb7aa3248226ddc3" translate="yes" xml:space="preserve">
          <source>Prefix query</source>
          <target state="translated">前缀查询</target>
        </trans-unit>
        <trans-unit id="d876a9e47626f4666efcfc69bdf4c50fcc426b9e" translate="yes" xml:space="preserve">
          <source>Prefix search in FTS3 is much more efficient.</source>
          <target state="translated">在FTS3中,前缀搜索的效率更高。</target>
        </trans-unit>
        <trans-unit id="68a57fd3726c085ce337dc259dc3b2499a35efce" translate="yes" xml:space="preserve">
          <source>Preliminaries</source>
          <target state="translated">Preliminaries</target>
        </trans-unit>
        <trans-unit id="f3d20f83dbeeb1d79306958dea533c43146bb29c" translate="yes" xml:space="preserve">
          <source>Prepare Flags</source>
          <target state="translated">准备旗帜</target>
        </trans-unit>
        <trans-unit id="d5f65540d8f04f5669bf0a7783fb7256d5f3309f" translate="yes" xml:space="preserve">
          <source>Prepared Statement Object</source>
          <target state="translated">预备声明对象</target>
        </trans-unit>
        <trans-unit id="d84580c0a3c076e6a6095c0d8c0427ccdaa13d1e" translate="yes" xml:space="preserve">
          <source>Prepared Statement Scan Status</source>
          <target state="translated">预备报表扫描状态</target>
        </trans-unit>
        <trans-unit id="1037ef270384cfd9be096004017447826d2cb2f5" translate="yes" xml:space="preserve">
          <source>Prepared Statement Scan Status Opcodes</source>
          <target state="translated">预备报表扫描状态操作码</target>
        </trans-unit>
        <trans-unit id="2f5da103100b3440f26c60eb3e05807f62717d70" translate="yes" xml:space="preserve">
          <source>Prepared Statement Status</source>
          <target state="translated">编制报表情况</target>
        </trans-unit>
        <trans-unit id="213d6f218c41a8dc480fb564c77564038e40e839" translate="yes" xml:space="preserve">
          <source>Prepend as many &quot;0&quot; characters to numeric substitutions as necessary to expand the value out to the specified width. If the width field is omitted, then this flag is a no-op.</source>
          <target state="translated">根据需要在数字替换中加入尽可能多的 &quot;0 &quot;字符,以便将数值扩展到指定的宽度。如果宽度字段被省略,那么这个标志是一个无操作的标志。</target>
        </trans-unit>
        <trans-unit id="07ea5425dab39a1ce6090bfaba72b208d8a2bb32" translate="yes" xml:space="preserve">
          <source>Prepend the &quot;&lt;code&gt;file:&lt;/code&gt;&quot; scheme.</source>
          <target state="translated">前置&amp;ldquo; &lt;code&gt;file:&lt;/code&gt; &amp;rdquo;方案。</target>
        </trans-unit>
        <trans-unit id="b5b2c6aa0c741177b3341a9cac682f0503cc7181" translate="yes" xml:space="preserve">
          <source>Pretend that the single row just extracted is the only row in the recursive table and run the recursive-select, adding all results to the queue.</source>
          <target state="translated">假设刚才提取的单行是递归表中唯一的一行,运行递归-select,将所有结果加入到队列中。</target>
        </trans-unit>
        <trans-unit id="e96fea52df5eb0d7ea088eb0523f5fd6be20645f" translate="yes" xml:space="preserve">
          <source>Prev</source>
          <target state="translated">Prev</target>
        </trans-unit>
        <trans-unit id="d011a785f80d4ac2978260fd4baeb9a488339607" translate="yes" xml:space="preserve">
          <source>Prevent journal file overflows on huge transactions.</source>
          <target state="translated">防止巨额交易的日志文件溢出。</target>
        </trans-unit>
        <trans-unit id="15aff2aaf0be53526cd90b44a8f7faa67462af63" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/docsrc&quot;&gt;https://www.sqlite.org/docsrc&lt;/a&gt;</source>
          <target state="translated">主要位置：&lt;a href=&quot;https://www.sqlite.org/docsrc&quot;&gt;https&lt;/a&gt;：//www.sqlite.org/docsrc</target>
        </trans-unit>
        <trans-unit id="bb559fe38e423e3bb19de0649fe3fd5b6b237723" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/sqllogictest&quot;&gt;https://www.sqlite.org/sqllogictest&lt;/a&gt;</source>
          <target state="translated">主要位置：&lt;a href=&quot;https://www.sqlite.org/sqllogictest&quot;&gt;https&lt;/a&gt;：//www.sqlite.org/sqllogictest</target>
        </trans-unit>
        <trans-unit id="40da77fe99b4c2e0002b4b5a88b9bdf5b5ffd788" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;https://www.sqlite.org/src&lt;/a&gt;</source>
          <target state="translated">主要位置：&lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;https&lt;/a&gt;：//www.sqlite.org/src</target>
        </trans-unit>
        <trans-unit id="72c44b5ab0d08449343e1c11f7db59a0baee6a06" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/th3&quot;&gt;https://www.sqlite.org/th3&lt;/a&gt;</source>
          <target state="translated">主要位置：&lt;a href=&quot;https://www.sqlite.org/th3&quot;&gt;https&lt;/a&gt;：//www.sqlite.org/th3</target>
        </trans-unit>
        <trans-unit id="284d8db03255f327420e4917415f7de011fcda53" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/th3private&quot;&gt;https://www.sqlite.org/th3private&lt;/a&gt;</source>
          <target state="translated">主要位置：&lt;a href=&quot;https://www.sqlite.org/th3private&quot;&gt;https&lt;/a&gt;：//www.sqlite.org/th3private</target>
        </trans-unit>
        <trans-unit id="12c6ce30d8dde9c30a0548e43a1a65f2399c3ac8" translate="yes" xml:space="preserve">
          <source>Primary result code symbolic names are of the form &quot;SQLITE_XXXXXX&quot; where XXXXXX is a sequence of uppercase alphabetic characters. Extended result code names are of the form &quot;SQLITE_XXXXXX_YYYYYYY&quot; where the XXXXXX part is the corresponding primary result code and the YYYYYYY is an extension that further classifies the result code.</source>
          <target state="translated">主结果代码符号名的形式是 &quot;SQLITE_XXXXXX&quot;,其中XXXXX是一个大写字母字符序列。扩展结果代码名称的形式为 &quot;SQLITE_XXXXXX_YYYYY&quot;,其中XXXXX部分是相应的主结果代码,YYYYY是对结果代码进一步分类的扩展。</target>
        </trans-unit>
        <trans-unit id="4fda803b9a957798a3e6c9099105e126c5e73e36" translate="yes" xml:space="preserve">
          <source>Primary versus extended result codes</source>
          <target state="translated">主要结果代码与扩展结果代码</target>
        </trans-unit>
        <trans-unit id="3b2d52029dad08f51a816bff4a2b1ace042995a8" translate="yes" xml:space="preserve">
          <source>Print the offending SQL statement when an error occurs.</source>
          <target state="translated">当发生错误时,打印出违规的SQL语句。</target>
        </trans-unit>
        <trans-unit id="93863d358af110c5080e64cc1cfc5d8749e0490f" translate="yes" xml:space="preserve">
          <source>Prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26), SQLite always used the &quot;Nearest Neighbor&quot; or &quot;NN&quot; heuristic when searching for the best query plan. The NN heuristic makes a single traversal of the graph, always choosing the lowest-cost arc as the next step. The NN heuristic works surprisingly well in most cases. And NN is fast, so that SQLite is able to quickly find good plans for even large 64-way joins. In contrast, other SQL database engines that do more extensive searching tend to bog down when the number of tables in a join goes above 10 or 15.</source>
          <target state="translated">在&lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;版本3.8.0&lt;/a&gt;（2013-08-26）之前，SQLite在搜索最佳查询计划时始终使用&amp;ldquo;最近邻居&amp;rdquo;或&amp;ldquo; NN&amp;rdquo;启发式方法。NN启发式算法遍历图形，始终选择成本最低的弧作为下一步。NN启发式方法在大多数情况下都表现出色。而且NN快速，因此SQLite甚至可以为大型64路联接快速找到好的计划。相反，当联接中的表数超过10或15时，其他进行更广泛搜索的SQL数据库引擎往往会陷入困境。</target>
        </trans-unit>
        <trans-unit id="0cbead769cfd094dac2d1d702814135203e88038" translate="yes" xml:space="preserve">
          <source>Prior to SQLite 3.20.0 (2017-08-01) all date/time functions were always considered non-deterministic. The ability for date/time functions to be deterministic sometimes and non-deterministic at other times, depending on their arguments, was added for the 3.20.0 release.</source>
          <target state="translated">在SQLite 3.20.0(2017-08-01)之前,所有的日期/时间函数总是被认为是非确定性的。3.20.0版本增加了日期/时间函数有时是确定性的,有时是非确定性的,这取决于它们的参数。</target>
        </trans-unit>
        <trans-unit id="6c7f8cc84bc5292827563b13ba75248881d97140" translate="yes" xml:space="preserve">
          <source>Prior to SQLite 3.7.15 (2012-12-12), a subquery in the FROM clause would be either flattened into the outer query, or else the subquery would be run to completion before the outer query started, the result set from the subquery would be stored in a transient table, and then the transient table would be used in the outer query. Newer versions of SQLite have a third option, which is to implement the subquery using a co-routine.</source>
          <target state="translated">在SQLite 3.7.15(2012-12-12)之前,FROM子句中的子查询要么被扁平化到外层查询中,要么在外层查询开始之前将子查询运行完成,将子查询的结果集存储在瞬时表中,然后在外层查询中使用瞬时表。新版本的SQLite有第三种选择,那就是使用协程来实现子查询。</target>
        </trans-unit>
        <trans-unit id="a720aafd2afa8c2c385472fc2e648bd2ccdf321e" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;version 3.11.0&lt;/a&gt; (2016-02-15), the arguments to fts3_tokenzer() could be literal strings or BLOBs. They did not have to be &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;. But that could lead to security problems in the event of an SQL injection. Hence, the legacy behavior is now disabled by default. But the old legacy behavior can be enabled, for backwards compatibility in applications that really need it, by calling &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;,1,0).</source>
          <target state="translated">在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;版本3.11.0&lt;/a&gt;（2016-02-15）之前，fts3_tokenzer（）的参数可以是文字字符串或BLOB。它们不必&lt;a href=&quot;lang_expr#varparam&quot;&gt;绑定参数&lt;/a&gt;。但这可能在SQL注入事件中导致安全问题。因此，默认情况下现在禁用旧行为。但是，可以通过调用&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;，1,0）来启用旧的旧行为，以在真正需要它的应用程序中实现向后兼容性。</target>
        </trans-unit>
        <trans-unit id="51d8edb11a84377ed9b294770763b3964473b7ee" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt; (2009-08-10), the virtual table mechanism assumes that each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; kept its own copy of the database schema. Hence, the virtual table mechanism could not be used in a database that has &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; enabled. The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; interface would return an error if &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; is enabled. That restriction was relaxed beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt;.</source>
          <target state="translated">在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;3.6.17&lt;/a&gt;（2009-08-10）版本之前，虚拟表机制假定每个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接均&lt;/a&gt;保留其自己的数据库架构副本。因此，不能在启用了&lt;a href=&quot;sharedcache&quot;&gt;共享缓存模式&lt;/a&gt;的数据库中使用虚拟表机制。该&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module（）&lt;/a&gt;如果接口将返回一个错误&lt;a href=&quot;sharedcache&quot;&gt;共享缓存模式&lt;/a&gt;被启用。从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;3.6.17版本&lt;/a&gt;开始放宽了该限制。</target>
        </trans-unit>
        <trans-unit id="33d0fd70a8f55e9f98c0c7adf04301e981d0c322" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;version 3.6.18&lt;/a&gt; (2009-09-11), recursive triggers were not supported. The behavior of SQLite was always as if this pragma was set to OFF. Support for recursive triggers was added in version 3.6.18 but was initially turned OFF by default, for compatibility. Recursive triggers may be turned on by default in future versions of SQLite.</source>
          <target state="translated">在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;3.6.18&lt;/a&gt;（2009-09-11）之前的版本中，不支持递归触发器。 SQLite的行为始终好像此编译指示设置为OFF。在版本3.6.18中添加了对递归触发器的支持，但是出于兼容性考虑，默认情况下最初将其关闭。默认情况下，SQLite的未来版本中可能会打开递归触发器。</target>
        </trans-unit>
        <trans-unit id="a28758e140ed243892fd7015e84c9739d352fdbe" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;version 3.6.18&lt;/a&gt; (2009-09-11), triggers were not recursive and so this limit was meaningless. Beginning with version 3.6.18, recursive triggers were supported but had to be explicitly enabled using the &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt; statement. Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2009-09-11), recursive triggers are enabled by default but can be manually disabled using &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt;. The SQLITE_MAX_TRIGGER_DEPTH is only meaningful if recursive triggers are enabled.</source>
          <target state="translated">在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;3.6.18&lt;/a&gt;（2009-09-11）之前，触发器不是递归的，因此此限制毫无意义。从3.6.18版开始，支持递归触发器，但必须使用&lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt;语句显式启用它。从&lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;版本3.7.0&lt;/a&gt;（2009-09-11）开始，默认情况下启用了递归触发器，但可以使用&lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt;手动禁用它。仅当启用了递归触发器时，SQLITE_MAX_TRIGGER_DEPTH才有意义。</target>
        </trans-unit>
        <trans-unit id="534f30ad3bfba01b49cf3bf01218d9cf22140413" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.17.0, the session extension only worked with &lt;a href=&quot;rowidtable&quot;&gt;rowid tables&lt;/a&gt;, not &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. As of 3.17.0, both rowid and WITHOUT ROWID tables are supported.</source>
          <target state="translated">在SQLite 3.17.0之前的版本中，会话扩展仅适用于&lt;a href=&quot;rowidtable&quot;&gt;rowid表&lt;/a&gt;，而不能使用&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表。从3.17.0开始，同时支持rowid和WITHOUT ROWID表。</target>
        </trans-unit>
        <trans-unit id="8ca3ddf5fd526ae6f9a1aaa722828cf40f2bf92a" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.3.14, a sector size of 512 bytes was assumed in all cases. There was a compile-time option to change this but the code had never been tested with a larger value. The 512 byte sector assumption seemed reasonable since until very recently all disk drives used a 512 byte sector internally. However, there has recently been a push to increase the sector size of disks to 4096 bytes. Also the sector size for flash memory is usually larger than 512 bytes. For these reasons, versions of SQLite beginning with 3.3.14 have a method in the OS interface layer that interrogates the underlying filesystem to find the true sector size. As currently implemented (version 3.5.0) this method still returns a hard-coded value of 512 bytes, since there is no standard way of discovering the true sector size on either Unix or Windows. But the method is available for embedded device manufacturers to tweak according to their own needs. And we have left open the possibility of filling in a more meaningful implementation on Unix and Windows in the future.</source>
          <target state="translated">在SQLite 3.3.14版本之前,所有情况下都假定扇区大小为512字节。有一个编译时的选项可以改变这个值,但代码从未用更大的值进行过测试。512字节扇区的假设似乎是合理的,因为直到最近,所有的磁盘驱动器都在内部使用512字节的扇区。然而,最近有人推动将磁盘的扇区大小增加到4096字节。另外,闪存的扇区大小通常也大于512字节。由于这些原因,从3.3.14开始的SQLite版本在操作系统接口层中有一个方法,它可以查询底层的文件系统以找到真正的扇区大小。按照目前的实现(3.5.0版本),这个方法仍然返回一个512字节的硬编码值,因为在Unix或Windows上都没有发现真实扇区大小的标准方法。但该方法可供嵌入式设备制造商根据自己的需要进行调整。而且我们还留有余地,将来可以在Unix和Windows上填写更有意义的实现方式。</target>
        </trans-unit>
        <trans-unit id="d9c2ee7b5aac6da179c8f578b8285aa5c54f4524" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.7.10, the Windows OS interface layer called the system malloc() and free() directly when converting filenames between the UTF-8 encoding used by SQLite and whatever filename encoding is used by the particular Windows installation. Memory allocation errors were detected, but they were reported back as &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt; rather than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;.</source>
          <target state="translated">在SQLite 3.7.10之前，Windows OS接口层在SQLite使用的UTF-8编码和特定Windows安装使用的任何文件名编码之间转换文件名时，直接调用系统malloc（）和free（）。检测到内存分配错误，但将其报告为&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt;而不是&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="91089ffc77affdb7ae59f739dbaf9014a293f340" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.7.10, the Windows OS interface layer called the system malloc() and free() directly when converting filenames between the UTF-8 encoding used by SQLite and whatever filename encoding is used by the particular Windows installation. Memory allocation errors were detected, but they were reported back as &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; or &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; rather than &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;.</source>
          <target state="translated">在SQLite 3.7.10之前，Windows OS接口层在SQLite使用的UTF-8编码和特定Windows安装使用的任何文件名编码之间转换文件名时，直接调用系统malloc（）和free（）。检测到内存分配错误，但将其报告为&lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt;或&lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;而不是&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f00bebae92fba462c0a2ff1a68401159dfc1bce" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.8.2 (2013-12-06), casting a REAL value greater than +9223372036854775807.0 into an integer resulted in the most negative integer, -9223372036854775808. This behavior was meant to emulate the behavior of x86/x64 hardware when doing the equivalent cast.</source>
          <target state="translated">在SQLite 3.8.2版本(2013-12-06)之前,将一个大于+9223372036854775807.0的REAL值投射到一个整数中,结果是最负的整数,即-9223372036854775808。这种行为是为了模拟x86/x64硬件在进行等价投射时的行为。</target>
        </trans-unit>
        <trans-unit id="a1634472b77cd282aba3425a6cf5a2a4d268772c" translate="yes" xml:space="preserve">
          <source>Prior to each check-in to the SQLite source tree, developers typically run a subset (called &quot;veryquick&quot;) of the Tcl tests consisting of about 248.5 thousand test cases. The veryquick tests include most tests other than the anomaly, fuzz, and soak tests. The idea behind the veryquick tests are that they are sufficient to catch most errors, but also run in only a few minutes instead of a few hours.</source>
          <target state="translated">在每次签入SQLite源代码树之前,开发人员通常会运行Tcl测试的一个子集(称为 &quot;veryquick&quot;),其中包括大约24.85万个测试用例。veryquick测试包括除了异常、模糊和soak测试之外的大部分测试。veryquick测试背后的理念是,它们足以捕捉到大多数错误,但也只需几分钟就可以运行,而不是几个小时。</target>
        </trans-unit>
        <trans-unit id="ce5fd27df1123f4d155915fc1d5725287e09a7ea" translate="yes" xml:space="preserve">
          <source>Prior to making any changes to the database file, SQLite first creates a separate rollback journal file and writes into the rollback journal the original content of the database pages that are to be altered. The idea behind the rollback journal is that it contains all information needed to restore the database back to its original state.</source>
          <target state="translated">在对数据库文件进行任何修改之前,SQLite首先创建一个单独的回滚日志文件,并将要修改的数据库页面的原始内容写入回滚日志中。回滚日志背后的想法是,它包含了将数据库恢复到原始状态所需的所有信息。</target>
        </trans-unit>
        <trans-unit id="5e201518d0d186ad7cdf7483565006fe761fd040" translate="yes" xml:space="preserve">
          <source>Prior to making changes to the database file itself, we must obtain an exclusive lock on the database file. Obtaining an exclusive lock is really a two-step process. First SQLite obtains a &quot;pending&quot; lock. Then it escalates the pending lock to an exclusive lock.</source>
          <target state="translated">在对数据库文件本身进行修改之前,我们必须获得数据库文件的独占锁。获得独占锁实际上是一个两步走的过程。首先,SQLite会获得一个 &quot;待定 &quot;锁。然后,它将挂起的锁升级为独占锁。</target>
        </trans-unit>
        <trans-unit id="3f85c53dbe23e0808bcb91d75d8ad07e4c7bc69c" translate="yes" xml:space="preserve">
          <source>Prior to version 3.26.0 (2018-12-01), FOREIGN KEY references to a table that is renamed were only edited if the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=ON&lt;/a&gt;, or in other words if &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; were begin enforced. With &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=OFF&lt;/a&gt;, FOREIGN KEY constraints would not be changed when the table that the foreign key referred to (the &quot;&lt;a href=&quot;foreignkeys#parentchild&quot;&gt;parent table&lt;/a&gt;&quot;) was renamed. Beginning with version 3.26.0, FOREIGN KEY constraints are always converted when a table is renamed, unless the &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table=ON&lt;/a&gt; setting is engaged. The following table summaries the difference:</source>
          <target state="translated">在版本3.26.0（2018-12-01）之前，仅当&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys = ON&lt;/a&gt;或换句话说如果开始强制执行&lt;a href=&quot;foreignkeys&quot;&gt;外键约束&lt;/a&gt;时才编辑对重命名表的FOREIGN KEY引用。在&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys = OFF的情况下&lt;/a&gt;，重命名外键引用的表（&amp;ldquo; &lt;a href=&quot;foreignkeys#parentchild&quot;&gt;父表&lt;/a&gt; &amp;rdquo;）时，FOREIGN KEY约束不会更改。从3.26.0版开始，重命名表时始终会转换FOREIGN KEY约束，除非使用&lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table = ON&lt;/a&gt;设置。下表总结了不同之处：</target>
        </trans-unit>
        <trans-unit id="4367495333845697b7f484185297e72e4794158a" translate="yes" xml:space="preserve">
          <source>Prior to version 3.26.0 (2018-12-01), FOREIGN KEY references to a table that is renamed were only edited if the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=ON&lt;/a&gt;, or in other words if &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; were being enforced. With &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=OFF&lt;/a&gt;, FOREIGN KEY constraints would not be changed when the table that the foreign key referred to (the &quot;&lt;a href=&quot;foreignkeys#parentchild&quot;&gt;parent table&lt;/a&gt;&quot;) was renamed. Beginning with version 3.26.0, FOREIGN KEY constraints are always converted when a table is renamed, unless the &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table=ON&lt;/a&gt; setting is engaged. The following table summaries the difference:</source>
          <target state="translated">在版本3.26.0（2018-12-01）之前，仅当&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys = ON&lt;/a&gt;或换句话说如果强制执行&lt;a href=&quot;foreignkeys&quot;&gt;外键约束&lt;/a&gt;时才编辑对重命名表的FOREIGN KEY引用。在&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys = OFF的情况下&lt;/a&gt;，重命名外键引用的表（&amp;ldquo;&lt;a href=&quot;foreignkeys#parentchild&quot;&gt;父表&lt;/a&gt;&amp;rdquo;）时，FOREIGN KEY约束将不会更改。从3.26.0版开始，重命名表时始终会转换FOREIGN KEY约束，除非使用&lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table = ON&lt;/a&gt;设置。下表总结了不同之处：</target>
        </trans-unit>
        <trans-unit id="5f15493198f102fc11171baf7abf0e0dbb2b1e4b" translate="yes" xml:space="preserve">
          <source>Prior to version 3.5.0 the &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; function would try to reclaim memory from all database connections in the same thread as the sqlite3_release_memory() call. Beginning with version 3.5.0, the sqlite3_release_memory() function will attempt to reclaim memory from all database connections in all threads.</source>
          <target state="translated">在3.5.0版之前，&lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory（）&lt;/a&gt;函数将尝试从与sqlite3_release_memory（）调用相同的线程中的所有数据库连接中回收内存。从3.5.0版开始，sqlite3_release_memory（）函数将尝试从所有线程中的所有数据库连接中回收内存。</target>
        </trans-unit>
        <trans-unit id="4167592bfe9ab2523a8fde6561d95f830a107410" translate="yes" xml:space="preserve">
          <source>Prior to version 3.5.0 the &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; set an upper bound on heap memory usage for all database connections within a single thread. Each thread could have its own heap limit. Beginning in version 3.5.0, there is a single heap limit for the entire process. This seems more restrictive (one limit as opposed to many) but in practice it is what most users want.</source>
          <target state="translated">在版本3.5.0之前，&lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit（）&lt;/a&gt;设置单个线程内所有数据库连接的堆内存使用上限。每个线程可以有自己的堆限制。从3.5.0版开始，整个过程只有一个堆限制。这似乎更具限制性（一个限制而不是许多限制），但实际上这是大多数用户想要的。</target>
        </trans-unit>
        <trans-unit id="fc681e809e94e340265ecee10f223e6915cced6a" translate="yes" xml:space="preserve">
          <source>Prior to version 3.5.0, the &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; API would enable and disable the shared cache feature for all connections within a single thread - the same thread from which the sqlite3_enable_shared_cache() routine was called. Database connections that used the shared cache were restricted to running in the same thread in which they were opened. Beginning with version 3.5.0, the sqlite3_enable_shared_cache() applies to all database connections in all threads within the process. Now database connections running in separate threads can share a cache. And database connections that use shared cache can migrate from one thread to another.</source>
          <target state="translated">在版本3.5.0之前，&lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）&lt;/a&gt; API将为单个线程（调用sqlite3_enable_shared_cache（）例程的同一线程）中的所有连接启用和禁用共享缓存功能。使用共享缓存的数据库连接只能在打开它们的同一线程中运行。从版本3.5.0开始，sqlite3_enable_shared_cache（）适用于进程内所有线程中的所有数据库连接。现在，在单独线程中运行的数据库连接可以共享缓存。使用共享缓存的数据库连接可以从一个线程迁移到另一个线程。</target>
        </trans-unit>
        <trans-unit id="d828632471991da7903c0c2be934633680ad57e8" translate="yes" xml:space="preserve">
          <source>Process A now tries to write to the database. But process A's view of the database content is now obsolete because process B has modified the database file after process A read from it. Hence process A gets an SQLITE_BUSY_SNAPSHOT error.</source>
          <target state="translated">进程A现在试图向数据库写入内容。但是进程A对数据库内容的看法已经过时了,因为进程B在进程A从数据库文件中读取数据后修改了数据库文件。因此进程A得到一个SQLITE_BUSY_SNAPSHOT错误。</target>
        </trans-unit>
        <trans-unit id="6588c47b29127d1f98a87c238369e743b0e77d94" translate="yes" xml:space="preserve">
          <source>Process A starts a read transaction on the database and does one or more SELECT statement. Process A keeps the transaction open.</source>
          <target state="translated">进程A在数据库上启动一个读事务,并做一个或多个SELECT语句。进程A保持事务开放。</target>
        </trans-unit>
        <trans-unit id="7e082f5417cd4ab89e9c56b231bce953e66b35a9" translate="yes" xml:space="preserve">
          <source>Process B updates the database, changing values previous read by process A.</source>
          <target state="translated">进程B更新数据库,改变进程A之前读取的值。</target>
        </trans-unit>
        <trans-unit id="ee0914d299e6e7430a22ed0faafffc12d302d567" translate="yes" xml:space="preserve">
          <source>Productize and officially support the group_concat() SQL function.</source>
          <target state="translated">产品化并正式支持group_concat()SQL函数。</target>
        </trans-unit>
        <trans-unit id="9257f2cbe973bd89967c512a0ab4ef3a71be8dcc" translate="yes" xml:space="preserve">
          <source>Profile guided optimization (PGO) is not helpful with SQLite. PGO results in binaries that are about 1% larger and about 0.33% slower.</source>
          <target state="translated">Profile guided optimization (PGO)对SQLite没有帮助。PGO会导致二进制文件大1%左右,慢0.33%左右。</target>
        </trans-unit>
        <trans-unit id="b46994e8cc3c2683acbfd969c84c88b83b02d9c0" translate="yes" xml:space="preserve">
          <source>Profiling indicates that for most systems and in most circumstances SQLite spends most of its time doing disk I/O. It follows then that anything we can do to reduce the amount of disk I/O will likely have a large positive impact on the performance of SQLite. This section describes some of the techniques used by SQLite to try to reduce the amount of disk I/O to a minimum while still preserving atomic commit.</source>
          <target state="translated">剖析表明,对于大多数系统和大多数情况下,SQLite的大部分时间都在做磁盘I/O。那么由此可见,任何我们可以做的减少磁盘I/O量的事情,都可能对SQLite的性能产生很大的积极影响。本节介绍了SQLite使用的一些技术,以尝试将磁盘I/O量减少到最小,同时仍然保留原子提交。</target>
        </trans-unit>
        <trans-unit id="9d68007b0763cb230f9034ec96f52b39d03ad630" translate="yes" xml:space="preserve">
          <source>Program</source>
          <target state="translated">Program</target>
        </trans-unit>
        <trans-unit id="6bc5295aed74aa8af8bf9a74f722f2706e580d3c" translate="yes" xml:space="preserve">
          <source>Programmers are cautioned not to use the two exceptions described in the previous bullets. We emphasize that they exist only so that old and ill-formed SQL statements will run correctly. Future versions of SQLite might raise errors instead of accepting the malformed statements covered by the exceptions above.</source>
          <target state="translated">我们提醒程序员不要使用前面小节中描述的两种异常。我们强调,它们的存在只是为了让旧的和格式不正确的SQL语句能够正确运行。未来版本的SQLite可能会引发错误,而不是接受上述异常所涵盖的畸形语句。</target>
        </trans-unit>
        <trans-unit id="442f2f1b223aedc9d27d672e9d91f49a3b27fb5b" translate="yes" xml:space="preserve">
          <source>Programmers can force SQLite to use a particular loop nesting order for a join by using the CROSS JOIN operator instead of just JOIN, INNER JOIN, NATURAL JOIN, or a &quot;,&quot; join. Though CROSS JOINs are commutative in theory, SQLite chooses to never reorder the tables in a CROSS JOIN. Hence, the left table of a CROSS JOIN will always be in an outer loop relative to the right table.</source>
          <target state="translated">程序员可以通过使用CROSS JOIN操作符而不是仅仅使用JOIN、INNER JOIN、NATURAL JOIN或&quot;,&quot;连接来强制SQLite为连接使用特定的循环嵌套顺序。尽管CROSS JOIN在理论上是互换的,但SQLite选择永远不对CROSS JOIN中的表重新排序。因此,CROSS JOIN的左边表总是相对于右边表处于外循环中。</target>
        </trans-unit>
        <trans-unit id="9ecd00ed19c9aa2f215c5b5e8453037ffd17fc89" translate="yes" xml:space="preserve">
          <source>Programming Interfaces</source>
          <target state="translated">编程接口</target>
        </trans-unit>
        <trans-unit id="1c8b4bfbf1e2ec54cc62ffa3332992d5ae9a4350" translate="yes" xml:space="preserve">
          <source>Programming Loadable Extensions</source>
          <target state="translated">可加载式扩展编程</target>
        </trans-unit>
        <trans-unit id="19ca1fa808a68639f1670f7213bf267471fdbd20" translate="yes" xml:space="preserve">
          <source>Programs contain a single instance of this opcode as the very first opcode.</source>
          <target state="translated">程序包含这个操作码的一个实例作为第一个操作码。</target>
        </trans-unit>
        <trans-unit id="7b85e7edf23f7121981c9a7f81acf2f88e25d897" translate="yes" xml:space="preserve">
          <source>Prohibit the use of SQL functions inside triggers, views, CHECK constraints, DEFAULT clauses, expression indexes, partial indexes, or generated columns unless those functions are tagged with &lt;a href=&quot;#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt;.</source>
          <target state="translated">禁止在触发器，视图，CHECK约束，DEFAULT子句，表达式索引，部分索引或生成的列中使用SQL函数，除非这些函数用&lt;a href=&quot;#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt;标记。</target>
        </trans-unit>
        <trans-unit id="836cdbe091f8e6d2e0a3bc0953580f5b61d80d1b" translate="yes" xml:space="preserve">
          <source>Prohibit the use of SQL functions inside triggers, views, CHECK constraints, DEFAULT clauses, expression indexes, partial indexes, or generated columns unless those functions are tagged with &lt;a href=&quot;c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt;.</source>
          <target state="translated">禁止在触发器，视图，CHECK约束，DEFAULT子句，表达式索引，部分索引或生成的列中使用SQL函数，除非这些函数用&lt;a href=&quot;c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt;标记。</target>
        </trans-unit>
        <trans-unit id="a4131fb0c74864c2b5168b32ce6c60e9b911d245" translate="yes" xml:space="preserve">
          <source>Prohibit the use of virtual tables inside of triggers or views unless those virtual tables are tagged with &lt;a href=&quot;#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUS&lt;/a&gt;.</source>
          <target state="translated">禁止在触发器或视图内使用虚拟表，除非这些虚拟表已用&lt;a href=&quot;#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUS&lt;/a&gt;标记。</target>
        </trans-unit>
        <trans-unit id="0dd1398efbb71440f12c0472c04e04e100c1dd4b" translate="yes" xml:space="preserve">
          <source>Prohibit the use of virtual tables inside of triggers or views unless those virtual tables are tagged with &lt;a href=&quot;c_vtab_constraint_support#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUS&lt;/a&gt;.</source>
          <target state="translated">禁止在触发器或视图内使用虚拟表，除非这些虚拟表已用&lt;a href=&quot;c_vtab_constraint_support#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUS&lt;/a&gt;标记。</target>
        </trans-unit>
        <trans-unit id="1b341d69d9619d4d85640d6150737c146812b7c0" translate="yes" xml:space="preserve">
          <source>Provide &lt;a href=&quot;pragma#pragfunc&quot;&gt;PRAGMA functions&lt;/a&gt; for &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt;.</source>
          <target state="translated">提供&lt;a href=&quot;pragma#pragfunc&quot;&gt;PRAGMA函数，&lt;/a&gt;用于&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA完整性检查&lt;/a&gt;，&lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a4632572329984193ba91894b49406924b5a89d" translate="yes" xml:space="preserve">
          <source>Provide a hint to cursor P1 that it only needs to return rows that satisfy the Expr in P4. TK_REGISTER terms in the P4 expression refer to values currently held in registers. TK_COLUMN terms in the P4 expression refer to columns in the b-tree to which cursor P1 is pointing.</source>
          <target state="translated">给游标P1提供一个提示,即它只需要返回满足P4中Expr的记录。P4表达式中的TK_REGISTER项指的是当前存放在寄存器中的值。P4表达式中的TK_COLUMN项是指游标P1指向的b树中的列。</target>
        </trans-unit>
        <trans-unit id="054ee0d871e7b20122b3ff23a8374fbfb871d9ca" translate="yes" xml:space="preserve">
          <source>Provide an appropriate error message when the sqlite_master table contains a CREATE TABLE AS statement. Formerly this caused either an assertion fault or null pointer dereference. Problem found by OSSFuzz on the GDAL project. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/d75e67654aa96&quot;&gt;d75e67654aa96&lt;/a&gt;</source>
          <target state="translated">当sqlite_master表包含CREATE TABLE AS语句时，提供适当的错误消息。以前，这导致断言错误或空指针取消引用。OSSFuzz在GDAL项目上发现了问题。登机&lt;a href=&quot;https://www.sqlite.org/src/info/d75e67654aa96&quot;&gt;D75E67654AA96&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c2fd3e74c8200bf8ab45d458d069a0c702c0cd7" translate="yes" xml:space="preserve">
          <source>Provide the &lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparepersistent&quot;&gt;SQLITE_PREPARE_PERSISTENT&lt;/a&gt; flag for &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and use it to limit &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory&lt;/a&gt; misuse by &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, and the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;.</source>
          <target state="translated">为&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;提供&lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparepersistent&quot;&gt;SQLITE_PREPARE_PERSISTENT&lt;/a&gt;标志，并使用它来限制&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;，&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;和&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展的&lt;/a&gt;&lt;a href=&quot;malloc#lookaside&quot;&gt;后备内存&lt;/a&gt;滥用。</target>
        </trans-unit>
        <trans-unit id="0788f21345510b44c97d1a7ea9db2e84d27c5ed1" translate="yes" xml:space="preserve">
          <source>Provide the &lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset(X)&lt;/a&gt; SQL function that returns the byte offset into the database file to the beginning of the record holding value X, when compiling with &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt;.</source>
          <target state="translated">提供&lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset（X）&lt;/a&gt; SQL函数，该函数在使用&lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC进行&lt;/a&gt;编译时，将字节偏移量返回数据库文件中的记录保存值X的开头。</target>
        </trans-unit>
        <trans-unit id="6abc71c7c814cc2d05ebc22239e7790b1f15e917" translate="yes" xml:space="preserve">
          <source>Provide the ability to tag &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; with new properties &lt;a href=&quot;c3ref/c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt; or &lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;.</source>
          <target state="translated">提供使用新属性&lt;a href=&quot;c3ref/c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt;或&lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;标记&lt;a href=&quot;appfunc&quot;&gt;应用程序定义的SQL函数的功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fcb01e4e57cfae253305eca2f9007587c22f7fb2" translate="yes" xml:space="preserve">
          <source>Provides SQL access to the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; and &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interfaces.</source>
          <target state="translated">提供对&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64（）&lt;/a&gt;和&lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;接口的SQL访问。</target>
        </trans-unit>
        <trans-unit id="c78b408cda5c2c489b9c5ef105dac2382d881e16" translate="yes" xml:space="preserve">
          <source>Provides information about all files in a single check-in in the &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil version control system&lt;/a&gt;. This virtual table is not part of the SQLite project but is included because it provides an example of how to use virtual tables and because it is used to help version control the SQLite sources.</source>
          <target state="translated">在&lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil版本控制系统&lt;/a&gt;中的一次签入中提供有关所有文件的信息。该虚拟表不是SQLite项目的一部分，但包含在内，因为它提供了如何使用虚拟表的示例，并且因为它用于帮助版本控制SQLite源。</target>
        </trans-unit>
        <trans-unit id="3126f48ce2a68ae1473f8364444a7e563e9968c3" translate="yes" xml:space="preserve">
          <source>Provides information about the purpose and use of each page in a database file. Used in the implementation of the &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer&lt;/a&gt; utility program.</source>
          <target state="translated">提供有关数据库文件中每个页面的用途和用途的信息。在&lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer&lt;/a&gt;实用程序的实现中使用。</target>
        </trans-unit>
        <trans-unit id="bfec143c19b8a7da8ef2986bfdff976c6539b3dc" translate="yes" xml:space="preserve">
          <source>Pseudo-Random Number Generator</source>
          <target state="translated">伪随机数发生器</target>
        </trans-unit>
        <trans-unit id="52a406d334528b19ea259feaeb009e7160aeac5f" translate="yes" xml:space="preserve">
          <source>Ptrmap pages must exist in any database file which has a non-zero largest root b-tree page value at offset 52 in the database header. If the largest root b-tree page value is zero, then the database must not contain ptrmap pages.</source>
          <target state="translated">Ptrmap页必须存在于任何数据库文件中,在数据库头偏移量52处有一个非零的最大根b-tree页值。如果最大的根b树页值为零,那么数据库必须不包含ptrmap页。</target>
        </trans-unit>
        <trans-unit id="fe35e9945539e89cd05f704b37cf341406598782" translate="yes" xml:space="preserve">
          <source>Punctuation characters like &quot;,&quot; or &quot;==&quot; or &quot;;&quot;.</source>
          <target state="translated">标点符号,如&quot;,&quot;或&quot;==&quot;或&quot;;&quot;。</target>
        </trans-unit>
        <trans-unit id="b7a7b9c96916fe33cad00dfc0a31cbc73811f7fc" translate="yes" xml:space="preserve">
          <source>PureFunc</source>
          <target state="translated">PureFunc</target>
        </trans-unit>
        <trans-unit id="73f66c4bb296f02b5e558e94e1ebb8671640db19" translate="yes" xml:space="preserve">
          <source>Purging a Dirty Page</source>
          <target state="translated">清除肮脏的页面</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="865ca2a73367e4e56f98cc35dd0cc7fe25f8e129" translate="yes" xml:space="preserve">
          <source>Push the next &quot;thing&quot; onto the stack and fall through OR jump to P2, depending on whether or not there is a next &quot;thing&quot; to push.</source>
          <target state="translated">把下一个 &quot;东西 &quot;推到栈道上,然后掉过去OR跳到P2,看是否有下一个 &quot;东西 &quot;可以推。</target>
        </trans-unit>
        <trans-unit id="0555ed5711adce7afcbd2d3235114460d585953d" translate="yes" xml:space="preserve">
          <source>Put all identifier names inside double-quotes. This is the official SQL way to escape identifier names.</source>
          <target state="translated">将所有的标识符名称放在双引号内。这是官方的SQL转义标识符名称的方式。</target>
        </trans-unit>
        <trans-unit id="73eb67d0cb954e65c543496b0577de68b482cb5a" translate="yes" xml:space="preserve">
          <source>Put identifier names inside [...]. This is not standard SQL, but it is what SQL Server does and so lots of programmers use this technique.</source>
          <target state="translated">把标识符名称放在[...]里面。这不是标准的SQL,但这是SQL Server的做法,所以很多程序员都使用这种技术。</target>
        </trans-unit>
        <trans-unit id="e8b5818c3fdaa2a399fa24163289f33ef9912b79" translate="yes" xml:space="preserve">
          <source>Put the macro &quot;&lt;code&gt;SQLITE_EXTENSION_INIT1&lt;/code&gt;&quot; on a line by itself right after the &quot;&lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt;&quot; line.</source>
          <target state="translated">将宏&amp;ldquo; &lt;code&gt;SQLITE_EXTENSION_INIT1&lt;/code&gt; &amp;rdquo; 单独放在一行&amp;ldquo; &lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt; &amp;rdquo;之后。</target>
        </trans-unit>
        <trans-unit id="36dc5ec2a56fbc19dcd1aa69b72dba8e93123b26" translate="yes" xml:space="preserve">
          <source>Put your hope in God.</source>
          <target state="translated">把你的希望放在上帝身上。</target>
        </trans-unit>
        <trans-unit id="c3156e00d3c2588c639e0d3cf6821258b05761c7" translate="yes" xml:space="preserve">
          <source>Q</source>
          <target state="translated">Q</target>
        </trans-unit>
        <trans-unit id="4ae694911c3fee4e1df954bf5e225e075d582d11" translate="yes" xml:space="preserve">
          <source>QUERY</source>
          <target state="translated">QUERY</target>
        </trans-unit>
        <trans-unit id="ebdfba68a60db859050a346ba6621b2d1c232869" translate="yes" xml:space="preserve">
          <source>Quality Management</source>
          <target state="translated">质量管理</target>
        </trans-unit>
        <trans-unit id="3dd6362242ec4d8e950fc308f0c9c5371ac3e523" translate="yes" xml:space="preserve">
          <source>Quality assurance in SQLite is done using &lt;a href=&quot;testing#coverage&quot;&gt;full-coverage testing&lt;/a&gt;, not by compiler warnings or other static code analysis tools. In other words, we verify that SQLite actually gets the correct answer, not that it merely satisfies stylistic constraints. Most of the SQLite code base is devoted purely to testing. The SQLite test suite runs tens of thousands of separate test cases and many of those test cases are parameterized so that hundreds of millions of tests involving billions of SQL statements are run and evaluated for correctness prior to every release. The developers use code coverage tools to verify that all paths through the code are tested. Whenever a bug is found in SQLite, new test cases are written to exhibit the bug so that the bug cannot recur undetected in the future.</source>
          <target state="translated">SQLite中的质量保证是使用&lt;a href=&quot;testing#coverage&quot;&gt;全面测试&lt;/a&gt;来完成的，而不是通过编译器警告或其他静态代码分析工具来完成的。换句话说，我们验证SQLite确实得到了正确的答案，而不仅仅是它满足了样式约束。大多数SQLite代码库纯粹用于测试。 SQLite测试套件运行成千上万个单独的测试用例，并且其中许多测试用例已参数化，因此在每次发行之前，都要运行并评估涉及数十亿条SQL语句的亿万个测试的正确性。开发人员使用代码覆盖率工具来验证是否测试了所有通过代码的路径。每当在SQLite中发现错误时，都会编写新的测试用例来展示该错误，以便将来不会再次发现该错误。</target>
        </trans-unit>
        <trans-unit id="96ecb898d9fd59826f9555c415e65eadb6f74ead" translate="yes" xml:space="preserve">
          <source>Quality management documents tend to expand into binders full of incomprehensible jargon that nobody reads. This document strives to break that pattern by being concise and useful.</source>
          <target state="translated">质量管理文件往往会扩展成一个文件夹,里面装满了难以理解的专业术语,没有人阅读。本文件力图通过简洁和有用的方式打破这种模式。</target>
        </trans-unit>
        <trans-unit id="61b1d96663c5eb21b3f12fad273403f6ef48c73d" translate="yes" xml:space="preserve">
          <source>Queries (and also DELETE and UPDATE statements) in which the WHERE clause contains a bare geopoly_overlap() or geopoly_within() function make use of the underlying R*Tree data structures for a fast lookup that only has to examine a subset of the rows in the table. The number of rows examines depends, of course, on the size of the $query_polygon. Large $query_polygons will normally need to look at more rows than small ones.</source>
          <target state="translated">查询(还有DELETE和UPDATE语句)中的WHERE子句包含一个裸露的geopoly_overlap()或geopoly_within()函数,利用底层的R*Tree数据结构进行快速查找,只需要检查表中的行的子集。当然,检查的行数取决于$query_polygon的大小。大的$query_polygons通常比小的需要检查更多的行。</target>
        </trans-unit>
        <trans-unit id="5877d4b4dd805510713fc8b0f7324db5905fcfac" translate="yes" xml:space="preserve">
          <source>Queries Against A Graph</source>
          <target state="translated">对图表的查询</target>
        </trans-unit>
        <trans-unit id="83b570c5458fbacf6723ef9304ccc7570ee10af8" translate="yes" xml:space="preserve">
          <source>Queries against the rowid of a geopoly table are also very quick, even for tables with a vast number of rows. However, none of the auxiliary data columns are indexes, and so queries against the auxiliary data columns will involve a full table scan.</source>
          <target state="translated">针对地缘表的rowid的查询也是非常快的,即使是对于行数众多的表也是如此。但是,辅助数据列都不是索引,因此针对辅助数据列的查询将涉及到全表扫描。</target>
        </trans-unit>
        <trans-unit id="e655d8b919b6556f1f0ce40faccc63fe0ee22962" translate="yes" xml:space="preserve">
          <source>Queries of the form: &quot;SELECT max(x), y FROM table&quot; returns the value of y on the same row that contains the maximum x value.</source>
          <target state="translated">形式的查询。&quot;SELECT max(x),y FROM table &quot;返回的是包含最大x值的同一行的y值。</target>
        </trans-unit>
        <trans-unit id="e4ff6a5e7ac06c745f7d49496f70f4a140defd99" translate="yes" xml:space="preserve">
          <source>Queries that contain a single MIN() or MAX() aggregate function whose argument is the left-most column of an index might be satisfied by doing a single index lookup rather than by scanning the entire table. Examples:</source>
          <target state="translated">包含单个MIN()或MAX()集合函数的查询,其参数是索引的最左列,可能会通过做单个索引查找而不是扫描整个表来满足。例子。</target>
        </trans-unit>
        <trans-unit id="29a6a39bdba4fd39660625514af2f1cb40b3edcf" translate="yes" xml:space="preserve">
          <source>Queries that contain subqueries must sometime evaluate the subqueries separately and store the results in a temporary table, then use the content of the temporary table to evaluate the outer query. We call this &quot;materializing&quot; the subquery. The query optimizer in SQLite attempts to avoid materializing, but sometimes it is not easily avoidable. The temporary tables created by materialization are each stored in their own separate temporary file, which is automatically deleted at the conclusion of the query. The size of these temporary tables depends on the amount of data in the materialization of the subquery, of course.</source>
          <target state="translated">包含子查询的查询必须在某个时候分别对子查询进行评估,并将结果存储在一个临时表中,然后使用临时表的内容来评估外层查询。我们称这为子查询的 &quot;物质化&quot;。SQLite中的查询优化器试图避免物化,但有时不易避免。物质化创建的临时表分别存储在自己的临时文件中,在查询结束后会自动删除。当然,这些临时表的大小取决于子查询的物化中的数据量。</target>
        </trans-unit>
        <trans-unit id="cfbd9457ec43caaedb5b89c759265cf2be427fe5" translate="yes" xml:space="preserve">
          <source>Queries that use ORDER BY and LIMIT now try to avoid computing rows that cannot possibly come in under the LIMIT. This can greatly improve performance of ORDER BY LIMIT queries, especially when the LIMIT is small relative to the number of unrestricted output rows.</source>
          <target state="translated">使用ORDER BY和LIMIT的查询现在会尽量避免计算那些不可能在LIMIT下进来的行。这可以极大地提高ORDER BY LIMIT查询的性能,特别是当LIMIT相对于非限制性输出行的数量较少时。</target>
        </trans-unit>
        <trans-unit id="e885c97cd0eb73037d91afe0e25f71733d813af5" translate="yes" xml:space="preserve">
          <source>Query Language Understood by SQLite</source>
          <target state="translated">SQLite所理解的查询语言</target>
        </trans-unit>
        <trans-unit id="3d4f16fd1d91b47c556b84948dabe05573437a3d" translate="yes" xml:space="preserve">
          <source>Query Planner</source>
          <target state="translated">查询规划器</target>
        </trans-unit>
        <trans-unit id="efa9d81fc99ae6041fbe49339a919ef99bac7ade" translate="yes" xml:space="preserve">
          <source>Query Planning</source>
          <target state="translated">查询规划</target>
        </trans-unit>
        <trans-unit id="625af40606e435d60c7571eb3eaed21802aa70ee" translate="yes" xml:space="preserve">
          <source>Query Progress Callbacks</source>
          <target state="translated">查询进度回调</target>
        </trans-unit>
        <trans-unit id="4af542248ab5d4cfc6f1e9df7245e3bb184ea082" translate="yes" xml:space="preserve">
          <source>Query The EXPLAIN Setting For A Prepared Statement</source>
          <target state="translated">查询已准备好的语句的EXPLAIN设置。</target>
        </trans-unit>
        <trans-unit id="27930b82a7c3d467781ad3b52e0b1d9894281ffa" translate="yes" xml:space="preserve">
          <source>Query flattener</source>
          <target state="translated">扁平化查询器</target>
        </trans-unit>
        <trans-unit id="e60fdc9ba7fb5d86546748b364cd1dfbde0107e1" translate="yes" xml:space="preserve">
          <source>Query flattening is an important optimization when views are used as each use of a view is translated into a subquery.</source>
          <target state="translated">当使用视图时,查询扁平化是一个重要的优化,因为视图的每一次使用都会转化为一个子查询。</target>
        </trans-unit>
        <trans-unit id="bfee3391ed2fb89e3470d4d2a93c4c710274a3ef" translate="yes" xml:space="preserve">
          <source>Query for the details of phrase match iIdx within the current row. Phrase matches are numbered starting from zero, so the iIdx argument should be greater than or equal to zero and smaller than the value output by xInstCount().</source>
          <target state="translated">查询当前行中的短语匹配iIdx的详细信息,短语匹配从零开始编号,所以参数iIdx应该大于或等于零,小于xInstCount()输出的值。短语匹配从零开始编号,所以iIdx参数应该大于或等于零,小于xInstCount()输出的值。</target>
        </trans-unit>
        <trans-unit id="3a7dd1ac6b04f70fb3ec3bd5dfe2b333de122f27" translate="yes" xml:space="preserve">
          <source>Query optimizer enhancements:</source>
          <target state="translated">查询优化器增强。</target>
        </trans-unit>
        <trans-unit id="a2c73363a91970f8d7d0f3ba2033b2b1141c7659" translate="yes" xml:space="preserve">
          <source>Query optimizer improvements:</source>
          <target state="translated">查询优化器的改进。</target>
        </trans-unit>
        <trans-unit id="65d2f2329c994ccea3b5e213a1d1b909c0f33338" translate="yes" xml:space="preserve">
          <source>Query or change a limit on the &lt;a href=&quot;lang_analyze#approx&quot;&gt;approximate ANALYZE&lt;/a&gt; setting. This is approximate number of rows examined in each index by the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command. If the argument</source>
          <target state="translated">查询或更改&lt;a href=&quot;lang_analyze#approx&quot;&gt;ANALYZE近似&lt;/a&gt;设置的限制。这是&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令在每个索引中检查的大约行数。如果论点</target>
        </trans-unit>
        <trans-unit id="d0fbdef4345ce05f423c29e77346a76ae1183a9c" translate="yes" xml:space="preserve">
          <source>Query or change the count-changes flag. Normally, when the count-changes flag is not set, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements return no data. When count-changes is set, each of these commands returns a single row of data consisting of one integer value - the number of rows inserted, modified or deleted by the command. The returned change count does not include any insertions, modifications or deletions performed by triggers, any changes made automatically by &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt;, or updates caused by an &lt;a href=&quot;lang_upsert&quot;&gt;upsert&lt;/a&gt;.</source>
          <target state="translated">查询或更改计数更改标志。通常，当未设置count-changes标志时，&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;，&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;和&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;语句不返回任何数据。设置计数更改后，这些命令中的每条命令都返回一行数据，该数据由一个整数值组成-该命令插入，修改或删除的行数。返回的更改计数不包括触发器执行的任何插入，修改或删除，&lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;外键操作&lt;/a&gt;自动进行的任何更改或&lt;a href=&quot;lang_upsert&quot;&gt;upsert&lt;/a&gt;引起的更新。</target>
        </trans-unit>
        <trans-unit id="9a7df9605f2eec87d8f2db2efd84251b953fcfd6" translate="yes" xml:space="preserve">
          <source>Query or change the empty-result-callbacks flag.</source>
          <target state="translated">查询或更改空结果回调标志。</target>
        </trans-unit>
        <trans-unit id="4386c302fe03b8bf430568c307ba9f2bfa451ec8" translate="yes" xml:space="preserve">
          <source>Query or change the full_column_names flag. This flag together with the &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; flag determine the way SQLite assigns names to result columns of &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. Result columns are named by applying the following rules in order:</source>
          <target state="translated">查询或更改full_column_names标志。该标志与&lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt;标志一起确定了SQLite将名称分配给&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句的结果列的方式。通过按顺序应用以下规则来命名结果列：</target>
        </trans-unit>
        <trans-unit id="6ea33a7feb73dab172e527ce6afcb51892e3e546" translate="yes" xml:space="preserve">
          <source>Query or change the fullfsync flag for &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operations. If this flag is set, then the F_FULLFSYNC syncing method is used during checkpoint operations on systems that support F_FULLFSYNC. The default value of the checkpoint_fullfsync flag is off. Only Mac OS-X supports F_FULLFSYNC.</source>
          <target state="translated">查询或更改用于&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;操作的fullfsync标志。如果设置了此标志，则在支持F_FULLFSYNC的系统上的检查点操作期间将使用F_FULLFSYNC同步方法。checkpoint_fullfsync标志的默认值是off。仅Mac OS-X支持F_FULLFSYNC。</target>
        </trans-unit>
        <trans-unit id="563bc8c4477c1c2b886876e5894cd59e0001b35e" translate="yes" xml:space="preserve">
          <source>Query or change the fullfsync flag. This flag determines whether or not the F_FULLFSYNC syncing method is used on systems that support it. The default value of the fullfsync flag is off. Only Mac OS X supports F_FULLFSYNC.</source>
          <target state="translated">查询或更改fullfsync标志,该标志决定了在支持F_FULLFSYNC的系统上是否使用同步方法。这个标志决定了在支持F_FULLFSYNC的系统上是否使用F_FULLFSYNC同步方法。fullfsync标志的默认值是关闭。只有Mac OS X支持F_FULLFSYNC。</target>
        </trans-unit>
        <trans-unit id="77df4b91f1e34f39b185a6ee7e54e82d58dfa005" translate="yes" xml:space="preserve">
          <source>Query or change the maximum number of bytes that are set aside for memory-mapped I/O on a single database. The first form (without an argument) queries the current limit. The second form (with a numeric argument) sets the limit for the specified database, or for all databases if the optional database name is omitted. In the second form, if the database name is omitted, the limit that is set becomes the default limit for all databases that are added to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; by subsequent &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statements.</source>
          <target state="translated">查询或更改为单个数据库上的内存映射I / O预留的最大字节数。第一种形式（不带参数）查询当前限制。第二种形式（带有数字参数）设置指定数据库或所有数据库（如果省略了可选数据库名称）的限制。在第二种形式中，如果省略数据库名称，则设置的限制将成为通过后续&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;语句添加到&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;的所有数据库的默认限制。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
