<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="6e50e0d48c576b86d93a31befcc02f54e14b5267" translate="yes" xml:space="preserve">
          <source>There is the extra operation of &lt;a href=&quot;wal#ckpt&quot;&gt;checkpointing&lt;/a&gt; which, though automatic by default, is still something that application developers need to be mindful of.</source>
          <target state="translated">还有额外的&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;操作，尽管默认情况下是自动的，但仍然是应用程序开发人员需要注意的一点。</target>
        </trans-unit>
        <trans-unit id="62428f96be095192850e1858e6283c21fe02dd48" translate="yes" xml:space="preserve">
          <source>There is write permission on the directory containing the database so that the &lt;code&gt;-shm&lt;/code&gt; and &lt;code&gt;-wal&lt;/code&gt; files can be created.</source>
          <target state="translated">在包含数据库的目录上具有写许可权，因此可以创建 &lt;code&gt;-shm&lt;/code&gt; 和 &lt;code&gt;-wal&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="5b6352389dca7ff834f53599bb4e1238c6a257d8" translate="yes" xml:space="preserve">
          <source>There may be at most one unlock-notify callback registered by a blocked connection. If sqlite3_unlock_notify() is called when the blocked connection already has a registered unlock-notify callback, then the new callback replaces the old. If sqlite3_unlock_notify() is called with a NULL pointer as its second argument, then any existing unlock-notify callback is canceled. The blocked connections unlock-notify callback may also be canceled by closing the blocked connection using &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">被阻止的连接最多可以注册一个解锁通知回调。如果在阻止的连接已经具有注册的解锁通知回调时调用sqlite3_unlock_notify（），则新的回调将替换旧的回调。如果使用空指针作为第二个参数调用sqlite3_unlock_notify（），则将取消所有现有的unlock-notify回调。也可以通过使用&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close（）&lt;/a&gt;关闭被阻止的连接来取消被阻止的连接的解锁通知回调。</target>
        </trans-unit>
        <trans-unit id="474f04800d7576cb1df432f79959d44e97ec88c4" translate="yes" xml:space="preserve">
          <source>There may be at most one unlock-notify callback registered by a blocked connection. If sqlite3_unlock_notify() is called when the blocked connection already has a registered unlock-notify callback, then the new callback replaces the old. If sqlite3_unlock_notify() is called with a NULL pointer as its second argument, then any existing unlock-notify callback is canceled. The blocked connections unlock-notify callback may also be canceled by closing the blocked connection using &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">被阻止的连接最多可以注册一个解锁通知回调。如果在阻止的连接已经具有注册的解锁通知回调时调用sqlite3_unlock_notify（），则新的回调将替换旧的回调。如果使用空指针作为第二个参数调用sqlite3_unlock_notify（），则将取消所有现有的unlock-notify回调。也可以通过使用&lt;a href=&quot;close&quot;&gt;sqlite3_close（）&lt;/a&gt;关闭被阻止的连接来取消被阻止的连接的解锁通知回调。</target>
        </trans-unit>
        <trans-unit id="51e2e6b0569ca6a8c745966ed3e14378d13e60a9" translate="yes" xml:space="preserve">
          <source>There might be merge conflicts. In other words, it might be that the changes from (2) to (3) are incompatible with the changes from (1) to (4). In that case, the maintainer will have to manually resolve the conflicts. Hopefully conflicts will not come up that often. Conflicts are less likely to occur when the private edits are kept to a minimum.</source>
          <target state="translated">可能存在合并冲突。换句话说,可能是(2)至(3)的改动与(1)至(4)的改动不兼容。在这种情况下,维护者将不得不手动解决这些冲突。希望冲突不会那么频繁地出现。当私人编辑被保持在最低限度时,冲突就不太可能发生。</target>
        </trans-unit>
        <trans-unit id="c1f15675484de7896b9f4cea6917b5f96c0a2c61" translate="yes" xml:space="preserve">
          <source>There might be one or more &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; objects open and in use on the virtual table instance and perhaps even on the row of the virtual table when the xUpdate method is invoked. The implementation of xUpdate must be prepared for attempts to delete or modify rows of the table out from other existing cursors. If the virtual table cannot accommodate such changes, the xUpdate method must return an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">调用xUpdate方法时，可能在虚拟表实例上甚至在虚拟表的行上打开并使用了一个或多个&lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt;对象。xUpdate的实现必须准备好尝试从其他现有游标中删除或修改表的行。如果虚拟表不能容纳此类更改，则xUpdate方法必须返回&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f17a65d092891c67c0c7c0d6ffba57606e51c65a" translate="yes" xml:space="preserve">
          <source>There must be a read-lock on the database (either a transaction must be started or there must be an open cursor) before executing this instruction.</source>
          <target state="translated">在执行这条指令之前,必须在数据库上有一个读锁(必须启动一个事务或者必须有一个打开的游标)。</target>
        </trans-unit>
        <trans-unit id="838abced0ca5c629a232ce0c8ac382dc2a5201e9" translate="yes" xml:space="preserve">
          <source>There must be no overlap in the bands of rowids for the various tables in a union-vtab.</source>
          <target state="translated">在union-vtab中,各个表的rowids带不能有重叠。</target>
        </trans-unit>
        <trans-unit id="2f109c8b1d1e372963703dc38ccb68fefa2006aa" translate="yes" xml:space="preserve">
          <source>There must be no overlapping rowid ranges in the rows returned by the SQL statement. It is an error if there are.</source>
          <target state="translated">在SQL语句返回的行中,不能有重叠的rowid范围。如果有,则是错误。</target>
        </trans-unit>
        <trans-unit id="af3fe573da439b499f0025edd3eb3c7aa3d7e8cd" translate="yes" xml:space="preserve">
          <source>There must not be a write transaction open on schema S of database connection D.</source>
          <target state="translated">数据库连接D的模式S上一定没有打开一个写事务。</target>
        </trans-unit>
        <trans-unit id="3d41940c4561987aa3b448b06598e8d1c6472839" translate="yes" xml:space="preserve">
          <source>There should be exactly one call to sqlite3_backup_finish() for each successful call to sqlite3_backup_init().</source>
          <target state="translated">每成功调用一次sqlite3_backup_init(),应该正好有一次对sqlite3_backup_finish()的调用。</target>
        </trans-unit>
        <trans-unit id="9cf5a0f0e6851073aea7c635470af127d9d907d8" translate="yes" xml:space="preserve">
          <source>There were reports that SQLite did not perform as well on an indexed table. This test was recently added to disprove those rumors. It is true that SQLite is not as fast at creating new index entries as the other engines (see Test 6 below) but its overall speed is still better.</source>
          <target state="translated">有报道称,SQLite在索引表上的表现不尽如人意。最近增加了这个测试来否定这些传言。的确,SQLite在创建新索引项的速度上不如其他引擎(见下面的测试6),但其整体速度还是比较好的。</target>
        </trans-unit>
        <trans-unit id="7cdb3ca5132a0c3bc86c19fe3abd0889729f8701" translate="yes" xml:space="preserve">
          <source>These APIs are only available if the library was compiled with the &lt;a href=&quot;../compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; C-preprocessor symbol.</source>
          <target state="translated">仅当使用&lt;a href=&quot;../compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; C预处理器符号编译该库时，这些API才可用。</target>
        </trans-unit>
        <trans-unit id="04c8e718505dcab90cfc6233e2bd22375b7164d1" translate="yes" xml:space="preserve">
          <source>These APIs are only available if the library was compiled with the &lt;a href=&quot;compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; C-preprocessor symbol.</source>
          <target state="translated">仅当使用&lt;a href=&quot;compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; C预处理器符号编译该库时，这些API才可用。</target>
        </trans-unit>
        <trans-unit id="c0bacb531ef3c143611b93d8575c5722c7b86645" translate="yes" xml:space="preserve">
          <source>These action code values signify what kind of operation is to be authorized. The 3rd and 4th parameters to the authorization callback function will be parameters or NULL depending on which of these codes is used as the second parameter. The 5th parameter to the authorizer callback is the name of the database (&quot;main&quot;, &quot;temp&quot;, etc.) if applicable. The 6th parameter to the authorizer callback is the name of the inner-most trigger or view that is responsible for the access attempt or NULL if this access attempt is directly from top-level SQL code.</source>
          <target state="translated">这些动作代码值表示要授权的操作类型。授权回调函数的第3和第4个参数将是参数或NULL,这取决于这些代码中的哪个被用作第二个参数。授权回调的第5个参数是数据库的名称(&quot;main&quot;、&quot;temp &quot;等),如果适用的话。授权者回调的第6个参数是负责访问尝试的最内层触发器或视图的名称,如果这个访问尝试直接来自顶层SQL代码,则为NULL。</target>
        </trans-unit>
        <trans-unit id="08d99679f060455eb057ba3c4cf117bfe450c567" translate="yes" xml:space="preserve">
          <source>These and other similar syntax restrictions are described in the text.</source>
          <target state="translated">这些和其他类似的语法限制在文中有描述。</target>
        </trans-unit>
        <trans-unit id="373ccf29c36481aabf98cf8d5fcf341e72288794" translate="yes" xml:space="preserve">
          <source>These are just a few of the benefits of using SQLite as an application file format &amp;mdash; the benefits that seem most likely to improve the user experience for applications like OpenOffice. Other applications might benefit from SQLite in different ways. See the &lt;a href=&quot;appfileformat&quot;&gt;Application File Format&lt;/a&gt; document for additional ideas.</source>
          <target state="translated">这些只是将SQLite用作应用程序文件格式的一些好处-这些好处似乎最有可能改善OpenOffice等应用程序的用户体验。其他应用程序可能会以不同的方式受益于SQLite。有关其他建议，请参见&amp;ldquo; &lt;a href=&quot;appfileformat&quot;&gt;应用程序文件格式&amp;rdquo;&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="840704459c7bebebba604f0b7c84031cf12ac5c7" translate="yes" xml:space="preserve">
          <source>These are special values for the destructor that is passed in as the final argument to routines like &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_blob()&lt;/a&gt;. If the destructor argument is SQLITE_STATIC, it means that the content pointer is constant and will never change. It does not need to be destroyed. The SQLITE_TRANSIENT value means that the content will likely change in the near future and that SQLite should make its own private copy of the content before returning.</source>
          <target state="translated">这些是析构函数的特殊值，这些值作为最终参数传递给诸如&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_blob（）之&lt;/a&gt;类的例程。如果析构函数参数为SQLITE_STATIC，则表示内容指针是常量，并且永远不会更改。它不需要被销毁。SQLITE_TRANSIENT值表示内容可能会在不久的将来更改，并且SQLite应该在返回之前对其内容进行私有复制。</target>
        </trans-unit>
        <trans-unit id="3097b1326f3eb788f48bb5e49292e793f88d3f73" translate="yes" xml:space="preserve">
          <source>These are special values for the destructor that is passed in as the final argument to routines like &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_blob()&lt;/a&gt;. If the destructor argument is SQLITE_STATIC, it means that the content pointer is constant and will never change. It does not need to be destroyed. The SQLITE_TRANSIENT value means that the content will likely change in the near future and that SQLite should make its own private copy of the content before returning.</source>
          <target state="translated">这些是析构函数的特殊值，这些值作为最终参数传递给诸如&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_blob（）之&lt;/a&gt;类的例程。如果析构函数参数为SQLITE_STATIC，则表示内容指针是常量，并且永远不会更改。它不需要被销毁。SQLITE_TRANSIENT值表示内容可能会在不久的将来更改，并且SQLite应该在返回之前对其内容进行私有复制。</target>
        </trans-unit>
        <trans-unit id="49e507a42bf99a1526a38fb0d00d4e955eae6280" translate="yes" xml:space="preserve">
          <source>These are the eight locks supported:</source>
          <target state="translated">这就是支持的八把锁。</target>
        </trans-unit>
        <trans-unit id="b356241fa91bdf09876f0517086180731227ee47" translate="yes" xml:space="preserve">
          <source>These are utility routines, useful to &lt;a href=&quot;../vfs&quot;&gt;custom VFS implementations&lt;/a&gt;, that check if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ef0cc4c32969ca19f4793dd10614a44d9a509c" translate="yes" xml:space="preserve">
          <source>These are utility routines, useful to &lt;a href=&quot;vfs&quot;&gt;custom VFS implementations&lt;/a&gt;, that check if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61de6a061e0e9a67e085323db1a55d01abf6a99" translate="yes" xml:space="preserve">
          <source>These are utility routines, useful to VFS implementations, that check to see if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.</source>
          <target state="translated">这些都是对VFS实现有用的实用例程,它们检查数据库文件是否是一个包含特定查询参数的URI,如果是,则获得该查询参数的值。</target>
        </trans-unit>
        <trans-unit id="0ae1c1d92689387597a221cbf4a8586463c0d9b8" translate="yes" xml:space="preserve">
          <source>These bit values are intended for use in the 3rd parameter to the &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface and in the 4th parameter to the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method.</source>
          <target state="translated">这些位值旨在在&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;接口的第3个参数中以及在&lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;方法的第4个参数中使用。</target>
        </trans-unit>
        <trans-unit id="091c1cd775270574b7e8fe92576bddaa3dc774e3" translate="yes" xml:space="preserve">
          <source>These bit values are intended for use in the 3rd parameter to the &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface and in the 4th parameter to the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method.</source>
          <target state="translated">这些位值旨在在&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;接口的第3个参数中以及在&lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;方法的第4个参数中使用。</target>
        </trans-unit>
        <trans-unit id="7379d4e0ce4f6675fd9028087eadfa8eb7ff4976" translate="yes" xml:space="preserve">
          <source>These changes in the default behavior of SQLite are not a compatibility break. All legacy database files continue to be readable and writable by newer versions of SQLite, and all newly created database files continue to be readable and writable by legacy versions of the SQLite library. The only thing that is changing is some default settings. This should result in a performance increase for many applications.</source>
          <target state="translated">SQLite默认行为的这些变化并不是兼容性的破坏。所有遗留的数据库文件都可以继续被新版本的SQLite读取和写入,所有新创建的数据库文件也可以继续被遗留版本的SQLite库读取和写入。唯一改变的是一些默认设置。这应该会使许多应用程序的性能得到提高。</target>
        </trans-unit>
        <trans-unit id="f8b6f19362cf61de4d3d35983b38ffd9c2bbd4d6" translate="yes" xml:space="preserve">
          <source>These constant define integer codes that represent the various text encodings supported by SQLite.</source>
          <target state="translated">这些常量定义了代表SQLite支持的各种文本编码的整数代码。</target>
        </trans-unit>
        <trans-unit id="28ee7781baba8510621fd94348e40d728944ee20" translate="yes" xml:space="preserve">
          <source>These constants are codes for each of those types.</source>
          <target state="translated">这些常量是这些类型的代码。</target>
        </trans-unit>
        <trans-unit id="5d678085fc410906abd9ecdf3f62895a2bdac8f9" translate="yes" xml:space="preserve">
          <source>These constants are returned by &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; to inform a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation what the &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is for the SQL statement being evaluated.</source>
          <target state="translated">这些常量由&lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;返回，以通知&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;实现所评估的SQL语句的&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;模式是什么。</target>
        </trans-unit>
        <trans-unit id="8d5af3a6c05bd2fcca2c0f972b2fd66256957f31" translate="yes" xml:space="preserve">
          <source>These constants are returned by &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; to inform a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementation what the &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is for the SQL statement being evaluated.</source>
          <target state="translated">这些常量由&lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;返回，以通知&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;实现所评估的SQL语句的&lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;模式是什么。</target>
        </trans-unit>
        <trans-unit id="e0814beadd7fffeacf97b8f77142e48bc418e590" translate="yes" xml:space="preserve">
          <source>These constants are the available integer &quot;verbs&quot; that can be passed as the second argument to the &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface.</source>
          <target state="translated">这些常量是可用的整数&amp;ldquo;动词&amp;rdquo;，可以作为第二个参数传递给&lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="ee8e50c4c247f1789de616c3122fcd5d75fef481" translate="yes" xml:space="preserve">
          <source>These constants are the available integer &quot;verbs&quot; that can be passed as the second argument to the &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface.</source>
          <target state="translated">这些常量是可用的整数&amp;ldquo;动词&amp;rdquo;，可以作为第二个参数传递给&lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="5685826d85b489c4a4722d59958f312636d778f9" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the first argument to the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; interface.</source>
          <target state="translated">这些常量是可用的整数配置选项，可以作为第一个参数传递给&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="cb2ae78ea5b1ae2e5bfc176e2229bcc4eaa83a74" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the first argument to the &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; interface.</source>
          <target state="translated">这些常量是可用的整数配置选项，可以作为第一个参数传递给&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="b8b83f50bcee4d621ab3350b27ae006d83053d8d" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the second argument to the &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface.</source>
          <target state="translated">这些常量是可用的整数配置选项，可以作为第二个参数传递给&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="bfdbb7c579979335802d5433a0c4351cc2e64138" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the second argument to the &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface.</source>
          <target state="translated">这些常量是可用的整数配置选项，可以作为第二个参数传递给&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="adcbc56bb51ca533b4d845770250da49d6cb92e5" translate="yes" xml:space="preserve">
          <source>These constants are the valid operation code parameters used as the first argument to &lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt;.</source>
          <target state="translated">这些常量是有效的操作代码参数，用作&lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control（）&lt;/a&gt;的第一个参数。</target>
        </trans-unit>
        <trans-unit id="c9e83fda514b191357ca2f8a433c34a6a2561552" translate="yes" xml:space="preserve">
          <source>These constants are the valid operation code parameters used as the first argument to &lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt;.</source>
          <target state="translated">这些常量是有效的操作代码参数，用作&lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control（）&lt;/a&gt;的第一个参数。</target>
        </trans-unit>
        <trans-unit id="01b7633fac6735c207dc2ef793e2ed3c159bf015" translate="yes" xml:space="preserve">
          <source>These constants define all valid values for the &quot;checkpoint mode&quot; passed as the third parameter to the &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface. See the &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; documentation for details on the meaning of each of these checkpoint modes.</source>
          <target state="translated">这些常量定义了作为&amp;ldquo;检查点模式&amp;rdquo;的所有有效值，这些值作为第三个参数传递到&lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;接口。有关每种检查点模式含义的详细信息，请参见&lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="1096d3bfc46b56a1b04a8f3fad11f5e8e55e3e9f" translate="yes" xml:space="preserve">
          <source>These constants define all valid values for the &quot;checkpoint mode&quot; passed as the third parameter to the &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface. See the &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; documentation for details on the meaning of each of these checkpoint modes.</source>
          <target state="translated">这些常量定义了作为&amp;ldquo;检查点模式&amp;rdquo;的所有有效值，这些值作为第三个参数传递到&lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;接口。有关每种检查点模式含义的详细信息，请参见&lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="f262688fc8aaf9f38b8c78556de1b6829b6de723" translate="yes" xml:space="preserve">
          <source>These constants define various flags that can be passed into &quot;prepFlags&quot; parameter of the &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; interfaces.</source>
          <target state="translated">这些常量定义了各种标志，可以将这些标志传递到&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;接口的&amp;ldquo; prepFlags&amp;rdquo;参数中。</target>
        </trans-unit>
        <trans-unit id="52a7e652cd3193b904625b47cf5fc5b4007943d0" translate="yes" xml:space="preserve">
          <source>These constants define various flags that can be passed into &quot;prepFlags&quot; parameter of the &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; interfaces.</source>
          <target state="translated">这些常量定义了各种标志，可以将这些标志传递到&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;和&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;接口的&amp;ldquo; prepFlags&amp;rdquo;参数中。</target>
        </trans-unit>
        <trans-unit id="f4779c39284f3e8f89de78b1cf22bb4300a2dde2" translate="yes" xml:space="preserve">
          <source>These constants define various performance limits that can be lowered at run-time using &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt;. The synopsis of the meanings of the various limits is shown below. Additional information is available at &lt;a href=&quot;limits&quot;&gt;Limits in SQLite&lt;/a&gt;.</source>
          <target state="translated">这些常量定义了各种性能限制，可以在运行时使用&lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;降低这些限制。各种限制含义的摘要如下所示。有关更多信息，请&lt;a href=&quot;limits&quot;&gt;参见SQLite&lt;/a&gt;中的Limits。</target>
        </trans-unit>
        <trans-unit id="dc33a9fdf99d3b7c3164b92212d61358e77ed2b2" translate="yes" xml:space="preserve">
          <source>These constants define various performance limits that can be lowered at run-time using &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt;. The synopsis of the meanings of the various limits is shown below. Additional information is available at &lt;a href=&quot;../limits&quot;&gt;Limits in SQLite&lt;/a&gt;.</source>
          <target state="translated">这些常量定义了各种性能限制，可以在运行时使用&lt;a href=&quot;limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;降低这些限制。各种限制含义的摘要如下所示。有关更多信息，请&lt;a href=&quot;../limits&quot;&gt;参见SQLite&lt;/a&gt;中的Limits。</target>
        </trans-unit>
        <trans-unit id="2d9ca50401c9fc616026596d32b3930da4b3846d" translate="yes" xml:space="preserve">
          <source>These constants identify classes of events that can be monitored using the &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; tracing logic. The M argument to &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2(D,M,X,P)&lt;/a&gt; is an OR-ed combination of one or more of the following constants. The first argument to the trace callback is one of the following constants.</source>
          <target state="translated">这些常量标识可以使用&lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;跟踪逻辑进行监视的事件类别。&lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2（D，M，X，P）&lt;/a&gt;的M参数是一个或多个以下常量的或运算组合。跟踪回调的第一个参数是以下常量之一。</target>
        </trans-unit>
        <trans-unit id="ed407cdd4869216425bae7d051975b3bcd0fdc3b" translate="yes" xml:space="preserve">
          <source>These constants identify classes of events that can be monitored using the &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; tracing logic. The M argument to &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2(D,M,X,P)&lt;/a&gt; is an OR-ed combination of one or more of the following constants. The first argument to the trace callback is one of the following constants.</source>
          <target state="translated">这些常量标识可以使用&lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;跟踪逻辑进行监视的事件类别。&lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2（D，M，X，P）&lt;/a&gt;的M参数是一个或多个以下常量的或运算组合。跟踪回调的第一个参数是以下常量之一。</target>
        </trans-unit>
        <trans-unit id="14266cc61d0db9a630a6d1107d408c2e2d4959a8" translate="yes" xml:space="preserve">
          <source>These constants may be ORed together with the &lt;a href=&quot;#SQLITE_ANY&quot;&gt;preferred text encoding&lt;/a&gt; as the fourth argument to &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt;.</source>
          <target state="translated">这些常量可以与&lt;a href=&quot;#SQLITE_ANY&quot;&gt;首选文本编码&lt;/a&gt;一起进行&amp;ldquo;或&amp;rdquo;运算，作为&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function_v2（）&lt;/a&gt;的第四个参数。</target>
        </trans-unit>
        <trans-unit id="4e4c2775c736d10a648ec5f64c5240681b8a597f" translate="yes" xml:space="preserve">
          <source>These constants may be ORed together with the &lt;a href=&quot;c_any&quot;&gt;preferred text encoding&lt;/a&gt; as the fourth argument to &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;, &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt;, or &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt;.</source>
          <target state="translated">这些常量可以与&lt;a href=&quot;c_any&quot;&gt;首选文本编码&lt;/a&gt;一起进行&amp;ldquo;或&amp;rdquo;运算，作为&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;，&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;或&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function_v2（）&lt;/a&gt;的第四个参数。</target>
        </trans-unit>
        <trans-unit id="d452c2a5987467cef42875b2093f98a07b801c06" translate="yes" xml:space="preserve">
          <source>These functions (collectively known as &quot;function creation routines&quot;) are used to add SQL functions or aggregates or to redefine the behavior of existing SQL functions or aggregates. The only differences between the three &quot;sqlite3_create_function*&quot; routines are the text encoding expected for the second parameter (the name of the function being created) and the presence or absence of a destructor callback for the application data pointer. Function sqlite3_create_window_function() is similar, but allows the user to supply the extra callback functions needed by &lt;a href=&quot;../windowfunctions#aggwinfunc&quot;&gt;aggregate window functions&lt;/a&gt;.</source>
          <target state="translated">这些函数（统称为&amp;ldquo;函数创建例程&amp;rdquo;）用于添加SQL函数或聚合或重新定义现有SQL函数或聚合的行为。这三个&amp;ldquo; sqlite3_create_function *&amp;rdquo;例程之间的唯一区别是，第二个参数（正在创建的函数的名称）预期的文本编码以及应用程序数据指针是否存在析构函数回调。函数sqlite3_create_window_function（）类似，但允许用户提供&lt;a href=&quot;../windowfunctions#aggwinfunc&quot;&gt;聚合窗口函数&lt;/a&gt;所需的额外回调函数。</target>
        </trans-unit>
        <trans-unit id="460bddf16e550adbe692fb026aea91fd5c1a8fa1" translate="yes" xml:space="preserve">
          <source>These functions (collectively known as &quot;function creation routines&quot;) are used to add SQL functions or aggregates or to redefine the behavior of existing SQL functions or aggregates. The only differences between the three &quot;sqlite3_create_function*&quot; routines are the text encoding expected for the second parameter (the name of the function being created) and the presence or absence of a destructor callback for the application data pointer. Function sqlite3_create_window_function() is similar, but allows the user to supply the extra callback functions needed by &lt;a href=&quot;windowfunctions#aggwinfunc&quot;&gt;aggregate window functions&lt;/a&gt;.</source>
          <target state="translated">这些函数（统称为&amp;ldquo;函数创建例程&amp;rdquo;）用于添加SQL函数或聚合或重新定义现有SQL函数或聚合的行为。这三个&amp;ldquo; sqlite3_create_function *&amp;rdquo;例程之间的唯一区别是，第二个参数（正在创建的函数的名称）预期的文本编码以及应用程序数据指针是否存在析构函数回调。函数sqlite3_create_window_function（）类似，但允许用户提供&lt;a href=&quot;windowfunctions#aggwinfunc&quot;&gt;聚合窗口函数&lt;/a&gt;所需的额外回调函数。</target>
        </trans-unit>
        <trans-unit id="f5aa8ee7f5d5dcd17c7a255e21fd6564afc6f3cb" translate="yes" xml:space="preserve">
          <source>These functions add, remove, or modify a &lt;a href=&quot;../datatype3#collation&quot;&gt;collation&lt;/a&gt; associated with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; specified as the first argument.</source>
          <target state="translated">这些函数添加，删除或修改与指定为第一个参数的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;关联的&lt;a href=&quot;../datatype3#collation&quot;&gt;排序规则&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed63a5a7289985766e806cdca8d318ceb652f682" translate="yes" xml:space="preserve">
          <source>These functions add, remove, or modify a &lt;a href=&quot;datatype3#collation&quot;&gt;collation&lt;/a&gt; associated with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; specified as the first argument.</source>
          <target state="translated">这些函数添加，删除或修改与指定为第一个参数的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;关联的&lt;a href=&quot;datatype3#collation&quot;&gt;排序规则&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e828096ae0ef377574b3a48a5e49c755665e8418" translate="yes" xml:space="preserve">
          <source>These functions are &lt;a href=&quot;capi3ref&quot;&gt;deprecated&lt;/a&gt;. In order to maintain backwards compatibility with older code, these functions continue to be supported. However, new applications should avoid the use of these functions. To encourage programmers to avoid these functions, we will not explain what they do.</source>
          <target state="translated">这些功能已被&lt;a href=&quot;capi3ref&quot;&gt;弃用&lt;/a&gt;。为了保持与旧代码的向后兼容性，将继续支持这些功能。但是，新的应用程序应避免使用这些功能。为了鼓励程序员避免使用这些功能，我们将不解释它们的作用。</target>
        </trans-unit>
        <trans-unit id="a53c5b52778acbd5177be1207d66b6e2855a89a9" translate="yes" xml:space="preserve">
          <source>These functions are &lt;a href=&quot;experimental&quot;&gt;deprecated&lt;/a&gt;. In order to maintain backwards compatibility with older code, these functions continue to be supported. However, new applications should avoid the use of these functions. To encourage programmers to avoid these functions, we will not explain what they do.</source>
          <target state="translated">这些功能已被&lt;a href=&quot;experimental&quot;&gt;弃用&lt;/a&gt;。为了保持与旧代码的向后兼容性，将继续支持这些功能。但是，新的应用程序应避免使用这些功能。为了鼓励程序员避免使用这些功能，我们将不解释它们的作用。</target>
        </trans-unit>
        <trans-unit id="20e0d52fc906194ab3c598ecb16113bb7e27244d" translate="yes" xml:space="preserve">
          <source>These functions may be used by (non-aggregate) SQL functions to associate metadata with argument values. If the same value is passed to multiple invocations of the same SQL function during query execution, under some circumstances the associated metadata may be preserved. An example of where this might be useful is in a regular-expression matching function. The compiled version of the regular expression can be stored as metadata associated with the pattern string. Then as long as the pattern string remains the same, the compiled regular expression can be reused on multiple invocations of the same function.</source>
          <target state="translated">这些函数可以被(非聚合)SQL函数用来将元数据与参数值关联起来。如果在查询执行过程中,相同的值被传递给同一个SQL函数的多次调用,在某些情况下,相关的元数据可能会被保留。在正则表达式匹配函数中,这可能是一个有用的例子。正则表达式的编译版本可以被存储为与模式字符串相关联的元数据。只要模式字符串保持不变,编译后的正则表达式就可以在多次调用同一函数时重复使用。</target>
        </trans-unit>
        <trans-unit id="6522a9f48ff48fe82ed5d5982cbd1db9ee5c56d5" translate="yes" xml:space="preserve">
          <source>These functions only work for dates between 0000-01-01 00:00:00 and 9999-12-31 23:59:59 (julian day numbers 1721059.5 through 5373484.5). For dates outside that range, the results of these functions are undefined.</source>
          <target state="translated">这些函数只适用于0000-01-01 00:00:00和9999-12-31 23:59:59之间的日期(儒略日数1721059.5至5373484.5)。对于这个范围之外的日期,这些函数的结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="05e896fbaa59935c0c643898daaa4791cc7323f5" translate="yes" xml:space="preserve">
          <source>These functions respectively add, subtract, and multiply their arguments and return a new text string that is the decimal representation of the result. There is no division operator at this time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8d304d80363d45f2a701bb02157d9c038cae0f9" translate="yes" xml:space="preserve">
          <source>These functions work very much like the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;parameter binding&lt;/a&gt; family of functions used to bind values to host parameters in prepared statements. Refer to the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL parameter&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">这些函数的工作方式与&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;参数绑定&lt;/a&gt;系列非常相似，该函数用于将值绑定到准备好的语句中的主机参数。有关其他信息，请参考&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL参数&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="b317ce2527b91fa298699867534154a11da36ac3" translate="yes" xml:space="preserve">
          <source>These functions work very much like the &lt;a href=&quot;bind_blob&quot;&gt;parameter binding&lt;/a&gt; family of functions used to bind values to host parameters in prepared statements. Refer to the &lt;a href=&quot;bind_blob&quot;&gt;SQL parameter&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">这些函数的工作方式与&lt;a href=&quot;bind_blob&quot;&gt;参数绑定&lt;/a&gt;系列非常相似，该函数用于将值绑定到准备好的语句中的主机参数。有关其他信息，请参考&lt;a href=&quot;bind_blob&quot;&gt;SQL参数&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="ab78522f9e6af4ebb0a819cdbba908125b1aa9de" translate="yes" xml:space="preserve">
          <source>These integer constants are opcodes for the xFileControl method of the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object and for the &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface.</source>
          <target state="translated">这些整数常量是&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象的xFileControl方法和&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;接口的操作码。</target>
        </trans-unit>
        <trans-unit id="a38e815d9a81f8a36563593031ac86d208aff3ef" translate="yes" xml:space="preserve">
          <source>These integer constants are opcodes for the xFileControl method of the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object and for the &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface.</source>
          <target state="translated">这些整数常量是&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象的xFileControl方法和&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;接口的操作码。</target>
        </trans-unit>
        <trans-unit id="ea60b84c9e9ef3033a276fcbd9184666b77d102f" translate="yes" xml:space="preserve">
          <source>These integer constants can be used as the third parameter to the xAccess method of an &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. They determine what kind of permissions the xAccess method is looking for. With SQLITE_ACCESS_EXISTS, the xAccess method simply checks whether the file exists. With SQLITE_ACCESS_READWRITE, the xAccess method checks whether the named directory is both readable and writable (in other words, if files can be added, removed, and renamed within the directory). The SQLITE_ACCESS_READWRITE constant is currently used only by the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, though this could change in a future release of SQLite. With SQLITE_ACCESS_READ, the xAccess method checks whether the file is readable. The SQLITE_ACCESS_READ constant is currently unused, though it might be used in a future release of SQLite.</source>
          <target state="translated">这些整数常量可用作&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的xAccess方法的第三个参数。它们确定xAccess方法正在寻找哪种权限。使用SQLITE_ACCESS_EXISTS，xAccess方法仅检查文件是否存在。使用SQLITE_ACCESS_READWRITE，xAccess方法检查命名目录是否可读写（换句话说，是否可以在目录中添加，删除和重命名文件）。SQLITE_ACCESS_READWRITE常量当前仅由&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma使用&lt;/a&gt;，尽管在将来的SQLite版本中可能会改变。使用SQLITE_ACCESS_READ，xAccess方法检查文件是否可读。SQLITE_ACCESS_READ常量当前未使用，尽管将来的SQLite版本中可能会使用它。</target>
        </trans-unit>
        <trans-unit id="311aa59e56c46be41f406ebc987fb4c56872151d" translate="yes" xml:space="preserve">
          <source>These integer constants can be used as the third parameter to the xAccess method of an &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. They determine what kind of permissions the xAccess method is looking for. With SQLITE_ACCESS_EXISTS, the xAccess method simply checks whether the file exists. With SQLITE_ACCESS_READWRITE, the xAccess method checks whether the named directory is both readable and writable (in other words, if files can be added, removed, and renamed within the directory). The SQLITE_ACCESS_READWRITE constant is currently used only by the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, though this could change in a future release of SQLite. With SQLITE_ACCESS_READ, the xAccess method checks whether the file is readable. The SQLITE_ACCESS_READ constant is currently unused, though it might be used in a future release of SQLite.</source>
          <target state="translated">这些整数常量可用作&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的xAccess方法的第三个参数。它们确定xAccess方法正在寻找哪种权限。使用SQLITE_ACCESS_EXISTS，xAccess方法仅检查文件是否存在。使用SQLITE_ACCESS_READWRITE，xAccess方法检查命名目录是否可读写（换句话说，是否可以在目录中添加，删除和重命名文件）。SQLITE_ACCESS_READWRITE常量当前仅由&lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma使用&lt;/a&gt;，尽管在将来的SQLite版本中可能会改变。使用SQLITE_ACCESS_READ，xAccess方法检查文件是否可读。SQLITE_ACCESS_READ常量当前未使用，尽管将来的SQLite版本中可能会使用它。</target>
        </trans-unit>
        <trans-unit id="8e30f4610e846824046fcc55a5610ab368656db0" translate="yes" xml:space="preserve">
          <source>These integer constants define the various locking operations allowed by the xShmLock method of &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;. The following are the only legal combinations of flags to the xShmLock method:</source>
          <target state="translated">这些整数常量定义&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;的xShmLock方法允许的各种锁定操作。以下是xShmLock方法的标志的唯一合法组合：</target>
        </trans-unit>
        <trans-unit id="63c61207725308cbbebcd362e48d34bfbbce9eff" translate="yes" xml:space="preserve">
          <source>These integer constants define the various locking operations allowed by the xShmLock method of &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;. The following are the only legal combinations of flags to the xShmLock method:</source>
          <target state="translated">这些整数常量定义&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;的xShmLock方法允许的各种锁定操作。以下是xShmLock方法的标志的唯一合法组合：</target>
        </trans-unit>
        <trans-unit id="46be45c61b7407297842f2bf5d770d15053c4ac4" translate="yes" xml:space="preserve">
          <source>These integer constants designate various run-time status parameters that can be returned by &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status()&lt;/a&gt;.</source>
          <target state="translated">这些整数常量指定&lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status（）&lt;/a&gt;可以返回的各种运行时状态参数。</target>
        </trans-unit>
        <trans-unit id="9d8a64fd442238eaa787788726abe76149b5cae0" translate="yes" xml:space="preserve">
          <source>These integer constants designate various run-time status parameters that can be returned by &lt;a href=&quot;status&quot;&gt;sqlite3_status()&lt;/a&gt;.</source>
          <target state="translated">这些整数常量指定&lt;a href=&quot;status&quot;&gt;sqlite3_status（）&lt;/a&gt;可以返回的各种运行时状态参数。</target>
        </trans-unit>
        <trans-unit id="1dd74d0b7bde7f62eaef94d29d31baa355fc24b9" translate="yes" xml:space="preserve">
          <source>These interfaces add content to an sqlite3_str object previously obtained from &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">这些接口将内容添加到先前从&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;获得的sqlite3_str对象。</target>
        </trans-unit>
        <trans-unit id="f4c68aa7a2ee53b8d7d01e966ec46bd4df66a0b8" translate="yes" xml:space="preserve">
          <source>These interfaces add content to an sqlite3_str object previously obtained from &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">这些接口将内容添加到先前从&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;获得的sqlite3_str对象。</target>
        </trans-unit>
        <trans-unit id="37d07c864bda5264afb416a4db651631968abf92" translate="yes" xml:space="preserve">
          <source>These interfaces are available only on Windows. The &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface is used to set the value associated with the &lt;a href=&quot;#sqlite3_temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; or &lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable, to zValue, depending on the value of the type parameter. The zValue parameter should be NULL to cause the previous value to be freed via &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;; a non-NULL value will be copied into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; prior to being used. The &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; to indicate success, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if the type is unsupported, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; if memory could not be allocated. The value of the &lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable is intended to act as a replacement for the current directory on the sub-platforms of Win32 where that concept is not present, e.g. WinRT and UWP. The &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt; and &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt; interfaces behave exactly the same as the sqlite3_win32_set_directory interface except the string parameter must be UTF-8 or UTF-16, respectively.</source>
          <target state="translated">这些接口仅在Windows上可用。所述&lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt;接口用于设置与所述相关联的值&lt;a href=&quot;#sqlite3_temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;或&lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt;变量，以zValue，取决于类型参数的值。 zValue参数应该为NULL，以使之前的值通过&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;释放；在使用之前，非NULL值将被复制到从&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;获得的内存中。该&lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt;接口返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;表示成功，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;如果类型不受支持，或&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;如果无法分配内存。所述的值&lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt;变量旨在充当用于在Win32的副平台当前的目录中替换，其中该概念不存在，例如WinRT的和UWP。的&lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt;和&lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt;接口行为完全相同，除了字符串参数的sqlite3_win32_set_directory接口必须是UTF-8或UTF-16，分别。</target>
        </trans-unit>
        <trans-unit id="e3077cf84285d5d0c77e1603a1b1cc3c809c60d7" translate="yes" xml:space="preserve">
          <source>These interfaces are available only on Windows. The &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface is used to set the value associated with the &lt;a href=&quot;temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; or &lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable, to zValue, depending on the value of the type parameter. The zValue parameter should be NULL to cause the previous value to be freed via &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;; a non-NULL value will be copied into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; prior to being used. The &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; to indicate success, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if the type is unsupported, or &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; if memory could not be allocated. The value of the &lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable is intended to act as a replacement for the current directory on the sub-platforms of Win32 where that concept is not present, e.g. WinRT and UWP. The &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt; and &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt; interfaces behave exactly the same as the sqlite3_win32_set_directory interface except the string parameter must be UTF-8 or UTF-16, respectively.</source>
          <target state="translated">这些接口仅在Windows上可用。所述&lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt;接口用于设置与所述相关联的值&lt;a href=&quot;temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;或&lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt;变量，以zValue，取决于类型参数的值。 zValue参数应该为NULL，以使之前的值通过&lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;释放；在使用之前，非NULL值将被复制到从&lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;获得的内存中。该&lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt;接口返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;表示成功，&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;如果类型不受支持，或&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;如果无法分配内存。所述的值&lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt;变量旨在充当用于在Win32的副平台当前的目录中替换，其中该概念不存在，例如WinRT的和UWP。的&lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt;和&lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt;接口行为完全相同，除了字符串参数的sqlite3_win32_set_directory接口必须是UTF-8或UTF-16，分别。</target>
        </trans-unit>
        <trans-unit id="bf73a94780de490a8f9c02eb38be04e9aad9c703" translate="yes" xml:space="preserve">
          <source>These interfaces are only available if SQLite is compiled using the &lt;a href=&quot;../compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt; compile-time option.</source>
          <target state="translated">仅当使用&lt;a href=&quot;../compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt;编译时选项编译SQLite时，这些接口才可用。</target>
        </trans-unit>
        <trans-unit id="2573d74316b2beb50fe8b93933b238b687b3e25f" translate="yes" xml:space="preserve">
          <source>These interfaces are only available if SQLite is compiled using the &lt;a href=&quot;compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt; compile-time option.</source>
          <target state="translated">仅当使用&lt;a href=&quot;compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt;编译时选项编译SQLite时，这些接口才可用。</target>
        </trans-unit>
        <trans-unit id="1dfbcb8f183f59b84e1cdc3c799c0026a4da7b1c" translate="yes" xml:space="preserve">
          <source>These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks. The first argument is an integer code for the specific parameter to measure. Recognized integer codes are of the form &lt;a href=&quot;#SQLITE_STATUS_MALLOC_COUNT&quot;&gt;SQLITE_STATUS_...&lt;/a&gt;. The current value of the parameter is returned into *pCurrent. The highest recorded value is returned in *pHighwater. If the resetFlag is true, then the highest record value is reset after *pHighwater is written. Some parameters do not record the highest value. For those parameters nothing is written into *pHighwater and the resetFlag is ignored. Other parameters record only the highwater mark and not the current value. For these latter parameters nothing is written into *pCurrent.</source>
          <target state="translated">这些接口用于检索有关SQLite性能的运行时状态信息，并可以选择重置各种高水位线。第一个参数是要测量的特定参数的整数代码。公认的整数代码的形式为&lt;a href=&quot;#SQLITE_STATUS_MALLOC_COUNT&quot;&gt;SQLITE_STATUS _...&lt;/a&gt;。参数的当前值返回到* pCurrent。最高记录值在* pHighwater中返回。如果resetFlag为true，则在写入* pHighwater之后将重置最高记录值。某些参数未记录最高值。对于这些参数，不会将任何内容写入* pHighwater中，并且会忽略resetFlag。其他参数仅记录高水位线，而不记录当前值。对于这些后面的参数，没有任何内容写入* pCurrent。</target>
        </trans-unit>
        <trans-unit id="9a006bb7b78680fec3ca85a8c33bf946ae2c290a" translate="yes" xml:space="preserve">
          <source>These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks. The first argument is an integer code for the specific parameter to measure. Recognized integer codes are of the form &lt;a href=&quot;c_status_malloc_count&quot;&gt;SQLITE_STATUS_...&lt;/a&gt;. The current value of the parameter is returned into *pCurrent. The highest recorded value is returned in *pHighwater. If the resetFlag is true, then the highest record value is reset after *pHighwater is written. Some parameters do not record the highest value. For those parameters nothing is written into *pHighwater and the resetFlag is ignored. Other parameters record only the highwater mark and not the current value. For these latter parameters nothing is written into *pCurrent.</source>
          <target state="translated">这些接口用于检索有关SQLite性能的运行时状态信息，并可以选择重置各种高水位线。第一个参数是要测量的特定参数的整数代码。公认的整数代码的形式为&lt;a href=&quot;c_status_malloc_count&quot;&gt;SQLITE_STATUS _...&lt;/a&gt;。参数的当前值返回到* pCurrent。最高记录值在* pHighwater中返回。如果resetFlag为true，则在写入* pHighwater之后将重置最高记录值。某些参数未记录最高值。对于这些参数，不会将任何内容写入* pHighwater中，并且会忽略resetFlag。其他参数仅记录高水位线，而不记录当前值。对于这些后面的参数，没有任何内容写入* pCurrent。</target>
        </trans-unit>
        <trans-unit id="7a26bb8a6cfb99470baf86e2f9ba8d8fe1ec3d04" translate="yes" xml:space="preserve">
          <source>These interfaces can be used by an application to monitor how much memory SQLite is using. The &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; routine returns the number of bytes of memory currently in use and the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; returns the maximum instantaneous memory usage. Neither routine includes the overhead associated with the memory allocator. These routines are provided for use by the application. SQLite never invokes them itself. So if the application is providing its own memory allocation subsystem, it can omit these interfaces if desired.</source>
          <target state="translated">应用程序可以使用这些接口来监视SQLite使用的内存量。所述&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;例程返回当前正在使用的存储器的字节数和&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;返回最大瞬时内存使用情况。这两个例程都不包括与内存分配器相关的开销。提供了这些例程供应用程序使用。 SQLite永远不会调用它们本身。因此，如果应用程序提供了自己的内存分配子系统，则可以根据需要忽略这些接口。</target>
        </trans-unit>
        <trans-unit id="5e6bfb4cf13a4a1ec7a21d1345619d3a829697d4" translate="yes" xml:space="preserve">
          <source>These interfaces impose limits on the amount of heap memory that will be by all database connections within a single process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d867180f3b3d1ed5572faf6a624799c6449d787" translate="yes" xml:space="preserve">
          <source>These interfaces provide the same information as the &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;, &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;, and &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macros but are associated with the library instead of the header file. Cautious programmers might include assert() statements in their application to verify that values returned by these interfaces match the macros in the header, and thus ensure that the application is compiled with matching library and header files.</source>
          <target state="translated">这些接口提供的信息与&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;，&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;和&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C预处理器宏相同，但与库而不是头文件关联。谨慎的程序员可能在其应用程序中包含assert（）语句，以验证这些接口返回的值与标头中的宏相匹配，从而确保使用匹配的库和标头文件来编译应用程序。</target>
        </trans-unit>
        <trans-unit id="7e7f85933d01fbbc2719e5dc64309e8e175f6d5d" translate="yes" xml:space="preserve">
          <source>These interfaces provide the same information as the &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt;, &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;, and &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macros but are associated with the library instead of the header file. Cautious programmers might include assert() statements in their application to verify that values returned by these interfaces match the macros in the header, and thus ensure that the application is compiled with matching library and header files.</source>
          <target state="translated">这些接口提供的信息与&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt;，&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;和&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C预处理器宏相同，但与库而不是头文件关联。谨慎的程序员可能在其应用程序中包含assert（）语句，以验证这些接口返回的值与标头中的宏相匹配，从而确保使用匹配的库和标头文件来编译应用程序。</target>
        </trans-unit>
        <trans-unit id="8f3967be8dcb65457d2a35a639ddbcd4e8748853" translate="yes" xml:space="preserve">
          <source>These interfaces return the current status of an &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object.</source>
          <target state="translated">这些接口返回&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;对象的当前状态。</target>
        </trans-unit>
        <trans-unit id="9f4d86f27a761f3cf1b6a9d1b51464453bd7acc2" translate="yes" xml:space="preserve">
          <source>These interfaces return the current status of an &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object.</source>
          <target state="translated">这些接口返回&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;对象的当前状态。</target>
        </trans-unit>
        <trans-unit id="0bd4a9c1d8ef359db205ab90399688f58e57b40f" translate="yes" xml:space="preserve">
          <source>These interfces are provided for use by &lt;a href=&quot;../vfs#shim&quot;&gt;VFS shim&lt;/a&gt; implementations and are not useful outside of that context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edf2097b32647c30069fed117ef937baf26e2654" translate="yes" xml:space="preserve">
          <source>These interfces are provided for use by &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt; implementations and are not useful outside of that context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a8d7ae768abbd8bdb6f16b4e0e326ba78812f7" translate="yes" xml:space="preserve">
          <source>These macros are only available on Windows. They define the allowed values for the type argument to the &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface.</source>
          <target state="translated">这些宏仅在Windows上可用。它们为&lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt;接口的type参数定义了允许的值。</target>
        </trans-unit>
        <trans-unit id="a687dbdbbc158f7b1d8247c45af66df0ad45cf41" translate="yes" xml:space="preserve">
          <source>These macros are only available on Windows. They define the allowed values for the type argument to the &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface.</source>
          <target state="translated">这些宏仅在Windows上可用。它们为&lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt;接口的type参数定义了允许的值。</target>
        </trans-unit>
        <trans-unit id="a53b463320023e1da4e50fb5fb587f4bc7e0b044" translate="yes" xml:space="preserve">
          <source>These macros define the allowed values for the &lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285af12f9b73f8c383619a138a0750effc7e59e8" translate="yes" xml:space="preserve">
          <source>These macros define the allowed values for the &lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8efdced9c4da4c580aa62b3a5a3c4685a1b1ed67" translate="yes" xml:space="preserve">
          <source>These macros define the various options to the &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; interface that &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementations can use to customize and optimize their behavior.</source>
          <target state="translated">这些宏为&lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config（）&lt;/a&gt;接口定义了各种选项，&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;实现可用于自定义和优化其行为。</target>
        </trans-unit>
        <trans-unit id="648697ac8bc614b007ee6a86dba8449e42be0af2" translate="yes" xml:space="preserve">
          <source>These macros define the various options to the &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; interface that &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementations can use to customize and optimize their behavior.</source>
          <target state="translated">这些宏为&lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config（）&lt;/a&gt;接口定义了各种选项，&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;实现可用于自定义和优化其行为。</target>
        </trans-unit>
        <trans-unit id="e2c086e3788cfb99a6897d54171eed03d73b01e8" translate="yes" xml:space="preserve">
          <source>These macros defined the allowed values for the &lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">这些宏定义了&lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .aConstraint []。op字段的允许值。每个值代表一个运算符，该运算符是使用&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;的查询的wHERE子句中约束条件的一部分。</target>
        </trans-unit>
        <trans-unit id="fa39882fd7522d6ac624eca8d9d3a80dde9e04fa" translate="yes" xml:space="preserve">
          <source>These macros defined the allowed values for the &lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">这些宏定义了&lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .aConstraint []。op字段的允许值。每个值代表一个运算符，该运算符是使用&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;的查询的wHERE子句中约束条件的一部分。</target>
        </trans-unit>
        <trans-unit id="cef481ad6fa7db18e075879f04ed74ee515d6f8c" translate="yes" xml:space="preserve">
          <source>These methods do not return a result code. If an error occurs, that fact is recorded in the &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object and can be recovered by a subsequent call to &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt;.</source>
          <target state="translated">这些方法不返回结果代码。如果发生错误，则将该事实记录在&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;对象中，并且可以通过后续调用&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode（X）&lt;/a&gt;来恢复。</target>
        </trans-unit>
        <trans-unit id="cf9638bb05ccc82e92352f4c91e50e88181ed764" translate="yes" xml:space="preserve">
          <source>These methods do not return a result code. If an error occurs, that fact is recorded in the &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object and can be recovered by a subsequent call to &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt;.</source>
          <target state="translated">这些方法不返回结果代码。如果发生错误，则将该事实记录在&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;对象中，并且可以通过后续调用&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode（X）&lt;/a&gt;来恢复。</target>
        </trans-unit>
        <trans-unit id="c8abab119f90d9828a9a200b591657ce6dda56d7" translate="yes" xml:space="preserve">
          <source>These methods provide the virtual table implementation an opportunity to implement nested transactions. They are always optional and will only be called in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;version 3.7.7&lt;/a&gt; (2011-06-23) and later.</source>
          <target state="translated">这些方法为虚拟表实现提供了实现嵌套事务的机会。它们始终是可选的，并且只能在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;3.7.7&lt;/a&gt;（2011-06-23）及更高版本中调用。</target>
        </trans-unit>
        <trans-unit id="46bde550196023cbdbd528e902d936fa4e39c988" translate="yes" xml:space="preserve">
          <source>These operations are described in detail in section</source>
          <target state="translated">这些操作将在以下章节中详细介绍</target>
        </trans-unit>
        <trans-unit id="8a581a47ac4eaa711b3f420b4ba4930e1f71a44b" translate="yes" xml:space="preserve">
          <source>These options are obsolete and should not be used by new code. They are retained for backwards compatibility but are now no-ops.</source>
          <target state="translated">这些选项已经过时,不应该被新代码使用。保留这些选项是为了向后的兼容性,但现在已经没有了。</target>
        </trans-unit>
        <trans-unit id="559388a0d9af9b6cbe52d397cd3542b5b1c78fdd" translate="yes" xml:space="preserve">
          <source>These pages are intended to be precise and detailed specification. For a tutorial introduction, see instead:</source>
          <target state="translated">这些页面旨在精确和详细的规范。关于教程介绍,请参见。</target>
        </trans-unit>
        <trans-unit id="6abb0e63f8d45e8d38ed1d32dbd7bc6804598807" translate="yes" xml:space="preserve">
          <source>These parameters and their meanings are subject to change without notice. These values are for testing purposes only. Applications should not use any of these parameters or the &lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; interface.</source>
          <target state="translated">这些参数及其含义如有更改，恕不另行通知。这些值仅用于测试目的。应用程序不应使用任何这些参数或&lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="572f36fd8fcb5b2b9a0c163c10706d2d9c69fa95" translate="yes" xml:space="preserve">
          <source>These parameters and their meanings are subject to change without notice. These values are for testing purposes only. Applications should not use any of these parameters or the &lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; interface.</source>
          <target state="translated">这些参数及其含义如有更改，恕不另行通知。这些值仅用于测试目的。应用程序不应使用任何这些参数或&lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="f8a0b86303fc051c5fd0870031ccb3460d4da0f7" translate="yes" xml:space="preserve">
          <source>These pragmas are only available in builds using non-standard compile-time options.</source>
          <target state="translated">这些实用程序只在使用非标准编译时选项的构建中可用。</target>
        </trans-unit>
        <trans-unit id="7d1b3b12b0e1a81b824764e591a7c4f5ca02302c" translate="yes" xml:space="preserve">
          <source>These pragmas are used for testing SQLite and are not recommended for use in application programs.</source>
          <target state="translated">这些实用程序用于测试SQLite,不建议在应用程序中使用。</target>
        </trans-unit>
        <trans-unit id="995493d489d94b8be4b015e9bc63ccee86968693" translate="yes" xml:space="preserve">
          <source>These preprocessor macros define integer codes that name counter values associated with the &lt;a href=&quot;#sqlite3_stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; interface. The meanings of the various counters are as follows:</source>
          <target state="translated">这些预处理器宏定义整数代码，这些整数代码命名与&lt;a href=&quot;#sqlite3_stmt_status&quot;&gt;sqlite3_stmt_status（）&lt;/a&gt;接口关联的计数器值。各个计数器的含义如下：</target>
        </trans-unit>
        <trans-unit id="45f1f746bd34bc0ce563d83def09a125c5bf05c1" translate="yes" xml:space="preserve">
          <source>These preprocessor macros define integer codes that name counter values associated with the &lt;a href=&quot;stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; interface. The meanings of the various counters are as follows:</source>
          <target state="translated">这些预处理器宏定义整数代码，这些整数代码命名与&lt;a href=&quot;stmt_status&quot;&gt;sqlite3_stmt_status（）&lt;/a&gt;接口关联的计数器值。各个计数器的含义如下：</target>
        </trans-unit>
        <trans-unit id="1d52a4f9ee56f3e7a3ab55d8ba1b413dd3cccc36" translate="yes" xml:space="preserve">
          <source>These routines are available to &lt;a href=&quot;../vfs&quot;&gt;custom VFS implementations&lt;/a&gt; for translating filenames between the main database file, the journal file, and the WAL file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c705c2e0cd7b6320d8503e4412e5e99c6ba613d2" translate="yes" xml:space="preserve">
          <source>These routines are available to &lt;a href=&quot;vfs&quot;&gt;custom VFS implementations&lt;/a&gt; for translating filenames between the main database file, the journal file, and the WAL file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2638c6822db8d54f4bd5ddffbdd3a5cd063ac265" translate="yes" xml:space="preserve">
          <source>These routines are deprecated. Use the &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; interface instead of the routines described here.</source>
          <target state="translated">这些例程已弃用。使用&lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;接口代替此处描述的例程。</target>
        </trans-unit>
        <trans-unit id="79eec12a37e6ba999a536376578f3d7f9c0f472e" translate="yes" xml:space="preserve">
          <source>These routines are deprecated. Use the &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; interface instead of the routines described here.</source>
          <target state="translated">这些例程已弃用。使用&lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;接口代替此处描述的例程。</target>
        </trans-unit>
        <trans-unit id="88da5c4ccf3f13c2b355a0a8cea0eee5123dacc4" translate="yes" xml:space="preserve">
          <source>These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates. See &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; for additional information.</source>
          <target state="translated">这些例程由实现SQL函数和聚合的xFunc或xFinal回调使用。有关其他信息，请参见&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ac11b77df30733555a1b785ff3b36747aa22425" translate="yes" xml:space="preserve">
          <source>These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates. See &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; for additional information.</source>
          <target state="translated">这些例程由实现SQL函数和聚合的xFunc或xFinal回调使用。有关其他信息，请参见&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;和&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a645fc58a9b80b5d58439099cf576c18383cf676" translate="yes" xml:space="preserve">
          <source>These routines are used to register a new &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt; name. Module names must be registered before creating a new &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; using the module and before using a preexisting &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; for the module.</source>
          <target state="translated">这些例程用于注册新的&lt;a href=&quot;#sqlite3_module&quot;&gt;虚拟表模块&lt;/a&gt;名称。在使用模块创建新的&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;之前以及在使用模块的现有&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;之前，必须注册模块名称。</target>
        </trans-unit>
        <trans-unit id="947d0c2cba6cd0b29a7af62bdccba7526d0c92de" translate="yes" xml:space="preserve">
          <source>These routines are used to register a new &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt; name. Module names must be registered before creating a new &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; using the module and before using a preexisting &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; for the module.</source>
          <target state="translated">这些例程用于注册新的&lt;a href=&quot;module&quot;&gt;虚拟表模块&lt;/a&gt;名称。在使用模块创建新的&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;之前以及在使用模块的现有&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;之前，必须注册模块名称。</target>
        </trans-unit>
        <trans-unit id="52698fd9d4ddf179ee30cea3431e78d27c345761" translate="yes" xml:space="preserve">
          <source>These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing. These routines return 1 if the input string appears to be a complete SQL statement. A statement is judged to be complete if it ends with a semicolon token and is not a prefix of a well-formed CREATE TRIGGER statement. Semicolons that are embedded within string literals or quoted identifier names or comments are not independent tokens (they are part of the token in which they are embedded) and thus do not count as a statement terminator. Whitespace and comments that follow the final semicolon are ignored.</source>
          <target state="translated">这些例程在命令行输入过程中很有用,可以确定当前输入的文本是否是一条完整的SQL语句,或者在将文本发送到SQLite进行解析之前是否需要额外的输入。如果输入的字符串看起来是一条完整的SQL语句,这些例程就返回1。如果一条语句以分号结束,并且不是一个完整的CREATE TRIGGER语句的前缀,那么这条语句就被认为是完整的。嵌入在字符串字面或引号标识符名称或注释中的分号不是独立的标记(它们是嵌入其中的标记的一部分),因此不作为语句结束符。最后分号后面的空白和注释会被忽略。</target>
        </trans-unit>
        <trans-unit id="1eee207918e3686e6a6a0aff77d6f8f4cd324299" translate="yes" xml:space="preserve">
          <source>These routines are work-alikes of the &quot;printf()&quot; family of functions from the standard C library. These routines understand most of the common formatting options from the standard library printf() plus some additional non-standard formats (&lt;a href=&quot;../printf#percentq&quot;&gt;%q&lt;/a&gt;, &lt;a href=&quot;../printf#percentq&quot;&gt;%Q&lt;/a&gt;, &lt;a href=&quot;../printf#percentw&quot;&gt;%w&lt;/a&gt;, and &lt;a href=&quot;../printf#percentz&quot;&gt;%z&lt;/a&gt;). See the &lt;a href=&quot;../printf&quot;&gt;built-in printf()&lt;/a&gt; documentation for details.</source>
          <target state="translated">这些例程与标准C库中的&amp;ldquo; printf（）&amp;rdquo;函数家族相似。这些例程了解标准库printf（）的大多数常见格式设置选项以及一些其他非标准格式（&lt;a href=&quot;../printf#percentq&quot;&gt;％q&lt;/a&gt;，&lt;a href=&quot;../printf#percentq&quot;&gt;％Q&lt;/a&gt;，&lt;a href=&quot;../printf#percentw&quot;&gt;％w&lt;/a&gt;和&lt;a href=&quot;../printf#percentz&quot;&gt;％z&lt;/a&gt;）。有关详细信息，请参见&lt;a href=&quot;../printf&quot;&gt;内置的printf（）&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="5d6ce4df9ede9c6a9b8604117d8eeec42326da1e" translate="yes" xml:space="preserve">
          <source>These routines are work-alikes of the &quot;printf()&quot; family of functions from the standard C library. These routines understand most of the common formatting options from the standard library printf() plus some additional non-standard formats (&lt;a href=&quot;printf#percentq&quot;&gt;%q&lt;/a&gt;, &lt;a href=&quot;printf#percentq&quot;&gt;%Q&lt;/a&gt;, &lt;a href=&quot;printf#percentw&quot;&gt;%w&lt;/a&gt;, and &lt;a href=&quot;printf#percentz&quot;&gt;%z&lt;/a&gt;). See the &lt;a href=&quot;printf&quot;&gt;built-in printf()&lt;/a&gt; documentation for details.</source>
          <target state="translated">这些例程与标准C库中的&amp;ldquo; printf（）&amp;rdquo;函数家族相似。这些例程了解标准库printf（）的大多数常见格式设置选项以及一些其他非标准格式（&lt;a href=&quot;printf#percentq&quot;&gt;％q&lt;/a&gt;，&lt;a href=&quot;printf#percentq&quot;&gt;％Q&lt;/a&gt;，&lt;a href=&quot;printf#percentw&quot;&gt;％w&lt;/a&gt;和&lt;a href=&quot;printf#percentz&quot;&gt;％z&lt;/a&gt;）。有关详细信息，请参见&lt;a href=&quot;printf&quot;&gt;内置的printf（）&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="d695b797410a06f75931294f55b67ec9c439fcc7" translate="yes" xml:space="preserve">
          <source>These routines do not parse the SQL statements thus will not detect syntactically incorrect SQL.</source>
          <target state="translated">这些例程不会解析SQL语句,因此不会检测到语法错误的SQL。</target>
        </trans-unit>
        <trans-unit id="7531da5fcda9441742ab989cffc3d5a7ea0da49d" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into implementation of &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">这些例程从&lt;a href=&quot;#sqlite3_value&quot;&gt;受保护的sqlite3_value&lt;/a&gt;对象提取类型，大小和内容信息。受保护的sqlite3_value对象用于将参数信息传递到&lt;a href=&quot;#sqlite3_create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;和&lt;a href=&quot;vtab&quot;&gt;虚拟表的实现中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="780ed181ddbb53bd0cd75f887c1efe5a712dae77" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into the functions that implement &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c79baca34267204233cef0f72fa563f702ea3b9b" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into implementation of &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">这些例程从&lt;a href=&quot;value&quot;&gt;受保护的sqlite3_value&lt;/a&gt;对象提取类型，大小和内容信息。受保护的sqlite3_value对象用于将参数信息传递到&lt;a href=&quot;create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;和&lt;a href=&quot;../vtab&quot;&gt;虚拟表的实现中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="080e4929a8edf88eab58f3131b66975c555d313b" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into the functions that implement &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6356562f1a7ea967d47e4aa35dbd596cfeb17ce" translate="yes" xml:space="preserve">
          <source>These routines must be called from the same thread as the SQL function that supplied the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value*&lt;/a&gt; parameters.</source>
          <target state="translated">必须从与提供&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value *&lt;/a&gt;参数的SQL函数相同的线程中调用这些例程。</target>
        </trans-unit>
        <trans-unit id="ea74f3659cddc5ce0c6b4fa5c6b8b6ea6fcf9692" translate="yes" xml:space="preserve">
          <source>These routines must be called from the same thread as the SQL function that supplied the &lt;a href=&quot;value&quot;&gt;sqlite3_value*&lt;/a&gt; parameters.</source>
          <target state="translated">必须从与提供&lt;a href=&quot;value&quot;&gt;sqlite3_value *&lt;/a&gt;参数的SQL函数相同的线程中调用这些例程。</target>
        </trans-unit>
        <trans-unit id="a54537ed3c843a1d7c75c98c519dd12715dd5904" translate="yes" xml:space="preserve">
          <source>These routines must be called from the same thread in which the SQL function is running.</source>
          <target state="translated">这些例程必须从运行SQL函数的同一线程中调用。</target>
        </trans-unit>
        <trans-unit id="aea4f6b4200dc559c39531008b13c73c4dca39ea" translate="yes" xml:space="preserve">
          <source>These routines open an SQLite database file as specified by the filename argument. The filename argument is interpreted as UTF-8 for sqlite3_open() and sqlite3_open_v2() and as UTF-16 in the native byte order for sqlite3_open16(). A &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; handle is usually returned in *ppDb, even if an error occurs. The only exception is that if SQLite is unable to allocate memory to hold the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object, a NULL will be written into *ppDb instead of a pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. If the database is opened (and/or created) successfully, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; is returned. Otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned. The &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; routines can be used to obtain an English language description of the error following a failure of any of the sqlite3_open() routines.</source>
          <target state="translated">这些例程打开由filename参数指定的SQLite数据库文件。 filename参数对于sqlite3_open（）和sqlite3_open_v2（）解释为UTF-8，对于sqlite3_open16（）则以本机字节顺序解释为UTF-16。一个&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;手柄通常在* PPDB返回，即使发生错误。唯一的例外是，如果SQLite无法分配内存来容纳&lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象，则会将一个NULL写入* ppDb而不是指向&lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象的指针。如果成功打开（和/或创建）数据库，则返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;。否则，将返回&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。所述&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16（）&lt;/a&gt;在任何sqlite3_open（）例程失败之后，可以使用该例程获取错误的英语描述。</target>
        </trans-unit>
        <trans-unit id="24814302ce83d408ddc70164757005571a98a1af" translate="yes" xml:space="preserve">
          <source>These routines open an SQLite database file as specified by the filename argument. The filename argument is interpreted as UTF-8 for sqlite3_open() and sqlite3_open_v2() and as UTF-16 in the native byte order for sqlite3_open16(). A &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; handle is usually returned in *ppDb, even if an error occurs. The only exception is that if SQLite is unable to allocate memory to hold the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object, a NULL will be written into *ppDb instead of a pointer to the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. If the database is opened (and/or created) successfully, then &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; is returned. Otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned. The &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; routines can be used to obtain an English language description of the error following a failure of any of the sqlite3_open() routines.</source>
          <target state="translated">这些例程打开由filename参数指定的SQLite数据库文件。 filename参数对于sqlite3_open（）和sqlite3_open_v2（）解释为UTF-8，对于sqlite3_open16（）则以本机字节顺序解释为UTF-16。一个&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;手柄通常在* PPDB返回，即使发生错误。唯一的例外是，如果SQLite无法分配内存来容纳&lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象，则会将一个NULL写入* ppDb而不是指向&lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象的指针。如果成功打开（和/或创建）数据库，则返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。否则，将返回&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;。所述&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;或&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16（）&lt;/a&gt;在任何sqlite3_open（）例程失败之后，可以使用该例程获取错误的英语描述。</target>
        </trans-unit>
        <trans-unit id="4cb0a6ed5fd628702f759fa88fc57a08522ef219" translate="yes" xml:space="preserve">
          <source>These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The name of the database or table or column can be returned as either a UTF-8 or UTF-16 string. The _database_ routines return the database name, the _table_ routines return the table name, and the origin_ routines return the column name. The returned string is valid until the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed using &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the same information is requested again in a different encoding.</source>
          <target state="translated">这些例程提供了一种确定数据库，表和表列的方法，该数据库，表和表列是&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;语句中特定结果列的来源。数据库或表或列的名称可以作为UTF-8或UTF-16字符串返回。 _database_例程返回数据库名称，_table_例程返回表名称，origin_例程返回列名称。返回的字符串是有效的，直到使用&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;销毁&lt;a href=&quot;stmt&quot;&gt;准备好的语句，&lt;/a&gt;或者直到第一次调用&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;来为特定运行自动重新编写该语句为止，或者直到再次以不同的编码请求相同的信息为止。</target>
        </trans-unit>
        <trans-unit id="6747cec9622a96ae1091ed2adc2461d962bf2710" translate="yes" xml:space="preserve">
          <source>These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The name of the database or table or column can be returned as either a UTF-8 or UTF-16 string. The _database_ routines return the database name, the _table_ routines return the table name, and the origin_ routines return the column name. The returned string is valid until the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed using &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the same information is requested again in a different encoding.</source>
          <target state="translated">这些例程提供了一种确定数据库，表和表列的方法，该数据库，表和表列是&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句中特定结果列的来源。数据库或表或列的名称可以作为UTF-8或UTF-16字符串返回。 _database_例程返回数据库名称，_table_例程返回表名称，origin_例程返回列名称。返回的字符串是有效的，直到使用&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;销毁&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句，&lt;/a&gt;或者直到第一次调用&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;来为特定运行自动重新编写该语句为止，或者直到再次以不同的编码请求相同的信息为止。</target>
        </trans-unit>
        <trans-unit id="723ec7b5764e01bb470a171ac81db6f1bccacf01" translate="yes" xml:space="preserve">
          <source>These routines provide access to the set of SQL language keywords recognized by SQLite. Applications can uses these routines to determine whether or not a specific identifier needs to be escaped (for example, by enclosing in double-quotes) so as not to confuse the parser.</source>
          <target state="translated">这些例程提供了对SQLite识别的SQL语言关键字集的访问。应用程序可以使用这些例程来确定是否需要对特定的标识符进行转义(例如,用双引号括起来),以避免混淆解析器。</target>
        </trans-unit>
        <trans-unit id="c63151a5ae56c785b897a0325e0c6f8aa37ea7fb" translate="yes" xml:space="preserve">
          <source>These routines provide direct access to the version of the Wagner edit-distance function that allows for application-defined weights on edit operations. The first two forms of this function compare pattern P against word W and return the edit distance. In the first function, the langid is assumed to be 0 and in the second, the langid is given by the L parameter. The third form of this function reloads edit distance coefficients from the table named by T.</source>
          <target state="translated">这些例程提供了对 Wagner edit-distance 函数版本的直接访问,该函数允许应用程序定义编辑操作的权重。该函数的前两种形式是将模式 P 与单词 W 进行比较,并返回编辑距离。在第一个函数中,langid被假定为0,而在第二个函数中,langid由L参数给出。该函数的第三种形式是从T命名的表中重新加载编辑距离系数。</target>
        </trans-unit>
        <trans-unit id="6ece6463ac2989d7eff64fecae9f2305cb234cc2" translate="yes" xml:space="preserve">
          <source>These routines register callback functions that can be used for tracing and profiling the execution of SQL statements.</source>
          <target state="translated">这些例程注册了回调函数,可用于跟踪和分析SQL语句的执行情况。</target>
        </trans-unit>
        <trans-unit id="40a118423314c412a0ead5a2681ebf518ed77f67" translate="yes" xml:space="preserve">
          <source>These routines return 0 if the statement is incomplete. If a memory allocation fails, then SQLITE_NOMEM is returned.</source>
          <target state="translated">如果语句不完整,这些例程返回0。如果内存分配失败,则返回SQLITE_NOMEM。</target>
        </trans-unit>
        <trans-unit id="324c17666cfb5119bcfea9a10a94bbaee6b00643" translate="yes" xml:space="preserve">
          <source>These routines return information about a single column of the current result row of a query. In every case the first argument is a pointer to the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that is being evaluated (the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; that was returned from &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or one of its variants) and the second argument is the index of the column for which information should be returned. The leftmost column of the result set has the index 0. The number of columns in the result can be determined using &lt;a href=&quot;#sqlite3_column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt;.</source>
          <target state="translated">这些例程返回有关查询当前结果行的单个列的信息。在每种情况下，第一个参数是指向要评估的&lt;a href=&quot;#sqlite3_stmt&quot;&gt;预&lt;/a&gt;&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备语句&lt;/a&gt;的指针（从&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或其变体之一返回的sqlite3_stmt *），第二个参数是应为其返回信息的列的索引。结果集的最左列索引为0。可以使用&lt;a href=&quot;#sqlite3_column_count&quot;&gt;sqlite3_column_count（）&lt;/a&gt;确定结果中的列数。</target>
        </trans-unit>
        <trans-unit id="5435456a1f2380e65f87b371b45464ea838877ae" translate="yes" xml:space="preserve">
          <source>These routines return information about a single column of the current result row of a query. In every case the first argument is a pointer to the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that is being evaluated (the &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; that was returned from &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or one of its variants) and the second argument is the index of the column for which information should be returned. The leftmost column of the result set has the index 0. The number of columns in the result can be determined using &lt;a href=&quot;column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt;.</source>
          <target state="translated">这些例程返回有关查询当前结果行的单个列的信息。在每种情况下，第一个参数是指向要评估的&lt;a href=&quot;stmt&quot;&gt;预&lt;/a&gt;&lt;a href=&quot;stmt&quot;&gt;准备语句&lt;/a&gt;的指针（从&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或其变体之一返回的sqlite3_stmt *），第二个参数是应为其返回信息的列的索引。结果集的最左列索引为0。可以使用&lt;a href=&quot;column_count&quot;&gt;sqlite3_column_count（）&lt;/a&gt;确定结果中的列数。</target>
        </trans-unit>
        <trans-unit id="86c424b8734fe7ddecb01d35115c043c61c06f29" translate="yes" xml:space="preserve">
          <source>These routines return the name assigned to a particular column in the result set of a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The sqlite3_column_name() interface returns a pointer to a zero-terminated UTF-8 string and sqlite3_column_name16() returns a pointer to a zero-terminated UTF-16 string. The first parameter is the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that implements the &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The second parameter is the column number. The leftmost column is number 0.</source>
          <target state="translated">这些例程返回分配给&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;语句结果集中的特定列的名称。sqlite3_column_name（）接口返回一个以零结尾的UTF-8字符串的指针，而sqlite3_column_name16（）返回一个以零结尾的UTF-16字符串的指针。第一个参数是&lt;a href=&quot;stmt&quot;&gt;准备&lt;/a&gt;执行&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;语句的语句。第二个参数是列号。最左边的列是数字0。</target>
        </trans-unit>
        <trans-unit id="c92c0a5a51a4b6415e4465e481831e591f5adbb3" translate="yes" xml:space="preserve">
          <source>These routines return the name assigned to a particular column in the result set of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The sqlite3_column_name() interface returns a pointer to a zero-terminated UTF-8 string and sqlite3_column_name16() returns a pointer to a zero-terminated UTF-16 string. The first parameter is the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that implements the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The second parameter is the column number. The leftmost column is number 0.</source>
          <target state="translated">这些例程返回分配给&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句结果集中的特定列的名称。sqlite3_column_name（）接口返回一个以零结尾的UTF-8字符串的指针，而sqlite3_column_name16（）返回一个以零结尾的UTF-16字符串的指针。第一个参数是&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备&lt;/a&gt;执行&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句的语句。第二个参数是列号。最左边的列是数字0。</target>
        </trans-unit>
        <trans-unit id="5de2bfd9e6d919b373b4c3d1b80a7310909f2955" translate="yes" xml:space="preserve">
          <source>These routines should return true if the mutex in their argument is held or not held, respectively, by the calling thread.</source>
          <target state="translated">这些例程应该在其参数中的mutex分别被调用线程持有或不持有时返回true。</target>
        </trans-unit>
        <trans-unit id="afa365b8dc52497e4284392ecbb9654dff91e29b" translate="yes" xml:space="preserve">
          <source>These routines throw an error if the first JSON argument is not well-formed or if any PATH argument is not well-formed or if any argument is a BLOB.</source>
          <target state="translated">如果第一个JSON参数没有格式化,或者任何PATH参数没有格式化,或者任何参数是BLOB,这些例程会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="040db3ed336324c99d540be07030ca6b73dfe1d9" translate="yes" xml:space="preserve">
          <source>These routines work just like the corresponding &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;column access functions&lt;/a&gt; except that these routines take a single &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object pointer instead of a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; pointer and an integer column number.</source>
          <target state="translated">这些例程的工作方式与相应的&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;列访问函数&lt;/a&gt;相同，只是这些例程采用单个&lt;a href=&quot;#sqlite3_value&quot;&gt;受保护的sqlite3_value&lt;/a&gt;对象指针，而不是&lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt *&lt;/a&gt;指针和整数列号。</target>
        </trans-unit>
        <trans-unit id="8f8d6c3e862ca519958d58c8125484847b89c711" translate="yes" xml:space="preserve">
          <source>These routines work just like the corresponding &lt;a href=&quot;column_blob&quot;&gt;column access functions&lt;/a&gt; except that these routines take a single &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object pointer instead of a &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; pointer and an integer column number.</source>
          <target state="translated">这些例程的工作方式与相应的&lt;a href=&quot;column_blob&quot;&gt;列访问函数&lt;/a&gt;相同，只是这些例程采用单个&lt;a href=&quot;value&quot;&gt;受保护的sqlite3_value&lt;/a&gt;对象指针，而不是&lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt *&lt;/a&gt;指针和整数列号。</target>
        </trans-unit>
        <trans-unit id="95d389aedaf4f8ce85f9804703017919fd80feca" translate="yes" xml:space="preserve">
          <source>These routines work only with &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Any attempt to use these routines on an &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; is not threadsafe.</source>
          <target state="translated">这些例程仅适用于&lt;a href=&quot;#sqlite3_value&quot;&gt;受保护的sqlite3_value&lt;/a&gt;对象。在&lt;a href=&quot;#sqlite3_value&quot;&gt;不受保护的sqlite3_value&lt;/a&gt;上使用这些例程的任何尝试都不是线程安全的。</target>
        </trans-unit>
        <trans-unit id="7a8ed928c1fb3dc4a20d3be2fb5cfe01bd35f70b" translate="yes" xml:space="preserve">
          <source>These routines work only with &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Any attempt to use these routines on an &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; is not threadsafe.</source>
          <target state="translated">这些例程仅适用于&lt;a href=&quot;value&quot;&gt;受保护的sqlite3_value&lt;/a&gt;对象。在&lt;a href=&quot;value&quot;&gt;不受保护的sqlite3_value&lt;/a&gt;上使用这些例程的任何尝试都不是线程安全的。</target>
        </trans-unit>
        <trans-unit id="cf9c078687c96682c6a85bb7a67b91a68491a0f8" translate="yes" xml:space="preserve">
          <source>These static mutexes are reserved for use internally by SQLite and should not be used by the application. The static mutexes are all non-recursive.</source>
          <target state="translated">这些静态mutexes是保留给SQLite内部使用的,不应该被应用程序使用。这些静态mutexes都是非递归的。</target>
        </trans-unit>
        <trans-unit id="a11e17b224413c41480316935dad79b1f586c189" translate="yes" xml:space="preserve">
          <source>These techniques are designed to aid in understanding the core SQLite library itself, not applications that merely use SQLite.</source>
          <target state="translated">这些技术旨在帮助理解核心SQLite库本身,而不是仅仅使用SQLite的应用程序。</target>
        </trans-unit>
        <trans-unit id="7f9968558d6525a5e69fdd942a06f1a35ab390ef" translate="yes" xml:space="preserve">
          <source>These tests are on a relatively small (approximately 14 megabyte) database. They do not measure how well the database engines scale to larger problems.</source>
          <target state="translated">这些测试是在一个相对较小(大约14兆字节)的数据库上进行的。它们并不能衡量数据库引擎对更大问题的扩展能力。</target>
        </trans-unit>
        <trans-unit id="f97df2bc02e2ab86d912a22d332def150459caf8" translate="yes" xml:space="preserve">
          <source>These tests did not attempt to measure multi-user performance or optimization of complex queries involving multiple joins and subqueries.</source>
          <target state="translated">这些测试并没有试图测量多用户性能或涉及多个连接和子查询的复杂查询的优化。</target>
        </trans-unit>
        <trans-unit id="dd70aa0fe10c02751ca4c43bd10acab99e561495" translate="yes" xml:space="preserve">
          <source>These three ways of committing a transaction correspond to the DELETE, TRUNCATE, and PERSIST settings, respectively, of the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;.</source>
          <target state="translated">这三种提交事务的方式分别对应于journal_mode &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;pragma&lt;/a&gt;的DELETE，TRUNCATE和PERSIST设置。</target>
        </trans-unit>
        <trans-unit id="8f79d49bdd4e3aeeeb4789bde61715a9a01e430c" translate="yes" xml:space="preserve">
          <source>These two rules describe how the query planner for SQLite works as of this writing (2013-08-01). And the rules above will always be honored. However, future versions of SQLite might incorporate a better theorem prover that can find other cases where W&amp;rArr;X is true and thus may find more instances where partial indexes are useful.</source>
          <target state="translated">这两个规则描述了撰写本文时（2013-08-01）的SQLite查询计划程序的工作方式。并且上述规则将始终得到遵守。但是，未来版本的SQLite可能会包含一个更好的定理证明器，它可以找到W&amp;rArr;X为true的其他情况，从而可以找到更多使用部分索引的实例。</target>
        </trans-unit>
        <trans-unit id="c8fd956e215d583a512e53c2c78546d08e30ff46" translate="yes" xml:space="preserve">
          <source>Things That Can Go Wrong</source>
          <target state="translated">可能出错的事情</target>
        </trans-unit>
        <trans-unit id="42067c10086226bb2498180a8a023f3ac259d639" translate="yes" xml:space="preserve">
          <source>Things are more complicated if the sqlite3_changes() function is executed while a trigger program is running. This may happen if the program uses the &lt;a href=&quot;../lang_corefunc#changes&quot;&gt;changes() SQL function&lt;/a&gt;, or if some other callback function invokes sqlite3_changes() directly. Essentially:</source>
          <target state="translated">如果在运行触发器程序的同时执行sqlite3_changes（）函数，事情将变得更加复杂。如果程序使用&lt;a href=&quot;../lang_corefunc#changes&quot;&gt;changes（）SQL函数&lt;/a&gt;，或者某些其他回调函数直接调用sqlite3_changes（），则可能会发生这种情况。本质上：</target>
        </trans-unit>
        <trans-unit id="53a7af1ec1bf96fe1cf7aeeb3a8a96e5b6a416b2" translate="yes" xml:space="preserve">
          <source>Things are more complicated if the sqlite3_changes() function is executed while a trigger program is running. This may happen if the program uses the &lt;a href=&quot;lang_corefunc#changes&quot;&gt;changes() SQL function&lt;/a&gt;, or if some other callback function invokes sqlite3_changes() directly. Essentially:</source>
          <target state="translated">如果在运行触发器程序的同时执行sqlite3_changes（）函数，事情将变得更加复杂。如果程序使用&lt;a href=&quot;lang_corefunc#changes&quot;&gt;changes（）SQL函数&lt;/a&gt;，或者某些其他回调函数直接调用sqlite3_changes（），则可能会发生这种情况。本质上：</target>
        </trans-unit>
        <trans-unit id="774483139813d257b6024c3ca6cbcda75578301f" translate="yes" xml:space="preserve">
          <source>Think of each SQL statement as a separate computer program. The original SQL text is source code. A prepared statement object is the compiled object code. All SQL must be converted into a prepared statement before it can be run.</source>
          <target state="translated">把每条SQL语句看作是一个独立的计算机程序。原始的SQL文本就是源代码。准备好的语句对象就是编译后的对象代码。所有的SQL都必须在运行之前将其转换为准备好的语句。</target>
        </trans-unit>
        <trans-unit id="2f8cd345a6425d660448be637505c8f25ad1aef9" translate="yes" xml:space="preserve">
          <source>Think of each SQL statement as a small computer program. The purpose of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; is to compile that program into object code. The &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; is the object code. The &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface then runs the object code to get a result.</source>
          <target state="translated">将每个SQL语句视为一个小型计算机程序。&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;的目的是将该程序编译为目标代码。在&lt;a href=&quot;c3ref/stmt&quot;&gt;准备语句&lt;/a&gt;是目标代码。然后，&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;接口运行目标代码以获取结果。</target>
        </trans-unit>
        <trans-unit id="cfafbb2da361739c04c43a8272cc38856e9c67a7" translate="yes" xml:space="preserve">
          <source>Third Improvement: Versioning</source>
          <target state="translated">第三次改进。版本化</target>
        </trans-unit>
        <trans-unit id="865c9c12492c3442466282bf437772709b257a8a" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; option. If the FTS5 table is created with either &quot;detail=none&quot; &quot;content=&quot; option (i.e. if it is a contentless table), then this API always iterates through an empty set (all calls to xPhraseFirstColumn() set iCol to -1).</source>
          <target state="translated">如果使用以 &quot;detail=none &quot;选项创建的FTS5表,这个API可能会相当慢。如果FTS5表是以 &quot;detail=none&quot;&quot;content=&quot;选项创建的(即如果它是一个无内容的表),那么这个API总是遍历一个空集(所有对xPhraseFirstColumn()的调用都将iCol设置为-1)。</target>
        </trans-unit>
        <trans-unit id="ebf79b4cb55761477acdbbee63fd4654b2112a93" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; or &quot;detail=column&quot; option.</source>
          <target state="translated">如果使用以 &quot;detail=none &quot;或 &quot;detail=column &quot;选项创建的FTS5表,这个API可能会相当慢。</target>
        </trans-unit>
        <trans-unit id="320a596dec5edeedf6c5c2728a533311ecff7379" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; or &quot;detail=column&quot; option. If the FTS5 table is created with either &quot;detail=none&quot; or &quot;detail=column&quot; and &quot;content=&quot; option (i.e. if it is a contentless table), then this API always iterates through an empty set (all calls to xPhraseFirst() set iCol to -1).</source>
          <target state="translated">如果与以 &quot;detail=none &quot;或 &quot;detail=column &quot;选项创建的FTS5表一起使用,该API可能会相当缓慢。如果FTS5表是以 &quot;detail=none &quot;或 &quot;detail=column &quot;和 &quot;content=&quot;选项创建的(即如果它是一个无内容表),那么这个API总是在一个空集合中迭代(所有对xPhraseFirst()的调用都将iCol设置为-1)。</target>
        </trans-unit>
        <trans-unit id="f65fb946e21f0df296308a1267bfc8d75459c36f" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; or &quot;detail=column&quot; option. If the FTS5 table is created with either &quot;detail=none&quot; or &quot;detail=column&quot; and &quot;content=&quot; option (i.e. if it is a contentless table), then this API always returns 0.</source>
          <target state="translated">如果使用以 &quot;detail=none &quot;或 &quot;detail=column &quot;选项创建的FTS5表,该API可能会相当缓慢。如果FTS5表是以 &quot;detail=none &quot;或 &quot;detail=column &quot;和 &quot;content=&quot;选项创建的(即如果它是一个无内容表),那么这个API总是返回0。</target>
        </trans-unit>
        <trans-unit id="43444bfacf757a80f8f09485afde0ead5f0a776e" translate="yes" xml:space="preserve">
          <source>This API function is used to query the FTS table for phrase iPhrase of the current query. Specifically, a query equivalent to:</source>
          <target state="translated">该API函数用于查询当前查询的短语iPhrase的FTS表。具体来说,相当于以下的查询。</target>
        </trans-unit>
        <trans-unit id="d89725045237fc9113c1fa0f974917002e582aec" translate="yes" xml:space="preserve">
          <source>This API is only available if the library is built with pre-processor symbol &lt;a href=&quot;../compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt; defined.</source>
          <target state="translated">仅当库是使用定义的预处理程序符号&lt;a href=&quot;../compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt;构建的时，此API才可用。</target>
        </trans-unit>
        <trans-unit id="48dac83568aa304395644b3c39b1c1984d8ea7c3" translate="yes" xml:space="preserve">
          <source>This API is only available if the library is built with pre-processor symbol &lt;a href=&quot;compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt; defined.</source>
          <target state="translated">仅当库是使用定义的预处理程序符号&lt;a href=&quot;compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt;构建的时，此API才可用。</target>
        </trans-unit>
        <trans-unit id="f548cc5880d8bc2ce8ab0c825c0274336bee682c" translate="yes" xml:space="preserve">
          <source>This API makes sure a global version of a function with a particular name and number of parameters exists. If no such function exists before this API is called, a new function is created. The implementation of the new function always causes an exception to be thrown. So the new function is not good for anything by itself. Its only purpose is to be a placeholder function that can be overloaded by a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">此API确保存在具有特定名称和参数数量的函数的全局版本。如果在调用此API之前不存在此类函数，则会创建一个新函数。新功能的实现始终会引发异常。因此，新功能本身并不适合任何功能。它的唯一目的是成为一个可以被&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;重载的占位符函数。</target>
        </trans-unit>
        <trans-unit id="8540f6a2004da77a77789ccfaf202735cf5c6ba1" translate="yes" xml:space="preserve">
          <source>This API makes sure a global version of a function with a particular name and number of parameters exists. If no such function exists before this API is called, a new function is created. The implementation of the new function always causes an exception to be thrown. So the new function is not good for anything by itself. Its only purpose is to be a placeholder function that can be overloaded by a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">此API确保存在具有特定名称和参数数量的函数的全局版本。如果在调用此API之前不存在此类函数，则会创建一个新函数。新功能的实现始终会引发异常。因此，新功能本身并不适合任何功能。它的唯一目的是成为一个可以被&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;重载的占位符函数。</target>
        </trans-unit>
        <trans-unit id="6ab96b1e97da69a025cb8ca96b99b710398cad45" translate="yes" xml:space="preserve">
          <source>This C-preprocess macro determines the default setting of the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigcoveringindexscan&quot;&gt;SQLITE_CONFIG_COVERING_INDEX_SCAN&lt;/a&gt; configuration setting. It defaults to 1 (on) which means that covering indices are used for full table scans where possible, in order to reduce I/O and improve performance. However, the use of a covering index for a full scan will cause results to appear in a different order from legacy, which could cause some (incorrectly-coded) legacy applications to break. Hence, the covering index scan option can be disabled at compile-time on systems that what to minimize their risk of exposing errors in legacy applications.</source>
          <target state="translated">此C预处理宏确定&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigcoveringindexscan&quot;&gt;SQLITE_CONFIG_COVERING_INDEX_SCAN&lt;/a&gt;配置设置的默认设置。默认为1（开），这意味着覆盖索引将在可能的情况下用于全表扫描，以减少I / O并提高性能。但是，将覆盖索引用于完整扫描将导致结果显示的顺序与旧版的顺序不同，这可能会导致某些（错误编码）的旧版应用程序崩溃。因此，覆盖索引扫描选项可以在编译时在系统上禁用，以最大程度地降低其在遗留应用程序中暴露错误的风险。</target>
        </trans-unit>
        <trans-unit id="352e275c0ba546327eab38cacb1b8cfd047e40c3" translate="yes" xml:space="preserve">
          <source>This CVE identifies a bug in a development check-in of SQLite. The bug never appeared in any official SQLite release. &lt;a href=&quot;https://www.sqlite.org/src/info/6601da58032d18ae&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6673eaea3893e3fceb60fe446b80a1ff19d0e8" translate="yes" xml:space="preserve">
          <source>This DELETE statement will remove every record from the &quot;examp&quot; table where the &quot;two&quot; column is less than 50. The code generated to do this is as follows:</source>
          <target state="translated">这条DELETE语句将删除 &quot;examp &quot;表中 &quot;two &quot;列小于50的每一条记录。为此生成的代码如下:</target>
        </trans-unit>
        <trans-unit id="b0bfab415a485beb9edddb8d5188d00815376867" translate="yes" xml:space="preserve">
          <source>This allows optimizations: (a) when P4==0 there is no need to test the RowSet object for P3, as it is guaranteed not to contain it, (b) when P4==-1 there is no need to insert the value, as it will never be tested for, and (c) when a value that is part of set X is inserted, there is no need to search to see if the same value was previously inserted as part of set X (only if it was previously inserted as part of some other set).</source>
          <target state="translated">这样就可以进行优化。(a)当P4==0时,不需要测试P3的RowSet对象,因为它保证不包含P3;(b)当P4==1时,不需要插入该值,因为它永远不会被测试;(c)当插入一个属于集X的值时,不需要搜索该值以前是否作为集X的一部分被插入(只有当它以前作为其他集的一部分被插入)。</target>
        </trans-unit>
        <trans-unit id="e9de882f0fc5b21571717171f0fcc8e049f8f4b3" translate="yes" xml:space="preserve">
          <source>This allows separate database connections to share the same in-memory database. Of course, all database connections sharing the in-memory database need to be in the same process. The database is automatically deleted and memory is reclaimed when the last connection to the database closes.</source>
          <target state="translated">这样就可以让不同的数据库连接共享同一个内存数据库。当然,所有共享内存数据库的数据库连接都需要在同一个进程中。当最后一个数据库连接关闭时,数据库会被自动删除,内存会被回收。</target>
        </trans-unit>
        <trans-unit id="c92e98ecc01f031d3a1efe7cd735db9a008161b9" translate="yes" xml:space="preserve">
          <source>This article also uses the terms &quot;bytecode program&quot; and &quot;prepared statement&quot; interchangeably, as they are mostly the same thing.</source>
          <target state="translated">本文还交替使用 &quot;字节码程序 &quot;和 &quot;准备好的语句 &quot;这两个术语,因为它们大多是一回事。</target>
        </trans-unit>
        <trans-unit id="a9af0cbe702f19f3f49888228ef0df406a0e5175" translate="yes" xml:space="preserve">
          <source>This article defines what the limits of SQLite are and how they can be customized for specific applications. The default settings for limits are normally quite large and adequate for almost every application. Some applications may want to increase a limit here or there, but we expect such needs to be rare. More commonly, an application might want to recompile SQLite with much lower limits to avoid excess resource utilization in the event of bug in higher-level SQL statement generators or to help thwart attackers who inject malicious SQL statements.</source>
          <target state="translated">本文定义了SQLite的限制是什么,以及如何针对特定的应用进行自定义。通常情况下,限制的默认设置是相当大的,对于几乎所有的应用程序来说都足够了。有些应用程序可能想在这里或那里增加限制,但我们希望这种需求是罕见的。更常见的情况是,一个应用程序可能希望用低得多的限制来重新编译SQLite,以避免在更高级别的SQL语句生成器出现bug的情况下过度使用资源,或者帮助阻止注入恶意SQL语句的攻击者。</target>
        </trans-unit>
        <trans-unit id="316fd7167581f1bf3b1521c621172952b269d34a" translate="yes" xml:space="preserve">
          <source>This article describes how the SQLite developers measure CPU usage, what those measurements actually mean, and the techniques used by SQLite developers on their continuing quest to further reduce the CPU usage of the SQLite library.</source>
          <target state="translated">本文介绍了SQLite开发人员是如何测量CPU使用率的,这些测量结果的实际意义,以及SQLite开发人员在不断追求进一步降低SQLite库的CPU使用率的过程中所使用的技术。</target>
        </trans-unit>
        <trans-unit id="926f25884d306babc2c568ebac87d0360fd509bf" translate="yes" xml:space="preserve">
          <source>This article describes the SQLite OS portability layer or &quot;VFS&quot; - the module at the bottom of the SQLite implementation stack that provides portability across operating systems.</source>
          <target state="translated">本文介绍了SQLite操作系统可移植性层或 &quot;VFS&quot;--SQLite实现栈底部的模块,它提供了跨操作系统的可移植性。</target>
        </trans-unit>
        <trans-unit id="e9493c358448eb3b281eac84dedc92f4531c0a0b" translate="yes" xml:space="preserve">
          <source>This article describes the techniques used by SQLite to create the illusion of atomic commit.</source>
          <target state="translated">本文介绍了SQLite用来制造原子提交假象的技术。</target>
        </trans-unit>
        <trans-unit id="c7354274b5f5ad835c3ba9869336d09f507f1b91" translate="yes" xml:space="preserve">
          <source>This article describes the various temporary files that SQLite creates and uses. It describes when the files are created, when they are deleted, what they are used for, why they are important, and how to avoid them on systems where creating temporary files is expensive.</source>
          <target state="translated">本文介绍了SQLite创建和使用的各种临时文件。它描述了这些文件何时创建,何时删除,它们的用途,为什么它们很重要,以及如何在创建临时文件很昂贵的系统中避免它们。</target>
        </trans-unit>
        <trans-unit id="bf37adfcb2e68d7e2d42601f83e22affd6226d10" translate="yes" xml:space="preserve">
          <source>This article does not contain a step-by-step recipe for compiling SQLite. That would be difficult since each development situation is different. Rather, this article describes and illustrates the principals behind the compilation of SQLite. Typical compilation commands are provided as examples with the expectation that application developers can use these examples as guidance for developing their own custom compilation procedures. In other words, this article provides ideas and insights, not turnkey solutions.</source>
          <target state="translated">本文不包含编译SQLite的步骤秘诀。这将是很困难的,因为每个开发情况都是不同的。相反,本文描述和说明了编译SQLite背后的原理。典型的编译命令是作为例子提供的,希望应用程序开发人员可以使用这些例子作为指导来开发他们自己的自定义编译过程。换句话说,本文提供的是想法和见解,而不是万能的解决方案。</target>
        </trans-unit>
        <trans-unit id="945df33c68655603cf7dd0502f5d42134ad32f1a" translate="yes" xml:space="preserve">
          <source>This article has been revised multiple times in an attempt to improve clarity, address concerns and misgivings, and to fix errors identified on &lt;a href=&quot;https://news.ycombinator.com/item?id=16806114&quot;&gt;Hacker News&lt;/a&gt;, &lt;a href=&quot;https://www.reddit.com/r/programming/comments/8c2niw/why_sqlite_does_not_use_git/&quot;&gt;Reddit&lt;/a&gt; and &lt;a href=&quot;https://lobste.rs/s/slcntl/why_sqlite_does_not_use_git&quot;&gt;Lobsters&lt;/a&gt;. The complete edit history can be seen at &lt;a href=&quot;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&quot;&gt;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&lt;/a&gt;. (Usage hint: Click on any two nodes of the graph for a diff.)</source>
          <target state="translated">本文已多次修订，以提高清晰度，解决疑虑和疑虑，并修复在&lt;a href=&quot;https://news.ycombinator.com/item?id=16806114&quot;&gt;Hacker News&lt;/a&gt;，&lt;a href=&quot;https://www.reddit.com/r/programming/comments/8c2niw/why_sqlite_does_not_use_git/&quot;&gt;Reddit&lt;/a&gt;和&lt;a href=&quot;https://lobste.rs/s/slcntl/why_sqlite_does_not_use_git&quot;&gt;Lobsters&lt;/a&gt;上发现的错误。完整的编辑历史记录可以在&lt;a href=&quot;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&quot;&gt;https://sqlite.org/docsrc/finfo/pages/whynotgit.in中&lt;/a&gt;查看。（使用提示：单击图的任意两个节点进行比较。）</target>
        </trans-unit>
        <trans-unit id="62a4071d7245439102f2788bb499d61e09713933" translate="yes" xml:space="preserve">
          <source>This article has reviewed all of the major techniques used by SQLite's VDBE to implement SQL statements. What has not been shown is that most of these techniques can be used in combination to generate code for an appropriately complex query statement. For example, we have shown how sorting is accomplished on a simple query and we have shown how to implement a compound query. But we did not give an example of sorting in a compound query. This is because sorting a compound query does not introduce any new concepts: it merely combines two previous ideas (sorting and compounding) in the same VDBE program.</source>
          <target state="translated">本文已经回顾了SQLite的VDBE用来实现SQL语句的所有主要技术。但没有展示的是,这些技术中的大多数可以组合使用,以生成适当复杂的查询语句的代码。例如,我们已经展示了如何在一个简单的查询上完成排序,我们已经展示了如何实现复合查询。但是我们并没有给出复合查询中排序的例子。这是因为对复合查询进行排序并没有引入任何新的概念:它只是在同一个VDBE程序中结合了以前的两个想法(排序和复合)。</target>
        </trans-unit>
        <trans-unit id="a20be3ae1245d83ff9c73306d203b42ad8b16c54" translate="yes" xml:space="preserve">
          <source>This article is &lt;u&gt;not&lt;/u&gt; a comparison between Fossil and Git. See &lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&quot;&gt;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&lt;/a&gt; for one comparison of the two systems. There are others as well.</source>
          <target state="translated">本文&lt;u&gt;不是&lt;/u&gt; Fossil和Git之间的比较。请参阅&lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&quot;&gt;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&lt;/a&gt;了解两种系统的比较。还有其他。</target>
        </trans-unit>
        <trans-unit id="afdaa5ec4a00df9435f74fca69ef2e683fab815e" translate="yes" xml:space="preserve">
          <source>This article is &lt;u&gt;not&lt;/u&gt; advocating that you switch your projects away from Git. You can use whatever version control system you want. If you are perfectly happy with Git, then by all means keep using Git. But, if you are wondering if there isn't something better, then maybe try to understand the perspectives presented below. Use the insights thus obtained to find or write a different and better version control system, or to just make improvements to Git itself.</source>
          <target state="translated">本文&lt;u&gt;并不&lt;/u&gt;主张您将项目从Git移开。您可以使用所需的任何版本控制系统。如果您对Git感到非常满意，那么一定要继续使用Git。但是，如果您想知道是否还有更好的选择，那么也许可以尝试理解下面介绍的观点。使用由此获得的见解来查找或编写其他更好的版本控制系统，或仅对Git本身进行改进。</target>
        </trans-unit>
        <trans-unit id="7e8b2b9b07235888ae1de754eef75c5cbe3b972b" translate="yes" xml:space="preserve">
          <source>This article is a brief introduction to how the VDBE works and in particular how the various VDBE instructions (documented &lt;a href=&quot;opcode&quot;&gt;here&lt;/a&gt;) work together to do useful things with the database. The style is tutorial, beginning with simple tasks and working toward solving more complex problems. Along the way we will visit most submodules in the SQLite library. After completing this tutorial, you should have a pretty good understanding of how SQLite works and will be ready to begin studying the actual source code.</source>
          <target state="translated">本文简要介绍了VDBE的工作方式，尤其是各种VDBE指令（&lt;a href=&quot;opcode&quot;&gt;在此处记录&lt;/a&gt;）如何协同工作以对数据库进行有用的操作。样式是教程，从简单的任务开始，逐步解决更复杂的问题。在此过程中，我们将访问SQLite库中的大多数子模块。完成本教程后，您应该对SQLite的工作原理有很好的了解，并准备开始研究实际的源代码。</target>
        </trans-unit>
        <trans-unit id="2a689ac1a6bfa9fdba228a490c8ca90cb86bfd11" translate="yes" xml:space="preserve">
          <source>This article is about the bottom layer.</source>
          <target state="translated">本条是关于底层的。</target>
        </trans-unit>
        <trans-unit id="8376dd4be0a7eabaff5c0a359df7f198ffdee0ed" translate="yes" xml:space="preserve">
          <source>This article only mentions the most important and most commonly used SQLite interfaces. The SQLite library includes many other APIs implementing useful features that are not described here. A &lt;a href=&quot;c3ref/funclist&quot;&gt;complete list of functions&lt;/a&gt; that form the SQLite application programming interface is found at the &lt;a href=&quot;c3ref/intro&quot;&gt;C/C++ Interface Specification&lt;/a&gt;. Refer to that document for complete and authoritative information about all SQLite interfaces.</source>
          <target state="translated">本文仅提及最重要和最常用的SQLite接口。 SQLite库包括许多其他API，这些API实现了此处未描述的有用功能。在&lt;a href=&quot;c3ref/intro&quot;&gt;C / C ++接口规范中&lt;/a&gt;可以找到构成SQLite应用程序编程接口&lt;a href=&quot;c3ref/funclist&quot;&gt;的功能&lt;/a&gt;的完整列表。有关所有SQLite接口的完整和权威信息，请参阅该文档。</target>
        </trans-unit>
        <trans-unit id="ecb82abd11a7741bac191b285785a86679cd3dd8" translate="yes" xml:space="preserve">
          <source>This article outlines one possible method for keeping a private branch of SQLite in sync with the public SQLite source code. There are many ways of maintaining a private branch, of course. Nobody is compelled to use the method describe here. This article is not trying to impose a particular procedure on maintainers of private branches. The point of this article is to offer an example of one process for maintaining a private branch which can be used as a template for designing processes best suited for the circumstances of each individual project.</source>
          <target state="translated">本文概述了一种可能的方法,让SQLite的私有分支与公共SQLite源代码保持同步。当然,维护私有分支的方法有很多。没有人必须使用这里描述的方法。这篇文章并不是要把一个特定的程序强加给私有分支的维护者。本文的目的是提供一个维护私有分支的过程的例子,它可以作为一个模板来设计最适合每个项目情况的过程。</target>
        </trans-unit>
        <trans-unit id="6e9369c9e16c87662c003b06c9e9f9920fb45e35" translate="yes" xml:space="preserve">
          <source>This article overviews the importance of query planning, describes some of the problems inherent to query planning, and outlines how the NGQP solves those problems.</source>
          <target state="translated">本文概述了查询规划的重要性,描述了查询规划固有的一些问题,并概述了NGQP如何解决这些问题。</target>
        </trans-unit>
        <trans-unit id="edd2ab1205dd1a38d5ce29f020d2d454461aadbe" translate="yes" xml:space="preserve">
          <source>This article presents a technique using the SQLite &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface such that calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; and &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; block until the required locks are available instead of returning SQLITE_LOCKED immediately. If the sqlite3_blocking_step() or sqlite3_blocking_prepare_v2() functions presented to the left return SQLITE_LOCKED, this indicates that to block would deadlock the system.</source>
          <target state="translated">本文介绍一种使用SQLite &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;接口的技术，以便调用&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;和&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;块，直到所需的锁可用为止，而不是立即返回SQLITE_LOCKED。如果显示在左侧的sqlite3_blocking_step（）或sqlite3_blocking_prepare_v2（）函数返回SQLITE_LOCKED，则表明阻塞将使系统死锁。</target>
        </trans-unit>
        <trans-unit id="9498c6cd8712f6376d65af391550cc9e3ffdabcd" translate="yes" xml:space="preserve">
          <source>This block of instruction cleans up the VDBE program. Three of these instructions aren't really required, but are generated by the SQLite parser from its code templates, which are designed to handle more complicated cases.</source>
          <target state="translated">这条指令块清理了VDBE程序。其中有三条指令并不是真正需要的,而是由SQLite解析器从其代码模板中生成的,这些模板是为了处理更复杂的情况而设计的。</target>
        </trans-unit>
        <trans-unit id="4a01a06f54367b20ad3750e286b70148e2c847d5" translate="yes" xml:space="preserve">
          <source>This built-in window function calculates the window frame for each row in the same way as an aggregate window function. It returns the value of</source>
          <target state="translated">这个内置的窗口函数以与集合窗口函数相同的方式计算每行的窗口框架。它返回</target>
        </trans-unit>
        <trans-unit id="20ec5d83d88c2da3b16c3295bcff75c38125962e" translate="yes" xml:space="preserve">
          <source>This change is an exception to the version number rule described above in that it is neither forwards or backwards compatible. A complete reload of the database is required. This is the only exception.</source>
          <target state="translated">这一变化是上述版本号规则的一个例外,因为它既不向前也不向后兼容。需要完全重新加载数据库。这是唯一的例外。</target>
        </trans-unit>
        <trans-unit id="c6a5f96c5622bed501ea8661519073e0de4f52cd" translate="yes" xml:space="preserve">
          <source>This column also always contains an integer value greater than zero.</source>
          <target state="translated">这一列也总是包含一个大于零的整数值。</target>
        </trans-unit>
        <trans-unit id="fb0358a44a2292d9d05f4777b69d5f05939eb420" translate="yes" xml:space="preserve">
          <source>This column always contains an integer value greater than zero.</source>
          <target state="translated">此列总是包含一个大于零的整数值。</target>
        </trans-unit>
        <trans-unit id="1713bd9e06b77e4bbf5df2753a784a802e3933b6" translate="yes" xml:space="preserve">
          <source>This column determines which &lt;a href=&quot;fts3#*fts4languageid&quot; id=&quot;f4alid&quot;&gt;languageid&lt;/a&gt; is used to extract vocabulary from the FTS3/4 table.</source>
          <target state="translated">此列确定使用哪种&lt;a href=&quot;fts3#*fts4languageid&quot; id=&quot;f4alid&quot;&gt;languageid&lt;/a&gt;从FTS3 / 4表中提取词汇。</target>
        </trans-unit>
        <trans-unit id="285c275d9591ca00ecba379d1be0f439e124856e" translate="yes" xml:space="preserve">
          <source>This column may contain either the text value '*' (i.e. a single character, U+002a) or an integer between 0 and N-1, where N is again the number of user-defined columns in the corresponding FTS table.</source>
          <target state="translated">这一列可以包含文本值'*'(即一个字符,U+002a),也可以是0到N-1之间的整数,其中N又是相应FTS表中用户定义的列数。</target>
        </trans-unit>
        <trans-unit id="65f82075152c89e2aff2366597dc220e2a3e5878" translate="yes" xml:space="preserve">
          <source>This column must be set to NULL. If a non-NULL value is inserted into this column, or if a new non-NULL value is provided using an UPDATE statement, it is an error.</source>
          <target state="translated">此列必须设置为NULL。如果在此列中插入了一个非NULL值,或者使用UPDATE语句提供了一个新的非NULL值,则是一个错误。</target>
        </trans-unit>
        <trans-unit id="e9e3819e4d76ebe92176deabc7d0279eab9fbfc8" translate="yes" xml:space="preserve">
          <source>This column shows the phonetic hash prefix that was used to restrict the search. For any given query, this column should be the same for every row. This information is available for diagnostic purposes and is not normally considered useful in real applications.</source>
          <target state="translated">这一列显示了用于限制搜索的拼音哈希前缀。对于任何给定的查询,这一列对于每一行都应该是相同的。此信息可用于诊断目的,通常不认为在实际应用中有用。</target>
        </trans-unit>
        <trans-unit id="01288c4cfddc172d238625a965b9f1003be61617" translate="yes" xml:space="preserve">
          <source>This command both creates the new repository and populates it with all the latest SQLite code. You can then create a private branch as described in section 3.4.</source>
          <target state="translated">这个命令既创建了新的版本库,又将所有最新的 SQLite 代码填充到版本库中。然后你可以创建一个私有分支,如3.4节所述。</target>
        </trans-unit>
        <trans-unit id="e0ca6b6ac38f5b817649e53a976402c687ab2fa8" translate="yes" xml:space="preserve">
          <source>This command causes SQLite to disconnect from the previous database and reattach to an in-memory database with the content in</source>
          <target state="translated">这条命令会使SQLite断开与前一个数据库的连接,并重新连接到一个内存数据库,内容在</target>
        </trans-unit>
        <trans-unit id="52245829743ea4e1b3e2fa49a0972f85d14c8fbb" translate="yes" xml:space="preserve">
          <source>This command causes the &quot;callback&quot; script to be invoked whenever certain conditions occurs. The conditions are determined by the</source>
          <target state="translated">每当某些条件发生时,这个命令会使 &quot;回调 &quot;脚本被调用。这些条件是由</target>
        </trans-unit>
        <trans-unit id="13f59d1cb3e06c83ff056103acea107f7910080d" translate="yes" xml:space="preserve">
          <source>This command first deletes the entire full-text index, then rebuilds it based on the contents of the table or &lt;a href=&quot;fts5#external_content_tables&quot;&gt;content table&lt;/a&gt;. It is not available with &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless tables&lt;/a&gt;.</source>
          <target state="translated">此命令首先删除整个全文索引，然后根据表或&lt;a href=&quot;fts5#external_content_tables&quot;&gt;内容表&lt;/a&gt;的内容重建它。它对于&lt;a href=&quot;fts5#contentless_tables&quot;&gt;无内容表&lt;/a&gt;不可用。</target>
        </trans-unit>
        <trans-unit id="fe5638fc83b6cdbce8fdc02e570b8e2b10a1482f" translate="yes" xml:space="preserve">
          <source>This command is only available with &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content&lt;/a&gt; and &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless&lt;/a&gt; tables. It deletes all entries from the full-text index.</source>
          <target state="translated">该命令仅适用于&lt;a href=&quot;fts5#external_content_tables&quot;&gt;外部内容&lt;/a&gt;和&lt;a href=&quot;fts5#contentless_tables&quot;&gt;无内容&lt;/a&gt;表。它将从全文索引中删除所有条目。</target>
        </trans-unit>
        <trans-unit id="7489ecbcacef562551b65244089f9307c364a891" translate="yes" xml:space="preserve">
          <source>This command is only available with &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content&lt;/a&gt; and &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless&lt;/a&gt; tables. It is used to delete the index entries associated with a single row from the full-text index. This command and the &lt;a href=&quot;fts5#the_delete_all_command&quot;&gt;delete-all&lt;/a&gt; command are the only ways to remove entries from the full-text index of a contentless table.</source>
          <target state="translated">该命令仅适用于&lt;a href=&quot;fts5#external_content_tables&quot;&gt;外部内容&lt;/a&gt;和&lt;a href=&quot;fts5#contentless_tables&quot;&gt;无内容&lt;/a&gt;表。它用于从全文索引中删除与单行关联的索引条目。该命令和&lt;a href=&quot;fts5#the_delete_all_command&quot;&gt;delete-all&lt;/a&gt;命令是从无内容表的全文索引中删除条目的唯一方法。</target>
        </trans-unit>
        <trans-unit id="a1d13a5c03e8731ed6d7cfb96b7277fb1a9eb4b2" translate="yes" xml:space="preserve">
          <source>This command is used to set the persistent &quot;pgsz&quot; option.</source>
          <target state="translated">该命令用于设置持久化的 &quot;pgz &quot;选项。</target>
        </trans-unit>
        <trans-unit id="b39428042e588fc7d00e73c6e90326dc9e9ea85b" translate="yes" xml:space="preserve">
          <source>This command is used to set the persistent &quot;rank&quot; option.</source>
          <target state="translated">该命令用于设置持久的 &quot;等级 &quot;选项。</target>
        </trans-unit>
        <trans-unit id="85b16bab1c29894a0c668469c8830c0b869b0913" translate="yes" xml:space="preserve">
          <source>This command is used to set the persistent &quot;usermerge&quot; option.</source>
          <target state="translated">该命令用于设置持久化的 &quot;usermerge &quot;选项。</target>
        </trans-unit>
        <trans-unit id="3730a7c5668daaf6af3f627c894d5a241eb8942e" translate="yes" xml:space="preserve">
          <source>This command is used to verify that the full-text index is consistent with the contents of the FTS5 table or &lt;a href=&quot;fts5#external_content_tables&quot;&gt;content table&lt;/a&gt;. It is not available with &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless tables&lt;/a&gt;.</source>
          <target state="translated">此命令用于验证全文索引与FTS5表或&lt;a href=&quot;fts5#external_content_tables&quot;&gt;content表&lt;/a&gt;的内容一致。它对于&lt;a href=&quot;fts5#contentless_tables&quot;&gt;无内容表&lt;/a&gt;不可用。</target>
        </trans-unit>
        <trans-unit id="1a574335749833522810d0e9deb16c3b1a8c4736" translate="yes" xml:space="preserve">
          <source>This command may also be used with ordinary FTS4 tables, for example if the implementation of the tokenizer changes. It is an error to attempt to rebuild the full-text index maintained by a contentless FTS4 table, since no content will be available to do the rebuilding.</source>
          <target state="translated">该命令也可用于普通的 FTS4 表,例如,如果 tokenizer 的实现发生了变化。试图重建由无内容的 FTS4 表维护的全文索引是错误的,因为没有内容可以重建。</target>
        </trans-unit>
        <trans-unit id="61072f8fd085f0b1c6b3c6456d8203db4cf536aa" translate="yes" xml:space="preserve">
          <source>This command merges all individual b-trees that currently make up the full-text index into a single large b-tree structure. This ensures that the full-text index consumes the minimum space within the database and is in the fastest form to query.</source>
          <target state="translated">该命令将当前构成全文索引的所有单个b树合并为一个大b树结构。这样可以保证全文索引在数据库中占用的空间最小,而且是以最快的形式进行查询。</target>
        </trans-unit>
        <trans-unit id="51ac15b2185be7d66cfb5466a048917c1313d8ae" translate="yes" xml:space="preserve">
          <source>This command merges b-tree structures together until roughly N pages of merged data have been written to the database, where N is the absolute value of the parameter specified as part of the 'merge' command. The size of each page is as configured by the &lt;a href=&quot;fts5#the_pgsz_configuration_option&quot;&gt;FTS5 pgsz option&lt;/a&gt;.</source>
          <target state="translated">此命令将b树结构合并在一起，直到大约N页合并数据已写入数据库，其中N是作为&amp;ldquo;合并&amp;rdquo;命令的一部分指定的参数的绝对值。每页的大小由&lt;a href=&quot;fts5#the_pgsz_configuration_option&quot;&gt;FTS5 pgsz选项&lt;/a&gt;配置。</target>
        </trans-unit>
        <trans-unit id="f6ccb891d0018f34c8b539ed4ad53a6be49ac1c9" translate="yes" xml:space="preserve">
          <source>This command sequence is a lot to memorize and type. (One would want to create a bash alias or short shell script if it were used frequently.) Furthermore, it is not quite the same thing. The command above gives one a list of descendents without showing the branching structure, which is important for understanding what happened. In contrast, Fossil offers displays such as &lt;a href=&quot;https://sqlite.org/src/timeline?d=8a439a6dda390d74&amp;amp;n=15&quot;&gt;https://sqlite.org/src/timeline?d=8a439a6dda390d74&amp;amp;n=15&lt;/a&gt;, which is a tremendous help in analyzing the aftermath of historical changes.</source>
          <target state="translated">这个命令序列要记住和键入很多。（如果经常使用的话，可能要创建一个bash别名或简短的shell脚本。）此外，它也不是完全一样的。上面的命令给出了一个后代列表，但未显示分支结构，这对于理解发生的事情很重要。相反，Fossil提供了诸如&lt;a href=&quot;https://sqlite.org/src/timeline?d=8a439a6dda390d74&amp;amp;n=15&quot;&gt;https://sqlite.org/src/timeline?d=8a439a6dda390d74&amp;amp;n=15之类的&lt;/a&gt;显示，这在分析历史变化的后果方面提供了巨大的帮助。</target>
        </trans-unit>
        <trans-unit id="309dfaa9b377c5a8af4ac33fa681865f1bffbfb3" translate="yes" xml:space="preserve">
          <source>This command will create a new branch named &quot;private&quot; (you can use a different name if you like) and assign it a background color of light blue (&quot;#add8e8&quot;). You can omit the background color if you want, though having a distinct background does make it easier to tell the branch from the &quot;trunk&quot; (the public branch) on timeline displays. You can change the background color of the private branch or of the public branch (the &quot;trunk&quot;) using the web interface if you like.</source>
          <target state="translated">这条命令将创建一个名为 &quot;private &quot;的新分支(如果你愿意,可以使用不同的名字),并为它指定一个浅蓝色的背景色(&quot;#add8e8&quot;)。如果你想的话,你可以省略背景色,尽管有一个独特的背景的确可以让你更容易在时间轴上区分该分支和 &quot;主干&quot;(公共分支)。如果你愿意,你可以使用 Web 界面改变私有分支或公共分支(&quot;主干&quot;)的背景颜色。</target>
        </trans-unit>
        <trans-unit id="5db5e98e2fd20bba8ab658518e972deb34aab3ef" translate="yes" xml:space="preserve">
          <source>This command-line shell leaves unnamed parameters unbound, meaning that they will have a value of an SQL NULL, but named parameters might be assigned values. If there exists a TEMP table named &quot;sqlite_parameters&quot; with a schema like this:</source>
          <target state="translated">这个命令行shell没有绑定未命名的参数,这意味着它们的值是SQL NULL,但是命名的参数可能会被赋值。如果存在一个名为 &quot;sqlite_parameters &quot;的TEMP表,其模式是这样的。</target>
        </trans-unit>
        <trans-unit id="4c4b4e9517b3e559a4264bd38d883b4075b15dd6" translate="yes" xml:space="preserve">
          <source>This compile-time option affects the SQL &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator only and has no impact on the &lt;a href=&quot;c3ref/strlike&quot;&gt;sqlite3_strlike()&lt;/a&gt; C-language interface.</source>
          <target state="translated">此编译时选项仅影响SQL &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;运算符，对&lt;a href=&quot;c3ref/strlike&quot;&gt;sqlite3_strlike（）&lt;/a&gt; C语言接口没有影响。</target>
        </trans-unit>
        <trans-unit id="6c67f3211a79226589052fa652c6121f10cd5b9d" translate="yes" xml:space="preserve">
          <source>This compile-time option causes the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator to always return False if either operand is a BLOB. The default behavior of &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; is that BLOB operands are cast to TEXT before the comparison is done.</source>
          <target state="translated">如果任一操作数是BLOB，则此编译时选项会使&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;运算符始终返回False。&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;的默认行为是在完成比较之前将BLOB操作数强制转换为TEXT。</target>
        </trans-unit>
        <trans-unit id="b087b90d5f82c6cd11bb4d6150e1edc15e3c7080" translate="yes" xml:space="preserve">
          <source>This compile-time option changes the default setting of the &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete pragma&lt;/a&gt;. When this option is not used, secure_delete defaults to off. When this option is present, secure_delete defaults to on.</source>
          <target state="translated">此编译时选项更改&lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete pragma&lt;/a&gt;的默认设置。不使用此选项时，secure_delete默认为关闭。存在此选项时，secure_delete默认为打开。</target>
        </trans-unit>
        <trans-unit id="ec3013abfee74643b8705338ad5e107049f5af6c" translate="yes" xml:space="preserve">
          <source>This compile-time option disables the &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;PRAGMA case_sensitive_like&lt;/a&gt; command.</source>
          <target state="translated">此编译时选项禁用&lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;PRAGMA case_sensitive_like&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="3400d01afcac3cfb7345138b17405acb7d27f932" translate="yes" xml:space="preserve">
          <source>This compile-time option enables SQLite to take advantage batch atomic write capabilities in the underlying filesystem. As of SQLite version 3.21.0 (2017-10-24) this is only supported on &lt;a href=&quot;https://en.wikipedia.org/wiki/F2FS&quot;&gt;F2FS&lt;/a&gt;. However, the interface is implemented generically, using &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; so the capability can be added to other filesystem times in the future. When this option is enabled, SQLite automatically detects that the underlying filesystem supports batch atomic writes, and when it does so it avoids writing the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; for transaction control. This can make transactions over twice as fast, while simultaneously reducing wear on SSD storage devices.</source>
          <target state="translated">该编译时选项使SQLite可以利用基础文件系统中的批处理原子写功能。从SQLite版本3.21.0（2017-10-24）开始，仅在&lt;a href=&quot;https://en.wikipedia.org/wiki/F2FS&quot;&gt;F2FS上&lt;/a&gt;支持此功能。但是，该接口是通过使用带&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;和&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE的&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;来通用实现的，因此将来可以将该功能添加到其他文件系统中。启用此选项后，SQLite会自动检测到基础文件系统支持批处理原子写，并且这样做时，它避免编写&lt;a href=&quot;lockingv3#rollback&quot;&gt;回滚日志&lt;/a&gt;用于交易控制。这可以使事务处理速度提高两倍，同时减少SSD存储设备的磨损。</target>
        </trans-unit>
        <trans-unit id="2a47cb88e70b43c326cbb7cc659779aee23f98fe" translate="yes" xml:space="preserve">
          <source>This compile-time option enables the &lt;a href=&quot;stmt&quot;&gt;SQLITE_STMT virtual table&lt;/a&gt; logic.</source>
          <target state="translated">此编译时选项启用&lt;a href=&quot;stmt&quot;&gt;SQLITE_STMT虚拟表&lt;/a&gt;逻辑。</target>
        </trans-unit>
        <trans-unit id="ff47a638485535b8abdf68c6579ec40497b2ae91" translate="yes" xml:space="preserve">
          <source>This compile-time option has been renamed to &lt;a href=&quot;compile#untestable&quot;&gt;SQLITE_UNTESTABLE&lt;/a&gt;.</source>
          <target state="translated">此编译时选项已重命名为&lt;a href=&quot;compile#untestable&quot;&gt;SQLITE_UNTESTABLE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e0b75f253921594adb213c37bae38c55286027e5" translate="yes" xml:space="preserve">
          <source>This compile-time option is deprecated and untested.</source>
          <target state="translated">这个编译时的选项已经废弃,并且未经测试。</target>
        </trans-unit>
        <trans-unit id="3be0a309752742e7707ae2403c4dadee6c132ddc" translate="yes" xml:space="preserve">
          <source>This compile-time option is no longer used.</source>
          <target state="translated">这个编译时的选项已不再使用。</target>
        </trans-unit>
        <trans-unit id="4333e0a432302d984fdf33eabb1d1ed8fc11d61a" translate="yes" xml:space="preserve">
          <source>This compile-time option makes SQLite run more efficiently when processing queries that use the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator, at the expense of breaking backwards compatibility. However, the backwards compatibility break may be only a technicality. There was a long-standing bug in the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; processing logic (see &lt;a href=&quot;https://www.sqlite.org/src/info/05f43be8fdda9f&quot;&gt;https://www.sqlite.org/src/info/05f43be8fdda9f&lt;/a&gt;) that caused it to misbehavior for BLOB operands and nobody observed that bug in nearly 10 years of active use. So for more users, it is probably safe to enable this compile-time option and thereby save a little CPU time on LIKE queries.</source>
          <target state="translated">当处理使用&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;运算符的查询时，此编译时选项使SQLite的运行效率更高，但代价是破坏了向后兼容性。但是，向后兼容性中断可能只是技术问题。&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;处理逻辑中存在一个长期存在的错误（请参阅&lt;a href=&quot;https://www.sqlite.org/src/info/05f43be8fdda9f&quot;&gt;https://www.sqlite.org/src/info/05f43be8fdda9f&lt;/a&gt;），导致它对BLOB操作数的行为不佳，并且在将近10年的活跃使用中没有人发现该错误。 。因此，对于更多用户而言，启用此编译时选项可能很安全，从而可以在LIKE查询上节省一点CPU时间。</target>
        </trans-unit>
        <trans-unit id="65b9357f2e420dd3508c81b4ae3257d2786b19ca" translate="yes" xml:space="preserve">
          <source>This constraint arises from the fact that numbers do not sort in lexicographical order. For example: 9&amp;lt;10 but '9'&amp;gt;'10'.</source>
          <target state="translated">这种限制是由于数字没有按字典顺序排序而产生的。例如：9 &amp;lt;10但'9'&amp;gt;'10'。</target>
        </trans-unit>
        <trans-unit id="187432feb7a09e6addc8b4c1a243d9ef78920104" translate="yes" xml:space="preserve">
          <source>This design note considers the database to be a collection of objects. Each SQL table is a class. Each row is an instance of that class. There are, of course, other ways to interpret an SQL database schema, and the techniques described here work equally well under alternative interpretations, but an object-oriented view seems be more natural to most contemporary programmers.</source>
          <target state="translated">本设计说明认为数据库是一个对象的集合。每个SQL表是一个类。每一行都是该类的一个实例。当然,还有其他的方法来解释SQL数据库模式,这里描述的技术在其他解释下也同样有效,但对于大多数当代程序员来说,面向对象的观点似乎更自然。</target>
        </trans-unit>
        <trans-unit id="7f5cd63f8a1306fc33b54e6f33d75fb0c8f5824b" translate="yes" xml:space="preserve">
          <source>This document describes SQLite internals. The information provided here is not needed for routine application development using SQLite. This document is intended for people who want to delve more deeply into the internal operation of SQLite.</source>
          <target state="translated">本文档描述了SQLite的内部结构。这里提供的信息对于使用SQLite进行常规的应用开发是不需要的。本文档是为那些想更深入地了解SQLite内部操作的人准备的。</target>
        </trans-unit>
        <trans-unit id="29000c12ac32a9037c669c50606cdb73ab6f60c1" translate="yes" xml:space="preserve">
          <source>This document describes and defines the on-disk database file format used by all releases of SQLite since version 3.0.0 (2004-06-18).</source>
          <target state="translated">本文档描述并定义了自3.0.0版本(2004-06-18)以来所有版本的SQLite所使用的磁盘数据库文件格式。</target>
        </trans-unit>
        <trans-unit id="dc53982e7fc871bc167dd841afd5d1fa7b1536a4" translate="yes" xml:space="preserve">
          <source>This document describes how to obtain the canonical source code for SQLite - the raw source files from which the amalgamation is built. See the &lt;a href=&quot;howtocompile&quot;&gt;How To Compile SQLite&lt;/a&gt; page for additional information on what to do with the canonical source code once it is obtained.</source>
          <target state="translated">本文档介绍了如何获取SQLite的规范源代码-构建合并的原始源文件。有关&lt;a href=&quot;howtocompile&quot;&gt;如何&lt;/a&gt;获取规范源代码的更多信息，请参见&amp;ldquo; 如何编译SQLite&amp;rdquo;页面。</target>
        </trans-unit>
        <trans-unit id="8cb17c7b427d4b622c77f47d250d842b7e4339f9" translate="yes" xml:space="preserve">
          <source>This document describes in detail the way that SQLite uses the API provided by the VFS adaptor component to solve the problems and implement the strategies enumerated above. It also specifies the assumptions made about the properties of the system that the VFS adaptor provides access to. For example, specific assumptions about the extent of data corruption that may occur if a power failure occurs while a database file is being updated are presented in section</source>
          <target state="translated">本文档详细描述了SQLite使用VFS适配器组件提供的API来解决问题和实现上面列举的策略的方式。它还指定了对VFS适配器提供访问的系统属性所做的假设。例如,关于在更新数据库文件时发生断电时可能发生的数据损坏程度的具体假设,在第</target>
        </trans-unit>
        <trans-unit id="7da4581d4d5128e1ce5220b57b58fd4271a11dba" translate="yes" xml:space="preserve">
          <source>This document describes incompatibilities that have occurred in SQLite prior to 2004. Since 2004, there have been enhancements to SQLite such that newer database files are unreadable by older versions of the SQLite library. But the most recent versions of the SQLite library should be able to read and write any older SQLite database file without any problems.</source>
          <target state="translated">本文档描述了2004年以前SQLite中发生的不兼容问题。自2004年以来,SQLite的功能得到了增强,旧版本的SQLite库无法读取较新的数据库文件,但最新版本的SQLite库应该可以毫无问题地读取和写入任何旧的SQLite数据库文件。但是,最新版本的SQLite库应该能够毫无问题地读写任何旧版SQLite数据库文件。</target>
        </trans-unit>
        <trans-unit id="522199e4ebe6e710a972b890a7a5a64190cc5d3b" translate="yes" xml:space="preserve">
          <source>This document describes low-level details on how &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is implemented on unix and windows.</source>
          <target state="translated">本文档介绍了有关如何在UNIX和Windows上实现&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;的底层细节。</target>
        </trans-unit>
        <trans-unit id="86876920b62069808dcd8a4f6cfa725666d13fe3" translate="yes" xml:space="preserve">
          <source>This document describes the architecture of the SQLite library. The information here is useful to those who want to understand or modify the inner workings of SQLite.</source>
          <target state="translated">本文档描述了SQLite库的架构。这里的信息对那些想了解或修改SQLite内部工作原理的人很有用。</target>
        </trans-unit>
        <trans-unit id="4d320774e9898d3525e4d8d7e2967bd5937be4b0" translate="yes" xml:space="preserve">
          <source>This document describes the support for SQL foreign key constraints introduced in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt; (2009-10-14).</source>
          <target state="translated">本文档介绍了SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;3.6.19&lt;/a&gt;（2009-10-14）版本中引入的对SQL外键约束的支持。</target>
        </trans-unit>
        <trans-unit id="2bc5a2a4190725779b47fa8957802675b43bcdcd" translate="yes" xml:space="preserve">
          <source>This document does not contain a full description of the syntax used to create foreign key constraints in SQLite. This may be found as part of the documentation for the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement.</source>
          <target state="translated">本文档未完整介绍用于在SQLite中创建外键约束的语法。这可以在&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句的文档中找到。</target>
        </trans-unit>
        <trans-unit id="1a95f5bdc9ff03cc2aba9a9f1c4e965180076c32" translate="yes" xml:space="preserve">
          <source>This document does not specify the details of the interface that must be implemented by the VFS adaptor component, that is left to</source>
          <target state="translated">本文档没有指定VFS适配器组件必须实现的接口的细节,那是留给VFS适配器组件的。</target>
        </trans-unit>
        <trans-unit id="4458da44ee2dc70541cbb9f7f722e55f2e9b165b" translate="yes" xml:space="preserve">
          <source>This document focuses on the NGQP. For a more general overview of the SQLite query planner that encompasses the entire history of SQLite, see the &quot;&lt;a href=&quot;optoverview&quot;&gt;The SQLite Query Optimizer Overview&lt;/a&gt;&quot; and &quot;&lt;a href=&quot;queryplanner&quot;&gt;How Indexes Work&lt;/a&gt;&quot; documents.</source>
          <target state="translated">本文档重点介绍NGQP。有关包含SQLite整个历史记录的SQLite查询计划程序的更一般的概述，请参见&amp;ldquo; &lt;a href=&quot;optoverview&quot;&gt;SQLite查询优化器概述&lt;/a&gt; &amp;rdquo;和&amp;ldquo; &lt;a href=&quot;queryplanner&quot;&gt;索引的工作方式&lt;/a&gt; &amp;rdquo;文档。</target>
        </trans-unit>
        <trans-unit id="da2a96113e96df4cba87ef0ebb6ecd70e207ec5c" translate="yes" xml:space="preserve">
          <source>This document gives an overview of the Tcl programming interface for SQLite.</source>
          <target state="translated">本文档概述了SQLite的Tcl编程接口。</target>
        </trans-unit>
        <trans-unit id="a5a4e1d46e6e2a3f39086d506303b41bc25dcc9a" translate="yes" xml:space="preserve">
          <source>This document is a quick introduction to the changes for SQLite 3.0 for users who are already familiar with SQLite version 2.8.</source>
          <target state="translated">本文档是为已经熟悉SQLite 2.8版本的用户快速介绍SQLite 3.0的变化。</target>
        </trans-unit>
        <trans-unit id="c1c02e760418d224f0c07cba5a70ec82e928ba41" translate="yes" xml:space="preserve">
          <source>This document is an introduction to the session extension. The details of the interface are in the separate &lt;a href=&quot;https://sqlite.org/session/intro.html&quot;&gt;Session Extension C-language Interface&lt;/a&gt; document.</source>
          <target state="translated">本文档是会话扩展的简介。接口的详细信息在单独的&lt;a href=&quot;https://sqlite.org/session/intro.html&quot;&gt;会话扩展C语言接口&lt;/a&gt;文档中。</target>
        </trans-unit>
        <trans-unit id="3ff7ff01849be2d401b1d6230764460ab55eb57e" translate="yes" xml:space="preserve">
          <source>This document is concerned with the persistent state of the database file, and since the wal-index is a transient structure, no further information about the format of the wal-index will be provided here. Additional details on the format of the wal-index are contained in the separate &lt;a href=&quot;walformat#walidxfmt&quot;&gt;WAL-index File Format&lt;/a&gt; document.</source>
          <target state="translated">该文档与数据库文件的持久状态有关，并且由于wal-index是一个临时结构，因此此处将不提供有关wal-index格式的更多信息。关于wal-index格式的其他详细信息包含在单独的&lt;a href=&quot;walformat#walidxfmt&quot;&gt;WAL-index文件格式&lt;/a&gt;文档中。</target>
        </trans-unit>
        <trans-unit id="ce4f9d4c36f7d70e8b9276d0825d097968bc414d" translate="yes" xml:space="preserve">
          <source>This document is created by a script which scans comments in the source code file sqlite3session.h.</source>
          <target state="translated">这个文档是由一个脚本创建的,它可以扫描源代码文件sqlite3session.h中的注释。</target>
        </trans-unit>
        <trans-unit id="d12748856fa96aaf8fec02bb978ea061f37e25d7" translate="yes" xml:space="preserve">
          <source>This document is still sometimes used as a &quot;Code of Conduct&quot; on supplier registration forms. But it is not a Code of Conduct in the same sense that many communities mean a Code of Conduct. Rather, this document describes the ethical principles upon which SQLite is based. Another way to look at this document is as a succinct description of the SQLite Founder's idea of what it means to be &quot;virtuous&quot;.</source>
          <target state="translated">本文件有时仍被用作供应商登记表上的 &quot;行为守则&quot;。但它并不是像许多社区所说的行为准则那样的行为准则。相反,这份文档描述了SQLite所基于的道德原则。另一种看法是,这份文件是对SQLite创始人关于 &quot;美德 &quot;含义的简明描述。</target>
        </trans-unit>
        <trans-unit id="6ead8dcfb3bc7787acee358a9c3c6b55198ad643" translate="yes" xml:space="preserve">
          <source>This document proposes to use &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;fossil&lt;/a&gt;, but any other distributed software configuration management system such as &lt;a href=&quot;http://www.monotone.ca/&quot;&gt;monotone&lt;/a&gt; or &lt;a href=&quot;http://www.selenic.com/mercurial/wiki/&quot;&gt;mercurial&lt;/a&gt; (a.k.a. &quot;hg&quot;), or &lt;a href=&quot;http://www.git-scm.org/&quot;&gt;git&lt;/a&gt; could serve just as well. The concept will be the same, though the specifics of the procedure will vary.</source>
          <target state="translated">该文档建议使用&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;化石&lt;/a&gt;，但是其他任何分布式软件配置管理系统（例如&lt;a href=&quot;http://www.monotone.ca/&quot;&gt;单调&lt;/a&gt;或&lt;a href=&quot;http://www.selenic.com/mercurial/wiki/&quot;&gt;Mercurial&lt;/a&gt;（aka&amp;ldquo; hg&amp;rdquo;）或&lt;a href=&quot;http://www.git-scm.org/&quot;&gt;git）&lt;/a&gt;也可以使用。尽管该过程的细节会有所不同，但概念是相同的。</target>
        </trans-unit>
        <trans-unit id="98d1415d454d0b20f9e20df74b68698917685b9f" translate="yes" xml:space="preserve">
          <source>This document provides an overview of dynamic memory allocation within SQLite. The target audience is software engineers who are tuning their use of SQLite for peak performance in demanding environments. Nothing in this document is required knowledge for using SQLite. The default settings and configuration for SQLite will work well in most applications. However, the information contained in this document may be useful to engineers who are tuning SQLite to comply with special requirements or to run under unusual circumstances.</source>
          <target state="translated">本文档概述了SQLite中的动态内存分配。目标读者是那些正在调整他们对SQLite的使用以在苛刻的环境中获得最佳性能的软件工程师。本文档中的任何内容都不是使用SQLite的必备知识。SQLite的默认设置和配置在大多数应用程序中都能很好地工作。然而,本文档中包含的信息可能对那些正在调整SQLite以符合特殊要求或在不寻常的环境下运行的工程师有用。</target>
        </trans-unit>
        <trans-unit id="c06afae30b0b7293df04fe27c7c538132693e4c6" translate="yes" xml:space="preserve">
          <source>This document provides an overview of how the query planner and optimizer for SQLite works.</source>
          <target state="translated">本文档概述了SQLite的查询规划器和优化器的工作原理。</target>
        </trans-unit>
        <trans-unit id="54a3569b4cf066b2b50e3e942ef2c48ddc1b1732" translate="yes" xml:space="preserve">
          <source>This document provides background information about how the SQLite query planner and query engine work. Programmers can use this information to help create better indexes, and provide hints to help the query planner when needed.</source>
          <target state="translated">本文档提供了关于SQLite查询规划器和查询引擎如何工作的背景信息。程序员可以使用这些信息来帮助创建更好的索引,并在需要时提供提示来帮助查询规划器。</target>
        </trans-unit>
        <trans-unit id="db48c0715525eb5ade6fdd8bc0b1d41936f8012f" translate="yes" xml:space="preserve">
          <source>This document strives to highlight the principal differences between SQLite and other SQL implementations, as an aid to developers that are porting to or from SQLite or who are trying to build a system that works across multiple database engines.</source>
          <target state="translated">本文档力图强调SQLite和其他SQL实现之间的主要区别,以帮助那些正在向SQLite移植或从SQLite移植的开发人员,或者那些试图构建一个能够跨多个数据库引擎工作的系统的开发人员。</target>
        </trans-unit>
        <trans-unit id="499e5ba33e0583ef7d40d010da72b3c26c5f57b3" translate="yes" xml:space="preserve">
          <source>This document was originally called a &quot;Code of Conduct&quot; and was created (in a slightly different format) for the purpose of filling in a box on &quot;supplier registration&quot; forms submitted to the SQLite developers by various minor clients. However, we subsequently learned that &quot;Code of Conduct&quot; has a specific technical meaning within many software development communities, a meaning which was at odds with the intent of this document. Hence, this document is now renamed and replaced by a &lt;a href=&quot;codeofconduct&quot;&gt;Code of Conduct&lt;/a&gt; that does comply with the specific technical requirements was inserted in the place of the old name.</source>
          <target state="translated">该文档最初被称为&amp;ldquo;行为准则&amp;rdquo;，其创建方式（格式略有不同）是为了填写由各个未成年人提交给SQLite开发人员的&amp;ldquo;供应商注册&amp;rdquo;表格上的方框。但是，我们随后了解到，&amp;ldquo;行为准则&amp;rdquo;在许多软件开发社区中具有特定的技术含义，该含义与本文档的意图背道而驰。因此，该文件现在已被重命名并由符合特定技术要求&lt;a href=&quot;codeofconduct&quot;&gt;的行为准则&lt;/a&gt;代替，并以旧名称代替。</target>
        </trans-unit>
        <trans-unit id="9f4b3397370025bf1fdba593094ae6486be0fecb" translate="yes" xml:space="preserve">
          <source>This document was originally created in early 2004 when SQLite version 2 was still in widespread use and was written to introduce the new concepts of SQLite version 3 to readers who were already familiar with SQLite version 2. But these days, most readers of this document have probably never seen SQLite version 2 and are only familiar with SQLite version 3. Nevertheless, this document continues to serve as an authoritative reference to how database file locking works in SQLite version 3.</source>
          <target state="translated">本文档最初创建于2004年初,当时SQLite版本2还在广泛使用,编写本文档的目的是向已经熟悉SQLite版本2的读者介绍SQLite版本3的新概念。但如今,本文档的大多数读者可能从未见过SQLite版本2,只熟悉SQLite版本3。尽管如此,本文档仍然是SQLite版本3中数据库文件锁定工作原理的权威参考。</target>
        </trans-unit>
        <trans-unit id="efa34a5056d6c01d0548b0f2be11ce7b6109059b" translate="yes" xml:space="preserve">
          <source>This experimental &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; provides information about a single &lt;a href=&quot;fileformat2#btree&quot;&gt;B-tree&lt;/a&gt; in a database file, such as the depth, and estimated number of pages and number of entries, and so forth.</source>
          <target state="translated">这个实验性的&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;提供有关数据库文件中单个&lt;a href=&quot;fileformat2#btree&quot;&gt;B树&lt;/a&gt;的信息，例如深度，估计的页面数和条目数，等等。</target>
        </trans-unit>
        <trans-unit id="0902999854d1422342b1343c7db1457520c25f82" translate="yes" xml:space="preserve">
          <source>This facility is provided for WinRT which does not have an OS mechanism for reading or changing the current working directory. The use of this pragma in any other context is discouraged and may be disallowed in future releases.</source>
          <target state="translated">这个功能是为WinRT提供的,因为WinRT没有一个操作系统机制来读取或改变当前的工作目录。不鼓励在任何其他情况下使用这个pragma,在未来的版本中可能会被禁止。</target>
        </trans-unit>
        <trans-unit id="a16ab751fe0e625eef00360bec04f5c6e2724bea" translate="yes" xml:space="preserve">
          <source>This feature could be used to implement &lt;a href=&quot;https://en.wikipedia.org/wiki/Information_schema&quot;&gt;information schema&lt;/a&gt; by first creating a separate schema using</source>
          <target state="translated">通过首先使用以下方法创建单独的架构，可以使用此功能来实现&lt;a href=&quot;https://en.wikipedia.org/wiki/Information_schema&quot;&gt;信息架构&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="bbc13030cdb5706fbe971e91e53cd50c5af469f0" translate="yes" xml:space="preserve">
          <source>This feature is experimental and is subject to change. Further documentation will become available if and when the table-valued functions for PRAGMAs feature becomes officially supported.</source>
          <target state="translated">这个功能是试验性的,可能会有变化。如果PRAGMAs的表值函数得到正式支持,将有进一步的文档。</target>
        </trans-unit>
        <trans-unit id="18abc550835bcdb0029b1a86390eaca991d2351b" translate="yes" xml:space="preserve">
          <source>This field contains a checksum value, calculated based on the contents of the journaled database page data (the previous field) and the values stored in the</source>
          <target state="translated">这个字段包含了一个校验值,它是根据日志数据库页面数据的内容(前一个字段)和存储在数据库中的值计算出来的。</target>
        </trans-unit>
        <trans-unit id="e3760b531cd8fa332f7ee70ed518883a43ad81f8" translate="yes" xml:space="preserve">
          <source>This field contains the original data for the page, exactly as it appeared in the database file before the</source>
          <target state="translated">这个字段包含了页面的原始数据,与数据库文件中出现的数据一模一样。</target>
        </trans-unit>
        <trans-unit id="3ae121150e2dd424e68324ff08f7e0c6c1d0a2a0" translate="yes" xml:space="preserve">
          <source>This field holds a phonetic code derived from coalesce(k1,word). Letters that have similar sounds are mapped into the same symbol. For example, all vowels and vowel clusters become the single symbol &quot;A&quot;. And the letters &quot;p&quot;, &quot;b&quot;, &quot;f&quot;, and &quot;v&quot; all become &quot;B&quot;. All nasal sounds are represented as &quot;N&quot;. And so forth. The mapping is based on ideas found in Soundex, Metaphone, and other long-standing phonetic matching systems. This key can be generated by the function spellfix1_phonehash(X). Hence: k2 = spellfix1_phonehash(coalesce(k1,word))</source>
          <target state="translated">这个字段保存着从coalesce(k1,word)导出的音码。具有相似音的字母被映射到同一个符号中。例如,所有元音和元音群都会变成单一的符号 &quot;A&quot;。而字母 &quot;p&quot;、&quot;b&quot;、&quot;f&quot;、&quot;v &quot;都成为 &quot;B&quot;。所有的鼻音都表示为 &quot;N&quot;。以此类推。这个映射是基于Soundex、Metaphone和其他长期存在的语音匹配系统中的想法。这个键可以通过函数spellfix1_phonehash(X)生成。因此:k2=spellfix1_phonehash(coalesce(k1,word))</target>
        </trans-unit>
        <trans-unit id="7981d385aa4b9ca4b4f9844539885d4afde0da8a" translate="yes" xml:space="preserve">
          <source>This field may contain either an integer or a text field consisting of two integers separated by a space character (unicode codepoint 0x20).</source>
          <target state="translated">该字段可以包含一个整数,也可以包含一个由两个整数组成的文本字段,由一个空格字符隔开(unicode cepepoint 0x20)。</target>
        </trans-unit>
        <trans-unit id="de591efb54fdb80ffddf1b7c9525e6ab9978c95c" translate="yes" xml:space="preserve">
          <source>This field must be set one of integer values 0 and 8, or else to NULL.</source>
          <target state="translated">该字段必须设置为整数值0和8之一,否则为NULL。</target>
        </trans-unit>
        <trans-unit id="7e75b74f43def5b21dd19f54d176219e2332fba0" translate="yes" xml:space="preserve">
          <source>This field, the &lt;b&gt;database page count&lt;/b&gt;, is set to the number of pages that the</source>
          <target state="translated">此字段（&lt;b&gt;数据库页数&lt;/b&gt;）设置为</target>
        </trans-unit>
        <trans-unit id="4ce138fa916045f081e00c343e7762b51298df38" translate="yes" xml:space="preserve">
          <source>This field, the &lt;b&gt;locking page number&lt;/b&gt;, is always set to the page number of the database</source>
          <target state="translated">此字段（&lt;b&gt;锁定页号&lt;/b&gt;）始终设置为数据库的页号</target>
        </trans-unit>
        <trans-unit id="825eef8a444b33cb8e93566d91167c3eabd02df8" translate="yes" xml:space="preserve">
          <source>This field, the &lt;b&gt;record count&lt;/b&gt;, is set to the number of</source>
          <target state="translated">该字段（&lt;b&gt;记录计数&lt;/b&gt;）设置为</target>
        </trans-unit>
        <trans-unit id="f631e740c08280177f2a7f6f8390e6ab3758fda5" translate="yes" xml:space="preserve">
          <source>This field, the &lt;b&gt;sector size&lt;/b&gt;, is set to the</source>
          <target state="translated">此字段（&lt;b&gt;扇区大小&lt;/b&gt;）设置为</target>
        </trans-unit>
        <trans-unit id="caf63c1c58b9f87489297844a819efb8d6633a40" translate="yes" xml:space="preserve">
          <source>This flag causes comma-separators to be added to the output of %d and %i substitutions, between every 3 digits from the left. This can help humans to more easily discern the magnitude of large integer values. For example, the value 2147483647 would be rendered as &quot;2147483647&quot; using &quot;%d&quot; but would appear as &quot;2,147,483,647&quot; with &quot;%,d&quot;. This flag is a non-standard extension.</source>
          <target state="translated">这个标志会使%d和%i替换的输出结果中加入逗号分隔符,从左边开始每3个数字之间。这可以帮助人类更容易辨别大的整数值的大小。例如,值2147483647使用&quot;%d &quot;会被渲染为 &quot;2147483647&quot;,但使用&quot;%,d &quot;会显示为 &quot;2,147,483,647&quot;。这个标志是一个非标准的扩展。</target>
        </trans-unit>
        <trans-unit id="a5b80382a268dfe85ecc58efaaccd407cc41e4b2" translate="yes" xml:space="preserve">
          <source>This function adds a set of changes to the session object that could be used to update the table in database zFrom (call this the &quot;from-table&quot;) so that its content is the same as the table attached to the session object (call this the &quot;to-table&quot;). Specifically:</source>
          <target state="translated">该函数向会话对象添加一组变化,可以用来更新数据库zFrom中的表(称之为 &quot;from-table&quot;),使其内容与附加在会话对象上的表(称之为 &quot;to-table&quot;)相同。具体来说,就是</target>
        </trans-unit>
        <trans-unit id="3b5d7e99038e4d5b072061176057f97dc299323e" translate="yes" xml:space="preserve">
          <source>This function and xPhraseNextColumn() are similar to the xPhraseFirst() and xPhraseNext() APIs described above. The difference is that instead of iterating through all instances of a phrase in the current row, these APIs are used to iterate through the set of columns in the current row that contain one or more instances of a specified phrase. For example:</source>
          <target state="translated">这个函数和xPhraseNextColumn()类似于上面描述的xPhraseFirst()和xPhraseNext()API。不同的是,这些API不是遍历当前行中短语的所有实例,而是遍历当前行中包含一个或多个指定短语实例的列的集合。比如说,在当前行中包含一个或多个指定短语实例的列中,这些API用来迭代。</target>
        </trans-unit>
        <trans-unit id="80988b461d2df6302b49f4dceec8b27b005d6908" translate="yes" xml:space="preserve">
          <source>This function attempts to retrieve the text of column iCol of the current document. If successful, (*pz) is set to point to a buffer containing the text in utf-8 encoding, (*pn) is set to the size in bytes (not characters) of the buffer and SQLITE_OK is returned. Otherwise, if an error occurs, an SQLite error code is returned and the final values of (*pz) and (*pn) are undefined.</source>
          <target state="translated">该函数试图检索当前文档中iCol列的文本。如果成功,(*pz)被设置为指向一个包含utf-8编码文本的缓冲区,(*pn)被设置为缓冲区的字节数(不是字符数),并返回SQLITE_OK。否则,如果发生错误,将返回SQLite错误代码,并且(*pz)和(*pn)的最终值未定义。</target>
        </trans-unit>
        <trans-unit id="28a6bb3de337284487682e360c8a725a543916e4" translate="yes" xml:space="preserve">
          <source>This function attempts to scan the WAL file associated with database zDb of database handle db and make all valid snapshots available to sqlite3_snapshot_open(). It is an error if there is already a read transaction open on the database, or if the database is not a WAL mode database.</source>
          <target state="translated">这个函数试图扫描与数据库句柄db的数据库zDb相关联的WAL文件,并使所有有效的快照都能被sqlite3_snapshot_open()使用。如果数据库上已经打开了一个读事务,或者数据库不是WAL模式的数据库,那么这个函数就会出错。</target>
        </trans-unit>
        <trans-unit id="27eaa9cd67b4a77bfd0fe868cf2e24b92591db2f" translate="yes" xml:space="preserve">
          <source>This function causes all database schemas to be read from disk and parsed, if that has not already been done, and returns an error if any errors are encountered while loading the schema.</source>
          <target state="translated">该函数使所有的数据库模式从磁盘上读取并进行解析,如果还没有这样做的话,如果在加载模式时遇到任何错误,则返回一个错误。</target>
        </trans-unit>
        <trans-unit id="7d871089984a2a55cb6c89bf16fcd0bc4a023753" translate="yes" xml:space="preserve">
          <source>This function causes any pending database operation to abort and return at its earliest opportunity. This routine is typically called in response to a user action such as pressing &quot;Cancel&quot; or Ctrl-C where the user wants a long query operation to halt immediately.</source>
          <target state="translated">这个函数使任何待定的数据库操作中止,并在其最早的机会返回。这个例程通常在用户操作时被调用,如按 &quot;Cancel &quot;或Ctrl-C,用户希望一个长查询操作立即停止。</target>
        </trans-unit>
        <trans-unit id="84f0a277d8eb36da2c14763cce01f3221d3f3be5" translate="yes" xml:space="preserve">
          <source>This function closes an open &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt;. The BLOB handle is closed unconditionally. Even if this routine returns an error code, the handle is still closed.</source>
          <target state="translated">此函数关闭打开的&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄&lt;/a&gt;。BLOB句柄无条件关闭。即使此例程返回错误代码，句柄仍将关闭。</target>
        </trans-unit>
        <trans-unit id="c52c6ec750ee5ca8bf8f3568aa703ede60385a7a" translate="yes" xml:space="preserve">
          <source>This function closes an open &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt;. The BLOB handle is closed unconditionally. Even if this routine returns an error code, the handle is still closed.</source>
          <target state="translated">此函数关闭打开的&lt;a href=&quot;blob&quot;&gt;BLOB句柄&lt;/a&gt;。BLOB句柄无条件关闭。即使此例程返回错误代码，句柄仍将关闭。</target>
        </trans-unit>
        <trans-unit id="dcb5cb2e9c08e0b9f3037428dbe4920c74c2b405" translate="yes" xml:space="preserve">
          <source>This function combines the two input changesets using an sqlite3_changegroup object. Calling it produces similar results as the following code fragment:</source>
          <target state="translated">这个函数使用一个sqlite3_changegroup对象将两个输入的变化集结合起来。调用它产生的结果类似于下面的代码片段。</target>
        </trans-unit>
        <trans-unit id="4624a9200d853f2e32a44b7a98a35021843efd43" translate="yes" xml:space="preserve">
          <source>This function does not change the order in which changes appear within the changeset. It merely reverses the sense of each individual change.</source>
          <target state="translated">这个功能并不改变变更集中变更出现的顺序。它只是颠倒了每个单独变化的意义。</target>
        </trans-unit>
        <trans-unit id="d7cbc42833b432d19d25054e50c1379caf39e23d" translate="yes" xml:space="preserve">
          <source>This function does not set the database handle error code or message returned by the &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; functions.</source>
          <target state="translated">此函数不会设置由&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;函数返回的数据库句柄错误代码或消息。</target>
        </trans-unit>
        <trans-unit id="2c015e6f1fde0378f350b940649e6bb977266a40" translate="yes" xml:space="preserve">
          <source>This function does not set the database handle error code or message returned by the &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; functions.</source>
          <target state="translated">此函数不会设置由&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;和&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;函数返回的数据库句柄错误代码或消息。</target>
        </trans-unit>
        <trans-unit id="6303b7057e9914dac072c1b4a0b74b270e4dc698" translate="yes" xml:space="preserve">
          <source>This function fails with SQLITE_ERROR if any of the following are true:</source>
          <target state="translated">如果以下任何一项为真,该函数将以SQLITE_ERROR失败。</target>
        </trans-unit>
        <trans-unit id="870ceb33e21de66e2ccc8a5ce1caa06026ee0a3c" translate="yes" xml:space="preserve">
          <source>This function is accessible to SQL statements via the &lt;a href=&quot;../lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid() SQL function&lt;/a&gt;.</source>
          <target state="translated">SQL语句可通过&lt;a href=&quot;../lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid（）SQL函数&lt;/a&gt;访问此函数。</target>
        </trans-unit>
        <trans-unit id="3ed24a06a5fab16f67d5f77a45744a9d31cdf2e0" translate="yes" xml:space="preserve">
          <source>This function is accessible to SQL statements via the &lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid() SQL function&lt;/a&gt;.</source>
          <target state="translated">SQL语句可通过&lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid（）SQL函数&lt;/a&gt;访问此函数。</target>
        </trans-unit>
        <trans-unit id="ba56f71e7eaf44d8bff350353ce98793aa844743" translate="yes" xml:space="preserve">
          <source>This function is expected to tokenize the nText byte string indicated by argument pText. pText may or may not be nul-terminated. The first argument passed to this function is a pointer to an Fts5Tokenizer object returned by an earlier call to xCreate().</source>
          <target state="translated">这个函数将对参数 pText 所表示的 nText 字节进行标记化处理。传递给本函数的第一个参数是指向一个Fts5Tokenizer对象的指针,该对象由之前调用xCreate()返回。</target>
        </trans-unit>
        <trans-unit id="c0f6fbfd19fbfc44b1560cfd2b05948b7fed7c50" translate="yes" xml:space="preserve">
          <source>This function is invoked to delete a tokenizer handle previously allocated using xCreate(). Fts5 guarantees that this function will be invoked exactly once for each successful call to xCreate().</source>
          <target state="translated">该函数用于删除之前使用 xCreate()分配的 tokenizer 句柄。Fts5 保证每次成功调用 xCreate()时,这个函数都会被调用一次。</target>
        </trans-unit>
        <trans-unit id="fcde84651450f2b10b0843fe43cf87cdc47c8be9" translate="yes" xml:space="preserve">
          <source>This function is used to &quot;invert&quot; a changeset object. Applying an inverted changeset to a database reverses the effects of applying the uninverted changeset. Specifically:</source>
          <target state="translated">这个函数用来 &quot;反转 &quot;一个变化集对象。将一个倒置的变化集应用到数据库中会反转应用未倒置的变化集的效果。具体来说</target>
        </trans-unit>
        <trans-unit id="29ae82377275c7b1f1384fc8e2d212e8da0789d4" translate="yes" xml:space="preserve">
          <source>This function is used to allocate and initialize a tokenizer instance. A tokenizer instance is required to actually tokenize text.</source>
          <target state="translated">该函数用于分配和初始化一个标记符实例。需要一个tokenizer实例来实际标记文本。</target>
        </trans-unit>
        <trans-unit id="24b74a85f4b47c195bc0b6fe21af9724e0d1ed94" translate="yes" xml:space="preserve">
          <source>This function is used to concatenate two changesets, A and B, into a single changeset. The result is a changeset equivalent to applying changeset A followed by changeset B.</source>
          <target state="translated">这个函数用于将两个变化集,A和B,连接成一个变化集。结果是一个变化集,相当于应用变化集A和变化集B。</target>
        </trans-unit>
        <trans-unit id="69eb445f771165e9cf3bdc2eef0ebd4932045f16" translate="yes" xml:space="preserve">
          <source>This function is used to finalize an iterator allocated with &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;.</source>
          <target state="translated">此函数用于完成分配有&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;的迭代器。</target>
        </trans-unit>
        <trans-unit id="b35815e34122016382887fcb96a49b58070b37da" translate="yes" xml:space="preserve">
          <source>This function is used to finalize an iterator allocated with &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;.</source>
          <target state="translated">此函数用于完成分配有&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;的迭代器。</target>
        </trans-unit>
        <trans-unit id="2cfec4fd8864b11036478634ce0c848102b439e0" translate="yes" xml:space="preserve">
          <source>This function is used to find which columns comprise the PRIMARY KEY of the table modified by the change that iterator pIter currently points to. If successful, *pabPK is set to point to an array of nCol entries, where nCol is the number of columns in the table. Elements of *pabPK are set to 0x01 if the corresponding column is part of the tables primary key, or 0x00 if it is not.</source>
          <target state="translated">该函数用于查找由迭代器pIter当前指向的变化所修改的表的PRIMARY KEY由哪些列组成。如果成功,*pabPK将被设置为指向一个nCol条目的数组,其中nCol是表中的列数。如果对应的列是表的主键的一部分,则*pabPK的元素被设置为0x01,如果不是,则为0x00。</target>
        </trans-unit>
        <trans-unit id="e114c8bad40f12de287f68c473424a8e6e66648d" translate="yes" xml:space="preserve">
          <source>This function is used to move an existing &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; so that it points to a different row of the same database table. The new row is identified by the rowid value passed as the second argument. Only the row can be changed. The database, table and column on which the blob handle is open remain the same. Moving an existing &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; to a new row is faster than closing the existing handle and opening a new one.</source>
          <target state="translated">此函数用于移动现有的&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄&lt;/a&gt;，使其指向同一数据库表的另一行。新行由作为第二个参数传递的rowid值标识。仅该行可以更改。打开Blob句柄的数据库，表和列保持不变。将现有的&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄&lt;/a&gt;移动到新行比关闭现有的句柄并打开新的句柄要快。</target>
        </trans-unit>
        <trans-unit id="308c798f0a295eb0c4645e5b7f42fbabbc544780" translate="yes" xml:space="preserve">
          <source>This function is used to move an existing &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; so that it points to a different row of the same database table. The new row is identified by the rowid value passed as the second argument. Only the row can be changed. The database, table and column on which the blob handle is open remain the same. Moving an existing &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; to a new row is faster than closing the existing handle and opening a new one.</source>
          <target state="translated">此函数用于移动现有的&lt;a href=&quot;blob&quot;&gt;BLOB句柄&lt;/a&gt;，使其指向同一数据库表的另一行。新行由作为第二个参数传递的rowid值标识。仅该行可以更改。打开Blob句柄的数据库，表和列保持不变。将现有的&lt;a href=&quot;blob&quot;&gt;BLOB句柄&lt;/a&gt;移动到新行比关闭现有的句柄并打开新的句柄要快。</target>
        </trans-unit>
        <trans-unit id="4b885ede0001de9f5c638f038a437a23ced24dd6" translate="yes" xml:space="preserve">
          <source>This function is used to read data from an open &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; into a caller-supplied buffer. N bytes of data are copied into buffer Z from the open BLOB, starting at offset iOffset.</source>
          <target state="translated">此函数用于将数据从打开的&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄&lt;/a&gt;读取到调用方提供的缓冲区中。从偏移量iOffset开始，将N个字节的数据从打开的BLOB复制到缓冲区Z中。</target>
        </trans-unit>
        <trans-unit id="21272222209bb70a086675dada0f2b2f97f0f8e4" translate="yes" xml:space="preserve">
          <source>This function is used to read data from an open &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; into a caller-supplied buffer. N bytes of data are copied into buffer Z from the open BLOB, starting at offset iOffset.</source>
          <target state="translated">此函数用于将数据从打开的&lt;a href=&quot;blob&quot;&gt;BLOB句柄&lt;/a&gt;读取到调用方提供的缓冲区中。从偏移量iOffset开始，将N个字节的数据从打开的BLOB复制到缓冲区Z中。</target>
        </trans-unit>
        <trans-unit id="9f3667d662139e493e6cf3b56b1b782512c8bc44" translate="yes" xml:space="preserve">
          <source>This function is used to retrieve the total number of rows in the table. In other words, the same value that would be returned by:</source>
          <target state="translated">这个函数用于检索表中的总行数。换句话说,与以下函数返回的值相同。</target>
        </trans-unit>
        <trans-unit id="b651a758789810b674e3ae5146e089dc27672b54" translate="yes" xml:space="preserve">
          <source>This function is used to set, clear or query the session object indirect flag. If the second argument passed to this function is zero, then the indirect flag is cleared. If it is greater than zero, the indirect flag is set. Passing a value less than zero does not modify the current value of the indirect flag, and may be used to query the current state of the indirect flag for the specified session object.</source>
          <target state="translated">该函数用于设置、清除或查询会话对象的间接标志,如果传递给该函数的第二个参数为零,则清除间接标志。如果传递给此函数的第二个参数为0,则清除间接标志。如果大于零,则设置间接标志。传递的值小于零,则不会修改间接标志的当前值,可用于查询指定会话对象间接标志的当前状态。</target>
        </trans-unit>
        <trans-unit id="57a1761e9d0e1762347b4943de9494b5f2f5f8cc" translate="yes" xml:space="preserve">
          <source>This function is used to write data into an open &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; from a caller-supplied buffer. N bytes of data are copied from the buffer Z into the open BLOB, starting at offset iOffset.</source>
          <target state="translated">此函数用于将数据从调用者提供的缓冲区写入打开的&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄中&lt;/a&gt;。从偏移量iOffset开始，将N个字节的数据从缓冲区Z复制到打开的BLOB中。</target>
        </trans-unit>
        <trans-unit id="959745cc981e8eae46a52bb0e5894da3fa5cff9f" translate="yes" xml:space="preserve">
          <source>This function is used to write data into an open &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; from a caller-supplied buffer. N bytes of data are copied from the buffer Z into the open BLOB, starting at offset iOffset.</source>
          <target state="translated">此函数用于将数据从调用者提供的缓冲区写入打开的&lt;a href=&quot;blob&quot;&gt;BLOB句柄中&lt;/a&gt;。从偏移量iOffset开始，将N个字节的数据从缓冲区Z复制到打开的BLOB中。</target>
        </trans-unit>
        <trans-unit id="1483892d5daffd0f4eda8275dee22e2f701b626d" translate="yes" xml:space="preserve">
          <source>This function is used, along with type Fts5PhraseIter and the xPhraseNext method, to iterate through all instances of a single query phrase within the current row. This is the same information as is accessible via the xInstCount/xInst APIs. While the xInstCount/xInst APIs are more convenient to use, this API may be faster under some circumstances. To iterate through instances of phrase iPhrase, use the following code:</source>
          <target state="translated">这个函数与Fts5PhraseIter类型和xPhraseNext方法一起,用来遍历当前行中单个查询短语的所有实例。这与通过xInstCount/xInst APIs访问的信息相同。虽然xInstCount/xInst APIs使用起来更方便,但在某些情况下,这个API可能更快。要遍历短语iPhrase的实例,请使用以下代码。</target>
        </trans-unit>
        <trans-unit id="2e540303404a447a74d8a0d678f9bad1c3c4058d" translate="yes" xml:space="preserve">
          <source>This function maps every page number into an integer between 0 and 8191 inclusive. The aHash field of each 32768-byte shm file unit maps P values into indexes of the aPgno field of the same unit as follows:</source>
          <target state="translated">这个函数将每个页码映射成0到8191之间的整数。每个32768字节的shm文件单元的aHash字段将P值映射到同一单元的aPgno字段的索引中,如下所示。</target>
        </trans-unit>
        <trans-unit id="b474b368c95d2db3e02f8d968fb517ea9f808a38" translate="yes" xml:space="preserve">
          <source>This function may also return SQLITE_NOMEM. If it is called with the database handle in autocommit mode but fails for some other reason, whether or not a read transaction is opened on schema S is undefined.</source>
          <target state="translated">这个函数也可能返回SQLITE_NOMEM。如果在数据库句柄处于自动提交模式的情况下调用该函数,但由于其他原因而失败,那么是否在模式S上打开读事务是未定义的。</target>
        </trans-unit>
        <trans-unit id="d107c7c4ed710ea3330eefcfd44db3b75a5ff363" translate="yes" xml:space="preserve">
          <source>This function may be called by either the &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementation to configure various facets of the virtual table interface.</source>
          <target state="translated">&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;实现的&lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;或&lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;方法可以调用此函数，以配置虚拟表接口的各个方面。</target>
        </trans-unit>
        <trans-unit id="436450a55b61a947a304f65e4e9be131ade57dc9" translate="yes" xml:space="preserve">
          <source>This function may be called by either the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation to configure various facets of the virtual table interface.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;实现的&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;或&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;方法可以调用此函数，以配置虚拟表接口的各个方面。</target>
        </trans-unit>
        <trans-unit id="892823d34401462a7936657244cacf73ba9d16a7" translate="yes" xml:space="preserve">
          <source>This function may be quite inefficient if used with an FTS5 table created with the &quot;columnsize=0&quot; option.</source>
          <target state="translated">如果使用以 &quot;columnsize=0 &quot;选项创建的FTS5表,这个函数的效率可能很低。</target>
        </trans-unit>
        <trans-unit id="e3c728fb74daea7a42a0d0a89203b1fbf38464ae" translate="yes" xml:space="preserve">
          <source>This function may only be called from within a call to the &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">此函数只能在对&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;的&lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;方法的调用中调用。</target>
        </trans-unit>
        <trans-unit id="651e6e671ae629015a6ac3d4f4c461902dc827bb" translate="yes" xml:space="preserve">
          <source>This function may only be called from within a call to the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementation for an INSERT or UPDATE operation. The value returned is one of &lt;a href=&quot;c_fail&quot;&gt;SQLITE_ROLLBACK&lt;/a&gt;, &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;, &lt;a href=&quot;c_fail&quot;&gt;SQLITE_FAIL&lt;/a&gt;, &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;, or &lt;a href=&quot;c_fail&quot;&gt;SQLITE_REPLACE&lt;/a&gt;, according to the &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode of the SQL statement that triggered the call to the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">只能在对INSERT或UPDATE操作的&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;实现的&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法的调用中调用此函数。根据触发&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法调用的SQL语句的&lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;模式，返回的值是&lt;a href=&quot;c_fail&quot;&gt;SQLITE_ROLLBACK&lt;/a&gt;，&lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;，&lt;a href=&quot;c_fail&quot;&gt;SQLITE_FAIL&lt;/a&gt;，&lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;或&lt;a href=&quot;c_fail&quot;&gt;SQLITE_REPLACE&lt;/a&gt;之一。</target>
        </trans-unit>
        <trans-unit id="a16a26f00d528f2a67fb084167cd62426f17fa64" translate="yes" xml:space="preserve">
          <source>This function may only be called from within a call to the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">此函数只能在对&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;的&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;方法的调用中调用。</target>
        </trans-unit>
        <trans-unit id="a48f675a9216b80779894ce906eb64bd5d832356" translate="yes" xml:space="preserve">
          <source>This function may only be called from within a call to the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation for an INSERT or UPDATE operation. The value returned is one of &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_ROLLBACK&lt;/a&gt;, &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_FAIL&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_REPLACE&lt;/a&gt;, according to the &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode of the SQL statement that triggered the call to the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">只能在对INSERT或UPDATE操作的&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;实现的&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法的调用中调用此函数。根据触发&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;方法调用的SQL语句的&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;模式，返回的值是&lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_ROLLBACK&lt;/a&gt;，&lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;，&lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_FAIL&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;或&lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_REPLACE&lt;/a&gt;之一。</target>
        </trans-unit>
        <trans-unit id="9f4b868b197498e92e7be98a22186e8a9d0ec008" translate="yes" xml:space="preserve">
          <source>This function may only be called with an iterator passed to an SQLITE_CHANGESET_FOREIGN_KEY conflict handler callback. In this case it sets the output variable to the total number of known foreign key violations in the destination database and returns SQLITE_OK.</source>
          <target state="translated">这个函数只能与传递给SQLITE_CHANGESET_FOREIGN_KEY冲突处理回调的迭代器一起调用。在这种情况下,它将输出变量设置为目标数据库中已知外键违规的总数,并返回SQLITE_OK。</target>
        </trans-unit>
        <trans-unit id="6aefcc013460f98a7eaca0c2faea39955530e82b" translate="yes" xml:space="preserve">
          <source>This function may only be used with iterators created by function &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. If it is called on an iterator passed to a conflict-handler callback by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, SQLITE_MISUSE is returned and the call has no effect.</source>
          <target state="translated">此函数只能与由&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;函数创建的迭代器一起使用。如果在通过&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;传递给冲突处理程序回调的迭代器上调用它，则返回SQLITE_MISUSE，并且该调用无效。</target>
        </trans-unit>
        <trans-unit id="6b40997bef104535dd0852dc311c81d541b71952" translate="yes" xml:space="preserve">
          <source>This function may only be used with iterators created by function &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. If it is called on an iterator passed to a conflict-handler callback by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, SQLITE_MISUSE is returned and the call has no effect.</source>
          <target state="translated">此函数只能与由&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;函数创建的迭代器一起使用。如果在通过&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;传递给冲突处理程序回调的迭代器上调用它，则返回SQLITE_MISUSE，并且该调用无效。</target>
        </trans-unit>
        <trans-unit id="81dcfaa530f9bc3b0cf4ff6ac3dd711bd8249deb" translate="yes" xml:space="preserve">
          <source>This function may only be used with iterators created by the function &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. If it is called on an iterator passed to a conflict-handler callback by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, SQLITE_MISUSE is returned and the call has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2a7a3750664d2ff5967d620601e32e54729a198" translate="yes" xml:space="preserve">
          <source>This function may only be used with iterators created by the function &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. If it is called on an iterator passed to a conflict-handler callback by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, SQLITE_MISUSE is returned and the call has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3cebc479567b581aaea382b042cd658c5a6fd2" translate="yes" xml:space="preserve">
          <source>This function may only modify the contents of the BLOB; it is not possible to increase the size of a BLOB using this API. If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is written. The size of the BLOB (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface. If N or iOffset are less than zero &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is written.</source>
          <target state="translated">该函数只能修改BLOB的内容；使用此API不可能增加BLOB的大小。如果偏移量iOffset从BLOB的末尾开始小于N个字节，则返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR且不&lt;/a&gt;写入任何数据。可以使用&lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;接口确定BLOB的大小（以及N + iOffset的最大值）。如果N或iOffset小于零，则返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR且不&lt;/a&gt;写入任何数据。</target>
        </trans-unit>
        <trans-unit id="cc4415e783325c61d6eb500d3a2195a9814914cb" translate="yes" xml:space="preserve">
          <source>This function may only modify the contents of the BLOB; it is not possible to increase the size of a BLOB using this API. If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is written. The size of the BLOB (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface. If N or iOffset are less than zero &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is written.</source>
          <target state="translated">该函数只能修改BLOB的内容；使用此API不可能增加BLOB的大小。如果偏移量iOffset从BLOB的末尾开始小于N个字节，则返回&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR且不&lt;/a&gt;写入任何数据。可以使用&lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;接口确定BLOB的大小（以及N + iOffset的最大值）。如果N或iOffset小于零，则返回&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR且不&lt;/a&gt;写入任何数据。</target>
        </trans-unit>
        <trans-unit id="e611001e69d55801c25d56986ec39153bc754108" translate="yes" xml:space="preserve">
          <source>This function returns SQLITE_OK if successful, or an SQLite error code otherwise.</source>
          <target state="translated">如果成功,该函数返回SQLITE_OK,否则返回SQLite错误代码。</target>
        </trans-unit>
        <trans-unit id="1c2517d3cf09b0cdb52fd7581d781f148fee8f8f" translate="yes" xml:space="preserve">
          <source>This function returns the number of rows modified, inserted or deleted by the most recently completed INSERT, UPDATE or DELETE statement on the database connection specified by the only parameter. Executing any other type of SQL statement does not modify the value returned by this function.</source>
          <target state="translated">这个函数返回在唯一参数指定的数据库连接上最近完成的INSERT、UPDATE或DELETE语句所修改、插入或删除的行数。执行任何其他类型的SQL语句都不会修改这个函数返回的值。</target>
        </trans-unit>
        <trans-unit id="6b76b4997f936492171845d7baebab3de049f79f" translate="yes" xml:space="preserve">
          <source>This function returns the total number of rows inserted, modified or deleted by all &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; statements completed since the database connection was opened, including those executed as part of trigger programs. Executing any other type of SQL statement does not affect the value returned by sqlite3_total_changes().</source>
          <target state="translated">此函数返回自打开数据库连接以来已完成的所有&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;，&lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt;或&lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt;语句插入，修改或删除的行总数，包括作为触发器程序一部分执行的行。执行任何其他类型的SQL语句都不会影响sqlite3_total_changes（）返回的值。</target>
        </trans-unit>
        <trans-unit id="adf4834644160b8bd2e8b37a1e591e556b1afb6a" translate="yes" xml:space="preserve">
          <source>This function returns the total number of rows inserted, modified or deleted by all &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements completed since the database connection was opened, including those executed as part of trigger programs. Executing any other type of SQL statement does not affect the value returned by sqlite3_total_changes().</source>
          <target state="translated">此函数返回自打开数据库连接以来已完成的所有&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;，&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;或&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;语句插入，修改或删除的行总数，包括作为触发器程序一部分执行的行。执行任何其他类型的SQL语句都不会影响sqlite3_total_changes（）返回的值。</target>
        </trans-unit>
        <trans-unit id="8213d08301f09db1801edcdcc6b6898d5bedde17" translate="yes" xml:space="preserve">
          <source>This function sets the database handle error code and message.</source>
          <target state="translated">该函数设置数据库句柄的错误代码和消息。</target>
        </trans-unit>
        <trans-unit id="dc027be02604df0d93fb0c7fd87bd8fb650c8db3" translate="yes" xml:space="preserve">
          <source>This function should only be called on iterators created using the &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; function. If an application calls this function with an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; is immediately returned and the call has no effect.</source>
          <target state="translated">仅应在使用&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;函数创建的迭代器上调用此函数。如果应用程序调用该函数通过传递给冲突处理程序迭代&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（） &lt;/a&gt;，&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;立即返回，呼叫没有任何影响。</target>
        </trans-unit>
        <trans-unit id="2df7e3d1377d5e8297acef52974006d62b57703e" translate="yes" xml:space="preserve">
          <source>This function should only be called on iterators created using the &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; function. If an application calls this function with an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; is immediately returned and the call has no effect.</source>
          <target state="translated">仅应在使用&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;函数创建的迭代器上调用此函数。如果应用程序调用该函数通过传递给冲突处理程序迭代&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（） &lt;/a&gt;，&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;立即返回，呼叫没有任何影响。</target>
        </trans-unit>
        <trans-unit id="6644624c994928cadd1595cf7f165d3a9a2ca4f0" translate="yes" xml:space="preserve">
          <source>This function should only be used with iterator objects passed to a conflict-handler callback by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; with either &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; or &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;. If this function is called on any other iterator, &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; is returned and *ppValue is set to NULL.</source>
          <target state="translated">该函数仅应与&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;通过&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt;或&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;传递给冲突处理程序回调的迭代器对象一起使用。如果在任何其他迭代器上调用此函数，则返回&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;并将* ppValue设置为NULL。</target>
        </trans-unit>
        <trans-unit id="548141af0246ca4eef33b575f89c5796207c5a05" translate="yes" xml:space="preserve">
          <source>This function should only be used with iterator objects passed to a conflict-handler callback by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; with either &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; or &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;. If this function is called on any other iterator, &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; is returned and *ppValue is set to NULL.</source>
          <target state="translated">该函数仅应与&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;通过&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt;或&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;传递给冲突处理程序回调的迭代器对象一起使用。如果在任何其他迭代器上调用此函数，则返回&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;并将* ppValue设置为NULL。</target>
        </trans-unit>
        <trans-unit id="aabca26792420e3dedde38828f3aa35b5f3a0612" translate="yes" xml:space="preserve">
          <source>This generates a file named &lt;b&gt;ex1.dump.gz&lt;/b&gt; that contains everything you need to reconstruct the database at a later time, or on another machine. To reconstruct the database, just type:</source>
          <target state="translated">这将生成一个名为&lt;b&gt;ex1.dump.gz&lt;/b&gt;的文件，其中包含稍后或在另一台计算机上重建数据库所需的所有内容。要重建数据库，只需键入：</target>
        </trans-unit>
        <trans-unit id="311cc4fab23f9723b1a4efe300a30ad45967a776" translate="yes" xml:space="preserve">
          <source>This graph is acyclic. And we assume that the mtime of every child checkin is no less than the mtime of all its parents. But unlike the earlier examples, this graph might have multiple paths of differing lengths between any two checkins.</source>
          <target state="translated">这个图是无周期的。我们假设每个子签到的m时间不小于所有父签到的m时间。但与前面的例子不同的是,这个图可能在任何两个签入之间有多条长度不同的路径。</target>
        </trans-unit>
        <trans-unit id="fa0e2bf6a1863b49e18b3cb7db1999e03d428ead" translate="yes" xml:space="preserve">
          <source>This historical version numbering system used a two-, three-, or four-number version: W.X, W.X.Y, or W.X.Y.Z. W was the file format: 1 or 2 or 3. X was the major version. Y was the minor version. Z was used only for patch releases to fix bugs.</source>
          <target state="translated">这种历史上的版本编号系统采用的是二号、三号或四号版本。W.X,W.X.Y,或W.X.Y.Z.W是文件格式:1或2或3.X是主要版本。Y是次要版本。Z只用于修复错误的补丁版本。</target>
        </trans-unit>
        <trans-unit id="9f4676d0afd51e8fa37c9aa0283801b026a1b72b" translate="yes" xml:space="preserve">
          <source>This instruction causes the VM to halt.</source>
          <target state="translated">该指令会导致虚拟机停止。</target>
        </trans-unit>
        <trans-unit id="fdc444b74a87e964e8bcc2b42a370bbc5df69c15" translate="yes" xml:space="preserve">
          <source>This instruction makes a deep copy of the value. A duplicate is made of any string or blob constant. See also &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt;.</source>
          <target state="translated">该指令对值进行了深层复制。任何字符串或blob常量均构成重复项。另请参阅&lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0dad5db056b0ca8e5a487c8ab6c8e6dc7e0f2672" translate="yes" xml:space="preserve">
          <source>This instruction makes a shallow copy of the value. If the value is a string or blob, then the copy is only a pointer to the original and hence if the original changes so will the copy. Worse, if the original is deallocated, the copy becomes invalid. Thus the program must guarantee that the original will not change during the lifetime of the copy. Use &lt;a href=&quot;opcode#Copy&quot;&gt;Copy&lt;/a&gt; to make a complete copy.</source>
          <target state="translated">该指令对值进行了浅表复制。如果值是字符串或Blob，则副本只是指向原始对象的指针，因此，如果原始对象发生更改，则副本也将更改。更糟糕的是，如果原件被重新分配，副本将无效。因此，程序必须保证原件在复印期间不会更改。使用&amp;ldquo; &lt;a href=&quot;opcode#Copy&quot;&gt;复印&amp;rdquo;&lt;/a&gt;进行完整复印。</target>
        </trans-unit>
        <trans-unit id="4df251f100bd98635ac20986854a4f9d3558bf05" translate="yes" xml:space="preserve">
          <source>This instruction only works for indices. The equivalent instruction for tables is &lt;a href=&quot;opcode#Insert&quot;&gt;Insert&lt;/a&gt;.</source>
          <target state="translated">该指令仅适用于索引。表的等效指令是&lt;a href=&quot;opcode#Insert&quot;&gt;Insert&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="724c5d92359b2812711bd98fdbbd0ee48ff16933" translate="yes" xml:space="preserve">
          <source>This instruction only works on tables. The equivalent instruction for indices is &lt;a href=&quot;opcode#IdxInsert&quot;&gt;IdxInsert&lt;/a&gt;.</source>
          <target state="translated">该指令仅适用于表。索引的等效指令是&lt;a href=&quot;opcode#IdxInsert&quot;&gt;IdxInsert&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cc342418f5a1b7e3edc039b6124a9b746a56c8e5" translate="yes" xml:space="preserve">
          <source>This instruction throws an error if the memory cell is not initially an integer.</source>
          <target state="translated">如果内存单元最初不是一个整数,则该指令会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="b8399072455bb3b6ee2757655f5f7b2af59230c1" translate="yes" xml:space="preserve">
          <source>This instruction works like &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; except that it opens the cursor in read/write mode.</source>
          <target state="translated">该指令的工作方式与&lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt;相似，只是它以读/写模式打开游标。</target>
        </trans-unit>
        <trans-unit id="849ae2eb4b736949542c4487e7de5222b770b0b6" translate="yes" xml:space="preserve">
          <source>This interface allows the size of various constructs to be limited on a connection by connection basis. The first parameter is the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; whose limit is to be set or queried. The second parameter is one of the &lt;a href=&quot;#SQLITE_LIMIT_ATTACHED&quot;&gt;limit categories&lt;/a&gt; that define a class of constructs to be size limited. The third parameter is the new limit for that construct.</source>
          <target state="translated">该接口允许在逐个连接的基础上限制各种构造的大小。第一个参数是要设置或查询其限制的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;。第二个参数是&lt;a href=&quot;#SQLITE_LIMIT_ATTACHED&quot;&gt;限制类别&lt;/a&gt;之一，它定义了要限制大小的构造类。第三个参数是该构造的新限制。</target>
        </trans-unit>
        <trans-unit id="6687035e8ed6fa147345334bd3634ec9e7ff5918" translate="yes" xml:space="preserve">
          <source>This interface allows the size of various constructs to be limited on a connection by connection basis. The first parameter is the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; whose limit is to be set or queried. The second parameter is one of the &lt;a href=&quot;c_limit_attached&quot;&gt;limit categories&lt;/a&gt; that define a class of constructs to be size limited. The third parameter is the new limit for that construct.</source>
          <target state="translated">该接口允许在逐个连接的基础上限制各种构造的大小。第一个参数是要设置或查询其限制的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;。第二个参数是&lt;a href=&quot;c_limit_attached&quot;&gt;限制类别&lt;/a&gt;之一，它定义了要限制大小的构造类。第三个参数是该构造的新限制。</target>
        </trans-unit>
        <trans-unit id="9256e21c25ccdf9db985fbb93738819f3d6d967d" translate="yes" xml:space="preserve">
          <source>This interface can be used by an application to make sure that the version of SQLite that it is linking against was compiled with the desired setting of the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; macro.</source>
          <target state="translated">应用程序可以使用此接口，以确保使用所需的&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt;宏设置编译了与其链接的SQLite版本。</target>
        </trans-unit>
        <trans-unit id="32dc361b08c9c60505d75103bdc36b57584e9fcf" translate="yes" xml:space="preserve">
          <source>This interface can be used by an application to make sure that the version of SQLite that it is linking against was compiled with the desired setting of the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; macro.</source>
          <target state="translated">应用程序可以使用此接口，以确保使用所需的&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt;宏设置编译了与其链接的SQLite版本。</target>
        </trans-unit>
        <trans-unit id="25ebb19095f954c7ae8a2ed499bdbfed83aadaa6" translate="yes" xml:space="preserve">
          <source>This interface can be used in combination &lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt()&lt;/a&gt; to locate all prepared statements associated with a database connection that are in need of being reset. This can be used, for example, in diagnostic routines to search for prepared statements that are holding a transaction open.</source>
          <target state="translated">该接口可以与&lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt（）&lt;/a&gt;结合使用，以查找与数据库连接关联的所有准备语句，这些语句需要重置。例如，可以在诊断例程中使用它来搜索使事务处于打开状态的准备好的语句。</target>
        </trans-unit>
        <trans-unit id="d607ef96133a79a067aeb3d80e9e814bdda87569" translate="yes" xml:space="preserve">
          <source>This interface can be used in combination &lt;a href=&quot;next_stmt&quot;&gt;sqlite3_next_stmt()&lt;/a&gt; to locate all prepared statements associated with a database connection that are in need of being reset. This can be used, for example, in diagnostic routines to search for prepared statements that are holding a transaction open.</source>
          <target state="translated">该接口可以与&lt;a href=&quot;next_stmt&quot;&gt;sqlite3_next_stmt（）&lt;/a&gt;结合使用，以查找与数据库连接关联的所有准备语句，这些语句需要重置。例如，可以在诊断例程中使用它来搜索使事务处于打开状态的准备好的语句。</target>
        </trans-unit>
        <trans-unit id="d798abdc7bea34806f312f897736975cfc379c7c" translate="yes" xml:space="preserve">
          <source>This interface causes the xEntryPoint() function to be invoked for each new &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that is created. The idea here is that xEntryPoint() is the entry point for a statically linked &lt;a href=&quot;loadext&quot;&gt;SQLite extension&lt;/a&gt; that is to be automatically loaded into all new database connections.</source>
          <target state="translated">此接口导致为创建的每个新&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;调用xEntryPoint（）函数。这里的想法是xEntryPoint（）是静态链接的&lt;a href=&quot;loadext&quot;&gt;SQLite扩展&lt;/a&gt;的入口点，该扩展将自动加载到所有新的数据库连接中。</target>
        </trans-unit>
        <trans-unit id="a18b59c5465abea2190a535937651aa6f4f67fb4" translate="yes" xml:space="preserve">
          <source>This interface causes the xEntryPoint() function to be invoked for each new &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that is created. The idea here is that xEntryPoint() is the entry point for a statically linked &lt;a href=&quot;../loadext&quot;&gt;SQLite extension&lt;/a&gt; that is to be automatically loaded into all new database connections.</source>
          <target state="translated">此接口导致为创建的每个新&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;调用xEntryPoint（）函数。这里的想法是xEntryPoint（）是静态链接的&lt;a href=&quot;../loadext&quot;&gt;SQLite扩展&lt;/a&gt;的入口点，该扩展将自动加载到所有新的数据库连接中。</target>
        </trans-unit>
        <trans-unit id="9786ef1ecb8c77d789971c3f849525761d5d38c2" translate="yes" xml:space="preserve">
          <source>This interface disables all automatic extensions previously registered using &lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt;.</source>
          <target state="translated">此接口禁用以前使用&lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;注册的所有自动扩展。</target>
        </trans-unit>
        <trans-unit id="2b9c0cbd974b30f6431515e1186211476ca08e78" translate="yes" xml:space="preserve">
          <source>This interface disables all automatic extensions previously registered using &lt;a href=&quot;auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt;.</source>
          <target state="translated">此接口禁用以前使用&lt;a href=&quot;auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;注册的所有自动扩展。</target>
        </trans-unit>
        <trans-unit id="8736a85b1a1bcc4c800c4ff7d229eb677c9e2f70" translate="yes" xml:space="preserve">
          <source>This interface enables or disables both the C-API &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; and the SQL function &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt;. Use &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;,..) to enable or disable only the C-API.</source>
          <target state="translated">此接口启用或禁用C-API &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;和SQL函数&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt;。使用&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（db，&lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;，..）仅启用或禁用C-API。</target>
        </trans-unit>
        <trans-unit id="ab1cdc93fe51f37fdae78544827ec5e365f941a3" translate="yes" xml:space="preserve">
          <source>This interface enables or disables both the C-API &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; and the SQL function &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt;. Use &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;,..) to enable or disable only the C-API.</source>
          <target state="translated">此接口启用或禁用C-API &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;和SQL函数&lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt;。使用&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（db，&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;，..）仅启用或禁用C-API。</target>
        </trans-unit>
        <trans-unit id="737d038457ffc2dd705bbf7d3e67fd74eca8f49b" translate="yes" xml:space="preserve">
          <source>This interface is not for use by applications. It exists solely for verifying the correct operation of the SQLite library. Depending on how the SQLite library is compiled, this interface might not exist.</source>
          <target state="translated">这个接口不供应用程序使用。它的存在只是为了验证SQLite库的正确操作。根据SQLite库的编译方式,这个接口可能不存在。</target>
        </trans-unit>
        <trans-unit id="dec74db456b76b7c855d3cb1358c040acad3ef05" translate="yes" xml:space="preserve">
          <source>This interface is only available if SQLite is compiled with the &lt;a href=&quot;../compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt; option.</source>
          <target state="translated">仅当使用&lt;a href=&quot;../compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt;选项编译SQLite时，此接口才可用。</target>
        </trans-unit>
        <trans-unit id="5c93fb0edc37eb4be652a31e1dc573b6923060cf" translate="yes" xml:space="preserve">
          <source>This interface is only available if SQLite is compiled with the &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; option.</source>
          <target state="translated">仅当使用&lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt;选项编译SQLite时，此接口才可用。</target>
        </trans-unit>
        <trans-unit id="17b0e4d3f046d7d363af1d959e76e0c4d41dedec" translate="yes" xml:space="preserve">
          <source>This interface is only available if SQLite is compiled with the &lt;a href=&quot;compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt; option.</source>
          <target state="translated">仅当使用&lt;a href=&quot;compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt;选项编译SQLite时，此接口才可用。</target>
        </trans-unit>
        <trans-unit id="f287e88e4474f60d3222ad14486a836ab2470ef3" translate="yes" xml:space="preserve">
          <source>This interface is only available if SQLite is compiled with the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; option.</source>
          <target state="translated">仅当使用&lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt;选项编译SQLite时，此接口才可用。</target>
        </trans-unit>
        <trans-unit id="a689b67f9c0bc2c193b97b5db4c5c4f5c1e2370b" translate="yes" xml:space="preserve">
          <source>This interface is similar except that it takes a pointer to a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as its first argument and returns statistics about that one object rather than about the entire SQLite library. The &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface currently only recognizes a single verb &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuslookasideused&quot;&gt;SQLITE_DBSTATUS_LOOKASIDE_USED&lt;/a&gt;, though additional verbs may be added in the future.</source>
          <target state="translated">该接口与之类似，不同之处在于它以指向&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;的指针作为第一个参数，并返回有关该对象而不是整个SQLite库的统计信息。所述&lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;接口目前只能识别单一的动词&lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuslookasideused&quot;&gt;SQLITE_DBSTATUS_LOOKASIDE_USED&lt;/a&gt;，虽然附加的动词可以在将来增加。</target>
        </trans-unit>
        <trans-unit id="6dbf3e0af679b24ae953bf947ba5e6b711370c31" translate="yes" xml:space="preserve">
          <source>This interface is threadsafe on processors where writing a 32-bit integer is atomic.</source>
          <target state="translated">这个接口在写32位整数的处理器上是线程安全的。</target>
        </trans-unit>
        <trans-unit id="107b6df452544e21fe27c0a26828c70050b20ba8" translate="yes" xml:space="preserve">
          <source>This interface is used to retrieve and reset counter values from a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. The first argument is the prepared statement object to be interrogated. The second argument is an integer code for a specific &lt;a href=&quot;#SQLITE_STMTSTATUS%20counter&quot;&gt;SQLITE_STMTSTATUS counter&lt;/a&gt; to be interrogated. The current value of the requested counter is returned. If the resetFlg is true, then the counter is reset to zero after this interface call returns.</source>
          <target state="translated">该接口用于从&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句中&lt;/a&gt;检索和重置计数器值。第一个参数是要查询的准备好的语句对象。第二个参数是要查询的特定&lt;a href=&quot;#SQLITE_STMTSTATUS%20counter&quot;&gt;SQLITE_STMTSTATUS计数器&lt;/a&gt;的整数代码。返回所请求计数器的当前值。如果resetFlg为true，则此接口调用返回后，计数器将重置为零。</target>
        </trans-unit>
        <trans-unit id="459a2b79d755add49b63bbc4196d838dcdf41bd6" translate="yes" xml:space="preserve">
          <source>This interface is used to retrieve and reset counter values from a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. The first argument is the prepared statement object to be interrogated. The second argument is an integer code for a specific &lt;a href=&quot;c_stmtstatus_counter&quot;&gt;SQLITE_STMTSTATUS counter&lt;/a&gt; to be interrogated. The current value of the requested counter is returned. If the resetFlg is true, then the counter is reset to zero after this interface call returns.</source>
          <target state="translated">该接口用于从&lt;a href=&quot;stmt&quot;&gt;准备好的语句中&lt;/a&gt;检索和重置计数器值。第一个参数是要查询的准备好的语句对象。第二个参数是要查询的特定&lt;a href=&quot;c_stmtstatus_counter&quot;&gt;SQLITE_STMTSTATUS计数器&lt;/a&gt;的整数代码。返回所请求计数器的当前值。如果resetFlg为true，则此接口调用返回后，计数器将重置为零。</target>
        </trans-unit>
        <trans-unit id="4800232e2d56454f4af979f9b03af1383971aa52" translate="yes" xml:space="preserve">
          <source>This interface is used to retrieve runtime status information about a single &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument is the database connection object to be interrogated. The second argument is an integer constant, taken from the set of &lt;a href=&quot;#SQLITE_DBSTATUS%20options&quot;&gt;SQLITE_DBSTATUS options&lt;/a&gt;, that determines the parameter to interrogate. The set of &lt;a href=&quot;#SQLITE_DBSTATUS%20options&quot;&gt;SQLITE_DBSTATUS options&lt;/a&gt; is likely to grow in future releases of SQLite.</source>
          <target state="translated">此接口用于检索有关单个&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接的&lt;/a&gt;运行时状态信息。第一个参数是要查询的数据库连接对象。第二个参数是一个整数常量，它取自&lt;a href=&quot;#SQLITE_DBSTATUS%20options&quot;&gt;SQLITE_DBSTATUS选项&lt;/a&gt;的集合，该常量确定要询问的参数。&lt;a href=&quot;#SQLITE_DBSTATUS%20options&quot;&gt;SQLITE_DBSTATUS选项&lt;/a&gt;的集合在将来的SQLite版本中可能会增加。</target>
        </trans-unit>
        <trans-unit id="bbc3302201d2b7cd437db8ee6aa036bac03658d0" translate="yes" xml:space="preserve">
          <source>This interface is used to retrieve runtime status information about a single &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument is the database connection object to be interrogated. The second argument is an integer constant, taken from the set of &lt;a href=&quot;c_dbstatus_options&quot;&gt;SQLITE_DBSTATUS options&lt;/a&gt;, that determines the parameter to interrogate. The set of &lt;a href=&quot;c_dbstatus_options&quot;&gt;SQLITE_DBSTATUS options&lt;/a&gt; is likely to grow in future releases of SQLite.</source>
          <target state="translated">此接口用于检索有关单个&lt;a href=&quot;sqlite3&quot;&gt;数据库连接的&lt;/a&gt;运行时状态信息。第一个参数是要查询的数据库连接对象。第二个参数是一个整数常量，它取自&lt;a href=&quot;c_dbstatus_options&quot;&gt;SQLITE_DBSTATUS选项&lt;/a&gt;的集合，该常量确定要询问的参数。&lt;a href=&quot;c_dbstatus_options&quot;&gt;SQLITE_DBSTATUS选项&lt;/a&gt;的集合在将来的SQLite版本中可能会增加。</target>
        </trans-unit>
        <trans-unit id="0177c23c0459f643a4c9d13247ce19efb1a18257" translate="yes" xml:space="preserve">
          <source>This interface loads an SQLite extension library from the named file.</source>
          <target state="translated">这个接口从命名的文件中加载一个SQLite扩展库。</target>
        </trans-unit>
        <trans-unit id="8179bad6a4aa6b903a52e81e492e1156f601b09e" translate="yes" xml:space="preserve">
          <source>This interface only reports on the compile-time mutex setting of the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; flag. If SQLite is compiled with SQLITE_THREADSAFE=1 or =2 then mutexes are enabled by default but can be fully or partially disabled using a call to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; with the verbs &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;, &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt;, or &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt;. The return value of the sqlite3_threadsafe() function shows only the compile-time setting of thread safety, not any run-time changes to that setting made by sqlite3_config(). In other words, the return value from sqlite3_threadsafe() is unchanged by calls to sqlite3_config().</source>
          <target state="translated">该接口仅报告&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt;标志的编译时互斥设置。如果使用SQLITE_THREADSAFE = 1或= 2编译SQLite，则默认情况下会启用互斥锁，但可以通过使用带有动词&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;，&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt;或&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED的&lt;/a&gt;&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;调用来完全或部分禁用互斥锁。 sqlite3_threadsafe（）函数的返回值仅显示线程安全的编译时设置，而不显示对sqlite3_config（）所做的设置的任何运行时更改。换句话说，通过调用sqlite3_config（）不会改变sqlite3_threadsafe（）的返回值。</target>
        </trans-unit>
        <trans-unit id="2f1c5432e18dc84d0ab872e79f78a9b49a5ab932" translate="yes" xml:space="preserve">
          <source>This interface only reports on the compile-time mutex setting of the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; flag. If SQLite is compiled with SQLITE_THREADSAFE=1 or =2 then mutexes are enabled by default but can be fully or partially disabled using a call to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; with the verbs &lt;a href=&quot;#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;, &lt;a href=&quot;#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt;, or &lt;a href=&quot;#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt;. The return value of the sqlite3_threadsafe() function shows only the compile-time setting of thread safety, not any run-time changes to that setting made by sqlite3_config(). In other words, the return value from sqlite3_threadsafe() is unchanged by calls to sqlite3_config().</source>
          <target state="translated">该接口仅报告&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt;标志的编译时互斥设置。如果使用SQLITE_THREADSAFE = 1或= 2编译SQLite，则默认情况下会启用互斥锁，但可以通过使用带有动词&lt;a href=&quot;#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;，&lt;a href=&quot;#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt;或&lt;a href=&quot;#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED的&lt;/a&gt;&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;调用来完全或部分禁用互斥锁。 sqlite3_threadsafe（）函数的返回值仅显示线程安全的编译时设置，而不显示对sqlite3_config（）所做的设置的任何运行时更改。换句话说，通过调用sqlite3_config（）不会改变sqlite3_threadsafe（）的返回值。</target>
        </trans-unit>
        <trans-unit id="3e88b1695c7d666ba2e7d53c0b55a6d5efcc55d7" translate="yes" xml:space="preserve">
          <source>This interface returns a pointer the &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object that serializes access to the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; given in the argument when the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; is Serialized. If the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; is Single-thread or Multi-thread then this routine returns a NULL pointer.</source>
          <target state="translated">该接口返回一个指针&lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;对象，该对象将在&lt;a href=&quot;threadsafe&quot;&gt;线程化模式&lt;/a&gt;为Serialized时序列化对参数中给定的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接的&lt;/a&gt;访问。如果&lt;a href=&quot;threadsafe&quot;&gt;线程模式&lt;/a&gt;是单线程或多线程，则此例程返回NULL指针。</target>
        </trans-unit>
        <trans-unit id="d1fc22f71a3cec256b724ef1c90f879b1fc5cc86" translate="yes" xml:space="preserve">
          <source>This interface returns a pointer the &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object that serializes access to the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; given in the argument when the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; is Serialized. If the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; is Single-thread or Multi-thread then this routine returns a NULL pointer.</source>
          <target state="translated">该接口返回一个指针&lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;对象，该对象将在&lt;a href=&quot;../threadsafe&quot;&gt;线程化模式&lt;/a&gt;为Serialized时序列化对参数中给定的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接的&lt;/a&gt;访问。如果&lt;a href=&quot;../threadsafe&quot;&gt;线程模式&lt;/a&gt;是单线程或多线程，则此例程返回NULL指针。</target>
        </trans-unit>
        <trans-unit id="293e65533b2e0bf802333580611e0758a28818fb" translate="yes" xml:space="preserve">
          <source>This interface returns a pointer to the next &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; after pStmt associated with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; pDb. If pStmt is NULL then this interface returns a pointer to the first prepared statement associated with the database connection pDb. If no prepared statement satisfies the conditions of this routine, it returns NULL.</source>
          <target state="translated">该接口返回指向与&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; pDb 关联的pStmt 之后的下一个&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;的指针。如果pStmt为NULL，则此接口返回指向与数据库连接pDb关联的第一个准备好的语句的指针。如果没有准备好的语句满足该例程的条件，则返回NULL。</target>
        </trans-unit>
        <trans-unit id="298da08b2fcbf608e155bad7e295f53eb1526e44" translate="yes" xml:space="preserve">
          <source>This interface returns a pointer to the next &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; after pStmt associated with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; pDb. If pStmt is NULL then this interface returns a pointer to the first prepared statement associated with the database connection pDb. If no prepared statement satisfies the conditions of this routine, it returns NULL.</source>
          <target state="translated">该接口返回指向与&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; pDb 关联的pStmt 之后的下一个&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;的指针。如果pStmt为NULL，则此接口返回指向与数据库连接pDb关联的第一个准备好的语句的指针。如果没有准备好的语句满足该例程的条件，则返回NULL。</target>
        </trans-unit>
        <trans-unit id="e0779d667db00a554725939028269aca490f34bf" translate="yes" xml:space="preserve">
          <source>This interface returns information about the predicted and measured performance for pStmt. Advanced applications can use this interface to compare the predicted and the measured performance and issue warnings and/or rerun &lt;a href=&quot;../lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; if discrepancies are found.</source>
          <target state="translated">此接口返回有关pStmt的预测和测量性能的信息。高级应用程序可以使用此界面比较预测的性能和测量的性能，并发出警告和/或在发现差异时重新运行&lt;a href=&quot;../lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="85a4493d9adb4944292a15518241fee7e748e502" translate="yes" xml:space="preserve">
          <source>This interface returns information about the predicted and measured performance for pStmt. Advanced applications can use this interface to compare the predicted and the measured performance and issue warnings and/or rerun &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; if discrepancies are found.</source>
          <target state="translated">此接口返回有关pStmt的预测和测量性能的信息。高级应用程序可以使用此界面比较预测的性能和测量的性能，并发出警告和/或在发现差异时重新运行&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1bb0500a44659bfdd838f99dddff5b2745a24fd7" translate="yes" xml:space="preserve">
          <source>This interface used to be the only way to cause a checkpoint to occur. But then the newer and more powerful &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface was added. This interface is retained for backwards compatibility and as a convenience for applications that need to manually start a callback but which do not need the full power (and corresponding complication) of &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt;.</source>
          <target state="translated">该接口曾经是导致检查点发生的唯一方法。但是随后添加了更新且功能更强大的&lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;接口。保留此接口是为了向后兼容，并且为需要手动启动回调但不需要&lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;的全部功能（以及相应的复杂性）的应用程序提供便利。</target>
        </trans-unit>
        <trans-unit id="f8650a908576cbf78aafa5f2c01220a648b07e6e" translate="yes" xml:space="preserve">
          <source>This interface used to be the only way to cause a checkpoint to occur. But then the newer and more powerful &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface was added. This interface is retained for backwards compatibility and as a convenience for applications that need to manually start a callback but which do not need the full power (and corresponding complication) of &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt;.</source>
          <target state="translated">该接口曾经是导致检查点发生的唯一方法。但是随后添加了更新且功能更强大的&lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;接口。保留此接口是为了向后兼容，并且为需要手动启动回调但不需要&lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;的全部功能（以及相应的复杂性）的应用程序提供便利。</target>
        </trans-unit>
        <trans-unit id="f7d4c03d6a4b6a9f5c9aedcc9b701719388f47dd" translate="yes" xml:space="preserve">
          <source>This interfaces opens a &lt;a href=&quot;#sqlite3_blob&quot;&gt;handle&lt;/a&gt; to the BLOB located in row iRow, column zColumn, table zTable in database zDb; in other words, the same BLOB that would be selected by:</source>
          <target state="translated">该接口为位于数据库zDb中的iRow行，zColumn列，zTable表中的BLOB 打开&lt;a href=&quot;#sqlite3_blob&quot;&gt;句柄&lt;/a&gt;；换句话说，将通过以下方式选择相同的BLOB：</target>
        </trans-unit>
        <trans-unit id="d56bad6a2645b8e7253284f59e7a63eae875fa74" translate="yes" xml:space="preserve">
          <source>This interfaces opens a &lt;a href=&quot;blob&quot;&gt;handle&lt;/a&gt; to the BLOB located in row iRow, column zColumn, table zTable in database zDb; in other words, the same BLOB that would be selected by:</source>
          <target state="translated">该接口为位于数据库zDb中的iRow行，zColumn列，zTable表中的BLOB 打开&lt;a href=&quot;blob&quot;&gt;句柄&lt;/a&gt;；换句话说，将通过以下方式选择相同的BLOB：</target>
        </trans-unit>
        <trans-unit id="13a6b9699070bd3ee5f0499a2e1cddf56e4de906" translate="yes" xml:space="preserve">
          <source>This is a convenience method. It saves the user from having to do a &quot;&lt;code&gt;[lindex ... 0]&lt;/code&gt;&quot; on the results of an &quot;eval&quot; in order to extract a single column result.</source>
          <target state="translated">这是一种方便的方法。它使用户不必为了提取单列结果而对&amp;ldquo; eval&amp;rdquo;的结果执行&amp;ldquo; &lt;code&gt;[lindex ... 0]&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="38e166d44e718495aa683d7ad0a1c631f4c6b59a" translate="yes" xml:space="preserve">
          <source>This is a deferred seek. Nothing actually happens until the cursor is used to read a record. That way, if no reads occur, no unnecessary I/O happens.</source>
          <target state="translated">这是一个延迟查找。在使用游标读取记录之前,实际上什么都没有发生。这样一来,如果没有发生读取,就不会发生不必要的I/O。</target>
        </trans-unit>
        <trans-unit id="2382322bd7fe40fc2a51108a576a294144a75f00" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of the &lt;a href=&quot;#sqlite3_hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface. This routine is provided for historical compatibility only. All new applications should use the &lt;a href=&quot;#sqlite3_hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface rather than this one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3322a19f5183f0c0a12dac751f8fe80d74d2317" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of the &lt;a href=&quot;#sqlite3_soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface. This routine is provided for historical compatibility only. All new applications should use the &lt;a href=&quot;#sqlite3_soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface rather than this one.</source>
          <target state="translated">这是&lt;a href=&quot;#sqlite3_soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64（）&lt;/a&gt;接口的不推荐使用的版本。提供此例程仅出于历史兼容性。所有新应用程序都应使用&lt;a href=&quot;#sqlite3_soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64（）&lt;/a&gt;接口，而不要使用此接口。</target>
        </trans-unit>
        <trans-unit id="549ad021f1f25c6ff9bbe6ad516bdc1aab2d979c" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of the &lt;a href=&quot;hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface. This routine is provided for historical compatibility only. All new applications should use the &lt;a href=&quot;hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface rather than this one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83b5b2c4751d7d27636c7987b515f0e77b9f539e" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of the &lt;a href=&quot;soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface. This routine is provided for historical compatibility only. All new applications should use the &lt;a href=&quot;soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface rather than this one.</source>
          <target state="translated">这是&lt;a href=&quot;soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64（）&lt;/a&gt;接口的不推荐使用的版本。提供此例程仅出于历史兼容性。所有新应用程序都应使用&lt;a href=&quot;soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64（）&lt;/a&gt;接口，而不要使用此接口。</target>
        </trans-unit>
        <trans-unit id="3265de0d01aec05a2acca7ad5cf1ffeadb61ea03" translate="yes" xml:space="preserve">
          <source>This is a feature, not a bug. SQLite uses &lt;a href=&quot;datatype3&quot;&gt;dynamic typing&lt;/a&gt;. It does not enforce data type constraints. Data of any type can (usually) be inserted into any column. You can put arbitrary length strings into integer columns, floating point numbers in boolean columns, or dates in character columns. The &lt;a href=&quot;datatype3&quot;&gt;datatype&lt;/a&gt; you assign to a column in the CREATE TABLE command does not restrict what data can be put into that column. Every column is able to hold an arbitrary length string. (There is one exception: Columns of type &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; may only hold a 64-bit signed integer. An error will result if you try to put anything other than an integer into an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column.)</source>
          <target state="translated">这是一个功能，而不是错误。 SQLite使用&lt;a href=&quot;datatype3&quot;&gt;动态类型&lt;/a&gt;。它不强制执行数据类型约束。任何类型的数据都可以（通常）插入任何列中。您可以将任意长度的字符串放入整数列，布尔列中的浮点数或字符列中的日期。您在CREATE TABLE命令中分配给列的&lt;a href=&quot;datatype3&quot;&gt;数据类型&lt;/a&gt;不限制可以在该列中放入哪些数据。每列都可以容纳任意长度的字符串。 （有一个例外：&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;类型的列只能包含一个64位带符号整数。如果尝试将一个整数以外的任何内容放入&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列，则会导致错误。）</target>
        </trans-unit>
        <trans-unit id="5c1fa1ef2dde20cd88e16281d01dfa503bb7906f" translate="yes" xml:space="preserve">
          <source>This is a function with powerful side-effects. Most programmers would be naturally cautious about using it, but probably would not see the harm in merely having it available. But there is great risk in merely defining such a function, even if the application itself never invokes it!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7d02094df3f3fda475c3c0669d010669d55439e" translate="yes" xml:space="preserve">
          <source>This is a legacy interface that is preserved for backwards compatibility. Use of this interface is not recommended.</source>
          <target state="translated">这是一个传统的接口,为了向后兼容而保留下来。不建议使用该接口。</target>
        </trans-unit>
        <trans-unit id="5f257f6218e523212322ebfdf81d8c0135554419" translate="yes" xml:space="preserve">
          <source>This is a limitation of the R-Tree extension only. Ordinary tables in SQLite are able to read and write at the same time. Other virtual tables might (or might not) also that capability. And R-Tree can appear to read and write at the same time in some circumstances, if it can figure out how to reliably run the query to completion before starting the update. But you shouldn't count on that for every query. Generally speaking, it is best to avoid running queries and updates to the same R-Tree at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d61b35431e03f12c702f21bbd7e7a511e4a6548" translate="yes" xml:space="preserve">
          <source>This is a maintenance release only. Various minor bugs have been fixed and some portability enhancements are added.</source>
          <target state="translated">这只是一个维护版本。修复了各种小错误,并增加了一些可移植性的改进。</target>
        </trans-unit>
        <trans-unit id="899c3e8633e96cd6aefa72bc202abc232fd0022d" translate="yes" xml:space="preserve">
          <source>This is an edit distance or Levenshtein distance going from the pattern to the word.</source>
          <target state="translated">这是一个从图案到单词的编辑距离或莱文什丁距离。</target>
        </trans-unit>
        <trans-unit id="910e8aa32c8839104ce5280b502b0fcc013f6738" translate="yes" xml:space="preserve">
          <source>This is an optimized version of &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt; that works only for integer values.</source>
          <target state="translated">这是&lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt;的优化版本，仅适用于整数值。</target>
        </trans-unit>
        <trans-unit id="801748b6bec70348d36bd30ab9aa7d8d99ebf0cc" translate="yes" xml:space="preserve">
          <source>This is done by using the file locking facilities provided by the VFS adaptor to serialize writers (write transactions) and preventing readers (read transactions) from accessing database files while writers are midway through updating them.</source>
          <target state="translated">这是通过使用VFS适配器提供的文件锁定设施来实现的,它可以将写入者(写事务)序列化,并防止读取者(读事务)在写入者更新数据库文件的中途访问数据库文件。</target>
        </trans-unit>
        <trans-unit id="8da36cedfb4232a176b408433fde7c4fd7207c97" translate="yes" xml:space="preserve">
          <source>This is not a trivial point. A clear, concise, and easy to understand file format is a crucial part of any application design. Fred Brooks, in his all-time best-selling computer science text,</source>
          <target state="translated">这不是一个小问题。一个清晰、简明、易懂的文件格式是任何应用程序设计的关键部分。弗雷德-布鲁克斯在他的历史上最畅销的计算机科学文本中:</target>
        </trans-unit>
        <trans-unit id="1c13d43de084b1c54ea28d7db810dbdc504863cc" translate="yes" xml:space="preserve">
          <source>This is not to say that CVEs are useless. CVEs do still (mostly) report actual bugs. But in most cases the bugs are not true vulnerabilities, in the sense that they do not contribute to data loss or compromise in and of themselves. It is good that bugs are reported and fixed. But not every bug is accessible from every application. In the case of SQLite, most of the bugs reported by CVEs are inaccessible in most applications. Upgrading to the latest version of SQLite is always a good plan, but it need not be an emergency just because an anonymous grey-hat on the internet wrote up a CVE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71f131e03503ae5c8b8ced0f182cb10a7090642b" translate="yes" xml:space="preserve">
          <source>This is not valid SQL because of the apostrophe in the word &quot;y'all&quot;. But if the %q formatting option is used instead of %s, like this:</source>
          <target state="translated">这不是有效的SQL,因为 &quot;y'all &quot;一词中的撇号。但如果用%q格式选项代替%s,就像这样。</target>
        </trans-unit>
        <trans-unit id="b10e12e9a12481ea13f1cbdd991de65338cc882f" translate="yes" xml:space="preserve">
          <source>This is the &quot;alternate-form-1&quot; flag. For %g and %G substitutions, this causes trailing zeros to be removed. This flag forces a decimal point to appear for all floating-point substitutions. For %o, %x, and %X substitutions, the alternate-form-1 flag cause the value to be prepended with &quot;0&quot;, &quot;0x&quot;, or &quot;0X&quot;, respectively.</source>
          <target state="translated">这是 &quot;交替形式-1 &quot;标志。对于%g和%G的替换,会导致去掉尾部的零。这个标志使得所有浮点替换都会出现一个小数点。对于%o、%x和%X的替换,交替形式-1标志分别使数值以 &quot;0&quot;、&quot;0x &quot;或 &quot;0X &quot;开头。</target>
        </trans-unit>
        <trans-unit id="63cb4b6d9fe02ab2deb206f8aa9f5671d078c8f3" translate="yes" xml:space="preserve">
          <source>This is the &quot;alternate-form-2 flag. For string substitutions, this flag causes the width and precision to be understand in terms of characters rather than bytes. For floating point substitutions, the alternate-form-2 flag increases the maximum number of significant digits displayed from 16 to 26, forces the display of the decimal point and causes at least one digit to appear after the decimal point.</source>
          <target state="translated">这就是 &quot;交替形式-2 &quot;标志,对于字符串的替换,这个标志会使宽度和精度以字符而不是以字节来理解。对于字符串替换,这个标志使宽度和精度以字符而不是以字节来理解。对于浮点替换,交替形式-2标志将显示的最大有效数字数从16位增加到26位,强制显示小数点,并使小数点后至少出现一位数字。</target>
        </trans-unit>
        <trans-unit id="bc902c483a7876a1b0deb3582a89dafeb4cea481" translate="yes" xml:space="preserve">
          <source>This is the Quality Management Plan for SQLite.</source>
          <target state="translated">这就是SQLite的质量管理计划。</target>
        </trans-unit>
        <trans-unit id="67d77b8b0173c35f0fc8ffa751afcfc454c71889" translate="yes" xml:space="preserve">
          <source>This is the approximate number of bytes of heap memory used to store the prepared statement. This value is not actually a counter, and so the resetFlg parameter to sqlite3_stmt_status() is ignored when the opcode is SQLITE_STMTSTATUS_MEMUSED.</source>
          <target state="translated">这是用来存储准备好的语句的堆内存的大约字节数。这个值实际上不是一个计数器,所以当操作码为SQLITE_STMTSTATUS_MEMUSED时,sqlite3_stmt_status()的resetFlg参数被忽略。</target>
        </trans-unit>
        <trans-unit id="f5f605b9bb40dfe0763a4e4919a2589f9005f3a1" translate="yes" xml:space="preserve">
          <source>This is the language-id of the word. All queries are against a single language-id, which defaults to 0. For any given query this value is the same on all rows.</source>
          <target state="translated">这是该词的语言标识。对于任何给定的查询,这个值在所有行中都是相同的。</target>
        </trans-unit>
        <trans-unit id="9fdc70ab1d09ee31e6a0831adfe5fa272a3194e2" translate="yes" xml:space="preserve">
          <source>This is the number of rows inserted into transient indices that were created automatically in order to help joins run faster. A non-zero value in this counter may indicate an opportunity to improvement performance by adding permanent indices that do not need to be reinitialized each time the statement is run.</source>
          <target state="translated">这是插入到自动创建的瞬时索引中的行数,这些索引的创建是为了帮助连接运行得更快。这个计数器中的非零值可能表明有机会通过添加永久索引来提高性能,因为永久索引不需要在每次运行语句时重新初始化。</target>
        </trans-unit>
        <trans-unit id="8c5491db23237dd3c1b297335729c93feb9329fe" translate="yes" xml:space="preserve">
          <source>This is the number of sort operations that have occurred. A non-zero value in this counter may indicate an opportunity to improvement performance through careful use of indices.</source>
          <target state="translated">这是已发生的排序操作的次数。该计数器中的非零值可能表明有机会通过谨慎使用指数来提高性能。</target>
        </trans-unit>
        <trans-unit id="f6022b63855545d987e1fb6ed3574f3dde788d4f" translate="yes" xml:space="preserve">
          <source>This is the number of times that SQLite has stepped forward in a table as part of a full table scan. Large numbers for this counter may indicate opportunities for performance improvement through careful use of indices.</source>
          <target state="translated">这是SQLite作为全表扫描的一部分,在表中向前迈进的次数。该计数器的数字越大,表明有机会通过谨慎使用索引来提高性能。</target>
        </trans-unit>
        <trans-unit id="2e2d5cd35f18306585fb3833a8437cb1c68463de" translate="yes" xml:space="preserve">
          <source>This is the number of times that the prepare statement has been automatically regenerated due to schema changes or change to &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; that might affect the query plan.</source>
          <target state="translated">这是由于架构更改或更改&lt;a href=&quot;../lang_expr#varparam&quot;&gt;绑定参数&lt;/a&gt;（可能影响查询计划）而自动重新生成prepare语句的次数。</target>
        </trans-unit>
        <trans-unit id="89a19ef4023707e912e6bb81167cc9edbf3dbf2a" translate="yes" xml:space="preserve">
          <source>This is the number of times that the prepare statement has been automatically regenerated due to schema changes or change to &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; that might affect the query plan.</source>
          <target state="translated">这是由于架构更改或更改&lt;a href=&quot;lang_expr#varparam&quot;&gt;绑定参数&lt;/a&gt;（可能影响查询计划）而自动重新生成prepare语句的次数。</target>
        </trans-unit>
        <trans-unit id="ad8da654215d27127f1f2f4f4e254bee11f6c200" translate="yes" xml:space="preserve">
          <source>This is the number of times that the prepare statement has been automatically regenerated due to schema changes or changes to &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; that might affect the query plan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b13313031c39949951f19dcc69954d4d1da9fef4" translate="yes" xml:space="preserve">
          <source>This is the number of times that the prepare statement has been automatically regenerated due to schema changes or changes to &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; that might affect the query plan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fb615d618780dfbede44490d9c1ccf7fc81bcec" translate="yes" xml:space="preserve">
          <source>This is the number of times that the prepared statement has been run. A single &quot;run&quot; for the purposes of this counter is one or more calls to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; followed by a call to &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt;. The counter is incremented on the first &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call of each cycle.</source>
          <target state="translated">这是已准备的语句已运行的次数。就此计数器而言，单个&amp;ldquo;运行&amp;rdquo;是对&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）的&lt;/a&gt;一个或多个调用，然后是对&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;的调用。在每个周期的第一个&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;调用中，计数器都会递增。</target>
        </trans-unit>
        <trans-unit id="02a22b1b5a6d045d2732a9c5f17c43be586d3ec0" translate="yes" xml:space="preserve">
          <source>This is the number of times that the prepared statement has been run. A single &quot;run&quot; for the purposes of this counter is one or more calls to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; followed by a call to &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt;. The counter is incremented on the first &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call of each cycle.</source>
          <target state="translated">这是已准备的语句已运行的次数。就此计数器而言，单个&amp;ldquo;运行&amp;rdquo;是对&lt;a href=&quot;step&quot;&gt;sqlite3_step（）的&lt;/a&gt;一个或多个调用，然后是对&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;的调用。在每个周期的第一个&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;调用中，计数器都会递增。</target>
        </trans-unit>
        <trans-unit id="dac86b21d034a44083d19f0648edfd3d6aee1a04" translate="yes" xml:space="preserve">
          <source>This is the number of virtual machine operations executed by the prepared statement if that number is less than or equal to 2147483647. The number of virtual machine operations can be used as a proxy for the total work done by the prepared statement. If the number of virtual machine operations exceeds 2147483647 then the value returned by this statement status code is undefined.</source>
          <target state="translated">这是准备好的语句所执行的虚拟机操作数,如果该数小于或等于2147483647。虚拟机操作数可以作为准备好的语句所做的总工作的代理。如果虚拟机操作数超过2147483647,则该语句状态码返回的值为未定义。</target>
        </trans-unit>
        <trans-unit id="cd780664af2f5e88c09d027911d10ff2fa28ed11" translate="yes" xml:space="preserve">
          <source>This is the query that solves the puzzle:</source>
          <target state="translated">这就是解决难题的查询。</target>
        </trans-unit>
        <trans-unit id="68e28408e53f654e22a7d4b5e13087b011ad015a" translate="yes" xml:space="preserve">
          <source>This is the rank of the word, as specified in the original INSERT statement.</source>
          <target state="translated">这是单词的等级,在原始INSERT语句中指定。</target>
        </trans-unit>
        <trans-unit id="3c347af279705ccb7203ae88698186539d78c1bc" translate="yes" xml:space="preserve">
          <source>This is the same as &quot;&amp;lt;expr&amp;gt; PRECEDING&quot; except that the boundary is &amp;lt;expr&amp;gt; units after the current rather than before the current row.</source>
          <target state="translated">这与&amp;ldquo; &amp;lt;expr&amp;gt; PRECEDING&amp;rdquo;相同，除了边界是当前行之后而不是当前行之前的&amp;lt;expr&amp;gt;个单位。</target>
        </trans-unit>
        <trans-unit id="b5b506e660f5afa226074ab8a993cee25ea85c25" translate="yes" xml:space="preserve">
          <source>This key is then limited to &quot;scope&quot; characters. The default scope value is 4, but an alternative scope can be specified using the &quot;scope=N&quot; term in the WHERE clause. After the key has been truncated, the edit distance is run against every term in the vocabulary that has a k2 value that begins with the abbreviated key.</source>
          <target state="translated">然后这个键被限制在 &quot;范围 &quot;字符。默认的范围值是4,但是可以使用WHERE子句中的 &quot;scope=N &quot;术语指定一个替代范围。在键被截断后,编辑距离将针对词汇表中每一个具有以缩写键开头的k2值的术语运行。</target>
        </trans-unit>
        <trans-unit id="09f3f2089114bd06180ad8313e37ae120cabb71b" translate="yes" xml:space="preserve">
          <source>This kind of problem comes up all the time when dealing with floating point binary numbers. The general rule to remember is that most fractional numbers that have a finite representation in decimal (a.k.a &quot;base-10&quot;) do not have a finite representation in binary (a.k.a &quot;base-2&quot;). And so they are approximated using the closest binary number available. That approximation is usually very close, but it will be slightly off and in some cases can cause your results to be a little different from what you might expect.</source>
          <target state="translated">在处理浮点二进制数时,这种问题经常出现。要记住的一般规则是,大多数小数在十进制(也就是 &quot;base-10&quot;)中都有有限的表示,但在二进制(也就是 &quot;base-2&quot;)中没有有限的表示。因此,它们是用最接近的二进制数来近似表示的。这种近似值通常是非常接近的,但它会稍有偏差,在某些情况下,可能会导致您的结果与您可能期望的略有不同。</target>
        </trans-unit>
        <trans-unit id="a135a2763d0f0112ca15bcc48e7dbab83e04271e" translate="yes" xml:space="preserve">
          <source>This last code will give the following output:</source>
          <target state="translated">最后这段代码将给出以下输出。</target>
        </trans-unit>
        <trans-unit id="47d19850010695a0ad5164e9f6289137fa74e392" translate="yes" xml:space="preserve">
          <source>This later query generates exactly the same &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; as the previous scalar formulation, but using syntax that it cleaner and easier to read.</source>
          <target state="translated">此后一个查询生成与以前的标量公式完全相同的&lt;a href=&quot;opcode&quot;&gt;字节码&lt;/a&gt;，但使用的语法更清晰，更易于阅读。</target>
        </trans-unit>
        <trans-unit id="ee338f99e5b2a8dc89eb5fd7e38f440a68b4f663" translate="yes" xml:space="preserve">
          <source>This limit is only functional if memory usage statistics are available via the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64&lt;/a&gt;(&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;) interfaces. Without that memory usage information, SQLite has no way of knowing when it is about to go over the limit, and thus is unable to prevent the excess memory allocation. Memory usage tracking is turned on by default, but can be disabled at compile-time using the &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; option, or at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;).</source>
          <target state="translated">仅当通过&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;和&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64&lt;/a&gt;（&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;）接口提供内存使用情况统计信息时，此限制才起作用。没有该内存使用信息，SQLite无法知道何时将要超过限制，因此无法防止过多的内存分配。内存使用情况跟踪默认情况下处于打开状态，但可以在编译时使用&lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;选项禁用，也可以在启动时使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;）禁用。</target>
        </trans-unit>
        <trans-unit id="13ca9d3dd4559d964cbe8a24d9fb9dfdfb2e704d" translate="yes" xml:space="preserve">
          <source>This loop does the actual deleting. It is organized differently from the one in the UPDATE example. The ListRead instruction plays the role that the Next did in the INSERT loop, but because it jumps to P2 on failure, and Next jumps on success, we put it at the start of the loop instead of the end. This means that we have to put a Goto at the end of the loop to jump back to the loop test at the beginning. So this loop has the form of a C while(){...} loop, while the loop in the INSERT example had the form of a do{...}while() loop. The Delete instruction fills the role that the callback function did in the preceding examples.</source>
          <target state="translated">这个循环进行实际的删除工作。它的组织结构与UPDATE例子中的循环不同。ListRead指令扮演了Next在INSERT循环中的角色,但是因为它在失败时跳转到P2,而Next在成功时跳转,所以我们把它放在循环的开始而不是结束。这就意味着我们必须在循环的最后放一个Goto,才能跳回开头的循环测试。所以这个循环的形式是C while(){...}循环,而insert例子中的循环的形式是do{...}while()循环。删除指令填补了前面例子中回调函数的作用。</target>
        </trans-unit>
        <trans-unit id="43be1340da3a9e761d1e60e5b0cf2fe23b219f5a" translate="yes" xml:space="preserve">
          <source>This macro determines if SQLite creates databases with the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; flag set by default to OFF (0), FULL (1), or INCREMENTAL (2). The default value is 0 meaning that databases are created with auto-vacuum turned off. In any case the compile-time default may be overridden by the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA auto_vacuum&lt;/a&gt; command.</source>
          <target state="translated">此宏确定SQLite是否创建默认情况下将&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;标志设置为OFF（0），FULL（1）或INCREMENTAL（2）的数据库。默认值为0，表示在关闭自动真空的情况下创建数据库。在任何情况下，&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA auto_vacuum&lt;/a&gt;命令都可以覆盖编译时默认值。</target>
        </trans-unit>
        <trans-unit id="ce1cd413cb1e6bc64251da855027734d62907557" translate="yes" xml:space="preserve">
          <source>This macro determines the default value for the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema&lt;/a&gt; setting. If no alternative is specified, the trusted-schema setting defaults to ON (a value of 1) for legacy compatibility. However, for best security, systems that implement &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; and/or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; should consider changing the default to OFF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="490e529c008d3db9d5367e44a026855e51e6b03f" translate="yes" xml:space="preserve">
          <source>This macro determines the default value of the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting for database files that open in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. If not overridden at compile-time, this value is the same as &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt;.</source>
          <target state="translated">该宏为在&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;打开的数据库文件确定&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt;设置的默认值。如果在编译时未覆盖，则此值与&lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="8336b743e8d9803a85ebb0e91376530edf711cf6" translate="yes" xml:space="preserve">
          <source>This macro determines the default value of the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting. If not overridden at compile-time, the default setting is 2 (FULL).</source>
          <target state="translated">此宏确定&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt;设置的默认值。如果在编译时未覆盖，则默认设置为2（FULL）。</target>
        </trans-unit>
        <trans-unit id="f58f286fe549400b3ffb2a0508013420e777661c" translate="yes" xml:space="preserve">
          <source>This macro determines the default values for &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsddl&quot;&gt;SQLITE_DBCONFIG_DQS_DDL&lt;/a&gt; and &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsdml&quot;&gt;SQLITE_DBCONFIG_DQS_DML&lt;/a&gt;, which in turn how SQLite handles each &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt;. The &quot;DQS&quot; name stands for &quot;&lt;u&gt;D&lt;/u&gt;ouble-&lt;u&gt;Q&lt;/u&gt;uoted &lt;u&gt;S&lt;/u&gt;tring&quot;. The</source>
          <target state="translated">该宏确定&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsddl&quot;&gt;SQLITE_DBCONFIG_DQS_DDL&lt;/a&gt;和&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsdml&quot;&gt;SQLITE_DBCONFIG_DQS_DML&lt;/a&gt;的默认值，这又是SQLite处理每个&lt;a href=&quot;quirks#dblquote&quot;&gt;双引号字符串文字的方式&lt;/a&gt;。在&amp;ldquo;DQS&amp;rdquo;的名字代表&amp;ldquo; &lt;u&gt;d&lt;/u&gt; ouble- &lt;u&gt;Q&lt;/u&gt; uoted &lt;u&gt;小号&lt;/u&gt;特林&amp;rdquo;。的</target>
        </trans-unit>
        <trans-unit id="522e09ca43264c4a7b51fc0648da718f31a48474" translate="yes" xml:space="preserve">
          <source>This macro determines the initial setting for &lt;a href=&quot;pragma#pragma_automatic_index&quot;&gt;PRAGMA automatic_index&lt;/a&gt; for newly opened &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;. For all versions of SQLite through 3.7.17, automatic indices are normally enabled for new database connections if this compile-time option is omitted. However, that might change in future releases of SQLite.</source>
          <target state="translated">该宏为新打开的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;确定&lt;a href=&quot;pragma#pragma_automatic_index&quot;&gt;PRAGMA automatic_index&lt;/a&gt;的初始设置。对于SQLite 3.7.17之前的所有版本，如果省略了编译时选项，通常都会为新的数据库连接启用自动索引。但是，这可能会在将来的SQLite版本中发生变化。</target>
        </trans-unit>
        <trans-unit id="5fa0389d41296c7a84b787e330c502e72d66ebe7" translate="yes" xml:space="preserve">
          <source>This macro determines the number of pages initially allocated by the page cache module when &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; configuration option is not use and memory for the page cache is obtained from &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; instead. The number of pages set by this macro are allocated in a single allocation, which reduces the load on the memory allocator.</source>
          <target state="translated">当不使用&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;配置选项并且从&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;获取用于页面高速缓存的内存时，此宏确定页面高速缓存模块最初分配的页面数。该宏设置的页面数在单个分配中分配，这减少了内存分配器上的负载。</target>
        </trans-unit>
        <trans-unit id="559bc66ac71c6e41021ef2b91f75b46c2b3b9325" translate="yes" xml:space="preserve">
          <source>This macro determines whether enforcement of &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; is enabled or disabled by default for new database connections. Each database connection can always turn enforcement of foreign key constraints on and off and run-time using the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;foreign_keys pragma&lt;/a&gt;. Enforcement of foreign key constraints is normally off by default, but if this compile-time parameter is set to 1, enforcement of foreign key constraints will be on by default.</source>
          <target state="translated">该宏确定默认情况下对新数据库连接是启用还是禁用&lt;a href=&quot;foreignkeys&quot;&gt;外键约束的&lt;/a&gt;实施。每个数据库连接都可以使用&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;foreign_keys pragma&lt;/a&gt;始终打开和关闭外键约束以及在运行时强制实施。通常，默认情况下，外键约束的实施通常是关闭的，但是如果将此编译时参数设置为1，则默认情况下，外键约束的实施将是启用的。</target>
        </trans-unit>
        <trans-unit id="226608496184b7fdf2d8299d14ed30387d3f4541" translate="yes" xml:space="preserve">
          <source>This macro identifies an externally visible interface for SQLite. This macro is sometimes set to &quot;extern&quot;. But the definition is compiler-specific.</source>
          <target state="translated">这个宏标识SQLite的外部可见接口。这个宏有时被设置为 &quot;extern&quot;。但是这个定义是针对编译器的。</target>
        </trans-unit>
        <trans-unit id="0de6453c343098370301ec003932dc6266aca99a" translate="yes" xml:space="preserve">
          <source>This macro identifies the calling convention used by operating system interfaces for target the platform for an SQLite build. This macro is normally defined to be nothing, though on Windows builds it can sometimes be set to &quot;__stdcall&quot;.</source>
          <target state="translated">这个宏标识了操作系统接口对SQLite构建的目标平台所使用的调用约定。这个宏通常被定义为 &quot;无&quot;,不过在Windows构建中,它有时会被设置为&quot;__stdcall&quot;。</target>
        </trans-unit>
        <trans-unit id="9b44c726a2553acb75e5ed795a28d472290ceb29" translate="yes" xml:space="preserve">
          <source>This macro identifies the calling convention used by public interface routines in SQLite. This macro is normally defined to be nothing, though on Windows builds it can sometimes be set to &quot;__cdecl&quot; or &quot;__stdcall&quot;. The &quot;__cdecl&quot; setting is the default, but &quot;__stdcall&quot; is used when SQLite is intended to be compiled as a Windows system library.</source>
          <target state="translated">这个宏标识了SQLite中公共接口例程的调用惯例。这个宏通常被定义为 &quot;无&quot;,尽管在Windows的构建中,它有时会被设置为&quot;__cdecl &quot;或&quot;__stdcall&quot;。&quot;__cdecl &quot;的设置是默认的,但是当SQLite打算被编译成Windows系统库时,会使用&quot;__stdcall&quot;。</target>
        </trans-unit>
        <trans-unit id="b1a94429c7fe64a39ff03aac291075f1fc53f3f7" translate="yes" xml:space="preserve">
          <source>This macro is used to determine whether or not the features enabled and disabled using the SQLITE_CONFIG_MEMSTATUS argument to &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; are available by default. The default value is 1 (&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; related features enabled).</source>
          <target state="translated">此宏用于确定默认情况下使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;的SQLITE_CONFIG_MEMSTATUS参数启用和禁用的功能是否可用。默认值为1（启用了&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;相关功能）。</target>
        </trans-unit>
        <trans-unit id="6f913dad07b84381374f393818e5b17603014056" translate="yes" xml:space="preserve">
          <source>This macro is used to omit support for UTF16 text encoding. When this is defined all API functions that return or accept UTF16 encoded text are unavailable. These functions can be identified by the fact that they end with '16', for example &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_text16()&lt;/a&gt; and &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_text16()&lt;/a&gt;.</source>
          <target state="translated">此宏用于省略对UTF16文本编码的支持。定义此属性后，返回或接受UTF16编码文本的所有API函数均不可用。这些函数可以通过以'16'结尾的事实来标识，例如&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16（）&lt;/a&gt;，&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_text16（）&lt;/a&gt;和&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_text16（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="345c1823c22673f2e2116c52a9629c25f967676c" translate="yes" xml:space="preserve">
          <source>This macro is used to set the default page-size used when a database is created. The value assigned must be a power of 2. The default value is 4096. The compile-time default may be overridden at runtime by the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; command.</source>
          <target state="translated">此宏用于设置创建数据库时使用的默认页面大小。分配的值必须为2的幂。默认值为4096。在运行时，&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt;命令可以覆盖编译时的默认值。</target>
        </trans-unit>
        <trans-unit id="7c4d127d6e65cd3ab45a035f901ed93fb97bfdbf" translate="yes" xml:space="preserve">
          <source>This macro may not be used in combination with any of &lt;a href=&quot;compile#apicall&quot;&gt;SQLITE_APICALL&lt;/a&gt;, &lt;a href=&quot;compile#callback&quot;&gt;SQLITE_CALLBACK&lt;/a&gt;, &lt;a href=&quot;compile#cdecl&quot;&gt;SQLITE_CDECL&lt;/a&gt;, or &lt;a href=&quot;compile#syscall&quot;&gt;SQLITE_SYSCALL&lt;/a&gt;.</source>
          <target state="translated">此宏不得与&lt;a href=&quot;compile#apicall&quot;&gt;SQLITE_APICALL&lt;/a&gt;，&lt;a href=&quot;compile#callback&quot;&gt;SQLITE_CALLBACK&lt;/a&gt;，&lt;a href=&quot;compile#cdecl&quot;&gt;SQLITE_CDECL&lt;/a&gt;或&lt;a href=&quot;compile#syscall&quot;&gt;SQLITE_SYSCALL结合使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="419ea570d98b36b74bab8426d78c04933a0304df" translate="yes" xml:space="preserve">
          <source>This macro sets a hard upper bound on the amount of address space that can be used by any single database for memory-mapped I/O. Setting this value to 0 completely disables memory-mapped I/O and causes logic associated with memory-mapped I/O to be omitted from the build. This option does change the default memory-mapped I/O address space size (set by &lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt; or sqlite3_config(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;) or the run-time memory-mapped I/O address space size (set by sqlite3_file_control(&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt;) or &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;) as long as those other settings are less than the maximum value defined here.</source>
          <target state="translated">此宏为任何单个数据库可用于内存映射I / O的地址空间量设置了硬上限。将此值设置为0将完全禁用内存映射的I / O，并使与内存映射的I / O相关的逻辑从构建中省略。此选项确实改变默认的存储器映射I / O地址空间的大小（设置由&lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt;或sqlite3_config（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;）或运行时间存储器映射I / O地址空间的大小（一套由sqlite3_file_control（&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt;）或&lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;）作为只要其他设置小于此处定义的最大值。</target>
        </trans-unit>
        <trans-unit id="145e78ac1776ccd32943f854f10f2f9b0fb6393c" translate="yes" xml:space="preserve">
          <source>This macro sets the default limit on the amount of memory that will be used for memory-mapped I/O for each open database file. If the</source>
          <target state="translated">这个宏设置了每个打开的数据库文件用于内存映射I/O的内存量的默认限制。如果</target>
        </trans-unit>
        <trans-unit id="6ae2df8a2127ec82caea89871c84ffb977c2588f" translate="yes" xml:space="preserve">
          <source>This macro sets the default maximum size of the page-cache for each attached database. A positive value means that the limit is N page. If N is negative that means to limit the cache size to -N*1024 bytes. The suggested maximum cache size can be overridden by the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; command. The default value is -2000, which translates into a maximum of 2048000 bytes per cache.</source>
          <target state="translated">该宏为每个连接的数据库设置页面高速缓存的默认最大大小。正值表示限制为N页。如果N为负，则意味着将缓存大小限制为-N * 1024字节。建议的最大高速缓存大小可以被&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt;命令覆盖。缺省值为-2000，这表示每个高速缓存最多可转换2048000字节。</target>
        </trans-unit>
        <trans-unit id="069102b338eefceeca656d056762e6d78be6422a" translate="yes" xml:space="preserve">
          <source>This macro sets the default page count for the &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;&lt;a href=&quot;wal#ckpt&quot;&gt;automatic checkpointing&lt;/a&gt; feature. If unspecified, the default page count is 1000.</source>
          <target state="translated">此宏设置&lt;a href=&quot;wal&quot;&gt;WAL &lt;/a&gt;&lt;a href=&quot;wal#ckpt&quot;&gt;自动检查点&lt;/a&gt;功能的默认页数。如果未指定，则默认页数为1000。</target>
        </trans-unit>
        <trans-unit id="40e8768dd2f7f8b92849cd1662a4c1ca65d4e334" translate="yes" xml:space="preserve">
          <source>This macro sets the default value for the &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt; parameter. The &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt; parameter sets the maximum number of auxiliary threads that a single &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; will launch to assist it with a query. If not specified, the default maximum is 0. The value set here cannot be more than &lt;a href=&quot;compile#max_worker_threads&quot;&gt;SQLITE_MAX_WORKER_THREADS&lt;/a&gt;.</source>
          <target state="translated">此宏设置&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt;参数的默认值。该&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt;参数设置一个辅助线程的最大数量&lt;a href=&quot;c3ref/stmt&quot;&gt;准备的语句&lt;/a&gt;将推出与查询，以帮助它。如果未指定，则默认最大值为0。此处设置的值不能超过&lt;a href=&quot;compile#max_worker_threads&quot;&gt;SQLITE_MAX_WORKER_THREADS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f1a3a8e3c666c19a28c715230f239e6dc92f408" translate="yes" xml:space="preserve">
          <source>This macro sets the maximum depth of the LALR(1) stack used by the SQL parser within SQLite. The default value is 100. A typical application will use less than about 20 levels of the stack. Developers whose applications contain SQL statements that need more than 100 LALR(1) stack entries should seriously consider refactoring their SQL as it is likely to be well beyond the ability of any human to comprehend.</source>
          <target state="translated">这个宏设置SQLite中SQL解析器使用的LALR(1)栈的最大深度。默认值是100。一个典型的应用程序将使用少于约20层的堆栈。如果开发人员的应用程序包含的SQL语句需要超过100个LALR(1)堆栈条目,应该认真考虑重构他们的SQL,因为它很可能远远超出任何人类的理解能力。</target>
        </trans-unit>
        <trans-unit id="8108e74c0ea6d892451dd561e6365c3c14ad84ce" translate="yes" xml:space="preserve">
          <source>This macro sets the maximum depth of the search tree that corresponds to the right-hand side of the MATCH operator in an &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; or &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; full-text index. The full-text search uses a recursive algorithm, so the depth of the tree is limited to prevent using too much stack space. The default limit is 12. This limit is sufficient for up to 4095 search terms on the right-hand side of the MATCH operator and it holds stack space usage to less than 2000 bytes.</source>
          <target state="translated">此宏设置&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;或&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;全文索引中与MATCH运算符右侧相对应的搜索树的最大深度。全文搜索使用递归算法，因此限制了树的深度，以防止使用过多的堆栈空间。默认限制为12。此限制足以匹配MATCH运算符右侧的4095个搜索词，并且它使堆栈空间使用量少于2000个字节。</target>
        </trans-unit>
        <trans-unit id="3f15f1a968a26e30aa2768ccc2b2f950c4faa629" translate="yes" xml:space="preserve">
          <source>This macro specifies the calling convention used by callback pointers in SQLite. This macro is normally defined to be nothing, though on Windows builds it can sometimes be set to &quot;__cdecl&quot; or &quot;__stdcall&quot;. The &quot;__cdecl&quot; setting is the default, but &quot;__stdcall&quot; is used when SQLite is intended to be compiled as a Windows system library.</source>
          <target state="translated">这个宏指定了SQLite中回调指针的调用约定。这个宏通常被定义为 &quot;无&quot;,尽管在Windows的构建中,它有时会被设置为&quot;__cdecl &quot;或&quot;__stdcall&quot;。&quot;__cdecl &quot;的设置是默认的,但是当SQLite打算被编译成Windows系统库时,会使用&quot;__stdcall&quot;。</target>
        </trans-unit>
        <trans-unit id="2528260ddde8472dd8957f56284dfe7c74c79aa8" translate="yes" xml:space="preserve">
          <source>This macro specifies the calling convention used by the &lt;a href=&quot;http://www.tcl.tk&quot;&gt;TCL&lt;/a&gt; library interface routines. This macro is not used by the SQLite core, but only by the &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; and &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt;. This macro is normally defined to be nothing, though on Windows builds it can sometimes be set to &quot;__cdecl&quot;. This macro is used on TCL library interface routines which are always compiled as __cdecl, even on platforms that prefer to use __stdcall, so this macro should not be set to __stdcall unless the platform as a custom TCL library build that supports __stdcall.</source>
          <target state="translated">该宏指定&lt;a href=&quot;http://www.tcl.tk&quot;&gt;TCL&lt;/a&gt;库接口例程使用的调用约定。 SQLite核心不使用此宏，而&lt;a href=&quot;tclsqlite&quot;&gt;TCL接口&lt;/a&gt;和&lt;a href=&quot;testing#tcl&quot;&gt;TCL测试套件&lt;/a&gt;仅使用此宏。尽管在Windows构建中，有时可以将其设置为&amp;ldquo; __cdecl&amp;rdquo;，但通常将其定义为空。即使在更喜欢使用__stdcall的平台上，该宏也用于始终编译为__cdecl的TCL库接口例程中，因此，除非该平台作为支持__stdcall的自定义TCL库构建平台，否则不应将此宏设置为__stdcall。</target>
        </trans-unit>
        <trans-unit id="bc472ae5f8b8a1fc9f763f0953cf89d622ce1417" translate="yes" xml:space="preserve">
          <source>This macro specifies the calling convention used by varargs interface routines in SQLite. This macro is normally defined to be nothing, though on Windows builds it can sometimes be set to &quot;__cdecl&quot;. This macro is used on varargs routines and so cannot be set to &quot;__stdcall&quot; since the __stdcall calling convention does not support varargs functions.</source>
          <target state="translated">这个宏指定了SQLite中varargs接口例程的调用约定。这个宏通常被定义为 &quot;无&quot;,尽管在Windows的构建中,它有时可以被设置为&quot;__cdecl&quot;。这个宏用于varargs例程,所以不能设置为&quot;__stdcall&quot;,因为__stdcall调用约定不支持varargs函数。</target>
        </trans-unit>
        <trans-unit id="bc36de796d91df2f3c6874f4468e8054d8e3ac3e" translate="yes" xml:space="preserve">
          <source>This major version number X was historically incremented only for large and important changes to the code. What constituted &quot;large and important&quot; was subjective. The 3.6.23 to 3.7.0 change was a result of adding support for &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. The 3.7.17 to 3.8.0 change was a result of rewrite known as the &lt;a href=&quot;queryplanner-ng&quot;&gt;next generation query planner&lt;/a&gt;.</source>
          <target state="translated">从历史上看，主要版本号X仅在对代码进行大而重要的更改时才递增。构成&amp;ldquo;大而重要&amp;rdquo;的是主观的。从3.6.23到3.7.0的更改是添加了对&lt;a href=&quot;wal&quot;&gt;WAL模式的&lt;/a&gt;支持的结果。从3.7.17到3.8.0的更改是重写的结果，被称为&lt;a href=&quot;queryplanner-ng&quot;&gt;下一代查询计划程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5cef14b3410c92f823704c7230a809d3f5116354" translate="yes" xml:space="preserve">
          <source>This may conflict with a remote UPDATE or DELETE. If it conflicts with a DELETE, and the conflict resolution was OMIT, then the update is changed into an INSERT. Any undefined values in the new.* record from the update change are filled in using the old.* values from the conflicting DELETE. Or, if the conflict resolution was REPLACE, the UPDATE change is simply omitted from the rebased changeset.</source>
          <target state="translated">这可能与远程的UPDATE或DELETE冲突。如果它与DELETE冲突,并且冲突的解决方式是OMIT,那么更新就会被改为INSERT。任何来自更新更改的new.*记录中的未定义值都会使用冲突的DELETE中的old.*值来填充。或者,如果冲突的解决方式是REPLACE,那么UPDATE更改就会从重新建立的更改集中被简单地省略掉。</target>
        </trans-unit>
        <trans-unit id="250cc754fd71fa455b1171906aaea6df74adc895" translate="yes" xml:space="preserve">
          <source>This may conflict with a remote UPDATE or DELETE. In both cases the only possible resolution is OMIT. If the remote operation was a DELETE, then add no change to the rebased changeset. If the remote operation was an UPDATE, then the old.* fields of change are updated to reflect the new.* values in the UPDATE.</source>
          <target state="translated">这可能与远程UPDATE或DELETE冲突。在这两种情况下,唯一可能的解决方法是OMIT。如果远程操作是DELETE,那么就不添加任何变化到重新建立的变化集。如果远程操作是UPDATE,那么改变的旧.*字段将被更新以反映UPDATE中的新.*值。</target>
        </trans-unit>
        <trans-unit id="8d5037a58507a3656fe5eded6e14400ea7347e50" translate="yes" xml:space="preserve">
          <source>This may only conflict with a remote INSERT. If the conflict resolution was OMIT, then add an UPDATE change to the rebased changeset. Or, if the conflict resolution was REPLACE, add nothing to the rebased changeset.</source>
          <target state="translated">这可能只与远程INSERT冲突。如果冲突的解决方法是OMIT,那么就在重新建立的变更集中添加一个UPDATE变更。或者,如果冲突的解决方法是REPLACE,那么就不给重新建立的变更集添加任何内容。</target>
        </trans-unit>
        <trans-unit id="e86988ffb57c2ce2d0a24b3ed45d3fc0cd35e72c" translate="yes" xml:space="preserve">
          <source>This means that SQLite transactions are not atomic across multiple database files on a power-loss when the database files have synchronous turned off or when they are using journal modes of OFF, MEMORY, or WAL. For synchronous OFF and for journal_modes OFF and MEMORY, database will usually corrupt if a transaction commit is interrupted by a power loss. For &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, individual database files are updated atomically across a power-loss, but in the case of a multi-file transactions, some files might rollback while others roll forward after power is restored.</source>
          <target state="translated">这意味着当数据库文件已同步关闭或使用OFF，MEMORY或WAL日志模式时，断电时多个数据库文件之间的SQLite事务不是原子的。对于同步OFF以及对于journal_modes OFF和MEMORY，如果断电中断事务提交，则数据库通常会损坏。对于&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;，单个数据库文件会在断电时自动更新，但是在多文件事务的情况下，某些文件可能会回滚，而其他文件在恢复电源后会回滚。</target>
        </trans-unit>
        <trans-unit id="c4d263eb72d44481bc6aecfbc23e6defa0aa1498" translate="yes" xml:space="preserve">
          <source>This means that actions that occur during sqlite3_prepare() are unaffected by EXPLAIN.</source>
          <target state="translated">这意味着在sqlite3_prepare()期间发生的操作不会受到EXPLAIN的影响。</target>
        </trans-unit>
        <trans-unit id="607b25be39beb5f9bef58cd8962c20567dd55554" translate="yes" xml:space="preserve">
          <source>This means that for many common cases where the temporary tables and indices are small (small enough to fit into the page cache) no temporary files are created and no disk I/O occurs. Only when the temporary data becomes too large to fit in RAM does the information spill to disk.</source>
          <target state="translated">这意味着对于许多常见的情况,临时表和索引很小(小到可以放入页面缓存),不会创建临时文件,也不会发生磁盘I/O。只有当临时数据变得太大而无法放入RAM时,信息才会溢出到磁盘。</target>
        </trans-unit>
        <trans-unit id="593fad237e8d234622c2a00c4634885f5c48bfa8" translate="yes" xml:space="preserve">
          <source>This means that if the changes() SQL function (or similar) is used by the first INSERT, UPDATE or DELETE statement within a trigger, it returns the value as set when the calling statement began executing. If it is used by the second or subsequent such statement within a trigger program, the value returned reflects the number of rows modified by the previous INSERT, UPDATE or DELETE statement within the same trigger.</source>
          <target state="translated">这意味着,如果一个触发器中的第一个INSERT、UPDATE或DELETE语句使用了changes()SQL函数(或类似的函数),那么它将返回调用语句开始执行时设置的值。如果它被触发器程序中的第二条或后续的此类语句使用,那么返回的值反映了同一触发器中被前一条INSERT、UPDATE或DELETE语句修改的行数。</target>
        </trans-unit>
        <trans-unit id="47de8d4e850286135f1da838b319021d7542c6e4" translate="yes" xml:space="preserve">
          <source>This means that in order to keep an FTS in sync with an external content table, any UPDATE or DELETE operations must be applied first to the FTS table, and then to the external content table. For example:</source>
          <target state="translated">这意味着,为了使FTS与外部内容表保持同步,任何UPDATE或DELETE操作必须首先应用于FTS表,然后应用于外部内容表。例如</target>
        </trans-unit>
        <trans-unit id="e5987b4f32ba7f13fcab7f6d474b93f549e8b5dd" translate="yes" xml:space="preserve">
          <source>This means that you should always call sqlite3_column_bytes() or sqlite3_column_bytes16() &lt;u&gt;before&lt;/u&gt; calling sqlite3_column_blob(), sqlite3_column_text(), or sqlite3_column_text16().</source>
          <target state="translated">这意味着您应始终&lt;u&gt;在&lt;/u&gt;调用sqlite3_column_blob（），sqlite3_column_text（）或sqlite3_column_text16（）&lt;u&gt;之前&lt;/u&gt;调用sqlite3_column_bytes（）或sqlite3_column_bytes16（）。</target>
        </trans-unit>
        <trans-unit id="a800932549bc1585500113c923ee38830d5bf518" translate="yes" xml:space="preserve">
          <source>This means, amongst other things, that if a row is inserted and then later deleted while a session object is active, neither the insert nor the delete will be present in the changeset. Or if a row is deleted and then later a row with the same primary key values inserted while a session object is active, the resulting changeset will contain an UPDATE change instead of a DELETE and an INSERT.</source>
          <target state="translated">这意味着,除其他外,如果一条记录被插入,然后在会话对象处于活动状态时被删除,那么插入和删除都不会出现在变化集中。或者说,如果一条记录被删除,然后在会话对象处于活动状态时插入了一条具有相同主键值的记录,那么所产生的变化集将包含UPDATE变化,而不是DELETE和INSERT。</target>
        </trans-unit>
        <trans-unit id="a00a0b75d114c0d51218afdcfc54870beb085cdd" translate="yes" xml:space="preserve">
          <source>This method begins a search of a virtual table. The first argument is a cursor opened by &lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt;. The next two arguments define a particular search index previously chosen by &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;. The specific meanings of idxNum and idxStr are unimportant as long as xFilter and xBestIndex agree on what that meaning is.</source>
          <target state="translated">此方法开始搜索虚拟表。第一个参数是&lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt;打开的游标。接下来的两个参数定义先前由&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;选择的特定搜索索引。只要xFilter和xBestIndex同意什么含义，idxNum和idxStr的具体含义就不重要了。</target>
        </trans-unit>
        <trans-unit id="834bb1ed541ae4dfe20c9142ebec2a570acf7ecb" translate="yes" xml:space="preserve">
          <source>This method begins a transaction on a virtual table. This is method is optional. The xBegin pointer of &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; may be NULL.</source>
          <target state="translated">此方法在虚拟表上开始事务。这是可选方法。&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt;的xBegin指针可以为NULL。</target>
        </trans-unit>
        <trans-unit id="a08aaa3a7033e43137865bcb5ae5a8fbc061274b" translate="yes" xml:space="preserve">
          <source>This method causes a virtual table transaction to commit. This is method is optional. The xCommit pointer of &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; may be NULL.</source>
          <target state="translated">此方法导致虚拟表事务提交。这是可选方法。&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt;的xCommit指针可以为NULL。</target>
        </trans-unit>
        <trans-unit id="35812c6906eecb5f5456d27817929132fa134b1e" translate="yes" xml:space="preserve">
          <source>This method causes a virtual table transaction to rollback. This is method is optional. The xRollback pointer of &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; may be NULL.</source>
          <target state="translated">此方法导致虚拟表事务回滚。这是可选方法。&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt;的xRollback指针可以为NULL。</target>
        </trans-unit>
        <trans-unit id="34e410d7a2b4537f1e469f9ac830727f0e9a19a0" translate="yes" xml:space="preserve">
          <source>This method is a destructor for a connection to the virtual table. Contrast this method with &lt;a href=&quot;vtab#sqlite3_module.xDestroy&quot;&gt;xDestroy&lt;/a&gt;. The xDestroy is a destructor for the entire virtual table.</source>
          <target state="translated">此方法是与虚拟表的连接的析构函数。将此方法与&lt;a href=&quot;vtab#sqlite3_module.xDestroy&quot;&gt;xDestroy进行&lt;/a&gt;对比。xDestroy是整个虚拟表的析构函数。</target>
        </trans-unit>
        <trans-unit id="fead0fa710dfed08f0c2973066d106e0409882fe" translate="yes" xml:space="preserve">
          <source>This method is always followed by one call to either the &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; or &lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt; method. Virtual table transactions do not nest, so the xBegin method will not be invoked more than once on a single virtual table without an intervening call to either &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; or &lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt;. Multiple calls to other methods can and likely will occur in between the xBegin and the corresponding &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; or &lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt;.</source>
          <target state="translated">始终在此方法之后是对&lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt;或&lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt;方法的一次调用。虚拟表事务不会嵌套，因此在没有对&lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt;或&lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt;进行中间调用的情况下，不会在单个虚拟表上多次调用xBegin方法。在xBegin与对应的&lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt;或&lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt;之间可能会发生对其他方法的多次调用。</target>
        </trans-unit>
        <trans-unit id="83c5d6a9d04d0fa8516ae7c5f17b40f6d4c8afec" translate="yes" xml:space="preserve">
          <source>This method is called during &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; to give the virtual table implementation an opportunity to overload functions. This method may be set to NULL in which case no overloading occurs.</source>
          <target state="translated">在&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;期间调用此方法，以使虚拟表实现有机会重载函数。在没有过载的情况下，可以将此方法设置为NULL。</target>
        </trans-unit>
        <trans-unit id="905580614d4d5c3d75c09c6cba74a2febc0c6255" translate="yes" xml:space="preserve">
          <source>This method is only invoked after call to the &lt;a href=&quot;vtab#xBegin&quot;&gt;xBegin&lt;/a&gt; method and prior to an &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; or &lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt;. In order to implement two-phase commit, the xSync method on all virtual tables is invoked prior to invoking the &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; method on any virtual table. If any of the xSync methods fail, the entire transaction is rolled back.</source>
          <target state="translated">仅在调用&lt;a href=&quot;vtab#xBegin&quot;&gt;xBegin&lt;/a&gt;方法之后，在&lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt;或&lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt;之前调用此方法。为了实现两阶段提交，在调用任何虚拟表上的&lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt;方法之前，将在所有虚拟表上调用xSync方法。如果任何xSync方法失败，则会回滚整个事务。</target>
        </trans-unit>
        <trans-unit id="14ef93018d8fba942c0db9f44fa55460f6e9c76d" translate="yes" xml:space="preserve">
          <source>This method is only required window aggregate functions, not legacy aggregate function implementations. It is invoked to remove a row from the current window. The function arguments, if any, correspond to the row being removed.</source>
          <target state="translated">这个方法只需要窗口聚合函数,而不是传统的聚合函数实现。它被调用来从当前窗口中删除一条记录。函数参数(如果有)与被删除的行相对应。</target>
        </trans-unit>
        <trans-unit id="ce08d539ea8ee34ede5a43f0a8a17d5ea1cf7eda" translate="yes" xml:space="preserve">
          <source>This method is only required window aggregate functions, not legacy aggregate function implementations. It is invoked to return the current value of the aggregate. Unlike xFinal, the implementation should not delete any context.</source>
          <target state="translated">这个方法只需要窗口聚合函数,而不是传统的聚合函数实现。它被调用来返回集合的当前值。与xFinal不同的是,该方法的实现不应该删除任何上下文。</target>
        </trans-unit>
        <trans-unit id="08d8cbadac9e2ea26500ba730130d1d2ea25cffc" translate="yes" xml:space="preserve">
          <source>This method is required by both window aggregate and legacy aggregate function implementations. It is invoked to add a row to the current window. The function arguments, if any, corresponding to the row being added are passed to the implementation of xStep.</source>
          <target state="translated">窗口聚合和传统的聚合函数实现都需要这个方法。它被调用来添加一条记录到当前窗口中。函数参数,如果有的话,对应于被添加的行的参数被传递给xStep的实现。</target>
        </trans-unit>
        <trans-unit id="9dd3404779d40aa0e18784dd6025c6e495214062" translate="yes" xml:space="preserve">
          <source>This method is required by both window aggregate and legacy aggregate function implementations. It is invoked to return the current value of the aggregate (determined by the contents of the current window), and to free any resources allocated by earlier calls to xStep.</source>
          <target state="translated">这个方法是窗口聚合和传统聚合函数实现所需要的,它被调用来返回聚合的当前值(由当前窗口的内容决定),并释放之前调用xStep所分配的任何资源。它被调用来返回集合的当前值(由当前窗口的内容决定),并释放之前调用xStep分配的任何资源。</target>
        </trans-unit>
        <trans-unit id="7eac31ed05b29ccf070b56974e9ebd5c94362b9d" translate="yes" xml:space="preserve">
          <source>This method is used to profile the execution of SQL statements run by the application. The syntax is as follows:</source>
          <target state="translated">该方法用于对应用程序运行的SQL语句的执行情况进行描述。语法如下。</target>
        </trans-unit>
        <trans-unit id="9ee8409951c2f3bc2e8906346a5b0b0340e5f814" translate="yes" xml:space="preserve">
          <source>This method maps to the &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; C/C++ interface.</source>
          <target state="translated">此方法映射到&lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）&lt;/a&gt; C / C ++接口。</target>
        </trans-unit>
        <trans-unit id="225a540a3967cae27a759b7346927a4c3dd4b89d" translate="yes" xml:space="preserve">
          <source>This method might decide to run a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; either itself or as a subsequent idle callback. Note that SQLite only allows a single WAL hook. By default this single WAL hook is used for the auto-checkpointing. If you set up an explicit WAL hook, then that one WAL hook must ensure that checkpoints are occurring since the auto-checkpointing mechanism will be disabled.</source>
          <target state="translated">此方法可能决定运行&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;本身还是作为后续的空闲回调。请注意，SQLite仅允许单个WAL挂钩。默认情况下，此单个WAL挂钩用于自动检查点。如果设置了显式WAL挂钩，则该WAL挂钩必须确保发生检查点，因为将禁用自动检查点机制。</target>
        </trans-unit>
        <trans-unit id="eb481b19911bf534590dc3a5ac3a0d7a4a0b626e" translate="yes" xml:space="preserve">
          <source>This method must release all resources allocated by the corresponding xOpen call. The routine will not be called again even if it returns an error. The SQLite core will not use the &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; again after it has been closed.</source>
          <target state="translated">此方法必须释放由相应的xOpen调用分配的所有资源。该例程即使返回错误也不会再次被调用。关闭后，SQLite核心将不再使用&lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="055d0207ea9526f8fc1f47ff97e4b9e575a536d0" translate="yes" xml:space="preserve">
          <source>This method must return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if successful, or an sqlite &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if an error occurs.</source>
          <target state="translated">如果成功，此方法必须返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK；&lt;/a&gt;如果发生&lt;a href=&quot;rescode&quot;&gt;错误&lt;/a&gt;，则必须返回sqlite 错误代码。</target>
        </trans-unit>
        <trans-unit id="b41b86554f48d4aba1d771ee8d8fecba032486ca" translate="yes" xml:space="preserve">
          <source>This method only functions if SQLite is compiled with -DSQLITE_ENABLE_DESERIALIZE</source>
          <target state="translated">只有当SQLite编译时使用-DSQLITE_ENABLE_DESERIALIZE时,本方法才会发挥作用。</target>
        </trans-unit>
        <trans-unit id="aca26a9b3273f84c2f90b69b02bbfb9f22a90825" translate="yes" xml:space="preserve">
          <source>This method opens a TCL channel that can be used to read or write into a preexisting BLOB in the database. The syntax is like this:</source>
          <target state="translated">这个方法打开了一个TCL通道,可以用来读取或写入数据库中预先存在的BLOB。语法是这样的。</target>
        </trans-unit>
        <trans-unit id="a7939d2d993e49eddf1cab2881c4166045801fa6" translate="yes" xml:space="preserve">
          <source>This method provides notification that the virtual table implementation that the virtual table will be given a new name. If this method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; then SQLite renames the table. If this method returns an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; then the renaming is prevented.</source>
          <target state="translated">此方法提供通知，通知虚拟表实现将为虚拟表赋予新名称。如果此方法返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK，&lt;/a&gt;则SQLite重命名表。如果此方法返回&lt;a href=&quot;rescode&quot;&gt;错误代码，&lt;/a&gt;则将阻止重命名。</target>
        </trans-unit>
        <trans-unit id="a08efc90f97c033c6f3a136a45c2a7cd6eb3f466" translate="yes" xml:space="preserve">
          <source>This method registers a callback routine that is invoked after transaction commit when the database is in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. Two arguments are appended to the callback command before it is invoked:</source>
          <target state="translated">此方法注册一个回调例程，当数据库处于&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;时，该例程在事务提交后调用。在调用之前，将两个参数附加到回调命令中：</target>
        </trans-unit>
        <trans-unit id="2920f36d10d056ba3578501d280b4d02be0b6e1d" translate="yes" xml:space="preserve">
          <source>This method registers a callback routine that is invoked just before SQLite tries to commit changes to a database. If the callback throws an exception or returns a non-zero result, then the transaction rolls back rather than commit.</source>
          <target state="translated">这个方法注册了一个回调例程,它在SQLite试图提交数据库的变化之前被调用。如果回调抛出一个异常或返回一个非零的结果,那么事务就会回滚而不是提交。</target>
        </trans-unit>
        <trans-unit id="20062984ae0be47aefc8270221280e0e79c3fbe2" translate="yes" xml:space="preserve">
          <source>This method registers a callback routine that is invoked just before SQLite tries to do a rollback. The script argument is run without change.</source>
          <target state="translated">这个方法注册了一个回调例程,在SQLite尝试进行回滚之前被调用。脚本参数在运行时不做任何改变。</target>
        </trans-unit>
        <trans-unit id="b68fa7e92d08c038d817ec9f0f1dc21053a80d3a" translate="yes" xml:space="preserve">
          <source>This method registers a callback routine that is invoked just before each row is modified by an UPDATE, INSERT, or DELETE statement. Four arguments are appended to the callback before it is invoked:</source>
          <target state="translated">这个方法注册了一个回调例程,这个例程在每条记录被UPDATE、INSERT或DELETE语句修改之前被调用。在调用之前,有四个参数被附加到回调程序中。</target>
        </trans-unit>
        <trans-unit id="1de39dc4601511299a305e0af9ade7a304a3c689" translate="yes" xml:space="preserve">
          <source>This method registers a callback routine that is invoked when the SQLite engine needs a particular collating sequence but does not have that collating sequence registered. The callback can register the collating sequence. The callback is invoked with a single parameter which is the name of the needed collating sequence.</source>
          <target state="translated">这个方法注册了一个回调例程,当SQLite引擎需要一个特定的整理序列但没有注册该整理序列时,就会调用这个回调例程。回调可以注册整理序列。回调调用的参数只有一个,就是需要的整理序列的名称。</target>
        </trans-unit>
        <trans-unit id="21ae789dba180ad8c87b4a2a750db64d49f46fa8" translate="yes" xml:space="preserve">
          <source>This method registers a callback that is invoked periodically during query processing. There are two arguments: the number of SQLite virtual machine opcodes between invocations, and the TCL command to invoke. Setting the progress callback to an empty string disables it.</source>
          <target state="translated">这个方法注册一个回调,在查询处理过程中定期调用。有两个参数:调用之间的SQLite虚拟机操作码数,以及要调用的TCL命令。将进度回调设置为空字符串会使其失效。</target>
        </trans-unit>
        <trans-unit id="2dc944f8c7fefbfebd13fd137f3e37227d9d5fa9" translate="yes" xml:space="preserve">
          <source>This method registers new text collating sequences. There are two arguments: the name of the collating sequence and the name of a TCL procedure that implements a comparison function for the collating sequence.</source>
          <target state="translated">这个方法注册新的文本整理序列。有两个参数:整理序列的名称和实现整理序列比较函数的TCL存储过程的名称。</target>
        </trans-unit>
        <trans-unit id="e6fd7472db353bf284142fd5894eee70bc3b8bf2" translate="yes" xml:space="preserve">
          <source>This method releases a connection to a virtual table, just like the &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; method, and it also destroys the underlying table implementation. This method undoes the work of &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;.</source>
          <target state="translated">就像&lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt;方法一样，此方法释放与虚拟表的连接，并且还会破坏基础表的实现。此方法撤消&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;的工作。</target>
        </trans-unit>
        <trans-unit id="ef832304ea34e78e50a8e321fbc11fd1e9032c28" translate="yes" xml:space="preserve">
          <source>This method releases a connection to a virtual table. Only the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object is destroyed. The virtual table is not destroyed and any backing store associated with the virtual table persists. This method undoes the work of &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;.</source>
          <target state="translated">此方法释放到虚拟表的连接。仅&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;对象被破坏。虚拟表不会被销毁，与该虚拟表关联的任何后备存储都将保留。此方法&lt;a href=&quot;vtab#xconnect&quot;&gt;取消xConnect&lt;/a&gt;的工作。</target>
        </trans-unit>
        <trans-unit id="4227ff89f6190deba008640864f1fdb82c90a383" translate="yes" xml:space="preserve">
          <source>This method returns status information from the most recently evaluated SQL statement. The status method takes a single argument which should be either &quot;steps&quot; or &quot;sorts&quot;. If the argument is &quot;steps&quot;, then the method returns the number of full table scan steps that the previous SQL statement evaluated. If the argument is &quot;sorts&quot;, the method returns the number of sort operations. This information can be used to detect queries that are not using indices to speed search or sorting.</source>
          <target state="translated">这个方法返回最近一次评估的SQL语句的状态信息。状态方法需要一个参数,这个参数应该是 &quot;步骤 &quot;或 &quot;排序&quot;。如果参数是 &quot;步骤&quot;,那么方法返回前一条SQL语句所评估的全表扫描步骤数。如果参数是 &quot;sorts&quot;,则该方法返回排序操作的次数。这些信息可以用来检测没有使用索引来加速搜索或排序的查询。</target>
        </trans-unit>
        <trans-unit id="8fc50ec02b1fc52936f33c145dd76c2dbb1165ca" translate="yes" xml:space="preserve">
          <source>This method returns the numeric error code that resulted from the most recent SQLite operation.</source>
          <target state="translated">此方法返回最近一次SQLite操作产生的数字错误代码。</target>
        </trans-unit>
        <trans-unit id="f84b852e58521bbbf0fe6bd6ba3aaa76874ffba2" translate="yes" xml:space="preserve">
          <source>This method should return an integer value that is equivalent to an SQLite error code (usually 0 for SQLITE_OK in the case of success or 1 for SQLITE_ERROR if some error occurs). As in &lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt;, the results of returning an integer that does not correspond to an SQLite error code are undefined. If the value returned by the script cannot be interpreted as an integer value, or if the script throws a Tcl exception, no error is returned to SQLite but a Tcl background-error is raised.</source>
          <target state="translated">此方法应返回一个等于SQLite错误代码的整数值（如果成功，则对于SQLITE_OK通常为0；如果发生某些错误，则对于SQLITE_ERROR通常为1）。与&lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook（）中一样&lt;/a&gt;，返回与SQLite错误代码不对应的整数的结果是不确定的。如果脚本返回的值不能解释为整数值，或者脚本抛出Tcl异常，则不会向SQLite返回任何错误，但会引发Tcl背景错误。</target>
        </trans-unit>
        <trans-unit id="69d817508f731b9a1bddece3df659e773b266409" translate="yes" xml:space="preserve">
          <source>This method signals the start of a two-phase commit on a virtual table. This is method is optional. The xSync pointer of &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; may be NULL.</source>
          <target state="translated">此方法表示在虚拟表上开始两阶段提交。这是可选方法。&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt;的xSync指针可以为NULL。</target>
        </trans-unit>
        <trans-unit id="1be99db4c515118ac04440359b90544a681fa330" translate="yes" xml:space="preserve">
          <source>This method takes a single boolean argument which will turn the extension loading functionality on or off.</source>
          <target state="translated">这个方法需要一个布尔参数,它将开启或关闭扩展加载功能。</target>
        </trans-unit>
        <trans-unit id="6c561fc9f9d18e98c0c786b020b147ec37c718e8" translate="yes" xml:space="preserve">
          <source>This misfeature means that a misspelled double-quoted identifier will be interpreted as a string literal, rather than generating an error. It also lures developers who are new to the SQL language into the bad habit of using double-quoted string literals when they really need to learn to use the correct single-quoted string literal form.</source>
          <target state="translated">这个错误特性意味着拼写错误的双引号标识符将被解释为字符串文字,而不是产生错误。它还会诱使刚接触SQL语言的开发人员养成使用双引号字符串文字的坏习惯,而他们确实需要学习使用正确的单引号字符串文字形式。</target>
        </trans-unit>
        <trans-unit id="a7d7620eee00f67af5794e95b53ed251b900cca6" translate="yes" xml:space="preserve">
          <source>This mode blocks (invokes the &lt;a href=&quot;c3ref/busy_handler&quot;&gt;busy-handler callback&lt;/a&gt;) until there is no database writer and all readers are reading from the most recent database snapshot. It then checkpoints all frames in the log file and syncs the database file. FULL blocks concurrent writers while it is running, but readers can proceed.</source>
          <target state="translated">此模式将阻塞（调用&lt;a href=&quot;c3ref/busy_handler&quot;&gt;busy-handler回调&lt;/a&gt;），直到没有数据库写入器并且所有读取器都从最新的数据库快照读取数据为止。然后，它在日志文件中检查所有帧并同步数据库文件。FULL在运行时阻止并发写入器，但读取器可以继续。</target>
        </trans-unit>
        <trans-unit id="d4d4de2de6eaf1fc63ccde7eca3a1fd81c8366c2" translate="yes" xml:space="preserve">
          <source>This mode blocks (it invokes the &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler callback&lt;/a&gt;) until there is no database writer and all readers are reading from the most recent database snapshot. It then checkpoints all frames in the log file and syncs the database file. This mode blocks new database writers while it is pending, but new database readers are allowed to continue unimpeded.</source>
          <target state="translated">此模式将阻塞（它调用&lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler回调&lt;/a&gt;），直到没有数据库写入器并且所有读取器都从最近的数据库快照读取数据为止。然后，它在日志文件中检查所有帧并同步数据库文件。此模式在挂起时会阻止新的数据库编写器，但允许新的数据库编写器不受阻碍地继续运行。</target>
        </trans-unit>
        <trans-unit id="3cc26aa0e4889928aaca415a8d70e942682adf13" translate="yes" xml:space="preserve">
          <source>This mode blocks (it invokes the &lt;a href=&quot;busy_handler&quot;&gt;busy-handler callback&lt;/a&gt;) until there is no database writer and all readers are reading from the most recent database snapshot. It then checkpoints all frames in the log file and syncs the database file. This mode blocks new database writers while it is pending, but new database readers are allowed to continue unimpeded.</source>
          <target state="translated">此模式将阻塞（它调用&lt;a href=&quot;busy_handler&quot;&gt;busy-handler回调&lt;/a&gt;），直到没有数据库写入器并且所有读取器都从最近的数据库快照读取数据为止。然后，它在日志文件中检查所有帧并同步数据库文件。此模式在挂起时会阻止新的数据库编写器，但允许新的数据库编写器不受阻碍地继续运行。</target>
        </trans-unit>
        <trans-unit id="3564356c049b3cc19954e75da9c3a3e14807a420" translate="yes" xml:space="preserve">
          <source>This mode works the same way as FULL with the addition that after checkpointing the log file it blocks (calls the &lt;a href=&quot;c3ref/busy_handler&quot;&gt;busy-handler callback&lt;/a&gt;) until all readers are finished with the log file. This ensures that the next client to write to the database file restarts the log file from the beginning. RESTART blocks concurrent writers while it is running, but allowed readers to proceed.</source>
          <target state="translated">此模式的功能与FULL相同，不同之处在于，在对日志文件进行检查点之后，它将阻塞（调用&lt;a href=&quot;c3ref/busy_handler&quot;&gt;busy-handler回调&lt;/a&gt;），直到所有读取器都完成了日志文件为止。这样可以确保下一个要写入数据库文件的客户端从头开始重新启动日志文件。RESTART在运行时阻止并发写入器，但允许读取器继续进行。</target>
        </trans-unit>
        <trans-unit id="1fb881e2173a556242d04296f314a6e802d8d176" translate="yes" xml:space="preserve">
          <source>This mode works the same way as RESTART with the addition that the WAL file is truncated to zero bytes upon successful completion.</source>
          <target state="translated">该模式的工作方式与RESTART相同,但在成功完成后,WAL文件将被截断为零字节。</target>
        </trans-unit>
        <trans-unit id="94e1a681e057e0efd19e4f8568beb354e5ca747a" translate="yes" xml:space="preserve">
          <source>This mode works the same way as SQLITE_CHECKPOINT_FULL with the addition that after checkpointing the log file it blocks (calls the &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler callback&lt;/a&gt;) until all readers are reading from the database file only. This ensures that the next writer will restart the log file from the beginning. Like SQLITE_CHECKPOINT_FULL, this mode blocks new database writer attempts while it is pending, but does not impede readers.</source>
          <target state="translated">此模式的工作方式与SQLITE_CHECKPOINT_FULL相同，不同之处在于，在对日志文件进行检查点之后，该模式将阻塞（调用&lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler回调&lt;/a&gt;），直到所有读取器仅从数据库文件读取为止。这样可以确保下一个编写器从头开始重新启动日志文件。与SQLITE_CHECKPOINT_FULL一样，此模式在挂起时会阻止新的数据库编写器尝试，但不会阻止读取器。</target>
        </trans-unit>
        <trans-unit id="2565fbfb38de6ccb4881d6d5b4ff9625664b3e35" translate="yes" xml:space="preserve">
          <source>This mode works the same way as SQLITE_CHECKPOINT_FULL with the addition that after checkpointing the log file it blocks (calls the &lt;a href=&quot;busy_handler&quot;&gt;busy-handler callback&lt;/a&gt;) until all readers are reading from the database file only. This ensures that the next writer will restart the log file from the beginning. Like SQLITE_CHECKPOINT_FULL, this mode blocks new database writer attempts while it is pending, but does not impede readers.</source>
          <target state="translated">此模式的工作方式与SQLITE_CHECKPOINT_FULL相同，不同之处在于，在对日志文件进行检查点之后，该模式将阻塞（调用&lt;a href=&quot;busy_handler&quot;&gt;busy-handler回调&lt;/a&gt;），直到所有读取器仅从数据库文件读取为止。这样可以确保下一个编写器从头开始重新启动日志文件。与SQLITE_CHECKPOINT_FULL一样，此模式在挂起时会阻止新的数据库编写器尝试，但不会阻止读取器。</target>
        </trans-unit>
        <trans-unit id="6553148329df03707f6ea6e001cc2a449f7036e8" translate="yes" xml:space="preserve">
          <source>This mode works the same way as SQLITE_CHECKPOINT_RESTART with the addition that it also truncates the log file to zero bytes just prior to a successful return.</source>
          <target state="translated">该模式的工作方式与SQLITE_CHECKPOINT_RESTART相同,只是在成功返回之前,它还将日志文件截断为零字节。</target>
        </trans-unit>
        <trans-unit id="5e17d751b95d394b7ad8a49ae12b1ba579b3059a" translate="yes" xml:space="preserve">
          <source>This new index can be used to implement a faster algorithm for the original &quot;Price of Peaches&quot; query.</source>
          <target state="translated">这个新的索引可以用来实现原来 &quot;桃子的价格 &quot;查询的更快算法。</target>
        </trans-unit>
        <trans-unit id="f7c2f3e95925f0342ad3f077f1f083b0da69c5fe" translate="yes" xml:space="preserve">
          <source>This new index contains all the columns of the original FruitsForSale table that are used by the query - both the search terms and the output. We call this a &quot;covering index&quot;. Because all of the information needed is in the covering index, SQLite never needs to consult the original table in order to find the price.</source>
          <target state="translated">这个新的索引包含了原始FruitsForSale表的所有列,这些列被查询使用--包括搜索词和输出。我们将其称为 &quot;覆盖索引&quot;。因为所有需要的信息都在覆盖索引中,所以SQLite永远不需要为了查找价格而查阅原表。</target>
        </trans-unit>
        <trans-unit id="acf43845a5ea53f1f00ff4c11a6f5e1b8a8b33d3" translate="yes" xml:space="preserve">
          <source>This next query solves a Sudoku puzzle. The state of the puzzle is defined by an 81-character string formed by reading entries from the puzzle box row by row from left to right and then from top to bottom. Blank squares in the puzzle are denoted by a &quot;.&quot; character. Thus the input string:</source>
          <target state="translated">下一个查询解决了一个数独谜题。谜题的状态由一个81个字符组成的字符串来定义,这个字符串是从谜题框中从左到右,再从上到下逐行读取条目。空格用&quot;.&quot;字符表示。因此,输入的字符串。</target>
        </trans-unit>
        <trans-unit id="68714059b3f9385751b77bf5e71ea40721ded156" translate="yes" xml:space="preserve">
          <source>This object is used in only one place in the SQLite interface. A pointer to an instance of this object is the argument to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; when the configuration option is &lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; or &lt;a href=&quot;#sqliteconfiggetmalloc&quot;&gt;SQLITE_CONFIG_GETMALLOC&lt;/a&gt;. By creating an instance of this object and passing it to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;) during configuration, an application can specify an alternative memory allocation subsystem for SQLite to use for all of its dynamic memory needs.</source>
          <target state="translated">该对象仅在SQLite界面的一个位置使用。当配置选项为&lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;或&lt;a href=&quot;#sqliteconfiggetmalloc&quot;&gt;SQLITE_CONFIG_GETMALLOC&lt;/a&gt;时，指向此对象实例的指针是&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;的参数。通过在配置过程中创建此对象的实例并将其传递给&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;），应用程序可以为SQLite指定备用内存分配子系统，以用于其所有动态内存需求。</target>
        </trans-unit>
        <trans-unit id="3560b833b5836cc3d10c63801ce7146372dee16e" translate="yes" xml:space="preserve">
          <source>This object is used in only one place in the SQLite interface. A pointer to an instance of this object is the argument to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; when the configuration option is &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; or &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiggetmalloc&quot;&gt;SQLITE_CONFIG_GETMALLOC&lt;/a&gt;. By creating an instance of this object and passing it to &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;) during configuration, an application can specify an alternative memory allocation subsystem for SQLite to use for all of its dynamic memory needs.</source>
          <target state="translated">该对象仅在SQLite界面的一个位置使用。当配置选项为&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;或&lt;a href=&quot;c_config_covering_index_scan#sqliteconfiggetmalloc&quot;&gt;SQLITE_CONFIG_GETMALLOC&lt;/a&gt;时，指向此对象实例的指针是&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;的参数。通过在配置过程中创建此对象的实例并将其传递给&lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;），应用程序可以为SQLite指定备用内存分配子系统，以用于其所有动态内存需求。</target>
        </trans-unit>
        <trans-unit id="1882a6d3fc0a0bded1e433917173d1858c24f074" translate="yes" xml:space="preserve">
          <source>This only works when compiled with &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;.</source>
          <target state="translated">这仅在使用&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;编译时有效。</target>
        </trans-unit>
        <trans-unit id="cfa6d4acc676d7ac09e89de67c072931e0df8cd6" translate="yes" xml:space="preserve">
          <source>This opcode (which only exists if SQLite was compiled with SQLITE_ENABLE_COLUMN_USED_MASK) identifies which columns of the table or index for cursor P1 are used. P4 is a 64-bit integer (P4_INT64) in which the first 63 bits are one for each of the first 63 columns of the table or index that are actually used by the cursor. The high-order bit is set if any column after the 64th is used.</source>
          <target state="translated">这个操作码(只有在SQLite编译时使用了SQLITE_ENABLE_COLUMN_USED_MASK时才会存在)用于标识游标P1使用了表或索引的哪些列。P4是一个64位的整数(P4_INT64),其中前63位为游标实际使用的表或索引的前63列的1位。如果第64列之后的任何一列被使用,则设置高阶位。</target>
        </trans-unit>
        <trans-unit id="b79886bbc08237ffaab5449ea6dabdf7a84bb8eb" translate="yes" xml:space="preserve">
          <source>This opcode behaves like &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; if the seekHit flag is clear and it behaves like &lt;a href=&quot;opcode#Noop&quot;&gt;Noop&lt;/a&gt; if the seekHit flag is set.</source>
          <target state="translated">如果将seekHit标志清除，则此操作码的行为类似于&lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound；&lt;/a&gt;如果将seekHit标志设置为1，则其行为类似于&lt;a href=&quot;opcode#Noop&quot;&gt;Noop&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e04269abd438fa3b7333edfe660e9856975a5dd0" translate="yes" xml:space="preserve">
          <source>This opcode does exactly the same thing as &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; except that it increments an undocumented global variable used for testing.</source>
          <target state="translated">该操作码的作用与&lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt;完全相同，只是它增加了用于测试的未记录的全局变量。</target>
        </trans-unit>
        <trans-unit id="c8090fac6edb839ad1f5d93ed66a4501d0732691" translate="yes" xml:space="preserve">
          <source>This opcode implements the IS TRUE, IS FALSE, IS NOT TRUE, and IS NOT FALSE operators.</source>
          <target state="translated">这个操作码实现了IS TRUE、IS FALSE、IS NOT TRUE和IS NOT FALSE运算符。</target>
        </trans-unit>
        <trans-unit id="80195a95c1d144667fff82486976a6e1af2d3b57" translate="yes" xml:space="preserve">
          <source>This opcode invokes the parser to create a new virtual machine, then runs the new virtual machine. It is thus a re-entrant opcode.</source>
          <target state="translated">这个操作码调用解析器来创建一个新的虚拟机,然后运行新的虚拟机。因此它是一个重入操作码。</target>
        </trans-unit>
        <trans-unit id="d5ae7a9a55b8c3387be81c142b3c731709ff4fb8" translate="yes" xml:space="preserve">
          <source>This opcode invokes the xFilter method on the virtual table specified by P1. The integer query plan parameter to xFilter is stored in register P3. Register P3+1 stores the argc parameter to be passed to the xFilter method. Registers P3+2..P3+1+argc are the argc additional parameters which are passed to xFilter as argv. Register P3+2 becomes argv[0] when passed to xFilter.</source>
          <target state="translated">这个操作码在P1指定的虚拟表上调用xFilter方法。xFilter的整数查询计划参数被存储在寄存器P3中,寄存器P3+1存储了要传递给xFilter方法的参数。寄存器P3+1存储了要传递给xFilter方法的argc参数。寄存器P3+2...P3+1+argc是作为argv传递给xFilter的附加参数。寄存器P3+2在传递给xFilter时成为argv[0]。</target>
        </trans-unit>
        <trans-unit id="b4696388c2a5ea95b129447ae7160a304f284c78" translate="yes" xml:space="preserve">
          <source>This opcode is an alias for &lt;a href=&quot;opcode#Sort&quot;&gt;Sort&lt;/a&gt; and &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; that is used for Sorter objects.</source>
          <target state="translated">此操作码是用于Sorter对象的&lt;a href=&quot;opcode#Sort&quot;&gt;Sort&lt;/a&gt; and &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="2cd5c8a03dccaa1c2e173dfb77000d3f09963ffe" translate="yes" xml:space="preserve">
          <source>This opcode is initially coded as OP_AggStep0. On first evaluation, the FuncDef stored in P4 is converted into an sqlite3_context and the opcode is changed. In this way, the initialization of the sqlite3_context only happens once, instead of on each call to the step function.</source>
          <target state="translated">这个操作码最初被编码为OP_AggStep0。在第一次评估时,存储在P4中的FuncDef被转换为sqlite3_context,并且改变了操作码。这样,sqlite3_context的初始化只发生一次,而不是在每次调用步骤函数时。</target>
        </trans-unit>
        <trans-unit id="ccd042d8c20621b0ba115fbd962b688a465b7a1e" translate="yes" xml:space="preserve">
          <source>This opcode is normally use to move a record out of the sorter and into a register that is the source for a pseudo-table cursor created using &lt;a href=&quot;opcode#OpenPseudo&quot;&gt;OpenPseudo&lt;/a&gt;. That pseudo-table cursor is the one that is identified by parameter P3. Clearing the P3 column cache as part of this opcode saves us from having to issue a separate &lt;a href=&quot;opcode#NullRow&quot;&gt;NullRow&lt;/a&gt; instruction to clear that cache.</source>
          <target state="translated">此操作码通常用于将记录移出排序器，并移入寄存器，该寄存器是使用&lt;a href=&quot;opcode#OpenPseudo&quot;&gt;OpenPseudo&lt;/a&gt;创建的伪表游标的源。该伪表游标是由参数P3标识的那个。清除P3列缓存作为此操作码的一部分，使我们不必再发出单独的&lt;a href=&quot;opcode#NullRow&quot;&gt;NullRow&lt;/a&gt;指令来清除该缓存。</target>
        </trans-unit>
        <trans-unit id="f368e74bed9bf6036c173d5ffc843879779adc0f" translate="yes" xml:space="preserve">
          <source>This opcode is only available if SQLite is compiled with the -DSQLITE_ENABLE_OFFSET_SQL_FUNC option.</source>
          <target state="translated">这个操作码只有在SQLite编译时使用-DSQLITE_ENABLE_OFFSET_SQL_FUNC选项时才可用。</target>
        </trans-unit>
        <trans-unit id="cc6bc217f526f9cd459391c67d3dce0bbbb0723f" translate="yes" xml:space="preserve">
          <source>This opcode is only available in testing and debugging builds. It is not generated for release builds. The purpose of this opcode is to help validate the generated bytecode. This opcode does not actually contribute to computing an answer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd0c6b395f56420b6f36502ce5f6e4b927e5a5c" translate="yes" xml:space="preserve">
          <source>This opcode is only ever present in sub-programs called via the &lt;a href=&quot;opcode#Program&quot;&gt;Program&lt;/a&gt; instruction. &lt;a href=&quot;opcode#Copy&quot;&gt;Copy&lt;/a&gt; a value currently stored in a memory cell of the calling (parent) frame to cell P2 in the current frames address space. This is used by trigger programs to access the new.* and old.* values.</source>
          <target state="translated">该操作码仅在通过&lt;a href=&quot;opcode#Program&quot;&gt;程序&lt;/a&gt;指令调用的子程序中存在。&lt;a href=&quot;opcode#Copy&quot;&gt;将&lt;/a&gt;当前存储在调用（父）帧的存储单元中的值复制到当前帧地址空间中的单元P2。触发程序使用它来访问new。*和old。*值。</target>
        </trans-unit>
        <trans-unit id="1edae59fc3236745f7fbf501252bcea75f5db5b9" translate="yes" xml:space="preserve">
          <source>This opcode is similar to &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; with the exceptions that the branch is always taken if any part of the search key input is NULL.</source>
          <target state="translated">此操作码与&lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt;相似，不同之处在于，如果搜索键输入的任何部分为NULL，则始终采用该分支。</target>
        </trans-unit>
        <trans-unit id="1074ea1e6510853bdec71ac78b6a534ca6039b57" translate="yes" xml:space="preserve">
          <source>This opcode is used in IN clause processing for a multi-column key. If an IN clause is attached to an element of the key other than the left-most element, and if there are no matches on the most recent seek over the whole key, then it might be that one of the key element to the left is prohibiting a match, and hence there is &quot;no hope&quot; of any match regardless of how many IN clause elements are checked. In such a case, we abandon the IN clause search early, using this opcode. The opcode name comes from the fact that the jump is taken if there is &quot;no hope&quot; of achieving a match.</source>
          <target state="translated">这个操作码用于多列键的IN子句处理。如果一个IN子句附加在键的最左边元素以外的元素上,如果最近一次在整个键上的搜索没有匹配,那么可能是左边的一个键元素禁止匹配,因此无论检查多少个IN子句元素,都 &quot;没有希望 &quot;有任何匹配。在这种情况下,我们提前放弃IN子句搜索,使用这个操作码。这个操作码的名字来自于如果 &quot;没有希望 &quot;实现匹配,就会进行跳转。</target>
        </trans-unit>
        <trans-unit id="8a560c644b1064348d0d21a9885c9e73f72f185e" translate="yes" xml:space="preserve">
          <source>This opcode is used to implement the integrity_check pragma.</source>
          <target state="translated">这个操作码用于实现完整性检查原则。</target>
        </trans-unit>
        <trans-unit id="36b9014a68a8fcf60471eef29422a00680109ffb" translate="yes" xml:space="preserve">
          <source>This opcode is used when extracting information from a column that has REAL affinity. Such column values may still be stored as integers, for space efficiency, but after extraction we want them to have only a real value.</source>
          <target state="translated">这个操作码用于从具有REAL亲和力的列中提取信息。为了节省空间,这样的列值仍然可以以整数的形式存储,但是在提取之后我们希望它们只有一个实值。</target>
        </trans-unit>
        <trans-unit id="cfa4b2533ec63a8dec1bee2b7cfac77ec376defc" translate="yes" xml:space="preserve">
          <source>This opcode leaves the cursor configured to move in forward order, from the beginning toward the end. In other words, the cursor is configured to use &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;, not &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;.</source>
          <target state="translated">此操作码使光标配置为从头到尾向前移动。换句话说，将光标配置为使用&lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;而不是&lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9db9421c1851bc92812d2d99ea83270abb9a3281" translate="yes" xml:space="preserve">
          <source>This opcode leaves the cursor configured to move in reverse order, from the end toward the beginning. In other words, the cursor is configured to use &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;, not &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;.</source>
          <target state="translated">此操作码使光标配置为从末尾到开头以相反的顺序移动。换句话说，将光标配置为使用&lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;，而不是&lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f2f0cd72e4c85aa3ba21b6915cd7acce5e5760e8" translate="yes" xml:space="preserve">
          <source>This opcode leaves the cursor in a state where it cannot be advanced in either direction. In other words, the &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; and &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; opcodes will not work following this opcode.</source>
          <target state="translated">此操作码使光标处于无法向任一方向前进的状态。换句话说，&lt;a href=&quot;opcode#Next&quot;&gt;下一个&lt;/a&gt;和上&lt;a href=&quot;opcode#Prev&quot;&gt;一个&lt;/a&gt;操作码在该操作码之后将不起作用。</target>
        </trans-unit>
        <trans-unit id="e0f99ac32670b6df2ff48dc1552c8225ad687653" translate="yes" xml:space="preserve">
          <source>This opcode must follow an &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; or &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; comparison operator. There can be zero or more OP_ReleaseReg opcodes intervening, but no other opcodes are allowed to occur between this instruction and the previous &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; or &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt;. Furthermore, the prior &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; or &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; must have the SQLITE_STOREP2 bit set in the P5 field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6db8b6773ccb389e7a96c1d48f5077207b71453" translate="yes" xml:space="preserve">
          <source>This opcode must immediately follow an &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; or &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; comparison operator. If result of an &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; comparison on the same two operands would have be NULL or false (0), then then jump to P2. If the result of an &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; comparison on the two previous operands would have been true (1), then fall through.</source>
          <target state="translated">此操作码必须立即跟随&lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt;或&lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt;比较运算符。如果对相同两个操作数进行&lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt;比较的结果为NULL或false（0），则跳至P2。如果对前两个操作数进行&lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt;比较的结果为true（1），则失败。</target>
        </trans-unit>
        <trans-unit id="fe62ed3995127b50711c091c796c38839099f405" translate="yes" xml:space="preserve">
          <source>This opcode only works for cursors used for sorting and opened with &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt; or &lt;a href=&quot;opcode#SorterOpen&quot;&gt;SorterOpen&lt;/a&gt;.</source>
          <target state="translated">此操作码仅适用于用于排序并使用&lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt;或&lt;a href=&quot;opcode#SorterOpen&quot;&gt;SorterOpen&lt;/a&gt;打开的游标。</target>
        </trans-unit>
        <trans-unit id="0a5cf188d3f8f57c9bc976279d8b9451f3af100d" translate="yes" xml:space="preserve">
          <source>This opcode performs a commonly used computation associated with LIMIT and OFFSET process. r[P1] holds the limit counter. r[P3] holds the offset counter. The opcode computes the combined value of the LIMIT and OFFSET and stores that value in r[P2]. The r[P2] value computed is the total number of rows that will need to be visited in order to complete the query.</source>
          <target state="translated">r[P1]存放限位计数器,r[P3]存放偏移计数器。该操作码计算LIMIT和OFFSET的组合值,并将该值存储在r[P2]中。计算出的r[P2]值就是为了完成查询而需要访问的总行数。</target>
        </trans-unit>
        <trans-unit id="5c774d8b575a72465fcca20f5e30c011a493a27a" translate="yes" xml:space="preserve">
          <source>This opcode tests if a foreign key constraint-counter is currently zero. If so, jump to instruction P2. Otherwise, fall through to the next instruction.</source>
          <target state="translated">该操作码测试外键约束-计数器当前是否为零。如果是,则跳转到指令P2。否则,跳转到下一条指令。</target>
        </trans-unit>
        <trans-unit id="546c52afd639a2ac1b1f0294a0fa0ff8fad9df32" translate="yes" xml:space="preserve">
          <source>This opcode throws an error if there are any active reader VMs when it is invoked. This is done to avoid the difficulty associated with updating existing cursors when a root page is moved in an AUTOVACUUM database. This error is thrown even if the database is not an AUTOVACUUM db in order to avoid introducing an incompatibility between autovacuum and non-autovacuum modes.</source>
          <target state="translated">当调用该操作码时,如果有任何活动的阅读器虚拟机,该操作码会抛出一个错误。这样做是为了避免在AUTOVACUUM数据库中移动根页面时更新现有的游标所带来的困难。即使数据库不是AUTOVACUUM数据库,也会抛出这个错误,以避免在自动真空和非自动真空模式之间引入不兼容。</target>
        </trans-unit>
        <trans-unit id="52667b3b8e58f7e2254dc2c69756775349787b29" translate="yes" xml:space="preserve">
          <source>This opcode works exactly like &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt;. The only difference is in its name. This opcode is used in places where the function must be purely non-deterministic. Some built-in date/time functions can be either determinitic of non-deterministic, depending on their arguments. When those function are used in a non-deterministic way, they will check to see if they were called using &lt;a href=&quot;opcode#PureFunc&quot;&gt;PureFunc&lt;/a&gt; instead of &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt;, and if they were, they throw an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="480cdfb81d03d4678699e7e229cd926e397be01a" translate="yes" xml:space="preserve">
          <source>This opcode works just like &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; except that P1 must be a sorter object for which the &lt;a href=&quot;opcode#SorterSort&quot;&gt;SorterSort&lt;/a&gt; opcode has been invoked. This opcode advances the cursor to the next sorted record, or jumps to P2 if there are no more sorted records.</source>
          <target state="translated">该操作码与&lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;一样工作，除了P1必须是已为其调用&lt;a href=&quot;opcode#SorterSort&quot;&gt;SorterSort&lt;/a&gt;操作码的排序器对象。此操作码使光标前进到下一个已排序的记录，如果没有更多已排序的记录，则跳转到P2。</target>
        </trans-unit>
        <trans-unit id="8c41d39eeb147c07c8acc288aca8d67aa65d5265" translate="yes" xml:space="preserve">
          <source>This opcode works like &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt; except that it opens a transient index that is specifically designed to sort large tables using an external merge-sort algorithm.</source>
          <target state="translated">该操作码的工作方式与&lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral相似，&lt;/a&gt;不同之处在于它打开了一个临时索引，该索引专门设计用于使用外部合并排序算法对大型表进行排序。</target>
        </trans-unit>
        <trans-unit id="1bd026a84c4b134c052fab965e0298249387c523" translate="yes" xml:space="preserve">
          <source>This opcode works the same as &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt;. It has a different name to distinguish its use. Tables created using by this opcode will be used for automatically created transient indices in joins.</source>
          <target state="translated">此操作码的作用与&lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt;相同。它具有不同的名称以区分其用途。使用此操作码创建的表将用于联接中自动创建的瞬态索引。</target>
        </trans-unit>
        <trans-unit id="aea3e0eadc6549a98e3f2a226a78969a9d9be0e4" translate="yes" xml:space="preserve">
          <source>This operation leaves the cursor in a state where it can be advanced in the forward direction. The &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; instruction will work, but not the &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; instruction.</source>
          <target state="translated">该操作使光标处于可以向前移动的状态。在&lt;a href=&quot;opcode#Next&quot;&gt;接下来&lt;/a&gt;的指令将工作，但不是&lt;a href=&quot;opcode#Prev&quot;&gt;上一个&lt;/a&gt;指令。</target>
        </trans-unit>
        <trans-unit id="674899f070471e538d8c615be60bc1cbfc82c6f5" translate="yes" xml:space="preserve">
          <source>This operation leaves the cursor in a state where it cannot be advanced in either direction. In other words, the &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; and &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; opcodes do not work after this operation.</source>
          <target state="translated">此操作使光标处于无法向任一方向前进的状态。换句话说，&lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;和&lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;操作码在此操作后不起作用。</target>
        </trans-unit>
        <trans-unit id="692e5e8e72323f3828134ed084c67a8aae1f6191" translate="yes" xml:space="preserve">
          <source>This option activates an optimization that reduces the memory required by the sorter at the cost of doing additional B-tree lookups after the sort has occurred.</source>
          <target state="translated">此选项可激活优化,减少分拣机所需的内存,但代价是在分拣后进行额外的 B 树查找。</target>
        </trans-unit>
        <trans-unit id="e1b53eed6630caef9cfd2ca35ff19d694b6cd8e9" translate="yes" xml:space="preserve">
          <source>This option adds additional logic to the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command and to the &lt;a href=&quot;optoverview&quot;&gt;query planner&lt;/a&gt; that can help SQLite to chose a better query plan under certain situations. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command is enhanced to collect histogram data from all columns of every index and store that data in the &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; table. The query planner will then use the histogram data to help it make better index choices. The downside of this compile-time option is that it violates the &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;query planner stability guarantee&lt;/a&gt; making it more difficult to ensure consistent performance in mass-produced applications.</source>
          <target state="translated">此选项在&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令和&lt;a href=&quot;optoverview&quot;&gt;查询计划程序&lt;/a&gt;中添加了其他逻辑，可以帮助SQLite在某些情况下选择更好的查询计划。该&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令是从每一个索引的所有列和存储增强收集直方图数据，在数据&lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;表。然后，查询计划者将使用直方图数据来帮助它做出更好的索引选择。此编译时选项的缺点是，它违反了&lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;查询计划程序的稳定性保证&lt;/a&gt;，因此很难确保在批量生产的应用程序中保持一致的性能。</target>
        </trans-unit>
        <trans-unit id="d6209f0377358c783d1190518295961bb9d4da90" translate="yes" xml:space="preserve">
          <source>This option adds extra logic to SQLite that allows it to release unused memory upon request. This option must be enabled in order for the &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface to work. If this compile-time option is not used, the &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface is a no-op.</source>
          <target state="translated">此选项向SQLite添加了额外的逻辑，使其可以根据请求释放未使用的内存。为了启用&lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory（）&lt;/a&gt;接口，必须启用此选项。如果不使用此编译时选项，则&lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory（）&lt;/a&gt;接口为空操作。</target>
        </trans-unit>
        <trans-unit id="939f1a447a21a0874443461aacf8890bd098e69f" translate="yes" xml:space="preserve">
          <source>This option adds extra logic to SQLite that inserts comment text into the output of &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;. These extra comments use extra memory, thus making &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; larger and very slightly slower, and so they are turned off by default and in most application. But some applications, such as the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; for SQLite, value clarity of EXPLAIN output over raw performance and so this compile-time option is available to them. The SQLITE_ENABLE_EXPLAIN_COMMENTS compile-time option is also enabled automatically if &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; is enabled.</source>
          <target state="translated">此选项向SQLite添加了额外的逻辑，该逻辑将注释文本插入&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;的输出中。这些额外的注释会占用额外的内存，从而使&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;变大且变慢，因此默认情况下会在大多数应用程序中将其关闭。但是某些应用程序（例如SQLite 的&lt;a href=&quot;cli&quot;&gt;命令行外壳）相&lt;/a&gt;对于原始性能重视EXPLAIN输出的清晰度，因此，他们可以使用此编译时选项。如果启用了&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG，&lt;/a&gt;还将自动启用SQLITE_ENABLE_EXPLAIN_COMMENTS编译时选项。</target>
        </trans-unit>
        <trans-unit id="4c48faf6b414235fea882e17a937347af8cad6d7" translate="yes" xml:space="preserve">
          <source>This option builds SQLite without support for shared-cache mode. The &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; is omitted along with a fair amount of logic within the B-Tree subsystem associated with shared cache management.</source>
          <target state="translated">此选项将构建不支持共享缓存模式的SQLite。所述&lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）&lt;/a&gt;与逻辑的与共享高速缓存管理相关的B树子系统内相当数量省略沿。</target>
        </trans-unit>
        <trans-unit id="b993563b54a3e7e57504381c57f5844eff0c8f71" translate="yes" xml:space="preserve">
          <source>This option builds a version of the SQLite library that contains no Writable Static Data (WSD). WSD is global variables and/or static variables. Some platforms do not support WSD, and this option is necessary in order for SQLite to work those platforms.</source>
          <target state="translated">这个选项构建了一个不包含可写静态数据(WSD)的SQLite库的版本。WSD是全局变量和/或静态变量。有些平台不支持WSD,为了让SQLite在这些平台上运行,这个选项是必要的。</target>
        </trans-unit>
        <trans-unit id="cc1dc5438a20aea7b771ebb862eeafa845ecba70" translate="yes" xml:space="preserve">
          <source>This option causes SQLite to include support for the &lt;a href=&quot;rtree&quot;&gt;R*Tree index extension&lt;/a&gt;.</source>
          <target state="translated">此选项使SQLite包括对&lt;a href=&quot;rtree&quot;&gt;R * Tree索引扩展的支持&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d49b99c0ffb50444c0efac26b8174b7d62f63e18" translate="yes" xml:space="preserve">
          <source>This option causes SQLite to issue extra &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE&lt;/a&gt; file controls to provide supplementary information to the VFS. The &quot;vfslog.c&quot; extension makes use of this to provide enhanced logs of VFS activity.</source>
          <target state="translated">此选项使SQLite发出额外的&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE&lt;/a&gt;文件控件，以向VFS提供补充信息。&amp;ldquo; vfslog.c&amp;rdquo;扩展使用此功能来提供VFS活动的增强日志。</target>
        </trans-unit>
        <trans-unit id="f48b901e533b97a7c255e13419b3b1ee589cd6a2" translate="yes" xml:space="preserve">
          <source>This option causes SQLite to omit support for CHECK constraints. The parser will still accept CHECK constraints in SQL statements, they will just not be enforced.</source>
          <target state="translated">这个选项会导致SQLite省略对CHECK约束的支持。解析器仍然会接受SQL语句中的CHECK约束,只是它们不会被强制执行。</target>
        </trans-unit>
        <trans-unit id="0e8d6847f55a56b21f8cc66e6cb9b40222b5beea" translate="yes" xml:space="preserve">
          <source>This option causes SQLite to omit support for interfaces marked as deprecated. This includes &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_aggregate_count()&lt;/a&gt;, &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_expired()&lt;/a&gt;, &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_transfer_bindings()&lt;/a&gt;, &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_global_recover()&lt;/a&gt;, &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_thread_cleanup()&lt;/a&gt; and &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm()&lt;/a&gt; interfaces and &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;PRAGMA count_changes&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;PRAGMA data_store_directory&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_default_cache_size&quot;&gt;PRAGMA default_cache_size&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt;PRAGMA empty_result_callbacks&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;PRAGMA full_column_names&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;PRAGMA short_column_names&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt;.</source>
          <target state="translated">此选项导致SQLite省略对标记为已弃用的接口的支持。这包括&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_aggregate_count（） &lt;/a&gt;，&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_expired（） &lt;/a&gt;，&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_transfer_bindings（） &lt;/a&gt;，&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_global_recover（） &lt;/a&gt;，&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_thread_cleanup（）&lt;/a&gt;和&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm（）&lt;/a&gt;接口和&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;语句&lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;PRAGMA count_changes&lt;/a&gt;，&lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;PRAGMA data_store_directory&lt;/a&gt;，&lt;a href=&quot;pragma#pragma_default_cache_size&quot;&gt;PRAGMA default_cache_size&lt;/a&gt;，&lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt;PRAGMA empty_result_callbacks&lt;/a&gt;，&lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;PRAGMA full_column_names&lt;/a&gt;，&lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;PRAGMA short_column_names&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3bc3317e6e04ba669cec1fd0969c97803605f228" translate="yes" xml:space="preserve">
          <source>This option causes SQLite to omit support for the &lt;a href=&quot;c3ref/column_decltype&quot;&gt;sqlite3_column_decltype()&lt;/a&gt; and &lt;a href=&quot;c3ref/column_decltype&quot;&gt;sqlite3_column_decltype16()&lt;/a&gt; interfaces.</source>
          <target state="translated">此选项导致SQLite省略对&lt;a href=&quot;c3ref/column_decltype&quot;&gt;sqlite3_column_decltype（）&lt;/a&gt;和&lt;a href=&quot;c3ref/column_decltype&quot;&gt;sqlite3_column_decltype16（）&lt;/a&gt;接口的支持。</target>
        </trans-unit>
        <trans-unit id="f5f11391f5a431c21a74cece861bb90184bcc1ca" translate="yes" xml:space="preserve">
          <source>This option causes SQLite to omit support for the CAST operator.</source>
          <target state="translated">这个选项会导致SQLite省略对CAST操作符的支持。</target>
        </trans-unit>
        <trans-unit id="42e9c6736f13f3788e9996fc842184805b38c422" translate="yes" xml:space="preserve">
          <source>This option causes some extensions to link against the &lt;a href=&quot;https://zlib.net&quot;&gt;zlib compression library&lt;/a&gt;.</source>
          <target state="translated">此选项导致某些扩展链接到&lt;a href=&quot;https://zlib.net&quot;&gt;zlib压缩库&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8f9a553122464d073f41c1a4907a1e3a4d15ea05" translate="yes" xml:space="preserve">
          <source>This option causes support for &lt;a href=&quot;c3ref/blob&quot;&gt;incremental BLOB I/O&lt;/a&gt; to be omitted.</source>
          <target state="translated">此选项导致省略对&lt;a href=&quot;c3ref/blob&quot;&gt;增量BLOB I / O的&lt;/a&gt;支持。</target>
        </trans-unit>
        <trans-unit id="a5fb6aca1f0d6549bb7f87e1d2117bf9906d5faa" translate="yes" xml:space="preserve">
          <source>This option causes support for &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; and &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_free_table()&lt;/a&gt; to be omitted.</source>
          <target state="translated">此选项导致省略对&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;和&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_free_table（）的&lt;/a&gt;支持。</target>
        </trans-unit>
        <trans-unit id="81ad82489e08da7b33af60fe7dc85cf28f77189f" translate="yes" xml:space="preserve">
          <source>This option causes support for &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt; to be omitted.</source>
          <target state="translated">此选项导致省略对&lt;a href=&quot;lang_with&quot;&gt;公用表表达式的&lt;/a&gt;支持。</target>
        </trans-unit>
        <trans-unit id="1d462d4f5baf96b5381e5a9efb9392dd8419bfa1" translate="yes" xml:space="preserve">
          <source>This option causes the &lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete()&lt;/a&gt; and &lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete16()&lt;/a&gt; interfaces to be omitted.</source>
          <target state="translated">此选项导致省略&lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete（）&lt;/a&gt;和&lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete16（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="c44c8eec11a8ae8049df43dc8d152025a2065bf2" translate="yes" xml:space="preserve">
          <source>This option causes the &lt;a href=&quot;http://www.icu-project.org/&quot;&gt;International Components for Unicode&lt;/a&gt; or &quot;ICU&quot; extension to SQLite to be added to the build.</source>
          <target state="translated">此选项导致将&lt;a href=&quot;http://www.icu-project.org/&quot;&gt;Unicode&lt;/a&gt;的国际组件或SQLite的&amp;ldquo; ICU&amp;rdquo;扩展名添加到构建中。</target>
        </trans-unit>
        <trans-unit id="3e7ba1f2e4ecce44e2a9ed58760bf709eee38824" translate="yes" xml:space="preserve">
          <source>This option causes the &lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;PRAGMA reverse_unordered_selects&lt;/a&gt; setting to be enabled by default. When enabled, &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements that lack an ORDER BY clause will run in reverse order.</source>
          <target state="translated">此选项使&lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;PRAGMA reverse_unordered_selects&lt;/a&gt;设置在默认情况下启用。启用后，缺少ORDER BY子句的&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句将以相反的顺序运行。</target>
        </trans-unit>
        <trans-unit id="f5c90b7d8674897dce67771e2421445a44cf5d0f" translate="yes" xml:space="preserve">
          <source>This option causes the &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;query planner stability guarantee&lt;/a&gt; (QPSG) to be on by default. Normally the QPSG is off and must be activated at run-time using the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt; option to the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface.</source>
          <target state="translated">此选项使&lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;查询计划程序稳定性保证&lt;/a&gt;（QPSG）在默认情况下处于启用状态。通常，QPSG是关闭的，必须在运行时使用&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;接口的&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt;选项激活。</target>
        </trans-unit>
        <trans-unit id="f3e81e1ee9998eb2eded923b7975e23afc33d57f" translate="yes" xml:space="preserve">
          <source>This option causes the &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; process logic to be enabled by default.</source>
          <target state="translated">此选项使&lt;a href=&quot;uri&quot;&gt;URI文件名&lt;/a&gt;处理逻辑默认情况下处于启用状态。</target>
        </trans-unit>
        <trans-unit id="25841760348a4a05ca082684fc85caf48a8848ea" translate="yes" xml:space="preserve">
          <source>This option causes the LALR(1) parser stack depth to be tracked and reported using the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status&lt;/a&gt;(&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusparserstack&quot;&gt;SQLITE_STATUS_PARSER_STACK&lt;/a&gt;,...) interface. SQLite's LALR(1) parser has a fixed stack depth (determined at compile-time using the &lt;a href=&quot;compile#yystackdepth&quot;&gt;YYSTACKDEPTH&lt;/a&gt; options). This option can be used to help determine if an application is getting close to exceeding the maximum LALR(1) stack depth.</source>
          <target state="translated">此选项导致使用&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status&lt;/a&gt;（&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusparserstack&quot;&gt;SQLITE_STATUS_PARSER_STACK&lt;/a&gt;，...）接口跟踪和报告LALR（1）解析器堆栈深度。 SQLite的LALR（1）解析器具有固定的堆栈深度（在编译时使用&lt;a href=&quot;compile#yystackdepth&quot;&gt;YYSTACKDEPTH&lt;/a&gt;选项确定）。此选项可用于帮助确定应用程序是否接近最大LALR（1）堆栈深度。</target>
        </trans-unit>
        <trans-unit id="32f86baa9c92a63548375cdf50ea0fd1c52ed044" translate="yes" xml:space="preserve">
          <source>This option changes the default assumption about &lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt; for the underlying filesystems for the unix and windows &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;. Setting SQLITE_POWERSAFE_OVERWRITE to 1 causes SQLite to assume that application-level writes cannot changes bytes outside the range of bytes written even if the write occurs just before a power loss. With SQLITE_POWERSAFE_OVERWRITE set to 0, SQLite assumes that other bytes in the same sector with a written byte might be changed or damaged by a power loss.</source>
          <target state="translated">此选项更改有关UNIX和Windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;的基础文件系统&lt;a href=&quot;psow&quot;&gt;电源安全覆盖&lt;/a&gt;的默认假设。将SQLITE_POWERSAFE_OVERWRITE设置为1会导致SQLite假定应用程序级写操作无法更改超出所写字节范围的字节，即使该写操作恰好在断电之前发生。在将SQLITE_POWERSAFE_OVERWRITE设置为0的情况下，SQLite假定同一扇区中具有写入字节的其他字节可能因断电而被更改或损坏。</target>
        </trans-unit>
        <trans-unit id="791fdd9bdb7ed68e09202021e5669277498343c1" translate="yes" xml:space="preserve">
          <source>This option controls whether or not code is included in SQLite to enable it to operate safely in a multithreaded environment. The default is SQLITE_THREADSAFE=1 which is safe for use in a multithreaded environment. When compiled with SQLITE_THREADSAFE=0 all mutexing code is omitted and it is unsafe to use SQLite in a multithreaded program. When compiled with SQLITE_THREADSAFE=2, SQLite can be used in a multithreaded program so long as no two threads attempt to use the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; (or any &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; derived from that database connection) at the same time.</source>
          <target state="translated">此选项控制代码是否包含在SQLite中以使其能够在多线程环境中安全运行。默认值为SQLITE_THREADSAFE = 1，可以在多线程环境中安全使用。当使用SQLITE_THREADSAFE = 0进行编译时，将忽略所有的静音代码，并且在多线程程序中使用SQLite是不安全的。当使用SQLITE_THREADSAFE = 2进行编译时，只要没有两个线程尝试同时使用相同的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;（或从该数据库连接派生的任何&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;），就可以在多线程程序中使用SQLite 。</target>
        </trans-unit>
        <trans-unit id="e2db1e13a20e398e5992253ddd17146aa86ad317" translate="yes" xml:space="preserve">
          <source>This option controls whether temporary files are stored on disk or in memory. The meanings for various settings of this compile-time option are as follows:</source>
          <target state="translated">这个选项控制临时文件是存储在磁盘上还是内存中。这个编译时选项的各种设置的含义如下。</target>
        </trans-unit>
        <trans-unit id="f480e09e0e7a4b4c8eaae40f24ab8395889d63cf" translate="yes" xml:space="preserve">
          <source>This option disables the ability of SQLite to use an index together with terms of a WHERE clause connected by the OR operator.</source>
          <target state="translated">这个选项禁止SQLite使用索引和由OR操作符连接的WHERE子句的条款。</target>
        </trans-unit>
        <trans-unit id="bf93493f8d0082c8b326cab559012b486b9691a3" translate="yes" xml:space="preserve">
          <source>This option disables the ability of SQLite to use indices to help resolve &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; and &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operators in a WHERE clause.</source>
          <target state="translated">此选项禁用SQLite使用索引来帮助解析WHERE子句中的&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;和&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;运算符的功能。</target>
        </trans-unit>
        <trans-unit id="faffed503a7ff1447f6b122080398e29ed11b00e" translate="yes" xml:space="preserve">
          <source>This option disables the use of compiler-specific built-in functions such as __builtin_bswap32() and __builtin_add_overflow() in GCC and Clang, or _byteswap_ulong() and _ReadWriteBarrier() with MSVC.</source>
          <target state="translated">这个选项禁止使用编译器特定的内置函数,比如GCC和Clang中的__builtin_bswap32()和__builtin_add_overflow(),或者MSVC中的_byteswap_ulong()和_ReadWriteBarrier()。</target>
        </trans-unit>
        <trans-unit id="30e5236a00b5a0e3f369da0d4ce09a34450e4f5d" translate="yes" xml:space="preserve">
          <source>This option disables the use of indices with WHERE clause terms that employ the BETWEEN operator.</source>
          <target state="translated">这个选项禁止使用使用BETWEEN操作符的WHERE子句的索引。</target>
        </trans-unit>
        <trans-unit id="f2b0cbc6ec1854f9e4c7dd19a372c4979cbe3657" translate="yes" xml:space="preserve">
          <source>This option enables &lt;a href=&quot;c3ref/preupdate_count&quot;&gt;several new APIs&lt;/a&gt; that provide callbacks prior to any change to a &lt;a href=&quot;rowidtable&quot;&gt;rowid table&lt;/a&gt;. The callbacks can be used to record the state of the row before the change occurs.</source>
          <target state="translated">此选项启用&lt;a href=&quot;c3ref/preupdate_count&quot;&gt;几个新API&lt;/a&gt;，这些API在对&lt;a href=&quot;rowidtable&quot;&gt;rowid表&lt;/a&gt;进行任何更改之前提供回调。回调可用于记录更改发生之前的行状态。</target>
        </trans-unit>
        <trans-unit id="0f330069807dae4c09d6cca239bf6220ceecd386" translate="yes" xml:space="preserve">
          <source>This option enables additional logic in the OS interface layer for Mac OS X. The additional logic attempts to determine the type of the underlying filesystem and choose and alternative locking strategy that works correctly for that filesystem type. Five locking strategies are available:</source>
          <target state="translated">此选项可在 Mac OS X 的 OS 接口层中启用附加逻辑。额外的逻辑试图确定底层文件系统的类型,并选择正确适用于该文件系统类型的替代锁定策略。有五种锁定策略可用。</target>
        </trans-unit>
        <trans-unit id="b0cda88b35aef2718ccabbc509d1fe578d46ccac" translate="yes" xml:space="preserve">
          <source>This option enables an optimization that omits NULL columns at the ends of rows, for a space savings on disk.</source>
          <target state="translated">这个选项可以实现在行尾省略NULL列的优化,以节省磁盘空间。</target>
        </trans-unit>
        <trans-unit id="6f83f444cc87212970d30b59ad548ac739a161e1" translate="yes" xml:space="preserve">
          <source>This option enables an optional ORDER BY and LIMIT clause on &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements.</source>
          <target state="translated">此选项在&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;和&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;语句上启用可选的ORDER BY和LIMIT子句。</target>
        </trans-unit>
        <trans-unit id="e69261024b835708d0d4847720c9f1cf32a794de" translate="yes" xml:space="preserve">
          <source>This option enables extra code (especially the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsqllog&quot;&gt;SQLITE_CONFIG_SQLLOG&lt;/a&gt; option to &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt;) that can be used to create logs of all SQLite processing performed by an application. These logs can be useful in doing off-line analysis of the behavior of an application, and especially for performance analysis. In order for the SQLITE_ENABLE_SQLLOG option to be useful, some extra code is required. The &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/test_sqllog.c&quot;&gt;&quot;test_sqllog.c&quot;&lt;/a&gt; source code file in the SQLite source tree is a working example of the required extra code. On unix and windows systems, a developer can append the text of the &quot;test_sqllog.c&quot; source code file to the end of an &quot;sqlite3.c&quot; amalgamation, recompile the application using the -DSQLITE_ENABLE_SQLLOG option, then control logging using environment variables. See the header comment on the &quot;test_sqllog.c&quot; source file for additional detail.</source>
          <target state="translated">此选项启用额外的代码（尤其是&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;的&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsqllog&quot;&gt;SQLITE_CONFIG_SQLLOG&lt;/a&gt;选项），可用于创建应用程序执行的所有SQLite处理的日志。这些日志可用于对应用程序的行为进行离线分析，尤其是对于性能分析。为了使SQLITE_ENABLE_SQLLOG选项有用，需要一些额外的代码。该&lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/test_sqllog.c&quot;&gt;&amp;ldquo;test_sqllog.c&amp;rdquo;&lt;/a&gt;SQLite源代码树中的源代码文件是所需额外代码的有效示例。在UNIX和Windows系统上，开发人员可以将&amp;ldquo; test_sqllog.c&amp;rdquo;源代码文件的文本附加到&amp;ldquo; sqlite3.c&amp;rdquo;合并的末尾，使用-DSQLITE_ENABLE_SQLLOG选项重新编译应用程序，然后使用环境变量控制日志记录。有关更多详细信息，请参见&amp;ldquo; test_sqllog.c&amp;rdquo;源文件上的标题注释。</target>
        </trans-unit>
        <trans-unit id="274a5f8b5db607c52552d4637956a2899e2617fe" translate="yes" xml:space="preserve">
          <source>This option enables support for the &lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset(X)&lt;/a&gt; SQL function.</source>
          <target state="translated">此选项启用对&lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset（X）&lt;/a&gt; SQL函数的支持。</target>
        </trans-unit>
        <trans-unit id="93022ac685f42e44c6bd7d7db98fb4366cf5def1" translate="yes" xml:space="preserve">
          <source>This option enables the &lt;a href=&quot;bytecodevtab&quot;&gt;bytecode and tables_used virtual tables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9a1787f4c945251b506136e6798154b2c122d60" translate="yes" xml:space="preserve">
          <source>This option enables the &lt;a href=&quot;c3ref/serialize&quot;&gt;sqlite3_serialize()&lt;/a&gt; and &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; interfaces.</source>
          <target state="translated">此选项启用&lt;a href=&quot;c3ref/serialize&quot;&gt;sqlite3_serialize（）&lt;/a&gt;和&lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="be87642b57ced8abee8b1950b45aa93d46620bfd" translate="yes" xml:space="preserve">
          <source>This option enables the &lt;a href=&quot;c3ref/stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus()&lt;/a&gt; interface. The &lt;a href=&quot;c3ref/stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus()&lt;/a&gt; interface is normally omitted from the build because it imposes a small performance penalty, even on statements that do not use the feature.</source>
          <target state="translated">此选项启用&lt;a href=&quot;c3ref/stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus（）&lt;/a&gt;接口。该&lt;a href=&quot;c3ref/stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus（）&lt;/a&gt;接口通常从构建省略，因为它规定一个小的性能损失，即使在不使用该功能的语句。</target>
        </trans-unit>
        <trans-unit id="51d540f2703b7f49001660035d021722d40f355e" translate="yes" xml:space="preserve">
          <source>This option enables the &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface and its associated functionality. See the documentation titled &lt;a href=&quot;unlock_notify&quot;&gt;Using the SQLite Unlock Notification Feature&lt;/a&gt; for additional information.</source>
          <target state="translated">此选项启用&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;接口及其关联的功能。有关其他信息，请参见标题为&amp;ldquo; &lt;a href=&quot;unlock_notify&quot;&gt;使用SQLite解锁通知功能&lt;/a&gt; &amp;rdquo;的文档。</target>
        </trans-unit>
        <trans-unit id="d95741cd8a126d1cf356358b77e58a5cff687ae7" translate="yes" xml:space="preserve">
          <source>This option enables the &lt;a href=&quot;dbpage&quot;&gt;SQLITE_DBPAGE virtual table&lt;/a&gt;.</source>
          <target state="translated">此选项启用&lt;a href=&quot;dbpage&quot;&gt;SQLITE_DBPAGE虚拟表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="67a232ef452eb71b2c364382991ea5fe843a8072" translate="yes" xml:space="preserve">
          <source>This option enables the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;.</source>
          <target state="translated">此选项启用&lt;a href=&quot;dbstat&quot;&gt;dbstat虚拟表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="263fe759843f50fd8ce96e059c3daf128b5aa902" translate="yes" xml:space="preserve">
          <source>This option enables the &lt;a href=&quot;lang_corefunc#soundex&quot;&gt;soundex() SQL function&lt;/a&gt;.</source>
          <target state="translated">此选项启用&lt;a href=&quot;lang_corefunc#soundex&quot;&gt;soundex（）SQL函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2f583d286c14b783ea80b9c826f07e649637eb7a" translate="yes" xml:space="preserve">
          <source>This option enables the &lt;a href=&quot;sessionintro&quot;&gt;session extension&lt;/a&gt;.</source>
          <target state="translated">此选项启用&lt;a href=&quot;sessionintro&quot;&gt;会话扩展&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9acfdf9bd0e7a3663dc2bc3825b43b38a145c695" translate="yes" xml:space="preserve">
          <source>This option enables the code to support the &lt;a href=&quot;c3ref/snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object and its related interfaces:</source>
          <target state="translated">此选项使代码能够支持&lt;a href=&quot;c3ref/snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt;对象及其相关接口：</target>
        </trans-unit>
        <trans-unit id="223f501de382821eed41b9386a107ab95a98080f" translate="yes" xml:space="preserve">
          <source>This option enables the two-argument version of the &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; interface. The second argument to fts3_tokenizer() is suppose to be a pointer to a function (encoded as a BLOB) that implements an application defined tokenizer. If hostile actors are able to run the two-argument version of fts3_tokenizer() with an arbitrary second argument, they could use crash or take control of the process.</source>
          <target state="translated">此选项启用&lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer（）&lt;/a&gt;接口的两个参数版本。假设fts3_tokenizer（）的第二个参数是指向实现应用程序定义的令牌生成器的函数（编码为BLOB）的指针。如果敌对行动者能够使用任意第二个参数运行fts3_tokenizer（）的两个参数版本，则他们可以使用崩溃或控制进程。</target>
        </trans-unit>
        <trans-unit id="7cc48f6d5950f1e34bb75faacdf1cc192e5f2843" translate="yes" xml:space="preserve">
          <source>This option enables the use of the Windows Heap API functions for memory allocation instead of the standard library malloc() and free() routines.</source>
          <target state="translated">这个选项可以使用Windows Heap API函数进行内存分配,而不是标准的库malloc()和free()例程。</target>
        </trans-unit>
        <trans-unit id="4c5a946f48226950dd966bd130e90484df7d66b6" translate="yes" xml:space="preserve">
          <source>This option forces the Win32 native memory allocator, when enabled, to create a private heap to hold all memory allocations.</source>
          <target state="translated">这个选项强制Win32本机内存分配器在启用时,创建一个私有堆来保存所有的内存分配。</target>
        </trans-unit>
        <trans-unit id="a6e532ac60807302cf761f04099d7e9ae4df7d97" translate="yes" xml:space="preserve">
          <source>This option forces the Win32 native memory allocator, when enabled, to make strategic calls into the HeapValidate() function if assert() is also enabled.</source>
          <target state="translated">这个选项强制Win32本机内存分配器在启用后,如果assert()也被启用,就会对HeapValidate()函数进行策略调用。</target>
        </trans-unit>
        <trans-unit id="38ef15a6ec83783f8e5342533553962834968880" translate="yes" xml:space="preserve">
          <source>This option has no affect on the SQLite core. It is only used by extensions. This is option is necessary for the compression and decompression functions that are part of &lt;a href=&quot;sqlar&quot;&gt;SQL Archive&lt;/a&gt; support in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">此选项对SQLite核心没有影响。仅扩展使用。对于&lt;a href=&quot;cli&quot;&gt;命令行外壳程序&lt;/a&gt;中&lt;a href=&quot;sqlar&quot;&gt;SQL Archive&lt;/a&gt;支持的压缩和解压缩功能，此选项是必需的。</target>
        </trans-unit>
        <trans-unit id="14c8af9768bd63293fd017249118cc8e97ccdc51" translate="yes" xml:space="preserve">
          <source>This option includes code in SQLite that implements an alternative memory allocator. This alternative memory allocator is only engaged when the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; option to &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; is used to supply a large chunk of memory from which all memory allocations are taken. The MEMSYS3 memory allocator uses a hybrid allocation algorithm patterned after dlmalloc(). Only one of SQLITE_ENABLE_MEMSYS3 and SQLITE_ENABLE_MEMSYS5 may be enabled at once.</source>
          <target state="translated">此选项包括SQLite中实现替代内存分配器的代码。当这种替代内存分配器仅接合&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;选项&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;用于供应的存储器大块从中提取所有的内存分配。 MEMSYS3内存分配器使用在dlmalloc（）之后模式化的混合分配算法。一次只能启用SQLITE_ENABLE_MEMSYS3和SQLITE_ENABLE_MEMSYS5之一。</target>
        </trans-unit>
        <trans-unit id="ec14e9ee089db4506386b040d7a0d29749f6e52a" translate="yes" xml:space="preserve">
          <source>This option includes code in SQLite that implements an alternative memory allocator. This alternative memory allocator is only engaged when the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; option to &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; is used to supply a large chunk of memory from which all memory allocations are taken. The MEMSYS5 module rounds all allocations up to the next power of two and uses a first-fit, buddy-allocator algorithm that provides strong guarantees against fragmentation and breakdown subject to certain operating constraints.</source>
          <target state="translated">此选项包括SQLite中实现替代内存分配器的代码。仅当使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;的&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;选项提供大量内存以从中获取所有内存分配时，才使用此备用内存分配器。 MEMSYS5模块将所有分配向上舍入为2的下一个幂，并使用&amp;ldquo;最适合&amp;rdquo;的伙伴分配器算法，该算法为某些操作约束下的碎片和崩溃提供了有力的保证。</target>
        </trans-unit>
        <trans-unit id="b2d0fc0af3baf2bb6313e04cb3b2c292231a6d89" translate="yes" xml:space="preserve">
          <source>This option is no longer used for anything. It is a no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0d5394036aa4f4e95f3e2cab1f066c690e694f" translate="yes" xml:space="preserve">
          <source>This option is obsolete. It used to enable some extra some extra PRAGMA statements such as &lt;a href=&quot;pragma#pragma_function_list&quot;&gt;PRAGMA function_list&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_module_list&quot;&gt;PRAGMA module_list&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_pragma_list&quot;&gt;PRAGMA pragma_list&lt;/a&gt;, but those pragmas are now all enabled by default. See &lt;a href=&quot;compile#omit_introspection_pragmas&quot;&gt;SQLITE_OMIT_INTROSPECTION_PRAGMAS&lt;/a&gt;.</source>
          <target state="translated">此选项已过时。它曾经使一些额外的一些额外的注记语句，如&lt;a href=&quot;pragma#pragma_function_list&quot;&gt;PRAGMA function_list&lt;/a&gt;，&lt;a href=&quot;pragma#pragma_module_list&quot;&gt;PRAGMA MODULE_LIST&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_pragma_list&quot;&gt;PRAGMA pragma_list&lt;/a&gt;，但这些pragma现在都默认启用。请参阅&lt;a href=&quot;compile#omit_introspection_pragmas&quot;&gt;SQLITE_OMIT_INTROSPECTION_PRAGMAS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3d64e8ca0a51fe592b5c0aacc258d17bc062a414" translate="yes" xml:space="preserve">
          <source>This option is omits the &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; feature. When this is macro is defined, columns declared as &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; AUTOINCREMENT&quot; behave in the same way as columns declared as &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;&quot; when a NULL is inserted. The sqlite_sequence system table is neither created, nor respected if it already exists.</source>
          <target state="translated">此选项省略了&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;功能。定义此宏时，插入NULL时，声明为&amp;ldquo; &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; AUTOINCREMENT&amp;rdquo;的列的行为与声明为&amp;ldquo; &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; &amp;rdquo;的列相同。sqlite_sequence系统表既不会创建，也不会受到尊重（如果已存在）。</target>
        </trans-unit>
        <trans-unit id="35532e84bec206bb40c52a637418126e7ac12604" translate="yes" xml:space="preserve">
          <source>This option is only available if sqlite is compiled with the &lt;a href=&quot;../compile#enable_sqllog&quot;&gt;SQLITE_ENABLE_SQLLOG&lt;/a&gt; pre-processor macro defined. The first argument should be a pointer to a function of type void(*)(void*,sqlite3*,const char*, int). The second should be of type (void*). The callback is invoked by the library in three separate circumstances, identified by the value passed as the fourth parameter. If the fourth parameter is 0, then the database connection passed as the second argument has just been opened. The third argument points to a buffer containing the name of the main database file. If the fourth parameter is 1, then the SQL statement that the third parameter points to has just been executed. Or, if the fourth parameter is 2, then the connection being passed as the second parameter is being closed. The third parameter is passed NULL In this case. An example of using this configuration option can be seen in the &quot;test_sqllog.c&quot; source file in the canonical SQLite source tree.</source>
          <target state="translated">仅当使用&lt;a href=&quot;../compile#enable_sqllog&quot;&gt;SQLITE_ENABLE_SQLLOG&lt;/a&gt;编译sqlite时，此选项才可用定义了预处理器宏。第一个参数应该是指向void（*）（void *，sqlite3 *，const char *，int）类型的函数的指针。第二个应为（void *）类型。库在三种不同的情况下调用回调，这些情况由作为第四个参数传递的值标识。如果第四个参数为0，则刚刚打开作为第二个参数传递的数据库连接。第三个参数指向包含主数据库文件名称的缓冲区。如果第四个参数为1，则刚刚执行了第三个参数指向的SQL语句。或者，如果第四个参数为2，则在关闭第二个参数时正在传递的连接。在这种情况下，将第三个参数传递为NULL。在&amp;ldquo; test_sqllog.c&amp;rdquo;中可以看到使用此配置选项的示例。SQLite规范树中的源文件。</target>
        </trans-unit>
        <trans-unit id="3370b57f53a2cc0599282e4a4706bd9d78d8e68e" translate="yes" xml:space="preserve">
          <source>This option is only available if sqlite is compiled with the &lt;a href=&quot;compile#enable_sqllog&quot;&gt;SQLITE_ENABLE_SQLLOG&lt;/a&gt; pre-processor macro defined. The first argument should be a pointer to a function of type void(*)(void*,sqlite3*,const char*, int). The second should be of type (void*). The callback is invoked by the library in three separate circumstances, identified by the value passed as the fourth parameter. If the fourth parameter is 0, then the database connection passed as the second argument has just been opened. The third argument points to a buffer containing the name of the main database file. If the fourth parameter is 1, then the SQL statement that the third parameter points to has just been executed. Or, if the fourth parameter is 2, then the connection being passed as the second parameter is being closed. The third parameter is passed NULL In this case. An example of using this configuration option can be seen in the &quot;test_sqllog.c&quot; source file in the canonical SQLite source tree.</source>
          <target state="translated">仅当使用&lt;a href=&quot;compile#enable_sqllog&quot;&gt;SQLITE_ENABLE_SQLLOG&lt;/a&gt;编译sqlite时，此选项才可用定义了预处理器宏。第一个参数应该是指向void（*）（void *，sqlite3 *，const char *，int）类型的函数的指针。第二个应为（void *）类型。库在三种不同的情况下调用回调，这些情况由作为第四个参数传递的值标识。如果第四个参数为0，则刚刚打开作为第二个参数传递的数据库连接。第三个参数指向包含主数据库文件名称的缓冲区。如果第四个参数为1，则刚刚执行了第三个参数指向的SQL语句。或者，如果第四个参数为2，则在关闭第二个参数时正在传递的连接。在这种情况下，将第三个参数传递为NULL。在&amp;ldquo; test_sqllog.c&amp;rdquo;中可以看到使用此配置选项的示例。SQLite规范树中的源文件。</target>
        </trans-unit>
        <trans-unit id="dd9b28b9e3c685c0ebb9d5ffb873be86ed7e4a11" translate="yes" xml:space="preserve">
          <source>This option is typically used when building SQLite for an embedded platform with a custom operating system.</source>
          <target state="translated">该选项通常用于为嵌入式平台与自定义操作系统构建SQLite时。</target>
        </trans-unit>
        <trans-unit id="2457ea19543336e39ab5ad959ce6c6fc2134a1fe" translate="yes" xml:space="preserve">
          <source>This option is used to change the name of the &quot;main&quot; database schema. The sole argument is a pointer to a constant UTF8 string which will become the new schema name in place of &quot;main&quot;. SQLite does not make a copy of the new main schema name string, so the application must ensure that the argument passed into this DBCONFIG option is unchanged until after the database connection closes.</source>
          <target state="translated">这个选项用来改变 &quot;main &quot;数据库模式的名称。唯一的参数是一个指向UTF8常量字符串的指针,这个字符串将成为新的模式名,代替 &quot;main&quot;。SQLite不会复制新的主模式名字符串,所以应用程序必须确保传递到这个DBCONFIG选项中的参数保持不变,直到数据库连接关闭之后。</target>
        </trans-unit>
        <trans-unit id="39287b1bd3b31dd8abed9ad5de5fbf18b92fbab1" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable &lt;a href=&quot;../lang_createtrigger&quot;&gt;triggers&lt;/a&gt;. There should be two additional arguments. The first argument is an integer which is 0 to disable triggers, positive to enable triggers or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether triggers are disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the trigger setting is not reported back.</source>
          <target state="translated">此选项用于启用或禁用&lt;a href=&quot;../lang_createtrigger&quot;&gt;触发器&lt;/a&gt;。应该有两个附加参数。第一个参数是一个整数，其值为0以禁用触发器，为正数以启用触发器，或者为负数以保持设置不变。第二个参数是指向整数的指针，该整数写入0或1，以指示在此调用之后是禁用还是启用触发器。第二个参数可以是NULL指针，在这种情况下不会触发触发器设置。</target>
        </trans-unit>
        <trans-unit id="05b777e4219204f514426e561a55ff3f15bc7095" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable &lt;a href=&quot;../lang_createview&quot;&gt;views&lt;/a&gt;. There should be two additional arguments. The first argument is an integer which is 0 to disable views, positive to enable views or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether views are disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the view setting is not reported back.</source>
          <target state="translated">此选项用于启用或禁用&lt;a href=&quot;../lang_createview&quot;&gt;视图&lt;/a&gt;。应该有两个附加参数。第一个参数是一个整数，其值为0表示禁用视图，为正数表示启用视图，为负数表示不更改设置。第二个参数是指向整数的指针，该整数写入0或1以指示在此调用之后是禁用还是启用视图。第二个参数可以是NULL指针，在这种情况下，不会回传视图设置。</target>
        </trans-unit>
        <trans-unit id="3c7692bc9a975790e68229b265337d4ffba19ed3" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt;. There should be two additional arguments. The first argument is an integer which is 0 to disable triggers, positive to enable triggers or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether triggers are disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the trigger setting is not reported back.</source>
          <target state="translated">此选项用于启用或禁用&lt;a href=&quot;lang_createtrigger&quot;&gt;触发器&lt;/a&gt;。应该有两个附加参数。第一个参数是一个整数，其值为0以禁用触发器，为正数以启用触发器，或者为负数以保持设置不变。第二个参数是指向整数的指针，该整数写入0或1，以指示在此调用之后是禁用还是启用触发器。第二个参数可以是NULL指针，在这种情况下不会触发触发器设置。</target>
        </trans-unit>
        <trans-unit id="7a79afada1e049dc560306db03b875b605d30773" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt;. There should be two additional arguments. The first argument is an integer which is 0 to disable views, positive to enable views or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether views are disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the view setting is not reported back.</source>
          <target state="translated">This option is used to enable or disable &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt;. There should be two additional arguments. The first argument is an integer which is 0 to disable views, positive to enable views or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether views are disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the view setting is not reported back.</target>
        </trans-unit>
        <trans-unit id="c1d1e7d85a436fe8e6a223e6a43f70bf20bcb28e" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable the &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface independently of the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function. The &lt;a href=&quot;#sqlite3_enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; API enables or disables both the C-API &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; and the SQL function &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt;. There should be two additional arguments. When the first argument to this interface is 1, then only the C-API is enabled and the SQL function remains disabled. If the first argument to this interface is 0, then both the C-API and the SQL function are disabled. If the first argument is -1, then no changes are made to state of either the C-API or the SQL function. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface is disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the new setting is not reported back.</source>
          <target state="translated">此选项用于独立于&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt; SQL函数启用或禁用&lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;接口。所述&lt;a href=&quot;#sqlite3_enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）&lt;/a&gt; API激活或关闭两个C-API &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;和SQL函数&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt;。应该有两个附加参数。当此接口的第一个参数为1时，则仅启用C-API，并且SQL功能保持禁用状态。如果此接口的第一个参数为0，则C-API和SQL函数均被禁用。如果第一个参数为-1，则不会更改C-API或SQL函数的状态。第二个参数是指向整数的指针，该整数写入0或1以指示在此调用之后是否禁用或启用&lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;接口。第二个参数可以是NULL指针，在这种情况下不会报告新设置。</target>
        </trans-unit>
        <trans-unit id="053a078eadb0638cfc133802b1e15bd819ee981c" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable the &lt;a href=&quot;../fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; function which is part of the &lt;a href=&quot;../fts3&quot;&gt;FTS3&lt;/a&gt; full-text search engine extension. There should be two additional arguments. The first argument is an integer which is 0 to disable fts3_tokenizer() or positive to enable fts3_tokenizer() or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether fts3_tokenizer is disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the new setting is not reported back.</source>
          <target state="translated">此选项用于启用或禁用&lt;a href=&quot;../fts3#f3tknzr&quot;&gt;fts3_tokenizer（）&lt;/a&gt;函数，该函数是&lt;a href=&quot;../fts3&quot;&gt;FTS3&lt;/a&gt;全文搜索引擎扩展的一部分。应该有两个附加参数。第一个参数是一个整数，其值为0以禁用fts3_tokenizer（）或为正数以启用fts3_tokenizer（）或为负数以保持设置不变。第二个参数是指向整数的指针，该整数写入0或1以指示在此调用之后是禁用还是启用fts3_tokenizer。第二个参数可以是NULL指针，在这种情况下不会报告新设置。</target>
        </trans-unit>
        <trans-unit id="0aba264fcea35dcf7c8427203d720dc08ab19f9c" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable the &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; function which is part of the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; full-text search engine extension. There should be two additional arguments. The first argument is an integer which is 0 to disable fts3_tokenizer() or positive to enable fts3_tokenizer() or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether fts3_tokenizer is disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the new setting is not reported back.</source>
          <target state="translated">此选项用于启用或禁用&lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer（）&lt;/a&gt;函数，该函数是&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;全文搜索引擎扩展的一部分。应该有两个附加参数。第一个参数是一个整数，其值为0以禁用fts3_tokenizer（）或为正数以启用fts3_tokenizer（）或为负数以保持设置不变。第二个参数是指向整数的指针，该整数写入0或1以指示在此调用之后是禁用还是启用fts3_tokenizer。第二个参数可以是NULL指针，在这种情况下不会报告新设置。</target>
        </trans-unit>
        <trans-unit id="3b4986571e9b0fde1f22dd6aa95c6a58bcc8dce7" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable the &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface independently of the &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function. The &lt;a href=&quot;enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; API enables or disables both the C-API &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; and the SQL function &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt;. There should be two additional arguments. When the first argument to this interface is 1, then only the C-API is enabled and the SQL function remains disabled. If the first argument to this interface is 0, then both the C-API and the SQL function are disabled. If the first argument is -1, then no changes are made to state of either the C-API or the SQL function. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface is disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the new setting is not reported back.</source>
          <target state="translated">此选项用于独立于&lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt; SQL函数启用或禁用&lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;接口。所述&lt;a href=&quot;enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）&lt;/a&gt; API激活或关闭两个C-API &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;和SQL函数&lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt;。应该有两个附加参数。当此接口的第一个参数为1时，则仅启用C-API，并且SQL功能保持禁用状态。如果此接口的第一个参数为0，则C-API和SQL函数均被禁用。如果第一个参数为-1，则不会更改C-API或SQL函数的状态。第二个参数是指向整数的指针，该整数写入0或1以指示在此调用之后是否禁用或启用&lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;接口。第二个参数可以是NULL指针，在这种情况下不会报告新设置。</target>
        </trans-unit>
        <trans-unit id="7217434ff65eb94c32bf308c55b512fbfab6001b" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable the enforcement of &lt;a href=&quot;../foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt;. There should be two additional arguments. The first argument is an integer which is 0 to disable FK enforcement, positive to enable FK enforcement or negative to leave FK enforcement unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether FK enforcement is off or on following this call. The second parameter may be a NULL pointer, in which case the FK enforcement setting is not reported back.</source>
          <target state="translated">此选项用于启用或禁用&lt;a href=&quot;../foreignkeys&quot;&gt;外键约束的实施&lt;/a&gt;。应该有两个附加参数。第一个参数是一个整数，该整数为0以禁用FK强制执行，为正数以启用FK强制执行，为负数以保持FK强制执行不变。第二个参数是指向整数的指针，在该整数中写入0或1以指示FK强制是在此调用之后关闭还是打开。第二个参数可以是NULL指针，在这种情况下，不会报告回FK强制设置。</target>
        </trans-unit>
        <trans-unit id="4e9535dd92f396e0ccd9b1725779ad05f2042542" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable the enforcement of &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt;. There should be two additional arguments. The first argument is an integer which is 0 to disable FK enforcement, positive to enable FK enforcement or negative to leave FK enforcement unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether FK enforcement is off or on following this call. The second parameter may be a NULL pointer, in which case the FK enforcement setting is not reported back.</source>
          <target state="translated">此选项用于启用或禁用&lt;a href=&quot;foreignkeys&quot;&gt;外键约束的实施&lt;/a&gt;。应该有两个附加参数。第一个参数是一个整数，该整数为0以禁用FK强制执行，为正数以启用FK强制执行，为负数以保持FK强制执行不变。第二个参数是指向整数的指针，在该整数中写入0或1以指示FK强制是在此调用之后关闭还是打开。第二个参数可以是NULL指针，在这种情况下，不会报告回FK强制设置。</target>
        </trans-unit>
        <trans-unit id="b25224fdc16ddfe6de8238e7f19837e56d45d01c" translate="yes" xml:space="preserve">
          <source>This option is used to omit floating-point number support from the SQLite library. When specified, specifying a floating point number as a literal (i.e. &quot;1.01&quot;) results in a parse error.</source>
          <target state="translated">这个选项用于省略SQLite库中的浮点数支持。当指定该选项时,如果将浮点数指定为文字形式(例如 &quot;1.01&quot;),将导致解析错误。</target>
        </trans-unit>
        <trans-unit id="299a6909399a8b4b26dc341e805951ee902fb9f9" translate="yes" xml:space="preserve">
          <source>This option is used to omit the &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; functionality. See also: &lt;a href=&quot;compile#default_automatic_index&quot;&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX&lt;/a&gt;.</source>
          <target state="translated">此选项用于省略&lt;a href=&quot;optoverview#autoindex&quot;&gt;自动索引&lt;/a&gt;功能。另请参阅：&lt;a href=&quot;compile#default_automatic_index&quot;&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b4b919b2428e6408085cdcd9e60a16588061b220" translate="yes" xml:space="preserve">
          <source>This option is used to omit the &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; command from the library. Note that it is useful to define the macros that omit specific pragmas in addition to this, as they may also remove supporting code in other sub-systems. This macro removes the &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; command only.</source>
          <target state="translated">此选项用于从库中省略&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;命令。注意，定义除此以外的宏也很有用，因为它们也可能会删除其他子系统中的支持代码。该宏仅删除&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="9c62439be8833757141bf29ba12fcdc5e143f4a3" translate="yes" xml:space="preserve">
          <source>This option is used to omit the compile-time option diagnostics available in SQLite, including the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get()&lt;/a&gt; C/C++ functions, the &lt;a href=&quot;lang_corefunc#sqlite_compileoption_used&quot;&gt;sqlite_compileoption_used()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get()&lt;/a&gt; SQL functions, and the &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;.</source>
          <target state="translated">此选项用于省略SQLite中可用的编译时选项诊断，包括&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used（）&lt;/a&gt;和&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get（）&lt;/a&gt; C / C ++函数，&lt;a href=&quot;lang_corefunc#sqlite_compileoption_used&quot;&gt;sqlite_compileoption_used（）&lt;/a&gt;和&lt;a href=&quot;lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get（）&lt;/a&gt; SQL函数以及&lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="38860900c0578b43980895e455bb7920237198bd" translate="yes" xml:space="preserve">
          <source>This option is used to omit the compound &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; functionality. &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements that use the UNION, UNION ALL, INTERSECT or EXCEPT compound SELECT operators will cause a parse error.</source>
          <target state="translated">此选项用于省略复合&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;功能。&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;是使用UNION，UNION ALL，INTERSECT或EXCEPT复合SELECT语句运营商将导致解析错误。</target>
        </trans-unit>
        <trans-unit id="1fef9193f2041138de94b7a55c6ac0d8866c0350" translate="yes" xml:space="preserve">
          <source>This option is used to specify additional unicode characters that should be considered as separator characters, even if they are token characters according to Unicode 6.1. All characters in the string that this option is set to are considered separators.</source>
          <target state="translated">这个选项用来指定额外的unicode字符,即使它们是Unicode 6.1的标记字符,也应该被视为分隔符。该选项设置的字符串中的所有字符都被视为分隔符。</target>
        </trans-unit>
        <trans-unit id="b4d01f5260497e72988e92e809b28f4e71ef175b" translate="yes" xml:space="preserve">
          <source>This option is used to specify additional unicode characters that should be considered token characters, even if they are white-space or punctuation characters according to Unicode 6.1. All characters in the string that this option is set to are considered token characters.</source>
          <target state="translated">这个选项用于指定额外的unicode字符,即使是Unicode 6.1规定的空白字符或标点符号,也应视为标记字符。该选项设置的字符串中的所有字符都被视为标记字符。</target>
        </trans-unit>
        <trans-unit id="c4a9266d00b4e2d968e68127ae9c3b66b98515c7" translate="yes" xml:space="preserve">
          <source>This option is used to specify the name of a column for which data is not indexed. Values stored in columns that are not indexed are not matched by MATCH queries. Nor are they recognized by auxiliary functions. A single CREATE VIRTUAL TABLE statement may have any number of notindexed options.</source>
          <target state="translated">这个选项用于指定数据未被索引的列的名称。存储在没有索引的列中的值不会被MATCH查询匹配,也不会被辅助函数识别。它们也不被辅助函数所识别。一条CREATE VIRTUAL TABLE语句可以有任意数量的不索引选项。</target>
        </trans-unit>
        <trans-unit id="4091aa76a32dd6eeb30d11ba0fc9616111651aa8" translate="yes" xml:space="preserve">
          <source>This option is used to specify the uncompress function. It is an error to specify an uncompress function without also specifying a compress function. &lt;a href=&quot;fts3#the_compress_and_uncompress_options&quot;&gt;See below&lt;/a&gt; for details.</source>
          <target state="translated">此选项用于指定解压缩功能。在不指定压缩功能的情况下指定解压缩功能是错误的。&lt;a href=&quot;fts3#the_compress_and_uncompress_options&quot;&gt;有关&lt;/a&gt;详情，请参见下文。</target>
        </trans-unit>
        <trans-unit id="27d1b2d9a48342fb7ec198ba4551e4f29a4a7923" translate="yes" xml:space="preserve">
          <source>This option is useful for detecting when applications (incorrectly) assume that the order of rows in a SELECT without an ORDER BY clause will always be the same.</source>
          <target state="translated">这个选项对于检测应用程序(不正确地)认为没有ORDER BY子句的SELECT中的行的顺序总是相同的情况很有用。</target>
        </trans-unit>
        <trans-unit id="b8889fe26abbab5acf6f1b3b96ae4522f63cbd2c" translate="yes" xml:space="preserve">
          <source>This option limits the maximum width and precision of substitutions for the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; and the other C-language string formatting functions such as &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; and &lt;a href=&quot;c3ref/str_append&quot;&gt;sqlite3_str_appendf()&lt;/a&gt;. This is turn can prevent a hostile or malfunctioning script from using excessive memory by invoking a format such as: &quot;&lt;code&gt;printf('%*s',2147483647,'hi')&lt;/code&gt;&quot;. A value for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="543b32c3fbd0d24e0024e6fd7c7c17a61e1a7b3f" translate="yes" xml:space="preserve">
          <source>This option limits the total amount of memory that SQLite will request from malloc() to</source>
          <target state="translated">这个选项将SQLite从malloc()请求的内存总量限制为</target>
        </trans-unit>
        <trans-unit id="0ff916221ebb2875958a4c995a621fdfe504377b" translate="yes" xml:space="preserve">
          <source>This option may be defined to omit the capability to issue &quot;progress&quot; callbacks during long-running SQL statements. The &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler()&lt;/a&gt; API function is not present in the library.</source>
          <target state="translated">可以定义此选项以省略在长时间运行的SQL语句期间发出&amp;ldquo;进度&amp;rdquo;回调的功能。该库中不存在&lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler（）&lt;/a&gt; API函数。</target>
        </trans-unit>
        <trans-unit id="fec09e7b8a97b18d234467bbff1f92f5f877270a" translate="yes" xml:space="preserve">
          <source>This option may be set to a comma-separated list of positive non-zero integers. For each integer N in the list, a separate index is created in the database file to optimize &lt;a href=&quot;fts3#termprefix&quot;&gt;prefix queries&lt;/a&gt; where the query term is N bytes in length, not including the '*' character, when encoded using UTF-8. &lt;a href=&quot;fts3#the_prefix_option&quot;&gt;See below&lt;/a&gt; for details.</source>
          <target state="translated">可以将此选项设置为以逗号分隔的正非零整数列表。对于列表中的每个整数N ，在使用UTF-8进行编码时，都会在数据库文件中创建一个单独的索引以优化&lt;a href=&quot;fts3#termprefix&quot;&gt;前缀查询&lt;/a&gt;，其中查询项的长度为N个字节，不包括'*'字符。&lt;a href=&quot;fts3#the_prefix_option&quot;&gt;有关&lt;/a&gt;详情，请参见下文。</target>
        </trans-unit>
        <trans-unit id="8c9f3ac023e577c95d719f9b2c33d97d1a3da596" translate="yes" xml:space="preserve">
          <source>This option may be used to modify the set of Unicode general categories that are considered to correspond to token characters. The argument must consist of a space separated list of two-character general category abbreviations (e.g. &quot;Lu&quot; or &quot;Nd&quot;), or of the same with the second character replaced with an asterisk (&quot;*&quot;), interpreted as a glob pattern. The default value is &quot;L* N* Co&quot;.</source>
          <target state="translated">这个选项可以用来修改Unicode通用类别的集合,这些通用类别被认为是与标记字符相对应的。参数必须包含一个以空格分隔的双字符通用类别缩写列表(如 &quot;Lu &quot;或 &quot;Nd&quot;),或以星号(&quot;*&quot;)代替第二个字符,并解释为glob模式。默认值是 &quot;L*N*Co&quot;。</target>
        </trans-unit>
        <trans-unit id="9c262753dfc8e34d6477e70174470eb22dfb8f78" translate="yes" xml:space="preserve">
          <source>This option modifies the query pattern parser in FTS3 such that it supports operators AND and NOT (in addition to the usual OR and NEAR) and also allows query expressions to contain nested parenthesis.</source>
          <target state="translated">这个选项修改了FTS3中的查询模式分析器,使其支持运算符AND和NOT(除了通常的OR和NEAR),并允许查询表达式包含嵌套小括号。</target>
        </trans-unit>
        <trans-unit id="6d1184a1fad2aaee9c295bffada9d4dba260e364" translate="yes" xml:space="preserve">
          <source>This option omits all support for writing to the disk and forces databases to exist in memory only. This option has not been maintained and probably does not work with newer versions of SQLite.</source>
          <target state="translated">这个选项省略了对写入磁盘的所有支持,并强制数据库只存在于内存中。这个选项没有被维护过,可能在较新版本的SQLite中不起作用。</target>
        </trans-unit>
        <trans-unit id="50a1abc30b4ee91bf9953df50f6ee0d6dc4cb18c" translate="yes" xml:space="preserve">
          <source>This option omits an alternative, faster B-Tree balancing routine. Using this option makes SQLite slightly smaller at the expense of making it run slightly slower.</source>
          <target state="translated">这个选项省略了一个替代的、更快的B-Tree平衡例程。使用这个选项可以使SQLite的体积略微变小,但代价是使其运行速度略微变慢。</target>
        </trans-unit>
        <trans-unit id="d570b3f8ad95b26858fd7fbeddae0dd0f1ac312a" translate="yes" xml:space="preserve">
          <source>This option omits both the &lt;a href=&quot;malloc#defaultalloc&quot;&gt;default memory allocator&lt;/a&gt; and the &lt;a href=&quot;malloc#memdebug&quot;&gt;debugging memory allocator&lt;/a&gt; from the build and substitutes a stub memory allocator that always fails. SQLite will not run with this stub memory allocator since it will be unable to allocate memory. But this stub can be replaced at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;,...) or &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;,...). So the net effect of this compile-time option is that it allows SQLite to be compiled and linked against a system library that does not support malloc(), free(), and/or realloc().</source>
          <target state="translated">此选项从构建中忽略&lt;a href=&quot;malloc#defaultalloc&quot;&gt;默认的内存分配器&lt;/a&gt;和&lt;a href=&quot;malloc#memdebug&quot;&gt;调试内存分配器&lt;/a&gt;，并替换始终失败的存根内存分配器。 SQLite将无法使用此存根内存分配器运行，因为它将无法分配内存。但是可以在开始时使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;，...）或&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;，...）替换此存根。因此，此编译时选项的最终效果是，它允许对不支持malloc（），free（）和/或realloc（）的系统库进行编译和链接。</target>
        </trans-unit>
        <trans-unit id="5550296bc5b898d8389bff0bafe61564efcdf3d2" translate="yes" xml:space="preserve">
          <source>This option omits support for &lt;a href=&quot;lang_expr#hexint&quot;&gt;hexadecimal integer literals&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f67843c3cb518fbe115dfafaf7514809b870ff9" translate="yes" xml:space="preserve">
          <source>This option omits support for &lt;a href=&quot;pragma#pragma_function_list&quot;&gt;PRAGMA function_list&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_module_list&quot;&gt;PRAGMA module_list&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_pragma_list&quot;&gt;PRAGMA pragma_list&lt;/a&gt;.</source>
          <target state="translated">此选项省略了支持&lt;a href=&quot;pragma#pragma_function_list&quot;&gt;PRAGMA function_list&lt;/a&gt;，&lt;a href=&quot;pragma#pragma_module_list&quot;&gt;PRAGMA MODULE_LIST&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_pragma_list&quot;&gt;PRAGMA pragma_list&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a55821b0db5795de6378b285741aad2fe64bd6fd" translate="yes" xml:space="preserve">
          <source>This option omits support for TEMP or TEMPORARY tables.</source>
          <target state="translated">这个选项省略了对TEMP或TEMPORARY表的支持。</target>
        </trans-unit>
        <trans-unit id="75dd747eb6da7034a4b5f9d3b3a93668de880788" translate="yes" xml:space="preserve">
          <source>This option omits support for a subset of &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; commands that query and set boolean properties.</source>
          <target state="translated">此选项省略了对查询和设置布尔属性的&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;命令子集的支持。</target>
        </trans-unit>
        <trans-unit id="1e296396a40210ed6c66f92e2002f5643c4f4856" translate="yes" xml:space="preserve">
          <source>This option omits support for optimizations that help statements of the form &quot;INSERT INTO ... SELECT ...&quot; run faster.</source>
          <target state="translated">这个选项省略了对优化的支持,这些优化有助于 &quot;INSERT INTO ....SELECT ...&quot;这样的语句运行速度更快。</target>
        </trans-unit>
        <trans-unit id="c9bd65d56ee2206a853b54ac9d65ed0eaccc6228" translate="yes" xml:space="preserve">
          <source>This option omits support for the &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_profile()&lt;/a&gt; and &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; interfaces and their associated logic.</source>
          <target state="translated">此选项省略了对&lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_profile（）&lt;/a&gt;和&lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace（）&lt;/a&gt;接口及其关联逻辑的支持。</target>
        </trans-unit>
        <trans-unit id="a30f0d1d064421d344c9b42be2dca6717bf88cb6" translate="yes" xml:space="preserve">
          <source>This option omits support for the &lt;a href=&quot;c3ref/vtab&quot;&gt;Virtual Table&lt;/a&gt; mechanism in SQLite.</source>
          <target state="translated">此选项省略了对SQLite中的&lt;a href=&quot;c3ref/vtab&quot;&gt;虚拟表&lt;/a&gt;机制的支持。</target>
        </trans-unit>
        <trans-unit id="26d721f7d82f01b797a61e0e7e4801b3ecce9f78" translate="yes" xml:space="preserve">
          <source>This option omits support for the &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check pragma&lt;/a&gt;.</source>
          <target state="translated">此选项省略了对&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check pragma的&lt;/a&gt;支持。</target>
        </trans-unit>
        <trans-unit id="39729a96f5a26c118c51c00f252de6a1bfa6274f" translate="yes" xml:space="preserve">
          <source>This option omits the &quot;&lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;&quot; (a.k.a. &quot;&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;&quot;) capability.</source>
          <target state="translated">该选项省略了&amp;ldquo; &lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt; &amp;rdquo;（又名&amp;ldquo; &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; &amp;rdquo;）功能。</target>
        </trans-unit>
        <trans-unit id="7b6f231803998cf650a2af3d3a3a9b9230f13c79" translate="yes" xml:space="preserve">
          <source>This option omits the &quot;localtime&quot; modifier from the date and time functions. This option is sometimes useful when trying to compile the date and time functions on a platform that does not support the concept of local time.</source>
          <target state="translated">这个选项省略了日期和时间函数中的 &quot;localtime &quot;修饰符。在不支持当地时间概念的平台上编译日期和时间函数时,这个选项有时会很有用。</target>
        </trans-unit>
        <trans-unit id="d15a997b56bb6d2881d721f3ab9c998f9a495874" translate="yes" xml:space="preserve">
          <source>This option omits the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt;.</source>
          <target state="translated">此选项省略了&lt;a href=&quot;malloc#lookaside&quot;&gt;后备内存分配器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="71559f53bbfd877c056bb7c4c6ba8f68a92f4b43" translate="yes" xml:space="preserve">
          <source>This option omits the entire extension loading mechanism from SQLite, including &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; and &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interfaces.</source>
          <target state="translated">此选项忽略了SQLite的整个扩展加载机制，包括&lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）&lt;/a&gt;和&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="d584fb7ba86013ad6f07889a83d2808e572dd20a" translate="yes" xml:space="preserve">
          <source>This option sets the size limit on &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; files in &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;persistent journal mode&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; and on the size of the write-ahead log file in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. When this compile-time option is omitted there is no upper bound on the size of the rollback journals or write-ahead logs. The journal file size limit can be changed at run-time using the &lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;journal_size_limit pragma&lt;/a&gt;.</source>
          <target state="translated">此选项在&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;持久日志模式&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;排他锁定模式下&lt;/a&gt;设置&lt;a href=&quot;lockingv3#rollback&quot;&gt;回滚日志&lt;/a&gt;文件的大小限制，在&lt;a href=&quot;wal&quot;&gt;WAL模式下设置&lt;/a&gt;预写日志文件的大小限制。省略此编译时选项时，回滚日志或预写日志的大小没有上限。日志文件大小限制可以在运行时使用&lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;journal_size_limit pragma&lt;/a&gt;更改。</target>
        </trans-unit>
        <trans-unit id="a7ed22f566a23185b972efa8699f5831a4e8d150" translate="yes" xml:space="preserve">
          <source>This option should be set to &quot;0&quot;, &quot;1&quot; or &quot;2&quot;. The default value is &quot;1&quot;. If it is set to &quot;1&quot; or &quot;2&quot;, then diacritics are removed from Latin script characters as described above. However, if it is set to &quot;1&quot;, then diacritics are not removed in the fairly uncommon case where a single unicode codepoint is used to represent a character with more that one diacritic. For example, diacritics are not removed from codepoint 0x1ED9 (&quot;LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW&quot;). This is technically a bug, but cannot be fixed without creating backwards compatibility problems. If this option is set to &quot;2&quot;, then diacritics are correctly removed from all Latin characters.</source>
          <target state="translated">该选项应设置为 &quot;0&quot;、&quot;1 &quot;或 &quot;2&quot;。默认值是 &quot;1&quot;。如果它被设置为 &quot;1 &quot;或 &quot;2&quot;,那么拉丁字母字符中的双标点符号将如上所述被移除。然而,如果它被设置为 &quot;1&quot;,那么在相当少见的情况下,当一个单一的unicode码点被用来表示一个有多个重音符号的字符时,重音符号就不会被移除。例如,在代码点0x1ED9(&quot;LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW&quot;)中没有去除双音符。这在技术上是一个错误,但如果不造成向后的兼容性问题,就无法修复。如果这个选项被设置为 &quot;2&quot;,那么所有拉丁字符中的双音符就会被正确地删除。</target>
        </trans-unit>
        <trans-unit id="feb5bc303a82732e4bebbca22fa198d9bb5a37e5" translate="yes" xml:space="preserve">
          <source>This option takes three additional arguments that determine the &lt;a href=&quot;../malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; configuration for the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument (the third parameter to &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; is a pointer to a memory buffer to use for lookaside memory. The first argument after the SQLITE_DBCONFIG_LOOKASIDE verb may be NULL in which case SQLite will allocate the lookaside buffer itself using &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The second argument is the size of each lookaside buffer slot. The third argument is the number of slots. The size of the buffer in the first argument must be greater than or equal to the product of the second and third arguments. The buffer must be aligned to an 8-byte boundary. If the second argument to SQLITE_DBCONFIG_LOOKASIDE is not a multiple of 8, it is internally rounded down to the next smaller multiple of 8. The lookaside memory configuration for a database connection can only be changed when that connection is not currently using lookaside memory, or in other words when the &quot;current value&quot; returned by &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status&lt;/a&gt;(D,&lt;a href=&quot;c_config_covering_index_scan#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt;,...) is zero. Any attempt to change the lookaside memory configuration when lookaside memory is in use leaves the configuration unchanged and returns &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="translated">此选项采用三个附加参数来确定&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;的&lt;a href=&quot;../malloc#lookaside&quot;&gt;后备内存分配器&lt;/a&gt;配置。第一个参数（&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;的第三个参数是指向用于后备内存的内存缓冲区的指针。SQLITE_DBCONFIG_LOOKASIDE动词后的第一个参数可能为NULL，在这种情况下，SQLite将使用&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;分配后备缓冲区本身。。第二个参数是每个后备缓冲区的大小。第三个参数是插槽数。第一个参数中的缓冲区大小必须大于或等于第二个和第三个参数的乘积。缓冲区必须与8字节边界对齐。如果SQLITE_DBCONFIG_LOOKASIDE的第二个参数不是8的倍数，它会在内部舍入为8的下一个较小倍数。仅当数据库连接的后备内存配置当前未使用后备内存时，才可以更改该数据库连接的后备内存配置。换句话说，当&lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status&lt;/a&gt;返回的&amp;ldquo;当前值&amp;rdquo; （D，&lt;a href=&quot;c_config_covering_index_scan#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt;，...）为零。在使用后备内存时，任何更改后备内存配置的尝试都&lt;a href=&quot;../rescode#busy&quot;&gt;将使&lt;/a&gt;配置保持不变，并返回SQLITE_BUSY。</target>
        </trans-unit>
        <trans-unit id="ae3ddbf7ef0dc412e99f290afefb3dbddaa1ab55" translate="yes" xml:space="preserve">
          <source>This option takes three additional arguments that determine the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; configuration for the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument (the third parameter to &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; is a pointer to a memory buffer to use for lookaside memory. The first argument after the SQLITE_DBCONFIG_LOOKASIDE verb may be NULL in which case SQLite will allocate the lookaside buffer itself using &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The second argument is the size of each lookaside buffer slot. The third argument is the number of slots. The size of the buffer in the first argument must be greater than or equal to the product of the second and third arguments. The buffer must be aligned to an 8-byte boundary. If the second argument to SQLITE_DBCONFIG_LOOKASIDE is not a multiple of 8, it is internally rounded down to the next smaller multiple of 8. The lookaside memory configuration for a database connection can only be changed when that connection is not currently using lookaside memory, or in other words when the &quot;current value&quot; returned by &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status&lt;/a&gt;(D,&lt;a href=&quot;#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt;,...) is zero. Any attempt to change the lookaside memory configuration when lookaside memory is in use leaves the configuration unchanged and returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="translated">此选项采用三个附加参数来确定&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;的&lt;a href=&quot;malloc#lookaside&quot;&gt;后备内存分配器&lt;/a&gt;配置。第一个参数（&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;的第三个参数是指向用于后备内存的内存缓冲区的指针。SQLITE_DBCONFIG_LOOKASIDE动词后的第一个参数可能为NULL，在这种情况下，SQLite将使用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;分配后备缓冲区本身。。第二个参数是每个后备缓冲区的大小。第三个参数是插槽数。第一个参数中的缓冲区大小必须大于或等于第二个和第三个参数的乘积。缓冲区必须与8字节边界对齐。如果SQLITE_DBCONFIG_LOOKASIDE的第二个参数不是8的倍数，它会在内部舍入为8的下一个较小倍数。仅当数据库连接的后备内存配置当前未使用后备内存时，才可以更改该数据库连接的后备内存配置。换句话说，当&lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status&lt;/a&gt;返回的&amp;ldquo;当前值&amp;rdquo; （D，&lt;a href=&quot;#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt;，...）为零。在使用后备内存时，任何更改后备内存配置的尝试都&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;将使&lt;/a&gt;配置保持不变，并返回SQLITE_BUSY。</target>
        </trans-unit>
        <trans-unit id="ba38f20f7029807295f199c46762e2a8e9ec46b2" translate="yes" xml:space="preserve">
          <source>This page contains all C-language interface information in a single HTML file. The same information is also available broken out into &lt;a href=&quot;https://sqlite.org/session/intro.html&quot;&gt;lots of small pages&lt;/a&gt; for easier viewing, if you prefer.</source>
          <target state="translated">此页面在单个HTML文件中包含所有C语言界面信息。如果您愿意，也可以将相同的信息分成&lt;a href=&quot;https://sqlite.org/session/intro.html&quot;&gt;很多小页面&lt;/a&gt;，以便于查看。</target>
        </trans-unit>
        <trans-unit id="c894452ecdb5719e75b3532de3158fbd553c90da" translate="yes" xml:space="preserve">
          <source>This page defines the C-language interface to the SQLite &lt;a href=&quot;sessionintro&quot;&gt;session extension&lt;/a&gt;. This is not a tutorial. These pages are designed to be precise, not easy to read. A tutorial is &lt;a href=&quot;sessionintro&quot;&gt;available separately&lt;/a&gt;.</source>
          <target state="translated">该页面定义了SQLite &lt;a href=&quot;sessionintro&quot;&gt;会话扩展&lt;/a&gt;的C语言接口。这不是教程。这些页面设计得很精确，不容易阅读。教程&lt;a href=&quot;sessionintro&quot;&gt;可单独获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="17b8a8f3cb3fe57cc88a96142bed282e75d22786" translate="yes" xml:space="preserve">
          <source>This page demonstrates how to use triggers to implement undo/redo logic for an application that uses SQLite as its &lt;a href=&quot;appfileformat&quot;&gt;application file format&lt;/a&gt;.</source>
          <target state="translated">该页面演示了如何使用触发器为使用SQLite作为其&lt;a href=&quot;appfileformat&quot;&gt;应用程序文件格式&lt;/a&gt;的应用程序实现撤消/重做逻辑。</target>
        </trans-unit>
        <trans-unit id="e34958625ac04bc1ac3a1a6e0735cfa01d4d7986" translate="yes" xml:space="preserve">
          <source>This page highlights some of the characteristics of SQLite that are unusual and which make SQLite different from many other SQL database engines.</source>
          <target state="translated">本页重点介绍了SQLite的一些不同寻常的特性,这些特性使得SQLite与许多其他SQL数据库引擎不同。</target>
        </trans-unit>
        <trans-unit id="c95782bb823ae8ab36f53a6f092ceeb01d076bbe" translate="yes" xml:space="preserve">
          <source>This page is intended to be a precise and detailed specification. For a tutorial introductions, see instead:</source>
          <target state="translated">本页旨在精确和详细的规范。关于教程介绍,请参见。</target>
        </trans-unit>
        <trans-unit id="fbcb2c48721c5a151bcbee73ca17847e3bcd77c1" translate="yes" xml:space="preserve">
          <source>This page provides a high-level summary of changes to SQLite. For more detail, see the Fossil checkin logs at &lt;a href=&quot;http://www.sqlite.org/src/timeline&quot;&gt; http://www.sqlite.org/src/timeline&lt;/a&gt; and &lt;a href=&quot;http://www.sqlite.org/src/timeline?t=release&quot;&gt; http://www.sqlite.org/src/timeline?t=release&lt;/a&gt;. See the &lt;a href=&quot;https://sqlite.org/chronology.html&quot;&gt;chronology&lt;/a&gt; a succinct listing of releases.</source>
          <target state="translated">此页面提供了SQLite更改的高级摘要。有关更多详细信息，请参见&lt;a href=&quot;http://www.sqlite.org/src/timeline&quot;&gt;http://www.sqlite.org/src/timeline&lt;/a&gt;和&lt;a href=&quot;http://www.sqlite.org/src/timeline?t=release&quot;&gt;http://www.sqlite.org/src/timeline?t=release上&lt;/a&gt;的Fossil签入日志。请&lt;a href=&quot;https://sqlite.org/chronology.html&quot;&gt;按时间顺序&lt;/a&gt;简要列出发行版。</target>
        </trans-unit>
        <trans-unit id="5475000272cca06dc30e6a01a60b47e85642d9ec" translate="yes" xml:space="preserve">
          <source>This parameter is similar to DBSTATUS_CACHE_USED, except that if a pager cache is shared between two or more connections the bytes of heap memory used by that pager cache is divided evenly between the attached connections. In other words, if none of the pager caches associated with the database connection are shared, this request returns the same value as DBSTATUS_CACHE_USED. Or, if one or more or the pager caches are shared, the value returned by this call will be smaller than that returned by DBSTATUS_CACHE_USED. The highwater mark associated with SQLITE_DBSTATUS_CACHE_USED_SHARED is always 0.</source>
          <target state="translated">这个参数与DBSTATUS_CACHE_USED类似,不同的是,如果一个寻呼机缓存在两个或多个连接之间共享,那么该寻呼机缓存所使用的堆内存字节将在所连接的连接之间平均分配。换句话说,如果与数据库连接相关的寻呼机缓存都不共享,这个请求返回的值与DBSTATUS_CACHE_USED相同。或者,如果一个或多个或寻呼机缓存是共享的,这个调用返回的值将小于DBSTATUS_CACHE_USED返回的值。与SQLITE_DBSTATUS_CACHE_USED_SHARED相关联的高水位标志总是0。</target>
        </trans-unit>
        <trans-unit id="45093e4716ae49eb14650b76fbdcb71b112d6752" translate="yes" xml:space="preserve">
          <source>This parameter is the current amount of memory checked out using &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, either directly or indirectly. The figure includes calls made to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; by the application and internal memory usage by the SQLite library. Auxiliary page-cache memory controlled by &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; is not included in this parameter. The amount returned is the sum of the allocation sizes as reported by the xSize method in &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;.</source>
          <target state="translated">此参数是使用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;直接或间接检出的当前内存量。该图包括应用程序对&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;的调用以及SQLite库对内部内存的使用。由&lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;控制的辅助页面高速缓存存储器不包括在此参数中。返回的数量是xsize方法在&lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods中&lt;/a&gt;报告的分配大小的总和。</target>
        </trans-unit>
        <trans-unit id="01bdf9cb94894d18cc4c5e31ed1dd67a9595bbe8" translate="yes" xml:space="preserve">
          <source>This parameter is the current amount of memory checked out using &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, either directly or indirectly. The figure includes calls made to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; by the application and internal memory usage by the SQLite library. Auxiliary page-cache memory controlled by &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; is not included in this parameter. The amount returned is the sum of the allocation sizes as reported by the xSize method in &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;.</source>
          <target state="translated">此参数是使用&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;直接或间接检出的当前内存量。该图包括应用程序对&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;的调用以及SQLite库对内部内存的使用。由&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;控制的辅助页面高速缓存存储器不包括在此参数中。返回的数量是xsize方法在&lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods中&lt;/a&gt;报告的分配大小的总和。</target>
        </trans-unit>
        <trans-unit id="87bf008f327b3b848c63d8cad43c4d0127a86a19" translate="yes" xml:space="preserve">
          <source>This parameter records the largest memory allocation request handed to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; (or their internal equivalents). Only the value returned in the *pHighwater parameter to &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status()&lt;/a&gt; is of interest. The value written into the *pCurrent parameter is undefined.</source>
          <target state="translated">此参数记录传递给&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;（或其内部等效项）的最大内存分配请求。仅关注* p​​Highwater参数中返回给&lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status（）的&lt;/a&gt;值。写入* pCurrent参数的值是不确定的。</target>
        </trans-unit>
        <trans-unit id="b8177250f0bf5e0ac2bcf219826fc36ccb3e8b06" translate="yes" xml:space="preserve">
          <source>This parameter records the largest memory allocation request handed to &lt;a href=&quot;../malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;. Only the value returned in the *pHighwater parameter to &lt;a href=&quot;status&quot;&gt;sqlite3_status()&lt;/a&gt; is of interest. The value written into the *pCurrent parameter is undefined.</source>
          <target state="translated">此参数记录传递给&lt;a href=&quot;../malloc#pagecache&quot;&gt;pagecache内存分配器&lt;/a&gt;的最大内存分配请求。仅关注* p​​Highwater参数中返回给&lt;a href=&quot;status&quot;&gt;sqlite3_status（）的&lt;/a&gt;值。写入* pCurrent参数的值是不确定的。</target>
        </trans-unit>
        <trans-unit id="393f3b702f2e6c0a4e019aad1ee82b57fe72cd84" translate="yes" xml:space="preserve">
          <source>This parameter records the largest memory allocation request handed to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; (or their internal equivalents). Only the value returned in the *pHighwater parameter to &lt;a href=&quot;status&quot;&gt;sqlite3_status()&lt;/a&gt; is of interest. The value written into the *pCurrent parameter is undefined.</source>
          <target state="translated">此参数记录传递给&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;或&lt;a href=&quot;free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;（或其内部等效项）的最大内存分配请求。仅关注* p​​Highwater参数中返回给&lt;a href=&quot;status&quot;&gt;sqlite3_status（）的&lt;/a&gt;值。写入* pCurrent参数的值是不确定的。</target>
        </trans-unit>
        <trans-unit id="564d1fbcfc60fdaedbed1032bf2fd462555b60f6" translate="yes" xml:space="preserve">
          <source>This parameter records the largest memory allocation request handed to &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;. Only the value returned in the *pHighwater parameter to &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status()&lt;/a&gt; is of interest. The value written into the *pCurrent parameter is undefined.</source>
          <target state="translated">此参数记录传递给&lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache内存分配器&lt;/a&gt;的最大内存分配请求。仅关注* p​​Highwater参数中返回给&lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status（）的&lt;/a&gt;值。写入* pCurrent参数的值是不确定的。</target>
        </trans-unit>
        <trans-unit id="64d736a9df1c88312c645f6820d596570b17758b" translate="yes" xml:space="preserve">
          <source>This parameter records the largest memory allocation request handed to the &lt;a href=&quot;../malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;. Only the value returned in the *pHighwater parameter to &lt;a href=&quot;status&quot;&gt;sqlite3_status()&lt;/a&gt; is of interest. The value written into the *pCurrent parameter is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f746ca9a95438a262dd8ecb82737decdd93a0a" translate="yes" xml:space="preserve">
          <source>This parameter records the largest memory allocation request handed to the &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;. Only the value returned in the *pHighwater parameter to &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status()&lt;/a&gt; is of interest. The value written into the *pCurrent parameter is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e7936cbdee9e2eb1bb98fbfe6edbf522e37ef4" translate="yes" xml:space="preserve">
          <source>This parameter records the number of separate memory allocations currently checked out.</source>
          <target state="translated">该参数记录了当前签出的独立内存分配数量。</target>
        </trans-unit>
        <trans-unit id="cf9c08cd996cbec55637b0a188d75a636f637583" translate="yes" xml:space="preserve">
          <source>This parameter returns the approximate number of bytes of heap and lookaside memory used by all prepared statements associated with the database connection. The highwater mark associated with SQLITE_DBSTATUS_STMT_USED is always 0.</source>
          <target state="translated">这个参数返回与数据库连接相关联的所有准备好的语句所使用的堆和lookaside内存的大约字节数。与SQLITE_DBSTATUS_STMT_USED相关联的高水位标志总是0。</target>
        </trans-unit>
        <trans-unit id="ec61ce5ecfd88d74d32d14b1a1a33c077c0d1415" translate="yes" xml:space="preserve">
          <source>This parameter returns the approximate number of bytes of heap memory used by all pager caches associated with the database connection. The highwater mark associated with SQLITE_DBSTATUS_CACHE_USED is always 0.</source>
          <target state="translated">这个参数返回与数据库连接相关联的所有寻呼机缓存所使用的堆内存的大概字节数。与SQLITE_DBSTATUS_CACHE_USED相关联的高水位标志总是0。</target>
        </trans-unit>
        <trans-unit id="f3bc4fe0cf826c482abac176d6762a6d942bb530" translate="yes" xml:space="preserve">
          <source>This parameter returns the approximate number of bytes of heap memory used to store the schema for all databases associated with the connection - main, temp, and any &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed databases. The full amount of memory used by the schemas is reported, even if the schema memory is shared with other database connections due to &lt;a href=&quot;../sharedcache&quot;&gt;shared cache mode&lt;/a&gt; being enabled. The highwater mark associated with SQLITE_DBSTATUS_SCHEMA_USED is always 0.</source>
          <target state="translated">此参数返回用于存储与连接关联的所有数据库（主数据库，临时数据库和任何&lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;数据库）的模式的堆内存的大约字节数。即使由于启用了&lt;a href=&quot;../sharedcache&quot;&gt;共享缓存模式&lt;/a&gt;而与其他数据库连接共享架构内存，也会报告架构使用的内存总量。与SQLITE_DBSTATUS_SCHEMA_USED关联的高水位线始终为0。</target>
        </trans-unit>
        <trans-unit id="b848e7fbcecb9e3547155ffa2bb4d624a93e8ec6" translate="yes" xml:space="preserve">
          <source>This parameter returns the approximate number of bytes of heap memory used to store the schema for all databases associated with the connection - main, temp, and any &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed databases. The full amount of memory used by the schemas is reported, even if the schema memory is shared with other database connections due to &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; being enabled. The highwater mark associated with SQLITE_DBSTATUS_SCHEMA_USED is always 0.</source>
          <target state="translated">此参数返回用于存储与连接关联的所有数据库（主数据库，临时数据库和任何&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;数据库）的模式的堆内存的大约字节数。即使由于启用了&lt;a href=&quot;sharedcache&quot;&gt;共享缓存模式&lt;/a&gt;而与其他数据库连接共享架构内存，也会报告架构使用的内存总量。与SQLITE_DBSTATUS_SCHEMA_USED关联的高水位线始终为0。</target>
        </trans-unit>
        <trans-unit id="a6814e9402bd718137686f1d55de51f53b7d680a" translate="yes" xml:space="preserve">
          <source>This parameter returns the number malloc attempts that might have been satisfied using lookaside memory but failed due to all lookaside memory already being in use. Only the high-water value is meaningful; the current value is always zero.</source>
          <target state="translated">这个参数返回可能使用lookaside内存满足的malloc尝试次数,但由于所有lookaside内存已经被使用而失败。只有高水位值才有意义,当前值始终为零。</target>
        </trans-unit>
        <trans-unit id="a0c69cbe3d9c323ac8bc99255ae1a5f0fdf34b7a" translate="yes" xml:space="preserve">
          <source>This parameter returns the number malloc attempts that might have been satisfied using lookaside memory but failed due to the amount of memory requested being larger than the lookaside slot size. Only the high-water value is meaningful; the current value is always zero.</source>
          <target state="translated">这个参数返回使用lookaside内存可能满足的malloc尝试次数,但由于请求的内存量大于lookaside插槽大小而失败。只有高水位值才有意义,当前值始终为零。</target>
        </trans-unit>
        <trans-unit id="784f52e8abbe06e6dd208856ce82a30603bacb4b" translate="yes" xml:space="preserve">
          <source>This parameter returns the number malloc attempts that were satisfied using lookaside memory. Only the high-water value is meaningful; the current value is always zero.</source>
          <target state="translated">这个参数返回使用lookaside内存满足的malloc尝试次数。只有高水位值才有意义,当前值始终为零。</target>
        </trans-unit>
        <trans-unit id="cc0e40686d40fc1dc39dc4ea777a5b751b8b8271" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of bytes of page cache allocation which could not be satisfied by the &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; buffer and where forced to overflow to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The returned value includes allocations that overflowed because they where too large (they were larger than the &quot;sz&quot; parameter to &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;) and allocations that overflowed because no space was left in the page cache.</source>
          <target state="translated">此参数返回&lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;缓冲区无法满足的页面高速缓存分配的字节数，并强制将其溢出到&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;。返回的值包括由于分配太大而溢出的分配（它们大于&lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;的&amp;ldquo; sz&amp;rdquo;参数）和由于页面高速缓存中没有剩余空间而导致分配溢出的分配。</target>
        </trans-unit>
        <trans-unit id="1df7262bbdc4130b7cdd11ed7c458ceceae08c22" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of bytes of page cache allocation which could not be satisfied by the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; buffer and where forced to overflow to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The returned value includes allocations that overflowed because they where too large (they were larger than the &quot;sz&quot; parameter to &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;) and allocations that overflowed because no space was left in the page cache.</source>
          <target state="translated">此参数返回&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;缓冲区无法满足的页面高速缓存分配的字节数，并强制将其溢出到&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;。返回的值包括由于分配太大而溢出的分配（它们大于&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;的&amp;ldquo; sz&amp;rdquo;参数）和由于页面高速缓存中没有剩余空间而导致分配溢出的分配。</target>
        </trans-unit>
        <trans-unit id="b382d85f918ffb35600f5c2612295ce2f5d3c59a" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of dirty cache entries that have been written to disk in the middle of a transaction due to the page cache overflowing. Transactions are more efficient if they are written to disk all at once. When pages spill mid-transaction, that introduces additional overhead. This parameter can be used help identify inefficiencies that can be resolve by increasing the cache size.</source>
          <target state="translated">该参数返回在事务中间由于页面缓存溢出而被写入磁盘的脏缓存条目数。如果事务一次全部写入磁盘,效率会更高。当页面在事务中间溢出时,会带来额外的开销。这个参数可以用来帮助识别效率低下的情况,可以通过增加缓存大小来解决。</target>
        </trans-unit>
        <trans-unit id="3475d60ae6206bcbd673ce958d5051acadbef20d" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of dirty cache entries that have been written to disk in the middle of a transaction due to the page cache overflowing. Transactions are more efficient if they are written to disk all at once. When pages spill mid-transaction, that introduces additional overhead. This parameter can be used help identify inefficiencies that can be resolved by increasing the cache size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4add896ad21b8491b3b9cbc64b507c0e7d258f86" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of dirty cache entries that have been written to disk. Specifically, the number of pages written to the wal file in wal mode databases, or the number of pages written to the database file in rollback mode databases. Any pages written as part of transaction rollback or database recovery operations are not included. If an IO or other error occurs while writing a page to disk, the effect on subsequent SQLITE_DBSTATUS_CACHE_WRITE requests is undefined. The highwater mark associated with SQLITE_DBSTATUS_CACHE_WRITE is always 0.</source>
          <target state="translated">该参数返回已写入磁盘的脏缓存条目数。具体来说,就是在wal模式数据库中写入wal文件的页数,或者在回滚模式数据库中写入数据库文件的页数。任何作为事务回滚或数据库恢复操作的一部分而写入的页数都不包括在内。如果在向磁盘写入页面时发生IO或其他错误,对后续SQLITE_DBSTATUS_CACHE_WRITE请求的影响是未定义的。与SQLITE_DBSTATUS_CACHE_WRITE相关联的高水位标记始终为0。</target>
        </trans-unit>
        <trans-unit id="69935728c544ae1a697199dc6c173a0425e6fda2" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of lookaside memory slots currently checked out.</source>
          <target state="translated">该参数返回当前签出的lookaside内存槽数。</target>
        </trans-unit>
        <trans-unit id="a266b665a2f2d9def7548328ed2be49c55b4af7e" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of malloc attempts that were satisfied using lookaside memory. Only the high-water value is meaningful; the current value is always zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8bdabdecaacb45640f2cbeb00ef8072cec5611a" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of pager cache hits that have occurred. The highwater mark associated with SQLITE_DBSTATUS_CACHE_HIT is always 0.</source>
          <target state="translated">这个参数返回已经发生的寻呼机缓存点击次数。与SQLITE_DBSTATUS_CACHE_HIT相关联的高水位标志总是0。</target>
        </trans-unit>
        <trans-unit id="a1a0936c69215c7750450f05188a928a77f51678" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of pager cache misses that have occurred. The highwater mark associated with SQLITE_DBSTATUS_CACHE_MISS is always 0.</source>
          <target state="translated">这个参数返回已经发生的寻呼机缓存错过的次数。与SQLITE_DBSTATUS_CACHE_MISS相关联的高水位标志总是0。</target>
        </trans-unit>
        <trans-unit id="62efb57b98feebe4577753d45e38ef4eace35cab" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of pages used out of the &lt;a href=&quot;../malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt; that was configured using &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The value returned is in pages, not in bytes.</source>
          <target state="translated">此参数返回使用&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;配置的页面&lt;a href=&quot;../malloc#pagecache&quot;&gt;缓存内存分配器&lt;/a&gt;中已使用的页面数。返回的值以页为单位，而不是以字节为单位。</target>
        </trans-unit>
        <trans-unit id="3d50e93c0353d6a987ae81a3f776523fd382a6cc" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of pages used out of the &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt; that was configured using &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The value returned is in pages, not in bytes.</source>
          <target state="translated">此参数返回使用&lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;配置的页面&lt;a href=&quot;malloc#pagecache&quot;&gt;缓存内存分配器&lt;/a&gt;中已使用的页面数。返回的值以页为单位，而不是以字节为单位。</target>
        </trans-unit>
        <trans-unit id="c53ec125616f6c12d3da713a54e88d2031114fcb" translate="yes" xml:space="preserve">
          <source>This parameter returns zero for the current value if and only if all foreign key constraints (deferred or immediate) have been resolved. The highwater mark is always 0.</source>
          <target state="translated">如果且仅当所有的外键约束(递延或即时)都已被解决,该参数对当前值返回0。高水位线始终为0。</target>
        </trans-unit>
        <trans-unit id="a9b0527c8ca1034e0c3fe99b84c3e116d1b7eb73" translate="yes" xml:space="preserve">
          <source>This particular upper bound is untested since the developers do not have access to hardware capable of reaching this limit. However, tests do verify that SQLite behaves correctly and sanely when a database reaches the maximum file size of the underlying filesystem (which is usually much less than the maximum theoretical database size) and when a database is unable to grow due to disk space exhaustion.</source>
          <target state="translated">这个特定的上限是未经测试的,因为开发人员无法获得能够达到这个极限的硬件。然而,测试确实验证了当数据库达到底层文件系统的最大文件大小(通常远小于数据库的最大理论大小),以及当数据库因磁盘空间耗尽而无法增长时,SQLite表现得正确而理智。</target>
        </trans-unit>
        <trans-unit id="81929be5939c881096cfb3fe31776e243ea07fe4" translate="yes" xml:space="preserve">
          <source>This pragma can be used to help the ANALYZE command run faster on large databases. The results of analysis are not as good when only part of each index is examined, but the results are usually good enough. Setting N to 100 or 1000 allows the ANALYZE command to run very quickly, even on multi-gigabyte database files. This pragma is particularly useful in combination with &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0657d8e0799efb6b3e706990d12dd141b3fb62ea" translate="yes" xml:space="preserve">
          <source>This pragma can only lower the heap limit, never raise it. The C-language interface &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64()&lt;/a&gt; must be used to raise the heap limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7efda67e025441ca7525899af5b6354ff74a512" translate="yes" xml:space="preserve">
          <source>This pragma causes the database connection on which it is invoked to free up as much memory as it can, by calling &lt;a href=&quot;c3ref/db_release_memory&quot;&gt;sqlite3_db_release_memory()&lt;/a&gt;.</source>
          <target state="translated">此编译指示通过调用&lt;a href=&quot;c3ref/db_release_memory&quot;&gt;sqlite3_db_release_memory（）使&lt;/a&gt;调用它的数据库连接释放尽可能多的内存。</target>
        </trans-unit>
        <trans-unit id="f69354dd852353205605bc71b9cf56c1b9de8e3e" translate="yes" xml:space="preserve">
          <source>This pragma does a low-level formatting and consistency check of the database. The integrity_check pragma look for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f777ea86721cabf6a34809d49c7198fa24090a8b" translate="yes" xml:space="preserve">
          <source>This pragma does an integrity check of the entire database. The integrity_check pragma looks for out-of-order records, missing pages, malformed records, missing index entries, and UNIQUE, CHECK, and NOT NULL constraint errors. If the integrity_check pragma finds problems, strings are returned (as multiple rows with a single column per row) which describe the problems. Pragma integrity_check will return at most</source>
          <target state="translated">这个pragma对整个数据库进行完整性检查。integrity_check pragma 会检查失序记录、缺页、畸形记录、缺失索引条目以及 UNIQUE、CHECK 和 NOT NULL 约束错误。如果 integrity_check pragma 发现了问题,就会返回描述问题的字符串(作为多行,每行一列)。参数 integrity_check 最多只能返回</target>
        </trans-unit>
        <trans-unit id="d85860b039a63de256f402e6d6762d68de4406bf" translate="yes" xml:space="preserve">
          <source>This pragma enables or disables the enforcement of CHECK constraints. The default setting is off, meaning that CHECK constraints are enforced by default.</source>
          <target state="translated">这个pragma启用或禁用CHECK约束的执行。默认设置是关闭,意味着CHECK约束条件是默认执行的。</target>
        </trans-unit>
        <trans-unit id="2c0f6dec458913f5b6b49b019227adc4aaee9eed" translate="yes" xml:space="preserve">
          <source>This pragma invokes the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64()&lt;/a&gt; interface with the argument N, if N is specified and N is a positive integer that is less than the current hard heap limit. The hard_heap_limit pragma always returns the same integer that would be returned by the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64&lt;/a&gt;(-1) C-language function. That is to say, it always returns the value of the hard heap limit that is set after any changes imposed by this PRAGMA.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc93e52c19bbd4f2114a2157aba5ec2280234488" translate="yes" xml:space="preserve">
          <source>This pragma invokes the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface with the argument N, if N is specified and is a non-negative integer. The soft_heap_limit pragma always returns the same integer that would be returned by the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64&lt;/a&gt;(-1) C-language function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bacd85c546ef4ea41bfa44a9338d7347c9ec6db4" translate="yes" xml:space="preserve">
          <source>This pragma invokes the &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface with the argument N, if N is specified and is a non-negative integer. The soft_heap_limit pragma always returns the same integer that would be returned by the &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64&lt;/a&gt;(-1) C-language function.</source>
          <target state="translated">如果指定N并且它是一个非负整数，则该编译指示使用参数N 调用&lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64（）&lt;/a&gt;接口。soft_heap_limit杂注总是返回与&lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64&lt;/a&gt;（-1）C语言函数返回的整数相同的整数。</target>
        </trans-unit>
        <trans-unit id="e5367a74af180a6816189a47cadfc307e646cf0c" translate="yes" xml:space="preserve">
          <source>This pragma is a no-op within a transaction; foreign key constraint enforcement may only be enabled or disabled when there is no pending &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; or &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;.</source>
          <target state="translated">这种语用是交易中的禁忌。仅当没有待处理的&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;或&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;时，才可以启用或禁用外键约束强制。</target>
        </trans-unit>
        <trans-unit id="7664f5360eeae6cb14733319d33c60e55709bd68" translate="yes" xml:space="preserve">
          <source>This pragma is a thin wrapper around the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt;,...) interface.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;实用&lt;/a&gt;程序是&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，SQLITE_LIMIT_WORKER_THREADS，...）接口周围的薄包装。</target>
        </trans-unit>
        <trans-unit id="db34d966e31d8d00cada3d5a5b19ca1db1e53aa4" translate="yes" xml:space="preserve">
          <source>This pragma is a wrapper around the &lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint()&lt;/a&gt; C interface. All automatic checkpoints are &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;PASSIVE&lt;/a&gt;.</source>
          <target state="translated">该编译指示是&lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint（）&lt;/a&gt; C接口的包装。所有自动检查点均为&lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;PASSIVE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="030bb1c5ea97fb7c877a4d85a6707ab503f61e3b" translate="yes" xml:space="preserve">
          <source>This pragma is intended for use when debugging SQLite itself. It is only available when the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">该杂注旨在在调试SQLite本身时使用。仅在使用&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;编译时选项时可用。</target>
        </trans-unit>
        <trans-unit id="e56acb3f3acf3108d2bcfa664b49bb38684bdece" translate="yes" xml:space="preserve">
          <source>This pragma is provided as a work-around for older programs that contain code that expect the incomplete behavior of &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; found in older versions of SQLite. New applications should leave this flag turned off.</source>
          <target state="translated">提供此杂项作为变通方法，用于较旧的程序，这些较旧的程序包含的代码期望在较旧版本的SQLite中发现&lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME的&lt;/a&gt;行为不完整。新应用程序应将此标志保持关闭状态。</target>
        </trans-unit>
        <trans-unit id="da6399d7b11614d555263b7b5c1f6eeed6216d28" translate="yes" xml:space="preserve">
          <source>This pragma is usually a no-op or nearly so and is very fast. However if SQLite feels that performing database optimizations (such as running &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; or creating new indexes) will improve the performance of future queries, then some database I/O may be done. Applications that want to limit the amount of work performed can set a timer that will invoke &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; if the pragma goes on for too long.</source>
          <target state="translated">此实用程序通常是无操作的或几乎没有操作的，并且非常快。但是，如果SQLite认为执行数据库优化（例如运行&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;或创建新索引）将提高未来查询的性能，则可以完成一些数据库I / O。想要限制执行的工作量的应用程序可以设置一个计时器，如果编译指示进行的时间过长，它将调用&lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eed3f0fa483000682a7d14c72650e371b0cd8ff1" translate="yes" xml:space="preserve">
          <source>This pragma is usually a no-op or nearly so and is very fast. However if SQLite feels that performing database optimizations (such as running &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; or creating new indexes) will improve the performance of future queries, then some database I/O may be done. Applications that want to limit the amount of work performed can set a timer that will invoke &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; if the pragma goes on for too long. Or, since SQLite 3.32.0, the application can use &lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;PRAGMA analysis_limit=&lt;i&gt;N&lt;/i&gt;&lt;/a&gt; for some small value of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dc81b55aa5ba45ad453a6bcde0f0c60e0ee6240" translate="yes" xml:space="preserve">
          <source>This pragma no longer functions. It has become a no-op. The capabilities formerly provided by PRAGMA legacy_file_format are now available using the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyfileformat&quot;&gt;SQLITE_DBCONFIG_LEGACY_FILE_FORMAT&lt;/a&gt; option to the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; C-language interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa79296e3017bdd16ab4375742cc5d36bf545d0" translate="yes" xml:space="preserve">
          <source>This pragma only operates on the single database specified prior to the pragma name (or on the &quot;main&quot; database if no database is specified.) There is no way to change the journal size limit on all attached databases using a single PRAGMA statement. The size limit must be set separately for each attached database.</source>
          <target state="translated">这个pragma只在pragma名称前指定的单个数据库上运行(如果没有指定数据库,则在 &quot;主 &quot;数据库上运行),没有办法使用单个pragma语句改变所有附加数据库的日志大小限制。必须为每个附加数据库单独设置大小限制。</target>
        </trans-unit>
        <trans-unit id="aaba056a4862e01cda71d1b761b20e44b6644509" translate="yes" xml:space="preserve">
          <source>This pragma queries or sets the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;&lt;a href=&quot;wal#ckpt&quot;&gt;auto-checkpoint&lt;/a&gt; interval. When the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; is enabled (via the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;) a checkpoint will be run automatically whenever the write-ahead log equals or exceeds</source>
          <target state="translated">此实用程序查询或设置&lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt;&lt;a href=&quot;wal#ckpt&quot;&gt;自动检查点&lt;/a&gt;间隔。当&lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt;被启用（通过&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode编译&lt;/a&gt;）检查点都将自动运行每当预写日志等于或超过</target>
        </trans-unit>
        <trans-unit id="bfa75e14bfef32a3a2655c1f71aac8485fad888a" translate="yes" xml:space="preserve">
          <source>This pragma queries or sets the journal mode for databases associated with the current &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">此编译指示查询或设置与当前&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;关联的数据库的日志模式。</target>
        </trans-unit>
        <trans-unit id="d7c0c8e01f410012df8cd3104181fe89fb374fb3" translate="yes" xml:space="preserve">
          <source>This pragma queries or sets the suggested maximum number of pages of disk cache that will be allocated per open database file. The difference between this pragma and &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt; is that the value set here persists across database connections. The value of the default cache size is stored in the 4-byte big-endian integer located at offset 48 in the header of the database file.</source>
          <target state="translated">此编译指示查询或设置建议为每个打开的数据库文件分配的最大磁盘高速缓存页数。该编译指示和&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt;之间的区别在于，此处设置的值在数据库连接之间保持不变。默认高速缓存大小的值存储在数据库文件头中偏移量48处的4字节big-endian整数中。</target>
        </trans-unit>
        <trans-unit id="1ef2565e895730d620c072e537d3e53ba600062b" translate="yes" xml:space="preserve">
          <source>This pragma returns a list of &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; modules registered with the database connection.</source>
          <target state="translated">该编译指示返回已向数据库连接注册的&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;模块的列表。</target>
        </trans-unit>
        <trans-unit id="761ef2eae4b7a8c11954de10636acd7a99ab380d" translate="yes" xml:space="preserve">
          <source>This pragma returns a list of PRAGMA commands known to the database connection.</source>
          <target state="translated">这个pragma返回数据库连接已知的PRAGMA命令列表。</target>
        </trans-unit>
        <trans-unit id="9ed8c879810cf3faa84c36c2770e39958fecd02f" translate="yes" xml:space="preserve">
          <source>This pragma returns a list of SQL functions known to the database connection.</source>
          <target state="translated">这个pragma返回数据库连接中已知的SQL函数列表。</target>
        </trans-unit>
        <trans-unit id="0dc9b418a5af323c70ff0736fa3cf8ab37665f1f" translate="yes" xml:space="preserve">
          <source>This pragma returns a list of SQL functions known to the database connection. Each row of the result describes a single calling signature for a single SQL function. Some SQL functions will have multiple rows in the result set if they can (for example) be invoked with a varying number of arguments or can accept text in various encodings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84be4457e11159e63d3d0bcb841125df9cb83de4" translate="yes" xml:space="preserve">
          <source>This pragma returns auxiliary information about tables and indices. The returned information is used during testing to help verify that the query planner is operating correctly. The format and meaning of this pragma will likely change from one release to the next. Because of its volatility, the behavior and output format of this pragma are deliberately undocumented.</source>
          <target state="translated">这个pragma返回有关表和索引的辅助信息。返回的信息在测试过程中被用来帮助验证查询规划器是否正确运行。这个pragma的格式和意义可能会在不同的版本中发生变化。由于它的不稳定性,这个pragma的行为和输出格式故意不被记录。</target>
        </trans-unit>
        <trans-unit id="2c1dbb4a8fba94e2ded892c87199bba0f95f66bb" translate="yes" xml:space="preserve">
          <source>This pragma returns information about every column in an index. Unlike this &lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_info pragma&lt;/a&gt;, this pragma returns information about every column in the index, not just the key columns. (A key column is a column that is actually named in the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; index statement or &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE constraint&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY constraint&lt;/a&gt; that created the index. Auxiliary columns are additional columns needed to locate the table entry that corresponds to each index entry.)</source>
          <target state="translated">该编译指示返回有关索引中每一列的信息。不同于&lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_info杂注&lt;/a&gt;，此杂注返回有关索引中每一列的信息，而不仅仅是键列。（键列是在&lt;a href=&quot;lang_createindex&quot;&gt;创建索引&lt;/a&gt;的CREATE INDEX索引语句或&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE约束&lt;/a&gt;或&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY约束&lt;/a&gt;中实际命名的列。辅助列是查找与每个索引条目相对应的表条目所需的其他列。）</target>
        </trans-unit>
        <trans-unit id="a24a2d4f09014cb1eb0e92389ff660a1c3604451" translate="yes" xml:space="preserve">
          <source>This pragma returns one row for each &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; created by a REFERENCES clause in the CREATE TABLE statement of table &quot;</source>
          <target state="translated">对于由&amp;ldquo;表&amp;rdquo;的CREATE TABLE语句中的REFERENCES子句创建的每个&lt;a href=&quot;foreignkeys&quot;&gt;外键约束，&lt;/a&gt;此编译指示均返回一行。</target>
        </trans-unit>
        <trans-unit id="f5e8b048594bfe6e950f49e7a3df451544d23739" translate="yes" xml:space="preserve">
          <source>This pragma returns one row for each column in the named table, including &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden columns&lt;/a&gt; in virtual tables. The output is the same as for &lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt; except that hidden columns are shown rather than being omitted.</source>
          <target state="translated">该编译指示为命名表中的每一列返回一行，包括虚拟表中的&lt;a href=&quot;vtab#hiddencol&quot;&gt;隐藏列&lt;/a&gt;。输出与&lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt;相同，除了显示而不是省略隐藏列。</target>
        </trans-unit>
        <trans-unit id="0f2a61f261d82a90c74c33973c7e5e1738138e48" translate="yes" xml:space="preserve">
          <source>This pragma returns one row for each column in the named table. Columns in the result set include the column name, data type, whether or not the column can be NULL, and the default value for the column. The &quot;pk&quot; column in the result set is zero for columns that are not part of the primary key, and is the index of the column in the primary key for columns that are part of the primary key.</source>
          <target state="translated">这个pragma为命名表中的每一列返回一行。结果集中的列包括列名、数据类型、该列是否可以为NULL以及该列的默认值。对于不属于主键的列,结果集中的 &quot;pk &quot;列为零,对于属于主键的列,则是该列在主键中的索引。</target>
        </trans-unit>
        <trans-unit id="843feda403cc5662c28514409a8476f790a07bc9" translate="yes" xml:space="preserve">
          <source>This pragma returns one row for each index associated with the given table.</source>
          <target state="translated">这个pragma为每个与给定表相关联的索引返回一条记录。</target>
        </trans-unit>
        <trans-unit id="e15d06d79e2f134d82370610f854504fb7d9c9fb" translate="yes" xml:space="preserve">
          <source>This pragma returns one row for each key column in the named index. A key column is a column that is actually named in the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; index statement or &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE constraint&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY constraint&lt;/a&gt; that created the index. Index entries also usually contain auxiliary columns that point back to the table row being indexed. The auxiliary index-columns are not shown by the index_info pragma, but they are listed by the &lt;a href=&quot;pragma#pragma_index_xinfo&quot;&gt;index_xinfo pragma&lt;/a&gt;.</source>
          <target state="translated">该编译指示为命名索引中的每个键列返回一行。键列是在&lt;a href=&quot;lang_createindex&quot;&gt;创建索引&lt;/a&gt;的CREATE INDEX索引语句或&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE约束&lt;/a&gt;或&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY约束&lt;/a&gt;中实际命名的列。索引条目通常还包含辅助列，这些辅助列指向要建立索引的表行。辅助索引列未由index_info编译指示显示，但由&lt;a href=&quot;pragma#pragma_index_xinfo&quot;&gt;index_xinfo编译指示&lt;/a&gt;列出。</target>
        </trans-unit>
        <trans-unit id="d1297e6852f3b4af2f7f71b997d91f96306d187f" translate="yes" xml:space="preserve">
          <source>This pragma returns the names of &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; used when building SQLite, one option per row. The &quot;SQLITE_&quot; prefix is omitted from the returned option names. See also the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get()&lt;/a&gt; C/C++ interface and the &lt;a href=&quot;lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get()&lt;/a&gt; SQL functions.</source>
          <target state="translated">此编译指示返回在构建SQLite &lt;a href=&quot;compile&quot;&gt;时&lt;/a&gt;使用的编译时选项的名称，每行一个选项。返回的选项名称中省略了&amp;ldquo; SQLITE_&amp;rdquo;前缀。另请参见&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get（）&lt;/a&gt; C / C ++接口和&lt;a href=&quot;lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get（）&lt;/a&gt; SQL函数。</target>
        </trans-unit>
        <trans-unit id="1f4e86e6ac578887a9d6dbf11a796008c25a44d7" translate="yes" xml:space="preserve">
          <source>This pragma sets or queries the database connection locking-mode. The locking-mode is either NORMAL or EXCLUSIVE.</source>
          <target state="translated">这个pragma设置或查询数据库连接锁定模式。锁定模式可以是NORMAL或EXCLUSIVE。</target>
        </trans-unit>
        <trans-unit id="bdaa228ea88957ef0c9ab9a688d3e7fea7b874a6" translate="yes" xml:space="preserve">
          <source>This pragma sets or queries the value of the legacy_alter_table flag. When this flag is on, the &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; command (for changing the name of a table) works as it did in SQLite 3.24.0 (2018-06-04) and earlier. More specifically, when this flag is on the &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; command only rewrites the initial occurrence of the table name in its &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement and in any associated &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; and &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statements. Other references to the table are unmodified, including:</source>
          <target state="translated">此编译指示设置或查询legacy_alter_table标志的值。启用此标志时，&lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt;命令（用于更改表的名称）的工作方式与SQLite 3.24.0（2018-06-04）及更早版本中的工作相同。更具体地说，当此标志位于&lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt;命令上时，仅在其&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句以及任何关联的&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;和&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;语句中重写表名的初始出现。对该表的其他引用未经修改，包括：</target>
        </trans-unit>
        <trans-unit id="7a05efbc35058ad10c4f2cd985fb255ec41f8221" translate="yes" xml:space="preserve">
          <source>This pragma sets or queries the value of the legacy_file_format flag. When this flag is on, new SQLite databases are created in a file format that is readable and writable by all versions of SQLite going back to 3.0.0. When the flag is off, new databases are created using the latest file format which might not be readable or writable by versions of SQLite prior to 3.3.0.</source>
          <target state="translated">这个pragma设置或查询legacy_file_format标志的值。当这个标志开启时,新的SQLite数据库是以3.0.0以前的所有版本的SQLite都能读和写的文件格式创建的。 当这个标志关闭时,新的数据库是使用最新的文件格式创建的,而3.3.0以前的SQLite版本可能无法读和写。</target>
        </trans-unit>
        <trans-unit id="b26c49351792e86f1f1cf4afa447e502bc4e050e" translate="yes" xml:space="preserve">
          <source>This pragma tells the ANALYZE command to start a full scan of the index as it normally would. But when the number of rows visited reaches 1000 (or whatever other limit is specified by the pragma), the ANALYZE command will begin taking actions to stop the scan. If the left-most column of the index has changed at least once during the previous 1000 steps, then the analysis stops immediately. But if the left-most column has always been the same, then ANALYZE skips ahead to the first entry with a different left-most column and reads an additional 1000 rows before terminating.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2256ef3045f9cad069bd18349bbc99a6efdd738" translate="yes" xml:space="preserve">
          <source>This pragma uses &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; to overload the LIKE and GLOB functions, which may override previous implementations of LIKE and GLOB registered by the application. This pragma only changes the behavior of the SQL &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator. It does not change the behavior of the &lt;a href=&quot;c3ref/strlike&quot;&gt;sqlite3_strlike()&lt;/a&gt; C-language interface, which is always case insensitive.</source>
          <target state="translated">此编译指示使用&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;重载LIKE和GLOB函数，这可能会覆盖应用程序注册的LIKE和GLOB的先前实现。此编译指示仅更改SQL &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;运算符的行为。它不会更改&lt;a href=&quot;c3ref/strlike&quot;&gt;sqlite3_strlike（）&lt;/a&gt; C语言接口的行为，该行为始终不区分大小写。</target>
        </trans-unit>
        <trans-unit id="310b52d96c912ff71562ab1fd81b11654003b13d" translate="yes" xml:space="preserve">
          <source>This pragma was added in SQLite version 3.32.0 (2020-05-22). The current implementation only uses the lower 31 bits of the N value - higher order bits are silently ignored. Future versions of SQLite might begin using higher order bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="447007d852fb19b826d2b7aaae3e67946a28d336" translate="yes" xml:space="preserve">
          <source>This pragma works like a query to return one row for each database attached to the current database connection. The second column is &quot;main&quot; for the main database file, &quot;temp&quot; for the database file used to store TEMP objects, or the name of the ATTACHed database for other database files. The third column is the name of the database file itself, or an empty string if the database is not associated with a file.</source>
          <target state="translated">这个pragma的工作原理就像查询一样,为当前数据库连接所附的每个数据库返回一行。第二列是 &quot;main &quot;表示主数据库文件,&quot;temp &quot;表示用于存储TEMP对象的数据库文件,或者其他数据库文件的ATTACHed数据库名称。第三列是数据库文件本身的名称,如果数据库没有与文件关联,则为空字符串。</target>
        </trans-unit>
        <trans-unit id="b7e6bffb05642d99fecc1f2c74da4ca842565145" translate="yes" xml:space="preserve">
          <source>This problem was discovered during internal testing and has never been observed in the wild. The problem was fixed on 2011-01-27 and in version 3.7.5.</source>
          <target state="translated">该问题是在内部测试中发现的,从未在野外观察到。该问题已于2011-01-27和3.7.5版本中得到修复。</target>
        </trans-unit>
        <trans-unit id="9438a6524ce2126c022c5e9ae1c6d3bb84977f28" translate="yes" xml:space="preserve">
          <source>This problem was fixed on 2010-08-04 for SQLite version 3.7.1.</source>
          <target state="translated">该问题已于2010-08-04修复,适用于SQLite 3.7.1版本。</target>
        </trans-unit>
        <trans-unit id="3bba8168352d9cb374bc4be5ca367062ebf9277c" translate="yes" xml:space="preserve">
          <source>This problem was fixed on 2010-08-23 for SQLite version 3.7.2.</source>
          <target state="translated">该问题已于2010-08-23修复,适用于SQLite 3.7.2版本。</target>
        </trans-unit>
        <trans-unit id="3eea872e5b7d7a7257a591147c473522673fa365" translate="yes" xml:space="preserve">
          <source>This problem was fixed on 2010-09-20 for SQLite version 3.7.3.</source>
          <target state="translated">该问题已于2010-09-20修复,适用于SQLite 3.7.3版本。</target>
        </trans-unit>
        <trans-unit id="0ce7e9d811851c36704d972293b4f2237f7e1d64" translate="yes" xml:space="preserve">
          <source>This procedure works well in many scenarios and is usually very fast. However, this technique has the following shortcomings:</source>
          <target state="translated">这个程序在很多情况下都很好用,而且通常非常快。但是,这种技术有以下缺点:</target>
        </trans-unit>
        <trans-unit id="4c414b9643d2b1eb4ae1c2d544d59015b0f98573" translate="yes" xml:space="preserve">
          <source>This program is essentially the same as the DELETE program except that the body of the second loop has been replace by a sequence of instructions (at addresses 17 through 26) that update the record rather than delete it. Most of this instruction sequence should already be familiar to you, but there are a couple of minor twists so we will go over it briefly. Also note that the order of some of the instructions before and after the 2nd loop has changed. This is just the way the SQLite parser chose to output the code using a different template.</source>
          <target state="translated">这个程序与DELETE程序基本相同,只是第二个循环的主体被更新记录而不是删除记录的指令序列(地址为17到26)所取代。这个指令序列的大部分内容你应该已经很熟悉了,但是有几个小的转折,所以我们将简单介绍一下。还要注意的是,第2个循环前后的一些指令的顺序发生了变化。这只是SQLite解析器选择使用不同模板输出代码的方式。</target>
        </trans-unit>
        <trans-unit id="f54cc6d1386375f0cfa0eb855ce7f2e93f001461" translate="yes" xml:space="preserve">
          <source>This query asks for is all information about edges that go from nodes labeled &quot;alice&quot; to nodes labeled &quot;bob&quot;. The query optimizer in SQLite has basically two choices on how to implement this query. (There are actually six different choices, but we will only consider two of them here.) Pseudocode below demonstrating these two choices.</source>
          <target state="translated">这个查询要求的是所有从标记为 &quot;alice &quot;的节点到标记为 &quot;bob &quot;的节点的边的信息。SQLite中的查询优化器基本上有两种选择来实现这个查询。实际上有六种不同的选择,但我们在这里只考虑其中的两种)。下面的伪代码演示了这两种选择。</target>
        </trans-unit>
        <trans-unit id="7e3da084168a6f4b3ad897e2e46b6850a28945d4" translate="yes" xml:space="preserve">
          <source>This query first has to search the index B-Tree looking for any entry that contains the matching value for &quot;word&quot;. When an entry is found in the index, the rowid is extracted and used to search the main table. Then the &quot;cnt&quot; value is read out of the main table and returned. Hence, two separate binary searches are required to fulfill the request.</source>
          <target state="translated">这个查询首先要搜索索引B树,寻找任何包含 &quot;word &quot;匹配值的条目。当在索引中找到一个条目时,提取出rowid并用于搜索主表,然后从主表中读出 &quot;cnt &quot;值并返回。然后从主表中读出 &quot;cnt &quot;值并返回。因此,需要进行两次独立的二进制搜索来完成请求。</target>
        </trans-unit>
        <trans-unit id="620f9a1f33cc73df6597e56b9939bf24aa81844a" translate="yes" xml:space="preserve">
          <source>This query gives the same result:</source>
          <target state="translated">这个查询给出了同样的结果。</target>
        </trans-unit>
        <trans-unit id="d2601bd4ed6990af8a96269ebe6b0cb66d50d79e" translate="yes" xml:space="preserve">
          <source>This query is not especially complicated, but even so it replaces hundreds or perhaps thousands of lines of procedural code. The gist of the query is this: Scan down the EVENT table looking for the most recent 200 check-ins that satisfy any one of three conditions:</source>
          <target state="translated">这个查询并不是特别复杂,但即便如此,它也取代了几百行甚至上千行的程序代码。这个查询的要点是这样的。扫描EVENT表,寻找最近200个符合三个条件之一的签到。</target>
        </trans-unit>
        <trans-unit id="2749b73f041610bfa01e6d5aed946eaac3cd848e" translate="yes" xml:space="preserve">
          <source>This query is perhaps a bit contrived, but it does serve to illustrate our points. The result will have three column with names &quot;one&quot;, &quot;two&quot;, and &quot;both&quot;. The first two columns are direct copies of the two columns in the table and the third result column is a string formed by concatenating the first and second columns of the table. Finally, the WHERE clause says that we will only chose rows for the results where the &quot;one&quot; column begins with an &quot;H&quot;. Here is what the VDBE program looks like for this query:</source>
          <target state="translated">这个查询也许有点造作,但它确实可以说明我们的观点。结果将有三列,名称分别为 &quot;一&quot;、&quot;二 &quot;和 &quot;二&quot;。前两列是表中两列的直接拷贝,第三个结果列是表中第一列和第二列连在一起形成的字符串。最后,WHERE子句表示我们将只选择 &quot;一 &quot;列以 &quot;H &quot;开头的结果行。下面是这个查询的VDBE程序的样子。</target>
        </trans-unit>
        <trans-unit id="6af6cd36f1f43fba0a96ca0a8f8120de050aaf2f" translate="yes" xml:space="preserve">
          <source>This query will quickly and efficiently return the content of the first slide, which could then be speedily parsed and displayed to the user. Only one page needs to be read and parsed in order render the first screen, which means that the first screen appears much faster and there is no longer a need for an annoying progress bar.</source>
          <target state="translated">这个查询将快速有效地返回第一张幻灯片的内容,然后可以快速解析并显示给用户。只需要读取和解析一个页面就可以呈现第一个屏幕,这意味着第一个屏幕出现的速度要快得多,而且不再需要烦人的进度条。</target>
        </trans-unit>
        <trans-unit id="5a6c62ef8547acc00a0d376fd2eee1cb18ab798d" translate="yes" xml:space="preserve">
          <source>This query will return the name, login and host computer name for every employee whose login begins with the letter &quot;d&quot;. If this query is submitted to &lt;b&gt;sqlite_get_table&lt;/b&gt; the result might look like this:</source>
          <target state="translated">该查询将返回每个以字母&amp;ldquo; d&amp;rdquo;开头的员工的姓名，登录名和主机名。如果此查询提交到&lt;b&gt;sqlite_get_table，&lt;/b&gt;则结果可能如下所示：</target>
        </trans-unit>
        <trans-unit id="786fc0a802df1e8aec075c9e88a6bbb535aa99ad" translate="yes" xml:space="preserve">
          <source>This routine actually returns the index of the largest (rightmost) parameter. For all forms except ?NNN, this will correspond to the number of unique parameters. If parameters of the ?NNN form are used, there may be gaps in the list.</source>
          <target state="translated">这个例程实际上返回最大(最右边)参数的索引。对于除?NNN以外的所有形式,这将对应于唯一参数的数量。如果使用的是?NNN形式的参数,那么列表中可能会有空白。</target>
        </trans-unit>
        <trans-unit id="82cead05834ab856656df11fcc02860924d8d8b1" translate="yes" xml:space="preserve">
          <source>This routine can be used to find the number of &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL parameters&lt;/a&gt; in a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. SQL parameters are tokens of the form &quot;?&quot;, &quot;?NNN&quot;, &quot;:AAA&quot;, &quot;$AAA&quot;, or &quot;@AAA&quot; that serve as placeholders for values that are &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bound&lt;/a&gt; to the parameters at a later time.</source>
          <target state="translated">此例程可用于在&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句中&lt;/a&gt;查找&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL参数&lt;/a&gt;的数量。SQL参数是形式为&amp;ldquo;？&amp;rdquo;，&amp;ldquo;？NNN&amp;rdquo;，&amp;ldquo;：AAA&amp;rdquo;，&amp;ldquo; $ AAA&amp;rdquo;或&amp;ldquo; @AAA&amp;rdquo;的令牌，用作以后&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;绑定&lt;/a&gt;到参数的值的占位符。</target>
        </trans-unit>
        <trans-unit id="6aaf25d9f82325cb031a156482001e57680fd3f9" translate="yes" xml:space="preserve">
          <source>This routine can be used to find the number of &lt;a href=&quot;bind_blob&quot;&gt;SQL parameters&lt;/a&gt; in a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. SQL parameters are tokens of the form &quot;?&quot;, &quot;?NNN&quot;, &quot;:AAA&quot;, &quot;$AAA&quot;, or &quot;@AAA&quot; that serve as placeholders for values that are &lt;a href=&quot;bind_blob&quot;&gt;bound&lt;/a&gt; to the parameters at a later time.</source>
          <target state="translated">此例程可用于在&lt;a href=&quot;stmt&quot;&gt;准备好的语句中&lt;/a&gt;查找&lt;a href=&quot;bind_blob&quot;&gt;SQL参数&lt;/a&gt;的数量。SQL参数是形式为&amp;ldquo;？&amp;rdquo;，&amp;ldquo;？NNN&amp;rdquo;，&amp;ldquo;：AAA&amp;rdquo;，&amp;ldquo; $ AAA&amp;rdquo;或&amp;ldquo; @AAA&amp;rdquo;的令牌，用作以后&lt;a href=&quot;bind_blob&quot;&gt;绑定&lt;/a&gt;到参数的值的占位符。</target>
        </trans-unit>
        <trans-unit id="1a65562aad6f3d45b12e58b386a59a0e67c73c2c" translate="yes" xml:space="preserve">
          <source>This routine closes a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; previously opened by a call to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;. All &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with the connection should be &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt; prior to closing the connection.</source>
          <target state="translated">该例程关闭先前通过调用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;打开的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;。与连接关联的所有&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;应在关闭连接之前&lt;a href=&quot;c3ref/finalize&quot;&gt;完成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6109a4798fab358a5831fcddc3e8943992908f3a" translate="yes" xml:space="preserve">
          <source>This routine constructs a phonetic hash of the pure ascii input word X and returns that hash. This routine is used internally by spellfix1 in order to transform the K1 column of the shadow table into the K2 column.</source>
          <target state="translated">这个例程构建一个纯ascii输入字X的语音哈希值,并返回该哈希值。这个例程在内部被spellfix1使用,以便将影子表的K1列转换为K2列。</target>
        </trans-unit>
        <trans-unit id="0ac023c7cfdfffbaae6b8a792abd8043d224eebe" translate="yes" xml:space="preserve">
          <source>This routine converts SQL text into a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object and returns a pointer to that object. This interface requires a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; pointer created by a prior call to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and a text string containing the SQL statement to be prepared. This API does not actually evaluate the SQL statement. It merely prepares the SQL statement for evaluation.</source>
          <target state="translated">该例程将SQL文本转换为&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;对象，并返回指向该对象的指针。此接口需要一个由先前调用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;创建的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;指针和一个包含要准备的SQL语句的文本字符串。该API实际上不会评估SQL语句。它只是准备要评估的SQL语句。</target>
        </trans-unit>
        <trans-unit id="3865bbf14bf147fc543355db38f5dadbf150122d" translate="yes" xml:space="preserve">
          <source>This routine destroys a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; created by a prior call to &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;. Every prepared statement must be destroyed using a call to this routine in order to avoid memory leaks.</source>
          <target state="translated">该例程破坏了由先前调用&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;创建的&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;。必须使用对此例程的调用来销毁每个准备好的语句，以避免内存泄漏。</target>
        </trans-unit>
        <trans-unit id="a52c3faf1c3a1657fd6a40523756966514b3bd4b" translate="yes" xml:space="preserve">
          <source>This routine enables or disables the sharing of the database cache and schema data structures between &lt;a href=&quot;#sqlite3&quot;&gt;connections&lt;/a&gt; to the same database. Sharing is enabled if the argument is true and disabled if the argument is false.</source>
          <target state="translated">此例程启用或禁用在同一数据库的&lt;a href=&quot;#sqlite3&quot;&gt;连接&lt;/a&gt;之间共享数据库缓存和架构数据结构。如果参数为true，则启用共享；如果参数为false，则禁用共享。</target>
        </trans-unit>
        <trans-unit id="d901aac850e2874e347f7c695dbc9ec37b0c376c" translate="yes" xml:space="preserve">
          <source>This routine enables or disables the sharing of the database cache and schema data structures between &lt;a href=&quot;sqlite3&quot;&gt;connections&lt;/a&gt; to the same database. Sharing is enabled if the argument is true and disabled if the argument is false.</source>
          <target state="translated">此例程启用或禁用在同一数据库的&lt;a href=&quot;sqlite3&quot;&gt;连接&lt;/a&gt;之间共享数据库缓存和架构数据结构。如果参数为true，则启用共享；如果参数为false，则禁用共享。</target>
        </trans-unit>
        <trans-unit id="e45ac400962f26a46b0c7a761a5b27fee72dc04a" translate="yes" xml:space="preserve">
          <source>This routine is intended for use in custom &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt; implementations only. It is not a general-purpose interface. The argument sqlite3_file_object(X) must be a filename pointer that has been passed into &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;.xOpen method where the flags parameter to xOpen contains one of the bits &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_MAIN_JOURNAL&lt;/a&gt; or &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_WAL&lt;/a&gt;. Any other use of this routine results in undefined and probably undesirable behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29a07bad74dc3a8e7d5052bfbcc32c750599206e" translate="yes" xml:space="preserve">
          <source>This routine is intended for use in custom &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations only. It is not a general-purpose interface. The argument sqlite3_file_object(X) must be a filename pointer that has been passed into &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;.xOpen method where the flags parameter to xOpen contains one of the bits &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_MAIN_JOURNAL&lt;/a&gt; or &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_WAL&lt;/a&gt;. Any other use of this routine results in undefined and probably undesirable behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ec00e3ab29e600b8638a80acbfec2ed5a9c1b5" translate="yes" xml:space="preserve">
          <source>This routine is used to evaluate a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; that has been previously created by the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface. The statement is evaluated up to the point where the first row of results are available. To advance to the second row of results, invoke &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; again. Continue invoking &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; until the statement is complete. Statements that do not return results (ex: INSERT, UPDATE, or DELETE statements) run to completion on a single call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">此例程用于评估先前由&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;接口创建的预&lt;a href=&quot;c3ref/stmt&quot;&gt;准备语句&lt;/a&gt;。对该语句进行评估，直到结果的第一行可用为止。要前进到结果的第二行，请再次调用&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;。继续调用&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;直到语句完成。不返回结果的语句（例如INSERT，UPDATE或DELETE语句）在单次调用&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）时便&lt;/a&gt;运行完毕。</target>
        </trans-unit>
        <trans-unit id="c21adee0cae411351e9767eae2ca17c143aefc07" translate="yes" xml:space="preserve">
          <source>This routine must be called from the same thread in which the aggregate SQL function is running.</source>
          <target state="translated">这个例程必须在运行聚合SQL函数的同一线程中调用。</target>
        </trans-unit>
        <trans-unit id="e489cf15316fb146ac0baf370fbbfcb5134583b8" translate="yes" xml:space="preserve">
          <source>This routine must be called from the same thread in which the application-defined function is running.</source>
          <target state="translated">这个例程必须从运行应用程序定义函数的同一线程中调用。</target>
        </trans-unit>
        <trans-unit id="07007def1c51de043ffcd727a12c0e6566d62bdb" translate="yes" xml:space="preserve">
          <source>This routine only works on a &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; which has been created by a prior successful call to &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; and which has not been closed by &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;. Passing any other pointer in to this routine results in undefined and probably undesirable behavior.</source>
          <target state="translated">此例程仅适用于&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄&lt;/a&gt;，该句柄是由先前对&lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open（）的&lt;/a&gt;成功调用创建的，并且尚未由&lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close（）&lt;/a&gt;关闭。将任何其他指针传递到此例程将导致未定义的行为，并且可能是不良行为。</target>
        </trans-unit>
        <trans-unit id="d92c14464f28e95d1806fdcf38633495ea9ee90c" translate="yes" xml:space="preserve">
          <source>This routine only works on a &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; which has been created by a prior successful call to &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; and which has not been closed by &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;. Passing any other pointer in to this routine results in undefined and probably undesirable behavior.</source>
          <target state="translated">此例程仅适用于&lt;a href=&quot;blob&quot;&gt;BLOB句柄&lt;/a&gt;，该句柄是由先前对&lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open（）的&lt;/a&gt;成功调用创建的，并且尚未由&lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close（）&lt;/a&gt;关闭。将任何其他指针传递到此例程将导致未定义的行为，并且可能是不良行为。</target>
        </trans-unit>
        <trans-unit id="07b6feb6d3d354b38307dc8433a451fe5b332630" translate="yes" xml:space="preserve">
          <source>This routine opens a connection to an SQLite database file and returns a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; object. This is often the first SQLite API call that an application makes and is a prerequisite for most other SQLite APIs. Many SQLite interfaces require a pointer to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; object as their first parameter and can be thought of as methods on the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; object. This routine is the constructor for the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; object.</source>
          <target state="translated">该例程打开与SQLite数据库文件的连接，并返回&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;对象。这通常是应用程序进行的第一个SQLite API调用，并且是大多数其他SQLite API的前提条件。许多SQLite接口要求将指向&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;对象的指针作为它们的第一个参数，并且可以将其视为&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;对象上的方法。该例程是&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;对象的构造函数。</target>
        </trans-unit>
        <trans-unit id="8eb287af5c0b98096f9cf0455204f0ad3d8277d3" translate="yes" xml:space="preserve">
          <source>This routine provides access to the built-in Wagner edit-distance function that uses default, fixed costs. The value returned is the edit distance needed to transform W into P.</source>
          <target state="translated">这个例程提供了对使用默认固定成本的内置Wagner编辑距离函数的访问。返回的值是将W转换为P所需的编辑距离。</target>
        </trans-unit>
        <trans-unit id="93eac9a1a83b23f2a48d0e76580b6d5dc096f4b0" translate="yes" xml:space="preserve">
          <source>This routine registers an authorizer callback with a particular &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;, supplied in the first argument. The authorizer callback is invoked as SQL statements are being compiled by &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;. At various points during the compilation process, as logic is being created to perform various actions, the authorizer callback is invoked to see if those actions are allowed. The authorizer callback should return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; to allow the action, &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; to disallow the specific action but allow the SQL statement to continue to be compiled, or &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_DENY&lt;/a&gt; to cause the entire SQL statement to be rejected with an error. If the authorizer callback returns any value other than &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_DENY&lt;/a&gt; then the &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or equivalent call that triggered the authorizer will fail with an error message.</source>
          <target state="translated">此例程使用第一个参数中提供的特定&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;注册授权者回调。当&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;或其变体&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;编译SQL语句时，将调用Authorizer回调。在编译过程中的各个阶段，随着创建逻辑来执行各种动作，将调用授权者回调以查看是否允许这些动作。授权者回调应返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;以允许操作&lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;禁止执行特定操作，但允许继续编译SQL语句，或者&lt;a href=&quot;#SQLITE_DENY&quot;&gt;允许SQLITE_DENY&lt;/a&gt;导致整个SQL语句被错误拒绝。如果授权者回调返回除&lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;或&lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_DENY&lt;/a&gt;之外的任何其他值，则触发授权者的&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或等效调用将失败，并显示一条错误消息。</target>
        </trans-unit>
        <trans-unit id="dcaafc38803b7cef296c24894bb19eac21f398f7" translate="yes" xml:space="preserve">
          <source>This routine registers an authorizer callback with a particular &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;, supplied in the first argument. The authorizer callback is invoked as SQL statements are being compiled by &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, and &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;. At various points during the compilation process, as logic is being created to perform various actions, the authorizer callback is invoked to see if those actions are allowed. The authorizer callback should return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; to allow the action, &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; to disallow the specific action but allow the SQL statement to continue to be compiled, or &lt;a href=&quot;c_deny&quot;&gt;SQLITE_DENY&lt;/a&gt; to cause the entire SQL statement to be rejected with an error. If the authorizer callback returns any value other than &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;, &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;, or &lt;a href=&quot;c_deny&quot;&gt;SQLITE_DENY&lt;/a&gt; then the &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or equivalent call that triggered the authorizer will fail with an error message.</source>
          <target state="translated">此例程使用第一个参数中提供的特定&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;注册授权者回调。当&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;或其变体&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;，&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;，&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16（）&lt;/a&gt;，&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;和&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;编译SQL语句时，将调用Authorizer回调。在编译过程中的各个阶段，随着创建逻辑来执行各种动作，将调用授权者回调以查看是否允许这些动作。授权者回调应返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;以允许操作&lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;禁止执行特定操作，但允许继续编译SQL语句，或者&lt;a href=&quot;c_deny&quot;&gt;允许SQLITE_DENY&lt;/a&gt;导致整个SQL语句被错误拒绝。如果授权者回调返回除&lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;，&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;或&lt;a href=&quot;c_deny&quot;&gt;SQLITE_DENY&lt;/a&gt;之外的任何其他值，则触发授权者的&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或等效调用将失败，并显示一条错误消息。</target>
        </trans-unit>
        <trans-unit id="99bd82f31eb3b138636b801769508b327d9ce007" translate="yes" xml:space="preserve">
          <source>This routine returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if shared cache was enabled or disabled successfully. An &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned otherwise.</source>
          <target state="translated">如果成功启用或禁用了共享缓存，此例程将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;。一个&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;否则返回。</target>
        </trans-unit>
        <trans-unit id="2e5b155148072e0e0717f83e2e5d7963cd701ab3" translate="yes" xml:space="preserve">
          <source>This routine returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if shared cache was enabled or disabled successfully. An &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned otherwise.</source>
          <target state="translated">如果成功启用或禁用了共享缓存，此例程将返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。一个&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;否则返回。</target>
        </trans-unit>
        <trans-unit id="4d167dde1efd15582fdfdddff7653e5e9800f482" translate="yes" xml:space="preserve">
          <source>This routine returns a TCL byte-array that is the complete content of the identified database. This byte-array can be written into a file and then used as an ordinary SQLite database, or it can be sent over a TCP/IP connection to some other application, or passed to the &quot;deserialize&quot; method of another database connection.</source>
          <target state="translated">这个例程返回一个TCL字节数组,它是所识别数据库的完整内容。这个字节数组可以被写入一个文件,然后作为一个普通的SQLite数据库使用,也可以通过TCP/IP连接发送到其他应用程序,或者传递给另一个数据库连接的 &quot;反序列化 &quot;方法。</target>
        </trans-unit>
        <trans-unit id="dc962087e437ca7c6c8165e9968a2bc2c77ed304" translate="yes" xml:space="preserve">
          <source>This routine returns a single column from the current row of a result set for a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; that is being evaluated by &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. Each time &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; stops with a new result set row, this routine can be called multiple times to find the values of all columns in that row.</source>
          <target state="translated">该例程从结果集的当前行返回一个单列，用于由&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;评估的&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;。每次&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;以新的结果集行停止时，可以多次调用此例程以查找该行中所有列的值。</target>
        </trans-unit>
        <trans-unit id="eb8bd2a9855b404f89ce4b63dddd244bdc9bda29" translate="yes" xml:space="preserve">
          <source>This routine sets a &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy handler&lt;/a&gt; that sleeps for a specified amount of time when a table is locked. The handler will sleep multiple times until at least &quot;ms&quot; milliseconds of sleeping have accumulated. After at least &quot;ms&quot; milliseconds of sleeping, the handler returns 0 which causes &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; to return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="translated">此例程设置一个&lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;繁忙的处理程序&lt;/a&gt;，该处理程序在锁定表时会休眠指定的时间。处理程序将多次睡眠，直到至少&amp;ldquo; ms&amp;rdquo;毫秒的睡眠累积为止。经过至少&amp;ldquo; ms&amp;rdquo;毫秒的睡眠后，处理程序返回0，这导致&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="97ac6d25d7ee72382d3f7aec3c40d5d374b3ea97" translate="yes" xml:space="preserve">
          <source>This routine sets a &lt;a href=&quot;busy_handler&quot;&gt;busy handler&lt;/a&gt; that sleeps for a specified amount of time when a table is locked. The handler will sleep multiple times until at least &quot;ms&quot; milliseconds of sleeping have accumulated. After at least &quot;ms&quot; milliseconds of sleeping, the handler returns 0 which causes &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; to return &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="translated">此例程设置一个&lt;a href=&quot;busy_handler&quot;&gt;繁忙的处理程序&lt;/a&gt;，该处理程序在锁定表时会休眠指定的时间。处理程序将多次睡眠，直到至少&amp;ldquo; ms&amp;rdquo;毫秒的睡眠累积为止。经过至少&amp;ldquo; ms&amp;rdquo;毫秒的睡眠后，处理程序返回0，这导致&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;返回&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d633b79271bff7ae103d633764cef0869ef0e52" translate="yes" xml:space="preserve">
          <source>This routine transliterates unicode text into pure ascii, returning the pure ascii representation of the input text X. This is the function that is used internally to transform vocabulary words into the K1 column of the shadow table.</source>
          <target state="translated">这个例程将unicode文本翻译成纯ascii,返回输入文本X的纯ascii表示。这是内部用于将词汇转换到影子表K1列的函数。</target>
        </trans-unit>
        <trans-unit id="f0ad86a48fbea1254fe3c4c84468bcbdc8dd6e8c" translate="yes" xml:space="preserve">
          <source>This same content is also available as a &lt;a href=&quot;../capi3ref&quot;&gt;single large HTML file&lt;/a&gt;.</source>
          <target state="translated">同样的内容也可以作为&lt;a href=&quot;../capi3ref&quot;&gt;单个大HTML文件获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b74b81048986ae624c4d01a81a2fa637394592ee" translate="yes" xml:space="preserve">
          <source>This same content is also available split out into &lt;a href=&quot;c3ref/intro&quot;&gt;lots of small pages&lt;/a&gt;.</source>
          <target state="translated">同样的内容也可以分成&lt;a href=&quot;c3ref/intro&quot;&gt;很多小页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8e9d9070e55bd57ac8188b9955c919aae3b6970b" translate="yes" xml:space="preserve">
          <source>This scenario can be avoided by ensuring that there are &quot;reader gaps&quot;: times when no processes are reading from the database and that checkpoints are attempted during those times. In applications with many concurrent readers, one might also consider running manual checkpoints with the &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_RESTART&lt;/a&gt; or &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_TRUNCATE&lt;/a&gt; option which will ensure that the checkpoint runs to completion before returning. The disadvantage of using &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_RESTART&lt;/a&gt; and &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_TRUNCATE&lt;/a&gt; is that readers might block while the checkpoint is running.</source>
          <target state="translated">可以通过确保存在&amp;ldquo;读取器间隔&amp;rdquo;来避免这种情况：没有时间从数据库中读取进程，并且在这些时间内尝试了检查点。在具有多个并发阅读器的应用程序中，您可能还会考虑使用&lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_RESTART&lt;/a&gt;或&lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_TRUNCATE&lt;/a&gt;选项运行手动检查点，这将确保检查点在返回之前运行完毕。使用&lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_RESTART&lt;/a&gt;和&lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_TRUNCATE&lt;/a&gt;的缺点是，当检查点运行时，读者可能会阻塞。</target>
        </trans-unit>
        <trans-unit id="727ff7ebcc4d3f37cef6d2c8786627a54c4374f3" translate="yes" xml:space="preserve">
          <source>This second command will &quot;checkout&quot; the latest check-in from the SQLite source tree into your current directory. Subsequently, you can easily switch to a different version by typing:</source>
          <target state="translated">第二条命令将从SQLite源树中 &quot;签出 &quot;最新的签入到你当前的目录中。随后,你可以通过键入轻松切换到不同的版本。</target>
        </trans-unit>
        <trans-unit id="61831695cc5a4baa6ebe1da3db0f44d7f1cd6a66" translate="yes" xml:space="preserve">
          <source>This second number is too small. The first number is closer to the desired value of 47.49, so that is the one that gets used. But it is not exact. Most decimal values work this way in IEEE 754. Remember the key point we made above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c18c66c49575067fb81143d22f048900116d477" translate="yes" xml:space="preserve">
          <source>This second query will likely use the index because now the expression in the WHERE clause (x+y) matches the expression in the index exactly.</source>
          <target state="translated">第二个查询可能会使用索引,因为现在WHERE子句(x+y)中的表达式与索引中的表达式完全匹配。</target>
        </trans-unit>
        <trans-unit id="7abd749e3d4aa6938fa840ccf9ebcf410ac2c722" translate="yes" xml:space="preserve">
          <source>This second query would find both entry 1 (the SQLite.org office) which is entirely contained within the query box and also the 12th Congressional District which extends well outside the query box but still overlaps the query box.</source>
          <target state="translated">第二个查询既可以找到完全包含在查询框内的条目1(SQLite.org办公室),也可以找到延伸到查询框外但仍与查询框重合的第12国会区。</target>
        </trans-unit>
        <trans-unit id="810173a22163c6dabf4d33c2feedff31184b22f0" translate="yes" xml:space="preserve">
          <source>This section describes at a high-level the way the FTS module stores its index and content in the database. It is &lt;b&gt;not necessary to read or understand the material in this section in order to use FTS&lt;/b&gt; in an application. However, it may be useful to application developers attempting to analyze and understand FTS performance characteristics, or to developers contemplating enhancements to the existing FTS feature set.</source>
          <target state="translated">本节从更高层次描述了FTS模块将其索引和内容存储在数据库中的方式。这是&lt;b&gt;没有必要阅读或理解本节中的材料，以便使用FTS&lt;/b&gt;在应用程序中。但是，这对于尝试分析和理解FTS性能特征的应用程序开发人员，或正在考虑对现有FTS功能集进行增强的开发人员而言可能很有用。</target>
        </trans-unit>
        <trans-unit id="64d17de40cff5e777833059135b83479f23261c6" translate="yes" xml:space="preserve">
          <source>This section describes how the assumptions presented in the parent section apply to the individual API functions and operations provided by the VFS to SQLite for the purposes of modifying the contents of the file-system.</source>
          <target state="translated">这一节描述了上一节中介绍的假设如何应用于VFS向SQLite提供的各个API函数和操作,以便修改文件系统的内容。</target>
        </trans-unit>
        <trans-unit id="02fc8cc874e5b9c1577641015a9135b50baf469c" translate="yes" xml:space="preserve">
          <source>This section describes the VFS operations that take place when a new database connection is created.</source>
          <target state="translated">本节描述了在创建新的数据库连接时发生的VFS操作。</target>
        </trans-unit>
        <trans-unit id="4342e6a0d98af49025e37a5849302106877ca948" translate="yes" xml:space="preserve">
          <source>This section describes the VFS operations that take place when an existing database connection is closed (destroyed).</source>
          <target state="translated">本节描述了在关闭(销毁)现有数据库连接时发生的VFS操作。</target>
        </trans-unit>
        <trans-unit id="c2a1275da916ed3be3012a2f190ab9c2d388331b" translate="yes" xml:space="preserve">
          <source>This section describes the assumptions that SQLite makes about the content of a file-system following a power or system failure. In other words, it describes the extent of file and file-system corruption that such an event may cause.</source>
          <target state="translated">本节描述了SQLite在电源或系统故障后对文件系统内容的假设。换句话说,它描述了这种事件可能导致的文件和文件系统损坏的程度。</target>
        </trans-unit>
        <trans-unit id="edc6897ad6af970e04c51704d6197016314c42a7" translate="yes" xml:space="preserve">
          <source>This section describes the format used by an SQLite</source>
          <target state="translated">这一节描述了一个SQLite使用的格式。</target>
        </trans-unit>
        <trans-unit id="9a13aa03c88e9ab244b07031a9171942d0c6ff54" translate="yes" xml:space="preserve">
          <source>This section describes the procedure that SQLite uses to detect a</source>
          <target state="translated">这一节描述了SQLite用来检测一个</target>
        </trans-unit>
        <trans-unit id="bfe35a7e5c6f4117d5a645ddcb82fb94f15ae997" translate="yes" xml:space="preserve">
          <source>This section describes the progression of an SQLite</source>
          <target state="translated">这一节描述了一个SQLite的进展。</target>
        </trans-unit>
        <trans-unit id="f48fcfeb28df528b9f1d5864af41f8c4b970f962" translate="yes" xml:space="preserve">
          <source>This section describes the way the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;, and &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; commands interact with SQLite's foreign keys.</source>
          <target state="translated">本节介绍&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;，&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;和&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;命令与SQLite的外键交互的方式。</target>
        </trans-unit>
        <trans-unit id="58dd65dbe0083407cb2b8d63f24be502e95d9bbe" translate="yes" xml:space="preserve">
          <source>This section documents those assumptions made about the system that the VFS adaptor provides access to. The assumptions noted in section</source>
          <target state="translated">本节记录了对VFS适配器提供访问的系统所做的假设。本节中提到的假设</target>
        </trans-unit>
        <trans-unit id="1a8f1342dd83bc1cc71b3fbbf42a58b70897383c" translate="yes" xml:space="preserve">
          <source>This section is a combination of the Plan For Software Aspects Of Certification and the Software Development Plan sections of DO-178B.</source>
          <target state="translated">本部分是DO-178B的软件认证计划和软件开发计划部分的组合。</target>
        </trans-unit>
        <trans-unit id="30a1220c5879164f4d9cfc83dbec5374939998e6" translate="yes" xml:space="preserve">
          <source>This section is different from the others. Most other sections of this document talks about a particular SQL command. This section does not talk about a standalone command but about &quot;expressions&quot; which are subcomponents of most other commands.</source>
          <target state="translated">本节与其他章节不同。本文档中的大多数其他章节都是在谈论一个特定的SQL命令。本节并不是讲一个独立的命令,而是讲 &quot;表达式&quot;,而 &quot;表达式 &quot;是大多数其他命令的子组件。</target>
        </trans-unit>
        <trans-unit id="7d95e851797a07bafc31faa128d84f9f3bcc87a9" translate="yes" xml:space="preserve">
          <source>This section lists a few limitations and omitted features that are not mentioned elsewhere.</source>
          <target state="translated">本节列出了其他地方没有提到的一些限制和省略的功能。</target>
        </trans-unit>
        <trans-unit id="5f346ae80c10c621b4cd5c514c74301adfd2cd43" translate="yes" xml:space="preserve">
          <source>This section only describes the format of the journal file and the various objects that make it up. But because a journal file may be read by an SQLite process following recovery from a system failure (</source>
          <target state="translated">本节只描述了日志文件的格式和组成它的各种对象。但由于日志文件可以在系统故障恢复后被SQLite进程读取(</target>
        </trans-unit>
        <trans-unit id="aa8720f51b774a70c5f7cce02a309b8eb281c900" translate="yes" xml:space="preserve">
          <source>This section provides an overview of and example code demonstrating the integration of RBU Vacuum into an application program. For full details, refer to the comments in &lt;a href=&quot;http://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h&quot;&gt;header file sqlite3rbu.h&lt;/a&gt;.</source>
          <target state="translated">本节概述了示例代码，并演示了将RBU Vacuum集成到应用程序中的示例代码。有关完整的详细信息，请参见&lt;a href=&quot;http://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h&quot;&gt;头文件sqlite3rbu.h中&lt;/a&gt;的注释。</target>
        </trans-unit>
        <trans-unit id="6c2f6418e2cfdab367ef3398ce17bbd29bfdf0e6" translate="yes" xml:space="preserve">
          <source>This section provides examples that demonstrate how to use the sessions extension.</source>
          <target state="translated">本节提供了一些例子来演示如何使用会话扩展。</target>
        </trans-unit>
        <trans-unit id="4b87966e6f8ae748c88886a65d993a4d228e6112" translate="yes" xml:space="preserve">
          <source>This sets the maximum number of statements that can be cached. The upper limit is 100. The default is 10. If you set the cache size to 0, no caching is done.</source>
          <target state="translated">此项设置可以缓存的语句的最大数量。上限是100条。默认值是10。如果将缓存大小设置为0,则不进行缓存。</target>
        </trans-unit>
        <trans-unit id="6ac8ffe5a0d74c555a62f1b92afaea89504bf302" translate="yes" xml:space="preserve">
          <source>This setting defaults to &quot;on&quot; for legacy compatibility, however all applications are advised to turn it off if possible. This setting can also be controlled using the &lt;a href=&quot;../pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema&lt;/a&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5315120760f3d3f82397813611296a7c3158949" translate="yes" xml:space="preserve">
          <source>This setting defaults to &quot;on&quot; for legacy compatibility, however all applications are advised to turn it off if possible. This setting can also be controlled using the &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema&lt;/a&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e77f8448a0f37903a1b46b5a44275edbc4cdc59" translate="yes" xml:space="preserve">
          <source>This spellfix1 &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; can be used to search a large vocabulary for close matches. For example, spellfix1 can be used to suggest corrections to misspelled words. Or, it could be used with &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; to do full-text search using potentially misspelled words.</source>
          <target state="translated">此spellfix1 &lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;可用于搜索大词汇表以查找紧密匹配项。例如，spellfix1可用于建议对拼写错误的单词的更正。或者，它可以与&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;一起使用，以使用可能拼写错误的单词进行全文搜索。</target>
        </trans-unit>
        <trans-unit id="6b40152c9ab376b3fd172fa9a2eebf595b1b8d89" translate="yes" xml:space="preserve">
          <source>This statement detaches an additional database connection previously attached using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. When not in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, it is possible to have the same database file attached multiple times using different names, and detaching one connection to a file will leave the others intact.</source>
          <target state="translated">该语句分离以前使用&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;语句附加的其他数据库连接。如果不在&lt;a href=&quot;sharedcache&quot;&gt;共享缓存模式下&lt;/a&gt;，则可以使用不同的名称多次附加同一数据库文件，而将一个连接分离到一个文件将使其他连接保持完整。</target>
        </trans-unit>
        <trans-unit id="34e0116d5c2febec8b6ae2d5a756ac7b5b48d70e" translate="yes" xml:space="preserve">
          <source>This step corresponds to steps &lt;a href=&quot;#section_3_8&quot;&gt;3.8&lt;/a&gt;, &lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt;, and &lt;a href=&quot;#section_3_10&quot;&gt;3.10&lt;/a&gt; in the single-file commit scenario described previously.</source>
          <target state="translated">该步骤对应于步骤&lt;a href=&quot;#section_3_8&quot;&gt;3.8&lt;/a&gt;，&lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt;和&lt;a href=&quot;#section_3_10&quot;&gt;3.10&lt;/a&gt;在单文件提交方案如前所述。</target>
        </trans-unit>
        <trans-unit id="0bc82eb6eb64e5996a7d75a58cb1d3a4ce9124d4" translate="yes" xml:space="preserve">
          <source>This step is analogous to &lt;a href=&quot;#section_3_7&quot;&gt;step 3.7&lt;/a&gt; in the single-file commit scenario described above.</source>
          <target state="translated">此步骤类似于上述单文件提交方案中的&lt;a href=&quot;#section_3_7&quot;&gt;步骤3.7&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e70a15ffedf708ad5c91c97bd2e22cff7b5bcebe" translate="yes" xml:space="preserve">
          <source>This step is usually more complicated than simply flushing the rollback journal to the disk. On most platforms two separate flush (or fsync()) operations are required. The first flush writes out the base rollback journal content. Then the header of the rollback journal is modified to show the number of pages in the rollback journal. Then the header is flushed to disk. The details on why we do this header modification and extra flush are provided in a later section of this paper.</source>
          <target state="translated">这一步通常比简单地将回滚日志刷新到磁盘上要复杂得多,在大多数平台上,需要进行两个单独的刷新(或fsync())操作。在大多数平台上,需要进行两个独立的刷新(或fsync())操作。第一次刷新会写出基本的回滚日志内容。然后修改回滚日志的标题,以显示回滚日志的页数。然后将头刷新到磁盘上。关于为什么要做这个头的修改和额外的刷新,本文后面的章节会详细介绍。</target>
        </trans-unit>
        <trans-unit id="60743213af70350c2b0e4cdfe091bf8177abcaf2" translate="yes" xml:space="preserve">
          <source>This structure, sometimes called a &quot;virtual table module&quot;, defines the implementation of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;. This structure consists mostly of methods for the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efa2100d52bcf7ffba30b15c96c96f87de04a155" translate="yes" xml:space="preserve">
          <source>This structure, sometimes called a &quot;virtual table module&quot;, defines the implementation of a &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt;. This structure consists mostly of methods for the module.</source>
          <target state="translated">这种结构有时称为&amp;ldquo;虚拟表模块&amp;rdquo;，它定义了&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;的实现。该结构主要由模块的方法组成。</target>
        </trans-unit>
        <trans-unit id="5114924ab3d2182dbc86222d1c257aa678f84e0e" translate="yes" xml:space="preserve">
          <source>This structure, sometimes called a &quot;virtual table module&quot;, defines the implementation of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;. This structure consists mostly of methods for the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b149e60f46d57857e167e94989fa609269eabe7" translate="yes" xml:space="preserve">
          <source>This structure, sometimes called a &quot;virtual table module&quot;, defines the implementation of a &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;. This structure consists mostly of methods for the module.</source>
          <target state="translated">这种结构有时称为&amp;ldquo;虚拟表模块&amp;rdquo;，它定义了&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;的实现。该结构主要由模块的方法组成。</target>
        </trans-unit>
        <trans-unit id="c18963c23800694aa33718fdc0a2deeb514a26e5" translate="yes" xml:space="preserve">
          <source>This substitution works like %q except that it doubles all double-quote characters (&quot;) instead of single-quotes, making the result suitable for using with a double-quoted identifier name in an SQL statement.</source>
          <target state="translated">这个替换和%q的工作原理一样,只是它将所有双引号字符(&quot;)加倍,而不是单引号,使得结果适合在SQL语句中与双引号标识符名称一起使用。</target>
        </trans-unit>
        <trans-unit id="42be9e1e34f4a968dedd36f548fc29765ab65613" translate="yes" xml:space="preserve">
          <source>This superclass exists in order to define fields of the cursor that are common to all implementations.</source>
          <target state="translated">这个超类的存在是为了定义游标的字段,这些字段对所有的实现都是通用的。</target>
        </trans-unit>
        <trans-unit id="28a7628277525a8ffd76f253de9da66f017821fe" translate="yes" xml:space="preserve">
          <source>This table contains most of the full-text index data.</source>
          <target state="translated">该表包含了大部分的全文索引数据。</target>
        </trans-unit>
        <trans-unit id="63f8d9aa5562f8625c8b6180eed7f4824807c199" translate="yes" xml:space="preserve">
          <source>This table contains the remainder of the full-text index data. It is almost always much smaller than the &amp;lt;name&amp;gt;_data table.</source>
          <target state="translated">该表包含全文索引数据的其余部分。它几乎总是比&amp;lt;name&amp;gt; _data表小得多。</target>
        </trans-unit>
        <trans-unit id="99a29c55c2ba7d8e5ed532c3667ff2c75e355b87" translate="yes" xml:space="preserve">
          <source>This template will be expanded considerably as we consider additional complications such as joins, compound selects, using indices to speed the search, sorting, and aggregate functions with and without GROUP BY and HAVING clauses. But the same basic ideas will continue to apply.</source>
          <target state="translated">这个模板将得到很大的扩展,因为我们将考虑更多的复杂情况,如连接、复合选择、使用索引来加快搜索、排序和聚合函数,有或没有GROUP BY和HAVING子句。但同样的基本思想将继续适用。</target>
        </trans-unit>
        <trans-unit id="24117611eed72daf6182805466d7956918d024ae" translate="yes" xml:space="preserve">
          <source>This template will work, but it is likely to be slow since we are now dealing with an O(N&lt;sup&gt;2&lt;/sup&gt;) loop. But it often works out that the WHERE clause can be factored into terms and that one or more of those terms will involve only columns in the first table. When this happens, we can factor part of the WHERE clause test out of the inner loop and gain a lot of efficiency. So a better template would be something like this:</source>
          <target state="translated">该模板可以工作，但是由于我们现在正在处理O（N &lt;sup&gt;2&lt;/sup&gt;）循环，因此它可能会很慢。但是通常可以得出结论，可以将WHERE子句分解为术语，并且其中一个或多个这些术语将仅涉及第一个表中的列。发生这种情况时，我们可以将WHERE子句测试的一部分从内部循环中分解出来，并获得很大的效率。因此，更好的模板如下所示：</target>
        </trans-unit>
        <trans-unit id="40b7eb475c7480d45cf5d3a80f0e3d7ffa7f110b" translate="yes" xml:space="preserve">
          <source>This test does 100 queries on a 25000 entry table without an index, thus requiring a full table scan. Prior versions of SQLite used to be slower than PostgreSQL and MySQL on this test, but recent performance enhancements have increased its speed so that it is now the fastest of the group.</source>
          <target state="translated">这个测试在一个25000条目的表上做100个查询,没有索引,因此需要全表扫描。以前的SQLite版本在这个测试中曾经比PostgreSQL和MySQL慢,但最近的性能提升提高了它的速度,所以它现在是这组中最快的。</target>
        </trans-unit>
        <trans-unit id="90bd4e8e5db8b4283e65f22e76a0a17334a8b857" translate="yes" xml:space="preserve">
          <source>This test is significant because it is one of the few where PostgreSQL is faster than MySQL. The asynchronous SQLite is, however, faster then both the other two.</source>
          <target state="translated">这个测试很重要,因为它是少数几个PostgreSQL比MySQL快的测试之一。然而,异步SQLite比其他两个都要快。</target>
        </trans-unit>
        <trans-unit id="ff90f130b4a2f4ca55eaa179d90bc136860c0418" translate="yes" xml:space="preserve">
          <source>This test still does 100 full table scans but it uses uses string comparisons instead of numerical comparisons. SQLite is over three times faster than PostgreSQL here and about 30% faster than MySQL.</source>
          <target state="translated">这个测试仍然是进行100次全表扫描,但它使用的是字符串比较而不是数字比较。SQLite在这里比PostgreSQL快3倍以上,比MySQL快30%左右。</target>
        </trans-unit>
        <trans-unit id="75cb6907a37685d70c3eab0489918444cffd71bd" translate="yes" xml:space="preserve">
          <source>This value may only be returned if the second argument to the conflict handler was SQLITE_CHANGESET_DATA or SQLITE_CHANGESET_CONFLICT. If this is not the case, any changes applied so far are rolled back and the call to sqlite3changeset_apply() returns SQLITE_MISUSE.</source>
          <target state="translated">只有当冲突处理程序的第二个参数是SQLITE_CHANGESET_DATA或SQLITE_CHANGESET_CONFLICT时,才可以返回这个值。如果不是这种情况,那么到目前为止应用的任何更改都会被回滚,并且调用 sqlite3changeset_apply()会返回 SQLITE_MISUSE。</target>
        </trans-unit>
        <trans-unit id="fe35134e2f2f77c904cd39e87bb164a345691cc7" translate="yes" xml:space="preserve">
          <source>This version of the query is very similar to that used by the &lt;a href=&quot;http://www.sqlite.org/search?q=fts3&quot;&gt;sqlite.org documentation search&lt;/a&gt; application.</source>
          <target state="translated">此版本的查询与&lt;a href=&quot;http://www.sqlite.org/search?q=fts3&quot;&gt;sqlite.org文档搜索&lt;/a&gt;应用程序使用的查询非常相似。</target>
        </trans-unit>
        <trans-unit id="e1b7ba2bf7de254b6233045869c121647086b777" translate="yes" xml:space="preserve">
          <source>This way, even if the tokenizer does not provide synonyms when tokenizing query text (it should not - to do so would be inefficient), it doesn't matter if the user queries for 'first + place' or '1st + place', as there are entries in the FTS index corresponding to both forms of the first token.</source>
          <target state="translated">这样一来,即使tokenizer在对查询文本进行token化时没有提供同义词(不应该这样做--这样做会很低效),用户查询 &quot;first+place &quot;或 &quot;1st+place &quot;也没有关系,因为在FTS索引中,有条目对应于第一个token的两种形式。</target>
        </trans-unit>
        <trans-unit id="8b49b7dda3f7ed95bc6c0488f10b2d72b542544f" translate="yes" xml:space="preserve">
          <source>This way, it doesn't matter if the unlock-notify callback has already been invoked, or is being invoked, when the wait_for_unlock_notify() thread begins blocking.</source>
          <target state="translated">这样,当wait_for_unlock_notify()线程开始阻塞时,不管解锁通知回调是否已经被调用,或者正在被调用。</target>
        </trans-unit>
        <trans-unit id="e965074df0aa19e8da42be140ba59a4414b6e325" translate="yes" xml:space="preserve">
          <source>This way, the constraint is enforced by SQLite. Attempting to insert a row into the</source>
          <target state="translated">这样一来,约束就被SQLite强制执行了。试图将一条记录插入到</target>
        </trans-unit>
        <trans-unit id="1963503ab7ddc8537d802ec1a46d6ab92fd36cda" translate="yes" xml:space="preserve">
          <source>This works just like the Eq opcode except that the jump is taken if the operands in registers P1 and P3 are not equal. See the Eq opcode for additional information.</source>
          <target state="translated">除了在寄存器P1和P3中的操作数不相等时进行跳转外,该操作码的工作原理与Eq操作码相同。更多信息请参见Eq操作码。</target>
        </trans-unit>
        <trans-unit id="ba4077bf92f07ea1c02be8f845355e71e2fb6bc1" translate="yes" xml:space="preserve">
          <source>This works just like the Lt opcode except that the jump is taken if the content of register P3 is greater than or equal to the content of register P1. See the Lt opcode for additional information.</source>
          <target state="translated">这和Lt操作码的工作原理一样,只是如果寄存器P3的内容大于或等于寄存器P1的内容,就会进行跳转。更多信息请参见Lt操作码。</target>
        </trans-unit>
        <trans-unit id="72ecdb2970fef3b315f55cce910e6f260e472e04" translate="yes" xml:space="preserve">
          <source>This works just like the Lt opcode except that the jump is taken if the content of register P3 is greater than the content of register P1. See the Lt opcode for additional information.</source>
          <target state="translated">这和Lt操作码的工作原理一样,只是如果寄存器P3的内容大于寄存器P1的内容,就会进行跳转。更多信息请参见Lt操作码。</target>
        </trans-unit>
        <trans-unit id="c1c247f5679a36aaa3ff0f0b8bb4e1ddc0bb02eb" translate="yes" xml:space="preserve">
          <source>This works just like the Lt opcode except that the jump is taken if the content of register P3 is less than or equal to the content of register P1. See the Lt opcode for additional information.</source>
          <target state="translated">这和Lt操作码的工作原理一样,只是如果寄存器P3的内容小于或等于寄存器P1的内容,就会进行跳转。更多信息请参见Lt操作码。</target>
        </trans-unit>
        <trans-unit id="ccca64f89115392e8d23869e20d951ca911dd666" translate="yes" xml:space="preserve">
          <source>Those columns of the ORDER BY that are already in the correct order due to indexes can be omitted from the sort key, further reducing storage requirements and CPU time.</source>
          <target state="translated">ORDER BY中那些因为索引而已经正确排序的列,可以从排序键中省略,进一步减少存储需求和CPU时间。</target>
        </trans-unit>
        <trans-unit id="3d2c9c2c10bcace961c3bdf096488ff4797705a5" translate="yes" xml:space="preserve">
          <source>Those familiar with &lt;a href=&quot;lang_createtrigger&quot;&gt;SQLite triggers&lt;/a&gt; will have noticed that the &quot;ON DELETE SET DEFAULT&quot; action demonstrated in the example above is similar in effect to the following AFTER DELETE trigger:</source>
          <target state="translated">那些熟悉&lt;a href=&quot;lang_createtrigger&quot;&gt;SQLite触发器的人&lt;/a&gt;会注意到，上例中演示的&amp;ldquo; ON DELETE SET DEFAULT&amp;rdquo;操作实际上与以下AFTER DELETE触发器类似：</target>
        </trans-unit>
        <trans-unit id="3d18009fe3f6af8b99678afaf8cbdbff34a63626" translate="yes" xml:space="preserve">
          <source>Though SQLite is resistant to database corruption, it is not immune. This document describes the various ways that an SQLite database might go corrupt.</source>
          <target state="translated">虽然SQLite对数据库损坏有抵抗力,但也不能幸免。本文档描述了SQLite数据库可能发生损坏的各种方式。</target>
        </trans-unit>
        <trans-unit id="63d965d7269cad4f0b5e995d2cd0b230b8d8b12b" translate="yes" xml:space="preserve">
          <source>Though most application should not notice any change (except that they run a little faster), if problems arise then the legacy behavior can be restored at compile-time by using the following options to the C-compiler:</source>
          <target state="translated">虽然大多数应用程序应该不会注意到任何变化(除了运行速度快了一点),但如果出现问题,那么可以在编译时通过使用以下选项恢复C-编译器的遗留行为。</target>
        </trans-unit>
        <trans-unit id="b87710f7e7be3fc29f9b95f7ed9731b29e09de9b" translate="yes" xml:space="preserve">
          <source>Though stable now, when SQLite was first designed, the rules for unicode case folding where still in flux. That means that the behavior might have changed with each new unicode release, disrupting applications and corrupting indexes in the process.</source>
          <target state="translated">虽然现在很稳定,但在最初设计SQLite时,unicode大小写折叠的规则还在不断变化中,这意味着行为可能会随着每个新的unicode版本的发布而改变,扰乱应用程序并破坏索引。这意味着行为可能会随着每个新的unicode版本的发布而改变,在此过程中会破坏应用程序并损坏索引。</target>
        </trans-unit>
        <trans-unit id="91666d572b5dcdd0257e06fbd15cb93e3374b565" translate="yes" xml:space="preserve">
          <source>Though the SQLite developers do not consider CVEs to be a reliable source of information about bugs in SQLite, they recognize that many groups, and especially small teams working at the bottom of tall bureaucracies, sometimes need to track CVEs, whether they are useful or not. To aid in this chore, the following table of recent CVEs affecting SQLite is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32c0373383e43339e4cb612416beb69372e9cd00" translate="yes" xml:space="preserve">
          <source>Though these routines exist for the use of the SQLite core, application code is free to use these routines as well, if desired. A mutex is an &lt;a href=&quot;c3ref/mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object. The &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt; routine allocates a new mutex object and returns a pointer to it. The argument to &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt; should be &lt;a href=&quot;c3ref/c_mutex_fast&quot;&gt;SQLITE_MUTEX_FAST&lt;/a&gt; or &lt;a href=&quot;c3ref/c_mutex_fast&quot;&gt;SQLITE_MUTEX_RECURSIVE&lt;/a&gt; for non-recursive and recursive mutexes, respectively. If the underlying system does not provide non-recursive mutexes, then a recursive mutex can be substituted in that case. The argument to &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt; can also be a constant designating one of several static mutexes:</source>
          <target state="translated">尽管存在使用SQLite核心的例程，但如果需要，应用程序代码也可以自由使用这些例程。互斥锁是&lt;a href=&quot;c3ref/mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;对象。所述&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_alloc（）&lt;/a&gt;例行程序分配一个新的互斥对象，并返回一个指向它的指针。对于非递归和递归互斥对象，&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_alloc（）&lt;/a&gt;的参数应分别为&lt;a href=&quot;c3ref/c_mutex_fast&quot;&gt;SQLITE_MUTEX_FAST&lt;/a&gt;或&lt;a href=&quot;c3ref/c_mutex_fast&quot;&gt;SQLITE_MUTEX_RECURSIVE&lt;/a&gt;。如果基础系统不提供非递归互斥锁，则在这种情况下可以替换递归互斥锁。&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_alloc（）&lt;/a&gt;的参数也可以是一个常量，它指定多个静态互斥锁之一：</target>
        </trans-unit>
        <trans-unit id="bd8e45f7c88cdfcb99131b4aaa5838c20ed6b8b6" translate="yes" xml:space="preserve">
          <source>Threads pragma</source>
          <target state="translated">线程 Pragma</target>
        </trans-unit>
        <trans-unit id="4aa00012e302f932462a2aadd7eac2be49a6dc69" translate="yes" xml:space="preserve">
          <source>Three independently developed test harnesses</source>
          <target state="translated">三个独立开发的测试线束</target>
        </trans-unit>
        <trans-unit id="101417f647e79751240d39257253cbe0e7dba110" translate="yes" xml:space="preserve">
          <source>Three new &quot;_pointer()&quot; interfaces were added to SQLite 3.20.0 (2017-08-01):</source>
          <target state="translated">SQLite 3.20.0(2017-08-01)新增了三个&quot;_pointer()&quot;接口。</target>
        </trans-unit>
        <trans-unit id="176df8577c19b0a0b1cbe128b8ab9971af780b41" translate="yes" xml:space="preserve">
          <source>Three new interfaces are used to create alternative OS interfaces: &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;, &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_unregister()&lt;/a&gt;, and &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt;.</source>
          <target state="translated">使用三个新接口来创建备用OS接口：&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;，&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_unregister（）&lt;/a&gt;和&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bddfc84ad3ee0ff45f2511104b4769a3c7921c10" translate="yes" xml:space="preserve">
          <source>Three new objects are defined for specifying I/O procedures: &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;, &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;, and &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;.</source>
          <target state="translated">定义了三个用于指定I / O过程的新对象：&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;，&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;和&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26f24f48d0d16296ec7a50525c0bafe03ba4c4e6" translate="yes" xml:space="preserve">
          <source>Three separate builds are used to validate the SQLite software.</source>
          <target state="translated">三个独立的构建是用来验证SQLite软件的。</target>
        </trans-unit>
        <trans-unit id="72ea1e12fc0eda1090ebcae83911a5114d06b045" translate="yes" xml:space="preserve">
          <source>Throughout this article, we will call the mass storage device &quot;disk&quot; even though the mass storage device might really be flash memory.</source>
          <target state="translated">在本文中,我们将把大容量存储设备称为 &quot;磁盘&quot;,尽管大容量存储设备可能真的是闪存。</target>
        </trans-unit>
        <trans-unit id="e196474211e435a6f5483b8a22aa9fc7215731cf" translate="yes" xml:space="preserve">
          <source>Throw an error if the ON clause of a LEFT JOIN references tables to the right of the ON clause. This is the same behavior as PostgreSQL. Formerly, SQLite silently converted the LEFT JOIN into an INNER JOIN. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/25e335f802dd&quot;&gt;25e335f802dd&lt;/a&gt;.</source>
          <target state="translated">如果LEFT JOIN的ON子句引用ON子句右边的表，则会引发错误。这与PostgreSQL的行为相同。以前，SQLite默默地将LEFT JOIN转换为INNER JOIN。修复票证&lt;a href=&quot;https://www.sqlite.org/src/info/25e335f802dd&quot;&gt;25e335f802dd&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="21549ff8099c71713aab7703fb00b1ee44e6073d" translate="yes" xml:space="preserve">
          <source>Thus a long-running read transaction can prevent a checkpointer from making progress. But presumably every read transaction will eventually end and the checkpointer will be able to continue.</source>
          <target state="translated">因此,一个长期运行的读事务会阻止检查指针的进展。但大概每个读事务最终都会结束,检查指针将能够继续。</target>
        </trans-unit>
        <trans-unit id="66a9c8441c0a2a7c6aa8fad21d196fb6d9fccc17" translate="yes" xml:space="preserve">
          <source>Thus, in some cases, a WITHOUT ROWID table can use about half the amount of disk space and can operate nearly twice as fast. Of course, in a real-world schema, there will typically be secondary indices and/or UNIQUE constraints, and the situation is more complicated. But even then, there can often be space and performance advantages to using WITHOUT ROWID on tables that have non-integer or composite PRIMARY KEYs.</source>
          <target state="translated">因此,在某些情况下,without ROWID表可以使用大约一半的磁盘空间,而且运行速度几乎是两倍。当然,在现实世界的模式中,通常会有二级索引和/或UNIQUE约束,情况比较复杂。但即便如此,在有非整数或复合primary keys的表上使用without rowid往往可以获得空间和性能上的优势。</target>
        </trans-unit>
        <trans-unit id="c862bae7f1be02bdcb9d8e255dd3ec4c98f14797" translate="yes" xml:space="preserve">
          <source>Time Strings</source>
          <target state="translated">时间字符串</target>
        </trans-unit>
        <trans-unit id="3efef30f9e54a3aa98bf3ea7266c1fe5e32903a6" translate="yes" xml:space="preserve">
          <source>Timeout method</source>
          <target state="translated">超时方法</target>
        </trans-unit>
        <trans-unit id="4c2102fd7eb59a1aa14201958dca73486b19babc" translate="yes" xml:space="preserve">
          <source>Tip: If the application requires a stricter relationship between</source>
          <target state="translated">提示:如果应用程序需要更严格的之间的关系。</target>
        </trans-unit>
        <trans-unit id="9e8b45c5519a803740f95fa980a6771d28344be2" translate="yes" xml:space="preserve">
          <source>Tip: If the command &quot;PRAGMA foreign_keys&quot; returns no data instead of a single row containing &quot;0&quot; or &quot;1&quot;, then the version of SQLite you are using does not support foreign keys (either because it is older than 3.6.19 or because it was compiled with &lt;a href=&quot;compile#omit_foreign_key&quot;&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/a&gt; or &lt;a href=&quot;compile#omit_trigger&quot;&gt;SQLITE_OMIT_TRIGGER&lt;/a&gt; defined).</source>
          <target state="translated">提示：如果命令&amp;ldquo; PRAGMA foreign_keys&amp;rdquo;不返回任何数据，而不是包含&amp;ldquo; 0&amp;rdquo;或&amp;ldquo; 1&amp;rdquo;的单行，则您使用的SQLite版本不支持外键（因为它早于3.6.19或因为它是使用&lt;a href=&quot;compile#omit_trigger&quot;&gt;已&lt;/a&gt;定义的&lt;a href=&quot;compile#omit_foreign_key&quot;&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/a&gt;或SQLITE_OMIT_TRIGGER编译的）。</target>
        </trans-unit>
        <trans-unit id="c0bd7276e013b0c8d316928d427b046dc76a4f10" translate="yes" xml:space="preserve">
          <source>To &quot;apply affinity&quot; means to convert an operand to a particular storage class if and only if the conversion does not lose essential information. Numeric values can always be converted into TEXT. TEXT values can be converted into numeric values if the text content is a well-formed integer or real literal, but not a hexadecimal integer literal. BLOB values are converted into TEXT values by simply interpreting the binary BLOB context as a text string in the current database encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9953da657538c4e50d519e562b12ca1980f1dcb7" translate="yes" xml:space="preserve">
          <source>To &quot;apply affinity&quot; means to convert an operand to a particular storage class if and only if the conversion is lossless and reversible. Affinity is applied to operands of a comparison operator prior to the comparison according to the following rules in the order shown:</source>
          <target state="translated">&quot;应用亲和力 &quot;是指将操作数转换为特定的存储类,如果且仅当转换是无损和可逆的。亲和力在比较操作数之前按照下列规则按所示顺序应用于比较操作数。</target>
        </trans-unit>
        <trans-unit id="5a8c0c09fa3a23fe732db499c52749bc592395f7" translate="yes" xml:space="preserve">
          <source>To SQL, the values created by &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; are indistinguishable from NULL. An SQL statement that tries to use the &lt;a href=&quot;lang_corefunc#hex&quot;&gt;hex()&lt;/a&gt; function to read the value of a pointer will get an SQL NULL answer. The only way to discover whether or not a value has an associated pointer is to use the &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; interface with the appropriate type string T.</source>
          <target state="translated">对于SQL，由&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;和&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;创建的值与NULL是无法区分的。尝试使用&lt;a href=&quot;lang_corefunc#hex&quot;&gt;hex（）&lt;/a&gt;函数读取指针值的SQL语句将获得SQL NULL答案。发现值是否具有关联的指针的唯一方法是使用带有适当类型字符串T 的&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="bd20e3a8ddd8b4faa78ec9a165e77cef8f3d196f" translate="yes" xml:space="preserve">
          <source>To achieve the best long-term query performance without the need to do a detailed engineering analysis of the application schema and SQL, it is recommended that applications run &quot;PRAGMA optimize&quot; (with no arguments) just before closing each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. Long-running applications might also benefit from setting a timer to run &quot;PRAGMA optimize&quot; every few hours.</source>
          <target state="translated">为了获得最佳的长期查询性能，而无需对应用程序模式和SQL进行详细的工程分析，建议在关闭每个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;之前，应用程序运行&amp;ldquo; PRAGMAoptimize&amp;rdquo;（不带参数）。长时间运行的应用程序还可以通过设置计时器每隔几个小时运行一次&amp;ldquo; PRAGMA优化&amp;rdquo;来受益。</target>
        </trans-unit>
        <trans-unit id="4711fd773d775e7aba9628e842931be929ca6432" translate="yes" xml:space="preserve">
          <source>To activate memory-mapped I/O, an application can set the mmap_size to some large value. For example:</source>
          <target state="translated">为了激活内存映射的I/O,应用程序可以将mmap_size设置为某个大值。例如:</target>
        </trans-unit>
        <trans-unit id="645a357eaf144992f34fe37551ab4e935405fce2" translate="yes" xml:space="preserve">
          <source>To activate the undo/redo logic, invoke the undo::activate command with all classes (tables) that are to participate in the undo/redo as arguments. Use undo::deactivate, undo::freeze, and undo::unfreeze to control the state of the undo/redo mechanism.</source>
          <target state="translated">要激活 undo::activate 逻辑,请调用 undo::activate 命令,将所有要参与 undo/redo 的类(表)作为参数。使用 undo::deactivate、undo::freeze 和 undo::unfreeze 来控制 undo/redo 机制的状态。</target>
        </trans-unit>
        <trans-unit id="fd71ab2838c8371371ec0d2fdb4dcfcc6665885b" translate="yes" xml:space="preserve">
          <source>To add or update files in an existing SQLite Archive:</source>
          <target state="translated">在现有的SQLite存档中添加或更新文件。</target>
        </trans-unit>
        <trans-unit id="4ae1010309917f14b49ddef52acc40466e6c17b8" translate="yes" xml:space="preserve">
          <source>To add prefix indexes to an FTS5 table, the &quot;prefix&quot; option is set to either a single positive integer or a text value containing a white-space separated list of one or more positive integer values. A prefix index is created for each integer specified. If more than one &quot;prefix&quot; option is specified as part of a single CREATE VIRTUAL TABLE statement, all apply.</source>
          <target state="translated">要将前缀索引添加到FTS5表中,&quot;前缀 &quot;选项被设置为一个单一的正整数或一个包含一个或多个正整数值的空白分隔列表的文本值。每个指定的整数都会创建一个前缀索引。如果在一个CREATE VIRTUAL TABLE语句中指定了一个以上的 &quot;前缀 &quot;选项,那么所有的前缀都适用。</target>
        </trans-unit>
        <trans-unit id="c191d56879fcb319acf75a9863fb0fa338e351b7" translate="yes" xml:space="preserve">
          <source>To append an element onto the end of an array, using json_insert() with an array index of &quot;#&quot;. Examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9404c6d887c060fefd19170a66f575055b2dffb6" translate="yes" xml:space="preserve">
          <source>To avoid a parsing ambiguity, the SELECT statement should always contain a WHERE clause, even if that clause is simply &quot;WHERE true&quot;, if the &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt; is present. Without the WHERE clause, the parser does not know if the token &quot;ON&quot; is part of a join constraint on the SELECT, or the beginning of the &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;.</source>
          <target state="translated">为避免语法歧义，SELECT语句应始终包含WHERE子句，即使该子句只是&amp;ldquo; WHERE true&amp;rdquo;（如果存在&lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert子句）&lt;/a&gt;也是如此。没有WHERE子句，解析器将不知道标记&amp;ldquo; ON&amp;rdquo;是否是SELECT上的&lt;a href=&quot;syntax/upsert-clause&quot;&gt;联接&lt;/a&gt;约束的一部分，还是upsert-clause的开头。</target>
        </trans-unit>
        <trans-unit id="a1e573e48b1d1bbc7ead62db489ded9fccb8416c" translate="yes" xml:space="preserve">
          <source>To avoid a resource leak, every open &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; should eventually be released by a call to &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;.</source>
          <target state="translated">为了避免资源泄漏，最终应通过调用&lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close（）&lt;/a&gt;释放每个打开的&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d1fa3979b4e4aef1b6ce33c8f42fa7bd685b437c" translate="yes" xml:space="preserve">
          <source>To avoid a resource leak, every open &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; should eventually be released by a call to &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;.</source>
          <target state="translated">为了避免资源泄漏，最终应通过调用&lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close（）&lt;/a&gt;释放每个打开的&lt;a href=&quot;blob&quot;&gt;BLOB句柄&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1ab3db1a50085aa74a015739222af42ac2d31de2" translate="yes" xml:space="preserve">
          <source>To avoid creating the temporary table, the query might be rewritten as follows:</source>
          <target state="translated">为了避免创建临时表,查询可以改写如下。</target>
        </trans-unit>
        <trans-unit id="a939a1a7b1b6da9d7410b936fb953adb2a10ab14" translate="yes" xml:space="preserve">
          <source>To avoid deadlocks and other threading problems, the sqlite3_log() routine will not use dynamically allocated memory. The log message is stored in a fixed-length buffer on the stack. If the log message is longer than a few hundred characters, it will be truncated to the length of the buffer.</source>
          <target state="translated">为了避免死锁和其他线程问题,sqlite3_log()例程不会使用动态分配的内存。日志信息存储在堆栈上一个固定长度的缓冲区中。如果日志信息超过几百个字符,它将被截断到缓冲区的长度。</target>
        </trans-unit>
        <trans-unit id="4d1915ee0fe2780a5f846ddace0d96d4a65194c4" translate="yes" xml:space="preserve">
          <source>To avoid having to register all collation sequences before a database can be used, a single callback function may be registered with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; to be invoked whenever an undefined collation sequence is required.</source>
          <target state="translated">为了避免在使用数据库之前必须注册所有排序规则序列，只要需要未定义的排序规则序列，就可以在要调用的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接中&lt;/a&gt;注册单个回调函数。</target>
        </trans-unit>
        <trans-unit id="e2a04aec5cbeb09fcc4e41c36a55b1da3e1b43d6" translate="yes" xml:space="preserve">
          <source>To avoid having to register all collation sequences before a database can be used, a single callback function may be registered with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; to be invoked whenever an undefined collation sequence is required.</source>
          <target state="translated">为了避免在使用数据库之前必须注册所有排序规则序列，只要需要未定义的排序规则序列，就可以在要调用的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接中&lt;/a&gt;注册单个回调函数。</target>
        </trans-unit>
        <trans-unit id="f9e3ed74fe6098d68e31f0bee29e829f469078e4" translate="yes" xml:space="preserve">
          <source>To avoid name collisions, all external symbols in the SQLite library begin with the prefix &lt;b&gt;sqlite3&lt;/b&gt;. Those symbols that are intended for external use (in other words, those symbols which form the API for SQLite) add an underscore, and thus begin with &lt;b&gt;sqlite3_&lt;/b&gt;. Extension APIs sometimes add the extension name prior to the underscore; for example: &lt;b&gt;sqlite3rbu_&lt;/b&gt; or &lt;b&gt;sqlite3session_&lt;/b&gt;.</source>
          <target state="translated">为了避免名称冲突，SQLite库中的所有外部符号都以前缀&lt;b&gt;sqlite3&lt;/b&gt;开头。这些供外部使用的符号（换句话说，构成SQLite API的那些符号）添加了下划线，因此以&lt;b&gt;sqlite3_&lt;/b&gt;开头。扩展API有时会在下划线之前添加扩展名。例如：&lt;b&gt;sqlite3rbu_&lt;/b&gt;或&lt;b&gt;sqlite3session_&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="51b8dbcd79c868e6c2b51fbc0d8f4e62d1ce3707" translate="yes" xml:space="preserve">
          <source>To avoid spiky INSERT performance, an application can run the &quot;merge=X,Y&quot; command periodically, possibly in an idle thread or idle process, to ensure that the FTS table never accumulates too many b-tree segments at the same level. INSERT performance spikes can generally be avoided, and performance of FTS3/4 can be maximized, by running &quot;merge=X,Y&quot; after every few thousand document inserts. Each &quot;merge=X,Y&quot; command will run in a separate transaction (unless they are grouped together using &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;...&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;, of course). The transactions can be kept small by choosing a value for X in the range of 100 to 300. The idle thread that is running the merge commands can know when it is done by checking the difference in &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; before and after each &quot;merge=X,Y&quot; command and stopping the loop when the difference drops below two.</source>
          <target state="translated">为了避免尖锐的INSERT性能，应用程序可以定期（可能在空闲线程或空闲进程中）运行&amp;ldquo; merge = X，Y&amp;rdquo;命令，以确保FTS表在同一级别上永远不会累积太多的b树段。通过每插入几千个文档后运行&amp;ldquo; merge = X，Y&amp;rdquo;，通常可以避免INSERT性能峰值，并且可以最大化FTS3 / 4的性能。每个&amp;ldquo; merge = X，Y&amp;rdquo;命令将在单独的事务中运行（当然，除非使用&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; ... &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;将它们分组在一起）。通过为X选择一个介于100到300之间的值，可以使事务保持较小状态。运行合并命令的空闲线程可以通过检查&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）中&lt;/a&gt;的差异来知道何时完成该事务。 在每个&amp;ldquo; merge = X，Y&amp;rdquo;命令之前和之后，并在差值降至2以下时停止循环。</target>
        </trans-unit>
        <trans-unit id="bed15fd00e4480b7c81ecee249b2b398f62c1b86" translate="yes" xml:space="preserve">
          <source>To avoid this scenario, the sqlite3_unlock_notify() performs deadlock detection. If a given call to sqlite3_unlock_notify() would put the system in a deadlocked state, then SQLITE_LOCKED is returned and no unlock-notify callback is registered. The system is said to be in a deadlocked state if connection A has registered for an unlock-notify callback on the conclusion of connection B's transaction, and connection B has itself registered for an unlock-notify callback when connection A's transaction is concluded. Indirect deadlock is also detected, so the system is also considered to be deadlocked if connection B has registered for an unlock-notify callback on the conclusion of connection C's transaction, where connection C is waiting on connection A. Any number of levels of indirection are allowed.</source>
          <target state="translated">为了避免这种情况,sqlite3_unlock_notify()执行死锁检测。如果给定的对 sqlite3_unlock_notify()的调用会使系统处于死锁状态,那么返回 SQLITE_LOCKED,并且没有注册任何解锁-通知回调。如果连接A在连接B的事务结束时注册了一个解锁-通知回调,而连接B在连接A的事务结束时自己也注册了一个解锁-通知回调,那么系统就被称为处于死锁状态。间接死锁也会被检测到,所以如果连接B在连接C的事务结束时注册了一个解锁-通知回调,而连接C在连接A上等待,那么系统也被认为是死锁的,允许任何数量的间接级别。</target>
        </trans-unit>
        <trans-unit id="3e35797a56e3488dd19632be8d37b7c920ead5fc" translate="yes" xml:space="preserve">
          <source>To be clear: &quot;</source>
          <target state="translated">要说明的是:&quot;</target>
        </trans-unit>
        <trans-unit id="80e35d386745dd980983bb89049deefc03dfe51b" translate="yes" xml:space="preserve">
          <source>To build a DLL of SQLite for use in Windows, first acquire the appropriate amalgamated source code files, sqlite3.c and sqlite3.h. These can either be downloaded from the &lt;a href=&quot;http://www.sqlite.org/download.html&quot;&gt;SQLite website&lt;/a&gt; or custom generated from sources as shown above.</source>
          <target state="translated">要构建用于Windows的SQLite DLL，请首先获取适当的混合源代码文件sqlite3.c和sqlite3.h。可以从&lt;a href=&quot;http://www.sqlite.org/download.html&quot;&gt;SQLite网站&lt;/a&gt;下载这些文件，也可以从上面显示的源中定制生成这些文件。</target>
        </trans-unit>
        <trans-unit id="8c2bc1841bf864b266faa9153cf419507175bd74" translate="yes" xml:space="preserve">
          <source>To build a copy of the dbhash utility program on unix, get a copy of the canonical SQLite source code and enter:</source>
          <target state="translated">要在unix上建立一个dbhash实用程序的副本,得到一份规范的SQLite源代码并输入。</target>
        </trans-unit>
        <trans-unit id="8dbbee62ca23cc1e3fdd3d3f98bea994ab8a5656" translate="yes" xml:space="preserve">
          <source>To build a custom amalgamation, first download the original individual source files onto a unix or unix-like development platform. Be sure to get the original source files not the &quot;preprocessed source files&quot;. One can obtain the complete set of original source files either from the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; or directly from the &lt;a href=&quot;http://www.sqlite.org/src&quot;&gt;configuration management system&lt;/a&gt;.</source>
          <target state="translated">要构建自定义合并，请首先将原始的单个源文件下载到unix或类似unix的开发平台上。确保获取原始源文件，而不是&amp;ldquo;预处理的源文件&amp;rdquo;。可以从&lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;下载页面&lt;/a&gt;或直接从&lt;a href=&quot;http://www.sqlite.org/src&quot;&gt;配置管理系统&lt;/a&gt;获取完整的原始源文件集。</target>
        </trans-unit>
        <trans-unit id="bbb58546549ded0701f18afdab64c04ca26ea6a1" translate="yes" xml:space="preserve">
          <source>To build the CLI, simply put these three files in the same directory and compile them together. Using MSVC:</source>
          <target state="translated">要构建CLI,只需将这三个文件放在同一个目录下,然后一起编译。使用MSVC。</target>
        </trans-unit>
        <trans-unit id="5d2c0fe38d130be317edc2f5dfddee01ac43e855" translate="yes" xml:space="preserve">
          <source>To build the amalgamation (either the full amalgamation or the split amalgamation), first &lt;a href=&quot;getthecode&quot;&gt;get the canonical source code&lt;/a&gt; from one of the three servers. Then, on both unix-like systems and on Windows systems that have the free &lt;a href=&quot;http://mingw.org/wiki/msys&quot;&gt;MinGW&lt;/a&gt; development environment installed, the amalgamation can be built using the following commands:</source>
          <target state="translated">要构建合并（完全合并或拆分合并），请首先从三个服务器之一&lt;a href=&quot;getthecode&quot;&gt;获取规范源代码&lt;/a&gt;。然后，在类似unix的系统上以及在安装了免费&lt;a href=&quot;http://mingw.org/wiki/msys&quot;&gt;MinGW&lt;/a&gt;开发环境的Windows系统上，可以使用以下命令构建合并：</target>
        </trans-unit>
        <trans-unit id="774e7f5cdd8b87b1abd96dec12eb0c1dad3d32d9" translate="yes" xml:space="preserve">
          <source>To build the checksum VFS module into a run-time loadable extension, use commands similar to the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7b9af325052cb89e33dbc430967cc0b7deb7cf6" translate="yes" xml:space="preserve">
          <source>To build using Microsoft Visual C++, run this command:</source>
          <target state="translated">要使用Microsoft Visual C++构建,请运行此命令。</target>
        </trans-unit>
        <trans-unit id="39cded5adcef7aa92aca1ba527e5da5a120510e0" translate="yes" xml:space="preserve">
          <source>To cast a BLOB value to TEXT, the sequence of bytes that make up the BLOB is interpreted as text encoded using the database encoding.</source>
          <target state="translated">要将BLOB值转换为TEXT,组成BLOB的字节序列将被解释为使用数据库编码的文本。</target>
        </trans-unit>
        <trans-unit id="78f27fb02b3100de75bd999544415d6f6516d9a7" translate="yes" xml:space="preserve">
          <source>To cause SQLite to use a new memory allocator, the application simply calls:</source>
          <target state="translated">要使SQLite使用一个新的内存分配器,应用程序只需调用。</target>
        </trans-unit>
        <trans-unit id="06731044cb7999e326abfa5edb7ddc70e70000e7" translate="yes" xml:space="preserve">
          <source>To change your check-out to the private branch, type:</source>
          <target state="translated">要改变您的结帐方式,请输入。</target>
        </trans-unit>
        <trans-unit id="1981f2b6db16ebcce7bb76f8ad9bf3a92a4b7325" translate="yes" xml:space="preserve">
          <source>To change your checkout to a different version of Fossil use the &quot;update&quot; command:</source>
          <target state="translated">要改变你的结账到不同版本的Fossil,使用 &quot;更新 &quot;命令。</target>
        </trans-unit>
        <trans-unit id="e90e1970a4d12dd7ff50fb8afa438dceccf71dae" translate="yes" xml:space="preserve">
          <source>To circumvent this limitation, the amalgamation is also available in a split form, consisting of files &quot;sqlite3-1.c&quot;, &quot;sqlite3-2.c&quot;, and so forth, where each file is less than 32,768 lines in length and where the concatenation of the files contain all of the code for the complete amalgamation. Then there is a separate source file named &quot;sqlite3-all.c&quot; which basically consists of code like this:</source>
          <target state="translated">为了规避这个限制,还可以用拆分的形式,由 &quot;sqlite3-1.c&quot;、&quot;sqlite3-2.c &quot;等文件组成,每个文件的长度都小于32768行,这些文件的合并包含了完整的amalgamation的所有代码。然后还有一个单独的源文件,名为 &quot;sqlite3-all.c&quot;,基本由这样的代码组成。</target>
        </trans-unit>
        <trans-unit id="2e894e5b94a3ef2bd6606b0bac122e783cd91aa9" translate="yes" xml:space="preserve">
          <source>To clarify, if this function is called and then a changeset constructed using &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt;, then after applying that changeset to database zFrom the contents of the two compatible tables would be identical.</source>
          <target state="translated">为了明确&lt;a href=&quot;#sqlite3session_changeset&quot;&gt;起见&lt;/a&gt;，如果先调用此函数，然后使用sqlite3session_changeset（）构造一个变更集，则将该变更集应用于数据库z之后，两个兼容表的内容将相同。</target>
        </trans-unit>
        <trans-unit id="6d157b6ace52aa2f1341c1373e4a984c6c232891" translate="yes" xml:space="preserve">
          <source>To clarify, if this function is called and then a changeset constructed using &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt;, then after applying that changeset to database zFrom the contents of the two compatible tables would be identical.</source>
          <target state="translated">为了明确&lt;a href=&quot;sqlite3session_changeset&quot;&gt;起见&lt;/a&gt;，如果先调用此函数，然后使用sqlite3session_changeset（）构造一个变更集，则将该变更集应用于数据库z之后，两个兼容表的内容将相同。</target>
        </trans-unit>
        <trans-unit id="c1845a0b274cc5a67a90f51319c61b78f90f9584" translate="yes" xml:space="preserve">
          <source>To clarify: SQLite version 3.31.0 can read and write any database created by any prior version of SQLite going back to SQLite 3.0.0 (2004-06-18). And, earlier versions of SQLite, prior to 3.31.0, can read and write databases created by SQLite version 3.31.0 and later as long as the database schema does not contain features, such as generated columns, that are not understood by the earlier version. Problems only arise if you create a new database that contains generated columns, using SQLite version 3.31.0 or later, and then try to read or write that database file using an earlier version of SQLite that does not understand generated columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f3d190805c91114a85c4ded726387a4e9c9b6ef" translate="yes" xml:space="preserve">
          <source>To clarify: an extension for which the initialization function returns SQLITE_OK_LOAD_PERMANENTLY continues to exist in memory after the database connection closes. However, the extension is &lt;em&gt;not&lt;/em&gt; automatically registered with subsequent database connections. This makes it possible to load extensions that implement new &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;. To persistently load and register an extension that implements new SQL functions, collating sequences, and/or virtual tables, such that those added capabilities are available to all subsequent database connections, then the initialization routine should also invoke &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; on a subfunction that will register those services.</source>
          <target state="translated">需要说明的是：在数据库连接关闭之后，初始化函数返回SQLITE_OK_LOAD_PERMANENTLY的扩展名继续存在于内存中。但是，该扩展名&lt;em&gt;不会&lt;/em&gt;自动注册到后续数据库连接中。这样就可以加载实现新&lt;a href=&quot;vfs&quot;&gt;VFS的&lt;/a&gt;扩展。为了持久地加载和注册一个实现新SQL函数，整理序列和/或虚拟表的扩展，以使这些附加功能可用于所有后续数据库连接，则初始化例程还应在子函数上调用&lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;注册这些服务。</target>
        </trans-unit>
        <trans-unit id="bccbaf3af7fd4e2f28bb629648fc3e526aaa7ab9" translate="yes" xml:space="preserve">
          <source>To clone the entire history of SQLite, first go to the &lt;a href=&quot;http://www.fossil-scm.org/download.html&quot;&gt;http://www.fossil-scm.org/download.html&lt;/a&gt; page and grab a precompiled binary for the Fossil version control program. Or get the source code on the same page and compile it yourself.</source>
          <target state="translated">要克隆SQLite的整个历史记录，请首先转到&lt;a href=&quot;http://www.fossil-scm.org/download.html&quot;&gt;http://www.fossil-scm.org/download.html&lt;/a&gt;页面，并获取Fossil版本控制程序的预编译二进制文件。或在同一页面上获取源代码并自己编译。</target>
        </trans-unit>
        <trans-unit id="1a2fe4833a1026479d31af2dc4ee8fce8b3b5030" translate="yes" xml:space="preserve">
          <source>To close an SQLite database, call the &lt;b&gt;sqlite_close&lt;/b&gt; function passing it the sqlite structure pointer that was obtained from a prior call to &lt;b&gt;sqlite_open&lt;/b&gt;. If a transaction is active when the database is closed, the transaction is rolled back.</source>
          <target state="translated">要关闭SQLite数据库，请调用&lt;b&gt;sqlite_close&lt;/b&gt;函数，&lt;b&gt;向其&lt;/b&gt;传递从先前调用&lt;b&gt;sqlite_open&lt;/b&gt;获得的sqlite结构指针。如果在关闭数据库时事务处于活动状态，则将回滚该事务。</target>
        </trans-unit>
        <trans-unit id="2864c3c7a649d4d26acb60269d4c618571d81546" translate="yes" xml:space="preserve">
          <source>To compile for Windows using MinGW, the command line is just like it is for unix except that the output file suffix is changed to &quot;.dll&quot; and the -fPIC argument is omitted:</source>
          <target state="translated">要使用MinGW在Windows下编译,命令行和unix下一样,只是输出文件后缀改为&quot;.dll&quot;,并且省略了-fPIC参数。</target>
        </trans-unit>
        <trans-unit id="f73c38ca2dac9f31efaddc70782e387db0501bf7" translate="yes" xml:space="preserve">
          <source>To compile on Windows using MSVC, a command similar to the following will usually work:</source>
          <target state="translated">要在Windows上使用MSVC进行编译,通常使用类似于下面的命令即可。</target>
        </trans-unit>
        <trans-unit id="5f996fbc61d75fe9538101264c9b8819e60f8184" translate="yes" xml:space="preserve">
          <source>To compile the command-line shell on unix systems and on Windows with MinGW, the usual configure-make command works:</source>
          <target state="translated">要在unix系统和Windows系统上用MinGW编译命令行shell,一般的configure-make命令就可以了。</target>
        </trans-unit>
        <trans-unit id="51cc1e77b8f71008cf9ef9201c87c8f93c492b49" translate="yes" xml:space="preserve">
          <source>To compute aggregate functions, the VDBE implements a special data structure and instructions for controlling that data structure. The data structure is an unordered set of buckets, where each bucket has a key and one or more memory locations. Within the query loop, the GROUP BY clause is used to construct a key and the bucket with that key is brought into focus. A new bucket is created with the key if one did not previously exist. Once the bucket is in focus, the memory locations of the bucket are used to accumulate the values of the various aggregate functions. After the query loop terminates, each bucket is visited once to generate a single row of the results.</source>
          <target state="translated">为了计算集合函数,VDBE实现了一个特殊的数据结构和控制该数据结构的指令。数据结构是一组无序的桶,其中每个桶有一个键和一个或多个内存位置。在查询循环中,GROUP BY子句被用来构造一个键,并使带有该键的bucket成为焦点。如果之前不存在一个新的桶,那么就会用这个键创建一个新的桶。一旦bucket被聚焦,bucket的内存位置就被用来累积各种聚合函数的值。在查询循环终止后,每个桶被访问一次,以生成结果的单行。</target>
        </trans-unit>
        <trans-unit id="94ded02646e1eb96801f525361b3b596cadfec9e" translate="yes" xml:space="preserve">
          <source>To control memory usage in the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt;, compile with &quot;&lt;a href=&quot;compile#printf_precision_limit&quot;&gt;-DSQLITE_PRINTF_PRECISION_LIMIT=1000&lt;/a&gt;&quot; or some similar small value. This #define limits the width and precision for %-substitutions in the printf() function, and thus prevents a hostile SQL statement from consuming large amounts of RAM via constructs such as &quot;&lt;code&gt;printf('%1000000000s','hi')&lt;/code&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de49f53ff4a4b3038be9f08fcf4db86631b03856" translate="yes" xml:space="preserve">
          <source>To convert an SQLite 2.8 database into an SQLite 3.0 database, have ready the command-line shells for both version 2.8 and 3.0. Then enter a command like the following:</source>
          <target state="translated">要将SQLite 2.8数据库转换为SQLite 3.0数据库,需要准备好2.8和3.0版本的命令行shell。然后输入类似下面的命令。</target>
        </trans-unit>
        <trans-unit id="d15f29e334ec535855fdc1d71f46105bc0e5b848" translate="yes" xml:space="preserve">
          <source>To convert the results of an SQL expression to a boolean value, SQLite first casts the result to a NUMERIC value in the same way as a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt;. A numeric zero value (integer value 0 or real value 0.0) is considered to be false. A NULL value is still NULL. All other values are considered true.</source>
          <target state="translated">要将SQL表达式的结果转换为布尔值，SQLite首先以与&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST表达式&lt;/a&gt;相同的方式将结果转换为NUMERIC值。数字零值（整数值0或实数值0.0）被认为是错误的。NULL值仍为NULL。所有其他值都被认为是正确的。</target>
        </trans-unit>
        <trans-unit id="86fc6f32b0c0d0aa47c4d6f69f34d90eb1dafec6" translate="yes" xml:space="preserve">
          <source>To create a WITHOUT ROWID table, simply add the keywords &quot;WITHOUT ROWID&quot; to the end of the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. For example:</source>
          <target state="translated">要创建WITHOUT ROWID表，只需在&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句的末尾添加关键字&amp;ldquo; WITHOUT ROWID&amp;rdquo; 。例如：</target>
        </trans-unit>
        <trans-unit id="44c6e38819829481385517b096a1954e645cc686" translate="yes" xml:space="preserve">
          <source>To create a custom tokenizer, an application must implement three functions: a tokenizer constructor (xCreate), a destructor (xDelete) and a function to do the actual tokenization (xTokenize). The type of each function is as for the member variables of the fts5_tokenizer struct:</source>
          <target state="translated">要创建一个自定义的标记化器,应用程序必须实现三个函数:一个标记化器构造函数 (xCreate),一个解构函数 (xDelete),以及一个用于实际标记化的函数 (xTokenize)。每个函数的类型与fts5_tokenizer结构的成员变量相同。</target>
        </trans-unit>
        <trans-unit id="e13c6f787f4a4c87c62a52e8c2eaf1189f9ab3f7" translate="yes" xml:space="preserve">
          <source>To create a new SQLite Archive named &quot;alltxt.sqlar&quot; containing all *.txt files in the current directory:</source>
          <target state="translated">创建一个名为 &quot;alltxt.sqllar &quot;的新SQLite存档,其中包含当前目录下的所有*.txt文件。</target>
        </trans-unit>
        <trans-unit id="66b80310b3a0d85a550dc7fa520d19dce45cca28" translate="yes" xml:space="preserve">
          <source>To create a new VFS, an application fills in an instance of this structure with appropriate values and then calls &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;.</source>
          <target state="translated">要创建新的VFS，应用程序会使用适当的值填充此结构的实例，然后调用&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b68e0297b120fdc8700b37a16e22b1bcac7b7255" translate="yes" xml:space="preserve">
          <source>To create a permanent imposter table &quot;t2&quot; against index &quot;t1bc&quot; one should first enable editing of the sqlite_master table by running &quot;&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt;&quot;. (Be careful to observe the warnings that accompany this PRAGMA. A mistake can cause severe database corruption.) Then insert a new entry into the sqlite_master table like this:</source>
          <target state="translated">要针对索引&amp;ldquo; t1bc&amp;rdquo;创建永久冒名顶替者表&amp;ldquo; t2&amp;rdquo;，应首先通过运行&amp;ldquo; &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = ON&lt;/a&gt; &amp;rdquo;来启用sqlite_master表的编辑。 （请小心遵守此PRAGMA的警告。错误可能会导致数据库严重损坏。）然后将新条目插入sqlite_master表，如下所示：</target>
        </trans-unit>
        <trans-unit id="36c615429908288394555c6e0565e1074cd2dbb0" translate="yes" xml:space="preserve">
          <source>To create a permanent imposter table &quot;t2&quot; against index &quot;t1bc&quot; one should first enable editing of the sqlite_schema table by running &quot;&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt;&quot;. (Be careful to observe the warnings that accompany this PRAGMA. A mistake can cause severe database corruption.) Then insert a new entry into the sqlite_schema table like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75af239d46a1ccaf4ed3b8c83752a1c8cd61ef3d" translate="yes" xml:space="preserve">
          <source>To create a transient imposter table, first call sqlite3_test_control() as follows:</source>
          <target state="translated">要创建一个瞬时冒名表,首先调用sqlite3_test_control(),如下所示。</target>
        </trans-unit>
        <trans-unit id="840cded7bd85361bb0373236ba14ab05cb33ba76" translate="yes" xml:space="preserve">
          <source>To disable memory-mapped I/O, simply set the mmap_size to zero:</source>
          <target state="translated">要禁用内存映射的I/O,只需将mmap_size设置为0即可。</target>
        </trans-unit>
        <trans-unit id="4162611fd5eb01354b37fefdcc47165c36368726" translate="yes" xml:space="preserve">
          <source>To download a specific historical version, first locate the specific version desired by visiting the timeline page on one of these servers (for example: &lt;a href=&quot;http://www.sqlite.org/cgi/src/timeline&quot;&gt;http://www.sqlite.org/cgi/src/timeline&lt;/a&gt;). If you know the approximate date of the version you want to download, you can add a query parameter like &quot;c=YYYY-MM-DD&quot; to the &quot;timeline&quot; URL to see a timeline centered on that date. For example, to see all the check-ins that occurred around August 26, 2013, visit &lt;a href=&quot;http://www.sqlite.org/cgi/src/timeline?c=2013-08-26&quot;&gt;http://www.sqlite.org/cgi/src/timeline?c=2013-08-26&lt;/a&gt;. If you are looking for an official release, visit the &lt;a href=&quot;https://sqlite.org/chronology.html&quot;&gt;chronology&lt;/a&gt; page, click on the date to the left of the release you are looking for, and that will take you immediately to the check-in corresponding to the release.</source>
          <target state="translated">要下载特定的历史版本，请首先通过访问这些服务器之一上的时间轴页面找到所需的特定版本（例如：&lt;a href=&quot;http://www.sqlite.org/cgi/src/timeline&quot;&gt;http&lt;/a&gt; : //www.sqlite.org/cgi/src/timeline）。如果知道要下载的版本的大概日期，则可以在&amp;ldquo;时间轴&amp;rdquo; URL中添加查询参数，例如&amp;ldquo; c = YYYY-MM-DD&amp;rdquo;，以查看以该日期为中心的时间轴。例如，要查看2013年8月26日前后发生的所有签入，请访问&lt;a href=&quot;http://www.sqlite.org/cgi/src/timeline?c=2013-08-26&quot;&gt;http://www.sqlite.org/cgi/src/timeline?c=2013-08-26&lt;/a&gt;。如果您要查找正式发行版，请访问&lt;a href=&quot;https://sqlite.org/chronology.html&quot;&gt;年表&lt;/a&gt;页面，单击要查找的发行版左侧的日期，这将立即带您进入该发行版所对应的签入位置。</target>
        </trans-unit>
        <trans-unit id="26b6f299c4f6dbffd907751cbcf7de075d977917" translate="yes" xml:space="preserve">
          <source>To end a</source>
          <target state="translated">要结束一个</target>
        </trans-unit>
        <trans-unit id="b5999f6915f561051a988538e0bd45a5b252eaed" translate="yes" xml:space="preserve">
          <source>To enhance the ability to correct the spelling of &quot;salm&quot; into &quot;psalm&quot;, make an addition entry like this:</source>
          <target state="translated">为了提高将 &quot;salm &quot;拼写成 &quot;psalm &quot;的改正能力,可以做一个这样的附加条目。</target>
        </trans-unit>
        <trans-unit id="cad4b923bd651194c8769c3ac961aaea0541a296" translate="yes" xml:space="preserve">
          <source>To ensure that</source>
          <target state="translated">为确保</target>
        </trans-unit>
        <trans-unit id="1e6f0b75d33070e67761c1e9b6a6ed87d2ff380d" translate="yes" xml:space="preserve">
          <source>To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines. Or, in other words, these routines are constructors for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; object.</source>
          <target state="translated">要执行SQL语句，必须首先使用以下例程之一将其编译为字节码程序。换句话说，这些例程是&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;对象的构造函数。</target>
        </trans-unit>
        <trans-unit id="ec8443402dd2eb014887f71b7af85c4019b4e801" translate="yes" xml:space="preserve">
          <source>To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines. Or, in other words, these routines are constructors for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; object.</source>
          <target state="translated">要执行SQL语句，必须首先使用以下例程之一将其编译为字节码程序。换句话说，这些例程是&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;对象的构造函数。</target>
        </trans-unit>
        <trans-unit id="58b794006b35834c11476296b13d055bca3cb6ad" translate="yes" xml:space="preserve">
          <source>To export an SQLite table (or part of a table) as CSV, simply set the &quot;mode&quot; to &quot;csv&quot; and then run a query to extract the desired rows of the table.</source>
          <target state="translated">要将SQLite表(或表的一部分)导出为CSV,只需将 &quot;模式 &quot;设置为 &quot;csv&quot;,然后运行查询以提取表的所需行。</target>
        </trans-unit>
        <trans-unit id="34bdecaf4db0d4f0bc535a4d51fd07e2c07ade79" translate="yes" xml:space="preserve">
          <source>To extract all files from an SQLite Archive named &quot;example.sqlar&quot;:</source>
          <target state="translated">从名为 &quot;example.sqllar &quot;的SQLite存档中提取所有文件。</target>
        </trans-unit>
        <trans-unit id="378da684f0e8132365653868ae764440748a4226" translate="yes" xml:space="preserve">
          <source>To find the average fan-out for a table, run:</source>
          <target state="translated">要找出一张桌子的平均扇出量,运行。</target>
        </trans-unit>
        <trans-unit id="ee153014b1f6b01134aa6e70c369b696d194ac09" translate="yes" xml:space="preserve">
          <source>To find the total number of pages used to store table &quot;xyz&quot; in schema &quot;aux1&quot;, use either of the following two queries (the first is the traditional way, and the second shows the use of the aggregated feature):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77ab957506d48f71aa3fc70f6eedd2aaaf50bd48" translate="yes" xml:space="preserve">
          <source>To find the total number of pages used to store table &quot;xyz&quot; in schema &quot;aux1&quot;, use:</source>
          <target state="translated">要找出在模式 &quot;aux1 &quot;中存储表 &quot;xyz &quot;所使用的总页数,请使用。</target>
        </trans-unit>
        <trans-unit id="0a11c9e40b95aaa85081ba6c0555c462813b8b92" translate="yes" xml:space="preserve">
          <source>To force any register to be an integer, just add 0.</source>
          <target state="translated">要强制任何寄存器为整数,只需加0即可。</target>
        </trans-unit>
        <trans-unit id="7bb085f6483822eb83ea0075d305dc39115c6ffe" translate="yes" xml:space="preserve">
          <source>To generate a TCL-loadable library for SQLite on Linux, the following command will suffice:</source>
          <target state="translated">要在Linux上为SQLite生成一个可加载的TCL库,使用以下命令即可。</target>
        </trans-unit>
        <trans-unit id="dc0ee9d48bb10de38aec057fb2ba37285a13b707" translate="yes" xml:space="preserve">
          <source>To generate a standalone tclsh that is statically linked with SQLite, use this compiler invocation:</source>
          <target state="translated">要生成一个与SQLite静态链接的独立tclsh,请使用这个编译器调用。</target>
        </trans-unit>
        <trans-unit id="8ffcbf0f0118885934819d8152d29f23d6bdeaf0" translate="yes" xml:space="preserve">
          <source>To get the latest release, use &quot;release&quot; for</source>
          <target state="translated">要获得最新的版本,请使用 &quot;release &quot;来获取。</target>
        </trans-unit>
        <trans-unit id="865105a4d24714f5572a2af260a890cf20c3e9e8" translate="yes" xml:space="preserve">
          <source>To get the latest trunk check-in, us &quot;trunk&quot; for</source>
          <target state="translated">要想获得最新的后备箱签到,请用 &quot;后备箱 &quot;查询。</target>
        </trans-unit>
        <trans-unit id="baaadfb75f7d2bdda9240215ff1dc1b92db5726d" translate="yes" xml:space="preserve">
          <source>To get the maximum performance out of a query with multiple AND-connected terms in the WHERE clause, you really want a multi-column index with columns for each of the AND terms. In this case we create a new index on the &quot;fruit&quot; and &quot;state&quot; columns of FruitsForSale:</source>
          <target state="translated">为了从一个在WHERE子句中包含多个AND连接的术语的查询中获得最大的性能,你真的需要一个多列索引,其中包含每个AND术语的列。在本例中,我们在FruitsForSale的 &quot;水果 &quot;和 &quot;状态 &quot;列上创建一个新索引。</target>
        </trans-unit>
        <trans-unit id="6c98051e0b4ba35892475ed9f9c40c06634ca73f" translate="yes" xml:space="preserve">
          <source>To help ensure that SQLite does not make use of undefined or implementation defined behavior, the test suites are rerun using instrumented builds that try to detect undefined behavior. For example, test suites are run using the &quot;-ftrapv&quot; option of GCC. And they are run again using the &quot;-fsanitize=undefined&quot; option on Clang. And again using the &quot;/RTC1&quot; option in MSVC. Then the test suites are rerun using options like &quot;-funsigned-char&quot; and &quot;-fsigned-char&quot; to make sure that implementation differences do not matter either. Tests are then repeated on 32-bit and 64-bit systems and on big-endian and little-endian systems, using a variety of CPU architectures. Furthermore, the test suites are augmented with many test cases that are deliberately designed to provoke undefined behavior. For example: &quot;&lt;b&gt;SELECT -1*(-9223372036854775808);&lt;/b&gt;&quot;.</source>
          <target state="translated">为了帮助确保SQLite不使用未定义或实现定义的行为，将使用试图检测未定义行为的检测内部版本来重新运行测试套件。例如，使用GCC的&amp;ldquo; -ftrapv&amp;rdquo;选项运行测试套件。然后使用Clang上的&amp;ldquo; -fsanitize = undefined&amp;rdquo;选项再次运行它们。再次使用MSVC中的&amp;ldquo; / RTC1&amp;rdquo;选项。然后使用&amp;ldquo; -funsigned-char&amp;rdquo;和&amp;ldquo; -fsigned-char&amp;rdquo;之类的选项重新运行测试套件，以确保实现差异也不重要。然后，使用各种CPU架构，在32位和64位系统以及大端和小端系统上重复测试。此外，在测试套件中增加了许多故意设计为引发未定义行为的测试用例。例如：&amp;ldquo; &lt;b&gt;SELECT -1 *（-9223372036854775808）;&lt;/b&gt;&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a47c1a7cf7a764ae8418d262a8cbe0034fa682ba" translate="yes" xml:space="preserve">
          <source>To help the optimizer get a more accurate estimate of the work involved in using various indices, the user may optionally run the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command scans all indices of database where there might be a choice between two or more indices and gathers statistics on the selectiveness of those indices. The statistics gathered by this scan are stored in special database tables names shows names all begin with &quot;&lt;b&gt;sqlite_stat&lt;/b&gt;&quot;. The content of these tables is not updated as the database changes so after making significant changes it might be prudent to rerun &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;. The results of an ANALYZE command are only available to database connections that are opened after the ANALYZE command completes.</source>
          <target state="translated">为了帮助优化器更准确地估计使用各种索引所涉及的工作，用户可以选择运行&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令。该&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令扫描数据库的所有索引中可能有这些指标的选择性强两个或更多的指标和收集统计信息之间进行选择。此扫描收集的统计信息存储在特殊的数据库表中，名称显示的名称均以&amp;ldquo; &lt;b&gt;sqlite_stat&lt;/b&gt; &amp;rdquo; 开头。这些表的内容不会随着数据库的更改而更新，因此在进行重大更改后，重新运行&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;可能是明智的。ANALYZE命令的结果仅可用于在ANALYZE命令完成后打开的数据库连接。</target>
        </trans-unit>
        <trans-unit id="13cfb0765d8bed99c080b9b691906f95cc028d17" translate="yes" xml:space="preserve">
          <source>To illustrate the difference between statement coverage and branch coverage, consider the following hypothetical line of C code:</source>
          <target state="translated">为了说明语句覆盖和分支覆盖之间的区别,请考虑以下假设的C代码行。</target>
        </trans-unit>
        <trans-unit id="ae50591a7fcbd23ea798d861abeb0270f701ae3a" translate="yes" xml:space="preserve">
          <source>To implement atomic transactions in the face of potential application, operating system or power failures, database writers write a copy of those portions of the database file that they are going to modify into a second file, the</source>
          <target state="translated">为了在潜在的应用程序、操作系统或电源故障的情况下实现原子事务,数据库写作者将数据库文件中要修改的那些部分写进第二个文件,即</target>
        </trans-unit>
        <trans-unit id="b22523df059612f91ea53aafd162b4bd5ed35d56" translate="yes" xml:space="preserve">
          <source>To include a single &quot;%&quot; character in the output, put two consecutive &quot;%&quot; characters in the template.</source>
          <target state="translated">要在输出中包含一个&quot;%&quot;字符,请在模板中放入两个连续的&quot;%&quot;字符。</target>
        </trans-unit>
        <trans-unit id="04f1ff1539e760f03360e336c883d5d39fb452d1" translate="yes" xml:space="preserve">
          <source>To insert a directory into the archive, this field must be set to NULL. In this case if a value was explicitly specified for the &quot;mode&quot; column, then it must be consistent with a directory (i.e. it must be true that (mode &amp;amp; 0040000)=0040000).</source>
          <target state="translated">要将目录插入存档，必须将该字段设置为NULL。在这种情况下，如果为&amp;ldquo;模式&amp;rdquo;列显式指定了一个值，则该值必须与目录一致（即，必须为（mode＆0040000）= 0040000）。</target>
        </trans-unit>
        <trans-unit id="f39783c1ee7868744c61463c5d909272c5cc8fe4" translate="yes" xml:space="preserve">
          <source>To insert a symbolic link, the user must also supply a &quot;mode&quot; value. For example, to add a symbolic link from &quot;link.txt&quot; to &quot;m.txt&quot;:</source>
          <target state="translated">要插入一个符号链接,用户还必须提供一个 &quot;模式 &quot;值。例如,要添加一个从 &quot;link.txt &quot;到 &quot;m.txt &quot;的符号链接。</target>
        </trans-unit>
        <trans-unit id="95775537d7e96d79f73ff5683b7a0f5a80a5ce74" translate="yes" xml:space="preserve">
          <source>To invoke a method of the fts5_api object, the fts5_api pointer itself should be passed as the methods first argument followed by the other, method specific, arguments. For example:</source>
          <target state="translated">要调用fts5_api对象的方法,应该把fts5_api指针本身作为方法的第一个参数,然后再传给其他特定方法的参数。例如,在调用fts5_api对象的方法时</target>
        </trans-unit>
        <trans-unit id="6e6a0331292326c4328c6ad0538b3a057984238d" translate="yes" xml:space="preserve">
          <source>To invoke an auxiliary function, the name of the FTS5 table should be specified as the first argument. Other arguments may follow the first, depending on the specific auxiliary function being invoked. For example, to invoke the &quot;highlight&quot; function:</source>
          <target state="translated">要调用一个辅助函数,应指定FTS5表的名称作为第一个参数。其他参数可以跟在第一个参数后面,这取决于被调用的具体辅助函数。例如,要调用 &quot;高亮 &quot;函数。</target>
        </trans-unit>
        <trans-unit id="87798f32eb98a197933acbeaa659a6391e6e206b" translate="yes" xml:space="preserve">
          <source>To list all of the files in an SQLite Archive named &quot;example.sqlar&quot; using one of these commands:</source>
          <target state="translated">使用以下命令之一列出名为 &quot;example.sqlar &quot;的SQLite存档中的所有文件。</target>
        </trans-unit>
        <trans-unit id="a8e56bf2f9a0444cb5685f8d4658bfe54c212bc2" translate="yes" xml:space="preserve">
          <source>To load this extension as a shared library, you first have to bring up a dummy SQLite database connection to use as the argument to the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; API call. Then you invoke the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; API and shutdown the dummy database connection. All subsequent database connections that are opened will include this extension. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98a407629fac05e188e2276249cb3e6705d8eabc" translate="yes" xml:space="preserve">
          <source>To make the original query more efficient, we can add an index on the &quot;fruit&quot; column of the &quot;fruitsforsale&quot; table like this:</source>
          <target state="translated">为了使原来的查询更有效率,我们可以在 &quot;fruitsforsale &quot;表的 &quot;水果 &quot;列上添加一个索引,像这样。</target>
        </trans-unit>
        <trans-unit id="477566566ad78ed80a1c50e083a36f65bd003836" translate="yes" xml:space="preserve">
          <source>To mark a foreign key constraint as deferred, its declaration must include the following clause:</source>
          <target state="translated">要将一个外键约束标记为递延,它的声明必须包括以下子句。</target>
        </trans-unit>
        <trans-unit id="ffa62717516e178da2c90e6012b64fda52ee2d3e" translate="yes" xml:space="preserve">
          <source>To minimize storage space, the 64-bit rowid is stored as a variable length integer. Rowids between 0 and 127 use only a single byte. Rowids between 0 and 16383 use just 2 bytes. Up to 2097152 uses three bytes. And so forth. Negative rowids are allowed but they always use nine bytes of storage and so their use is discouraged. When rowids are generated automatically by SQLite, they will always be non-negative.</source>
          <target state="translated">为了最小化存储空间,64位的rowid被存储为一个可变长度的整数。0到127之间的行数只使用一个字节。0到16383之间的rowid只使用2个字节。高达2097152的行数使用三个字节。以此类推。负值的rowids是允许的,但是它们总是使用9个字节的存储空间,所以不鼓励使用它们。当SQLite自动生成rowids时,它们总是非负数。</target>
        </trans-unit>
        <trans-unit id="d120ff6bfe9d147f02eaa10dff44acc87f07df1f" translate="yes" xml:space="preserve">
          <source>To overcome this problem, SQLite attempts to flatten subqueries in the FROM clause of a SELECT. This involves inserting the FROM clause of the subquery into the FROM clause of the outer query and rewriting expressions in the outer query that refer to the result set of the subquery. For example:</source>
          <target state="translated">为了克服这个问题,SQLite 试图在 SELECT 的 FROM 子句中扁平化子查询。这包括将子查询的FROM子句插入到外层查询的FROM子句中,并重写外层查询中引用子查询结果集的表达式。例如</target>
        </trans-unit>
        <trans-unit id="294f2168272133a9c981fc5402e94f65b32feecd" translate="yes" xml:space="preserve">
          <source>To perform a backup operation:</source>
          <target state="translated">要执行备份操作。</target>
        </trans-unit>
        <trans-unit id="9189855e1dd7fa25c3ea4d362ef1bbf56fd3d46b" translate="yes" xml:space="preserve">
          <source>To port the asynchronous IO extension to another platform, the user must implement mutex and condition variable primitives for the new platform. Currently there is no externally available interface to allow this, but modifying the code within sqlite3async.c to include the new platforms concurrency primitives is relatively easy. Search within sqlite3async.c for the comment string &quot;PORTING FUNCTIONS&quot; for details. Then implement new versions of each of the following:</source>
          <target state="translated">要将异步IO扩展移植到另一个平台,用户必须为新平台实现mutex和条件变量基元。目前没有外部可用的接口来允许这样做,但是修改sqlite3async.c中的代码以包含新平台的并发基元是相对容易的。在sqlite3async.c中搜索注释字符串 &quot;PORTING FUNCTIONS &quot;以了解详情。然后实现以下每个函数的新版本。</target>
        </trans-unit>
        <trans-unit id="b29c4e979c790f9733cc9cd0e4cadf4faa4804b3" translate="yes" xml:space="preserve">
          <source>To prevent this kind of mischief, applications that create their own custom SQL functions should take one or more of the following safety precautions. The more precautions taken the better:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abe3a1c0f986e7dff3c66e10e0bc8613ec8a4a29" translate="yes" xml:space="preserve">
          <source>To program the costs of editdist3, create a table such as the following:</source>
          <target state="translated">要对editdist3的成本进行编程,请创建如下表格。</target>
        </trans-unit>
        <trans-unit id="dd961efb741387ced404586d2d77531be32d0018" translate="yes" xml:space="preserve">
          <source>To put it another way, SQLITE_THREADSAFE=1 sets the default &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Serialized. SQLITE_THREADSAFE=2 sets the default &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Multi-threaded. And SQLITE_THREADSAFE=0 sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Single-threaded.</source>
          <target state="translated">换句话说，SQLITE_THREADSAFE = 1将默认&lt;a href=&quot;threadsafe&quot;&gt;线程模式设置&lt;/a&gt;为序列化。SQLITE_THREADSAFE = 2将默认&lt;a href=&quot;threadsafe&quot;&gt;线程模式设置&lt;/a&gt;为多线程。并且SQLITE_THREADSAFE = 0会将&lt;a href=&quot;threadsafe&quot;&gt;线程模式&lt;/a&gt;设置为单线程。</target>
        </trans-unit>
        <trans-unit id="8bbf633fa4610c96c0c7ffee341d20c19f6a10c0" translate="yes" xml:space="preserve">
          <source>To put it another way, a recursive common table expression must look like the following:</source>
          <target state="translated">换一种说法,一个递归的通用表表达式必须像下面这样。</target>
        </trans-unit>
        <trans-unit id="d0db6354379e9349b630c5c37e78992d9de59b0b" translate="yes" xml:space="preserve">
          <source>To put it another way, this setting requires that application-defined functions only be run directly by top-level SQL invoked from the application itself, not as a consequence of doing some other innocent-looking query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36ef640929ff79fff30565de2cdb61e3e8331dcd" translate="yes" xml:space="preserve">
          <source>To query the geopoly table using an indexed geospatial search, use one of the functions geopoly_overlap() or geopoly_within() as a boolean function in the WHERE clause, with the &quot;_shape&quot; column as the first argument to the function. For example:</source>
          <target state="translated">要使用索引地理空间搜索查询地缘表,请在WHERE子句中使用函数geopoly_overlap()或geopoly_within()中的一个布尔函数,并将&quot;_shape &quot;列作为函数的第一个参数。例如</target>
        </trans-unit>
        <trans-unit id="4c7559a504a1b848e2c2a1bb94bcc0d6574af605" translate="yes" xml:space="preserve">
          <source>To query the virtual table, include a MATCH operator in the WHERE clause. For example:</source>
          <target state="translated">要查询虚拟表,请在WHERE子句中加入MATCH操作符。例如:</target>
        </trans-unit>
        <trans-unit id="956aac33f5ccab9c31f6bd406dfe90336575d36e" translate="yes" xml:space="preserve">
          <source>To raise an error, the xColumn method should use one of the result_text() methods to set the error message text, then return an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;. The xColumn method must return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success.</source>
          <target state="translated">要引发错误，xColumn方法应使用result_text（）方法之一来设置错误消息文本，然后返回适当的&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。如果成功，xColumn方法必须返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a347542d414080ba36506855372190f72248d59a" translate="yes" xml:space="preserve">
          <source>To read a page from the database (call it page number P), a reader first checks the WAL to see if it contains page P. If so, then the last valid instance of page P that is followed by a commit frame or is a commit frame itself becomes the value read. If the WAL contains no copies of page P that are valid and which are a commit frame or are followed by a commit frame, then page P is read from the database file.</source>
          <target state="translated">要从数据库中读取一个页面(称其为页码P),读取器首先检查WAL是否包含P页,如果包含,那么P页的最后一个有效实例,如果后面有一个提交框或者本身就是一个提交框,则成为读取值。如果WAL中不包含有效的P页,并且是一个提交框或后面有一个提交框,那么就从数据库文件中读取P页。</target>
        </trans-unit>
        <trans-unit id="76f16284fd2bce9d8388d5ab5df8c7614583bafc" translate="yes" xml:space="preserve">
          <source>To read a page of database content using the legacy xRead() method, SQLite first allocates a page-size chunk of heap memory then invokes the xRead() method which causes the database page content to be copied into the newly allocated heap memory. This involves (at a minimum) a copy of the entire page.</source>
          <target state="translated">要使用传统的xRead()方法读取数据库内容页,SQLite首先分配一个页大小的堆内存块,然后调用xRead()方法,使数据库页内容被复制到新分配的堆内存中。这涉及(至少)整个页面的复制。</target>
        </trans-unit>
        <trans-unit id="0d23c4dcc478663c58481efcab9ef78dfade7580" translate="yes" xml:space="preserve">
          <source>To reiterate, the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter and the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; only influence the temporary files other than the rollback journal and the master journal. The rollback journal and the master journal are always written to disk regardless of the settings of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter and the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">重申一下，&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;编译时参数和&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store编译指示&lt;/a&gt;仅影响除回滚日志和主日志以外的临时文件。无论&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;编译时参数和&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;的设置如何，始终将回滚日志和主日志写入磁盘。</target>
        </trans-unit>
        <trans-unit id="2e5b2bd7c52b7e4f110f0ff73389c5c950328a31" translate="yes" xml:space="preserve">
          <source>To reiterate, the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter and the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; only influence the temporary files other than the rollback journal and the super-journal. The rollback journal and the super-journal are always written to disk regardless of the settings of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter and the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c25cb966293d60ae97a959ff16018be4ed0f257f" translate="yes" xml:space="preserve">
          <source>To rotate a polygon by R radians around the point 0, 0:</source>
          <target state="translated">要围绕点0,0旋转多边形R弧度。</target>
        </trans-unit>
        <trans-unit id="b22af78238ac154cfedfa8fdf1735dd0e28767bd" translate="yes" xml:space="preserve">
          <source>To run an SQL statement, the application follows these steps:</source>
          <target state="translated">要运行一条SQL语句,应用程序遵循以下步骤。</target>
        </trans-unit>
        <trans-unit id="2ac3ac4ee6565dd2ccf0aa06e215ad75c047aa3c" translate="yes" xml:space="preserve">
          <source>To satisfy this query, SQLite reads every row out of the table, checks to see if the &quot;fruit&quot; column has the value of &quot;Peach&quot; and if so, outputs the &quot;price&quot; column from that row. The process is illustrated by &lt;a href=&quot;#fig2&quot;&gt;figure 2&lt;/a&gt; below. This is algorithm is called a</source>
          <target state="translated">为了满足该查询，SQLite从表中读取每一行，检查&amp;ldquo;水果&amp;rdquo;列是否具有&amp;ldquo;桃子&amp;rdquo;值，如果是，则从该行输出&amp;ldquo;价格&amp;rdquo;列。下&lt;a href=&quot;#fig2&quot;&gt;图2&lt;/a&gt;说明了该过程。这就是所谓的算法</target>
        </trans-unit>
        <trans-unit id="15441596cf9057824d089a51008503a5c1e85b73" translate="yes" xml:space="preserve">
          <source>To see all optimizations that would have been done without actually doing them, run &quot;PRAGMA optimize(-1)&quot;. To use only the ANALYZE optimization, run &quot;PRAGMA optimize(0x02)&quot;.</source>
          <target state="translated">如果要查看所有本来不需要实际执行的优化,请运行 &quot;PRAGMA optimize(-1)&quot;。要只使用 ANALYZE 优化,请运行 &quot;PRAGMA optimize(0x02)&quot;。</target>
        </trans-unit>
        <trans-unit id="eba318aa21bd2422c25fe6b43564edd2f371cc6a" translate="yes" xml:space="preserve">
          <source>To see how efficiently the content of a table is stored on disk, compute the amount of space used to hold actual content divided by the total amount of disk space used. The closer this number is to 100%, the more efficient the packing. (In this example, the 'xyz' table is assumed to be in the 'main' schema. Again, there are two different versions that show the use of DBSTAT both without and with the new aggregated feature, respectively.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63736dfc77ed5a0f9b2aa82f7d9b5938ad21b2a2" translate="yes" xml:space="preserve">
          <source>To see how efficiently the content of a table is stored on disk, compute the amount of space used to hold actual content divided by the total amount of disk space used. The closer this number is to 100%, the more efficient the packing. (In this example, the 'xyz' table is assumed to be in the 'main' schema.)</source>
          <target state="translated">要了解一张表的内容在磁盘上的存储效率,请计算用于容纳实际内容的空间除以使用的磁盘空间总量。这个数字越接近100%,打包的效率就越高。在本例中,假设'xyz'表在'main'模式中。</target>
        </trans-unit>
        <trans-unit id="b389fbfc405d7654267e252e722e4fd63d443182" translate="yes" xml:space="preserve">
          <source>To see what SQL statements are used to implement an SQLite Archive operation, add the --dryrun or -n option. This causes the SQL to be displayed but inhibits the execution of the SQL.</source>
          <target state="translated">要查看哪些SQL语句用于实现SQLite Archive操作,请添加-dryrun或-n选项。这将导致显示SQL语句,但会抑制SQL的执行。</target>
        </trans-unit>
        <trans-unit id="4b42f62d4c2b9ee3d96292447437ef792183dfd3" translate="yes" xml:space="preserve">
          <source>To simplify export to a spreadsheet, the CLI provides the &quot;.excel&quot; command which captures the output of a single query and sends that output to the default spreadsheet program on the host computer. Use it like this:</source>
          <target state="translated">为了简化导出到电子表格的过程,CLI提供了&quot;.excel &quot;命令,它可以捕获单个查询的输出,并将该输出发送到主机上的默认电子表格程序。像这样使用它。</target>
        </trans-unit>
        <trans-unit id="7637fa0269c40df023fe74c58e653b7742bc4073" translate="yes" xml:space="preserve">
          <source>To simplify matters, SQLite is also available as a pre-packaged &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; source code file: &lt;b&gt;sqlite3.c&lt;/b&gt;. The amalgamation is a single file of ANSI-C code that implements the entire SQLite library. The amalgamation is much easier to deal with. Everything is contained within a single code file, so it is easy to drop into the source tree of a larger C or C++ program. All the code generation and transformation steps have already been carried out so there are no auxiliary C programs to configure and compile and no scripts to run. And, because the entire library is contained in a single translation unit, compilers are able to do more advanced optimizations resulting in a 5% to 10% performance improvement. For these reasons, the amalgamation source file (&quot;&lt;b&gt;sqlite3.c&lt;/b&gt;&quot;) is recommended for all applications.</source>
          <target state="translated">为了简化问题，SQLite还可以作为预打包的&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;源代码文件：&lt;b&gt;sqlite3.c提供&lt;/b&gt;。合并是实现整个SQLite库的ANSI-C代码的单个文件。合并更容易处理。所有内容都包含在一个代码文件中，因此很容易放入较大的C或C ++程序的源代码树中。所有代码生成和转换步骤均已执行，因此无需配置和编译辅助C程序，也无需运行脚本。而且，由于整个库都包含在一个翻译单元中，因此编译器能够进行更高级的优化，从而将性能提高5％到10％。由于这些原因，合并源文件（&amp;ldquo; &lt;b&gt;sqlite3.c&lt;/b&gt;&amp;ldquo;）建议用于所有应用程序。</target>
        </trans-unit>
        <trans-unit id="d56a317c733fa84480a64f52f9271ff584d1e783" translate="yes" xml:space="preserve">
          <source>To start a read transaction, the reader records the number of value frames in the WAL as &quot;mxFrame&quot;. (&lt;a href=&quot;walformat#mxframe&quot;&gt;More detail&lt;/a&gt;) The reader uses this recorded mxFrame value for all subsequent read operations. New transactions can be appended to the WAL, but as long as the reader uses its original mxFrame value and ignores subsequently appended content, the reader will see a consistent snapshot of the database from a single point in time. This technique allows multiple concurrent readers to view different versions of the database content simultaneously.</source>
          <target state="translated">为了开始读取事务，读取器将WAL中的值帧数记录为&amp;ldquo; mxFrame&amp;rdquo;。（&lt;a href=&quot;walformat#mxframe&quot;&gt;更多详细信息&lt;/a&gt;）阅读器将此记录的mxFrame值用于所有后续读取操作。可以将新事务附加到WAL，但是只要读者使用其原始mxFrame值并且忽略随后附加的内容，则读者将从单个时间点看到数据库的一致快照。此技术允许多个并发阅读器同时查看数据库内容的不同版本。</target>
        </trans-unit>
        <trans-unit id="9664fcd7b01d40ea215ecbc89763a66fc98a4450" translate="yes" xml:space="preserve">
          <source>To statically link this extension with your product, compile it like any other C-language module but add the &quot;-DSQLITE_CKSUMVFS_STATIC&quot; option so that this module knows that it is being statically linked rather than dynamically linked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dba6bd0d0a444202c62a827b56648b58c226e29" translate="yes" xml:space="preserve">
          <source>To statically link your extension, simply add the -DSQLITE_CORE compile-time option. The SQLITE_CORE macro causes the SQLITE_EXTENSION_INIT1 and SQLITE_EXTENSION_INIT2 macros to become no-ops. Then modify your application to invoke the entry point directly, passing in a NULL pointer as the third &quot;pApi&quot; parameter.</source>
          <target state="translated">要静态链接您的扩展,只需添加-DSQLITE_CORE编译时选项。SQLITE_CORE 宏会使 SQLITE_EXTENSION_INIT1 和 SQLITE_EXTENSION_INIT2 宏变成无操作。然后修改你的应用程序,直接调用入口点,传入一个NULL指针作为第三个 &quot;pApi &quot;参数。</target>
        </trans-unit>
        <trans-unit id="63ab9efaac3f7a15bafc977a5dae2473a8be793a" translate="yes" xml:space="preserve">
          <source>To support</source>
          <target state="translated">为了支持</target>
        </trans-unit>
        <trans-unit id="a791e72c80a35cf93de60b32f2721ee1c5ba3b6f" translate="yes" xml:space="preserve">
          <source>To support full-text queries, FTS maintains an inverted index that maps from each unique term or word that appears in the dataset to the locations in which it appears within the table contents. For the curious, a complete description of the &lt;a href=&quot;fts3#data_structures&quot;&gt;data structure&lt;/a&gt; used to store this index within the database file appears below. A feature of this data structure is that at any time the database may contain not one index b-tree, but several different b-trees that are incrementally merged as rows are inserted, updated and deleted. This technique improves performance when writing to an FTS table, but causes some overhead for full-text queries that use the index. Evaluating the special &lt;a href=&quot;fts3#*fts4optcmd&quot;&gt;&quot;optimize&quot; command&lt;/a&gt;, an SQL statement of the form &quot;INSERT INTO &amp;lt;fts-table&amp;gt;(&amp;lt;fts-table&amp;gt;) VALUES('optimize')&quot;, causes FTS to merge all existing index b-trees into a single large b-tree containing the entire index. This can be an expensive operation, but may speed up future queries.</source>
          <target state="translated">为了支持全文查询，FTS维护一个反向索引，该索引将从数据集中出现的每个唯一术语或单词映射到表内容中出现的位置。出于好奇，下面显示了用于在数据库文件中存储此索引的&lt;a href=&quot;fts3#data_structures&quot;&gt;数据结构&lt;/a&gt;的完整描述。该数据结构的一个特点是，数据库在任何时候都可能不包含一个索引b树，而是包含几个不同的b树，这些树在插入，更新和删除行时逐渐合并。写入FTS表时，该技术可提高性能，但会给使用索引的全文查询带来一些开销。评估特殊的&lt;a href=&quot;fts3#*fts4optcmd&quot;&gt;&amp;ldquo;优化&amp;rdquo;命令&lt;/a&gt;，即&amp;ldquo; INSERT INTO &amp;lt;fts-table&amp;gt;（&amp;lt;fts-table&amp;gt;）VALUES（'optimize'）&amp;rdquo;形式的SQL语句，导致FTS将所有现有的索引b树合并为包含整个索引树的单个大b树指数。这可能是一项昂贵的操作，但可能会加快将来的查询速度。</target>
        </trans-unit>
        <trans-unit id="ef681c818587ecc3e802ff227ea9402f9c2f1648" translate="yes" xml:space="preserve">
          <source>To try to answer this, we ran 49 test cases with various BLOB sizes and SQLite page sizes on a Linux workstation (Ubuntu circa 2011 with the Ext4 filesystem on a fast SATA disk). For each test case, a database was created that contains 100MB of BLOB content. The sizes of the BLOBs ranged from 10KB to 1MB. The number of BLOBs varied in order to keep the total BLOB content at about 100MB. (Hence, 100 BLOBs for the 1MB size and 10000 BLOBs for the 10K size and so forth.) SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_8.html&quot;&gt;version 3.7.8&lt;/a&gt; (2011-09-19) was used.</source>
          <target state="translated">为了尝试回答这个问题，我们在Linux工作站（Ubuntu大约在2011年，快速SATA磁盘上使用Ext4文件系统）上运行了49个具有各种BLOB大小和SQLite页面大小的测试用例。对于每个测试用例，都会创建一个包含100MB BLOB内容的数据库。BLOB的大小范围从10KB到1MB。BLOB的数量各不相同，以使总BLOB内容保持在大约100MB。（因此，对于1MB大小，有100个BLOB，对于10K大小，有10000个BLOB，依此类推。）使用SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_8.html&quot;&gt;版本3.7.8&lt;/a&gt;（2011-09-19）。</target>
        </trans-unit>
        <trans-unit id="49ecd119f567ef3a86904898280b0f364fa219ed" translate="yes" xml:space="preserve">
          <source>To understand better how indices work, lets first look at how they are created. Let's go ahead and put an index on the two column of the examp table. We have:</source>
          <target state="translated">为了更好的理解索引的工作原理,我们先来看看索引是如何创建的。让我们继续在examp表的两列上建立一个索引。我们有。</target>
        </trans-unit>
        <trans-unit id="dec160dc75f7898baa78422fcd36c20f9eb86bdf" translate="yes" xml:space="preserve">
          <source>To use FTS5, the user creates an FTS5 virtual table with one or more columns. For example:</source>
          <target state="translated">要使用FTS5,用户需要创建一个带有一列或多列的FTS5虚拟表。例如:</target>
        </trans-unit>
        <trans-unit id="265f2aec4f2165ae622d11cb8e5b583eee970ef5" translate="yes" xml:space="preserve">
          <source>To use a custom delta format, the RBU application must register a user-defined SQL function named &quot;rbu_delta&quot; before beginning to process the update. rbu_delta() will be invoked with two arguments - the original value stored in the target table column and the delta value provided as part of the RBU update. It should return the result of applying the delta to the original value. To use the custom delta function, the character of the rbu_control value corresponding to the target column to update must be set to 'd' instead of 'x'. Then, instead of updating the target table with the value stored in the corresponding data_% column, RBU invokes the user-defined SQL function &quot;rbu_delta()&quot; and the store in the target table column.</source>
          <target state="translated">要使用自定义的delta格式,RBU应用程序必须在开始处理更新之前注册一个名为 &quot;rbu_delta &quot;的用户定义的SQL函数。rbu_delta()将以两个参数被调用--存储在目标表列中的原始值和作为RBU更新的一部分提供的delta值。它应该返回对原始值应用delta的结果。要使用自定义delta函数,必须将与要更新的目标列对应的rbu_control值的字符设置为'd',而不是'x'。然后,RBU不是用存储在相应data_%列中的值更新目标表,而是调用用户定义的SQL函数 &quot;rbu_delta()&quot;,并存储在目标表列中。</target>
        </trans-unit>
        <trans-unit id="1df3b152e981587cbc8d566dc7a1e4614e184269" translate="yes" xml:space="preserve">
          <source>To use the asynchronous IO extension, compile sqlite3async.c as part of the application that uses SQLite. Then use the APIs defined in sqlite3async.h to initialize and configure the module.</source>
          <target state="translated">要使用异步IO扩展,编译sqlite3async.c作为使用SQLite的应用程序的一部分。然后使用 sqlite3async.h 中定义的 API 来初始化和配置模块。</target>
        </trans-unit>
        <trans-unit id="54369ca0a2e65d88aa2188ae1aea4d3b328a4d8d" translate="yes" xml:space="preserve">
          <source>To work around this problem, comments of the form &quot;&lt;code&gt;/*OPTIMIZATION-IF-TRUE*/&lt;/code&gt;&quot; and &quot;&lt;code&gt;/*OPTIMIZATION-IF-FALSE*/&lt;/code&gt;&quot; are inserted into the SQLite source code to tell the mutation testing script to ignore some branch instructions.</source>
          <target state="translated">要变通解决此问题，将注释形式的&amp;ldquo; &lt;code&gt;/*OPTIMIZATION-IF-TRUE*/&lt;/code&gt; &amp;rdquo;和&amp;ldquo; &lt;code&gt;/*OPTIMIZATION-IF-FALSE*/&lt;/code&gt; &amp;rdquo;插入到SQLite源代码中，以告诉变异测试脚本忽略某些分支说明。</target>
        </trans-unit>
        <trans-unit id="8634a2716b4084136c44730377ba4cb303464e5e" translate="yes" xml:space="preserve">
          <source>To write to a database, a process must first acquire a SHARED lock as described above (possibly rolling back incomplete changes if there is a hot journal). After a SHARED lock is obtained, a RESERVED lock must be acquired. The RESERVED lock signals that the process intends to write to the database at some point in the future. Only one process at a time can hold a RESERVED lock. But other processes can continue to read the database while the RESERVED lock is held.</source>
          <target state="translated">要向数据库写入数据,一个进程必须首先获得一个如上所述的SHARED锁(如果有热日志,可能会回滚不完整的更改)。在获得SHARED锁之后,必须获得一个RESERVED锁。RESERVED锁发出信号,表明该进程打算在未来的某个时刻向数据库写入数据。每次只有一个进程可以持有一个RESERVED锁。但是其他进程可以在持有 RESERVED 锁的时候继续读取数据库。</target>
        </trans-unit>
        <trans-unit id="d6a3153289ec6bfe9b3f6870a925bacb15383077" translate="yes" xml:space="preserve">
          <source>Tokenize text using the tokenizer belonging to the FTS5 table.</source>
          <target state="translated">使用属于FTS5表的标记器对文本进行标记。</target>
        </trans-unit>
        <trans-unit id="0c8bdf6b370d1a312eb6820161397309d486c6dc" translate="yes" xml:space="preserve">
          <source>Tokenizer</source>
          <target state="translated">Tokenizer</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="75832235d44d151c0581571bd2e345dae5797a4a" translate="yes" xml:space="preserve">
          <source>Top-level programs determine first invocation by comparing the P1 operand against the P1 operand on the &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode at the beginning of the program. If the P1 values differ, then fall through and make the P1 of this opcode equal to the P1 of &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt;. If P1 values are the same then take the jump.</source>
          <target state="translated">顶级程序通过将P1操作数与程序开始时&lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt;操作码上的P1操作数进行比较来确定首次调用。如果P1值不同，则掉落并使该操作码的P1等于&lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt;的P1 。如果P1值相同，则进行跳转。</target>
        </trans-unit>
        <trans-unit id="95996c8558adf5424c8f05c23135b86d2248df1e" translate="yes" xml:space="preserve">
          <source>Torn Pages</source>
          <target state="translated">撕页</target>
        </trans-unit>
        <trans-unit id="f377932bef10eacf89a6d96048f5b7dd7d0a3754" translate="yes" xml:space="preserve">
          <source>Torn page</source>
          <target state="translated">撕页</target>
        </trans-unit>
        <trans-unit id="052c92ab74e0edce8a8ddb051550d404ed7fea5b" translate="yes" xml:space="preserve">
          <source>Total Number Of Rows Modified</source>
          <target state="translated">修改的总行数</target>
        </trans-unit>
        <trans-unit id="3c9565648378ccdf7ff691fdffa344d4a20079e8" translate="yes" xml:space="preserve">
          <source>Total number of freelist pages.</source>
          <target state="translated">自由职业者总页数:</target>
        </trans-unit>
        <trans-unit id="bedc83f26e09b1694605e6429adbe802acf7164e" translate="yes" xml:space="preserve">
          <source>Total storage space used by the current page or btree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f38169a712e499b917900e244feafc980a814f4" translate="yes" xml:space="preserve">
          <source>Trace</source>
          <target state="translated">Trace</target>
        </trans-unit>
        <trans-unit id="74cdc489721505bec65d3348184378ff2eaaa995" translate="yes" xml:space="preserve">
          <source>Trace method</source>
          <target state="translated">追踪方法</target>
        </trans-unit>
        <trans-unit id="d43a1036d6d0f2293d5b6b4fac27045bad910d65" translate="yes" xml:space="preserve">
          <source>Traces for &lt;b&gt;close&lt;/b&gt; invoke the callback with a single argument as the database connection is closing. The argument is an integer which is the value of a pointer to the underlying &lt;a href=&quot;c3ref/sqlite3&quot;&gt;sqlite3&lt;/a&gt; object that is closing.</source>
          <target state="translated">当数据库连接关闭时，&lt;b&gt;关闭&lt;/b&gt;跟踪将使用单个参数调用回调。参数是一个整数，它是指向即将关闭的基础&lt;a href=&quot;c3ref/sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象的指针的值。</target>
        </trans-unit>
        <trans-unit id="a9ae29ad74c7078369f553dd8cff4f37e437703e" translate="yes" xml:space="preserve">
          <source>Traces for &lt;b&gt;profile&lt;/b&gt; invoke the callback with two arguments as each SQL statement finishes. The first argument is an integer which is the value of the underlying &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object. The second argument is the approximate run-time for the statement in nanoseconds. The run-time is the best estimate available depending on the capabilities of the platform on which the application is running.</source>
          <target state="translated">每个SQL语句完成时，&lt;b&gt;配置文件的&lt;/b&gt;跟踪将使用两个参数来调用回调。第一个参数是一个整数，它是基础&lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;对象的值。第二个参数是该语句的近似运行时间（以纳秒为单位）。运行时是可用的最佳估计，具体取决于运行应用程序的平台的功能。</target>
        </trans-unit>
        <trans-unit id="57b5e1e30279e2c4dd1bed70627b5481cb49b436" translate="yes" xml:space="preserve">
          <source>Traces for &lt;b&gt;row&lt;/b&gt; invoke the callback with a single argument whenever a new result row is available from an SQL statement. The argument is an integer which is the value of the underlying &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object pointer.</source>
          <target state="translated">每当来自SQL语句的新结果行可用时，针对&lt;b&gt;行的&lt;/b&gt;跟踪将使用单个参数调用回调。参数是一个整数，它是基础&lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;对象指针的值。</target>
        </trans-unit>
        <trans-unit id="408f79d424be1f606eac26e2ea2665bbafc8553b" translate="yes" xml:space="preserve">
          <source>Traces for &lt;b&gt;statement&lt;/b&gt; invoke the callback with two arguments whenever a new SQL statement is run. The first argument is an integer which is the value of the pointer to the underlying &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object. This integer can be used to correlate SQL statement text with the result of a &lt;b&gt;profile&lt;/b&gt; or &lt;b&gt;row&lt;/b&gt; callback. The second argument is the unexpanded text of the SQL statement being run. By &quot;unexpanded&quot;, we mean that variable substitutions in the text are not expanded into the variable values. This is different from the behavior of the &quot;trace&quot; method which does expand variable substitutions.</source>
          <target state="translated">每当运行新的SQL语句时，for &lt;b&gt;语句的&lt;/b&gt;跟踪都会使用两个参数来调用回调。第一个参数是一个整数，它是指向基础&lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;对象的指针的值。该整数可用于将SQL语句文本与&lt;b&gt;配置文件&lt;/b&gt;或&lt;b&gt;行&lt;/b&gt;回调的结果相关联。第二个参数是正在运行的SQL语句的未扩展文本。 &amp;ldquo;未扩展&amp;rdquo;是指文本中的变量替换未扩展为变量值。这与&amp;ldquo; trace&amp;rdquo;方法的行为不同，后者确实扩展了变量替换。</target>
        </trans-unit>
        <trans-unit id="97acc1b59f9ec17c88715b436c8c28883bd4892f" translate="yes" xml:space="preserve">
          <source>Tracing And Profiling Functions</source>
          <target state="translated">追踪和剖析功能</target>
        </trans-unit>
        <trans-unit id="394bbe198e3a9b250514b00b862a8ecf0b427532" translate="yes" xml:space="preserve">
          <source>Tracing VDBE Program Execution</source>
          <target state="translated">追踪VDBE程序的执行情况</target>
        </trans-unit>
        <trans-unit id="a89304c783bc5056656be7a965ab51352c92b27f" translate="yes" xml:space="preserve">
          <source>Traditional Command</source>
          <target state="translated">传统指挥</target>
        </trans-unit>
        <trans-unit id="1a7b7c1b33d161f45804730c70b75175dccd9883" translate="yes" xml:space="preserve">
          <source>Transaction</source>
          <target state="translated">Transaction</target>
        </trans-unit>
        <trans-unit id="9f6d84035f64a6ceb70cb91cd6cf32d299234a85" translate="yes" xml:space="preserve">
          <source>Transaction Nesting Rules</source>
          <target state="translated">交易嵌套规则</target>
        </trans-unit>
        <trans-unit id="559a84bc65d3e0735a796537311e8ae93e9b3578" translate="yes" xml:space="preserve">
          <source>Transaction Rollback</source>
          <target state="translated">交易回滚</target>
        </trans-unit>
        <trans-unit id="8ade0bd69f2ac11b2fad88f7b26304c0adf8bac8" translate="yes" xml:space="preserve">
          <source>Transaction control statements such as &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt;, &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt;, &lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;, &lt;a href=&quot;../lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;, and &lt;a href=&quot;../lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; cause sqlite3_stmt_readonly() to return true, since the statements themselves do not actually modify the database but rather they control the timing of when other statements modify the database. The &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; and &lt;a href=&quot;../lang_detach&quot;&gt;DETACH&lt;/a&gt; statements also cause sqlite3_stmt_readonly() to return true since, while those statements change the configuration of a database connection, they do not make changes to the content of the database files on disk. The sqlite3_stmt_readonly() interface returns true for &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt; since &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt; merely sets internal flags, but the &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; and &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN EXCLUSIVE&lt;/a&gt; commands do touch the database and so sqlite3_stmt_readonly() returns false for those commands.</source>
          <target state="translated">事务控制语句（例如&lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt;，&lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt;，&lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;，&lt;a href=&quot;../lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;和&lt;a href=&quot;../lang_savepoint&quot;&gt;RELEASE）&lt;/a&gt;使sqlite3_stmt_readonly（）返回true，因为语句本身并不实际修改数据库，而是控制其他语句修改数据库的时间。该&lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;和&lt;a href=&quot;../lang_detach&quot;&gt;DETACH&lt;/a&gt;语句也引起sqlite3_stmt_readonly（），因为返回true，而那些语句更改数据库连接的配置，也不用更改数据库文件的磁盘上的内容。 sqlite3_stmt_readonly（）接口为&lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt;返回true，因为&lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt;仅设置内部标志，但是&lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt;和&lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN EXCLUSIVE&lt;/a&gt;命令确实会触及数据库，因此sqlite3_stmt_readonly（）对于这些命令返回false。</target>
        </trans-unit>
        <trans-unit id="27b3779c5fd38ff491a7c50d915a8ad6fa71bac3" translate="yes" xml:space="preserve">
          <source>Transaction control statements such as &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;, &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;, &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;, &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;, and &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; cause sqlite3_stmt_readonly() to return true, since the statements themselves do not actually modify the database but rather they control the timing of when other statements modify the database. The &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; and &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; statements also cause sqlite3_stmt_readonly() to return true since, while those statements change the configuration of a database connection, they do not make changes to the content of the database files on disk. The sqlite3_stmt_readonly() interface returns true for &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; since &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; merely sets internal flags, but the &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; and &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN EXCLUSIVE&lt;/a&gt; commands do touch the database and so sqlite3_stmt_readonly() returns false for those commands.</source>
          <target state="translated">事务控制语句（例如&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;，&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;，&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;，&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;和&lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE）&lt;/a&gt;使sqlite3_stmt_readonly（）返回true，因为语句本身并不实际修改数据库，而是控制其他语句修改数据库的时间。该&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;和&lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt;语句也引起sqlite3_stmt_readonly（），因为返回true，而那些语句更改数据库连接的配置，也不用更改数据库文件的磁盘上的内容。 sqlite3_stmt_readonly（）接口为&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;返回true，因为&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;仅设置内部标志，但是&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt;和&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN EXCLUSIVE&lt;/a&gt;命令确实会触及数据库，因此sqlite3_stmt_readonly（）对于这些命令返回false。</target>
        </trans-unit>
        <trans-unit id="8a3a9f146929435e416d0b1eea1f2d4c645865f1" translate="yes" xml:space="preserve">
          <source>Transaction method</source>
          <target state="translated">交易方法</target>
        </trans-unit>
        <trans-unit id="e07bd983fd2be3fec651b38d00687dea5ddec91f" translate="yes" xml:space="preserve">
          <source>Transaction speed is limited by disk drive speed because (by default) SQLite actually waits until the data really is safely stored on the disk surface before the transaction is complete. That way, if you suddenly lose power or if your OS crashes, your data is still safe. For details, read about &lt;a href=&quot;atomiccommit&quot;&gt;atomic commit in SQLite.&lt;/a&gt;.</source>
          <target state="translated">事务处理速度受到磁盘驱动器速度的限制，因为（默认情况下）SQLite实际上会等到数据真正安全地存储在磁盘表面上，然后再完成事务处理。这样，即使您突然断电或操作系统崩溃，您的数据仍然是安全的。有关详细信息，请阅读有关&lt;a href=&quot;atomiccommit&quot;&gt;SQLite中的原子提交的信息。&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="df69c71bc9ee2d5d83cb3c63296f150aa519dbce" translate="yes" xml:space="preserve">
          <source>Transactions can be DEFERRED, IMMEDIATE, or EXCLUSIVE. The default transaction behavior is DEFERRED.</source>
          <target state="translated">交易可以是DEFERRED、IMMEDIATE或EXCLUSIVE。默认的交易行为是DEFERRED。</target>
        </trans-unit>
        <trans-unit id="8441979420cc8e7193bf0e0806b90756ef918a72" translate="yes" xml:space="preserve">
          <source>Transactions can be started manually using the BEGIN command. Such transactions usually persist until the next COMMIT or ROLLBACK command. But a transaction will also ROLLBACK if the database is closed or if an error occurs and the ROLLBACK conflict resolution algorithm is specified. See the documentation on the &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clause for additional information about the ROLLBACK conflict resolution algorithm.</source>
          <target state="translated">可以使用BEGIN命令手动启动事务。这样的事务通常会持续到下一个COMMIT或ROLLBACK命令为止。但是，如果数据库关闭或发生错误并且指定了ROLLBACK冲突解决算法，则事务也将回滚。有关ROLLBACK冲突解决算法的更多信息，请参见&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;子句的文档。</target>
        </trans-unit>
        <trans-unit id="5743531bc167a0f47f6a510d1c09f16148c6d3da" translate="yes" xml:space="preserve">
          <source>Transactions created using BEGIN...COMMIT do not nest. For nested transactions, use the &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; and &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; commands. The &quot;TO SAVEPOINT name&quot; clause of the ROLLBACK command shown in the syntax diagram above is only applicable to &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; transactions. An attempt to invoke the BEGIN command within a transaction will fail with an error, regardless of whether the transaction was started by &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; or a prior BEGIN. The COMMIT command and the ROLLBACK command without the TO clause work the same on &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; transactions as they do with transactions started by BEGIN.</source>
          <target state="translated">使用BEGIN ... COMMIT创建的事务不会嵌套。对于嵌套事务，请使用&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;和&lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt;命令。上面的语法图中显示的ROLLBACK命令的&amp;ldquo; TO SAVEPOINT名称&amp;rdquo;子句仅适用于&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;事务。无论事务是由&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;启动还是由先前的BEGIN 启动，尝试在事务内调用BEGIN命令都将失败并显示错误。不带TO子句的COMMIT命令和ROLLBACK命令在&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;事务上的作用与对BEGIN启动的事务的作用相同。</target>
        </trans-unit>
        <trans-unit id="4e5b097bbdedc9d11240febdc9033ef693213407" translate="yes" xml:space="preserve">
          <source>Transactions in SQLite are SERIALIZABLE.</source>
          <target state="translated">SQLite中的事务是SERIALIZABLE的。</target>
        </trans-unit>
        <trans-unit id="40f17b088c01997dd93e90e0db80840a80f74d26" translate="yes" xml:space="preserve">
          <source>Transactions involving multiple attached databases are atomic, assuming that the main database is not &quot;&lt;a href=&quot;inmemorydb&quot;&gt;:memory:&lt;/a&gt;&quot; and the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; is not &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;. If the main database is &quot;:memory:&quot; or if the journal_mode is WAL, then transactions continue to be atomic within each individual database file. But if the host computer crashes in the middle of a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; where two or more database files are updated, some of those files might get the changes where others might not.</source>
          <target state="translated">假设主数据库不是&amp;ldquo; &lt;a href=&quot;inmemorydb&quot;&gt;：memory：&lt;/a&gt; &amp;rdquo;并且&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt;不是&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;，则涉及多个附加数据库的事务是原子的。如果主数据库是&amp;ldquo;：memory：&amp;rdquo;或journal_mode是WAL，则事务在每个单独的数据库文件中仍然是原子的。但是，如果主机在更新两个或多个数据库文件的&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;中间崩溃，则其中的某些文件可能会获得更改，而其他文件可能不会。</target>
        </trans-unit>
        <trans-unit id="eceeec5767d02607ea24c1ab3a8a3bd0186d9069" translate="yes" xml:space="preserve">
          <source>Transactions that involve changes against multiple &lt;a href=&quot;lang_attach&quot;&gt;ATTACHed&lt;/a&gt; databases are atomic for each individual database, but are not atomic across all databases as a set.</source>
          <target state="translated">涉及对多个&lt;a href=&quot;lang_attach&quot;&gt;ATTACHed&lt;/a&gt;数据库进行更改的事务对于每个单独的数据库都是原子的，但是对于作为集合的所有数据库都不是原子的。</target>
        </trans-unit>
        <trans-unit id="62eb009ad23bc2fc48eb046817b2cfc13d56eba9" translate="yes" xml:space="preserve">
          <source>Transfer any terms of the HAVING clause that use only columns mentioned in the GROUP BY clause over to the WHERE clause for faster processing.</source>
          <target state="translated">将HAVING子句中只使用GROUP BY子句中提到的列的任何条款转移到WHERE子句中,以加快处理速度。</target>
        </trans-unit>
        <trans-unit id="730f8c6a84d5869c2c8dd4a477da51b4cb41ea47" translate="yes" xml:space="preserve">
          <source>Transfer content from X into new_X using a statement like: INSERT INTO new_X SELECT ... FROM X.</source>
          <target state="translated">使用类似这样的语句将X中的内容转移到new_X中。INSERT INTO new_X SELECT ...FROM X。</target>
        </trans-unit>
        <trans-unit id="f547c01f878e078bc070f937769a72523b2e574f" translate="yes" xml:space="preserve">
          <source>Transfer the integer value held in register P1 into register P2.</source>
          <target state="translated">将寄存器P1中的整数值转移到寄存器P2中。</target>
        </trans-unit>
        <trans-unit id="77dbfff94d90d8a93cedb37403df1e3f9c6cd3b3" translate="yes" xml:space="preserve">
          <source>Transfer the values of bound parameter P1 into register P2</source>
          <target state="translated">将绑定参数P1的值转移到寄存器P2中。</target>
        </trans-unit>
        <trans-unit id="893d914ab7aa99042fec20acf2eaca5958133d3d" translate="yes" xml:space="preserve">
          <source>Transient databases used by VACUUM</source>
          <target state="translated">VACUUM使用的瞬时数据库。</target>
        </trans-unit>
        <trans-unit id="2f1b468fe1a7e1526a9f4c864607d41c919ffd24" translate="yes" xml:space="preserve">
          <source>Transient indices</source>
          <target state="translated">瞬态指数</target>
        </trans-unit>
        <trans-unit id="50518458bc2d78b06bb9e7c5b63ac61506608217" translate="yes" xml:space="preserve">
          <source>Translate between MBCS and UTF8 when running in &lt;a href=&quot;https://en.wikipedia.org/wiki/Cmd.exe&quot;&gt;cmd.exe&lt;/a&gt; on Windows.</source>
          <target state="translated">在Windows 上的&lt;a href=&quot;https://en.wikipedia.org/wiki/Cmd.exe&quot;&gt;cmd.exe中&lt;/a&gt;运行时，在MBCS和UTF8之间转换。</target>
        </trans-unit>
        <trans-unit id="6e387894c93cc4723354d247bd4d6e5f35bd4895" translate="yes" xml:space="preserve">
          <source>Translate filenames</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f295e110407055d129ea14d63c92143f2eb2907c" translate="yes" xml:space="preserve">
          <source>Translate the program source text into an executable format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="644d0f445f0d7fb8522aea7a162b92e1da1dcdd3" translate="yes" xml:space="preserve">
          <source>Treat carriage returns as white space.</source>
          <target state="translated">将回车作为白色空间处理。</target>
        </trans-unit>
        <trans-unit id="aa1627be3072e4ff3d0841c2ea6a10d65f535946" translate="yes" xml:space="preserve">
          <source>Treats the CROSS JOIN operator specially</source>
          <target state="translated">对CROSS JOIN操作者进行特殊处理</target>
        </trans-unit>
        <trans-unit id="decc687edb29445327b8a79bb188b87ba3135e16" translate="yes" xml:space="preserve">
          <source>Trigger automatic reprepares on all prepared statements when &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; is run.</source>
          <target state="translated">在运行&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;时，对所有准备好的语句触发自动重新准备。</target>
        </trans-unit>
        <trans-unit id="1766c462387d7f9f9f502cf4237e70b197fe70e9" translate="yes" xml:space="preserve">
          <source>Triggers are automatically &lt;a href=&quot;lang_droptrigger&quot;&gt;dropped&lt;/a&gt; when the table that they are associated with (the</source>
          <target state="translated">触发器自动&lt;a href=&quot;lang_droptrigger&quot;&gt;下降&lt;/a&gt;时表，他们正在与（相关</target>
        </trans-unit>
        <trans-unit id="69e3fbc441e15119829ba089bca3c89252728d25" translate="yes" xml:space="preserve">
          <source>Triggers are removed using the &lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt; statement.</source>
          <target state="translated">使用&lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt;语句删除触发器。</target>
        </trans-unit>
        <trans-unit id="dcdd52f1e8691359fb02268af93879c1dfcea004" translate="yes" xml:space="preserve">
          <source>Triggers may be created on &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt;, as well as ordinary tables, by specifying INSTEAD OF in the CREATE TRIGGER statement. If one or more ON INSERT, ON DELETE or ON UPDATE triggers are defined on a view, then it is not an error to execute an INSERT, DELETE or UPDATE statement on the view, respectively. Instead, executing an INSERT, DELETE or UPDATE on the view causes the associated triggers to fire. The real tables underlying the view are not modified (except possibly explicitly, by a trigger program).</source>
          <target state="translated">通过在CREATE TRIGGER语句中指定INSTEAD OF，可以在&lt;a href=&quot;lang_createview&quot;&gt;视图&lt;/a&gt;以及普通表上创建触发器。如果在视图上定义了一个或多个ON INSERT，ON DELETE或ON UPDATE触发器，那么分别在视图上执行INSERT，DELETE或UPDATE语句就不会出错。而是在视图上执行INSERT，DELETE或UPDATE会引发关联的触发器。视图基础的实际表不会被修改（可能由触发程序明确修改除外）。</target>
        </trans-unit>
        <trans-unit id="b66e919e408840fec331f77f8a3429cfe94170cd" translate="yes" xml:space="preserve">
          <source>Triggers such as the above could be entered manually, but that is tedious. An important feature of the technique demonstrated below is that the triggers are generated automatically.</source>
          <target state="translated">诸如上述的触发器可以手动输入,但那很繁琐。下面演示的技术的一个重要特点是,触发器是自动生成的。</target>
        </trans-unit>
        <trans-unit id="e34acb097623e43c8ff52044ca91f3ced5485a85" translate="yes" xml:space="preserve">
          <source>Triggers to record changes to table EX1 might look like this:</source>
          <target state="translated">记录表EX1变化的触发器可能是这样的。</target>
        </trans-unit>
        <trans-unit id="43c2fb589737be865737ea2fc85a0b75088859d6" translate="yes" xml:space="preserve">
          <source>True (non-zero) for incremental-vacuum mode. False (zero) otherwise.</source>
          <target state="translated">增量真空模式为真(非零),否则为假(零)。否则为假(零)。</target>
        </trans-unit>
        <trans-unit id="7f074c0b29f264e9ae59cff2fae5db054bccc396" translate="yes" xml:space="preserve">
          <source>True if column has a NOT NULL constraint</source>
          <target state="translated">如果列有NOT NULL约束,则为真。</target>
        </trans-unit>
        <trans-unit id="fe2612de064655438c6e90275d3a5af5d9b7504f" translate="yes" xml:space="preserve">
          <source>True if column is &lt;a href=&quot;../autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;</source>
          <target state="translated">如果&lt;a href=&quot;../autoinc&quot;&gt;列为AUTOINCREMENT，&lt;/a&gt;则为True</target>
        </trans-unit>
        <trans-unit id="7d8389507b03b7d46d63990e4a0a8f44db65074c" translate="yes" xml:space="preserve">
          <source>True if column is &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;</source>
          <target state="translated">如果&lt;a href=&quot;autoinc&quot;&gt;列为AUTOINCREMENT，&lt;/a&gt;则为True</target>
        </trans-unit>
        <trans-unit id="1c010493691adbcbc6784aac8024d72b69524a24" translate="yes" xml:space="preserve">
          <source>True if column is part of the PRIMARY KEY</source>
          <target state="translated">如果列是PRIMARY KEY的一部分,则为真。</target>
        </trans-unit>
        <trans-unit id="ce6a6b1eac82572eb6efa838b7ab286cb9aa31b8" translate="yes" xml:space="preserve">
          <source>True if the WAL file uses big-ending checksums. 0 if the WAL uses little-endian checksums.</source>
          <target state="translated">如果WAL文件使用大尾端校验和,则为真。如果WAL文件使用小尾数校验和,则为0。</target>
        </trans-unit>
        <trans-unit id="4f373c45e72a0d221fc0b61dcd227422649ce1e7" translate="yes" xml:space="preserve">
          <source>Truncate optimization</source>
          <target state="translated">截断优化</target>
        </trans-unit>
        <trans-unit id="7e18421daa9a7bec86e2d8e3de5902e74a610b23" translate="yes" xml:space="preserve">
          <source>Truncate rather than delete the rollback journal when committing a transaction in exclusive access mode, or when committing the TEMP database.</source>
          <target state="translated">在独占访问模式下提交事务或提交腾博会登录数据库时,截断而不是删除回滚日志。</target>
        </trans-unit>
        <trans-unit id="4b63e8b603e1d297d723aa97c1e1ff1c6b4ada53" translate="yes" xml:space="preserve">
          <source>Truncating a page from the end of the database file.</source>
          <target state="translated">从数据库文件的结尾处截断一个页面。</target>
        </trans-unit>
        <trans-unit id="4e8f932224015abd68ecfec37f440d1143c9375a" translate="yes" xml:space="preserve">
          <source>Try to set the maximum page count for database P1 to the value in P3. Do not let the maximum page count fall below the current page count and do not change the maximum page count value if P3==0.</source>
          <target state="translated">尝试将数据库P1的最大页数设置为P3中的值。不要让最大页数低于当前页数,如果P3==0,不要改变最大页数值。</target>
        </trans-unit>
        <trans-unit id="6f50ca78764f92b1078126a69f3373b839ce5721" translate="yes" xml:space="preserve">
          <source>Tweaks to the query planner to help it do a better job of finding the most efficient query plan for each query.</source>
          <target state="translated">对查询规划器进行调整,帮助它更好地为每个查询找到最有效的查询计划。</target>
        </trans-unit>
        <trans-unit id="95be1719f96ddc802fb54cddca40bb8014e1f9bb" translate="yes" xml:space="preserve">
          <source>Two &quot;%&quot; characters in a row are translated into a single &quot;%&quot; in the output, without substituting any values.</source>
          <target state="translated">一行中的两个&quot;%&quot;字符在输出中被翻译成一个&quot;%&quot;,不需要替换任何值。</target>
        </trans-unit>
        <trans-unit id="1133220939a743e590c3ead4cc79361a1d89e1c7" translate="yes" xml:space="preserve">
          <source>Two methods of measuring test coverage were described above: &quot;statement&quot; and &quot;branch&quot; coverage. There are many other test coverage metrics besides these two. Another popular metric is &quot;Modified Condition/Decision Coverage&quot; or MC/DC. &lt;a href=&quot;http://en.wikipedia.org/wiki/Modified_Condition/Decision_Coverage&quot;&gt;Wikipedia&lt;/a&gt; defines MC/DC as follows:</source>
          <target state="translated">上面描述了两种测量测试覆盖率的方法：&amp;ldquo;声明&amp;rdquo;和&amp;ldquo;分支&amp;rdquo;覆盖率。除了这两个以外，还有许多其他测试覆盖率指标。另一个流行的度量标准是&amp;ldquo;修改的条件/决策覆盖率&amp;rdquo;或MC / DC。&lt;a href=&quot;http://en.wikipedia.org/wiki/Modified_Condition/Decision_Coverage&quot;&gt;维基百科&lt;/a&gt;对MC / DC的定义如下：</target>
        </trans-unit>
        <trans-unit id="8cca3509242a992941b536c5c6f0d9414a60665b" translate="yes" xml:space="preserve">
          <source>Two or more &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; statements may be connected together to form a compound SELECT using the UNION, UNION ALL, INTERSECT or EXCEPT operator, as shown by the following diagram:</source>
          <target state="translated">可以使用UNION，UNION ALL，INTERSECT或EXCEPT运算符将两个或多个&lt;a href=&quot;lang_select#simpleselect&quot;&gt;简单的SELECT&lt;/a&gt;语句连接在一起以形成复合SELECT，如下图所示：</target>
        </trans-unit>
        <trans-unit id="b49920fdd4ad177f1ffaae1df0f25051b8256c94" translate="yes" xml:space="preserve">
          <source>Two or more MATCH operators are allowed in the same WHERE clause, as long as they are connected by AND operators. However, the R*Tree query engine only contains a single priority queue. The priority assigned to each node in the search is the lowest priority returned by any of the MATCH operators.</source>
          <target state="translated">在同一个WHERE子句中允许有两个或多个MATCH运算符,只要它们由AND运算符连接即可。但是,R*Tree查询引擎只包含一个优先级队列。分配给搜索中每个节点的优先级是任何一个MATCH操作符返回的最低优先级。</target>
        </trans-unit>
        <trans-unit id="b719bd70cf2f4781f7a548062aa93163c0a6f5e6" translate="yes" xml:space="preserve">
          <source>Two or more changeset/patchsets may be combined using the &lt;a href=&quot;session/sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat()&lt;/a&gt; or &lt;a href=&quot;session/changegroup&quot;&gt;sqlite3_changegroup&lt;/a&gt; interfaces.</source>
          <target state="translated">可以使用&lt;a href=&quot;session/sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat（）&lt;/a&gt;或&lt;a href=&quot;session/changegroup&quot;&gt;sqlite3_changegroup&lt;/a&gt;接口组合两个或多个变更集/补丁集。</target>
        </trans-unit>
        <trans-unit id="b9c4d063752347abc5d77d07399a38265fd22861" translate="yes" xml:space="preserve">
          <source>Two or more phrases may be grouped into a &lt;b&gt;NEAR group&lt;/b&gt;. A NEAR group is specified by the token &quot;NEAR&quot; (case sensitive) followed by an open parenthesis character, followed by two or more whitespace separated phrases, optionally followed by a comma and the numeric parameter</source>
          <target state="translated">可以将两个或多个短语分组为&lt;b&gt;NEAR组&lt;/b&gt;。NEAR组由标记&amp;ldquo; NEAR&amp;rdquo;（区分大小写）指定，后跟一个开放的括号字符，然后是两个或多个空格分隔的短语，并可选地后面跟一个逗号和数字参数</target>
        </trans-unit>
        <trans-unit id="0284a3abf0fb32119d7d4eb4f9b488143f92f251" translate="yes" xml:space="preserve">
          <source>Two other very minor bug fixes</source>
          <target state="translated">另外两个非常小的错误修复</target>
        </trans-unit>
        <trans-unit id="439961cdf4c53f5e47fc6a54c26c745e60b3c545" translate="yes" xml:space="preserve">
          <source>Two row values are compared by looking at the constituent scalar values from left to right. A NULL means of &quot;unknown&quot;. The overall result of comparison is NULL if it is possible to make the result either true or false by substituting alternative values in place of the constituent NULLs. The following query demonstrates some row value comparisons:</source>
          <target state="translated">通过从左到右观察组成标量值来比较两行值。NULL表示 &quot;未知&quot;。如果可以通过用替代值代替组成的NULL来使结果为真或为假,那么比较的总体结果就是NULL。下面的查询演示了一些行值比较。</target>
        </trans-unit>
        <trans-unit id="ce050ac4e33af964af82beb0e5b3e0ce52ab58e9" translate="yes" xml:space="preserve">
          <source>Two row values of the same size can be compared using operators &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, =, &amp;lt;&amp;gt;, IS, IS NOT, IN, NOT IN, BETWEEN, or CASE.</source>
          <target state="translated">可以使用运算符&amp;lt;，&amp;lt;=，&amp;gt;，&amp;gt; =，=，&amp;lt;&amp;gt;，IS，IS NOT，IN，IN，NOT IN，BETWEEN或CASE比较具有相同大小的两个行值。</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
