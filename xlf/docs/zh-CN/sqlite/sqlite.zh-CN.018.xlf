<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="a689b67f9c0bc2c193b97b5db4c5c4f5c1e2370b" translate="yes" xml:space="preserve">
          <source>This interface is similar except that it takes a pointer to a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as its first argument and returns statistics about that one object rather than about the entire SQLite library. The &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface currently only recognizes a single verb &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuslookasideused&quot;&gt;SQLITE_DBSTATUS_LOOKASIDE_USED&lt;/a&gt;, though additional verbs may be added in the future.</source>
          <target state="translated">该接口与之类似，不同之处在于它以指向&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;的指针作为第一个参数，并返回有关该对象而不是整个SQLite库的统计信息。所述&lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;接口目前只能识别单一的动词&lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuslookasideused&quot;&gt;SQLITE_DBSTATUS_LOOKASIDE_USED&lt;/a&gt;，虽然附加的动词可以在将来增加。</target>
        </trans-unit>
        <trans-unit id="6dbf3e0af679b24ae953bf947ba5e6b711370c31" translate="yes" xml:space="preserve">
          <source>This interface is threadsafe on processors where writing a 32-bit integer is atomic.</source>
          <target state="translated">这个接口在写32位整数的处理器上是线程安全的。</target>
        </trans-unit>
        <trans-unit id="107b6df452544e21fe27c0a26828c70050b20ba8" translate="yes" xml:space="preserve">
          <source>This interface is used to retrieve and reset counter values from a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. The first argument is the prepared statement object to be interrogated. The second argument is an integer code for a specific &lt;a href=&quot;#SQLITE_STMTSTATUS%20counter&quot;&gt;SQLITE_STMTSTATUS counter&lt;/a&gt; to be interrogated. The current value of the requested counter is returned. If the resetFlg is true, then the counter is reset to zero after this interface call returns.</source>
          <target state="translated">该接口用于从&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句中&lt;/a&gt;检索和重置计数器值。第一个参数是要查询的准备好的语句对象。第二个参数是要查询的特定&lt;a href=&quot;#SQLITE_STMTSTATUS%20counter&quot;&gt;SQLITE_STMTSTATUS计数器&lt;/a&gt;的整数代码。返回所请求计数器的当前值。如果resetFlg为true，则此接口调用返回后，计数器将重置为零。</target>
        </trans-unit>
        <trans-unit id="459a2b79d755add49b63bbc4196d838dcdf41bd6" translate="yes" xml:space="preserve">
          <source>This interface is used to retrieve and reset counter values from a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. The first argument is the prepared statement object to be interrogated. The second argument is an integer code for a specific &lt;a href=&quot;c_stmtstatus_counter&quot;&gt;SQLITE_STMTSTATUS counter&lt;/a&gt; to be interrogated. The current value of the requested counter is returned. If the resetFlg is true, then the counter is reset to zero after this interface call returns.</source>
          <target state="translated">该接口用于从&lt;a href=&quot;stmt&quot;&gt;准备好的语句中&lt;/a&gt;检索和重置计数器值。第一个参数是要查询的准备好的语句对象。第二个参数是要查询的特定&lt;a href=&quot;c_stmtstatus_counter&quot;&gt;SQLITE_STMTSTATUS计数器&lt;/a&gt;的整数代码。返回所请求计数器的当前值。如果resetFlg为true，则此接口调用返回后，计数器将重置为零。</target>
        </trans-unit>
        <trans-unit id="4800232e2d56454f4af979f9b03af1383971aa52" translate="yes" xml:space="preserve">
          <source>This interface is used to retrieve runtime status information about a single &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument is the database connection object to be interrogated. The second argument is an integer constant, taken from the set of &lt;a href=&quot;#SQLITE_DBSTATUS%20options&quot;&gt;SQLITE_DBSTATUS options&lt;/a&gt;, that determines the parameter to interrogate. The set of &lt;a href=&quot;#SQLITE_DBSTATUS%20options&quot;&gt;SQLITE_DBSTATUS options&lt;/a&gt; is likely to grow in future releases of SQLite.</source>
          <target state="translated">此接口用于检索有关单个&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接的&lt;/a&gt;运行时状态信息。第一个参数是要查询的数据库连接对象。第二个参数是一个整数常量，它取自&lt;a href=&quot;#SQLITE_DBSTATUS%20options&quot;&gt;SQLITE_DBSTATUS选项&lt;/a&gt;的集合，该常量确定要询问的参数。&lt;a href=&quot;#SQLITE_DBSTATUS%20options&quot;&gt;SQLITE_DBSTATUS选项&lt;/a&gt;的集合在将来的SQLite版本中可能会增加。</target>
        </trans-unit>
        <trans-unit id="bbc3302201d2b7cd437db8ee6aa036bac03658d0" translate="yes" xml:space="preserve">
          <source>This interface is used to retrieve runtime status information about a single &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument is the database connection object to be interrogated. The second argument is an integer constant, taken from the set of &lt;a href=&quot;c_dbstatus_options&quot;&gt;SQLITE_DBSTATUS options&lt;/a&gt;, that determines the parameter to interrogate. The set of &lt;a href=&quot;c_dbstatus_options&quot;&gt;SQLITE_DBSTATUS options&lt;/a&gt; is likely to grow in future releases of SQLite.</source>
          <target state="translated">此接口用于检索有关单个&lt;a href=&quot;sqlite3&quot;&gt;数据库连接的&lt;/a&gt;运行时状态信息。第一个参数是要查询的数据库连接对象。第二个参数是一个整数常量，它取自&lt;a href=&quot;c_dbstatus_options&quot;&gt;SQLITE_DBSTATUS选项&lt;/a&gt;的集合，该常量确定要询问的参数。&lt;a href=&quot;c_dbstatus_options&quot;&gt;SQLITE_DBSTATUS选项&lt;/a&gt;的集合在将来的SQLite版本中可能会增加。</target>
        </trans-unit>
        <trans-unit id="0177c23c0459f643a4c9d13247ce19efb1a18257" translate="yes" xml:space="preserve">
          <source>This interface loads an SQLite extension library from the named file.</source>
          <target state="translated">这个接口从命名的文件中加载一个SQLite扩展库。</target>
        </trans-unit>
        <trans-unit id="8179bad6a4aa6b903a52e81e492e1156f601b09e" translate="yes" xml:space="preserve">
          <source>This interface only reports on the compile-time mutex setting of the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; flag. If SQLite is compiled with SQLITE_THREADSAFE=1 or =2 then mutexes are enabled by default but can be fully or partially disabled using a call to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; with the verbs &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;, &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt;, or &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt;. The return value of the sqlite3_threadsafe() function shows only the compile-time setting of thread safety, not any run-time changes to that setting made by sqlite3_config(). In other words, the return value from sqlite3_threadsafe() is unchanged by calls to sqlite3_config().</source>
          <target state="translated">该接口仅报告&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt;标志的编译时互斥设置。如果使用SQLITE_THREADSAFE = 1或= 2编译SQLite，则默认情况下会启用互斥锁，但可以通过使用带有动词&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;，&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt;或&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED的&lt;/a&gt;&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;调用来完全或部分禁用互斥锁。 sqlite3_threadsafe（）函数的返回值仅显示线程安全的编译时设置，而不显示对sqlite3_config（）所做的设置的任何运行时更改。换句话说，通过调用sqlite3_config（）不会改变sqlite3_threadsafe（）的返回值。</target>
        </trans-unit>
        <trans-unit id="2f1c5432e18dc84d0ab872e79f78a9b49a5ab932" translate="yes" xml:space="preserve">
          <source>This interface only reports on the compile-time mutex setting of the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; flag. If SQLite is compiled with SQLITE_THREADSAFE=1 or =2 then mutexes are enabled by default but can be fully or partially disabled using a call to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; with the verbs &lt;a href=&quot;#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;, &lt;a href=&quot;#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt;, or &lt;a href=&quot;#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt;. The return value of the sqlite3_threadsafe() function shows only the compile-time setting of thread safety, not any run-time changes to that setting made by sqlite3_config(). In other words, the return value from sqlite3_threadsafe() is unchanged by calls to sqlite3_config().</source>
          <target state="translated">该接口仅报告&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt;标志的编译时互斥设置。如果使用SQLITE_THREADSAFE = 1或= 2编译SQLite，则默认情况下会启用互斥锁，但可以通过使用带有动词&lt;a href=&quot;#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;，&lt;a href=&quot;#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt;或&lt;a href=&quot;#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED的&lt;/a&gt;&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;调用来完全或部分禁用互斥锁。 sqlite3_threadsafe（）函数的返回值仅显示线程安全的编译时设置，而不显示对sqlite3_config（）所做的设置的任何运行时更改。换句话说，通过调用sqlite3_config（）不会改变sqlite3_threadsafe（）的返回值。</target>
        </trans-unit>
        <trans-unit id="3e88b1695c7d666ba2e7d53c0b55a6d5efcc55d7" translate="yes" xml:space="preserve">
          <source>This interface returns a pointer the &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object that serializes access to the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; given in the argument when the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; is Serialized. If the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; is Single-thread or Multi-thread then this routine returns a NULL pointer.</source>
          <target state="translated">该接口返回一个指针&lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;对象，该对象将在&lt;a href=&quot;threadsafe&quot;&gt;线程化模式&lt;/a&gt;为Serialized时序列化对参数中给定的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接的&lt;/a&gt;访问。如果&lt;a href=&quot;threadsafe&quot;&gt;线程模式&lt;/a&gt;是单线程或多线程，则此例程返回NULL指针。</target>
        </trans-unit>
        <trans-unit id="d1fc22f71a3cec256b724ef1c90f879b1fc5cc86" translate="yes" xml:space="preserve">
          <source>This interface returns a pointer the &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object that serializes access to the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; given in the argument when the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; is Serialized. If the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; is Single-thread or Multi-thread then this routine returns a NULL pointer.</source>
          <target state="translated">该接口返回一个指针&lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;对象，该对象将在&lt;a href=&quot;../threadsafe&quot;&gt;线程化模式&lt;/a&gt;为Serialized时序列化对参数中给定的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接的&lt;/a&gt;访问。如果&lt;a href=&quot;../threadsafe&quot;&gt;线程模式&lt;/a&gt;是单线程或多线程，则此例程返回NULL指针。</target>
        </trans-unit>
        <trans-unit id="293e65533b2e0bf802333580611e0758a28818fb" translate="yes" xml:space="preserve">
          <source>This interface returns a pointer to the next &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; after pStmt associated with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; pDb. If pStmt is NULL then this interface returns a pointer to the first prepared statement associated with the database connection pDb. If no prepared statement satisfies the conditions of this routine, it returns NULL.</source>
          <target state="translated">该接口返回指向与&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; pDb 关联的pStmt 之后的下一个&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;的指针。如果pStmt为NULL，则此接口返回指向与数据库连接pDb关联的第一个准备好的语句的指针。如果没有准备好的语句满足该例程的条件，则返回NULL。</target>
        </trans-unit>
        <trans-unit id="298da08b2fcbf608e155bad7e295f53eb1526e44" translate="yes" xml:space="preserve">
          <source>This interface returns a pointer to the next &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; after pStmt associated with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; pDb. If pStmt is NULL then this interface returns a pointer to the first prepared statement associated with the database connection pDb. If no prepared statement satisfies the conditions of this routine, it returns NULL.</source>
          <target state="translated">该接口返回指向与&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; pDb 关联的pStmt 之后的下一个&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;的指针。如果pStmt为NULL，则此接口返回指向与数据库连接pDb关联的第一个准备好的语句的指针。如果没有准备好的语句满足该例程的条件，则返回NULL。</target>
        </trans-unit>
        <trans-unit id="e0779d667db00a554725939028269aca490f34bf" translate="yes" xml:space="preserve">
          <source>This interface returns information about the predicted and measured performance for pStmt. Advanced applications can use this interface to compare the predicted and the measured performance and issue warnings and/or rerun &lt;a href=&quot;../lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; if discrepancies are found.</source>
          <target state="translated">此接口返回有关pStmt的预测和测量性能的信息。高级应用程序可以使用此界面比较预测的性能和测量的性能，并发出警告和/或在发现差异时重新运行&lt;a href=&quot;../lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="85a4493d9adb4944292a15518241fee7e748e502" translate="yes" xml:space="preserve">
          <source>This interface returns information about the predicted and measured performance for pStmt. Advanced applications can use this interface to compare the predicted and the measured performance and issue warnings and/or rerun &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; if discrepancies are found.</source>
          <target state="translated">此接口返回有关pStmt的预测和测量性能的信息。高级应用程序可以使用此界面比较预测的性能和测量的性能，并发出警告和/或在发现差异时重新运行&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1bb0500a44659bfdd838f99dddff5b2745a24fd7" translate="yes" xml:space="preserve">
          <source>This interface used to be the only way to cause a checkpoint to occur. But then the newer and more powerful &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface was added. This interface is retained for backwards compatibility and as a convenience for applications that need to manually start a callback but which do not need the full power (and corresponding complication) of &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt;.</source>
          <target state="translated">该接口曾经是导致检查点发生的唯一方法。但是随后添加了更新且功能更强大的&lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;接口。保留此接口是为了向后兼容，并且为需要手动启动回调但不需要&lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;的全部功能（以及相应的复杂性）的应用程序提供便利。</target>
        </trans-unit>
        <trans-unit id="f8650a908576cbf78aafa5f2c01220a648b07e6e" translate="yes" xml:space="preserve">
          <source>This interface used to be the only way to cause a checkpoint to occur. But then the newer and more powerful &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface was added. This interface is retained for backwards compatibility and as a convenience for applications that need to manually start a callback but which do not need the full power (and corresponding complication) of &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt;.</source>
          <target state="translated">该接口曾经是导致检查点发生的唯一方法。但是随后添加了更新且功能更强大的&lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;接口。保留此接口是为了向后兼容，并且为需要手动启动回调但不需要&lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;的全部功能（以及相应的复杂性）的应用程序提供便利。</target>
        </trans-unit>
        <trans-unit id="f7d4c03d6a4b6a9f5c9aedcc9b701719388f47dd" translate="yes" xml:space="preserve">
          <source>This interfaces opens a &lt;a href=&quot;#sqlite3_blob&quot;&gt;handle&lt;/a&gt; to the BLOB located in row iRow, column zColumn, table zTable in database zDb; in other words, the same BLOB that would be selected by:</source>
          <target state="translated">该接口为位于数据库zDb中的iRow行，zColumn列，zTable表中的BLOB 打开&lt;a href=&quot;#sqlite3_blob&quot;&gt;句柄&lt;/a&gt;；换句话说，将通过以下方式选择相同的BLOB：</target>
        </trans-unit>
        <trans-unit id="d56bad6a2645b8e7253284f59e7a63eae875fa74" translate="yes" xml:space="preserve">
          <source>This interfaces opens a &lt;a href=&quot;blob&quot;&gt;handle&lt;/a&gt; to the BLOB located in row iRow, column zColumn, table zTable in database zDb; in other words, the same BLOB that would be selected by:</source>
          <target state="translated">该接口为位于数据库zDb中的iRow行，zColumn列，zTable表中的BLOB 打开&lt;a href=&quot;blob&quot;&gt;句柄&lt;/a&gt;；换句话说，将通过以下方式选择相同的BLOB：</target>
        </trans-unit>
        <trans-unit id="13a6b9699070bd3ee5f0499a2e1cddf56e4de906" translate="yes" xml:space="preserve">
          <source>This is a convenience method. It saves the user from having to do a &quot;&lt;code&gt;[lindex ... 0]&lt;/code&gt;&quot; on the results of an &quot;eval&quot; in order to extract a single column result.</source>
          <target state="translated">这是一种方便的方法。它使用户不必为了提取单列结果而对&amp;ldquo; eval&amp;rdquo;的结果执行&amp;ldquo; &lt;code&gt;[lindex ... 0]&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="38e166d44e718495aa683d7ad0a1c631f4c6b59a" translate="yes" xml:space="preserve">
          <source>This is a deferred seek. Nothing actually happens until the cursor is used to read a record. That way, if no reads occur, no unnecessary I/O happens.</source>
          <target state="translated">这是一个延迟查找。在使用游标读取记录之前,实际上什么都没有发生。这样一来,如果没有发生读取,就不会发生不必要的I/O。</target>
        </trans-unit>
        <trans-unit id="2382322bd7fe40fc2a51108a576a294144a75f00" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of the &lt;a href=&quot;#sqlite3_hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface. This routine is provided for historical compatibility only. All new applications should use the &lt;a href=&quot;#sqlite3_hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface rather than this one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3322a19f5183f0c0a12dac751f8fe80d74d2317" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of the &lt;a href=&quot;#sqlite3_soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface. This routine is provided for historical compatibility only. All new applications should use the &lt;a href=&quot;#sqlite3_soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface rather than this one.</source>
          <target state="translated">这是&lt;a href=&quot;#sqlite3_soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64（）&lt;/a&gt;接口的不推荐使用的版本。提供此例程仅出于历史兼容性。所有新应用程序都应使用&lt;a href=&quot;#sqlite3_soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64（）&lt;/a&gt;接口，而不要使用此接口。</target>
        </trans-unit>
        <trans-unit id="549ad021f1f25c6ff9bbe6ad516bdc1aab2d979c" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of the &lt;a href=&quot;hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface. This routine is provided for historical compatibility only. All new applications should use the &lt;a href=&quot;hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface rather than this one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83b5b2c4751d7d27636c7987b515f0e77b9f539e" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of the &lt;a href=&quot;soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface. This routine is provided for historical compatibility only. All new applications should use the &lt;a href=&quot;soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface rather than this one.</source>
          <target state="translated">这是&lt;a href=&quot;soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64（）&lt;/a&gt;接口的不推荐使用的版本。提供此例程仅出于历史兼容性。所有新应用程序都应使用&lt;a href=&quot;soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64（）&lt;/a&gt;接口，而不要使用此接口。</target>
        </trans-unit>
        <trans-unit id="3265de0d01aec05a2acca7ad5cf1ffeadb61ea03" translate="yes" xml:space="preserve">
          <source>This is a feature, not a bug. SQLite uses &lt;a href=&quot;datatype3&quot;&gt;dynamic typing&lt;/a&gt;. It does not enforce data type constraints. Data of any type can (usually) be inserted into any column. You can put arbitrary length strings into integer columns, floating point numbers in boolean columns, or dates in character columns. The &lt;a href=&quot;datatype3&quot;&gt;datatype&lt;/a&gt; you assign to a column in the CREATE TABLE command does not restrict what data can be put into that column. Every column is able to hold an arbitrary length string. (There is one exception: Columns of type &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; may only hold a 64-bit signed integer. An error will result if you try to put anything other than an integer into an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column.)</source>
          <target state="translated">这是一个功能，而不是错误。 SQLite使用&lt;a href=&quot;datatype3&quot;&gt;动态类型&lt;/a&gt;。它不强制执行数据类型约束。任何类型的数据都可以（通常）插入任何列中。您可以将任意长度的字符串放入整数列，布尔列中的浮点数或字符列中的日期。您在CREATE TABLE命令中分配给列的&lt;a href=&quot;datatype3&quot;&gt;数据类型&lt;/a&gt;不限制可以在该列中放入哪些数据。每列都可以容纳任意长度的字符串。 （有一个例外：&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;类型的列只能包含一个64位带符号整数。如果尝试将一个整数以外的任何内容放入&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列，则会导致错误。）</target>
        </trans-unit>
        <trans-unit id="c7d02094df3f3fda475c3c0669d010669d55439e" translate="yes" xml:space="preserve">
          <source>This is a legacy interface that is preserved for backwards compatibility. Use of this interface is not recommended.</source>
          <target state="translated">这是一个传统的接口,为了向后兼容而保留下来。不建议使用该接口。</target>
        </trans-unit>
        <trans-unit id="5f257f6218e523212322ebfdf81d8c0135554419" translate="yes" xml:space="preserve">
          <source>This is a limitation of the R-Tree extension only. Ordinary tables in SQLite are able to read and write at the same time. Other virtual tables might (or might not) also that capability. And R-Tree can appear to read and write at the same time in some circumstances, if it can figure out how to reliably run the query to completion before starting the update. But you shouldn't count on that for every query. Generally speaking, it is best to avoid running queries and updates to the same R-Tree at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d61b35431e03f12c702f21bbd7e7a511e4a6548" translate="yes" xml:space="preserve">
          <source>This is a maintenance release only. Various minor bugs have been fixed and some portability enhancements are added.</source>
          <target state="translated">这只是一个维护版本。修复了各种小错误,并增加了一些可移植性的改进。</target>
        </trans-unit>
        <trans-unit id="899c3e8633e96cd6aefa72bc202abc232fd0022d" translate="yes" xml:space="preserve">
          <source>This is an edit distance or Levenshtein distance going from the pattern to the word.</source>
          <target state="translated">这是一个从图案到单词的编辑距离或莱文什丁距离。</target>
        </trans-unit>
        <trans-unit id="910e8aa32c8839104ce5280b502b0fcc013f6738" translate="yes" xml:space="preserve">
          <source>This is an optimized version of &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt; that works only for integer values.</source>
          <target state="translated">这是&lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt;的优化版本，仅适用于整数值。</target>
        </trans-unit>
        <trans-unit id="801748b6bec70348d36bd30ab9aa7d8d99ebf0cc" translate="yes" xml:space="preserve">
          <source>This is done by using the file locking facilities provided by the VFS adaptor to serialize writers (write transactions) and preventing readers (read transactions) from accessing database files while writers are midway through updating them.</source>
          <target state="translated">这是通过使用VFS适配器提供的文件锁定设施来实现的,它可以将写入者(写事务)序列化,并防止读取者(读事务)在写入者更新数据库文件的中途访问数据库文件。</target>
        </trans-unit>
        <trans-unit id="8da36cedfb4232a176b408433fde7c4fd7207c97" translate="yes" xml:space="preserve">
          <source>This is not a trivial point. A clear, concise, and easy to understand file format is a crucial part of any application design. Fred Brooks, in his all-time best-selling computer science text,</source>
          <target state="translated">这不是一个小问题。一个清晰、简明、易懂的文件格式是任何应用程序设计的关键部分。弗雷德-布鲁克斯在他的历史上最畅销的计算机科学文本中:</target>
        </trans-unit>
        <trans-unit id="71f131e03503ae5c8b8ced0f182cb10a7090642b" translate="yes" xml:space="preserve">
          <source>This is not valid SQL because of the apostrophe in the word &quot;y'all&quot;. But if the %q formatting option is used instead of %s, like this:</source>
          <target state="translated">这不是有效的SQL,因为 &quot;y'all &quot;一词中的撇号。但如果用%q格式选项代替%s,就像这样。</target>
        </trans-unit>
        <trans-unit id="b10e12e9a12481ea13f1cbdd991de65338cc882f" translate="yes" xml:space="preserve">
          <source>This is the &quot;alternate-form-1&quot; flag. For %g and %G substitutions, this causes trailing zeros to be removed. This flag forces a decimal point to appear for all floating-point substitutions. For %o, %x, and %X substitutions, the alternate-form-1 flag cause the value to be prepended with &quot;0&quot;, &quot;0x&quot;, or &quot;0X&quot;, respectively.</source>
          <target state="translated">这是 &quot;交替形式-1 &quot;标志。对于%g和%G的替换,会导致去掉尾部的零。这个标志使得所有浮点替换都会出现一个小数点。对于%o、%x和%X的替换,交替形式-1标志分别使数值以 &quot;0&quot;、&quot;0x &quot;或 &quot;0X &quot;开头。</target>
        </trans-unit>
        <trans-unit id="63cb4b6d9fe02ab2deb206f8aa9f5671d078c8f3" translate="yes" xml:space="preserve">
          <source>This is the &quot;alternate-form-2 flag. For string substitutions, this flag causes the width and precision to be understand in terms of characters rather than bytes. For floating point substitutions, the alternate-form-2 flag increases the maximum number of significant digits displayed from 16 to 26, forces the display of the decimal point and causes at least one digit to appear after the decimal point.</source>
          <target state="translated">这就是 &quot;交替形式-2 &quot;标志,对于字符串的替换,这个标志会使宽度和精度以字符而不是以字节来理解。对于字符串替换,这个标志使宽度和精度以字符而不是以字节来理解。对于浮点替换,交替形式-2标志将显示的最大有效数字数从16位增加到26位,强制显示小数点,并使小数点后至少出现一位数字。</target>
        </trans-unit>
        <trans-unit id="bc902c483a7876a1b0deb3582a89dafeb4cea481" translate="yes" xml:space="preserve">
          <source>This is the Quality Management Plan for SQLite.</source>
          <target state="translated">这就是SQLite的质量管理计划。</target>
        </trans-unit>
        <trans-unit id="67d77b8b0173c35f0fc8ffa751afcfc454c71889" translate="yes" xml:space="preserve">
          <source>This is the approximate number of bytes of heap memory used to store the prepared statement. This value is not actually a counter, and so the resetFlg parameter to sqlite3_stmt_status() is ignored when the opcode is SQLITE_STMTSTATUS_MEMUSED.</source>
          <target state="translated">这是用来存储准备好的语句的堆内存的大约字节数。这个值实际上不是一个计数器,所以当操作码为SQLITE_STMTSTATUS_MEMUSED时,sqlite3_stmt_status()的resetFlg参数被忽略。</target>
        </trans-unit>
        <trans-unit id="f5f605b9bb40dfe0763a4e4919a2589f9005f3a1" translate="yes" xml:space="preserve">
          <source>This is the language-id of the word. All queries are against a single language-id, which defaults to 0. For any given query this value is the same on all rows.</source>
          <target state="translated">这是该词的语言标识。对于任何给定的查询,这个值在所有行中都是相同的。</target>
        </trans-unit>
        <trans-unit id="9fdc70ab1d09ee31e6a0831adfe5fa272a3194e2" translate="yes" xml:space="preserve">
          <source>This is the number of rows inserted into transient indices that were created automatically in order to help joins run faster. A non-zero value in this counter may indicate an opportunity to improvement performance by adding permanent indices that do not need to be reinitialized each time the statement is run.</source>
          <target state="translated">这是插入到自动创建的瞬时索引中的行数,这些索引的创建是为了帮助连接运行得更快。这个计数器中的非零值可能表明有机会通过添加永久索引来提高性能,因为永久索引不需要在每次运行语句时重新初始化。</target>
        </trans-unit>
        <trans-unit id="8c5491db23237dd3c1b297335729c93feb9329fe" translate="yes" xml:space="preserve">
          <source>This is the number of sort operations that have occurred. A non-zero value in this counter may indicate an opportunity to improvement performance through careful use of indices.</source>
          <target state="translated">这是已发生的排序操作的次数。该计数器中的非零值可能表明有机会通过谨慎使用指数来提高性能。</target>
        </trans-unit>
        <trans-unit id="f6022b63855545d987e1fb6ed3574f3dde788d4f" translate="yes" xml:space="preserve">
          <source>This is the number of times that SQLite has stepped forward in a table as part of a full table scan. Large numbers for this counter may indicate opportunities for performance improvement through careful use of indices.</source>
          <target state="translated">这是SQLite作为全表扫描的一部分,在表中向前迈进的次数。该计数器的数字越大,表明有机会通过谨慎使用索引来提高性能。</target>
        </trans-unit>
        <trans-unit id="2e2d5cd35f18306585fb3833a8437cb1c68463de" translate="yes" xml:space="preserve">
          <source>This is the number of times that the prepare statement has been automatically regenerated due to schema changes or change to &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; that might affect the query plan.</source>
          <target state="translated">这是由于架构更改或更改&lt;a href=&quot;../lang_expr#varparam&quot;&gt;绑定参数&lt;/a&gt;（可能影响查询计划）而自动重新生成prepare语句的次数。</target>
        </trans-unit>
        <trans-unit id="89a19ef4023707e912e6bb81167cc9edbf3dbf2a" translate="yes" xml:space="preserve">
          <source>This is the number of times that the prepare statement has been automatically regenerated due to schema changes or change to &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; that might affect the query plan.</source>
          <target state="translated">这是由于架构更改或更改&lt;a href=&quot;lang_expr#varparam&quot;&gt;绑定参数&lt;/a&gt;（可能影响查询计划）而自动重新生成prepare语句的次数。</target>
        </trans-unit>
        <trans-unit id="ad8da654215d27127f1f2f4f4e254bee11f6c200" translate="yes" xml:space="preserve">
          <source>This is the number of times that the prepare statement has been automatically regenerated due to schema changes or changes to &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; that might affect the query plan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b13313031c39949951f19dcc69954d4d1da9fef4" translate="yes" xml:space="preserve">
          <source>This is the number of times that the prepare statement has been automatically regenerated due to schema changes or changes to &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; that might affect the query plan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fb615d618780dfbede44490d9c1ccf7fc81bcec" translate="yes" xml:space="preserve">
          <source>This is the number of times that the prepared statement has been run. A single &quot;run&quot; for the purposes of this counter is one or more calls to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; followed by a call to &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt;. The counter is incremented on the first &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call of each cycle.</source>
          <target state="translated">这是已准备的语句已运行的次数。就此计数器而言，单个&amp;ldquo;运行&amp;rdquo;是对&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）的&lt;/a&gt;一个或多个调用，然后是对&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;的调用。在每个周期的第一个&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;调用中，计数器都会递增。</target>
        </trans-unit>
        <trans-unit id="02a22b1b5a6d045d2732a9c5f17c43be586d3ec0" translate="yes" xml:space="preserve">
          <source>This is the number of times that the prepared statement has been run. A single &quot;run&quot; for the purposes of this counter is one or more calls to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; followed by a call to &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt;. The counter is incremented on the first &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call of each cycle.</source>
          <target state="translated">这是已准备的语句已运行的次数。就此计数器而言，单个&amp;ldquo;运行&amp;rdquo;是对&lt;a href=&quot;step&quot;&gt;sqlite3_step（）的&lt;/a&gt;一个或多个调用，然后是对&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;的调用。在每个周期的第一个&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;调用中，计数器都会递增。</target>
        </trans-unit>
        <trans-unit id="dac86b21d034a44083d19f0648edfd3d6aee1a04" translate="yes" xml:space="preserve">
          <source>This is the number of virtual machine operations executed by the prepared statement if that number is less than or equal to 2147483647. The number of virtual machine operations can be used as a proxy for the total work done by the prepared statement. If the number of virtual machine operations exceeds 2147483647 then the value returned by this statement status code is undefined.</source>
          <target state="translated">这是准备好的语句所执行的虚拟机操作数,如果该数小于或等于2147483647。虚拟机操作数可以作为准备好的语句所做的总工作的代理。如果虚拟机操作数超过2147483647,则该语句状态码返回的值为未定义。</target>
        </trans-unit>
        <trans-unit id="cd780664af2f5e88c09d027911d10ff2fa28ed11" translate="yes" xml:space="preserve">
          <source>This is the query that solves the puzzle:</source>
          <target state="translated">这就是解决难题的查询。</target>
        </trans-unit>
        <trans-unit id="68e28408e53f654e22a7d4b5e13087b011ad015a" translate="yes" xml:space="preserve">
          <source>This is the rank of the word, as specified in the original INSERT statement.</source>
          <target state="translated">这是单词的等级,在原始INSERT语句中指定。</target>
        </trans-unit>
        <trans-unit id="3c347af279705ccb7203ae88698186539d78c1bc" translate="yes" xml:space="preserve">
          <source>This is the same as &quot;&amp;lt;expr&amp;gt; PRECEDING&quot; except that the boundary is &amp;lt;expr&amp;gt; units after the current rather than before the current row.</source>
          <target state="translated">这与&amp;ldquo; &amp;lt;expr&amp;gt; PRECEDING&amp;rdquo;相同，除了边界是当前行之后而不是当前行之前的&amp;lt;expr&amp;gt;个单位。</target>
        </trans-unit>
        <trans-unit id="b5b506e660f5afa226074ab8a993cee25ea85c25" translate="yes" xml:space="preserve">
          <source>This key is then limited to &quot;scope&quot; characters. The default scope value is 4, but an alternative scope can be specified using the &quot;scope=N&quot; term in the WHERE clause. After the key has been truncated, the edit distance is run against every term in the vocabulary that has a k2 value that begins with the abbreviated key.</source>
          <target state="translated">然后这个键被限制在 &quot;范围 &quot;字符。默认的范围值是4,但是可以使用WHERE子句中的 &quot;scope=N &quot;术语指定一个替代范围。在键被截断后,编辑距离将针对词汇表中每一个具有以缩写键开头的k2值的术语运行。</target>
        </trans-unit>
        <trans-unit id="09f3f2089114bd06180ad8313e37ae120cabb71b" translate="yes" xml:space="preserve">
          <source>This kind of problem comes up all the time when dealing with floating point binary numbers. The general rule to remember is that most fractional numbers that have a finite representation in decimal (a.k.a &quot;base-10&quot;) do not have a finite representation in binary (a.k.a &quot;base-2&quot;). And so they are approximated using the closest binary number available. That approximation is usually very close, but it will be slightly off and in some cases can cause your results to be a little different from what you might expect.</source>
          <target state="translated">在处理浮点二进制数时,这种问题经常出现。要记住的一般规则是,大多数小数在十进制(也就是 &quot;base-10&quot;)中都有有限的表示,但在二进制(也就是 &quot;base-2&quot;)中没有有限的表示。因此,它们是用最接近的二进制数来近似表示的。这种近似值通常是非常接近的,但它会稍有偏差,在某些情况下,可能会导致您的结果与您可能期望的略有不同。</target>
        </trans-unit>
        <trans-unit id="a135a2763d0f0112ca15bcc48e7dbab83e04271e" translate="yes" xml:space="preserve">
          <source>This last code will give the following output:</source>
          <target state="translated">最后这段代码将给出以下输出。</target>
        </trans-unit>
        <trans-unit id="47d19850010695a0ad5164e9f6289137fa74e392" translate="yes" xml:space="preserve">
          <source>This later query generates exactly the same &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; as the previous scalar formulation, but using syntax that it cleaner and easier to read.</source>
          <target state="translated">此后一个查询生成与以前的标量公式完全相同的&lt;a href=&quot;opcode&quot;&gt;字节码&lt;/a&gt;，但使用的语法更清晰，更易于阅读。</target>
        </trans-unit>
        <trans-unit id="ee338f99e5b2a8dc89eb5fd7e38f440a68b4f663" translate="yes" xml:space="preserve">
          <source>This limit is only functional if memory usage statistics are available via the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64&lt;/a&gt;(&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;) interfaces. Without that memory usage information, SQLite has no way of knowing when it is about to go over the limit, and thus is unable to prevent the excess memory allocation. Memory usage tracking is turned on by default, but can be disabled at compile-time using the &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; option, or at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;).</source>
          <target state="translated">仅当通过&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;和&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64&lt;/a&gt;（&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;）接口提供内存使用情况统计信息时，此限制才起作用。没有该内存使用信息，SQLite无法知道何时将要超过限制，因此无法防止过多的内存分配。内存使用情况跟踪默认情况下处于打开状态，但可以在编译时使用&lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;选项禁用，也可以在启动时使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;）禁用。</target>
        </trans-unit>
        <trans-unit id="13ca9d3dd4559d964cbe8a24d9fb9dfdfb2e704d" translate="yes" xml:space="preserve">
          <source>This loop does the actual deleting. It is organized differently from the one in the UPDATE example. The ListRead instruction plays the role that the Next did in the INSERT loop, but because it jumps to P2 on failure, and Next jumps on success, we put it at the start of the loop instead of the end. This means that we have to put a Goto at the end of the loop to jump back to the loop test at the beginning. So this loop has the form of a C while(){...} loop, while the loop in the INSERT example had the form of a do{...}while() loop. The Delete instruction fills the role that the callback function did in the preceding examples.</source>
          <target state="translated">这个循环进行实际的删除工作。它的组织结构与UPDATE例子中的循环不同。ListRead指令扮演了Next在INSERT循环中的角色,但是因为它在失败时跳转到P2,而Next在成功时跳转,所以我们把它放在循环的开始而不是结束。这就意味着我们必须在循环的最后放一个Goto,才能跳回开头的循环测试。所以这个循环的形式是C while(){...}循环,而insert例子中的循环的形式是do{...}while()循环。删除指令填补了前面例子中回调函数的作用。</target>
        </trans-unit>
        <trans-unit id="43be1340da3a9e761d1e60e5b0cf2fe23b219f5a" translate="yes" xml:space="preserve">
          <source>This macro determines if SQLite creates databases with the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; flag set by default to OFF (0), FULL (1), or INCREMENTAL (2). The default value is 0 meaning that databases are created with auto-vacuum turned off. In any case the compile-time default may be overridden by the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA auto_vacuum&lt;/a&gt; command.</source>
          <target state="translated">此宏确定SQLite是否创建默认情况下将&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;标志设置为OFF（0），FULL（1）或INCREMENTAL（2）的数据库。默认值为0，表示在关闭自动真空的情况下创建数据库。在任何情况下，&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA auto_vacuum&lt;/a&gt;命令都可以覆盖编译时默认值。</target>
        </trans-unit>
        <trans-unit id="ce1cd413cb1e6bc64251da855027734d62907557" translate="yes" xml:space="preserve">
          <source>This macro determines the default value for the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema&lt;/a&gt; setting. If no alternative is specified, the trusted-schema setting defaults to ON (a value of 1) for legacy compatibility. However, for best security, systems that implement &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; and/or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; should consider changing the default to OFF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="490e529c008d3db9d5367e44a026855e51e6b03f" translate="yes" xml:space="preserve">
          <source>This macro determines the default value of the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting for database files that open in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. If not overridden at compile-time, this value is the same as &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt;.</source>
          <target state="translated">该宏为在&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;打开的数据库文件确定&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt;设置的默认值。如果在编译时未覆盖，则此值与&lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="8336b743e8d9803a85ebb0e91376530edf711cf6" translate="yes" xml:space="preserve">
          <source>This macro determines the default value of the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting. If not overridden at compile-time, the default setting is 2 (FULL).</source>
          <target state="translated">此宏确定&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt;设置的默认值。如果在编译时未覆盖，则默认设置为2（FULL）。</target>
        </trans-unit>
        <trans-unit id="f58f286fe549400b3ffb2a0508013420e777661c" translate="yes" xml:space="preserve">
          <source>This macro determines the default values for &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsddl&quot;&gt;SQLITE_DBCONFIG_DQS_DDL&lt;/a&gt; and &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsdml&quot;&gt;SQLITE_DBCONFIG_DQS_DML&lt;/a&gt;, which in turn how SQLite handles each &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt;. The &quot;DQS&quot; name stands for &quot;&lt;u&gt;D&lt;/u&gt;ouble-&lt;u&gt;Q&lt;/u&gt;uoted &lt;u&gt;S&lt;/u&gt;tring&quot;. The</source>
          <target state="translated">该宏确定&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsddl&quot;&gt;SQLITE_DBCONFIG_DQS_DDL&lt;/a&gt;和&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsdml&quot;&gt;SQLITE_DBCONFIG_DQS_DML&lt;/a&gt;的默认值，这又是SQLite处理每个&lt;a href=&quot;quirks#dblquote&quot;&gt;双引号字符串文字的方式&lt;/a&gt;。在&amp;ldquo;DQS&amp;rdquo;的名字代表&amp;ldquo; &lt;u&gt;d&lt;/u&gt; ouble- &lt;u&gt;Q&lt;/u&gt; uoted &lt;u&gt;小号&lt;/u&gt;特林&amp;rdquo;。的</target>
        </trans-unit>
        <trans-unit id="522e09ca43264c4a7b51fc0648da718f31a48474" translate="yes" xml:space="preserve">
          <source>This macro determines the initial setting for &lt;a href=&quot;pragma#pragma_automatic_index&quot;&gt;PRAGMA automatic_index&lt;/a&gt; for newly opened &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;. For all versions of SQLite through 3.7.17, automatic indices are normally enabled for new database connections if this compile-time option is omitted. However, that might change in future releases of SQLite.</source>
          <target state="translated">该宏为新打开的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;确定&lt;a href=&quot;pragma#pragma_automatic_index&quot;&gt;PRAGMA automatic_index&lt;/a&gt;的初始设置。对于SQLite 3.7.17之前的所有版本，如果省略了编译时选项，通常都会为新的数据库连接启用自动索引。但是，这可能会在将来的SQLite版本中发生变化。</target>
        </trans-unit>
        <trans-unit id="5fa0389d41296c7a84b787e330c502e72d66ebe7" translate="yes" xml:space="preserve">
          <source>This macro determines the number of pages initially allocated by the page cache module when &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; configuration option is not use and memory for the page cache is obtained from &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; instead. The number of pages set by this macro are allocated in a single allocation, which reduces the load on the memory allocator.</source>
          <target state="translated">当不使用&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;配置选项并且从&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;获取用于页面高速缓存的内存时，此宏确定页面高速缓存模块最初分配的页面数。该宏设置的页面数在单个分配中分配，这减少了内存分配器上的负载。</target>
        </trans-unit>
        <trans-unit id="559bc66ac71c6e41021ef2b91f75b46c2b3b9325" translate="yes" xml:space="preserve">
          <source>This macro determines whether enforcement of &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; is enabled or disabled by default for new database connections. Each database connection can always turn enforcement of foreign key constraints on and off and run-time using the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;foreign_keys pragma&lt;/a&gt;. Enforcement of foreign key constraints is normally off by default, but if this compile-time parameter is set to 1, enforcement of foreign key constraints will be on by default.</source>
          <target state="translated">该宏确定默认情况下对新数据库连接是启用还是禁用&lt;a href=&quot;foreignkeys&quot;&gt;外键约束的&lt;/a&gt;实施。每个数据库连接都可以使用&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;foreign_keys pragma&lt;/a&gt;始终打开和关闭外键约束以及在运行时强制实施。通常，默认情况下，外键约束的实施通常是关闭的，但是如果将此编译时参数设置为1，则默认情况下，外键约束的实施将是启用的。</target>
        </trans-unit>
        <trans-unit id="226608496184b7fdf2d8299d14ed30387d3f4541" translate="yes" xml:space="preserve">
          <source>This macro identifies an externally visible interface for SQLite. This macro is sometimes set to &quot;extern&quot;. But the definition is compiler-specific.</source>
          <target state="translated">这个宏标识SQLite的外部可见接口。这个宏有时被设置为 &quot;extern&quot;。但是这个定义是针对编译器的。</target>
        </trans-unit>
        <trans-unit id="0de6453c343098370301ec003932dc6266aca99a" translate="yes" xml:space="preserve">
          <source>This macro identifies the calling convention used by operating system interfaces for target the platform for an SQLite build. This macro is normally defined to be nothing, though on Windows builds it can sometimes be set to &quot;__stdcall&quot;.</source>
          <target state="translated">这个宏标识了操作系统接口对SQLite构建的目标平台所使用的调用约定。这个宏通常被定义为 &quot;无&quot;,不过在Windows构建中,它有时会被设置为&quot;__stdcall&quot;。</target>
        </trans-unit>
        <trans-unit id="9b44c726a2553acb75e5ed795a28d472290ceb29" translate="yes" xml:space="preserve">
          <source>This macro identifies the calling convention used by public interface routines in SQLite. This macro is normally defined to be nothing, though on Windows builds it can sometimes be set to &quot;__cdecl&quot; or &quot;__stdcall&quot;. The &quot;__cdecl&quot; setting is the default, but &quot;__stdcall&quot; is used when SQLite is intended to be compiled as a Windows system library.</source>
          <target state="translated">这个宏标识了SQLite中公共接口例程的调用惯例。这个宏通常被定义为 &quot;无&quot;,尽管在Windows的构建中,它有时会被设置为&quot;__cdecl &quot;或&quot;__stdcall&quot;。&quot;__cdecl &quot;的设置是默认的,但是当SQLite打算被编译成Windows系统库时,会使用&quot;__stdcall&quot;。</target>
        </trans-unit>
        <trans-unit id="b1a94429c7fe64a39ff03aac291075f1fc53f3f7" translate="yes" xml:space="preserve">
          <source>This macro is used to determine whether or not the features enabled and disabled using the SQLITE_CONFIG_MEMSTATUS argument to &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; are available by default. The default value is 1 (&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; related features enabled).</source>
          <target state="translated">此宏用于确定默认情况下使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;的SQLITE_CONFIG_MEMSTATUS参数启用和禁用的功能是否可用。默认值为1（启用了&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;相关功能）。</target>
        </trans-unit>
        <trans-unit id="6f913dad07b84381374f393818e5b17603014056" translate="yes" xml:space="preserve">
          <source>This macro is used to omit support for UTF16 text encoding. When this is defined all API functions that return or accept UTF16 encoded text are unavailable. These functions can be identified by the fact that they end with '16', for example &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_text16()&lt;/a&gt; and &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_text16()&lt;/a&gt;.</source>
          <target state="translated">此宏用于省略对UTF16文本编码的支持。定义此属性后，返回或接受UTF16编码文本的所有API函数均不可用。这些函数可以通过以'16'结尾的事实来标识，例如&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16（）&lt;/a&gt;，&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_text16（）&lt;/a&gt;和&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_text16（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="345c1823c22673f2e2116c52a9629c25f967676c" translate="yes" xml:space="preserve">
          <source>This macro is used to set the default page-size used when a database is created. The value assigned must be a power of 2. The default value is 4096. The compile-time default may be overridden at runtime by the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; command.</source>
          <target state="translated">此宏用于设置创建数据库时使用的默认页面大小。分配的值必须为2的幂。默认值为4096。在运行时，&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt;命令可以覆盖编译时的默认值。</target>
        </trans-unit>
        <trans-unit id="7c4d127d6e65cd3ab45a035f901ed93fb97bfdbf" translate="yes" xml:space="preserve">
          <source>This macro may not be used in combination with any of &lt;a href=&quot;compile#apicall&quot;&gt;SQLITE_APICALL&lt;/a&gt;, &lt;a href=&quot;compile#callback&quot;&gt;SQLITE_CALLBACK&lt;/a&gt;, &lt;a href=&quot;compile#cdecl&quot;&gt;SQLITE_CDECL&lt;/a&gt;, or &lt;a href=&quot;compile#syscall&quot;&gt;SQLITE_SYSCALL&lt;/a&gt;.</source>
          <target state="translated">此宏不得与&lt;a href=&quot;compile#apicall&quot;&gt;SQLITE_APICALL&lt;/a&gt;，&lt;a href=&quot;compile#callback&quot;&gt;SQLITE_CALLBACK&lt;/a&gt;，&lt;a href=&quot;compile#cdecl&quot;&gt;SQLITE_CDECL&lt;/a&gt;或&lt;a href=&quot;compile#syscall&quot;&gt;SQLITE_SYSCALL结合使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="419ea570d98b36b74bab8426d78c04933a0304df" translate="yes" xml:space="preserve">
          <source>This macro sets a hard upper bound on the amount of address space that can be used by any single database for memory-mapped I/O. Setting this value to 0 completely disables memory-mapped I/O and causes logic associated with memory-mapped I/O to be omitted from the build. This option does change the default memory-mapped I/O address space size (set by &lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt; or sqlite3_config(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;) or the run-time memory-mapped I/O address space size (set by sqlite3_file_control(&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt;) or &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;) as long as those other settings are less than the maximum value defined here.</source>
          <target state="translated">此宏为任何单个数据库可用于内存映射I / O的地址空间量设置了硬上限。将此值设置为0将完全禁用内存映射的I / O，并使与内存映射的I / O相关的逻辑从构建中省略。此选项确实改变默认的存储器映射I / O地址空间的大小（设置由&lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt;或sqlite3_config（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;）或运行时间存储器映射I / O地址空间的大小（一套由sqlite3_file_control（&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt;）或&lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;）作为只要其他设置小于此处定义的最大值。</target>
        </trans-unit>
        <trans-unit id="145e78ac1776ccd32943f854f10f2f9b0fb6393c" translate="yes" xml:space="preserve">
          <source>This macro sets the default limit on the amount of memory that will be used for memory-mapped I/O for each open database file. If the</source>
          <target state="translated">这个宏设置了每个打开的数据库文件用于内存映射I/O的内存量的默认限制。如果</target>
        </trans-unit>
        <trans-unit id="6ae2df8a2127ec82caea89871c84ffb977c2588f" translate="yes" xml:space="preserve">
          <source>This macro sets the default maximum size of the page-cache for each attached database. A positive value means that the limit is N page. If N is negative that means to limit the cache size to -N*1024 bytes. The suggested maximum cache size can be overridden by the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; command. The default value is -2000, which translates into a maximum of 2048000 bytes per cache.</source>
          <target state="translated">该宏为每个连接的数据库设置页面高速缓存的默认最大大小。正值表示限制为N页。如果N为负，则意味着将缓存大小限制为-N * 1024字节。建议的最大高速缓存大小可以被&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt;命令覆盖。缺省值为-2000，这表示每个高速缓存最多可转换2048000字节。</target>
        </trans-unit>
        <trans-unit id="069102b338eefceeca656d056762e6d78be6422a" translate="yes" xml:space="preserve">
          <source>This macro sets the default page count for the &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;&lt;a href=&quot;wal#ckpt&quot;&gt;automatic checkpointing&lt;/a&gt; feature. If unspecified, the default page count is 1000.</source>
          <target state="translated">此宏设置&lt;a href=&quot;wal&quot;&gt;WAL &lt;/a&gt;&lt;a href=&quot;wal#ckpt&quot;&gt;自动检查点&lt;/a&gt;功能的默认页数。如果未指定，则默认页数为1000。</target>
        </trans-unit>
        <trans-unit id="40e8768dd2f7f8b92849cd1662a4c1ca65d4e334" translate="yes" xml:space="preserve">
          <source>This macro sets the default value for the &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt; parameter. The &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt; parameter sets the maximum number of auxiliary threads that a single &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; will launch to assist it with a query. If not specified, the default maximum is 0. The value set here cannot be more than &lt;a href=&quot;compile#max_worker_threads&quot;&gt;SQLITE_MAX_WORKER_THREADS&lt;/a&gt;.</source>
          <target state="translated">此宏设置&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt;参数的默认值。该&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt;参数设置一个辅助线程的最大数量&lt;a href=&quot;c3ref/stmt&quot;&gt;准备的语句&lt;/a&gt;将推出与查询，以帮助它。如果未指定，则默认最大值为0。此处设置的值不能超过&lt;a href=&quot;compile#max_worker_threads&quot;&gt;SQLITE_MAX_WORKER_THREADS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f1a3a8e3c666c19a28c715230f239e6dc92f408" translate="yes" xml:space="preserve">
          <source>This macro sets the maximum depth of the LALR(1) stack used by the SQL parser within SQLite. The default value is 100. A typical application will use less than about 20 levels of the stack. Developers whose applications contain SQL statements that need more than 100 LALR(1) stack entries should seriously consider refactoring their SQL as it is likely to be well beyond the ability of any human to comprehend.</source>
          <target state="translated">这个宏设置SQLite中SQL解析器使用的LALR(1)栈的最大深度。默认值是100。一个典型的应用程序将使用少于约20层的堆栈。如果开发人员的应用程序包含的SQL语句需要超过100个LALR(1)堆栈条目,应该认真考虑重构他们的SQL,因为它很可能远远超出任何人类的理解能力。</target>
        </trans-unit>
        <trans-unit id="8108e74c0ea6d892451dd561e6365c3c14ad84ce" translate="yes" xml:space="preserve">
          <source>This macro sets the maximum depth of the search tree that corresponds to the right-hand side of the MATCH operator in an &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; or &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; full-text index. The full-text search uses a recursive algorithm, so the depth of the tree is limited to prevent using too much stack space. The default limit is 12. This limit is sufficient for up to 4095 search terms on the right-hand side of the MATCH operator and it holds stack space usage to less than 2000 bytes.</source>
          <target state="translated">此宏设置&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;或&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;全文索引中与MATCH运算符右侧相对应的搜索树的最大深度。全文搜索使用递归算法，因此限制了树的深度，以防止使用过多的堆栈空间。默认限制为12。此限制足以匹配MATCH运算符右侧的4095个搜索词，并且它使堆栈空间使用量少于2000个字节。</target>
        </trans-unit>
        <trans-unit id="3f15f1a968a26e30aa2768ccc2b2f950c4faa629" translate="yes" xml:space="preserve">
          <source>This macro specifies the calling convention used by callback pointers in SQLite. This macro is normally defined to be nothing, though on Windows builds it can sometimes be set to &quot;__cdecl&quot; or &quot;__stdcall&quot;. The &quot;__cdecl&quot; setting is the default, but &quot;__stdcall&quot; is used when SQLite is intended to be compiled as a Windows system library.</source>
          <target state="translated">这个宏指定了SQLite中回调指针的调用约定。这个宏通常被定义为 &quot;无&quot;,尽管在Windows的构建中,它有时会被设置为&quot;__cdecl &quot;或&quot;__stdcall&quot;。&quot;__cdecl &quot;的设置是默认的,但是当SQLite打算被编译成Windows系统库时,会使用&quot;__stdcall&quot;。</target>
        </trans-unit>
        <trans-unit id="2528260ddde8472dd8957f56284dfe7c74c79aa8" translate="yes" xml:space="preserve">
          <source>This macro specifies the calling convention used by the &lt;a href=&quot;http://www.tcl.tk&quot;&gt;TCL&lt;/a&gt; library interface routines. This macro is not used by the SQLite core, but only by the &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; and &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt;. This macro is normally defined to be nothing, though on Windows builds it can sometimes be set to &quot;__cdecl&quot;. This macro is used on TCL library interface routines which are always compiled as __cdecl, even on platforms that prefer to use __stdcall, so this macro should not be set to __stdcall unless the platform as a custom TCL library build that supports __stdcall.</source>
          <target state="translated">该宏指定&lt;a href=&quot;http://www.tcl.tk&quot;&gt;TCL&lt;/a&gt;库接口例程使用的调用约定。 SQLite核心不使用此宏，而&lt;a href=&quot;tclsqlite&quot;&gt;TCL接口&lt;/a&gt;和&lt;a href=&quot;testing#tcl&quot;&gt;TCL测试套件&lt;/a&gt;仅使用此宏。尽管在Windows构建中，有时可以将其设置为&amp;ldquo; __cdecl&amp;rdquo;，但通常将其定义为空。即使在更喜欢使用__stdcall的平台上，该宏也用于始终编译为__cdecl的TCL库接口例程中，因此，除非该平台作为支持__stdcall的自定义TCL库构建平台，否则不应将此宏设置为__stdcall。</target>
        </trans-unit>
        <trans-unit id="bc472ae5f8b8a1fc9f763f0953cf89d622ce1417" translate="yes" xml:space="preserve">
          <source>This macro specifies the calling convention used by varargs interface routines in SQLite. This macro is normally defined to be nothing, though on Windows builds it can sometimes be set to &quot;__cdecl&quot;. This macro is used on varargs routines and so cannot be set to &quot;__stdcall&quot; since the __stdcall calling convention does not support varargs functions.</source>
          <target state="translated">这个宏指定了SQLite中varargs接口例程的调用约定。这个宏通常被定义为 &quot;无&quot;,尽管在Windows的构建中,它有时可以被设置为&quot;__cdecl&quot;。这个宏用于varargs例程,所以不能设置为&quot;__stdcall&quot;,因为__stdcall调用约定不支持varargs函数。</target>
        </trans-unit>
        <trans-unit id="bc36de796d91df2f3c6874f4468e8054d8e3ac3e" translate="yes" xml:space="preserve">
          <source>This major version number X was historically incremented only for large and important changes to the code. What constituted &quot;large and important&quot; was subjective. The 3.6.23 to 3.7.0 change was a result of adding support for &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. The 3.7.17 to 3.8.0 change was a result of rewrite known as the &lt;a href=&quot;queryplanner-ng&quot;&gt;next generation query planner&lt;/a&gt;.</source>
          <target state="translated">从历史上看，主要版本号X仅在对代码进行大而重要的更改时才递增。构成&amp;ldquo;大而重要&amp;rdquo;的是主观的。从3.6.23到3.7.0的更改是添加了对&lt;a href=&quot;wal&quot;&gt;WAL模式的&lt;/a&gt;支持的结果。从3.7.17到3.8.0的更改是重写的结果，被称为&lt;a href=&quot;queryplanner-ng&quot;&gt;下一代查询计划程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5cef14b3410c92f823704c7230a809d3f5116354" translate="yes" xml:space="preserve">
          <source>This may conflict with a remote UPDATE or DELETE. If it conflicts with a DELETE, and the conflict resolution was OMIT, then the update is changed into an INSERT. Any undefined values in the new.* record from the update change are filled in using the old.* values from the conflicting DELETE. Or, if the conflict resolution was REPLACE, the UPDATE change is simply omitted from the rebased changeset.</source>
          <target state="translated">这可能与远程的UPDATE或DELETE冲突。如果它与DELETE冲突,并且冲突的解决方式是OMIT,那么更新就会被改为INSERT。任何来自更新更改的new.*记录中的未定义值都会使用冲突的DELETE中的old.*值来填充。或者,如果冲突的解决方式是REPLACE,那么UPDATE更改就会从重新建立的更改集中被简单地省略掉。</target>
        </trans-unit>
        <trans-unit id="250cc754fd71fa455b1171906aaea6df74adc895" translate="yes" xml:space="preserve">
          <source>This may conflict with a remote UPDATE or DELETE. In both cases the only possible resolution is OMIT. If the remote operation was a DELETE, then add no change to the rebased changeset. If the remote operation was an UPDATE, then the old.* fields of change are updated to reflect the new.* values in the UPDATE.</source>
          <target state="translated">这可能与远程UPDATE或DELETE冲突。在这两种情况下,唯一可能的解决方法是OMIT。如果远程操作是DELETE,那么就不添加任何变化到重新建立的变化集。如果远程操作是UPDATE,那么改变的旧.*字段将被更新以反映UPDATE中的新.*值。</target>
        </trans-unit>
        <trans-unit id="8d5037a58507a3656fe5eded6e14400ea7347e50" translate="yes" xml:space="preserve">
          <source>This may only conflict with a remote INSERT. If the conflict resolution was OMIT, then add an UPDATE change to the rebased changeset. Or, if the conflict resolution was REPLACE, add nothing to the rebased changeset.</source>
          <target state="translated">这可能只与远程INSERT冲突。如果冲突的解决方法是OMIT,那么就在重新建立的变更集中添加一个UPDATE变更。或者,如果冲突的解决方法是REPLACE,那么就不给重新建立的变更集添加任何内容。</target>
        </trans-unit>
        <trans-unit id="e86988ffb57c2ce2d0a24b3ed45d3fc0cd35e72c" translate="yes" xml:space="preserve">
          <source>This means that SQLite transactions are not atomic across multiple database files on a power-loss when the database files have synchronous turned off or when they are using journal modes of OFF, MEMORY, or WAL. For synchronous OFF and for journal_modes OFF and MEMORY, database will usually corrupt if a transaction commit is interrupted by a power loss. For &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, individual database files are updated atomically across a power-loss, but in the case of a multi-file transactions, some files might rollback while others roll forward after power is restored.</source>
          <target state="translated">这意味着当数据库文件已同步关闭或使用OFF，MEMORY或WAL日志模式时，断电时多个数据库文件之间的SQLite事务不是原子的。对于同步OFF以及对于journal_modes OFF和MEMORY，如果断电中断事务提交，则数据库通常会损坏。对于&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;，单个数据库文件会在断电时自动更新，但是在多文件事务的情况下，某些文件可能会回滚，而其他文件在恢复电源后会回滚。</target>
        </trans-unit>
        <trans-unit id="c4d263eb72d44481bc6aecfbc23e6defa0aa1498" translate="yes" xml:space="preserve">
          <source>This means that actions that occur during sqlite3_prepare() are unaffected by EXPLAIN.</source>
          <target state="translated">这意味着在sqlite3_prepare()期间发生的操作不会受到EXPLAIN的影响。</target>
        </trans-unit>
        <trans-unit id="607b25be39beb5f9bef58cd8962c20567dd55554" translate="yes" xml:space="preserve">
          <source>This means that for many common cases where the temporary tables and indices are small (small enough to fit into the page cache) no temporary files are created and no disk I/O occurs. Only when the temporary data becomes too large to fit in RAM does the information spill to disk.</source>
          <target state="translated">这意味着对于许多常见的情况,临时表和索引很小(小到可以放入页面缓存),不会创建临时文件,也不会发生磁盘I/O。只有当临时数据变得太大而无法放入RAM时,信息才会溢出到磁盘。</target>
        </trans-unit>
        <trans-unit id="593fad237e8d234622c2a00c4634885f5c48bfa8" translate="yes" xml:space="preserve">
          <source>This means that if the changes() SQL function (or similar) is used by the first INSERT, UPDATE or DELETE statement within a trigger, it returns the value as set when the calling statement began executing. If it is used by the second or subsequent such statement within a trigger program, the value returned reflects the number of rows modified by the previous INSERT, UPDATE or DELETE statement within the same trigger.</source>
          <target state="translated">这意味着,如果一个触发器中的第一个INSERT、UPDATE或DELETE语句使用了changes()SQL函数(或类似的函数),那么它将返回调用语句开始执行时设置的值。如果它被触发器程序中的第二条或后续的此类语句使用,那么返回的值反映了同一触发器中被前一条INSERT、UPDATE或DELETE语句修改的行数。</target>
        </trans-unit>
        <trans-unit id="47de8d4e850286135f1da838b319021d7542c6e4" translate="yes" xml:space="preserve">
          <source>This means that in order to keep an FTS in sync with an external content table, any UPDATE or DELETE operations must be applied first to the FTS table, and then to the external content table. For example:</source>
          <target state="translated">这意味着,为了使FTS与外部内容表保持同步,任何UPDATE或DELETE操作必须首先应用于FTS表,然后应用于外部内容表。例如</target>
        </trans-unit>
        <trans-unit id="e5987b4f32ba7f13fcab7f6d474b93f549e8b5dd" translate="yes" xml:space="preserve">
          <source>This means that you should always call sqlite3_column_bytes() or sqlite3_column_bytes16() &lt;u&gt;before&lt;/u&gt; calling sqlite3_column_blob(), sqlite3_column_text(), or sqlite3_column_text16().</source>
          <target state="translated">这意味着您应始终&lt;u&gt;在&lt;/u&gt;调用sqlite3_column_blob（），sqlite3_column_text（）或sqlite3_column_text16（）&lt;u&gt;之前&lt;/u&gt;调用sqlite3_column_bytes（）或sqlite3_column_bytes16（）。</target>
        </trans-unit>
        <trans-unit id="a800932549bc1585500113c923ee38830d5bf518" translate="yes" xml:space="preserve">
          <source>This means, amongst other things, that if a row is inserted and then later deleted while a session object is active, neither the insert nor the delete will be present in the changeset. Or if a row is deleted and then later a row with the same primary key values inserted while a session object is active, the resulting changeset will contain an UPDATE change instead of a DELETE and an INSERT.</source>
          <target state="translated">这意味着,除其他外,如果一条记录被插入,然后在会话对象处于活动状态时被删除,那么插入和删除都不会出现在变化集中。或者说,如果一条记录被删除,然后在会话对象处于活动状态时插入了一条具有相同主键值的记录,那么所产生的变化集将包含UPDATE变化,而不是DELETE和INSERT。</target>
        </trans-unit>
        <trans-unit id="a00a0b75d114c0d51218afdcfc54870beb085cdd" translate="yes" xml:space="preserve">
          <source>This method begins a search of a virtual table. The first argument is a cursor opened by &lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt;. The next two arguments define a particular search index previously chosen by &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;. The specific meanings of idxNum and idxStr are unimportant as long as xFilter and xBestIndex agree on what that meaning is.</source>
          <target state="translated">此方法开始搜索虚拟表。第一个参数是&lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt;打开的游标。接下来的两个参数定义先前由&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;选择的特定搜索索引。只要xFilter和xBestIndex同意什么含义，idxNum和idxStr的具体含义就不重要了。</target>
        </trans-unit>
        <trans-unit id="834bb1ed541ae4dfe20c9142ebec2a570acf7ecb" translate="yes" xml:space="preserve">
          <source>This method begins a transaction on a virtual table. This is method is optional. The xBegin pointer of &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; may be NULL.</source>
          <target state="translated">此方法在虚拟表上开始事务。这是可选方法。&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt;的xBegin指针可以为NULL。</target>
        </trans-unit>
        <trans-unit id="a08aaa3a7033e43137865bcb5ae5a8fbc061274b" translate="yes" xml:space="preserve">
          <source>This method causes a virtual table transaction to commit. This is method is optional. The xCommit pointer of &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; may be NULL.</source>
          <target state="translated">此方法导致虚拟表事务提交。这是可选方法。&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt;的xCommit指针可以为NULL。</target>
        </trans-unit>
        <trans-unit id="35812c6906eecb5f5456d27817929132fa134b1e" translate="yes" xml:space="preserve">
          <source>This method causes a virtual table transaction to rollback. This is method is optional. The xRollback pointer of &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; may be NULL.</source>
          <target state="translated">此方法导致虚拟表事务回滚。这是可选方法。&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt;的xRollback指针可以为NULL。</target>
        </trans-unit>
        <trans-unit id="34e410d7a2b4537f1e469f9ac830727f0e9a19a0" translate="yes" xml:space="preserve">
          <source>This method is a destructor for a connection to the virtual table. Contrast this method with &lt;a href=&quot;vtab#sqlite3_module.xDestroy&quot;&gt;xDestroy&lt;/a&gt;. The xDestroy is a destructor for the entire virtual table.</source>
          <target state="translated">此方法是与虚拟表的连接的析构函数。将此方法与&lt;a href=&quot;vtab#sqlite3_module.xDestroy&quot;&gt;xDestroy进行&lt;/a&gt;对比。xDestroy是整个虚拟表的析构函数。</target>
        </trans-unit>
        <trans-unit id="fead0fa710dfed08f0c2973066d106e0409882fe" translate="yes" xml:space="preserve">
          <source>This method is always followed by one call to either the &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; or &lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt; method. Virtual table transactions do not nest, so the xBegin method will not be invoked more than once on a single virtual table without an intervening call to either &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; or &lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt;. Multiple calls to other methods can and likely will occur in between the xBegin and the corresponding &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; or &lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt;.</source>
          <target state="translated">始终在此方法之后是对&lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt;或&lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt;方法的一次调用。虚拟表事务不会嵌套，因此在没有对&lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt;或&lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt;进行中间调用的情况下，不会在单个虚拟表上多次调用xBegin方法。在xBegin与对应的&lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt;或&lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt;之间可能会发生对其他方法的多次调用。</target>
        </trans-unit>
        <trans-unit id="83c5d6a9d04d0fa8516ae7c5f17b40f6d4c8afec" translate="yes" xml:space="preserve">
          <source>This method is called during &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; to give the virtual table implementation an opportunity to overload functions. This method may be set to NULL in which case no overloading occurs.</source>
          <target state="translated">在&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;期间调用此方法，以使虚拟表实现有机会重载函数。在没有过载的情况下，可以将此方法设置为NULL。</target>
        </trans-unit>
        <trans-unit id="905580614d4d5c3d75c09c6cba74a2febc0c6255" translate="yes" xml:space="preserve">
          <source>This method is only invoked after call to the &lt;a href=&quot;vtab#xBegin&quot;&gt;xBegin&lt;/a&gt; method and prior to an &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; or &lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt;. In order to implement two-phase commit, the xSync method on all virtual tables is invoked prior to invoking the &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; method on any virtual table. If any of the xSync methods fail, the entire transaction is rolled back.</source>
          <target state="translated">仅在调用&lt;a href=&quot;vtab#xBegin&quot;&gt;xBegin&lt;/a&gt;方法之后，在&lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt;或&lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt;之前调用此方法。为了实现两阶段提交，在调用任何虚拟表上的&lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt;方法之前，将在所有虚拟表上调用xSync方法。如果任何xSync方法失败，则会回滚整个事务。</target>
        </trans-unit>
        <trans-unit id="14ef93018d8fba942c0db9f44fa55460f6e9c76d" translate="yes" xml:space="preserve">
          <source>This method is only required window aggregate functions, not legacy aggregate function implementations. It is invoked to remove a row from the current window. The function arguments, if any, correspond to the row being removed.</source>
          <target state="translated">这个方法只需要窗口聚合函数,而不是传统的聚合函数实现。它被调用来从当前窗口中删除一条记录。函数参数(如果有)与被删除的行相对应。</target>
        </trans-unit>
        <trans-unit id="ce08d539ea8ee34ede5a43f0a8a17d5ea1cf7eda" translate="yes" xml:space="preserve">
          <source>This method is only required window aggregate functions, not legacy aggregate function implementations. It is invoked to return the current value of the aggregate. Unlike xFinal, the implementation should not delete any context.</source>
          <target state="translated">这个方法只需要窗口聚合函数,而不是传统的聚合函数实现。它被调用来返回集合的当前值。与xFinal不同的是,该方法的实现不应该删除任何上下文。</target>
        </trans-unit>
        <trans-unit id="08d8cbadac9e2ea26500ba730130d1d2ea25cffc" translate="yes" xml:space="preserve">
          <source>This method is required by both window aggregate and legacy aggregate function implementations. It is invoked to add a row to the current window. The function arguments, if any, corresponding to the row being added are passed to the implementation of xStep.</source>
          <target state="translated">窗口聚合和传统的聚合函数实现都需要这个方法。它被调用来添加一条记录到当前窗口中。函数参数,如果有的话,对应于被添加的行的参数被传递给xStep的实现。</target>
        </trans-unit>
        <trans-unit id="9dd3404779d40aa0e18784dd6025c6e495214062" translate="yes" xml:space="preserve">
          <source>This method is required by both window aggregate and legacy aggregate function implementations. It is invoked to return the current value of the aggregate (determined by the contents of the current window), and to free any resources allocated by earlier calls to xStep.</source>
          <target state="translated">这个方法是窗口聚合和传统聚合函数实现所需要的,它被调用来返回聚合的当前值(由当前窗口的内容决定),并释放之前调用xStep所分配的任何资源。它被调用来返回集合的当前值(由当前窗口的内容决定),并释放之前调用xStep分配的任何资源。</target>
        </trans-unit>
        <trans-unit id="7eac31ed05b29ccf070b56974e9ebd5c94362b9d" translate="yes" xml:space="preserve">
          <source>This method is used to profile the execution of SQL statements run by the application. The syntax is as follows:</source>
          <target state="translated">该方法用于对应用程序运行的SQL语句的执行情况进行描述。语法如下。</target>
        </trans-unit>
        <trans-unit id="9ee8409951c2f3bc2e8906346a5b0b0340e5f814" translate="yes" xml:space="preserve">
          <source>This method maps to the &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; C/C++ interface.</source>
          <target state="translated">此方法映射到&lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）&lt;/a&gt; C / C ++接口。</target>
        </trans-unit>
        <trans-unit id="225a540a3967cae27a759b7346927a4c3dd4b89d" translate="yes" xml:space="preserve">
          <source>This method might decide to run a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; either itself or as a subsequent idle callback. Note that SQLite only allows a single WAL hook. By default this single WAL hook is used for the auto-checkpointing. If you set up an explicit WAL hook, then that one WAL hook must ensure that checkpoints are occurring since the auto-checkpointing mechanism will be disabled.</source>
          <target state="translated">此方法可能决定运行&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;本身还是作为后续的空闲回调。请注意，SQLite仅允许单个WAL挂钩。默认情况下，此单个WAL挂钩用于自动检查点。如果设置了显式WAL挂钩，则该WAL挂钩必须确保发生检查点，因为将禁用自动检查点机制。</target>
        </trans-unit>
        <trans-unit id="eb481b19911bf534590dc3a5ac3a0d7a4a0b626e" translate="yes" xml:space="preserve">
          <source>This method must release all resources allocated by the corresponding xOpen call. The routine will not be called again even if it returns an error. The SQLite core will not use the &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; again after it has been closed.</source>
          <target state="translated">此方法必须释放由相应的xOpen调用分配的所有资源。该例程即使返回错误也不会再次被调用。关闭后，SQLite核心将不再使用&lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="055d0207ea9526f8fc1f47ff97e4b9e575a536d0" translate="yes" xml:space="preserve">
          <source>This method must return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if successful, or an sqlite &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if an error occurs.</source>
          <target state="translated">如果成功，此方法必须返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK；&lt;/a&gt;如果发生&lt;a href=&quot;rescode&quot;&gt;错误&lt;/a&gt;，则必须返回sqlite 错误代码。</target>
        </trans-unit>
        <trans-unit id="b41b86554f48d4aba1d771ee8d8fecba032486ca" translate="yes" xml:space="preserve">
          <source>This method only functions if SQLite is compiled with -DSQLITE_ENABLE_DESERIALIZE</source>
          <target state="translated">只有当SQLite编译时使用-DSQLITE_ENABLE_DESERIALIZE时,本方法才会发挥作用。</target>
        </trans-unit>
        <trans-unit id="aca26a9b3273f84c2f90b69b02bbfb9f22a90825" translate="yes" xml:space="preserve">
          <source>This method opens a TCL channel that can be used to read or write into a preexisting BLOB in the database. The syntax is like this:</source>
          <target state="translated">这个方法打开了一个TCL通道,可以用来读取或写入数据库中预先存在的BLOB。语法是这样的。</target>
        </trans-unit>
        <trans-unit id="a7939d2d993e49eddf1cab2881c4166045801fa6" translate="yes" xml:space="preserve">
          <source>This method provides notification that the virtual table implementation that the virtual table will be given a new name. If this method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; then SQLite renames the table. If this method returns an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; then the renaming is prevented.</source>
          <target state="translated">此方法提供通知，通知虚拟表实现将为虚拟表赋予新名称。如果此方法返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK，&lt;/a&gt;则SQLite重命名表。如果此方法返回&lt;a href=&quot;rescode&quot;&gt;错误代码，&lt;/a&gt;则将阻止重命名。</target>
        </trans-unit>
        <trans-unit id="a08efc90f97c033c6f3a136a45c2a7cd6eb3f466" translate="yes" xml:space="preserve">
          <source>This method registers a callback routine that is invoked after transaction commit when the database is in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. Two arguments are appended to the callback command before it is invoked:</source>
          <target state="translated">此方法注册一个回调例程，当数据库处于&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;时，该例程在事务提交后调用。在调用之前，将两个参数附加到回调命令中：</target>
        </trans-unit>
        <trans-unit id="2920f36d10d056ba3578501d280b4d02be0b6e1d" translate="yes" xml:space="preserve">
          <source>This method registers a callback routine that is invoked just before SQLite tries to commit changes to a database. If the callback throws an exception or returns a non-zero result, then the transaction rolls back rather than commit.</source>
          <target state="translated">这个方法注册了一个回调例程,它在SQLite试图提交数据库的变化之前被调用。如果回调抛出一个异常或返回一个非零的结果,那么事务就会回滚而不是提交。</target>
        </trans-unit>
        <trans-unit id="20062984ae0be47aefc8270221280e0e79c3fbe2" translate="yes" xml:space="preserve">
          <source>This method registers a callback routine that is invoked just before SQLite tries to do a rollback. The script argument is run without change.</source>
          <target state="translated">这个方法注册了一个回调例程,在SQLite尝试进行回滚之前被调用。脚本参数在运行时不做任何改变。</target>
        </trans-unit>
        <trans-unit id="b68fa7e92d08c038d817ec9f0f1dc21053a80d3a" translate="yes" xml:space="preserve">
          <source>This method registers a callback routine that is invoked just before each row is modified by an UPDATE, INSERT, or DELETE statement. Four arguments are appended to the callback before it is invoked:</source>
          <target state="translated">这个方法注册了一个回调例程,这个例程在每条记录被UPDATE、INSERT或DELETE语句修改之前被调用。在调用之前,有四个参数被附加到回调程序中。</target>
        </trans-unit>
        <trans-unit id="1de39dc4601511299a305e0af9ade7a304a3c689" translate="yes" xml:space="preserve">
          <source>This method registers a callback routine that is invoked when the SQLite engine needs a particular collating sequence but does not have that collating sequence registered. The callback can register the collating sequence. The callback is invoked with a single parameter which is the name of the needed collating sequence.</source>
          <target state="translated">这个方法注册了一个回调例程,当SQLite引擎需要一个特定的整理序列但没有注册该整理序列时,就会调用这个回调例程。回调可以注册整理序列。回调调用的参数只有一个,就是需要的整理序列的名称。</target>
        </trans-unit>
        <trans-unit id="21ae789dba180ad8c87b4a2a750db64d49f46fa8" translate="yes" xml:space="preserve">
          <source>This method registers a callback that is invoked periodically during query processing. There are two arguments: the number of SQLite virtual machine opcodes between invocations, and the TCL command to invoke. Setting the progress callback to an empty string disables it.</source>
          <target state="translated">这个方法注册一个回调,在查询处理过程中定期调用。有两个参数:调用之间的SQLite虚拟机操作码数,以及要调用的TCL命令。将进度回调设置为空字符串会使其失效。</target>
        </trans-unit>
        <trans-unit id="2dc944f8c7fefbfebd13fd137f3e37227d9d5fa9" translate="yes" xml:space="preserve">
          <source>This method registers new text collating sequences. There are two arguments: the name of the collating sequence and the name of a TCL procedure that implements a comparison function for the collating sequence.</source>
          <target state="translated">这个方法注册新的文本整理序列。有两个参数:整理序列的名称和实现整理序列比较函数的TCL存储过程的名称。</target>
        </trans-unit>
        <trans-unit id="e6fd7472db353bf284142fd5894eee70bc3b8bf2" translate="yes" xml:space="preserve">
          <source>This method releases a connection to a virtual table, just like the &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; method, and it also destroys the underlying table implementation. This method undoes the work of &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;.</source>
          <target state="translated">就像&lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt;方法一样，此方法释放与虚拟表的连接，并且还会破坏基础表的实现。此方法撤消&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;的工作。</target>
        </trans-unit>
        <trans-unit id="ef832304ea34e78e50a8e321fbc11fd1e9032c28" translate="yes" xml:space="preserve">
          <source>This method releases a connection to a virtual table. Only the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object is destroyed. The virtual table is not destroyed and any backing store associated with the virtual table persists. This method undoes the work of &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;.</source>
          <target state="translated">此方法释放到虚拟表的连接。仅&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;对象被破坏。虚拟表不会被销毁，与该虚拟表关联的任何后备存储都将保留。此方法&lt;a href=&quot;vtab#xconnect&quot;&gt;取消xConnect&lt;/a&gt;的工作。</target>
        </trans-unit>
        <trans-unit id="4227ff89f6190deba008640864f1fdb82c90a383" translate="yes" xml:space="preserve">
          <source>This method returns status information from the most recently evaluated SQL statement. The status method takes a single argument which should be either &quot;steps&quot; or &quot;sorts&quot;. If the argument is &quot;steps&quot;, then the method returns the number of full table scan steps that the previous SQL statement evaluated. If the argument is &quot;sorts&quot;, the method returns the number of sort operations. This information can be used to detect queries that are not using indices to speed search or sorting.</source>
          <target state="translated">这个方法返回最近一次评估的SQL语句的状态信息。状态方法需要一个参数,这个参数应该是 &quot;步骤 &quot;或 &quot;排序&quot;。如果参数是 &quot;步骤&quot;,那么方法返回前一条SQL语句所评估的全表扫描步骤数。如果参数是 &quot;sorts&quot;,则该方法返回排序操作的次数。这些信息可以用来检测没有使用索引来加速搜索或排序的查询。</target>
        </trans-unit>
        <trans-unit id="8fc50ec02b1fc52936f33c145dd76c2dbb1165ca" translate="yes" xml:space="preserve">
          <source>This method returns the numeric error code that resulted from the most recent SQLite operation.</source>
          <target state="translated">此方法返回最近一次SQLite操作产生的数字错误代码。</target>
        </trans-unit>
        <trans-unit id="f84b852e58521bbbf0fe6bd6ba3aaa76874ffba2" translate="yes" xml:space="preserve">
          <source>This method should return an integer value that is equivalent to an SQLite error code (usually 0 for SQLITE_OK in the case of success or 1 for SQLITE_ERROR if some error occurs). As in &lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt;, the results of returning an integer that does not correspond to an SQLite error code are undefined. If the value returned by the script cannot be interpreted as an integer value, or if the script throws a Tcl exception, no error is returned to SQLite but a Tcl background-error is raised.</source>
          <target state="translated">此方法应返回一个等于SQLite错误代码的整数值（如果成功，则对于SQLITE_OK通常为0；如果发生某些错误，则对于SQLITE_ERROR通常为1）。与&lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook（）中一样&lt;/a&gt;，返回与SQLite错误代码不对应的整数的结果是不确定的。如果脚本返回的值不能解释为整数值，或者脚本抛出Tcl异常，则不会向SQLite返回任何错误，但会引发Tcl背景错误。</target>
        </trans-unit>
        <trans-unit id="69d817508f731b9a1bddece3df659e773b266409" translate="yes" xml:space="preserve">
          <source>This method signals the start of a two-phase commit on a virtual table. This is method is optional. The xSync pointer of &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; may be NULL.</source>
          <target state="translated">此方法表示在虚拟表上开始两阶段提交。这是可选方法。&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt;的xSync指针可以为NULL。</target>
        </trans-unit>
        <trans-unit id="1be99db4c515118ac04440359b90544a681fa330" translate="yes" xml:space="preserve">
          <source>This method takes a single boolean argument which will turn the extension loading functionality on or off.</source>
          <target state="translated">这个方法需要一个布尔参数,它将开启或关闭扩展加载功能。</target>
        </trans-unit>
        <trans-unit id="6c561fc9f9d18e98c0c786b020b147ec37c718e8" translate="yes" xml:space="preserve">
          <source>This misfeature means that a misspelled double-quoted identifier will be interpreted as a string literal, rather than generating an error. It also lures developers who are new to the SQL language into the bad habit of using double-quoted string literals when they really need to learn to use the correct single-quoted string literal form.</source>
          <target state="translated">这个错误特性意味着拼写错误的双引号标识符将被解释为字符串文字,而不是产生错误。它还会诱使刚接触SQL语言的开发人员养成使用双引号字符串文字的坏习惯,而他们确实需要学习使用正确的单引号字符串文字形式。</target>
        </trans-unit>
        <trans-unit id="a7d7620eee00f67af5794e95b53ed251b900cca6" translate="yes" xml:space="preserve">
          <source>This mode blocks (invokes the &lt;a href=&quot;c3ref/busy_handler&quot;&gt;busy-handler callback&lt;/a&gt;) until there is no database writer and all readers are reading from the most recent database snapshot. It then checkpoints all frames in the log file and syncs the database file. FULL blocks concurrent writers while it is running, but readers can proceed.</source>
          <target state="translated">此模式将阻塞（调用&lt;a href=&quot;c3ref/busy_handler&quot;&gt;busy-handler回调&lt;/a&gt;），直到没有数据库写入器并且所有读取器都从最新的数据库快照读取数据为止。然后，它在日志文件中检查所有帧并同步数据库文件。FULL在运行时阻止并发写入器，但读取器可以继续。</target>
        </trans-unit>
        <trans-unit id="d4d4de2de6eaf1fc63ccde7eca3a1fd81c8366c2" translate="yes" xml:space="preserve">
          <source>This mode blocks (it invokes the &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler callback&lt;/a&gt;) until there is no database writer and all readers are reading from the most recent database snapshot. It then checkpoints all frames in the log file and syncs the database file. This mode blocks new database writers while it is pending, but new database readers are allowed to continue unimpeded.</source>
          <target state="translated">此模式将阻塞（它调用&lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler回调&lt;/a&gt;），直到没有数据库写入器并且所有读取器都从最近的数据库快照读取数据为止。然后，它在日志文件中检查所有帧并同步数据库文件。此模式在挂起时会阻止新的数据库编写器，但允许新的数据库编写器不受阻碍地继续运行。</target>
        </trans-unit>
        <trans-unit id="3cc26aa0e4889928aaca415a8d70e942682adf13" translate="yes" xml:space="preserve">
          <source>This mode blocks (it invokes the &lt;a href=&quot;busy_handler&quot;&gt;busy-handler callback&lt;/a&gt;) until there is no database writer and all readers are reading from the most recent database snapshot. It then checkpoints all frames in the log file and syncs the database file. This mode blocks new database writers while it is pending, but new database readers are allowed to continue unimpeded.</source>
          <target state="translated">此模式将阻塞（它调用&lt;a href=&quot;busy_handler&quot;&gt;busy-handler回调&lt;/a&gt;），直到没有数据库写入器并且所有读取器都从最近的数据库快照读取数据为止。然后，它在日志文件中检查所有帧并同步数据库文件。此模式在挂起时会阻止新的数据库编写器，但允许新的数据库编写器不受阻碍地继续运行。</target>
        </trans-unit>
        <trans-unit id="3564356c049b3cc19954e75da9c3a3e14807a420" translate="yes" xml:space="preserve">
          <source>This mode works the same way as FULL with the addition that after checkpointing the log file it blocks (calls the &lt;a href=&quot;c3ref/busy_handler&quot;&gt;busy-handler callback&lt;/a&gt;) until all readers are finished with the log file. This ensures that the next client to write to the database file restarts the log file from the beginning. RESTART blocks concurrent writers while it is running, but allowed readers to proceed.</source>
          <target state="translated">此模式的功能与FULL相同，不同之处在于，在对日志文件进行检查点之后，它将阻塞（调用&lt;a href=&quot;c3ref/busy_handler&quot;&gt;busy-handler回调&lt;/a&gt;），直到所有读取器都完成了日志文件为止。这样可以确保下一个要写入数据库文件的客户端从头开始重新启动日志文件。RESTART在运行时阻止并发写入器，但允许读取器继续进行。</target>
        </trans-unit>
        <trans-unit id="1fb881e2173a556242d04296f314a6e802d8d176" translate="yes" xml:space="preserve">
          <source>This mode works the same way as RESTART with the addition that the WAL file is truncated to zero bytes upon successful completion.</source>
          <target state="translated">该模式的工作方式与RESTART相同,但在成功完成后,WAL文件将被截断为零字节。</target>
        </trans-unit>
        <trans-unit id="94e1a681e057e0efd19e4f8568beb354e5ca747a" translate="yes" xml:space="preserve">
          <source>This mode works the same way as SQLITE_CHECKPOINT_FULL with the addition that after checkpointing the log file it blocks (calls the &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler callback&lt;/a&gt;) until all readers are reading from the database file only. This ensures that the next writer will restart the log file from the beginning. Like SQLITE_CHECKPOINT_FULL, this mode blocks new database writer attempts while it is pending, but does not impede readers.</source>
          <target state="translated">此模式的工作方式与SQLITE_CHECKPOINT_FULL相同，不同之处在于，在对日志文件进行检查点之后，该模式将阻塞（调用&lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler回调&lt;/a&gt;），直到所有读取器仅从数据库文件读取为止。这样可以确保下一个编写器从头开始重新启动日志文件。与SQLITE_CHECKPOINT_FULL一样，此模式在挂起时会阻止新的数据库编写器尝试，但不会阻止读取器。</target>
        </trans-unit>
        <trans-unit id="2565fbfb38de6ccb4881d6d5b4ff9625664b3e35" translate="yes" xml:space="preserve">
          <source>This mode works the same way as SQLITE_CHECKPOINT_FULL with the addition that after checkpointing the log file it blocks (calls the &lt;a href=&quot;busy_handler&quot;&gt;busy-handler callback&lt;/a&gt;) until all readers are reading from the database file only. This ensures that the next writer will restart the log file from the beginning. Like SQLITE_CHECKPOINT_FULL, this mode blocks new database writer attempts while it is pending, but does not impede readers.</source>
          <target state="translated">此模式的工作方式与SQLITE_CHECKPOINT_FULL相同，不同之处在于，在对日志文件进行检查点之后，该模式将阻塞（调用&lt;a href=&quot;busy_handler&quot;&gt;busy-handler回调&lt;/a&gt;），直到所有读取器仅从数据库文件读取为止。这样可以确保下一个编写器从头开始重新启动日志文件。与SQLITE_CHECKPOINT_FULL一样，此模式在挂起时会阻止新的数据库编写器尝试，但不会阻止读取器。</target>
        </trans-unit>
        <trans-unit id="6553148329df03707f6ea6e001cc2a449f7036e8" translate="yes" xml:space="preserve">
          <source>This mode works the same way as SQLITE_CHECKPOINT_RESTART with the addition that it also truncates the log file to zero bytes just prior to a successful return.</source>
          <target state="translated">该模式的工作方式与SQLITE_CHECKPOINT_RESTART相同,只是在成功返回之前,它还将日志文件截断为零字节。</target>
        </trans-unit>
        <trans-unit id="5e17d751b95d394b7ad8a49ae12b1ba579b3059a" translate="yes" xml:space="preserve">
          <source>This new index can be used to implement a faster algorithm for the original &quot;Price of Peaches&quot; query.</source>
          <target state="translated">这个新的索引可以用来实现原来 &quot;桃子的价格 &quot;查询的更快算法。</target>
        </trans-unit>
        <trans-unit id="f7c2f3e95925f0342ad3f077f1f083b0da69c5fe" translate="yes" xml:space="preserve">
          <source>This new index contains all the columns of the original FruitsForSale table that are used by the query - both the search terms and the output. We call this a &quot;covering index&quot;. Because all of the information needed is in the covering index, SQLite never needs to consult the original table in order to find the price.</source>
          <target state="translated">这个新的索引包含了原始FruitsForSale表的所有列,这些列被查询使用--包括搜索词和输出。我们将其称为 &quot;覆盖索引&quot;。因为所有需要的信息都在覆盖索引中,所以SQLite永远不需要为了查找价格而查阅原表。</target>
        </trans-unit>
        <trans-unit id="acf43845a5ea53f1f00ff4c11a6f5e1b8a8b33d3" translate="yes" xml:space="preserve">
          <source>This next query solves a Sudoku puzzle. The state of the puzzle is defined by an 81-character string formed by reading entries from the puzzle box row by row from left to right and then from top to bottom. Blank squares in the puzzle are denoted by a &quot;.&quot; character. Thus the input string:</source>
          <target state="translated">下一个查询解决了一个数独谜题。谜题的状态由一个81个字符组成的字符串来定义,这个字符串是从谜题框中从左到右,再从上到下逐行读取条目。空格用&quot;.&quot;字符表示。因此,输入的字符串。</target>
        </trans-unit>
        <trans-unit id="68714059b3f9385751b77bf5e71ea40721ded156" translate="yes" xml:space="preserve">
          <source>This object is used in only one place in the SQLite interface. A pointer to an instance of this object is the argument to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; when the configuration option is &lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; or &lt;a href=&quot;#sqliteconfiggetmalloc&quot;&gt;SQLITE_CONFIG_GETMALLOC&lt;/a&gt;. By creating an instance of this object and passing it to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;) during configuration, an application can specify an alternative memory allocation subsystem for SQLite to use for all of its dynamic memory needs.</source>
          <target state="translated">该对象仅在SQLite界面的一个位置使用。当配置选项为&lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;或&lt;a href=&quot;#sqliteconfiggetmalloc&quot;&gt;SQLITE_CONFIG_GETMALLOC&lt;/a&gt;时，指向此对象实例的指针是&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;的参数。通过在配置过程中创建此对象的实例并将其传递给&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;），应用程序可以为SQLite指定备用内存分配子系统，以用于其所有动态内存需求。</target>
        </trans-unit>
        <trans-unit id="3560b833b5836cc3d10c63801ce7146372dee16e" translate="yes" xml:space="preserve">
          <source>This object is used in only one place in the SQLite interface. A pointer to an instance of this object is the argument to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; when the configuration option is &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; or &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiggetmalloc&quot;&gt;SQLITE_CONFIG_GETMALLOC&lt;/a&gt;. By creating an instance of this object and passing it to &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;) during configuration, an application can specify an alternative memory allocation subsystem for SQLite to use for all of its dynamic memory needs.</source>
          <target state="translated">该对象仅在SQLite界面的一个位置使用。当配置选项为&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;或&lt;a href=&quot;c_config_covering_index_scan#sqliteconfiggetmalloc&quot;&gt;SQLITE_CONFIG_GETMALLOC&lt;/a&gt;时，指向此对象实例的指针是&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;的参数。通过在配置过程中创建此对象的实例并将其传递给&lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;），应用程序可以为SQLite指定备用内存分配子系统，以用于其所有动态内存需求。</target>
        </trans-unit>
        <trans-unit id="1882a6d3fc0a0bded1e433917173d1858c24f074" translate="yes" xml:space="preserve">
          <source>This only works when compiled with &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;.</source>
          <target state="translated">这仅在使用&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;编译时有效。</target>
        </trans-unit>
        <trans-unit id="cfa6d4acc676d7ac09e89de67c072931e0df8cd6" translate="yes" xml:space="preserve">
          <source>This opcode (which only exists if SQLite was compiled with SQLITE_ENABLE_COLUMN_USED_MASK) identifies which columns of the table or index for cursor P1 are used. P4 is a 64-bit integer (P4_INT64) in which the first 63 bits are one for each of the first 63 columns of the table or index that are actually used by the cursor. The high-order bit is set if any column after the 64th is used.</source>
          <target state="translated">这个操作码(只有在SQLite编译时使用了SQLITE_ENABLE_COLUMN_USED_MASK时才会存在)用于标识游标P1使用了表或索引的哪些列。P4是一个64位的整数(P4_INT64),其中前63位为游标实际使用的表或索引的前63列的1位。如果第64列之后的任何一列被使用,则设置高阶位。</target>
        </trans-unit>
        <trans-unit id="b79886bbc08237ffaab5449ea6dabdf7a84bb8eb" translate="yes" xml:space="preserve">
          <source>This opcode behaves like &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; if the seekHit flag is clear and it behaves like &lt;a href=&quot;opcode#Noop&quot;&gt;Noop&lt;/a&gt; if the seekHit flag is set.</source>
          <target state="translated">如果将seekHit标志清除，则此操作码的行为类似于&lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound；&lt;/a&gt;如果将seekHit标志设置为1，则其行为类似于&lt;a href=&quot;opcode#Noop&quot;&gt;Noop&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e04269abd438fa3b7333edfe660e9856975a5dd0" translate="yes" xml:space="preserve">
          <source>This opcode does exactly the same thing as &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; except that it increments an undocumented global variable used for testing.</source>
          <target state="translated">该操作码的作用与&lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt;完全相同，只是它增加了用于测试的未记录的全局变量。</target>
        </trans-unit>
        <trans-unit id="c8090fac6edb839ad1f5d93ed66a4501d0732691" translate="yes" xml:space="preserve">
          <source>This opcode implements the IS TRUE, IS FALSE, IS NOT TRUE, and IS NOT FALSE operators.</source>
          <target state="translated">这个操作码实现了IS TRUE、IS FALSE、IS NOT TRUE和IS NOT FALSE运算符。</target>
        </trans-unit>
        <trans-unit id="80195a95c1d144667fff82486976a6e1af2d3b57" translate="yes" xml:space="preserve">
          <source>This opcode invokes the parser to create a new virtual machine, then runs the new virtual machine. It is thus a re-entrant opcode.</source>
          <target state="translated">这个操作码调用解析器来创建一个新的虚拟机,然后运行新的虚拟机。因此它是一个重入操作码。</target>
        </trans-unit>
        <trans-unit id="d5ae7a9a55b8c3387be81c142b3c731709ff4fb8" translate="yes" xml:space="preserve">
          <source>This opcode invokes the xFilter method on the virtual table specified by P1. The integer query plan parameter to xFilter is stored in register P3. Register P3+1 stores the argc parameter to be passed to the xFilter method. Registers P3+2..P3+1+argc are the argc additional parameters which are passed to xFilter as argv. Register P3+2 becomes argv[0] when passed to xFilter.</source>
          <target state="translated">这个操作码在P1指定的虚拟表上调用xFilter方法。xFilter的整数查询计划参数被存储在寄存器P3中,寄存器P3+1存储了要传递给xFilter方法的参数。寄存器P3+1存储了要传递给xFilter方法的argc参数。寄存器P3+2...P3+1+argc是作为argv传递给xFilter的附加参数。寄存器P3+2在传递给xFilter时成为argv[0]。</target>
        </trans-unit>
        <trans-unit id="b4696388c2a5ea95b129447ae7160a304f284c78" translate="yes" xml:space="preserve">
          <source>This opcode is an alias for &lt;a href=&quot;opcode#Sort&quot;&gt;Sort&lt;/a&gt; and &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; that is used for Sorter objects.</source>
          <target state="translated">此操作码是用于Sorter对象的&lt;a href=&quot;opcode#Sort&quot;&gt;Sort&lt;/a&gt; and &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="2cd5c8a03dccaa1c2e173dfb77000d3f09963ffe" translate="yes" xml:space="preserve">
          <source>This opcode is initially coded as OP_AggStep0. On first evaluation, the FuncDef stored in P4 is converted into an sqlite3_context and the opcode is changed. In this way, the initialization of the sqlite3_context only happens once, instead of on each call to the step function.</source>
          <target state="translated">这个操作码最初被编码为OP_AggStep0。在第一次评估时,存储在P4中的FuncDef被转换为sqlite3_context,并且改变了操作码。这样,sqlite3_context的初始化只发生一次,而不是在每次调用步骤函数时。</target>
        </trans-unit>
        <trans-unit id="ccd042d8c20621b0ba115fbd962b688a465b7a1e" translate="yes" xml:space="preserve">
          <source>This opcode is normally use to move a record out of the sorter and into a register that is the source for a pseudo-table cursor created using &lt;a href=&quot;opcode#OpenPseudo&quot;&gt;OpenPseudo&lt;/a&gt;. That pseudo-table cursor is the one that is identified by parameter P3. Clearing the P3 column cache as part of this opcode saves us from having to issue a separate &lt;a href=&quot;opcode#NullRow&quot;&gt;NullRow&lt;/a&gt; instruction to clear that cache.</source>
          <target state="translated">此操作码通常用于将记录移出排序器，并移入寄存器，该寄存器是使用&lt;a href=&quot;opcode#OpenPseudo&quot;&gt;OpenPseudo&lt;/a&gt;创建的伪表游标的源。该伪表游标是由参数P3标识的那个。清除P3列缓存作为此操作码的一部分，使我们不必再发出单独的&lt;a href=&quot;opcode#NullRow&quot;&gt;NullRow&lt;/a&gt;指令来清除该缓存。</target>
        </trans-unit>
        <trans-unit id="f368e74bed9bf6036c173d5ffc843879779adc0f" translate="yes" xml:space="preserve">
          <source>This opcode is only available if SQLite is compiled with the -DSQLITE_ENABLE_OFFSET_SQL_FUNC option.</source>
          <target state="translated">这个操作码只有在SQLite编译时使用-DSQLITE_ENABLE_OFFSET_SQL_FUNC选项时才可用。</target>
        </trans-unit>
        <trans-unit id="cc6bc217f526f9cd459391c67d3dce0bbbb0723f" translate="yes" xml:space="preserve">
          <source>This opcode is only available in testing and debugging builds. It is not generated for release builds. The purpose of this opcode is to help validate the generated bytecode. This opcode does not actually contribute to computing an answer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd0c6b395f56420b6f36502ce5f6e4b927e5a5c" translate="yes" xml:space="preserve">
          <source>This opcode is only ever present in sub-programs called via the &lt;a href=&quot;opcode#Program&quot;&gt;Program&lt;/a&gt; instruction. &lt;a href=&quot;opcode#Copy&quot;&gt;Copy&lt;/a&gt; a value currently stored in a memory cell of the calling (parent) frame to cell P2 in the current frames address space. This is used by trigger programs to access the new.* and old.* values.</source>
          <target state="translated">该操作码仅在通过&lt;a href=&quot;opcode#Program&quot;&gt;程序&lt;/a&gt;指令调用的子程序中存在。&lt;a href=&quot;opcode#Copy&quot;&gt;将&lt;/a&gt;当前存储在调用（父）帧的存储单元中的值复制到当前帧地址空间中的单元P2。触发程序使用它来访问new。*和old。*值。</target>
        </trans-unit>
        <trans-unit id="1edae59fc3236745f7fbf501252bcea75f5db5b9" translate="yes" xml:space="preserve">
          <source>This opcode is similar to &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; with the exceptions that the branch is always taken if any part of the search key input is NULL.</source>
          <target state="translated">此操作码与&lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt;相似，不同之处在于，如果搜索键输入的任何部分为NULL，则始终采用该分支。</target>
        </trans-unit>
        <trans-unit id="1074ea1e6510853bdec71ac78b6a534ca6039b57" translate="yes" xml:space="preserve">
          <source>This opcode is used in IN clause processing for a multi-column key. If an IN clause is attached to an element of the key other than the left-most element, and if there are no matches on the most recent seek over the whole key, then it might be that one of the key element to the left is prohibiting a match, and hence there is &quot;no hope&quot; of any match regardless of how many IN clause elements are checked. In such a case, we abandon the IN clause search early, using this opcode. The opcode name comes from the fact that the jump is taken if there is &quot;no hope&quot; of achieving a match.</source>
          <target state="translated">这个操作码用于多列键的IN子句处理。如果一个IN子句附加在键的最左边元素以外的元素上,如果最近一次在整个键上的搜索没有匹配,那么可能是左边的一个键元素禁止匹配,因此无论检查多少个IN子句元素,都 &quot;没有希望 &quot;有任何匹配。在这种情况下,我们提前放弃IN子句搜索,使用这个操作码。这个操作码的名字来自于如果 &quot;没有希望 &quot;实现匹配,就会进行跳转。</target>
        </trans-unit>
        <trans-unit id="8a560c644b1064348d0d21a9885c9e73f72f185e" translate="yes" xml:space="preserve">
          <source>This opcode is used to implement the integrity_check pragma.</source>
          <target state="translated">这个操作码用于实现完整性检查原则。</target>
        </trans-unit>
        <trans-unit id="36b9014a68a8fcf60471eef29422a00680109ffb" translate="yes" xml:space="preserve">
          <source>This opcode is used when extracting information from a column that has REAL affinity. Such column values may still be stored as integers, for space efficiency, but after extraction we want them to have only a real value.</source>
          <target state="translated">这个操作码用于从具有REAL亲和力的列中提取信息。为了节省空间,这样的列值仍然可以以整数的形式存储,但是在提取之后我们希望它们只有一个实值。</target>
        </trans-unit>
        <trans-unit id="cfa4b2533ec63a8dec1bee2b7cfac77ec376defc" translate="yes" xml:space="preserve">
          <source>This opcode leaves the cursor configured to move in forward order, from the beginning toward the end. In other words, the cursor is configured to use &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;, not &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;.</source>
          <target state="translated">此操作码使光标配置为从头到尾向前移动。换句话说，将光标配置为使用&lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;而不是&lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9db9421c1851bc92812d2d99ea83270abb9a3281" translate="yes" xml:space="preserve">
          <source>This opcode leaves the cursor configured to move in reverse order, from the end toward the beginning. In other words, the cursor is configured to use &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;, not &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;.</source>
          <target state="translated">此操作码使光标配置为从末尾到开头以相反的顺序移动。换句话说，将光标配置为使用&lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;，而不是&lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f2f0cd72e4c85aa3ba21b6915cd7acce5e5760e8" translate="yes" xml:space="preserve">
          <source>This opcode leaves the cursor in a state where it cannot be advanced in either direction. In other words, the &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; and &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; opcodes will not work following this opcode.</source>
          <target state="translated">此操作码使光标处于无法向任一方向前进的状态。换句话说，&lt;a href=&quot;opcode#Next&quot;&gt;下一个&lt;/a&gt;和上&lt;a href=&quot;opcode#Prev&quot;&gt;一个&lt;/a&gt;操作码在该操作码之后将不起作用。</target>
        </trans-unit>
        <trans-unit id="e0f99ac32670b6df2ff48dc1552c8225ad687653" translate="yes" xml:space="preserve">
          <source>This opcode must follow an &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; or &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; comparison operator. There can be zero or more OP_ReleaseReg opcodes intervening, but no other opcodes are allowed to occur between this instruction and the previous &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; or &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt;. Furthermore, the prior &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; or &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; must have the SQLITE_STOREP2 bit set in the P5 field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6db8b6773ccb389e7a96c1d48f5077207b71453" translate="yes" xml:space="preserve">
          <source>This opcode must immediately follow an &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; or &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; comparison operator. If result of an &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; comparison on the same two operands would have be NULL or false (0), then then jump to P2. If the result of an &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; comparison on the two previous operands would have been true (1), then fall through.</source>
          <target state="translated">此操作码必须立即跟随&lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt;或&lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt;比较运算符。如果对相同两个操作数进行&lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt;比较的结果为NULL或false（0），则跳至P2。如果对前两个操作数进行&lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt;比较的结果为true（1），则失败。</target>
        </trans-unit>
        <trans-unit id="fe62ed3995127b50711c091c796c38839099f405" translate="yes" xml:space="preserve">
          <source>This opcode only works for cursors used for sorting and opened with &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt; or &lt;a href=&quot;opcode#SorterOpen&quot;&gt;SorterOpen&lt;/a&gt;.</source>
          <target state="translated">此操作码仅适用于用于排序并使用&lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt;或&lt;a href=&quot;opcode#SorterOpen&quot;&gt;SorterOpen&lt;/a&gt;打开的游标。</target>
        </trans-unit>
        <trans-unit id="0a5cf188d3f8f57c9bc976279d8b9451f3af100d" translate="yes" xml:space="preserve">
          <source>This opcode performs a commonly used computation associated with LIMIT and OFFSET process. r[P1] holds the limit counter. r[P3] holds the offset counter. The opcode computes the combined value of the LIMIT and OFFSET and stores that value in r[P2]. The r[P2] value computed is the total number of rows that will need to be visited in order to complete the query.</source>
          <target state="translated">r[P1]存放限位计数器,r[P3]存放偏移计数器。该操作码计算LIMIT和OFFSET的组合值,并将该值存储在r[P2]中。计算出的r[P2]值就是为了完成查询而需要访问的总行数。</target>
        </trans-unit>
        <trans-unit id="5c774d8b575a72465fcca20f5e30c011a493a27a" translate="yes" xml:space="preserve">
          <source>This opcode tests if a foreign key constraint-counter is currently zero. If so, jump to instruction P2. Otherwise, fall through to the next instruction.</source>
          <target state="translated">该操作码测试外键约束-计数器当前是否为零。如果是,则跳转到指令P2。否则,跳转到下一条指令。</target>
        </trans-unit>
        <trans-unit id="546c52afd639a2ac1b1f0294a0fa0ff8fad9df32" translate="yes" xml:space="preserve">
          <source>This opcode throws an error if there are any active reader VMs when it is invoked. This is done to avoid the difficulty associated with updating existing cursors when a root page is moved in an AUTOVACUUM database. This error is thrown even if the database is not an AUTOVACUUM db in order to avoid introducing an incompatibility between autovacuum and non-autovacuum modes.</source>
          <target state="translated">当调用该操作码时,如果有任何活动的阅读器虚拟机,该操作码会抛出一个错误。这样做是为了避免在AUTOVACUUM数据库中移动根页面时更新现有的游标所带来的困难。即使数据库不是AUTOVACUUM数据库,也会抛出这个错误,以避免在自动真空和非自动真空模式之间引入不兼容。</target>
        </trans-unit>
        <trans-unit id="52667b3b8e58f7e2254dc2c69756775349787b29" translate="yes" xml:space="preserve">
          <source>This opcode works exactly like &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt;. The only difference is in its name. This opcode is used in places where the function must be purely non-deterministic. Some built-in date/time functions can be either determinitic of non-deterministic, depending on their arguments. When those function are used in a non-deterministic way, they will check to see if they were called using &lt;a href=&quot;opcode#PureFunc&quot;&gt;PureFunc&lt;/a&gt; instead of &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt;, and if they were, they throw an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="480cdfb81d03d4678699e7e229cd926e397be01a" translate="yes" xml:space="preserve">
          <source>This opcode works just like &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; except that P1 must be a sorter object for which the &lt;a href=&quot;opcode#SorterSort&quot;&gt;SorterSort&lt;/a&gt; opcode has been invoked. This opcode advances the cursor to the next sorted record, or jumps to P2 if there are no more sorted records.</source>
          <target state="translated">该操作码与&lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;一样工作，除了P1必须是已为其调用&lt;a href=&quot;opcode#SorterSort&quot;&gt;SorterSort&lt;/a&gt;操作码的排序器对象。此操作码使光标前进到下一个已排序的记录，如果没有更多已排序的记录，则跳转到P2。</target>
        </trans-unit>
        <trans-unit id="8c41d39eeb147c07c8acc288aca8d67aa65d5265" translate="yes" xml:space="preserve">
          <source>This opcode works like &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt; except that it opens a transient index that is specifically designed to sort large tables using an external merge-sort algorithm.</source>
          <target state="translated">该操作码的工作方式与&lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral相似，&lt;/a&gt;不同之处在于它打开了一个临时索引，该索引专门设计用于使用外部合并排序算法对大型表进行排序。</target>
        </trans-unit>
        <trans-unit id="1bd026a84c4b134c052fab965e0298249387c523" translate="yes" xml:space="preserve">
          <source>This opcode works the same as &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt;. It has a different name to distinguish its use. Tables created using by this opcode will be used for automatically created transient indices in joins.</source>
          <target state="translated">此操作码的作用与&lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt;相同。它具有不同的名称以区分其用途。使用此操作码创建的表将用于联接中自动创建的瞬态索引。</target>
        </trans-unit>
        <trans-unit id="aea3e0eadc6549a98e3f2a226a78969a9d9be0e4" translate="yes" xml:space="preserve">
          <source>This operation leaves the cursor in a state where it can be advanced in the forward direction. The &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; instruction will work, but not the &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; instruction.</source>
          <target state="translated">该操作使光标处于可以向前移动的状态。在&lt;a href=&quot;opcode#Next&quot;&gt;接下来&lt;/a&gt;的指令将工作，但不是&lt;a href=&quot;opcode#Prev&quot;&gt;上一个&lt;/a&gt;指令。</target>
        </trans-unit>
        <trans-unit id="674899f070471e538d8c615be60bc1cbfc82c6f5" translate="yes" xml:space="preserve">
          <source>This operation leaves the cursor in a state where it cannot be advanced in either direction. In other words, the &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; and &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; opcodes do not work after this operation.</source>
          <target state="translated">此操作使光标处于无法向任一方向前进的状态。换句话说，&lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;和&lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;操作码在此操作后不起作用。</target>
        </trans-unit>
        <trans-unit id="692e5e8e72323f3828134ed084c67a8aae1f6191" translate="yes" xml:space="preserve">
          <source>This option activates an optimization that reduces the memory required by the sorter at the cost of doing additional B-tree lookups after the sort has occurred.</source>
          <target state="translated">此选项可激活优化,减少分拣机所需的内存,但代价是在分拣后进行额外的 B 树查找。</target>
        </trans-unit>
        <trans-unit id="e1b53eed6630caef9cfd2ca35ff19d694b6cd8e9" translate="yes" xml:space="preserve">
          <source>This option adds additional logic to the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command and to the &lt;a href=&quot;optoverview&quot;&gt;query planner&lt;/a&gt; that can help SQLite to chose a better query plan under certain situations. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command is enhanced to collect histogram data from all columns of every index and store that data in the &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; table. The query planner will then use the histogram data to help it make better index choices. The downside of this compile-time option is that it violates the &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;query planner stability guarantee&lt;/a&gt; making it more difficult to ensure consistent performance in mass-produced applications.</source>
          <target state="translated">此选项在&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令和&lt;a href=&quot;optoverview&quot;&gt;查询计划程序&lt;/a&gt;中添加了其他逻辑，可以帮助SQLite在某些情况下选择更好的查询计划。该&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令是从每一个索引的所有列和存储增强收集直方图数据，在数据&lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;表。然后，查询计划者将使用直方图数据来帮助它做出更好的索引选择。此编译时选项的缺点是，它违反了&lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;查询计划程序的稳定性保证&lt;/a&gt;，因此很难确保在批量生产的应用程序中保持一致的性能。</target>
        </trans-unit>
        <trans-unit id="d6209f0377358c783d1190518295961bb9d4da90" translate="yes" xml:space="preserve">
          <source>This option adds extra logic to SQLite that allows it to release unused memory upon request. This option must be enabled in order for the &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface to work. If this compile-time option is not used, the &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface is a no-op.</source>
          <target state="translated">此选项向SQLite添加了额外的逻辑，使其可以根据请求释放未使用的内存。为了启用&lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory（）&lt;/a&gt;接口，必须启用此选项。如果不使用此编译时选项，则&lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory（）&lt;/a&gt;接口为空操作。</target>
        </trans-unit>
        <trans-unit id="939f1a447a21a0874443461aacf8890bd098e69f" translate="yes" xml:space="preserve">
          <source>This option adds extra logic to SQLite that inserts comment text into the output of &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;. These extra comments use extra memory, thus making &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; larger and very slightly slower, and so they are turned off by default and in most application. But some applications, such as the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; for SQLite, value clarity of EXPLAIN output over raw performance and so this compile-time option is available to them. The SQLITE_ENABLE_EXPLAIN_COMMENTS compile-time option is also enabled automatically if &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; is enabled.</source>
          <target state="translated">此选项向SQLite添加了额外的逻辑，该逻辑将注释文本插入&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;的输出中。这些额外的注释会占用额外的内存，从而使&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;变大且变慢，因此默认情况下会在大多数应用程序中将其关闭。但是某些应用程序（例如SQLite 的&lt;a href=&quot;cli&quot;&gt;命令行外壳）相&lt;/a&gt;对于原始性能重视EXPLAIN输出的清晰度，因此，他们可以使用此编译时选项。如果启用了&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG，&lt;/a&gt;还将自动启用SQLITE_ENABLE_EXPLAIN_COMMENTS编译时选项。</target>
        </trans-unit>
        <trans-unit id="4c48faf6b414235fea882e17a937347af8cad6d7" translate="yes" xml:space="preserve">
          <source>This option builds SQLite without support for shared-cache mode. The &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; is omitted along with a fair amount of logic within the B-Tree subsystem associated with shared cache management.</source>
          <target state="translated">此选项将构建不支持共享缓存模式的SQLite。所述&lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）&lt;/a&gt;与逻辑的与共享高速缓存管理相关的B树子系统内相当数量省略沿。</target>
        </trans-unit>
        <trans-unit id="b993563b54a3e7e57504381c57f5844eff0c8f71" translate="yes" xml:space="preserve">
          <source>This option builds a version of the SQLite library that contains no Writable Static Data (WSD). WSD is global variables and/or static variables. Some platforms do not support WSD, and this option is necessary in order for SQLite to work those platforms.</source>
          <target state="translated">这个选项构建了一个不包含可写静态数据(WSD)的SQLite库的版本。WSD是全局变量和/或静态变量。有些平台不支持WSD,为了让SQLite在这些平台上运行,这个选项是必要的。</target>
        </trans-unit>
        <trans-unit id="cc1dc5438a20aea7b771ebb862eeafa845ecba70" translate="yes" xml:space="preserve">
          <source>This option causes SQLite to include support for the &lt;a href=&quot;rtree&quot;&gt;R*Tree index extension&lt;/a&gt;.</source>
          <target state="translated">此选项使SQLite包括对&lt;a href=&quot;rtree&quot;&gt;R * Tree索引扩展的支持&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d49b99c0ffb50444c0efac26b8174b7d62f63e18" translate="yes" xml:space="preserve">
          <source>This option causes SQLite to issue extra &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE&lt;/a&gt; file controls to provide supplementary information to the VFS. The &quot;vfslog.c&quot; extension makes use of this to provide enhanced logs of VFS activity.</source>
          <target state="translated">此选项使SQLite发出额外的&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE&lt;/a&gt;文件控件，以向VFS提供补充信息。&amp;ldquo; vfslog.c&amp;rdquo;扩展使用此功能来提供VFS活动的增强日志。</target>
        </trans-unit>
        <trans-unit id="f48b901e533b97a7c255e13419b3b1ee589cd6a2" translate="yes" xml:space="preserve">
          <source>This option causes SQLite to omit support for CHECK constraints. The parser will still accept CHECK constraints in SQL statements, they will just not be enforced.</source>
          <target state="translated">这个选项会导致SQLite省略对CHECK约束的支持。解析器仍然会接受SQL语句中的CHECK约束,只是它们不会被强制执行。</target>
        </trans-unit>
        <trans-unit id="0e8d6847f55a56b21f8cc66e6cb9b40222b5beea" translate="yes" xml:space="preserve">
          <source>This option causes SQLite to omit support for interfaces marked as deprecated. This includes &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_aggregate_count()&lt;/a&gt;, &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_expired()&lt;/a&gt;, &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_transfer_bindings()&lt;/a&gt;, &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_global_recover()&lt;/a&gt;, &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_thread_cleanup()&lt;/a&gt; and &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm()&lt;/a&gt; interfaces and &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;PRAGMA count_changes&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;PRAGMA data_store_directory&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_default_cache_size&quot;&gt;PRAGMA default_cache_size&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt;PRAGMA empty_result_callbacks&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;PRAGMA full_column_names&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;PRAGMA short_column_names&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt;.</source>
          <target state="translated">此选项导致SQLite省略对标记为已弃用的接口的支持。这包括&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_aggregate_count（） &lt;/a&gt;，&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_expired（） &lt;/a&gt;，&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_transfer_bindings（） &lt;/a&gt;，&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_global_recover（） &lt;/a&gt;，&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_thread_cleanup（）&lt;/a&gt;和&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm（）&lt;/a&gt;接口和&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;语句&lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;PRAGMA count_changes&lt;/a&gt;，&lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;PRAGMA data_store_directory&lt;/a&gt;，&lt;a href=&quot;pragma#pragma_default_cache_size&quot;&gt;PRAGMA default_cache_size&lt;/a&gt;，&lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt;PRAGMA empty_result_callbacks&lt;/a&gt;，&lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;PRAGMA full_column_names&lt;/a&gt;，&lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;PRAGMA short_column_names&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3bc3317e6e04ba669cec1fd0969c97803605f228" translate="yes" xml:space="preserve">
          <source>This option causes SQLite to omit support for the &lt;a href=&quot;c3ref/column_decltype&quot;&gt;sqlite3_column_decltype()&lt;/a&gt; and &lt;a href=&quot;c3ref/column_decltype&quot;&gt;sqlite3_column_decltype16()&lt;/a&gt; interfaces.</source>
          <target state="translated">此选项导致SQLite省略对&lt;a href=&quot;c3ref/column_decltype&quot;&gt;sqlite3_column_decltype（）&lt;/a&gt;和&lt;a href=&quot;c3ref/column_decltype&quot;&gt;sqlite3_column_decltype16（）&lt;/a&gt;接口的支持。</target>
        </trans-unit>
        <trans-unit id="f5f11391f5a431c21a74cece861bb90184bcc1ca" translate="yes" xml:space="preserve">
          <source>This option causes SQLite to omit support for the CAST operator.</source>
          <target state="translated">这个选项会导致SQLite省略对CAST操作符的支持。</target>
        </trans-unit>
        <trans-unit id="42e9c6736f13f3788e9996fc842184805b38c422" translate="yes" xml:space="preserve">
          <source>This option causes some extensions to link against the &lt;a href=&quot;https://zlib.net&quot;&gt;zlib compression library&lt;/a&gt;.</source>
          <target state="translated">此选项导致某些扩展链接到&lt;a href=&quot;https://zlib.net&quot;&gt;zlib压缩库&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8f9a553122464d073f41c1a4907a1e3a4d15ea05" translate="yes" xml:space="preserve">
          <source>This option causes support for &lt;a href=&quot;c3ref/blob&quot;&gt;incremental BLOB I/O&lt;/a&gt; to be omitted.</source>
          <target state="translated">此选项导致省略对&lt;a href=&quot;c3ref/blob&quot;&gt;增量BLOB I / O的&lt;/a&gt;支持。</target>
        </trans-unit>
        <trans-unit id="a5fb6aca1f0d6549bb7f87e1d2117bf9906d5faa" translate="yes" xml:space="preserve">
          <source>This option causes support for &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; and &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_free_table()&lt;/a&gt; to be omitted.</source>
          <target state="translated">此选项导致省略对&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;和&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_free_table（）的&lt;/a&gt;支持。</target>
        </trans-unit>
        <trans-unit id="81ad82489e08da7b33af60fe7dc85cf28f77189f" translate="yes" xml:space="preserve">
          <source>This option causes support for &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt; to be omitted.</source>
          <target state="translated">此选项导致省略对&lt;a href=&quot;lang_with&quot;&gt;公用表表达式的&lt;/a&gt;支持。</target>
        </trans-unit>
        <trans-unit id="1d462d4f5baf96b5381e5a9efb9392dd8419bfa1" translate="yes" xml:space="preserve">
          <source>This option causes the &lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete()&lt;/a&gt; and &lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete16()&lt;/a&gt; interfaces to be omitted.</source>
          <target state="translated">此选项导致省略&lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete（）&lt;/a&gt;和&lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete16（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="c44c8eec11a8ae8049df43dc8d152025a2065bf2" translate="yes" xml:space="preserve">
          <source>This option causes the &lt;a href=&quot;http://www.icu-project.org/&quot;&gt;International Components for Unicode&lt;/a&gt; or &quot;ICU&quot; extension to SQLite to be added to the build.</source>
          <target state="translated">此选项导致将&lt;a href=&quot;http://www.icu-project.org/&quot;&gt;Unicode&lt;/a&gt;的国际组件或SQLite的&amp;ldquo; ICU&amp;rdquo;扩展名添加到构建中。</target>
        </trans-unit>
        <trans-unit id="3e7ba1f2e4ecce44e2a9ed58760bf709eee38824" translate="yes" xml:space="preserve">
          <source>This option causes the &lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;PRAGMA reverse_unordered_selects&lt;/a&gt; setting to be enabled by default. When enabled, &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements that lack an ORDER BY clause will run in reverse order.</source>
          <target state="translated">此选项使&lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;PRAGMA reverse_unordered_selects&lt;/a&gt;设置在默认情况下启用。启用后，缺少ORDER BY子句的&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句将以相反的顺序运行。</target>
        </trans-unit>
        <trans-unit id="f5c90b7d8674897dce67771e2421445a44cf5d0f" translate="yes" xml:space="preserve">
          <source>This option causes the &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;query planner stability guarantee&lt;/a&gt; (QPSG) to be on by default. Normally the QPSG is off and must be activated at run-time using the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt; option to the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface.</source>
          <target state="translated">此选项使&lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;查询计划程序稳定性保证&lt;/a&gt;（QPSG）在默认情况下处于启用状态。通常，QPSG是关闭的，必须在运行时使用&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;接口的&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt;选项激活。</target>
        </trans-unit>
        <trans-unit id="f3e81e1ee9998eb2eded923b7975e23afc33d57f" translate="yes" xml:space="preserve">
          <source>This option causes the &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; process logic to be enabled by default.</source>
          <target state="translated">此选项使&lt;a href=&quot;uri&quot;&gt;URI文件名&lt;/a&gt;处理逻辑默认情况下处于启用状态。</target>
        </trans-unit>
        <trans-unit id="25841760348a4a05ca082684fc85caf48a8848ea" translate="yes" xml:space="preserve">
          <source>This option causes the LALR(1) parser stack depth to be tracked and reported using the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status&lt;/a&gt;(&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusparserstack&quot;&gt;SQLITE_STATUS_PARSER_STACK&lt;/a&gt;,...) interface. SQLite's LALR(1) parser has a fixed stack depth (determined at compile-time using the &lt;a href=&quot;compile#yystackdepth&quot;&gt;YYSTACKDEPTH&lt;/a&gt; options). This option can be used to help determine if an application is getting close to exceeding the maximum LALR(1) stack depth.</source>
          <target state="translated">此选项导致使用&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status&lt;/a&gt;（&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusparserstack&quot;&gt;SQLITE_STATUS_PARSER_STACK&lt;/a&gt;，...）接口跟踪和报告LALR（1）解析器堆栈深度。 SQLite的LALR（1）解析器具有固定的堆栈深度（在编译时使用&lt;a href=&quot;compile#yystackdepth&quot;&gt;YYSTACKDEPTH&lt;/a&gt;选项确定）。此选项可用于帮助确定应用程序是否接近最大LALR（1）堆栈深度。</target>
        </trans-unit>
        <trans-unit id="32f86baa9c92a63548375cdf50ea0fd1c52ed044" translate="yes" xml:space="preserve">
          <source>This option changes the default assumption about &lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt; for the underlying filesystems for the unix and windows &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;. Setting SQLITE_POWERSAFE_OVERWRITE to 1 causes SQLite to assume that application-level writes cannot changes bytes outside the range of bytes written even if the write occurs just before a power loss. With SQLITE_POWERSAFE_OVERWRITE set to 0, SQLite assumes that other bytes in the same sector with a written byte might be changed or damaged by a power loss.</source>
          <target state="translated">此选项更改有关UNIX和Windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;的基础文件系统&lt;a href=&quot;psow&quot;&gt;电源安全覆盖&lt;/a&gt;的默认假设。将SQLITE_POWERSAFE_OVERWRITE设置为1会导致SQLite假定应用程序级写操作无法更改超出所写字节范围的字节，即使该写操作恰好在断电之前发生。在将SQLITE_POWERSAFE_OVERWRITE设置为0的情况下，SQLite假定同一扇区中具有写入字节的其他字节可能因断电而被更改或损坏。</target>
        </trans-unit>
        <trans-unit id="791fdd9bdb7ed68e09202021e5669277498343c1" translate="yes" xml:space="preserve">
          <source>This option controls whether or not code is included in SQLite to enable it to operate safely in a multithreaded environment. The default is SQLITE_THREADSAFE=1 which is safe for use in a multithreaded environment. When compiled with SQLITE_THREADSAFE=0 all mutexing code is omitted and it is unsafe to use SQLite in a multithreaded program. When compiled with SQLITE_THREADSAFE=2, SQLite can be used in a multithreaded program so long as no two threads attempt to use the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; (or any &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; derived from that database connection) at the same time.</source>
          <target state="translated">此选项控制代码是否包含在SQLite中以使其能够在多线程环境中安全运行。默认值为SQLITE_THREADSAFE = 1，可以在多线程环境中安全使用。当使用SQLITE_THREADSAFE = 0进行编译时，将忽略所有的静音代码，并且在多线程程序中使用SQLite是不安全的。当使用SQLITE_THREADSAFE = 2进行编译时，只要没有两个线程尝试同时使用相同的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;（或从该数据库连接派生的任何&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;），就可以在多线程程序中使用SQLite 。</target>
        </trans-unit>
        <trans-unit id="e2db1e13a20e398e5992253ddd17146aa86ad317" translate="yes" xml:space="preserve">
          <source>This option controls whether temporary files are stored on disk or in memory. The meanings for various settings of this compile-time option are as follows:</source>
          <target state="translated">这个选项控制临时文件是存储在磁盘上还是内存中。这个编译时选项的各种设置的含义如下。</target>
        </trans-unit>
        <trans-unit id="f480e09e0e7a4b4c8eaae40f24ab8395889d63cf" translate="yes" xml:space="preserve">
          <source>This option disables the ability of SQLite to use an index together with terms of a WHERE clause connected by the OR operator.</source>
          <target state="translated">这个选项禁止SQLite使用索引和由OR操作符连接的WHERE子句的条款。</target>
        </trans-unit>
        <trans-unit id="bf93493f8d0082c8b326cab559012b486b9691a3" translate="yes" xml:space="preserve">
          <source>This option disables the ability of SQLite to use indices to help resolve &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; and &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operators in a WHERE clause.</source>
          <target state="translated">此选项禁用SQLite使用索引来帮助解析WHERE子句中的&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;和&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;运算符的功能。</target>
        </trans-unit>
        <trans-unit id="faffed503a7ff1447f6b122080398e29ed11b00e" translate="yes" xml:space="preserve">
          <source>This option disables the use of compiler-specific built-in functions such as __builtin_bswap32() and __builtin_add_overflow() in GCC and Clang, or _byteswap_ulong() and _ReadWriteBarrier() with MSVC.</source>
          <target state="translated">这个选项禁止使用编译器特定的内置函数,比如GCC和Clang中的__builtin_bswap32()和__builtin_add_overflow(),或者MSVC中的_byteswap_ulong()和_ReadWriteBarrier()。</target>
        </trans-unit>
        <trans-unit id="30e5236a00b5a0e3f369da0d4ce09a34450e4f5d" translate="yes" xml:space="preserve">
          <source>This option disables the use of indices with WHERE clause terms that employ the BETWEEN operator.</source>
          <target state="translated">这个选项禁止使用使用BETWEEN操作符的WHERE子句的索引。</target>
        </trans-unit>
        <trans-unit id="f2b0cbc6ec1854f9e4c7dd19a372c4979cbe3657" translate="yes" xml:space="preserve">
          <source>This option enables &lt;a href=&quot;c3ref/preupdate_count&quot;&gt;several new APIs&lt;/a&gt; that provide callbacks prior to any change to a &lt;a href=&quot;rowidtable&quot;&gt;rowid table&lt;/a&gt;. The callbacks can be used to record the state of the row before the change occurs.</source>
          <target state="translated">此选项启用&lt;a href=&quot;c3ref/preupdate_count&quot;&gt;几个新API&lt;/a&gt;，这些API在对&lt;a href=&quot;rowidtable&quot;&gt;rowid表&lt;/a&gt;进行任何更改之前提供回调。回调可用于记录更改发生之前的行状态。</target>
        </trans-unit>
        <trans-unit id="0f330069807dae4c09d6cca239bf6220ceecd386" translate="yes" xml:space="preserve">
          <source>This option enables additional logic in the OS interface layer for Mac OS X. The additional logic attempts to determine the type of the underlying filesystem and choose and alternative locking strategy that works correctly for that filesystem type. Five locking strategies are available:</source>
          <target state="translated">此选项可在 Mac OS X 的 OS 接口层中启用附加逻辑。额外的逻辑试图确定底层文件系统的类型,并选择正确适用于该文件系统类型的替代锁定策略。有五种锁定策略可用。</target>
        </trans-unit>
        <trans-unit id="b0cda88b35aef2718ccabbc509d1fe578d46ccac" translate="yes" xml:space="preserve">
          <source>This option enables an optimization that omits NULL columns at the ends of rows, for a space savings on disk.</source>
          <target state="translated">这个选项可以实现在行尾省略NULL列的优化,以节省磁盘空间。</target>
        </trans-unit>
        <trans-unit id="6f83f444cc87212970d30b59ad548ac739a161e1" translate="yes" xml:space="preserve">
          <source>This option enables an optional ORDER BY and LIMIT clause on &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements.</source>
          <target state="translated">此选项在&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;和&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;语句上启用可选的ORDER BY和LIMIT子句。</target>
        </trans-unit>
        <trans-unit id="e69261024b835708d0d4847720c9f1cf32a794de" translate="yes" xml:space="preserve">
          <source>This option enables extra code (especially the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsqllog&quot;&gt;SQLITE_CONFIG_SQLLOG&lt;/a&gt; option to &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt;) that can be used to create logs of all SQLite processing performed by an application. These logs can be useful in doing off-line analysis of the behavior of an application, and especially for performance analysis. In order for the SQLITE_ENABLE_SQLLOG option to be useful, some extra code is required. The &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/test_sqllog.c&quot;&gt;&quot;test_sqllog.c&quot;&lt;/a&gt; source code file in the SQLite source tree is a working example of the required extra code. On unix and windows systems, a developer can append the text of the &quot;test_sqllog.c&quot; source code file to the end of an &quot;sqlite3.c&quot; amalgamation, recompile the application using the -DSQLITE_ENABLE_SQLLOG option, then control logging using environment variables. See the header comment on the &quot;test_sqllog.c&quot; source file for additional detail.</source>
          <target state="translated">此选项启用额外的代码（尤其是&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;的&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsqllog&quot;&gt;SQLITE_CONFIG_SQLLOG&lt;/a&gt;选项），可用于创建应用程序执行的所有SQLite处理的日志。这些日志可用于对应用程序的行为进行离线分析，尤其是对于性能分析。为了使SQLITE_ENABLE_SQLLOG选项有用，需要一些额外的代码。该&lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/test_sqllog.c&quot;&gt;&amp;ldquo;test_sqllog.c&amp;rdquo;&lt;/a&gt;SQLite源代码树中的源代码文件是所需额外代码的有效示例。在UNIX和Windows系统上，开发人员可以将&amp;ldquo; test_sqllog.c&amp;rdquo;源代码文件的文本附加到&amp;ldquo; sqlite3.c&amp;rdquo;合并的末尾，使用-DSQLITE_ENABLE_SQLLOG选项重新编译应用程序，然后使用环境变量控制日志记录。有关更多详细信息，请参见&amp;ldquo; test_sqllog.c&amp;rdquo;源文件上的标题注释。</target>
        </trans-unit>
        <trans-unit id="274a5f8b5db607c52552d4637956a2899e2617fe" translate="yes" xml:space="preserve">
          <source>This option enables support for the &lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset(X)&lt;/a&gt; SQL function.</source>
          <target state="translated">此选项启用对&lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset（X）&lt;/a&gt; SQL函数的支持。</target>
        </trans-unit>
        <trans-unit id="93022ac685f42e44c6bd7d7db98fb4366cf5def1" translate="yes" xml:space="preserve">
          <source>This option enables the &lt;a href=&quot;bytecodevtab&quot;&gt;bytecode and tables_used virtual tables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9a1787f4c945251b506136e6798154b2c122d60" translate="yes" xml:space="preserve">
          <source>This option enables the &lt;a href=&quot;c3ref/serialize&quot;&gt;sqlite3_serialize()&lt;/a&gt; and &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; interfaces.</source>
          <target state="translated">此选项启用&lt;a href=&quot;c3ref/serialize&quot;&gt;sqlite3_serialize（）&lt;/a&gt;和&lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="be87642b57ced8abee8b1950b45aa93d46620bfd" translate="yes" xml:space="preserve">
          <source>This option enables the &lt;a href=&quot;c3ref/stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus()&lt;/a&gt; interface. The &lt;a href=&quot;c3ref/stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus()&lt;/a&gt; interface is normally omitted from the build because it imposes a small performance penalty, even on statements that do not use the feature.</source>
          <target state="translated">此选项启用&lt;a href=&quot;c3ref/stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus（）&lt;/a&gt;接口。该&lt;a href=&quot;c3ref/stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus（）&lt;/a&gt;接口通常从构建省略，因为它规定一个小的性能损失，即使在不使用该功能的语句。</target>
        </trans-unit>
        <trans-unit id="51d540f2703b7f49001660035d021722d40f355e" translate="yes" xml:space="preserve">
          <source>This option enables the &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface and its associated functionality. See the documentation titled &lt;a href=&quot;unlock_notify&quot;&gt;Using the SQLite Unlock Notification Feature&lt;/a&gt; for additional information.</source>
          <target state="translated">此选项启用&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;接口及其关联的功能。有关其他信息，请参见标题为&amp;ldquo; &lt;a href=&quot;unlock_notify&quot;&gt;使用SQLite解锁通知功能&lt;/a&gt; &amp;rdquo;的文档。</target>
        </trans-unit>
        <trans-unit id="d95741cd8a126d1cf356358b77e58a5cff687ae7" translate="yes" xml:space="preserve">
          <source>This option enables the &lt;a href=&quot;dbpage&quot;&gt;SQLITE_DBPAGE virtual table&lt;/a&gt;.</source>
          <target state="translated">此选项启用&lt;a href=&quot;dbpage&quot;&gt;SQLITE_DBPAGE虚拟表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="67a232ef452eb71b2c364382991ea5fe843a8072" translate="yes" xml:space="preserve">
          <source>This option enables the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;.</source>
          <target state="translated">此选项启用&lt;a href=&quot;dbstat&quot;&gt;dbstat虚拟表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="263fe759843f50fd8ce96e059c3daf128b5aa902" translate="yes" xml:space="preserve">
          <source>This option enables the &lt;a href=&quot;lang_corefunc#soundex&quot;&gt;soundex() SQL function&lt;/a&gt;.</source>
          <target state="translated">此选项启用&lt;a href=&quot;lang_corefunc#soundex&quot;&gt;soundex（）SQL函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2f583d286c14b783ea80b9c826f07e649637eb7a" translate="yes" xml:space="preserve">
          <source>This option enables the &lt;a href=&quot;sessionintro&quot;&gt;session extension&lt;/a&gt;.</source>
          <target state="translated">此选项启用&lt;a href=&quot;sessionintro&quot;&gt;会话扩展&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9acfdf9bd0e7a3663dc2bc3825b43b38a145c695" translate="yes" xml:space="preserve">
          <source>This option enables the code to support the &lt;a href=&quot;c3ref/snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object and its related interfaces:</source>
          <target state="translated">此选项使代码能够支持&lt;a href=&quot;c3ref/snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt;对象及其相关接口：</target>
        </trans-unit>
        <trans-unit id="223f501de382821eed41b9386a107ab95a98080f" translate="yes" xml:space="preserve">
          <source>This option enables the two-argument version of the &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; interface. The second argument to fts3_tokenizer() is suppose to be a pointer to a function (encoded as a BLOB) that implements an application defined tokenizer. If hostile actors are able to run the two-argument version of fts3_tokenizer() with an arbitrary second argument, they could use crash or take control of the process.</source>
          <target state="translated">此选项启用&lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer（）&lt;/a&gt;接口的两个参数版本。假设fts3_tokenizer（）的第二个参数是指向实现应用程序定义的令牌生成器的函数（编码为BLOB）的指针。如果敌对行动者能够使用任意第二个参数运行fts3_tokenizer（）的两个参数版本，则他们可以使用崩溃或控制进程。</target>
        </trans-unit>
        <trans-unit id="7cc48f6d5950f1e34bb75faacdf1cc192e5f2843" translate="yes" xml:space="preserve">
          <source>This option enables the use of the Windows Heap API functions for memory allocation instead of the standard library malloc() and free() routines.</source>
          <target state="translated">这个选项可以使用Windows Heap API函数进行内存分配,而不是标准的库malloc()和free()例程。</target>
        </trans-unit>
        <trans-unit id="4c5a946f48226950dd966bd130e90484df7d66b6" translate="yes" xml:space="preserve">
          <source>This option forces the Win32 native memory allocator, when enabled, to create a private heap to hold all memory allocations.</source>
          <target state="translated">这个选项强制Win32本机内存分配器在启用时,创建一个私有堆来保存所有的内存分配。</target>
        </trans-unit>
        <trans-unit id="a6e532ac60807302cf761f04099d7e9ae4df7d97" translate="yes" xml:space="preserve">
          <source>This option forces the Win32 native memory allocator, when enabled, to make strategic calls into the HeapValidate() function if assert() is also enabled.</source>
          <target state="translated">这个选项强制Win32本机内存分配器在启用后,如果assert()也被启用,就会对HeapValidate()函数进行策略调用。</target>
        </trans-unit>
        <trans-unit id="38ef15a6ec83783f8e5342533553962834968880" translate="yes" xml:space="preserve">
          <source>This option has no affect on the SQLite core. It is only used by extensions. This is option is necessary for the compression and decompression functions that are part of &lt;a href=&quot;sqlar&quot;&gt;SQL Archive&lt;/a&gt; support in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">此选项对SQLite核心没有影响。仅扩展使用。对于&lt;a href=&quot;cli&quot;&gt;命令行外壳程序&lt;/a&gt;中&lt;a href=&quot;sqlar&quot;&gt;SQL Archive&lt;/a&gt;支持的压缩和解压缩功能，此选项是必需的。</target>
        </trans-unit>
        <trans-unit id="14c8af9768bd63293fd017249118cc8e97ccdc51" translate="yes" xml:space="preserve">
          <source>This option includes code in SQLite that implements an alternative memory allocator. This alternative memory allocator is only engaged when the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; option to &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; is used to supply a large chunk of memory from which all memory allocations are taken. The MEMSYS3 memory allocator uses a hybrid allocation algorithm patterned after dlmalloc(). Only one of SQLITE_ENABLE_MEMSYS3 and SQLITE_ENABLE_MEMSYS5 may be enabled at once.</source>
          <target state="translated">此选项包括SQLite中实现替代内存分配器的代码。当这种替代内存分配器仅接合&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;选项&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;用于供应的存储器大块从中提取所有的内存分配。 MEMSYS3内存分配器使用在dlmalloc（）之后模式化的混合分配算法。一次只能启用SQLITE_ENABLE_MEMSYS3和SQLITE_ENABLE_MEMSYS5之一。</target>
        </trans-unit>
        <trans-unit id="ec14e9ee089db4506386b040d7a0d29749f6e52a" translate="yes" xml:space="preserve">
          <source>This option includes code in SQLite that implements an alternative memory allocator. This alternative memory allocator is only engaged when the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; option to &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; is used to supply a large chunk of memory from which all memory allocations are taken. The MEMSYS5 module rounds all allocations up to the next power of two and uses a first-fit, buddy-allocator algorithm that provides strong guarantees against fragmentation and breakdown subject to certain operating constraints.</source>
          <target state="translated">此选项包括SQLite中实现替代内存分配器的代码。仅当使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;的&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;选项提供大量内存以从中获取所有内存分配时，才使用此备用内存分配器。 MEMSYS5模块将所有分配向上舍入为2的下一个幂，并使用&amp;ldquo;最适合&amp;rdquo;的伙伴分配器算法，该算法为某些操作约束下的碎片和崩溃提供了有力的保证。</target>
        </trans-unit>
        <trans-unit id="b2d0fc0af3baf2bb6313e04cb3b2c292231a6d89" translate="yes" xml:space="preserve">
          <source>This option is no longer used for anything. It is a no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0d5394036aa4f4e95f3e2cab1f066c690e694f" translate="yes" xml:space="preserve">
          <source>This option is obsolete. It used to enable some extra some extra PRAGMA statements such as &lt;a href=&quot;pragma#pragma_function_list&quot;&gt;PRAGMA function_list&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_module_list&quot;&gt;PRAGMA module_list&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_pragma_list&quot;&gt;PRAGMA pragma_list&lt;/a&gt;, but those pragmas are now all enabled by default. See &lt;a href=&quot;compile#omit_introspection_pragmas&quot;&gt;SQLITE_OMIT_INTROSPECTION_PRAGMAS&lt;/a&gt;.</source>
          <target state="translated">此选项已过时。它曾经使一些额外的一些额外的注记语句，如&lt;a href=&quot;pragma#pragma_function_list&quot;&gt;PRAGMA function_list&lt;/a&gt;，&lt;a href=&quot;pragma#pragma_module_list&quot;&gt;PRAGMA MODULE_LIST&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_pragma_list&quot;&gt;PRAGMA pragma_list&lt;/a&gt;，但这些pragma现在都默认启用。请参阅&lt;a href=&quot;compile#omit_introspection_pragmas&quot;&gt;SQLITE_OMIT_INTROSPECTION_PRAGMAS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3d64e8ca0a51fe592b5c0aacc258d17bc062a414" translate="yes" xml:space="preserve">
          <source>This option is omits the &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; feature. When this is macro is defined, columns declared as &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; AUTOINCREMENT&quot; behave in the same way as columns declared as &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;&quot; when a NULL is inserted. The sqlite_sequence system table is neither created, nor respected if it already exists.</source>
          <target state="translated">此选项省略了&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;功能。定义此宏时，插入NULL时，声明为&amp;ldquo; &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; AUTOINCREMENT&amp;rdquo;的列的行为与声明为&amp;ldquo; &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; &amp;rdquo;的列相同。sqlite_sequence系统表既不会创建，也不会受到尊重（如果已存在）。</target>
        </trans-unit>
        <trans-unit id="35532e84bec206bb40c52a637418126e7ac12604" translate="yes" xml:space="preserve">
          <source>This option is only available if sqlite is compiled with the &lt;a href=&quot;../compile#enable_sqllog&quot;&gt;SQLITE_ENABLE_SQLLOG&lt;/a&gt; pre-processor macro defined. The first argument should be a pointer to a function of type void(*)(void*,sqlite3*,const char*, int). The second should be of type (void*). The callback is invoked by the library in three separate circumstances, identified by the value passed as the fourth parameter. If the fourth parameter is 0, then the database connection passed as the second argument has just been opened. The third argument points to a buffer containing the name of the main database file. If the fourth parameter is 1, then the SQL statement that the third parameter points to has just been executed. Or, if the fourth parameter is 2, then the connection being passed as the second parameter is being closed. The third parameter is passed NULL In this case. An example of using this configuration option can be seen in the &quot;test_sqllog.c&quot; source file in the canonical SQLite source tree.</source>
          <target state="translated">仅当使用&lt;a href=&quot;../compile#enable_sqllog&quot;&gt;SQLITE_ENABLE_SQLLOG&lt;/a&gt;编译sqlite时，此选项才可用定义了预处理器宏。第一个参数应该是指向void（*）（void *，sqlite3 *，const char *，int）类型的函数的指针。第二个应为（void *）类型。库在三种不同的情况下调用回调，这些情况由作为第四个参数传递的值标识。如果第四个参数为0，则刚刚打开作为第二个参数传递的数据库连接。第三个参数指向包含主数据库文件名称的缓冲区。如果第四个参数为1，则刚刚执行了第三个参数指向的SQL语句。或者，如果第四个参数为2，则在关闭第二个参数时正在传递的连接。在这种情况下，将第三个参数传递为NULL。在&amp;ldquo; test_sqllog.c&amp;rdquo;中可以看到使用此配置选项的示例。SQLite规范树中的源文件。</target>
        </trans-unit>
        <trans-unit id="3370b57f53a2cc0599282e4a4706bd9d78d8e68e" translate="yes" xml:space="preserve">
          <source>This option is only available if sqlite is compiled with the &lt;a href=&quot;compile#enable_sqllog&quot;&gt;SQLITE_ENABLE_SQLLOG&lt;/a&gt; pre-processor macro defined. The first argument should be a pointer to a function of type void(*)(void*,sqlite3*,const char*, int). The second should be of type (void*). The callback is invoked by the library in three separate circumstances, identified by the value passed as the fourth parameter. If the fourth parameter is 0, then the database connection passed as the second argument has just been opened. The third argument points to a buffer containing the name of the main database file. If the fourth parameter is 1, then the SQL statement that the third parameter points to has just been executed. Or, if the fourth parameter is 2, then the connection being passed as the second parameter is being closed. The third parameter is passed NULL In this case. An example of using this configuration option can be seen in the &quot;test_sqllog.c&quot; source file in the canonical SQLite source tree.</source>
          <target state="translated">仅当使用&lt;a href=&quot;compile#enable_sqllog&quot;&gt;SQLITE_ENABLE_SQLLOG&lt;/a&gt;编译sqlite时，此选项才可用定义了预处理器宏。第一个参数应该是指向void（*）（void *，sqlite3 *，const char *，int）类型的函数的指针。第二个应为（void *）类型。库在三种不同的情况下调用回调，这些情况由作为第四个参数传递的值标识。如果第四个参数为0，则刚刚打开作为第二个参数传递的数据库连接。第三个参数指向包含主数据库文件名称的缓冲区。如果第四个参数为1，则刚刚执行了第三个参数指向的SQL语句。或者，如果第四个参数为2，则在关闭第二个参数时正在传递的连接。在这种情况下，将第三个参数传递为NULL。在&amp;ldquo; test_sqllog.c&amp;rdquo;中可以看到使用此配置选项的示例。SQLite规范树中的源文件。</target>
        </trans-unit>
        <trans-unit id="dd9b28b9e3c685c0ebb9d5ffb873be86ed7e4a11" translate="yes" xml:space="preserve">
          <source>This option is typically used when building SQLite for an embedded platform with a custom operating system.</source>
          <target state="translated">该选项通常用于为嵌入式平台与自定义操作系统构建SQLite时。</target>
        </trans-unit>
        <trans-unit id="2457ea19543336e39ab5ad959ce6c6fc2134a1fe" translate="yes" xml:space="preserve">
          <source>This option is used to change the name of the &quot;main&quot; database schema. The sole argument is a pointer to a constant UTF8 string which will become the new schema name in place of &quot;main&quot;. SQLite does not make a copy of the new main schema name string, so the application must ensure that the argument passed into this DBCONFIG option is unchanged until after the database connection closes.</source>
          <target state="translated">这个选项用来改变 &quot;main &quot;数据库模式的名称。唯一的参数是一个指向UTF8常量字符串的指针,这个字符串将成为新的模式名,代替 &quot;main&quot;。SQLite不会复制新的主模式名字符串,所以应用程序必须确保传递到这个DBCONFIG选项中的参数保持不变,直到数据库连接关闭之后。</target>
        </trans-unit>
        <trans-unit id="39287b1bd3b31dd8abed9ad5de5fbf18b92fbab1" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable &lt;a href=&quot;../lang_createtrigger&quot;&gt;triggers&lt;/a&gt;. There should be two additional arguments. The first argument is an integer which is 0 to disable triggers, positive to enable triggers or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether triggers are disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the trigger setting is not reported back.</source>
          <target state="translated">此选项用于启用或禁用&lt;a href=&quot;../lang_createtrigger&quot;&gt;触发器&lt;/a&gt;。应该有两个附加参数。第一个参数是一个整数，其值为0以禁用触发器，为正数以启用触发器，或者为负数以保持设置不变。第二个参数是指向整数的指针，该整数写入0或1，以指示在此调用之后是禁用还是启用触发器。第二个参数可以是NULL指针，在这种情况下不会触发触发器设置。</target>
        </trans-unit>
        <trans-unit id="05b777e4219204f514426e561a55ff3f15bc7095" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable &lt;a href=&quot;../lang_createview&quot;&gt;views&lt;/a&gt;. There should be two additional arguments. The first argument is an integer which is 0 to disable views, positive to enable views or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether views are disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the view setting is not reported back.</source>
          <target state="translated">此选项用于启用或禁用&lt;a href=&quot;../lang_createview&quot;&gt;视图&lt;/a&gt;。应该有两个附加参数。第一个参数是一个整数，其值为0表示禁用视图，为正数表示启用视图，为负数表示不更改设置。第二个参数是指向整数的指针，该整数写入0或1以指示在此调用之后是禁用还是启用视图。第二个参数可以是NULL指针，在这种情况下，不会回传视图设置。</target>
        </trans-unit>
        <trans-unit id="3c7692bc9a975790e68229b265337d4ffba19ed3" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt;. There should be two additional arguments. The first argument is an integer which is 0 to disable triggers, positive to enable triggers or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether triggers are disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the trigger setting is not reported back.</source>
          <target state="translated">此选项用于启用或禁用&lt;a href=&quot;lang_createtrigger&quot;&gt;触发器&lt;/a&gt;。应该有两个附加参数。第一个参数是一个整数，其值为0以禁用触发器，为正数以启用触发器，或者为负数以保持设置不变。第二个参数是指向整数的指针，该整数写入0或1，以指示在此调用之后是禁用还是启用触发器。第二个参数可以是NULL指针，在这种情况下不会触发触发器设置。</target>
        </trans-unit>
        <trans-unit id="7a79afada1e049dc560306db03b875b605d30773" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt;. There should be two additional arguments. The first argument is an integer which is 0 to disable views, positive to enable views or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether views are disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the view setting is not reported back.</source>
          <target state="translated">This option is used to enable or disable &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt;. There should be two additional arguments. The first argument is an integer which is 0 to disable views, positive to enable views or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether views are disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the view setting is not reported back.</target>
        </trans-unit>
        <trans-unit id="c1d1e7d85a436fe8e6a223e6a43f70bf20bcb28e" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable the &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface independently of the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function. The &lt;a href=&quot;#sqlite3_enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; API enables or disables both the C-API &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; and the SQL function &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt;. There should be two additional arguments. When the first argument to this interface is 1, then only the C-API is enabled and the SQL function remains disabled. If the first argument to this interface is 0, then both the C-API and the SQL function are disabled. If the first argument is -1, then no changes are made to state of either the C-API or the SQL function. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface is disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the new setting is not reported back.</source>
          <target state="translated">此选项用于独立于&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt; SQL函数启用或禁用&lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;接口。所述&lt;a href=&quot;#sqlite3_enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）&lt;/a&gt; API激活或关闭两个C-API &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;和SQL函数&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt;。应该有两个附加参数。当此接口的第一个参数为1时，则仅启用C-API，并且SQL功能保持禁用状态。如果此接口的第一个参数为0，则C-API和SQL函数均被禁用。如果第一个参数为-1，则不会更改C-API或SQL函数的状态。第二个参数是指向整数的指针，该整数写入0或1以指示在此调用之后是否禁用或启用&lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;接口。第二个参数可以是NULL指针，在这种情况下不会报告新设置。</target>
        </trans-unit>
        <trans-unit id="053a078eadb0638cfc133802b1e15bd819ee981c" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable the &lt;a href=&quot;../fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; function which is part of the &lt;a href=&quot;../fts3&quot;&gt;FTS3&lt;/a&gt; full-text search engine extension. There should be two additional arguments. The first argument is an integer which is 0 to disable fts3_tokenizer() or positive to enable fts3_tokenizer() or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether fts3_tokenizer is disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the new setting is not reported back.</source>
          <target state="translated">此选项用于启用或禁用&lt;a href=&quot;../fts3#f3tknzr&quot;&gt;fts3_tokenizer（）&lt;/a&gt;函数，该函数是&lt;a href=&quot;../fts3&quot;&gt;FTS3&lt;/a&gt;全文搜索引擎扩展的一部分。应该有两个附加参数。第一个参数是一个整数，其值为0以禁用fts3_tokenizer（）或为正数以启用fts3_tokenizer（）或为负数以保持设置不变。第二个参数是指向整数的指针，该整数写入0或1以指示在此调用之后是禁用还是启用fts3_tokenizer。第二个参数可以是NULL指针，在这种情况下不会报告新设置。</target>
        </trans-unit>
        <trans-unit id="0aba264fcea35dcf7c8427203d720dc08ab19f9c" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable the &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; function which is part of the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; full-text search engine extension. There should be two additional arguments. The first argument is an integer which is 0 to disable fts3_tokenizer() or positive to enable fts3_tokenizer() or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether fts3_tokenizer is disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the new setting is not reported back.</source>
          <target state="translated">此选项用于启用或禁用&lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer（）&lt;/a&gt;函数，该函数是&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;全文搜索引擎扩展的一部分。应该有两个附加参数。第一个参数是一个整数，其值为0以禁用fts3_tokenizer（）或为正数以启用fts3_tokenizer（）或为负数以保持设置不变。第二个参数是指向整数的指针，该整数写入0或1以指示在此调用之后是禁用还是启用fts3_tokenizer。第二个参数可以是NULL指针，在这种情况下不会报告新设置。</target>
        </trans-unit>
        <trans-unit id="3b4986571e9b0fde1f22dd6aa95c6a58bcc8dce7" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable the &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface independently of the &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function. The &lt;a href=&quot;enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; API enables or disables both the C-API &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; and the SQL function &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt;. There should be two additional arguments. When the first argument to this interface is 1, then only the C-API is enabled and the SQL function remains disabled. If the first argument to this interface is 0, then both the C-API and the SQL function are disabled. If the first argument is -1, then no changes are made to state of either the C-API or the SQL function. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface is disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the new setting is not reported back.</source>
          <target state="translated">此选项用于独立于&lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt; SQL函数启用或禁用&lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;接口。所述&lt;a href=&quot;enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）&lt;/a&gt; API激活或关闭两个C-API &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;和SQL函数&lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt;。应该有两个附加参数。当此接口的第一个参数为1时，则仅启用C-API，并且SQL功能保持禁用状态。如果此接口的第一个参数为0，则C-API和SQL函数均被禁用。如果第一个参数为-1，则不会更改C-API或SQL函数的状态。第二个参数是指向整数的指针，该整数写入0或1以指示在此调用之后是否禁用或启用&lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;接口。第二个参数可以是NULL指针，在这种情况下不会报告新设置。</target>
        </trans-unit>
        <trans-unit id="7217434ff65eb94c32bf308c55b512fbfab6001b" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable the enforcement of &lt;a href=&quot;../foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt;. There should be two additional arguments. The first argument is an integer which is 0 to disable FK enforcement, positive to enable FK enforcement or negative to leave FK enforcement unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether FK enforcement is off or on following this call. The second parameter may be a NULL pointer, in which case the FK enforcement setting is not reported back.</source>
          <target state="translated">此选项用于启用或禁用&lt;a href=&quot;../foreignkeys&quot;&gt;外键约束的实施&lt;/a&gt;。应该有两个附加参数。第一个参数是一个整数，该整数为0以禁用FK强制执行，为正数以启用FK强制执行，为负数以保持FK强制执行不变。第二个参数是指向整数的指针，在该整数中写入0或1以指示FK强制是在此调用之后关闭还是打开。第二个参数可以是NULL指针，在这种情况下，不会报告回FK强制设置。</target>
        </trans-unit>
        <trans-unit id="4e9535dd92f396e0ccd9b1725779ad05f2042542" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable the enforcement of &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt;. There should be two additional arguments. The first argument is an integer which is 0 to disable FK enforcement, positive to enable FK enforcement or negative to leave FK enforcement unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether FK enforcement is off or on following this call. The second parameter may be a NULL pointer, in which case the FK enforcement setting is not reported back.</source>
          <target state="translated">此选项用于启用或禁用&lt;a href=&quot;foreignkeys&quot;&gt;外键约束的实施&lt;/a&gt;。应该有两个附加参数。第一个参数是一个整数，该整数为0以禁用FK强制执行，为正数以启用FK强制执行，为负数以保持FK强制执行不变。第二个参数是指向整数的指针，在该整数中写入0或1以指示FK强制是在此调用之后关闭还是打开。第二个参数可以是NULL指针，在这种情况下，不会报告回FK强制设置。</target>
        </trans-unit>
        <trans-unit id="b25224fdc16ddfe6de8238e7f19837e56d45d01c" translate="yes" xml:space="preserve">
          <source>This option is used to omit floating-point number support from the SQLite library. When specified, specifying a floating point number as a literal (i.e. &quot;1.01&quot;) results in a parse error.</source>
          <target state="translated">这个选项用于省略SQLite库中的浮点数支持。当指定该选项时,如果将浮点数指定为文字形式(例如 &quot;1.01&quot;),将导致解析错误。</target>
        </trans-unit>
        <trans-unit id="299a6909399a8b4b26dc341e805951ee902fb9f9" translate="yes" xml:space="preserve">
          <source>This option is used to omit the &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; functionality. See also: &lt;a href=&quot;compile#default_automatic_index&quot;&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX&lt;/a&gt;.</source>
          <target state="translated">此选项用于省略&lt;a href=&quot;optoverview#autoindex&quot;&gt;自动索引&lt;/a&gt;功能。另请参阅：&lt;a href=&quot;compile#default_automatic_index&quot;&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b4b919b2428e6408085cdcd9e60a16588061b220" translate="yes" xml:space="preserve">
          <source>This option is used to omit the &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; command from the library. Note that it is useful to define the macros that omit specific pragmas in addition to this, as they may also remove supporting code in other sub-systems. This macro removes the &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; command only.</source>
          <target state="translated">此选项用于从库中省略&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;命令。注意，定义除此以外的宏也很有用，因为它们也可能会删除其他子系统中的支持代码。该宏仅删除&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="9c62439be8833757141bf29ba12fcdc5e143f4a3" translate="yes" xml:space="preserve">
          <source>This option is used to omit the compile-time option diagnostics available in SQLite, including the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get()&lt;/a&gt; C/C++ functions, the &lt;a href=&quot;lang_corefunc#sqlite_compileoption_used&quot;&gt;sqlite_compileoption_used()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get()&lt;/a&gt; SQL functions, and the &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;.</source>
          <target state="translated">此选项用于省略SQLite中可用的编译时选项诊断，包括&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used（）&lt;/a&gt;和&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get（）&lt;/a&gt; C / C ++函数，&lt;a href=&quot;lang_corefunc#sqlite_compileoption_used&quot;&gt;sqlite_compileoption_used（）&lt;/a&gt;和&lt;a href=&quot;lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get（）&lt;/a&gt; SQL函数以及&lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="38860900c0578b43980895e455bb7920237198bd" translate="yes" xml:space="preserve">
          <source>This option is used to omit the compound &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; functionality. &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements that use the UNION, UNION ALL, INTERSECT or EXCEPT compound SELECT operators will cause a parse error.</source>
          <target state="translated">此选项用于省略复合&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;功能。&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;是使用UNION，UNION ALL，INTERSECT或EXCEPT复合SELECT语句运营商将导致解析错误。</target>
        </trans-unit>
        <trans-unit id="1fef9193f2041138de94b7a55c6ac0d8866c0350" translate="yes" xml:space="preserve">
          <source>This option is used to specify additional unicode characters that should be considered as separator characters, even if they are token characters according to Unicode 6.1. All characters in the string that this option is set to are considered separators.</source>
          <target state="translated">这个选项用来指定额外的unicode字符,即使它们是Unicode 6.1的标记字符,也应该被视为分隔符。该选项设置的字符串中的所有字符都被视为分隔符。</target>
        </trans-unit>
        <trans-unit id="b4d01f5260497e72988e92e809b28f4e71ef175b" translate="yes" xml:space="preserve">
          <source>This option is used to specify additional unicode characters that should be considered token characters, even if they are white-space or punctuation characters according to Unicode 6.1. All characters in the string that this option is set to are considered token characters.</source>
          <target state="translated">这个选项用于指定额外的unicode字符,即使是Unicode 6.1规定的空白字符或标点符号,也应视为标记字符。该选项设置的字符串中的所有字符都被视为标记字符。</target>
        </trans-unit>
        <trans-unit id="c4a9266d00b4e2d968e68127ae9c3b66b98515c7" translate="yes" xml:space="preserve">
          <source>This option is used to specify the name of a column for which data is not indexed. Values stored in columns that are not indexed are not matched by MATCH queries. Nor are they recognized by auxiliary functions. A single CREATE VIRTUAL TABLE statement may have any number of notindexed options.</source>
          <target state="translated">这个选项用于指定数据未被索引的列的名称。存储在没有索引的列中的值不会被MATCH查询匹配,也不会被辅助函数识别。它们也不被辅助函数所识别。一条CREATE VIRTUAL TABLE语句可以有任意数量的不索引选项。</target>
        </trans-unit>
        <trans-unit id="4091aa76a32dd6eeb30d11ba0fc9616111651aa8" translate="yes" xml:space="preserve">
          <source>This option is used to specify the uncompress function. It is an error to specify an uncompress function without also specifying a compress function. &lt;a href=&quot;fts3#the_compress_and_uncompress_options&quot;&gt;See below&lt;/a&gt; for details.</source>
          <target state="translated">此选项用于指定解压缩功能。在不指定压缩功能的情况下指定解压缩功能是错误的。&lt;a href=&quot;fts3#the_compress_and_uncompress_options&quot;&gt;有关&lt;/a&gt;详情，请参见下文。</target>
        </trans-unit>
        <trans-unit id="27d1b2d9a48342fb7ec198ba4551e4f29a4a7923" translate="yes" xml:space="preserve">
          <source>This option is useful for detecting when applications (incorrectly) assume that the order of rows in a SELECT without an ORDER BY clause will always be the same.</source>
          <target state="translated">这个选项对于检测应用程序(不正确地)认为没有ORDER BY子句的SELECT中的行的顺序总是相同的情况很有用。</target>
        </trans-unit>
        <trans-unit id="b8889fe26abbab5acf6f1b3b96ae4522f63cbd2c" translate="yes" xml:space="preserve">
          <source>This option limits the maximum width and precision of substitutions for the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; and the other C-language string formatting functions such as &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; and &lt;a href=&quot;c3ref/str_append&quot;&gt;sqlite3_str_appendf()&lt;/a&gt;. This is turn can prevent a hostile or malfunctioning script from using excessive memory by invoking a format such as: &quot;&lt;code&gt;printf('%*s',2147483647,'hi')&lt;/code&gt;&quot;. A value for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="543b32c3fbd0d24e0024e6fd7c7c17a61e1a7b3f" translate="yes" xml:space="preserve">
          <source>This option limits the total amount of memory that SQLite will request from malloc() to</source>
          <target state="translated">这个选项将SQLite从malloc()请求的内存总量限制为</target>
        </trans-unit>
        <trans-unit id="0ff916221ebb2875958a4c995a621fdfe504377b" translate="yes" xml:space="preserve">
          <source>This option may be defined to omit the capability to issue &quot;progress&quot; callbacks during long-running SQL statements. The &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler()&lt;/a&gt; API function is not present in the library.</source>
          <target state="translated">可以定义此选项以省略在长时间运行的SQL语句期间发出&amp;ldquo;进度&amp;rdquo;回调的功能。该库中不存在&lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler（）&lt;/a&gt; API函数。</target>
        </trans-unit>
        <trans-unit id="fec09e7b8a97b18d234467bbff1f92f5f877270a" translate="yes" xml:space="preserve">
          <source>This option may be set to a comma-separated list of positive non-zero integers. For each integer N in the list, a separate index is created in the database file to optimize &lt;a href=&quot;fts3#termprefix&quot;&gt;prefix queries&lt;/a&gt; where the query term is N bytes in length, not including the '*' character, when encoded using UTF-8. &lt;a href=&quot;fts3#the_prefix_option&quot;&gt;See below&lt;/a&gt; for details.</source>
          <target state="translated">可以将此选项设置为以逗号分隔的正非零整数列表。对于列表中的每个整数N ，在使用UTF-8进行编码时，都会在数据库文件中创建一个单独的索引以优化&lt;a href=&quot;fts3#termprefix&quot;&gt;前缀查询&lt;/a&gt;，其中查询项的长度为N个字节，不包括'*'字符。&lt;a href=&quot;fts3#the_prefix_option&quot;&gt;有关&lt;/a&gt;详情，请参见下文。</target>
        </trans-unit>
        <trans-unit id="8c9f3ac023e577c95d719f9b2c33d97d1a3da596" translate="yes" xml:space="preserve">
          <source>This option may be used to modify the set of Unicode general categories that are considered to correspond to token characters. The argument must consist of a space separated list of two-character general category abbreviations (e.g. &quot;Lu&quot; or &quot;Nd&quot;), or of the same with the second character replaced with an asterisk (&quot;*&quot;), interpreted as a glob pattern. The default value is &quot;L* N* Co&quot;.</source>
          <target state="translated">这个选项可以用来修改Unicode通用类别的集合,这些通用类别被认为是与标记字符相对应的。参数必须包含一个以空格分隔的双字符通用类别缩写列表(如 &quot;Lu &quot;或 &quot;Nd&quot;),或以星号(&quot;*&quot;)代替第二个字符,并解释为glob模式。默认值是 &quot;L*N*Co&quot;。</target>
        </trans-unit>
        <trans-unit id="9c262753dfc8e34d6477e70174470eb22dfb8f78" translate="yes" xml:space="preserve">
          <source>This option modifies the query pattern parser in FTS3 such that it supports operators AND and NOT (in addition to the usual OR and NEAR) and also allows query expressions to contain nested parenthesis.</source>
          <target state="translated">这个选项修改了FTS3中的查询模式分析器,使其支持运算符AND和NOT(除了通常的OR和NEAR),并允许查询表达式包含嵌套小括号。</target>
        </trans-unit>
        <trans-unit id="6d1184a1fad2aaee9c295bffada9d4dba260e364" translate="yes" xml:space="preserve">
          <source>This option omits all support for writing to the disk and forces databases to exist in memory only. This option has not been maintained and probably does not work with newer versions of SQLite.</source>
          <target state="translated">这个选项省略了对写入磁盘的所有支持,并强制数据库只存在于内存中。这个选项没有被维护过,可能在较新版本的SQLite中不起作用。</target>
        </trans-unit>
        <trans-unit id="50a1abc30b4ee91bf9953df50f6ee0d6dc4cb18c" translate="yes" xml:space="preserve">
          <source>This option omits an alternative, faster B-Tree balancing routine. Using this option makes SQLite slightly smaller at the expense of making it run slightly slower.</source>
          <target state="translated">这个选项省略了一个替代的、更快的B-Tree平衡例程。使用这个选项可以使SQLite的体积略微变小,但代价是使其运行速度略微变慢。</target>
        </trans-unit>
        <trans-unit id="d570b3f8ad95b26858fd7fbeddae0dd0f1ac312a" translate="yes" xml:space="preserve">
          <source>This option omits both the &lt;a href=&quot;malloc#defaultalloc&quot;&gt;default memory allocator&lt;/a&gt; and the &lt;a href=&quot;malloc#memdebug&quot;&gt;debugging memory allocator&lt;/a&gt; from the build and substitutes a stub memory allocator that always fails. SQLite will not run with this stub memory allocator since it will be unable to allocate memory. But this stub can be replaced at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;,...) or &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;,...). So the net effect of this compile-time option is that it allows SQLite to be compiled and linked against a system library that does not support malloc(), free(), and/or realloc().</source>
          <target state="translated">此选项从构建中忽略&lt;a href=&quot;malloc#defaultalloc&quot;&gt;默认的内存分配器&lt;/a&gt;和&lt;a href=&quot;malloc#memdebug&quot;&gt;调试内存分配器&lt;/a&gt;，并替换始终失败的存根内存分配器。 SQLite将无法使用此存根内存分配器运行，因为它将无法分配内存。但是可以在开始时使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;，...）或&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;，...）替换此存根。因此，此编译时选项的最终效果是，它允许对不支持malloc（），free（）和/或realloc（）的系统库进行编译和链接。</target>
        </trans-unit>
        <trans-unit id="5550296bc5b898d8389bff0bafe61564efcdf3d2" translate="yes" xml:space="preserve">
          <source>This option omits support for &lt;a href=&quot;lang_expr#hexint&quot;&gt;hexadecimal integer literals&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f67843c3cb518fbe115dfafaf7514809b870ff9" translate="yes" xml:space="preserve">
          <source>This option omits support for &lt;a href=&quot;pragma#pragma_function_list&quot;&gt;PRAGMA function_list&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_module_list&quot;&gt;PRAGMA module_list&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_pragma_list&quot;&gt;PRAGMA pragma_list&lt;/a&gt;.</source>
          <target state="translated">此选项省略了支持&lt;a href=&quot;pragma#pragma_function_list&quot;&gt;PRAGMA function_list&lt;/a&gt;，&lt;a href=&quot;pragma#pragma_module_list&quot;&gt;PRAGMA MODULE_LIST&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_pragma_list&quot;&gt;PRAGMA pragma_list&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a55821b0db5795de6378b285741aad2fe64bd6fd" translate="yes" xml:space="preserve">
          <source>This option omits support for TEMP or TEMPORARY tables.</source>
          <target state="translated">这个选项省略了对TEMP或TEMPORARY表的支持。</target>
        </trans-unit>
        <trans-unit id="75dd747eb6da7034a4b5f9d3b3a93668de880788" translate="yes" xml:space="preserve">
          <source>This option omits support for a subset of &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; commands that query and set boolean properties.</source>
          <target state="translated">此选项省略了对查询和设置布尔属性的&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;命令子集的支持。</target>
        </trans-unit>
        <trans-unit id="1e296396a40210ed6c66f92e2002f5643c4f4856" translate="yes" xml:space="preserve">
          <source>This option omits support for optimizations that help statements of the form &quot;INSERT INTO ... SELECT ...&quot; run faster.</source>
          <target state="translated">这个选项省略了对优化的支持,这些优化有助于 &quot;INSERT INTO ....SELECT ...&quot;这样的语句运行速度更快。</target>
        </trans-unit>
        <trans-unit id="c9bd65d56ee2206a853b54ac9d65ed0eaccc6228" translate="yes" xml:space="preserve">
          <source>This option omits support for the &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_profile()&lt;/a&gt; and &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; interfaces and their associated logic.</source>
          <target state="translated">此选项省略了对&lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_profile（）&lt;/a&gt;和&lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace（）&lt;/a&gt;接口及其关联逻辑的支持。</target>
        </trans-unit>
        <trans-unit id="a30f0d1d064421d344c9b42be2dca6717bf88cb6" translate="yes" xml:space="preserve">
          <source>This option omits support for the &lt;a href=&quot;c3ref/vtab&quot;&gt;Virtual Table&lt;/a&gt; mechanism in SQLite.</source>
          <target state="translated">此选项省略了对SQLite中的&lt;a href=&quot;c3ref/vtab&quot;&gt;虚拟表&lt;/a&gt;机制的支持。</target>
        </trans-unit>
        <trans-unit id="26d721f7d82f01b797a61e0e7e4801b3ecce9f78" translate="yes" xml:space="preserve">
          <source>This option omits support for the &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check pragma&lt;/a&gt;.</source>
          <target state="translated">此选项省略了对&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check pragma的&lt;/a&gt;支持。</target>
        </trans-unit>
        <trans-unit id="39729a96f5a26c118c51c00f252de6a1bfa6274f" translate="yes" xml:space="preserve">
          <source>This option omits the &quot;&lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;&quot; (a.k.a. &quot;&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;&quot;) capability.</source>
          <target state="translated">该选项省略了&amp;ldquo; &lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt; &amp;rdquo;（又名&amp;ldquo; &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; &amp;rdquo;）功能。</target>
        </trans-unit>
        <trans-unit id="7b6f231803998cf650a2af3d3a3a9b9230f13c79" translate="yes" xml:space="preserve">
          <source>This option omits the &quot;localtime&quot; modifier from the date and time functions. This option is sometimes useful when trying to compile the date and time functions on a platform that does not support the concept of local time.</source>
          <target state="translated">这个选项省略了日期和时间函数中的 &quot;localtime &quot;修饰符。在不支持当地时间概念的平台上编译日期和时间函数时,这个选项有时会很有用。</target>
        </trans-unit>
        <trans-unit id="d15a997b56bb6d2881d721f3ab9c998f9a495874" translate="yes" xml:space="preserve">
          <source>This option omits the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt;.</source>
          <target state="translated">此选项省略了&lt;a href=&quot;malloc#lookaside&quot;&gt;后备内存分配器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="71559f53bbfd877c056bb7c4c6ba8f68a92f4b43" translate="yes" xml:space="preserve">
          <source>This option omits the entire extension loading mechanism from SQLite, including &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; and &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interfaces.</source>
          <target state="translated">此选项忽略了SQLite的整个扩展加载机制，包括&lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）&lt;/a&gt;和&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="d584fb7ba86013ad6f07889a83d2808e572dd20a" translate="yes" xml:space="preserve">
          <source>This option sets the size limit on &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; files in &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;persistent journal mode&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; and on the size of the write-ahead log file in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. When this compile-time option is omitted there is no upper bound on the size of the rollback journals or write-ahead logs. The journal file size limit can be changed at run-time using the &lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;journal_size_limit pragma&lt;/a&gt;.</source>
          <target state="translated">此选项在&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;持久日志模式&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;排他锁定模式下&lt;/a&gt;设置&lt;a href=&quot;lockingv3#rollback&quot;&gt;回滚日志&lt;/a&gt;文件的大小限制，在&lt;a href=&quot;wal&quot;&gt;WAL模式下设置&lt;/a&gt;预写日志文件的大小限制。省略此编译时选项时，回滚日志或预写日志的大小没有上限。日志文件大小限制可以在运行时使用&lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;journal_size_limit pragma&lt;/a&gt;更改。</target>
        </trans-unit>
        <trans-unit id="a7ed22f566a23185b972efa8699f5831a4e8d150" translate="yes" xml:space="preserve">
          <source>This option should be set to &quot;0&quot;, &quot;1&quot; or &quot;2&quot;. The default value is &quot;1&quot;. If it is set to &quot;1&quot; or &quot;2&quot;, then diacritics are removed from Latin script characters as described above. However, if it is set to &quot;1&quot;, then diacritics are not removed in the fairly uncommon case where a single unicode codepoint is used to represent a character with more that one diacritic. For example, diacritics are not removed from codepoint 0x1ED9 (&quot;LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW&quot;). This is technically a bug, but cannot be fixed without creating backwards compatibility problems. If this option is set to &quot;2&quot;, then diacritics are correctly removed from all Latin characters.</source>
          <target state="translated">该选项应设置为 &quot;0&quot;、&quot;1 &quot;或 &quot;2&quot;。默认值是 &quot;1&quot;。如果它被设置为 &quot;1 &quot;或 &quot;2&quot;,那么拉丁字母字符中的双标点符号将如上所述被移除。然而,如果它被设置为 &quot;1&quot;,那么在相当少见的情况下,当一个单一的unicode码点被用来表示一个有多个重音符号的字符时,重音符号就不会被移除。例如,在代码点0x1ED9(&quot;LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW&quot;)中没有去除双音符。这在技术上是一个错误,但如果不造成向后的兼容性问题,就无法修复。如果这个选项被设置为 &quot;2&quot;,那么所有拉丁字符中的双音符就会被正确地删除。</target>
        </trans-unit>
        <trans-unit id="feb5bc303a82732e4bebbca22fa198d9bb5a37e5" translate="yes" xml:space="preserve">
          <source>This option takes three additional arguments that determine the &lt;a href=&quot;../malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; configuration for the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument (the third parameter to &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; is a pointer to a memory buffer to use for lookaside memory. The first argument after the SQLITE_DBCONFIG_LOOKASIDE verb may be NULL in which case SQLite will allocate the lookaside buffer itself using &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The second argument is the size of each lookaside buffer slot. The third argument is the number of slots. The size of the buffer in the first argument must be greater than or equal to the product of the second and third arguments. The buffer must be aligned to an 8-byte boundary. If the second argument to SQLITE_DBCONFIG_LOOKASIDE is not a multiple of 8, it is internally rounded down to the next smaller multiple of 8. The lookaside memory configuration for a database connection can only be changed when that connection is not currently using lookaside memory, or in other words when the &quot;current value&quot; returned by &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status&lt;/a&gt;(D,&lt;a href=&quot;c_config_covering_index_scan#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt;,...) is zero. Any attempt to change the lookaside memory configuration when lookaside memory is in use leaves the configuration unchanged and returns &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="translated">此选项采用三个附加参数来确定&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;的&lt;a href=&quot;../malloc#lookaside&quot;&gt;后备内存分配器&lt;/a&gt;配置。第一个参数（&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;的第三个参数是指向用于后备内存的内存缓冲区的指针。SQLITE_DBCONFIG_LOOKASIDE动词后的第一个参数可能为NULL，在这种情况下，SQLite将使用&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;分配后备缓冲区本身。。第二个参数是每个后备缓冲区的大小。第三个参数是插槽数。第一个参数中的缓冲区大小必须大于或等于第二个和第三个参数的乘积。缓冲区必须与8字节边界对齐。如果SQLITE_DBCONFIG_LOOKASIDE的第二个参数不是8的倍数，它会在内部舍入为8的下一个较小倍数。仅当数据库连接的后备内存配置当前未使用后备内存时，才可以更改该数据库连接的后备内存配置。换句话说，当&lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status&lt;/a&gt;返回的&amp;ldquo;当前值&amp;rdquo; （D，&lt;a href=&quot;c_config_covering_index_scan#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt;，...）为零。在使用后备内存时，任何更改后备内存配置的尝试都&lt;a href=&quot;../rescode#busy&quot;&gt;将使&lt;/a&gt;配置保持不变，并返回SQLITE_BUSY。</target>
        </trans-unit>
        <trans-unit id="ae3ddbf7ef0dc412e99f290afefb3dbddaa1ab55" translate="yes" xml:space="preserve">
          <source>This option takes three additional arguments that determine the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; configuration for the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument (the third parameter to &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; is a pointer to a memory buffer to use for lookaside memory. The first argument after the SQLITE_DBCONFIG_LOOKASIDE verb may be NULL in which case SQLite will allocate the lookaside buffer itself using &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The second argument is the size of each lookaside buffer slot. The third argument is the number of slots. The size of the buffer in the first argument must be greater than or equal to the product of the second and third arguments. The buffer must be aligned to an 8-byte boundary. If the second argument to SQLITE_DBCONFIG_LOOKASIDE is not a multiple of 8, it is internally rounded down to the next smaller multiple of 8. The lookaside memory configuration for a database connection can only be changed when that connection is not currently using lookaside memory, or in other words when the &quot;current value&quot; returned by &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status&lt;/a&gt;(D,&lt;a href=&quot;#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt;,...) is zero. Any attempt to change the lookaside memory configuration when lookaside memory is in use leaves the configuration unchanged and returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="translated">此选项采用三个附加参数来确定&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;的&lt;a href=&quot;malloc#lookaside&quot;&gt;后备内存分配器&lt;/a&gt;配置。第一个参数（&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;的第三个参数是指向用于后备内存的内存缓冲区的指针。SQLITE_DBCONFIG_LOOKASIDE动词后的第一个参数可能为NULL，在这种情况下，SQLite将使用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;分配后备缓冲区本身。。第二个参数是每个后备缓冲区的大小。第三个参数是插槽数。第一个参数中的缓冲区大小必须大于或等于第二个和第三个参数的乘积。缓冲区必须与8字节边界对齐。如果SQLITE_DBCONFIG_LOOKASIDE的第二个参数不是8的倍数，它会在内部舍入为8的下一个较小倍数。仅当数据库连接的后备内存配置当前未使用后备内存时，才可以更改该数据库连接的后备内存配置。换句话说，当&lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status&lt;/a&gt;返回的&amp;ldquo;当前值&amp;rdquo; （D，&lt;a href=&quot;#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt;，...）为零。在使用后备内存时，任何更改后备内存配置的尝试都&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;将使&lt;/a&gt;配置保持不变，并返回SQLITE_BUSY。</target>
        </trans-unit>
        <trans-unit id="ba38f20f7029807295f199c46762e2a8e9ec46b2" translate="yes" xml:space="preserve">
          <source>This page contains all C-language interface information in a single HTML file. The same information is also available broken out into &lt;a href=&quot;https://sqlite.org/session/intro.html&quot;&gt;lots of small pages&lt;/a&gt; for easier viewing, if you prefer.</source>
          <target state="translated">此页面在单个HTML文件中包含所有C语言界面信息。如果您愿意，也可以将相同的信息分成&lt;a href=&quot;https://sqlite.org/session/intro.html&quot;&gt;很多小页面&lt;/a&gt;，以便于查看。</target>
        </trans-unit>
        <trans-unit id="c894452ecdb5719e75b3532de3158fbd553c90da" translate="yes" xml:space="preserve">
          <source>This page defines the C-language interface to the SQLite &lt;a href=&quot;sessionintro&quot;&gt;session extension&lt;/a&gt;. This is not a tutorial. These pages are designed to be precise, not easy to read. A tutorial is &lt;a href=&quot;sessionintro&quot;&gt;available separately&lt;/a&gt;.</source>
          <target state="translated">该页面定义了SQLite &lt;a href=&quot;sessionintro&quot;&gt;会话扩展&lt;/a&gt;的C语言接口。这不是教程。这些页面设计得很精确，不容易阅读。教程&lt;a href=&quot;sessionintro&quot;&gt;可单独获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="17b8a8f3cb3fe57cc88a96142bed282e75d22786" translate="yes" xml:space="preserve">
          <source>This page demonstrates how to use triggers to implement undo/redo logic for an application that uses SQLite as its &lt;a href=&quot;appfileformat&quot;&gt;application file format&lt;/a&gt;.</source>
          <target state="translated">该页面演示了如何使用触发器为使用SQLite作为其&lt;a href=&quot;appfileformat&quot;&gt;应用程序文件格式&lt;/a&gt;的应用程序实现撤消/重做逻辑。</target>
        </trans-unit>
        <trans-unit id="e34958625ac04bc1ac3a1a6e0735cfa01d4d7986" translate="yes" xml:space="preserve">
          <source>This page highlights some of the characteristics of SQLite that are unusual and which make SQLite different from many other SQL database engines.</source>
          <target state="translated">本页重点介绍了SQLite的一些不同寻常的特性,这些特性使得SQLite与许多其他SQL数据库引擎不同。</target>
        </trans-unit>
        <trans-unit id="c95782bb823ae8ab36f53a6f092ceeb01d076bbe" translate="yes" xml:space="preserve">
          <source>This page is intended to be a precise and detailed specification. For a tutorial introductions, see instead:</source>
          <target state="translated">本页旨在精确和详细的规范。关于教程介绍,请参见。</target>
        </trans-unit>
        <trans-unit id="fbcb2c48721c5a151bcbee73ca17847e3bcd77c1" translate="yes" xml:space="preserve">
          <source>This page provides a high-level summary of changes to SQLite. For more detail, see the Fossil checkin logs at &lt;a href=&quot;http://www.sqlite.org/src/timeline&quot;&gt; http://www.sqlite.org/src/timeline&lt;/a&gt; and &lt;a href=&quot;http://www.sqlite.org/src/timeline?t=release&quot;&gt; http://www.sqlite.org/src/timeline?t=release&lt;/a&gt;. See the &lt;a href=&quot;https://sqlite.org/chronology.html&quot;&gt;chronology&lt;/a&gt; a succinct listing of releases.</source>
          <target state="translated">此页面提供了SQLite更改的高级摘要。有关更多详细信息，请参见&lt;a href=&quot;http://www.sqlite.org/src/timeline&quot;&gt;http://www.sqlite.org/src/timeline&lt;/a&gt;和&lt;a href=&quot;http://www.sqlite.org/src/timeline?t=release&quot;&gt;http://www.sqlite.org/src/timeline?t=release上&lt;/a&gt;的Fossil签入日志。请&lt;a href=&quot;https://sqlite.org/chronology.html&quot;&gt;按时间顺序&lt;/a&gt;简要列出发行版。</target>
        </trans-unit>
        <trans-unit id="5475000272cca06dc30e6a01a60b47e85642d9ec" translate="yes" xml:space="preserve">
          <source>This parameter is similar to DBSTATUS_CACHE_USED, except that if a pager cache is shared between two or more connections the bytes of heap memory used by that pager cache is divided evenly between the attached connections. In other words, if none of the pager caches associated with the database connection are shared, this request returns the same value as DBSTATUS_CACHE_USED. Or, if one or more or the pager caches are shared, the value returned by this call will be smaller than that returned by DBSTATUS_CACHE_USED. The highwater mark associated with SQLITE_DBSTATUS_CACHE_USED_SHARED is always 0.</source>
          <target state="translated">这个参数与DBSTATUS_CACHE_USED类似,不同的是,如果一个寻呼机缓存在两个或多个连接之间共享,那么该寻呼机缓存所使用的堆内存字节将在所连接的连接之间平均分配。换句话说,如果与数据库连接相关的寻呼机缓存都不共享,这个请求返回的值与DBSTATUS_CACHE_USED相同。或者,如果一个或多个或寻呼机缓存是共享的,这个调用返回的值将小于DBSTATUS_CACHE_USED返回的值。与SQLITE_DBSTATUS_CACHE_USED_SHARED相关联的高水位标志总是0。</target>
        </trans-unit>
        <trans-unit id="45093e4716ae49eb14650b76fbdcb71b112d6752" translate="yes" xml:space="preserve">
          <source>This parameter is the current amount of memory checked out using &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, either directly or indirectly. The figure includes calls made to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; by the application and internal memory usage by the SQLite library. Auxiliary page-cache memory controlled by &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; is not included in this parameter. The amount returned is the sum of the allocation sizes as reported by the xSize method in &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;.</source>
          <target state="translated">此参数是使用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;直接或间接检出的当前内存量。该图包括应用程序对&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;的调用以及SQLite库对内部内存的使用。由&lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;控制的辅助页面高速缓存存储器不包括在此参数中。返回的数量是xsize方法在&lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods中&lt;/a&gt;报告的分配大小的总和。</target>
        </trans-unit>
        <trans-unit id="01bdf9cb94894d18cc4c5e31ed1dd67a9595bbe8" translate="yes" xml:space="preserve">
          <source>This parameter is the current amount of memory checked out using &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, either directly or indirectly. The figure includes calls made to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; by the application and internal memory usage by the SQLite library. Auxiliary page-cache memory controlled by &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; is not included in this parameter. The amount returned is the sum of the allocation sizes as reported by the xSize method in &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;.</source>
          <target state="translated">此参数是使用&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;直接或间接检出的当前内存量。该图包括应用程序对&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;的调用以及SQLite库对内部内存的使用。由&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;控制的辅助页面高速缓存存储器不包括在此参数中。返回的数量是xsize方法在&lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods中&lt;/a&gt;报告的分配大小的总和。</target>
        </trans-unit>
        <trans-unit id="87bf008f327b3b848c63d8cad43c4d0127a86a19" translate="yes" xml:space="preserve">
          <source>This parameter records the largest memory allocation request handed to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; (or their internal equivalents). Only the value returned in the *pHighwater parameter to &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status()&lt;/a&gt; is of interest. The value written into the *pCurrent parameter is undefined.</source>
          <target state="translated">此参数记录传递给&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;（或其内部等效项）的最大内存分配请求。仅关注* p​​Highwater参数中返回给&lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status（）的&lt;/a&gt;值。写入* pCurrent参数的值是不确定的。</target>
        </trans-unit>
        <trans-unit id="b8177250f0bf5e0ac2bcf219826fc36ccb3e8b06" translate="yes" xml:space="preserve">
          <source>This parameter records the largest memory allocation request handed to &lt;a href=&quot;../malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;. Only the value returned in the *pHighwater parameter to &lt;a href=&quot;status&quot;&gt;sqlite3_status()&lt;/a&gt; is of interest. The value written into the *pCurrent parameter is undefined.</source>
          <target state="translated">此参数记录传递给&lt;a href=&quot;../malloc#pagecache&quot;&gt;pagecache内存分配器&lt;/a&gt;的最大内存分配请求。仅关注* p​​Highwater参数中返回给&lt;a href=&quot;status&quot;&gt;sqlite3_status（）的&lt;/a&gt;值。写入* pCurrent参数的值是不确定的。</target>
        </trans-unit>
        <trans-unit id="393f3b702f2e6c0a4e019aad1ee82b57fe72cd84" translate="yes" xml:space="preserve">
          <source>This parameter records the largest memory allocation request handed to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; (or their internal equivalents). Only the value returned in the *pHighwater parameter to &lt;a href=&quot;status&quot;&gt;sqlite3_status()&lt;/a&gt; is of interest. The value written into the *pCurrent parameter is undefined.</source>
          <target state="translated">此参数记录传递给&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;或&lt;a href=&quot;free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;（或其内部等效项）的最大内存分配请求。仅关注* p​​Highwater参数中返回给&lt;a href=&quot;status&quot;&gt;sqlite3_status（）的&lt;/a&gt;值。写入* pCurrent参数的值是不确定的。</target>
        </trans-unit>
        <trans-unit id="564d1fbcfc60fdaedbed1032bf2fd462555b60f6" translate="yes" xml:space="preserve">
          <source>This parameter records the largest memory allocation request handed to &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;. Only the value returned in the *pHighwater parameter to &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status()&lt;/a&gt; is of interest. The value written into the *pCurrent parameter is undefined.</source>
          <target state="translated">此参数记录传递给&lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache内存分配器&lt;/a&gt;的最大内存分配请求。仅关注* p​​Highwater参数中返回给&lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status（）的&lt;/a&gt;值。写入* pCurrent参数的值是不确定的。</target>
        </trans-unit>
        <trans-unit id="64d736a9df1c88312c645f6820d596570b17758b" translate="yes" xml:space="preserve">
          <source>This parameter records the largest memory allocation request handed to the &lt;a href=&quot;../malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;. Only the value returned in the *pHighwater parameter to &lt;a href=&quot;status&quot;&gt;sqlite3_status()&lt;/a&gt; is of interest. The value written into the *pCurrent parameter is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f746ca9a95438a262dd8ecb82737decdd93a0a" translate="yes" xml:space="preserve">
          <source>This parameter records the largest memory allocation request handed to the &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;. Only the value returned in the *pHighwater parameter to &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status()&lt;/a&gt; is of interest. The value written into the *pCurrent parameter is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e7936cbdee9e2eb1bb98fbfe6edbf522e37ef4" translate="yes" xml:space="preserve">
          <source>This parameter records the number of separate memory allocations currently checked out.</source>
          <target state="translated">该参数记录了当前签出的独立内存分配数量。</target>
        </trans-unit>
        <trans-unit id="cf9c08cd996cbec55637b0a188d75a636f637583" translate="yes" xml:space="preserve">
          <source>This parameter returns the approximate number of bytes of heap and lookaside memory used by all prepared statements associated with the database connection. The highwater mark associated with SQLITE_DBSTATUS_STMT_USED is always 0.</source>
          <target state="translated">这个参数返回与数据库连接相关联的所有准备好的语句所使用的堆和lookaside内存的大约字节数。与SQLITE_DBSTATUS_STMT_USED相关联的高水位标志总是0。</target>
        </trans-unit>
        <trans-unit id="ec61ce5ecfd88d74d32d14b1a1a33c077c0d1415" translate="yes" xml:space="preserve">
          <source>This parameter returns the approximate number of bytes of heap memory used by all pager caches associated with the database connection. The highwater mark associated with SQLITE_DBSTATUS_CACHE_USED is always 0.</source>
          <target state="translated">这个参数返回与数据库连接相关联的所有寻呼机缓存所使用的堆内存的大概字节数。与SQLITE_DBSTATUS_CACHE_USED相关联的高水位标志总是0。</target>
        </trans-unit>
        <trans-unit id="f3bc4fe0cf826c482abac176d6762a6d942bb530" translate="yes" xml:space="preserve">
          <source>This parameter returns the approximate number of bytes of heap memory used to store the schema for all databases associated with the connection - main, temp, and any &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed databases. The full amount of memory used by the schemas is reported, even if the schema memory is shared with other database connections due to &lt;a href=&quot;../sharedcache&quot;&gt;shared cache mode&lt;/a&gt; being enabled. The highwater mark associated with SQLITE_DBSTATUS_SCHEMA_USED is always 0.</source>
          <target state="translated">此参数返回用于存储与连接关联的所有数据库（主数据库，临时数据库和任何&lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;数据库）的模式的堆内存的大约字节数。即使由于启用了&lt;a href=&quot;../sharedcache&quot;&gt;共享缓存模式&lt;/a&gt;而与其他数据库连接共享架构内存，也会报告架构使用的内存总量。与SQLITE_DBSTATUS_SCHEMA_USED关联的高水位线始终为0。</target>
        </trans-unit>
        <trans-unit id="b848e7fbcecb9e3547155ffa2bb4d624a93e8ec6" translate="yes" xml:space="preserve">
          <source>This parameter returns the approximate number of bytes of heap memory used to store the schema for all databases associated with the connection - main, temp, and any &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed databases. The full amount of memory used by the schemas is reported, even if the schema memory is shared with other database connections due to &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; being enabled. The highwater mark associated with SQLITE_DBSTATUS_SCHEMA_USED is always 0.</source>
          <target state="translated">此参数返回用于存储与连接关联的所有数据库（主数据库，临时数据库和任何&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;数据库）的模式的堆内存的大约字节数。即使由于启用了&lt;a href=&quot;sharedcache&quot;&gt;共享缓存模式&lt;/a&gt;而与其他数据库连接共享架构内存，也会报告架构使用的内存总量。与SQLITE_DBSTATUS_SCHEMA_USED关联的高水位线始终为0。</target>
        </trans-unit>
        <trans-unit id="a6814e9402bd718137686f1d55de51f53b7d680a" translate="yes" xml:space="preserve">
          <source>This parameter returns the number malloc attempts that might have been satisfied using lookaside memory but failed due to all lookaside memory already being in use. Only the high-water value is meaningful; the current value is always zero.</source>
          <target state="translated">这个参数返回可能使用lookaside内存满足的malloc尝试次数,但由于所有lookaside内存已经被使用而失败。只有高水位值才有意义,当前值始终为零。</target>
        </trans-unit>
        <trans-unit id="a0c69cbe3d9c323ac8bc99255ae1a5f0fdf34b7a" translate="yes" xml:space="preserve">
          <source>This parameter returns the number malloc attempts that might have been satisfied using lookaside memory but failed due to the amount of memory requested being larger than the lookaside slot size. Only the high-water value is meaningful; the current value is always zero.</source>
          <target state="translated">这个参数返回使用lookaside内存可能满足的malloc尝试次数,但由于请求的内存量大于lookaside插槽大小而失败。只有高水位值才有意义,当前值始终为零。</target>
        </trans-unit>
        <trans-unit id="784f52e8abbe06e6dd208856ce82a30603bacb4b" translate="yes" xml:space="preserve">
          <source>This parameter returns the number malloc attempts that were satisfied using lookaside memory. Only the high-water value is meaningful; the current value is always zero.</source>
          <target state="translated">这个参数返回使用lookaside内存满足的malloc尝试次数。只有高水位值才有意义,当前值始终为零。</target>
        </trans-unit>
        <trans-unit id="cc0e40686d40fc1dc39dc4ea777a5b751b8b8271" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of bytes of page cache allocation which could not be satisfied by the &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; buffer and where forced to overflow to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The returned value includes allocations that overflowed because they where too large (they were larger than the &quot;sz&quot; parameter to &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;) and allocations that overflowed because no space was left in the page cache.</source>
          <target state="translated">此参数返回&lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;缓冲区无法满足的页面高速缓存分配的字节数，并强制将其溢出到&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;。返回的值包括由于分配太大而溢出的分配（它们大于&lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;的&amp;ldquo; sz&amp;rdquo;参数）和由于页面高速缓存中没有剩余空间而导致分配溢出的分配。</target>
        </trans-unit>
        <trans-unit id="1df7262bbdc4130b7cdd11ed7c458ceceae08c22" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of bytes of page cache allocation which could not be satisfied by the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; buffer and where forced to overflow to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The returned value includes allocations that overflowed because they where too large (they were larger than the &quot;sz&quot; parameter to &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;) and allocations that overflowed because no space was left in the page cache.</source>
          <target state="translated">此参数返回&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;缓冲区无法满足的页面高速缓存分配的字节数，并强制将其溢出到&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;。返回的值包括由于分配太大而溢出的分配（它们大于&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;的&amp;ldquo; sz&amp;rdquo;参数）和由于页面高速缓存中没有剩余空间而导致分配溢出的分配。</target>
        </trans-unit>
        <trans-unit id="b382d85f918ffb35600f5c2612295ce2f5d3c59a" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of dirty cache entries that have been written to disk in the middle of a transaction due to the page cache overflowing. Transactions are more efficient if they are written to disk all at once. When pages spill mid-transaction, that introduces additional overhead. This parameter can be used help identify inefficiencies that can be resolve by increasing the cache size.</source>
          <target state="translated">该参数返回在事务中间由于页面缓存溢出而被写入磁盘的脏缓存条目数。如果事务一次全部写入磁盘,效率会更高。当页面在事务中间溢出时,会带来额外的开销。这个参数可以用来帮助识别效率低下的情况,可以通过增加缓存大小来解决。</target>
        </trans-unit>
        <trans-unit id="3475d60ae6206bcbd673ce958d5051acadbef20d" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of dirty cache entries that have been written to disk in the middle of a transaction due to the page cache overflowing. Transactions are more efficient if they are written to disk all at once. When pages spill mid-transaction, that introduces additional overhead. This parameter can be used help identify inefficiencies that can be resolved by increasing the cache size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4add896ad21b8491b3b9cbc64b507c0e7d258f86" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of dirty cache entries that have been written to disk. Specifically, the number of pages written to the wal file in wal mode databases, or the number of pages written to the database file in rollback mode databases. Any pages written as part of transaction rollback or database recovery operations are not included. If an IO or other error occurs while writing a page to disk, the effect on subsequent SQLITE_DBSTATUS_CACHE_WRITE requests is undefined. The highwater mark associated with SQLITE_DBSTATUS_CACHE_WRITE is always 0.</source>
          <target state="translated">该参数返回已写入磁盘的脏缓存条目数。具体来说,就是在wal模式数据库中写入wal文件的页数,或者在回滚模式数据库中写入数据库文件的页数。任何作为事务回滚或数据库恢复操作的一部分而写入的页数都不包括在内。如果在向磁盘写入页面时发生IO或其他错误,对后续SQLITE_DBSTATUS_CACHE_WRITE请求的影响是未定义的。与SQLITE_DBSTATUS_CACHE_WRITE相关联的高水位标记始终为0。</target>
        </trans-unit>
        <trans-unit id="69935728c544ae1a697199dc6c173a0425e6fda2" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of lookaside memory slots currently checked out.</source>
          <target state="translated">该参数返回当前签出的lookaside内存槽数。</target>
        </trans-unit>
        <trans-unit id="a266b665a2f2d9def7548328ed2be49c55b4af7e" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of malloc attempts that were satisfied using lookaside memory. Only the high-water value is meaningful; the current value is always zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8bdabdecaacb45640f2cbeb00ef8072cec5611a" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of pager cache hits that have occurred. The highwater mark associated with SQLITE_DBSTATUS_CACHE_HIT is always 0.</source>
          <target state="translated">这个参数返回已经发生的寻呼机缓存点击次数。与SQLITE_DBSTATUS_CACHE_HIT相关联的高水位标志总是0。</target>
        </trans-unit>
        <trans-unit id="a1a0936c69215c7750450f05188a928a77f51678" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of pager cache misses that have occurred. The highwater mark associated with SQLITE_DBSTATUS_CACHE_MISS is always 0.</source>
          <target state="translated">这个参数返回已经发生的寻呼机缓存错过的次数。与SQLITE_DBSTATUS_CACHE_MISS相关联的高水位标志总是0。</target>
        </trans-unit>
        <trans-unit id="62efb57b98feebe4577753d45e38ef4eace35cab" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of pages used out of the &lt;a href=&quot;../malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt; that was configured using &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The value returned is in pages, not in bytes.</source>
          <target state="translated">此参数返回使用&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;配置的页面&lt;a href=&quot;../malloc#pagecache&quot;&gt;缓存内存分配器&lt;/a&gt;中已使用的页面数。返回的值以页为单位，而不是以字节为单位。</target>
        </trans-unit>
        <trans-unit id="3d50e93c0353d6a987ae81a3f776523fd382a6cc" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of pages used out of the &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt; that was configured using &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The value returned is in pages, not in bytes.</source>
          <target state="translated">此参数返回使用&lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;配置的页面&lt;a href=&quot;malloc#pagecache&quot;&gt;缓存内存分配器&lt;/a&gt;中已使用的页面数。返回的值以页为单位，而不是以字节为单位。</target>
        </trans-unit>
        <trans-unit id="c53ec125616f6c12d3da713a54e88d2031114fcb" translate="yes" xml:space="preserve">
          <source>This parameter returns zero for the current value if and only if all foreign key constraints (deferred or immediate) have been resolved. The highwater mark is always 0.</source>
          <target state="translated">如果且仅当所有的外键约束(递延或即时)都已被解决,该参数对当前值返回0。高水位线始终为0。</target>
        </trans-unit>
        <trans-unit id="a9b0527c8ca1034e0c3fe99b84c3e116d1b7eb73" translate="yes" xml:space="preserve">
          <source>This particular upper bound is untested since the developers do not have access to hardware capable of reaching this limit. However, tests do verify that SQLite behaves correctly and sanely when a database reaches the maximum file size of the underlying filesystem (which is usually much less than the maximum theoretical database size) and when a database is unable to grow due to disk space exhaustion.</source>
          <target state="translated">这个特定的上限是未经测试的,因为开发人员无法获得能够达到这个极限的硬件。然而,测试确实验证了当数据库达到底层文件系统的最大文件大小(通常远小于数据库的最大理论大小),以及当数据库因磁盘空间耗尽而无法增长时,SQLite表现得正确而理智。</target>
        </trans-unit>
        <trans-unit id="81929be5939c881096cfb3fe31776e243ea07fe4" translate="yes" xml:space="preserve">
          <source>This pragma can be used to help the ANALYZE command run faster on large databases. The results of analysis are not as good when only part of each index is examined, but the results are usually good enough. Setting N to 100 or 1000 allows the ANALYZE command to run very quickly, even on multi-gigabyte database files. This pragma is particularly useful in combination with &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0657d8e0799efb6b3e706990d12dd141b3fb62ea" translate="yes" xml:space="preserve">
          <source>This pragma can only lower the heap limit, never raise it. The C-language interface &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64()&lt;/a&gt; must be used to raise the heap limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7efda67e025441ca7525899af5b6354ff74a512" translate="yes" xml:space="preserve">
          <source>This pragma causes the database connection on which it is invoked to free up as much memory as it can, by calling &lt;a href=&quot;c3ref/db_release_memory&quot;&gt;sqlite3_db_release_memory()&lt;/a&gt;.</source>
          <target state="translated">此编译指示通过调用&lt;a href=&quot;c3ref/db_release_memory&quot;&gt;sqlite3_db_release_memory（）使&lt;/a&gt;调用它的数据库连接释放尽可能多的内存。</target>
        </trans-unit>
        <trans-unit id="f69354dd852353205605bc71b9cf56c1b9de8e3e" translate="yes" xml:space="preserve">
          <source>This pragma does a low-level formatting and consistency check of the database. The integrity_check pragma look for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f777ea86721cabf6a34809d49c7198fa24090a8b" translate="yes" xml:space="preserve">
          <source>This pragma does an integrity check of the entire database. The integrity_check pragma looks for out-of-order records, missing pages, malformed records, missing index entries, and UNIQUE, CHECK, and NOT NULL constraint errors. If the integrity_check pragma finds problems, strings are returned (as multiple rows with a single column per row) which describe the problems. Pragma integrity_check will return at most</source>
          <target state="translated">这个pragma对整个数据库进行完整性检查。integrity_check pragma 会检查失序记录、缺页、畸形记录、缺失索引条目以及 UNIQUE、CHECK 和 NOT NULL 约束错误。如果 integrity_check pragma 发现了问题,就会返回描述问题的字符串(作为多行,每行一列)。参数 integrity_check 最多只能返回</target>
        </trans-unit>
        <trans-unit id="d85860b039a63de256f402e6d6762d68de4406bf" translate="yes" xml:space="preserve">
          <source>This pragma enables or disables the enforcement of CHECK constraints. The default setting is off, meaning that CHECK constraints are enforced by default.</source>
          <target state="translated">这个pragma启用或禁用CHECK约束的执行。默认设置是关闭,意味着CHECK约束条件是默认执行的。</target>
        </trans-unit>
        <trans-unit id="2c0f6dec458913f5b6b49b019227adc4aaee9eed" translate="yes" xml:space="preserve">
          <source>This pragma invokes the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64()&lt;/a&gt; interface with the argument N, if N is specified and N is a positive integer that is less than the current hard heap limit. The hard_heap_limit pragma always returns the same integer that would be returned by the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64&lt;/a&gt;(-1) C-language function. That is to say, it always returns the value of the hard heap limit that is set after any changes imposed by this PRAGMA.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc93e52c19bbd4f2114a2157aba5ec2280234488" translate="yes" xml:space="preserve">
          <source>This pragma invokes the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface with the argument N, if N is specified and is a non-negative integer. The soft_heap_limit pragma always returns the same integer that would be returned by the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64&lt;/a&gt;(-1) C-language function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bacd85c546ef4ea41bfa44a9338d7347c9ec6db4" translate="yes" xml:space="preserve">
          <source>This pragma invokes the &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface with the argument N, if N is specified and is a non-negative integer. The soft_heap_limit pragma always returns the same integer that would be returned by the &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64&lt;/a&gt;(-1) C-language function.</source>
          <target state="translated">如果指定N并且它是一个非负整数，则该编译指示使用参数N 调用&lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64（）&lt;/a&gt;接口。soft_heap_limit杂注总是返回与&lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64&lt;/a&gt;（-1）C语言函数返回的整数相同的整数。</target>
        </trans-unit>
        <trans-unit id="e5367a74af180a6816189a47cadfc307e646cf0c" translate="yes" xml:space="preserve">
          <source>This pragma is a no-op within a transaction; foreign key constraint enforcement may only be enabled or disabled when there is no pending &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; or &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;.</source>
          <target state="translated">这种语用是交易中的禁忌。仅当没有待处理的&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;或&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;时，才可以启用或禁用外键约束强制。</target>
        </trans-unit>
        <trans-unit id="7664f5360eeae6cb14733319d33c60e55709bd68" translate="yes" xml:space="preserve">
          <source>This pragma is a thin wrapper around the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt;,...) interface.</source>
          <target state="translated">该&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;实用&lt;/a&gt;程序是&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，SQLITE_LIMIT_WORKER_THREADS，...）接口周围的薄包装。</target>
        </trans-unit>
        <trans-unit id="db34d966e31d8d00cada3d5a5b19ca1db1e53aa4" translate="yes" xml:space="preserve">
          <source>This pragma is a wrapper around the &lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint()&lt;/a&gt; C interface. All automatic checkpoints are &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;PASSIVE&lt;/a&gt;.</source>
          <target state="translated">该编译指示是&lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint（）&lt;/a&gt; C接口的包装。所有自动检查点均为&lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;PASSIVE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="030bb1c5ea97fb7c877a4d85a6707ab503f61e3b" translate="yes" xml:space="preserve">
          <source>This pragma is intended for use when debugging SQLite itself. It is only available when the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">该杂注旨在在调试SQLite本身时使用。仅在使用&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;编译时选项时可用。</target>
        </trans-unit>
        <trans-unit id="e56acb3f3acf3108d2bcfa664b49bb38684bdece" translate="yes" xml:space="preserve">
          <source>This pragma is provided as a work-around for older programs that contain code that expect the incomplete behavior of &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; found in older versions of SQLite. New applications should leave this flag turned off.</source>
          <target state="translated">提供此杂项作为变通方法，用于较旧的程序，这些较旧的程序包含的代码期望在较旧版本的SQLite中发现&lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME的&lt;/a&gt;行为不完整。新应用程序应将此标志保持关闭状态。</target>
        </trans-unit>
        <trans-unit id="da6399d7b11614d555263b7b5c1f6eeed6216d28" translate="yes" xml:space="preserve">
          <source>This pragma is usually a no-op or nearly so and is very fast. However if SQLite feels that performing database optimizations (such as running &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; or creating new indexes) will improve the performance of future queries, then some database I/O may be done. Applications that want to limit the amount of work performed can set a timer that will invoke &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; if the pragma goes on for too long.</source>
          <target state="translated">此实用程序通常是无操作的或几乎没有操作的，并且非常快。但是，如果SQLite认为执行数据库优化（例如运行&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;或创建新索引）将提高未来查询的性能，则可以完成一些数据库I / O。想要限制执行的工作量的应用程序可以设置一个计时器，如果编译指示进行的时间过长，它将调用&lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eed3f0fa483000682a7d14c72650e371b0cd8ff1" translate="yes" xml:space="preserve">
          <source>This pragma is usually a no-op or nearly so and is very fast. However if SQLite feels that performing database optimizations (such as running &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; or creating new indexes) will improve the performance of future queries, then some database I/O may be done. Applications that want to limit the amount of work performed can set a timer that will invoke &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; if the pragma goes on for too long. Or, since SQLite 3.32.0, the application can use &lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;PRAGMA analysis_limit=&lt;i&gt;N&lt;/i&gt;&lt;/a&gt; for some small value of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dc81b55aa5ba45ad453a6bcde0f0c60e0ee6240" translate="yes" xml:space="preserve">
          <source>This pragma no longer functions. It has become a no-op. The capabilities formerly provided by PRAGMA legacy_file_format are now available using the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyfileformat&quot;&gt;SQLITE_DBCONFIG_LEGACY_FILE_FORMAT&lt;/a&gt; option to the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; C-language interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa79296e3017bdd16ab4375742cc5d36bf545d0" translate="yes" xml:space="preserve">
          <source>This pragma only operates on the single database specified prior to the pragma name (or on the &quot;main&quot; database if no database is specified.) There is no way to change the journal size limit on all attached databases using a single PRAGMA statement. The size limit must be set separately for each attached database.</source>
          <target state="translated">这个pragma只在pragma名称前指定的单个数据库上运行(如果没有指定数据库,则在 &quot;主 &quot;数据库上运行),没有办法使用单个pragma语句改变所有附加数据库的日志大小限制。必须为每个附加数据库单独设置大小限制。</target>
        </trans-unit>
        <trans-unit id="aaba056a4862e01cda71d1b761b20e44b6644509" translate="yes" xml:space="preserve">
          <source>This pragma queries or sets the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;&lt;a href=&quot;wal#ckpt&quot;&gt;auto-checkpoint&lt;/a&gt; interval. When the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; is enabled (via the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;) a checkpoint will be run automatically whenever the write-ahead log equals or exceeds</source>
          <target state="translated">此实用程序查询或设置&lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt;&lt;a href=&quot;wal#ckpt&quot;&gt;自动检查点&lt;/a&gt;间隔。当&lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt;被启用（通过&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode编译&lt;/a&gt;）检查点都将自动运行每当预写日志等于或超过</target>
        </trans-unit>
        <trans-unit id="bfa75e14bfef32a3a2655c1f71aac8485fad888a" translate="yes" xml:space="preserve">
          <source>This pragma queries or sets the journal mode for databases associated with the current &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">此编译指示查询或设置与当前&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;关联的数据库的日志模式。</target>
        </trans-unit>
        <trans-unit id="d7c0c8e01f410012df8cd3104181fe89fb374fb3" translate="yes" xml:space="preserve">
          <source>This pragma queries or sets the suggested maximum number of pages of disk cache that will be allocated per open database file. The difference between this pragma and &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt; is that the value set here persists across database connections. The value of the default cache size is stored in the 4-byte big-endian integer located at offset 48 in the header of the database file.</source>
          <target state="translated">此编译指示查询或设置建议为每个打开的数据库文件分配的最大磁盘高速缓存页数。该编译指示和&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt;之间的区别在于，此处设置的值在数据库连接之间保持不变。默认高速缓存大小的值存储在数据库文件头中偏移量48处的4字节big-endian整数中。</target>
        </trans-unit>
        <trans-unit id="1ef2565e895730d620c072e537d3e53ba600062b" translate="yes" xml:space="preserve">
          <source>This pragma returns a list of &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; modules registered with the database connection.</source>
          <target state="translated">该编译指示返回已向数据库连接注册的&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;模块的列表。</target>
        </trans-unit>
        <trans-unit id="761ef2eae4b7a8c11954de10636acd7a99ab380d" translate="yes" xml:space="preserve">
          <source>This pragma returns a list of PRAGMA commands known to the database connection.</source>
          <target state="translated">这个pragma返回数据库连接已知的PRAGMA命令列表。</target>
        </trans-unit>
        <trans-unit id="9ed8c879810cf3faa84c36c2770e39958fecd02f" translate="yes" xml:space="preserve">
          <source>This pragma returns a list of SQL functions known to the database connection.</source>
          <target state="translated">这个pragma返回数据库连接中已知的SQL函数列表。</target>
        </trans-unit>
        <trans-unit id="0dc9b418a5af323c70ff0736fa3cf8ab37665f1f" translate="yes" xml:space="preserve">
          <source>This pragma returns a list of SQL functions known to the database connection. Each row of the result describes a single calling signature for a single SQL function. Some SQL functions will have multiple rows in the result set if they can (for example) be invoked with a varying number of arguments or can accept text in various encodings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84be4457e11159e63d3d0bcb841125df9cb83de4" translate="yes" xml:space="preserve">
          <source>This pragma returns auxiliary information about tables and indices. The returned information is used during testing to help verify that the query planner is operating correctly. The format and meaning of this pragma will likely change from one release to the next. Because of its volatility, the behavior and output format of this pragma are deliberately undocumented.</source>
          <target state="translated">这个pragma返回有关表和索引的辅助信息。返回的信息在测试过程中被用来帮助验证查询规划器是否正确运行。这个pragma的格式和意义可能会在不同的版本中发生变化。由于它的不稳定性,这个pragma的行为和输出格式故意不被记录。</target>
        </trans-unit>
        <trans-unit id="2c1dbb4a8fba94e2ded892c87199bba0f95f66bb" translate="yes" xml:space="preserve">
          <source>This pragma returns information about every column in an index. Unlike this &lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_info pragma&lt;/a&gt;, this pragma returns information about every column in the index, not just the key columns. (A key column is a column that is actually named in the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; index statement or &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE constraint&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY constraint&lt;/a&gt; that created the index. Auxiliary columns are additional columns needed to locate the table entry that corresponds to each index entry.)</source>
          <target state="translated">该编译指示返回有关索引中每一列的信息。不同于&lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_info杂注&lt;/a&gt;，此杂注返回有关索引中每一列的信息，而不仅仅是键列。（键列是在&lt;a href=&quot;lang_createindex&quot;&gt;创建索引&lt;/a&gt;的CREATE INDEX索引语句或&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE约束&lt;/a&gt;或&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY约束&lt;/a&gt;中实际命名的列。辅助列是查找与每个索引条目相对应的表条目所需的其他列。）</target>
        </trans-unit>
        <trans-unit id="a24a2d4f09014cb1eb0e92389ff660a1c3604451" translate="yes" xml:space="preserve">
          <source>This pragma returns one row for each &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; created by a REFERENCES clause in the CREATE TABLE statement of table &quot;</source>
          <target state="translated">对于由&amp;ldquo;表&amp;rdquo;的CREATE TABLE语句中的REFERENCES子句创建的每个&lt;a href=&quot;foreignkeys&quot;&gt;外键约束，&lt;/a&gt;此编译指示均返回一行。</target>
        </trans-unit>
        <trans-unit id="f5e8b048594bfe6e950f49e7a3df451544d23739" translate="yes" xml:space="preserve">
          <source>This pragma returns one row for each column in the named table, including &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden columns&lt;/a&gt; in virtual tables. The output is the same as for &lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt; except that hidden columns are shown rather than being omitted.</source>
          <target state="translated">该编译指示为命名表中的每一列返回一行，包括虚拟表中的&lt;a href=&quot;vtab#hiddencol&quot;&gt;隐藏列&lt;/a&gt;。输出与&lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt;相同，除了显示而不是省略隐藏列。</target>
        </trans-unit>
        <trans-unit id="0f2a61f261d82a90c74c33973c7e5e1738138e48" translate="yes" xml:space="preserve">
          <source>This pragma returns one row for each column in the named table. Columns in the result set include the column name, data type, whether or not the column can be NULL, and the default value for the column. The &quot;pk&quot; column in the result set is zero for columns that are not part of the primary key, and is the index of the column in the primary key for columns that are part of the primary key.</source>
          <target state="translated">这个pragma为命名表中的每一列返回一行。结果集中的列包括列名、数据类型、该列是否可以为NULL以及该列的默认值。对于不属于主键的列,结果集中的 &quot;pk &quot;列为零,对于属于主键的列,则是该列在主键中的索引。</target>
        </trans-unit>
        <trans-unit id="843feda403cc5662c28514409a8476f790a07bc9" translate="yes" xml:space="preserve">
          <source>This pragma returns one row for each index associated with the given table.</source>
          <target state="translated">这个pragma为每个与给定表相关联的索引返回一条记录。</target>
        </trans-unit>
        <trans-unit id="e15d06d79e2f134d82370610f854504fb7d9c9fb" translate="yes" xml:space="preserve">
          <source>This pragma returns one row for each key column in the named index. A key column is a column that is actually named in the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; index statement or &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE constraint&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY constraint&lt;/a&gt; that created the index. Index entries also usually contain auxiliary columns that point back to the table row being indexed. The auxiliary index-columns are not shown by the index_info pragma, but they are listed by the &lt;a href=&quot;pragma#pragma_index_xinfo&quot;&gt;index_xinfo pragma&lt;/a&gt;.</source>
          <target state="translated">该编译指示为命名索引中的每个键列返回一行。键列是在&lt;a href=&quot;lang_createindex&quot;&gt;创建索引&lt;/a&gt;的CREATE INDEX索引语句或&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE约束&lt;/a&gt;或&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY约束&lt;/a&gt;中实际命名的列。索引条目通常还包含辅助列，这些辅助列指向要建立索引的表行。辅助索引列未由index_info编译指示显示，但由&lt;a href=&quot;pragma#pragma_index_xinfo&quot;&gt;index_xinfo编译指示&lt;/a&gt;列出。</target>
        </trans-unit>
        <trans-unit id="d1297e6852f3b4af2f7f71b997d91f96306d187f" translate="yes" xml:space="preserve">
          <source>This pragma returns the names of &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; used when building SQLite, one option per row. The &quot;SQLITE_&quot; prefix is omitted from the returned option names. See also the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get()&lt;/a&gt; C/C++ interface and the &lt;a href=&quot;lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get()&lt;/a&gt; SQL functions.</source>
          <target state="translated">此编译指示返回在构建SQLite &lt;a href=&quot;compile&quot;&gt;时&lt;/a&gt;使用的编译时选项的名称，每行一个选项。返回的选项名称中省略了&amp;ldquo; SQLITE_&amp;rdquo;前缀。另请参见&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get（）&lt;/a&gt; C / C ++接口和&lt;a href=&quot;lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get（）&lt;/a&gt; SQL函数。</target>
        </trans-unit>
        <trans-unit id="1f4e86e6ac578887a9d6dbf11a796008c25a44d7" translate="yes" xml:space="preserve">
          <source>This pragma sets or queries the database connection locking-mode. The locking-mode is either NORMAL or EXCLUSIVE.</source>
          <target state="translated">这个pragma设置或查询数据库连接锁定模式。锁定模式可以是NORMAL或EXCLUSIVE。</target>
        </trans-unit>
        <trans-unit id="bdaa228ea88957ef0c9ab9a688d3e7fea7b874a6" translate="yes" xml:space="preserve">
          <source>This pragma sets or queries the value of the legacy_alter_table flag. When this flag is on, the &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; command (for changing the name of a table) works as it did in SQLite 3.24.0 (2018-06-04) and earlier. More specifically, when this flag is on the &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; command only rewrites the initial occurrence of the table name in its &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement and in any associated &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; and &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statements. Other references to the table are unmodified, including:</source>
          <target state="translated">此编译指示设置或查询legacy_alter_table标志的值。启用此标志时，&lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt;命令（用于更改表的名称）的工作方式与SQLite 3.24.0（2018-06-04）及更早版本中的工作相同。更具体地说，当此标志位于&lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt;命令上时，仅在其&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句以及任何关联的&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;和&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;语句中重写表名的初始出现。对该表的其他引用未经修改，包括：</target>
        </trans-unit>
        <trans-unit id="7a05efbc35058ad10c4f2cd985fb255ec41f8221" translate="yes" xml:space="preserve">
          <source>This pragma sets or queries the value of the legacy_file_format flag. When this flag is on, new SQLite databases are created in a file format that is readable and writable by all versions of SQLite going back to 3.0.0. When the flag is off, new databases are created using the latest file format which might not be readable or writable by versions of SQLite prior to 3.3.0.</source>
          <target state="translated">这个pragma设置或查询legacy_file_format标志的值。当这个标志开启时,新的SQLite数据库是以3.0.0以前的所有版本的SQLite都能读和写的文件格式创建的。 当这个标志关闭时,新的数据库是使用最新的文件格式创建的,而3.3.0以前的SQLite版本可能无法读和写。</target>
        </trans-unit>
        <trans-unit id="b26c49351792e86f1f1cf4afa447e502bc4e050e" translate="yes" xml:space="preserve">
          <source>This pragma tells the ANALYZE command to start a full scan of the index as it normally would. But when the number of rows visited reaches 1000 (or whatever other limit is specified by the pragma), the ANALYZE command will begin taking actions to stop the scan. If the left-most column of the index has changed at least once during the previous 1000 steps, then the analysis stops immediately. But if the left-most column has always been the same, then ANALYZE skips ahead to the first entry with a different left-most column and reads an additional 1000 rows before terminating.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2256ef3045f9cad069bd18349bbc99a6efdd738" translate="yes" xml:space="preserve">
          <source>This pragma uses &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; to overload the LIKE and GLOB functions, which may override previous implementations of LIKE and GLOB registered by the application. This pragma only changes the behavior of the SQL &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator. It does not change the behavior of the &lt;a href=&quot;c3ref/strlike&quot;&gt;sqlite3_strlike()&lt;/a&gt; C-language interface, which is always case insensitive.</source>
          <target state="translated">此编译指示使用&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;重载LIKE和GLOB函数，这可能会覆盖应用程序注册的LIKE和GLOB的先前实现。此编译指示仅更改SQL &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;运算符的行为。它不会更改&lt;a href=&quot;c3ref/strlike&quot;&gt;sqlite3_strlike（）&lt;/a&gt; C语言接口的行为，该行为始终不区分大小写。</target>
        </trans-unit>
        <trans-unit id="310b52d96c912ff71562ab1fd81b11654003b13d" translate="yes" xml:space="preserve">
          <source>This pragma was added in SQLite version 3.32.0 (2020-05-22). The current implementation only uses the lower 31 bits of the N value - higher order bits are silently ignored. Future versions of SQLite might begin using higher order bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="447007d852fb19b826d2b7aaae3e67946a28d336" translate="yes" xml:space="preserve">
          <source>This pragma works like a query to return one row for each database attached to the current database connection. The second column is &quot;main&quot; for the main database file, &quot;temp&quot; for the database file used to store TEMP objects, or the name of the ATTACHed database for other database files. The third column is the name of the database file itself, or an empty string if the database is not associated with a file.</source>
          <target state="translated">这个pragma的工作原理就像查询一样,为当前数据库连接所附的每个数据库返回一行。第二列是 &quot;main &quot;表示主数据库文件,&quot;temp &quot;表示用于存储TEMP对象的数据库文件,或者其他数据库文件的ATTACHed数据库名称。第三列是数据库文件本身的名称,如果数据库没有与文件关联,则为空字符串。</target>
        </trans-unit>
        <trans-unit id="b7e6bffb05642d99fecc1f2c74da4ca842565145" translate="yes" xml:space="preserve">
          <source>This problem was discovered during internal testing and has never been observed in the wild. The problem was fixed on 2011-01-27 and in version 3.7.5.</source>
          <target state="translated">该问题是在内部测试中发现的,从未在野外观察到。该问题已于2011-01-27和3.7.5版本中得到修复。</target>
        </trans-unit>
        <trans-unit id="9438a6524ce2126c022c5e9ae1c6d3bb84977f28" translate="yes" xml:space="preserve">
          <source>This problem was fixed on 2010-08-04 for SQLite version 3.7.1.</source>
          <target state="translated">该问题已于2010-08-04修复,适用于SQLite 3.7.1版本。</target>
        </trans-unit>
        <trans-unit id="3bba8168352d9cb374bc4be5ca367062ebf9277c" translate="yes" xml:space="preserve">
          <source>This problem was fixed on 2010-08-23 for SQLite version 3.7.2.</source>
          <target state="translated">该问题已于2010-08-23修复,适用于SQLite 3.7.2版本。</target>
        </trans-unit>
        <trans-unit id="3eea872e5b7d7a7257a591147c473522673fa365" translate="yes" xml:space="preserve">
          <source>This problem was fixed on 2010-09-20 for SQLite version 3.7.3.</source>
          <target state="translated">该问题已于2010-09-20修复,适用于SQLite 3.7.3版本。</target>
        </trans-unit>
        <trans-unit id="0ce7e9d811851c36704d972293b4f2237f7e1d64" translate="yes" xml:space="preserve">
          <source>This procedure works well in many scenarios and is usually very fast. However, this technique has the following shortcomings:</source>
          <target state="translated">这个程序在很多情况下都很好用,而且通常非常快。但是,这种技术有以下缺点:</target>
        </trans-unit>
        <trans-unit id="4c414b9643d2b1eb4ae1c2d544d59015b0f98573" translate="yes" xml:space="preserve">
          <source>This program is essentially the same as the DELETE program except that the body of the second loop has been replace by a sequence of instructions (at addresses 17 through 26) that update the record rather than delete it. Most of this instruction sequence should already be familiar to you, but there are a couple of minor twists so we will go over it briefly. Also note that the order of some of the instructions before and after the 2nd loop has changed. This is just the way the SQLite parser chose to output the code using a different template.</source>
          <target state="translated">这个程序与DELETE程序基本相同,只是第二个循环的主体被更新记录而不是删除记录的指令序列(地址为17到26)所取代。这个指令序列的大部分内容你应该已经很熟悉了,但是有几个小的转折,所以我们将简单介绍一下。还要注意的是,第2个循环前后的一些指令的顺序发生了变化。这只是SQLite解析器选择使用不同模板输出代码的方式。</target>
        </trans-unit>
        <trans-unit id="f54cc6d1386375f0cfa0eb855ce7f2e93f001461" translate="yes" xml:space="preserve">
          <source>This query asks for is all information about edges that go from nodes labeled &quot;alice&quot; to nodes labeled &quot;bob&quot;. The query optimizer in SQLite has basically two choices on how to implement this query. (There are actually six different choices, but we will only consider two of them here.) Pseudocode below demonstrating these two choices.</source>
          <target state="translated">这个查询要求的是所有从标记为 &quot;alice &quot;的节点到标记为 &quot;bob &quot;的节点的边的信息。SQLite中的查询优化器基本上有两种选择来实现这个查询。实际上有六种不同的选择,但我们在这里只考虑其中的两种)。下面的伪代码演示了这两种选择。</target>
        </trans-unit>
        <trans-unit id="7e3da084168a6f4b3ad897e2e46b6850a28945d4" translate="yes" xml:space="preserve">
          <source>This query first has to search the index B-Tree looking for any entry that contains the matching value for &quot;word&quot;. When an entry is found in the index, the rowid is extracted and used to search the main table. Then the &quot;cnt&quot; value is read out of the main table and returned. Hence, two separate binary searches are required to fulfill the request.</source>
          <target state="translated">这个查询首先要搜索索引B树,寻找任何包含 &quot;word &quot;匹配值的条目。当在索引中找到一个条目时,提取出rowid并用于搜索主表,然后从主表中读出 &quot;cnt &quot;值并返回。然后从主表中读出 &quot;cnt &quot;值并返回。因此,需要进行两次独立的二进制搜索来完成请求。</target>
        </trans-unit>
        <trans-unit id="620f9a1f33cc73df6597e56b9939bf24aa81844a" translate="yes" xml:space="preserve">
          <source>This query gives the same result:</source>
          <target state="translated">这个查询给出了同样的结果。</target>
        </trans-unit>
        <trans-unit id="d2601bd4ed6990af8a96269ebe6b0cb66d50d79e" translate="yes" xml:space="preserve">
          <source>This query is not especially complicated, but even so it replaces hundreds or perhaps thousands of lines of procedural code. The gist of the query is this: Scan down the EVENT table looking for the most recent 200 check-ins that satisfy any one of three conditions:</source>
          <target state="translated">这个查询并不是特别复杂,但即便如此,它也取代了几百行甚至上千行的程序代码。这个查询的要点是这样的。扫描EVENT表,寻找最近200个符合三个条件之一的签到。</target>
        </trans-unit>
        <trans-unit id="2749b73f041610bfa01e6d5aed946eaac3cd848e" translate="yes" xml:space="preserve">
          <source>This query is perhaps a bit contrived, but it does serve to illustrate our points. The result will have three column with names &quot;one&quot;, &quot;two&quot;, and &quot;both&quot;. The first two columns are direct copies of the two columns in the table and the third result column is a string formed by concatenating the first and second columns of the table. Finally, the WHERE clause says that we will only chose rows for the results where the &quot;one&quot; column begins with an &quot;H&quot;. Here is what the VDBE program looks like for this query:</source>
          <target state="translated">这个查询也许有点造作,但它确实可以说明我们的观点。结果将有三列,名称分别为 &quot;一&quot;、&quot;二 &quot;和 &quot;二&quot;。前两列是表中两列的直接拷贝,第三个结果列是表中第一列和第二列连在一起形成的字符串。最后,WHERE子句表示我们将只选择 &quot;一 &quot;列以 &quot;H &quot;开头的结果行。下面是这个查询的VDBE程序的样子。</target>
        </trans-unit>
        <trans-unit id="6af6cd36f1f43fba0a96ca0a8f8120de050aaf2f" translate="yes" xml:space="preserve">
          <source>This query will quickly and efficiently return the content of the first slide, which could then be speedily parsed and displayed to the user. Only one page needs to be read and parsed in order render the first screen, which means that the first screen appears much faster and there is no longer a need for an annoying progress bar.</source>
          <target state="translated">这个查询将快速有效地返回第一张幻灯片的内容,然后可以快速解析并显示给用户。只需要读取和解析一个页面就可以呈现第一个屏幕,这意味着第一个屏幕出现的速度要快得多,而且不再需要烦人的进度条。</target>
        </trans-unit>
        <trans-unit id="5a6c62ef8547acc00a0d376fd2eee1cb18ab798d" translate="yes" xml:space="preserve">
          <source>This query will return the name, login and host computer name for every employee whose login begins with the letter &quot;d&quot;. If this query is submitted to &lt;b&gt;sqlite_get_table&lt;/b&gt; the result might look like this:</source>
          <target state="translated">该查询将返回每个以字母&amp;ldquo; d&amp;rdquo;开头的员工的姓名，登录名和主机名。如果此查询提交到&lt;b&gt;sqlite_get_table，&lt;/b&gt;则结果可能如下所示：</target>
        </trans-unit>
        <trans-unit id="786fc0a802df1e8aec075c9e88a6bbb535aa99ad" translate="yes" xml:space="preserve">
          <source>This routine actually returns the index of the largest (rightmost) parameter. For all forms except ?NNN, this will correspond to the number of unique parameters. If parameters of the ?NNN form are used, there may be gaps in the list.</source>
          <target state="translated">这个例程实际上返回最大(最右边)参数的索引。对于除?NNN以外的所有形式,这将对应于唯一参数的数量。如果使用的是?NNN形式的参数,那么列表中可能会有空白。</target>
        </trans-unit>
        <trans-unit id="82cead05834ab856656df11fcc02860924d8d8b1" translate="yes" xml:space="preserve">
          <source>This routine can be used to find the number of &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL parameters&lt;/a&gt; in a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. SQL parameters are tokens of the form &quot;?&quot;, &quot;?NNN&quot;, &quot;:AAA&quot;, &quot;$AAA&quot;, or &quot;@AAA&quot; that serve as placeholders for values that are &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bound&lt;/a&gt; to the parameters at a later time.</source>
          <target state="translated">此例程可用于在&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句中&lt;/a&gt;查找&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL参数&lt;/a&gt;的数量。SQL参数是形式为&amp;ldquo;？&amp;rdquo;，&amp;ldquo;？NNN&amp;rdquo;，&amp;ldquo;：AAA&amp;rdquo;，&amp;ldquo; $ AAA&amp;rdquo;或&amp;ldquo; @AAA&amp;rdquo;的令牌，用作以后&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;绑定&lt;/a&gt;到参数的值的占位符。</target>
        </trans-unit>
        <trans-unit id="6aaf25d9f82325cb031a156482001e57680fd3f9" translate="yes" xml:space="preserve">
          <source>This routine can be used to find the number of &lt;a href=&quot;bind_blob&quot;&gt;SQL parameters&lt;/a&gt; in a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. SQL parameters are tokens of the form &quot;?&quot;, &quot;?NNN&quot;, &quot;:AAA&quot;, &quot;$AAA&quot;, or &quot;@AAA&quot; that serve as placeholders for values that are &lt;a href=&quot;bind_blob&quot;&gt;bound&lt;/a&gt; to the parameters at a later time.</source>
          <target state="translated">此例程可用于在&lt;a href=&quot;stmt&quot;&gt;准备好的语句中&lt;/a&gt;查找&lt;a href=&quot;bind_blob&quot;&gt;SQL参数&lt;/a&gt;的数量。SQL参数是形式为&amp;ldquo;？&amp;rdquo;，&amp;ldquo;？NNN&amp;rdquo;，&amp;ldquo;：AAA&amp;rdquo;，&amp;ldquo; $ AAA&amp;rdquo;或&amp;ldquo; @AAA&amp;rdquo;的令牌，用作以后&lt;a href=&quot;bind_blob&quot;&gt;绑定&lt;/a&gt;到参数的值的占位符。</target>
        </trans-unit>
        <trans-unit id="1a65562aad6f3d45b12e58b386a59a0e67c73c2c" translate="yes" xml:space="preserve">
          <source>This routine closes a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; previously opened by a call to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;. All &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with the connection should be &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt; prior to closing the connection.</source>
          <target state="translated">该例程关闭先前通过调用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;打开的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;。与连接关联的所有&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;应在关闭连接之前&lt;a href=&quot;c3ref/finalize&quot;&gt;完成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6109a4798fab358a5831fcddc3e8943992908f3a" translate="yes" xml:space="preserve">
          <source>This routine constructs a phonetic hash of the pure ascii input word X and returns that hash. This routine is used internally by spellfix1 in order to transform the K1 column of the shadow table into the K2 column.</source>
          <target state="translated">这个例程构建一个纯ascii输入字X的语音哈希值,并返回该哈希值。这个例程在内部被spellfix1使用,以便将影子表的K1列转换为K2列。</target>
        </trans-unit>
        <trans-unit id="0ac023c7cfdfffbaae6b8a792abd8043d224eebe" translate="yes" xml:space="preserve">
          <source>This routine converts SQL text into a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object and returns a pointer to that object. This interface requires a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; pointer created by a prior call to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and a text string containing the SQL statement to be prepared. This API does not actually evaluate the SQL statement. It merely prepares the SQL statement for evaluation.</source>
          <target state="translated">该例程将SQL文本转换为&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;对象，并返回指向该对象的指针。此接口需要一个由先前调用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;创建的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;指针和一个包含要准备的SQL语句的文本字符串。该API实际上不会评估SQL语句。它只是准备要评估的SQL语句。</target>
        </trans-unit>
        <trans-unit id="3865bbf14bf147fc543355db38f5dadbf150122d" translate="yes" xml:space="preserve">
          <source>This routine destroys a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; created by a prior call to &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;. Every prepared statement must be destroyed using a call to this routine in order to avoid memory leaks.</source>
          <target state="translated">该例程破坏了由先前调用&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;创建的&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;。必须使用对此例程的调用来销毁每个准备好的语句，以避免内存泄漏。</target>
        </trans-unit>
        <trans-unit id="a52c3faf1c3a1657fd6a40523756966514b3bd4b" translate="yes" xml:space="preserve">
          <source>This routine enables or disables the sharing of the database cache and schema data structures between &lt;a href=&quot;#sqlite3&quot;&gt;connections&lt;/a&gt; to the same database. Sharing is enabled if the argument is true and disabled if the argument is false.</source>
          <target state="translated">此例程启用或禁用在同一数据库的&lt;a href=&quot;#sqlite3&quot;&gt;连接&lt;/a&gt;之间共享数据库缓存和架构数据结构。如果参数为true，则启用共享；如果参数为false，则禁用共享。</target>
        </trans-unit>
        <trans-unit id="d901aac850e2874e347f7c695dbc9ec37b0c376c" translate="yes" xml:space="preserve">
          <source>This routine enables or disables the sharing of the database cache and schema data structures between &lt;a href=&quot;sqlite3&quot;&gt;connections&lt;/a&gt; to the same database. Sharing is enabled if the argument is true and disabled if the argument is false.</source>
          <target state="translated">此例程启用或禁用在同一数据库的&lt;a href=&quot;sqlite3&quot;&gt;连接&lt;/a&gt;之间共享数据库缓存和架构数据结构。如果参数为true，则启用共享；如果参数为false，则禁用共享。</target>
        </trans-unit>
        <trans-unit id="29a07bad74dc3a8e7d5052bfbcc32c750599206e" translate="yes" xml:space="preserve">
          <source>This routine is intended for use in custom &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations only. It is not a general-purpose interface. The argument sqlite3_file_object(X) must be a filename pointer that has been passed into &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;.xOpen method where the flags parameter to xOpen contains one of the bits &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_MAIN_JOURNAL&lt;/a&gt; or &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_WAL&lt;/a&gt;. Any other use of this routine results in undefined and probably undesirable behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ec00e3ab29e600b8638a80acbfec2ed5a9c1b5" translate="yes" xml:space="preserve">
          <source>This routine is used to evaluate a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; that has been previously created by the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface. The statement is evaluated up to the point where the first row of results are available. To advance to the second row of results, invoke &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; again. Continue invoking &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; until the statement is complete. Statements that do not return results (ex: INSERT, UPDATE, or DELETE statements) run to completion on a single call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">此例程用于评估先前由&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;接口创建的预&lt;a href=&quot;c3ref/stmt&quot;&gt;准备语句&lt;/a&gt;。对该语句进行评估，直到结果的第一行可用为止。要前进到结果的第二行，请再次调用&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;。继续调用&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;直到语句完成。不返回结果的语句（例如INSERT，UPDATE或DELETE语句）在单次调用&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）时便&lt;/a&gt;运行完毕。</target>
        </trans-unit>
        <trans-unit id="c21adee0cae411351e9767eae2ca17c143aefc07" translate="yes" xml:space="preserve">
          <source>This routine must be called from the same thread in which the aggregate SQL function is running.</source>
          <target state="translated">这个例程必须在运行聚合SQL函数的同一线程中调用。</target>
        </trans-unit>
        <trans-unit id="e489cf15316fb146ac0baf370fbbfcb5134583b8" translate="yes" xml:space="preserve">
          <source>This routine must be called from the same thread in which the application-defined function is running.</source>
          <target state="translated">这个例程必须从运行应用程序定义函数的同一线程中调用。</target>
        </trans-unit>
        <trans-unit id="07007def1c51de043ffcd727a12c0e6566d62bdb" translate="yes" xml:space="preserve">
          <source>This routine only works on a &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; which has been created by a prior successful call to &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; and which has not been closed by &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;. Passing any other pointer in to this routine results in undefined and probably undesirable behavior.</source>
          <target state="translated">此例程仅适用于&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄&lt;/a&gt;，该句柄是由先前对&lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open（）的&lt;/a&gt;成功调用创建的，并且尚未由&lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close（）&lt;/a&gt;关闭。将任何其他指针传递到此例程将导致未定义的行为，并且可能是不良行为。</target>
        </trans-unit>
        <trans-unit id="d92c14464f28e95d1806fdcf38633495ea9ee90c" translate="yes" xml:space="preserve">
          <source>This routine only works on a &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; which has been created by a prior successful call to &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; and which has not been closed by &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;. Passing any other pointer in to this routine results in undefined and probably undesirable behavior.</source>
          <target state="translated">此例程仅适用于&lt;a href=&quot;blob&quot;&gt;BLOB句柄&lt;/a&gt;，该句柄是由先前对&lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open（）的&lt;/a&gt;成功调用创建的，并且尚未由&lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close（）&lt;/a&gt;关闭。将任何其他指针传递到此例程将导致未定义的行为，并且可能是不良行为。</target>
        </trans-unit>
        <trans-unit id="07b6feb6d3d354b38307dc8433a451fe5b332630" translate="yes" xml:space="preserve">
          <source>This routine opens a connection to an SQLite database file and returns a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; object. This is often the first SQLite API call that an application makes and is a prerequisite for most other SQLite APIs. Many SQLite interfaces require a pointer to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; object as their first parameter and can be thought of as methods on the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; object. This routine is the constructor for the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; object.</source>
          <target state="translated">该例程打开与SQLite数据库文件的连接，并返回&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;对象。这通常是应用程序进行的第一个SQLite API调用，并且是大多数其他SQLite API的前提条件。许多SQLite接口要求将指向&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;对象的指针作为它们的第一个参数，并且可以将其视为&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;对象上的方法。该例程是&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;对象的构造函数。</target>
        </trans-unit>
        <trans-unit id="8eb287af5c0b98096f9cf0455204f0ad3d8277d3" translate="yes" xml:space="preserve">
          <source>This routine provides access to the built-in Wagner edit-distance function that uses default, fixed costs. The value returned is the edit distance needed to transform W into P.</source>
          <target state="translated">这个例程提供了对使用默认固定成本的内置Wagner编辑距离函数的访问。返回的值是将W转换为P所需的编辑距离。</target>
        </trans-unit>
        <trans-unit id="93eac9a1a83b23f2a48d0e76580b6d5dc096f4b0" translate="yes" xml:space="preserve">
          <source>This routine registers an authorizer callback with a particular &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;, supplied in the first argument. The authorizer callback is invoked as SQL statements are being compiled by &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;. At various points during the compilation process, as logic is being created to perform various actions, the authorizer callback is invoked to see if those actions are allowed. The authorizer callback should return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; to allow the action, &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; to disallow the specific action but allow the SQL statement to continue to be compiled, or &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_DENY&lt;/a&gt; to cause the entire SQL statement to be rejected with an error. If the authorizer callback returns any value other than &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_DENY&lt;/a&gt; then the &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or equivalent call that triggered the authorizer will fail with an error message.</source>
          <target state="translated">此例程使用第一个参数中提供的特定&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;注册授权者回调。当&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;或其变体&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;编译SQL语句时，将调用Authorizer回调。在编译过程中的各个阶段，随着创建逻辑来执行各种动作，将调用授权者回调以查看是否允许这些动作。授权者回调应返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;以允许操作&lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;禁止执行特定操作，但允许继续编译SQL语句，或者&lt;a href=&quot;#SQLITE_DENY&quot;&gt;允许SQLITE_DENY&lt;/a&gt;导致整个SQL语句被错误拒绝。如果授权者回调返回除&lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;或&lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_DENY&lt;/a&gt;之外的任何其他值，则触发授权者的&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或等效调用将失败，并显示一条错误消息。</target>
        </trans-unit>
        <trans-unit id="dcaafc38803b7cef296c24894bb19eac21f398f7" translate="yes" xml:space="preserve">
          <source>This routine registers an authorizer callback with a particular &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;, supplied in the first argument. The authorizer callback is invoked as SQL statements are being compiled by &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, and &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;. At various points during the compilation process, as logic is being created to perform various actions, the authorizer callback is invoked to see if those actions are allowed. The authorizer callback should return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; to allow the action, &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; to disallow the specific action but allow the SQL statement to continue to be compiled, or &lt;a href=&quot;c_deny&quot;&gt;SQLITE_DENY&lt;/a&gt; to cause the entire SQL statement to be rejected with an error. If the authorizer callback returns any value other than &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;, &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;, or &lt;a href=&quot;c_deny&quot;&gt;SQLITE_DENY&lt;/a&gt; then the &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or equivalent call that triggered the authorizer will fail with an error message.</source>
          <target state="translated">此例程使用第一个参数中提供的特定&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;注册授权者回调。当&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;或其变体&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;，&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;，&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16（）&lt;/a&gt;，&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;和&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;编译SQL语句时，将调用Authorizer回调。在编译过程中的各个阶段，随着创建逻辑来执行各种动作，将调用授权者回调以查看是否允许这些动作。授权者回调应返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;以允许操作&lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;禁止执行特定操作，但允许继续编译SQL语句，或者&lt;a href=&quot;c_deny&quot;&gt;允许SQLITE_DENY&lt;/a&gt;导致整个SQL语句被错误拒绝。如果授权者回调返回除&lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;，&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;或&lt;a href=&quot;c_deny&quot;&gt;SQLITE_DENY&lt;/a&gt;之外的任何其他值，则触发授权者的&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或等效调用将失败，并显示一条错误消息。</target>
        </trans-unit>
        <trans-unit id="99bd82f31eb3b138636b801769508b327d9ce007" translate="yes" xml:space="preserve">
          <source>This routine returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if shared cache was enabled or disabled successfully. An &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned otherwise.</source>
          <target state="translated">如果成功启用或禁用了共享缓存，此例程将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;。一个&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;否则返回。</target>
        </trans-unit>
        <trans-unit id="2e5b155148072e0e0717f83e2e5d7963cd701ab3" translate="yes" xml:space="preserve">
          <source>This routine returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if shared cache was enabled or disabled successfully. An &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned otherwise.</source>
          <target state="translated">如果成功启用或禁用了共享缓存，此例程将返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。一个&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;否则返回。</target>
        </trans-unit>
        <trans-unit id="4d167dde1efd15582fdfdddff7653e5e9800f482" translate="yes" xml:space="preserve">
          <source>This routine returns a TCL byte-array that is the complete content of the identified database. This byte-array can be written into a file and then used as an ordinary SQLite database, or it can be sent over a TCP/IP connection to some other application, or passed to the &quot;deserialize&quot; method of another database connection.</source>
          <target state="translated">这个例程返回一个TCL字节数组,它是所识别数据库的完整内容。这个字节数组可以被写入一个文件,然后作为一个普通的SQLite数据库使用,也可以通过TCP/IP连接发送到其他应用程序,或者传递给另一个数据库连接的 &quot;反序列化 &quot;方法。</target>
        </trans-unit>
        <trans-unit id="dc962087e437ca7c6c8165e9968a2bc2c77ed304" translate="yes" xml:space="preserve">
          <source>This routine returns a single column from the current row of a result set for a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; that is being evaluated by &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. Each time &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; stops with a new result set row, this routine can be called multiple times to find the values of all columns in that row.</source>
          <target state="translated">该例程从结果集的当前行返回一个单列，用于由&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;评估的&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;。每次&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;以新的结果集行停止时，可以多次调用此例程以查找该行中所有列的值。</target>
        </trans-unit>
        <trans-unit id="eb8bd2a9855b404f89ce4b63dddd244bdc9bda29" translate="yes" xml:space="preserve">
          <source>This routine sets a &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy handler&lt;/a&gt; that sleeps for a specified amount of time when a table is locked. The handler will sleep multiple times until at least &quot;ms&quot; milliseconds of sleeping have accumulated. After at least &quot;ms&quot; milliseconds of sleeping, the handler returns 0 which causes &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; to return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="translated">此例程设置一个&lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;繁忙的处理程序&lt;/a&gt;，该处理程序在锁定表时会休眠指定的时间。处理程序将多次睡眠，直到至少&amp;ldquo; ms&amp;rdquo;毫秒的睡眠累积为止。经过至少&amp;ldquo; ms&amp;rdquo;毫秒的睡眠后，处理程序返回0，这导致&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="97ac6d25d7ee72382d3f7aec3c40d5d374b3ea97" translate="yes" xml:space="preserve">
          <source>This routine sets a &lt;a href=&quot;busy_handler&quot;&gt;busy handler&lt;/a&gt; that sleeps for a specified amount of time when a table is locked. The handler will sleep multiple times until at least &quot;ms&quot; milliseconds of sleeping have accumulated. After at least &quot;ms&quot; milliseconds of sleeping, the handler returns 0 which causes &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; to return &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="translated">此例程设置一个&lt;a href=&quot;busy_handler&quot;&gt;繁忙的处理程序&lt;/a&gt;，该处理程序在锁定表时会休眠指定的时间。处理程序将多次睡眠，直到至少&amp;ldquo; ms&amp;rdquo;毫秒的睡眠累积为止。经过至少&amp;ldquo; ms&amp;rdquo;毫秒的睡眠后，处理程序返回0，这导致&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;返回&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d633b79271bff7ae103d633764cef0869ef0e52" translate="yes" xml:space="preserve">
          <source>This routine transliterates unicode text into pure ascii, returning the pure ascii representation of the input text X. This is the function that is used internally to transform vocabulary words into the K1 column of the shadow table.</source>
          <target state="translated">这个例程将unicode文本翻译成纯ascii,返回输入文本X的纯ascii表示。这是内部用于将词汇转换到影子表K1列的函数。</target>
        </trans-unit>
        <trans-unit id="f0ad86a48fbea1254fe3c4c84468bcbdc8dd6e8c" translate="yes" xml:space="preserve">
          <source>This same content is also available as a &lt;a href=&quot;../capi3ref&quot;&gt;single large HTML file&lt;/a&gt;.</source>
          <target state="translated">同样的内容也可以作为&lt;a href=&quot;../capi3ref&quot;&gt;单个大HTML文件获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b74b81048986ae624c4d01a81a2fa637394592ee" translate="yes" xml:space="preserve">
          <source>This same content is also available split out into &lt;a href=&quot;c3ref/intro&quot;&gt;lots of small pages&lt;/a&gt;.</source>
          <target state="translated">同样的内容也可以分成&lt;a href=&quot;c3ref/intro&quot;&gt;很多小页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8e9d9070e55bd57ac8188b9955c919aae3b6970b" translate="yes" xml:space="preserve">
          <source>This scenario can be avoided by ensuring that there are &quot;reader gaps&quot;: times when no processes are reading from the database and that checkpoints are attempted during those times. In applications with many concurrent readers, one might also consider running manual checkpoints with the &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_RESTART&lt;/a&gt; or &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_TRUNCATE&lt;/a&gt; option which will ensure that the checkpoint runs to completion before returning. The disadvantage of using &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_RESTART&lt;/a&gt; and &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_TRUNCATE&lt;/a&gt; is that readers might block while the checkpoint is running.</source>
          <target state="translated">可以通过确保存在&amp;ldquo;读取器间隔&amp;rdquo;来避免这种情况：没有时间从数据库中读取进程，并且在这些时间内尝试了检查点。在具有多个并发阅读器的应用程序中，您可能还会考虑使用&lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_RESTART&lt;/a&gt;或&lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_TRUNCATE&lt;/a&gt;选项运行手动检查点，这将确保检查点在返回之前运行完毕。使用&lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_RESTART&lt;/a&gt;和&lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_TRUNCATE&lt;/a&gt;的缺点是，当检查点运行时，读者可能会阻塞。</target>
        </trans-unit>
        <trans-unit id="727ff7ebcc4d3f37cef6d2c8786627a54c4374f3" translate="yes" xml:space="preserve">
          <source>This second command will &quot;checkout&quot; the latest check-in from the SQLite source tree into your current directory. Subsequently, you can easily switch to a different version by typing:</source>
          <target state="translated">第二条命令将从SQLite源树中 &quot;签出 &quot;最新的签入到你当前的目录中。随后,你可以通过键入轻松切换到不同的版本。</target>
        </trans-unit>
        <trans-unit id="7c18c66c49575067fb81143d22f048900116d477" translate="yes" xml:space="preserve">
          <source>This second query will likely use the index because now the expression in the WHERE clause (x+y) matches the expression in the index exactly.</source>
          <target state="translated">第二个查询可能会使用索引,因为现在WHERE子句(x+y)中的表达式与索引中的表达式完全匹配。</target>
        </trans-unit>
        <trans-unit id="7abd749e3d4aa6938fa840ccf9ebcf410ac2c722" translate="yes" xml:space="preserve">
          <source>This second query would find both entry 1 (the SQLite.org office) which is entirely contained within the query box and also the 12th Congressional District which extends well outside the query box but still overlaps the query box.</source>
          <target state="translated">第二个查询既可以找到完全包含在查询框内的条目1(SQLite.org办公室),也可以找到延伸到查询框外但仍与查询框重合的第12国会区。</target>
        </trans-unit>
        <trans-unit id="810173a22163c6dabf4d33c2feedff31184b22f0" translate="yes" xml:space="preserve">
          <source>This section describes at a high-level the way the FTS module stores its index and content in the database. It is &lt;b&gt;not necessary to read or understand the material in this section in order to use FTS&lt;/b&gt; in an application. However, it may be useful to application developers attempting to analyze and understand FTS performance characteristics, or to developers contemplating enhancements to the existing FTS feature set.</source>
          <target state="translated">本节从更高层次描述了FTS模块将其索引和内容存储在数据库中的方式。这是&lt;b&gt;没有必要阅读或理解本节中的材料，以便使用FTS&lt;/b&gt;在应用程序中。但是，这对于尝试分析和理解FTS性能特征的应用程序开发人员，或正在考虑对现有FTS功能集进行增强的开发人员而言可能很有用。</target>
        </trans-unit>
        <trans-unit id="64d17de40cff5e777833059135b83479f23261c6" translate="yes" xml:space="preserve">
          <source>This section describes how the assumptions presented in the parent section apply to the individual API functions and operations provided by the VFS to SQLite for the purposes of modifying the contents of the file-system.</source>
          <target state="translated">这一节描述了上一节中介绍的假设如何应用于VFS向SQLite提供的各个API函数和操作,以便修改文件系统的内容。</target>
        </trans-unit>
        <trans-unit id="02fc8cc874e5b9c1577641015a9135b50baf469c" translate="yes" xml:space="preserve">
          <source>This section describes the VFS operations that take place when a new database connection is created.</source>
          <target state="translated">本节描述了在创建新的数据库连接时发生的VFS操作。</target>
        </trans-unit>
        <trans-unit id="4342e6a0d98af49025e37a5849302106877ca948" translate="yes" xml:space="preserve">
          <source>This section describes the VFS operations that take place when an existing database connection is closed (destroyed).</source>
          <target state="translated">本节描述了在关闭(销毁)现有数据库连接时发生的VFS操作。</target>
        </trans-unit>
        <trans-unit id="c2a1275da916ed3be3012a2f190ab9c2d388331b" translate="yes" xml:space="preserve">
          <source>This section describes the assumptions that SQLite makes about the content of a file-system following a power or system failure. In other words, it describes the extent of file and file-system corruption that such an event may cause.</source>
          <target state="translated">本节描述了SQLite在电源或系统故障后对文件系统内容的假设。换句话说,它描述了这种事件可能导致的文件和文件系统损坏的程度。</target>
        </trans-unit>
        <trans-unit id="edc6897ad6af970e04c51704d6197016314c42a7" translate="yes" xml:space="preserve">
          <source>This section describes the format used by an SQLite</source>
          <target state="translated">这一节描述了一个SQLite使用的格式。</target>
        </trans-unit>
        <trans-unit id="9a13aa03c88e9ab244b07031a9171942d0c6ff54" translate="yes" xml:space="preserve">
          <source>This section describes the procedure that SQLite uses to detect a</source>
          <target state="translated">这一节描述了SQLite用来检测一个</target>
        </trans-unit>
        <trans-unit id="bfe35a7e5c6f4117d5a645ddcb82fb94f15ae997" translate="yes" xml:space="preserve">
          <source>This section describes the progression of an SQLite</source>
          <target state="translated">这一节描述了一个SQLite的进展。</target>
        </trans-unit>
        <trans-unit id="f48fcfeb28df528b9f1d5864af41f8c4b970f962" translate="yes" xml:space="preserve">
          <source>This section describes the way the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;, and &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; commands interact with SQLite's foreign keys.</source>
          <target state="translated">本节介绍&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;，&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;和&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;命令与SQLite的外键交互的方式。</target>
        </trans-unit>
        <trans-unit id="58dd65dbe0083407cb2b8d63f24be502e95d9bbe" translate="yes" xml:space="preserve">
          <source>This section documents those assumptions made about the system that the VFS adaptor provides access to. The assumptions noted in section</source>
          <target state="translated">本节记录了对VFS适配器提供访问的系统所做的假设。本节中提到的假设</target>
        </trans-unit>
        <trans-unit id="1a8f1342dd83bc1cc71b3fbbf42a58b70897383c" translate="yes" xml:space="preserve">
          <source>This section is a combination of the Plan For Software Aspects Of Certification and the Software Development Plan sections of DO-178B.</source>
          <target state="translated">本部分是DO-178B的软件认证计划和软件开发计划部分的组合。</target>
        </trans-unit>
        <trans-unit id="30a1220c5879164f4d9cfc83dbec5374939998e6" translate="yes" xml:space="preserve">
          <source>This section is different from the others. Most other sections of this document talks about a particular SQL command. This section does not talk about a standalone command but about &quot;expressions&quot; which are subcomponents of most other commands.</source>
          <target state="translated">本节与其他章节不同。本文档中的大多数其他章节都是在谈论一个特定的SQL命令。本节并不是讲一个独立的命令,而是讲 &quot;表达式&quot;,而 &quot;表达式 &quot;是大多数其他命令的子组件。</target>
        </trans-unit>
        <trans-unit id="7d95e851797a07bafc31faa128d84f9f3bcc87a9" translate="yes" xml:space="preserve">
          <source>This section lists a few limitations and omitted features that are not mentioned elsewhere.</source>
          <target state="translated">本节列出了其他地方没有提到的一些限制和省略的功能。</target>
        </trans-unit>
        <trans-unit id="5f346ae80c10c621b4cd5c514c74301adfd2cd43" translate="yes" xml:space="preserve">
          <source>This section only describes the format of the journal file and the various objects that make it up. But because a journal file may be read by an SQLite process following recovery from a system failure (</source>
          <target state="translated">本节只描述了日志文件的格式和组成它的各种对象。但由于日志文件可以在系统故障恢复后被SQLite进程读取(</target>
        </trans-unit>
        <trans-unit id="aa8720f51b774a70c5f7cce02a309b8eb281c900" translate="yes" xml:space="preserve">
          <source>This section provides an overview of and example code demonstrating the integration of RBU Vacuum into an application program. For full details, refer to the comments in &lt;a href=&quot;http://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h&quot;&gt;header file sqlite3rbu.h&lt;/a&gt;.</source>
          <target state="translated">本节概述了示例代码，并演示了将RBU Vacuum集成到应用程序中的示例代码。有关完整的详细信息，请参见&lt;a href=&quot;http://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h&quot;&gt;头文件sqlite3rbu.h中&lt;/a&gt;的注释。</target>
        </trans-unit>
        <trans-unit id="6c2f6418e2cfdab367ef3398ce17bbd29bfdf0e6" translate="yes" xml:space="preserve">
          <source>This section provides examples that demonstrate how to use the sessions extension.</source>
          <target state="translated">本节提供了一些例子来演示如何使用会话扩展。</target>
        </trans-unit>
        <trans-unit id="4b87966e6f8ae748c88886a65d993a4d228e6112" translate="yes" xml:space="preserve">
          <source>This sets the maximum number of statements that can be cached. The upper limit is 100. The default is 10. If you set the cache size to 0, no caching is done.</source>
          <target state="translated">此项设置可以缓存的语句的最大数量。上限是100条。默认值是10。如果将缓存大小设置为0,则不进行缓存。</target>
        </trans-unit>
        <trans-unit id="6ac8ffe5a0d74c555a62f1b92afaea89504bf302" translate="yes" xml:space="preserve">
          <source>This setting defaults to &quot;on&quot; for legacy compatibility, however all applications are advised to turn it off if possible. This setting can also be controlled using the &lt;a href=&quot;../pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema&lt;/a&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5315120760f3d3f82397813611296a7c3158949" translate="yes" xml:space="preserve">
          <source>This setting defaults to &quot;on&quot; for legacy compatibility, however all applications are advised to turn it off if possible. This setting can also be controlled using the &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema&lt;/a&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e77f8448a0f37903a1b46b5a44275edbc4cdc59" translate="yes" xml:space="preserve">
          <source>This spellfix1 &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; can be used to search a large vocabulary for close matches. For example, spellfix1 can be used to suggest corrections to misspelled words. Or, it could be used with &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; to do full-text search using potentially misspelled words.</source>
          <target state="translated">此spellfix1 &lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;可用于搜索大词汇表以查找紧密匹配项。例如，spellfix1可用于建议对拼写错误的单词的更正。或者，它可以与&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;一起使用，以使用可能拼写错误的单词进行全文搜索。</target>
        </trans-unit>
        <trans-unit id="6b40152c9ab376b3fd172fa9a2eebf595b1b8d89" translate="yes" xml:space="preserve">
          <source>This statement detaches an additional database connection previously attached using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. When not in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, it is possible to have the same database file attached multiple times using different names, and detaching one connection to a file will leave the others intact.</source>
          <target state="translated">该语句分离以前使用&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;语句附加的其他数据库连接。如果不在&lt;a href=&quot;sharedcache&quot;&gt;共享缓存模式下&lt;/a&gt;，则可以使用不同的名称多次附加同一数据库文件，而将一个连接分离到一个文件将使其他连接保持完整。</target>
        </trans-unit>
        <trans-unit id="34e0116d5c2febec8b6ae2d5a756ac7b5b48d70e" translate="yes" xml:space="preserve">
          <source>This step corresponds to steps &lt;a href=&quot;#section_3_8&quot;&gt;3.8&lt;/a&gt;, &lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt;, and &lt;a href=&quot;#section_3_10&quot;&gt;3.10&lt;/a&gt; in the single-file commit scenario described previously.</source>
          <target state="translated">该步骤对应于步骤&lt;a href=&quot;#section_3_8&quot;&gt;3.8&lt;/a&gt;，&lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt;和&lt;a href=&quot;#section_3_10&quot;&gt;3.10&lt;/a&gt;在单文件提交方案如前所述。</target>
        </trans-unit>
        <trans-unit id="0bc82eb6eb64e5996a7d75a58cb1d3a4ce9124d4" translate="yes" xml:space="preserve">
          <source>This step is analogous to &lt;a href=&quot;#section_3_7&quot;&gt;step 3.7&lt;/a&gt; in the single-file commit scenario described above.</source>
          <target state="translated">此步骤类似于上述单文件提交方案中的&lt;a href=&quot;#section_3_7&quot;&gt;步骤3.7&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e70a15ffedf708ad5c91c97bd2e22cff7b5bcebe" translate="yes" xml:space="preserve">
          <source>This step is usually more complicated than simply flushing the rollback journal to the disk. On most platforms two separate flush (or fsync()) operations are required. The first flush writes out the base rollback journal content. Then the header of the rollback journal is modified to show the number of pages in the rollback journal. Then the header is flushed to disk. The details on why we do this header modification and extra flush are provided in a later section of this paper.</source>
          <target state="translated">这一步通常比简单地将回滚日志刷新到磁盘上要复杂得多,在大多数平台上,需要进行两个单独的刷新(或fsync())操作。在大多数平台上,需要进行两个独立的刷新(或fsync())操作。第一次刷新会写出基本的回滚日志内容。然后修改回滚日志的标题,以显示回滚日志的页数。然后将头刷新到磁盘上。关于为什么要做这个头的修改和额外的刷新,本文后面的章节会详细介绍。</target>
        </trans-unit>
        <trans-unit id="60743213af70350c2b0e4cdfe091bf8177abcaf2" translate="yes" xml:space="preserve">
          <source>This structure, sometimes called a &quot;virtual table module&quot;, defines the implementation of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;. This structure consists mostly of methods for the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efa2100d52bcf7ffba30b15c96c96f87de04a155" translate="yes" xml:space="preserve">
          <source>This structure, sometimes called a &quot;virtual table module&quot;, defines the implementation of a &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt;. This structure consists mostly of methods for the module.</source>
          <target state="translated">这种结构有时称为&amp;ldquo;虚拟表模块&amp;rdquo;，它定义了&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;的实现。该结构主要由模块的方法组成。</target>
        </trans-unit>
        <trans-unit id="5114924ab3d2182dbc86222d1c257aa678f84e0e" translate="yes" xml:space="preserve">
          <source>This structure, sometimes called a &quot;virtual table module&quot;, defines the implementation of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;. This structure consists mostly of methods for the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b149e60f46d57857e167e94989fa609269eabe7" translate="yes" xml:space="preserve">
          <source>This structure, sometimes called a &quot;virtual table module&quot;, defines the implementation of a &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;. This structure consists mostly of methods for the module.</source>
          <target state="translated">这种结构有时称为&amp;ldquo;虚拟表模块&amp;rdquo;，它定义了&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;的实现。该结构主要由模块的方法组成。</target>
        </trans-unit>
        <trans-unit id="c18963c23800694aa33718fdc0a2deeb514a26e5" translate="yes" xml:space="preserve">
          <source>This substitution works like %q except that it doubles all double-quote characters (&quot;) instead of single-quotes, making the result suitable for using with a double-quoted identifier name in an SQL statement.</source>
          <target state="translated">这个替换和%q的工作原理一样,只是它将所有双引号字符(&quot;)加倍,而不是单引号,使得结果适合在SQL语句中与双引号标识符名称一起使用。</target>
        </trans-unit>
        <trans-unit id="42be9e1e34f4a968dedd36f548fc29765ab65613" translate="yes" xml:space="preserve">
          <source>This superclass exists in order to define fields of the cursor that are common to all implementations.</source>
          <target state="translated">这个超类的存在是为了定义游标的字段,这些字段对所有的实现都是通用的。</target>
        </trans-unit>
        <trans-unit id="28a7628277525a8ffd76f253de9da66f017821fe" translate="yes" xml:space="preserve">
          <source>This table contains most of the full-text index data.</source>
          <target state="translated">该表包含了大部分的全文索引数据。</target>
        </trans-unit>
        <trans-unit id="63f8d9aa5562f8625c8b6180eed7f4824807c199" translate="yes" xml:space="preserve">
          <source>This table contains the remainder of the full-text index data. It is almost always much smaller than the &amp;lt;name&amp;gt;_data table.</source>
          <target state="translated">该表包含全文索引数据的其余部分。它几乎总是比&amp;lt;name&amp;gt; _data表小得多。</target>
        </trans-unit>
        <trans-unit id="99a29c55c2ba7d8e5ed532c3667ff2c75e355b87" translate="yes" xml:space="preserve">
          <source>This template will be expanded considerably as we consider additional complications such as joins, compound selects, using indices to speed the search, sorting, and aggregate functions with and without GROUP BY and HAVING clauses. But the same basic ideas will continue to apply.</source>
          <target state="translated">这个模板将得到很大的扩展,因为我们将考虑更多的复杂情况,如连接、复合选择、使用索引来加快搜索、排序和聚合函数,有或没有GROUP BY和HAVING子句。但同样的基本思想将继续适用。</target>
        </trans-unit>
        <trans-unit id="24117611eed72daf6182805466d7956918d024ae" translate="yes" xml:space="preserve">
          <source>This template will work, but it is likely to be slow since we are now dealing with an O(N&lt;sup&gt;2&lt;/sup&gt;) loop. But it often works out that the WHERE clause can be factored into terms and that one or more of those terms will involve only columns in the first table. When this happens, we can factor part of the WHERE clause test out of the inner loop and gain a lot of efficiency. So a better template would be something like this:</source>
          <target state="translated">该模板可以工作，但是由于我们现在正在处理O（N &lt;sup&gt;2&lt;/sup&gt;）循环，因此它可能会很慢。但是通常可以得出结论，可以将WHERE子句分解为术语，并且其中一个或多个这些术语将仅涉及第一个表中的列。发生这种情况时，我们可以将WHERE子句测试的一部分从内部循环中分解出来，并获得很大的效率。因此，更好的模板如下所示：</target>
        </trans-unit>
        <trans-unit id="40b7eb475c7480d45cf5d3a80f0e3d7ffa7f110b" translate="yes" xml:space="preserve">
          <source>This test does 100 queries on a 25000 entry table without an index, thus requiring a full table scan. Prior versions of SQLite used to be slower than PostgreSQL and MySQL on this test, but recent performance enhancements have increased its speed so that it is now the fastest of the group.</source>
          <target state="translated">这个测试在一个25000条目的表上做100个查询,没有索引,因此需要全表扫描。以前的SQLite版本在这个测试中曾经比PostgreSQL和MySQL慢,但最近的性能提升提高了它的速度,所以它现在是这组中最快的。</target>
        </trans-unit>
        <trans-unit id="90bd4e8e5db8b4283e65f22e76a0a17334a8b857" translate="yes" xml:space="preserve">
          <source>This test is significant because it is one of the few where PostgreSQL is faster than MySQL. The asynchronous SQLite is, however, faster then both the other two.</source>
          <target state="translated">这个测试很重要,因为它是少数几个PostgreSQL比MySQL快的测试之一。然而,异步SQLite比其他两个都要快。</target>
        </trans-unit>
        <trans-unit id="ff90f130b4a2f4ca55eaa179d90bc136860c0418" translate="yes" xml:space="preserve">
          <source>This test still does 100 full table scans but it uses uses string comparisons instead of numerical comparisons. SQLite is over three times faster than PostgreSQL here and about 30% faster than MySQL.</source>
          <target state="translated">这个测试仍然是进行100次全表扫描,但它使用的是字符串比较而不是数字比较。SQLite在这里比PostgreSQL快3倍以上,比MySQL快30%左右。</target>
        </trans-unit>
        <trans-unit id="75cb6907a37685d70c3eab0489918444cffd71bd" translate="yes" xml:space="preserve">
          <source>This value may only be returned if the second argument to the conflict handler was SQLITE_CHANGESET_DATA or SQLITE_CHANGESET_CONFLICT. If this is not the case, any changes applied so far are rolled back and the call to sqlite3changeset_apply() returns SQLITE_MISUSE.</source>
          <target state="translated">只有当冲突处理程序的第二个参数是SQLITE_CHANGESET_DATA或SQLITE_CHANGESET_CONFLICT时,才可以返回这个值。如果不是这种情况,那么到目前为止应用的任何更改都会被回滚,并且调用 sqlite3changeset_apply()会返回 SQLITE_MISUSE。</target>
        </trans-unit>
        <trans-unit id="fe35134e2f2f77c904cd39e87bb164a345691cc7" translate="yes" xml:space="preserve">
          <source>This version of the query is very similar to that used by the &lt;a href=&quot;http://www.sqlite.org/search?q=fts3&quot;&gt;sqlite.org documentation search&lt;/a&gt; application.</source>
          <target state="translated">此版本的查询与&lt;a href=&quot;http://www.sqlite.org/search?q=fts3&quot;&gt;sqlite.org文档搜索&lt;/a&gt;应用程序使用的查询非常相似。</target>
        </trans-unit>
        <trans-unit id="e1b7ba2bf7de254b6233045869c121647086b777" translate="yes" xml:space="preserve">
          <source>This way, even if the tokenizer does not provide synonyms when tokenizing query text (it should not - to do so would be inefficient), it doesn't matter if the user queries for 'first + place' or '1st + place', as there are entries in the FTS index corresponding to both forms of the first token.</source>
          <target state="translated">这样一来,即使tokenizer在对查询文本进行token化时没有提供同义词(不应该这样做--这样做会很低效),用户查询 &quot;first+place &quot;或 &quot;1st+place &quot;也没有关系,因为在FTS索引中,有条目对应于第一个token的两种形式。</target>
        </trans-unit>
        <trans-unit id="8b49b7dda3f7ed95bc6c0488f10b2d72b542544f" translate="yes" xml:space="preserve">
          <source>This way, it doesn't matter if the unlock-notify callback has already been invoked, or is being invoked, when the wait_for_unlock_notify() thread begins blocking.</source>
          <target state="translated">这样,当wait_for_unlock_notify()线程开始阻塞时,不管解锁通知回调是否已经被调用,或者正在被调用。</target>
        </trans-unit>
        <trans-unit id="e965074df0aa19e8da42be140ba59a4414b6e325" translate="yes" xml:space="preserve">
          <source>This way, the constraint is enforced by SQLite. Attempting to insert a row into the</source>
          <target state="translated">这样一来,约束就被SQLite强制执行了。试图将一条记录插入到</target>
        </trans-unit>
        <trans-unit id="1963503ab7ddc8537d802ec1a46d6ab92fd36cda" translate="yes" xml:space="preserve">
          <source>This works just like the Eq opcode except that the jump is taken if the operands in registers P1 and P3 are not equal. See the Eq opcode for additional information.</source>
          <target state="translated">除了在寄存器P1和P3中的操作数不相等时进行跳转外,该操作码的工作原理与Eq操作码相同。更多信息请参见Eq操作码。</target>
        </trans-unit>
        <trans-unit id="ba4077bf92f07ea1c02be8f845355e71e2fb6bc1" translate="yes" xml:space="preserve">
          <source>This works just like the Lt opcode except that the jump is taken if the content of register P3 is greater than or equal to the content of register P1. See the Lt opcode for additional information.</source>
          <target state="translated">这和Lt操作码的工作原理一样,只是如果寄存器P3的内容大于或等于寄存器P1的内容,就会进行跳转。更多信息请参见Lt操作码。</target>
        </trans-unit>
        <trans-unit id="72ecdb2970fef3b315f55cce910e6f260e472e04" translate="yes" xml:space="preserve">
          <source>This works just like the Lt opcode except that the jump is taken if the content of register P3 is greater than the content of register P1. See the Lt opcode for additional information.</source>
          <target state="translated">这和Lt操作码的工作原理一样,只是如果寄存器P3的内容大于寄存器P1的内容,就会进行跳转。更多信息请参见Lt操作码。</target>
        </trans-unit>
        <trans-unit id="c1c247f5679a36aaa3ff0f0b8bb4e1ddc0bb02eb" translate="yes" xml:space="preserve">
          <source>This works just like the Lt opcode except that the jump is taken if the content of register P3 is less than or equal to the content of register P1. See the Lt opcode for additional information.</source>
          <target state="translated">这和Lt操作码的工作原理一样,只是如果寄存器P3的内容小于或等于寄存器P1的内容,就会进行跳转。更多信息请参见Lt操作码。</target>
        </trans-unit>
        <trans-unit id="ccca64f89115392e8d23869e20d951ca911dd666" translate="yes" xml:space="preserve">
          <source>Those columns of the ORDER BY that are already in the correct order due to indexes can be omitted from the sort key, further reducing storage requirements and CPU time.</source>
          <target state="translated">ORDER BY中那些因为索引而已经正确排序的列,可以从排序键中省略,进一步减少存储需求和CPU时间。</target>
        </trans-unit>
        <trans-unit id="3d2c9c2c10bcace961c3bdf096488ff4797705a5" translate="yes" xml:space="preserve">
          <source>Those familiar with &lt;a href=&quot;lang_createtrigger&quot;&gt;SQLite triggers&lt;/a&gt; will have noticed that the &quot;ON DELETE SET DEFAULT&quot; action demonstrated in the example above is similar in effect to the following AFTER DELETE trigger:</source>
          <target state="translated">那些熟悉&lt;a href=&quot;lang_createtrigger&quot;&gt;SQLite触发器的人&lt;/a&gt;会注意到，上例中演示的&amp;ldquo; ON DELETE SET DEFAULT&amp;rdquo;操作实际上与以下AFTER DELETE触发器类似：</target>
        </trans-unit>
        <trans-unit id="3d18009fe3f6af8b99678afaf8cbdbff34a63626" translate="yes" xml:space="preserve">
          <source>Though SQLite is resistant to database corruption, it is not immune. This document describes the various ways that an SQLite database might go corrupt.</source>
          <target state="translated">虽然SQLite对数据库损坏有抵抗力,但也不能幸免。本文档描述了SQLite数据库可能发生损坏的各种方式。</target>
        </trans-unit>
        <trans-unit id="63d965d7269cad4f0b5e995d2cd0b230b8d8b12b" translate="yes" xml:space="preserve">
          <source>Though most application should not notice any change (except that they run a little faster), if problems arise then the legacy behavior can be restored at compile-time by using the following options to the C-compiler:</source>
          <target state="translated">虽然大多数应用程序应该不会注意到任何变化(除了运行速度快了一点),但如果出现问题,那么可以在编译时通过使用以下选项恢复C-编译器的遗留行为。</target>
        </trans-unit>
        <trans-unit id="b87710f7e7be3fc29f9b95f7ed9731b29e09de9b" translate="yes" xml:space="preserve">
          <source>Though stable now, when SQLite was first designed, the rules for unicode case folding where still in flux. That means that the behavior might have changed with each new unicode release, disrupting applications and corrupting indexes in the process.</source>
          <target state="translated">虽然现在很稳定,但在最初设计SQLite时,unicode大小写折叠的规则还在不断变化中,这意味着行为可能会随着每个新的unicode版本的发布而改变,扰乱应用程序并破坏索引。这意味着行为可能会随着每个新的unicode版本的发布而改变,在此过程中会破坏应用程序并损坏索引。</target>
        </trans-unit>
        <trans-unit id="32c0373383e43339e4cb612416beb69372e9cd00" translate="yes" xml:space="preserve">
          <source>Though these routines exist for the use of the SQLite core, application code is free to use these routines as well, if desired. A mutex is an &lt;a href=&quot;c3ref/mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object. The &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt; routine allocates a new mutex object and returns a pointer to it. The argument to &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt; should be &lt;a href=&quot;c3ref/c_mutex_fast&quot;&gt;SQLITE_MUTEX_FAST&lt;/a&gt; or &lt;a href=&quot;c3ref/c_mutex_fast&quot;&gt;SQLITE_MUTEX_RECURSIVE&lt;/a&gt; for non-recursive and recursive mutexes, respectively. If the underlying system does not provide non-recursive mutexes, then a recursive mutex can be substituted in that case. The argument to &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt; can also be a constant designating one of several static mutexes:</source>
          <target state="translated">尽管存在使用SQLite核心的例程，但如果需要，应用程序代码也可以自由使用这些例程。互斥锁是&lt;a href=&quot;c3ref/mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;对象。所述&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_alloc（）&lt;/a&gt;例行程序分配一个新的互斥对象，并返回一个指向它的指针。对于非递归和递归互斥对象，&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_alloc（）&lt;/a&gt;的参数应分别为&lt;a href=&quot;c3ref/c_mutex_fast&quot;&gt;SQLITE_MUTEX_FAST&lt;/a&gt;或&lt;a href=&quot;c3ref/c_mutex_fast&quot;&gt;SQLITE_MUTEX_RECURSIVE&lt;/a&gt;。如果基础系统不提供非递归互斥锁，则在这种情况下可以替换递归互斥锁。&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_alloc（）&lt;/a&gt;的参数也可以是一个常量，它指定多个静态互斥锁之一：</target>
        </trans-unit>
        <trans-unit id="bd8e45f7c88cdfcb99131b4aaa5838c20ed6b8b6" translate="yes" xml:space="preserve">
          <source>Threads pragma</source>
          <target state="translated">线程 Pragma</target>
        </trans-unit>
        <trans-unit id="4aa00012e302f932462a2aadd7eac2be49a6dc69" translate="yes" xml:space="preserve">
          <source>Three independently developed test harnesses</source>
          <target state="translated">三个独立开发的测试线束</target>
        </trans-unit>
        <trans-unit id="101417f647e79751240d39257253cbe0e7dba110" translate="yes" xml:space="preserve">
          <source>Three new &quot;_pointer()&quot; interfaces were added to SQLite 3.20.0 (2017-08-01):</source>
          <target state="translated">SQLite 3.20.0(2017-08-01)新增了三个&quot;_pointer()&quot;接口。</target>
        </trans-unit>
        <trans-unit id="176df8577c19b0a0b1cbe128b8ab9971af780b41" translate="yes" xml:space="preserve">
          <source>Three new interfaces are used to create alternative OS interfaces: &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;, &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_unregister()&lt;/a&gt;, and &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt;.</source>
          <target state="translated">使用三个新接口来创建备用OS接口：&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;，&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_unregister（）&lt;/a&gt;和&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bddfc84ad3ee0ff45f2511104b4769a3c7921c10" translate="yes" xml:space="preserve">
          <source>Three new objects are defined for specifying I/O procedures: &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;, &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;, and &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;.</source>
          <target state="translated">定义了三个用于指定I / O过程的新对象：&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;，&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;和&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26f24f48d0d16296ec7a50525c0bafe03ba4c4e6" translate="yes" xml:space="preserve">
          <source>Three separate builds are used to validate the SQLite software.</source>
          <target state="translated">三个独立的构建是用来验证SQLite软件的。</target>
        </trans-unit>
        <trans-unit id="72ea1e12fc0eda1090ebcae83911a5114d06b045" translate="yes" xml:space="preserve">
          <source>Throughout this article, we will call the mass storage device &quot;disk&quot; even though the mass storage device might really be flash memory.</source>
          <target state="translated">在本文中,我们将把大容量存储设备称为 &quot;磁盘&quot;,尽管大容量存储设备可能真的是闪存。</target>
        </trans-unit>
        <trans-unit id="e196474211e435a6f5483b8a22aa9fc7215731cf" translate="yes" xml:space="preserve">
          <source>Throw an error if the ON clause of a LEFT JOIN references tables to the right of the ON clause. This is the same behavior as PostgreSQL. Formerly, SQLite silently converted the LEFT JOIN into an INNER JOIN. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/25e335f802dd&quot;&gt;25e335f802dd&lt;/a&gt;.</source>
          <target state="translated">如果LEFT JOIN的ON子句引用ON子句右边的表，则会引发错误。这与PostgreSQL的行为相同。以前，SQLite默默地将LEFT JOIN转换为INNER JOIN。修复票证&lt;a href=&quot;https://www.sqlite.org/src/info/25e335f802dd&quot;&gt;25e335f802dd&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="21549ff8099c71713aab7703fb00b1ee44e6073d" translate="yes" xml:space="preserve">
          <source>Thus a long-running read transaction can prevent a checkpointer from making progress. But presumably every read transaction will eventually end and the checkpointer will be able to continue.</source>
          <target state="translated">因此,一个长期运行的读事务会阻止检查指针的进展。但大概每个读事务最终都会结束,检查指针将能够继续。</target>
        </trans-unit>
        <trans-unit id="66a9c8441c0a2a7c6aa8fad21d196fb6d9fccc17" translate="yes" xml:space="preserve">
          <source>Thus, in some cases, a WITHOUT ROWID table can use about half the amount of disk space and can operate nearly twice as fast. Of course, in a real-world schema, there will typically be secondary indices and/or UNIQUE constraints, and the situation is more complicated. But even then, there can often be space and performance advantages to using WITHOUT ROWID on tables that have non-integer or composite PRIMARY KEYs.</source>
          <target state="translated">因此,在某些情况下,without ROWID表可以使用大约一半的磁盘空间,而且运行速度几乎是两倍。当然,在现实世界的模式中,通常会有二级索引和/或UNIQUE约束,情况比较复杂。但即便如此,在有非整数或复合primary keys的表上使用without rowid往往可以获得空间和性能上的优势。</target>
        </trans-unit>
        <trans-unit id="c862bae7f1be02bdcb9d8e255dd3ec4c98f14797" translate="yes" xml:space="preserve">
          <source>Time Strings</source>
          <target state="translated">时间字符串</target>
        </trans-unit>
        <trans-unit id="3efef30f9e54a3aa98bf3ea7266c1fe5e32903a6" translate="yes" xml:space="preserve">
          <source>Timeout method</source>
          <target state="translated">超时方法</target>
        </trans-unit>
        <trans-unit id="4c2102fd7eb59a1aa14201958dca73486b19babc" translate="yes" xml:space="preserve">
          <source>Tip: If the application requires a stricter relationship between</source>
          <target state="translated">提示:如果应用程序需要更严格的之间的关系。</target>
        </trans-unit>
        <trans-unit id="9e8b45c5519a803740f95fa980a6771d28344be2" translate="yes" xml:space="preserve">
          <source>Tip: If the command &quot;PRAGMA foreign_keys&quot; returns no data instead of a single row containing &quot;0&quot; or &quot;1&quot;, then the version of SQLite you are using does not support foreign keys (either because it is older than 3.6.19 or because it was compiled with &lt;a href=&quot;compile#omit_foreign_key&quot;&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/a&gt; or &lt;a href=&quot;compile#omit_trigger&quot;&gt;SQLITE_OMIT_TRIGGER&lt;/a&gt; defined).</source>
          <target state="translated">提示：如果命令&amp;ldquo; PRAGMA foreign_keys&amp;rdquo;不返回任何数据，而不是包含&amp;ldquo; 0&amp;rdquo;或&amp;ldquo; 1&amp;rdquo;的单行，则您使用的SQLite版本不支持外键（因为它早于3.6.19或因为它是使用&lt;a href=&quot;compile#omit_trigger&quot;&gt;已&lt;/a&gt;定义的&lt;a href=&quot;compile#omit_foreign_key&quot;&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/a&gt;或SQLITE_OMIT_TRIGGER编译的）。</target>
        </trans-unit>
        <trans-unit id="c0bd7276e013b0c8d316928d427b046dc76a4f10" translate="yes" xml:space="preserve">
          <source>To &quot;apply affinity&quot; means to convert an operand to a particular storage class if and only if the conversion does not lose essential information. Numeric values can always be converted into TEXT. TEXT values can be converted into numeric values if the text content is a well-formed integer or real literal, but not a hexadecimal integer literal. BLOB values are converted into TEXT values by simply interpreting the binary BLOB context as a text string in the current database encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9953da657538c4e50d519e562b12ca1980f1dcb7" translate="yes" xml:space="preserve">
          <source>To &quot;apply affinity&quot; means to convert an operand to a particular storage class if and only if the conversion is lossless and reversible. Affinity is applied to operands of a comparison operator prior to the comparison according to the following rules in the order shown:</source>
          <target state="translated">&quot;应用亲和力 &quot;是指将操作数转换为特定的存储类,如果且仅当转换是无损和可逆的。亲和力在比较操作数之前按照下列规则按所示顺序应用于比较操作数。</target>
        </trans-unit>
        <trans-unit id="5a8c0c09fa3a23fe732db499c52749bc592395f7" translate="yes" xml:space="preserve">
          <source>To SQL, the values created by &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; are indistinguishable from NULL. An SQL statement that tries to use the &lt;a href=&quot;lang_corefunc#hex&quot;&gt;hex()&lt;/a&gt; function to read the value of a pointer will get an SQL NULL answer. The only way to discover whether or not a value has an associated pointer is to use the &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; interface with the appropriate type string T.</source>
          <target state="translated">对于SQL，由&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;和&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;创建的值与NULL是无法区分的。尝试使用&lt;a href=&quot;lang_corefunc#hex&quot;&gt;hex（）&lt;/a&gt;函数读取指针值的SQL语句将获得SQL NULL答案。发现值是否具有关联的指针的唯一方法是使用带有适当类型字符串T 的&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="bd20e3a8ddd8b4faa78ec9a165e77cef8f3d196f" translate="yes" xml:space="preserve">
          <source>To achieve the best long-term query performance without the need to do a detailed engineering analysis of the application schema and SQL, it is recommended that applications run &quot;PRAGMA optimize&quot; (with no arguments) just before closing each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. Long-running applications might also benefit from setting a timer to run &quot;PRAGMA optimize&quot; every few hours.</source>
          <target state="translated">为了获得最佳的长期查询性能，而无需对应用程序模式和SQL进行详细的工程分析，建议在关闭每个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;之前，应用程序运行&amp;ldquo; PRAGMAoptimize&amp;rdquo;（不带参数）。长时间运行的应用程序还可以通过设置计时器每隔几个小时运行一次&amp;ldquo; PRAGMA优化&amp;rdquo;来受益。</target>
        </trans-unit>
        <trans-unit id="4711fd773d775e7aba9628e842931be929ca6432" translate="yes" xml:space="preserve">
          <source>To activate memory-mapped I/O, an application can set the mmap_size to some large value. For example:</source>
          <target state="translated">为了激活内存映射的I/O,应用程序可以将mmap_size设置为某个大值。例如:</target>
        </trans-unit>
        <trans-unit id="645a357eaf144992f34fe37551ab4e935405fce2" translate="yes" xml:space="preserve">
          <source>To activate the undo/redo logic, invoke the undo::activate command with all classes (tables) that are to participate in the undo/redo as arguments. Use undo::deactivate, undo::freeze, and undo::unfreeze to control the state of the undo/redo mechanism.</source>
          <target state="translated">要激活 undo::activate 逻辑,请调用 undo::activate 命令,将所有要参与 undo/redo 的类(表)作为参数。使用 undo::deactivate、undo::freeze 和 undo::unfreeze 来控制 undo/redo 机制的状态。</target>
        </trans-unit>
        <trans-unit id="fd71ab2838c8371371ec0d2fdb4dcfcc6665885b" translate="yes" xml:space="preserve">
          <source>To add or update files in an existing SQLite Archive:</source>
          <target state="translated">在现有的SQLite存档中添加或更新文件。</target>
        </trans-unit>
        <trans-unit id="4ae1010309917f14b49ddef52acc40466e6c17b8" translate="yes" xml:space="preserve">
          <source>To add prefix indexes to an FTS5 table, the &quot;prefix&quot; option is set to either a single positive integer or a text value containing a white-space separated list of one or more positive integer values. A prefix index is created for each integer specified. If more than one &quot;prefix&quot; option is specified as part of a single CREATE VIRTUAL TABLE statement, all apply.</source>
          <target state="translated">要将前缀索引添加到FTS5表中,&quot;前缀 &quot;选项被设置为一个单一的正整数或一个包含一个或多个正整数值的空白分隔列表的文本值。每个指定的整数都会创建一个前缀索引。如果在一个CREATE VIRTUAL TABLE语句中指定了一个以上的 &quot;前缀 &quot;选项,那么所有的前缀都适用。</target>
        </trans-unit>
        <trans-unit id="c191d56879fcb319acf75a9863fb0fa338e351b7" translate="yes" xml:space="preserve">
          <source>To append an element onto the end of an array, using json_insert() with an array index of &quot;#&quot;. Examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9404c6d887c060fefd19170a66f575055b2dffb6" translate="yes" xml:space="preserve">
          <source>To avoid a parsing ambiguity, the SELECT statement should always contain a WHERE clause, even if that clause is simply &quot;WHERE true&quot;, if the &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt; is present. Without the WHERE clause, the parser does not know if the token &quot;ON&quot; is part of a join constraint on the SELECT, or the beginning of the &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;.</source>
          <target state="translated">为避免语法歧义，SELECT语句应始终包含WHERE子句，即使该子句只是&amp;ldquo; WHERE true&amp;rdquo;（如果存在&lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert子句）&lt;/a&gt;也是如此。没有WHERE子句，解析器将不知道标记&amp;ldquo; ON&amp;rdquo;是否是SELECT上的&lt;a href=&quot;syntax/upsert-clause&quot;&gt;联接&lt;/a&gt;约束的一部分，还是upsert-clause的开头。</target>
        </trans-unit>
        <trans-unit id="a1e573e48b1d1bbc7ead62db489ded9fccb8416c" translate="yes" xml:space="preserve">
          <source>To avoid a resource leak, every open &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; should eventually be released by a call to &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;.</source>
          <target state="translated">为了避免资源泄漏，最终应通过调用&lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close（）&lt;/a&gt;释放每个打开的&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB句柄&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d1fa3979b4e4aef1b6ce33c8f42fa7bd685b437c" translate="yes" xml:space="preserve">
          <source>To avoid a resource leak, every open &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; should eventually be released by a call to &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;.</source>
          <target state="translated">为了避免资源泄漏，最终应通过调用&lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close（）&lt;/a&gt;释放每个打开的&lt;a href=&quot;blob&quot;&gt;BLOB句柄&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1ab3db1a50085aa74a015739222af42ac2d31de2" translate="yes" xml:space="preserve">
          <source>To avoid creating the temporary table, the query might be rewritten as follows:</source>
          <target state="translated">为了避免创建临时表,查询可以改写如下。</target>
        </trans-unit>
        <trans-unit id="a939a1a7b1b6da9d7410b936fb953adb2a10ab14" translate="yes" xml:space="preserve">
          <source>To avoid deadlocks and other threading problems, the sqlite3_log() routine will not use dynamically allocated memory. The log message is stored in a fixed-length buffer on the stack. If the log message is longer than a few hundred characters, it will be truncated to the length of the buffer.</source>
          <target state="translated">为了避免死锁和其他线程问题,sqlite3_log()例程不会使用动态分配的内存。日志信息存储在堆栈上一个固定长度的缓冲区中。如果日志信息超过几百个字符,它将被截断到缓冲区的长度。</target>
        </trans-unit>
        <trans-unit id="4d1915ee0fe2780a5f846ddace0d96d4a65194c4" translate="yes" xml:space="preserve">
          <source>To avoid having to register all collation sequences before a database can be used, a single callback function may be registered with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; to be invoked whenever an undefined collation sequence is required.</source>
          <target state="translated">为了避免在使用数据库之前必须注册所有排序规则序列，只要需要未定义的排序规则序列，就可以在要调用的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接中&lt;/a&gt;注册单个回调函数。</target>
        </trans-unit>
        <trans-unit id="e2a04aec5cbeb09fcc4e41c36a55b1da3e1b43d6" translate="yes" xml:space="preserve">
          <source>To avoid having to register all collation sequences before a database can be used, a single callback function may be registered with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; to be invoked whenever an undefined collation sequence is required.</source>
          <target state="translated">为了避免在使用数据库之前必须注册所有排序规则序列，只要需要未定义的排序规则序列，就可以在要调用的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接中&lt;/a&gt;注册单个回调函数。</target>
        </trans-unit>
        <trans-unit id="f9e3ed74fe6098d68e31f0bee29e829f469078e4" translate="yes" xml:space="preserve">
          <source>To avoid name collisions, all external symbols in the SQLite library begin with the prefix &lt;b&gt;sqlite3&lt;/b&gt;. Those symbols that are intended for external use (in other words, those symbols which form the API for SQLite) add an underscore, and thus begin with &lt;b&gt;sqlite3_&lt;/b&gt;. Extension APIs sometimes add the extension name prior to the underscore; for example: &lt;b&gt;sqlite3rbu_&lt;/b&gt; or &lt;b&gt;sqlite3session_&lt;/b&gt;.</source>
          <target state="translated">为了避免名称冲突，SQLite库中的所有外部符号都以前缀&lt;b&gt;sqlite3&lt;/b&gt;开头。这些供外部使用的符号（换句话说，构成SQLite API的那些符号）添加了下划线，因此以&lt;b&gt;sqlite3_&lt;/b&gt;开头。扩展API有时会在下划线之前添加扩展名。例如：&lt;b&gt;sqlite3rbu_&lt;/b&gt;或&lt;b&gt;sqlite3session_&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="51b8dbcd79c868e6c2b51fbc0d8f4e62d1ce3707" translate="yes" xml:space="preserve">
          <source>To avoid spiky INSERT performance, an application can run the &quot;merge=X,Y&quot; command periodically, possibly in an idle thread or idle process, to ensure that the FTS table never accumulates too many b-tree segments at the same level. INSERT performance spikes can generally be avoided, and performance of FTS3/4 can be maximized, by running &quot;merge=X,Y&quot; after every few thousand document inserts. Each &quot;merge=X,Y&quot; command will run in a separate transaction (unless they are grouped together using &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;...&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;, of course). The transactions can be kept small by choosing a value for X in the range of 100 to 300. The idle thread that is running the merge commands can know when it is done by checking the difference in &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; before and after each &quot;merge=X,Y&quot; command and stopping the loop when the difference drops below two.</source>
          <target state="translated">为了避免尖锐的INSERT性能，应用程序可以定期（可能在空闲线程或空闲进程中）运行&amp;ldquo; merge = X，Y&amp;rdquo;命令，以确保FTS表在同一级别上永远不会累积太多的b树段。通过每插入几千个文档后运行&amp;ldquo; merge = X，Y&amp;rdquo;，通常可以避免INSERT性能峰值，并且可以最大化FTS3 / 4的性能。每个&amp;ldquo; merge = X，Y&amp;rdquo;命令将在单独的事务中运行（当然，除非使用&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; ... &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;将它们分组在一起）。通过为X选择一个介于100到300之间的值，可以使事务保持较小状态。运行合并命令的空闲线程可以通过检查&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）中&lt;/a&gt;的差异来知道何时完成该事务。 在每个&amp;ldquo; merge = X，Y&amp;rdquo;命令之前和之后，并在差值降至2以下时停止循环。</target>
        </trans-unit>
        <trans-unit id="bed15fd00e4480b7c81ecee249b2b398f62c1b86" translate="yes" xml:space="preserve">
          <source>To avoid this scenario, the sqlite3_unlock_notify() performs deadlock detection. If a given call to sqlite3_unlock_notify() would put the system in a deadlocked state, then SQLITE_LOCKED is returned and no unlock-notify callback is registered. The system is said to be in a deadlocked state if connection A has registered for an unlock-notify callback on the conclusion of connection B's transaction, and connection B has itself registered for an unlock-notify callback when connection A's transaction is concluded. Indirect deadlock is also detected, so the system is also considered to be deadlocked if connection B has registered for an unlock-notify callback on the conclusion of connection C's transaction, where connection C is waiting on connection A. Any number of levels of indirection are allowed.</source>
          <target state="translated">为了避免这种情况,sqlite3_unlock_notify()执行死锁检测。如果给定的对 sqlite3_unlock_notify()的调用会使系统处于死锁状态,那么返回 SQLITE_LOCKED,并且没有注册任何解锁-通知回调。如果连接A在连接B的事务结束时注册了一个解锁-通知回调,而连接B在连接A的事务结束时自己也注册了一个解锁-通知回调,那么系统就被称为处于死锁状态。间接死锁也会被检测到,所以如果连接B在连接C的事务结束时注册了一个解锁-通知回调,而连接C在连接A上等待,那么系统也被认为是死锁的,允许任何数量的间接级别。</target>
        </trans-unit>
        <trans-unit id="3e35797a56e3488dd19632be8d37b7c920ead5fc" translate="yes" xml:space="preserve">
          <source>To be clear: &quot;</source>
          <target state="translated">要说明的是:&quot;</target>
        </trans-unit>
        <trans-unit id="80e35d386745dd980983bb89049deefc03dfe51b" translate="yes" xml:space="preserve">
          <source>To build a DLL of SQLite for use in Windows, first acquire the appropriate amalgamated source code files, sqlite3.c and sqlite3.h. These can either be downloaded from the &lt;a href=&quot;http://www.sqlite.org/download.html&quot;&gt;SQLite website&lt;/a&gt; or custom generated from sources as shown above.</source>
          <target state="translated">要构建用于Windows的SQLite DLL，请首先获取适当的混合源代码文件sqlite3.c和sqlite3.h。可以从&lt;a href=&quot;http://www.sqlite.org/download.html&quot;&gt;SQLite网站&lt;/a&gt;下载这些文件，也可以从上面显示的源中定制生成这些文件。</target>
        </trans-unit>
        <trans-unit id="8c2bc1841bf864b266faa9153cf419507175bd74" translate="yes" xml:space="preserve">
          <source>To build a copy of the dbhash utility program on unix, get a copy of the canonical SQLite source code and enter:</source>
          <target state="translated">要在unix上建立一个dbhash实用程序的副本,得到一份规范的SQLite源代码并输入。</target>
        </trans-unit>
        <trans-unit id="8dbbee62ca23cc1e3fdd3d3f98bea994ab8a5656" translate="yes" xml:space="preserve">
          <source>To build a custom amalgamation, first download the original individual source files onto a unix or unix-like development platform. Be sure to get the original source files not the &quot;preprocessed source files&quot;. One can obtain the complete set of original source files either from the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; or directly from the &lt;a href=&quot;http://www.sqlite.org/src&quot;&gt;configuration management system&lt;/a&gt;.</source>
          <target state="translated">要构建自定义合并，请首先将原始的单个源文件下载到unix或类似unix的开发平台上。确保获取原始源文件，而不是&amp;ldquo;预处理的源文件&amp;rdquo;。可以从&lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;下载页面&lt;/a&gt;或直接从&lt;a href=&quot;http://www.sqlite.org/src&quot;&gt;配置管理系统&lt;/a&gt;获取完整的原始源文件集。</target>
        </trans-unit>
        <trans-unit id="bbb58546549ded0701f18afdab64c04ca26ea6a1" translate="yes" xml:space="preserve">
          <source>To build the CLI, simply put these three files in the same directory and compile them together. Using MSVC:</source>
          <target state="translated">要构建CLI,只需将这三个文件放在同一个目录下,然后一起编译。使用MSVC。</target>
        </trans-unit>
        <trans-unit id="5d2c0fe38d130be317edc2f5dfddee01ac43e855" translate="yes" xml:space="preserve">
          <source>To build the amalgamation (either the full amalgamation or the split amalgamation), first &lt;a href=&quot;getthecode&quot;&gt;get the canonical source code&lt;/a&gt; from one of the three servers. Then, on both unix-like systems and on Windows systems that have the free &lt;a href=&quot;http://mingw.org/wiki/msys&quot;&gt;MinGW&lt;/a&gt; development environment installed, the amalgamation can be built using the following commands:</source>
          <target state="translated">要构建合并（完全合并或拆分合并），请首先从三个服务器之一&lt;a href=&quot;getthecode&quot;&gt;获取规范源代码&lt;/a&gt;。然后，在类似unix的系统上以及在安装了免费&lt;a href=&quot;http://mingw.org/wiki/msys&quot;&gt;MinGW&lt;/a&gt;开发环境的Windows系统上，可以使用以下命令构建合并：</target>
        </trans-unit>
        <trans-unit id="d7b9af325052cb89e33dbc430967cc0b7deb7cf6" translate="yes" xml:space="preserve">
          <source>To build using Microsoft Visual C++, run this command:</source>
          <target state="translated">要使用Microsoft Visual C++构建,请运行此命令。</target>
        </trans-unit>
        <trans-unit id="39cded5adcef7aa92aca1ba527e5da5a120510e0" translate="yes" xml:space="preserve">
          <source>To cast a BLOB value to TEXT, the sequence of bytes that make up the BLOB is interpreted as text encoded using the database encoding.</source>
          <target state="translated">要将BLOB值转换为TEXT,组成BLOB的字节序列将被解释为使用数据库编码的文本。</target>
        </trans-unit>
        <trans-unit id="78f27fb02b3100de75bd999544415d6f6516d9a7" translate="yes" xml:space="preserve">
          <source>To cause SQLite to use a new memory allocator, the application simply calls:</source>
          <target state="translated">要使SQLite使用一个新的内存分配器,应用程序只需调用。</target>
        </trans-unit>
        <trans-unit id="06731044cb7999e326abfa5edb7ddc70e70000e7" translate="yes" xml:space="preserve">
          <source>To change your check-out to the private branch, type:</source>
          <target state="translated">要改变您的结帐方式,请输入。</target>
        </trans-unit>
        <trans-unit id="1981f2b6db16ebcce7bb76f8ad9bf3a92a4b7325" translate="yes" xml:space="preserve">
          <source>To change your checkout to a different version of Fossil use the &quot;update&quot; command:</source>
          <target state="translated">要改变你的结账到不同版本的Fossil,使用 &quot;更新 &quot;命令。</target>
        </trans-unit>
        <trans-unit id="e90e1970a4d12dd7ff50fb8afa438dceccf71dae" translate="yes" xml:space="preserve">
          <source>To circumvent this limitation, the amalgamation is also available in a split form, consisting of files &quot;sqlite3-1.c&quot;, &quot;sqlite3-2.c&quot;, and so forth, where each file is less than 32,768 lines in length and where the concatenation of the files contain all of the code for the complete amalgamation. Then there is a separate source file named &quot;sqlite3-all.c&quot; which basically consists of code like this:</source>
          <target state="translated">为了规避这个限制,还可以用拆分的形式,由 &quot;sqlite3-1.c&quot;、&quot;sqlite3-2.c &quot;等文件组成,每个文件的长度都小于32768行,这些文件的合并包含了完整的amalgamation的所有代码。然后还有一个单独的源文件,名为 &quot;sqlite3-all.c&quot;,基本由这样的代码组成。</target>
        </trans-unit>
        <trans-unit id="2e894e5b94a3ef2bd6606b0bac122e783cd91aa9" translate="yes" xml:space="preserve">
          <source>To clarify, if this function is called and then a changeset constructed using &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt;, then after applying that changeset to database zFrom the contents of the two compatible tables would be identical.</source>
          <target state="translated">为了明确&lt;a href=&quot;#sqlite3session_changeset&quot;&gt;起见&lt;/a&gt;，如果先调用此函数，然后使用sqlite3session_changeset（）构造一个变更集，则将该变更集应用于数据库z之后，两个兼容表的内容将相同。</target>
        </trans-unit>
        <trans-unit id="6d157b6ace52aa2f1341c1373e4a984c6c232891" translate="yes" xml:space="preserve">
          <source>To clarify, if this function is called and then a changeset constructed using &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt;, then after applying that changeset to database zFrom the contents of the two compatible tables would be identical.</source>
          <target state="translated">为了明确&lt;a href=&quot;sqlite3session_changeset&quot;&gt;起见&lt;/a&gt;，如果先调用此函数，然后使用sqlite3session_changeset（）构造一个变更集，则将该变更集应用于数据库z之后，两个兼容表的内容将相同。</target>
        </trans-unit>
        <trans-unit id="5f3d190805c91114a85c4ded726387a4e9c9b6ef" translate="yes" xml:space="preserve">
          <source>To clarify: an extension for which the initialization function returns SQLITE_OK_LOAD_PERMANENTLY continues to exist in memory after the database connection closes. However, the extension is &lt;em&gt;not&lt;/em&gt; automatically registered with subsequent database connections. This makes it possible to load extensions that implement new &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;. To persistently load and register an extension that implements new SQL functions, collating sequences, and/or virtual tables, such that those added capabilities are available to all subsequent database connections, then the initialization routine should also invoke &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; on a subfunction that will register those services.</source>
          <target state="translated">需要说明的是：在数据库连接关闭之后，初始化函数返回SQLITE_OK_LOAD_PERMANENTLY的扩展名继续存在于内存中。但是，该扩展名&lt;em&gt;不会&lt;/em&gt;自动注册到后续数据库连接中。这样就可以加载实现新&lt;a href=&quot;vfs&quot;&gt;VFS的&lt;/a&gt;扩展。为了持久地加载和注册一个实现新SQL函数，整理序列和/或虚拟表的扩展，以使这些附加功能可用于所有后续数据库连接，则初始化例程还应在子函数上调用&lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;注册这些服务。</target>
        </trans-unit>
        <trans-unit id="bccbaf3af7fd4e2f28bb629648fc3e526aaa7ab9" translate="yes" xml:space="preserve">
          <source>To clone the entire history of SQLite, first go to the &lt;a href=&quot;http://www.fossil-scm.org/download.html&quot;&gt;http://www.fossil-scm.org/download.html&lt;/a&gt; page and grab a precompiled binary for the Fossil version control program. Or get the source code on the same page and compile it yourself.</source>
          <target state="translated">要克隆SQLite的整个历史记录，请首先转到&lt;a href=&quot;http://www.fossil-scm.org/download.html&quot;&gt;http://www.fossil-scm.org/download.html&lt;/a&gt;页面，并获取Fossil版本控制程序的预编译二进制文件。或在同一页面上获取源代码并自己编译。</target>
        </trans-unit>
        <trans-unit id="1a2fe4833a1026479d31af2dc4ee8fce8b3b5030" translate="yes" xml:space="preserve">
          <source>To close an SQLite database, call the &lt;b&gt;sqlite_close&lt;/b&gt; function passing it the sqlite structure pointer that was obtained from a prior call to &lt;b&gt;sqlite_open&lt;/b&gt;. If a transaction is active when the database is closed, the transaction is rolled back.</source>
          <target state="translated">要关闭SQLite数据库，请调用&lt;b&gt;sqlite_close&lt;/b&gt;函数，&lt;b&gt;向其&lt;/b&gt;传递从先前调用&lt;b&gt;sqlite_open&lt;/b&gt;获得的sqlite结构指针。如果在关闭数据库时事务处于活动状态，则将回滚该事务。</target>
        </trans-unit>
        <trans-unit id="2864c3c7a649d4d26acb60269d4c618571d81546" translate="yes" xml:space="preserve">
          <source>To compile for Windows using MinGW, the command line is just like it is for unix except that the output file suffix is changed to &quot;.dll&quot; and the -fPIC argument is omitted:</source>
          <target state="translated">要使用MinGW在Windows下编译,命令行和unix下一样,只是输出文件后缀改为&quot;.dll&quot;,并且省略了-fPIC参数。</target>
        </trans-unit>
        <trans-unit id="f73c38ca2dac9f31efaddc70782e387db0501bf7" translate="yes" xml:space="preserve">
          <source>To compile on Windows using MSVC, a command similar to the following will usually work:</source>
          <target state="translated">要在Windows上使用MSVC进行编译,通常使用类似于下面的命令即可。</target>
        </trans-unit>
        <trans-unit id="5f996fbc61d75fe9538101264c9b8819e60f8184" translate="yes" xml:space="preserve">
          <source>To compile the command-line shell on unix systems and on Windows with MinGW, the usual configure-make command works:</source>
          <target state="translated">要在unix系统和Windows系统上用MinGW编译命令行shell,一般的configure-make命令就可以了。</target>
        </trans-unit>
        <trans-unit id="51cc1e77b8f71008cf9ef9201c87c8f93c492b49" translate="yes" xml:space="preserve">
          <source>To compute aggregate functions, the VDBE implements a special data structure and instructions for controlling that data structure. The data structure is an unordered set of buckets, where each bucket has a key and one or more memory locations. Within the query loop, the GROUP BY clause is used to construct a key and the bucket with that key is brought into focus. A new bucket is created with the key if one did not previously exist. Once the bucket is in focus, the memory locations of the bucket are used to accumulate the values of the various aggregate functions. After the query loop terminates, each bucket is visited once to generate a single row of the results.</source>
          <target state="translated">为了计算集合函数,VDBE实现了一个特殊的数据结构和控制该数据结构的指令。数据结构是一组无序的桶,其中每个桶有一个键和一个或多个内存位置。在查询循环中,GROUP BY子句被用来构造一个键,并使带有该键的bucket成为焦点。如果之前不存在一个新的桶,那么就会用这个键创建一个新的桶。一旦bucket被聚焦,bucket的内存位置就被用来累积各种聚合函数的值。在查询循环终止后,每个桶被访问一次,以生成结果的单行。</target>
        </trans-unit>
        <trans-unit id="94ded02646e1eb96801f525361b3b596cadfec9e" translate="yes" xml:space="preserve">
          <source>To control memory usage in the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt;, compile with &quot;&lt;a href=&quot;compile#printf_precision_limit&quot;&gt;-DSQLITE_PRINTF_PRECISION_LIMIT=1000&lt;/a&gt;&quot; or some similar small value. This #define limits the width and precision for %-substitutions in the printf() function, and thus prevents a hostile SQL statement from consuming large amounts of RAM via constructs such as &quot;&lt;code&gt;printf('%1000000000s','hi')&lt;/code&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de49f53ff4a4b3038be9f08fcf4db86631b03856" translate="yes" xml:space="preserve">
          <source>To convert an SQLite 2.8 database into an SQLite 3.0 database, have ready the command-line shells for both version 2.8 and 3.0. Then enter a command like the following:</source>
          <target state="translated">要将SQLite 2.8数据库转换为SQLite 3.0数据库,需要准备好2.8和3.0版本的命令行shell。然后输入类似下面的命令。</target>
        </trans-unit>
        <trans-unit id="d15f29e334ec535855fdc1d71f46105bc0e5b848" translate="yes" xml:space="preserve">
          <source>To convert the results of an SQL expression to a boolean value, SQLite first casts the result to a NUMERIC value in the same way as a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt;. A numeric zero value (integer value 0 or real value 0.0) is considered to be false. A NULL value is still NULL. All other values are considered true.</source>
          <target state="translated">要将SQL表达式的结果转换为布尔值，SQLite首先以与&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST表达式&lt;/a&gt;相同的方式将结果转换为NUMERIC值。数字零值（整数值0或实数值0.0）被认为是错误的。NULL值仍为NULL。所有其他值都被认为是正确的。</target>
        </trans-unit>
        <trans-unit id="86fc6f32b0c0d0aa47c4d6f69f34d90eb1dafec6" translate="yes" xml:space="preserve">
          <source>To create a WITHOUT ROWID table, simply add the keywords &quot;WITHOUT ROWID&quot; to the end of the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. For example:</source>
          <target state="translated">要创建WITHOUT ROWID表，只需在&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句的末尾添加关键字&amp;ldquo; WITHOUT ROWID&amp;rdquo; 。例如：</target>
        </trans-unit>
        <trans-unit id="44c6e38819829481385517b096a1954e645cc686" translate="yes" xml:space="preserve">
          <source>To create a custom tokenizer, an application must implement three functions: a tokenizer constructor (xCreate), a destructor (xDelete) and a function to do the actual tokenization (xTokenize). The type of each function is as for the member variables of the fts5_tokenizer struct:</source>
          <target state="translated">要创建一个自定义的标记化器,应用程序必须实现三个函数:一个标记化器构造函数 (xCreate),一个解构函数 (xDelete),以及一个用于实际标记化的函数 (xTokenize)。每个函数的类型与fts5_tokenizer结构的成员变量相同。</target>
        </trans-unit>
        <trans-unit id="e13c6f787f4a4c87c62a52e8c2eaf1189f9ab3f7" translate="yes" xml:space="preserve">
          <source>To create a new SQLite Archive named &quot;alltxt.sqlar&quot; containing all *.txt files in the current directory:</source>
          <target state="translated">创建一个名为 &quot;alltxt.sqllar &quot;的新SQLite存档,其中包含当前目录下的所有*.txt文件。</target>
        </trans-unit>
        <trans-unit id="66b80310b3a0d85a550dc7fa520d19dce45cca28" translate="yes" xml:space="preserve">
          <source>To create a new VFS, an application fills in an instance of this structure with appropriate values and then calls &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;.</source>
          <target state="translated">要创建新的VFS，应用程序会使用适当的值填充此结构的实例，然后调用&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b68e0297b120fdc8700b37a16e22b1bcac7b7255" translate="yes" xml:space="preserve">
          <source>To create a permanent imposter table &quot;t2&quot; against index &quot;t1bc&quot; one should first enable editing of the sqlite_master table by running &quot;&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt;&quot;. (Be careful to observe the warnings that accompany this PRAGMA. A mistake can cause severe database corruption.) Then insert a new entry into the sqlite_master table like this:</source>
          <target state="translated">要针对索引&amp;ldquo; t1bc&amp;rdquo;创建永久冒名顶替者表&amp;ldquo; t2&amp;rdquo;，应首先通过运行&amp;ldquo; &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = ON&lt;/a&gt; &amp;rdquo;来启用sqlite_master表的编辑。 （请小心遵守此PRAGMA的警告。错误可能会导致数据库严重损坏。）然后将新条目插入sqlite_master表，如下所示：</target>
        </trans-unit>
        <trans-unit id="36c615429908288394555c6e0565e1074cd2dbb0" translate="yes" xml:space="preserve">
          <source>To create a permanent imposter table &quot;t2&quot; against index &quot;t1bc&quot; one should first enable editing of the sqlite_schema table by running &quot;&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt;&quot;. (Be careful to observe the warnings that accompany this PRAGMA. A mistake can cause severe database corruption.) Then insert a new entry into the sqlite_schema table like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75af239d46a1ccaf4ed3b8c83752a1c8cd61ef3d" translate="yes" xml:space="preserve">
          <source>To create a transient imposter table, first call sqlite3_test_control() as follows:</source>
          <target state="translated">要创建一个瞬时冒名表,首先调用sqlite3_test_control(),如下所示。</target>
        </trans-unit>
        <trans-unit id="840cded7bd85361bb0373236ba14ab05cb33ba76" translate="yes" xml:space="preserve">
          <source>To disable memory-mapped I/O, simply set the mmap_size to zero:</source>
          <target state="translated">要禁用内存映射的I/O,只需将mmap_size设置为0即可。</target>
        </trans-unit>
        <trans-unit id="4162611fd5eb01354b37fefdcc47165c36368726" translate="yes" xml:space="preserve">
          <source>To download a specific historical version, first locate the specific version desired by visiting the timeline page on one of these servers (for example: &lt;a href=&quot;http://www.sqlite.org/cgi/src/timeline&quot;&gt;http://www.sqlite.org/cgi/src/timeline&lt;/a&gt;). If you know the approximate date of the version you want to download, you can add a query parameter like &quot;c=YYYY-MM-DD&quot; to the &quot;timeline&quot; URL to see a timeline centered on that date. For example, to see all the check-ins that occurred around August 26, 2013, visit &lt;a href=&quot;http://www.sqlite.org/cgi/src/timeline?c=2013-08-26&quot;&gt;http://www.sqlite.org/cgi/src/timeline?c=2013-08-26&lt;/a&gt;. If you are looking for an official release, visit the &lt;a href=&quot;https://sqlite.org/chronology.html&quot;&gt;chronology&lt;/a&gt; page, click on the date to the left of the release you are looking for, and that will take you immediately to the check-in corresponding to the release.</source>
          <target state="translated">要下载特定的历史版本，请首先通过访问这些服务器之一上的时间轴页面找到所需的特定版本（例如：&lt;a href=&quot;http://www.sqlite.org/cgi/src/timeline&quot;&gt;http&lt;/a&gt; : //www.sqlite.org/cgi/src/timeline）。如果知道要下载的版本的大概日期，则可以在&amp;ldquo;时间轴&amp;rdquo; URL中添加查询参数，例如&amp;ldquo; c = YYYY-MM-DD&amp;rdquo;，以查看以该日期为中心的时间轴。例如，要查看2013年8月26日前后发生的所有签入，请访问&lt;a href=&quot;http://www.sqlite.org/cgi/src/timeline?c=2013-08-26&quot;&gt;http://www.sqlite.org/cgi/src/timeline?c=2013-08-26&lt;/a&gt;。如果您要查找正式发行版，请访问&lt;a href=&quot;https://sqlite.org/chronology.html&quot;&gt;年表&lt;/a&gt;页面，单击要查找的发行版左侧的日期，这将立即带您进入该发行版所对应的签入位置。</target>
        </trans-unit>
        <trans-unit id="26b6f299c4f6dbffd907751cbcf7de075d977917" translate="yes" xml:space="preserve">
          <source>To end a</source>
          <target state="translated">要结束一个</target>
        </trans-unit>
        <trans-unit id="b5999f6915f561051a988538e0bd45a5b252eaed" translate="yes" xml:space="preserve">
          <source>To enhance the ability to correct the spelling of &quot;salm&quot; into &quot;psalm&quot;, make an addition entry like this:</source>
          <target state="translated">为了提高将 &quot;salm &quot;拼写成 &quot;psalm &quot;的改正能力,可以做一个这样的附加条目。</target>
        </trans-unit>
        <trans-unit id="cad4b923bd651194c8769c3ac961aaea0541a296" translate="yes" xml:space="preserve">
          <source>To ensure that</source>
          <target state="translated">为确保</target>
        </trans-unit>
        <trans-unit id="1e6f0b75d33070e67761c1e9b6a6ed87d2ff380d" translate="yes" xml:space="preserve">
          <source>To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines. Or, in other words, these routines are constructors for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; object.</source>
          <target state="translated">要执行SQL语句，必须首先使用以下例程之一将其编译为字节码程序。换句话说，这些例程是&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;对象的构造函数。</target>
        </trans-unit>
        <trans-unit id="ec8443402dd2eb014887f71b7af85c4019b4e801" translate="yes" xml:space="preserve">
          <source>To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines. Or, in other words, these routines are constructors for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; object.</source>
          <target state="translated">要执行SQL语句，必须首先使用以下例程之一将其编译为字节码程序。换句话说，这些例程是&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;对象的构造函数。</target>
        </trans-unit>
        <trans-unit id="58b794006b35834c11476296b13d055bca3cb6ad" translate="yes" xml:space="preserve">
          <source>To export an SQLite table (or part of a table) as CSV, simply set the &quot;mode&quot; to &quot;csv&quot; and then run a query to extract the desired rows of the table.</source>
          <target state="translated">要将SQLite表(或表的一部分)导出为CSV,只需将 &quot;模式 &quot;设置为 &quot;csv&quot;,然后运行查询以提取表的所需行。</target>
        </trans-unit>
        <trans-unit id="34bdecaf4db0d4f0bc535a4d51fd07e2c07ade79" translate="yes" xml:space="preserve">
          <source>To extract all files from an SQLite Archive named &quot;example.sqlar&quot;:</source>
          <target state="translated">从名为 &quot;example.sqllar &quot;的SQLite存档中提取所有文件。</target>
        </trans-unit>
        <trans-unit id="378da684f0e8132365653868ae764440748a4226" translate="yes" xml:space="preserve">
          <source>To find the average fan-out for a table, run:</source>
          <target state="translated">要找出一张桌子的平均扇出量,运行。</target>
        </trans-unit>
        <trans-unit id="ee153014b1f6b01134aa6e70c369b696d194ac09" translate="yes" xml:space="preserve">
          <source>To find the total number of pages used to store table &quot;xyz&quot; in schema &quot;aux1&quot;, use either of the following two queries (the first is the traditional way, and the second shows the use of the aggregated feature):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77ab957506d48f71aa3fc70f6eedd2aaaf50bd48" translate="yes" xml:space="preserve">
          <source>To find the total number of pages used to store table &quot;xyz&quot; in schema &quot;aux1&quot;, use:</source>
          <target state="translated">要找出在模式 &quot;aux1 &quot;中存储表 &quot;xyz &quot;所使用的总页数,请使用。</target>
        </trans-unit>
        <trans-unit id="0a11c9e40b95aaa85081ba6c0555c462813b8b92" translate="yes" xml:space="preserve">
          <source>To force any register to be an integer, just add 0.</source>
          <target state="translated">要强制任何寄存器为整数,只需加0即可。</target>
        </trans-unit>
        <trans-unit id="7bb085f6483822eb83ea0075d305dc39115c6ffe" translate="yes" xml:space="preserve">
          <source>To generate a TCL-loadable library for SQLite on Linux, the following command will suffice:</source>
          <target state="translated">要在Linux上为SQLite生成一个可加载的TCL库,使用以下命令即可。</target>
        </trans-unit>
        <trans-unit id="dc0ee9d48bb10de38aec057fb2ba37285a13b707" translate="yes" xml:space="preserve">
          <source>To generate a standalone tclsh that is statically linked with SQLite, use this compiler invocation:</source>
          <target state="translated">要生成一个与SQLite静态链接的独立tclsh,请使用这个编译器调用。</target>
        </trans-unit>
        <trans-unit id="8ffcbf0f0118885934819d8152d29f23d6bdeaf0" translate="yes" xml:space="preserve">
          <source>To get the latest release, use &quot;release&quot; for</source>
          <target state="translated">要获得最新的版本,请使用 &quot;release &quot;来获取。</target>
        </trans-unit>
        <trans-unit id="865105a4d24714f5572a2af260a890cf20c3e9e8" translate="yes" xml:space="preserve">
          <source>To get the latest trunk check-in, us &quot;trunk&quot; for</source>
          <target state="translated">要想获得最新的后备箱签到,请用 &quot;后备箱 &quot;查询。</target>
        </trans-unit>
        <trans-unit id="baaadfb75f7d2bdda9240215ff1dc1b92db5726d" translate="yes" xml:space="preserve">
          <source>To get the maximum performance out of a query with multiple AND-connected terms in the WHERE clause, you really want a multi-column index with columns for each of the AND terms. In this case we create a new index on the &quot;fruit&quot; and &quot;state&quot; columns of FruitsForSale:</source>
          <target state="translated">为了从一个在WHERE子句中包含多个AND连接的术语的查询中获得最大的性能,你真的需要一个多列索引,其中包含每个AND术语的列。在本例中,我们在FruitsForSale的 &quot;水果 &quot;和 &quot;状态 &quot;列上创建一个新索引。</target>
        </trans-unit>
        <trans-unit id="6c98051e0b4ba35892475ed9f9c40c06634ca73f" translate="yes" xml:space="preserve">
          <source>To help ensure that SQLite does not make use of undefined or implementation defined behavior, the test suites are rerun using instrumented builds that try to detect undefined behavior. For example, test suites are run using the &quot;-ftrapv&quot; option of GCC. And they are run again using the &quot;-fsanitize=undefined&quot; option on Clang. And again using the &quot;/RTC1&quot; option in MSVC. Then the test suites are rerun using options like &quot;-funsigned-char&quot; and &quot;-fsigned-char&quot; to make sure that implementation differences do not matter either. Tests are then repeated on 32-bit and 64-bit systems and on big-endian and little-endian systems, using a variety of CPU architectures. Furthermore, the test suites are augmented with many test cases that are deliberately designed to provoke undefined behavior. For example: &quot;&lt;b&gt;SELECT -1*(-9223372036854775808);&lt;/b&gt;&quot;.</source>
          <target state="translated">为了帮助确保SQLite不使用未定义或实现定义的行为，将使用试图检测未定义行为的检测内部版本来重新运行测试套件。例如，使用GCC的&amp;ldquo; -ftrapv&amp;rdquo;选项运行测试套件。然后使用Clang上的&amp;ldquo; -fsanitize = undefined&amp;rdquo;选项再次运行它们。再次使用MSVC中的&amp;ldquo; / RTC1&amp;rdquo;选项。然后使用&amp;ldquo; -funsigned-char&amp;rdquo;和&amp;ldquo; -fsigned-char&amp;rdquo;之类的选项重新运行测试套件，以确保实现差异也不重要。然后，使用各种CPU架构，在32位和64位系统以及大端和小端系统上重复测试。此外，在测试套件中增加了许多故意设计为引发未定义行为的测试用例。例如：&amp;ldquo; &lt;b&gt;SELECT -1 *（-9223372036854775808）;&lt;/b&gt;&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a47c1a7cf7a764ae8418d262a8cbe0034fa682ba" translate="yes" xml:space="preserve">
          <source>To help the optimizer get a more accurate estimate of the work involved in using various indices, the user may optionally run the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command scans all indices of database where there might be a choice between two or more indices and gathers statistics on the selectiveness of those indices. The statistics gathered by this scan are stored in special database tables names shows names all begin with &quot;&lt;b&gt;sqlite_stat&lt;/b&gt;&quot;. The content of these tables is not updated as the database changes so after making significant changes it might be prudent to rerun &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;. The results of an ANALYZE command are only available to database connections that are opened after the ANALYZE command completes.</source>
          <target state="translated">为了帮助优化器更准确地估计使用各种索引所涉及的工作，用户可以选择运行&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令。该&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令扫描数据库的所有索引中可能有这些指标的选择性强两个或更多的指标和收集统计信息之间进行选择。此扫描收集的统计信息存储在特殊的数据库表中，名称显示的名称均以&amp;ldquo; &lt;b&gt;sqlite_stat&lt;/b&gt; &amp;rdquo; 开头。这些表的内容不会随着数据库的更改而更新，因此在进行重大更改后，重新运行&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;可能是明智的。ANALYZE命令的结果仅可用于在ANALYZE命令完成后打开的数据库连接。</target>
        </trans-unit>
        <trans-unit id="13cfb0765d8bed99c080b9b691906f95cc028d17" translate="yes" xml:space="preserve">
          <source>To illustrate the difference between statement coverage and branch coverage, consider the following hypothetical line of C code:</source>
          <target state="translated">为了说明语句覆盖和分支覆盖之间的区别,请考虑以下假设的C代码行。</target>
        </trans-unit>
        <trans-unit id="ae50591a7fcbd23ea798d861abeb0270f701ae3a" translate="yes" xml:space="preserve">
          <source>To implement atomic transactions in the face of potential application, operating system or power failures, database writers write a copy of those portions of the database file that they are going to modify into a second file, the</source>
          <target state="translated">为了在潜在的应用程序、操作系统或电源故障的情况下实现原子事务,数据库写作者将数据库文件中要修改的那些部分写进第二个文件,即</target>
        </trans-unit>
        <trans-unit id="b22523df059612f91ea53aafd162b4bd5ed35d56" translate="yes" xml:space="preserve">
          <source>To include a single &quot;%&quot; character in the output, put two consecutive &quot;%&quot; characters in the template.</source>
          <target state="translated">要在输出中包含一个&quot;%&quot;字符,请在模板中放入两个连续的&quot;%&quot;字符。</target>
        </trans-unit>
        <trans-unit id="04f1ff1539e760f03360e336c883d5d39fb452d1" translate="yes" xml:space="preserve">
          <source>To insert a directory into the archive, this field must be set to NULL. In this case if a value was explicitly specified for the &quot;mode&quot; column, then it must be consistent with a directory (i.e. it must be true that (mode &amp;amp; 0040000)=0040000).</source>
          <target state="translated">要将目录插入存档，必须将该字段设置为NULL。在这种情况下，如果为&amp;ldquo;模式&amp;rdquo;列显式指定了一个值，则该值必须与目录一致（即，必须为（mode＆0040000）= 0040000）。</target>
        </trans-unit>
        <trans-unit id="f39783c1ee7868744c61463c5d909272c5cc8fe4" translate="yes" xml:space="preserve">
          <source>To insert a symbolic link, the user must also supply a &quot;mode&quot; value. For example, to add a symbolic link from &quot;link.txt&quot; to &quot;m.txt&quot;:</source>
          <target state="translated">要插入一个符号链接,用户还必须提供一个 &quot;模式 &quot;值。例如,要添加一个从 &quot;link.txt &quot;到 &quot;m.txt &quot;的符号链接。</target>
        </trans-unit>
        <trans-unit id="95775537d7e96d79f73ff5683b7a0f5a80a5ce74" translate="yes" xml:space="preserve">
          <source>To invoke a method of the fts5_api object, the fts5_api pointer itself should be passed as the methods first argument followed by the other, method specific, arguments. For example:</source>
          <target state="translated">要调用fts5_api对象的方法,应该把fts5_api指针本身作为方法的第一个参数,然后再传给其他特定方法的参数。例如,在调用fts5_api对象的方法时</target>
        </trans-unit>
        <trans-unit id="6e6a0331292326c4328c6ad0538b3a057984238d" translate="yes" xml:space="preserve">
          <source>To invoke an auxiliary function, the name of the FTS5 table should be specified as the first argument. Other arguments may follow the first, depending on the specific auxiliary function being invoked. For example, to invoke the &quot;highlight&quot; function:</source>
          <target state="translated">要调用一个辅助函数,应指定FTS5表的名称作为第一个参数。其他参数可以跟在第一个参数后面,这取决于被调用的具体辅助函数。例如,要调用 &quot;高亮 &quot;函数。</target>
        </trans-unit>
        <trans-unit id="87798f32eb98a197933acbeaa659a6391e6e206b" translate="yes" xml:space="preserve">
          <source>To list all of the files in an SQLite Archive named &quot;example.sqlar&quot; using one of these commands:</source>
          <target state="translated">使用以下命令之一列出名为 &quot;example.sqlar &quot;的SQLite存档中的所有文件。</target>
        </trans-unit>
        <trans-unit id="98a407629fac05e188e2276249cb3e6705d8eabc" translate="yes" xml:space="preserve">
          <source>To make the original query more efficient, we can add an index on the &quot;fruit&quot; column of the &quot;fruitsforsale&quot; table like this:</source>
          <target state="translated">为了使原来的查询更有效率,我们可以在 &quot;fruitsforsale &quot;表的 &quot;水果 &quot;列上添加一个索引,像这样。</target>
        </trans-unit>
        <trans-unit id="477566566ad78ed80a1c50e083a36f65bd003836" translate="yes" xml:space="preserve">
          <source>To mark a foreign key constraint as deferred, its declaration must include the following clause:</source>
          <target state="translated">要将一个外键约束标记为递延,它的声明必须包括以下子句。</target>
        </trans-unit>
        <trans-unit id="ffa62717516e178da2c90e6012b64fda52ee2d3e" translate="yes" xml:space="preserve">
          <source>To minimize storage space, the 64-bit rowid is stored as a variable length integer. Rowids between 0 and 127 use only a single byte. Rowids between 0 and 16383 use just 2 bytes. Up to 2097152 uses three bytes. And so forth. Negative rowids are allowed but they always use nine bytes of storage and so their use is discouraged. When rowids are generated automatically by SQLite, they will always be non-negative.</source>
          <target state="translated">为了最小化存储空间,64位的rowid被存储为一个可变长度的整数。0到127之间的行数只使用一个字节。0到16383之间的rowid只使用2个字节。高达2097152的行数使用三个字节。以此类推。负值的rowids是允许的,但是它们总是使用9个字节的存储空间,所以不鼓励使用它们。当SQLite自动生成rowids时,它们总是非负数。</target>
        </trans-unit>
        <trans-unit id="d120ff6bfe9d147f02eaa10dff44acc87f07df1f" translate="yes" xml:space="preserve">
          <source>To overcome this problem, SQLite attempts to flatten subqueries in the FROM clause of a SELECT. This involves inserting the FROM clause of the subquery into the FROM clause of the outer query and rewriting expressions in the outer query that refer to the result set of the subquery. For example:</source>
          <target state="translated">为了克服这个问题,SQLite 试图在 SELECT 的 FROM 子句中扁平化子查询。这包括将子查询的FROM子句插入到外层查询的FROM子句中,并重写外层查询中引用子查询结果集的表达式。例如</target>
        </trans-unit>
        <trans-unit id="294f2168272133a9c981fc5402e94f65b32feecd" translate="yes" xml:space="preserve">
          <source>To perform a backup operation:</source>
          <target state="translated">要执行备份操作。</target>
        </trans-unit>
        <trans-unit id="9189855e1dd7fa25c3ea4d362ef1bbf56fd3d46b" translate="yes" xml:space="preserve">
          <source>To port the asynchronous IO extension to another platform, the user must implement mutex and condition variable primitives for the new platform. Currently there is no externally available interface to allow this, but modifying the code within sqlite3async.c to include the new platforms concurrency primitives is relatively easy. Search within sqlite3async.c for the comment string &quot;PORTING FUNCTIONS&quot; for details. Then implement new versions of each of the following:</source>
          <target state="translated">要将异步IO扩展移植到另一个平台,用户必须为新平台实现mutex和条件变量基元。目前没有外部可用的接口来允许这样做,但是修改sqlite3async.c中的代码以包含新平台的并发基元是相对容易的。在sqlite3async.c中搜索注释字符串 &quot;PORTING FUNCTIONS &quot;以了解详情。然后实现以下每个函数的新版本。</target>
        </trans-unit>
        <trans-unit id="abe3a1c0f986e7dff3c66e10e0bc8613ec8a4a29" translate="yes" xml:space="preserve">
          <source>To program the costs of editdist3, create a table such as the following:</source>
          <target state="translated">要对editdist3的成本进行编程,请创建如下表格。</target>
        </trans-unit>
        <trans-unit id="dd961efb741387ced404586d2d77531be32d0018" translate="yes" xml:space="preserve">
          <source>To put it another way, SQLITE_THREADSAFE=1 sets the default &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Serialized. SQLITE_THREADSAFE=2 sets the default &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Multi-threaded. And SQLITE_THREADSAFE=0 sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Single-threaded.</source>
          <target state="translated">换句话说，SQLITE_THREADSAFE = 1将默认&lt;a href=&quot;threadsafe&quot;&gt;线程模式设置&lt;/a&gt;为序列化。SQLITE_THREADSAFE = 2将默认&lt;a href=&quot;threadsafe&quot;&gt;线程模式设置&lt;/a&gt;为多线程。并且SQLITE_THREADSAFE = 0会将&lt;a href=&quot;threadsafe&quot;&gt;线程模式&lt;/a&gt;设置为单线程。</target>
        </trans-unit>
        <trans-unit id="8bbf633fa4610c96c0c7ffee341d20c19f6a10c0" translate="yes" xml:space="preserve">
          <source>To put it another way, a recursive common table expression must look like the following:</source>
          <target state="translated">换一种说法,一个递归的通用表表达式必须像下面这样。</target>
        </trans-unit>
        <trans-unit id="36ef640929ff79fff30565de2cdb61e3e8331dcd" translate="yes" xml:space="preserve">
          <source>To query the geopoly table using an indexed geospatial search, use one of the functions geopoly_overlap() or geopoly_within() as a boolean function in the WHERE clause, with the &quot;_shape&quot; column as the first argument to the function. For example:</source>
          <target state="translated">要使用索引地理空间搜索查询地缘表,请在WHERE子句中使用函数geopoly_overlap()或geopoly_within()中的一个布尔函数,并将&quot;_shape &quot;列作为函数的第一个参数。例如</target>
        </trans-unit>
        <trans-unit id="4c7559a504a1b848e2c2a1bb94bcc0d6574af605" translate="yes" xml:space="preserve">
          <source>To query the virtual table, include a MATCH operator in the WHERE clause. For example:</source>
          <target state="translated">要查询虚拟表,请在WHERE子句中加入MATCH操作符。例如:</target>
        </trans-unit>
        <trans-unit id="956aac33f5ccab9c31f6bd406dfe90336575d36e" translate="yes" xml:space="preserve">
          <source>To raise an error, the xColumn method should use one of the result_text() methods to set the error message text, then return an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;. The xColumn method must return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success.</source>
          <target state="translated">要引发错误，xColumn方法应使用result_text（）方法之一来设置错误消息文本，然后返回适当的&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。如果成功，xColumn方法必须返回&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a347542d414080ba36506855372190f72248d59a" translate="yes" xml:space="preserve">
          <source>To read a page from the database (call it page number P), a reader first checks the WAL to see if it contains page P. If so, then the last valid instance of page P that is followed by a commit frame or is a commit frame itself becomes the value read. If the WAL contains no copies of page P that are valid and which are a commit frame or are followed by a commit frame, then page P is read from the database file.</source>
          <target state="translated">要从数据库中读取一个页面(称其为页码P),读取器首先检查WAL是否包含P页,如果包含,那么P页的最后一个有效实例,如果后面有一个提交框或者本身就是一个提交框,则成为读取值。如果WAL中不包含有效的P页,并且是一个提交框或后面有一个提交框,那么就从数据库文件中读取P页。</target>
        </trans-unit>
        <trans-unit id="76f16284fd2bce9d8388d5ab5df8c7614583bafc" translate="yes" xml:space="preserve">
          <source>To read a page of database content using the legacy xRead() method, SQLite first allocates a page-size chunk of heap memory then invokes the xRead() method which causes the database page content to be copied into the newly allocated heap memory. This involves (at a minimum) a copy of the entire page.</source>
          <target state="translated">要使用传统的xRead()方法读取数据库内容页,SQLite首先分配一个页大小的堆内存块,然后调用xRead()方法,使数据库页内容被复制到新分配的堆内存中。这涉及(至少)整个页面的复制。</target>
        </trans-unit>
        <trans-unit id="0d23c4dcc478663c58481efcab9ef78dfade7580" translate="yes" xml:space="preserve">
          <source>To reiterate, the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter and the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; only influence the temporary files other than the rollback journal and the master journal. The rollback journal and the master journal are always written to disk regardless of the settings of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter and the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">重申一下，&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;编译时参数和&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store编译指示&lt;/a&gt;仅影响除回滚日志和主日志以外的临时文件。无论&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;编译时参数和&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;的设置如何，始终将回滚日志和主日志写入磁盘。</target>
        </trans-unit>
        <trans-unit id="2e5b2bd7c52b7e4f110f0ff73389c5c950328a31" translate="yes" xml:space="preserve">
          <source>To reiterate, the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter and the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; only influence the temporary files other than the rollback journal and the super-journal. The rollback journal and the super-journal are always written to disk regardless of the settings of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter and the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c25cb966293d60ae97a959ff16018be4ed0f257f" translate="yes" xml:space="preserve">
          <source>To rotate a polygon by R radians around the point 0, 0:</source>
          <target state="translated">要围绕点0,0旋转多边形R弧度。</target>
        </trans-unit>
        <trans-unit id="b22af78238ac154cfedfa8fdf1735dd0e28767bd" translate="yes" xml:space="preserve">
          <source>To run an SQL statement, the application follows these steps:</source>
          <target state="translated">要运行一条SQL语句,应用程序遵循以下步骤。</target>
        </trans-unit>
        <trans-unit id="2ac3ac4ee6565dd2ccf0aa06e215ad75c047aa3c" translate="yes" xml:space="preserve">
          <source>To satisfy this query, SQLite reads every row out of the table, checks to see if the &quot;fruit&quot; column has the value of &quot;Peach&quot; and if so, outputs the &quot;price&quot; column from that row. The process is illustrated by &lt;a href=&quot;#fig2&quot;&gt;figure 2&lt;/a&gt; below. This is algorithm is called a</source>
          <target state="translated">为了满足该查询，SQLite从表中读取每一行，检查&amp;ldquo;水果&amp;rdquo;列是否具有&amp;ldquo;桃子&amp;rdquo;值，如果是，则从该行输出&amp;ldquo;价格&amp;rdquo;列。下&lt;a href=&quot;#fig2&quot;&gt;图2&lt;/a&gt;说明了该过程。这就是所谓的算法</target>
        </trans-unit>
        <trans-unit id="15441596cf9057824d089a51008503a5c1e85b73" translate="yes" xml:space="preserve">
          <source>To see all optimizations that would have been done without actually doing them, run &quot;PRAGMA optimize(-1)&quot;. To use only the ANALYZE optimization, run &quot;PRAGMA optimize(0x02)&quot;.</source>
          <target state="translated">如果要查看所有本来不需要实际执行的优化,请运行 &quot;PRAGMA optimize(-1)&quot;。要只使用 ANALYZE 优化,请运行 &quot;PRAGMA optimize(0x02)&quot;。</target>
        </trans-unit>
        <trans-unit id="eba318aa21bd2422c25fe6b43564edd2f371cc6a" translate="yes" xml:space="preserve">
          <source>To see how efficiently the content of a table is stored on disk, compute the amount of space used to hold actual content divided by the total amount of disk space used. The closer this number is to 100%, the more efficient the packing. (In this example, the 'xyz' table is assumed to be in the 'main' schema. Again, there are two different versions that show the use of DBSTAT both without and with the new aggregated feature, respectively.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63736dfc77ed5a0f9b2aa82f7d9b5938ad21b2a2" translate="yes" xml:space="preserve">
          <source>To see how efficiently the content of a table is stored on disk, compute the amount of space used to hold actual content divided by the total amount of disk space used. The closer this number is to 100%, the more efficient the packing. (In this example, the 'xyz' table is assumed to be in the 'main' schema.)</source>
          <target state="translated">要了解一张表的内容在磁盘上的存储效率,请计算用于容纳实际内容的空间除以使用的磁盘空间总量。这个数字越接近100%,打包的效率就越高。在本例中,假设'xyz'表在'main'模式中。</target>
        </trans-unit>
        <trans-unit id="b389fbfc405d7654267e252e722e4fd63d443182" translate="yes" xml:space="preserve">
          <source>To see what SQL statements are used to implement an SQLite Archive operation, add the --dryrun or -n option. This causes the SQL to be displayed but inhibits the execution of the SQL.</source>
          <target state="translated">要查看哪些SQL语句用于实现SQLite Archive操作,请添加-dryrun或-n选项。这将导致显示SQL语句,但会抑制SQL的执行。</target>
        </trans-unit>
        <trans-unit id="4b42f62d4c2b9ee3d96292447437ef792183dfd3" translate="yes" xml:space="preserve">
          <source>To simplify export to a spreadsheet, the CLI provides the &quot;.excel&quot; command which captures the output of a single query and sends that output to the default spreadsheet program on the host computer. Use it like this:</source>
          <target state="translated">为了简化导出到电子表格的过程,CLI提供了&quot;.excel &quot;命令,它可以捕获单个查询的输出,并将该输出发送到主机上的默认电子表格程序。像这样使用它。</target>
        </trans-unit>
        <trans-unit id="7637fa0269c40df023fe74c58e653b7742bc4073" translate="yes" xml:space="preserve">
          <source>To simplify matters, SQLite is also available as a pre-packaged &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; source code file: &lt;b&gt;sqlite3.c&lt;/b&gt;. The amalgamation is a single file of ANSI-C code that implements the entire SQLite library. The amalgamation is much easier to deal with. Everything is contained within a single code file, so it is easy to drop into the source tree of a larger C or C++ program. All the code generation and transformation steps have already been carried out so there are no auxiliary C programs to configure and compile and no scripts to run. And, because the entire library is contained in a single translation unit, compilers are able to do more advanced optimizations resulting in a 5% to 10% performance improvement. For these reasons, the amalgamation source file (&quot;&lt;b&gt;sqlite3.c&lt;/b&gt;&quot;) is recommended for all applications.</source>
          <target state="translated">为了简化问题，SQLite还可以作为预打包的&lt;a href=&quot;amalgamation&quot;&gt;合并&lt;/a&gt;源代码文件：&lt;b&gt;sqlite3.c提供&lt;/b&gt;。合并是实现整个SQLite库的ANSI-C代码的单个文件。合并更容易处理。所有内容都包含在一个代码文件中，因此很容易放入较大的C或C ++程序的源代码树中。所有代码生成和转换步骤均已执行，因此无需配置和编译辅助C程序，也无需运行脚本。而且，由于整个库都包含在一个翻译单元中，因此编译器能够进行更高级的优化，从而将性能提高5％到10％。由于这些原因，合并源文件（&amp;ldquo; &lt;b&gt;sqlite3.c&lt;/b&gt;&amp;ldquo;）建议用于所有应用程序。</target>
        </trans-unit>
        <trans-unit id="d56a317c733fa84480a64f52f9271ff584d1e783" translate="yes" xml:space="preserve">
          <source>To start a read transaction, the reader records the number of value frames in the WAL as &quot;mxFrame&quot;. (&lt;a href=&quot;walformat#mxframe&quot;&gt;More detail&lt;/a&gt;) The reader uses this recorded mxFrame value for all subsequent read operations. New transactions can be appended to the WAL, but as long as the reader uses its original mxFrame value and ignores subsequently appended content, the reader will see a consistent snapshot of the database from a single point in time. This technique allows multiple concurrent readers to view different versions of the database content simultaneously.</source>
          <target state="translated">为了开始读取事务，读取器将WAL中的值帧数记录为&amp;ldquo; mxFrame&amp;rdquo;。（&lt;a href=&quot;walformat#mxframe&quot;&gt;更多详细信息&lt;/a&gt;）阅读器将此记录的mxFrame值用于所有后续读取操作。可以将新事务附加到WAL，但是只要读者使用其原始mxFrame值并且忽略随后附加的内容，则读者将从单个时间点看到数据库的一致快照。此技术允许多个并发阅读器同时查看数据库内容的不同版本。</target>
        </trans-unit>
        <trans-unit id="5dba6bd0d0a444202c62a827b56648b58c226e29" translate="yes" xml:space="preserve">
          <source>To statically link your extension, simply add the -DSQLITE_CORE compile-time option. The SQLITE_CORE macro causes the SQLITE_EXTENSION_INIT1 and SQLITE_EXTENSION_INIT2 macros to become no-ops. Then modify your application to invoke the entry point directly, passing in a NULL pointer as the third &quot;pApi&quot; parameter.</source>
          <target state="translated">要静态链接您的扩展,只需添加-DSQLITE_CORE编译时选项。SQLITE_CORE 宏会使 SQLITE_EXTENSION_INIT1 和 SQLITE_EXTENSION_INIT2 宏变成无操作。然后修改你的应用程序,直接调用入口点,传入一个NULL指针作为第三个 &quot;pApi &quot;参数。</target>
        </trans-unit>
        <trans-unit id="63ab9efaac3f7a15bafc977a5dae2473a8be793a" translate="yes" xml:space="preserve">
          <source>To support</source>
          <target state="translated">为了支持</target>
        </trans-unit>
        <trans-unit id="a791e72c80a35cf93de60b32f2721ee1c5ba3b6f" translate="yes" xml:space="preserve">
          <source>To support full-text queries, FTS maintains an inverted index that maps from each unique term or word that appears in the dataset to the locations in which it appears within the table contents. For the curious, a complete description of the &lt;a href=&quot;fts3#data_structures&quot;&gt;data structure&lt;/a&gt; used to store this index within the database file appears below. A feature of this data structure is that at any time the database may contain not one index b-tree, but several different b-trees that are incrementally merged as rows are inserted, updated and deleted. This technique improves performance when writing to an FTS table, but causes some overhead for full-text queries that use the index. Evaluating the special &lt;a href=&quot;fts3#*fts4optcmd&quot;&gt;&quot;optimize&quot; command&lt;/a&gt;, an SQL statement of the form &quot;INSERT INTO &amp;lt;fts-table&amp;gt;(&amp;lt;fts-table&amp;gt;) VALUES('optimize')&quot;, causes FTS to merge all existing index b-trees into a single large b-tree containing the entire index. This can be an expensive operation, but may speed up future queries.</source>
          <target state="translated">为了支持全文查询，FTS维护一个反向索引，该索引将从数据集中出现的每个唯一术语或单词映射到表内容中出现的位置。出于好奇，下面显示了用于在数据库文件中存储此索引的&lt;a href=&quot;fts3#data_structures&quot;&gt;数据结构&lt;/a&gt;的完整描述。该数据结构的一个特点是，数据库在任何时候都可能不包含一个索引b树，而是包含几个不同的b树，这些树在插入，更新和删除行时逐渐合并。写入FTS表时，该技术可提高性能，但会给使用索引的全文查询带来一些开销。评估特殊的&lt;a href=&quot;fts3#*fts4optcmd&quot;&gt;&amp;ldquo;优化&amp;rdquo;命令&lt;/a&gt;，即&amp;ldquo; INSERT INTO &amp;lt;fts-table&amp;gt;（&amp;lt;fts-table&amp;gt;）VALUES（'optimize'）&amp;rdquo;形式的SQL语句，导致FTS将所有现有的索引b树合并为包含整个索引树的单个大b树指数。这可能是一项昂贵的操作，但可能会加快将来的查询速度。</target>
        </trans-unit>
        <trans-unit id="ef681c818587ecc3e802ff227ea9402f9c2f1648" translate="yes" xml:space="preserve">
          <source>To try to answer this, we ran 49 test cases with various BLOB sizes and SQLite page sizes on a Linux workstation (Ubuntu circa 2011 with the Ext4 filesystem on a fast SATA disk). For each test case, a database was created that contains 100MB of BLOB content. The sizes of the BLOBs ranged from 10KB to 1MB. The number of BLOBs varied in order to keep the total BLOB content at about 100MB. (Hence, 100 BLOBs for the 1MB size and 10000 BLOBs for the 10K size and so forth.) SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_8.html&quot;&gt;version 3.7.8&lt;/a&gt; (2011-09-19) was used.</source>
          <target state="translated">为了尝试回答这个问题，我们在Linux工作站（Ubuntu大约在2011年，快速SATA磁盘上使用Ext4文件系统）上运行了49个具有各种BLOB大小和SQLite页面大小的测试用例。对于每个测试用例，都会创建一个包含100MB BLOB内容的数据库。BLOB的大小范围从10KB到1MB。BLOB的数量各不相同，以使总BLOB内容保持在大约100MB。（因此，对于1MB大小，有100个BLOB，对于10K大小，有10000个BLOB，依此类推。）使用SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_8.html&quot;&gt;版本3.7.8&lt;/a&gt;（2011-09-19）。</target>
        </trans-unit>
        <trans-unit id="49ecd119f567ef3a86904898280b0f364fa219ed" translate="yes" xml:space="preserve">
          <source>To understand better how indices work, lets first look at how they are created. Let's go ahead and put an index on the two column of the examp table. We have:</source>
          <target state="translated">为了更好的理解索引的工作原理,我们先来看看索引是如何创建的。让我们继续在examp表的两列上建立一个索引。我们有。</target>
        </trans-unit>
        <trans-unit id="dec160dc75f7898baa78422fcd36c20f9eb86bdf" translate="yes" xml:space="preserve">
          <source>To use FTS5, the user creates an FTS5 virtual table with one or more columns. For example:</source>
          <target state="translated">要使用FTS5,用户需要创建一个带有一列或多列的FTS5虚拟表。例如:</target>
        </trans-unit>
        <trans-unit id="265f2aec4f2165ae622d11cb8e5b583eee970ef5" translate="yes" xml:space="preserve">
          <source>To use a custom delta format, the RBU application must register a user-defined SQL function named &quot;rbu_delta&quot; before beginning to process the update. rbu_delta() will be invoked with two arguments - the original value stored in the target table column and the delta value provided as part of the RBU update. It should return the result of applying the delta to the original value. To use the custom delta function, the character of the rbu_control value corresponding to the target column to update must be set to 'd' instead of 'x'. Then, instead of updating the target table with the value stored in the corresponding data_% column, RBU invokes the user-defined SQL function &quot;rbu_delta()&quot; and the store in the target table column.</source>
          <target state="translated">要使用自定义的delta格式,RBU应用程序必须在开始处理更新之前注册一个名为 &quot;rbu_delta &quot;的用户定义的SQL函数。rbu_delta()将以两个参数被调用--存储在目标表列中的原始值和作为RBU更新的一部分提供的delta值。它应该返回对原始值应用delta的结果。要使用自定义delta函数,必须将与要更新的目标列对应的rbu_control值的字符设置为'd',而不是'x'。然后,RBU不是用存储在相应data_%列中的值更新目标表,而是调用用户定义的SQL函数 &quot;rbu_delta()&quot;,并存储在目标表列中。</target>
        </trans-unit>
        <trans-unit id="1df3b152e981587cbc8d566dc7a1e4614e184269" translate="yes" xml:space="preserve">
          <source>To use the asynchronous IO extension, compile sqlite3async.c as part of the application that uses SQLite. Then use the APIs defined in sqlite3async.h to initialize and configure the module.</source>
          <target state="translated">要使用异步IO扩展,编译sqlite3async.c作为使用SQLite的应用程序的一部分。然后使用 sqlite3async.h 中定义的 API 来初始化和配置模块。</target>
        </trans-unit>
        <trans-unit id="54369ca0a2e65d88aa2188ae1aea4d3b328a4d8d" translate="yes" xml:space="preserve">
          <source>To work around this problem, comments of the form &quot;&lt;code&gt;/*OPTIMIZATION-IF-TRUE*/&lt;/code&gt;&quot; and &quot;&lt;code&gt;/*OPTIMIZATION-IF-FALSE*/&lt;/code&gt;&quot; are inserted into the SQLite source code to tell the mutation testing script to ignore some branch instructions.</source>
          <target state="translated">要变通解决此问题，将注释形式的&amp;ldquo; &lt;code&gt;/*OPTIMIZATION-IF-TRUE*/&lt;/code&gt; &amp;rdquo;和&amp;ldquo; &lt;code&gt;/*OPTIMIZATION-IF-FALSE*/&lt;/code&gt; &amp;rdquo;插入到SQLite源代码中，以告诉变异测试脚本忽略某些分支说明。</target>
        </trans-unit>
        <trans-unit id="8634a2716b4084136c44730377ba4cb303464e5e" translate="yes" xml:space="preserve">
          <source>To write to a database, a process must first acquire a SHARED lock as described above (possibly rolling back incomplete changes if there is a hot journal). After a SHARED lock is obtained, a RESERVED lock must be acquired. The RESERVED lock signals that the process intends to write to the database at some point in the future. Only one process at a time can hold a RESERVED lock. But other processes can continue to read the database while the RESERVED lock is held.</source>
          <target state="translated">要向数据库写入数据,一个进程必须首先获得一个如上所述的SHARED锁(如果有热日志,可能会回滚不完整的更改)。在获得SHARED锁之后,必须获得一个RESERVED锁。RESERVED锁发出信号,表明该进程打算在未来的某个时刻向数据库写入数据。每次只有一个进程可以持有一个RESERVED锁。但是其他进程可以在持有 RESERVED 锁的时候继续读取数据库。</target>
        </trans-unit>
        <trans-unit id="d6a3153289ec6bfe9b3f6870a925bacb15383077" translate="yes" xml:space="preserve">
          <source>Tokenize text using the tokenizer belonging to the FTS5 table.</source>
          <target state="translated">使用属于FTS5表的标记器对文本进行标记。</target>
        </trans-unit>
        <trans-unit id="0c8bdf6b370d1a312eb6820161397309d486c6dc" translate="yes" xml:space="preserve">
          <source>Tokenizer</source>
          <target state="translated">Tokenizer</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="75832235d44d151c0581571bd2e345dae5797a4a" translate="yes" xml:space="preserve">
          <source>Top-level programs determine first invocation by comparing the P1 operand against the P1 operand on the &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode at the beginning of the program. If the P1 values differ, then fall through and make the P1 of this opcode equal to the P1 of &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt;. If P1 values are the same then take the jump.</source>
          <target state="translated">顶级程序通过将P1操作数与程序开始时&lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt;操作码上的P1操作数进行比较来确定首次调用。如果P1值不同，则掉落并使该操作码的P1等于&lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt;的P1 。如果P1值相同，则进行跳转。</target>
        </trans-unit>
        <trans-unit id="95996c8558adf5424c8f05c23135b86d2248df1e" translate="yes" xml:space="preserve">
          <source>Torn Pages</source>
          <target state="translated">撕页</target>
        </trans-unit>
        <trans-unit id="f377932bef10eacf89a6d96048f5b7dd7d0a3754" translate="yes" xml:space="preserve">
          <source>Torn page</source>
          <target state="translated">撕页</target>
        </trans-unit>
        <trans-unit id="052c92ab74e0edce8a8ddb051550d404ed7fea5b" translate="yes" xml:space="preserve">
          <source>Total Number Of Rows Modified</source>
          <target state="translated">修改的总行数</target>
        </trans-unit>
        <trans-unit id="3c9565648378ccdf7ff691fdffa344d4a20079e8" translate="yes" xml:space="preserve">
          <source>Total number of freelist pages.</source>
          <target state="translated">自由职业者总页数:</target>
        </trans-unit>
        <trans-unit id="bedc83f26e09b1694605e6429adbe802acf7164e" translate="yes" xml:space="preserve">
          <source>Total storage space used by the current page or btree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f38169a712e499b917900e244feafc980a814f4" translate="yes" xml:space="preserve">
          <source>Trace</source>
          <target state="translated">Trace</target>
        </trans-unit>
        <trans-unit id="74cdc489721505bec65d3348184378ff2eaaa995" translate="yes" xml:space="preserve">
          <source>Trace method</source>
          <target state="translated">追踪方法</target>
        </trans-unit>
        <trans-unit id="d43a1036d6d0f2293d5b6b4fac27045bad910d65" translate="yes" xml:space="preserve">
          <source>Traces for &lt;b&gt;close&lt;/b&gt; invoke the callback with a single argument as the database connection is closing. The argument is an integer which is the value of a pointer to the underlying &lt;a href=&quot;c3ref/sqlite3&quot;&gt;sqlite3&lt;/a&gt; object that is closing.</source>
          <target state="translated">当数据库连接关闭时，&lt;b&gt;关闭&lt;/b&gt;跟踪将使用单个参数调用回调。参数是一个整数，它是指向即将关闭的基础&lt;a href=&quot;c3ref/sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象的指针的值。</target>
        </trans-unit>
        <trans-unit id="a9ae29ad74c7078369f553dd8cff4f37e437703e" translate="yes" xml:space="preserve">
          <source>Traces for &lt;b&gt;profile&lt;/b&gt; invoke the callback with two arguments as each SQL statement finishes. The first argument is an integer which is the value of the underlying &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object. The second argument is the approximate run-time for the statement in nanoseconds. The run-time is the best estimate available depending on the capabilities of the platform on which the application is running.</source>
          <target state="translated">每个SQL语句完成时，&lt;b&gt;配置文件的&lt;/b&gt;跟踪将使用两个参数来调用回调。第一个参数是一个整数，它是基础&lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;对象的值。第二个参数是该语句的近似运行时间（以纳秒为单位）。运行时是可用的最佳估计，具体取决于运行应用程序的平台的功能。</target>
        </trans-unit>
        <trans-unit id="57b5e1e30279e2c4dd1bed70627b5481cb49b436" translate="yes" xml:space="preserve">
          <source>Traces for &lt;b&gt;row&lt;/b&gt; invoke the callback with a single argument whenever a new result row is available from an SQL statement. The argument is an integer which is the value of the underlying &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object pointer.</source>
          <target state="translated">每当来自SQL语句的新结果行可用时，针对&lt;b&gt;行的&lt;/b&gt;跟踪将使用单个参数调用回调。参数是一个整数，它是基础&lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;对象指针的值。</target>
        </trans-unit>
        <trans-unit id="408f79d424be1f606eac26e2ea2665bbafc8553b" translate="yes" xml:space="preserve">
          <source>Traces for &lt;b&gt;statement&lt;/b&gt; invoke the callback with two arguments whenever a new SQL statement is run. The first argument is an integer which is the value of the pointer to the underlying &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object. This integer can be used to correlate SQL statement text with the result of a &lt;b&gt;profile&lt;/b&gt; or &lt;b&gt;row&lt;/b&gt; callback. The second argument is the unexpanded text of the SQL statement being run. By &quot;unexpanded&quot;, we mean that variable substitutions in the text are not expanded into the variable values. This is different from the behavior of the &quot;trace&quot; method which does expand variable substitutions.</source>
          <target state="translated">每当运行新的SQL语句时，for &lt;b&gt;语句的&lt;/b&gt;跟踪都会使用两个参数来调用回调。第一个参数是一个整数，它是指向基础&lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;对象的指针的值。该整数可用于将SQL语句文本与&lt;b&gt;配置文件&lt;/b&gt;或&lt;b&gt;行&lt;/b&gt;回调的结果相关联。第二个参数是正在运行的SQL语句的未扩展文本。 &amp;ldquo;未扩展&amp;rdquo;是指文本中的变量替换未扩展为变量值。这与&amp;ldquo; trace&amp;rdquo;方法的行为不同，后者确实扩展了变量替换。</target>
        </trans-unit>
        <trans-unit id="97acc1b59f9ec17c88715b436c8c28883bd4892f" translate="yes" xml:space="preserve">
          <source>Tracing And Profiling Functions</source>
          <target state="translated">追踪和剖析功能</target>
        </trans-unit>
        <trans-unit id="394bbe198e3a9b250514b00b862a8ecf0b427532" translate="yes" xml:space="preserve">
          <source>Tracing VDBE Program Execution</source>
          <target state="translated">追踪VDBE程序的执行情况</target>
        </trans-unit>
        <trans-unit id="a89304c783bc5056656be7a965ab51352c92b27f" translate="yes" xml:space="preserve">
          <source>Traditional Command</source>
          <target state="translated">传统指挥</target>
        </trans-unit>
        <trans-unit id="1a7b7c1b33d161f45804730c70b75175dccd9883" translate="yes" xml:space="preserve">
          <source>Transaction</source>
          <target state="translated">Transaction</target>
        </trans-unit>
        <trans-unit id="9f6d84035f64a6ceb70cb91cd6cf32d299234a85" translate="yes" xml:space="preserve">
          <source>Transaction Nesting Rules</source>
          <target state="translated">交易嵌套规则</target>
        </trans-unit>
        <trans-unit id="559a84bc65d3e0735a796537311e8ae93e9b3578" translate="yes" xml:space="preserve">
          <source>Transaction Rollback</source>
          <target state="translated">交易回滚</target>
        </trans-unit>
        <trans-unit id="8ade0bd69f2ac11b2fad88f7b26304c0adf8bac8" translate="yes" xml:space="preserve">
          <source>Transaction control statements such as &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt;, &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt;, &lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;, &lt;a href=&quot;../lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;, and &lt;a href=&quot;../lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; cause sqlite3_stmt_readonly() to return true, since the statements themselves do not actually modify the database but rather they control the timing of when other statements modify the database. The &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; and &lt;a href=&quot;../lang_detach&quot;&gt;DETACH&lt;/a&gt; statements also cause sqlite3_stmt_readonly() to return true since, while those statements change the configuration of a database connection, they do not make changes to the content of the database files on disk. The sqlite3_stmt_readonly() interface returns true for &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt; since &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt; merely sets internal flags, but the &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; and &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN EXCLUSIVE&lt;/a&gt; commands do touch the database and so sqlite3_stmt_readonly() returns false for those commands.</source>
          <target state="translated">事务控制语句（例如&lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt;，&lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt;，&lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;，&lt;a href=&quot;../lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;和&lt;a href=&quot;../lang_savepoint&quot;&gt;RELEASE）&lt;/a&gt;使sqlite3_stmt_readonly（）返回true，因为语句本身并不实际修改数据库，而是控制其他语句修改数据库的时间。该&lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;和&lt;a href=&quot;../lang_detach&quot;&gt;DETACH&lt;/a&gt;语句也引起sqlite3_stmt_readonly（），因为返回true，而那些语句更改数据库连接的配置，也不用更改数据库文件的磁盘上的内容。 sqlite3_stmt_readonly（）接口为&lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt;返回true，因为&lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt;仅设置内部标志，但是&lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt;和&lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN EXCLUSIVE&lt;/a&gt;命令确实会触及数据库，因此sqlite3_stmt_readonly（）对于这些命令返回false。</target>
        </trans-unit>
        <trans-unit id="27b3779c5fd38ff491a7c50d915a8ad6fa71bac3" translate="yes" xml:space="preserve">
          <source>Transaction control statements such as &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;, &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;, &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;, &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;, and &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; cause sqlite3_stmt_readonly() to return true, since the statements themselves do not actually modify the database but rather they control the timing of when other statements modify the database. The &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; and &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; statements also cause sqlite3_stmt_readonly() to return true since, while those statements change the configuration of a database connection, they do not make changes to the content of the database files on disk. The sqlite3_stmt_readonly() interface returns true for &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; since &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; merely sets internal flags, but the &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; and &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN EXCLUSIVE&lt;/a&gt; commands do touch the database and so sqlite3_stmt_readonly() returns false for those commands.</source>
          <target state="translated">事务控制语句（例如&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;，&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;，&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;，&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;和&lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE）&lt;/a&gt;使sqlite3_stmt_readonly（）返回true，因为语句本身并不实际修改数据库，而是控制其他语句修改数据库的时间。该&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;和&lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt;语句也引起sqlite3_stmt_readonly（），因为返回true，而那些语句更改数据库连接的配置，也不用更改数据库文件的磁盘上的内容。 sqlite3_stmt_readonly（）接口为&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;返回true，因为&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;仅设置内部标志，但是&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt;和&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN EXCLUSIVE&lt;/a&gt;命令确实会触及数据库，因此sqlite3_stmt_readonly（）对于这些命令返回false。</target>
        </trans-unit>
        <trans-unit id="8a3a9f146929435e416d0b1eea1f2d4c645865f1" translate="yes" xml:space="preserve">
          <source>Transaction method</source>
          <target state="translated">交易方法</target>
        </trans-unit>
        <trans-unit id="e07bd983fd2be3fec651b38d00687dea5ddec91f" translate="yes" xml:space="preserve">
          <source>Transaction speed is limited by disk drive speed because (by default) SQLite actually waits until the data really is safely stored on the disk surface before the transaction is complete. That way, if you suddenly lose power or if your OS crashes, your data is still safe. For details, read about &lt;a href=&quot;atomiccommit&quot;&gt;atomic commit in SQLite.&lt;/a&gt;.</source>
          <target state="translated">事务处理速度受到磁盘驱动器速度的限制，因为（默认情况下）SQLite实际上会等到数据真正安全地存储在磁盘表面上，然后再完成事务处理。这样，即使您突然断电或操作系统崩溃，您的数据仍然是安全的。有关详细信息，请阅读有关&lt;a href=&quot;atomiccommit&quot;&gt;SQLite中的原子提交的信息。&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="df69c71bc9ee2d5d83cb3c63296f150aa519dbce" translate="yes" xml:space="preserve">
          <source>Transactions can be DEFERRED, IMMEDIATE, or EXCLUSIVE. The default transaction behavior is DEFERRED.</source>
          <target state="translated">交易可以是DEFERRED、IMMEDIATE或EXCLUSIVE。默认的交易行为是DEFERRED。</target>
        </trans-unit>
        <trans-unit id="8441979420cc8e7193bf0e0806b90756ef918a72" translate="yes" xml:space="preserve">
          <source>Transactions can be started manually using the BEGIN command. Such transactions usually persist until the next COMMIT or ROLLBACK command. But a transaction will also ROLLBACK if the database is closed or if an error occurs and the ROLLBACK conflict resolution algorithm is specified. See the documentation on the &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clause for additional information about the ROLLBACK conflict resolution algorithm.</source>
          <target state="translated">可以使用BEGIN命令手动启动事务。这样的事务通常会持续到下一个COMMIT或ROLLBACK命令为止。但是，如果数据库关闭或发生错误并且指定了ROLLBACK冲突解决算法，则事务也将回滚。有关ROLLBACK冲突解决算法的更多信息，请参见&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;子句的文档。</target>
        </trans-unit>
        <trans-unit id="5743531bc167a0f47f6a510d1c09f16148c6d3da" translate="yes" xml:space="preserve">
          <source>Transactions created using BEGIN...COMMIT do not nest. For nested transactions, use the &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; and &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; commands. The &quot;TO SAVEPOINT name&quot; clause of the ROLLBACK command shown in the syntax diagram above is only applicable to &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; transactions. An attempt to invoke the BEGIN command within a transaction will fail with an error, regardless of whether the transaction was started by &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; or a prior BEGIN. The COMMIT command and the ROLLBACK command without the TO clause work the same on &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; transactions as they do with transactions started by BEGIN.</source>
          <target state="translated">使用BEGIN ... COMMIT创建的事务不会嵌套。对于嵌套事务，请使用&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;和&lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt;命令。上面的语法图中显示的ROLLBACK命令的&amp;ldquo; TO SAVEPOINT名称&amp;rdquo;子句仅适用于&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;事务。无论事务是由&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;启动还是由先前的BEGIN 启动，尝试在事务内调用BEGIN命令都将失败并显示错误。不带TO子句的COMMIT命令和ROLLBACK命令在&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;事务上的作用与对BEGIN启动的事务的作用相同。</target>
        </trans-unit>
        <trans-unit id="4e5b097bbdedc9d11240febdc9033ef693213407" translate="yes" xml:space="preserve">
          <source>Transactions in SQLite are SERIALIZABLE.</source>
          <target state="translated">SQLite中的事务是SERIALIZABLE的。</target>
        </trans-unit>
        <trans-unit id="40f17b088c01997dd93e90e0db80840a80f74d26" translate="yes" xml:space="preserve">
          <source>Transactions involving multiple attached databases are atomic, assuming that the main database is not &quot;&lt;a href=&quot;inmemorydb&quot;&gt;:memory:&lt;/a&gt;&quot; and the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; is not &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;. If the main database is &quot;:memory:&quot; or if the journal_mode is WAL, then transactions continue to be atomic within each individual database file. But if the host computer crashes in the middle of a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; where two or more database files are updated, some of those files might get the changes where others might not.</source>
          <target state="translated">假设主数据库不是&amp;ldquo; &lt;a href=&quot;inmemorydb&quot;&gt;：memory：&lt;/a&gt; &amp;rdquo;并且&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt;不是&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;，则涉及多个附加数据库的事务是原子的。如果主数据库是&amp;ldquo;：memory：&amp;rdquo;或journal_mode是WAL，则事务在每个单独的数据库文件中仍然是原子的。但是，如果主机在更新两个或多个数据库文件的&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;中间崩溃，则其中的某些文件可能会获得更改，而其他文件可能不会。</target>
        </trans-unit>
        <trans-unit id="eceeec5767d02607ea24c1ab3a8a3bd0186d9069" translate="yes" xml:space="preserve">
          <source>Transactions that involve changes against multiple &lt;a href=&quot;lang_attach&quot;&gt;ATTACHed&lt;/a&gt; databases are atomic for each individual database, but are not atomic across all databases as a set.</source>
          <target state="translated">涉及对多个&lt;a href=&quot;lang_attach&quot;&gt;ATTACHed&lt;/a&gt;数据库进行更改的事务对于每个单独的数据库都是原子的，但是对于作为集合的所有数据库都不是原子的。</target>
        </trans-unit>
        <trans-unit id="62eb009ad23bc2fc48eb046817b2cfc13d56eba9" translate="yes" xml:space="preserve">
          <source>Transfer any terms of the HAVING clause that use only columns mentioned in the GROUP BY clause over to the WHERE clause for faster processing.</source>
          <target state="translated">将HAVING子句中只使用GROUP BY子句中提到的列的任何条款转移到WHERE子句中,以加快处理速度。</target>
        </trans-unit>
        <trans-unit id="730f8c6a84d5869c2c8dd4a477da51b4cb41ea47" translate="yes" xml:space="preserve">
          <source>Transfer content from X into new_X using a statement like: INSERT INTO new_X SELECT ... FROM X.</source>
          <target state="translated">使用类似这样的语句将X中的内容转移到new_X中。INSERT INTO new_X SELECT ...FROM X。</target>
        </trans-unit>
        <trans-unit id="f547c01f878e078bc070f937769a72523b2e574f" translate="yes" xml:space="preserve">
          <source>Transfer the integer value held in register P1 into register P2.</source>
          <target state="translated">将寄存器P1中的整数值转移到寄存器P2中。</target>
        </trans-unit>
        <trans-unit id="77dbfff94d90d8a93cedb37403df1e3f9c6cd3b3" translate="yes" xml:space="preserve">
          <source>Transfer the values of bound parameter P1 into register P2</source>
          <target state="translated">将绑定参数P1的值转移到寄存器P2中。</target>
        </trans-unit>
        <trans-unit id="893d914ab7aa99042fec20acf2eaca5958133d3d" translate="yes" xml:space="preserve">
          <source>Transient databases used by VACUUM</source>
          <target state="translated">VACUUM使用的瞬时数据库。</target>
        </trans-unit>
        <trans-unit id="2f1b468fe1a7e1526a9f4c864607d41c919ffd24" translate="yes" xml:space="preserve">
          <source>Transient indices</source>
          <target state="translated">瞬态指数</target>
        </trans-unit>
        <trans-unit id="50518458bc2d78b06bb9e7c5b63ac61506608217" translate="yes" xml:space="preserve">
          <source>Translate between MBCS and UTF8 when running in &lt;a href=&quot;https://en.wikipedia.org/wiki/Cmd.exe&quot;&gt;cmd.exe&lt;/a&gt; on Windows.</source>
          <target state="translated">在Windows 上的&lt;a href=&quot;https://en.wikipedia.org/wiki/Cmd.exe&quot;&gt;cmd.exe中&lt;/a&gt;运行时，在MBCS和UTF8之间转换。</target>
        </trans-unit>
        <trans-unit id="6e387894c93cc4723354d247bd4d6e5f35bd4895" translate="yes" xml:space="preserve">
          <source>Translate filenames</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="644d0f445f0d7fb8522aea7a162b92e1da1dcdd3" translate="yes" xml:space="preserve">
          <source>Treat carriage returns as white space.</source>
          <target state="translated">将回车作为白色空间处理。</target>
        </trans-unit>
        <trans-unit id="aa1627be3072e4ff3d0841c2ea6a10d65f535946" translate="yes" xml:space="preserve">
          <source>Treats the CROSS JOIN operator specially</source>
          <target state="translated">对CROSS JOIN操作者进行特殊处理</target>
        </trans-unit>
        <trans-unit id="decc687edb29445327b8a79bb188b87ba3135e16" translate="yes" xml:space="preserve">
          <source>Trigger automatic reprepares on all prepared statements when &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; is run.</source>
          <target state="translated">在运行&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;时，对所有准备好的语句触发自动重新准备。</target>
        </trans-unit>
        <trans-unit id="1766c462387d7f9f9f502cf4237e70b197fe70e9" translate="yes" xml:space="preserve">
          <source>Triggers are automatically &lt;a href=&quot;lang_droptrigger&quot;&gt;dropped&lt;/a&gt; when the table that they are associated with (the</source>
          <target state="translated">触发器自动&lt;a href=&quot;lang_droptrigger&quot;&gt;下降&lt;/a&gt;时表，他们正在与（相关</target>
        </trans-unit>
        <trans-unit id="69e3fbc441e15119829ba089bca3c89252728d25" translate="yes" xml:space="preserve">
          <source>Triggers are removed using the &lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt; statement.</source>
          <target state="translated">使用&lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt;语句删除触发器。</target>
        </trans-unit>
        <trans-unit id="dcdd52f1e8691359fb02268af93879c1dfcea004" translate="yes" xml:space="preserve">
          <source>Triggers may be created on &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt;, as well as ordinary tables, by specifying INSTEAD OF in the CREATE TRIGGER statement. If one or more ON INSERT, ON DELETE or ON UPDATE triggers are defined on a view, then it is not an error to execute an INSERT, DELETE or UPDATE statement on the view, respectively. Instead, executing an INSERT, DELETE or UPDATE on the view causes the associated triggers to fire. The real tables underlying the view are not modified (except possibly explicitly, by a trigger program).</source>
          <target state="translated">通过在CREATE TRIGGER语句中指定INSTEAD OF，可以在&lt;a href=&quot;lang_createview&quot;&gt;视图&lt;/a&gt;以及普通表上创建触发器。如果在视图上定义了一个或多个ON INSERT，ON DELETE或ON UPDATE触发器，那么分别在视图上执行INSERT，DELETE或UPDATE语句就不会出错。而是在视图上执行INSERT，DELETE或UPDATE会引发关联的触发器。视图基础的实际表不会被修改（可能由触发程序明确修改除外）。</target>
        </trans-unit>
        <trans-unit id="b66e919e408840fec331f77f8a3429cfe94170cd" translate="yes" xml:space="preserve">
          <source>Triggers such as the above could be entered manually, but that is tedious. An important feature of the technique demonstrated below is that the triggers are generated automatically.</source>
          <target state="translated">诸如上述的触发器可以手动输入,但那很繁琐。下面演示的技术的一个重要特点是,触发器是自动生成的。</target>
        </trans-unit>
        <trans-unit id="e34acb097623e43c8ff52044ca91f3ced5485a85" translate="yes" xml:space="preserve">
          <source>Triggers to record changes to table EX1 might look like this:</source>
          <target state="translated">记录表EX1变化的触发器可能是这样的。</target>
        </trans-unit>
        <trans-unit id="43c2fb589737be865737ea2fc85a0b75088859d6" translate="yes" xml:space="preserve">
          <source>True (non-zero) for incremental-vacuum mode. False (zero) otherwise.</source>
          <target state="translated">增量真空模式为真(非零),否则为假(零)。否则为假(零)。</target>
        </trans-unit>
        <trans-unit id="7f074c0b29f264e9ae59cff2fae5db054bccc396" translate="yes" xml:space="preserve">
          <source>True if column has a NOT NULL constraint</source>
          <target state="translated">如果列有NOT NULL约束,则为真。</target>
        </trans-unit>
        <trans-unit id="fe2612de064655438c6e90275d3a5af5d9b7504f" translate="yes" xml:space="preserve">
          <source>True if column is &lt;a href=&quot;../autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;</source>
          <target state="translated">如果&lt;a href=&quot;../autoinc&quot;&gt;列为AUTOINCREMENT，&lt;/a&gt;则为True</target>
        </trans-unit>
        <trans-unit id="7d8389507b03b7d46d63990e4a0a8f44db65074c" translate="yes" xml:space="preserve">
          <source>True if column is &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;</source>
          <target state="translated">如果&lt;a href=&quot;autoinc&quot;&gt;列为AUTOINCREMENT，&lt;/a&gt;则为True</target>
        </trans-unit>
        <trans-unit id="1c010493691adbcbc6784aac8024d72b69524a24" translate="yes" xml:space="preserve">
          <source>True if column is part of the PRIMARY KEY</source>
          <target state="translated">如果列是PRIMARY KEY的一部分,则为真。</target>
        </trans-unit>
        <trans-unit id="ce6a6b1eac82572eb6efa838b7ab286cb9aa31b8" translate="yes" xml:space="preserve">
          <source>True if the WAL file uses big-ending checksums. 0 if the WAL uses little-endian checksums.</source>
          <target state="translated">如果WAL文件使用大尾端校验和,则为真。如果WAL文件使用小尾数校验和,则为0。</target>
        </trans-unit>
        <trans-unit id="4f373c45e72a0d221fc0b61dcd227422649ce1e7" translate="yes" xml:space="preserve">
          <source>Truncate optimization</source>
          <target state="translated">截断优化</target>
        </trans-unit>
        <trans-unit id="7e18421daa9a7bec86e2d8e3de5902e74a610b23" translate="yes" xml:space="preserve">
          <source>Truncate rather than delete the rollback journal when committing a transaction in exclusive access mode, or when committing the TEMP database.</source>
          <target state="translated">在独占访问模式下提交事务或提交腾博会登录数据库时,截断而不是删除回滚日志。</target>
        </trans-unit>
        <trans-unit id="4b63e8b603e1d297d723aa97c1e1ff1c6b4ada53" translate="yes" xml:space="preserve">
          <source>Truncating a page from the end of the database file.</source>
          <target state="translated">从数据库文件的结尾处截断一个页面。</target>
        </trans-unit>
        <trans-unit id="4e8f932224015abd68ecfec37f440d1143c9375a" translate="yes" xml:space="preserve">
          <source>Try to set the maximum page count for database P1 to the value in P3. Do not let the maximum page count fall below the current page count and do not change the maximum page count value if P3==0.</source>
          <target state="translated">尝试将数据库P1的最大页数设置为P3中的值。不要让最大页数低于当前页数,如果P3==0,不要改变最大页数值。</target>
        </trans-unit>
        <trans-unit id="6f50ca78764f92b1078126a69f3373b839ce5721" translate="yes" xml:space="preserve">
          <source>Tweaks to the query planner to help it do a better job of finding the most efficient query plan for each query.</source>
          <target state="translated">对查询规划器进行调整,帮助它更好地为每个查询找到最有效的查询计划。</target>
        </trans-unit>
        <trans-unit id="95be1719f96ddc802fb54cddca40bb8014e1f9bb" translate="yes" xml:space="preserve">
          <source>Two &quot;%&quot; characters in a row are translated into a single &quot;%&quot; in the output, without substituting any values.</source>
          <target state="translated">一行中的两个&quot;%&quot;字符在输出中被翻译成一个&quot;%&quot;,不需要替换任何值。</target>
        </trans-unit>
        <trans-unit id="1133220939a743e590c3ead4cc79361a1d89e1c7" translate="yes" xml:space="preserve">
          <source>Two methods of measuring test coverage were described above: &quot;statement&quot; and &quot;branch&quot; coverage. There are many other test coverage metrics besides these two. Another popular metric is &quot;Modified Condition/Decision Coverage&quot; or MC/DC. &lt;a href=&quot;http://en.wikipedia.org/wiki/Modified_Condition/Decision_Coverage&quot;&gt;Wikipedia&lt;/a&gt; defines MC/DC as follows:</source>
          <target state="translated">上面描述了两种测量测试覆盖率的方法：&amp;ldquo;声明&amp;rdquo;和&amp;ldquo;分支&amp;rdquo;覆盖率。除了这两个以外，还有许多其他测试覆盖率指标。另一个流行的度量标准是&amp;ldquo;修改的条件/决策覆盖率&amp;rdquo;或MC / DC。&lt;a href=&quot;http://en.wikipedia.org/wiki/Modified_Condition/Decision_Coverage&quot;&gt;维基百科&lt;/a&gt;对MC / DC的定义如下：</target>
        </trans-unit>
        <trans-unit id="8cca3509242a992941b536c5c6f0d9414a60665b" translate="yes" xml:space="preserve">
          <source>Two or more &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; statements may be connected together to form a compound SELECT using the UNION, UNION ALL, INTERSECT or EXCEPT operator, as shown by the following diagram:</source>
          <target state="translated">可以使用UNION，UNION ALL，INTERSECT或EXCEPT运算符将两个或多个&lt;a href=&quot;lang_select#simpleselect&quot;&gt;简单的SELECT&lt;/a&gt;语句连接在一起以形成复合SELECT，如下图所示：</target>
        </trans-unit>
        <trans-unit id="b49920fdd4ad177f1ffaae1df0f25051b8256c94" translate="yes" xml:space="preserve">
          <source>Two or more MATCH operators are allowed in the same WHERE clause, as long as they are connected by AND operators. However, the R*Tree query engine only contains a single priority queue. The priority assigned to each node in the search is the lowest priority returned by any of the MATCH operators.</source>
          <target state="translated">在同一个WHERE子句中允许有两个或多个MATCH运算符,只要它们由AND运算符连接即可。但是,R*Tree查询引擎只包含一个优先级队列。分配给搜索中每个节点的优先级是任何一个MATCH操作符返回的最低优先级。</target>
        </trans-unit>
        <trans-unit id="b719bd70cf2f4781f7a548062aa93163c0a6f5e6" translate="yes" xml:space="preserve">
          <source>Two or more changeset/patchsets may be combined using the &lt;a href=&quot;session/sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat()&lt;/a&gt; or &lt;a href=&quot;session/changegroup&quot;&gt;sqlite3_changegroup&lt;/a&gt; interfaces.</source>
          <target state="translated">可以使用&lt;a href=&quot;session/sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat（）&lt;/a&gt;或&lt;a href=&quot;session/changegroup&quot;&gt;sqlite3_changegroup&lt;/a&gt;接口组合两个或多个变更集/补丁集。</target>
        </trans-unit>
        <trans-unit id="b9c4d063752347abc5d77d07399a38265fd22861" translate="yes" xml:space="preserve">
          <source>Two or more phrases may be grouped into a &lt;b&gt;NEAR group&lt;/b&gt;. A NEAR group is specified by the token &quot;NEAR&quot; (case sensitive) followed by an open parenthesis character, followed by two or more whitespace separated phrases, optionally followed by a comma and the numeric parameter</source>
          <target state="translated">可以将两个或多个短语分组为&lt;b&gt;NEAR组&lt;/b&gt;。NEAR组由标记&amp;ldquo; NEAR&amp;rdquo;（区分大小写）指定，后跟一个开放的括号字符，然后是两个或多个空格分隔的短语，并可选地后面跟一个逗号和数字参数</target>
        </trans-unit>
        <trans-unit id="0284a3abf0fb32119d7d4eb4f9b488143f92f251" translate="yes" xml:space="preserve">
          <source>Two other very minor bug fixes</source>
          <target state="translated">另外两个非常小的错误修复</target>
        </trans-unit>
        <trans-unit id="439961cdf4c53f5e47fc6a54c26c745e60b3c545" translate="yes" xml:space="preserve">
          <source>Two row values are compared by looking at the constituent scalar values from left to right. A NULL means of &quot;unknown&quot;. The overall result of comparison is NULL if it is possible to make the result either true or false by substituting alternative values in place of the constituent NULLs. The following query demonstrates some row value comparisons:</source>
          <target state="translated">通过从左到右观察组成标量值来比较两行值。NULL表示 &quot;未知&quot;。如果可以通过用替代值代替组成的NULL来使结果为真或为假,那么比较的总体结果就是NULL。下面的查询演示了一些行值比较。</target>
        </trans-unit>
        <trans-unit id="ce050ac4e33af964af82beb0e5b3e0ce52ab58e9" translate="yes" xml:space="preserve">
          <source>Two row values of the same size can be compared using operators &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, =, &amp;lt;&amp;gt;, IS, IS NOT, IN, NOT IN, BETWEEN, or CASE.</source>
          <target state="translated">可以使用运算符&amp;lt;，&amp;lt;=，&amp;gt;，&amp;gt; =，=，&amp;lt;&amp;gt;，IS，IS NOT，IN，IN，NOT IN，BETWEEN或CASE比较具有相同大小的两个行值。</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="59ef232ad2a9a13529bf5e89145da92a1a6319d6" translate="yes" xml:space="preserve">
          <source>Type affinity</source>
          <target state="translated">类型亲和力</target>
        </trans-unit>
        <trans-unit id="38895187a3c7e29b6f02e06c184834c7180dd221" translate="yes" xml:space="preserve">
          <source>Typical output from a single TH3 test program run looks like this:</source>
          <target state="translated">一个TH3测试程序运行的典型输出是这样的。</target>
        </trans-unit>
        <trans-unit id="8711d8537a2bf9829ad98f22b75b8b8dc119969c" translate="yes" xml:space="preserve">
          <source>UNBOUNDED</source>
          <target state="translated">UNBOUNDED</target>
        </trans-unit>
        <trans-unit id="363cb5cb9b015bf8fe75ee8f6f3ad675ca5618cc" translate="yes" xml:space="preserve">
          <source>UNION</source>
          <target state="translated">UNION</target>
        </trans-unit>
        <trans-unit id="e0f0a7115a4e0b11973725c719a99090b1a2caa7" translate="yes" xml:space="preserve">
          <source>UNION ALL ... UNION ALL SELECT</source>
          <target state="translated">UNION ALL ...UNION ALL SELECT</target>
        </trans-unit>
        <trans-unit id="2ef896dc8994d71c3776f028df0d2a89b61b4550" translate="yes" xml:space="preserve">
          <source>UNION, UNION ALL, INTERSECT, and EXCEPT</source>
          <target state="translated">UNION、UNION ALL、INTERSECT和EXCEPT。</target>
        </trans-unit>
        <trans-unit id="c9e6a29d14f3f27cd2ee75b65407552ad50a3078" translate="yes" xml:space="preserve">
          <source>UNIQUE</source>
          <target state="translated">UNIQUE</target>
        </trans-unit>
        <trans-unit id="841c884fb288309550412babe47484ff0e3745f9" translate="yes" xml:space="preserve">
          <source>UNIQUE, CHECK, and NOT NULL constraint errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ead37d8578ae9705f3d87c1d034addd810cd1ed" translate="yes" xml:space="preserve">
          <source>UNIX mode, as returned by stat(2) for the zip file record (an integer). This identifies the type of record (file, directory or symbolic link), and the associated user/group/all permissions.</source>
          <target state="translated">UNIX 模式,由 stat(2)返回的 zip 文件记录(一个整数)。它标识了记录的类型(文件、目录或符号链接),以及相关的用户/组/所有权限。</target>
        </trans-unit>
        <trans-unit id="f6fee659655c0db9d5b27d3ee09d34358c974b03" translate="yes" xml:space="preserve">
          <source>UNLOCKED</source>
          <target state="translated">UNLOCKED</target>
        </trans-unit>
        <trans-unit id="d272346adafef58007de20094d2f682eb2fe1bd2" translate="yes" xml:space="preserve">
          <source>UNSIGNED BIG INT</source>
          <target state="translated">未签字的大国际</target>
        </trans-unit>
        <trans-unit id="52c6c1812015585dc1092393a1f244f60d68c60a" translate="yes" xml:space="preserve">
          <source>UPDATE</source>
          <target state="translated">UPDATE</target>
        </trans-unit>
        <trans-unit id="688e558eee1d1bb512a94d0cc620288bf7d472f2" translate="yes" xml:space="preserve">
          <source>UPDATE And DELETE Statements</source>
          <target state="translated">UPDATE 和 DELETE 语句</target>
        </trans-unit>
        <trans-unit id="49a16f1602f22a2ff3d079003de17960196cd62b" translate="yes" xml:space="preserve">
          <source>UPDATE Changes</source>
          <target state="translated">更新变化</target>
        </trans-unit>
        <trans-unit id="bf53a6aae01db9b5dad497a7e025817f66502008" translate="yes" xml:space="preserve">
          <source>UPDATE and DELETE statements work similarly.</source>
          <target state="translated">UPDATE和DELETE语句的工作原理类似。</target>
        </trans-unit>
        <trans-unit id="1c9d5c3eed910621fdbd8231e3b605e82a063d04" translate="yes" xml:space="preserve">
          <source>UPDATE statements work very much like DELETE statements except that instead of deleting the record they replace it with a new one. Consider this example:</source>
          <target state="translated">UPDATE语句的工作原理与DELETE语句非常相似,只是它们不是删除记录,而是用一个新的记录来替换。考虑这个例子。</target>
        </trans-unit>
        <trans-unit id="23f1f94678733621721dfbd9281a151e75fd39b3" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b = 'v2' WHERE a=1;</source>
          <target state="translated">UPDATE t1 SET b='v2' WHERE a=1;</target>
        </trans-unit>
        <trans-unit id="9d1ad45a1d025bcccb63dad4f87235cf205b5b63" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b=b*2 WHERE a&amp;gt;=0 AND a&amp;lt;10;</source>
          <target state="translated">更新t1设置b = b * 2其中a&amp;gt; = 0且a &amp;lt;10;</target>
        </trans-unit>
        <trans-unit id="7bc4a22623437c880e8e4324cc657c00abd18be7" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b=b*2 WHERE a&amp;gt;=10 AND a&amp;lt;20;</source>
          <target state="translated">更新t1设置b = b * 2其中a&amp;gt; = 10并且a &amp;lt;20;</target>
        </trans-unit>
        <trans-unit id="69fa4f2a787b8c6d32fe94ec05425d1fb170202e" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b=b*2 WHERE a&amp;gt;=9980 AND a&amp;lt;9990;</source>
          <target state="translated">更新t1设置b = b * 2其中a&amp;gt; = 9980和a &amp;lt;9990;</target>
        </trans-unit>
        <trans-unit id="bd6a359ea6d6ffa5fa77996361d46448cd59ce9f" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b=b*2 WHERE a&amp;gt;=9990 AND a&amp;lt;10000;</source>
          <target state="translated">更新t1设置b = b * 2其中a&amp;gt; = 9990并且a &amp;lt;10000;</target>
        </trans-unit>
        <trans-unit id="0afa724368a197872d6c5ffb446fe74a06bc33c2" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET b=121928 WHERE a=2;</source>
          <target state="translated">UPDATE t2 SET b=121928 WHERE a=2;</target>
        </trans-unit>
        <trans-unit id="3526291b0bb67daddf75ff2b44713d0b345a7083" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET b=347393 WHERE a=25000;</source>
          <target state="translated">UPDATE t2 SET b=347393 WHERE a=25000;</target>
        </trans-unit>
        <trans-unit id="1e3a05f35bab1c3145c54848bb462d616f180f96" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET b=35065 WHERE a=24999;</source>
          <target state="translated">UPDATE t2 SET b=35065 WHERE a=24999;</target>
        </trans-unit>
        <trans-unit id="83da842c2149e8d92733fb66a7c52922e2a8bb02" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET b=468026 WHERE a=1;</source>
          <target state="translated">UPDATE t2 SET b=468026 WHERE a=1。</target>
        </trans-unit>
        <trans-unit id="abe0aeef0bc8c95cf7dba0b992e2c26051c0fbd4" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET c='one hundred forty eight thousand three hundred eighty two' WHERE a=1;</source>
          <target state="translated">UPDATE t2 SET c='一百四十八万三千八百二' WHERE a=1。</target>
        </trans-unit>
        <trans-unit id="2e646600f6e7b2bb70471ce989105819d65503b9" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET c='three hundred eighty three thousand ninety nine' WHERE a=24999;</source>
          <target state="translated">UPDATE t2 SET c='三十八万三千九百九十九' WHERE a=24999。</target>
        </trans-unit>
        <trans-unit id="24be2b2373e2e643ec5af7225d298b219c086994" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET c='three hundred sixty six thousand five hundred two' WHERE a=2;</source>
          <target state="translated">UPDATE t2 SET c='三十六万五千两' WHERE a=2。</target>
        </trans-unit>
        <trans-unit id="317adbaa4dc2a3c2843d99c6771359a7f0624c58" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET c='two hundred fifty six thousand eight hundred thirty' WHERE a=25000;</source>
          <target state="translated">UPDATE t2 SET c='二十五万六千八百三十' WHERE a=25000。</target>
        </trans-unit>
        <trans-unit id="c55112b254b71dd5f11927b24c53d183f3ed4118" translate="yes" xml:space="preserve">
          <source>UPSERT</source>
          <target state="translated">UPSERT</target>
        </trans-unit>
        <trans-unit id="6eee69d236c66ab4ffc25696fb830833cbb3fd3c" translate="yes" xml:space="preserve">
          <source>UPSERT does not currently work for &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">UPSERT当前不适用于&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1c2066bfe0e8babe467800cce0c33996ece301c4" translate="yes" xml:space="preserve">
          <source>UPSERT is a special syntax addition to &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; that causes the INSERT to behave as an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or a no-op if the INSERT would violate a uniqueness constraint. UPSERT is not standard SQL. UPSERT in SQLite follows the syntax established by PostgreSQL. UPSERT syntax was added to SQLite with version 3.24.0 (2018-06-04).</source>
          <target state="translated">UPSERT是&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;的特殊语法补充，如果INSERT违反唯一性约束，则它会使INSERT表现为&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;或no-op。UPSERT不是标准的SQL。SQLite中的UPSERT遵循PostgreSQL建立的语法。UPSERT语法已添加到SQLite版本3.24.0（2018-06-04）中。</target>
        </trans-unit>
        <trans-unit id="095b20b5d88a77f400266be9db4f8fd23dca8121" translate="yes" xml:space="preserve">
          <source>URI Filenames</source>
          <target state="translated">URI文件名</target>
        </trans-unit>
        <trans-unit id="6b3e19882ec7248890e4c5d13ea994d174863955" translate="yes" xml:space="preserve">
          <source>URI filename examples</source>
          <target state="translated">URI文件名示例</target>
        </trans-unit>
        <trans-unit id="5e847e5e42eefec738b40d802039de3c59cd0211" translate="yes" xml:space="preserve">
          <source>URI filenames</source>
          <target state="translated">URI文件名</target>
        </trans-unit>
        <trans-unit id="bcc83fb4f795835fa81fea70c5b7f4ce3da5fb80" translate="yes" xml:space="preserve">
          <source>URI filenames are parsed according to RFC 3986. If the URI contains an authority, then it must be either an empty string or the string &quot;localhost&quot;. If the authority is not an empty string or &quot;localhost&quot;, an error is returned to the caller. The fragment component of a URI, if present, is ignored.</source>
          <target state="translated">URI文件名根据RFC 3986进行解析。如果URI包含一个权威,那么它必须是一个空字符串或 &quot;localhost &quot;字符串。如果授权不是空字符串或 &quot;localhost&quot;,则会向调用者返回一个错误。如果存在URI的片段成分,则会被忽略。</target>
        </trans-unit>
        <trans-unit id="f52fa99533bd53d2651964895f6aead88e88448d" translate="yes" xml:space="preserve">
          <source>URI filenames in sqlite3_open()</source>
          <target state="translated">sqlite3_open()中的URI文件名。</target>
        </trans-unit>
        <trans-unit id="26ed4ff394970482b699209414b942167f2dd638" translate="yes" xml:space="preserve">
          <source>URI hexadecimal escape sequences (%HH) are supported within the path and query components of a URI. A hexadecimal escape sequence consists of a percent sign - &quot;%&quot; - followed by exactly two hexadecimal digits specifying an octet value. Before the path or query components of a URI filename are interpreted, they are encoded using UTF-8 and all hexadecimal escape sequences replaced by a single byte containing the corresponding octet. If this process generates an invalid UTF-8 encoding, the results are undefined.</source>
          <target state="translated">在URI的路径和查询组件中支持URI十六进制转义序列(%HH)。一个十六进制转义序列由一个百分号--&quot;%&quot;--和两个十六进制数字组成,指定一个八位数的值。在解释URI文件名的路径或查询组件之前,它们使用UTF-8编码,所有十六进制转义序列被一个包含相应八位数的单字节所取代。如果这个过程产生了无效的UTF-8编码,那么结果是未定义的。</target>
        </trans-unit>
        <trans-unit id="40da99c368fe0d628f9b0dcc937070f1edfd1b1f" translate="yes" xml:space="preserve">
          <source>URIs are processed as UTF8 text. The filename argument sqlite3_open16() is converted from UTF16 native byte order into UTF8 prior to processing.</source>
          <target state="translated">URI被处理为UTF8文本。文件名参数sqlite3_open16()在处理前会从UTF16本机字节顺序转换为UTF8。</target>
        </trans-unit>
        <trans-unit id="41b3da30e1707f2b0bc331e3534b952825349eed" translate="yes" xml:space="preserve">
          <source>USB flash memory sticks seem to be especially pernicious liars regarding sync requests. One can easily see this by committing a large transaction to an SQLite database on a USB memory stick. The COMMIT command will return relatively quickly, indicating that the memory stick has told the operating system and the operating system has told SQLite that all content is safely in persistent storage, and yet the LED on the end of the memory stick will continue flashing for several more seconds. Pulling out the memory stick while the LED is still flashing will frequently result in database corruption.</source>
          <target state="translated">在同步请求方面,USB闪存棒似乎是特别恶毒的骗子。通过向U盘上的SQLite数据库提交一个大型事务,可以很容易地看出这一点。COMMIT命令会比较快地返回,说明记忆棒已经告诉操作系统,操作系统也已经告诉SQLite,所有的内容都安全地在持久化存储中,然而记忆棒末端的LED灯还会继续闪烁几秒钟。在LED灯还在闪烁的时候拔出记忆棒会经常导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="b0138e4f9dc0aacc367a1f86d8e4506b943320e8" translate="yes" xml:space="preserve">
          <source>USING</source>
          <target state="translated">USING</target>
        </trans-unit>
        <trans-unit id="4a2b12a8f9db417e4cc5f36a3e1c2fec1469fe7f" translate="yes" xml:space="preserve">
          <source>UTC timestamp, in seconds since the UNIX epoch (an integer).</source>
          <target state="translated">UTC时间戳,自UNIX纪元以来的秒数(一个整数)。</target>
        </trans-unit>
        <trans-unit id="28ef7752ac0283beed8e66a2b5b204db183549fd" translate="yes" xml:space="preserve">
          <source>Unallocated space</source>
          <target state="translated">未分配的空间</target>
        </trans-unit>
        <trans-unit id="b0b4a5a01660223c1f1c6d19e4a89997fe5e3325" translate="yes" xml:space="preserve">
          <source>Unary &quot;-&quot;</source>
          <target state="translated">单一的&quot;-&quot;</target>
        </trans-unit>
        <trans-unit id="6bfa68ac4d2f61f36caa0def08a4a0095686e16a" translate="yes" xml:space="preserve">
          <source>Undefined BEFORE trigger behavior</source>
          <target state="translated">未定义BEFORE触发行为</target>
        </trans-unit>
        <trans-unit id="9e37e5dd8e036cac3e0f290adf0e16da58e3ffe8" translate="yes" xml:space="preserve">
          <source>Undefined behavior checks</source>
          <target state="translated">未定义行为检查</target>
        </trans-unit>
        <trans-unit id="79dfa4a9456d7e99f2303579887d4ea94c961a44" translate="yes" xml:space="preserve">
          <source>Under Unix, an &lt;b&gt;sqlite*&lt;/b&gt; pointer should not be carried across a &lt;b&gt;fork()&lt;/b&gt; system call into the child process. The child process should open its own copy of the database after the &lt;b&gt;fork()&lt;/b&gt;.</source>
          <target state="translated">在Unix下，&lt;b&gt;sqlite *&lt;/b&gt;指针不应通过&lt;b&gt;fork（）&lt;/b&gt;系统调用携带到子进程中。子进程应在&lt;b&gt;fork（）&lt;/b&gt;之后打开其自己的数据库副本。</target>
        </trans-unit>
        <trans-unit id="7887974e08825eb481696126029ce641dab388bf" translate="yes" xml:space="preserve">
          <source>Under Unix, you should not carry an open SQLite database across a fork() system call into the child process.</source>
          <target state="translated">在Unix下,你不应该将一个开放的SQLite数据库跨越fork()系统调用带到子进程中。</target>
        </trans-unit>
        <trans-unit id="d2245919272810b035145426205e128fae32a19a" translate="yes" xml:space="preserve">
          <source>Under most circumstances, the original LIKE or GLOB operator is still tested against each input row even if the virtual terms are used to constrain an index. This is because we do not know what additional constraints may be imposed by characters to the right of the</source>
          <target state="translated">在大多数情况下,即使虚拟项被用来约束索引,原始的LIKE或GLOB操作符仍然会对每条输入行进行测试。这是因为我们不知道在虚拟项右边的字符可能会施加什么额外的约束。</target>
        </trans-unit>
        <trans-unit id="0aafde4f0303b5c58e56ca1461baa83fd0408041" translate="yes" xml:space="preserve">
          <source>Unfortunately, SQLite contains many branch instructions that help the code run faster without changing the output. Such branches generate false-positives during mutation testing. As an example, consider the following &lt;a href=&quot;https://www.sqlite.org/src/artifact/55b5fb474?ln=55-62&quot;&gt;hash function&lt;/a&gt; used to accelerate table-name lookup:</source>
          <target state="translated">不幸的是，SQLite包含许多分支指令，这些指令可以帮助代码更快地运行而无需更改输出。这样的分支在突变测试过程中会产生假阳性。例如，请考虑以下用于加速表名查找的&lt;a href=&quot;https://www.sqlite.org/src/artifact/55b5fb474?ln=55-62&quot;&gt;哈希函数&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="0c6793d3cab2ac8df02302e6322b00044082495f" translate="yes" xml:space="preserve">
          <source>Unfortunately, algorithm-2 is slower than algorithm-1 in this application.</source>
          <target state="translated">不幸的是,在这个应用中,算法-2比算法-1慢。</target>
        </trans-unit>
        <trans-unit id="fcfb2377607479ca817d6a09b03610de66f64da2" translate="yes" xml:space="preserve">
          <source>Unfortunately, even though virtual tables are ignored by default, any &lt;a href=&quot;fts3#*shadowtab&quot;&gt;underlying database tables&lt;/a&gt; that they create in order to store data within the database are not, and &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt; will include add these to any RBU database. For this reason, users attempting to use sqldiff to create RBU updates to apply to target databases with one or more virtual tables will likely have to run sqldiff using the --table option separately for each table to update in the target database.</source>
          <target state="translated">不幸的是，即使默认情况下虚拟表被忽略，它们为在数据库中存储数据而创建的任何&lt;a href=&quot;fts3#*shadowtab&quot;&gt;基础数据库表&lt;/a&gt;也不会被&lt;a href=&quot;sqldiff&quot;&gt;删除&lt;/a&gt;，并且sqldiff将包括将这些表添加到任何RBU数据库中。因此，尝试使用sqldiff创建RBU更新以应用于具有一个或多个虚拟表的目标数据库的用户可能必须使用--table选项单独运行sqldiff，以在目标数据库中更新每个表。</target>
        </trans-unit>
        <trans-unit id="c58a4f6c2a537b213079cd1adcaa6b2001643e9a" translate="yes" xml:space="preserve">
          <source>Unfortunately, most consumer-grade mass storage devices lie about syncing. Disk drives will report that content is safely on persistent media as soon as it reaches the track buffer and before actually being written to oxide. This makes the disk drives seem to operate faster (which is vitally important to the manufacturer so that they can show good benchmark numbers in trade magazines). And in fairness, the lie normally causes no harm, as long as there is no power loss or hard reset prior to the track buffer actually being written to oxide. But if a power loss or hard reset does occur, and if that results in content that was written after a sync reaching oxide while content written before the sync is still in a track buffer, then database corruption can occur.</source>
          <target state="translated">不幸的是,大多数消费级大容量存储设备在同步问题上撒谎。磁盘驱动器会报告说,内容一到达轨道缓冲区,在实际写入氧化物之前,就已经安全地在持久性介质上了。这使得磁盘驱动器看起来运行得更快(这对制造商来说至关重要,这样他们就可以在贸易杂志上展示良好的基准数据)。平心而论,只要在轨道缓冲区实际被写入氧化物之前没有断电或硬复位,这个谎言通常不会造成伤害。但是,如果确实发生了断电或硬复位,如果这导致在同步之后写入的内容到达氧化物,而同步之前写入的内容还在轨道缓冲区中,那么就会发生数据库损坏。</target>
        </trans-unit>
        <trans-unit id="af520d1880e5ee3cdc82e50d4d1525585fc7beb9" translate="yes" xml:space="preserve">
          <source>Unfortunately, the NGQP caused a performance regression in Fossil.</source>
          <target state="translated">不幸的是,NGQP造成了Fossil的性能倒退。</target>
        </trans-unit>
        <trans-unit id="7536fed3548161a0855cd29750230303476e4484" translate="yes" xml:space="preserve">
          <source>Unfortunately, the no-limits policy has been shown to create problems. Because the upper bounds were not well defined, they were not tested, and bugs (including possible security exploits) were often found when pushing SQLite to extremes. For this reason, newer versions of SQLite have well-defined limits and those limits are tested as part of the &lt;a href=&quot;testing&quot;&gt;test suite&lt;/a&gt;.</source>
          <target state="translated">不幸的是，无限制政策已经显示出会产生问题。由于上限没有很好地定义，因此未进行测试，并且在将SQLite推向极限时经常发现错误（包括可能的安全漏洞）。因此，较新版本的SQLite具有明确定义的限制，并且这些限制已作为&lt;a href=&quot;testing&quot;&gt;测试套件的&lt;/a&gt;一部分进行了测试。</target>
        </trans-unit>
        <trans-unit id="154cee1be1782349508f9f52cb47759ac0528fca" translate="yes" xml:space="preserve">
          <source>Unfortunately, the no-limits policy has been shown to create problems. Because the upper bounds were not well defined, they were not tested, and bugs were often found when pushing SQLite to extremes. For this reason, versions of SQLite since about release 3.5.8 (2008-04-16) have well-defined limits, and those limits are tested as part of the &lt;a href=&quot;testing&quot;&gt;test suite&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9809fad4d13ccafd43c46a06696bc5f74c1752de" translate="yes" xml:space="preserve">
          <source>Unfortunately, the query plan computed by NN for TPC-H Q8 is not optimal. The plan computed using NN is R-N1-N2-S-C-O-L-P with a cost of 36.92. The notation in the previous sentence means that the R table is run in the outer loop, N1 is in the next inner loop, N2 is in the third loop, and so forth down to P which is in the inner-most loop. The shortest path through the graph (as found via exhaustive search) is P-L-O-C-N1-R-S-N2 with a cost of 27.38. The difference might not seem like much, but remember that the costs are logarithmic, so the shortest path is nearly 750 times faster than that path found using the NN heuristic.</source>
          <target state="translated">遗憾的是,用NN计算出的TPC-H Q8的查询计划不是最优的。用NN计算的计划是R-N1-N2-S-C-O-L-P,成本为36.92。前面一句话中的符号是指R表在外循环中运行,N1在下一个内循环中运行,N2在第三个循环中运行,以此类推一直到最内循环中的P。图中最短的路径(通过穷尽搜索发现)是P-L-O-C-N1-R-S-N2,成本为27.38。这两者之间的差别可能看起来并不大,但请记住,成本是对数的,所以最短路径比使用NN启发式找到的路径快了近750倍。</target>
        </trans-unit>
        <trans-unit id="12b20c37115e65b5f7d7e36cc94465f524bad30b" translate="yes" xml:space="preserve">
          <source>Uniform Resource Identifiers</source>
          <target state="translated">统一资源标识符</target>
        </trans-unit>
        <trans-unit id="77df08227da6ac685804effa87058e13d84c4065" translate="yes" xml:space="preserve">
          <source>Unique constraint</source>
          <target state="translated">独特的制约因素</target>
        </trans-unit>
        <trans-unit id="aa980d194e964e7fb7f97273f5336434b107da41" translate="yes" xml:space="preserve">
          <source>Unique index</source>
          <target state="translated">单一指数</target>
        </trans-unit>
        <trans-unit id="7157e0defd66f64a5eef1f6b25ed305c7ea76e58" translate="yes" xml:space="preserve">
          <source>Unix builds come with multiple built-in VFSes. The default VFS for unix is called &quot;unix&quot; and is used in most applications. Other VFSes that might be found in unix (depending on compile-time options) include:</source>
          <target state="translated">Unix构建的时候会有多个内置的VFS。unix的默认VFS被称为 &quot;unix&quot;,在大多数应用程序中使用。其他可能在unix中找到的VFSes(取决于编译时的选项)包括:。</target>
        </trans-unit>
        <trans-unit id="fc9481ccc42310377001eaf4b65f0ba7f43291d9" translate="yes" xml:space="preserve">
          <source>Unless</source>
          <target state="translated">Unless</target>
        </trans-unit>
        <trans-unit id="e08358316619a161ecbcf33073f1d600c7a3d1d8" translate="yes" xml:space="preserve">
          <source>Unless SQLite is running in &quot;auto_vacuum=FULL&quot; mode, when a large amount of data is deleted from the database file it leaves behind empty space, or &quot;free&quot; database pages. This means the database file might be larger than strictly necessary. Running VACUUM to rebuild the database reclaims this space and reduces the size of the database file.</source>
          <target state="translated">除非SQLite运行在 &quot;auto_vacuum=FULL &quot;模式下,否则当大量数据从数据库文件中删除时,会留下空的空间,或 &quot;空闲 &quot;的数据库页面。这意味着数据库文件可能比严格意义上的需要更大。运行VACUUM重建数据库可以回收这些空间,减小数据库文件的大小。</target>
        </trans-unit>
        <trans-unit id="0e73f60b051af43064d6e0d8d691c92bf067b075" translate="yes" xml:space="preserve">
          <source>Unless a specific tokenizer is specified as part of the CREATE VIRTUAL TABLE statement used to create the FTS table, the default tokenizer, &quot;simple&quot;, is used. The simple tokenizer extracts tokens from a document or basic FTS full-text query according to the following rules:</source>
          <target state="translated">除非在创建 FTS 表的 CREATE VIRTUAL TABLE 语句中指定了特定的标记器,否则将使用默认的标记器 &quot;simple&quot;。simple tokenizer 根据以下规则从文档或基本 FTS 全文查询中提取标记。</target>
        </trans-unit>
        <trans-unit id="5fdc85037d052204b60739c85a692574cdca8812" translate="yes" xml:space="preserve">
          <source>Unless deadlock is detected (see below), sqlite3_unlock_notify() always returns SQLITE_OK.</source>
          <target state="translated">除非检测到死锁(见下文),否则sqlite3_unlock_notify()总是返回SQLITE_OK。</target>
        </trans-unit>
        <trans-unit id="7c4feec28833f0a64ab53ef0f49205604d9d8edc" translate="yes" xml:space="preserve">
          <source>Unless it is a CREATE TABLE ... AS SELECT statement, a CREATE TABLE includes one or more &lt;a href=&quot;syntax/column-def&quot;&gt;column definitions&lt;/a&gt;, optionally followed by a list of &lt;a href=&quot;syntax/table-constraint&quot;&gt;table constraints&lt;/a&gt;. Each column definition consists of the name of the column, optionally followed by the declared type of the column, then one or more optional &lt;a href=&quot;syntax/column-constraint&quot;&gt;column constraints&lt;/a&gt;. Included in the definition of &quot;column constraints&quot; for the purposes of the previous statement are the COLLATE and DEFAULT clauses, even though these are not really constraints in the sense that they do not restrict the data that the table may contain. The other constraints - NOT NULL, CHECK, UNIQUE, PRIMARY KEY and FOREIGN KEY constraints - impose restrictions on the table data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="318eb4656e47b06b6ea5260cd43d217bcb29a47f" translate="yes" xml:space="preserve">
          <source>Unless it is a CREATE TABLE ... AS SELECT statement, a CREATE TABLE includes one or more &lt;a href=&quot;syntax/column-def&quot;&gt;column definitions&lt;/a&gt;, optionally followed by a list of &lt;a href=&quot;syntax/table-constraint&quot;&gt;table constraints&lt;/a&gt;. Each column definition consists of the name of the column, optionally followed by the declared type of the column, then one or more optional &lt;a href=&quot;syntax/column-constraint&quot;&gt;column constraints&lt;/a&gt;. Included in the definition of &quot;column constraints&quot; for the purposes of the previous statement are the COLLATE and DEFAULT clauses, even though these are not really constraints in the sense that they do not restrict the data that the table may contain. The other constraints - NOT NULL, CHECK, UNIQUE, PRIMARY KEY and FOREIGN KEY constraints - impose restrictions on the tables data, and are are described under &lt;a href=&quot;lang_createtable#constraints&quot;&gt;SQL Data Constraints&lt;/a&gt; below.</source>
          <target state="translated">除非它是CREATE TABLE ... AS SELECT语句，否则CREATE TABLE包含一个或多个&lt;a href=&quot;syntax/column-def&quot;&gt;列定义&lt;/a&gt;，并可选地后面跟&lt;a href=&quot;syntax/table-constraint&quot;&gt;表约束&lt;/a&gt;列表。每个列定义都由列名组成，可选地，其后跟列的声明类型，然后是一个或多个可选&lt;a href=&quot;syntax/column-constraint&quot;&gt;列约束&lt;/a&gt;。就上一条语句而言，&amp;ldquo;列约束&amp;rdquo;的定义中包括COLLATE和DEFAULT子句，即使这些并不是真正的约束，因为它们并不限制表可能包含的数据。其他约束-NOT NULL，CHECK，UNIQUE，PRIMARY KEY和FOREIGN KEY约束-限制表数据，在&lt;a href=&quot;lang_createtable#constraints&quot;&gt;SQL数据约束&lt;/a&gt;下进行介绍 下面。</target>
        </trans-unit>
        <trans-unit id="1c00ba237aa117de710c9323f816c96f6ada7a01" translate="yes" xml:space="preserve">
          <source>Unless it returns SQLITE_MISUSE, the sqlite3_wal_checkpoint_v2() interface sets the error information that is queried by &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">除非返回SQLITE_MISUSE，否则sqlite3_wal_checkpoint_v2（）接口将设置由&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;查询的错误信息。</target>
        </trans-unit>
        <trans-unit id="4e06b73ee3affa8214cc1405f997b2bb6e5fc2af" translate="yes" xml:space="preserve">
          <source>Unless it returns SQLITE_MISUSE, the sqlite3_wal_checkpoint_v2() interface sets the error information that is queried by &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">除非返回SQLITE_MISUSE，否则sqlite3_wal_checkpoint_v2（）接口将设置由&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;和&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;查询的错误信息。</target>
        </trans-unit>
        <trans-unit id="4591266e2017f729f7aff5d0aced794f6644a4c3" translate="yes" xml:space="preserve">
          <source>Unless it returns SQLITE_MISUSE, this function sets the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">除非返回SQLITE_MISUSE，否则此函数设置可通过&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;及相关函数访问的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;错误代码和消息。</target>
        </trans-unit>
        <trans-unit id="0e4971f6a57c5c65a9a1ae31e9cf2a3e92d4934e" translate="yes" xml:space="preserve">
          <source>Unless it returns SQLITE_MISUSE, this function sets the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">除非返回SQLITE_MISUSE，否则此函数设置可通过&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;和&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;及相关函数访问的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;错误代码和消息。</target>
        </trans-unit>
        <trans-unit id="b37e8216d0e44ec2efee716d4c9dd7d3e0183bf7" translate="yes" xml:space="preserve">
          <source>Unless the &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt; is applied, if a subquery appears in the FROM clause of a SELECT statement, SQLite can either run the subquery and stores the results in a temporary table, or it can run the subquery as a co-routine. The following query is an example of the latter. The subquery is run by a co-routine. The outer query blocks whenever it needs another row of input from the subquery. Control switches to the co-routine which produces the desired output row, then control switches back to the main routine which continues processing.</source>
          <target state="translated">除非应用&lt;a href=&quot;optoverview#flattening&quot;&gt;扁平化优化&lt;/a&gt;，否则如果子查询出现在SELECT语句的FROM子句中，则SQLite可以运行子查询并将结果存储在临时表中，也可以将子查询作为协同例程运行。以下查询是后者的示例。子查询由协同例程运行。每当外部查询需要子查询的另一行输入时，外部查询就会阻塞。控制权切换到产生所需输出行的协同程序，然后控制权切换回到继续处理的主程序。</target>
        </trans-unit>
        <trans-unit id="6debb16b797e55251f765dccb022c7b2f7c44222" translate="yes" xml:space="preserve">
          <source>Unlike most SQL databases, SQLite does not restrict the type of data that may be inserted into a column based on the columns declared type. Instead, SQLite uses &lt;a href=&quot;datatype3&quot;&gt;dynamic typing&lt;/a&gt;. The declared type of a column is used to determine the &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; of the column only.</source>
          <target state="translated">与大多数SQL数据库不同，SQLite并不基于声明的列类型限制可以插入到列中的数据类型。相反，SQLite使用&lt;a href=&quot;datatype3&quot;&gt;动态类型&lt;/a&gt;。列的声明类型仅用于确定列的&lt;a href=&quot;datatype3#affinity&quot;&gt;亲和力&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8fc35fdda18e32589afbc6422311960ed986aa1d" translate="yes" xml:space="preserve">
          <source>Unlike most other SQL implementations, SQLite does not have a separate BOOLEAN data type. Instead, TRUE and FALSE are (normally) represented as integers 1 and 0, respectively. This does not seem to cause many problems, as we seldom get complaints about it. But it is important to recognize.</source>
          <target state="translated">与大多数其他SQL实现不同,SQLite没有单独的BOOLEAN数据类型。相反,TRUE和FALSE(通常)分别表示为整数1和0。这似乎不会引起很多问题,因为我们很少收到关于它的投诉。但认识到这一点很重要。</target>
        </trans-unit>
        <trans-unit id="19f905f254ee85ddda7a69f550a125cf0e71bdf9" translate="yes" xml:space="preserve">
          <source>Unlike option values and column names, SQL text literals intended as tokenizers must be quoted using single quote characters. For example:</source>
          <target state="translated">与选项值和列名不同,作为标记符的SQL文本字元必须使用单引号字符进行引用。例如</target>
        </trans-unit>
        <trans-unit id="4a575ebe60947d8ad09098452667c713c7ab1bb2" translate="yes" xml:space="preserve">
          <source>Unlike ordinary functions, window functions cannot use the DISTINCT keyword. Also, Window functions may only appear in the result set and in the ORDER BY clause of a SELECT statement.</source>
          <target state="translated">与普通函数不同,窗口函数不能使用DISTINCT关键字。另外,窗口函数只能出现在结果集和SELECT语句的ORDER BY子句中。</target>
        </trans-unit>
        <trans-unit id="2f67d962c33cac256671fd15a0b1070b30d60167" translate="yes" xml:space="preserve">
          <source>Unlike other OMIT options which make the SQLite library smaller, this option actually increases the size of SQLite and makes it run a little slower. Only use this option if SQLite is being built for an embedded target that does not support WSD.</source>
          <target state="translated">与其他OMIT选项使SQLite库变小不同,这个选项实际上增加了SQLite的大小,使其运行速度更慢一些。只有在为不支持 WSD 的嵌入式目标构建 SQLite 时才使用此选项。</target>
        </trans-unit>
        <trans-unit id="0fc95e0cae6fea6934c86fc94073155aecd6590f" translate="yes" xml:space="preserve">
          <source>Unlike the other journaling modes, &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=WAL&lt;/a&gt; is persistent. If a process sets WAL mode, then closes and reopens the database, the database will come back in WAL mode. In contrast, if a process sets (for example) PRAGMA journal_mode=TRUNCATE and then closes and reopens the database will come back up in the default rollback mode of DELETE rather than the previous TRUNCATE setting.</source>
          <target state="translated">与其他&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;日记&lt;/a&gt;记录模式不同，PRAGMA journal_mode = WAL是持久性的。如果进程设置了WAL模式，然后关闭并重新打开数据库，则数据库将恢复为WAL模式。相反，如果某个进程设置（例如）PRAGMA journal_mode = TRUNCATE，然后关闭然后重新打开，则数据库将以默认的DELETE回滚模式而不是先前的TRUNCATE设置恢复。</target>
        </trans-unit>
        <trans-unit id="3542ed2ff90a29869b311f3e2e4680675b20b4a0" translate="yes" xml:space="preserve">
          <source>Unlike the rollback journals, the master journal does not contain any original database page content. Instead, the master journal contains the full pathnames for rollback journals for every database that is participating in the transaction.</source>
          <target state="translated">与回滚日志不同,主日志不包含任何原始数据库页面内容,而是包含参与事务的每个数据库的回滚日志的完整路径名。相反,主日志包含参与事务的每个数据库的回滚日志的完整路径名。</target>
        </trans-unit>
        <trans-unit id="3dcad4a4f47bac4601655442badbb882f7ce80cb" translate="yes" xml:space="preserve">
          <source>Unlike the rollback journals, the super-journal does not contain any original database page content. Instead, the super-journal contains the full pathnames for rollback journals for every database that is participating in the transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02b418069c25f685f24a747aa6e2e42a4b27661e" translate="yes" xml:space="preserve">
          <source>Unlike the xFilter argument, xConflict may not be passed NULL. The results of passing anything other than a valid function pointer as the xConflict argument are undefined.</source>
          <target state="translated">与xFilter参数不同的是,xConflict不能被传递为NULL。除了有效的函数指针之外,传递任何其他参数作为xConflict参数的结果都是未定义的。</target>
        </trans-unit>
        <trans-unit id="8cc38ff6e04932db1753dbe47e43a46b66cca7d3" translate="yes" xml:space="preserve">
          <source>Unlinked database files</source>
          <target state="translated">未链接的数据库文件</target>
        </trans-unit>
        <trans-unit id="2e66bd886206de5f2b17ce23c8df1ed8d25d65b5" translate="yes" xml:space="preserve">
          <source>Unlock Notification</source>
          <target state="translated">解锁通知</target>
        </trans-unit>
        <trans-unit id="1129dcb047456b603be7d9e26492484e1ef87d61" translate="yes" xml:space="preserve">
          <source>Unlock the btree to which cursor P1 is pointing so that it can be written by other cursors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc88710cf7a309e590112924b4f0f18efd64749f" translate="yes" xml:space="preserve">
          <source>Unnecessary OP_IsNull, OP_Affinity, and OP_MustBeInt VDBE opcodes are suppressed</source>
          <target state="translated">抑制不必要的OP_IsNull、OP_Affinity和OP_MustBeInt VDBE操作码。</target>
        </trans-unit>
        <trans-unit id="b028e3e382d48044cb8ac6852f58d5f9280df947" translate="yes" xml:space="preserve">
          <source>Unpinning a database page.</source>
          <target state="translated">解除对数据库页面的锁定。</target>
        </trans-unit>
        <trans-unit id="4d158e591edd9ba39fa4326da9d09c5874218ca5" translate="yes" xml:space="preserve">
          <source>Unregister a VFS with the sqlite3_vfs_unregister() interface. If the default VFS is unregistered, another VFS is chosen as the default. The choice for the new VFS is arbitrary.</source>
          <target state="translated">用sqlite3_vfs_unregister()接口取消注册一个VFS。如果默认的VFS被取消注册,那么会选择另一个VFS作为默认值。新VFS的选择是任意的。</target>
        </trans-unit>
        <trans-unit id="ef3bbadff8cc850c1a14d5bac3c132d39dd7aef1" translate="yes" xml:space="preserve">
          <source>Unsigned integer counter, incremented with each transaction</source>
          <target state="translated">无符号整数,每次交易时递增。</target>
        </trans-unit>
        <trans-unit id="3c2ab651c10dcd781af9d81861dc05c7e00cd0e4" translate="yes" xml:space="preserve">
          <source>Unused bytes of on the current page or btree</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ae451c5b9e60f30746c607b23e33192b93fe52d" translate="yes" xml:space="preserve">
          <source>Unused padding space. Must be zero.</source>
          <target state="translated">未使用的填充空间。必须为零。</target>
        </trans-unit>
        <trans-unit id="e3a057d9b649ee6d00a614b6de91fb18fda426f0" translate="yes" xml:space="preserve">
          <source>Unused pages in the database file are stored on a freelist. The 4-byte big-endian integer at offset 32 stores the page number of the first page of the freelist, or zero if the freelist is empty. The 4-byte big-endian integer at offset 36 stores stores the total number of pages on the freelist.</source>
          <target state="translated">数据库文件中未使用的页面被存储在自由列表中。位于偏移量32的4字节大整数,存储自由列表第一页的页码,如果自由列表为空,则存储0。偏移量36处的4字节大恩迪安整数存储了自由列表的总页数。</target>
        </trans-unit>
        <trans-unit id="533ec3a09a391d616af998c213244ec0a1e5a3cc" translate="yes" xml:space="preserve">
          <source>Unused space reserved for further expansion.</source>
          <target state="translated">为进一步扩展而保留的未使用空间。</target>
        </trans-unit>
        <trans-unit id="c494dd09b1047ff61f225fbdc40bf010e62739a8" translate="yes" xml:space="preserve">
          <source>Unused space set aside for 8 file locks.</source>
          <target state="translated">预留8个文件锁的未使用空间。</target>
        </trans-unit>
        <trans-unit id="6ccb1ae240f52b5b4ac6a0a3624ae84ecc9e72d1" translate="yes" xml:space="preserve">
          <source>Up to 32K columns in a table and unlimited rows</source>
          <target state="translated">在一个表格中最多可以有32K列,并且不限行数</target>
        </trans-unit>
        <trans-unit id="6b12c595d758d017b4f8b2df393f1e4bc59a0386" translate="yes" xml:space="preserve">
          <source>Up to 64-way joins</source>
          <target state="translated">最多64路连接</target>
        </trans-unit>
        <trans-unit id="cb305c54c2dd32659178ffaaae86eb202de286b0" translate="yes" xml:space="preserve">
          <source>Upcoming maintenance releases announced on the sqlite-users and sqlite-dev &lt;a href=&quot;https://sqlite.org/support.html#mailinglists&quot;&gt;mailing lists&lt;/a&gt; about two weeks prior to the anticipated release. Approximately one week prior to release, the lead developer declares &quot;pencils down&quot; after which only bug-fix check-ins are allowed on trunk. A new &lt;a href=&quot;https://sqlite.org/checklists&quot;&gt;release checklist&lt;/a&gt; is created and updated as needed. As items of the checklist are verified, they are checked off and turn green. The release occurs when all elements of the checklist are green. That process normally takes about a week.</source>
          <target state="translated">在sqlite-users和sqlite-dev &lt;a href=&quot;https://sqlite.org/support.html#mailinglists&quot;&gt;邮件列表中&lt;/a&gt;宣布的即将发布的维护版本比预期版本提前约两周。大约在发布前一周，主要开发人员宣布&amp;ldquo;关闭铅笔&amp;rdquo;，之后仅允许在主干上进行错误修复检入。将创建一个新的&lt;a href=&quot;https://sqlite.org/checklists&quot;&gt;发行清单&lt;/a&gt;，并根据需要进行更新。核对清单中的项目后，将其选中并变为绿色。当清单的所有元素均为绿色时，将发生释放。该过程通常需要大约一周的时间。</target>
        </trans-unit>
        <trans-unit id="8621615ea5e13954070618a81964dc62abe12dff" translate="yes" xml:space="preserve">
          <source>Update 2003-07-13:</source>
          <target state="translated">2003-07-13更新。</target>
        </trans-unit>
        <trans-unit id="e6d951c5abc007e402d1496a11b3024eba850b99" translate="yes" xml:space="preserve">
          <source>Update cygwin interfaces to omit deprecated API calls.</source>
          <target state="translated">更新cygwin接口,以省略过时的API调用。</target>
        </trans-unit>
        <trans-unit id="f8692a500a2140ecfbdf4ae0b2b2fa362f3e4d18" translate="yes" xml:space="preserve">
          <source>Update on 2018-11-24: This section was important when the NGQP was new. But five years have elapsed, the NGQP has been deployed successfully to billions of devices, and everyone has upgraded. The upgrade hazard has vanished. This section is retained for historical reference only. Modern reads can skip ahead to the &lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;query planner checklist&lt;/a&gt;.</source>
          <target state="translated">2018年11月24日更新：当NGQP是新的时，此部分很重要。但是五年过去了，NGQP已成功部署到数十亿台设备，并且每个人都进行了升级。升级的危险已消失。本节保留，仅供历史参考。现代读物可以跳到&lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;查询计划器清单&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f7a5f87f2cf88e6e7e5e6ca7b270c03397b5d3d9" translate="yes" xml:space="preserve">
          <source>Update or delete the row in the parent table,</source>
          <target state="translated">更新或删除父表中的行。</target>
        </trans-unit>
        <trans-unit id="eadf20cb1fcf64b516be4d0e9aca0f806ea0946c" translate="yes" xml:space="preserve">
          <source>Update the &quot;.import&quot; command in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; to support multi-line fields and correct RFC-4180 quoting and to issue warning and/or error messages if the input text is not strictly RFC-4180 compliant.</source>
          <target state="translated">如果输入文本不严格符合RFC-4180 ，请在&lt;a href=&quot;cli&quot;&gt;命令行外壳中&lt;/a&gt;更新&amp;ldquo; .import&amp;rdquo;命令以支持多行字段并更正RFC-4180引用，并发出警告和/或错误消息。</target>
        </trans-unit>
        <trans-unit id="95e555f2b3f8baa46d6d1c3fa11a385e51f02eb2" translate="yes" xml:space="preserve">
          <source>Update the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; to make use of the enhanced virtual table interface.</source>
          <target state="translated">更新&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展&lt;/a&gt;以利用增强的虚拟表界面。</target>
        </trans-unit>
        <trans-unit id="afd4ef5f9984771affe8a02ef21dc1f52c746e3a" translate="yes" xml:space="preserve">
          <source>Update the NULL-handling documentation.</source>
          <target state="translated">更新NULL处理文档。</target>
        </trans-unit>
        <trans-unit id="8eb7bca41bb60469d609f31a7c94a8af987dd0b7" translate="yes" xml:space="preserve">
          <source>Update the _FILE_OFFSET_BITS macro so that builds work again on QNX.</source>
          <target state="translated">更新 _FILE_OFFSET_BITS 宏,以便在 QNX 上重新构建。</target>
        </trans-unit>
        <trans-unit id="83db802c5575f2f5c375cb1b62089d3a370412c6" translate="yes" xml:space="preserve">
          <source>Update the banner on the command-line shell to alert novice users when they are using an ephemeral in-memory database.</source>
          <target state="translated">更新命令行shell上的横幅,以提醒新手用户在使用短暂的内存数据库时。</target>
        </trans-unit>
        <trans-unit id="5deccb253aff130770ec3068052cf362ce9ebe27" translate="yes" xml:space="preserve">
          <source>Update the built-in &lt;a href=&quot;fts3&quot;&gt;FTS3/FTS4&lt;/a&gt; and &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; virtual tables to support &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clauses and &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt;.</source>
          <target state="translated">更新内置的&lt;a href=&quot;fts3&quot;&gt;FTS3 / FTS4&lt;/a&gt;和&lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;虚拟表以支持&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;子句和&lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b504122b8dfef94ab33eb2666fd1889d16053291" translate="yes" xml:space="preserve">
          <source>Update the text of error messages returned by &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; for some error codes.</source>
          <target state="translated">将&lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;返回的错误消息文本更新为一些错误代码。</target>
        </trans-unit>
        <trans-unit id="f19ef97f712dc9336cd9881c1cc678760d93cdf8" translate="yes" xml:space="preserve">
          <source>Update: As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;version 3.29.0&lt;/a&gt; (2019-07-10) the use of AFL has been superceded by the new &lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz&lt;/a&gt; fuzzer described below.</source>
          <target state="translated">更新：从SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;3.29.0版&lt;/a&gt;（2019-07-10）开始，AFL的使用已被下面所述的新&lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz模糊&lt;/a&gt;器取代。</target>
        </trans-unit>
        <trans-unit id="c202e0c1d72e2322ab1803ee32b5877979d2de60" translate="yes" xml:space="preserve">
          <source>Update: New measurements for SQLite version 3.19.0 (2017-05-22) show that SQLite is about &lt;a href=&quot;fasterthanfs&quot;&gt;35% faster&lt;/a&gt; than direct disk I/O for both reads and writes of 10KB blobs.</source>
          <target state="translated">更新：SQLite 3.19.0版（2017-05-22）的新测量表明，对于10KB Blob的读取和写入，SQLite 比直接磁盘I / O &lt;a href=&quot;fasterthanfs&quot;&gt;快35％&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a960dbfb2b124d6ed06bf7e934a25380bb894d60" translate="yes" xml:space="preserve">
          <source>Update: The &lt;a href=&quot;lang_vacuum#vacuuminto&quot;&gt;VACUUM INTO&lt;/a&gt; command introduced in SQLite version 3.27.0 (2019-02-07) can serve as an alternative to the backup API.</source>
          <target state="translated">更新：SQLite版本3.27.0（2019-02-07）中引入的&lt;a href=&quot;lang_vacuum#vacuuminto&quot;&gt;VACUUM INTO&lt;/a&gt;命令可以替代备份API。</target>
        </trans-unit>
        <trans-unit id="ae9f91d2ff06391addf58fdcc8dd4af3777ab8ac" translate="yes" xml:space="preserve">
          <source>Updated the &quot;unix-dotfile&quot; &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to use locking directories with mkdir() and rmdir() instead of locking files with open() and unlink().</source>
          <target state="translated">更新了&amp;ldquo; unix-dotfile&amp;rdquo; &lt;a href=&quot;vfs&quot;&gt;VFS，&lt;/a&gt;以使用带有mkdir（）和rmdir（）的锁定目录，而不是带有open（）和unlink（）的锁定文件。</target>
        </trans-unit>
        <trans-unit id="9ecd4cacc54f9eb845eb05b8c1cec0b8deaabeb2" translate="yes" xml:space="preserve">
          <source>Updated the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; so that it can be built using &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt; and &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;.</source>
          <target state="translated">更新了&lt;a href=&quot;cli&quot;&gt;命令行外壳程序，&lt;/a&gt;以便可以使用&lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;和&lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;进行构建。</target>
        </trans-unit>
        <trans-unit id="ae68475963e11d8ffb9d1743f7f05f6343c16e81" translate="yes" xml:space="preserve">
          <source>Updated the &lt;a href=&quot;nulls&quot;&gt;NULL-handling document&lt;/a&gt;.</source>
          <target state="translated">更新了&lt;a href=&quot;nulls&quot;&gt;NULL处理文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2cc8e0782c7a9b456827f5ac2f3deff6afb93a61" translate="yes" xml:space="preserve">
          <source>Updated the documentation for due to the above change.</source>
          <target state="translated">由于上述变化,更新了文件。</target>
        </trans-unit>
        <trans-unit id="e10ae62e4bb036329cb9ea0d831ba16069afdf6b" translate="yes" xml:space="preserve">
          <source>Updates to &lt;a href=&quot;c3ref/stmt_readonly&quot;&gt;sqlite3_stmt_readonly()&lt;/a&gt; so that its result is well-defined for all prepared statements and so that it works with &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;.</source>
          <target state="translated">更新为&lt;a href=&quot;c3ref/stmt_readonly&quot;&gt;sqlite3_stmt_readonly（），&lt;/a&gt;以便为所有准备好的语句明确定义其结果，并使其与&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM一起使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="611a149936e51e86e5dc517a30918e94113a5c96" translate="yes" xml:space="preserve">
          <source>Updates to comments and documentation.</source>
          <target state="translated">更新评论和文件。</target>
        </trans-unit>
        <trans-unit id="5cd9f8d0a6523c89d101b12728ca830f506daa93" translate="yes" xml:space="preserve">
          <source>Updates to the FAQ</source>
          <target state="translated">更新常见问题</target>
        </trans-unit>
        <trans-unit id="225b3af8e67127ee3d34043567f27a4b206ed152" translate="yes" xml:space="preserve">
          <source>Updates to the co-hosted &lt;a href=&quot;lemon&quot;&gt;Lemon LALR(1) parser generator&lt;/a&gt;. (These updates did not affect SQLite.)</source>
          <target state="translated">更新到共同托管的&lt;a href=&quot;lemon&quot;&gt;Lemon LALR（1）解析器生成器&lt;/a&gt;。（这些更新不影响SQLite。）</target>
        </trans-unit>
        <trans-unit id="5ff086f286850610a359720beb1814b02bde490c" translate="yes" xml:space="preserve">
          <source>Updates to the man page</source>
          <target state="translated">更新手册页面</target>
        </trans-unit>
        <trans-unit id="0b579189066ad6233ab9a30e75015931b715153e" translate="yes" xml:space="preserve">
          <source>Upgrade to an</source>
          <target state="translated">升级为</target>
        </trans-unit>
        <trans-unit id="fa23bdbf593290f21c99984edfe7206d0b3f48ab" translate="yes" xml:space="preserve">
          <source>Upgraded the &lt;a href=&quot;c3ref/uri_boolean&quot;&gt;sqlite3_uri_parameter()&lt;/a&gt; function so that it works with the rollback journal or WAL filename in addition to the database filename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54e621618c30d2d51e0e7eb2f7c9980b70d460c6" translate="yes" xml:space="preserve">
          <source>Upgrading SQLite, Backwards Compatibility</source>
          <target state="translated">升级SQLite,向下兼容</target>
        </trans-unit>
        <trans-unit id="f63424e9ccf9758aa115a08c1ca29da89505f175" translate="yes" xml:space="preserve">
          <source>Upgrading to an Exclusive Lock</source>
          <target state="translated">升级到专属锁</target>
        </trans-unit>
        <trans-unit id="0b7b831bc0dc4db0969e61d108d5ed08e60a2a5a" translate="yes" xml:space="preserve">
          <source>Usable size</source>
          <target state="translated">可用尺寸</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="f7d660e7e185b02ed0b42d1ed9b98bb6209a9521" translate="yes" xml:space="preserve">
          <source>Use &quot;&lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt;&quot; at the top of your source code files instead of &quot;&lt;code&gt;#include &amp;lt;sqlite3.h&amp;gt;&lt;/code&gt;&quot;.</source>
          <target state="translated">在源代码文件的顶部使用&amp;ldquo; &lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt; &amp;rdquo;，而不是&amp;ldquo; &lt;code&gt;#include &amp;lt;sqlite3.h&amp;gt;&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="62e753b43ef69616b1563515522f39fb45747e31" translate="yes" xml:space="preserve">
          <source>Use &quot;trunk&quot; for</source>
          <target state="translated">用 &quot;树干 &quot;表示</target>
        </trans-unit>
        <trans-unit id="237aa140efed61c820a219860ca38adb64fb7ec3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;lang_corefunc#replace&quot;&gt;replace()&lt;/a&gt; instead of &lt;a href=&quot;lang_corefunc#char&quot;&gt;char()&lt;/a&gt; for escaping newline and carriage-return characters embedded in strings in the .dump output from the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;lang_corefunc#replace&quot;&gt;replace（）&lt;/a&gt;代替&lt;a href=&quot;lang_corefunc#char&quot;&gt;char（）&lt;/a&gt;来转义嵌入在&lt;a href=&quot;cli&quot;&gt;命令行shell&lt;/a&gt; .dump输出中字符串中的换行符和回车符。</target>
        </trans-unit>
        <trans-unit id="c7a8d415f6b6311567858afd10504aff2606d36c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;, and &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; to reconstruct indexes, triggers, and views associated with table X. Perhaps use the old format of the triggers, indexes, and views saved from step 3 above as a guide, making changes as appropriate for the alteration.</source>
          <target state="translated">使用&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;，&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;和&lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;来重建与表X关联的索引，触发器和视图。也许可以使用上面第3步中保存的触发器，索引和视图的旧格式作为指导，进行相应的更改改变。</target>
        </trans-unit>
        <trans-unit id="536befb3634409293843309bd592f3735064b803" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; to construct a new table &quot;new_X&quot; that is in the desired revised format of table X. Make sure that the name &quot;new_X&quot; does not collide with any existing table name, of course.</source>
          <target state="translated">使用&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;构造一个新的表&amp;ldquo; new_X&amp;rdquo;，该表具有表X的所需修订格式。当然，请确保名称&amp;ldquo; new_X&amp;rdquo;不与任何现有表名冲突。</target>
        </trans-unit>
        <trans-unit id="4324752dc06a9ac4571627fdbc5052d079c7ceec" translate="yes" xml:space="preserve">
          <source>Use a &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement to create a new index on one or more expressions just like you would to create an index on columns. The only difference is that expressions are listed as the elements to be indexed rather than column names.</source>
          <target state="translated">使用&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;语句在一个或多个表达式上创建新索引，就像在列上创建索引一样。唯一的区别是表达式被列为要索引的元素，而不是列名。</target>
        </trans-unit>
        <trans-unit id="7496f7181dc9302ddc248c78082db1a132361364" translate="yes" xml:space="preserve">
          <source>Use a negative column width for right-justified columns.</source>
          <target state="translated">对右对齐的列使用负列宽。</target>
        </trans-unit>
        <trans-unit id="5ed5b81249d213d275afc651f4e6fd002e1e541a" translate="yes" xml:space="preserve">
          <source>Use a separate mutex on every inode in the unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;, rather than a single mutex shared among them all, for slightly better concurrency in multi-threaded environments.</source>
          <target state="translated">在unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;中的每个索引节点上使用单独的互斥锁，而不是在它们之间共享一个互斥锁，以便在多线程环境中更好地并发。</target>
        </trans-unit>
        <trans-unit id="de146a75582fa0d61aaa74e50c8ce2d58d1921c8" translate="yes" xml:space="preserve">
          <source>Use an index to satisfy an IS NULL operator in the WHERE clause</source>
          <target state="translated">在WHERE子句中使用索引来满足IS NULL操作符。</target>
        </trans-unit>
        <trans-unit id="6bdba762bb27236a6cb868fd917b885a3fb66243" translate="yes" xml:space="preserve">
          <source>Use compiler built-ins __builtin_sub_overflow(), __builtin_add_overflow(), and __builtin_mul_overflow() when available. (All compiler built-ins can be omitted with the &lt;a href=&quot;compile#disable_intrinsic&quot;&gt;SQLITE_DISABLE_INTRINSIC&lt;/a&gt; compile-time option.)</source>
          <target state="translated">使用编译器内置的__builtin_sub_overflow（），__ builtin_add_overflow（）和__builtin_mul_overflow（）。（可使用&lt;a href=&quot;compile#disable_intrinsic&quot;&gt;SQLITE_DISABLE_INTRINSIC&lt;/a&gt;编译时选项忽略所有编译器内置函数。）</target>
        </trans-unit>
        <trans-unit id="137cf73aa42452fce0415a41813408b4501767a7" translate="yes" xml:space="preserve">
          <source>Use either disk or memory storage for temporary files as determined by the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="translated">使用&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;编译时参数确定的临时文件使用磁盘或内存存储。</target>
        </trans-unit>
        <trans-unit id="2af669874066cde2346e922c573e9e835ac690a1" translate="yes" xml:space="preserve">
          <source>Use fdatasync() instead of fsync() where possible in order to speed up commits slightly</source>
          <target state="translated">尽可能使用fdatasync()代替fsync(),以稍微加快提交速度。</target>
        </trans-unit>
        <trans-unit id="50f06d5432236287d8673fac9ba31c9f7a72e979" translate="yes" xml:space="preserve">
          <source>Use files by default but allow the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;PRAGMA temp_store&lt;/a&gt; command to override</source>
          <target state="translated">默认情况下使用文件，但允许&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;PRAGMA temp_store&lt;/a&gt;命令覆盖</target>
        </trans-unit>
        <trans-unit id="263a25f617f6abfd3d532ea4693a64ebfdbddfbe" translate="yes" xml:space="preserve">
          <source>Use heap space instead of stack space for large buffers in the pager - useful on embedded platforms with stack-space limitations.</source>
          <target state="translated">对寻呼机中的大缓冲区使用堆空间而不是栈空间--在有栈空间限制的嵌入式平台上很有用。</target>
        </trans-unit>
        <trans-unit id="3a48cc9a1a2d824c57ec5e25aeb6cff31334d1e8" translate="yes" xml:space="preserve">
          <source>Use indices to help with GLOB expressions and LIKE expressions too when the case_sensitive_like pragma is enabled</source>
          <target state="translated">当启用case_sensitive_like pragma时,使用索引来帮助GLOB表达式和LIKE表达式。</target>
        </trans-unit>
        <trans-unit id="bc1fcae1e921cce9fd520fbec66677338b3c72ed" translate="yes" xml:space="preserve">
          <source>Use less memory by not remembering CHECK constraints on read-only database connections.</source>
          <target state="translated">通过不记忆只读数据库连接上的CHECK约束,使用更少的内存。</target>
        </trans-unit>
        <trans-unit id="0f855b65765fc8c17befd3c681198b2b5b5c7616" translate="yes" xml:space="preserve">
          <source>Use memmove() instead of memcpy() when moving between memory regions that might overlap. Ticket #2334</source>
          <target state="translated">在可能重叠的内存区域之间移动时,使用 memmove()而不是 memcpy()。Ticket #2334</target>
        </trans-unit>
        <trans-unit id="469854fc5e213a56cb9e96864bf70b794360aa2e" translate="yes" xml:space="preserve">
          <source>Use memory by default but allow the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;PRAGMA temp_store&lt;/a&gt; command to override</source>
          <target state="translated">默认情况下使用内存，但允许&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;PRAGMA temp_store&lt;/a&gt;命令覆盖</target>
        </trans-unit>
        <trans-unit id="48a8e3645a8edde160a5adbd651d1d588f3d82af" translate="yes" xml:space="preserve">
          <source>Use of the CROSS keyword in a join turns off the table reordering optimization</source>
          <target state="translated">在连接中使用CROSS关键字会关闭表的重新排序优化。</target>
        </trans-unit>
        <trans-unit id="4efb979f35de88aa03beb8b52191a1054ccebd97" translate="yes" xml:space="preserve">
          <source>Use single-quotes, not double-quotes, around string literals in SQL. This is what the SQL standard requires. Your WHERE clause expression should read: &lt;code&gt;column1='column1'&lt;/code&gt;</source>
          <target state="translated">在SQL的字符串文字中使用单引号而不是双引号。这就是SQL标准的要求。您的WHERE子句表达式应显示为： &lt;code&gt;column1='column1'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc43b1a2c6a31ffdd8561f57d1fbf734126319be" translate="yes" xml:space="preserve">
          <source>Use sqlite3_mprintf() instead of strdup() to avoid libc dependencies</source>
          <target state="translated">使用sqlite3_mprintf()代替strdup()来避免libc依赖性。</target>
        </trans-unit>
        <trans-unit id="b154d5767d626fe947b811cbac8223761d775253" translate="yes" xml:space="preserve">
          <source>Use the &quot;.dump&quot; command to convert the entire contents of a database into a single ASCII text file. This file can be converted back into a database by piping it back into &lt;b&gt;sqlite3&lt;/b&gt;.</source>
          <target state="translated">使用&amp;ldquo; .dump&amp;rdquo;命令将数据库的全部内容转换为单个ASCII文本文件。可以通过将其通过管道传输回&lt;b&gt;sqlite3&lt;/b&gt;来将其转换回数据库。</target>
        </trans-unit>
        <trans-unit id="031acdfcfcb7c6ac30666a1a6360f5fb4b5b9407" translate="yes" xml:space="preserve">
          <source>Use the &quot;.import&quot; command to import CSV (comma separated value) data into an SQLite table. The &quot;.import&quot; command takes two arguments which are the name of the disk file from which CSV data is to be read and the name of the SQLite table into which the CSV data is to be inserted.</source>
          <target state="translated">使用&quot;.import &quot;命令将CSV(逗号分隔值)数据导入到SQLite表中。&quot;.import &quot;命令有两个参数,分别是要读取CSV数据的磁盘文件的名称和要插入CSV数据的SQLite表的名称。</target>
        </trans-unit>
        <trans-unit id="1514a3f709961a8c5a81dddff2a1805d46c2a271" translate="yes" xml:space="preserve">
          <source>Use the &quot;.separator&quot; dot command to change the separator. For example, to change the separator to a comma and a space, you could do this:</source>
          <target state="translated">使用&quot;.separator &quot;点命令来改变分隔符。例如,要将分隔符改为逗号和空格,可以这样做。</target>
        </trans-unit>
        <trans-unit id="7e3a1db63b5ffcfa0304033285d6169940ca5e9f" translate="yes" xml:space="preserve">
          <source>Use the &quot;&lt;code&gt;fossil ui&lt;/code&gt;&quot; command from within the ~/sqlite checkout to bring up a local copy of the website.</source>
          <target state="translated">在〜/ sqlite结帐中，使用&amp;ldquo; &lt;code&gt;fossil ui&lt;/code&gt; &amp;rdquo;命令调出该网站的本地副本。</target>
        </trans-unit>
        <trans-unit id="2314ee65a646ac667a54b17ec0394586fd245f83" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface to determine the size of the opened blob. The size of a blob may not be changed by this interface. Use the &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; SQL command to change the size of a blob.</source>
          <target state="translated">使用&lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;接口确定打开的Blob的大小。此接口可能无法更改Blob的大小。使用&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; SQL命令更改Blob的大小。</target>
        </trans-unit>
        <trans-unit id="36f9cf35dec4a270350f0bd2263a94cc3699ef47" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface to determine the size of the opened blob. The size of a blob may not be changed by this interface. Use the &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; SQL command to change the size of a blob.</source>
          <target state="translated">使用&lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;接口确定打开的Blob的大小。此接口可能无法更改Blob的大小。使用&lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; SQL命令更改Blob的大小。</target>
        </trans-unit>
        <trans-unit id="bd4ed3d4650cd4e7bc264eb1acc9e459a702bd1f" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time parameter to selected the threading mode. If no &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time parameter is present, then serialized mode is used. This can be made explicit with &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=1&lt;/a&gt;. With &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=0&lt;/a&gt; the threading mode is single-thread. With &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=2&lt;/a&gt; the threading mode is multi-thread.</source>
          <target state="translated">使用&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt;编译时参数选择线程模式。如果不存在&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt;编译时参数，则使用序列化模式。可以使用&lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 1&lt;/a&gt;使其明确。使用&lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 0时&lt;/a&gt;，线程模式为单线程。使用&lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 2时&lt;/a&gt;，线程模式为多线程。</target>
        </trans-unit>
        <trans-unit id="274f4747a1320d774731188d128cb3683b032794" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt; even if the right-hand side string contains no wildcards.</source>
          <target state="translated">即使右侧字符串不包含通配符，也请使用&lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE优化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5308e85c61acbd7495be650845b12311f9dc3964" translate="yes" xml:space="preserve">
          <source>Use the &lt;b&gt;sqlite_open&lt;/b&gt; function to open an existing SQLite database or to create a new SQLite database. The first argument is the database name. The second argument is intended to signal whether the database is going to be used for reading and writing or just for reading. But in the current implementation, the second argument to &lt;b&gt;sqlite_open&lt;/b&gt; is ignored. The third argument is a pointer to a string pointer. If the third argument is not NULL and an error occurs while trying to open the database, then an error message will be written to memory obtained from malloc() and *errmsg will be made to point to this error message. The calling function is responsible for freeing the memory when it has finished with it.</source>
          <target state="translated">使用&lt;b&gt;sqlite_open&lt;/b&gt;函数打开现有的SQLite数据库或创建新的SQLite数据库。第一个参数是数据库名称。第二个参数旨在表明该数据库是用于读取还是写入还是仅用于读取。但是在当前实现中，忽略&lt;b&gt;sqlite_open&lt;/b&gt;的第二个参数。第三个参数是指向字符串指针的指针。如果第三个参数不为NULL，并且在尝试打开数据库时发生错误，则错误消息将写入从malloc（）获得的内存中，并将使* errmsg指向此错误消息。调用函数负责在完成处理后释放内存。</target>
        </trans-unit>
        <trans-unit id="c6d46e33d7807116ac9add91d72550fca2ffbf23" translate="yes" xml:space="preserve">
          <source>Use the WHERE clause to reduce the size of a materialized VIEW in an UPDATE or DELETE statement. (Optimization)</source>
          <target state="translated">在UPDATE或DELETE语句中,使用WHERE子句来缩小物化VIEW的大小。(优化)</target>
        </trans-unit>
        <trans-unit id="efe8cfb25313b8ffdcda22d1d22b3397432240d2" translate="yes" xml:space="preserve">
          <source>Use the correct affinity for columns of automatic indexes. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7ffd1ca1d2ad4ec&quot;&gt;7ffd1ca1d2ad4ec&lt;/a&gt;.</source>
          <target state="translated">对自动索引的列使用正确的相似性。票证&lt;a href=&quot;https://www.sqlite.org/src/info/7ffd1ca1d2ad4ec&quot;&gt;7ffd1ca1d2ad4ec&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f8484df7605c1331750609f898da67fe4dcaeabf" translate="yes" xml:space="preserve">
          <source>Use the macro SQLITE_PRIVATE (defaulting to &quot;static&quot;) on all internal functions in the amalgamation.</source>
          <target state="translated">在合并中的所有内部函数上使用宏SQLITE_PRIVATE(默认为 &quot;静态&quot;)。</target>
        </trans-unit>
        <trans-unit id="bc78bf67fa7d6c1c485c06940843c7741c22f19b" translate="yes" xml:space="preserve">
          <source>Use the new &lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; interface to improve the performance of FTS.</source>
          <target state="translated">使用新的&lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;接口来提高FTS的性能。</target>
        </trans-unit>
        <trans-unit id="3b2244da3774583cbb3fc1a48e72dfd44d3ab95d" translate="yes" xml:space="preserve">
          <source>Use the normal SQLite API to read and write to databases via the asynchronous IO VFS.</source>
          <target state="translated">使用普通的SQLite API通过异步IO VFS对数据库进行读写。</target>
        </trans-unit>
        <trans-unit id="26f92b5c0905f544db1bb7d8ca5ebd0ed63e16d8" translate="yes" xml:space="preserve">
          <source>Use the resulting &quot;kvtest&quot; program to generate a test database with 100,000 random uncompressible blobs, each with a random size between 8,000 and 12,000 bytes using a command like this:</source>
          <target state="translated">使用生成的 &quot;kvtest &quot;程序生成一个具有100,000个随机不可压缩的blobs的测试数据库,每个blobs的随机大小在8,000到12,000字节之间,使用这样的命令。</target>
        </trans-unit>
        <trans-unit id="7834abce7ece24f8701462e346703566e2de3e27" translate="yes" xml:space="preserve">
          <source>Use the schema-defined &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; instead of the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; to pair rows in the source and destination database. (See additional explanation below.)</source>
          <target state="translated">使用模式定义的&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY（&lt;/a&gt;而不是&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid）&lt;/a&gt;来配对源数据库和目标数据库中的行。（请参阅下面的其他说明。）</target>
        </trans-unit>
        <trans-unit id="02df1e951c416cb903ab43afc2694bfdea186be2" translate="yes" xml:space="preserve">
          <source>Use the strcspn() C-library routine to speed up the LIKE and GLOB operators.</source>
          <target state="translated">使用strcspn()C库例程来加快LIKE和GLOB运算符的速度。</target>
        </trans-unit>
        <trans-unit id="f1f443135d8d6987de124f0e64e3f9227d9a5c27" translate="yes" xml:space="preserve">
          <source>Use the transitive property to try to propagate constant values within the WHERE clause. For example, convert &quot;a=99 AND b=a&quot; into &quot;a=99 AND b=99&quot;.</source>
          <target state="translated">使用转置属性尝试在WHERE子句中传播常量值。例如,将 &quot;a=99 AND b=a &quot;转换为 &quot;a=99 AND b=99&quot;。</target>
        </trans-unit>
        <trans-unit id="0ea0700fa56071e98d4cc761a6e621b61eff1903" translate="yes" xml:space="preserve">
          <source>Use the unicode API in Windows</source>
          <target state="translated">在Windows中使用unicode API</target>
        </trans-unit>
        <trans-unit id="97776a8d79289b0d1017fb264bc954bd7ad83946" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#aggregate-function-invocation&quot;&gt;aggregate-function-invocation&lt;/a&gt;&lt;a href=&quot;#attach-stmt&quot;&gt;attach-stmt&lt;/a&gt;&lt;a href=&quot;#column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;#frame-spec&quot;&gt;frame-spec&lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;indexed-column&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#join-constraint&quot;&gt;join-constraint&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-function-invocation&quot;&gt;simple-function-invocation&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;#aggregate-function-invocation&quot;&gt;聚合函数调用&lt;/a&gt;&lt;a href=&quot;#attach-stmt&quot;&gt;attach-stmt &lt;/a&gt;&lt;a href=&quot;#column-constraint&quot;&gt;列约束&lt;/a&gt;&lt;a href=&quot;#compound-select-stmt&quot;&gt;复合选择stmt &lt;/a&gt;&lt;a href=&quot;#create-index-stmt&quot;&gt;创建索引index-mt &lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;触发触发器-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;删除stmt-有限因&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;式选择-stmt &lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;过滤器子句&lt;/a&gt;&lt;a href=&quot;#frame-spec&quot;&gt;框架规范&lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;索引-列&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;#join-constraint&quot;&gt;加入约束&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;排序项&lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;子句&lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;结果列&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;选择核心&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#simple-function-invocation&quot;&gt;简单函数调用&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt &lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;表约束&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;表或子查询&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-子句&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn &lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3cfe8ec4e623b595e4ac50171983c062621b492" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#aggregate-function-invocation&quot;&gt;aggregate-function-invocation&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;#aggregate-function-invocation&quot;&gt;聚合函数调用&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;窗口函数调用&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9fa16a928ddc1dc237caf8ee5a2f33829abb8c95" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#alter-table-stmt&quot;&gt;alter-table-stmt&lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#alter-table-stmt&quot;&gt;alter-table-stmt &lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;创建表-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7605fd600c574fecb47de09ab5decde53c108336" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#column-constraint&quot;&gt;column-constraint &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9d132b987e9571018a10419466ce9e4241f4144" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;#pragma-value&quot;&gt;pragma-value&lt;/a&gt;&lt;a href=&quot;#type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;#column-constraint&quot;&gt;列约束&lt;/a&gt;&lt;a href=&quot;#pragma-value&quot;&gt;编译指示值&lt;/a&gt;&lt;a href=&quot;#type-name&quot;&gt;类型名称&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6859f1dc44376fa95c8d38fdf3b6141e03d2c1ae" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;#column-constraint&quot;&gt;列约束&lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;表约束&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a380af02d8c9c93f329808cab4b27595f6a4a3c5" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d289a73c451effafc4667d2bf1f3b0e030afac60" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#column-def&quot;&gt;column-def &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a431a18a7738c53de3472c652954e2bc59958670" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;#create-view-stmt&quot;&gt;create-view-stmt&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt &lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;#create-view-stmt&quot;&gt;create-view-stmt &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;带子句的&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;表或子查询&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="224be4c1f3c548d22132987eb2bf278a86171468" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abb141b71ecdf70ef024445a846b6364ea02ee67" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;#compound-select-stmt&quot;&gt;复合选择stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;删除stmt限制&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;分解选择stmt &lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;子句&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select stmt &lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;简单选择stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;更新stmt受限&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ab6cea255f6025204d21b009964174b973b40cd6" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#compound-select-stmt&quot;&gt;复合选择stmt &lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;分解选择stmt &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;选择stmt &lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;简单选择stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9a35f3e8899c13b9a454dc09b2554a9fc11894f" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#compound-select-stmt&quot;&gt;复合选择stmt &lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;分解选择stmt &lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;简单选择stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56b558cf19b1f43efb09e7c3cf6f834bdf6f9e08" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt &lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;表约束&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ed338e20414f7c9ffcbc59e0281f80cccd5a763" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6b50a14ac773fa0a58261d63783e57e4cbe15c68" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed0705dac87c2b47586b5a816bab059a80c3dff1" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#delete-stmt&quot;&gt;使用者&lt;/a&gt;：delete-stmt &lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fed14e0505bafc78d4d9d690a2b7426f9c8198b2" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#delete-stmt&quot;&gt;用法&lt;/a&gt;：delete-stmt &lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a021ee5a9dccd79e0bc3acd62766c09cd9fb8cae" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="082ab3c78daf3f012c8a8cd5f4c53643a071209a" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09a6e3cc1f24c34ba4f2a0f20d3c51dbe35db3c3" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#insert-stmt&quot;&gt;使用者&lt;/a&gt;：insert-stmt</target>
        </trans-unit>
        <trans-unit id="97d8dfd0bb5c0f6552eb23078a3e1e860cc9a6c3" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed8783360dda42990afd13092353a2478b98c818" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c4cd678b8b993f3438c0117dedb1f0fd21e9e1b" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af677aaf273d3f1f76df6b503b77ba2fd60bed2" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">用于：&lt;a href=&quot;#over-clause&quot;&gt;子句&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8079f3adf01a444617315e6ee69c27b2f0e4367b" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#pragma-stmt&quot;&gt;pragma-stmt&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#pragma-stmt&quot;&gt;使用者&lt;/a&gt;：pragma-stmt</target>
        </trans-unit>
        <trans-unit id="80938cb5970c9483ff312171cb2cce6f1c888a48" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#recursive-cte&quot;&gt;recursive-cte&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#recursive-cte&quot;&gt;使用者&lt;/a&gt;：递归cte &lt;a href=&quot;#with-clause&quot;&gt;从句&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ae852a57048a30f81de513ccc896f0c0dd648fe" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3f7cbedd2f19d68e5c65e3a5494b079eb45e6d0" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;#select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;表或子查询&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="589e0a5319c833b4b7bc5d107ed94b7fe1c7d8cd" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35ea943fa5a24500d0b2de81bfcae0c263e9c947" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;窗口函数调用&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f6ef1477fa5df999acf552fb4e67164b37b0a48f" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#sql-stmt&quot;&gt;使用者&lt;/a&gt;：sql-stmt</target>
        </trans-unit>
        <trans-unit id="b6d1945ca75963e8557621ed71f512d0d1f8a13e" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#sql-stmt-list&quot;&gt;sql-stmt-list&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#sql-stmt-list&quot;&gt;使用者&lt;/a&gt;：sql-stmt-list</target>
        </trans-unit>
        <trans-unit id="1042aa6c3f092cc75f0c8a676be3f2d32a0e48e0" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#update-stmt&quot;&gt;使用者&lt;/a&gt;：update-stmt &lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1f1be8756f8f6e3850d5a9e7441499016850919" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;aggregate-function-invocation&quot;&gt;aggregate-function-invocation&lt;/a&gt;&lt;a href=&quot;attach-stmt&quot;&gt;attach-stmt&lt;/a&gt;&lt;a href=&quot;column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;frame-spec&quot;&gt;frame-spec&lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed-column&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;join-constraint&quot;&gt;join-constraint&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;simple-function-invocation&quot;&gt;simple-function-invocation&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;aggregate-function-invocation&quot;&gt;聚合函数调用&lt;/a&gt;&lt;a href=&quot;attach-stmt&quot;&gt;attach-stmt &lt;/a&gt;&lt;a href=&quot;column-constraint&quot;&gt;列约束&lt;/a&gt;&lt;a href=&quot;compound-select-stmt&quot;&gt;复合选择stmt &lt;/a&gt;&lt;a href=&quot;create-index-stmt&quot;&gt;创建索引index-mt &lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;触发触发器-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;删除stmt-有限因&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;式选择-stmt &lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;过滤器子句&lt;/a&gt;&lt;a href=&quot;frame-spec&quot;&gt;框架规范&lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;索引-列&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;join-constraint&quot;&gt;加入约束&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;排序项&lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;子句&lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;结果列&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;选择核心&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;simple-function-invocation&quot;&gt;简单函数调用&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt &lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;表约束&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;表或子查询&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-子句&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn &lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8dba34c5ead7ae94617f98c7cde1dd99c8cf20f1" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;aggregate-function-invocation&quot;&gt;aggregate-function-invocation&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;aggregate-function-invocation&quot;&gt;聚合函数调用&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;窗口函数调用&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="307e140208125cd798472be7cbdee684ec27af23" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;alter-table-stmt&quot;&gt;alter-table-stmt&lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;alter-table-stmt&quot;&gt;alter-table-stmt &lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;创建表-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5caeae659f486a37e2e78f0f36394d00574f259" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;column-constraint&quot;&gt;column-constraint &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a86521d0d079a24ae129812150a3753aecda3e41" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;pragma-value&quot;&gt;pragma-value&lt;/a&gt;&lt;a href=&quot;type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;column-constraint&quot;&gt;列约束&lt;/a&gt;&lt;a href=&quot;pragma-value&quot;&gt;编译指示值&lt;/a&gt;&lt;a href=&quot;type-name&quot;&gt;类型名称&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4797572b6c11d132a08e6eb97c1346965d8c3891" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;column-constraint&quot;&gt;列约束&lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;表约束&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="530c72cf587d62fa294e2381602271f96f0f96d7" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bae571e21875de9dbe7973158d01f4c614d8c361" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;column-def&quot;&gt;column-def &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d621ef2d30a77aac0f67e4cb22f0496953330ae4" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;create-view-stmt&quot;&gt;create-view-stmt&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt &lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;create-view-stmt&quot;&gt;create-view-stmt &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;带子句的&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;表或子查询&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7999cb7cebc65a8fd79ca0339c4bb490ea515b01" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0856e25a6da8ebb570311e60dcc92e62c9700b8" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;compound-select-stmt&quot;&gt;复合选择stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;删除stmt限制&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;分解选择stmt &lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;子句&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select stmt &lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;简单选择stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;更新stmt受限&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="21f8541c9dc2a69fa16cf43b335b7b363315d397" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;compound-select-stmt&quot;&gt;复合选择stmt &lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;分解选择stmt &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;选择stmt &lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;简单选择stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4ab6ebc8f279a3034f0fdb604843d248415ee1bf" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;compound-select-stmt&quot;&gt;复合选择stmt &lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;分解选择stmt &lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;简单选择stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9b73b88651ef8bf860289b6de3757bded750bc5" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt &lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;表约束&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f17754185255593ea4e239b7777c291185f4d22a" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1250d862d07127e87b9840caf01bde3487514be4" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7ffe5f5730adb72eee0e8790e0d4f442453ca532" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;delete-stmt&quot;&gt;使用者&lt;/a&gt;：delete-stmt &lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b346b7bdc3d0ceef5715a064d5778a794c30fe18" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;delete-stmt&quot;&gt;使用者&lt;/a&gt;：delete-stmt &lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ecd461adaec5db6b876f0dff52c7be72090d1b14" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1d46198801b0b7bba9815dc12e4cdb3e29b72db5" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="79c1bf6cb1bf604130309cdb21b4f8fbff437aa3" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;insert-stmt&quot;&gt;使用者&lt;/a&gt;：insert-stmt</target>
        </trans-unit>
        <trans-unit id="9892cdf8b7abbe2222939b3dd694fd626893c60f" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b8026c06ece9d695e8c405568f97c947f459d098" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e21ce3a84da1747a72ee6509dcd2b66aa22588d4" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9280252176a18a8cad0168e3316dcfbe48390b81" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">用于：&lt;a href=&quot;over-clause&quot;&gt;子句&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98a46233f40109c7b176062c4c3a604629e49ee7" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;pragma-stmt&quot;&gt;pragma-stmt&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pragma-stmt&quot;&gt;使用者&lt;/a&gt;：pragma-stmt</target>
        </trans-unit>
        <trans-unit id="b50593211eada2909f681edc15211383687e61a9" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;recursive-cte&quot;&gt;recursive-cte&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;recursive-cte&quot;&gt;使用者&lt;/a&gt;：递归cte &lt;a href=&quot;with-clause&quot;&gt;从句&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="36f9352a3528ee1d344ab047f86be842bf862c8a" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7939044785ba0a8ca2c0b2b3b645bfec873f9c5c" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">用法：&lt;a href=&quot;select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;表或子查询&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8113b13214eea91b3a3368ba7da6ad54a4268b3b" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd5b650bb8cb46f8defc106f0dfcc99d5b051cd" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;窗口函数调用&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4594a38d58964e1e237c00459543be8431bc246" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;sql-stmt&quot;&gt;使用者&lt;/a&gt;：sql-stmt</target>
        </trans-unit>
        <trans-unit id="35b40c8cd50b969bfb81394dd732cd863e0cd4d1" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;sql-stmt-list&quot;&gt;sql-stmt-list&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;sql-stmt-list&quot;&gt;使用者&lt;/a&gt;：sql-stmt-list</target>
        </trans-unit>
        <trans-unit id="b23afd53b16f293ca94992760b0d75920c0db155" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;update-stmt&quot;&gt;使用者&lt;/a&gt;：update-stmt &lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="83a28142d94277b9f824e8d439d35c64935809cf" translate="yes" xml:space="preserve">
          <source>User Data For Functions</source>
          <target state="translated">功能的用户数据</target>
        </trans-unit>
        <trans-unit id="f87f9bec30fa447642063fa0c8666b7e8eb0bcd7" translate="yes" xml:space="preserve">
          <source>User defined functions can be created using the following routine:</source>
          <target state="translated">可以使用以下例程创建用户定义的函数。</target>
        </trans-unit>
        <trans-unit id="444756f6f1895c936bb10bab307f679e2df66fa7" translate="yes" xml:space="preserve">
          <source>User-definable text collating sequences.</source>
          <target state="translated">用户可自定义文本整理序列。</target>
        </trans-unit>
        <trans-unit id="41cabf87c0640a35632815a9c1c75379f4b103ed" translate="yes" xml:space="preserve">
          <source>User-defined Collating Sequences</source>
          <target state="translated">用户自定义整理序列</target>
        </trans-unit>
        <trans-unit id="679b4a0d57b60e54b747cb9aacd21774ca84d965" translate="yes" xml:space="preserve">
          <source>User-defined aggregate window functions may be created using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_window_function&lt;/a&gt;() API. Implementing an aggregate window function is very similar to an ordinary aggregate function. Any user-defined aggregate window function may also be used as an ordinary aggregate. To implement a user-defined aggregate window function the application must supply four callback functions:</source>
          <target state="translated">可以使用&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_window_function&lt;/a&gt;（）API 创建用户定义的聚合窗口函数。实现聚合窗口功能与普通聚合功能非常相似。任何用户定义的聚合窗口函数也可以用作普通聚合。要实现用户定义的聚合窗口函数，应用程序必须提供四个回调函数：</target>
        </trans-unit>
        <trans-unit id="8cb5450ed96e61339c7346965130b897dcacb151" translate="yes" xml:space="preserve">
          <source>User-defined text collating sequences.</source>
          <target state="translated">用户自定义文本整理序列。</target>
        </trans-unit>
        <trans-unit id="e6d26b2d97c6ea4098987a42caa6c50e042619be" translate="yes" xml:space="preserve">
          <source>Uses 9% fewer CPU cycles. (See the &lt;a href=&quot;cpu&quot;&gt;CPU performance measurement&lt;/a&gt; report for details on how this performance increase was computed.)</source>
          <target state="translated">使用的CPU周期减少了9％。（有关如何计算此性能提升的详细信息，请参阅&lt;a href=&quot;cpu&quot;&gt;CPU性能评估&lt;/a&gt;报告。）</target>
        </trans-unit>
        <trans-unit id="d0301d0d4694000bac42286a893da835217aae2d" translate="yes" xml:space="preserve">
          <source>Uses compiler built-ins (ex: __builtin_bswap32() or _byteswap_ulong()) for byteswapping when available.</source>
          <target state="translated">在可用的情况下,使用编译器内建(例如:__builtin_bswap32()或__byteswap_ulong())进行字节交换。</target>
        </trans-unit>
        <trans-unit id="f10225b09b2eddd2b69fc1125f1e8c1790100225" translate="yes" xml:space="preserve">
          <source>Uses the &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; key/value access object instead of SQL for pulling content out of R-Tree nodes</source>
          <target state="translated">使用&lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt;键/值访问对象而不是SQL从R-Tree节点中提取内容</target>
        </trans-unit>
        <trans-unit id="bf6a8d8b0b161f49ba5a16ea51a640dcb0e4cfe4" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=MEMORY&lt;/a&gt; and taking an application crash in the middle of a write transaction.</source>
          <target state="translated">使用&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = OFF&lt;/a&gt;或&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = MEMORY&lt;/a&gt;并在写事务过程中使应用程序崩溃。</target>
        </trans-unit>
        <trans-unit id="1020c3daf5ee3d9c72ef57a803c58bd0586e47f7" translate="yes" xml:space="preserve">
          <source>Using CREATE or DROP to create or destroy a table or index is really the same as doing an INSERT or DELETE from the special &quot;sqlite_master&quot; table, at least from the point of view of the VDBE. The sqlite_master table is a special table that is automatically created for every SQLite database. It looks like this:</source>
          <target state="translated">使用CREATE或DROP来创建或销毁表或索引,其实和从特殊的 &quot;sqlite_master &quot;表进行INSERT或DELETE是一样的,至少从VDBE的角度来看是这样。sqlite_master表是一个特殊的表,它是为每个SQLite数据库自动创建的。它的样子是这样的。</target>
        </trans-unit>
        <trans-unit id="4d2637c8d86cb85da8f8da94256a0cdc80d9b4c2" translate="yes" xml:space="preserve">
          <source>Using DDL or DML SQL statements, SQLite users may modify the contents and size of a database file. Exactly how changes to the logical database are translated to modifications to the database file is described in</source>
          <target state="translated">使用DDL或DML SQL语句,SQLite用户可以修改数据库文件的内容和大小。具体如何将对逻辑数据库的修改转化为对数据库文件的修改,将在下面描述。</target>
        </trans-unit>
        <trans-unit id="435c55e01cffb5570c6c79cda02f466b6061178b" translate="yes" xml:space="preserve">
          <source>Using Idx2 instead of Idx1 causes SQLite to examine a different set of rows, but it gets the same answer in the end (which is very important - remember that indices should never change the answer, only help SQLite to get to the answer more quickly) and it does the same amount of work. So the Idx2 index did not help performance in this case.</source>
          <target state="translated">使用Idx2而不是Idx1会导致SQLite检查一组不同的行,但最终得到的答案是一样的(这一点非常重要--请记住,索引永远不应该改变答案,只能帮助SQLite更快地得到答案),而且它做的工作量也是一样的。所以在这种情况下,Idx2索引对性能没有帮助。</target>
        </trans-unit>
        <trans-unit id="c7fd16dcb5fbd84cb48400bd250b2f97394100cb" translate="yes" xml:space="preserve">
          <source>Using Indexes To Speed Searching</source>
          <target state="translated">使用索引来加快搜索速度</target>
        </trans-unit>
        <trans-unit id="9f210fd1e7b63cdc7dd0138afd84809f14583a65" translate="yes" xml:space="preserve">
          <source>Using SELECT Statements As Terms In An Expression</source>
          <target state="translated">在表达式中使用SELECT语句作为术语。</target>
        </trans-unit>
        <trans-unit id="97437976ebeb573c52b13ddfd438d2c91bf1893b" translate="yes" xml:space="preserve">
          <source>Using SQLite In Multi-Threaded Applications</source>
          <target state="translated">在多线程应用程序中使用 SQLite</target>
        </trans-unit>
        <trans-unit id="307f31c1c11aebab82631ac4f8b0ab54eca6e078" translate="yes" xml:space="preserve">
          <source>Using a MATCH operator in the WHERE clause of a SELECT statement, or</source>
          <target state="translated">在SELECT语句的WHERE子句中使用MATCH操作符,或</target>
        </trans-unit>
        <trans-unit id="3e68860fe2d2ad5dc9651e317f240eed014363dc" translate="yes" xml:space="preserve">
          <source>Using a built-in printf() implementation means that SQLite has one fewer dependency on the host environment, making it more portable.</source>
          <target state="translated">使用内置的printf()实现,意味着SQLite少了一个对主机环境的依赖,使其更具可移植性。</target>
        </trans-unit>
        <trans-unit id="c90117e39221737f02ea3e7e44c49c43210beeb3" translate="yes" xml:space="preserve">
          <source>Using a database file with 8+3 filenames in some cases while in other cases using long filenames is equivalent to &lt;a href=&quot;howtocorrupt#delhotjrnl&quot;&gt;deleting a hot journal&lt;/a&gt;.</source>
          <target state="translated">在某些情况下，使用文件名8 + 3的数据库文件，而在其他情况下，使用长文件名等效于&lt;a href=&quot;howtocorrupt#delhotjrnl&quot;&gt;删除热日志&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8fb331fbfc19c9ad94dbe708335967012f83cb31" translate="yes" xml:space="preserve">
          <source>Using a dataset of American place names (derived from &lt;a href=&quot;http://geonames.usgs.gov/domestic/download_data.htm&quot;&gt;http://geonames.usgs.gov/domestic/download_data.htm&lt;/a&gt;) the query above returns 20 results beginning with:</source>
          <target state="translated">使用美国地名的数据集（源自&lt;a href=&quot;http://geonames.usgs.gov/domestic/download_data.htm&quot;&gt;http://geonames.usgs.gov/domestic/download_data.htm&lt;/a&gt;），上面的查询返回20个结果，开头为：</target>
        </trans-unit>
        <trans-unit id="cced5340290d93733d759f1a49ce8d467995399f" translate="yes" xml:space="preserve">
          <source>Using a single query such as the above, the application obtains a list of the slideIds for all slides in the presentation. The application then queries for the content of the first slide, and parses and displays that content, as before.</source>
          <target state="translated">使用像上面这样的单一查询,应用程序获得演示文稿中所有幻灯片的slideIds列表。然后,应用程序查询第一张幻灯片的内容,并像之前一样,解析和显示该内容。</target>
        </trans-unit>
        <trans-unit id="7dd3bf0fc645009566609bccf3a14f62d35a3f59" translate="yes" xml:space="preserve">
          <source>Using an equals (&quot;=&quot;) operator in the WHERE clause of a SELECT statement, or</source>
          <target state="translated">在SELECT语句的WHERE子句中使用等价(&quot;=&quot;)操作符,或</target>
        </trans-unit>
        <trans-unit id="23bf7370fe569447da050d73459abb59d1093647" translate="yes" xml:space="preserve">
          <source>Using an ordinary disk file to provide shared memory has the disadvantage that it might actually do unnecessary disk I/O by writing the shared memory to disk. However, the developers do not think this is a major concern since the wal-index rarely exceeds 32 KiB in size and is never synced. Furthermore, the wal-index backing file is deleted when the last database connection disconnects, which often prevents any real disk I/O from ever happening.</source>
          <target state="translated">使用普通的磁盘文件来提供共享内存有一个缺点,那就是它实际上可能会通过将共享内存写入磁盘来进行不必要的磁盘I/O。然而,开发人员认为这不是一个主要的问题,因为wal-index的大小很少超过32 KiB,而且从不同步。此外,当最后一个数据库连接断开时,wal-index备份文件会被删除,这通常会阻止任何真正的磁盘I/O发生。</target>
        </trans-unit>
        <trans-unit id="314bb9e64d758d2b63c2c5acc0e1727dc6e61abf" translate="yes" xml:space="preserve">
          <source>Using an unnamed subquery in a FROM clause would cause a segfault.</source>
          <target state="translated">在FROM子句中使用未命名的子查询会导致segfault。</target>
        </trans-unit>
        <trans-unit id="9766cdfa57f62810ee226e9c3deec347064cc20b" translate="yes" xml:space="preserve">
          <source>Using gcov (or similar) to show that every branch instruction is taken at least once in both directions is good measure of test suite quality. But even better is showing that every branch instruction makes a difference in the output. In other words, we want to show not only that every branch instruction both jumps and falls through but also that every branch is doing useful work and that the test suite is able to detect and verify that work. When a branch is found that does not make a difference in the output, that suggests that the code associated the branch can be removed (reducing the size of the library and perhaps making it run faster) or that the test suite is inadequately testing the feature that the branch implements.</source>
          <target state="translated">使用gcov(或类似的)来显示每个分支指令在两个方向上至少被采取一次,是衡量测试套件质量的好方法。但更好的是显示每条分支指令都会使输出有所区别。换句话说,我们不仅要证明每条分支指令既跳转又落空,还要证明每条分支都在做有用的工作,并且测试套件能够检测和验证这些工作。当发现一个分支没有使输出产生差异时,这表明与该分支相关的代码可以被删除(减少库的大小,也许会使库运行得更快),或者测试套件对该分支实现的功能测试不足。</target>
        </trans-unit>
        <trans-unit id="db5729475276e1f07562cb2df1e724ad2371713c" translate="yes" xml:space="preserve">
          <source>Using one particular subset of the available TH3 test modules (the &quot;cov1&quot; tests) SQLite obtained &lt;a href=&quot;testing#coverage&quot;&gt;100% branch test coverage&lt;/a&gt; and 100% &lt;a href=&quot;testing#mcdc&quot;&gt;MC/DC&lt;/a&gt; as measured by &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt; on Linux x86 and x86_64 hardware. All releases of SQLite since &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt; (2009-08-10) have been tested to this standard. The SQLite developers are committed to maintaining 100% branch coverage and MC/DC for all future releases of SQLite.</source>
          <target state="translated">使用可用的TH3测试模块的一个特定子集（&amp;ldquo; cov1&amp;rdquo;测试），SQLite 在Linux x86和x86_64硬件上通过&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt;测量得出&lt;a href=&quot;testing#coverage&quot;&gt;100％的分支测试覆盖率&lt;/a&gt;和100％的&lt;a href=&quot;testing#mcdc&quot;&gt;MC / DC&lt;/a&gt;。自&lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;版本3.6.17&lt;/a&gt;（2009-08-10）起，SQLite的所有发行版均已按照此标准进行了测试。SQLite开发人员致力于为所有将来版本的SQLite保持100％的分支覆盖率和MC / DC。</target>
        </trans-unit>
        <trans-unit id="9270ae0408b0c691c7bbd964a691a187fe62e891" translate="yes" xml:space="preserve">
          <source>Using subtypes to identify valid pointers prevented the WebSQL exploit. But it turned out to be an incomplete solution.</source>
          <target state="translated">使用子类型来识别有效的指针,防止了WebSQL的漏洞。但事实证明这是一个不完整的解决方案。</target>
        </trans-unit>
        <trans-unit id="4b795c9ed4e93bd126c1058e30a1d247be674aba" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4 content option&lt;/a&gt; and failing to manually keep the content in sync with the FTS4 inverted indices.</source>
          <target state="translated">使用&lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4内容选项，&lt;/a&gt;并且无法手动使内容与FTS4倒排索引同步。</target>
        </trans-unit>
        <trans-unit id="c352b493b2f0901876aea8d20656c0d87ef6b6a9" translate="yes" xml:space="preserve">
          <source>Using the N+1 Query pattern in Fossil does not harm the application. But the N+1 Query pattern does have benefits. For one, the section of the code that creates the timeline query can be completely separate from the section that prepares each timeline entry for display. This provides a separation of responsibility that helps keep the code simple and easy to maintain. Secondly, the information needed for display, and the queries needed to extract that information, vary according to what type of objects to be shown. Check-ins need one set of queries. Tickets need another set of queries. Wiki pages need a different query. And so forth. By implementing these queries on-demand and in the part of the code dealing with the various entities, there is further separation of responsibility and simplification of the overall code base.</source>
          <target state="translated">在Fossil中使用N+1查询模式不会对应用造成伤害。但N+1查询模式确实有好处。首先,创建时间线查询的代码部分可以与准备显示每个时间线条目的部分完全分开。这提供了一种责任分离,有助于保持代码的简单和易于维护。其次,显示所需的信息,以及提取这些信息所需的查询,根据要显示的对象的类型而有所不同。签到需要一组查询。票务需要另一组查询。Wiki页面需要不同的查询。以此类推。通过在处理各种实体的代码部分按需实现这些查询,可以进一步分清责任,简化整个代码库。</target>
        </trans-unit>
        <trans-unit id="ed8c795d039e297badfdb934d5dad24eb9711fc6" translate="yes" xml:space="preserve">
          <source>Using the SQLite Online Backup API</source>
          <target state="translated">使用SQLite在线备份API</target>
        </trans-unit>
        <trans-unit id="702c33598d91f7511e11baf351b09ecd585c68e7" translate="yes" xml:space="preserve">
          <source>Using the VFS xAccess() method, SQLite queries the file-system to see if the journal file associated with the database exists. If it does not, then there is no hot-journal file.</source>
          <target state="translated">使用VFS xAccess()方法,SQLite查询文件系统,查看与数据库相关联的日志文件是否存在。如果不存在,则不存在热期刊文件。</target>
        </trans-unit>
        <trans-unit id="15a6ded3b6ea323ecf5d8ed10a9908901c0cf29c" translate="yes" xml:space="preserve">
          <source>Using the memcpy() function on overlapping buffers.</source>
          <target state="translated">在重叠的缓冲区上使用memcpy()函数。</target>
        </trans-unit>
        <trans-unit id="0ff71664481484af5340c1f4f2d1ad694ff3ab5e" translate="yes" xml:space="preserve">
          <source>Using the new Idx2 index on &quot;state&quot;, SQLite has another option for lookup up the price of California oranges: it can look up every row that contains fruit from California and filter out those rows that are not oranges.</source>
          <target state="translated">使用新的Idx2索引 &quot;state&quot;,SQLite有了另一个查询加州橙子价格的选项:它可以查询每一条包含加州水果的记录,并过滤掉那些不是橙子的记录。</target>
        </trans-unit>
        <trans-unit id="fcde00cc70debec35832ff9273a06512f95fa039" translate="yes" xml:space="preserve">
          <source>Using the sqlite3_unlock_notify() API</source>
          <target state="translated">使用sqlite3_unlock_notify()API。</target>
        </trans-unit>
        <trans-unit id="08fc370c39b7ca0e2248cedd981f211b8dabd8d8" translate="yes" xml:space="preserve">
          <source>Using the two routines above, it is simple for applications to insert new records into or extract existing records from an SQLite Archive. Insert a new into an SQLite Archive using code like this:</source>
          <target state="translated">使用以上两个例程,应用程序可以很简单地将新记录插入到SQLite Archive中或从SQLite Archive中提取现有记录。使用这样的代码将新的记录插入到SQLite Archive中。</target>
        </trans-unit>
        <trans-unit id="5881634960ec51d660f927c3ca27237c1640f650" translate="yes" xml:space="preserve">
          <source>Using the virtual table interface, new entries may be added to a zip archive by inserting new rows into the virtual table. Entries may be removed by deleting rows or modified by updating them.</source>
          <target state="translated">使用虚拟表界面,通过在虚拟表中插入新的行,可以将新的条目添加到 zip 档案中。可以通过删除行或更新行来删除条目。</target>
        </trans-unit>
        <trans-unit id="e7f12616ba6b09fc33431b9c20577f960596b4bb" translate="yes" xml:space="preserve">
          <source>Using the xFileSize() method of the file-handle opened on the database file, SQLite checks if the database file is 0 bytes in size. If it is, the journal file is not considered to be a</source>
          <target state="translated">使用在数据库文件上打开的文件柄的xFileSize()方法,SQLite检查数据库文件的大小是否为0字节。如果是,则不认为日志文件是一个新的文件。</target>
        </trans-unit>
        <trans-unit id="18744e7331495a3e5c139b339aa5a7dcf1c94f70" translate="yes" xml:space="preserve">
          <source>Usually (the exceptions are &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; tables and &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables) a PRIMARY KEY in an SQLite table is really the same as a UNIQUE constraint. Due to an historical oversight, the column values of such a PRIMARY KEY are allowed to be NULL. This is a bug, but by the time the problem was discovered there where so many databases in circulation that depended on the bug that the decision was made to support the bugging behavior moving forward.</source>
          <target state="translated">通常（例外是&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;表和&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表），SQLite表中的PRIMARY KEY实际上与UNIQUE约束相同。由于历史上的疏忽，此类PRIMARY KEY的列值允许为NULL。这是一个错误，但是到那时发现问题的时候，由于存在大量依赖该错误的数据库，因此决定支持该错误行为。</target>
        </trans-unit>
        <trans-unit id="f79481390537aded0fd54463773aac91edd4e79c" translate="yes" xml:space="preserve">
          <source>Usually only a subset of the pages in the database file are read. In this example we are showing three pages out of eight being read. In a typical application, a database will have thousands of pages and a query will normally only touch a small percentage of those pages.</source>
          <target state="translated">通常,数据库文件中只有一部分页面被读取。在这个例子中,我们显示的是8个页面中的3个被读取。在一个典型的应用中,一个数据库会有成千上万的页面,而查询通常只会触及其中一小部分页面。</target>
        </trans-unit>
        <trans-unit id="27499120d97c0cbd6ba1013d6ea9b6e679141d60" translate="yes" xml:space="preserve">
          <source>Usually the b-trees for tables and indexes are slightly different. A table b-tree contains a 64-bit integer key and arbitrary data. The 64-bit integer key is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;. Index b-trees contain an arbitrary binary key and no data. So table b-trees and index b-trees are not directly compatible.</source>
          <target state="translated">通常，表和索引的b树略有不同。表b树包含一个64位整数键和任意数据。64位整数键是&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;。索引b树包含任意二进制密钥，并且没有数据。因此表b树和索引b树不直接兼容。</target>
        </trans-unit>
        <trans-unit id="63880029448f25d934c11aa39c24fad9c0bb97f6" translate="yes" xml:space="preserve">
          <source>Usually, a new</source>
          <target state="translated">通常情况下,一个新的</target>
        </trans-unit>
        <trans-unit id="251e8707bded33b5cb244d2e22971c5ac18fc6ad" translate="yes" xml:space="preserve">
          <source>Usually, an &lt;a href=&quot;fts3&quot;&gt;FTS3 or FTS4&lt;/a&gt; table is an example of a virtual table with a rowid that works like a PRIMARY KEY. So, for the following FTS4 tables:</source>
          <target state="translated">通常，&lt;a href=&quot;fts3&quot;&gt;FTS3或FTS4&lt;/a&gt;表是虚拟表的示例，其虚拟行的行为类似于PRIMARY KEY。因此，对于以下FTS4表：</target>
        </trans-unit>
        <trans-unit id="016fa908ece58367a08159cc60971094eae348ed" translate="yes" xml:space="preserve">
          <source>Usually, it does not matter if the page-sizes of the source database and the destination database are different before the contents of the destination are overwritten. The page-size of the destination database is simply changed as part of the backup operation. The exception is if the destination database happens to be an in-memory database. In this case, if the page sizes are not the same at the start of the backup operation, then the operation fails with an SQLITE_READONLY error. Unfortunately, this could occur when loading a database image from a file into an in-memory database using function loadOrSaveDb().</source>
          <target state="translated">通常情况下,在覆盖目标数据库的内容之前,源数据库和目标数据库的页面大小是否不同并不重要。目标数据库的页面大小只是作为备份操作的一部分进行更改。如果目标数据库是内存数据库,则例外。在这种情况下,如果在备份操作开始时页面大小不一样,那么操作就会以 SQLITE_READONLY 错误失败。不幸的是,当使用函数 loadOrSaveDb()将数据库映像从文件加载到内存数据库时,可能会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="6590aa5b903de1376b91e1364c96b7ab1602da04" translate="yes" xml:space="preserve">
          <source>Usually, no data is actually written to the database file until the user commits the active</source>
          <target state="translated">通常情况下,在用户提交活动之前,不会向数据库文件实际写入任何数据。</target>
        </trans-unit>
        <trans-unit id="5bf501f181ccf2cf7d7e6317299b267cead1ee47" translate="yes" xml:space="preserve">
          <source>Usually, output parameter *piPhrase is set to the phrase number, *piCol to the column in which it occurs and *piOff the token offset of the first token of the phrase. Returns SQLITE_OK if successful, or an error code (i.e. SQLITE_NOMEM) if an error occurs.</source>
          <target state="translated">通常,输出参数*piPhrase设置为短语编号,*piCol设置为出现短语的列,*piOff设置为短语第一个标记的标记偏移量。如果成功,返回SQLITE_OK,如果发生错误,则返回错误代码(即SQLITE_NOMEM)。</target>
        </trans-unit>
        <trans-unit id="4375ef1d6cde5037d03b8ccb25b702b95cd0734d" translate="yes" xml:space="preserve">
          <source>Usually, the default mutex implementations provided by SQLite are sufficient, however the application has the option of substituting a custom implementation for specialized deployments or systems for which SQLite does not provide a suitable implementation. In this case, the application creates and populates an instance of this structure to pass to sqlite3_config() along with the &lt;a href=&quot;#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; option. Additionally, an instance of this structure can be used as an output variable when querying the system for the current mutex implementation, using the &lt;a href=&quot;#sqliteconfiggetmutex&quot;&gt;SQLITE_CONFIG_GETMUTEX&lt;/a&gt; option.</source>
          <target state="translated">通常，SQLite提供的默认互斥量实现就足够了，但是应用程序可以选择用自定义实现来替代SQLite无法提供合适实现的专用部署或系统。在这种情况下，应用程序将创建并填充此结构的实例，以将其与&lt;a href=&quot;#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt;选项一起传递给sqlite3_config（）。此外，在使用&lt;a href=&quot;#sqliteconfiggetmutex&quot;&gt;SQLITE_CONFIG_GETMUTEX&lt;/a&gt;选项向系统查询当前互斥量实现时，可以将此结构的实例用作输出变量。</target>
        </trans-unit>
        <trans-unit id="d9cb5f2ee721a0e054d3593ea56d06ca4f711a8d" translate="yes" xml:space="preserve">
          <source>Usually, the default mutex implementations provided by SQLite are sufficient, however the application has the option of substituting a custom implementation for specialized deployments or systems for which SQLite does not provide a suitable implementation. In this case, the application creates and populates an instance of this structure to pass to sqlite3_config() along with the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; option. Additionally, an instance of this structure can be used as an output variable when querying the system for the current mutex implementation, using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiggetmutex&quot;&gt;SQLITE_CONFIG_GETMUTEX&lt;/a&gt; option.</source>
          <target state="translated">通常，SQLite提供的默认互斥量实现就足够了，但是应用程序可以选择用自定义实现来替代SQLite无法提供合适实现的专用部署或系统。在这种情况下，应用程序将创建并填充此结构的实例，以将其与&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt;选项一起传递给sqlite3_config（）。此外，在使用&lt;a href=&quot;c_config_covering_index_scan#sqliteconfiggetmutex&quot;&gt;SQLITE_CONFIG_GETMUTEX&lt;/a&gt;选项向系统查询当前互斥量实现时，可以将此结构的实例用作输出变量。</target>
        </trans-unit>
        <trans-unit id="f67d8e98eea6d06da4e67ed9ebc795e5c21c27d3" translate="yes" xml:space="preserve">
          <source>Usually, the parent key of a foreign key constraint is the primary key of the parent table. If they are not the primary key, then the parent key columns must be collectively subject to a UNIQUE constraint or have a UNIQUE index. If the parent key columns have a UNIQUE index, then that index must use the collation sequences that are specified in the CREATE TABLE statement for the parent table. For example,</source>
          <target state="translated">通常,外键约束的父键是父表的主键。如果它们不是主键,那么父键列必须共同受制于一个UNIQUE约束,或者有一个UNIQUE索引。如果父键列有一个UNIQUE索引,那么该索引必须使用在父表的CREATE TABLE语句中指定的整理序列。例如</target>
        </trans-unit>
        <trans-unit id="6dab9ce5b9389cc793db1ee13d4fd8a8749eccd9" translate="yes" xml:space="preserve">
          <source>Usually, the sessions module encloses all operations performed by a single call to apply_v2() or apply_v2_strm() in a &lt;a href=&quot;../lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;. The SAVEPOINT is committed if the changeset or patchset is successfully applied, or rolled back if an error occurs. Specifying this flag causes the sessions module to omit this savepoint. In this case, if the caller has an open transaction or savepoint when apply_v2() is called, it may revert the partially applied changeset by rolling it back.</source>
          <target state="translated">通常情况下，会话模块封装一个函数调用在执行apply_v2（）或apply_v2_strm（）的所有操作&lt;a href=&quot;../lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;。如果成功应用了变更集或补丁集，则提交SAVEPOINT；如果发生错误，则回滚SAVEPOINT。指定此标志将导致会话模块忽略此保存点。在这种情况下，如果在调用apply_v2（）时调用方具有打开的事务或保存点，则可以回滚部分应用的变更集。</target>
        </trans-unit>
        <trans-unit id="651dad2d1a7cdde77afe8c8f6efa3556819be19f" translate="yes" xml:space="preserve">
          <source>Usually, the sessions module encloses all operations performed by a single call to apply_v2() or apply_v2_strm() in a &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;. The SAVEPOINT is committed if the changeset or patchset is successfully applied, or rolled back if an error occurs. Specifying this flag causes the sessions module to omit this savepoint. In this case, if the caller has an open transaction or savepoint when apply_v2() is called, it may revert the partially applied changeset by rolling it back.</source>
          <target state="translated">通常情况下，会话模块封装一个函数调用在执行apply_v2（）或apply_v2_strm（）的所有操作&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;。如果成功应用了变更集或补丁集，则提交SAVEPOINT；如果发生错误，则回滚SAVEPOINT。指定此标志将导致会话模块忽略此保存点。在这种情况下，如果在调用apply_v2（）时调用方具有打开的事务或保存点，则可以回滚部分应用的变更集。</target>
        </trans-unit>
        <trans-unit id="a7c5b3a786dedb589ca7dfd4119dc946fad418cc" translate="yes" xml:space="preserve">
          <source>Usually, when a database in wal mode is closed or detached from a database handle, SQLite checks if this will mean that there are now no connections at all to the database. If so, it performs a checkpoint operation before closing the connection. This option may be used to override this behaviour. The first parameter passed to this operation is an integer - positive to disable checkpoints-on-close, or zero (the default) to enable them, and negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether checkpoints-on-close have been disabled - 0 if they are not disabled, 1 if they are.</source>
          <target state="translated">通常,当一个处于wal模式的数据库关闭或脱离数据库句柄时,SQLite会检查这是否会意味着现在与数据库完全没有连接。如果是这样,它会在关闭连接之前执行一个检查点操作。这个选项可以用来覆盖这个行为。传递给该操作的第一个参数是一个整数--正数表示禁用关闭时的检查点,零(默认)表示启用,负数表示保持设置不变。第二个参数是一个指向整数的指针,将0或1写入其中,表示是否禁用了关闭时检查点--0表示没有禁用,1表示禁用。</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="998ce99ff7bc11e5fda480fd5bfcbe7172fa1458" translate="yes" xml:space="preserve">
          <source>Utter only truth from heart and mouth.</source>
          <target state="translated">只从心和口中说出真相。</target>
        </trans-unit>
        <trans-unit id="0a83488e309bcd16565cc48e7357404309c680f8" translate="yes" xml:space="preserve">
          <source>VACUUM</source>
          <target state="translated">VACUUM</target>
        </trans-unit>
        <trans-unit id="338c2017b922c8c778a643c9a2bb9bb0d159e34d" translate="yes" xml:space="preserve">
          <source>VACUUM INTO</source>
          <target state="translated">真空进入</target>
        </trans-unit>
        <trans-unit id="204b6e5828ce2852bf6877318b1361fbae1e4020" translate="yes" xml:space="preserve">
          <source>VACUUM uses a temporary file in the official TEMP folder, not in the same directory as the original database</source>
          <target state="translated">VACUUM使用的是官方TEMP文件夹下的临时文件,而不是与原数据库在同一目录下的文件。</target>
        </trans-unit>
        <trans-unit id="eba0ca62d23c0aa5d1fd44639bb5b08cca16a456" translate="yes" xml:space="preserve">
          <source>VACUUM with an INTO clause</source>
          <target state="translated">带INTO子句的VACUUM</target>
        </trans-unit>
        <trans-unit id="b3cba55338b3625665f9ea5a7e33ff9db26da1af" translate="yes" xml:space="preserve">
          <source>VALUES</source>
          <target state="translated">VALUES</target>
        </trans-unit>
        <trans-unit id="3893415f582da8528cfdc804ac3bee7e25a15ab1" translate="yes" xml:space="preserve">
          <source>VALUES clause</source>
          <target state="translated">VALUES条款</target>
        </trans-unit>
        <trans-unit id="2010132ce9d7ecb7ffcd8583e46eb6830b5b89ee" translate="yes" xml:space="preserve">
          <source>VARCHAR(255)</source>
          <target state="translated">VARCHAR(255)</target>
        </trans-unit>
        <trans-unit id="8e2934685262dc368f8941746e5ac5ff58123235" translate="yes" xml:space="preserve">
          <source>VARYING CHARACTER(255)</source>
          <target state="translated">变化的字符(255)</target>
        </trans-unit>
        <trans-unit id="efde179e9b49292e75991e12678580f142a070e1" translate="yes" xml:space="preserve">
          <source>VBegin</source>
          <target state="translated">VBegin</target>
        </trans-unit>
        <trans-unit id="d0eedafb13c92d47b81b7b056def9e323b6e493c" translate="yes" xml:space="preserve">
          <source>VColumn</source>
          <target state="translated">VColumn</target>
        </trans-unit>
        <trans-unit id="f84b9b0948754b7d110e0815c9837bdc1fddebe7" translate="yes" xml:space="preserve">
          <source>VCreate</source>
          <target state="translated">VCreate</target>
        </trans-unit>
        <trans-unit id="91b564dbaa1169fe6e48962a34cffa4f703f0be0" translate="yes" xml:space="preserve">
          <source>VDestroy</source>
          <target state="translated">VDestroy</target>
        </trans-unit>
        <trans-unit id="b33892fbddeffc3368077b4904ad0b3d562a7312" translate="yes" xml:space="preserve">
          <source>VERSION</source>
          <target state="translated">VERSION</target>
        </trans-unit>
        <trans-unit id="9913e8aa2ef97f43053931ebe92afe906139c950" translate="yes" xml:space="preserve">
          <source>VFS</source>
          <target state="translated">VFS</target>
        </trans-unit>
        <trans-unit id="e0bba973b3126bd49629e5735098909a83c37fb8" translate="yes" xml:space="preserve">
          <source>VFS Adaptor Related Assumptions</source>
          <target state="translated">VFS适配器相关假设</target>
        </trans-unit>
        <trans-unit id="0427fe52d1301f469be76b38e86110229024c26c" translate="yes" xml:space="preserve">
          <source>VFS shim</source>
          <target state="translated">VFS垫片</target>
        </trans-unit>
        <trans-unit id="42c3d050c1ab4fc79ee66e794588a38879f87c59" translate="yes" xml:space="preserve">
          <source>VFilter</source>
          <target state="translated">VFilter</target>
        </trans-unit>
        <trans-unit id="0fa2ff5785952199b4086a34e015d691fb6f638e" translate="yes" xml:space="preserve">
          <source>VIEW</source>
          <target state="translated">VIEW</target>
        </trans-unit>
        <trans-unit id="d1ea68c099681d5006dd208d2e34db6600ee8c5a" translate="yes" xml:space="preserve">
          <source>VIEWs in SQLite are read-only. You may not execute a DELETE, INSERT, or UPDATE statement on a view. But you can create a trigger that fires on an attempt to DELETE, INSERT, or UPDATE a view and do what you need in the body of the trigger.</source>
          <target state="translated">SQLite中的视图是只读的。你不能在视图上执行DELETE、INSERT或UPDATE语句。但你可以创建一个触发器,在尝试DELETE、INSERT或UPDATE视图时触发,并在触发器的主体中执行你需要的操作。</target>
        </trans-unit>
        <trans-unit id="5fe4dd429e7ca82543f447d5b6e37edc0b0211f3" translate="yes" xml:space="preserve">
          <source>VIRTUAL</source>
          <target state="translated">VIRTUAL</target>
        </trans-unit>
        <trans-unit id="b9de5e41c6dc887dbc8f743605405fee0be8e279" translate="yes" xml:space="preserve">
          <source>VNext</source>
          <target state="translated">VNext</target>
        </trans-unit>
        <trans-unit id="348f1db286c8e9b47c43f2f013b0dd88171bf692" translate="yes" xml:space="preserve">
          <source>VOpen</source>
          <target state="translated">VOpen</target>
        </trans-unit>
        <trans-unit id="9741852a241ce6064f8f2d351b08520dd5847d98" translate="yes" xml:space="preserve">
          <source>VRename</source>
          <target state="translated">VRename</target>
        </trans-unit>
        <trans-unit id="4bce4ebd3cc132100d6cc36475c7b1294f94edb7" translate="yes" xml:space="preserve">
          <source>VUpdate</source>
          <target state="translated">VUpdate</target>
        </trans-unit>
        <trans-unit id="5fe15df2c7882707d49fdc0903788dfd022b02ca" translate="yes" xml:space="preserve">
          <source>Vacuum</source>
          <target state="translated">Vacuum</target>
        </trans-unit>
        <trans-unit id="27b07b92ebcc99b13cdafff029c3e3d22606bada" translate="yes" xml:space="preserve">
          <source>Vacuum the entire database P1. P1 is 0 for &quot;main&quot;, and 2 or more for an attached database. The &quot;temp&quot; database may not be vacuumed.</source>
          <target state="translated">真空整个数据库P1。P1对于 &quot;main &quot;为0,对于附属数据库为2或更多。&quot;temp &quot;数据库可以不吸尘。</target>
        </trans-unit>
        <trans-unit id="0819f8114e772508968d8c091f0521044cadc7f0" translate="yes" xml:space="preserve">
          <source>Valgrind analysis</source>
          <target state="translated">碾压分析</target>
        </trans-unit>
        <trans-unit id="4869177d0c589735a7d4b9114f8982fe5d26f899" translate="yes" xml:space="preserve">
          <source>Value is a BLOB that is (N-12)/2 bytes in length.</source>
          <target state="translated">值是一个长度为(N-12)/2字节的BLOB。</target>
        </trans-unit>
        <trans-unit id="5d5aa2bdd2060b855e479d53c2581cc8223ca5a6" translate="yes" xml:space="preserve">
          <source>Value is a NULL.</source>
          <target state="translated">值是一个NULL。</target>
        </trans-unit>
        <trans-unit id="c499129fd21c535eaa7f12c5970a992328cc9e08" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 16-bit twos-complement integer.</source>
          <target state="translated">值是一个大写的16位双补码整数。</target>
        </trans-unit>
        <trans-unit id="e70cb145efe11c54bff7a396cfac28a6df7474e8" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 24-bit twos-complement integer.</source>
          <target state="translated">值是一个大写的24位双补码整数。</target>
        </trans-unit>
        <trans-unit id="5e8e5ccfe7344d0d3d0abc79f36a5fdb932a3b7c" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 32-bit twos-complement integer.</source>
          <target state="translated">值是一个大写的32位双补码整数。</target>
        </trans-unit>
        <trans-unit id="b3f234aeea73b3135246f413e61277eaccb53eb8" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 48-bit twos-complement integer.</source>
          <target state="translated">值是一个48位双补码的大迭代整数。</target>
        </trans-unit>
        <trans-unit id="af2248db1aa0f6b54f70fbd4bad24187360977fd" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 64-bit twos-complement integer.</source>
          <target state="translated">值是一个64位的双补码大写字母整数。</target>
        </trans-unit>
        <trans-unit id="ae871c1581e8a49ebac1c7419a009e8fb57a2d5e" translate="yes" xml:space="preserve">
          <source>Value is a big-endian IEEE 754-2008 64-bit floating point number.</source>
          <target state="translated">值是一个大写的IEEE 754-2008 64位浮点数。</target>
        </trans-unit>
        <trans-unit id="02f41d10900d18e2f000b1b5a2e593cf69aeca4b" translate="yes" xml:space="preserve">
          <source>Value is a string in the &lt;a href=&quot;fileformat2#enc&quot;&gt;text encoding&lt;/a&gt; and (N-13)/2 bytes in length. The nul terminator is not stored.</source>
          <target state="translated">值是&lt;a href=&quot;fileformat2#enc&quot;&gt;文本编码&lt;/a&gt;的字符串，长度为（N-13）/ 2个字节。不存储nul终止符。</target>
        </trans-unit>
        <trans-unit id="d4c71d03558220fa7cbe0d35d7582077b87759fd" translate="yes" xml:space="preserve">
          <source>Value is an 8-bit twos-complement integer.</source>
          <target state="translated">值是一个8位双补整数。</target>
        </trans-unit>
        <trans-unit id="21a8bbbdb0477e77f764478e79099dc10eca1b5a" translate="yes" xml:space="preserve">
          <source>Value is the integer 0. (Only available for &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format&lt;/a&gt; 4 and higher.)</source>
          <target state="translated">值是整数0。（仅适用于&lt;a href=&quot;fileformat2#schemaformat&quot;&gt;架构格式&lt;/a&gt; 4和更高版本。）</target>
        </trans-unit>
        <trans-unit id="4b218cb556caba65180a69703c18a8657584030f" translate="yes" xml:space="preserve">
          <source>Value is the integer 1. (Only available for &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format&lt;/a&gt; 4 and higher.)</source>
          <target state="translated">值是整数1。（仅适用于&lt;a href=&quot;fileformat2#schemaformat&quot;&gt;架构格式&lt;/a&gt; 4和更高版本。）</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="b74a3f9a59a12c1f692032bcd73742874ff821bd" translate="yes" xml:space="preserve">
          <source>Values for sqlite3session_config()</source>
          <target state="translated">sqlite3session_config()的值。</target>
        </trans-unit>
        <trans-unit id="bc12625ab4c97d74dcdc9d561aba55de6f3648e6" translate="yes" xml:space="preserve">
          <source>Values for sqlite3session_config().</source>
          <target state="translated">sqlite3session_config()的值。</target>
        </trans-unit>
        <trans-unit id="21fb70cd308e717f82d11db0a79a04443511207e" translate="yes" xml:space="preserve">
          <source>Values of N between 100 and 1000 are recommended. Or, to disable the analysis limit, causing ANALYZE to do a complete scan of each index, set the analysis limit to 0. The default value for the analysis limit is 0 for backwards compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b975fa21a49b294e75ba8fe14419189c4abab11" translate="yes" xml:space="preserve">
          <source>Values stored in unindexed columns are not eligible to match MATCH operators. They do not influence the results of the offsets() or matchinfo() auxiliary functions. Nor will the snippet() function ever return a snippet based on a value stored in an unindexed column.</source>
          <target state="translated">存储在非索引列中的值没有资格匹配MATCH操作符。它们不会影响offsets()或matchinfo()辅助函数的结果。snippet()函数也不会返回一个基于存储在非索引列中的值的片段。</target>
        </trans-unit>
        <trans-unit id="c15b50c2bdb6ec892f0c03794f814403120328ad" translate="yes" xml:space="preserve">
          <source>Values that may be passed as the second argument to a conflict-handler.</source>
          <target state="translated">可作为第二个参数传递给冲突处理程序的值。</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="51a317c7ddc79a1154219a293b13d3647c7088e1" translate="yes" xml:space="preserve">
          <source>Various bug fixes and documentation updates.</source>
          <target state="translated">各种错误修复和文档更新。</target>
        </trans-unit>
        <trans-unit id="d5f06a4766a5315e31c33eb58743a7e83afa9adb" translate="yes" xml:space="preserve">
          <source>Various bug fixes and optimizations</source>
          <target state="translated">各种错误修复和优化</target>
        </trans-unit>
        <trans-unit id="85d7c8482bd4c4d0eab034cc91f2ea5f21b20d90" translate="yes" xml:space="preserve">
          <source>Various bug fixes in the &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt; tool.</source>
          <target state="translated">&lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt;工具中的各种错误修复。</target>
        </trans-unit>
        <trans-unit id="ecec24b66500dbd17ba7725547d5521b2d6d2040" translate="yes" xml:space="preserve">
          <source>Various code refactorizations for performance</source>
          <target state="translated">为提高性能而进行的各种代码重构</target>
        </trans-unit>
        <trans-unit id="85976ded19739ce2942c54c82204b742186a7556" translate="yes" xml:space="preserve">
          <source>Various compiler compatibility fixes.</source>
          <target state="translated">各种编译器兼容性修复。</target>
        </trans-unit>
        <trans-unit id="ab65a12d6caf25bdc60a4edee517dc1ebef7b909" translate="yes" xml:space="preserve">
          <source>Various improvements in how the query planner uses &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; information to estimate plan costs.</source>
          <target state="translated">查询计划程序如何使用&lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;信息来估计计划成本，进行了各种改进。</target>
        </trans-unit>
        <trans-unit id="03823e5b502773a079a3bee8b39ca22cddaecb57" translate="yes" xml:space="preserve">
          <source>Various minor bug and documentation typo fixes and performance enhancements.</source>
          <target state="translated">各种小的bug和文档排版修复以及性能提升。</target>
        </trans-unit>
        <trans-unit id="10b44287786294b34c89472b1d33c638e18576ac" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes</source>
          <target state="translated">各种小错误修复</target>
        </trans-unit>
        <trans-unit id="3f779a48c89979c93ac37abe87c5a7687464bc7d" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes and documentation enhancements.</source>
          <target state="translated">各种小的bug修复和文档增强。</target>
        </trans-unit>
        <trans-unit id="4847f53fde0fb417d8d4a76ab68b44562fd9a573" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes and performance enhancements.</source>
          <target state="translated">各种小bug修复和性能提升。</target>
        </trans-unit>
        <trans-unit id="95ba96bcd2bbb545050ce738d48cb5ec939831b2" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes including fixes for tickets &lt;a href=&quot;https://www.sqlite.org/src/info/8f157e8010b22af0&quot;&gt;8f157e8010b22af0&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/info/9fb26d37cefaba40&quot;&gt;9fb26d37cefaba40&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/info/e367f31901ea8700&quot;&gt;e367f31901ea8700&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/info/b706351ce2ecf59a&quot;&gt;b706351ce2ecf59a&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/info/7c6d876f84e6e7e2&quot;&gt;7c6d876f84e6e7e2&lt;/a&gt;, and &lt;a href=&quot;https://www.sqlite.org/src/info/c8d3b9f0a750a529&quot;&gt;c8d3b9f0a750a529&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d9299a31e992a8798950b9ee230e2efd3cac0b2" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes.</source>
          <target state="translated">各种小BUG的修复。</target>
        </trans-unit>
        <trans-unit id="2514c8b40a668dc1475dfd0f9f137b0141e179e2" translate="yes" xml:space="preserve">
          <source>Various performance improvements.</source>
          <target state="translated">各种性能改进。</target>
        </trans-unit>
        <trans-unit id="6342eea4c52b8714f01d87ea8795935f65636135" translate="yes" xml:space="preserve">
          <source>Verify that an Abort can happen. Assert if an Abort at this point might cause database corruption. This opcode only appears in debugging builds.</source>
          <target state="translated">验证是否会发生Abort。断言此时的Abort是否会导致数据库损坏。这个操作码只出现在调试构建中。</target>
        </trans-unit>
        <trans-unit id="0e121d547f14e098984e65cce93a4f32d31bdccc" translate="yes" xml:space="preserve">
          <source>Version 1.0.X of SQLite used the GDBM library as its backend interface to the disk. Beginning in version 2.0.0, GDBM was replaced by a custom B-Tree library written especially for SQLite. The new B-Tree backend is twice as fast as GDBM, supports atomic commits and rollback, and stores an entire database in a single disk file instead using a separate file for each table as GDBM does. The two file formats are not even remotely similar.</source>
          <target state="translated">1.0.X版本的SQLite使用GDBM库作为其与磁盘的后端接口。从2.0.0版本开始,GDBM被一个专门为SQLite编写的自定义B-Tree库所取代。新的B-Tree后端速度是GDBM的两倍,支持原子提交和回滚,并且将整个数据库存储在一个磁盘文件中,而不是像GDBM那样为每个表使用一个单独的文件。这两种文件格式根本没有任何相似之处。</target>
        </trans-unit>
        <trans-unit id="15147c06759c9052778bf2211d35cc6a76e87f68" translate="yes" xml:space="preserve">
          <source>Version 2.2.0 and later of the library will automatically detect when it is reading a 2.1.x database and will disable the new INTEGER PRIMARY KEY feature. In other words, version 2.2.x is backwards compatible to version 2.1.x. But version 2.1.x is not forward compatible with version 2.2.x. If you try to open a 2.2.x database with an older 2.1.x library and that database contains an INTEGER PRIMARY KEY, you will likely get a coredump. If the database schema does not contain any INTEGER PRIMARY KEYs, then the version 2.1.x and version 2.2.x database files will be identical and completely interchangeable.</source>
          <target state="translated">2.2.0及以后版本的库将自动检测到它正在读取2.1.x数据库,并将禁用新的INTEGER PRIMARY KEY功能。换句话说,2.2.x版本向后兼容2.1.x版本,但2.1.x版本与2.2.x版本不向前兼容。如果你试图用旧的2.1.x库打开一个2.2.x数据库,而该数据库包含一个INTEGER PRIMARY KEY,你可能会得到一个coredump。如果数据库模式不包含任何INTEGER PRIMARY KEY,那么2.1.x版本和2.2.x版本的数据库文件将是相同的,完全可以互换。</target>
        </trans-unit>
        <trans-unit id="0117d508d1c578c143be74741c597fcb4aa7a934" translate="yes" xml:space="preserve">
          <source>Version 2.6.0 or later of the library cannot open read-only database files from version 2.5.6 or earlier, since read-only files cannot be upgraded to the new format.</source>
          <target state="translated">2.6.0或更高版本的库不能打开2.5.6或更早版本的只读数据库文件,因为只读文件不能升级到新格式。</target>
        </trans-unit>
        <trans-unit id="b22eaca7a28d27b61c642146bfe60e035fc837b9" translate="yes" xml:space="preserve">
          <source>Version 2.8.0 introduces a change to the format of the rollback journal file. The main database file format is unchanged. Versions 2.7.6 and earlier can read and write 2.8.0 databases and vice versa. Version 2.8.0 can rollback a transaction that was started by version 2.7.6 and earlier. But version 2.7.6 and earlier cannot rollback a transaction started by version 2.8.0 or later.</source>
          <target state="translated">2.8.0版本对回滚日志文件的格式进行了修改。主数据库文件的格式没有变化。2.7.6及以前的版本可以读写2.8.0数据库,反之亦然。2.8.0版本可以回滚一个由2.7.6和更早版本启动的事务。但2.7.6和更早的版本不能回滚2.8.0或更早版本启动的事务。</target>
        </trans-unit>
        <trans-unit id="5ab1c612d2172f97ee17ccb094511130795e0e49" translate="yes" xml:space="preserve">
          <source>Version 3.0.0 is a major upgrade for SQLite that incorporates support for UTF-16, BLOBs, and a more compact encoding that results in database files that are typically 25% to 50% smaller. The new file format is very different and is completely incompatible with the version 2 file format.</source>
          <target state="translated">3.0.0版本是SQLite的重大升级,它加入了对UTF-16、BLOBs的支持,并采用了更紧凑的编码,使数据库文件通常减少25%到50%。新的文件格式与第2版的文件格式非常不同,完全不兼容。</target>
        </trans-unit>
        <trans-unit id="560474f7906b0238187c7f7b7f4ee43ef0381a4c" translate="yes" xml:space="preserve">
          <source>Version 3.10.0 introduced a case-folding bug in the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator which is fixed by this patch release. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/80369eddd5c94&quot;&gt;80369eddd5c94&lt;/a&gt;.</source>
          <target state="translated">版本3.10.0引入了&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;运算符中的案例折叠错误，此补丁版本已修复该错误。机票&lt;a href=&quot;https://www.sqlite.org/src/info/80369eddd5c94&quot;&gt;80369eddd5c94&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="09330c4007db255bbeea2ef8f69d34761c5d8efc" translate="yes" xml:space="preserve">
          <source>Version 3.5.0 of SQLite changes the behavior of a few APIs in ways that are technically incompatible. However, these APIs are seldom used and even when they are used it is difficult to imagine a scenario where the change might break something. The changes actually makes these interface much more useful and powerful.</source>
          <target state="translated">SQLite 3.5.0版本改变了一些API的行为,在技术上是不兼容的。然而,这些API很少被使用,即使使用它们,也很难想象改变会破坏什么的场景。这些变化实际上让这些接口变得更加有用和强大。</target>
        </trans-unit>
        <trans-unit id="621e552e91497473887ee98c411a17ae0c22faad" translate="yes" xml:space="preserve">
          <source>Version Change</source>
          <target state="translated">版本变更</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
