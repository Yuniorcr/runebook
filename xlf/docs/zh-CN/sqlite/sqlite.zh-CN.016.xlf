<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="0137a1cc90b7f7f164b60d3e6a0abb13294403cf" translate="yes" xml:space="preserve">
          <source>The functionality provided by the fts4aux module is now provided by &lt;a href=&quot;fts5#the_fts5vocab_virtual_table_module&quot;&gt;fts5vocab&lt;/a&gt;. The schema of these two tables is slightly different.</source>
          <target state="translated">fts5vocab现在提供了fts4aux模块提供的&lt;a href=&quot;fts5#the_fts5vocab_virtual_table_module&quot;&gt;功能&lt;/a&gt;。这两个表的架构略有不同。</target>
        </trans-unit>
        <trans-unit id="82f4a608941f31ed6516bc837d2ee3e175fc4792" translate="yes" xml:space="preserve">
          <source>The functionality required of each of the above functions is described in comments in sqlite3async.c.</source>
          <target state="translated">以上每个函数所需的功能在sqlite3async.c的注释中都有描述。</target>
        </trans-unit>
        <trans-unit id="a3e3ee73e4504a9b18df3710202691563a7ae8e5" translate="yes" xml:space="preserve">
          <source>The general purpose memory allocator is the most difficult memory pool to manage because it supports allocations of varying sizes. Since &lt;b&gt;n&lt;/b&gt; is a multiplier on &lt;b&gt;M&lt;/b&gt; we want to keep &lt;b&gt;n&lt;/b&gt; as small as possible. This argues for keeping the minimum allocation size for &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; as large as possible. In most applications, the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; is able to handle small allocations. So it is reasonable to set the minimum allocation size for &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; to 2, 4 or even 8 times the maximum size of a lookaside allocation. A minimum allocation size of 512 is a reasonable setting.</source>
          <target state="translated">通用内存分配器是最难管理的内存池，因为它支持大小不同的分配。由于&lt;b&gt;n&lt;/b&gt;是&lt;b&gt;M&lt;/b&gt;的乘数，因此我们要使&lt;b&gt;n&lt;/b&gt;尽可能小。这&lt;a href=&quot;malloc#memsys5&quot;&gt;表明应将memsys5&lt;/a&gt;的最小分配大小保持尽可能大。在大多数应用程序中，&lt;a href=&quot;malloc#lookaside&quot;&gt;后备内存分配器&lt;/a&gt;能够处理少量分配。因此，将&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;的最小分配大小设置为后备分配最大大小的2倍，4倍甚至8倍是合理的。最小分配大小为512是合理的设置。</target>
        </trans-unit>
        <trans-unit id="30bdbd95e17bffd329d217ead465e3fe28cd023c" translate="yes" xml:space="preserve">
          <source>The general rule is that indexes are only useful if there are WHERE-clause constraints on the left-most columns of the index. However, in some cases, SQLite is able to use an index even if the first few columns of the index are omitted from the WHERE clause but later columns are included.</source>
          <target state="translated">一般的规则是,只有在索引的最左边的列上有WHERE子句约束时,索引才有用。然而,在某些情况下,即使在WHERE子句中省略了索引的前几列,但包含了后面的列,SQLite也能够使用索引。</target>
        </trans-unit>
        <trans-unit id="084577b6dd782fa1eb4651ff451c238f84ef2391" translate="yes" xml:space="preserve">
          <source>The general-purpose memory allocator (&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;).</source>
          <target state="translated">通用内存分配器（&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="21a012c95267cb8d2b8d45dbbd928793f6616b70" translate="yes" xml:space="preserve">
          <source>The generate_series Table-Valued Function</source>
          <target state="translated">generate_series 表值函数</target>
        </trans-unit>
        <trans-unit id="476dfd7c8482f7d1208e7bd9537292c089264e39" translate="yes" xml:space="preserve">
          <source>The generate_series table can be simulated using a &lt;a href=&quot;lang_with#recursivecte&quot;&gt;recursive common table expression&lt;/a&gt;. If the three parameters are $start, $end, and $step, then the equivalent common table expression is:</source>
          <target state="translated">可以使用&lt;a href=&quot;lang_with#recursivecte&quot;&gt;递归公用表表达式&lt;/a&gt;来模拟generate_series表。如果三个参数分别是$ start，$ end和$ step，则等效的公用表表达式为：</target>
        </trans-unit>
        <trans-unit id="4e3c394ee97ca6ac89b21ae3983e2fd5668b4aa8" translate="yes" xml:space="preserve">
          <source>The generate_series(START,END,STEP) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; included in the SQLite source tree, and compiled into the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;. The generate_series() table has a single result column named &quot;value&quot; holding integer values and a number of rows determined by the parameters START, END, and STEP. The first row of the table has a value of START. Subsequent rows increase by STEP up to END.</source>
          <target state="translated">generate_series（START，END，STEP）&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;是SQLite源树中包含的&lt;a href=&quot;loadext&quot;&gt;可加载扩展&lt;/a&gt;，并已编译到&lt;a href=&quot;cli&quot;&gt;命令行shell中&lt;/a&gt;。generate_series（）表具有一个名为&amp;ldquo; value&amp;rdquo;的单个结果列，其中包含整数值，并且包含由参数START，END和STEP确定的行数。该表的第一行的值为START。随后的行按STEP递增，直到END。</target>
        </trans-unit>
        <trans-unit id="3f2ed0d414c19e451dbd160a6e3115271ef19a02" translate="yes" xml:space="preserve">
          <source>The geopoly module defines several new SQL functions that are useful for dealing with polygons. All polygon arguments to these functions can be either the GeoJSON format or the internal binary format.</source>
          <target state="translated">geopoly模块定义了几个新的SQL函数,这些函数对处理多边形很有用。这些函数的所有多边形参数可以是GeoJSON格式或内部二进制格式。</target>
        </trans-unit>
        <trans-unit id="8d993a3d44bf40860242bebc1265b2783cf9c63f" translate="yes" xml:space="preserve">
          <source>The geopoly module is an extension to the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;. Geopoly uses the same underlying logic and shadow tables as the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;. Geopoly merely presents a different interface, and provides some extra logic to compute polygon decoding, overlap, and containment.</source>
          <target state="translated">geopoly模块是&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展的扩展&lt;/a&gt;。Geopoly使用与&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展&lt;/a&gt;相同的基础逻辑和影子表。Geopoly仅提供了一个不同的界面，并提供了一些额外的逻辑来计算多边形解码，重叠和包含。</target>
        </trans-unit>
        <trans-unit id="acb138b945d23f00cd83af917d94b141700de307" translate="yes" xml:space="preserve">
          <source>The geopoly module is built on top of the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; and uses the same underlying shadow tables and algorithms. For indexing purposes, each polygon is represented in the shadow tables as a rectangular bounding box. The underlying R-Tree implementation uses bounding boxes to limit the search space. Then the geoploy_overlap() and/or geopoly_within() routines further refine the search to the exact answer.</source>
          <target state="translated">地理多边形模块建立在&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展的&lt;/a&gt;顶部，并使用相同的基础阴影表和算法。为了建立索引，每个多边形在阴影表中均表示为矩形边界框。底层的R-Tree实现使用边界框来限制搜索空间。然后，geoploy_overlap（）和/或geopoly_within（）例程将搜索进一步优化为确切的答案。</target>
        </trans-unit>
        <trans-unit id="fdb9ae6360ea866b8222993691854e31ea695989" translate="yes" xml:space="preserve">
          <source>The geopoly_ccw(J) function returns the polygon J with counter-clockwise (CCW) rotation.</source>
          <target state="translated">geopoly_ccw(J)函数返回逆时针(CCW)旋转的多边形J。</target>
        </trans-unit>
        <trans-unit id="58be5b36690d1c8a61ca619684c9087df6d3c79c" translate="yes" xml:space="preserve">
          <source>The geopoly_group_bbox(P) function is an aggregate version of geopoly_bbox(P). The geopoly_group_bbox(P) function returns the smallest rectangle that will enclose all P values seen during aggregation.</source>
          <target state="translated">geopoly_group_bbox(P)函数是geopoly_bbox(P)的集合版本。geopoly_group_bbox(P)函数返回在聚合过程中所有P值的最小矩形。</target>
        </trans-unit>
        <trans-unit id="7aa31a665e34b0f93544b760a7bd5d5549c54d97" translate="yes" xml:space="preserve">
          <source>The geopoly_overlap(P1,P2) function is special in that the geopoly virtual table knows how to use R*Tree indexes to optimize queries in which the WHERE clause uses geopoly_overlap() as a boolean function. Only the geopoly_overlap(P1,P2) and geopoly_within(P1,P2) functions have this capability.</source>
          <target state="translated">geopoly_overlap(P1,P2)函数的特殊之处在于,geopoly虚拟表知道如何使用R*Tree索引来优化查询,其中WHERE子句使用geopoly_overlap()作为布尔函数。只有geopoly_overlap(P1,P2)和geopoly_within(P1,P2)函数具有这种能力。</target>
        </trans-unit>
        <trans-unit id="4552cf5a5f2e459423714152983f2ca48f86f169" translate="yes" xml:space="preserve">
          <source>The geopoly_regular(X,Y,R,N) function returns a convex, simple, regular, equilateral, equiangular polygon with N sides, centered at X,Y, and with a circumradius of R. Or, if R is negative or if N is less than 3, the function returns NULL. The N value is capped at 1000 so that the routine will never render a polygon with more than 1000 sides even if the N value is larger than 1000.</source>
          <target state="translated">geopoly_regular(X,Y,R,N)函数返回一个以X,Y为中心,周长为R的具有N条边的凸面、简单、规则、等边、等角的多边形,或者,如果R为负值或者N小于3,函数返回NULL。N值的上限为1000,因此即使N值大于1000,该例程也不会渲染一个边数超过1000的多边形。</target>
        </trans-unit>
        <trans-unit id="01eba492c4ddd36076bba0e9fe7c2f9d9c526116" translate="yes" xml:space="preserve">
          <source>The geopoly_within(P1,P2) function is special in that the geopoly virtual table knows how to use R*Tree indexes to optimize queries in which the WHERE clause uses geopoly_within() as a boolean function. Only the geopoly_within(P1,P2) and geopoly_overlap(P1,P2) functions have this capability.</source>
          <target state="translated">geopoly_within(P1,P2)函数的特殊之处在于,geopoly虚拟表知道如何使用R*Tree索引来优化查询,其中WHERE子句使用geopoly_within()作为布尔函数。只有geopoly_within(P1,P2)和geopoly_overlap(P1,P2)函数具有这种能力。</target>
        </trans-unit>
        <trans-unit id="45313c37ef01af04ca79cf8e508d2efcd3ced709" translate="yes" xml:space="preserve">
          <source>The geopoly_xform(P,A,B,C,D,E,F) function returns a new polygon that is an affine transformation of the polygon P and where the transformation is defined by values A,B,C,D,E,F. If P is not a valid polygon, this routine returns NULL.</source>
          <target state="translated">geopoly_xform(P,A,B,C,D,E,F)函数返回一个新的多边形,这个多边形是多边形P的仿射变换,变换的定义是A,B,C,D,E,F。如果P不是一个有效的多边形,这个例程返回NULL。</target>
        </trans-unit>
        <trans-unit id="8a7538a75bac0dc91c968f2f943ef8c77b915108" translate="yes" xml:space="preserve">
          <source>The glob(X,Y) function is equivalent to the expression &quot;&lt;b&gt;Y GLOB X&lt;/b&gt;&quot;. Note that the X and Y arguments are reversed in the glob() function relative to the infix &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator. Y is the string and X is the pattern. So, for example, the following expressions are equivalent:</source>
          <target state="translated">glob（X，Y）函数等效于表达式&amp;ldquo; &lt;b&gt;Y GLOB X&lt;/b&gt; &amp;rdquo;。请注意，相对于中缀&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;运算符，glob（）函数中的X和Y参数是相反的。Y是字符串，X是模式。因此，例如，以下表达式是等效的：</target>
        </trans-unit>
        <trans-unit id="57af892941202e82d82f19e609a84ccb0531eaad" translate="yes" xml:space="preserve">
          <source>The goal is to make SQLite handle NULLs in a standards-compliant way. But the descriptions in the SQL standards on how to handle NULLs seem ambiguous. It is not clear from the standards documents exactly how NULLs should be handled in all circumstances.</source>
          <target state="translated">目标是让SQLite以符合标准的方式处理NULLs。但是SQL标准中关于如何处理NULLs的描述似乎很模糊。从标准文档中看不出在所有情况下到底应该如何处理NULLs。</target>
        </trans-unit>
        <trans-unit id="2ba0147df5ada0e089bdabaebc1a5094f5e9a20f" translate="yes" xml:space="preserve">
          <source>The goal of this query is to compute some value for the five most recent entries in the table. But in the query above, the &quot;expensive_function()&quot; is invoked prior to the sort and thus is invoked on every row of the table, even rows that are ultimately omitted due to the LIMIT clause. A co-routine can be used to work around this:</source>
          <target state="translated">这个查询的目标是为表中最近的五个条目计算一些值。但是在上面的查询中,&quot; expensive_function()&quot;是在排序之前被调用的,因此在表中的每一条记录上都会被调用,甚至是由于limit子句而最终被省略的记录。可以使用一个联合程序来解决这个问题。</target>
        </trans-unit>
        <trans-unit id="27130ed911ba5b72cf5d70b6f38c66e3447f97b9" translate="yes" xml:space="preserve">
          <source>The grammar syntax is less error prone - using symbolic names for semantic values rather that the &quot;$1&quot;-style positional notation of Yacc.</source>
          <target state="translated">语法不容易出错--使用符号名来表示语义值,而不是Yacc的 &quot;1美元 &quot;式的位置符号。</target>
        </trans-unit>
        <trans-unit id="8288ae8eb06e54b34a1335f8c6fbfb99327b7542" translate="yes" xml:space="preserve">
          <source>The graph below shows the number of CPU cycles used by SQLite on a standard workload, for versions of SQLite going back about 10 years. Recent versions of SQLite use about one third as many the CPU cycles compared to older versions.</source>
          <target state="translated">下图显示了SQLite在标准工作负载上使用的CPU周期数,对于SQLite的版本可以追溯到10年前。与旧版本相比,最新版本的SQLite所使用的CPU周期约为三分之一。</target>
        </trans-unit>
        <trans-unit id="ea3dfc83e3fad7e5da84aa92171fa1f2ebb6adae" translate="yes" xml:space="preserve">
          <source>The group_concat() function returns a string which is the concatenation of all non-NULL values of</source>
          <target state="translated">group_concat()函数返回一个字符串,这个字符串是所有非NULL值的连接。</target>
        </trans-unit>
        <trans-unit id="998c879f2d9a4a324ed589705e44b7743eed8ace" translate="yes" xml:space="preserve">
          <source>The group_concat(x,'') SQL function returns NULL instead of an empty string when all inputs are empty strings. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/55746f9e65f85&quot;&gt;55746f9e65&lt;/a&gt;</source>
          <target state="translated">当所有输入均为空字符串时，group_concat（x，''）SQL函数将返回NULL而不是空字符串。机票&lt;a href=&quot;http://www.sqlite.org/src/info/55746f9e65f85&quot;&gt;55746F9E65&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3cc69e429ade6ced467dc065c3703a231254bc0f" translate="yes" xml:space="preserve">
          <source>The handling of IN and NOT IN operators that contain a NULL on their right-hand side expression is brought into compliance with the SQL standard and with other SQL database engines. This is a bug fix, but as it has the potential to break legacy applications that depend on the older buggy behavior, we mark that as a *** Potentially incompatible change ***</source>
          <target state="translated">IN 和 NOT IN 运算符的处理,如果在其右侧表达式中包含 NULL,则符合 SQL 标准和其他 SQL 数据库引擎。这是一个bug修复,但由于它有可能破坏依赖于旧的bug行为的遗留应用程序,我们将其标记为***潜在的不兼容变化***。</target>
        </trans-unit>
        <trans-unit id="d0efc6030fa81d141b43a701523b55c7bcf660fd" translate="yes" xml:space="preserve">
          <source>The hash tables in the shm file are designed to answer the following question quickly:</source>
          <target state="translated">shm文件中的哈希表是为了快速回答以下问题而设计的。</target>
        </trans-unit>
        <trans-unit id="2856b370cad55dc7412b44b6f210c8cf053331d6" translate="yes" xml:space="preserve">
          <source>The hashes that identify check-ins and files on the Git mirror are different from the hashes in Fossil. There are many reasons for this, chief among them that Fossil uses a SHA3-256 hash whereas Git uses a SHA1 hash. During export, the original Fossil hash for each check-in is added as a footer to check-in comments. To avoid confusion, always use the original Fossil hash, not the Git hash, when referring to SQLite check-ins.</source>
          <target state="translated">Git 镜像上识别签到和文件的哈希值与 Fossil 的哈希值不同。这有很多原因,其中最主要的原因是 Fossil 使用的是 SHA3-256 哈希值,而 Git 使用的是 SHA1 哈希值。在导出过程中,每个签入的Fossil原始哈希值会被添加到签入注释的脚注中。为了避免混淆,在引用 SQLite 检查记录时,请使用 Fossil 的原始哈希值,而不是 Git 的哈希值。</target>
        </trans-unit>
        <trans-unit id="e115da518074674c7bed9606a1f3c39c1334b0dc" translate="yes" xml:space="preserve">
          <source>The header of the rollback journal can be overwritten with invalid header text (for example, all zeros).</source>
          <target state="translated">回滚日志的头可以用无效的头文字(例如,全部为零)覆盖。</target>
        </trans-unit>
        <trans-unit id="328251bbc9b91a18ef755ecd2993b4b5eb3cf221" translate="yes" xml:space="preserve">
          <source>The header of the rollback journal is well-formed and in particular has not been zeroed out.</source>
          <target state="translated">回滚期刊的刊头成型良好,特别是没有被清零。</target>
        </trans-unit>
        <trans-unit id="8908758df6621b583f7634e3a00bc808f16a9ffb" translate="yes" xml:space="preserve">
          <source>The header size varint and serial type varints will usually consist of a single byte. The serial type varints for large strings and BLOBs might extend to two or three byte varints, but that is the exception rather than the rule. The varint format is very efficient at coding the record header.</source>
          <target state="translated">头部大小变位符和序列类型变位符通常由一个字节组成。大字符串和BLOB的序列类型变位数可能会扩展到两个或三个字节的变位数,但这是例外而不是规则。varint格式对记录头的编码非常有效。</target>
        </trans-unit>
        <trans-unit id="6a561080aa600994c95f7609f8c9a76e07664cc1" translate="yes" xml:space="preserve">
          <source>The header string: &quot;SQLite format 3\000&quot;</source>
          <target state="translated">标题字符串:&quot;SQLite format 3\000&quot;</target>
        </trans-unit>
        <trans-unit id="9618d06778e016225462d5681eb6b291f7c80aa5" translate="yes" xml:space="preserve">
          <source>The heap limits are not enforced in the current implementation if one or more of following conditions are true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95f9212fdc8a88cf98b4e1490976ec2f7354c6a2" translate="yes" xml:space="preserve">
          <source>The heavy wrapper employed by &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; is intended for use only during testing, analysis, and debugging of SQLite. The heavy wrapper has a significant performance and memory overhead and probably should not be used in production.</source>
          <target state="translated">&lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt;使用的重包装仅适用于SQLite的测试，分析和调试。繁重的包装程序具有显着的性能和内存开销，因此可能不应该在生产中使用。</target>
        </trans-unit>
        <trans-unit id="eb4610f1226d8f274f85d7debe217f5d65427f90" translate="yes" xml:space="preserve">
          <source>The heavy wrapper that is used when &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; is set also makes sure each new allocation is filled with nonsense data prior to returning the allocation to the caller. And as soon as an allocation is free, it is again filled with nonsense data. These two actions help to ensure that the SQLite core does not make assumptions about the state of newly allocated memory and that memory allocations are not used after they have been freed.</source>
          <target state="translated">设置&lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt;时使用的重包装器还可以确保在将分配返回给调用者之前，每个新分配都被无用数据填充。一旦分配是免费的，它就会再次被废话数据填充。这两个动作有助于确保SQLite核心不对新分配的内存状态做出假设，并且确保释放内存后不使用内存分配。</target>
        </trans-unit>
        <trans-unit id="a33b86543e89aa7fc91f1c01c079a10eabc5b26c" translate="yes" xml:space="preserve">
          <source>The hex() function interprets its argument as a BLOB and returns a string which is the upper-case hexadecimal rendering of the content of that blob.</source>
          <target state="translated">hex()函数将其参数解释为BLOB,并返回一个字符串,该字符串是该blob内容的大写十六进制渲染。</target>
        </trans-unit>
        <trans-unit id="47e9ec1a2ca9f6468b5d5ea9dca27a7ef3e3db0a" translate="yes" xml:space="preserve">
          <source>The high repeatability of cachegrind allows the SQLite developers to implement and measure &quot;microoptimizations&quot;. A microoptimization is a change to the code that results in a very small performance increase. Typical micro-optimizations reduce the number of CPU cycles by 0.1% or 0.05% or even less. Such improvements are impossible to measure with real-world timings. But hundreds or thousands of microoptimizations add up, resulting in measurable real-world performance gains.</source>
          <target state="translated">cachegrind的高重复性使得SQLite开发人员可以实现和测量 &quot;微优化&quot;。微优化是指对代码进行修改,使其性能得到很小的提升。典型的微优化可以减少0.1%或0.05%甚至更少的CPU周期数。这样的改进是无法用真实世界的时序来衡量的。但数百或数千次的微优化累积起来,就会产生可衡量的实际性能提升。</target>
        </trans-unit>
        <trans-unit id="8ccb63c8eb8186df2591985e1dd0399f9de8ed53" translate="yes" xml:space="preserve">
          <source>The high-reliability of SQLite is proven in practice. SQLite has been used without problems in multiple billions of smart-phones, IoT devices, and desktop applications, around the world, and for almost two decades.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8285d1c1b74bc88c5caec05770baddba5bd483b5" translate="yes" xml:space="preserve">
          <source>The high-reliability of SQLite is proven in practice. SQLite has been used without problems in multiple billions of smart-phones, IoT devices, and desktop applications, around the world, and for over a decade.</source>
          <target state="translated">SQLite的高可靠性在实践中得到了验证。SQLite已经在全球多亿部智能手机、物联网设备和桌面应用中顺利使用,并且已经使用了十几年。</target>
        </trans-unit>
        <trans-unit id="f6fadaee687e9cfda1c93f7fa51b5ba3b3240bd6" translate="yes" xml:space="preserve">
          <source>The highlight() function returns a copy of the text from a specified column of the current row with extra markup text inserted to mark the start and end of phrase matches.</source>
          <target state="translated">Highlight()函数从当前行的指定列中返回一份文本的副本,并插入额外的标记文本来标记短语匹配的开始和结束。</target>
        </trans-unit>
        <trans-unit id="e43753ce0913d39afca1c9c249ea51ebaf6b6f06" translate="yes" xml:space="preserve">
          <source>The highlight() must be invoked with exactly three arguments following the table name. To be interpreted as follows:</source>
          <target state="translated">调用highlight()时,必须在表名后正好有三个参数。解释如下:</target>
        </trans-unit>
        <trans-unit id="bb9d506afb5b0054b66298f3975841775d6d258d" translate="yes" xml:space="preserve">
          <source>The histogram data is only useful if the right-hand side of the constraint is a simple compile-time constant or &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and not an expression.</source>
          <target state="translated">直方图数据仅在约束的右侧是简单的编译时常量或&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;而不是表达式的情况下才有用。</target>
        </trans-unit>
        <trans-unit id="754b3dec45709dc037212c7449e27878498a6122" translate="yes" xml:space="preserve">
          <source>The historical behavior of SQLite is incorrect according to the SQL:1999 standard and it is inconsistent with the behavior of MySQL and PostgreSQL. Version 3.6.0 changes the behavior of the IN and NOT IN operators to conform to the standard and to give the same results as other SQL database engines.</source>
          <target state="translated">根据SQL:1999标准,SQLite的历史行为是不正确的,它与MySQL和PostgreSQL的行为不一致。3.6.0版本改变了IN和NOT IN运算符的行为,以符合标准,并提供与其他SQL数据库引擎相同的结果。</target>
        </trans-unit>
        <trans-unit id="3be31364c3c06e62038927597ca88135a8ca4d7a" translate="yes" xml:space="preserve">
          <source>The iCost column is the numeric cost of transforming cFrom into cTo. This value should be a non-negative integer, and should probably be less than 100. The default single-character insertion and deletion costs are 100 and the default single-character to single-character substitution cost is 150. A cost of 10000 or more is considered &quot;infinite&quot; and causes the rule to be ignored.</source>
          <target state="translated">iCost列是将cFrom转换为cTo的数字成本。这个值应该是一个非负的整数,可能应该小于100。默认的单字符插入和删除成本是100,默认的单字符到单字符的替换成本是150。成本为10000或更多则被认为是 &quot;无限 &quot;的,会导致规则被忽略。</target>
        </trans-unit>
        <trans-unit id="d0b9d0aa5d29da45f0b93b40de44e2f95388c2e0" translate="yes" xml:space="preserve">
          <source>The iLang column is a non-negative integer that identifies a set of costs appropriate for a particular language. The editdist3 function will only use a single iLang value for any given edit-distance computation. The default value is 0. It is recommended that applications that only need to use a single language always use iLang==0 for all entries.</source>
          <target state="translated">iLang列是一个非负的整数,它标识了一组适合特定语言的成本。editdist3函数在任何给定的edit-distance计算中都只使用一个iLang值,默认值是0。默认值是0,建议只需要使用单一语言的应用程序总是对所有条目使用iLang==0。</target>
        </trans-unit>
        <trans-unit id="5013f8a1a10fac4a872743ceb29c353308c4297d" translate="yes" xml:space="preserve">
          <source>The iVersion field of &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; is provided as insurance against future enhancements. The iVersion value should always be 1 for SQLite version 3.5.</source>
          <target state="translated">提供&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;的iVersion字段作为将来增强功能的保证。对于SQLite版本3.5，iVersion值应始终为1。</target>
        </trans-unit>
        <trans-unit id="8b61610ddf9130372f875adae334c360bf359102" translate="yes" xml:space="preserve">
          <source>The iVersion field of &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; should be 1 for SQLite version 3.5.0. This number may increase in future versions of SQLite if we have to modify the VFS object in some way. We hope that this never happens, but the provision is made in case it does.</source>
          <target state="translated">对于SQLite版本3.5.0 ，&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;的iVersion字段应为1。如果我们必须以某种方式修改VFS对象，则在将来的SQLite版本中此数目可能会增加。我们希望这种情况永远不会发生，但会在必要时作出规定。</target>
        </trans-unit>
        <trans-unit id="ea830f2d673441ec5d80e9c5eb8623ea5999e87b" translate="yes" xml:space="preserve">
          <source>The idea behind a reserved lock is that it signals that a process intends to modify the database file in the near future but has not yet started to make the modifications. And because the modifications have not yet started, other processes can continue to read from the database. However, no other process should also begin trying to write to the database.</source>
          <target state="translated">保留锁背后的想法是,它标志着一个进程打算在不久的将来修改数据库文件,但还没有开始进行修改。而由于修改还没有开始,其他进程可以继续从数据库中读取。但是,其他进程也不应该开始尝试向数据库写入。</target>
        </trans-unit>
        <trans-unit id="b86c36b3766e07cfb666e3625925c99f4017f8b5" translate="yes" xml:space="preserve">
          <source>The idxNum and idxPtr values are recorded and passed into the &lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; is used to free idxPtr if and only if needToFreeIdxPtr is true.</source>
          <target state="translated">记录idxNum和idxPtr值，并将其传递到&lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;方法中。当且仅当needToFreeIdxPtr为true时，才使用&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放idxPtr。</target>
        </trans-unit>
        <trans-unit id="357574f6e5fd171b87a29904a513e7015690c872" translate="yes" xml:space="preserve">
          <source>The idxNum and idxPtr values are recorded and passed into the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; is used to free idxPtr if and only if needToFreeIdxPtr is true.</source>
          <target state="translated">记录idxNum和idxPtr值，并将其传递到&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;方法中。当且仅当needToFreeIdxPtr为true时，才使用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放idxPtr。</target>
        </trans-unit>
        <trans-unit id="013b479832be35dd0d8a4395d938100b93b10f74" translate="yes" xml:space="preserve">
          <source>The idxStr value may be a string obtained from an SQLite memory allocation function such as &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;. If this is the case, then the needToFreeIdxStr flag must be set to true so that the SQLite core will know to call &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; on that string when it has finished with it, and thus avoid a memory leak. The idxStr value may also be a static constant string, in which case the needToFreeIdxStr boolean should remain false.</source>
          <target state="translated">idxStr值可以是从SQLite内存分配函数（例如&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（））&lt;/a&gt;获得的字符串。如果是这种情况，那么必须将needToFreeIdxStr标志设置为true，以便SQLite内核在完成该字符串后将知道在该字符串上调用&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;，从而避免了内存泄漏。idxStr值也可以是静态常量字符串，在这种情况下，needToFreeIdxStr布尔值应保持为false。</target>
        </trans-unit>
        <trans-unit id="4d5a7e8bc386f87dedf4ba3978aa31bcde8d6916" translate="yes" xml:space="preserve">
          <source>The ifnull() function returns a copy of its first non-NULL argument, or NULL if both arguments are NULL. Ifnull() must have exactly 2 arguments. The ifnull() function is equivalent to &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt; with two arguments.</source>
          <target state="translated">ifnull（）函数返回其第一个非NULL参数的副本，如果两个参数均为NULL，则返回NULL。 Ifnull（）必须正好有2个参数。 ifnull（）函数等效于带有两个参数的&lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="003c977ed53ddacaa1a12c60c49d228fced8878c" translate="yes" xml:space="preserve">
          <source>The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise. The iif(X,Y,Z) function is logically equivalent to and generates the same &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; as the &lt;a href=&quot;lang_expr#case&quot;&gt;CASE expression&lt;/a&gt; &quot;CASE WHEN X THEN Y ELSE Z END&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46220a05919fd727bb5192ff33d2f0412a4a1656" translate="yes" xml:space="preserve">
          <source>The immutable query parameter is a boolean that signals to SQLite that the underlying database file is held on read-only media and cannot be modified, even by another process with elevated privileges. SQLite always opens immutable database files read-only and it skips all file locking and change detection on immutable database files. If these query parameter (or the &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_IMMUTABLE&lt;/a&gt; bit in xDeviceCharacteristics) asserts that a database file is immutable and that file changes anyhow, then SQLite might return incorrect query results and/or &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; errors.</source>
          <target state="translated">不可变的查询参数是一个布尔值，它向SQLite发出信号，通知其基础数据库文件位于只读介质上，并且即使具有更高特权的另一个进程也无法对其进行修改。 SQLite始终以只读方式打开不可变数据库文件，并跳过所有文件锁定并更改不可变数据库文件的更改检测。如果这些查询参数（或&lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;xDeviceCharacteristics&lt;/a&gt;中的SQLITE_IOCAP_IMMUTABLE位）断言数据库文件是不可变的，并且该文件无论如何都会发生更改，则SQLite可能返回错误的查询结果和/或&lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt;错误。</target>
        </trans-unit>
        <trans-unit id="a6b9b8cf3a7d94e9575aa22c08feee5317ab9464" translate="yes" xml:space="preserve">
          <source>The implementation for the spellfix1 virtual table is held in the SQLite source tree in the miscellaneous extensions folder and in particular in the file &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=ext/misc/spellfix.c&quot;&gt;ext/misc/spellfix1.c&lt;/a&gt;. The spellfix1 virtual table is not included in the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; and is not a part of any standard SQLite build. It is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;.</source>
          <target state="translated">spellfix1虚拟表的实现保存在SQLite源树的其他扩展文件夹中，尤其是在文件&lt;a href=&quot;http://www.sqlite.org/src/finfo?name=ext/misc/spellfix.c&quot;&gt;ext / misc / spellfix1.c中&lt;/a&gt;。spellfix1虚拟表未包含在SQLite &lt;a href=&quot;amalgamation&quot;&gt;合并中&lt;/a&gt;，也不是任何标准SQLite构建的一部分。这是一个&lt;a href=&quot;loadext&quot;&gt;可加载的扩展&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8eb5688bafc7d4405d9e0ef667e71e04726e76e8" translate="yes" xml:space="preserve">
          <source>The implementation is not required to provide versions of these routines that actually work. If the implementation does not provide working versions of these routines, it should at least provide stubs that always return true so that one does not get spurious assertion failures.</source>
          <target state="translated">不要求实施者提供这些例程的实际工作版本。如果实现不提供这些例程的工作版本,它至少应该提供总是返回true的存根,这样就不会出现虚假的断言失败。</target>
        </trans-unit>
        <trans-unit id="8b40a9e730bef66c422bb631b44b6863716defa7" translate="yes" xml:space="preserve">
          <source>The implementation is registered with the FTS5 module by calling the xCreateFunction() method of the fts5_api object. If there is already an auxiliary function with the same name, it is replaced by the new function. If a non-NULL xDestroy parameter is passed to xCreateFunction(), it is invoked with a copy of the pContext pointer passed as the only argument when the database handle is closed or when the registered auxiliary function is replaced.</source>
          <target state="translated">通过调用fts5_api对象的xCreateFunction()方法,实现在FTS5模块中注册。如果已经有一个同名的辅助函数,那么它将被新函数所取代。如果向xCreateFunction()传递了一个非NULL的xDestroy参数,那么当数据库句柄关闭或已注册的辅助函数被替换时,它将被调用,传递的pContext指针的副本作为唯一的参数。</target>
        </trans-unit>
        <trans-unit id="bbe3105d33c8a4906448b08f8925bf436af3dd67" translate="yes" xml:space="preserve">
          <source>The implementation is registered with the FTS5 module by calling the xCreateTokenizer() method of the fts5_api object. If there is already a tokenizer with the same name, it is replaced. If a non-NULL xDestroy parameter is passed to xCreateTokenizer(), it is invoked with a copy of the pContext pointer passed as the only argument when the database handle is closed or when the tokenizer is replaced.</source>
          <target state="translated">通过调用fts5_api对象的xCreateTokenizer()方法,实现在FTS5模块中注册。如果已经有一个同名的tokenizer,它将被替换。如果xCreateTokenizer()方法中传递了一个非NULL的xDestroy参数,那么当数据库句柄关闭或tokenizer被替换时,将以pContext指针的副本作为唯一的参数被调用。</target>
        </trans-unit>
        <trans-unit id="8b89a513d4c178ab8d213508b88c8e5c09e3c7a1" translate="yes" xml:space="preserve">
          <source>The implementation language for the example code is &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TCL&lt;/a&gt;, though you can easily do the same thing in another programming language. Remember that the code here is a demonstration of the technique, not a drop-in module that will automatically do everything for you. The demonstration code shown below is derived from actual code in production use. But you will need to make changes to tailor it to your application.</source>
          <target state="translated">示例代码的实现语言是&lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TCL&lt;/a&gt;，尽管您可以轻松地用另一种编程语言来做同样的事情。请记住，这里的代码是该技术的演示，而不是将自动为您做所有事情的嵌入式模块。下面显示的演示代码源自生产中的实际代码。但是您将需要进行更改以使其适合您的应用程序。</target>
        </trans-unit>
        <trans-unit id="1c7602fe1bd4486f649d10efe941c63ad9ebc01d" translate="yes" xml:space="preserve">
          <source>The implementation of this function could be enhanced in at least two ways:</source>
          <target state="translated">至少可以从两个方面加强这一功能的实施。</target>
        </trans-unit>
        <trans-unit id="fb654149d36243346cb33110dabec3f86ec0e93a" translate="yes" xml:space="preserve">
          <source>The important parts of the output (the parts that the developers pay the most attention to) are shown in red. Basically, the developers want to know the size of the compiled SQLite library and how many CPU cycles were needed to run the performance test.</source>
          <target state="translated">输出的重要部分(开发者最关注的部分)用红色显示。基本上,开发人员想知道编译后的SQLite库的大小,以及运行性能测试需要多少CPU周期。</target>
        </trans-unit>
        <trans-unit id="98a68810edc43f0319b74cd65a4602d55569695b" translate="yes" xml:space="preserve">
          <source>The imposter table mechanism is a power analysis and debugging tool for SQLite. But as with all sharp tools, it can also be dangerous and can result in corrupt database files if misused. Do not attempt to use imposter tables in an application. Imposter tables are intended for use in the laboratory by experts.</source>
          <target state="translated">冒名表机制是SQLite的一个强大的分析和调试工具。但是和所有的利器一样,它也是危险的,如果误用的话,可能会导致数据库文件的损坏。不要试图在应用程序中使用冒名表。冒牌表是供专家在实验室使用的。</target>
        </trans-unit>
        <trans-unit id="f137c1fa92f06c6d9054e4f6699dd72be9e8aeef" translate="yes" xml:space="preserve">
          <source>The in-header database size is only considered to be valid if it is non-zero and if the 4-byte &lt;a href=&quot;fileformat2#chngctr&quot;&gt;change counter&lt;/a&gt; at offset 24 exactly matches the 4-byte &lt;a href=&quot;fileformat2#validfor&quot;&gt;version-valid-for number&lt;/a&gt; at offset 92. The in-header database size is always valid when the database is only modified using recent versions of SQLite, versions 3.7.0 (2010-07-21) and later. If a legacy version of SQLite writes to the database, it will not know to update the in-header database size and so the in-header database size could be incorrect. But legacy versions of SQLite will also leave the version-valid-for number at offset 92 unchanged so it will not match the change-counter. Hence, invalid in-header database sizes can be detected (and ignored) by observing when the change-counter does not match the version-valid-for number.</source>
          <target state="translated">头内数据库大小只有在非零且偏移量为24 的4字节&lt;a href=&quot;fileformat2#chngctr&quot;&gt;更改计数器&lt;/a&gt;与偏移量92处的4字节&lt;a href=&quot;fileformat2#validfor&quot;&gt;版本有效号&lt;/a&gt;完全匹配时，才被认为是有效的。头内数据库当仅使用SQLite的最新版本3.7.0（2010-07-21）和更高版本修改数据库时，size始终有效。如果旧版本的SQLite写入数据库，它将不知道更新头中数据库的大小，因此头中数据库的大小可能不正确。但是SQLite的旧版本还将在偏移量92处保留版本有效号，因此它不会与更改计数器匹配。因此，可以通过观察更改计数器何时与版本有效期号不匹配来检测（并忽略）无效的页眉内数据库大小。</target>
        </trans-unit>
        <trans-unit id="856311d50a8fd5f75cd3339835ec40132b3ad9e1" translate="yes" xml:space="preserve">
          <source>The incremental_vacuum pragma causes up to</source>
          <target state="translated">递增式真空原则最多可以造成</target>
        </trans-unit>
        <trans-unit id="2dd53e3930b5b852ae3198064e374d5480957b02" translate="yes" xml:space="preserve">
          <source>The index is not usable at all because the left-most column of the index (column &quot;a&quot;) is not constrained. Assuming there are no other indices, the query above would result in a full table scan.</source>
          <target state="translated">该索引根本无法使用,因为该索引最左边的列(列 &quot;a&quot;)没有受到约束。假设没有其他索引,上面的查询将导致全表扫描。</target>
        </trans-unit>
        <trans-unit id="af8e63da60690ffa41a028a8c03b3a46553b1974" translate="yes" xml:space="preserve">
          <source>The index is not usable because the WHERE clause terms are connected by OR instead of AND. This query would result in a full table scan. However, if three additional indices where added that contained columns b, c, and d as their left-most columns, then the &lt;a href=&quot;#or_opt&quot;&gt;OR-clause optimization&lt;/a&gt; might apply.</source>
          <target state="translated">该索引不可用，因为WHERE子句项通过OR而不是AND连接。该查询将导致全表扫描。但是，如果添加的另外三个索引包含b，c和d列作为它们的最左列，则可能应用&lt;a href=&quot;#or_opt&quot;&gt;OR子句优化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="672cc6d4ea8af33a329ad85f582fc436091b60cb" translate="yes" xml:space="preserve">
          <source>The index of the term instance within its column. Terms are numbered in order of occurrence starting from 0.</source>
          <target state="translated">术语实例在其列中的索引。术语按出现的顺序从0开始编号。</target>
        </trans-unit>
        <trans-unit id="9be4bc1fc0e600b05c5d496186036ea84f9ef15d" translate="yes" xml:space="preserve">
          <source>The indexed documents are not stored within the SQLite database at all (a &quot;contentless&quot; FTS4 table), or</source>
          <target state="translated">索引的文档根本没有存储在SQLite数据库中(一个 &quot;无内容 &quot;的FTS4表),或</target>
        </trans-unit>
        <trans-unit id="e1d425e949e65fa344c6b8fb0277d12b499d6fc9" translate="yes" xml:space="preserve">
          <source>The indexed documents are stored in a database table created and managed by the user (an &quot;external content&quot; FTS4 table).</source>
          <target state="translated">索引文件存储在用户创建和管理的数据库表中(&quot;外部内容 &quot;FTS4表)。</target>
        </trans-unit>
        <trans-unit id="4aef068b1a0d56e1caa7dcf9dfa167672f1599ff" translate="yes" xml:space="preserve">
          <source>The infix LIKE operator is implemented by calling the application-defined SQL functions &lt;a href=&quot;lang_corefunc#like&quot;&gt;like(&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;X&lt;/i&gt;)&lt;/a&gt; or &lt;a href=&quot;lang_corefunc#like&quot;&gt;like(&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/a&gt;.</source>
          <target state="translated">通过调用应用程序定义的SQL函数&lt;a href=&quot;lang_corefunc#like&quot;&gt;（如（&lt;i&gt;Y&lt;/i&gt;，&lt;i&gt;X&lt;/i&gt;）&lt;/a&gt;或&lt;a href=&quot;lang_corefunc#like&quot;&gt;like（&lt;i&gt;Y&lt;/i&gt;，&lt;i&gt;X&lt;/i&gt;，&lt;i&gt;Z&lt;/i&gt;）&lt;/a&gt;来实现infix LIKE运算符。</target>
        </trans-unit>
        <trans-unit id="88a733d117cd4f0a7921fa6f2a987e25c2eb02d1" translate="yes" xml:space="preserve">
          <source>The information above can be recast into a table format as follows:</source>
          <target state="translated">上述信息可改写成如下表格格式:</target>
        </trans-unit>
        <trans-unit id="7c260215b8c7aaba3e0315515668088d0bdaae79" translate="yes" xml:space="preserve">
          <source>The information accessed using this API and its companion xPhraseFirstColumn() may also be obtained using xPhraseFirst/xPhraseNext (or xInst/xInstCount). The chief advantage of this API is that it is significantly more efficient than those alternatives when used with &quot;detail=column&quot; tables.</source>
          <target state="translated">使用该API及其配套的xPhraseFirstColumn()访问的信息也可以使用xPhraseFirst/xPhraseNext(或xInst/xInstCount)获得。这个API的主要优点是,当与 &quot;detail=column &quot;表一起使用时,它的效率明显高于这些替代方法。</target>
        </trans-unit>
        <trans-unit id="e6d1054c7b3f35c96345a991890c1e40578c9e8c" translate="yes" xml:space="preserve">
          <source>The information in the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure is ephemeral and may be overwritten or deallocated as soon as the xBestIndex method returns. If the xBestIndex method needs to remember any part of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure, it should make a copy. Care must be take to store the copy in a place where it will be deallocated, such as in the idxStr field with needToFreeIdxStr set to 1.</source>
          <target state="translated">&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;结构中的信息是短暂的，并且xBestIndex方法返回时可能会被覆盖或释放。如果xBestIndex方法需要记住&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;结构的任何部分，则应进行复制。必须注意将副本存储在将要释放的位置，例如，在NeedToFreeIdxStr设置为1的idxStr字段中。</target>
        </trans-unit>
        <trans-unit id="32cf05e222bbae76e66c5abe0ecf2fd84a3a7c70" translate="yes" xml:space="preserve">
          <source>The information in this article applies only when SQLite is operating in &quot;rollback mode&quot;, or in other words when SQLite is not using a &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;. SQLite still supports atomic commit when write-ahead logging is enabled, but it accomplishes atomic commit by a different mechanism from the one described in this article. See the &lt;a href=&quot;wal&quot;&gt;write-ahead log documentation&lt;/a&gt; for additional information on how SQLite supports atomic commit in that context.</source>
          <target state="translated">本文中的信息仅在SQLite在&amp;ldquo;回退模式&amp;rdquo;下运行时才适用，换句话说，当SQLite不使用&lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt;时才适用。启用预写日志记录后，SQLite仍支持原子提交，但是它通过与本文介绍的机制不同的机制来实现原子提交。有关SQLite在该上下文中如何支持原子提交的其他信息，请参见&lt;a href=&quot;wal&quot;&gt;预写日志文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f9342562e97e372cf7348a184a4d34dd086f3cc5" translate="yes" xml:space="preserve">
          <source>The initial &quot;INSERT&quot; keyword can be replaced by &quot;REPLACE&quot; or &quot;INSERT OR</source>
          <target state="translated">最初的 &quot;INSERT &quot;关键字可以用 &quot;REPLACE &quot;或 &quot;INSERT OR &quot;代替。</target>
        </trans-unit>
        <trans-unit id="d2a90ccaf25a62976be28829cc53054a6feb5a8b" translate="yes" xml:space="preserve">
          <source>The initial content is UTF-16 text and sqlite3_column_bytes() or sqlite3_column_text() is called. The content must be converted to UTF-8.</source>
          <target state="translated">初始内容为UTF-16文本,调用sqlite3_column_bytes()或sqlite3_column_text()。内容必须转换为UTF-8。</target>
        </trans-unit>
        <trans-unit id="f5abf60cee620000168958a8b5acfa6d74016d3a" translate="yes" xml:space="preserve">
          <source>The initial content is UTF-8 text and sqlite3_column_bytes16() or sqlite3_column_text16() is called. The content must be converted to UTF-16.</source>
          <target state="translated">初始内容为UTF-8文本,调用sqlite3_column_bytes16()或sqlite3_column_text16()。内容必须转换为UTF-16。</target>
        </trans-unit>
        <trans-unit id="16a79a9ef866be9ddb29420482c978bd29b5a111" translate="yes" xml:space="preserve">
          <source>The initial content is a BLOB and sqlite3_column_text() or sqlite3_column_text16() is called. A zero-terminator might need to be added to the string.</source>
          <target state="translated">初始内容是一个BLOB,调用sqlite3_column_text()或sqlite3_column_text16()。可能需要在字符串中添加一个零结束符。</target>
        </trans-unit>
        <trans-unit id="e8f78c0547aa09c0045543ed5c95b2ff19b12417" translate="yes" xml:space="preserve">
          <source>The initial implementation of NGQP chooses N=1 for simple queries, N=5 for two-way joins and N=10 for all joins with three or more tables. This formula for selecting N might change in subsequent releases.</source>
          <target state="translated">NGQP的初始实现对简单查询选择N=1,对双向连接选择N=5,对所有有三个或更多表的连接选择N=10。这个选择N的公式在后续版本中可能会改变。</target>
        </trans-unit>
        <trans-unit id="433c6a25716e7b035366d6fcddc3266fd3d25e85" translate="yes" xml:space="preserve">
          <source>The initial portion of the payload that does not spill to overflow pages.</source>
          <target state="translated">不溢出到溢出页的有效载荷的初始部分。</target>
        </trans-unit>
        <trans-unit id="a60a09b4b0f1a33259942d5b4f17c8bccd4a335d" translate="yes" xml:space="preserve">
          <source>The inner SELECT statement is implemented by instructions 1 through 10. All this code does is make an entry in the temporary table for each row of the examp2 table with a non-NULL value for the &quot;three&quot; column. The key for each temporary table entry is the &quot;three&quot; column of examp2 and the data is an empty string since it is never used.</source>
          <target state="translated">内部的SELECT语句由指令1至10实现。这段代码所做的就是在临时表中为examp2表的每一行做一个条目,&quot;三 &quot;列的值为非NULL。每个临时表条目的键是examp2的 &quot;三 &quot;列,数据是一个空字符串,因为它从未被使用过。</target>
        </trans-unit>
        <trans-unit id="059bc1f5d258819deb1954aaf03c0ff2e66225d4" translate="yes" xml:space="preserve">
          <source>The input data used by a simple SELECT query is a set of</source>
          <target state="translated">一个简单的SELECT查询所使用的输入数据是一系列的</target>
        </trans-unit>
        <trans-unit id="6894645090ea407676b9f33e59a0dad3066f4727" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete()&lt;/a&gt; must be a zero-terminated UTF-8 string.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete（）&lt;/a&gt;的输入必须是一个零终止的UTF-8字符串。</target>
        </trans-unit>
        <trans-unit id="4d7419b960ffd32c455a130a0e74d0adde2f9624" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete16()&lt;/a&gt; must be a zero-terminated UTF-16 string in native byte order.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete16（）&lt;/a&gt;的输入必须是以本机字节顺序为零终止的UTF-16字符串。</target>
        </trans-unit>
        <trans-unit id="4b672bd7f0a1d030d51edf7b207eec2b4f3ae087" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;complete&quot;&gt;sqlite3_complete()&lt;/a&gt; must be a zero-terminated UTF-8 string.</source>
          <target state="translated">&lt;a href=&quot;complete&quot;&gt;sqlite3_complete（）&lt;/a&gt;的输入必须是一个零终止的UTF-8字符串。</target>
        </trans-unit>
        <trans-unit id="cfd5dd711daa7423070d67fd7c844d95a0e5c24f" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;complete&quot;&gt;sqlite3_complete16()&lt;/a&gt; must be a zero-terminated UTF-16 string in native byte order.</source>
          <target state="translated">&lt;a href=&quot;complete&quot;&gt;sqlite3_complete16（）&lt;/a&gt;的输入必须是以本机字节顺序为零终止的UTF-16字符串。</target>
        </trans-unit>
        <trans-unit id="2d24c8f818c9e23a7423d1fe6a231842fef7a551" translate="yes" xml:space="preserve">
          <source>The inputs to TH3 are test modules written in C or SQL and small configuration files that determine how to initialize SQLite. The TH3 package includes 1,444 test modules and more than 47 configurations (as of 2018-05-19). New modules and configurations can be added to customize TH3 for specialized applications. Each time TH3 is run, it reads a subset of the available test modules and configuration files to generate a custom C program that performs all of the specified tests under all specified configurations. A complete test of SQLite normally involves running TH3 multiple times to generate multiple test programs covering different aspects of SQLite's operation, then linking all test programs against a common SQLite library and running them separately on the target platform.</source>
          <target state="translated">TH3的输入是用C或SQL编写的测试模块和决定如何初始化SQLite的小配置文件。TH3包包括1,444个测试模块和超过47种配置(截至2018-05-19)。可以添加新的模块和配置,以便为专门的应用定制TH3。每次运行TH3时,它都会读取可用的测试模块和配置文件的子集,以生成一个自定义C程序,在所有指定的配置下执行所有指定的测试。一个完整的SQLite测试通常需要多次运行TH3生成多个测试程序,涵盖SQLite操作的不同方面,然后将所有测试程序针对一个通用的SQLite库进行链接,并在目标平台上分别运行。</target>
        </trans-unit>
        <trans-unit id="bb4e6367e51d64e49b708aca20c83e616d792f73" translate="yes" xml:space="preserve">
          <source>The inspiration for this document is &lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt;. Among quality standards, DO-178B seems to have the highest usefulness to paperwork ratio. Even so, the amount of documentation needed for a full-up DO-178B implementation is vast. SQLite strives to be nimble and low-ceremony, and to that end, much of the required DO-178B documentation is omitted. We retain only those parts that genuinely improve quality for a open-source software project such as SQLite.</source>
          <target state="translated">本文档的灵感来自&lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt;。在质量标准中，DO-178B似乎对文书工作的使用率最高。即使这样，完整的DO-178B实施所需的文档数量仍然很大。SQLite努力做到敏捷和低礼仪，为此，省略了许多必需的DO-178B文档。我们仅保留那些真正提高了开源软件项目（例如SQLite）质量的部分。</target>
        </trans-unit>
        <trans-unit id="eeb6f7cf85fc1473abd39059a6c5676d36ad32d5" translate="yes" xml:space="preserve">
          <source>The instr(X,Y) function finds the first occurrence of string Y within string X and returns the number of prior characters plus 1, or 0 if Y is nowhere found within X. Or, if X and Y are both BLOBs, then instr(X,Y) returns one more than the number bytes prior to the first occurrence of Y, or 0 if Y does not occur anywhere within X. If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs then both are interpreted as strings. If either X or Y are NULL in instr(X,Y) then the result is NULL.</source>
          <target state="translated">instr(X,Y)函数在字符串X中找到字符串Y的首次出现,并返回前面的字符数加1,如果在X中找不到Y,则返回0。或者,如果X和Y都是BLOB,那么instr(X,Y)返回比Y首次出现之前的字节数多1,如果Y在X中没有出现,则返回0。如果instr(X,Y)的参数X和Y都是非NULL,并且不是BLOB,那么两者都被解释为字符串。如果在instr(X,Y)中X或Y都是NULL,那么结果就是NULL。</target>
        </trans-unit>
        <trans-unit id="a78743c67ceb66f35152669e19fad52bf271ff90" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Close&quot;&gt;Close&lt;/a&gt; closes a cursor previously opened as P1 (0, the only open cursor). If P1 is not currently open, this instruction is a no-op.</source>
          <target state="translated">&amp;ldquo; &lt;a href=&quot;opcode#Close&quot;&gt;关闭&lt;/a&gt; &amp;rdquo;指令关闭先前打开为P1（0，唯一打开的游标）的游标。如果P1当前未打开，则该指令为无操作。</target>
        </trans-unit>
        <trans-unit id="e8c5c65cb041570fcd5ae40ccc7306b738bb99f4" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Commit&quot;&gt;Commit&lt;/a&gt; causes all modifications to the database that have been made since the last Transaction to actually take effect. No additional modifications are allowed until another transaction is started. The Commit instruction deletes the journal file and releases the write lock on the database. A read lock continues to be held if there are still cursors open.</source>
          <target state="translated">&lt;a href=&quot;opcode#Commit&quot;&gt;提交&lt;/a&gt;指令使自上次事务处理以来对数据库所做的所有修改实际生效。在开始另一个事务之前，不允许进行其他修改。提交指令删除日志文件并释放数据库上的写锁。如果仍有游标打开，则将继续保持读锁定。</target>
        </trans-unit>
        <trans-unit id="71d724f14f1b112c6a8977fb693b84af3a6cb813" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; causes the VDBE engine to exit immediately. All open cursors, Lists, Sorts, etc are closed automatically. P1 is the result code returned by sqlite_exec(). For a normal halt, this should be SQLITE_OK (0). For errors, it can be some other value. The operand P2 is only used when there is an error. There is an implied &quot;Halt 0 0 0&quot; instruction at the end of every program, which the VDBE appends when it prepares a program to run.</source>
          <target state="translated">&lt;a href=&quot;opcode#Halt&quot;&gt;停止&lt;/a&gt;指令使VDBE引擎立即退出。所有打开的游标，列表，排序等都将自动关闭。 P1是sqlite_exec（）返回的结果代码。对于正常的停止，该值应为SQLITE_OK（0）。对于错误，它可以是其他值。仅在出现错误时才使用操作数P2。每个程序的末尾都有一个隐含的&amp;ldquo; Halt 0 0 0&amp;rdquo;指令，VDBE在准备要运行的程序时会附加该指令。</target>
        </trans-unit>
        <trans-unit id="4a2e93cc788564162251660dae046bf0362122e8" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#IdxRecno&quot;&gt;IdxRecno&lt;/a&gt; at 13 pushes onto the stack the table record number from the index. The following MoveTo pops it and moves the table cursor to that row. The next 3 instructions select the column data the same way as in the non- indexed case. The Column instructions fetch the column data and the callback function is invoked. The final Next instruction advances the index cursor, not the table cursor, to the next row, and then branches back to the start of the loop if there are any index records left.</source>
          <target state="translated">位于13 的指令&lt;a href=&quot;opcode#IdxRecno&quot;&gt;IdxRecno&lt;/a&gt;将来自索引的表记录号压入堆栈。下面的MoveTo弹出它，并将表格光标移动到该行。接下来的3条指令以与未索引情况相同的方式选择列数据。列指令获取列数据并调用回调函数。最后一条Next指令将索引游标（而不是表游标）前进到下一行，然后在剩余索引记录的情况下分支回到循环的开始。</target>
        </trans-unit>
        <trans-unit id="89a91a29199817279a977a2ce4541fd6e7fee24a" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt; pushes its P1 operand (99) onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">指令&lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt;将其P1操作数（99）压入堆栈。之后，堆栈如下所示：</target>
        </trans-unit>
        <trans-unit id="15f722b882a29ac5b03a20e923af0ef9dcb502b1" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt; pushes the integer value P1 (0) onto the stack. Here 0 is the number of the database to use in the following OpenWrite instruction. If P3 is not NULL then it is a string representation of the same integer. Afterwards the stack looks like this:</source>
          <target state="translated">指令&lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt;将整数值P1（0）压入堆栈。0是下面的OpenWrite指令中要使用的数据库的编号。如果P3不为NULL，则它是相同整数的字符串表示形式。之后，堆栈如下所示：</target>
        </trans-unit>
        <trans-unit id="d1df5b7ac8ac4ed32e40d9d958d1c725defad872" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; pops the top P1 elements off the stack (2 in this case) and converts them into the binary format used for storing records in a database file. (See the &lt;a href=&quot;fileformat&quot;&gt;file format&lt;/a&gt; description for details.) The new record generated by the MakeRecord instruction is pushed back onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;指令将顶部的P1元素弹出堆栈（在这种情况下为2），并将其转换为用于在数据库文件中存储记录的二进制格式。（有关详细信息，请参见&lt;a href=&quot;fileformat&quot;&gt;文件格式&lt;/a&gt;说明。）由MakeRecord指令生成的新记录将推回堆栈。之后，堆栈如下所示：</target>
        </trans-unit>
        <trans-unit id="21bb54c4787b5b030612c3d381e1ba9b4bb1f341" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#NewRecno&quot;&gt;NewRecno&lt;/a&gt; creates a new integer record number for the table pointed to by cursor P1. The record number is one not currently used as a key in the table. The new record number is pushed onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">指令&lt;a href=&quot;opcode#NewRecno&quot;&gt;NewRecno&lt;/a&gt;为光标P1指向的表创建一个新的整数记录号。记录号是当前未在表中用作键的记录号。新的记录号被压入堆栈。之后，堆栈如下所示：</target>
        </trans-unit>
        <trans-unit id="213073395c8927a399e8bb754b1febc0fe16eb95" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt; opens a new read/write cursor with handle P1 (0 in this case) on table &quot;examp&quot;, whose root page is P2 (3, in this database file). Cursor handles can be any non-negative integer. But the VDBE allocates cursors in an array with the size of the array being one more than the largest cursor. So to conserve memory, it is best to use handles beginning with zero and working upward consecutively. Here P3 (&quot;examp&quot;) is the name of the table being opened, but this is unused, and only generated to make the code easier to read. This instruction pops the database number to use (0, the main database) from the top of the stack, so afterwards the stack is empty again.</source>
          <target state="translated">指令&lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt;在表&amp;ldquo; examp&amp;rdquo;上用句柄P1（在这种情况下为0）打开一个新的读/写游标，该表的根页为P2（在此数据库文件中为3）。游标句柄可以是任何非负整数。但是VDBE在数组中分配游标，该数组的大小比最大游标大一。因此，为了节省内存，最好使用从零开始并连续向上处理的句柄。这里的P3（&amp;ldquo;示例&amp;rdquo;）是要打开的表的名称，但是未使用，仅是为了使代码易于阅读而生成的。该指令从堆栈顶部弹出要使用的数据库编号（0，即主数据库），因此此后堆栈再次为空。</target>
        </trans-unit>
        <trans-unit id="98bb30ff1b874474319c63eb890c40ec0fb09de2" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#PutIntKey&quot;&gt;PutIntKey&lt;/a&gt; uses the top 2 stack entries to write an entry into the table pointed to by cursor P1. A new entry is created if it doesn't already exist or the data for an existing entry is overwritten. The record data is the top stack entry, and the key is the next entry down. The stack is popped twice by this instruction. Because operand P2 is 1 the row change count is incremented and the rowid is stored for subsequent return by the sqlite_last_insert_rowid() function. If P2 is 0 the row change count is unmodified. This instruction is where the insert actually occurs.</source>
          <target state="translated">指令&lt;a href=&quot;opcode#PutIntKey&quot;&gt;PutIntKey&lt;/a&gt;使用前2个堆栈条目将条目写入光标P1指向的表中。如果尚不存在新条目或现有条目的数据被覆盖，则会创建一个新条目。记录数据是顶部堆栈条目，而键是下一个条目。该指令将堆栈弹出两次。因为操作数P2为1，所以行更改计数增加，并且存储rowid以供sqlite_last_insert_rowid（）函数随后返回。如果P2为0，则行更改计数不变。该指令是插入实际发生的位置。</target>
        </trans-unit>
        <trans-unit id="0b320ec6225176f371f5c1f951d40976365b4443" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; pushes its P3 operand onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">指令&lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt;将其P3操作数压入堆栈。之后，堆栈如下所示：</target>
        </trans-unit>
        <trans-unit id="d914ce420de942b21ca6d5eb303d1b4bdd87f483" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt; begins a transaction. The transaction ends when a Commit or Rollback opcode is encountered. P1 is the index of the database file on which the transaction is started. Index 0 is the main database file. A write lock is obtained on the database file when a transaction is started. No other process can read or write the file while the transaction is underway. Starting a transaction also creates a rollback journal. A transaction must be started before any changes can be made to the database.</source>
          <target state="translated">指令&lt;a href=&quot;opcode#Transaction&quot;&gt;交易&lt;/a&gt;开始交易。遇到Commit或Rollback操作码时，事务结束。 P1是在其上启动事务的数据库文件的索引。索引0是主数据库文件。启动事务时，将在数据库文件上获得写锁定。事务进行期间，没有其他进程可以读取或写入文件。启动事务还会创建回滚日志。必须先启动事务，然后才能对数据库进行任何更改。</target>
        </trans-unit>
        <trans-unit id="766fac627c726045a9f4c4dcb9828d544fcadbb2" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#VerifyCookie&quot;&gt;VerifyCookie&lt;/a&gt; checks cookie 0 (the database schema version) to make sure it is equal to P2 (the value obtained when the database schema was last read). P1 is the database number (0 for the main database). This is done to make sure the database schema hasn't been changed by another thread, in which case it has to be reread.</source>
          <target state="translated">指令&lt;a href=&quot;opcode#VerifyCookie&quot;&gt;VerifyCookie会&lt;/a&gt;检查cookie 0（数据库模式版本）以确保它等于P2（上一次读取数据库模式时获得的值）。 P1是数据库编号（主数据库为0）。这样做是为了确保数据库架构没有被另一个线程更改，在这种情况下，必须重新读取它。</target>
        </trans-unit>
        <trans-unit id="1541b9a811a194a4f9e80a336055e479ef3f480e" translate="yes" xml:space="preserve">
          <source>The instruction at address 9 implements the branching part of the loop. Together with the Rewind at address 5 it forms the loop logic. This is a key concept that you should pay close attention to. The &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; instruction advances the cursor P1 to the next record. If the cursor advance was successful, then jump immediately to P2 (6, the beginning of the loop body). If the cursor was at the end, then fall through to the following instruction, which ends the loop.</source>
          <target state="translated">地址9处的指令实现了循环的分支部分。它与地址5的倒带一起形成循环逻辑。这是您应该密切注意的关键概念。在&lt;a href=&quot;opcode#Next&quot;&gt;下一步&lt;/a&gt;指令游标前进P1到下一个记录。如果光标前进成功，则立即跳转到P2（循环主体的开始6）。如果光标位于末尾，则进入以下指令，从而结束循环。</target>
        </trans-unit>
        <trans-unit id="14da6ae11560ca2b2c31ae75e094431766a4621e" translate="yes" xml:space="preserve">
          <source>The instruction at the address in register P1 is a &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt;. &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; to the P2 parameter of that &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt;. After the jump, register P1 becomes undefined.</source>
          <target state="translated">寄存器P1中地址处的指令为&lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt;。&lt;a href=&quot;opcode#Jump&quot;&gt;跳至&lt;/a&gt;该&lt;a href=&quot;opcode#Yield&quot;&gt;收益率&lt;/a&gt;的P2参数。跳转后，寄存器P1变为未定义。</target>
        </trans-unit>
        <trans-unit id="cd201e480371afb73e8686f10704843996fccd91" translate="yes" xml:space="preserve">
          <source>The instructions 6 through 8 form the body of the loop that will execute once for each record in the database file. The &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; instructions at addresses 6 and 7 each take the P2-th column from the P1-th cursor and push it onto the stack. In this example, the first Column instruction is pushing the value for the column &quot;one&quot; onto the stack and the second Column instruction is pushing the value for column &quot;two&quot;. The &lt;a href=&quot;opcode#Callback&quot;&gt;Callback&lt;/a&gt; instruction at address 8 invokes the callback() function. The P1 operand to Callback becomes the value for &lt;b&gt;nColumn&lt;/b&gt;. The Callback instruction pops P1 values from the stack and uses them to fill the &lt;b&gt;azData[]&lt;/b&gt; array.</source>
          <target state="translated">指令6至8构成循环的主体，该循环将对数据库文件中的每个记录执行一次。地址6和7 的&lt;a href=&quot;opcode#Column&quot;&gt;列&lt;/a&gt;指令分别从第P1个游标获取第P2列，并将其压入堆栈。在此示例中，第一个Column指令将列&amp;ldquo; one&amp;rdquo;的值压入堆栈，第二个Column指令将列&amp;ldquo; two&amp;rdquo;的值压入堆栈。地址8 的&lt;a href=&quot;opcode#Callback&quot;&gt;Callback&lt;/a&gt;指令调用callback（）函数。回调的P1操作数成为&lt;b&gt;nColumn&lt;/b&gt;的值。回调指令从堆栈中弹出P1值，并使用它们填充&lt;b&gt;azData []&lt;/b&gt;数组。</target>
        </trans-unit>
        <trans-unit id="c46964020db9e221e22ce0203153f52f7c4afbe0" translate="yes" xml:space="preserve">
          <source>The integer values returned by two invocations of &quot;PRAGMA data_version&quot; from the same connection will be different if changes were committed to the database by any other connection in the interim. The &quot;PRAGMA data_version&quot; value is unchanged for commits made on the same database connection. The behavior of &quot;PRAGMA data_version&quot; is the same for all database connections, including database connections in separate processes and &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; database connections.</source>
          <target state="translated">如果在此期间任何其他连接将更改提交给数据库，则从同一连接两次调用&amp;ldquo; PRAGMA data_version&amp;rdquo;返回的整数值将有所不同。对于在同一数据库连接上进行的提交，&amp;ldquo; PRAGMA data_version&amp;rdquo;值不变。所有数据库连接（包括独立进程中的数据库连接和&lt;a href=&quot;sharedcache&quot;&gt;共享缓存&lt;/a&gt;数据库连接）的&amp;ldquo; PRAGMA data_version&amp;rdquo;行为都是相同的。</target>
        </trans-unit>
        <trans-unit id="4e05f2b57d17a355c0ea1387908101e6bd52b31e" translate="yes" xml:space="preserve">
          <source>The integer values to xLock() and xUnlock() are one of</source>
          <target state="translated">xLock()和xUnlock()的整数值是其中之一。</target>
        </trans-unit>
        <trans-unit id="3a9652af526f0c1e8a87ab92c4d5d7f777a76ac5" translate="yes" xml:space="preserve">
          <source>The integrity-check command is invoked by inserting the text value 'integrity-check' into the special column with the same name as the FTS5 table. For example:</source>
          <target state="translated">通过在与FTS5表同名的特殊列中插入文本值 &quot;诚信检查 &quot;来调用诚信检查命令。例如:</target>
        </trans-unit>
        <trans-unit id="8b9cbbc162055ec87304da9b44deb92f428d9750" translate="yes" xml:space="preserve">
          <source>The intended use of this pragma is only for testing and validation of SQLite. This pragma is subject to change without notice and is not recommended for use by application programs.</source>
          <target state="translated">这个pragma的预期用途只是为了测试和验证SQLite。这个pragma可能会在没有通知的情况下发生变化,不建议应用程序使用。</target>
        </trans-unit>
        <trans-unit id="ff65b14ad46243e5d5f2ba9708d0bfaa67d238c4" translate="yes" xml:space="preserve">
          <source>The intent of the developers is to support SQLite through the year 2050.</source>
          <target state="translated">开发者的意图是支持SQLite到2050年。</target>
        </trans-unit>
        <trans-unit id="b8c5c15fb8411770e1f2302c0a93c745cb58106c" translate="yes" xml:space="preserve">
          <source>The intent of these enhancements to the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; and &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; commands is to ensure that they cannot be used to create a database that contains foreign key violations, at least while foreign key constraints are enabled. There is one exception to this rule though. If a parent key is not subject to a PRIMARY KEY or UNIQUE constraint created as part of the parent table definition, but is subject to a UNIQUE constraint by virtue of an index created using the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; command, then the child table may be populated without causing a &quot;foreign key mismatch&quot; error. If the UNIQUE index is dropped from the database schema, then the parent table itself is dropped, no error will be reported. However the database may be left in a state where the child table of the foreign key constraint contains rows that do not refer to any parent table row. This case can be avoided if all parent keys in the database schema are constrained by PRIMARY KEY or UNIQUE constraints added as part of the parent table definition, not by external UNIQUE indexes.</source>
          <target state="translated">对&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;和&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;命令进行这些增强的目的是确保至少在启用外键约束的情况下，不能将它们用于创建包含外键违规的数据库。但是，此规则有一个例外。如果父键不受作为父表定义一部分创建的PRIMARY KEY或UNIQUE约束的约束，但由于使用&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;创建的索引而受UNIQUE约束的约束命令，然后可以填充子表而不会引起&amp;ldquo;外键不匹配&amp;rdquo;错误。如果从数据库架构中删除了UNIQUE索引，那么父表本身也将被删除，则不会报告任何错误。但是，数据库可能处于外键约束的子表包含不引用任何父表行的行的状态。如果数据库架构中的所有父键都由作为父表定义的一部分添加的PRIMARY KEY或UNIQUE约束而不是由外部UNIQUE索引约束，则可以避免这种情况。</target>
        </trans-unit>
        <trans-unit id="f25fb84e751737880254b9bbae4d5bcd681d4573" translate="yes" xml:space="preserve">
          <source>The interface between the VDBE and B-Tree layer is enhanced such that the VDBE provides hints to the B-Tree layer letting the B-Tree layer know when it is safe to use hashing instead of B-Trees for transient tables.</source>
          <target state="translated">VDBE和B-Tree层之间的接口得到了增强,VDBE为B-Tree层提供了提示,让B-Tree层知道什么时候使用哈希而不是B-Tree来处理瞬时表是安全的。</target>
        </trans-unit>
        <trans-unit id="8f6df7d6e95fb6e2e2d0cc834a6496c76dd46264" translate="yes" xml:space="preserve">
          <source>The interface to the B-tree subsystem and the rest of the SQLite library is defined by the header file &lt;a href=&quot;https://sqlite.org/src/file/src/btree.h&quot;&gt;btree.h&lt;/a&gt;.</source>
          <target state="translated">B-tree子系统和其余SQLite库的接口&lt;a href=&quot;https://sqlite.org/src/file/src/btree.h&quot;&gt;由头&lt;/a&gt;文件btree.h定义。</target>
        </trans-unit>
        <trans-unit id="b91796ad2d511be2d8979f83ba1c6fb0431a4019" translate="yes" xml:space="preserve">
          <source>The interface to the SQLite library consists of single tcl command named &lt;b&gt;sqlite3&lt;/b&gt; Because there is only this one command, the interface is not placed in a separate namespace.</source>
          <target state="translated">SQLite库的接口由单个名为&lt;b&gt;sqlite3的&lt;/b&gt; tcl命令组成。由于只有一个命令，因此该接口不会放置在单独的命名空间中。</target>
        </trans-unit>
        <trans-unit id="3c849c0d323b0ad6135a0bb1621f8f7a986a9fa1" translate="yes" xml:space="preserve">
          <source>The interface to the SQLite library consists of three core functions, one opaque data structure, and some constants used as return values. The core interface is as follows:</source>
          <target state="translated">SQLite库的接口由三个核心函数、一个不透明的数据结构和一些用作返回值的常量组成。核心接口如下。</target>
        </trans-unit>
        <trans-unit id="da5910db62046423c913e2518dadca7a36c2bb7d" translate="yes" xml:space="preserve">
          <source>The interface used by the implementation of the aforementioned functions to retrieve the collation sequence set by this opcode is not available publicly. Only built-in functions have access to this feature.</source>
          <target state="translated">上述函数的实现用来检索该操作码设置的整理序列的接口是不公开的。只有内置的函数可以使用这个功能。</target>
        </trans-unit>
        <trans-unit id="1824212549f384e7aed12eb3886c9cf696af6dde" translate="yes" xml:space="preserve">
          <source>The interfaces necessary to construct a function that is sometimes deterministic and sometimes non-deterministic depending on their inputs, such as the built-in date/time functions, are not published. Generic &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; must be always deterministic or always non-deterministic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82c461e3315f13aa8457935ffce58f8ac7ef7cd3" translate="yes" xml:space="preserve">
          <source>The interfaces necessary to construct a function that is sometimes deterministic and sometimes non-deterministic depending on their inputs, such as the built-in date/time functions, are not published. Generic &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; must be always deterministic or always non-deterministic.</source>
          <target state="translated">未发布构造有时取决于其输入的确定性和有时不确定性的功能所必需的接口，例如内置的日期/时间函数。通用的&lt;a href=&quot;c3ref/create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;必须始终是确定性的或始终是不确定性的。</target>
        </trans-unit>
        <trans-unit id="15015bc60e3376a39ca9d7ebc27d602beffae1d0" translate="yes" xml:space="preserve">
          <source>The internal Mem object stores the value for a single register. The abstract &lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt; object that is exposed in the API is really just a Mem object or register.</source>
          <target state="translated">内部Mem对象存储单个寄存器的值。API中公开的抽象&lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt;对象实际上只是一个Mem对象或寄存器。</target>
        </trans-unit>
        <trans-unit id="e1059fa5a511cb460ad6acfc6dbdaaa7898a9f5d" translate="yes" xml:space="preserve">
          <source>The internal organization of the SQLite library can be viewed as the stack of modules shown to the right. The Tokenizer, Parser, and Code Generator components are used to process SQL statements and convert them into executable programs in a virtual machine language or byte code. Roughly speaking, these top three layers implement &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. The byte code generated by the top three layers is a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt;. The Virtual Machine module is responsible for running the SQL statement byte code. The B-Tree module organizes a database file into multiple key/value stores with ordered keys and logarithmic performance. The Pager module is responsible for loading pages of the database file into memory, for implementing and controlling transactions, and for creating and maintaining the journal files that prevent database corruption following a crash or power failure. The OS Interface is a thin abstraction that provides a common set of routines for adapting SQLite to run on different operating systems. Roughly speaking, the bottom four layers implement &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">SQLite库的内部组织可以视为如右图所示的模块堆栈。令牌生成器，解析器和代码生成器组件用于处理SQL语句，并将其转换为虚拟机语言或字节码的可执行程序。粗略地说，这三层实现了&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;。前三层生成的字节码是&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;。虚拟机模块负责运行SQL语句字节代码。B-Tree模块将数据库文件组织到具有有序键和对数性能的多个键/值存储中。Pager模块负责将数据库文件的页面加载到内存中，以实现和控制事务，并创建和维护日记文件，以防止崩溃或电源故障后数据库损坏。OS Interface是一个瘦的抽象，它提供了一套通用的例程，以使SQLite适应在不同的操作系统上运行。粗略地讲，最下面的四层实现&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b82fe06906efdf8da65bc9a3b09aabf0c14e629e" translate="yes" xml:space="preserve">
          <source>The internet is an increasingly hostile place. These day, developers should assume that attackers will find a way to execute arbitrary SQL in an application. Applications should be designed to prevent the execution of arbitrary SQL from escalating into a more severe exploit.</source>
          <target state="translated">互联网是一个越来越敌对的地方。如今,开发人员应该假设攻击者会找到一种方法在应用程序中执行任意SQL。应用程序的设计应该防止任意SQL的执行升级为更严重的利用。</target>
        </trans-unit>
        <trans-unit id="541368df6be3b3211d485998b29f10dd5bcba535" translate="yes" xml:space="preserve">
          <source>The interpretation of the final column, if it is present, is &lt;a href=&quot;swarmvtab#component_table_context_values&quot;&gt;described here&lt;/a&gt;.</source>
          <target state="translated">如果存在最后一栏，则&lt;a href=&quot;swarmvtab#component_table_context_values&quot;&gt;在此处进行说明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ecf9411adae8ae3787bf4274e751f3717d6110f0" translate="yes" xml:space="preserve">
          <source>The ioctl on Mac OS X to control syncing to disk is F_FULLFSYNC, not F_FULLSYNC. The previous release had it wrong.</source>
          <target state="translated">Mac OS X 上控制同步到磁盘的 ioctl 是 F_FULLFSYNC,而不是 F_FULLSYNC。以前的版本是错的。</target>
        </trans-unit>
        <trans-unit id="d9c0a5f06c6830c793bad013d5441e96d45f8af0" translate="yes" xml:space="preserve">
          <source>The job of the eval method is to execute the SQL statement or statements given in the second argument. For example, to create a new table in a database, you can do this:</source>
          <target state="translated">eval方法的工作是执行第二个参数中给出的SQL语句或语句。例如,要在数据库中创建一个新表,可以这样做。</target>
        </trans-unit>
        <trans-unit id="ce55e90a07de980cc86c5f2dfac419a865729e47" translate="yes" xml:space="preserve">
          <source>The job of this method is to construct the new virtual table object (an &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object) and return a pointer to it in *ppVTab.</source>
          <target state="translated">此方法的工作是构造新的虚拟表对象（&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;对象），并在* ppVTab中返回指向它的指针。</target>
        </trans-unit>
        <trans-unit id="82b29f2835b0336ce594d7095e779f9ce1307885" translate="yes" xml:space="preserve">
          <source>The journal header is non-zero and well-formed, and</source>
          <target state="translated">日志标头是非零的,而且格式良好,而且。</target>
        </trans-unit>
        <trans-unit id="3978774f2c0624ee0736d9f40af64bca3b94a2e0" translate="yes" xml:space="preserve">
          <source>The journal tests are an additional double-check over and above the crash tests to make sure that SQLite transactions will be atomic across system crashes and power failures.</source>
          <target state="translated">日志测试是在崩溃测试之上的额外双重检查,以确保SQLite事务在系统崩溃和电源故障时是原子的。</target>
        </trans-unit>
        <trans-unit id="eadea62ca220c75cf3d8b7ee7d22ba8de7aa3934" translate="yes" xml:space="preserve">
          <source>The journal_mode pragma returns a string which is the new journal mode. On success, the pragma will return the string &quot;&lt;code&gt;wal&lt;/code&gt;&quot;. If the conversion to WAL could not be completed (for example, if the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; does not support the necessary shared-memory primitives) then the journaling mode will be unchanged and the string returned from the primitive will be the prior journaling mode (for example &quot;&lt;code&gt;delete&lt;/code&gt;&quot;).</source>
          <target state="translated">journal_mode编译指示返回一个字符串，它是新的日志模式。成功时，编译指示将返回字符串&amp;ldquo; &lt;code&gt;wal&lt;/code&gt; &amp;rdquo;。如果无法完成向WAL的转换（例如，如果&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;不支持必要的共享内存原语），则日记记录模式将保持不变，并且从原语返回的字符串将是先前的日记记录模式（例如&amp;ldquo; &lt;code&gt;delete&lt;/code&gt; &amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="cf12bc7373958f09d761ed0f9bf5075e87444a0e" translate="yes" xml:space="preserve">
          <source>The journal_size_limit pragma may be used to limit the size of rollback-journal and WAL files left in the file-system after transactions or checkpoints. Each time a transaction is committed or a WAL file resets, SQLite compares the size of the rollback journal file or WAL file left in the file-system to the size limit set by this pragma and if the journal or WAL file is larger it is truncated to the limit.</source>
          <target state="translated">journal_size_limit pragma可以用来限制事务或检查点之后留在文件系统中的回滚日志文件和WAL文件的大小。每当一个事务被提交或WAL文件被重置时,SQLite会将留在文件系统中的回滚日志文件或WAL文件的大小与这个pragma设置的大小限制进行比较,如果日志或WAL文件的大小较大,则会被截断到该限制。</target>
        </trans-unit>
        <trans-unit id="e4ee7815366ce998637e6c73fab93997f9ad3bf9" translate="yes" xml:space="preserve">
          <source>The json(X) function verifies that its argument X is a valid JSON string and returns a minified version of that JSON string (with all unnecessary whitespace removed). If X is not a well-formed JSON string, then this routine throws an error.</source>
          <target state="translated">json(X)函数验证其参数X是一个有效的JSON字符串,并返回该JSON字符串的最小化版本(去掉所有不必要的空格)。如果X不是一个格式良好的JSON字符串,那么这个例程会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="b38a8f8844d02f721e88e8305af9dc835b4312f1" translate="yes" xml:space="preserve">
          <source>The json1 extension (currently) stores JSON as ordinary text.</source>
          <target state="translated">json1扩展(目前)以普通文本的形式存储JSON。</target>
        </trans-unit>
        <trans-unit id="600cff3bfb9b2a0fb597c7fc0f7fa3f65076ca7b" translate="yes" xml:space="preserve">
          <source>The json1 extension does not (currently) support a binary encoding of JSON. Experiments have been unable to find a binary encoding that is significantly smaller or faster than a plain text encoding. (The present implementation parses JSON text at over 1 GB/s.) All json1 functions currently throw an error if any of their arguments are BLOBs because BLOBs are reserved for a future enhancement in which BLOBs will store the binary encoding for JSON.</source>
          <target state="translated">json1扩展(目前)不支持JSON的二进制编码。实验无法找到比纯文本编码更小更快的二进制编码。(目前的实现以超过1 GB/s的速度解析JSON文本。)目前所有的json1函数如果其任何参数是BLOBs,都会抛出一个错误,因为BLOBs是为将来的增强版保留的,其中BLOBs将存储JSON的二进制编码。</target>
        </trans-unit>
        <trans-unit id="50447979a47d38485f569438ae4849e4fe11a47d" translate="yes" xml:space="preserve">
          <source>The json1 extension uses the &lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; interfaces that were introduced with SQLite version 3.9.0 (2015-10-14) The json1 extension will not work in earlier versions of SQLite.</source>
          <target state="translated">json1扩展使用SQLite版本3.9.0（2015-10-14）引入的&lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype（）&lt;/a&gt;和&lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype（）&lt;/a&gt;接口json1扩展在早期版本的SQLite中将不起作用。</target>
        </trans-unit>
        <trans-unit id="96336d37aaa994d4a790a5daf6a1eabf939e9f47" translate="yes" xml:space="preserve">
          <source>The json1 source code is included with the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, though it is disabled by default. Add the &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; compile-time option to enable the json1 extension that is built into the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. The standard makefiles include -DSQLITE_ENABLE_JSON1 when building the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; and some of the test utilities so this extension is normally available in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">json1源代码包含在SQLite &lt;a href=&quot;amalgamation&quot;&gt;合并中&lt;/a&gt;，但默认情况下已禁用。添加&lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt;编译时选项，以启用内置于&lt;a href=&quot;amalgamation&quot;&gt;amalgamation中&lt;/a&gt;的json1扩展。构建&lt;a href=&quot;cli&quot;&gt;命令行外壳&lt;/a&gt;程序时，标准的makefile包括-DSQLITE_ENABLE_JSON1 以及一些测试实用程序，因此此扩展名通常在&lt;a href=&quot;cli&quot;&gt;命令行外壳&lt;/a&gt;程序中可用。</target>
        </trans-unit>
        <trans-unit id="bb08cc12ccf8da2d3e2af52ece257a447253b7e8" translate="yes" xml:space="preserve">
          <source>The json_array() SQL function accepts zero or more arguments and returns a well-formed JSON array that is composed from those arguments. If any argument to json_array() is a BLOB then an error is thrown.</source>
          <target state="translated">json_array()SQL函数接受0个或多个参数,并返回一个由这些参数组成的格式良好的JSON数组。如果json_array()的任何参数是一个BLOB,那么就会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="9521182f315a0d302eb912198a80302f20c295c7" translate="yes" xml:space="preserve">
          <source>The json_array_length(X) function returns the number of elements in the JSON array X, or 0 if X is some kind of JSON value other than an array. The json_array_length(X,P) locates the array at path P within X and returns the length of that array, or 0 if path P locates an element or X other than a JSON array, and NULL if path P does not locate any element of X. Errors are thrown if either X is not well-formed JSON or if P is not a well-formed path.</source>
          <target state="translated">json_array_length(X)函数返回JSON数组X中的元素数,如果X是数组以外的JSON值,则返回0。json_array_length(X,P)函数定位X中的路径P处的数组,并返回数组的长度,如果路径P定位到了JSON数组以外的元素或X,则返回0;如果路径P没有定位到X中的任何元素,则返回NULL。如果X不是格式良好的JSON,或者P不是格式良好的路径,则会产生错误。</target>
        </trans-unit>
        <trans-unit id="a38155ffebbf6577ab0909bd9445bf04a40481a5" translate="yes" xml:space="preserve">
          <source>The json_each(X) and json_tree(X) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; walk the JSON value provided as their first argument and return one row for each element. The json_each(X) function only walks the immediate children of the top-level array or object or or just the top-level element itself if the top-level element is a primitive value. The json_tree(X) function recursively walks through the JSON substructure starting with the top-level element.</source>
          <target state="translated">&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt; json_each（X）和json_tree（X）遍历作为其第一个参数提供的JSON值，并为每个元素返回一行。json_each（X）函数仅遍历顶级数组或对象的直接子级，或者如果顶级元素是原始值，则仅遍历顶级元素本身。json_tree（X）函数以递归的方式遍历从顶层元素开始的JSON子结构。</target>
        </trans-unit>
        <trans-unit id="41fff21b05289cb2b0be52b887077b0fcae3db31" translate="yes" xml:space="preserve">
          <source>The json_each(X,P) and json_tree(X,P) functions work just like their one-argument counterparts except that they treat the element identified by path P as the top-level element.</source>
          <target state="translated">json_each(X,P)和json_tree(X,P)函数的工作原理和它们的单参数对应函数一样,只是它们将路径P所标识的元素视为顶层元素。</target>
        </trans-unit>
        <trans-unit id="c2ff80179397d0e306699ce5e6f1d0c9aff0af74" translate="yes" xml:space="preserve">
          <source>The json_extract(X,P1,P2,...) extracts and returns one or more values from the well-formed JSON at X. If only a single path P1 is provided, then the SQL datatype of the result is NULL for a JSON null, INTEGER or REAL for a JSON numeric value, an INTEGER zero for a JSON false value, an INTEGER one for a JSON true value, the dequoted text for a JSON string value, and a text representation for JSON object and array values. If there are multiple path arguments (P1, P2, and so forth) then this routine returns SQLite text which is a well-formed JSON array holding the various values.</source>
          <target state="translated">json_extract(X,P1,P2,...)从X处格式良好的JSON中提取并返回一个或多个值。如果只提供了一个路径P1,那么结果的SQL数据类型为:JSON空值为NULL,JSON数值为INTEGER或REAL,JSON假值为INTEGER 0,JSON真值为INTEGER 1,JSON字符串值为去引号文本,JSON对象和数组值为文本表示。如果有多个路径参数(P1、P2等),那么这个例程就会返回SQLite文本,这个文本是一个格式良好的JSON数组,存放着各种值。</target>
        </trans-unit>
        <trans-unit id="0f1627c2753898c7b2ebba7d223fce4a18da0c11" translate="yes" xml:space="preserve">
          <source>The json_group_array(X) function is an &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate SQL function&lt;/a&gt; that returns a JSON array comprised of all X values in the aggregation. Similarly, the json_group_object(NAME,VALUE) function returns a JSON object comprised of all NAME/VALUE pairs in the aggregation.</source>
          <target state="translated">json_group_array（X）函数是一个&lt;a href=&quot;lang_aggfunc&quot;&gt;聚合SQL函数&lt;/a&gt;，该函数返回一个由聚合中所有X值组成的JSON数组。同样，json_group_object（NAME，VALUE）函数返回由聚合中的所有NAME / VALUE对组成的JSON对象。</target>
        </trans-unit>
        <trans-unit id="08b54ec339ea85bd242a6d5ab159f649d0636c35" translate="yes" xml:space="preserve">
          <source>The json_insert(), json_replace(), and json_set() functions always take an odd number of arguments. The first argument is always the original JSON to be edited. Subsequent arguments occur in pairs with the first element of each pair being a path and the second element being the value to insert or replace or set on that path.</source>
          <target state="translated">json_insert()、json_replace()和json_set()函数总是取奇数的参数。第一个参数总是要编辑的原始JSON。随后的参数成对出现,每个参数对的第一个元素是一个路径,第二个元素是要插入或替换或设置在该路径上的值。</target>
        </trans-unit>
        <trans-unit id="cc677da89c2d6a3534f49f58dca0325fe7275ac0" translate="yes" xml:space="preserve">
          <source>The json_insert(), json_replace, and json_set() functions all take a single JSON value as their first argument followed by zero or more pairs of path and value arguments, and return a new JSON string formed by updating the input JSON by the path/value pairs. The functions differ only in how they deal with creating new values and overwriting preexisting values.</source>
          <target state="translated">json_insert()、json_replace和json_set()函数都以一个JSON值作为它们的第一个参数,后面跟着零个或多个路径和值参数对,并返回一个新的JSON字符串,这个字符串是通过更新输入的JSON的路径/值对形成的。这些函数的不同之处仅在于它们如何处理创建新值和覆盖已有值。</target>
        </trans-unit>
        <trans-unit id="a89fe09131a222458243e59c86a47b9418f5cefc" translate="yes" xml:space="preserve">
          <source>The json_object() SQL function accepts zero or more pairs of arguments and returns a well-formed JSON object that is composed from those arguments. The first argument of each pair is the label and the second argument of each pair is the value. If any argument to json_object() is a BLOB then an error is thrown.</source>
          <target state="translated">json_object()SQL函数接受0个或多个参数对,并返回一个由这些参数组成的格式良好的JSON对象。每对参数的第一个参数是标签,第二个参数是值。如果json_object()的任何参数是一个BLOB,那么就会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="2288fffe16f420052bb17e5c8958c3ccdbc841f2" translate="yes" xml:space="preserve">
          <source>The json_object() function currently allows duplicate labels without complaint, though this might change in a future enhancement.</source>
          <target state="translated">json_object()函数目前允许重复的标签,不过这一点可能会在未来的改进中改变。</target>
        </trans-unit>
        <trans-unit id="5e496b884466eb1ac12c106e9502f3cd98163883" translate="yes" xml:space="preserve">
          <source>The json_patch(T,P) SQL function runs the &lt;a href=&quot;https://tools.ietf.org/html/rfc7396&quot;&gt;RFC-7396&lt;/a&gt; MergePatch algorithm to apply patch P against input T. The patched copy of T is returned.</source>
          <target state="translated">json_patch（T，P）SQL函数运行&lt;a href=&quot;https://tools.ietf.org/html/rfc7396&quot;&gt;RFC-7396&lt;/a&gt; MergePatch算法，将补丁P应用于输入T。返回T的补丁副本。</target>
        </trans-unit>
        <trans-unit id="d843d41461d41ce71296d2cc16a75e0d0ddb050b" translate="yes" xml:space="preserve">
          <source>The json_quote(X) function converts the SQL value X (a number or a string) into its corresponding JSON representation.</source>
          <target state="translated">json_quote(X)函数将SQL值X(一个数字或字符串)转换为相应的JSON表示。</target>
        </trans-unit>
        <trans-unit id="076810db69b99bc12f8c66592e6373c496370f8e" translate="yes" xml:space="preserve">
          <source>The json_remove() function throws an error if the first argument is not well-formed JSON or if any later argument is not a well-formed path, or if any argument is a BLOB.</source>
          <target state="translated">如果第一个参数不是格式良好的JSON,或者任何后面的参数不是格式良好的路径,或者任何参数是BLOB,那么json_remove()函数会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="07c228732927cc33b2fd2172e7d852ff75280285" translate="yes" xml:space="preserve">
          <source>The json_remove(X,P,...) function takes a single JSON value as its first argument followed by zero or more path arguments. The json_remove(X,P,...) function returns a new JSON value that is the X with all the elements identified by path arguments removed. Paths that select elements not found in X are silently ignored.</source>
          <target state="translated">json_remove(X,P,...)函数的第一个参数是一个JSON值,后面是0个或多个路径参数。json_remove(X,P,...)函数返回一个新的JSON值,这个新的JSON值就是X,它包含了路径参数所标识的所有元素。选择在X中没有找到的元素的路径会被默默忽略。</target>
        </trans-unit>
        <trans-unit id="dc2a43381f4cc4dcc4e70977bde02a9d9d1a46e8" translate="yes" xml:space="preserve">
          <source>The json_type() function throws an error if any of its arguments are not well-formed or is a BLOB.</source>
          <target state="translated">如果它的任何一个参数不是形式良好的或者是BLOB,json_type()函数会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="4607298214330613e115639247f1a2af460f4cfe" translate="yes" xml:space="preserve">
          <source>The json_type(X) function returns the &quot;type&quot; of the outermost element of X. The json_type(X,P) function returns the &quot;type&quot; of the element in X that is selected by path P. The &quot;type&quot; returned by json_type() is on of the following an SQL text values: 'null', 'true', 'false', 'integer', 'real', 'text', 'array', or 'object'. If the path P in json_type(X,P) selects an element that does not exist in X, then this function returns NULL.</source>
          <target state="translated">json_type(X)函数返回X中最外层元素的 &quot;类型&quot;。json_type(X,P)函数返回X中被路径P选中的元素的 &quot;类型&quot;。json_type()返回的 &quot;类型 &quot;是以下SQL文本值中的一种。'null'、'true'、'false'、'integer'、'real'、'text'、'array'或'object'。如果json_type(X,P)中的路径P选择了一个在X中不存在的元素,那么这个函数返回NULL。</target>
        </trans-unit>
        <trans-unit id="719a758ba2801754e03a7b8fe39124f85c9b0d1b" translate="yes" xml:space="preserve">
          <source>The json_type(X) function returns the &quot;type&quot; of the outermost element of X. The json_type(X,P) function returns the &quot;type&quot; of the element in X that is selected by path P. The &quot;type&quot; returned by json_type() is one of the following an SQL text values: 'null', 'true', 'false', 'integer', 'real', 'text', 'array', or 'object'. If the path P in json_type(X,P) selects an element that does not exist in X, then this function returns NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98bb00412965806c0f2fa0e24dcf65a44105fd64" translate="yes" xml:space="preserve">
          <source>The json_valid(X) function return 1 if the argument X is well-formed JSON and return 0 if the argument X is not well-formed JSON.</source>
          <target state="translated">json_valid(X)函数如果参数X是格式良好的JSON,则返回1,如果参数X不是格式良好的JSON,则返回0。</target>
        </trans-unit>
        <trans-unit id="b554cbe69a3700d4f56fb5609be0488decea2e7b" translate="yes" xml:space="preserve">
          <source>The key element of a</source>
          <target state="translated">的关键因素。</target>
        </trans-unit>
        <trans-unit id="1f79347fd256f18500712ca620e7ffb89d509d9e" translate="yes" xml:space="preserve">
          <source>The key point is that SQLite is very forgiving of the type of data that you put into the database. For example, if a column has a datatype of &quot;INTEGER&quot; and the application inserts a text string into that column, SQLite will first try to convert the text string into an integer, just like every other SQL database engine. Thus, if one inserts &lt;b&gt;'1234'&lt;/b&gt; into an INTEGER column, that value is converted into an integer 1234 and stored. But, if you insert a non-numeric string like &lt;b&gt;'wxyz'&lt;/b&gt; into an INTEGER column, unlike other SQL databases, SQLite does not throw an error. Instead, SQLite stores the actual string value in the column.</source>
          <target state="translated">关键是，SQLite非常宽容您放入数据库中的数据类型。例如，如果某列的数据类型为&amp;ldquo; INTEGER&amp;rdquo;，并且应用程序在该列中插入了文本字符串，则与其他所有SQL数据库引擎一样，SQLite将首先尝试将文本字符串转换为整数。因此，如果将&lt;b&gt;&amp;ldquo; 1234&amp;rdquo;&lt;/b&gt;插入到INTEGER列中，则该值将转换为整数1234并存储。但是，与其他SQL数据库不同，如果将像&lt;b&gt;'wxyz'&lt;/b&gt;这样的非数字字符串插入INTEGER列，则SQLite不会引发错误。相反，SQLite将实际的字符串值存储在该列中。</target>
        </trans-unit>
        <trans-unit id="3e290f56c0ef256cb5bbb18b2ba0fb09ea68db61" translate="yes" xml:space="preserve">
          <source>The key point is this: Building the CLI consists of compiling together two C-language files. The &lt;b&gt;shell.c&lt;/b&gt; file contains the definition of the entry point and the user input loop and the SQLite amalgamation &lt;b&gt;sqlite3.c&lt;/b&gt; contains the complete implementation of the SQLite library.</source>
          <target state="translated">关键是：构建CLI包括将两个C语言文件编译在一起。该&lt;b&gt;shell.c&lt;/b&gt;文件包含入口点的定义和用户输入回路和SQLite的融合&lt;b&gt;sqlite3.c&lt;/b&gt;包含了SQLite库的完整实现。</target>
        </trans-unit>
        <trans-unit id="bb2fbeab5253f75ff8183f69852d5cbb7ab2bba6" translate="yes" xml:space="preserve">
          <source>The key points of the previous example were the use of the Callback instruction to invoke the callback function, and the use of the Next instruction to implement a loop over all records of the database file. This example attempts to drive home those ideas by demonstrating a slightly more complex query that involves more columns of output, some of which are computed values, and a WHERE clause that limits which records actually make it to the callback function. Consider this query:</source>
          <target state="translated">上一个例子的关键点是使用Callback指令来调用回调函数,以及使用Next指令来实现对数据库文件所有记录的循环。这个例子试图通过演示一个略微复杂的查询来阐述这些观点,这个查询涉及更多的输出列,其中一些是计算值,还有一个WHERE子句来限制哪些记录实际进入回调函数。考虑一下这个查询。</target>
        </trans-unit>
        <trans-unit id="986f899677204f1290b417dd64fe3fcaa05f7c30" translate="yes" xml:space="preserve">
          <source>The keys used by each segment b-tree are terms (words). As well as the key, each segment b-tree entry has an associated &quot;doclist&quot; (document list). A doclist consists of zero or more entries, where each entry consists of:</source>
          <target state="translated">每个段b树使用的键是术语(词)。除了键,每个段b树条目还有一个相关的 &quot;doclist&quot;(文档列表)。doclist由0个或多个条目组成,其中每个条目包括:</target>
        </trans-unit>
        <trans-unit id="a93934848f28a5d1e280c92cac942b828e6dc7e9" translate="yes" xml:space="preserve">
          <source>The keyword &quot;INSERT&quot;, &quot;UPDATE&quot;, or &quot;DELETE&quot;, as appropriate</source>
          <target state="translated">关键字 &quot;INSERT&quot;、&quot;UPDATE &quot;或 &quot;DELETE&quot;,视情况而定。</target>
        </trans-unit>
        <trans-unit id="799f75f9fa5e2cb1d9335f9637de442233918b1a" translate="yes" xml:space="preserve">
          <source>The kvtest program is compiled and run on Android as follows. First install the Android SDK and NDK. Then prepare a script named &quot;android-gcc&quot; that looks approximately like this:</source>
          <target state="translated">kvtest程序在Android上编译运行的方法如下。首先安装Android SDK和NDK。然后准备一个名为 &quot;android-gcc &quot;的脚本,大致如下。</target>
        </trans-unit>
        <trans-unit id="a518e69633f247201841ea47eb51e547b9e7d52f" translate="yes" xml:space="preserve">
          <source>The label to the right of an AS in the column list of a SELECT can now be used as part of an expression in the WHERE, ORDER BY, GROUP BY, and/or HAVING clauses.</source>
          <target state="translated">现在,SELECT列列表中AS右边的标签可以作为WHERE、ORDER BY、GROUP BY和/或HAVING子句中表达式的一部分。</target>
        </trans-unit>
        <trans-unit id="5d78c31e6fd49e38e9a6929f67e573c2fcc27d5f" translate="yes" xml:space="preserve">
          <source>The language id for this entry.</source>
          <target state="translated">本条目的语言标识。</target>
        </trans-unit>
        <trans-unit id="e80fa2a23c99c4e0919bc332ef910ec1f3215c2c" translate="yes" xml:space="preserve">
          <source>The languageid option causes the FTS4 table to have an additional hidden integer column that identifies the language of the text contained in each row. The use of the languageid option allows the same FTS4 table to hold text in multiple languages or scripts, each with different tokenizer rules, and to query each language independently of the others.</source>
          <target state="translated">languageid 选项使 FTS4 表有一个额外的隐藏整数列,用于标识每行所含文本的语言。使用languageid选项可以让同一个FTS4表容纳多种语言或脚本的文本,每种语言或脚本都有不同的标记规则,并且可以独立查询每种语言。</target>
        </trans-unit>
        <trans-unit id="333c7dbdc428cf52a63d6a76d33660a2004630b2" translate="yes" xml:space="preserve">
          <source>The largest payload found anywhere in the current page or btree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a93c8c9ebe55117d8275a20a3a64f1279cc0414" translate="yes" xml:space="preserve">
          <source>The largest possible setting for SQLITE_MAX_PAGE_COUNT is 2147483646. When used with the maximum page size of 65536, this gives a maximum SQLite database size of about 140 terabytes.</source>
          <target state="translated">SQLITE_MAX_PAGE_COUNT的最大可能设置是2147483646。当与最大页面大小65536一起使用时,这将使SQLite数据库的最大大小约为140TB。</target>
        </trans-unit>
        <trans-unit id="4e80216c90c51ba3170a6cfbdb6ff5453a279861" translate="yes" xml:space="preserve">
          <source>The largest possible setting for SQLITE_MAX_PAGE_COUNT is 4294967294. When used with the maximum page size of 65536, this gives a maximum SQLite database size of about 281 terabytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0fabb1072d1e3ea604e33e251741f22426c0f61" translate="yes" xml:space="preserve">
          <source>The last (fourth) bullet above merits additional comment. When SQLite creates a journal file on Unix, it opens the directory that contains that file and calls fsync() on the directory, in an effort to push the directory information to disk. But suppose some other process is adding or removing unrelated files to the directory that contains the database and journal at the moment of a power failure. The supposedly unrelated actions of this other process might result in the journal file being dropped from the directory and moved into &quot;lost+found&quot;. This is an unlikely scenario, but it could happen. The best defenses are to use a journaling filesystem or to keep the database and journal in a directory by themselves.</source>
          <target state="translated">上面最后一个(第四个)项目值得补充评论。当SQLite在Unix上创建一个日志文件时,它会打开包含该文件的目录,并对该目录调用fsync(),努力将目录信息推送到磁盘上。但假设在断电的时刻,有其他进程在向包含数据库和日志的目录中添加或删除不相关的文件。这个其他进程的所谓不相关的行为可能会导致日志文件从目录中被删除,并移到 &quot;丢失+发现 &quot;中。这种情况不太可能,但有可能发生。最好的防御措施是使用日志文件系统,或者将数据库和日志单独放在一个目录中。</target>
        </trans-unit>
        <trans-unit id="0d792644cd574497ddbf62ba435f6dbc99253564" translate="yes" xml:space="preserve">
          <source>The last bullet above is illustrated by the following:</source>
          <target state="translated">上述最后一个项目的说明如下:</target>
        </trans-unit>
        <trans-unit id="6fcee6d642fa1ca93fa14337ac4410163d2a9df9" translate="yes" xml:space="preserve">
          <source>The last output mode is &quot;html&quot;. In this mode, sqlite3 writes the results of the query as an XHTML table. The beginning &amp;lt;TABLE&amp;gt; and the ending &amp;lt;/TABLE&amp;gt; are not written, but all of the intervening &amp;lt;TR&amp;gt;s, &amp;lt;TH&amp;gt;s, and &amp;lt;TD&amp;gt;s are. The html output mode is envisioned as being useful for CGI.</source>
          <target state="translated">最后的输出模式是&amp;ldquo; html&amp;rdquo;。在这种模式下，sqlite3将查询结果写入XHTML表。开头的&amp;lt;TABLE&amp;gt;和结尾的&amp;lt;/ TABLE&amp;gt;均未写入，但所有中间的&amp;lt;TR&amp;gt;，&amp;lt;TH&amp;gt;和&amp;lt;TD&amp;gt;均已写入。可以设想html输出模式对于CGI很有用。</target>
        </trans-unit>
        <trans-unit id="a123c1f8dadbf6bb9cc227ef0871a1fb2cbe0f9d" translate="yes" xml:space="preserve">
          <source>The last parameter to the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; routines is a pointer to a procedure used to dispose of the P pointer once SQLite has finished with it. This pointer can be NULL, in which case no destructor is called.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;和&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;例程的最后一个参数是指向SQLite完成处理P指针的过程的指针。该指针可以为NULL，在这种情况下，不会调用任何析构函数。</target>
        </trans-unit>
        <trans-unit id="d52a179000f827088051359c744fec0210401d8f" translate="yes" xml:space="preserve">
          <source>The last step in the commit process is to release the exclusive lock so that other processes can once again start accessing the database file.</source>
          <target state="translated">提交过程的最后一步是释放独占锁,以便其他进程可以再次开始访问数据库文件。</target>
        </trans-unit>
        <trans-unit id="56b9bbac0263da28aef9dee3010ecc1e8725f669" translate="yes" xml:space="preserve">
          <source>The last transaction started will be the first transaction committed or rolled back.</source>
          <target state="translated">最后启动的交易将是第一个提交或回滚的交易。</target>
        </trans-unit>
        <trans-unit id="c2015d5e4ba733546bdea54c6daefbab27ed0b3f" translate="yes" xml:space="preserve">
          <source>The last two allocations can be controlled and/or eliminated by configuring the &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;, and &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; appropriately, as described above. The storage space required for &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects depends to some extent on the length of the filename of the database file, but rarely exceeds 2KB on 32-bit systems. (More space is required on 64-bit systems due to the increased size of pointers.) Each parser object uses about 1.6KB of memory. Thus, elements 3 through 7 above can easily be controlled to keep the maximum memory allocation size below 2KB.</source>
          <target state="translated">如上所述，可以通过适当地配置页面&lt;a href=&quot;malloc#pagecache&quot;&gt;缓存内存分配器&lt;/a&gt;和&lt;a href=&quot;malloc#lookaside&quot;&gt;后备内存分配器&lt;/a&gt;来控制和/或消除最后两个分配。&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;对象所需的存储空间在某种程度上取决于数据库文件名的长度，但在32位系统上很少超过2KB。 （由于指针的增加，在64位系统上需要更多空间。）每个解析器对象使用大约1.6KB的内存。因此，可以容易地控制上述元件3至7以将最大存储器分配大小保持在2KB以下。</target>
        </trans-unit>
        <trans-unit id="dd770eea393f2ccabe1cb964e8f446d8577e90ba" translate="yes" xml:space="preserve">
          <source>The last two queries take the same amount of time, in our example. So which index, Idx1 or Idx2, will SQLite choose? If the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command has been run on the database, so that SQLite has had an opportunity to gather statistics about the available indices, then SQLite will know that the Idx1 index usually narrows the search down to a single item (our example of fruit='Orange' is the exception to this rule) whereas the Idx2 index will normally only narrow the search down to two rows. So, if all else is equal, SQLite will choose Idx1 with the hope of narrowing the search to as small a number of rows as possible. This choice is only possible because of the statistics provided by &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;. If &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has not been run then the choice of which index to use is arbitrary.</source>
          <target state="translated">在我们的示例中，最后两个查询花费相同的时间。那么，SQLite将选择哪个索引Idx1或Idx2？如果在数据库上运行了&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令，则SQLite有机会收集了有关可用索引的统计信息，那么SQLite将知道Idx1索引通常将搜索范围缩小到单个项目（我们的fruit ='示例）。橙色&amp;rdquo;是该规则的例外），而Idx2索引通常只会将搜索范围缩小到两行。因此，如果其他所有条件都相等，SQLite将选择Idx1，希望将搜索范围缩小到尽可能少的行。由于&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;提供的统计信息，因此只能进行此选择。如果&lt;a href=&quot;lang_analyze&quot;&gt;分析&lt;/a&gt; 尚未运行，则选择使用哪个索引是任意的。</target>
        </trans-unit>
        <trans-unit id="0271db818028a9ffb097a09e837d0647ab050705" translate="yes" xml:space="preserve">
          <source>The last_insert_rowid() function returns the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; of the last row insert from the database connection which invoked the function. The last_insert_rowid() SQL function is a wrapper around the &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; C/C++ interface function.</source>
          <target state="translated">last_insert_rowid（）函数从调用该函数的数据库连接返回最后一行插入的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;。last_insert_rowid（）SQL函数是&lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt; C / C ++接口函数的包装。</target>
        </trans-unit>
        <trans-unit id="dc54cc3b765595ad1e2bcb9ada53a0d0dfaa1af8" translate="yes" xml:space="preserve">
          <source>The latest checklists contain approximately 200 items that are individually verified for each release. Some checklist items only take a few seconds to verify and mark off. Others involve test suites that run for many hours.</source>
          <target state="translated">最新的核对表包含大约200个项目,这些项目是针对每个版本进行单独验证的。有些检查清单项目只需要几秒钟的时间来验证和标记。其他项目则涉及运行数小时的测试套件。</target>
        </trans-unit>
        <trans-unit id="972ae3a81fba75ac7b1cb927798468eb94557f5e" translate="yes" xml:space="preserve">
          <source>The latter query can not use the partial index because there might be rows in the table with b=456 and where c is NULL. But those rows would not be in the partial index.</source>
          <target state="translated">后一个查询不能使用部分索引,因为在表中可能有b=456的记录,并且c是NULL。但是这些记录不会出现在部分索引中。</target>
        </trans-unit>
        <trans-unit id="5d0da56ef4fd6dfbe12fe3015e9d0a6d277654f6" translate="yes" xml:space="preserve">
          <source>The leftmost column of the &quot;%_content&quot; table is an INTEGER PRIMARY KEY field named &quot;docid&quot;. Following this is one column for each column of the FTS virtual table as declared by the user, named by prepending the column name supplied by the user with &quot;c</source>
          <target state="translated">&quot;%_content &quot;表的最左边一列是一个名为 &quot;docid &quot;的INTEGER主键字段。在这之后是用户声明的FTS虚拟表的每一列,命名时在用户提供的列名前加上 &quot;c</target>
        </trans-unit>
        <trans-unit id="3fe10f10852f3ac1156d75127fc7c938a298af76" translate="yes" xml:space="preserve">
          <source>The legacy &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; compile-time option is now a no-op.</source>
          <target state="translated">现在，旧版&lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3的&lt;/a&gt;编译时选项为空操作。</target>
        </trans-unit>
        <trans-unit id="19d5e9050bddb7e40ed3e17c750502a0acf23cf7" translate="yes" xml:space="preserve">
          <source>The legacy alter table behavior can also be toggled on and off using the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyaltertable&quot;&gt;SQLITE_DBCONFIG_LEGACY_ALTER_TABLE&lt;/a&gt; option to the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface.</source>
          <target state="translated">也可以使用&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;接口的&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyaltertable&quot;&gt;SQLITE_DBCONFIG_LEGACY_ALTER_TABLE&lt;/a&gt;选项来打开和关闭旧式alter table行为。</target>
        </trans-unit>
        <trans-unit id="41fd664aa5a45cba5ac773955a3426725e8decb9" translate="yes" xml:space="preserve">
          <source>The legacy alter table behavior is a per-connection setting. Turning this features on or off affects all attached database files within the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. The setting does not persist. Changing this setting in one connection does not affect any other connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0281c5597d6458d92c064f8c4ce4817fe25c10e" translate="yes" xml:space="preserve">
          <source>The legacy xGeom callback is invoked with four arguments. The first argument is a pointer to an sqlite3_rtree_geometry structure which provides information about how the SQL function was invoked. The second argument is the number of coordinates in each r-tree entry, and is always the same for any given R*Tree. The number of coordinates is 2 for a 1-dimensional R*Tree, 4 for a 2-dimensional R*Tree, 6 for a 3-dimensional R*Tree, and so forth. The third argument, aCoord[], is an array of nCoord coordinates that defines a bounding box to be tested. The last argument is a pointer into which the callback result should be written. The result is zero if the bounding-box defined by aCoord[] is completely outside the region defined by the xGeom callback and the result is non-zero if the bounding-box is inside or overlaps with the xGeom region. The xGeom callback should normally return SQLITE_OK. If xGeom returns anything other than SQLITE_OK, then the r-tree query will abort with an error.</source>
          <target state="translated">传统的xGeom回调有四个参数。第一个参数是指向 sqlite3_rtree_geometry 结构的指针,它提供了关于 SQL 函数如何被调用的信息。第二个参数是每个r-tree条目中的坐标数,对于任何给定的R*Tree来说,坐标数总是相同的。一维R*Tree的坐标数为2,二维R*Tree为4,三维R*Tree为6,以此类推。第三个参数aCoord[]是一个nCoord坐标数组,定义了一个要测试的边界框。最后一个参数是一个指针,回调结果应该写入其中。如果aCoord[]定义的边界框完全在xGeom回调定义的区域之外,则结果为零;如果边界框在xGeom区域内或与xGeom区域重合,则结果为非零。xGeom回调通常应该返回SQLITE_OK。如果xGeom返回的不是SQLITE_OK,那么r-tree查询将以错误的方式中止。</target>
        </trans-unit>
        <trans-unit id="c26ac59b1bddfababdeff98e88ee3a4d181edb8a" translate="yes" xml:space="preserve">
          <source>The legacy_file_format pragma is initialized to OFF when an existing database in the newer file format is first opened.</source>
          <target state="translated">当第一次打开一个较新文件格式的现有数据库时,legacy_file_format pragma被初始化为OFF。</target>
        </trans-unit>
        <trans-unit id="5c416af28ee6cf9f448dc251869a118022ef5870" translate="yes" xml:space="preserve">
          <source>The length of a function name may not exceed 255 characters. Any attempt to create a function whose name exceeds 255 characters in length will result in an error.</source>
          <target state="translated">一个函数名称的长度不能超过255个字符。任何试图创建一个名称长度超过255个字符的函数都会导致错误。</target>
        </trans-unit>
        <trans-unit id="64a58fb27f585f3af736420c55a5c7aba354a480" translate="yes" xml:space="preserve">
          <source>The length of the argument value can be specified by one or more letters that occur just prior to the substitution type letter. In SQLite, the length only matter for integer types. The length is ignored for the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; which always uses 64-bit values. The following table shows the length specifiers allowed by SQLite:</source>
          <target state="translated">参数值的长度可以由替换类型字母之前的一个或多个字母指定。在SQLite中，长度仅与整数类型有关。对于始终使用64位值的&lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf（）SQL函数&lt;/a&gt;，将忽略该长度。下表显示了SQLite允许的长度说明符：</target>
        </trans-unit>
        <trans-unit id="835ff0a5a3c1f19c6461eba222151b4907f96047" translate="yes" xml:space="preserve">
          <source>The letter &quot;j&quot; pronounced like &quot;h&quot; in Spanish: LaJolla</source>
          <target state="translated">字母 &quot;j &quot;在西班牙语中发音像 &quot;h&quot;。LaJolla</target>
        </trans-unit>
        <trans-unit id="ee9eb5ebb3823c5e0db14477052af2948a8b37ee" translate="yes" xml:space="preserve">
          <source>The library now assumes data is stored as UTF-8 if the --enable-utf8 option is given to configure. The default behavior is to assume iso8859-x, as it has always done. This only makes a difference for LIKE and GLOB operators and the LENGTH and SUBSTR functions.</source>
          <target state="translated">如果给定了 --enable-utf8 选项来配置,该库现在假定数据以 UTF-8 存储。默认的行为是假设为iso8859-x,因为它一直都是这样做的。这只对 LIKE 和 GLOB 操作符以及 LENGTH 和 SUBSTR 函数有所区别。</target>
        </trans-unit>
        <trans-unit id="2b11a2ab2af2c4ff66c5a4f077ed6909c7421f85" translate="yes" xml:space="preserve">
          <source>The life-cycle of a prepared statement object usually goes like this:</source>
          <target state="translated">一个准备好的报表对象的生命周期通常是这样的。</target>
        </trans-unit>
        <trans-unit id="610e163977a4d438d498cc7745085654d18422e2" translate="yes" xml:space="preserve">
          <source>The lifecycle of an sqlite3_str object is as follows:</source>
          <target state="translated">sqlite3_str对象的生命周期如下。</target>
        </trans-unit>
        <trans-unit id="e1c985dd036afafc48409f9dec76735bbf115b4e" translate="yes" xml:space="preserve">
          <source>The like() function is used to implement the &quot;&lt;b&gt;Y LIKE X [ESCAPE Z]&lt;/b&gt;&quot; expression. If the optional ESCAPE clause is present, then the like() function is invoked with three arguments. Otherwise, it is invoked with two arguments only. Note that the X and Y parameters are reversed in the like() function relative to the infix &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator. X is the pattern and Y is the string to match against that pattern. Hence, the following expressions are equivalent:</source>
          <target state="translated">like（）函数用于实现&amp;ldquo; &lt;b&gt;Y LIKE X [ESCAPE Z]&lt;/b&gt; &amp;rdquo;表达式。如果存在可选的ESCAPE子句，则使用三个参数调用like（）函数。否则，仅使用两个参数调用它。请注意，like（）函数中的X和Y参数相对于infix &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;运算符是相反的。 X是模式，Y是要与该模式匹配的字符串。因此，以下表达式是等效的：</target>
        </trans-unit>
        <trans-unit id="1725d5bdba0b7e8833554a2371c0c343ab2395e2" translate="yes" xml:space="preserve">
          <source>The likelihood(X,Y) function returns argument X unchanged. The value Y in likelihood(X,Y) must be a floating point constant between 0.0 and 1.0, inclusive. The likelihood(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles during run-time (that is, during calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;). The purpose of the likelihood(X,Y) function is to provide a hint to the query planner that the argument X is a boolean that is true with a probability of approximately Y. The &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely(X)&lt;/a&gt; function is short-hand for likelihood(X,0.0625). The &lt;a href=&quot;lang_corefunc#likely&quot;&gt;likely(X)&lt;/a&gt; function is short-hand for likelihood(X,0.9375).</source>
          <target state="translated">似然性（X，Y）函数不变地返回参数X。似然性（X，Y）中的值Y必须是介于0.0和1.0之间（包括两者）的浮点常量。似然性（X）函数是一种无操作，代码生成器会对其进行优化，以使其在运行时（即在调用&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;期间）不占用任何CPU周期。似然的（X，Y）的目的的功能是提供一个提示来查询规划该参数X是一个布尔值，是真正用约Y的概率&lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;不可能的（X）&lt;/a&gt;函数是短手的可能性（ X，0.0625）。的&lt;a href=&quot;lang_corefunc#likely&quot;&gt;可能的（X）&lt;/a&gt;函数是短手的可能性（X，0.9375）。</target>
        </trans-unit>
        <trans-unit id="047f4505a74dbe546931a88238b570dcea0e5906" translate="yes" xml:space="preserve">
          <source>The likely(X) function returns the argument X unchanged. The likely(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles at run-time (that is, during calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;). The purpose of the likely(X) function is to provide a hint to the query planner that the argument X is a boolean value that is usually true. The likely(X) function is equivalent to &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood&lt;/a&gt;(X,0.9375). See also: &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely(X)&lt;/a&gt;.</source>
          <target state="translated">可能的（X）函数返回参数X不变。可能（X）函数是一个无操作函数，代码生成器会对其进行优化，以使其在运行时（即在调用&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;期间）不占用任何CPU周期。 Possible（X）函数的目的是向查询计划者提供一个提示，即参数X是通常为true的布尔值。可能性（X）函数等效于&lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;可能性&lt;/a&gt;（X，0.9375）。另请参阅：&lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;不太可能（X）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="604c341d9009d83169d386485e03d9e7bc04c662" translate="yes" xml:space="preserve">
          <source>The limit value is set to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7008986405b40055720891f4830c40ce21496380" translate="yes" xml:space="preserve">
          <source>The line &quot;.once</source>
          <target state="translated">这一行&quot;.一旦</target>
        </trans-unit>
        <trans-unit id="d0c3acc92dc701e819ac94a0c8098f2db90a205c" translate="yes" xml:space="preserve">
          <source>The list below is not exhaustive. Other virtual table implementation exist in the SQLite source tree and elsewhere. The list below tries to capture the more interesting virtual table implementations.</source>
          <target state="translated">下面的列表并不详尽。在SQLite源码树和其他地方还存在其他的虚拟表实现。下面的列表试图捕捉更有趣的虚拟表实现。</target>
        </trans-unit>
        <trans-unit id="d3b78caa21f35e034eafcfa346ed07394d0ca6e0" translate="yes" xml:space="preserve">
          <source>The list below shows all possible keywords used by any build of SQLite regardless of &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt;. Most reasonable configurations use most or all of these keywords, but some keywords may be omitted when SQL language features are disabled. Applications can use the &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count()&lt;/a&gt;, &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name()&lt;/a&gt;, and &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check()&lt;/a&gt; interfaces to determine the keywords recognized by SQLite at run-time. Regardless of the compile-time configuration, any identifier that is not on the following 143 element list is not a keyword to the SQL parser in SQLite:</source>
          <target state="translated">下面的列表显示了任何SQLite版本都使用的所有可能的关键字，而不管&lt;a href=&quot;compile&quot;&gt;编译时选项如何&lt;/a&gt;。最合理的配置使用大多数或所有这些关键字，但是当禁用SQL语言功能时，某些关键字可能会省略。应用程序可以使用&lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count（）&lt;/a&gt;，&lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name（）&lt;/a&gt;和&lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check（）&lt;/a&gt;接口来确定SQLite在运行时识别的关键字。不管编译时配置如何，不在以下143元素列表中的任何标识符都不是SQLite中SQL解析器的关键字：</target>
        </trans-unit>
        <trans-unit id="0180a1bb67bb5f33291414ccd4cfdc93226599e9" translate="yes" xml:space="preserve">
          <source>The list below shows all possible keywords used by any build of SQLite regardless of &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt;. Most reasonable configurations use most or all of these keywords, but some keywords may be omitted when SQL language features are disabled. Applications can use the &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count()&lt;/a&gt;, &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name()&lt;/a&gt;, and &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check()&lt;/a&gt; interfaces to determine the keywords recognized by SQLite at run-time. Regardless of the compile-time configuration, any identifier that is not on the following 145 element list is not a keyword to the SQL parser in SQLite:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="281c02e8bf5d35129f9e1be609bd2e9295d15355" translate="yes" xml:space="preserve">
          <source>The list of coordinates in the binary format contains no redundancy. The last coordinate is not a repeat of the first as it is with GeoJSON. Hence, there is always one fewer coordinate pair in the binary representation of a polygon compared to the GeoJSON representation.</source>
          <target state="translated">二进制格式的坐标列表不包含多余的内容。最后一个坐标不会像GeoJSON那样重复第一个坐标。因此,与GeoJSON表示法相比,多边形的二进制表示法总是少一个坐标对。</target>
        </trans-unit>
        <trans-unit id="31509dccb06d1116de02483b9bec949662404996" translate="yes" xml:space="preserve">
          <source>The list of expressions between the SELECT and FROM keywords is known as the result expression list. If a result expression is the special expression &quot;*&quot; then all columns in the input data are substituted for that one expression. If the expression is the alias of a table or subquery in the FROM clause followed by &quot;.*&quot; then all columns from the named table or subquery are substituted for the single expression. It is an error to use a &quot;*&quot; or &quot;alias.*&quot; expression in any context other than a result expression list. It is also an error to use a &quot;*&quot; or &quot;alias.*&quot; expression in a simple SELECT query that does not have a FROM clause.</source>
          <target state="translated">SELECT和FROM关键字之间的表达式列表称为结果表达式列表。如果结果表达式是特殊表达式 &quot;*&quot;,那么输入数据中的所有列都会被这一个表达式所替代。如果表达式是FROM子句中表或子查询的别名,后面加&quot;.*&quot;,那么被命名的表或子查询中的所有列都会被这一个表达式所替代。在结果表达式列表以外的任何上下文中使用 &quot;*&quot;或 &quot;alias.*&quot;表达式都是错误的。在没有FROM子句的简单SELECT查询中使用 &quot;*&quot;或 &quot;alias.*&quot;表达式也是错误的。</target>
        </trans-unit>
        <trans-unit id="aff07670c95df2683c32cdb3b9c35bd30fecbe25" translate="yes" xml:space="preserve">
          <source>The list of integers in the stat column can optionally be followed by arguments, each of which is a sequence of non-space characters. All arguments are preceded by a single space. Unrecognized arguments are silently ignored.</source>
          <target state="translated">统计列中的整数列表可以选择跟在参数后面,每个参数都是一个非空格字符的序列。所有参数前面都有一个空格。未识别的参数将被忽略。</target>
        </trans-unit>
        <trans-unit id="5c584c3300424511e57cf7c45771316447fd9008" translate="yes" xml:space="preserve">
          <source>The load_extension() function will fail if the extension attempts to modify or delete an SQL function or collating sequence. The extension can add new functions or collating sequences, but cannot modify or delete existing functions or collating sequences because those functions and/or collating sequences might be used elsewhere in the currently running SQL statement. To load an extension that changes or deletes functions or collating sequences, use the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; C-language API.</source>
          <target state="translated">如果扩展尝试修改或删除SQL函数或整理序列，则load_extension（）函数将失败。该扩展可以添加新功能或整理序列，但不能修改或删除现有功能或整理序列，因为这些功能和/或整理序列可能在当前运行的SQL语句中的其他位置使用。要加载更改或删除函数或整理序列的扩展，请使用&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt; C语言API。</target>
        </trans-unit>
        <trans-unit id="349abdc2376164ceeb049d0fdce3e4218d275600" translate="yes" xml:space="preserve">
          <source>The load_extension(X,Y) function loads &lt;a href=&quot;loadext&quot;&gt;SQLite extensions&lt;/a&gt; out of the shared library file named X using the entry point Y. The result of load_extension() is always a NULL. If Y is omitted then the default entry point name is used. The load_extension() function raises an exception if the extension fails to load or initialize correctly.</source>
          <target state="translated">load_extension（X，Y）函数使用入口点Y从名为X的共享库文件中加载&lt;a href=&quot;loadext&quot;&gt;SQLite扩展&lt;/a&gt;。load_extension（）的结果始终为NULL。如果省略Y，则使用默认入口点名称。如果扩展无法正确加载或初始化，load_extension（）函数将引发异常。</target>
        </trans-unit>
        <trans-unit id="3c476d76e8d35e3c5addfedd0889c28cfa2868c0" translate="yes" xml:space="preserve">
          <source>The local copy of the remote head</source>
          <target state="translated">远程云台的本地副本</target>
        </trans-unit>
        <trans-unit id="9c687c8acb9d37e788292221df58e5cc9d9b9e4e" translate="yes" xml:space="preserve">
          <source>The local head</source>
          <target state="translated">当地负责人</target>
        </trans-unit>
        <trans-unit id="ef999d9e04e59df040c534586df9501decb45621" translate="yes" xml:space="preserve">
          <source>The lock-byte page</source>
          <target state="translated">锁定字节页</target>
        </trans-unit>
        <trans-unit id="5c06094b5494afcc6bc0546930a2d751ec1db7b7" translate="yes" xml:space="preserve">
          <source>The lock-byte page arose from the need to support Win95 which was the predominant operating system when this file format was designed and which only supported mandatory file locking. All modern operating systems that we know of support advisory file locking, and so the lock-byte page is not really needed any more, but is retained for backwards compatibility.</source>
          <target state="translated">锁定字节页的产生是由于需要支持Win95,而Win95在设计这种文件格式时是最主要的操作系统,它只支持强制文件锁定。我们所知道的所有现代操作系统都支持咨询文件锁定,因此不再需要锁定字节页,而是为了向后兼容而保留。</target>
        </trans-unit>
        <trans-unit id="4bd512e93ea74564dff8bf82d8627bae1ed3c48e" translate="yes" xml:space="preserve">
          <source>The lock-byte page is set aside for use by the operating-system specific &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementation in implementing the database file locking primitives. SQLite does not use the lock-byte page. The SQLite core will never read or write the lock-byte page, though operating-system specific &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations may choose to read or write bytes on the lock-byte page according to the needs and proclivities of the underlying system. The unix and win32 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations that come built into SQLite do not write to the lock-byte page, but third-party VFS implementations for other operating systems might.</source>
          <target state="translated">保留了锁定字节页面，以供操作系统特定的&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;实现在实现数据库文件锁定原语时使用。 SQLite不使用锁定字节页面。尽管特定于操作系统的&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;实现可能会根据底层系统的需要和倾向选择在锁定字节页上读取或写入字节，但SQLite核心永远不会读取或写入锁定字节页。SQLite内置的unix和win32 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;实现不会写入锁定字节页，但是其他操作系统的第三方VFS实现可能会写入。</target>
        </trans-unit>
        <trans-unit id="df185932a5473981e68a610e19ea95a4f593a072" translate="yes" xml:space="preserve">
          <source>The lock-byte page is the single page of the database file that contains the bytes at offsets between 1073741824 and 1073742335, inclusive. A database file that is less than or equal to 1073741824 bytes in size contains no lock-byte page. A database file larger than 1073741824 contains exactly one lock-byte page.</source>
          <target state="translated">锁字节页是指数据库文件中包含1073741824和1073742335(含)之间偏移量的字节的单页。小于或等于1073741824字节大小的数据库文件不包含锁字节页。大于1073741824字节的数据库文件正好包含一个锁字节页。</target>
        </trans-unit>
        <trans-unit id="dda6a9ed2d568f9a7c6dc08407b442fb82119304" translate="yes" xml:space="preserve">
          <source>The logic is summarized like this:</source>
          <target state="translated">逻辑是这样总结的。</target>
        </trans-unit>
        <trans-unit id="355578bfd3a4498b2a633a6f3c4ff7c7b09de69f" translate="yes" xml:space="preserve">
          <source>The logical database size is now stored in the database header so that bytes can be appended to the end of the database file without corrupting it and so that SQLite will work correctly on systems that lack support for ftruncate().</source>
          <target state="translated">现在,逻辑数据库的大小存储在数据库头中,这样就可以在不破坏数据库文件的情况下将字节追加到文件末尾,这样SQLite就可以在缺乏ftruncate()支持的系统上正确工作。</target>
        </trans-unit>
        <trans-unit id="e93186cc2b2b96f693bcff5f9715523649b95afa" translate="yes" xml:space="preserve">
          <source>The lookaside configuration can only be changed while there are no outstanding lookaside allocations for the database connection. Hence, the configuration should be set immediately after creating the database connection using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; (or equivalent) and before evaluating any SQL statements on the connection.</source>
          <target state="translated">仅当数据库连接没有未完成的后备分配时，才能更改后备配置。因此，应在使用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;（或等效方法）创建数据库连接之后并在评估连接上的任何SQL语句之前立即设置配置。</target>
        </trans-unit>
        <trans-unit id="98de1d7e1c308aef9eeb240a9c0c48340d7aa4c3" translate="yes" xml:space="preserve">
          <source>The lookaside memory allocator is really intended as performance optimization, not as a method for assuring breakdown-free memory allocation, so it is not unreasonable to completely disable the lookaside memory allocator for safety-critical operations.</source>
          <target state="translated">lookaside内存分配器的真正目的是为了优化性能,而不是保证无故障内存分配的方法,所以对于安全关键的操作,完全禁用lookaside内存分配器并非不合理。</target>
        </trans-unit>
        <trans-unit id="02f0ada4fc69e2b3f3d2c6c843b91333faf8b563" translate="yes" xml:space="preserve">
          <source>The lookaside pool can be changed for an individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; &quot;db&quot; using this call:</source>
          <target state="translated">可以使用以下调用为单个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt; &amp;ldquo; db&amp;rdquo; 更改后备池：</target>
        </trans-unit>
        <trans-unit id="31d19ac91c3d68e4ec2f5534877ee0ca68a0efec" translate="yes" xml:space="preserve">
          <source>The loop begins with the &lt;a href=&quot;opcode#MemLoad&quot;&gt;MemLoad&lt;/a&gt; instruction at 11 which pushes a copy of the index key back onto the stack. The instruction &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; at 12 compares the key to the key in the current index record pointed to by cursor P1. If the index key at the current cursor location is greater than the index we are looking for, then jump out of the loop.</source>
          <target state="translated">循环从11处的&lt;a href=&quot;opcode#MemLoad&quot;&gt;MemLoad&lt;/a&gt;指令开始，该指令将索引键的副本推回堆栈中。位于12 的指令&lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt;将键与光标P1指向的当前索引记录中的键进行比较。如果当前光标位置的索引键大于我们要查找的索引，则跳出循环。</target>
        </trans-unit>
        <trans-unit id="9b4e40524d32f647817434932fe77ea61e285d86" translate="yes" xml:space="preserve">
          <source>The lower(X) function returns a copy of string X with all ASCII characters converted to lower case. The default built-in lower() function works for ASCII characters only. To do case conversions on non-ASCII characters, load the ICU extension.</source>
          <target state="translated">lower(X)函数返回字符串 X 的副本,并将所有 ASCII 字符转换为小写。默认内置的 lower()函数只对 ASCII 字符起作用,如果要对非 ASCII 字符进行大小写转换,请加载 ICU 扩展。要对非 ASCII 字符进行大小写转换,请加载 ICU 扩展。</target>
        </trans-unit>
        <trans-unit id="84e26bc0d335ef0f3f91dcbee9450cd939575e9d" translate="yes" xml:space="preserve">
          <source>The ltrim(X,Y) function returns a string formed by removing any and all characters that appear in Y from the left side of X. If the Y argument is omitted, ltrim(X) removes spaces from the left side of X.</source>
          <target state="translated">ltrim(X,Y)函数返回一个从X的左侧删除Y中出现的所有字符形成的字符串,如果省略Y参数,ltrim(X)将删除X左侧的空格。</target>
        </trans-unit>
        <trans-unit id="fdcc55ab3a12db83d0fd351a3149fb5d3844b7fd" translate="yes" xml:space="preserve">
          <source>The macros in this section do not require values. The following compilation switches all have the same effect:</source>
          <target state="translated">本节中的宏不需要值。下面的编译开关都有同样的效果。</target>
        </trans-unit>
        <trans-unit id="9225c9e6b4935393e2d3171b186997ddaa13f218" translate="yes" xml:space="preserve">
          <source>The main database file consists of one or more pages. The size of a page is a power of two between 512 and 65536 inclusive. All pages within the same database are the same size. The page size for a database file is determined by the 2-byte integer located at an offset of 16 bytes from the beginning of the database file.</source>
          <target state="translated">主数据库文件由一个或多个页面组成。一个页面的大小是512到65536(含)之间的二倍。同一数据库中的所有页面大小相同。数据库文件的页面大小由位于数据库文件开头16字节偏移处的2字节整数决定。</target>
        </trans-unit>
        <trans-unit id="7d6f37716756d458f806be1f0cab62c9c7d22175" translate="yes" xml:space="preserve">
          <source>The main database file with an arbitrary name &quot;X&quot;.</source>
          <target state="translated">主数据库文件的名称为任意 &quot;X&quot;。</target>
        </trans-unit>
        <trans-unit id="f6b3e874976f8a865414a00bc3a0b52995dae0f9" translate="yes" xml:space="preserve">
          <source>The main expression bubble diagram above shows a single syntax for all function invocations. But this is merely to simplify the expression bubble diagram. In reality, each type of function has a slightly different syntax, shown below. The function invocation syntax shown in the main expression bubble diagram is the union of the three syntaxes shown here:</source>
          <target state="translated">上面的主表达式气泡图显示了所有函数调用的单一语法。但这只是为了简化表达式气泡图。实际上,每种类型的函数都有稍微不同的语法,如下图所示。主表达式气泡图中所示的函数调用语法是这里所示的三种语法的结合。</target>
        </trans-unit>
        <trans-unit id="408e5f03d044dab233873eb64f906cb6ccb49b90" translate="yes" xml:space="preserve">
          <source>The main machine in Dallas &lt;a href=&quot;https://www.sqlite.org/&quot;&gt;https://www.sqlite.org/&lt;/a&gt; is the primary server and the one that most people use. The other two are considered backups.</source>
          <target state="translated">达拉斯&lt;a href=&quot;https://www.sqlite.org/&quot;&gt;https://www.sqlite.org/&lt;/a&gt;中的主机是主要服务器，也是大多数人使用的服务器。其他两个被视为备份。</target>
        </trans-unit>
        <trans-unit id="1d698f91852ce738e8b0efe94402ad56dc5b35ee" translate="yes" xml:space="preserve">
          <source>The main result from &lt;b&gt;sqlite_get_table&lt;/b&gt; is an array of pointers to strings. There is one element in this array for each column of each row in the result. NULL results are represented by a NULL pointer. In addition to the regular data, there is an added row at the beginning of the array that contains the name of each column of the result.</source>
          <target state="translated">&lt;b&gt;sqlite_get_table&lt;/b&gt;的主要结果是一个指向字符串的指针数组。结果中每一行的每一列在此数组中都有一个元素。NULL结果由NULL指针表示。除常规数据外，数组开头还有一个添加的行，其中包含结果每一列的名称。</target>
        </trans-unit>
        <trans-unit id="2fb1295c928ccfed10f4bea85ec6d057bdb858da" translate="yes" xml:space="preserve">
          <source>The main thing that the SQLite core is trying to communicate to the virtual table is the constraints that are available to limit the number of rows that need to be searched. The aConstraint[] array contains one entry for each constraint. There will be exactly nConstraint entries in that array.</source>
          <target state="translated">SQLite核心要传达给虚拟表的主要内容是可用来限制需要搜索的行数的约束。aConstraint[]数组包含每个约束的一个条目。该数组中正好会有n个Constraint条目。</target>
        </trans-unit>
        <trans-unit id="c00fa1abbc4e41f8e98c7516bdb7add3970ff677" translate="yes" xml:space="preserve">
          <source>The makefiles and scripts used to generate the documentation gather text from baseline documents in the documentation source repository. Additional text is extracted from comments in the SQLite source code. Requirements coverage information is extract from special comments in the &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt; which is part of the source repository, and from comments in the &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; test suite which is a separate private repository.</source>
          <target state="translated">用于生成文档的makefile和脚本从文档源存储库中的基准文档中收集文本。其他文本是从SQLite源代码中的注释中提取的。需求覆盖率信息是从&lt;a href=&quot;testing#tcl&quot;&gt;TCL测试套件（&lt;/a&gt;它是源存储库的一部分）中的特殊注释以及&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;测试套件（一个单独的私有存储库）中的注释中提取的。</target>
        </trans-unit>
        <trans-unit id="42a78601e6da24d033fc5c1c1ee7512e6c89f88c" translate="yes" xml:space="preserve">
          <source>The makefiles for SQLite have an &quot;sqlite3.c&quot; target for building the file we call &quot;the amalgamation&quot;. The amalgamation is a single C code file, named &quot;sqlite3.c&quot;, that contains all C code for the core SQLite library and the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;, &lt;a href=&quot;dbstat&quot;&gt;DBSTAT&lt;/a&gt;, &lt;a href=&quot;json1&quot;&gt;JSON1&lt;/a&gt;, and &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; extensions. This file contains about 184K lines of code (113K if you omit blank lines and comments) and is over 6.4 megabytes in size. Though the various extensions are included in the &quot;sqlite3.c&quot; amalgamation file, they are disabled using #ifdef statements. Activate the extensions using &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; like:</source>
          <target state="translated">SQLite的makefile具有一个&amp;ldquo; sqlite3.c&amp;rdquo;目标，用于构建我们称为&amp;ldquo;合并&amp;rdquo;的文件。合并是一个单独的C代码文件，名为&amp;ldquo; sqlite3.c&amp;rdquo;，其中包含核心SQLite库以及&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;，&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;，&lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;，&lt;a href=&quot;dbstat&quot;&gt;DBSTAT&lt;/a&gt;，&lt;a href=&quot;json1&quot;&gt;JSON1&lt;/a&gt;和&lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt;扩展的所有C代码。该文件包含大约18.4万行代码（如果省略空行和注释，则为113K），大小超过6.4兆字节。尽管&amp;ldquo; sqlite3.c&amp;rdquo;合并文件中包含各种扩展名，但是使用#ifdef语句将其禁用。使用如下&lt;a href=&quot;compile&quot;&gt;编译时选项&lt;/a&gt;激活扩展：</target>
        </trans-unit>
        <trans-unit id="0980756624132b6830b479bc71ea60b90272891a" translate="yes" xml:space="preserve">
          <source>The manner in which SQLite uses temporary files is not considered part of the contract that SQLite makes with applications. The information in this document is a correct description of how SQLite operates at the time that this document was written or last updated. But there is no guarantee that future versions of SQLite will use temporary files in the same way. New kinds of temporary files might be employed and some of the current temporary file uses might be discontinued in future releases of SQLite.</source>
          <target state="translated">SQLite使用临时文件的方式不被认为是SQLite与应用程序签订的合同的一部分。本文档中的信息是本文档编写或最后一次更新时对SQLite操作方式的正确描述。但不能保证未来版本的SQLite会以同样的方式使用临时文件。在未来的SQLite版本中,可能会采用新的临时文件种类,而且当前的一些临时文件的使用可能会被停止。</target>
        </trans-unit>
        <trans-unit id="3c2b798d423398f0b8335bc4cb33aea4b3800944" translate="yes" xml:space="preserve">
          <source>The mapping from character to affinity is given by the SQLITE_AFF_ macros defined in sqliteInt.h.</source>
          <target state="translated">从字符到亲和力的映射由 sqliteInt.h 中定义的 SQLITE_AFF_宏给出。</target>
        </trans-unit>
        <trans-unit id="e5801820a892b25589a4f5acb0cdb08d7136d42b" translate="yes" xml:space="preserve">
          <source>The master journal file is only created for &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; operations that involve multiple database files where at least two of the databases meet all of the following requirements:</source>
          <target state="translated">仅为涉及多个数据库文件的&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;操作创建主日志文件，其中至少两个数据库满足以下所有要求：</target>
        </trans-unit>
        <trans-unit id="31da1199925e2ef2121e09ef393e19f883001204" translate="yes" xml:space="preserve">
          <source>The master journal file is used as part of the atomic commit process when a single transaction makes changes to multiple databases that have been added to a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. The master journal file is always located in the same directory as the main database file (the main database file is the database that is identified in the original &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that created the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;) with a randomized suffix. The master journal file contains the names of all of the various attached auxiliary databases that were changed during the transaction. The multi-database transaction commits when the master journal file is deleted. See the documentation titled &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit In SQLite&lt;/a&gt; for additional detail.</source>
          <target state="translated">当单个事务对使用&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;语句添加到单个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;中的多个数据库进行更改时，主日志文件将用作原子提交过程的一部分。主日志文件始终与主数据库文件位于同一目录中（主数据库文件是在创建&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;的原始&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;或&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;调用中标识的数据库）），并带有随机后缀。主日志文件包含在事务期间更改的所有各种附加辅助数据库的名称。当删除主日记文件时，将执行多数据库事务。有关更多详细信息，请参见标题为&amp;ldquo; &lt;a href=&quot;atomiccommit&quot;&gt;SQLite&lt;/a&gt;中的原子提交&amp;rdquo;的文档。</target>
        </trans-unit>
        <trans-unit id="772c6b302e1774e25495c91e9341c8308af64569" translate="yes" xml:space="preserve">
          <source>The matchinfo 'b' flag provides similar information to the &lt;a href=&quot;fts3#matchinfo-y&quot; id=&quot;matchinfo-b&quot;&gt;matchinfo 'y' flag&lt;/a&gt;, but in a more compact form. Instead of the precise number of hits, 'b' provides a single boolean flag for each phrase/column combination. If the phrase is present in the column at least once (i.e. if the corresponding integer output of 'y' would be non-zero), the corresponding flag is set. Otherwise cleared.</source>
          <target state="translated">所述matchinfo&amp;ldquo;b&amp;rdquo;标记提供类似的信息给&lt;a href=&quot;fts3#matchinfo-y&quot; id=&quot;matchinfo-b&quot;&gt;matchinfo&amp;ldquo;y&amp;rdquo;的标志&lt;/a&gt;，但在一个更紧凑的形式。&amp;ldquo; b&amp;rdquo;代替了准确的匹配数，而是为每个短语/列组合提供了一个布尔标志。如果该短语在该列中至少存在一次（即，如果&amp;ldquo; y&amp;rdquo;的相应整数输出为非零），则设置相应的标志。否则清除。</target>
        </trans-unit>
        <trans-unit id="0e92769ac2bedb9028e89c1796d219b3c41ebfd0" translate="yes" xml:space="preserve">
          <source>The matchinfo function is called with either one or two arguments. As for all auxiliary functions, the first argument must be the special &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt;. The second argument, if it is specified, must be a text value comprised only of the characters 'p', 'c', 'n', 'a', 'l', 's', 'x', 'y' and 'b'. If no second argument is explicitly supplied, it defaults to &quot;pcx&quot;. The second argument is referred to as the &quot;format string&quot; below.</source>
          <target state="translated">使用一个或两个参数调用matchinfo函数。对于所有辅助功能，第一个参数必须是特殊的&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS隐藏列&lt;/a&gt;。第二个参数（如果已指定）必须是仅由字符&amp;ldquo; p&amp;rdquo;，&amp;ldquo; c&amp;rdquo;，&amp;ldquo; n&amp;rdquo;，&amp;ldquo; a&amp;rdquo;，&amp;ldquo; l&amp;rdquo;，&amp;ldquo; s&amp;rdquo;，&amp;ldquo; x&amp;rdquo;，&amp;ldquo; y&amp;rdquo;组成的文本值和&amp;ldquo; b&amp;rdquo;。如果未显式提供第二个参数，则默认为&amp;ldquo; pcx&amp;rdquo;。第二个参数在下面称为&amp;ldquo;格式字符串&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d7687da8f246deec886a3154fb495c0792554c7d" translate="yes" xml:space="preserve">
          <source>The matchinfo function is much faster than either the snippet or offsets functions. This is because the implementation of both snippet and offsets is required to retrieve the documents being analyzed from disk, whereas all data required by matchinfo is available as part of the same portions of the full-text index that are required to implement the full-text query itself. This means that of the following two queries, the first may be an order of magnitude faster than the second:</source>
          <target state="translated">matchinfo 函数比 snippet 或 offsets 函数快得多。这是因为实现snippet和offsets都需要从磁盘上检索被分析的文档,而matchinfo所需要的所有数据都可以作为全文索引的一部分,这些部分是实现全文查询本身所需要的。这意味着,在以下两个查询中,第一个查询可能比第二个查询快一个数量级。</target>
        </trans-unit>
        <trans-unit id="c65df31b33c2a6ca0926acfdea9fd52aa875638d" translate="yes" xml:space="preserve">
          <source>The matchinfo function provides all the information required to calculate probabilistic &quot;bag-of-words&quot; relevancy scores such as &lt;a href=&quot;http://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;Okapi BM25/BM25F&lt;/a&gt; that may be used to order results in a full-text search application. Appendix A of this document, &quot;&lt;a href=&quot;fts3#appendix_a&quot;&gt;search application tips&lt;/a&gt;&quot;, contains an example of using the matchinfo() function efficiently.</source>
          <target state="translated">matchinfo函数提供了计算概率&amp;ldquo;单词袋&amp;rdquo;相关性分数所需的所有信息，例如&lt;a href=&quot;http://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;Okapi BM25 / BM25F&lt;/a&gt;，可用于对全文搜索应用程序中的结果进行排序。本文档的附录A&amp;ldquo; &lt;a href=&quot;fts3#appendix_a&quot;&gt;搜索应用程序技巧&lt;/a&gt; &amp;rdquo;包含一个有效使用matchinfo（）函数的示例。</target>
        </trans-unit>
        <trans-unit id="e90549847387fb18f595713064d87ed6f095e05c" translate="yes" xml:space="preserve">
          <source>The matchinfo function returns a blob value. If it is used within a query that does not use the full-text index (a &quot;query by rowid&quot; or &quot;linear scan&quot;), then the blob is zero bytes in size. Otherwise, the blob consists of zero or more 32-bit unsigned integers in machine byte-order. The exact number of integers in the returned array depends on both the query and the value of the second argument (if any) passed to the matchinfo function.</source>
          <target state="translated">matchinfo函数返回一个blob值。如果它是在一个不使用全文索引的查询中使用的(&quot;按rowid查询 &quot;或 &quot;线性扫描&quot;),那么blob的大小为零字节。否则,blob由0个或更多的32位无符号整数按机器字节顺序组成。返回数组中整数的确切数量取决于查询和传递给matchinfo函数的第二个参数的值(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="5fd973e0c684054ad3dbbf4a32a2b97ce84282bb" translate="yes" xml:space="preserve">
          <source>The matchinfo option may only be set to the value &quot;fts3&quot;. Attempting to set matchinfo to anything other than &quot;fts3&quot; is an error. If this option is specified, then some of the extra information stored by FTS4 is omitted. This reduces the amount of disk space consumed by an FTS4 table until it is almost the same as the amount that would be used by the equivalent FTS3 table, but also means that the data accessed by passing the 'l' flag to the &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; function is not available.</source>
          <target state="translated">matchinfo选项只能设置为值&amp;ldquo; fts3&amp;rdquo;。尝试将matchinfo设置为除&amp;ldquo; fts3&amp;rdquo;以外的任何其他内容是错误的。如果指定了此选项，则将省略FTS4存储的一些额外信息。这将减少FTS4表占用的磁盘空间量，直到与等效的FTS3表所使用的磁盘空间几乎相同为止，而且还意味着通过将'l'标志传递给&lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo（）&lt;/a&gt;来访问数据。功能不可用。</target>
        </trans-unit>
        <trans-unit id="30566a971375718efb83d0535cdd7975a1033a22" translate="yes" xml:space="preserve">
          <source>The matrix below shows the time needed to read BLOBs stored in separate files divided by the time needed to read BLOBs stored entirely in the database. Hence, for numbers larger than 1.0, it is faster to store the BLOBs directly in the database. For numbers smaller than 1.0, it is faster to store the BLOBs in separate files.</source>
          <target state="translated">下面的矩阵显示了读取存储在单独文件中的BLOB所需的时间除以读取完全存储在数据库中的BLOB所需的时间。因此,对于大于1.0的数字,直接将BLOBs存储在数据库中更快。对于小于1.0的数字,将BLOB存储在单独的文件中更快。</target>
        </trans-unit>
        <trans-unit id="4c2fbc6111561deb5f89baa2a61ac965889a611a" translate="yes" xml:space="preserve">
          <source>The max() aggregate function returns the maximum value of all values in the group. The maximum value is the value that would be returned last in an ORDER BY on the same column. Aggregate max() returns NULL if and only if there are no non-NULL values in the group.</source>
          <target state="translated">max()集合函数返回该组中所有值的最大值,最大值是同一列的ORDER BY中最后返回的值。最大值是在同一列的ORDER BY中最后返回的值。如果且仅当组中没有非NULL值时,聚合函数max()返回NULL。</target>
        </trans-unit>
        <trans-unit id="259079b25b4ee53dd3af62dccf64b88cf7401fe7" translate="yes" xml:space="preserve">
          <source>The maximum allowed value for the 'automerge' parameter is 16. The default value is 4. Setting the 'automerge' parameter to 0 disables the automatic incremental merging of b-trees altogether.</source>
          <target state="translated">automerge &quot;参数的最大允许值是16,默认值是4。默认值是4,将'automerge'参数设置为0,则完全禁止b树的自动增量合并。</target>
        </trans-unit>
        <trans-unit id="99bed95a8c8918c9ad675486624a0ec50cca0b55" translate="yes" xml:space="preserve">
          <source>The maximum amount of general-purpose memory needed by the application is determined by such factors as how many simultaneous open &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects the application uses, and on the complexity of the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;. For any given application, these factors are normally fixed and can be determined experimentally using &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;. A typical application might only use about 40KB of general-purpose memory. This gives a value of &lt;b&gt;N&lt;/b&gt; of around 100KB.</source>
          <target state="translated">应用程序所需的最大通用内存量由以下因素确定，这些因素包括应用程序使用多少个同时打开的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;和&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;对象，以及&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;的复杂性。对于任何给定的应用程序，这些因素通常是固定的，可以使用&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;通过实验确定。一个典型的应用程序可能只使用大约40KB的通用内存。&lt;b&gt;N&lt;/b&gt;的值约为100KB。</target>
        </trans-unit>
        <trans-unit id="a9b767b87a835989935611d9f91af0a49ef22427" translate="yes" xml:space="preserve">
          <source>The maximum and minimum embedded payload fractions and the leaf payload fraction values must be 64, 32, and 32. These values were originally intended to be tunable parameters that could be used to modify the storage format of the b-tree algorithm. However, that functionality is not supported and there are no current plans to add support in the future. Hence, these three bytes are fixed at the values specified.</source>
          <target state="translated">最大和最小的嵌入有效载荷分数和叶有效载荷分数值必须是64、32和32。这些值最初的目的是作为可调整的参数,可用于修改b树算法的存储格式。但是,该功能不被支持,目前也没有计划在未来增加支持。因此,这三个字节被固定在指定的值上。</target>
        </trans-unit>
        <trans-unit id="3b75dd01c336dd48a91229fb4fe465cfca0656d8" translate="yes" xml:space="preserve">
          <source>The maximum depth of an expression tree can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt;,size) interface if the SQLITE_MAX_EXPR_DEPTH is initially positive. In other words, the maximum expression depth can be lowered at run-time if there is already a compile-time limit on the expression depth. If SQLITE_MAX_EXPR_DEPTH is set to 0 at compile time (if the depth of expressions is unlimited) then the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt;,size) is a no-op.</source>
          <target state="translated">如果SQLITE_MAX_EXPR_DEPTH最初为正，则可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt;，size）接口降低表达式树的最大深度。换句话说，如果表达式深度已经存在编译时限制，则可以在运行时降低最大表达式深度。如果在编译时将SQLITE_MAX_EXPR_DEPTH设置为0（如果表达式的深度不受限制），则&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH的&lt;/a&gt;大小）是无操作的。</target>
        </trans-unit>
        <trans-unit id="7601f568790af4a666771d9637268d8679fb90bb" translate="yes" xml:space="preserve">
          <source>The maximum depth of recursion for triggers.</source>
          <target state="translated">触发器的最大递归深度。</target>
        </trans-unit>
        <trans-unit id="f7ca88d6870cff0eca30922b0b5339bd065f10ca" translate="yes" xml:space="preserve">
          <source>The maximum depth of the parse tree on any expression.</source>
          <target state="translated">任何表达式上解析树的最大深度。</target>
        </trans-unit>
        <trans-unit id="2e6bbb757edd69dcf67031bc6d4f260f516ed8d0" translate="yes" xml:space="preserve">
          <source>The maximum host parameter number can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;,size) interface.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;，size）接口降低最大主机参数数量。</target>
        </trans-unit>
        <trans-unit id="b3e774d908522cebf9bd7f7f3469b3fb31276410" translate="yes" xml:space="preserve">
          <source>The maximum index number of any &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; in an SQL statement.</source>
          <target state="translated">SQL语句中任何&lt;a href=&quot;../lang_expr#varparam&quot;&gt;参数&lt;/a&gt;的最大索引号。</target>
        </trans-unit>
        <trans-unit id="32a6d72e37d636464c2192cbf409c3425887feb6" translate="yes" xml:space="preserve">
          <source>The maximum index number of any &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; in an SQL statement.</source>
          <target state="translated">SQL语句中任何&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;的最大索引号。</target>
        </trans-unit>
        <trans-unit id="ab2a11cb65d0770d55a8b43b094028bd3c341a46" translate="yes" xml:space="preserve">
          <source>The maximum length of a LIKE or GLOB pattern can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlikepatternlength&quot;&gt;SQLITE_LIMIT_LIKE_PATTERN_LENGTH&lt;/a&gt;,size) interface.</source>
          <target state="translated">可以使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlikepatternlength&quot;&gt;SQLITE_LIMIT_LIKE_PATTERN_LENGTH&lt;/a&gt;，size）接口在运行时降低LIKE或GLOB模式的最大长度。</target>
        </trans-unit>
        <trans-unit id="d765036961e5dc86e0ba5117af47c297fab27c55" translate="yes" xml:space="preserve">
          <source>The maximum length of an SQL statement can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitsqllength&quot;&gt;SQLITE_LIMIT_SQL_LENGTH&lt;/a&gt;,size) interface.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitsqllength&quot;&gt;SQLITE_LIMIT_SQL_LENGTH&lt;/a&gt;，size）接口降低SQL语句的最大长度。</target>
        </trans-unit>
        <trans-unit id="d303fbf5ebde80b928a0a149ac1d360f8b2d9beb" translate="yes" xml:space="preserve">
          <source>The maximum length of an SQL statement, in bytes.</source>
          <target state="translated">一个SQL语句的最大长度,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="c8feb93491c3d188a9985624d09a15796f2e0e57" translate="yes" xml:space="preserve">
          <source>The maximum length of the pattern argument to the &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operators.</source>
          <target state="translated">&lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt;或&lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;运算符的pattern参数的最大长度。</target>
        </trans-unit>
        <trans-unit id="1ee02be23a19dec285dd5109a44c64362161f0e7" translate="yes" xml:space="preserve">
          <source>The maximum length of the pattern argument to the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operators.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;或&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;运算符的pattern参数的最大长度。</target>
        </trans-unit>
        <trans-unit id="b23da6f4323ba72ffe46e74c0191923768cdb864" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;a href=&quot;../lang_attach&quot;&gt;attached databases&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../lang_attach&quot;&gt;附加数据库&lt;/a&gt;的最大数量。</target>
        </trans-unit>
        <trans-unit id="b544569d59df80608bd6a41e19a745bdff4577b6" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;a href=&quot;lang_attach&quot;&gt;attached databases&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;附加数据库&lt;/a&gt;的最大数量。</target>
        </trans-unit>
        <trans-unit id="471b9bc71d47534b60a1c278c46d4cee7c9664ba" translate="yes" xml:space="preserve">
          <source>The maximum number of arguments in a function can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;,size) interface.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;，size）接口降低函数中参数的最大数量。</target>
        </trans-unit>
        <trans-unit id="00eff3b06f801e572f28af21289c2619b46c2f08" translate="yes" xml:space="preserve">
          <source>The maximum number of arguments on a function.</source>
          <target state="translated">一个函数的最大参数数。</target>
        </trans-unit>
        <trans-unit id="b6c416e24701b8851e7053c0bb7cd7dd6b331315" translate="yes" xml:space="preserve">
          <source>The maximum number of attached databases can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt;,size) interface.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt;，size）接口降低附加数据库的最大数量。</target>
        </trans-unit>
        <trans-unit id="0b6c3c6cf8605d1353c6caeac57deb9da3ed0c6e" translate="yes" xml:space="preserve">
          <source>The maximum number of auxiliary worker threads that a single &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; may start.</source>
          <target state="translated">一个&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;可以启动的辅助工作线程的最大数量。</target>
        </trans-unit>
        <trans-unit id="66f8c3a081d879e272abf19945402c6cac2a7ecc" translate="yes" xml:space="preserve">
          <source>The maximum number of auxiliary worker threads that a single &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; may start.</source>
          <target state="translated">一个&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;可以启动的辅助工作线程的最大数量。</target>
        </trans-unit>
        <trans-unit id="bbb454e2483711c9ac94945a0c80d3f47e450874" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes in a string or BLOB in SQLite is defined by the preprocessor macro SQLITE_MAX_LENGTH. The default value of this macro is 1 billion (1 thousand million or 1,000,000,000). You can raise or lower this value at compile-time using a command-line option like this:</source>
          <target state="translated">在SQLite中,字符串或BLOB的最大字节数由预处理器宏SQLITE_MAX_LENGTH定义。这个宏的默认值是10亿(10亿或1,000,000,000)。你可以在编译时使用命令行选项提高或降低这个值,比如这样。</target>
        </trans-unit>
        <trans-unit id="da1ee68dd77283238b55af162c380f02592134ee" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes in the text of an SQL statement is limited to SQLITE_MAX_SQL_LENGTH which defaults to 1000000. You can redefine this limit to be as large as the smaller of SQLITE_MAX_LENGTH and 1073741824.</source>
          <target state="translated">SQL语句文本中的最大字节数限制为SQLITE_MAX_SQL_LENGTH,默认为1000000。你可以重新定义这个限制,使其大到SQLITE_MAX_LENGTH和1073741824中的较小值。</target>
        </trans-unit>
        <trans-unit id="6345ddabb514350f3e36f681af647ea84308cf28" translate="yes" xml:space="preserve">
          <source>The maximum number of columns can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt;,size) interface.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt;，size）接口降低最大列数。</target>
        </trans-unit>
        <trans-unit id="1c620a336050426a95c894972afda47b3aee66a2" translate="yes" xml:space="preserve">
          <source>The maximum number of columns in a table definition or in the result set of a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; or the maximum number of columns in an index or in an ORDER BY or GROUP BY clause.</source>
          <target state="translated">表定义或&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;结果集中的最大列数，或索引或ORDER BY或GROUP BY子句中的最大列数。</target>
        </trans-unit>
        <trans-unit id="355eec7f9bb7446523a2374f005ae8119aa229d8" translate="yes" xml:space="preserve">
          <source>The maximum number of columns in a table definition or in the result set of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; or the maximum number of columns in an index or in an ORDER BY or GROUP BY clause.</source>
          <target state="translated">表定义或&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;结果集中的最大列数，或索引或ORDER BY或GROUP BY子句中的最大列数。</target>
        </trans-unit>
        <trans-unit id="8374b8e68f54521ffc214c5ed7e8c2d7fd95f1b7" translate="yes" xml:space="preserve">
          <source>The maximum number of compound SELECT terms can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT&lt;/a&gt;,size) interface.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT&lt;/a&gt;，size）接口降低复合SELECT术语的最大数量。</target>
        </trans-unit>
        <trans-unit id="63cbc7c9607d5bbb2a5e8441eb06e668604fc05c" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions in a virtual machine program used to implement an SQL statement. If &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or the equivalent tries to allocate space for more than this many opcodes in a single prepared statement, an SQLITE_NOMEM error is returned.</source>
          <target state="translated">虚拟机程序中用于实现SQL语句的最大指令数。如果&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或等效方法试图在单个准备好的语句中为多个操作码分配空间，则将返回SQLITE_NOMEM错误。</target>
        </trans-unit>
        <trans-unit id="3914cdf98f328c74ff19ff41972588f848a7b49e" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions in a virtual machine program used to implement an SQL statement. If &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or the equivalent tries to allocate space for more than this many opcodes in a single prepared statement, an SQLITE_NOMEM error is returned.</source>
          <target state="translated">虚拟机程序中用于实现SQL语句的最大指令数。如果&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或等效方法试图在单个准备好的语句中为多个操作码分配空间，则将返回SQLITE_NOMEM错误。</target>
        </trans-unit>
        <trans-unit id="7c57be7916f18cb9fd931235954ed49b10f67a38" translate="yes" xml:space="preserve">
          <source>The maximum number of terms in a compound SELECT statement.</source>
          <target state="translated">复合SELECT语句中的最大项数。</target>
        </trans-unit>
        <trans-unit id="6409e263b558e4fc8032ff274ccb7661be29c559" translate="yes" xml:space="preserve">
          <source>The maximum number of tokens in the returned text. This must be greater than zero and equal to or less than 64.</source>
          <target state="translated">返回文本中的最大标记数。必须大于零,等于或小于64。</target>
        </trans-unit>
        <trans-unit id="970d6e67d87a8bc5f32df0c8fe5b2ab66eff4335" translate="yes" xml:space="preserve">
          <source>The maximum parameter number is set at compile-time by the &lt;a href=&quot;limits#max_variable_number&quot;&gt;SQLITE_MAX_VARIABLE_NUMBER&lt;/a&gt; macro. An individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; D can reduce its maximum parameter number below the compile-time maximum using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(D, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;,...) interface.</source>
          <target state="translated">最大参数数是在编译时由&lt;a href=&quot;limits#max_variable_number&quot;&gt;SQLITE_MAX_VARIABLE_NUMBER&lt;/a&gt;宏设置的。单个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt; D可以使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（D，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;，...）接口将其最大参数数减少到编译时最大值以下。</target>
        </trans-unit>
        <trans-unit id="eeb9b32b1bfb4a0ced4bb9bc2aaa054c3abdfc92" translate="yes" xml:space="preserve">
          <source>The maximum size of any string or BLOB or table row, in bytes.</source>
          <target state="translated">任何字符串或BLOB或表格行的最大尺寸,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="c7f288d6ab417ac4a35975a5356fac79645319c2" translate="yes" xml:space="preserve">
          <source>The maximum string or BLOB length can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;,size) interface.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;，size）接口降低最大字符串或BLOB长度。</target>
        </trans-unit>
        <trans-unit id="770a09ba0039805fb6c3142551082e18eaaafe07" translate="yes" xml:space="preserve">
          <source>The meaning of P5 depends on whether or not the SQLITE_ENABLE_NULL_TRIM compile-time option is enabled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cc8ccfaed1025b2039c6bdfd6b0a5399eacb5ca" translate="yes" xml:space="preserve">
          <source>The meanings for all $nResCode result code values are shown below, in numeric order.</source>
          <target state="translated">所有$nResCode结果代码值的含义如下所示,按数字顺序排列。</target>
        </trans-unit>
        <trans-unit id="4cad3638dbf4cc08ff40caa02c71d9ae2dc2cc12" translate="yes" xml:space="preserve">
          <source>The meanings for all 92 result code values are shown below, in numeric order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acfaa39aa41d2de54931d409a9de16ab158bc08a" translate="yes" xml:space="preserve">
          <source>The meanings of these various return values are as follows:</source>
          <target state="translated">这些不同的返回值的含义如下:</target>
        </trans-unit>
        <trans-unit id="3594f845ca8155469ebf0d3a1db0993f4bb9cbd1" translate="yes" xml:space="preserve">
          <source>The measurements in this article were made during the week of 2017-06-05 using a version of SQLite in between 3.19.2 and 3.20.0. You may expect future versions of SQLite to perform even better.</source>
          <target state="translated">本文中的测量是在2017-06-05这一周使用3.19.2和3.20.0之间的SQLite版本进行的。您可能会期待未来版本的SQLite表现更好。</target>
        </trans-unit>
        <trans-unit id="f2809fd545c907ef31fca4768c017467b4928225" translate="yes" xml:space="preserve">
          <source>The memory allocation limits can also be adjusted using &lt;a href=&quot;pragma#pragma_soft_heap_limit&quot;&gt;PRAGMA soft_heap_limit&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_hard_heap_limit&quot;&gt;PRAGMA hard_heap_limit&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e788358e2ac74022367111d33deb5ddc9a976282" translate="yes" xml:space="preserve">
          <source>The memory corruption problem becomes more acute when using &lt;a href=&quot;mmap&quot;&gt;memory-mapped I/O&lt;/a&gt;. When all or part of the database file is mapped into the application's address space, then a stray pointer that overwrites any part of that mapped space will immediately corrupt the database file, without requiring the application to do a subsequent write() system call.</source>
          <target state="translated">使用&lt;a href=&quot;mmap&quot;&gt;内存映射的I / O&lt;/a&gt;时，内存损坏问题变得更加严重。当数据库文件的全部或部分映射到应用程序的地址空间时，覆盖该映射空间的任何部分的杂散指针将立即破坏数据库文件，而无需应用程序执行后续的write（）系统调用。</target>
        </trans-unit>
        <trans-unit id="1f25753cb6dacb02b829c0a340f5d35891b7f9cb" translate="yes" xml:space="preserve">
          <source>The memory footprint of the application can be dramatically reduced by only loading content that is relevant to the current display and keeping the bulk of the content on disk. The fast query capability of SQLite make this a viable alternative to keeping all content in memory at all times. And when applications use less memory, it makes the entire computer more responsive, further enhancing the user experience.</source>
          <target state="translated">通过只加载与当前显示相关的内容,而将大部分内容保留在磁盘上,可以极大地减少应用程序的内存占用。SQLite的快速查询能力使其成为一个可行的替代方案,而不是将所有内容始终保留在内存中。而当应用程序使用较少的内存时,就会使整个计算机的响应速度更快,进一步提升用户体验。</target>
        </trans-unit>
        <trans-unit id="9d3e4b06e9105ca7c88a4e1edabcb69936b1841b" translate="yes" xml:space="preserve">
          <source>The memory high-water mark is reset to the current value of &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; if and only if the parameter to &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; is true. The value returned by &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater(1)&lt;/a&gt; is the high-water mark prior to the reset.</source>
          <target state="translated">当且仅当&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;的参数为true时，内存高水位标记才会重置为&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;的当前值。&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater（1）&lt;/a&gt;返回的值是重置之前的高水位线。</target>
        </trans-unit>
        <trans-unit id="cd5593ab95a8d1e1ac6cc8d242678782f1a535e8" translate="yes" xml:space="preserve">
          <source>The memory high-water mark is reset to the current value of &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; if and only if the parameter to &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; is true. The value returned by &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater(1)&lt;/a&gt; is the high-water mark prior to the reset.</source>
          <target state="translated">当且仅当&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;的参数为true时，内存高水位标记才会重置为&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;的当前值。&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater（1）&lt;/a&gt;返回的值是重置之前的高水位线。</target>
        </trans-unit>
        <trans-unit id="a98788d1208d8031c1910803fa2f1051d600b111" translate="yes" xml:space="preserve">
          <source>The memory pointed to by the character pointers returned for the declaration type and collation sequence is valid until the next call to any SQLite API function.</source>
          <target state="translated">为声明类型和整理序列返回的字符指针所指向的内存是有效的,直到下一次调用任何SQLite API函数。</target>
        </trans-unit>
        <trans-unit id="523aa17230ae599153575b20eede454c13803757" translate="yes" xml:space="preserve">
          <source>The memory returned by sqlite3_malloc(), sqlite3_realloc(), sqlite3_malloc64(), and sqlite3_realloc64() is always aligned to at least an 8 byte boundary, or to a 4 byte boundary if the &lt;a href=&quot;../compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">sqlite3_malloc（），sqlite3_realloc（），sqlite3_malloc64（）和sqlite3_realloc64（）返回的内存始终至少对齐8个字节边界，如果使用&lt;a href=&quot;../compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt;编译时选项，则始终对齐4个字节边界。</target>
        </trans-unit>
        <trans-unit id="0b4a85ec728749e1396a0209dbea3173ce995dba" translate="yes" xml:space="preserve">
          <source>The memory returned by sqlite3_malloc(), sqlite3_realloc(), sqlite3_malloc64(), and sqlite3_realloc64() is always aligned to at least an 8 byte boundary, or to a 4 byte boundary if the &lt;a href=&quot;compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">sqlite3_malloc（），sqlite3_realloc（），sqlite3_malloc64（）和sqlite3_realloc64（）返回的内存始终至少对齐8个字节边界，如果使用&lt;a href=&quot;compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt;编译时选项，则始终对齐4个字节边界。</target>
        </trans-unit>
        <trans-unit id="d4065cde811c203e3d250a3f54d5601da517866b" translate="yes" xml:space="preserve">
          <source>The memsys5 allocator is designed for use on embedded systems, though there is nothing to prevent its use on workstations. The szBuf is typically between a few hundred kilobytes up to a few dozen megabytes, depending on system requirements and memory budget.</source>
          <target state="translated">memsys5分配器是为在嵌入式系统上使用而设计的,不过并不妨碍在工作站上使用它。szBuf通常在几百千字节到几十兆字节之间,这取决于系统需求和内存预算。</target>
        </trans-unit>
        <trans-unit id="15e755d3b15a2797fc8e730750dc9e96957bcf11" translate="yes" xml:space="preserve">
          <source>The min() aggregate function returns the minimum non-NULL value of all values in the group. The minimum value is the first non-NULL value that would appear in an ORDER BY of the column. Aggregate min() returns NULL if and only if there are no non-NULL values in the group.</source>
          <target state="translated">min()集合函数返回该组中所有值的最小非NULL值,最小值是在列的ORDER BY中出现的第一个非NULL值。最小值是列的ORDER BY中出现的第一个非NULL值。聚合函数min()只在组中没有非NULL值的情况下返回NULL。</target>
        </trans-unit>
        <trans-unit id="114a5a7dbd98c187abf7e68d111172546895bf6d" translate="yes" xml:space="preserve">
          <source>The min/max-value pair columns are stored as 32-bit floating point values for &quot;rtree&quot; virtual tables or as 32-bit signed integers in &quot;rtree_i32&quot; virtual tables. Unlike regular SQLite tables which can store data in a variety of datatypes and formats, the R*Tree rigidly enforce these storage types. If any other type of value is inserted into such a column, the r-tree module silently converts it to the required type before writing the new record to the database.</source>
          <target state="translated">对于 &quot;rtree &quot;虚拟表来说,最小值/最大值对列存储为32位浮点值,或者在 &quot;rtree_i32 &quot;虚拟表中存储为32位有符号整数。与常规的SQLite表可以以各种数据类型和格式存储数据不同,R*Tree严格执行这些存储类型。如果在这样的列中插入任何其他类型的值,r-tree模块会在将新记录写入数据库之前,默默地将其转换为所需类型。</target>
        </trans-unit>
        <trans-unit id="697dd64d2ba004e05302a199cbf94ae930397047" translate="yes" xml:space="preserve">
          <source>The minimum &quot;three+four&quot; value</source>
          <target state="translated">最低 &quot;三+四 &quot;值</target>
        </trans-unit>
        <trans-unit id="4344744cb5e4e7fe1c07e4d9e9f4f1a35db07ca5" translate="yes" xml:space="preserve">
          <source>The minimum size of an SQLite database is one page for each table and each index. With a larger page size, the size of an empty database for a given schema will grow by a factor of four, therefore. However, once the database begins to fill with content the size of the older 1024-byte page databases and the newer 4096-byte page databases will quickly converge. Due to relaxed bin-packing constraints, the 4096-byte page size might actually result in a smaller file, once substantial content is added.</source>
          <target state="translated">SQLite数据库的最小尺寸是每个表和每个索引的一个页面。随着页面大小的增大,一个给定模式的空数据库的大小将增长4倍,因此。然而,一旦数据库开始充满内容,旧的1024字节页数据库和新的4096字节页数据库的大小将迅速趋同。由于放宽了bin-packing限制,一旦添加了大量内容,4096字节的页面大小实际上可能会导致文件变小。</target>
        </trans-unit>
        <trans-unit id="e5d2ce57cb5bfbf79b3c98a499658be04c3e7756" translate="yes" xml:space="preserve">
          <source>The minor version number Y was historically incremented for new features and/or new interfaces that did not significantly change the structure of the code. The addition of &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt;, &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;, and &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt; are all examples of &quot;minor&quot; changes. Again, the distinction between &quot;major&quot; and &quot;minor&quot; is subjective.</source>
          <target state="translated">对于新功能和/或新接口，次要版本号Y在历史上一直递增，而新功能和/或新接口并未显着改变代码的结构。的加入&lt;a href=&quot;lang_with&quot;&gt;公共表表达式&lt;/a&gt;，&lt;a href=&quot;partialindex&quot;&gt;部分指标&lt;/a&gt;和&lt;a href=&quot;expridx&quot;&gt;指标上的表达&lt;/a&gt;是&amp;ldquo;小&amp;rdquo;的变化的例子。同样，&amp;ldquo;主要&amp;rdquo;和&amp;ldquo;次要&amp;rdquo;之间的区别是主观的。</target>
        </trans-unit>
        <trans-unit id="daac53b800202886e5a1bc16ab5a5eb44a3f8d4d" translate="yes" xml:space="preserve">
          <source>The mirror is an incremental export of the &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;canonical Fossil repository&lt;/a&gt; for SQLite. A cron-job updates the GitHub repository once an hour. This is a one-way, read-only code mirror. No pull requests or changes are accepted via GitHub. The GitHub repository merely copies the content from the Fossil repository. All changes are input via Fossil.</source>
          <target state="translated">镜像是SQLite &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;规范化Fossil存储库&lt;/a&gt;的增量导出。一个cron-job每小时更新一次GitHub存储库。这是一个单向只读代码镜像。 GitHub不接受任何请求或更改。 GitHub存储库仅复制Fossil存储库中的内容。所有更改均通过Fossil输入。</target>
        </trans-unit>
        <trans-unit id="8699fa6e48270c38aaec7f72b7768d7c856e3da2" translate="yes" xml:space="preserve">
          <source>The mmap_size is set separately for each database file using the &quot;&lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;&quot; statement. The usual default mmap_size is zero, meaning that memory mapped I/O is disabled by default. However, the default mmap_size can be increased either at compile-time using the &lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt; macro or at start-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;,...) interface.</source>
          <target state="translated">使用&amp;ldquo; &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; &amp;rdquo;语句为每个数据库文件分别设置mmap_size。通常的默认mmap_size为零，这意味着默认情况下禁用内存映射的I / O。但是，可以在编译时使用&lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt;宏或在启动时使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;，...）接口来增加默认的mmap_size 。</target>
        </trans-unit>
        <trans-unit id="bc3aa8081ad975eaa64522ee2647fdff6a383213" translate="yes" xml:space="preserve">
          <source>The mode query parameter determines if the new database is opened read-only, read-write, read-write and created if it does not exist, or that the database is a pure in-memory database that never interacts with disk, respectively.</source>
          <target state="translated">模式查询参数分别决定新数据库是只读、读写、读写,如果不存在则创建,或者数据库是纯内存数据库,从不与磁盘交互。</target>
        </trans-unit>
        <trans-unit id="f2526ac46e681fb29c61b97dfb71933e5d3d8f00" translate="yes" xml:space="preserve">
          <source>The modifications made to each row affected by an UPDATE statement are determined by the list of assignments following the SET keyword. Each assignment specifies a column-name to the left of the equals sign and a scalar expression to the right. For each affected row, the named columns are set to the values found by evaluating the corresponding scalar expressions. If a single column-name appears more than once in the list of assignment expressions, all but the rightmost occurrence is ignored. Columns that do not appear in the list of assignments are left unmodified. The scalar expressions may refer to columns of the row being updated. In this case all scalar expressions are evaluated before any assignments are made.</source>
          <target state="translated">受UPDATE语句影响的每条记录的修改由SET关键字后面的赋值列表决定。每个赋值都在等号左边指定一个列名,右边指定一个标量表达式。对于每一条受影响的记录,被命名的列会被设置为通过评估相应的标量表达式所找到的值。如果一个列名在赋值表达式列表中出现了一次以上,那么除了最右边出现的列名外,其他列名都会被忽略。没有出现在赋值列表中的列名将不被修改。标量表达式可能指的是被更新行的列。在这种情况下,所有标量表达式在进行任何赋值之前都会被评估。</target>
        </trans-unit>
        <trans-unit id="c57c56215c73a95bddb16c7f419303a4f511dbe2" translate="yes" xml:space="preserve">
          <source>The module name is registered on the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the first parameter. The name of the module is given by the second parameter. The third parameter is a pointer to the implementation of the &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt;. The fourth parameter is an arbitrary client data pointer that is passed through into the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of the virtual table module when a new virtual table is be being created or reinitialized.</source>
          <target state="translated">模块名称在第一个参数指定的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;上注册。模块的名称由第二个参数给出。第三个参数是&lt;a href=&quot;#sqlite3_module&quot;&gt;虚拟表模块&lt;/a&gt;实现的指针。第四个参数是一个任意的客户端数据指针，当创建或重新初始化新的虚拟表时，该指针将传递到虚拟表模块的&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;和&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;方法中。</target>
        </trans-unit>
        <trans-unit id="f7d008fdf7032ca8558d613dfe5b4ba03ec8869a" translate="yes" xml:space="preserve">
          <source>The module name is registered on the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the first parameter. The name of the module is given by the second parameter. The third parameter is a pointer to the implementation of the &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt;. The fourth parameter is an arbitrary client data pointer that is passed through into the &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of the virtual table module when a new virtual table is be being created or reinitialized.</source>
          <target state="translated">模块名称在第一个参数指定的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;上注册。模块的名称由第二个参数给出。第三个参数是&lt;a href=&quot;module&quot;&gt;虚拟表模块&lt;/a&gt;实现的指针。第四个参数是一个任意的客户端数据指针，当创建或重新初始化新的虚拟表时，该指针将传递到虚拟表模块的&lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;和&lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;方法中。</target>
        </trans-unit>
        <trans-unit id="c29884604bb765a8ff66e73918a8eec45479c155" translate="yes" xml:space="preserve">
          <source>The module name must be changed from &quot;fts3&quot; or &quot;fts4&quot; to &quot;fts5&quot;.</source>
          <target state="translated">模块名称必须从 &quot;fts3 &quot;或 &quot;fts4 &quot;改为 &quot;fts5&quot;。</target>
        </trans-unit>
        <trans-unit id="ea30bfabecd455dc9fb80bfe26599d0bf2066398" translate="yes" xml:space="preserve">
          <source>The module structure contains methods that are invoked by SQLite to perform various actions on the virtual table such as creating new instances of a virtual table or destroying old ones, reading and writing data, searching for and deleting, updating, or inserting rows. The module structure is explained in more detail below.</source>
          <target state="translated">该模块结构包含了SQLite调用的方法,用于对虚拟表执行各种操作,如创建虚拟表的新实例或销毁旧实例、读写数据、搜索和删除、更新或插入行。下面将对该模块结构进行详细说明。</target>
        </trans-unit>
        <trans-unit id="e7e8ce1834b0e39b1a04f1ee58c27c3761f545ea" translate="yes" xml:space="preserve">
          <source>The module structure defines all of the methods for each virtual table object. The module structure also contains the iVersion field which defines the particular edition of the module table structure. Currently, iVersion is always 3 or less, but in future releases of SQLite the module structure definition might be extended with additional methods and in that case the maximum iVersion value will be increased.</source>
          <target state="translated">模块结构定义了每个虚拟表对象的所有方法。模块结构还包含iVersion字段,它定义了模块表结构的特定版本。目前,iVersion总是3或更少,但在未来的SQLite版本中,模块结构定义可能会扩展更多的方法,在这种情况下,最大的iVersion值会增加。</target>
        </trans-unit>
        <trans-unit id="f82636212897757718a1a7712ed9f6ebe7472ac1" translate="yes" xml:space="preserve">
          <source>The module-name is the name of an object that implements the virtual table. The module-name must be registered with the SQLite database connection using &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; prior to issuing the CREATE VIRTUAL TABLE statement. The module takes zero or more comma-separated arguments. The arguments can be just about any text as long as it has balanced parentheses. The argument syntax is sufficiently general that the arguments can be made to appear as &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definitions&lt;/a&gt; in a traditional &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. SQLite passes the module arguments directly to the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of the module implementation without any interpretation. It is the responsibility of the module implementation to parse and interpret its own arguments.</source>
          <target state="translated">module-name是实现虚拟表的对象的名称。在发出CREATE VIRTUAL TABLE语句之前，必须使用&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module（）&lt;/a&gt;或&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2（）&lt;/a&gt;向SQLite数据库连接注册模块名称。该模块接受零个或多个逗号分隔的参数。只要括号中有括号，参数就可以是任何文本。参数语法足够通用，可以使参数在传统的&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句中显示为&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;列定义&lt;/a&gt;。 SQLite将模块参数直接传递给&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;和&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;模块实现的方法，无需任何解释。模块实现负责解析和解释其自身的参数。</target>
        </trans-unit>
        <trans-unit id="44619ca32ea56419710789f2ec6fc9766c59ac70" translate="yes" xml:space="preserve">
          <source>The most common reason an attempt to obtain a</source>
          <target state="translated">最常见的原因是,试图获得</target>
        </trans-unit>
        <trans-unit id="b4677e9c54155902987749f94de50b511a297fed" translate="yes" xml:space="preserve">
          <source>The most common way to force an SQLite database to exist purely in memory is to open the database using the special filename &quot;&lt;b&gt;:memory:&lt;/b&gt;&quot;. In other words, instead of passing the name of a real disk file into one of the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; functions, pass in the string &quot;:memory:&quot;. For example:</source>
          <target state="translated">强制SQLite数据库完全存在于内存中的最常见方法是使用特殊文件名&amp;ldquo; &lt;b&gt;：memory：&lt;/b&gt; &amp;rdquo; 打开数据库。换句话说，不是将实际磁盘文件的名称传递给&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;或&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;函数之一，而是传递字符串&amp;ldquo;：memory：&amp;rdquo;。例如：</target>
        </trans-unit>
        <trans-unit id="03a7919d9a36d839fb3e6c8676819056867ece77" translate="yes" xml:space="preserve">
          <source>The most efficient way to apply changes to a B-Tree (the data structure that SQLite uses to store each table and index on disk) is to make the changes in key order. But if an SQL table has one or more indexes, the key order for each index may be different from the main table and the other auxiliary indexes. As a result, when executing a series of &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements it is not generally possible to order the operations so that all b-trees are updated in key order. The RBU update process works around this by applying all changes to the main table in one pass, then applying changes to each index in separate passes, ensuring each B-Tree is updated optimally. For a large database file (one that does not fit in the OS disk cache) this procedure can result in two orders of magnitude faster updates.</source>
          <target state="translated">将更改应用于B树（SQLite用于在磁盘上存储每个表和索引的数据结构）的最有效方法是按键顺序进行更改。但是，如果SQL表具有一个或多个索引，则每个索引的键顺序可能与主表和其他辅助索引不同。结果，当执行一系列&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;，&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;和&lt;a href=&quot;lang_delete&quot;&gt;DELETE时&lt;/a&gt;语句通常无法对操作进行排序，以使所有b树都按键顺序进行更新。 RBU更新过程通过一次将所有更改应用于主表，然后在单独的通道中将更改应用于每个索引，从而确保对每个B-Tree进行最佳更新来解决此问题。对于大型数据库文件（一个不适合OS磁盘缓存的文件），此过程可以使更新速度提高两个数量级。</target>
        </trans-unit>
        <trans-unit id="0aab584bc04ad9506143fb4e57b11f24aeb68952" translate="yes" xml:space="preserve">
          <source>The most useful</source>
          <target state="translated">最有用的</target>
        </trans-unit>
        <trans-unit id="672a287b758e4f6545eeda0d335349088507b997" translate="yes" xml:space="preserve">
          <source>The most useful thing about FTS tables is the queries that may be performed using the built-in full-text index. Full-text queries are performed by specifying a clause of the form &quot;&amp;lt;column&amp;gt; MATCH &amp;lt;full-text query expression&amp;gt;&quot; as part of the WHERE clause of a SELECT statement that reads data from an FTS table. &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;Simple FTS queries&lt;/a&gt; that return all documents that contain a given term are described above. In that discussion the right-hand operand of the MATCH operator was assumed to be a string consisting of a single term. This section describes the more complex query types supported by FTS tables, and how they may be utilized by specifying a more complex query expression as the right-hand operand of a MATCH operator.</source>
          <target state="translated">关于FTS表，最有用的是可以使用内置的全文本索引执行的查询。通过指定形式为&amp;ldquo; &amp;lt;column&amp;gt; MATCH &amp;lt;全文查询表达式&amp;gt;&amp;rdquo;的子句来执行全文查询，这是从FTS表中读取数据的SELECT语句的WHERE子句的一部分。上面描述了返回所有包含给定术语的所有文档的&lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;简单FTS查询&lt;/a&gt;。在该讨论中，MATCH运算符的右侧操作数被假定为由单个项组成的字符串。本节描述FTS表支持的更复杂的查询类型，以及如何通过将更复杂的查询表达式指定为MATCH运算符的右侧操作数来利用它们。</target>
        </trans-unit>
        <trans-unit id="b952b720a1c68c621b96fa1e29a1ec3a3e91db58" translate="yes" xml:space="preserve">
          <source>The multi-argument max() function returns the argument with the maximum value, or return NULL if any argument is NULL. The multi-argument max() function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If none of the arguments to max() define a collating function, then the BINARY collating function is used. Note that &lt;b&gt;max()&lt;/b&gt; is a simple function when it has 2 or more arguments but operates as an &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;aggregate function&lt;/a&gt; if given only a single argument.</source>
          <target state="translated">多参数max（）函数返回具有最大值的参数，如果任何参数为NULL，则返回NULL。多参数max（）函数从左到右搜索其参数，以找到定义整理函数并将该整理函数用于所有字符串比较的参数。如果max（）的参数均未定义整理函数，则使用BINARY整理函数。请注意，当&lt;b&gt;max（）&lt;/b&gt;具有2个或更多参数时，它是一个简单函数，但如果仅给出单个参数，则它作为一个&lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;聚合函数&lt;/a&gt;运行。</target>
        </trans-unit>
        <trans-unit id="4978bfa5c1668418de3cae9f58ae0236b3a923fa" translate="yes" xml:space="preserve">
          <source>The multi-argument min() function returns the argument with the minimum value. The multi-argument min() function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If none of the arguments to min() define a collating function, then the BINARY collating function is used. Note that &lt;b&gt;min()&lt;/b&gt; is a simple function when it has 2 or more arguments but operates as an &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;aggregate function&lt;/a&gt; if given only a single argument.</source>
          <target state="translated">多参数min（）函数返回带有最小值的参数。多参数min（）函数从左到右搜索其参数，以定义一个定义整理函数的参数，并将该整理函数用于所有字符串比较。如果min（）的参数均未定义整理函数，则使用BINARY整理函数。请注意，当&lt;b&gt;min（）&lt;/b&gt;具有2个或更多参数时，它是一个简单的函数；但是，如果仅给定单个参数，则它将作为&lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;聚合函数&lt;/a&gt;运行。</target>
        </trans-unit>
        <trans-unit id="78c0cf060a6f9ee3d1106d60ebe5e6c21511776f" translate="yes" xml:space="preserve">
          <source>The multiply operator now correctly detects 64-bit integer overflow and promotes to floating point in all corner-cases. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/1ec41379c9c1e400&quot;&gt;1ec41379c9c1e400&lt;/a&gt;.</source>
          <target state="translated">现在，乘法运算符可以正确检测到64位整数溢出，并在所有转折情况下都提升为浮点数。修复票&lt;a href=&quot;https://www.sqlite.org/src/info/1ec41379c9c1e400&quot;&gt;1ec41379c9c1e400&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ee9132cb0f48417f8650cad9e27fe43d03b0618b" translate="yes" xml:space="preserve">
          <source>The mutation-test.tcl script takes care of all of the details for running a mutation test:</source>
          <target state="translated">mutation-test.tcl脚本处理了运行突变测试的所有细节。</target>
        </trans-unit>
        <trans-unit id="2945579c517aa1d3b8ba9d11b0bc3f91de1e9921" translate="yes" xml:space="preserve">
          <source>The mutex module within SQLite defines &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; to be an abstract type for a mutex object. The SQLite core never looks at the internal representation of an &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;. It only deals with pointers to the &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object.</source>
          <target state="translated">SQLite中的互斥模块将&lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;定义为互斥对象的抽象类型。SQLite核心从不查看&lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;的内部表示。它仅处理指向&lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;对象的指针。</target>
        </trans-unit>
        <trans-unit id="d0e09c593f6493d406d9e4e9dcac2eadda30e574" translate="yes" xml:space="preserve">
          <source>The mutex module within SQLite defines &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; to be an abstract type for a mutex object. The SQLite core never looks at the internal representation of an &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;. It only deals with pointers to the &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object.</source>
          <target state="translated">SQLite中的互斥模块将&lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;定义为互斥对象的抽象类型。SQLite核心从不查看&lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;的内部表示。它仅处理指向&lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;对象的指针。</target>
        </trans-unit>
        <trans-unit id="2683feab4dd898006f40d9a775532ccca7b7b569" translate="yes" xml:space="preserve">
          <source>The mxFrame value is always greater than or equal to both &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; and nBackfillAttempted.</source>
          <target state="translated">mxFrame值始终大于或等于&lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt;和nBackfillAttempted。</target>
        </trans-unit>
        <trans-unit id="ab3c5c72a969cacdc78a3e4dd0229038bdf0e320" translate="yes" xml:space="preserve">
          <source>The mxPathname field is the maximum length of a file pathname that this VFS can use. SQLite sometimes has to preallocate buffers of this size, so it should be as small as reasonably possible. Some filesystems permit huge pathnames, but in practice pathnames rarely extend beyond 100 bytes or so. You do not have to put the longest pathname that the underlying filesystem can handle here. You only have to put the longest pathname that you want SQLite to be able to handle. A few hundred is a good value in most cases.</source>
          <target state="translated">mxPathname字段是这个VFS可以使用的文件路径名的最大长度。SQLite有时不得不预分配这个大小的缓冲区,所以它应该尽可能的小。有些文件系统允许使用巨大的路径名,但实际上路径名很少超过100字节左右。你不需要把底层文件系统能处理的最长路径名放在这里。你只需要输入你希望SQLite能够处理的最长路径名。在大多数情况下,几百个是一个不错的值。</target>
        </trans-unit>
        <trans-unit id="cb1334872e71aa02626433d46e5f9130af9a0bfd" translate="yes" xml:space="preserve">
          <source>The nArg parameter specifies the number of arguments to the function. A value of 0 indicates that any number of arguments is allowed. The eTextRep parameter specifies what representation text values are expected to be in for arguments to this function. The value of this parameter should be one of the parameters defined above. SQLite version 3 allows multiple implementations of the same function using different text representations. The database engine chooses the function that minimization the number of text conversions required.</source>
          <target state="translated">nArg参数指定函数的参数数。值为0表示允许任何数量的参数。eTextRep参数指定本函数参数的文本值应该用什么表示。这个参数的值应该是上面定义的参数之一。SQLite第3版允许同一个函数使用不同的文本表示方式进行多种实现。数据库引擎会选择能使所需的文本转换次数最小化的函数。</target>
        </trans-unit>
        <trans-unit id="15067be8341cb3e5ea308646b0092b9f585804c8" translate="yes" xml:space="preserve">
          <source>The nBackfill can only be increased while holding the WAL_CKPT_LOCK. However, nBackfill is changed to zero during a &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL reset&lt;/a&gt;, and this happens while holding the WAL_WRITE_LOCK.</source>
          <target state="translated">仅在保持WAL_CKPT_LOCK的同时增加nBackfill。但是，在&lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL重置&lt;/a&gt;过程中，nBackfill会更改为零，并且在保持WAL_WRITE_LOCK时会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="99673f4f335d79523c7b7494142bf07ba1cd84e2" translate="yes" xml:space="preserve">
          <source>The nBackfill number is never greater than &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt;. When nBackfill equals &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt;, that means that the WAL content has been completely written back into the database and it is ok to &lt;a href=&quot;fileformat2#walreset&quot;&gt;reset the WAL&lt;/a&gt; if there are no locks held on any of WAL_READ_LOCK(N) for N&amp;gt;0.</source>
          <target state="translated">nBackfill编号永远不会大于&lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt;。当nBackfill等于&lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame时&lt;/a&gt;，这意味着WAL内容已被完全写回到数据库中，并且如果N&amp;gt; 0的WAL_READ_LOCK（N）中没有任何锁，则可以&lt;a href=&quot;fileformat2#walreset&quot;&gt;重置WAL&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="58aea584e25c7551e85c617c6b8537adc3f19238" translate="yes" xml:space="preserve">
          <source>The name &quot;memsys5&quot; used for the zero-malloc memory allocator implies that there are several additional memory allocators available, and indeed there are. The default memory allocator is &quot;memsys1&quot;. The debugging memory allocator is &quot;memsys2&quot;. Those have already been covered.</source>
          <target state="translated">零内存分配器使用的名称 &quot;memsys5 &quot;意味着还有几个额外的内存分配器可用,事实上也有。默认的内存分配器是 &quot;memsys1&quot;。调试内存分配器是 &quot;memsys2&quot;。这些已经介绍过了。</target>
        </trans-unit>
        <trans-unit id="e00b973d0e23f6d37321209e23fc2917cf32700a" translate="yes" xml:space="preserve">
          <source>The name &quot;sqlite_schema&quot; does not appear anywhere in the file format. That name is just a convention used by the database implementation. Due to historical and operational considerations, the &quot;sqlite_schema&quot; table can also sometimes be called by one of the following aliases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5db0afbba9901c1e9e8534384d38571355c85857" translate="yes" xml:space="preserve">
          <source>The name for the &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; used to compare values in the index-column.</source>
          <target state="translated">&lt;a href=&quot;datatype3#collation&quot;&gt;整理序列&lt;/a&gt;的名称，用于比较索引列中的值。</target>
        </trans-unit>
        <trans-unit id="d0a42cf139ce30315511c41a36a93d913d4ae81d" translate="yes" xml:space="preserve">
          <source>The name of a result column is the value of the &quot;AS&quot; clause for that column, if there is an AS clause. If there is no AS clause then the name of the column is unspecified and may change from one release of SQLite to the next.</source>
          <target state="translated">如果有AS子句,那么结果列的名称就是该列的 &quot;AS &quot;子句的值。如果没有AS子句,那么该列的名称是未指定的,可能会随着SQLite的不同版本而改变。</target>
        </trans-unit>
        <trans-unit id="a57f858acf3d2e5077979e3afa2c8309985a2b90" translate="yes" xml:space="preserve">
          <source>The name of an SQLite database is the name of a file that will contain the database. If the file does not exist, SQLite attempts to create and initialize it. If the file is read-only (due to permission bits or because it is located on read-only media like a CD-ROM) then SQLite opens the database for reading only. The entire SQL database is stored in a single file on the disk. But additional temporary files may be created during the execution of an SQL command in order to store the database rollback journal or temporary and intermediate results of a query.</source>
          <target state="translated">SQLite数据库的名称是一个将包含数据库的文件的名称。如果文件不存在,SQLite会尝试创建并初始化它。如果文件是只读的(由于权限位或因为它位于CD-ROM等只读介质上),那么SQLite就会打开数据库进行只读。整个SQL数据库存储在磁盘上的一个文件中。但是在执行SQL命令的过程中可能会创建额外的临时文件,以便存储数据库回滚日志或查询的临时和中间结果。</target>
        </trans-unit>
        <trans-unit id="2e5f7637f527bcb85ea83184153ee4c57e5bbfca" translate="yes" xml:space="preserve">
          <source>The name of each column in the table.</source>
          <target state="translated">表中每一列的名称。</target>
        </trans-unit>
        <trans-unit id="e1e64668404efe0d041f261ba3d958b47753bba4" translate="yes" xml:space="preserve">
          <source>The name of the FTS5 table column that contains the term.</source>
          <target state="translated">包含术语的FTS5表列名称。</target>
        </trans-unit>
        <trans-unit id="fb2519166ef6466d94c575e04a046d25ae02cbef" translate="yes" xml:space="preserve">
          <source>The name of the collation is a UTF-8 string for sqlite3_create_collation() and sqlite3_create_collation_v2() and a UTF-16 string in native byte order for sqlite3_create_collation16(). Collation names that compare equal according to &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; are considered to be the same name.</source>
          <target state="translated">排序规则的名称是sqlite3_create_collat​​ion（）和sqlite3_create_collat​​ion_v2（）的UTF-8字符串，以及sqlite3_create_collat​​ion16（）的本地字节顺序的UTF-16字符串。根据&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp（）&lt;/a&gt;比较相等的排序规则名称被视为相同的名称。</target>
        </trans-unit>
        <trans-unit id="7df8bfa2bb01af5c880a238a6167d3b3a1623f37" translate="yes" xml:space="preserve">
          <source>The name of the collation is a UTF-8 string for sqlite3_create_collation() and sqlite3_create_collation_v2() and a UTF-16 string in native byte order for sqlite3_create_collation16(). Collation names that compare equal according to &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; are considered to be the same name.</source>
          <target state="translated">排序规则的名称是sqlite3_create_collat​​ion（）和sqlite3_create_collat​​ion_v2（）的UTF-8字符串，以及sqlite3_create_collat​​ion16（）的本地字节顺序的UTF-16字符串。根据&lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp（）&lt;/a&gt;比较相等的排序规则名称被视为相同的名称。</target>
        </trans-unit>
        <trans-unit id="60f9c38a5b1707739850b72dfb67adc25dbc2069" translate="yes" xml:space="preserve">
          <source>The name of the column being indexed, or NULL if the index-column is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the table being indexed or an &lt;a href=&quot;expridx&quot;&gt;expression&lt;/a&gt;.</source>
          <target state="translated">被索引列的名称；如果index-column是被索引表的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;或&lt;a href=&quot;expridx&quot;&gt;expression，&lt;/a&gt;则为NULL 。</target>
        </trans-unit>
        <trans-unit id="a2c4a68aabf0cd9d6847a72cb797a421605fdb66" translate="yes" xml:space="preserve">
          <source>The name of the column being indexed. This columns is NULL if the column is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; or an &lt;a href=&quot;expridx&quot;&gt;expression&lt;/a&gt;.</source>
          <target state="translated">被索引的列的名称。如果列是&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;或&lt;a href=&quot;expridx&quot;&gt;表达式，&lt;/a&gt;则此列为 NULL 。</target>
        </trans-unit>
        <trans-unit id="2755fad1da17fab976d4effee601e3a0ced598c2" translate="yes" xml:space="preserve">
          <source>The name of the column that contains the term instance.</source>
          <target state="translated">包含术语实例的列名。</target>
        </trans-unit>
        <trans-unit id="d4c672f643ac02f7fa3683763e45ddf698d1be4b" translate="yes" xml:space="preserve">
          <source>The name of the database is usually just the name of a disk file in which the database is stored. If the name of the database is the special name &quot;&lt;a href=&quot;inmemorydb&quot;&gt;:memory:&lt;/a&gt;&quot; then a new database is created in memory. If the name of the database is an empty string, then the database is created in an empty file that is automatically deleted when the database connection closes. &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; can be used if the &quot;&lt;b&gt;-uri yes&lt;/b&gt;&quot; option is supplied on the &lt;b&gt;sqlite3&lt;/b&gt; command.</source>
          <target state="translated">数据库的名称通常只是存储数据库的磁盘文件的名称。如果数据库名称是特殊名称&amp;ldquo; &lt;a href=&quot;inmemorydb&quot;&gt;：memory：&lt;/a&gt; &amp;rdquo;，则会在内存中创建一个新数据库。如果数据库名称是一个空字符串，那么将在一个空文件中创建数据库，该文件将在数据库连接关闭时自动删除。如果&lt;b&gt;sqlite3&lt;/b&gt;命令提供了&amp;ldquo; &lt;b&gt;-uri yes&lt;/b&gt; &amp;rdquo;选项，则可以使用&lt;a href=&quot;uri&quot;&gt;URI文件名&lt;/a&gt;。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="638ad72e8f8e6b978d1b5c7a5434bac446aa668c" translate="yes" xml:space="preserve">
          <source>The name of the database on which the transaction was committed</source>
          <target state="translated">进行交易的数据库名称;</target>
        </trans-unit>
        <trans-unit id="b53c39aeaa16a31f4a835cb5ee0c4ef2cb1c4ca7" translate="yes" xml:space="preserve">
          <source>The name of the database table,</source>
          <target state="translated">数据库表的名称。</target>
        </trans-unit>
        <trans-unit id="1389d8d4ecdcdbedac7a4549e6a07ae7ad0ad26c" translate="yes" xml:space="preserve">
          <source>The name of the database which is being changed</source>
          <target state="translated">正在更改的数据库名称</target>
        </trans-unit>
        <trans-unit id="fc047e5a2c9d6a845176aac031ed03d6a1b50ee2" translate="yes" xml:space="preserve">
          <source>The name of the desired tokenizer should be substituted in place of 'porter' in the example, of course. If the tokenizer requires one or more arguments, they should be separated by commas in the fts3tokenize declaration (even though they are separated by spaces in declarations of regular fts4 tables). The following creates fts4 and fts3tokenize tables that use the same tokenizer:</source>
          <target state="translated">当然,在本例中,需要用 tokenizer 的名称代替 'porter'。如果 tokenizer 需要一个或多个参数,那么在 fts3tokenize 声明中应该用逗号来分隔(尽管在常规的 fts4 表的声明中是用空格分隔的)。下面创建了使用相同 tokenizer 的 fts4 和 fts3tokenize 表。</target>
        </trans-unit>
        <trans-unit id="9a63a9136665984fc122cf635a36ad0166ead67d" translate="yes" xml:space="preserve">
          <source>The name of the index.</source>
          <target state="translated">索引的名称。</target>
        </trans-unit>
        <trans-unit id="c2412b63f15e8dfde7222fa76ad9e5504c06aea1" translate="yes" xml:space="preserve">
          <source>The name of the new table.</source>
          <target state="translated">新表的名称。</target>
        </trans-unit>
        <trans-unit id="a12d264e140fa64a7adf3172f5ec27d60bbcedb0" translate="yes" xml:space="preserve">
          <source>The name of the result column is a combination of the source table and source column name: TABLE.COLUMN</source>
          <target state="translated">结果列的名称是源表和源列名称的组合:TABLE.COLUMN。</target>
        </trans-unit>
        <trans-unit id="85777de7d38bf8fc5dfa8258c31af44f8a1c7698" translate="yes" xml:space="preserve">
          <source>The name of the table contains one or more &quot;_&quot; characters.</source>
          <target state="translated">表名包含一个或多个&quot;_&quot;字符。</target>
        </trans-unit>
        <trans-unit id="d14fb34ff4c810e0436eba6520cbeda0158f9e95" translate="yes" xml:space="preserve">
          <source>The name of the table data is read from.</source>
          <target state="translated">从表中读取数据的名称。</target>
        </trans-unit>
        <trans-unit id="a43b536a14c1d7b3d8b50ac0e9b44a83e9c467f9" translate="yes" xml:space="preserve">
          <source>The name of the table in which the xColumnSize values are stored (unless columnsize=0 is specified) is &quot;&amp;lt;name&amp;gt;_docsize&quot;, where &amp;lt;name&amp;gt; is the name of the FTS5 table itself. The &lt;a href=&quot;https://www.sqlite.org/download.html&quot;&gt;sqlite3_analyzer&lt;/a&gt; tool may be used on an existing database in order to determine how much space might be saved by recreating an FTS5 table using columnsize=0.</source>
          <target state="translated">存储xColumnSize值的表的名称（除非指定了columnize = 0）是&amp;ldquo; &amp;lt;名称&amp;gt; _docsize&amp;rdquo;，其中，&amp;lt;名称&amp;gt;是FTS5表本身的名称。该&lt;a href=&quot;https://www.sqlite.org/download.html&quot;&gt;sqlite3_analyzer&lt;/a&gt;工具可以在现有的数据库，以确定有多少空间可以通过重新使用columnsize = 0的FTS5表保存使用。</target>
        </trans-unit>
        <trans-unit id="ba455f33d978f1db1e5e1561024b5ab7e0845678" translate="yes" xml:space="preserve">
          <source>The name of the table or index that is implemented by the btree of the current row</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9dba3fb9b44494b1bade858ebafe1459aa85475" translate="yes" xml:space="preserve">
          <source>The name of the table to be modified in an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement must be an unqualified table name. In other words, one must use just &quot;</source>
          <target state="translated">要在&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;，&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;或&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;语句中修改的表的名称必须是非限定的表名称。换句话说，您只能使用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="6e32ef9d959d1305ba25656ee3bbcec3b526eef2" translate="yes" xml:space="preserve">
          <source>The name that occurs after the AS keyword is the name of the database used internally by SQLite. The schema-names 'main' and 'temp' refer to the main database and the database used for temporary tables. The main and temp databases cannot be attached or detached.</source>
          <target state="translated">AS关键字后出现的名称是SQLite内部使用的数据库名称。模式名'main'和'temp'指的是主数据库和用于临时表的数据库。主数据库和临时数据库不能被附加或分离。</target>
        </trans-unit>
        <trans-unit id="c7f1793be68e4540903171531d569a4a7be0fbfa" translate="yes" xml:space="preserve">
          <source>The names and numeric values for existing result codes are fixed and unchanging. However, new result codes, and especially new extended result codes, might appear in future releases of SQLite.</source>
          <target state="translated">现有结果代码的名称和数值是固定不变的。但是,新的结果代码,特别是新的扩展结果代码,可能会出现在SQLite的未来版本中。</target>
        </trans-unit>
        <trans-unit id="6c186656572f2bf1670bbd5a3b99aeadd51bedda" translate="yes" xml:space="preserve">
          <source>The names of the columns are contained in first</source>
          <target state="translated">栏目名称包含在第一</target>
        </trans-unit>
        <trans-unit id="6e42a281800acf1a1a711bf3baf9388c4ecfa00b" translate="yes" xml:space="preserve">
          <source>The names returned are the original un-aliased names of the database, table, and column.</source>
          <target state="translated">返回的名称是数据库、表、列的原始无偏旁名称。</target>
        </trans-unit>
        <trans-unit id="9d972c129d1db380a40044755e84ee7d9ba4bda3" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface allows an application to customize the behavior of SQLite at run-time. Customizations possible using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; include the following:</source>
          <target state="translated">新的&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;接口允许应用程序在运行时自定义SQLite的行为。使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;可能进行的自定义包括以下内容：</target>
        </trans-unit>
        <trans-unit id="3df658c177f1eac56b80fa5f85864ebd817426dc" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt; interface allows an application to query the performance status of SQLite at runtime.</source>
          <target state="translated">新的&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status（）&lt;/a&gt;接口允许应用程序在运行时查询SQLite的性能状态。</target>
        </trans-unit>
        <trans-unit id="a8d3b04d8482aa6bd5d923ab36f6fdfe7a6ac1b9" translate="yes" xml:space="preserve">
          <source>The new API for SQLite 3.0 contains routines that accept text as both UTF-8 and UTF-16 in the native byte order of the host machine. Each database file manages text as either UTF-8, UTF-16BE (big-endian), or UTF-16LE (little-endian). Internally and in the disk file, the same text representation is used everywhere. If the text representation specified by the database file (in the file header) does not match the text representation required by the interface routines, then text is converted on-the-fly. Constantly converting text from one representation to another can be computationally expensive, so it is suggested that programmers choose a single representation and stick with it throughout their application.</source>
          <target state="translated">SQLite 3.0的新API包含了一些例程,这些例程可以接受文本为UTF-8和UTF-16,并以主机的本地字节顺序排列。每个数据库文件都以UTF-8、UTF-16BE(大字节)或UTF-16LE(小字节)的形式管理文本。在内部和磁盘文件中,到处都使用相同的文本表示法。如果数据库文件(在文件头)指定的文本表示法与接口例程所需的文本表示法不匹配,那么文本将被即时转换。不断地将文本从一种表示方式转换到另一种表示方式可能会造成计算成本,因此建议程序员选择一种单一的表示方式,并在整个应用程序中坚持使用它。</target>
        </trans-unit>
        <trans-unit id="30af4368149bbc60ce20946b58b7cfd9adb8ff97" translate="yes" xml:space="preserve">
          <source>The new OS interface for SQLite is built around an object named &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;. The &quot;vfs&quot; stands for &quot;Virtual File System&quot;. The sqlite3_vfs object is basically a structure containing pointers to functions that implement the primitive disk I/O operations that SQLite needs to perform in order to read and write databases. In this article, we will often refer to an sqlite3_vfs objects as a &quot;VFS&quot;.</source>
          <target state="translated">SQLite的新OS接口基于名为&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;的对象构建。&amp;ldquo; vfs&amp;rdquo;代表&amp;ldquo;虚拟文件系统&amp;rdquo;。sqlite3_vfs对象基本上是一个结构，其中包含指向函数的指针，这些函数实现SQLite为了读取和写入数据库而需要执行的原始磁盘I / O操作。在本文中，我们经常将sqlite3_vfs对象称为&amp;ldquo; VFS&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6c9ac7112282c02c3ac370e4792bfc347f1711f1" translate="yes" xml:space="preserve">
          <source>The new change is ignored. This case does not occur if the new changeset was recorded immediately after the changesets already added to the changegroup.</source>
          <target state="translated">新的变更被忽略。如果新的变更集是在已经添加到变更组的变更集之后立即记录的,这种情况不会发生。</target>
        </trans-unit>
        <trans-unit id="7b39e9d3e42d3852cda66bb7e7297a2f31d0e706" translate="yes" xml:space="preserve">
          <source>The new database connection will use the &quot;multi-thread&quot; &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt;. This means that separate threads are allowed to use SQLite at the same time, as long as each thread is using a different &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ff5fb06e02cb095d4456f9e428328e41689b42" translate="yes" xml:space="preserve">
          <source>The new database connection will use the &quot;multi-thread&quot; &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt;. This means that separate threads are allowed to use SQLite at the same time, as long as each thread is using a different &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed188f9846a7395326bff47f2223ddc25ac3eab" translate="yes" xml:space="preserve">
          <source>The new database connection will use the &quot;serialized&quot; &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt;. This means the multiple threads can safely attempt to use the same database connection at the same time. (Mutexes will block any actual concurrency, but in this mode there is no harm in trying.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2075b8f3b4c50de265f00054b0d87b23e094598" translate="yes" xml:space="preserve">
          <source>The new database connection will use the &quot;serialized&quot; &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt;. This means the multiple threads can safely attempt to use the same database connection at the same time. (Mutexes will block any actual concurrency, but in this mode there is no harm in trying.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ae31ac06c9efe8e8edfec9e13527250faad45f" translate="yes" xml:space="preserve">
          <source>The new database file format uses B+trees for tables. In a B+tree, all data is stored in the leaves of the tree instead of in both the leaves and the intermediate branch nodes. The use of B+trees for tables allows for better scalability and the storage of larger data fields without the use of overflow pages. Traditional B-trees are still used for indices.</source>
          <target state="translated">新的数据库文件格式使用B+树作为表。在B+树中,所有的数据都存储在树的叶子中,而不是同时存储在叶子和中间的分支节点中。表使用B+树可以实现更好的扩展性,并且可以存储更大的数据字段,而不需要使用溢出页。传统的B树仍然用于索引。</target>
        </trans-unit>
        <trans-unit id="31e91eb6ebd1ae009dff2061b0ed5da69f5f04a8" translate="yes" xml:space="preserve">
          <source>The new file format also supports variable pages sizes between 512 and 65536 bytes. The size of a page is stored in the file header so the same library can read databases with different pages sizes, in theory, though this feature has not yet been implemented in practice.</source>
          <target state="translated">新的文件格式还支持512到65536字节之间的可变页面大小。页面的大小存储在文件头中,因此理论上同一库可以读取不同页面大小的数据库,尽管这一功能尚未在实践中实现。</target>
        </trans-unit>
        <trans-unit id="b7b98e36d84deeda55906998dc0425a8e896c821" translate="yes" xml:space="preserve">
          <source>The new file format omits unused fields from its disk images. For example, indices use only the key part of a B-tree record and not the data. So for indices, the field that records the length of the data is omitted. Integer values such as the length of key and data are stored using a variable-length encoding so that only one or two bytes are required to store the most common cases but up to 64-bits of information can be encoded if needed. Integer and floating point data is stored on the disk in binary rather than being converted into ASCII as in SQLite version 2.8. These changes taken together result in database files that are typically 25% to 35% smaller than the equivalent files in SQLite version 2.8.</source>
          <target state="translated">新的文件格式从其磁盘图像中省略了未使用的字段。例如,索引只使用B树记录的关键部分,而不使用数据。所以对于索引,记录数据长度的字段被省略。整数值如键的长度和数据的长度使用可变长度的编码来存储,所以在最常见的情况下只需要存储一个或两个字节,但如果需要的话,可以对最多64位的信息进行编码。整数和浮点数据以二进制方式存储在磁盘上,而不是像SQLite 2.8版本那样转换成ASCII。这些变化加在一起的结果是,数据库文件通常比SQLite 2.8版本中的同等文件小25%到35%。</target>
        </trans-unit>
        <trans-unit id="5a8ddfc73fc040315222214bdfe8a3558fe0da52" translate="yes" xml:space="preserve">
          <source>The new interface uses three separate functions to replace the single &lt;b&gt;sqlite_exec&lt;/b&gt; function.</source>
          <target state="translated">新接口使用三个单独的函数来替换单个&lt;b&gt;sqlite_exec&lt;/b&gt;函数。</target>
        </trans-unit>
        <trans-unit id="601cb56433c850ed70120e223ec644602fc957a5" translate="yes" xml:space="preserve">
          <source>The new object is configured with the rebase buffer obtained from sqlite3changeset_apply_v2() by calling sqlite3rebaser_configure(). If the local changeset is to be rebased against multiple remote changesets, then sqlite3rebaser_configure() should be called multiple times, in the same order that the multiple sqlite3changeset_apply_v2() calls were made.</source>
          <target state="translated">通过调用sqlite3rebaser_configure(),用从sqlite3changeset_apply_v2()获得的重基缓冲区配置新对象。如果本地变化集要针对多个远程变化集进行重基,那么sqlite3rebaser_configure()应该被多次调用,调用顺序与多次调用sqlite3changeset_apply_v2()的顺序相同。</target>
        </trans-unit>
        <trans-unit id="a80319826820a0baa113ed82a7da25195888339a" translate="yes" xml:space="preserve">
          <source>The new row must meet the same criteria as for &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; - it must exist and there must be either a blob or text value stored in the nominated column. If the new row is not present in the table, or if it does not contain a blob or text value, or if another error occurs, an SQLite error code is returned and the blob handle is considered aborted. All subsequent calls to &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; on an aborted blob handle immediately return SQLITE_ABORT. Calling &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; on an aborted blob handle always returns zero.</source>
          <target state="translated">新行必须满足与&lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open（）&lt;/a&gt;相同的条件- 新行必须存在，并且被提名列中必须存储有blob或text值。如果表中不存在新行，或者其中不包含Blob或文本值，或者发生其他错误，则返回SQLite错误代码，并且Blob句柄被视为中止。在中断的Blob句柄上对&lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen（）的&lt;/a&gt;所有后续调用都立即返回SQLITE_ABORT。在&lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;异常&lt;/a&gt;终止的Blob句柄上调用sqlite3_blob_bytes（）始终返回零。</target>
        </trans-unit>
        <trans-unit id="1fc9db87ef5146974ffc63aaf19ef4d76ed16ccc" translate="yes" xml:space="preserve">
          <source>The new row must meet the same criteria as for &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; - it must exist and there must be either a blob or text value stored in the nominated column. If the new row is not present in the table, or if it does not contain a blob or text value, or if another error occurs, an SQLite error code is returned and the blob handle is considered aborted. All subsequent calls to &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; or &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; on an aborted blob handle immediately return SQLITE_ABORT. Calling &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; on an aborted blob handle always returns zero.</source>
          <target state="translated">新行必须满足与&lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open（）&lt;/a&gt;相同的条件- 新行必须存在，并且被提名列中必须存储有blob或text值。如果表中不存在新行，或者其中不包含Blob或文本值，或者发生其他错误，则返回SQLite错误代码，并且Blob句柄被视为中止。在中断的Blob句柄上对&lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;，&lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;或&lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen（）的&lt;/a&gt;所有后续调用都立即返回SQLITE_ABORT。在&lt;a href=&quot;blob_bytes&quot;&gt;异常&lt;/a&gt;终止的Blob句柄上调用sqlite3_blob_bytes（）始终返回零。</target>
        </trans-unit>
        <trans-unit id="477dc8c1b42a8f1f1f9e215976276669879cbe40" translate="yes" xml:space="preserve">
          <source>The new values for each modified field of the row, and</source>
          <target state="translated">行中每个修改后的字段的新值,以及</target>
        </trans-unit>
        <trans-unit id="9ca11824ed5a21754d9f34df6fca6bca218bd35f" translate="yes" xml:space="preserve">
          <source>The new window definition must not include a PARTITION BY clause. The PARTITION BY clause, if there is one, must be supplied by the base window specification.</source>
          <target state="translated">新窗口定义不得包含 PARTITION BY 子句。如果有PARTITION BY子句,则必须由基本窗口规范提供。</target>
        </trans-unit>
        <trans-unit id="f3a9a1d6f9268d0f1362c9fb457875a7fb250370" translate="yes" xml:space="preserve">
          <source>The newer &quot;.eqp trace&quot; command does everything that &quot;.eqp full&quot; does and also turns on &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;VDBE tracing&lt;/a&gt;.</source>
          <target state="translated">较新的&amp;ldquo; .eqp trace&amp;rdquo;命令执行&amp;ldquo; .eqp full&amp;rdquo;所做的所有操作，并且还打开了&lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;VDBE跟踪&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd8ed5a57b50230eec8d4ec2e3e5c1e149c55cc8" translate="yes" xml:space="preserve">
          <source>The newer xQueryFunc callback receives more information from the r-tree query engine on each call, and it sends more information back to the query engine before it returns. To help keep the interface manageable, the xQueryFunc callback sends and receives information from the query engine as fields in the sqlite3_rtree_query_info structure:</source>
          <target state="translated">较新的xQueryFunc回调在每次调用时都会从r-tree查询引擎接收更多的信息,并且在返回之前会将更多的信息发回给查询引擎。为了帮助保持接口的可管理性,xQueryFunc回调以sqlite3_rtree_query_info结构中的字段形式发送和接收来自查询引擎的信息。</target>
        </trans-unit>
        <trans-unit id="03223a32a94905afaa2e599c575bdc7c618a776e" translate="yes" xml:space="preserve">
          <source>The next &quot;.mode&quot; command will reset the &quot;.separator&quot; back to its default. So you will need repeat the &quot;.separator&quot; command whenever you change modes if you want to continue using a non-standard separator.</source>
          <target state="translated">下一个&quot;.mode &quot;命令会将&quot;.separator &quot;重置为默认值。因此,如果你想继续使用非标准的分隔符,你需要在每次改变模式时重复使用&quot;.separator &quot;命令。</target>
        </trans-unit>
        <trans-unit id="9bff369a4e5022b3604d755cd856a8cb8591c715" translate="yes" xml:space="preserve">
          <source>The next block contains an example rank function that uses matchinfo data implemented in C. Instead of a single weight, it allows a weight to be externally assigned to each column of each document. It may be registered with SQLite like any other user function using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function&lt;/a&gt;.</source>
          <target state="translated">下一个块包含一个示例等级函数，该函数使用在C中实现的matchinfo数据。它允许将权重从外部分配给每个文档的每一列，而不是单个权重。可以像其他任何使用&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function的&lt;/a&gt;用户函数一样，将其注册到SQLite 。</target>
        </trans-unit>
        <trans-unit id="5e308fd7498285ea1f61e243e9d3f001701f643f" translate="yes" xml:space="preserve">
          <source>The next block of SQL enhances the query with solutions to two other problems that may arise in developing search applications using FTS:</source>
          <target state="translated">接下来的SQL块通过解决使用FTS开发搜索应用程序时可能出现的另外两个问题来增强查询。</target>
        </trans-unit>
        <trans-unit id="acd253e5152192f86ab636fd16bb5196034aa10b" translate="yes" xml:space="preserve">
          <source>The next chart compares SQLite database updates in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; against raw direct-to-disk overwrites of separate files on disk. The &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting is NORMAL. All database writes are in a single transaction. The timer for the database writes is stopped after the transaction commits, but before a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; is run. Note that the SQLite writes, unlike the direct-to-disk writes, are &lt;a href=&quot;transactional&quot;&gt;transactional&lt;/a&gt; and &lt;a href=&quot;transactional&quot;&gt;power-safe&lt;/a&gt;, though because the synchronous setting is NORMAL instead of FULL, the transactions are not durable.</source>
          <target state="translated">下一张图表将&lt;a href=&quot;wal&quot;&gt;WAL模式下的&lt;/a&gt; SQLite数据库更新与磁盘上单独文件的原始直接磁盘覆盖进行了比较。该&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt;设置为正常。所有数据库写入都在单个事务中。在事务提交之后但在运行&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;之前，数据库写计时器将停止。请注意，与直接磁盘写入不同，SQLite写入具有&lt;a href=&quot;transactional&quot;&gt;事务性&lt;/a&gt;和&lt;a href=&quot;transactional&quot;&gt;电源安全性&lt;/a&gt;，但是由于同步设置为NORMAL而不是FULL，因此事务不持久。</target>
        </trans-unit>
        <trans-unit id="0aae132ea98563594c1fa5eb1b5277ade35e9e0f" translate="yes" xml:space="preserve">
          <source>The next chart shows the performance of SQLite versus direct-to-disk when transactions are disabled (&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt;) and &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; is set to OFF. These settings put SQLite on an equal footing with direct-to-disk writes, which is to say they make the data prone to corruption due to system crashes and power failures.</source>
          <target state="translated">下一张图表显示了禁用事务（&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = OFF&lt;/a&gt;）并将&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA sync&lt;/a&gt;设置为OFF 时，SQLite与直接磁盘的性能。这些设置使SQLite在磁盘直接写入方面处于平等的地位，也就是说，由于系统崩溃和电源故障，它们使数据易于损坏。</target>
        </trans-unit>
        <trans-unit id="a36fc6db6d371099515d1fcc0740a7c0b2437b14" translate="yes" xml:space="preserve">
          <source>The next example demonstrates lag(), lead(), first_value(), last_value() and nth_value(). The frame-spec is ignored by both lag() and lead(), but respected by first_value(), last_value() and nth_value().</source>
          <target state="translated">下一个例子演示了lag()、lead()、first_value()、last_value()和nth_value()。lag()和lead()都会忽略frame-spec,但first_value()、last_value()和nth_value()会尊重它。</target>
        </trans-unit>
        <trans-unit id="edb143346c38b864be88a8c33e46d2997195abb0" translate="yes" xml:space="preserve">
          <source>The next example uses two common table expressions in a single WITH clause. The following table records a family tree:</source>
          <target state="translated">下一个例子在一个WITH子句中使用了两个常见的表表达式。下面的表记录了一个家庭树。</target>
        </trans-unit>
        <trans-unit id="1e6dfc599524aaa9c044c52fd99b0a8ed104813e" translate="yes" xml:space="preserve">
          <source>The next interface routine to SQLite is a convenience function used to test whether or not a string forms a complete SQL statement. If the &lt;b&gt;sqlite_complete&lt;/b&gt; function returns true when its input is a string, then the argument forms a complete SQL statement. There are no guarantees that the syntax of that statement is correct, but we at least know the statement is complete. If &lt;b&gt;sqlite_complete&lt;/b&gt; returns false, then more text is required to complete the SQL statement.</source>
          <target state="translated">SQLite的下一个接口例程是一个便捷函数，用于测试字符串是否形成完整的SQL语句。如果&lt;b&gt;sqlite_complete&lt;/b&gt;函数的输入为字符串时返回true，则该参数形成完整的SQL语句。不能保证该语句的语法正确，但是我们至少知道该语句是完整的。如果&lt;b&gt;sqlite_complete&lt;/b&gt;返回false，则需要更多文本来完成SQL语句。</target>
        </trans-unit>
        <trans-unit id="c0fe3b1ebf5cdcafa2a519a22d91d50cf98645d3" translate="yes" xml:space="preserve">
          <source>The next step in a multi-file commit is the creation of a &quot;master journal&quot; file. The name of the master journal file is the same name as the original database filename (the database that was opened using the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; interface, not one of the &lt;a href=&quot;lang_attach&quot;&gt;ATTACHed&lt;/a&gt; auxiliary databases) with the text &quot;&lt;b&gt;-mj&lt;/b&gt;</source>
          <target state="translated">多文件提交的下一步是创建&amp;ldquo;主日志&amp;rdquo;文件。主日志文件的名称与原始数据库文件名（使用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;接口打开的数据库，不是&lt;a href=&quot;lang_attach&quot;&gt;ATTACHed&lt;/a&gt;辅助数据库之一）打开的文本&lt;b&gt;名称相同&lt;/b&gt;，且文本为&amp;ldquo; &lt;b&gt;-mj&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0cd61740e94e70cec25ceb66f34763d5696dff28" translate="yes" xml:space="preserve">
          <source>The next step in a multi-file commit is the creation of a &quot;super-journal&quot; file. The name of the super-journal file is the same name as the original database filename (the database that was opened using the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; interface, not one of the &lt;a href=&quot;lang_attach&quot;&gt;ATTACHed&lt;/a&gt; auxiliary databases) with the text &quot;&lt;b&gt;-mj&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3da089b39e9e2681938268cb3d32b250cde300bb" translate="yes" xml:space="preserve">
          <source>The next step is to delete the master journal file. This is the point where the multi-file transaction commits. This step corresponds to &lt;a href=&quot;#section_3_11&quot;&gt;step 3.11&lt;/a&gt; in the single-file commit scenario where the rollback journal is deleted.</source>
          <target state="translated">下一步是删除主日记文件。这就是提交多文件事务的地方。在删除回滚日志的单文件提交方案中，此步骤对应于&lt;a href=&quot;#section_3_11&quot;&gt;步骤3.11&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8eca8d6f0301fd62dd1a522a60a7179d3923b8b3" translate="yes" xml:space="preserve">
          <source>The next step is to delete the super-journal file. This is the point where the multi-file transaction commits. This step corresponds to &lt;a href=&quot;#section_3_11&quot;&gt;step 3.11&lt;/a&gt; in the single-file commit scenario where the rollback journal is deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f8a36a95656f30638f07c12cb9da14410f8f263" translate="yes" xml:space="preserve">
          <source>The next step is to flush the content of the rollback journal file to nonvolatile storage. As we will see later, this is a critical step in insuring that the database can survive an unexpected power loss. This step also takes a lot of time, since writing to nonvolatile storage is normally a slow operation.</source>
          <target state="translated">下一步是将回滚日志文件的内容刷新到非易失性存储中。正如我们稍后将看到的那样,这是保证数据库能够在意外断电的情况下生存的关键一步。这一步也需要大量的时间,因为向非易失性存储中写入内容通常是一个缓慢的操作。</target>
        </trans-unit>
        <trans-unit id="2d76b37ca4cb1c2c8f635e9aaada12e5312b553c" translate="yes" xml:space="preserve">
          <source>The next step is to move the changes in the public branch over into the private branch. In other words, we want to create circle (5) in the diagram above. Begin by changing to the private branch using &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot;. Then type this command:</source>
          <target state="translated">下一步是将公共分支中的更改移到私有分支中。换句话说，我们要在上图中创建圆（5）。首先使用&amp;ldquo; &lt;code&gt;fossil update private&lt;/code&gt; &amp;rdquo; 更改为私有分支。然后键入以下命令：</target>
        </trans-unit>
        <trans-unit id="7e4259fddae0dc878cdf5dde573b08c0dee99991" translate="yes" xml:space="preserve">
          <source>The next step is to record the full pathname of the master journal file in the header of every rollback journal. Space to hold the master journal filename was reserved at the beginning of each rollback journal as the rollback journals were created.</source>
          <target state="translated">下一步是将主日志文件的完整路径名记录在每个回滚日志的页眉中。在创建回滚日记本时,每个回滚日记本的开头都预留了存放主日记本文件名的空间。</target>
        </trans-unit>
        <trans-unit id="75cf4af1420a93693d3db893fcca12c3f40102cd" translate="yes" xml:space="preserve">
          <source>The next step is to record the full pathname of the super-journal file in the header of every rollback journal. Space to hold the super-journal filename was reserved at the beginning of each rollback journal as the rollback journals were created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10799d0f2a52185a80b7f98059fdd7fef8ba0412" translate="yes" xml:space="preserve">
          <source>The next three bytes in the header record the number of vertexes in the polygon as a big-endian integer. Thus there is an upper bound of about 16 million vertexes per polygon.</source>
          <target state="translated">头部的三个字节记录了多边形中的顶点数量,是一个大安字节的整数,因此每个多边形的顶点数量上限是1600万。因此,每个多边形的顶点数上限为1600万。</target>
        </trans-unit>
        <trans-unit id="a4532dd188d90322b7de7cb35c04fd5fcf2e6593" translate="yes" xml:space="preserve">
          <source>The next use of the &lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt; or &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; or &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; instruction for P1 will refer to the first entry in the database table or index. If the table or index is empty, jump immediately to P2. If the table or index is not empty, fall through to the following instruction.</source>
          <target state="translated">P1 的&lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt;或&lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt;或&lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;指令的下一次使用将引用数据库表或索引中的第一个条目。如果表或索引为空，请立即跳至P2。如果表或索引不为空，请执行以下指令。</target>
        </trans-unit>
        <trans-unit id="db275badbcaa5bbb5c1ecd5830883705763b811b" translate="yes" xml:space="preserve">
          <source>The next use of the &lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt; or &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; or &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; instruction for P1 will refer to the last entry in the database table or index. If the table or index is empty and P2&amp;gt;0, then jump immediately to P2. If P2 is 0 or if the table or index is not empty, fall through to the following instruction.</source>
          <target state="translated">P1 的&lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt;或&lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt;或&lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;指令的下一次使用将引用数据库表或索引中的最后一个条目。如果表或索引为空并且P2&amp;gt; 0，则立即跳转到P2。如果P2为0，或者表或索引不为空，请执行以下指令。</target>
        </trans-unit>
        <trans-unit id="971bdad47f863dca0857c6853816fdb36613779f" translate="yes" xml:space="preserve">
          <source>The no-op memory allocator is not useful by itself. It exists only as a placeholder so that SQLite has a memory allocator to link against on systems that may not have malloc(), free(), or realloc() in their standard library. An application that is compiled with &lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt; will need to use &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; together with &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; or &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; to specify a new alternative memory allocator before beginning to use SQLite.</source>
          <target state="translated">无操作内存分配器本身没有用。它仅作为占位符存在，因此SQLite可以在其标准库中可能没有malloc（），free（）或realloc（）的系统上链接一个内存分配器。在开始使用SQLite之前，使用&lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt;编译的应用程序将需要与&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;或&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;一起使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;来指定新的备用内存分配器。</target>
        </trans-unit>
        <trans-unit id="fa03e3271f78c25f5482177efc3b575ee4cb93ab" translate="yes" xml:space="preserve">
          <source>The nolock query parameter is a boolean that disables all calls to the xLock, xUnlock, and xCheckReservedLock methods of the VFS when true. The nolock query parameter might be used, for example, when trying to access a file on a filesystem that does not support file locking. Caution: If two or more &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; try to interact with the same SQLite database and one or more of those connections has enabled &quot;nolock&quot;, then database corruption can result. The &quot;nolock&quot; query parameter should only be used if the application can guarantee that writes to the database are serialized.</source>
          <target state="translated">nolock查询参数是一个布尔值，当为true时，它将禁用对VFS的xLock，xUnlock和xCheckReservedLock方法的所有调用。例如，当尝试访问不支持文件锁定的文件系统上的文件时，可以使用nolock查询参数。警告：如果两个或多个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;尝试与同一个SQLite数据库进行交互，并且其中一个或多个连接启用了&amp;ldquo; nolock&amp;rdquo;，则可能导致数据库损坏。仅当应用程序可以保证对数据库的写操作已序列化时，才应使用&amp;ldquo; nolock&amp;rdquo;查询参数。</target>
        </trans-unit>
        <trans-unit id="b327cb7b48d6db3fd953f98055ad0798aba25bf9" translate="yes" xml:space="preserve">
          <source>The normal ROWID selection algorithm described above will generate monotonically increasing unique ROWIDs as long as you never use the maximum ROWID value and you never delete the entry in the table with the largest ROWID. If you ever delete rows or if you ever create a row with the maximum possible ROWID, then ROWIDs from previously deleted rows might be reused when creating new rows and newly created ROWIDs might not be in strictly ascending order.</source>
          <target state="translated">只要你从不使用最大的ROWID值,也从不删除表中具有最大ROWID的条目,上面描述的正常ROWID选择算法就会产生单调增加的唯一ROWID。如果你曾经删除过行,或者你曾经用最大可能的ROWID创建过行,那么在创建新行时,以前删除的行的ROWID可能会被重新使用,而且新创建的ROWID可能不会严格按照升序排列。</target>
        </trans-unit>
        <trans-unit id="dd6fdcceb1d1ed51baa294f01d457a9007d5dbff" translate="yes" xml:space="preserve">
          <source>The notindexed= option is not available. Adding &lt;a href=&quot;fts5#the_unindexed_column_option&quot;&gt;UNINDEXED&lt;/a&gt; to the column definition is equivalent.</source>
          <target state="translated">notindexed =选项不可用。将&lt;a href=&quot;fts5#the_unindexed_column_option&quot;&gt;UNINDEXED&lt;/a&gt;添加到列定义是等效的。</target>
        </trans-unit>
        <trans-unit id="e15aca005b3d3fc4e0be53d1a5e363f5a459da35" translate="yes" xml:space="preserve">
          <source>The nullif(X,Y) function returns its first argument if the arguments are different and NULL if the arguments are the same. The nullif(X,Y) function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If neither argument to nullif() defines a collating function then the BINARY is used.</source>
          <target state="translated">如果参数不同,nullif(X,Y)函数返回第一个参数,如果参数相同,则返回NULL。nullif(X,Y)函数从左到右搜索它的参数,寻找一个定义了整理函数的参数,并使用这个整理函数进行所有的字符串比较。如果nullif()的两个参数都没有定义整理函数,则使用BINARY。</target>
        </trans-unit>
        <trans-unit id="0d33dbf967cc9fffb2bcf5f7dd0e676a56e0fe27" translate="yes" xml:space="preserve">
          <source>The number of arguments to a function is sometimes stored in a signed character. So there is a hard upper bound on SQLITE_MAX_FUNCTION_ARG of 127.</source>
          <target state="translated">一个函数的参数数有时会用一个符号字符来存储。所以SQLITE_MAX_FUNCTION_ARG有一个硬性的上限,为127。</target>
        </trans-unit>
        <trans-unit id="22855456991124f9a63a13f70b4de30a07b1a44f" translate="yes" xml:space="preserve">
          <source>The number of characters in cFrom and cTo do not need to be the same. The rule above says that &quot;ss&quot; on user input will match &quot;&amp;szlig;&quot; with a penalty of 8.</source>
          <target state="translated">cFrom和cTo中的字符数不必相同。上面的规则说，用户输入上的&amp;ldquo; ss&amp;rdquo;将与&amp;ldquo;&amp;szlig;&amp;rdquo;匹配，惩罚为8。</target>
        </trans-unit>
        <trans-unit id="1dc8b6de1e412ad3d4600fff75a5432b18cfae89" translate="yes" xml:space="preserve">
          <source>The number of columns in a table</source>
          <target state="translated">表格中的列数</target>
        </trans-unit>
        <trans-unit id="c449227bed7d73e21c9772a435303abb6080e61e" translate="yes" xml:space="preserve">
          <source>The number of columns in a table is limited by the &lt;a href=&quot;limits#max_column&quot;&gt;SQLITE_MAX_COLUMN&lt;/a&gt; compile-time parameter. A single row of a table cannot store more than &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; bytes of data. Both of these limits can be lowered at runtime using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; C/C++ interface.</source>
          <target state="translated">表中的列数受&lt;a href=&quot;limits#max_column&quot;&gt;SQLITE_MAX_COLUMN&lt;/a&gt;编译时参数的限制。表的一行不能存储超过&lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;个字节的数据。使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit（）&lt;/a&gt; C / C ++接口可以在运行时降低这两个限制。</target>
        </trans-unit>
        <trans-unit id="8a6392262a1b2aadeab5c7954067326f2acb3a1d" translate="yes" xml:space="preserve">
          <source>The number of columns in a view</source>
          <target state="translated">视图中的列数</target>
        </trans-unit>
        <trans-unit id="7da1c90b5d954b64a1a4a566749d8c554741462e" translate="yes" xml:space="preserve">
          <source>The number of columns in an index</source>
          <target state="translated">索引中的列数</target>
        </trans-unit>
        <trans-unit id="155a4bbdc3161555e0a5db3b049b1a9960793a80" translate="yes" xml:space="preserve">
          <source>The number of columns in each row returned by the SELECT statement (if any) and the specific values returned have no effect on the results of the EXISTS operator. In particular, rows containing NULL values are not handled any differently from rows without NULL values.</source>
          <target state="translated">SELECT语句返回的每行中的列数(如果有的话)和返回的具体值对EXISTS操作符的结果没有影响。特别是,包含NULL值的行与不包含NULL值的行的处理方式没有任何区别。</target>
        </trans-unit>
        <trans-unit id="b33773d9bb8fcd548b7aa9142e9dd252802d3ebf" translate="yes" xml:space="preserve">
          <source>The number of columns in the result set of a SELECT statement</source>
          <target state="translated">SELECT语句的结果集中的列数。</target>
        </trans-unit>
        <trans-unit id="5962dbc1c4fa716686ee3f9c370159a83fff2488" translate="yes" xml:space="preserve">
          <source>The number of columns in the rows returned by a simple SELECT statement is equal to the number of expressions in the result expression list after substitution of * and alias.* expressions. Each result row is calculated by evaluating the expressions in the result expression list with respect to a single row of input data or, for aggregate queries, with respect to a group of rows.</source>
          <target state="translated">一个简单的SELECT语句返回的行中的列数等于结果表达式列表中替换*和别名.*表达式后的表达式数。每条结果行都是通过评估结果表达式列表中关于单行输入数据的表达式来计算的,或者,对于汇总查询来说,是关于一组行的表达式。</target>
        </trans-unit>
        <trans-unit id="efcaef0127aaba4759abf4c43138ceabba69a62b" translate="yes" xml:space="preserve">
          <source>The number of columns in the table, and</source>
          <target state="translated">表中的列数,以及</target>
        </trans-unit>
        <trans-unit id="ec4b9441464f8df5d1135d79fc696ff2d27c10ef" translate="yes" xml:space="preserve">
          <source>The number of columns the table has, and</source>
          <target state="translated">表的列数,以及</target>
        </trans-unit>
        <trans-unit id="f71fcd9bd24f5e705202e8ea9d15f75d827b7073" translate="yes" xml:space="preserve">
          <source>The number of entries in the write-ahead log (WAL) file for that database</source>
          <target state="translated">该数据库的写前日志(WAL)文件中的条目数。</target>
        </trans-unit>
        <trans-unit id="146718a82c006ef871da6bc05817a225f7435b26" translate="yes" xml:space="preserve">
          <source>The number of fields in this row.</source>
          <target state="translated">本行的字段数。</target>
        </trans-unit>
        <trans-unit id="049187119aa733be135d042e46c0767e81dbbd57" translate="yes" xml:space="preserve">
          <source>The number of freelist pages is stored as a 4-byte big-endian integer in the database header at an offset of 36 from the beginning of the file. The database header also stores the page number of the first freelist trunk page as a 4-byte big-endian integer at an offset of 32 from the beginning of the file.</source>
          <target state="translated">自由列表的页数在数据库头中以4字节的大字节整数形式存储,偏移量为36,从文件的开头开始。数据库头也将第一个自由列表主干页的页数作为一个4字节的大字节整数存储在文件开头的32个偏移量中。</target>
        </trans-unit>
        <trans-unit id="297412af9b640397abb6b05573031f719033bedb" translate="yes" xml:space="preserve">
          <source>The number of matchable phrases in the query.</source>
          <target state="translated">查询中可匹配的短语数量。</target>
        </trans-unit>
        <trans-unit id="96242742547a237955f6f616dd7a1536e46de1dc" translate="yes" xml:space="preserve">
          <source>The number of open read-transactions on the shared-cache drops to zero.</source>
          <target state="translated">共享缓存上开放的读交易数量降为零。</target>
        </trans-unit>
        <trans-unit id="140866849ab31e765e1dcf46dadf93357615ced1" translate="yes" xml:space="preserve">
          <source>The number of registers in a single prepared statement is fixed at compile-time. The content of all registers is cleared when a prepared statement is &lt;a href=&quot;c3ref/reset&quot;&gt;reset&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt;.</source>
          <target state="translated">单个准备好的语句中的寄存器数量在编译时是固定的。当&lt;a href=&quot;c3ref/reset&quot;&gt;重置&lt;/a&gt;或&lt;a href=&quot;c3ref/finalize&quot;&gt;结束&lt;/a&gt;准备好的语句时，将清除所有寄存器的内容。</target>
        </trans-unit>
        <trans-unit id="4967dccc017338cead0491dfe60a2adb347e1af4" translate="yes" xml:space="preserve">
          <source>The number of rows in a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES clause&lt;/a&gt; is no longer limited by &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_select#values&quot;&gt;VALUES子句中&lt;/a&gt;的行数不再受&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT的&lt;/a&gt;限制。</target>
        </trans-unit>
        <trans-unit id="36747c7623716448e27a5f87c9f1a06587b9fa71" translate="yes" xml:space="preserve">
          <source>The number of rows in the FTS4 table. This value is only available when querying FTS4 tables, not FTS3.</source>
          <target state="translated">FTS4表中的行数。该值仅在查询FTS4表时可用,而非FTS3表。</target>
        </trans-unit>
        <trans-unit id="e61b9ea13ff6553c9d51a6610c8145f4cf2adbcc" translate="yes" xml:space="preserve">
          <source>The number of rows in the FTS5 table for which column $col contains at least one instance of the term.</source>
          <target state="translated">FTS5表中$col列至少包含一个术语实例的行数。</target>
        </trans-unit>
        <trans-unit id="05c84b067bb80eadabe7075383b96e16df1c5aad" translate="yes" xml:space="preserve">
          <source>The number of rows that contain at least one instance of the term.</source>
          <target state="translated">至少包含一个术语实例的行数。</target>
        </trans-unit>
        <trans-unit id="32422ea0ce2f612eaf439b2072fddd2d97242e6b" translate="yes" xml:space="preserve">
          <source>The number of system calls for filesystem operations is reduced, possibly resulting in a small performance increase.</source>
          <target state="translated">减少了系统对文件系统操作的调用次数,可能导致性能小幅提升。</target>
        </trans-unit>
        <trans-unit id="e6551507f016b4d4b5fee98e7304b5666b04c04e" translate="yes" xml:space="preserve">
          <source>The number of terms in a GROUP BY or ORDER BY clause</source>
          <target state="translated">GROUP BY或ORDER BY子句中术语的数量。</target>
        </trans-unit>
        <trans-unit id="1c91b565cbe9942030a8129bf45c560b0a7de90f" translate="yes" xml:space="preserve">
          <source>The number of terms in the SET clause of an UPDATE statement</source>
          <target state="translated">UPDATE语句的SET子句中的术语数。</target>
        </trans-unit>
        <trans-unit id="70c8732a507183c03eb179514303045a0317c738" translate="yes" xml:space="preserve">
          <source>The number of the current row's peer group within its partition - the rank of the current row without gaps. Partitions are numbered starting from 1 in the order defined by the ORDER BY clause in the window definition. If there is no ORDER BY clause, then all rows are considered peers and this function always returns 1.</source>
          <target state="translated">当前行的对等组在其分区内的编号--当前行的等级,没有空隙。分区按照窗口定义中的ORDER BY子句定义的顺序从1开始编号。如果没有ORDER BY子句,那么所有的行都被认为是对等组,这个函数总是返回1。</target>
        </trans-unit>
        <trans-unit id="19450a48e3be402fdbd06d100d558662cd52a063" translate="yes" xml:space="preserve">
          <source>The number of the row within the current partition. Rows are numbered starting from 1 in the order defined by the ORDER BY clause in the window definition, or in arbitrary order otherwise.</source>
          <target state="translated">当前分区中行的编号。按照窗口定义中的ORDER BY子句定义的顺序,从1开始给行编号,否则按照任意顺序编号。</target>
        </trans-unit>
        <trans-unit id="4dd0d77e2a923847446dbf60b3f48736890bd6ba" translate="yes" xml:space="preserve">
          <source>The number of user defined columns in the FTS table (i.e. not including the docid or the &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt;).</source>
          <target state="translated">FTS表中用户定义的列数（即，不包括docid或&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS隐藏列&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ec04163c2280ea8f1f3a4d1db55ac34599bd6c09" translate="yes" xml:space="preserve">
          <source>The number of values in an INSERT statement</source>
          <target state="translated">INSERT语句中的值的数量</target>
        </trans-unit>
        <trans-unit id="0c5896381d0db64fdbbf15f25aac8c07347171d8" translate="yes" xml:space="preserve">
          <source>The numbered list above notes that the data for the first page of the database file, if it exists and is not already loaded into the</source>
          <target state="translated">上面的编号列表中指出,如果数据库文件的第一页数据存在,而且还没有加载到</target>
        </trans-unit>
        <trans-unit id="57671fab77edd8c578d7c9204ffe057965cc804a" translate="yes" xml:space="preserve">
          <source>The numbers here have become meaningless. This page has been retained only as an historical artifact.</source>
          <target state="translated">这里的数字已经变得毫无意义。本页仅作为历史文物保留。</target>
        </trans-unit>
        <trans-unit id="dde5b38271f3bab6f5848df944b4001a9705e033" translate="yes" xml:space="preserve">
          <source>The numbers on the left are the CPU cycle counts for that line of code, of course.</source>
          <target state="translated">当然,左边的数字是该行代码的CPU周期数。</target>
        </trans-unit>
        <trans-unit id="a08476269382d9cd02770e2cab87ae0ab5a527b0" translate="yes" xml:space="preserve">
          <source>The object is deleted using a call to sqlite3changegroup_delete().</source>
          <target state="translated">使用调用sqlite3changegroup_delete()删除该对象。</target>
        </trans-unit>
        <trans-unit id="5ae7075075a940fc9e83c06d49e89ed478d0bf99" translate="yes" xml:space="preserve">
          <source>The one-byte flag at offset 0 indicating the b-tree page type.</source>
          <target state="translated">偏移量0的一个字节标志,表示b树的页面类型。</target>
        </trans-unit>
        <trans-unit id="8ef8e17609c1f629f28fe60dfd6c0e8997843e40" translate="yes" xml:space="preserve">
          <source>The one-byte integer at offset 7 gives the number of fragmented free bytes within the cell content area.</source>
          <target state="translated">偏移量7处的一字节整数给出了单元内容区域内碎片化的自由字节数。</target>
        </trans-unit>
        <trans-unit id="729502a2e01c1766734981063a90830e318512ca" translate="yes" xml:space="preserve">
          <source>The online backup API is &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;documented here&lt;/a&gt;. The remainder of this page contains two C language examples illustrating common uses of the API and discussions thereof. Reading these examples is no substitute for reading the API documentation!</source>
          <target state="translated">在线备份API &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;在此处记录&lt;/a&gt;。该页面的其余部分包含两个C语言示例，这些示例说明了API的常见用法及其讨论。阅读这些示例不能代替阅读API文档！</target>
        </trans-unit>
        <trans-unit id="0ca3b9f46f696e6082e6b7a829be81ef745b8e77" translate="yes" xml:space="preserve">
          <source>The only SQLite compile-time option used was &lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt;. The optional &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; memory allocator is used for performance testing because it gives results that are more repeatable than the library-supplied malloc()/free() on Ubuntu.</source>
          <target state="translated">使用的唯一SQLite编译时选项是&lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt;。可选的&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;内存分配器用于性能测试，因为它提供的结果比Ubuntu上库提供的malloc（）/ free（）更具可重复性。</target>
        </trans-unit>
        <trans-unit id="89c13a55d3d11964427a1a5b2d10d0b78ec66565" translate="yes" xml:space="preserve">
          <source>The only compression algorithm supported is &lt;a href=&quot;https://zlib.net&quot;&gt;&quot;deflate&quot;&lt;/a&gt;.</source>
          <target state="translated">支持的唯一压缩算法是&lt;a href=&quot;https://zlib.net&quot;&gt;&amp;ldquo; deflate&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ecb1124fca00e2a69914563c0d3a9baa08011926" translate="yes" xml:space="preserve">
          <source>The only difference between the following two CASE expressions is that the</source>
          <target state="translated">以下两个CASE表达式的唯一区别是</target>
        </trans-unit>
        <trans-unit id="f71f4a9db1fb88c54de0203ce462454fe4edc774" translate="yes" xml:space="preserve">
          <source>The only difference is that the public sqlite3_XXX functions enumerated above silently ignore any invocations that pass a NULL pointer instead of a valid mutex handle. The implementations of the methods defined by this structure are not required to handle this case, the results of passing a NULL pointer instead of a valid mutex handle are undefined (i.e. it is acceptable to provide an implementation that segfaults if it is passed a NULL pointer).</source>
          <target state="translated">唯一不同的是,上面列举的公共sqlite3_XXX函数会默默地忽略任何传递一个NULL指针而不是有效的mutex句柄的调用。这个结构所定义的方法的实现不需要处理这种情况,传递NULL指针而不是有效的mutex句柄的结果是未定义的(也就是说,如果传递了一个NULL指针,提供一个segfaults的实现是可以接受的)。</target>
        </trans-unit>
        <trans-unit id="9650a6c44a89db8ce8453af489933161fa10a223" translate="yes" xml:space="preserve">
          <source>The only difference is that the public sqlite3_XXX functions enumerated above silently ignore any invocations that pass a NULL pointer instead of a valid mutex handle. The implementations of the methods defined by this structure are not required to handle this case. The results of passing a NULL pointer instead of a valid mutex handle are undefined (i.e. it is acceptable to provide an implementation that segfaults if it is passed a NULL pointer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="927a15e9b9c9c5a21e0cad33a99f89864994a2c1" translate="yes" xml:space="preserve">
          <source>The only really hard part is step 1. You might want to start with an existing virtual table implementation and modify it to suit your needs. The &lt;a href=&quot;https://sqlite.org/src/dir?ci=trunk&amp;amp;type=tree&quot;&gt;SQLite source tree&lt;/a&gt; contains many virtual table implementations that are suitable for copying, including:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b216563d4489c23da5dd8ef7bbce7ce15447a023" translate="yes" xml:space="preserve">
          <source>The only really hard part is step 1. You might want to start with an existing virtual table implementation and modify it to suit your needs. There are several virtual table implementations in the SQLite source tree (for testing purposes). You might use one of those as a guide. Locate these test virtual table implementations by searching for &quot;sqlite3_create_module&quot;.</source>
          <target state="translated">唯一真正困难的部分是第1步。你可能想从一个现有的虚拟表实现开始,并根据你的需要修改它。在SQLite源代码树中有几个虚拟表的实现(用于测试目的)。你可以使用其中的一个作为指导。通过搜索 &quot;sqlite3_create_module &quot;找到这些测试虚拟表实现。</target>
        </trans-unit>
        <trans-unit id="6a54b4d13a6de9bd96883cd76ca40e5bd7dd1a4b" translate="yes" xml:space="preserve">
          <source>The only reasons for providing functions other than strftime() is for convenience and for efficiency.</source>
          <target state="translated">提供strftime()以外的函数的唯一原因是为了方便和提高效率。</target>
        </trans-unit>
        <trans-unit id="c64051b826835db581e8535aa4a8fb802f2e8d26" translate="yes" xml:space="preserve">
          <source>The only schema altering commands directly supported by SQLite are the &quot;&lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;rename table&lt;/a&gt;&quot;, &quot;&lt;a href=&quot;lang_altertable#altertabmvcol&quot;&gt;rename column&lt;/a&gt;&quot;, and &quot;&lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;add column&lt;/a&gt;&quot; commands shown above. However, applications can make other arbitrary changes to the format of a table using a simple sequence of operations. The steps to make arbitrary changes to the schema design of some table X are as follows:</source>
          <target state="translated">SQLite直接支持的唯一模式更改命令是上面显示的&amp;ldquo; &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;重命名表&lt;/a&gt; &amp;rdquo;，&amp;ldquo; &lt;a href=&quot;lang_altertable#altertabmvcol&quot;&gt;重命名列&lt;/a&gt; &amp;rdquo;和&amp;ldquo; &lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;添加列&lt;/a&gt; &amp;rdquo;命令。但是，应用程序可以使用简单的操作序列对表的格式进行其他任意更改。对某些表X的架构设计进行任意更改的步骤如下：</target>
        </trans-unit>
        <trans-unit id="a93c45a553bd489c541613e587314033dbb5442e" translate="yes" xml:space="preserve">
          <source>The only significant design decision that developers need to make is whether to use -Os (optimize for size) or -O6 (optimize for speed). The -O6 setting makes binaries that run about 2% or 3% faster, but which are also 66% larger. The performance here is measured by counting CPU cycles using cachegrind. I-cache misses are not considered in the analysis. If I-cache misses are considered, builds with -O6 might not be any faster than builds with -Os.</source>
          <target state="translated">开发者需要做的唯一重要的设计决策是使用-Os(优化大小)还是-O6(优化速度)。-O6的设置使得二进制文件的运行速度提高了大约2%或3%,但其体积也大了66%。这里的性能是通过使用cachegrind计算CPU周期来衡量的。在分析中不考虑I-cache misses。如果考虑到 I-cache 遗漏,使用 -O6 的构建可能不会比使用 -Os 的构建更快。</target>
        </trans-unit>
        <trans-unit id="67fcf151555c1f1738044349d853d4cc0820a67f" translate="yes" xml:space="preserve">
          <source>The only thing that is really new about the current example is the WHERE clause which is implemented by instructions at addresses 7 through 10. Instructions at address 7 and 8 push onto the stack the value of the &quot;one&quot; column from the table and the literal string &quot;H%&quot;. The &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt; instruction at address 9 pops these two values from the stack and pushes the result of the LIKE() function back onto the stack. The &lt;a href=&quot;opcode#IfNot&quot;&gt;IfNot&lt;/a&gt; instruction pops the top stack value and causes an immediate jump forward to the Next instruction if the top value was false (&lt;em&gt;not&lt;/em&gt; not like the literal string &quot;H%&quot;). Taking this jump effectively skips the callback, which is the whole point of the WHERE clause. If the result of the comparison is true, the jump is not taken and control falls through to the Callback instruction below.</source>
          <target state="translated">当前示例中唯一真正新颖的是WHERE子句，该子句由地址7到10的指令实现。地址7和8的指令将表和文字中的&amp;ldquo; one&amp;rdquo;列的值压入堆栈字符串&amp;ldquo; H％&amp;rdquo;。地址9处的&lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt;指令从堆栈中弹出这两个值，并将LIKE（）函数的结果推回堆栈中。在&lt;a href=&quot;opcode#IfNot&quot;&gt;如不方便&lt;/a&gt;指令弹出堆栈顶部的值，并导致立即跳跃式前进到下一条指令，如果顶部的值是假的（&lt;em&gt;不&lt;/em&gt;不像文字字符串&amp;ldquo; H％&amp;rdquo;）。有效地执行此跳转将跳过回调，这是WHERE子句的重点。如果比较结果为true，则不执行跳转，控制权落到下面的Callback指令中。</target>
        </trans-unit>
        <trans-unit id="7db0a106b3cc6051a669fd3768b87982a2f1bf0d" translate="yes" xml:space="preserve">
          <source>The only time this would ever be an issue is when you have a program using version 2.8.0 or later that crashes with an incomplete transaction, then you try to examine the database using version 2.7.6 or earlier. The 2.7.6 code will not be able to read the journal file and thus will not be able to rollback the incomplete transaction to restore the database.</source>
          <target state="translated">只有当你有一个使用2.8.0或更高版本的程序因不完整的事务而崩溃,然后你尝试使用2.7.6或更早的版本检查数据库时,才会出现这种情况。2.7.6版本的代码将无法读取日志文件,因此将无法回滚不完整事务来恢复数据库。</target>
        </trans-unit>
        <trans-unit id="3427e2677eb5693de36c8d23ded03f405a1417be" translate="yes" xml:space="preserve">
          <source>The only way that SQLite can know that the left-most columns of an index have many duplicate is if the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command has been run on the database. Without the results of ANALYZE, SQLite has to guess at the &quot;shape&quot; of the data in the table, and the default guess is that there are an average of 10 duplicates for every value in the left-most column of the index. But skip-scan only becomes profitable (it only gets to be faster than a full table scan) when the number of duplicates is about 18 or more. Hence, a skip-scan is never used on a database that has not been analyzed.</source>
          <target state="translated">SQLite知道索引的最左列有很多重复项的唯一方法是，是否已经在数据库上运行了&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令。没有ANALYZE的结果，SQLite必须猜测表中数据的&amp;ldquo;形状&amp;rdquo;，默认猜测是索引最左列中的每个值平均有10个重复项。但是，当重复项的数量大约为18或更多时，跳过扫描只会变得有利可图（它只会比全表扫描更快）。因此，从未对尚未分析的数据库使用跳过扫描。</target>
        </trans-unit>
        <trans-unit id="4470bf44a4ab413995e0a4a3db8d3df4a465f540" translate="yes" xml:space="preserve">
          <source>The opening and/or creating of the database file is deferred until the file is actually needed. This allows options and parameters, such as the native text representation and default page size, to be set using PRAGMA statements.</source>
          <target state="translated">数据库文件的打开和/或创建被推迟到实际需要该文件的时候。这允许使用PRAGMA语句设置选项和参数,如本地文本表示和默认页面大小。</target>
        </trans-unit>
        <trans-unit id="0fff8fde33861bc909ec1bcff7cb77c490217d5b" translate="yes" xml:space="preserve">
          <source>The operating system interface layer understands and tracks all five locking states described above. The pager module only tracks four of the five locking states. A PENDING lock is always just a temporary stepping stone on the path to an EXCLUSIVE lock and so the pager module does not track PENDING locks.</source>
          <target state="translated">操作系统接口层了解并跟踪上述所有五种锁定状态。寻呼机模块只跟踪五种锁定状态中的四种。待定锁永远只是通往专属锁的临时垫脚石,所以寻呼机模块不跟踪待定锁。</target>
        </trans-unit>
        <trans-unit id="6f69f5f3efa82abf10e6a8b25aaa02ea47607f29" translate="yes" xml:space="preserve">
          <source>The operating system must have a unified buffer cache in order for the memory-mapped I/O extension to work correctly, especially in situations where two processes are accessing the same database file and one process is using memory-mapped I/O while the other is not. Not all operating systems have a unified buffer cache. In some operating systems that claim to have a unified buffer cache, the implementation is buggy and can lead to corrupt databases.</source>
          <target state="translated">操作系统必须有统一的缓冲区缓存,内存映射的I/O扩展才能正常工作,特别是在两个进程访问同一个数据库文件,一个进程使用内存映射的I/O而另一个进程不使用的情况下。并非所有的操作系统都有统一的缓冲区缓存。在一些宣称有统一缓冲区缓存的操作系统中,其实现是有bug的,可能导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="2fef3a1777aac58cd8a21d6d8b1475aa38c4964a" translate="yes" xml:space="preserve">
          <source>The operations above can potentially cause vast changes the raw database file, and hence cause very different SHA1 hashes at the file level. But since the content represented in the database file is unchanged by these operations, the hash computed by dbhash is also unchanged.</source>
          <target state="translated">上面的操作有可能会导致原始数据库文件发生巨大的变化,从而在文件级造成截然不同的SHA1哈希。但由于数据库文件中所表示的内容在这些操作中是不变的,所以dbhash计算出的哈希值也是不变的。</target>
        </trans-unit>
        <trans-unit id="fa365bc2db1bf185a92f2d5ef6ff8250e55de644" translate="yes" xml:space="preserve">
          <source>The optimization that uses an index to quickly compute an aggregate min() or max() is extended to work with &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.</source>
          <target state="translated">使用索引来快速计算聚合min（）或max（）的优化已扩展为可&lt;a href=&quot;expridx&quot;&gt;用于表达式的索引&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0ff09fb1c0cc730867c7410dca6d8522dc6581b" translate="yes" xml:space="preserve">
          <source>The optimizer automatically inverts terms of the form &quot;expr OP column&quot; and makes other simplifications to the WHERE clause in an attempt to get as many WHERE clause terms into the form shown above as possible. The aConstraint[] array only reports WHERE clause terms that are relevant to the particular virtual table being queried.</source>
          <target state="translated">优化器会自动反转 &quot;expr OP列 &quot;形式的术语,并对WHERE子句进行其他简化,试图让尽可能多的WHERE子句进入上图所示的形式。aConstraint[]数组只报告与被查询的特定虚拟表相关的WHERE子句。</target>
        </trans-unit>
        <trans-unit id="3a8fb11a2c37159ec0832c94b1217f4e3525fc9f" translate="yes" xml:space="preserve">
          <source>The optimizer has more freedom to reorder tables in the FROM clause even in there are LEFT joins.</source>
          <target state="translated">优化器有更多的自由度来重新排列FROM子句中的表,即使在有LEFT连接的情况下。</target>
        </trans-unit>
        <trans-unit id="ed82314b13b2ea2beac78e23a61e927cbc2a784b" translate="yes" xml:space="preserve">
          <source>The optimizer will now scan tables in the reverse if doing so will satisfy an ORDER BY ... DESC clause.</source>
          <target state="translated">优化器现在会反向扫描表,如果这样做会满足ORDER BY ...DESC子句。</target>
        </trans-unit>
        <trans-unit id="8d9594a87362ce1971b7a9efe4bfc116ba95e426" translate="yes" xml:space="preserve">
          <source>The option</source>
          <target state="translated">该选项</target>
        </trans-unit>
        <trans-unit id="a17a0a84a2d535101cac8aa7214d0ca78303a13a" translate="yes" xml:space="preserve">
          <source>The option causes SQLite to omit its built-in operating system interfaces for Unix, Windows, and OS/2. The resulting library will have no default &lt;a href=&quot;c3ref/vfs&quot;&gt;operating system interface&lt;/a&gt;. Applications must use &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; to register an appropriate interface before using SQLite. Applications must also supply implementations for the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; and &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_end()&lt;/a&gt; interfaces. The usual practice is for the supplied &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; to invoke &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;. SQLite will automatically invoke &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; when it initializes.</source>
          <target state="translated">该选项使SQLite省略其针对Unix，Windows和OS / 2的内置操作系统接口。生成的库将没有默认的&lt;a href=&quot;c3ref/vfs&quot;&gt;操作系统接口&lt;/a&gt;。在使用SQLite之前，应用程序必须使用&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;注册适当的接口。应用程序还必须提供&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init（）&lt;/a&gt;和&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_end（）&lt;/a&gt;接口的实现。通常的做法是让提供的&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init（）&lt;/a&gt;调用&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;。 SQLite 初始化时将自动调用&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">可选的</target>
        </trans-unit>
        <trans-unit id="e154860c714282a196150a8b230c6746d885f55b" translate="yes" xml:space="preserve">
          <source>The optional &quot;</source>
          <target state="translated">可选的&quot;</target>
        </trans-unit>
        <trans-unit id="44528aeaa99ba557a8ba7b80ef11d6c589ba4953" translate="yes" xml:space="preserve">
          <source>The optional &quot;AS alias&quot; phrase provides an alternative name for the table into which content is being inserted. The alias name can be used within WHERE and SET clauses of the &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt;. If there is no &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;, then the alias is pointless, but also harmless.</source>
          <target state="translated">可选的&amp;ldquo; AS别名&amp;rdquo;短语为插入内容的表提供了备用名称。别名可以在&lt;a href=&quot;lang_upsert&quot;&gt;UPSERT的&lt;/a&gt; WHERE和SET子句中使用。如果没有&lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert子句&lt;/a&gt;，则别名是没有意义的，而且也是无害的。</target>
        </trans-unit>
        <trans-unit id="af3a99778493ef21555e9c9fa86a7e91b06e70d3" translate="yes" xml:space="preserve">
          <source>The optional &quot;OR</source>
          <target state="translated">可选的 &quot;OR</target>
        </trans-unit>
        <trans-unit id="20d5db3386f7bebafe75fa5cbd335d930edd4888" translate="yes" xml:space="preserve">
          <source>The optional EXCLUDE clause may take any of the following four forms:</source>
          <target state="translated">可选的排除条款可以采取以下四种形式中的任何一种:</target>
        </trans-unit>
        <trans-unit id="f5dad0eb12cbe81d01819ac36d3268610ba8edac" translate="yes" xml:space="preserve">
          <source>The optional IF EXISTS clause suppresses the error that would normally result if the table does not exist.</source>
          <target state="translated">可选的IF EXISTS子句抑制了表不存在时通常会产生的错误。</target>
        </trans-unit>
        <trans-unit id="5cb5d652a77ff38b54b62cd30fd9ed282bedd94d" translate="yes" xml:space="preserve">
          <source>The optional MASK argument is a bitmask of optimizations to perform:</source>
          <target state="translated">可选的 MASK 参数是要执行的优化的位掩码。</target>
        </trans-unit>
        <trans-unit id="6a52a350b8227e3f2c9ade5a4eb34242d4d7eced" translate="yes" xml:space="preserve">
          <source>The optional argument is the name of the schema or database to be serialized. The default value is &quot;main&quot;.</source>
          <target state="translated">可选参数是要序列化的模式或数据库的名称。默认值是 &quot;main&quot;。</target>
        </trans-unit>
        <trans-unit id="38da3cf28a52f4f6d620faa6e6cb2361f1cf4901" translate="yes" xml:space="preserve">
          <source>The optional expression that occurs in between the CASE keyword and the first WHEN keyword is called the &quot;base&quot; expression. There are two basic forms of the CASE expression: those with a base expression and those without.</source>
          <target state="translated">出现在CASE关键字和第一个WHEN关键字之间的可选表达式称为 &quot;基础 &quot;表达式。CASE表达式有两种基本形式:有基础表达式的和没有基础表达式的。</target>
        </trans-unit>
        <trans-unit id="4916a24a4905c950af19989b67424175234963da" translate="yes" xml:space="preserve">
          <source>The optional expression that occurs in between the CASE keyword and the first WHEN keyword is called the &quot;base&quot; expression. There are two fundamental forms of the CASE expression: those with a base expression and those without.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b46109c9ae9c950c43fe7007d16547e58baf09ab" translate="yes" xml:space="preserve">
          <source>The optional shared cache and memory management features that were introduced in version 3.3.0 can now be used across multiple threads within the same process. Formerly, these extensions only applied to database connections operating within a single thread.</source>
          <target state="translated">在3.3.0版本中引入的可选共享缓存和内存管理功能现在可以在同一进程中的多个线程中使用。以前,这些扩展只适用于在单个线程内运行的数据库连接。</target>
        </trans-unit>
        <trans-unit id="095e758e6c75bd1010500f9c5cbf1c0112ebeaf1" translate="yes" xml:space="preserve">
          <source>The order of evaluation of function arguments.</source>
          <target state="translated">函数参数的评估顺序。</target>
        </trans-unit>
        <trans-unit id="671d3f63e428cbeb09358473179412be4940924b" translate="yes" xml:space="preserve">
          <source>The order of keys in an index b-tree is determined by the sort order of the records that the keys represent. Record comparison progresses column by column. Columns of a record are examined from left to right. The first pair of columns that are not equal determines the relative order of the two records. The sort order of individual columns is as follows:</source>
          <target state="translated">索引b树中键的顺序是由键所代表的记录的排序顺序决定的。记录比较是逐列进行的。记录的列从左到右进行检查。第一对不相等的列决定了两条记录的相对顺序。各列的排序顺序如下。</target>
        </trans-unit>
        <trans-unit id="2b489797ae43740676c30370f9b2ea776aa65877" translate="yes" xml:space="preserve">
          <source>The order of tables in a join is adjusted automatically to make better use of indices</source>
          <target state="translated">自动调整连接中表的顺序,以便更好地利用索引。</target>
        </trans-unit>
        <trans-unit id="140f29de259bdc1e34708f12946df0112e292cdd" translate="yes" xml:space="preserve">
          <source>The order of the buffer pointer and buffer size parameters in the built-in snprintf() implementation is reversed from the order used in standard-library implementations.</source>
          <target state="translated">在内置的snprintf()实现中,缓冲区指针和缓冲区大小参数的顺序与标准库实现中使用的顺序是相反的。</target>
        </trans-unit>
        <trans-unit id="5e9268cc64b3aabab9ece14a89f94084ddd4b3cc" translate="yes" xml:space="preserve">
          <source>The order of the columns in the data_% table does not matter.</source>
          <target state="translated">data_%表中各列的顺序并不重要。</target>
        </trans-unit>
        <trans-unit id="b1b615b19c9501777b15d4388be1e80320f4db76" translate="yes" xml:space="preserve">
          <source>The order of the entries indicates the nesting order. In this case, the scan of table t1 using index i2 is the outer loop (since it appears first) and the full-table scan of table t2 is the inner loop (since it appears last). In the following example, the positions of t1 and t2 in the FROM clause of the SELECT are reversed. The query strategy remains the same. The output from EXPLAIN QUERY PLAN shows how the query is actually evaluated, not how it is specified in the SQL statement.</source>
          <target state="translated">条目的顺序表示嵌套顺序。在本例中,使用索引i2对表t1的扫描是外循环(因为它最先出现),对表t2的全表扫描是内循环(因为它最后出现)。在下面的例子中,SELECT的FROM子句中t1和t2的位置是相反的。查询策略保持不变。EXPLAIN QUERY PLAN的输出显示的是查询的实际评估方式,而不是SQL语句中指定的方式。</target>
        </trans-unit>
        <trans-unit id="70ac1e5ab36762649806ee198f0345318ef8e4bd" translate="yes" xml:space="preserve">
          <source>The orderByConsumed means that output from &lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;/&lt;a href=&quot;../vtab#xnext&quot;&gt;xNext&lt;/a&gt; will occur in the correct order to satisfy the ORDER BY clause so that no separate sorting step is required.</source>
          <target state="translated">orderByConsumed意味着&lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; / &lt;a href=&quot;../vtab#xnext&quot;&gt;xNext的&lt;/a&gt;输出将以正确的顺序出现，以满足ORDER BY子句，因此不需要单独的排序步骤。</target>
        </trans-unit>
        <trans-unit id="a4ee366293d58487c3c181ee97d4fddeec053e83" translate="yes" xml:space="preserve">
          <source>The orderByConsumed means that output from &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;/&lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; will occur in the correct order to satisfy the ORDER BY clause so that no separate sorting step is required.</source>
          <target state="translated">orderByConsumed意味着&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; / &lt;a href=&quot;vtab#xnext&quot;&gt;xNext的&lt;/a&gt;输出将以正确的顺序出现，以满足ORDER BY子句，因此不需要单独的排序步骤。</target>
        </trans-unit>
        <trans-unit id="361a689885e1ba1224dc1550da95ae3bd8151f01" translate="yes" xml:space="preserve">
          <source>The original UTF8 text of the vocabulary word</source>
          <target state="translated">词汇的UTF8原文。</target>
        </trans-unit>
        <trans-unit id="8f218b03066661856e3cf8a761cc5ae4bbd68ed0" translate="yes" xml:space="preserve">
          <source>The original document we put here was more of a &lt;a href=&quot;codeofethics&quot;&gt;Code of Ethics of the Project Founder&lt;/a&gt;. While we stand by those principles, they are not in line with the modern technical meaning of a Code of Conduct and have hence been renamed.</source>
          <target state="translated">我们放在这里的原始文档更多地是&lt;a href=&quot;codeofethics&quot;&gt;Project Founder的道德守则&lt;/a&gt;。尽管我们坚持这些原则，但它们不符合《行为准则》的现代技术含义，因此已被重命名。</target>
        </trans-unit>
        <trans-unit id="c32bb1620d101b8c498092185971e74a9cc27eb4" translate="yes" xml:space="preserve">
          <source>The original implementation of SQLite sought to follow &lt;a href=&quot;https://en.wikipedia.org/wiki/Robustness_principle&quot;&gt;Postel's Law&lt;/a&gt; which states in part &quot;Be liberal in what you accept&quot;. This used to be considered good design - that a system would accept dodgy inputs and try to do the best it could without complaining too much. But lately, people have come to realize that it is sometimes better to be strict in what you accept, so as to more easily find errors in the input.</source>
          <target state="translated">SQLite的原始实现试图遵循&lt;a href=&quot;https://en.wikipedia.org/wiki/Robustness_principle&quot;&gt;Postel法则&lt;/a&gt;，该法则部分规定&amp;ldquo;在所接受的内容中保持自由&amp;rdquo;。过去，这被认为是好的设计-系统可以接受狡猾的输入，并尽其所能地做到最好，而不会抱怨太多。但是最近，人们开始意识到有时最好严格接受您所接受的内容，以便更轻松地发现输入中的错误。</target>
        </trans-unit>
        <trans-unit id="faed9cec852456e57ebf990afb4cf1cac2f27e57" translate="yes" xml:space="preserve">
          <source>The original values for each modified field of the row.</source>
          <target state="translated">该行各修改字段的原始值。</target>
        </trans-unit>
        <trans-unit id="2a41f1df0018eecb7b908d40c9986e3b87989e32" translate="yes" xml:space="preserve">
          <source>The original values of any modified fields are omitted from UPDATE records.</source>
          <target state="translated">任何修改后的字段的原始值都会从UPDATE记录中省略。</target>
        </trans-unit>
        <trans-unit id="f1449473437f390f79738378e7abd93ce9be7fe0" translate="yes" xml:space="preserve">
          <source>The other advantage to using SQLite in place of ZIP is that the document can now be updated incrementally, without risk of corrupting the document if a power loss or other crash occurs in the middle of the update. (Remember that writes to &lt;a href=&quot;atomiccommit&quot;&gt;SQLite databases are atomic&lt;/a&gt;.) True, all the content is still kept in a single big XML file (&quot;content.xml&quot;) which must be completely rewritten if so much as a single character changes. But with SQLite, only that one file needs to change. The other 77 files in the repository can remain unaltered. They do not all have to be rewritten, which in turn makes &quot;File/Save&quot; run much faster and saves wear on SSDs.</source>
          <target state="translated">使用SQLite代替ZIP的另一个优点是，现在可以增量更新文档，而如果在更新过程中发生断电或其他崩溃，则不会损坏文档。 （请记住，写入&lt;a href=&quot;atomiccommit&quot;&gt;SQLite数据库是原子的&lt;/a&gt;。）确实，所有内容仍然保存在一个大的XML文件（&amp;ldquo; content.xml&amp;rdquo;）中，如果单个字符发生很大变化，则必须将其完全重写。但是，使用SQLite，只需更改一个文件即可。存储库中的其他77个文件可以保持不变。不必全部重写它们，从而使&amp;ldquo;文件/保存&amp;rdquo;运行得更快，并节省了SSD的磨损。</target>
        </trans-unit>
        <trans-unit id="ff8ed48a831b734ff6e1604276150ac99b9ac0e1" translate="yes" xml:space="preserve">
          <source>The other allowed parameters to sqlite3_mutex_alloc() (anything other than SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE) each return a pointer to a static preexisting mutex. Nine static mutexes are used by the current version of SQLite. Future versions of SQLite may add additional static mutexes. Static mutexes are for internal use by SQLite only. Applications that use SQLite mutexes should use only the dynamic mutexes returned by SQLITE_MUTEX_FAST or SQLITE_MUTEX_RECURSIVE.</source>
          <target state="translated">sqlite3_mutex_alloc()的其他允许参数(除了SQLITE_MUTEX_FAST和SQLITE_MUTEX_RECURSIVE以外的任何参数),每个参数都返回一个指向静态预存在的mutex的指针。当前版本的SQLite使用了九个静态互斥。未来版本的SQLite可能会添加更多的静态互斥。静态mutexes只供SQLite内部使用。使用SQLite mutexes的应用程序应该只使用由SQLITE_MUTEX_FAST或SQLITE_MUTEX_RECURSIVE返回的动态mutexes。</target>
        </trans-unit>
        <trans-unit id="e68942fbbde7b9568017891360f3a9246030e2a2" translate="yes" xml:space="preserve">
          <source>The other file, &quot;fts5.h&quot;, is not required to compile the FTS5 extension. It is used by applications that implement &lt;a href=&quot;fts5#extending_fts5&quot;&gt;custom FTS5 tokenizers or auxiliary functions&lt;/a&gt;.</source>
          <target state="translated">不需要另一个文件&amp;ldquo; fts5.h&amp;rdquo;来编译FTS5扩展名。由实现&lt;a href=&quot;fts5#extending_fts5&quot;&gt;自定义FTS5标记程序或辅助功能&lt;/a&gt;的应用程序使用。</target>
        </trans-unit>
        <trans-unit id="f74c4fa3b3502ec3d363778205dc40519edfac8e" translate="yes" xml:space="preserve">
          <source>The other information required to create a changeset or patchset is read from the database file when &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; or &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset()&lt;/a&gt; is called. Specifically,</source>
          <target state="translated">&lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;调用sqlite3session_changeset（）&lt;/a&gt;或&lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset（）&lt;/a&gt;时，将从数据库文件中读取创建变更集或补丁集所需的其他信息。特别，</target>
        </trans-unit>
        <trans-unit id="4ceb7a7a69cfd1205ea5e7612f272fc9e42d8423" translate="yes" xml:space="preserve">
          <source>The outer SELECT is implemented by instructions 11 through 25. In particular, the WHERE clause containing the IN operator is implemented by instructions at 16, 17, and 20. Instruction 16 pushes the value of the &quot;two&quot; column for the current row onto the stack and instruction 17 checks to see that it is non-NULL. If this is successful, execution jumps to 20, where it tests to see if top of the stack matches any key in the temporary table. The rest of the code is the same as what has been shown before.</source>
          <target state="translated">外层的SELECT是由指令11到25实现的。特别是包含IN操作符的WHERE子句由指令16、17和20实现。指令16将当前行的 &quot;二 &quot;列的值推到堆栈上,指令17检查它是否为非NULL。如果成功,执行跳转到20,在这里测试栈顶是否与临时表中的任何键相匹配。其余的代码与前面所展示的相同。</target>
        </trans-unit>
        <trans-unit id="636166e4ba0668356d630c0a9cb37eba4fcc8c00" translate="yes" xml:space="preserve">
          <source>The outer SELECT is implemented by instructions 14 through 25. In particular, the WHERE clause that contains the nested select is implemented by instructions 19 through 21. You can see that the result of the inner select is loaded onto the stack by instruction 20 and used by the conditional jump at 21.</source>
          <target state="translated">外层的select由指令14到25实现。特别是包含嵌套选择的WHERE子句由指令19到21实现。可以看到,内层选择的结果由指令20加载到堆栈中,并由21处的条件跳转使用。</target>
        </trans-unit>
        <trans-unit id="fcdaf6e60b18b913fe64114ea32692d007183ab8" translate="yes" xml:space="preserve">
          <source>The outer loop over table examp is implement by instructions 7 through 23. The inner loop is instructions 13 through 22. Notice that the &quot;two&amp;lt;50&quot; term of the WHERE expression involves only columns from the first table and can be factored out of the inner loop. SQLite does this and implements the &quot;two&amp;lt;50&quot; test in instructions 10 through 12. The &quot;four==two&quot; test is implement by instructions 14 through 16 in the inner loop.</source>
          <target state="translated">表examp的外部循环由指令7至23实现。内部循环由13至22指令实现。请注意，WHERE表达式的&amp;ldquo; two &amp;lt;50&amp;rdquo;术语仅涉及第一张表中的列，并且可以从内循环。SQLite这样做并在指令10到12中实现&amp;ldquo; two &amp;lt;50&amp;rdquo;测试。&amp;ldquo; four == two&amp;rdquo;测试由内部循环中的指令14到16实现。</target>
        </trans-unit>
        <trans-unit id="0e7b99d6dfc2b5d85e34f55e3ea4da579b189034" translate="yes" xml:space="preserve">
          <source>The output begins with a report of the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; (cross-checked again &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt;) for the SQLite under test and the compile-time options used as reported by &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get()&lt;/a&gt;. The output concludes with a summary of the test results and a repeat of the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;. If any errors are detected, additional lines detail the problem. The error reporting lines always begin with a single space character so that they can be quickly extracted from large output files using:</source>
          <target state="translated">输出以针对测试中的SQLite 的&lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;报告（再次交叉检查&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid（）&lt;/a&gt;）和&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get（）&lt;/a&gt;报告的编译时选项开始。输出以测试结果的摘要和&lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;的重复结尾。如果检测到任何错误，则其他行会详细说明问题。错误报告行始终以单个空格字符开头，以便可以使用以下命令从大型输出文件中快速提取它们：</target>
        </trans-unit>
        <trans-unit id="b2295d00e027ddb605dbb2cc9b7646825272b788" translate="yes" xml:space="preserve">
          <source>The output from EXPLAIN and EXPLAIN QUERY PLAN is intended for interactive analysis and troubleshooting only. The details of the output format are subject to change from one release of SQLite to the next. Applications should not use EXPLAIN or EXPLAIN QUERY PLAN since their exact behavior is variable and only partially documented.</source>
          <target state="translated">EXPLAIN 和 EXPLAIN QUERY PLAN 的输出仅用于交互式分析和故障排除。输出格式的细节会随着SQLite的不同版本而改变。应用程序不应该使用EXPLAIN或EXPLAIN QUERY PLAN,因为它们的确切行为是可变的,而且只有部分记录。</target>
        </trans-unit>
        <trans-unit id="235163a8fba9aa1445cd051f01c741ea66911c96" translate="yes" xml:space="preserve">
          <source>The output from the &lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;cg_anno.tcl&lt;/a&gt; script shows the number of CPU cycles spent on each line of code. The report is approximately 80,000 lines long. The following is a brief snippet taken from the middle of the report to show what it looks like:</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;cg_anno.tcl&lt;/a&gt;脚本的输出显示每行代码花费的CPU周期数。该报告大约有80,000行。以下是摘自报告中间的简短摘要，以显示其外观：</target>
        </trans-unit>
        <trans-unit id="4c55fd24704ccac9a200bb25fe01e36a7bd6347b" translate="yes" xml:space="preserve">
          <source>The output from the mkth3.tcl script is a C program that contains everything needed to run the tests - everything that is except for the SQLite library itself. The generated test program contains implementations for all of the support interfaces used by the test modules and it contains the &lt;code&gt;main()&lt;/code&gt; routine that drives the tests. To convert the test program into a working executable, simply compile it against SQLite:</source>
          <target state="translated">mkth3.tcl脚本的输出是一个C程序，其中包含运行测试所需的所有内容-除SQLite库本身以外的所有内容。生成的测试程序包含测试模块使用的所有支持接口的实现，并且包含驱动测试的 &lt;code&gt;main()&lt;/code&gt; 例程。要将测试程序转换为可运行的可执行文件，只需针对SQLite对其进行编译：</target>
        </trans-unit>
        <trans-unit id="abe6a29295e5add598505fe98eb212b9e3e6e910" translate="yes" xml:space="preserve">
          <source>The output is a human-readable ASCII text report that provides information on the space utilization of the database file. The report is intended to be self-explanatory, though there is some &lt;a href=&quot;sqlanalyze#defs&quot;&gt;additional explanation&lt;/a&gt; of the various parameters reported toward the end of the report.</source>
          <target state="translated">输出是人类可读的ASCII文本报告，该报告提供有关数据库文件空间利用率的信息。尽管对报告末尾所报告的各种参数还有一些&lt;a href=&quot;sqlanalyze#defs&quot;&gt;其他&lt;/a&gt;解释，但该报告的目的不言而喻。</target>
        </trans-unit>
        <trans-unit id="89607a5138078e5c86fca97ee25682b106679c11" translate="yes" xml:space="preserve">
          <source>The output is also valid SQL. Most of the report text is contained within a header comment, with various SQL statements that create and initialize a database at the &lt;a href=&quot;sqlanalyze#sqlx&quot;&gt;end of the report&lt;/a&gt;. The constructed database contains the raw data from which the report was extracted. Hence the original report can be read into an instance of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; and then the raw data can be queried to dig deeper into the space utilization of a particular database file.</source>
          <target state="translated">输出也是有效的SQL。报告的大部分文本都包含在标题注释中，&lt;a href=&quot;sqlanalyze#sqlx&quot;&gt;在报告末尾&lt;/a&gt;带有各种SQL语句，这些语句创建和初始化数据库。构建的数据库包含从中提取报告的原始数据。因此，可以将原始报告读入&lt;a href=&quot;cli&quot;&gt;命令行Shell&lt;/a&gt;的实例，然后可以查询原始数据以更深入地了解特定数据库文件的空间利用率。</target>
        </trans-unit>
        <trans-unit id="bcfd95781cb98e2851bb0886cd3f1a588c682428" translate="yes" xml:space="preserve">
          <source>The output of &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; now shows each individual SQL statement run within a trigger.</source>
          <target state="translated">&lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;的输出现在显示在触发器中运行的每个单独的SQL语句。</target>
        </trans-unit>
        <trans-unit id="2d09f331aa1d428bbd3337e80bd418ed5659e816" translate="yes" xml:space="preserve">
          <source>The output of this revised query is:</source>
          <target state="translated">这个修订后的查询结果是:</target>
        </trans-unit>
        <trans-unit id="e3541aa5b140ee88f1e6bb5e89e08e8618d880af" translate="yes" xml:space="preserve">
          <source>The outputs s0 and s1 are both weighted checksums using Fibonacci weights in reverse order. (The largest Fibonacci weight occurs on the first element of the sequence being summed.) The s1 value spans all 32-bit integer terms of the sequence whereas s0 omits the final term.</source>
          <target state="translated">输出s0和s1都是使用斐波那契权重的加权校验和,顺序相反。(最大的斐波那契权重出现在被求和的序列的第一个元素上。)s1的值涵盖了序列的所有32位整数项,而s0则省略了最后一项。s1的值涵盖了序列的所有32位整数项,而s0则省略了最后一项。</target>
        </trans-unit>
        <trans-unit id="2d1abc65d901f9a5d25ea3d57ab5dd49e8f85287" translate="yes" xml:space="preserve">
          <source>The overflow thresholds are designed to give a minimum fanout of 4 for index b-trees and to make sure enough of the payload is on the b-tree page that the record header can usually be accessed without consulting an overflow page. In hindsight, the designer of the SQLite b-tree logic realized that these thresholds could have been made much simpler. However, the computations cannot be changed without resulting in an incompatible file format. And the current computations work well, even if they are a little complex.</source>
          <target state="translated">溢出阈值的设计是为了给索引b树提供最小的扇出量为4,并确保b树页面上有足够多的有效载荷,通常不需要咨询溢出页面就可以访问记录头。事后,SQLite b-tree逻辑的设计者意识到,这些阈值可以做得更简单。但是,如果不改变计算方式,就不能导致文件格式不兼容。而目前的计算结果很好用,即使它们有点复杂。</target>
        </trans-unit>
        <trans-unit id="ac70d959175f460608260178c8989bd26b78e65e" translate="yes" xml:space="preserve">
          <source>The pAppData pointer is unused by the SQLite core. The pointer is available to store auxiliary information that a VFS information might want to carry around.</source>
          <target state="translated">pAppData指针不被SQLite核心使用。该指针可用于存储VFS信息可能想要携带的辅助信息。</target>
        </trans-unit>
        <trans-unit id="18730b00ae23b4c106f1118f96d5a509058fa368" translate="yes" xml:space="preserve">
          <source>The pBuf parameter is a pointer to a contiguous range of bytes that SQLite will use for page-cache memory allocations. The buffer must be at least sz*N bytes in size. The &quot;sz&quot; parameter is the size of each page-cache allocation. N is the maximum number of available allocations.</source>
          <target state="translated">pBuf参数是指向SQLite将用于页缓存内存分配的连续字节范围的指针。缓冲区的大小必须至少是sz*N字节。&quot;sz &quot;参数是每个页缓存分配的大小。N是可用分配的最大数量。</target>
        </trans-unit>
        <trans-unit id="ac154834d9f47915a3416a80860f0b58cefd5585" translate="yes" xml:space="preserve">
          <source>The pContext member of the sqlite3_rtree_geometry structure is always set to a copy of the pContext argument passed to sqlite3_rtree_geometry_callback() when the callback is registered. The aParam[] array (size nParam) contains the parameter values passed to the SQL function on the right-hand side of the MATCH operator. In the example &quot;circle&quot; query above, nParam would be set to 3 and the aParam[] array would contain the three values 45.3, 22.9 and 5.0.</source>
          <target state="translated">sqlite3_rtree_geometry结构的pContext成员总是被设置为回调注册时传递给sqlite3_rtree_geometry_callback()的pContext参数的副本。aParam[]数组(大小为nParam)包含了传递给MATCH操作符右侧SQL函数的参数值。在上面的 &quot;圆 &quot;查询示例中,nParam将被设置为3,而aParam[]数组将包含三个值45.3、22.9和5.0。</target>
        </trans-unit>
        <trans-unit id="e127dc3dcbbc20bee3b0cdc450a4bea7c1e6776f" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;. If this is not the case, this function returns &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;.</source>
          <target state="translated">传递给该功能的参数PITER可以是由传递给一个冲突处理程序的迭代器&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;）sqlite3changeset_apply（&lt;/a&gt;或通过创建一个迭代&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;（）sqlite3changeset_start&lt;/a&gt;。在后一种情况下，对&lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）的&lt;/a&gt;最新调用必须返回&lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;。如果不是这种情况，则此函数返回&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="135aebf5a9dd2b851dadacfebf43a14b9409aa81" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">传递给该功能的参数PITER可以是由传递给一个冲突处理程序的迭代器&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;）sqlite3changeset_apply（&lt;/a&gt;或通过创建一个迭代&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;（）sqlite3changeset_start&lt;/a&gt;。在后一种情况下，对&lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）的&lt;/a&gt;最新调用必须返回SQLITE_ROW。此外，仅当迭代器当前指向的更改类型是&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;或&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE时&lt;/a&gt;，才可以调用它。否则，此函数返回&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;并将* ppValue设置为NULL。</target>
        </trans-unit>
        <trans-unit id="47ae6763d58288a12e6ca470cf923677f0731f46" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">传递给该功能的参数PITER可以是由传递给一个冲突处理程序的迭代器&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;）sqlite3changeset_apply（&lt;/a&gt;或通过创建一个迭代&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;（）sqlite3changeset_start&lt;/a&gt;。在后一种情况下，对&lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）的&lt;/a&gt;最新调用必须返回SQLITE_ROW。此外，仅当迭代器当前指向的更改类型是&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;或&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT时&lt;/a&gt;，才可以调用它。否则，此函数返回&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;并将* ppValue设置为NULL。</target>
        </trans-unit>
        <trans-unit id="5f4815a3e637ae9700d2b5b8cf01f7df97a164dc" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;. If this is not the case, this function returns &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;.</source>
          <target state="translated">传递给该功能的参数PITER可以是由传递给一个冲突处理程序的迭代器&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;）sqlite3changeset_apply（&lt;/a&gt;或通过创建一个迭代&lt;a href=&quot;sqlite3changeset_start&quot;&gt;（）sqlite3changeset_start&lt;/a&gt;。在后一种情况下，对&lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）的&lt;/a&gt;最新调用必须返回&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;。如果不是这种情况，则此函数返回&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5cb49779aa9657ac4af96a2c62fd60bce7011cad" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">传递给该功能的参数PITER可以是由传递给一个冲突处理程序的迭代器&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;）sqlite3changeset_apply（&lt;/a&gt;或通过创建一个迭代&lt;a href=&quot;sqlite3changeset_start&quot;&gt;（）sqlite3changeset_start&lt;/a&gt;。在后一种情况下，对&lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）的&lt;/a&gt;最新调用必须返回SQLITE_ROW。此外，仅当迭代器当前指向的更改类型是&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;或&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE时&lt;/a&gt;，才可以调用它。否则，此函数返回&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;并将* ppValue设置为NULL。</target>
        </trans-unit>
        <trans-unit id="836812d109e0eaaadd1e45a40c1311bde5cb7d98" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; or &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">传递给该功能的参数PITER可以是由传递给一个冲突处理程序的迭代器&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;）sqlite3changeset_apply（&lt;/a&gt;或通过创建一个迭代&lt;a href=&quot;sqlite3changeset_start&quot;&gt;（）sqlite3changeset_start&lt;/a&gt;。在后一种情况下，对&lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）的&lt;/a&gt;最新调用必须返回SQLITE_ROW。此外，仅当迭代器当前指向的更改类型是&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;或&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT时&lt;/a&gt;，才可以调用它。否则，此函数返回&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;并将* ppValue设置为NULL。</target>
        </trans-unit>
        <trans-unit id="87ffccb080e4ff9265c31827b97ddd2621e463bc" translate="yes" xml:space="preserve">
          <source>The pNext field is the only field in the sqlite3_vfs structure that SQLite will ever modify. SQLite will only access or modify this field while holding a particular static mutex. The application should never modify anything within the sqlite3_vfs object once the object has been registered.</source>
          <target state="translated">pNext字段是sqlite3_vfs结构中唯一会被SQLite修改的字段。SQLite只有在持有一个特定的静态互斥时才会访问或修改这个字段。一旦sqlite3_vfs对象被注册,应用程序就不应该修改该对象中的任何内容。</target>
        </trans-unit>
        <trans-unit id="754388a17b97b997745df633f79a8efeaffaaacb" translate="yes" xml:space="preserve">
          <source>The pNext field is used internally by SQLite. Specifically, SQLite uses this field to form a linked list of registered VFSes.</source>
          <target state="translated">pNext字段由SQLite内部使用。具体来说,SQLite使用这个字段来形成一个注册VFSes的链接列表。</target>
        </trans-unit>
        <trans-unit id="ed269faa072ea0bc301321c2683b96864943c28b" translate="yes" xml:space="preserve">
          <source>The pUser and xDelUser members of the sqlite3_rtree_geometry structure are initially set to NULL. The pUser variable may be set by the callback implementation to any arbitrary value that may be useful to subsequent invocations of the callback within the same query (for example, a pointer to a complicated data structure used to test for region intersection). If the xDelUser variable is set to a non-NULL value, then after the query has finished running SQLite automatically invokes it with the value of the pUser variable as the only argument. In other words, xDelUser may be set to a destructor function for the pUser value.</source>
          <target state="translated">sqlite3_rtree_geometry结构的pUser和xDelUser成员最初被设置为NULL。pUser变量可以被回调实现设置为任何对同一查询中后续调用回调有用的任意值(例如,指向用于测试区域交叉的复杂数据结构的指针)。如果xDelUser变量被设置为非NULL值,那么在查询运行完毕后,SQLite会自动调用它,将pUser变量的值作为唯一的参数。换句话说,xDelUser可以被设置为pUser值的析构函数。</target>
        </trans-unit>
        <trans-unit id="17b3e72d28371d5d2ffa9ec67e0ffe035454e59f" translate="yes" xml:space="preserve">
          <source>The page cache allocates from its own memory pool supplied by &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;,...) rather than from the heap.</source>
          <target state="translated">页面缓存从&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;，...）提供的内存池中分配，而不是从堆中分配。</target>
        </trans-unit>
        <trans-unit id="c49923490f20015de5b3c1344ee709093d18e9ac" translate="yes" xml:space="preserve">
          <source>The page cache allocates from its own memory pool supplied by &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;,...) rather than from the heap.</source>
          <target state="translated">页面缓存从&lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;，...）提供的内存池中分配，而不是从堆中分配。</target>
        </trans-unit>
        <trans-unit id="a302370f325aa6580998e916c1cd813d2e0b53c6" translate="yes" xml:space="preserve">
          <source>The page number in the database file</source>
          <target state="translated">数据库文件中的页码</target>
        </trans-unit>
        <trans-unit id="cb3defd1f8ac1da0588e9ad79d27848df6931c39" translate="yes" xml:space="preserve">
          <source>The page number of the database page associated with this</source>
          <target state="translated">与此相关的数据库页面的页码。</target>
        </trans-unit>
        <trans-unit id="0780190de9ffbf4345610e2662e0abd5cdf52be0" translate="yes" xml:space="preserve">
          <source>The page number of the database page for the current row</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d2ed89da4b6a6d4a6521b481ff6c43d5bdf9213" translate="yes" xml:space="preserve">
          <source>The page number of the largest root b-tree page when in auto-vacuum or incremental-vacuum modes, or zero otherwise.</source>
          <target state="translated">当处于自动真空或增量真空模式时,最大的b树根页的页数,否则为零。</target>
        </trans-unit>
        <trans-unit id="9a28509eee63401403c2ae3763725cac2ca99893" translate="yes" xml:space="preserve">
          <source>The page number of the page on which this row was found.</source>
          <target state="translated">该行所在页面的页码。</target>
        </trans-unit>
        <trans-unit id="41b015c66ddae0dbc3440c640484bd01738dbaf6" translate="yes" xml:space="preserve">
          <source>The page size and cache size can also be set or changed at run-time using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size pragma&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size pragma&lt;/a&gt;, respectively.</source>
          <target state="translated">页面大小和缓存大小也可以在运行时分别使用&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size pragma&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size pragma&lt;/a&gt;进行设置或更改。</target>
        </trans-unit>
        <trans-unit id="0105846f7fbf6f81d53292a1128d1e82d5804983" translate="yes" xml:space="preserve">
          <source>The page to be fetched is determined by the key. The minimum key value is 1. After it has been retrieved using xFetch, the page is considered to be &quot;pinned&quot;.</source>
          <target state="translated">要检索的页面由键决定。最小键值为1,使用xFetch检索后,页面被视为 &quot;钉住&quot;。</target>
        </trans-unit>
        <trans-unit id="ae6ce89a0e7b046f1218400c05d873074d2788d0" translate="yes" xml:space="preserve">
          <source>The page-cache memory allocator is disabled by default. An application can enable it at start-time as follows:</source>
          <target state="translated">页缓存内存分配器默认是禁用的,应用程序可以在启动时启用它。应用程序可以在启动时启用它,具体如下。</target>
        </trans-unit>
        <trans-unit id="79944cfbe90583fe884c628acc92c56b549b69ab" translate="yes" xml:space="preserve">
          <source>The pager and btree subsystems added back. They are now the only available backend.</source>
          <target state="translated">寻呼机和btree子系统添加回来。它们现在是唯一可用的后台。</target>
        </trans-unit>
        <trans-unit id="177ac3877a5c726efa0192a81b9a621bfc8aa28e" translate="yes" xml:space="preserve">
          <source>The pager is unconcerned with the details of B-Trees, text encodings, indices, and so forth. From the point of view of the pager the database consists of a single file of uniform-sized blocks. Each block is called a &quot;page&quot; and is usually 1024 bytes in size. The pages are numbered beginning with 1. So the first 1024 bytes of the database are called &quot;page 1&quot; and the second 1024 bytes are call &quot;page 2&quot; and so forth. All other encoding details are handled by higher layers of the library. The pager communicates with the operating system using one of several modules (Examples: &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_unix.c&quot;&gt; os_unix.c&lt;/a&gt;, &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_win.c&quot;&gt; os_win.c&lt;/a&gt;) that provides a uniform abstraction for operating system services.</source>
          <target state="translated">寻呼机不关心B树，文本编码，索引等细节。从寻呼机的角度来看，数据库由一个统一大小的块文件组成。每个块称为&amp;ldquo;页面&amp;rdquo;，通常大小为1024字节。页面从1开始编号。因此数据库的前1024个字节称为&amp;ldquo;第1页&amp;rdquo;，后1024个字节称为&amp;ldquo;第2页&amp;rdquo;，依此类推。所有其他编码细节由库的更高层处理。寻呼机使用几个模块之一与操作系统进行通信（示例：&lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt;，&lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_win.c&quot;&gt;os_win.c&lt;/a&gt;），这些模块为操作系统服务提供统一的抽象。</target>
        </trans-unit>
        <trans-unit id="5acaa405b470e4fb9ef36344daf0f015a3d5bf69" translate="yes" xml:space="preserve">
          <source>The pager module effectively controls access for separate threads, or separate processes, or both. Throughout this document whenever the word &quot;process&quot; is written you may substitute the word &quot;thread&quot; without changing the truth of the statement.</source>
          <target state="translated">寻呼机模块有效地控制了单独的线程,或单独的进程,或两者的访问。在本文档中,每当写到 &quot;进程 &quot;一词时,你可以用 &quot;线程 &quot;来代替,而不改变声明的真实性。</target>
        </trans-unit>
        <trans-unit id="3fbaa9934c130eb17f7eada7403c9132c86bbc58" translate="yes" xml:space="preserve">
          <source>The pager module is very robust but it can be subverted. This section attempts to identify and explain the risks. (See also the &lt;a href=&quot;atomiccommit#sect_9_0&quot;&gt;Things That Can Go Wrong&lt;/a&gt; section of the article on &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit&lt;/a&gt;.</source>
          <target state="translated">寻呼机模块非常强大，但是可以被颠覆。本节试图识别和解释风险。（另请参阅&amp;ldquo; &lt;a href=&quot;atomiccommit&quot;&gt;原子提交&lt;/a&gt; &amp;rdquo;一文中的&lt;a href=&quot;atomiccommit#sect_9_0&quot;&gt;&amp;ldquo;可能出错的&lt;/a&gt;部分&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="0f15cdebe573fd03148e855390c11255190632e7" translate="yes" xml:space="preserve">
          <source>The paragraph above notes that a MATCH operator with a simple term as the right-hand operand evaluates to true for all documents that contain the specified term. In this context, the &quot;document&quot; may refer to either the data stored in a single column of a row of an FTS table, or to the contents of all columns in a single row, depending on the identifier used as the left-hand operand to the MATCH operator. If the identifier specified as the left-hand operand of the MATCH operator is an FTS table column name, then the document that the search term must be contained in is the value stored in the specified column. However, if the identifier is the name of the FTS</source>
          <target state="translated">上段指出,以一个简单术语作为右手操作数的MATCH操作符,对于所有包含指定术语的文档来说,评价为真。在此上下文中,&quot;文档 &quot;可以指存储在FTS表中一行的单列中的数据,也可以指单行中所有列的内容,这取决于用作MATCH操作符左手操作数的标识符。如果作为 MATCH 操作符的左手操作符指定的标识符是 FTS 表的列名,那么搜索词必须包含的文档就是存储在指定列中的值。但是,如果标识符是FTS表的名称,那么搜索词必须包含在指定的列中。</target>
        </trans-unit>
        <trans-unit id="15582287ef68bc76059b207ebd8e45ad35a9f199" translate="yes" xml:space="preserve">
          <source>The parameter P is passed through as the only parameter to the callback function X. The parameter N is the approximate number of &lt;a href=&quot;../opcode&quot;&gt;virtual machine instructions&lt;/a&gt; that are evaluated between successive invocations of the callback X. If N is less than one then the progress handler is disabled.</source>
          <target state="translated">参数P作为唯一参数传递给回调函数X。参数N是在回调X的连续调用之间评估的&lt;a href=&quot;../opcode&quot;&gt;虚拟机指令&lt;/a&gt;的近似数量。如果N小于1，则禁用进度处理程序。</target>
        </trans-unit>
        <trans-unit id="de8aa7c163a7cfc0e81022005dde253ed27f9cea" translate="yes" xml:space="preserve">
          <source>The parameter P is passed through as the only parameter to the callback function X. The parameter N is the approximate number of &lt;a href=&quot;opcode&quot;&gt;virtual machine instructions&lt;/a&gt; that are evaluated between successive invocations of the callback X. If N is less than one then the progress handler is disabled.</source>
          <target state="translated">参数P作为唯一参数传递给回调函数X。参数N是在回调X的连续调用之间评估的&lt;a href=&quot;opcode&quot;&gt;虚拟机指令&lt;/a&gt;的近似数量。如果N小于1，则禁用进度处理程序。</target>
        </trans-unit>
        <trans-unit id="b6a1b97180e82088f349d801a8feb225d5ea8536" translate="yes" xml:space="preserve">
          <source>The parameters to the callback are the pArg value, the amount of memory currently in use, and the size of the allocation that provoked the callback. The callback will presumably invoke &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; to free up memory space. The callback may invoke &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt; but if it does, no additional callbacks will be invoked by the recursive calls.</source>
          <target state="translated">回调的参数是pArg值，当前使用的内存量以及引起回调的分配大小。回调可能会调用&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放内存空间。回调可以调用&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;或&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc（），&lt;/a&gt;但如果这样做，则递归调用将不会再调用其他回调。</target>
        </trans-unit>
        <trans-unit id="a0635b4b828516772af2e4a5c5f8f7c2b0b83854" translate="yes" xml:space="preserve">
          <source>The parent and sub-query may contain WHERE clauses. Subject to rules (11), (12) and (13), they may also contain ORDER BY, LIMIT and OFFSET clauses.</source>
          <target state="translated">母查询和子查询可以包含WHERE子句。在遵守规则(11)、(12)和(13)的前提下,它们还可以包含ORDER BY、LIMIT和OFFSET子句。</target>
        </trans-unit>
        <trans-unit id="6d5030cd0c93ffa44cd5f784ea6b109c2ce36ffc" translate="yes" xml:space="preserve">
          <source>The parent key columns named in the foreign key constraint are not the primary key of the parent table and are not subject to a unique constraint using collating sequence specified in the CREATE TABLE, or</source>
          <target state="translated">外键约束中命名的父键列不是父表的主键,并且不受唯一约束,使用CREATE TABLE中指定的整理序列,或</target>
        </trans-unit>
        <trans-unit id="0feae637448fae26652f631fd44b61bcd440968a" translate="yes" xml:space="preserve">
          <source>The parent key columns named in the foreign key constraint do not exist, or</source>
          <target state="translated">外键约束中命名的父键列不存在,或</target>
        </trans-unit>
        <trans-unit id="ba132dacfac52109e850c048192c0d768817957a" translate="yes" xml:space="preserve">
          <source>The parent table does not exist, or</source>
          <target state="translated">父表不存在,或</target>
        </trans-unit>
        <trans-unit id="cfb0e652f64b7c831f470e25c9ae00145b03ba52" translate="yes" xml:space="preserve">
          <source>The parser assigns meaning to tokens based on their context. The parser for SQLite is generated using the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt;. Lemon does the same job as YACC/BISON, but it uses a different input syntax which is less error-prone. Lemon also generates a parser which is reentrant and thread-safe. And Lemon defines the concept of a non-terminal destructor so that it does not leak memory when syntax errors are encountered. The grammar file that drives Lemon and that defines the SQL language that SQLite understands is found in &lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y&lt;/a&gt;.</source>
          <target state="translated">解析器根据令牌的上下文为令牌分配含义。 SQLite的解析器是使用&lt;a href=&quot;lemon&quot;&gt;Lemon解析器生成器生成的&lt;/a&gt;。 Lemon做的工作与YACC / BISON相同，但是它使用不同的输入语法，因此不容易出错。 Lemon还生成可重入且线程安全的解析器。 Lemon定义了非终端析构函数的概念，以便在遇到语法错误时不会泄漏内存。在&lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y中&lt;/a&gt;可以找到驱动Lemon的语法文件，该语法文件定义了SQLite可以理解的SQL语言。</target>
        </trans-unit>
        <trans-unit id="bba39e24b4502de9e348487cd65024dc8a8b4825" translate="yes" xml:space="preserve">
          <source>The parser now insists on seeing a semicolon or the end of input before executing a statement. This avoids an accidental disaster if the WHERE keyword is misspelled in an UPDATE or DELETE statement.</source>
          <target state="translated">解析器现在坚持在执行语句之前看到分号或输入的结尾。这就避免了在UPDATE或DELETE语句中,WHERE关键字拼写错误的情况下发生意外灾难。</target>
        </trans-unit>
        <trans-unit id="276468011b3fce8fd043bc0ac6f52f8e374eb1fe" translate="yes" xml:space="preserve">
          <source>The parser used by SQLite is forgiving. It is often possible to use a keyword as an identifier as long as such use does not result in a parsing ambiguity. For example, the statement &quot;CREATE TABLE BEGIN(REPLACE,PRAGMA,END);&quot; is accepted by SQLite, and creates a new table named &quot;BEGIN&quot; with three columns named &quot;REPLACE&quot;, &quot;PRAGMA&quot;, and &quot;END&quot;. Nevertheless, best practice is to avoid using keywords as identifiers. Common techniques used to avoid keyword name collisions include:</source>
          <target state="translated">SQLite使用的解析器是宽容的。只要不造成解析上的歧义,通常可以使用关键字作为标识符。例如,语句 &quot;CREATE TABLE BEGIN(REPLACE,PRAGMA,END);&quot;被SQLite接受,并创建了一个名为 &quot;BEGIN &quot;的新表,其中有三列名为 &quot;REPLACE&quot;、&quot;PRAGMA &quot;和 &quot;END&quot;。尽管如此,最好的做法是避免使用关键字作为标识符。避免关键词名称碰撞的常用技术包括:。</target>
        </trans-unit>
        <trans-unit id="cf399069b7a65af0b661c7a78ceab3a98b1156db" translate="yes" xml:space="preserve">
          <source>The parser's stack was overflowing on a very long UPDATE statement. This is now fixed.</source>
          <target state="translated">在很长的UPDATE语句上,解析器的堆栈溢出。现在已经修复。</target>
        </trans-unit>
        <trans-unit id="a5c83958bfdec6a8c2fd0d74498090055bde1a94" translate="yes" xml:space="preserve">
          <source>The parsing of SQL statements is a significant consumer of CPU cycles in any SQL database engine. On-going efforts to optimize SQLite have caused the developers to spend a lot of time tweaking Lemon to generate faster parsers. These efforts have benefited all users of the Lemon parser generator, not just SQLite. But if Lemon had been a separately maintained tool, it would have been more difficulty to make coordinated changes to both SQLite and Lemon, and as a result not as much optimization would have been accomplished. Hence, the fact that the parser generator tool is included in the source tree for SQLite has turned out to be a net benefit for both the tool itself and for SQLite.</source>
          <target state="translated">在任何SQL数据库引擎中,SQL语句的解析都是CPU周期的重要消耗。为了优化SQLite,开发人员花费了大量的时间来调整Lemon,以生成更快的解析器。这些努力使Lemon解析器生成器的所有用户受益,而不仅仅是SQLite。但是,如果Lemon是一个单独维护的工具,那么对SQLite和Lemon进行协调修改的难度就会更大,结果就不会有那么多的优化。因此,事实证明,解析器生成器工具被包含在SQLite的源码树中,对工具本身和SQLite都是净收益。</target>
        </trans-unit>
        <trans-unit id="7d2ca17144abc28a05044c4d5d55dce18e17a921" translate="yes" xml:space="preserve">
          <source>The part of the name prior to the last &quot;_&quot; exactly matches the name of a virtual table that was created using &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;. (Shadow tables are not recognized for &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual tables&lt;/a&gt; and &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;.)</source>
          <target state="translated">名称中最后一个&amp;ldquo; _&amp;rdquo;之前的部分与使用&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;创建的虚拟表的名称完全匹配。 （&lt;a href=&quot;vtab#epovtab&quot;&gt;同名虚拟表&lt;/a&gt;和&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;无法识别影子表。）</target>
        </trans-unit>
        <trans-unit id="042a9e73444095c51cd83e16473e75bf7e45a5e4" translate="yes" xml:space="preserve">
          <source>The patch level Z was historically only used for bug-fix releases that changed only a small number of code lines.</source>
          <target state="translated">补丁级别Z在历史上只用于只修改少量代码行的错误修复版本。</target>
        </trans-unit>
        <trans-unit id="274dfc20017243c18164f876bdd5c3980ade92fe" translate="yes" xml:space="preserve">
          <source>The path component of the URI specifies the disk file that is the SQLite database to be opened. If the path component is omitted, then the database is stored in a temporary file that will be automatically deleted when the database connection closes. If the authority section is present, then the path is always an absolute pathname. If the authority section is omitted, then the path is an absolute pathname if it begins with the &quot;/&quot; character (ASCII code 0x2f) and is a relative pathname otherwise. On windows, if the absolute path begins with &quot;&lt;b&gt;/&lt;i&gt;X&lt;/i&gt;:/&lt;/b&gt;&quot; where &lt;b&gt;&lt;i&gt;X&lt;/i&gt;&lt;/b&gt; is any single ASCII alphabetic character (&quot;a&quot; through &quot;z&quot; or &quot;A&quot; through &quot;Z&quot;) then the &quot;&lt;b&gt;&lt;i&gt;X:&lt;/i&gt;&lt;/b&gt;&quot; is understood to be the drive letter of the volume containing the file, not the toplevel directory.</source>
          <target state="translated">URI的路径组件指定磁盘文件，该磁盘文件是要打开的SQLite数据库。如果省略路径组件，则数据库存储在一个临时文件中，当数据库连接关闭时，该文件将自动删除。如果存在授权部分，则该路径始终是绝对路径名。如果省略了权限部分，则该路径以&amp;ldquo; /&amp;rdquo;字符（ASCII代码0x2f）开头为绝对路径名，否则为相对路径名。在Windows上，如果绝对路径以&amp;ldquo; &lt;b&gt;/ &lt;i&gt;X&lt;/i&gt;：/&lt;/b&gt; &amp;rdquo; 开头，其中&lt;b&gt;&lt;i&gt;X&lt;/i&gt;&lt;/b&gt;是任何单个ASCII字母字符（&amp;ldquo; a&amp;rdquo;至&amp;ldquo; z&amp;rdquo;或&amp;ldquo; A&amp;rdquo;至&amp;ldquo; Z&amp;rdquo;），则&amp;ldquo; &lt;b&gt;&lt;i&gt;X：&lt;/i&gt;&lt;/b&gt;&amp;ldquo;&amp;rdquo;被理解为是包含文件而不是顶层目录的卷的驱动器号。</target>
        </trans-unit>
        <trans-unit id="f3532ac83d22ad95431b31438dce70e426b9f355" translate="yes" xml:space="preserve">
          <source>The path is optional if the authority is present. If the authority is omitted then the path is required.</source>
          <target state="translated">如果有权限,路径是可选的。如果省略了权限,则路径为必填项。</target>
        </trans-unit>
        <trans-unit id="5dd0cabb7668cbee80844078c73a695152a285b7" translate="yes" xml:space="preserve">
          <source>The pattern matching algorithm used in the default &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; and &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; implementation of SQLite can exhibit O(N&amp;amp;sup2) performance (where N is the number of characters in the pattern) for certain pathological cases. To avoid denial-of-service attacks from miscreants who are able to specify their own LIKE or GLOB patterns, the length of the LIKE or GLOB pattern is limited to SQLITE_MAX_LIKE_PATTERN_LENGTH bytes. The default value of this limit is 50000. A modern workstation can evaluate even a pathological LIKE or GLOB pattern of 50000 bytes relatively quickly. The denial of service problem only comes into play when the pattern length gets into millions of bytes. Nevertheless, since most useful LIKE or GLOB patterns are at most a few dozen bytes in length, paranoid application developers may want to reduce this parameter to something in the range of a few hundred if they know that external users are able to generate arbitrary patterns.</source>
          <target state="translated">默认&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;和&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB中&lt;/a&gt;使用的模式匹配算法对于某些病理情况，SQLite的实现可以表现出O（N＆sup2）性能（其中N是模式中的字符数）。为了避免能够指定自己的LIKE或GLOB模式的恶意者进行的拒绝服务攻击，LIKE或GLOB模式的长度限制为SQLITE_MAX_LIKE_PATTERN_LENGTH字节。此限制的默认值为50000。现代工作站甚至可以相对快速地评估甚至是50000字节的病理LIKE或GLOB模式。仅当模式长度达到数百万个字节时，拒绝服务问题才起作用。不过，由于最有用的LIKE或GLOB模式的长度最多为几十个字节，如果他们知道外部用户能够生成任意模式，则偏执的应用程序开发人员可能希望将此参数减小到几百个范围。</target>
        </trans-unit>
        <trans-unit id="d6c16218a9785941384e3fbed5d84494c8c3a3ec" translate="yes" xml:space="preserve">
          <source>The pattern matching algorithm used in the default &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; and &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; implementation of SQLite can exhibit O(N&amp;sup2;) performance (where N is the number of characters in the pattern) for certain pathological cases. To avoid denial-of-service attacks from miscreants who are able to specify their own LIKE or GLOB patterns, the length of the LIKE or GLOB pattern is limited to SQLITE_MAX_LIKE_PATTERN_LENGTH bytes. The default value of this limit is 50000. A modern workstation can evaluate even a pathological LIKE or GLOB pattern of 50000 bytes relatively quickly. The denial of service problem only comes into play when the pattern length gets into millions of bytes. Nevertheless, since most useful LIKE or GLOB patterns are at most a few dozen bytes in length, paranoid application developers may want to reduce this parameter to something in the range of a few hundred if they know that external users are able to generate arbitrary patterns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="202855d0443faeb5dfa8c360619529b04d6a4b20" translate="yes" xml:space="preserve">
          <source>The people table has one entry for each person in a large organization. Each person is either a &quot;student&quot; or a &quot;teacher&quot;, as determined by the &quot;role&quot; field. And we record the height in centimeters of each person. The role and height are indexed. Notice that the left-most column of the index is not very selective - it only contains two possible values.</source>
          <target state="translated">人员表为一个大型组织中的每个人设置了一个条目。每个人要么是 &quot;学生&quot;,要么是 &quot;老师&quot;,由 &quot;角色 &quot;字段决定。而我们记录的是每个人的身高,单位是厘米。角色和身高是有索引的。请注意,索引的最左边一列不是很有选择性--它只包含两个可能的值。</target>
        </trans-unit>
        <trans-unit id="92b29d0fa9a5e447b11571a63811cd4169611d21" translate="yes" xml:space="preserve">
          <source>The per-connection statistics do not use global variables and hence do not require mutexes to update or access. Consequently the per-connection statistics continue to function even if &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is turned off.</source>
          <target state="translated">每个连接的统计信息不使用全局变量，因此不需要互斥来更新或访问。因此，即使关闭了&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;，每个连接的统计信息仍继续起作用。</target>
        </trans-unit>
        <trans-unit id="50dbff919de02c3f0e66d4c1de101521648ed2d5" translate="yes" xml:space="preserve">
          <source>The performance can be improved slightly by bypassing the SQL layer and reading the blob content directly using the &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; interface, as shown in the next chart:</source>
          <target state="translated">通过绕过SQL层并使用&lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;接口直接读取blob内容，可以稍微提高性能，如下图所示：</target>
        </trans-unit>
        <trans-unit id="095c3d78e34e00649d5524d5d46327c65695f40f" translate="yes" xml:space="preserve">
          <source>The performance difference arises (we believe) because when working from an SQLite database, the open() and close() system calls are invoked only once, whereas open() and close() are invoked once for each blob when using blobs stored in individual files. It appears that the overhead of calling open() and close() is greater than the overhead of using the database. The size reduction arises from the fact that individual files are padded out to the next multiple of the filesystem block size, whereas the blobs are packed more tightly into an SQLite database.</source>
          <target state="translated">性能差异的产生(我们认为)是因为当从SQLite数据库工作时,open()和close()系统调用只被调用一次,而当使用存储在单个文件中的blob时,每个blob都要调用一次open()和close()。看来,调用open()和close()的开销大于使用数据库的开销。文件大小的减小是因为单个文件被填充到文件系统块大小的下一个倍数,而blob则被更紧密地打包到SQLite数据库中。</target>
        </trans-unit>
        <trans-unit id="2a5a29c317c697ba64096b7f2c68033b4565ac42" translate="yes" xml:space="preserve">
          <source>The permutation is only valid until the next &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; that has the OPFLAG_PERMUTE bit set in P5. Typically the &lt;a href=&quot;opcode#Permutation&quot;&gt;Permutation&lt;/a&gt; should occur immediately prior to the &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt;.</source>
          <target state="translated">该排列仅在下一个在P5中将OPFLAG_PERMUTE位置1的&lt;a href=&quot;opcode#Compare&quot;&gt;比较&lt;/a&gt;之前有效。通常，&lt;a href=&quot;opcode#Permutation&quot;&gt;排列&lt;/a&gt;应该在&lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt;之前立即进行。</target>
        </trans-unit>
        <trans-unit id="645402751e5b5ab0dd0504759786ac3f99e9f97b" translate="yes" xml:space="preserve">
          <source>The persistence of WAL mode means that applications can be converted to using SQLite in WAL mode without making any changes to the application itself. One has merely to run &quot;&lt;code&gt;PRAGMA journal_mode=WAL;&lt;/code&gt;&quot; on the database file(s) using the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; or other utility, then restart the application.</source>
          <target state="translated">WAL模式的持久性意味着可以在WAL模式下使用SQLite将应用程序转换为应用程序，而无需对应用程序本身进行任何更改。只需使用&lt;a href=&quot;cli&quot;&gt;命令行Shell&lt;/a&gt;或其他实用程序在数据库文件上运行&amp;ldquo; &lt;code&gt;PRAGMA journal_mode=WAL;&lt;/code&gt; &amp;rdquo; ，然后重新启动应用程序。</target>
        </trans-unit>
        <trans-unit id="37f0ea5f181b03035443f3a918ec838d5bf0f5c4" translate="yes" xml:space="preserve">
          <source>The phrase &quot;VALUES(</source>
          <target state="translated">这句话 &quot;VALUES(</target>
        </trans-unit>
        <trans-unit id="afda55d9895c016a5496f6b600205dbf8fbc7d06" translate="yes" xml:space="preserve">
          <source>The planner avoids query plans that use indexes with unknown collating functions.</source>
          <target state="translated">规划器避免使用具有未知整理函数的索引的查询计划。</target>
        </trans-unit>
        <trans-unit id="926646f3fb08c1ad8acc73155c7f0bcd303e689e" translate="yes" xml:space="preserve">
          <source>The planner omits unused LEFT JOINs even if they are not the right-most joins of a query.</source>
          <target state="translated">规划器会省略未使用的LEFT JOIN,即使它们不是查询的最右边的连接。</target>
        </trans-unit>
        <trans-unit id="5852e8af03eff264841e6547e952b8e08ad085dc" translate="yes" xml:space="preserve">
          <source>The platform used for these tests is a 1.6GHz Athlon with 1GB or memory and an IDE disk drive. The operating system is RedHat Linux 7.2 with a stock kernel.</source>
          <target state="translated">这些测试使用的平台是1.6GHz的Athlon,1GB或内存和IDE磁盘驱动器。操作系统为RedHat Linux 7.2,内核为普通内核。</target>
        </trans-unit>
        <trans-unit id="e614d538ab4445c07af270ecdc6677ad39ccfb17" translate="yes" xml:space="preserve">
          <source>The point is this: an SQL database schema almost always does a far better job of defining and organizing the tables and data structures and their relationships. And having clear, concise, and well-defined representation almost always results in an application that performs better, has fewer problems, and is easier to develop and maintain.</source>
          <target state="translated">重点是:SQL数据库模式几乎总是在定义和组织表和数据结构及其关系方面做得更好。而拥有清晰、简明和定义良好的表示方式,几乎总是能使应用程序的性能更好,问题更少,更容易开发和维护。</target>
        </trans-unit>
        <trans-unit id="1249a327a44d56131079defe491a7680b8885a62" translate="yes" xml:space="preserve">
          <source>The pointer arguments to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; must be either NULL or else pointers obtained from a prior invocation of &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; that have not yet been released.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;的指针参数必须为NULL，否则必须是从先前调用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;之前尚未释放的指针中获得的指针。</target>
        </trans-unit>
        <trans-unit id="70d5983c94ca6fdbfd5d05e2d8f25d536fa0e2f9" translate="yes" xml:space="preserve">
          <source>The pointer arguments to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; and &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; must be either NULL or else pointers obtained from a prior invocation of &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; that have not yet been released.</source>
          <target state="translated">&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;和&lt;a href=&quot;free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;的指针参数必须为NULL，否则必须是从先前调用&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;或&lt;a href=&quot;free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;之前尚未释放的指针中获得的指针。</target>
        </trans-unit>
        <trans-unit id="19e21383ec674e61332285628bf7a07277fe3452" translate="yes" xml:space="preserve">
          <source>The pointer type is not intended to be flexible and dynamic. The pointer type is intended to be a design-time constant. Applications should not synthesize pointer type strings at run-time. Providing support for dynamic pointer type strings would lead developers to misuse the pointer-passing interfaces by creating run-time synthesized pointer type strings. Requiring the pointer type strings to be static encourages developers to do the right thing by choosing fixed pointer type names at design-time and encoding those names as constant strings.</source>
          <target state="translated">指针类型不是为了灵活和动态。指针类型旨在成为设计时的常量,应用程序不应该在运行时合成指针类型字符串。应用程序不应在运行时合成指针类型字符串。提供对动态指针类型字符串的支持会导致开发人员通过创建运行时合成的指针类型字符串来滥用指针传递接口。要求指针类型字符串是静态的,会鼓励开发人员在设计时选择固定的指针类型名称,并将这些名称编码为常量字符串,从而做正确的事情。</target>
        </trans-unit>
        <trans-unit id="0a50e253ab7c267f33ad3d5a3deec486738946df" translate="yes" xml:space="preserve">
          <source>The pointers returned are valid until a type conversion occurs as described above, or until &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; is called. The memory space used to hold strings and BLOBs is freed automatically. Do not pass the pointers returned from &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_blob()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, etc. into &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">返回的指针有效，直到如上所述发生类型转换，或者直到调用&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;为止。用于保存字符串和BLOB的内存空间会自动释放。不要将从&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_blob（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text（）&lt;/a&gt;等返回的指针传递到&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3551cf33afa7b1894cdea20e6326c2bf8dcf19de" translate="yes" xml:space="preserve">
          <source>The pointers returned are valid until a type conversion occurs as described above, or until &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; is called. The memory space used to hold strings and BLOBs is freed automatically. Do not pass the pointers returned from &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_blob()&lt;/a&gt;, &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, etc. into &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">返回的指针有效，直到如上所述发生类型转换，或者直到调用&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;或&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;或&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;为止。用于保存字符串和BLOB的内存空间会自动释放。不要将从&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_blob（）&lt;/a&gt;，&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text（）&lt;/a&gt;等返回的指针传递到&lt;a href=&quot;free&quot;&gt;sqlite3_free（）中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9edff31b2dc071eb66ab4aa44d22adfef6b1aa3c" translate="yes" xml:space="preserve">
          <source>The pointers that piggy-back on SQL NULL values using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;, and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; interface are transient and ephemeral. The pointers are never written into the database. The pointers will not survive sorting. The latter fact is why there is no sqlite3_column_pointer() interface, since it is impossible to predict whether or not the query planner will insert a sort operation prior to returning a value from a query, so it would be impossible to know if a pointer value inserted into a query by &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; or &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; would survive through to the result set.</source>
          <target state="translated">使用&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;，&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;和&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;接口搭载SQL NULL值的指针是临时的和短暂的。指针永远不会写入数据库。指针将无法生存排序。后一个事实是为什么没有sqlite3_column_pointer（）接口的原因，因为无法预测查询计划程序是否会在从查询返回值之前插入排序操作，因此将无法知道指针值由&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;或&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;插入查询中将保留到结果集。</target>
        </trans-unit>
        <trans-unit id="41025b56b1d99416ab106417d2e02a42b25af90e" translate="yes" xml:space="preserve">
          <source>The porter tokenizer is a wrapper tokenizer. It takes the output of some other tokenizer and applies the &lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;porter stemming algorithm&lt;/a&gt; to each token before it returns it to FTS5. This allows search terms like &quot;correction&quot; to match similar words such as &quot;corrected&quot; or &quot;correcting&quot;. The porter stemmer algorithm is designed for use with English language terms only - using it with other languages may or may not improve search utility.</source>
          <target state="translated">搬运程序标记器是包装标记器。这需要一些其他标记生成器的输出，并应用&lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;波特词干算法&lt;/a&gt;给每个令牌它返回到FTS5之前。这允许像&amp;ldquo;更正&amp;rdquo;之类的搜索字词匹配类似&amp;ldquo;更正&amp;rdquo;或&amp;ldquo;更正&amp;rdquo;之类的词。搬运工词干分析器算法仅设计用于英语术语-与其他语言一起使用可能会或可能不会提高搜索实用性。</target>
        </trans-unit>
        <trans-unit id="8db274801095c26d088720201acb1bad2d40d917" translate="yes" xml:space="preserve">
          <source>The power of an SQLite database could, in theory, be achieved using a custom file format. But any custom file format that is as expressive as a relational database would likely require an enormous design specification and many tens or hundreds of thousands of lines of code to implement. And the end result would be an &quot;opaque blob&quot; that is inaccessible without specialized tools.</source>
          <target state="translated">理论上,SQLite数据库的强大功能可以通过使用自定义文件格式来实现。但是,任何像关系型数据库一样具有表现力的自定义文件格式都很可能需要一个庞大的设计规范和几万行或几十万行的代码来实现。而最终的结果将是一个 &quot;不透明的小球&quot;,没有专门的工具是无法进入的。</target>
        </trans-unit>
        <trans-unit id="4938c1fbe50ea261772ee32f2ec000b4cb6af37b" translate="yes" xml:space="preserve">
          <source>The powersafe overwrite property for individual databases can be specified as the database is opened using the &quot;psow&quot; query parameter with a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. For example, to always assume powersafe overwrite for a file (perhaps to ensure maximum write performance), open it as</source>
          <target state="translated">当使用带有&lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;的&amp;ldquo; psow&amp;rdquo;查询参数打开数据库时，可以指定各个数据库的powersafe overwrite属性。例如，要始终假定文件的电源安全覆盖（可能是为了确保最大的写入性能），请以</target>
        </trans-unit>
        <trans-unit id="67790abdb6b576eda27fab78ba503267f5a114fa" translate="yes" xml:space="preserve">
          <source>The powersafe overwrite property says nothing about the state of the bytes that were written. Those bytes might contain their old values, their new values, random values, or some combination of these. The powersafe overwrite property merely states that writes cannot change bytes outside of the range of bytes written.</source>
          <target state="translated">powersafe overwrite 属性对被写入的字节的状态没有任何说明。这些字节可能包含了它们的旧值、新值、随机值,或者它们的某种组合。powersafe overwrite属性只是说明写入不能改变写入的字节范围之外的字节。</target>
        </trans-unit>
        <trans-unit id="1389e8d5f9998cc48b0c99ae215e31d8f358ccd0" translate="yes" xml:space="preserve">
          <source>The pragma command is specific to SQLite and is not compatible with any other SQL database engine.</source>
          <target state="translated">pragma命令是针对SQLite的,与其他任何SQL数据库引擎都不兼容。</target>
        </trans-unit>
        <trans-unit id="f45ce9f6459acccc6664213a9c9d236d0392b096" translate="yes" xml:space="preserve">
          <source>The pragma is like &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check&lt;/a&gt; except that it does not verify UNIQUE constraints and does not verify that index content matches table content. By skipping UNIQUE and index consistency checks, quick_check is able to run faster. PRAGMA quick_check runs in O(N) time whereas &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; requires O(NlogN) time where N is the total number of rows in the database. Otherwise the two pragmas are the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b9cdfdccce2f8d840c93537988a1d96c50df274" translate="yes" xml:space="preserve">
          <source>The pragma is like &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check&lt;/a&gt; except that it does not verify UNIQUE constraints and does not verify that index content matches table content. By skipping UNIQUE and index consistency checks, quick_check is able to run much faster than integrity_check. Otherwise the two pragmas are the same.</source>
          <target state="translated">该编译指示类似于&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;完整性检查，&lt;/a&gt;不同之处在于它不验证UNIQUE约束并且不验证索引内容是否与表内容匹配。通过跳过UNIQUE和索引一致性检查，quick_check的运行速度比完整性完整性检查要快得多。否则，两个语用相同。</target>
        </trans-unit>
        <trans-unit id="da60401a603e537afbb64f9be897b6e57271b0ee" translate="yes" xml:space="preserve">
          <source>The pre-update hook</source>
          <target state="translated">预更新钩子</target>
        </trans-unit>
        <trans-unit id="77a94c0ef3120048af1c78a5031b2bc8f51341cf" translate="yes" xml:space="preserve">
          <source>The pre-update hook.</source>
          <target state="translated">预更新的勾当。</target>
        </trans-unit>
        <trans-unit id="464d49040a7350ab38dd3a440629e97d8425be1c" translate="yes" xml:space="preserve">
          <source>The precautions above are not required in order to use SQLite safely with potentially hostile inputs. However, they do provide an extra layer of defense against zero-day exploits and are encouraged for applications that pass data from untrusted sources into SQLite.</source>
          <target state="translated">为了安全地使用SQLite与潜在的敌对输入,上述预防措施不是必需的。然而,它们确实提供了一个额外的防御层,以防止零日漏洞,并鼓励将来自不受信任来源的数据传递到SQLite的应用程序。</target>
        </trans-unit>
        <trans-unit id="05bf811875969018cb62c264a6781abc17b442f0" translate="yes" xml:space="preserve">
          <source>The precedence order for ON CONFLICT clauses was changed so that ON CONFLICT clauses on BEGIN statements have a higher precedence than ON CONFLICT clauses on constraints.</source>
          <target state="translated">改变了ON CONFLICT子句的优先顺序,使BEGIN语句上的ON CONFLICT子句比约束条件上的ON CONFLICT子句具有更高的优先权。</target>
        </trans-unit>
        <trans-unit id="122c8023ebc9769b59f3a1882e33d76b3169c9fd" translate="yes" xml:space="preserve">
          <source>The preceding paragraphs contain a lot of information. To ease the task of constructing a new VFS for SQLite we offer the following implementation checklist:</source>
          <target state="translated">前面的段落包含了很多信息。为了简化为SQLite构建一个新的VFS的任务,我们提供了以下的实施检查表。</target>
        </trans-unit>
        <trans-unit id="661723ea54e783ccd80036c290bfdccff5b43478" translate="yes" xml:space="preserve">
          <source>The precision field, if it is present, must follow the width separated by a single &quot;.&quot; character. If there is no width, then the &quot;.&quot; that introduces the precision immediately follows either the flags (if there are any) or the initial &quot;%&quot;.</source>
          <target state="translated">如果有精度字段,必须在宽度后面用一个&quot;.&quot;字符隔开。如果没有宽度,那么引入精度的&quot;.&quot;字段紧跟在标志(如果有的话)或初始&quot;%&quot;之后。</target>
        </trans-unit>
        <trans-unit id="274c336721e63c209854a5c06e41f1f163132ddd" translate="yes" xml:space="preserve">
          <source>The preferred routine to use is &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface is legacy and should be avoided. &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; has an extra &quot;prepFlags&quot; option that is used for special purposes.</source>
          <target state="translated">首选使用的例程是&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;。该&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;接口是传统的，应当避免。&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;有一个额外的&amp;ldquo; prepFlags&amp;rdquo;选项，用于特殊目的。</target>
        </trans-unit>
        <trans-unit id="2a1d33401c2095551ef53ebdb2c936c2ab4e7f75" translate="yes" xml:space="preserve">
          <source>The preferred routine to use is &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. The &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface is legacy and should be avoided. &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; has an extra &quot;prepFlags&quot; option that is used for special purposes.</source>
          <target state="translated">首选使用的例程是&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;。该&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;接口是传统的，应当避免。&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;有一个额外的&amp;ldquo; prepFlags&amp;rdquo;选项，用于特殊目的。</target>
        </trans-unit>
        <trans-unit id="e5802699120466acd022e1fa07d198c436289856" translate="yes" xml:space="preserve">
          <source>The prefix on temporary filenames on Windows is changed from &quot;sqlite&quot; to &quot;etilqs&quot;.</source>
          <target state="translated">Windows上临时文件名的前缀由 &quot;sqlite &quot;改为 &quot;etilqs&quot;。</target>
        </trans-unit>
        <trans-unit id="f3230410aa1ec23cdd51b1c85ef3e6e8a5bf6364" translate="yes" xml:space="preserve">
          <source>The presence of a busy handler does not guarantee that it will be invoked when there is lock contention. If SQLite determines that invoking the busy handler could result in a deadlock, it will go ahead and return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; to the application instead of invoking the busy handler. Consider a scenario where one process is holding a read lock that it is trying to promote to a reserved lock and a second process is holding a reserved lock that it is trying to promote to an exclusive lock. The first process cannot proceed because it is blocked by the second and the second process cannot proceed because it is blocked by the first. If both processes invoke the busy handlers, neither will make any progress. Therefore, SQLite returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; for the first process, hoping that this will induce the first process to release its read lock and allow the second process to proceed.</source>
          <target state="translated">繁忙处理程序的存在并不能保证在存在锁争用时将调用该处理程序。如果SQLite确定调用繁忙处理程序可能导致死锁，它将继续执行并将&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;返回给应用程序，而不是调用繁忙处理程序。考虑一个场景，其中一个进程持有试图将其提升为保留锁的读取锁，而第二个进程持有试图将其提升为排他锁的保留锁。第一个进程无法进行，因为它被第二个进程阻止，第二个进程无法进行，因为它被第一个进程阻止。如果两个进程都调用繁忙的处理程序，则两者都不会取得任何进展。因此，SQLite返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;对于第一个进程，希望这将导致第一个进程释放其读取锁并允许第二个进程继续进行。</target>
        </trans-unit>
        <trans-unit id="f52f9d0c779543db7a531d457708b0c4e1e3b230" translate="yes" xml:space="preserve">
          <source>The presence of a busy handler does not guarantee that it will be invoked when there is lock contention. If SQLite determines that invoking the busy handler could result in a deadlock, it will go ahead and return &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; to the application instead of invoking the busy handler. Consider a scenario where one process is holding a read lock that it is trying to promote to a reserved lock and a second process is holding a reserved lock that it is trying to promote to an exclusive lock. The first process cannot proceed because it is blocked by the second and the second process cannot proceed because it is blocked by the first. If both processes invoke the busy handlers, neither will make any progress. Therefore, SQLite returns &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; for the first process, hoping that this will induce the first process to release its read lock and allow the second process to proceed.</source>
          <target state="translated">繁忙处理程序的存在并不能保证在存在锁争用时将调用该处理程序。如果SQLite确定调用繁忙处理程序可能导致死锁，它将继续执行并将&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;返回给应用程序，而不是调用繁忙处理程序。考虑一个场景，其中一个进程持有试图将其提升为保留锁的读取锁，而第二个进程持有试图将其提升为排他锁的保留锁。第一个进程无法进行，因为它被第二个进程阻止，第二个进程无法进行，因为它被第一个进程阻止。如果两个进程都调用繁忙的处理程序，则两者都不会取得任何进展。因此，SQLite返回&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;对于第一个进程，希望这将导致第一个进程释放其读取锁并允许第二个进程继续进行。</target>
        </trans-unit>
        <trans-unit id="b2efda84ef1340b69a62f5b61118269d4141c529" translate="yes" xml:space="preserve">
          <source>The presence of a hot journal is our indication that a previous process was trying to commit a transaction but it aborted for some reason prior to the completion of the commit. A hot journal means that the database file is in an inconsistent state and needs to be repaired (by rollback) prior to being used.</source>
          <target state="translated">热日志的存在是我们的指示,表明前一个进程正试图提交一个事务,但在完成提交之前因某种原因而中止。热日志意味着数据库文件处于不一致的状态,需要在使用前进行修复(通过回滚)。</target>
        </trans-unit>
        <trans-unit id="53e2bd6dac9cbbc9b06c74e123d964800e4d3352" translate="yes" xml:space="preserve">
          <source>The presence of the &quot;noskipscan&quot; token on the sqlite_stat1.stat field of an index prevents that index from being used with the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt;.</source>
          <target state="translated">索引的sqlite_stat1.stat字段上存在&amp;ldquo; noskipscan&amp;rdquo;令牌，这会阻止该索引与&lt;a href=&quot;optoverview#skipscan&quot;&gt;跳过扫描优化配合使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a01f573624c54e96d01f0d23d0ba8b3593807a0a" translate="yes" xml:space="preserve">
          <source>The presentation of the query planner problem above is a simplification. The costs are estimates. We cannot know what the true cost of running a loop is until we actually run the loop. SQLite makes guesses for the cost of running a loop based on the availability of indexes and constraints found in the WHERE clause. These guesses are usually pretty good, but they can sometimes be off. Using the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command to collect additional statistical information about the database can sometimes enable SQLite to make better guesses about the cost.</source>
          <target state="translated">上面查询规划器问题的表示是一种简化。费用是估计数。在实际运行循环之前，我们不知道运行循环的真正成本是多少。SQLite根据在WHERE子句中找到的索引和约束的可用性来猜测运行循环的成本。这些猜测通常是很好的，但有时可能会落空。使用&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令收集有关数据库的其他统计信息有时可以使SQLite对成本进行更好的猜测。</target>
        </trans-unit>
        <trans-unit id="1c32ea8c1623df88595d5e28c3a4322ef70e185f" translate="yes" xml:space="preserve">
          <source>The preupdate hook interfaces were originally added to support the &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; extension.</source>
          <target state="translated">最初添加了preupdate挂钩接口以支持&lt;a href=&quot;sessionintro&quot;&gt;会话&lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="54aaab8c82da084a0f8a9658f2bc76535e494e38" translate="yes" xml:space="preserve">
          <source>The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; or to system tables like sqlite_master or sqlite_stat1.</source>
          <target state="translated">preupdate挂钩仅在更改实际数据库表时触发。对于&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;或系统表（如sqlite_master或sqlite_stat1）的更改，不会调用preupdate挂钩。</target>
        </trans-unit>
        <trans-unit id="56711536eb144f6abbe43b67b69a4f340bd68f45" translate="yes" xml:space="preserve">
          <source>The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; or to system tables like sqlite_sequence or sqlite_stat1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f619ca19c48dc2cd5df5d0de6abefa9c15ce6509" translate="yes" xml:space="preserve">
          <source>The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; or to system tables like sqlite_master or sqlite_stat1.</source>
          <target state="translated">preupdate挂钩仅在更改实际数据库表时触发。对于&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;或系统表（如sqlite_master或sqlite_stat1）的更改，不会调用preupdate挂钩。</target>
        </trans-unit>
        <trans-unit id="f6985f034f86292cf6702a3b24e4e0140c1d7b08" translate="yes" xml:space="preserve">
          <source>The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; or to system tables like sqlite_sequence or sqlite_stat1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548d335209dbce4d25a40d42ac27b0b5a00affc4" translate="yes" xml:space="preserve">
          <source>The previous discussion has treated searching and sorting as separate topics. But in practice, it is often the case that one wants to search and sort at the same time. Fortunately, it is possible to do this using a single index.</source>
          <target state="translated">前面的讨论已经把搜索和排序作为单独的主题。但在实际操作中,经常会出现想同时进行搜索和排序的情况。幸运的是,使用一个单一的索引就可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="5a894252915223aa28176cd8caebb845eabbbe5b" translate="yes" xml:space="preserve">
          <source>The previous example is a specific case of a more general problem: The state of an SQLite database is controlled by both the database file and the journal file. In a quiescent state, the journal file does not exist and only the database file matters. But if the journal file does exist, it must be kept together with the database to avoid corruption. The following actions are all likely to lead to corruption:</source>
          <target state="translated">前面的例子是一个比较普遍的问题的具体案例:一个SQLite数据库的状态是由数据库文件和日志文件控制的。在静止状态下,日志文件不存在,只有数据库文件重要。但如果日志文件确实存在,则必须与数据库一起保存,以避免损坏。以下操作都有可能导致损坏。</target>
        </trans-unit>
        <trans-unit id="96495b049cd011fd87b80d69ae6b3a8f79a60e9a" translate="yes" xml:space="preserve">
          <source>The previous example will return every row for which the _shape overlaps the polygon in the $query_polygon parameter. The geopoly_within() function works similarly, but only returns rows for which the _shape is completely contained within $query_polygon.</source>
          <target state="translated">前面的例子将返回$query_polygon参数中_shape与多边形重合的每一条记录。geopoly_within()函数的工作原理类似,但是只返回那些_形状完全包含在$query_polygon参数中的行。</target>
        </trans-unit>
        <trans-unit id="493e14ba39e9f9ab43ab64d3b6be4b87292ba69a" translate="yes" xml:space="preserve">
          <source>The previous example, SQLite uses index &quot;i1&quot; to optimize a WHERE clause term of the form (a=?) - in this case &quot;a=1&quot;. The previous example could not use a &lt;a href=&quot;queryplanner#covidx&quot;&gt;covering index&lt;/a&gt;, but the following example can, and that fact is reflected in the output:</source>
          <target state="translated">在前面的示例中，SQLite使用索引&amp;ldquo; i1&amp;rdquo;来优化形式（a =？）的WHERE子句项-在这种情况下为&amp;ldquo; a = 1&amp;rdquo;。前面的示例不能使用&lt;a href=&quot;queryplanner#covidx&quot;&gt;coverage索引&lt;/a&gt;，但是下面的示例可以使用，并且事实反映在输出中：</target>
        </trans-unit>
        <trans-unit id="69c7b95e4071269d47577736bbe07ea0a083b117" translate="yes" xml:space="preserve">
          <source>The previous fix was not quite right. This one seems to work better.</source>
          <target state="translated">之前的修复方法不太正确。这个似乎比较好用。</target>
        </trans-unit>
        <trans-unit id="fdab229cc2f18edd4b33bcf4f2dc07383013038b" translate="yes" xml:space="preserve">
          <source>The previous paragraph describes what happens when the synchronous pragma setting is &quot;full&quot;.</source>
          <target state="translated">上一段介绍了当同步pragma设置为 &quot;满 &quot;时的情况。</target>
        </trans-unit>
        <trans-unit id="af577bd70a120b3a01a3ee4e9c639a65b514f294" translate="yes" xml:space="preserve">
          <source>The previous paragraph is also true (separate database connections are isolated from one another) in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; as long as the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; remains turned off. The &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; is off by default and so if the application does nothing to turn it on, it will remain off. Hence, unless the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; is used to change the default behavior, changes made by one database connection are invisible to readers on a different database connection sharing the same cache until the writer commits its transaction.</source>
          <target state="translated">只要保持&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted编译指示&lt;/a&gt;处于关闭状态，上一段在&lt;a href=&quot;sharedcache&quot;&gt;共享缓存模式下&lt;/a&gt;也是正确的（独立的数据库连接彼此隔离）。该&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;READ_UNCOMMITTED编译&lt;/a&gt;默认是关闭的，因此，如果应用程序没有采取任何措施打开它，它会保持关闭状态。因此，除非使用&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted编译指示&lt;/a&gt;来更改默认行为，否则共享共享缓存的另一个数据库连接上的读取器将看不到一个数据库连接所做的更改，直到写入器提交其事务为止。</target>
        </trans-unit>
        <trans-unit id="4443bdbe2499eab3d6d488e897e8d552fc707661" translate="yes" xml:space="preserve">
          <source>The previous paragraph states that SQLite does not assume that sector writes are atomic. This is true by default. But as of SQLite version 3.5.0, there is a new interface called the Virtual File System (&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;) interface. The &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; is the only means by which SQLite communicates to the underlying filesystem. The code comes with default VFS implementations for Unix and Windows and there is a mechanism for creating new custom VFS implementations at runtime. In this new VFS interface there is a method called xDeviceCharacteristics. This method interrogates the underlying filesystem to discover various properties and behaviors that the filesystem may or may not exhibit. The xDeviceCharacteristics method might indicate that sector writes are atomic, and if it does so indicate, SQLite will try to take advantage of that fact. But the default xDeviceCharacteristics method for both Unix and Windows does not indicate atomic sector writes and so these optimizations are normally omitted.</source>
          <target state="translated">上一段指出，SQLite不假定扇区写入是原子的。默认情况下是这样。但是从SQLite版本3.5.0开始，有一个称为虚拟文件系统（&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;）接口的新接口。该&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;是SQLite与基础文件系统通信的唯一方法。该代码随附用于Unix和Windows的默认VFS实现，并且提供了一种在运行时创建新的自定义VFS实现的机制。在这个新的VFS接口中，有一个称为xDeviceCharacteristics的方法。此方法询问基础文件系统，以发现文件系统可能会或可能不会出现的各种属性和行为。 xDeviceCharacteristics方法可能表明扇区写是原子的，如果这样做表明SQLite将尝试利用这一事实。但是，对于Unix和Windows，默认的xDeviceCharacteristics方法并不指示原子扇区写入，因此通常会省略这些优化。</target>
        </trans-unit>
        <trans-unit id="342bf4dfcd7ddbf3e5538a244e6458410341ab97" translate="yes" xml:space="preserve">
          <source>The previous paragraphs describe the behavior of temporary databases under the default SQLite configuration. An application can use the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; and the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter to force temporary databases to behave as pure in-memory databases, if desired.</source>
          <target state="translated">前面的段落描述了默认SQLite配置下临时数据库的行为。如果需要，应用程序可以使用&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;和&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;编译时参数来强制临时数据库表现为纯内存数据库。</target>
        </trans-unit>
        <trans-unit id="6e1f293bab97b2b5f7895a766acf571a1f59dca9" translate="yes" xml:space="preserve">
          <source>The previous query is equivalent to the following:</source>
          <target state="translated">前面的查询相当于下面的查询:</target>
        </trans-unit>
        <trans-unit id="2a8f5ff04cf0666d4b31c9cd45d0419954ccab05" translate="yes" xml:space="preserve">
          <source>The previous step created circle (1) in the diagram above. This step will create circle (2). Run the following command:</source>
          <target state="translated">上一步在上图中创建了圆(1)。这一步将创建圆圈(2)。运行以下命令。</target>
        </trans-unit>
        <trans-unit id="73d4cf9a53d1a814d3d61247ac59a2dcf02d4a89" translate="yes" xml:space="preserve">
          <source>The primary page cache implementation is in the &lt;a href=&quot;https://sqlite.org/src/file/src/pager.c&quot;&gt;pager.c&lt;/a&gt; file. &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; logic is in the separate &lt;a href=&quot;https://sqlite.org/src/file/src/wal.c&quot;&gt;wal.c&lt;/a&gt;. In-memory caching is implemented by the &lt;a href=&quot;https://sqlite.org/src/file/src/pcache.c&quot;&gt;pcache.c&lt;/a&gt; and &lt;a href=&quot;https://sqlite.org/src/file/src/pcache1.c&quot;&gt;pcache1.c&lt;/a&gt; files. The interface between page cache subsystem and the rest of SQLite is defined by the header file &lt;a href=&quot;https://sqlite.org/src/file/src/pager.h&quot;&gt;pager.h&lt;/a&gt;.</source>
          <target state="translated">主页面缓存实现位于&lt;a href=&quot;https://sqlite.org/src/file/src/pager.c&quot;&gt;pager.c&lt;/a&gt;文件中。&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;逻辑在单独的&lt;a href=&quot;https://sqlite.org/src/file/src/wal.c&quot;&gt;wal.c中&lt;/a&gt;。内存中缓存由&lt;a href=&quot;https://sqlite.org/src/file/src/pcache.c&quot;&gt;pcache.c&lt;/a&gt;和&lt;a href=&quot;https://sqlite.org/src/file/src/pcache1.c&quot;&gt;pcache1.c&lt;/a&gt;文件实现。页面缓存子系统和其余SQLite之间的接口&lt;a href=&quot;https://sqlite.org/src/file/src/pager.h&quot;&gt;由头&lt;/a&gt;文件pager.h定义。</target>
        </trans-unit>
        <trans-unit id="01bd1fccd0eb574f8649d147f7495318ef2ed3aa" translate="yes" xml:space="preserve">
          <source>The primary use of Lemon is to create the SQL language parser. A grammar file (&lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y&lt;/a&gt;) is compiled by Lemon into parse.c and parse.h. The parse.c file is incorporated into the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; without further modification.</source>
          <target state="translated">Lemon的主要用途是创建SQL语言解析器。Lemon将一个语法文件（&lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y&lt;/a&gt;）编译为parse.c和parse.h。parse.c文件无需进一步修改即可合并到&lt;a href=&quot;amalgamation&quot;&gt;合并中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c694d6e20cc8030ef2cf2b05c8cbbbe628062074" translate="yes" xml:space="preserve">
          <source>The principal task of an SQL database engine is to evaluate SQL statements of SQL. To accomplish this, the developer needs two objects:</source>
          <target state="translated">SQL数据库引擎的主要任务是评估SQL的SQL语句。为了完成这个任务,开发者需要两个对象。</target>
        </trans-unit>
        <trans-unit id="cfcb012162b1a505da1f19d8786ad1f42bcacc75" translate="yes" xml:space="preserve">
          <source>The principle difference between FTS3/4 and FTS5 is that in FTS3/4, each instance-list is stored as a single large database record, whereas in FTS5 large instance-lists are divided between multiple database records. This has the following implications for dealing with large databases that contain large lists:</source>
          <target state="translated">FTS3/4和FTS5之间的主要区别是,在FTS3/4中,每个实例列表都作为一个大的数据库记录存储,而在FTS5中,大的实例列表在多个数据库记录之间划分。这对处理包含大型列表的大型数据库有以下影响。</target>
        </trans-unit>
        <trans-unit id="d7231b054e5abc6f0cfc5cc85f7e3279373f74d4" translate="yes" xml:space="preserve">
          <source>The printf() in SQLite supports new non-standard substitution types (&lt;a href=&quot;printf#percentq&quot;&gt;%q&lt;/a&gt;, &lt;a href=&quot;printf#percentq&quot;&gt;%Q&lt;/a&gt;, &lt;a href=&quot;printf#percentw&quot;&gt;%w&lt;/a&gt;, and &lt;a href=&quot;printf#percentz&quot;&gt;%z&lt;/a&gt;) that are useful both internally to SQLite and to applications using SQLite. Standard library printf()s cannot normally be extended in this way.</source>
          <target state="translated">SQLite中的printf（）支持新的非标准替换类型（&lt;a href=&quot;printf#percentq&quot;&gt;％q&lt;/a&gt;，&lt;a href=&quot;printf#percentq&quot;&gt;％Q&lt;/a&gt;，&lt;a href=&quot;printf#percentw&quot;&gt;％w&lt;/a&gt;和&lt;a href=&quot;printf#percentz&quot;&gt;％z&lt;/a&gt;），这些替换类型在内部对SQLite以及使用SQLite的应用程序均有用。通常无法以这种方式扩展标准库的printf（）s。</target>
        </trans-unit>
        <trans-unit id="0592c94ffabf868a1145cae373098959875b4ffd" translate="yes" xml:space="preserve">
          <source>The printf(FORMAT,...) SQL function works like the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; C-language function and the printf() function from the standard C library. The first argument is a format string that specifies how to construct the output string using values taken from subsequent arguments. If the FORMAT argument is missing or NULL then the result is NULL. The %n format is silently ignored and does not consume an argument. The %p format is an alias for %X. The %z format is interchangeable with %s. If there are too few arguments in the argument list, missing arguments are assumed to have a NULL value, which is translated into 0 or 0.0 for numeric formats or an empty string for %s. See the &lt;a href=&quot;printf&quot;&gt;built-in printf()&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">SQL函数printf（FORMAT，...）类似于&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt; C语言函数和标准C库中的printf（）函数。第一个参数是格式字符串，该格式字符串指定如何使用从后续参数获取的值构造输出字符串。如果FORMAT参数丢失或为NULL，则结果为NULL。 ％n格式将被静默忽略，并且不使用任何参数。 ％p格式是％X的别名。 ％z格式可以与％s互换。如果参数列表中的参数太少，则假定缺少的参数具有NULL值，对于数字格式，它将转换为0或0.0；对于％s，它将转换为空字符串。有关其他信息，请参见&lt;a href=&quot;printf&quot;&gt;内置的printf（）&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="f7aa000e854fa1e51d2a8e3276f08d834816bb0a" translate="yes" xml:space="preserve">
          <source>The private memory cell is initialized to NULL by the first two instructions. Instructions 2 through 13 implement the inner SELECT statement against the examp2 table. Notice that instead of sending the result to a callback or storing the result on a sorter, the result of the query is pushed into the memory cell by instruction 10 and the loop is abandoned by the jump at instruction 11. The jump at instruction at 11 is vestigial and never executes.</source>
          <target state="translated">前两条指令将私有内存单元初始化为NULL。指令2到13实现了对examp2表的内部SELECT语句。请注意,查询的结果不是发送到回调或存储在分拣机上,而是由指令10将查询结果推送到内存单元中,并由指令11处的跳转放弃循环。11号指令处的跳转是残缺的,从来没有执行过。</target>
        </trans-unit>
        <trans-unit id="576c1ad7241fb816002c325b35c536b5acba643f" translate="yes" xml:space="preserve">
          <source>The problem is that the indexes are not of equal quality. A check-in is likely to only have one child. So the first field of PLINK_I1 will usually narrow down the search to just a single row. But there are thousands and thousands check-ins tagged with &quot;trunk&quot;, so the first field of TAGXREF_I1 will be of little help in narrowing down the search.</source>
          <target state="translated">问题是,指数的质量不一样。一个签到很可能只有一个孩子。所以PLINK_I1的第一个字段通常会将搜索范围缩小到只有一行。但是有成千上万的带有 &quot;主干 &quot;标签的签入,所以TAGXREF_I1的第一个字段对缩小搜索范围帮助不大。</target>
        </trans-unit>
        <trans-unit id="4910b74e848d7f84054aa8b42c2da7951eb8cf1a" translate="yes" xml:space="preserve">
          <source>The problem of dynamic memory allocation, and specifically the problem of a memory allocator breakdown, has been studied by J. M. Robson and the results published as:</source>
          <target state="translated">J.M.Robson对动态内存分配问题,特别是内存分配器故障问题进行了研究,结果发表为:。</target>
        </trans-unit>
        <trans-unit id="c0e48a1c7e6fc766c0233c83a22616959f0ed84b" translate="yes" xml:space="preserve">
          <source>The problem of finding the best query plan is equivalent to finding a minimum-cost path through the graph that visits each node exactly once.</source>
          <target state="translated">寻找最佳查询计划的问题相当于在图中寻找一条最小成本的路径,它能准确地访问每个节点一次。</target>
        </trans-unit>
        <trans-unit id="0f52798620170b176ff3d3af06fd50b65930b59c" translate="yes" xml:space="preserve">
          <source>The problem was fixed on 2011-02-20. The fix first appears in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;version 3.7.6&lt;/a&gt; (2011-04-12).</source>
          <target state="translated">该问题已于2011-02-20修复。该修复程序首先出现在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;版本3.7.6&lt;/a&gt;（2011-04-12）中。</target>
        </trans-unit>
        <trans-unit id="0a9231ded77785fbf75b111ccef695ba60c384a1" translate="yes" xml:space="preserve">
          <source>The problem with looking up information by rowid is that you probably do not care what the price of &quot;item 4&quot; is - you want to know the price of peaches. And so a rowid lookup is not helpful.</source>
          <target state="translated">通过rowid查找信息的问题是,你可能并不关心 &quot;物品4 &quot;的价格是多少--你想知道桃子的价格。所以用rowid查找是没有帮助的。</target>
        </trans-unit>
        <trans-unit id="5ca928318271d59121bcae8c1e00c91157b277dc" translate="yes" xml:space="preserve">
          <source>The problem with this latter query is that it must apply the contained_in() function to millions of entries in the demo_data table. The use of the R*Tree in the penultimate query reduces the number of calls to contained_in() function to a small subset of the entire table. The R*Tree index did not find the exact answer itself, it merely limited the search space.</source>
          <target state="translated">后一个查询的问题是,它必须对demo_data表中的数百万个条目应用contains_in()函数。在倒数第二个查询中使用了R*Tree,将对contains_in()函数的调用次数减少到整个表的一个小子集。R*Tree索引本身并没有找到准确的答案,它只是限制了搜索空间。</target>
        </trans-unit>
        <trans-unit id="4d80ba47d569d0e4a2a3e8f3108543e7f76afec3" translate="yes" xml:space="preserve">
          <source>The procedure used to detect a</source>
          <target state="translated">用于检测的程序</target>
        </trans-unit>
        <trans-unit id="7c5ac2fd9c78337a35d0c9980fe79b8e26f93a08" translate="yes" xml:space="preserve">
          <source>The process is explained at &lt;a href=&quot;http://wiki.tcl-lang.org/21708&quot;&gt;http://wiki.tcl-lang.org/21708&lt;/a&gt;.</source>
          <target state="translated">该过程在&lt;a href=&quot;http://wiki.tcl-lang.org/21708&quot;&gt;http://wiki.tcl-lang.org/21708&lt;/a&gt;上进行了说明。</target>
        </trans-unit>
        <trans-unit id="6eeaa105f7c556f91bf9c6156b767ca4d840a8c0" translate="yes" xml:space="preserve">
          <source>The progress callback can be used to display the status of a lengthy query or to process GUI events during a lengthy query.</source>
          <target state="translated">进度回调可用于显示冗长查询的状态或在冗长查询期间处理GUI事件。</target>
        </trans-unit>
        <trans-unit id="c69ceeecbdd66434afc39e336822e8ab81198858" translate="yes" xml:space="preserve">
          <source>The progress handler callback must not do anything that will modify the database connection that invoked the progress handler. Note that &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">进度处理程序回调不得做任何会修改调用进度处理程序的数据库连接的操作。请注意，在本段中，&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;都修改了其数据库连接，以实现&amp;ldquo;修改&amp;rdquo;的含义。</target>
        </trans-unit>
        <trans-unit id="cfdeee9bdc15af91672d8ad9f38656051ea8a13d" translate="yes" xml:space="preserve">
          <source>The progress handler callback must not do anything that will modify the database connection that invoked the progress handler. Note that &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">进度处理程序回调不得做任何会修改调用进度处理程序的数据库连接的操作。请注意，在本段中，&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;和&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;都修改了其数据库连接，以实现&amp;ldquo;修改&amp;rdquo;的含义。</target>
        </trans-unit>
        <trans-unit id="d0b8dc8c8f3e20ba03797e52e7e128023b09d0a3" translate="yes" xml:space="preserve">
          <source>The properties of the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; and &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; commands described above only apply if foreign keys are enabled. If the user considers them undesirable, then the workaround is to use &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; to disable foreign key constraints before executing the DROP or ALTER TABLE command. Of course, while foreign key constraints are disabled, there is nothing to stop the user from violating foreign key constraints and thus creating an internally inconsistent database.</source>
          <target state="translated">上面描述的&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;和&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;命令的属性仅在启用外键的情况下适用。如果用户认为它们不受欢迎，则解决方法是在执行DROP或ALTER TABLE命令之前，使用&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt;禁用外键约束。当然，在禁用外键约束的同时，也没有什么可以阻止用户违反外键约束，从而创建一个内部不一致的数据库。</target>
        </trans-unit>
        <trans-unit id="12341c72ae5851f82e7e9d06ed859f6acb79d027" translate="yes" xml:space="preserve">
          <source>The prover that determines whether any column of the right-hand table of a LEFT JOIN must be non-NULL in the WHERE clause is imperfect. It sometimes returns a false negative. In other words, it sometimes fails to reduce the strength of a LEFT JOIN when doing so was in fact possible. For example, the prover does not know the &lt;a href=&quot;lang_datefunc&quot;&gt;datetime() SQL function&lt;/a&gt; will always return NULL if its first argument is NULL, and so it will not recognize that the LEFT JOIN in the following query could be strength-reduced:</source>
          <target state="translated">确定WHERE子句中LEFT JOIN右侧表的任何列是否必须为非NULL的证明者是不完善的。有时会返回假阴性。换句话说，有时可能无法降低左联接的强度。例如，证明者不知道如果&lt;a href=&quot;lang_datefunc&quot;&gt;datetime（）SQL函数&lt;/a&gt;的第一个参数为NULL，则它将始终返回NULL，因此它无法识别以下查询中的LEFT JOIN可以降低强度：</target>
        </trans-unit>
        <trans-unit id="48a058bacf71fa48c37c493961b3f8857c5bcde0" translate="yes" xml:space="preserve">
          <source>The psow query parameter overrides the &lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt; property of the database file being opened. The psow query parameter works with the default windows and unix &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; but might be a no-op for other proprietary or non-standard VFSes.</source>
          <target state="translated">psow查询参数将&lt;a href=&quot;psow&quot;&gt;覆盖&lt;/a&gt;正在打开的数据库文件的powersafe overwrite属性。psow查询参数可与默认的Windows和UNIX &lt;a href=&quot;vfs&quot;&gt;VFS一起使用，&lt;/a&gt;但对于其他专有或非标准VFS可能是无效的。</target>
        </trans-unit>
        <trans-unit id="ffe108cd06e0c16c268bec90ba5007639fcc32ef" translate="yes" xml:space="preserve">
          <source>The pthreads interface provides the pthread_cond_wait() function. This function allows the caller to simultaneously release a mutex and start waiting for an asynchronous signal. Using this function, a &quot;fired&quot; flag and a mutex, the race-condition described above may be eliminated as follows:</source>
          <target state="translated">pthreads接口提供了pthread_cond_wait()函数。这个函数允许调用者同时释放一个mutex并开始等待一个异步信号。使用该函数、&quot;fireed &quot;标志和mutex,可以消除上述的竞赛条件,具体如下。</target>
        </trans-unit>
        <trans-unit id="5730c4be2fce644af4a3a0b4f7bf8a21afa9d144" translate="yes" xml:space="preserve">
          <source>The pthreads library is needed to make SQLite threadsafe. But since the CLI is single threaded, we could instruct SQLite to build in a non-threadsafe mode and thereby omit the pthreads library:</source>
          <target state="translated">pthreads库是使SQLite线程安全的需要。但由于CLI是单线程的,我们可以指示SQLite在非线程安全模式下构建,从而省略pthreads库。</target>
        </trans-unit>
        <trans-unit id="ead084e5ac51c3a25e7e77f7295b3ad410aff0a2" translate="yes" xml:space="preserve">
          <source>The purpose of the master journal is to ensure that multi-file transactions are atomic across a power-loss. But if the database files have other settings that compromise integrity across a power-loss event (such as &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=MEMORY&lt;/a&gt;) then the creation of the master journal is omitted, as an optimization.</source>
          <target state="translated">主日志的目的是确保跨功耗的多文件事务是原子的。但是，如果数据库文件具有其他设置，这些设置会在掉电事件中危及完整性（例如&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMAynchronized = OFF&lt;/a&gt;或&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = MEMORY&lt;/a&gt;），那么作为优化，将省略主日志的创建。</target>
        </trans-unit>
        <trans-unit id="80a4c796df15be02f28a9491edc718e0a6ad327d" translate="yes" xml:space="preserve">
          <source>The purpose of the other files and folders is presently unknown to the author but is probably not difficult to figure out.</source>
          <target state="translated">其他文件和文件夹的用途目前笔者不得而知,但大概不难弄清楚。</target>
        </trans-unit>
        <trans-unit id="f221997932c715d1cdc1bd2a990d3e44e81c153a" translate="yes" xml:space="preserve">
          <source>The purpose of the super-journal is to ensure that multi-file transactions are atomic across a power-loss. But if the database files have other settings that compromise integrity across a power-loss event (such as &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=MEMORY&lt;/a&gt;) then the creation of the super-journal is omitted, as an optimization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad934bb2af516663297a114c16808bb7efaf019" translate="yes" xml:space="preserve">
          <source>The purpose of the wal-index is to answer this question quickly:</source>
          <target state="translated">华尔指数的目的就是为了快速回答这个问题。</target>
        </trans-unit>
        <trans-unit id="138e57468a79af5c77be9bf617137e42c028e084" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to argue in favor of a fourth new category of application file format: An SQLite database file.</source>
          <target state="translated">本文件的目的是为了论证支持第四类新的应用文件格式。SQLite数据库文件。</target>
        </trans-unit>
        <trans-unit id="a73682c963786c3512a8e2606835fb2fa3f30921" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to brief the reader on how SQLite development team functions on a daily basis, as they continuously enhance the SQLite software and work to improve its already high reliability. The document achieves its purpose if a competent developer can be assimilated into the development team quickly after perusing this document.</source>
          <target state="translated">本文档的目的是向读者简要介绍SQLite开发团队在日常工作中是如何运作的,因为他们在不断增强SQLite软件的功能,并努力提高其本来就很高的可靠性。如果一个有能力的开发人员在通读本文档后能迅速融入开发团队,那么本文档就达到了目的。</target>
        </trans-unit>
        <trans-unit id="634e9e567d1f1f2dd99eda8c5536d500fa1e6e07" translate="yes" xml:space="preserve">
          <source>The push-down optimization cannot always be used. For example, if the subquery contains a LIMIT, then pushing down any part of the WHERE clause from the outer query could change the result of the inner query. There are other restrictions, explained in a comment in the source code on the pushDownWhereTerms() routine that implements this optimization.</source>
          <target state="translated">不能总是使用下推优化。例如,如果子查询包含一个LIMIT,那么从外部查询中推倒WHERE子句的任何部分都可能改变内部查询的结果。还有其他的限制,在源代码中关于实现这个优化的pushDownWhereTerms()例程的注释中会有解释。</target>
        </trans-unit>
        <trans-unit id="95403298754cba937ffb2896cd7e77d09dc82fdd" translate="yes" xml:space="preserve">
          <source>The quality management plan was originally composed by going through the description of outputs in section 11 of DO-178B (pages 48 through 56) and writing down those elements that seemed relevant to SQLite. The text will be subsequent revised to track enhancements to the SQLite quality process.</source>
          <target state="translated">质量管理计划最初是通过浏览DO-178B第11节(第48至56页)中的产出描述,并写下那些似乎与SQLite相关的内容。随后将对该案文进行修订,以跟踪SQLite质量程序的改进情况。</target>
        </trans-unit>
        <trans-unit id="06064891cfb2016593d8db9b131661701e81d4c1" translate="yes" xml:space="preserve">
          <source>The query above could be made to run faster by using the FTS &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo&lt;/a&gt; function to determine the number of query term instances that appear in each result. The matchinfo function is much more efficient than the offsets function. Furthermore, the matchinfo function provides extra information regarding the overall number of occurrences of each query term in the entire document set (not just the current row) and the number of documents in which each query term appears. This may be used (for example) to attach a higher weight to less common terms which may increase the overall computed relevancy of those results the user considers more interesting.</source>
          <target state="translated">通过使用FTS &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo&lt;/a&gt;函数确定出现在每个结果中的查询词实例的数量，可以使上面的查询运行得更快。 matchinfo函数比offsets函数有效得多。此外，matchinfo函数提供有关整个文档集中（不仅是当前行）每个查询词的出现总数以及每个查询词出现在其中的文档数的额外信息。这可以用于（例如）将较高的权重附加到不太常见的术语上，这可以增加用户认为更有趣的那些结果的总体计算相关性。</target>
        </trans-unit>
        <trans-unit id="418f38a31900c8102303fe91cea3cb03a0bfc91a" translate="yes" xml:space="preserve">
          <source>The query above could be rewritten as a join and without the use of row values:</source>
          <target state="translated">上面的查询可以改写为连接,而不使用行值。</target>
        </trans-unit>
        <trans-unit id="8505932c272eacf13a6ac016c3034294904230a0" translate="yes" xml:space="preserve">
          <source>The query above will return suggestions for the whole input word that begins with $prefix. The $wholeline parameter is all text from the beginning of the line up to the insertion point. The $wholeline parameter is used for context.</source>
          <target state="translated">上面的查询将返回以$prefix开头的整个输入词的建议。$wholeline参数是指从行首到插入点的所有文本。$wholeline参数用于上下文。</target>
        </trans-unit>
        <trans-unit id="f9921b4f3858e29c8d8f50be7ccdabc32d452e7c" translate="yes" xml:space="preserve">
          <source>The query above will use the po_parent index to help find the answer, since the po_parent index contains entries for all rows of interest. Note that since po_parent is smaller than a full index, the query will likely run faster too.</source>
          <target state="translated">上面的查询将使用po_parent索引来帮助找到答案,因为po_parent索引包含了所有相关记录的条目。需要注意的是,由于po_parent索引比完整索引小,所以查询的运行速度也会更快。</target>
        </trans-unit>
        <trans-unit id="0190a12968e1ccf51186372beeb26ae3012cb0b9" translate="yes" xml:space="preserve">
          <source>The query above would very quickly locate the id of 1 even if the R*Tree contained millions of entries. The previous is an example of a &quot;contained-within&quot; query. The R*Tree also supports &quot;overlapping&quot; queries. For example, to find all bounding boxes that overlap the Charlotte area:</source>
          <target state="translated">即使R*Tree中包含了数百万个条目,上面的查询也会非常快速地找到1的id。前面是一个 &quot;包含-内 &quot;查询的例子。R*Tree还支持 &quot;重叠 &quot;查询。例如,要找到所有与Charlotte区域重叠的边界框。</target>
        </trans-unit>
        <trans-unit id="94364d8100096142da610b0a18f63efa10ad070a" translate="yes" xml:space="preserve">
          <source>The query component of a URI may contain parameters that are interpreted either by SQLite itself, or by a &lt;a href=&quot;../vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;custom VFS implementation&lt;/a&gt;. SQLite and its built-in &lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; interpret the following query parameters:</source>
          <target state="translated">URI的查询组件可能包含由SQLite本身或由&lt;a href=&quot;../vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;自定义VFS实现&lt;/a&gt;解释的参数。SQLite及其内置的&lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt;解释以下查询参数：</target>
        </trans-unit>
        <trans-unit id="86e91a7c9e388f3708828edd53ce0492e58dcf0d" translate="yes" xml:space="preserve">
          <source>The query component of a URI may contain parameters that are interpreted either by SQLite itself, or by a &lt;a href=&quot;vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;custom VFS implementation&lt;/a&gt;. SQLite and its built-in &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; interpret the following query parameters:</source>
          <target state="translated">URI的查询组件可能包含由SQLite本身或由&lt;a href=&quot;vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;自定义VFS实现&lt;/a&gt;解释的参数。SQLite及其内置的&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;解释以下查询参数：</target>
        </trans-unit>
        <trans-unit id="f6f2f3df836d46d9540098c193cbe7de6978b27d" translate="yes" xml:space="preserve">
          <source>The query contains both a search restriction in the WHERE clause and a sort order in the ORDER BY clause. Both the search and the sort can be accomplished at the same time using the two-column index Idx3.</source>
          <target state="translated">这个查询包含了WHERE子句中的搜索限制和ORDER BY子句中的排序顺序,搜索和排序都可以通过使用两列索引Idx3同时完成。搜索和排序都可以使用双列索引Idx3同时完成。</target>
        </trans-unit>
        <trans-unit id="bb441cf385ae38b5e50765b319372e3b2d5a50b2" translate="yes" xml:space="preserve">
          <source>The query does a binary search on the index to find the subset of rows that have fruit='Orange'. (Because the fruit column is the left-most column of the index and the rows of the index are in sorted order, all such rows will be adjacent.) Then it scans the matching index rows from top to bottom to get the rowids for the original table, and for each rowid does a binary search on the original table to find the price.</source>
          <target state="translated">该查询在索引上进行二进制搜索,以查找fruit='Orange'的行的子集。(因为fruit列是索引的最左边的一列,而索引的行是按顺序排列的,所以所有这样的行都会相邻)。然后它从上到下扫描匹配的索引行,得到原表的rowid,并对每个rowid在原表上进行二元搜索,找到价格。</target>
        </trans-unit>
        <trans-unit id="0da70d4a5a91c3bdacf749b9198a4a57a477e008" translate="yes" xml:space="preserve">
          <source>The query is not an aggregate</source>
          <target state="translated">查询不是一个集合</target>
        </trans-unit>
        <trans-unit id="d5463ef5a6e2ace12b54dcf259b0837fe48d0c3a" translate="yes" xml:space="preserve">
          <source>The query loop is built from instructions 5 through 13. Instructions 6 through 8 build a record that contains the azData[] values for a single invocation of the callback. A sort key is generated by instructions 9 through 11. Instruction 12 combines the invocation record and the sort key into a single entry and puts that entry on the sort list.</source>
          <target state="translated">查询循环是由指令5到13建立的。指令6到指令8建立一条记录,其中包含回调的一次调用的azData[]值。排序键由指令9到11生成。指令12将调用记录和排序键合并为一个条目,并将该条目放在排序列表中。</target>
        </trans-unit>
        <trans-unit id="b89b1eb2c0211443a7be50a77507c951f5a3834f" translate="yes" xml:space="preserve">
          <source>The query loop is implemented by instructions 8 through 22. The aggregate key specified by the GROUP BY clause is computed by instructions 9 and 10. Instruction 11 causes the appropriate bucket to come into focus. If a bucket with the given key does not already exists, a new bucket is created and control falls through to instructions 12 and 13 which initialize the bucket. If the bucket does already exist, then a jump is made to instruction 14. The values of aggregate functions are updated by the instructions between 11 and 21. Instructions 14 through 18 update memory slot 1 to hold the next value &quot;min(three+four)&quot;. Then the sum of the &quot;four&quot; column is updated by instructions 19 through 21.</source>
          <target state="translated">查询循环由指令8到22实现。由GROUP BY子句指定的集合键由指令9和10计算。指令11使适当的桶成为焦点。如果具有给定键的bucket还不存在,则创建一个新的bucket,控制权落到指令12和13,这两条指令初始化bucket。如果 bucket 已经存在,则跳转到指令 14。汇总函数的值由11到21之间的指令更新。指令14到18更新内存槽1,以保持下一个值 &quot;min(three+four)&quot;。然后由指令19到21更新 &quot;四 &quot;列的和。</target>
        </trans-unit>
        <trans-unit id="a6ac9b746a0ebf6db3c5dac60c7fc4d3c527912f" translate="yes" xml:space="preserve">
          <source>The query optimizer might translate this into three separate constraints:</source>
          <target state="translated">查询优化器可以将其转化为三个独立的约束条件。</target>
        </trans-unit>
        <trans-unit id="ca7f72fc82a7c6f8223569dbd345a23847f45a71" translate="yes" xml:space="preserve">
          <source>The query optimizer now attempts to implement the ORDER BY clause using an index. Sorting is still used if not suitable index is available.</source>
          <target state="translated">查询优化器现在尝试使用索引来实现ORDER BY子句。如果没有合适的索引,仍然会使用排序。</target>
        </trans-unit>
        <trans-unit id="074dd395e411c2a7564e05c9a803ff7d91501e5c" translate="yes" xml:space="preserve">
          <source>The query planner considers the LIMIT clause when estimating the cost of ORDER BY.</source>
          <target state="translated">查询规划师在估算ORDER BY的成本时,会考虑LIMIT子句。</target>
        </trans-unit>
        <trans-unit id="efb22d31da7b95dc237d9b06fed089e63b961bd2" translate="yes" xml:space="preserve">
          <source>The query planner examines the values of bound parameters to help determine if a partial index is usable.</source>
          <target state="translated">查询规划器检查约束参数的值,以帮助确定部分索引是否可用。</target>
        </trans-unit>
        <trans-unit id="e51e3ffe015829441eac83092590224609d07ba7" translate="yes" xml:space="preserve">
          <source>The query planner in SQLite normally does a terrific job of selecting fast algorithms for running your SQL statements. This is true of the legacy query planner and even more true of the new NGQP. There may be an occasional situation where, due to incomplete information, the query planner selects a suboptimal plan. This will happen less often with the NGQP than with the legacy query planner, but it might still happen. Only in those rare cases do application developers need to get involved and help the query planner to do the right thing. In the common case, the NGQP is just a new enhancement to SQLite that makes the application run a little faster and which requires no new developer thought or action.</source>
          <target state="translated">SQLite中的查询规划器通常在选择运行SQL语句的快速算法方面做得非常出色。传统的查询规划器如此,新的NGQP更是如此。偶尔会出现这样的情况:由于信息不完整,查询规划器选择了一个次优的计划。这种情况在NGQP中发生的频率会比在传统查询规划器中发生的频率要低,但仍有可能发生。只有在这些极少数情况下,应用开发人员才需要参与进来,帮助查询规划器做正确的事情。在常见的情况下,NGQP只是对SQLite的一个新的增强,它使应用程序的运行速度更快一些,它不需要开发人员有新的想法或行动。</target>
        </trans-unit>
        <trans-unit id="7056feb20ef72b761795635d81c08e5ed2af62a2" translate="yes" xml:space="preserve">
          <source>The query planner in future versions of SQLite might grow smart enough to make transformations such as the above automatically, in both directions. That is to say, future versions of SQLite might transform queries of the first form into the second, or queries written the second way into the first. As of SQLite version 3.22.0 (2018-01-22), the query planner will flatten the subquery if the outer query does not make use of any user-defined functions or subqueries in its result set. For the examples shown above, however, SQLite implements each of the queries as written.</source>
          <target state="translated">未来版本的SQLite中的查询规划器可能会长得足够聪明,可以自动地进行如上的转换,双向转换。也就是说,未来版本的SQLite可能会将第一种形式的查询转化为第二种形式,或者将第二种方式写的查询转化为第一种方式。从SQLite 3.22.0版本(2018-01-22)开始,如果外层查询的结果集中没有使用任何用户定义的函数或子查询,查询规划器将扁平化子查询。然而,对于上面显示的例子,SQLite按照编写的方式实现了每个查询。</target>
        </trans-unit>
        <trans-unit id="f9ae7f14e38f472239e8cbf47519f9f962bf6c41" translate="yes" xml:space="preserve">
          <source>The query planner is able to optimize IN operators on &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; even if the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method does not set the sqlite3_index_constraint_usage.omit flag of the virtual table column to the left of the IN operator.</source>
          <target state="translated">即使&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;方法未将虚拟表列的sqlite3_index_constraint_usage.omit标志设置在IN运算符的左侧，查询计划程序仍可以优化&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;上的IN运算符。</target>
        </trans-unit>
        <trans-unit id="4b67d5103aec179badd00d13df4b687ed31a2fd8" translate="yes" xml:space="preserve">
          <source>The query planner is more aggressive about using &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexes&lt;/a&gt; for views and subqueries for which it is not possible to create a persistent index.</source>
          <target state="translated">查询计划者对于无法为其创建持久索引的视图和子查询使用&lt;a href=&quot;optoverview#autoindex&quot;&gt;自动索引&lt;/a&gt;更具攻击性。</target>
        </trans-unit>
        <trans-unit id="0ff80f93923c8ea0ed391da80428d773af3f58c7" translate="yes" xml:space="preserve">
          <source>The query planner is now able to use &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt; that contain AND-connected terms in the WHERE clause.</source>
          <target state="translated">现在，查询计划器可以使用在WHERE子句中包含AND连接项的&lt;a href=&quot;partialindex&quot;&gt;部分索引&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1bf26dc5394aa893fb29edbb88f7b0f3c1a3bf4" translate="yes" xml:space="preserve">
          <source>The query planner loads the content of the statistics tables into memory when the schema is read. Hence, when an application changes the statistics tables directly, SQLite will not immediately notice the changes. An application can force the query planner to reread the statistics tables by running &lt;b&gt;ANALYZE sqlite_master&lt;/b&gt;.</source>
          <target state="translated">读取架构时，查询计划器会将统计信息表的内容加载到内存中。因此，当应用程序直接更改统计表时，SQLite将不会立即注意到这些更改。应用程序可以通过运行&lt;b&gt;ANALYZE sqlite_master&lt;/b&gt;来强制查询计划程序重新读取统计信息表。</target>
        </trans-unit>
        <trans-unit id="b54043d2a3881a0e42bb93d2a4b188d8e3b927bd" translate="yes" xml:space="preserve">
          <source>The query planner loads the content of the statistics tables into memory when the schema is read. Hence, when an application changes the statistics tables directly, SQLite will not immediately notice the changes. An application can force the query planner to reread the statistics tables by running &lt;b&gt;ANALYZE sqlite_schema&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764ebb928a21a2403e7ad4384e4177e72689b2ef" translate="yes" xml:space="preserve">
          <source>The query planner must decide between many possible implementations of this query, but two plans in particular are of note:</source>
          <target state="translated">查询规划者必须在这个查询的许多可能的实现中做出决定,但有两个计划特别值得注意。</target>
        </trans-unit>
        <trans-unit id="35937457496b4c465e761e374d83f1c328cfb649" translate="yes" xml:space="preserve">
          <source>The query planner now does a better job of optimizing &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; accesses in a 3-way or higher join where constraints on the virtual table are split across two or more other tables of the join.</source>
          <target state="translated">现在，查询计划器可以更好地优化3向或更高连接中的&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;访问，其中虚拟表上的约束分布在两个或多个其他连接表中。</target>
        </trans-unit>
        <trans-unit id="ecefb9cd6e1de2d9ed81b2814e874ca9b432f553" translate="yes" xml:space="preserve">
          <source>The query planner now prefers to implement FROM-clause subqueries using &lt;a href=&quot;optoverview#coroutines&quot;&gt;co-routines&lt;/a&gt; rather using the &lt;a href=&quot;optoverview#flattening&quot;&gt;query flattener&lt;/a&gt; optimization. Support for the use of co-routines for subqueries may no longer be disabled.</source>
          <target state="translated">现在，查询计划者更喜欢使用&lt;a href=&quot;optoverview#coroutines&quot;&gt;协例程&lt;/a&gt;而不是&lt;a href=&quot;optoverview#flattening&quot;&gt;查询展平器&lt;/a&gt;优化来实现FROM子句子查询。可能不再禁用对子查询使用协同例程的支持。</target>
        </trans-unit>
        <trans-unit id="39ca8ebd42e9f170c8e29a8cb05c453c4287996d" translate="yes" xml:space="preserve">
          <source>The query planner now recognizes that any column in the right-hand table of a LEFT JOIN can be NULL, even if that column has a NOT NULL constraint. Avoid trying to optimize out NULL tests in those cases. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7ed&lt;/a&gt;.</source>
          <target state="translated">现在，查询计划器可以识别LEFT JOIN右侧表中的任何列都可以为NULL，即使该列具有NOT NULL约束。在这种情况下，请避免尝试优化NULL测试。修复票证&lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7ed&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec8769590db8f2b5c877d645663be729be900155" translate="yes" xml:space="preserve">
          <source>The query planner now uses &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; information (created by &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;) to help determine if the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; is appropriate.</source>
          <target state="translated">现在，查询计划器使用&lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;信息（由&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;创建）来帮助确定&lt;a href=&quot;optoverview#skipscan&quot;&gt;跳过扫描优化&lt;/a&gt;是否合适。</target>
        </trans-unit>
        <trans-unit id="c31a7ce3fe100e3f0ec40a06c5c355aa9ab9699f" translate="yes" xml:space="preserve">
          <source>The query planner used &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;-style statistics for one or more indexes of the table at some point during the lifetime of the current connection.</source>
          <target state="translated">查询计划程序在当前连接的生存期内的某个时候对表的一个或多个索引使用了&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;样式的统计信息。</target>
        </trans-unit>
        <trans-unit id="a97e7a7c05ace47af23f942a5bb054692500ea21" translate="yes" xml:space="preserve">
          <source>The query planner uses a full scan of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; instead of a full scan of the main table, in cases where that makes sense.</source>
          <target state="translated">在这种情况下，查询计划程序将使用&lt;a href=&quot;partialindex&quot;&gt;部分索引&lt;/a&gt;的完整扫描而不是主表的完整扫描。</target>
        </trans-unit>
        <trans-unit id="5c0c2991e6f563d6716af52b8b617039da1f2fdd" translate="yes" xml:space="preserve">
          <source>The query starts by doing a binary search on the Idx1 index for entries that have fruit='Peach'. SQLite can do this binary search on the Idx1 index but not on the original FruitsForSale table because the rows in Idx1 are sorted by the &quot;fruit&quot; column. Having found a row in the Idx1 index that has fruit='Peach', the database engine can extract the rowid for that row. Then the database engines does a second binary search on the original FruitsForSale table to find the original row that contains fruit='Peach'. From the row in the FruitsForSale table, SQLite can then extract the value of the price column. This procedure is illustrated by &lt;a href=&quot;#fig5&quot;&gt;figure 5&lt;/a&gt;.</source>
          <target state="translated">该查询从对Idx1索引进行二进制搜索开始，以查找具有fruit ='Peach'的条目。 SQLite可以在Idx1索引上执行此二进制搜索，但不能在原始FruitsForSale表上执行此二进制搜索，因为Idx1中的行按&amp;ldquo;水果&amp;rdquo;列排序。在Idx1索引中找到具有fruit ='Peach'的行之后，数据库引擎可以提取该行的rowid。然后，数据库引擎对原始FruitsForSale表进行第二次二进制搜索，以找到包含fruit ='Peach'的原始行。然后，从FruitsForSale表的行中，SQLite可以提取price列的值。该过程由&lt;a href=&quot;#fig5&quot;&gt;图5&lt;/a&gt;示出。</target>
        </trans-unit>
        <trans-unit id="7d2f0fdfeb4c2c835aff8667a9df0a76c56f4c48" translate="yes" xml:space="preserve">
          <source>The query string is optional. If the query string is present, then all query parameters are passed through into the xOpen method of the underlying &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;.</source>
          <target state="translated">查询字符串是可选的。如果存在查询字符串，那么所有查询参数都将传递到基础&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;的xOpen方法中。</target>
        </trans-unit>
        <trans-unit id="85170b302d04cae08fe65e554bbdfb1393e9fe62" translate="yes" xml:space="preserve">
          <source>The query syntax has been revised where necessary to remove ambiguities and to make it possible to escape special characters in query terms.</source>
          <target state="translated">必要时对查询语法进行了修改,以消除歧义,并使查询术语中的特殊字符可以转义。</target>
        </trans-unit>
        <trans-unit id="6a08992b107064a2b4d32992f6db718c41160975" translate="yes" xml:space="preserve">
          <source>The query_only pragma prevents all changes to database files when enabled.</source>
          <target state="translated">query_only pragma 启用后,可以防止对数据库文件的所有更改。</target>
        </trans-unit>
        <trans-unit id="c227c47e0d2b0279a9dff3f8b02f840ecf77eb68" translate="yes" xml:space="preserve">
          <source>The quote(X) function returns the text of an SQL literal which is the value of its argument suitable for inclusion into an SQL statement. Strings are surrounded by single-quotes with escapes on interior quotes as needed. BLOBs are encoded as hexadecimal literals. Strings with embedded NUL characters cannot be represented as string literals in SQL and hence the returned string literal is truncated prior to the first NUL.</source>
          <target state="translated">quote(X)函数返回一个SQL文字的文本,这个文本是其参数的值,适合包含在SQL语句中。字符串由单引号包围,并根据需要在内部引号上进行转义。BLOBs被编码为十六进制文字。嵌入NUL字符的字符串在SQL中不能表示为字符串字元,因此返回的字符串字元在第一个NUL之前被截断。</target>
        </trans-unit>
        <trans-unit id="9f63b25a5004d971fa73a7b89854797c36e88a71" translate="yes" xml:space="preserve">
          <source>The random() function provides 64 bits of randomness instead of only 32 bits.</source>
          <target state="translated">random()函数提供了64位的随机性,而不是只有32位。</target>
        </trans-unit>
        <trans-unit id="db5db9919e511217ef7da4b79216c59c757f004b" translate="yes" xml:space="preserve">
          <source>The random() function returns a pseudo-random integer between -9223372036854775808 and +9223372036854775807.</source>
          <target state="translated">random()函数返回一个介于-9223372036854775808和+9223372036854775807之间的伪随机整数。</target>
        </trans-unit>
        <trans-unit id="dc66046ce33b1a2430fa7d3f10cb359cc80fae20" translate="yes" xml:space="preserve">
          <source>The randomblob(N) function return an N-byte blob containing pseudo-random bytes. If N is less than 1 then a 1-byte random blob is returned.</source>
          <target state="translated">randomblob(N)函数返回一个包含伪随机字节的N字节blob。如果N小于1,则返回一个1字节的随机blob。</target>
        </trans-unit>
        <trans-unit id="c291d5ba33f13d62c916974b77fcaf954ce3ff7e" translate="yes" xml:space="preserve">
          <source>The rank of the column within the index. (0 means left-most. Key columns come before auxiliary columns.)</source>
          <target state="translated">列在索引中的等级,(0表示最左,关键列在辅助列之前。)(0表示最左,关键列在辅助列之前。)</target>
        </trans-unit>
        <trans-unit id="0b2bd6ab8a45c757d36fc0179def745c6a1bbb66" translate="yes" xml:space="preserve">
          <source>The rank of the column within the index. (0 means left-most.)</source>
          <target state="translated">列在索引中的等级。(0表示最左边。)</target>
        </trans-unit>
        <trans-unit id="463c4210effd7ad2a8dada3187acf9269beea08a" translate="yes" xml:space="preserve">
          <source>The rank of the column within the table being indexed, or -1 if the index-column is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the table being indexed and -2 if the &lt;a href=&quot;expridx&quot;&gt;index is on an expression&lt;/a&gt;.</source>
          <target state="translated">被索引表中的列的排名；如果index-column是被索引表的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;，则为-1，如果&lt;a href=&quot;expridx&quot;&gt;索引位于expression上，则为&lt;/a&gt; -2 。</target>
        </trans-unit>
        <trans-unit id="84413b7d19914c0bede4000ce3b0ffb8491410c6" translate="yes" xml:space="preserve">
          <source>The rank of the column within the table being indexed. A value of -1 means &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; and a value of -2 means that an &lt;a href=&quot;expridx&quot;&gt;expression&lt;/a&gt; is being used.</source>
          <target state="translated">被索引表中列的等级。值-1表示&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;，值-2表示正在使用&lt;a href=&quot;expridx&quot;&gt;表达式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8754b3bec73ba7fde29d928b708ca495c5b77ae4" translate="yes" xml:space="preserve">
          <source>The rank of word.</source>
          <target state="translated">字的等级。</target>
        </trans-unit>
        <trans-unit id="2dd609ed9718452c7fad1b16788c833004253127" translate="yes" xml:space="preserve">
          <source>The rank option is used to change the default auxiliary function mapping for the rank column. The option should be set to a text value in the same format as described for &lt;a href=&quot;fts5#sorting_by_auxiliary_function_results&quot;&gt;&quot;rank MATCH ?&quot;&lt;/a&gt; terms above. For example:</source>
          <target state="translated">rank选项用于更改rank列的默认辅助功能映射。该选项应设置为与&lt;a href=&quot;fts5#sorting_by_auxiliary_function_results&quot;&gt;&amp;ldquo; rank MATCH？&amp;rdquo;&lt;/a&gt;所述格式相同的文本值。以上条款。例如：</target>
        </trans-unit>
        <trans-unit id="3e012920d09c510ffee894f9967688d5537ade9a" translate="yes" xml:space="preserve">
          <source>The rate of enhancement for SQLite over the previous five years (2010-2015) is approximately 6 increments of Y per year. The numbering format used by for &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; and &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; allows versions up to 3.999.999, which is more than enough for the planned end-of-support date for SQLite in 2050. However, the current tarball naming conventions only reserve two digits for the Y and so the naming format for downloads will need to be revised in about 2030.</source>
          <target state="translated">在过去的五年（2010-2015年）中，SQLite的增强速度约为每年Y的6个增量。&lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;和&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number（）&lt;/a&gt;使用的编号格式允许版本高达3.999.999，这对于2050年SQLite计划的支持终止日期已绰绰有余。但是，当前的tarball命名约定仅保留两位数字用于Y，因此需要在2030年左右修改下载的命名格式。</target>
        </trans-unit>
        <trans-unit id="e8a5095befc118ca6a6fec21354c920d6bd315d2" translate="yes" xml:space="preserve">
          <source>The reader algorithm in the previous paragraphs works correctly, but because frames for page P can appear anywhere within the WAL, the reader has to scan the entire WAL looking for page P frames. If the WAL is large (multiple megabytes is typical) that scan can be slow, and read performance suffers. To overcome this problem, a separate data structure called the wal-index is maintained to expedite the search for frames of a particular page.</source>
          <target state="translated">前面几段中的阅读器算法是正确的,但是由于P页的帧可以出现在WAL中的任何地方,所以阅读器必须扫描整个WAL来寻找P页的帧。如果WAL很大(典型的是多兆字节),这种扫描会很慢,读取性能也会受到影响。为了克服这个问题,我们维护了一个单独的数据结构,称为wal-index,以加快搜索某一页的帧。</target>
        </trans-unit>
        <trans-unit id="3e2fc6a74baa30b6fadb3fd43bce3110d90f198d" translate="yes" xml:space="preserve">
          <source>The readfile(X) SQL function reads the entire content of the file named X and returns that content as a BLOB. This can be used to load content into a table. For example:</source>
          <target state="translated">readfile(X)SQL函数读取名为X的文件的全部内容,并将这些内容以BLOB的形式返回。这可以用来将内容加载到一个表中。例如</target>
        </trans-unit>
        <trans-unit id="f5d4c0c9266d8eca05dca08f98a5cbf6d922d36a" translate="yes" xml:space="preserve">
          <source>The realization that an aggregate query is really two consecutive loops makes it much easier to understand the difference between a WHERE clause and a HAVING clause in SQL query statement. The WHERE clause is a restriction on the first loop and the HAVING clause is a restriction on the second loop. You can see this by adding both a WHERE and a HAVING clause to our example query:</source>
          <target state="translated">认识到聚合查询实际上是两个连续的循环,就更容易理解SQL查询语句中WHERE子句和HAVING子句的区别了。WHERE子句是对第一个循环的限制,HAVING子句是对第二个循环的限制。你可以通过在我们的示例查询中同时添加一个WHERE子句和一个HAVING子句来了解这一点。</target>
        </trans-unit>
        <trans-unit id="4a5758542d7b569e5728a8a94a0c5f527ec1ddfe" translate="yes" xml:space="preserve">
          <source>The reallocarray() interface is a recent innovation (circa 2014) from the OpenBSD community that grow out of efforts to prevent the next &lt;a href=&quot;http://heartbleed.com&quot;&gt;&quot;heartbleed&quot; bug&lt;/a&gt; by avoiding 32-bit integer arithmetic overflow on memory allocation size computations. The reallocarray() function has both unit-size and count parameters. To allocate memory sufficient to hold an array of N elements each X-bytes in size, one calls &quot;reallocarray(0,X,N)&quot;. This is preferred over the traditional technique of invoking &quot;malloc(X*N)&quot; as reallocarray() eliminates the risk that the X*N multiplication will overflow and cause malloc() to return a buffer that is a different size from what the application expected.</source>
          <target state="translated">reallocarray（）接口是OpenBSD社区的一项最新创新（大约于2014年），它通过避免内存分配大小计算中的32位整数算术溢出来防止下一个&lt;a href=&quot;http://heartbleed.com&quot;&gt;&amp;ldquo;令人讨厌的&amp;rdquo;错误&lt;/a&gt;。 reallocarray（）函数同时具有单位大小和计数参数。为了分配足够的内存来容纳每个X字节大小的N个元素的数组，一个调用&amp;ldquo; reallocarray（0，X，N）&amp;rdquo;。这优于调用&amp;ldquo; malloc（X * N）&amp;rdquo;的传统技术，因为reallocarray（）消除了X * N乘法将溢出并导致malloc（）返回与应用程序大小不同的缓冲区的风险。预期。</target>
        </trans-unit>
        <trans-unit id="a25a89f7da0624003a3e075ec1d5437a5611f942" translate="yes" xml:space="preserve">
          <source>The reason for attempting to read the</source>
          <target state="translated">试图阅读的原因。</target>
        </trans-unit>
        <trans-unit id="61ed3e5eacc7786aa96400e0606560d6b0c2919c" translate="yes" xml:space="preserve">
          <source>The reason for this is easy to understand: When a document is inserted into the FTS5 table, an entry is added to the full-text index to record the position of each token within the new document. When a document is removed, the original data is required in order to determine the set of entries that need to be removed from the full-text index. So if the data supplied to FTS5 when a row is deleted using this command is different from that used to determine the set of token instances when it was inserted, some full-text index entries may not be correctly deleted, or FTS5 may try to remove index entries that do not exist. This can leave the full-text index in an unpredictable state, making future query results unreliable.</source>
          <target state="translated">这样做的原因很容易理解。当一份文件被插入FTS5表时,全文索引中会增加一个条目,以记录新文件中每个标记的位置。当文档被删除时,需要原始数据来确定需要从全文索引中删除的条目集。因此,如果使用此命令删除某行时提供给 FTS5 的数据与插入时用于确定标记实例集的数据不同,则一些全文索引条目可能不会被正确删除,或者 FTS5 可能会尝试删除不存在的索引条目。这可能会使全文索引处于不可预测的状态,使未来的查询结果不可靠。</target>
        </trans-unit>
        <trans-unit id="aaf49440241f0d03e40af262860c9b5798f65bc8" translate="yes" xml:space="preserve">
          <source>The reason that the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; has its buffer pointer and buffer size arguments reversed from what is found in the standard library snprintf() routine is because there was no snprintf() routine in the standard C library when Hipp was first implementing his version, and he chose a different order than the designers of the standard C library.</source>
          <target state="translated">之所以说&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;有它的缓冲区指针和缓冲从什么是在标准库的snprintf发现逆转尺寸参数（）函数是因为在标准C库中没有的snprintf（）函数时希普首次实现他的版本，他选择的顺序与标准C库的设计人员不同。</target>
        </trans-unit>
        <trans-unit id="791eaa4dd6fb2ae12ed4b869340107d40b780f17" translate="yes" xml:space="preserve">
          <source>The reasons why C is the best language to implement SQLite include:</source>
          <target state="translated">C语言是实现SQLite的最佳语言的原因包括:。</target>
        </trans-unit>
        <trans-unit id="570c3cd1b218e89b5e9796c1a0c8bf3041d5fcd8" translate="yes" xml:space="preserve">
          <source>The recommended fix for this problem is to select a different filesystem. These days, there is a huge selection of high-performance, reliable, patent-free filesystems that support long filenames. Where possible, it is recommended that embedded devices use one of these other filesystems. This will avoid compatibility issues and the danger of &lt;a href=&quot;shortnames#db83corrupt&quot;&gt;database corruption caused by inconsistent use of 8+3 filenames&lt;/a&gt;.</source>
          <target state="translated">对于此问题，建议的解决方法是选择其他文件系统。如今，支持长文件名的高性能，可靠，免专利的文件系统种类繁多。在可能的情况下，建议嵌入式设备使用这些其他文件系统之一。这将避免兼容性问题，以及&lt;a href=&quot;shortnames#db83corrupt&quot;&gt;由于不一致使用8 + 3文件名而导致数据库损坏&lt;/a&gt;的危险。</target>
        </trans-unit>
        <trans-unit id="25181bcaf1df8e046a1c955d3b9df90abb750621" translate="yes" xml:space="preserve">
          <source>The recommended setting is 0, meaning that double-quoted strings are disallowed in all contexts. However, the default setting is 3 for maximum compatibility with legacy applications.</source>
          <target state="translated">建议设置为0,这意味着在所有情况下都不允许使用双引号字符串。但是,为了最大限度地与传统应用程序兼容,默认设置为3。</target>
        </trans-unit>
        <trans-unit id="932d02d128af056f356f5d45448ef957094cec8a" translate="yes" xml:space="preserve">
          <source>The recommended usage pattern for the &lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;analysis_limit&lt;/a&gt; pragma is like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e4e6885559253d0ddfdbd8cf19b8d22821af1f" translate="yes" xml:space="preserve">
          <source>The recommended way of creating, updating, listing, and extracting an SQLite Archive is to use the &lt;a href=&quot;cli&quot;&gt;sqlite3.exe command-line shell&lt;/a&gt; for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;version 3.23.0&lt;/a&gt; (2018-04-02) or later. This CLI supports the -A command-line option that allows easy management of SQLite Archives. The CLI for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;version 3.22.0&lt;/a&gt; (2018-01-22) has the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt; for managing SQLite Archives, but that requires interacting with the shell.</source>
          <target state="translated">创建，更新，列出和提取SQLite存档的推荐方法是将&lt;a href=&quot;cli&quot;&gt;sqlite3.exe命令行外壳&lt;/a&gt;用于SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;3.23.0&lt;/a&gt;（2018-04-02）或更高版本。此CLI支持-A命令行选项，该选项可轻松管理SQLite存档。用于SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;3.22.0版&lt;/a&gt;（2018-01-22）的CLI 具有用于管理SQLite存档的&lt;a href=&quot;cli#sqlar&quot;&gt;.archive命令&lt;/a&gt;，但是需要与Shell进行交互。</target>
        </trans-unit>
        <trans-unit id="4601afd19c62f4d6f4dd6a59905680482f9f3f16" translate="yes" xml:space="preserve">
          <source>The record format makes extensive use of the &lt;a href=&quot;fileformat2#varint&quot;&gt;variable-length integer&lt;/a&gt; or &lt;a href=&quot;fileformat2#varint&quot;&gt;varint&lt;/a&gt; representation of 64-bit signed integers defined above.</source>
          <target state="translated">记录格式大量使用了上面定义的64位带符号整数的&lt;a href=&quot;fileformat2#varint&quot;&gt;变长整数&lt;/a&gt;或&lt;a href=&quot;fileformat2#varint&quot;&gt;varint&lt;/a&gt;表示形式。</target>
        </trans-unit>
        <trans-unit id="6f45dfeab7c8fdea2c19dfb3263b7e954261008d" translate="yes" xml:space="preserve">
          <source>The register P3 contains one less than the maximum number of allowed errors. At most reg(P3) errors will be reported. In other words, the analysis stops as soon as reg(P1) errors are seen. Reg(P1) is updated with the number of errors remaining.</source>
          <target state="translated">寄存器P3中包含的错误比最大允许的错误数少一个。最多只能报告reg(P3)错误。换句话说,一旦看到reg(P1)错误,分析就会停止。reg(P1)会根据剩余的错误数更新。</target>
        </trans-unit>
        <trans-unit id="b0a0f881a2de041dc76deecadc2825d6252c40fe" translate="yes" xml:space="preserve">
          <source>The registers P1 through P1+P2-1 contain a single row of results. This opcode causes the sqlite3_step() call to terminate with an SQLITE_ROW return code and it sets up the sqlite3_stmt structure to provide access to the r(P1)..r(P1+P2-1) values as the result row.</source>
          <target state="translated">寄存器P1到P1+P2-1包含了单行的结果。这个操作码导致sqlite3_step()调用以SQLITE_ROW返回代码终止,并且它设置了sqlite3_stmt结构以提供对r(P1)...r(P1+P2-1)值的访问作为结果行。</target>
        </trans-unit>
        <trans-unit id="3af4c8adff2c9c78e4e3d405284a88188dcbb490" translate="yes" xml:space="preserve">
          <source>The registers released will be the P2 registers starting at P1, except if bit ii of P3 set, then do not release register P1+ii. In other words, P3 is a mask of registers to preserve.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad008f7525662f6767cf59c0a5ffbf397455036" translate="yes" xml:space="preserve">
          <source>The relative precedence of the set operations is different. In particular, using the standard query syntax the &quot;OR&quot; operator has a higher precedence than &quot;AND&quot;. The precedence of operators when using the standard query syntax is:</source>
          <target state="translated">集合操作的相对优先性是不同的。特别是,使用标准查询语法时,&quot;OR &quot;操作符的优先级高于 &quot;AND&quot;。使用标准查询语法时,运算符的优先级是:</target>
        </trans-unit>
        <trans-unit id="4055a7e54aa1eb8dd8ef4889c3d207a5659a2b35" translate="yes" xml:space="preserve">
          <source>The release build is used to validate the generated machine code.</source>
          <target state="translated">发布构建是用来验证生成的机器代码。</target>
        </trans-unit>
        <trans-unit id="4fe1d3a13dd63ed4836e434d893dc270763cfe84" translate="yes" xml:space="preserve">
          <source>The release checklist is continuously evolving. As new problems or potential problems are discovered, new checklist items are added to make sure those problems do not appear in subsequent releases. The release checklist has proven to be an invaluable tool in helping to ensure that nothing is overlooked during the release process.</source>
          <target state="translated">发布检查表是不断发展的。随着新问题或潜在问题的发现,新的检查表项目被添加进来,以确保这些问题不会出现在随后的版本中。事实证明,发布检查清单是一个宝贵的工具,有助于确保在发布过程中不遗漏任何问题。</target>
        </trans-unit>
        <trans-unit id="54fb9bcb3273ff541df78c3b4ae7a5c1d95caf43" translate="yes" xml:space="preserve">
          <source>The release checklist is not automated: developers run each item on the checklist manually. We find that it is important to keep a human in the loop. Sometimes problems are found while running a checklist item even though the test itself passed. It is important to have a human reviewing the test output at the highest level, and constantly asking &quot;Is this really right?&quot;</source>
          <target state="translated">发布检查表不是自动的:开发人员手动运行检查表上的每个项目。我们发现,让人参与其中很重要。有时,即使测试本身通过了,但在运行检查表项目时还是会发现问题。让一个人在最高级别审查测试输出,并不断询问 &quot;这真的是对的吗?&quot;是很重要的。</target>
        </trans-unit>
        <trans-unit id="2c9d643524e4e559789769fa0d9c05fd5ba6364a" translate="yes" xml:space="preserve">
          <source>The relevancy of a document may depend on something other than just the data available in the return value of matchinfo. For example each document in the database may be assigned a static weight based on factors unrelated to its content (origin, author, age, number of references etc.). These values can be stored by the application in a separate table that can be joined against the documents table in the sub-query so that the rank function may access them.</source>
          <target state="translated">一个文档的相关性可能不仅仅取决于matchinfo的返回值中的数据。例如,数据库中的每个文档可以根据与其内容无关的因素(来源、作者、年龄、参考文献的数量等)分配一个静态权重。这些值可以由应用程序存储在一个单独的表中,可以与子查询中的文档表连接,以便排名函数可以访问它们。</target>
        </trans-unit>
        <trans-unit id="d03714ee4fa95f4e8679f472e2f3c59cc9a47883" translate="yes" xml:space="preserve">
          <source>The reliability and robustness of SQLite is achieved in part by thorough and careful testing.</source>
          <target state="translated">SQLite的可靠性和健壮性在一定程度上是通过彻底和仔细的测试实现的。</target>
        </trans-unit>
        <trans-unit id="7a3157bd64ab9a637ba9a36bada2711bd2147294" translate="yes" xml:space="preserve">
          <source>The remainder of this document will guide the reader through the steps needed to maintain a private branch. The general idea is the same as outlined above. This section merely provides more detail.</source>
          <target state="translated">本文件的其余部分将指导读者完成维护私人分支机构所需的步骤。总的思路与上文所述相同。本节只是提供更多细节。</target>
        </trans-unit>
        <trans-unit id="30a538553e382aa8cfb9498b6fd827480cf2d80b" translate="yes" xml:space="preserve">
          <source>The remaining fields of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object all store pointers to functions that implement primitive operations. We call these &quot;methods&quot;. The first method, xOpen, is used to open files on the underlying storage media. The result is an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. There are additional methods, defined by the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object itself that are used to read and write and close the file. The additional methods are detailed below. The filename is in UTF-8. SQLite will guarantee that the zFilename string passed to xOpen() is a full pathname as generated by xFullPathname() and that the string will be valid and unchanged until xClose() is called. So the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; can store a pointer to the filename if it needs to remember the filename for some reason. The flags argument to xOpen() is a copy of the flags argument to sqlite3_open_v2(). If sqlite3_open() or sqlite3_open16() is used, then flags is &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;. If xOpen() opens a file read-only then it sets *pOutFlags to include &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;. Other bits in *pOutFlags may be set. SQLite will also add one of the following flags to the xOpen() call, depending on the object being opened:</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的其余字段都存储指向实现原始操作的函数的指针。我们称这些为&amp;ldquo;方法&amp;rdquo;。第一种方法xOpen用于打开基础存储介质上的文件。结果是一个&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;对象。由&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;对象本身定义的其他方法可用于读取和写入以及关闭文件。其他方法将在下面详细说明。文件名采用UTF-8。 SQLite将确保传递给xOpen（）的zFilename字符串是由xFullPathname（）生成的完整路径名，并且该字符串在调用xClose（）之前将一直有效且不变。所以&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;如果由于某种原因需要记住文件名，可以存储指向文件名的指针。 xOpen（）的flags参数是sqlite3_open_v2（）的flags参数的副本。如果使用sqlite3_open（）或sqlite3_open16（），则标志为&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;。如果xOpen（）以只读方式打开文件，则它将* pOutFlags设置为包括&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;。 * pOutFlags中的其他位可以设置。 SQLite还将根据打开的对象向xOpen（）调用添加以下标志之一：</target>
        </trans-unit>
        <trans-unit id="75ee3ed9cd8aa1cdca7e660d366395ab9cdd104b" translate="yes" xml:space="preserve">
          <source>The remaining seven methods defined by this structure (xMutexAlloc, xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and xMutexNotheld) implement the following interfaces (respectively):</source>
          <target state="translated">该结构定义的其余七个方法(xMutexAlloc、xMutexFree、xMutexEnter、xMutexTry、xMutexLeave、xMutexHeld和xMutexNotheld)分别实现了以下接口。</target>
        </trans-unit>
        <trans-unit id="01d5ccb02fb58f9483b8bb4a6c89788e5e99328d" translate="yes" xml:space="preserve">
          <source>The remove_diacritics option is not supported.</source>
          <target state="translated">不支持 remove_diacritics 选项。</target>
        </trans-unit>
        <trans-unit id="5dc3bfc4e2330eb1c8eb7d47b9e9b34b4b7effb1" translate="yes" xml:space="preserve">
          <source>The remove_diacritics option may be set to &quot;0&quot;, &quot;1&quot; or &quot;2&quot;. The default value is &quot;1&quot;. If it is set to &quot;1&quot; or &quot;2&quot;, then diacritics are removed from Latin script characters as described above. However, if it is set to &quot;1&quot;, then diacritics are not removed in the fairly uncommon case where a single unicode codepoint is used to represent a character with more that one diacritic. For example, diacritics are not removed from codepoint 0x1ED9 (&quot;LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW&quot;). This is technically a bug, but cannot be fixed without creating backwards compatibility problems. If this option is set to &quot;2&quot;, then diacritics are correctly removed from all Latin characters.</source>
          <target state="translated">remove_diacritics选项可以设置为 &quot;0&quot;、&quot;1 &quot;或 &quot;2&quot;。默认值是 &quot;1&quot;。如果它被设置为 &quot;1 &quot;或 &quot;2&quot;,那么拉丁字母字符中的暗号就会如上所述被移除,但如果它被设置为 &quot;1&quot;,那么暗号就不会被移除。然而,如果它被设置为 &quot;1&quot;,那么在相当少见的情况下,当一个单一的unicode码点被用来表示一个有多个重音符号的字符时,重音符号就不会被移除。例如,0x1ED9码点(&quot;LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW&quot;)的暗号没有被删除。这在技术上是一个错误,但如果不造成向后的兼容性问题,就无法修复。如果这个选项被设置为 &quot;2&quot;,那么所有拉丁字符中的双音符就会被正确地删除。</target>
        </trans-unit>
        <trans-unit id="e878b1555960f1149f69c44e721edf9e3c3726dd" translate="yes" xml:space="preserve">
          <source>The replace(X,Y,Z) function returns a string formed by substituting string Z for every occurrence of string Y in string X. The &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt; collating sequence is used for comparisons. If Y is an empty string then return X unchanged. If Z is not initially a string, it is cast to a UTF-8 string prior to processing.</source>
          <target state="translated">replace（X，Y，Z）函数返回一个字符串，该字符串是用字符串Z替换字符串X中每次出现的字符串Y所形成的字符串&lt;a href=&quot;datatype3#collation&quot;&gt;。BINARY&lt;/a&gt;整理序列用于比较。如果Y为空字符串，则返回X不变。如果Z最初不是字符串，则在处理之前将其强制转换为UTF-8字符串。</target>
        </trans-unit>
        <trans-unit id="7d84cb3d97dd720ff83b043f47169f048a42ed9d" translate="yes" xml:space="preserve">
          <source>The repository created in the previous step is initially empty. The next step is to load the baseline SQLite release - circle (1) in the diagram above.</source>
          <target state="translated">上一步创建的版本库最初是空的。下一步是加载基线SQLite版本--上图中的圆圈(1)。</target>
        </trans-unit>
        <trans-unit id="10c2d611bbd1154503c3d2f589b7893620f36217" translate="yes" xml:space="preserve">
          <source>The reserved region is an area of unused space at the end of every page (except the locking page) that extensions can use to hold per-page information. The size of the reserved region is determined by the one-byte unsigned integer found at an offset of 20 into the database file header. The size of the reserved region is usually zero.</source>
          <target state="translated">保留区域是每页(除锁定页外)末尾未使用的空间,扩展程序可以用它来保存每页信息。保留区域的大小由数据库文件头中偏移量为20的一字节无符号整数决定。保留区域的大小通常为零。</target>
        </trans-unit>
        <trans-unit id="5406b5dfde9f00d0738ba2c75a1507fa33caf617" translate="yes" xml:space="preserve">
          <source>The reserved region.</source>
          <target state="translated">保留区域;</target>
        </trans-unit>
        <trans-unit id="aad9068a01cab0c1ed6f0408e5a3ca43105c9476" translate="yes" xml:space="preserve">
          <source>The response of SQLite to out-of-memory (OOM) errors is tested using a specialized memory allocator overlay that can simulate memory failures. The overlay is a layer that is inserted in between the memory allocator and the rest of SQLite. The overlay passes most memory allocation requests straight through to the underlying allocator and passes the results back up to the requester. But the overlay can be set to cause the Nth memory allocation to fail. To run an OOM test, the overlay is first set to fail on the first allocation attempt. Then some test script is run and verification that the allocation was correctly caught and handled is made. Then the overlay is set to fail on the second allocation and the test repeats. The failure point continues to advance one allocation at a time until the entire test procedure runs to completion without hitting a memory allocation error. This whole test sequence run twice. On the first pass, the overlay is set to fail only the Nth allocation. On the second pass, the overlay is set to fail the Nth and all subsequent allocations.</source>
          <target state="translated">使用专门的内存分配器覆盖层来测试SQLite对内存外(OOM)错误的响应,该覆盖层可以模拟内存故障。覆盖层是一个插入在内存分配器和SQLite其他部分之间的层。覆盖层将大部分内存分配请求直接传递给底层分配器,并将结果传回给请求者。但是覆盖层可以被设置为导致第N次内存分配失败。要运行OOM测试,首先设置覆盖层在第一次分配尝试时失败。然后运行一些测试脚本,验证分配是否被正确捕获和处理。然后在第二次分配时将覆盖设置为失败,然后重复测试。失败点每次继续推进一个分配,直到整个测试程序运行完成,没有碰到内存分配错误。这整个测试序列运行两次。在第一次通过时,覆盖点被设置为只在第N次分配时失败。在第二次测试中,覆盖点被设置为第N次分配和所有后续分配失败。</target>
        </trans-unit>
        <trans-unit id="12691a5bbec67aa65e24fe31d2477402bd3c4199" translate="yes" xml:space="preserve">
          <source>The rest of the module structure consists of methods used to implement various features of the virtual table. Details on what each of these methods do are provided in the sequel.</source>
          <target state="translated">该模块结构的其余部分由用于实现虚拟表的各种功能的方法组成。关于这些方法的详细内容将在后文中提供。</target>
        </trans-unit>
        <trans-unit id="4c062c28bf53cd1153a7f659fc941fb25e4394ee" translate="yes" xml:space="preserve">
          <source>The result column names generated for compound subqueries have been simplified to show only the name of the column of the original table and omit the table name. This makes SQLite operate more like other SQL database engines.</source>
          <target state="translated">对复合子查询生成的结果列名进行了简化,只显示原表的列名,省略表名。这使得SQLite的操作更像其他SQL数据库引擎。</target>
        </trans-unit>
        <trans-unit id="8fba3a08c8f1c5c3b4c188d84f260675274f7bae" translate="yes" xml:space="preserve">
          <source>The result of &quot;(1,2,3)=(1,NULL,3)&quot; is NULL because the result might be true if we replaced NULL&amp;rarr;2 or false if we replaced NULL&amp;rarr;9. The result of &quot;(1,2,3)=(1,NULL,4)&quot; is not NULL because there is no substitutions of the constituent NULL that will make the expression true, since 3 will never equal 4 in the third column.</source>
          <target state="translated">&amp;ldquo;（1,2,3）=（1，NULL，3）&amp;rdquo;的结果为NULL，因为如果替换为NULL&amp;rarr;2，则结果可能为true；如果替换为NULL&amp;rarr;9，则结果为false。结果&amp;ldquo;（1,2,3）=（1，NULL，4）&amp;rdquo;不是NULL，因为没有组成NULL的替换将使表达式为true，因为在第三列中3永远不会等于4。</target>
        </trans-unit>
        <trans-unit id="8f8beef2187bafe894f67b36f4b351c6bf0083c2" translate="yes" xml:space="preserve">
          <source>The result of an IN or NOT IN operator is determined by the following matrix:</source>
          <target state="translated">IN或NOT IN运算符的结果由以下矩阵决定:</target>
        </trans-unit>
        <trans-unit id="61365ffa3c163a280c658c5edf1eb2a5c12ca346" translate="yes" xml:space="preserve">
          <source>The result of any binary operator is either a numeric value or NULL, except for the</source>
          <target state="translated">任何二进制运算符的结果要么是一个数值,要么是NULL,但除了</target>
        </trans-unit>
        <trans-unit id="efe84f22635d66f10495dd8d63c09814ab5f5a9a" translate="yes" xml:space="preserve">
          <source>The result of combining all input changesets together is obtained by the application via a call to sqlite3changegroup_output().</source>
          <target state="translated">应用程序通过调用sqlite3changegroup_output()获得将所有输入的变化集组合在一起的结果。</target>
        </trans-unit>
        <trans-unit id="bf374835b6b23f4254068862fbe80fd36859e25a" translate="yes" xml:space="preserve">
          <source>The result of opening a file is an instance of an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object is an abstract base class defined as follows:</source>
          <target state="translated">打开文件的结果是&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;对象的实例。所述&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;对象是一个抽象基类定义如下：</target>
        </trans-unit>
        <trans-unit id="8384d1099fcb8eaa40cfc52c9ccfbf281fc795df" translate="yes" xml:space="preserve">
          <source>The result of the compound select is sent to the callback routine by the loop at instructions 22 through 25. There is nothing new or remarkable about this loop, except for the fact that the Column instruction at 23 will be extracting a column out of the record key rather than the record data.</source>
          <target state="translated">复合选择的结果由指令22到25的循环发送到回调例程。这个循环没有什么新的或值得注意的地方,除了23处的Column指令将从记录键中提取一列而不是记录数据。</target>
        </trans-unit>
        <trans-unit id="a2285b0635d880f7a2485fe902caef319bce2b4f" translate="yes" xml:space="preserve">
          <source>The result of this last example should be every unique value of the &quot;two&quot; column in the examp table, except any value that is in the &quot;four&quot; column of examp2 is removed. The code to implement this query is as follows:</source>
          <target state="translated">最后一个例子的结果应该是examp表中 &quot;2 &quot;列中的每一个唯一值,除了examp2的 &quot;4 &quot;列中的任何值都会被删除。实现这个查询的代码如下。</target>
        </trans-unit>
        <trans-unit id="ccf7a73ae578c847fadf3966512c178de5c0acda" translate="yes" xml:space="preserve">
          <source>The result of total() is always a floating point value. The result of sum() is an integer value if all non-NULL inputs are integers. If any input to sum() is neither an integer or a NULL then sum() returns a floating point value which might be an approximation to the true sum.</source>
          <target state="translated">total()的结果总是一个浮点值。如果所有非NULL输入都是整数,那么sum()的结果就是一个整数值。如果sum()的任何输入既不是整数也不是NULL,那么sum()返回的是一个浮点值,它可能是真实总和的近似值。</target>
        </trans-unit>
        <trans-unit id="0a6fa042949920d8ab9a65592e82f3922c405d35" translate="yes" xml:space="preserve">
          <source>The resulting &quot;sqlite3.c&quot; amalgamation code file (and its associated header file &quot;sqlite3.h&quot;) can then be moved to a non-unix platform for final compilation using a native compiler.</source>
          <target state="translated">由此产生的 &quot;sqlite3.c &quot;合并代码文件(及其相关的头文件 &quot;sqlite3.h&quot;)可以移到非unix平台上使用本地编译器进行最终编译。</target>
        </trans-unit>
        <trans-unit id="e2d2e1926aa6ddaac2f60d9749f53fb11268ec2a" translate="yes" xml:space="preserve">
          <source>The results of a comparison depend on the storage classes of the operands, according to the following rules:</source>
          <target state="translated">根据以下规则,比较的结果取决于操作数的存储类别。</target>
        </trans-unit>
        <trans-unit id="32d9d0342a63956078e67d37802198109f0decfd" translate="yes" xml:space="preserve">
          <source>The results presented here come with the following caveats:</source>
          <target state="translated">这里介绍的结果有以下几点注意事项。</target>
        </trans-unit>
        <trans-unit id="0aa6d6ab54b80d454b7163f11aaed1a126d7a246" translate="yes" xml:space="preserve">
          <source>The return value from both sqlite3_soft_heap_limit64() and sqlite3_hard_heap_limit64() is the size of the heap limit prior to the call, or negative in the case of an error. If the argument N is negative then no change is made to the heap limit. Hence, the current size of heap limits can be determined by invoking sqlite3_soft_heap_limit64(-1) or sqlite3_hard_heap_limit(-1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9310ef8309cce9fab8d7528f6f21efe5cbb34c7" translate="yes" xml:space="preserve">
          <source>The return value from sqlite3_soft_heap_limit64() is the size of the soft heap limit prior to the call, or negative in the case of an error. If the argument N is negative then no change is made to the soft heap limit. Hence, the current size of the soft heap limit can be determined by invoking sqlite3_soft_heap_limit64() with a negative argument.</source>
          <target state="translated">sqlite3_soft_heap_limit64()的返回值是调用前软堆限制的大小,如果出现错误,返回值为负值。如果参数N为负值,则不会对软堆限制进行任何改变。因此,可以通过调用参数为负的sqlite3_soft_heap_limit64()来确定当前软堆限制的大小。</target>
        </trans-unit>
        <trans-unit id="b9ca53c6554299d5eae8ef584802645a6046ae33" translate="yes" xml:space="preserve">
          <source>The return value indicates the final state of the indirect flag: 0 if it is clear, or 1 if it is set.</source>
          <target state="translated">返回值表示间接标志的最终状态:如果是清除,则为0;如果是设置,则为1。</target>
        </trans-unit>
        <trans-unit id="7ce2179f1a4d84a59cb420b693cc86ea07338afc" translate="yes" xml:space="preserve">
          <source>The return value indicates the final state of the session object: 0 if the session is disabled, or 1 if it is enabled.</source>
          <target state="translated">返回值表示会话对象的最终状态:如果会话被禁用,则为0;如果会话被启用,则为1。</target>
        </trans-unit>
        <trans-unit id="cae4bd57ed056db33a88f07df4b39cc7f3ccb51d" translate="yes" xml:space="preserve">
          <source>The return value of the &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface is determined by the compile-time threading mode selection. If single-thread mode is selected at compile-time, then &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returns false. If either the multi-thread or serialized modes are selected, then &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returns true. The &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface predates the multi-thread mode and start-time and run-time mode selection and so is unable to distinguish between multi-thread and serialized mode nor is it able to report start-time or run-time mode changes.</source>
          <target state="translated">&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;接口的返回值由编译时线程模式选择确定。如果在编译时选择了单线程模式，则&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;返回false。如果选择了多线程或序列化模式，则&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;返回true。该&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;接口早在多线程模式和启动时间和运行时间模式选择，因此是无法多线程和序列化的模式，也没有区分是它能够报告开始时间或运行时模式的变化。</target>
        </trans-unit>
        <trans-unit id="39d80cd93bcac1fdb374e9a2b5c0dd95b400a1d6" translate="yes" xml:space="preserve">
          <source>The return value of the &lt;b&gt;sqlite_open&lt;/b&gt; function is a pointer to an opaque &lt;b&gt;sqlite&lt;/b&gt; structure. This pointer will be the first argument to all subsequent SQLite function calls that deal with the same database. NULL is returned if the open fails for any reason.</source>
          <target state="translated">&lt;b&gt;sqlite_open&lt;/b&gt;函数的返回值是一个不透明的&lt;b&gt;sqlite&lt;/b&gt;结构的指针。该指针将成为处理同一数据库的所有后续SQLite函数调用的第一个参数。如果打开由于任何原因失败，则返回NULL。</target>
        </trans-unit>
        <trans-unit id="6ab6c5924ac478fb10f4cbca37723d1a21ffdbb3" translate="yes" xml:space="preserve">
          <source>The returned string pointer is valid until either the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed by &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the next call to sqlite3_column_name() or sqlite3_column_name16() on the same column.</source>
          <target state="translated">返回的字符串指针是有效的，直到用&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;销毁&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;或直到针对特定运行的第一次调用&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;来自动重新准备该语句为止，或者直到下次调用sqlite3_column_name（）或sqlite3_column_name16（）为止。同一列。</target>
        </trans-unit>
        <trans-unit id="b378f46326a64f9ce7b892670372ed936b24e5cc" translate="yes" xml:space="preserve">
          <source>The returned string pointer is valid until either the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed by &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the next call to sqlite3_column_name() or sqlite3_column_name16() on the same column.</source>
          <target state="translated">返回的字符串指针是有效的，直到用&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;销毁&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;或直到针对特定运行的第一次调用&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;来自动重新准备该语句为止，或者直到下次调用sqlite3_column_name（）或sqlite3_column_name16（）为止。同一列。</target>
        </trans-unit>
        <trans-unit id="bee83cce7953088554432a61ef6e85ee98f1b384" translate="yes" xml:space="preserve">
          <source>The rewritten expression above is conceptual; WHERE clauses containing OR are not really rewritten this way. The actual implementation of the OR clause uses a mechanism that is more efficient and that works even for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables or tables in which the &quot;rowid&quot; is inaccessible. But the essence of the implementation is captured by the statement above: Separate indices are used to find candidate result rows from each OR clause term and the final result is the union of those rows.</source>
          <target state="translated">上面重写的表达是概念性的；包含OR的WHERE子句实际上不是用这种方式重写的。OR子句的实际实现使用一种效率更高的机制，甚至对于&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表或无法访问&amp;ldquo; rowid&amp;rdquo;的表也可以使用。但是，实现的实质已由上面的语句捕获：使用单独的索引从每个OR子句项中查找候选结果行，而最终结果是这些行的并集。</target>
        </trans-unit>
        <trans-unit id="1bd2a272126ae7fe0bcc8e6d37c8017e55bcc2f1" translate="yes" xml:space="preserve">
          <source>The rewritten term then might go on to constrain an index using the normal rules for *IN* operators. Note that</source>
          <target state="translated">然后,重写的项可能会继续使用*IN*运算符的正常规则来约束一个索引。注意</target>
        </trans-unit>
        <trans-unit id="d0930df338a07de9990756603662657ba4f08d89" translate="yes" xml:space="preserve">
          <source>The right-hand operand of an IN or NOT IN operator has no affinity if the operand is a list and has the same affinity as the affinity of the result set expression if the operand is a SELECT.</source>
          <target state="translated">如果操作数是列表,IN或NOT IN操作数的右侧操作数没有亲和力,如果操作数是SELECT,则与结果集表达式的亲和力相同。</target>
        </trans-unit>
        <trans-unit id="066626c86d12ae463e5bc63db194f29a635a8420" translate="yes" xml:space="preserve">
          <source>The right-hand side of the IN operator can now be a list of expressions instead of just a list of constants</source>
          <target state="translated">现在,IN操作符的右侧可以是表达式的列表,而不仅仅是常量的列表。</target>
        </trans-unit>
        <trans-unit id="5c40f29b907e12e70ce95f7046453c736453580d" translate="yes" xml:space="preserve">
          <source>The right-hand side of the LIKE or GLOB must be either a string literal or a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; bound to a string literal that does not begin with a wildcard character.</source>
          <target state="translated">LIKE或GLOB的右侧必须是字符串文字或绑定到不以通配符开头的字符串文字的&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b4246dd614eb68d70df4434b2497d819d23353bb" translate="yes" xml:space="preserve">
          <source>The right-hand table of the LEFT JOIN is not be used anywhere in the query outside of its own USING or ON clause.</source>
          <target state="translated">LEFT JOIN的右侧表在查询中除了它自己的USING或ON子句外的任何地方都不能使用。</target>
        </trans-unit>
        <trans-unit id="fc3dd2572b5bfa090299b30f5d81e58803cff0cb" translate="yes" xml:space="preserve">
          <source>The right-hand-side of the MATCH or = operator must be a constant expression that evaluates to a string consisting of the auxiliary function to invoke, followed by zero or more comma separated arguments within parenthesis. Arguments must be SQL literals. For example:</source>
          <target state="translated">MATCH 或=操作符的右侧必须是一个常量表达式,它的值是一个由要调用的辅助函数组成的字符串,后面的括号内是零个或多个逗号分隔的参数。参数必须是 SQL 字符。例如</target>
        </trans-unit>
        <trans-unit id="60bf6a0aa9c141c91d3c15f81e63af1fbe6058ec" translate="yes" xml:space="preserve">
          <source>The right-most SELECT of the compound select must not make use of &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate&lt;/a&gt; or &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;.</source>
          <target state="translated">复合选择的最右边的SELECT不得使用&lt;a href=&quot;lang_aggfunc&quot;&gt;聚集&lt;/a&gt;或&lt;a href=&quot;windowfunctions&quot;&gt;窗口函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7b1ae3c5986255800fb2859410b2b4acb04d2122" translate="yes" xml:space="preserve">
          <source>The rollback journal contains a small header (shown in green in the diagram) that records the original size of the database file. So if a change causes the database file to grow, we will still know the original size of the database. The page number is stored together with each database page that is written into the rollback journal.</source>
          <target state="translated">回滚日志包含一个小头(图中绿色所示),记录了数据库文件的原始大小。因此,如果一个变化导致数据库文件增长,我们仍然会知道数据库的原始大小。页码与每个写入回滚日志的数据库页一起存储。</target>
        </trans-unit>
        <trans-unit id="1c053ab6c700ac534ac79f62078cfd2e255f73f2" translate="yes" xml:space="preserve">
          <source>The rollback journal does not contain the name of a master journal file (see &lt;a href=&quot;#section_5_5&quot;&gt;section 5.5&lt;/a&gt; below) or if does contain the name of a master journal, then that master journal file exists.</source>
          <target state="translated">回滚日志不包含主日志文件的名称（请参阅下面的&lt;a href=&quot;#section_5_5&quot;&gt;5.5节&lt;/a&gt;），或者如果包含主日志的名称，则该主日志文件存在。</target>
        </trans-unit>
        <trans-unit id="070c8fccacf99462797ddd5845e4bd8960ffcf17" translate="yes" xml:space="preserve">
          <source>The rollback journal does not contain the name of a super-journal file (see &lt;a href=&quot;#section_5_5&quot;&gt;section 5.5&lt;/a&gt; below) or if does contain the name of a super-journal, then that super-journal file exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e312e9592f38c1d0abcf1823ca656ae6dc24729" translate="yes" xml:space="preserve">
          <source>The rollback journal exists.</source>
          <target state="translated">回滚日志存在。</target>
        </trans-unit>
        <trans-unit id="a6a9ff12c8273f443fb56b2bd7d0ab6853333cef" translate="yes" xml:space="preserve">
          <source>The rollback journal file can be deleted,</source>
          <target state="translated">可以删除回滚日志文件。</target>
        </trans-unit>
        <trans-unit id="841baedc01f54f9ab6f694a5b23bcc695e5f21f1" translate="yes" xml:space="preserve">
          <source>The rollback journal file can be truncated to zero length, or</source>
          <target state="translated">回滚日志文件可以被截断为零长度,或者是</target>
        </trans-unit>
        <trans-unit id="31415ebe9f384149b021a50dd2fb2ee645763262" translate="yes" xml:space="preserve">
          <source>The rollback journal is</source>
          <target state="translated">回滚日志是</target>
        </trans-unit>
        <trans-unit id="08afad671df0d2c575466e5f9fe1a518b69a6c6b" translate="yes" xml:space="preserve">
          <source>The rollback journal is a file associated with each SQLite database file that holds information used to restore the database file to its initial state during the course of a transaction. The rollback journal file is always located in the same directory as the database file and has the same name as the database file but with the string &quot;&lt;code&gt;-journal&lt;/code&gt;&quot; appended. There can only be a single rollback journal associated with a give database and hence there can only be one write transaction open against a single database at one time.</source>
          <target state="translated">回滚日志是与每个SQLite数据库文件关联的文件，其中包含用于在事务过程中将数据库文件还原到其初始状态的信息。回滚日志文件始终与数据库文件位于同一目录中，并且与数据库文件具有相同的名称，但是附加了字符串&amp;ldquo; &lt;code&gt;-journal&lt;/code&gt; &amp;rdquo;。与给定数据库只能有一个回滚日志，因此一次只能对一个数据库打开一个写事务。</target>
        </trans-unit>
        <trans-unit id="8a29cd2d15ece2c4c624bfe95a88741dea324ccf" translate="yes" xml:space="preserve">
          <source>The rollback journal is complete and intact on disk when the power is restored. This is a key point. The reason for the flush operation in &lt;a href=&quot;#section_3_7&quot;&gt;step 3.7&lt;/a&gt; is to make absolutely sure that all of the rollback journal is safely on nonvolatile storage prior to making any changes to the database file itself.</source>
          <target state="translated">恢复电源后，回滚日志已完成并且在磁盘上完好无损。这是关键。&lt;a href=&quot;#section_3_7&quot;&gt;步骤3.7&lt;/a&gt;中进行刷新操作的原因是，在对数据库文件本身进行任何更改之前，绝对要确保所有回滚日志都安全地存储在非易失性存储中。</target>
        </trans-unit>
        <trans-unit id="5d1b7832cc643f77f52a69083206bb3b5fc3e74c" translate="yes" xml:space="preserve">
          <source>The rollback journal is not an empty file.</source>
          <target state="translated">回滚日志不是一个空文件。</target>
        </trans-unit>
        <trans-unit id="194c559058723739212e12d7c3749019f8df5f55" translate="yes" xml:space="preserve">
          <source>The root page numbers of all tables in the database are integers stored in P4_INTARRAY argument.</source>
          <target state="translated">数据库中所有表的根号都是整数,存储在P4_INTARRAY参数中。</target>
        </trans-unit>
        <trans-unit id="a973ad8403210b9b222fd26c2aef5b8f2808389c" translate="yes" xml:space="preserve">
          <source>The round(X,Y) function returns a floating-point value X rounded to Y digits to the right of the decimal point. If the Y argument is omitted, it is assumed to be 0.</source>
          <target state="translated">round(X,Y)函数返回一个浮点值X,将其四舍五入到小数点右边的Y位。如果省略Y参数,则假定为0。</target>
        </trans-unit>
        <trans-unit id="5fa12ab6f93c055083bc1a95b917e71f9cff725b" translate="yes" xml:space="preserve">
          <source>The routines &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; accept an SQL statement list (sql-stmt-list) which is a semicolon-separated list of statements.</source>
          <target state="translated">例程&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;，&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;，&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16（）&lt;/a&gt;，&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;，&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;和&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;接受SQL语句列表（sql-stmt-list），该列表以分号分隔。</target>
        </trans-unit>
        <trans-unit id="94230b7f00353328063595629d48ef7be9fce389" translate="yes" xml:space="preserve">
          <source>The row-value notation is useful for updating two or more columns of a table from the result of a single query. An example of this is in the full-text search feature of the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil version control system&lt;/a&gt;.</source>
          <target state="translated">行值表示法对于从单个查询的结果更新表的两个或更多列很有用。例如，&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil版本控制系统&lt;/a&gt;的全文本搜索功能。</target>
        </trans-unit>
        <trans-unit id="12b6af8126e4e3b962d71bf35b72e9a66ab6fcba" translate="yes" xml:space="preserve">
          <source>The row_number() of the first peer in each group - the rank of the current row with gaps. If there is no ORDER BY clause, then all rows are considered peers and this function always returns 1.</source>
          <target state="translated">每组中第一个对等体的row_number()--当前有空隙的行的等级。如果没有ORDER BY子句,那么所有的行都被认为是对等体,这个函数总是返回1。</target>
        </trans-unit>
        <trans-unit id="d3978e13ae998834400769bcf87213e9a57acdbe" translate="yes" xml:space="preserve">
          <source>The row_number() window function assigns consecutive integers to each row in order of the &quot;ORDER BY&quot; clause within the window-defn (in this case &quot;ORDER BY y&quot;). Note that this does not affect the order in which results are returned from the overall query. The order of the final output is still governed by the ORDER BY clause attached to the SELECT statement (in this case &quot;ORDER BY x&quot;).</source>
          <target state="translated">row_number()窗口函数按照window-defn中的 &quot;ORDER BY &quot;子句(在本例中为 &quot;ORDER BY y&quot;)的顺序为每条记录分配连续的整数。请注意,这不会影响整个查询结果的返回顺序。最终输出结果的顺序仍然受SELECT语句中附加的ORDER BY子句的约束(在本例中为 &quot;ORDER BY x&quot;)。</target>
        </trans-unit>
        <trans-unit id="97fcd9de22c4efb0eb648cf609eba1ee3fdf411d" translate="yes" xml:space="preserve">
          <source>The rowid (and &quot;oid&quot; and &quot;_rowid_&quot;) is omitted in &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. WITHOUT ROWID tables are only available in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06) and later. A table that lacks the WITHOUT ROWID clause is called a &quot;rowid table&quot;.</source>
          <target state="translated">在&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表中省略了rowid（以及&amp;ldquo; oid&amp;rdquo;和&amp;ldquo; _rowid_&amp;rdquo;）。WITHOUT ROWID表仅在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;3.8.2&lt;/a&gt;（2013-12-06）及更高版本中可用。缺少WITHOUT ROWID子句的表称为&amp;ldquo; rowid表&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a4a453c67097537d0d10c4b81190fd5d03a4b9dd" translate="yes" xml:space="preserve">
          <source>The rowid column is not accessible on a WITHOUT ROWID virtual table (of course).</source>
          <target state="translated">rowid列在without rowid虚拟表上是无法访问的(当然)。</target>
        </trans-unit>
        <trans-unit id="101d05f0746854eb07065f446e80313cdc7692a7" translate="yes" xml:space="preserve">
          <source>The rowid of the document that contains the term instance.</source>
          <target state="translated">包含术语实例的文档的rowid。</target>
        </trans-unit>
        <trans-unit id="21037157130833680d029f7ec56534a7a85bda67" translate="yes" xml:space="preserve">
          <source>The rowid of the row in the table being changed</source>
          <target state="translated">表中被更改的行的行名。</target>
        </trans-unit>
        <trans-unit id="4967842a66478a8da76fb91a725d0ca4385c40a8" translate="yes" xml:space="preserve">
          <source>The rtreecheck() function performs the following checks:</source>
          <target state="translated">rtreecheck()函数执行以下检查。</target>
        </trans-unit>
        <trans-unit id="93e10cfe1c883491ee9016750849300312683ba1" translate="yes" xml:space="preserve">
          <source>The rtrim(X,Y) function returns a string formed by removing any and all characters that appear in Y from the right side of X. If the Y argument is omitted, rtrim(X) removes spaces from the right side of X.</source>
          <target state="translated">rtrim(X,Y)函数返回一个从X的右侧删除Y中出现的所有字符所形成的字符串,如果省略Y参数,rtrim(X)将从X的右侧删除空格。</target>
        </trans-unit>
        <trans-unit id="46ff031bad92aa35bcef2484317fc2661aa2d589" translate="yes" xml:space="preserve">
          <source>The rule above says that the letter &quot;a&quot; in user input can be matched against the letter &quot;&amp;auml;&quot; in the dictionary with a penalty of 5.</source>
          <target state="translated">上面的规则说，用户输入中的字母&amp;ldquo; a&amp;rdquo;可以与字典中的字母&amp;ldquo;&amp;auml;&amp;rdquo;匹配，罚分5。</target>
        </trans-unit>
        <trans-unit id="ed3a2c883d263a1e9abd7d6661fda464d09422b3" translate="yes" xml:space="preserve">
          <source>The rules for determining which collating function to use for a binary comparison operator (=, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, !=, IS, and IS NOT) are as follows:</source>
          <target state="translated">确定用于二进制比较运算符（=，&amp;lt;，&amp;gt;，&amp;lt;=，&amp;gt; =，！=，IS和IS NOT）的排序规则的规则如下：</target>
        </trans-unit>
        <trans-unit id="27705c6545cd7b92f01b98bd6ebfb1aa891406e9" translate="yes" xml:space="preserve">
          <source>The rules for when tables are analyzed are likely to change in future releases.</source>
          <target state="translated">在未来的版本中,何时对表格进行分析的规则可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="819c15849a2758e415f2520702095eeff7ea13a5" translate="yes" xml:space="preserve">
          <source>The safest and easiest to remember policy is this: assume that any result from</source>
          <target state="translated">最安全、最容易记住的政策是:假设任何结果从</target>
        </trans-unit>
        <trans-unit id="9bfc94ce3f6dbf06df6c899612d318253dda6014" translate="yes" xml:space="preserve">
          <source>The safest policy is to invoke these routines in one of the following ways:</source>
          <target state="translated">最安全的政策是以下列方式之一调用这些例程。</target>
        </trans-unit>
        <trans-unit id="376b573ee029dd7d9463b27b130e605260069a93" translate="yes" xml:space="preserve">
          <source>The salt-1 and salt-2 values in the frame-header match salt values in the wal-header</source>
          <target state="translated">框架头中的盐-1和盐-2的值与墙头中的盐值相匹配。</target>
        </trans-unit>
        <trans-unit id="b0647dc001e4e971c816ce4a73a18b5c698aa62d" translate="yes" xml:space="preserve">
          <source>The same SQL statement will fail on every other SQL implementation that we know of due to the use of keywords &quot;union&quot;, &quot;true&quot;, and &quot;with&quot; as identifiers.</source>
          <target state="translated">由于使用关键字 &quot;union&quot;、&quot;true &quot;和 &quot;with &quot;作为标识符,同样的SQL语句在我们知道的所有其他SQL实现上都会失败。</target>
        </trans-unit>
        <trans-unit id="67d39480596a16c7c11f0309e84be58f71d89746" translate="yes" xml:space="preserve">
          <source>The same basic B-Tree format is used but the details of the index keys were changed in order to provide better query optimization opportunities. Some of the headers were also changed in order to increase the maximum size of a row from 64KB to 24MB.</source>
          <target state="translated">使用相同的基本B-Tree格式,但为了提供更好的查询优化机会,改变了索引键的细节。为了将一行的最大大小从64KB增加到24MB,还改变了一些头文件。</target>
        </trans-unit>
        <trans-unit id="8827fbb3b64d8c27595464e7777bbb4e772df118" translate="yes" xml:space="preserve">
          <source>The same basic algorithm is followed, except this time the matching rows of the index are scanned from bottom to top instead of from top to bottom, so that the states will appear in descending order.</source>
          <target state="translated">同样的基本算法,只是这次索引的匹配行是从下往上扫描,而不是从上往下扫描,这样状态将按降序出现。</target>
        </trans-unit>
        <trans-unit id="8ef4bb6f50ee96f372f99fa9088d7b9c16950c07" translate="yes" xml:space="preserve">
          <source>The same core string formatter is also used internally by SQLite.</source>
          <target state="translated">同样的核心字符串格式化器也被SQLite内部使用。</target>
        </trans-unit>
        <trans-unit id="c76359de67616f16a26e96d68504c135072ade53" translate="yes" xml:space="preserve">
          <source>The same database connection may now be used simultaneously by separate threads.</source>
          <target state="translated">同一数据库连接现在可以由不同的线程同时使用。</target>
        </trans-unit>
        <trans-unit id="3bfa6cdc7cb80687d83044e6ab3337ab8d5595b5" translate="yes" xml:space="preserve">
          <source>The same indices are used to speed up every loop in both implementation options. The only difference in these two query plans is the order in which the loops are nested.</source>
          <target state="translated">在这两个实现方案中,使用相同的索引来加快每个循环的速度。这两个查询计划的唯一区别是循环的嵌套顺序。</target>
        </trans-unit>
        <trans-unit id="d1cd4608c87b02b3bc5ed6c81e7bb9ae9c4b8e13" translate="yes" xml:space="preserve">
          <source>The same technique ensures that an SQLite database file cannot be corrupted by a system failure that occurs at an inopportune moment. If a system failure does occur before SQLite has had a chance to execute sufficient</source>
          <target state="translated">同样的技术确保了SQLite数据库文件不会因为在不恰当的时刻发生的系统故障而损坏。如果系统故障确实发生在SQLite还没有来得及执行足够的程序之前。</target>
        </trans-unit>
        <trans-unit id="40cbe38c06ce85b1c49ad0c8414f8f89ac5525ac" translate="yes" xml:space="preserve">
          <source>The same thing can be done with an enterprise client/server database, of course. The advantage of SQLite is that it is easier to install and use and the resulting database is a single file that can be written to a USB memory stick or emailed to a colleague.</source>
          <target state="translated">当然,同样的事情也可以用企业客户/服务器数据库来完成。SQLite的优点是安装和使用比较方便,而且生成的数据库是一个单一的文件,可以写入U盘或者通过电子邮件发给同事。</target>
        </trans-unit>
        <trans-unit id="d9e7d4c0bf312ba2ed4d788d1d81806125454441" translate="yes" xml:space="preserve">
          <source>The scalar SQL function rtreecheck(R) or rtreecheck(S,R) runs an integrity check on the rtree table named R contained within database S. The function returns a human-language description of any problems found, or the string 'ok' if everything is ok. Running rtreecheck() on an R*Tree virtual table is similar to running &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; on a database.</source>
          <target state="translated">标量SQL函数rtreecheck（R）或rtreecheck（S，R）对数据库S中包含的名为R的rtree表运行完整性检查。该函数返回发现的任何问题的人工语言描述，或者返回字符串'ok'（如果存在）一切都好。在R * Tree虚拟表上运行rtreecheck（）类似于在数据库上运行&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="181bcf0e796a132dd22a68144a4e494726dfbf32" translate="yes" xml:space="preserve">
          <source>The scenario above sounds far-fetched. But the SQLite developers are aware of at least one commercial product that was released with exactly this bug. The vendor came to the SQLite developers seeking help in tracking down some infrequent database corruption issues they were seeing on Linux and Mac. The problem was eventually traced to the fact that the application was linking against two separate copies of SQLite. The solution was to change the application build procedures to link against just one copy of SQLite instead of two.</source>
          <target state="translated">上述情况听起来很牵强。但SQLite开发者知道至少有一款商业产品发布时恰恰存在这种错误。供应商向SQLite开发人员寻求帮助,以追踪他们在Linux和Mac上看到的一些不频繁的数据库损坏问题。这个问题最终被追溯到一个事实,即应用程序是针对SQLite的两个独立副本进行链接的。解决方法是改变应用程序的构建过程,使其只与一个SQLite副本而不是两个副本进行链接。</target>
        </trans-unit>
        <trans-unit id="7cf33abd12fd2e97d31a441b54d245ec800fc490" translate="yes" xml:space="preserve">
          <source>The schema above defines a directed graph with the ability to store a name at each node. Now consider a query against this schema:</source>
          <target state="translated">上面的模式定义了一个有向图,能够在每个节点上存储一个名字。现在考虑对这个模式进行查询。</target>
        </trans-unit>
        <trans-unit id="d37b6e6570fc572ab09d9f50bc38138c9b41b0ec" translate="yes" xml:space="preserve">
          <source>The schema cookie is a 4-byte big-endian integer at offset 40 that is incremented whenever the database schema changes. A prepared statement is compiled against a specific version of the database schema. When the database schema changes, the statement must be reprepared. When a prepared statement runs, it first checks the schema cookie to ensure the value is the same as when the statement was prepared and if the schema cookie has changed, the statement either automatically reprepares and reruns or it aborts with an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error.</source>
          <target state="translated">模式cookie是偏移量40处的4字节大尾数整数，每当数据库模式更改时，该cookie就会递增。准备好的语句是针对特定版本的数据库模式进行编译的。当数据库模式更改时，必须重新准备该语句。当准备好的语句运行时，它首先检查架构cookie，以确保该值与准备该语句时的值相同；如果架构cookie已更改，则该语句将自动重新准备并重新运行，或者由于&lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt;错误而中止。</target>
        </trans-unit>
        <trans-unit id="1ab0e540f94c93f90585f3869aa649d5881cec37" translate="yes" xml:space="preserve">
          <source>The schema cookie.</source>
          <target state="translated">模式cookie。</target>
        </trans-unit>
        <trans-unit id="4488aa59b7580b3c4da5952eb56f99b2cde228a2" translate="yes" xml:space="preserve">
          <source>The schema depicted above is not designed to store the full-text index directly. Instead, it is used to store one or more b-tree structures. There is one b-tree for each row in the %_segdir table. The %_segdir table row contains the root node and various meta-data associated with the b-tree structure, and the %_segments table contains all other (non-root) b-tree nodes. Each b-tree is referred to as a &quot;segment&quot;. Once it has been created, a segment b-tree is never updated (although it may be deleted altogether).</source>
          <target state="translated">上面所描述的模式并不是为了直接存储全文索引而设计的,而是用来存储一个或多个b-tree结构。相反,它被用来存储一个或多个b-tree结构。在%_segdir表中,每一行都有一个b树。%_segdir表行包含根节点和与b树结构相关的各种元数据,%_segments表包含所有其他(非根)b树节点。每个b树被称为 &quot;segments&quot;。一旦被创建,一个分段b树就不会被更新(尽管它可能被完全删除)。</target>
        </trans-unit>
        <trans-unit id="2b92ee620ed7f83eb29e5266f914917afed4620a" translate="yes" xml:space="preserve">
          <source>The schema for the DBSTAT virtual table looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd02dc53052cb07a4282595789654910705302c" translate="yes" xml:space="preserve">
          <source>The schema for the dbstat virtual table is this:</source>
          <target state="translated">dbstat虚拟表的模式是这样的。</target>
        </trans-unit>
        <trans-unit id="2252a25e95423355b1edc92e550e314acf60ad89" translate="yes" xml:space="preserve">
          <source>The schema for the table returned by json_each() and json_tree() is as follows:</source>
          <target state="translated">json_each()和json_tree()返回的表的模式如下。</target>
        </trans-unit>
        <trans-unit id="7f20e4cd592c03cab97adad3d2182916294f862d" translate="yes" xml:space="preserve">
          <source>The schema format number for a new database can be set at runtime using the &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format&lt;/a&gt; command.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format&lt;/a&gt;命令设置新数据库的模式格式编号。</target>
        </trans-unit>
        <trans-unit id="933a80ece41d7c4fe3169e373964e2826ef1d8f7" translate="yes" xml:space="preserve">
          <source>The schema format number is a 4-byte big-endian integer at offset 44. The schema format number is similar to the file format read and write version numbers at offsets 18 and 19 except that the schema format number refers to the high-level SQL formatting rather than the low-level b-tree formatting. Four schema format numbers are currently defined:</source>
          <target state="translated">模式格式号是一个4字节的大恩迪安整数,位于偏移量44。模式格式号与偏移量18和19处的文件格式读写版本号类似,只是模式格式号指的是高级SQL格式化,而不是低级b-tree格式化。目前定义了四种模式格式号。</target>
        </trans-unit>
        <trans-unit id="62a7a887a20a821d1b69e9b449caf90b4200d958" translate="yes" xml:space="preserve">
          <source>The schema format number. Supported schema formats are 1, 2, 3, and 4.</source>
          <target state="translated">方案格式号。支持的模式格式有1、2、3和4。</target>
        </trans-unit>
        <trans-unit id="c07d56a869023707575ade10738a217ecfcee4af" translate="yes" xml:space="preserve">
          <source>The schema of an SQL database is able to represent information more directly and succinctly than a key/value database such as a ZIP archive. This makes the document content more accessible to third-party applications and scripts and facilitates advanced features such as built-in document versioning, and incremental saving of work in progress for recovery after a crash.</source>
          <target state="translated">与ZIP档案等键/值数据库相比,SQL数据库的模式能够更直接、更简洁地表示信息。这使得文档内容更容易被第三方应用程序和脚本所访问,并促进了高级功能,如内置的文档版本,以及正在进行的工作的增量保存,以便在崩溃后恢复。</target>
        </trans-unit>
        <trans-unit id="70d31e0ed54ade1f01f5803b76d2ee1ab0a7fa16" translate="yes" xml:space="preserve">
          <source>The schema_version pragma will get or set the value of the schema-version integer at offset 40 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87cc88d5b4a5e95bb023c0790cc28378b9e2bd05" translate="yes" xml:space="preserve">
          <source>The schema_version pragma will to get or set the value of the schema-version integer at offset 40 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;.</source>
          <target state="translated">schema_version编译指示将获取或设置&lt;a href=&quot;fileformat2#database_header&quot;&gt;数据库标头&lt;/a&gt;中偏移40处的schema-version整数的值。</target>
        </trans-unit>
        <trans-unit id="077341a10c528ac1588a1408b9034c9f8021b705" translate="yes" xml:space="preserve">
          <source>The scheme of the URI must be &quot;&lt;code&gt;file:&lt;/code&gt;&quot;. Any other scheme results in the input being treated as an ordinary filename.</source>
          <target state="translated">URI的方案必须为&amp;ldquo; &lt;code&gt;file:&lt;/code&gt; &amp;rdquo;。任何其他方案都会导致输入被视为普通文件名。</target>
        </trans-unit>
        <trans-unit id="08d91918dffee8fc87a94df6946790f6caab8817" translate="yes" xml:space="preserve">
          <source>The score is a combination of rank and distance. The idea is that a lower score is better. The virtual table attempts to find words with the lowest score and by default (unless overridden by ORDER BY) returns results in order of increasing score.</source>
          <target state="translated">分数是等级和距离的组合。这个想法是分数越低越好。虚拟表试图找到得分最低的词,默认情况下(除非被ORDER BY覆盖)按得分增加的顺序返回结果。</target>
        </trans-unit>
        <trans-unit id="61fd3b441b127465c680d5c3514e6d464720698f" translate="yes" xml:space="preserve">
          <source>The script compiles the TH3 test harness into machine code (&quot;th3.o&quot;) if necessary.</source>
          <target state="translated">如果需要的话,这个脚本会把TH3测试线束编译成机器代码(&quot;th3.o&quot;)。</target>
        </trans-unit>
        <trans-unit id="9f405708716b43bff0ad67cd4c7d9fb92e6afc28" translate="yes" xml:space="preserve">
          <source>The script compiles the sqlite3.c source file into assembly language (&quot;sqlite3.s&quot;) if necessary.</source>
          <target state="translated">如果需要的话,脚本会将sqlite3.c源文件编译成汇编语言(&quot;sqlite3.s&quot;)。</target>
        </trans-unit>
        <trans-unit id="9bf1fc92f793f60b433b7ebac87847be7a48eb60" translate="yes" xml:space="preserve">
          <source>The script loops through instructions in the assembly language file to locate branch operations.</source>
          <target state="translated">脚本循环浏览汇编语言文件中的指令,以定位分支操作。</target>
        </trans-unit>
        <trans-unit id="576c62795ba33247bec0c331da3dd87f14e7a748" translate="yes" xml:space="preserve">
          <source>The script makes a copy of the original sqlite3.s file.</source>
          <target state="translated">脚本对原来的sqlite3.s文件进行复制。</target>
        </trans-unit>
        <trans-unit id="fbefc60f4848710280b3f195980be93ae6fb0731" translate="yes" xml:space="preserve">
          <source>The script shows progress for each cycle of the previous step then displays a summary of &quot;survivors&quot; at the end. A &quot;survivor&quot; is a mutation that was not detected by TH3.</source>
          <target state="translated">脚本显示了上一步的每个周期的进展,然后在最后显示 &quot;幸存者 &quot;的摘要。一个 &quot;幸存者 &quot;是指一个没有被TH3检测到的突变。</target>
        </trans-unit>
        <trans-unit id="4a731425cd1bb86844c78ad068a724419eca7459" translate="yes" xml:space="preserve">
          <source>The search for these strings in the type declaration is case insensitive, of course. If any of the above strings occur anywhere in the type declaration, then the datatype of the column is text. Notice that the type &quot;VARCHAR&quot; contains &quot;CHAR&quot; as a substring so it is considered text.</source>
          <target state="translated">当然,在类型声明中搜索这些字符串是不区分大小写的。如果在类型声明中的任何地方出现上述字符串,那么列的数据类型就是文本。注意,类型 &quot;VARCHAR &quot;中包含 &quot;CHAR &quot;作为子串,所以它被认为是文本。</target>
        </trans-unit>
        <trans-unit id="201735a6137bd8c721345300624cc86e3645ba64" translate="yes" xml:space="preserve">
          <source>The second &lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt; instruction begins a transaction and starts a rollback journal for database 1, the database used for temporary tables.</source>
          <target state="translated">第二个&lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt;指令开始一个事务并启动数据库1（用于临时表的数据库）的回滚日志。</target>
        </trans-unit>
        <trans-unit id="541464126fdf47682a89498dd2c1f59037e5c50b" translate="yes" xml:space="preserve">
          <source>The second SELECT is implemented by instructions 14 through 19. Instruction 14 initializes the loop by rewinding its cursor. A new result row is created from the &quot;four&quot; column of table &quot;examp2&quot; by instructions 15 and 16. But instead of using PutStrKey to write this new row into the temporary table, we instead call Delete to remove it from the temporary table if it exists.</source>
          <target state="translated">第二条SELECT由指令14至19实现。指令14通过将光标回卷来初始化循环。通过指令15和16从表 &quot;examp2 &quot;的 &quot;四 &quot;列中创建一条新的结果行。但是我们没有使用PutStrKey将这条新行写入临时表,而是调用Delete将其从临时表中删除(如果存在的话)。</target>
        </trans-unit>
        <trans-unit id="b382925f3a88c50c566963d5ae8b2f2a69bce488" translate="yes" xml:space="preserve">
          <source>The second advantage the SQLite printf routines have over &lt;b&gt;sprintf&lt;/b&gt; are two new formatting options specifically designed to support string literals in SQL. Within the format string, the %q formatting option works very much like %s in that it reads a null-terminated string from the argument list and inserts it into the result. But %q translates the inserted string by making two copies of every single-quote (') character in the substituted string. This has the effect of escaping the end-of-string meaning of single-quote within a string literal. The %Q formatting option works similar; it translates the single-quotes like %q and additionally encloses the resulting string in single-quotes. If the argument for the %Q formatting options is a NULL pointer, the resulting string is NULL without single quotes.</source>
          <target state="translated">与&lt;b&gt;sprintf&lt;/b&gt;相比，SQLite printf例程具有的第二个优势是两个新的格式设置选项，这些选项专门设计用于支持SQL中的字符串文字。在格式字符串中，％q格式设置选项的作用与％s非常相似，因为它从参数列表中读取以空值结尾的字符串并将其插入到结果中。但是％q通过为替换字符串中的每个单引号（'）字符制作两个副本来翻译插入的字符串。这具有在字符串文字中转义单引号的字符串结尾含义的效果。 ％Q格式化选项的工作原理类似；它翻译％q之类的单引号，并另外将结果字符串括在单引号中。如果％Q格式设置选项的参数为NULL指针，则结果字符串为NULL，不带单引号。</target>
        </trans-unit>
        <trans-unit id="24bd2add8c4054117cbe09f659537f282404edb5" translate="yes" xml:space="preserve">
          <source>The second and all subsequent 32768-byte units of the shm file are like this:</source>
          <target state="translated">shm文件的第二个及以后所有32768字节的单位是这样的。</target>
        </trans-unit>
        <trans-unit id="2f88dda8423c5371c7ad74eb85809481a6d1addf" translate="yes" xml:space="preserve">
          <source>The second and third forms return the computed edit distance between strings 'string1' and &quot;string2'. In the second form, a language id of 0 is used. The language id is specified in the third form.</source>
          <target state="translated">第二和第三种形式返回字符串 &quot;string1 &quot;和 &quot;string2 &quot;之间的计算编辑距离。在第二种形式中,使用的语言ID为0。在第三种形式中,语言ID被指定。</target>
        </trans-unit>
        <trans-unit id="bab5b375ff048a5d63f1a3b4cc3d343effcaa9c1" translate="yes" xml:space="preserve">
          <source>The second argument (xFilter) is the &quot;filter callback&quot;. For changes to rows in tables that are not attached to the Session object, the filter is called to determine whether changes to the table's rows should be tracked or not. If xFilter returns 0, changes are not tracked. Note that once a table is attached, xFilter will not be called again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a47f0193da66fdda72484a51d350d2076b5681" translate="yes" xml:space="preserve">
          <source>The second argument (xFilter) is the &quot;filter callback&quot;. For changes to rows in tables that are not attached to the Session object, the filter is called to determine whether changes to the table's rows should be tracked or not. If xFilter returns 0, changes is not tracked. Note that once a table is attached, xFilter will not be called again.</source>
          <target state="translated">第二个参数(xFilter)是 &quot;过滤器回调&quot;。对于没有连接到Session对象的表的行的更改,过滤器被调用来决定是否应该跟踪表的行的更改。如果xFilter返回0,则不跟踪更改。请注意,一旦表被附加,xFilter将不会被再次调用。</target>
        </trans-unit>
        <trans-unit id="718f90fed591046439ad14f60ea06810377e7e83" translate="yes" xml:space="preserve">
          <source>The second argument indicates the reason that FTS5 is requesting tokenization of the supplied text. This is always one of the following four values:</source>
          <target state="translated">第二个参数表示FTS5请求对提供的文本进行标记化的原因。该参数始终是以下四个值之一。</target>
        </trans-unit>
        <trans-unit id="1b37e9b1846948d626696aade4d54493fddd03d8" translate="yes" xml:space="preserve">
          <source>The second argument is a pointer to the function to invoke when a row is updated, inserted or deleted in a rowid table. The first argument to the callback is a copy of the third argument to sqlite3_update_hook(). The second callback argument is one of &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the operation that caused the callback to be invoked. The third and fourth arguments to the callback contain pointers to the database and table name containing the affected row. The final callback parameter is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row. In the case of an update, this is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; after the update takes place.</source>
          <target state="translated">第二个参数是指向在rowid表中更新，插入或删除行时要调用的函数的指针。回调的第一个参数是sqlite3_update_hook（）的第三个参数的副本。第二个回调参数是&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE之一&lt;/a&gt;，具体取决于导致调用回调的操作。回调的第三个和第四个参数包含指向数据库的指针和包含受影响的行的表名称。最后的回调参数是该行的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。在更新的情况下，这是更新发生后的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6eef977cb1db09c38e32ceda39f74ec952be8d2" translate="yes" xml:space="preserve">
          <source>The second argument is a pointer to the function to invoke when a row is updated, inserted or deleted in a rowid table. The first argument to the callback is a copy of the third argument to sqlite3_update_hook(). The second callback argument is one of &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the operation that caused the callback to be invoked. The third and fourth arguments to the callback contain pointers to the database and table name containing the affected row. The final callback parameter is the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row. In the case of an update, this is the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; after the update takes place.</source>
          <target state="translated">第二个参数是指向在rowid表中更新，插入或删除行时要调用的函数的指针。回调的第一个参数是sqlite3_update_hook（）的第三个参数的副本。第二个回调参数是&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;，&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;或&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE之一&lt;/a&gt;，具体取决于导致调用回调的操作。回调的第三个和第四个参数包含指向数据库的指针和包含受影响的行的表名称。最后的回调参数是该行的&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。在更新的情况下，这是更新发生后的&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="724bd11ad92d936922e1ead7d8425d39851a3038" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 32766).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e308f3aa98b17590b5e994747b662ab58b2433" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 999).</source>
          <target state="translated">第二个参数是要设置的SQL参数的索引。最左边的SQL参数的索引为1。当多次使用同一命名的SQL参数时，第二个及后续出现的索引与第一次出现的索引相同。如果需要，可以使用&lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index（）&lt;/a&gt; API 查找命名参数的索引。 &amp;ldquo;？NNN&amp;rdquo;参数的索引是NNN的值。 NNN值必须介于1到&lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;参数&lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER之间&lt;/a&gt;（默认值：999）。</target>
        </trans-unit>
        <trans-unit id="ff965dc4a3884d50d8419508e30018f226ac3b0d" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 32766).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f014790ea15d84ae5efd1a40e8d6440e64de4e" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 999).</source>
          <target state="translated">第二个参数是要设置的SQL参数的索引。最左边的SQL参数的索引为1。当多次使用同一命名的SQL参数时，第二个及后续出现的索引与第一次出现的索引相同。如果需要，可以使用&lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index（）&lt;/a&gt; API 查找命名参数的索引。 &amp;ldquo;？NNN&amp;rdquo;参数的索引是NNN的值。 NNN值必须介于1到&lt;a href=&quot;limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;参数&lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER之间&lt;/a&gt;（默认值：999）。</target>
        </trans-unit>
        <trans-unit id="2fb1bff691f79072fe4cf1aa2d31d1bd3832725a" translate="yes" xml:space="preserve">
          <source>The second argument passed to the xToken() callback (&quot;tflags&quot;) should normally be set to 0. The exception is if the tokenizer supports synonyms. In this case see the discussion below for details.</source>
          <target state="translated">传递给xToken()回调的第二个参数(&quot;tflags&quot;)通常应该设置为0。 如果tokenizer支持同义词,则例外。在这种情况下,详情请参考下面的讨论。</target>
        </trans-unit>
        <trans-unit id="ca943db57529952ad5f76d4c9a47b52221a6d6e3" translate="yes" xml:space="preserve">
          <source>The second argument to sqlite3_db_config(D,V,...) is the &lt;a href=&quot;#sqlitedbconfiglookaside&quot;&gt;configuration verb&lt;/a&gt; - an integer code that indicates what aspect of the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being configured. Subsequent arguments vary depending on the configuration verb.</source>
          <target state="translated">sqlite3_db_config（D，V，...）的第二个参数是&lt;a href=&quot;#sqlitedbconfiglookaside&quot;&gt;配置动词&lt;/a&gt; -一个整数代码，指示正在配置&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接的&lt;/a&gt;哪个方面。后续参数根据配置动词而有所不同。</target>
        </trans-unit>
        <trans-unit id="a7845e3bb7f88361055af36d05adde4b952592f9" translate="yes" xml:space="preserve">
          <source>The second argument to sqlite3_db_config(D,V,...) is the &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;configuration verb&lt;/a&gt; - an integer code that indicates what aspect of the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being configured. Subsequent arguments vary depending on the configuration verb.</source>
          <target state="translated">sqlite3_db_config（D，V，...）的第二个参数是&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;配置动词&lt;/a&gt; -一个整数代码，指示正在配置&lt;a href=&quot;sqlite3&quot;&gt;数据库连接的&lt;/a&gt;哪个方面。后续参数根据配置动词而有所不同。</target>
        </trans-unit>
        <trans-unit id="7ca88f23336b34513d2d790b7c87ef9c5d8d0e67" translate="yes" xml:space="preserve">
          <source>The second argument to the error logger callback is an integer &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt;. The third argument to the error logger is the text of the error message. The error message text is stored in a fixed-length stack buffer in the calling function and so will only be valid for the duration of the error logger callback function. The error logger should make a copy of this message into persistent storage if retention of the message is needed.</source>
          <target state="translated">错误记录器回调的第二个参数是整数&lt;a href=&quot;rescode#extrc&quot;&gt;扩展错误代码&lt;/a&gt;。错误记录器的第三个参数是错误消息的文本。错误消息文本存储在调用函数的固定长度堆栈缓冲区中，因此仅在错误记录器回调函数期间有效。如果需要保留消息，则错误记录器应将此消息复制到持久性存储中。</target>
        </trans-unit>
        <trans-unit id="a2a47b21d6064e4d10a2f6d6161c0f1dce1664a1" translate="yes" xml:space="preserve">
          <source>The second argument, &quot;zSql&quot;, is the statement to be compiled, encoded as either UTF-8 or UTF-16. The sqlite3_prepare(), sqlite3_prepare_v2(), and sqlite3_prepare_v3() interfaces use UTF-8, and sqlite3_prepare16(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() use UTF-16.</source>
          <target state="translated">第二个参数 &quot;zSql &quot;是要编译的语句,编码为UTF-8或UTF-16。sqlite3_prepare()、 sqlite3_prepare_v2()和 sqlite3_prepare_v3()接口使用UTF-8,sqlite3_prepare16()、 sqlite3_prepare16_v2()和 sqlite3_prepare16_v3()使用UTF-16。</target>
        </trans-unit>
        <trans-unit id="f2e250c2ef383dec7dc31067a07b23d0da95c91b" translate="yes" xml:space="preserve">
          <source>The second beta release for SQLite 3.0.</source>
          <target state="translated">SQLite 3.0的第二个测试版本。</target>
        </trans-unit>
        <trans-unit id="771287a1de97a728b2134cd9c420c1c39a0f52c6" translate="yes" xml:space="preserve">
          <source>The second column is the name of the table.</source>
          <target state="translated">第二列是表的名称。</target>
        </trans-unit>
        <trans-unit id="68511a08109abd7af5a81fce815eeb4f023584c9" translate="yes" xml:space="preserve">
          <source>The second form changes the journaling mode for &quot;</source>
          <target state="translated">第二种形式将日记模式改为&quot;&quot;。</target>
        </trans-unit>
        <trans-unit id="2f272c30ebac8ce92b2f903964b40a07bad463d7" translate="yes" xml:space="preserve">
          <source>The second form of the INSERT statement contains a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement instead of a VALUES clause. A new entry is inserted into the table for each row of data returned by executing the SELECT statement. If a column-list is specified, the number of columns in the result of the SELECT must be the same as the number of items in the column-list. Otherwise, if no column-list is specified, the number of columns in the result of the SELECT must be the same as the number of columns in the table. Any SELECT statement, including &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECTs&lt;/a&gt; and SELECT statements with &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; and/or &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; clauses, may be used in an INSERT statement of this form.</source>
          <target state="translated">INSERT语句的第二种形式包含&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句，而不是VALUES子句。对于通过执行SELECT语句返回的每一行数据，表中都会插入一个新条目。如果指定了列列表，则SELECT结果中的列数必须与列列表中的项目数相同。否则，如果未指定column-list，则SELECT结果中的列数必须与表中的列数相同。任何SELECT语句，包括&lt;a href=&quot;lang_select#compound&quot;&gt;复合SELECTs&lt;/a&gt;和带有&lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;和/或&lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt;子句的SELECT语句，都可以在这种形式的INSERT语句中使用。</target>
        </trans-unit>
        <trans-unit id="ec9aa9593798c759bbdf9a6cf2b73541eab87efe" translate="yes" xml:space="preserve">
          <source>The second form of the command is this:</source>
          <target state="translated">命令的第二种形式是这样的。</target>
        </trans-unit>
        <trans-unit id="fa9b557c755fe5c619c7e5fc0af0adff81ce48ad" translate="yes" xml:space="preserve">
          <source>The second form of the pragma listed above is used to set a new limit in bytes for the specified database. A negative number implies no limit. To always truncate rollback journals and WAL files to their minimum size, set the journal_size_limit to zero. Both the first and second forms of the pragma listed above return a single result row containing a single integer column - the value of the journal size limit in bytes. The default journal size limit is -1 (no limit). The &lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT&lt;/a&gt; preprocessor macro can be used to change the default journal size limit at compile-time.</source>
          <target state="translated">上面列出的编译指示的第二种形式用于为指定的数据库设置新的字节限制。负数表示没有限制。要始终将回滚日志和WAL文件截断为最小大小，请将journal_size_limit设置为零。上面列出的编译指示的第一种和第二种形式均返回包含单个整数列的单个结果行-日志大小限制的值（以字节为单位）。默认的日记帐大小限制为-1（无限制）。该&lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT&lt;/a&gt;预处理宏可以用来在编译时更改默认的日志大小限制。</target>
        </trans-unit>
        <trans-unit id="4008980ca9a9274111928748bc06de4b907efa68" translate="yes" xml:space="preserve">
          <source>The second integer, if it is present, is the aggregate size of all data stored on leaf pages in bytes. If the value is negative, then the segment is the output of an unfinished incremental-merge operation, and the absolute value is current size in bytes.</source>
          <target state="translated">第二个整数,如果存在,则是存储在叶页上的所有数据的总大小,单位是字节。如果该值为负,则该段是未完成的增量合并操作的输出,绝对值是当前大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="211c21970b7cdeb91101e574bc29708c2cdfae64" translate="yes" xml:space="preserve">
          <source>The second line above creates a virtual table named &quot;t1&quot; that reads the content of the file named in the argument. The number and names of the columns is determined automatically by reading the first line of content. Other options to the CSV virtual table provide the ability to take the CSV content from a string rather than a separate file, and give the programmer more control over the number and names of the columns. The options are detailed below. The CSV virtual table is usually created as a TEMP table so that it exists only for the current database connection and does not become a permanent part of the database schema. Note that there is no &quot;CREATE TEMP VIRTUAL TABLE&quot; command in SQLite. Instead, prepend the &quot;temp.&quot; schema prefix to the name of the virtual table.</source>
          <target state="translated">上面第二行创建了一个名为 &quot;t1 &quot;的虚拟表,读取参数中命名的文件内容。列的数量和名称是通过读取第一行内容自动确定的。CSV虚拟表的其他选项提供了从字符串而不是单独的文件中获取CSV内容的能力,并让程序员对列的数量和名称有更多的控制。这些选项详述如下。CSV虚拟表通常是作为TEMP表创建的,这样它只为当前的数据库连接而存在,不会成为数据库模式的永久部分。注意,在SQLite中没有 &quot;CREATE TEMP VIRTUAL TABLE &quot;命令。而是在虚拟表的名称前加上 &quot;temp.&quot;模式前缀。</target>
        </trans-unit>
        <trans-unit id="c3933495d9788c26f88ba69fbabb317f1e83064e" translate="yes" xml:space="preserve">
          <source>The second line of the file contains 211792 characters of impenetrable XML. Yes, 211792 characters all on one line. This file is a good stress-test for a text editor. Thankfully, the file is not some obscure binary format, but in terms of accessibility, it might as well be written in Klingon.</source>
          <target state="translated">文件的第二行包含211792个字符,是无法穿透的XML。是的,211792个字符都在一行。这个文件对文本编辑器来说是一个很好的压力测试。值得庆幸的是,这个文件并不是什么晦涩难懂的二进制格式,但就无障碍性而言,它也可能是用克林贡语写的。</target>
        </trans-unit>
        <trans-unit id="5c1d27adf7a874de9fb599be39fb1d27d63c3092" translate="yes" xml:space="preserve">
          <source>The second number Y is incremented for any change that breaks forward compatibility by adding new features. Most future SQLite releases are expected to increment the second number Y. The Z is reset to zero whenever Y is increased.</source>
          <target state="translated">第二位数字Y是通过增加新功能而破坏前向兼容性的任何变化而递增的,未来的大多数SQLite版本预计会递增第二位数字Y,每当Y增加时,Z会被重置为零。大多数未来的SQLite版本都会对第二个数字Y进行递增,每当Y增加时,Z会被重置为零。</target>
        </trans-unit>
        <trans-unit id="50b9dd44fd65466aa651f4fce7056da00ed7e13a" translate="yes" xml:space="preserve">
          <source>The second parameter (argc) and the fourth parameter (columnNames) are still valid and can be used to determine the number and names of the result columns if there had been a result. The default behavior is not to invoke the callback at all if the result set is empty.</source>
          <target state="translated">第二个参数(argc)和第四个参数(columnNames)仍然有效,如果有结果,可以用来确定结果列的数量和名称。如果结果集为空,默认行为是完全不调用回调。</target>
        </trans-unit>
        <trans-unit id="682054ab4ce2cb4dfe2528dcad7556d5d406ca5f" translate="yes" xml:space="preserve">
          <source>The second parameter is the name of the SQL function to be created or redefined. The length of the name is limited to 255 bytes in a UTF-8 representation, exclusive of the zero-terminator. Note that the name length limit is in UTF-8 bytes, not characters nor UTF-16 bytes. Any attempt to create a function with a longer name will result in &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt; being returned.</source>
          <target state="translated">第二个参数是要创建或重新定义的SQL函数的名称。名称的长度以UTF-8表示形式限制为255个字节，不包括零终止符。请注意，名称长度限制以UTF-8字节为单位，而不是字符或UTF-16字节。任何尝试使用更长名称创建函数的尝试都会导致返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="266b83f6439ab5e88dcd3928741ef542cdbb6626" translate="yes" xml:space="preserve">
          <source>The second parameter is the name of the SQL function to be created or redefined. The length of the name is limited to 255 bytes in a UTF-8 representation, exclusive of the zero-terminator. Note that the name length limit is in UTF-8 bytes, not characters nor UTF-16 bytes. Any attempt to create a function with a longer name will result in &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; being returned.</source>
          <target state="translated">第二个参数是要创建或重新定义的SQL函数的名称。名称的长度以UTF-8表示形式限制为255个字节，不包括零终止符。请注意，名称长度限制以UTF-8字节为单位，而不是字符或UTF-16字节。任何尝试使用更长名称创建函数的尝试都会导致返回&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="560b989b803d6b51bde79f3db2c1500c44cc5751" translate="yes" xml:space="preserve">
          <source>The second parameter to the preupdate callback is a pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that registered the preupdate hook. The third parameter to the preupdate callback is one of the constants &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE&lt;/a&gt; to identify the kind of update operation that is about to occur. The fourth parameter to the preupdate callback is the name of the database within the database connection that is being modified. This will be &quot;main&quot; for the main database or &quot;temp&quot; for TEMP tables or the name given after the AS keyword in the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for attached databases. The fifth parameter to the preupdate callback is the name of the table that is being modified.</source>
          <target state="translated">preupdate回调的第二个参数是指向注册preupdate挂钩的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;的指针。 preupdate回调的第三个参数是常量&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE之一，&lt;/a&gt;用于标识即将发生的更新操作的类型。 preupdate回调的第四个参数是数据库连接中正在修改的数据库的名称。对于主数据库，这将是&amp;ldquo; main&amp;rdquo;；对于TEMP表，这将是&amp;ldquo; temp&amp;rdquo;；对于已连接的数据库，这将在&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;语句中的AS关键字之后给出。 preupdate回调的第五个参数是要修改的表的名称。</target>
        </trans-unit>
        <trans-unit id="097d5db1a651bbf810ec3be53362ed0414cfc3f9" translate="yes" xml:space="preserve">
          <source>The second parameter to the preupdate callback is a pointer to the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that registered the preupdate hook. The third parameter to the preupdate callback is one of the constants &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; to identify the kind of update operation that is about to occur. The fourth parameter to the preupdate callback is the name of the database within the database connection that is being modified. This will be &quot;main&quot; for the main database or &quot;temp&quot; for TEMP tables or the name given after the AS keyword in the &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for attached databases. The fifth parameter to the preupdate callback is the name of the table that is being modified.</source>
          <target state="translated">preupdate回调的第二个参数是指向注册preupdate挂钩的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;的指针。 preupdate回调的第三个参数是常量&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;，&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;或&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE之一，&lt;/a&gt;用于标识即将发生的更新操作的类型。 preupdate回调的第四个参数是数据库连接中正在修改的数据库的名称。对于主数据库，这将是&amp;ldquo; main&amp;rdquo;；对于TEMP表，这将是&amp;ldquo; temp&amp;rdquo;；对于已连接的数据库，这将在&lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;语句中的AS关键字之后给出。 preupdate回调的第五个参数是要修改的表的名称。</target>
        </trans-unit>
        <trans-unit id="f5ad56c8e6b709d2294efc15c0b9ac27fea8d776" translate="yes" xml:space="preserve">
          <source>The second step finds the four shortest paths to visit two nodes beginning with one of the four paths from the previous step. In the case where two or more paths are equivalent (they have the same set of visited nodes, though possibly in a different order) only the first and lowest-cost path is retained. We have:</source>
          <target state="translated">第二步从上一步的四条路径中的一条开始,找出访问两个节点的四条最短路径。在两条或多条路径相等的情况下(它们有相同的访问节点集,虽然顺序可能不同),只保留第一条成本最低的路径。我们有:</target>
        </trans-unit>
        <trans-unit id="73fbb8fcf9b3b6fa8277785714e82cfa142507c2" translate="yes" xml:space="preserve">
          <source>The second through fifth forms of this pragma set the encoding that the main database will be created with if it is created by this session. The string 'UTF-16' is interpreted as &quot;UTF-16 encoding using native machine byte-ordering&quot;. It is not possible to change the text encoding of a database after it has been created and any attempt to do so will be silently ignored.</source>
          <target state="translated">这个pragma的第二到第五种形式设置了如果主数据库是由这个会话创建的,它将被创建的编码。字符串'UTF-16'被解释为 &quot;使用本机字节排序的UTF-16编码&quot;。在创建数据库后,不可能更改数据库的文本编码,任何试图这样做的行为都将被默默忽略。</target>
        </trans-unit>
        <trans-unit id="5882943850506b5e4c2358f26a0aca06e4d009ac" translate="yes" xml:space="preserve">
          <source>The secure_delete setting causes deleted content to be overwritten with zeros. There is a small performance penalty since additional I/O must occur. On the other hand, secure_delete can prevent fragments of sensitive information from lingering in unused parts of the database file after it has been deleted. See the documentation on the &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete pragma&lt;/a&gt; for additional information.</source>
          <target state="translated">secure_delete设置导致删除的内容被零覆盖。由于必须进行额外的I / O，因此性能损失很小。另一方面，secure_delete可以防止敏感信息的片段在删除后保留在数据库文件的未使用部分中。有关其他信息，请参见&lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete编译&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="5b04afcfc3f7fd09080833015b31410c518c0339" translate="yes" xml:space="preserve">
          <source>The separate &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; description provides details on the structure of a database file and of the write-head log file used in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. But details of the locking protocol and of the format of the WAL-index are deliberately omitted since those details are left to discretion of individual &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations. This document fills in those missing details for the unix and windows &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;.</source>
          <target state="translated">单独的&lt;a href=&quot;fileformat2&quot;&gt;文件格式&lt;/a&gt;描述提供了有关&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;使用的数据库文件和写头日志文件的结构的详细信息。但是有意省略了锁定协议的细节和WAL-index格式的细节，因为这些细节留给各个&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;实现酌情决定。本文档填充了UNIX和Windows &lt;a href=&quot;vfs&quot;&gt;VFS的&lt;/a&gt;那些缺失的详细信息。</target>
        </trans-unit>
        <trans-unit id="92103d1dd017d8e08e89604f71cfaaa913bec164" translate="yes" xml:space="preserve">
          <source>The session extension facilitates this by recording all changes to both Alice's and Bob's databases and writing those changes into changeset or patchset files. At the end of the day, Alice can send her changeset to Bob and Bob can &quot;apply&quot; it to his database. The result (assuming there are no conflicts) is that Bob's database then contains both his changes and Alice's changes. Likewise, Bob can send a changeset of his work over to Alice and she can apply his changes to her database.</source>
          <target state="translated">会话扩展通过记录Alice和Bob数据库的所有变化,并将这些变化写进变化集或补丁集文件中来实现这一目的。在一天结束的时候,Alice可以把她的变化集发送给Bob,Bob可以把它应用到他的数据库中。结果(假设没有冲突)是Bob的数据库中包含了他的变化和Alice的变化。同样的,Bob可以把他的工作变化集发送给Alice,而Alice可以把他的变化应用到她的数据库中。</target>
        </trans-unit>
        <trans-unit id="1c8659fbbef014d7697d1ea170e739bed552acd5" translate="yes" xml:space="preserve">
          <source>The session extension only works with tables that have a declared PRIMARY KEY. The PRIMARY KEY of a table may be an INTEGER PRIMARY KEY (rowid alias) or an external PRIMARY KEY.</source>
          <target state="translated">会话扩展只适用于有声明PRIMARY KEY的表。表的PRIMARY KEY可以是一个INTEGER PRIMARY KEY(rowid别名)或一个外部PRIMARY KEY。</target>
        </trans-unit>
        <trans-unit id="8619b8eb0bb510e39b3c8622337b2bb7b6549aba" translate="yes" xml:space="preserve">
          <source>The session extension provide a mechanism for recording changes to some or all of the &lt;a href=&quot;rowidtable&quot;&gt;rowid tables&lt;/a&gt; in an SQLite database, and packaging those changes into a &quot;changeset&quot; or &quot;patchset&quot; file that can later be used to apply the same set of changes to another database with the same schema and compatible starting data. A &quot;changeset&quot; may also be inverted and used to &quot;undo&quot; a session.</source>
          <target state="translated">会话扩展提供了一种机制，用于记录对SQLite数据库中某些或所有&lt;a href=&quot;rowidtable&quot;&gt;rowid表&lt;/a&gt;的更改，并将这些更改打包到&amp;ldquo; changeset&amp;rdquo;或&amp;ldquo; patchset&amp;rdquo;文件中，这些文件以后可用于将同一组更改应用于另一个具有相同架构和兼容起始数据的数据库。&amp;ldquo;变更集&amp;rdquo;也可以反转并用于&amp;ldquo;撤消&amp;rdquo;会话。</target>
        </trans-unit>
        <trans-unit id="0b97f5ba300285bc33992abb7779519b897b7aa7" translate="yes" xml:space="preserve">
          <source>The session object &quot;indirect&quot; flag is set when the change is made, or</source>
          <target state="translated">变更时设置会话对象 &quot;间接 &quot;标志,或者是</target>
        </trans-unit>
        <trans-unit id="ffcb76dee8dc3b4cb20fe29908bbbe2ff2230909" translate="yes" xml:space="preserve">
          <source>The session object is configured with a set of tables to monitor changes on.</source>
          <target state="translated">会话对象配置了一组表来监控变化。</target>
        </trans-unit>
        <trans-unit id="0c67ff7ccfd533851dea34da8187939bbeae8841" translate="yes" xml:space="preserve">
          <source>The session object is deleted using a call to the &lt;a href=&quot;session/sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt; API function.</source>
          <target state="translated">可以使用对&lt;a href=&quot;session/sqlite3session_delete&quot;&gt;sqlite3session_delete（）&lt;/a&gt; API函数的调用来删除会话对象。</target>
        </trans-unit>
        <trans-unit id="b41c2d1dd25f0b9daf0304c7870c3eb7ae78b919" translate="yes" xml:space="preserve">
          <source>The session object therefore accumulates two types of records - those that consist of primary key values only (created when the user inserts a new record) and those that consist of the primary key values and the original values of other table columns (created when the users deletes or updates a record).</source>
          <target state="translated">因此,会话对象积累了两种类型的记录--仅由主键值组成的记录(当用户插入一条新记录时创建)和由主键值和其他表列的原始值组成的记录(当用户删除或更新一条记录时创建)。</target>
        </trans-unit>
        <trans-unit id="67b4d05a6aa852ba851b95d39158470c33cead0c" translate="yes" xml:space="preserve">
          <source>The session object will be used to create changesets for tables in database zDb, where zDb is either &quot;main&quot;, or &quot;temp&quot;, or the name of an attached database. It is not an error if database zDb is not attached to the database when the session object is created.</source>
          <target state="translated">会话对象将用于为数据库zDb中的表创建更改集,其中zDb是 &quot;main &quot;或 &quot;temp&quot;,或者是附加数据库的名称。如果在创建会话对象时,数据库zDb没有被连接到数据库,这并不是一个错误。</target>
        </trans-unit>
        <trans-unit id="45a8679117c7936fefc29c4e8b252b099d09917b" translate="yes" xml:space="preserve">
          <source>The sessions module never invokes an xOutput callback with the third parameter set to a value less than or equal to zero. Other than this, no guarantees are made as to the size of the chunks of data returned.</source>
          <target state="translated">会话模块从不调用第三个参数设置为小于或等于0的xOutput回调。除此之外,我们不保证返回的数据块的大小。</target>
        </trans-unit>
        <trans-unit id="a218d47a709906affb4f3ae717da9de3077b519d" translate="yes" xml:space="preserve">
          <source>The sessions module revolves around creating and manipulating changesets. A changeset is a blob of data that encodes a series of changes to a database. Each change in a changeset is one of the following:</source>
          <target state="translated">会话模块围绕着创建和操作变更集展开。一个变化集是一个数据块,它编码了一系列对数据库的变化。变更集中的每一个变化都是以下几种情况之一。</target>
        </trans-unit>
        <trans-unit id="d639d6bbcd88a2f2cd5339240f5d5c5de8f80432" translate="yes" xml:space="preserve">
          <source>The set X contains the index in aPgno of every entry in the current 32768-byte unit of the shm file that might possible be a solution to the FindFrame(P,M) function. Each of these entries must be checked separately to ensure that the aPgno value is P and that the frame number does not exceed M. The largest frame number that passes those two tests is the answer.</source>
          <target state="translated">集X包含了shm文件当前32768字节单位中每一个可能是FindFrame(P,M)函数解的条目在aPgno中的索引。每一个条目都必须单独检查,以确保aPgno的值是P,并且帧数不超过M,通过这两个测试的最大帧数就是答案。</target>
        </trans-unit>
        <trans-unit id="daeab809359987c0f17f57c78f38704f62041f7b" translate="yes" xml:space="preserve">
          <source>The set of</source>
          <target state="translated">这套</target>
        </trans-unit>
        <trans-unit id="df619f50e7143055665ccf4d69e938c1340f4737" translate="yes" xml:space="preserve">
          <source>The set of built-in auxiliary functions provided by FTS5 may be improved upon in the future.</source>
          <target state="translated">未来可能会对FTS5提供的一组内置辅助功能进行改进。</target>
        </trans-unit>
        <trans-unit id="a49341beec33b485301f8bafe6ae6c61c6f39915" translate="yes" xml:space="preserve">
          <source>The set of checklist items for release checklist is potentially updated for each release. The content and complete history of each release checklist are retained for the historical record.</source>
          <target state="translated">每次发布时,发布检查表的检查项目集都有可能更新。每份发布检查表的内容和完整的历史记录都会被保留下来,作为历史记录。</target>
        </trans-unit>
        <trans-unit id="0f5a66644e1d1f4b0f41c960d4f2f7a794b20868" translate="yes" xml:space="preserve">
          <source>The set of static mutexes may change from one SQLite release to the next. Applications that override the built-in mutex logic must be prepared to accommodate additional static mutexes.</source>
          <target state="translated">静态mutexes集可能会从一个SQLite版本改变到下一个版本。覆盖内置的mutex逻辑的应用程序必须准备好适应额外的静态mutexes。</target>
        </trans-unit>
        <trans-unit id="9b60f1982b5c4164ca917a617479f0aacfe46294" translate="yes" xml:space="preserve">
          <source>The shadow tables are ordinary SQLite data tables. You can query them directly if you like, though this unlikely to reveal anything particularly useful. And you can &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; or even &lt;a href=&quot;lang_droptable&quot;&gt;DROP&lt;/a&gt; the shadow tables, though doing so will corrupt your R*Tree index. So it is best to simply ignore the shadow tables. Recognize that they hold your R*Tree index information and let it go as that.</source>
          <target state="translated">影子表是普通的SQLite数据表。您可以根据需要直接查询它们，尽管这不可能揭示任何特别有用的东西。而且您可以&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;，&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;，&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;甚至是&lt;a href=&quot;lang_droptable&quot;&gt;DROP&lt;/a&gt;影子表，尽管这样做会破坏您的R * Tree索引。因此，最好只是忽略影子表。认识到他们拥有您的R * Tree索引信息，并就这样继续进行。</target>
        </trans-unit>
        <trans-unit id="7b89e4e1261efca1d668789aecafeceb06cf0045" translate="yes" xml:space="preserve">
          <source>The shared library filename passed to &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; may omit the filename suffix, and an appropriate architecture-dependent suffix (&quot;.so&quot;, &quot;.dylib&quot;, or &quot;.dll&quot;) will be added automatically.</source>
          <target state="translated">传递给&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;的共享库文件名可以省略文件名后缀，并且将自动添加适当的与体系结构相关的后缀（&amp;ldquo; .so&amp;rdquo;，&amp;ldquo;。dylib&amp;rdquo;或&amp;ldquo; .dll&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="683712ddb2de169a205df89a5ffe29d5c006c2b5" translate="yes" xml:space="preserve">
          <source>The shared-memory file contains no persistent content. The only purpose of the shared-memory file is to provide a block of shared memory for use by multiple processes all accessing the same database in WAL mode. If the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; is able to provide an alternative method for accessing shared memory, then that alternative method might be used rather than the shared-memory file. For example, if &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMA locking_mode&lt;/a&gt; is set to EXCLUSIVE (meaning that only one process is able to access the database file) then the shared memory will be allocated from heap rather than out of the shared-memory file, and the shared-memory file will never be created.</source>
          <target state="translated">共享内存文件不包含任何持久性内容。共享内存文件的唯一目的是提供一块共享内存，供所有以WAL模式访问同一数据库的多个进程使用。如果&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;能够提供一种访问共享内存的替代方法，则可以使用该替代方法而不是共享内存文件。例如，如果&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMAlocking_mode&lt;/a&gt;设置为EXCLUSIVE（意味着只有一个进程能够访问数据库文件），则共享内存将从堆中分配，而不是从共享内存文件中分配，并且共享内存文件将永远不会被创造。</target>
        </trans-unit>
        <trans-unit id="d84d71db4e9c7a1a18a467e4bbe2be0320c053f2" translate="yes" xml:space="preserve">
          <source>The shared-memory file has the same lifetime as its associated WAL file. The shared-memory file is created when the WAL file is created and is deleted when the WAL file is deleted. During WAL file recovery, the shared memory file is recreated from scratch based on the contents of the WAL file being recovered.</source>
          <target state="translated">共享内存文件与其关联的WAL文件具有相同的寿命。当创建WAL文件时,共享内存文件被创建,当删除WAL文件时,共享内存文件被删除。在WAL文件恢复过程中,共享内存文件会根据被恢复的WAL文件的内容从头开始重新创建。</target>
        </trans-unit>
        <trans-unit id="c6175d074e784d9fffd662056186d3e1dc1f4cc9" translate="yes" xml:space="preserve">
          <source>The shm does not contain any database content and is not required to recover the database following a crash. For that reason, the first client to connect to a quiescent database will normally truncate the shm file if it exists. Since the content of the shm file does not need to be preserved across a crash, the shm file is never fsync()-ed to disk. In fact, if there were a mechanism by which SQLite could tell the operating system to never persist the shm file to disk but always hold it in cache memory, SQLite would use that mechanism to avoid any unnecessary disk I/O associated with the shm file. However, no such mechanism exists in standard posix.</source>
          <target state="translated">shm不包含任何数据库内容,也不需要在崩溃后恢复数据库。因此,第一个连接到静止数据库的客户端通常会截断shm文件(如果它存在的话)。由于shm文件的内容不需要在崩溃时保存,所以shm文件永远不会被fsync()-ed到磁盘上。事实上,如果有一种机制可以让SQLite告诉操作系统永远不要将shm文件持久化到磁盘上,而总是将其保存在缓存中,那么SQLite就会使用这种机制来避免与shm文件相关的任何不必要的磁盘I/O。然而,在标准posix中不存在这样的机制。</target>
        </trans-unit>
        <trans-unit id="2ce5842569cd9ae6cb873fe122d925e98dfd9e57" translate="yes" xml:space="preserve">
          <source>The shm file consists of one or more hash tables, where each hash table is 32768 bytes in size. Except, a 136-byte header is carved out of the front of the very first hash table, so the first hash table is only 32632 bytes in size. The total size of the shm file is always a multiple of 32768. In most cases, the total size of the shm file is exactly 32768 bytes. The shm file only needs to grow beyond a single hash table if when the wal file grows very large (more than 4079 frames). Since the default &lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;automatic checkpoint threshold&lt;/a&gt; is 1000, WAL files rare reach the 4079 threshold needed to make the shm file grow.</source>
          <target state="translated">shm文件由一个或多个哈希表组成，其中每个哈希表的大小为32768字节。除了在第一个哈希表的开头雕刻了一个136字节的标头之外，因此第一个哈希表的大小仅为32632字节。 shm文件的总大小始终是32768的倍数。在大多数情况下，shm文件的总大小恰好是32768字节。如果wal文件变得非常大（超过4079帧），则shm文件仅需要增长到单个哈希表之外。由于默认的&lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;自动检查点阈&lt;/a&gt;值为1000，因此WAL文件很少达到使shm文件增长所需的4079阈值。</target>
        </trans-unit>
        <trans-unit id="0d8774149ef596e36906cd1fe56afff10a697841" translate="yes" xml:space="preserve">
          <source>The signature of the xAccess method has been modified to return an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; and to store its output into an integer pointed to by a parameter, rather than returning the output directly. This change allows the xAccess() method to report failures. In association with this signature change, a new extended error code &lt;a href=&quot;rescode#ioerr_access&quot;&gt;SQLITE_IOERR_ACCESS&lt;/a&gt; has been added.</source>
          <target state="translated">已修改xAccess方法的签名，以返回&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;并将其输出存储到参数指向的整数中，而不是直接返回输出。此更改使xAccess（）方法可以报告失败。与此签名更改相关联，添加了新的扩展错误代码&lt;a href=&quot;rescode#ioerr_access&quot;&gt;SQLITE_IOERR_ACCESS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="73da15d1378e7e4cecf6c05a9921a5f1b3117f3b" translate="yes" xml:space="preserve">
          <source>The signature of the xCheckReservedLock method on &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; has been modified so that it returns an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; and stores its boolean result into an integer pointed to by a parameter. In association with this change, a new extended error code &lt;a href=&quot;rescode#ioerr_checkreservedlock&quot;&gt;SQLITE_IOERR_CHECKRESERVEDLOCK&lt;/a&gt; has been added.</source>
          <target state="translated">&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;上xCheckReservedLock方法的签名已被修改，以便它返回&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;并将其布尔结果存储到参数所指向的整数中。与此更改关联，添加了新的扩展错误代码&lt;a href=&quot;rescode#ioerr_checkreservedlock&quot;&gt;SQLITE_IOERR_CHECKRESERVEDLOCK&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23da313c5318bbaf1e11638c6787139e74ceff62" translate="yes" xml:space="preserve">
          <source>The simple, modular design of SQLite makes it a good platform for prototyping new, experimental database language features or ideas.</source>
          <target state="translated">SQLite简单、模块化的设计使其成为一个很好的平台,可以对新的、实验性的数据库语言功能或想法进行原型设计。</target>
        </trans-unit>
        <trans-unit id="2d0de7ad7a0838db1beb185b37e3f4659d20a947" translate="yes" xml:space="preserve">
          <source>The single row of result-set data created by evaluating the aggregate and non-aggregate expressions in the result-set forms the result of an aggregate query without a GROUP BY clause. An aggregate query without a GROUP BY clause always returns exactly one row of data, even if there are zero rows of input data.</source>
          <target state="translated">通过评估结果集中的聚合和非聚合表达式创建的单行结果集数据,形成了没有GROUP BY子句的聚合查询的结果。没有GROUP BY子句的聚合查询总是只返回一行数据,即使输入数据的行数为零。</target>
        </trans-unit>
        <trans-unit id="fee8fe6df1809775fcd62fdf9f110bcf759d94a6" translate="yes" xml:space="preserve">
          <source>The six streaming API xxx_strm() functions serve similar purposes to the corresponding non-streaming API functions:</source>
          <target state="translated">六个流式API xxx_strm()函数的作用与相应的非流式API函数类似。</target>
        </trans-unit>
        <trans-unit id="af903c0dcc364c9d11abbe191c3960a1c5d014f5" translate="yes" xml:space="preserve">
          <source>The sixth argument to sqlite3_bind_text64() must be one of &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; to specify the encoding of the text in the third parameter. If the sixth argument to sqlite3_bind_text64() is not one of the allowed values shown above, or if the text encoding is different from the encoding specified by the sixth parameter, then the behavior is undefined.</source>
          <target state="translated">sqlite3_bind_text64（）的第六个参数必须是&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;，&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;之一，以在第三个参数中指定文本的编码。如果sqlite3_bind_text64（）的第六个参数不是上面显示的允许值之一，或者文本编码与第六个参数指定的编码不同，则该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="3a920902ff183846916ffe84129516653c512659" translate="yes" xml:space="preserve">
          <source>The sixth argument to sqlite3_bind_text64() must be one of &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; to specify the encoding of the text in the third parameter. If the sixth argument to sqlite3_bind_text64() is not one of the allowed values shown above, or if the text encoding is different from the encoding specified by the sixth parameter, then the behavior is undefined.</source>
          <target state="translated">sqlite3_bind_text64（）的第六个参数必须是&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;，&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;，&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;或&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;之一，以在第三个参数中指定文本的编码。如果sqlite3_bind_text64（）的第六个参数不是上面显示的允许值之一，或者文本编码与第六个参数指定的编码不同，则该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="e8b06ccbdc8c379a9a470f7c185a0247a80f8e2b" translate="yes" xml:space="preserve">
          <source>The sixth, seventh and eighth parameters passed to the three &quot;sqlite3_create_function*&quot; functions, xFunc, xStep and xFinal, are pointers to C-language functions that implement the SQL function or aggregate. A scalar SQL function requires an implementation of the xFunc callback only; NULL pointers must be passed as the xStep and xFinal parameters. An aggregate SQL function requires an implementation of xStep and xFinal and NULL pointer must be passed for xFunc. To delete an existing SQL function or aggregate, pass NULL pointers for all three function callbacks.</source>
          <target state="translated">传递给三个 &quot;sqlite3_create_function*&quot;函数xFunc、xStep和xFinal的第六、第七和第八个参数是实现SQL函数或集合的C语言函数的指针。一个标量SQL函数只需要实现xFunc回调,NULL指针必须作为xStep和xFinal参数传递。聚合SQL函数需要xStep和xFinal的实现,必须为xFunc传递NULL指针。要删除一个现有的SQL函数或聚合函数,必须为这三个函数的回调传递NULL指针。</target>
        </trans-unit>
        <trans-unit id="5a1e0ca7d22b49ccdf57dfbe9e13e610f7e7488a" translate="yes" xml:space="preserve">
          <source>The sixth, seventh, eighth and ninth parameters (xStep, xFinal, xValue and xInverse) passed to sqlite3_create_window_function are pointers to C-language callbacks that implement the new function. xStep and xFinal must both be non-NULL. xValue and xInverse may either both be NULL, in which case a regular aggregate function is created, or must both be non-NULL, in which case the new function may be used as either an aggregate or aggregate window function. More details regarding the implementation of aggregate window functions are &lt;a href=&quot;../windowfunctions#udfwinfunc&quot;&gt;available here&lt;/a&gt;.</source>
          <target state="translated">传递给sqlite3_create_window_function的第六，第七，第八和第九个参数（xStep，xFinal，xValue和xInverse）是指向实现新功能的C语言回调的指针。 xStep和xFinal必须都为非NULL。 xValue和xInverse都可以为NULL（在这种情况下会创建常规的聚合函数），或者必须都为非NULL（在这种情况下，新函数可以用作聚合或聚​​合窗口函数）。有关聚合窗口功能实现的更多详细信息，&lt;a href=&quot;../windowfunctions#udfwinfunc&quot;&gt;请参见此处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f70d86715eabcca8a7d61d2f6e68b2fc4d6a57e" translate="yes" xml:space="preserve">
          <source>The sixth, seventh, eighth and ninth parameters (xStep, xFinal, xValue and xInverse) passed to sqlite3_create_window_function are pointers to C-language callbacks that implement the new function. xStep and xFinal must both be non-NULL. xValue and xInverse may either both be NULL, in which case a regular aggregate function is created, or must both be non-NULL, in which case the new function may be used as either an aggregate or aggregate window function. More details regarding the implementation of aggregate window functions are &lt;a href=&quot;windowfunctions#udfwinfunc&quot;&gt;available here&lt;/a&gt;.</source>
          <target state="translated">传递给sqlite3_create_window_function的第六，第七，第八和第九个参数（xStep，xFinal，xValue和xInverse）是指向实现新功能的C语言回调的指针。 xStep和xFinal必须都为非NULL。 xValue和xInverse都可以为NULL（在这种情况下会创建常规的聚合函数），或者必须都为非NULL（在这种情况下，新函数可以用作聚合或聚​​合窗口函数）。有关聚合窗口功能实现的更多详细信息，&lt;a href=&quot;windowfunctions#udfwinfunc&quot;&gt;请参见此处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="650196bb22cf5bf05d1563df9b31bf781c3e9a6d" translate="yes" xml:space="preserve">
          <source>The size of the blobs in the test data affects performance. The filesystem will generally be faster for larger blobs, since the overhead of open() and close() is amortized over more bytes of I/O, whereas the database will be more efficient in both speed and space as the average blob size decreases.</source>
          <target state="translated">测试数据中的 blobs 大小会影响性能。一般来说,文件系统对于较大的blob会更快,因为open()和close()的开销是通过更多的I/O字节来分摊的,而数据库随着blob平均大小的减小,在速度和空间上都会更有效率。</target>
        </trans-unit>
        <trans-unit id="71ba6b5b378d657456a5945d2ff20a780b1b14d4" translate="yes" xml:space="preserve">
          <source>The size of the lookaside memory pool has a global default value but can also be configured on a connection-by-connection basis. To change the default size of the lookaside memory pool at compile-time, use the &lt;a href=&quot;compile#default_lookaside&quot;&gt;-DSQLITE_DEFAULT_LOOKASIDE=&lt;i&gt;SZ,N&lt;/i&gt;&lt;/a&gt; option. To change the default size of the lookaside memory pool at start-time, use the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface:</source>
          <target state="translated">后备内存池的大小具有全局默认值，但也可以基于逐个连接进行配置。要在编译时更改后备内存池的默认大小，请使用&lt;a href=&quot;compile#default_lookaside&quot;&gt;-DSQLITE_DEFAULT_LOOKASIDE = &lt;i&gt;SZ，N&lt;/i&gt;&lt;/a&gt;选项。要在启动时更改后备内存池的默认大小，请使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;接口：</target>
        </trans-unit>
        <trans-unit id="7032e0044fe8cbf0ccd0392512f38ee2b17ffc25" translate="yes" xml:space="preserve">
          <source>The size of the matching term in bytes.</source>
          <target state="translated">匹配项的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="481f99d28cac0daa50062e9ad3a05601840366c0" translate="yes" xml:space="preserve">
          <source>The size of the memory-mapped I/O region cannot be changed while the memory-mapped I/O region is in active use, to avoid unmapping memory out from under running SQL statements. For this reason, the mmap_size pragma may be a no-op if the prior mmap_size is non-zero and there are other SQL statements running concurrently on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">内存映射的I / O区域处于活动状态时，不能更改内存映射的I / O区域的大小，以避免在正在运行的SQL语句中取消内存的映射。因此，如果先前的mmap_size不为零，并且在同一&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;上同时运行其他SQL语句，则mmap_size编译指示可能为空。</target>
        </trans-unit>
        <trans-unit id="19c67c781984d7843a725bf421c45281605af01e" translate="yes" xml:space="preserve">
          <source>The snippet function first attempts to find a fragment of text consisting of</source>
          <target state="translated">代码段函数首先尝试查找由以下内容组成的文本片段</target>
        </trans-unit>
        <trans-unit id="54b3f9fdd628ef57cd97424e1a01116d0ba15ccd" translate="yes" xml:space="preserve">
          <source>The snippet function is used to create formatted fragments of document text for display as part of a full-text query results report. The snippet function may be passed between one and six arguments, as follows:</source>
          <target state="translated">snippet函数用于创建格式化的文档文本片段,以便作为全文查询结果报告的一部分显示。可以通过一个到六个参数来传递snippet函数,如下所示:</target>
        </trans-unit>
        <trans-unit id="25ab90403f978d997e2573cced370b12d71d602c" translate="yes" xml:space="preserve">
          <source>The snippet() function is similar to highlight(), except that instead of returning entire column values, it automatically selects and extracts a short fragment of document text to process and return. The snippet() function must be passed five parameters following the table name argument:</source>
          <target state="translated">snippet()函数类似于highlight(),不同的是,它不是返回整个列的值,而是自动选择和提取文档文本的一个短片段来处理和返回。snippet()函数必须在表名参数后传递五个参数。</target>
        </trans-unit>
        <trans-unit id="650db23255aac8aa4103c6f6d9992ba8c2854051" translate="yes" xml:space="preserve">
          <source>The soft heap limit is &quot;soft&quot; in this sense: If SQLite is not able to free up enough auxiliary memory to stay below the limit, it goes ahead and allocates the extra memory and exceeds its limit. This occurs under the theory that it is better to use additional memory than to fail outright.</source>
          <target state="translated">软堆限制在这个意义上是 &quot;软 &quot;的:如果SQLite无法释放出足够的辅助内存,无法保持在限额以下,它就会去分配额外的内存,并超过其限额。这种情况发生的理论是,使用额外的内存比直接失败要好。</target>
        </trans-unit>
        <trans-unit id="f259c7b18142819d8b2454c94e82cad365d3cfbd" translate="yes" xml:space="preserve">
          <source>The soft heap limit is not enforced in the current implementation if one or more of following conditions are true:</source>
          <target state="translated">如果以下一个或多个条件为真,软堆限制在当前的实施中不会被执行。</target>
        </trans-unit>
        <trans-unit id="62f643dbe59889b37bb6ee27203ce861b75e4df1" translate="yes" xml:space="preserve">
          <source>The soft heap limit is set to zero.</source>
          <target state="translated">软堆限制设置为零。</target>
        </trans-unit>
        <trans-unit id="1e9f9417ca080fbcc56641af6510e79f88f545c2" translate="yes" xml:space="preserve">
          <source>The soft heap limit may not be greater than the hard heap limit. If the hard heap limit is enabled and if sqlite3_soft_heap_limit(N) is invoked with a value of N that is greater than the hard heap limit, the the soft heap limit is set to the value of the hard heap limit. The soft heap limit is automatically enabled whenever the hard heap limit is enabled. When sqlite3_hard_heap_limit64(N) is invoked and the soft heap limit is outside the range of 1..N, then the soft heap limit is set to N. Invoking sqlite3_soft_heap_limit64(0) when the hard heap limit is enabled makes the soft heap limit equal to the hard heap limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84963983acb45095ae249428915953ba1875b5f1" translate="yes" xml:space="preserve">
          <source>The solution was computed in less than 300 milliseconds on a modern workstation.</source>
          <target state="translated">在现代工作站上,该解决方案的计算时间不到300毫秒。</target>
        </trans-unit>
        <trans-unit id="d8fc439428a4b57b8a635dfdc3bc6c9e9458a598" translate="yes" xml:space="preserve">
          <source>The solver works by adding new entries to the &quot;x&quot; recursive table. Given prior entries, the recursive-select tries to fill in a single new position with all values between 1 and 9 that actually work in that position. The complicated &quot;NOT EXISTS&quot; subquery is the magic that figures out whether or not each candidate &quot;s&quot; string is a valid sudoku puzzle or not.</source>
          <target state="translated">求解器通过向 &quot;x &quot;递归表添加新条目来工作。给定先前的条目,递归选择试图用1到9之间的所有值来填补一个新的位置,而这些值实际上是在这个位置上工作的。复杂的 &quot;NOT EXISTS &quot;子查询是计算出每个候选 &quot;s &quot;字符串是否为有效数独谜题的法宝。</target>
        </trans-unit>
        <trans-unit id="a81e5007b5735cbaaaf41fe92b085a6bb28859ca" translate="yes" xml:space="preserve">
          <source>The sorter can use auxiliary helper threads to increase real-time response. This feature is off by default and may be enabled using the &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; command or the &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; compile-time option.</source>
          <target state="translated">排序器可以使用辅助帮助器线程来增加实时响应。此功能默认情况下处于关闭状态，可以使用&lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA线程&lt;/a&gt;命令或&lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt;编译时选项启用。</target>
        </trans-unit>
        <trans-unit id="f3082f533e58c712999cbf940673f567d8a29017" translate="yes" xml:space="preserve">
          <source>The soundex(X) function returns a string that is the soundex encoding of the string X. The string &quot;?000&quot; is returned if the argument is NULL or contains no ASCII alphabetic characters. This function is omitted from SQLite by default. It is only available if the &lt;a href=&quot;compile#soundex&quot;&gt;SQLITE_SOUNDEX&lt;/a&gt; compile-time option is used when SQLite is built.</source>
          <target state="translated">soundex（X）函数返回的字符串是字符串X的soundex编码。如果参数为NULL或不包含ASCII字母字符，则返回字符串&amp;ldquo;？000&amp;rdquo;。默认情况下，SQLite会省略此功能。仅当构建SQLite时使用&lt;a href=&quot;compile#soundex&quot;&gt;SQLITE_SOUNDEX&lt;/a&gt;编译时选项时，此选项才可用。</target>
        </trans-unit>
        <trans-unit id="9611e60fec986c004f40bb3986af444fd02497aa" translate="yes" xml:space="preserve">
          <source>The source &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; may be used by the application for other purposes while a backup operation is underway or being initialized. If SQLite is compiled and configured to support threadsafe database connections, then the source database connection may be used concurrently from within other threads.</source>
          <target state="translated">在备份操作正在进行或初始化时，应用程序可以将源&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;用于其他目的。如果将SQLite编译并配置为支持线程安全数据库连接，则可以从其他线程中同时使用源数据库连接。</target>
        </trans-unit>
        <trans-unit id="d46770cf519d64fb4869e93bb4ebad2a0d214ebb" translate="yes" xml:space="preserve">
          <source>The source &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; may be used by the application for other purposes while a backup operation is underway or being initialized. If SQLite is compiled and configured to support threadsafe database connections, then the source database connection may be used concurrently from within other threads.</source>
          <target state="translated">在备份操作正在进行或初始化时，应用程序可以将源&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;用于其他目的。如果将SQLite编译并配置为支持线程安全数据库连接，则可以从其他线程中同时使用源数据库连接。</target>
        </trans-unit>
        <trans-unit id="cb98bce78cf336a453aacfd68f1f2a70ccf1bb9e" translate="yes" xml:space="preserve">
          <source>The source code files for other SQL database engines typically begin with a comment describing your legal rights to view and copy that file. The SQLite source code contains no license since it is not governed by copyright. Instead of a license, the SQLite source code offers a blessing:</source>
          <target state="translated">其他SQL数据库引擎的源代码文件通常以注释开头,说明你查看和复制该文件的合法权利。SQLite源代码不包含许可证,因为它不受版权的约束。SQLite源代码提供的不是许可证,而是祝福。</target>
        </trans-unit>
        <trans-unit id="b230daf41ab11e7921fa2a959263c09c6fe7e609" translate="yes" xml:space="preserve">
          <source>The source code for Geopoly is included in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; but is not included in the library unless the &lt;a href=&quot;compile#enable_geopoly&quot;&gt;-DSQLITE_ENABLE_GEOPOLY&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">Geopoly的源代码包含在&lt;a href=&quot;amalgamation&quot;&gt;合并中，&lt;/a&gt;但没有包含在库中，除非使用&lt;a href=&quot;compile#enable_geopoly&quot;&gt;-DSQLITE_ENABLE_GEOPOLY&lt;/a&gt;编译时选项。</target>
        </trans-unit>
        <trans-unit id="9ce563d47e369284dcc9eb90d209f5fe50c9d87d" translate="yes" xml:space="preserve">
          <source>The source code for SQLite is in the public domain. No claim of copyright is made on any part of the core source code. (The documentation and test code is a different matter - some sections of documentation and test logic are governed by open-source licenses.) All contributors to the SQLite core software have signed affidavits specifically disavowing any copyright interest in the code. This means that anybody is able to legally do anything they want with the SQLite source code.</source>
          <target state="translated">SQLite的源代码是在公共领域。没有对核心源代码的任何部分提出版权要求。文档和测试代码是另一回事--文档和测试逻辑的某些部分受开源许可证的约束)。SQLite核心软件的所有贡献者都签署了宣誓书,明确表示不承认代码中的任何版权利益。这意味着任何人都可以合法地对SQLite源代码做任何他们想做的事情。</target>
        </trans-unit>
        <trans-unit id="1cfec4458134c689073b56a3f124a05cfee319a4" translate="yes" xml:space="preserve">
          <source>The source code in public SQLite releases uses unix line endings (ASCII code 10: &quot;newline&quot; only, NL) and spaces instead of tabs. If you will be changing the line ending to windows-style line endings (ASCII codes 13, 10: &quot;carriage-return&quot; and &quot;newline&quot;; CR-NL) or if you will be changing space indents into tab indents, &lt;b&gt;make that change now&lt;/b&gt; before you check in the baseline. The merging process will only work well if the differences between the public and the private branches are minimal. If every single line of the source file is changed in the private branch because you changed from NL to CR-NL line endings, then the merge steps will not work correctly.</source>
          <target state="translated">公共SQLite版本中的源代码使用unix行尾（ASCII代码10：仅&amp;ldquo; newline&amp;rdquo;，NL）和空格而不是制表符。如果要将行尾更改为Windows样式的行尾（ASCII代码13、10：&amp;ldquo; carriage-return&amp;rdquo;和&amp;ldquo; newline&amp;rdquo;； CR-NL），或者要将空格缩进更改为制表符缩进，请&lt;b&gt;进行更改现在，&lt;/b&gt;在检查基线之前。只有在公共部门和私人部门之间的差异很小的情况下，合并过程才能很好地工作。如果源文件的每一行都在私人分支中更改（因为您从NL更改为CR-NL行尾），则合并步骤将无法正常进行。</target>
        </trans-unit>
        <trans-unit id="c71fe30151d8d1ffe822e83fe610e421f8822069" translate="yes" xml:space="preserve">
          <source>The source code module that implements the spellfix1 virtual table also implements several SQL functions that might be useful to applications that employ spellfix1 or for testing or diagnostic work while developing applications that use spellfix1. The following auxiliary functions are available:</source>
          <target state="translated">实现spellfix1虚拟表的源码模块还实现了几个SQL函数,这些函数可能对采用spellfix1的应用程序或开发使用spellfix1的应用程序时的测试或诊断工作有用。以下是可用的辅助函数。</target>
        </trans-unit>
        <trans-unit id="06e0d7a5506cbf178b35ec85914ad01a3f38017c" translate="yes" xml:space="preserve">
          <source>The source code to SQLite is designed to be readable and accessible to the average programmer. All procedures and data structures and many automatic variables are carefully commented with useful information about what they do. Boilerplate commenting is omitted.</source>
          <target state="translated">SQLite的源代码被设计成对普通程序员来说是可读和可访问的。所有的程序和数据结构以及许多自动变量都有仔细的注释,并提供了它们的有用信息。锅炉板的注释被省略了。</target>
        </trans-unit>
        <trans-unit id="042c70a1cba19758906aae3ec84cad7dc8c53383" translate="yes" xml:space="preserve">
          <source>The source code to the SQLite R*Tree module is included as part of the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; but is disabled by default. To enable the R*Tree module, simply compile with the &lt;a href=&quot;compile#enable_rtree&quot;&gt;SQLITE_ENABLE_RTREE&lt;/a&gt; C-preprocessor macro defined. With many compilers, this is accomplished by adding the option &quot;-DSQLITE_ENABLE_RTREE=1&quot; to the compiler command-line.</source>
          <target state="translated">SQLite R * Tree模块的源代码包含在&lt;a href=&quot;amalgamation&quot;&gt;合并中，&lt;/a&gt;但默认情况下处于禁用状态。要启用R * Tree模块，只需使用定义的&lt;a href=&quot;compile#enable_rtree&quot;&gt;SQLITE_ENABLE_RTREE&lt;/a&gt; C预处理器宏进行编译。对于许多编译器，这是通过在编译器命令行中添加选项&amp;ldquo; -DSQLITE_ENABLE_RTREE = 1&amp;rdquo;来实现的。</target>
        </trans-unit>
        <trans-unit id="a40cbeb8ac52569bca99e948856ab4db846ed02b" translate="yes" xml:space="preserve">
          <source>The source code to the bytecode engine is in the &lt;a href=&quot;http://www.sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt; source file. The &lt;a href=&quot;opcode#codes&quot;&gt;opcode definitions&lt;/a&gt; in this document are derived from comments in that source file. The source code comments are the canonical source of information about the bytecode engine. When in doubt, refer to the source code.</source>
          <target state="translated">字节码引擎的源代码位于&lt;a href=&quot;http://www.sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt;源文件中。本文档中的&lt;a href=&quot;opcode#codes&quot;&gt;操作码定义&lt;/a&gt;源自该源文件中的注释。源代码注释是有关字节码引擎的规范信息源。如有疑问，请参考源代码。</target>
        </trans-unit>
        <trans-unit id="013177e363c21284dd8426d7c41bb413bf325a0a" translate="yes" xml:space="preserve">
          <source>The source code to the software that runs the checklists is stored in its own Fossil repository at &lt;a href=&quot;https://www.sqlite.org/checklistapp&quot;&gt;https://www.sqlite.org/checklistapp&lt;/a&gt;.</source>
          <target state="translated">运行清单的软件的源代码存储在其自己的Fossil信息库中，&lt;a href=&quot;https://www.sqlite.org/checklistapp&quot;&gt;网址&lt;/a&gt;为https://www.sqlite.org/checklistapp。</target>
        </trans-unit>
        <trans-unit id="79b8e8d26e2fd4c36bb8b15bd366cedd02031771" translate="yes" xml:space="preserve">
          <source>The source code to the sqlite3 command line interface is in a single file named &quot;shell.c&quot;. The shell.c source file is generated from other sources, but most of the code for shell.c can be found in &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src/shell.c.in&lt;/a&gt;. (Regenerate shell.c by typing &quot;make shell.c&quot; from the canonical source tree.) &lt;a href=&quot;howtocompile&quot;&gt;Compile&lt;/a&gt; the shell.c file (together with the &lt;a href=&quot;amalgamation&quot;&gt;sqlite3 library source code&lt;/a&gt;) to generate the executable. For example:</source>
          <target state="translated">sqlite3命令行界面的源代码位于一个名为&amp;ldquo; shell.c&amp;rdquo;的文件中。shell.c源文件是从其他来源生成的，但是大多数shell.c代码可以在&lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src / shell.c.in中&lt;/a&gt;找到。（通过从规范的源代码树中键入&amp;ldquo; make shell.c&amp;rdquo;来重新生成shell.c。）&lt;a href=&quot;howtocompile&quot;&gt;编译&lt;/a&gt; shell.c文件（与&lt;a href=&quot;amalgamation&quot;&gt;sqlite3库源代码一起&lt;/a&gt;）以生成可执行文件。例如：</target>
        </trans-unit>
        <trans-unit id="3baebed042eebfba10dcbc501e7f4785bd1f6d07" translate="yes" xml:space="preserve">
          <source>The source file and entry point are named for &quot;unionvtab&quot; instead of &quot;swarmvtab&quot;. Unionvtab is a &lt;a href=&quot;unionvtab&quot;&gt;separately documented&lt;/a&gt; virtual table that is bundled with swarmvtab.</source>
          <target state="translated">源文件和入口点以&amp;ldquo; unionvtab&amp;rdquo;而不是&amp;ldquo; swarmvtab&amp;rdquo;命名。Unionvtab是&lt;a href=&quot;unionvtab&quot;&gt;单独记录的&lt;/a&gt;虚拟表，与swarmvtab捆绑在一起。</target>
        </trans-unit>
        <trans-unit id="f3fba365763538ecbddb6c57bd7009fd058f9084" translate="yes" xml:space="preserve">
          <source>The special &quot;:memory:&quot; filename also works when using &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt;. For example:</source>
          <target state="translated">当使用&lt;a href=&quot;uri&quot;&gt;URI文件名&lt;/a&gt;时，特殊的&amp;ldquo;：memory：&amp;rdquo;文件名也可以使用。例如：</target>
        </trans-unit>
        <trans-unit id="e94ff833d41c9d30c15767ac9e7aeb85daf442aa" translate="yes" xml:space="preserve">
          <source>The special UPSERT processing happens only for uniqueness constraint on the table that is receiving the INSERT. A &quot;uniqueness constraint&quot; is an explicit UNIQUE or PRIMARY KEY constraint within the CREATE TABLE statement, or a &lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;unique index&lt;/a&gt;. UPSERT does not intervene for failed NOT NULL or foreign key constraints or for constraints that are implemented using triggers.</source>
          <target state="translated">特殊的UPSERT处理仅针对接收INSERT的表上的唯一性约束而发生。&amp;ldquo;唯一性约束&amp;rdquo;是CREATE TABLE语句中的显式UNIQUE或PRIMARY KEY约束，或者是&lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;唯一索引&lt;/a&gt;。UPSERT不会针对失败的NOT NULL或外键约束或使用触发器实现的约束进行干预。</target>
        </trans-unit>
        <trans-unit id="2e94e3f68bdf7fc07fc0dcd878c089797a3fe9a2" translate="yes" xml:space="preserve">
          <source>The special filename &quot;:memory:&quot; can be used anywhere that a database filename is permitted. For example, it can be used as the</source>
          <target state="translated">特殊的文件名&quot;:memory:&quot;可以用在任何允许数据库文件名的地方。例如,它可以被用作</target>
        </trans-unit>
        <trans-unit id="dff68709141a31a267598fa549dc38cfbd61c946" translate="yes" xml:space="preserve">
          <source>The special processing for opening ZIP archives is a trick of the command-line shell, not the core SQLite library. So if you want to open a ZIP archive as a database in your application, you will need to activate the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; module then run an appropriate &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29bca994e11cb6f841a93aac5cdb8471376e38df" translate="yes" xml:space="preserve">
          <source>The specified column of row iRow contains a value that is not a TEXT or BLOB value,</source>
          <target state="translated">行iRow的指定列包含一个不是TEXT或BLOB的值。</target>
        </trans-unit>
        <trans-unit id="06e48e6df6f51c35512fa45acc8a0e8a634c95f8" translate="yes" xml:space="preserve">
          <source>The speedtest1.c program is updated from time to time as the SQLite developers' understanding of what constitutes &quot;typical&quot; usage evolves.</source>
          <target state="translated">speedtest1.c程序会随着SQLite开发人员对 &quot;典型 &quot;用法的理解而不时更新。</target>
        </trans-unit>
        <trans-unit id="5446f248e6916745d646dc3f5e88e893b3ad00cc" translate="yes" xml:space="preserve">
          <source>The speedtest1.c workload that is being measured tries to be representative of a wide range of typical uses of SQLite. But every application is different. The speedtest1.c workload might not be a good proxy for the kinds of activities performed by some applications. The SQLite developers are constantly working to improve the speedtest1.c program, to make it a better proxy for actual SQLite usage. Community feedback is welcomed.</source>
          <target state="translated">正在测量的 speedtest1.c 工作负载试图代表 SQLite 的各种典型用途。但每个应用程序都是不同的。speedtest1.c 工作负载可能无法很好地代表某些应用程序所执行的活动类型。SQLite 开发人员正在不断努力改进 speedtest1.c 程序,使其更好地代表实际 SQLite 使用情况。欢迎社区的反馈意见。</target>
        </trans-unit>
        <trans-unit id="92167de554e681259504f6e2f3edf942b7026bd6" translate="yes" xml:space="preserve">
          <source>The spellfix1 virtual table creates a single shadow table named &quot;%_vocab&quot; (where the % is replaced by the name of the virtual table; Ex: &quot;demo_vocab&quot; for the &quot;demo&quot; virtual table). the shadow table contains the following columns:</source>
          <target state="translated">spellfix1虚拟表创建了一个名为&quot;%_vocab &quot;的影子表(其中%被虚拟表的名称所代替;Ex:&quot;demo_vocab &quot;代表 &quot;demo &quot;虚拟表),影子表包含以下列。</target>
        </trans-unit>
        <trans-unit id="f9097157fe13f14b48b89617ee87aed62da83c73" translate="yes" xml:space="preserve">
          <source>The spellfix1 virtual table uses editdist3 if the &quot;edit_cost_table=TABLE&quot; option is specified as an argument when the spellfix1 virtual table is created. But editdist3 can also be tested directly using the built-in &quot;editdist3()&quot; SQL function. The editdist3() SQL function has 3 forms:</source>
          <target state="translated">如果在创建spellfix1虚拟表时指定 &quot;edit_cost_table=TABLE &quot;选项作为参数,那么spellfix1虚拟表就会使用editdist3。但是editdist3也可以直接使用内置的 &quot;editdist3()&quot;SQL函数进行测试。editdist3()SQL函数有3种形式。</target>
        </trans-unit>
        <trans-unit id="e416e23f51996e4d87d84d45407db4bd482280e4" translate="yes" xml:space="preserve">
          <source>The sqlar_compress(X) function attempts to compress a copy of the string or blob X using the &lt;a href=&quot;https://zlib.net/&quot;&gt;Default&lt;/a&gt; algorithm and returns the result as a blob. If the input X is incompressible, then a copy of X is returned. This routine is used when inserting content into an SQLite Archive.</source>
          <target state="translated">sqlar_compress（X）函数尝试使用&lt;a href=&quot;https://zlib.net/&quot;&gt;Default&lt;/a&gt;算法压缩字符串或Blob X的副本，并将结果作为Blob返回。如果输入X是不可压缩的，则返回X的副本。在将内容插入SQLite存档时使用此例程。</target>
        </trans-unit>
        <trans-unit id="0c132e268d7082089985d58b1716bee78c9b6c72" translate="yes" xml:space="preserve">
          <source>The sqlar_uncompress(Y,SZ) function will undo the compression accomplished by sqlar_compress(X). The Y parameter is the compressed content (the output from a prior call to sqlar_compress()) and SZ is the original uncompressed size of the input X that generated Y. If SZ is less than or equal to the size of Y, that indicates that no compression occurred, and so sqlar_uncompress(Y,SZ) returns a copy of Y. Otherwise, sqlar_uncompress(Y,SZ) runs the Inflate algorithm on Y to uncompress it and restore it to its original form and returns the uncompressed content. This routine is used when extracting content from an SQLite Archive.</source>
          <target state="translated">sqlar_uncompress(Y,SZ)函数将撤销由sqlar_compress(X)完成的压缩。如果SZ小于或等于Y的大小,则表明没有发生压缩,所以sqlar_uncompress(Y,SZ)返回Y的副本。否则,sqlar_uncompress(Y,SZ)会在Y上运行Inflate算法来解压缩,并将其恢复到原始形式,然后返回未压缩的内容。这个例程在从SQLite Archive中提取内容时使用。</target>
        </trans-unit>
        <trans-unit id="9894bd2027e1ec7fe1defc073eb794af8cfcddba" translate="yes" xml:space="preserve">
          <source>The sqldiff.exe utility does not (currently) display differences in &lt;a href=&quot;lang_createtrigger&quot;&gt;TRIGGERs&lt;/a&gt; or &lt;a href=&quot;lang_createview&quot;&gt;VIEWs&lt;/a&gt;.</source>
          <target state="translated">所述sqldiff.exe实用程序执行中不（目前）显示差异&lt;a href=&quot;lang_createtrigger&quot;&gt;触发器&lt;/a&gt;或&lt;a href=&quot;lang_createview&quot;&gt;意见&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1eec35831f2ddb18882fbe495fb78b6e88f27f70" translate="yes" xml:space="preserve">
          <source>The sqldiff.exe utility is unable to compute differences for rowid tables for which the rowid is inaccessible. An example of a table with an inaccessible rowid is:</source>
          <target state="translated">sqldiff.exe 工具无法计算无法访问 rowid 的表的差异。下面是一个无法访问的表的例子。</target>
        </trans-unit>
        <trans-unit id="199f0fae6d132ab01eeef495a83df7f5456338b1" translate="yes" xml:space="preserve">
          <source>The sqldiff.exe utility works by finding rows in the source and destination that are logical &quot;pairs&quot;. The default behavior is to treat two rows as pairs if they are in tables with the same name and they have the same &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, or in the case of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table if they have the same &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;. Any differences in the content of paired rows are output as UPDATEs. Rows in the source database that could not be paired are output as DELETEs. Rows in the destination database that could not be paired are output as INSERTs.</source>
          <target state="translated">sqldiff.exe实用程序通过在源和目标中查找逻辑&amp;ldquo;对&amp;rdquo;的行来工作。默认行为是，如果两行位于相同名称的表中且具有相同的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;，则将它们视为对；如果为&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表，则将它们具有相同的&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;视为一对。成对行内容的任何差异都将作为UPDATE输出。源数据库中无法配对的行将作为DELETE输出。目标数据库中无法配对的行将作为INSERT输出。</target>
        </trans-unit>
        <trans-unit id="5a94a70315a765a01576195e900e88922987242a" translate="yes" xml:space="preserve">
          <source>The sqlite3 program is able to show the results of a query in 14 different formats:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a33930cce71afaf2bac4391a7d92f2102fe6799" translate="yes" xml:space="preserve">
          <source>The sqlite3 program is able to show the results of a query in eight different formats: &quot;csv&quot;, &quot;column&quot;, &quot;html&quot;, &quot;insert&quot;, &quot;line&quot;, &quot;list&quot;, &quot;quote&quot;, &quot;tabs&quot;, and &quot;tcl&quot;. You can use the &quot;.mode&quot; dot command to switch between these output formats.</source>
          <target state="translated">sqlite3程序能够以八种不同的格式显示查询结果。&quot;csv&quot;、&quot;column&quot;、&quot;html&quot;、&quot;insert&quot;、&quot;line&quot;、&quot;list&quot;、&quot;quote&quot;、&quot;tabs &quot;和 &quot;tcl&quot;。你可以使用&quot;.mode &quot;点命令来切换这些输出格式。</target>
        </trans-unit>
        <trans-unit id="c934dde95758c5fad9d43c84ef7f4c41bf3fe114" translate="yes" xml:space="preserve">
          <source>The sqlite3 program provides several convenience commands that are useful for looking at the schema of the database. There is nothing that these commands do that cannot be done by some other means. These commands are provided purely as a shortcut.</source>
          <target state="translated">sqlite3程序提供了几个方便的命令,这些命令对查看数据库的模式很有用。这些命令所做的事情没有什么是不能通过其他方式完成的。这些命令纯粹是作为一种快捷方式提供的。</target>
        </trans-unit>
        <trans-unit id="d730ebfc68ed44661fe9aaa4784f842bff23a6ec" translate="yes" xml:space="preserve">
          <source>The sqlite3_aggregate_context(C,N) routine returns a NULL pointer when first called if N is less than or equal to zero or if a memory allocate error occurs.</source>
          <target state="translated">sqlite3_aggregate_context(C,N)例程在第一次调用时,如果N小于或等于0,或者发生内存分配错误,则返回一个NULL指针。</target>
        </trans-unit>
        <trans-unit id="a781b80076608933fb39f35323ee417edf53e9fb" translate="yes" xml:space="preserve">
          <source>The sqlite3_analyzer utility program is updated to provide better descriptions and to compute a more accurate estimate for &quot;Non-sequential pages&quot;</source>
          <target state="translated">sqlite3_analyzer实用程序已经更新,以提供更好的描述,并计算出更准确的 &quot;非连续页面 &quot;估计值。</target>
        </trans-unit>
        <trans-unit id="cea6cec9b3cecf3cdb8b21b8c439ffacaf7e4757" translate="yes" xml:space="preserve">
          <source>The sqlite3_analyzer.exe Utility Program</source>
          <target state="translated">sqlite3_analyzer.exe实用程序。</target>
        </trans-unit>
        <trans-unit id="08064e181ad262ed7b2155684ee88c71ec311b40" translate="yes" xml:space="preserve">
          <source>The sqlite3_analyzer.exe utility is updated to report the depth of each btree and to show the average fanout for indexes and WITHOUT ROWID tables.</source>
          <target state="translated">sqlite3_analyzer.exe实用程序已经更新,以报告每个btree的深度,并显示索引和WITHOUT ROWID表的平均扇出。</target>
        </trans-unit>
        <trans-unit id="69ea749b99043a4585c42b36d581974b4510bba7" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup object records state information about an ongoing online backup operation. The sqlite3_backup object is created by a call to &lt;a href=&quot;#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; and is destroyed by a call to &lt;a href=&quot;#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_backup对象记录有关正在进行的联机备份操作的状态信息。所述sqlite3_backup目的通过一个调用创建到&lt;a href=&quot;#sqlite3backupinit&quot;&gt;sqlite3_backup_init（） &lt;/a&gt;，并通过呼叫销毁&lt;a href=&quot;#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ff5c92c4105199925092609d2d9f802d1fa55672" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup object records state information about an ongoing online backup operation. The sqlite3_backup object is created by a call to &lt;a href=&quot;backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; and is destroyed by a call to &lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_backup对象记录有关正在进行的联机备份操作的状态信息。所述sqlite3_backup目的通过一个调用创建到&lt;a href=&quot;backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init（） &lt;/a&gt;，并通过呼叫销毁&lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db586a6cde9f4397b1aba32074e60460ba79310a" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_remaining() and sqlite3_backup_pagecount() APIs report values stored by the previous call to sqlite3_backup_step(), they do not actually inspect the source database file. This means that if the source database is written to by another thread or process after the call to sqlite3_backup_step() returns but before the values returned by sqlite3_backup_remaining() and sqlite3_backup_pagecount() are used, the values may be technically incorrect. This is not usually a problem.</source>
          <target state="translated">sqlite3_backup_remaining()和 sqlite3_backup_pagecount()API报告之前调用 sqlite3_backup_step()所存储的值,它们实际上并不检查源数据库文件。这意味着,如果在调用 sqlite3_backup_step()返回之后,但在使用 sqlite3_backup_remaining()和 sqlite3_backup_pagecount()返回的值之前,源数据库被另一个线程或进程写入,那么这些值在技术上可能是不正确的。这通常不是一个问题。</target>
        </trans-unit>
        <trans-unit id="ab13e83a5eec05a800456f808bd2ed14f96ad7d8" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_remaining() routine returns the number of pages still to be backed up at the conclusion of the most recent sqlite3_backup_step(). The sqlite3_backup_pagecount() routine returns the total number of pages in the source database at the conclusion of the most recent sqlite3_backup_step(). The values returned by these functions are only updated by sqlite3_backup_step(). If the source database is modified in a way that changes the size of the source database or the number of pages remaining, those changes are not reflected in the output of sqlite3_backup_pagecount() and sqlite3_backup_remaining() until after the next sqlite3_backup_step().</source>
          <target state="translated">sqlite3_backup_remaining()例程返回最近一次 sqlite3_backup_step()结束时仍然需要备份的页面数。sqlite3_backup_pagecount()例程返回最近一次 sqlite3_backup_step()结束时源数据库的总页数。这些函数返回的值只由 sqlite3_backup_step()更新。如果源数据库被修改,改变了源数据库的大小或剩余页数,这些改变不会反映在sqlite3_backup_pagecount()和sqlite3_backup_remaining()的输出中,直到下一个sqlite3_backup_step()之后。</target>
        </trans-unit>
        <trans-unit id="027c7809f8a158ea3a080d548eaba037441f7cc5" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_step() might return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt; if</source>
          <target state="translated">该sqlite3_backup_step（）可能返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;如果</target>
        </trans-unit>
        <trans-unit id="44bfd22dba6c2a0335c1b72cfe8865a0ed15325c" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_step() might return &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; if</source>
          <target state="translated">该sqlite3_backup_step（）可能返回&lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;如果</target>
        </trans-unit>
        <trans-unit id="a2f8db9336dd78e8265a2d46cc59a9e446011dc7" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_* routines return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success or an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if anything goes wrong. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; might be returned if the size of a string or BLOB exceeds limits imposed by &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) or &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned if the parameter index is out of range. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; is returned if malloc() fails.</source>
          <target state="translated">sqlite3_bind_ *例程成功返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;，如果出现任何&lt;a href=&quot;rescode&quot;&gt;错误，&lt;/a&gt;则返回错误代码。&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt;如果字符串或BLOB的大小超过规定的限制，可能会返回&lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;（&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;）或&lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;。如果参数索引超出范围，则返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_RANGE&lt;/a&gt;。如果malloc（）失败，则返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb0da7fe06be85118ba3dab99ff46185b6777bbe" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_* routines return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success or an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if anything goes wrong. &lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; might be returned if the size of a string or BLOB exceeds limits imposed by &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) or &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;. &lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned if the parameter index is out of range. &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; is returned if malloc() fails.</source>
          <target state="translated">sqlite3_bind_ *例程成功返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;，如果出现任何&lt;a href=&quot;../rescode&quot;&gt;错误，&lt;/a&gt;则返回错误代码。&lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt;如果字符串或BLOB的大小超过规定的限制，可能会返回&lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;（&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;）或&lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;。如果参数索引超出范围，则返回&lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt;。如果malloc（）失败，则返回&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f71713542739e9593b1adb467245384ef671786" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_parameter_name(P,N) interface returns the name of the N-th &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL parameter&lt;/a&gt; in the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P. SQL parameters of the form &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; have a name which is the string &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; respectively. In other words, the initial &quot;:&quot; or &quot;$&quot; or &quot;@&quot; or &quot;?&quot; is included as part of the name. Parameters of the form &quot;?&quot; without a following integer have no name and are referred to as &quot;nameless&quot; or &quot;anonymous parameters&quot;.</source>
          <target state="translated">sqlite3_bind_parameter_name（P，N）接口在&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt; P中返回第N个&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL参数&lt;/a&gt;的名称。形式为&amp;ldquo;？NNN&amp;rdquo;或&amp;ldquo;：AAA&amp;rdquo;或&amp;ldquo; @AAA&amp;rdquo;或&amp;ldquo; $ AAA&amp;rdquo;的SQL参数有一个名称，分别是字符串&amp;ldquo;？NNN&amp;rdquo;或&amp;ldquo;：AAA&amp;rdquo;或&amp;ldquo; @AAA&amp;rdquo;或&amp;ldquo; $ AAA&amp;rdquo;。换句话说，首字母&amp;ldquo;：&amp;rdquo;或&amp;ldquo; $&amp;rdquo;或&amp;ldquo; @&amp;rdquo;或&amp;ldquo;？&amp;rdquo;包含在名称中。形式为&amp;ldquo;？&amp;rdquo;的参数没有后面的整数的名字没有名字，被称为&amp;ldquo;无名&amp;rdquo;或&amp;ldquo;匿名参数&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="8f7478b82c93544aa582bd52cdb8be854dddfaed" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_parameter_name(P,N) interface returns the name of the N-th &lt;a href=&quot;bind_blob&quot;&gt;SQL parameter&lt;/a&gt; in the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P. SQL parameters of the form &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; have a name which is the string &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; respectively. In other words, the initial &quot;:&quot; or &quot;$&quot; or &quot;@&quot; or &quot;?&quot; is included as part of the name. Parameters of the form &quot;?&quot; without a following integer have no name and are referred to as &quot;nameless&quot; or &quot;anonymous parameters&quot;.</source>
          <target state="translated">sqlite3_bind_parameter_name（P，N）接口在&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt; P中返回第N个&lt;a href=&quot;bind_blob&quot;&gt;SQL参数&lt;/a&gt;的名称。形式为&amp;ldquo;？NNN&amp;rdquo;或&amp;ldquo;：AAA&amp;rdquo;或&amp;ldquo; @AAA&amp;rdquo;或&amp;ldquo; $ AAA&amp;rdquo;的SQL参数有一个名称，分别是字符串&amp;ldquo;？NNN&amp;rdquo;或&amp;ldquo;：AAA&amp;rdquo;或&amp;ldquo; @AAA&amp;rdquo;或&amp;ldquo; $ AAA&amp;rdquo;。换句话说，首字母&amp;ldquo;：&amp;rdquo;或&amp;ldquo; $&amp;rdquo;或&amp;ldquo; @&amp;rdquo;或&amp;ldquo;？&amp;rdquo;包含在名称中。形式为&amp;ldquo;？&amp;rdquo;的参数没有后面的整数的名字没有名字，被称为&amp;ldquo;无名&amp;rdquo;或&amp;ldquo;匿名参数&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2f7ba9ace88be98840180479bfcb11ff0ebe16ce" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_pointer(S,I,P,T,D) routine causes the I-th parameter in &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S to have an SQL value of NULL, but to also be associated with the pointer P of type T. D is either a NULL pointer or a pointer to a destructor function for P. SQLite will invoke the destructor D with a single argument of P when it is finished using P. The T parameter should be a static string, preferably a string literal. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_bind_pointer（S，I，P，T，D）例程使已&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt; S中的第I个参数的SQL值为NULL，但也与类型T的指针P关联。D为NULL指针或指向P的析构函数的指针。使用P完成时，SQLite将使用P的单个参数调用析构函数D。T参数应为静态字符串，最好是字符串文字。 sqlite3_bind_pointer（）例程是为SQLite 3.20.0添加的&lt;a href=&quot;bindptr&quot;&gt;指针传递接口的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="658c91c6c69fa0e297b2600c0a7ae1e8d41b306a" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_pointer(S,I,P,T,D) routine causes the I-th parameter in &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S to have an SQL value of NULL, but to also be associated with the pointer P of type T. D is either a NULL pointer or a pointer to a destructor function for P. SQLite will invoke the destructor D with a single argument of P when it is finished using P. The T parameter should be a static string, preferably a string literal. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_bind_pointer（S，I，P，T，D）例程使已&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt; S中的第I个参数的SQL值为NULL，但也与类型T的指针P关联。D为NULL指针或指向P的析构函数的指针。使用P完成时，SQLite将使用P的单个参数调用析构函数D。T参数应为静态字符串，最好是字符串文字。 sqlite3_bind_pointer（）例程是为SQLite 3.20.0添加的&lt;a href=&quot;../bindptr&quot;&gt;指针传递接口的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="6397a7b2569f0831356316d22abee5d260da2f56" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_zeroblob() routine binds a BLOB of length N that is filled with zeroes. A zeroblob uses a fixed amount of memory (just an integer to hold its size) while it is being processed. Zeroblobs are intended to serve as placeholders for BLOBs whose content is later written using &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt; routines. A negative value for the zeroblob results in a zero-length BLOB.</source>
          <target state="translated">sqlite3_bind_zeroblob（）例程绑定长度为N的BLOB，并用零填充。在处理过程中，zeroblob使用固定数量的内存（仅保留一个整数即可容纳其大小）。Zeroblob旨在用作BLOB的占位符，其内容随后使用&lt;a href=&quot;#sqlite3_blob_open&quot;&gt;增量BLOB I / O&lt;/a&gt;例程编写。零blob的负值将导致零长度BLOB。</target>
        </trans-unit>
        <trans-unit id="c43ef2df76e0304e4b4beb3c8e7c5dbefc82b96b" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_zeroblob() routine binds a BLOB of length N that is filled with zeroes. A zeroblob uses a fixed amount of memory (just an integer to hold its size) while it is being processed. Zeroblobs are intended to serve as placeholders for BLOBs whose content is later written using &lt;a href=&quot;blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt; routines. A negative value for the zeroblob results in a zero-length BLOB.</source>
          <target state="translated">sqlite3_bind_zeroblob（）例程绑定长度为N的BLOB，并用零填充。在处理过程中，zeroblob使用固定数量的内存（仅保留一个整数即可容纳其大小）。Zeroblob旨在用作BLOB的占位符，其内容随后使用&lt;a href=&quot;blob_open&quot;&gt;增量BLOB I / O&lt;/a&gt;例程编写。零blob的负值将导致零长度BLOB。</target>
        </trans-unit>
        <trans-unit id="3d2cce49ac08682bc109d88559efafcb5bc906c9" translate="yes" xml:space="preserve">
          <source>The sqlite3_busy_handler(D,X,P) routine sets a callback function X that might be invoked with argument P whenever an attempt is made to access a database table associated with &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D when another thread or process has the table locked. The sqlite3_busy_handler() interface is used to implement &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;.</source>
          <target state="translated">sqlite3_busy_handler（D，X，P）例程设置一个回调函数X，只要在另一个线程或进程将表锁定时尝试访问与&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 相关联的数据库表，都可以使用参数P调用该回调函数。sqlite3_busy_handler（）接口用于实现&lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d3363e5f93709d191e40f4d06f477acdab0e375e" translate="yes" xml:space="preserve">
          <source>The sqlite3_busy_handler(D,X,P) routine sets a callback function X that might be invoked with argument P whenever an attempt is made to access a database table associated with &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D when another thread or process has the table locked. The sqlite3_busy_handler() interface is used to implement &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; and &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;.</source>
          <target state="translated">sqlite3_busy_handler（D，X，P）例程设置一个回调函数X，只要在另一个线程或进程将表锁定时尝试访问与&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 相关联的数据库表，都可以使用参数P调用该回调函数。sqlite3_busy_handler（）接口用于实现&lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;和&lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8d93853c1f8ff5d06942fd5a08d82650ba96772" translate="yes" xml:space="preserve">
          <source>The sqlite3_close() and sqlite3_close_v2() routines are destructors for the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. Calls to sqlite3_close() and sqlite3_close_v2() return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is successfully destroyed and all associated resources are deallocated.</source>
          <target state="translated">sqlite3_close（）和sqlite3_close_v2（）例程是&lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象的析构函数。如果&lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象成功销毁并且所有关联资源都已释放，则对sqlite3_close（）和sqlite3_close_v2（）的调用返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c3b661e4a47ed928f3b7e88dd929f7831fe5385b" translate="yes" xml:space="preserve">
          <source>The sqlite3_close() and sqlite3_close_v2() routines are destructors for the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. Calls to sqlite3_close() and sqlite3_close_v2() return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is successfully destroyed and all associated resources are deallocated.</source>
          <target state="translated">sqlite3_close（）和sqlite3_close_v2（）例程是&lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象的析构函数。如果&lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt;对象成功销毁并且所有关联资源都已释放，则对sqlite3_close（）和sqlite3_close_v2（）的调用返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e35c3e04c8fe7269b95a0494cefdd5cde7acf02" translate="yes" xml:space="preserve">
          <source>The sqlite3_collation_needed() routine registers a callback which the database engine will invoke if it encounters an unknown collating sequence. The callback can lookup an appropriate comparison function and invoke sqlite_3_create_collation() as needed. The fourth parameter to the callback is the name of the collating sequence in UTF-8. For sqlite3_collation_need16() the callback sends the collating sequence name in UTF-16 host byte order.</source>
          <target state="translated">sqlite3_collation_needed()例程注册了一个回调,如果遇到未知的整理序列,数据库引擎会调用这个回调。该回调可以查找一个合适的比较函数,并根据需要调用sqlite_3_create_collation()。回调的第四个参数是整理序列的名称,用UTF-8表示。对于sqlite3_collation_need16(),回调会以UTF-16主机字节顺序发送整理序列名。</target>
        </trans-unit>
        <trans-unit id="289668a545984e8fa7c4b426fa20f850363028a3" translate="yes" xml:space="preserve">
          <source>The sqlite3_column_decltype() routine returns text which is the declared type of the column in the CREATE TABLE statement. For an expression, the return type is an empty string. sqlite3_column_name() returns the name of the Nth column. sqlite3_column_bytes() returns the number of bytes in a column that has type BLOB or the number of bytes in a TEXT string with UTF-8 encoding. sqlite3_column_bytes16() returns the same value for BLOBs but for TEXT strings returns the number of bytes in a UTF-16 encoding. sqlite3_column_blob() return BLOB data. sqlite3_column_text() return TEXT data as UTF-8. sqlite3_column_text16() return TEXT data as UTF-16. sqlite3_column_int() return INTEGER data in the host machines native integer format. sqlite3_column_int64() returns 64-bit INTEGER data. Finally, sqlite3_column_double() return floating point data.</source>
          <target state="translated">sqlite3_column_decltype()例程返回的文本是在CREATE TABLE语句中声明的列的类型。sqlite3_column_name()返回第N个列的名称。 sqlite3_column_bytes()返回BLOB类型的列的字节数或者UTF-8编码的TEXT字符串的字节数。 sqlite3_column_bytes16()对BLOB返回相同的值,但是对TEXT字符串返回UTF-16编码的字节数。sqlite3_column_blob()返回BLOB数据。 sqlite3_column_text()返回UTF-8格式的TEXT数据。 sqlite3_column_text16()返回UTF-16格式的TEXT数据。 sqlite3_column_int()返回主机本地整数格式的INTEGER数据。最后,sqlite3_column_double()返回浮点数据。</target>
        </trans-unit>
        <trans-unit id="a9b38d21f857b4d104b01ccf828564edcab9302b" translate="yes" xml:space="preserve">
          <source>The sqlite3_column_type() routine returns the &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype code&lt;/a&gt; for the initial data type of the result column. The returned value is one of &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL&lt;/a&gt;. The return value of sqlite3_column_type() can be used to decide which of the first six interface should be used to extract the column value. The value returned by sqlite3_column_type() is only meaningful if no automatic type conversions have occurred for the value in question. After a type conversion, the result of calling sqlite3_column_type() is undefined, though harmless. Future versions of SQLite may change the behavior of sqlite3_column_type() following a type conversion.</source>
          <target state="translated">sqlite3_column_type（）例程返回结果列的初始数据类型的&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;数据类型代码&lt;/a&gt;。返回的值是&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;，&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;，&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;，&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;或&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL之一&lt;/a&gt;。 sqlite3_column_type（）的返回值可用于确定应使用前六个接口中的哪个来提取列值。 sqlite3_column_type（）返回的值仅在没有针对该值进行自动类型转换的情况下才有意义。类型转换后，调用sqlite3_column_type（）的结果是不确定的，尽管无害。类型转换后，SQLite的未来版本可能会更改sqlite3_column_type（）的行为。</target>
        </trans-unit>
        <trans-unit id="d87c623fe2ec1f08f5218d69ec07d1b6f1fe406e" translate="yes" xml:space="preserve">
          <source>The sqlite3_column_type() routine returns the &lt;a href=&quot;c_blob&quot;&gt;datatype code&lt;/a&gt; for the initial data type of the result column. The returned value is one of &lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL&lt;/a&gt;. The return value of sqlite3_column_type() can be used to decide which of the first six interface should be used to extract the column value. The value returned by sqlite3_column_type() is only meaningful if no automatic type conversions have occurred for the value in question. After a type conversion, the result of calling sqlite3_column_type() is undefined, though harmless. Future versions of SQLite may change the behavior of sqlite3_column_type() following a type conversion.</source>
          <target state="translated">sqlite3_column_type（）例程返回结果列的初始数据类型的&lt;a href=&quot;c_blob&quot;&gt;数据类型代码&lt;/a&gt;。返回的值是&lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;，&lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;，&lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;，&lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;或&lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL之一&lt;/a&gt;。 sqlite3_column_type（）的返回值可用于确定应使用前六个接口中的哪个来提取列值。 sqlite3_column_type（）返回的值仅在没有针对该值进行自动类型转换的情况下才有意义。类型转换后，调用sqlite3_column_type（）的结果是不确定的，尽管无害。类型转换后，SQLite的未来版本可能会更改sqlite3_column_type（）的行为。</target>
        </trans-unit>
        <trans-unit id="80c9429e83e0f6600057106ffc072b05d6e8df14" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;../lang_transaction&quot;&gt;committed&lt;/a&gt;. Any callback set by a previous call to sqlite3_commit_hook() for the same database connection is overridden. The sqlite3_rollback_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;../lang_transaction&quot;&gt;rolled back&lt;/a&gt;. Any callback set by a previous call to sqlite3_rollback_hook() for the same database connection is overridden. The pArg argument is passed through to the callback. If the callback on a commit hook function returns non-zero, then the commit is converted into a rollback.</source>
          <target state="translated">sqlite3_commit_hook（）接口注册一个回调函数，只要&lt;a href=&quot;../lang_transaction&quot;&gt;提交&lt;/a&gt;事务即可调用该回调函数。先前调用sqlite3_commit_hook（）为同一数据库连接设置的任何回调都将被覆盖。 sqlite3_rollback_hook（）接口注册一个回调函数，每当事务&lt;a href=&quot;../lang_transaction&quot;&gt;回滚&lt;/a&gt;时，该回调函数就会被调用。先前调用sqlite3_rollback_hook（）为同一数据库连接设置的任何回调都将被覆盖。 pArg参数传递给回调。如果提交挂钩函数上的回调返回非零，则提交将转换为回滚。</target>
        </trans-unit>
        <trans-unit id="c831f98581f1e28276e947cc54e55e8093cff2bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;lang_transaction&quot;&gt;committed&lt;/a&gt;. Any callback set by a previous call to sqlite3_commit_hook() for the same database connection is overridden. The sqlite3_rollback_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;lang_transaction&quot;&gt;rolled back&lt;/a&gt;. Any callback set by a previous call to sqlite3_rollback_hook() for the same database connection is overridden. The pArg argument is passed through to the callback. If the callback on a commit hook function returns non-zero, then the commit is converted into a rollback.</source>
          <target state="translated">sqlite3_commit_hook（）接口注册一个回调函数，只要&lt;a href=&quot;lang_transaction&quot;&gt;提交&lt;/a&gt;事务即可调用该回调函数。先前调用sqlite3_commit_hook（）为同一数据库连接设置的任何回调都将被覆盖。 sqlite3_rollback_hook（）接口注册一个回调函数，每当事务&lt;a href=&quot;lang_transaction&quot;&gt;回滚&lt;/a&gt;时，该回调函数就会被调用。先前调用sqlite3_rollback_hook（）为同一数据库连接设置的任何回调都将被覆盖。 pArg参数传递给回调。如果提交挂钩函数上的回调返回非零，则提交将转换为回滚。</target>
        </trans-unit>
        <trans-unit id="8ed0ff1b29d3e198ebfc7c54c6d04128fb45e5b9" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook(D,C,P) and sqlite3_rollback_hook(D,C,P) functions return the P argument from the previous call of the same function on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call for each function on D.</source>
          <target state="translated">sqlite3_commit_hook（D，C，P）和sqlite3_rollback_hook（D，C，P）函数从相同&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上同一函数的上一次调用返回P参数，对于D上每个函数的首次调用返回NULL。</target>
        </trans-unit>
        <trans-unit id="5c814d040fa0b2376c6a44e987d8d06f8d405641" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook(D,C,P) and sqlite3_rollback_hook(D,C,P) functions return the P argument from the previous call of the same function on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call for each function on D.</source>
          <target state="translated">sqlite3_commit_hook（D，C，P）和sqlite3_rollback_hook（D，C，P）函数从相同&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上同一函数的上一次调用返回P参数，对于D上每个函数的首次调用返回NULL。</target>
        </trans-unit>
        <trans-unit id="a783ef29506da5187d0b6a8b529c5db8a199c982" translate="yes" xml:space="preserve">
          <source>The sqlite3_compileoption_get() function allows iterating over the list of options that were defined at compile time by returning the N-th compile time option string. If N is out of range, sqlite3_compileoption_get() returns a NULL pointer. The SQLITE_ prefix is omitted from any strings returned by sqlite3_compileoption_get().</source>
          <target state="translated">sqlite3_compileoption_get()函数允许通过返回第N个编译时的选项字符串来迭代编译时定义的选项列表。如果N超出了范围,sqlite3_compileoption_get()返回一个NULL指针。sqlite3_compileoption_get()返回的任何字符串都将省略SQLITE_前缀。</target>
        </trans-unit>
        <trans-unit id="39c27e864f7c32b9ceed46ceee3feba79ed9e6fc" translate="yes" xml:space="preserve">
          <source>The sqlite3_compileoption_used() function returns 0 or 1 indicating whether the specified option was defined at compile time. The SQLITE_ prefix may be omitted from the option name passed to sqlite3_compileoption_used().</source>
          <target state="translated">sqlite3_compileoption_used()函数返回0或1,表示指定的选项是否在编译时被定义。传递给sqlite3_compileoption_used()的选项名中可以省略SQLITE_前缀。</target>
        </trans-unit>
        <trans-unit id="c2f7b71d769d28cabe75800e2f0fc786a0e3ca05" translate="yes" xml:space="preserve">
          <source>The sqlite3_config() interface is used to make global configuration changes to SQLite in order to tune SQLite to the specific needs of the application. The default configuration is recommended for most applications and so this routine is usually not necessary. It is provided to support rare applications with unusual needs.</source>
          <target state="translated">sqlite3_config()接口用于对SQLite进行全局配置更改,以便根据应用程序的特定需求调整SQLite。对于大多数应用程序来说,默认配置是被推荐的,因此这个例程通常是不必要的。提供它是为了支持有特殊需求的罕见应用。</target>
        </trans-unit>
        <trans-unit id="2a43551c13014713b84ff3176d603e20a0bb2d0e" translate="yes" xml:space="preserve">
          <source>The sqlite3_config() interface may only be invoked prior to library initialization using &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; or after shutdown by &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. If sqlite3_config() is called after &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and before &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; then it will return SQLITE_MISUSE. Note, however, that sqlite3_config() can be called as part of the implementation of an application-defined &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_config（）接口只能在使用&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;初始化库之前或在通过&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;关闭后调用。如果sqlite3_config（）被称为后&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;和前&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown（） &lt;/a&gt;，然后将返回SQLITE_MISUSE。但是请注意，可以将sqlite3_config（）作为应用程序定义的&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_os_init（）&lt;/a&gt;的实现的一部分来调用。</target>
        </trans-unit>
        <trans-unit id="950f596cd61399b38213d68d8e3371f1294cd97c" translate="yes" xml:space="preserve">
          <source>The sqlite3_config() interface may only be invoked prior to library initialization using &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; or after shutdown by &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. If sqlite3_config() is called after &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and before &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; then it will return SQLITE_MISUSE. Note, however, that sqlite3_config() can be called as part of the implementation of an application-defined &lt;a href=&quot;initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_config（）接口只能在使用&lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;初始化库之前或在通过&lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;关闭后调用。如果sqlite3_config（）被称为后&lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;和前&lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown（） &lt;/a&gt;，然后将返回SQLITE_MISUSE。但是请注意，可以将sqlite3_config（）作为应用程序定义的&lt;a href=&quot;initialize&quot;&gt;sqlite3_os_init（）&lt;/a&gt;的实现的一部分来调用。</target>
        </trans-unit>
        <trans-unit id="f36e7397009cd60c7259be5a8cbdeb80264ff811" translate="yes" xml:space="preserve">
          <source>The sqlite3_context_db_handle() interface returns a copy of the pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; (the 1st parameter) of the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_context_db_handle（）接口返回指向最初注册了应用程序定义函数的&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;例程的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;（第一个参数）的指针的副本。</target>
        </trans-unit>
        <trans-unit id="04b3afa93b5033ef2c02acd3a1ef18374b3a066e" translate="yes" xml:space="preserve">
          <source>The sqlite3_context_db_handle() interface returns a copy of the pointer to the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; (the 1st parameter) of the &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_context_db_handle（）接口返回指向最初注册了应用程序定义函数的&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;和&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;例程的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;（第一个参数）的指针的副本。</target>
        </trans-unit>
        <trans-unit id="0b0f49ec423453d8567eeff6ab2f843591a04245" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation() function honors the SQLITE_UTF16_ALIGNED flag.</source>
          <target state="translated">sqlite3_create_collation()函数尊重SQLITE_UTF16_ALIGNED标志。</target>
        </trans-unit>
        <trans-unit id="0e46987511170cbb4e8e90d14cfd9fe052087146" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation() function specifies a collating sequence name and a comparison function to implement that collating sequence. The comparison function is only used for comparing text values. The eTextRep parameter is one of SQLITE_UTF8, SQLITE_UTF16LE, SQLITE_UTF16BE, or SQLITE_ANY to specify which text representation the comparison function works with. Separate comparison functions can exist for the same collating sequence for each of the UTF-8, UTF-16LE and UTF-16BE text representations. The sqlite3_create_collation16() works like sqlite3_create_collation() except that the collation name is specified in UTF-16 host byte order instead of in UTF-8.</source>
          <target state="translated">sqlite3_create_collation()函数指定了一个整理序列名和一个比较函数来实现该整理序列。比较函数只用于比较文本值。eTextRep参数是SQLITE_UTF8、SQLITE_UTF16LE、SQLITE_UTF16BE或SQLITE_ANY中的一个,用于指定比较函数工作的文本表示方式。对于UTF-8、UTF-16LE和UTF-16BE三种文本表示,同一整理序列可以存在单独的比较函数。sqlite3_create_collation16()的工作原理和 sqlite3_create_collation()一样,只是整理名称是以 UTF-16 主机字节顺序而不是 UTF-8 来指定的。</target>
        </trans-unit>
        <trans-unit id="3bb1bc030c0ecaf171e6e7837d4fc5ad509b9304" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation_v2() works like sqlite3_create_collation() with the addition that the xDestroy callback is invoked on pArg when the collating function is deleted. Collating functions are deleted when they are overridden by later calls to the collation creation functions or when the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is closed using &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_create_collat​​ion_v2（）的工作方式与sqlite3_create_collat​​ion（）相似，此外，删除整理功能后，在pArg上调用了xDestroy回调。当整理函数被以后对整理创建函数的调用所覆盖，或者使用&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close（）&lt;/a&gt;关闭&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;时，整理函数将被删除。</target>
        </trans-unit>
        <trans-unit id="cce8a06023084f98541458166466b478b68c97fc" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation_v2() works like sqlite3_create_collation() with the addition that the xDestroy callback is invoked on pArg when the collating function is deleted. Collating functions are deleted when they are overridden by later calls to the collation creation functions or when the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is closed using &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_create_collat​​ion_v2（）的工作方式与sqlite3_create_collat​​ion（）相似，此外，删除整理功能后，在pArg上调用了xDestroy回调。当整理函数被以后对整理创建函数的调用所覆盖，或者使用&lt;a href=&quot;close&quot;&gt;sqlite3_close（）&lt;/a&gt;关闭&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;时，整理函数将被删除。</target>
        </trans-unit>
        <trans-unit id="35eaa1fdb7403d0bf2c872e0985b90cb08324f23" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_filename(D,J,W,N,P) allocates memory to hold a version of database filename D with corresponding journal file J and WAL file W and with N URI parameters key/values pairs in the array P. The result from sqlite3_create_filename(D,J,W,N,P) is a pointer to a database filename that is safe to pass to routines like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2321a78d45e7f791f5be9bd5eeeecdd73b61cbff" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_module_v2() interface has a fifth parameter which is a pointer to a destructor for the pClientData. SQLite will invoke the destructor function (if it is not NULL) when SQLite no longer needs the pClientData pointer. The destructor will also be invoked if the call to sqlite3_create_module_v2() fails. The sqlite3_create_module() interface is equivalent to sqlite3_create_module_v2() with a NULL destructor.</source>
          <target state="translated">sqlite3_create_module_v2()接口有第五个参数,它是指向pClientData的析构器的指针,当SQLite不再需要pClientData指针时,SQLite会调用析构器函数(如果不是NULL)。当SQLite不再需要pClientData指针时,SQLite将调用destructor函数(如果它不是NULL)。如果调用 sqlite3_create_module_v2()失败,destructor 也会被调用。sqlite3_create_module()接口相当于sqlite3_create_module_v2()的NULL析构器。</target>
        </trans-unit>
        <trans-unit id="ce43917c89192dc7d4a31aeaa86afac14bcedebc" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; family of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23578428cca6b0b7cc9f351266849d54d3f4ac7" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_*()&lt;/a&gt; of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="translated">sqlite3_data_count（P）接口返回已&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt; P 结果集中当前行中的列数。如果已准备好的语句P没有准备好返回结果（通过调用接口的&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column _ *（）&lt;/a&gt;），则sqlite3_data_count（ P）返回0。如果P是NULL指针，则sqlite3_data_count（P）例程也返回0。如果先前对&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;（P）的调用返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;，则sqlite3_data_count（P）例程返回0 。如果先前对&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;（P）的调用返回了&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;，则sqlite3_data_count（P）将返回非零值，但&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA增量式&lt;/a&gt;真空的情况除外由于该多步骤编译指示的每一步都会返回0列数据，因此该位置始终返回零。</target>
        </trans-unit>
        <trans-unit id="f5791b68b76b19a4a15dafbc0a31b6f189b8fc89" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; family of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0331c5159620074031eabe2d2fffeb3879925815" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_*()&lt;/a&gt; of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="translated">sqlite3_data_count（P）接口返回已&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt; P 结果集中当前行中的列数。如果已准备好的语句P没有准备好返回结果（通过调用接口的&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column _ *（）&lt;/a&gt;），则sqlite3_data_count（ P）返回0。如果P是NULL指针，则sqlite3_data_count（P）例程也返回0。如果先前对&lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;（P）的调用返回&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;，则sqlite3_data_count（P）例程返回0 。如果先前对&lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;（P）的调用返回了&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;，则sqlite3_data_count（P）将返回非零值，但&lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA增量式&lt;/a&gt;真空的情况除外由于该多步骤编译指示的每一步都会返回0列数据，因此该位置始终返回零。</target>
        </trans-unit>
        <trans-unit id="043836a9d52018cfd95036ef1de8601c0dd65b27" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_config() interface is used to make configuration changes to a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. The interface is similar to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; except that the changes apply to a single &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; (specified in the first argument).</source>
          <target state="translated">sqlite3_db_config（）接口用于对&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;进行配置更改。该接口与&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;相似，不同之处在于更改适用于单个&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;（在第一个参数中指定）。</target>
        </trans-unit>
        <trans-unit id="cb382b8043f6bd41fb4e955562ae2dd8de8821a6" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_config() interface is used to make configuration changes to a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. The interface is similar to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; except that the changes apply to a single &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; (specified in the first argument).</source>
          <target state="translated">sqlite3_db_config（）接口用于对&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;进行配置更改。该接口与&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;相似，不同之处在于更改适用于单个&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;（在第一个参数中指定）。</target>
        </trans-unit>
        <trans-unit id="d9890e9099b39efa9f23ed1209f98fc2abd695d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_filename(D,N) interface returns a pointer to a filename associated with database N of connection D. The main database file has the name &quot;main&quot;. If there is no attached database N on the database connection D, or if database N is a temporary or in-memory database, then this function will return either a NULL pointer or an empty string.</source>
          <target state="translated">sqlite3_db_filename(D,N)接口返回一个指向连接D的数据库N相关联的文件名的指针,主数据库文件的名称为 &quot;main&quot;。如果数据库连接D上没有关联的数据库N,或者数据库N是一个临时的或者内存中的数据库,那么这个函数将返回一个NULL指针或者一个空字符串。</target>
        </trans-unit>
        <trans-unit id="6ce559d2134cd8f80b32424d9cafa088f3f1de6d" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_filename(D,N) interface returns a pointer to the filename associated with database N of connection D. If there is no attached database N on the database connection D, or if database N is a temporary or in-memory database, then this function will return either a NULL pointer or an empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a0142f7765d452e556a6d1ade538189bbf023a1" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_handle interface returns the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; handle to which a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; belongs. The &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; returned by sqlite3_db_handle is the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that was the first argument to the &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; call (or its variants) that was used to create the statement in the first place.</source>
          <target state="translated">sqlite3_db_handle接口返回已&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;所属的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;句柄。该&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;通过sqlite3_db_handle返回相同&lt;a href=&quot;#sqlite3&quot;&gt;的数据库连接&lt;/a&gt;，这是第一个参数到&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;是用于创建摆在首位的语句调用（或其变体）。</target>
        </trans-unit>
        <trans-unit id="0ed4944069eec7d7c0e7904b6909ffc71d6a37af" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_handle interface returns the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; handle to which a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; belongs. The &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; returned by sqlite3_db_handle is the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that was the first argument to the &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; call (or its variants) that was used to create the statement in the first place.</source>
          <target state="translated">sqlite3_db_handle接口返回已&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;所属的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;句柄。该&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;通过sqlite3_db_handle返回相同&lt;a href=&quot;sqlite3&quot;&gt;的数据库连接&lt;/a&gt;，这是第一个参数到&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;是用于创建摆在首位的语句调用（或其变体）。</target>
        </trans-unit>
        <trans-unit id="f13e3d008759351c9d014a67b0c7d66c909c38ed" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_readonly(D,N) interface returns 1 if the database N of connection D is read-only, 0 if it is read/write, or -1 if N is not the name of a database on connection D.</source>
          <target state="translated">sqlite3_db_readonly(D,N)接口如果连接D的数据库N是只读,则返回1,如果是读/写,则返回0,如果N不是连接D上的数据库名称,则返回-1。</target>
        </trans-unit>
        <trans-unit id="7c54e0312a49676acc8e0fa5a98fa6c3ca389049" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_release_memory(D) interface attempts to free as much heap memory as possible from database connection D. Unlike the &lt;a href=&quot;#sqlite3_release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface, this interface is in effect even when the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is omitted.</source>
          <target state="translated">sqlite3_db_release_memory（D）接口尝试从数据库连接D释放尽可能多的堆内存。与&lt;a href=&quot;#sqlite3_release_memory&quot;&gt;sqlite3_release_memory（）&lt;/a&gt;接口不同，即使忽略了&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;编译时选项，此接口也有效。</target>
        </trans-unit>
        <trans-unit id="a4505b330dae36966abd878a7a5251bb10a809a6" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_release_memory(D) interface attempts to free as much heap memory as possible from database connection D. Unlike the &lt;a href=&quot;release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface, this interface is in effect even when the &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is omitted.</source>
          <target state="translated">sqlite3_db_release_memory（D）接口尝试从数据库连接D释放尽可能多的堆内存。与&lt;a href=&quot;release_memory&quot;&gt;sqlite3_release_memory（）&lt;/a&gt;接口不同，即使忽略了&lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;编译时选项，此接口也有效。</target>
        </trans-unit>
        <trans-unit id="83634ce6a2d174966fca0f07d2eb6e5e52439e9f" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_status() routine returns SQLITE_OK on success and a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_db_status（）例程在成功时返回SQLITE_OK，在失败时返回非零&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7babdc84886f95b16b07a064461180aa8e231247" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_status() routine returns SQLITE_OK on success and a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_db_status（）例程在成功时返回SQLITE_OK，在失败时返回非零&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18d47ae58f8b29dbac7701bb014dc19e22eadf62" translate="yes" xml:space="preserve">
          <source>The sqlite3_deserialize() interface will fail with SQLITE_BUSY if the database is currently in a read transaction or is involved in a backup operation.</source>
          <target state="translated">如果数据库当前处于读取事务中或者参与了备份操作,那么sqlite3_deserialize()接口将以SQLITE_BUSY失败。</target>
        </trans-unit>
        <trans-unit id="12340c8333dc6a82eca44a1f4c8bbf0434fac375" translate="yes" xml:space="preserve">
          <source>The sqlite3_deserialize(D,S,P,N,M,F) interface causes the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D to disconnect from database S and then reopen S as an in-memory database based on the serialization contained in P. The serialized database P is N bytes in size. M is the size of the buffer P, which might be larger than N. If M is larger than N, and the SQLITE_DESERIALIZE_READONLY bit is not set in F, then SQLite is permitted to add content to the in-memory database as long as the total size does not exceed M bytes.</source>
          <target state="translated">sqlite3_deserialize（D，S，P，N，M，F）接口使&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D与数据库S断开连接，然后根据P中包含的序列化将S作为内存数据库重新打开。序列化的数据库P为N字节大小。M是缓冲区P的大小，它可能大于N。如果M大于N，并且F中未设置SQLITE_DESERIALIZE_READONLY位，则只要允许SQLite向内存数据库添加内容，就可以总大小不超过M个字节。</target>
        </trans-unit>
        <trans-unit id="afac5ec67e0561a540471ae51b94788f3734ed79" translate="yes" xml:space="preserve">
          <source>The sqlite3_deserialize(D,S,P,N,M,F) interface causes the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D to disconnect from database S and then reopen S as an in-memory database based on the serialization contained in P. The serialized database P is N bytes in size. M is the size of the buffer P, which might be larger than N. If M is larger than N, and the SQLITE_DESERIALIZE_READONLY bit is not set in F, then SQLite is permitted to add content to the in-memory database as long as the total size does not exceed M bytes.</source>
          <target state="translated">sqlite3_deserialize（D，S，P，N，M，F）接口使&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D与数据库S断开连接，然后根据P中包含的序列化将S作为内存数据库重新打开。序列化的数据库P为N字节大小。M是缓冲区P的大小，它可能大于N。如果M大于N，并且F中未设置SQLITE_DESERIALIZE_READONLY位，则只要允许SQLite向内存数据库添加内容，就可以总大小不超过M个字节。</target>
        </trans-unit>
        <trans-unit id="6ae05681a8b59259daa468a1d8590729337a135a" translate="yes" xml:space="preserve">
          <source>The sqlite3_drop_modules(D,L) interface removes all virtual table modules from database connection D except those named on list L. The L parameter must be either NULL or a pointer to an array of pointers to strings where the array is terminated by a single NULL pointer. If the L parameter is NULL, then all virtual table modules are removed.</source>
          <target state="translated">sqlite3_drop_modules(D,L)接口从数据库连接D中删除所有虚拟表模块,列表L中命名的模块除外。L参数必须是NULL或指向字符串指针数组的指针,其中数组以单个NULL指针结束。如果L参数为NULL,则删除所有虚拟表模块。</target>
        </trans-unit>
        <trans-unit id="cb17fe8b042f1bd6f76a39ed23dd1524edfc2345" translate="yes" xml:space="preserve">
          <source>The sqlite3_errcode() routine returns a result code for the most recent major API call. sqlite3_errmsg() returns an English-language text error message for the most recent error. The error message is represented in UTF-8 and will be ephemeral - it could disappear on the next call to any SQLite API function. sqlite3_errmsg16() works like sqlite3_errmsg() except that it returns the error message represented as UTF-16 in host native byte order.</source>
          <target state="translated">sqlite3_errcode()例程返回最近一次主要API调用的结果代码。 sqlite3_errmsg()返回最近一次错误的英文文本错误信息。sqlite3_errmsg16()的工作原理和sqlite3_errmsg()一样,只是它以主机本地字节顺序返回UTF-16表示的错误信息。</target>
        </trans-unit>
        <trans-unit id="5e0d9cf7c1277961ee0db98705525eacc5bb425f" translate="yes" xml:space="preserve">
          <source>The sqlite3_errmsg() and sqlite3_errmsg16() return English-language text that describes the error, as either UTF-8 or UTF-16 respectively. Memory to hold the error message string is managed internally. The application does not need to worry about freeing the result. However, the error string might be overwritten or deallocated by subsequent calls to other SQLite interface functions.</source>
          <target state="translated">sqlite3_errmsg()和sqlite3_errmsg16()分别以UTF-8或UTF-16的形式返回描述错误的英文文本。用于保存错误信息字符串的内存由内部管理。应用程序不需要担心释放结果。但是,错误字符串可能会被后续对其他SQLite接口函数的调用覆盖或重新分配。</target>
        </trans-unit>
        <trans-unit id="a3b2d05546afbeecb20b8fe87e3f3189bfedb642" translate="yes" xml:space="preserve">
          <source>The sqlite3_errstr() interface returns the English-language text that describes the &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt;, as UTF-8. Memory to hold the error message string is managed internally and must not be freed by the application.</source>
          <target state="translated">sqlite3_errstr（）接口以UTF-8 返回描述&lt;a href=&quot;../rescode&quot;&gt;结果代码&lt;/a&gt;的英语文本。包含错误消息字符串的内存是在内部进行管理的，应用程序不得释放该内存。</target>
        </trans-unit>
        <trans-unit id="3185f0fefecbff2d0db8b69bac9298083b70809e" translate="yes" xml:space="preserve">
          <source>The sqlite3_errstr() interface returns the English-language text that describes the &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt;, as UTF-8. Memory to hold the error message string is managed internally and must not be freed by the application.</source>
          <target state="translated">sqlite3_errstr（）接口以UTF-8 返回描述&lt;a href=&quot;rescode&quot;&gt;结果代码&lt;/a&gt;的英语文本。包含错误消息字符串的内存是在内部进行管理的，应用程序不得释放该内存。</target>
        </trans-unit>
        <trans-unit id="eec19de3d00e4cd6319cb02ddf72d5b612e30300" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface is a convenience wrapper around &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;, that allows an application to run multiple statements of SQL without having to use a lot of C code.</source>
          <target state="translated">sqlite3_exec（）接口是&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;的便捷包装，它允许应用程序运行多个SQL语句而无需使用大量C代码。</target>
        </trans-unit>
        <trans-unit id="9a4e88bd32574fff7b2361feb6cf37710d7194a2" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface is a convenience wrapper around &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;, and &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;, that allows an application to run multiple statements of SQL without having to use a lot of C code.</source>
          <target state="translated">sqlite3_exec（）接口是&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;，&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;和&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;的便捷包装，它允许应用程序运行多个SQL语句而无需使用大量C代码。</target>
        </trans-unit>
        <trans-unit id="5f6ecb5327784e2b3ab3076a060e42400e8e6e49" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface runs zero or more UTF-8 encoded, semicolon-separate SQL statements passed into its 2nd argument, in the context of the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; passed in as its 1st argument. If the callback function of the 3rd argument to sqlite3_exec() is not NULL, then it is invoked for each result row coming out of the evaluated SQL statements. The 4th argument to sqlite3_exec() is relayed through to the 1st argument of each callback invocation. If the callback pointer to sqlite3_exec() is NULL, then no callback is ever invoked and result rows are ignored.</source>
          <target state="translated">sqlite3_exec（）接口在作为第一个参数传入的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;的上下文中，运行零个或多个以UTF-8编码，以分号分隔的SQL语句，并将其传递给第二个参数。如果sqlite3_exec（）的第3个参数的回调函数不为NULL，则将对从评估的SQL语句中出来的每个结果行调用该函数。sqlite3_exec（）的第4个参数将中继到每个回调调用的第一个参数。如果指向sqlite3_exec（）的回调指针为NULL，则不会调用任何回调，并且将忽略结果行。</target>
        </trans-unit>
        <trans-unit id="7f2bf987e70ab4f6565417a4f7295b79e8706b9e" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface runs zero or more UTF-8 encoded, semicolon-separate SQL statements passed into its 2nd argument, in the context of the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; passed in as its 1st argument. If the callback function of the 3rd argument to sqlite3_exec() is not NULL, then it is invoked for each result row coming out of the evaluated SQL statements. The 4th argument to sqlite3_exec() is relayed through to the 1st argument of each callback invocation. If the callback pointer to sqlite3_exec() is NULL, then no callback is ever invoked and result rows are ignored.</source>
          <target state="translated">sqlite3_exec（）接口在作为第一个参数传入的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;的上下文中，运行零个或多个以UTF-8编码，以分号分隔的SQL语句，并将其传递给第二个参数。如果sqlite3_exec（）的第3个参数的回调函数不为NULL，则将对从评估的SQL语句中出来的每个结果行调用该函数。sqlite3_exec（）的第4个参数将中继到每个回调调用的第一个参数。如果指向sqlite3_exec（）的回调指针为NULL，则不会调用任何回调，并且将忽略结果行。</target>
        </trans-unit>
        <trans-unit id="fdc80de144729ab29ec768dc45f521935b24167a" translate="yes" xml:space="preserve">
          <source>The sqlite3_expanded_sql() interface returns NULL if insufficient memory is available to hold the result, or if the result would exceed the the maximum string length determined by the &lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;.</source>
          <target state="translated">如果没有足够的内存来保存结果，或者如果结果将超过&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;确定的最大字符串长度，则sqlite3_expanded_sql（）接口返回NULL 。</target>
        </trans-unit>
        <trans-unit id="253eafa1da6e36def799917e15566e8c664899fe" translate="yes" xml:space="preserve">
          <source>The sqlite3_expanded_sql() interface returns NULL if insufficient memory is available to hold the result, or if the result would exceed the the maximum string length determined by the &lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;.</source>
          <target state="translated">如果没有足够的内存来保存结果，或者如果结果将超过&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;确定的最大字符串长度，则sqlite3_expanded_sql（）接口返回NULL 。</target>
        </trans-unit>
        <trans-unit id="1d1fd4c0ad3995d89a0ef41f1f46affc2269eba4" translate="yes" xml:space="preserve">
          <source>The sqlite3_extended_result_codes() routine enables or disables the &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; feature of SQLite. The extended result codes are disabled by default for historical compatibility.</source>
          <target state="translated">sqlite3_extended_result_codes（）例程启用或禁用SQLite 的&lt;a href=&quot;../rescode#extrc&quot;&gt;扩展结果代码&lt;/a&gt;功能。默认情况下，扩展结果代码是禁用的，以实现历史兼容性。</target>
        </trans-unit>
        <trans-unit id="904ab00e0ae19fa09117889888e1162471d32017" translate="yes" xml:space="preserve">
          <source>The sqlite3_extended_result_codes() routine enables or disables the &lt;a href=&quot;rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; feature of SQLite. The extended result codes are disabled by default for historical compatibility.</source>
          <target state="translated">sqlite3_extended_result_codes（）例程启用或禁用SQLite 的&lt;a href=&quot;rescode#extrc&quot;&gt;扩展结果代码&lt;/a&gt;功能。默认情况下，扩展结果代码是禁用的，以实现历史兼容性。</target>
        </trans-unit>
        <trans-unit id="5daeea1eac71cd621bf8b80af259a724f2e831b8" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize() function is called to delete a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. If the most recent evaluation of the statement encountered no errors or if the statement is never been evaluated, then sqlite3_finalize() returns SQLITE_OK. If the most recent evaluation of statement S failed, then sqlite3_finalize(S) returns the appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt;.</source>
          <target state="translated">调用sqlite3_finalize（）函数以删除&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;。如果对语句的最新评估没有遇到错误，或者从未对语句进行评估，则sqlite3_finalize（）返回SQLITE_OK。如果对语句S的最新评估失败，则sqlite3_finalize（S）返回适当的&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;或&lt;a href=&quot;rescode#extrc&quot;&gt;扩展错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="74837217c620c1e41ee1e321a9ad17968e0d6486" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize() function is called to delete a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. If the most recent evaluation of the statement encountered no errors or if the statement is never been evaluated, then sqlite3_finalize() returns SQLITE_OK. If the most recent evaluation of statement S failed, then sqlite3_finalize(S) returns the appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt;.</source>
          <target state="translated">调用sqlite3_finalize（）函数以删除&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;。如果对语句的最新评估没有遇到错误，或者从未对语句进行评估，则sqlite3_finalize（）返回SQLITE_OK。如果对语句S的最新评估失败，则sqlite3_finalize（S）返回适当的&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;或&lt;a href=&quot;../rescode#extrc&quot;&gt;扩展错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cfdc64000a1f68dd938d60f9bb70e02c947748fd" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize(S) routine can be called at any point during the life cycle of &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S: before statement S is ever evaluated, after one or more calls to &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, or after any call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; regardless of whether or not the statement has completed execution.</source>
          <target state="translated">sqlite3_finalize（S）例程可以在已&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt; S 的生命周期中的任何时间调用：在评估语句 S之前，一次或多次调用&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;之后或在调用&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）之后，&lt;/a&gt;无论是否或语句尚未完成执行。</target>
        </trans-unit>
        <trans-unit id="1dec5478469a2333006cfdfd3bbed8c6613161e2" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize(S) routine can be called at any point during the life cycle of &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S: before statement S is ever evaluated, after one or more calls to &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, or after any call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; regardless of whether or not the statement has completed execution.</source>
          <target state="translated">sqlite3_finalize（S）例程可以在已&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt; S 的生命周期中的任何时间调用：在评估语句 S之前，一次或多次调用&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;之后或在调用&lt;a href=&quot;step&quot;&gt;sqlite3_step（）之后，&lt;/a&gt;无论是否或语句尚未完成执行。</target>
        </trans-unit>
        <trans-unit id="408796a34b26a6721118a4ab1b7c1f9baef90909" translate="yes" xml:space="preserve">
          <source>The sqlite3_free_filename(Y) routine releases a memory allocation previously obtained from sqlite3_create_filename(). Invoking sqlite3_free_filename(Y) where Y is a NULL pointer is a harmless no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a8a4dfedb4d5de550dae28093210eb5e1165c50" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_autocommit() interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively. Autocommit mode is on by default. Autocommit mode is disabled by a &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt; statement. Autocommit mode is re-enabled by a &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; or &lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;.</source>
          <target state="translated">如果给定的数据库连接分别处于或不处于自动提交模式，则sqlite3_get_autocommit（）接口分别返回非零或零。默认情况下，自动提交模式是打开的。自动提交模式被&lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt;语句禁用。自动提交模式由&lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt;或&lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;重新启用。</target>
        </trans-unit>
        <trans-unit id="c6407bbe024eecae19905f3987328770ebef955e" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_autocommit() interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively. Autocommit mode is on by default. Autocommit mode is disabled by a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; statement. Autocommit mode is re-enabled by a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; or &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;.</source>
          <target state="translated">如果给定的数据库连接分别处于或不处于自动提交模式，则sqlite3_get_autocommit（）接口分别返回非零或零。默认情况下，自动提交模式是打开的。自动提交模式被&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;语句禁用。自动提交模式由&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;或&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;重新启用。</target>
        </trans-unit>
        <trans-unit id="c54753db8fb054877250927a699aaaed04734d2b" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_auxdata(C,N) interface returns a pointer to the metadata associated by the sqlite3_set_auxdata(C,N,P,X) function with the Nth argument value to the application-defined function. N is zero for the left-most function argument. If there is no metadata associated with the function argument, the sqlite3_get_auxdata(C,N) interface returns a NULL pointer.</source>
          <target state="translated">sqlite3_get_auxdata(C,N)接口返回一个指针,指向sqlite3_set_auxdata(C,N,P,X)函数与应用定义函数的第N个参数值关联的元数据。对于最左边的函数参数,N为零。如果没有与函数参数相关联的元数据,sqlite3_get_auxdata(C,N)接口返回一个NULL指针。</target>
        </trans-unit>
        <trans-unit id="35597daf57a6a6a4650eb220c2a29fa2c91a59d0" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_table() function evaluates one or more semicolon-separated SQL statements in the zero-terminated UTF-8 string of its 2nd parameter and returns a result table to the pointer given in its 3rd parameter.</source>
          <target state="translated">sqlite3_get_table()函数对其第2个参数中的一个或多个以分号分隔的UTF-8字符串的SQL语句进行评估,并向其第3个参数中给出的指针返回一个结果表。</target>
        </trans-unit>
        <trans-unit id="acdf7ebaf34cc7cf8bdf020e8dc45c52df0d628c" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_table() interface is implemented as a wrapper around &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;. The sqlite3_get_table() routine does not have access to any internal data structures of SQLite. It uses only the public interface defined here. As a consequence, errors that occur in the wrapper layer outside of the internal &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt; call are not reflected in subsequent calls to &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_get_table（）接口被实现为&lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;的包装。 sqlite3_get_table（）例程无法访问SQLite的任何内部数据结构。它仅使用此处定义的公共接口。结果，内部&lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;调用外部的包装层中发生的错误不会反映在后续对&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）的&lt;/a&gt;调用中。</target>
        </trans-unit>
        <trans-unit id="566ec671a5bf78f09b92642b451438dd26c86350" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_table() interface is implemented as a wrapper around &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;. The sqlite3_get_table() routine does not have access to any internal data structures of SQLite. It uses only the public interface defined here. As a consequence, errors that occur in the wrapper layer outside of the internal &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt; call are not reflected in subsequent calls to &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_get_table（）接口被实现为&lt;a href=&quot;exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;的包装。 sqlite3_get_table（）例程无法访问SQLite的任何内部数据结构。它仅使用此处定义的公共接口。结果，内部&lt;a href=&quot;exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;调用外部的包装层中发生的错误不会反映在后续对&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;或&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）的&lt;/a&gt;调用中。</target>
        </trans-unit>
        <trans-unit id="b9b992cc0be7235d15c4a18cbb125e283656622e" translate="yes" xml:space="preserve">
          <source>The sqlite3_hard_heap_limit64(N) interface sets a hard upper bound of N bytes on the amount of memory that will be allocated. The sqlite3_hard_heap_limit64(N) interface is similar to sqlite3_soft_heap_limit64(N) except that memory allocations will fail when the hard heap limit is reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1053b2bb267ced2e3415b8b71b02dc7bb0d976" translate="yes" xml:space="preserve">
          <source>The sqlite3_index_info structure and its substructures is used as part of the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; interface to pass information into and receive the reply from the &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt;. The fields under **Inputs** are the inputs to xBestIndex and are read-only. xBestIndex inserts its results into the **Outputs** fields.</source>
          <target state="translated">sqlite3_index_info结构及其子结构用作&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;接口的一部分，以将信息传递到&lt;a href=&quot;module&quot;&gt;虚拟表模块&lt;/a&gt;的&lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;方法并从中接收答复。**输入**下的字段是xBestIndex的输入，并且是只读的。xBestIndex将其结果插入到&amp;ldquo;输出&amp;rdquo;字段中。</target>
        </trans-unit>
        <trans-unit id="779db7516101e2733ab83d988869d6422e837e26" translate="yes" xml:space="preserve">
          <source>The sqlite3_index_info structure and its substructures is used as part of the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; interface to pass information into and receive the reply from the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt;. The fields under **Inputs** are the inputs to xBestIndex and are read-only. xBestIndex inserts its results into the **Outputs** fields.</source>
          <target state="translated">sqlite3_index_info结构及其子结构用作&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;接口的一部分，以将信息传递到&lt;a href=&quot;#sqlite3_module&quot;&gt;虚拟表模块&lt;/a&gt;的&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;方法并从中接收答复。**输入**下的字段是xBestIndex的输入，并且是只读的。xBestIndex将其结果插入到&amp;ldquo;输出&amp;rdquo;字段中。</target>
        </trans-unit>
        <trans-unit id="f7b3a693ac538b125172c62d75cc7d377f31b955" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() interface is threadsafe, but sqlite3_shutdown() is not. The sqlite3_shutdown() interface must only be called from a single thread. All open &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; must be closed and all other SQLite resources must be deallocated prior to invoking sqlite3_shutdown().</source>
          <target state="translated">sqlite3_initialize（）接口是线程安全的，但sqlite3_shutdown（）不是。sqlite3_shutdown（）接口只能从单个线程中调用。在调用sqlite3_shutdown（）之前，必须关闭所有打开的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接，&lt;/a&gt;并且必须释放所有其他SQLite资源。</target>
        </trans-unit>
        <trans-unit id="88e442978d61726b76c4c6bd7b1f8a87808c119b" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() interface is threadsafe, but sqlite3_shutdown() is not. The sqlite3_shutdown() interface must only be called from a single thread. All open &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; must be closed and all other SQLite resources must be deallocated prior to invoking sqlite3_shutdown().</source>
          <target state="translated">sqlite3_initialize（）接口是线程安全的，但sqlite3_shutdown（）不是。sqlite3_shutdown（）接口只能从单个线程中调用。在调用sqlite3_shutdown（）之前，必须关闭所有打开的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接，&lt;/a&gt;并且必须释放所有其他SQLite资源。</target>
        </trans-unit>
        <trans-unit id="0e2957684efb0782443d87103a368a9305c21dfe" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine initializes the SQLite library. The sqlite3_shutdown() routine deallocates any resources that were allocated by sqlite3_initialize(). These routines are designed to aid in process initialization and shutdown on embedded systems. Workstation applications using SQLite normally do not need to invoke either of these routines.</source>
          <target state="translated">sqlite3_initialize()例程初始化SQLite库。sqlite3_shutdown()例程会重新分配由 sqlite3_initialize()分配的资源。这些例程被设计用来帮助嵌入式系统的进程初始化和关闭。使用SQLite的工作站应用程序通常不需要调用这两个例程。</target>
        </trans-unit>
        <trans-unit id="6344d658101e62a854952f62047632e568cb77e6" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine is called internally by many other SQLite interfaces so that an application usually does not need to invoke sqlite3_initialize() directly. For example, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt; calls sqlite3_initialize() so the SQLite library will be automatically initialized when &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt; is called if it has not be initialized already. However, if SQLite is compiled with the &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; compile-time option, then the automatic calls to sqlite3_initialize() are omitted and the application must call sqlite3_initialize() directly prior to using any other SQLite interface. For maximum portability, it is recommended that applications always invoke sqlite3_initialize() directly prior to using any other SQLite interface. Future releases of SQLite may require this. In other words, the behavior exhibited when SQLite is compiled with &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; might become the default behavior in some future release of SQLite.</source>
          <target state="translated">sqlite3_initialize（）例程由许多其他SQLite接口在内部调用，因此应用程序通常不需要直接调用sqlite3_initialize（）。例如，&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;调用sqlite3_initialize（），所以SQLite库时将被自动初始化&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;被调用，如果它没有被已经初始化。但是，如果使用&lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;编译SQLite使用compile-time选项，则将省略对sqlite3_initialize（）的自动调用，并且应用程序必须在使用任何其他SQLite接口之前直接调用sqlite3_initialize（）。为了获得最大的可移植性，建议应用程序始终始终在使用任何其他SQLite接口之前直接调用sqlite3_initialize（）。 SQLite的未来版本可能会要求这样做。换句话说，在将来的SQLite发行版中，使用&lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;编译SQLite时显示的行为可能成为默认行为。</target>
        </trans-unit>
        <trans-unit id="fcebb10283d6873f839e3d670ae393ff5c1368df" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine is called internally by many other SQLite interfaces so that an application usually does not need to invoke sqlite3_initialize() directly. For example, &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt; calls sqlite3_initialize() so the SQLite library will be automatically initialized when &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt; is called if it has not be initialized already. However, if SQLite is compiled with the &lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; compile-time option, then the automatic calls to sqlite3_initialize() are omitted and the application must call sqlite3_initialize() directly prior to using any other SQLite interface. For maximum portability, it is recommended that applications always invoke sqlite3_initialize() directly prior to using any other SQLite interface. Future releases of SQLite may require this. In other words, the behavior exhibited when SQLite is compiled with &lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; might become the default behavior in some future release of SQLite.</source>
          <target state="translated">sqlite3_initialize（）例程由许多其他SQLite接口在内部调用，因此应用程序通常不需要直接调用sqlite3_initialize（）。例如，&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;调用sqlite3_initialize（），所以SQLite库时将被自动初始化&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;被调用，如果它没有被已经初始化。但是，如果使用&lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;编译SQLite使用compile-time选项，则将省略对sqlite3_initialize（）的自动调用，并且应用程序必须在使用任何其他SQLite接口之前直接调用sqlite3_initialize（）。为了获得最大的可移植性，建议应用程序始终始终在使用任何其他SQLite接口之前直接调用sqlite3_initialize（）。 SQLite的未来版本可能会要求这样做。换句话说，在将来的SQLite发行版中，使用&lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;编译SQLite时显示的行为可能成为默认行为。</target>
        </trans-unit>
        <trans-unit id="ce2e2f5e58c3c92f466c0d1a9cbb3782ccb3ca7e" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success. If for some reason, sqlite3_initialize() is unable to initialize the library (perhaps it is unable to allocate a needed resource such as a mutex) it returns an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">sqlite3_initialize（）例程成功返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;。如果由于某种原因sqlite3_initialize（）无法初始化库（也许无法分配所需的资源，例如互斥锁），则它将返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;以外的&lt;a href=&quot;rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7cfd6fb2b2f9b6bef5dc2729044b616aa2e46340" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success. If for some reason, sqlite3_initialize() is unable to initialize the library (perhaps it is unable to allocate a needed resource such as a mutex) it returns an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; other than &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">sqlite3_initialize（）例程成功返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。如果由于某种原因sqlite3_initialize（）无法初始化库（也许无法分配所需的资源，例如互斥锁），则它将返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;以外的&lt;a href=&quot;../rescode&quot;&gt;错误代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="004164880e4716eb9f6522ffa56490d8e1026730" translate="yes" xml:space="preserve">
          <source>The sqlite3_int64 and sqlite3_uint64 are the preferred type definitions. The sqlite_int64 and sqlite_uint64 types are supported for backwards compatibility only.</source>
          <target state="translated">sqlite3_int64和 sqlite3_uint64是首选类型定义。sqlite_int64和 sqlite_uint64类型只支持向后兼容。</target>
        </trans-unit>
        <trans-unit id="7d87f3d7209e128d2babe00e667401d22d9cc8a5" translate="yes" xml:space="preserve">
          <source>The sqlite3_int64 and sqlite_int64 types can store integer values between -9223372036854775808 and +9223372036854775807 inclusive. The sqlite3_uint64 and sqlite_uint64 types can store integer values between 0 and +18446744073709551615 inclusive.</source>
          <target state="translated">sqlite3_int64和sqlite_int64类型可以存储-9223372036854775808和+9223372036854775807(含)之间的整数值。sqlite3_uint64和sqlite_uint64类型可以存储0和+18446744073709551615(含)之间的整数值。</target>
        </trans-unit>
        <trans-unit id="d1945cfc4228bc66b1032ca0f61bc88893782d0c" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statement count reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eba8c8e6f99b81a907173174c705f9ed98298ab" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statements reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="translated">sqlite3_interrupt（D）调用将一直有效，直到&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上所有当前正在运行的SQL语句完成为止。在sqlite3_interrupt（）调用之后且正在运行的语句达到零之前启动的任何新SQL语句都被中断，就好像它们在sqlite3_interrupt（）调用之前已在运行一样。在运行语句计数达到零之后启动的新SQL语句不受sqlite3_interrupt（）的影响。在没有运行中的SQL语句时发生的对sqlite3_interrupt（D）的调用是无操作的，并且对在sqlite3_interrupt（）调用返回后启动的SQL语句没有影响。</target>
        </trans-unit>
        <trans-unit id="397354330de52f0df08035b92ede80f0eda59fd9" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statement count reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6b86af3fa8ce3c883af892e74e82bdad0554e41" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statements reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="translated">sqlite3_interrupt（D）调用将一直有效，直到&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt; D 上所有当前正在运行的SQL语句完成为止。在sqlite3_interrupt（）调用之后且正在运行的语句达到零之前启动的任何新SQL语句都被中断，就好像它们在sqlite3_interrupt（）调用之前已在运行一样。在运行语句计数达到零之后启动的新SQL语句不受sqlite3_interrupt（）的影响。在没有运行中的SQL语句时发生的对sqlite3_interrupt（D）的调用是无操作的，并且对在sqlite3_interrupt（）调用返回后启动的SQL语句没有影响。</target>
        </trans-unit>
        <trans-unit id="3bfe2e62ea9486a964b648fd6403e7edfa3b65f8" translate="yes" xml:space="preserve">
          <source>The sqlite3_keyword_check(Z,L) interface checks to see whether or not the L-byte UTF8 identifier that Z points to is a keyword, returning non-zero if it is and zero if not.</source>
          <target state="translated">sqlite3_keyword_check(Z,L)接口检查Z指向的L字节UTF8标识符是否是关键字,如果是,返回非零,如果不是,返回零。</target>
        </trans-unit>
        <trans-unit id="d4d8092bdf6d249db5e6e39b2ccbee0c913272c1" translate="yes" xml:space="preserve">
          <source>The sqlite3_keyword_count() interface returns the number of distinct keywords understood by SQLite.</source>
          <target state="translated">sqlite3_keyword_count()接口返回SQLite所理解的不同关键字的数量。</target>
        </trans-unit>
        <trans-unit id="dc0acf41ffb529d44b2ebca13529ac325b17bad2" translate="yes" xml:space="preserve">
          <source>The sqlite3_keyword_name(N,Z,L) interface finds the N-th keyword and makes *Z point to that keyword expressed as UTF8 and writes the number of bytes in the keyword into *L. The string that *Z points to is not zero-terminated. The sqlite3_keyword_name(N,Z,L) routine returns SQLITE_OK if N is within bounds and SQLITE_ERROR if not. If either Z or L are NULL or invalid pointers then calls to sqlite3_keyword_name(N,Z,L) result in undefined behavior.</source>
          <target state="translated">sqlite3_keyword_name(N,Z,L)接口找到第N个关键字,并使*Z指向该关键字,用UTF8表示,并将关键字的字节数写入*L中。*Z指向的字符串不以零结尾。sqlite3_keyword_name(N,Z,L)例程如果N在范围内则返回SQLITE_OK,如果不在范围内则返回SQLITE_ERROR。如果Z或L是NULL或无效指针,那么对sqlite3_keyword_name(N,Z,L)的调用将导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="0a1d77fc76c131dee5ee5dd030d6d5133cee00d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_last_insert_rowid(D) interface usually returns the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the most recent successful &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; into a rowid table or &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; on database connection D. Inserts into &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are not recorded. If no successful &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;s into rowid tables have ever occurred on the database connection D, then sqlite3_last_insert_rowid(D) returns zero.</source>
          <target state="translated">所述sqlite3_last_insert_rowid（d）接口通常返回&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;最近成功的&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;成一个rowid表或&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;上的数据库连接D.插入到&lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表不被记录。如果在数据库连接D上没有成功向rowid表&lt;a href=&quot;../lang_insert&quot;&gt;插入INSERT&lt;/a&gt;，则sqlite3_last_insert_rowid（D）返回零。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
