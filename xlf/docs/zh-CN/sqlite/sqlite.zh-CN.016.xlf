<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="480bdad0842ce92215a602c8e8a2e2ba5036d89a" translate="yes" xml:space="preserve">
          <source>The directory or folder in which temporary files are created is determined by the OS-specific &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;.</source>
          <target state="translated">在其中创建临时文件的目录或文件夹由操作系统特定的&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;确定。</target>
        </trans-unit>
        <trans-unit id="58c1fd9cf0b8fae2622f0a1831b48a0d95eaabc6" translate="yes" xml:space="preserve">
          <source>The directory set by &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt; or by the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable</source>
          <target state="translated">由&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt;或&lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;全局变量设置的目录</target>
        </trans-unit>
        <trans-unit id="8e347995ace178c5b68534f7a6dde94c35392830" translate="yes" xml:space="preserve">
          <source>The directory used to hold temporary files on unix can now be set using the SQLITE_TMPDIR environment variable, which takes precedence over the TMPDIR environment variable. The &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable still has higher precedence than both environment variables, however.</source>
          <target state="translated">现在可以使用SQLITE_TMPDIR环境变量来设置用于在Unix上保留临时文件的目录，该目录优先于TMPDIR环境变量。但是，&lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;全局变量的优先级仍然高于两个环境变量。</target>
        </trans-unit>
        <trans-unit id="081d4a11583041f4e8625a8cc56c88ce7150faa6" translate="yes" xml:space="preserve">
          <source>The docid value. The first entry in a doclist contains the literal docid value. The first field of each subsequent doclist entry contains the difference between the new docid and the previous one (always a positive number).</source>
          <target state="translated">docid值。doclist的第一个条目包含docid的字面值。后续每一个doclist条目的第一个字段包含新的docid和前一个的差值(总是一个正数)。</target>
        </trans-unit>
        <trans-unit id="49e2bf067b92acf951896b04368654ffcd3a3f99" translate="yes" xml:space="preserve">
          <source>The document only describes locking for the older rollback-mode transaction mechanism. Locking for the newer &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; or &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is described separately.</source>
          <target state="translated">该文档仅描述了针对较旧的回滚模式事务处理机制的锁定。单独描述了用于较新的&lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt;或&lt;a href=&quot;wal&quot;&gt;WAL模式的&lt;/a&gt;锁定。</target>
        </trans-unit>
        <trans-unit id="1297878fc527d5d7c17142be2f4f043e484d8aa6" translate="yes" xml:space="preserve">
          <source>The documentation is maintained in separate source repositories on those same servers:</source>
          <target state="translated">这些文档在这些服务器上的单独的源码库中维护。</target>
        </trans-unit>
        <trans-unit id="d0017ab9193a6ed1029ad59fab58ce3ec88e592f" translate="yes" xml:space="preserve">
          <source>The documentation sources include documentation text and images with the scripts and makefile needed to construct the SQLite website documentation. This document is contained within the documentation sources. The document sources are kept in a separate repository distinct from the source code. The documentation sources repository is publicly readable.</source>
          <target state="translated">文档源包括文档文本和图片,以及构建SQLite网站文档所需的脚本和makefile。该文档包含在文档源中。文档源保存在一个独立的存储库中,与源代码不同。文档源存储库是可以公开阅读的。</target>
        </trans-unit>
        <trans-unit id="278f1b137f0865ba684c7cde1fa14cf1c768e813" translate="yes" xml:space="preserve">
          <source>The documentation system automatically maintains a &lt;a href=&quot;https://sqlite.org/chronology.html&quot;&gt;chronology&lt;/a&gt; of past releases, as well as a &lt;a href=&quot;changes&quot;&gt;complete list of SQLite releases&lt;/a&gt; with change summaries.</source>
          <target state="translated">文档系统会自动维护过去版本的&lt;a href=&quot;https://sqlite.org/chronology.html&quot;&gt;时间顺序&lt;/a&gt;，以及带有变更摘要&lt;a href=&quot;changes&quot;&gt;的SQLite版本&lt;/a&gt;的完整列表。</target>
        </trans-unit>
        <trans-unit id="65988e654b808af94ee6da6f09345ac1241a1ac8" translate="yes" xml:space="preserve">
          <source>The dot-command must be entirely contained on a single input line.</source>
          <target state="translated">点阵命令必须完全包含在一个输入行中。</target>
        </trans-unit>
        <trans-unit id="6fcffd0a57b5ba6715e1715a67438a136bebf610" translate="yes" xml:space="preserve">
          <source>The dot-commands are interpreted by the sqlite3.exe command-line program, not by SQLite itself. So none of the dot-commands will work as an argument to SQLite interfaces like &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;.</source>
          <target state="translated">点命令由sqlite3.exe命令行程序解释，而不由SQLite本身解释。因此，任何点命令都不能用作&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;或&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）之&lt;/a&gt;类的SQLite接口的参数。</target>
        </trans-unit>
        <trans-unit id="73b101a4a2aed2c88c1089ef5e27eb7bd916289f" translate="yes" xml:space="preserve">
          <source>The downside of automatic incremental merging is that it makes every INSERT, UPDATE, and DELETE operation on an FTS3/4 table run a little slower, since extra time must be used to do the incremental merge. For maximum performance, it is recommended that applications disable automatic incremental merge and instead use the &lt;a href=&quot;fts3#*fts4mergecmd&quot;&gt;&quot;merge&quot; command&lt;/a&gt; in an idle process to keep the inverted indices well merged. But if the structure of an application does not easily allow for idle processes, the use of automatic incremental merge is a very reasonable fallback solution.</source>
          <target state="translated">自动增量合并的缺点是，由于必须花费额外的时间来进行增量合并，因此它会使FTS3 / 4表上的每个INSERT，UPDATE和DELETE操作都慢一些。为了获得最佳性能，建议应用程序禁用自动增量合并，而应在空闲过程中使用&lt;a href=&quot;fts3#*fts4mergecmd&quot;&gt;&amp;ldquo; merge&amp;rdquo;命令&lt;/a&gt;来保持反向索引良好地合并。但是，如果应用程序的结构不容易允许空闲进程，则使用自动增量合并是一种非常合理的后备解决方案。</target>
        </trans-unit>
        <trans-unit id="c77ebced48dfa7e23a77c44a167057f7558d4f17" translate="yes" xml:space="preserve">
          <source>The downside of storing schema a text is that it can make the schema tricky to modify. And for that reason, the ALTER TABLE support in SQLite has traditionally lagged behind other SQL database engines that store their schemas as parsed system tables that are easier to modify.</source>
          <target state="translated">将schema存储为文本的缺点是会使schema的修改变得棘手。而由于这个原因,SQLite中的ALTER TABLE支持历来落后于其他SQL数据库引擎,因为其他SQL数据库引擎将模式存储为解析的系统表,更容易修改。</target>
        </trans-unit>
        <trans-unit id="1bd6a18e90f1a8ee8256e02fe4825c2a58f166f7" translate="yes" xml:space="preserve">
          <source>The dynamic webpages on the SQLite website are mostly generated by the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil version control system&lt;/a&gt;. A typical dynamic page would be a timeline such as &lt;a href=&quot;https://www.sqlite.org/src/timeline&quot;&gt;https://www.sqlite.org/src/timeline&lt;/a&gt;. A log of all SQL used by the timeline is shown below.</source>
          <target state="translated">SQLite网站上的动态网页主要由&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil版本控制系统&lt;/a&gt;生成。典型的动态页面是时间轴，例如&lt;a href=&quot;https://www.sqlite.org/src/timeline&quot;&gt;https://www.sqlite.org/src/timeline&lt;/a&gt;。时间轴使用的所有SQL的日志如下所示。</target>
        </trans-unit>
        <trans-unit id="f53c608dfb99715244babeb0f18e6bedb4ce61c6" translate="yes" xml:space="preserve">
          <source>The eTextRep argument determines the encoding of strings passed to the collating function callback, xCallback. The &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; and &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; values for eTextRep force strings to be UTF16 with native byte order. The &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; value for eTextRep forces strings to begin on an even byte address.</source>
          <target state="translated">eTextRep参数确定传递到整理函数回调xCallback的字符串的编码。该&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;和&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt;为eTextRep力的字符串值是UTF-16与本地字节顺序。该&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt;为eTextRep力的字符串值，开始在偶数字节地址。</target>
        </trans-unit>
        <trans-unit id="1f8a73896c29d2961fd12e3fd13060416db06dbd" translate="yes" xml:space="preserve">
          <source>The eTextRep argument determines the encoding of strings passed to the collating function callback, xCallback. The &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; and &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; values for eTextRep force strings to be UTF16 with native byte order. The &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; value for eTextRep forces strings to begin on an even byte address.</source>
          <target state="translated">eTextRep参数确定传递到整理函数回调xCallback的字符串的编码。该&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;和&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt;为eTextRep力的字符串值是UTF-16与本地字节顺序。该&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt;为eTextRep力的字符串值，开始在偶数字节地址。</target>
        </trans-unit>
        <trans-unit id="4013154ef9b1afc10a2efd1408a9638085e650fc" translate="yes" xml:space="preserve">
          <source>The eTextRep argument determines the encoding of strings passed to the collating function callback, xCompare. The &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; and &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; values for eTextRep force strings to be UTF16 with native byte order. The &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; value for eTextRep forces strings to begin on an even byte address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7222f354f082d59aa96eba0376b7b091cc4ec0bd" translate="yes" xml:space="preserve">
          <source>The eTextRep argument determines the encoding of strings passed to the collating function callback, xCompare. The &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; and &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; values for eTextRep force strings to be UTF16 with native byte order. The &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; value for eTextRep forces strings to begin on an even byte address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af71ae840c72707272be3031b3c3ee6f45c5d71f" translate="yes" xml:space="preserve">
          <source>The edit distance coefficients are normally read from the APPCOST table once and there after stored in memory. Hence, run-time changes to the APPCOST table will not normally affect the edit distance results. However, inserting the special string 'reset' into the &quot;command&quot; column of the virtual table causes the edit distance coefficients to be reread the APPCOST table. Hence, applications should run a SQL statement similar to the following when changes to the APPCOST table occur:</source>
          <target state="translated">编辑距离系数通常从APPCOST表中读取一次,然后存储在内存中。因此,运行时对APPCOST表的修改通常不会影响编辑距离结果。但是,在虚拟表的 &quot;命令 &quot;列中插入特殊字符串 &quot;复位 &quot;会导致重新读取APPCOST表的编辑距离系数。因此,当APPCOST表发生变化时,应用程序应该运行类似于以下的SQL语句。</target>
        </trans-unit>
        <trans-unit id="49994af0743488763f79d75d2c9c86ebfda2dfb6" translate="yes" xml:space="preserve">
          <source>The edit program can also be used as a viewer, by simply ignoring the return value. For example, to merely look at the image above, you might run:</source>
          <target state="translated">编辑程序也可以作为查看器使用,只要忽略返回值即可。例如,如果只是看上面的图片,你可以运行。</target>
        </trans-unit>
        <trans-unit id="47a4a763ba31495e47240c644f7558e9498bae30" translate="yes" xml:space="preserve">
          <source>The edit() function can be used to make changes to large text values. For example:</source>
          <target state="translated">edit()函数可以用来对大文本值进行修改。例如:&quot;edit()&quot;函数可以用来修改大的文本值。</target>
        </trans-unit>
        <trans-unit id="fd34f0d751c4ddc69b221f64ffd45f8927b66781" translate="yes" xml:space="preserve">
          <source>The editdist3 algorithm is a function that computes the minimum edit distance (a.k.a. the Levenshtein distance) between two input strings. The editdist3 algorithm is a configurable alternative to the default edit distance function of spellfix1. Features of editdist3 include:</source>
          <target state="translated">editdist3 算法是一个计算两个输入字符串之间最小编辑距离(也就是 Levenshtein 距离)的函数。editdist3算法是spellfix1的默认编辑距离函数的一个可配置的替代品。editdist3的功能包括</target>
        </trans-unit>
        <trans-unit id="870b1bf5bd7c0178ecc9a04d5313cc57bc40b4f1" translate="yes" xml:space="preserve">
          <source>The effects of a &lt;b&gt;truncate file&lt;/b&gt; operation are not assumed to be made persistent until after the corresponding file has been</source>
          <target state="translated">&lt;b&gt;截断文件&lt;/b&gt;操作的效果直到相应文件被删除后才被认为是持久的。</target>
        </trans-unit>
        <trans-unit id="393d1077fa976da06b2c81028e0e667751bfce07" translate="yes" xml:space="preserve">
          <source>The empty-result-callbacks flag affects the &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; API only. Normally, when the empty-result-callbacks flag is cleared, the callback function supplied to the &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; is not invoked for commands that return zero rows of data. When empty-result-callbacks is set in this situation, the callback function is invoked exactly once, with the third parameter set to 0 (NULL). This is to enable programs that use the &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; API to retrieve column-names even when a query returns no data.</source>
          <target state="translated">empty-result-callbacks标志仅影响&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt; API。通常，当清除empty-result-callbacks标志时，不会为返回零行数据的命令调用提供给&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;的回调函数。如果在这种情况下设置了empty-result-callbacks，则将回调函数仅调用一次，第三个参数设置为0（NULL）。这是为了使使用&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt; API的程序即使在查询不返回任何数据时也可以检索列名。</target>
        </trans-unit>
        <trans-unit id="f1a25180fc453bfc9b7157e5b028aa8235fc10f5" translate="yes" xml:space="preserve">
          <source>The end-user executes DML or DDL SQL statements that require the structure of the database file of the database file to be modified. These modifications may be any combination of operations to</source>
          <target state="translated">最终用户执行DML或DDL SQL语句,需要对数据库文件的结构进行修改。这些修改可以是任意组合的操作,以达到</target>
        </trans-unit>
        <trans-unit id="5b923462226ca9a3f1ea2da34aa276431384d659" translate="yes" xml:space="preserve">
          <source>The ending frame boundary can be omitted (if the BETWEEN and AND keywords that surround the starting frame boundary are also omitted), in which case the ending frame boundary defaults to CURRENT ROW.</source>
          <target state="translated">结束帧边界可以省略(如果包围起始帧边界的BETWEEN和AND关键字也被省略的话),在这种情况下,结束帧边界默认为CURRENT ROW。</target>
        </trans-unit>
        <trans-unit id="b26c1d5670afb707a661dd133bd85c139805e555" translate="yes" xml:space="preserve">
          <source>The ending frame boundary may not take a form that appears higher in the above list than the starting frame boundary.</source>
          <target state="translated">结束帧边界的形式不得高于上述列表中的起始帧边界。</target>
        </trans-unit>
        <trans-unit id="1133a1a20cf9f9901ca7376082c18ed0b6c4a36d" translate="yes" xml:space="preserve">
          <source>The engine no longer consults the main table if it can get all the information it needs from an index.</source>
          <target state="translated">如果能从索引中获得所需的所有信息,引擎就不再查询主表。</target>
        </trans-unit>
        <trans-unit id="b873e4983f185f34587580faeee301ccc43a5a88" translate="yes" xml:space="preserve">
          <source>The enhanced query syntax supports the AND, OR and NOT binary set operators. Each of the two operands to an operator may be a basic FTS query, or the result of another AND, OR or NOT set operation. Operators must be entered using capital letters. Otherwise, they are interpreted as basic term queries instead of set operators.</source>
          <target state="translated">增强型查询语法支持AND、OR和NOT二进制集运算符。操作符的两个操作数中的每一个都可以是一个基本的FTS查询,或者是另一个AND、OR或NOT集操作的结果。操作符必须用大写字母输入。否则,它们将被解释为基本术语查询,而不是集合运算符。</target>
        </trans-unit>
        <trans-unit id="ec0a2d5aa63b2e3b719340bb237dcfc9aebe4443" translate="yes" xml:space="preserve">
          <source>The entries above might represent (for example) a bounding box around the main office for SQLite.org and bounding box around the 12th Congressional District of North Carolina (prior to the 2011 redistricting) in which SQLite.org was located.</source>
          <target state="translated">上面的条目可能代表(例如)SQLite.org主办公室周围的边界框和SQLite.org所在的北卡罗来纳州第12个国会选区(在2011年重新划分之前)周围的边界框。</target>
        </trans-unit>
        <trans-unit id="df23c9e0d03ef84c1b3ecc39ad637f8b14bf70ea" translate="yes" xml:space="preserve">
          <source>The entry point is zProc. zProc may be 0, in which case SQLite will try to come up with an entry point name on its own. It first tries &quot;sqlite3_extension_init&quot;. If that does not work, it constructs a name &quot;sqlite3_X_init&quot; where the X is consists of the lower-case equivalent of all ASCII alphabetic characters in the filename from the last &quot;/&quot; to the first following &quot;.&quot; and omitting any initial &quot;lib&quot;. The sqlite3_load_extension() interface returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if something goes wrong. If an error occurs and pzErrMsg is not 0, then the &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface shall attempt to fill *pzErrMsg with error message text stored in memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The calling function should free this memory by calling &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">入口点是zProc。 zProc可能为0，在这种情况下，SQLite会尝试自行提出入口点名称。首先尝试&amp;ldquo; sqlite3_extension_init&amp;rdquo;。如果不起作用，它将构造一个名称&amp;ldquo; sqlite3_X_init&amp;rdquo;，其中X由文件名中所有ASCII字母字符的小写形式等效，从最后一个&amp;ldquo; /&amp;rdquo;到其后的第一个&amp;ldquo;&amp;rdquo;。并省略任何初始的&amp;ldquo; lib&amp;rdquo;。该sqlite3_load_extension（）接口返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;成功和&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;如果出现错误。如果发生错误并且pzErrMsg不为0，则&lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;接口应尝试使用从&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;获取的存储在错误消息中的文本填充* pzErrMsg。。调用函数应通过调用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放此内存。</target>
        </trans-unit>
        <trans-unit id="4f2e7b718e4064a2f8cc8acbe7a051458f014ce0" translate="yes" xml:space="preserve">
          <source>The entry point is zProc. zProc may be 0, in which case SQLite will try to come up with an entry point name on its own. It first tries &quot;sqlite3_extension_init&quot;. If that does not work, it constructs a name &quot;sqlite3_X_init&quot; where the X is consists of the lower-case equivalent of all ASCII alphabetic characters in the filename from the last &quot;/&quot; to the first following &quot;.&quot; and omitting any initial &quot;lib&quot;. The sqlite3_load_extension() interface returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if something goes wrong. If an error occurs and pzErrMsg is not 0, then the &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface shall attempt to fill *pzErrMsg with error message text stored in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The calling function should free this memory by calling &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">入口点是zProc。 zProc可能为0，在这种情况下，SQLite会尝试自行提出入口点名称。首先尝试&amp;ldquo; sqlite3_extension_init&amp;rdquo;。如果不起作用，它将构造一个名称&amp;ldquo; sqlite3_X_init&amp;rdquo;，其中X由文件名中所有ASCII字母字符的小写形式等效，从最后一个&amp;ldquo; /&amp;rdquo;到其后的第一个&amp;ldquo;&amp;rdquo;。并省略任何初始的&amp;ldquo; lib&amp;rdquo;。该sqlite3_load_extension（）接口返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;成功和&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;如果出现错误。如果发生错误并且pzErrMsg不为0，则&lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;接口应尝试使用从&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;获取的存储在错误消息中的文本填充* pzErrMsg。。调用函数应通过调用&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放此内存。</target>
        </trans-unit>
        <trans-unit id="c3b2f6eda62654fcc0bcaa7e0b88feb088762bb7" translate="yes" xml:space="preserve">
          <source>The error arises because only about the first 15 significant digits of each number are stored accurately, and first the difference between the two numbers being subtracted is in the 16th digit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40007c6bf4af7619580a2e5c3ec81a4fee4ad813" translate="yes" xml:space="preserve">
          <source>The error code is changed to &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; (instead of &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;) when an attempt is made to &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; while one or more queries are still pending.</source>
          <target state="translated">在一个或多个查询仍悬而未决的情况下尝试进行&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;时，错误代码将更改为&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;（而不是&lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2e60aa60ea376ea9ca807c8cc7d0b0b91ec054e5" translate="yes" xml:space="preserve">
          <source>The error codes for SQLite version 3 are unchanged from version 2. They are as follows:</source>
          <target state="translated">SQLite第3版的错误代码与第2版没有变化。这些错误代码如下:</target>
        </trans-unit>
        <trans-unit id="2ccece93e5a00d5f5d9d7a6919183b3a66f82129" translate="yes" xml:space="preserve">
          <source>The error logger callback function might look something like this:</source>
          <target state="translated">错误记录器的回调函数可能看起来像这样。</target>
        </trans-unit>
        <trans-unit id="8ad007677ae545b2ad036dc3fbfd526afb2a9647" translate="yes" xml:space="preserve">
          <source>The error logger callback should be treated like a signal handler. The application should save off or otherwise process the error, then return as soon as possible. No other SQLite APIs should be invoked, directly or indirectly, from the error logger. SQLite is &lt;u&gt;not&lt;/u&gt; reentrant through the error logger callback. In particular, the error logger callback is invoked when a memory allocation fails, so it is generally a bad idea to try to allocate memory inside the error logger. Do not even think about trying to store the error message in another SQLite database.</source>
          <target state="translated">错误记录器回调应被视为信号处理程序。应用程序应保存或以其他方式处理该错误，然后尽快返回。不应从错误记录器直接或间接调用其他SQLite API。通过错误记录器回调，SQLite &lt;u&gt;不可&lt;/u&gt;重入。特别是，当内存分配失败时，将调用错误记录器回调，因此尝试在错误记录器中分配内存通常是一个坏主意。甚至不要考虑尝试将错误消息存储在另一个SQLite数据库中。</target>
        </trans-unit>
        <trans-unit id="931b7a49e1d266b8f7af8c59c48646cf4fc9a825" translate="yes" xml:space="preserve">
          <source>The error messages that might be sent to the error logger and their exact format is subject to changes from one release to the next. So applications should not depend on any particular error message text formats or error codes. Things do not change capriciously, but they do sometimes changes.</source>
          <target state="translated">可能被发送到错误记录器的错误信息及其确切格式会因版本不同而发生变化。所以应用程序不应依赖任何特定的错误信息文本格式或错误代码。事物不会任性地变化,但有时也会发生变化。</target>
        </trans-unit>
        <trans-unit id="6f0f73d0eed4daf2fa7ce504b606f01da04260dc" translate="yes" xml:space="preserve">
          <source>The estimatedCost field should be set to the estimated number of disk access operations required to execute this query against the virtual table. The SQLite core will often call xBestIndex multiple times with different constraints, obtain multiple cost estimates, then choose the query plan that gives the lowest estimate. The SQLite core initializes estimatedCost to a very large value prior to invoking xBestIndex, so if xBestIndex determines that the current combination of parameters is undesirable, it can leave the estimatedCost field unchanged to discourage its use.</source>
          <target state="translated">estimatedCost字段应设置为对虚拟表执行此查询所需的磁盘访问操作的估计次数。SQLite核心经常会用不同的约束条件多次调用xBestIndex,获取多个成本估计值,然后选择给出最低估计值的查询计划。在调用xBestIndex之前,SQLite核心会将assimestCost初始化为一个非常大的值,所以如果xBestIndex确定当前的参数组合是不可取的,它可以不改变assimestCost字段,以阻止其使用。</target>
        </trans-unit>
        <trans-unit id="9110d26065cfada658af48dd22a731f2e42c4634" translate="yes" xml:space="preserve">
          <source>The estimatedCost value is an estimate of the cost of a particular strategy. A cost of N indicates that the cost of the strategy is similar to a linear scan of an SQLite table with N rows. A cost of log(N) indicates that the expense of the operation is similar to that of a binary search on a unique indexed field of an SQLite table with N rows.</source>
          <target state="translated">estimatedCost值是对特定策略成本的估计。成本为N表示该策略的费用类似于对一个有N行的SQLite表进行线性扫描的费用。log(N)表示该操作的费用类似于对一个有N行的SQLite表的唯一索引字段进行二进制搜索的费用。</target>
        </trans-unit>
        <trans-unit id="a1d11ebb28b1bb46c038273ece9416f81d29642b" translate="yes" xml:space="preserve">
          <source>The estimatedRows value is an estimate of the number of rows that will be returned by the strategy.</source>
          <target state="translated">estimatedRows值是对策略将返回的行数的估计。</target>
        </trans-unit>
        <trans-unit id="6e98b869e8e492045895b07f0da4a451a3b65571" translate="yes" xml:space="preserve">
          <source>The exact logic used to determine if a</source>
          <target state="translated">确切的逻辑是用来确定一个</target>
        </trans-unit>
        <trans-unit id="c7341ca7ddb26c5a501b148a51edcbd920ab7841" translate="yes" xml:space="preserve">
          <source>The exact same source code can be used for both a run-time loadable shared library or DLL and as a module that is statically linked with your application. This provides flexibility and allows you to reuse the same code in different ways.</source>
          <target state="translated">完全相同的源代码既可用于运行时可加载的共享库或DLL,也可用于与应用程序静态链接的模块。这提供了灵活性,允许您以不同的方式重复使用相同的代码。</target>
        </trans-unit>
        <trans-unit id="51d3ce62c3eb93876d401465d70f8ba808604db2" translate="yes" xml:space="preserve">
          <source>The example above causes the database file named &quot;ex1.db&quot; to be opened and used. The &quot;ex1.db&quot; file is created if it does not previously exist. You might want to use a full pathname to ensure that the file is in the directory that you think it is in. Use forward-slashes as the directory separator character. In other words use &quot;c:/work/ex1.db&quot;, not &quot;c:\work\ex1.db&quot;.</source>
          <target state="translated">上面的例子导致名为 &quot;ex1.db &quot;的数据库文件被打开并使用。如果 &quot;ex1.db &quot;文件之前不存在,就会被创建。您可能需要使用完整的路径名来确保文件在您认为的目录中。使用正斜线作为目录分隔符。换句话说,使用 &quot;c:/work/ex1.db&quot;,而不是 &quot;c:\work\ex1.db&quot;。</target>
        </trans-unit>
        <trans-unit id="97b14b6298ce84315e618c11d7722d98fb92421a" translate="yes" xml:space="preserve">
          <source>The example above contains two &quot;SCALAR&quot; subqueries. The subqueries are SCALAR in the sense that they return a single value - a one-row, one-column table. If the actual query returns more than that, then only the first column of the first row is used.</source>
          <target state="translated">上面的示例包含两个 &quot;SCALAR &quot;子查询。这些子查询是SCALAR,因为它们只返回一个值--一个单行单列的表。如果实际查询返回的值超过这个值,那么只使用第一行的第一列。</target>
        </trans-unit>
        <trans-unit id="d7a7c3999051bd06566a95bdd9bc9de8e3e4adaa" translate="yes" xml:space="preserve">
          <source>The example above illustrates the signature of the error logger callback. However, in an embedded application, one usually does not print messages on stderr. Instead, one might store the messages in a preallocated circular buffer where they can be accessed when diagnostic information is needed during debugging. Or perhaps the messages can be sent to &lt;a href=&quot;http://en.wikipedia.org/wiki/Syslog&quot;&gt;Syslog&lt;/a&gt;. Somehow, the messages need to be stored where they are accessible to developers, not displayed to end users.</source>
          <target state="translated">上面的示例说明了错误记录器回调的签名。但是，在嵌入式应用程序中，通常不会在stderr上打印消息。相反，可以将消息存储在预分配的循环缓冲区中，在调试期间需要诊断信息时可以在其中访问这些消息。或者，消息可以发送到&lt;a href=&quot;http://en.wikipedia.org/wiki/Syslog&quot;&gt;Syslog&lt;/a&gt;。消息需要以某种方式存储在开发人员可以访问的位置，而不显示给最终用户。</target>
        </trans-unit>
        <trans-unit id="d307547a7cd9c2e8e0dc86cacf98f3de8afb55c2" translate="yes" xml:space="preserve">
          <source>The example above showed a single &lt;b&gt;filename='thefile.csv'&lt;/b&gt; argument for the CSV virtual table. But other arguments are also possible.</source>
          <target state="translated">上面的示例显示了CSV虚拟表的单个&lt;b&gt;filename ='thefile.csv'&lt;/b&gt;参数。但是其他论点也是可能的。</target>
        </trans-unit>
        <trans-unit id="11a05b76af4570008579a529531a96eb802e047d" translate="yes" xml:space="preserve">
          <source>The example above shows SQLite picking full-table scan will visit all rows in the table. If the query were able to use an index, then the SCAN/SEARCH record would include the name of the index and, for a SEARCH record, an indication of how the subset of rows visited is identified. For example:</source>
          <target state="translated">上面的例子显示,SQLite挑选全表扫描将访问表中的所有行。假如查询能够运用索引,那么SCAN/SEARCH记载就会包含索引的姓名,而关于SEARCH记载,则会标明怎样辨认所拜访的行的子集。比如说:&quot;SCAN/SEARCH记录&quot;。</target>
        </trans-unit>
        <trans-unit id="abd381887f2ea42f76bfd9ebc8b17425d16e2957" translate="yes" xml:space="preserve">
          <source>The example below uses ntile() to divide the six rows into two groups (the ntile(2) call) and into four groups (the ntile(4) call). For ntile(2), there are three rows assigned to each group. For ntile(4), there are two groups of two and two groups of one. The larger groups of two appear first.</source>
          <target state="translated">下面的例子使用ntile()将六条记录分为两组(ntile(2)调用)和四组(ntile(4)调用)。对于ntile(2),每组有三条记录。对于ntile(4),有两组的两组和两组的一组。大的两组先出现。</target>
        </trans-unit>
        <trans-unit id="c8ad72613a1253e10b2aeefbfa091cedb3448e07" translate="yes" xml:space="preserve">
          <source>The example code below demonstrates the steps involved in capturing a changeset while executing SQL commands. In summary:</source>
          <target state="translated">下面的示例代码演示了在执行SQL命令时捕获变化集的步骤。总的来说。</target>
        </trans-unit>
        <trans-unit id="cfda7c494f05312b3bf7826ec92aff6df2e44b46" translate="yes" xml:space="preserve">
          <source>The example code below demonstrates the techniques used to iterate through and extract the data related to all changes in a changeset. To summarize:</source>
          <target state="translated">下面的示例代码演示了用于迭代并提取与变更集中所有变更相关的数据的技术。总结一下。</target>
        </trans-unit>
        <trans-unit id="5dde8802fcba008ca09e765d610fcb4f5bf326ca" translate="yes" xml:space="preserve">
          <source>The example code below uses the second of the methods enumerated above - it monitors for changes on all database tables.</source>
          <target state="translated">下面的示例代码使用了上面列举的第二种方法--它监控所有数据库表的变化。</target>
        </trans-unit>
        <trans-unit id="3f036ecd22d9629ed467ac2dbb67b517f12166ad" translate="yes" xml:space="preserve">
          <source>The examples above all use basic full-text term queries as both operands of the set operations demonstrated. Phrase and NEAR queries may also be used, as may the results of other set operations. When more than one set operation is present in an FTS query, the precedence of operators is as follows:</source>
          <target state="translated">上面的例子都使用基本的全文术语查询作为所演示的集合运算的操作数。也可以使用短语和near查询,也可以使用其他集合操作的结果。当一个FTS查询中出现一个以上的集合操作时,操作符的优先级如下。</target>
        </trans-unit>
        <trans-unit id="1921013ee1678e9933f635ab4c9457e39025bfc3" translate="yes" xml:space="preserve">
          <source>The examples below identify the collating sequences that would be used to determine the results of text comparisons that may be performed by various SQL statements. Note that a text comparison may not be required, and no collating sequence used, in the case of numeric, blob or NULL values.</source>
          <target state="translated">下面的示例确定了用于确定各种SQL语句可能执行的文本比较结果的整理序列。请注意,在数值、blob或NULL值的情况下,可能不需要进行文本比较,也不使用整理序列。</target>
        </trans-unit>
        <trans-unit id="367a92feb39a9287f4306f6946c319f7064a8b02" translate="yes" xml:space="preserve">
          <source>The examples in this section all assume that the database is populated as follows:</source>
          <target state="translated">本节的例子都假设数据库的填充方式如下。</target>
        </trans-unit>
        <trans-unit id="c2bd8a896b6e33422d64448169403c1bc373cf0d" translate="yes" xml:space="preserve">
          <source>The examples in this section all assume the following data:</source>
          <target state="translated">本节的例子都是假设以下数据。</target>
        </trans-unit>
        <trans-unit id="4d8c3a17bac2c4be1cb9b2d64248454f5513cff9" translate="yes" xml:space="preserve">
          <source>The exception mentioned above is that if the declaration of a column with declared type &quot;INTEGER&quot; includes an &quot;PRIMARY KEY DESC&quot; clause, it does not become an alias for the rowid and is not classified as an integer primary key. This quirk is not by design. It is due to a bug in early versions of SQLite. But fixing the bug could result in backwards incompatibilities. Hence, the original behavior has been retained (and documented) because odd behavior in a corner case is far better than a compatibility break. This means that the following three table declarations all cause the column &quot;x&quot; to be an alias for the rowid (an integer primary key):</source>
          <target state="translated">上面提到的例外情况是,如果声明类型为 &quot;INTEGER &quot;的列的声明中包含了 &quot;PRIMARY KEY DESC &quot;子句,那么它不会成为rowid的别名,也不会被归为整数主键。这个怪癖不是设计出来的。它是由于SQLite早期版本中的一个bug。但是修复这个错误可能会导致向后的不兼容。因此,原来的行为被保留了下来(并被记录下来),因为在角落的情况下,奇怪的行为远比兼容性的破坏要好得多。这意味着以下三个表的声明都会导致列 &quot;x &quot;成为rowid(一个整数主键)的别名。</target>
        </trans-unit>
        <trans-unit id="3fca028858f76596a98f86d48ac0ce09545ac4bf" translate="yes" xml:space="preserve">
          <source>The executable format really ends up being just an implementation detail. The key point is that all languages have a compiler step which translates programs into an executable format and a run step that executes the compiled program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f41b51d024f674a1f6149c31aede1e868d7d56cf" translate="yes" xml:space="preserve">
          <source>The existence of a transaction depends on whether or not the rollback journal file exists and the deletion of a file appears to be an atomic operation from the point of view of a user-space process. Therefore, a transaction appears to be an atomic operation.</source>
          <target state="translated">一个事务的存在取决于回滚日志文件是否存在,从用户空间进程的角度看,删除一个文件似乎是一个原子操作。因此,一个事务看起来是一个原子操作。</target>
        </trans-unit>
        <trans-unit id="6021cb5e88d7481ca7795a9ddd0c04e6033fc0e0" translate="yes" xml:space="preserve">
          <source>The existing INSERT is removed from the changegroup. The DELETE is not added.</source>
          <target state="translated">现有的INSERT从变更组中删除。不增加DELETE。</target>
        </trans-unit>
        <trans-unit id="4a2b5a6b7a6bdb1833a8cf1e839e065d174385dc" translate="yes" xml:space="preserve">
          <source>The existing UPDATE is replaced by the new DELETE within the changegroup.</source>
          <target state="translated">现有的UPDATE被changegroup中新的DELETE取代。</target>
        </trans-unit>
        <trans-unit id="5c1e2e9de2a17cfdc315c14e1e74a36e45b9c92f" translate="yes" xml:space="preserve">
          <source>The existing UPDATE remains within the changegroup. It is amended so that the accompanying values are as if the row was updated once by the existing change and then again by the new change.</source>
          <target state="translated">现有的UPDATE仍然保留在changegroup中。修改后,所附的值就像该行被现有的变化更新了一次,然后又被新的变化更新了一次一样。</target>
        </trans-unit>
        <trans-unit id="fca9185c8e0eb9e3e49b7068e021cf8a710c066e" translate="yes" xml:space="preserve">
          <source>The explicit COMMIT command runs immediately, even if there are pending &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. However, if there are pending write operations, the COMMIT command will fail with an error code &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="translated">即使有未决的&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句，显式COMMIT命令也会立即运行。但是，如果有挂起的写操作，则COMMIT命令将失败，并显示错误代码&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e2d16a733bb795b8f24e0161c9bf1e3201567a34" translate="yes" xml:space="preserve">
          <source>The expression &quot;+column&quot; is now considered the same as &quot;column&quot; when computing the collating sequence to use on the expression.</source>
          <target state="translated">现在,在计算对表达式使用的整理序列时,表达式 &quot;+column &quot;被认为与 &quot;column &quot;相同。</target>
        </trans-unit>
        <trans-unit id="fee373e0e83d3368c40362493777ab8e984bd97b" translate="yes" xml:space="preserve">
          <source>The expression &quot;a BETWEEN b AND c&quot; is treated as two separate binary comparisons &quot;a &amp;gt;= b AND a &amp;lt;= c&quot;, even if that means different affinities are applied to 'a' in each of the comparisons. Datatype conversions in comparisons of the form &quot;x IN (SELECT y ...)&quot; are handled is if the comparison were really &quot;x=y&quot;. The expression &quot;a IN (x, y, z, ...)&quot; is equivalent to &quot;a = +x OR a = +y OR a = +z OR ...&quot;. In other words, the values to the right of the IN operator (the &quot;x&quot;, &quot;y&quot;, and &quot;z&quot; values in this example) are considered to have no affinity, even if they happen to be column values or CAST expressions.</source>
          <target state="translated">表达式&amp;ldquo; a在b AND c之间&amp;rdquo;被视为两个单独的二进制比较&amp;ldquo; a&amp;gt; = b AND a &amp;lt;= c&amp;rdquo;，即使这意味着在每个比较中对&amp;ldquo; a&amp;rdquo;应用了不同的亲和力。如果比较确实是&amp;ldquo; x = y&amp;rdquo;，则处理形式为&amp;ldquo; x IN（SELECT y ...）&amp;rdquo;的比较中的数据类型转换。表达式&amp;ldquo; a IN（x，y，z，...）&amp;rdquo;等效于&amp;ldquo; a = + x OR a = + y OR a = + z OR ...&amp;rdquo;。换句话说，IN运算符右边的值（在此示例中为&amp;ldquo; x&amp;rdquo;，&amp;ldquo; y&amp;rdquo;和&amp;ldquo; z&amp;rdquo;值）被认为没有亲和力，即使它们碰巧是列值或CAST表达式。</target>
        </trans-unit>
        <trans-unit id="15a424b3e7e4f20cd419dc00af0824f2446f3f50" translate="yes" xml:space="preserve">
          <source>The expression &quot;x BETWEEN y and z&quot; is logically equivalent to two comparisons &quot;x &amp;gt;= y AND x &amp;lt;= z&quot; and works with respect to collating functions as if it were two separate comparisons. The expression &quot;x IN (SELECT y ...)&quot; is handled in the same way as the expression &quot;x = y&quot; for the purposes of determining the collating sequence. The collating sequence used for expressions of the form &quot;x IN (y, z, ...)&quot; is the collating sequence of x.</source>
          <target state="translated">表达式&amp;ldquo; x在y和z之间&amp;rdquo;在逻辑上等效于两个比较&amp;ldquo; x&amp;gt; = y AND x &amp;lt;= z&amp;rdquo;，并且对于整理函数而言就像是两个单独的比较一样。为了确定整理顺序，以与表达式&amp;ldquo; x = y&amp;rdquo;相同的方式处理表达式&amp;ldquo; x IN（SELECT y ...）&amp;rdquo;。用于形式为&amp;ldquo; x IN（y，z，...）&amp;rdquo;的表达式的整理序列是x的整理序列。</target>
        </trans-unit>
        <trans-unit id="70c0ccea32ba2d8b128981db932845adc7b90c4c" translate="yes" xml:space="preserve">
          <source>The expression &quot;x BETWEEN y and z&quot; is logically equivalent to two comparisons &quot;x &amp;gt;= y AND x &amp;lt;= z&quot; and works with respect to collating functions as if it were two separate comparisons. The expression &quot;x IN (SELECT y ...)&quot; is handled in the same way as the expression &quot;x = y&quot; for the purposes of determining the collating sequence. The collating sequence used for expressions of the form &quot;x IN (y, z, ...)&quot; is the collating sequence of x. If an explicit collating sequence is required on an IN operator it should be applied to the left operand, like this: &quot;x COLLATE nocase IN (y,z, ...)&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6d1934b411c6401d1051c4d7453826ea7a9843" translate="yes" xml:space="preserve">
          <source>The expression attached to the optional OFFSET clause that may follow a LIMIT clause must also evaluate to an integer, or a value that can be losslessly converted to an integer. If an expression has an OFFSET clause, then the first M rows are omitted from the result set returned by the SELECT statement and the next N rows are returned, where M and N are the values that the OFFSET and LIMIT clauses evaluate to, respectively. Or, if the SELECT would return less than M+N rows if it did not have a LIMIT clause, then the first M rows are skipped and the remaining rows (if any) are returned. If the OFFSET clause evaluates to a negative value, the results are the same as if it had evaluated to zero.</source>
          <target state="translated">附加在可选OFFSET子句上的表达式,在LIMIT子句后面的表达式也必须评估为一个整数,或者一个可以无损转换为整数的值。如果一个表达式有一个OFFSET子句,那么SELECT语句返回的结果集中将省略前M条记录,并返回接下来的N条记录,其中M和N分别是OFFSET子句和LIMIT子句评估的值。或者,如果SELECT没有LIMIT子句的话,返回的记录少于M+N条,那么就跳过前M条记录,返回剩余的记录(如果有的话)。如果OFFSET子句的值为负值,那么结果就和它的值为0一样。</target>
        </trans-unit>
        <trans-unit id="1cd8c2a06181abbb52fb772c5e4393bf493adec9" translate="yes" xml:space="preserve">
          <source>The expression following the WHERE clause may contain operators, literal values, and names of columns in the table being indexed. The WHERE clause may &lt;em&gt;not&lt;/em&gt; contain subqueries, references to other tables, &lt;a href=&quot;deterministic&quot;&gt;non-deterministic functions&lt;/a&gt;, or &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;.</source>
          <target state="translated">WHERE子句后面的表达式可以包含运算符，文字值和要建立索引的表中的列名称。WHERE子句&lt;em&gt;不能&lt;/em&gt;包含子查询，对其他表的引用，&lt;a href=&quot;deterministic&quot;&gt;不确定性函数&lt;/a&gt;或&lt;a href=&quot;lang_expr#varparam&quot;&gt;绑定参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1c1e099acc66b957c91a242e71ab41548df3e15b" translate="yes" xml:space="preserve">
          <source>The expression of a generated column can refer to any of the other declared columns in the table, including other generated columns, as long as the expression does not directly or indirectly refer back to itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cd71176d0cd745c21cb3b1319609677077ace52" translate="yes" xml:space="preserve">
          <source>The expression of a generated column may not directly reference the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;, though it can reference the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column, which is often the same thing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67b0f355cc2989c7cff5a5d8658f4cccd6f86732" translate="yes" xml:space="preserve">
          <source>The expression of a generated column may only reference constant literals and columns within the same row, and may only use scalar &lt;a href=&quot;deterministic&quot;&gt;deterministic functions&lt;/a&gt;. The expression may not use subqueries, aggregate functions, window functions, or table-valued functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3177e05d9fce52b64c04ddd90d24e41132bbd994" translate="yes" xml:space="preserve">
          <source>The expression of a generated column may refer to other generated columns in the same row, but no generated column can depend upon itself, either directly or indirectly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa57007d3af78002775463ea997fdbb172a0c191" translate="yes" xml:space="preserve">
          <source>The extension loading mechanism of SQLite (accessed using the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function) is turned off by default. This is a security precaution. If an application wants to make use of the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; function it must first turn the capability on using this method.</source>
          <target state="translated">默认情况下，SQLite的扩展加载机制（使用&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt; SQL函数访问）是关闭的。这是安全预防措施。如果应用程序要使用&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt;函数，则必须首先使用此方法打开该功能。</target>
        </trans-unit>
        <trans-unit id="bbd9a40496de97ba5cfcabba824166980ee9d8c1" translate="yes" xml:space="preserve">
          <source>The extra write overhead prompted a reexamination of assumptions about powersafe overwrite. With modern disk drives, the capacity has become so large and the data density so great that a single sector is very small and writing a single sector takes very little time. We know that disk drives can detect an impending power loss and continue to operate for some small amount of time on residual energy because those drives are able to park their heads before spinning down. And so if an impending power loss is detectable by the disk controller, it seems reasonable that the controller will finish writing whatever sector it is current working on when the imminent power loss is first detected, prior to parking the heads, as long as doing so does not take too long, which it should not with small and dense sectors. Hence it seems reasonable to assume powersafe overwrite for modern disks. Indeed, BerkeleyDB has made this assumption for decades, we are told. Caution is advised though. As Roger Binns noted on the SQLite developers mailing list: &quot;'poorly written' should be the main assumption about drive firmware.&quot;</source>
          <target state="translated">额外的写入开销促使人们重新审视关于powersafe overwrite的假设。对于现代磁盘驱动器,容量已经变得非常大,数据密度非常大,单个扇区非常小,写入一个扇区需要的时间非常少。我们知道,磁盘驱动器可以检测到即将发生的功率损失,并依靠剩余的能量继续工作一小段时间,因为这些驱动器能够在旋转下来之前停好头。因此,如果磁盘控制器可以检测到即将发生的功率损失,那么控制器在第一次检测到即将发生的功率损失时,会先完成当前正在工作的扇区的写入工作,然后再停放磁头,这似乎是合理的,只要这样做不需要太长的时间,对于小而密集的扇区来说,应该是不会的。因此,假设现代磁盘的powerafe overwrite似乎是合理的。事实上,BerkeleyDB已经做了几十年的假设,我们被告知。不过,我们还是建议大家谨慎行事。正如Roger Binns在SQLite开发者邮件列表中所指出的那样。&quot;'写得不好'应该是硬盘固件的主要假设&quot;</target>
        </trans-unit>
        <trans-unit id="f31765748ec404a72a387c3ce457db0e7fddb3f0" translate="yes" xml:space="preserve">
          <source>The fact that NULLs are distinct for UNIQUE columns but are indistinct for SELECT DISTINCT and UNION continues to be puzzling. It seems that NULLs should be either distinct everywhere or nowhere. And the SQL standards documents suggest that NULLs should be distinct everywhere. Yet as of this writing, no SQL engine tested treats NULLs as distinct in a SELECT DISTINCT statement or in a UNION.</source>
          <target state="translated">NULLs对于UNIQUE列是明确的,但对于SELECT DISTINCT和UNION却不明确,这个事实仍然令人困惑。似乎NULLs应该在任何地方都是不同的,或者在任何地方都是不同的。而SQL标准文档建议,NULLs应该是处处有区别的。然而,截至本文撰写时,没有一个经过测试的SQL引擎在SELECT DISTINCT语句或UNION中把NULLs视为不同的。</target>
        </trans-unit>
        <trans-unit id="36716fd190ed79338836da067e34479b294afa61" translate="yes" xml:space="preserve">
          <source>The fact that SQLite is embedded and &lt;a href=&quot;serverless&quot;&gt;serverless&lt;/a&gt; instead of being client/server is a feature, not a bug.</source>
          <target state="translated">SQLite是嵌入式且&lt;a href=&quot;serverless&quot;&gt;无服务器的，&lt;/a&gt;而不是作为客户端/服务器的，这是一个功能，而不是错误。</target>
        </trans-unit>
        <trans-unit id="893ade2ecf018b089d7d0c2f18f2d37a93397ea0" translate="yes" xml:space="preserve">
          <source>The fifth argument to the BLOB and string binding interfaces is a destructor used to dispose of the BLOB or string after SQLite has finished with it. The destructor is called to dispose of the BLOB or string even if the call to the bind API fails, except the destructor is not called if the third parameter is a NULL pointer or the fourth parameter is negative. If the fifth argument is the special value &lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_STATIC&lt;/a&gt;, then SQLite assumes that the information is in static, unmanaged space and does not need to be freed. If the fifth argument has the value &lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_TRANSIENT&lt;/a&gt;, then SQLite makes its own private copy of the data immediately, before the sqlite3_bind_*() routine returns.</source>
          <target state="translated">BLOB和字符串绑定接口的第五个参数是一个析构函数，用于在SQLite完成后处理BLOB或字符串。即使对绑定API的调用失败，也会调用析构函数来处置BLOB或字符串，但如果第三个参数为NULL指针或第四个参数为负，则不会调用析构函数。如果第五个参数是特殊值&lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_STATIC&lt;/a&gt;，则SQLite假定信息位于静态的非托管空间中，不需要释放。如果第五个参数的值是&lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_TRANSIENT&lt;/a&gt;，则SQLite会在sqlite3_bind _ *（）例程返回之前立即创建其自己的数据私有副本。</target>
        </trans-unit>
        <trans-unit id="e68c8434fb7585b2fc0da0f853455aed19727f06" translate="yes" xml:space="preserve">
          <source>The fifth argument to the BLOB and string binding interfaces is a destructor used to dispose of the BLOB or string after SQLite has finished with it. The destructor is called to dispose of the BLOB or string even if the call to the bind API fails, except the destructor is not called if the third parameter is a NULL pointer or the fourth parameter is negative. If the fifth argument is the special value &lt;a href=&quot;c_static&quot;&gt;SQLITE_STATIC&lt;/a&gt;, then SQLite assumes that the information is in static, unmanaged space and does not need to be freed. If the fifth argument has the value &lt;a href=&quot;c_static&quot;&gt;SQLITE_TRANSIENT&lt;/a&gt;, then SQLite makes its own private copy of the data immediately, before the sqlite3_bind_*() routine returns.</source>
          <target state="translated">BLOB和字符串绑定接口的第五个参数是一个析构函数，用于在SQLite完成后处理BLOB或字符串。即使对绑定API的调用失败，也会调用析构函数来处置BLOB或字符串，但如果第三个参数为NULL指针或第四个参数为负，则不会调用析构函数。如果第五个参数是特殊值&lt;a href=&quot;c_static&quot;&gt;SQLITE_STATIC&lt;/a&gt;，则SQLite假定信息位于静态的非托管空间中，不需要释放。如果第五个参数的值是&lt;a href=&quot;c_static&quot;&gt;SQLITE_TRANSIENT&lt;/a&gt;，则SQLite会在sqlite3_bind _ *（）例程返回之前立即创建其自己的数据私有副本。</target>
        </trans-unit>
        <trans-unit id="901b5e438fd14b98c5489ac30117b7e4f79582ec" translate="yes" xml:space="preserve">
          <source>The fifth argument, xCallback, is a pointer to the collating function. Multiple collating functions can be registered using the same name but with different eTextRep parameters and SQLite will use whichever function requires the least amount of data transformation. If the xCallback argument is NULL then the collating function is deleted. When all collating functions having the same name are deleted, that collation is no longer usable.</source>
          <target state="translated">第五个参数xCallback是指向整理函数的指针。多个整理函数可以使用相同的名称注册,但有不同的eTextRep参数,SQLite将使用任何一个需要最少数据转换的函数。如果xCallback参数为NULL,那么整理函数将被删除。当所有具有相同名称的整理函数被删除时,该整理函数就不再可用。</target>
        </trans-unit>
        <trans-unit id="9b66d05a972406caa6b8e66ca673681eea81f8a6" translate="yes" xml:space="preserve">
          <source>The fifth argument, xCompare, is a pointer to the collating function. Multiple collating functions can be registered using the same name but with different eTextRep parameters and SQLite will use whichever function requires the least amount of data transformation. If the xCompare argument is NULL then the collating function is deleted. When all collating functions having the same name are deleted, that collation is no longer usable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a3d71778e0851af7f19eb98c05ebd04280b893c" translate="yes" xml:space="preserve">
          <source>The fifth parameter is an arbitrary pointer. The implementation of the function can gain access to this pointer using &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;.</source>
          <target state="translated">第五个参数是任意指针。该函数的实现可以使用&lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data（）&lt;/a&gt;来访问此指针。</target>
        </trans-unit>
        <trans-unit id="8991c375d182bf0ed874e01ceb3c3fba4c90a4d1" translate="yes" xml:space="preserve">
          <source>The fifth parameter is an arbitrary pointer. The implementation of the function can gain access to this pointer using &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;.</source>
          <target state="translated">第五个参数是任意指针。该函数的实现可以使用&lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data（）&lt;/a&gt;来访问此指针。</target>
        </trans-unit>
        <trans-unit id="8b5fa94425e25711d656d2caafbaef27474f2b42" translate="yes" xml:space="preserve">
          <source>The file I/O implementation can use the object type flags to change the way it deals with files. For example, an application that does not care about crash recovery or rollback might make the open of a journal file a no-op. Writes to this journal would also be no-ops, and any attempt to read the journal would return SQLITE_IOERR. Or the implementation might recognize that a database file will be doing page-aligned sector reads and writes in a random order and set up its I/O subsystem accordingly.</source>
          <target state="translated">文件I/O实现可以使用对象类型标志来改变它处理文件的方式。例如,一个不关心崩溃恢复或回滚的应用程序可能会将打开一个日志文件的操作定为no-op,对这个日志文件的写入也是no-op,任何读取日志的尝试都会返回SQLITE_IOERR。对这个日志文件的写入也是no-op,任何读取日志的尝试都会返回SQLITE_IOERR。或者实现可能会认识到数据库文件将以随机顺序进行页对齐扇区读写,并据此设置其I/O子系统。</target>
        </trans-unit>
        <trans-unit id="2ace627b4eb1891a06a62ee2e61523c0922ec242" translate="yes" xml:space="preserve">
          <source>The file I/O implementation can use the object type flags to changes the way it deals with files. For example, an application that does not care about crash recovery or rollback, might make the open of a journal file a no-op. Writes to this journal are also a no-op. Any attempt to read the journal returns &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;. Or the implementation might recognize the a database file will be doing page-aligned sector reads and writes in a random order and set up its I/O subsystem accordingly. SQLite might also add one of the following flags to the xOpen method:</source>
          <target state="translated">文件I / O实现可以使用对象类型标志来更改其处理文件的方式。例如，一个不关心崩溃恢复或回滚的应用程序可能使打开日记文件成为无操作。禁止向该期刊写信。任何尝试读取日记的尝试都将返回&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;。或者实现可能会认识到数据库文件将以随机顺序进行页面对齐的扇区读取和写入，并相应地设置其I / O子系统。SQLite可能还会向xOpen方法添加以下标志之一：</target>
        </trans-unit>
        <trans-unit id="339116ded6000b1bbd01c16fbc4b426fdbec3ebf" translate="yes" xml:space="preserve">
          <source>The file change counter is a 4-byte big-endian integer at offset 24 that is incremented whenever the database file is unlocked after having been modified. When two or more processes are reading the same database file, each process can detect database changes from other processes by monitoring the change counter. A process will normally want to flush its database page cache when another process modified the database, since the cache has become stale. The file change counter facilitates this.</source>
          <target state="translated">文件更改计数器是一个偏移量为24的4字节的大字节整数,每当数据库文件被修改后解锁时,该计数器就会递增。当两个或多个进程在读取同一个数据库文件时,每个进程都可以通过监视变化计数器来检测其他进程的数据库变化。当另一个进程修改了数据库时,一个进程通常会希望刷新它的数据库页面缓存,因为缓存已经失效了。文件变更计数器可以方便地实现这一点。</target>
        </trans-unit>
        <trans-unit id="3144a807afc9a81e0cce3e084ad085692d9830bb" translate="yes" xml:space="preserve">
          <source>The file format can be extended in future releases simply by adding new tables and/or column, preserving backwards compatibility.</source>
          <target state="translated">该文件格式可以在未来的版本中通过添加新的表格和/或列来扩展,保持向后的兼容性。</target>
        </trans-unit>
        <trans-unit id="e6aaed4a8d57b71607b8967869bcc7f23189ec3d" translate="yes" xml:space="preserve">
          <source>The file format for indices was changed slightly in order to work around an inefficiency that can sometimes come up with GDBM when there are large indices having many entries with the same key. ** Incompatible Change **</source>
          <target state="translated">指数的文件格式略有改变,以解决GDBM有时会出现的效率低下的问题,当有许多条目具有相同的键时,就会出现这种情况。**不兼容的改变 **</target>
        </trans-unit>
        <trans-unit id="227aafe2527e84f2018568e74a1b6b84889b7a1b" translate="yes" xml:space="preserve">
          <source>The file format write version and file format read version at offsets 18 and 19 are intended to allow for enhancements of the file format in future versions of SQLite. In current versions of SQLite, both of these values are 1 for rollback journalling modes and 2 for &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; journalling mode. If a version of SQLite coded to the current file format specification encounters a database file where the read version is 1 or 2 but the write version is greater than 2, then the database file must be treated as read-only. If a database file with a read version greater than 2 is encountered, then that database cannot be read or written.</source>
          <target state="translated">偏移量18和19处的文件格式写入版本和文件格式读取版本旨在允许在将来的SQLite版本中增强文件格式。在当前版本的SQLite中，对于回滚日志记录模式，这两个值均为1；对于&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;日志记录模式，这两个值均为2 。如果编码为当前文件格式规范的SQLite版本遇到读取版本为1或2但写入版本大于2的数据库文件，则必须将该数据库文件视为只读。如果遇到读取版本大于2的数据库文件，则无法读取或写入该数据库。</target>
        </trans-unit>
        <trans-unit id="57007ced430f8a0cf3127ebbd04af2dceb5d897b" translate="yes" xml:space="preserve">
          <source>The file-handle open on the</source>
          <target state="translated">打开的文件柄上的</target>
        </trans-unit>
        <trans-unit id="b75893e55d63ac0a30441dba63c6c7335b33555b" translate="yes" xml:space="preserve">
          <source>The file-system</source>
          <target state="translated">文件系统</target>
        </trans-unit>
        <trans-unit id="e3cc87e79b2a7545d431775230c50e5146077116" translate="yes" xml:space="preserve">
          <source>The filename can be interpreted as a URI if this flag is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1f230eea69094b4593dd99813cb077b78f99716" translate="yes" xml:space="preserve">
          <source>The filename for the database to be attached is the value of the expression that occurs before the AS keyword. The filename of the database follows the same semantics as the filename argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;; the special name &quot;&lt;a href=&quot;inmemorydb&quot;&gt;:memory:&lt;/a&gt;&quot; results in an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; and an empty string results in a new temporary database. The filename argument can be a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; if URI filename processing is enable on the database connection. The default behavior is for URI filenames to be disabled, however that might change in a future release of SQLite, so application developers are advised to plan accordingly.</source>
          <target state="translated">要附加的数据库的文件名是在AS关键字之前出现的表达式的值。数据库的文件名与&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;和&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;的filename参数具有相同的语义；特殊名称&amp;ldquo; &lt;a href=&quot;inmemorydb&quot;&gt;：memory：&lt;/a&gt; &amp;rdquo;将导致&lt;a href=&quot;inmemorydb&quot;&gt;内存数据库，&lt;/a&gt;而空字符串将导致新的临时数据库。如果在数据库连接上启用了&lt;a href=&quot;uri&quot;&gt;URI文件&lt;/a&gt;名处理，则filename参数可以是URI文件名。默认行为是禁用URI文件名，但是在将来的SQLite版本中可能会更改，因此建议应用程序开发人员进行相应的计划。</target>
        </trans-unit>
        <trans-unit id="f17e1c0d84ff3c2fe25d0856ea88c3fbd19c5fb1" translate="yes" xml:space="preserve">
          <source>The filename in the INTO clause can be an arbitrary SQL expression that evaluates to a string. The file named by the INTO clause must not previously exist, or else it must be an empty file, or the VACUUM INTO command will fail with an error.</source>
          <target state="translated">INTO子句中的文件名可以是一个任意的SQL表达式,它的值是一个字符串。INTO子句命名的文件必须是之前不存在的,否则必须是一个空文件,否则VACUUM INTO命令会出错而失败。</target>
        </trans-unit>
        <trans-unit id="d4df05c7fc29b7702e9fa3ab7eeeb629cbcad3f5" translate="yes" xml:space="preserve">
          <source>The filename returned by this function is the output of the xFullPathname method of the &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt;. In other words, the filename will be an absolute pathname, even if the filename used to open the database originally was a URI or relative pathname.</source>
          <target state="translated">此函数返回的文件名是&lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt;的xFullPathname方法的输出。换句话说，即使最初用于打开数据库的文件名是URI或相对路径名，文件名也将是绝对路径名。</target>
        </trans-unit>
        <trans-unit id="9485b160522d31184c8916615322f5219f0612b8" translate="yes" xml:space="preserve">
          <source>The filename returned by this function is the output of the xFullPathname method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. In other words, the filename will be an absolute pathname, even if the filename used to open the database originally was a URI or relative pathname.</source>
          <target state="translated">此函数返回的文件名是&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;的xFullPathname方法的输出。换句话说，即使最初用于打开数据库的文件名是URI或相对路径名，文件名也将是绝对路径名。</target>
        </trans-unit>
        <trans-unit id="fc318f399f5ecbc4db919258057f39b26883fdf3" translate="yes" xml:space="preserve">
          <source>The final answer is found by looking for a string with ind==0. If the original sudoku problem did not have a unique solution, then the query will return all possible solutions. If the original problem was unsolvable, then no rows will be returned. In this case, the unique answer is:</source>
          <target state="translated">通过寻找ind==0的字符串来找到最终的答案,如果原始数独问题没有唯一的解,那么查询将返回所有可能的解。如果原来的问题是无法解决的,那么将不返回任何行。在这种情况下,唯一的答案是。</target>
        </trans-unit>
        <trans-unit id="0fa7031611bf07c03077958f2b8ed29a77590306" translate="yes" xml:space="preserve">
          <source>The final argument is an output variable. If successful, (*ppOut) should be set to point to the new tokenizer handle and SQLITE_OK returned. If an error occurs, some value other than SQLITE_OK should be returned. In this case, fts5 assumes that the final value of *ppOut is undefined.</source>
          <target state="translated">最后一个参数是一个输出变量。如果成功,(*ppOut)应该被设置为指向新的标记器句柄,并返回SQLITE_OK。如果发生错误,应该返回SQLITE_OK以外的其他值。在这种情况下,fts5假设*ppOut的最终值是未定义的。</target>
        </trans-unit>
        <trans-unit id="3adcbd65298a5982e7a64803692e07245861c301" translate="yes" xml:space="preserve">
          <source>The final byte of an encoded FTS varint has its most significant bit cleared. All preceding bytes have the most significant bit set. Data is stored in the remaining seven least significant bits of each byte. The first byte of the encoded representation contains the least significant seven bits of the encoded integer value. The second byte of the encoded representation, if it is present, contains the seven next least significant bits of the integer value, and so on. The following table contains examples of encoded integer values:</source>
          <target state="translated">编码后的FTS varint的最后一个字节的最重要的位被清除。所有前面的字节都设置了最有意义的位。数据被存储在每个字节的剩余7个最不重要的位中。编码表示的第一个字节包含编码整数值的最不重要的七个位。编码表示的第二个字节(如果存在的话)包含整数值的下七个最小有效位,以此类推。下表包含编码整数值的例子。</target>
        </trans-unit>
        <trans-unit id="c65b7966b6f5867eece6741b751cabc0c349ca6a" translate="yes" xml:space="preserve">
          <source>The final line of the example (the &quot;.system c:/work/dataout.csv&quot;) has the same effect as double-clicking on the c:/work/dataout.csv file in windows. This will typically bring up a spreadsheet program to display the CSV file.</source>
          <target state="translated">例子的最后一行(&quot;.system c:/work/dataout.csv&quot;)与在windows中双击c:/work/dataout.csv文件的效果相同。这通常会弹出一个电子表格程序来显示CSV文件。</target>
        </trans-unit>
        <trans-unit id="312ab3f0c70e0337ccdf666710177cbb51a2f6d3" translate="yes" xml:space="preserve">
          <source>The final query in the block above may not work as expected. Because the &quot;*&quot; character is inside the double-quotes, it will be passed to the tokenizer, which will likely discard it (or perhaps, depending on the specific tokenizer in use, include it as part of the final token) instead of recognizing it as a special FTS character.</source>
          <target state="translated">上面代码块中的最后一个查询可能不会像预期的那样工作。由于 &quot;*&quot;字符位于双引号内,因此它将被传递给标记器,标记器可能会丢弃它(或者根据使用的特定标记器,可能会将其作为最终标记的一部分),而不是将其识别为一个特殊的 FTS 字符。</target>
        </trans-unit>
        <trans-unit id="a564ec7adef18f2e787e1258b9aed3803202963e" translate="yes" xml:space="preserve">
          <source>The final recovery step is to reduce the exclusive lock back to a shared lock. Once this happens, the database is back in the state that it would have been if the aborted transaction had never started. Since all of this recovery activity happens completely automatically and transparently, it appears to the program using SQLite as if the aborted transaction had never begun.</source>
          <target state="translated">最后的恢复步骤是将独占锁还原为共享锁。一旦发生这种情况,数据库就回到了被中止的事务从未开始时的状态。由于所有这些恢复活动都是完全自动和透明地发生的,所以在使用SQLite的程序中,它看起来就像被中止的事务从未开始过一样。</target>
        </trans-unit>
        <trans-unit id="434e32f7c5be2c22a40571665c3031a75ce803d2" translate="yes" xml:space="preserve">
          <source>The final source of large memory allocations is the space to hold the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; that result from compiling complex SQL operations. Ongoing work by the SQLite developers is reducing the amount of space required here. But large and complex queries might still require &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; that are several kilobytes in size. The only workaround at the moment is for the application to break complex SQL operations up into two or more smaller and simpler operations contained in separate &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;.</source>
          <target state="translated">大内存分配的最终来源是用于保存由于编译复杂的SQL操作而产生的&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;的空间。 SQLite开发人员正在进行的工作正在减少此处所需的空间。但是大型和复杂的查询可能仍然需要大小为几千字节的&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;。目前，唯一的解决方法是应用程序将复杂的SQL操作分解为两个或更多的更小的，更简单的操作，这些操作包含在单独的&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e5be990568c2b06d13617fdb20a3f4473d59b9c" translate="yes" xml:space="preserve">
          <source>The final step in a multi-file commit is to delete the individual rollback journals and drop the exclusive locks on the database files so that other processes can see the changes. This corresponds to &lt;a href=&quot;#section_3_12&quot;&gt;step 3.12&lt;/a&gt; in the single-file commit sequence.</source>
          <target state="translated">多文件提交的最后一步是删除单个回滚日志，并删除数据库文件上的排他锁，以便其他进程可以看到更改。这对应于单文件提交序列中的&lt;a href=&quot;#section_3_12&quot;&gt;步骤3.12&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="570119a07afaf61a9f20cf9abd68b217ebf33834" translate="yes" xml:space="preserve">
          <source>The final three arguments passed to the auxiliary function callback are similar to the three arguments passed to the implementation of a scalar SQL function. All arguments except the first passed to the auxiliary function are available to the implementation in the apVal[] array. The implementation should return a result or error via the content handle pCtx.</source>
          <target state="translated">传递给辅助函数回调的最后三个参数与传递给标量SQL函数实现的三个参数类似。除了传递给辅助函数的第一个参数之外,所有的参数都可以在apVal[]数组中被实现。实现应该通过内容句柄pCtx返回一个结果或错误。</target>
        </trans-unit>
        <trans-unit id="72acf6716754df5bf7660108439b7caacc7e6afa" translate="yes" xml:space="preserve">
          <source>The first 100 bytes of the database file comprise the database file header. The database file header is divided into fields as shown by the table below. All multibyte fields in the database file header are stored with the most significant byte first (big-endian).</source>
          <target state="translated">数据库文件的前100个字节由数据库文件头组成。数据库文件头被划分为如下表所示的字段。数据库文件头中的所有多字节字段都是以最重要的字节为先(big-endian)进行存储。</target>
        </trans-unit>
        <trans-unit id="7ad8baeb9b6a7d25df8e53c7bba57a3b07d6a12e" translate="yes" xml:space="preserve">
          <source>The first 136 bytes of the shm file are a header. The shm header has three main divisions as follows:</source>
          <target state="translated">shm文件的前136个字节是一个头。shm文件头有以下三个主要部分:</target>
        </trans-unit>
        <trans-unit id="32a4d848523b5982a35dd9ccae2a5e300c48ac95" translate="yes" xml:space="preserve">
          <source>The first 8 bytes of the</source>
          <target state="translated">前8个字节的</target>
        </trans-unit>
        <trans-unit id="31e639e14579d85dee4c60a5aeaa903eaa1984f2" translate="yes" xml:space="preserve">
          <source>The first argument must be the sqlite3_index_info object that is the first parameter to the xBestIndex() method. The second argument must be an index into the aConstraint[] array belonging to the sqlite3_index_info structure passed to xBestIndex. This function returns a pointer to a buffer containing the name of the collation sequence for the corresponding constraint.</source>
          <target state="translated">第一个参数必须是 sqlite3_index_info 对象,它是 xBestIndex()方法的第一个参数。第二个参数必须是属于传递给xBestIndex的sqlite3_index_info结构的aConstraint[]数组的索引。这个函数返回一个指向缓冲区的指针,缓冲区中包含对应约束的整理序列名称。</target>
        </trans-unit>
        <trans-unit id="756a3aef230a7b2fc01840e9c05f1d8a68c861b7" translate="yes" xml:space="preserve">
          <source>The first argument passed should be the database handle to register the extension with. The second and third arguments should both be passed 0.</source>
          <target state="translated">传递的第一个参数应该是要注册扩展的数据库句柄,第二个和第三个参数都应该传递0。第二个和第三个参数都应该是0。</target>
        </trans-unit>
        <trans-unit id="7fa580625e479f237836af3af275aa2f6a47351d" translate="yes" xml:space="preserve">
          <source>The first argument passed to an auxiliary function callback is a pointer to a structure containing methods that may be invoked in order to obtain information regarding the current query or row. The second argument is an opaque handle that should be passed as the first argument to any such method invocation. For example, the following auxiliary function definition returns the total number of tokens in all columns of the current row:</source>
          <target state="translated">传递给辅助函数回调的第一个参数是指向一个结构的指针,该结构包含了可以被调用的方法,以便获得有关当前查询或行的信息。第二个参数是一个不透明的句柄,它应该作为任何此类方法调用的第一个参数传递。例如,下面的辅助函数定义返回当前行的所有列中的标记总数。</target>
        </trans-unit>
        <trans-unit id="d4428415829da9afdeca7abddd54df2e62906cce" translate="yes" xml:space="preserve">
          <source>The first argument passed to this function is a copy of the (void*) pointer provided by the application when the fts5_tokenizer object was registered with FTS5 (the third argument to xCreateTokenizer()). The second and third arguments are an array of nul-terminated strings containing the tokenizer arguments, if any, specified following the tokenizer name as part of the CREATE VIRTUAL TABLE statement used to create the FTS5 table.</source>
          <target state="translated">传递给该函数的第一个参数是在FTS5注册fts5_tokenizer对象时,应用程序提供的(void*)指针的副本(xCreateTokenizer()的第三个参数)。第二个和第三个参数是一个无结尾的字符串数组,包含了tokenizer参数(如果有的话),这些参数是在创建FTS5表的CREATE VIRTUAL TABLE语句中指定的。</target>
        </trans-unit>
        <trans-unit id="3ddc48958f41facca8a1ecdc60ac948a59cb2349" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; must be the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; pointer as the first parameter to this method. The second argument to &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; must a zero-terminated UTF-8 string that contains a well-formed &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement that defines the columns in the virtual table and their data types. The name of the table in this CREATE TABLE statement is ignored, as are all constraints. Only the column names and datatypes matter. The CREATE TABLE statement string need not to be held in persistent memory. The string can be deallocated and/or reused as soon as the &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; routine returns.</source>
          <target state="translated">的第一个参数&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt;必须是相同的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;的指针作为第一个参数，以这种方法。&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt;的第二个参数必须为零结尾的UTF-8字符串，其中包含格式正确的&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句，该语句定义虚拟表中的列及其数据类型。与所有约束一样，此CREATE TABLE语句中的表名将被忽略。仅列名称和数据类型很重要。 CREATE TABLE语句字符串不需要保存在持久性内存中。&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt;例程返回后，可以立即释放和/或重用该字符串。</target>
        </trans-unit>
        <trans-unit id="1aed5522193a69fc6ff8aa89cff3e41266a3f600" translate="yes" xml:space="preserve">
          <source>The first argument to all three special SQL scalar functions must be the &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; of the FTS table that the function is applied to. The &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; is an automatically-generated column found on all FTS tables that has the same name as the FTS table itself. For example, given an FTS table named &quot;mail&quot;:</source>
          <target state="translated">这三个特殊SQL标量函数的第一个参数必须是该函数所应用的FTS表的&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS隐藏列&lt;/a&gt;。该&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS隐藏的列&lt;/a&gt;是具有相同的名称作为FTS表本身的所有FTS表中找到一个自动生成的列。例如，给定一个名为&amp;ldquo; mail&amp;rdquo;的FTS表：</target>
        </trans-unit>
        <trans-unit id="952294bca557c59738bac0e545034c52a263067f" translate="yes" xml:space="preserve">
          <source>The first argument to sqlite3_config() is an integer &lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;configuration option&lt;/a&gt; that determines what property of SQLite is to be configured. Subsequent arguments vary depending on the &lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;configuration option&lt;/a&gt; in the first argument.</source>
          <target state="translated">sqlite3_config（）的第一个参数是整数&lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;配置选项&lt;/a&gt;，该选项确定要配置SQLite的属性。后续参数根据第一个参数中的&lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;配置选项&lt;/a&gt;而有所不同。</target>
        </trans-unit>
        <trans-unit id="f875f5d7c01e9a29524328575e142babf2bae3ae" translate="yes" xml:space="preserve">
          <source>The first argument to sqlite3_config() is an integer &lt;a href=&quot;c_config_covering_index_scan&quot;&gt;configuration option&lt;/a&gt; that determines what property of SQLite is to be configured. Subsequent arguments vary depending on the &lt;a href=&quot;c_config_covering_index_scan&quot;&gt;configuration option&lt;/a&gt; in the first argument.</source>
          <target state="translated">sqlite3_config（）的第一个参数是整数&lt;a href=&quot;c_config_covering_index_scan&quot;&gt;配置选项&lt;/a&gt;，该选项确定要配置SQLite的属性。后续参数根据第一个参数中的&lt;a href=&quot;c_config_covering_index_scan&quot;&gt;配置选项&lt;/a&gt;而有所不同。</target>
        </trans-unit>
        <trans-unit id="3f0ed77e9965fa2c39bb9cbb993108ef55b7d05b" translate="yes" xml:space="preserve">
          <source>The first argument to the busy handler is a copy of the void* pointer which is the third argument to sqlite3_busy_handler(). The second argument to the busy handler callback is the number of times that the busy handler has been invoked previously for the same locking event. If the busy callback returns 0, then no additional attempts are made to access the database and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the application. If the callback returns non-zero, then another attempt is made to access the database and the cycle repeats.</source>
          <target state="translated">繁忙处理程序的第一个参数是void *指针的副本，该指针是sqlite3_busy_handler（）的第三个参数。繁忙处理程序回调的第二个参数是先前为同一锁定事件调用繁忙处理程序的次数。如果忙碌回调返回0，则不进行其他尝试访问数据库，并且&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;返回到应用程序。如果回调返回非零值，则将再次尝试访问数据库，并重复该循环。</target>
        </trans-unit>
        <trans-unit id="73aa47dd980f8a887b15a2decc4e912f8fd4e328" translate="yes" xml:space="preserve">
          <source>The first argument to the busy handler is a copy of the void* pointer which is the third argument to sqlite3_busy_handler(). The second argument to the busy handler callback is the number of times that the busy handler has been invoked previously for the same locking event. If the busy callback returns 0, then no additional attempts are made to access the database and &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the application. If the callback returns non-zero, then another attempt is made to access the database and the cycle repeats.</source>
          <target state="translated">繁忙处理程序的第一个参数是void *指针的副本，该指针是sqlite3_busy_handler（）的第三个参数。繁忙处理程序回调的第二个参数是先前为同一锁定事件调用繁忙处理程序的次数。如果忙碌回调返回0，则不进行其他尝试访问数据库，并且&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;返回到应用程序。如果回调返回非零值，则将再次尝试访问数据库，并重复该循环。</target>
        </trans-unit>
        <trans-unit id="395ff21e8cf7b4d90e5bc3764e07164a7c24e72d" translate="yes" xml:space="preserve">
          <source>The first argument to the callback is just a copy of the fourth argument to &lt;b&gt;sqlite_exec&lt;/b&gt; This parameter can be used to pass arbitrary information through to the callback function from client code. The second argument is the number of columns in the query result. The third argument is an array of pointers to strings where each string is a single column of the result for that record. Note that the callback function reports a NULL value in the database as a NULL pointer, which is very different from an empty string. If the i-th parameter is an empty string, we will get:</source>
          <target state="translated">回调的第一个参数只是&lt;b&gt;sqlite_exec&lt;/b&gt;的第四个参数的副本。此参数可用于将任意信息从客户端代码传递到回调函数。第二个参数是查询结果中的列数。第三个参数是指向字符串的指针数组，其中每个字符串是该记录的结果的单列。请注意，回调函数将数据库中的NULL值报告为NULL指针，这与空字符串有很大不同。如果第i个参数为空字符串，我们将得到：</target>
        </trans-unit>
        <trans-unit id="19ed31ae74a9a14120db33894759ec36b8a3df0f" translate="yes" xml:space="preserve">
          <source>The first argument to the snippet function must always be the &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; of the FTS table being queried and from which the snippet is to be taken. The &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; is an automatically generated column with the same name as the FTS table itself.</source>
          <target state="translated">片段功能的第一个参数必须始终是要查询的FTS表的&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS隐藏列&lt;/a&gt;，并从中获取该片段。所述&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS隐藏的列&lt;/a&gt;是具有相同名称为FTS表本身自动生成的列。</target>
        </trans-unit>
        <trans-unit id="a3c117d3156af5d9687ce63c9ca2baca71f1029c" translate="yes" xml:space="preserve">
          <source>The first argument to the sqlite3_bind_*() routines is always a pointer to the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object returned from &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or its variants.</source>
          <target state="translated">sqlite3_bind _ *（）例程的第一个参数始终是指向从&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或其变体返回的&lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;对象的指针。</target>
        </trans-unit>
        <trans-unit id="e62bb2c9601439134c1919cc9d703235a3e8dcf1" translate="yes" xml:space="preserve">
          <source>The first argument to the sqlite3_bind_*() routines is always a pointer to the &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object returned from &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or its variants.</source>
          <target state="translated">sqlite3_bind _ *（）例程的第一个参数始终是指向从&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或其变体返回的&lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;对象的指针。</target>
        </trans-unit>
        <trans-unit id="4376fc02622bfe056753a887d840cb5de850cf76" translate="yes" xml:space="preserve">
          <source>The first argument to the sqlite3session_config() function must be one of the SQLITE_SESSION_CONFIG_XXX constants defined below. The interpretation of the (void*) value passed as the second parameter and the effect of calling this function depends on the value of the first parameter.</source>
          <target state="translated">sqlite3session_config()函数的第一个参数必须是下面定义的SQLITE_SESSION_CONFIG_XXX常量之一。作为第二个参数传递的(void*)值的解释和调用该函数的效果取决于第一个参数的值。</target>
        </trans-unit>
        <trans-unit id="46628205e32bedcd53350a6840ee825a63d42391" translate="yes" xml:space="preserve">
          <source>The first argument to these interfaces is a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. These functions return information about the Nth result column returned by the statement, where N is the second function argument. The left-most column is column 0 for these routines.</source>
          <target state="translated">这些接口的第一个参数是&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;。这些函数返回有关语句返回的第N个结果列的信息，其中N是第二个函数参数。这些例程的最左列是第0列。</target>
        </trans-unit>
        <trans-unit id="0f76a71e763d5bd4fbae26e4a6f14b3c938ceb32" translate="yes" xml:space="preserve">
          <source>The first argument to these interfaces is a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. These functions return information about the Nth result column returned by the statement, where N is the second function argument. The left-most column is column 0 for these routines.</source>
          <target state="translated">这些接口的第一个参数是&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;。这些函数返回有关语句返回的第N个结果列的信息，其中N是第二个函数参数。这些例程的最左列是第0列。</target>
        </trans-unit>
        <trans-unit id="a5ff723764d00dd9ac3f381e3bed0a1f08296ed5" translate="yes" xml:space="preserve">
          <source>The first argument, &quot;db&quot;, is a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; obtained from a prior successful call to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;. The database connection must not have been closed.</source>
          <target state="translated">第一个参数&amp;ldquo; db&amp;rdquo;是从先前成功调用&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16（）&lt;/a&gt;获得的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;。数据库连接必须尚未关闭。</target>
        </trans-unit>
        <trans-unit id="691e78895187de6910913a151c966bb350230789" translate="yes" xml:space="preserve">
          <source>The first argument, &quot;db&quot;, is a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; obtained from a prior successful call to &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; or &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;. The database connection must not have been closed.</source>
          <target state="translated">第一个参数&amp;ldquo; db&amp;rdquo;是从先前成功调用&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;或&lt;a href=&quot;open&quot;&gt;sqlite3_open16（）&lt;/a&gt;获得的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;。数据库连接必须尚未关闭。</target>
        </trans-unit>
        <trans-unit id="5da926bf27ba88ce6fa226bb8489971c4b0badd1" translate="yes" xml:space="preserve">
          <source>The first attempt at closing security gaps in pointer passing was to prevent pointer values from being forged. This was accomplished by having the sender attach a subtype to each pointer using &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; and having the receiver verify that subtype using &lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; and reject pointers that had an incorrect subtype. Since there is no way to attach a subtype to a result using pure SQL, this prevents pointers from being forged using SQL. The only way to send a pointer is to use C code. If an attacker can set a subtype, then he is also able to forge a pointer without the help of SQLite.</source>
          <target state="translated">缩小指针传递中的安全间隔的首次尝试是防止伪造指针值。这是通过使发送者使用&lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype（）&lt;/a&gt;将子类型附加到每个指针，并让接收者使用&lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype（）&lt;/a&gt;验证该子类型并拒绝具有不正确子类型的指针来实现的。由于无法使用纯SQL将子类型附加到结果，因此可以防止使用SQL伪造指针。发送指针的唯一方法是使用C代码。如果攻击者可以设置子类型，那么他也可以在没有SQLite帮助的情况下伪造指针。</target>
        </trans-unit>
        <trans-unit id="b3f912cc569c0361b5c2cd2202f03f7409e6b0b1" translate="yes" xml:space="preserve">
          <source>The first beta release for SQLite 3.0.</source>
          <target state="translated">SQLite 3.0的第一个测试版本。</target>
        </trans-unit>
        <trans-unit id="85577f9e39e1e56bdcef30a17afd1e7fd9d77720" translate="yes" xml:space="preserve">
          <source>The first byte of the header is a flag byte. The least significant bit of the flag byte determines whether the coordinate pairs that follow the header are stored big-endian or little-endian. A value of 0 for the least significant bit means big-endian and a value of 1 means little endian. Other bits of the first byte in the header are reserved for future expansion.</source>
          <target state="translated">头部的第一个字节是标志字节。标志字节的最不重要的位决定了跟在标题后面的坐标对是存储在大恩迪安还是小恩迪安。最小有效位的值为0表示大恩典,值为1表示小恩典。标头中第一个字节的其他位是为将来的扩展保留的。</target>
        </trans-unit>
        <trans-unit id="f63d26f2f4bc609cd955a5edef912da4a0a9006c" translate="yes" xml:space="preserve">
          <source>The first call to &lt;a href=&quot;session/sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; on the iterator moves it to point to the first change in the changeset (or to EOF, if the changeset is completely empty). sqlite3changeset_next() returns SQLITE_ROW if it moves the iterator to point to a valid entry, SQLITE_DONE if it moves the iterator to EOF, or an SQLite error code if an error occurs.</source>
          <target state="translated">对迭代器上的&lt;a href=&quot;session/sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）&lt;/a&gt;的首次调用将其移至指向变更集中的第一个变更（如果变更集完全为空，则指向EOF）。如果sqlite3changeset_next（）将迭代器移至指向有效条目，则返回SQLITE_ROW；如果将迭代器移至EOF，则返回SQLITE_DONE；如果发生错误，则返回SQLite错误代码。</target>
        </trans-unit>
        <trans-unit id="261c910c7fa661af930e1c363bad2fff3671bdea" translate="yes" xml:space="preserve">
          <source>The first call to sqlite3_backup_step() obtains an exclusive lock on the destination file. The exclusive lock is not released until either sqlite3_backup_finish() is called or the backup operation is complete and sqlite3_backup_step() returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. Every call to sqlite3_backup_step() obtains a &lt;a href=&quot;lockingv3#shared_lock&quot;&gt;shared lock&lt;/a&gt; on the source database that lasts for the duration of the sqlite3_backup_step() call. Because the source database is not locked between calls to sqlite3_backup_step(), the source database may be modified mid-way through the backup process. If the source database is modified by an external process or via a database connection other than the one being used by the backup operation, then the backup will be automatically restarted by the next call to sqlite3_backup_step(). If the source database is modified by the using the same database connection as is used by the backup operation, then the backup database is automatically updated at the same time.</source>
          <target state="translated">首次调用sqlite3_backup_step（）会获得目标文件的排他锁。在调用sqlite3_backup_finish（）或备份操作完成并且sqlite3_backup_step（）返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;之前，不释放排他锁。每次调用sqlite3_backup_step（）都会获得一个&lt;a href=&quot;lockingv3#shared_lock&quot;&gt;共享锁&lt;/a&gt;在sqlite3_backup_step（）调用期间持续存在的源数据库上。因为在两次调用sqlite3_backup_step（）之间未锁定源数据库，所以可以在备份过程中途修改源数据库。如果源数据库是通过外部过程或通过数据库连接修改的，而不是通过备份操作使用的数据库连接修改的，则备份将在下一次调用sqlite3_backup_step（）时自动重新启动。如果通过使用与备份操作相同的数据库连接来修改源数据库，则备份数据库将同时自动更新。</target>
        </trans-unit>
        <trans-unit id="57eb736cb2a536a07c53b0e0f817765662d0da0a" translate="yes" xml:space="preserve">
          <source>The first call to sqlite3_backup_step() obtains an exclusive lock on the destination file. The exclusive lock is not released until either sqlite3_backup_finish() is called or the backup operation is complete and sqlite3_backup_step() returns &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. Every call to sqlite3_backup_step() obtains a &lt;a href=&quot;../lockingv3#shared_lock&quot;&gt;shared lock&lt;/a&gt; on the source database that lasts for the duration of the sqlite3_backup_step() call. Because the source database is not locked between calls to sqlite3_backup_step(), the source database may be modified mid-way through the backup process. If the source database is modified by an external process or via a database connection other than the one being used by the backup operation, then the backup will be automatically restarted by the next call to sqlite3_backup_step(). If the source database is modified by the using the same database connection as is used by the backup operation, then the backup database is automatically updated at the same time.</source>
          <target state="translated">首次调用sqlite3_backup_step（）会获得目标文件的排他锁。在调用sqlite3_backup_finish（）或备份操作完成并且sqlite3_backup_step（）返回&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;之前，不释放排他锁。每次调用sqlite3_backup_step（）都会获得一个&lt;a href=&quot;../lockingv3#shared_lock&quot;&gt;共享锁&lt;/a&gt;在sqlite3_backup_step（）调用期间持续存在的源数据库上。因为在两次调用sqlite3_backup_step（）之间未锁定源数据库，所以可以在备份过程中途修改源数据库。如果源数据库是通过外部过程或通过数据库连接修改的，而不是通过备份操作使用的数据库连接修改的，则备份将在下一次调用sqlite3_backup_step（）时自动重新启动。如果通过使用与备份操作相同的数据库连接来修改源数据库，则备份数据库将同时自动更新。</target>
        </trans-unit>
        <trans-unit id="878621de1d1518fe649327da44b122a6dcc1e4c1" translate="yes" xml:space="preserve">
          <source>The first code for TH3 was laid down on 2008-09-25. An intense effort over the next 10 months resulted in TH3 achieving 100% MC/DC on 2009-07-25. The TH3 code continues to be improved and expanded.</source>
          <target state="translated">2008-09-25,为TH3制定了第一个代码。经过10个月的紧张努力,TH3于2009-07-25实现了100%的MC/DC。TH3代码还在继续改进和扩大。</target>
        </trans-unit>
        <trans-unit id="708a1cddc7d07a561f3445a868346de6a13841df" translate="yes" xml:space="preserve">
          <source>The first column is the schema name for the database that contains the tables. Examples: &quot;main&quot;, &quot;zone512&quot;.</source>
          <target state="translated">第一列是包含表的数据库的模式名称。例如:&quot;main&quot;、&quot;zone512&quot;。&quot;main&quot;,&quot;zone512&quot;。</target>
        </trans-unit>
        <trans-unit id="9814feb56c887ece7381e15fd8887b6ec1a1d8c0" translate="yes" xml:space="preserve">
          <source>The first column of an SQLite R*Tree is similar to an integer primary key column of a normal SQLite table. It may only store a 64-bit signed integer value. Inserting a NULL value into this column causes SQLite to automatically generate a new unique primary key value. If an attempt is made to insert any other non-integer value into this column, the r-tree module silently converts it to an integer before writing it into the database.</source>
          <target state="translated">SQLite R*Tree的第一列类似于普通SQLite表的整数主键列。它只能存储一个64位有符号的整数值。在这一列中插入一个NULL值会导致SQLite自动生成一个新的唯一主键值。如果试图在此列中插入任何其他非整数值,r-tree模块会在将其写入数据库之前,默默地将其转换为整数。</target>
        </trans-unit>
        <trans-unit id="840bd12d54aba66c9e7cdaff39f91dd2e3886bf1" translate="yes" xml:space="preserve">
          <source>The first condition causes all of the trunk check-ins to be displayed and the second and third cause check-ins that merge into or fork from the trunk to also be included. The three conditions are implemented by the three OR-connected EXISTS statements in the WHERE clause of the query. The slowdown that occurred with the NGQP was caused by the second and third conditions. The problem is the same in each, so we will examine just the second one. The subquery of the second condition can be rewritten (with minor and immaterial simplifications) as follows:</source>
          <target state="translated">第一个条件会导致所有的主干签到都被显示出来,第二个和第三个条件会导致合并到主干或从主干分叉的签到也被包括在内。这三个条件是由查询的WHERE子句中的三个OR-连接的EXISTS语句实现的。NGQP出现的速度变慢是由第二个和第三个条件造成的。每个条件的问题都是一样的,所以我们只研究第二个条件。第二个条件的子查询可以改写如下(稍作不重要的简化)。</target>
        </trans-unit>
        <trans-unit id="4abd9649e552817a07b47b388971861bc70b5489" translate="yes" xml:space="preserve">
          <source>The first eight columns are the address, opcode, and operands for a single &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; in the virtual machine that implements the statement. These columns are the same columns output when using EXPLAIN. The bytecode virtual tables shows all operations in the prepared statement, both the main body of the prepared statement and in subprograms used to implement triggers or foreign key actions. The &quot;subprog&quot; field is NULL for the main body of the prepared statement, or is the trigger name or the string &quot;(FK)&quot; for triggers and foreign key actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d90855e6a48f657d5fb1f13585eab05ee2b6665" translate="yes" xml:space="preserve">
          <source>The first example above is the preferred definition of the table, of course. All of the examples create a WITHOUT ROWID table with two PRIMARY KEY columns, &quot;a&quot; and &quot;c&quot;, in that order, followed by two data columns &quot;b&quot; and &quot;d&quot;, also in that order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d78f5e7f65436952c61eefc9d02af59c750bcb9f" translate="yes" xml:space="preserve">
          <source>The first five fields of the sqlite3_rtree_query_info structure are identical to the sqlite3_rtree_geometry structure, and have exactly the same meaning. The sqlite3_rtree_query_info structure also contains nCoord and aCoord fields which have the same meaning as the parameter of the same name in the xGeom callback.</source>
          <target state="translated">sqlite3_rtree_query_info结构的前五个字段与sqlite3_rtree_geometry结构相同,意义也完全相同。sqlite3_rtree_query_info结构还包含了nCoord和aCoord字段,这两个字段与xGeom回调中的同名参数意义相同。</target>
        </trans-unit>
        <trans-unit id="8e073e98c04e5afd81b1a912e72c323c17ce2eb5" translate="yes" xml:space="preserve">
          <source>The first form (with the &quot;VALUES&quot; keyword) creates one or more new rows in an existing table. If the column-name list after table-name is omitted then the number of values inserted into each row must be the same as the number of columns in the table. In this case the result of evaluating the left-most expression from each term of the VALUES list is inserted into the left-most column of each new row, and so forth for each subsequent expression. If a column-name list is specified, then the number of values in each term of the VALUE list must match the number of specified columns. Each of the named columns of the new row is populated with the results of evaluating the corresponding VALUES expression. Table columns that do not appear in the column list are populated with the &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default column value&lt;/a&gt; (specified as part of the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement), or with NULL if no &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default value&lt;/a&gt; is specified.</source>
          <target state="translated">第一种形式（带有&amp;ldquo; VALUES&amp;rdquo;关键字）在现有表中创建一个或多个新行。如果省略了table-name之后的column-name列表，则插入每行的值的数量必须与表中的列数相同。在这种情况下，将VALUES列表中每个术语的最左边表达式的求值结果插入到每个新行的最左边的列中，对于每个后续表达式，依此类推。如果指定了列名列表，则VALUE列表的每个术语中的值数必须与指定的列数匹配。新行的每个命名列均填充有评估相应VALUES表达式的结果。未显示在列列表中的表列将填充为&lt;a href=&quot;lang_createtable#dfltval&quot;&gt;默认列值&lt;/a&gt;（指定为&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句的一部分），如果未指定&lt;a href=&quot;lang_createtable#dfltval&quot;&gt;默认值，&lt;/a&gt;则为NULL 。</target>
        </trans-unit>
        <trans-unit id="2570c22a55e27cbe9ad6c1dce2c1cff1bff0c5c4" translate="yes" xml:space="preserve">
          <source>The first form loads the edit distance coefficients from a table called 'TABLENAME'. Any prior coefficients are discarded. So when experimenting with weights and the weight table changes, simply rerun the single-argument form of editdist3() to reload revised coefficients. Note that the edit distance weights used by the editdist3() SQL function are independent from the weights used by the spellfix1 virtual table.</source>
          <target state="translated">第一张表格从名为'TABLENAME'的表中加载编辑距离系数。任何之前的系数都会被丢弃。因此,当实验权重和权重表发生变化时,只需重新运行editdist3()的单参数形式来重新加载修改后的系数。注意,editdist3()SQL函数使用的编辑距离权重与spellfix1虚拟表使用的权重无关。</target>
        </trans-unit>
        <trans-unit id="7597ee6d3f1982d757a998bf7dd70b5fa125869a" translate="yes" xml:space="preserve">
          <source>The first form of the lag() function returns the result of evaluating expression</source>
          <target state="translated">lag()函数的第一种形式返回评估表达式的结果。</target>
        </trans-unit>
        <trans-unit id="99435f14d6ece88179aba89152e1459d1e98bf65" translate="yes" xml:space="preserve">
          <source>The first form of the lead() function returns the result of evaluating expression</source>
          <target state="translated">函数lead()的第一种形式返回对表达式的评估结果</target>
        </trans-unit>
        <trans-unit id="0e38dddff1d9fcb9023e44603abe1408f559a08e" translate="yes" xml:space="preserve">
          <source>The first form of this pragma queries the current journaling mode for</source>
          <target state="translated">这个pragma的第一种形式是查询当前的日记模式。</target>
        </trans-unit>
        <trans-unit id="b8118a5225d858802697d63c772d9f2007991455" translate="yes" xml:space="preserve">
          <source>The first four columns a, b, c, and d of the index would be usable since those four columns form a prefix of the index and are all bound by equality constraints.</source>
          <target state="translated">索引的前四列a、b、c、d将是可用的,因为这四列构成了索引的前缀,并且都受到平等约束。</target>
        </trans-unit>
        <trans-unit id="4ead6c16538264b763b7c6adde08cc0b22f7c9e0" translate="yes" xml:space="preserve">
          <source>The first group of queries in the log are extracting display options from the &quot;config&quot; and &quot;global_config&quot; tables of the Fossil database. Then there is a single complex query that extracts a list of all elements to be displayed on the timeline. This &quot;timeline&quot; query demonstrates that SQLite can easily process complex relational database queries involving multiple tables, subqueries, and complex WHERE clause constraints, and it can make effective use of indexes to solve the queries with minimal disk I/O.</source>
          <target state="translated">日志中的第一组查询是从Fossil数据库的 &quot;config &quot;和 &quot;global_config &quot;表中提取显示选项。然后是一个单一的复杂查询,提取所有要显示在时间轴上的元素列表。这个 &quot;时间轴 &quot;查询表明,SQLite可以轻松地处理涉及多表、子查询和复杂的WHERE子句约束的复杂关系数据库查询,它可以有效地利用索引,以最小的磁盘I/O来解决查询。</target>
        </trans-unit>
        <trans-unit id="4e52fafda10d32765550d3edce2eeda11c3b4ffd" translate="yes" xml:space="preserve">
          <source>The first host parameter has an index of 1, not 0.</source>
          <target state="translated">第一个主机参数的索引为1,而不是0。</target>
        </trans-unit>
        <trans-unit id="178a49643c52d6ff462985df8e6c238cfb8ec5cd" translate="yes" xml:space="preserve">
          <source>The first instruction of interest is the &lt;a href=&quot;opcode#AggReset&quot;&gt;AggReset&lt;/a&gt; at 2. The AggReset instruction initializes the set of buckets to be the empty set and specifies the number of memory slots available in each bucket as P2. In this example, each bucket will hold 3 memory slots. It is not obvious, but if you look closely at the rest of the program you can figure out what each of these slots is intended for.</source>
          <target state="translated">感兴趣的第一指令是&lt;a href=&quot;opcode#AggReset&quot;&gt;AggReset&lt;/a&gt;在2. AggReset指令初始化集桶的是空集，并指定每个桶中为P2可用存储器时隙的数目。在此示例中，每个存储桶将容纳3个内存插槽。这不是很明显，但是如果您仔细查看程序的其余部分，则可以弄清楚每个插槽的用途。</target>
        </trans-unit>
        <trans-unit id="11dcba86733ec3f9c57f212488f98cc390a1b479" translate="yes" xml:space="preserve">
          <source>The first integer in the P4 integer array is the length of the array and does not become part of the permutation.</source>
          <target state="translated">P4整型数组中的第一个整数是数组的长度,不会成为换位的一部分。</target>
        </trans-unit>
        <trans-unit id="388856185e941f1980f4fd92691075a08784c68c" translate="yes" xml:space="preserve">
          <source>The first line of the script above causes the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; to read and activate the run-time loadable extension for CSV. For an application, the equivalent C-language API is &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt;. Observe that the filename extension (ex: &quot;.dll&quot; or &quot;.so&quot; or &quot;.dylib&quot;) is omitted from the extension filename. Omitting the filename extension is not required, but it helps in making the script cross-platform. SQLite will automatically append the appropriate extension.</source>
          <target state="translated">上面脚本的第一行使&lt;a href=&quot;cli&quot;&gt;命令行外壳&lt;/a&gt;读取并激活CSV的运行时可加载扩展。对于应用程序，等效的C语言API是&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;。请注意，扩展名中省略了文件扩展名（例如：&amp;ldquo;。dll&amp;rdquo;，&amp;ldquo;。so&amp;rdquo;或&amp;ldquo; .dylib&amp;rdquo;）。不需要省略文件扩展名，但这有助于使脚本跨平台。 SQLite将自动附加适当的扩展名。</target>
        </trans-unit>
        <trans-unit id="75252c48c68a826da51013f5fcc062daddeb6d8f" translate="yes" xml:space="preserve">
          <source>The first of the above that is found to exist and have the write and execute bits set is used. The final &quot;.&quot; fallback is important for some applications that use SQLite inside of chroot jails that do not have the standard temporary file locations available.</source>
          <target state="translated">使用上述第一个被发现存在并设置了写和执行位的文件。最后一个&quot;.&quot;的回退对于一些在chroot监狱中使用SQLite的应用程序非常重要,因为这些应用程序没有标准的临时文件位置。</target>
        </trans-unit>
        <trans-unit id="1f9a60bfbed88db253a25c41a987f86e19f4d6aa" translate="yes" xml:space="preserve">
          <source>The first page of a cell payload overflow chain. The page number is the b-tree page that contains the cell whose content has overflowed.</source>
          <target state="translated">单元格有效载荷溢出链的第一页。页码是包含内容已溢出的单元格的b树页。</target>
        </trans-unit>
        <trans-unit id="571e717de8bab6f472a3daa4d0e34a129cf9485d" translate="yes" xml:space="preserve">
          <source>The first parameter is a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. If this statement is a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement and the Nth column of the returned result set of that &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; is a table column (not an expression or subquery) then the declared type of the table column is returned. If the Nth column of the result set is an expression or subquery, then a NULL pointer is returned. The returned string is always UTF-8 encoded.</source>
          <target state="translated">第一个参数是&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;。如果该语句是一个&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句和返回的结果集的第N列&lt;a href=&quot;lang_select&quot;&gt;选择&lt;/a&gt;被表列（不是表达式或子查询），则表列的声明的类型被返回。如果结果集的第N列是表达式或子查询，则返回NULL指针。返回的字符串始终是UTF-8编码的。</target>
        </trans-unit>
        <trans-unit id="2d95d478fea3b8287d0a6628b14c6c99e2b30bf0" translate="yes" xml:space="preserve">
          <source>The first parameter is a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. If this statement is a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement and the Nth column of the returned result set of that &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; is a table column (not an expression or subquery) then the declared type of the table column is returned. If the Nth column of the result set is an expression or subquery, then a NULL pointer is returned. The returned string is always UTF-8 encoded.</source>
          <target state="translated">第一个参数是&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;。如果该语句是一个&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;语句和返回的结果集的第N列&lt;a href=&quot;../lang_select&quot;&gt;选择&lt;/a&gt;被表列（不是表达式或子查询），则表列的声明的类型被返回。如果结果集的第N列是表达式或子查询，则返回NULL指针。返回的字符串始终是UTF-8编码的。</target>
        </trans-unit>
        <trans-unit id="c8355444303911368f3db824744273405e752637" translate="yes" xml:space="preserve">
          <source>The first parameter is the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; to which the SQL function is to be added. If an application uses more than one database connection then application-defined SQL functions must be added to each database connection separately.</source>
          <target state="translated">第一个参数是要添加SQL函数的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;。如果一个应用程序使用多个数据库连接，则必须将应用程序定义的SQL函数分别添加到每个数据库连接中。</target>
        </trans-unit>
        <trans-unit id="2034bce444668b7bc337245a2c547e0aff9b9fd1" translate="yes" xml:space="preserve">
          <source>The first parameter is the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; to which the SQL function is to be added. If an application uses more than one database connection then application-defined SQL functions must be added to each database connection separately.</source>
          <target state="translated">第一个参数是要添加SQL函数的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;。如果一个应用程序使用多个数据库连接，则必须将应用程序定义的SQL函数分别添加到每个数据库连接中。</target>
        </trans-unit>
        <trans-unit id="02bbb4f6b68ff55742031c8b1808d80607aaa103" translate="yes" xml:space="preserve">
          <source>The first parameter must be a copy of the &lt;a href=&quot;#sqlite3_context&quot;&gt;SQL function context&lt;/a&gt; that is the first parameter to the xStep or xFinal callback routine that implements the aggregate function.</source>
          <target state="translated">第一个参数必须是&lt;a href=&quot;#sqlite3_context&quot;&gt;SQL函数上下文&lt;/a&gt;的副本，该副本是实现聚合函数的xStep或xFinal回调例程的第一个参数。</target>
        </trans-unit>
        <trans-unit id="303b1214ac90198e86e2d6fded39de6f12728048" translate="yes" xml:space="preserve">
          <source>The first parameter must be a copy of the &lt;a href=&quot;context&quot;&gt;SQL function context&lt;/a&gt; that is the first parameter to the xStep or xFinal callback routine that implements the aggregate function.</source>
          <target state="translated">第一个参数必须是&lt;a href=&quot;context&quot;&gt;SQL函数上下文&lt;/a&gt;的副本，该副本是实现聚合函数的xStep或xFinal回调例程的第一个参数。</target>
        </trans-unit>
        <trans-unit id="51bc3b9167a1367dcb303b210930c2e99a40f80a" translate="yes" xml:space="preserve">
          <source>The first parameter passed to the callback function when it is invoked is a copy of the third parameter passed to sqlite3_wal_hook() when registering the callback. The second is a copy of the database handle. The third parameter is the name of the database that was written to - either &quot;main&quot; or the name of an &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed database. The fourth parameter is the number of pages currently in the write-ahead log file, including those that were just committed.</source>
          <target state="translated">调用回调函数时传递给它的第一个参数是注册回调时传递给sqlite3_wal_hook（）的第三个参数的副本。第二个是数据库句柄的副本。第三个参数是写入的数据库的名称-&amp;ldquo; main&amp;rdquo;或&lt;a href=&quot;../lang_attach&quot;&gt;ATTACH编辑的&lt;/a&gt;数据库的名称。第四个参数是当前预写日志文件中的页面数，包括刚刚提交的页面数。</target>
        </trans-unit>
        <trans-unit id="8448fcb45b7f072723f93590a80d37aef6a727c3" translate="yes" xml:space="preserve">
          <source>The first parameter passed to the callback function when it is invoked is a copy of the third parameter passed to sqlite3_wal_hook() when registering the callback. The second is a copy of the database handle. The third parameter is the name of the database that was written to - either &quot;main&quot; or the name of an &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed database. The fourth parameter is the number of pages currently in the write-ahead log file, including those that were just committed.</source>
          <target state="translated">调用回调函数时传递给它的第一个参数是注册回调时传递给sqlite3_wal_hook（）的第三个参数的副本。第二个是数据库句柄的副本。第三个参数是写入的数据库的名称-&amp;ldquo; main&amp;rdquo;或&lt;a href=&quot;lang_attach&quot;&gt;ATTACH编辑的&lt;/a&gt;数据库的名称。第四个参数是当前预写日志文件中的页面数，包括刚刚提交的页面数。</target>
        </trans-unit>
        <trans-unit id="114b67e4b3a89669211882b27d3030f929c0b812" translate="yes" xml:space="preserve">
          <source>The first parameter to the authorizer callback is a copy of the third parameter to the sqlite3_set_authorizer() interface. The second parameter to the callback is an integer &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;action code&lt;/a&gt; that specifies the particular action to be authorized. The third through sixth parameters to the callback are either NULL pointers or zero-terminated strings that contain additional details about the action to be authorized. Applications must always be prepared to encounter a NULL pointer in any of the third through the sixth parameters of the authorization callback.</source>
          <target state="translated">Authorizer回调的第一个参数是第三个参数到sqlite3_set_authorizer（）接口的副本。回调的第二个参数是整数&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;操作代码&lt;/a&gt;，它指定要授权的特定操作。回调的第三到第六个参数是NULL指针或零终止字符串，其中包含有关要授权的操作的其他详细信息。应用程序必须始终准备在授权回调的第三至第六个参数中的任何一个中遇到NULL指针。</target>
        </trans-unit>
        <trans-unit id="031900d436ad256c6483a02e204c32e4df2ca84e" translate="yes" xml:space="preserve">
          <source>The first parameter to the authorizer callback is a copy of the third parameter to the sqlite3_set_authorizer() interface. The second parameter to the callback is an integer &lt;a href=&quot;c_alter_table&quot;&gt;action code&lt;/a&gt; that specifies the particular action to be authorized. The third through sixth parameters to the callback are either NULL pointers or zero-terminated strings that contain additional details about the action to be authorized. Applications must always be prepared to encounter a NULL pointer in any of the third through the sixth parameters of the authorization callback.</source>
          <target state="translated">Authorizer回调的第一个参数是第三个参数到sqlite3_set_authorizer（）接口的副本。回调的第二个参数是整数&lt;a href=&quot;c_alter_table&quot;&gt;操作代码&lt;/a&gt;，它指定要授权的特定操作。回调的第三到第六个参数是NULL指针或零终止字符串，其中包含有关要授权的操作的其他详细信息。应用程序必须始终准备在授权回调的第三至第六个参数中的任何一个中遇到NULL指针。</target>
        </trans-unit>
        <trans-unit id="1622094cd4d4c27ce242fb95c194e4ab11274192" translate="yes" xml:space="preserve">
          <source>The first parameter to these interfaces (hereafter referred to as F) must be one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c4884990e25d1601d544fb2189fcbf8e2210be" translate="yes" xml:space="preserve">
          <source>The first section introduces the concept of an SQL foreign key by example and defines the terminology used for the remainder of the document. Section 2 describes the steps an application must take in order to enable foreign key constraints in SQLite (it is disabled by default). The next section, section 3, describes the indexes that the user must create in order to use foreign key constraints, and those that should be created in order for foreign key constraints to function efficiently. Section 4 describes the advanced foreign key related features supported by SQLite and section 5 describes the way the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER&lt;/a&gt; and &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; commands are enhanced to support foreign key constraints. Finally, section 6 enumerates the missing features and limits of the current implementation.</source>
          <target state="translated">第一部分通过示例介绍了SQL外键的概念，并定义了文档其余部分使用的术语。第2节介绍了应用程序在SQLite中启用外键约束所必须采取的步骤（默认情况下已禁用）。下一部分，第3节，描述了用户必须创建的索引才能使用外键约束，以及为使外键约束有效运行而必须创建的索引。第4节介绍了SQLite支持的高级外键相关功能，第5节介绍了增强&lt;a href=&quot;lang_altertable&quot;&gt;ALTER&lt;/a&gt;和&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;命令以支持外键约束的方式。最后，第6节列举了当前实现的缺失功能和局限性。</target>
        </trans-unit>
        <trans-unit id="6abe8a139c8044b273ba74ec6b9c2e3f141ecabe" translate="yes" xml:space="preserve">
          <source>The first set of three values corresponds to the left-most column of the table (column 0) and the left-most matchable phrase in the query (phrase 0). If the table has more than one column, the second set of three values in the output array correspond to phrase 0 and column 1. Followed by phrase 0, column 2 and so on for all columns of the table. And so on for phrase 1, column 0, then phrase 1, column 1 etc. In other words, the data for occurrences of phrase</source>
          <target state="translated">第一组三个值对应于表格最左边的一列(列0)和查询中最左边的可匹配短语(短语0)。如果表有多于一列,输出数组中的第二组三个值对应短语0和第1列。接着是短语0,第2列,以此类推,表的所有列。以此类推短语1、第0列,然后是短语1、第1列等。换句话说,短语的出现数据为</target>
        </trans-unit>
        <trans-unit id="b88b9c17da99b9d9285ae75db888dfa7bebfc06c" translate="yes" xml:space="preserve">
          <source>The first six interfaces (_blob, _double, _int, _int64, _text, and _text16) each return the value of a result column in a specific data format. If the result column is not initially in the requested format (for example, if the query returns an integer but the sqlite3_column_text() interface is used to extract the value) then an automatic type conversion is performed.</source>
          <target state="translated">前六个接口(_blob,_double,_int,_int64,_text,和 _text16)分别返回特定数据格式的结果列的值。如果结果列最初并不是所要求的格式(例如,如果查询返回的是一个整数,但使用sqlite3_column_text()接口来提取值),那么就会进行自动类型转换。</target>
        </trans-unit>
        <trans-unit id="67231aa738e6314e6f80285f8fe72b39964cf222" translate="yes" xml:space="preserve">
          <source>The first six modifiers (1 through 6) simply add the specified amount of time to the date and time specified by the preceding timestring and modifiers. The 's' character at the end of the modifier names is optional. Note that &quot;&amp;plusmn;NNN months&quot; works by rendering the original date into the YYYY-MM-DD format, adding the &amp;plusmn;NNN to the MM month value, then normalizing the result. Thus, for example, the data 2001-03-31 modified by '+1 month' initially yields 2001-04-31, but April only has 30 days so the date is normalized to 2001-05-01. A similar effect occurs when the original date is February 29 of a leapyear and the modifier is &amp;plusmn;N years where N is not a multiple of four.</source>
          <target state="translated">The first six modifiers (1 through 6) simply add the specified amount of time to the date and time specified by the preceding timestring and modifiers. The 's' character at the end of the modifier names is optional. Note that &quot;&amp;plusmn;NNN months&quot; works by rendering the original date into the YYYY-MM-DD format, adding the &amp;plusmn;NNN to the MM month value, then normalizing the result. Thus, for example, the data 2001-03-31 modified by '+1 month' initially yields 2001-04-31, but April only has 30 days so the date is normalized to 2001-05-01. A similar effect occurs when the original date is February 29 of a leapyear and the modifier is &amp;plusmn;N years where N is not a multiple of four.</target>
        </trans-unit>
        <trans-unit id="de80fd15e7d30919dde63ea2e434aa9d73b98e29" translate="yes" xml:space="preserve">
          <source>The first step toward dealing with a hot journal is to obtain an exclusive lock on the database file. This prevents two or more processes from trying to rollback the same hot journal at the same time.</source>
          <target state="translated">处理热日志的第一步是获得数据库文件上的独占锁,这样可以防止两个或多个进程同时试图回滚同一个热日志。这可以防止两个或多个进程同时试图回滚同一个热日志。</target>
        </trans-unit>
        <trans-unit id="6d5dce142e8b6c56f2485efc4da630bd41e2b246" translate="yes" xml:space="preserve">
          <source>The first step toward reading from the database file is obtaining a shared lock on the database file. A &quot;shared&quot; lock allows two or more database connections to read from the database file at the same time. But a shared lock prevents another database connection from writing to the database file while we are reading it. This is necessary because if another database connection were writing to the database file at the same time we are reading from the database file, we might read some data before the change and other data after the change. This would make it appear as if the change made by the other process is not atomic.</source>
          <target state="translated">从数据库文件读取的第一步是获得数据库文件的共享锁。一个 &quot;共享 &quot;锁允许两个或多个数据库连接同时从数据库文件中读取。但是共享锁可以防止另一个数据库连接在我们读取数据库文件的时候向数据库文件写入。这是必要的,因为如果另一个数据库连接在我们从数据库文件读取的同时向数据库文件写入数据,我们可能会在改变之前读取一些数据,而在改变之后读取其他数据。这样就会显得另一个进程所做的改变不是原子性的。</target>
        </trans-unit>
        <trans-unit id="728a2c812c40e366db04b46879d8327a7463b66e" translate="yes" xml:space="preserve">
          <source>The first string or bareword in a column declaration is the column name. It is an error to attempt to name an fts5 table column &quot;rowid&quot; or &quot;rank&quot;, or to assign the same name to a column as is used by the table itself. This is not supported.</source>
          <target state="translated">列声明中的第一个字符串或裸字是列名。试图将fts5表列命名为 &quot;rowid &quot;或 &quot;rank&quot;,或者将表本身使用的相同名称分配给列,都是错误的。这是不支持的。</target>
        </trans-unit>
        <trans-unit id="15aebb5889bf7eacd8a14d41dd89f37206fa7a06" translate="yes" xml:space="preserve">
          <source>The first subquery above is constant with respect to the outer query. The value for the first subquery can be computed once and then reused for each row of the outer SELECT. The second subquery, however, is &quot;CORRELATED&quot;. The value of the second subquery changes depending on values in the current row of the outer query. Hence, the second subquery must be run once for each output row in the outer SELECT.</source>
          <target state="translated">上面的第一个子查询相对于外层查询来说是不变的。第一个子查询的值可以计算一次,然后对外部SELECT的每一条记录重复使用。而第二个子查询则是 &quot;CORRELATED&quot;。第二个子查询的值会根据外侧查询的当前行的值而改变。因此,第二个子查询必须为外侧SELECT中的每一条输出行运行一次。</target>
        </trans-unit>
        <trans-unit id="c31bdf542d6f05cfa5241d61c80e5148ec82df02" translate="yes" xml:space="preserve">
          <source>The first term stored on each node (&quot;Term 1&quot; in the figure above) is stored verbatim. Each subsequent term is prefix-compressed with respect to its predecessor. Terms are stored within a page in sorted (memcmp) order.</source>
          <target state="translated">每个节点上存储的第一个术语(上图中的 &quot;术语1&quot;)是逐字存储的。后续的每一个术语相对于它的前一个术语都是前缀压缩的。术语按排序(memcmp)顺序存储在一个页面中。</target>
        </trans-unit>
        <trans-unit id="7a099bb22daac790c8e16aa7a285108628e1197d" translate="yes" xml:space="preserve">
          <source>The first thing that happens is that we open the table being indexed for reading. In order to construct an index for a table, we have to know what is in that table. The index has already been opened for writing using cursor 0 by instructions 3 and 4.</source>
          <target state="translated">首先,我们打开被索引的表进行读取。为了构建一个表的索引,我们必须知道这个表里有什么。通过指令3和指令4,已经用游标0打开了索引进行写入。</target>
        </trans-unit>
        <trans-unit id="5eb1752f78007fa49f66b7f76488ea011879482b" translate="yes" xml:space="preserve">
          <source>The first time that any SQLite process attempts to access the database file, it obtains a shared lock as described in &lt;a href=&quot;https://sqlite.org/section_3_2&quot;&gt;section 3.2&lt;/a&gt; above. But then it notices that there is a rollback journal file present. SQLite then checks to see if the rollback journal is a &quot;hot journal&quot;. A hot journal is a rollback journal that needs to be played back in order to restore the database to a sane state. A hot journal only exists when an earlier process was in the middle of committing a transaction when it crashed or lost power.</source>
          <target state="translated">任何SQLite进程首次尝试访问数据库文件时，都会获得共享锁，如上面&lt;a href=&quot;https://sqlite.org/section_3_2&quot;&gt;3.2节中&lt;/a&gt;所述。但是随后它注意到存在回滚日志文件。然后，SQLite检查回滚日志是否为&amp;ldquo;热日志&amp;rdquo;。热日志是一种回滚日志，需要将其还原才能将数据库还原到正常状态。仅当较早的进程崩溃或断电时才提交事务时，才存在热日志。</target>
        </trans-unit>
        <trans-unit id="e68a1d44352d39217814d6bf160a385833864476" translate="yes" xml:space="preserve">
          <source>The first time the sqlite3_aggregate_context(C,N) routine is called for a particular aggregate function, SQLite allocates N bytes of memory, zeroes out that memory, and returns a pointer to the new memory. On second and subsequent calls to sqlite3_aggregate_context() for the same aggregate function instance, the same buffer is returned. Sqlite3_aggregate_context() is normally called once for each invocation of the xStep callback and then one last time when the xFinal callback is invoked. When no rows match an aggregate query, the xStep() callback of the aggregate function implementation is never called and xFinal() is called exactly once. In those cases, sqlite3_aggregate_context() might be called for the first time from within xFinal().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3a42cd86f3f8e7c9fddbcba13c3c1c638314931" translate="yes" xml:space="preserve">
          <source>The first time the sqlite3_aggregate_context(C,N) routine is called for a particular aggregate function, SQLite allocates N of memory, zeroes out that memory, and returns a pointer to the new memory. On second and subsequent calls to sqlite3_aggregate_context() for the same aggregate function instance, the same buffer is returned. Sqlite3_aggregate_context() is normally called once for each invocation of the xStep callback and then one last time when the xFinal callback is invoked. When no rows match an aggregate query, the xStep() callback of the aggregate function implementation is never called and xFinal() is called exactly once. In those cases, sqlite3_aggregate_context() might be called for the first time from within xFinal().</source>
          <target state="translated">第一次调用sqlite3_aggregate_context(C,N)例程来执行一个特定的聚合函数时,SQLite会分配N个内存,将该内存清零,并返回一个指向新内存的指针。在第二次以及后续对同一聚合函数实例调用 sqlite3_aggregate_context()时,返回相同的缓冲区。Sqlite3_aggregate_context()通常在每次调用xStep回调时调用一次,然后在调用xFinal回调时调用最后一次。当没有记录匹配聚合查询时,聚合函数实现的xStep()回调永远不会被调用,而xFinal()正好被调用一次。在这些情况下,sqlite3_aggregate_context()可能会在xFinal()中被第一次调用。</target>
        </trans-unit>
        <trans-unit id="33a73e33477151458e48dab8a4d76f2a383719c8" translate="yes" xml:space="preserve">
          <source>The first two constants (SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE) cause sqlite3_mutex_alloc() to create a new mutex. The new mutex is recursive when SQLITE_MUTEX_RECURSIVE is used but not necessarily so when SQLITE_MUTEX_FAST is used. The mutex implementation does not need to make a distinction between SQLITE_MUTEX_RECURSIVE and SQLITE_MUTEX_FAST if it does not want to. SQLite will only request a recursive mutex in cases where it really needs one. If a faster non-recursive mutex implementation is available on the host platform, the mutex subsystem might return such a mutex in response to SQLITE_MUTEX_FAST.</source>
          <target state="translated">前两个常量(SQLITE_MUTEX_FAST和SQLITE_MUTEX_RECURSIVE)会导致 sqlite3_mutex_alloc()创建一个新的mutex。当使用SQLITE_MUTEX_RECURSIVE时,新的mutex是递归的,但当使用SQLITE_MUTEX_FAST时就不一定了。如果不想区分SQLITE_MUTEX_RECURSIVE和SQLITE_MUTEX_FAST,mutex实现不需要区分。SQLite只会在真正需要递归mutex的情况下请求递归mutex。如果主机平台上有更快的非递归mutex实现,mutex子系统可能会返回这样的mutex来响应SQLITE_MUTEX_FAST。</target>
        </trans-unit>
        <trans-unit id="3ad84c4124333660ac2ec2d4b3b96a74793fd127" translate="yes" xml:space="preserve">
          <source>The first two elements in the list above, the associated</source>
          <target state="translated">上述清单中的前两个要素,即相关的</target>
        </trans-unit>
        <trans-unit id="9de36623b06dcc8a12dabc9fe8d69bf46f2afdab" translate="yes" xml:space="preserve">
          <source>The first two instructions in the VDBE program for our query are concerned with setting up values for &lt;b&gt;azColumn&lt;/b&gt;. The &lt;a href=&quot;opcode#ColumnName&quot;&gt;ColumnName&lt;/a&gt; instructions tell the VDBE what values to fill in for each element of the &lt;b&gt;azColumnName[]&lt;/b&gt; array. Every query will begin with one ColumnName instruction for each column in the result, and there will be a matching Column instruction for each one later in the query.</source>
          <target state="translated">VDBE程序中用于查询的前两个指令涉及为&lt;b&gt;azColumn&lt;/b&gt;设置值。所述&lt;a href=&quot;opcode#ColumnName&quot;&gt;的ColumnName&lt;/a&gt;指令告诉VDBE填补哪些值在用于的每个元素&lt;b&gt;azColumnName []&lt;/b&gt;数组。每个查询将以一个ColumnName指令开头结果中的每一列，并且稍后在查询中将为每一个列提供匹配的Column指令。</target>
        </trans-unit>
        <trans-unit id="80f7eaccbd1b0c6d2fde7b56494766bcf2304eb6" translate="yes" xml:space="preserve">
          <source>The first two query examples illustrate a kind of template that every SELECT program will follow. Basically, we have:</source>
          <target state="translated">前两个查询示例说明了一种模板,每个SELECT程序都会遵循。基本上,我们有:</target>
        </trans-unit>
        <trans-unit id="c636087069b26e9346b965d8bb5b5d8294795344" translate="yes" xml:space="preserve">
          <source>The first value in the array of integer values corresponds to the leftmost column of the table (column 0) and the first phrase in the query (phrase 0). The values corresponding to other column/phrase combinations may be located using the following formula:</source>
          <target state="translated">整数数组中的第一个值对应于表的最左列(列0)和查询中的第一个短语(短语0)。对应于其他列/短语组合的值可以用下面的公式来定位。</target>
        </trans-unit>
        <trans-unit id="61029d8449643ad48e743f1026fb94f8a1ed1222" translate="yes" xml:space="preserve">
          <source>The first, or only, integer is the blockid that corresponds to the interior node with the largest blockid that belongs to this segment b-tree. Or zero if the entire segment b-tree fits on the root node. If it exists, this node is always an interior node.</source>
          <target state="translated">第一个,或者说唯一的整数,是对应于这个段b树的最大blockid的内部节点的blockid。如果整个段b树都适合在根节点上,则为零。如果存在,这个节点总是内部节点。</target>
        </trans-unit>
        <trans-unit id="c0ebe13b31f8942f70d44d11a35f84a9529666cd" translate="yes" xml:space="preserve">
          <source>The fix in the 3.25.0 release for the endless-loop in the byte-code associated with the ORDER BY LIMIT optimization did not work for some queries involving window functions. An additional correction is required. Ticket &lt;a href=&quot;https://sqlite.org/src/info/510cde277783b5fb&quot;&gt;510cde277783b5fb&lt;/a&gt;</source>
          <target state="translated">3.25.0版本中针对与ORDER BY LIMIT优化相关联的字节码中的无限循环的修复不适用于某些涉及窗口函数的查询。需要进行其他更正。门票&lt;a href=&quot;https://sqlite.org/src/info/510cde277783b5fb&quot;&gt;510cde277783b5fb&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c2032be06ad1313d23c4aa0f2d29e1f73447dfd8" translate="yes" xml:space="preserve">
          <source>The fix to the previous bug uncovered a deadlock which was also fixed.</source>
          <target state="translated">之前的bug的修复发现了一个死锁,也被修复了。</target>
        </trans-unit>
        <trans-unit id="8197368f601d93edb14a348de0bf212d3c1bcf51" translate="yes" xml:space="preserve">
          <source>The flags argument to xAccess() may be &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; to test for the existence of a file, or &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; to test whether a file is readable and writable, or &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; to test whether a file is at least readable. The SQLITE_ACCESS_READ flag is never actually used and is not implemented in the built-in VFSes of SQLite. The file is named by the second argument and can be a directory. The xAccess method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success or some non-zero error code if there is an I/O error or if the name of the file given in the second argument is illegal. If SQLITE_OK is returned, then non-zero or zero is written into *pResOut to indicate whether or not the file is accessible.</source>
          <target state="translated">flags参数到Xaccess文件（）可以是&lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt;到用于测试的存在的文件的，或&lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt;到测试文件是否是可读写的，或&lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt;到测试文件是否至少可读。 SQLITE_ACCESS_READ标志从不实际使用，也不在SQLite的内置VFS中实现。该文件由第二个参数命名，并且可以是目录。如果出现I / O错误或第二个参数中给定的文件名不&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;合法&lt;/a&gt;，则xAccess方法成功返回SQLITE_OK或返回一些非零错误代码。如果返回SQLITE_OK，则将非零或零写入* pResOut，以指示该文件是否可访问。</target>
        </trans-unit>
        <trans-unit id="ee0102cf2398a56ff989592f19a055847f5dc920" translate="yes" xml:space="preserve">
          <source>The flags argument to xAccess() may be &lt;a href=&quot;c_access_exists&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; to test for the existence of a file, or &lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; to test whether a file is readable and writable, or &lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; to test whether a file is at least readable. The SQLITE_ACCESS_READ flag is never actually used and is not implemented in the built-in VFSes of SQLite. The file is named by the second argument and can be a directory. The xAccess method returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success or some non-zero error code if there is an I/O error or if the name of the file given in the second argument is illegal. If SQLITE_OK is returned, then non-zero or zero is written into *pResOut to indicate whether or not the file is accessible.</source>
          <target state="translated">flags参数到Xaccess文件（）可以是&lt;a href=&quot;c_access_exists&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt;到用于测试的存在的文件的，或&lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt;到测试文件是否是可读写的，或&lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt;到测试文件是否至少可读。 SQLITE_ACCESS_READ标志从不实际使用，也不在SQLite的内置VFS中实现。该文件由第二个参数命名，并且可以是目录。如果出现I / O错误或第二个参数中给定的文件名不&lt;a href=&quot;../rescode#ok&quot;&gt;合法&lt;/a&gt;，则xAccess方法成功返回SQLITE_OK或返回一些非零错误代码。如果返回SQLITE_OK，则将非零或零写入* pResOut，以指示该文件是否可访问。</target>
        </trans-unit>
        <trans-unit id="d9f0c284ad1c57f7e5da616991af768f686e341f" translate="yes" xml:space="preserve">
          <source>The flags argument to xOpen() includes all bits set in the flags argument to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. Or if &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt; is used, then flags includes at least &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;. If xOpen() opens a file read-only then it sets *pOutFlags to include &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;. Other bits in *pOutFlags may be set.</source>
          <target state="translated">xOpen（）的flags参数包括在&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;的flags参数中设置的所有位。或者，如果使用&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16（）&lt;/a&gt;，则标志至少包括&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | |。&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;。如果xOpen（）以只读方式打开文件，则它将* pOutFlags设置为包括&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;。 * pOutFlags中的其他位可以设置。</target>
        </trans-unit>
        <trans-unit id="f5198d48ad55972f3bafe448a5f83115c01462b7" translate="yes" xml:space="preserve">
          <source>The flags argument to xOpen() includes all bits set in the flags argument to &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. Or if &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt; is used, then flags includes at least &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;. If xOpen() opens a file read-only then it sets *pOutFlags to include &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;. Other bits in *pOutFlags may be set.</source>
          <target state="translated">xOpen（）的flags参数包括在&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;的flags参数中设置的所有位。或者，如果使用&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;或&lt;a href=&quot;open&quot;&gt;sqlite3_open16（）&lt;/a&gt;，则标志至少包括&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | |。&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;。如果xOpen（）以只读方式打开文件，则它将* pOutFlags设置为包括&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;。 * pOutFlags中的其他位可以设置。</target>
        </trans-unit>
        <trans-unit id="7bc004618637404d4a4bd35b24cc91bd411a3086" translate="yes" xml:space="preserve">
          <source>The flags argument to xSync may be one of &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt; or &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt;. The first choice is the normal fsync(). The second choice is a Mac OS X style fullsync. The &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_DATAONLY&lt;/a&gt; flag may be ORed in to indicate that only the data of the file and not its inode needs to be synced.</source>
          <target state="translated">xSync的flags参数可以是&lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt;或&lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_FULL之一&lt;/a&gt;。首选是普通的fsync（）。第二个选择是Mac OS X风格的fullsync。可以对&lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_DATAONLY&lt;/a&gt;标志进行OR运算，以指示仅文件的数据而不是其索引节点需要同步。</target>
        </trans-unit>
        <trans-unit id="99d3aea2b8c0b18767851d7c8d3921e4603f6ed1" translate="yes" xml:space="preserve">
          <source>The flags argument to xSync may be one of &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt; or &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt;. The first choice is the normal fsync(). The second choice is a Mac OS X style fullsync. The &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_DATAONLY&lt;/a&gt; flag may be ORed in to indicate that only the data of the file and not its inode needs to be synced.</source>
          <target state="translated">xSync的flags参数可以是&lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt;或&lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL之一&lt;/a&gt;。首选是普通的fsync（）。第二个选择是Mac OS X风格的fullsync。可以对&lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_DATAONLY&lt;/a&gt;标志进行OR运算，以指示仅文件的数据而不是其索引节点需要同步。</target>
        </trans-unit>
        <trans-unit id="c377d5a3884469a39150e12bd3af49c973f2fad1" translate="yes" xml:space="preserve">
          <source>The floating-point to text conversion subfunction for the built-in printf() is limited in precision to 16 significant digits or 26 significant digits if the &quot;!&quot; alternate-form-2 flag is used. Every IEEE-754 double can be represented exactly as a decimal floating-point value, but some doubles require more than 16 or 26 significant digits.</source>
          <target state="translated">内置printf()的浮点到文本转换子函数的精度限制为16位有效数字,如果使用&quot;!&quot;交替形式-2标志,则限制为26位有效数字,每个IEEE-754双数都可以完全表示十进制浮点值,但有些双数需要超过16或26位有效数字。每一个IEEE-754双数都可以用十进制浮点值来表示,但有些双数需要超过16或26个有意义的数字。</target>
        </trans-unit>
        <trans-unit id="68fce5c170ab1896511f13fd3e82f411098f2695" translate="yes" xml:space="preserve">
          <source>The folder returned by the GetTempPath() system interface.</source>
          <target state="translated">GetTempPath()系统接口返回的文件夹。</target>
        </trans-unit>
        <trans-unit id="4f48bdf9b1dfd94aea260fd19b610d7cf9d72be5" translate="yes" xml:space="preserve">
          <source>The folder set by &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt; or by the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable</source>
          <target state="translated">由&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt;或&lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;全局变量设置的文件夹</target>
        </trans-unit>
        <trans-unit id="8f393fa7f5f393cd220ff4a7a6a7ccbac66e5676" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://xkcd.com/1597/&quot;&gt;https://xkcd.com/1597/&lt;/a&gt; cartoon is an exaggeration, yet hits close to home:</source>
          <target state="translated">以下&lt;a href=&quot;https://xkcd.com/1597/&quot;&gt;https://xkcd.com/1597/&lt;/a&gt;卡通很夸张，但很受欢迎：</target>
        </trans-unit>
        <trans-unit id="40de557d79eeab5be4528c0beef95dcb1a5f7ef4" translate="yes" xml:space="preserve">
          <source>The following RBU database schema may be used:</source>
          <target state="translated">可使用下列区域局数据库模式:</target>
        </trans-unit>
        <trans-unit id="ae49ebf9365c52bbf37afc8c396e0cba8b2d31d3" translate="yes" xml:space="preserve">
          <source>The following SQL demonstrates how SQLite uses column affinity to do type conversions when values are inserted into a table.</source>
          <target state="translated">下面的SQL演示了当值被插入到表中时,SQLite如何使用列亲和力来进行类型转换。</target>
        </trans-unit>
        <trans-unit id="d10a8778dff23f69800ec8a5dd149287ef5743ba" translate="yes" xml:space="preserve">
          <source>The following SQL illustrates how to use the ieee754 and decimal extensions to compute the exact decimal equivalent for a binary64 floating-point number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7479fafb0c600f993e6250d871980ae79cbdf35" translate="yes" xml:space="preserve">
          <source>The following SQLite command-line session illustrates the effect of the foreign key constraint added to the</source>
          <target state="translated">下面的SQLite命令行会话说明了外键约束添加至</target>
        </trans-unit>
        <trans-unit id="1f8a8aec572c42d81f9a9d30dc36ba0c1a7ca331" translate="yes" xml:space="preserve">
          <source>The following additional compile-time options are recommended in order to provide a full-featured command-line shell:</source>
          <target state="translated">为了提供一个功能齐全的命令行shell,建议使用以下额外的编译时选项。</target>
        </trans-unit>
        <trans-unit id="e661fc6daecc53fc88e2038803ed3bcb13092e93" translate="yes" xml:space="preserve">
          <source>The following additional syntax restrictions apply to UPDATE statements that occur within the body of a &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement.</source>
          <target state="translated">以下其他语法限制适用于&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;语句主体内的UPDATE 语句。</target>
        </trans-unit>
        <trans-unit id="0a78308c3e0962720a3b6c6b2c92b551ac030e31" translate="yes" xml:space="preserve">
          <source>The following are allowed values for 6th argument (the F argument) to the &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize(D,S,P,N,M,F)&lt;/a&gt; interface.</source>
          <target state="translated">以下是&lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize（D，S，P，N，M，F）&lt;/a&gt;接口的第六个参数（F参数）的允许值。</target>
        </trans-unit>
        <trans-unit id="b9076a86669fb7bce220c5cc2398686ebb071016" translate="yes" xml:space="preserve">
          <source>The following are allowed values for 6th argument (the F argument) to the &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize(D,S,P,N,M,F)&lt;/a&gt; interface.</source>
          <target state="translated">以下是&lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize（D，S，P，N，M，F）&lt;/a&gt;接口的第六个参数（F参数）的允许值。</target>
        </trans-unit>
        <trans-unit id="a59459d6632d0bbc1149f827b602fb3d835358c8" translate="yes" xml:space="preserve">
          <source>The following are examples of disabling the built-in protection mechanisms of SQLite:</source>
          <target state="translated">以下是禁用SQLite内置保护机制的例子。</target>
        </trans-unit>
        <trans-unit id="80d00e742a47603d638009e13703b23c42a0d91f" translate="yes" xml:space="preserve">
          <source>The following are other VFS implementations available in the public SQLite source tree:</source>
          <target state="translated">以下是公共SQLite源树中的其他VFS实现。</target>
        </trans-unit>
        <trans-unit id="ec123026fdd8e1c2278a5f9715d6939ab0dbeb46" translate="yes" xml:space="preserve">
          <source>The following are the available OMIT options:</source>
          <target state="translated">以下是可用的OMIT选项。</target>
        </trans-unit>
        <trans-unit id="8fa3cecc90ff41687bc039d2f339ed203679e422" translate="yes" xml:space="preserve">
          <source>The following block contains a summary of the FTS query syntax in BNF form. A detailed explanation follows.</source>
          <target state="translated">下面的块包含了BNF形式的FTS查询语法摘要。下面是详细的解释。</target>
        </trans-unit>
        <trans-unit id="9eacb2386777a09c397574d603b9f7b4a178b7c8" translate="yes" xml:space="preserve">
          <source>The following block contains an example of calling the fts3_tokenizer() function from C code:</source>
          <target state="translated">下面的代码块包含了一个从C代码中调用fts3_tokenizer()函数的例子。</target>
        </trans-unit>
        <trans-unit id="8a513f3e74d7cb1dc9f72503b5eb2053d246b6ad" translate="yes" xml:space="preserve">
          <source>The following block contains examples that use the offsets function.</source>
          <target state="translated">下面的代码块包含了使用偏移量函数的例子。</target>
        </trans-unit>
        <trans-unit id="5c334635414a3c37311f7280f25331d2da05c0d0" translate="yes" xml:space="preserve">
          <source>The following chart shows the substitution types supported by SQLite:</source>
          <target state="translated">下图显示了SQLite支持的替换类型。</target>
        </trans-unit>
        <trans-unit id="16f175b629dac9ff34c51ebace5610e8bb2a6ee9" translate="yes" xml:space="preserve">
          <source>The following compile-time options are recommended for applications that are able to use them, in order to minimized the number of CPU cycles and the bytes of memory used by SQLite. Not all of these compile-time options are usable by every application. For example, the SQLITE_THREADSAFE=0 option is only usable by applications that never access SQLite from more than one thread at a time. And the SQLITE_OMIT_PROGRESS_CALLBACK option is only usable by applications that do not use the &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler()&lt;/a&gt; interface. And so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c06c8d896e801657db8f70d5a5bd2960e6843e64" translate="yes" xml:space="preserve">
          <source>The following compile-time options are recommended for applications that are able to use them, in order to minimized the number of CPU cycles and the bytes of memory used by SQLite. Not all of these compile-time options are usable by every application. For example, the SQLITE_THREADSAFE=0 option is only usable by applications that never access SQLite from more than one thread at a time. And the SQLITE_OMIT_PROGRESS_CALLBACK option is only usable by applications that doe not use the &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler()&lt;/a&gt; interface. And so forth.</source>
          <target state="translated">对于能够使用它们的应用程序，建议使用以下编译时选项，以最大程度地减少CPU周期数和SQLite使用的内存字节。并非每个应用程序都可以使用所有这些编译时选项。例如，SQLITE_THREADSAFE = 0选项仅可用于永远不会一次从多个线程访问SQLite的应用程序。SQLITE_OMIT_PROGRESS_CALLBACK选项仅由不使用&lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler（）&lt;/a&gt;接口的应用程序使用。依此类推。</target>
        </trans-unit>
        <trans-unit id="1f053eef3c13d51d862b4f23cc04af6f84e75626" translate="yes" xml:space="preserve">
          <source>The following constants can be used for the T parameter to the &lt;a href=&quot;#sqlite3_stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus(S,X,T,V)&lt;/a&gt; interface. Each constant designates a different metric for sqlite3_stmt_scanstatus() to return.</source>
          <target state="translated">以下常量可用于&lt;a href=&quot;#sqlite3_stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus（S，X，T，V）&lt;/a&gt;接口的T参数。每个常量为sqlite3_stmt_scanstatus（）返回指定一个不同的度量。</target>
        </trans-unit>
        <trans-unit id="42e5a30e943fe484b45c04468e002affa80c1a88" translate="yes" xml:space="preserve">
          <source>The following constants can be used for the T parameter to the &lt;a href=&quot;stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus(S,X,T,V)&lt;/a&gt; interface. Each constant designates a different metric for sqlite3_stmt_scanstatus() to return.</source>
          <target state="translated">以下常量可用于&lt;a href=&quot;stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus（S，X，T，V）&lt;/a&gt;接口的T参数。每个常量为sqlite3_stmt_scanstatus（）返回指定一个不同的度量。</target>
        </trans-unit>
        <trans-unit id="0dd0f222abc9f123e613d4dc8f011601915507ab" translate="yes" xml:space="preserve">
          <source>The following diagram depicts the format of a segment b-tree interior (non-leaf) node.</source>
          <target state="translated">下图描述了段b树内部(非叶)节点的格式。</target>
        </trans-unit>
        <trans-unit id="24519f5efb1b482cdcbf663c45ec684bda267ab2" translate="yes" xml:space="preserve">
          <source>The following diagram depicts the format of a segment b-tree leaf node.</source>
          <target state="translated">下图描述了段b树叶子节点的格式。</target>
        </trans-unit>
        <trans-unit id="d2d809dec5a64a655b9636ca71424601eda3c8d0" translate="yes" xml:space="preserve">
          <source>The following example code illustrates the techniques described above.</source>
          <target state="translated">下面的示例代码说明了上述技术。</target>
        </trans-unit>
        <trans-unit id="54bdf2a30ded538a716ed8a4baee084a78f8a312" translate="yes" xml:space="preserve">
          <source>The following example creates a new SQL function named &quot;hex&quot; that converts its numeric argument in to a hexadecimal encoded string:</source>
          <target state="translated">下面的示例创建了一个名为 &quot;hex &quot;的新SQL函数,该函数将其数字参数转换为十六进制编码的字符串。</target>
        </trans-unit>
        <trans-unit id="9d4eb7545f22068db9db1145bb2583cae1439f33" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the effect of the various forms of the EXCLUDE clause:</source>
          <target state="translated">下面的例子展示了各种形式的EXCLUDE子句的效果。</target>
        </trans-unit>
        <trans-unit id="3fb64142e08ab04e58bc3d16cc93b9564bb653f2" translate="yes" xml:space="preserve">
          <source>The following example illustrates precedence of operators using the standard query syntax:</source>
          <target state="translated">下面的例子说明了使用标准查询语法的运算符的优先性。</target>
        </trans-unit>
        <trans-unit id="33e08656a40dfd68bcb2d6194c63e1be80dcd4d4" translate="yes" xml:space="preserve">
          <source>The following example illustrates the above. The expressions &quot;docs&quot;, &quot;docs.docs&quot; and &quot;main.docs.docs&quot; all refer to column &quot;docs&quot;. However, the expression &quot;main.docs&quot; does not refer to any column. It could be used to refer to a table, but a table name is not allowed in the context in which it is used below.</source>
          <target state="translated">下面的例子说明了上述情况。表达式 &quot;docs&quot;、&quot;docs.docs &quot;和 &quot;main.docs.docs &quot;都指向列 &quot;docs&quot;。然而,表达式 &quot;main.docs &quot;并不指向任何列。它可以用来指代一个表,但在下面使用它的上下文中,不允许使用表名。</target>
        </trans-unit>
        <trans-unit id="6318f87943b573664a21e50213cf281e74663a27" translate="yes" xml:space="preserve">
          <source>The following example illustrates the behaviour of the five ranking functions - row_number(), rank(), dense_rank(), percent_rank() and cume_dist().</source>
          <target state="translated">下面的例子说明了row_number()、rank()、dense_rank()、percent_rank()和cume_dist()这五个排名函数的行为。</target>
        </trans-unit>
        <trans-unit id="fd2f5de221e0f758d71eb8931f8c7e719ace6200" translate="yes" xml:space="preserve">
          <source>The following example illustrates the effect of using a deferred foreign key constraint.</source>
          <target state="translated">下面的例子说明了使用延迟外键约束的效果。</target>
        </trans-unit>
        <trans-unit id="c39a3730f5c13caef84a726a00ac693030617813" translate="yes" xml:space="preserve">
          <source>The following example shows how to remove NUL character, and all text that follows, from a column of a table. So if you have a database file that contains embedded NULs and you would like to remove them, running UPDATE statements similar to the following might help:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21740a6dff76788fbc521cbbbedbec453f6795d5" translate="yes" xml:space="preserve">
          <source>The following example uses the sumint() function implemented by the above C code. For each row, the window consists of the preceding row (if any), the current row and the following row (again, if any):</source>
          <target state="translated">下面的例子使用了上述C代码实现的sumint()函数。对于每一行,窗口由前一行(如果有的话)、当前一行和后一行(如果有的话)组成。</target>
        </trans-unit>
        <trans-unit id="9b577d330901567bab085337ea84d2a43135e876" translate="yes" xml:space="preserve">
          <source>The following example will better illustrate the use of SQLITE_CONSTRAINT as a return value from xBestIndex:</source>
          <target state="translated">下面的例子可以更好地说明SQLITE_CONSTRAINT作为xBestIndex的返回值的使用。</target>
        </trans-unit>
        <trans-unit id="3f5880fbaaf652f0861c35b2ed9bf834e8800e30" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 4th parameter to &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt; and &lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt;:</source>
          <target state="translated">以下标志可以通过第4个参数传递给&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt;和&lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="dcb818ec6ae695589b5e698d66cbb55415f5689e" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 4th parameter to &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt; and &lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt;:</source>
          <target state="translated">以下标志可以通过第4个参数传递给&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt;和&lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="eaf06e6487557d77e67f76618b64eb4b39aae85e" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 9th parameter to &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt; and &lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt;:</source>
          <target state="translated">以下标志可以通过第9个参数传递给&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt;和&lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="8acfd72cc7dc7df0be4ef94764fa15b5b7e0e403" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 9th parameter to &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt; and &lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt;:</source>
          <target state="translated">以下标志可以通过第9个参数传递给&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt;和&lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="90a5abe74323cb727451a1fc89d79f6674e34a04" translate="yes" xml:space="preserve">
          <source>The following four configuration changes are recommended for maximum application security. Turning off the trust_schema setting prevents virtual tables and dodgy SQL functions from being used inside of triggers, views, CHECK constraints, generated columns, and expression indexes. Turning off the dqs_dml and dqs_ddl settings prevents the use of double-quoted strings. Turning on defensive prevents direct writes to shadow tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f88559c5309089b2c53eff7ab551567dc8265aad" translate="yes" xml:space="preserve">
          <source>The following functions can be used to advance and query a changeset iterator created by this function:</source>
          <target state="translated">以下函数可以用来推进和查询由该函数创建的变化集迭代器。</target>
        </trans-unit>
        <trans-unit id="35f53ac017499b71e5f28f348a1b347ee5939139" translate="yes" xml:space="preserve">
          <source>The following is a log of all SQL used to generate one particular timeline (captured on 2016-09-16):</source>
          <target state="translated">以下是用于生成一个特定时间轴的所有SQL的日志(捕获于2016-09-16)。</target>
        </trans-unit>
        <trans-unit id="8ca654574638bb42c5b323e2fbbcf528a1c97560" translate="yes" xml:space="preserve">
          <source>The following is a partial list of the kinds of messages that might appear in the error logger callback.</source>
          <target state="translated">以下是可能出现在错误记录器回调中的部分消息类型列表。</target>
        </trans-unit>
        <trans-unit id="91f9f5074c39cae7458cb274b5e2472dd1f18791" translate="yes" xml:space="preserve">
          <source>The following is a random assortment of techniques used by the SQLite developers to trace, examine, and understand the behavior of the core SQLite library.</source>
          <target state="translated">以下是SQLite开发人员用来跟踪、检查和了解核心SQLite库行为的随机分类技术。</target>
        </trans-unit>
        <trans-unit id="172b7cc8402676bd9591f1901c350fe56e3b1a3a" translate="yes" xml:space="preserve">
          <source>The following is sqlite3_analyzer output for an example places.sqlite database used by Firefox.</source>
          <target state="translated">下面是sqlite3_analyzer对Firefox使用的一个例子places.sqlite数据库的输出。</target>
        </trans-unit>
        <trans-unit id="3b9bb38ec5e22c57b0f7c289494707329a29a947" translate="yes" xml:space="preserve">
          <source>The following limitations apply to RBU updates:</source>
          <target state="translated">以下限制适用于区域局的更新:</target>
        </trans-unit>
        <trans-unit id="fc2fda4c09167d54864b95b318f076cb56ce31c3" translate="yes" xml:space="preserve">
          <source>The following macros specify interface linkage for certain kinds of SQLite builds. The Makefiles will normally handle setting these macros automatically. Application developers should not need to worry with these macros. The following documentation about these macros is included completeness.</source>
          <target state="translated">下面的宏指定了某些类型的 SQLite 编译的接口链接。通常Makefiles会自动处理这些宏的设置。应用程序开发人员不需要担心这些宏。以下是关于这些宏的完整文档。</target>
        </trans-unit>
        <trans-unit id="e520cf121083171350ce54bdc25d9fb94f2ae9df" translate="yes" xml:space="preserve">
          <source>The following must be true for this function to succeed. If any of the following statements are false when sqlite3_snapshot_get() is called, SQLITE_ERROR is returned. The final value of *P is undefined in this case.</source>
          <target state="translated">为了使这个函数成功,以下语句必须为真。如果调用sqlite3_snapshot_get()时,以下任何一条语句为假,则返回SQLITE_ERROR。在这种情况下,*P的最终值是未定义的。</target>
        </trans-unit>
        <trans-unit id="13b4c313c53ce999997969a2a1da623479829206" translate="yes" xml:space="preserve">
          <source>The following options can be used to &lt;a href=&quot;footprint&quot;&gt;reduce the size of the compiled library&lt;/a&gt; by omitting unused features. This is probably only useful in embedded systems where space is especially tight, as even with all features included the SQLite library is relatively small. Don't forget to tell your compiler to optimize for binary size! (the -Os option if using GCC). Telling your compiler to optimize for size usually has a much larger impact on library footprint than employing any of these compile-time options. You should also verify that &lt;a href=&quot;#debugoptions&quot;&gt;debugging options&lt;/a&gt; are disabled.</source>
          <target state="translated">以下选项可用于通过省略未使用的功能来&lt;a href=&quot;footprint&quot;&gt;减小编译库的大小&lt;/a&gt;。这可能仅在空间特别狭窄的嵌入式系统中有用，因为即使包括了所有功能，SQLite库也相对较小。不要忘记告诉编译器针对二进制大小进行优化！（如果使用GCC，则为-Os选项）。与使用任何这些编译时选项相比，告诉编译器进行大小优化通常对库占用空间的影响要大得多。您还应该验证&lt;a href=&quot;#debugoptions&quot;&gt;调试选项&lt;/a&gt;是否已禁用。</target>
        </trans-unit>
        <trans-unit id="aa7c844b688230c89a2857560379c0f551e0b077" translate="yes" xml:space="preserve">
          <source>The following query computes an approximation of the Mandelbrot Set and outputs the result as ASCII-art:</source>
          <target state="translated">下面的查询计算了Mandelbrot Set的近似值,并将结果输出为ASCII-art。</target>
        </trans-unit>
        <trans-unit id="165c7c17f77322908874e60dfb0fb76218a06202" translate="yes" xml:space="preserve">
          <source>The following query parameters are recognized by SQLite as of &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;version 3.15.0&lt;/a&gt; (2016-10-14). New query parameters might be added in the future.</source>
          <target state="translated">SQLite从&lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;版本3.15.0&lt;/a&gt;（2016-10-14）起可以识别以下查询参数。将来可能会添加新的查询参数。</target>
        </trans-unit>
        <trans-unit id="482aaeeca1acb6ff828caa9e341d537cef50e256" translate="yes" xml:space="preserve">
          <source>The following query returns all integers between 1 and 1000000:</source>
          <target state="translated">下面的查询返回1到1000000之间的所有整数。</target>
        </trans-unit>
        <trans-unit id="df61dccd4718a46758145386ef91e3af7a125626" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 1 of the above procedure in more detail.</source>
          <target state="translated">以下要求更详细地描述了上述程序的步骤1。</target>
        </trans-unit>
        <trans-unit id="c7e0a9c1d2e39a35866f813a7b58e616f8a0dfa1" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 2 of the above procedure in more detail.</source>
          <target state="translated">以下要求更详细地描述了上述程序的第2步。</target>
        </trans-unit>
        <trans-unit id="ab60a1fc45053970e49cb2236072b7574ce682f2" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 3 of the above procedure in more detail.</source>
          <target state="translated">以下要求更详细地描述了上述程序的第3步。</target>
        </trans-unit>
        <trans-unit id="0f5ce0f453d6b71b276dab07b31a916fac2ad143" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 4 of the above procedure in more detail.</source>
          <target state="translated">以下要求更详细地描述了上述程序的步骤4。</target>
        </trans-unit>
        <trans-unit id="ff1604c4fd7473773943aa62c8883c18d8179ef1" translate="yes" xml:space="preserve">
          <source>The following requirements describe the steps enumerated above in more detail.</source>
          <target state="translated">以下要求更详细地描述了上述步骤。</target>
        </trans-unit>
        <trans-unit id="ca6589a3a75bae1a771049671e8297b9c43f424f" translate="yes" xml:space="preserve">
          <source>The following restrictions apply to DELETE statements that occur within the body of a &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement:</source>
          <target state="translated">以下限制适用于在&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;语句内出现的DELETE 语句：</target>
        </trans-unit>
        <trans-unit id="1404887613e3d3d478c15bfa20064138fe1f758d" translate="yes" xml:space="preserve">
          <source>The following routines are used to implement user-defined collating sequences:</source>
          <target state="translated">以下例程用于实现用户定义的整理序列。</target>
        </trans-unit>
        <trans-unit id="9d61d2cb84c2da7119bdaa99ad1c2d7a32c4afe9" translate="yes" xml:space="preserve">
          <source>The following rules and caveats apply to the values specified as part of each INSERT statement:</source>
          <target state="translated">以下规则和注意事项适用于作为每个INSERT语句的一部分而指定的值。</target>
        </trans-unit>
        <trans-unit id="a26a29856749163d9eb4f80a667633bb87f813e9" translate="yes" xml:space="preserve">
          <source>The following rules show how each of the locks is used.</source>
          <target state="translated">下面的规则说明了各锁的使用方法。</target>
        </trans-unit>
        <trans-unit id="737ea9fa3e70c97a0a7b4c9228ebcdc9127f52cb" translate="yes" xml:space="preserve">
          <source>The following scenario illustrates how an SQLITE_BUSY_SNAPSHOT error might arise:</source>
          <target state="translated">下面的场景说明了SQLITE_BUSY_SNAPSHOT错误如何产生。</target>
        </trans-unit>
        <trans-unit id="4840312a4c02316c9bb1b228254597da9db65628" translate="yes" xml:space="preserve">
          <source>The following script was used to gather information for the table above.</source>
          <target state="translated">以下脚本用于收集上表的信息。</target>
        </trans-unit>
        <trans-unit id="5f95a6062676138baa336da2cd5b1ec87382d19c" translate="yes" xml:space="preserve">
          <source>The following section describes the API offered to auxiliary function implementations in detail. Further examples may be found in the &quot;fts5_aux.c&quot; file of the source code.</source>
          <target state="translated">下面一节详细描述了提供给辅助函数实现的API。更多的例子可以在源代码的 &quot;fts5_aux.c &quot;文件中找到。</target>
        </trans-unit>
        <trans-unit id="c91d01efc0ba3649e7eacbf59f700342ec3a53a5" translate="yes" xml:space="preserve">
          <source>The following sections describe some low-level details of the R*Tree implementation, that might be useful for trouble-shooting or performance analysis.</source>
          <target state="translated">下面的章节描述了R*Tree实现的一些低级细节,这些细节可能对故障排除或性能分析有用。</target>
        </trans-unit>
        <trans-unit id="17e43452198f5289d975fb07abeb874782ed48a0" translate="yes" xml:space="preserve">
          <source>The following sections describe the supported parameters. Specifying an unrecognized parameter name is an error.</source>
          <target state="translated">下面的章节描述了支持的参数。指定一个未被识别的参数名称是一个错误。</target>
        </trans-unit>
        <trans-unit id="009cc36fd7239429da331a5197a208b717cdb22a" translate="yes" xml:space="preserve">
          <source>The following sections provide additional detail on the operation of the various functions that are part of the json1 extension.</source>
          <target state="translated">下面的章节提供了关于json1扩展中各种函数操作的额外细节。</target>
        </trans-unit>
        <trans-unit id="0b996a91eae66dcc3a2860511963eb7fa7efc7eb" translate="yes" xml:space="preserve">
          <source>The following syntax documentation topics are available:</source>
          <target state="translated">以下是语法文档主题。</target>
        </trans-unit>
        <trans-unit id="0e5fa08cf1724f31556de517effc85351bb377ec" translate="yes" xml:space="preserve">
          <source>The following table shows how many common datatype names from more traditional SQL implementations are converted into affinities by the five rules of the previous section. This table shows only a small subset of the datatype names that SQLite will accept. Note that numeric arguments in parentheses that following the type name (ex: &quot;VARCHAR(255)&quot;) are ignored by SQLite - SQLite does not impose any length restrictions (other than the large global &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; limit) on the length of strings, BLOBs or numeric values.</source>
          <target state="translated">下表显示了通过上一节的五个规则将更传统的SQL实现中的多少个通用数据类型名称转换为关联性。该表仅显示SQLite将接受的数据类型名称的一小部分。请注意，SQLite会忽略类型名称后面的括号中的数字参数（例如：&amp;ldquo; VARCHAR（255）&amp;rdquo;）-SQLite不会对字符串，BLOB或字符串的长度施加任何长度限制（大的全局&lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;限制除外）。数值。</target>
        </trans-unit>
        <trans-unit id="54c0ab33937bb3d0205754132a184edc97ac8f8b" translate="yes" xml:space="preserve">
          <source>The following table shows the meanings of the (non-hidden) columns of DBSTAT in both normal and aggregated mode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54feeefe0d9e52f7880c035de3af5b0398710d6a" translate="yes" xml:space="preserve">
          <source>The following table shows the results of the NULL handling experiments.</source>
          <target state="translated">下表是NULL处理实验的结果。</target>
        </trans-unit>
        <trans-unit id="12e0a00ef75b703780c84d1074e0287b2f403501" translate="yes" xml:space="preserve">
          <source>The following table summarizes the SQLite file format changes that have occurred since version 1.0.0:</source>
          <target state="translated">下表总结了自1.0.0版本以来发生的SQLite文件格式变化。</target>
        </trans-unit>
        <trans-unit id="ea82e2bbe8fed4a7a8a0361c062cdbf2a7cb2e1f" translate="yes" xml:space="preserve">
          <source>The following two objects and eight methods comprise the essential elements of the SQLite interface:</source>
          <target state="translated">以下两个对象和八个方法构成了SQLite接口的基本元素。</target>
        </trans-unit>
        <trans-unit id="1b3057a8ce2692f0addf4973e487586ba5e334ab" translate="yes" xml:space="preserve">
          <source>The foregoing is all one really needs to know in order to use SQLite effectively. All the rest is optimization and detail.</source>
          <target state="translated">以上就是一个人真正需要知道的所有内容,以便有效地使用SQLite。剩下的都是优化和细节。</target>
        </trans-unit>
        <trans-unit id="75a22928178fbb3c0cbb048a8ad2cc0d5b3170b7" translate="yes" xml:space="preserve">
          <source>The foregoing text describes low-level aspects of the SQLite file format. The b-tree mechanism provides a powerful and efficient means of accessing a large data set. This section will describe how the low-level b-tree layer is used to implement higher-level SQL capabilities.</source>
          <target state="translated">前文介绍了SQLite文件格式的低级方面。b-tree机制提供了一种强大而高效的访问大型数据集的方法。本节将描述如何使用低级的b-tree层来实现更高级别的SQL功能。</target>
        </trans-unit>
        <trans-unit id="12199f4a726aab3fb6304db80ece6cf69a955319" translate="yes" xml:space="preserve">
          <source>The foreign key constraint is satisfied if for each row in the child table either one or more of the child key columns are NULL, or there exists a row in the parent table for which each parent key column contains a value equal to the value in its associated child key column.</source>
          <target state="translated">如果对于子表中的每条记录,有一个或多个子键列是NULL,或者在父表中存在一条记录,其中每个父键列包含的值等于其相关联的子键列中的值,则满足外键约束。</target>
        </trans-unit>
        <trans-unit id="7eb5b173b9130668a2a0b17e4f207640eaa017f0" translate="yes" xml:space="preserve">
          <source>The foreign key constraints created as part of tables</source>
          <target state="translated">作为表的一部分创建的外键约束</target>
        </trans-unit>
        <trans-unit id="add6cc21a0d1ec9f3c982acde6cc5dc3f05465f0" translate="yes" xml:space="preserve">
          <source>The foreign_key_check pragma checks the database, or the table called &quot;</source>
          <target state="translated">foreign_key_check pragma检查数据库,或者说检查名为&quot;&quot;的表。</target>
        </trans-unit>
        <trans-unit id="9efc16f15cca4547a2a6b1e6f0aea092764cfc35" translate="yes" xml:space="preserve">
          <source>The formalized assumptions in this section refer to</source>
          <target state="translated">本节的形式化假设是指</target>
        </trans-unit>
        <trans-unit id="fe9496c466bbe179ee18ac47ed69a346233c9cbd" translate="yes" xml:space="preserve">
          <source>The format for sqlite_stat2 is recorded here for legacy reference. Recent versions of SQLite no longer support sqlite_stat2 and the sqlite_stat2 table, if is exists, is simply ignored.</source>
          <target state="translated">这里记录了sqlite_stat2的格式,供旧版本参考。最新版本的SQLite不再支持sqlite_stat2,如果sqlite_stat2表存在,则直接忽略。</target>
        </trans-unit>
        <trans-unit id="d2a469c667d3464f2b4b57e3f59fb88c3da53ff2" translate="yes" xml:space="preserve">
          <source>The format of a cell depends on which kind of b-tree page the cell appears on. The following table shows the elements of a cell, in order of appearance, for the various b-tree page types.</source>
          <target state="translated">单元格的格式取决于单元格出现在哪种类型的b-tree页面上。下表显示了单元格的元素,按出现的顺序排列,适用于各种b-tree页面类型。</target>
        </trans-unit>
        <trans-unit id="8f6ebed1965bbd7f7af8c4c0949451b7c054d06f" translate="yes" xml:space="preserve">
          <source>The format of the arguments to the module is very general. Each module-argument may contain keywords, string literals, identifiers, numbers, and punctuation. Each module-argument is passed as written (as text) into the &lt;a href=&quot;vtab#xcreate&quot;&gt;constructor method&lt;/a&gt; of the virtual table implementation when the virtual table is created and that constructor is responsible for parsing and interpreting the arguments. The argument syntax is sufficiently general that a virtual table implementation can, if it wants to, interpret its arguments as &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definitions&lt;/a&gt; in an ordinary &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. The implementation could also impose some other interpretation on the arguments.</source>
          <target state="translated">模块参数的格式非常通用。每个模块参数可以包含关键字，字符串文字，标识符，数字和标点符号。创建虚拟表时，每个模块参数都以书面形式（作为文本）传递到虚拟表实现的&lt;a href=&quot;vtab#xcreate&quot;&gt;构造函数方法&lt;/a&gt;中，并且该构造函数负责解析和解释参数。参数语法足够通用，因此虚拟表实现可以在普通&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句中将其参数解释为&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;列定义&lt;/a&gt;。该实现还可以对参数进行其他解释。</target>
        </trans-unit>
        <trans-unit id="ce6813c51545b0e36cbda5b5ae9abe31c78f2212" translate="yes" xml:space="preserve">
          <source>The format of the main database file is as described in the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; document. The &lt;a href=&quot;fileformat2#vnums&quot;&gt;file format version numbers&lt;/a&gt; at offsets 18 and 19 into the main database must both be 2 to indicate that the database is in WAL mode. The main database may have an arbitrary name allowed by the underlying filesystem. No special file suffixes are required, though &quot;.db&quot;, &quot;.sqlite&quot;, and &quot;.sqlite3&quot; seem to be popular choices.</source>
          <target state="translated">主数据库文件的格式如&lt;a href=&quot;fileformat2&quot;&gt;文件格式&lt;/a&gt;文档中所述。主数据库中偏移量18和19 的&lt;a href=&quot;fileformat2#vnums&quot;&gt;文件格式版本号&lt;/a&gt;都必须均为2，以指示数据库处于WAL模式。主数据库可以具有基础文件系统允许的任意名称。尽管&amp;ldquo; .db&amp;rdquo;，&amp;ldquo;。sqlite&amp;rdquo;和&amp;ldquo; .sqlite3&amp;rdquo;似乎是流行的选择，但不需要特殊的文件后缀。</target>
        </trans-unit>
        <trans-unit id="c748249cfa33fdfdfb8560eb0a7a2d06c6a7130e" translate="yes" xml:space="preserve">
          <source>The format string for printf() is a template for the generated string. Substitutions are made whenever a &quot;%&quot; character appears in the format string. The &quot;%&quot; is followed by one or more additional characters that describe the substitution. Each substitution has the following format:</source>
          <target state="translated">printf()的格式字符串是生成字符串的模板。每当格式字符串中出现&quot;%&quot;字符时,就会进行替换。%&quot;后面是一个或多个描述替换的附加字符。每个替换的格式如下。</target>
        </trans-unit>
        <trans-unit id="e5481902d614e43b8906fc140d4dc2a9c7914623" translate="yes" xml:space="preserve">
          <source>The format used by SQLite database files has been completely revised. The old version 2.1 format and the new 3.0 format are incompatible with one another. Version 2.8 of SQLite will not read a version 3.0 database files and version 3.0 of SQLite will not read a version 2.8 database file.</source>
          <target state="translated">SQLite数据库文件所使用的格式已经被彻底修改。旧的2.1版格式和新的3.0版格式是不兼容的,2.8版的SQLite不能读取3.0版的数据库文件,3.0版的SQLite不能读取2.8版的数据库文件。2.8版本的SQLite无法读取3.0版本的数据库文件,3.0版本的SQLite无法读取2.8版本的数据库文件。</target>
        </trans-unit>
        <trans-unit id="a376c207dbbf638ec2db0cb626e4c46931a236b1" translate="yes" xml:space="preserve">
          <source>The fossil delta format may only be used to update BLOB values. Instead of storing the new BLOB within the data_% table, the fossil delta is stored instead. And instead of specifying an 'x' as part of the rbu_control string for the column to be updated, an 'f' character is stored. When processing an 'f' update, RBU loads the original BLOB data from disk, applies the fossil delta to it and stores the results back into the database file. The RBU databases generated by &lt;a href=&quot;rbu#sqldiff&quot;&gt;sqldiff --rbu&lt;/a&gt; make use of fossil deltas wherever doing so would save space in the RBU database.</source>
          <target state="translated">化石增量格式只能用于更新BLOB值。代替存储新的BLOB在data_％表中，而是存储化石增量。并且，不是在要更新的列的rbu_control字符串的一部分中指定&amp;ldquo; x&amp;rdquo;，而是存储了&amp;ldquo; f&amp;rdquo;字符。在处理&amp;ldquo; f&amp;rdquo;更新时，RBU从磁盘加载原始BLOB数据，对其应用化石增量并将结果存储回数据库文件中。&lt;a href=&quot;rbu#sqldiff&quot;&gt;sqldiff --rbu&lt;/a&gt;生成的RBU数据库在任何地方都可以利用化石三角洲，从而节省RBU数据库中的空间。</target>
        </trans-unit>
        <trans-unit id="23a39933682f9054d9fbfd81554ffb9e23300f95" translate="yes" xml:space="preserve">
          <source>The founder of SQLite and all current developers have pledged to follow spirit of The Rule to the best of their ability. They view The Rule as their promise to all SQLite users of how the developers are expected to behave in community. This is a one-way promise, or covenant. In other words, the developers are saying: &quot;We will treat you this way regardless of how you treat us.&quot;</source>
          <target state="translated">SQLite的创始人和所有当前的开发者都承诺将尽其所能地遵循The Rule的精神。他们认为The Rule是他们对所有SQLite用户的承诺,即开发者在社区中应该如何行事。这是一个单向的承诺,或者说是契约。换句话说,开发者们在说 &quot;无论你如何对待我们,我们都会这样对待你。&quot;</target>
        </trans-unit>
        <trans-unit id="fac57078ba906f356fde5d5be039fc86e66f550e" translate="yes" xml:space="preserve">
          <source>The founder of SQLite, and all of the current developers at the time when this document was composed, have pledged to govern their interactions with each other, with their clients, and with the larger SQLite user community in accordance with the &quot;instruments of good works&quot; from chapter 4 of &lt;a href=&quot;https://en.wikipedia.org/wiki/Rule_of_Saint_Benedict&quot;&gt;The Rule of St. Benedict&lt;/a&gt; (hereafter: &quot;The Rule&quot;). This code of ethics has proven its mettle in thousands of diverse communities for over 1,500 years, and has served as a baseline for many civil law codes since the time of Charlemagne.</source>
          <target state="translated">SQLite的创始人以及撰写本文档时的所有当前开发人员已保证按照&amp;ldquo;好的工具&amp;rdquo;来管理彼此之间，与他们的客户以及与更大的SQLite用户社区之间的交互。 &amp;rdquo;摘自&lt;a href=&quot;https://en.wikipedia.org/wiki/Rule_of_Saint_Benedict&quot;&gt;《圣本尼迪克特规则&lt;/a&gt;》第4章（以下简称&amp;ldquo;规则&amp;rdquo;）。超过1500年以来，该道德准则已在数千个不同社区中证明了自己的才能，并且自查理曼大帝时代以来便已成为许多民法准则的基准。</target>
        </trans-unit>
        <trans-unit id="555d8586503882b041c2a8a309c2f9e999580160" translate="yes" xml:space="preserve">
          <source>The four utility functions</source>
          <target state="translated">四个效用函数</target>
        </trans-unit>
        <trans-unit id="6cfb5a37e3c4d212e2442aae712218c04b105dd5" translate="yes" xml:space="preserve">
          <source>The four-byte page number at offset 8 is the right-most pointer. This value appears in the header of interior b-tree pages only and is omitted from all other pages.</source>
          <target state="translated">偏移量8的4字节页码是最右边的指针。这个值只出现在内部b-tree页的页眉中,所有其他页面都被省略。</target>
        </trans-unit>
        <trans-unit id="76f618a5029c6002ebdae975ee6043d888618d19" translate="yes" xml:space="preserve">
          <source>The fourth argument (xFilter) passed to these functions is the &quot;filter callback&quot;. If it is not NULL, then for each table affected by at least one change in the changeset, the filter callback is invoked with the table name as the second argument, and a copy of the context pointer passed as the sixth argument as the first. If the &quot;filter callback&quot; returns zero, then no attempt is made to apply any changes to the table. Otherwise, if the return value is non-zero or the xFilter argument to is NULL, all changes related to the table are attempted.</source>
          <target state="translated">传递给这些函数的第四个参数(xFilter)是 &quot;过滤器回调&quot;。如果它不是NULL,那么对于每个受变化集中至少一个变化影响的表,过滤器回调将被调用,表名作为第二个参数,第六个参数传递的上下文指针的副本作为第一个参数。如果 &quot;过滤器回调 &quot;返回值为0,则不尝试对表应用任何更改。否则,如果返回值为非零或者xFilter参数为NULL,则会尝试对表进行所有相关的更改。</target>
        </trans-unit>
        <trans-unit id="999f04c49ef94f8766fa9cb6bb9bbba18afe2ece" translate="yes" xml:space="preserve">
          <source>The fourth argument, pArg, is an application data pointer that is passed through as the first argument to the collating function callback.</source>
          <target state="translated">第四个参数pArg是一个应用数据指针,作为整理函数回调的第一个参数通过。</target>
        </trans-unit>
        <trans-unit id="c6b1934196a189db01281779b0c51a4b66faf522" translate="yes" xml:space="preserve">
          <source>The fourth column is the maximum value of any rowid in the table.</source>
          <target state="translated">第四列是表中任何rowid的最大值。</target>
        </trans-unit>
        <trans-unit id="69cc3b7ae5b0c474135cb2e440fa03951919eaf0" translate="yes" xml:space="preserve">
          <source>The fourth parameter may also optionally include the &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag, which if present prevents the function from being invoked from within VIEWs or TRIGGERs. For security reasons, the &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag is recommended for any application-defined SQL function that has side-effects.</source>
          <target state="translated">第四个参数还可以选择包含&lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;标志，如果存在该标志，则防止从VIEW或TRIGGER内部调用该函数。出于安全原因，建议将&lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;标志用于任何有副作用的应用程序定义的SQL函数。</target>
        </trans-unit>
        <trans-unit id="c1fbaaa3083276ec5194db2d1a793d5691751026" translate="yes" xml:space="preserve">
          <source>The fourth parameter may also optionally include the &lt;a href=&quot;#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag, which if present prevents the function from being invoked from within VIEWs, TRIGGERs, CHECK constraints, generated column expressions, index expressions, or the WHERE clause of partial indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52c4099bf56a2a098b10ec045515f7e30e89130" translate="yes" xml:space="preserve">
          <source>The fourth parameter may also optionally include the &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag, which if present prevents the function from being invoked from within VIEWs or TRIGGERs. For security reasons, the &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag is recommended for any application-defined SQL function that has side-effects.</source>
          <target state="translated">第四个参数还可以选择包含&lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;标志，如果存在该标志，则防止从VIEW或TRIGGER内部调用该函数。出于安全原因，建议将&lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;标志用于任何有副作用的应用程序定义的SQL函数。</target>
        </trans-unit>
        <trans-unit id="67ad2195f1817b78a8b4837501855037b255117b" translate="yes" xml:space="preserve">
          <source>The fourth parameter may also optionally include the &lt;a href=&quot;c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag, which if present prevents the function from being invoked from within VIEWs, TRIGGERs, CHECK constraints, generated column expressions, index expressions, or the WHERE clause of partial indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="649add83c8043b4bf2ea6e4b6cf49a7fdf941dff" translate="yes" xml:space="preserve">
          <source>The fourth parameter may optionally be ORed with &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; to signal that the function will always return the same result given the same inputs within a single SQL statement. Most SQL functions are deterministic. The built-in &lt;a href=&quot;lang_corefunc#random&quot;&gt;random()&lt;/a&gt; SQL function is an example of a function that is not deterministic. The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is recommended where possible.</source>
          <target state="translated">可以选择将第四个参数与&lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;进行&amp;ldquo;或&amp;rdquo;运算，以表明在给定单个SQL语句中相同的输入的情况下，该函数将始终返回相同的结果。大多数SQL函数都是确定性的。内置的&lt;a href=&quot;lang_corefunc#random&quot;&gt;random（）&lt;/a&gt; SQL函数是不确定性函数的一个示例。 SQLite查询计划程序能够对确定性函数执行其他优化，因此建议尽可能使用&lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;标志。</target>
        </trans-unit>
        <trans-unit id="6481c8ccbbe2254925779028e6672b2de9b23312" translate="yes" xml:space="preserve">
          <source>The fourth parameter may optionally be ORed with &lt;a href=&quot;#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; to signal that the function will always return the same result given the same inputs within a single SQL statement. Most SQL functions are deterministic. The built-in &lt;a href=&quot;lang_corefunc#random&quot;&gt;random()&lt;/a&gt; SQL function is an example of a function that is not deterministic. The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the &lt;a href=&quot;#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is recommended where possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="658cc43bdf2652e8cf4b2cffdcf6459b264f185d" translate="yes" xml:space="preserve">
          <source>The fourth parameter may optionally be ORed with &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; to signal that the function will always return the same result given the same inputs within a single SQL statement. Most SQL functions are deterministic. The built-in &lt;a href=&quot;../lang_corefunc#random&quot;&gt;random()&lt;/a&gt; SQL function is an example of a function that is not deterministic. The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is recommended where possible.</source>
          <target state="translated">可以选择将第四个参数与&lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;进行&amp;ldquo;或&amp;rdquo;运算，以表明在给定单个SQL语句中相同的输入的情况下，该函数将始终返回相同的结果。大多数SQL函数都是确定性的。内置的&lt;a href=&quot;../lang_corefunc#random&quot;&gt;random（）&lt;/a&gt; SQL函数是不确定性函数的一个示例。 SQLite查询计划程序能够对确定性函数执行其他优化，因此建议尽可能使用&lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;标志。</target>
        </trans-unit>
        <trans-unit id="7980c4f3a8ec7ae6d00b95c7cb68067b43db4da9" translate="yes" xml:space="preserve">
          <source>The fourth parameter may optionally be ORed with &lt;a href=&quot;c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; to signal that the function will always return the same result given the same inputs within a single SQL statement. Most SQL functions are deterministic. The built-in &lt;a href=&quot;../lang_corefunc#random&quot;&gt;random()&lt;/a&gt; SQL function is an example of a function that is not deterministic. The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the &lt;a href=&quot;c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is recommended where possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feefd1b9ff1b8c4a1a74b3c8f0c879ca3de261f9" translate="yes" xml:space="preserve">
          <source>The fourth parameter to sqlite3_open_v2() is the name of the &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object that defines the operating system interface that the new database connection should use. If the fourth parameter is a NULL pointer then the default &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is used.</source>
          <target state="translated">sqlite3_open_v2（）的第四个参数是&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的名称，该对象定义新数据库连接应使用的操作系统接口。如果第四个参数是NULL指针，则使用默认的&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="b7bbbda582299a1f3186b36dde756d304b0fa7e6" translate="yes" xml:space="preserve">
          <source>The fourth parameter to sqlite3_open_v2() is the name of the &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object that defines the operating system interface that the new database connection should use. If the fourth parameter is a NULL pointer then the default &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is used.</source>
          <target state="translated">sqlite3_open_v2（）的第四个参数是&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的名称，该对象定义新数据库连接应使用的操作系统接口。如果第四个参数是NULL指针，则使用默认的&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="d063d165e08786a1b7ee913cfa396d1655f4a730" translate="yes" xml:space="preserve">
          <source>The fourth parameter, eTextRep, specifies what &lt;a href=&quot;#SQLITE_ANY&quot;&gt;text encoding&lt;/a&gt; this SQL function prefers for its parameters. The application should set this parameter to &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; if the function implementation invokes &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16le()&lt;/a&gt; on an input, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; if the implementation invokes &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16be()&lt;/a&gt; on an input, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; if &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; is used, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt; otherwise. The same SQL function may be registered multiple times using different preferred text encodings, with different implementations for each encoding. When multiple implementations of the same function are available, SQLite will pick the one that involves the least amount of data conversion.</source>
          <target state="translated">第四个参数eTextRep指定此SQL函数首选使用哪种&lt;a href=&quot;#SQLITE_ANY&quot;&gt;文本编码&lt;/a&gt;。该应用程序应此参数设置为&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;如果函数实现调用&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16le（）&lt;/a&gt;的输入，或&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;如果实现调用&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16be（）&lt;/a&gt;的输入，或&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;如果&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16（）&lt;/a&gt;被使用，或&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;除此以外。相同的SQL函数可以使用不同的首选文本编码多次注册，每种编码具有不同的实现方式。当同一功能的多个实现可用时，SQLite将选择涉及最少数据转换量的实现。</target>
        </trans-unit>
        <trans-unit id="57c66b621bee32c598b5cb9d09e4c1e1ae3f09dc" translate="yes" xml:space="preserve">
          <source>The fourth parameter, eTextRep, specifies what &lt;a href=&quot;c_any&quot;&gt;text encoding&lt;/a&gt; this SQL function prefers for its parameters. The application should set this parameter to &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; if the function implementation invokes &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16le()&lt;/a&gt; on an input, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; if the implementation invokes &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16be()&lt;/a&gt; on an input, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; if &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; is used, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt; otherwise. The same SQL function may be registered multiple times using different preferred text encodings, with different implementations for each encoding. When multiple implementations of the same function are available, SQLite will pick the one that involves the least amount of data conversion.</source>
          <target state="translated">第四个参数eTextRep指定此SQL函数首选使用哪种&lt;a href=&quot;c_any&quot;&gt;文本编码&lt;/a&gt;。该应用程序应此参数设置为&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;如果函数实现调用&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16le（）&lt;/a&gt;的输入，或&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;如果实现调用&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16be（）&lt;/a&gt;的输入，或&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;如果&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16（）&lt;/a&gt;被使用，或&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;除此以外。相同的SQL函数可以使用不同的首选文本编码多次注册，每种编码具有不同的实现方式。当同一功能的多个实现可用时，SQLite将选择涉及最少数据转换量的实现。</target>
        </trans-unit>
        <trans-unit id="cdeeaf74a0034cfafd692646911468eeef688545" translate="yes" xml:space="preserve">
          <source>The fragment is optional. If present, it is ignored.</source>
          <target state="translated">该片段是可选的。如果存在,则会被忽略。</target>
        </trans-unit>
        <trans-unit id="36f14f55d888327ce43d396d69903a3ff7fd8e07" translate="yes" xml:space="preserve">
          <source>The frame boundary is the first row in the &lt;a href=&quot;windowfunctions#ptxn&quot;&gt;partition&lt;/a&gt;.</source>
          <target state="translated">框架边界是&lt;a href=&quot;windowfunctions#ptxn&quot;&gt;分区中&lt;/a&gt;的第一行。</target>
        </trans-unit>
        <trans-unit id="3a03f5ecd3e39afb46315f6d23c888ecf09dac7b" translate="yes" xml:space="preserve">
          <source>The frame boundary is the last row in the &lt;a href=&quot;windowfunctions#ptxn&quot;&gt;partition&lt;/a&gt;.</source>
          <target state="translated">框架边界是&lt;a href=&quot;windowfunctions#ptxn&quot;&gt;分区中&lt;/a&gt;的最后一行。</target>
        </trans-unit>
        <trans-unit id="d8ad39ba6054748efcf881cf5f3cfd24dafacebd" translate="yes" xml:space="preserve">
          <source>The frame-spec determines which output rows are read by an aggregate window function. The frame-spec consists of four parts:</source>
          <target state="translated">Frame-spec决定了集合窗口函数读取哪些输出行。框架规格由四个部分组成:</target>
        </trans-unit>
        <trans-unit id="8eb0b0542bfd6ed405e2b53c332150eda864217a" translate="yes" xml:space="preserve">
          <source>The freelist is organized as a linked list of freelist trunk pages with each trunk page containing page numbers for zero or more freelist leaf pages.</source>
          <target state="translated">自由列表的组织形式是自由列表主干页的链接列表,每个主干页包含零或多个自由列表叶页的页码。</target>
        </trans-unit>
        <trans-unit id="4faa37aa2595b1d3bc75280cd8996cd072597ac3" translate="yes" xml:space="preserve">
          <source>The fts3tokenize virtual table can be used on any tokenizer, regardless of whether or not there exists an FTS3 or FTS4 table that actually uses that tokenizer.</source>
          <target state="translated">fts3tokenize 虚拟表可以在任何标记器上使用,无论是否存在实际使用该标记器的 FTS3 或 FTS4 表。</target>
        </trans-unit>
        <trans-unit id="346445abda1b7582bb76e9ab2cc48bb753bf4d95" translate="yes" xml:space="preserve">
          <source>The fts5 unicode61 tokenizer is byte-for-byte compatible with the fts3/4 unicode61 tokenizer.</source>
          <target state="translated">fts5 unicode61 tokenizer与fts3/4 unicode61 tokenizer字节对字节兼容。</target>
        </trans-unit>
        <trans-unit id="78675caf2de7d160a88a0d764272d7a44454db10" translate="yes" xml:space="preserve">
          <source>The fts5_api structure is defined as follows. It exposes three methods, one each for registering new auxiliary functions and tokenizers, and one for retrieving existing tokenizer. The latter is intended to facilitate the implementation of &quot;tokenizer wrappers&quot; similar to the built-in porter tokenizer.</source>
          <target state="translated">fts5_api 结构定义如下。它公开了三个方法,一个用于注册新的辅助函数和令牌器,另一个用于检索现有的令牌器。后者的目的是为了方便实现类似于内置的 porter tokenizer 的 &quot;tokenizer 包装器&quot;。</target>
        </trans-unit>
        <trans-unit id="162ffee085d8569c08bb1ab9fff2a388996d64c4" translate="yes" xml:space="preserve">
          <source>The fts5_api structure methods are described individually in the following sections.</source>
          <target state="translated">fts5_api结构方法将在下面的章节中单独描述。</target>
        </trans-unit>
        <trans-unit id="10c372ee6826e322ad4396357787688e82cce472" translate="yes" xml:space="preserve">
          <source>The fts5vocab virtual table module allows users to extract information from an FTS5 full-text index directly. The fts5vocab module is a part of FTS5 - it is available whenever FTS5 is.</source>
          <target state="translated">fts5vocab虚拟表模块允许用户直接从FTS5全文索引中提取信息。fts5vocab模块是FTS5的一部分--只要FTS5在,它就可以使用。</target>
        </trans-unit>
        <trans-unit id="7f3f12f1d0cab297fd4ff2f20d0ccb7ef0778aa5" translate="yes" xml:space="preserve">
          <source>The full pathname of the database file is now remembered even if a relative path is passed into sqlite_open(). This allows the library to continue operating correctly after a chdir().</source>
          <target state="translated">即使将相对路径传递给 sqlite_open(),数据库文件的完整路径名也会被记住。这允许库在chdir()之后继续正确运行。</target>
        </trans-unit>
        <trans-unit id="3b9a46ef2b67e207b1134faeedabd205f3bd8481" translate="yes" xml:space="preserve">
          <source>The full syntax for specifying foreign key constraints is available as part of the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; documentation. Replacing the phrase above with any of the following creates an immediate foreign key constraint.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;文档的一部分提供了用于指定外键约束的完整语法。用以下任何一项替换上面的短语会创建立即外键约束。</target>
        </trans-unit>
        <trans-unit id="976d387f058fd1530001e6bc24b270372cb7f6ff" translate="yes" xml:space="preserve">
          <source>The full-text index maintained by FTS5 is stored as a series of fixed-size blobs in a database table. It is not strictly necessary for all blobs that make up a full-text index to be the same size. The pgsz option determines the size of all blobs created by subsequent index writers. The default value is 1000.</source>
          <target state="translated">FTS5维护的全文索引以一系列固定大小的blobs的形式存储在数据库表中。严格来说,组成全文索引的所有 blobs 的大小并不需要相同。pgsz 选项决定了后续索引写入者创建的所有 blobs 的大小。默认值是1000。</target>
        </trans-unit>
        <trans-unit id="7d7917f6db9701130aeed21c2478cad3cdfc0903" translate="yes" xml:space="preserve">
          <source>The function name is specified in UTF-8. A separate sqlite3_create_function16() API works the same as sqlite_create_function() except that the function name is specified in UTF-16 host byte order.</source>
          <target state="translated">函数名用UTF-8指定。一个单独的sqlite3_create_function16()API的工作原理与sqlite_create_function()相同,只是函数名是以UTF-16主机字节顺序指定的。</target>
        </trans-unit>
        <trans-unit id="026205ed147556f48d88752d5a21eccbd2a64b48" translate="yes" xml:space="preserve">
          <source>The function pointer returned by this routine must be valid for the lifetime of the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object given in the first parameter.</source>
          <target state="translated">此例程返回的函数指针必须在第一个参数中给出的&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;对象的生存期内有效。</target>
        </trans-unit>
        <trans-unit id="d5578e17f6c531f672841ef155dfdacbfa341e5d" translate="yes" xml:space="preserve">
          <source>The function presented in the previous example copies the entire source database in one call to &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt;. This requires holding a read-lock on the source database file for the duration of the operation, preventing any other database user from writing to the database. It also holds the mutex associated with database pInMemory throughout the copy, preventing any other thread from using it. The C function in this section, designed to be called by a background thread or process for creating a backup of an online database, avoids these problems using the following approach:</source>
          <target state="translated">上一个示例中提供的函数通过一次调用将整个源数据库复制到&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（）&lt;/a&gt;。这要求在操作期间在源数据库文件上保持读取锁定，以防止任何其他数据库用户写入数据库。它还在整个副本中保留与数据库pInMemory相关联的互斥锁，从而防止任何其他线程使用它。本节中的C函数旨在由后台线程或用于创建在线数据库备份的进程调用，它使用以下方法避免了这些问题：</target>
        </trans-unit>
        <trans-unit id="0137a1cc90b7f7f164b60d3e6a0abb13294403cf" translate="yes" xml:space="preserve">
          <source>The functionality provided by the fts4aux module is now provided by &lt;a href=&quot;fts5#the_fts5vocab_virtual_table_module&quot;&gt;fts5vocab&lt;/a&gt;. The schema of these two tables is slightly different.</source>
          <target state="translated">fts5vocab现在提供了fts4aux模块提供的&lt;a href=&quot;fts5#the_fts5vocab_virtual_table_module&quot;&gt;功能&lt;/a&gt;。这两个表的架构略有不同。</target>
        </trans-unit>
        <trans-unit id="82f4a608941f31ed6516bc837d2ee3e175fc4792" translate="yes" xml:space="preserve">
          <source>The functionality required of each of the above functions is described in comments in sqlite3async.c.</source>
          <target state="translated">以上每个函数所需的功能在sqlite3async.c的注释中都有描述。</target>
        </trans-unit>
        <trans-unit id="a3e3ee73e4504a9b18df3710202691563a7ae8e5" translate="yes" xml:space="preserve">
          <source>The general purpose memory allocator is the most difficult memory pool to manage because it supports allocations of varying sizes. Since &lt;b&gt;n&lt;/b&gt; is a multiplier on &lt;b&gt;M&lt;/b&gt; we want to keep &lt;b&gt;n&lt;/b&gt; as small as possible. This argues for keeping the minimum allocation size for &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; as large as possible. In most applications, the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; is able to handle small allocations. So it is reasonable to set the minimum allocation size for &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; to 2, 4 or even 8 times the maximum size of a lookaside allocation. A minimum allocation size of 512 is a reasonable setting.</source>
          <target state="translated">通用内存分配器是最难管理的内存池，因为它支持大小不同的分配。由于&lt;b&gt;n&lt;/b&gt;是&lt;b&gt;M&lt;/b&gt;的乘数，因此我们要使&lt;b&gt;n&lt;/b&gt;尽可能小。这&lt;a href=&quot;malloc#memsys5&quot;&gt;表明应将memsys5&lt;/a&gt;的最小分配大小保持尽可能大。在大多数应用程序中，&lt;a href=&quot;malloc#lookaside&quot;&gt;后备内存分配器&lt;/a&gt;能够处理少量分配。因此，将&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;的最小分配大小设置为后备分配最大大小的2倍，4倍甚至8倍是合理的。最小分配大小为512是合理的设置。</target>
        </trans-unit>
        <trans-unit id="30bdbd95e17bffd329d217ead465e3fe28cd023c" translate="yes" xml:space="preserve">
          <source>The general rule is that indexes are only useful if there are WHERE-clause constraints on the left-most columns of the index. However, in some cases, SQLite is able to use an index even if the first few columns of the index are omitted from the WHERE clause but later columns are included.</source>
          <target state="translated">一般的规则是,只有在索引的最左边的列上有WHERE子句约束时,索引才有用。然而,在某些情况下,即使在WHERE子句中省略了索引的前几列,但包含了后面的列,SQLite也能够使用索引。</target>
        </trans-unit>
        <trans-unit id="084577b6dd782fa1eb4651ff451c238f84ef2391" translate="yes" xml:space="preserve">
          <source>The general-purpose memory allocator (&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;).</source>
          <target state="translated">通用内存分配器（&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="21a012c95267cb8d2b8d45dbbd928793f6616b70" translate="yes" xml:space="preserve">
          <source>The generate_series Table-Valued Function</source>
          <target state="translated">generate_series 表值函数</target>
        </trans-unit>
        <trans-unit id="476dfd7c8482f7d1208e7bd9537292c089264e39" translate="yes" xml:space="preserve">
          <source>The generate_series table can be simulated using a &lt;a href=&quot;lang_with#recursivecte&quot;&gt;recursive common table expression&lt;/a&gt;. If the three parameters are $start, $end, and $step, then the equivalent common table expression is:</source>
          <target state="translated">可以使用&lt;a href=&quot;lang_with#recursivecte&quot;&gt;递归公用表表达式&lt;/a&gt;来模拟generate_series表。如果三个参数分别是$ start，$ end和$ step，则等效的公用表表达式为：</target>
        </trans-unit>
        <trans-unit id="4e3c394ee97ca6ac89b21ae3983e2fd5668b4aa8" translate="yes" xml:space="preserve">
          <source>The generate_series(START,END,STEP) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; included in the SQLite source tree, and compiled into the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;. The generate_series() table has a single result column named &quot;value&quot; holding integer values and a number of rows determined by the parameters START, END, and STEP. The first row of the table has a value of START. Subsequent rows increase by STEP up to END.</source>
          <target state="translated">generate_series（START，END，STEP）&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;是SQLite源树中包含的&lt;a href=&quot;loadext&quot;&gt;可加载扩展&lt;/a&gt;，并已编译到&lt;a href=&quot;cli&quot;&gt;命令行shell中&lt;/a&gt;。generate_series（）表具有一个名为&amp;ldquo; value&amp;rdquo;的单个结果列，其中包含整数值，并且包含由参数START，END和STEP确定的行数。该表的第一行的值为START。随后的行按STEP递增，直到END。</target>
        </trans-unit>
        <trans-unit id="3f2ed0d414c19e451dbd160a6e3115271ef19a02" translate="yes" xml:space="preserve">
          <source>The geopoly module defines several new SQL functions that are useful for dealing with polygons. All polygon arguments to these functions can be either the GeoJSON format or the internal binary format.</source>
          <target state="translated">geopoly模块定义了几个新的SQL函数,这些函数对处理多边形很有用。这些函数的所有多边形参数可以是GeoJSON格式或内部二进制格式。</target>
        </trans-unit>
        <trans-unit id="8d993a3d44bf40860242bebc1265b2783cf9c63f" translate="yes" xml:space="preserve">
          <source>The geopoly module is an extension to the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;. Geopoly uses the same underlying logic and shadow tables as the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;. Geopoly merely presents a different interface, and provides some extra logic to compute polygon decoding, overlap, and containment.</source>
          <target state="translated">geopoly模块是&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展的扩展&lt;/a&gt;。Geopoly使用与&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展&lt;/a&gt;相同的基础逻辑和影子表。Geopoly仅提供了一个不同的界面，并提供了一些额外的逻辑来计算多边形解码，重叠和包含。</target>
        </trans-unit>
        <trans-unit id="acb138b945d23f00cd83af917d94b141700de307" translate="yes" xml:space="preserve">
          <source>The geopoly module is built on top of the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; and uses the same underlying shadow tables and algorithms. For indexing purposes, each polygon is represented in the shadow tables as a rectangular bounding box. The underlying R-Tree implementation uses bounding boxes to limit the search space. Then the geoploy_overlap() and/or geopoly_within() routines further refine the search to the exact answer.</source>
          <target state="translated">地理多边形模块建立在&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展的&lt;/a&gt;顶部，并使用相同的基础阴影表和算法。为了建立索引，每个多边形在阴影表中均表示为矩形边界框。底层的R-Tree实现使用边界框来限制搜索空间。然后，geoploy_overlap（）和/或geopoly_within（）例程将搜索进一步优化为确切的答案。</target>
        </trans-unit>
        <trans-unit id="fdb9ae6360ea866b8222993691854e31ea695989" translate="yes" xml:space="preserve">
          <source>The geopoly_ccw(J) function returns the polygon J with counter-clockwise (CCW) rotation.</source>
          <target state="translated">geopoly_ccw(J)函数返回逆时针(CCW)旋转的多边形J。</target>
        </trans-unit>
        <trans-unit id="58be5b36690d1c8a61ca619684c9087df6d3c79c" translate="yes" xml:space="preserve">
          <source>The geopoly_group_bbox(P) function is an aggregate version of geopoly_bbox(P). The geopoly_group_bbox(P) function returns the smallest rectangle that will enclose all P values seen during aggregation.</source>
          <target state="translated">geopoly_group_bbox(P)函数是geopoly_bbox(P)的集合版本。geopoly_group_bbox(P)函数返回在聚合过程中所有P值的最小矩形。</target>
        </trans-unit>
        <trans-unit id="7aa31a665e34b0f93544b760a7bd5d5549c54d97" translate="yes" xml:space="preserve">
          <source>The geopoly_overlap(P1,P2) function is special in that the geopoly virtual table knows how to use R*Tree indexes to optimize queries in which the WHERE clause uses geopoly_overlap() as a boolean function. Only the geopoly_overlap(P1,P2) and geopoly_within(P1,P2) functions have this capability.</source>
          <target state="translated">geopoly_overlap(P1,P2)函数的特殊之处在于,geopoly虚拟表知道如何使用R*Tree索引来优化查询,其中WHERE子句使用geopoly_overlap()作为布尔函数。只有geopoly_overlap(P1,P2)和geopoly_within(P1,P2)函数具有这种能力。</target>
        </trans-unit>
        <trans-unit id="4552cf5a5f2e459423714152983f2ca48f86f169" translate="yes" xml:space="preserve">
          <source>The geopoly_regular(X,Y,R,N) function returns a convex, simple, regular, equilateral, equiangular polygon with N sides, centered at X,Y, and with a circumradius of R. Or, if R is negative or if N is less than 3, the function returns NULL. The N value is capped at 1000 so that the routine will never render a polygon with more than 1000 sides even if the N value is larger than 1000.</source>
          <target state="translated">geopoly_regular(X,Y,R,N)函数返回一个以X,Y为中心,周长为R的具有N条边的凸面、简单、规则、等边、等角的多边形,或者,如果R为负值或者N小于3,函数返回NULL。N值的上限为1000,因此即使N值大于1000,该例程也不会渲染一个边数超过1000的多边形。</target>
        </trans-unit>
        <trans-unit id="01eba492c4ddd36076bba0e9fe7c2f9d9c526116" translate="yes" xml:space="preserve">
          <source>The geopoly_within(P1,P2) function is special in that the geopoly virtual table knows how to use R*Tree indexes to optimize queries in which the WHERE clause uses geopoly_within() as a boolean function. Only the geopoly_within(P1,P2) and geopoly_overlap(P1,P2) functions have this capability.</source>
          <target state="translated">geopoly_within(P1,P2)函数的特殊之处在于,geopoly虚拟表知道如何使用R*Tree索引来优化查询,其中WHERE子句使用geopoly_within()作为布尔函数。只有geopoly_within(P1,P2)和geopoly_overlap(P1,P2)函数具有这种能力。</target>
        </trans-unit>
        <trans-unit id="45313c37ef01af04ca79cf8e508d2efcd3ced709" translate="yes" xml:space="preserve">
          <source>The geopoly_xform(P,A,B,C,D,E,F) function returns a new polygon that is an affine transformation of the polygon P and where the transformation is defined by values A,B,C,D,E,F. If P is not a valid polygon, this routine returns NULL.</source>
          <target state="translated">geopoly_xform(P,A,B,C,D,E,F)函数返回一个新的多边形,这个多边形是多边形P的仿射变换,变换的定义是A,B,C,D,E,F。如果P不是一个有效的多边形,这个例程返回NULL。</target>
        </trans-unit>
        <trans-unit id="8a7538a75bac0dc91c968f2f943ef8c77b915108" translate="yes" xml:space="preserve">
          <source>The glob(X,Y) function is equivalent to the expression &quot;&lt;b&gt;Y GLOB X&lt;/b&gt;&quot;. Note that the X and Y arguments are reversed in the glob() function relative to the infix &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator. Y is the string and X is the pattern. So, for example, the following expressions are equivalent:</source>
          <target state="translated">glob（X，Y）函数等效于表达式&amp;ldquo; &lt;b&gt;Y GLOB X&lt;/b&gt; &amp;rdquo;。请注意，相对于中缀&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;运算符，glob（）函数中的X和Y参数是相反的。Y是字符串，X是模式。因此，例如，以下表达式是等效的：</target>
        </trans-unit>
        <trans-unit id="57af892941202e82d82f19e609a84ccb0531eaad" translate="yes" xml:space="preserve">
          <source>The goal is to make SQLite handle NULLs in a standards-compliant way. But the descriptions in the SQL standards on how to handle NULLs seem ambiguous. It is not clear from the standards documents exactly how NULLs should be handled in all circumstances.</source>
          <target state="translated">目标是让SQLite以符合标准的方式处理NULLs。但是SQL标准中关于如何处理NULLs的描述似乎很模糊。从标准文档中看不出在所有情况下到底应该如何处理NULLs。</target>
        </trans-unit>
        <trans-unit id="2ba0147df5ada0e089bdabaebc1a5094f5e9a20f" translate="yes" xml:space="preserve">
          <source>The goal of this query is to compute some value for the five most recent entries in the table. But in the query above, the &quot;expensive_function()&quot; is invoked prior to the sort and thus is invoked on every row of the table, even rows that are ultimately omitted due to the LIMIT clause. A co-routine can be used to work around this:</source>
          <target state="translated">这个查询的目标是为表中最近的五个条目计算一些值。但是在上面的查询中,&quot; expensive_function()&quot;是在排序之前被调用的,因此在表中的每一条记录上都会被调用,甚至是由于limit子句而最终被省略的记录。可以使用一个联合程序来解决这个问题。</target>
        </trans-unit>
        <trans-unit id="27130ed911ba5b72cf5d70b6f38c66e3447f97b9" translate="yes" xml:space="preserve">
          <source>The grammar syntax is less error prone - using symbolic names for semantic values rather that the &quot;$1&quot;-style positional notation of Yacc.</source>
          <target state="translated">语法不容易出错--使用符号名来表示语义值,而不是Yacc的 &quot;1美元 &quot;式的位置符号。</target>
        </trans-unit>
        <trans-unit id="8288ae8eb06e54b34a1335f8c6fbfb99327b7542" translate="yes" xml:space="preserve">
          <source>The graph below shows the number of CPU cycles used by SQLite on a standard workload, for versions of SQLite going back about 10 years. Recent versions of SQLite use about one third as many the CPU cycles compared to older versions.</source>
          <target state="translated">下图显示了SQLite在标准工作负载上使用的CPU周期数,对于SQLite的版本可以追溯到10年前。与旧版本相比,最新版本的SQLite所使用的CPU周期约为三分之一。</target>
        </trans-unit>
        <trans-unit id="ea3dfc83e3fad7e5da84aa92171fa1f2ebb6adae" translate="yes" xml:space="preserve">
          <source>The group_concat() function returns a string which is the concatenation of all non-NULL values of</source>
          <target state="translated">group_concat()函数返回一个字符串,这个字符串是所有非NULL值的连接。</target>
        </trans-unit>
        <trans-unit id="998c879f2d9a4a324ed589705e44b7743eed8ace" translate="yes" xml:space="preserve">
          <source>The group_concat(x,'') SQL function returns NULL instead of an empty string when all inputs are empty strings. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/55746f9e65f85&quot;&gt;55746f9e65&lt;/a&gt;</source>
          <target state="translated">当所有输入均为空字符串时，group_concat（x，''）SQL函数将返回NULL而不是空字符串。机票&lt;a href=&quot;http://www.sqlite.org/src/info/55746f9e65f85&quot;&gt;55746F9E65&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3cc69e429ade6ced467dc065c3703a231254bc0f" translate="yes" xml:space="preserve">
          <source>The handling of IN and NOT IN operators that contain a NULL on their right-hand side expression is brought into compliance with the SQL standard and with other SQL database engines. This is a bug fix, but as it has the potential to break legacy applications that depend on the older buggy behavior, we mark that as a *** Potentially incompatible change ***</source>
          <target state="translated">IN 和 NOT IN 运算符的处理,如果在其右侧表达式中包含 NULL,则符合 SQL 标准和其他 SQL 数据库引擎。这是一个bug修复,但由于它有可能破坏依赖于旧的bug行为的遗留应用程序,我们将其标记为***潜在的不兼容变化***。</target>
        </trans-unit>
        <trans-unit id="d0efc6030fa81d141b43a701523b55c7bcf660fd" translate="yes" xml:space="preserve">
          <source>The hash tables in the shm file are designed to answer the following question quickly:</source>
          <target state="translated">shm文件中的哈希表是为了快速回答以下问题而设计的。</target>
        </trans-unit>
        <trans-unit id="2856b370cad55dc7412b44b6f210c8cf053331d6" translate="yes" xml:space="preserve">
          <source>The hashes that identify check-ins and files on the Git mirror are different from the hashes in Fossil. There are many reasons for this, chief among them that Fossil uses a SHA3-256 hash whereas Git uses a SHA1 hash. During export, the original Fossil hash for each check-in is added as a footer to check-in comments. To avoid confusion, always use the original Fossil hash, not the Git hash, when referring to SQLite check-ins.</source>
          <target state="translated">Git 镜像上识别签到和文件的哈希值与 Fossil 的哈希值不同。这有很多原因,其中最主要的原因是 Fossil 使用的是 SHA3-256 哈希值,而 Git 使用的是 SHA1 哈希值。在导出过程中,每个签入的Fossil原始哈希值会被添加到签入注释的脚注中。为了避免混淆,在引用 SQLite 检查记录时,请使用 Fossil 的原始哈希值,而不是 Git 的哈希值。</target>
        </trans-unit>
        <trans-unit id="e115da518074674c7bed9606a1f3c39c1334b0dc" translate="yes" xml:space="preserve">
          <source>The header of the rollback journal can be overwritten with invalid header text (for example, all zeros).</source>
          <target state="translated">回滚日志的头可以用无效的头文字(例如,全部为零)覆盖。</target>
        </trans-unit>
        <trans-unit id="328251bbc9b91a18ef755ecd2993b4b5eb3cf221" translate="yes" xml:space="preserve">
          <source>The header of the rollback journal is well-formed and in particular has not been zeroed out.</source>
          <target state="translated">回滚期刊的刊头成型良好,特别是没有被清零。</target>
        </trans-unit>
        <trans-unit id="8908758df6621b583f7634e3a00bc808f16a9ffb" translate="yes" xml:space="preserve">
          <source>The header size varint and serial type varints will usually consist of a single byte. The serial type varints for large strings and BLOBs might extend to two or three byte varints, but that is the exception rather than the rule. The varint format is very efficient at coding the record header.</source>
          <target state="translated">头部大小变位符和序列类型变位符通常由一个字节组成。大字符串和BLOB的序列类型变位数可能会扩展到两个或三个字节的变位数,但这是例外而不是规则。varint格式对记录头的编码非常有效。</target>
        </trans-unit>
        <trans-unit id="6a561080aa600994c95f7609f8c9a76e07664cc1" translate="yes" xml:space="preserve">
          <source>The header string: &quot;SQLite format 3\000&quot;</source>
          <target state="translated">标题字符串:&quot;SQLite format 3\000&quot;</target>
        </trans-unit>
        <trans-unit id="9618d06778e016225462d5681eb6b291f7c80aa5" translate="yes" xml:space="preserve">
          <source>The heap limits are not enforced in the current implementation if one or more of following conditions are true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95f9212fdc8a88cf98b4e1490976ec2f7354c6a2" translate="yes" xml:space="preserve">
          <source>The heavy wrapper employed by &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; is intended for use only during testing, analysis, and debugging of SQLite. The heavy wrapper has a significant performance and memory overhead and probably should not be used in production.</source>
          <target state="translated">&lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt;使用的重包装仅适用于SQLite的测试，分析和调试。繁重的包装程序具有显着的性能和内存开销，因此可能不应该在生产中使用。</target>
        </trans-unit>
        <trans-unit id="eb4610f1226d8f274f85d7debe217f5d65427f90" translate="yes" xml:space="preserve">
          <source>The heavy wrapper that is used when &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; is set also makes sure each new allocation is filled with nonsense data prior to returning the allocation to the caller. And as soon as an allocation is free, it is again filled with nonsense data. These two actions help to ensure that the SQLite core does not make assumptions about the state of newly allocated memory and that memory allocations are not used after they have been freed.</source>
          <target state="translated">设置&lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt;时使用的重包装器还可以确保在将分配返回给调用者之前，每个新分配都被无用数据填充。一旦分配是免费的，它就会再次被废话数据填充。这两个动作有助于确保SQLite核心不对新分配的内存状态做出假设，并且确保释放内存后不使用内存分配。</target>
        </trans-unit>
        <trans-unit id="a33b86543e89aa7fc91f1c01c079a10eabc5b26c" translate="yes" xml:space="preserve">
          <source>The hex() function interprets its argument as a BLOB and returns a string which is the upper-case hexadecimal rendering of the content of that blob.</source>
          <target state="translated">hex()函数将其参数解释为BLOB,并返回一个字符串,该字符串是该blob内容的大写十六进制渲染。</target>
        </trans-unit>
        <trans-unit id="47e9ec1a2ca9f6468b5d5ea9dca27a7ef3e3db0a" translate="yes" xml:space="preserve">
          <source>The high repeatability of cachegrind allows the SQLite developers to implement and measure &quot;microoptimizations&quot;. A microoptimization is a change to the code that results in a very small performance increase. Typical micro-optimizations reduce the number of CPU cycles by 0.1% or 0.05% or even less. Such improvements are impossible to measure with real-world timings. But hundreds or thousands of microoptimizations add up, resulting in measurable real-world performance gains.</source>
          <target state="translated">cachegrind的高重复性使得SQLite开发人员可以实现和测量 &quot;微优化&quot;。微优化是指对代码进行修改,使其性能得到很小的提升。典型的微优化可以减少0.1%或0.05%甚至更少的CPU周期数。这样的改进是无法用真实世界的时序来衡量的。但数百或数千次的微优化累积起来,就会产生可衡量的实际性能提升。</target>
        </trans-unit>
        <trans-unit id="8ccb63c8eb8186df2591985e1dd0399f9de8ed53" translate="yes" xml:space="preserve">
          <source>The high-reliability of SQLite is proven in practice. SQLite has been used without problems in multiple billions of smart-phones, IoT devices, and desktop applications, around the world, and for almost two decades.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8285d1c1b74bc88c5caec05770baddba5bd483b5" translate="yes" xml:space="preserve">
          <source>The high-reliability of SQLite is proven in practice. SQLite has been used without problems in multiple billions of smart-phones, IoT devices, and desktop applications, around the world, and for over a decade.</source>
          <target state="translated">SQLite的高可靠性在实践中得到了验证。SQLite已经在全球多亿部智能手机、物联网设备和桌面应用中顺利使用,并且已经使用了十几年。</target>
        </trans-unit>
        <trans-unit id="f6fadaee687e9cfda1c93f7fa51b5ba3b3240bd6" translate="yes" xml:space="preserve">
          <source>The highlight() function returns a copy of the text from a specified column of the current row with extra markup text inserted to mark the start and end of phrase matches.</source>
          <target state="translated">Highlight()函数从当前行的指定列中返回一份文本的副本,并插入额外的标记文本来标记短语匹配的开始和结束。</target>
        </trans-unit>
        <trans-unit id="e43753ce0913d39afca1c9c249ea51ebaf6b6f06" translate="yes" xml:space="preserve">
          <source>The highlight() must be invoked with exactly three arguments following the table name. To be interpreted as follows:</source>
          <target state="translated">调用highlight()时,必须在表名后正好有三个参数。解释如下:</target>
        </trans-unit>
        <trans-unit id="bb9d506afb5b0054b66298f3975841775d6d258d" translate="yes" xml:space="preserve">
          <source>The histogram data is only useful if the right-hand side of the constraint is a simple compile-time constant or &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and not an expression.</source>
          <target state="translated">直方图数据仅在约束的右侧是简单的编译时常量或&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;而不是表达式的情况下才有用。</target>
        </trans-unit>
        <trans-unit id="754b3dec45709dc037212c7449e27878498a6122" translate="yes" xml:space="preserve">
          <source>The historical behavior of SQLite is incorrect according to the SQL:1999 standard and it is inconsistent with the behavior of MySQL and PostgreSQL. Version 3.6.0 changes the behavior of the IN and NOT IN operators to conform to the standard and to give the same results as other SQL database engines.</source>
          <target state="translated">根据SQL:1999标准,SQLite的历史行为是不正确的,它与MySQL和PostgreSQL的行为不一致。3.6.0版本改变了IN和NOT IN运算符的行为,以符合标准,并提供与其他SQL数据库引擎相同的结果。</target>
        </trans-unit>
        <trans-unit id="3be31364c3c06e62038927597ca88135a8ca4d7a" translate="yes" xml:space="preserve">
          <source>The iCost column is the numeric cost of transforming cFrom into cTo. This value should be a non-negative integer, and should probably be less than 100. The default single-character insertion and deletion costs are 100 and the default single-character to single-character substitution cost is 150. A cost of 10000 or more is considered &quot;infinite&quot; and causes the rule to be ignored.</source>
          <target state="translated">iCost列是将cFrom转换为cTo的数字成本。这个值应该是一个非负的整数,可能应该小于100。默认的单字符插入和删除成本是100,默认的单字符到单字符的替换成本是150。成本为10000或更多则被认为是 &quot;无限 &quot;的,会导致规则被忽略。</target>
        </trans-unit>
        <trans-unit id="d0b9d0aa5d29da45f0b93b40de44e2f95388c2e0" translate="yes" xml:space="preserve">
          <source>The iLang column is a non-negative integer that identifies a set of costs appropriate for a particular language. The editdist3 function will only use a single iLang value for any given edit-distance computation. The default value is 0. It is recommended that applications that only need to use a single language always use iLang==0 for all entries.</source>
          <target state="translated">iLang列是一个非负的整数,它标识了一组适合特定语言的成本。editdist3函数在任何给定的edit-distance计算中都只使用一个iLang值,默认值是0。默认值是0,建议只需要使用单一语言的应用程序总是对所有条目使用iLang==0。</target>
        </trans-unit>
        <trans-unit id="5013f8a1a10fac4a872743ceb29c353308c4297d" translate="yes" xml:space="preserve">
          <source>The iVersion field of &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; is provided as insurance against future enhancements. The iVersion value should always be 1 for SQLite version 3.5.</source>
          <target state="translated">提供&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;的iVersion字段作为将来增强功能的保证。对于SQLite版本3.5，iVersion值应始终为1。</target>
        </trans-unit>
        <trans-unit id="8b61610ddf9130372f875adae334c360bf359102" translate="yes" xml:space="preserve">
          <source>The iVersion field of &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; should be 1 for SQLite version 3.5.0. This number may increase in future versions of SQLite if we have to modify the VFS object in some way. We hope that this never happens, but the provision is made in case it does.</source>
          <target state="translated">对于SQLite版本3.5.0 ，&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;的iVersion字段应为1。如果我们必须以某种方式修改VFS对象，则在将来的SQLite版本中此数目可能会增加。我们希望这种情况永远不会发生，但会在必要时作出规定。</target>
        </trans-unit>
        <trans-unit id="ea830f2d673441ec5d80e9c5eb8623ea5999e87b" translate="yes" xml:space="preserve">
          <source>The idea behind a reserved lock is that it signals that a process intends to modify the database file in the near future but has not yet started to make the modifications. And because the modifications have not yet started, other processes can continue to read from the database. However, no other process should also begin trying to write to the database.</source>
          <target state="translated">保留锁背后的想法是,它标志着一个进程打算在不久的将来修改数据库文件,但还没有开始进行修改。而由于修改还没有开始,其他进程可以继续从数据库中读取。但是,其他进程也不应该开始尝试向数据库写入。</target>
        </trans-unit>
        <trans-unit id="b86c36b3766e07cfb666e3625925c99f4017f8b5" translate="yes" xml:space="preserve">
          <source>The idxNum and idxPtr values are recorded and passed into the &lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; is used to free idxPtr if and only if needToFreeIdxPtr is true.</source>
          <target state="translated">记录idxNum和idxPtr值，并将其传递到&lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;方法中。当且仅当needToFreeIdxPtr为true时，才使用&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放idxPtr。</target>
        </trans-unit>
        <trans-unit id="357574f6e5fd171b87a29904a513e7015690c872" translate="yes" xml:space="preserve">
          <source>The idxNum and idxPtr values are recorded and passed into the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; is used to free idxPtr if and only if needToFreeIdxPtr is true.</source>
          <target state="translated">记录idxNum和idxPtr值，并将其传递到&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;方法中。当且仅当needToFreeIdxPtr为true时，才使用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放idxPtr。</target>
        </trans-unit>
        <trans-unit id="013b479832be35dd0d8a4395d938100b93b10f74" translate="yes" xml:space="preserve">
          <source>The idxStr value may be a string obtained from an SQLite memory allocation function such as &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;. If this is the case, then the needToFreeIdxStr flag must be set to true so that the SQLite core will know to call &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; on that string when it has finished with it, and thus avoid a memory leak. The idxStr value may also be a static constant string, in which case the needToFreeIdxStr boolean should remain false.</source>
          <target state="translated">idxStr值可以是从SQLite内存分配函数（例如&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（））&lt;/a&gt;获得的字符串。如果是这种情况，那么必须将needToFreeIdxStr标志设置为true，以便SQLite内核在完成该字符串后将知道在该字符串上调用&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;，从而避免了内存泄漏。idxStr值也可以是静态常量字符串，在这种情况下，needToFreeIdxStr布尔值应保持为false。</target>
        </trans-unit>
        <trans-unit id="53bc345818e3cfbbe8c82ba1be412d51eef79f34" translate="yes" xml:space="preserve">
          <source>The ieee754 extension converts a floating point number between its binary64 representation and the M&amp;times;2&lt;sup&gt;&lt;small&gt;E&lt;/small&gt;&lt;/sup&gt; format. In other words in the expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2f1322e38e7bf458c5d54d75c7506d3ae73217c" translate="yes" xml:space="preserve">
          <source>The ieee754 extension converts between F and (M,E) and back again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d7e2d6ba2a9578fe636d96019c4ffb56636fdf7" translate="yes" xml:space="preserve">
          <source>The ieee754 extension is not part of the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, but it is included by default in the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;. If you want to include the ieee754 extension in your application, you will need to compile and load it separately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac62a77b019e01de7ef209efbe441dd3c0eb2c08" translate="yes" xml:space="preserve">
          <source>The ieee754(F) SQL function takes a single floating-point argument as its input and returns a string that looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c018ce9988c89e6d43c340880c6cf378ed2e6c" translate="yes" xml:space="preserve">
          <source>The ieee754_to_blob(F) SQL function converts the floating point number F into an 8-byte BLOB that is the big-endian binary64 encoding of that number. The ieee754_from_blob(B) function goes the other way, converting an 8-byte blob into the floating-point value that the binary64 encoding represents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d5a7e8bc386f87dedf4ba3978aa31bcde8d6916" translate="yes" xml:space="preserve">
          <source>The ifnull() function returns a copy of its first non-NULL argument, or NULL if both arguments are NULL. Ifnull() must have exactly 2 arguments. The ifnull() function is equivalent to &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt; with two arguments.</source>
          <target state="translated">ifnull（）函数返回其第一个非NULL参数的副本，如果两个参数均为NULL，则返回NULL。 Ifnull（）必须正好有2个参数。 ifnull（）函数等效于带有两个参数的&lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="003c977ed53ddacaa1a12c60c49d228fced8878c" translate="yes" xml:space="preserve">
          <source>The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise. The iif(X,Y,Z) function is logically equivalent to and generates the same &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; as the &lt;a href=&quot;lang_expr#case&quot;&gt;CASE expression&lt;/a&gt; &quot;CASE WHEN X THEN Y ELSE Z END&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46220a05919fd727bb5192ff33d2f0412a4a1656" translate="yes" xml:space="preserve">
          <source>The immutable query parameter is a boolean that signals to SQLite that the underlying database file is held on read-only media and cannot be modified, even by another process with elevated privileges. SQLite always opens immutable database files read-only and it skips all file locking and change detection on immutable database files. If these query parameter (or the &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_IMMUTABLE&lt;/a&gt; bit in xDeviceCharacteristics) asserts that a database file is immutable and that file changes anyhow, then SQLite might return incorrect query results and/or &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; errors.</source>
          <target state="translated">不可变的查询参数是一个布尔值，它向SQLite发出信号，通知其基础数据库文件位于只读介质上，并且即使具有更高特权的另一个进程也无法对其进行修改。 SQLite始终以只读方式打开不可变数据库文件，并跳过所有文件锁定并更改不可变数据库文件的更改检测。如果这些查询参数（或&lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;xDeviceCharacteristics&lt;/a&gt;中的SQLITE_IOCAP_IMMUTABLE位）断言数据库文件是不可变的，并且该文件无论如何都会发生更改，则SQLite可能返回错误的查询结果和/或&lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt;错误。</target>
        </trans-unit>
        <trans-unit id="a6b9b8cf3a7d94e9575aa22c08feee5317ab9464" translate="yes" xml:space="preserve">
          <source>The implementation for the spellfix1 virtual table is held in the SQLite source tree in the miscellaneous extensions folder and in particular in the file &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=ext/misc/spellfix.c&quot;&gt;ext/misc/spellfix1.c&lt;/a&gt;. The spellfix1 virtual table is not included in the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; and is not a part of any standard SQLite build. It is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;.</source>
          <target state="translated">spellfix1虚拟表的实现保存在SQLite源树的其他扩展文件夹中，尤其是在文件&lt;a href=&quot;http://www.sqlite.org/src/finfo?name=ext/misc/spellfix.c&quot;&gt;ext / misc / spellfix1.c中&lt;/a&gt;。spellfix1虚拟表未包含在SQLite &lt;a href=&quot;amalgamation&quot;&gt;合并中&lt;/a&gt;，也不是任何标准SQLite构建的一部分。这是一个&lt;a href=&quot;loadext&quot;&gt;可加载的扩展&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8eb5688bafc7d4405d9e0ef667e71e04726e76e8" translate="yes" xml:space="preserve">
          <source>The implementation is not required to provide versions of these routines that actually work. If the implementation does not provide working versions of these routines, it should at least provide stubs that always return true so that one does not get spurious assertion failures.</source>
          <target state="translated">不要求实施者提供这些例程的实际工作版本。如果实现不提供这些例程的工作版本,它至少应该提供总是返回true的存根,这样就不会出现虚假的断言失败。</target>
        </trans-unit>
        <trans-unit id="8b40a9e730bef66c422bb631b44b6863716defa7" translate="yes" xml:space="preserve">
          <source>The implementation is registered with the FTS5 module by calling the xCreateFunction() method of the fts5_api object. If there is already an auxiliary function with the same name, it is replaced by the new function. If a non-NULL xDestroy parameter is passed to xCreateFunction(), it is invoked with a copy of the pContext pointer passed as the only argument when the database handle is closed or when the registered auxiliary function is replaced.</source>
          <target state="translated">通过调用fts5_api对象的xCreateFunction()方法,实现在FTS5模块中注册。如果已经有一个同名的辅助函数,那么它将被新函数所取代。如果向xCreateFunction()传递了一个非NULL的xDestroy参数,那么当数据库句柄关闭或已注册的辅助函数被替换时,它将被调用,传递的pContext指针的副本作为唯一的参数。</target>
        </trans-unit>
        <trans-unit id="bbe3105d33c8a4906448b08f8925bf436af3dd67" translate="yes" xml:space="preserve">
          <source>The implementation is registered with the FTS5 module by calling the xCreateTokenizer() method of the fts5_api object. If there is already a tokenizer with the same name, it is replaced. If a non-NULL xDestroy parameter is passed to xCreateTokenizer(), it is invoked with a copy of the pContext pointer passed as the only argument when the database handle is closed or when the tokenizer is replaced.</source>
          <target state="translated">通过调用fts5_api对象的xCreateTokenizer()方法,实现在FTS5模块中注册。如果已经有一个同名的tokenizer,它将被替换。如果xCreateTokenizer()方法中传递了一个非NULL的xDestroy参数,那么当数据库句柄关闭或tokenizer被替换时,将以pContext指针的副本作为唯一的参数被调用。</target>
        </trans-unit>
        <trans-unit id="8b89a513d4c178ab8d213508b88c8e5c09e3c7a1" translate="yes" xml:space="preserve">
          <source>The implementation language for the example code is &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TCL&lt;/a&gt;, though you can easily do the same thing in another programming language. Remember that the code here is a demonstration of the technique, not a drop-in module that will automatically do everything for you. The demonstration code shown below is derived from actual code in production use. But you will need to make changes to tailor it to your application.</source>
          <target state="translated">示例代码的实现语言是&lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TCL&lt;/a&gt;，尽管您可以轻松地用另一种编程语言来做同样的事情。请记住，这里的代码是该技术的演示，而不是将自动为您做所有事情的嵌入式模块。下面显示的演示代码源自生产中的实际代码。但是您将需要进行更改以使其适合您的应用程序。</target>
        </trans-unit>
        <trans-unit id="1c7602fe1bd4486f649d10efe941c63ad9ebc01d" translate="yes" xml:space="preserve">
          <source>The implementation of this function could be enhanced in at least two ways:</source>
          <target state="translated">至少可以从两个方面加强这一功能的实施。</target>
        </trans-unit>
        <trans-unit id="fb654149d36243346cb33110dabec3f86ec0e93a" translate="yes" xml:space="preserve">
          <source>The important parts of the output (the parts that the developers pay the most attention to) are shown in red. Basically, the developers want to know the size of the compiled SQLite library and how many CPU cycles were needed to run the performance test.</source>
          <target state="translated">输出的重要部分(开发者最关注的部分)用红色显示。基本上,开发人员想知道编译后的SQLite库的大小,以及运行性能测试需要多少CPU周期。</target>
        </trans-unit>
        <trans-unit id="98a68810edc43f0319b74cd65a4602d55569695b" translate="yes" xml:space="preserve">
          <source>The imposter table mechanism is a power analysis and debugging tool for SQLite. But as with all sharp tools, it can also be dangerous and can result in corrupt database files if misused. Do not attempt to use imposter tables in an application. Imposter tables are intended for use in the laboratory by experts.</source>
          <target state="translated">冒名表机制是SQLite的一个强大的分析和调试工具。但是和所有的利器一样,它也是危险的,如果误用的话,可能会导致数据库文件的损坏。不要试图在应用程序中使用冒名表。冒牌表是供专家在实验室使用的。</target>
        </trans-unit>
        <trans-unit id="f137c1fa92f06c6d9054e4f6699dd72be9e8aeef" translate="yes" xml:space="preserve">
          <source>The in-header database size is only considered to be valid if it is non-zero and if the 4-byte &lt;a href=&quot;fileformat2#chngctr&quot;&gt;change counter&lt;/a&gt; at offset 24 exactly matches the 4-byte &lt;a href=&quot;fileformat2#validfor&quot;&gt;version-valid-for number&lt;/a&gt; at offset 92. The in-header database size is always valid when the database is only modified using recent versions of SQLite, versions 3.7.0 (2010-07-21) and later. If a legacy version of SQLite writes to the database, it will not know to update the in-header database size and so the in-header database size could be incorrect. But legacy versions of SQLite will also leave the version-valid-for number at offset 92 unchanged so it will not match the change-counter. Hence, invalid in-header database sizes can be detected (and ignored) by observing when the change-counter does not match the version-valid-for number.</source>
          <target state="translated">头内数据库大小只有在非零且偏移量为24 的4字节&lt;a href=&quot;fileformat2#chngctr&quot;&gt;更改计数器&lt;/a&gt;与偏移量92处的4字节&lt;a href=&quot;fileformat2#validfor&quot;&gt;版本有效号&lt;/a&gt;完全匹配时，才被认为是有效的。头内数据库当仅使用SQLite的最新版本3.7.0（2010-07-21）和更高版本修改数据库时，size始终有效。如果旧版本的SQLite写入数据库，它将不知道更新头中数据库的大小，因此头中数据库的大小可能不正确。但是SQLite的旧版本还将在偏移量92处保留版本有效号，因此它不会与更改计数器匹配。因此，可以通过观察更改计数器何时与版本有效期号不匹配来检测（并忽略）无效的页眉内数据库大小。</target>
        </trans-unit>
        <trans-unit id="856311d50a8fd5f75cd3339835ec40132b3ad9e1" translate="yes" xml:space="preserve">
          <source>The incremental_vacuum pragma causes up to</source>
          <target state="translated">递增式真空原则最多可以造成</target>
        </trans-unit>
        <trans-unit id="2dd53e3930b5b852ae3198064e374d5480957b02" translate="yes" xml:space="preserve">
          <source>The index is not usable at all because the left-most column of the index (column &quot;a&quot;) is not constrained. Assuming there are no other indices, the query above would result in a full table scan.</source>
          <target state="translated">该索引根本无法使用,因为该索引最左边的列(列 &quot;a&quot;)没有受到约束。假设没有其他索引,上面的查询将导致全表扫描。</target>
        </trans-unit>
        <trans-unit id="af8e63da60690ffa41a028a8c03b3a46553b1974" translate="yes" xml:space="preserve">
          <source>The index is not usable because the WHERE clause terms are connected by OR instead of AND. This query would result in a full table scan. However, if three additional indices where added that contained columns b, c, and d as their left-most columns, then the &lt;a href=&quot;#or_opt&quot;&gt;OR-clause optimization&lt;/a&gt; might apply.</source>
          <target state="translated">该索引不可用，因为WHERE子句项通过OR而不是AND连接。该查询将导致全表扫描。但是，如果添加的另外三个索引包含b，c和d列作为它们的最左列，则可能应用&lt;a href=&quot;#or_opt&quot;&gt;OR子句优化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="672cc6d4ea8af33a329ad85f582fc436091b60cb" translate="yes" xml:space="preserve">
          <source>The index of the term instance within its column. Terms are numbered in order of occurrence starting from 0.</source>
          <target state="translated">术语实例在其列中的索引。术语按出现的顺序从0开始编号。</target>
        </trans-unit>
        <trans-unit id="9be4bc1fc0e600b05c5d496186036ea84f9ef15d" translate="yes" xml:space="preserve">
          <source>The indexed documents are not stored within the SQLite database at all (a &quot;contentless&quot; FTS4 table), or</source>
          <target state="translated">索引的文档根本没有存储在SQLite数据库中(一个 &quot;无内容 &quot;的FTS4表),或</target>
        </trans-unit>
        <trans-unit id="e1d425e949e65fa344c6b8fb0277d12b499d6fc9" translate="yes" xml:space="preserve">
          <source>The indexed documents are stored in a database table created and managed by the user (an &quot;external content&quot; FTS4 table).</source>
          <target state="translated">索引文件存储在用户创建和管理的数据库表中(&quot;外部内容 &quot;FTS4表)。</target>
        </trans-unit>
        <trans-unit id="4aef068b1a0d56e1caa7dcf9dfa167672f1599ff" translate="yes" xml:space="preserve">
          <source>The infix LIKE operator is implemented by calling the application-defined SQL functions &lt;a href=&quot;lang_corefunc#like&quot;&gt;like(&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;X&lt;/i&gt;)&lt;/a&gt; or &lt;a href=&quot;lang_corefunc#like&quot;&gt;like(&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/a&gt;.</source>
          <target state="translated">通过调用应用程序定义的SQL函数&lt;a href=&quot;lang_corefunc#like&quot;&gt;（如（&lt;i&gt;Y&lt;/i&gt;，&lt;i&gt;X&lt;/i&gt;）&lt;/a&gt;或&lt;a href=&quot;lang_corefunc#like&quot;&gt;like（&lt;i&gt;Y&lt;/i&gt;，&lt;i&gt;X&lt;/i&gt;，&lt;i&gt;Z&lt;/i&gt;）&lt;/a&gt;来实现infix LIKE运算符。</target>
        </trans-unit>
        <trans-unit id="88a733d117cd4f0a7921fa6f2a987e25c2eb02d1" translate="yes" xml:space="preserve">
          <source>The information above can be recast into a table format as follows:</source>
          <target state="translated">上述信息可改写成如下表格格式:</target>
        </trans-unit>
        <trans-unit id="7c260215b8c7aaba3e0315515668088d0bdaae79" translate="yes" xml:space="preserve">
          <source>The information accessed using this API and its companion xPhraseFirstColumn() may also be obtained using xPhraseFirst/xPhraseNext (or xInst/xInstCount). The chief advantage of this API is that it is significantly more efficient than those alternatives when used with &quot;detail=column&quot; tables.</source>
          <target state="translated">使用该API及其配套的xPhraseFirstColumn()访问的信息也可以使用xPhraseFirst/xPhraseNext(或xInst/xInstCount)获得。这个API的主要优点是,当与 &quot;detail=column &quot;表一起使用时,它的效率明显高于这些替代方法。</target>
        </trans-unit>
        <trans-unit id="e6d1054c7b3f35c96345a991890c1e40578c9e8c" translate="yes" xml:space="preserve">
          <source>The information in the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure is ephemeral and may be overwritten or deallocated as soon as the xBestIndex method returns. If the xBestIndex method needs to remember any part of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure, it should make a copy. Care must be take to store the copy in a place where it will be deallocated, such as in the idxStr field with needToFreeIdxStr set to 1.</source>
          <target state="translated">&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;结构中的信息是短暂的，并且xBestIndex方法返回时可能会被覆盖或释放。如果xBestIndex方法需要记住&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;结构的任何部分，则应进行复制。必须注意将副本存储在将要释放的位置，例如，在NeedToFreeIdxStr设置为1的idxStr字段中。</target>
        </trans-unit>
        <trans-unit id="32cf05e222bbae76e66c5abe0ecf2fd84a3a7c70" translate="yes" xml:space="preserve">
          <source>The information in this article applies only when SQLite is operating in &quot;rollback mode&quot;, or in other words when SQLite is not using a &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;. SQLite still supports atomic commit when write-ahead logging is enabled, but it accomplishes atomic commit by a different mechanism from the one described in this article. See the &lt;a href=&quot;wal&quot;&gt;write-ahead log documentation&lt;/a&gt; for additional information on how SQLite supports atomic commit in that context.</source>
          <target state="translated">本文中的信息仅在SQLite在&amp;ldquo;回退模式&amp;rdquo;下运行时才适用，换句话说，当SQLite不使用&lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt;时才适用。启用预写日志记录后，SQLite仍支持原子提交，但是它通过与本文介绍的机制不同的机制来实现原子提交。有关SQLite在该上下文中如何支持原子提交的其他信息，请参见&lt;a href=&quot;wal&quot;&gt;预写日志文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f9342562e97e372cf7348a184a4d34dd086f3cc5" translate="yes" xml:space="preserve">
          <source>The initial &quot;INSERT&quot; keyword can be replaced by &quot;REPLACE&quot; or &quot;INSERT OR</source>
          <target state="translated">最初的 &quot;INSERT &quot;关键字可以用 &quot;REPLACE &quot;或 &quot;INSERT OR &quot;代替。</target>
        </trans-unit>
        <trans-unit id="d2a90ccaf25a62976be28829cc53054a6feb5a8b" translate="yes" xml:space="preserve">
          <source>The initial content is UTF-16 text and sqlite3_column_bytes() or sqlite3_column_text() is called. The content must be converted to UTF-8.</source>
          <target state="translated">初始内容为UTF-16文本,调用sqlite3_column_bytes()或sqlite3_column_text()。内容必须转换为UTF-8。</target>
        </trans-unit>
        <trans-unit id="f5abf60cee620000168958a8b5acfa6d74016d3a" translate="yes" xml:space="preserve">
          <source>The initial content is UTF-8 text and sqlite3_column_bytes16() or sqlite3_column_text16() is called. The content must be converted to UTF-16.</source>
          <target state="translated">初始内容为UTF-8文本,调用sqlite3_column_bytes16()或sqlite3_column_text16()。内容必须转换为UTF-16。</target>
        </trans-unit>
        <trans-unit id="16a79a9ef866be9ddb29420482c978bd29b5a111" translate="yes" xml:space="preserve">
          <source>The initial content is a BLOB and sqlite3_column_text() or sqlite3_column_text16() is called. A zero-terminator might need to be added to the string.</source>
          <target state="translated">初始内容是一个BLOB,调用sqlite3_column_text()或sqlite3_column_text16()。可能需要在字符串中添加一个零结束符。</target>
        </trans-unit>
        <trans-unit id="e8f78c0547aa09c0045543ed5c95b2ff19b12417" translate="yes" xml:space="preserve">
          <source>The initial implementation of NGQP chooses N=1 for simple queries, N=5 for two-way joins and N=10 for all joins with three or more tables. This formula for selecting N might change in subsequent releases.</source>
          <target state="translated">NGQP的初始实现对简单查询选择N=1,对双向连接选择N=5,对所有有三个或更多表的连接选择N=10。这个选择N的公式在后续版本中可能会改变。</target>
        </trans-unit>
        <trans-unit id="433c6a25716e7b035366d6fcddc3266fd3d25e85" translate="yes" xml:space="preserve">
          <source>The initial portion of the payload that does not spill to overflow pages.</source>
          <target state="translated">不溢出到溢出页的有效载荷的初始部分。</target>
        </trans-unit>
        <trans-unit id="a60a09b4b0f1a33259942d5b4f17c8bccd4a335d" translate="yes" xml:space="preserve">
          <source>The inner SELECT statement is implemented by instructions 1 through 10. All this code does is make an entry in the temporary table for each row of the examp2 table with a non-NULL value for the &quot;three&quot; column. The key for each temporary table entry is the &quot;three&quot; column of examp2 and the data is an empty string since it is never used.</source>
          <target state="translated">内部的SELECT语句由指令1至10实现。这段代码所做的就是在临时表中为examp2表的每一行做一个条目,&quot;三 &quot;列的值为非NULL。每个临时表条目的键是examp2的 &quot;三 &quot;列,数据是一个空字符串,因为它从未被使用过。</target>
        </trans-unit>
        <trans-unit id="059bc1f5d258819deb1954aaf03c0ff2e66225d4" translate="yes" xml:space="preserve">
          <source>The input data used by a simple SELECT query is a set of</source>
          <target state="translated">一个简单的SELECT查询所使用的输入数据是一系列的</target>
        </trans-unit>
        <trans-unit id="6894645090ea407676b9f33e59a0dad3066f4727" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete()&lt;/a&gt; must be a zero-terminated UTF-8 string.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete（）&lt;/a&gt;的输入必须是一个零终止的UTF-8字符串。</target>
        </trans-unit>
        <trans-unit id="4d7419b960ffd32c455a130a0e74d0adde2f9624" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete16()&lt;/a&gt; must be a zero-terminated UTF-16 string in native byte order.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete16（）&lt;/a&gt;的输入必须是以本机字节顺序为零终止的UTF-16字符串。</target>
        </trans-unit>
        <trans-unit id="4b672bd7f0a1d030d51edf7b207eec2b4f3ae087" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;complete&quot;&gt;sqlite3_complete()&lt;/a&gt; must be a zero-terminated UTF-8 string.</source>
          <target state="translated">&lt;a href=&quot;complete&quot;&gt;sqlite3_complete（）&lt;/a&gt;的输入必须是一个零终止的UTF-8字符串。</target>
        </trans-unit>
        <trans-unit id="cfd5dd711daa7423070d67fd7c844d95a0e5c24f" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;complete&quot;&gt;sqlite3_complete16()&lt;/a&gt; must be a zero-terminated UTF-16 string in native byte order.</source>
          <target state="translated">&lt;a href=&quot;complete&quot;&gt;sqlite3_complete16（）&lt;/a&gt;的输入必须是以本机字节顺序为零终止的UTF-16字符串。</target>
        </trans-unit>
        <trans-unit id="2d24c8f818c9e23a7423d1fe6a231842fef7a551" translate="yes" xml:space="preserve">
          <source>The inputs to TH3 are test modules written in C or SQL and small configuration files that determine how to initialize SQLite. The TH3 package includes 1,444 test modules and more than 47 configurations (as of 2018-05-19). New modules and configurations can be added to customize TH3 for specialized applications. Each time TH3 is run, it reads a subset of the available test modules and configuration files to generate a custom C program that performs all of the specified tests under all specified configurations. A complete test of SQLite normally involves running TH3 multiple times to generate multiple test programs covering different aspects of SQLite's operation, then linking all test programs against a common SQLite library and running them separately on the target platform.</source>
          <target state="translated">TH3的输入是用C或SQL编写的测试模块和决定如何初始化SQLite的小配置文件。TH3包包括1,444个测试模块和超过47种配置(截至2018-05-19)。可以添加新的模块和配置,以便为专门的应用定制TH3。每次运行TH3时,它都会读取可用的测试模块和配置文件的子集,以生成一个自定义C程序,在所有指定的配置下执行所有指定的测试。一个完整的SQLite测试通常需要多次运行TH3生成多个测试程序,涵盖SQLite操作的不同方面,然后将所有测试程序针对一个通用的SQLite库进行链接,并在目标平台上分别运行。</target>
        </trans-unit>
        <trans-unit id="bb4e6367e51d64e49b708aca20c83e616d792f73" translate="yes" xml:space="preserve">
          <source>The inspiration for this document is &lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt;. Among quality standards, DO-178B seems to have the highest usefulness to paperwork ratio. Even so, the amount of documentation needed for a full-up DO-178B implementation is vast. SQLite strives to be nimble and low-ceremony, and to that end, much of the required DO-178B documentation is omitted. We retain only those parts that genuinely improve quality for a open-source software project such as SQLite.</source>
          <target state="translated">本文档的灵感来自&lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt;。在质量标准中，DO-178B似乎对文书工作的使用率最高。即使这样，完整的DO-178B实施所需的文档数量仍然很大。SQLite努力做到敏捷和低礼仪，为此，省略了许多必需的DO-178B文档。我们仅保留那些真正提高了开源软件项目（例如SQLite）质量的部分。</target>
        </trans-unit>
        <trans-unit id="eeb6f7cf85fc1473abd39059a6c5676d36ad32d5" translate="yes" xml:space="preserve">
          <source>The instr(X,Y) function finds the first occurrence of string Y within string X and returns the number of prior characters plus 1, or 0 if Y is nowhere found within X. Or, if X and Y are both BLOBs, then instr(X,Y) returns one more than the number bytes prior to the first occurrence of Y, or 0 if Y does not occur anywhere within X. If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs then both are interpreted as strings. If either X or Y are NULL in instr(X,Y) then the result is NULL.</source>
          <target state="translated">instr(X,Y)函数在字符串X中找到字符串Y的首次出现,并返回前面的字符数加1,如果在X中找不到Y,则返回0。或者,如果X和Y都是BLOB,那么instr(X,Y)返回比Y首次出现之前的字节数多1,如果Y在X中没有出现,则返回0。如果instr(X,Y)的参数X和Y都是非NULL,并且不是BLOB,那么两者都被解释为字符串。如果在instr(X,Y)中X或Y都是NULL,那么结果就是NULL。</target>
        </trans-unit>
        <trans-unit id="a78743c67ceb66f35152669e19fad52bf271ff90" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Close&quot;&gt;Close&lt;/a&gt; closes a cursor previously opened as P1 (0, the only open cursor). If P1 is not currently open, this instruction is a no-op.</source>
          <target state="translated">&amp;ldquo; &lt;a href=&quot;opcode#Close&quot;&gt;关闭&lt;/a&gt; &amp;rdquo;指令关闭先前打开为P1（0，唯一打开的游标）的游标。如果P1当前未打开，则该指令为无操作。</target>
        </trans-unit>
        <trans-unit id="e8c5c65cb041570fcd5ae40ccc7306b738bb99f4" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Commit&quot;&gt;Commit&lt;/a&gt; causes all modifications to the database that have been made since the last Transaction to actually take effect. No additional modifications are allowed until another transaction is started. The Commit instruction deletes the journal file and releases the write lock on the database. A read lock continues to be held if there are still cursors open.</source>
          <target state="translated">&lt;a href=&quot;opcode#Commit&quot;&gt;提交&lt;/a&gt;指令使自上次事务处理以来对数据库所做的所有修改实际生效。在开始另一个事务之前，不允许进行其他修改。提交指令删除日志文件并释放数据库上的写锁。如果仍有游标打开，则将继续保持读锁定。</target>
        </trans-unit>
        <trans-unit id="71d724f14f1b112c6a8977fb693b84af3a6cb813" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; causes the VDBE engine to exit immediately. All open cursors, Lists, Sorts, etc are closed automatically. P1 is the result code returned by sqlite_exec(). For a normal halt, this should be SQLITE_OK (0). For errors, it can be some other value. The operand P2 is only used when there is an error. There is an implied &quot;Halt 0 0 0&quot; instruction at the end of every program, which the VDBE appends when it prepares a program to run.</source>
          <target state="translated">&lt;a href=&quot;opcode#Halt&quot;&gt;停止&lt;/a&gt;指令使VDBE引擎立即退出。所有打开的游标，列表，排序等都将自动关闭。 P1是sqlite_exec（）返回的结果代码。对于正常的停止，该值应为SQLITE_OK（0）。对于错误，它可以是其他值。仅在出现错误时才使用操作数P2。每个程序的末尾都有一个隐含的&amp;ldquo; Halt 0 0 0&amp;rdquo;指令，VDBE在准备要运行的程序时会附加该指令。</target>
        </trans-unit>
        <trans-unit id="4a2e93cc788564162251660dae046bf0362122e8" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#IdxRecno&quot;&gt;IdxRecno&lt;/a&gt; at 13 pushes onto the stack the table record number from the index. The following MoveTo pops it and moves the table cursor to that row. The next 3 instructions select the column data the same way as in the non- indexed case. The Column instructions fetch the column data and the callback function is invoked. The final Next instruction advances the index cursor, not the table cursor, to the next row, and then branches back to the start of the loop if there are any index records left.</source>
          <target state="translated">位于13 的指令&lt;a href=&quot;opcode#IdxRecno&quot;&gt;IdxRecno&lt;/a&gt;将来自索引的表记录号压入堆栈。下面的MoveTo弹出它，并将表格光标移动到该行。接下来的3条指令以与未索引情况相同的方式选择列数据。列指令获取列数据并调用回调函数。最后一条Next指令将索引游标（而不是表游标）前进到下一行，然后在剩余索引记录的情况下分支回到循环的开始。</target>
        </trans-unit>
        <trans-unit id="89a91a29199817279a977a2ce4541fd6e7fee24a" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt; pushes its P1 operand (99) onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">指令&lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt;将其P1操作数（99）压入堆栈。之后，堆栈如下所示：</target>
        </trans-unit>
        <trans-unit id="15f722b882a29ac5b03a20e923af0ef9dcb502b1" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt; pushes the integer value P1 (0) onto the stack. Here 0 is the number of the database to use in the following OpenWrite instruction. If P3 is not NULL then it is a string representation of the same integer. Afterwards the stack looks like this:</source>
          <target state="translated">指令&lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt;将整数值P1（0）压入堆栈。0是下面的OpenWrite指令中要使用的数据库的编号。如果P3不为NULL，则它是相同整数的字符串表示形式。之后，堆栈如下所示：</target>
        </trans-unit>
        <trans-unit id="d1df5b7ac8ac4ed32e40d9d958d1c725defad872" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; pops the top P1 elements off the stack (2 in this case) and converts them into the binary format used for storing records in a database file. (See the &lt;a href=&quot;fileformat&quot;&gt;file format&lt;/a&gt; description for details.) The new record generated by the MakeRecord instruction is pushed back onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;指令将顶部的P1元素弹出堆栈（在这种情况下为2），并将其转换为用于在数据库文件中存储记录的二进制格式。（有关详细信息，请参见&lt;a href=&quot;fileformat&quot;&gt;文件格式&lt;/a&gt;说明。）由MakeRecord指令生成的新记录将推回堆栈。之后，堆栈如下所示：</target>
        </trans-unit>
        <trans-unit id="21bb54c4787b5b030612c3d381e1ba9b4bb1f341" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#NewRecno&quot;&gt;NewRecno&lt;/a&gt; creates a new integer record number for the table pointed to by cursor P1. The record number is one not currently used as a key in the table. The new record number is pushed onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">指令&lt;a href=&quot;opcode#NewRecno&quot;&gt;NewRecno&lt;/a&gt;为光标P1指向的表创建一个新的整数记录号。记录号是当前未在表中用作键的记录号。新的记录号被压入堆栈。之后，堆栈如下所示：</target>
        </trans-unit>
        <trans-unit id="213073395c8927a399e8bb754b1febc0fe16eb95" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt; opens a new read/write cursor with handle P1 (0 in this case) on table &quot;examp&quot;, whose root page is P2 (3, in this database file). Cursor handles can be any non-negative integer. But the VDBE allocates cursors in an array with the size of the array being one more than the largest cursor. So to conserve memory, it is best to use handles beginning with zero and working upward consecutively. Here P3 (&quot;examp&quot;) is the name of the table being opened, but this is unused, and only generated to make the code easier to read. This instruction pops the database number to use (0, the main database) from the top of the stack, so afterwards the stack is empty again.</source>
          <target state="translated">指令&lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt;在表&amp;ldquo; examp&amp;rdquo;上用句柄P1（在这种情况下为0）打开一个新的读/写游标，该表的根页为P2（在此数据库文件中为3）。游标句柄可以是任何非负整数。但是VDBE在数组中分配游标，该数组的大小比最大游标大一。因此，为了节省内存，最好使用从零开始并连续向上处理的句柄。这里的P3（&amp;ldquo;示例&amp;rdquo;）是要打开的表的名称，但是未使用，仅是为了使代码易于阅读而生成的。该指令从堆栈顶部弹出要使用的数据库编号（0，即主数据库），因此此后堆栈再次为空。</target>
        </trans-unit>
        <trans-unit id="98bb30ff1b874474319c63eb890c40ec0fb09de2" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#PutIntKey&quot;&gt;PutIntKey&lt;/a&gt; uses the top 2 stack entries to write an entry into the table pointed to by cursor P1. A new entry is created if it doesn't already exist or the data for an existing entry is overwritten. The record data is the top stack entry, and the key is the next entry down. The stack is popped twice by this instruction. Because operand P2 is 1 the row change count is incremented and the rowid is stored for subsequent return by the sqlite_last_insert_rowid() function. If P2 is 0 the row change count is unmodified. This instruction is where the insert actually occurs.</source>
          <target state="translated">指令&lt;a href=&quot;opcode#PutIntKey&quot;&gt;PutIntKey&lt;/a&gt;使用前2个堆栈条目将条目写入光标P1指向的表中。如果尚不存在新条目或现有条目的数据被覆盖，则会创建一个新条目。记录数据是顶部堆栈条目，而键是下一个条目。该指令将堆栈弹出两次。因为操作数P2为1，所以行更改计数增加，并且存储rowid以供sqlite_last_insert_rowid（）函数随后返回。如果P2为0，则行更改计数不变。该指令是插入实际发生的位置。</target>
        </trans-unit>
        <trans-unit id="0b320ec6225176f371f5c1f951d40976365b4443" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; pushes its P3 operand onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">指令&lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt;将其P3操作数压入堆栈。之后，堆栈如下所示：</target>
        </trans-unit>
        <trans-unit id="d914ce420de942b21ca6d5eb303d1b4bdd87f483" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt; begins a transaction. The transaction ends when a Commit or Rollback opcode is encountered. P1 is the index of the database file on which the transaction is started. Index 0 is the main database file. A write lock is obtained on the database file when a transaction is started. No other process can read or write the file while the transaction is underway. Starting a transaction also creates a rollback journal. A transaction must be started before any changes can be made to the database.</source>
          <target state="translated">指令&lt;a href=&quot;opcode#Transaction&quot;&gt;交易&lt;/a&gt;开始交易。遇到Commit或Rollback操作码时，事务结束。 P1是在其上启动事务的数据库文件的索引。索引0是主数据库文件。启动事务时，将在数据库文件上获得写锁定。事务进行期间，没有其他进程可以读取或写入文件。启动事务还会创建回滚日志。必须先启动事务，然后才能对数据库进行任何更改。</target>
        </trans-unit>
        <trans-unit id="766fac627c726045a9f4c4dcb9828d544fcadbb2" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#VerifyCookie&quot;&gt;VerifyCookie&lt;/a&gt; checks cookie 0 (the database schema version) to make sure it is equal to P2 (the value obtained when the database schema was last read). P1 is the database number (0 for the main database). This is done to make sure the database schema hasn't been changed by another thread, in which case it has to be reread.</source>
          <target state="translated">指令&lt;a href=&quot;opcode#VerifyCookie&quot;&gt;VerifyCookie会&lt;/a&gt;检查cookie 0（数据库模式版本）以确保它等于P2（上一次读取数据库模式时获得的值）。 P1是数据库编号（主数据库为0）。这样做是为了确保数据库架构没有被另一个线程更改，在这种情况下，必须重新读取它。</target>
        </trans-unit>
        <trans-unit id="1541b9a811a194a4f9e80a336055e479ef3f480e" translate="yes" xml:space="preserve">
          <source>The instruction at address 9 implements the branching part of the loop. Together with the Rewind at address 5 it forms the loop logic. This is a key concept that you should pay close attention to. The &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; instruction advances the cursor P1 to the next record. If the cursor advance was successful, then jump immediately to P2 (6, the beginning of the loop body). If the cursor was at the end, then fall through to the following instruction, which ends the loop.</source>
          <target state="translated">地址9处的指令实现了循环的分支部分。它与地址5的倒带一起形成循环逻辑。这是您应该密切注意的关键概念。在&lt;a href=&quot;opcode#Next&quot;&gt;下一步&lt;/a&gt;指令游标前进P1到下一个记录。如果光标前进成功，则立即跳转到P2（循环主体的开始6）。如果光标位于末尾，则进入以下指令，从而结束循环。</target>
        </trans-unit>
        <trans-unit id="14da6ae11560ca2b2c31ae75e094431766a4621e" translate="yes" xml:space="preserve">
          <source>The instruction at the address in register P1 is a &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt;. &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; to the P2 parameter of that &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt;. After the jump, register P1 becomes undefined.</source>
          <target state="translated">寄存器P1中地址处的指令为&lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt;。&lt;a href=&quot;opcode#Jump&quot;&gt;跳至&lt;/a&gt;该&lt;a href=&quot;opcode#Yield&quot;&gt;收益率&lt;/a&gt;的P2参数。跳转后，寄存器P1变为未定义。</target>
        </trans-unit>
        <trans-unit id="cd201e480371afb73e8686f10704843996fccd91" translate="yes" xml:space="preserve">
          <source>The instructions 6 through 8 form the body of the loop that will execute once for each record in the database file. The &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; instructions at addresses 6 and 7 each take the P2-th column from the P1-th cursor and push it onto the stack. In this example, the first Column instruction is pushing the value for the column &quot;one&quot; onto the stack and the second Column instruction is pushing the value for column &quot;two&quot;. The &lt;a href=&quot;opcode#Callback&quot;&gt;Callback&lt;/a&gt; instruction at address 8 invokes the callback() function. The P1 operand to Callback becomes the value for &lt;b&gt;nColumn&lt;/b&gt;. The Callback instruction pops P1 values from the stack and uses them to fill the &lt;b&gt;azData[]&lt;/b&gt; array.</source>
          <target state="translated">指令6至8构成循环的主体，该循环将对数据库文件中的每个记录执行一次。地址6和7 的&lt;a href=&quot;opcode#Column&quot;&gt;列&lt;/a&gt;指令分别从第P1个游标获取第P2列，并将其压入堆栈。在此示例中，第一个Column指令将列&amp;ldquo; one&amp;rdquo;的值压入堆栈，第二个Column指令将列&amp;ldquo; two&amp;rdquo;的值压入堆栈。地址8 的&lt;a href=&quot;opcode#Callback&quot;&gt;Callback&lt;/a&gt;指令调用callback（）函数。回调的P1操作数成为&lt;b&gt;nColumn&lt;/b&gt;的值。回调指令从堆栈中弹出P1值，并使用它们填充&lt;b&gt;azData []&lt;/b&gt;数组。</target>
        </trans-unit>
        <trans-unit id="c46964020db9e221e22ce0203153f52f7c4afbe0" translate="yes" xml:space="preserve">
          <source>The integer values returned by two invocations of &quot;PRAGMA data_version&quot; from the same connection will be different if changes were committed to the database by any other connection in the interim. The &quot;PRAGMA data_version&quot; value is unchanged for commits made on the same database connection. The behavior of &quot;PRAGMA data_version&quot; is the same for all database connections, including database connections in separate processes and &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; database connections.</source>
          <target state="translated">如果在此期间任何其他连接将更改提交给数据库，则从同一连接两次调用&amp;ldquo; PRAGMA data_version&amp;rdquo;返回的整数值将有所不同。对于在同一数据库连接上进行的提交，&amp;ldquo; PRAGMA data_version&amp;rdquo;值不变。所有数据库连接（包括独立进程中的数据库连接和&lt;a href=&quot;sharedcache&quot;&gt;共享缓存&lt;/a&gt;数据库连接）的&amp;ldquo; PRAGMA data_version&amp;rdquo;行为都是相同的。</target>
        </trans-unit>
        <trans-unit id="4e05f2b57d17a355c0ea1387908101e6bd52b31e" translate="yes" xml:space="preserve">
          <source>The integer values to xLock() and xUnlock() are one of</source>
          <target state="translated">xLock()和xUnlock()的整数值是其中之一。</target>
        </trans-unit>
        <trans-unit id="3a9652af526f0c1e8a87ab92c4d5d7f777a76ac5" translate="yes" xml:space="preserve">
          <source>The integrity-check command is invoked by inserting the text value 'integrity-check' into the special column with the same name as the FTS5 table. For example:</source>
          <target state="translated">通过在与FTS5表同名的特殊列中插入文本值 &quot;诚信检查 &quot;来调用诚信检查命令。例如:</target>
        </trans-unit>
        <trans-unit id="8b9cbbc162055ec87304da9b44deb92f428d9750" translate="yes" xml:space="preserve">
          <source>The intended use of this pragma is only for testing and validation of SQLite. This pragma is subject to change without notice and is not recommended for use by application programs.</source>
          <target state="translated">这个pragma的预期用途只是为了测试和验证SQLite。这个pragma可能会在没有通知的情况下发生变化,不建议应用程序使用。</target>
        </trans-unit>
        <trans-unit id="ff65b14ad46243e5d5f2ba9708d0bfaa67d238c4" translate="yes" xml:space="preserve">
          <source>The intent of the developers is to support SQLite through the year 2050.</source>
          <target state="translated">开发者的意图是支持SQLite到2050年。</target>
        </trans-unit>
        <trans-unit id="b8c5c15fb8411770e1f2302c0a93c745cb58106c" translate="yes" xml:space="preserve">
          <source>The intent of these enhancements to the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; and &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; commands is to ensure that they cannot be used to create a database that contains foreign key violations, at least while foreign key constraints are enabled. There is one exception to this rule though. If a parent key is not subject to a PRIMARY KEY or UNIQUE constraint created as part of the parent table definition, but is subject to a UNIQUE constraint by virtue of an index created using the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; command, then the child table may be populated without causing a &quot;foreign key mismatch&quot; error. If the UNIQUE index is dropped from the database schema, then the parent table itself is dropped, no error will be reported. However the database may be left in a state where the child table of the foreign key constraint contains rows that do not refer to any parent table row. This case can be avoided if all parent keys in the database schema are constrained by PRIMARY KEY or UNIQUE constraints added as part of the parent table definition, not by external UNIQUE indexes.</source>
          <target state="translated">对&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;和&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;命令进行这些增强的目的是确保至少在启用外键约束的情况下，不能将它们用于创建包含外键违规的数据库。但是，此规则有一个例外。如果父键不受作为父表定义一部分创建的PRIMARY KEY或UNIQUE约束的约束，但由于使用&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;创建的索引而受UNIQUE约束的约束命令，然后可以填充子表而不会引起&amp;ldquo;外键不匹配&amp;rdquo;错误。如果从数据库架构中删除了UNIQUE索引，那么父表本身也将被删除，则不会报告任何错误。但是，数据库可能处于外键约束的子表包含不引用任何父表行的行的状态。如果数据库架构中的所有父键都由作为父表定义的一部分添加的PRIMARY KEY或UNIQUE约束而不是由外部UNIQUE索引约束，则可以避免这种情况。</target>
        </trans-unit>
        <trans-unit id="f25fb84e751737880254b9bbae4d5bcd681d4573" translate="yes" xml:space="preserve">
          <source>The interface between the VDBE and B-Tree layer is enhanced such that the VDBE provides hints to the B-Tree layer letting the B-Tree layer know when it is safe to use hashing instead of B-Trees for transient tables.</source>
          <target state="translated">VDBE和B-Tree层之间的接口得到了增强,VDBE为B-Tree层提供了提示,让B-Tree层知道什么时候使用哈希而不是B-Tree来处理瞬时表是安全的。</target>
        </trans-unit>
        <trans-unit id="8f6df7d6e95fb6e2e2d0cc834a6496c76dd46264" translate="yes" xml:space="preserve">
          <source>The interface to the B-tree subsystem and the rest of the SQLite library is defined by the header file &lt;a href=&quot;https://sqlite.org/src/file/src/btree.h&quot;&gt;btree.h&lt;/a&gt;.</source>
          <target state="translated">B-tree子系统和其余SQLite库的接口&lt;a href=&quot;https://sqlite.org/src/file/src/btree.h&quot;&gt;由头&lt;/a&gt;文件btree.h定义。</target>
        </trans-unit>
        <trans-unit id="b91796ad2d511be2d8979f83ba1c6fb0431a4019" translate="yes" xml:space="preserve">
          <source>The interface to the SQLite library consists of single tcl command named &lt;b&gt;sqlite3&lt;/b&gt; Because there is only this one command, the interface is not placed in a separate namespace.</source>
          <target state="translated">SQLite库的接口由单个名为&lt;b&gt;sqlite3的&lt;/b&gt; tcl命令组成。由于只有一个命令，因此该接口不会放置在单独的命名空间中。</target>
        </trans-unit>
        <trans-unit id="3c849c0d323b0ad6135a0bb1621f8f7a986a9fa1" translate="yes" xml:space="preserve">
          <source>The interface to the SQLite library consists of three core functions, one opaque data structure, and some constants used as return values. The core interface is as follows:</source>
          <target state="translated">SQLite库的接口由三个核心函数、一个不透明的数据结构和一些用作返回值的常量组成。核心接口如下。</target>
        </trans-unit>
        <trans-unit id="da5910db62046423c913e2518dadca7a36c2bb7d" translate="yes" xml:space="preserve">
          <source>The interface used by the implementation of the aforementioned functions to retrieve the collation sequence set by this opcode is not available publicly. Only built-in functions have access to this feature.</source>
          <target state="translated">上述函数的实现用来检索该操作码设置的整理序列的接口是不公开的。只有内置的函数可以使用这个功能。</target>
        </trans-unit>
        <trans-unit id="1824212549f384e7aed12eb3886c9cf696af6dde" translate="yes" xml:space="preserve">
          <source>The interfaces necessary to construct a function that is sometimes deterministic and sometimes non-deterministic depending on their inputs, such as the built-in date/time functions, are not published. Generic &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; must be always deterministic or always non-deterministic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82c461e3315f13aa8457935ffce58f8ac7ef7cd3" translate="yes" xml:space="preserve">
          <source>The interfaces necessary to construct a function that is sometimes deterministic and sometimes non-deterministic depending on their inputs, such as the built-in date/time functions, are not published. Generic &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; must be always deterministic or always non-deterministic.</source>
          <target state="translated">未发布构造有时取决于其输入的确定性和有时不确定性的功能所必需的接口，例如内置的日期/时间函数。通用的&lt;a href=&quot;c3ref/create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;必须始终是确定性的或始终是不确定性的。</target>
        </trans-unit>
        <trans-unit id="15015bc60e3376a39ca9d7ebc27d602beffae1d0" translate="yes" xml:space="preserve">
          <source>The internal Mem object stores the value for a single register. The abstract &lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt; object that is exposed in the API is really just a Mem object or register.</source>
          <target state="translated">内部Mem对象存储单个寄存器的值。API中公开的抽象&lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt;对象实际上只是一个Mem对象或寄存器。</target>
        </trans-unit>
        <trans-unit id="e1059fa5a511cb460ad6acfc6dbdaaa7898a9f5d" translate="yes" xml:space="preserve">
          <source>The internal organization of the SQLite library can be viewed as the stack of modules shown to the right. The Tokenizer, Parser, and Code Generator components are used to process SQL statements and convert them into executable programs in a virtual machine language or byte code. Roughly speaking, these top three layers implement &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. The byte code generated by the top three layers is a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt;. The Virtual Machine module is responsible for running the SQL statement byte code. The B-Tree module organizes a database file into multiple key/value stores with ordered keys and logarithmic performance. The Pager module is responsible for loading pages of the database file into memory, for implementing and controlling transactions, and for creating and maintaining the journal files that prevent database corruption following a crash or power failure. The OS Interface is a thin abstraction that provides a common set of routines for adapting SQLite to run on different operating systems. Roughly speaking, the bottom four layers implement &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">SQLite库的内部组织可以视为如右图所示的模块堆栈。令牌生成器，解析器和代码生成器组件用于处理SQL语句，并将其转换为虚拟机语言或字节码的可执行程序。粗略地说，这三层实现了&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;。前三层生成的字节码是&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;。虚拟机模块负责运行SQL语句字节代码。B-Tree模块将数据库文件组织到具有有序键和对数性能的多个键/值存储中。Pager模块负责将数据库文件的页面加载到内存中，以实现和控制事务，并创建和维护日记文件，以防止崩溃或电源故障后数据库损坏。OS Interface是一个瘦的抽象，它提供了一套通用的例程，以使SQLite适应在不同的操作系统上运行。粗略地讲，最下面的四层实现&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b82fe06906efdf8da65bc9a3b09aabf0c14e629e" translate="yes" xml:space="preserve">
          <source>The internet is an increasingly hostile place. These day, developers should assume that attackers will find a way to execute arbitrary SQL in an application. Applications should be designed to prevent the execution of arbitrary SQL from escalating into a more severe exploit.</source>
          <target state="translated">互联网是一个越来越敌对的地方。如今,开发人员应该假设攻击者会找到一种方法在应用程序中执行任意SQL。应用程序的设计应该防止任意SQL的执行升级为更严重的利用。</target>
        </trans-unit>
        <trans-unit id="541368df6be3b3211d485998b29f10dd5bcba535" translate="yes" xml:space="preserve">
          <source>The interpretation of the final column, if it is present, is &lt;a href=&quot;swarmvtab#component_table_context_values&quot;&gt;described here&lt;/a&gt;.</source>
          <target state="translated">如果存在最后一栏，则&lt;a href=&quot;swarmvtab#component_table_context_values&quot;&gt;在此处进行说明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ecf9411adae8ae3787bf4274e751f3717d6110f0" translate="yes" xml:space="preserve">
          <source>The ioctl on Mac OS X to control syncing to disk is F_FULLFSYNC, not F_FULLSYNC. The previous release had it wrong.</source>
          <target state="translated">Mac OS X 上控制同步到磁盘的 ioctl 是 F_FULLFSYNC,而不是 F_FULLSYNC。以前的版本是错的。</target>
        </trans-unit>
        <trans-unit id="d9c0a5f06c6830c793bad013d5441e96d45f8af0" translate="yes" xml:space="preserve">
          <source>The job of the eval method is to execute the SQL statement or statements given in the second argument. For example, to create a new table in a database, you can do this:</source>
          <target state="translated">eval方法的工作是执行第二个参数中给出的SQL语句或语句。例如,要在数据库中创建一个新表,可以这样做。</target>
        </trans-unit>
        <trans-unit id="ce55e90a07de980cc86c5f2dfac419a865729e47" translate="yes" xml:space="preserve">
          <source>The job of this method is to construct the new virtual table object (an &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object) and return a pointer to it in *ppVTab.</source>
          <target state="translated">此方法的工作是构造新的虚拟表对象（&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;对象），并在* ppVTab中返回指向它的指针。</target>
        </trans-unit>
        <trans-unit id="82b29f2835b0336ce594d7095e779f9ce1307885" translate="yes" xml:space="preserve">
          <source>The journal header is non-zero and well-formed, and</source>
          <target state="translated">日志标头是非零的,而且格式良好,而且。</target>
        </trans-unit>
        <trans-unit id="3978774f2c0624ee0736d9f40af64bca3b94a2e0" translate="yes" xml:space="preserve">
          <source>The journal tests are an additional double-check over and above the crash tests to make sure that SQLite transactions will be atomic across system crashes and power failures.</source>
          <target state="translated">日志测试是在崩溃测试之上的额外双重检查,以确保SQLite事务在系统崩溃和电源故障时是原子的。</target>
        </trans-unit>
        <trans-unit id="eadea62ca220c75cf3d8b7ee7d22ba8de7aa3934" translate="yes" xml:space="preserve">
          <source>The journal_mode pragma returns a string which is the new journal mode. On success, the pragma will return the string &quot;&lt;code&gt;wal&lt;/code&gt;&quot;. If the conversion to WAL could not be completed (for example, if the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; does not support the necessary shared-memory primitives) then the journaling mode will be unchanged and the string returned from the primitive will be the prior journaling mode (for example &quot;&lt;code&gt;delete&lt;/code&gt;&quot;).</source>
          <target state="translated">journal_mode编译指示返回一个字符串，它是新的日志模式。成功时，编译指示将返回字符串&amp;ldquo; &lt;code&gt;wal&lt;/code&gt; &amp;rdquo;。如果无法完成向WAL的转换（例如，如果&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;不支持必要的共享内存原语），则日记记录模式将保持不变，并且从原语返回的字符串将是先前的日记记录模式（例如&amp;ldquo; &lt;code&gt;delete&lt;/code&gt; &amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="cf12bc7373958f09d761ed0f9bf5075e87444a0e" translate="yes" xml:space="preserve">
          <source>The journal_size_limit pragma may be used to limit the size of rollback-journal and WAL files left in the file-system after transactions or checkpoints. Each time a transaction is committed or a WAL file resets, SQLite compares the size of the rollback journal file or WAL file left in the file-system to the size limit set by this pragma and if the journal or WAL file is larger it is truncated to the limit.</source>
          <target state="translated">journal_size_limit pragma可以用来限制事务或检查点之后留在文件系统中的回滚日志文件和WAL文件的大小。每当一个事务被提交或WAL文件被重置时,SQLite会将留在文件系统中的回滚日志文件或WAL文件的大小与这个pragma设置的大小限制进行比较,如果日志或WAL文件的大小较大,则会被截断到该限制。</target>
        </trans-unit>
        <trans-unit id="e4ee7815366ce998637e6c73fab93997f9ad3bf9" translate="yes" xml:space="preserve">
          <source>The json(X) function verifies that its argument X is a valid JSON string and returns a minified version of that JSON string (with all unnecessary whitespace removed). If X is not a well-formed JSON string, then this routine throws an error.</source>
          <target state="translated">json(X)函数验证其参数X是一个有效的JSON字符串,并返回该JSON字符串的最小化版本(去掉所有不必要的空格)。如果X不是一个格式良好的JSON字符串,那么这个例程会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="b38a8f8844d02f721e88e8305af9dc835b4312f1" translate="yes" xml:space="preserve">
          <source>The json1 extension (currently) stores JSON as ordinary text.</source>
          <target state="translated">json1扩展(目前)以普通文本的形式存储JSON。</target>
        </trans-unit>
        <trans-unit id="600cff3bfb9b2a0fb597c7fc0f7fa3f65076ca7b" translate="yes" xml:space="preserve">
          <source>The json1 extension does not (currently) support a binary encoding of JSON. Experiments have been unable to find a binary encoding that is significantly smaller or faster than a plain text encoding. (The present implementation parses JSON text at over 1 GB/s.) All json1 functions currently throw an error if any of their arguments are BLOBs because BLOBs are reserved for a future enhancement in which BLOBs will store the binary encoding for JSON.</source>
          <target state="translated">json1扩展(目前)不支持JSON的二进制编码。实验无法找到比纯文本编码更小更快的二进制编码。(目前的实现以超过1 GB/s的速度解析JSON文本。)目前所有的json1函数如果其任何参数是BLOBs,都会抛出一个错误,因为BLOBs是为将来的增强版保留的,其中BLOBs将存储JSON的二进制编码。</target>
        </trans-unit>
        <trans-unit id="50447979a47d38485f569438ae4849e4fe11a47d" translate="yes" xml:space="preserve">
          <source>The json1 extension uses the &lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; interfaces that were introduced with SQLite version 3.9.0 (2015-10-14) The json1 extension will not work in earlier versions of SQLite.</source>
          <target state="translated">json1扩展使用SQLite版本3.9.0（2015-10-14）引入的&lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype（）&lt;/a&gt;和&lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype（）&lt;/a&gt;接口json1扩展在早期版本的SQLite中将不起作用。</target>
        </trans-unit>
        <trans-unit id="96336d37aaa994d4a790a5daf6a1eabf939e9f47" translate="yes" xml:space="preserve">
          <source>The json1 source code is included with the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, though it is disabled by default. Add the &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; compile-time option to enable the json1 extension that is built into the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. The standard makefiles include -DSQLITE_ENABLE_JSON1 when building the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; and some of the test utilities so this extension is normally available in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">json1源代码包含在SQLite &lt;a href=&quot;amalgamation&quot;&gt;合并中&lt;/a&gt;，但默认情况下已禁用。添加&lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt;编译时选项，以启用内置于&lt;a href=&quot;amalgamation&quot;&gt;amalgamation中&lt;/a&gt;的json1扩展。构建&lt;a href=&quot;cli&quot;&gt;命令行外壳&lt;/a&gt;程序时，标准的makefile包括-DSQLITE_ENABLE_JSON1 以及一些测试实用程序，因此此扩展名通常在&lt;a href=&quot;cli&quot;&gt;命令行外壳&lt;/a&gt;程序中可用。</target>
        </trans-unit>
        <trans-unit id="bb08cc12ccf8da2d3e2af52ece257a447253b7e8" translate="yes" xml:space="preserve">
          <source>The json_array() SQL function accepts zero or more arguments and returns a well-formed JSON array that is composed from those arguments. If any argument to json_array() is a BLOB then an error is thrown.</source>
          <target state="translated">json_array()SQL函数接受0个或多个参数,并返回一个由这些参数组成的格式良好的JSON数组。如果json_array()的任何参数是一个BLOB,那么就会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="9521182f315a0d302eb912198a80302f20c295c7" translate="yes" xml:space="preserve">
          <source>The json_array_length(X) function returns the number of elements in the JSON array X, or 0 if X is some kind of JSON value other than an array. The json_array_length(X,P) locates the array at path P within X and returns the length of that array, or 0 if path P locates an element or X other than a JSON array, and NULL if path P does not locate any element of X. Errors are thrown if either X is not well-formed JSON or if P is not a well-formed path.</source>
          <target state="translated">json_array_length(X)函数返回JSON数组X中的元素数,如果X是数组以外的JSON值,则返回0。json_array_length(X,P)函数定位X中的路径P处的数组,并返回数组的长度,如果路径P定位到了JSON数组以外的元素或X,则返回0;如果路径P没有定位到X中的任何元素,则返回NULL。如果X不是格式良好的JSON,或者P不是格式良好的路径,则会产生错误。</target>
        </trans-unit>
        <trans-unit id="a38155ffebbf6577ab0909bd9445bf04a40481a5" translate="yes" xml:space="preserve">
          <source>The json_each(X) and json_tree(X) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; walk the JSON value provided as their first argument and return one row for each element. The json_each(X) function only walks the immediate children of the top-level array or object or or just the top-level element itself if the top-level element is a primitive value. The json_tree(X) function recursively walks through the JSON substructure starting with the top-level element.</source>
          <target state="translated">&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt; json_each（X）和json_tree（X）遍历作为其第一个参数提供的JSON值，并为每个元素返回一行。json_each（X）函数仅遍历顶级数组或对象的直接子级，或者如果顶级元素是原始值，则仅遍历顶级元素本身。json_tree（X）函数以递归的方式遍历从顶层元素开始的JSON子结构。</target>
        </trans-unit>
        <trans-unit id="41fff21b05289cb2b0be52b887077b0fcae3db31" translate="yes" xml:space="preserve">
          <source>The json_each(X,P) and json_tree(X,P) functions work just like their one-argument counterparts except that they treat the element identified by path P as the top-level element.</source>
          <target state="translated">json_each(X,P)和json_tree(X,P)函数的工作原理和它们的单参数对应函数一样,只是它们将路径P所标识的元素视为顶层元素。</target>
        </trans-unit>
        <trans-unit id="c2ff80179397d0e306699ce5e6f1d0c9aff0af74" translate="yes" xml:space="preserve">
          <source>The json_extract(X,P1,P2,...) extracts and returns one or more values from the well-formed JSON at X. If only a single path P1 is provided, then the SQL datatype of the result is NULL for a JSON null, INTEGER or REAL for a JSON numeric value, an INTEGER zero for a JSON false value, an INTEGER one for a JSON true value, the dequoted text for a JSON string value, and a text representation for JSON object and array values. If there are multiple path arguments (P1, P2, and so forth) then this routine returns SQLite text which is a well-formed JSON array holding the various values.</source>
          <target state="translated">json_extract(X,P1,P2,...)从X处格式良好的JSON中提取并返回一个或多个值。如果只提供了一个路径P1,那么结果的SQL数据类型为:JSON空值为NULL,JSON数值为INTEGER或REAL,JSON假值为INTEGER 0,JSON真值为INTEGER 1,JSON字符串值为去引号文本,JSON对象和数组值为文本表示。如果有多个路径参数(P1、P2等),那么这个例程就会返回SQLite文本,这个文本是一个格式良好的JSON数组,存放着各种值。</target>
        </trans-unit>
        <trans-unit id="0f1627c2753898c7b2ebba7d223fce4a18da0c11" translate="yes" xml:space="preserve">
          <source>The json_group_array(X) function is an &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate SQL function&lt;/a&gt; that returns a JSON array comprised of all X values in the aggregation. Similarly, the json_group_object(NAME,VALUE) function returns a JSON object comprised of all NAME/VALUE pairs in the aggregation.</source>
          <target state="translated">json_group_array（X）函数是一个&lt;a href=&quot;lang_aggfunc&quot;&gt;聚合SQL函数&lt;/a&gt;，该函数返回一个由聚合中所有X值组成的JSON数组。同样，json_group_object（NAME，VALUE）函数返回由聚合中的所有NAME / VALUE对组成的JSON对象。</target>
        </trans-unit>
        <trans-unit id="08b54ec339ea85bd242a6d5ab159f649d0636c35" translate="yes" xml:space="preserve">
          <source>The json_insert(), json_replace(), and json_set() functions always take an odd number of arguments. The first argument is always the original JSON to be edited. Subsequent arguments occur in pairs with the first element of each pair being a path and the second element being the value to insert or replace or set on that path.</source>
          <target state="translated">json_insert()、json_replace()和json_set()函数总是取奇数的参数。第一个参数总是要编辑的原始JSON。随后的参数成对出现,每个参数对的第一个元素是一个路径,第二个元素是要插入或替换或设置在该路径上的值。</target>
        </trans-unit>
        <trans-unit id="cc677da89c2d6a3534f49f58dca0325fe7275ac0" translate="yes" xml:space="preserve">
          <source>The json_insert(), json_replace, and json_set() functions all take a single JSON value as their first argument followed by zero or more pairs of path and value arguments, and return a new JSON string formed by updating the input JSON by the path/value pairs. The functions differ only in how they deal with creating new values and overwriting preexisting values.</source>
          <target state="translated">json_insert()、json_replace和json_set()函数都以一个JSON值作为它们的第一个参数,后面跟着零个或多个路径和值参数对,并返回一个新的JSON字符串,这个字符串是通过更新输入的JSON的路径/值对形成的。这些函数的不同之处仅在于它们如何处理创建新值和覆盖已有值。</target>
        </trans-unit>
        <trans-unit id="a89fe09131a222458243e59c86a47b9418f5cefc" translate="yes" xml:space="preserve">
          <source>The json_object() SQL function accepts zero or more pairs of arguments and returns a well-formed JSON object that is composed from those arguments. The first argument of each pair is the label and the second argument of each pair is the value. If any argument to json_object() is a BLOB then an error is thrown.</source>
          <target state="translated">json_object()SQL函数接受0个或多个参数对,并返回一个由这些参数组成的格式良好的JSON对象。每对参数的第一个参数是标签,第二个参数是值。如果json_object()的任何参数是一个BLOB,那么就会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="2288fffe16f420052bb17e5c8958c3ccdbc841f2" translate="yes" xml:space="preserve">
          <source>The json_object() function currently allows duplicate labels without complaint, though this might change in a future enhancement.</source>
          <target state="translated">json_object()函数目前允许重复的标签,不过这一点可能会在未来的改进中改变。</target>
        </trans-unit>
        <trans-unit id="5e496b884466eb1ac12c106e9502f3cd98163883" translate="yes" xml:space="preserve">
          <source>The json_patch(T,P) SQL function runs the &lt;a href=&quot;https://tools.ietf.org/html/rfc7396&quot;&gt;RFC-7396&lt;/a&gt; MergePatch algorithm to apply patch P against input T. The patched copy of T is returned.</source>
          <target state="translated">json_patch（T，P）SQL函数运行&lt;a href=&quot;https://tools.ietf.org/html/rfc7396&quot;&gt;RFC-7396&lt;/a&gt; MergePatch算法，将补丁P应用于输入T。返回T的补丁副本。</target>
        </trans-unit>
        <trans-unit id="d843d41461d41ce71296d2cc16a75e0d0ddb050b" translate="yes" xml:space="preserve">
          <source>The json_quote(X) function converts the SQL value X (a number or a string) into its corresponding JSON representation.</source>
          <target state="translated">json_quote(X)函数将SQL值X(一个数字或字符串)转换为相应的JSON表示。</target>
        </trans-unit>
        <trans-unit id="076810db69b99bc12f8c66592e6373c496370f8e" translate="yes" xml:space="preserve">
          <source>The json_remove() function throws an error if the first argument is not well-formed JSON or if any later argument is not a well-formed path, or if any argument is a BLOB.</source>
          <target state="translated">如果第一个参数不是格式良好的JSON,或者任何后面的参数不是格式良好的路径,或者任何参数是BLOB,那么json_remove()函数会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="07c228732927cc33b2fd2172e7d852ff75280285" translate="yes" xml:space="preserve">
          <source>The json_remove(X,P,...) function takes a single JSON value as its first argument followed by zero or more path arguments. The json_remove(X,P,...) function returns a new JSON value that is the X with all the elements identified by path arguments removed. Paths that select elements not found in X are silently ignored.</source>
          <target state="translated">json_remove(X,P,...)函数的第一个参数是一个JSON值,后面是0个或多个路径参数。json_remove(X,P,...)函数返回一个新的JSON值,这个新的JSON值就是X,它包含了路径参数所标识的所有元素。选择在X中没有找到的元素的路径会被默默忽略。</target>
        </trans-unit>
        <trans-unit id="dc2a43381f4cc4dcc4e70977bde02a9d9d1a46e8" translate="yes" xml:space="preserve">
          <source>The json_type() function throws an error if any of its arguments are not well-formed or is a BLOB.</source>
          <target state="translated">如果它的任何一个参数不是形式良好的或者是BLOB,json_type()函数会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="4607298214330613e115639247f1a2af460f4cfe" translate="yes" xml:space="preserve">
          <source>The json_type(X) function returns the &quot;type&quot; of the outermost element of X. The json_type(X,P) function returns the &quot;type&quot; of the element in X that is selected by path P. The &quot;type&quot; returned by json_type() is on of the following an SQL text values: 'null', 'true', 'false', 'integer', 'real', 'text', 'array', or 'object'. If the path P in json_type(X,P) selects an element that does not exist in X, then this function returns NULL.</source>
          <target state="translated">json_type(X)函数返回X中最外层元素的 &quot;类型&quot;。json_type(X,P)函数返回X中被路径P选中的元素的 &quot;类型&quot;。json_type()返回的 &quot;类型 &quot;是以下SQL文本值中的一种。'null'、'true'、'false'、'integer'、'real'、'text'、'array'或'object'。如果json_type(X,P)中的路径P选择了一个在X中不存在的元素,那么这个函数返回NULL。</target>
        </trans-unit>
        <trans-unit id="719a758ba2801754e03a7b8fe39124f85c9b0d1b" translate="yes" xml:space="preserve">
          <source>The json_type(X) function returns the &quot;type&quot; of the outermost element of X. The json_type(X,P) function returns the &quot;type&quot; of the element in X that is selected by path P. The &quot;type&quot; returned by json_type() is one of the following an SQL text values: 'null', 'true', 'false', 'integer', 'real', 'text', 'array', or 'object'. If the path P in json_type(X,P) selects an element that does not exist in X, then this function returns NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98bb00412965806c0f2fa0e24dcf65a44105fd64" translate="yes" xml:space="preserve">
          <source>The json_valid(X) function return 1 if the argument X is well-formed JSON and return 0 if the argument X is not well-formed JSON.</source>
          <target state="translated">json_valid(X)函数如果参数X是格式良好的JSON,则返回1,如果参数X不是格式良好的JSON,则返回0。</target>
        </trans-unit>
        <trans-unit id="b554cbe69a3700d4f56fb5609be0488decea2e7b" translate="yes" xml:space="preserve">
          <source>The key element of a</source>
          <target state="translated">的关键因素。</target>
        </trans-unit>
        <trans-unit id="1f79347fd256f18500712ca620e7ffb89d509d9e" translate="yes" xml:space="preserve">
          <source>The key point is that SQLite is very forgiving of the type of data that you put into the database. For example, if a column has a datatype of &quot;INTEGER&quot; and the application inserts a text string into that column, SQLite will first try to convert the text string into an integer, just like every other SQL database engine. Thus, if one inserts &lt;b&gt;'1234'&lt;/b&gt; into an INTEGER column, that value is converted into an integer 1234 and stored. But, if you insert a non-numeric string like &lt;b&gt;'wxyz'&lt;/b&gt; into an INTEGER column, unlike other SQL databases, SQLite does not throw an error. Instead, SQLite stores the actual string value in the column.</source>
          <target state="translated">关键是，SQLite非常宽容您放入数据库中的数据类型。例如，如果某列的数据类型为&amp;ldquo; INTEGER&amp;rdquo;，并且应用程序在该列中插入了文本字符串，则与其他所有SQL数据库引擎一样，SQLite将首先尝试将文本字符串转换为整数。因此，如果将&lt;b&gt;&amp;ldquo; 1234&amp;rdquo;&lt;/b&gt;插入到INTEGER列中，则该值将转换为整数1234并存储。但是，与其他SQL数据库不同，如果将像&lt;b&gt;'wxyz'&lt;/b&gt;这样的非数字字符串插入INTEGER列，则SQLite不会引发错误。相反，SQLite将实际的字符串值存储在该列中。</target>
        </trans-unit>
        <trans-unit id="3e290f56c0ef256cb5bbb18b2ba0fb09ea68db61" translate="yes" xml:space="preserve">
          <source>The key point is this: Building the CLI consists of compiling together two C-language files. The &lt;b&gt;shell.c&lt;/b&gt; file contains the definition of the entry point and the user input loop and the SQLite amalgamation &lt;b&gt;sqlite3.c&lt;/b&gt; contains the complete implementation of the SQLite library.</source>
          <target state="translated">关键是：构建CLI包括将两个C语言文件编译在一起。该&lt;b&gt;shell.c&lt;/b&gt;文件包含入口点的定义和用户输入回路和SQLite的融合&lt;b&gt;sqlite3.c&lt;/b&gt;包含了SQLite库的完整实现。</target>
        </trans-unit>
        <trans-unit id="bb2fbeab5253f75ff8183f69852d5cbb7ab2bba6" translate="yes" xml:space="preserve">
          <source>The key points of the previous example were the use of the Callback instruction to invoke the callback function, and the use of the Next instruction to implement a loop over all records of the database file. This example attempts to drive home those ideas by demonstrating a slightly more complex query that involves more columns of output, some of which are computed values, and a WHERE clause that limits which records actually make it to the callback function. Consider this query:</source>
          <target state="translated">上一个例子的关键点是使用Callback指令来调用回调函数,以及使用Next指令来实现对数据库文件所有记录的循环。这个例子试图通过演示一个略微复杂的查询来阐述这些观点,这个查询涉及更多的输出列,其中一些是计算值,还有一个WHERE子句来限制哪些记录实际进入回调函数。考虑一下这个查询。</target>
        </trans-unit>
        <trans-unit id="986f899677204f1290b417dd64fe3fcaa05f7c30" translate="yes" xml:space="preserve">
          <source>The keys used by each segment b-tree are terms (words). As well as the key, each segment b-tree entry has an associated &quot;doclist&quot; (document list). A doclist consists of zero or more entries, where each entry consists of:</source>
          <target state="translated">每个段b树使用的键是术语(词)。除了键,每个段b树条目还有一个相关的 &quot;doclist&quot;(文档列表)。doclist由0个或多个条目组成,其中每个条目包括:</target>
        </trans-unit>
        <trans-unit id="a93934848f28a5d1e280c92cac942b828e6dc7e9" translate="yes" xml:space="preserve">
          <source>The keyword &quot;INSERT&quot;, &quot;UPDATE&quot;, or &quot;DELETE&quot;, as appropriate</source>
          <target state="translated">关键字 &quot;INSERT&quot;、&quot;UPDATE &quot;或 &quot;DELETE&quot;,视情况而定。</target>
        </trans-unit>
        <trans-unit id="799f75f9fa5e2cb1d9335f9637de442233918b1a" translate="yes" xml:space="preserve">
          <source>The kvtest program is compiled and run on Android as follows. First install the Android SDK and NDK. Then prepare a script named &quot;android-gcc&quot; that looks approximately like this:</source>
          <target state="translated">kvtest程序在Android上编译运行的方法如下。首先安装Android SDK和NDK。然后准备一个名为 &quot;android-gcc &quot;的脚本,大致如下。</target>
        </trans-unit>
        <trans-unit id="a518e69633f247201841ea47eb51e547b9e7d52f" translate="yes" xml:space="preserve">
          <source>The label to the right of an AS in the column list of a SELECT can now be used as part of an expression in the WHERE, ORDER BY, GROUP BY, and/or HAVING clauses.</source>
          <target state="translated">现在,SELECT列列表中AS右边的标签可以作为WHERE、ORDER BY、GROUP BY和/或HAVING子句中表达式的一部分。</target>
        </trans-unit>
        <trans-unit id="5d78c31e6fd49e38e9a6929f67e573c2fcc27d5f" translate="yes" xml:space="preserve">
          <source>The language id for this entry.</source>
          <target state="translated">本条目的语言标识。</target>
        </trans-unit>
        <trans-unit id="e80fa2a23c99c4e0919bc332ef910ec1f3215c2c" translate="yes" xml:space="preserve">
          <source>The languageid option causes the FTS4 table to have an additional hidden integer column that identifies the language of the text contained in each row. The use of the languageid option allows the same FTS4 table to hold text in multiple languages or scripts, each with different tokenizer rules, and to query each language independently of the others.</source>
          <target state="translated">languageid 选项使 FTS4 表有一个额外的隐藏整数列,用于标识每行所含文本的语言。使用languageid选项可以让同一个FTS4表容纳多种语言或脚本的文本,每种语言或脚本都有不同的标记规则,并且可以独立查询每种语言。</target>
        </trans-unit>
        <trans-unit id="333c7dbdc428cf52a63d6a76d33660a2004630b2" translate="yes" xml:space="preserve">
          <source>The largest payload found anywhere in the current page or btree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a93c8c9ebe55117d8275a20a3a64f1279cc0414" translate="yes" xml:space="preserve">
          <source>The largest possible setting for SQLITE_MAX_PAGE_COUNT is 2147483646. When used with the maximum page size of 65536, this gives a maximum SQLite database size of about 140 terabytes.</source>
          <target state="translated">SQLITE_MAX_PAGE_COUNT的最大可能设置是2147483646。当与最大页面大小65536一起使用时,这将使SQLite数据库的最大大小约为140TB。</target>
        </trans-unit>
        <trans-unit id="4e80216c90c51ba3170a6cfbdb6ff5453a279861" translate="yes" xml:space="preserve">
          <source>The largest possible setting for SQLITE_MAX_PAGE_COUNT is 4294967294. When used with the maximum page size of 65536, this gives a maximum SQLite database size of about 281 terabytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0fabb1072d1e3ea604e33e251741f22426c0f61" translate="yes" xml:space="preserve">
          <source>The last (fourth) bullet above merits additional comment. When SQLite creates a journal file on Unix, it opens the directory that contains that file and calls fsync() on the directory, in an effort to push the directory information to disk. But suppose some other process is adding or removing unrelated files to the directory that contains the database and journal at the moment of a power failure. The supposedly unrelated actions of this other process might result in the journal file being dropped from the directory and moved into &quot;lost+found&quot;. This is an unlikely scenario, but it could happen. The best defenses are to use a journaling filesystem or to keep the database and journal in a directory by themselves.</source>
          <target state="translated">上面最后一个(第四个)项目值得补充评论。当SQLite在Unix上创建一个日志文件时,它会打开包含该文件的目录,并对该目录调用fsync(),努力将目录信息推送到磁盘上。但假设在断电的时刻,有其他进程在向包含数据库和日志的目录中添加或删除不相关的文件。这个其他进程的所谓不相关的行为可能会导致日志文件从目录中被删除,并移到 &quot;丢失+发现 &quot;中。这种情况不太可能,但有可能发生。最好的防御措施是使用日志文件系统,或者将数据库和日志单独放在一个目录中。</target>
        </trans-unit>
        <trans-unit id="0d792644cd574497ddbf62ba435f6dbc99253564" translate="yes" xml:space="preserve">
          <source>The last bullet above is illustrated by the following:</source>
          <target state="translated">上述最后一个项目的说明如下:</target>
        </trans-unit>
        <trans-unit id="6fcee6d642fa1ca93fa14337ac4410163d2a9df9" translate="yes" xml:space="preserve">
          <source>The last output mode is &quot;html&quot;. In this mode, sqlite3 writes the results of the query as an XHTML table. The beginning &amp;lt;TABLE&amp;gt; and the ending &amp;lt;/TABLE&amp;gt; are not written, but all of the intervening &amp;lt;TR&amp;gt;s, &amp;lt;TH&amp;gt;s, and &amp;lt;TD&amp;gt;s are. The html output mode is envisioned as being useful for CGI.</source>
          <target state="translated">最后的输出模式是&amp;ldquo; html&amp;rdquo;。在这种模式下，sqlite3将查询结果写入XHTML表。开头的&amp;lt;TABLE&amp;gt;和结尾的&amp;lt;/ TABLE&amp;gt;均未写入，但所有中间的&amp;lt;TR&amp;gt;，&amp;lt;TH&amp;gt;和&amp;lt;TD&amp;gt;均已写入。可以设想html输出模式对于CGI很有用。</target>
        </trans-unit>
        <trans-unit id="a123c1f8dadbf6bb9cc227ef0871a1fb2cbe0f9d" translate="yes" xml:space="preserve">
          <source>The last parameter to the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; routines is a pointer to a procedure used to dispose of the P pointer once SQLite has finished with it. This pointer can be NULL, in which case no destructor is called.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;和&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;例程的最后一个参数是指向SQLite完成处理P指针的过程的指针。该指针可以为NULL，在这种情况下，不会调用任何析构函数。</target>
        </trans-unit>
        <trans-unit id="d52a179000f827088051359c744fec0210401d8f" translate="yes" xml:space="preserve">
          <source>The last step in the commit process is to release the exclusive lock so that other processes can once again start accessing the database file.</source>
          <target state="translated">提交过程的最后一步是释放独占锁,以便其他进程可以再次开始访问数据库文件。</target>
        </trans-unit>
        <trans-unit id="56b9bbac0263da28aef9dee3010ecc1e8725f669" translate="yes" xml:space="preserve">
          <source>The last transaction started will be the first transaction committed or rolled back.</source>
          <target state="translated">最后启动的交易将是第一个提交或回滚的交易。</target>
        </trans-unit>
        <trans-unit id="c2015d5e4ba733546bdea54c6daefbab27ed0b3f" translate="yes" xml:space="preserve">
          <source>The last two allocations can be controlled and/or eliminated by configuring the &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;, and &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; appropriately, as described above. The storage space required for &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects depends to some extent on the length of the filename of the database file, but rarely exceeds 2KB on 32-bit systems. (More space is required on 64-bit systems due to the increased size of pointers.) Each parser object uses about 1.6KB of memory. Thus, elements 3 through 7 above can easily be controlled to keep the maximum memory allocation size below 2KB.</source>
          <target state="translated">如上所述，可以通过适当地配置页面&lt;a href=&quot;malloc#pagecache&quot;&gt;缓存内存分配器&lt;/a&gt;和&lt;a href=&quot;malloc#lookaside&quot;&gt;后备内存分配器&lt;/a&gt;来控制和/或消除最后两个分配。&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;对象所需的存储空间在某种程度上取决于数据库文件名的长度，但在32位系统上很少超过2KB。 （由于指针的增加，在64位系统上需要更多空间。）每个解析器对象使用大约1.6KB的内存。因此，可以容易地控制上述元件3至7以将最大存储器分配大小保持在2KB以下。</target>
        </trans-unit>
        <trans-unit id="dd770eea393f2ccabe1cb964e8f446d8577e90ba" translate="yes" xml:space="preserve">
          <source>The last two queries take the same amount of time, in our example. So which index, Idx1 or Idx2, will SQLite choose? If the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command has been run on the database, so that SQLite has had an opportunity to gather statistics about the available indices, then SQLite will know that the Idx1 index usually narrows the search down to a single item (our example of fruit='Orange' is the exception to this rule) whereas the Idx2 index will normally only narrow the search down to two rows. So, if all else is equal, SQLite will choose Idx1 with the hope of narrowing the search to as small a number of rows as possible. This choice is only possible because of the statistics provided by &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;. If &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has not been run then the choice of which index to use is arbitrary.</source>
          <target state="translated">在我们的示例中，最后两个查询花费相同的时间。那么，SQLite将选择哪个索引Idx1或Idx2？如果在数据库上运行了&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令，则SQLite有机会收集了有关可用索引的统计信息，那么SQLite将知道Idx1索引通常将搜索范围缩小到单个项目（我们的fruit ='示例）。橙色&amp;rdquo;是该规则的例外），而Idx2索引通常只会将搜索范围缩小到两行。因此，如果其他所有条件都相等，SQLite将选择Idx1，希望将搜索范围缩小到尽可能少的行。由于&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;提供的统计信息，因此只能进行此选择。如果&lt;a href=&quot;lang_analyze&quot;&gt;分析&lt;/a&gt; 尚未运行，则选择使用哪个索引是任意的。</target>
        </trans-unit>
        <trans-unit id="0271db818028a9ffb097a09e837d0647ab050705" translate="yes" xml:space="preserve">
          <source>The last_insert_rowid() function returns the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; of the last row insert from the database connection which invoked the function. The last_insert_rowid() SQL function is a wrapper around the &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; C/C++ interface function.</source>
          <target state="translated">last_insert_rowid（）函数从调用该函数的数据库连接返回最后一行插入的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;。last_insert_rowid（）SQL函数是&lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt; C / C ++接口函数的包装。</target>
        </trans-unit>
        <trans-unit id="dc54cc3b765595ad1e2bcb9ada53a0d0dfaa1af8" translate="yes" xml:space="preserve">
          <source>The latest checklists contain approximately 200 items that are individually verified for each release. Some checklist items only take a few seconds to verify and mark off. Others involve test suites that run for many hours.</source>
          <target state="translated">最新的核对表包含大约200个项目,这些项目是针对每个版本进行单独验证的。有些检查清单项目只需要几秒钟的时间来验证和标记。其他项目则涉及运行数小时的测试套件。</target>
        </trans-unit>
        <trans-unit id="972ae3a81fba75ac7b1cb927798468eb94557f5e" translate="yes" xml:space="preserve">
          <source>The latter query can not use the partial index because there might be rows in the table with b=456 and where c is NULL. But those rows would not be in the partial index.</source>
          <target state="translated">后一个查询不能使用部分索引,因为在表中可能有b=456的记录,并且c是NULL。但是这些记录不会出现在部分索引中。</target>
        </trans-unit>
        <trans-unit id="5d0da56ef4fd6dfbe12fe3015e9d0a6d277654f6" translate="yes" xml:space="preserve">
          <source>The leftmost column of the &quot;%_content&quot; table is an INTEGER PRIMARY KEY field named &quot;docid&quot;. Following this is one column for each column of the FTS virtual table as declared by the user, named by prepending the column name supplied by the user with &quot;c</source>
          <target state="translated">&quot;%_content &quot;表的最左边一列是一个名为 &quot;docid &quot;的INTEGER主键字段。在这之后是用户声明的FTS虚拟表的每一列,命名时在用户提供的列名前加上 &quot;c</target>
        </trans-unit>
        <trans-unit id="3fe10f10852f3ac1156d75127fc7c938a298af76" translate="yes" xml:space="preserve">
          <source>The legacy &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; compile-time option is now a no-op.</source>
          <target state="translated">现在，旧版&lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3的&lt;/a&gt;编译时选项为空操作。</target>
        </trans-unit>
        <trans-unit id="19d5e9050bddb7e40ed3e17c750502a0acf23cf7" translate="yes" xml:space="preserve">
          <source>The legacy alter table behavior can also be toggled on and off using the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyaltertable&quot;&gt;SQLITE_DBCONFIG_LEGACY_ALTER_TABLE&lt;/a&gt; option to the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface.</source>
          <target state="translated">也可以使用&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;接口的&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyaltertable&quot;&gt;SQLITE_DBCONFIG_LEGACY_ALTER_TABLE&lt;/a&gt;选项来打开和关闭旧式alter table行为。</target>
        </trans-unit>
        <trans-unit id="41fd664aa5a45cba5ac773955a3426725e8decb9" translate="yes" xml:space="preserve">
          <source>The legacy alter table behavior is a per-connection setting. Turning this features on or off affects all attached database files within the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. The setting does not persist. Changing this setting in one connection does not affect any other connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0281c5597d6458d92c064f8c4ce4817fe25c10e" translate="yes" xml:space="preserve">
          <source>The legacy xGeom callback is invoked with four arguments. The first argument is a pointer to an sqlite3_rtree_geometry structure which provides information about how the SQL function was invoked. The second argument is the number of coordinates in each r-tree entry, and is always the same for any given R*Tree. The number of coordinates is 2 for a 1-dimensional R*Tree, 4 for a 2-dimensional R*Tree, 6 for a 3-dimensional R*Tree, and so forth. The third argument, aCoord[], is an array of nCoord coordinates that defines a bounding box to be tested. The last argument is a pointer into which the callback result should be written. The result is zero if the bounding-box defined by aCoord[] is completely outside the region defined by the xGeom callback and the result is non-zero if the bounding-box is inside or overlaps with the xGeom region. The xGeom callback should normally return SQLITE_OK. If xGeom returns anything other than SQLITE_OK, then the r-tree query will abort with an error.</source>
          <target state="translated">传统的xGeom回调有四个参数。第一个参数是指向 sqlite3_rtree_geometry 结构的指针,它提供了关于 SQL 函数如何被调用的信息。第二个参数是每个r-tree条目中的坐标数,对于任何给定的R*Tree来说,坐标数总是相同的。一维R*Tree的坐标数为2,二维R*Tree为4,三维R*Tree为6,以此类推。第三个参数aCoord[]是一个nCoord坐标数组,定义了一个要测试的边界框。最后一个参数是一个指针,回调结果应该写入其中。如果aCoord[]定义的边界框完全在xGeom回调定义的区域之外,则结果为零;如果边界框在xGeom区域内或与xGeom区域重合,则结果为非零。xGeom回调通常应该返回SQLITE_OK。如果xGeom返回的不是SQLITE_OK,那么r-tree查询将以错误的方式中止。</target>
        </trans-unit>
        <trans-unit id="c26ac59b1bddfababdeff98e88ee3a4d181edb8a" translate="yes" xml:space="preserve">
          <source>The legacy_file_format pragma is initialized to OFF when an existing database in the newer file format is first opened.</source>
          <target state="translated">当第一次打开一个较新文件格式的现有数据库时,legacy_file_format pragma被初始化为OFF。</target>
        </trans-unit>
        <trans-unit id="5c416af28ee6cf9f448dc251869a118022ef5870" translate="yes" xml:space="preserve">
          <source>The length of a function name may not exceed 255 characters. Any attempt to create a function whose name exceeds 255 characters in length will result in an error.</source>
          <target state="translated">一个函数名称的长度不能超过255个字符。任何试图创建一个名称长度超过255个字符的函数都会导致错误。</target>
        </trans-unit>
        <trans-unit id="64a58fb27f585f3af736420c55a5c7aba354a480" translate="yes" xml:space="preserve">
          <source>The length of the argument value can be specified by one or more letters that occur just prior to the substitution type letter. In SQLite, the length only matter for integer types. The length is ignored for the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; which always uses 64-bit values. The following table shows the length specifiers allowed by SQLite:</source>
          <target state="translated">参数值的长度可以由替换类型字母之前的一个或多个字母指定。在SQLite中，长度仅与整数类型有关。对于始终使用64位值的&lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf（）SQL函数&lt;/a&gt;，将忽略该长度。下表显示了SQLite允许的长度说明符：</target>
        </trans-unit>
        <trans-unit id="835ff0a5a3c1f19c6461eba222151b4907f96047" translate="yes" xml:space="preserve">
          <source>The letter &quot;j&quot; pronounced like &quot;h&quot; in Spanish: LaJolla</source>
          <target state="translated">字母 &quot;j &quot;在西班牙语中发音像 &quot;h&quot;。LaJolla</target>
        </trans-unit>
        <trans-unit id="ee9eb5ebb3823c5e0db14477052af2948a8b37ee" translate="yes" xml:space="preserve">
          <source>The library now assumes data is stored as UTF-8 if the --enable-utf8 option is given to configure. The default behavior is to assume iso8859-x, as it has always done. This only makes a difference for LIKE and GLOB operators and the LENGTH and SUBSTR functions.</source>
          <target state="translated">如果给定了 --enable-utf8 选项来配置,该库现在假定数据以 UTF-8 存储。默认的行为是假设为iso8859-x,因为它一直都是这样做的。这只对 LIKE 和 GLOB 操作符以及 LENGTH 和 SUBSTR 函数有所区别。</target>
        </trans-unit>
        <trans-unit id="2b11a2ab2af2c4ff66c5a4f077ed6909c7421f85" translate="yes" xml:space="preserve">
          <source>The life-cycle of a prepared statement object usually goes like this:</source>
          <target state="translated">一个准备好的报表对象的生命周期通常是这样的。</target>
        </trans-unit>
        <trans-unit id="610e163977a4d438d498cc7745085654d18422e2" translate="yes" xml:space="preserve">
          <source>The lifecycle of an sqlite3_str object is as follows:</source>
          <target state="translated">sqlite3_str对象的生命周期如下。</target>
        </trans-unit>
        <trans-unit id="e1c985dd036afafc48409f9dec76735bbf115b4e" translate="yes" xml:space="preserve">
          <source>The like() function is used to implement the &quot;&lt;b&gt;Y LIKE X [ESCAPE Z]&lt;/b&gt;&quot; expression. If the optional ESCAPE clause is present, then the like() function is invoked with three arguments. Otherwise, it is invoked with two arguments only. Note that the X and Y parameters are reversed in the like() function relative to the infix &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator. X is the pattern and Y is the string to match against that pattern. Hence, the following expressions are equivalent:</source>
          <target state="translated">like（）函数用于实现&amp;ldquo; &lt;b&gt;Y LIKE X [ESCAPE Z]&lt;/b&gt; &amp;rdquo;表达式。如果存在可选的ESCAPE子句，则使用三个参数调用like（）函数。否则，仅使用两个参数调用它。请注意，like（）函数中的X和Y参数相对于infix &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;运算符是相反的。 X是模式，Y是要与该模式匹配的字符串。因此，以下表达式是等效的：</target>
        </trans-unit>
        <trans-unit id="1725d5bdba0b7e8833554a2371c0c343ab2395e2" translate="yes" xml:space="preserve">
          <source>The likelihood(X,Y) function returns argument X unchanged. The value Y in likelihood(X,Y) must be a floating point constant between 0.0 and 1.0, inclusive. The likelihood(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles during run-time (that is, during calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;). The purpose of the likelihood(X,Y) function is to provide a hint to the query planner that the argument X is a boolean that is true with a probability of approximately Y. The &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely(X)&lt;/a&gt; function is short-hand for likelihood(X,0.0625). The &lt;a href=&quot;lang_corefunc#likely&quot;&gt;likely(X)&lt;/a&gt; function is short-hand for likelihood(X,0.9375).</source>
          <target state="translated">似然性（X，Y）函数不变地返回参数X。似然性（X，Y）中的值Y必须是介于0.0和1.0之间（包括两者）的浮点常量。似然性（X）函数是一种无操作，代码生成器会对其进行优化，以使其在运行时（即在调用&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;期间）不占用任何CPU周期。似然的（X，Y）的目的的功能是提供一个提示来查询规划该参数X是一个布尔值，是真正用约Y的概率&lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;不可能的（X）&lt;/a&gt;函数是短手的可能性（ X，0.0625）。的&lt;a href=&quot;lang_corefunc#likely&quot;&gt;可能的（X）&lt;/a&gt;函数是短手的可能性（X，0.9375）。</target>
        </trans-unit>
        <trans-unit id="047f4505a74dbe546931a88238b570dcea0e5906" translate="yes" xml:space="preserve">
          <source>The likely(X) function returns the argument X unchanged. The likely(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles at run-time (that is, during calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;). The purpose of the likely(X) function is to provide a hint to the query planner that the argument X is a boolean value that is usually true. The likely(X) function is equivalent to &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood&lt;/a&gt;(X,0.9375). See also: &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely(X)&lt;/a&gt;.</source>
          <target state="translated">可能的（X）函数返回参数X不变。可能（X）函数是一个无操作函数，代码生成器会对其进行优化，以使其在运行时（即在调用&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;期间）不占用任何CPU周期。 Possible（X）函数的目的是向查询计划者提供一个提示，即参数X是通常为true的布尔值。可能性（X）函数等效于&lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;可能性&lt;/a&gt;（X，0.9375）。另请参阅：&lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;不太可能（X）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="604c341d9009d83169d386485e03d9e7bc04c662" translate="yes" xml:space="preserve">
          <source>The limit value is set to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7008986405b40055720891f4830c40ce21496380" translate="yes" xml:space="preserve">
          <source>The line &quot;.once</source>
          <target state="translated">这一行&quot;.一旦</target>
        </trans-unit>
        <trans-unit id="d0c3acc92dc701e819ac94a0c8098f2db90a205c" translate="yes" xml:space="preserve">
          <source>The list below is not exhaustive. Other virtual table implementation exist in the SQLite source tree and elsewhere. The list below tries to capture the more interesting virtual table implementations.</source>
          <target state="translated">下面的列表并不详尽。在SQLite源码树和其他地方还存在其他的虚拟表实现。下面的列表试图捕捉更有趣的虚拟表实现。</target>
        </trans-unit>
        <trans-unit id="d3b78caa21f35e034eafcfa346ed07394d0ca6e0" translate="yes" xml:space="preserve">
          <source>The list below shows all possible keywords used by any build of SQLite regardless of &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt;. Most reasonable configurations use most or all of these keywords, but some keywords may be omitted when SQL language features are disabled. Applications can use the &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count()&lt;/a&gt;, &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name()&lt;/a&gt;, and &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check()&lt;/a&gt; interfaces to determine the keywords recognized by SQLite at run-time. Regardless of the compile-time configuration, any identifier that is not on the following 143 element list is not a keyword to the SQL parser in SQLite:</source>
          <target state="translated">下面的列表显示了任何SQLite版本都使用的所有可能的关键字，而不管&lt;a href=&quot;compile&quot;&gt;编译时选项如何&lt;/a&gt;。最合理的配置使用大多数或所有这些关键字，但是当禁用SQL语言功能时，某些关键字可能会省略。应用程序可以使用&lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count（）&lt;/a&gt;，&lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name（）&lt;/a&gt;和&lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check（）&lt;/a&gt;接口来确定SQLite在运行时识别的关键字。不管编译时配置如何，不在以下143元素列表中的任何标识符都不是SQLite中SQL解析器的关键字：</target>
        </trans-unit>
        <trans-unit id="0180a1bb67bb5f33291414ccd4cfdc93226599e9" translate="yes" xml:space="preserve">
          <source>The list below shows all possible keywords used by any build of SQLite regardless of &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt;. Most reasonable configurations use most or all of these keywords, but some keywords may be omitted when SQL language features are disabled. Applications can use the &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count()&lt;/a&gt;, &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name()&lt;/a&gt;, and &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check()&lt;/a&gt; interfaces to determine the keywords recognized by SQLite at run-time. Regardless of the compile-time configuration, any identifier that is not on the following 145 element list is not a keyword to the SQL parser in SQLite:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="281c02e8bf5d35129f9e1be609bd2e9295d15355" translate="yes" xml:space="preserve">
          <source>The list of coordinates in the binary format contains no redundancy. The last coordinate is not a repeat of the first as it is with GeoJSON. Hence, there is always one fewer coordinate pair in the binary representation of a polygon compared to the GeoJSON representation.</source>
          <target state="translated">二进制格式的坐标列表不包含多余的内容。最后一个坐标不会像GeoJSON那样重复第一个坐标。因此,与GeoJSON表示法相比,多边形的二进制表示法总是少一个坐标对。</target>
        </trans-unit>
        <trans-unit id="31509dccb06d1116de02483b9bec949662404996" translate="yes" xml:space="preserve">
          <source>The list of expressions between the SELECT and FROM keywords is known as the result expression list. If a result expression is the special expression &quot;*&quot; then all columns in the input data are substituted for that one expression. If the expression is the alias of a table or subquery in the FROM clause followed by &quot;.*&quot; then all columns from the named table or subquery are substituted for the single expression. It is an error to use a &quot;*&quot; or &quot;alias.*&quot; expression in any context other than a result expression list. It is also an error to use a &quot;*&quot; or &quot;alias.*&quot; expression in a simple SELECT query that does not have a FROM clause.</source>
          <target state="translated">SELECT和FROM关键字之间的表达式列表称为结果表达式列表。如果结果表达式是特殊表达式 &quot;*&quot;,那么输入数据中的所有列都会被这一个表达式所替代。如果表达式是FROM子句中表或子查询的别名,后面加&quot;.*&quot;,那么被命名的表或子查询中的所有列都会被这一个表达式所替代。在结果表达式列表以外的任何上下文中使用 &quot;*&quot;或 &quot;alias.*&quot;表达式都是错误的。在没有FROM子句的简单SELECT查询中使用 &quot;*&quot;或 &quot;alias.*&quot;表达式也是错误的。</target>
        </trans-unit>
        <trans-unit id="aff07670c95df2683c32cdb3b9c35bd30fecbe25" translate="yes" xml:space="preserve">
          <source>The list of integers in the stat column can optionally be followed by arguments, each of which is a sequence of non-space characters. All arguments are preceded by a single space. Unrecognized arguments are silently ignored.</source>
          <target state="translated">统计列中的整数列表可以选择跟在参数后面,每个参数都是一个非空格字符的序列。所有参数前面都有一个空格。未识别的参数将被忽略。</target>
        </trans-unit>
        <trans-unit id="5c584c3300424511e57cf7c45771316447fd9008" translate="yes" xml:space="preserve">
          <source>The load_extension() function will fail if the extension attempts to modify or delete an SQL function or collating sequence. The extension can add new functions or collating sequences, but cannot modify or delete existing functions or collating sequences because those functions and/or collating sequences might be used elsewhere in the currently running SQL statement. To load an extension that changes or deletes functions or collating sequences, use the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; C-language API.</source>
          <target state="translated">如果扩展尝试修改或删除SQL函数或整理序列，则load_extension（）函数将失败。该扩展可以添加新功能或整理序列，但不能修改或删除现有功能或整理序列，因为这些功能和/或整理序列可能在当前运行的SQL语句中的其他位置使用。要加载更改或删除函数或整理序列的扩展，请使用&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt; C语言API。</target>
        </trans-unit>
        <trans-unit id="349abdc2376164ceeb049d0fdce3e4218d275600" translate="yes" xml:space="preserve">
          <source>The load_extension(X,Y) function loads &lt;a href=&quot;loadext&quot;&gt;SQLite extensions&lt;/a&gt; out of the shared library file named X using the entry point Y. The result of load_extension() is always a NULL. If Y is omitted then the default entry point name is used. The load_extension() function raises an exception if the extension fails to load or initialize correctly.</source>
          <target state="translated">load_extension（X，Y）函数使用入口点Y从名为X的共享库文件中加载&lt;a href=&quot;loadext&quot;&gt;SQLite扩展&lt;/a&gt;。load_extension（）的结果始终为NULL。如果省略Y，则使用默认入口点名称。如果扩展无法正确加载或初始化，load_extension（）函数将引发异常。</target>
        </trans-unit>
        <trans-unit id="3c476d76e8d35e3c5addfedd0889c28cfa2868c0" translate="yes" xml:space="preserve">
          <source>The local copy of the remote head</source>
          <target state="translated">远程云台的本地副本</target>
        </trans-unit>
        <trans-unit id="9c687c8acb9d37e788292221df58e5cc9d9b9e4e" translate="yes" xml:space="preserve">
          <source>The local head</source>
          <target state="translated">当地负责人</target>
        </trans-unit>
        <trans-unit id="ef999d9e04e59df040c534586df9501decb45621" translate="yes" xml:space="preserve">
          <source>The lock-byte page</source>
          <target state="translated">锁定字节页</target>
        </trans-unit>
        <trans-unit id="5c06094b5494afcc6bc0546930a2d751ec1db7b7" translate="yes" xml:space="preserve">
          <source>The lock-byte page arose from the need to support Win95 which was the predominant operating system when this file format was designed and which only supported mandatory file locking. All modern operating systems that we know of support advisory file locking, and so the lock-byte page is not really needed any more, but is retained for backwards compatibility.</source>
          <target state="translated">锁定字节页的产生是由于需要支持Win95,而Win95在设计这种文件格式时是最主要的操作系统,它只支持强制文件锁定。我们所知道的所有现代操作系统都支持咨询文件锁定,因此不再需要锁定字节页,而是为了向后兼容而保留。</target>
        </trans-unit>
        <trans-unit id="4bd512e93ea74564dff8bf82d8627bae1ed3c48e" translate="yes" xml:space="preserve">
          <source>The lock-byte page is set aside for use by the operating-system specific &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementation in implementing the database file locking primitives. SQLite does not use the lock-byte page. The SQLite core will never read or write the lock-byte page, though operating-system specific &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations may choose to read or write bytes on the lock-byte page according to the needs and proclivities of the underlying system. The unix and win32 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations that come built into SQLite do not write to the lock-byte page, but third-party VFS implementations for other operating systems might.</source>
          <target state="translated">保留了锁定字节页面，以供操作系统特定的&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;实现在实现数据库文件锁定原语时使用。 SQLite不使用锁定字节页面。尽管特定于操作系统的&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;实现可能会根据底层系统的需要和倾向选择在锁定字节页上读取或写入字节，但SQLite核心永远不会读取或写入锁定字节页。SQLite内置的unix和win32 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;实现不会写入锁定字节页，但是其他操作系统的第三方VFS实现可能会写入。</target>
        </trans-unit>
        <trans-unit id="df185932a5473981e68a610e19ea95a4f593a072" translate="yes" xml:space="preserve">
          <source>The lock-byte page is the single page of the database file that contains the bytes at offsets between 1073741824 and 1073742335, inclusive. A database file that is less than or equal to 1073741824 bytes in size contains no lock-byte page. A database file larger than 1073741824 contains exactly one lock-byte page.</source>
          <target state="translated">锁字节页是指数据库文件中包含1073741824和1073742335(含)之间偏移量的字节的单页。小于或等于1073741824字节大小的数据库文件不包含锁字节页。大于1073741824字节的数据库文件正好包含一个锁字节页。</target>
        </trans-unit>
        <trans-unit id="dda6a9ed2d568f9a7c6dc08407b442fb82119304" translate="yes" xml:space="preserve">
          <source>The logic is summarized like this:</source>
          <target state="translated">逻辑是这样总结的。</target>
        </trans-unit>
        <trans-unit id="355578bfd3a4498b2a633a6f3c4ff7c7b09de69f" translate="yes" xml:space="preserve">
          <source>The logical database size is now stored in the database header so that bytes can be appended to the end of the database file without corrupting it and so that SQLite will work correctly on systems that lack support for ftruncate().</source>
          <target state="translated">现在,逻辑数据库的大小存储在数据库头中,这样就可以在不破坏数据库文件的情况下将字节追加到文件末尾,这样SQLite就可以在缺乏ftruncate()支持的系统上正确工作。</target>
        </trans-unit>
        <trans-unit id="e93186cc2b2b96f693bcff5f9715523649b95afa" translate="yes" xml:space="preserve">
          <source>The lookaside configuration can only be changed while there are no outstanding lookaside allocations for the database connection. Hence, the configuration should be set immediately after creating the database connection using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; (or equivalent) and before evaluating any SQL statements on the connection.</source>
          <target state="translated">仅当数据库连接没有未完成的后备分配时，才能更改后备配置。因此，应在使用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;（或等效方法）创建数据库连接之后并在评估连接上的任何SQL语句之前立即设置配置。</target>
        </trans-unit>
        <trans-unit id="98de1d7e1c308aef9eeb240a9c0c48340d7aa4c3" translate="yes" xml:space="preserve">
          <source>The lookaside memory allocator is really intended as performance optimization, not as a method for assuring breakdown-free memory allocation, so it is not unreasonable to completely disable the lookaside memory allocator for safety-critical operations.</source>
          <target state="translated">lookaside内存分配器的真正目的是为了优化性能,而不是保证无故障内存分配的方法,所以对于安全关键的操作,完全禁用lookaside内存分配器并非不合理。</target>
        </trans-unit>
        <trans-unit id="02f0ada4fc69e2b3f3d2c6c843b91333faf8b563" translate="yes" xml:space="preserve">
          <source>The lookaside pool can be changed for an individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; &quot;db&quot; using this call:</source>
          <target state="translated">可以使用以下调用为单个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt; &amp;ldquo; db&amp;rdquo; 更改后备池：</target>
        </trans-unit>
        <trans-unit id="31d19ac91c3d68e4ec2f5534877ee0ca68a0efec" translate="yes" xml:space="preserve">
          <source>The loop begins with the &lt;a href=&quot;opcode#MemLoad&quot;&gt;MemLoad&lt;/a&gt; instruction at 11 which pushes a copy of the index key back onto the stack. The instruction &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; at 12 compares the key to the key in the current index record pointed to by cursor P1. If the index key at the current cursor location is greater than the index we are looking for, then jump out of the loop.</source>
          <target state="translated">循环从11处的&lt;a href=&quot;opcode#MemLoad&quot;&gt;MemLoad&lt;/a&gt;指令开始，该指令将索引键的副本推回堆栈中。位于12 的指令&lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt;将键与光标P1指向的当前索引记录中的键进行比较。如果当前光标位置的索引键大于我们要查找的索引，则跳出循环。</target>
        </trans-unit>
        <trans-unit id="9b4e40524d32f647817434932fe77ea61e285d86" translate="yes" xml:space="preserve">
          <source>The lower(X) function returns a copy of string X with all ASCII characters converted to lower case. The default built-in lower() function works for ASCII characters only. To do case conversions on non-ASCII characters, load the ICU extension.</source>
          <target state="translated">lower(X)函数返回字符串 X 的副本,并将所有 ASCII 字符转换为小写。默认内置的 lower()函数只对 ASCII 字符起作用,如果要对非 ASCII 字符进行大小写转换,请加载 ICU 扩展。要对非 ASCII 字符进行大小写转换,请加载 ICU 扩展。</target>
        </trans-unit>
        <trans-unit id="84e26bc0d335ef0f3f91dcbee9450cd939575e9d" translate="yes" xml:space="preserve">
          <source>The ltrim(X,Y) function returns a string formed by removing any and all characters that appear in Y from the left side of X. If the Y argument is omitted, ltrim(X) removes spaces from the left side of X.</source>
          <target state="translated">ltrim(X,Y)函数返回一个从X的左侧删除Y中出现的所有字符形成的字符串,如果省略Y参数,ltrim(X)将删除X左侧的空格。</target>
        </trans-unit>
        <trans-unit id="fdcc55ab3a12db83d0fd351a3149fb5d3844b7fd" translate="yes" xml:space="preserve">
          <source>The macros in this section do not require values. The following compilation switches all have the same effect:</source>
          <target state="translated">本节中的宏不需要值。下面的编译开关都有同样的效果。</target>
        </trans-unit>
        <trans-unit id="9225c9e6b4935393e2d3171b186997ddaa13f218" translate="yes" xml:space="preserve">
          <source>The main database file consists of one or more pages. The size of a page is a power of two between 512 and 65536 inclusive. All pages within the same database are the same size. The page size for a database file is determined by the 2-byte integer located at an offset of 16 bytes from the beginning of the database file.</source>
          <target state="translated">主数据库文件由一个或多个页面组成。一个页面的大小是512到65536(含)之间的二倍。同一数据库中的所有页面大小相同。数据库文件的页面大小由位于数据库文件开头16字节偏移处的2字节整数决定。</target>
        </trans-unit>
        <trans-unit id="7d6f37716756d458f806be1f0cab62c9c7d22175" translate="yes" xml:space="preserve">
          <source>The main database file with an arbitrary name &quot;X&quot;.</source>
          <target state="translated">主数据库文件的名称为任意 &quot;X&quot;。</target>
        </trans-unit>
        <trans-unit id="f6b3e874976f8a865414a00bc3a0b52995dae0f9" translate="yes" xml:space="preserve">
          <source>The main expression bubble diagram above shows a single syntax for all function invocations. But this is merely to simplify the expression bubble diagram. In reality, each type of function has a slightly different syntax, shown below. The function invocation syntax shown in the main expression bubble diagram is the union of the three syntaxes shown here:</source>
          <target state="translated">上面的主表达式气泡图显示了所有函数调用的单一语法。但这只是为了简化表达式气泡图。实际上,每种类型的函数都有稍微不同的语法,如下图所示。主表达式气泡图中所示的函数调用语法是这里所示的三种语法的结合。</target>
        </trans-unit>
        <trans-unit id="408e5f03d044dab233873eb64f906cb6ccb49b90" translate="yes" xml:space="preserve">
          <source>The main machine in Dallas &lt;a href=&quot;https://www.sqlite.org/&quot;&gt;https://www.sqlite.org/&lt;/a&gt; is the primary server and the one that most people use. The other two are considered backups.</source>
          <target state="translated">达拉斯&lt;a href=&quot;https://www.sqlite.org/&quot;&gt;https://www.sqlite.org/&lt;/a&gt;中的主机是主要服务器，也是大多数人使用的服务器。其他两个被视为备份。</target>
        </trans-unit>
        <trans-unit id="1d698f91852ce738e8b0efe94402ad56dc5b35ee" translate="yes" xml:space="preserve">
          <source>The main result from &lt;b&gt;sqlite_get_table&lt;/b&gt; is an array of pointers to strings. There is one element in this array for each column of each row in the result. NULL results are represented by a NULL pointer. In addition to the regular data, there is an added row at the beginning of the array that contains the name of each column of the result.</source>
          <target state="translated">&lt;b&gt;sqlite_get_table&lt;/b&gt;的主要结果是一个指向字符串的指针数组。结果中每一行的每一列在此数组中都有一个元素。NULL结果由NULL指针表示。除常规数据外，数组开头还有一个添加的行，其中包含结果每一列的名称。</target>
        </trans-unit>
        <trans-unit id="2fb1295c928ccfed10f4bea85ec6d057bdb858da" translate="yes" xml:space="preserve">
          <source>The main thing that the SQLite core is trying to communicate to the virtual table is the constraints that are available to limit the number of rows that need to be searched. The aConstraint[] array contains one entry for each constraint. There will be exactly nConstraint entries in that array.</source>
          <target state="translated">SQLite核心要传达给虚拟表的主要内容是可用来限制需要搜索的行数的约束。aConstraint[]数组包含每个约束的一个条目。该数组中正好会有n个Constraint条目。</target>
        </trans-unit>
        <trans-unit id="c00fa1abbc4e41f8e98c7516bdb7add3970ff677" translate="yes" xml:space="preserve">
          <source>The makefiles and scripts used to generate the documentation gather text from baseline documents in the documentation source repository. Additional text is extracted from comments in the SQLite source code. Requirements coverage information is extract from special comments in the &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt; which is part of the source repository, and from comments in the &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; test suite which is a separate private repository.</source>
          <target state="translated">用于生成文档的makefile和脚本从文档源存储库中的基准文档中收集文本。其他文本是从SQLite源代码中的注释中提取的。需求覆盖率信息是从&lt;a href=&quot;testing#tcl&quot;&gt;TCL测试套件（&lt;/a&gt;它是源存储库的一部分）中的特殊注释以及&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;测试套件（一个单独的私有存储库）中的注释中提取的。</target>
        </trans-unit>
        <trans-unit id="42a78601e6da24d033fc5c1c1ee7512e6c89f88c" translate="yes" xml:space="preserve">
          <source>The makefiles for SQLite have an &quot;sqlite3.c&quot; target for building the file we call &quot;the amalgamation&quot;. The amalgamation is a single C code file, named &quot;sqlite3.c&quot;, that contains all C code for the core SQLite library and the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;, &lt;a href=&quot;dbstat&quot;&gt;DBSTAT&lt;/a&gt;, &lt;a href=&quot;json1&quot;&gt;JSON1&lt;/a&gt;, and &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; extensions. This file contains about 184K lines of code (113K if you omit blank lines and comments) and is over 6.4 megabytes in size. Though the various extensions are included in the &quot;sqlite3.c&quot; amalgamation file, they are disabled using #ifdef statements. Activate the extensions using &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; like:</source>
          <target state="translated">SQLite的makefile具有一个&amp;ldquo; sqlite3.c&amp;rdquo;目标，用于构建我们称为&amp;ldquo;合并&amp;rdquo;的文件。合并是一个单独的C代码文件，名为&amp;ldquo; sqlite3.c&amp;rdquo;，其中包含核心SQLite库以及&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;，&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;，&lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;，&lt;a href=&quot;dbstat&quot;&gt;DBSTAT&lt;/a&gt;，&lt;a href=&quot;json1&quot;&gt;JSON1&lt;/a&gt;和&lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt;扩展的所有C代码。该文件包含大约18.4万行代码（如果省略空行和注释，则为113K），大小超过6.4兆字节。尽管&amp;ldquo; sqlite3.c&amp;rdquo;合并文件中包含各种扩展名，但是使用#ifdef语句将其禁用。使用如下&lt;a href=&quot;compile&quot;&gt;编译时选项&lt;/a&gt;激活扩展：</target>
        </trans-unit>
        <trans-unit id="0980756624132b6830b479bc71ea60b90272891a" translate="yes" xml:space="preserve">
          <source>The manner in which SQLite uses temporary files is not considered part of the contract that SQLite makes with applications. The information in this document is a correct description of how SQLite operates at the time that this document was written or last updated. But there is no guarantee that future versions of SQLite will use temporary files in the same way. New kinds of temporary files might be employed and some of the current temporary file uses might be discontinued in future releases of SQLite.</source>
          <target state="translated">SQLite使用临时文件的方式不被认为是SQLite与应用程序签订的合同的一部分。本文档中的信息是本文档编写或最后一次更新时对SQLite操作方式的正确描述。但不能保证未来版本的SQLite会以同样的方式使用临时文件。在未来的SQLite版本中,可能会采用新的临时文件种类,而且当前的一些临时文件的使用可能会被停止。</target>
        </trans-unit>
        <trans-unit id="3c2b798d423398f0b8335bc4cb33aea4b3800944" translate="yes" xml:space="preserve">
          <source>The mapping from character to affinity is given by the SQLITE_AFF_ macros defined in sqliteInt.h.</source>
          <target state="translated">从字符到亲和力的映射由 sqliteInt.h 中定义的 SQLITE_AFF_宏给出。</target>
        </trans-unit>
        <trans-unit id="e5801820a892b25589a4f5acb0cdb08d7136d42b" translate="yes" xml:space="preserve">
          <source>The master journal file is only created for &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; operations that involve multiple database files where at least two of the databases meet all of the following requirements:</source>
          <target state="translated">仅为涉及多个数据库文件的&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;操作创建主日志文件，其中至少两个数据库满足以下所有要求：</target>
        </trans-unit>
        <trans-unit id="31da1199925e2ef2121e09ef393e19f883001204" translate="yes" xml:space="preserve">
          <source>The master journal file is used as part of the atomic commit process when a single transaction makes changes to multiple databases that have been added to a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. The master journal file is always located in the same directory as the main database file (the main database file is the database that is identified in the original &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that created the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;) with a randomized suffix. The master journal file contains the names of all of the various attached auxiliary databases that were changed during the transaction. The multi-database transaction commits when the master journal file is deleted. See the documentation titled &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit In SQLite&lt;/a&gt; for additional detail.</source>
          <target state="translated">当单个事务对使用&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;语句添加到单个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;中的多个数据库进行更改时，主日志文件将用作原子提交过程的一部分。主日志文件始终与主数据库文件位于同一目录中（主数据库文件是在创建&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;的原始&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;或&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;调用中标识的数据库）），并带有随机后缀。主日志文件包含在事务期间更改的所有各种附加辅助数据库的名称。当删除主日记文件时，将执行多数据库事务。有关更多详细信息，请参见标题为&amp;ldquo; &lt;a href=&quot;atomiccommit&quot;&gt;SQLite&lt;/a&gt;中的原子提交&amp;rdquo;的文档。</target>
        </trans-unit>
        <trans-unit id="772c6b302e1774e25495c91e9341c8308af64569" translate="yes" xml:space="preserve">
          <source>The matchinfo 'b' flag provides similar information to the &lt;a href=&quot;fts3#matchinfo-y&quot; id=&quot;matchinfo-b&quot;&gt;matchinfo 'y' flag&lt;/a&gt;, but in a more compact form. Instead of the precise number of hits, 'b' provides a single boolean flag for each phrase/column combination. If the phrase is present in the column at least once (i.e. if the corresponding integer output of 'y' would be non-zero), the corresponding flag is set. Otherwise cleared.</source>
          <target state="translated">所述matchinfo&amp;ldquo;b&amp;rdquo;标记提供类似的信息给&lt;a href=&quot;fts3#matchinfo-y&quot; id=&quot;matchinfo-b&quot;&gt;matchinfo&amp;ldquo;y&amp;rdquo;的标志&lt;/a&gt;，但在一个更紧凑的形式。&amp;ldquo; b&amp;rdquo;代替了准确的匹配数，而是为每个短语/列组合提供了一个布尔标志。如果该短语在该列中至少存在一次（即，如果&amp;ldquo; y&amp;rdquo;的相应整数输出为非零），则设置相应的标志。否则清除。</target>
        </trans-unit>
        <trans-unit id="0e92769ac2bedb9028e89c1796d219b3c41ebfd0" translate="yes" xml:space="preserve">
          <source>The matchinfo function is called with either one or two arguments. As for all auxiliary functions, the first argument must be the special &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt;. The second argument, if it is specified, must be a text value comprised only of the characters 'p', 'c', 'n', 'a', 'l', 's', 'x', 'y' and 'b'. If no second argument is explicitly supplied, it defaults to &quot;pcx&quot;. The second argument is referred to as the &quot;format string&quot; below.</source>
          <target state="translated">使用一个或两个参数调用matchinfo函数。对于所有辅助功能，第一个参数必须是特殊的&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS隐藏列&lt;/a&gt;。第二个参数（如果已指定）必须是仅由字符&amp;ldquo; p&amp;rdquo;，&amp;ldquo; c&amp;rdquo;，&amp;ldquo; n&amp;rdquo;，&amp;ldquo; a&amp;rdquo;，&amp;ldquo; l&amp;rdquo;，&amp;ldquo; s&amp;rdquo;，&amp;ldquo; x&amp;rdquo;，&amp;ldquo; y&amp;rdquo;组成的文本值和&amp;ldquo; b&amp;rdquo;。如果未显式提供第二个参数，则默认为&amp;ldquo; pcx&amp;rdquo;。第二个参数在下面称为&amp;ldquo;格式字符串&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d7687da8f246deec886a3154fb495c0792554c7d" translate="yes" xml:space="preserve">
          <source>The matchinfo function is much faster than either the snippet or offsets functions. This is because the implementation of both snippet and offsets is required to retrieve the documents being analyzed from disk, whereas all data required by matchinfo is available as part of the same portions of the full-text index that are required to implement the full-text query itself. This means that of the following two queries, the first may be an order of magnitude faster than the second:</source>
          <target state="translated">matchinfo 函数比 snippet 或 offsets 函数快得多。这是因为实现snippet和offsets都需要从磁盘上检索被分析的文档,而matchinfo所需要的所有数据都可以作为全文索引的一部分,这些部分是实现全文查询本身所需要的。这意味着,在以下两个查询中,第一个查询可能比第二个查询快一个数量级。</target>
        </trans-unit>
        <trans-unit id="c65df31b33c2a6ca0926acfdea9fd52aa875638d" translate="yes" xml:space="preserve">
          <source>The matchinfo function provides all the information required to calculate probabilistic &quot;bag-of-words&quot; relevancy scores such as &lt;a href=&quot;http://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;Okapi BM25/BM25F&lt;/a&gt; that may be used to order results in a full-text search application. Appendix A of this document, &quot;&lt;a href=&quot;fts3#appendix_a&quot;&gt;search application tips&lt;/a&gt;&quot;, contains an example of using the matchinfo() function efficiently.</source>
          <target state="translated">matchinfo函数提供了计算概率&amp;ldquo;单词袋&amp;rdquo;相关性分数所需的所有信息，例如&lt;a href=&quot;http://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;Okapi BM25 / BM25F&lt;/a&gt;，可用于对全文搜索应用程序中的结果进行排序。本文档的附录A&amp;ldquo; &lt;a href=&quot;fts3#appendix_a&quot;&gt;搜索应用程序技巧&lt;/a&gt; &amp;rdquo;包含一个有效使用matchinfo（）函数的示例。</target>
        </trans-unit>
        <trans-unit id="e90549847387fb18f595713064d87ed6f095e05c" translate="yes" xml:space="preserve">
          <source>The matchinfo function returns a blob value. If it is used within a query that does not use the full-text index (a &quot;query by rowid&quot; or &quot;linear scan&quot;), then the blob is zero bytes in size. Otherwise, the blob consists of zero or more 32-bit unsigned integers in machine byte-order. The exact number of integers in the returned array depends on both the query and the value of the second argument (if any) passed to the matchinfo function.</source>
          <target state="translated">matchinfo函数返回一个blob值。如果它是在一个不使用全文索引的查询中使用的(&quot;按rowid查询 &quot;或 &quot;线性扫描&quot;),那么blob的大小为零字节。否则,blob由0个或更多的32位无符号整数按机器字节顺序组成。返回数组中整数的确切数量取决于查询和传递给matchinfo函数的第二个参数的值(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="5fd973e0c684054ad3dbbf4a32a2b97ce84282bb" translate="yes" xml:space="preserve">
          <source>The matchinfo option may only be set to the value &quot;fts3&quot;. Attempting to set matchinfo to anything other than &quot;fts3&quot; is an error. If this option is specified, then some of the extra information stored by FTS4 is omitted. This reduces the amount of disk space consumed by an FTS4 table until it is almost the same as the amount that would be used by the equivalent FTS3 table, but also means that the data accessed by passing the 'l' flag to the &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; function is not available.</source>
          <target state="translated">matchinfo选项只能设置为值&amp;ldquo; fts3&amp;rdquo;。尝试将matchinfo设置为除&amp;ldquo; fts3&amp;rdquo;以外的任何其他内容是错误的。如果指定了此选项，则将省略FTS4存储的一些额外信息。这将减少FTS4表占用的磁盘空间量，直到与等效的FTS3表所使用的磁盘空间几乎相同为止，而且还意味着通过将'l'标志传递给&lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo（）&lt;/a&gt;来访问数据。功能不可用。</target>
        </trans-unit>
        <trans-unit id="30566a971375718efb83d0535cdd7975a1033a22" translate="yes" xml:space="preserve">
          <source>The matrix below shows the time needed to read BLOBs stored in separate files divided by the time needed to read BLOBs stored entirely in the database. Hence, for numbers larger than 1.0, it is faster to store the BLOBs directly in the database. For numbers smaller than 1.0, it is faster to store the BLOBs in separate files.</source>
          <target state="translated">下面的矩阵显示了读取存储在单独文件中的BLOB所需的时间除以读取完全存储在数据库中的BLOB所需的时间。因此,对于大于1.0的数字,直接将BLOBs存储在数据库中更快。对于小于1.0的数字,将BLOB存储在单独的文件中更快。</target>
        </trans-unit>
        <trans-unit id="4c2fbc6111561deb5f89baa2a61ac965889a611a" translate="yes" xml:space="preserve">
          <source>The max() aggregate function returns the maximum value of all values in the group. The maximum value is the value that would be returned last in an ORDER BY on the same column. Aggregate max() returns NULL if and only if there are no non-NULL values in the group.</source>
          <target state="translated">max()集合函数返回该组中所有值的最大值,最大值是同一列的ORDER BY中最后返回的值。最大值是在同一列的ORDER BY中最后返回的值。如果且仅当组中没有非NULL值时,聚合函数max()返回NULL。</target>
        </trans-unit>
        <trans-unit id="259079b25b4ee53dd3af62dccf64b88cf7401fe7" translate="yes" xml:space="preserve">
          <source>The maximum allowed value for the 'automerge' parameter is 16. The default value is 4. Setting the 'automerge' parameter to 0 disables the automatic incremental merging of b-trees altogether.</source>
          <target state="translated">automerge &quot;参数的最大允许值是16,默认值是4。默认值是4,将'automerge'参数设置为0,则完全禁止b树的自动增量合并。</target>
        </trans-unit>
        <trans-unit id="99bed95a8c8918c9ad675486624a0ec50cca0b55" translate="yes" xml:space="preserve">
          <source>The maximum amount of general-purpose memory needed by the application is determined by such factors as how many simultaneous open &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects the application uses, and on the complexity of the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;. For any given application, these factors are normally fixed and can be determined experimentally using &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;. A typical application might only use about 40KB of general-purpose memory. This gives a value of &lt;b&gt;N&lt;/b&gt; of around 100KB.</source>
          <target state="translated">应用程序所需的最大通用内存量由以下因素确定，这些因素包括应用程序使用多少个同时打开的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;和&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;对象，以及&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;的复杂性。对于任何给定的应用程序，这些因素通常是固定的，可以使用&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;通过实验确定。一个典型的应用程序可能只使用大约40KB的通用内存。&lt;b&gt;N&lt;/b&gt;的值约为100KB。</target>
        </trans-unit>
        <trans-unit id="a9b767b87a835989935611d9f91af0a49ef22427" translate="yes" xml:space="preserve">
          <source>The maximum and minimum embedded payload fractions and the leaf payload fraction values must be 64, 32, and 32. These values were originally intended to be tunable parameters that could be used to modify the storage format of the b-tree algorithm. However, that functionality is not supported and there are no current plans to add support in the future. Hence, these three bytes are fixed at the values specified.</source>
          <target state="translated">最大和最小的嵌入有效载荷分数和叶有效载荷分数值必须是64、32和32。这些值最初的目的是作为可调整的参数,可用于修改b树算法的存储格式。但是,该功能不被支持,目前也没有计划在未来增加支持。因此,这三个字节被固定在指定的值上。</target>
        </trans-unit>
        <trans-unit id="3b75dd01c336dd48a91229fb4fe465cfca0656d8" translate="yes" xml:space="preserve">
          <source>The maximum depth of an expression tree can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt;,size) interface if the SQLITE_MAX_EXPR_DEPTH is initially positive. In other words, the maximum expression depth can be lowered at run-time if there is already a compile-time limit on the expression depth. If SQLITE_MAX_EXPR_DEPTH is set to 0 at compile time (if the depth of expressions is unlimited) then the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt;,size) is a no-op.</source>
          <target state="translated">如果SQLITE_MAX_EXPR_DEPTH最初为正，则可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt;，size）接口降低表达式树的最大深度。换句话说，如果表达式深度已经存在编译时限制，则可以在运行时降低最大表达式深度。如果在编译时将SQLITE_MAX_EXPR_DEPTH设置为0（如果表达式的深度不受限制），则&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH的&lt;/a&gt;大小）是无操作的。</target>
        </trans-unit>
        <trans-unit id="7601f568790af4a666771d9637268d8679fb90bb" translate="yes" xml:space="preserve">
          <source>The maximum depth of recursion for triggers.</source>
          <target state="translated">触发器的最大递归深度。</target>
        </trans-unit>
        <trans-unit id="f7ca88d6870cff0eca30922b0b5339bd065f10ca" translate="yes" xml:space="preserve">
          <source>The maximum depth of the parse tree on any expression.</source>
          <target state="translated">任何表达式上解析树的最大深度。</target>
        </trans-unit>
        <trans-unit id="2e6bbb757edd69dcf67031bc6d4f260f516ed8d0" translate="yes" xml:space="preserve">
          <source>The maximum host parameter number can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;,size) interface.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;，size）接口降低最大主机参数数量。</target>
        </trans-unit>
        <trans-unit id="b3e774d908522cebf9bd7f7f3469b3fb31276410" translate="yes" xml:space="preserve">
          <source>The maximum index number of any &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; in an SQL statement.</source>
          <target state="translated">SQL语句中任何&lt;a href=&quot;../lang_expr#varparam&quot;&gt;参数&lt;/a&gt;的最大索引号。</target>
        </trans-unit>
        <trans-unit id="32a6d72e37d636464c2192cbf409c3425887feb6" translate="yes" xml:space="preserve">
          <source>The maximum index number of any &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; in an SQL statement.</source>
          <target state="translated">SQL语句中任何&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;的最大索引号。</target>
        </trans-unit>
        <trans-unit id="ab2a11cb65d0770d55a8b43b094028bd3c341a46" translate="yes" xml:space="preserve">
          <source>The maximum length of a LIKE or GLOB pattern can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlikepatternlength&quot;&gt;SQLITE_LIMIT_LIKE_PATTERN_LENGTH&lt;/a&gt;,size) interface.</source>
          <target state="translated">可以使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlikepatternlength&quot;&gt;SQLITE_LIMIT_LIKE_PATTERN_LENGTH&lt;/a&gt;，size）接口在运行时降低LIKE或GLOB模式的最大长度。</target>
        </trans-unit>
        <trans-unit id="295e913f367222db2770c86b223d1cb94f3eaca7" translate="yes" xml:space="preserve">
          <source>The maximum length of a SQL function name is 255 bytes of UTF8. Any attempt to create a function with a longer name will result in an &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d765036961e5dc86e0ba5117af47c297fab27c55" translate="yes" xml:space="preserve">
          <source>The maximum length of an SQL statement can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitsqllength&quot;&gt;SQLITE_LIMIT_SQL_LENGTH&lt;/a&gt;,size) interface.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitsqllength&quot;&gt;SQLITE_LIMIT_SQL_LENGTH&lt;/a&gt;，size）接口降低SQL语句的最大长度。</target>
        </trans-unit>
        <trans-unit id="d303fbf5ebde80b928a0a149ac1d360f8b2d9beb" translate="yes" xml:space="preserve">
          <source>The maximum length of an SQL statement, in bytes.</source>
          <target state="translated">一个SQL语句的最大长度,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="c8feb93491c3d188a9985624d09a15796f2e0e57" translate="yes" xml:space="preserve">
          <source>The maximum length of the pattern argument to the &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operators.</source>
          <target state="translated">&lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt;或&lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;运算符的pattern参数的最大长度。</target>
        </trans-unit>
        <trans-unit id="1ee02be23a19dec285dd5109a44c64362161f0e7" translate="yes" xml:space="preserve">
          <source>The maximum length of the pattern argument to the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operators.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;或&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;运算符的pattern参数的最大长度。</target>
        </trans-unit>
        <trans-unit id="b23da6f4323ba72ffe46e74c0191923768cdb864" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;a href=&quot;../lang_attach&quot;&gt;attached databases&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../lang_attach&quot;&gt;附加数据库&lt;/a&gt;的最大数量。</target>
        </trans-unit>
        <trans-unit id="b544569d59df80608bd6a41e19a745bdff4577b6" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;a href=&quot;lang_attach&quot;&gt;attached databases&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;附加数据库&lt;/a&gt;的最大数量。</target>
        </trans-unit>
        <trans-unit id="471b9bc71d47534b60a1c278c46d4cee7c9664ba" translate="yes" xml:space="preserve">
          <source>The maximum number of arguments in a function can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;,size) interface.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;，size）接口降低函数中参数的最大数量。</target>
        </trans-unit>
        <trans-unit id="00eff3b06f801e572f28af21289c2619b46c2f08" translate="yes" xml:space="preserve">
          <source>The maximum number of arguments on a function.</source>
          <target state="translated">一个函数的最大参数数。</target>
        </trans-unit>
        <trans-unit id="b6c416e24701b8851e7053c0bb7cd7dd6b331315" translate="yes" xml:space="preserve">
          <source>The maximum number of attached databases can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt;,size) interface.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt;，size）接口降低附加数据库的最大数量。</target>
        </trans-unit>
        <trans-unit id="0b6c3c6cf8605d1353c6caeac57deb9da3ed0c6e" translate="yes" xml:space="preserve">
          <source>The maximum number of auxiliary worker threads that a single &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; may start.</source>
          <target state="translated">一个&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;可以启动的辅助工作线程的最大数量。</target>
        </trans-unit>
        <trans-unit id="66f8c3a081d879e272abf19945402c6cac2a7ecc" translate="yes" xml:space="preserve">
          <source>The maximum number of auxiliary worker threads that a single &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; may start.</source>
          <target state="translated">一个&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;可以启动的辅助工作线程的最大数量。</target>
        </trans-unit>
        <trans-unit id="bbb454e2483711c9ac94945a0c80d3f47e450874" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes in a string or BLOB in SQLite is defined by the preprocessor macro SQLITE_MAX_LENGTH. The default value of this macro is 1 billion (1 thousand million or 1,000,000,000). You can raise or lower this value at compile-time using a command-line option like this:</source>
          <target state="translated">在SQLite中,字符串或BLOB的最大字节数由预处理器宏SQLITE_MAX_LENGTH定义。这个宏的默认值是10亿(10亿或1,000,000,000)。你可以在编译时使用命令行选项提高或降低这个值,比如这样。</target>
        </trans-unit>
        <trans-unit id="da1ee68dd77283238b55af162c380f02592134ee" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes in the text of an SQL statement is limited to SQLITE_MAX_SQL_LENGTH which defaults to 1000000. You can redefine this limit to be as large as the smaller of SQLITE_MAX_LENGTH and 1073741824.</source>
          <target state="translated">SQL语句文本中的最大字节数限制为SQLITE_MAX_SQL_LENGTH,默认为1000000。你可以重新定义这个限制,使其大到SQLITE_MAX_LENGTH和1073741824中的较小值。</target>
        </trans-unit>
        <trans-unit id="6345ddabb514350f3e36f681af647ea84308cf28" translate="yes" xml:space="preserve">
          <source>The maximum number of columns can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt;,size) interface.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt;，size）接口降低最大列数。</target>
        </trans-unit>
        <trans-unit id="1c620a336050426a95c894972afda47b3aee66a2" translate="yes" xml:space="preserve">
          <source>The maximum number of columns in a table definition or in the result set of a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; or the maximum number of columns in an index or in an ORDER BY or GROUP BY clause.</source>
          <target state="translated">表定义或&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;结果集中的最大列数，或索引或ORDER BY或GROUP BY子句中的最大列数。</target>
        </trans-unit>
        <trans-unit id="355eec7f9bb7446523a2374f005ae8119aa229d8" translate="yes" xml:space="preserve">
          <source>The maximum number of columns in a table definition or in the result set of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; or the maximum number of columns in an index or in an ORDER BY or GROUP BY clause.</source>
          <target state="translated">表定义或&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;结果集中的最大列数，或索引或ORDER BY或GROUP BY子句中的最大列数。</target>
        </trans-unit>
        <trans-unit id="8374b8e68f54521ffc214c5ed7e8c2d7fd95f1b7" translate="yes" xml:space="preserve">
          <source>The maximum number of compound SELECT terms can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT&lt;/a&gt;,size) interface.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT&lt;/a&gt;，size）接口降低复合SELECT术语的最大数量。</target>
        </trans-unit>
        <trans-unit id="63cbc7c9607d5bbb2a5e8441eb06e668604fc05c" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions in a virtual machine program used to implement an SQL statement. If &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or the equivalent tries to allocate space for more than this many opcodes in a single prepared statement, an SQLITE_NOMEM error is returned.</source>
          <target state="translated">虚拟机程序中用于实现SQL语句的最大指令数。如果&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或等效方法试图在单个准备好的语句中为多个操作码分配空间，则将返回SQLITE_NOMEM错误。</target>
        </trans-unit>
        <trans-unit id="3914cdf98f328c74ff19ff41972588f848a7b49e" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions in a virtual machine program used to implement an SQL statement. If &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or the equivalent tries to allocate space for more than this many opcodes in a single prepared statement, an SQLITE_NOMEM error is returned.</source>
          <target state="translated">虚拟机程序中用于实现SQL语句的最大指令数。如果&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或等效方法试图在单个准备好的语句中为多个操作码分配空间，则将返回SQLITE_NOMEM错误。</target>
        </trans-unit>
        <trans-unit id="7c57be7916f18cb9fd931235954ed49b10f67a38" translate="yes" xml:space="preserve">
          <source>The maximum number of terms in a compound SELECT statement.</source>
          <target state="translated">复合SELECT语句中的最大项数。</target>
        </trans-unit>
        <trans-unit id="6409e263b558e4fc8032ff274ccb7661be29c559" translate="yes" xml:space="preserve">
          <source>The maximum number of tokens in the returned text. This must be greater than zero and equal to or less than 64.</source>
          <target state="translated">返回文本中的最大标记数。必须大于零,等于或小于64。</target>
        </trans-unit>
        <trans-unit id="970d6e67d87a8bc5f32df0c8fe5b2ab66eff4335" translate="yes" xml:space="preserve">
          <source>The maximum parameter number is set at compile-time by the &lt;a href=&quot;limits#max_variable_number&quot;&gt;SQLITE_MAX_VARIABLE_NUMBER&lt;/a&gt; macro. An individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; D can reduce its maximum parameter number below the compile-time maximum using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(D, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;,...) interface.</source>
          <target state="translated">最大参数数是在编译时由&lt;a href=&quot;limits#max_variable_number&quot;&gt;SQLITE_MAX_VARIABLE_NUMBER&lt;/a&gt;宏设置的。单个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt; D可以使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（D，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;，...）接口将其最大参数数减少到编译时最大值以下。</target>
        </trans-unit>
        <trans-unit id="eeb9b32b1bfb4a0ced4bb9bc2aaa054c3abdfc92" translate="yes" xml:space="preserve">
          <source>The maximum size of any string or BLOB or table row, in bytes.</source>
          <target state="translated">任何字符串或BLOB或表格行的最大尺寸,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="c7f288d6ab417ac4a35975a5356fac79645319c2" translate="yes" xml:space="preserve">
          <source>The maximum string or BLOB length can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;,size) interface.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;，size）接口降低最大字符串或BLOB长度。</target>
        </trans-unit>
        <trans-unit id="770a09ba0039805fb6c3142551082e18eaaafe07" translate="yes" xml:space="preserve">
          <source>The meaning of P5 depends on whether or not the SQLITE_ENABLE_NULL_TRIM compile-time option is enabled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cc8ccfaed1025b2039c6bdfd6b0a5399eacb5ca" translate="yes" xml:space="preserve">
          <source>The meanings for all $nResCode result code values are shown below, in numeric order.</source>
          <target state="translated">所有$nResCode结果代码值的含义如下所示,按数字顺序排列。</target>
        </trans-unit>
        <trans-unit id="4cad3638dbf4cc08ff40caa02c71d9ae2dc2cc12" translate="yes" xml:space="preserve">
          <source>The meanings for all 92 result code values are shown below, in numeric order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07eeff254885d567e91c4b2aaaeee641fbf91699" translate="yes" xml:space="preserve">
          <source>The meanings of the fields of the schema table are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acfaa39aa41d2de54931d409a9de16ab158bc08a" translate="yes" xml:space="preserve">
          <source>The meanings of these various return values are as follows:</source>
          <target state="translated">这些不同的返回值的含义如下:</target>
        </trans-unit>
        <trans-unit id="3594f845ca8155469ebf0d3a1db0993f4bb9cbd1" translate="yes" xml:space="preserve">
          <source>The measurements in this article were made during the week of 2017-06-05 using a version of SQLite in between 3.19.2 and 3.20.0. You may expect future versions of SQLite to perform even better.</source>
          <target state="translated">本文中的测量是在2017-06-05这一周使用3.19.2和3.20.0之间的SQLite版本进行的。您可能会期待未来版本的SQLite表现更好。</target>
        </trans-unit>
        <trans-unit id="5036b12169e90ae6667838e4b73b7f71ccf84ec9" translate="yes" xml:space="preserve">
          <source>The memory allocation limits can also be adjusted using &lt;a href=&quot;../pragma#pragma_soft_heap_limit&quot;&gt;PRAGMA soft_heap_limit&lt;/a&gt; and &lt;a href=&quot;../pragma#pragma_hard_heap_limit&quot;&gt;PRAGMA hard_heap_limit&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2809fd545c907ef31fca4768c017467b4928225" translate="yes" xml:space="preserve">
          <source>The memory allocation limits can also be adjusted using &lt;a href=&quot;pragma#pragma_soft_heap_limit&quot;&gt;PRAGMA soft_heap_limit&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_hard_heap_limit&quot;&gt;PRAGMA hard_heap_limit&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e788358e2ac74022367111d33deb5ddc9a976282" translate="yes" xml:space="preserve">
          <source>The memory corruption problem becomes more acute when using &lt;a href=&quot;mmap&quot;&gt;memory-mapped I/O&lt;/a&gt;. When all or part of the database file is mapped into the application's address space, then a stray pointer that overwrites any part of that mapped space will immediately corrupt the database file, without requiring the application to do a subsequent write() system call.</source>
          <target state="translated">使用&lt;a href=&quot;mmap&quot;&gt;内存映射的I / O&lt;/a&gt;时，内存损坏问题变得更加严重。当数据库文件的全部或部分映射到应用程序的地址空间时，覆盖该映射空间的任何部分的杂散指针将立即破坏数据库文件，而无需应用程序执行后续的write（）系统调用。</target>
        </trans-unit>
        <trans-unit id="1f25753cb6dacb02b829c0a340f5d35891b7f9cb" translate="yes" xml:space="preserve">
          <source>The memory footprint of the application can be dramatically reduced by only loading content that is relevant to the current display and keeping the bulk of the content on disk. The fast query capability of SQLite make this a viable alternative to keeping all content in memory at all times. And when applications use less memory, it makes the entire computer more responsive, further enhancing the user experience.</source>
          <target state="translated">通过只加载与当前显示相关的内容,而将大部分内容保留在磁盘上,可以极大地减少应用程序的内存占用。SQLite的快速查询能力使其成为一个可行的替代方案,而不是将所有内容始终保留在内存中。而当应用程序使用较少的内存时,就会使整个计算机的响应速度更快,进一步提升用户体验。</target>
        </trans-unit>
        <trans-unit id="9d3e4b06e9105ca7c88a4e1edabcb69936b1841b" translate="yes" xml:space="preserve">
          <source>The memory high-water mark is reset to the current value of &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; if and only if the parameter to &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; is true. The value returned by &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater(1)&lt;/a&gt; is the high-water mark prior to the reset.</source>
          <target state="translated">当且仅当&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;的参数为true时，内存高水位标记才会重置为&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;的当前值。&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater（1）&lt;/a&gt;返回的值是重置之前的高水位线。</target>
        </trans-unit>
        <trans-unit id="cd5593ab95a8d1e1ac6cc8d242678782f1a535e8" translate="yes" xml:space="preserve">
          <source>The memory high-water mark is reset to the current value of &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; if and only if the parameter to &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; is true. The value returned by &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater(1)&lt;/a&gt; is the high-water mark prior to the reset.</source>
          <target state="translated">当且仅当&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;的参数为true时，内存高水位标记才会重置为&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;的当前值。&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater（1）&lt;/a&gt;返回的值是重置之前的高水位线。</target>
        </trans-unit>
        <trans-unit id="a98788d1208d8031c1910803fa2f1051d600b111" translate="yes" xml:space="preserve">
          <source>The memory pointed to by the character pointers returned for the declaration type and collation sequence is valid until the next call to any SQLite API function.</source>
          <target state="translated">为声明类型和整理序列返回的字符指针所指向的内存是有效的,直到下一次调用任何SQLite API函数。</target>
        </trans-unit>
        <trans-unit id="523aa17230ae599153575b20eede454c13803757" translate="yes" xml:space="preserve">
          <source>The memory returned by sqlite3_malloc(), sqlite3_realloc(), sqlite3_malloc64(), and sqlite3_realloc64() is always aligned to at least an 8 byte boundary, or to a 4 byte boundary if the &lt;a href=&quot;../compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">sqlite3_malloc（），sqlite3_realloc（），sqlite3_malloc64（）和sqlite3_realloc64（）返回的内存始终至少对齐8个字节边界，如果使用&lt;a href=&quot;../compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt;编译时选项，则始终对齐4个字节边界。</target>
        </trans-unit>
        <trans-unit id="0b4a85ec728749e1396a0209dbea3173ce995dba" translate="yes" xml:space="preserve">
          <source>The memory returned by sqlite3_malloc(), sqlite3_realloc(), sqlite3_malloc64(), and sqlite3_realloc64() is always aligned to at least an 8 byte boundary, or to a 4 byte boundary if the &lt;a href=&quot;compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">sqlite3_malloc（），sqlite3_realloc（），sqlite3_malloc64（）和sqlite3_realloc64（）返回的内存始终至少对齐8个字节边界，如果使用&lt;a href=&quot;compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt;编译时选项，则始终对齐4个字节边界。</target>
        </trans-unit>
        <trans-unit id="d4065cde811c203e3d250a3f54d5601da517866b" translate="yes" xml:space="preserve">
          <source>The memsys5 allocator is designed for use on embedded systems, though there is nothing to prevent its use on workstations. The szBuf is typically between a few hundred kilobytes up to a few dozen megabytes, depending on system requirements and memory budget.</source>
          <target state="translated">memsys5分配器是为在嵌入式系统上使用而设计的,不过并不妨碍在工作站上使用它。szBuf通常在几百千字节到几十兆字节之间,这取决于系统需求和内存预算。</target>
        </trans-unit>
        <trans-unit id="15e755d3b15a2797fc8e730750dc9e96957bcf11" translate="yes" xml:space="preserve">
          <source>The min() aggregate function returns the minimum non-NULL value of all values in the group. The minimum value is the first non-NULL value that would appear in an ORDER BY of the column. Aggregate min() returns NULL if and only if there are no non-NULL values in the group.</source>
          <target state="translated">min()集合函数返回该组中所有值的最小非NULL值,最小值是在列的ORDER BY中出现的第一个非NULL值。最小值是列的ORDER BY中出现的第一个非NULL值。聚合函数min()只在组中没有非NULL值的情况下返回NULL。</target>
        </trans-unit>
        <trans-unit id="114a5a7dbd98c187abf7e68d111172546895bf6d" translate="yes" xml:space="preserve">
          <source>The min/max-value pair columns are stored as 32-bit floating point values for &quot;rtree&quot; virtual tables or as 32-bit signed integers in &quot;rtree_i32&quot; virtual tables. Unlike regular SQLite tables which can store data in a variety of datatypes and formats, the R*Tree rigidly enforce these storage types. If any other type of value is inserted into such a column, the r-tree module silently converts it to the required type before writing the new record to the database.</source>
          <target state="translated">对于 &quot;rtree &quot;虚拟表来说,最小值/最大值对列存储为32位浮点值,或者在 &quot;rtree_i32 &quot;虚拟表中存储为32位有符号整数。与常规的SQLite表可以以各种数据类型和格式存储数据不同,R*Tree严格执行这些存储类型。如果在这样的列中插入任何其他类型的值,r-tree模块会在将新记录写入数据库之前,默默地将其转换为所需类型。</target>
        </trans-unit>
        <trans-unit id="697dd64d2ba004e05302a199cbf94ae930397047" translate="yes" xml:space="preserve">
          <source>The minimum &quot;three+four&quot; value</source>
          <target state="translated">最低 &quot;三+四 &quot;值</target>
        </trans-unit>
        <trans-unit id="4344744cb5e4e7fe1c07e4d9e9f4f1a35db07ca5" translate="yes" xml:space="preserve">
          <source>The minimum size of an SQLite database is one page for each table and each index. With a larger page size, the size of an empty database for a given schema will grow by a factor of four, therefore. However, once the database begins to fill with content the size of the older 1024-byte page databases and the newer 4096-byte page databases will quickly converge. Due to relaxed bin-packing constraints, the 4096-byte page size might actually result in a smaller file, once substantial content is added.</source>
          <target state="translated">SQLite数据库的最小尺寸是每个表和每个索引的一个页面。随着页面大小的增大,一个给定模式的空数据库的大小将增长4倍,因此。然而,一旦数据库开始充满内容,旧的1024字节页数据库和新的4096字节页数据库的大小将迅速趋同。由于放宽了bin-packing限制,一旦添加了大量内容,4096字节的页面大小实际上可能会导致文件变小。</target>
        </trans-unit>
        <trans-unit id="e5d2ce57cb5bfbf79b3c98a499658be04c3e7756" translate="yes" xml:space="preserve">
          <source>The minor version number Y was historically incremented for new features and/or new interfaces that did not significantly change the structure of the code. The addition of &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt;, &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;, and &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt; are all examples of &quot;minor&quot; changes. Again, the distinction between &quot;major&quot; and &quot;minor&quot; is subjective.</source>
          <target state="translated">对于新功能和/或新接口，次要版本号Y在历史上一直递增，而新功能和/或新接口并未显着改变代码的结构。的加入&lt;a href=&quot;lang_with&quot;&gt;公共表表达式&lt;/a&gt;，&lt;a href=&quot;partialindex&quot;&gt;部分指标&lt;/a&gt;和&lt;a href=&quot;expridx&quot;&gt;指标上的表达&lt;/a&gt;是&amp;ldquo;小&amp;rdquo;的变化的例子。同样，&amp;ldquo;主要&amp;rdquo;和&amp;ldquo;次要&amp;rdquo;之间的区别是主观的。</target>
        </trans-unit>
        <trans-unit id="daac53b800202886e5a1bc16ab5a5eb44a3f8d4d" translate="yes" xml:space="preserve">
          <source>The mirror is an incremental export of the &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;canonical Fossil repository&lt;/a&gt; for SQLite. A cron-job updates the GitHub repository once an hour. This is a one-way, read-only code mirror. No pull requests or changes are accepted via GitHub. The GitHub repository merely copies the content from the Fossil repository. All changes are input via Fossil.</source>
          <target state="translated">镜像是SQLite &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;规范化Fossil存储库&lt;/a&gt;的增量导出。一个cron-job每小时更新一次GitHub存储库。这是一个单向只读代码镜像。 GitHub不接受任何请求或更改。 GitHub存储库仅复制Fossil存储库中的内容。所有更改均通过Fossil输入。</target>
        </trans-unit>
        <trans-unit id="8699fa6e48270c38aaec7f72b7768d7c856e3da2" translate="yes" xml:space="preserve">
          <source>The mmap_size is set separately for each database file using the &quot;&lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;&quot; statement. The usual default mmap_size is zero, meaning that memory mapped I/O is disabled by default. However, the default mmap_size can be increased either at compile-time using the &lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt; macro or at start-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;,...) interface.</source>
          <target state="translated">使用&amp;ldquo; &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; &amp;rdquo;语句为每个数据库文件分别设置mmap_size。通常的默认mmap_size为零，这意味着默认情况下禁用内存映射的I / O。但是，可以在编译时使用&lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt;宏或在启动时使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;，...）接口来增加默认的mmap_size 。</target>
        </trans-unit>
        <trans-unit id="bc3aa8081ad975eaa64522ee2647fdff6a383213" translate="yes" xml:space="preserve">
          <source>The mode query parameter determines if the new database is opened read-only, read-write, read-write and created if it does not exist, or that the database is a pure in-memory database that never interacts with disk, respectively.</source>
          <target state="translated">模式查询参数分别决定新数据库是只读、读写、读写,如果不存在则创建,或者数据库是纯内存数据库,从不与磁盘交互。</target>
        </trans-unit>
        <trans-unit id="f2526ac46e681fb29c61b97dfb71933e5d3d8f00" translate="yes" xml:space="preserve">
          <source>The modifications made to each row affected by an UPDATE statement are determined by the list of assignments following the SET keyword. Each assignment specifies a column-name to the left of the equals sign and a scalar expression to the right. For each affected row, the named columns are set to the values found by evaluating the corresponding scalar expressions. If a single column-name appears more than once in the list of assignment expressions, all but the rightmost occurrence is ignored. Columns that do not appear in the list of assignments are left unmodified. The scalar expressions may refer to columns of the row being updated. In this case all scalar expressions are evaluated before any assignments are made.</source>
          <target state="translated">受UPDATE语句影响的每条记录的修改由SET关键字后面的赋值列表决定。每个赋值都在等号左边指定一个列名,右边指定一个标量表达式。对于每一条受影响的记录,被命名的列会被设置为通过评估相应的标量表达式所找到的值。如果一个列名在赋值表达式列表中出现了一次以上,那么除了最右边出现的列名外,其他列名都会被忽略。没有出现在赋值列表中的列名将不被修改。标量表达式可能指的是被更新行的列。在这种情况下,所有标量表达式在进行任何赋值之前都会被评估。</target>
        </trans-unit>
        <trans-unit id="c57c56215c73a95bddb16c7f419303a4f511dbe2" translate="yes" xml:space="preserve">
          <source>The module name is registered on the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the first parameter. The name of the module is given by the second parameter. The third parameter is a pointer to the implementation of the &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt;. The fourth parameter is an arbitrary client data pointer that is passed through into the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of the virtual table module when a new virtual table is be being created or reinitialized.</source>
          <target state="translated">模块名称在第一个参数指定的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;上注册。模块的名称由第二个参数给出。第三个参数是&lt;a href=&quot;#sqlite3_module&quot;&gt;虚拟表模块&lt;/a&gt;实现的指针。第四个参数是一个任意的客户端数据指针，当创建或重新初始化新的虚拟表时，该指针将传递到虚拟表模块的&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;和&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;方法中。</target>
        </trans-unit>
        <trans-unit id="f7d008fdf7032ca8558d613dfe5b4ba03ec8869a" translate="yes" xml:space="preserve">
          <source>The module name is registered on the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the first parameter. The name of the module is given by the second parameter. The third parameter is a pointer to the implementation of the &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt;. The fourth parameter is an arbitrary client data pointer that is passed through into the &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of the virtual table module when a new virtual table is be being created or reinitialized.</source>
          <target state="translated">模块名称在第一个参数指定的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;上注册。模块的名称由第二个参数给出。第三个参数是&lt;a href=&quot;module&quot;&gt;虚拟表模块&lt;/a&gt;实现的指针。第四个参数是一个任意的客户端数据指针，当创建或重新初始化新的虚拟表时，该指针将传递到虚拟表模块的&lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;和&lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;方法中。</target>
        </trans-unit>
        <trans-unit id="c29884604bb765a8ff66e73918a8eec45479c155" translate="yes" xml:space="preserve">
          <source>The module name must be changed from &quot;fts3&quot; or &quot;fts4&quot; to &quot;fts5&quot;.</source>
          <target state="translated">模块名称必须从 &quot;fts3 &quot;或 &quot;fts4 &quot;改为 &quot;fts5&quot;。</target>
        </trans-unit>
        <trans-unit id="ea30bfabecd455dc9fb80bfe26599d0bf2066398" translate="yes" xml:space="preserve">
          <source>The module structure contains methods that are invoked by SQLite to perform various actions on the virtual table such as creating new instances of a virtual table or destroying old ones, reading and writing data, searching for and deleting, updating, or inserting rows. The module structure is explained in more detail below.</source>
          <target state="translated">该模块结构包含了SQLite调用的方法,用于对虚拟表执行各种操作,如创建虚拟表的新实例或销毁旧实例、读写数据、搜索和删除、更新或插入行。下面将对该模块结构进行详细说明。</target>
        </trans-unit>
        <trans-unit id="e7e8ce1834b0e39b1a04f1ee58c27c3761f545ea" translate="yes" xml:space="preserve">
          <source>The module structure defines all of the methods for each virtual table object. The module structure also contains the iVersion field which defines the particular edition of the module table structure. Currently, iVersion is always 3 or less, but in future releases of SQLite the module structure definition might be extended with additional methods and in that case the maximum iVersion value will be increased.</source>
          <target state="translated">模块结构定义了每个虚拟表对象的所有方法。模块结构还包含iVersion字段,它定义了模块表结构的特定版本。目前,iVersion总是3或更少,但在未来的SQLite版本中,模块结构定义可能会扩展更多的方法,在这种情况下,最大的iVersion值会增加。</target>
        </trans-unit>
        <trans-unit id="f82636212897757718a1a7712ed9f6ebe7472ac1" translate="yes" xml:space="preserve">
          <source>The module-name is the name of an object that implements the virtual table. The module-name must be registered with the SQLite database connection using &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; prior to issuing the CREATE VIRTUAL TABLE statement. The module takes zero or more comma-separated arguments. The arguments can be just about any text as long as it has balanced parentheses. The argument syntax is sufficiently general that the arguments can be made to appear as &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definitions&lt;/a&gt; in a traditional &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. SQLite passes the module arguments directly to the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of the module implementation without any interpretation. It is the responsibility of the module implementation to parse and interpret its own arguments.</source>
          <target state="translated">module-name是实现虚拟表的对象的名称。在发出CREATE VIRTUAL TABLE语句之前，必须使用&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module（）&lt;/a&gt;或&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2（）&lt;/a&gt;向SQLite数据库连接注册模块名称。该模块接受零个或多个逗号分隔的参数。只要括号中有括号，参数就可以是任何文本。参数语法足够通用，可以使参数在传统的&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句中显示为&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;列定义&lt;/a&gt;。 SQLite将模块参数直接传递给&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;和&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;模块实现的方法，无需任何解释。模块实现负责解析和解释其自身的参数。</target>
        </trans-unit>
        <trans-unit id="44619ca32ea56419710789f2ec6fc9766c59ac70" translate="yes" xml:space="preserve">
          <source>The most common reason an attempt to obtain a</source>
          <target state="translated">最常见的原因是,试图获得</target>
        </trans-unit>
        <trans-unit id="b4677e9c54155902987749f94de50b511a297fed" translate="yes" xml:space="preserve">
          <source>The most common way to force an SQLite database to exist purely in memory is to open the database using the special filename &quot;&lt;b&gt;:memory:&lt;/b&gt;&quot;. In other words, instead of passing the name of a real disk file into one of the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; functions, pass in the string &quot;:memory:&quot;. For example:</source>
          <target state="translated">强制SQLite数据库完全存在于内存中的最常见方法是使用特殊文件名&amp;ldquo; &lt;b&gt;：memory：&lt;/b&gt; &amp;rdquo; 打开数据库。换句话说，不是将实际磁盘文件的名称传递给&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;或&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;函数之一，而是传递字符串&amp;ldquo;：memory：&amp;rdquo;。例如：</target>
        </trans-unit>
        <trans-unit id="03a7919d9a36d839fb3e6c8676819056867ece77" translate="yes" xml:space="preserve">
          <source>The most efficient way to apply changes to a B-Tree (the data structure that SQLite uses to store each table and index on disk) is to make the changes in key order. But if an SQL table has one or more indexes, the key order for each index may be different from the main table and the other auxiliary indexes. As a result, when executing a series of &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements it is not generally possible to order the operations so that all b-trees are updated in key order. The RBU update process works around this by applying all changes to the main table in one pass, then applying changes to each index in separate passes, ensuring each B-Tree is updated optimally. For a large database file (one that does not fit in the OS disk cache) this procedure can result in two orders of magnitude faster updates.</source>
          <target state="translated">将更改应用于B树（SQLite用于在磁盘上存储每个表和索引的数据结构）的最有效方法是按键顺序进行更改。但是，如果SQL表具有一个或多个索引，则每个索引的键顺序可能与主表和其他辅助索引不同。结果，当执行一系列&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;，&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;和&lt;a href=&quot;lang_delete&quot;&gt;DELETE时&lt;/a&gt;语句通常无法对操作进行排序，以使所有b树都按键顺序进行更新。 RBU更新过程通过一次将所有更改应用于主表，然后在单独的通道中将更改应用于每个索引，从而确保对每个B-Tree进行最佳更新来解决此问题。对于大型数据库文件（一个不适合OS磁盘缓存的文件），此过程可以使更新速度提高两个数量级。</target>
        </trans-unit>
        <trans-unit id="0aab584bc04ad9506143fb4e57b11f24aeb68952" translate="yes" xml:space="preserve">
          <source>The most useful</source>
          <target state="translated">最有用的</target>
        </trans-unit>
        <trans-unit id="672a287b758e4f6545eeda0d335349088507b997" translate="yes" xml:space="preserve">
          <source>The most useful thing about FTS tables is the queries that may be performed using the built-in full-text index. Full-text queries are performed by specifying a clause of the form &quot;&amp;lt;column&amp;gt; MATCH &amp;lt;full-text query expression&amp;gt;&quot; as part of the WHERE clause of a SELECT statement that reads data from an FTS table. &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;Simple FTS queries&lt;/a&gt; that return all documents that contain a given term are described above. In that discussion the right-hand operand of the MATCH operator was assumed to be a string consisting of a single term. This section describes the more complex query types supported by FTS tables, and how they may be utilized by specifying a more complex query expression as the right-hand operand of a MATCH operator.</source>
          <target state="translated">关于FTS表，最有用的是可以使用内置的全文本索引执行的查询。通过指定形式为&amp;ldquo; &amp;lt;column&amp;gt; MATCH &amp;lt;全文查询表达式&amp;gt;&amp;rdquo;的子句来执行全文查询，这是从FTS表中读取数据的SELECT语句的WHERE子句的一部分。上面描述了返回所有包含给定术语的所有文档的&lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;简单FTS查询&lt;/a&gt;。在该讨论中，MATCH运算符的右侧操作数被假定为由单个项组成的字符串。本节描述FTS表支持的更复杂的查询类型，以及如何通过将更复杂的查询表达式指定为MATCH运算符的右侧操作数来利用它们。</target>
        </trans-unit>
        <trans-unit id="b952b720a1c68c621b96fa1e29a1ec3a3e91db58" translate="yes" xml:space="preserve">
          <source>The multi-argument max() function returns the argument with the maximum value, or return NULL if any argument is NULL. The multi-argument max() function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If none of the arguments to max() define a collating function, then the BINARY collating function is used. Note that &lt;b&gt;max()&lt;/b&gt; is a simple function when it has 2 or more arguments but operates as an &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;aggregate function&lt;/a&gt; if given only a single argument.</source>
          <target state="translated">多参数max（）函数返回具有最大值的参数，如果任何参数为NULL，则返回NULL。多参数max（）函数从左到右搜索其参数，以找到定义整理函数并将该整理函数用于所有字符串比较的参数。如果max（）的参数均未定义整理函数，则使用BINARY整理函数。请注意，当&lt;b&gt;max（）&lt;/b&gt;具有2个或更多参数时，它是一个简单函数，但如果仅给出单个参数，则它作为一个&lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;聚合函数&lt;/a&gt;运行。</target>
        </trans-unit>
        <trans-unit id="4978bfa5c1668418de3cae9f58ae0236b3a923fa" translate="yes" xml:space="preserve">
          <source>The multi-argument min() function returns the argument with the minimum value. The multi-argument min() function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If none of the arguments to min() define a collating function, then the BINARY collating function is used. Note that &lt;b&gt;min()&lt;/b&gt; is a simple function when it has 2 or more arguments but operates as an &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;aggregate function&lt;/a&gt; if given only a single argument.</source>
          <target state="translated">多参数min（）函数返回带有最小值的参数。多参数min（）函数从左到右搜索其参数，以定义一个定义整理函数的参数，并将该整理函数用于所有字符串比较。如果min（）的参数均未定义整理函数，则使用BINARY整理函数。请注意，当&lt;b&gt;min（）&lt;/b&gt;具有2个或更多参数时，它是一个简单的函数；但是，如果仅给定单个参数，则它将作为&lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;聚合函数&lt;/a&gt;运行。</target>
        </trans-unit>
        <trans-unit id="78c0cf060a6f9ee3d1106d60ebe5e6c21511776f" translate="yes" xml:space="preserve">
          <source>The multiply operator now correctly detects 64-bit integer overflow and promotes to floating point in all corner-cases. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/1ec41379c9c1e400&quot;&gt;1ec41379c9c1e400&lt;/a&gt;.</source>
          <target state="translated">现在，乘法运算符可以正确检测到64位整数溢出，并在所有转折情况下都提升为浮点数。修复票&lt;a href=&quot;https://www.sqlite.org/src/info/1ec41379c9c1e400&quot;&gt;1ec41379c9c1e400&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ee9132cb0f48417f8650cad9e27fe43d03b0618b" translate="yes" xml:space="preserve">
          <source>The mutation-test.tcl script takes care of all of the details for running a mutation test:</source>
          <target state="translated">mutation-test.tcl脚本处理了运行突变测试的所有细节。</target>
        </trans-unit>
        <trans-unit id="2945579c517aa1d3b8ba9d11b0bc3f91de1e9921" translate="yes" xml:space="preserve">
          <source>The mutex module within SQLite defines &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; to be an abstract type for a mutex object. The SQLite core never looks at the internal representation of an &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;. It only deals with pointers to the &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object.</source>
          <target state="translated">SQLite中的互斥模块将&lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;定义为互斥对象的抽象类型。SQLite核心从不查看&lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;的内部表示。它仅处理指向&lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;对象的指针。</target>
        </trans-unit>
        <trans-unit id="d0e09c593f6493d406d9e4e9dcac2eadda30e574" translate="yes" xml:space="preserve">
          <source>The mutex module within SQLite defines &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; to be an abstract type for a mutex object. The SQLite core never looks at the internal representation of an &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;. It only deals with pointers to the &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object.</source>
          <target state="translated">SQLite中的互斥模块将&lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;定义为互斥对象的抽象类型。SQLite核心从不查看&lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;的内部表示。它仅处理指向&lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;对象的指针。</target>
        </trans-unit>
        <trans-unit id="2683feab4dd898006f40d9a775532ccca7b7b569" translate="yes" xml:space="preserve">
          <source>The mxFrame value is always greater than or equal to both &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; and nBackfillAttempted.</source>
          <target state="translated">mxFrame值始终大于或等于&lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt;和nBackfillAttempted。</target>
        </trans-unit>
        <trans-unit id="ab3c5c72a969cacdc78a3e4dd0229038bdf0e320" translate="yes" xml:space="preserve">
          <source>The mxPathname field is the maximum length of a file pathname that this VFS can use. SQLite sometimes has to preallocate buffers of this size, so it should be as small as reasonably possible. Some filesystems permit huge pathnames, but in practice pathnames rarely extend beyond 100 bytes or so. You do not have to put the longest pathname that the underlying filesystem can handle here. You only have to put the longest pathname that you want SQLite to be able to handle. A few hundred is a good value in most cases.</source>
          <target state="translated">mxPathname字段是这个VFS可以使用的文件路径名的最大长度。SQLite有时不得不预分配这个大小的缓冲区,所以它应该尽可能的小。有些文件系统允许使用巨大的路径名,但实际上路径名很少超过100字节左右。你不需要把底层文件系统能处理的最长路径名放在这里。你只需要输入你希望SQLite能够处理的最长路径名。在大多数情况下,几百个是一个不错的值。</target>
        </trans-unit>
        <trans-unit id="cb1334872e71aa02626433d46e5f9130af9a0bfd" translate="yes" xml:space="preserve">
          <source>The nArg parameter specifies the number of arguments to the function. A value of 0 indicates that any number of arguments is allowed. The eTextRep parameter specifies what representation text values are expected to be in for arguments to this function. The value of this parameter should be one of the parameters defined above. SQLite version 3 allows multiple implementations of the same function using different text representations. The database engine chooses the function that minimization the number of text conversions required.</source>
          <target state="translated">nArg参数指定函数的参数数。值为0表示允许任何数量的参数。eTextRep参数指定本函数参数的文本值应该用什么表示。这个参数的值应该是上面定义的参数之一。SQLite第3版允许同一个函数使用不同的文本表示方式进行多种实现。数据库引擎会选择能使所需的文本转换次数最小化的函数。</target>
        </trans-unit>
        <trans-unit id="15067be8341cb3e5ea308646b0092b9f585804c8" translate="yes" xml:space="preserve">
          <source>The nBackfill can only be increased while holding the WAL_CKPT_LOCK. However, nBackfill is changed to zero during a &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL reset&lt;/a&gt;, and this happens while holding the WAL_WRITE_LOCK.</source>
          <target state="translated">仅在保持WAL_CKPT_LOCK的同时增加nBackfill。但是，在&lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL重置&lt;/a&gt;过程中，nBackfill会更改为零，并且在保持WAL_WRITE_LOCK时会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="99673f4f335d79523c7b7494142bf07ba1cd84e2" translate="yes" xml:space="preserve">
          <source>The nBackfill number is never greater than &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt;. When nBackfill equals &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt;, that means that the WAL content has been completely written back into the database and it is ok to &lt;a href=&quot;fileformat2#walreset&quot;&gt;reset the WAL&lt;/a&gt; if there are no locks held on any of WAL_READ_LOCK(N) for N&amp;gt;0.</source>
          <target state="translated">nBackfill编号永远不会大于&lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt;。当nBackfill等于&lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame时&lt;/a&gt;，这意味着WAL内容已被完全写回到数据库中，并且如果N&amp;gt; 0的WAL_READ_LOCK（N）中没有任何锁，则可以&lt;a href=&quot;fileformat2#walreset&quot;&gt;重置WAL&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="58aea584e25c7551e85c617c6b8537adc3f19238" translate="yes" xml:space="preserve">
          <source>The name &quot;memsys5&quot; used for the zero-malloc memory allocator implies that there are several additional memory allocators available, and indeed there are. The default memory allocator is &quot;memsys1&quot;. The debugging memory allocator is &quot;memsys2&quot;. Those have already been covered.</source>
          <target state="translated">零内存分配器使用的名称 &quot;memsys5 &quot;意味着还有几个额外的内存分配器可用,事实上也有。默认的内存分配器是 &quot;memsys1&quot;。调试内存分配器是 &quot;memsys2&quot;。这些已经介绍过了。</target>
        </trans-unit>
        <trans-unit id="e00b973d0e23f6d37321209e23fc2917cf32700a" translate="yes" xml:space="preserve">
          <source>The name &quot;sqlite_schema&quot; does not appear anywhere in the file format. That name is just a convention used by the database implementation. Due to historical and operational considerations, the &quot;sqlite_schema&quot; table can also sometimes be called by one of the following aliases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5db0afbba9901c1e9e8534384d38571355c85857" translate="yes" xml:space="preserve">
          <source>The name for the &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; used to compare values in the index-column.</source>
          <target state="translated">&lt;a href=&quot;datatype3#collation&quot;&gt;整理序列&lt;/a&gt;的名称，用于比较索引列中的值。</target>
        </trans-unit>
        <trans-unit id="d0a42cf139ce30315511c41a36a93d913d4ae81d" translate="yes" xml:space="preserve">
          <source>The name of a result column is the value of the &quot;AS&quot; clause for that column, if there is an AS clause. If there is no AS clause then the name of the column is unspecified and may change from one release of SQLite to the next.</source>
          <target state="translated">如果有AS子句,那么结果列的名称就是该列的 &quot;AS &quot;子句的值。如果没有AS子句,那么该列的名称是未指定的,可能会随着SQLite的不同版本而改变。</target>
        </trans-unit>
        <trans-unit id="a57f858acf3d2e5077979e3afa2c8309985a2b90" translate="yes" xml:space="preserve">
          <source>The name of an SQLite database is the name of a file that will contain the database. If the file does not exist, SQLite attempts to create and initialize it. If the file is read-only (due to permission bits or because it is located on read-only media like a CD-ROM) then SQLite opens the database for reading only. The entire SQL database is stored in a single file on the disk. But additional temporary files may be created during the execution of an SQL command in order to store the database rollback journal or temporary and intermediate results of a query.</source>
          <target state="translated">SQLite数据库的名称是一个将包含数据库的文件的名称。如果文件不存在,SQLite会尝试创建并初始化它。如果文件是只读的(由于权限位或因为它位于CD-ROM等只读介质上),那么SQLite就会打开数据库进行只读。整个SQL数据库存储在磁盘上的一个文件中。但是在执行SQL命令的过程中可能会创建额外的临时文件,以便存储数据库回滚日志或查询的临时和中间结果。</target>
        </trans-unit>
        <trans-unit id="2e5f7637f527bcb85ea83184153ee4c57e5bbfca" translate="yes" xml:space="preserve">
          <source>The name of each column in the table.</source>
          <target state="translated">表中每一列的名称。</target>
        </trans-unit>
        <trans-unit id="e1e64668404efe0d041f261ba3d958b47753bba4" translate="yes" xml:space="preserve">
          <source>The name of the FTS5 table column that contains the term.</source>
          <target state="translated">包含术语的FTS5表列名称。</target>
        </trans-unit>
        <trans-unit id="fb2519166ef6466d94c575e04a046d25ae02cbef" translate="yes" xml:space="preserve">
          <source>The name of the collation is a UTF-8 string for sqlite3_create_collation() and sqlite3_create_collation_v2() and a UTF-16 string in native byte order for sqlite3_create_collation16(). Collation names that compare equal according to &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; are considered to be the same name.</source>
          <target state="translated">排序规则的名称是sqlite3_create_collat​​ion（）和sqlite3_create_collat​​ion_v2（）的UTF-8字符串，以及sqlite3_create_collat​​ion16（）的本地字节顺序的UTF-16字符串。根据&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp（）&lt;/a&gt;比较相等的排序规则名称被视为相同的名称。</target>
        </trans-unit>
        <trans-unit id="7df8bfa2bb01af5c880a238a6167d3b3a1623f37" translate="yes" xml:space="preserve">
          <source>The name of the collation is a UTF-8 string for sqlite3_create_collation() and sqlite3_create_collation_v2() and a UTF-16 string in native byte order for sqlite3_create_collation16(). Collation names that compare equal according to &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; are considered to be the same name.</source>
          <target state="translated">排序规则的名称是sqlite3_create_collat​​ion（）和sqlite3_create_collat​​ion_v2（）的UTF-8字符串，以及sqlite3_create_collat​​ion16（）的本地字节顺序的UTF-16字符串。根据&lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp（）&lt;/a&gt;比较相等的排序规则名称被视为相同的名称。</target>
        </trans-unit>
        <trans-unit id="60f9c38a5b1707739850b72dfb67adc25dbc2069" translate="yes" xml:space="preserve">
          <source>The name of the column being indexed, or NULL if the index-column is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the table being indexed or an &lt;a href=&quot;expridx&quot;&gt;expression&lt;/a&gt;.</source>
          <target state="translated">被索引列的名称；如果index-column是被索引表的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;或&lt;a href=&quot;expridx&quot;&gt;expression，&lt;/a&gt;则为NULL 。</target>
        </trans-unit>
        <trans-unit id="a2c4a68aabf0cd9d6847a72cb797a421605fdb66" translate="yes" xml:space="preserve">
          <source>The name of the column being indexed. This columns is NULL if the column is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; or an &lt;a href=&quot;expridx&quot;&gt;expression&lt;/a&gt;.</source>
          <target state="translated">被索引的列的名称。如果列是&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;或&lt;a href=&quot;expridx&quot;&gt;表达式，&lt;/a&gt;则此列为 NULL 。</target>
        </trans-unit>
        <trans-unit id="2755fad1da17fab976d4effee601e3a0ced598c2" translate="yes" xml:space="preserve">
          <source>The name of the column that contains the term instance.</source>
          <target state="translated">包含术语实例的列名。</target>
        </trans-unit>
        <trans-unit id="d4c672f643ac02f7fa3683763e45ddf698d1be4b" translate="yes" xml:space="preserve">
          <source>The name of the database is usually just the name of a disk file in which the database is stored. If the name of the database is the special name &quot;&lt;a href=&quot;inmemorydb&quot;&gt;:memory:&lt;/a&gt;&quot; then a new database is created in memory. If the name of the database is an empty string, then the database is created in an empty file that is automatically deleted when the database connection closes. &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; can be used if the &quot;&lt;b&gt;-uri yes&lt;/b&gt;&quot; option is supplied on the &lt;b&gt;sqlite3&lt;/b&gt; command.</source>
          <target state="translated">数据库的名称通常只是存储数据库的磁盘文件的名称。如果数据库名称是特殊名称&amp;ldquo; &lt;a href=&quot;inmemorydb&quot;&gt;：memory：&lt;/a&gt; &amp;rdquo;，则会在内存中创建一个新数据库。如果数据库名称是一个空字符串，那么将在一个空文件中创建数据库，该文件将在数据库连接关闭时自动删除。如果&lt;b&gt;sqlite3&lt;/b&gt;命令提供了&amp;ldquo; &lt;b&gt;-uri yes&lt;/b&gt; &amp;rdquo;选项，则可以使用&lt;a href=&quot;uri&quot;&gt;URI文件名&lt;/a&gt;。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="638ad72e8f8e6b978d1b5c7a5434bac446aa668c" translate="yes" xml:space="preserve">
          <source>The name of the database on which the transaction was committed</source>
          <target state="translated">进行交易的数据库名称;</target>
        </trans-unit>
        <trans-unit id="b53c39aeaa16a31f4a835cb5ee0c4ef2cb1c4ca7" translate="yes" xml:space="preserve">
          <source>The name of the database table,</source>
          <target state="translated">数据库表的名称。</target>
        </trans-unit>
        <trans-unit id="1389d8d4ecdcdbedac7a4549e6a07ae7ad0ad26c" translate="yes" xml:space="preserve">
          <source>The name of the database which is being changed</source>
          <target state="translated">正在更改的数据库名称</target>
        </trans-unit>
        <trans-unit id="fc047e5a2c9d6a845176aac031ed03d6a1b50ee2" translate="yes" xml:space="preserve">
          <source>The name of the desired tokenizer should be substituted in place of 'porter' in the example, of course. If the tokenizer requires one or more arguments, they should be separated by commas in the fts3tokenize declaration (even though they are separated by spaces in declarations of regular fts4 tables). The following creates fts4 and fts3tokenize tables that use the same tokenizer:</source>
          <target state="translated">当然,在本例中,需要用 tokenizer 的名称代替 'porter'。如果 tokenizer 需要一个或多个参数,那么在 fts3tokenize 声明中应该用逗号来分隔(尽管在常规的 fts4 表的声明中是用空格分隔的)。下面创建了使用相同 tokenizer 的 fts4 和 fts3tokenize 表。</target>
        </trans-unit>
        <trans-unit id="9a63a9136665984fc122cf635a36ad0166ead67d" translate="yes" xml:space="preserve">
          <source>The name of the index.</source>
          <target state="translated">索引的名称。</target>
        </trans-unit>
        <trans-unit id="c2412b63f15e8dfde7222fa76ad9e5504c06aea1" translate="yes" xml:space="preserve">
          <source>The name of the new table.</source>
          <target state="translated">新表的名称。</target>
        </trans-unit>
        <trans-unit id="a12d264e140fa64a7adf3172f5ec27d60bbcedb0" translate="yes" xml:space="preserve">
          <source>The name of the result column is a combination of the source table and source column name: TABLE.COLUMN</source>
          <target state="translated">结果列的名称是源表和源列名称的组合:TABLE.COLUMN。</target>
        </trans-unit>
        <trans-unit id="85777de7d38bf8fc5dfa8258c31af44f8a1c7698" translate="yes" xml:space="preserve">
          <source>The name of the table contains one or more &quot;_&quot; characters.</source>
          <target state="translated">表名包含一个或多个&quot;_&quot;字符。</target>
        </trans-unit>
        <trans-unit id="d14fb34ff4c810e0436eba6520cbeda0158f9e95" translate="yes" xml:space="preserve">
          <source>The name of the table data is read from.</source>
          <target state="translated">从表中读取数据的名称。</target>
        </trans-unit>
        <trans-unit id="a43b536a14c1d7b3d8b50ac0e9b44a83e9c467f9" translate="yes" xml:space="preserve">
          <source>The name of the table in which the xColumnSize values are stored (unless columnsize=0 is specified) is &quot;&amp;lt;name&amp;gt;_docsize&quot;, where &amp;lt;name&amp;gt; is the name of the FTS5 table itself. The &lt;a href=&quot;https://www.sqlite.org/download.html&quot;&gt;sqlite3_analyzer&lt;/a&gt; tool may be used on an existing database in order to determine how much space might be saved by recreating an FTS5 table using columnsize=0.</source>
          <target state="translated">存储xColumnSize值的表的名称（除非指定了columnize = 0）是&amp;ldquo; &amp;lt;名称&amp;gt; _docsize&amp;rdquo;，其中，&amp;lt;名称&amp;gt;是FTS5表本身的名称。该&lt;a href=&quot;https://www.sqlite.org/download.html&quot;&gt;sqlite3_analyzer&lt;/a&gt;工具可以在现有的数据库，以确定有多少空间可以通过重新使用columnsize = 0的FTS5表保存使用。</target>
        </trans-unit>
        <trans-unit id="ba455f33d978f1db1e5e1561024b5ab7e0845678" translate="yes" xml:space="preserve">
          <source>The name of the table or index that is implemented by the btree of the current row</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9dba3fb9b44494b1bade858ebafe1459aa85475" translate="yes" xml:space="preserve">
          <source>The name of the table to be modified in an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement must be an unqualified table name. In other words, one must use just &quot;</source>
          <target state="translated">要在&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;，&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;或&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;语句中修改的表的名称必须是非限定的表名称。换句话说，您只能使用&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="6e32ef9d959d1305ba25656ee3bbcec3b526eef2" translate="yes" xml:space="preserve">
          <source>The name that occurs after the AS keyword is the name of the database used internally by SQLite. The schema-names 'main' and 'temp' refer to the main database and the database used for temporary tables. The main and temp databases cannot be attached or detached.</source>
          <target state="translated">AS关键字后出现的名称是SQLite内部使用的数据库名称。模式名'main'和'temp'指的是主数据库和用于临时表的数据库。主数据库和临时数据库不能被附加或分离。</target>
        </trans-unit>
        <trans-unit id="c7f1793be68e4540903171531d569a4a7be0fbfa" translate="yes" xml:space="preserve">
          <source>The names and numeric values for existing result codes are fixed and unchanging. However, new result codes, and especially new extended result codes, might appear in future releases of SQLite.</source>
          <target state="translated">现有结果代码的名称和数值是固定不变的。但是,新的结果代码,特别是新的扩展结果代码,可能会出现在SQLite的未来版本中。</target>
        </trans-unit>
        <trans-unit id="6c186656572f2bf1670bbd5a3b99aeadd51bedda" translate="yes" xml:space="preserve">
          <source>The names of the columns are contained in first</source>
          <target state="translated">栏目名称包含在第一</target>
        </trans-unit>
        <trans-unit id="6e42a281800acf1a1a711bf3baf9388c4ecfa00b" translate="yes" xml:space="preserve">
          <source>The names returned are the original un-aliased names of the database, table, and column.</source>
          <target state="translated">返回的名称是数据库、表、列的原始无偏旁名称。</target>
        </trans-unit>
        <trans-unit id="9d972c129d1db380a40044755e84ee7d9ba4bda3" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface allows an application to customize the behavior of SQLite at run-time. Customizations possible using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; include the following:</source>
          <target state="translated">新的&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;接口允许应用程序在运行时自定义SQLite的行为。使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;可能进行的自定义包括以下内容：</target>
        </trans-unit>
        <trans-unit id="3df658c177f1eac56b80fa5f85864ebd817426dc" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt; interface allows an application to query the performance status of SQLite at runtime.</source>
          <target state="translated">新的&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status（）&lt;/a&gt;接口允许应用程序在运行时查询SQLite的性能状态。</target>
        </trans-unit>
        <trans-unit id="a8d3b04d8482aa6bd5d923ab36f6fdfe7a6ac1b9" translate="yes" xml:space="preserve">
          <source>The new API for SQLite 3.0 contains routines that accept text as both UTF-8 and UTF-16 in the native byte order of the host machine. Each database file manages text as either UTF-8, UTF-16BE (big-endian), or UTF-16LE (little-endian). Internally and in the disk file, the same text representation is used everywhere. If the text representation specified by the database file (in the file header) does not match the text representation required by the interface routines, then text is converted on-the-fly. Constantly converting text from one representation to another can be computationally expensive, so it is suggested that programmers choose a single representation and stick with it throughout their application.</source>
          <target state="translated">SQLite 3.0的新API包含了一些例程,这些例程可以接受文本为UTF-8和UTF-16,并以主机的本地字节顺序排列。每个数据库文件都以UTF-8、UTF-16BE(大字节)或UTF-16LE(小字节)的形式管理文本。在内部和磁盘文件中,到处都使用相同的文本表示法。如果数据库文件(在文件头)指定的文本表示法与接口例程所需的文本表示法不匹配,那么文本将被即时转换。不断地将文本从一种表示方式转换到另一种表示方式可能会造成计算成本,因此建议程序员选择一种单一的表示方式,并在整个应用程序中坚持使用它。</target>
        </trans-unit>
        <trans-unit id="30af4368149bbc60ce20946b58b7cfd9adb8ff97" translate="yes" xml:space="preserve">
          <source>The new OS interface for SQLite is built around an object named &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;. The &quot;vfs&quot; stands for &quot;Virtual File System&quot;. The sqlite3_vfs object is basically a structure containing pointers to functions that implement the primitive disk I/O operations that SQLite needs to perform in order to read and write databases. In this article, we will often refer to an sqlite3_vfs objects as a &quot;VFS&quot;.</source>
          <target state="translated">SQLite的新OS接口基于名为&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;的对象构建。&amp;ldquo; vfs&amp;rdquo;代表&amp;ldquo;虚拟文件系统&amp;rdquo;。sqlite3_vfs对象基本上是一个结构，其中包含指向函数的指针，这些函数实现SQLite为了读取和写入数据库而需要执行的原始磁盘I / O操作。在本文中，我们经常将sqlite3_vfs对象称为&amp;ldquo; VFS&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6c9ac7112282c02c3ac370e4792bfc347f1711f1" translate="yes" xml:space="preserve">
          <source>The new change is ignored. This case does not occur if the new changeset was recorded immediately after the changesets already added to the changegroup.</source>
          <target state="translated">新的变更被忽略。如果新的变更集是在已经添加到变更组的变更集之后立即记录的,这种情况不会发生。</target>
        </trans-unit>
        <trans-unit id="7b39e9d3e42d3852cda66bb7e7297a2f31d0e706" translate="yes" xml:space="preserve">
          <source>The new database connection will use the &quot;multi-thread&quot; &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt;. This means that separate threads are allowed to use SQLite at the same time, as long as each thread is using a different &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ff5fb06e02cb095d4456f9e428328e41689b42" translate="yes" xml:space="preserve">
          <source>The new database connection will use the &quot;multi-thread&quot; &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt;. This means that separate threads are allowed to use SQLite at the same time, as long as each thread is using a different &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed188f9846a7395326bff47f2223ddc25ac3eab" translate="yes" xml:space="preserve">
          <source>The new database connection will use the &quot;serialized&quot; &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt;. This means the multiple threads can safely attempt to use the same database connection at the same time. (Mutexes will block any actual concurrency, but in this mode there is no harm in trying.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2075b8f3b4c50de265f00054b0d87b23e094598" translate="yes" xml:space="preserve">
          <source>The new database connection will use the &quot;serialized&quot; &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt;. This means the multiple threads can safely attempt to use the same database connection at the same time. (Mutexes will block any actual concurrency, but in this mode there is no harm in trying.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ae31ac06c9efe8e8edfec9e13527250faad45f" translate="yes" xml:space="preserve">
          <source>The new database file format uses B+trees for tables. In a B+tree, all data is stored in the leaves of the tree instead of in both the leaves and the intermediate branch nodes. The use of B+trees for tables allows for better scalability and the storage of larger data fields without the use of overflow pages. Traditional B-trees are still used for indices.</source>
          <target state="translated">新的数据库文件格式使用B+树作为表。在B+树中,所有的数据都存储在树的叶子中,而不是同时存储在叶子和中间的分支节点中。表使用B+树可以实现更好的扩展性,并且可以存储更大的数据字段,而不需要使用溢出页。传统的B树仍然用于索引。</target>
        </trans-unit>
        <trans-unit id="31e91eb6ebd1ae009dff2061b0ed5da69f5f04a8" translate="yes" xml:space="preserve">
          <source>The new file format also supports variable pages sizes between 512 and 65536 bytes. The size of a page is stored in the file header so the same library can read databases with different pages sizes, in theory, though this feature has not yet been implemented in practice.</source>
          <target state="translated">新的文件格式还支持512到65536字节之间的可变页面大小。页面的大小存储在文件头中,因此理论上同一库可以读取不同页面大小的数据库,尽管这一功能尚未在实践中实现。</target>
        </trans-unit>
        <trans-unit id="b7b98e36d84deeda55906998dc0425a8e896c821" translate="yes" xml:space="preserve">
          <source>The new file format omits unused fields from its disk images. For example, indices use only the key part of a B-tree record and not the data. So for indices, the field that records the length of the data is omitted. Integer values such as the length of key and data are stored using a variable-length encoding so that only one or two bytes are required to store the most common cases but up to 64-bits of information can be encoded if needed. Integer and floating point data is stored on the disk in binary rather than being converted into ASCII as in SQLite version 2.8. These changes taken together result in database files that are typically 25% to 35% smaller than the equivalent files in SQLite version 2.8.</source>
          <target state="translated">新的文件格式从其磁盘图像中省略了未使用的字段。例如,索引只使用B树记录的关键部分,而不使用数据。所以对于索引,记录数据长度的字段被省略。整数值如键的长度和数据的长度使用可变长度的编码来存储,所以在最常见的情况下只需要存储一个或两个字节,但如果需要的话,可以对最多64位的信息进行编码。整数和浮点数据以二进制方式存储在磁盘上,而不是像SQLite 2.8版本那样转换成ASCII。这些变化加在一起的结果是,数据库文件通常比SQLite 2.8版本中的同等文件小25%到35%。</target>
        </trans-unit>
        <trans-unit id="5a8ddfc73fc040315222214bdfe8a3558fe0da52" translate="yes" xml:space="preserve">
          <source>The new interface uses three separate functions to replace the single &lt;b&gt;sqlite_exec&lt;/b&gt; function.</source>
          <target state="translated">新接口使用三个单独的函数来替换单个&lt;b&gt;sqlite_exec&lt;/b&gt;函数。</target>
        </trans-unit>
        <trans-unit id="601cb56433c850ed70120e223ec644602fc957a5" translate="yes" xml:space="preserve">
          <source>The new object is configured with the rebase buffer obtained from sqlite3changeset_apply_v2() by calling sqlite3rebaser_configure(). If the local changeset is to be rebased against multiple remote changesets, then sqlite3rebaser_configure() should be called multiple times, in the same order that the multiple sqlite3changeset_apply_v2() calls were made.</source>
          <target state="translated">通过调用sqlite3rebaser_configure(),用从sqlite3changeset_apply_v2()获得的重基缓冲区配置新对象。如果本地变化集要针对多个远程变化集进行重基,那么sqlite3rebaser_configure()应该被多次调用,调用顺序与多次调用sqlite3changeset_apply_v2()的顺序相同。</target>
        </trans-unit>
        <trans-unit id="a80319826820a0baa113ed82a7da25195888339a" translate="yes" xml:space="preserve">
          <source>The new row must meet the same criteria as for &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; - it must exist and there must be either a blob or text value stored in the nominated column. If the new row is not present in the table, or if it does not contain a blob or text value, or if another error occurs, an SQLite error code is returned and the blob handle is considered aborted. All subsequent calls to &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; on an aborted blob handle immediately return SQLITE_ABORT. Calling &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; on an aborted blob handle always returns zero.</source>
          <target state="translated">新行必须满足与&lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open（）&lt;/a&gt;相同的条件- 新行必须存在，并且被提名列中必须存储有blob或text值。如果表中不存在新行，或者其中不包含Blob或文本值，或者发生其他错误，则返回SQLite错误代码，并且Blob句柄被视为中止。在中断的Blob句柄上对&lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen（）的&lt;/a&gt;所有后续调用都立即返回SQLITE_ABORT。在&lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;异常&lt;/a&gt;终止的Blob句柄上调用sqlite3_blob_bytes（）始终返回零。</target>
        </trans-unit>
        <trans-unit id="1fc9db87ef5146974ffc63aaf19ef4d76ed16ccc" translate="yes" xml:space="preserve">
          <source>The new row must meet the same criteria as for &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; - it must exist and there must be either a blob or text value stored in the nominated column. If the new row is not present in the table, or if it does not contain a blob or text value, or if another error occurs, an SQLite error code is returned and the blob handle is considered aborted. All subsequent calls to &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; or &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; on an aborted blob handle immediately return SQLITE_ABORT. Calling &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; on an aborted blob handle always returns zero.</source>
          <target state="translated">新行必须满足与&lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open（）&lt;/a&gt;相同的条件- 新行必须存在，并且被提名列中必须存储有blob或text值。如果表中不存在新行，或者其中不包含Blob或文本值，或者发生其他错误，则返回SQLite错误代码，并且Blob句柄被视为中止。在中断的Blob句柄上对&lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;，&lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;或&lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen（）的&lt;/a&gt;所有后续调用都立即返回SQLITE_ABORT。在&lt;a href=&quot;blob_bytes&quot;&gt;异常&lt;/a&gt;终止的Blob句柄上调用sqlite3_blob_bytes（）始终返回零。</target>
        </trans-unit>
        <trans-unit id="477dc8c1b42a8f1f1f9e215976276669879cbe40" translate="yes" xml:space="preserve">
          <source>The new values for each modified field of the row, and</source>
          <target state="translated">行中每个修改后的字段的新值,以及</target>
        </trans-unit>
        <trans-unit id="9ca11824ed5a21754d9f34df6fca6bca218bd35f" translate="yes" xml:space="preserve">
          <source>The new window definition must not include a PARTITION BY clause. The PARTITION BY clause, if there is one, must be supplied by the base window specification.</source>
          <target state="translated">新窗口定义不得包含 PARTITION BY 子句。如果有PARTITION BY子句,则必须由基本窗口规范提供。</target>
        </trans-unit>
        <trans-unit id="f3a9a1d6f9268d0f1362c9fb457875a7fb250370" translate="yes" xml:space="preserve">
          <source>The newer &quot;.eqp trace&quot; command does everything that &quot;.eqp full&quot; does and also turns on &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;VDBE tracing&lt;/a&gt;.</source>
          <target state="translated">较新的&amp;ldquo; .eqp trace&amp;rdquo;命令执行&amp;ldquo; .eqp full&amp;rdquo;所做的所有操作，并且还打开了&lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;VDBE跟踪&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd8ed5a57b50230eec8d4ec2e3e5c1e149c55cc8" translate="yes" xml:space="preserve">
          <source>The newer xQueryFunc callback receives more information from the r-tree query engine on each call, and it sends more information back to the query engine before it returns. To help keep the interface manageable, the xQueryFunc callback sends and receives information from the query engine as fields in the sqlite3_rtree_query_info structure:</source>
          <target state="translated">较新的xQueryFunc回调在每次调用时都会从r-tree查询引擎接收更多的信息,并且在返回之前会将更多的信息发回给查询引擎。为了帮助保持接口的可管理性,xQueryFunc回调以sqlite3_rtree_query_info结构中的字段形式发送和接收来自查询引擎的信息。</target>
        </trans-unit>
        <trans-unit id="03223a32a94905afaa2e599c575bdc7c618a776e" translate="yes" xml:space="preserve">
          <source>The next &quot;.mode&quot; command will reset the &quot;.separator&quot; back to its default. So you will need repeat the &quot;.separator&quot; command whenever you change modes if you want to continue using a non-standard separator.</source>
          <target state="translated">下一个&quot;.mode &quot;命令会将&quot;.separator &quot;重置为默认值。因此,如果你想继续使用非标准的分隔符,你需要在每次改变模式时重复使用&quot;.separator &quot;命令。</target>
        </trans-unit>
        <trans-unit id="9bff369a4e5022b3604d755cd856a8cb8591c715" translate="yes" xml:space="preserve">
          <source>The next block contains an example rank function that uses matchinfo data implemented in C. Instead of a single weight, it allows a weight to be externally assigned to each column of each document. It may be registered with SQLite like any other user function using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function&lt;/a&gt;.</source>
          <target state="translated">下一个块包含一个示例等级函数，该函数使用在C中实现的matchinfo数据。它允许将权重从外部分配给每个文档的每一列，而不是单个权重。可以像其他任何使用&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function的&lt;/a&gt;用户函数一样，将其注册到SQLite 。</target>
        </trans-unit>
        <trans-unit id="5e308fd7498285ea1f61e243e9d3f001701f643f" translate="yes" xml:space="preserve">
          <source>The next block of SQL enhances the query with solutions to two other problems that may arise in developing search applications using FTS:</source>
          <target state="translated">接下来的SQL块通过解决使用FTS开发搜索应用程序时可能出现的另外两个问题来增强查询。</target>
        </trans-unit>
        <trans-unit id="acd253e5152192f86ab636fd16bb5196034aa10b" translate="yes" xml:space="preserve">
          <source>The next chart compares SQLite database updates in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; against raw direct-to-disk overwrites of separate files on disk. The &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting is NORMAL. All database writes are in a single transaction. The timer for the database writes is stopped after the transaction commits, but before a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; is run. Note that the SQLite writes, unlike the direct-to-disk writes, are &lt;a href=&quot;transactional&quot;&gt;transactional&lt;/a&gt; and &lt;a href=&quot;transactional&quot;&gt;power-safe&lt;/a&gt;, though because the synchronous setting is NORMAL instead of FULL, the transactions are not durable.</source>
          <target state="translated">下一张图表将&lt;a href=&quot;wal&quot;&gt;WAL模式下的&lt;/a&gt; SQLite数据库更新与磁盘上单独文件的原始直接磁盘覆盖进行了比较。该&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt;设置为正常。所有数据库写入都在单个事务中。在事务提交之后但在运行&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;之前，数据库写计时器将停止。请注意，与直接磁盘写入不同，SQLite写入具有&lt;a href=&quot;transactional&quot;&gt;事务性&lt;/a&gt;和&lt;a href=&quot;transactional&quot;&gt;电源安全性&lt;/a&gt;，但是由于同步设置为NORMAL而不是FULL，因此事务不持久。</target>
        </trans-unit>
        <trans-unit id="0aae132ea98563594c1fa5eb1b5277ade35e9e0f" translate="yes" xml:space="preserve">
          <source>The next chart shows the performance of SQLite versus direct-to-disk when transactions are disabled (&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt;) and &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; is set to OFF. These settings put SQLite on an equal footing with direct-to-disk writes, which is to say they make the data prone to corruption due to system crashes and power failures.</source>
          <target state="translated">下一张图表显示了禁用事务（&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = OFF&lt;/a&gt;）并将&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA sync&lt;/a&gt;设置为OFF 时，SQLite与直接磁盘的性能。这些设置使SQLite在磁盘直接写入方面处于平等的地位，也就是说，由于系统崩溃和电源故障，它们使数据易于损坏。</target>
        </trans-unit>
        <trans-unit id="a36fc6db6d371099515d1fcc0740a7c0b2437b14" translate="yes" xml:space="preserve">
          <source>The next example demonstrates lag(), lead(), first_value(), last_value() and nth_value(). The frame-spec is ignored by both lag() and lead(), but respected by first_value(), last_value() and nth_value().</source>
          <target state="translated">下一个例子演示了lag()、lead()、first_value()、last_value()和nth_value()。lag()和lead()都会忽略frame-spec,但first_value()、last_value()和nth_value()会尊重它。</target>
        </trans-unit>
        <trans-unit id="edb143346c38b864be88a8c33e46d2997195abb0" translate="yes" xml:space="preserve">
          <source>The next example uses two common table expressions in a single WITH clause. The following table records a family tree:</source>
          <target state="translated">下一个例子在一个WITH子句中使用了两个常见的表表达式。下面的表记录了一个家庭树。</target>
        </trans-unit>
        <trans-unit id="1e6dfc599524aaa9c044c52fd99b0a8ed104813e" translate="yes" xml:space="preserve">
          <source>The next interface routine to SQLite is a convenience function used to test whether or not a string forms a complete SQL statement. If the &lt;b&gt;sqlite_complete&lt;/b&gt; function returns true when its input is a string, then the argument forms a complete SQL statement. There are no guarantees that the syntax of that statement is correct, but we at least know the statement is complete. If &lt;b&gt;sqlite_complete&lt;/b&gt; returns false, then more text is required to complete the SQL statement.</source>
          <target state="translated">SQLite的下一个接口例程是一个便捷函数，用于测试字符串是否形成完整的SQL语句。如果&lt;b&gt;sqlite_complete&lt;/b&gt;函数的输入为字符串时返回true，则该参数形成完整的SQL语句。不能保证该语句的语法正确，但是我们至少知道该语句是完整的。如果&lt;b&gt;sqlite_complete&lt;/b&gt;返回false，则需要更多文本来完成SQL语句。</target>
        </trans-unit>
        <trans-unit id="c0fe3b1ebf5cdcafa2a519a22d91d50cf98645d3" translate="yes" xml:space="preserve">
          <source>The next step in a multi-file commit is the creation of a &quot;master journal&quot; file. The name of the master journal file is the same name as the original database filename (the database that was opened using the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; interface, not one of the &lt;a href=&quot;lang_attach&quot;&gt;ATTACHed&lt;/a&gt; auxiliary databases) with the text &quot;&lt;b&gt;-mj&lt;/b&gt;</source>
          <target state="translated">多文件提交的下一步是创建&amp;ldquo;主日志&amp;rdquo;文件。主日志文件的名称与原始数据库文件名（使用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;接口打开的数据库，不是&lt;a href=&quot;lang_attach&quot;&gt;ATTACHed&lt;/a&gt;辅助数据库之一）打开的文本&lt;b&gt;名称相同&lt;/b&gt;，且文本为&amp;ldquo; &lt;b&gt;-mj&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0cd61740e94e70cec25ceb66f34763d5696dff28" translate="yes" xml:space="preserve">
          <source>The next step in a multi-file commit is the creation of a &quot;super-journal&quot; file. The name of the super-journal file is the same name as the original database filename (the database that was opened using the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; interface, not one of the &lt;a href=&quot;lang_attach&quot;&gt;ATTACHed&lt;/a&gt; auxiliary databases) with the text &quot;&lt;b&gt;-mj&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3da089b39e9e2681938268cb3d32b250cde300bb" translate="yes" xml:space="preserve">
          <source>The next step is to delete the master journal file. This is the point where the multi-file transaction commits. This step corresponds to &lt;a href=&quot;#section_3_11&quot;&gt;step 3.11&lt;/a&gt; in the single-file commit scenario where the rollback journal is deleted.</source>
          <target state="translated">下一步是删除主日记文件。这就是提交多文件事务的地方。在删除回滚日志的单文件提交方案中，此步骤对应于&lt;a href=&quot;#section_3_11&quot;&gt;步骤3.11&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8eca8d6f0301fd62dd1a522a60a7179d3923b8b3" translate="yes" xml:space="preserve">
          <source>The next step is to delete the super-journal file. This is the point where the multi-file transaction commits. This step corresponds to &lt;a href=&quot;#section_3_11&quot;&gt;step 3.11&lt;/a&gt; in the single-file commit scenario where the rollback journal is deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f8a36a95656f30638f07c12cb9da14410f8f263" translate="yes" xml:space="preserve">
          <source>The next step is to flush the content of the rollback journal file to nonvolatile storage. As we will see later, this is a critical step in insuring that the database can survive an unexpected power loss. This step also takes a lot of time, since writing to nonvolatile storage is normally a slow operation.</source>
          <target state="translated">下一步是将回滚日志文件的内容刷新到非易失性存储中。正如我们稍后将看到的那样,这是保证数据库能够在意外断电的情况下生存的关键一步。这一步也需要大量的时间,因为向非易失性存储中写入内容通常是一个缓慢的操作。</target>
        </trans-unit>
        <trans-unit id="2d76b37ca4cb1c2c8f635e9aaada12e5312b553c" translate="yes" xml:space="preserve">
          <source>The next step is to move the changes in the public branch over into the private branch. In other words, we want to create circle (5) in the diagram above. Begin by changing to the private branch using &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot;. Then type this command:</source>
          <target state="translated">下一步是将公共分支中的更改移到私有分支中。换句话说，我们要在上图中创建圆（5）。首先使用&amp;ldquo; &lt;code&gt;fossil update private&lt;/code&gt; &amp;rdquo; 更改为私有分支。然后键入以下命令：</target>
        </trans-unit>
        <trans-unit id="7e4259fddae0dc878cdf5dde573b08c0dee99991" translate="yes" xml:space="preserve">
          <source>The next step is to record the full pathname of the master journal file in the header of every rollback journal. Space to hold the master journal filename was reserved at the beginning of each rollback journal as the rollback journals were created.</source>
          <target state="translated">下一步是将主日志文件的完整路径名记录在每个回滚日志的页眉中。在创建回滚日记本时,每个回滚日记本的开头都预留了存放主日记本文件名的空间。</target>
        </trans-unit>
        <trans-unit id="75cf4af1420a93693d3db893fcca12c3f40102cd" translate="yes" xml:space="preserve">
          <source>The next step is to record the full pathname of the super-journal file in the header of every rollback journal. Space to hold the super-journal filename was reserved at the beginning of each rollback journal as the rollback journals were created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10799d0f2a52185a80b7f98059fdd7fef8ba0412" translate="yes" xml:space="preserve">
          <source>The next three bytes in the header record the number of vertexes in the polygon as a big-endian integer. Thus there is an upper bound of about 16 million vertexes per polygon.</source>
          <target state="translated">头部的三个字节记录了多边形中的顶点数量,是一个大安字节的整数,因此每个多边形的顶点数量上限是1600万。因此,每个多边形的顶点数上限为1600万。</target>
        </trans-unit>
        <trans-unit id="a4532dd188d90322b7de7cb35c04fd5fcf2e6593" translate="yes" xml:space="preserve">
          <source>The next use of the &lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt; or &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; or &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; instruction for P1 will refer to the first entry in the database table or index. If the table or index is empty, jump immediately to P2. If the table or index is not empty, fall through to the following instruction.</source>
          <target state="translated">P1 的&lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt;或&lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt;或&lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;指令的下一次使用将引用数据库表或索引中的第一个条目。如果表或索引为空，请立即跳至P2。如果表或索引不为空，请执行以下指令。</target>
        </trans-unit>
        <trans-unit id="db275badbcaa5bbb5c1ecd5830883705763b811b" translate="yes" xml:space="preserve">
          <source>The next use of the &lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt; or &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; or &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; instruction for P1 will refer to the last entry in the database table or index. If the table or index is empty and P2&amp;gt;0, then jump immediately to P2. If P2 is 0 or if the table or index is not empty, fall through to the following instruction.</source>
          <target state="translated">P1 的&lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt;或&lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt;或&lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;指令的下一次使用将引用数据库表或索引中的最后一个条目。如果表或索引为空并且P2&amp;gt; 0，则立即跳转到P2。如果P2为0，或者表或索引不为空，请执行以下指令。</target>
        </trans-unit>
        <trans-unit id="971bdad47f863dca0857c6853816fdb36613779f" translate="yes" xml:space="preserve">
          <source>The no-op memory allocator is not useful by itself. It exists only as a placeholder so that SQLite has a memory allocator to link against on systems that may not have malloc(), free(), or realloc() in their standard library. An application that is compiled with &lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt; will need to use &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; together with &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; or &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; to specify a new alternative memory allocator before beginning to use SQLite.</source>
          <target state="translated">无操作内存分配器本身没有用。它仅作为占位符存在，因此SQLite可以在其标准库中可能没有malloc（），free（）或realloc（）的系统上链接一个内存分配器。在开始使用SQLite之前，使用&lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt;编译的应用程序将需要与&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;或&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;一起使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;来指定新的备用内存分配器。</target>
        </trans-unit>
        <trans-unit id="fa03e3271f78c25f5482177efc3b575ee4cb93ab" translate="yes" xml:space="preserve">
          <source>The nolock query parameter is a boolean that disables all calls to the xLock, xUnlock, and xCheckReservedLock methods of the VFS when true. The nolock query parameter might be used, for example, when trying to access a file on a filesystem that does not support file locking. Caution: If two or more &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; try to interact with the same SQLite database and one or more of those connections has enabled &quot;nolock&quot;, then database corruption can result. The &quot;nolock&quot; query parameter should only be used if the application can guarantee that writes to the database are serialized.</source>
          <target state="translated">nolock查询参数是一个布尔值，当为true时，它将禁用对VFS的xLock，xUnlock和xCheckReservedLock方法的所有调用。例如，当尝试访问不支持文件锁定的文件系统上的文件时，可以使用nolock查询参数。警告：如果两个或多个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;尝试与同一个SQLite数据库进行交互，并且其中一个或多个连接启用了&amp;ldquo; nolock&amp;rdquo;，则可能导致数据库损坏。仅当应用程序可以保证对数据库的写操作已序列化时，才应使用&amp;ldquo; nolock&amp;rdquo;查询参数。</target>
        </trans-unit>
        <trans-unit id="b327cb7b48d6db3fd953f98055ad0798aba25bf9" translate="yes" xml:space="preserve">
          <source>The normal ROWID selection algorithm described above will generate monotonically increasing unique ROWIDs as long as you never use the maximum ROWID value and you never delete the entry in the table with the largest ROWID. If you ever delete rows or if you ever create a row with the maximum possible ROWID, then ROWIDs from previously deleted rows might be reused when creating new rows and newly created ROWIDs might not be in strictly ascending order.</source>
          <target state="translated">只要你从不使用最大的ROWID值,也从不删除表中具有最大ROWID的条目,上面描述的正常ROWID选择算法就会产生单调增加的唯一ROWID。如果你曾经删除过行,或者你曾经用最大可能的ROWID创建过行,那么在创建新行时,以前删除的行的ROWID可能会被重新使用,而且新创建的ROWID可能不会严格按照升序排列。</target>
        </trans-unit>
        <trans-unit id="dd6fdcceb1d1ed51baa294f01d457a9007d5dbff" translate="yes" xml:space="preserve">
          <source>The notindexed= option is not available. Adding &lt;a href=&quot;fts5#the_unindexed_column_option&quot;&gt;UNINDEXED&lt;/a&gt; to the column definition is equivalent.</source>
          <target state="translated">notindexed =选项不可用。将&lt;a href=&quot;fts5#the_unindexed_column_option&quot;&gt;UNINDEXED&lt;/a&gt;添加到列定义是等效的。</target>
        </trans-unit>
        <trans-unit id="e15aca005b3d3fc4e0be53d1a5e363f5a459da35" translate="yes" xml:space="preserve">
          <source>The nullif(X,Y) function returns its first argument if the arguments are different and NULL if the arguments are the same. The nullif(X,Y) function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If neither argument to nullif() defines a collating function then the BINARY is used.</source>
          <target state="translated">如果参数不同,nullif(X,Y)函数返回第一个参数,如果参数相同,则返回NULL。nullif(X,Y)函数从左到右搜索它的参数,寻找一个定义了整理函数的参数,并使用这个整理函数进行所有的字符串比较。如果nullif()的两个参数都没有定义整理函数,则使用BINARY。</target>
        </trans-unit>
        <trans-unit id="0d33dbf967cc9fffb2bcf5f7dd0e676a56e0fe27" translate="yes" xml:space="preserve">
          <source>The number of arguments to a function is sometimes stored in a signed character. So there is a hard upper bound on SQLITE_MAX_FUNCTION_ARG of 127.</source>
          <target state="translated">一个函数的参数数有时会用一个符号字符来存储。所以SQLITE_MAX_FUNCTION_ARG有一个硬性的上限,为127。</target>
        </trans-unit>
        <trans-unit id="22855456991124f9a63a13f70b4de30a07b1a44f" translate="yes" xml:space="preserve">
          <source>The number of characters in cFrom and cTo do not need to be the same. The rule above says that &quot;ss&quot; on user input will match &quot;&amp;szlig;&quot; with a penalty of 8.</source>
          <target state="translated">cFrom和cTo中的字符数不必相同。上面的规则说，用户输入上的&amp;ldquo; ss&amp;rdquo;将与&amp;ldquo;&amp;szlig;&amp;rdquo;匹配，惩罚为8。</target>
        </trans-unit>
        <trans-unit id="1dc8b6de1e412ad3d4600fff75a5432b18cfae89" translate="yes" xml:space="preserve">
          <source>The number of columns in a table</source>
          <target state="translated">表格中的列数</target>
        </trans-unit>
        <trans-unit id="c449227bed7d73e21c9772a435303abb6080e61e" translate="yes" xml:space="preserve">
          <source>The number of columns in a table is limited by the &lt;a href=&quot;limits#max_column&quot;&gt;SQLITE_MAX_COLUMN&lt;/a&gt; compile-time parameter. A single row of a table cannot store more than &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; bytes of data. Both of these limits can be lowered at runtime using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; C/C++ interface.</source>
          <target state="translated">表中的列数受&lt;a href=&quot;limits#max_column&quot;&gt;SQLITE_MAX_COLUMN&lt;/a&gt;编译时参数的限制。表的一行不能存储超过&lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;个字节的数据。使用&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit（）&lt;/a&gt; C / C ++接口可以在运行时降低这两个限制。</target>
        </trans-unit>
        <trans-unit id="8a6392262a1b2aadeab5c7954067326f2acb3a1d" translate="yes" xml:space="preserve">
          <source>The number of columns in a view</source>
          <target state="translated">视图中的列数</target>
        </trans-unit>
        <trans-unit id="7da1c90b5d954b64a1a4a566749d8c554741462e" translate="yes" xml:space="preserve">
          <source>The number of columns in an index</source>
          <target state="translated">索引中的列数</target>
        </trans-unit>
        <trans-unit id="155a4bbdc3161555e0a5db3b049b1a9960793a80" translate="yes" xml:space="preserve">
          <source>The number of columns in each row returned by the SELECT statement (if any) and the specific values returned have no effect on the results of the EXISTS operator. In particular, rows containing NULL values are not handled any differently from rows without NULL values.</source>
          <target state="translated">SELECT语句返回的每行中的列数(如果有的话)和返回的具体值对EXISTS操作符的结果没有影响。特别是,包含NULL值的行与不包含NULL值的行的处理方式没有任何区别。</target>
        </trans-unit>
        <trans-unit id="b33773d9bb8fcd548b7aa9142e9dd252802d3ebf" translate="yes" xml:space="preserve">
          <source>The number of columns in the result set of a SELECT statement</source>
          <target state="translated">SELECT语句的结果集中的列数。</target>
        </trans-unit>
        <trans-unit id="5962dbc1c4fa716686ee3f9c370159a83fff2488" translate="yes" xml:space="preserve">
          <source>The number of columns in the rows returned by a simple SELECT statement is equal to the number of expressions in the result expression list after substitution of * and alias.* expressions. Each result row is calculated by evaluating the expressions in the result expression list with respect to a single row of input data or, for aggregate queries, with respect to a group of rows.</source>
          <target state="translated">一个简单的SELECT语句返回的行中的列数等于结果表达式列表中替换*和别名.*表达式后的表达式数。每条结果行都是通过评估结果表达式列表中关于单行输入数据的表达式来计算的,或者,对于汇总查询来说,是关于一组行的表达式。</target>
        </trans-unit>
        <trans-unit id="efcaef0127aaba4759abf4c43138ceabba69a62b" translate="yes" xml:space="preserve">
          <source>The number of columns in the table, and</source>
          <target state="translated">表中的列数,以及</target>
        </trans-unit>
        <trans-unit id="ec4b9441464f8df5d1135d79fc696ff2d27c10ef" translate="yes" xml:space="preserve">
          <source>The number of columns the table has, and</source>
          <target state="translated">表的列数,以及</target>
        </trans-unit>
        <trans-unit id="f71fcd9bd24f5e705202e8ea9d15f75d827b7073" translate="yes" xml:space="preserve">
          <source>The number of entries in the write-ahead log (WAL) file for that database</source>
          <target state="translated">该数据库的写前日志(WAL)文件中的条目数。</target>
        </trans-unit>
        <trans-unit id="146718a82c006ef871da6bc05817a225f7435b26" translate="yes" xml:space="preserve">
          <source>The number of fields in this row.</source>
          <target state="translated">本行的字段数。</target>
        </trans-unit>
        <trans-unit id="049187119aa733be135d042e46c0767e81dbbd57" translate="yes" xml:space="preserve">
          <source>The number of freelist pages is stored as a 4-byte big-endian integer in the database header at an offset of 36 from the beginning of the file. The database header also stores the page number of the first freelist trunk page as a 4-byte big-endian integer at an offset of 32 from the beginning of the file.</source>
          <target state="translated">自由列表的页数在数据库头中以4字节的大字节整数形式存储,偏移量为36,从文件的开头开始。数据库头也将第一个自由列表主干页的页数作为一个4字节的大字节整数存储在文件开头的32个偏移量中。</target>
        </trans-unit>
        <trans-unit id="297412af9b640397abb6b05573031f719033bedb" translate="yes" xml:space="preserve">
          <source>The number of matchable phrases in the query.</source>
          <target state="translated">查询中可匹配的短语数量。</target>
        </trans-unit>
        <trans-unit id="96242742547a237955f6f616dd7a1536e46de1dc" translate="yes" xml:space="preserve">
          <source>The number of open read-transactions on the shared-cache drops to zero.</source>
          <target state="translated">共享缓存上开放的读交易数量降为零。</target>
        </trans-unit>
        <trans-unit id="140866849ab31e765e1dcf46dadf93357615ced1" translate="yes" xml:space="preserve">
          <source>The number of registers in a single prepared statement is fixed at compile-time. The content of all registers is cleared when a prepared statement is &lt;a href=&quot;c3ref/reset&quot;&gt;reset&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt;.</source>
          <target state="translated">单个准备好的语句中的寄存器数量在编译时是固定的。当&lt;a href=&quot;c3ref/reset&quot;&gt;重置&lt;/a&gt;或&lt;a href=&quot;c3ref/finalize&quot;&gt;结束&lt;/a&gt;准备好的语句时，将清除所有寄存器的内容。</target>
        </trans-unit>
        <trans-unit id="4967dccc017338cead0491dfe60a2adb347e1af4" translate="yes" xml:space="preserve">
          <source>The number of rows in a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES clause&lt;/a&gt; is no longer limited by &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_select#values&quot;&gt;VALUES子句中&lt;/a&gt;的行数不再受&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT的&lt;/a&gt;限制。</target>
        </trans-unit>
        <trans-unit id="36747c7623716448e27a5f87c9f1a06587b9fa71" translate="yes" xml:space="preserve">
          <source>The number of rows in the FTS4 table. This value is only available when querying FTS4 tables, not FTS3.</source>
          <target state="translated">FTS4表中的行数。该值仅在查询FTS4表时可用,而非FTS3表。</target>
        </trans-unit>
        <trans-unit id="e61b9ea13ff6553c9d51a6610c8145f4cf2adbcc" translate="yes" xml:space="preserve">
          <source>The number of rows in the FTS5 table for which column $col contains at least one instance of the term.</source>
          <target state="translated">FTS5表中$col列至少包含一个术语实例的行数。</target>
        </trans-unit>
        <trans-unit id="05c84b067bb80eadabe7075383b96e16df1c5aad" translate="yes" xml:space="preserve">
          <source>The number of rows that contain at least one instance of the term.</source>
          <target state="translated">至少包含一个术语实例的行数。</target>
        </trans-unit>
        <trans-unit id="32422ea0ce2f612eaf439b2072fddd2d97242e6b" translate="yes" xml:space="preserve">
          <source>The number of system calls for filesystem operations is reduced, possibly resulting in a small performance increase.</source>
          <target state="translated">减少了系统对文件系统操作的调用次数,可能导致性能小幅提升。</target>
        </trans-unit>
        <trans-unit id="e6551507f016b4d4b5fee98e7304b5666b04c04e" translate="yes" xml:space="preserve">
          <source>The number of terms in a GROUP BY or ORDER BY clause</source>
          <target state="translated">GROUP BY或ORDER BY子句中术语的数量。</target>
        </trans-unit>
        <trans-unit id="1c91b565cbe9942030a8129bf45c560b0a7de90f" translate="yes" xml:space="preserve">
          <source>The number of terms in the SET clause of an UPDATE statement</source>
          <target state="translated">UPDATE语句的SET子句中的术语数。</target>
        </trans-unit>
        <trans-unit id="70c8732a507183c03eb179514303045a0317c738" translate="yes" xml:space="preserve">
          <source>The number of the current row's peer group within its partition - the rank of the current row without gaps. Partitions are numbered starting from 1 in the order defined by the ORDER BY clause in the window definition. If there is no ORDER BY clause, then all rows are considered peers and this function always returns 1.</source>
          <target state="translated">当前行的对等组在其分区内的编号--当前行的等级,没有空隙。分区按照窗口定义中的ORDER BY子句定义的顺序从1开始编号。如果没有ORDER BY子句,那么所有的行都被认为是对等组,这个函数总是返回1。</target>
        </trans-unit>
        <trans-unit id="19450a48e3be402fdbd06d100d558662cd52a063" translate="yes" xml:space="preserve">
          <source>The number of the row within the current partition. Rows are numbered starting from 1 in the order defined by the ORDER BY clause in the window definition, or in arbitrary order otherwise.</source>
          <target state="translated">当前分区中行的编号。按照窗口定义中的ORDER BY子句定义的顺序,从1开始给行编号,否则按照任意顺序编号。</target>
        </trans-unit>
        <trans-unit id="4dd0d77e2a923847446dbf60b3f48736890bd6ba" translate="yes" xml:space="preserve">
          <source>The number of user defined columns in the FTS table (i.e. not including the docid or the &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt;).</source>
          <target state="translated">FTS表中用户定义的列数（即，不包括docid或&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS隐藏列&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ec04163c2280ea8f1f3a4d1db55ac34599bd6c09" translate="yes" xml:space="preserve">
          <source>The number of values in an INSERT statement</source>
          <target state="translated">INSERT语句中的值的数量</target>
        </trans-unit>
        <trans-unit id="0c5896381d0db64fdbbf15f25aac8c07347171d8" translate="yes" xml:space="preserve">
          <source>The numbered list above notes that the data for the first page of the database file, if it exists and is not already loaded into the</source>
          <target state="translated">上面的编号列表中指出,如果数据库文件的第一页数据存在,而且还没有加载到</target>
        </trans-unit>
        <trans-unit id="57671fab77edd8c578d7c9204ffe057965cc804a" translate="yes" xml:space="preserve">
          <source>The numbers here have become meaningless. This page has been retained only as an historical artifact.</source>
          <target state="translated">这里的数字已经变得毫无意义。本页仅作为历史文物保留。</target>
        </trans-unit>
        <trans-unit id="dde5b38271f3bab6f5848df944b4001a9705e033" translate="yes" xml:space="preserve">
          <source>The numbers on the left are the CPU cycle counts for that line of code, of course.</source>
          <target state="translated">当然,左边的数字是该行代码的CPU周期数。</target>
        </trans-unit>
        <trans-unit id="a08476269382d9cd02770e2cab87ae0ab5a527b0" translate="yes" xml:space="preserve">
          <source>The object is deleted using a call to sqlite3changegroup_delete().</source>
          <target state="translated">使用调用sqlite3changegroup_delete()删除该对象。</target>
        </trans-unit>
        <trans-unit id="5ae7075075a940fc9e83c06d49e89ed478d0bf99" translate="yes" xml:space="preserve">
          <source>The one-byte flag at offset 0 indicating the b-tree page type.</source>
          <target state="translated">偏移量0的一个字节标志,表示b树的页面类型。</target>
        </trans-unit>
        <trans-unit id="8ef8e17609c1f629f28fe60dfd6c0e8997843e40" translate="yes" xml:space="preserve">
          <source>The one-byte integer at offset 7 gives the number of fragmented free bytes within the cell content area.</source>
          <target state="translated">偏移量7处的一字节整数给出了单元内容区域内碎片化的自由字节数。</target>
        </trans-unit>
        <trans-unit id="729502a2e01c1766734981063a90830e318512ca" translate="yes" xml:space="preserve">
          <source>The online backup API is &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;documented here&lt;/a&gt;. The remainder of this page contains two C language examples illustrating common uses of the API and discussions thereof. Reading these examples is no substitute for reading the API documentation!</source>
          <target state="translated">在线备份API &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;在此处记录&lt;/a&gt;。该页面的其余部分包含两个C语言示例，这些示例说明了API的常见用法及其讨论。阅读这些示例不能代替阅读API文档！</target>
        </trans-unit>
        <trans-unit id="0ca3b9f46f696e6082e6b7a829be81ef745b8e77" translate="yes" xml:space="preserve">
          <source>The only SQLite compile-time option used was &lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt;. The optional &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; memory allocator is used for performance testing because it gives results that are more repeatable than the library-supplied malloc()/free() on Ubuntu.</source>
          <target state="translated">使用的唯一SQLite编译时选项是&lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt;。可选的&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;内存分配器用于性能测试，因为它提供的结果比Ubuntu上库提供的malloc（）/ free（）更具可重复性。</target>
        </trans-unit>
        <trans-unit id="89c13a55d3d11964427a1a5b2d10d0b78ec66565" translate="yes" xml:space="preserve">
          <source>The only compression algorithm supported is &lt;a href=&quot;https://zlib.net&quot;&gt;&quot;deflate&quot;&lt;/a&gt;.</source>
          <target state="translated">支持的唯一压缩算法是&lt;a href=&quot;https://zlib.net&quot;&gt;&amp;ldquo; deflate&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ecb1124fca00e2a69914563c0d3a9baa08011926" translate="yes" xml:space="preserve">
          <source>The only difference between the following two CASE expressions is that the</source>
          <target state="translated">以下两个CASE表达式的唯一区别是</target>
        </trans-unit>
        <trans-unit id="f71f4a9db1fb88c54de0203ce462454fe4edc774" translate="yes" xml:space="preserve">
          <source>The only difference is that the public sqlite3_XXX functions enumerated above silently ignore any invocations that pass a NULL pointer instead of a valid mutex handle. The implementations of the methods defined by this structure are not required to handle this case, the results of passing a NULL pointer instead of a valid mutex handle are undefined (i.e. it is acceptable to provide an implementation that segfaults if it is passed a NULL pointer).</source>
          <target state="translated">唯一不同的是,上面列举的公共sqlite3_XXX函数会默默地忽略任何传递一个NULL指针而不是有效的mutex句柄的调用。这个结构所定义的方法的实现不需要处理这种情况,传递NULL指针而不是有效的mutex句柄的结果是未定义的(也就是说,如果传递了一个NULL指针,提供一个segfaults的实现是可以接受的)。</target>
        </trans-unit>
        <trans-unit id="9650a6c44a89db8ce8453af489933161fa10a223" translate="yes" xml:space="preserve">
          <source>The only difference is that the public sqlite3_XXX functions enumerated above silently ignore any invocations that pass a NULL pointer instead of a valid mutex handle. The implementations of the methods defined by this structure are not required to handle this case. The results of passing a NULL pointer instead of a valid mutex handle are undefined (i.e. it is acceptable to provide an implementation that segfaults if it is passed a NULL pointer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="927a15e9b9c9c5a21e0cad33a99f89864994a2c1" translate="yes" xml:space="preserve">
          <source>The only really hard part is step 1. You might want to start with an existing virtual table implementation and modify it to suit your needs. The &lt;a href=&quot;https://sqlite.org/src/dir?ci=trunk&amp;amp;type=tree&quot;&gt;SQLite source tree&lt;/a&gt; contains many virtual table implementations that are suitable for copying, including:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b216563d4489c23da5dd8ef7bbce7ce15447a023" translate="yes" xml:space="preserve">
          <source>The only really hard part is step 1. You might want to start with an existing virtual table implementation and modify it to suit your needs. There are several virtual table implementations in the SQLite source tree (for testing purposes). You might use one of those as a guide. Locate these test virtual table implementations by searching for &quot;sqlite3_create_module&quot;.</source>
          <target state="translated">唯一真正困难的部分是第1步。你可能想从一个现有的虚拟表实现开始,并根据你的需要修改它。在SQLite源代码树中有几个虚拟表的实现(用于测试目的)。你可以使用其中的一个作为指导。通过搜索 &quot;sqlite3_create_module &quot;找到这些测试虚拟表实现。</target>
        </trans-unit>
        <trans-unit id="6a54b4d13a6de9bd96883cd76ca40e5bd7dd1a4b" translate="yes" xml:space="preserve">
          <source>The only reasons for providing functions other than strftime() is for convenience and for efficiency.</source>
          <target state="translated">提供strftime()以外的函数的唯一原因是为了方便和提高效率。</target>
        </trans-unit>
        <trans-unit id="c64051b826835db581e8535aa4a8fb802f2e8d26" translate="yes" xml:space="preserve">
          <source>The only schema altering commands directly supported by SQLite are the &quot;&lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;rename table&lt;/a&gt;&quot;, &quot;&lt;a href=&quot;lang_altertable#altertabmvcol&quot;&gt;rename column&lt;/a&gt;&quot;, and &quot;&lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;add column&lt;/a&gt;&quot; commands shown above. However, applications can make other arbitrary changes to the format of a table using a simple sequence of operations. The steps to make arbitrary changes to the schema design of some table X are as follows:</source>
          <target state="translated">SQLite直接支持的唯一模式更改命令是上面显示的&amp;ldquo; &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;重命名表&lt;/a&gt; &amp;rdquo;，&amp;ldquo; &lt;a href=&quot;lang_altertable#altertabmvcol&quot;&gt;重命名列&lt;/a&gt; &amp;rdquo;和&amp;ldquo; &lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;添加列&lt;/a&gt; &amp;rdquo;命令。但是，应用程序可以使用简单的操作序列对表的格式进行其他任意更改。对某些表X的架构设计进行任意更改的步骤如下：</target>
        </trans-unit>
        <trans-unit id="a93c45a553bd489c541613e587314033dbb5442e" translate="yes" xml:space="preserve">
          <source>The only significant design decision that developers need to make is whether to use -Os (optimize for size) or -O6 (optimize for speed). The -O6 setting makes binaries that run about 2% or 3% faster, but which are also 66% larger. The performance here is measured by counting CPU cycles using cachegrind. I-cache misses are not considered in the analysis. If I-cache misses are considered, builds with -O6 might not be any faster than builds with -Os.</source>
          <target state="translated">开发者需要做的唯一重要的设计决策是使用-Os(优化大小)还是-O6(优化速度)。-O6的设置使得二进制文件的运行速度提高了大约2%或3%,但其体积也大了66%。这里的性能是通过使用cachegrind计算CPU周期来衡量的。在分析中不考虑I-cache misses。如果考虑到 I-cache 遗漏,使用 -O6 的构建可能不会比使用 -Os 的构建更快。</target>
        </trans-unit>
        <trans-unit id="67fcf151555c1f1738044349d853d4cc0820a67f" translate="yes" xml:space="preserve">
          <source>The only thing that is really new about the current example is the WHERE clause which is implemented by instructions at addresses 7 through 10. Instructions at address 7 and 8 push onto the stack the value of the &quot;one&quot; column from the table and the literal string &quot;H%&quot;. The &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt; instruction at address 9 pops these two values from the stack and pushes the result of the LIKE() function back onto the stack. The &lt;a href=&quot;opcode#IfNot&quot;&gt;IfNot&lt;/a&gt; instruction pops the top stack value and causes an immediate jump forward to the Next instruction if the top value was false (&lt;em&gt;not&lt;/em&gt; not like the literal string &quot;H%&quot;). Taking this jump effectively skips the callback, which is the whole point of the WHERE clause. If the result of the comparison is true, the jump is not taken and control falls through to the Callback instruction below.</source>
          <target state="translated">当前示例中唯一真正新颖的是WHERE子句，该子句由地址7到10的指令实现。地址7和8的指令将表和文字中的&amp;ldquo; one&amp;rdquo;列的值压入堆栈字符串&amp;ldquo; H％&amp;rdquo;。地址9处的&lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt;指令从堆栈中弹出这两个值，并将LIKE（）函数的结果推回堆栈中。在&lt;a href=&quot;opcode#IfNot&quot;&gt;如不方便&lt;/a&gt;指令弹出堆栈顶部的值，并导致立即跳跃式前进到下一条指令，如果顶部的值是假的（&lt;em&gt;不&lt;/em&gt;不像文字字符串&amp;ldquo; H％&amp;rdquo;）。有效地执行此跳转将跳过回调，这是WHERE子句的重点。如果比较结果为true，则不执行跳转，控制权落到下面的Callback指令中。</target>
        </trans-unit>
        <trans-unit id="7db0a106b3cc6051a669fd3768b87982a2f1bf0d" translate="yes" xml:space="preserve">
          <source>The only time this would ever be an issue is when you have a program using version 2.8.0 or later that crashes with an incomplete transaction, then you try to examine the database using version 2.7.6 or earlier. The 2.7.6 code will not be able to read the journal file and thus will not be able to rollback the incomplete transaction to restore the database.</source>
          <target state="translated">只有当你有一个使用2.8.0或更高版本的程序因不完整的事务而崩溃,然后你尝试使用2.7.6或更早的版本检查数据库时,才会出现这种情况。2.7.6版本的代码将无法读取日志文件,因此将无法回滚不完整事务来恢复数据库。</target>
        </trans-unit>
        <trans-unit id="3427e2677eb5693de36c8d23ded03f405a1417be" translate="yes" xml:space="preserve">
          <source>The only way that SQLite can know that the left-most columns of an index have many duplicate is if the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command has been run on the database. Without the results of ANALYZE, SQLite has to guess at the &quot;shape&quot; of the data in the table, and the default guess is that there are an average of 10 duplicates for every value in the left-most column of the index. But skip-scan only becomes profitable (it only gets to be faster than a full table scan) when the number of duplicates is about 18 or more. Hence, a skip-scan is never used on a database that has not been analyzed.</source>
          <target state="translated">SQLite知道索引的最左列有很多重复项的唯一方法是，是否已经在数据库上运行了&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令。没有ANALYZE的结果，SQLite必须猜测表中数据的&amp;ldquo;形状&amp;rdquo;，默认猜测是索引最左列中的每个值平均有10个重复项。但是，当重复项的数量大约为18或更多时，跳过扫描只会变得有利可图（它只会比全表扫描更快）。因此，从未对尚未分析的数据库使用跳过扫描。</target>
        </trans-unit>
        <trans-unit id="4470bf44a4ab413995e0a4a3db8d3df4a465f540" translate="yes" xml:space="preserve">
          <source>The opening and/or creating of the database file is deferred until the file is actually needed. This allows options and parameters, such as the native text representation and default page size, to be set using PRAGMA statements.</source>
          <target state="translated">数据库文件的打开和/或创建被推迟到实际需要该文件的时候。这允许使用PRAGMA语句设置选项和参数,如本地文本表示和默认页面大小。</target>
        </trans-unit>
        <trans-unit id="0fff8fde33861bc909ec1bcff7cb77c490217d5b" translate="yes" xml:space="preserve">
          <source>The operating system interface layer understands and tracks all five locking states described above. The pager module only tracks four of the five locking states. A PENDING lock is always just a temporary stepping stone on the path to an EXCLUSIVE lock and so the pager module does not track PENDING locks.</source>
          <target state="translated">操作系统接口层了解并跟踪上述所有五种锁定状态。寻呼机模块只跟踪五种锁定状态中的四种。待定锁永远只是通往专属锁的临时垫脚石,所以寻呼机模块不跟踪待定锁。</target>
        </trans-unit>
        <trans-unit id="6f69f5f3efa82abf10e6a8b25aaa02ea47607f29" translate="yes" xml:space="preserve">
          <source>The operating system must have a unified buffer cache in order for the memory-mapped I/O extension to work correctly, especially in situations where two processes are accessing the same database file and one process is using memory-mapped I/O while the other is not. Not all operating systems have a unified buffer cache. In some operating systems that claim to have a unified buffer cache, the implementation is buggy and can lead to corrupt databases.</source>
          <target state="translated">操作系统必须有统一的缓冲区缓存,内存映射的I/O扩展才能正常工作,特别是在两个进程访问同一个数据库文件,一个进程使用内存映射的I/O而另一个进程不使用的情况下。并非所有的操作系统都有统一的缓冲区缓存。在一些宣称有统一缓冲区缓存的操作系统中,其实现是有bug的,可能导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="2fef3a1777aac58cd8a21d6d8b1475aa38c4964a" translate="yes" xml:space="preserve">
          <source>The operations above can potentially cause vast changes the raw database file, and hence cause very different SHA1 hashes at the file level. But since the content represented in the database file is unchanged by these operations, the hash computed by dbhash is also unchanged.</source>
          <target state="translated">上面的操作有可能会导致原始数据库文件发生巨大的变化,从而在文件级造成截然不同的SHA1哈希。但由于数据库文件中所表示的内容在这些操作中是不变的,所以dbhash计算出的哈希值也是不变的。</target>
        </trans-unit>
        <trans-unit id="fa365bc2db1bf185a92f2d5ef6ff8250e55de644" translate="yes" xml:space="preserve">
          <source>The optimization that uses an index to quickly compute an aggregate min() or max() is extended to work with &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.</source>
          <target state="translated">使用索引来快速计算聚合min（）或max（）的优化已扩展为可&lt;a href=&quot;expridx&quot;&gt;用于表达式的索引&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0ff09fb1c0cc730867c7410dca6d8522dc6581b" translate="yes" xml:space="preserve">
          <source>The optimizer automatically inverts terms of the form &quot;expr OP column&quot; and makes other simplifications to the WHERE clause in an attempt to get as many WHERE clause terms into the form shown above as possible. The aConstraint[] array only reports WHERE clause terms that are relevant to the particular virtual table being queried.</source>
          <target state="translated">优化器会自动反转 &quot;expr OP列 &quot;形式的术语,并对WHERE子句进行其他简化,试图让尽可能多的WHERE子句进入上图所示的形式。aConstraint[]数组只报告与被查询的特定虚拟表相关的WHERE子句。</target>
        </trans-unit>
        <trans-unit id="3a8fb11a2c37159ec0832c94b1217f4e3525fc9f" translate="yes" xml:space="preserve">
          <source>The optimizer has more freedom to reorder tables in the FROM clause even in there are LEFT joins.</source>
          <target state="translated">优化器有更多的自由度来重新排列FROM子句中的表,即使在有LEFT连接的情况下。</target>
        </trans-unit>
        <trans-unit id="ed82314b13b2ea2beac78e23a61e927cbc2a784b" translate="yes" xml:space="preserve">
          <source>The optimizer will now scan tables in the reverse if doing so will satisfy an ORDER BY ... DESC clause.</source>
          <target state="translated">优化器现在会反向扫描表,如果这样做会满足ORDER BY ...DESC子句。</target>
        </trans-unit>
        <trans-unit id="8d9594a87362ce1971b7a9efe4bfc116ba95e426" translate="yes" xml:space="preserve">
          <source>The option</source>
          <target state="translated">该选项</target>
        </trans-unit>
        <trans-unit id="a17a0a84a2d535101cac8aa7214d0ca78303a13a" translate="yes" xml:space="preserve">
          <source>The option causes SQLite to omit its built-in operating system interfaces for Unix, Windows, and OS/2. The resulting library will have no default &lt;a href=&quot;c3ref/vfs&quot;&gt;operating system interface&lt;/a&gt;. Applications must use &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; to register an appropriate interface before using SQLite. Applications must also supply implementations for the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; and &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_end()&lt;/a&gt; interfaces. The usual practice is for the supplied &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; to invoke &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;. SQLite will automatically invoke &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; when it initializes.</source>
          <target state="translated">该选项使SQLite省略其针对Unix，Windows和OS / 2的内置操作系统接口。生成的库将没有默认的&lt;a href=&quot;c3ref/vfs&quot;&gt;操作系统接口&lt;/a&gt;。在使用SQLite之前，应用程序必须使用&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;注册适当的接口。应用程序还必须提供&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init（）&lt;/a&gt;和&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_end（）&lt;/a&gt;接口的实现。通常的做法是让提供的&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init（）&lt;/a&gt;调用&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;。 SQLite 初始化时将自动调用&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">可选的</target>
        </trans-unit>
        <trans-unit id="e154860c714282a196150a8b230c6746d885f55b" translate="yes" xml:space="preserve">
          <source>The optional &quot;</source>
          <target state="translated">可选的&quot;</target>
        </trans-unit>
        <trans-unit id="44528aeaa99ba557a8ba7b80ef11d6c589ba4953" translate="yes" xml:space="preserve">
          <source>The optional &quot;AS alias&quot; phrase provides an alternative name for the table into which content is being inserted. The alias name can be used within WHERE and SET clauses of the &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt;. If there is no &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;, then the alias is pointless, but also harmless.</source>
          <target state="translated">可选的&amp;ldquo; AS别名&amp;rdquo;短语为插入内容的表提供了备用名称。别名可以在&lt;a href=&quot;lang_upsert&quot;&gt;UPSERT的&lt;/a&gt; WHERE和SET子句中使用。如果没有&lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert子句&lt;/a&gt;，则别名是没有意义的，而且也是无害的。</target>
        </trans-unit>
        <trans-unit id="af3a99778493ef21555e9c9fa86a7e91b06e70d3" translate="yes" xml:space="preserve">
          <source>The optional &quot;OR</source>
          <target state="translated">可选的 &quot;OR</target>
        </trans-unit>
        <trans-unit id="20d5db3386f7bebafe75fa5cbd335d930edd4888" translate="yes" xml:space="preserve">
          <source>The optional EXCLUDE clause may take any of the following four forms:</source>
          <target state="translated">可选的排除条款可以采取以下四种形式中的任何一种:</target>
        </trans-unit>
        <trans-unit id="f5dad0eb12cbe81d01819ac36d3268610ba8edac" translate="yes" xml:space="preserve">
          <source>The optional IF EXISTS clause suppresses the error that would normally result if the table does not exist.</source>
          <target state="translated">可选的IF EXISTS子句抑制了表不存在时通常会产生的错误。</target>
        </trans-unit>
        <trans-unit id="5cb5d652a77ff38b54b62cd30fd9ed282bedd94d" translate="yes" xml:space="preserve">
          <source>The optional MASK argument is a bitmask of optimizations to perform:</source>
          <target state="translated">可选的 MASK 参数是要执行的优化的位掩码。</target>
        </trans-unit>
        <trans-unit id="6a52a350b8227e3f2c9ade5a4eb34242d4d7eced" translate="yes" xml:space="preserve">
          <source>The optional argument is the name of the schema or database to be serialized. The default value is &quot;main&quot;.</source>
          <target state="translated">可选参数是要序列化的模式或数据库的名称。默认值是 &quot;main&quot;。</target>
        </trans-unit>
        <trans-unit id="38da3cf28a52f4f6d620faa6e6cb2361f1cf4901" translate="yes" xml:space="preserve">
          <source>The optional expression that occurs in between the CASE keyword and the first WHEN keyword is called the &quot;base&quot; expression. There are two basic forms of the CASE expression: those with a base expression and those without.</source>
          <target state="translated">出现在CASE关键字和第一个WHEN关键字之间的可选表达式称为 &quot;基础 &quot;表达式。CASE表达式有两种基本形式:有基础表达式的和没有基础表达式的。</target>
        </trans-unit>
        <trans-unit id="4916a24a4905c950af19989b67424175234963da" translate="yes" xml:space="preserve">
          <source>The optional expression that occurs in between the CASE keyword and the first WHEN keyword is called the &quot;base&quot; expression. There are two fundamental forms of the CASE expression: those with a base expression and those without.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b46109c9ae9c950c43fe7007d16547e58baf09ab" translate="yes" xml:space="preserve">
          <source>The optional shared cache and memory management features that were introduced in version 3.3.0 can now be used across multiple threads within the same process. Formerly, these extensions only applied to database connections operating within a single thread.</source>
          <target state="translated">在3.3.0版本中引入的可选共享缓存和内存管理功能现在可以在同一进程中的多个线程中使用。以前,这些扩展只适用于在单个线程内运行的数据库连接。</target>
        </trans-unit>
        <trans-unit id="095e758e6c75bd1010500f9c5cbf1c0112ebeaf1" translate="yes" xml:space="preserve">
          <source>The order of evaluation of function arguments.</source>
          <target state="translated">函数参数的评估顺序。</target>
        </trans-unit>
        <trans-unit id="671d3f63e428cbeb09358473179412be4940924b" translate="yes" xml:space="preserve">
          <source>The order of keys in an index b-tree is determined by the sort order of the records that the keys represent. Record comparison progresses column by column. Columns of a record are examined from left to right. The first pair of columns that are not equal determines the relative order of the two records. The sort order of individual columns is as follows:</source>
          <target state="translated">索引b树中键的顺序是由键所代表的记录的排序顺序决定的。记录比较是逐列进行的。记录的列从左到右进行检查。第一对不相等的列决定了两条记录的相对顺序。各列的排序顺序如下。</target>
        </trans-unit>
        <trans-unit id="2b489797ae43740676c30370f9b2ea776aa65877" translate="yes" xml:space="preserve">
          <source>The order of tables in a join is adjusted automatically to make better use of indices</source>
          <target state="translated">自动调整连接中表的顺序,以便更好地利用索引。</target>
        </trans-unit>
        <trans-unit id="140f29de259bdc1e34708f12946df0112e292cdd" translate="yes" xml:space="preserve">
          <source>The order of the buffer pointer and buffer size parameters in the built-in snprintf() implementation is reversed from the order used in standard-library implementations.</source>
          <target state="translated">在内置的snprintf()实现中,缓冲区指针和缓冲区大小参数的顺序与标准库实现中使用的顺序是相反的。</target>
        </trans-unit>
        <trans-unit id="5e9268cc64b3aabab9ece14a89f94084ddd4b3cc" translate="yes" xml:space="preserve">
          <source>The order of the columns in the data_% table does not matter.</source>
          <target state="translated">data_%表中各列的顺序并不重要。</target>
        </trans-unit>
        <trans-unit id="b1b615b19c9501777b15d4388be1e80320f4db76" translate="yes" xml:space="preserve">
          <source>The order of the entries indicates the nesting order. In this case, the scan of table t1 using index i2 is the outer loop (since it appears first) and the full-table scan of table t2 is the inner loop (since it appears last). In the following example, the positions of t1 and t2 in the FROM clause of the SELECT are reversed. The query strategy remains the same. The output from EXPLAIN QUERY PLAN shows how the query is actually evaluated, not how it is specified in the SQL statement.</source>
          <target state="translated">条目的顺序表示嵌套顺序。在本例中,使用索引i2对表t1的扫描是外循环(因为它最先出现),对表t2的全表扫描是内循环(因为它最后出现)。在下面的例子中,SELECT的FROM子句中t1和t2的位置是相反的。查询策略保持不变。EXPLAIN QUERY PLAN的输出显示的是查询的实际评估方式,而不是SQL语句中指定的方式。</target>
        </trans-unit>
        <trans-unit id="70ac1e5ab36762649806ee198f0345318ef8e4bd" translate="yes" xml:space="preserve">
          <source>The orderByConsumed means that output from &lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;/&lt;a href=&quot;../vtab#xnext&quot;&gt;xNext&lt;/a&gt; will occur in the correct order to satisfy the ORDER BY clause so that no separate sorting step is required.</source>
          <target state="translated">orderByConsumed意味着&lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; / &lt;a href=&quot;../vtab#xnext&quot;&gt;xNext的&lt;/a&gt;输出将以正确的顺序出现，以满足ORDER BY子句，因此不需要单独的排序步骤。</target>
        </trans-unit>
        <trans-unit id="a4ee366293d58487c3c181ee97d4fddeec053e83" translate="yes" xml:space="preserve">
          <source>The orderByConsumed means that output from &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;/&lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; will occur in the correct order to satisfy the ORDER BY clause so that no separate sorting step is required.</source>
          <target state="translated">orderByConsumed意味着&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; / &lt;a href=&quot;vtab#xnext&quot;&gt;xNext的&lt;/a&gt;输出将以正确的顺序出现，以满足ORDER BY子句，因此不需要单独的排序步骤。</target>
        </trans-unit>
        <trans-unit id="361a689885e1ba1224dc1550da95ae3bd8151f01" translate="yes" xml:space="preserve">
          <source>The original UTF8 text of the vocabulary word</source>
          <target state="translated">词汇的UTF8原文。</target>
        </trans-unit>
        <trans-unit id="8f218b03066661856e3cf8a761cc5ae4bbd68ed0" translate="yes" xml:space="preserve">
          <source>The original document we put here was more of a &lt;a href=&quot;codeofethics&quot;&gt;Code of Ethics of the Project Founder&lt;/a&gt;. While we stand by those principles, they are not in line with the modern technical meaning of a Code of Conduct and have hence been renamed.</source>
          <target state="translated">我们放在这里的原始文档更多地是&lt;a href=&quot;codeofethics&quot;&gt;Project Founder的道德守则&lt;/a&gt;。尽管我们坚持这些原则，但它们不符合《行为准则》的现代技术含义，因此已被重命名。</target>
        </trans-unit>
        <trans-unit id="c32bb1620d101b8c498092185971e74a9cc27eb4" translate="yes" xml:space="preserve">
          <source>The original implementation of SQLite sought to follow &lt;a href=&quot;https://en.wikipedia.org/wiki/Robustness_principle&quot;&gt;Postel's Law&lt;/a&gt; which states in part &quot;Be liberal in what you accept&quot;. This used to be considered good design - that a system would accept dodgy inputs and try to do the best it could without complaining too much. But lately, people have come to realize that it is sometimes better to be strict in what you accept, so as to more easily find errors in the input.</source>
          <target state="translated">SQLite的原始实现试图遵循&lt;a href=&quot;https://en.wikipedia.org/wiki/Robustness_principle&quot;&gt;Postel法则&lt;/a&gt;，该法则部分规定&amp;ldquo;在所接受的内容中保持自由&amp;rdquo;。过去，这被认为是好的设计-系统可以接受狡猾的输入，并尽其所能地做到最好，而不会抱怨太多。但是最近，人们开始意识到有时最好严格接受您所接受的内容，以便更轻松地发现输入中的错误。</target>
        </trans-unit>
        <trans-unit id="faed9cec852456e57ebf990afb4cf1cac2f27e57" translate="yes" xml:space="preserve">
          <source>The original values for each modified field of the row.</source>
          <target state="translated">该行各修改字段的原始值。</target>
        </trans-unit>
        <trans-unit id="2a41f1df0018eecb7b908d40c9986e3b87989e32" translate="yes" xml:space="preserve">
          <source>The original values of any modified fields are omitted from UPDATE records.</source>
          <target state="translated">任何修改后的字段的原始值都会从UPDATE记录中省略。</target>
        </trans-unit>
        <trans-unit id="f1449473437f390f79738378e7abd93ce9be7fe0" translate="yes" xml:space="preserve">
          <source>The other advantage to using SQLite in place of ZIP is that the document can now be updated incrementally, without risk of corrupting the document if a power loss or other crash occurs in the middle of the update. (Remember that writes to &lt;a href=&quot;atomiccommit&quot;&gt;SQLite databases are atomic&lt;/a&gt;.) True, all the content is still kept in a single big XML file (&quot;content.xml&quot;) which must be completely rewritten if so much as a single character changes. But with SQLite, only that one file needs to change. The other 77 files in the repository can remain unaltered. They do not all have to be rewritten, which in turn makes &quot;File/Save&quot; run much faster and saves wear on SSDs.</source>
          <target state="translated">使用SQLite代替ZIP的另一个优点是，现在可以增量更新文档，而如果在更新过程中发生断电或其他崩溃，则不会损坏文档。 （请记住，写入&lt;a href=&quot;atomiccommit&quot;&gt;SQLite数据库是原子的&lt;/a&gt;。）确实，所有内容仍然保存在一个大的XML文件（&amp;ldquo; content.xml&amp;rdquo;）中，如果单个字符发生很大变化，则必须将其完全重写。但是，使用SQLite，只需更改一个文件即可。存储库中的其他77个文件可以保持不变。不必全部重写它们，从而使&amp;ldquo;文件/保存&amp;rdquo;运行得更快，并节省了SSD的磨损。</target>
        </trans-unit>
        <trans-unit id="ff8ed48a831b734ff6e1604276150ac99b9ac0e1" translate="yes" xml:space="preserve">
          <source>The other allowed parameters to sqlite3_mutex_alloc() (anything other than SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE) each return a pointer to a static preexisting mutex. Nine static mutexes are used by the current version of SQLite. Future versions of SQLite may add additional static mutexes. Static mutexes are for internal use by SQLite only. Applications that use SQLite mutexes should use only the dynamic mutexes returned by SQLITE_MUTEX_FAST or SQLITE_MUTEX_RECURSIVE.</source>
          <target state="translated">sqlite3_mutex_alloc()的其他允许参数(除了SQLITE_MUTEX_FAST和SQLITE_MUTEX_RECURSIVE以外的任何参数),每个参数都返回一个指向静态预存在的mutex的指针。当前版本的SQLite使用了九个静态互斥。未来版本的SQLite可能会添加更多的静态互斥。静态mutexes只供SQLite内部使用。使用SQLite mutexes的应用程序应该只使用由SQLITE_MUTEX_FAST或SQLITE_MUTEX_RECURSIVE返回的动态mutexes。</target>
        </trans-unit>
        <trans-unit id="e68942fbbde7b9568017891360f3a9246030e2a2" translate="yes" xml:space="preserve">
          <source>The other file, &quot;fts5.h&quot;, is not required to compile the FTS5 extension. It is used by applications that implement &lt;a href=&quot;fts5#extending_fts5&quot;&gt;custom FTS5 tokenizers or auxiliary functions&lt;/a&gt;.</source>
          <target state="translated">不需要另一个文件&amp;ldquo; fts5.h&amp;rdquo;来编译FTS5扩展名。由实现&lt;a href=&quot;fts5#extending_fts5&quot;&gt;自定义FTS5标记程序或辅助功能&lt;/a&gt;的应用程序使用。</target>
        </trans-unit>
        <trans-unit id="f74c4fa3b3502ec3d363778205dc40519edfac8e" translate="yes" xml:space="preserve">
          <source>The other information required to create a changeset or patchset is read from the database file when &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; or &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset()&lt;/a&gt; is called. Specifically,</source>
          <target state="translated">&lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;调用sqlite3session_changeset（）&lt;/a&gt;或&lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset（）&lt;/a&gt;时，将从数据库文件中读取创建变更集或补丁集所需的其他信息。特别，</target>
        </trans-unit>
        <trans-unit id="4ceb7a7a69cfd1205ea5e7612f272fc9e42d8423" translate="yes" xml:space="preserve">
          <source>The outer SELECT is implemented by instructions 11 through 25. In particular, the WHERE clause containing the IN operator is implemented by instructions at 16, 17, and 20. Instruction 16 pushes the value of the &quot;two&quot; column for the current row onto the stack and instruction 17 checks to see that it is non-NULL. If this is successful, execution jumps to 20, where it tests to see if top of the stack matches any key in the temporary table. The rest of the code is the same as what has been shown before.</source>
          <target state="translated">外层的SELECT是由指令11到25实现的。特别是包含IN操作符的WHERE子句由指令16、17和20实现。指令16将当前行的 &quot;二 &quot;列的值推到堆栈上,指令17检查它是否为非NULL。如果成功,执行跳转到20,在这里测试栈顶是否与临时表中的任何键相匹配。其余的代码与前面所展示的相同。</target>
        </trans-unit>
        <trans-unit id="636166e4ba0668356d630c0a9cb37eba4fcc8c00" translate="yes" xml:space="preserve">
          <source>The outer SELECT is implemented by instructions 14 through 25. In particular, the WHERE clause that contains the nested select is implemented by instructions 19 through 21. You can see that the result of the inner select is loaded onto the stack by instruction 20 and used by the conditional jump at 21.</source>
          <target state="translated">外层的select由指令14到25实现。特别是包含嵌套选择的WHERE子句由指令19到21实现。可以看到,内层选择的结果由指令20加载到堆栈中,并由21处的条件跳转使用。</target>
        </trans-unit>
        <trans-unit id="fcdaf6e60b18b913fe64114ea32692d007183ab8" translate="yes" xml:space="preserve">
          <source>The outer loop over table examp is implement by instructions 7 through 23. The inner loop is instructions 13 through 22. Notice that the &quot;two&amp;lt;50&quot; term of the WHERE expression involves only columns from the first table and can be factored out of the inner loop. SQLite does this and implements the &quot;two&amp;lt;50&quot; test in instructions 10 through 12. The &quot;four==two&quot; test is implement by instructions 14 through 16 in the inner loop.</source>
          <target state="translated">表examp的外部循环由指令7至23实现。内部循环由13至22指令实现。请注意，WHERE表达式的&amp;ldquo; two &amp;lt;50&amp;rdquo;术语仅涉及第一张表中的列，并且可以从内循环。SQLite这样做并在指令10到12中实现&amp;ldquo; two &amp;lt;50&amp;rdquo;测试。&amp;ldquo; four == two&amp;rdquo;测试由内部循环中的指令14到16实现。</target>
        </trans-unit>
        <trans-unit id="0e7b99d6dfc2b5d85e34f55e3ea4da579b189034" translate="yes" xml:space="preserve">
          <source>The output begins with a report of the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; (cross-checked again &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt;) for the SQLite under test and the compile-time options used as reported by &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get()&lt;/a&gt;. The output concludes with a summary of the test results and a repeat of the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;. If any errors are detected, additional lines detail the problem. The error reporting lines always begin with a single space character so that they can be quickly extracted from large output files using:</source>
          <target state="translated">输出以针对测试中的SQLite 的&lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;报告（再次交叉检查&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid（）&lt;/a&gt;）和&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get（）&lt;/a&gt;报告的编译时选项开始。输出以测试结果的摘要和&lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;的重复结尾。如果检测到任何错误，则其他行会详细说明问题。错误报告行始终以单个空格字符开头，以便可以使用以下命令从大型输出文件中快速提取它们：</target>
        </trans-unit>
        <trans-unit id="b2295d00e027ddb605dbb2cc9b7646825272b788" translate="yes" xml:space="preserve">
          <source>The output from EXPLAIN and EXPLAIN QUERY PLAN is intended for interactive analysis and troubleshooting only. The details of the output format are subject to change from one release of SQLite to the next. Applications should not use EXPLAIN or EXPLAIN QUERY PLAN since their exact behavior is variable and only partially documented.</source>
          <target state="translated">EXPLAIN 和 EXPLAIN QUERY PLAN 的输出仅用于交互式分析和故障排除。输出格式的细节会随着SQLite的不同版本而改变。应用程序不应该使用EXPLAIN或EXPLAIN QUERY PLAN,因为它们的确切行为是可变的,而且只有部分记录。</target>
        </trans-unit>
        <trans-unit id="235163a8fba9aa1445cd051f01c741ea66911c96" translate="yes" xml:space="preserve">
          <source>The output from the &lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;cg_anno.tcl&lt;/a&gt; script shows the number of CPU cycles spent on each line of code. The report is approximately 80,000 lines long. The following is a brief snippet taken from the middle of the report to show what it looks like:</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;cg_anno.tcl&lt;/a&gt;脚本的输出显示每行代码花费的CPU周期数。该报告大约有80,000行。以下是摘自报告中间的简短摘要，以显示其外观：</target>
        </trans-unit>
        <trans-unit id="4c55fd24704ccac9a200bb25fe01e36a7bd6347b" translate="yes" xml:space="preserve">
          <source>The output from the mkth3.tcl script is a C program that contains everything needed to run the tests - everything that is except for the SQLite library itself. The generated test program contains implementations for all of the support interfaces used by the test modules and it contains the &lt;code&gt;main()&lt;/code&gt; routine that drives the tests. To convert the test program into a working executable, simply compile it against SQLite:</source>
          <target state="translated">mkth3.tcl脚本的输出是一个C程序，其中包含运行测试所需的所有内容-除SQLite库本身以外的所有内容。生成的测试程序包含测试模块使用的所有支持接口的实现，并且包含驱动测试的 &lt;code&gt;main()&lt;/code&gt; 例程。要将测试程序转换为可运行的可执行文件，只需针对SQLite对其进行编译：</target>
        </trans-unit>
        <trans-unit id="abe6a29295e5add598505fe98eb212b9e3e6e910" translate="yes" xml:space="preserve">
          <source>The output is a human-readable ASCII text report that provides information on the space utilization of the database file. The report is intended to be self-explanatory, though there is some &lt;a href=&quot;sqlanalyze#defs&quot;&gt;additional explanation&lt;/a&gt; of the various parameters reported toward the end of the report.</source>
          <target state="translated">输出是人类可读的ASCII文本报告，该报告提供有关数据库文件空间利用率的信息。尽管对报告末尾所报告的各种参数还有一些&lt;a href=&quot;sqlanalyze#defs&quot;&gt;其他&lt;/a&gt;解释，但该报告的目的不言而喻。</target>
        </trans-unit>
        <trans-unit id="89607a5138078e5c86fca97ee25682b106679c11" translate="yes" xml:space="preserve">
          <source>The output is also valid SQL. Most of the report text is contained within a header comment, with various SQL statements that create and initialize a database at the &lt;a href=&quot;sqlanalyze#sqlx&quot;&gt;end of the report&lt;/a&gt;. The constructed database contains the raw data from which the report was extracted. Hence the original report can be read into an instance of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; and then the raw data can be queried to dig deeper into the space utilization of a particular database file.</source>
          <target state="translated">输出也是有效的SQL。报告的大部分文本都包含在标题注释中，&lt;a href=&quot;sqlanalyze#sqlx&quot;&gt;在报告末尾&lt;/a&gt;带有各种SQL语句，这些语句创建和初始化数据库。构建的数据库包含从中提取报告的原始数据。因此，可以将原始报告读入&lt;a href=&quot;cli&quot;&gt;命令行Shell&lt;/a&gt;的实例，然后可以查询原始数据以更深入地了解特定数据库文件的空间利用率。</target>
        </trans-unit>
        <trans-unit id="bcfd95781cb98e2851bb0886cd3f1a588c682428" translate="yes" xml:space="preserve">
          <source>The output of &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; now shows each individual SQL statement run within a trigger.</source>
          <target state="translated">&lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;的输出现在显示在触发器中运行的每个单独的SQL语句。</target>
        </trans-unit>
        <trans-unit id="2d09f331aa1d428bbd3337e80bd418ed5659e816" translate="yes" xml:space="preserve">
          <source>The output of this revised query is:</source>
          <target state="translated">这个修订后的查询结果是:</target>
        </trans-unit>
        <trans-unit id="e3541aa5b140ee88f1e6bb5e89e08e8618d880af" translate="yes" xml:space="preserve">
          <source>The outputs s0 and s1 are both weighted checksums using Fibonacci weights in reverse order. (The largest Fibonacci weight occurs on the first element of the sequence being summed.) The s1 value spans all 32-bit integer terms of the sequence whereas s0 omits the final term.</source>
          <target state="translated">输出s0和s1都是使用斐波那契权重的加权校验和,顺序相反。(最大的斐波那契权重出现在被求和的序列的第一个元素上。)s1的值涵盖了序列的所有32位整数项,而s0则省略了最后一项。s1的值涵盖了序列的所有32位整数项,而s0则省略了最后一项。</target>
        </trans-unit>
        <trans-unit id="2d1abc65d901f9a5d25ea3d57ab5dd49e8f85287" translate="yes" xml:space="preserve">
          <source>The overflow thresholds are designed to give a minimum fanout of 4 for index b-trees and to make sure enough of the payload is on the b-tree page that the record header can usually be accessed without consulting an overflow page. In hindsight, the designer of the SQLite b-tree logic realized that these thresholds could have been made much simpler. However, the computations cannot be changed without resulting in an incompatible file format. And the current computations work well, even if they are a little complex.</source>
          <target state="translated">溢出阈值的设计是为了给索引b树提供最小的扇出量为4,并确保b树页面上有足够多的有效载荷,通常不需要咨询溢出页面就可以访问记录头。事后,SQLite b-tree逻辑的设计者意识到,这些阈值可以做得更简单。但是,如果不改变计算方式,就不能导致文件格式不兼容。而目前的计算结果很好用,即使它们有点复杂。</target>
        </trans-unit>
        <trans-unit id="ac70d959175f460608260178c8989bd26b78e65e" translate="yes" xml:space="preserve">
          <source>The pAppData pointer is unused by the SQLite core. The pointer is available to store auxiliary information that a VFS information might want to carry around.</source>
          <target state="translated">pAppData指针不被SQLite核心使用。该指针可用于存储VFS信息可能想要携带的辅助信息。</target>
        </trans-unit>
        <trans-unit id="18730b00ae23b4c106f1118f96d5a509058fa368" translate="yes" xml:space="preserve">
          <source>The pBuf parameter is a pointer to a contiguous range of bytes that SQLite will use for page-cache memory allocations. The buffer must be at least sz*N bytes in size. The &quot;sz&quot; parameter is the size of each page-cache allocation. N is the maximum number of available allocations.</source>
          <target state="translated">pBuf参数是指向SQLite将用于页缓存内存分配的连续字节范围的指针。缓冲区的大小必须至少是sz*N字节。&quot;sz &quot;参数是每个页缓存分配的大小。N是可用分配的最大数量。</target>
        </trans-unit>
        <trans-unit id="ac154834d9f47915a3416a80860f0b58cefd5585" translate="yes" xml:space="preserve">
          <source>The pContext member of the sqlite3_rtree_geometry structure is always set to a copy of the pContext argument passed to sqlite3_rtree_geometry_callback() when the callback is registered. The aParam[] array (size nParam) contains the parameter values passed to the SQL function on the right-hand side of the MATCH operator. In the example &quot;circle&quot; query above, nParam would be set to 3 and the aParam[] array would contain the three values 45.3, 22.9 and 5.0.</source>
          <target state="translated">sqlite3_rtree_geometry结构的pContext成员总是被设置为回调注册时传递给sqlite3_rtree_geometry_callback()的pContext参数的副本。aParam[]数组(大小为nParam)包含了传递给MATCH操作符右侧SQL函数的参数值。在上面的 &quot;圆 &quot;查询示例中,nParam将被设置为3,而aParam[]数组将包含三个值45.3、22.9和5.0。</target>
        </trans-unit>
        <trans-unit id="e127dc3dcbbc20bee3b0cdc450a4bea7c1e6776f" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;. If this is not the case, this function returns &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;.</source>
          <target state="translated">传递给该功能的参数PITER可以是由传递给一个冲突处理程序的迭代器&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;）sqlite3changeset_apply（&lt;/a&gt;或通过创建一个迭代&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;（）sqlite3changeset_start&lt;/a&gt;。在后一种情况下，对&lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）的&lt;/a&gt;最新调用必须返回&lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;。如果不是这种情况，则此函数返回&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="135aebf5a9dd2b851dadacfebf43a14b9409aa81" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">传递给该功能的参数PITER可以是由传递给一个冲突处理程序的迭代器&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;）sqlite3changeset_apply（&lt;/a&gt;或通过创建一个迭代&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;（）sqlite3changeset_start&lt;/a&gt;。在后一种情况下，对&lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）的&lt;/a&gt;最新调用必须返回SQLITE_ROW。此外，仅当迭代器当前指向的更改类型是&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;或&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE时&lt;/a&gt;，才可以调用它。否则，此函数返回&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;并将* ppValue设置为NULL。</target>
        </trans-unit>
        <trans-unit id="47ae6763d58288a12e6ca470cf923677f0731f46" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">传递给该功能的参数PITER可以是由传递给一个冲突处理程序的迭代器&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;）sqlite3changeset_apply（&lt;/a&gt;或通过创建一个迭代&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;（）sqlite3changeset_start&lt;/a&gt;。在后一种情况下，对&lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）的&lt;/a&gt;最新调用必须返回SQLITE_ROW。此外，仅当迭代器当前指向的更改类型是&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;或&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT时&lt;/a&gt;，才可以调用它。否则，此函数返回&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;并将* ppValue设置为NULL。</target>
        </trans-unit>
        <trans-unit id="5f4815a3e637ae9700d2b5b8cf01f7df97a164dc" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;. If this is not the case, this function returns &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;.</source>
          <target state="translated">传递给该功能的参数PITER可以是由传递给一个冲突处理程序的迭代器&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;）sqlite3changeset_apply（&lt;/a&gt;或通过创建一个迭代&lt;a href=&quot;sqlite3changeset_start&quot;&gt;（）sqlite3changeset_start&lt;/a&gt;。在后一种情况下，对&lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）的&lt;/a&gt;最新调用必须返回&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;。如果不是这种情况，则此函数返回&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5cb49779aa9657ac4af96a2c62fd60bce7011cad" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">传递给该功能的参数PITER可以是由传递给一个冲突处理程序的迭代器&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;）sqlite3changeset_apply（&lt;/a&gt;或通过创建一个迭代&lt;a href=&quot;sqlite3changeset_start&quot;&gt;（）sqlite3changeset_start&lt;/a&gt;。在后一种情况下，对&lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）的&lt;/a&gt;最新调用必须返回SQLITE_ROW。此外，仅当迭代器当前指向的更改类型是&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;或&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE时&lt;/a&gt;，才可以调用它。否则，此函数返回&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;并将* ppValue设置为NULL。</target>
        </trans-unit>
        <trans-unit id="836812d109e0eaaadd1e45a40c1311bde5cb7d98" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; or &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">传递给该功能的参数PITER可以是由传递给一个冲突处理程序的迭代器&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;）sqlite3changeset_apply（&lt;/a&gt;或通过创建一个迭代&lt;a href=&quot;sqlite3changeset_start&quot;&gt;（）sqlite3changeset_start&lt;/a&gt;。在后一种情况下，对&lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）的&lt;/a&gt;最新调用必须返回SQLITE_ROW。此外，仅当迭代器当前指向的更改类型是&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;或&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT时&lt;/a&gt;，才可以调用它。否则，此函数返回&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;并将* ppValue设置为NULL。</target>
        </trans-unit>
        <trans-unit id="87ffccb080e4ff9265c31827b97ddd2621e463bc" translate="yes" xml:space="preserve">
          <source>The pNext field is the only field in the sqlite3_vfs structure that SQLite will ever modify. SQLite will only access or modify this field while holding a particular static mutex. The application should never modify anything within the sqlite3_vfs object once the object has been registered.</source>
          <target state="translated">pNext字段是sqlite3_vfs结构中唯一会被SQLite修改的字段。SQLite只有在持有一个特定的静态互斥时才会访问或修改这个字段。一旦sqlite3_vfs对象被注册,应用程序就不应该修改该对象中的任何内容。</target>
        </trans-unit>
        <trans-unit id="754388a17b97b997745df633f79a8efeaffaaacb" translate="yes" xml:space="preserve">
          <source>The pNext field is used internally by SQLite. Specifically, SQLite uses this field to form a linked list of registered VFSes.</source>
          <target state="translated">pNext字段由SQLite内部使用。具体来说,SQLite使用这个字段来形成一个注册VFSes的链接列表。</target>
        </trans-unit>
        <trans-unit id="ed269faa072ea0bc301321c2683b96864943c28b" translate="yes" xml:space="preserve">
          <source>The pUser and xDelUser members of the sqlite3_rtree_geometry structure are initially set to NULL. The pUser variable may be set by the callback implementation to any arbitrary value that may be useful to subsequent invocations of the callback within the same query (for example, a pointer to a complicated data structure used to test for region intersection). If the xDelUser variable is set to a non-NULL value, then after the query has finished running SQLite automatically invokes it with the value of the pUser variable as the only argument. In other words, xDelUser may be set to a destructor function for the pUser value.</source>
          <target state="translated">sqlite3_rtree_geometry结构的pUser和xDelUser成员最初被设置为NULL。pUser变量可以被回调实现设置为任何对同一查询中后续调用回调有用的任意值(例如,指向用于测试区域交叉的复杂数据结构的指针)。如果xDelUser变量被设置为非NULL值,那么在查询运行完毕后,SQLite会自动调用它,将pUser变量的值作为唯一的参数。换句话说,xDelUser可以被设置为pUser值的析构函数。</target>
        </trans-unit>
        <trans-unit id="17b3e72d28371d5d2ffa9ec67e0ffe035454e59f" translate="yes" xml:space="preserve">
          <source>The page cache allocates from its own memory pool supplied by &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;,...) rather than from the heap.</source>
          <target state="translated">页面缓存从&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;，...）提供的内存池中分配，而不是从堆中分配。</target>
        </trans-unit>
        <trans-unit id="c49923490f20015de5b3c1344ee709093d18e9ac" translate="yes" xml:space="preserve">
          <source>The page cache allocates from its own memory pool supplied by &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;,...) rather than from the heap.</source>
          <target state="translated">页面缓存从&lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;，...）提供的内存池中分配，而不是从堆中分配。</target>
        </trans-unit>
        <trans-unit id="a302370f325aa6580998e916c1cd813d2e0b53c6" translate="yes" xml:space="preserve">
          <source>The page number in the database file</source>
          <target state="translated">数据库文件中的页码</target>
        </trans-unit>
        <trans-unit id="cb3defd1f8ac1da0588e9ad79d27848df6931c39" translate="yes" xml:space="preserve">
          <source>The page number of the database page associated with this</source>
          <target state="translated">与此相关的数据库页面的页码。</target>
        </trans-unit>
        <trans-unit id="0780190de9ffbf4345610e2662e0abd5cdf52be0" translate="yes" xml:space="preserve">
          <source>The page number of the database page for the current row</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d2ed89da4b6a6d4a6521b481ff6c43d5bdf9213" translate="yes" xml:space="preserve">
          <source>The page number of the largest root b-tree page when in auto-vacuum or incremental-vacuum modes, or zero otherwise.</source>
          <target state="translated">当处于自动真空或增量真空模式时,最大的b树根页的页数,否则为零。</target>
        </trans-unit>
        <trans-unit id="9a28509eee63401403c2ae3763725cac2ca99893" translate="yes" xml:space="preserve">
          <source>The page number of the page on which this row was found.</source>
          <target state="translated">该行所在页面的页码。</target>
        </trans-unit>
        <trans-unit id="41b015c66ddae0dbc3440c640484bd01738dbaf6" translate="yes" xml:space="preserve">
          <source>The page size and cache size can also be set or changed at run-time using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size pragma&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size pragma&lt;/a&gt;, respectively.</source>
          <target state="translated">页面大小和缓存大小也可以在运行时分别使用&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size pragma&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size pragma&lt;/a&gt;进行设置或更改。</target>
        </trans-unit>
        <trans-unit id="0105846f7fbf6f81d53292a1128d1e82d5804983" translate="yes" xml:space="preserve">
          <source>The page to be fetched is determined by the key. The minimum key value is 1. After it has been retrieved using xFetch, the page is considered to be &quot;pinned&quot;.</source>
          <target state="translated">要检索的页面由键决定。最小键值为1,使用xFetch检索后,页面被视为 &quot;钉住&quot;。</target>
        </trans-unit>
        <trans-unit id="ae6ce89a0e7b046f1218400c05d873074d2788d0" translate="yes" xml:space="preserve">
          <source>The page-cache memory allocator is disabled by default. An application can enable it at start-time as follows:</source>
          <target state="translated">页缓存内存分配器默认是禁用的,应用程序可以在启动时启用它。应用程序可以在启动时启用它,具体如下。</target>
        </trans-unit>
        <trans-unit id="79944cfbe90583fe884c628acc92c56b549b69ab" translate="yes" xml:space="preserve">
          <source>The pager and btree subsystems added back. They are now the only available backend.</source>
          <target state="translated">寻呼机和btree子系统添加回来。它们现在是唯一可用的后台。</target>
        </trans-unit>
        <trans-unit id="177ac3877a5c726efa0192a81b9a621bfc8aa28e" translate="yes" xml:space="preserve">
          <source>The pager is unconcerned with the details of B-Trees, text encodings, indices, and so forth. From the point of view of the pager the database consists of a single file of uniform-sized blocks. Each block is called a &quot;page&quot; and is usually 1024 bytes in size. The pages are numbered beginning with 1. So the first 1024 bytes of the database are called &quot;page 1&quot; and the second 1024 bytes are call &quot;page 2&quot; and so forth. All other encoding details are handled by higher layers of the library. The pager communicates with the operating system using one of several modules (Examples: &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_unix.c&quot;&gt; os_unix.c&lt;/a&gt;, &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_win.c&quot;&gt; os_win.c&lt;/a&gt;) that provides a uniform abstraction for operating system services.</source>
          <target state="translated">寻呼机不关心B树，文本编码，索引等细节。从寻呼机的角度来看，数据库由一个统一大小的块文件组成。每个块称为&amp;ldquo;页面&amp;rdquo;，通常大小为1024字节。页面从1开始编号。因此数据库的前1024个字节称为&amp;ldquo;第1页&amp;rdquo;，后1024个字节称为&amp;ldquo;第2页&amp;rdquo;，依此类推。所有其他编码细节由库的更高层处理。寻呼机使用几个模块之一与操作系统进行通信（示例：&lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt;，&lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_win.c&quot;&gt;os_win.c&lt;/a&gt;），这些模块为操作系统服务提供统一的抽象。</target>
        </trans-unit>
        <trans-unit id="5acaa405b470e4fb9ef36344daf0f015a3d5bf69" translate="yes" xml:space="preserve">
          <source>The pager module effectively controls access for separate threads, or separate processes, or both. Throughout this document whenever the word &quot;process&quot; is written you may substitute the word &quot;thread&quot; without changing the truth of the statement.</source>
          <target state="translated">寻呼机模块有效地控制了单独的线程,或单独的进程,或两者的访问。在本文档中,每当写到 &quot;进程 &quot;一词时,你可以用 &quot;线程 &quot;来代替,而不改变声明的真实性。</target>
        </trans-unit>
        <trans-unit id="3fbaa9934c130eb17f7eada7403c9132c86bbc58" translate="yes" xml:space="preserve">
          <source>The pager module is very robust but it can be subverted. This section attempts to identify and explain the risks. (See also the &lt;a href=&quot;atomiccommit#sect_9_0&quot;&gt;Things That Can Go Wrong&lt;/a&gt; section of the article on &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit&lt;/a&gt;.</source>
          <target state="translated">寻呼机模块非常强大，但是可以被颠覆。本节试图识别和解释风险。（另请参阅&amp;ldquo; &lt;a href=&quot;atomiccommit&quot;&gt;原子提交&lt;/a&gt; &amp;rdquo;一文中的&lt;a href=&quot;atomiccommit#sect_9_0&quot;&gt;&amp;ldquo;可能出错的&lt;/a&gt;部分&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="0f15cdebe573fd03148e855390c11255190632e7" translate="yes" xml:space="preserve">
          <source>The paragraph above notes that a MATCH operator with a simple term as the right-hand operand evaluates to true for all documents that contain the specified term. In this context, the &quot;document&quot; may refer to either the data stored in a single column of a row of an FTS table, or to the contents of all columns in a single row, depending on the identifier used as the left-hand operand to the MATCH operator. If the identifier specified as the left-hand operand of the MATCH operator is an FTS table column name, then the document that the search term must be contained in is the value stored in the specified column. However, if the identifier is the name of the FTS</source>
          <target state="translated">上段指出,以一个简单术语作为右手操作数的MATCH操作符,对于所有包含指定术语的文档来说,评价为真。在此上下文中,&quot;文档 &quot;可以指存储在FTS表中一行的单列中的数据,也可以指单行中所有列的内容,这取决于用作MATCH操作符左手操作数的标识符。如果作为 MATCH 操作符的左手操作符指定的标识符是 FTS 表的列名,那么搜索词必须包含的文档就是存储在指定列中的值。但是,如果标识符是FTS表的名称,那么搜索词必须包含在指定的列中。</target>
        </trans-unit>
        <trans-unit id="15582287ef68bc76059b207ebd8e45ad35a9f199" translate="yes" xml:space="preserve">
          <source>The parameter P is passed through as the only parameter to the callback function X. The parameter N is the approximate number of &lt;a href=&quot;../opcode&quot;&gt;virtual machine instructions&lt;/a&gt; that are evaluated between successive invocations of the callback X. If N is less than one then the progress handler is disabled.</source>
          <target state="translated">参数P作为唯一参数传递给回调函数X。参数N是在回调X的连续调用之间评估的&lt;a href=&quot;../opcode&quot;&gt;虚拟机指令&lt;/a&gt;的近似数量。如果N小于1，则禁用进度处理程序。</target>
        </trans-unit>
        <trans-unit id="de8aa7c163a7cfc0e81022005dde253ed27f9cea" translate="yes" xml:space="preserve">
          <source>The parameter P is passed through as the only parameter to the callback function X. The parameter N is the approximate number of &lt;a href=&quot;opcode&quot;&gt;virtual machine instructions&lt;/a&gt; that are evaluated between successive invocations of the callback X. If N is less than one then the progress handler is disabled.</source>
          <target state="translated">参数P作为唯一参数传递给回调函数X。参数N是在回调X的连续调用之间评估的&lt;a href=&quot;opcode&quot;&gt;虚拟机指令&lt;/a&gt;的近似数量。如果N小于1，则禁用进度处理程序。</target>
        </trans-unit>
        <trans-unit id="b6a1b97180e82088f349d801a8feb225d5ea8536" translate="yes" xml:space="preserve">
          <source>The parameters to the callback are the pArg value, the amount of memory currently in use, and the size of the allocation that provoked the callback. The callback will presumably invoke &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; to free up memory space. The callback may invoke &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt; but if it does, no additional callbacks will be invoked by the recursive calls.</source>
          <target state="translated">回调的参数是pArg值，当前使用的内存量以及引起回调的分配大小。回调可能会调用&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放内存空间。回调可以调用&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;或&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc（），&lt;/a&gt;但如果这样做，则递归调用将不会再调用其他回调。</target>
        </trans-unit>
        <trans-unit id="a0635b4b828516772af2e4a5c5f8f7c2b0b83854" translate="yes" xml:space="preserve">
          <source>The parent and sub-query may contain WHERE clauses. Subject to rules (11), (12) and (13), they may also contain ORDER BY, LIMIT and OFFSET clauses.</source>
          <target state="translated">母查询和子查询可以包含WHERE子句。在遵守规则(11)、(12)和(13)的前提下,它们还可以包含ORDER BY、LIMIT和OFFSET子句。</target>
        </trans-unit>
        <trans-unit id="6d5030cd0c93ffa44cd5f784ea6b109c2ce36ffc" translate="yes" xml:space="preserve">
          <source>The parent key columns named in the foreign key constraint are not the primary key of the parent table and are not subject to a unique constraint using collating sequence specified in the CREATE TABLE, or</source>
          <target state="translated">外键约束中命名的父键列不是父表的主键,并且不受唯一约束,使用CREATE TABLE中指定的整理序列,或</target>
        </trans-unit>
        <trans-unit id="0feae637448fae26652f631fd44b61bcd440968a" translate="yes" xml:space="preserve">
          <source>The parent key columns named in the foreign key constraint do not exist, or</source>
          <target state="translated">外键约束中命名的父键列不存在,或</target>
        </trans-unit>
        <trans-unit id="ba132dacfac52109e850c048192c0d768817957a" translate="yes" xml:space="preserve">
          <source>The parent table does not exist, or</source>
          <target state="translated">父表不存在,或</target>
        </trans-unit>
        <trans-unit id="cfb0e652f64b7c831f470e25c9ae00145b03ba52" translate="yes" xml:space="preserve">
          <source>The parser assigns meaning to tokens based on their context. The parser for SQLite is generated using the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt;. Lemon does the same job as YACC/BISON, but it uses a different input syntax which is less error-prone. Lemon also generates a parser which is reentrant and thread-safe. And Lemon defines the concept of a non-terminal destructor so that it does not leak memory when syntax errors are encountered. The grammar file that drives Lemon and that defines the SQL language that SQLite understands is found in &lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y&lt;/a&gt;.</source>
          <target state="translated">解析器根据令牌的上下文为令牌分配含义。 SQLite的解析器是使用&lt;a href=&quot;lemon&quot;&gt;Lemon解析器生成器生成的&lt;/a&gt;。 Lemon做的工作与YACC / BISON相同，但是它使用不同的输入语法，因此不容易出错。 Lemon还生成可重入且线程安全的解析器。 Lemon定义了非终端析构函数的概念，以便在遇到语法错误时不会泄漏内存。在&lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y中&lt;/a&gt;可以找到驱动Lemon的语法文件，该语法文件定义了SQLite可以理解的SQL语言。</target>
        </trans-unit>
        <trans-unit id="9872a2b10d55c6bd43d5d98d5414737378783a62" translate="yes" xml:space="preserve">
          <source>The parser forwards the AST on to the code generator. The code generator is the heart of SQLite, and is where most of the magic happens. The code generator resolves symbolic names in the AST - matching the names of columns and tables in the input SQL into actual columns and tables of the database. The code generator also does various transformations on the AST to &quot;optimize&quot; it. Finally the code generator chooses appropriate algorithms to implement the operations requested by the AST and constructs bytecode to carry out those operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bba39e24b4502de9e348487cd65024dc8a8b4825" translate="yes" xml:space="preserve">
          <source>The parser now insists on seeing a semicolon or the end of input before executing a statement. This avoids an accidental disaster if the WHERE keyword is misspelled in an UPDATE or DELETE statement.</source>
          <target state="translated">解析器现在坚持在执行语句之前看到分号或输入的结尾。这就避免了在UPDATE或DELETE语句中,WHERE关键字拼写错误的情况下发生意外灾难。</target>
        </trans-unit>
        <trans-unit id="276468011b3fce8fd043bc0ac6f52f8e374eb1fe" translate="yes" xml:space="preserve">
          <source>The parser used by SQLite is forgiving. It is often possible to use a keyword as an identifier as long as such use does not result in a parsing ambiguity. For example, the statement &quot;CREATE TABLE BEGIN(REPLACE,PRAGMA,END);&quot; is accepted by SQLite, and creates a new table named &quot;BEGIN&quot; with three columns named &quot;REPLACE&quot;, &quot;PRAGMA&quot;, and &quot;END&quot;. Nevertheless, best practice is to avoid using keywords as identifiers. Common techniques used to avoid keyword name collisions include:</source>
          <target state="translated">SQLite使用的解析器是宽容的。只要不造成解析上的歧义,通常可以使用关键字作为标识符。例如,语句 &quot;CREATE TABLE BEGIN(REPLACE,PRAGMA,END);&quot;被SQLite接受,并创建了一个名为 &quot;BEGIN &quot;的新表,其中有三列名为 &quot;REPLACE&quot;、&quot;PRAGMA &quot;和 &quot;END&quot;。尽管如此,最好的做法是避免使用关键字作为标识符。避免关键词名称碰撞的常用技术包括:。</target>
        </trans-unit>
        <trans-unit id="cf399069b7a65af0b661c7a78ceab3a98b1156db" translate="yes" xml:space="preserve">
          <source>The parser's stack was overflowing on a very long UPDATE statement. This is now fixed.</source>
          <target state="translated">在很长的UPDATE语句上,解析器的堆栈溢出。现在已经修复。</target>
        </trans-unit>
        <trans-unit id="a5c83958bfdec6a8c2fd0d74498090055bde1a94" translate="yes" xml:space="preserve">
          <source>The parsing of SQL statements is a significant consumer of CPU cycles in any SQL database engine. On-going efforts to optimize SQLite have caused the developers to spend a lot of time tweaking Lemon to generate faster parsers. These efforts have benefited all users of the Lemon parser generator, not just SQLite. But if Lemon had been a separately maintained tool, it would have been more difficulty to make coordinated changes to both SQLite and Lemon, and as a result not as much optimization would have been accomplished. Hence, the fact that the parser generator tool is included in the source tree for SQLite has turned out to be a net benefit for both the tool itself and for SQLite.</source>
          <target state="translated">在任何SQL数据库引擎中,SQL语句的解析都是CPU周期的重要消耗。为了优化SQLite,开发人员花费了大量的时间来调整Lemon,以生成更快的解析器。这些努力使Lemon解析器生成器的所有用户受益,而不仅仅是SQLite。但是,如果Lemon是一个单独维护的工具,那么对SQLite和Lemon进行协调修改的难度就会更大,结果就不会有那么多的优化。因此,事实证明,解析器生成器工具被包含在SQLite的源码树中,对工具本身和SQLite都是净收益。</target>
        </trans-unit>
        <trans-unit id="7d2ca17144abc28a05044c4d5d55dce18e17a921" translate="yes" xml:space="preserve">
          <source>The part of the name prior to the last &quot;_&quot; exactly matches the name of a virtual table that was created using &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;. (Shadow tables are not recognized for &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual tables&lt;/a&gt; and &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;.)</source>
          <target state="translated">名称中最后一个&amp;ldquo; _&amp;rdquo;之前的部分与使用&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;创建的虚拟表的名称完全匹配。 （&lt;a href=&quot;vtab#epovtab&quot;&gt;同名虚拟表&lt;/a&gt;和&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;无法识别影子表。）</target>
        </trans-unit>
        <trans-unit id="042a9e73444095c51cd83e16473e75bf7e45a5e4" translate="yes" xml:space="preserve">
          <source>The patch level Z was historically only used for bug-fix releases that changed only a small number of code lines.</source>
          <target state="translated">补丁级别Z在历史上只用于只修改少量代码行的错误修复版本。</target>
        </trans-unit>
        <trans-unit id="274dfc20017243c18164f876bdd5c3980ade92fe" translate="yes" xml:space="preserve">
          <source>The path component of the URI specifies the disk file that is the SQLite database to be opened. If the path component is omitted, then the database is stored in a temporary file that will be automatically deleted when the database connection closes. If the authority section is present, then the path is always an absolute pathname. If the authority section is omitted, then the path is an absolute pathname if it begins with the &quot;/&quot; character (ASCII code 0x2f) and is a relative pathname otherwise. On windows, if the absolute path begins with &quot;&lt;b&gt;/&lt;i&gt;X&lt;/i&gt;:/&lt;/b&gt;&quot; where &lt;b&gt;&lt;i&gt;X&lt;/i&gt;&lt;/b&gt; is any single ASCII alphabetic character (&quot;a&quot; through &quot;z&quot; or &quot;A&quot; through &quot;Z&quot;) then the &quot;&lt;b&gt;&lt;i&gt;X:&lt;/i&gt;&lt;/b&gt;&quot; is understood to be the drive letter of the volume containing the file, not the toplevel directory.</source>
          <target state="translated">URI的路径组件指定磁盘文件，该磁盘文件是要打开的SQLite数据库。如果省略路径组件，则数据库存储在一个临时文件中，当数据库连接关闭时，该文件将自动删除。如果存在授权部分，则该路径始终是绝对路径名。如果省略了权限部分，则该路径以&amp;ldquo; /&amp;rdquo;字符（ASCII代码0x2f）开头为绝对路径名，否则为相对路径名。在Windows上，如果绝对路径以&amp;ldquo; &lt;b&gt;/ &lt;i&gt;X&lt;/i&gt;：/&lt;/b&gt; &amp;rdquo; 开头，其中&lt;b&gt;&lt;i&gt;X&lt;/i&gt;&lt;/b&gt;是任何单个ASCII字母字符（&amp;ldquo; a&amp;rdquo;至&amp;ldquo; z&amp;rdquo;或&amp;ldquo; A&amp;rdquo;至&amp;ldquo; Z&amp;rdquo;），则&amp;ldquo; &lt;b&gt;&lt;i&gt;X：&lt;/i&gt;&lt;/b&gt;&amp;ldquo;&amp;rdquo;被理解为是包含文件而不是顶层目录的卷的驱动器号。</target>
        </trans-unit>
        <trans-unit id="f3532ac83d22ad95431b31438dce70e426b9f355" translate="yes" xml:space="preserve">
          <source>The path is optional if the authority is present. If the authority is omitted then the path is required.</source>
          <target state="translated">如果有权限,路径是可选的。如果省略了权限,则路径为必填项。</target>
        </trans-unit>
        <trans-unit id="5dd0cabb7668cbee80844078c73a695152a285b7" translate="yes" xml:space="preserve">
          <source>The pattern matching algorithm used in the default &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; and &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; implementation of SQLite can exhibit O(N&amp;amp;sup2) performance (where N is the number of characters in the pattern) for certain pathological cases. To avoid denial-of-service attacks from miscreants who are able to specify their own LIKE or GLOB patterns, the length of the LIKE or GLOB pattern is limited to SQLITE_MAX_LIKE_PATTERN_LENGTH bytes. The default value of this limit is 50000. A modern workstation can evaluate even a pathological LIKE or GLOB pattern of 50000 bytes relatively quickly. The denial of service problem only comes into play when the pattern length gets into millions of bytes. Nevertheless, since most useful LIKE or GLOB patterns are at most a few dozen bytes in length, paranoid application developers may want to reduce this parameter to something in the range of a few hundred if they know that external users are able to generate arbitrary patterns.</source>
          <target state="translated">默认&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;和&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB中&lt;/a&gt;使用的模式匹配算法对于某些病理情况，SQLite的实现可以表现出O（N＆sup2）性能（其中N是模式中的字符数）。为了避免能够指定自己的LIKE或GLOB模式的恶意者进行的拒绝服务攻击，LIKE或GLOB模式的长度限制为SQLITE_MAX_LIKE_PATTERN_LENGTH字节。此限制的默认值为50000。现代工作站甚至可以相对快速地评估甚至是50000字节的病理LIKE或GLOB模式。仅当模式长度达到数百万个字节时，拒绝服务问题才起作用。不过，由于最有用的LIKE或GLOB模式的长度最多为几十个字节，如果他们知道外部用户能够生成任意模式，则偏执的应用程序开发人员可能希望将此参数减小到几百个范围。</target>
        </trans-unit>
        <trans-unit id="d6c16218a9785941384e3fbed5d84494c8c3a3ec" translate="yes" xml:space="preserve">
          <source>The pattern matching algorithm used in the default &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; and &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; implementation of SQLite can exhibit O(N&amp;sup2;) performance (where N is the number of characters in the pattern) for certain pathological cases. To avoid denial-of-service attacks from miscreants who are able to specify their own LIKE or GLOB patterns, the length of the LIKE or GLOB pattern is limited to SQLITE_MAX_LIKE_PATTERN_LENGTH bytes. The default value of this limit is 50000. A modern workstation can evaluate even a pathological LIKE or GLOB pattern of 50000 bytes relatively quickly. The denial of service problem only comes into play when the pattern length gets into millions of bytes. Nevertheless, since most useful LIKE or GLOB patterns are at most a few dozen bytes in length, paranoid application developers may want to reduce this parameter to something in the range of a few hundred if they know that external users are able to generate arbitrary patterns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="202855d0443faeb5dfa8c360619529b04d6a4b20" translate="yes" xml:space="preserve">
          <source>The people table has one entry for each person in a large organization. Each person is either a &quot;student&quot; or a &quot;teacher&quot;, as determined by the &quot;role&quot; field. And we record the height in centimeters of each person. The role and height are indexed. Notice that the left-most column of the index is not very selective - it only contains two possible values.</source>
          <target state="translated">人员表为一个大型组织中的每个人设置了一个条目。每个人要么是 &quot;学生&quot;,要么是 &quot;老师&quot;,由 &quot;角色 &quot;字段决定。而我们记录的是每个人的身高,单位是厘米。角色和身高是有索引的。请注意,索引的最左边一列不是很有选择性--它只包含两个可能的值。</target>
        </trans-unit>
        <trans-unit id="92b29d0fa9a5e447b11571a63811cd4169611d21" translate="yes" xml:space="preserve">
          <source>The per-connection statistics do not use global variables and hence do not require mutexes to update or access. Consequently the per-connection statistics continue to function even if &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is turned off.</source>
          <target state="translated">每个连接的统计信息不使用全局变量，因此不需要互斥来更新或访问。因此，即使关闭了&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;，每个连接的统计信息仍继续起作用。</target>
        </trans-unit>
        <trans-unit id="50dbff919de02c3f0e66d4c1de101521648ed2d5" translate="yes" xml:space="preserve">
          <source>The performance can be improved slightly by bypassing the SQL layer and reading the blob content directly using the &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; interface, as shown in the next chart:</source>
          <target state="translated">通过绕过SQL层并使用&lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;接口直接读取blob内容，可以稍微提高性能，如下图所示：</target>
        </trans-unit>
        <trans-unit id="095c3d78e34e00649d5524d5d46327c65695f40f" translate="yes" xml:space="preserve">
          <source>The performance difference arises (we believe) because when working from an SQLite database, the open() and close() system calls are invoked only once, whereas open() and close() are invoked once for each blob when using blobs stored in individual files. It appears that the overhead of calling open() and close() is greater than the overhead of using the database. The size reduction arises from the fact that individual files are padded out to the next multiple of the filesystem block size, whereas the blobs are packed more tightly into an SQLite database.</source>
          <target state="translated">性能差异的产生(我们认为)是因为当从SQLite数据库工作时,open()和close()系统调用只被调用一次,而当使用存储在单个文件中的blob时,每个blob都要调用一次open()和close()。看来,调用open()和close()的开销大于使用数据库的开销。文件大小的减小是因为单个文件被填充到文件系统块大小的下一个倍数,而blob则被更紧密地打包到SQLite数据库中。</target>
        </trans-unit>
        <trans-unit id="2a5a29c317c697ba64096b7f2c68033b4565ac42" translate="yes" xml:space="preserve">
          <source>The permutation is only valid until the next &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; that has the OPFLAG_PERMUTE bit set in P5. Typically the &lt;a href=&quot;opcode#Permutation&quot;&gt;Permutation&lt;/a&gt; should occur immediately prior to the &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt;.</source>
          <target state="translated">该排列仅在下一个在P5中将OPFLAG_PERMUTE位置1的&lt;a href=&quot;opcode#Compare&quot;&gt;比较&lt;/a&gt;之前有效。通常，&lt;a href=&quot;opcode#Permutation&quot;&gt;排列&lt;/a&gt;应该在&lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt;之前立即进行。</target>
        </trans-unit>
        <trans-unit id="645402751e5b5ab0dd0504759786ac3f99e9f97b" translate="yes" xml:space="preserve">
          <source>The persistence of WAL mode means that applications can be converted to using SQLite in WAL mode without making any changes to the application itself. One has merely to run &quot;&lt;code&gt;PRAGMA journal_mode=WAL;&lt;/code&gt;&quot; on the database file(s) using the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; or other utility, then restart the application.</source>
          <target state="translated">WAL模式的持久性意味着可以在WAL模式下使用SQLite将应用程序转换为应用程序，而无需对应用程序本身进行任何更改。只需使用&lt;a href=&quot;cli&quot;&gt;命令行Shell&lt;/a&gt;或其他实用程序在数据库文件上运行&amp;ldquo; &lt;code&gt;PRAGMA journal_mode=WAL;&lt;/code&gt; &amp;rdquo; ，然后重新启动应用程序。</target>
        </trans-unit>
        <trans-unit id="37f0ea5f181b03035443f3a918ec838d5bf0f5c4" translate="yes" xml:space="preserve">
          <source>The phrase &quot;VALUES(</source>
          <target state="translated">这句话 &quot;VALUES(</target>
        </trans-unit>
        <trans-unit id="afda55d9895c016a5496f6b600205dbf8fbc7d06" translate="yes" xml:space="preserve">
          <source>The planner avoids query plans that use indexes with unknown collating functions.</source>
          <target state="translated">规划器避免使用具有未知整理函数的索引的查询计划。</target>
        </trans-unit>
        <trans-unit id="926646f3fb08c1ad8acc73155c7f0bcd303e689e" translate="yes" xml:space="preserve">
          <source>The planner omits unused LEFT JOINs even if they are not the right-most joins of a query.</source>
          <target state="translated">规划器会省略未使用的LEFT JOIN,即使它们不是查询的最右边的连接。</target>
        </trans-unit>
        <trans-unit id="5852e8af03eff264841e6547e952b8e08ad085dc" translate="yes" xml:space="preserve">
          <source>The platform used for these tests is a 1.6GHz Athlon with 1GB or memory and an IDE disk drive. The operating system is RedHat Linux 7.2 with a stock kernel.</source>
          <target state="translated">这些测试使用的平台是1.6GHz的Athlon,1GB或内存和IDE磁盘驱动器。操作系统为RedHat Linux 7.2,内核为普通内核。</target>
        </trans-unit>
        <trans-unit id="e614d538ab4445c07af270ecdc6677ad39ccfb17" translate="yes" xml:space="preserve">
          <source>The point is this: an SQL database schema almost always does a far better job of defining and organizing the tables and data structures and their relationships. And having clear, concise, and well-defined representation almost always results in an application that performs better, has fewer problems, and is easier to develop and maintain.</source>
          <target state="translated">重点是:SQL数据库模式几乎总是在定义和组织表和数据结构及其关系方面做得更好。而拥有清晰、简明和定义良好的表示方式,几乎总是能使应用程序的性能更好,问题更少,更容易开发和维护。</target>
        </trans-unit>
        <trans-unit id="1249a327a44d56131079defe491a7680b8885a62" translate="yes" xml:space="preserve">
          <source>The pointer arguments to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; must be either NULL or else pointers obtained from a prior invocation of &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; that have not yet been released.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;的指针参数必须为NULL，否则必须是从先前调用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;之前尚未释放的指针中获得的指针。</target>
        </trans-unit>
        <trans-unit id="70d5983c94ca6fdbfd5d05e2d8f25d536fa0e2f9" translate="yes" xml:space="preserve">
          <source>The pointer arguments to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; and &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; must be either NULL or else pointers obtained from a prior invocation of &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; that have not yet been released.</source>
          <target state="translated">&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;和&lt;a href=&quot;free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;的指针参数必须为NULL，否则必须是从先前调用&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;或&lt;a href=&quot;free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;之前尚未释放的指针中获得的指针。</target>
        </trans-unit>
        <trans-unit id="19e21383ec674e61332285628bf7a07277fe3452" translate="yes" xml:space="preserve">
          <source>The pointer type is not intended to be flexible and dynamic. The pointer type is intended to be a design-time constant. Applications should not synthesize pointer type strings at run-time. Providing support for dynamic pointer type strings would lead developers to misuse the pointer-passing interfaces by creating run-time synthesized pointer type strings. Requiring the pointer type strings to be static encourages developers to do the right thing by choosing fixed pointer type names at design-time and encoding those names as constant strings.</source>
          <target state="translated">指针类型不是为了灵活和动态。指针类型旨在成为设计时的常量,应用程序不应该在运行时合成指针类型字符串。应用程序不应在运行时合成指针类型字符串。提供对动态指针类型字符串的支持会导致开发人员通过创建运行时合成的指针类型字符串来滥用指针传递接口。要求指针类型字符串是静态的,会鼓励开发人员在设计时选择固定的指针类型名称,并将这些名称编码为常量字符串,从而做正确的事情。</target>
        </trans-unit>
        <trans-unit id="0a50e253ab7c267f33ad3d5a3deec486738946df" translate="yes" xml:space="preserve">
          <source>The pointers returned are valid until a type conversion occurs as described above, or until &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; is called. The memory space used to hold strings and BLOBs is freed automatically. Do not pass the pointers returned from &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_blob()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, etc. into &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">返回的指针有效，直到如上所述发生类型转换，或者直到调用&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;为止。用于保存字符串和BLOB的内存空间会自动释放。不要将从&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_blob（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text（）&lt;/a&gt;等返回的指针传递到&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3551cf33afa7b1894cdea20e6326c2bf8dcf19de" translate="yes" xml:space="preserve">
          <source>The pointers returned are valid until a type conversion occurs as described above, or until &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; is called. The memory space used to hold strings and BLOBs is freed automatically. Do not pass the pointers returned from &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_blob()&lt;/a&gt;, &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, etc. into &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">返回的指针有效，直到如上所述发生类型转换，或者直到调用&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;或&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;或&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;为止。用于保存字符串和BLOB的内存空间会自动释放。不要将从&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_blob（）&lt;/a&gt;，&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text（）&lt;/a&gt;等返回的指针传递到&lt;a href=&quot;free&quot;&gt;sqlite3_free（）中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9edff31b2dc071eb66ab4aa44d22adfef6b1aa3c" translate="yes" xml:space="preserve">
          <source>The pointers that piggy-back on SQL NULL values using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;, and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; interface are transient and ephemeral. The pointers are never written into the database. The pointers will not survive sorting. The latter fact is why there is no sqlite3_column_pointer() interface, since it is impossible to predict whether or not the query planner will insert a sort operation prior to returning a value from a query, so it would be impossible to know if a pointer value inserted into a query by &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; or &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; would survive through to the result set.</source>
          <target state="translated">使用&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;，&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;和&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;接口搭载SQL NULL值的指针是临时的和短暂的。指针永远不会写入数据库。指针将无法生存排序。后一个事实是为什么没有sqlite3_column_pointer（）接口的原因，因为无法预测查询计划程序是否会在从查询返回值之前插入排序操作，因此将无法知道指针值由&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;或&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;插入查询中将保留到结果集。</target>
        </trans-unit>
        <trans-unit id="41025b56b1d99416ab106417d2e02a42b25af90e" translate="yes" xml:space="preserve">
          <source>The porter tokenizer is a wrapper tokenizer. It takes the output of some other tokenizer and applies the &lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;porter stemming algorithm&lt;/a&gt; to each token before it returns it to FTS5. This allows search terms like &quot;correction&quot; to match similar words such as &quot;corrected&quot; or &quot;correcting&quot;. The porter stemmer algorithm is designed for use with English language terms only - using it with other languages may or may not improve search utility.</source>
          <target state="translated">搬运程序标记器是包装标记器。这需要一些其他标记生成器的输出，并应用&lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;波特词干算法&lt;/a&gt;给每个令牌它返回到FTS5之前。这允许像&amp;ldquo;更正&amp;rdquo;之类的搜索字词匹配类似&amp;ldquo;更正&amp;rdquo;或&amp;ldquo;更正&amp;rdquo;之类的词。搬运工词干分析器算法仅设计用于英语术语-与其他语言一起使用可能会或可能不会提高搜索实用性。</target>
        </trans-unit>
        <trans-unit id="8db274801095c26d088720201acb1bad2d40d917" translate="yes" xml:space="preserve">
          <source>The power of an SQLite database could, in theory, be achieved using a custom file format. But any custom file format that is as expressive as a relational database would likely require an enormous design specification and many tens or hundreds of thousands of lines of code to implement. And the end result would be an &quot;opaque blob&quot; that is inaccessible without specialized tools.</source>
          <target state="translated">理论上,SQLite数据库的强大功能可以通过使用自定义文件格式来实现。但是,任何像关系型数据库一样具有表现力的自定义文件格式都很可能需要一个庞大的设计规范和几万行或几十万行的代码来实现。而最终的结果将是一个 &quot;不透明的小球&quot;,没有专门的工具是无法进入的。</target>
        </trans-unit>
        <trans-unit id="4938c1fbe50ea261772ee32f2ec000b4cb6af37b" translate="yes" xml:space="preserve">
          <source>The powersafe overwrite property for individual databases can be specified as the database is opened using the &quot;psow&quot; query parameter with a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. For example, to always assume powersafe overwrite for a file (perhaps to ensure maximum write performance), open it as</source>
          <target state="translated">当使用带有&lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;的&amp;ldquo; psow&amp;rdquo;查询参数打开数据库时，可以指定各个数据库的powersafe overwrite属性。例如，要始终假定文件的电源安全覆盖（可能是为了确保最大的写入性能），请以</target>
        </trans-unit>
        <trans-unit id="67790abdb6b576eda27fab78ba503267f5a114fa" translate="yes" xml:space="preserve">
          <source>The powersafe overwrite property says nothing about the state of the bytes that were written. Those bytes might contain their old values, their new values, random values, or some combination of these. The powersafe overwrite property merely states that writes cannot change bytes outside of the range of bytes written.</source>
          <target state="translated">powersafe overwrite 属性对被写入的字节的状态没有任何说明。这些字节可能包含了它们的旧值、新值、随机值,或者它们的某种组合。powersafe overwrite属性只是说明写入不能改变写入的字节范围之外的字节。</target>
        </trans-unit>
        <trans-unit id="1389e8d5f9998cc48b0c99ae215e31d8f358ccd0" translate="yes" xml:space="preserve">
          <source>The pragma command is specific to SQLite and is not compatible with any other SQL database engine.</source>
          <target state="translated">pragma命令是针对SQLite的,与其他任何SQL数据库引擎都不兼容。</target>
        </trans-unit>
        <trans-unit id="f45ce9f6459acccc6664213a9c9d236d0392b096" translate="yes" xml:space="preserve">
          <source>The pragma is like &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check&lt;/a&gt; except that it does not verify UNIQUE constraints and does not verify that index content matches table content. By skipping UNIQUE and index consistency checks, quick_check is able to run faster. PRAGMA quick_check runs in O(N) time whereas &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; requires O(NlogN) time where N is the total number of rows in the database. Otherwise the two pragmas are the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b9cdfdccce2f8d840c93537988a1d96c50df274" translate="yes" xml:space="preserve">
          <source>The pragma is like &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check&lt;/a&gt; except that it does not verify UNIQUE constraints and does not verify that index content matches table content. By skipping UNIQUE and index consistency checks, quick_check is able to run much faster than integrity_check. Otherwise the two pragmas are the same.</source>
          <target state="translated">该编译指示类似于&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;完整性检查，&lt;/a&gt;不同之处在于它不验证UNIQUE约束并且不验证索引内容是否与表内容匹配。通过跳过UNIQUE和索引一致性检查，quick_check的运行速度比完整性完整性检查要快得多。否则，两个语用相同。</target>
        </trans-unit>
        <trans-unit id="da60401a603e537afbb64f9be897b6e57271b0ee" translate="yes" xml:space="preserve">
          <source>The pre-update hook</source>
          <target state="translated">预更新钩子</target>
        </trans-unit>
        <trans-unit id="77a94c0ef3120048af1c78a5031b2bc8f51341cf" translate="yes" xml:space="preserve">
          <source>The pre-update hook.</source>
          <target state="translated">预更新的勾当。</target>
        </trans-unit>
        <trans-unit id="464d49040a7350ab38dd3a440629e97d8425be1c" translate="yes" xml:space="preserve">
          <source>The precautions above are not required in order to use SQLite safely with potentially hostile inputs. However, they do provide an extra layer of defense against zero-day exploits and are encouraged for applications that pass data from untrusted sources into SQLite.</source>
          <target state="translated">为了安全地使用SQLite与潜在的敌对输入,上述预防措施不是必需的。然而,它们确实提供了一个额外的防御层,以防止零日漏洞,并鼓励将来自不受信任来源的数据传递到SQLite的应用程序。</target>
        </trans-unit>
        <trans-unit id="05bf811875969018cb62c264a6781abc17b442f0" translate="yes" xml:space="preserve">
          <source>The precedence order for ON CONFLICT clauses was changed so that ON CONFLICT clauses on BEGIN statements have a higher precedence than ON CONFLICT clauses on constraints.</source>
          <target state="translated">改变了ON CONFLICT子句的优先顺序,使BEGIN语句上的ON CONFLICT子句比约束条件上的ON CONFLICT子句具有更高的优先权。</target>
        </trans-unit>
        <trans-unit id="122c8023ebc9769b59f3a1882e33d76b3169c9fd" translate="yes" xml:space="preserve">
          <source>The preceding paragraphs contain a lot of information. To ease the task of constructing a new VFS for SQLite we offer the following implementation checklist:</source>
          <target state="translated">前面的段落包含了很多信息。为了简化为SQLite构建一个新的VFS的任务,我们提供了以下的实施检查表。</target>
        </trans-unit>
        <trans-unit id="661723ea54e783ccd80036c290bfdccff5b43478" translate="yes" xml:space="preserve">
          <source>The precision field, if it is present, must follow the width separated by a single &quot;.&quot; character. If there is no width, then the &quot;.&quot; that introduces the precision immediately follows either the flags (if there are any) or the initial &quot;%&quot;.</source>
          <target state="translated">如果有精度字段,必须在宽度后面用一个&quot;.&quot;字符隔开。如果没有宽度,那么引入精度的&quot;.&quot;字段紧跟在标志(如果有的话)或初始&quot;%&quot;之后。</target>
        </trans-unit>
        <trans-unit id="1f4e06f8dccb411ae11d13e1945ae927355460b6" translate="yes" xml:space="preserve">
          <source>The precision provided by IEEE 754 Binary64 is sufficient for most computations. For example, if &quot;47.49&quot; represents a price and inflation is running at 2% per year, then the price is going up by about 0.0000000301 dollars per second. The error in the recorded value of 47.49 represents about 66 nanoseconds worth of inflation. So if the 47.49 price is exact when you enter it, then the effects of inflation will cause the true value to exactly equal the value actually stored (47.4900000000000019895196601282805204391479492187) in less than one ten-millionth of a second. Surely that level of precision is sufficient for most purposes?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="274c336721e63c209854a5c06e41f1f163132ddd" translate="yes" xml:space="preserve">
          <source>The preferred routine to use is &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface is legacy and should be avoided. &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; has an extra &quot;prepFlags&quot; option that is used for special purposes.</source>
          <target state="translated">首选使用的例程是&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;。该&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;接口是传统的，应当避免。&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;有一个额外的&amp;ldquo; prepFlags&amp;rdquo;选项，用于特殊目的。</target>
        </trans-unit>
        <trans-unit id="2a1d33401c2095551ef53ebdb2c936c2ab4e7f75" translate="yes" xml:space="preserve">
          <source>The preferred routine to use is &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. The &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface is legacy and should be avoided. &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; has an extra &quot;prepFlags&quot; option that is used for special purposes.</source>
          <target state="translated">首选使用的例程是&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;。该&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;接口是传统的，应当避免。&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;有一个额外的&amp;ldquo; prepFlags&amp;rdquo;选项，用于特殊目的。</target>
        </trans-unit>
        <trans-unit id="e5802699120466acd022e1fa07d198c436289856" translate="yes" xml:space="preserve">
          <source>The prefix on temporary filenames on Windows is changed from &quot;sqlite&quot; to &quot;etilqs&quot;.</source>
          <target state="translated">Windows上临时文件名的前缀由 &quot;sqlite &quot;改为 &quot;etilqs&quot;。</target>
        </trans-unit>
        <trans-unit id="f3230410aa1ec23cdd51b1c85ef3e6e8a5bf6364" translate="yes" xml:space="preserve">
          <source>The presence of a busy handler does not guarantee that it will be invoked when there is lock contention. If SQLite determines that invoking the busy handler could result in a deadlock, it will go ahead and return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; to the application instead of invoking the busy handler. Consider a scenario where one process is holding a read lock that it is trying to promote to a reserved lock and a second process is holding a reserved lock that it is trying to promote to an exclusive lock. The first process cannot proceed because it is blocked by the second and the second process cannot proceed because it is blocked by the first. If both processes invoke the busy handlers, neither will make any progress. Therefore, SQLite returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; for the first process, hoping that this will induce the first process to release its read lock and allow the second process to proceed.</source>
          <target state="translated">繁忙处理程序的存在并不能保证在存在锁争用时将调用该处理程序。如果SQLite确定调用繁忙处理程序可能导致死锁，它将继续执行并将&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;返回给应用程序，而不是调用繁忙处理程序。考虑一个场景，其中一个进程持有试图将其提升为保留锁的读取锁，而第二个进程持有试图将其提升为排他锁的保留锁。第一个进程无法进行，因为它被第二个进程阻止，第二个进程无法进行，因为它被第一个进程阻止。如果两个进程都调用繁忙的处理程序，则两者都不会取得任何进展。因此，SQLite返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;对于第一个进程，希望这将导致第一个进程释放其读取锁并允许第二个进程继续进行。</target>
        </trans-unit>
        <trans-unit id="f52f9d0c779543db7a531d457708b0c4e1e3b230" translate="yes" xml:space="preserve">
          <source>The presence of a busy handler does not guarantee that it will be invoked when there is lock contention. If SQLite determines that invoking the busy handler could result in a deadlock, it will go ahead and return &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; to the application instead of invoking the busy handler. Consider a scenario where one process is holding a read lock that it is trying to promote to a reserved lock and a second process is holding a reserved lock that it is trying to promote to an exclusive lock. The first process cannot proceed because it is blocked by the second and the second process cannot proceed because it is blocked by the first. If both processes invoke the busy handlers, neither will make any progress. Therefore, SQLite returns &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; for the first process, hoping that this will induce the first process to release its read lock and allow the second process to proceed.</source>
          <target state="translated">繁忙处理程序的存在并不能保证在存在锁争用时将调用该处理程序。如果SQLite确定调用繁忙处理程序可能导致死锁，它将继续执行并将&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;返回给应用程序，而不是调用繁忙处理程序。考虑一个场景，其中一个进程持有试图将其提升为保留锁的读取锁，而第二个进程持有试图将其提升为排他锁的保留锁。第一个进程无法进行，因为它被第二个进程阻止，第二个进程无法进行，因为它被第一个进程阻止。如果两个进程都调用繁忙的处理程序，则两者都不会取得任何进展。因此，SQLite返回&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;对于第一个进程，希望这将导致第一个进程释放其读取锁并允许第二个进程继续进行。</target>
        </trans-unit>
        <trans-unit id="b2efda84ef1340b69a62f5b61118269d4141c529" translate="yes" xml:space="preserve">
          <source>The presence of a hot journal is our indication that a previous process was trying to commit a transaction but it aborted for some reason prior to the completion of the commit. A hot journal means that the database file is in an inconsistent state and needs to be repaired (by rollback) prior to being used.</source>
          <target state="translated">热日志的存在是我们的指示,表明前一个进程正试图提交一个事务,但在完成提交之前因某种原因而中止。热日志意味着数据库文件处于不一致的状态,需要在使用前进行修复(通过回滚)。</target>
        </trans-unit>
        <trans-unit id="53e2bd6dac9cbbc9b06c74e123d964800e4d3352" translate="yes" xml:space="preserve">
          <source>The presence of the &quot;noskipscan&quot; token on the sqlite_stat1.stat field of an index prevents that index from being used with the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt;.</source>
          <target state="translated">索引的sqlite_stat1.stat字段上存在&amp;ldquo; noskipscan&amp;rdquo;令牌，这会阻止该索引与&lt;a href=&quot;optoverview#skipscan&quot;&gt;跳过扫描优化配合使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a01f573624c54e96d01f0d23d0ba8b3593807a0a" translate="yes" xml:space="preserve">
          <source>The presentation of the query planner problem above is a simplification. The costs are estimates. We cannot know what the true cost of running a loop is until we actually run the loop. SQLite makes guesses for the cost of running a loop based on the availability of indexes and constraints found in the WHERE clause. These guesses are usually pretty good, but they can sometimes be off. Using the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command to collect additional statistical information about the database can sometimes enable SQLite to make better guesses about the cost.</source>
          <target state="translated">上面查询规划器问题的表示是一种简化。费用是估计数。在实际运行循环之前，我们不知道运行循环的真正成本是多少。SQLite根据在WHERE子句中找到的索引和约束的可用性来猜测运行循环的成本。这些猜测通常是很好的，但有时可能会落空。使用&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令收集有关数据库的其他统计信息有时可以使SQLite对成本进行更好的猜测。</target>
        </trans-unit>
        <trans-unit id="1c32ea8c1623df88595d5e28c3a4322ef70e185f" translate="yes" xml:space="preserve">
          <source>The preupdate hook interfaces were originally added to support the &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; extension.</source>
          <target state="translated">最初添加了preupdate挂钩接口以支持&lt;a href=&quot;sessionintro&quot;&gt;会话&lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="54aaab8c82da084a0f8a9658f2bc76535e494e38" translate="yes" xml:space="preserve">
          <source>The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; or to system tables like sqlite_master or sqlite_stat1.</source>
          <target state="translated">preupdate挂钩仅在更改实际数据库表时触发。对于&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;或系统表（如sqlite_master或sqlite_stat1）的更改，不会调用preupdate挂钩。</target>
        </trans-unit>
        <trans-unit id="56711536eb144f6abbe43b67b69a4f340bd68f45" translate="yes" xml:space="preserve">
          <source>The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; or to system tables like sqlite_sequence or sqlite_stat1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f619ca19c48dc2cd5df5d0de6abefa9c15ce6509" translate="yes" xml:space="preserve">
          <source>The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; or to system tables like sqlite_master or sqlite_stat1.</source>
          <target state="translated">preupdate挂钩仅在更改实际数据库表时触发。对于&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;或系统表（如sqlite_master或sqlite_stat1）的更改，不会调用preupdate挂钩。</target>
        </trans-unit>
        <trans-unit id="f6985f034f86292cf6702a3b24e4e0140c1d7b08" translate="yes" xml:space="preserve">
          <source>The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; or to system tables like sqlite_sequence or sqlite_stat1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548d335209dbce4d25a40d42ac27b0b5a00affc4" translate="yes" xml:space="preserve">
          <source>The previous discussion has treated searching and sorting as separate topics. But in practice, it is often the case that one wants to search and sort at the same time. Fortunately, it is possible to do this using a single index.</source>
          <target state="translated">前面的讨论已经把搜索和排序作为单独的主题。但在实际操作中,经常会出现想同时进行搜索和排序的情况。幸运的是,使用一个单一的索引就可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="5a894252915223aa28176cd8caebb845eabbbe5b" translate="yes" xml:space="preserve">
          <source>The previous example is a specific case of a more general problem: The state of an SQLite database is controlled by both the database file and the journal file. In a quiescent state, the journal file does not exist and only the database file matters. But if the journal file does exist, it must be kept together with the database to avoid corruption. The following actions are all likely to lead to corruption:</source>
          <target state="translated">前面的例子是一个比较普遍的问题的具体案例:一个SQLite数据库的状态是由数据库文件和日志文件控制的。在静止状态下,日志文件不存在,只有数据库文件重要。但如果日志文件确实存在,则必须与数据库一起保存,以避免损坏。以下操作都有可能导致损坏。</target>
        </trans-unit>
        <trans-unit id="96495b049cd011fd87b80d69ae6b3a8f79a60e9a" translate="yes" xml:space="preserve">
          <source>The previous example will return every row for which the _shape overlaps the polygon in the $query_polygon parameter. The geopoly_within() function works similarly, but only returns rows for which the _shape is completely contained within $query_polygon.</source>
          <target state="translated">前面的例子将返回$query_polygon参数中_shape与多边形重合的每一条记录。geopoly_within()函数的工作原理类似,但是只返回那些_形状完全包含在$query_polygon参数中的行。</target>
        </trans-unit>
        <trans-unit id="493e14ba39e9f9ab43ab64d3b6be4b87292ba69a" translate="yes" xml:space="preserve">
          <source>The previous example, SQLite uses index &quot;i1&quot; to optimize a WHERE clause term of the form (a=?) - in this case &quot;a=1&quot;. The previous example could not use a &lt;a href=&quot;queryplanner#covidx&quot;&gt;covering index&lt;/a&gt;, but the following example can, and that fact is reflected in the output:</source>
          <target state="translated">在前面的示例中，SQLite使用索引&amp;ldquo; i1&amp;rdquo;来优化形式（a =？）的WHERE子句项-在这种情况下为&amp;ldquo; a = 1&amp;rdquo;。前面的示例不能使用&lt;a href=&quot;queryplanner#covidx&quot;&gt;coverage索引&lt;/a&gt;，但是下面的示例可以使用，并且事实反映在输出中：</target>
        </trans-unit>
        <trans-unit id="69c7b95e4071269d47577736bbe07ea0a083b117" translate="yes" xml:space="preserve">
          <source>The previous fix was not quite right. This one seems to work better.</source>
          <target state="translated">之前的修复方法不太正确。这个似乎比较好用。</target>
        </trans-unit>
        <trans-unit id="fdab229cc2f18edd4b33bcf4f2dc07383013038b" translate="yes" xml:space="preserve">
          <source>The previous paragraph describes what happens when the synchronous pragma setting is &quot;full&quot;.</source>
          <target state="translated">上一段介绍了当同步pragma设置为 &quot;满 &quot;时的情况。</target>
        </trans-unit>
        <trans-unit id="af577bd70a120b3a01a3ee4e9c639a65b514f294" translate="yes" xml:space="preserve">
          <source>The previous paragraph is also true (separate database connections are isolated from one another) in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; as long as the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; remains turned off. The &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; is off by default and so if the application does nothing to turn it on, it will remain off. Hence, unless the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; is used to change the default behavior, changes made by one database connection are invisible to readers on a different database connection sharing the same cache until the writer commits its transaction.</source>
          <target state="translated">只要保持&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted编译指示&lt;/a&gt;处于关闭状态，上一段在&lt;a href=&quot;sharedcache&quot;&gt;共享缓存模式下&lt;/a&gt;也是正确的（独立的数据库连接彼此隔离）。该&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;READ_UNCOMMITTED编译&lt;/a&gt;默认是关闭的，因此，如果应用程序没有采取任何措施打开它，它会保持关闭状态。因此，除非使用&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted编译指示&lt;/a&gt;来更改默认行为，否则共享共享缓存的另一个数据库连接上的读取器将看不到一个数据库连接所做的更改，直到写入器提交其事务为止。</target>
        </trans-unit>
        <trans-unit id="4443bdbe2499eab3d6d488e897e8d552fc707661" translate="yes" xml:space="preserve">
          <source>The previous paragraph states that SQLite does not assume that sector writes are atomic. This is true by default. But as of SQLite version 3.5.0, there is a new interface called the Virtual File System (&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;) interface. The &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; is the only means by which SQLite communicates to the underlying filesystem. The code comes with default VFS implementations for Unix and Windows and there is a mechanism for creating new custom VFS implementations at runtime. In this new VFS interface there is a method called xDeviceCharacteristics. This method interrogates the underlying filesystem to discover various properties and behaviors that the filesystem may or may not exhibit. The xDeviceCharacteristics method might indicate that sector writes are atomic, and if it does so indicate, SQLite will try to take advantage of that fact. But the default xDeviceCharacteristics method for both Unix and Windows does not indicate atomic sector writes and so these optimizations are normally omitted.</source>
          <target state="translated">上一段指出，SQLite不假定扇区写入是原子的。默认情况下是这样。但是从SQLite版本3.5.0开始，有一个称为虚拟文件系统（&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;）接口的新接口。该&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;是SQLite与基础文件系统通信的唯一方法。该代码随附用于Unix和Windows的默认VFS实现，并且提供了一种在运行时创建新的自定义VFS实现的机制。在这个新的VFS接口中，有一个称为xDeviceCharacteristics的方法。此方法询问基础文件系统，以发现文件系统可能会或可能不会出现的各种属性和行为。 xDeviceCharacteristics方法可能表明扇区写是原子的，如果这样做表明SQLite将尝试利用这一事实。但是，对于Unix和Windows，默认的xDeviceCharacteristics方法并不指示原子扇区写入，因此通常会省略这些优化。</target>
        </trans-unit>
        <trans-unit id="342bf4dfcd7ddbf3e5538a244e6458410341ab97" translate="yes" xml:space="preserve">
          <source>The previous paragraphs describe the behavior of temporary databases under the default SQLite configuration. An application can use the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; and the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter to force temporary databases to behave as pure in-memory databases, if desired.</source>
          <target state="translated">前面的段落描述了默认SQLite配置下临时数据库的行为。如果需要，应用程序可以使用&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;和&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;编译时参数来强制临时数据库表现为纯内存数据库。</target>
        </trans-unit>
        <trans-unit id="6e1f293bab97b2b5f7895a766acf571a1f59dca9" translate="yes" xml:space="preserve">
          <source>The previous query is equivalent to the following:</source>
          <target state="translated">前面的查询相当于下面的查询:</target>
        </trans-unit>
        <trans-unit id="2a8f5ff04cf0666d4b31c9cd45d0419954ccab05" translate="yes" xml:space="preserve">
          <source>The previous step created circle (1) in the diagram above. This step will create circle (2). Run the following command:</source>
          <target state="translated">上一步在上图中创建了圆(1)。这一步将创建圆圈(2)。运行以下命令。</target>
        </trans-unit>
        <trans-unit id="73d4cf9a53d1a814d3d61247ac59a2dcf02d4a89" translate="yes" xml:space="preserve">
          <source>The primary page cache implementation is in the &lt;a href=&quot;https://sqlite.org/src/file/src/pager.c&quot;&gt;pager.c&lt;/a&gt; file. &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; logic is in the separate &lt;a href=&quot;https://sqlite.org/src/file/src/wal.c&quot;&gt;wal.c&lt;/a&gt;. In-memory caching is implemented by the &lt;a href=&quot;https://sqlite.org/src/file/src/pcache.c&quot;&gt;pcache.c&lt;/a&gt; and &lt;a href=&quot;https://sqlite.org/src/file/src/pcache1.c&quot;&gt;pcache1.c&lt;/a&gt; files. The interface between page cache subsystem and the rest of SQLite is defined by the header file &lt;a href=&quot;https://sqlite.org/src/file/src/pager.h&quot;&gt;pager.h&lt;/a&gt;.</source>
          <target state="translated">主页面缓存实现位于&lt;a href=&quot;https://sqlite.org/src/file/src/pager.c&quot;&gt;pager.c&lt;/a&gt;文件中。&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;逻辑在单独的&lt;a href=&quot;https://sqlite.org/src/file/src/wal.c&quot;&gt;wal.c中&lt;/a&gt;。内存中缓存由&lt;a href=&quot;https://sqlite.org/src/file/src/pcache.c&quot;&gt;pcache.c&lt;/a&gt;和&lt;a href=&quot;https://sqlite.org/src/file/src/pcache1.c&quot;&gt;pcache1.c&lt;/a&gt;文件实现。页面缓存子系统和其余SQLite之间的接口&lt;a href=&quot;https://sqlite.org/src/file/src/pager.h&quot;&gt;由头&lt;/a&gt;文件pager.h定义。</target>
        </trans-unit>
        <trans-unit id="01bd1fccd0eb574f8649d147f7495318ef2ed3aa" translate="yes" xml:space="preserve">
          <source>The primary use of Lemon is to create the SQL language parser. A grammar file (&lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y&lt;/a&gt;) is compiled by Lemon into parse.c and parse.h. The parse.c file is incorporated into the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; without further modification.</source>
          <target state="translated">Lemon的主要用途是创建SQL语言解析器。Lemon将一个语法文件（&lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y&lt;/a&gt;）编译为parse.c和parse.h。parse.c文件无需进一步修改即可合并到&lt;a href=&quot;amalgamation&quot;&gt;合并中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c694d6e20cc8030ef2cf2b05c8cbbbe628062074" translate="yes" xml:space="preserve">
          <source>The principal task of an SQL database engine is to evaluate SQL statements of SQL. To accomplish this, the developer needs two objects:</source>
          <target state="translated">SQL数据库引擎的主要任务是评估SQL的SQL语句。为了完成这个任务,开发者需要两个对象。</target>
        </trans-unit>
        <trans-unit id="cfcb012162b1a505da1f19d8786ad1f42bcacc75" translate="yes" xml:space="preserve">
          <source>The principle difference between FTS3/4 and FTS5 is that in FTS3/4, each instance-list is stored as a single large database record, whereas in FTS5 large instance-lists are divided between multiple database records. This has the following implications for dealing with large databases that contain large lists:</source>
          <target state="translated">FTS3/4和FTS5之间的主要区别是,在FTS3/4中,每个实例列表都作为一个大的数据库记录存储,而在FTS5中,大的实例列表在多个数据库记录之间划分。这对处理包含大型列表的大型数据库有以下影响。</target>
        </trans-unit>
        <trans-unit id="d7231b054e5abc6f0cfc5cc85f7e3279373f74d4" translate="yes" xml:space="preserve">
          <source>The printf() in SQLite supports new non-standard substitution types (&lt;a href=&quot;printf#percentq&quot;&gt;%q&lt;/a&gt;, &lt;a href=&quot;printf#percentq&quot;&gt;%Q&lt;/a&gt;, &lt;a href=&quot;printf#percentw&quot;&gt;%w&lt;/a&gt;, and &lt;a href=&quot;printf#percentz&quot;&gt;%z&lt;/a&gt;) that are useful both internally to SQLite and to applications using SQLite. Standard library printf()s cannot normally be extended in this way.</source>
          <target state="translated">SQLite中的printf（）支持新的非标准替换类型（&lt;a href=&quot;printf#percentq&quot;&gt;％q&lt;/a&gt;，&lt;a href=&quot;printf#percentq&quot;&gt;％Q&lt;/a&gt;，&lt;a href=&quot;printf#percentw&quot;&gt;％w&lt;/a&gt;和&lt;a href=&quot;printf#percentz&quot;&gt;％z&lt;/a&gt;），这些替换类型在内部对SQLite以及使用SQLite的应用程序均有用。通常无法以这种方式扩展标准库的printf（）s。</target>
        </trans-unit>
        <trans-unit id="0592c94ffabf868a1145cae373098959875b4ffd" translate="yes" xml:space="preserve">
          <source>The printf(FORMAT,...) SQL function works like the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; C-language function and the printf() function from the standard C library. The first argument is a format string that specifies how to construct the output string using values taken from subsequent arguments. If the FORMAT argument is missing or NULL then the result is NULL. The %n format is silently ignored and does not consume an argument. The %p format is an alias for %X. The %z format is interchangeable with %s. If there are too few arguments in the argument list, missing arguments are assumed to have a NULL value, which is translated into 0 or 0.0 for numeric formats or an empty string for %s. See the &lt;a href=&quot;printf&quot;&gt;built-in printf()&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">SQL函数printf（FORMAT，...）类似于&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt; C语言函数和标准C库中的printf（）函数。第一个参数是格式字符串，该格式字符串指定如何使用从后续参数获取的值构造输出字符串。如果FORMAT参数丢失或为NULL，则结果为NULL。 ％n格式将被静默忽略，并且不使用任何参数。 ％p格式是％X的别名。 ％z格式可以与％s互换。如果参数列表中的参数太少，则假定缺少的参数具有NULL值，对于数字格式，它将转换为0或0.0；对于％s，它将转换为空字符串。有关其他信息，请参见&lt;a href=&quot;printf&quot;&gt;内置的printf（）&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="f7aa000e854fa1e51d2a8e3276f08d834816bb0a" translate="yes" xml:space="preserve">
          <source>The private memory cell is initialized to NULL by the first two instructions. Instructions 2 through 13 implement the inner SELECT statement against the examp2 table. Notice that instead of sending the result to a callback or storing the result on a sorter, the result of the query is pushed into the memory cell by instruction 10 and the loop is abandoned by the jump at instruction 11. The jump at instruction at 11 is vestigial and never executes.</source>
          <target state="translated">前两条指令将私有内存单元初始化为NULL。指令2到13实现了对examp2表的内部SELECT语句。请注意,查询的结果不是发送到回调或存储在分拣机上,而是由指令10将查询结果推送到内存单元中,并由指令11处的跳转放弃循环。11号指令处的跳转是残缺的,从来没有执行过。</target>
        </trans-unit>
        <trans-unit id="576c1ad7241fb816002c325b35c536b5acba643f" translate="yes" xml:space="preserve">
          <source>The problem is that the indexes are not of equal quality. A check-in is likely to only have one child. So the first field of PLINK_I1 will usually narrow down the search to just a single row. But there are thousands and thousands check-ins tagged with &quot;trunk&quot;, so the first field of TAGXREF_I1 will be of little help in narrowing down the search.</source>
          <target state="translated">问题是,指数的质量不一样。一个签到很可能只有一个孩子。所以PLINK_I1的第一个字段通常会将搜索范围缩小到只有一行。但是有成千上万的带有 &quot;主干 &quot;标签的签入,所以TAGXREF_I1的第一个字段对缩小搜索范围帮助不大。</target>
        </trans-unit>
        <trans-unit id="4910b74e848d7f84054aa8b42c2da7951eb8cf1a" translate="yes" xml:space="preserve">
          <source>The problem of dynamic memory allocation, and specifically the problem of a memory allocator breakdown, has been studied by J. M. Robson and the results published as:</source>
          <target state="translated">J.M.Robson对动态内存分配问题,特别是内存分配器故障问题进行了研究,结果发表为:。</target>
        </trans-unit>
        <trans-unit id="c0e48a1c7e6fc766c0233c83a22616959f0ed84b" translate="yes" xml:space="preserve">
          <source>The problem of finding the best query plan is equivalent to finding a minimum-cost path through the graph that visits each node exactly once.</source>
          <target state="translated">寻找最佳查询计划的问题相当于在图中寻找一条最小成本的路径,它能准确地访问每个节点一次。</target>
        </trans-unit>
        <trans-unit id="0f52798620170b176ff3d3af06fd50b65930b59c" translate="yes" xml:space="preserve">
          <source>The problem was fixed on 2011-02-20. The fix first appears in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;version 3.7.6&lt;/a&gt; (2011-04-12).</source>
          <target state="translated">该问题已于2011-02-20修复。该修复程序首先出现在SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;版本3.7.6&lt;/a&gt;（2011-04-12）中。</target>
        </trans-unit>
        <trans-unit id="0a9231ded77785fbf75b111ccef695ba60c384a1" translate="yes" xml:space="preserve">
          <source>The problem with looking up information by rowid is that you probably do not care what the price of &quot;item 4&quot; is - you want to know the price of peaches. And so a rowid lookup is not helpful.</source>
          <target state="translated">通过rowid查找信息的问题是,你可能并不关心 &quot;物品4 &quot;的价格是多少--你想知道桃子的价格。所以用rowid查找是没有帮助的。</target>
        </trans-unit>
        <trans-unit id="5ca928318271d59121bcae8c1e00c91157b277dc" translate="yes" xml:space="preserve">
          <source>The problem with this latter query is that it must apply the contained_in() function to millions of entries in the demo_data table. The use of the R*Tree in the penultimate query reduces the number of calls to contained_in() function to a small subset of the entire table. The R*Tree index did not find the exact answer itself, it merely limited the search space.</source>
          <target state="translated">后一个查询的问题是,它必须对demo_data表中的数百万个条目应用contains_in()函数。在倒数第二个查询中使用了R*Tree,将对contains_in()函数的调用次数减少到整个表的一个小子集。R*Tree索引本身并没有找到准确的答案,它只是限制了搜索空间。</target>
        </trans-unit>
        <trans-unit id="4d80ba47d569d0e4a2a3e8f3108543e7f76afec3" translate="yes" xml:space="preserve">
          <source>The procedure used to detect a</source>
          <target state="translated">用于检测的程序</target>
        </trans-unit>
        <trans-unit id="7c5ac2fd9c78337a35d0c9980fe79b8e26f93a08" translate="yes" xml:space="preserve">
          <source>The process is explained at &lt;a href=&quot;http://wiki.tcl-lang.org/21708&quot;&gt;http://wiki.tcl-lang.org/21708&lt;/a&gt;.</source>
          <target state="translated">该过程在&lt;a href=&quot;http://wiki.tcl-lang.org/21708&quot;&gt;http://wiki.tcl-lang.org/21708&lt;/a&gt;上进行了说明。</target>
        </trans-unit>
        <trans-unit id="6eeaa105f7c556f91bf9c6156b767ca4d840a8c0" translate="yes" xml:space="preserve">
          <source>The progress callback can be used to display the status of a lengthy query or to process GUI events during a lengthy query.</source>
          <target state="translated">进度回调可用于显示冗长查询的状态或在冗长查询期间处理GUI事件。</target>
        </trans-unit>
        <trans-unit id="c69ceeecbdd66434afc39e336822e8ab81198858" translate="yes" xml:space="preserve">
          <source>The progress handler callback must not do anything that will modify the database connection that invoked the progress handler. Note that &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">进度处理程序回调不得做任何会修改调用进度处理程序的数据库连接的操作。请注意，在本段中，&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;都修改了其数据库连接，以实现&amp;ldquo;修改&amp;rdquo;的含义。</target>
        </trans-unit>
        <trans-unit id="cfdeee9bdc15af91672d8ad9f38656051ea8a13d" translate="yes" xml:space="preserve">
          <source>The progress handler callback must not do anything that will modify the database connection that invoked the progress handler. Note that &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">进度处理程序回调不得做任何会修改调用进度处理程序的数据库连接的操作。请注意，在本段中，&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;和&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;都修改了其数据库连接，以实现&amp;ldquo;修改&amp;rdquo;的含义。</target>
        </trans-unit>
        <trans-unit id="d0b8dc8c8f3e20ba03797e52e7e128023b09d0a3" translate="yes" xml:space="preserve">
          <source>The properties of the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; and &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; commands described above only apply if foreign keys are enabled. If the user considers them undesirable, then the workaround is to use &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; to disable foreign key constraints before executing the DROP or ALTER TABLE command. Of course, while foreign key constraints are disabled, there is nothing to stop the user from violating foreign key constraints and thus creating an internally inconsistent database.</source>
          <target state="translated">上面描述的&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;和&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;命令的属性仅在启用外键的情况下适用。如果用户认为它们不受欢迎，则解决方法是在执行DROP或ALTER TABLE命令之前，使用&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt;禁用外键约束。当然，在禁用外键约束的同时，也没有什么可以阻止用户违反外键约束，从而创建一个内部不一致的数据库。</target>
        </trans-unit>
        <trans-unit id="12341c72ae5851f82e7e9d06ed859f6acb79d027" translate="yes" xml:space="preserve">
          <source>The prover that determines whether any column of the right-hand table of a LEFT JOIN must be non-NULL in the WHERE clause is imperfect. It sometimes returns a false negative. In other words, it sometimes fails to reduce the strength of a LEFT JOIN when doing so was in fact possible. For example, the prover does not know the &lt;a href=&quot;lang_datefunc&quot;&gt;datetime() SQL function&lt;/a&gt; will always return NULL if its first argument is NULL, and so it will not recognize that the LEFT JOIN in the following query could be strength-reduced:</source>
          <target state="translated">确定WHERE子句中LEFT JOIN右侧表的任何列是否必须为非NULL的证明者是不完善的。有时会返回假阴性。换句话说，有时可能无法降低左联接的强度。例如，证明者不知道如果&lt;a href=&quot;lang_datefunc&quot;&gt;datetime（）SQL函数&lt;/a&gt;的第一个参数为NULL，则它将始终返回NULL，因此它无法识别以下查询中的LEFT JOIN可以降低强度：</target>
        </trans-unit>
        <trans-unit id="48a058bacf71fa48c37c493961b3f8857c5bcde0" translate="yes" xml:space="preserve">
          <source>The psow query parameter overrides the &lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt; property of the database file being opened. The psow query parameter works with the default windows and unix &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; but might be a no-op for other proprietary or non-standard VFSes.</source>
          <target state="translated">psow查询参数将&lt;a href=&quot;psow&quot;&gt;覆盖&lt;/a&gt;正在打开的数据库文件的powersafe overwrite属性。psow查询参数可与默认的Windows和UNIX &lt;a href=&quot;vfs&quot;&gt;VFS一起使用，&lt;/a&gt;但对于其他专有或非标准VFS可能是无效的。</target>
        </trans-unit>
        <trans-unit id="ffe108cd06e0c16c268bec90ba5007639fcc32ef" translate="yes" xml:space="preserve">
          <source>The pthreads interface provides the pthread_cond_wait() function. This function allows the caller to simultaneously release a mutex and start waiting for an asynchronous signal. Using this function, a &quot;fired&quot; flag and a mutex, the race-condition described above may be eliminated as follows:</source>
          <target state="translated">pthreads接口提供了pthread_cond_wait()函数。这个函数允许调用者同时释放一个mutex并开始等待一个异步信号。使用该函数、&quot;fireed &quot;标志和mutex,可以消除上述的竞赛条件,具体如下。</target>
        </trans-unit>
        <trans-unit id="5730c4be2fce644af4a3a0b4f7bf8a21afa9d144" translate="yes" xml:space="preserve">
          <source>The pthreads library is needed to make SQLite threadsafe. But since the CLI is single threaded, we could instruct SQLite to build in a non-threadsafe mode and thereby omit the pthreads library:</source>
          <target state="translated">pthreads库是使SQLite线程安全的需要。但由于CLI是单线程的,我们可以指示SQLite在非线程安全模式下构建,从而省略pthreads库。</target>
        </trans-unit>
        <trans-unit id="ead084e5ac51c3a25e7e77f7295b3ad410aff0a2" translate="yes" xml:space="preserve">
          <source>The purpose of the master journal is to ensure that multi-file transactions are atomic across a power-loss. But if the database files have other settings that compromise integrity across a power-loss event (such as &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=MEMORY&lt;/a&gt;) then the creation of the master journal is omitted, as an optimization.</source>
          <target state="translated">主日志的目的是确保跨功耗的多文件事务是原子的。但是，如果数据库文件具有其他设置，这些设置会在掉电事件中危及完整性（例如&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMAynchronized = OFF&lt;/a&gt;或&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = MEMORY&lt;/a&gt;），那么作为优化，将省略主日志的创建。</target>
        </trans-unit>
        <trans-unit id="80a4c796df15be02f28a9491edc718e0a6ad327d" translate="yes" xml:space="preserve">
          <source>The purpose of the other files and folders is presently unknown to the author but is probably not difficult to figure out.</source>
          <target state="translated">其他文件和文件夹的用途目前笔者不得而知,但大概不难弄清楚。</target>
        </trans-unit>
        <trans-unit id="f221997932c715d1cdc1bd2a990d3e44e81c153a" translate="yes" xml:space="preserve">
          <source>The purpose of the super-journal is to ensure that multi-file transactions are atomic across a power-loss. But if the database files have other settings that compromise integrity across a power-loss event (such as &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=MEMORY&lt;/a&gt;) then the creation of the super-journal is omitted, as an optimization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad934bb2af516663297a114c16808bb7efaf019" translate="yes" xml:space="preserve">
          <source>The purpose of the wal-index is to answer this question quickly:</source>
          <target state="translated">华尔指数的目的就是为了快速回答这个问题。</target>
        </trans-unit>
        <trans-unit id="138e57468a79af5c77be9bf617137e42c028e084" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to argue in favor of a fourth new category of application file format: An SQLite database file.</source>
          <target state="translated">本文件的目的是为了论证支持第四类新的应用文件格式。SQLite数据库文件。</target>
        </trans-unit>
        <trans-unit id="a73682c963786c3512a8e2606835fb2fa3f30921" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to brief the reader on how SQLite development team functions on a daily basis, as they continuously enhance the SQLite software and work to improve its already high reliability. The document achieves its purpose if a competent developer can be assimilated into the development team quickly after perusing this document.</source>
          <target state="translated">本文档的目的是向读者简要介绍SQLite开发团队在日常工作中是如何运作的,因为他们在不断增强SQLite软件的功能,并努力提高其本来就很高的可靠性。如果一个有能力的开发人员在通读本文档后能迅速融入开发团队,那么本文档就达到了目的。</target>
        </trans-unit>
        <trans-unit id="634e9e567d1f1f2dd99eda8c5536d500fa1e6e07" translate="yes" xml:space="preserve">
          <source>The push-down optimization cannot always be used. For example, if the subquery contains a LIMIT, then pushing down any part of the WHERE clause from the outer query could change the result of the inner query. There are other restrictions, explained in a comment in the source code on the pushDownWhereTerms() routine that implements this optimization.</source>
          <target state="translated">不能总是使用下推优化。例如,如果子查询包含一个LIMIT,那么从外部查询中推倒WHERE子句的任何部分都可能改变内部查询的结果。还有其他的限制,在源代码中关于实现这个优化的pushDownWhereTerms()例程的注释中会有解释。</target>
        </trans-unit>
        <trans-unit id="95403298754cba937ffb2896cd7e77d09dc82fdd" translate="yes" xml:space="preserve">
          <source>The quality management plan was originally composed by going through the description of outputs in section 11 of DO-178B (pages 48 through 56) and writing down those elements that seemed relevant to SQLite. The text will be subsequent revised to track enhancements to the SQLite quality process.</source>
          <target state="translated">质量管理计划最初是通过浏览DO-178B第11节(第48至56页)中的产出描述,并写下那些似乎与SQLite相关的内容。随后将对该案文进行修订,以跟踪SQLite质量程序的改进情况。</target>
        </trans-unit>
        <trans-unit id="06064891cfb2016593d8db9b131661701e81d4c1" translate="yes" xml:space="preserve">
          <source>The query above could be made to run faster by using the FTS &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo&lt;/a&gt; function to determine the number of query term instances that appear in each result. The matchinfo function is much more efficient than the offsets function. Furthermore, the matchinfo function provides extra information regarding the overall number of occurrences of each query term in the entire document set (not just the current row) and the number of documents in which each query term appears. This may be used (for example) to attach a higher weight to less common terms which may increase the overall computed relevancy of those results the user considers more interesting.</source>
          <target state="translated">通过使用FTS &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo&lt;/a&gt;函数确定出现在每个结果中的查询词实例的数量，可以使上面的查询运行得更快。 matchinfo函数比offsets函数有效得多。此外，matchinfo函数提供有关整个文档集中（不仅是当前行）每个查询词的出现总数以及每个查询词出现在其中的文档数的额外信息。这可以用于（例如）将较高的权重附加到不太常见的术语上，这可以增加用户认为更有趣的那些结果的总体计算相关性。</target>
        </trans-unit>
        <trans-unit id="418f38a31900c8102303fe91cea3cb03a0bfc91a" translate="yes" xml:space="preserve">
          <source>The query above could be rewritten as a join and without the use of row values:</source>
          <target state="translated">上面的查询可以改写为连接,而不使用行值。</target>
        </trans-unit>
        <trans-unit id="8505932c272eacf13a6ac016c3034294904230a0" translate="yes" xml:space="preserve">
          <source>The query above will return suggestions for the whole input word that begins with $prefix. The $wholeline parameter is all text from the beginning of the line up to the insertion point. The $wholeline parameter is used for context.</source>
          <target state="translated">上面的查询将返回以$prefix开头的整个输入词的建议。$wholeline参数是指从行首到插入点的所有文本。$wholeline参数用于上下文。</target>
        </trans-unit>
        <trans-unit id="f9921b4f3858e29c8d8f50be7ccdabc32d452e7c" translate="yes" xml:space="preserve">
          <source>The query above will use the po_parent index to help find the answer, since the po_parent index contains entries for all rows of interest. Note that since po_parent is smaller than a full index, the query will likely run faster too.</source>
          <target state="translated">上面的查询将使用po_parent索引来帮助找到答案,因为po_parent索引包含了所有相关记录的条目。需要注意的是,由于po_parent索引比完整索引小,所以查询的运行速度也会更快。</target>
        </trans-unit>
        <trans-unit id="0190a12968e1ccf51186372beeb26ae3012cb0b9" translate="yes" xml:space="preserve">
          <source>The query above would very quickly locate the id of 1 even if the R*Tree contained millions of entries. The previous is an example of a &quot;contained-within&quot; query. The R*Tree also supports &quot;overlapping&quot; queries. For example, to find all bounding boxes that overlap the Charlotte area:</source>
          <target state="translated">即使R*Tree中包含了数百万个条目,上面的查询也会非常快速地找到1的id。前面是一个 &quot;包含-内 &quot;查询的例子。R*Tree还支持 &quot;重叠 &quot;查询。例如,要找到所有与Charlotte区域重叠的边界框。</target>
        </trans-unit>
        <trans-unit id="94364d8100096142da610b0a18f63efa10ad070a" translate="yes" xml:space="preserve">
          <source>The query component of a URI may contain parameters that are interpreted either by SQLite itself, or by a &lt;a href=&quot;../vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;custom VFS implementation&lt;/a&gt;. SQLite and its built-in &lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; interpret the following query parameters:</source>
          <target state="translated">URI的查询组件可能包含由SQLite本身或由&lt;a href=&quot;../vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;自定义VFS实现&lt;/a&gt;解释的参数。SQLite及其内置的&lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt;解释以下查询参数：</target>
        </trans-unit>
        <trans-unit id="86e91a7c9e388f3708828edd53ce0492e58dcf0d" translate="yes" xml:space="preserve">
          <source>The query component of a URI may contain parameters that are interpreted either by SQLite itself, or by a &lt;a href=&quot;vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;custom VFS implementation&lt;/a&gt;. SQLite and its built-in &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; interpret the following query parameters:</source>
          <target state="translated">URI的查询组件可能包含由SQLite本身或由&lt;a href=&quot;vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;自定义VFS实现&lt;/a&gt;解释的参数。SQLite及其内置的&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;解释以下查询参数：</target>
        </trans-unit>
        <trans-unit id="f6f2f3df836d46d9540098c193cbe7de6978b27d" translate="yes" xml:space="preserve">
          <source>The query contains both a search restriction in the WHERE clause and a sort order in the ORDER BY clause. Both the search and the sort can be accomplished at the same time using the two-column index Idx3.</source>
          <target state="translated">这个查询包含了WHERE子句中的搜索限制和ORDER BY子句中的排序顺序,搜索和排序都可以通过使用两列索引Idx3同时完成。搜索和排序都可以使用双列索引Idx3同时完成。</target>
        </trans-unit>
        <trans-unit id="bb441cf385ae38b5e50765b319372e3b2d5a50b2" translate="yes" xml:space="preserve">
          <source>The query does a binary search on the index to find the subset of rows that have fruit='Orange'. (Because the fruit column is the left-most column of the index and the rows of the index are in sorted order, all such rows will be adjacent.) Then it scans the matching index rows from top to bottom to get the rowids for the original table, and for each rowid does a binary search on the original table to find the price.</source>
          <target state="translated">该查询在索引上进行二进制搜索,以查找fruit='Orange'的行的子集。(因为fruit列是索引的最左边的一列,而索引的行是按顺序排列的,所以所有这样的行都会相邻)。然后它从上到下扫描匹配的索引行,得到原表的rowid,并对每个rowid在原表上进行二元搜索,找到价格。</target>
        </trans-unit>
        <trans-unit id="0da70d4a5a91c3bdacf749b9198a4a57a477e008" translate="yes" xml:space="preserve">
          <source>The query is not an aggregate</source>
          <target state="translated">查询不是一个集合</target>
        </trans-unit>
        <trans-unit id="d5463ef5a6e2ace12b54dcf259b0837fe48d0c3a" translate="yes" xml:space="preserve">
          <source>The query loop is built from instructions 5 through 13. Instructions 6 through 8 build a record that contains the azData[] values for a single invocation of the callback. A sort key is generated by instructions 9 through 11. Instruction 12 combines the invocation record and the sort key into a single entry and puts that entry on the sort list.</source>
          <target state="translated">查询循环是由指令5到13建立的。指令6到指令8建立一条记录,其中包含回调的一次调用的azData[]值。排序键由指令9到11生成。指令12将调用记录和排序键合并为一个条目,并将该条目放在排序列表中。</target>
        </trans-unit>
        <trans-unit id="b89b1eb2c0211443a7be50a77507c951f5a3834f" translate="yes" xml:space="preserve">
          <source>The query loop is implemented by instructions 8 through 22. The aggregate key specified by the GROUP BY clause is computed by instructions 9 and 10. Instruction 11 causes the appropriate bucket to come into focus. If a bucket with the given key does not already exists, a new bucket is created and control falls through to instructions 12 and 13 which initialize the bucket. If the bucket does already exist, then a jump is made to instruction 14. The values of aggregate functions are updated by the instructions between 11 and 21. Instructions 14 through 18 update memory slot 1 to hold the next value &quot;min(three+four)&quot;. Then the sum of the &quot;four&quot; column is updated by instructions 19 through 21.</source>
          <target state="translated">查询循环由指令8到22实现。由GROUP BY子句指定的集合键由指令9和10计算。指令11使适当的桶成为焦点。如果具有给定键的bucket还不存在,则创建一个新的bucket,控制权落到指令12和13,这两条指令初始化bucket。如果 bucket 已经存在,则跳转到指令 14。汇总函数的值由11到21之间的指令更新。指令14到18更新内存槽1,以保持下一个值 &quot;min(three+four)&quot;。然后由指令19到21更新 &quot;四 &quot;列的和。</target>
        </trans-unit>
        <trans-unit id="a6ac9b746a0ebf6db3c5dac60c7fc4d3c527912f" translate="yes" xml:space="preserve">
          <source>The query optimizer might translate this into three separate constraints:</source>
          <target state="translated">查询优化器可以将其转化为三个独立的约束条件。</target>
        </trans-unit>
        <trans-unit id="ca7f72fc82a7c6f8223569dbd345a23847f45a71" translate="yes" xml:space="preserve">
          <source>The query optimizer now attempts to implement the ORDER BY clause using an index. Sorting is still used if not suitable index is available.</source>
          <target state="translated">查询优化器现在尝试使用索引来实现ORDER BY子句。如果没有合适的索引,仍然会使用排序。</target>
        </trans-unit>
        <trans-unit id="074dd395e411c2a7564e05c9a803ff7d91501e5c" translate="yes" xml:space="preserve">
          <source>The query planner considers the LIMIT clause when estimating the cost of ORDER BY.</source>
          <target state="translated">查询规划师在估算ORDER BY的成本时,会考虑LIMIT子句。</target>
        </trans-unit>
        <trans-unit id="efb22d31da7b95dc237d9b06fed089e63b961bd2" translate="yes" xml:space="preserve">
          <source>The query planner examines the values of bound parameters to help determine if a partial index is usable.</source>
          <target state="translated">查询规划器检查约束参数的值,以帮助确定部分索引是否可用。</target>
        </trans-unit>
        <trans-unit id="e51e3ffe015829441eac83092590224609d07ba7" translate="yes" xml:space="preserve">
          <source>The query planner in SQLite normally does a terrific job of selecting fast algorithms for running your SQL statements. This is true of the legacy query planner and even more true of the new NGQP. There may be an occasional situation where, due to incomplete information, the query planner selects a suboptimal plan. This will happen less often with the NGQP than with the legacy query planner, but it might still happen. Only in those rare cases do application developers need to get involved and help the query planner to do the right thing. In the common case, the NGQP is just a new enhancement to SQLite that makes the application run a little faster and which requires no new developer thought or action.</source>
          <target state="translated">SQLite中的查询规划器通常在选择运行SQL语句的快速算法方面做得非常出色。传统的查询规划器如此,新的NGQP更是如此。偶尔会出现这样的情况:由于信息不完整,查询规划器选择了一个次优的计划。这种情况在NGQP中发生的频率会比在传统查询规划器中发生的频率要低,但仍有可能发生。只有在这些极少数情况下,应用开发人员才需要参与进来,帮助查询规划器做正确的事情。在常见的情况下,NGQP只是对SQLite的一个新的增强,它使应用程序的运行速度更快一些,它不需要开发人员有新的想法或行动。</target>
        </trans-unit>
        <trans-unit id="7056feb20ef72b761795635d81c08e5ed2af62a2" translate="yes" xml:space="preserve">
          <source>The query planner in future versions of SQLite might grow smart enough to make transformations such as the above automatically, in both directions. That is to say, future versions of SQLite might transform queries of the first form into the second, or queries written the second way into the first. As of SQLite version 3.22.0 (2018-01-22), the query planner will flatten the subquery if the outer query does not make use of any user-defined functions or subqueries in its result set. For the examples shown above, however, SQLite implements each of the queries as written.</source>
          <target state="translated">未来版本的SQLite中的查询规划器可能会长得足够聪明,可以自动地进行如上的转换,双向转换。也就是说,未来版本的SQLite可能会将第一种形式的查询转化为第二种形式,或者将第二种方式写的查询转化为第一种方式。从SQLite 3.22.0版本(2018-01-22)开始,如果外层查询的结果集中没有使用任何用户定义的函数或子查询,查询规划器将扁平化子查询。然而,对于上面显示的例子,SQLite按照编写的方式实现了每个查询。</target>
        </trans-unit>
        <trans-unit id="f9ae7f14e38f472239e8cbf47519f9f962bf6c41" translate="yes" xml:space="preserve">
          <source>The query planner is able to optimize IN operators on &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; even if the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method does not set the sqlite3_index_constraint_usage.omit flag of the virtual table column to the left of the IN operator.</source>
          <target state="translated">即使&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;方法未将虚拟表列的sqlite3_index_constraint_usage.omit标志设置在IN运算符的左侧，查询计划程序仍可以优化&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;上的IN运算符。</target>
        </trans-unit>
        <trans-unit id="4b67d5103aec179badd00d13df4b687ed31a2fd8" translate="yes" xml:space="preserve">
          <source>The query planner is more aggressive about using &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexes&lt;/a&gt; for views and subqueries for which it is not possible to create a persistent index.</source>
          <target state="translated">查询计划者对于无法为其创建持久索引的视图和子查询使用&lt;a href=&quot;optoverview#autoindex&quot;&gt;自动索引&lt;/a&gt;更具攻击性。</target>
        </trans-unit>
        <trans-unit id="0ff80f93923c8ea0ed391da80428d773af3f58c7" translate="yes" xml:space="preserve">
          <source>The query planner is now able to use &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt; that contain AND-connected terms in the WHERE clause.</source>
          <target state="translated">现在，查询计划器可以使用在WHERE子句中包含AND连接项的&lt;a href=&quot;partialindex&quot;&gt;部分索引&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1bf26dc5394aa893fb29edbb88f7b0f3c1a3bf4" translate="yes" xml:space="preserve">
          <source>The query planner loads the content of the statistics tables into memory when the schema is read. Hence, when an application changes the statistics tables directly, SQLite will not immediately notice the changes. An application can force the query planner to reread the statistics tables by running &lt;b&gt;ANALYZE sqlite_master&lt;/b&gt;.</source>
          <target state="translated">读取架构时，查询计划器会将统计信息表的内容加载到内存中。因此，当应用程序直接更改统计表时，SQLite将不会立即注意到这些更改。应用程序可以通过运行&lt;b&gt;ANALYZE sqlite_master&lt;/b&gt;来强制查询计划程序重新读取统计信息表。</target>
        </trans-unit>
        <trans-unit id="b54043d2a3881a0e42bb93d2a4b188d8e3b927bd" translate="yes" xml:space="preserve">
          <source>The query planner loads the content of the statistics tables into memory when the schema is read. Hence, when an application changes the statistics tables directly, SQLite will not immediately notice the changes. An application can force the query planner to reread the statistics tables by running &lt;b&gt;ANALYZE sqlite_schema&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764ebb928a21a2403e7ad4384e4177e72689b2ef" translate="yes" xml:space="preserve">
          <source>The query planner must decide between many possible implementations of this query, but two plans in particular are of note:</source>
          <target state="translated">查询规划者必须在这个查询的许多可能的实现中做出决定,但有两个计划特别值得注意。</target>
        </trans-unit>
        <trans-unit id="35937457496b4c465e761e374d83f1c328cfb649" translate="yes" xml:space="preserve">
          <source>The query planner now does a better job of optimizing &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; accesses in a 3-way or higher join where constraints on the virtual table are split across two or more other tables of the join.</source>
          <target state="translated">现在，查询计划器可以更好地优化3向或更高连接中的&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;访问，其中虚拟表上的约束分布在两个或多个其他连接表中。</target>
        </trans-unit>
        <trans-unit id="ecefb9cd6e1de2d9ed81b2814e874ca9b432f553" translate="yes" xml:space="preserve">
          <source>The query planner now prefers to implement FROM-clause subqueries using &lt;a href=&quot;optoverview#coroutines&quot;&gt;co-routines&lt;/a&gt; rather using the &lt;a href=&quot;optoverview#flattening&quot;&gt;query flattener&lt;/a&gt; optimization. Support for the use of co-routines for subqueries may no longer be disabled.</source>
          <target state="translated">现在，查询计划者更喜欢使用&lt;a href=&quot;optoverview#coroutines&quot;&gt;协例程&lt;/a&gt;而不是&lt;a href=&quot;optoverview#flattening&quot;&gt;查询展平器&lt;/a&gt;优化来实现FROM子句子查询。可能不再禁用对子查询使用协同例程的支持。</target>
        </trans-unit>
        <trans-unit id="39ca8ebd42e9f170c8e29a8cb05c453c4287996d" translate="yes" xml:space="preserve">
          <source>The query planner now recognizes that any column in the right-hand table of a LEFT JOIN can be NULL, even if that column has a NOT NULL constraint. Avoid trying to optimize out NULL tests in those cases. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7ed&lt;/a&gt;.</source>
          <target state="translated">现在，查询计划器可以识别LEFT JOIN右侧表中的任何列都可以为NULL，即使该列具有NOT NULL约束。在这种情况下，请避免尝试优化NULL测试。修复票证&lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7ed&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec8769590db8f2b5c877d645663be729be900155" translate="yes" xml:space="preserve">
          <source>The query planner now uses &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; information (created by &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;) to help determine if the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; is appropriate.</source>
          <target state="translated">现在，查询计划器使用&lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;信息（由&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;创建）来帮助确定&lt;a href=&quot;optoverview#skipscan&quot;&gt;跳过扫描优化&lt;/a&gt;是否合适。</target>
        </trans-unit>
        <trans-unit id="c31a7ce3fe100e3f0ec40a06c5c355aa9ab9699f" translate="yes" xml:space="preserve">
          <source>The query planner used &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;-style statistics for one or more indexes of the table at some point during the lifetime of the current connection.</source>
          <target state="translated">查询计划程序在当前连接的生存期内的某个时候对表的一个或多个索引使用了&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;样式的统计信息。</target>
        </trans-unit>
        <trans-unit id="a97e7a7c05ace47af23f942a5bb054692500ea21" translate="yes" xml:space="preserve">
          <source>The query planner uses a full scan of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; instead of a full scan of the main table, in cases where that makes sense.</source>
          <target state="translated">在这种情况下，查询计划程序将使用&lt;a href=&quot;partialindex&quot;&gt;部分索引&lt;/a&gt;的完整扫描而不是主表的完整扫描。</target>
        </trans-unit>
        <trans-unit id="5c0c2991e6f563d6716af52b8b617039da1f2fdd" translate="yes" xml:space="preserve">
          <source>The query starts by doing a binary search on the Idx1 index for entries that have fruit='Peach'. SQLite can do this binary search on the Idx1 index but not on the original FruitsForSale table because the rows in Idx1 are sorted by the &quot;fruit&quot; column. Having found a row in the Idx1 index that has fruit='Peach', the database engine can extract the rowid for that row. Then the database engines does a second binary search on the original FruitsForSale table to find the original row that contains fruit='Peach'. From the row in the FruitsForSale table, SQLite can then extract the value of the price column. This procedure is illustrated by &lt;a href=&quot;#fig5&quot;&gt;figure 5&lt;/a&gt;.</source>
          <target state="translated">该查询从对Idx1索引进行二进制搜索开始，以查找具有fruit ='Peach'的条目。 SQLite可以在Idx1索引上执行此二进制搜索，但不能在原始FruitsForSale表上执行此二进制搜索，因为Idx1中的行按&amp;ldquo;水果&amp;rdquo;列排序。在Idx1索引中找到具有fruit ='Peach'的行之后，数据库引擎可以提取该行的rowid。然后，数据库引擎对原始FruitsForSale表进行第二次二进制搜索，以找到包含fruit ='Peach'的原始行。然后，从FruitsForSale表的行中，SQLite可以提取price列的值。该过程由&lt;a href=&quot;#fig5&quot;&gt;图5&lt;/a&gt;示出。</target>
        </trans-unit>
        <trans-unit id="7d2f0fdfeb4c2c835aff8667a9df0a76c56f4c48" translate="yes" xml:space="preserve">
          <source>The query string is optional. If the query string is present, then all query parameters are passed through into the xOpen method of the underlying &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;.</source>
          <target state="translated">查询字符串是可选的。如果存在查询字符串，那么所有查询参数都将传递到基础&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;的xOpen方法中。</target>
        </trans-unit>
        <trans-unit id="85170b302d04cae08fe65e554bbdfb1393e9fe62" translate="yes" xml:space="preserve">
          <source>The query syntax has been revised where necessary to remove ambiguities and to make it possible to escape special characters in query terms.</source>
          <target state="translated">必要时对查询语法进行了修改,以消除歧义,并使查询术语中的特殊字符可以转义。</target>
        </trans-unit>
        <trans-unit id="6a08992b107064a2b4d32992f6db718c41160975" translate="yes" xml:space="preserve">
          <source>The query_only pragma prevents all changes to database files when enabled.</source>
          <target state="translated">query_only pragma 启用后,可以防止对数据库文件的所有更改。</target>
        </trans-unit>
        <trans-unit id="c227c47e0d2b0279a9dff3f8b02f840ecf77eb68" translate="yes" xml:space="preserve">
          <source>The quote(X) function returns the text of an SQL literal which is the value of its argument suitable for inclusion into an SQL statement. Strings are surrounded by single-quotes with escapes on interior quotes as needed. BLOBs are encoded as hexadecimal literals. Strings with embedded NUL characters cannot be represented as string literals in SQL and hence the returned string literal is truncated prior to the first NUL.</source>
          <target state="translated">quote(X)函数返回一个SQL文字的文本,这个文本是其参数的值,适合包含在SQL语句中。字符串由单引号包围,并根据需要在内部引号上进行转义。BLOBs被编码为十六进制文字。嵌入NUL字符的字符串在SQL中不能表示为字符串字元,因此返回的字符串字元在第一个NUL之前被截断。</target>
        </trans-unit>
        <trans-unit id="9f63b25a5004d971fa73a7b89854797c36e88a71" translate="yes" xml:space="preserve">
          <source>The random() function provides 64 bits of randomness instead of only 32 bits.</source>
          <target state="translated">random()函数提供了64位的随机性,而不是只有32位。</target>
        </trans-unit>
        <trans-unit id="db5db9919e511217ef7da4b79216c59c757f004b" translate="yes" xml:space="preserve">
          <source>The random() function returns a pseudo-random integer between -9223372036854775808 and +9223372036854775807.</source>
          <target state="translated">random()函数返回一个介于-9223372036854775808和+9223372036854775807之间的伪随机整数。</target>
        </trans-unit>
        <trans-unit id="dc66046ce33b1a2430fa7d3f10cb359cc80fae20" translate="yes" xml:space="preserve">
          <source>The randomblob(N) function return an N-byte blob containing pseudo-random bytes. If N is less than 1 then a 1-byte random blob is returned.</source>
          <target state="translated">randomblob(N)函数返回一个包含伪随机字节的N字节blob。如果N小于1,则返回一个1字节的随机blob。</target>
        </trans-unit>
        <trans-unit id="c291d5ba33f13d62c916974b77fcaf954ce3ff7e" translate="yes" xml:space="preserve">
          <source>The rank of the column within the index. (0 means left-most. Key columns come before auxiliary columns.)</source>
          <target state="translated">列在索引中的等级,(0表示最左,关键列在辅助列之前。)(0表示最左,关键列在辅助列之前。)</target>
        </trans-unit>
        <trans-unit id="0b2bd6ab8a45c757d36fc0179def745c6a1bbb66" translate="yes" xml:space="preserve">
          <source>The rank of the column within the index. (0 means left-most.)</source>
          <target state="translated">列在索引中的等级。(0表示最左边。)</target>
        </trans-unit>
        <trans-unit id="463c4210effd7ad2a8dada3187acf9269beea08a" translate="yes" xml:space="preserve">
          <source>The rank of the column within the table being indexed, or -1 if the index-column is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the table being indexed and -2 if the &lt;a href=&quot;expridx&quot;&gt;index is on an expression&lt;/a&gt;.</source>
          <target state="translated">被索引表中的列的排名；如果index-column是被索引表的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;，则为-1，如果&lt;a href=&quot;expridx&quot;&gt;索引位于expression上，则为&lt;/a&gt; -2 。</target>
        </trans-unit>
        <trans-unit id="84413b7d19914c0bede4000ce3b0ffb8491410c6" translate="yes" xml:space="preserve">
          <source>The rank of the column within the table being indexed. A value of -1 means &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; and a value of -2 means that an &lt;a href=&quot;expridx&quot;&gt;expression&lt;/a&gt; is being used.</source>
          <target state="translated">被索引表中列的等级。值-1表示&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;，值-2表示正在使用&lt;a href=&quot;expridx&quot;&gt;表达式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8754b3bec73ba7fde29d928b708ca495c5b77ae4" translate="yes" xml:space="preserve">
          <source>The rank of word.</source>
          <target state="translated">字的等级。</target>
        </trans-unit>
        <trans-unit id="2dd609ed9718452c7fad1b16788c833004253127" translate="yes" xml:space="preserve">
          <source>The rank option is used to change the default auxiliary function mapping for the rank column. The option should be set to a text value in the same format as described for &lt;a href=&quot;fts5#sorting_by_auxiliary_function_results&quot;&gt;&quot;rank MATCH ?&quot;&lt;/a&gt; terms above. For example:</source>
          <target state="translated">rank选项用于更改rank列的默认辅助功能映射。该选项应设置为与&lt;a href=&quot;fts5#sorting_by_auxiliary_function_results&quot;&gt;&amp;ldquo; rank MATCH？&amp;rdquo;&lt;/a&gt;所述格式相同的文本值。以上条款。例如：</target>
        </trans-unit>
        <trans-unit id="3e012920d09c510ffee894f9967688d5537ade9a" translate="yes" xml:space="preserve">
          <source>The rate of enhancement for SQLite over the previous five years (2010-2015) is approximately 6 increments of Y per year. The numbering format used by for &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; and &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; allows versions up to 3.999.999, which is more than enough for the planned end-of-support date for SQLite in 2050. However, the current tarball naming conventions only reserve two digits for the Y and so the naming format for downloads will need to be revised in about 2030.</source>
          <target state="translated">在过去的五年（2010-2015年）中，SQLite的增强速度约为每年Y的6个增量。&lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;和&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number（）&lt;/a&gt;使用的编号格式允许版本高达3.999.999，这对于2050年SQLite计划的支持终止日期已绰绰有余。但是，当前的tarball命名约定仅保留两位数字用于Y，因此需要在2030年左右修改下载的命名格式。</target>
        </trans-unit>
        <trans-unit id="e8a5095befc118ca6a6fec21354c920d6bd315d2" translate="yes" xml:space="preserve">
          <source>The reader algorithm in the previous paragraphs works correctly, but because frames for page P can appear anywhere within the WAL, the reader has to scan the entire WAL looking for page P frames. If the WAL is large (multiple megabytes is typical) that scan can be slow, and read performance suffers. To overcome this problem, a separate data structure called the wal-index is maintained to expedite the search for frames of a particular page.</source>
          <target state="translated">前面几段中的阅读器算法是正确的,但是由于P页的帧可以出现在WAL中的任何地方,所以阅读器必须扫描整个WAL来寻找P页的帧。如果WAL很大(典型的是多兆字节),这种扫描会很慢,读取性能也会受到影响。为了克服这个问题,我们维护了一个单独的数据结构,称为wal-index,以加快搜索某一页的帧。</target>
        </trans-unit>
        <trans-unit id="3e2fc6a74baa30b6fadb3fd43bce3110d90f198d" translate="yes" xml:space="preserve">
          <source>The readfile(X) SQL function reads the entire content of the file named X and returns that content as a BLOB. This can be used to load content into a table. For example:</source>
          <target state="translated">readfile(X)SQL函数读取名为X的文件的全部内容,并将这些内容以BLOB的形式返回。这可以用来将内容加载到一个表中。例如</target>
        </trans-unit>
        <trans-unit id="f5d4c0c9266d8eca05dca08f98a5cbf6d922d36a" translate="yes" xml:space="preserve">
          <source>The realization that an aggregate query is really two consecutive loops makes it much easier to understand the difference between a WHERE clause and a HAVING clause in SQL query statement. The WHERE clause is a restriction on the first loop and the HAVING clause is a restriction on the second loop. You can see this by adding both a WHERE and a HAVING clause to our example query:</source>
          <target state="translated">认识到聚合查询实际上是两个连续的循环,就更容易理解SQL查询语句中WHERE子句和HAVING子句的区别了。WHERE子句是对第一个循环的限制,HAVING子句是对第二个循环的限制。你可以通过在我们的示例查询中同时添加一个WHERE子句和一个HAVING子句来了解这一点。</target>
        </trans-unit>
        <trans-unit id="4a5758542d7b569e5728a8a94a0c5f527ec1ddfe" translate="yes" xml:space="preserve">
          <source>The reallocarray() interface is a recent innovation (circa 2014) from the OpenBSD community that grow out of efforts to prevent the next &lt;a href=&quot;http://heartbleed.com&quot;&gt;&quot;heartbleed&quot; bug&lt;/a&gt; by avoiding 32-bit integer arithmetic overflow on memory allocation size computations. The reallocarray() function has both unit-size and count parameters. To allocate memory sufficient to hold an array of N elements each X-bytes in size, one calls &quot;reallocarray(0,X,N)&quot;. This is preferred over the traditional technique of invoking &quot;malloc(X*N)&quot; as reallocarray() eliminates the risk that the X*N multiplication will overflow and cause malloc() to return a buffer that is a different size from what the application expected.</source>
          <target state="translated">reallocarray（）接口是OpenBSD社区的一项最新创新（大约于2014年），它通过避免内存分配大小计算中的32位整数算术溢出来防止下一个&lt;a href=&quot;http://heartbleed.com&quot;&gt;&amp;ldquo;令人讨厌的&amp;rdquo;错误&lt;/a&gt;。 reallocarray（）函数同时具有单位大小和计数参数。为了分配足够的内存来容纳每个X字节大小的N个元素的数组，一个调用&amp;ldquo; reallocarray（0，X，N）&amp;rdquo;。这优于调用&amp;ldquo; malloc（X * N）&amp;rdquo;的传统技术，因为reallocarray（）消除了X * N乘法将溢出并导致malloc（）返回与应用程序大小不同的缓冲区的风险。预期。</target>
        </trans-unit>
        <trans-unit id="a25a89f7da0624003a3e075ec1d5437a5611f942" translate="yes" xml:space="preserve">
          <source>The reason for attempting to read the</source>
          <target state="translated">试图阅读的原因。</target>
        </trans-unit>
        <trans-unit id="61ed3e5eacc7786aa96400e0606560d6b0c2919c" translate="yes" xml:space="preserve">
          <source>The reason for this is easy to understand: When a document is inserted into the FTS5 table, an entry is added to the full-text index to record the position of each token within the new document. When a document is removed, the original data is required in order to determine the set of entries that need to be removed from the full-text index. So if the data supplied to FTS5 when a row is deleted using this command is different from that used to determine the set of token instances when it was inserted, some full-text index entries may not be correctly deleted, or FTS5 may try to remove index entries that do not exist. This can leave the full-text index in an unpredictable state, making future query results unreliable.</source>
          <target state="translated">这样做的原因很容易理解。当一份文件被插入FTS5表时,全文索引中会增加一个条目,以记录新文件中每个标记的位置。当文档被删除时,需要原始数据来确定需要从全文索引中删除的条目集。因此,如果使用此命令删除某行时提供给 FTS5 的数据与插入时用于确定标记实例集的数据不同,则一些全文索引条目可能不会被正确删除,或者 FTS5 可能会尝试删除不存在的索引条目。这可能会使全文索引处于不可预测的状态,使未来的查询结果不可靠。</target>
        </trans-unit>
        <trans-unit id="aaf49440241f0d03e40af262860c9b5798f65bc8" translate="yes" xml:space="preserve">
          <source>The reason that the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; has its buffer pointer and buffer size arguments reversed from what is found in the standard library snprintf() routine is because there was no snprintf() routine in the standard C library when Hipp was first implementing his version, and he chose a different order than the designers of the standard C library.</source>
          <target state="translated">之所以说&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;有它的缓冲区指针和缓冲从什么是在标准库的snprintf发现逆转尺寸参数（）函数是因为在标准C库中没有的snprintf（）函数时希普首次实现他的版本，他选择的顺序与标准C库的设计人员不同。</target>
        </trans-unit>
        <trans-unit id="791eaa4dd6fb2ae12ed4b869340107d40b780f17" translate="yes" xml:space="preserve">
          <source>The reasons why C is the best language to implement SQLite include:</source>
          <target state="translated">C语言是实现SQLite的最佳语言的原因包括:。</target>
        </trans-unit>
        <trans-unit id="570c3cd1b218e89b5e9796c1a0c8bf3041d5fcd8" translate="yes" xml:space="preserve">
          <source>The recommended fix for this problem is to select a different filesystem. These days, there is a huge selection of high-performance, reliable, patent-free filesystems that support long filenames. Where possible, it is recommended that embedded devices use one of these other filesystems. This will avoid compatibility issues and the danger of &lt;a href=&quot;shortnames#db83corrupt&quot;&gt;database corruption caused by inconsistent use of 8+3 filenames&lt;/a&gt;.</source>
          <target state="translated">对于此问题，建议的解决方法是选择其他文件系统。如今，支持长文件名的高性能，可靠，免专利的文件系统种类繁多。在可能的情况下，建议嵌入式设备使用这些其他文件系统之一。这将避免兼容性问题，以及&lt;a href=&quot;shortnames#db83corrupt&quot;&gt;由于不一致使用8 + 3文件名而导致数据库损坏&lt;/a&gt;的危险。</target>
        </trans-unit>
        <trans-unit id="25181bcaf1df8e046a1c955d3b9df90abb750621" translate="yes" xml:space="preserve">
          <source>The recommended setting is 0, meaning that double-quoted strings are disallowed in all contexts. However, the default setting is 3 for maximum compatibility with legacy applications.</source>
          <target state="translated">建议设置为0,这意味着在所有情况下都不允许使用双引号字符串。但是,为了最大限度地与传统应用程序兼容,默认设置为3。</target>
        </trans-unit>
        <trans-unit id="932d02d128af056f356f5d45448ef957094cec8a" translate="yes" xml:space="preserve">
          <source>The recommended usage pattern for the &lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;analysis_limit&lt;/a&gt; pragma is like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e4e6885559253d0ddfdbd8cf19b8d22821af1f" translate="yes" xml:space="preserve">
          <source>The recommended way of creating, updating, listing, and extracting an SQLite Archive is to use the &lt;a href=&quot;cli&quot;&gt;sqlite3.exe command-line shell&lt;/a&gt; for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;version 3.23.0&lt;/a&gt; (2018-04-02) or later. This CLI supports the -A command-line option that allows easy management of SQLite Archives. The CLI for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;version 3.22.0&lt;/a&gt; (2018-01-22) has the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt; for managing SQLite Archives, but that requires interacting with the shell.</source>
          <target state="translated">创建，更新，列出和提取SQLite存档的推荐方法是将&lt;a href=&quot;cli&quot;&gt;sqlite3.exe命令行外壳&lt;/a&gt;用于SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;3.23.0&lt;/a&gt;（2018-04-02）或更高版本。此CLI支持-A命令行选项，该选项可轻松管理SQLite存档。用于SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;3.22.0版&lt;/a&gt;（2018-01-22）的CLI 具有用于管理SQLite存档的&lt;a href=&quot;cli#sqlar&quot;&gt;.archive命令&lt;/a&gt;，但是需要与Shell进行交互。</target>
        </trans-unit>
        <trans-unit id="4601afd19c62f4d6f4dd6a59905680482f9f3f16" translate="yes" xml:space="preserve">
          <source>The record format makes extensive use of the &lt;a href=&quot;fileformat2#varint&quot;&gt;variable-length integer&lt;/a&gt; or &lt;a href=&quot;fileformat2#varint&quot;&gt;varint&lt;/a&gt; representation of 64-bit signed integers defined above.</source>
          <target state="translated">记录格式大量使用了上面定义的64位带符号整数的&lt;a href=&quot;fileformat2#varint&quot;&gt;变长整数&lt;/a&gt;或&lt;a href=&quot;fileformat2#varint&quot;&gt;varint&lt;/a&gt;表示形式。</target>
        </trans-unit>
        <trans-unit id="6f45dfeab7c8fdea2c19dfb3263b7e954261008d" translate="yes" xml:space="preserve">
          <source>The register P3 contains one less than the maximum number of allowed errors. At most reg(P3) errors will be reported. In other words, the analysis stops as soon as reg(P1) errors are seen. Reg(P1) is updated with the number of errors remaining.</source>
          <target state="translated">寄存器P3中包含的错误比最大允许的错误数少一个。最多只能报告reg(P3)错误。换句话说,一旦看到reg(P1)错误,分析就会停止。reg(P1)会根据剩余的错误数更新。</target>
        </trans-unit>
        <trans-unit id="b0a0f881a2de041dc76deecadc2825d6252c40fe" translate="yes" xml:space="preserve">
          <source>The registers P1 through P1+P2-1 contain a single row of results. This opcode causes the sqlite3_step() call to terminate with an SQLITE_ROW return code and it sets up the sqlite3_stmt structure to provide access to the r(P1)..r(P1+P2-1) values as the result row.</source>
          <target state="translated">寄存器P1到P1+P2-1包含了单行的结果。这个操作码导致sqlite3_step()调用以SQLITE_ROW返回代码终止,并且它设置了sqlite3_stmt结构以提供对r(P1)...r(P1+P2-1)值的访问作为结果行。</target>
        </trans-unit>
        <trans-unit id="3af4c8adff2c9c78e4e3d405284a88188dcbb490" translate="yes" xml:space="preserve">
          <source>The registers released will be the P2 registers starting at P1, except if bit ii of P3 set, then do not release register P1+ii. In other words, P3 is a mask of registers to preserve.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad008f7525662f6767cf59c0a5ffbf397455036" translate="yes" xml:space="preserve">
          <source>The relative precedence of the set operations is different. In particular, using the standard query syntax the &quot;OR&quot; operator has a higher precedence than &quot;AND&quot;. The precedence of operators when using the standard query syntax is:</source>
          <target state="translated">集合操作的相对优先性是不同的。特别是,使用标准查询语法时,&quot;OR &quot;操作符的优先级高于 &quot;AND&quot;。使用标准查询语法时,运算符的优先级是:</target>
        </trans-unit>
        <trans-unit id="4055a7e54aa1eb8dd8ef4889c3d207a5659a2b35" translate="yes" xml:space="preserve">
          <source>The release build is used to validate the generated machine code.</source>
          <target state="translated">发布构建是用来验证生成的机器代码。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
