<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="cae289508ac99f821f2b991e22b21782588d9eaa" translate="yes" xml:space="preserve">
          <source>The algorithm used by the sqlite3_blocking_step() function is as follows:</source>
          <target state="translated">sqlite3_blocking_step()函数使用的算法如下。</target>
        </trans-unit>
        <trans-unit id="ce63f03e43853b117cae180b17d7d91a1fc4423c" translate="yes" xml:space="preserve">
          <source>The alternate-form-2 flag is a non-standard extension that appears in no other printf() implementations, as far as we know.</source>
          <target state="translated">alternate-form-2 标志是一个非标准的扩展,据我们所知,它没有出现在其他 printf()实现中。</target>
        </trans-unit>
        <trans-unit id="28b22ace0382822e0d79f9e1827563fce76153d6" translate="yes" xml:space="preserve">
          <source>The alternative page cache mechanism is an extreme measure that is only needed by the most demanding applications. The built-in page cache is recommended for most uses.</source>
          <target state="translated">替代性页面缓存机制是一种极端措施,只有最苛刻的应用才需要。对于大多数用途,建议使用内置页面缓存。</target>
        </trans-unit>
        <trans-unit id="8b4794d01495b7d8ad2197d5e4f4f33e4044492d" translate="yes" xml:space="preserve">
          <source>The alternative query formulations shown above are conceptual only. SQLite does not really transform the query. The actual query plan is like this: SQLite locates the first possible value for &quot;role&quot;, which it can do by rewinding the &quot;people_idx1&quot; index to the beginning and reading the first record. SQLite stores this first &quot;role&quot; value in an internal variable that we will here call &quot;$role&quot;. Then SQLite runs a query like: &quot;SELECT name FROM people WHERE role=$role AND height&amp;gt;=180&quot;. This query has an equality constraint on the left-most column of the index and so the index can be used to resolve that query. Once that query is finished, SQLite then uses the &quot;people_idx1&quot; index to locate the next value of the &quot;role&quot; column, using code that is logically similar to &quot;SELECT role FROM people WHERE role&amp;gt;$role LIMIT 1&quot;. This new &quot;role&quot; value overwrites the $role variable, and the process repeats until all possible values for &quot;role&quot; have been examined.</source>
          <target state="translated">上面显示的替代查询公式仅是概念性的。 SQLite并不会真正改变查询。实际的查询计划是这样的：SQLite定位&amp;ldquo; role&amp;rdquo;的第一个可能值，可以通过将&amp;ldquo; people_idx1&amp;rdquo;索引倒退到开头并读取第一条记录来实现。 SQLite将此第一个&amp;ldquo; role&amp;rdquo;值存储在一个内部变量中，我们在这里将其称为&amp;ldquo; $ role&amp;rdquo;。然后，SQLite运行一个查询，例如：&amp;ldquo;从人的角色中选择名称，角色= $角色且高度&amp;gt; = 180&amp;rdquo;。该查询在索引的最左列具有相等约束，因此可以使用索引来解析该查询。该查询完成后，SQLite然后使用&amp;ldquo; people_idx1&amp;rdquo;索引来查找&amp;ldquo;角色&amp;rdquo;列的下一个值，并使用逻辑上类似于&amp;ldquo;在角色&amp;gt; $ role LIMIT 1&amp;ldquo;中从人员中选择角色。这个新的&amp;rdquo; role&amp;ldquo;值将覆盖$ role变量，然后重复该过程，直到检查了&amp;rdquo; role&amp;ldquo;的所有可能值。</target>
        </trans-unit>
        <trans-unit id="a91f523f7f1e692f775ff82bc9d632716d5637ec" translate="yes" xml:space="preserve">
          <source>The amalgamation and the sqlite3.h header file are available on the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; as a file named sqlite-amalgamation-X.zip where the X is replaced by the appropriate version number.</source>
          <target state="translated">合并和sqlite3.h标头文件在&lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;下载页面上&lt;/a&gt;以名为sqlite-amalgamation-X.zip的文件提供，其中X替换为适当的版本号。</target>
        </trans-unit>
        <trans-unit id="c0a154d12ef5a44def7683dee324b4a87567d061" translate="yes" xml:space="preserve">
          <source>The amalgamation contains everything you need to integrate SQLite into a larger project. Just copy the amalgamation into your source directory and compile it along with the other C code files in your project. (A &lt;a href=&quot;howtocompile&quot;&gt;more detailed discussion&lt;/a&gt; of the compilation process is available.) You may also want to make use of the &quot;sqlite3.h&quot; header file that defines the programming API for SQLite. The sqlite3.h header file is available separately. The sqlite3.h file is also contained within the amalgamation, in the first few thousand lines. So if you have a copy of sqlite3.c but cannot seem to locate sqlite3.h, you can always regenerate the sqlite3.h by copying and pasting from the amalgamation.</source>
          <target state="translated">合并包含将SQLite集成到更大项目中所需的一切。只需将合并内容复制到您的源目录中，然后将其与项目中的其他C代码文件一起编译即可。 （可以对编译过程进行&lt;a href=&quot;howtocompile&quot;&gt;更详细的讨论&lt;/a&gt;。）您可能还想使用&amp;ldquo; sqlite3.h&amp;rdquo;头文件，该头文件定义了SQLite的编程API。 sqlite3.h头文件可单独使用。 sqlite3.h文件也包含在合并后的前几千行中。因此，如果您拥有sqlite3.c的副本，但似乎无法找到sqlite3.h，则可以始终通过从合并中复制和粘贴来重新生成sqlite3.h。</target>
        </trans-unit>
        <trans-unit id="c5760ad296baf5ccd7d73666c3833985afa715a2" translate="yes" xml:space="preserve">
          <source>The amount of payload that spills onto overflow pages also depends on the page type. For the following computations, let U be the usable size of a database page, the total page size less the reserved space at the end of each page. And let P be the payload size. In the following, symbol X represents the maximum amount of payload that can be stored directly on the b-tree page without spilling onto an overflow page and symbol M represents the minimum amount of payload that must be stored on the btree page before spilling is allowed.</source>
          <target state="translated">溢出到溢出页上的有效载荷量也取决于页面类型。在下面的计算中,让U为数据库页面的可用大小,即总的页面大小减去每页末尾的保留空间。而让P为有效载荷大小。在下面的计算中,符号X表示在不溢出到溢出页的情况下可以直接存储在b树页上的最大有效载荷量,符号M表示在允许溢出之前必须存储在b树页上的最小有效载荷量。</target>
        </trans-unit>
        <trans-unit id="cc7c17ba1fc473503228a1ad5223b1322c93e902" translate="yes" xml:space="preserve">
          <source>The amount of space allocated by sqlite3_aggregate_context(C,N) is determined by the N parameter on first successful call. Changing the value of N in any subsequent call to sqlite3_aggregate_context() within the same aggregate function instance will not resize the memory allocation. Within the xFinal callback, it is customary to set N=0 in calls to sqlite3_aggregate_context(C,N) so that no pointless memory allocations occur.</source>
          <target state="translated">sqlite3_aggregate_context(C,N)分配的空间大小由第一次成功调用时的N参数决定。在同一个聚合函数实例中,在随后对 sqlite3_aggregate_context()的任何调用中改变 N 的值,都不会调整内存分配的大小。在xFinal回调中,习惯上在调用sqlite3_aggregate_context(C,N)时设置N=0,这样就不会发生无意义的内存分配。</target>
        </trans-unit>
        <trans-unit id="3035b3f13a8c2eedd1a82b2e759ec82828d6061b" translate="yes" xml:space="preserve">
          <source>The amount of space allocated by sqlite3_aggregate_context(C,N) is determined by the N parameter on first successful call. Changing the value of N in subsequent call to sqlite3_aggregate_context() within the same aggregate function instance will not resize the memory allocation. Within the xFinal callback, it is customary to set N=0 in calls to sqlite3_aggregate_context(C,N) so that no pointless memory allocations occur.</source>
          <target state="translated">sqlite3_aggregate_context(C,N)分配的空间大小由第一次成功调用时的N参数决定。在同一个聚合函数实例中,后续调用 sqlite3_aggregate_context()时改变 N 的值不会调整内存分配的大小。在xFinal回调中,习惯上在调用sqlite3_aggregate_context(C,N)时设置N=0,这样就不会发生无意义的内存分配。</target>
        </trans-unit>
        <trans-unit id="48fa74a585edf255bca976e35bf58c2115a55266" translate="yes" xml:space="preserve">
          <source>The android performance numbers for the write experiments are omitted because the performance tests on the Galaxy S3 are so random. Two consecutive runs of the exact same experiment would give wildly different times. And, to be fair, the performance of SQLite on android is slightly slower than writing directly to disk.</source>
          <target state="translated">由于Galaxy S3上的性能测试非常随机,所以省略了写实验的android性能数据。连续两次运行完全相同的实验,会得到迥然不同的时间。而且,为了公平起见,android上SQLite的性能比直接写到磁盘上要略慢。</target>
        </trans-unit>
        <trans-unit id="ba25e29078b648c595b0c513af632a78976e2d1a" translate="yes" xml:space="preserve">
          <source>The application file is portable across all operating systems, 32-bit and 64-bit and big- and little-endian architectures.</source>
          <target state="translated">该应用文件可在所有操作系统、32位和64位以及大、小迭代架构上移植。</target>
        </trans-unit>
        <trans-unit id="553858a0531981a9db580aff8d49f00f4db9f6bc" translate="yes" xml:space="preserve">
          <source>The application has made changes to the &lt;a href=&quot;fts3#*shadowtab&quot;&gt;FTS shadow tables&lt;/a&gt; directly, without using the FTS3/4 virtual table, causing the shadow tables to become out of sync with each other.</source>
          <target state="translated">该应用程序直接更改了&lt;a href=&quot;fts3#*shadowtab&quot;&gt;FTS影子表&lt;/a&gt;，而没有使用FTS3 / 4虚拟表，从而导致了影子表彼此不同步。</target>
        </trans-unit>
        <trans-unit id="744b17ec690883f96b76e631855849a6884a7431" translate="yes" xml:space="preserve">
          <source>The application must ensure that the 1st parameter to sqlite3_exec() is a valid and open &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">应用程序必须确保sqlite3_exec（）的第一个参数是有效且开放的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1a416f0180cf818dc5e0d104e2af8fd17ae77d32" translate="yes" xml:space="preserve">
          <source>The application must ensure that the 1st parameter to sqlite3_exec() is a valid and open &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">应用程序必须确保sqlite3_exec（）的第一个参数是有效且开放的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9dbea7596a56ecae7226dfed468f733b0ebf473a" translate="yes" xml:space="preserve">
          <source>The application must finalize every &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; in order to avoid resource leaks. It is a grievous error for the application to try to use a prepared statement after it has been finalized. Any use of a prepared statement after it has been finalized can result in undefined and undesirable behavior such as segfaults and heap corruption.</source>
          <target state="translated">应用程序必须完成每个&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;，以避免资源泄漏。应用程序在完成后尝试使用准备好的语句，这是一个严重的错误。在结束后使用任何准备好的语句都可能导致未定义的不良行为，例如segfaults和堆损坏。</target>
        </trans-unit>
        <trans-unit id="fb5d8c6646b2fcb9cbadc4a78abf91f82a6d7868" translate="yes" xml:space="preserve">
          <source>The application must finalize every &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; in order to avoid resource leaks. It is a grievous error for the application to try to use a prepared statement after it has been finalized. Any use of a prepared statement after it has been finalized can result in undefined and undesirable behavior such as segfaults and heap corruption.</source>
          <target state="translated">应用程序必须完成每个&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;，以避免资源泄漏。应用程序在完成后尝试使用准备好的语句，这是一个严重的错误。在结束后使用任何准备好的语句都可能导致未定义的不良行为，例如segfaults和堆损坏。</target>
        </trans-unit>
        <trans-unit id="99cabfda3eb8aea847c63c772b815f9008f98dc6" translate="yes" xml:space="preserve">
          <source>The application must not close the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the 1st parameter to sqlite3_exec() while sqlite3_exec() is running.</source>
          <target state="translated">运行sqlite3_exec（）时，应用程序不得关闭第一个参数指定的与sqlite3_exec（）的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e45e1c6c5dd0bb0af2de4709122fb9b7f5aa23a" translate="yes" xml:space="preserve">
          <source>The application must not close the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the 1st parameter to sqlite3_exec() while sqlite3_exec() is running.</source>
          <target state="translated">运行sqlite3_exec（）时，应用程序不得关闭第一个参数指定的与sqlite3_exec（）的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1ec93d570d3944810e00416d33fc158ef0b8df22" translate="yes" xml:space="preserve">
          <source>The application must not modify the SQL statement text passed into the 2nd parameter of sqlite3_exec() while sqlite3_exec() is running.</source>
          <target state="translated">当sqlite3_exec()运行时,应用程序不得修改传递到sqlite3_exec()第2个参数中的SQL语句文本。</target>
        </trans-unit>
        <trans-unit id="dd08aa5c98a2b87e47c47375f85e57ce41e870bc" translate="yes" xml:space="preserve">
          <source>The application must not read or write any part of a block of memory after it has been released using &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;释放应用程序后，该应用程序不得读取或写入该内存块的任何部分。</target>
        </trans-unit>
        <trans-unit id="04da8df88f025325ec4119082e7436a2ab79cfbf" translate="yes" xml:space="preserve">
          <source>The application must not read or write any part of a block of memory after it has been released using &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; or &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;或&lt;a href=&quot;free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;释放应用程序后，该应用程序不得读取或写入该内存块的任何部分。</target>
        </trans-unit>
        <trans-unit id="7136e470c61d513b5e2e7bb04278f687766f03e3" translate="yes" xml:space="preserve">
          <source>The application only has to load the data it needs, rather than reading the entire file and holding a complete parse in memory.</source>
          <target state="translated">应用程序只需要加载它所需要的数据,而不是读取整个文件并在内存中保持完整的解析。</target>
        </trans-unit>
        <trans-unit id="e521cca41ad74c95daa61ed9901e7bb27bdf7838" translate="yes" xml:space="preserve">
          <source>The application should never invoke either sqlite3_os_init() or sqlite3_os_end() directly. The application should only invoke sqlite3_initialize() and sqlite3_shutdown(). The sqlite3_os_init() interface is called automatically by sqlite3_initialize() and sqlite3_os_end() is called by sqlite3_shutdown(). Appropriate implementations for sqlite3_os_init() and sqlite3_os_end() are built into SQLite when it is compiled for Unix, Windows, or OS/2. When &lt;a href=&quot;../custombuild&quot;&gt;built for other platforms&lt;/a&gt; (using the &lt;a href=&quot;../compile#os_other&quot;&gt;SQLITE_OS_OTHER=1&lt;/a&gt; compile-time option) the application must supply a suitable implementation for sqlite3_os_init() and sqlite3_os_end(). An application-supplied implementation of sqlite3_os_init() or sqlite3_os_end() must return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and some other &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; upon failure.</source>
          <target state="translated">应用程序永远不要直接调用sqlite3_os_init（）或sqlite3_os_end（）。该应用程序仅应调用sqlite3_initialize（）和sqlite3_shutdown（）。 sqlite3_os_init（）接口由sqlite3_initialize（）自动调用，而sqlite3_os_end（）由sqlite3_shutdown（）调用。 SQLite为Unix，Windows或OS / 2编译时，sqlite3_os_init（）和sqlite3_os_end（）的适当实现已内置到SQLite中。当&lt;a href=&quot;../custombuild&quot;&gt;为其他平台构建&lt;/a&gt;（使用&lt;a href=&quot;../compile#os_other&quot;&gt;SQLITE_OS_OTHER = 1&lt;/a&gt;编译时选择）的应用程序必须提供用于sqlite3_os_init（）和sqlite3_os_end的合适的实现（）。应用程序提供的sqlite3_os_init（）或sqlite3_os_end（）实现必须在成功时返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;，并在其他情况下返回SQLITE_OK&lt;a href=&quot;../rescode&quot;&gt;&lt;/a&gt;失败时显示错误代码。</target>
        </trans-unit>
        <trans-unit id="5f9522c8f8708f8f795d05750d26ac94e862ee81" translate="yes" xml:space="preserve">
          <source>The application should never invoke either sqlite3_os_init() or sqlite3_os_end() directly. The application should only invoke sqlite3_initialize() and sqlite3_shutdown(). The sqlite3_os_init() interface is called automatically by sqlite3_initialize() and sqlite3_os_end() is called by sqlite3_shutdown(). Appropriate implementations for sqlite3_os_init() and sqlite3_os_end() are built into SQLite when it is compiled for Unix, Windows, or OS/2. When &lt;a href=&quot;custombuild&quot;&gt;built for other platforms&lt;/a&gt; (using the &lt;a href=&quot;compile#os_other&quot;&gt;SQLITE_OS_OTHER=1&lt;/a&gt; compile-time option) the application must supply a suitable implementation for sqlite3_os_init() and sqlite3_os_end(). An application-supplied implementation of sqlite3_os_init() or sqlite3_os_end() must return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success and some other &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; upon failure.</source>
          <target state="translated">应用程序永远不要直接调用sqlite3_os_init（）或sqlite3_os_end（）。该应用程序仅应调用sqlite3_initialize（）和sqlite3_shutdown（）。 sqlite3_os_init（）接口由sqlite3_initialize（）自动调用，而sqlite3_os_end（）由sqlite3_shutdown（）调用。 SQLite为Unix，Windows或OS / 2编译时，sqlite3_os_init（）和sqlite3_os_end（）的适当实现已内置到SQLite中。当&lt;a href=&quot;custombuild&quot;&gt;为其他平台构建&lt;/a&gt;（使用&lt;a href=&quot;compile#os_other&quot;&gt;SQLITE_OS_OTHER = 1&lt;/a&gt;编译时选择）的应用程序必须提供用于sqlite3_os_init（）和sqlite3_os_end的合适的实现（）。应用程序提供的sqlite3_os_init（）或sqlite3_os_end（）实现必须在成功时返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;，并在其他情况下返回SQLITE_OK&lt;a href=&quot;rescode&quot;&gt;&lt;/a&gt;失败时显示错误代码。</target>
        </trans-unit>
        <trans-unit id="371b08e858c1c9c61f57bffa9ac30d2c2c9616ae" translate="yes" xml:space="preserve">
          <source>The application wants to prevent other processes from accessing the database file.</source>
          <target state="translated">应用程序希望防止其他进程访问数据库文件。</target>
        </trans-unit>
        <trans-unit id="da9edea5d79c9c534eb8f394ef49ec7d996e51c8" translate="yes" xml:space="preserve">
          <source>The application_id PRAGMA is used to query or set the 32-bit signed big-endian &quot;Application ID&quot; integer located at offset 68 into the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;. Applications that use SQLite as their &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt; should set the Application ID integer to a unique integer so that utilities such as &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file(1)&lt;/a&gt; can determine the specific file type rather than just reporting &quot;SQLite3 Database&quot;. A list of assigned application IDs can be seen by consulting the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt; file in the SQLite source repository.</source>
          <target state="translated">application_id PRAGMA用于查询或将位于偏移量68处的32位带符号大端&amp;ldquo;应用程序ID&amp;rdquo;整数设置到&lt;a href=&quot;fileformat2#database_header&quot;&gt;数据库头中&lt;/a&gt;。使用SQLite作为其&lt;a href=&quot;appfileformat&quot;&gt;应用程序文件格式&lt;/a&gt;的应用程序应将Application ID整数设置为唯一的整数，以便诸如&lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file（1）之类的&lt;/a&gt;实用程序可以确定特定的文件类型，而不仅仅是报告&amp;ldquo; SQLite3数据库&amp;rdquo;。通过查询SQLite源存储库中的&lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt;文件，可以看到已分配的应用程序ID的列表。</target>
        </trans-unit>
        <trans-unit id="9cc4b4e7374316164e73ee8084ea97ba4afd41e4" translate="yes" xml:space="preserve">
          <source>The application_id PRAGMA is used to query or set the 32-bit signed big-endian &quot;Application ID&quot; integer located at offset 68 into the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;. Applications that use SQLite as their &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt; should set the Application ID integer to a unique integer so that utilities such as &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file(1)&lt;/a&gt; can determine the specific file type rather than just reporting &quot;SQLite3 Database&quot;. A list of assigned application IDs can be seen by consulting the &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt; file in the SQLite source repository.</source>
          <target state="translated">application_id PRAGMA用于查询或将位于偏移量68的32位带符号大端&amp;ldquo;应用程序ID&amp;rdquo;整数设置到&lt;a href=&quot;fileformat2#database_header&quot;&gt;数据库头中&lt;/a&gt;。使用SQLite作为其&lt;a href=&quot;appfileformat&quot;&gt;应用程序文件格式&lt;/a&gt;的应用程序应将Application ID整数设置为唯一的整数，以便诸如&lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file（1）之类的&lt;/a&gt;实用程序可以确定特定的文件类型，而不仅仅是报告&amp;ldquo; SQLite3数据库&amp;rdquo;。通过查询SQLite源存储库中的&lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt;文件，可以看到已分配的应用程序ID的列表。</target>
        </trans-unit>
        <trans-unit id="fbebe3f29ae821a203a540ede83fca7a51f6300e" translate="yes" xml:space="preserve">
          <source>The applications using this database are entitled to assume that for each row in the</source>
          <target state="translated">使用此数据库的应用程序有权假设,对于在</target>
        </trans-unit>
        <trans-unit id="c4abdec20da55bda36a7679394be4f500b633ccf" translate="yes" xml:space="preserve">
          <source>The argc parameter specifies the number of entries in the argv array. The value of argc will be 1 for a pure delete operation or N+2 for an insert or replace or update where N is the number of columns in the table. In the previous sentence, N includes any hidden columns.</source>
          <target state="translated">argc参数指定了argv数组中的条目数。argc的值对于纯删除操作来说是1,对于插入或替换或更新来说是N+2,其中N是表中的列数。在前一句中,N包括任何隐藏的列。</target>
        </trans-unit>
        <trans-unit id="b66b85dc16bc6667c3624ba8e6f64b24df3ac149" translate="yes" xml:space="preserve">
          <source>The argument N is the maximum number of bytes of the database file that will be accessed using memory-mapped I/O. If N is zero then memory mapped I/O is disabled. If N is negative, then the limit reverts to the default value determined by the most recent &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;), or to the compile time default determined by &lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt; if not start-time limit has been set.</source>
          <target state="translated">参数N是将使用内存映射的I / O访问的数据库文件的最大字节数。如果N为零，则禁用内存映射的I / O。如果N为负，则限制将恢复为由最新&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;）确定的默认值，或者恢复为由&lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt;确定的编译时间默认值（如果未设置开始时间限制）。</target>
        </trans-unit>
        <trans-unit id="7500855ec2b0357e501bb580486bc273725ede2e" translate="yes" xml:space="preserve">
          <source>The argument can be either the text of an SQL statement, in which case the bytecode (or tables_used) for that statement is returned, or the argument can be a parameter such as ?1 or $stmt that is later bound to a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; interface. Use a pointer type of &quot;stmt-pointer&quot; for the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; interface.</source>
          <target state="translated">参数可以是SQL语句的文本，在这种情况下，将返回该语句的字节码（或tables_used），或者参数可以是诸如？1或$ stmt之类的参数，该参数随后绑定到&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;对象使用&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;接口。在&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;接口中使用&amp;ldquo; stmt-pointer&amp;rdquo;指针类型。</target>
        </trans-unit>
        <trans-unit id="ab61127b621c6e57d8aaaae340d80e94025b5867" translate="yes" xml:space="preserve">
          <source>The argument is a double which is displayed in decimal.</source>
          <target state="translated">参数是一个双数,以十进制显示。</target>
        </trans-unit>
        <trans-unit id="7c92aff7ca85efdc01cd4da9e4f23a18dad234e0" translate="yes" xml:space="preserve">
          <source>The argument is a double which is displayed in either normal decimal notation or if the exponent is not close to zero, in exponential notation.</source>
          <target state="translated">参数是一个双数,可以用普通的十进制符号显示,如果指数不接近零,则用指数符号显示。</target>
        </trans-unit>
        <trans-unit id="2096ff23b8873f39597795db4f99b816ed776fc9" translate="yes" xml:space="preserve">
          <source>The argument is a double which is displayed in exponential notation. The exponent character is 'e' or 'E' depending on the type.</source>
          <target state="translated">参数是一个双数,以指数符号显示。指数字符是'e'或'E',取决于类型。</target>
        </trans-unit>
        <trans-unit id="11129b8da0d471f1bf24142ea87e57c0024e71a8" translate="yes" xml:space="preserve">
          <source>The argument is a pointer to an integer. Nothing is displayed for this substitution type. Instead, the integer to which the argument points is overwritten with the number of characters in the generated string that result from all format symbols to the left of the %n.</source>
          <target state="translated">参数是指向一个整数的指针。对于这种替换类型,不显示任何内容。取而代之的是,参数指向的整数会被生成的字符串中%n左边的所有格式符号所产生的字符数所覆盖。</target>
        </trans-unit>
        <trans-unit id="e6906c7030bdaf7b36a456360b0fbb4934d1a4ca" translate="yes" xml:space="preserve">
          <source>The argument is a pointer which is displayed as a hexadecimal address. Since the SQL language has no concept of a pointer, the %p substitution for the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; works like %x.</source>
          <target state="translated">参数是一个显示为十六进制地址的指针。由于SQL语言没有指针的概念，因此&lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf（）SQL函数&lt;/a&gt;的％p替代项类似于％x。</target>
        </trans-unit>
        <trans-unit id="e27c7fe9a83c9f08bcef3b205174fd7f4958e0c9" translate="yes" xml:space="preserve">
          <source>The argument is a signed integer which is displayed in decimal.</source>
          <target state="translated">参数是一个有符号的整数,以十进制显示。</target>
        </trans-unit>
        <trans-unit id="9b566b967632a4d496722ab350e0797c5b50a8e6" translate="yes" xml:space="preserve">
          <source>The argument is a zero-terminated string that is displayed. For the %z type in C-language interfaces, &lt;a href=&quot;c3ref/free&quot; id=&quot;percentz&quot;&gt;sqlite3_free()&lt;/a&gt; is invoked on the string after it has be copied into the output. The %s and %z substitutions are identical for the SQL printf() function.</source>
          <target state="translated">该参数是一个以零结尾的字符串。对于C语言界面中的％z类型，在将字符串复制到输出中之后，将在字符串上调用&lt;a href=&quot;c3ref/free&quot; id=&quot;percentz&quot;&gt;sqlite3_free（）&lt;/a&gt;。对于SQL printf（）函数，％s和％z替换是相同的。</target>
        </trans-unit>
        <trans-unit id="fcbbea9fc49916ff3eab8108379983087fe602ea" translate="yes" xml:space="preserve">
          <source>The argument is a zero-terminated string. The string is printed with all single quote (') characters doubled so that the string can safely appear inside an SQL string literal. The %Q substitution type also puts single-quotes on both ends of the substituted string.</source>
          <target state="translated">参数是一个零结尾的字符串。字符串在打印时,所有单引号(')字符都会加倍,这样字符串就可以安全地出现在一个SQL字符串的文字中。%Q替换类型也会在被替换字符串的两端加上单引号。</target>
        </trans-unit>
        <trans-unit id="f7cdf0497339bca82de3b36c80d3d61e29bc5c49" translate="yes" xml:space="preserve">
          <source>The argument is an integer which is displayed in hexadecimal. Lower-case hexadecimal is used for %x and upper-case is used for %X</source>
          <target state="translated">参数是一个整数,以十六进制显示,小写的十六进制用于%x,大写的用于%X。小写的十六进制表示%x,大写的表示%X。</target>
        </trans-unit>
        <trans-unit id="e8fcc09e116d95e79ec104c4fc555cc628b5c95b" translate="yes" xml:space="preserve">
          <source>The argument is an integer which is displayed in octal.</source>
          <target state="translated">参数是一个整数,以八进制显示。</target>
        </trans-unit>
        <trans-unit id="544017bf0d02198d9d372e60ce173d51892cc644" translate="yes" xml:space="preserve">
          <source>The argument is an unsigned integer which is displayed in decimal.</source>
          <target state="translated">参数是一个无符号整数,以十进制显示。</target>
        </trans-unit>
        <trans-unit id="5c161c084d3e3e79567bd33437dedcb35b7796bf" translate="yes" xml:space="preserve">
          <source>The argument is the symbolic name for the desired VFS. If the argument is a NULL pointer, then the default VFS is returned. The function returns a pointer to the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object that implements the VFS. Or it returns a NULL pointer if no object could be found that matched the search criteria.</source>
          <target state="translated">该参数是所需VFS的符号名称。如果参数是NULL指针，则返回默认的VFS。该函数返回一个指向实现VFS 的&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的指针。或者，如果找不到符合搜索条件的对象，则返回NULL指针。</target>
        </trans-unit>
        <trans-unit id="850af1642ffa208db124c3d32de875df305d3783" translate="yes" xml:space="preserve">
          <source>The argument to INTO can be a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; if URI filenames are enabled. URL filenames are enabled if any of the following are true:</source>
          <target state="translated">如果启用了&lt;a href=&quot;uri&quot;&gt;URI文件名，&lt;/a&gt;则INTO的参数可以是URI文件名。如果满足以下任一条件，则启用URL文件名：</target>
        </trans-unit>
        <trans-unit id="5b032a307670cabd16d781ba02c89e270db9d32d" translate="yes" xml:space="preserve">
          <source>The argument to the timeout method is the maximum number of milliseconds to wait for the lock to clear. So in the example above, the maximum delay would be 2 seconds.</source>
          <target state="translated">超时方法的参数是等待锁清除的最大毫秒数。所以在上面的例子中,最大的延迟是2秒。</target>
        </trans-unit>
        <trans-unit id="6304247ca5d53ec4d2f27644451268a5fc4c44d5" translate="yes" xml:space="preserve">
          <source>The arguments passed to the &quot;tokenchars=&quot; or &quot;separators=&quot; options are case-sensitive. In the example above, specifying that &quot;X&quot; is a separator character does not affect the way &quot;x&quot; is handled.</source>
          <target state="translated">传递给 &quot;tokenchars=&quot; 或 &quot;separators=&quot; 选项的参数是区分大小写的。在上面的例子中,指定 &quot;X &quot;为分隔符不会影响 &quot;x &quot;的处理方式。</target>
        </trans-unit>
        <trans-unit id="f42ca2142ac7440fc4af993ad46bce7740b98121" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;b&gt;sqlite_busy_handler&lt;/b&gt; are the opaque structure returned from &lt;b&gt;sqlite_open&lt;/b&gt;, a pointer to the busy callback function, and a generic pointer that will be passed as the first argument to the busy callback. When SQLite invokes the busy callback, it sends it three arguments: the generic pointer that was passed in as the third argument to &lt;b&gt;sqlite_busy_handler&lt;/b&gt;, the name of the database table or index that the library is trying to access, and the number of times that the library has attempted to access the database table or index.</source>
          <target state="translated">到的参数&lt;b&gt;sqlite_busy_handler&lt;/b&gt;从返回的不透明结构&lt;b&gt;sqlite_open&lt;/b&gt;，指针繁忙的回调函数，这将作为第一个参数繁忙回调传递一个通用的指针。当SQLite调用忙回调时，它将向它发送三个参数：作为第三个参数传递给&lt;b&gt;sqlite_busy_handler&lt;/b&gt;的通用指针，库正试图访问的数据库表或索引的名称以及库已尝试访问数据库表或索引。</target>
        </trans-unit>
        <trans-unit id="6fa9f93d8e2b44eeb698d1ed1229d89e77acc71a" translate="yes" xml:space="preserve">
          <source>The argv[0] parameter is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of a row in the virtual table to be deleted. If argv[0] is an SQL NULL, then no deletion occurs.</source>
          <target state="translated">所述的argv [0]的参数是&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;一排中的虚拟表被删除。如果argv [0]是SQL NULL，则不会发生删除。</target>
        </trans-unit>
        <trans-unit id="94f42e72810bd428d0a06485b57a23695591e88c" translate="yes" xml:space="preserve">
          <source>The argv[1] parameter is the rowid of a new row to be inserted into the virtual table. If argv[1] is an SQL NULL, then the implementation must choose a rowid for the newly inserted row. Subsequent argv[] entries contain values of the columns of the virtual table, in the order that the columns were declared. The number of columns will match the table declaration that the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method made using the &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; call. All hidden columns are included.</source>
          <target state="translated">argv [1]参数是要插入到虚拟表中的新行的rowid。如果argv [1]是SQL NULL，则实现必须为新插入的行选择一个rowid。随后的argv []条目包含虚拟表的列的值，并以声明列的顺序。列数将与使用&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt;调用的&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;或&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;方法做出的表声明匹配。包括所有隐藏的列。</target>
        </trans-unit>
        <trans-unit id="960c591f856ba7201455da5f944d6e4f1ebae33d" translate="yes" xml:space="preserve">
          <source>The arrows from the small circles labeled with &quot;*&quot; indicate the cost of running each loop with no dependencies. The outer loop must use this *-cost. Inner loops have the option of using the *-cost or a cost assuming one of the other terms is in an outer loop, whichever gives the best result. One can think of the *-costs as a short-hand notation indicating multiple arcs, one from each of the other nodes in the graph. The graph is therefore &quot;complete&quot;, meaning that there are arcs (some explicit and some implied) in both directions between every pair of nodes in the graph.</source>
          <target state="translated">从标有 &quot;*&quot;的小圆圈中的箭头表示在没有依赖关系的情况下运行每个循环的成本。外循环必须使用这个*成本。内循环可以选择使用*成本或假设其他项中有一项在外循环中的成本,以得到最佳结果为准。我们可以把*-costs看作是一个简短的符号,表示多条弧线,每条弧线来自图中的其他节点。因此,该图是 &quot;完整 &quot;的,这意味着在图中的每一对节点之间都有两个方向的弧线(有些是显式的,有些是隐式的)。</target>
        </trans-unit>
        <trans-unit id="d6a2923f627b3acd76aca2425895d68fa7fb43f5" translate="yes" xml:space="preserve">
          <source>The assert(X) macro is &lt;a href=&quot;https://en.wikipedia.org/wiki/Assert.h&quot;&gt;part of standard C&lt;/a&gt;, in the &amp;lt;assert.h&amp;gt; header file. SQLite adds three other assert()-like macros named NEVER(X), ALWAYS(X), and testcase(X).</source>
          <target state="translated">assert（X）宏是&amp;lt;assert.h&amp;gt;头文件&lt;a href=&quot;https://en.wikipedia.org/wiki/Assert.h&quot;&gt;中标准C的一部分&lt;/a&gt;。SQLite添加了其他三个类似assert（）的宏，分别称为NEVER（X），ALWAYS（X）和testcase（X）。</target>
        </trans-unit>
        <trans-unit id="8da4f4835817f9b4a63cc18fb5421f7207d5d808" translate="yes" xml:space="preserve">
          <source>The asynchronous I/O VFS is registered (and unregistered) by calls to the API functions sqlite3async_initialize() and sqlite3async_shutdown(). See section &quot;Compilation and Usage&quot; below for details.</source>
          <target state="translated">异步I/O VFS是通过调用API函数sqlite3async_initialize()和sqlite3async_shutdown()来注册(和取消注册)的。详情请参见下面的 &quot;编译和使用 &quot;一节。</target>
        </trans-unit>
        <trans-unit id="535287426332e5a1ad8bec16b3d83b02751661a5" translate="yes" xml:space="preserve">
          <source>The asynchronous IO VFS API is described in detail in comments in sqlite3async.h. Using the API usually consists of the following steps:</source>
          <target state="translated">异步IO VFS API在sqlite3async.h中的注释中有详细描述,使用API通常包括以下步骤。</target>
        </trans-unit>
        <trans-unit id="99f2292b58193481d23d957b96b6816c332c0bd5" translate="yes" xml:space="preserve">
          <source>The asynchronous IO extension consists of a single file of C code (sqlite3async.c), and a header file (sqlite3async.h), located in the &lt;a href=&quot;http://www.sqlite.org/src/dir?name=ext/async&quot;&gt; &lt;code&gt;ext/async/&lt;/code&gt; subfolder&lt;/a&gt; of the SQLite source tree, that defines the C API used by applications to activate and control the modules functionality.</source>
          <target state="translated">异步IO扩展由一个C代码文件（sqlite3async.c）和一个头文件（sqlite3async.h）组成，该&lt;a href=&quot;http://www.sqlite.org/src/dir?name=ext/async&quot;&gt;文件&lt;/a&gt;位于SQLite源树的 &lt;code&gt;ext/async/&lt;/code&gt; 子文件夹中，用于定义应用程序使用的C API激活和控制模块功能。</target>
        </trans-unit>
        <trans-unit id="3af3b819095a3c9a894e17624182795ef0341654" translate="yes" xml:space="preserve">
          <source>The asynchronous IO extension consists of a single file of C code (sqlite3async.c), and a header file (sqlite3async.h), located in the &lt;a href=&quot;https://www.sqlite.org/src/dir?name=ext/async&quot;&gt; &lt;code&gt;ext/async/&lt;/code&gt; subfolder&lt;/a&gt; of the SQLite source tree, that defines the C API used by applications to activate and control the modules functionality.</source>
          <target state="translated">异步IO扩展由一个C代码文件（sqlite3async.c）和一个头文件（sqlite3async.h）组成，该&lt;a href=&quot;https://www.sqlite.org/src/dir?name=ext/async&quot;&gt;文件&lt;/a&gt;位于SQLite源树的 &lt;code&gt;ext/async/&lt;/code&gt; 子文件夹中，用于定义应用程序使用的C API激活和控制模块功能。</target>
        </trans-unit>
        <trans-unit id="fa3d3b11288ba36989fe692263c29b42026caa0f" translate="yes" xml:space="preserve">
          <source>The asynchronous SQLite is just a shade slower than MySQL on this test. (MySQL seems to be especially adept at INSERT...SELECT statements.) The PostgreSQL engine is still thrashing - most of the 61 seconds it used were spent waiting on disk I/O.</source>
          <target state="translated">异步SQLite在这次测试中只是比MySQL慢了一丝。(MySQL似乎特别擅长INSERT......SELECT语句。)PostgreSQL引擎仍然在打转--它所用的61秒中的大部分时间都花在了等待磁盘I/O上。</target>
        </trans-unit>
        <trans-unit id="09f0791bf3a9c39b17b6897fd1eef3b3d7a8e21f" translate="yes" xml:space="preserve">
          <source>The atomic commit mechanism in SQLite has proven to be robust, but it can be circumvented by a sufficiently creative adversary or a sufficiently broken operating system implementation. This section describes a few of the ways in which an SQLite database might be corrupted by a power failure or system crash. (See also: &lt;a href=&quot;howtocorrupt&quot;&gt;How To Corrupt Your Database Files&lt;/a&gt;.)</source>
          <target state="translated">SQLite中的原子提交机制已被证明是健壮的，但是可以由足够有创造力的对手或足够破坏的操作系统实现来绕开。本节介绍了几种因电源故障或系统崩溃而损坏SQLite数据库的方法。（另请参见：&lt;a href=&quot;howtocorrupt&quot;&gt;如何损坏数据库文件&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="be392afd276ea778d7374d96f033564d6dcc8ac2" translate="yes" xml:space="preserve">
          <source>The attacker can submit a maliciously crafted database file to the application that the application will then open and query.</source>
          <target state="translated">攻击者可以向应用程序提交一个恶意制作的数据库文件,然后应用程序将打开并查询。</target>
        </trans-unit>
        <trans-unit id="a4da2591e4ae0c979cba5f61016108bf072266c8" translate="yes" xml:space="preserve">
          <source>The attacker can submit and run arbitrary SQL statements.</source>
          <target state="translated">攻击者可以提交并运行任意SQL语句。</target>
        </trans-unit>
        <trans-unit id="7497e373861cdeb1f861bd3cb7a15f476a8a4234" translate="yes" xml:space="preserve">
          <source>The author of Lemon and SQLite (Hipp) reports that his C programming skills were greatly enhanced by studying John Ousterhout's original source code to Tcl. Hipp discovered and studied Tcl in 1993. Lemon was written before then, and SQLite afterwards. There is a clear difference in the coding styles of these two products, with SQLite seeming to be cleaner, more readable, and easier to maintain.</source>
          <target state="translated">Lemon和SQLite》的作者(Hipp)报告说,通过学习John Ousterhout对Tcl的原始源代码,他的C语言编程技能得到了极大的提升。Hipp在1993年发现并研究了Tcl。Lemon是在那之前写的,而SQLite是在那之后写的。这两款产品的编码风格有明显的区别,SQLite似乎更干净,更易读,更容易维护。</target>
        </trans-unit>
        <trans-unit id="b01615602e972abb3c5942edbe63b3d8efbfa2ac" translate="yes" xml:space="preserve">
          <source>The authority may be omitted, may be blank, or may be &quot;&lt;code&gt;localhost&lt;/code&gt;&quot;. Any other authority results in an error. Exception: If SQLite is compiled with &lt;a href=&quot;compile#allow_uri_authority&quot;&gt;SQLITE_ALLOW_URI_AUTHORITY&lt;/a&gt; then any authority value other than &quot;localhost&quot; is passed through to the underlying operating system as a UNC filename.</source>
          <target state="translated">授权可以省略，可以为空白，也可以为&amp;ldquo; &lt;code&gt;localhost&lt;/code&gt; &amp;rdquo;。任何其他授权都会导致错误。例外：如果使用&lt;a href=&quot;compile#allow_uri_authority&quot;&gt;SQLITE_ALLOW_URI_AUTHORITY&lt;/a&gt;编译SQLite，则除&amp;ldquo; localhost&amp;rdquo;以外的任何权限值都将作为UNC文件名传递到基础操作系统。</target>
        </trans-unit>
        <trans-unit id="939e9fe5172b44eee1c6df02720143adc80675d6" translate="yes" xml:space="preserve">
          <source>The authorizer callback must not do anything that will modify the database connection that invoked the authorizer callback. Note that &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">授权者回调不得做任何会修改调用授权者回调的数据库连接的操作。请注意，在本段中，&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;都修改了其数据库连接，以实现&amp;ldquo;修改&amp;rdquo;的含义。</target>
        </trans-unit>
        <trans-unit id="cd0b9544f8e0ba2efe9de0f3a90df70febb9c84b" translate="yes" xml:space="preserve">
          <source>The authorizer callback must not do anything that will modify the database connection that invoked the authorizer callback. Note that &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">授权者回调不得做任何会修改调用授权者回调的数据库连接的操作。请注意，在本段中，&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;和&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;都修改了其数据库连接，以实现&amp;ldquo;修改&amp;rdquo;的含义。</target>
        </trans-unit>
        <trans-unit id="df84d2005e831c09e4f96777c00aabce6c502fa9" translate="yes" xml:space="preserve">
          <source>The automatic indexing capability can be disabled at run-time using the &lt;a href=&quot;pragma#pragma_automatic_index&quot;&gt;automatic_index pragma&lt;/a&gt;. Automatic indexing is turned on by default, but this can be changed so that automatic indexing is off by default using the &lt;a href=&quot;compile#default_automatic_index&quot;&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX&lt;/a&gt; compile-time option. The ability to create automatic indexes can be completely disabled by compiling with the &lt;a href=&quot;compile#omit_automatic_index&quot;&gt;SQLITE_OMIT_AUTOMATIC_INDEX&lt;/a&gt; compile-time option.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;pragma#pragma_automatic_index&quot;&gt;automatic_index pragma&lt;/a&gt;禁用自动索引功能。默认情况下，自动索引编制处于打开状态，但是可以更改此设置，以便默认情况下使用&lt;a href=&quot;compile#default_automatic_index&quot;&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX&lt;/a&gt;编译时选项可以关闭自动索引编制。通过使用&lt;a href=&quot;compile#omit_automatic_index&quot;&gt;SQLITE_OMIT_AUTOMATIC_INDEX&lt;/a&gt;编译时选项进行编译，可以完全禁用创建自动索引的功能。</target>
        </trans-unit>
        <trans-unit id="861ac52bff28d8b37d00f46c9e8ab0bcdffeef17" translate="yes" xml:space="preserve">
          <source>The automatic indexing capability can be disabled at run-time using the &lt;a href=&quot;pragma#pragma_automatic_index&quot;&gt;automatic_index pragma&lt;/a&gt;. Automatic indexing is turned on by default, but this can be changed so that automatic indexing is off by default using the &lt;a href=&quot;compile#default_automatic_index&quot;&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX&lt;/a&gt; compile-time option. The ability to create automatic indices can be completely disabled by compiling with the &lt;a href=&quot;compile#omit_automatic_index&quot;&gt;SQLITE_OMIT_AUTOMATIC_INDEX&lt;/a&gt; compile-time option.</source>
          <target state="translated">可以在运行时使用&lt;a href=&quot;pragma#pragma_automatic_index&quot;&gt;automatic_index pragma&lt;/a&gt;禁用自动索引功能。默认情况下，自动索引编制处于打开状态，但是可以更改该&lt;a href=&quot;compile#default_automatic_index&quot;&gt;属性，以便&lt;/a&gt;默认情况下使用SQLITE_DEFAULT_AUTOMATIC_INDEX编译时选项可以关闭自动索引编制。通过使用&lt;a href=&quot;compile#omit_automatic_index&quot;&gt;SQLITE_OMIT_AUTOMATIC_INDEX&lt;/a&gt;编译时选项进行编译，可以完全禁用创建自动索引的功能。</target>
        </trans-unit>
        <trans-unit id="ea88f1175fb0f90865a8970907b5e05e253378e5" translate="yes" xml:space="preserve">
          <source>The avg() function returns the average value of all non-NULL</source>
          <target state="translated">函数avg()返回所有非NULL对象的平均值。</target>
        </trans-unit>
        <trans-unit id="c29cb183c63bdd561faeb944d923a238a65c8f1b" translate="yes" xml:space="preserve">
          <source>The b-tree algorithm provides key/data storage with unique and ordered keys on page-oriented storage devices. For background information on b-trees, see Knuth, &lt;u&gt;The Art Of Computer Programming&lt;/u&gt;, Volume 3 &quot;Sorting and Searching&quot;, pages 471-479. Two kinds of b-trees are used by SQLite. The algorithm that Knuth calls &quot;B*-Tree&quot; stores all data in the leaves of the tree. SQLite calls this variety of b-tree a &quot;table b-tree&quot;. The algorithm that Knuth calls simply &quot;B-Tree&quot; stores both the key and the data together in both leaves and in interior pages. In the SQLite implementation, the original B-Tree algorithm stores keys only, omitting the data entirely, and is called an &quot;index b-tree&quot;.</source>
          <target state="translated">b树算法在面向页面的存储设备上提供具有唯一和有序密钥的密钥/数据存储。有关b树的背景信息，请参见Knuth，&lt;u&gt;计算机编程艺术&lt;/u&gt;，第3卷&amp;ldquo;排序和搜索&amp;rdquo;，第471-479页。 SQLite使用两种b树。 Knuth称为&amp;ldquo; B *-树&amp;rdquo;的算法将所有数据存储在树的叶子中。 SQLite将此各种各样的b树称为&amp;ldquo;表b树&amp;rdquo;。 Knuth简单地称其为&amp;ldquo; B树&amp;rdquo;的算法将密钥和数据存储在叶子和内部页面中。在SQLite实现中，原始的B树算法仅存储键，完全省略了数据，被称为&amp;ldquo;索引b树&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d112311c7e2ccc4f400060b3e5337023ffd30dd4" translate="yes" xml:space="preserve">
          <source>The b-tree algorithm provides key/data storage with unique and ordered keys on page-oriented storage devices. For background information on b-trees, see Knuth, &lt;u&gt;The Art Of Computer Programming&lt;/u&gt;, Volume 3 &quot;Sorting and Searching&quot;, pages 471-479. Two variants of b-trees are used by SQLite. &quot;Table b-trees&quot; use a 64-bit signed integer key and store all data in the leaves. &quot;Index b-trees&quot; use arbitrary keys and store no data at all.</source>
          <target state="translated">b树算法在面向页面的存储设备上提供具有唯一和有序密钥的密钥/数据存储。有关b树的背景信息，请参阅Knuth，&lt;u&gt;计算机编程艺术&lt;/u&gt;，第3卷&amp;ldquo;排序和搜索&amp;rdquo;，第471-479页。SQLite使用b树的两种变体。&amp;ldquo;表b树&amp;rdquo;使用64位带符号整数键并将所有数据存储在叶子中。&amp;ldquo;索引b树&amp;rdquo;使用任意键，并且根本不存储任何数据。</target>
        </trans-unit>
        <trans-unit id="bb8fb65a49101b4953ed3553fa6d2836b2742f88" translate="yes" xml:space="preserve">
          <source>The b-tree page header is 8 bytes in size for leaf pages and 12 bytes for interior pages. All multibyte values in the page header are big-endian. The b-tree page header is composed of the following fields:</source>
          <target state="translated">b-tree页头的大小,叶子页为8字节,内页为12字节。页头中的所有多字节值都是大字段。b-tree页头由以下字段组成。</target>
        </trans-unit>
        <trans-unit id="b3cbe5b0fd4215124588bcf352c662cc2398e510" translate="yes" xml:space="preserve">
          <source>The backup API copies the content of one database into another. It is useful either for creating backups of databases or for copying in-memory databases to or from persistent files.</source>
          <target state="translated">备份 API 将一个数据库的内容复制到另一个数据库中。它对于创建数据库的备份或将内存中的数据库复制到持久性文件或从持久性文件中复制出来都很有用。</target>
        </trans-unit>
        <trans-unit id="2cf1eb05a922a766ec8d7dd18ed7d6f4aa38bd5f" translate="yes" xml:space="preserve">
          <source>The backupDb() function uses the sqlite3_backup_remaining() and sqlite3_backup_pagecount() functions to report its progress via the user-supplied xProgress() callback. Function sqlite3_backup_remaining() returns the number of pages left to copy and sqlite3_backup_pagecount() returns the total number of pages in the source database (in this case the database opened by pDb). So the percentage completion of the process may be calculated as:</source>
          <target state="translated">backupDb()函数使用sqlite3_backup_remaining()和sqlite3_backup_pagecount()函数通过用户提供的xProgress()回调报告其进度。函数sqlite3_backup_remaining()返回剩余的复制页数,sqlite3_backup_pagecount()返回源数据库(本例中是pDb打开的数据库)的总页数。所以,这个过程的完成百分比可以计算为。</target>
        </trans-unit>
        <trans-unit id="6b553d2761ee3fe64acd25548c40d0f8e4d42c23" translate="yes" xml:space="preserve">
          <source>The base window may not specify a frame specification. The frame specification can only be given in the new window specification.</source>
          <target state="translated">基本窗口不得指定框架规格。框架规格只能在新窗口规格中给出。</target>
        </trans-unit>
        <trans-unit id="5c2a91b9a2da4a8d6526f62c2bd849ce606c97d4" translate="yes" xml:space="preserve">
          <source>The basic algorithm for computing the content of the recursive table is as follows:</source>
          <target state="translated">计算递归表内容的基本算法如下。</target>
        </trans-unit>
        <trans-unit id="cc257445d9ceee252762e517b278c85329543c96" translate="yes" xml:space="preserve">
          <source>The basic principals described above apply to both ordinary rowid tables and &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. The only difference is that the rowid column that serves as the key for tables and that appears as the right-most term in indexes is replaced by the PRIMARY KEY.</source>
          <target state="translated">上面描述的基本原理适用于普通rowid表和&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表。唯一的区别是，用作表键且在索引中最右边出现的rowid列被PRIMARY KEY取代。</target>
        </trans-unit>
        <trans-unit id="07bf749b7aaedba2ca3c53251a2ebc2903cbff5d" translate="yes" xml:space="preserve">
          <source>The basic procedure above may modified by the following additional rules:</source>
          <target state="translated">上述基本程序可通过以下附加规则进行修改:</target>
        </trans-unit>
        <trans-unit id="5580fafc283a76d74ea47e0554226ba42ea5bc40" translate="yes" xml:space="preserve">
          <source>The behavior implemented by the AUTOINCREMENT keyword is subtly different from the default behavior. With AUTOINCREMENT, rows with automatically selected ROWIDs are guaranteed to have ROWIDs that have never been used before by the same table in the same database. And the automatically generated ROWIDs are guaranteed to be monotonically increasing. These are important properties in certain applications. But if your application does not need these properties, you should probably stay with the default behavior since the use of AUTOINCREMENT requires additional work to be done as each row is inserted and thus causes INSERTs to run a little slower.</source>
          <target state="translated">AUTOINCREMENT关键字实现的行为与默认行为有细微的不同。使用AUTOINCREMENT,保证自动选择的ROWIDs的行,其ROWIDs从未被同一数据库中的同一张表使用过。而且保证自动生成的ROWIDs是单调增加的。这些在某些应用中是很重要的特性。但是如果你的应用程序不需要这些属性,你可能应该保持默认的行为,因为使用AUTOINCREMENT需要在插入每条记录时做额外的工作,因此会导致INSERTs运行得更慢一些。</target>
        </trans-unit>
        <trans-unit id="53ddd9ac28fbcaf8f2c3233a5b531ac7ced77a80" translate="yes" xml:space="preserve">
          <source>The behavior of cache_size with a negative N was different prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16). In earlier versions, the number of pages in the cache was set to the absolute value of N.</source>
          <target state="translated">在&lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;版本3.7.10&lt;/a&gt;（2012-01-16）之前，具有负N的cache_size的行为是不同的。在早期版本中，缓存中的页面数设置为N的绝对值。</target>
        </trans-unit>
        <trans-unit id="478ce327d17671071ecdc539934c95e63faeda7c" translate="yes" xml:space="preserve">
          <source>The behavior of sqlite3changeset_apply_v2() and its streaming equivalent may be modified by passing a combination of &lt;a href=&quot;#SQLITE_CHANGESETAPPLY_INVERT&quot;&gt;supported flags&lt;/a&gt; as the 9th parameter.</source>
          <target state="translated">sqlite3changeset_apply_v2（）的行为及其流等效项可以通过将&lt;a href=&quot;#SQLITE_CHANGESETAPPLY_INVERT&quot;&gt;支持的标志&lt;/a&gt;的组合作为第9个参数来进行修改。</target>
        </trans-unit>
        <trans-unit id="6e75893c7d343c6a289f5aa0da4c1e36a51499e7" translate="yes" xml:space="preserve">
          <source>The behavior of sqlite3changeset_apply_v2() and its streaming equivalent may be modified by passing a combination of &lt;a href=&quot;c_changesetapply_invert&quot;&gt;supported flags&lt;/a&gt; as the 9th parameter.</source>
          <target state="translated">sqlite3changeset_apply_v2（）的行为及其流等效项可以通过将&lt;a href=&quot;c_changesetapply_invert&quot;&gt;支持的标志&lt;/a&gt;的组合作为第9个参数来进行修改。</target>
        </trans-unit>
        <trans-unit id="3b226ef505264d45ed6c9760d30054930a97eb46" translate="yes" xml:space="preserve">
          <source>The behavior of sqlite3changeset_start_v2() and its streaming equivalent may be modified by passing a combination of &lt;a href=&quot;#SQLITE_CHANGESETSTART_INVERT&quot;&gt;supported flags&lt;/a&gt; as the 4th parameter.</source>
          <target state="translated">sqlite3changeset_start_v2（）的行为及其流等效项可以通过将&lt;a href=&quot;#SQLITE_CHANGESETSTART_INVERT&quot;&gt;支持的标志&lt;/a&gt;的组合作为第四个参数进行修改。</target>
        </trans-unit>
        <trans-unit id="462fed9af71f32884c9943463dae76b5706b0104" translate="yes" xml:space="preserve">
          <source>The behavior of sqlite3changeset_start_v2() and its streaming equivalent may be modified by passing a combination of &lt;a href=&quot;c_changesetstart_invert&quot;&gt;supported flags&lt;/a&gt; as the 4th parameter.</source>
          <target state="translated">sqlite3changeset_start_v2（）的行为及其流等效项可以通过将&lt;a href=&quot;c_changesetstart_invert&quot;&gt;支持的标志&lt;/a&gt;的组合作为第四个参数进行修改。</target>
        </trans-unit>
        <trans-unit id="0cd600a43e57a68ed3c7e61e8926b28cfcf03236" translate="yes" xml:space="preserve">
          <source>The behaviour described above may be modified slightly by using the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted&lt;/a&gt; pragma to change the isolation level from serialized (the default), to read-uncommitted.</source>
          <target state="translated">通过使用&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted&lt;/a&gt;编译指示将隔离级别从序列化（默认）更改为read- committed，可以对上述行为进行一些修改。</target>
        </trans-unit>
        <trans-unit id="d91219df791273fdd065b20fbe3a1ddef8cd79ad" translate="yes" xml:space="preserve">
          <source>The behaviour of queries when a column-filter is specified both as part of the FTS query and by using a column as the LHS of a MATCH operator is slightly different. For a table with columns &quot;a&quot; and &quot;b&quot; and a query similar to:</source>
          <target state="translated">当列过滤器被指定为FTS查询的一部分和使用列作为MATCH操作符的LHS时,查询的行为略有不同。对于一个有 &quot;a &quot;和 &quot;b &quot;列的表和类似于以下的查询:</target>
        </trans-unit>
        <trans-unit id="1b74d0e5579c64699d464837588df4c3744c10fa" translate="yes" xml:space="preserve">
          <source>The best approach to make reliable backup copies of an SQLite database is to make use of the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt; that is part of the SQLite library. Failing that, it is safe to make a copy of an SQLite database file as long as there are no transactions in progress by any process. If the previous transaction failed, then it is important that any rollback journal (the &lt;code&gt;*-journal&lt;/code&gt; file) or write-ahead log (the &lt;code&gt;*-wal&lt;/code&gt; file) be copied together with the database file itself.</source>
          <target state="translated">制作SQLite数据库可靠备份副本的最佳方法是利用SQLite库中的&lt;a href=&quot;backup&quot;&gt;备份API&lt;/a&gt;。失败的话，只要没有任何进程在进行事务处理，就可以安全地复制SQLite数据库文件。如果前一个事务失败，那么将任何回滚日志（ &lt;code&gt;*-journal&lt;/code&gt; 文件）或预写日志（ &lt;code&gt;*-wal&lt;/code&gt; 文件）与数据库文件本身一起复制是很重要的。</target>
        </trans-unit>
        <trans-unit id="3e4c95bce459286798ea2a27bd9ecd8decb1253c" translate="yes" xml:space="preserve">
          <source>The best feature of SQL (in &lt;u&gt;all&lt;/u&gt; its implementations, not just SQLite) is that it is a</source>
          <target state="translated">SQL的最佳功能（在其&lt;u&gt;所有&lt;/u&gt;实现中，不仅是SQLite）是</target>
        </trans-unit>
        <trans-unit id="0acc0c4a6e57763a2a98687d8dd5dae3b2f9935e" translate="yes" xml:space="preserve">
          <source>The best way to understand how SQL database engines work is to think of SQL as a programming language, not as a &quot;query language&quot;. Each SQL statement is a separate program. Applications construct SQL program source files and send them to the database engine. The database engine compiles the SQL source code into executable form, runs that executable, then sends the result back to the application.</source>
          <target state="translated">理解SQL数据库引擎工作原理的最好方法是把SQL看作是一种编程语言,而不是一种 &quot;查询语言&quot;。每个SQL语句都是一个独立的程序。应用程序构造SQL程序源文件,并将其发送给数据库引擎。数据库引擎将SQL源码编译成可执行的形式,运行该可执行程序,然后将结果发回给应用程序。</target>
        </trans-unit>
        <trans-unit id="d79f775859b5387594a0b408b014948f69145bb6" translate="yes" xml:space="preserve">
          <source>The binary64 floating-point format uses 64 bits per number. Hence there are 1.845e+19 different possible floating point values. On the other hand there are infinitely many real numbers in the range of 1.7977e+308 and 4.9407e-324. It follows then that binary64 cannot possibly represent all possible real numbers within that range. Approximations are required.</source>
          <target state="translated">binary64浮点格式每个数字使用64位。因此,有1.845e+19种不同的可能的浮点值。另一方面,在1.7977e+308和4.9407e-324的范围内有无限多的实数。因此,二进制64不可能表示该范围内所有可能的实数。所以需要近似。</target>
        </trans-unit>
        <trans-unit id="dc958ef4fbaadd7154585494d4a1f0d8657cd355" translate="yes" xml:space="preserve">
          <source>The block above uses a shorthand form to create the foreign key constraint. Attaching a &quot;REFERENCES</source>
          <target state="translated">上面的代码块使用速记形式来创建外键约束。附加一个 &quot;REFERENCES</target>
        </trans-unit>
        <trans-unit id="be5a6e82c647cd58e78eb343df366b2a12164999" translate="yes" xml:space="preserve">
          <source>The blockid that corresponds to the leaf node with the largest blockid that belongs to this segment b-tree. Or zero if the entire segment b-tree fits on the root node.</source>
          <target state="translated">属于这个b段树的最大blockid的叶子节点所对应的blockid。如果整个段b树都在根节点上,则为零。</target>
        </trans-unit>
        <trans-unit id="8114ba8fdc8ebfe0e7461c055a0e2fd44faa8a98" translate="yes" xml:space="preserve">
          <source>The blockid that corresponds to the node with the smallest blockid that belongs to this segment b-tree. Or zero if the entire segment b-tree fits on the root node. If it exists, this node is always a leaf node.</source>
          <target state="translated">属于这个b段树的最小blockid的节点所对应的blockid。如果整个段b树适合在根节点上,则为零。如果存在,这个节点总是叶子节点。</target>
        </trans-unit>
        <trans-unit id="f9a2b7b8a28aace68acd7dc6116c16ed08d188be" translate="yes" xml:space="preserve">
          <source>The boolean identifiers TRUE and FALSE are usually just aliases for the integer values 1 and 0, respectively. However, if TRUE or FALSE occur on the right-hand side of an IS operator, then they form new unary postfix operators &quot;IS TRUE&quot; and &quot;IS FALSE&quot; which test the boolean value of the operand on the left.</source>
          <target state="translated">布尔标识符TRUE和FALSE通常分别只是整数值1和0的别称。然而,如果TRUE或FALSE出现在IS运算符的右侧,那么它们就会形成新的单调后缀运算符 &quot;IS TRUE &quot;和 &quot;IS FALSE&quot;,用来测试左侧操作数的布尔值。</target>
        </trans-unit>
        <trans-unit id="cab234605422320bfe969b5533e06293770750e7" translate="yes" xml:space="preserve">
          <source>The boundary between a file format and an application format is fuzzy. This article calls JPEG a file format, but for an image editor, JPEG might be considered the application format. Much depends on context. For this article, let us say that a file format stores a single object and an application format stores many different objects and their relationships to one another.</source>
          <target state="translated">文件格式和应用格式之间的界限是模糊的。本文称JPEG为文件格式,但对于图像编辑器来说,JPEG可能被认为是应用格式。这在很大程度上取决于上下文。就本文而言,让我们说文件格式存储的是一个单一的对象,而应用格式存储的是许多不同的对象以及它们之间的关系。</target>
        </trans-unit>
        <trans-unit id="47707c3fbd653507bcb6765a57019dc2e9df3e77" translate="yes" xml:space="preserve">
          <source>The boundary description &quot;0 PRECEDING&quot; always means the same thing as &quot;CURRENT ROW&quot;.</source>
          <target state="translated">边界描述 &quot;0 PRECEDING &quot;总是与 &quot;CURRENT ROW &quot;含义相同。</target>
        </trans-unit>
        <trans-unit id="65e8d52b8ac553953a11325088115a059c247d93" translate="yes" xml:space="preserve">
          <source>The build process makes extensive use of the &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;Tcl&lt;/a&gt; scripting language. You will need to have a copy of TCL installed in order for the make targets above to work. Easy-to-use installers can be obtained from &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;http://www.tcl-lang.org/&lt;/a&gt;. Many unix workstations have Tcl installed by default.</source>
          <target state="translated">构建过程广泛使用了&lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;Tcl&lt;/a&gt;脚本语言。您需要安装TCL的副本才能使上述生成目标起作用。可从&lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;http://www.tcl-lang.org/&lt;/a&gt;获得易于使用的安装程序。许多Unix工作站默认都安装了Tcl。</target>
        </trans-unit>
        <trans-unit id="7d4e60a19016fc83307d1ede2e1aa59927cbae39" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_corefunc#iif&quot;&gt;iif(x,y,z) SQL function&lt;/a&gt; is logically equivalent to &quot;CASE WHEN x THEN y ELSE z END&quot;. The iif() function is found in SQL Server and is included in SQLite for compatibility. Some developers prefer the iif() function because it is more concise.</source>
          <target state="translated">内置的&lt;a href=&quot;lang_corefunc#iif&quot;&gt;iif（x，y，z）SQL函数&lt;/a&gt;在逻辑上等效于&amp;ldquo; CASE WHEN x THEN y ELSE z END&amp;rdquo;。iif（）函数可在SQL Server中找到，并包含在SQLite中以实现兼容性。一些开发人员更喜欢iif（）函数，因为它更简洁。</target>
        </trans-unit>
        <trans-unit id="2c9c97359a7945f825df70e8e7d3bf03b435fc83" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; have been enhanced so that they can be used in &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, in &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, and in the WHERE clauses of &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;, provided that they do not use the 'now', 'localtime', or 'utc' keywords. &lt;a href=&quot;deterministic#dtexception&quot;&gt;More information&lt;/a&gt;.</source>
          <target state="translated">内置的&lt;a href=&quot;lang_datefunc&quot;&gt;日期和时间函数&lt;/a&gt;已得到增强，因此它们可以在&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK约束&lt;/a&gt;，&lt;a href=&quot;expridx&quot;&gt;表达式索引&lt;/a&gt;以及&lt;a href=&quot;partialindex&quot;&gt;部分索引&lt;/a&gt;的WHERE子句中使用，前提是它们不使用&amp;ldquo; now&amp;rdquo;，&amp;ldquo; localtime&amp;rdquo;，或&amp;ldquo; utc&amp;rdquo;关键字。&lt;a href=&quot;deterministic#dtexception&quot;&gt;更多信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8a2f201a6d744f00508ed72b40ed46b5c83f60f1" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; of SQLite are a special case. These functions are usually considered deterministic. However, if these functions use the string &quot;now&quot; as the date, or if they use the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; or the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;utc modifier&lt;/a&gt;, then they are considered non-deterministic. Because the function inputs are not necessarily known until run-time, the date/time functions will throw an exception if they encounter any of the non-deterministic features in a context where only deterministic functions are allowed.</source>
          <target state="translated">SQLite的内置&lt;a href=&quot;lang_datefunc&quot;&gt;日期和时间功能&lt;/a&gt;是一种特殊情况。这些功能通常被认为是确定性的。但是，如果这些函数使用字符串&amp;ldquo; now&amp;rdquo;作为日期，或者它们使用&lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime修饰符&lt;/a&gt;或&lt;a href=&quot;lang_datefunc#localtime&quot;&gt;utc修饰符&lt;/a&gt;，则将它们视为不确定的。因为在运行时函数输入不一定是已知的，所以如果在仅允许确定性功能的情况下遇到日期中的任何不确定性功能，则日期/时间函数将引发异常。</target>
        </trans-unit>
        <trans-unit id="96663fb71968ae34b1131b3cb53ad7ba03319209" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; of SQLite are a special case. These functions are usually considered deterministic. However, if these functions use the string &quot;now&quot; as the date, or if they use the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; or the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;utc modifier&lt;/a&gt;, then they are considered non-deterministic. Because the function inputs are not necessarily known until run-time, the date/time functions will throw an exception if they encounter any of the non-deterministic features in a context where only deterministic functions are allows.</source>
          <target state="translated">SQLite 的内置&lt;a href=&quot;lang_datefunc&quot;&gt;日期和时间功能&lt;/a&gt;是一种特殊情况。这些功能通常被认为是确定性的。但是，如果这些函数使用字符串&amp;ldquo;现在&amp;rdquo;作为日期，或者它们使用&lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime修饰符&lt;/a&gt;或&lt;a href=&quot;lang_datefunc#localtime&quot;&gt;utc修饰符&lt;/a&gt;，则将它们视为不确定的。因为函数输入直到运行时才知道，所以如果日期/时间函数在仅允许确定性函数的情况下遇到任何不确定性特征，则它们将引发异常。</target>
        </trans-unit>
        <trans-unit id="adf744ca87e6c1a5f3b9a68b24961edea60809eb" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; of SQLite understand date/times in all of the formats above, and can freely change between them. Which format you use, is entirely up to your application.</source>
          <target state="translated">SQLite 的内置&lt;a href=&quot;lang_datefunc&quot;&gt;日期和时间功能&lt;/a&gt;可理解上述所有格式的日期/时间，并可在它们之间自由更改。使用哪种格式完全取决于您的应用程序。</target>
        </trans-unit>
        <trans-unit id="8a5b38222ac4fb96f9a2b189215735dd804f8b2d" translate="yes" xml:space="preserve">
          <source>The built-in BINARY collation compares strings byte by byte using the memcmp() function from the standard C library.</source>
          <target state="translated">内置的BINARY整理使用标准C库中的memcmp()函数对字符串进行逐个字节的比较。</target>
        </trans-unit>
        <trans-unit id="1b9d8615812e1b5dddaadf330db3704ed6104526" translate="yes" xml:space="preserve">
          <source>The built-in SQLite has compile-time options such as SQLITE_PRINTF_PRECISION_LIMIT that provide defense against denial-of-service attacks for application that expose the printf() functionality to untrusted users.</source>
          <target state="translated">内置的SQLite有一些编译时的选项,如SQLITE_PRINTF_PRECISION_LIMIT,这些选项为将printf()功能暴露给不受信任的用户的应用程序提供了拒绝服务攻击的防御。</target>
        </trans-unit>
        <trans-unit id="55ca16581ef8177476edac12f1cd562f40820547" translate="yes" xml:space="preserve">
          <source>The built-in Wagner edit-distance function with fixed weights can be replaced by the &lt;a href=&quot;spellfix1#editdist3&quot;&gt;editdist3()&lt;/a&gt; edit-distance function with application-defined weights and support for unicode, by specifying the &quot;edit_cost_table=</source>
          <target state="translated">与固定权内置瓦格纳编辑距离函数可以通过更换&lt;a href=&quot;spellfix1#editdist3&quot;&gt;editdist3（）&lt;/a&gt;与应用程序定义的权重和支持Unicode编辑距离函数，通过指定&amp;ldquo;edit_cost_table =</target>
        </trans-unit>
        <trans-unit id="919d1860b9bd16d4532d25388f1ffc8375baa209" translate="yes" xml:space="preserve">
          <source>The built-in auxiliary function bm25() returns a real value indicating how well the current row matches the full-text query. The better the match, the numerically smaller the value returned. A query such as the following may be used to return matches in order from best to worst match:</source>
          <target state="translated">内置的辅助函数bm25()返回一个实值,表示当前行与全文查询的匹配程度。匹配度越高,返回的数值越小。像下面这样的查询可以用来按照从最好的匹配度到最差的匹配度的顺序来返回匹配度。</target>
        </trans-unit>
        <trans-unit id="89afdc49975b5af95582dcbca838ad26684b8aa6" translate="yes" xml:space="preserve">
          <source>The built-in auxiliary functions provided as part of FTS5 are described in the following section. Applications may also implement &lt;a href=&quot;fts5#custom_auxiliary_functions&quot;&gt;custom auxiliary functions in C&lt;/a&gt;.</source>
          <target state="translated">下一部分将介绍作为FTS5的一部分提供的内置辅助功能。应用程序还可以&lt;a href=&quot;fts5#custom_auxiliary_functions&quot;&gt;在C中&lt;/a&gt;实现自定义辅助功能。</target>
        </trans-unit>
        <trans-unit id="9249ce5cc7f5a31c9f40d1d2aedadc1d6c797929" translate="yes" xml:space="preserve">
          <source>The built-in functions used to implement LIKE and GLOB must not have been overloaded using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; API.</source>
          <target state="translated">不能使用&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt; API 重载用于实现LIKE和GLOB的内置函数。</target>
        </trans-unit>
        <trans-unit id="49a23aa1a5c2e20f2c3c4ac966e9783cdfed04b2" translate="yes" xml:space="preserve">
          <source>The built-in memory allocators in SQLite also provide the following additional interfaces:</source>
          <target state="translated">SQLite中内置的内存分配器还提供了以下附加接口。</target>
        </trans-unit>
        <trans-unit id="4fa083c0cbf6940d57170ea9aa2f51d37713e7a7" translate="yes" xml:space="preserve">
          <source>The built-in min() and max() functions now honor the difference between NUMERIC and TEXT datatypes. Formerly, min() and max() always assumed their arguments were of type NUMERIC.</source>
          <target state="translated">内置的min()和max()函数现在尊重NUMERIC和TEXT数据类型之间的差异。以前,min()和max()总是假定它们的参数是NUMERIC类型。</target>
        </trans-unit>
        <trans-unit id="09829581870ec4ebe1c207006b15fd18f63554a5" translate="yes" xml:space="preserve">
          <source>The built-in printf() implementation does not handle posix positional referencing modifiers that allow the order of arguments to printf() to be different from the order of the %-substitutions. In the built-in printf(), the order of the arguments must exactly match the order of the %-substitutions.</source>
          <target state="translated">内置的printf()实现不能处理posix位置引用修饰符,这些修饰符允许printf()的参数顺序与%-substitutions的顺序不同。在内置printf()中,参数的顺序必须与%-substitutions的顺序完全一致。</target>
        </trans-unit>
        <trans-unit id="e86ab3d5db7f0615044de9985403c55275e95eaf" translate="yes" xml:space="preserve">
          <source>The built-in printf() implementation uses extra code space (about 7800 bytes on GCC 5.4 with -Os).</source>
          <target state="translated">内置的printf()的实现使用了额外的代码空间(在GCC 5.4和-Os下约7800字节)。</target>
        </trans-unit>
        <trans-unit id="68470e8ed26cf7ace0d2e09f00b9eab48903fc0b" translate="yes" xml:space="preserve">
          <source>The built-in tokenizers and auxiliary functions described in this document are all implemented using the publicly available API described below.</source>
          <target state="translated">本文档中描述的内置标记器和辅助功能都是通过下面描述的公开API实现的。</target>
        </trans-unit>
        <trans-unit id="9fc396222878f092f3ee1e16fde31353451d89d0" translate="yes" xml:space="preserve">
          <source>The busy callback should not take any actions which modify the database connection that invoked the busy handler. In other words, the busy handler is not reentrant. Any such actions result in undefined behavior.</source>
          <target state="translated">忙回调不应该采取任何修改调用忙处理程序的数据库连接的操作。换句话说,忙处理程序不是重入式的。任何这样的操作都会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="f4f573b1a486bc41f01b46a6d80d9ecec47641b0" translate="yes" xml:space="preserve">
          <source>The byte offset of the matching term within the column.</source>
          <target state="translated">列内匹配项的字节偏移量。</target>
        </trans-unit>
        <trans-unit id="05f015bc1e7204efce9fc81ea976f5bbb81740a9" translate="yes" xml:space="preserve">
          <source>The byte-order of UTF16 input text is determined by the byte-order mark (BOM, U+FEFF) found in first character, which is removed, or in the absence of a BOM the byte order is the native byte order of the host machine for sqlite3_bind_text16() or the byte order specified in the 6th parameter for sqlite3_bind_text64(). If UTF16 input text contains invalid unicode characters, then SQLite might change those invalid characters into the unicode replacement character: U+FFFD.</source>
          <target state="translated">UTF16输入文本的字节顺序由第一个字符中发现的字节顺序标记(BOM,U+FEFF)决定,该标记会被删除,如果没有BOM,则字节顺序是主机的本机字节顺序为sqlite3_bind_text16(),或者是sqlite3_bind_text64()的第6个参数中指定的字节顺序。如果UTF16输入文本包含无效的unicode字符,那么SQLite可能会将这些无效字符改为unicode替换字符。U+FFFD.</target>
        </trans-unit>
        <trans-unit id="2f568127fbaa97f70cb703194692bb7bd81d899e" translate="yes" xml:space="preserve">
          <source>The bytecode and tables_used tables are only available if SQLite has been compiled with the &lt;a href=&quot;compile#enable_bytecode_vtab&quot;&gt;-DSQLITE_ENABLE_BYTECODE_VTAB&lt;/a&gt; compile-time option. The &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; has been compiled that way, and so you can use the standard &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; as a test platform to experiement.</source>
          <target state="translated">仅当使用&lt;a href=&quot;compile#enable_bytecode_vtab&quot;&gt;-DSQLITE_ENABLE_BYTECODE_VTAB&lt;/a&gt;编译时选项编译SQLite时，字节码表和tables_used表才可用。该&lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;已编制这种方式，所以你可以使用标准的&lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;作为测试平台，以实验性功能。</target>
        </trans-unit>
        <trans-unit id="dbb76aa2fa15c5bd4f4468b266b4d77ab34c0a75" translate="yes" xml:space="preserve">
          <source>The bytecode engine begins execution on instruction number 0. Execution continues until a &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; instruction is seen, or until the program counter becomes greater than the address of last instruction, or until there is an error. When the bytecode engine halts, all memory that it allocated is released and all database cursors it may have had open are closed. If the execution stopped due to an error, any pending transactions are terminated and changes made to the database are rolled back.</source>
          <target state="translated">字节码引擎从0号指令开始执行。执行将继续直到看到&lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt;指令，或者直到程序计数器大于最后一条指令的地址为止，或者直到出现错误为止。当字节码引擎暂停时，将释放它分配的所有内存，并关闭可能已打开的所有数据库游标。如果执行由于错误而停止，则所有挂起的事务都将终止，并且对数据库所做的更改将回滚。</target>
        </trans-unit>
        <trans-unit id="9a6398c9082248055b1fbc77ff5022201f3b1441" translate="yes" xml:space="preserve">
          <source>The bytecode engine has no stack on which to store the return address of a subroutine. Return addresses must be stored in registers. Hence, bytecode subroutines are not reentrant.</source>
          <target state="translated">字节码引擎没有栈来存储子程序的返回地址。返回地址必须存储在寄存器中。因此,字节码子程序是不能重入的。</target>
        </trans-unit>
        <trans-unit id="28f086fcda9ebdf902655d03a38811e78fc96fb9" translate="yes" xml:space="preserve">
          <source>The bytecode engine is &lt;u&gt;not&lt;/u&gt; an API of SQLite. Details about the bytecode engine change from one release of SQLite to the next. Applications that use SQLite should not depend on any of the details found in this document.</source>
          <target state="translated">字节码引擎&lt;u&gt;不是&lt;/u&gt; SQLite的API。关于字节码引擎的详细信息从一个SQLite版本更改为另一个版本。使用SQLite的应用程序不应依赖于本文档中的任何详细信息。</target>
        </trans-unit>
        <trans-unit id="e552468adf820f25d29531e1e14d99733690b86b" translate="yes" xml:space="preserve">
          <source>The bytecode generated by the code generator is called a &quot;&lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt;&quot;. Translating SQL source text into a prepared statement is analogous to converting a C++ program into machine code by invoking gcc or clang. Human-readable source text (SQL or C++) goes in, and a machine readable executable (bytecode or machine code) comes out.</source>
          <target state="translated">由代码生成器生成的字节码称为&amp;ldquo;&lt;a href=&quot;c3ref/stmt&quot;&gt;准备语句&lt;/a&gt;&amp;rdquo;。将SQL源文本转换为准备好的语句类似于通过调用gcc或clang将C ++程序转换为机器代码。引入人类可读的源文本（SQL或C ++），然后出现机器可读的可执行文件（字节码或机器代码）。</target>
        </trans-unit>
        <trans-unit id="8f39ef66488b6211208c988daf5ffcab23760705" translate="yes" xml:space="preserve">
          <source>The bytecode virtual machine is the heart of SQLite. Programmers who want to understand how SQLite operates internally must be familiar with the bytecode engine.</source>
          <target state="translated">字节码虚拟机是SQLite的核心。想要了解SQLite内部运行方式的程序员必须熟悉字节码引擎。</target>
        </trans-unit>
        <trans-unit id="efeaf3fe17bdefca5b34d3df41725c68d1db2de0" translate="yes" xml:space="preserve">
          <source>The cFrom and cTo columns show edit transformation strings. Either or both columns may contain more than one character. Or either column (but not both) may hold an empty string. When cFrom is empty, that is the cost of inserting cTo. When cTo is empty, that is the cost of deleting cFrom.</source>
          <target state="translated">cFrom和cTo列显示编辑转换字符串。其中一列或两列可以包含一个以上的字符。或者其中一列(但不是两列)可以包含一个空字符串。当cFrom为空时,是插入cTo的成本。当cTo为空时,是删除cFrom的成本。</target>
        </trans-unit>
        <trans-unit id="334e7f3d3c0f1d00666221b0f79b06086771f2a0" translate="yes" xml:space="preserve">
          <source>The cache must not perform any reference counting. A single call to xUnpin() unpins the page regardless of the number of prior calls to xFetch().</source>
          <target state="translated">缓存必须不执行任何引用计数。单次调用xUnpin()就可以解除对页面的锁定,而不考虑之前调用xFetch()的次数。</target>
        </trans-unit>
        <trans-unit id="ba91e47edf5c7de46f6d683125d4647799118c05" translate="yes" xml:space="preserve">
          <source>The cache query parameter determines if the new database is opened using &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; or with a private cache.</source>
          <target state="translated">缓存查询参数确定是使用&lt;a href=&quot;sharedcache&quot;&gt;共享缓存模式&lt;/a&gt;还是使用专用缓存打开新数据库。</target>
        </trans-unit>
        <trans-unit id="3b1d92f7c11891a9dfcf8a02bdb8e1d1b67e45d9" translate="yes" xml:space="preserve">
          <source>The cache sharing mode set by this interface effects all subsequent calls to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;. Existing database connections continue to use the sharing mode that was in effect at the time they were opened.</source>
          <target state="translated">通过此接口设置的缓存共享模式会影响对&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16（）的&lt;/a&gt;所有后续调用。现有的数据库连接继续使用在打开它们时生效的共享模式。</target>
        </trans-unit>
        <trans-unit id="6c24d3d1b52233a8d1d33d1521f0d40a35115941" translate="yes" xml:space="preserve">
          <source>The cache sharing mode set by this interface effects all subsequent calls to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;. Existing database connections continue use the sharing mode that was in effect at the time they were opened.</source>
          <target state="translated">通过此接口设置的缓存共享模式会影响所有随后对&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16（）的&lt;/a&gt;调用。现有的数据库连接继续使用在打开它们时生效的共享模式。</target>
        </trans-unit>
        <trans-unit id="84568a531cbb8fea84a45d0e913a15a98ad6bdd3" translate="yes" xml:space="preserve">
          <source>The cache sharing mode set by this interface effects all subsequent calls to &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;. Existing database connections continue to use the sharing mode that was in effect at the time they were opened.</source>
          <target state="translated">通过此接口设置的缓存共享模式会影响对&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;和&lt;a href=&quot;open&quot;&gt;sqlite3_open16（）的&lt;/a&gt;所有后续调用。现有的数据库连接继续使用在打开它们时生效的共享模式。</target>
        </trans-unit>
        <trans-unit id="f37b504a453065b9fe4d5c4bf29c4836a5d7646e" translate="yes" xml:space="preserve">
          <source>The cache sharing mode set by this interface effects all subsequent calls to &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;. Existing database connections continue use the sharing mode that was in effect at the time they were opened.</source>
          <target state="translated">通过此接口设置的缓存共享模式会影响所有随后对&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;和&lt;a href=&quot;open&quot;&gt;sqlite3_open16（）的&lt;/a&gt;调用。现有的数据库连接继续使用在打开它们时生效的共享模式。</target>
        </trans-unit>
        <trans-unit id="e474b4529162f0cc96b1a00a4049ab5a12dcf32d" translate="yes" xml:space="preserve">
          <source>The cache-flush method &lt;a href=&quot;c3ref/finalize&quot;&gt;finalizes&lt;/a&gt; all prepared statements currently in the cache.</source>
          <target state="translated">cache-flush方法&lt;a href=&quot;c3ref/finalize&quot;&gt;最终确定&lt;/a&gt;当前在缓存中的所有准备好的语句。</target>
        </trans-unit>
        <trans-unit id="9d8d3b22c77f42c07d50a96703e45047516a539f" translate="yes" xml:space="preserve">
          <source>The cache_spill pragma enables or disables the ability of the pager to spill dirty cache pages to the database file in the middle of a transaction. Cache_spill is enabled by default and most applications should leave it that way as cache spilling is usually advantageous. However, a cache spill has the side-effect of acquiring an &lt;a href=&quot;lockingv3#excl_lock&quot;&gt;EXCLUSIVE lock&lt;/a&gt; on the database file. Hence, some applications that have large long-running transactions may want to disable cache spilling in order to prevent the application from acquiring an exclusive lock on the database until the moment that the transaction &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;s.</source>
          <target state="translated">cache_spill编译指示启用或禁用页面调度程序在事务中间将脏的缓存页面溢出到数据库文件的功能。默认情况下，Cache_spill是启用的，并且大多数应用程序都应该采用这种方式，因为缓存溢出通常是有利的。但是，缓存溢出具有获取数据库文件上的&lt;a href=&quot;lockingv3#excl_lock&quot;&gt;EXCLUSIVE锁&lt;/a&gt;的副作用。因此，某些具有大量长时间运行的事务的应用程序可能希望禁用缓存溢出，以防止应用程序在事务&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;之前获取数据库的排他锁。</target>
        </trans-unit>
        <trans-unit id="9721a1202302bdb3675cb33fdaf401b47649ef3f" translate="yes" xml:space="preserve">
          <source>The callback function is used to receive the results of a query. A prototype for the callback function is as follows:</source>
          <target state="translated">回调函数用于接收查询的结果。回调函数的原型如下。</target>
        </trans-unit>
        <trans-unit id="dce299de07269b78871b3c034bf37ba0c0271573" translate="yes" xml:space="preserve">
          <source>The callback function registered by sqlite3_profile() is invoked as each SQL statement finishes. The profile callback contains the original statement text and an estimate of wall-clock time of how long that statement took to run. The profile callback time is in units of nanoseconds, however the current implementation is only capable of millisecond resolution so the six least significant digits in the time are meaningless. Future versions of SQLite might provide greater resolution on the profiler callback. Invoking either &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; will cancel the profile callback.</source>
          <target state="translated">在每个SQL语句完成时，调用sqlite3_profile（）注册的回调函数。配置文件回调包含原始语句文本以及该语句运行多长时间的挂钟时间估计。配置文件回调时间以纳秒为单位，但是当前的实现仅能够实现毫秒级的分辨率，因此时间中的六个最低有效数字是没有意义的。 SQLite的未来版本可能会在探查器回调中提供更高的分辨率。调用&lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;将取消配置文件回调。</target>
        </trans-unit>
        <trans-unit id="a6f29aa702b9f0b66493dfb5e14c2df5fa8051eb" translate="yes" xml:space="preserve">
          <source>The callback function registered by sqlite3_profile() is invoked as each SQL statement finishes. The profile callback contains the original statement text and an estimate of wall-clock time of how long that statement took to run. The profile callback time is in units of nanoseconds, however the current implementation is only capable of millisecond resolution so the six least significant digits in the time are meaningless. Future versions of SQLite might provide greater resolution on the profiler callback. Invoking either &lt;a href=&quot;profile&quot;&gt;sqlite3_trace()&lt;/a&gt; or &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; will cancel the profile callback.</source>
          <target state="translated">在每个SQL语句完成时，调用sqlite3_profile（）注册的回调函数。配置文件回调包含原始语句文本以及该语句运行多长时间的挂钟时间估计。配置文件回调时间以纳秒为单位，但是当前的实现仅能够实现毫秒级的分辨率，因此时间中的六个最低有效数字是没有意义的。 SQLite的未来版本可能会在探查器回调中提供更高的分辨率。调用&lt;a href=&quot;profile&quot;&gt;sqlite3_trace（）&lt;/a&gt;或&lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;将取消配置文件回调。</target>
        </trans-unit>
        <trans-unit id="6cc8b0e0c1561082e8c35dc0acaf0338a474ad77" translate="yes" xml:space="preserve">
          <source>The callback function registered by sqlite3_trace() is invoked at various times when an SQL statement is being run by &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;. The sqlite3_trace() callback is invoked with a UTF-8 rendering of the SQL statement text as the statement first begins executing. Additional sqlite3_trace() callbacks might occur as each triggered subprogram is entered. The callbacks for triggers contain a UTF-8 SQL comment that identifies the trigger.</source>
          <target state="translated">（）由sqlite3_trace注册的回调函数在不同的时间被调用时的SQL语句正在运行的&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（） &lt;/a&gt;。在语句首次开始执行时，使用SQL语句文本的UTF-8渲染调用sqlite3_trace（）回调。输入每个触发的子程序时，可能会发生其他sqlite3_trace（）回调。触发器的回调包含用于标识触发器的UTF-8 SQL注释。</target>
        </trans-unit>
        <trans-unit id="ce29a09fb52c337eecabbd8bc599ef45377bf00d" translate="yes" xml:space="preserve">
          <source>The callback function registered by sqlite3_trace() is invoked at various times when an SQL statement is being run by &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;. The sqlite3_trace() callback is invoked with a UTF-8 rendering of the SQL statement text as the statement first begins executing. Additional sqlite3_trace() callbacks might occur as each triggered subprogram is entered. The callbacks for triggers contain a UTF-8 SQL comment that identifies the trigger.</source>
          <target state="translated">（）由sqlite3_trace注册的回调函数在不同的时间被调用时的SQL语句正在运行的&lt;a href=&quot;step&quot;&gt;sqlite3_step（） &lt;/a&gt;。在语句首次开始执行时，使用SQL语句文本的UTF-8渲染调用sqlite3_trace（）回调。输入每个触发的子程序时，可能会发生其他sqlite3_trace（）回调。触发器的回调包含用于标识触发器的UTF-8 SQL注释。</target>
        </trans-unit>
        <trans-unit id="b2f2fd31e08bf7a8ddd0b8f8f2559aa236b781e8" translate="yes" xml:space="preserve">
          <source>The callback function should normally return 0. If the callback function returns non-zero, the query is immediately aborted and &lt;b&gt;sqlite_exec&lt;/b&gt; will return SQLITE_ABORT.</source>
          <target state="translated">回调函数通常应返回0。如果回调函数返回非零，则查询将立即中止，而&lt;b&gt;sqlite_exec&lt;/b&gt;将返回SQLITE_ABORT。</target>
        </trans-unit>
        <trans-unit id="2394e983e60bde9a89a8173fd3ab1cfc913e1dc5" translate="yes" xml:space="preserve">
          <source>The callback function should normally return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;. If an error code is returned, that error will propagate back up through the SQLite code base to cause the statement that provoked the callback to report an error, though the commit will have still occurred. If the callback returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if it returns a value that does not correspond to any valid SQLite error code, the results are undefined.</source>
          <target state="translated">回调函数通常应返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;。如果返回了错误代码，则该错误将通过SQLite代码库传播回来，从而使引发回调的语句报告错误，尽管该提交仍会发生。如果回调返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;或&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;，或者返回的值与任何有效的SQLite错误代码都不对应，则结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="e115553094195c6d671fc1803e4945ba335eedc5" translate="yes" xml:space="preserve">
          <source>The callback function should normally return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;. If an error code is returned, that error will propagate back up through the SQLite code base to cause the statement that provoked the callback to report an error, though the commit will have still occurred. If the callback returns &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if it returns a value that does not correspond to any valid SQLite error code, the results are undefined.</source>
          <target state="translated">回调函数通常应返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;。如果返回了错误代码，则该错误将通过SQLite代码库传播回来，从而使引发回调的语句报告错误，尽管该提交仍会发生。如果回调返回&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;或&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;，或者返回的值与任何有效的SQLite错误代码都不对应，则结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="dd2c627a789615e3efe180bdedfefe32d9d62d76" translate="yes" xml:space="preserve">
          <source>The callback function should register the desired collation using &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation_v2()&lt;/a&gt;.</source>
          <target state="translated">回调函数应使用&lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collat​​ion（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collat​​ion16（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collat​​ion_v2（）&lt;/a&gt;注册所需的排序规则。</target>
        </trans-unit>
        <trans-unit id="c17f517957de57a117a3b4627294584d44e59419" translate="yes" xml:space="preserve">
          <source>The callback function should register the desired collation using &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt;, &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation16()&lt;/a&gt;, or &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation_v2()&lt;/a&gt;.</source>
          <target state="translated">回调函数应使用&lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collat​​ion（）&lt;/a&gt;，&lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collat​​ion16（）&lt;/a&gt;或&lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collat​​ion_v2（）&lt;/a&gt;注册所需的排序规则。</target>
        </trans-unit>
        <trans-unit id="fefabcb34707d427a36b9901ef209a203d46bf9f" translate="yes" xml:space="preserve">
          <source>The callback is invoked by SQLite after the commit has taken place and the associated write-lock on the database released, so the implementation may read, write or &lt;a href=&quot;../wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; the database as required.</source>
          <target state="translated">提交完成并释放对数据库的关联写锁定后，SQLite会调用回调，因此，实现可以根据需要读取，写入或&lt;a href=&quot;../wal#ckpt&quot;&gt;检查&lt;/a&gt;数据库。</target>
        </trans-unit>
        <trans-unit id="f6c4a8d646e0cbd66ca6c45574aae0dd0351286a" translate="yes" xml:space="preserve">
          <source>The callback is invoked by SQLite after the commit has taken place and the associated write-lock on the database released, so the implementation may read, write or &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; the database as required.</source>
          <target state="translated">提交完成并释放对数据库的关联写锁定后，SQLite会调用回调，因此，实现可以根据需要读取，写入或&lt;a href=&quot;wal#ckpt&quot;&gt;检查&lt;/a&gt;数据库。</target>
        </trans-unit>
        <trans-unit id="facad5f03164aa5e049b3e0fcdccc7d1ce7b086d" translate="yes" xml:space="preserve">
          <source>The callback is invoked every N virtual machine operations, where N is supplied as the second argument to &lt;b&gt;sqlite_progress_handler()&lt;/b&gt;. The third and fourth arguments to &lt;b&gt;sqlite_progress_handler()&lt;/b&gt; are a pointer to the routine to be invoked and a void pointer to be passed as the first argument to it.</source>
          <target state="translated">每N个虚拟机操作都会调用一次回调，其中N作为第二个参数提供给&lt;b&gt;sqlite_progress_handler（）&lt;/b&gt;。&lt;b&gt;sqlite_progress_handler（）&lt;/b&gt;的第三个和第四个参数是指向要调用的例程的指针，并且是作为第一个参数传递给它的void指针。</target>
        </trans-unit>
        <trans-unit id="70ae791199d0c0d2e25d25668478f3c97d6fcbcf" translate="yes" xml:space="preserve">
          <source>The callback registered by this function replaces any existing callback registered using &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt;. Likewise, registering a callback using &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; disables the automatic checkpoint mechanism configured by this function.</source>
          <target state="translated">此函数注册的回调将替换使用&lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;注册的任何现有回调。同样，使用&lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;注册回调将禁用此功能配置的自动检查点机制。</target>
        </trans-unit>
        <trans-unit id="95427739ef742c846008bdf4e9ade466f5ff0b68" translate="yes" xml:space="preserve">
          <source>The callback registered by this function replaces any existing callback registered using &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt;. Likewise, registering a callback using &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; disables the automatic checkpoint mechanism configured by this function.</source>
          <target state="translated">此函数注册的回调将替换使用&lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;注册的任何现有回调。同样，使用&lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;注册回调将禁用此功能配置的自动检查点机制。</target>
        </trans-unit>
        <trans-unit id="af79ec8f0bec910d80bc717aab639238d9ea73fe" translate="yes" xml:space="preserve">
          <source>The caller could distinguish between this special &quot;DROP TABLE|INDEX&quot; case and other cases by using &lt;a href=&quot;rescode#extrc&quot;&gt;extended error codes&lt;/a&gt;. When it is appropriate to call &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt;, the extended error code is SQLITE_LOCKED_SHAREDCACHE. Otherwise, in the &quot;DROP TABLE|INDEX&quot; case, it is just plain SQLITE_LOCKED. Another solution might be to limit the number of times that any single query could be reattempted (to say 100). Although this might be less efficient than one might wish, the situation in question is not likely to occur often.</source>
          <target state="translated">调用者可以通过使用&lt;a href=&quot;rescode#extrc&quot;&gt;扩展错误代码&lt;/a&gt;来区分这种特殊的&amp;ldquo; DROP TABLE | INDEX&amp;rdquo;情况和其他情况。当适合调用&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）时&lt;/a&gt;，扩展的错误代码为SQLITE_LOCKED_SHAREDCACHE。否则，在&amp;ldquo; DROP TABLE | INDEX&amp;rdquo;情况下，它只是普通的SQLITE_LOCKED。另一个解决方案可能是限制任何单个查询可以重新尝试的次数（例如100）。尽管这可能不如人们期望的那样有效，但是这种情况不太可能经常发生。</target>
        </trans-unit>
        <trans-unit id="b3f82dd9e0519120922fe3d796ee7df0852a43b3" translate="yes" xml:space="preserve">
          <source>The canonical FTS5 source code consists of a series of *.c and other files in the &quot;ext/fts5&quot; directory of the SQLite source tree. A build process reduces this to just two files - &quot;fts5.c&quot; and &quot;fts5.h&quot; - which may be used to build an SQLite loadable extension.</source>
          <target state="translated">规范的FTS5源码由一系列*.c和其他文件组成,在SQLite源码树的 &quot;ext/fts5 &quot;目录下。构建过程将其简化为两个文件--&quot;fts5.c &quot;和 &quot;fts5.h&quot;-这两个文件可以用来构建一个SQLite可加载扩展。</target>
        </trans-unit>
        <trans-unit id="821b27603ed5a2bcfa634bb0e0d6241eee07c748" translate="yes" xml:space="preserve">
          <source>The carray() function can be used in the FROM clause of a query. For example, to query two entries from the OBJ table using rowids taken from a C-language array at address $PTR.</source>
          <target state="translated">carray()函数可以在查询的FROM子句中使用,例如,使用地址为$PTR的C语言数组中的rowids从OBJ表中查询两个条目。例如,使用地址为$PTR的C语言数组中的rowids从OBJ表中查询两个条目。</target>
        </trans-unit>
        <trans-unit id="44fb31ec0ece772e4bff94846b749fc144432db5" translate="yes" xml:space="preserve">
          <source>The carray() function is not compiled into SQLite by default. It is available as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; in the &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/carray.c&quot;&gt;ext/misc/carray.c&lt;/a&gt; source file.</source>
          <target state="translated">默认情况下，carray（）函数未编译为SQLite。它可以作为&lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/carray.c&quot;&gt;ext / misc / carray.c&lt;/a&gt;源文件中的&lt;a href=&quot;loadext&quot;&gt;可加载扩展名&lt;/a&gt;使用。</target>
        </trans-unit>
        <trans-unit id="6e63d412e430ced0198abd5a08f3353e7c8e954f" translate="yes" xml:space="preserve">
          <source>The carray() function is not compiled into SQLite by default. It is available as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; in the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/carray.c&quot;&gt;ext/misc/carray.c&lt;/a&gt; source file.</source>
          <target state="translated">默认情况下，carray（）函数未编译到SQLite中。它可以作为&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/carray.c&quot;&gt;ext / misc / carray.c&lt;/a&gt;源文件中的&lt;a href=&quot;loadext&quot;&gt;可加载扩展名&lt;/a&gt;使用。</target>
        </trans-unit>
        <trans-unit id="c196efe3bbb9fab3e53eef891a9efbbc4c9d5551" translate="yes" xml:space="preserve">
          <source>The carray() function takes one, two, or three arguments.</source>
          <target state="translated">carray()函数接受一个、两个或三个参数。</target>
        </trans-unit>
        <trans-unit id="435764c5d08e172eacd91d4b4315996e3f48003b" translate="yes" xml:space="preserve">
          <source>The carray() function takes two or three arguments. The first argument is a pointer to an array. Since pointer values cannot be specified directly in SQL, the first argument must be a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that is bound to a pointer value using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; interface using a pointer-type of &quot;carray&quot;. The second argument is the number of elements in the array. The optional third argument is a string that determines the datatype of the elements in the C-language array. Allowed values for the third argument are:</source>
          <target state="translated">carray（）函数采用两个或三个参数。第一个参数是指向数组的指针。由于指针值不能直接在SQL中指定，第一个参数必须是一个&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;绑定到使用该指针值&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;接口使用指针型&amp;ldquo;CARRAY&amp;rdquo;的。第二个参数是数组中元素的数量。可选的第三个参数是一个字符串，用于确定C语言数组中元素的数据类型。第三个参数的允许值为：</target>
        </trans-unit>
        <trans-unit id="a7781753a10aa9d55edfb4fde889d70df4714233" translate="yes" xml:space="preserve">
          <source>The carray() function was first added to SQLite in version 3.14 (2016-08-08). The sqlite3_carray_bind() interface and the single-argument variant of carray() was added in SQLite version 3.34.0 (2020-12-01).</source>
          <target state="translated">carray()函数是在3.14版本(2016-08-08)首次添加到SQLite中。sqlite3_carray_bind()接口和carray()的单参数变体在SQLite 3.34.0版本(2020-12-01)中被添加。</target>
        </trans-unit>
        <trans-unit id="41b5d7c612b8b2127750760016443da99495e2ab" translate="yes" xml:space="preserve">
          <source>The casual reader is not expected to understand or remember any part of the list above. The point of this list is to demonstrate that the decision of whether or not to flatten a query is complex.</source>
          <target state="translated">普通读者不需要理解或记住上述列表的任何部分。这个清单的目的是要表明,是否将一个查询扁平化的决定是复杂的。</target>
        </trans-unit>
        <trans-unit id="bcf344511369b084d726030fdafcea463d5dc468" translate="yes" xml:space="preserve">
          <source>The cell content area</source>
          <target state="translated">细胞内容区</target>
        </trans-unit>
        <trans-unit id="4e5d403004805e89c7f707b8add474e39df5ebd7" translate="yes" xml:space="preserve">
          <source>The cell pointer array</source>
          <target state="translated">单元格指针阵列</target>
        </trans-unit>
        <trans-unit id="e6c56d9636275558f42c1d09a95b01d119d13bcb" translate="yes" xml:space="preserve">
          <source>The cell pointer array of a b-tree page immediately follows the b-tree page header. Let K be the number of cells on the btree. The cell pointer array consists of K 2-byte integer offsets to the cell contents. The cell pointers are arranged in key order with left-most cell (the cell with the smallest key) first and the right-most cell (the cell with the largest key) last.</source>
          <target state="translated">b树页的单元格指针数组紧跟在b树页页眉后面。让K是b树上的单元格数量。单元格指针数组由K个2字节的单元格内容的整数偏移量组成。单元格指针按键序排列,最左边的单元格(键最小的单元格)在前,最右边的单元格(键最大的单元格)在后。</target>
        </trans-unit>
        <trans-unit id="1302721086a59f9c1c80a0439335aec4ebc89654" translate="yes" xml:space="preserve">
          <source>The cell_size_check pragma enables or disables additional sanity checking on database b-tree pages as they are initially read from disk. With cell size checking enabled, database corruption is detected earlier and is less likely to &quot;spread&quot;. However, there is a small performance hit for doing the extra checks and so cell size checking is turned off by default.</source>
          <target state="translated">cell_size_check pragma可以在数据库b-tree页面最初从磁盘读取时启用或禁用额外的健康检查。启用单元格大小检查后,数据库损坏会被更早地检测到,并且不太可能 &quot;扩散&quot;。然而,做额外的检查会对性能造成很小的影响,所以默认情况下,单元格大小检查是关闭的。</target>
        </trans-unit>
        <trans-unit id="68b13b4df554f0eca9f783dc081206c3c433b689" translate="yes" xml:space="preserve">
          <source>The cg_anno.tcl script removes extraneous details from the default cachegrind annotation output so that before-and-after reports can be compared using a side-by-side diff to view specific details of how a micro-optimization attempt affected performance.</source>
          <target state="translated">cg_anno.tcl脚本从默认的cachegrind注释输出中删除了不相干的细节,这样前后的报告就可以通过并排比较来查看微优化尝试如何影响性能的具体细节。</target>
        </trans-unit>
        <trans-unit id="fdc2d39d7bf4988a1e3259d80bd003ba0f7f2a24" translate="yes" xml:space="preserve">
          <source>The change is made by an SQL trigger or foreign key action instead of directly as a result of a users SQL statement.</source>
          <target state="translated">变化是通过SQL触发器或外键操作进行的,而不是直接作为用户SQL语句的结果。</target>
        </trans-unit>
        <trans-unit id="55b6de28efb13f598ab97e8c9b2ad359898d3863" translate="yes" xml:space="preserve">
          <source>The changes must consist of &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operations only. CREATE and DROP operations are not supported.</source>
          <target state="translated">更改必须仅由&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;，&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;和&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;操作组成。不支持CREATE和DROP操作。</target>
        </trans-unit>
        <trans-unit id="204b32b2b5c56879d06b01e160a1a35686edf225" translate="yes" xml:space="preserve">
          <source>The changes to locking and concurrency control in SQLite version 3 also introduce some subtle changes in the way transactions work at the SQL language level. By default, SQLite version 3 operates in &lt;em&gt;autocommit&lt;/em&gt; mode. In autocommit mode, all changes to the database are committed as soon as all operations associated with the current database connection complete.</source>
          <target state="translated">SQLite版本3中对锁定和并发控制的更改还对事务在SQL语言级别上的工作方式进行了一些微妙的更改。默认情况下，SQLite版本3在&lt;em&gt;自动提交&lt;/em&gt;模式下运行。在自动提交模式下，对数据库的所有更改将在与当前数据库连接关联的所有操作完成后立即提交。</target>
        </trans-unit>
        <trans-unit id="9ec4059d42e348f2d46482a218570373eadf5d72" translate="yes" xml:space="preserve">
          <source>The changes() function returns the number of database rows that were changed or inserted or deleted by the most recently completed INSERT, DELETE, or UPDATE statement, exclusive of statements in lower-level triggers. The changes() SQL function is a wrapper around the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; C/C++ function and hence follows the same rules for counting changes.</source>
          <target state="translated">changes（）函数返回由最近完成的INSERT，DELETE或UPDATE语句更改，插入或删除的数据库行数，不包括低级触发器中的语句。changes（）SQL函数是&lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes（）&lt;/a&gt; C / C ++函数的包装，因此遵循相同的计数变化规则。</target>
        </trans-unit>
        <trans-unit id="a67c4e9392e6b6f9ae02f045b5dfeb70fe9c0330" translate="yes" xml:space="preserve">
          <source>The char(X1,X2,...,XN) function returns a string composed of characters having the unicode code point values of integers X1 through XN, respectively.</source>
          <target state="translated">char(X1,X2,...,XN)函数返回一个由分别具有整数X1到XN的unicode码点值的字符组成的字符串。</target>
        </trans-unit>
        <trans-unit id="37f1486781d28feebc971db6315e3ab886799387" translate="yes" xml:space="preserve">
          <source>The chart below shows average time to read a blob directly from the filesystem versus the time needed to read the same blob from the SQLite database. The actual timings vary considerably from one system to another (the Ubuntu desktop is much faster than the Galaxy S3 phone, for example). This chart shows the ratio of the times needed to read blobs from a file divided by the time needed to from the database. The left-most column in the chart is the normalized time to read from the database, for reference.</source>
          <target state="translated">下图显示了直接从文件系统读取blob的平均时间与从SQLite数据库读取相同blob所需的时间。不同系统的实际时间差异很大(比如Ubuntu桌面比Galaxy S3手机快很多)。这张图显示了从文件中读取blob所需时间与从数据库中读取blob所需时间的比值。图表中最左边的一列是从数据库读取的归一化时间,供参考。</target>
        </trans-unit>
        <trans-unit id="f11b1918c906d3777fe0d3b93cddb4875a03b224" translate="yes" xml:space="preserve">
          <source>The chart below shows data collected using &lt;a href=&quot;https://www.sqlite.org/src/file/test/kvtest.c&quot;&gt;kvtest.c&lt;/a&gt; on five different systems:</source>
          <target state="translated">下图显示了在五个不同系统上使用&lt;a href=&quot;https://www.sqlite.org/src/file/test/kvtest.c&quot;&gt;kvtest.c&lt;/a&gt;收集的数据：</target>
        </trans-unit>
        <trans-unit id="7328593ed0585c2ca2a1685910b260ca61685e5b" translate="yes" xml:space="preserve">
          <source>The chart below shows the relative size and performance for SQLite as of 2017-10-08 for various compilers and optimization settings as tested on Ubuntu 16.04.3 on x86_64. General observations:</source>
          <target state="translated">下图显示了截至2017-10-08,在x86_64的Ubuntu 16.04.3上测试的各种编译器和优化设置下,SQLite的相对大小和性能。一般性的观察。</target>
        </trans-unit>
        <trans-unit id="3c6947bf2e572c7854301cde9f7c5737935d4086" translate="yes" xml:space="preserve">
          <source>The chart shows that on Windows10, content can be read from the SQLite database about 5 times faster than it can be read directly from disk. On Android, SQLite is only about 35% faster than reading from disk.</source>
          <target state="translated">从图中可以看出,在Windows10上,从SQLite数据库中读取内容的速度是直接从磁盘读取的5倍左右。在安卓系统上,SQLite的速度仅比从磁盘读取快35%左右。</target>
        </trans-unit>
        <trans-unit id="4b79be443470ce0f3ea4b17f53ee3e0a63d67172" translate="yes" xml:space="preserve">
          <source>The check-in has a &quot;trunk&quot; tag.</source>
          <target state="translated">签到有 &quot;后备箱 &quot;标签。</target>
        </trans-unit>
        <trans-unit id="83b47a927090544c586621a60b2916e19fae4550" translate="yes" xml:space="preserve">
          <source>The check-in has a child that has a &quot;trunk&quot; tag.</source>
          <target state="translated">签到的孩子有一个 &quot;后备箱 &quot;的标签。</target>
        </trans-unit>
        <trans-unit id="62c61bcc8ce340ae3a9c5cbdd0d35b553d2386d8" translate="yes" xml:space="preserve">
          <source>The check-in has a parent that has a &quot;trunk&quot; tag.</source>
          <target state="translated">签到的父体有一个 &quot;树干 &quot;标签。</target>
        </trans-unit>
        <trans-unit id="6dad224b0586b91e423315e1a7ef99941945ad20" translate="yes" xml:space="preserve">
          <source>The checksum VFS extension is a &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt; that adds an 8-byte checksum to the end of every page in an SQLite database. The checksum is added as each page is written and verified as each page is read. The checksum is intended to help detect database corruption caused by random bit-flips in the mass storage device.</source>
          <target state="translated">校验和VFS扩展名是&lt;a href=&quot;vfs#shim&quot;&gt;VFS填充程序&lt;/a&gt;，它将8字节校验和添加到SQLite数据库中每个页面的末尾。在写入每页时添加校验和，并在读取每页时验证校验和。校验和旨在帮助检测由大容量存储设备中的随机位翻转引起的数据库损坏。</target>
        </trans-unit>
        <trans-unit id="34c12f92dcc6b984c7dc0650d9da983b05acb095" translate="yes" xml:space="preserve">
          <source>The checksum VFS extension requires SQLite version 3.32.0 (2020-05-22) or later. It will not work with earlier versions of SQLite.</source>
          <target state="translated">校验和VFS扩展需要SQLite 3.32.0(2020-05-22)或更高版本。它将无法与早期版本的SQLite一起工作。</target>
        </trans-unit>
        <trans-unit id="b0b70c1c0ff79721dae8d9a4e00e5b929e1563a7" translate="yes" xml:space="preserve">
          <source>The checksum VFS module is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;. It is not included in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. It must be added to SQLite either at compile-time or at run-time. The source code to the checksum VFS module is in the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/cksumvfs.c&quot;&gt;ext/misc/cksumvfs.c&lt;/a&gt; source file in the &lt;a href=&quot;https://sqlite.org/src&quot;&gt;SQLite source tree&lt;/a&gt;.</source>
          <target state="translated">校验和VFS模块是&lt;a href=&quot;loadext&quot;&gt;可加载的扩展&lt;/a&gt;。它不包括在&lt;a href=&quot;amalgamation&quot;&gt;合并中&lt;/a&gt;。必须在编译时或运行时将其添加到SQLite。校验和VFS模块的源代码位于&lt;a href=&quot;https://sqlite.org/src&quot;&gt;SQLite源树&lt;/a&gt;的&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/cksumvfs.c&quot;&gt;ext / misc / cksumvfs.c&lt;/a&gt;源文件中。</target>
        </trans-unit>
        <trans-unit id="b751a07c985fa86fe7c3c40b3bf6704b7852bcb1" translate="yes" xml:space="preserve">
          <source>The checksum algorithm only works for content which is a multiple of 8 bytes in length. In other words, if the inputs are x(0) through x(N) then N must be odd. The checksum algorithm is as follows:</source>
          <target state="translated">校验和算法只适用于长度为8字节的倍数的内容。换句话说,如果输入是x(0)到x(N),那么N必须是奇数。校验和算法如下。</target>
        </trans-unit>
        <trans-unit id="9654e9833d2bad18eac61dc57f147c1ed15a761f" translate="yes" xml:space="preserve">
          <source>The checksum is an unsigned 32-bit integer computed as follows:</source>
          <target state="translated">校验和是一个无符号的32位整数,计算方法如下。</target>
        </trans-unit>
        <trans-unit id="270f933e45ef3250cf9dcd69e18f5fd196bd90a0" translate="yes" xml:space="preserve">
          <source>The checksum is computed by interpreting the input as an even number of unsigned 32-bit integers: x(0) through x(N). The 32-bit integers are big-endian if the magic number in the first 4 bytes of the WAL header is 0x377f0683 and the integers are little-endian if the magic number is 0x377f0682. The checksum values are always stored in the frame header in a big-endian format regardless of which byte order is used to compute the checksum.</source>
          <target state="translated">校验和的计算方法是将输入解释为一个无符号32位整数:x(0)到x(N)。如果WAL头的前4个字节中的魔数是0x377f0683,则32位整数为大安迪,如果魔数是0x377f0682,则整数为小安迪。无论使用哪种字节顺序来计算校验值,校验值总是以大恩迪格式存储在帧头中。</target>
        </trans-unit>
        <trans-unit id="cc24b6f9af8e44f6ff2e41a4a1721f4bd21f35c7" translate="yes" xml:space="preserve">
          <source>The checksum value is used to guard against incomplete writes of a journal page record following a power failure. A different random nonce is used each time a transaction is started in order to minimize the risk that unwritten sectors might by chance contain data from the same page that was a part of prior journals. By changing the nonce for each transaction, stale data on disk will still generate an incorrect checksum and be detected with high probability. The checksum only uses a sparse sample of 32-bit words from the data record for performance reasons - design studies during the planning phases of SQLite 3.0.0 showed a significant performance hit in checksumming the entire page.</source>
          <target state="translated">校验和值用于防止断电后日记页记录的不完整写入。每次启动事务时,都会使用不同的随机nonce,以最大限度地降低未写入扇区可能偶然包含来自先前日记的同一页面的数据的风险。通过改变每个事务的nonce,磁盘上的陈旧数据仍然会产生一个错误的校验和,并以高概率被检测到。出于性能方面的考虑,校验和只使用数据记录中32位字的稀疏样本--在SQLite 3.0.0规划阶段的设计研究表明,对整个页面进行校验和会对性能造成很大影响。</target>
        </trans-unit>
        <trans-unit id="3990c0ed7263ce684acb68c345cf784357432dbe" translate="yes" xml:space="preserve">
          <source>The checksum value written to the</source>
          <target state="translated">写入的校验和值。</target>
        </trans-unit>
        <trans-unit id="77ac1ab95620d7ae472b49582dcc0e306b38c020" translate="yes" xml:space="preserve">
          <source>The checksum values in the final 8 bytes of the frame-header exactly match the checksum computed consecutively on the first 24 bytes of the WAL header and the first 8 bytes and the content of all frames up to and including the current frame.</source>
          <target state="translated">帧头最后8个字节的校验值与WAL头的前24个字节和前8个字节以及包括当前帧在内的所有帧的内容连续计算的校验值完全一致。</target>
        </trans-unit>
        <trans-unit id="6c5140842eec97f2402faa79d3b18bc3769b3084" translate="yes" xml:space="preserve">
          <source>The child table references the primary key of the parent without specifying the primary key columns and the number of primary key columns in the parent do not match the number of child key columns.</source>
          <target state="translated">子表引用了父表的主键,但没有指定主键列,且父表的主键列数与子表的主键列数不一致。</target>
        </trans-unit>
        <trans-unit id="cb680522ff952474c4763f726c9755f62f14ba34" translate="yes" xml:space="preserve">
          <source>The circumstances under which SQLite will enforce the heap limits may changes in future releases of SQLite.</source>
          <target state="translated">在未来的SQLite版本中,SQLite执行堆限制的情况可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="da194c4576594e7457a28ceeefa6139ab020edb1" translate="yes" xml:space="preserve">
          <source>The circumstances under which SQLite will enforce the soft heap limit may changes in future releases of SQLite.</source>
          <target state="translated">在未来的SQLite版本中,SQLite执行软堆限制的情况可能会改变。</target>
        </trans-unit>
        <trans-unit id="61459fdd1646e497264a92192cd0400ff16d21ef" translate="yes" xml:space="preserve">
          <source>The cksumvfs extension implements a new PRAGMA statement that can be used to disable, re-enable, or query the status of checksum verification:</source>
          <target state="translated">cksumvfs扩展实现了一个新的PRAGMA语句,它可以用来禁用、重新启用或查询校验的状态。</target>
        </trans-unit>
        <trans-unit id="eed6f77a1a12342f6f0e71580e9b4032c3ba5e49" translate="yes" xml:space="preserve">
          <source>The claim of the previous paragraph is extensively checked in the SQLite regression test suite using a special test harness that simulates the effects on a database file of operating system crashes and power failures.</source>
          <target state="translated">在SQLite回归测试套件中,使用一个特殊的测试线束,模拟操作系统崩溃和电源故障对数据库文件的影响,对前一段的说法进行了广泛的检查。</target>
        </trans-unit>
        <trans-unit id="ce6585a17c4368c809080175136a8937ad00861b" translate="yes" xml:space="preserve">
          <source>The coalesce() function returns a copy of its first non-NULL argument, or NULL if all arguments are NULL. Coalesce() must have at least 2 arguments.</source>
          <target state="translated">coalesce()函数返回第一个非NULL参数的副本,如果所有参数都是NULL,则返回NULL。Coalesce()必须至少有2个参数。</target>
        </trans-unit>
        <trans-unit id="f7c2331fa2d3327c8c4beede4ed0b6e31a651048" translate="yes" xml:space="preserve">
          <source>The code above is for the general case. For the special case of an SQLite Archive that only stores uncompressed or uncompressible content (this might come up, for example, in an SQLite Archive that stores only JPEG, GIF, and/or PNG images) then the content can be inserted into and extracted from the database without using the sqlar_compress() and sqlar_uncompress() functions, and the sqlar.c extension is not required.</source>
          <target state="translated">上面的代码是针对一般情况的。对于只存储未压缩或不可压缩内容的SQLite Archive的特殊情况(例如,在一个只存储JPEG、GIF和/或PNG图像的SQLite Archive中可能会出现这种情况),那么就可以在不使用sqlar_compress()和sqlar_uncompress()函数的情况下将内容插入数据库并从数据库中提取,而且不需要使用sqlar.c扩展。</target>
        </trans-unit>
        <trans-unit id="4eb7b1d4fed609f9eafac0ed3cfa712e4a84c44c" translate="yes" xml:space="preserve">
          <source>The code appears stable so we are now calling it &quot;beta&quot;.</source>
          <target state="translated">代码看起来很稳定,所以我们现在称它为 &quot;测试版&quot;。</target>
        </trans-unit>
        <trans-unit id="4dcec88beb123f0b5fcd5b586036ea0a356cf753" translate="yes" xml:space="preserve">
          <source>The code audits used to ensure that memory allocation size computations do not overflow in SQLite are repeated prior to every SQLite release.</source>
          <target state="translated">用于确保SQLite中内存分配大小计算不溢出的代码审计在每次SQLite发布之前都会重复进行。</target>
        </trans-unit>
        <trans-unit id="b0a804ee343680af0bae1b47adaea7bd27c01026" translate="yes" xml:space="preserve">
          <source>The code for the swarmvtab virtual table is found in the ext/misc/unionvtab.c file of the main SQLite source tree. It may be compiled into an SQLite &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; using a command like:</source>
          <target state="translated">swarmvtab虚拟表的代码位于主SQLite源树的ext / misc / unionvtab.c文件中。可以使用以下命令将其编译为SQLite &lt;a href=&quot;loadext&quot;&gt;可加载扩展&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="429be1d142052bd4928f94110562bdb201e97a74" translate="yes" xml:space="preserve">
          <source>The code for the zipfile module is found in the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/zipfile.c&quot;&gt;ext/misc/zipfile.c&lt;/a&gt; file of the &lt;a href=&quot;https://sqlite.org/src&quot;&gt;main SQLite source tree&lt;/a&gt;. It may be compiled into an SQLite &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; using a command like:</source>
          <target state="translated">zipfile模块的代码位于&lt;a href=&quot;https://sqlite.org/src&quot;&gt;主SQLite源树&lt;/a&gt;的&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/zipfile.c&quot;&gt;ext / misc / zipfile.c&lt;/a&gt;文件中。可以使用以下命令将其编译为SQLite &lt;a href=&quot;loadext&quot;&gt;可加载扩展&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="e9f5bceb13445c13d968dff10e26983b65675c68" translate="yes" xml:space="preserve">
          <source>The code generated in this last example is the same as the previous except for the addition of two conditional jumps used to implement the extra WHERE and HAVING clauses. The WHERE clause is implemented by instructions 9 through 11 in the query loop. The HAVING clause is implemented by instruction 28 through 30 in the output loop.</source>
          <target state="translated">最后一个例子中生成的代码与前一个例子相同,只是增加了两个条件跳转,用于实现额外的WHERE和HAVING子句。WHERE子句由查询循环中的第9到11条指令实现。HAVING子句由输出循环中的第28至30条指令实现。</target>
        </trans-unit>
        <trans-unit id="ecc7e2ea5797377ee55e53ff370e71d0a0432eb1" translate="yes" xml:space="preserve">
          <source>The code generated to implement this last query is as follows:</source>
          <target state="translated">为实现最后这个查询而生成的代码如下。</target>
        </trans-unit>
        <trans-unit id="26011ad1079cb8255e24204fff9114945ad7804b" translate="yes" xml:space="preserve">
          <source>The code generator in SQLite processes compound SELECT statements using a recursive algorithm. In order to limit the size of the stack, we therefore limit the number of terms in a compound SELECT. The maximum number of terms is SQLITE_MAX_COMPOUND_SELECT which defaults to 500. We think this is a generous allotment since in practice we almost never see the number of terms in a compound select exceed single digits.</source>
          <target state="translated">SQLite中的代码生成器使用递归算法处理复合SELECT语句。为了限制堆栈的大小,我们因此限制了复合SELECT中术语的数量。最大的项数是SQLITE_MAX_COMPOUND_SELECT,默认为500。我们认为这是一个慷慨的分配,因为在实践中,我们几乎从未看到复合选择中的术语数超过个位数。</target>
        </trans-unit>
        <trans-unit id="0a5ca134725357f1db49cf5e9aed85ae431b52f8" translate="yes" xml:space="preserve">
          <source>The code generator, and especially the logic in &lt;b&gt;where*.c&lt;/b&gt; and in &lt;a href=&quot;https://sqlite.org/src/file/src/select.c&quot;&gt;select.c&lt;/a&gt;, is sometimes called the &lt;a href=&quot;optoverview&quot;&gt;query planner&lt;/a&gt;. For any particular SQL statement, there might be hundreds, thousands, or millions of different algorithms to compute the answer. The query planner is an AI that strives to select the best algorithm from these millions of choices.</source>
          <target state="translated">代码生成器，尤其是&lt;b&gt;where * .c&lt;/b&gt;和&lt;a href=&quot;https://sqlite.org/src/file/src/select.c&quot;&gt;select.c中&lt;/a&gt;的逻辑，有时被称为&lt;a href=&quot;optoverview&quot;&gt;查询计划器&lt;/a&gt;。对于任何特定的SQL语句，可能有数百，数千或数百万种不同的算法来计算答案。查询计划器是一种AI，致力于从数百万种选择中选择最佳算法。</target>
        </trans-unit>
        <trans-unit id="25e3614fe3c2a2058c86f93c8b850392e16eae8c" translate="yes" xml:space="preserve">
          <source>The code in &quot;fts5.c&quot; may then be compiled into a loadable extension or statically linked into an application as described in &lt;a href=&quot;loadext#build&quot;&gt;Compiling Loadable Extensions&lt;/a&gt;. There are two entry points defined, both of which do the same thing:</source>
          <target state="translated">然后，可以如&amp;ldquo; &lt;a href=&quot;loadext#build&quot;&gt;编译可加载扩展&amp;rdquo;中&lt;/a&gt;所述将&amp;ldquo; fts5.c&amp;rdquo;中的代码编译成可加载扩展，或静态链接到应用程序中。定义了两个入口点，它们都具有相同的作用：</target>
        </trans-unit>
        <trans-unit id="c15d2613b82ac42eff7d51f6a4257bfde77f5feb" translate="yes" xml:space="preserve">
          <source>The code in this article could be improved in at least two ways:</source>
          <target state="translated">本文的代码至少可以从两个方面进行改进。</target>
        </trans-unit>
        <trans-unit id="81d14a407fed1c180dec58abfdf7e1bfd2ff10aa" translate="yes" xml:space="preserve">
          <source>The code space used by the SQLite library depends on the target platform, the compiler, and optimization settings. These variables also affect performance.</source>
          <target state="translated">SQLite库使用的代码空间取决于目标平台、编译器和优化设置。这些变量也会影响性能。</target>
        </trans-unit>
        <trans-unit id="5c4a1121bef63849753648d7ec67f82ac551ebbe" translate="yes" xml:space="preserve">
          <source>The colUsed field indicates which columns of the virtual table may be required by the current scan. Virtual table columns are numbered from zero in the order in which they appear within the CREATE TABLE statement passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62), the corresponding bit is set within the colUsed mask if the column may be required by SQLite. If the table has at least 64 columns and any column to the right of the first 63 is required, then bit 63 of colUsed is also set. In other words, column iCol may be required if the expression (colUsed &amp;amp; ((sqlite3_uint64)1 &amp;lt;&amp;lt; (iCol&amp;gt;=63 ? 63 : iCol))) evaluates to non-zero.</source>
          <target state="translated">colUsed字段指示当前扫描可能需要虚拟表的哪些列。虚拟表列的编号从零开始，按照它们在传递给sqlite3_declare_vtab（）的CREATE TABLE语句中出现的顺序。对于前63列（列0-62），如果SQLite可能需要使用此列，则在colUsed掩码内设置相应的位。如果该表至少有64列，并且必须在前63列的右边添加任何列，则还会设置colUsed的位63。换句话说，如果表达式（colUsed＆（（（sqlite3_uint64）1 &amp;lt;&amp;lt;（iCol&amp;gt; = 63？63：iCol）））的计算结果为非零，则可能需要列iCol。</target>
        </trans-unit>
        <trans-unit id="cd6add92b1a269fd1ee22788d7c2c68cbcfa3387" translate="yes" xml:space="preserve">
          <source>The collating function callback is invoked with a copy of the pArg application data pointer and with two strings in the encoding specified by the eTextRep argument. The collating function must return an integer that is negative, zero, or positive if the first string is less than, equal to, or greater than the second, respectively. A collating function must always return the same answer given the same inputs. If two or more collating functions are registered to the same collation name (using different eTextRep values) then all must give an equivalent answer when invoked with equivalent strings. The collating function must obey the following properties for all strings A, B, and C:</source>
          <target state="translated">整理函数回调是用pArg应用程序数据指针的副本和两个由eTextRep参数指定编码的字符串来调用的。如果第一个字符串分别小于、等于或大于第二个字符串,整理函数必须返回一个负数、零或正数的整数。在输入相同的情况下,整理函数必须总是返回相同的答案。如果两个或更多的整理函数注册在同一个整理名下(使用不同的eTextRep值),那么当用等价字符串调用时,所有的整理函数必须给出一个等价的答案。对于所有字符串A、B和C,整理函数必须服从以下属性。</target>
        </trans-unit>
        <trans-unit id="0a8a7f3b3c83ac2e3d1763414e674a2e2ca29ee7" translate="yes" xml:space="preserve">
          <source>The collating function callback is invoked with a copy of the pArg application data pointer and with two strings in the encoding specified by the eTextRep argument. The two integer parameters to the collating function callback are the length of the two strings, in bytes. The collating function must return an integer that is negative, zero, or positive if the first string is less than, equal to, or greater than the second, respectively. A collating function must always return the same answer given the same inputs. If two or more collating functions are registered to the same collation name (using different eTextRep values) then all must give an equivalent answer when invoked with equivalent strings. The collating function must obey the following properties for all strings A, B, and C:</source>
          <target state="translated">整理函数回调是用pArg应用程序数据指针的副本和两个由eTextRep参数指定编码的字符串来调用的。整理函数回调的两个整数参数是两个字符串的长度,单位是字节。如果第一个字符串小于、等于或大于第二个字符串,整理函数必须返回一个负数、零或正数的整数。在输入相同的情况下,整理函数必须总是返回相同的答案。如果两个或更多的整理函数注册在同一个整理名下(使用不同的eTextRep值),那么当用等价字符串调用时,所有的整理函数必须给出一个等价的答案。对于所有字符串A、B和C,整理函数必须服从以下属性。</target>
        </trans-unit>
        <trans-unit id="65d2bfaa5988de22a32b291f24dfa00da4fc2f70" translate="yes" xml:space="preserve">
          <source>The column is identified by the second, third and fourth parameters to this function. The second parameter is either the name of the database (i.e. &quot;main&quot;, &quot;temp&quot;, or an attached database) containing the specified table or NULL. If it is NULL, then all attached databases are searched for the table using the same algorithm used by the database engine to resolve unqualified table references.</source>
          <target state="translated">该列由该函数的第二、第三和第四个参数确定。第二个参数是包含指定表的数据库名称(即 &quot;main&quot;、&quot;temp &quot;或附属数据库)或NULL。如果是NULL,则使用数据库引擎用来解析非限定表引用的相同算法,搜索所有附加数据库来查找该表。</target>
        </trans-unit>
        <trans-unit id="7829593889659cca230ab3239645af748546a7d0" translate="yes" xml:space="preserve">
          <source>The column labels that appear on the first two lines of output can be turned on and off using the &quot;.header&quot; dot command. In the examples above, the column labels are on. To turn them off you could do this:</source>
          <target state="translated">可以使用&quot;.header &quot;点命令打开或关闭输出前两行的列标签。在上面的例子中,列标签是打开的。要关闭它们,您可以这样做。</target>
        </trans-unit>
        <trans-unit id="9b37c354a4343966405cb0363479fdc771c7551d" translate="yes" xml:space="preserve">
          <source>The column may not be &lt;a href=&quot;gencol&quot;&gt;GENERATED ALWAYS ... STORED&lt;/a&gt;, though VIRTUAL columns are allowed.</source>
          <target state="translated">尽管允许使用虚拟列，但该列可能不会始终&lt;a href=&quot;gencol&quot;&gt;生成...存储&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="71d2d7e1bd431710201b6152bbbf86fa85eac1e5" translate="yes" xml:space="preserve">
          <source>The column may not have a PRIMARY KEY or UNIQUE constraint.</source>
          <target state="translated">该列可能没有primary key或unique约束。</target>
        </trans-unit>
        <trans-unit id="99d848b798067eee9317efc709f08dee3a25b0a8" translate="yes" xml:space="preserve">
          <source>The column may not have a default value of CURRENT_TIME, CURRENT_DATE, CURRENT_TIMESTAMP, or an expression in parentheses.</source>
          <target state="translated">该列的默认值不能是CURRENT_TIME、CURRENT_DATE、CURRENT_TIMESTAMP或括号中的表达式。</target>
        </trans-unit>
        <trans-unit id="adb879e73b7d88dc161320c793668864d27ae4e6" translate="yes" xml:space="preserve">
          <source>The column names and definitions for</source>
          <target state="translated">的列名和定义。</target>
        </trans-unit>
        <trans-unit id="b16cccd51ed940f2dd9c18cb3d4d9b130c9ecd9e" translate="yes" xml:space="preserve">
          <source>The column names for the result sets of &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements have been tweaked in some cases to work more like other SQL database engines.</source>
          <target state="translated">在某些情况下，已经对&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句的结果集的列名进行了调整，使其更像其他SQL数据库引擎一样工作。</target>
        </trans-unit>
        <trans-unit id="239fe7786e783e697b78c9df7c06b9daecb4d9f7" translate="yes" xml:space="preserve">
          <source>The column names of the virtual table are determined primarily by the &lt;b&gt;schema=&lt;/b&gt; argument. If the &lt;b&gt;schema=&lt;/b&gt; argument is omitted, but &lt;b&gt;header&lt;/b&gt; is true, then the values found in the first line of the CSV file become the column names. If the &lt;b&gt;schema=&lt;/b&gt; argument is omitted and &lt;b&gt;header&lt;/b&gt; is false, then the columns are named &quot;c0&quot;, &quot;c1&quot;, &quot;c2&quot;, and so forth.</source>
          <target state="translated">虚拟表的列名称主要由&lt;b&gt;schema =&lt;/b&gt;参数确定。如果省略了&lt;b&gt;schema =&lt;/b&gt;参数，但&lt;b&gt;标头&lt;/b&gt;为true，则在CSV文件第一行中找到的值将成为列名。如果省略了&lt;b&gt;schema =&lt;/b&gt;参数，并且&lt;b&gt;标头&lt;/b&gt;为false，则这些列的名称为&amp;ldquo; c0&amp;rdquo;，&amp;ldquo; c1&amp;rdquo;，&amp;ldquo; c2&amp;rdquo;，依此类推。</target>
        </trans-unit>
        <trans-unit id="27cc219896194f2cbf6cb1853331dc30b6f1a32f" translate="yes" xml:space="preserve">
          <source>The column names reported by join subqueries have been modified slightly in order to work more like other database engines. Consider the following query:</source>
          <target state="translated">连接子查询所报告的列名已经稍作修改,以便更像其他数据库引擎那样工作。考虑以下查询。</target>
        </trans-unit>
        <trans-unit id="cf988c97f1d408bf1402feb7e21744609abdb492" translate="yes" xml:space="preserve">
          <source>The column number (1 for the second leftmost column, etc.). This field is omitted for any term-offset list associated with column 0.</source>
          <target state="translated">列号(1代表最左边第二列等)。与第0栏相关的任何术语偏移量清单都省略此栏。</target>
        </trans-unit>
        <trans-unit id="0d64ee03e40c54227cba3f5e9c70df99b5d87845" translate="yes" xml:space="preserve">
          <source>The column number that the term instance occurs in (0 for the leftmost column of the FTS table, 1 for the next leftmost, etc.).</source>
          <target state="translated">术语实例所在的列号(0代表FTS表的最左列,1代表下一个最左列,等等)。</target>
        </trans-unit>
        <trans-unit id="0e0d4c37f8f415ca48f1578c5fbfec2c6eeee2e7" translate="yes" xml:space="preserve">
          <source>The column-name list syntax was added in SQLite versions 3.9.0 (2015-10-14).</source>
          <target state="translated">在SQLite 3.9.0版本(2015-10-14)中增加了列名列表语法。</target>
        </trans-unit>
        <trans-unit id="74b05d9163657d39d9cb9b3d5f80884cae70cb2c" translate="yes" xml:space="preserve">
          <source>The columns are provided by the SQLITE_STMT virtual table are summarized by the hypothetical CREATE TABLE statement show here:</source>
          <target state="translated">SQLITE_STMT虚拟表提供的列由这里显示的假设CREATE TABLE语句来总结。</target>
        </trans-unit>
        <trans-unit id="99fc02c8d425b8c14b21527882dd349490360fd6" translate="yes" xml:space="preserve">
          <source>The columns referenced in the WHERE clause of a partial index can be any of the columns in the table, not just columns that happen to be indexed. However, it is very common for the WHERE clause expression of a partial index to be a simple expression on the column being indexed. The following is a typical example:</source>
          <target state="translated">部分索引的WHERE子句中引用的列可以是表中的任何一列,而不仅仅是刚好被索引的列。然而,非常常见的是,部分索引的WHERE子句表达式是对被索引列的简单表达式。下面是一个典型的例子。</target>
        </trans-unit>
        <trans-unit id="c36ceb732928b62fa9f17cf0516fa8ff6f38d20c" translate="yes" xml:space="preserve">
          <source>The command above created the new branch. But your checkout is still on the trunk - a fact you can see by running the command:</source>
          <target state="translated">上面的命令创建了新的分支。但你的结账仍然在主干上--你可以通过运行该命令看到这一事实。</target>
        </trans-unit>
        <trans-unit id="39e91ef2d072dfac6ebe4c80889ed64220c2f4b1" translate="yes" xml:space="preserve">
          <source>The command above will make a copy of the complete development history of SQLite into the &quot;sqlite.fossil&quot; file on your computer. Making this copy takes about a minute and uses about 32 megabytes of transfer. After making the copy, &quot;open&quot; the repository by typing:</source>
          <target state="translated">上面的命令会将SQLite的完整开发历史复制到电脑上的 &quot;sqlite.fossil &quot;文件中。制作这个副本大约需要一分钟,使用大约32兆的传输量。制作完拷贝后,通过输入 &quot;打开 &quot;版本库。</target>
        </trans-unit>
        <trans-unit id="4b3dc1d8af5139eaa56167ba29f9c2c18e9d510c" translate="yes" xml:space="preserve">
          <source>The command above writes the output of the query as CSV into a temporary file, invokes the default handler for CSV files (usually the preferred spreadsheet program such as Excel or LibreOffice), then deletes the temporary file. This is essentially a short-hand method of doing the sequence of &quot;.csv&quot;, &quot;.once&quot;, and &quot;.system&quot; commands described above.</source>
          <target state="translated">上面的命令将查询的输出以CSV的形式写入一个临时文件,调用CSV文件的默认处理程序(通常是首选的电子表格程序,如Excel或LibreOffice),然后删除临时文件。这本质上是一种简捷的方法,可以完成上面描述的&quot;.csv&quot;、&quot;.once &quot;和&quot;.system &quot;命令的序列。</target>
        </trans-unit>
        <trans-unit id="b075c13635ba5e790ee4582ea35e32db5040da00" translate="yes" xml:space="preserve">
          <source>The command returns a new TCL channel for reading or writing to the BLOB. The channel is opened using the underlying &lt;a href=&quot;c3ref/blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; C-language interface. Close the channel using the &lt;b&gt;close&lt;/b&gt; command of TCL.</source>
          <target state="translated">该命令返回一个新的TCL通道，用于读取或写入BLOB。使用基础&lt;a href=&quot;c3ref/blob_open&quot;&gt;sqlite3_blob_open（）&lt;/a&gt; C语言接口打开通道。使用TCL 的&lt;b&gt;关闭&lt;/b&gt;命令关闭通道。</target>
        </trans-unit>
        <trans-unit id="988274d0addcbb9018970d10733f7b4052f070a2" translate="yes" xml:space="preserve">
          <source>The command-line shell adds two &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; that facilitate reading content from a file into a table column, and writing the content of a column into a file, respectively.</source>
          <target state="translated">命令行外壳&lt;a href=&quot;appfunc&quot;&gt;程序&lt;/a&gt;添加了两个应用程序定义的SQL函数，这些函数分别有助于将文件中的内容读取到表列中以及将列中的内容写入文件中。</target>
        </trans-unit>
        <trans-unit id="1a64c0d6110f60679f08571c4a254a77214045a1" translate="yes" xml:space="preserve">
          <source>The command-line shell adds two &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; that facilitate reading content from a file into a table column, and writing the content of a column into a file, respectively.</source>
          <target state="translated">命令行外壳&lt;a href=&quot;c3ref/create_function&quot;&gt;程序&lt;/a&gt;添加了两个应用程序定义的SQL函数，这些函数有助于分别从文件中读取内容到表列中以及将列中的内容写入文件中。</target>
        </trans-unit>
        <trans-unit id="5a15969d303479025517006f69c3c3e87572075f" translate="yes" xml:space="preserve">
          <source>The command-line shell uses the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; to access ZIP archives. You can see this by running the &quot;.schema&quot; command when a ZIP archive is open:</source>
          <target state="translated">命令行外壳使用&lt;a href=&quot;zipfile&quot;&gt;Zipfile虚拟表&lt;/a&gt;访问ZIP存档。您可以通过在打开ZIP归档文件时运行&amp;ldquo; .schema&amp;rdquo;命令来查看此内容：</target>
        </trans-unit>
        <trans-unit id="9d792fd30ad98774099bd3871331d49c13f01ab7" translate="yes" xml:space="preserve">
          <source>The commit and rollback hook callbacks are not reentrant. The callback implementation must not do anything that will modify the database connection that invoked the callback. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the commit or rollback hook in the first place. Note that running any other SQL statements, including SELECT statements, or merely calling &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; will modify the database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">提交和回滚挂钩回调不可重入。回调实现不得做任何会修改调用回调的数据库连接的操作。必须先推迟任何修改数据库连接的操作，直到完成首先触发提交或回滚挂钩的&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;调用完成之后。请注意，运行任何其他SQL语句（包括SELECT语句）或仅调用&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;都会修改数据库连接，其含义在本段中为&amp;ldquo;修改&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="837a3144fbcca3d5f0e20f9cd17c26bc03114566" translate="yes" xml:space="preserve">
          <source>The commit and rollback hook callbacks are not reentrant. The callback implementation must not do anything that will modify the database connection that invoked the callback. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the commit or rollback hook in the first place. Note that running any other SQL statements, including SELECT statements, or merely calling &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; will modify the database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">提交和回滚挂钩回调不可重入。回调实现不得做任何会修改调用回调的数据库连接的操作。必须先推迟任何修改数据库连接的操作，直到完成首先触发提交或回滚挂钩的&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;调用完成之后。请注意，运行任何其他SQL语句（包括SELECT语句）或仅调用&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;和&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;都会修改数据库连接，其含义在本段中为&amp;ldquo;修改&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="5854e2359472df03b69e7808b8ee34022d4a6816" translate="yes" xml:space="preserve">
          <source>The commit process shown in &lt;a href=&quot;#section_3_0&quot;&gt;section 3.0&lt;/a&gt; assumes that all database changes fit in memory until it is time to commit. This is the common case. But sometimes a larger change will overflow the user-space cache prior to transaction commit. In those cases, the cache must spill to the database before the transaction is complete.</source>
          <target state="translated">&lt;a href=&quot;#section_3_0&quot;&gt;第3.0节中&lt;/a&gt;的提交过程假定所有数据库更改都适合内存，直到该提交为止。这是常见的情况。但是有时，较大的更改将在事务提交之前使用户空间缓存溢出。在这些情况下，缓存必须在事务完成之前溢出到数据库。</target>
        </trans-unit>
        <trans-unit id="831de8c9305e21ddee6326436c38620139c51d57" translate="yes" xml:space="preserve">
          <source>The common table expression works without having to load an extension. On the other hand, the extension is easier to program and faster.</source>
          <target state="translated">普通的表格表达式无需加载扩展即可工作。另一方面,扩展表更容易编程,速度更快。</target>
        </trans-unit>
        <trans-unit id="975322957294bcdde1991bc8533b4c3c42c34fe5" translate="yes" xml:space="preserve">
          <source>The comparison is a sort comparison, so NULLs compare equal, NULLs are less than numbers, numbers are less than strings, and strings are less than blobs.</source>
          <target state="translated">比较是一种排序比较,所以NULLs比较相等,NULLs小于数字,数字小于字符串,字符串小于blobs。</target>
        </trans-unit>
        <trans-unit id="77fdffaa220770108e157d8f6fdf86e8984310f3" translate="yes" xml:space="preserve">
          <source>The compilation step shown immediately above is merely representative. In a working installation, one would normally want to specify optimization parameters and compile-time switches on the compiler command line.</source>
          <target state="translated">上面显示的编译步骤仅仅是代表性的。在工作中,通常会在编译器命令行中指定优化参数和编译时开关。</target>
        </trans-unit>
        <trans-unit id="06859965a5874b48e17ef99de2638103b952d1aa" translate="yes" xml:space="preserve">
          <source>The compile-time options for setting upper bounds are &lt;a href=&quot;limits&quot;&gt;documented separately&lt;/a&gt;. The following is a list of the available settings:</source>
          <target state="translated">设置上限的编译时选项&lt;a href=&quot;limits&quot;&gt;单独记录&lt;/a&gt;。以下是可用设置的列表：</target>
        </trans-unit>
        <trans-unit id="d37610227543b6269c9a6c07ddb9c1381df5a58a" translate="yes" xml:space="preserve">
          <source>The complete state of an SQLite database is usually contained in a single file on disk called the &quot;main database file&quot;.</source>
          <target state="translated">SQLite数据库的完整状态通常包含在磁盘上的一个文件中,称为 &quot;主数据库文件&quot;。</target>
        </trans-unit>
        <trans-unit id="96bf44cd55dc348e4e3f4d568f7843d225f7562d" translate="yes" xml:space="preserve">
          <source>The completion table is designed for interactive use. It will return answers at a speed appropriate for human typing. No effort is made to be unusually efficient, so long as the response time is nearly instantaneous in a user interface.</source>
          <target state="translated">完成表是为交互式使用而设计的。它将以适合人类打字的速度返回答案。只要在用户界面上的反应时间几乎是瞬时的,就不会努力做到异常高效。</target>
        </trans-unit>
        <trans-unit id="d59eec775be7e50d6274c344c801f729c91ab804" translate="yes" xml:space="preserve">
          <source>The completion table is used to implement tab-completion in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; in conjunction with either the readline or linenoise input line editing packages for unix. See the &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;https://sqlite.org/src/file/src/shell.c.in&lt;/a&gt; source file for example code. Search for &quot;FROM completion&quot; to find the relevant code sections.</source>
          <target state="translated">补全表用于在&lt;a href=&quot;cli&quot;&gt;命令行外壳&lt;/a&gt;中结合Tab的readline或linenoise输入行编辑包来实现Tab 补全。有关示例代码，请参见源文件中的&lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;https://sqlite.org/src/file/src/shell.c&lt;/a&gt; .。搜索&amp;ldquo; FROM完成&amp;rdquo;以找到相关的代码部分。</target>
        </trans-unit>
        <trans-unit id="e034c5722458a4ef5f557863bb00dfc415febe07" translate="yes" xml:space="preserve">
          <source>The completion table might return the same candidate more than once, and it will return candidates in an arbitrary order. The DISTINCT keyword and the ORDER BY in the sample query above are added to make the answers unique and in lexicographical order.</source>
          <target state="translated">完形表可能会多次返回同一个考生,而且会以任意顺序返回考生。在上面的示例查询中加入了DISTINCT关键字和ORDER BY,使答案具有唯一性和词性顺序。</target>
        </trans-unit>
        <trans-unit id="7bf1657f4892b438bb6c981746dfe40cd870c0fa" translate="yes" xml:space="preserve">
          <source>The complexity of Git distracts attention from the software under development. A user of Git needs to keep all of the following in mind:</source>
          <target state="translated">Git的复杂性分散了人们对开发中软件的注意力。Git的用户需要牢记以下几点:</target>
        </trans-unit>
        <trans-unit id="15376f7aadf15df031fa31738229dcbaf3f18c9d" translate="yes" xml:space="preserve">
          <source>The compound SELECT operators UNION, INTERSECT and EXCEPT perform implicit comparisons between values. No affinity is applied to comparison operands for the implicit comparisons associated with UNION, INTERSECT, or EXCEPT - the values are compared as is.</source>
          <target state="translated">复合SELECT操作符UNION、INTERSECT和EXCEPT在值之间进行隐式比较。在与UNION、INTERSECT或EXCEPT相关联的隐式比较中,没有对比较操作数进行亲和性应用,而是按原样进行比较。</target>
        </trans-unit>
        <trans-unit id="dc11a925c84e89a2d79f62896a81bbc87b31205f" translate="yes" xml:space="preserve">
          <source>The compress and uncompress options allow FTS4 content to be stored in the database in a compressed form. Both options should be set to the name of an SQL scalar function registered using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; that accepts a single argument.</source>
          <target state="translated">压缩和解压缩选项允许FTS4内容以压缩形式存储在数据库中。这两个选项都应设置为使用&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;注册的SQL标量函数的名称，该函数接受单个参数。</target>
        </trans-unit>
        <trans-unit id="8f77d8f289ab8ab189cc2f583f00d06f6f32d94d" translate="yes" xml:space="preserve">
          <source>The compress function should return a compressed version of the value passed to it as an argument. Each time data is written to the FTS4 table, each column value is passed to the compress function and the result value stored in the database. The compress function may return any type of SQLite value (blob, text, real, integer or null).</source>
          <target state="translated">压缩函数应该返回作为参数传递给它的值的压缩版本。每次向FTS4表写入数据时,每个列的值都会传递给压缩函数,结果值存储在数据库中。压缩函数可以返回任何类型的SQLite值(blob、文本、实数、整数或空值)。</target>
        </trans-unit>
        <trans-unit id="290b0a4fd26e950183bc56ef03571b78a9f077cd" translate="yes" xml:space="preserve">
          <source>The compress option is used to specify the compress function. It is an error to specify a compress function without also specifying an uncompress function. &lt;a href=&quot;fts3#the_compress_and_uncompress_options&quot;&gt;See below&lt;/a&gt; for details.</source>
          <target state="translated">compress选项用于指定compress函数。指定压缩函数而不指定解压缩函数是错误的。&lt;a href=&quot;fts3#the_compress_and_uncompress_options&quot;&gt;有关&lt;/a&gt;详情，请参见下文。</target>
        </trans-unit>
        <trans-unit id="5836c13f879c56ed967a4394bb1d7a4816e02cd2" translate="yes" xml:space="preserve">
          <source>The compress=, uncompress= and languageid= options are not available. There is as of yet no equivalent for their functionality.</source>
          <target state="translated">压缩=、解压缩=和语言id=选项不可用。目前还没有对应的功能。</target>
        </trans-unit>
        <trans-unit id="2469db0ecb30ed655de4891189661dea5b883567" translate="yes" xml:space="preserve">
          <source>The compression method used to compress the data (an integer). The value 0 indicates that the data is stored in the zip archive without compression. 8 means the raw deflate algorithm.</source>
          <target state="translated">用于压缩数据的压缩方法(整数)。值0表示数据存储在zip压缩包中,不进行压缩。8表示原始放气算法。</target>
        </trans-unit>
        <trans-unit id="c682ba9f6178606617e01c8b48358fa9163f9c2c" translate="yes" xml:space="preserve">
          <source>The computation of local time depends heavily on the whim of politicians and is thus difficult to get correct for all locales. In this implementation, the standard C library function localtime_r() is used to assist in the calculation of local time. The localtime_r() C function normally only works for years between 1970 and 2037. For dates outside this range, SQLite attempts to map the year into an equivalent year within this range, do the calculation, then map the year back.</source>
          <target state="translated">当地时间的计算在很大程度上取决于政治家的一时兴起,因此很难在所有地方都得到正确的计算。在这个实现中,标准的C库函数localtime_r()被用来协助计算当地时间。localtime_r()C函数通常只适用于1970年到2037年之间的年份。对于这个范围之外的日期,SQLite会尝试将年份映射到这个范围内的等值年份,进行计算,然后将年份映射回来。</target>
        </trans-unit>
        <trans-unit id="a84ddecfbfcfd1c573cf704dea12a071acade093" translate="yes" xml:space="preserve">
          <source>The concept of fuzz testing has been around for decades, but fuzz testing was not an effective way to find bugs until 2014 when Michal Zalewski invented the first practical profile-guided fuzzer, &lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;American Fuzzy Lop&lt;/a&gt; or &quot;AFL&quot;. Unlike prior fuzzers that blindly generate random inputs, AFL instruments the program being tested (by modifying the assembly-language output from the C compiler) and uses that instrumentation to detect when an input causes the program to do something different - to follow a new control path or loop a different number of times. Inputs that provoke new behavior are retained and further mutated. In this way, AFL is able to &quot;discover&quot; new behaviors of the program under test, including behaviors that were never envisioned by the designers.</source>
          <target state="translated">模糊测试的概念已经存在了数十年，但是直到2014年Michal Zalewski发明了第一个实用的轮廓引导&lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;模糊&lt;/a&gt;器，American Fuzzy Lop或&amp;ldquo; AFL&amp;rdquo;后，模糊测试才是发现错误的有效方法。与以前的模糊器盲目生成随机输入不同，AFL会检测正在测试的程序（通过修改C编译器的汇编语言输出），并使用该检测方法来检测输入何时导致程序执行不同的操作-遵循新的控件路径或循环不同的次数。引发新行为的输入将保留并进一步突变。通过这种方式，AFL能够&amp;ldquo;发现&amp;rdquo;被测程序的新行为，包括设计人员从未想到的行为。</target>
        </trans-unit>
        <trans-unit id="3c788bf48ee2358b78bb00bc56b593bb09c394d8" translate="yes" xml:space="preserve">
          <source>The configure script (on unix) automatically detects pread() and pwrite() and sets compile-time options to use those OS interfaces if they are available.</source>
          <target state="translated">configure脚本(在unix上)会自动检测pread()和pwrite(),并设置编译时的选项,以便在这些操作系统接口可用时使用它们。</target>
        </trans-unit>
        <trans-unit id="b71509666058777b45e3ddaa4c2923ebc4c7fa2f" translate="yes" xml:space="preserve">
          <source>The configure-make works whether your are building from the canonical sources from the source tree, or from an amalgamated bundle. There are few dependencies. When building from canonical sources, a working &lt;a href=&quot;https://www.tcl.tk/man/tcl8.3/UserCmd/tclsh.htm&quot;&gt;tclsh&lt;/a&gt; is required. If using an amalgamation bundle, all the preprocessing work normally done by tclsh will have already been carried out and only normal build tools are required.</source>
          <target state="translated">无论您是从源代码树的标准源还是从合并的捆绑包中进行构建，configure-make都可以工作。依赖很少。从规范来源进行构建时，需要有效的&lt;a href=&quot;https://www.tcl.tk/man/tcl8.3/UserCmd/tclsh.htm&quot;&gt;tclsh&lt;/a&gt;。如果使用合并包，则通常已经由tclsh完成的所有预处理工作已经完成，并且仅需要常规的构建工具。</target>
        </trans-unit>
        <trans-unit id="8ac9040eb64152e9af693ac6b3d6353d633a032f" translate="yes" xml:space="preserve">
          <source>The conflict handler is invoked with CHANGESET_DATA as the second argument when processing a DELETE or UPDATE change if a row with the required PRIMARY KEY fields is present in the database, but one or more other (non primary-key) fields modified by the update do not contain the expected &quot;before&quot; values.</source>
          <target state="translated">当处理DELETE或UPDATE更改时,如果数据库中存在一条具有所需PRIMARY KEY字段的记录,但被更新修改的一个或多个其他(非PRIMARY KEY)字段不包含预期的 &quot;之前 &quot;值,那么冲突处理程序将以CHANGESET_DATA作为第二个参数被调用。</target>
        </trans-unit>
        <trans-unit id="23fc4d91796bed566e82459162cebcab0cf84b45" translate="yes" xml:space="preserve">
          <source>The conflict handler is invoked with CHANGESET_NOTFOUND as the second argument when processing a DELETE or UPDATE change if a row with the required PRIMARY KEY fields is not present in the database.</source>
          <target state="translated">当处理DELETE或UPDATE变更时,如果数据库中不存在具有所需PRIMARY KEY字段的记录,那么冲突处理程序将以CHANGESET_NOTFOUND作为第二个参数被调用。</target>
        </trans-unit>
        <trans-unit id="c661dc346561d136d5859295a5527b2af74324a7" translate="yes" xml:space="preserve">
          <source>The conflicting row in this case is the database row with the matching primary key.</source>
          <target state="translated">在这种情况下,冲突的行是具有匹配主键的数据库行。</target>
        </trans-unit>
        <trans-unit id="4298401952abf69332c686d0b1f446ca8e2e6344" translate="yes" xml:space="preserve">
          <source>The conflicting row, in this case, is the database row with the matching primary key.</source>
          <target state="translated">冲突的行,在这种情况下,是具有匹配主键的数据库行。</target>
        </trans-unit>
        <trans-unit id="ca62ceaf8e4848fb4512d05da76c6a9337ad0aa5" translate="yes" xml:space="preserve">
          <source>The connection checks if a</source>
          <target state="translated">连接检查是否有</target>
        </trans-unit>
        <trans-unit id="72c42ad2c395427b5b34bc215df721de823e8688" translate="yes" xml:space="preserve">
          <source>The connection checks if the data in the</source>
          <target state="translated">连接检查在</target>
        </trans-unit>
        <trans-unit id="aed384d7e555153a17ceb13abbd6bca15763f13c" translate="yes" xml:space="preserve">
          <source>The content allows the text being indexed to be stored in a separate table distinct from the FTS4 table, or even outside of SQLite.</source>
          <target state="translated">内容允许被索引的文本被存储在一个不同于FTS4表的单独的表中,甚至在SQLite之外。</target>
        </trans-unit>
        <trans-unit id="d6e0eda1c9ea11f507c054ff491306a6eca1ff67" translate="yes" xml:space="preserve">
          <source>The content in the sqlite_stat4 table cannot be computed with anything less than a full scan. Hence, if a non-zero analysis limit is specified, the sqlite_stat4 table is not computed.</source>
          <target state="translated">sqlite_stat4表中的内容不能用少于完整扫描的方式来计算,因此,如果指定了非零的分析限制,sqlite_stat4表中的内容不会被计算。因此,如果指定了一个非零的分析限制,sqlite_stat4表就不会被计算。</target>
        </trans-unit>
        <trans-unit id="cbbe292e23fdc57896771b367c267746f39de5b7" translate="yes" xml:space="preserve">
          <source>The content of P3 registers starting at register P2 form an unpacked index key. This opcode removes that entry from the index opened by cursor P1.</source>
          <target state="translated">从寄存器P2开始的P3寄存器的内容形成一个未打包的索引键。这个操作码从光标P1打开的索引中删除该条目。</target>
        </trans-unit>
        <trans-unit id="53039aadd3f75ae33d382081b8b5f0e6fd60f4d6" translate="yes" xml:space="preserve">
          <source>The content of an R*Tree index is actually stored in three ordinary SQLite tables with names derived from the name of the R*Tree. These three tables are called &quot;&lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt;&quot;. This is their schema:</source>
          <target state="translated">R * Tree索引的内容实际上存储在三个普通的SQLite表中，其名称从R * Tree的名称派生。这三个表称为&amp;ldquo; &lt;a href=&quot;vtab#xshadowname&quot;&gt;影子表&lt;/a&gt; &amp;rdquo;。这是他们的模式：</target>
        </trans-unit>
        <trans-unit id="dd5b1eb070f31c8697b621bf1847b35fb7a8adaf" translate="yes" xml:space="preserve">
          <source>The content of each SQL table row is stored in the database file by first combining the values in the various columns into a byte array in the record format, then storing that byte array as the payload in an entry in the table b-tree. The order of values in the record is the same as the order of columns in the SQL table definition. When an SQL table includes an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column (which aliases the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;) then that column appears in the record as a NULL value. SQLite will always use the table b-tree key rather than the NULL value when referencing the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column.</source>
          <target state="translated">每个SQL表行的内容存储在数据库文件中，方法是首先将各个列中的值组合成记录格式的字节数组，然后将该字节数组作为有效负载存储在表b树中的条目中。记录中的值顺序与SQL表定义中的列顺序相同。当SQL表包含&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列（别名&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;）时，该列在记录中显示为NULL值。当引用&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列时，SQLite将始终使用表b-tree键而不是NULL值。</target>
        </trans-unit>
        <trans-unit id="71920b63c9e6445164e490bc0f251a06d6bb693f" translate="yes" xml:space="preserve">
          <source>The content of each rollback journal is flushed to disk both before and after the master journal filename is written into the rollback journal header. It is important to do both of these flushes. Fortunately, the second flush is usually inexpensive since typically only a single page of the journal file (the first page) has changed.</source>
          <target state="translated">在主日志文件名写入回滚日志头之前和之后,每个回滚日志的内容都会被刷新到磁盘上。进行这两次刷新是很重要的。幸运的是,第二次刷新的费用通常不高,因为通常只有日志文件的一页(第一页)发生了变化。</target>
        </trans-unit>
        <trans-unit id="2c74d571015e1e1c51708cccb3ac9a7ab08632cc" translate="yes" xml:space="preserve">
          <source>The content of each rollback journal is flushed to disk both before and after the super-journal filename is written into the rollback journal header. It is important to do both of these flushes. Fortunately, the second flush is usually inexpensive since typically only a single page of the journal file (the first page) has changed.</source>
          <target state="translated">在超级期刊文件名写入回滚期刊头之前和之后,每个回滚期刊的内容都会被刷新到磁盘上。进行这两次刷新是很重要的。幸运的是,第二次刷新的费用通常不高,因为通常只有单页的日记文件(第一页)发生了变化。</target>
        </trans-unit>
        <trans-unit id="39b372f8730aa69db1fd10c964b137259496c534" translate="yes" xml:space="preserve">
          <source>The content of each slide could still be stored as compressed XML. But now each page is stored separately. So when opening a new document, the application could simply run:</source>
          <target state="translated">每张幻灯片的内容仍然可以作为压缩的XML存储。但现在每个页面都是单独存储的。因此,当打开一个新文档时,应用程序可以简单地运行。</target>
        </trans-unit>
        <trans-unit id="ef2de54ba7f62420a379fc46c4ab7cf3080ae413" translate="yes" xml:space="preserve">
          <source>The content of the statistics tables can be queried using &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; and can be changed using the &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, and &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; commands. The &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; command works on statistics tables as of SQLite version 3.7.9. (2011-11-01) The &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command does not work on statistics tables. Appropriate care should be used when changing the content of the statistics tables as invalid content can cause SQLite to select inefficient query plans. Generally speaking, one should not modify the content of the statistics tables by any mechanism other than invoking the ANALYZE command. See &quot;&lt;a href=&quot;optoverview#manctrl&quot;&gt;Manual Control Of Query Plans Using SQLITE_STAT Tables&lt;/a&gt;&quot; for further information.</source>
          <target state="translated">可以使用&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;查询统计信息表的内容，也可以使用&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;，&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;和&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;命令对其进行更改。从SQLite版本3.7.9开始，&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;命令可用于统计表。 （2011-11-01）&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;命令不适用于统计信息表。更改统计信息表的内容时应格外小心，因为无效的内容会导致SQLite选择效率低的查询计划。一般而言，除了调用ANALYZE命令之外，不应通过任何机制来修改统计信息表的内容。有关更多信息，请参见&amp;ldquo; &lt;a href=&quot;optoverview#manctrl&quot;&gt;使用SQLITE_STAT表手动控制查询计划&lt;/a&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="cb0bc8e6cf7e707512464168a8333cd25f0f7228" translate="yes" xml:space="preserve">
          <source>The content option allows FTS4 to forego storing the text being indexed. The content option can be used in two ways:</source>
          <target state="translated">内容选项允许FTS4放弃存储被索引的文本。内容选项可以用两种方式使用。</target>
        </trans-unit>
        <trans-unit id="50fd4cd87f476ff7994844fe209f20e1e61a3e92" translate="yes" xml:space="preserve">
          <source>The content table may also be queried as follows:</source>
          <target state="translated">内容表也可按以下方式查询:</target>
        </trans-unit>
        <trans-unit id="43da535bae3bfe186441cea4bad1d427988c63d1" translate="yes" xml:space="preserve">
          <source>The contents of a changeset may be traversed using an iterator created using the &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; API. A changeset may be applied to a database with a compatible schema using the &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; API.</source>
          <target state="translated">可以使用使用&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt; API 创建的迭代器遍历变更集的内容。可以使用&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt; API 将变更集应用于具有兼容架构的数据库。</target>
        </trans-unit>
        <trans-unit id="d1fc4719b451a2f189cbf09b3af719ceaa1455fd" translate="yes" xml:space="preserve">
          <source>The contents of a changeset may be traversed using an iterator created using the &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; API. A changeset may be applied to a database with a compatible schema using the &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; API.</source>
          <target state="translated">可以使用使用&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt; API 创建的迭代器遍历变更集的内容。可以使用&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt; API 将变更集应用于具有兼容架构的数据库。</target>
        </trans-unit>
        <trans-unit id="17197a14b8f9ff583e2fbe7ec6a33d12aff2f981" translate="yes" xml:space="preserve">
          <source>The contents of an SQLite database file are formatted as a set of fixed size pages. See</source>
          <target state="translated">SQLite数据库文件的内容被格式化为一组固定大小的页面。参见</target>
        </trans-unit>
        <trans-unit id="6741b03ffce89c3a2ca3addb1cadccc791915ce5" translate="yes" xml:space="preserve">
          <source>The contents of columns qualified with the UNINDEXED column option are not added to the FTS index. This means that for the purposes of MATCH queries and &lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;FTS5 auxiliary functions&lt;/a&gt;, the column contains no matchable tokens.</source>
          <target state="translated">使用UNINDEXED column选项限定的列的内容不会添加到FTS索引中。这意味着出于MATCH查询和&lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;FTS5辅助功能&lt;/a&gt;的目的，该列不包含可匹配的标记。</target>
        </trans-unit>
        <trans-unit id="f4381b2c97365bdc1448864c183789c2d75a4c76" translate="yes" xml:space="preserve">
          <source>The contents of the logical full-text index is found by merging the contents of all segment b-trees. If a term is present in more than one segment b-tree, then it maps to the union of each individual doclist. If, for a single term, the same docid occurs in more than one doclist, then only the doclist that is part of the most recently created segment b-tree is considered valid.</source>
          <target state="translated">逻辑全文索引的内容是通过合并所有段b树的内容来找到的。如果一个术语出现在一个以上的段 b 树中,那么它就映射到每个单独的 doclist 的联合。如果一个术语在一个以上的 doclist 中出现了相同的 docid,那么只有属于最近创建的段 b 树的 doclist 才被认为是有效的。</target>
        </trans-unit>
        <trans-unit id="603ef17ea7e8b979fdc97587b739002125ee3a17" translate="yes" xml:space="preserve">
          <source>The contents of the sqlite3_pcache_methods2 structure are copied to an internal buffer by SQLite within the call to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;. Hence the application may discard the parameter after the call to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; returns.</source>
          <target state="translated">sqlite3_pcache_methods2结构的内容在调用&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config的过程中&lt;/a&gt;由SQLite复制到内部缓冲区。因此，在调用&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;返回之后，应用程序可能会丢弃该参数。</target>
        </trans-unit>
        <trans-unit id="d33c4566f4b0045dff066d31694e73d46d2bf6db" translate="yes" xml:space="preserve">
          <source>The contents of the sqlite3_pcache_methods2 structure are copied to an internal buffer by SQLite within the call to &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;. Hence the application may discard the parameter after the call to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; returns.</source>
          <target state="translated">sqlite3_pcache_methods2结构的内容在调用&lt;a href=&quot;config&quot;&gt;sqlite3_config的过程中&lt;/a&gt;由SQLite复制到内部缓冲区。因此，在调用&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;返回之后，应用程序可能会丢弃该参数。</target>
        </trans-unit>
        <trans-unit id="1e184948fbfc41a2f2c0c14809d37c70c80c03a2" translate="yes" xml:space="preserve">
          <source>The context in which an SQL function executes is stored in an sqlite3_context object. A pointer to an sqlite3_context object is always first parameter to &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;. The application-defined SQL function implementation will pass this pointer through into calls to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_get_auxdata()&lt;/a&gt;, and/or &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt;.</source>
          <target state="translated">执行SQL函数的上下文存储在sqlite3_context对象中。指向sqlite3_context对象的指针始终是&lt;a href=&quot;#sqlite3_create_function&quot;&gt;应用程序定义的SQL函数的&lt;/a&gt;第一个参数。应用程序定义的SQL函数实现会将此指针传递给对&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_aggregate_context&quot;&gt;sqlite3_aggregate_context（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_context_db_handle&quot;&gt;sqlite3_context_db_handle（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_get_auxdata（）&lt;/a&gt;和/或&lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_set_auxdata（）的&lt;/a&gt;调用。</target>
        </trans-unit>
        <trans-unit id="eb189ce529b8d7d0045783021bb7d8fd77526437" translate="yes" xml:space="preserve">
          <source>The context in which an SQL function executes is stored in an sqlite3_context object. A pointer to an sqlite3_context object is always first parameter to &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;. The application-defined SQL function implementation will pass this pointer through into calls to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result()&lt;/a&gt;, &lt;a href=&quot;aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;, &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;, &lt;a href=&quot;context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt;, &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_get_auxdata()&lt;/a&gt;, and/or &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt;.</source>
          <target state="translated">执行SQL函数的上下文存储在sqlite3_context对象中。指向sqlite3_context对象的指针始终是&lt;a href=&quot;../appfunc&quot;&gt;应用程序定义的SQL函数的&lt;/a&gt;第一个参数。应用程序定义的SQL函数实现将将此指针传递给对&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result（）&lt;/a&gt;，&lt;a href=&quot;aggregate_context&quot;&gt;sqlite3_aggregate_context（）&lt;/a&gt;，&lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data（）&lt;/a&gt;，&lt;a href=&quot;context_db_handle&quot;&gt;sqlite3_context_db_handle（）&lt;/a&gt;，&lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_get_auxdata（）&lt;/a&gt;和/或&lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_set_auxdata（）的&lt;/a&gt;调用。</target>
        </trans-unit>
        <trans-unit id="53fb8a37d043abdf36747b3ab57dd8a44c62d486" translate="yes" xml:space="preserve">
          <source>The context in which an SQL function executes is stored in an sqlite3_context object. A pointer to an sqlite3_context object is always first parameter to &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;. The application-defined SQL function implementation will pass this pointer through into calls to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_get_auxdata()&lt;/a&gt;, and/or &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt;.</source>
          <target state="translated">执行SQL函数的上下文存储在sqlite3_context对象中。指向sqlite3_context对象的指针始终是&lt;a href=&quot;appfunc&quot;&gt;应用程序定义的SQL函数的&lt;/a&gt;第一个参数。应用程序定义的SQL函数实现将将此指针传递给对&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_aggregate_context&quot;&gt;sqlite3_aggregate_context（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_context_db_handle&quot;&gt;sqlite3_context_db_handle（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_get_auxdata（）&lt;/a&gt;和/或&lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_set_auxdata（）的&lt;/a&gt;调用。</target>
        </trans-unit>
        <trans-unit id="f7c0cad9919ee775dcafe683809a8efa13aeacfd" translate="yes" xml:space="preserve">
          <source>The context in which an SQL function executes is stored in an sqlite3_context object. A pointer to an sqlite3_context object is always first parameter to &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;. The application-defined SQL function implementation will pass this pointer through into calls to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result()&lt;/a&gt;, &lt;a href=&quot;aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;, &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;, &lt;a href=&quot;context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt;, &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_get_auxdata()&lt;/a&gt;, and/or &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt;.</source>
          <target state="translated">执行SQL函数的上下文存储在sqlite3_context对象中。指向sqlite3_context对象的指针始终是&lt;a href=&quot;create_function&quot;&gt;应用程序定义的SQL函数的&lt;/a&gt;第一个参数。应用程序定义的SQL函数实现会将此指针传递给对&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result（）&lt;/a&gt;，&lt;a href=&quot;aggregate_context&quot;&gt;sqlite3_aggregate_context（）&lt;/a&gt;，&lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data（）&lt;/a&gt;，&lt;a href=&quot;context_db_handle&quot;&gt;sqlite3_context_db_handle（）&lt;/a&gt;，&lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_get_auxdata（）&lt;/a&gt;和/或&lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_set_auxdata（）的&lt;/a&gt;调用。</target>
        </trans-unit>
        <trans-unit id="2dc88bed6dbd7abe62664d54e6bdaf4f83cf04fb" translate="yes" xml:space="preserve">
          <source>The copy is edited to change the branch instruction into either a no-op or an unconditional jump.</source>
          <target state="translated">复制编辑后,将分支指令改为无条件跳转或无条件跳转。</target>
        </trans-unit>
        <trans-unit id="cb1935e51d150180f58869cd5c4365f67de7c57a" translate="yes" xml:space="preserve">
          <source>The copy method implements similar functionality to the &lt;b&gt;.import&lt;/b&gt; SQLite shell command.</source>
          <target state="translated">copy方法实现与&lt;b&gt;.import&lt;/b&gt; SQLite shell命令类似的功能。</target>
        </trans-unit>
        <trans-unit id="7d3c9b74d67dc166ca8e07aaa910e143f4d6cf96" translate="yes" xml:space="preserve">
          <source>The copy of sqlite3.s is assembled into sqlite3.o then linked again th3.o to generate the &quot;th3&quot; executable.</source>
          <target state="translated">sqlite3.s的副本被组装成sqlite3.o,然后再次链接th3.o,生成 &quot;th3 &quot;可执行文件。</target>
        </trans-unit>
        <trans-unit id="b047a98a10f78ed2613ab80ee6fd529ee912f70f" translate="yes" xml:space="preserve">
          <source>The core functions shown below are available by default. &lt;a href=&quot;lang_datefunc&quot;&gt;Date &amp;amp; Time functions&lt;/a&gt;, &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate functions&lt;/a&gt;, &lt;a href=&quot;windowfunctions#biwinfunc&quot;&gt;window functions&lt;/a&gt;, and &lt;a href=&quot;json1&quot;&gt;JSON functions&lt;/a&gt; are documented separately. An application may define additional functions written in C and added to the database engine using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; API.</source>
          <target state="translated">默认情况下，以下所示的核心功能可用。&lt;a href=&quot;lang_datefunc&quot;&gt;日期和时间函数&lt;/a&gt;，&lt;a href=&quot;lang_aggfunc&quot;&gt;聚合函数&lt;/a&gt;，&lt;a href=&quot;windowfunctions#biwinfunc&quot;&gt;窗口函数&lt;/a&gt;和&lt;a href=&quot;json1&quot;&gt;JSON函数&lt;/a&gt;分别记录。应用程序可以定义用C编写并使用&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt; API 添加到数据库引擎的其他函数。</target>
        </trans-unit>
        <trans-unit id="a7002ce76e139b64c91049472e1737291c84c664" translate="yes" xml:space="preserve">
          <source>The core idea is to create a special table (named &quot;UNDOLOG&quot; in the example) that holds information needed to undo/redo changes to the database. For each class (table) in the database that wants to participate in the undo/redo, triggers are created that cause entries to be made in the UNDOLOG table for each DELETE, INSERT, and UPDATE of the participating class. The UNDOLOG entries consist of ordinary SQL statements the can be played back to reverse the changes.</source>
          <target state="translated">核心思想是创建一个特殊的表(在示例中命名为 &quot;UNDOLOG&quot;),该表保存了撤销/重做对数据库的更改所需的信息。对于数据库中想要参与撤消/重做的每个类(表),创建触发器,使参与类的每次DELETE、INSERT和UPDATE都在UNDOLOG表中产生条目。UNDOLOG 条目由普通的 SQL 语句组成,可以回放这些语句以反转更改。</target>
        </trans-unit>
        <trans-unit id="b4619c14d9f61ffdd467d39188a12cbd3dab6b8b" translate="yes" xml:space="preserve">
          <source>The core of a SELECT statement is a &quot;simple SELECT&quot; shown by the &lt;a href=&quot;syntax/select-core&quot;&gt;select-core&lt;/a&gt; and &lt;a href=&quot;syntax/simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt; syntax diagrams below. In practice, most SELECT statements are simple SELECT statements.</source>
          <target state="translated">SELECT语句的核心是下面的&lt;a href=&quot;syntax/select-core&quot;&gt;select-core&lt;/a&gt;和&lt;a href=&quot;syntax/simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;语法图所示的&amp;ldquo;简单SELECT&amp;rdquo; 。实际上，大多数SELECT语句都是简单的SELECT语句。</target>
        </trans-unit>
        <trans-unit id="202f127cc642aea639fbf4c524ee9db3a310c986" translate="yes" xml:space="preserve">
          <source>The core query used to generate the branch timeline is shown below. (Readers are not expected to understand the details of this query. Commentary will follow.)</source>
          <target state="translated">用于生成分支时间线的核心查询如下所示。(希望读者不要理解这个查询的细节。后面会有评注)。)</target>
        </trans-unit>
        <trans-unit id="ca59f51d09381d1b3447776404c915b9169882ab" translate="yes" xml:space="preserve">
          <source>The core string formatting routine is the sqlite3VXPrintf() function found in the &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; source file. All the various interfaces invoke (sometimes indirectly) this one core function. The sqlite3VXPrintf() function began as code written by the first author of SQLite (&lt;a href=&quot;https://sqlite.org/crew.html&quot;&gt;Hipp&lt;/a&gt;) when he was a graduate student a Duke University in the late 1980s. Hipp kept this printf() implementation in his personal toolbox until he started working on SQLite in 2000. The code was incorporated into the SQLite source tree on &lt;a href=&quot;https://sqlite.org/src/timeline?c=f9372072a6&quot;&gt;2000-10-08&lt;/a&gt; for SQLite version 1.0.9.</source>
          <target state="translated">核心字符串格式化例程是在&lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt;源文件中找到的sqlite3VXPrintf（）函数。所有各种接口都调用（有时是间接调用）这一核心功能。 sqlite3VXPrintf（）函数最初是由SQLite的第一作者（&lt;a href=&quot;https://sqlite.org/crew.html&quot;&gt;Hipp&lt;/a&gt;）于1980年代末毕业于杜克大学（Duke University）时编写的代码。希普（Hipp）将此printf（）实现保留在他的个人工具箱中，直到2000年开始使用SQLite为止。该代码已在&lt;a href=&quot;https://sqlite.org/src/timeline?c=f9372072a6&quot;&gt;2000-10-08&lt;/a&gt;合并到SQLite 1.0.9版的SQLite源代码树中。</target>
        </trans-unit>
        <trans-unit id="093b78a42e1ecfed114ac694aeda4be18d47e5e9" translate="yes" xml:space="preserve">
          <source>The cost table can be named anything you want - it does not have to be called &quot;editcost&quot;. And the table can contain additional columns. The only requirement is that the table must contain the four columns show above, with exactly the names shown.</source>
          <target state="translated">成本表可以用任何你想用的名字--不一定要叫 &quot;editcost&quot;。而且该表可以包含额外的列。唯一的要求是该表必须包含上面所示的四列,而且名称必须与上面所示的相同。</target>
        </trans-unit>
        <trans-unit id="ab3b915916ad100c2de3d193cbc3d8e54968ac9c" translate="yes" xml:space="preserve">
          <source>The costs are comprised of multiple numbers, not a single number as shown in the graph. SQLite computes several different estimated costs for each loop that apply at different times. For example, there is a &quot;setup&quot; cost that is incurred just once when the query starts. The setup cost is the cost of computing an &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic index&lt;/a&gt; for a table that does not already have an index. Then there is the cost of running each step of the loop. Finally, there is an estimate of the number rows generated by the loop, which is information needed in estimating the costs of inner loops. Sorting costs may come into play if the query has an ORDER BY clause.</source>
          <target state="translated">成本由多个数字组成，而不是如图所示的单个数字。 SQLite为在不同时间应用的每个循环计算几种不同的估计成本。例如，查询开始时仅产生一次&amp;ldquo;设置&amp;rdquo;成本。设置成本是为还没有&lt;a href=&quot;optoverview#autoindex&quot;&gt;索引&lt;/a&gt;的表计算自动索引的成本。然后就有了运行循环每个步骤的成本。最后，对循环产生的行数进行估算，这是估算内部循环成本所需的信息。如果查询具有ORDER BY子句，则排序成本可能会起作用。</target>
        </trans-unit>
        <trans-unit id="19bc3b9522f26a7b0a814b17b06d2223be3c56f5" translate="yes" xml:space="preserve">
          <source>The count(X) function returns a count of the number of times that</source>
          <target state="translated">函数count(X)返回该函数的次数。</target>
        </trans-unit>
        <trans-unit id="8e9bf7bdd6a7e80adbfe374cd14df21073d0a490" translate="yes" xml:space="preserve">
          <source>The countStep() callback is invoked once for each row in the aggregate. As you can see, the count is incremented if either there are no arguments, or if the one argument is not NULL.</source>
          <target state="translated">countStep()回调对集合中的每一行都会被调用一次。正如你所看到的,如果没有参数,或者如果一个参数不是NULL,则计数会递增。</target>
        </trans-unit>
        <trans-unit id="e3944d86225bf50f66350ca2264ab4a84abeb87d" translate="yes" xml:space="preserve">
          <source>The cov1 test set used to obtain 100% branch test coverage are only a subset of the tests currently implemented using TH3. New test modules are added on a regular basis.</source>
          <target state="translated">用于获得100%分支测试覆盖率的cov1测试集只是目前使用TH3实现的测试的一个子集。新的测试模块会定期增加。</target>
        </trans-unit>
        <trans-unit id="d677c2d682d4dade2e8fc2faf6167d79dbe61f08" translate="yes" xml:space="preserve">
          <source>The crash tests in SQLite have discovered a number of very subtle bugs (now fixed) in the recovery mechanism. Some of these bugs were very obscure and unlikely to have been found using only code inspection and analysis techniques. From this experience, the developers of SQLite feel confident that any other database system that does not use a similar crash test system likely contains undetected bugs that will lead to database corruption following a system crash or power failure.</source>
          <target state="translated">SQLite中的崩溃测试发现了恢复机制中的一些非常细微的bug(现已修复)。其中有些bug非常隐蔽,只用代码检查和分析技术不太可能发现。从这一经验来看,SQLite的开发者们确信,任何其他没有使用类似崩溃测试系统的数据库系统很可能包含了未被发现的bug,这些bug将导致系统崩溃或断电后的数据库损坏。</target>
        </trans-unit>
        <trans-unit id="33ac0d26d4e9c7d412c89e095055cacaebdbb563" translate="yes" xml:space="preserve">
          <source>The cumulative distribution. Calculated as</source>
          <target state="translated">累计分布。计算方法为</target>
        </trans-unit>
        <trans-unit id="9f3f4c9ed1a83693cad288a8dbbe975dd262d497" translate="yes" xml:space="preserve">
          <source>The current implementation of SQLite uses only loop joins. That is to say, joins are implemented as nested loops.</source>
          <target state="translated">目前SQLite的实现只使用循环连接。也就是说,连接是以嵌套循环的方式实现的。</target>
        </trans-unit>
        <trans-unit id="0595dd468ba4f2594b89c18514e0ce47ff0d0c46" translate="yes" xml:space="preserve">
          <source>The current implementation of this JSON library uses a recursive descent parser. In order to avoid using excess stack space, any JSON input that has more than 2000 levels of nesting is considered invalid. Limits on nesting depth are allowed for compatible implementations of JSON by &lt;a href=&quot;https://tools.ietf.org/html/rfc7159#section-9&quot;&gt;RFC-7159 section 9&lt;/a&gt;.</source>
          <target state="translated">该JSON库的当前实现使用递归下降解析器。为了避免使用过多的堆栈空间，任何具有超过2000个嵌套级别的JSON输入都被视为无效。&lt;a href=&quot;https://tools.ietf.org/html/rfc7159#section-9&quot;&gt;RFC-7159第9节&lt;/a&gt;允许对JSON的兼容实现进行嵌套深度限制。</target>
        </trans-unit>
        <trans-unit id="1859423b8976d8bfae8dfc344c1935671c660093" translate="yes" xml:space="preserve">
          <source>The current implementation will only support a string or BLOB length up to 2&lt;small&gt;&lt;sup&gt;31&lt;/sup&gt;&lt;/small&gt;-1 or 2147483647. And some built-in functions such as hex() might fail well before that point. In security-sensitive applications it is best not to try to increase the maximum string and blob length. In fact, you might do well to lower the maximum string and blob length to something more in the range of a few million if that is possible.</source>
          <target state="translated">当前实现仅支持最大2 &lt;small&gt;&lt;sup&gt;31&lt;/sup&gt;&lt;/small&gt; -1或2147483647 的字符串或BLOB长度。某些内置函数（例如hex（））可能在此之前就失败了。在对安全性敏感的应用程序中，最好不要尝试增加最大字符串和blob长度。实际上，如果可能的话，最好将最大字符串长度和blob长度减小到几百万。</target>
        </trans-unit>
        <trans-unit id="ce671671108a214d3061700585cfbe08230e46de" translate="yes" xml:space="preserve">
          <source>The current row. For RANGE and GROUPS frame types, peers of the current row are also included in the frame, unless specifically excluded by the EXCLUDE clause. This is true regardless of whether CURRENT ROW is used as the starting or ending frame boundary.</source>
          <target state="translated">当前行。对于RANGE和GROUPS帧类型,除非EXCLUDE子句特别排除,否则当前行的对等体也包含在帧中。无论CURRENT ROW是作为帧的起始或结束边界,这一点都是正确的。</target>
        </trans-unit>
        <trans-unit id="bd2930f3fd3f6f19fc9ada96c54055098b67532e" translate="yes" xml:space="preserve">
          <source>The current value of the requested parameter is written into *pCur and the highest instantaneous value is written into *pHiwtr. If the resetFlg is true, then the highest instantaneous value is reset back down to the current value.</source>
          <target state="translated">请求参数的当前值被写入*pCur,最高瞬时值被写入*pHiwtr。如果resetFlg为true,那么最高瞬时值将被重置为当前值。</target>
        </trans-unit>
        <trans-unit id="b3c10a59b750c785e72b4dc21d7b05d270490210" translate="yes" xml:space="preserve">
          <source>The current working directory (&quot;.&quot;)</source>
          <target state="translated">当前工作目录(&quot;.&quot;)</target>
        </trans-unit>
        <trans-unit id="34c8be248703e890d36c7a3af0b628d68ce8275b" translate="yes" xml:space="preserve">
          <source>The current writer concludes its transaction, OR</source>
          <target state="translated">当前作者结束其交易,OR</target>
        </trans-unit>
        <trans-unit id="d429ef679ef6041cdac168ab25fbc584b8f7c9d4" translate="yes" xml:space="preserve">
          <source>The cycle above can be repeated many times. The diagram shows a third SQLite release, 3.6.17 in circle (6). The private branch maintainer can do another merge in order to incorporate the changes moving from (4) to (6) into the private branch, resulting in version (7).</source>
          <target state="translated">以上循环可以重复多次。图中显示了第三个SQLite版本,即圆圈(6)中的3.6.17。私有分支的维护者可以再做一次合并,以便将从(4)到(6)的变化纳入私有分支,从而得到(7)版本。</target>
        </trans-unit>
        <trans-unit id="8810808ac8350e84a24599fba1a1c44e6d0fc9da" translate="yes" xml:space="preserve">
          <source>The cycle counts provided by cachegrind are a good proxy for actual performance, but they are not 100% accurate.</source>
          <target state="translated">cachegrind提供的周期数是实际性能的良好代表,但它们并不是100%准确。</target>
        </trans-unit>
        <trans-unit id="fac9319a6ade67af6ca8dc4d7c432433a5c8d584" translate="yes" xml:space="preserve">
          <source>The data and method columns may also be set as described for an INSERT above.</source>
          <target state="translated">数据列和方法列也可以像上面的INSERT那样进行设置。</target>
        </trans-unit>
        <trans-unit id="062b3a0f8f6a4c6911f0379b0878b031acaf0a51" translate="yes" xml:space="preserve">
          <source>The data for a table b-tree leaf page and the key of an index b-tree page was characterized above as an arbitrary sequence of bytes. The prior discussion mentioned one key being less than another, but did not define what &quot;less than&quot; meant. The current section will address these omissions.</source>
          <target state="translated">表b树叶页的数据和索引b树页的键在上面被描述为一个任意的字节序列。前面的讨论提到一个键小于另一个键,但没有定义 &quot;小于 &quot;的含义。本节将解决这些遗漏。</target>
        </trans-unit>
        <trans-unit id="b9c10539b9c59116b81ff7089713236e6e1327e8" translate="yes" xml:space="preserve">
          <source>The data for rowid tables is stored as a B-Tree structure containing one entry for each table row, using the rowid value as the key. This means that retrieving or sorting records by rowid is fast. Searching for a record with a specific rowid, or for all records with rowids within a specified range is around twice as fast as a similar search made by specifying any other PRIMARY KEY or indexed value.</source>
          <target state="translated">rowid表的数据以B-Tree结构存储,每个表行有一个条目,使用rowid值作为键。这意味着通过rowid来检索或排序记录是非常快速的。搜索具有特定rowid的记录,或者搜索在指定范围内具有rowid的所有记录,其速度大约是通过指定任何其他主键或索引值进行类似搜索的两倍。</target>
        </trans-unit>
        <trans-unit id="8f8b09e33f29c0f7e2cdc53d761f0421d3f8a545" translate="yes" xml:space="preserve">
          <source>The data_% table must have all the same columns as the target table, plus one additional column named &quot;rbu_control&quot;. The data_% table should have no PRIMARY KEY or UNIQUE constraints, but each column should have the same type as the corresponding column in the target database. The rbu_control column should have no type at all. For example, if the target database contains:</source>
          <target state="translated">data_%表必须拥有与目标表相同的所有列,外加一个名为 &quot;rbu_control &quot;的附加列。data_%表不应该有PRIMARY KEY或UNIQUE约束,但每一列应该与目标数据库中的相应列有相同的类型。rbu_control列应该完全没有类型。例如,如果目标数据库中包含。</target>
        </trans-unit>
        <trans-unit id="17bee7a4a210b94f9cd35ef19e344d890d514950" translate="yes" xml:space="preserve">
          <source>The data_% tables may be created as follows:</source>
          <target state="translated">data_%表的创建方法如下。</target>
        </trans-unit>
        <trans-unit id="d8fc42980131b74512111cf667ced537b6faec1f" translate="yes" xml:space="preserve">
          <source>The data_% tables themselves should have no PRIMARY KEY declarations. However, RBU is more efficient if reading the rows in from each data_% table in &quot;rowid&quot; order is roughly the same as reading them sorted by the PRIMARY KEY of the corresponding target database table. In other words, rows should be sorted using the destination table PRIMARY KEY fields before they are inserted into the data_% tables.</source>
          <target state="translated">data_%表本身不应该有PRIMARY KEY的声明。但是,如果按照 &quot;rowid &quot;的顺序从每个data_%表中读入的行,与按照对应的目标数据库表的PRIMARY KEY排序读入的行大致相同,那么RBU的效率会更高。换句话说,在将行插入data_%表之前,应该使用目标表的primary key字段进行排序。</target>
        </trans-unit>
        <trans-unit id="0e861495335228dd9715b8957c822d148379befb" translate="yes" xml:space="preserve">
          <source>The data_ccc table may then be populated as normal with the updates intended for target database table ccc. The same updates will be read by RBU from the data0_ccc_fts view and applied to FTS table ccc_fts. Because &quot;data0_ccc_fts&quot; is smaller than &quot;data_ccc&quot;, the FTS table will be updated first, as required.</source>
          <target state="translated">然后,data_ccc表可以像正常情况一样,用目标数据库表ccc的更新来填充。RBU将从data0_ccc_fts视图中读取同样的更新,并应用到FTS表ccc_fts中。因为 &quot;data0_ccc_fts &quot;比 &quot;data_ccc &quot;小,所以根据需要,FTS表将首先被更新。</target>
        </trans-unit>
        <trans-unit id="7a9df4aba808f0f7f287daab1202c053d1ad5c81" translate="yes" xml:space="preserve">
          <source>The database being vacuumed may not be in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">正在清理的数据库可能未处于&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d1f84e31daf7f78443fa69ada7a9a8e535388ab9" translate="yes" xml:space="preserve">
          <source>The database connection can be changed between full and incremental autovacuum mode at any time. However, changing from &quot;none&quot; to &quot;full&quot; or &quot;incremental&quot; can only occur when the database is new (no tables have yet been created) or by running the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. To change auto-vacuum modes, first use the auto_vacuum pragma to set the new desired mode, then invoke the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command to reorganize the entire database file. To change from &quot;full&quot; or &quot;incremental&quot; back to &quot;none&quot; always requires running &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; even on an empty database.</source>
          <target state="translated">可以随时在完全自动和增量自动真空模式之间更改数据库连接。但是，只有在数据库是新数据库（尚未创建表）或通过运行&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令时，才可以从&amp;ldquo;无&amp;rdquo;更改为&amp;ldquo;完整&amp;rdquo;或&amp;ldquo;增量&amp;rdquo; 。要更改自动真空模式，请首先使用auto_vacuum编译指示来设置新的所需模式，然后调用&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令重新组织整个数据库文件。要从&amp;ldquo;完全&amp;rdquo;或&amp;ldquo;增量&amp;rdquo;变回&amp;ldquo;无&amp;rdquo;，即使在空数据库上也始终需要运行&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3e8669da1288d64c48a1d4da77efa2cfbe93e717" translate="yes" xml:space="preserve">
          <source>The database connection is opened using the &lt;a href=&quot;uri#uriimmutable&quot;&gt;immutable query parameter&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;uri#uriimmutable&quot;&gt;不可变查询参数&lt;/a&gt;打开数据库连接。</target>
        </trans-unit>
        <trans-unit id="17dc502f4a596e5beade9b059c41722a7380dd5f" translate="yes" xml:space="preserve">
          <source>The database file format is unchanged for WAL mode. However, the WAL file and the &lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt; are new concepts and so older versions of SQLite will not know how to recover a crashed SQLite database that was operating in WAL mode when the crash occurred. To prevent older versions of SQLite (prior to version 3.7.0, 2010-07-22) from trying to recover a WAL-mode database (and making matters worse) the database file format version numbers (bytes 18 and 19 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;) are increased from 1 to 2 in WAL mode. Thus, if an older version of SQLite attempts to connect to an SQLite database that is operating in WAL mode, it will report an error along the lines of &quot;file is encrypted or is not a database&quot;.</source>
          <target state="translated">对于WAL模式，数据库文件格式不变。但是，WAL文件和&lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt;是新概念，因此旧版本的SQLite将不知道如何在发生崩溃时恢复在WAL模式下运行的崩溃的SQLite数据库。为了防止旧版本的SQLite（3.7.0之前的版本，2010-07-22）尝试恢复WAL模式数据库（并使情况更糟）数据库文件格式的版本号（&lt;a href=&quot;fileformat2#database_header&quot;&gt;数据库头&lt;/a&gt;中的字节18和19））在WAL模式下从1增加到2。因此，如果旧版本的SQLite尝试连接到以WAL模式运行的SQLite数据库，它将报告&amp;ldquo;文件已加密或不是数据库&amp;rdquo;的错误。</target>
        </trans-unit>
        <trans-unit id="9c1329ad6c1d5d5a9b13da19601459b465ae67ba" translate="yes" xml:space="preserve">
          <source>The database file format is unchanged.</source>
          <target state="translated">数据库文件格式不变。</target>
        </trans-unit>
        <trans-unit id="1d07edfc3d0d439a4f2d02bad68d889bf985841b" translate="yes" xml:space="preserve">
          <source>The database file header</source>
          <target state="translated">数据库文件头</target>
        </trans-unit>
        <trans-unit id="042540519692f217502c3ae945ec1187e2e057d0" translate="yes" xml:space="preserve">
          <source>The database file is synced to ensure that all updates are stored safely on the persistent media.</source>
          <target state="translated">数据库文件是同步的,以确保所有更新都安全地存储在持久性介质上。</target>
        </trans-unit>
        <trans-unit id="e23d0cd874d4749bf56cbe1f6d077df68f5dc7f5" translate="yes" xml:space="preserve">
          <source>The database file is unlocked.</source>
          <target state="translated">数据库文件被解锁。</target>
        </trans-unit>
        <trans-unit id="0b3f3d4ba2117afe864ef2e2e3855b3dd6cb1ace" translate="yes" xml:space="preserve">
          <source>The database filename is not allowed to be a symbolic link</source>
          <target state="translated">数据库文件名不允许是符号链接</target>
        </trans-unit>
        <trans-unit id="6f5b1b36f625c53227300ca5232e63d1f84ef897" translate="yes" xml:space="preserve">
          <source>The database for TEMP tables is not created until it is needed.</source>
          <target state="translated">腾博会登录表的数据库直到需要时才会创建。</target>
        </trans-unit>
        <trans-unit id="0bdbc9610964d617ffff9c05691c3e95d705203e" translate="yes" xml:space="preserve">
          <source>The database handle must not be in &lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;autocommit mode&lt;/a&gt;.</source>
          <target state="translated">数据库句柄不得处于&lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;自动提交模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94abbac71c91061eed5db3642683f70b586a784a" translate="yes" xml:space="preserve">
          <source>The database handle must not be in &lt;a href=&quot;get_autocommit&quot;&gt;autocommit mode&lt;/a&gt;.</source>
          <target state="translated">数据库句柄不得处于&lt;a href=&quot;get_autocommit&quot;&gt;自动提交模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="915d44defd987e4d007442eec15de7482af138fa" translate="yes" xml:space="preserve">
          <source>The database in which the new table is created. Tables may be created in the main database, the temp database, or in any attached database.</source>
          <target state="translated">创建新表的数据库。可以在主数据库、临时数据库或任何附属数据库中创建表。</target>
        </trans-unit>
        <trans-unit id="f11c35a2d4a1cdd518b7cc45f596b046478c935a" translate="yes" xml:space="preserve">
          <source>The database is modified by the transaction</source>
          <target state="translated">数据库是通过事务来修改的</target>
        </trans-unit>
        <trans-unit id="a60dcb2504ad2ca1f013e489bb243d5fba664847" translate="yes" xml:space="preserve">
          <source>The database is opened &lt;a href=&quot;../sharedcache&quot;&gt;shared cache&lt;/a&gt; disabled, overriding the default shared cache setting provided by &lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;.</source>
          <target state="translated">打开数据库时禁用了&lt;a href=&quot;../sharedcache&quot;&gt;共享缓存&lt;/a&gt;，将覆盖&lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）&lt;/a&gt;提供的默认共享缓存设置。</target>
        </trans-unit>
        <trans-unit id="4eaa608858923b8628e324d3b5e39f5d6ac0b6e8" translate="yes" xml:space="preserve">
          <source>The database is opened &lt;a href=&quot;../sharedcache&quot;&gt;shared cache&lt;/a&gt; enabled, overriding the default shared cache setting provided by &lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;.</source>
          <target state="translated">打开数据库后，启用了&lt;a href=&quot;../sharedcache&quot;&gt;共享缓存&lt;/a&gt;，将覆盖&lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）&lt;/a&gt;提供的默认共享缓存设置。</target>
        </trans-unit>
        <trans-unit id="438e6e4f2464e93327c1c43679960b9033bba769" translate="yes" xml:space="preserve">
          <source>The database is opened &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; disabled, overriding the default shared cache setting provided by &lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;.</source>
          <target state="translated">打开数据库时禁用了&lt;a href=&quot;sharedcache&quot;&gt;共享缓存&lt;/a&gt;，将覆盖&lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）&lt;/a&gt;提供的默认共享缓存设置。</target>
        </trans-unit>
        <trans-unit id="2866aa5f974824c8ab6f079d70d8228fd2d735a8" translate="yes" xml:space="preserve">
          <source>The database is opened &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; enabled, overriding the default shared cache setting provided by &lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;.</source>
          <target state="translated">打开数据库后，启用了&lt;a href=&quot;sharedcache&quot;&gt;共享缓存&lt;/a&gt;，将覆盖&lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）&lt;/a&gt;提供的默认共享缓存设置。</target>
        </trans-unit>
        <trans-unit id="0ca1bec50c05a4f92423e17a029876db2e2195fa" translate="yes" xml:space="preserve">
          <source>The database is opened for reading and writing if possible, or reading only if the file is write protected by the operating system. In either case the database must already exist, otherwise an error is returned.</source>
          <target state="translated">如果可能的话,数据库会被打开进行读写,如果文件受到操作系统的写保护,则只读。在这两种情况下,数据库必须已经存在,否则将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="9bd4a4b6de8565a3e1cf815b4bc5b9706070cf17" translate="yes" xml:space="preserve">
          <source>The database is opened for reading and writing, and is created if it does not already exist. This is the behavior that is always used for sqlite3_open() and sqlite3_open16().</source>
          <target state="translated">打开数据库进行读写,如果数据库还不存在,则创建数据库。这是sqlite3_open()和sqlite3_open16()一直使用的行为。</target>
        </trans-unit>
        <trans-unit id="e33053c4558a1f3729067b3cae6e30d0b922d25b" translate="yes" xml:space="preserve">
          <source>The database is opened in read-only mode. If the database does not already exist, an error is returned.</source>
          <target state="translated">数据库以只读模式打开。如果数据库不存在,则返回错误。</target>
        </trans-unit>
        <trans-unit id="c36f905350b3694fef2e907f7076bd6c0eb07bcf" translate="yes" xml:space="preserve">
          <source>The database may be read but not written. Any number of processes can hold SHARED locks at the same time, hence there can be many simultaneous readers. But no other thread or process is allowed to write to the database file while one or more SHARED locks are active.</source>
          <target state="translated">数据库可以被读,但不能被写。任何数量的进程都可以同时持有SHARED锁,因此可以有很多人同时读。但当一个或多个SHARED锁处于活动状态时,不允许其他线程或进程向数据库文件写入。</target>
        </trans-unit>
        <trans-unit id="2cc9e66b5c02e09e5ad16f7b64822b0c58495bb9" translate="yes" xml:space="preserve">
          <source>The database page size in bytes, or 1 if the page size is 65536.</source>
          <target state="translated">数据库页面大小,单位为字节,如果页面大小为65536,则为1。</target>
        </trans-unit>
        <trans-unit id="8a5fb001456adc96d15706d6924ffd2f301ed99f" translate="yes" xml:space="preserve">
          <source>The database page size in bytes. Must be a power of two between 512 and 32768 inclusive, or the value 1 representing a page size of 65536.</source>
          <target state="translated">数据库页面大小,以字节为单位,必须是512到32768之间的2次幂,或者1代表页面大小为65536。必须是512和32768(含)之间的2次幂,或者1代表65536的页面大小。</target>
        </trans-unit>
        <trans-unit id="960363c84d760f550ea9fae647b23fad91849f93" translate="yes" xml:space="preserve">
          <source>The database schema (in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table) is not normally included in the hash, but can be added by the &quot;--schema&quot; option.</source>
          <target state="translated">数据库模式（在&lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt;表中）通常不包括在哈希中，但是可以通过&amp;ldquo; --schema&amp;rdquo;选项添加。</target>
        </trans-unit>
        <trans-unit id="14a6eadb07a326767237571a6c459f7de69f6f90" translate="yes" xml:space="preserve">
          <source>The database schema (in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; table) is not normally included in the hash, but can be added by the &quot;--schema&quot; option.</source>
          <target state="translated">数据库模式（在&lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt;表中）通常不包括在哈希中，但是可以通过&amp;ldquo; --schema&amp;rdquo;选项添加。</target>
        </trans-unit>
        <trans-unit id="8594a821095f6391744d60f5433b9311564cee65" translate="yes" xml:space="preserve">
          <source>The database text encoding. A value of 1 means UTF-8. A value of 2 means UTF-16le. A value of 3 means UTF-16be.</source>
          <target state="translated">数据库文本编码。值为1表示UTF-8,值为2表示UTF-16le。值为2表示UTF-16le。值为3表示UTF-16be。</target>
        </trans-unit>
        <trans-unit id="e0c8f6d94e8860f110aff3d0dcf3dec439a12ec1" translate="yes" xml:space="preserve">
          <source>The database will be opened as an in-memory database. The database is named by the &quot;filename&quot; argument for the purposes of cache-sharing, if shared cache mode is enabled, but the &quot;filename&quot; is otherwise ignored.</source>
          <target state="translated">数据库将作为内存数据库打开。如果启用了共享缓存模式,数据库将以 &quot;文件名 &quot;参数命名,用于缓存共享,但 &quot;文件名 &quot;将被忽略。</target>
        </trans-unit>
        <trans-unit id="d24a19630de1f62dd0aa22d7bd05ac2f4445ed6a" translate="yes" xml:space="preserve">
          <source>The datatype and &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; of the generated column are determined only by the datatype and &lt;a href=&quot;lang_createtable#collateclause&quot;&gt;COLLATE clause&lt;/a&gt; on the column definition. The datatype and collating sequence of the GENERATED ALWAYS AS expression have no affect on the datatype and collating sequence of the column itself.</source>
          <target state="translated">生成的列的数据类型和&lt;a href=&quot;datatype3#collation&quot;&gt;排序顺序&lt;/a&gt;仅由列定义上的数据类型和&lt;a href=&quot;lang_createtable#collateclause&quot;&gt;COLLATE子句&lt;/a&gt;确定。 GENERATED ALWAYS AS表达式的数据类型和整理顺序对列本身的数据类型和整理顺序没有影响。</target>
        </trans-unit>
        <trans-unit id="8474bd3b47622066afeb4b46c5b6be93034d3e7c" translate="yes" xml:space="preserve">
          <source>The datatype of columns now appear in the 4th argument to the callback.</source>
          <target state="translated">列的数据类型现在出现在回调的第4个参数中。</target>
        </trans-unit>
        <trans-unit id="aa9bbe0be9ce7cff21329528d0726ee0baa77cf6" translate="yes" xml:space="preserve">
          <source>The date and time functions use a subset of &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601&quot;&gt;IS0-8601&lt;/a&gt; date and time formats. The date() function returns the date in this format: YYYY-MM-DD. The time() function returns the time as HH:MM:SS. The datetime() function returns &quot;YYYY-MM-DD HH:MM:SS&quot;. The julianday() function returns the &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day&lt;/a&gt; - the number of days since noon in Greenwich on November 24, 4714 B.C. (&lt;a href=&quot;http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar&quot;&gt;Proleptic Gregorian calendar&lt;/a&gt;). The strftime() routine returns the date formatted according to the format string specified as the first argument. The format string supports the most common substitutions found in the &lt;a href=&quot;http://opengroup.org/onlinepubs/007908799/xsh/strftime.html&quot;&gt;strftime() function&lt;/a&gt; from the standard C library plus two new substitutions, %f and %J. The following is a complete list of valid strftime() substitutions:</source>
          <target state="translated">日期和时间函数使用&lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601&quot;&gt;IS0-8601日期和时间格式的子集&lt;/a&gt;。 date（）函数以以下格式返回日期：YYYY-MM-DD。 time（）函数将时间返回为HH：MM：SS。 datetime（）函数返回&amp;ldquo; YYYY-MM-DD HH：MM：SS&amp;rdquo;。 julianday（）函数返回&lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;儒略日&lt;/a&gt; -公元前4714年11月24日（格林尼治&lt;a href=&quot;http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar&quot;&gt;公历&lt;/a&gt;）自格林威治中午以来的天数。 strftime（）例程返回根据指定为第一个参数的格式字符串格式化的日期。格式字符串支持在标准C库的&lt;a href=&quot;http://opengroup.org/onlinepubs/007908799/xsh/strftime.html&quot;&gt;strftime（）函数中&lt;/a&gt;找到的最常见替换，以及两个新替换％f和％J。以下是有效的strftime（）替换的完整列表：</target>
        </trans-unit>
        <trans-unit id="c572eaac3cc998a669390ba9b1ca1c2cef313090" translate="yes" xml:space="preserve">
          <source>The date and time functions use a subset of &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;IS0-8601&lt;/a&gt; date and time formats. The date() function returns the date in this format: YYYY-MM-DD. The time() function returns the time as HH:MM:SS. The datetime() function returns &quot;YYYY-MM-DD HH:MM:SS&quot;. The julianday() function returns the &lt;a href=&quot;https://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day&lt;/a&gt; - the number of days since noon in Greenwich on November 24, 4714 B.C. (&lt;a href=&quot;https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar&quot;&gt;Proleptic Gregorian calendar&lt;/a&gt;). The strftime() routine returns the date formatted according to the format string specified as the first argument. The format string supports the most common substitutions found in the &lt;a href=&quot;https://opengroup.org/onlinepubs/007908799/xsh/strftime.html&quot;&gt;strftime() function&lt;/a&gt; from the standard C library plus two new substitutions, %f and %J. The following is a complete list of valid strftime() substitutions:</source>
          <target state="translated">日期和时间功能使用&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;IS0-8601日期和时间格式的子集&lt;/a&gt;。 date（）函数以以下格式返回日期：YYYY-MM-DD。 time（）函数将时间返回为HH：MM：SS。 datetime（）函数返回&amp;ldquo; YYYY-MM-DD HH：MM：SS&amp;rdquo;。 julianday（）函数返回&lt;a href=&quot;https://en.wikipedia.org/wiki/Julian_day&quot;&gt;儒略日&lt;/a&gt;（Julian day） -公元前4714年11月24日（格林尼治&lt;a href=&quot;https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar&quot;&gt;公历&lt;/a&gt;）自格林威治中午以来的天数。 strftime（）例程返回根据指定为第一个参数的格式字符串设置格式的日期。格式字符串支持标准C库中&lt;a href=&quot;https://opengroup.org/onlinepubs/007908799/xsh/strftime.html&quot;&gt;strftime（）函数中&lt;/a&gt;最常见的替换，以及两个新的替换％f和％J。以下是有效的strftime（）替换的完整列表：</target>
        </trans-unit>
        <trans-unit id="41f51b9af9bc71b6bb1cc99119d6849c39b622ad" translate="yes" xml:space="preserve">
          <source>The db parameter is a pointer to the SQLite &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; that is executing the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. The pAux argument is the copy of the client data pointer that was the fourth argument to the &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; call that registered the &lt;a href=&quot;c3ref/module&quot;&gt;virtual table module&lt;/a&gt;. The argv parameter is an array of argc pointers to null terminated strings. The first string, argv[0], is the name of the module being invoked. The module name is the name provided as the second argument to &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; and as the argument to the USING clause of the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement that is running. The second, argv[1], is the name of the database in which the new virtual table is being created. The database name is &quot;main&quot; for the primary database, or &quot;temp&quot; for TEMP database, or the name given at the end of the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for attached databases. The third element of the array, argv[2], is the name of the new virtual table, as specified following the TABLE keyword in the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. If present, the fourth and subsequent strings in the argv[] array report the arguments to the module name in the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement.</source>
          <target state="translated">db参数是指向执行&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;语句的SQLite &lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;的指针。 pAux参数是客户端数据指针的副本，该指针是注册&lt;a href=&quot;c3ref/module&quot;&gt;虚拟表模块&lt;/a&gt;的&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module（）&lt;/a&gt;或&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2（）&lt;/a&gt;调用的第四个参数。 argv参数是指向空终止字符串的argc指针的数组。第一个字符串argv [0]是所调用模块的名称。模块名称是作为&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module（）&lt;/a&gt;的第二个参数以及&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;的USING子句的参数提供的名称。正在运行的语句。第二个参数argv [1]是在其中创建新虚拟表的数据库的名称。对于主数据库，数据库名称为&amp;ldquo; main&amp;rdquo;，对于TEMP数据库，数据库名称为&amp;ldquo; temp&amp;rdquo;，对于连接的数据库，数据库名称为&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;语句末尾给出的名称。数组的第三个元素argv [2]是新虚拟表的名称，在&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;语句中的TABLE关键字之后指定。如果存在，则argv []数组中的第四个及后续字符串将在&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;语句中向模块名称报告参数。</target>
        </trans-unit>
        <trans-unit id="f728f7217f7fc88bd0e8e8228a6a594400b21afc" translate="yes" xml:space="preserve">
          <source>The dbhash program is implemented by a single file of C-code called &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=tool/dbhash.c&quot;&gt;dbhash.c&lt;/a&gt;. To build the dbhash program manually, simply compile the dbhash.c source file and link it against the SQLite library.</source>
          <target state="translated">dbhash程序由一个名为&lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=tool/dbhash.c&quot;&gt;dbhash.c&lt;/a&gt;的C代码文件实现。要手动构建dbhash程序，只需编译dbhash.c源文件并将其链接到SQLite库即可。</target>
        </trans-unit>
        <trans-unit id="b16703d23a9ca6a2a8cb4ca235cc87a944a6dff5" translate="yes" xml:space="preserve">
          <source>The dbhash.exe Utility Program</source>
          <target state="translated">dbhash.exe实用程序。</target>
        </trans-unit>
        <trans-unit id="825612a3619e0d061fa775e13b4301fdfc5c4d06" translate="yes" xml:space="preserve">
          <source>The dbsqlfuzz fuzzer has been so successful at hardening the SQLite code base against malicious attack that it is now considered one of the four primary test harnesses for SQLite.</source>
          <target state="translated">dbsqlfuzzuzzer在硬化SQLite代码库以防止恶意攻击方面非常成功,现在它被认为是SQLite的四个主要测试工具之一。</target>
        </trans-unit>
        <trans-unit id="ce23c499eac5efbdaf2dbb036cb7b2ac9a155ffe" translate="yes" xml:space="preserve">
          <source>The dbsqlfuzz fuzzer mutates both the SQL input and the database file at the same time. Dbsqlfuzz uses a custom &lt;a href=&quot;https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md&quot;&gt;Structure-Aware Mutator&lt;/a&gt; on a specialized input file that defines both an input database and SQL text to be run against that database. Because it mutates both the input database and the input SQL at the same time, dbsqlfuzz has been able to find some obscure faults in SQLite that were missed by prior fuzzers that mutated only SQL inputs or only the database file.</source>
          <target state="translated">dbsqlfuzz模糊器同时更改SQL输入和数据库文件。Dbsqlfuzz 在专门的输入文件上使用自定义的&lt;a href=&quot;https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md&quot;&gt;结构感知&lt;/a&gt;突变体，该变量定义了输入数据库和要针对该数据库运行的SQL文本。由于dbsqlfuzz同时更改了输入数据库和输入SQL，因此dbsqlfuzz能够在SQLite中找到一些模糊的错误，而以前的仅将SQL输入或仅将数据库文件更改的模糊器则忽略了这些错误。</target>
        </trans-unit>
        <trans-unit id="e0f01bd5981d7e05e25eea466d94ddbb29381d04" translate="yes" xml:space="preserve">
          <source>The dbsqlfuzz fuzzer mutates both the SQL input and the database file at the same time. Dbsqlfuzz uses a custom &lt;a href=&quot;https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md&quot;&gt;Structure-Aware Mutator&lt;/a&gt; on a specialized input file that defines both an input database and SQL text to be run against that database. Because it mutates both the input database and the input SQL at the same time, dbsqlfuzz has been able to find some obscure faults in SQLite that were missed by prior fuzzers that mutated only SQL inputs or only the database file. The SQLite developers usually leave an instance or two of dbsqlfuzz running on the latest trunk code of SQLite whenever they are away from the office for an extended period, such as overnight.</source>
          <target state="translated">dbsqlfuzz模糊器同时更改SQL输入和数据库文件。 Dbsqlfuzz在专门的输入文件上使用自定义的&lt;a href=&quot;https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md&quot;&gt;结构感知&lt;/a&gt;突变体，该变量定义了输入数据库和要针对该数据库运行的SQL文本。由于dbsqlfuzz同时更改了输入数据库和输入SQL，因此dbsqlfuzz能够在SQLite中找到一些模糊的错误，这些错误仅由仅更改SQL输入或仅更改数据库文件的以前的模糊器遗漏了。 SQLite开发人员通常在离开办公室很长时间（例如整夜）时，会在最新的SQLite中继代码上运行dbsqlfuzz的一个或两个实例。</target>
        </trans-unit>
        <trans-unit id="0bae73cc22154360311af38fab160d5138d312f9" translate="yes" xml:space="preserve">
          <source>The dbstat virtual table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;, meaning that is not necessary to run &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; to create an instance of the dbstat virtual table before using it. The &quot;dbstat&quot; module name can be used as if it were a table name to query the dbstat virtual table directly. For example:</source>
          <target state="translated">dbstat虚拟表是一个&lt;a href=&quot;vtab#epovtab&quot;&gt;同义的虚拟表&lt;/a&gt;，这意味着在使用它之前不必运行&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;来创建dbstat虚拟表的实例。可以使用&amp;ldquo; dbstat&amp;rdquo;模块名称作为直接查询dbstat虚拟表的表名称。例如：</target>
        </trans-unit>
        <trans-unit id="e223099b7354d29f8974670689fc48600a955fe9" translate="yes" xml:space="preserve">
          <source>The decimal extension is not (currently) part of the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. However, it is included in the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;.</source>
          <target state="translated">十进制扩展名（当前）不是SQLite&lt;a href=&quot;amalgamation&quot;&gt;合并的&lt;/a&gt;一部分。但是，它包含在&lt;a href=&quot;cli&quot;&gt;CLI中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bf449afd5954b4d824e05da84c86a3c14eb17489" translate="yes" xml:space="preserve">
          <source>The decimal extension provides arbitrary-precision decimal arithmetic on numbers stored as text strings. Because the numbers are stored to arbitrary precision and as text, no approximations are needed. Computations can be done exactly.</source>
          <target state="translated">十进制扩展为以文本字符串形式存储的数字提供任意精度的十进制运算。由于数字是以任意精度和文本形式存储的,因此不需要近似值。可以精确地进行计算。</target>
        </trans-unit>
        <trans-unit id="6e61a5a7c6ccc546025a4d388dfa7ed2605e38bb" translate="yes" xml:space="preserve">
          <source>The decimal_sum(X) function is an aggregate, like the built-in &lt;a href=&quot;lang_aggfunc#sumunc&quot;&gt;sum() aggregate function&lt;/a&gt;, except that decimal_sum() computes its result to arbitrary precision and is therefore precise.</source>
          <target state="translated">十进制_sum（X）函数是一个聚合，类似于内置的&lt;a href=&quot;lang_aggfunc#sumunc&quot;&gt;sum（）聚合函数&lt;/a&gt;，不同之处在于十进制_sum（）将其结果计算为任意精度，因此是精确的。</target>
        </trans-unit>
        <trans-unit id="efcc1572318b12d880dcf6c5ba6e48d567425a65" translate="yes" xml:space="preserve">
          <source>The decision of whether to implement a FROM-clause subquery as a co-routine or using &lt;a href=&quot;optoverview#flattening&quot;&gt;query flattening&lt;/a&gt; now considers whether the result set of the outer query is &quot;complex&quot; (if it contains functions or expression subqueries). A complex result set biases the decision toward the use of co-routines.</source>
          <target state="translated">现在，是决定将FROM子句子查询实现为协同例程还是使用&lt;a href=&quot;optoverview#flattening&quot;&gt;查询展平，将&lt;/a&gt;考虑外部查询的结果集是否为&amp;ldquo;复杂&amp;rdquo;（如果它包含函数或表达式子查询）。复杂的结果集使决策偏向使用协同例程。</target>
        </trans-unit>
        <trans-unit id="ab20325df0acc9b2aa5397a0a5067782536af164" translate="yes" xml:space="preserve">
          <source>The decision of which collating sequence to use is controlled by the COLLATE clause in SQL. A COLLATE clause can occur on a table definition, to define a default collating sequence to a table column, or on field of an index, or in the ORDER BY clause of a SELECT statement. Planned enhancements to SQLite are to include standard CAST() syntax to allow the collating sequence of an expression to be defined.</source>
          <target state="translated">在SQL中,决定使用哪个整理序列是由 COLLATE子句控制的。COLLATE子句可以出现在一个表的定义中,定义一个表列的默认整理序列,或者出现在索引的字段中,或者出现在SELECT语句的ORDER BY子句中。计划对SQLite进行的改进是加入标准的CAST()语法,以允许定义表达式的整理序列。</target>
        </trans-unit>
        <trans-unit id="18e04830dfd2e28b2697cd44ccf76543eadbcceb" translate="yes" xml:space="preserve">
          <source>The declared type of each column in the table.</source>
          <target state="translated">表中每个列的声明类型。</target>
        </trans-unit>
        <trans-unit id="68032822fa262cd72f80461a11d217079b712edb" translate="yes" xml:space="preserve">
          <source>The default 'crisismerge' value is 16. There is no maximum limit. Attempting to set the 'crisismerge' parameter to a value of 0 or 1 is equivalent to setting it to the default value (16). It is an error to attempt to set the 'crisismerge' option to a negative value.</source>
          <target state="translated">缺省的'crashmerge'值是16。没有最大限制。试图将 &quot;危机融合 &quot;参数设置为0或1,相当于将其设置为默认值(16)。试图将 &quot;危机管理 &quot;选项设置为负值是错误的。</target>
        </trans-unit>
        <trans-unit id="04fcbed48c760da194eb2fb040297255b4fffa15" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format number&lt;/a&gt; is changed from 1 to 4. This means that, unless the &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format=ON&lt;/a&gt; statement is run, newly created database files will be unreadable by version of SQLite prior to 3.3.0 (2006-01-10). It also means that the &lt;a href=&quot;lang_createindex#descidx&quot;&gt;descending indices&lt;/a&gt; are enabled by default.</source>
          <target state="translated">默认&lt;a href=&quot;fileformat2#schemaformat&quot;&gt;模式格式编号&lt;/a&gt;从1更改为4。这意味着，除非运行&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format = ON&lt;/a&gt;语句，否则SQLite 3.3.0（2006-01-10）之前的版本将无法读取新创建的数据库文件。这也意味着默认情况下将启用&lt;a href=&quot;lang_createindex#descidx&quot;&gt;降序索引&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b8d41b5a0a8527b81ce581d5cb059a7a0ef7283f" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format number&lt;/a&gt; used by SQLite when creating new database files is set by this macro. The schema formats are all very similar. The difference between formats 1 and 4 is that format 4 understands &lt;a href=&quot;lang_createindex#descidx&quot;&gt;descending indices&lt;/a&gt; and has a tighter encoding for boolean values.</source>
          <target state="translated">此宏设置SQLite创建新数据库文件时使用的默认&lt;a href=&quot;fileformat2#schemaformat&quot;&gt;架构格式编号&lt;/a&gt;。模式格式都非常相似。格式1和4之间的区别在于，格式4可以理解&lt;a href=&quot;lang_createindex#descidx&quot;&gt;降序索引，&lt;/a&gt;并且对布尔值的编码更严格。</target>
        </trans-unit>
        <trans-unit id="ca0921362c7fa29bf8c96529653cba6ff2aa4225" translate="yes" xml:space="preserve">
          <source>The default MASK is and always shall be 0xfffe. The 0xfffe mask means perform all of the optimizations listed above except Debug Mode. If new optimizations are added in the future that should be off by default, those new optimizations will be given a mask of 0x10000 or larger.</source>
          <target state="translated">默认的MASK是并且永远是0xfffe。0xfffe mask 意味着执行上面列出的除 Debug 模式以外的所有优化。如果将来增加了新的优化,而这些优化在默认情况下应该是关闭的,这些新的优化将被赋予0x10000或更大的掩码。</target>
        </trans-unit>
        <trans-unit id="a903124a6abce3d6d4d4bbe7f6d1f8b599823062" translate="yes" xml:space="preserve">
          <source>The default VFS can be changed by registering or re-registering the VFS using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface with a second parameter of 1. Hence, if a (unix) process wants to always use the &quot;unix-nolock&quot; VFS in place of &quot;unix&quot;, the following code would work:</source>
          <target state="translated">可以通过使用带有第二个参数1 的&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;接口注册或重新注册VFS来更改默认VFS 。因此，如果（unix）进程希望始终使用&amp;ldquo; unix-nolock&amp;rdquo; VFS代替&amp;ldquo; unix&amp;rdquo;，则以下代码将起作用：</target>
        </trans-unit>
        <trans-unit id="c5a51f22fb2e29520e6fcdc862dfe6400d4b2d95" translate="yes" xml:space="preserve">
          <source>The default behavior for a loadable extension is that it is unloaded from process memory when the database connection that originally invoked &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; closes. (In other words, the xDlUnload method of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is called for all extensions when a database connection closes.) However, if the initialization procedure returns &lt;a href=&quot;rescode#ok_load_permanently&quot;&gt;SQLITE_OK_LOAD_PERMANENTLY&lt;/a&gt; instead of SQLITE_OK, then the extension will not be unloaded (xDlClose will not be invoked) and the extension will remain in process memory indefinitely. The SQLITE_OK_LOAD_PERMANENTLY return value is useful for extensions that want to register new &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;.</source>
          <target state="translated">可加载扩展的默认行为是，当最初调用&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;的数据库连接关闭时，将从进程内存中将其卸载。 （换句话说，关闭数据库连接时，将为所有扩展调用&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的xDlUnload方法。）但是，如果初始化过程返回&lt;a href=&quot;rescode#ok_load_permanently&quot;&gt;SQLITE_OK_LOAD_PERMANENTLY&lt;/a&gt;而不是SQLITE_OK，则不会卸载该扩展（不会调用xDlClose）并且扩展名将无限期保留在进程内存中。 SQLITE_OK_LOAD_PERMANENTLY返回值对于要注册新&lt;a href=&quot;vfs&quot;&gt;VFS的&lt;/a&gt;扩展很有用。</target>
        </trans-unit>
        <trans-unit id="35fa7584b655adc25cbf99cb25271bb088b3504f" translate="yes" xml:space="preserve">
          <source>The default behavior gives this results:</source>
          <target state="translated">默认行为给出了这样的结果。</target>
        </trans-unit>
        <trans-unit id="929789505d4e7daeec8d95f7bd37c902d7905d6b" translate="yes" xml:space="preserve">
          <source>The default behavior of assert(X) in standard C is that it is enabled for release builds. This is a reasonable default. However, the SQLite code base has many assert() statements in performance-sensitive areas of the code. Leaving assert(X) turned on causes SQLite to run about three times slower. Also, SQLite strives to provide 100% MC/DC in an as-delivered configuration, which is obviously impossible if assert(X) statements are enabled. For these reasons, assert(X) is a no-op for release builds in SQLite.</source>
          <target state="translated">assert(X)在标准 C 中的默认行为是它在发布版构建中被启用。这是一个合理的默认值。然而,SQLite代码库在代码的性能敏感区域有许多 assert()语句。让assert(X)开启会导致SQLite运行速度慢三倍左右。另外,SQLite努力在一个已交付的配置中提供100%的MC/DC,如果启用assert(X)语句,显然是不可能的。由于这些原因,assert(X)对于SQLite中的发行版构建来说是不可能的。</target>
        </trans-unit>
        <trans-unit id="d9b3b8cc178a304f2169b7fe7ac799ae14ab4502" translate="yes" xml:space="preserve">
          <source>The default behavior of the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator is to ignore case for ASCII characters. Hence, by default &lt;b&gt;'a' LIKE 'A'&lt;/b&gt; is true. The case_sensitive_like pragma installs a new application-defined LIKE function that is either case sensitive or insensitive depending on the value of the case_sensitive_like pragma. When case_sensitive_like is disabled, the default LIKE behavior is expressed. When case_sensitive_like is enabled, case becomes significant. So, for example, &lt;b&gt;'a' LIKE 'A'&lt;/b&gt; is false but &lt;b&gt;'a' LIKE 'a'&lt;/b&gt; is still true.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;运算符的默认行为是忽略ASCII字符的大小写。因此，默认情况下，&lt;b&gt;&amp;ldquo; a&amp;rdquo;（如&amp;ldquo; A&amp;rdquo;）&lt;/b&gt;为true。 case_sensitive_like编译指示将安装一个新的应用程序定义的LIKE函数，该函数区分大小写或不区分大小写，具体取决于case_sensitive_like编译指示的值。禁用case_sensitive_like时，将表示默认的LIKE行为。启用case_sensitive_like时，大小写变得重要。因此，例如，&lt;b&gt;&amp;ldquo; a&amp;rdquo;（如&amp;ldquo; A&amp;rdquo;）&lt;/b&gt;为假，但&lt;b&gt;&amp;ldquo; a&amp;rdquo;（如&amp;ldquo; a&amp;rdquo;&lt;/b&gt;）仍为真。</target>
        </trans-unit>
        <trans-unit id="9edad614da3d9aaf086c0a5c5b068d92a4f96481" translate="yes" xml:space="preserve">
          <source>The default builds for SQLite on Unix, Windows, and OS/2 include a VFS appropriate for the target platform. SQLite builds for other operating systems do not contain a VFS by default, but the application can register one or more at run-time.</source>
          <target state="translated">SQLite在Unix、Windows和OS/2上的默认构建包含一个适合目标平台的VFS。其他操作系统的SQLite构建版默认不包含VFS,但应用程序可以在运行时注册一个或多个VFS。</target>
        </trans-unit>
        <trans-unit id="6a78f3c92a0ec476b159128dcf1aca02c9237966" translate="yes" xml:space="preserve">
          <source>The default busy callback is NULL.</source>
          <target state="translated">默认的繁忙回调为NULL。</target>
        </trans-unit>
        <trans-unit id="a139fc5b0808f70ee2866da438ce9a4197bf896c" translate="yes" xml:space="preserve">
          <source>The default collating function for all strings is BINARY. Alternative collating functions for table columns can be specified in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement using the COLLATE clause on the &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definition&lt;/a&gt;. When a column is indexed, the same collating function specified in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement is used for the column in the index, by default, though this can be overridden using a COLLATE clause in the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement.</source>
          <target state="translated">所有字符串的默认整理功能是BINARY。可以使用&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;列定义&lt;/a&gt;上的COLLATE子句在&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句中指定表列的替代整理功能。对列进行索引时，默认情况下，为索引中的列使用在&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句中指定的相同整理函数，尽管可以使用&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;语句中的COLLATE子句将其覆盖。</target>
        </trans-unit>
        <trans-unit id="4196a7b520d0708c2ca6c2f0dd09284b39f44638" translate="yes" xml:space="preserve">
          <source>The default configuration for SQLite works great for most applications. But sometimes developers want to tweak the setup to try to squeeze out a little more performance, or take advantage of some obscure feature.</source>
          <target state="translated">SQLite的默认配置对于大多数应用程序来说都很好用,但有时开发人员想要调整设置,试图榨取更多的性能,或者利用一些不知名的功能。但有时,开发人员希望调整设置,以尝试挤出更多的性能,或利用一些不知名的功能。</target>
        </trans-unit>
        <trans-unit id="7f629fe0c846fce25506268b75e0f95dc1a4e2cd" translate="yes" xml:space="preserve">
          <source>The default configuration of SQLite assumes the underlying filesystem supports long filenames.</source>
          <target state="translated">SQLite的默认配置假设底层文件系统支持长文件名。</target>
        </trans-unit>
        <trans-unit id="f9ca0f7d70101ac90e64f7de1b18481b2e2650e6" translate="yes" xml:space="preserve">
          <source>The default configuration of SQLite only supports case-insensitive comparisons of ASCII characters. The reason for this is that doing full Unicode case-insensitive comparisons and case conversions requires tables and logic that would nearly double the size of the SQLite library. The SQLite developers reason that any application that needs full Unicode case support probably already has the necessary tables and functions and so SQLite should not take up space to duplicate this ability.</source>
          <target state="translated">SQLite的默认配置只支持ASCII字符的大小写不敏感比较。这样做的原因是,进行完全的Unicode大小写不敏感的比较和大小写转换需要表和逻辑,这将使SQLite库的大小几乎增加一倍。SQLite开发者的理由是,任何需要完全支持Unicode大小写的应用程序可能已经有了必要的表和函数,所以SQLite不应该占用空间来重复这种能力。</target>
        </trans-unit>
        <trans-unit id="c23763d0cb18af4da83857106ae71fb287c36d2b" translate="yes" xml:space="preserve">
          <source>The default datatype is 'int32'.</source>
          <target state="translated">默认的数据类型是'int32'。</target>
        </trans-unit>
        <trans-unit id="57ca93f20ecfcb67f54da8e6ff374c396f410f8d" translate="yes" xml:space="preserve">
          <source>The default deletion cost</source>
          <target state="translated">默认删除成本</target>
        </trans-unit>
        <trans-unit id="348ca4d833d68a6b457e44e2f51c5dde36928e20" translate="yes" xml:space="preserve">
          <source>The default directory for temporary files depends on the OS. Some OS interfaces may choose to ignore this variable and place temporary files in some other directory different from the directory specified here. In that sense, this pragma is only advisory.</source>
          <target state="translated">临时文件的默认目录取决于操作系统。一些操作系统接口可能会选择忽略这个变量,并将临时文件放在与这里指定的目录不同的其他目录中。在这个意义上,这个pragma只是建议性的。</target>
        </trans-unit>
        <trans-unit id="09a19fe31cacf32f0a49986af2b636abaafd7a24" translate="yes" xml:space="preserve">
          <source>The default encoding will be UTF-8 for databases created using sqlite3_open() or sqlite3_open_v2(). The default encoding for databases created using sqlite3_open16() will be UTF-16 in the native byte order.</source>
          <target state="translated">对于使用sqlite3_open()或sqlite3_open_v2()创建的数据库,默认的编码是UTF-8。对于使用sqlite3_open16()创建的数据库,默认的编码是UTF-16,按本地字节顺序。</target>
        </trans-unit>
        <trans-unit id="93b91496e8c579b792f6528c1582f57d8e5307a9" translate="yes" xml:space="preserve">
          <source>The default file format is now 1.</source>
          <target state="translated">现在默认的文件格式是1。</target>
        </trans-unit>
        <trans-unit id="07f52e2687ee82b720aa1390843c77644fb57108" translate="yes" xml:space="preserve">
          <source>The default file format is set by the &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt; compile-time option.</source>
          <target state="translated">默认文件格式由&lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt;编译时选项设置。</target>
        </trans-unit>
        <trans-unit id="cc414446f05fe3ef5190b22cd556bce2036d0102" translate="yes" xml:space="preserve">
          <source>The default frame-spec is:</source>
          <target state="translated">默认的帧规格是:</target>
        </trans-unit>
        <trans-unit id="c9df385f1bced3c35670bbdf7a0e4f5a1cfdb4ca" translate="yes" xml:space="preserve">
          <source>The default implementation stores all statistics in a single table named &quot;&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;&quot;. If SQLite is compiled with the &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; option and without the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; option, then additional histogram data is collected and stored in &lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt;. If SQLite is compiled with the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; option, then additional histogram data is collected and stored in &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;. Older versions of SQLite would make use of the &lt;a href=&quot;fileformat2#stat2tab&quot;&gt;sqlite_stat2&lt;/a&gt; table when compiled with &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; but all recent versions of SQLite ignore the sqlite_stat2 table. Future enhancements may create additional &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal tables&lt;/a&gt; with the same name pattern except with final digit larger than &quot;4&quot;. All of these tables are collectively referred to as &quot;statistics tables&quot;.</source>
          <target state="translated">默认实现将所有统计信息存储在一个名为&amp;ldquo; &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt; &amp;rdquo;的表中。如果使用&lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt;选项而不使用&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;选项编译SQLite ，则将收集其他直方图数据并将其存储在&lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3中&lt;/a&gt;。如果使用&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;选项编译SQLite ，则将收集其他直方图数据并将其存储在&lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4中&lt;/a&gt;。 SQLite的旧版本会利用的&lt;a href=&quot;fileformat2#stat2tab&quot;&gt;sqlite_stat2&lt;/a&gt;当编译表&lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;但最近所有的SQLite版本忽略sqlite_stat2表。将来的增强功能可能会创建其他&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部表&lt;/a&gt;名称模式相同，但最后一位数字大于&amp;ldquo; 4&amp;rdquo;。所有这些表统称为&amp;ldquo;统计表&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2000f471d1e2f9fad888fbe96454c85325906ea0" translate="yes" xml:space="preserve">
          <source>The default implementation stores all statistics in a single table named &quot;&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;&quot;. If SQLite is compiled with the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; option, then additional histogram data is collected and stored in &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;. Older versions of SQLite would make use of the &lt;a href=&quot;fileformat2#stat2tab&quot;&gt;sqlite_stat2&lt;/a&gt; table or &lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt; table when compiled with &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; or &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt;, but all recent versions of SQLite ignore the sqlite_stat2 and sqlite_stat3 tables. Future enhancements may create additional &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal tables&lt;/a&gt; with the same name pattern except with final digit larger than &quot;4&quot;. All of these tables are collectively referred to as &quot;statistics tables&quot;.</source>
          <target state="translated">默认实现将所有统计信息存储在一个名为&amp;ldquo; &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt; &amp;rdquo;的表中。如果使用&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;选项编译SQLite ，则将收集其他直方图数据并将其存储在&lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4中&lt;/a&gt;。当使用&lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;或&lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt;编译时，较旧版本的SQLite将使用&lt;a href=&quot;fileformat2#stat2tab&quot;&gt;sqlite_stat2&lt;/a&gt;表或&lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt;表，但所有最新版本的SQLite都会忽略sqlite_stat2和sqlite_stat3表。将来的增强功能可能会创建其他&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部表&lt;/a&gt;具有相同的名称模式，但最后一位数字大于&amp;ldquo; 4&amp;rdquo;。所有这些表统称为&amp;ldquo;统计表&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="92c0ee558e2a1a06a318ed232e40e1c0e6d83d45" translate="yes" xml:space="preserve">
          <source>The default insertion cost</source>
          <target state="translated">默认插入成本</target>
        </trans-unit>
        <trans-unit id="44b061817ffc2eb0f5dadec06f4e66f4f81231c2" translate="yes" xml:space="preserve">
          <source>The default locking mechanism used by SQLite on unix platforms is POSIX advisory locking, but there are other options. By selecting an alternative &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; using the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface, an application can make use of other locking protocols that might be more appropriate to certain filesystems. For example, dot-file locking might be select for use in an application that has to run on an NFS filesystem that does not support POSIX advisory locking.</source>
          <target state="translated">Unix平台上SQLite使用的默认锁定机制是POSIX咨询锁定，但还有其他选择。通过使用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;接口选择备用的&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;，应用程序可以使用可能更适合某些文件系统的其他锁定协议。例如，可能选择了点文件锁定，以用于必须在不支持POSIX咨询锁定的NFS文件系统上运行的应用程序中。</target>
        </trans-unit>
        <trans-unit id="d9e0888f3707dfa1a041c24c2a5eb623fe8f593b" translate="yes" xml:space="preserve">
          <source>The default locking mechanism used by SQLite on unix platforms is POSIX advisory locking. Unfortunately, POSIX advisory locking has design quirks that make it prone to misuse and failure. In particular, any thread in the same process with a file descriptor that is holding a POSIX advisory lock can override that lock using a different file descriptor. One particularly pernicious problem is that the &lt;code&gt;close()&lt;/code&gt; system call will cancel all POSIX advisory locks on the same file for all threads and all file descriptors in the process.</source>
          <target state="translated">Unix平台上SQLite使用的默认锁定机制是POSIX咨询锁定。不幸的是，POSIX咨询锁定具有一些设计上的怪癖，使其容易被滥用和失败。特别是，在同一进程中具有文件描述符且持有POSIX咨询锁的任何线程都可以使用其他文件描述符覆盖该锁。一个特别有害的问题是 &lt;code&gt;close()&lt;/code&gt; 系统调用将取消该进程中所有线程和所有文件描述符在同一文件上的所有POSIX咨询锁。</target>
        </trans-unit>
        <trans-unit id="07275b3b33b4fa68f4e8147d7f962856df7d7bd0" translate="yes" xml:space="preserve">
          <source>The default lookaside configuration has changed from 100 slots of 1200 bytes each (120KB) to be 40 slots of 1200 bytes each (48KB). This space ends up being allocated as 93 slots of 128 bytes each and 30 slots of 1200 bytes each. So more lookaside slots are available but much less heap space is used.</source>
          <target state="translated">默认的lookaside配置已经从100个1200字节的插槽(120KB)变为40个1200字节的插槽(48KB),这个空间最终被分配为93个128字节的插槽和30个1200字节的插槽。这个空间最终被分配为93个每个128字节的插槽和30个每个1200字节的插槽。因此,可以使用更多的lookaside插槽,但使用的堆空间却少了很多。</target>
        </trans-unit>
        <trans-unit id="4e313113e047c2f26bfe18f713c540368922a076" translate="yes" xml:space="preserve">
          <source>The default lookaside configuration, the size of the small-slots, and the details of how heap space is allocated between small-slots and big-slots, are all subject to change from one release to the next.</source>
          <target state="translated">默认的lookaside配置,小槽的大小,以及小槽和大槽之间堆空间如何分配的细节,都会在每个版本中发生变化。</target>
        </trans-unit>
        <trans-unit id="fdf451db4759c12771bfb1206d604a686ee94bb6" translate="yes" xml:space="preserve">
          <source>The default mapping of the rank column for a table may be modified using the &lt;a href=&quot;fts5#the_rank_configuration_option&quot;&gt;FTS5 rank configuration option&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;fts5#the_rank_configuration_option&quot;&gt;FTS5等级配置选项&lt;/a&gt;来修改表的等级列的默认映射。</target>
        </trans-unit>
        <trans-unit id="676ab2fe4bf4ab903767c236b27e9b63051796ee" translate="yes" xml:space="preserve">
          <source>The default maximum trigger recursion depth is 1000.</source>
          <target state="translated">默认的最大触发递归深度为1000。</target>
        </trans-unit>
        <trans-unit id="fd5421bb6c7fc35d245339e5557eb27520f8453d" translate="yes" xml:space="preserve">
          <source>The default means that aggregate window functions read all rows from the beginning of the partition up to and including the current row and its peers. This implies that rows that have the same values for all ORDER BY expressions will also have the same value for the result of the window function (as the window frame is the same). For example:</source>
          <target state="translated">默认情况下,意味着聚合窗口函数会读取从分区开始的所有行,直到并包括当前行及其同行。这意味着对于所有ORDER BY表达式具有相同值的行,其窗口函数的结果也将具有相同的值(因为窗口框架是相同的)。例如</target>
        </trans-unit>
        <trans-unit id="2d78a92ed9db0e9db8d034d6998442b87734337c" translate="yes" xml:space="preserve">
          <source>The default mechanism by which SQLite accesses and updates database disk files is the xRead() and xWrite() methods of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; VFS object. These methods are typically implemented as &quot;read()&quot; and &quot;write()&quot; system calls which cause the operating system to copy disk content between the kernel buffer cache and user space.</source>
          <target state="translated">SQLite访问和更新数据库磁盘文件的默认机制是&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; VFS对象的xRead（）和xWrite（）方法。这些方法通常以&amp;ldquo; read（）&amp;rdquo;和&amp;ldquo; write（）&amp;rdquo;系统调用的形式实现，这导致操作系统在内核缓冲区高速缓存和用户空间之间复制磁盘内容。</target>
        </trans-unit>
        <trans-unit id="af6b4fd5a17994d4af89bdbebf0e8f01053d45e7" translate="yes" xml:space="preserve">
          <source>The default memory allocation settings in SQLite are appropriate for most applications. However, applications with unusual or particularly strict requirements may want to adjust the configuration to more closely align SQLite to their needs. Both compile-time and start-time configuration options are available.</source>
          <target state="translated">SQLite中默认的内存分配设置适合大多数应用程序。但是,对于有不寻常或特别严格要求的应用程序,可能希望调整配置,使SQLite更贴近其需求。编译时和启动时的配置选项都是可用的。</target>
        </trans-unit>
        <trans-unit id="62759f30ef7e2768a0dc269d58d4f224a639e96a" translate="yes" xml:space="preserve">
          <source>The default memory allocator is recommended for most applications. If you do not have a compelling need to use an alternative memory allocator, then use the default.</source>
          <target state="translated">对于大多数应用程序,建议使用默认的内存分配器。如果你没有迫切的需要使用其他的内存分配器,那么就使用默认的内存分配器。</target>
        </trans-unit>
        <trans-unit id="dcfc21fe3a44b7df155912e662a52083d37f6130" translate="yes" xml:space="preserve">
          <source>The default method by which SQLite implements &lt;a href=&quot;atomiccommit&quot;&gt;atomic commit and rollback&lt;/a&gt; is a &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt;. Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21), a new &quot;Write-Ahead Log&quot; option (hereafter referred to as &quot;WAL&quot;) is available.</source>
          <target state="translated">SQLite实现&lt;a href=&quot;atomiccommit&quot;&gt;原子提交和回滚&lt;/a&gt;的默认方法是&lt;a href=&quot;lockingv3#rollback&quot;&gt;回滚日志&lt;/a&gt;。从&lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;版本3.7.0&lt;/a&gt;（2010-07-21）开始，提供了新的&amp;ldquo;预写日志&amp;rdquo;选项（以下称为&amp;ldquo; WAL&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="03533018c376c706c7055694a5695128f6d5dba9" translate="yes" xml:space="preserve">
          <source>The default mode is serialized.</source>
          <target state="translated">默认模式为序列化。</target>
        </trans-unit>
        <trans-unit id="c91c1c07eac44347101354cb661e73cefc49a14a" translate="yes" xml:space="preserve">
          <source>The default numeric file permissions for newly created database files under unix. If not specified, the default is 0644 which means that the files is globally readable but only writable by the creator.</source>
          <target state="translated">在unix下新建数据库文件的默认数字文件权限,如果没有指定,默认为0644,表示文件是全局可读的,但只能由创建者写。如果没有指定,默认为0644,这意味着文件是全局可读的,但只有创建者可以写。</target>
        </trans-unit>
        <trans-unit id="b7b908d4b0d2fc05c9ddc3f95f430fcff134a8ed" translate="yes" xml:space="preserve">
          <source>The default operation of edit() is to invoke a text editor. But by using an alternative edit program in the second argument, you can also get it to edit images or other non-text resources. For example, if you want to modify a JPEG image that happens to be stored in a field of a table, you could run:</source>
          <target state="translated">edit()的默认操作是调用一个文本编辑器,但通过在第二个参数中使用替代的编辑程序,你也可以让它编辑图片或其他非文本资源。但是通过在第二个参数中使用一个替代的编辑程序,你也可以让它来编辑图像或其他非文本资源。例如,如果你想修改一个恰好存储在表格字段中的JPEG图像,你可以运行。</target>
        </trans-unit>
        <trans-unit id="56314197173fa9030fb113bbb41424539c87a296" translate="yes" xml:space="preserve">
          <source>The default order of the nested loops in a join is for the left-most table in the FROM clause to form the outer loop and the right-most table to form the inner loop. However, SQLite will nest the loops in a different order if doing so will help it to select better indexes.</source>
          <target state="translated">连接中嵌套循环的默认顺序是FROM子句中最左边的表形成外循环,最右边的表形成内循环。但是,如果这样做可以帮助它选择更好的索引,SQLite会以不同的顺序来嵌套循环。</target>
        </trans-unit>
        <trans-unit id="e15d9f7898bd04fad7c8bec9316feb2b3c4d67cc" translate="yes" xml:space="preserve">
          <source>The default order of the nested loops in a join is for the left-most table in the FROM clause to form the outer loop and the right-most table to form the inner loop. However, SQLite will nest the loops in a different order if doing so will help it to select better indices.</source>
          <target state="translated">连接中嵌套循环的默认顺序是FROM子句中最左边的表形成外循环,最右边的表形成内循环。但是,如果这样做可以帮助SQLite选择更好的索引,那么SQLite会以不同的顺序来嵌套循环。</target>
        </trans-unit>
        <trans-unit id="c60124ec3003cce0626fc7fdd9909bdc4316bd6f" translate="yes" xml:space="preserve">
          <source>The default output mode is &quot;list&quot;. In list mode, each row of a query result is written on one line of output and each column within that row is separated by a specific separator string. The default separator is a pipe symbol (&quot;|&quot;). List mode is especially useful when you are going to send the output of a query to another program (such as AWK) for additional processing.</source>
          <target state="translated">默认的输出模式是 &quot;list&quot;。在列表模式下,查询结果的每一行都被写在一行输出中,该行中的每一列都用特定的分隔符隔开。默认的分隔符是一个管道符号(&quot;|&quot;)。当你要将查询的输出发送到另一个程序(如AWK)进行额外处理时,列表模式特别有用。</target>
        </trans-unit>
        <trans-unit id="cae14327c7d6852834539912db17ff8fae315187" translate="yes" xml:space="preserve">
          <source>The default output shows the beginning and end of each configuration and test module combination. In the example above &quot;c1&quot; and &quot;64k&quot; are configurations and &quot;pager08&quot;, &quot;build33&quot;, &quot;orderby01&quot;, etc. are test modules. Compile-time and run-time options are available to increase or decrease the amount of output. The output can be increased by showing each test case within each test module. The output can be decreased by degrees: omitting test modules starts and stops, omitting configuration starts and stops, and finally by omitting all output.</source>
          <target state="translated">默认输出显示了每个配置和测试模块组合的开始和结束。在上面的例子中,&quot;c1 &quot;和 &quot;64k &quot;是配置,&quot;pager08&quot;、&quot;build33&quot;、&quot;orderby01 &quot;等是测试模块。编译时和运行时选项可以增加或减少输出量。可以通过显示每个测试模块内的每个测试用例来增加输出量。输出量可以按程度减少:省略测试模块的启动和停止,省略配置的启动和停止,最后省略所有输出。</target>
        </trans-unit>
        <trans-unit id="81fe79158a35398aa7562b0fca6f1415aa39b894" translate="yes" xml:space="preserve">
          <source>The default page cache implemention does not allocate the full amount of cache memory all at once. Cache memory is allocated in smaller chunks on an as-needed basis. The page_cache setting is a (suggested) upper bound on the amount of memory that the cache can use, not the amount of memory it will use all of the time. This is the behavior of the default page cache implementation, but an &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;application defined page cache&lt;/a&gt; is free to behave differently if it wants.</source>
          <target state="translated">默认的页面缓存实现不会一次分配全部的缓存内存。高速缓存按需按较小的块分配。 page_cache设置是（建议的）上限，用于缓存可以使用的内存量，而不是其将一直使用的内存量。这是默认页面高速缓存实现的行为，但是&lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;应用程序定义的页面高速缓存&lt;/a&gt;可以随意改变行为。</target>
        </trans-unit>
        <trans-unit id="fc5d7962d2b50c7baceb7ed65dad81e0058ad64b" translate="yes" xml:space="preserve">
          <source>The default page cache strives more diligently to avoid using memory beyond what is allocated to it by &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. Or if using page cache is allocating from the heap, it strives to avoid going over the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt;, even if &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; is not set.</source>
          <target state="translated">默认页面高速缓存会尽力避免使用超出&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;分配给它的内存之外的内存。或者，如果使用页面缓存是从堆中分配的，即使未设置&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;，它也会努力避免遍历&lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b40256b332aa600059fdd4657f3e43acb14b4e3d" translate="yes" xml:space="preserve">
          <source>The default page cache strives more diligently to avoid using memory beyond what is allocated to it by &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. Or if using page cache is allocating from the heap, it strives to avoid going over the &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt;, even if &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; is not set.</source>
          <target state="translated">默认页面缓存会尽力避免使用超出&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;分配的内存之外的内存。或者，如果使用页面缓存是从堆中分配的，即使未设置&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;，它也会努力避免遍历&lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="619cdf9a91dcb3b5377126d1f738a21802c8e3aa" translate="yes" xml:space="preserve">
          <source>The default page size on windows is automatically adjusted to match the capabilities of the underlying filesystem.</source>
          <target state="translated">Windows上的默认页面大小会自动调整,以匹配底层文件系统的功能。</target>
        </trans-unit>
        <trans-unit id="df04859a275716c6652a67712d525008dc797ebb" translate="yes" xml:space="preserve">
          <source>The default setting for SQLITE_MAX_COLUMN is 2000. You can change it at compile time to values as large as 32767. On the other hand, many experienced database designers will argue that a well-normalized database will never need more than 100 columns in a table.</source>
          <target state="translated">SQLITE_MAX_COLUMN的默认设置是2000。你可以在编译时把它改成32767这么大的值。另一方面,许多有经验的数据库设计者会认为,一个规范化良好的数据库永远不会需要超过100列的表。</target>
        </trans-unit>
        <trans-unit id="0506f7d82e65a6fef4e6e411dc34fd230ff22185" translate="yes" xml:space="preserve">
          <source>The default setting for auto-vacuum is 0 or &quot;none&quot;, unless the &lt;a href=&quot;compile#default_autovacuum&quot;&gt;SQLITE_DEFAULT_AUTOVACUUM&lt;/a&gt; compile-time option is used. The &quot;none&quot; setting means that auto-vacuum is disabled. When auto-vacuum is disabled and data is deleted data from a database, the database file remains the same size. Unused database file pages are added to a &quot;&lt;a href=&quot;fileformat2#freelist&quot;&gt;freelist&lt;/a&gt;&quot; and reused for subsequent inserts. So no database file space is lost. However, the database file does not shrink. In this mode the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command can be used to rebuild the entire database file and thus reclaim unused disk space.</source>
          <target state="translated">除非使用&lt;a href=&quot;compile#default_autovacuum&quot;&gt;SQLITE_DEFAULT_AUTOVACUUM&lt;/a&gt;编译时选项，否则自动真空的默认设置为0或&amp;ldquo;无&amp;rdquo; 。 &amp;ldquo;无&amp;rdquo;设置表示禁用自动真空。禁用自动真空并且从数据库中删除数据后，数据库文件将保持相同大小。未使用的数据库文件页面被添加到&amp;ldquo; &lt;a href=&quot;fileformat2#freelist&quot;&gt;freelist&lt;/a&gt; &amp;rdquo;中，并用于后续插入。因此，不会丢失数据库文件空间。但是，数据库文件不会收缩。在这种模式下，&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;命令可用于重建整个数据库文件，从而回收未使用的磁盘空间。</target>
        </trans-unit>
        <trans-unit id="de25e032063f16295b8e77c37d21842694e060fe" translate="yes" xml:space="preserve">
          <source>The default setting for the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; is 0, which means to following the recommendation of &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;的默认设置为0，这意味着遵循&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;编译时参数的建议。</target>
        </trans-unit>
        <trans-unit id="d111baa1a5224d066ace9e922bc0723387d0391f" translate="yes" xml:space="preserve">
          <source>The default setting for this pragma is OFF, which means that all references to the table anywhere in the schema are converted to the new name.</source>
          <target state="translated">这个pragma的默认设置是OFF,这意味着在模式中任何地方对表的所有引用都将转换为新的名称。</target>
        </trans-unit>
        <trans-unit id="5060b84cc58c53853f2caf81d58480c0590b9ac5" translate="yes" xml:space="preserve">
          <source>The default setting is 1. Additional information can be found in &lt;a href=&quot;tempfiles#tempstore&quot;&gt;tempfiles.html&lt;/a&gt;.</source>
          <target state="translated">默认设置为1。其他信息可以在&lt;a href=&quot;tempfiles#tempstore&quot;&gt;tempfiles.html中&lt;/a&gt;找到。</target>
        </trans-unit>
        <trans-unit id="4e7fc079075b7fd84d6268869958a93f9d4d68c3" translate="yes" xml:space="preserve">
          <source>The default sorting procedure is to gather all information that will ultimately be output into a &quot;record&quot; and pass that complete record to the sorter. But in some cases, for example if some of the output columns consists of large BLOB values, the size of the each record can be large, which means that the sorter has to either use more memory, and/or write more content to temporary storage.</source>
          <target state="translated">默认的排序程序是将所有最终要输出的信息收集到一个 &quot;记录 &quot;中,并将这个完整的记录传递给分拣机。但在某些情况下,例如如果某些输出列由大的BLOB值组成,那么每条记录的大小可能会很大,这意味着分拣器必须使用更多的内存,和/或将更多的内容写入临时存储。</target>
        </trans-unit>
        <trans-unit id="6f4517865a59fec2a530bec6db77e7cd99eb8490" translate="yes" xml:space="preserve">
          <source>The default strategy is to allow successive write transactions to grow the WAL until the WAL becomes about 1000 pages in size, then to run a checkpoint operation for each subsequent COMMIT until the WAL is reset to be smaller than 1000 pages. By default, the checkpoint will be run automatically by the same thread that does the COMMIT that pushes the WAL over its size limit. This has the effect of causing most COMMIT operations to be very fast but an occasional COMMIT (those that trigger a checkpoint) to be much slower. If that effect is undesirable, then the application can disable automatic checkpointing and run the periodic checkpoints in a separate thread, or separate process. (Links to commands and interfaces to accomplish this are &lt;a href=&quot;#how_to_checkpoint&quot;&gt;shown below&lt;/a&gt;.)</source>
          <target state="translated">默认策略是允许连续的写事务增长WAL，直到WAL变为大约1000页，然后为每个后续COMMIT运行检查点操作，直到WAL重置为小于1000页为止。默认情况下，检查点将由执行COMMIT的同一线程自动运行，该线程使WAL超过其大小限制。这会导致大多数COMMIT操作非常快，但偶尔的COMMIT（触发检查点的操作）会慢得多。如果不希望这种影响，则应用程序可以禁用自动检查点，并在单独的线程或单独的进程中运行定期检查点。 （实现此目的的命令和界面的链接&lt;a href=&quot;#how_to_checkpoint&quot;&gt;如下所示&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="7aba3882e935c491d72d10d266cb950c10ccee5f" translate="yes" xml:space="preserve">
          <source>The default substitution cost</source>
          <target state="translated">默认替代成本</target>
        </trans-unit>
        <trans-unit id="6947c6a992789a324c997f5478292dca047e240d" translate="yes" xml:space="preserve">
          <source>The default synchronous setting is full so the above is what usually happens. However, if the synchronous setting is lowered to &quot;normal&quot;, SQLite only flushes the rollback journal once, after the page count has been written. This carries a risk of corruption because it might happen that the modified (non-zero) page count reaches the disk surface before all of the data does. The data will have been written first, but SQLite assumes that the underlying filesystem can reorder write requests and that the page count can be burned into oxide first even though its write request occurred last. So as a second line of defense, SQLite also uses a 32-bit checksum on every page of data in the rollback journal. This checksum is evaluated for each page during rollback while rolling back a journal as described in &lt;a href=&quot;#section_4_4&quot;&gt;section 4.4&lt;/a&gt;. If an incorrect checksum is seen, the rollback is abandoned. Note that the checksum does not guarantee that the page data is correct since there is a small but finite probability that the checksum might be right even if the data is corrupt. But the checksum does at least make such an error unlikely.</source>
          <target state="translated">默认同步设置已满，因此通常会发生上述情况。但是，如果将同步设置降低为&amp;ldquo;正常&amp;rdquo;，则在写入页数之后，SQLite仅刷新一次回滚日志。这会带来损坏的风险，因为修改后的（非零）页数可能会在所有数据之前到达磁盘表面。数据将首先被写入，但是SQLite假定基础文件系统可以重新排序写入请求，并且即使其写入请求最后发生，页数也可​​以被首先烧入氧化物。因此，作为第二道防线，SQLite还对回滚日志中的每一页数据使用32位校验和。如&lt;a href=&quot;#section_4_4&quot;&gt;第4.4节&lt;/a&gt;所述，在回滚期间，同时回滚日志时，将为每一页评估此校验和。。如果看到错误的校验和，则放弃回滚。请注意，校验和不能保证页面数据是正确的，因为即使数据损坏，校验和也可能是正确的概率很小，但有限。但是校验和至少不会使这种错误发生。</target>
        </trans-unit>
        <trans-unit id="095be1a2c22dcc1b72f1d8ee5a80821a8e3ba1f7" translate="yes" xml:space="preserve">
          <source>The default value for SQLITE_PRINTF_PRECISION_LIMIT is 2147483647 (0x7fffffff).</source>
          <target state="translated">SQLITE_PRINTF_PRECISION_LIMIT的默认值是2147483647 (0x7fffffff)。</target>
        </trans-unit>
        <trans-unit id="5887e5cef0e652ea249c383a61a9790399db5025" translate="yes" xml:space="preserve">
          <source>The default value for languageid is 0. If an alternative language is specified in WHERE clause constraints, then that alternative is used instead of 0. There can only be a single languageid per query. In other words, the WHERE clause cannot contain a range constraint or IN operator on the languageid.</source>
          <target state="translated">languageid的默认值是0,如果在WHERE子句约束中指定了一个替代语言,那么就会使用该替代语言代替0。 每个查询只能有一个语言id。换句话说,WHERE子句不能包含范围约束或语言id的IN操作符。</target>
        </trans-unit>
        <trans-unit id="3d6f85ef321cfdfaecfbd8525333d39487f3c884" translate="yes" xml:space="preserve">
          <source>The default value of a languageid column is 0. Any value inserted into a languageid column is converted to a 32-bit (not 64) signed integer.</source>
          <target state="translated">languageid列的默认值是0,任何插入到languageid列的值都会被转换为32位(不是64位)有符号的整数。</target>
        </trans-unit>
        <trans-unit id="0bb45f8540234b96b45cb058d442c35d3ea03bfa" translate="yes" xml:space="preserve">
          <source>The default value of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter is 1, which means to store temporary files on disk but provide the option of overriding the behavior using the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;编译时参数的默认值为1，这意味着将临时文件存储在磁盘上，但提供了使用&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;覆盖行为的选项。</target>
        </trans-unit>
        <trans-unit id="3aae70c9121f536fa334d3f452170e8968ea3458" translate="yes" xml:space="preserve">
          <source>The default value of the usermerge option is 4. The minimum allowed value is 2, and the maximum 16.</source>
          <target state="translated">usermerge选项的默认值是4,允许的最小值是2,最大值是16。</target>
        </trans-unit>
        <trans-unit id="6973079b710b23783ded0a80f07fc117f677c334" translate="yes" xml:space="preserve">
          <source>The default virtual table (&quot;rtree&quot;) normally stores coordinates as single-precision (4-byte) floating point numbers. If integer coordinates are desired, declare the table using &quot;rtree_i32&quot; instead:</source>
          <target state="translated">默认的虚拟表(&quot;rtree&quot;)通常将坐标存储为单精度(4字节)浮点数。如果需要整数坐标,请使用 &quot;rtree_i32 &quot;来声明该表。</target>
        </trans-unit>
        <trans-unit id="f282a44d7dfb6c6134a7e29df48c07aa44737ff7" translate="yes" xml:space="preserve">
          <source>The demonstration code assumes that the SQLite database is opened used as a database object named &quot;db&quot;.</source>
          <target state="translated">演示代码假设打开的SQLite数据库使用的是名为 &quot;db &quot;的数据库对象。</target>
        </trans-unit>
        <trans-unit id="8837968f443dfe5005184f2c6a7e1c74103e5e88" translate="yes" xml:space="preserve">
          <source>The demonstration code below includes a status_refresh method that grays-out or activates the Undo and Redo buttons and menu entries depending on whether or not there is anything to be undone or redone. You will need to redefine this method to control the Undo and Redo buttons in your application.</source>
          <target state="translated">下面的演示代码包含了一个status_refresh方法,该方法根据是否有任何需要撤销或重做的东西来灰化或激活Undo和Redo按钮和菜单项。你需要重新定义这个方法来控制应用程序中的Undo和Redo按钮。</target>
        </trans-unit>
        <trans-unit id="e759858c504e056da064aff365282dc111db1fea" translate="yes" xml:space="preserve">
          <source>The depth of recursion for triggers has a hard upper limit set by the &lt;a href=&quot;limits#max_trigger_depth&quot;&gt;SQLITE_MAX_TRIGGER_DEPTH&lt;/a&gt; compile-time option and a run-time limit set by &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimittriggerdepth&quot;&gt;SQLITE_LIMIT_TRIGGER_DEPTH&lt;/a&gt;,...).</source>
          <target state="translated">触发器的递归深度具有由&lt;a href=&quot;limits#max_trigger_depth&quot;&gt;SQLITE_MAX_TRIGGER_DEPTH&lt;/a&gt;编译时选项设置的硬上限和由&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db，&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimittriggerdepth&quot;&gt;SQLITE_LIMIT_TRIGGER_DEPTH&lt;/a&gt;，...）设置的运行时限制。</target>
        </trans-unit>
        <trans-unit id="40be115b96b882b5a59636c2c2b3cce3bdbb02d6" translate="yes" xml:space="preserve">
          <source>The descendants of OpenOffice tend to segfault more often than commercial competitors. Perhaps for this reason, the OpenOffice forks make periodic backups of their in-memory documents so that users do not lose all pending edits when the inevitable application crash does occur. This causes frustrating pauses in the application for the few seconds while each backup is being made. After restarting from a crash, the user is presented with a dialog box that walks them through the recovery process. Managing the crash recovery this way involves lots of extra application logic and is generally an annoyance to the user.</source>
          <target state="translated">OpenOffice的后裔往往比商业竞争者更经常发生segfault。也许是因为这个原因,OpenOffice的分叉会定期备份其内存中的文档,这样当不可避免的应用程序崩溃时,用户就不会失去所有尚未完成的编辑。这将导致应用程序在每次备份时的几秒钟内出现令人沮丧的暂停。从崩溃中重新启动后,用户会看到一个对话框,引导他们完成恢复过程。以这种方式管理崩溃恢复涉及大量额外的应用程序逻辑,通常会给用户带来烦恼。</target>
        </trans-unit>
        <trans-unit id="2a2b8799305e9ca9fdc0f3b11f07bd75b53378d6" translate="yes" xml:space="preserve">
          <source>The designed query interface is:</source>
          <target state="translated">设计的查询界面是。</target>
        </trans-unit>
        <trans-unit id="85d6b31a6dd13fa4a2b19e14c162e00851337050" translate="yes" xml:space="preserve">
          <source>The detail option may be set to &quot;full&quot; (the default value), &quot;column&quot; or &quot;none&quot;. For example:</source>
          <target state="translated">详细选项可以设置为 &quot;全&quot;(默认值)、&quot;列 &quot;或 &quot;无&quot;。例如:</target>
        </trans-unit>
        <trans-unit id="1de34563fa7a58730a8b8b8a025ab7bdcb0a2940" translate="yes" xml:space="preserve">
          <source>The details of optimizations performed by this pragma are expected to change and improve over time. Applications should anticipate that this pragma will perform new optimizations in future releases.</source>
          <target state="translated">此pragma执行的优化细节预计会随着时间的推移而改变和改进。应用程序应预计该Pragma将在未来的版本中执行新的优化。</target>
        </trans-unit>
        <trans-unit id="2ec6e7a356da9ba89cc679a27100e250b07d2b68" translate="yes" xml:space="preserve">
          <source>The details of the behavior of the sqlite3_step() interface depend on whether the statement was prepared using the newer &quot;vX&quot; interfaces &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; or the older legacy interfaces &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;. The use of the new &quot;vX&quot; interface is recommended for new applications but the legacy interface will continue to be supported.</source>
          <target state="translated">在sqlite3_step（）接口的行为的细节取决于该陈述是否是使用较新的&amp;ldquo;VX&amp;rdquo;接口编写&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3（） &lt;/a&gt;，&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（） &lt;/a&gt;，&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3（） &lt;/a&gt;，&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;或旧的遗留接口&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16 （）&lt;/a&gt;。建议对新应用程序使用新的&amp;ldquo; vX&amp;rdquo;界面，但仍会继续支持旧界面。</target>
        </trans-unit>
        <trans-unit id="a66564cccde706fd2f76931336faa29d5380763d" translate="yes" xml:space="preserve">
          <source>The details of the behavior of the sqlite3_step() interface depend on whether the statement was prepared using the newer &quot;vX&quot; interfaces &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; or the older legacy interfaces &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; and &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;. The use of the new &quot;vX&quot; interface is recommended for new applications but the legacy interface will continue to be supported.</source>
          <target state="translated">在sqlite3_step（）接口的行为的细节取决于该陈述是否是使用较新的&amp;ldquo;VX&amp;rdquo;接口编写&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3（） &lt;/a&gt;，&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（） &lt;/a&gt;，&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3（） &lt;/a&gt;，&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;或旧的遗留接口&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;和&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16 （）&lt;/a&gt;。建议对新应用程序使用新的&amp;ldquo; vX&amp;rdquo;界面，但仍会继续支持旧界面。</target>
        </trans-unit>
        <trans-unit id="d328873bfc7a5d2f8f59abeab740350558a37fbf" translate="yes" xml:space="preserve">
          <source>The details of the effects of the analysis limit described in the previous paragraph are subject to change in future versions of SQLite. But the core idea will remain the same. An analysis limit of N will strive to limit the number of rows visited in each index to approximately N.</source>
          <target state="translated">前一段描述的分析限制的效果细节,在SQLite的未来版本中可能会发生变化。但核心思想将保持不变。分析限制为N,将努力把每个索引中访问的行数限制在大约N的范围内。</target>
        </trans-unit>
        <trans-unit id="47cfb6e87da2bbb4d38b35a83664b9fdcddd81cb" translate="yes" xml:space="preserve">
          <source>The details of the operation codes, their meanings, the parameters they take, and what they do are all subject to change without notice. Unlike most of the SQLite API, this function is not guaranteed to operate consistently from one release to the next.</source>
          <target state="translated">操作代码的细节、它们的含义、它们所取的参数以及它们所做的事情都可能会发生变化,恕不另行通知。与大多数SQLite API不同的是,这个函数不能保证在不同的版本中操作一致。</target>
        </trans-unit>
        <trans-unit id="dd71fb5d39136060492d732375a6fec71ebfc8ad" translate="yes" xml:space="preserve">
          <source>The developers are also on the lookout for new ways to optimize the commit mechanism. The current VFS implementations for Unix (Linux and Mac OS X) and Windows make pessimistic assumptions about the behavior of those systems. After consultation with experts on how these systems work, we might be able to relax some of the assumptions on these systems and allow them to run faster. In particular, we suspect that most modern filesystems exhibit the safe append property and that many of them might support atomic sector writes. But until this is known for certain, SQLite will take the conservative approach and assume the worst.</source>
          <target state="translated">开发者也在寻找优化提交机制的新方法。目前Unix(Linux和Mac OS X)和Windows的VFS实现对这些系统的行为做出了悲观的假设。在咨询了这些系统的工作方式的专家后,我们或许可以放宽这些系统的一些假设,让它们运行得更快。特别是,我们怀疑大多数现代文件系统表现出安全追加属性,而且其中许多系统可能支持原子扇区写入。但在确定这一点之前,SQLite将采取保守的方法,并做最坏的假设。</target>
        </trans-unit>
        <trans-unit id="e4066095f770552d7d59a59bea4105aa7d61a017" translate="yes" xml:space="preserve">
          <source>The developers have no editorial influence on the content of CVEs, and they do not like to be controlled by groups in which they have no voice.</source>
          <target state="translated">开发商对CVE的内容没有编辑影响力,他们不喜欢被没有发言权的群体控制。</target>
        </trans-unit>
        <trans-unit id="cba4f98976654b480368200cf64e4d7ca1caf336" translate="yes" xml:space="preserve">
          <source>The developers of SQLite are confident that it is robust in the face of power failures and system crashes because the automatic test procedures do extensive checks on the ability of SQLite to recover from simulated power loss. We call these the &quot;crash tests&quot;.</source>
          <target state="translated">SQLite的开发者对它在面对断电和系统崩溃时的稳健性很有信心,因为自动测试程序对SQLite从模拟断电中恢复的能力进行了广泛的检查。我们称这些为 &quot;崩溃测试&quot;。</target>
        </trans-unit>
        <trans-unit id="57e3f42d8aa639c2f77c64f6029c9126e99e122e" translate="yes" xml:space="preserve">
          <source>The developers of SQLite have found that full coverage testing is an extremely effective method for locating and preventing bugs. Because every single branch instruction in SQLite core code is covered by test cases, the developers can be confident that changes made in one part of the code do not have unintended consequences in other parts of the code. The many new features and performance improvements that have been added to SQLite in recent years would not have been possible without the availability full-coverage testing.</source>
          <target state="translated">SQLite的开发人员发现,全覆盖测试是一种极其有效的定位和预防错误的方法。因为SQLite核心代码中的每一条分支指令都被测试用例所覆盖,开发人员可以确信在代码的某一部分所做的更改不会在代码的其他部分产生意想不到的后果。如果没有可用性全覆盖测试,近年来SQLite增加的许多新功能和性能改进是不可能的。</target>
        </trans-unit>
        <trans-unit id="c6e54cb667da50110192519bd611d69d7d2d59cd" translate="yes" xml:space="preserve">
          <source>The developers of SQLite intend to support the product through the year 2050. To this end, the source code is carefully documented to promote long-term maintainability. We prefer mature and stable over trendy and cutting-edge.</source>
          <target state="translated">SQLite的开发者打算支持该产品到2050年。为此,我们对源代码进行了仔细的记录,以促进长期的可维护性。比起时髦和前沿,我们更喜欢成熟稳定的产品。</target>
        </trans-unit>
        <trans-unit id="6b11572798416066a74cf3226912c7c4d4e245c6" translate="yes" xml:space="preserve">
          <source>The developers often do not find out about CVEs until long after the bug is fixed. You can see this by the fact that many CVEs reference the bug fix in their initial report.</source>
          <target state="translated">开发者往往在错误修复后很久才发现CVEs。你可以从许多CVE在他们的初始报告中引用错误修复这一事实中看出这一点。</target>
        </trans-unit>
        <trans-unit id="aa1c82e2078fb346e28f27499859e5261dd7cb0d" translate="yes" xml:space="preserve">
          <source>The diagram above implies that SQLite computes all of the rowids first and then combines them with a union operation before starting to do rowid lookups on the original table. In reality, the rowid lookups are interspersed with rowid computations. SQLite uses one index at a time to find rowids while remembering which rowids it has seen before so as to avoid duplicates. That is just an implementation detail, though. The diagram, while not 100% accurate, provides a good overview of what is happening.</source>
          <target state="translated">上图暗示SQLite先计算所有的rowid,然后用union操作将它们组合起来,再开始对原表进行rowid查找。实际上,rowid查找与rowid计算是穿插进行的。SQLite每次使用一个索引来查找rowid,同时记住之前看过哪些rowid,以避免重复。不过这只是一个实现细节。这张图虽然不是100%的准确,但它提供了一个很好的概述。</target>
        </trans-unit>
        <trans-unit id="cc06f8d8201603f348e84ed00b97e2bebb250253" translate="yes" xml:space="preserve">
          <source>The diagram at the right illustrates the concept. One begins with a standard SQLite release. For the sake of example, suppose that one intends to create a private branch off of SQLite version 3.6.15. In the diagram this is version (1). The maintainer makes an exact copy of the baseline SQLite into the branch space, shown as version (2). Note that (1) and (2) are exactly the same. Then the maintainer applies the private changes to version (2) resulting in version (3). In other words, version (3) is SQLite version 3.6.15 plus edits.</source>
          <target state="translated">右图说明了这个概念。首先是一个标准的SQLite版本。为了举例说明,假设我们打算在SQLite 3.6.15版本上创建一个私有分支。在图中,这是版本(1)。维护者将基线SQLite复制到分支空间,显示为版本(2)。请注意,(1)和(2)是完全一样的。然后,维护者将私有的变化应用到版本(2)中,产生版本(3)。换句话说,版本(3)是SQLite 3.6.15加上编辑的版本。</target>
        </trans-unit>
        <trans-unit id="7b170d383461e4dd7d9f55e0934f811bdf7d240b" translate="yes" xml:space="preserve">
          <source>The difference between reading from the rank column and using the bm25() function directly within the query is only significant when sorting by the returned value. In this case, using &quot;rank&quot; is faster than using bm25().</source>
          <target state="translated">从rank列中读取和直接在查询中使用bm25()函数之间的区别,只有在按返回值排序时才有明显的区别。在这种情况下,使用 &quot;rank &quot;比使用bm25()快。</target>
        </trans-unit>
        <trans-unit id="9a6b573084b906296ca61d103b50efb82fd91899" translate="yes" xml:space="preserve">
          <source>The difference between this option and the 'automerge' option is that when the 'automerge' limit is reached FTS5 only begins to merge the b-trees together. Most of the work is performed as part of subsequent INSERT, UPDATE or DELETE operations. Whereas when the 'crisismerge' limit is reached, the offending b-trees are all merged immediately. This means that an INSERT, UPDATE or DELETE that triggers a crisis-merge may take a long time to complete.</source>
          <target state="translated">这个选项和'automerge'选项的区别是,当达到'automerge'限制时,FTS5只开始合并b树。大部分工作是作为后续INSERT、UPDATE或DELETE操作的一部分。而当达到 &quot;危机合并 &quot;限制时,所有违规的b树都会立即被合并。这意味着,触发危机合并的INSERT、UPDATE或DELETE可能需要很长时间才能完成。</target>
        </trans-unit>
        <trans-unit id="6b73e10a6ce3d527b6333ec3f4b76095553830b9" translate="yes" xml:space="preserve">
          <source>The difference is that xConnect is called to establish a new connection to an existing virtual table whereas xCreate is called to create a new virtual table from scratch.</source>
          <target state="translated">不同的是,调用xConnect是为了给现有的虚拟表建立一个新的连接,而调用xCreate是为了从头开始创建一个新的虚拟表。</target>
        </trans-unit>
        <trans-unit id="2f41e80a4cb41a6cee44f4eaec98226e9c29f84f" translate="yes" xml:space="preserve">
          <source>The differences between a patchset and a changeset are that:</source>
          <target state="translated">补丁集和变化集的区别在于:1:</target>
        </trans-unit>
        <trans-unit id="4fa2acc79952a3a20f72fc7c3e0f092b1e96e820" translate="yes" xml:space="preserve">
          <source>The differences between an &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TEMP_DB&lt;/a&gt; database and an &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TRANSIENT_DB&lt;/a&gt; database is this: The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TEMP_DB&lt;/a&gt; is used for explicitly declared and named TEMP tables (using the CREATE TEMP TABLE syntax) or for named tables in a temporary database that is created by opening a database with a filename that is an empty string. An &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TRANSIENT_DB&lt;/a&gt; holds a database table that SQLite creates automatically in order to evaluate a subquery or ORDER BY or GROUP BY clause. Both TEMP_DB and TRANSIENT_DB databases are private and are deleted automatically. TEMP_DB databases last for the duration of the database connection. TRANSIENT_DB databases last only for the duration of a single SQL statement.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TEMP_DB&lt;/a&gt;数据库和&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TRANSIENT_DB&lt;/a&gt;数据库之间的区别是：&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TEMP_DB&lt;/a&gt;用于显式声明和命名的TEMP表（使用CREATE TEMP TABLE语法），或用于通过打开具有文件名的数据库而创建的临时数据库中的命名表。那是一个空字符串。一个&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TRANSIENT_DB&lt;/a&gt;认为，SQLite的，以评估BY子句的子查询或ORDER BY或GROUP会自动创建一个数据库表。 TEMP_DB和TRANSIENT_DB数据库都是私有数据库，会自动删除。 TEMP_DB数据库在数据库连接期间一直持续。 TRANSIENT_DB数据库仅在单个SQL语句的持续时间内持续。</target>
        </trans-unit>
        <trans-unit id="ea188c1a8a3d9f0d3afac3d8adfd72df27cd7aa2" translate="yes" xml:space="preserve">
          <source>The direct-to-disk writes are accomplished using fopen()/fwrite()/fclose(). By default, and in all the results shown below, the OS filesystem buffers are never flushed to persistent storage using fsync() or FlushFileBuffers(). In other words, there is no attempt to make the direct-to-disk writes transactional or power-safe. We found that invoking fsync() or FlushFileBuffers() on each file written causes direct-to-disk storage to be about 10 times or more slower than writes to SQLite.</source>
          <target state="translated">直接到磁盘的写入是使用fopen()/fwrite()/fclose()来完成的。默认情况下,在下面显示的所有结果中,操作系统的文件系统缓冲区从未使用fsync()或FlushFileBuffers()刷新到持久化存储。换句话说,没有试图使直接到磁盘的写入是事务性的或电源安全的。我们发现,在每个写入的文件上调用fsync()或FlushFileBuffers()会导致直接到磁盘存储的速度比写入SQLite慢10倍或更多。</target>
        </trans-unit>
        <trans-unit id="480bdad0842ce92215a602c8e8a2e2ba5036d89a" translate="yes" xml:space="preserve">
          <source>The directory or folder in which temporary files are created is determined by the OS-specific &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;.</source>
          <target state="translated">在其中创建临时文件的目录或文件夹由操作系统特定的&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;确定。</target>
        </trans-unit>
        <trans-unit id="58c1fd9cf0b8fae2622f0a1831b48a0d95eaabc6" translate="yes" xml:space="preserve">
          <source>The directory set by &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt; or by the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable</source>
          <target state="translated">由&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt;或&lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;全局变量设置的目录</target>
        </trans-unit>
        <trans-unit id="8e347995ace178c5b68534f7a6dde94c35392830" translate="yes" xml:space="preserve">
          <source>The directory used to hold temporary files on unix can now be set using the SQLITE_TMPDIR environment variable, which takes precedence over the TMPDIR environment variable. The &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable still has higher precedence than both environment variables, however.</source>
          <target state="translated">现在可以使用SQLITE_TMPDIR环境变量来设置用于在Unix上保留临时文件的目录，该目录优先于TMPDIR环境变量。但是，&lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;全局变量的优先级仍然高于两个环境变量。</target>
        </trans-unit>
        <trans-unit id="081d4a11583041f4e8625a8cc56c88ce7150faa6" translate="yes" xml:space="preserve">
          <source>The docid value. The first entry in a doclist contains the literal docid value. The first field of each subsequent doclist entry contains the difference between the new docid and the previous one (always a positive number).</source>
          <target state="translated">docid值。doclist的第一个条目包含docid的字面值。后续每一个doclist条目的第一个字段包含新的docid和前一个的差值(总是一个正数)。</target>
        </trans-unit>
        <trans-unit id="49e2bf067b92acf951896b04368654ffcd3a3f99" translate="yes" xml:space="preserve">
          <source>The document only describes locking for the older rollback-mode transaction mechanism. Locking for the newer &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; or &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is described separately.</source>
          <target state="translated">该文档仅描述了针对较旧的回滚模式事务处理机制的锁定。单独描述了用于较新的&lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt;或&lt;a href=&quot;wal&quot;&gt;WAL模式的&lt;/a&gt;锁定。</target>
        </trans-unit>
        <trans-unit id="1297878fc527d5d7c17142be2f4f043e484d8aa6" translate="yes" xml:space="preserve">
          <source>The documentation is maintained in separate source repositories on those same servers:</source>
          <target state="translated">这些文档在这些服务器上的单独的源码库中维护。</target>
        </trans-unit>
        <trans-unit id="d0017ab9193a6ed1029ad59fab58ce3ec88e592f" translate="yes" xml:space="preserve">
          <source>The documentation sources include documentation text and images with the scripts and makefile needed to construct the SQLite website documentation. This document is contained within the documentation sources. The document sources are kept in a separate repository distinct from the source code. The documentation sources repository is publicly readable.</source>
          <target state="translated">文档源包括文档文本和图片,以及构建SQLite网站文档所需的脚本和makefile。该文档包含在文档源中。文档源保存在一个独立的存储库中,与源代码不同。文档源存储库是可以公开阅读的。</target>
        </trans-unit>
        <trans-unit id="278f1b137f0865ba684c7cde1fa14cf1c768e813" translate="yes" xml:space="preserve">
          <source>The documentation system automatically maintains a &lt;a href=&quot;https://sqlite.org/chronology.html&quot;&gt;chronology&lt;/a&gt; of past releases, as well as a &lt;a href=&quot;changes&quot;&gt;complete list of SQLite releases&lt;/a&gt; with change summaries.</source>
          <target state="translated">文档系统会自动维护过去版本的&lt;a href=&quot;https://sqlite.org/chronology.html&quot;&gt;时间顺序&lt;/a&gt;，以及带有变更摘要&lt;a href=&quot;changes&quot;&gt;的SQLite版本&lt;/a&gt;的完整列表。</target>
        </trans-unit>
        <trans-unit id="65988e654b808af94ee6da6f09345ac1241a1ac8" translate="yes" xml:space="preserve">
          <source>The dot-command must be entirely contained on a single input line.</source>
          <target state="translated">点阵命令必须完全包含在一个输入行中。</target>
        </trans-unit>
        <trans-unit id="6fcffd0a57b5ba6715e1715a67438a136bebf610" translate="yes" xml:space="preserve">
          <source>The dot-commands are interpreted by the sqlite3.exe command-line program, not by SQLite itself. So none of the dot-commands will work as an argument to SQLite interfaces like &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;.</source>
          <target state="translated">点命令由sqlite3.exe命令行程序解释，而不由SQLite本身解释。因此，任何点命令都不能用作&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;或&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）之&lt;/a&gt;类的SQLite接口的参数。</target>
        </trans-unit>
        <trans-unit id="73b101a4a2aed2c88c1089ef5e27eb7bd916289f" translate="yes" xml:space="preserve">
          <source>The downside of automatic incremental merging is that it makes every INSERT, UPDATE, and DELETE operation on an FTS3/4 table run a little slower, since extra time must be used to do the incremental merge. For maximum performance, it is recommended that applications disable automatic incremental merge and instead use the &lt;a href=&quot;fts3#*fts4mergecmd&quot;&gt;&quot;merge&quot; command&lt;/a&gt; in an idle process to keep the inverted indices well merged. But if the structure of an application does not easily allow for idle processes, the use of automatic incremental merge is a very reasonable fallback solution.</source>
          <target state="translated">自动增量合并的缺点是，由于必须花费额外的时间来进行增量合并，因此它会使FTS3 / 4表上的每个INSERT，UPDATE和DELETE操作都慢一些。为了获得最佳性能，建议应用程序禁用自动增量合并，而应在空闲过程中使用&lt;a href=&quot;fts3#*fts4mergecmd&quot;&gt;&amp;ldquo; merge&amp;rdquo;命令&lt;/a&gt;来保持反向索引良好地合并。但是，如果应用程序的结构不容易允许空闲进程，则使用自动增量合并是一种非常合理的后备解决方案。</target>
        </trans-unit>
        <trans-unit id="c77ebced48dfa7e23a77c44a167057f7558d4f17" translate="yes" xml:space="preserve">
          <source>The downside of storing schema a text is that it can make the schema tricky to modify. And for that reason, the ALTER TABLE support in SQLite has traditionally lagged behind other SQL database engines that store their schemas as parsed system tables that are easier to modify.</source>
          <target state="translated">将schema存储为文本的缺点是会使schema的修改变得棘手。而由于这个原因,SQLite中的ALTER TABLE支持历来落后于其他SQL数据库引擎,因为其他SQL数据库引擎将模式存储为解析的系统表,更容易修改。</target>
        </trans-unit>
        <trans-unit id="1bd6a18e90f1a8ee8256e02fe4825c2a58f166f7" translate="yes" xml:space="preserve">
          <source>The dynamic webpages on the SQLite website are mostly generated by the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil version control system&lt;/a&gt;. A typical dynamic page would be a timeline such as &lt;a href=&quot;https://www.sqlite.org/src/timeline&quot;&gt;https://www.sqlite.org/src/timeline&lt;/a&gt;. A log of all SQL used by the timeline is shown below.</source>
          <target state="translated">SQLite网站上的动态网页主要由&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil版本控制系统&lt;/a&gt;生成。典型的动态页面是时间轴，例如&lt;a href=&quot;https://www.sqlite.org/src/timeline&quot;&gt;https://www.sqlite.org/src/timeline&lt;/a&gt;。时间轴使用的所有SQL的日志如下所示。</target>
        </trans-unit>
        <trans-unit id="f53c608dfb99715244babeb0f18e6bedb4ce61c6" translate="yes" xml:space="preserve">
          <source>The eTextRep argument determines the encoding of strings passed to the collating function callback, xCallback. The &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; and &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; values for eTextRep force strings to be UTF16 with native byte order. The &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; value for eTextRep forces strings to begin on an even byte address.</source>
          <target state="translated">eTextRep参数确定传递到整理函数回调xCallback的字符串的编码。该&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;和&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt;为eTextRep力的字符串值是UTF-16与本地字节顺序。该&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt;为eTextRep力的字符串值，开始在偶数字节地址。</target>
        </trans-unit>
        <trans-unit id="1f8a73896c29d2961fd12e3fd13060416db06dbd" translate="yes" xml:space="preserve">
          <source>The eTextRep argument determines the encoding of strings passed to the collating function callback, xCallback. The &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; and &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; values for eTextRep force strings to be UTF16 with native byte order. The &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; value for eTextRep forces strings to begin on an even byte address.</source>
          <target state="translated">eTextRep参数确定传递到整理函数回调xCallback的字符串的编码。该&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;和&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt;为eTextRep力的字符串值是UTF-16与本地字节顺序。该&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt;为eTextRep力的字符串值，开始在偶数字节地址。</target>
        </trans-unit>
        <trans-unit id="4013154ef9b1afc10a2efd1408a9638085e650fc" translate="yes" xml:space="preserve">
          <source>The eTextRep argument determines the encoding of strings passed to the collating function callback, xCompare. The &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; and &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; values for eTextRep force strings to be UTF16 with native byte order. The &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; value for eTextRep forces strings to begin on an even byte address.</source>
          <target state="translated">eTextRep参数确定传递到整理函数回调xCompare的字符串的编码。该&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;和&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt;为eTextRep力的字符串值是UTF-16与本地字节顺序。该&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt;为eTextRep力的字符串值，开始在偶数字节地址。</target>
        </trans-unit>
        <trans-unit id="7222f354f082d59aa96eba0376b7b091cc4ec0bd" translate="yes" xml:space="preserve">
          <source>The eTextRep argument determines the encoding of strings passed to the collating function callback, xCompare. The &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; and &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; values for eTextRep force strings to be UTF16 with native byte order. The &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; value for eTextRep forces strings to begin on an even byte address.</source>
          <target state="translated">eTextRep参数确定传递到整理函数回调xCompare的字符串的编码。该&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;和&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt;为eTextRep力的字符串值是UTF-16与本地字节顺序。该&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt;为eTextRep力的字符串值，开始在偶数字节地址。</target>
        </trans-unit>
        <trans-unit id="af71ae840c72707272be3031b3c3ee6f45c5d71f" translate="yes" xml:space="preserve">
          <source>The edit distance coefficients are normally read from the APPCOST table once and there after stored in memory. Hence, run-time changes to the APPCOST table will not normally affect the edit distance results. However, inserting the special string 'reset' into the &quot;command&quot; column of the virtual table causes the edit distance coefficients to be reread the APPCOST table. Hence, applications should run a SQL statement similar to the following when changes to the APPCOST table occur:</source>
          <target state="translated">编辑距离系数通常从APPCOST表中读取一次,然后存储在内存中。因此,运行时对APPCOST表的修改通常不会影响编辑距离结果。但是,在虚拟表的 &quot;命令 &quot;列中插入特殊字符串 &quot;复位 &quot;会导致重新读取APPCOST表的编辑距离系数。因此,当APPCOST表发生变化时,应用程序应该运行类似于以下的SQL语句。</target>
        </trans-unit>
        <trans-unit id="49994af0743488763f79d75d2c9c86ebfda2dfb6" translate="yes" xml:space="preserve">
          <source>The edit program can also be used as a viewer, by simply ignoring the return value. For example, to merely look at the image above, you might run:</source>
          <target state="translated">编辑程序也可以作为查看器使用,只要忽略返回值即可。例如,如果只是看上面的图片,你可以运行。</target>
        </trans-unit>
        <trans-unit id="47a4a763ba31495e47240c644f7558e9498bae30" translate="yes" xml:space="preserve">
          <source>The edit() function can be used to make changes to large text values. For example:</source>
          <target state="translated">edit()函数可以用来对大文本值进行修改。例如:&quot;edit()&quot;函数可以用来修改大的文本值。</target>
        </trans-unit>
        <trans-unit id="fd34f0d751c4ddc69b221f64ffd45f8927b66781" translate="yes" xml:space="preserve">
          <source>The editdist3 algorithm is a function that computes the minimum edit distance (a.k.a. the Levenshtein distance) between two input strings. The editdist3 algorithm is a configurable alternative to the default edit distance function of spellfix1. Features of editdist3 include:</source>
          <target state="translated">editdist3 算法是一个计算两个输入字符串之间最小编辑距离(也就是 Levenshtein 距离)的函数。editdist3算法是spellfix1的默认编辑距离函数的一个可配置的替代品。editdist3的功能包括</target>
        </trans-unit>
        <trans-unit id="870b1bf5bd7c0178ecc9a04d5313cc57bc40b4f1" translate="yes" xml:space="preserve">
          <source>The effects of a &lt;b&gt;truncate file&lt;/b&gt; operation are not assumed to be made persistent until after the corresponding file has been</source>
          <target state="translated">&lt;b&gt;截断文件&lt;/b&gt;操作的效果直到相应文件被删除后才被认为是持久的。</target>
        </trans-unit>
        <trans-unit id="393d1077fa976da06b2c81028e0e667751bfce07" translate="yes" xml:space="preserve">
          <source>The empty-result-callbacks flag affects the &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; API only. Normally, when the empty-result-callbacks flag is cleared, the callback function supplied to the &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; is not invoked for commands that return zero rows of data. When empty-result-callbacks is set in this situation, the callback function is invoked exactly once, with the third parameter set to 0 (NULL). This is to enable programs that use the &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; API to retrieve column-names even when a query returns no data.</source>
          <target state="translated">empty-result-callbacks标志仅影响&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt; API。通常，当清除empty-result-callbacks标志时，不会为返回零行数据的命令调用提供给&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;的回调函数。如果在这种情况下设置了empty-result-callbacks，则将回调函数仅调用一次，第三个参数设置为0（NULL）。这是为了使使用&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt; API的程序即使在查询不返回任何数据时也可以检索列名。</target>
        </trans-unit>
        <trans-unit id="f1a25180fc453bfc9b7157e5b028aa8235fc10f5" translate="yes" xml:space="preserve">
          <source>The end-user executes DML or DDL SQL statements that require the structure of the database file of the database file to be modified. These modifications may be any combination of operations to</source>
          <target state="translated">最终用户执行DML或DDL SQL语句,需要对数据库文件的结构进行修改。这些修改可以是任意组合的操作,以达到</target>
        </trans-unit>
        <trans-unit id="5b923462226ca9a3f1ea2da34aa276431384d659" translate="yes" xml:space="preserve">
          <source>The ending frame boundary can be omitted (if the BETWEEN and AND keywords that surround the starting frame boundary are also omitted), in which case the ending frame boundary defaults to CURRENT ROW.</source>
          <target state="translated">结束帧边界可以省略(如果包围起始帧边界的BETWEEN和AND关键字也被省略的话),在这种情况下,结束帧边界默认为CURRENT ROW。</target>
        </trans-unit>
        <trans-unit id="b26c1d5670afb707a661dd133bd85c139805e555" translate="yes" xml:space="preserve">
          <source>The ending frame boundary may not take a form that appears higher in the above list than the starting frame boundary.</source>
          <target state="translated">结束帧边界的形式不得高于上述列表中的起始帧边界。</target>
        </trans-unit>
        <trans-unit id="1133a1a20cf9f9901ca7376082c18ed0b6c4a36d" translate="yes" xml:space="preserve">
          <source>The engine no longer consults the main table if it can get all the information it needs from an index.</source>
          <target state="translated">如果能从索引中获得所需的所有信息,引擎就不再查询主表。</target>
        </trans-unit>
        <trans-unit id="b873e4983f185f34587580faeee301ccc43a5a88" translate="yes" xml:space="preserve">
          <source>The enhanced query syntax supports the AND, OR and NOT binary set operators. Each of the two operands to an operator may be a basic FTS query, or the result of another AND, OR or NOT set operation. Operators must be entered using capital letters. Otherwise, they are interpreted as basic term queries instead of set operators.</source>
          <target state="translated">增强型查询语法支持AND、OR和NOT二进制集运算符。操作符的两个操作数中的每一个都可以是一个基本的FTS查询,或者是另一个AND、OR或NOT集操作的结果。操作符必须用大写字母输入。否则,它们将被解释为基本术语查询,而不是集合运算符。</target>
        </trans-unit>
        <trans-unit id="ec0a2d5aa63b2e3b719340bb237dcfc9aebe4443" translate="yes" xml:space="preserve">
          <source>The entries above might represent (for example) a bounding box around the main office for SQLite.org and bounding box around the 12th Congressional District of North Carolina (prior to the 2011 redistricting) in which SQLite.org was located.</source>
          <target state="translated">上面的条目可能代表(例如)SQLite.org主办公室周围的边界框和SQLite.org所在的北卡罗来纳州第12个国会选区(在2011年重新划分之前)周围的边界框。</target>
        </trans-unit>
        <trans-unit id="df23c9e0d03ef84c1b3ecc39ad637f8b14bf70ea" translate="yes" xml:space="preserve">
          <source>The entry point is zProc. zProc may be 0, in which case SQLite will try to come up with an entry point name on its own. It first tries &quot;sqlite3_extension_init&quot;. If that does not work, it constructs a name &quot;sqlite3_X_init&quot; where the X is consists of the lower-case equivalent of all ASCII alphabetic characters in the filename from the last &quot;/&quot; to the first following &quot;.&quot; and omitting any initial &quot;lib&quot;. The sqlite3_load_extension() interface returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if something goes wrong. If an error occurs and pzErrMsg is not 0, then the &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface shall attempt to fill *pzErrMsg with error message text stored in memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The calling function should free this memory by calling &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">入口点是zProc。 zProc可能为0，在这种情况下，SQLite会尝试自行提出入口点名称。首先尝试&amp;ldquo; sqlite3_extension_init&amp;rdquo;。如果不起作用，它将构造一个名称&amp;ldquo; sqlite3_X_init&amp;rdquo;，其中X由文件名中所有ASCII字母字符的小写形式等效，从最后一个&amp;ldquo; /&amp;rdquo;到其后的第一个&amp;ldquo;&amp;rdquo;。并省略任何初始的&amp;ldquo; lib&amp;rdquo;。该sqlite3_load_extension（）接口返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;成功和&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;如果出现错误。如果发生错误并且pzErrMsg不为0，则&lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;接口应尝试使用从&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;获取的存储在错误消息中的文本填充* pzErrMsg。。调用函数应通过调用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放此内存。</target>
        </trans-unit>
        <trans-unit id="4f2e7b718e4064a2f8cc8acbe7a051458f014ce0" translate="yes" xml:space="preserve">
          <source>The entry point is zProc. zProc may be 0, in which case SQLite will try to come up with an entry point name on its own. It first tries &quot;sqlite3_extension_init&quot;. If that does not work, it constructs a name &quot;sqlite3_X_init&quot; where the X is consists of the lower-case equivalent of all ASCII alphabetic characters in the filename from the last &quot;/&quot; to the first following &quot;.&quot; and omitting any initial &quot;lib&quot;. The sqlite3_load_extension() interface returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if something goes wrong. If an error occurs and pzErrMsg is not 0, then the &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface shall attempt to fill *pzErrMsg with error message text stored in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The calling function should free this memory by calling &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">入口点是zProc。 zProc可能为0，在这种情况下，SQLite会尝试自行提出入口点名称。首先尝试&amp;ldquo; sqlite3_extension_init&amp;rdquo;。如果不起作用，它将构造一个名称&amp;ldquo; sqlite3_X_init&amp;rdquo;，其中X由文件名中所有ASCII字母字符的小写形式等效，从最后一个&amp;ldquo; /&amp;rdquo;到其后的第一个&amp;ldquo;&amp;rdquo;。并省略任何初始的&amp;ldquo; lib&amp;rdquo;。该sqlite3_load_extension（）接口返回&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;成功和&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;如果出现错误。如果发生错误并且pzErrMsg不为0，则&lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;接口应尝试使用从&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;获取的存储在错误消息中的文本填充* pzErrMsg。。调用函数应通过调用&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放此内存。</target>
        </trans-unit>
        <trans-unit id="c3b2f6eda62654fcc0bcaa7e0b88feb088762bb7" translate="yes" xml:space="preserve">
          <source>The error arises because only about the first 15 significant digits of each number are stored accurately, and first the difference between the two numbers being subtracted is in the 16th digit.</source>
          <target state="translated">产生错误的原因是,每个数字中只有大约前15位有意义的数字被准确地存储,首先被减去的两个数字的差值在第16位。</target>
        </trans-unit>
        <trans-unit id="456b9f2431df57bc4265718d78e0c8afe5c20d2e" translate="yes" xml:space="preserve">
          <source>The error arises because only about the first 15 significant digits of each number are stored accurately, and the first difference between the two numbers being subtracted is in the 16th digit.</source>
          <target state="translated">产生错误的原因是每个数字中只有大约前15位有意义的数字被准确地存储,而被减的两个数字之间的第一个差值在第16位。</target>
        </trans-unit>
        <trans-unit id="40007c6bf4af7619580a2e5c3ec81a4fee4ad813" translate="yes" xml:space="preserve">
          <source>The error code is changed to &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; (instead of &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;) when an attempt is made to &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; while one or more queries are still pending.</source>
          <target state="translated">在一个或多个查询仍悬而未决的情况下尝试进行&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;时，错误代码将更改为&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;（而不是&lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2e60aa60ea376ea9ca807c8cc7d0b0b91ec054e5" translate="yes" xml:space="preserve">
          <source>The error codes for SQLite version 3 are unchanged from version 2. They are as follows:</source>
          <target state="translated">SQLite第3版的错误代码与第2版没有变化。这些错误代码如下:</target>
        </trans-unit>
        <trans-unit id="2ccece93e5a00d5f5d9d7a6919183b3a66f82129" translate="yes" xml:space="preserve">
          <source>The error logger callback function might look something like this:</source>
          <target state="translated">错误记录器的回调函数可能看起来像这样。</target>
        </trans-unit>
        <trans-unit id="8ad007677ae545b2ad036dc3fbfd526afb2a9647" translate="yes" xml:space="preserve">
          <source>The error logger callback should be treated like a signal handler. The application should save off or otherwise process the error, then return as soon as possible. No other SQLite APIs should be invoked, directly or indirectly, from the error logger. SQLite is &lt;u&gt;not&lt;/u&gt; reentrant through the error logger callback. In particular, the error logger callback is invoked when a memory allocation fails, so it is generally a bad idea to try to allocate memory inside the error logger. Do not even think about trying to store the error message in another SQLite database.</source>
          <target state="translated">错误记录器回调应被视为信号处理程序。应用程序应保存或以其他方式处理该错误，然后尽快返回。不应从错误记录器直接或间接调用其他SQLite API。通过错误记录器回调，SQLite &lt;u&gt;不可&lt;/u&gt;重入。特别是，当内存分配失败时，将调用错误记录器回调，因此尝试在错误记录器中分配内存通常是一个坏主意。甚至不要考虑尝试将错误消息存储在另一个SQLite数据库中。</target>
        </trans-unit>
        <trans-unit id="931b7a49e1d266b8f7af8c59c48646cf4fc9a825" translate="yes" xml:space="preserve">
          <source>The error messages that might be sent to the error logger and their exact format is subject to changes from one release to the next. So applications should not depend on any particular error message text formats or error codes. Things do not change capriciously, but they do sometimes changes.</source>
          <target state="translated">可能被发送到错误记录器的错误信息及其确切格式会因版本不同而发生变化。所以应用程序不应依赖任何特定的错误信息文本格式或错误代码。事物不会任性地变化,但有时也会发生变化。</target>
        </trans-unit>
        <trans-unit id="6f0f73d0eed4daf2fa7ce504b606f01da04260dc" translate="yes" xml:space="preserve">
          <source>The estimatedCost field should be set to the estimated number of disk access operations required to execute this query against the virtual table. The SQLite core will often call xBestIndex multiple times with different constraints, obtain multiple cost estimates, then choose the query plan that gives the lowest estimate. The SQLite core initializes estimatedCost to a very large value prior to invoking xBestIndex, so if xBestIndex determines that the current combination of parameters is undesirable, it can leave the estimatedCost field unchanged to discourage its use.</source>
          <target state="translated">estimatedCost字段应设置为对虚拟表执行此查询所需的磁盘访问操作的估计次数。SQLite核心经常会用不同的约束条件多次调用xBestIndex,获取多个成本估计值,然后选择给出最低估计值的查询计划。在调用xBestIndex之前,SQLite核心会将assimestCost初始化为一个非常大的值,所以如果xBestIndex确定当前的参数组合是不可取的,它可以不改变assimestCost字段,以阻止其使用。</target>
        </trans-unit>
        <trans-unit id="9110d26065cfada658af48dd22a731f2e42c4634" translate="yes" xml:space="preserve">
          <source>The estimatedCost value is an estimate of the cost of a particular strategy. A cost of N indicates that the cost of the strategy is similar to a linear scan of an SQLite table with N rows. A cost of log(N) indicates that the expense of the operation is similar to that of a binary search on a unique indexed field of an SQLite table with N rows.</source>
          <target state="translated">estimatedCost值是对特定策略成本的估计。成本为N表示该策略的费用类似于对一个有N行的SQLite表进行线性扫描的费用。log(N)表示该操作的费用类似于对一个有N行的SQLite表的唯一索引字段进行二进制搜索的费用。</target>
        </trans-unit>
        <trans-unit id="a1d11ebb28b1bb46c038273ece9416f81d29642b" translate="yes" xml:space="preserve">
          <source>The estimatedRows value is an estimate of the number of rows that will be returned by the strategy.</source>
          <target state="translated">estimatedRows值是对策略将返回的行数的估计。</target>
        </trans-unit>
        <trans-unit id="6e98b869e8e492045895b07f0da4a451a3b65571" translate="yes" xml:space="preserve">
          <source>The exact logic used to determine if a</source>
          <target state="translated">确切的逻辑是用来确定一个</target>
        </trans-unit>
        <trans-unit id="c7341ca7ddb26c5a501b148a51edcbd920ab7841" translate="yes" xml:space="preserve">
          <source>The exact same source code can be used for both a run-time loadable shared library or DLL and as a module that is statically linked with your application. This provides flexibility and allows you to reuse the same code in different ways.</source>
          <target state="translated">完全相同的源代码既可用于运行时可加载的共享库或DLL,也可用于与应用程序静态链接的模块。这提供了灵活性,允许您以不同的方式重复使用相同的代码。</target>
        </trans-unit>
        <trans-unit id="51d3ce62c3eb93876d401465d70f8ba808604db2" translate="yes" xml:space="preserve">
          <source>The example above causes the database file named &quot;ex1.db&quot; to be opened and used. The &quot;ex1.db&quot; file is created if it does not previously exist. You might want to use a full pathname to ensure that the file is in the directory that you think it is in. Use forward-slashes as the directory separator character. In other words use &quot;c:/work/ex1.db&quot;, not &quot;c:\work\ex1.db&quot;.</source>
          <target state="translated">上面的例子导致名为 &quot;ex1.db &quot;的数据库文件被打开并使用。如果 &quot;ex1.db &quot;文件之前不存在,就会被创建。您可能需要使用完整的路径名来确保文件在您认为的目录中。使用正斜线作为目录分隔符。换句话说,使用 &quot;c:/work/ex1.db&quot;,而不是 &quot;c:\work\ex1.db&quot;。</target>
        </trans-unit>
        <trans-unit id="97b14b6298ce84315e618c11d7722d98fb92421a" translate="yes" xml:space="preserve">
          <source>The example above contains two &quot;SCALAR&quot; subqueries. The subqueries are SCALAR in the sense that they return a single value - a one-row, one-column table. If the actual query returns more than that, then only the first column of the first row is used.</source>
          <target state="translated">上面的示例包含两个 &quot;SCALAR &quot;子查询。这些子查询是SCALAR,因为它们只返回一个值--一个单行单列的表。如果实际查询返回的值超过这个值,那么只使用第一行的第一列。</target>
        </trans-unit>
        <trans-unit id="d7a7c3999051bd06566a95bdd9bc9de8e3e4adaa" translate="yes" xml:space="preserve">
          <source>The example above illustrates the signature of the error logger callback. However, in an embedded application, one usually does not print messages on stderr. Instead, one might store the messages in a preallocated circular buffer where they can be accessed when diagnostic information is needed during debugging. Or perhaps the messages can be sent to &lt;a href=&quot;http://en.wikipedia.org/wiki/Syslog&quot;&gt;Syslog&lt;/a&gt;. Somehow, the messages need to be stored where they are accessible to developers, not displayed to end users.</source>
          <target state="translated">上面的示例说明了错误记录器回调的签名。但是，在嵌入式应用程序中，通常不会在stderr上打印消息。相反，可以将消息存储在预分配的循环缓冲区中，在调试期间需要诊断信息时可以在其中访问这些消息。或者，消息可以发送到&lt;a href=&quot;http://en.wikipedia.org/wiki/Syslog&quot;&gt;Syslog&lt;/a&gt;。消息需要以某种方式存储在开发人员可以访问的位置，而不显示给最终用户。</target>
        </trans-unit>
        <trans-unit id="6fc4d45b4003fc3925ac8f8341dab42290a2d223" translate="yes" xml:space="preserve">
          <source>The example above illustrates the signature of the error logger callback. However, in an embedded application, one usually does not print messages on stderr. Instead, one might store the messages in a preallocated circular buffer where they can be accessed when diagnostic information is needed during debugging. Or perhaps the messages can be sent to &lt;a href=&quot;https://en.wikipedia.org/wiki/Syslog&quot;&gt;Syslog&lt;/a&gt;. Somehow, the messages need to be stored where they are accessible to developers, not displayed to end users.</source>
          <target state="translated">上面的示例说明了错误记录器回调的签名。但是，在嵌入式应用程序中，通常不会在stderr上打印消息。相反，可以将消息存储在预分配的循环缓冲区中，在调试期间需要诊断信息时可以在其中访问这些消息。或者，消息可以发送到&lt;a href=&quot;https://en.wikipedia.org/wiki/Syslog&quot;&gt;Syslog&lt;/a&gt;。消息必须以某种方式存储在开发人员可以访问的位置，而不显示给最终用户。</target>
        </trans-unit>
        <trans-unit id="d307547a7cd9c2e8e0dc86cacf98f3de8afb55c2" translate="yes" xml:space="preserve">
          <source>The example above showed a single &lt;b&gt;filename='thefile.csv'&lt;/b&gt; argument for the CSV virtual table. But other arguments are also possible.</source>
          <target state="translated">上面的示例显示了CSV虚拟表的单个&lt;b&gt;filename ='thefile.csv'&lt;/b&gt;参数。但是其他论点也是可能的。</target>
        </trans-unit>
        <trans-unit id="11a05b76af4570008579a529531a96eb802e047d" translate="yes" xml:space="preserve">
          <source>The example above shows SQLite picking full-table scan will visit all rows in the table. If the query were able to use an index, then the SCAN/SEARCH record would include the name of the index and, for a SEARCH record, an indication of how the subset of rows visited is identified. For example:</source>
          <target state="translated">上面的例子显示,SQLite挑选全表扫描将访问表中的所有行。假如查询能够运用索引,那么SCAN/SEARCH记载就会包含索引的姓名,而关于SEARCH记载,则会标明怎样辨认所拜访的行的子集。比如说:&quot;SCAN/SEARCH记录&quot;。</target>
        </trans-unit>
        <trans-unit id="abd381887f2ea42f76bfd9ebc8b17425d16e2957" translate="yes" xml:space="preserve">
          <source>The example below uses ntile() to divide the six rows into two groups (the ntile(2) call) and into four groups (the ntile(4) call). For ntile(2), there are three rows assigned to each group. For ntile(4), there are two groups of two and two groups of one. The larger groups of two appear first.</source>
          <target state="translated">下面的例子使用ntile()将六条记录分为两组(ntile(2)调用)和四组(ntile(4)调用)。对于ntile(2),每组有三条记录。对于ntile(4),有两组的两组和两组的一组。大的两组先出现。</target>
        </trans-unit>
        <trans-unit id="c8ad72613a1253e10b2aeefbfa091cedb3448e07" translate="yes" xml:space="preserve">
          <source>The example code below demonstrates the steps involved in capturing a changeset while executing SQL commands. In summary:</source>
          <target state="translated">下面的示例代码演示了在执行SQL命令时捕获变化集的步骤。总的来说。</target>
        </trans-unit>
        <trans-unit id="cfda7c494f05312b3bf7826ec92aff6df2e44b46" translate="yes" xml:space="preserve">
          <source>The example code below demonstrates the techniques used to iterate through and extract the data related to all changes in a changeset. To summarize:</source>
          <target state="translated">下面的示例代码演示了用于迭代并提取与变更集中所有变更相关的数据的技术。总结一下。</target>
        </trans-unit>
        <trans-unit id="5dde8802fcba008ca09e765d610fcb4f5bf326ca" translate="yes" xml:space="preserve">
          <source>The example code below uses the second of the methods enumerated above - it monitors for changes on all database tables.</source>
          <target state="translated">下面的示例代码使用了上面列举的第二种方法--它监控所有数据库表的变化。</target>
        </trans-unit>
        <trans-unit id="3f036ecd22d9629ed467ac2dbb67b517f12166ad" translate="yes" xml:space="preserve">
          <source>The examples above all use basic full-text term queries as both operands of the set operations demonstrated. Phrase and NEAR queries may also be used, as may the results of other set operations. When more than one set operation is present in an FTS query, the precedence of operators is as follows:</source>
          <target state="translated">上面的例子都使用基本的全文术语查询作为所演示的集合运算的操作数。也可以使用短语和near查询,也可以使用其他集合操作的结果。当一个FTS查询中出现一个以上的集合操作时,操作符的优先级如下。</target>
        </trans-unit>
        <trans-unit id="1921013ee1678e9933f635ab4c9457e39025bfc3" translate="yes" xml:space="preserve">
          <source>The examples below identify the collating sequences that would be used to determine the results of text comparisons that may be performed by various SQL statements. Note that a text comparison may not be required, and no collating sequence used, in the case of numeric, blob or NULL values.</source>
          <target state="translated">下面的示例确定了用于确定各种SQL语句可能执行的文本比较结果的整理序列。请注意,在数值、blob或NULL值的情况下,可能不需要进行文本比较,也不使用整理序列。</target>
        </trans-unit>
        <trans-unit id="367a92feb39a9287f4306f6946c319f7064a8b02" translate="yes" xml:space="preserve">
          <source>The examples in this section all assume that the database is populated as follows:</source>
          <target state="translated">本节的例子都假设数据库的填充方式如下。</target>
        </trans-unit>
        <trans-unit id="c2bd8a896b6e33422d64448169403c1bc373cf0d" translate="yes" xml:space="preserve">
          <source>The examples in this section all assume the following data:</source>
          <target state="translated">本节的例子都是假设以下数据。</target>
        </trans-unit>
        <trans-unit id="4d8c3a17bac2c4be1cb9b2d64248454f5513cff9" translate="yes" xml:space="preserve">
          <source>The exception mentioned above is that if the declaration of a column with declared type &quot;INTEGER&quot; includes an &quot;PRIMARY KEY DESC&quot; clause, it does not become an alias for the rowid and is not classified as an integer primary key. This quirk is not by design. It is due to a bug in early versions of SQLite. But fixing the bug could result in backwards incompatibilities. Hence, the original behavior has been retained (and documented) because odd behavior in a corner case is far better than a compatibility break. This means that the following three table declarations all cause the column &quot;x&quot; to be an alias for the rowid (an integer primary key):</source>
          <target state="translated">上面提到的例外情况是,如果声明类型为 &quot;INTEGER &quot;的列的声明中包含了 &quot;PRIMARY KEY DESC &quot;子句,那么它不会成为rowid的别名,也不会被归为整数主键。这个怪癖不是设计出来的。它是由于SQLite早期版本中的一个bug。但是修复这个错误可能会导致向后的不兼容。因此,原来的行为被保留了下来(并被记录下来),因为在角落的情况下,奇怪的行为远比兼容性的破坏要好得多。这意味着以下三个表的声明都会导致列 &quot;x &quot;成为rowid(一个整数主键)的别名。</target>
        </trans-unit>
        <trans-unit id="3fca028858f76596a98f86d48ac0ce09545ac4bf" translate="yes" xml:space="preserve">
          <source>The executable format really ends up being just an implementation detail. The key point is that all languages have a compiler step which translates programs into an executable format and a run step that executes the compiled program.</source>
          <target state="translated">可执行格式其实最后只是一个实现细节。关键的一点是,所有的语言都有一个编译器步骤,将程序翻译成可执行格式,还有一个运行步骤,执行编译后的程序。</target>
        </trans-unit>
        <trans-unit id="f41b51d024f674a1f6149c31aede1e868d7d56cf" translate="yes" xml:space="preserve">
          <source>The existence of a transaction depends on whether or not the rollback journal file exists and the deletion of a file appears to be an atomic operation from the point of view of a user-space process. Therefore, a transaction appears to be an atomic operation.</source>
          <target state="translated">一个事务的存在取决于回滚日志文件是否存在,从用户空间进程的角度看,删除一个文件似乎是一个原子操作。因此,一个事务看起来是一个原子操作。</target>
        </trans-unit>
        <trans-unit id="6021cb5e88d7481ca7795a9ddd0c04e6033fc0e0" translate="yes" xml:space="preserve">
          <source>The existing INSERT is removed from the changegroup. The DELETE is not added.</source>
          <target state="translated">现有的INSERT从变更组中删除。不增加DELETE。</target>
        </trans-unit>
        <trans-unit id="4a2b5a6b7a6bdb1833a8cf1e839e065d174385dc" translate="yes" xml:space="preserve">
          <source>The existing UPDATE is replaced by the new DELETE within the changegroup.</source>
          <target state="translated">现有的UPDATE被changegroup中新的DELETE取代。</target>
        </trans-unit>
        <trans-unit id="5c1e2e9de2a17cfdc315c14e1e74a36e45b9c92f" translate="yes" xml:space="preserve">
          <source>The existing UPDATE remains within the changegroup. It is amended so that the accompanying values are as if the row was updated once by the existing change and then again by the new change.</source>
          <target state="translated">现有的UPDATE仍然保留在changegroup中。修改后,所附的值就像该行被现有的变化更新了一次,然后又被新的变化更新了一次一样。</target>
        </trans-unit>
        <trans-unit id="fca9185c8e0eb9e3e49b7068e021cf8a710c066e" translate="yes" xml:space="preserve">
          <source>The explicit COMMIT command runs immediately, even if there are pending &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. However, if there are pending write operations, the COMMIT command will fail with an error code &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="translated">即使有未决的&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句，显式COMMIT命令也会立即运行。但是，如果有挂起的写操作，则COMMIT命令将失败，并显示错误代码&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e2d16a733bb795b8f24e0161c9bf1e3201567a34" translate="yes" xml:space="preserve">
          <source>The expression &quot;+column&quot; is now considered the same as &quot;column&quot; when computing the collating sequence to use on the expression.</source>
          <target state="translated">现在,在计算对表达式使用的整理序列时,表达式 &quot;+column &quot;被认为与 &quot;column &quot;相同。</target>
        </trans-unit>
        <trans-unit id="fee373e0e83d3368c40362493777ab8e984bd97b" translate="yes" xml:space="preserve">
          <source>The expression &quot;a BETWEEN b AND c&quot; is treated as two separate binary comparisons &quot;a &amp;gt;= b AND a &amp;lt;= c&quot;, even if that means different affinities are applied to 'a' in each of the comparisons. Datatype conversions in comparisons of the form &quot;x IN (SELECT y ...)&quot; are handled is if the comparison were really &quot;x=y&quot;. The expression &quot;a IN (x, y, z, ...)&quot; is equivalent to &quot;a = +x OR a = +y OR a = +z OR ...&quot;. In other words, the values to the right of the IN operator (the &quot;x&quot;, &quot;y&quot;, and &quot;z&quot; values in this example) are considered to have no affinity, even if they happen to be column values or CAST expressions.</source>
          <target state="translated">表达式&amp;ldquo; a在b AND c之间&amp;rdquo;被视为两个单独的二进制比较&amp;ldquo; a&amp;gt; = b AND a &amp;lt;= c&amp;rdquo;，即使这意味着在每个比较中对&amp;ldquo; a&amp;rdquo;应用了不同的亲和力。如果比较确实是&amp;ldquo; x = y&amp;rdquo;，则处理形式为&amp;ldquo; x IN（SELECT y ...）&amp;rdquo;的比较中的数据类型转换。表达式&amp;ldquo; a IN（x，y，z，...）&amp;rdquo;等效于&amp;ldquo; a = + x OR a = + y OR a = + z OR ...&amp;rdquo;。换句话说，IN运算符右边的值（在此示例中为&amp;ldquo; x&amp;rdquo;，&amp;ldquo; y&amp;rdquo;和&amp;ldquo; z&amp;rdquo;值）被认为没有亲和力，即使它们碰巧是列值或CAST表达式。</target>
        </trans-unit>
        <trans-unit id="15a424b3e7e4f20cd419dc00af0824f2446f3f50" translate="yes" xml:space="preserve">
          <source>The expression &quot;x BETWEEN y and z&quot; is logically equivalent to two comparisons &quot;x &amp;gt;= y AND x &amp;lt;= z&quot; and works with respect to collating functions as if it were two separate comparisons. The expression &quot;x IN (SELECT y ...)&quot; is handled in the same way as the expression &quot;x = y&quot; for the purposes of determining the collating sequence. The collating sequence used for expressions of the form &quot;x IN (y, z, ...)&quot; is the collating sequence of x.</source>
          <target state="translated">表达式&amp;ldquo; x在y和z之间&amp;rdquo;在逻辑上等效于两个比较&amp;ldquo; x&amp;gt; = y AND x &amp;lt;= z&amp;rdquo;，并且对于整理函数而言就像是两个单独的比较一样。为了确定整理顺序，以与表达式&amp;ldquo; x = y&amp;rdquo;相同的方式处理表达式&amp;ldquo; x IN（SELECT y ...）&amp;rdquo;。用于形式为&amp;ldquo; x IN（y，z，...）&amp;rdquo;的表达式的整理序列是x的整理序列。</target>
        </trans-unit>
        <trans-unit id="70c0ccea32ba2d8b128981db932845adc7b90c4c" translate="yes" xml:space="preserve">
          <source>The expression &quot;x BETWEEN y and z&quot; is logically equivalent to two comparisons &quot;x &amp;gt;= y AND x &amp;lt;= z&quot; and works with respect to collating functions as if it were two separate comparisons. The expression &quot;x IN (SELECT y ...)&quot; is handled in the same way as the expression &quot;x = y&quot; for the purposes of determining the collating sequence. The collating sequence used for expressions of the form &quot;x IN (y, z, ...)&quot; is the collating sequence of x. If an explicit collating sequence is required on an IN operator it should be applied to the left operand, like this: &quot;x COLLATE nocase IN (y,z, ...)&quot;.</source>
          <target state="translated">表达式&amp;ldquo; x在y和z之间&amp;rdquo;在逻辑上等效于两个比较&amp;ldquo; x&amp;gt; = y AND x &amp;lt;= z&amp;rdquo;，并且就整理函数而言好像是两个单独的比较。为了确定整理顺序，以与表达式&amp;ldquo; x = y&amp;rdquo;相同的方式处理表达式&amp;ldquo; x IN（SELECT y ...）&amp;rdquo;。用于形式为&amp;ldquo; x IN（y，z，...）&amp;rdquo;的表达式的整理序列是x的整理序列。如果IN运算符上需要显式的整理序列，则应将其应用于左操作数，如下所示：&amp;ldquo; x COLLATE nocase IN（y，z，...）&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0c6d1934b411c6401d1051c4d7453826ea7a9843" translate="yes" xml:space="preserve">
          <source>The expression attached to the optional OFFSET clause that may follow a LIMIT clause must also evaluate to an integer, or a value that can be losslessly converted to an integer. If an expression has an OFFSET clause, then the first M rows are omitted from the result set returned by the SELECT statement and the next N rows are returned, where M and N are the values that the OFFSET and LIMIT clauses evaluate to, respectively. Or, if the SELECT would return less than M+N rows if it did not have a LIMIT clause, then the first M rows are skipped and the remaining rows (if any) are returned. If the OFFSET clause evaluates to a negative value, the results are the same as if it had evaluated to zero.</source>
          <target state="translated">附加在可选OFFSET子句上的表达式,在LIMIT子句后面的表达式也必须评估为一个整数,或者一个可以无损转换为整数的值。如果一个表达式有一个OFFSET子句,那么SELECT语句返回的结果集中将省略前M条记录,并返回接下来的N条记录,其中M和N分别是OFFSET子句和LIMIT子句评估的值。或者,如果SELECT没有LIMIT子句的话,返回的记录少于M+N条,那么就跳过前M条记录,返回剩余的记录(如果有的话)。如果OFFSET子句的值为负值,那么结果就和它的值为0一样。</target>
        </trans-unit>
        <trans-unit id="1cd8c2a06181abbb52fb772c5e4393bf493adec9" translate="yes" xml:space="preserve">
          <source>The expression following the WHERE clause may contain operators, literal values, and names of columns in the table being indexed. The WHERE clause may &lt;em&gt;not&lt;/em&gt; contain subqueries, references to other tables, &lt;a href=&quot;deterministic&quot;&gt;non-deterministic functions&lt;/a&gt;, or &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;.</source>
          <target state="translated">WHERE子句后面的表达式可以包含运算符，文字值和要建立索引的表中的列名称。WHERE子句&lt;em&gt;不能&lt;/em&gt;包含子查询，对其他表的引用，&lt;a href=&quot;deterministic&quot;&gt;不确定性函数&lt;/a&gt;或&lt;a href=&quot;lang_expr#varparam&quot;&gt;绑定参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1c1e099acc66b957c91a242e71ab41548df3e15b" translate="yes" xml:space="preserve">
          <source>The expression of a generated column can refer to any of the other declared columns in the table, including other generated columns, as long as the expression does not directly or indirectly refer back to itself.</source>
          <target state="translated">生成列的表达式可以引用表中任何其他声明的列,包括其他生成列,只要该表达式不直接或间接地引用自己。</target>
        </trans-unit>
        <trans-unit id="4cd71176d0cd745c21cb3b1319609677077ace52" translate="yes" xml:space="preserve">
          <source>The expression of a generated column may not directly reference the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;, though it can reference the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column, which is often the same thing.</source>
          <target state="translated">生成的列的表达式虽然可以引用&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列，但可能不直接引用&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;，这通常是同一回事。</target>
        </trans-unit>
        <trans-unit id="67b0f355cc2989c7cff5a5d8658f4cccd6f86732" translate="yes" xml:space="preserve">
          <source>The expression of a generated column may only reference constant literals and columns within the same row, and may only use scalar &lt;a href=&quot;deterministic&quot;&gt;deterministic functions&lt;/a&gt;. The expression may not use subqueries, aggregate functions, window functions, or table-valued functions.</source>
          <target state="translated">生成的列的表达式只能引用常量文字和同一行内的列，并且只能使用标量&lt;a href=&quot;deterministic&quot;&gt;确定性函数&lt;/a&gt;。该表达式不能使用子查询，聚合函数，窗口函数或表值函数。</target>
        </trans-unit>
        <trans-unit id="3177e05d9fce52b64c04ddd90d24e41132bbd994" translate="yes" xml:space="preserve">
          <source>The expression of a generated column may refer to other generated columns in the same row, but no generated column can depend upon itself, either directly or indirectly.</source>
          <target state="translated">生成列的表达式可以参考同一行的其他生成列,但任何生成列都不能直接或间接地依赖自己。</target>
        </trans-unit>
        <trans-unit id="fa57007d3af78002775463ea997fdbb172a0c191" translate="yes" xml:space="preserve">
          <source>The extension loading mechanism of SQLite (accessed using the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function) is turned off by default. This is a security precaution. If an application wants to make use of the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; function it must first turn the capability on using this method.</source>
          <target state="translated">默认情况下，SQLite的扩展加载机制（使用&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt; SQL函数访问）是关闭的。这是安全预防措施。如果应用程序要使用&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt;函数，则必须首先使用此方法打开该功能。</target>
        </trans-unit>
        <trans-unit id="bbd9a40496de97ba5cfcabba824166980ee9d8c1" translate="yes" xml:space="preserve">
          <source>The extra write overhead prompted a reexamination of assumptions about powersafe overwrite. With modern disk drives, the capacity has become so large and the data density so great that a single sector is very small and writing a single sector takes very little time. We know that disk drives can detect an impending power loss and continue to operate for some small amount of time on residual energy because those drives are able to park their heads before spinning down. And so if an impending power loss is detectable by the disk controller, it seems reasonable that the controller will finish writing whatever sector it is current working on when the imminent power loss is first detected, prior to parking the heads, as long as doing so does not take too long, which it should not with small and dense sectors. Hence it seems reasonable to assume powersafe overwrite for modern disks. Indeed, BerkeleyDB has made this assumption for decades, we are told. Caution is advised though. As Roger Binns noted on the SQLite developers mailing list: &quot;'poorly written' should be the main assumption about drive firmware.&quot;</source>
          <target state="translated">额外的写入开销促使人们重新审视关于powersafe overwrite的假设。对于现代磁盘驱动器,容量已经变得非常大,数据密度非常大,单个扇区非常小,写入一个扇区需要的时间非常少。我们知道,磁盘驱动器可以检测到即将发生的功率损失,并依靠剩余的能量继续工作一小段时间,因为这些驱动器能够在旋转下来之前停好头。因此,如果磁盘控制器可以检测到即将发生的功率损失,那么控制器在第一次检测到即将发生的功率损失时,会先完成当前正在工作的扇区的写入工作,然后再停放磁头,这似乎是合理的,只要这样做不需要太长的时间,对于小而密集的扇区来说,应该是不会的。因此,假设现代磁盘的powerafe overwrite似乎是合理的。事实上,BerkeleyDB已经做了几十年的假设,我们被告知。不过,我们还是建议大家谨慎行事。正如Roger Binns在SQLite开发者邮件列表中所指出的那样。&quot;'写得不好'应该是硬盘固件的主要假设&quot;</target>
        </trans-unit>
        <trans-unit id="f31765748ec404a72a387c3ce457db0e7fddb3f0" translate="yes" xml:space="preserve">
          <source>The fact that NULLs are distinct for UNIQUE columns but are indistinct for SELECT DISTINCT and UNION continues to be puzzling. It seems that NULLs should be either distinct everywhere or nowhere. And the SQL standards documents suggest that NULLs should be distinct everywhere. Yet as of this writing, no SQL engine tested treats NULLs as distinct in a SELECT DISTINCT statement or in a UNION.</source>
          <target state="translated">NULLs对于UNIQUE列是明确的,但对于SELECT DISTINCT和UNION却不明确,这个事实仍然令人困惑。似乎NULLs应该在任何地方都是不同的,或者在任何地方都是不同的。而SQL标准文档建议,NULLs应该是处处有区别的。然而,截至本文撰写时,没有一个经过测试的SQL引擎在SELECT DISTINCT语句或UNION中把NULLs视为不同的。</target>
        </trans-unit>
        <trans-unit id="36716fd190ed79338836da067e34479b294afa61" translate="yes" xml:space="preserve">
          <source>The fact that SQLite is embedded and &lt;a href=&quot;serverless&quot;&gt;serverless&lt;/a&gt; instead of being client/server is a feature, not a bug.</source>
          <target state="translated">SQLite是嵌入式且&lt;a href=&quot;serverless&quot;&gt;无服务器的，&lt;/a&gt;而不是作为客户端/服务器的，这是一个功能，而不是错误。</target>
        </trans-unit>
        <trans-unit id="893ade2ecf018b089d7d0c2f18f2d37a93397ea0" translate="yes" xml:space="preserve">
          <source>The fifth argument to the BLOB and string binding interfaces is a destructor used to dispose of the BLOB or string after SQLite has finished with it. The destructor is called to dispose of the BLOB or string even if the call to the bind API fails, except the destructor is not called if the third parameter is a NULL pointer or the fourth parameter is negative. If the fifth argument is the special value &lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_STATIC&lt;/a&gt;, then SQLite assumes that the information is in static, unmanaged space and does not need to be freed. If the fifth argument has the value &lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_TRANSIENT&lt;/a&gt;, then SQLite makes its own private copy of the data immediately, before the sqlite3_bind_*() routine returns.</source>
          <target state="translated">BLOB和字符串绑定接口的第五个参数是一个析构函数，用于在SQLite完成后处理BLOB或字符串。即使对绑定API的调用失败，也会调用析构函数来处置BLOB或字符串，但如果第三个参数为NULL指针或第四个参数为负，则不会调用析构函数。如果第五个参数是特殊值&lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_STATIC&lt;/a&gt;，则SQLite假定信息位于静态的非托管空间中，不需要释放。如果第五个参数的值是&lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_TRANSIENT&lt;/a&gt;，则SQLite会在sqlite3_bind _ *（）例程返回之前立即创建其自己的数据私有副本。</target>
        </trans-unit>
        <trans-unit id="e68c8434fb7585b2fc0da0f853455aed19727f06" translate="yes" xml:space="preserve">
          <source>The fifth argument to the BLOB and string binding interfaces is a destructor used to dispose of the BLOB or string after SQLite has finished with it. The destructor is called to dispose of the BLOB or string even if the call to the bind API fails, except the destructor is not called if the third parameter is a NULL pointer or the fourth parameter is negative. If the fifth argument is the special value &lt;a href=&quot;c_static&quot;&gt;SQLITE_STATIC&lt;/a&gt;, then SQLite assumes that the information is in static, unmanaged space and does not need to be freed. If the fifth argument has the value &lt;a href=&quot;c_static&quot;&gt;SQLITE_TRANSIENT&lt;/a&gt;, then SQLite makes its own private copy of the data immediately, before the sqlite3_bind_*() routine returns.</source>
          <target state="translated">BLOB和字符串绑定接口的第五个参数是一个析构函数，用于在SQLite完成后处理BLOB或字符串。即使对绑定API的调用失败，也会调用析构函数来处置BLOB或字符串，但如果第三个参数为NULL指针或第四个参数为负，则不会调用析构函数。如果第五个参数是特殊值&lt;a href=&quot;c_static&quot;&gt;SQLITE_STATIC&lt;/a&gt;，则SQLite假定信息位于静态的非托管空间中，不需要释放。如果第五个参数的值是&lt;a href=&quot;c_static&quot;&gt;SQLITE_TRANSIENT&lt;/a&gt;，则SQLite会在sqlite3_bind _ *（）例程返回之前立即创建其自己的数据私有副本。</target>
        </trans-unit>
        <trans-unit id="901b5e438fd14b98c5489ac30117b7e4f79582ec" translate="yes" xml:space="preserve">
          <source>The fifth argument, xCallback, is a pointer to the collating function. Multiple collating functions can be registered using the same name but with different eTextRep parameters and SQLite will use whichever function requires the least amount of data transformation. If the xCallback argument is NULL then the collating function is deleted. When all collating functions having the same name are deleted, that collation is no longer usable.</source>
          <target state="translated">第五个参数xCallback是指向整理函数的指针。多个整理函数可以使用相同的名称注册,但有不同的eTextRep参数,SQLite将使用任何一个需要最少数据转换的函数。如果xCallback参数为NULL,那么整理函数将被删除。当所有具有相同名称的整理函数被删除时,该整理函数就不再可用。</target>
        </trans-unit>
        <trans-unit id="9b66d05a972406caa6b8e66ca673681eea81f8a6" translate="yes" xml:space="preserve">
          <source>The fifth argument, xCompare, is a pointer to the collating function. Multiple collating functions can be registered using the same name but with different eTextRep parameters and SQLite will use whichever function requires the least amount of data transformation. If the xCompare argument is NULL then the collating function is deleted. When all collating functions having the same name are deleted, that collation is no longer usable.</source>
          <target state="translated">第五个参数xCompare是指向整理函数的指针。多个整理函数可以使用相同的名称注册,但有不同的eTextRep参数,SQLite将使用任何一个需要最少数据转换的函数。如果xCompare参数为NULL,那么整理函数将被删除。当所有具有相同名称的整理函数被删除时,该整理函数就不再可用。</target>
        </trans-unit>
        <trans-unit id="3a3d71778e0851af7f19eb98c05ebd04280b893c" translate="yes" xml:space="preserve">
          <source>The fifth parameter is an arbitrary pointer. The implementation of the function can gain access to this pointer using &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;.</source>
          <target state="translated">第五个参数是任意指针。该函数的实现可以使用&lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data（）&lt;/a&gt;来访问此指针。</target>
        </trans-unit>
        <trans-unit id="8991c375d182bf0ed874e01ceb3c3fba4c90a4d1" translate="yes" xml:space="preserve">
          <source>The fifth parameter is an arbitrary pointer. The implementation of the function can gain access to this pointer using &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;.</source>
          <target state="translated">第五个参数是任意指针。该函数的实现可以使用&lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data（）&lt;/a&gt;来访问此指针。</target>
        </trans-unit>
        <trans-unit id="8b5fa94425e25711d656d2caafbaef27474f2b42" translate="yes" xml:space="preserve">
          <source>The file I/O implementation can use the object type flags to change the way it deals with files. For example, an application that does not care about crash recovery or rollback might make the open of a journal file a no-op. Writes to this journal would also be no-ops, and any attempt to read the journal would return SQLITE_IOERR. Or the implementation might recognize that a database file will be doing page-aligned sector reads and writes in a random order and set up its I/O subsystem accordingly.</source>
          <target state="translated">文件I/O实现可以使用对象类型标志来改变它处理文件的方式。例如,一个不关心崩溃恢复或回滚的应用程序可能会将打开一个日志文件的操作定为no-op,对这个日志文件的写入也是no-op,任何读取日志的尝试都会返回SQLITE_IOERR。对这个日志文件的写入也是no-op,任何读取日志的尝试都会返回SQLITE_IOERR。或者实现可能会认识到数据库文件将以随机顺序进行页对齐扇区读写,并据此设置其I/O子系统。</target>
        </trans-unit>
        <trans-unit id="2ace627b4eb1891a06a62ee2e61523c0922ec242" translate="yes" xml:space="preserve">
          <source>The file I/O implementation can use the object type flags to changes the way it deals with files. For example, an application that does not care about crash recovery or rollback, might make the open of a journal file a no-op. Writes to this journal are also a no-op. Any attempt to read the journal returns &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;. Or the implementation might recognize the a database file will be doing page-aligned sector reads and writes in a random order and set up its I/O subsystem accordingly. SQLite might also add one of the following flags to the xOpen method:</source>
          <target state="translated">文件I / O实现可以使用对象类型标志来更改其处理文件的方式。例如，一个不关心崩溃恢复或回滚的应用程序可能使打开日记文件成为无操作。禁止向该期刊写信。任何尝试读取日记的尝试都将返回&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;。或者实现可能会认识到数据库文件将以随机顺序进行页面对齐的扇区读取和写入，并相应地设置其I / O子系统。SQLite可能还会向xOpen方法添加以下标志之一：</target>
        </trans-unit>
        <trans-unit id="339116ded6000b1bbd01c16fbc4b426fdbec3ebf" translate="yes" xml:space="preserve">
          <source>The file change counter is a 4-byte big-endian integer at offset 24 that is incremented whenever the database file is unlocked after having been modified. When two or more processes are reading the same database file, each process can detect database changes from other processes by monitoring the change counter. A process will normally want to flush its database page cache when another process modified the database, since the cache has become stale. The file change counter facilitates this.</source>
          <target state="translated">文件更改计数器是一个偏移量为24的4字节的大字节整数,每当数据库文件被修改后解锁时,该计数器就会递增。当两个或多个进程在读取同一个数据库文件时,每个进程都可以通过监视变化计数器来检测其他进程的数据库变化。当另一个进程修改了数据库时,一个进程通常会希望刷新它的数据库页面缓存,因为缓存已经失效了。文件变更计数器可以方便地实现这一点。</target>
        </trans-unit>
        <trans-unit id="3144a807afc9a81e0cce3e084ad085692d9830bb" translate="yes" xml:space="preserve">
          <source>The file format can be extended in future releases simply by adding new tables and/or column, preserving backwards compatibility.</source>
          <target state="translated">该文件格式可以在未来的版本中通过添加新的表格和/或列来扩展,保持向后的兼容性。</target>
        </trans-unit>
        <trans-unit id="e6aaed4a8d57b71607b8967869bcc7f23189ec3d" translate="yes" xml:space="preserve">
          <source>The file format for indices was changed slightly in order to work around an inefficiency that can sometimes come up with GDBM when there are large indices having many entries with the same key. ** Incompatible Change **</source>
          <target state="translated">指数的文件格式略有改变,以解决GDBM有时会出现的效率低下的问题,当有许多条目具有相同的键时,就会出现这种情况。**不兼容的改变 **</target>
        </trans-unit>
        <trans-unit id="227aafe2527e84f2018568e74a1b6b84889b7a1b" translate="yes" xml:space="preserve">
          <source>The file format write version and file format read version at offsets 18 and 19 are intended to allow for enhancements of the file format in future versions of SQLite. In current versions of SQLite, both of these values are 1 for rollback journalling modes and 2 for &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; journalling mode. If a version of SQLite coded to the current file format specification encounters a database file where the read version is 1 or 2 but the write version is greater than 2, then the database file must be treated as read-only. If a database file with a read version greater than 2 is encountered, then that database cannot be read or written.</source>
          <target state="translated">偏移量18和19处的文件格式写入版本和文件格式读取版本旨在允许在将来的SQLite版本中增强文件格式。在当前版本的SQLite中，对于回滚日志记录模式，这两个值均为1；对于&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;日志记录模式，这两个值均为2 。如果编码为当前文件格式规范的SQLite版本遇到读取版本为1或2但写入版本大于2的数据库文件，则必须将该数据库文件视为只读。如果遇到读取版本大于2的数据库文件，则无法读取或写入该数据库。</target>
        </trans-unit>
        <trans-unit id="57007ced430f8a0cf3127ebbd04af2dceb5d897b" translate="yes" xml:space="preserve">
          <source>The file-handle open on the</source>
          <target state="translated">打开的文件柄上的</target>
        </trans-unit>
        <trans-unit id="b75893e55d63ac0a30441dba63c6c7335b33555b" translate="yes" xml:space="preserve">
          <source>The file-system</source>
          <target state="translated">文件系统</target>
        </trans-unit>
        <trans-unit id="e3cc87e79b2a7545d431775230c50e5146077116" translate="yes" xml:space="preserve">
          <source>The filename can be interpreted as a URI if this flag is set.</source>
          <target state="translated">如果设置了这个标志,文件名可以解释为URI。</target>
        </trans-unit>
        <trans-unit id="c1f230eea69094b4593dd99813cb077b78f99716" translate="yes" xml:space="preserve">
          <source>The filename for the database to be attached is the value of the expression that occurs before the AS keyword. The filename of the database follows the same semantics as the filename argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;; the special name &quot;&lt;a href=&quot;inmemorydb&quot;&gt;:memory:&lt;/a&gt;&quot; results in an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; and an empty string results in a new temporary database. The filename argument can be a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; if URI filename processing is enable on the database connection. The default behavior is for URI filenames to be disabled, however that might change in a future release of SQLite, so application developers are advised to plan accordingly.</source>
          <target state="translated">要附加的数据库的文件名是在AS关键字之前出现的表达式的值。数据库的文件名与&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;和&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;的filename参数具有相同的语义；特殊名称&amp;ldquo; &lt;a href=&quot;inmemorydb&quot;&gt;：memory：&lt;/a&gt; &amp;rdquo;将导致&lt;a href=&quot;inmemorydb&quot;&gt;内存数据库，&lt;/a&gt;而空字符串将导致新的临时数据库。如果在数据库连接上启用了&lt;a href=&quot;uri&quot;&gt;URI文件&lt;/a&gt;名处理，则filename参数可以是URI文件名。默认行为是禁用URI文件名，但是在将来的SQLite版本中可能会更改，因此建议应用程序开发人员进行相应的计划。</target>
        </trans-unit>
        <trans-unit id="f17e1c0d84ff3c2fe25d0856ea88c3fbd19c5fb1" translate="yes" xml:space="preserve">
          <source>The filename in the INTO clause can be an arbitrary SQL expression that evaluates to a string. The file named by the INTO clause must not previously exist, or else it must be an empty file, or the VACUUM INTO command will fail with an error.</source>
          <target state="translated">INTO子句中的文件名可以是一个任意的SQL表达式,它的值是一个字符串。INTO子句命名的文件必须是之前不存在的,否则必须是一个空文件,否则VACUUM INTO命令会出错而失败。</target>
        </trans-unit>
        <trans-unit id="d4df05c7fc29b7702e9fa3ab7eeeb629cbcad3f5" translate="yes" xml:space="preserve">
          <source>The filename returned by this function is the output of the xFullPathname method of the &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt;. In other words, the filename will be an absolute pathname, even if the filename used to open the database originally was a URI or relative pathname.</source>
          <target state="translated">此函数返回的文件名是&lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt;的xFullPathname方法的输出。换句话说，即使最初用于打开数据库的文件名是URI或相对路径名，文件名也将是绝对路径名。</target>
        </trans-unit>
        <trans-unit id="9485b160522d31184c8916615322f5219f0612b8" translate="yes" xml:space="preserve">
          <source>The filename returned by this function is the output of the xFullPathname method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. In other words, the filename will be an absolute pathname, even if the filename used to open the database originally was a URI or relative pathname.</source>
          <target state="translated">此函数返回的文件名是&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;的xFullPathname方法的输出。换句话说，即使最初用于打开数据库的文件名是URI或相对路径名，文件名也将是绝对路径名。</target>
        </trans-unit>
        <trans-unit id="fc318f399f5ecbc4db919258057f39b26883fdf3" translate="yes" xml:space="preserve">
          <source>The final answer is found by looking for a string with ind==0. If the original sudoku problem did not have a unique solution, then the query will return all possible solutions. If the original problem was unsolvable, then no rows will be returned. In this case, the unique answer is:</source>
          <target state="translated">通过寻找ind==0的字符串来找到最终的答案,如果原始数独问题没有唯一的解,那么查询将返回所有可能的解。如果原来的问题是无法解决的,那么将不返回任何行。在这种情况下,唯一的答案是。</target>
        </trans-unit>
        <trans-unit id="0fa7031611bf07c03077958f2b8ed29a77590306" translate="yes" xml:space="preserve">
          <source>The final argument is an output variable. If successful, (*ppOut) should be set to point to the new tokenizer handle and SQLITE_OK returned. If an error occurs, some value other than SQLITE_OK should be returned. In this case, fts5 assumes that the final value of *ppOut is undefined.</source>
          <target state="translated">最后一个参数是一个输出变量。如果成功,(*ppOut)应该被设置为指向新的标记器句柄,并返回SQLITE_OK。如果发生错误,应该返回SQLITE_OK以外的其他值。在这种情况下,fts5假设*ppOut的最终值是未定义的。</target>
        </trans-unit>
        <trans-unit id="3adcbd65298a5982e7a64803692e07245861c301" translate="yes" xml:space="preserve">
          <source>The final byte of an encoded FTS varint has its most significant bit cleared. All preceding bytes have the most significant bit set. Data is stored in the remaining seven least significant bits of each byte. The first byte of the encoded representation contains the least significant seven bits of the encoded integer value. The second byte of the encoded representation, if it is present, contains the seven next least significant bits of the integer value, and so on. The following table contains examples of encoded integer values:</source>
          <target state="translated">编码后的FTS varint的最后一个字节的最重要的位被清除。所有前面的字节都设置了最有意义的位。数据被存储在每个字节的剩余7个最不重要的位中。编码表示的第一个字节包含编码整数值的最不重要的七个位。编码表示的第二个字节(如果存在的话)包含整数值的下七个最小有效位,以此类推。下表包含编码整数值的例子。</target>
        </trans-unit>
        <trans-unit id="c65b7966b6f5867eece6741b751cabc0c349ca6a" translate="yes" xml:space="preserve">
          <source>The final line of the example (the &quot;.system c:/work/dataout.csv&quot;) has the same effect as double-clicking on the c:/work/dataout.csv file in windows. This will typically bring up a spreadsheet program to display the CSV file.</source>
          <target state="translated">例子的最后一行(&quot;.system c:/work/dataout.csv&quot;)与在windows中双击c:/work/dataout.csv文件的效果相同。这通常会弹出一个电子表格程序来显示CSV文件。</target>
        </trans-unit>
        <trans-unit id="312ab3f0c70e0337ccdf666710177cbb51a2f6d3" translate="yes" xml:space="preserve">
          <source>The final query in the block above may not work as expected. Because the &quot;*&quot; character is inside the double-quotes, it will be passed to the tokenizer, which will likely discard it (or perhaps, depending on the specific tokenizer in use, include it as part of the final token) instead of recognizing it as a special FTS character.</source>
          <target state="translated">上面代码块中的最后一个查询可能不会像预期的那样工作。由于 &quot;*&quot;字符位于双引号内,因此它将被传递给标记器,标记器可能会丢弃它(或者根据使用的特定标记器,可能会将其作为最终标记的一部分),而不是将其识别为一个特殊的 FTS 字符。</target>
        </trans-unit>
        <trans-unit id="a564ec7adef18f2e787e1258b9aed3803202963e" translate="yes" xml:space="preserve">
          <source>The final recovery step is to reduce the exclusive lock back to a shared lock. Once this happens, the database is back in the state that it would have been if the aborted transaction had never started. Since all of this recovery activity happens completely automatically and transparently, it appears to the program using SQLite as if the aborted transaction had never begun.</source>
          <target state="translated">最后的恢复步骤是将独占锁还原为共享锁。一旦发生这种情况,数据库就回到了被中止的事务从未开始时的状态。由于所有这些恢复活动都是完全自动和透明地发生的,所以在使用SQLite的程序中,它看起来就像被中止的事务从未开始过一样。</target>
        </trans-unit>
        <trans-unit id="434e32f7c5be2c22a40571665c3031a75ce803d2" translate="yes" xml:space="preserve">
          <source>The final source of large memory allocations is the space to hold the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; that result from compiling complex SQL operations. Ongoing work by the SQLite developers is reducing the amount of space required here. But large and complex queries might still require &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; that are several kilobytes in size. The only workaround at the moment is for the application to break complex SQL operations up into two or more smaller and simpler operations contained in separate &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;.</source>
          <target state="translated">大内存分配的最终来源是用于保存由于编译复杂的SQL操作而产生的&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;的空间。 SQLite开发人员正在进行的工作正在减少此处所需的空间。但是大型和复杂的查询可能仍然需要大小为几千字节的&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;。目前，唯一的解决方法是应用程序将复杂的SQL操作分解为两个或更多的更小的，更简单的操作，这些操作包含在单独的&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e5be990568c2b06d13617fdb20a3f4473d59b9c" translate="yes" xml:space="preserve">
          <source>The final step in a multi-file commit is to delete the individual rollback journals and drop the exclusive locks on the database files so that other processes can see the changes. This corresponds to &lt;a href=&quot;#section_3_12&quot;&gt;step 3.12&lt;/a&gt; in the single-file commit sequence.</source>
          <target state="translated">多文件提交的最后一步是删除单个回滚日志，并删除数据库文件上的排他锁，以便其他进程可以看到更改。这对应于单文件提交序列中的&lt;a href=&quot;#section_3_12&quot;&gt;步骤3.12&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="570119a07afaf61a9f20cf9abd68b217ebf33834" translate="yes" xml:space="preserve">
          <source>The final three arguments passed to the auxiliary function callback are similar to the three arguments passed to the implementation of a scalar SQL function. All arguments except the first passed to the auxiliary function are available to the implementation in the apVal[] array. The implementation should return a result or error via the content handle pCtx.</source>
          <target state="translated">传递给辅助函数回调的最后三个参数与传递给标量SQL函数实现的三个参数类似。除了传递给辅助函数的第一个参数之外,所有的参数都可以在apVal[]数组中被实现。实现应该通过内容句柄pCtx返回一个结果或错误。</target>
        </trans-unit>
        <trans-unit id="72acf6716754df5bf7660108439b7caacc7e6afa" translate="yes" xml:space="preserve">
          <source>The first 100 bytes of the database file comprise the database file header. The database file header is divided into fields as shown by the table below. All multibyte fields in the database file header are stored with the most significant byte first (big-endian).</source>
          <target state="translated">数据库文件的前100个字节由数据库文件头组成。数据库文件头被划分为如下表所示的字段。数据库文件头中的所有多字节字段都是以最重要的字节为先(big-endian)进行存储。</target>
        </trans-unit>
        <trans-unit id="7ad8baeb9b6a7d25df8e53c7bba57a3b07d6a12e" translate="yes" xml:space="preserve">
          <source>The first 136 bytes of the shm file are a header. The shm header has three main divisions as follows:</source>
          <target state="translated">shm文件的前136个字节是一个头。shm文件头有以下三个主要部分:</target>
        </trans-unit>
        <trans-unit id="32a4d848523b5982a35dd9ccae2a5e300c48ac95" translate="yes" xml:space="preserve">
          <source>The first 8 bytes of the</source>
          <target state="translated">前8个字节的</target>
        </trans-unit>
        <trans-unit id="31e639e14579d85dee4c60a5aeaa903eaa1984f2" translate="yes" xml:space="preserve">
          <source>The first argument must be the sqlite3_index_info object that is the first parameter to the xBestIndex() method. The second argument must be an index into the aConstraint[] array belonging to the sqlite3_index_info structure passed to xBestIndex. This function returns a pointer to a buffer containing the name of the collation sequence for the corresponding constraint.</source>
          <target state="translated">第一个参数必须是 sqlite3_index_info 对象,它是 xBestIndex()方法的第一个参数。第二个参数必须是属于传递给xBestIndex的sqlite3_index_info结构的aConstraint[]数组的索引。这个函数返回一个指向缓冲区的指针,缓冲区中包含对应约束的整理序列名称。</target>
        </trans-unit>
        <trans-unit id="756a3aef230a7b2fc01840e9c05f1d8a68c861b7" translate="yes" xml:space="preserve">
          <source>The first argument passed should be the database handle to register the extension with. The second and third arguments should both be passed 0.</source>
          <target state="translated">传递的第一个参数应该是要注册扩展的数据库句柄,第二个和第三个参数都应该传递0。第二个和第三个参数都应该是0。</target>
        </trans-unit>
        <trans-unit id="7fa580625e479f237836af3af275aa2f6a47351d" translate="yes" xml:space="preserve">
          <source>The first argument passed to an auxiliary function callback is a pointer to a structure containing methods that may be invoked in order to obtain information regarding the current query or row. The second argument is an opaque handle that should be passed as the first argument to any such method invocation. For example, the following auxiliary function definition returns the total number of tokens in all columns of the current row:</source>
          <target state="translated">传递给辅助函数回调的第一个参数是指向一个结构的指针,该结构包含了可以被调用的方法,以便获得有关当前查询或行的信息。第二个参数是一个不透明的句柄,它应该作为任何此类方法调用的第一个参数传递。例如,下面的辅助函数定义返回当前行的所有列中的标记总数。</target>
        </trans-unit>
        <trans-unit id="d4428415829da9afdeca7abddd54df2e62906cce" translate="yes" xml:space="preserve">
          <source>The first argument passed to this function is a copy of the (void*) pointer provided by the application when the fts5_tokenizer object was registered with FTS5 (the third argument to xCreateTokenizer()). The second and third arguments are an array of nul-terminated strings containing the tokenizer arguments, if any, specified following the tokenizer name as part of the CREATE VIRTUAL TABLE statement used to create the FTS5 table.</source>
          <target state="translated">传递给该函数的第一个参数是在FTS5注册fts5_tokenizer对象时,应用程序提供的(void*)指针的副本(xCreateTokenizer()的第三个参数)。第二个和第三个参数是一个无结尾的字符串数组,包含了tokenizer参数(如果有的话),这些参数是在创建FTS5表的CREATE VIRTUAL TABLE语句中指定的。</target>
        </trans-unit>
        <trans-unit id="3ddc48958f41facca8a1ecdc60ac948a59cb2349" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; must be the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; pointer as the first parameter to this method. The second argument to &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; must a zero-terminated UTF-8 string that contains a well-formed &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement that defines the columns in the virtual table and their data types. The name of the table in this CREATE TABLE statement is ignored, as are all constraints. Only the column names and datatypes matter. The CREATE TABLE statement string need not to be held in persistent memory. The string can be deallocated and/or reused as soon as the &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; routine returns.</source>
          <target state="translated">的第一个参数&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt;必须是相同的&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;的指针作为第一个参数，以这种方法。&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt;的第二个参数必须为零结尾的UTF-8字符串，其中包含格式正确的&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句，该语句定义虚拟表中的列及其数据类型。与所有约束一样，此CREATE TABLE语句中的表名将被忽略。仅列名称和数据类型很重要。 CREATE TABLE语句字符串不需要保存在持久性内存中。&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt;例程返回后，可以立即释放和/或重用该字符串。</target>
        </trans-unit>
        <trans-unit id="1aed5522193a69fc6ff8aa89cff3e41266a3f600" translate="yes" xml:space="preserve">
          <source>The first argument to all three special SQL scalar functions must be the &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; of the FTS table that the function is applied to. The &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; is an automatically-generated column found on all FTS tables that has the same name as the FTS table itself. For example, given an FTS table named &quot;mail&quot;:</source>
          <target state="translated">这三个特殊SQL标量函数的第一个参数必须是该函数所应用的FTS表的&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS隐藏列&lt;/a&gt;。该&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS隐藏的列&lt;/a&gt;是具有相同的名称作为FTS表本身的所有FTS表中找到一个自动生成的列。例如，给定一个名为&amp;ldquo; mail&amp;rdquo;的FTS表：</target>
        </trans-unit>
        <trans-unit id="952294bca557c59738bac0e545034c52a263067f" translate="yes" xml:space="preserve">
          <source>The first argument to sqlite3_config() is an integer &lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;configuration option&lt;/a&gt; that determines what property of SQLite is to be configured. Subsequent arguments vary depending on the &lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;configuration option&lt;/a&gt; in the first argument.</source>
          <target state="translated">sqlite3_config（）的第一个参数是整数&lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;配置选项&lt;/a&gt;，该选项确定要配置SQLite的属性。后续参数根据第一个参数中的&lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;配置选项&lt;/a&gt;而有所不同。</target>
        </trans-unit>
        <trans-unit id="f875f5d7c01e9a29524328575e142babf2bae3ae" translate="yes" xml:space="preserve">
          <source>The first argument to sqlite3_config() is an integer &lt;a href=&quot;c_config_covering_index_scan&quot;&gt;configuration option&lt;/a&gt; that determines what property of SQLite is to be configured. Subsequent arguments vary depending on the &lt;a href=&quot;c_config_covering_index_scan&quot;&gt;configuration option&lt;/a&gt; in the first argument.</source>
          <target state="translated">sqlite3_config（）的第一个参数是整数&lt;a href=&quot;c_config_covering_index_scan&quot;&gt;配置选项&lt;/a&gt;，该选项确定要配置SQLite的属性。后续参数根据第一个参数中的&lt;a href=&quot;c_config_covering_index_scan&quot;&gt;配置选项&lt;/a&gt;而有所不同。</target>
        </trans-unit>
        <trans-unit id="3f0ed77e9965fa2c39bb9cbb993108ef55b7d05b" translate="yes" xml:space="preserve">
          <source>The first argument to the busy handler is a copy of the void* pointer which is the third argument to sqlite3_busy_handler(). The second argument to the busy handler callback is the number of times that the busy handler has been invoked previously for the same locking event. If the busy callback returns 0, then no additional attempts are made to access the database and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the application. If the callback returns non-zero, then another attempt is made to access the database and the cycle repeats.</source>
          <target state="translated">繁忙处理程序的第一个参数是void *指针的副本，该指针是sqlite3_busy_handler（）的第三个参数。繁忙处理程序回调的第二个参数是先前为同一锁定事件调用繁忙处理程序的次数。如果忙碌回调返回0，则不进行其他尝试访问数据库，并且&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;返回到应用程序。如果回调返回非零值，则将再次尝试访问数据库，并重复该循环。</target>
        </trans-unit>
        <trans-unit id="73aa47dd980f8a887b15a2decc4e912f8fd4e328" translate="yes" xml:space="preserve">
          <source>The first argument to the busy handler is a copy of the void* pointer which is the third argument to sqlite3_busy_handler(). The second argument to the busy handler callback is the number of times that the busy handler has been invoked previously for the same locking event. If the busy callback returns 0, then no additional attempts are made to access the database and &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the application. If the callback returns non-zero, then another attempt is made to access the database and the cycle repeats.</source>
          <target state="translated">繁忙处理程序的第一个参数是void *指针的副本，该指针是sqlite3_busy_handler（）的第三个参数。繁忙处理程序回调的第二个参数是先前为同一锁定事件调用繁忙处理程序的次数。如果忙碌回调返回0，则不进行其他尝试访问数据库，并且&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;返回到应用程序。如果回调返回非零值，则将再次尝试访问数据库，并重复该循环。</target>
        </trans-unit>
        <trans-unit id="395ff21e8cf7b4d90e5bc3764e07164a7c24e72d" translate="yes" xml:space="preserve">
          <source>The first argument to the callback is just a copy of the fourth argument to &lt;b&gt;sqlite_exec&lt;/b&gt; This parameter can be used to pass arbitrary information through to the callback function from client code. The second argument is the number of columns in the query result. The third argument is an array of pointers to strings where each string is a single column of the result for that record. Note that the callback function reports a NULL value in the database as a NULL pointer, which is very different from an empty string. If the i-th parameter is an empty string, we will get:</source>
          <target state="translated">回调的第一个参数只是&lt;b&gt;sqlite_exec&lt;/b&gt;的第四个参数的副本。此参数可用于将任意信息从客户端代码传递到回调函数。第二个参数是查询结果中的列数。第三个参数是指向字符串的指针数组，其中每个字符串是该记录的结果的单列。请注意，回调函数将数据库中的NULL值报告为NULL指针，这与空字符串有很大不同。如果第i个参数为空字符串，我们将得到：</target>
        </trans-unit>
        <trans-unit id="19ed31ae74a9a14120db33894759ec36b8a3df0f" translate="yes" xml:space="preserve">
          <source>The first argument to the snippet function must always be the &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; of the FTS table being queried and from which the snippet is to be taken. The &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; is an automatically generated column with the same name as the FTS table itself.</source>
          <target state="translated">片段功能的第一个参数必须始终是要查询的FTS表的&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS隐藏列&lt;/a&gt;，并从中获取该片段。所述&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS隐藏的列&lt;/a&gt;是具有相同名称为FTS表本身自动生成的列。</target>
        </trans-unit>
        <trans-unit id="a3c117d3156af5d9687ce63c9ca2baca71f1029c" translate="yes" xml:space="preserve">
          <source>The first argument to the sqlite3_bind_*() routines is always a pointer to the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object returned from &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or its variants.</source>
          <target state="translated">sqlite3_bind _ *（）例程的第一个参数始终是指向从&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或其变体返回的&lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;对象的指针。</target>
        </trans-unit>
        <trans-unit id="e62bb2c9601439134c1919cc9d703235a3e8dcf1" translate="yes" xml:space="preserve">
          <source>The first argument to the sqlite3_bind_*() routines is always a pointer to the &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object returned from &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or its variants.</source>
          <target state="translated">sqlite3_bind _ *（）例程的第一个参数始终是指向从&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;或其变体返回的&lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;对象的指针。</target>
        </trans-unit>
        <trans-unit id="4376fc02622bfe056753a887d840cb5de850cf76" translate="yes" xml:space="preserve">
          <source>The first argument to the sqlite3session_config() function must be one of the SQLITE_SESSION_CONFIG_XXX constants defined below. The interpretation of the (void*) value passed as the second parameter and the effect of calling this function depends on the value of the first parameter.</source>
          <target state="translated">sqlite3session_config()函数的第一个参数必须是下面定义的SQLITE_SESSION_CONFIG_XXX常量之一。作为第二个参数传递的(void*)值的解释和调用该函数的效果取决于第一个参数的值。</target>
        </trans-unit>
        <trans-unit id="46628205e32bedcd53350a6840ee825a63d42391" translate="yes" xml:space="preserve">
          <source>The first argument to these interfaces is a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. These functions return information about the Nth result column returned by the statement, where N is the second function argument. The left-most column is column 0 for these routines.</source>
          <target state="translated">这些接口的第一个参数是&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;。这些函数返回有关语句返回的第N个结果列的信息，其中N是第二个函数参数。这些例程的最左列是第0列。</target>
        </trans-unit>
        <trans-unit id="0f76a71e763d5bd4fbae26e4a6f14b3c938ceb32" translate="yes" xml:space="preserve">
          <source>The first argument to these interfaces is a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. These functions return information about the Nth result column returned by the statement, where N is the second function argument. The left-most column is column 0 for these routines.</source>
          <target state="translated">这些接口的第一个参数是&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;。这些函数返回有关语句返回的第N个结果列的信息，其中N是第二个函数参数。这些例程的最左列是第0列。</target>
        </trans-unit>
        <trans-unit id="a5ff723764d00dd9ac3f381e3bed0a1f08296ed5" translate="yes" xml:space="preserve">
          <source>The first argument, &quot;db&quot;, is a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; obtained from a prior successful call to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;. The database connection must not have been closed.</source>
          <target state="translated">第一个参数&amp;ldquo; db&amp;rdquo;是从先前成功调用&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16（）&lt;/a&gt;获得的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;。数据库连接必须尚未关闭。</target>
        </trans-unit>
        <trans-unit id="691e78895187de6910913a151c966bb350230789" translate="yes" xml:space="preserve">
          <source>The first argument, &quot;db&quot;, is a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; obtained from a prior successful call to &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; or &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;. The database connection must not have been closed.</source>
          <target state="translated">第一个参数&amp;ldquo; db&amp;rdquo;是从先前成功调用&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;或&lt;a href=&quot;open&quot;&gt;sqlite3_open16（）&lt;/a&gt;获得的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;。数据库连接必须尚未关闭。</target>
        </trans-unit>
        <trans-unit id="5da926bf27ba88ce6fa226bb8489971c4b0badd1" translate="yes" xml:space="preserve">
          <source>The first attempt at closing security gaps in pointer passing was to prevent pointer values from being forged. This was accomplished by having the sender attach a subtype to each pointer using &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; and having the receiver verify that subtype using &lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; and reject pointers that had an incorrect subtype. Since there is no way to attach a subtype to a result using pure SQL, this prevents pointers from being forged using SQL. The only way to send a pointer is to use C code. If an attacker can set a subtype, then he is also able to forge a pointer without the help of SQLite.</source>
          <target state="translated">缩小指针传递中的安全间隔的首次尝试是防止伪造指针值。这是通过使发送者使用&lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype（）&lt;/a&gt;将子类型附加到每个指针，并让接收者使用&lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype（）&lt;/a&gt;验证该子类型并拒绝具有不正确子类型的指针来实现的。由于无法使用纯SQL将子类型附加到结果，因此可以防止使用SQL伪造指针。发送指针的唯一方法是使用C代码。如果攻击者可以设置子类型，那么他也可以在没有SQLite帮助的情况下伪造指针。</target>
        </trans-unit>
        <trans-unit id="b3f912cc569c0361b5c2cd2202f03f7409e6b0b1" translate="yes" xml:space="preserve">
          <source>The first beta release for SQLite 3.0.</source>
          <target state="translated">SQLite 3.0的第一个测试版本。</target>
        </trans-unit>
        <trans-unit id="85577f9e39e1e56bdcef30a17afd1e7fd9d77720" translate="yes" xml:space="preserve">
          <source>The first byte of the header is a flag byte. The least significant bit of the flag byte determines whether the coordinate pairs that follow the header are stored big-endian or little-endian. A value of 0 for the least significant bit means big-endian and a value of 1 means little endian. Other bits of the first byte in the header are reserved for future expansion.</source>
          <target state="translated">头部的第一个字节是标志字节。标志字节的最不重要的位决定了跟在标题后面的坐标对是存储在大恩迪安还是小恩迪安。最小有效位的值为0表示大恩典,值为1表示小恩典。标头中第一个字节的其他位是为将来的扩展保留的。</target>
        </trans-unit>
        <trans-unit id="f63d26f2f4bc609cd955a5edef912da4a0a9006c" translate="yes" xml:space="preserve">
          <source>The first call to &lt;a href=&quot;session/sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; on the iterator moves it to point to the first change in the changeset (or to EOF, if the changeset is completely empty). sqlite3changeset_next() returns SQLITE_ROW if it moves the iterator to point to a valid entry, SQLITE_DONE if it moves the iterator to EOF, or an SQLite error code if an error occurs.</source>
          <target state="translated">对迭代器上的&lt;a href=&quot;session/sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）&lt;/a&gt;的首次调用将其移至指向变更集中的第一个变更（如果变更集完全为空，则指向EOF）。如果sqlite3changeset_next（）将迭代器移至指向有效条目，则返回SQLITE_ROW；如果将迭代器移至EOF，则返回SQLITE_DONE；如果发生错误，则返回SQLite错误代码。</target>
        </trans-unit>
        <trans-unit id="261c910c7fa661af930e1c363bad2fff3671bdea" translate="yes" xml:space="preserve">
          <source>The first call to sqlite3_backup_step() obtains an exclusive lock on the destination file. The exclusive lock is not released until either sqlite3_backup_finish() is called or the backup operation is complete and sqlite3_backup_step() returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. Every call to sqlite3_backup_step() obtains a &lt;a href=&quot;lockingv3#shared_lock&quot;&gt;shared lock&lt;/a&gt; on the source database that lasts for the duration of the sqlite3_backup_step() call. Because the source database is not locked between calls to sqlite3_backup_step(), the source database may be modified mid-way through the backup process. If the source database is modified by an external process or via a database connection other than the one being used by the backup operation, then the backup will be automatically restarted by the next call to sqlite3_backup_step(). If the source database is modified by the using the same database connection as is used by the backup operation, then the backup database is automatically updated at the same time.</source>
          <target state="translated">首次调用sqlite3_backup_step（）会获得目标文件的排他锁。在调用sqlite3_backup_finish（）或备份操作完成并且sqlite3_backup_step（）返回&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;之前，不释放排他锁。每次调用sqlite3_backup_step（）都会获得一个&lt;a href=&quot;lockingv3#shared_lock&quot;&gt;共享锁&lt;/a&gt;在sqlite3_backup_step（）调用期间持续存在的源数据库上。因为在两次调用sqlite3_backup_step（）之间未锁定源数据库，所以可以在备份过程中途修改源数据库。如果源数据库是通过外部过程或通过数据库连接修改的，而不是通过备份操作使用的数据库连接修改的，则备份将在下一次调用sqlite3_backup_step（）时自动重新启动。如果通过使用与备份操作相同的数据库连接来修改源数据库，则备份数据库将同时自动更新。</target>
        </trans-unit>
        <trans-unit id="57eb736cb2a536a07c53b0e0f817765662d0da0a" translate="yes" xml:space="preserve">
          <source>The first call to sqlite3_backup_step() obtains an exclusive lock on the destination file. The exclusive lock is not released until either sqlite3_backup_finish() is called or the backup operation is complete and sqlite3_backup_step() returns &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. Every call to sqlite3_backup_step() obtains a &lt;a href=&quot;../lockingv3#shared_lock&quot;&gt;shared lock&lt;/a&gt; on the source database that lasts for the duration of the sqlite3_backup_step() call. Because the source database is not locked between calls to sqlite3_backup_step(), the source database may be modified mid-way through the backup process. If the source database is modified by an external process or via a database connection other than the one being used by the backup operation, then the backup will be automatically restarted by the next call to sqlite3_backup_step(). If the source database is modified by the using the same database connection as is used by the backup operation, then the backup database is automatically updated at the same time.</source>
          <target state="translated">首次调用sqlite3_backup_step（）会获得目标文件的排他锁。在调用sqlite3_backup_finish（）或备份操作完成并且sqlite3_backup_step（）返回&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;之前，不释放排他锁。每次调用sqlite3_backup_step（）都会获得一个&lt;a href=&quot;../lockingv3#shared_lock&quot;&gt;共享锁&lt;/a&gt;在sqlite3_backup_step（）调用期间持续存在的源数据库上。因为在两次调用sqlite3_backup_step（）之间未锁定源数据库，所以可以在备份过程中途修改源数据库。如果源数据库是通过外部过程或通过数据库连接修改的，而不是通过备份操作使用的数据库连接修改的，则备份将在下一次调用sqlite3_backup_step（）时自动重新启动。如果通过使用与备份操作相同的数据库连接来修改源数据库，则备份数据库将同时自动更新。</target>
        </trans-unit>
        <trans-unit id="878621de1d1518fe649327da44b122a6dcc1e4c1" translate="yes" xml:space="preserve">
          <source>The first code for TH3 was laid down on 2008-09-25. An intense effort over the next 10 months resulted in TH3 achieving 100% MC/DC on 2009-07-25. The TH3 code continues to be improved and expanded.</source>
          <target state="translated">2008-09-25,为TH3制定了第一个代码。经过10个月的紧张努力,TH3于2009-07-25实现了100%的MC/DC。TH3代码还在继续改进和扩大。</target>
        </trans-unit>
        <trans-unit id="708a1cddc7d07a561f3445a868346de6a13841df" translate="yes" xml:space="preserve">
          <source>The first column is the schema name for the database that contains the tables. Examples: &quot;main&quot;, &quot;zone512&quot;.</source>
          <target state="translated">第一列是包含表的数据库的模式名称。例如:&quot;main&quot;、&quot;zone512&quot;。&quot;main&quot;,&quot;zone512&quot;。</target>
        </trans-unit>
        <trans-unit id="9814feb56c887ece7381e15fd8887b6ec1a1d8c0" translate="yes" xml:space="preserve">
          <source>The first column of an SQLite R*Tree is similar to an integer primary key column of a normal SQLite table. It may only store a 64-bit signed integer value. Inserting a NULL value into this column causes SQLite to automatically generate a new unique primary key value. If an attempt is made to insert any other non-integer value into this column, the r-tree module silently converts it to an integer before writing it into the database.</source>
          <target state="translated">SQLite R*Tree的第一列类似于普通SQLite表的整数主键列。它只能存储一个64位有符号的整数值。在这一列中插入一个NULL值会导致SQLite自动生成一个新的唯一主键值。如果试图在此列中插入任何其他非整数值,r-tree模块会在将其写入数据库之前,默默地将其转换为整数。</target>
        </trans-unit>
        <trans-unit id="840bd12d54aba66c9e7cdaff39f91dd2e3886bf1" translate="yes" xml:space="preserve">
          <source>The first condition causes all of the trunk check-ins to be displayed and the second and third cause check-ins that merge into or fork from the trunk to also be included. The three conditions are implemented by the three OR-connected EXISTS statements in the WHERE clause of the query. The slowdown that occurred with the NGQP was caused by the second and third conditions. The problem is the same in each, so we will examine just the second one. The subquery of the second condition can be rewritten (with minor and immaterial simplifications) as follows:</source>
          <target state="translated">第一个条件会导致所有的主干签到都被显示出来,第二个和第三个条件会导致合并到主干或从主干分叉的签到也被包括在内。这三个条件是由查询的WHERE子句中的三个OR-连接的EXISTS语句实现的。NGQP出现的速度变慢是由第二个和第三个条件造成的。每个条件的问题都是一样的,所以我们只研究第二个条件。第二个条件的子查询可以改写如下(稍作不重要的简化)。</target>
        </trans-unit>
        <trans-unit id="4abd9649e552817a07b47b388971861bc70b5489" translate="yes" xml:space="preserve">
          <source>The first eight columns are the address, opcode, and operands for a single &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; in the virtual machine that implements the statement. These columns are the same columns output when using EXPLAIN. The bytecode virtual tables shows all operations in the prepared statement, both the main body of the prepared statement and in subprograms used to implement triggers or foreign key actions. The &quot;subprog&quot; field is NULL for the main body of the prepared statement, or is the trigger name or the string &quot;(FK)&quot; for triggers and foreign key actions.</source>
          <target state="translated">前八列是实现该语句的虚拟机中单个&lt;a href=&quot;opcode&quot;&gt;字节码&lt;/a&gt;的地址，操作码和操作数。这些列与使用EXPLAIN时输出的列相同。字节码虚拟表显示了预处理语句中的所有操作，包括预处理语句的主体和用于实现触发器或外键动作的子程序。对于准备好的语句的主体，&amp;ldquo; subprog&amp;rdquo;字段为NULL，对于触发器和外键操作，该字段为触发器名称或字符串&amp;ldquo;（FK）&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="1d90855e6a48f657d5fb1f13585eab05ee2b6665" translate="yes" xml:space="preserve">
          <source>The first example above is the preferred definition of the table, of course. All of the examples create a WITHOUT ROWID table with two PRIMARY KEY columns, &quot;a&quot; and &quot;c&quot;, in that order, followed by two data columns &quot;b&quot; and &quot;d&quot;, also in that order.</source>
          <target state="translated">当然,上面第一个例子是表的首选定义。所有的例子都创建了一个WITHOUT ROWID表,表中有两个PRIMARY KEY列 &quot;a &quot;和 &quot;c&quot;,依次是 &quot;a &quot;和 &quot;c&quot;,后面还有两个数据列 &quot;b &quot;和 &quot;d&quot;,也依次是 &quot;b &quot;和 &quot;d&quot;。</target>
        </trans-unit>
        <trans-unit id="d78f5e7f65436952c61eefc9d02af59c750bcb9f" translate="yes" xml:space="preserve">
          <source>The first five fields of the sqlite3_rtree_query_info structure are identical to the sqlite3_rtree_geometry structure, and have exactly the same meaning. The sqlite3_rtree_query_info structure also contains nCoord and aCoord fields which have the same meaning as the parameter of the same name in the xGeom callback.</source>
          <target state="translated">sqlite3_rtree_query_info结构的前五个字段与sqlite3_rtree_geometry结构相同,意义也完全相同。sqlite3_rtree_query_info结构还包含了nCoord和aCoord字段,这两个字段与xGeom回调中的同名参数意义相同。</target>
        </trans-unit>
        <trans-unit id="8e073e98c04e5afd81b1a912e72c323c17ce2eb5" translate="yes" xml:space="preserve">
          <source>The first form (with the &quot;VALUES&quot; keyword) creates one or more new rows in an existing table. If the column-name list after table-name is omitted then the number of values inserted into each row must be the same as the number of columns in the table. In this case the result of evaluating the left-most expression from each term of the VALUES list is inserted into the left-most column of each new row, and so forth for each subsequent expression. If a column-name list is specified, then the number of values in each term of the VALUE list must match the number of specified columns. Each of the named columns of the new row is populated with the results of evaluating the corresponding VALUES expression. Table columns that do not appear in the column list are populated with the &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default column value&lt;/a&gt; (specified as part of the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement), or with NULL if no &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default value&lt;/a&gt; is specified.</source>
          <target state="translated">第一种形式（带有&amp;ldquo; VALUES&amp;rdquo;关键字）在现有表中创建一个或多个新行。如果省略了table-name之后的column-name列表，则插入每行的值的数量必须与表中的列数相同。在这种情况下，将VALUES列表中每个术语的最左边表达式的求值结果插入到每个新行的最左边的列中，对于每个后续表达式，依此类推。如果指定了列名列表，则VALUE列表的每个术语中的值数必须与指定的列数匹配。新行的每个命名列均填充有评估相应VALUES表达式的结果。未显示在列列表中的表列将填充为&lt;a href=&quot;lang_createtable#dfltval&quot;&gt;默认列值&lt;/a&gt;（指定为&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句的一部分），如果未指定&lt;a href=&quot;lang_createtable#dfltval&quot;&gt;默认值，&lt;/a&gt;则为NULL 。</target>
        </trans-unit>
        <trans-unit id="2570c22a55e27cbe9ad6c1dce2c1cff1bff0c5c4" translate="yes" xml:space="preserve">
          <source>The first form loads the edit distance coefficients from a table called 'TABLENAME'. Any prior coefficients are discarded. So when experimenting with weights and the weight table changes, simply rerun the single-argument form of editdist3() to reload revised coefficients. Note that the edit distance weights used by the editdist3() SQL function are independent from the weights used by the spellfix1 virtual table.</source>
          <target state="translated">第一张表格从名为'TABLENAME'的表中加载编辑距离系数。任何之前的系数都会被丢弃。因此,当实验权重和权重表发生变化时,只需重新运行editdist3()的单参数形式来重新加载修改后的系数。注意,editdist3()SQL函数使用的编辑距离权重与spellfix1虚拟表使用的权重无关。</target>
        </trans-unit>
        <trans-unit id="7597ee6d3f1982d757a998bf7dd70b5fa125869a" translate="yes" xml:space="preserve">
          <source>The first form of the lag() function returns the result of evaluating expression</source>
          <target state="translated">lag()函数的第一种形式返回评估表达式的结果。</target>
        </trans-unit>
        <trans-unit id="99435f14d6ece88179aba89152e1459d1e98bf65" translate="yes" xml:space="preserve">
          <source>The first form of the lead() function returns the result of evaluating expression</source>
          <target state="translated">函数lead()的第一种形式返回对表达式的评估结果</target>
        </trans-unit>
        <trans-unit id="0e38dddff1d9fcb9023e44603abe1408f559a08e" translate="yes" xml:space="preserve">
          <source>The first form of this pragma queries the current journaling mode for</source>
          <target state="translated">这个pragma的第一种形式是查询当前的日记模式。</target>
        </trans-unit>
        <trans-unit id="b8118a5225d858802697d63c772d9f2007991455" translate="yes" xml:space="preserve">
          <source>The first four columns a, b, c, and d of the index would be usable since those four columns form a prefix of the index and are all bound by equality constraints.</source>
          <target state="translated">索引的前四列a、b、c、d将是可用的,因为这四列构成了索引的前缀,并且都受到平等约束。</target>
        </trans-unit>
        <trans-unit id="4ead6c16538264b763b7c6adde08cc0b22f7c9e0" translate="yes" xml:space="preserve">
          <source>The first group of queries in the log are extracting display options from the &quot;config&quot; and &quot;global_config&quot; tables of the Fossil database. Then there is a single complex query that extracts a list of all elements to be displayed on the timeline. This &quot;timeline&quot; query demonstrates that SQLite can easily process complex relational database queries involving multiple tables, subqueries, and complex WHERE clause constraints, and it can make effective use of indexes to solve the queries with minimal disk I/O.</source>
          <target state="translated">日志中的第一组查询是从Fossil数据库的 &quot;config &quot;和 &quot;global_config &quot;表中提取显示选项。然后是一个单一的复杂查询,提取所有要显示在时间轴上的元素列表。这个 &quot;时间轴 &quot;查询表明,SQLite可以轻松地处理涉及多表、子查询和复杂的WHERE子句约束的复杂关系数据库查询,它可以有效地利用索引,以最小的磁盘I/O来解决查询。</target>
        </trans-unit>
        <trans-unit id="4e52fafda10d32765550d3edce2eeda11c3b4ffd" translate="yes" xml:space="preserve">
          <source>The first host parameter has an index of 1, not 0.</source>
          <target state="translated">第一个主机参数的索引为1,而不是0。</target>
        </trans-unit>
        <trans-unit id="178a49643c52d6ff462985df8e6c238cfb8ec5cd" translate="yes" xml:space="preserve">
          <source>The first instruction of interest is the &lt;a href=&quot;opcode#AggReset&quot;&gt;AggReset&lt;/a&gt; at 2. The AggReset instruction initializes the set of buckets to be the empty set and specifies the number of memory slots available in each bucket as P2. In this example, each bucket will hold 3 memory slots. It is not obvious, but if you look closely at the rest of the program you can figure out what each of these slots is intended for.</source>
          <target state="translated">感兴趣的第一指令是&lt;a href=&quot;opcode#AggReset&quot;&gt;AggReset&lt;/a&gt;在2. AggReset指令初始化集桶的是空集，并指定每个桶中为P2可用存储器时隙的数目。在此示例中，每个存储桶将容纳3个内存插槽。这不是很明显，但是如果您仔细查看程序的其余部分，则可以弄清楚每个插槽的用途。</target>
        </trans-unit>
        <trans-unit id="11dcba86733ec3f9c57f212488f98cc390a1b479" translate="yes" xml:space="preserve">
          <source>The first integer in the P4 integer array is the length of the array and does not become part of the permutation.</source>
          <target state="translated">P4整型数组中的第一个整数是数组的长度,不会成为换位的一部分。</target>
        </trans-unit>
        <trans-unit id="388856185e941f1980f4fd92691075a08784c68c" translate="yes" xml:space="preserve">
          <source>The first line of the script above causes the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; to read and activate the run-time loadable extension for CSV. For an application, the equivalent C-language API is &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt;. Observe that the filename extension (ex: &quot;.dll&quot; or &quot;.so&quot; or &quot;.dylib&quot;) is omitted from the extension filename. Omitting the filename extension is not required, but it helps in making the script cross-platform. SQLite will automatically append the appropriate extension.</source>
          <target state="translated">上面脚本的第一行使&lt;a href=&quot;cli&quot;&gt;命令行外壳&lt;/a&gt;读取并激活CSV的运行时可加载扩展。对于应用程序，等效的C语言API是&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;。请注意，扩展名中省略了文件扩展名（例如：&amp;ldquo;。dll&amp;rdquo;，&amp;ldquo;。so&amp;rdquo;或&amp;ldquo; .dylib&amp;rdquo;）。不需要省略文件扩展名，但这有助于使脚本跨平台。 SQLite将自动附加适当的扩展名。</target>
        </trans-unit>
        <trans-unit id="75252c48c68a826da51013f5fcc062daddeb6d8f" translate="yes" xml:space="preserve">
          <source>The first of the above that is found to exist and have the write and execute bits set is used. The final &quot;.&quot; fallback is important for some applications that use SQLite inside of chroot jails that do not have the standard temporary file locations available.</source>
          <target state="translated">使用上述第一个被发现存在并设置了写和执行位的文件。最后一个&quot;.&quot;的回退对于一些在chroot监狱中使用SQLite的应用程序非常重要,因为这些应用程序没有标准的临时文件位置。</target>
        </trans-unit>
        <trans-unit id="1f9a60bfbed88db253a25c41a987f86e19f4d6aa" translate="yes" xml:space="preserve">
          <source>The first page of a cell payload overflow chain. The page number is the b-tree page that contains the cell whose content has overflowed.</source>
          <target state="translated">单元格有效载荷溢出链的第一页。页码是包含内容已溢出的单元格的b树页。</target>
        </trans-unit>
        <trans-unit id="571e717de8bab6f472a3daa4d0e34a129cf9485d" translate="yes" xml:space="preserve">
          <source>The first parameter is a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. If this statement is a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement and the Nth column of the returned result set of that &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; is a table column (not an expression or subquery) then the declared type of the table column is returned. If the Nth column of the result set is an expression or subquery, then a NULL pointer is returned. The returned string is always UTF-8 encoded.</source>
          <target state="translated">第一个参数是&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;。如果该语句是一个&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;语句和返回的结果集的第N列&lt;a href=&quot;lang_select&quot;&gt;选择&lt;/a&gt;被表列（不是表达式或子查询），则表列的声明的类型被返回。如果结果集的第N列是表达式或子查询，则返回NULL指针。返回的字符串始终是UTF-8编码的。</target>
        </trans-unit>
        <trans-unit id="2d95d478fea3b8287d0a6628b14c6c99e2b30bf0" translate="yes" xml:space="preserve">
          <source>The first parameter is a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. If this statement is a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement and the Nth column of the returned result set of that &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; is a table column (not an expression or subquery) then the declared type of the table column is returned. If the Nth column of the result set is an expression or subquery, then a NULL pointer is returned. The returned string is always UTF-8 encoded.</source>
          <target state="translated">第一个参数是&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;。如果该语句是一个&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;语句和返回的结果集的第N列&lt;a href=&quot;../lang_select&quot;&gt;选择&lt;/a&gt;被表列（不是表达式或子查询），则表列的声明的类型被返回。如果结果集的第N列是表达式或子查询，则返回NULL指针。返回的字符串始终是UTF-8编码的。</target>
        </trans-unit>
        <trans-unit id="c8355444303911368f3db824744273405e752637" translate="yes" xml:space="preserve">
          <source>The first parameter is the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; to which the SQL function is to be added. If an application uses more than one database connection then application-defined SQL functions must be added to each database connection separately.</source>
          <target state="translated">第一个参数是要添加SQL函数的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;。如果一个应用程序使用多个数据库连接，则必须将应用程序定义的SQL函数分别添加到每个数据库连接中。</target>
        </trans-unit>
        <trans-unit id="2034bce444668b7bc337245a2c547e0aff9b9fd1" translate="yes" xml:space="preserve">
          <source>The first parameter is the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; to which the SQL function is to be added. If an application uses more than one database connection then application-defined SQL functions must be added to each database connection separately.</source>
          <target state="translated">第一个参数是要添加SQL函数的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;。如果一个应用程序使用多个数据库连接，则必须将应用程序定义的SQL函数分别添加到每个数据库连接中。</target>
        </trans-unit>
        <trans-unit id="02bbb4f6b68ff55742031c8b1808d80607aaa103" translate="yes" xml:space="preserve">
          <source>The first parameter must be a copy of the &lt;a href=&quot;#sqlite3_context&quot;&gt;SQL function context&lt;/a&gt; that is the first parameter to the xStep or xFinal callback routine that implements the aggregate function.</source>
          <target state="translated">第一个参数必须是&lt;a href=&quot;#sqlite3_context&quot;&gt;SQL函数上下文&lt;/a&gt;的副本，该副本是实现聚合函数的xStep或xFinal回调例程的第一个参数。</target>
        </trans-unit>
        <trans-unit id="303b1214ac90198e86e2d6fded39de6f12728048" translate="yes" xml:space="preserve">
          <source>The first parameter must be a copy of the &lt;a href=&quot;context&quot;&gt;SQL function context&lt;/a&gt; that is the first parameter to the xStep or xFinal callback routine that implements the aggregate function.</source>
          <target state="translated">第一个参数必须是&lt;a href=&quot;context&quot;&gt;SQL函数上下文&lt;/a&gt;的副本，该副本是实现聚合函数的xStep或xFinal回调例程的第一个参数。</target>
        </trans-unit>
        <trans-unit id="51bc3b9167a1367dcb303b210930c2e99a40f80a" translate="yes" xml:space="preserve">
          <source>The first parameter passed to the callback function when it is invoked is a copy of the third parameter passed to sqlite3_wal_hook() when registering the callback. The second is a copy of the database handle. The third parameter is the name of the database that was written to - either &quot;main&quot; or the name of an &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed database. The fourth parameter is the number of pages currently in the write-ahead log file, including those that were just committed.</source>
          <target state="translated">调用回调函数时传递给它的第一个参数是注册回调时传递给sqlite3_wal_hook（）的第三个参数的副本。第二个是数据库句柄的副本。第三个参数是写入的数据库的名称-&amp;ldquo; main&amp;rdquo;或&lt;a href=&quot;../lang_attach&quot;&gt;ATTACH编辑的&lt;/a&gt;数据库的名称。第四个参数是当前预写日志文件中的页面数，包括刚刚提交的页面数。</target>
        </trans-unit>
        <trans-unit id="8448fcb45b7f072723f93590a80d37aef6a727c3" translate="yes" xml:space="preserve">
          <source>The first parameter passed to the callback function when it is invoked is a copy of the third parameter passed to sqlite3_wal_hook() when registering the callback. The second is a copy of the database handle. The third parameter is the name of the database that was written to - either &quot;main&quot; or the name of an &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed database. The fourth parameter is the number of pages currently in the write-ahead log file, including those that were just committed.</source>
          <target state="translated">调用回调函数时传递给它的第一个参数是注册回调时传递给sqlite3_wal_hook（）的第三个参数的副本。第二个是数据库句柄的副本。第三个参数是写入的数据库的名称-&amp;ldquo; main&amp;rdquo;或&lt;a href=&quot;lang_attach&quot;&gt;ATTACH编辑的&lt;/a&gt;数据库的名称。第四个参数是当前预写日志文件中的页面数，包括刚刚提交的页面数。</target>
        </trans-unit>
        <trans-unit id="114b67e4b3a89669211882b27d3030f929c0b812" translate="yes" xml:space="preserve">
          <source>The first parameter to the authorizer callback is a copy of the third parameter to the sqlite3_set_authorizer() interface. The second parameter to the callback is an integer &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;action code&lt;/a&gt; that specifies the particular action to be authorized. The third through sixth parameters to the callback are either NULL pointers or zero-terminated strings that contain additional details about the action to be authorized. Applications must always be prepared to encounter a NULL pointer in any of the third through the sixth parameters of the authorization callback.</source>
          <target state="translated">Authorizer回调的第一个参数是第三个参数到sqlite3_set_authorizer（）接口的副本。回调的第二个参数是整数&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;操作代码&lt;/a&gt;，它指定要授权的特定操作。回调的第三到第六个参数是NULL指针或零终止字符串，其中包含有关要授权的操作的其他详细信息。应用程序必须始终准备在授权回调的第三至第六个参数中的任何一个中遇到NULL指针。</target>
        </trans-unit>
        <trans-unit id="031900d436ad256c6483a02e204c32e4df2ca84e" translate="yes" xml:space="preserve">
          <source>The first parameter to the authorizer callback is a copy of the third parameter to the sqlite3_set_authorizer() interface. The second parameter to the callback is an integer &lt;a href=&quot;c_alter_table&quot;&gt;action code&lt;/a&gt; that specifies the particular action to be authorized. The third through sixth parameters to the callback are either NULL pointers or zero-terminated strings that contain additional details about the action to be authorized. Applications must always be prepared to encounter a NULL pointer in any of the third through the sixth parameters of the authorization callback.</source>
          <target state="translated">Authorizer回调的第一个参数是第三个参数到sqlite3_set_authorizer（）接口的副本。回调的第二个参数是整数&lt;a href=&quot;c_alter_table&quot;&gt;操作代码&lt;/a&gt;，它指定要授权的特定操作。回调的第三到第六个参数是NULL指针或零终止字符串，其中包含有关要授权的操作的其他详细信息。应用程序必须始终准备在授权回调的第三至第六个参数中的任何一个中遇到NULL指针。</target>
        </trans-unit>
        <trans-unit id="1622094cd4d4c27ce242fb95c194e4ab11274192" translate="yes" xml:space="preserve">
          <source>The first parameter to these interfaces (hereafter referred to as F) must be one of:</source>
          <target state="translated">这些接口的第一个参数(以下简称F)必须是其中之一。</target>
        </trans-unit>
        <trans-unit id="29c4884990e25d1601d544fb2189fcbf8e2210be" translate="yes" xml:space="preserve">
          <source>The first section introduces the concept of an SQL foreign key by example and defines the terminology used for the remainder of the document. Section 2 describes the steps an application must take in order to enable foreign key constraints in SQLite (it is disabled by default). The next section, section 3, describes the indexes that the user must create in order to use foreign key constraints, and those that should be created in order for foreign key constraints to function efficiently. Section 4 describes the advanced foreign key related features supported by SQLite and section 5 describes the way the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER&lt;/a&gt; and &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; commands are enhanced to support foreign key constraints. Finally, section 6 enumerates the missing features and limits of the current implementation.</source>
          <target state="translated">第一部分通过示例介绍了SQL外键的概念，并定义了文档其余部分使用的术语。第2节介绍了应用程序在SQLite中启用外键约束所必须采取的步骤（默认情况下已禁用）。下一部分，第3节，描述了用户必须创建的索引才能使用外键约束，以及为使外键约束有效运行而必须创建的索引。第4节介绍了SQLite支持的高级外键相关功能，第5节介绍了增强&lt;a href=&quot;lang_altertable&quot;&gt;ALTER&lt;/a&gt;和&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;命令以支持外键约束的方式。最后，第6节列举了当前实现的缺失功能和局限性。</target>
        </trans-unit>
        <trans-unit id="6abe8a139c8044b273ba74ec6b9c2e3f141ecabe" translate="yes" xml:space="preserve">
          <source>The first set of three values corresponds to the left-most column of the table (column 0) and the left-most matchable phrase in the query (phrase 0). If the table has more than one column, the second set of three values in the output array correspond to phrase 0 and column 1. Followed by phrase 0, column 2 and so on for all columns of the table. And so on for phrase 1, column 0, then phrase 1, column 1 etc. In other words, the data for occurrences of phrase</source>
          <target state="translated">第一组三个值对应于表格最左边的一列(列0)和查询中最左边的可匹配短语(短语0)。如果表有多于一列,输出数组中的第二组三个值对应短语0和第1列。接着是短语0,第2列,以此类推,表的所有列。以此类推短语1、第0列,然后是短语1、第1列等。换句话说,短语的出现数据为</target>
        </trans-unit>
        <trans-unit id="b88b9c17da99b9d9285ae75db888dfa7bebfc06c" translate="yes" xml:space="preserve">
          <source>The first six interfaces (_blob, _double, _int, _int64, _text, and _text16) each return the value of a result column in a specific data format. If the result column is not initially in the requested format (for example, if the query returns an integer but the sqlite3_column_text() interface is used to extract the value) then an automatic type conversion is performed.</source>
          <target state="translated">前六个接口(_blob,_double,_int,_int64,_text,和 _text16)分别返回特定数据格式的结果列的值。如果结果列最初并不是所要求的格式(例如,如果查询返回的是一个整数,但使用sqlite3_column_text()接口来提取值),那么就会进行自动类型转换。</target>
        </trans-unit>
        <trans-unit id="02811050bf1b47e5280ac4d9fe5bacd40c6fea46" translate="yes" xml:space="preserve">
          <source>The first six modifiers (1 through 6) simply add the specified amount of time to the date and time specified by the arguments to the left. The 's' character at the end of the modifier names is optional. Note that &quot;&amp;plusmn;NNN months&quot; works by rendering the original date into the YYYY-MM-DD format, adding the &amp;plusmn;NNN to the MM month value, then normalizing the result. Thus, for example, the data 2001-03-31 modified by '+1 month' initially yields 2001-04-31, but April only has 30 days so the date is normalized to 2001-05-01. A similar effect occurs when the original date is February 29 of a leapyear and the modifier is &amp;plusmn;N years where N is not a multiple of four.</source>
          <target state="translated">前六个修饰符（1到6）仅将指定的时间量添加到左侧参数所指定的日期和时间。修饰符名称末尾的's'字符是可选的。请注意，&amp;ldquo;&amp;plusmn;NNN月&amp;rdquo;的工作方式是将原始日期转换为YYYY-MM-DD格式，在MM月值中加上&amp;plusmn;NNN，然后对结果进行归一化。因此，例如，以&amp;ldquo; +1个月&amp;rdquo;修改的数据2001-03-31最初产生2001-04-31，但是4月只有30天，因此日期被归一化为2001-05-01。当原始日期是a年的2月29日并且修饰符是&amp;plusmn;N年，其中N不是4的倍数时，会发生类似的效果。</target>
        </trans-unit>
        <trans-unit id="67231aa738e6314e6f80285f8fe72b39964cf222" translate="yes" xml:space="preserve">
          <source>The first six modifiers (1 through 6) simply add the specified amount of time to the date and time specified by the preceding timestring and modifiers. The 's' character at the end of the modifier names is optional. Note that &quot;&amp;plusmn;NNN months&quot; works by rendering the original date into the YYYY-MM-DD format, adding the &amp;plusmn;NNN to the MM month value, then normalizing the result. Thus, for example, the data 2001-03-31 modified by '+1 month' initially yields 2001-04-31, but April only has 30 days so the date is normalized to 2001-05-01. A similar effect occurs when the original date is February 29 of a leapyear and the modifier is &amp;plusmn;N years where N is not a multiple of four.</source>
          <target state="translated">The first six modifiers (1 through 6) simply add the specified amount of time to the date and time specified by the preceding timestring and modifiers. The 's' character at the end of the modifier names is optional. Note that &quot;&amp;plusmn;NNN months&quot; works by rendering the original date into the YYYY-MM-DD format, adding the &amp;plusmn;NNN to the MM month value, then normalizing the result. Thus, for example, the data 2001-03-31 modified by '+1 month' initially yields 2001-04-31, but April only has 30 days so the date is normalized to 2001-05-01. A similar effect occurs when the original date is February 29 of a leapyear and the modifier is &amp;plusmn;N years where N is not a multiple of four.</target>
        </trans-unit>
        <trans-unit id="de80fd15e7d30919dde63ea2e434aa9d73b98e29" translate="yes" xml:space="preserve">
          <source>The first step toward dealing with a hot journal is to obtain an exclusive lock on the database file. This prevents two or more processes from trying to rollback the same hot journal at the same time.</source>
          <target state="translated">处理热日志的第一步是获得数据库文件上的独占锁,这样可以防止两个或多个进程同时试图回滚同一个热日志。这可以防止两个或多个进程同时试图回滚同一个热日志。</target>
        </trans-unit>
        <trans-unit id="6d5dce142e8b6c56f2485efc4da630bd41e2b246" translate="yes" xml:space="preserve">
          <source>The first step toward reading from the database file is obtaining a shared lock on the database file. A &quot;shared&quot; lock allows two or more database connections to read from the database file at the same time. But a shared lock prevents another database connection from writing to the database file while we are reading it. This is necessary because if another database connection were writing to the database file at the same time we are reading from the database file, we might read some data before the change and other data after the change. This would make it appear as if the change made by the other process is not atomic.</source>
          <target state="translated">从数据库文件读取的第一步是获得数据库文件的共享锁。一个 &quot;共享 &quot;锁允许两个或多个数据库连接同时从数据库文件中读取。但是共享锁可以防止另一个数据库连接在我们读取数据库文件的时候向数据库文件写入。这是必要的,因为如果另一个数据库连接在我们从数据库文件读取的同时向数据库文件写入数据,我们可能会在改变之前读取一些数据,而在改变之后读取其他数据。这样就会显得另一个进程所做的改变不是原子性的。</target>
        </trans-unit>
        <trans-unit id="728a2c812c40e366db04b46879d8327a7463b66e" translate="yes" xml:space="preserve">
          <source>The first string or bareword in a column declaration is the column name. It is an error to attempt to name an fts5 table column &quot;rowid&quot; or &quot;rank&quot;, or to assign the same name to a column as is used by the table itself. This is not supported.</source>
          <target state="translated">列声明中的第一个字符串或裸字是列名。试图将fts5表列命名为 &quot;rowid &quot;或 &quot;rank&quot;,或者将表本身使用的相同名称分配给列,都是错误的。这是不支持的。</target>
        </trans-unit>
        <trans-unit id="15aebb5889bf7eacd8a14d41dd89f37206fa7a06" translate="yes" xml:space="preserve">
          <source>The first subquery above is constant with respect to the outer query. The value for the first subquery can be computed once and then reused for each row of the outer SELECT. The second subquery, however, is &quot;CORRELATED&quot;. The value of the second subquery changes depending on values in the current row of the outer query. Hence, the second subquery must be run once for each output row in the outer SELECT.</source>
          <target state="translated">上面的第一个子查询相对于外层查询来说是不变的。第一个子查询的值可以计算一次,然后对外部SELECT的每一条记录重复使用。而第二个子查询则是 &quot;CORRELATED&quot;。第二个子查询的值会根据外侧查询的当前行的值而改变。因此,第二个子查询必须为外侧SELECT中的每一条输出行运行一次。</target>
        </trans-unit>
        <trans-unit id="c31bdf542d6f05cfa5241d61c80e5148ec82df02" translate="yes" xml:space="preserve">
          <source>The first term stored on each node (&quot;Term 1&quot; in the figure above) is stored verbatim. Each subsequent term is prefix-compressed with respect to its predecessor. Terms are stored within a page in sorted (memcmp) order.</source>
          <target state="translated">每个节点上存储的第一个术语(上图中的 &quot;术语1&quot;)是逐字存储的。后续的每一个术语相对于它的前一个术语都是前缀压缩的。术语按排序(memcmp)顺序存储在一个页面中。</target>
        </trans-unit>
        <trans-unit id="7a099bb22daac790c8e16aa7a285108628e1197d" translate="yes" xml:space="preserve">
          <source>The first thing that happens is that we open the table being indexed for reading. In order to construct an index for a table, we have to know what is in that table. The index has already been opened for writing using cursor 0 by instructions 3 and 4.</source>
          <target state="translated">首先,我们打开被索引的表进行读取。为了构建一个表的索引,我们必须知道这个表里有什么。通过指令3和指令4,已经用游标0打开了索引进行写入。</target>
        </trans-unit>
        <trans-unit id="5eb1752f78007fa49f66b7f76488ea011879482b" translate="yes" xml:space="preserve">
          <source>The first time that any SQLite process attempts to access the database file, it obtains a shared lock as described in &lt;a href=&quot;https://sqlite.org/section_3_2&quot;&gt;section 3.2&lt;/a&gt; above. But then it notices that there is a rollback journal file present. SQLite then checks to see if the rollback journal is a &quot;hot journal&quot;. A hot journal is a rollback journal that needs to be played back in order to restore the database to a sane state. A hot journal only exists when an earlier process was in the middle of committing a transaction when it crashed or lost power.</source>
          <target state="translated">任何SQLite进程首次尝试访问数据库文件时，都会获得共享锁，如上面&lt;a href=&quot;https://sqlite.org/section_3_2&quot;&gt;3.2节中&lt;/a&gt;所述。但是随后它注意到存在回滚日志文件。然后，SQLite检查回滚日志是否为&amp;ldquo;热日志&amp;rdquo;。热日志是一种回滚日志，需要将其还原才能将数据库还原到正常状态。仅当较早的进程崩溃或断电时才提交事务时，才存在热日志。</target>
        </trans-unit>
        <trans-unit id="e68a1d44352d39217814d6bf160a385833864476" translate="yes" xml:space="preserve">
          <source>The first time the sqlite3_aggregate_context(C,N) routine is called for a particular aggregate function, SQLite allocates N bytes of memory, zeroes out that memory, and returns a pointer to the new memory. On second and subsequent calls to sqlite3_aggregate_context() for the same aggregate function instance, the same buffer is returned. Sqlite3_aggregate_context() is normally called once for each invocation of the xStep callback and then one last time when the xFinal callback is invoked. When no rows match an aggregate query, the xStep() callback of the aggregate function implementation is never called and xFinal() is called exactly once. In those cases, sqlite3_aggregate_context() might be called for the first time from within xFinal().</source>
          <target state="translated">第一次调用sqlite3_aggregate_context(C,N)例程来执行一个特定的聚合函数时,SQLite会分配N个字节的内存,将该内存清零,并返回一个指向新内存的指针。在第二次以及后续调用sqlite3_aggregate_context()对同一个聚合函数实例进行调用时,返回相同的缓冲区。Sqlite3_aggregate_context()通常在每次调用xStep回调时调用一次,然后在调用xFinal回调时调用最后一次。当没有记录匹配聚合查询时,聚合函数实现的xStep()回调永远不会被调用,而xFinal()正好被调用一次。在这些情况下,sqlite3_aggregate_context()可能会在xFinal()中第一次被调用。</target>
        </trans-unit>
        <trans-unit id="e3a42cd86f3f8e7c9fddbcba13c3c1c638314931" translate="yes" xml:space="preserve">
          <source>The first time the sqlite3_aggregate_context(C,N) routine is called for a particular aggregate function, SQLite allocates N of memory, zeroes out that memory, and returns a pointer to the new memory. On second and subsequent calls to sqlite3_aggregate_context() for the same aggregate function instance, the same buffer is returned. Sqlite3_aggregate_context() is normally called once for each invocation of the xStep callback and then one last time when the xFinal callback is invoked. When no rows match an aggregate query, the xStep() callback of the aggregate function implementation is never called and xFinal() is called exactly once. In those cases, sqlite3_aggregate_context() might be called for the first time from within xFinal().</source>
          <target state="translated">第一次调用sqlite3_aggregate_context(C,N)例程来执行一个特定的聚合函数时,SQLite会分配N个内存,将该内存清零,并返回一个指向新内存的指针。在第二次以及后续对同一聚合函数实例调用 sqlite3_aggregate_context()时,返回相同的缓冲区。Sqlite3_aggregate_context()通常在每次调用xStep回调时调用一次,然后在调用xFinal回调时调用最后一次。当没有记录匹配聚合查询时,聚合函数实现的xStep()回调永远不会被调用,而xFinal()正好被调用一次。在这些情况下,sqlite3_aggregate_context()可能会在xFinal()中被第一次调用。</target>
        </trans-unit>
        <trans-unit id="33a73e33477151458e48dab8a4d76f2a383719c8" translate="yes" xml:space="preserve">
          <source>The first two constants (SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE) cause sqlite3_mutex_alloc() to create a new mutex. The new mutex is recursive when SQLITE_MUTEX_RECURSIVE is used but not necessarily so when SQLITE_MUTEX_FAST is used. The mutex implementation does not need to make a distinction between SQLITE_MUTEX_RECURSIVE and SQLITE_MUTEX_FAST if it does not want to. SQLite will only request a recursive mutex in cases where it really needs one. If a faster non-recursive mutex implementation is available on the host platform, the mutex subsystem might return such a mutex in response to SQLITE_MUTEX_FAST.</source>
          <target state="translated">前两个常量(SQLITE_MUTEX_FAST和SQLITE_MUTEX_RECURSIVE)会导致 sqlite3_mutex_alloc()创建一个新的mutex。当使用SQLITE_MUTEX_RECURSIVE时,新的mutex是递归的,但当使用SQLITE_MUTEX_FAST时就不一定了。如果不想区分SQLITE_MUTEX_RECURSIVE和SQLITE_MUTEX_FAST,mutex实现不需要区分。SQLite只会在真正需要递归mutex的情况下请求递归mutex。如果主机平台上有更快的非递归mutex实现,mutex子系统可能会返回这样的mutex来响应SQLITE_MUTEX_FAST。</target>
        </trans-unit>
        <trans-unit id="3ad84c4124333660ac2ec2d4b3b96a74793fd127" translate="yes" xml:space="preserve">
          <source>The first two elements in the list above, the associated</source>
          <target state="translated">上述清单中的前两个要素,即相关的</target>
        </trans-unit>
        <trans-unit id="9de36623b06dcc8a12dabc9fe8d69bf46f2afdab" translate="yes" xml:space="preserve">
          <source>The first two instructions in the VDBE program for our query are concerned with setting up values for &lt;b&gt;azColumn&lt;/b&gt;. The &lt;a href=&quot;opcode#ColumnName&quot;&gt;ColumnName&lt;/a&gt; instructions tell the VDBE what values to fill in for each element of the &lt;b&gt;azColumnName[]&lt;/b&gt; array. Every query will begin with one ColumnName instruction for each column in the result, and there will be a matching Column instruction for each one later in the query.</source>
          <target state="translated">VDBE程序中用于查询的前两个指令涉及为&lt;b&gt;azColumn&lt;/b&gt;设置值。所述&lt;a href=&quot;opcode#ColumnName&quot;&gt;的ColumnName&lt;/a&gt;指令告诉VDBE填补哪些值在用于的每个元素&lt;b&gt;azColumnName []&lt;/b&gt;数组。每个查询将以一个ColumnName指令开头结果中的每一列，并且稍后在查询中将为每一个列提供匹配的Column指令。</target>
        </trans-unit>
        <trans-unit id="80f7eaccbd1b0c6d2fde7b56494766bcf2304eb6" translate="yes" xml:space="preserve">
          <source>The first two query examples illustrate a kind of template that every SELECT program will follow. Basically, we have:</source>
          <target state="translated">前两个查询示例说明了一种模板,每个SELECT程序都会遵循。基本上,我们有:</target>
        </trans-unit>
        <trans-unit id="c636087069b26e9346b965d8bb5b5d8294795344" translate="yes" xml:space="preserve">
          <source>The first value in the array of integer values corresponds to the leftmost column of the table (column 0) and the first phrase in the query (phrase 0). The values corresponding to other column/phrase combinations may be located using the following formula:</source>
          <target state="translated">整数数组中的第一个值对应于表的最左列(列0)和查询中的第一个短语(短语0)。对应于其他列/短语组合的值可以用下面的公式来定位。</target>
        </trans-unit>
        <trans-unit id="61029d8449643ad48e743f1026fb94f8a1ed1222" translate="yes" xml:space="preserve">
          <source>The first, or only, integer is the blockid that corresponds to the interior node with the largest blockid that belongs to this segment b-tree. Or zero if the entire segment b-tree fits on the root node. If it exists, this node is always an interior node.</source>
          <target state="translated">第一个,或者说唯一的整数,是对应于这个段b树的最大blockid的内部节点的blockid。如果整个段b树都适合在根节点上,则为零。如果存在,这个节点总是内部节点。</target>
        </trans-unit>
        <trans-unit id="c0ebe13b31f8942f70d44d11a35f84a9529666cd" translate="yes" xml:space="preserve">
          <source>The fix in the 3.25.0 release for the endless-loop in the byte-code associated with the ORDER BY LIMIT optimization did not work for some queries involving window functions. An additional correction is required. Ticket &lt;a href=&quot;https://sqlite.org/src/info/510cde277783b5fb&quot;&gt;510cde277783b5fb&lt;/a&gt;</source>
          <target state="translated">3.25.0版本中针对与ORDER BY LIMIT优化相关联的字节码中的无限循环的修复不适用于某些涉及窗口函数的查询。需要进行其他更正。门票&lt;a href=&quot;https://sqlite.org/src/info/510cde277783b5fb&quot;&gt;510cde277783b5fb&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c2032be06ad1313d23c4aa0f2d29e1f73447dfd8" translate="yes" xml:space="preserve">
          <source>The fix to the previous bug uncovered a deadlock which was also fixed.</source>
          <target state="translated">之前的bug的修复发现了一个死锁,也被修复了。</target>
        </trans-unit>
        <trans-unit id="8197368f601d93edb14a348de0bf212d3c1bcf51" translate="yes" xml:space="preserve">
          <source>The flags argument to xAccess() may be &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; to test for the existence of a file, or &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; to test whether a file is readable and writable, or &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; to test whether a file is at least readable. The SQLITE_ACCESS_READ flag is never actually used and is not implemented in the built-in VFSes of SQLite. The file is named by the second argument and can be a directory. The xAccess method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success or some non-zero error code if there is an I/O error or if the name of the file given in the second argument is illegal. If SQLITE_OK is returned, then non-zero or zero is written into *pResOut to indicate whether or not the file is accessible.</source>
          <target state="translated">flags参数到Xaccess文件（）可以是&lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt;到用于测试的存在的文件的，或&lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt;到测试文件是否是可读写的，或&lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt;到测试文件是否至少可读。 SQLITE_ACCESS_READ标志从不实际使用，也不在SQLite的内置VFS中实现。该文件由第二个参数命名，并且可以是目录。如果出现I / O错误或第二个参数中给定的文件名不&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;合法&lt;/a&gt;，则xAccess方法成功返回SQLITE_OK或返回一些非零错误代码。如果返回SQLITE_OK，则将非零或零写入* pResOut，以指示该文件是否可访问。</target>
        </trans-unit>
        <trans-unit id="ee0102cf2398a56ff989592f19a055847f5dc920" translate="yes" xml:space="preserve">
          <source>The flags argument to xAccess() may be &lt;a href=&quot;c_access_exists&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; to test for the existence of a file, or &lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; to test whether a file is readable and writable, or &lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; to test whether a file is at least readable. The SQLITE_ACCESS_READ flag is never actually used and is not implemented in the built-in VFSes of SQLite. The file is named by the second argument and can be a directory. The xAccess method returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success or some non-zero error code if there is an I/O error or if the name of the file given in the second argument is illegal. If SQLITE_OK is returned, then non-zero or zero is written into *pResOut to indicate whether or not the file is accessible.</source>
          <target state="translated">flags参数到Xaccess文件（）可以是&lt;a href=&quot;c_access_exists&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt;到用于测试的存在的文件的，或&lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt;到测试文件是否是可读写的，或&lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt;到测试文件是否至少可读。 SQLITE_ACCESS_READ标志从不实际使用，也不在SQLite的内置VFS中实现。该文件由第二个参数命名，并且可以是目录。如果出现I / O错误或第二个参数中给定的文件名不&lt;a href=&quot;../rescode#ok&quot;&gt;合法&lt;/a&gt;，则xAccess方法成功返回SQLITE_OK或返回一些非零错误代码。如果返回SQLITE_OK，则将非零或零写入* pResOut，以指示该文件是否可访问。</target>
        </trans-unit>
        <trans-unit id="d9f0c284ad1c57f7e5da616991af768f686e341f" translate="yes" xml:space="preserve">
          <source>The flags argument to xOpen() includes all bits set in the flags argument to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. Or if &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt; is used, then flags includes at least &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;. If xOpen() opens a file read-only then it sets *pOutFlags to include &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;. Other bits in *pOutFlags may be set.</source>
          <target state="translated">xOpen（）的flags参数包括在&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;的flags参数中设置的所有位。或者，如果使用&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;或&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16（）&lt;/a&gt;，则标志至少包括&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | |。&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;。如果xOpen（）以只读方式打开文件，则它将* pOutFlags设置为包括&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;。 * pOutFlags中的其他位可以设置。</target>
        </trans-unit>
        <trans-unit id="f5198d48ad55972f3bafe448a5f83115c01462b7" translate="yes" xml:space="preserve">
          <source>The flags argument to xOpen() includes all bits set in the flags argument to &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. Or if &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt; is used, then flags includes at least &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;. If xOpen() opens a file read-only then it sets *pOutFlags to include &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;. Other bits in *pOutFlags may be set.</source>
          <target state="translated">xOpen（）的flags参数包括在&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;的flags参数中设置的所有位。或者，如果使用&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;或&lt;a href=&quot;open&quot;&gt;sqlite3_open16（）&lt;/a&gt;，则标志至少包括&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | |。&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;。如果xOpen（）以只读方式打开文件，则它将* pOutFlags设置为包括&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;。 * pOutFlags中的其他位可以设置。</target>
        </trans-unit>
        <trans-unit id="7bc004618637404d4a4bd35b24cc91bd411a3086" translate="yes" xml:space="preserve">
          <source>The flags argument to xSync may be one of &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt; or &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt;. The first choice is the normal fsync(). The second choice is a Mac OS X style fullsync. The &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_DATAONLY&lt;/a&gt; flag may be ORed in to indicate that only the data of the file and not its inode needs to be synced.</source>
          <target state="translated">xSync的flags参数可以是&lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt;或&lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_FULL之一&lt;/a&gt;。首选是普通的fsync（）。第二个选择是Mac OS X风格的fullsync。可以对&lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_DATAONLY&lt;/a&gt;标志进行OR运算，以指示仅文件的数据而不是其索引节点需要同步。</target>
        </trans-unit>
        <trans-unit id="99d3aea2b8c0b18767851d7c8d3921e4603f6ed1" translate="yes" xml:space="preserve">
          <source>The flags argument to xSync may be one of &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt; or &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt;. The first choice is the normal fsync(). The second choice is a Mac OS X style fullsync. The &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_DATAONLY&lt;/a&gt; flag may be ORed in to indicate that only the data of the file and not its inode needs to be synced.</source>
          <target state="translated">xSync的flags参数可以是&lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt;或&lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL之一&lt;/a&gt;。首选是普通的fsync（）。第二个选择是Mac OS X风格的fullsync。可以对&lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_DATAONLY&lt;/a&gt;标志进行OR运算，以指示仅文件的数据而不是其索引节点需要同步。</target>
        </trans-unit>
        <trans-unit id="c377d5a3884469a39150e12bd3af49c973f2fad1" translate="yes" xml:space="preserve">
          <source>The floating-point to text conversion subfunction for the built-in printf() is limited in precision to 16 significant digits or 26 significant digits if the &quot;!&quot; alternate-form-2 flag is used. Every IEEE-754 double can be represented exactly as a decimal floating-point value, but some doubles require more than 16 or 26 significant digits.</source>
          <target state="translated">内置printf()的浮点到文本转换子函数的精度限制为16位有效数字,如果使用&quot;!&quot;交替形式-2标志,则限制为26位有效数字,每个IEEE-754双数都可以完全表示十进制浮点值,但有些双数需要超过16或26位有效数字。每一个IEEE-754双数都可以用十进制浮点值来表示,但有些双数需要超过16或26个有意义的数字。</target>
        </trans-unit>
        <trans-unit id="68fce5c170ab1896511f13fd3e82f411098f2695" translate="yes" xml:space="preserve">
          <source>The folder returned by the GetTempPath() system interface.</source>
          <target state="translated">GetTempPath()系统接口返回的文件夹。</target>
        </trans-unit>
        <trans-unit id="4f48bdf9b1dfd94aea260fd19b610d7cf9d72be5" translate="yes" xml:space="preserve">
          <source>The folder set by &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt; or by the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable</source>
          <target state="translated">由&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt;或&lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;全局变量设置的文件夹</target>
        </trans-unit>
        <trans-unit id="8f393fa7f5f393cd220ff4a7a6a7ccbac66e5676" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://xkcd.com/1597/&quot;&gt;https://xkcd.com/1597/&lt;/a&gt; cartoon is an exaggeration, yet hits close to home:</source>
          <target state="translated">以下&lt;a href=&quot;https://xkcd.com/1597/&quot;&gt;https://xkcd.com/1597/&lt;/a&gt;卡通很夸张，但很受欢迎：</target>
        </trans-unit>
        <trans-unit id="40de557d79eeab5be4528c0beef95dcb1a5f7ef4" translate="yes" xml:space="preserve">
          <source>The following RBU database schema may be used:</source>
          <target state="translated">可使用下列区域局数据库模式:</target>
        </trans-unit>
        <trans-unit id="ae49ebf9365c52bbf37afc8c396e0cba8b2d31d3" translate="yes" xml:space="preserve">
          <source>The following SQL demonstrates how SQLite uses column affinity to do type conversions when values are inserted into a table.</source>
          <target state="translated">下面的SQL演示了当值被插入到表中时,SQLite如何使用列亲和力来进行类型转换。</target>
        </trans-unit>
        <trans-unit id="d10a8778dff23f69800ec8a5dd149287ef5743ba" translate="yes" xml:space="preserve">
          <source>The following SQL illustrates how to use the ieee754 and decimal extensions to compute the exact decimal equivalent for a binary64 floating-point number.</source>
          <target state="translated">下面的SQL说明了如何使用ieee754和十进制扩展来计算一个二进制64浮点数的精确十进制等值。</target>
        </trans-unit>
        <trans-unit id="b7479fafb0c600f993e6250d871980ae79cbdf35" translate="yes" xml:space="preserve">
          <source>The following SQLite command-line session illustrates the effect of the foreign key constraint added to the</source>
          <target state="translated">下面的SQLite命令行会话说明了外键约束添加至</target>
        </trans-unit>
        <trans-unit id="1f8a8aec572c42d81f9a9d30dc36ba0c1a7ca331" translate="yes" xml:space="preserve">
          <source>The following additional compile-time options are recommended in order to provide a full-featured command-line shell:</source>
          <target state="translated">为了提供一个功能齐全的命令行shell,建议使用以下额外的编译时选项。</target>
        </trans-unit>
        <trans-unit id="e661fc6daecc53fc88e2038803ed3bcb13092e93" translate="yes" xml:space="preserve">
          <source>The following additional syntax restrictions apply to UPDATE statements that occur within the body of a &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement.</source>
          <target state="translated">以下其他语法限制适用于&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;语句主体内的UPDATE 语句。</target>
        </trans-unit>
        <trans-unit id="0a78308c3e0962720a3b6c6b2c92b551ac030e31" translate="yes" xml:space="preserve">
          <source>The following are allowed values for 6th argument (the F argument) to the &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize(D,S,P,N,M,F)&lt;/a&gt; interface.</source>
          <target state="translated">以下是&lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize（D，S，P，N，M，F）&lt;/a&gt;接口的第六个参数（F参数）的允许值。</target>
        </trans-unit>
        <trans-unit id="b9076a86669fb7bce220c5cc2398686ebb071016" translate="yes" xml:space="preserve">
          <source>The following are allowed values for 6th argument (the F argument) to the &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize(D,S,P,N,M,F)&lt;/a&gt; interface.</source>
          <target state="translated">以下是&lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize（D，S，P，N，M，F）&lt;/a&gt;接口的第六个参数（F参数）的允许值。</target>
        </trans-unit>
        <trans-unit id="a59459d6632d0bbc1149f827b602fb3d835358c8" translate="yes" xml:space="preserve">
          <source>The following are examples of disabling the built-in protection mechanisms of SQLite:</source>
          <target state="translated">以下是禁用SQLite内置保护机制的例子。</target>
        </trans-unit>
        <trans-unit id="80d00e742a47603d638009e13703b23c42a0d91f" translate="yes" xml:space="preserve">
          <source>The following are other VFS implementations available in the public SQLite source tree:</source>
          <target state="translated">以下是公共SQLite源树中的其他VFS实现。</target>
        </trans-unit>
        <trans-unit id="ec123026fdd8e1c2278a5f9715d6939ab0dbeb46" translate="yes" xml:space="preserve">
          <source>The following are the available OMIT options:</source>
          <target state="translated">以下是可用的OMIT选项。</target>
        </trans-unit>
        <trans-unit id="8fa3cecc90ff41687bc039d2f339ed203679e422" translate="yes" xml:space="preserve">
          <source>The following block contains a summary of the FTS query syntax in BNF form. A detailed explanation follows.</source>
          <target state="translated">下面的块包含了BNF形式的FTS查询语法摘要。下面是详细的解释。</target>
        </trans-unit>
        <trans-unit id="9eacb2386777a09c397574d603b9f7b4a178b7c8" translate="yes" xml:space="preserve">
          <source>The following block contains an example of calling the fts3_tokenizer() function from C code:</source>
          <target state="translated">下面的代码块包含了一个从C代码中调用fts3_tokenizer()函数的例子。</target>
        </trans-unit>
        <trans-unit id="8a513f3e74d7cb1dc9f72503b5eb2053d246b6ad" translate="yes" xml:space="preserve">
          <source>The following block contains examples that use the offsets function.</source>
          <target state="translated">下面的代码块包含了使用偏移量函数的例子。</target>
        </trans-unit>
        <trans-unit id="5c334635414a3c37311f7280f25331d2da05c0d0" translate="yes" xml:space="preserve">
          <source>The following chart shows the substitution types supported by SQLite:</source>
          <target state="translated">下图显示了SQLite支持的替换类型。</target>
        </trans-unit>
        <trans-unit id="16f175b629dac9ff34c51ebace5610e8bb2a6ee9" translate="yes" xml:space="preserve">
          <source>The following compile-time options are recommended for applications that are able to use them, in order to minimized the number of CPU cycles and the bytes of memory used by SQLite. Not all of these compile-time options are usable by every application. For example, the SQLITE_THREADSAFE=0 option is only usable by applications that never access SQLite from more than one thread at a time. And the SQLITE_OMIT_PROGRESS_CALLBACK option is only usable by applications that do not use the &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler()&lt;/a&gt; interface. And so forth.</source>
          <target state="translated">对于能够使用它们的应用程序，建议使用以下编译时选项，以最大程度地减少CPU周期数和SQLite使用的内存字节。并非每个应用程序都可以使用所有这些编译时选项。例如，SQLITE_THREADSAFE = 0选项仅可用于永远不会一次从多个线程访问SQLite的应用程序。 SQLITE_OMIT_PROGRESS_CALLBACK选项仅由不使用&lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler（）&lt;/a&gt;接口的应用程序使用。依此类推。</target>
        </trans-unit>
        <trans-unit id="c06c8d896e801657db8f70d5a5bd2960e6843e64" translate="yes" xml:space="preserve">
          <source>The following compile-time options are recommended for applications that are able to use them, in order to minimized the number of CPU cycles and the bytes of memory used by SQLite. Not all of these compile-time options are usable by every application. For example, the SQLITE_THREADSAFE=0 option is only usable by applications that never access SQLite from more than one thread at a time. And the SQLITE_OMIT_PROGRESS_CALLBACK option is only usable by applications that doe not use the &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler()&lt;/a&gt; interface. And so forth.</source>
          <target state="translated">对于能够使用它们的应用程序，建议使用以下编译时选项，以最大程度地减少CPU周期数和SQLite使用的内存字节。并非每个应用程序都可以使用所有这些编译时选项。例如，SQLITE_THREADSAFE = 0选项仅可用于永远不会一次从多个线程访问SQLite的应用程序。SQLITE_OMIT_PROGRESS_CALLBACK选项仅由不使用&lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler（）&lt;/a&gt;接口的应用程序使用。依此类推。</target>
        </trans-unit>
        <trans-unit id="1f053eef3c13d51d862b4f23cc04af6f84e75626" translate="yes" xml:space="preserve">
          <source>The following constants can be used for the T parameter to the &lt;a href=&quot;#sqlite3_stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus(S,X,T,V)&lt;/a&gt; interface. Each constant designates a different metric for sqlite3_stmt_scanstatus() to return.</source>
          <target state="translated">以下常量可用于&lt;a href=&quot;#sqlite3_stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus（S，X，T，V）&lt;/a&gt;接口的T参数。每个常量为sqlite3_stmt_scanstatus（）返回指定一个不同的度量。</target>
        </trans-unit>
        <trans-unit id="42e5a30e943fe484b45c04468e002affa80c1a88" translate="yes" xml:space="preserve">
          <source>The following constants can be used for the T parameter to the &lt;a href=&quot;stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus(S,X,T,V)&lt;/a&gt; interface. Each constant designates a different metric for sqlite3_stmt_scanstatus() to return.</source>
          <target state="translated">以下常量可用于&lt;a href=&quot;stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus（S，X，T，V）&lt;/a&gt;接口的T参数。每个常量为sqlite3_stmt_scanstatus（）返回指定一个不同的度量。</target>
        </trans-unit>
        <trans-unit id="0dd0f222abc9f123e613d4dc8f011601915507ab" translate="yes" xml:space="preserve">
          <source>The following diagram depicts the format of a segment b-tree interior (non-leaf) node.</source>
          <target state="translated">下图描述了段b树内部(非叶)节点的格式。</target>
        </trans-unit>
        <trans-unit id="24519f5efb1b482cdcbf663c45ec684bda267ab2" translate="yes" xml:space="preserve">
          <source>The following diagram depicts the format of a segment b-tree leaf node.</source>
          <target state="translated">下图描述了段b树叶子节点的格式。</target>
        </trans-unit>
        <trans-unit id="d2d809dec5a64a655b9636ca71424601eda3c8d0" translate="yes" xml:space="preserve">
          <source>The following example code illustrates the techniques described above.</source>
          <target state="translated">下面的示例代码说明了上述技术。</target>
        </trans-unit>
        <trans-unit id="54bdf2a30ded538a716ed8a4baee084a78f8a312" translate="yes" xml:space="preserve">
          <source>The following example creates a new SQL function named &quot;hex&quot; that converts its numeric argument in to a hexadecimal encoded string:</source>
          <target state="translated">下面的示例创建了一个名为 &quot;hex &quot;的新SQL函数,该函数将其数字参数转换为十六进制编码的字符串。</target>
        </trans-unit>
        <trans-unit id="9d4eb7545f22068db9db1145bb2583cae1439f33" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the effect of the various forms of the EXCLUDE clause:</source>
          <target state="translated">下面的例子展示了各种形式的EXCLUDE子句的效果。</target>
        </trans-unit>
        <trans-unit id="3fb64142e08ab04e58bc3d16cc93b9564bb653f2" translate="yes" xml:space="preserve">
          <source>The following example illustrates precedence of operators using the standard query syntax:</source>
          <target state="translated">下面的例子说明了使用标准查询语法的运算符的优先性。</target>
        </trans-unit>
        <trans-unit id="33e08656a40dfd68bcb2d6194c63e1be80dcd4d4" translate="yes" xml:space="preserve">
          <source>The following example illustrates the above. The expressions &quot;docs&quot;, &quot;docs.docs&quot; and &quot;main.docs.docs&quot; all refer to column &quot;docs&quot;. However, the expression &quot;main.docs&quot; does not refer to any column. It could be used to refer to a table, but a table name is not allowed in the context in which it is used below.</source>
          <target state="translated">下面的例子说明了上述情况。表达式 &quot;docs&quot;、&quot;docs.docs &quot;和 &quot;main.docs.docs &quot;都指向列 &quot;docs&quot;。然而,表达式 &quot;main.docs &quot;并不指向任何列。它可以用来指代一个表,但在下面使用它的上下文中,不允许使用表名。</target>
        </trans-unit>
        <trans-unit id="6318f87943b573664a21e50213cf281e74663a27" translate="yes" xml:space="preserve">
          <source>The following example illustrates the behaviour of the five ranking functions - row_number(), rank(), dense_rank(), percent_rank() and cume_dist().</source>
          <target state="translated">下面的例子说明了row_number()、rank()、dense_rank()、percent_rank()和cume_dist()这五个排名函数的行为。</target>
        </trans-unit>
        <trans-unit id="fd2f5de221e0f758d71eb8931f8c7e719ace6200" translate="yes" xml:space="preserve">
          <source>The following example illustrates the effect of using a deferred foreign key constraint.</source>
          <target state="translated">下面的例子说明了使用延迟外键约束的效果。</target>
        </trans-unit>
        <trans-unit id="c39a3730f5c13caef84a726a00ac693030617813" translate="yes" xml:space="preserve">
          <source>The following example shows how to remove NUL character, and all text that follows, from a column of a table. So if you have a database file that contains embedded NULs and you would like to remove them, running UPDATE statements similar to the following might help:</source>
          <target state="translated">下面的例子展示了如何从表的一列中删除NUL字符,以及后面的所有文本。因此,如果你的数据库文件中包含了内嵌的NULs,你想删除它们,运行类似于下面的UPDATE语句可能会有帮助。</target>
        </trans-unit>
        <trans-unit id="21740a6dff76788fbc521cbbbedbec453f6795d5" translate="yes" xml:space="preserve">
          <source>The following example uses the sumint() function implemented by the above C code. For each row, the window consists of the preceding row (if any), the current row and the following row (again, if any):</source>
          <target state="translated">下面的例子使用了上述C代码实现的sumint()函数。对于每一行,窗口由前一行(如果有的话)、当前一行和后一行(如果有的话)组成。</target>
        </trans-unit>
        <trans-unit id="9b577d330901567bab085337ea84d2a43135e876" translate="yes" xml:space="preserve">
          <source>The following example will better illustrate the use of SQLITE_CONSTRAINT as a return value from xBestIndex:</source>
          <target state="translated">下面的例子可以更好地说明SQLITE_CONSTRAINT作为xBestIndex的返回值的使用。</target>
        </trans-unit>
        <trans-unit id="3f5880fbaaf652f0861c35b2ed9bf834e8800e30" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 4th parameter to &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt; and &lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt;:</source>
          <target state="translated">以下标志可以通过第4个参数传递给&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt;和&lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="dcb818ec6ae695589b5e698d66cbb55415f5689e" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 4th parameter to &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt; and &lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt;:</source>
          <target state="translated">以下标志可以通过第4个参数传递给&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt;和&lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="eaf06e6487557d77e67f76618b64eb4b39aae85e" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 9th parameter to &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt; and &lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt;:</source>
          <target state="translated">以下标志可以通过第9个参数传递给&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt;和&lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="8acfd72cc7dc7df0be4ef94764fa15b5b7e0e403" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 9th parameter to &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt; and &lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt;:</source>
          <target state="translated">以下标志可以通过第9个参数传递给&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt;和&lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="90a5abe74323cb727451a1fc89d79f6674e34a04" translate="yes" xml:space="preserve">
          <source>The following four configuration changes are recommended for maximum application security. Turning off the trust_schema setting prevents virtual tables and dodgy SQL functions from being used inside of triggers, views, CHECK constraints, generated columns, and expression indexes. Turning off the dqs_dml and dqs_ddl settings prevents the use of double-quoted strings. Turning on defensive prevents direct writes to shadow tables.</source>
          <target state="translated">为了最大限度地提高应用程序的安全性,建议进行以下四项配置更改。关闭trust_schema设置可以防止在触发器、视图、CHECK约束、生成的列和表达式索引内部使用虚拟表和可疑的SQL函数。关闭dqs_dml和dqs_ddl设置可以防止使用双引号字符串。开启防御功能可以防止对影子表的直接写入。</target>
        </trans-unit>
        <trans-unit id="f88559c5309089b2c53eff7ab551567dc8265aad" translate="yes" xml:space="preserve">
          <source>The following functions can be used to advance and query a changeset iterator created by this function:</source>
          <target state="translated">以下函数可以用来推进和查询由该函数创建的变化集迭代器。</target>
        </trans-unit>
        <trans-unit id="35f53ac017499b71e5f28f348a1b347ee5939139" translate="yes" xml:space="preserve">
          <source>The following is a log of all SQL used to generate one particular timeline (captured on 2016-09-16):</source>
          <target state="translated">以下是用于生成一个特定时间轴的所有SQL的日志(捕获于2016-09-16)。</target>
        </trans-unit>
        <trans-unit id="8ca654574638bb42c5b323e2fbbcf528a1c97560" translate="yes" xml:space="preserve">
          <source>The following is a partial list of the kinds of messages that might appear in the error logger callback.</source>
          <target state="translated">以下是可能出现在错误记录器回调中的部分消息类型列表。</target>
        </trans-unit>
        <trans-unit id="91f9f5074c39cae7458cb274b5e2472dd1f18791" translate="yes" xml:space="preserve">
          <source>The following is a random assortment of techniques used by the SQLite developers to trace, examine, and understand the behavior of the core SQLite library.</source>
          <target state="translated">以下是SQLite开发人员用来跟踪、检查和了解核心SQLite库行为的随机分类技术。</target>
        </trans-unit>
        <trans-unit id="172b7cc8402676bd9591f1901c350fe56e3b1a3a" translate="yes" xml:space="preserve">
          <source>The following is sqlite3_analyzer output for an example places.sqlite database used by Firefox.</source>
          <target state="translated">下面是sqlite3_analyzer对Firefox使用的一个例子places.sqlite数据库的输出。</target>
        </trans-unit>
        <trans-unit id="3b9bb38ec5e22c57b0f7c289494707329a29a947" translate="yes" xml:space="preserve">
          <source>The following limitations apply to RBU updates:</source>
          <target state="translated">以下限制适用于区域局的更新:</target>
        </trans-unit>
        <trans-unit id="fc2fda4c09167d54864b95b318f076cb56ce31c3" translate="yes" xml:space="preserve">
          <source>The following macros specify interface linkage for certain kinds of SQLite builds. The Makefiles will normally handle setting these macros automatically. Application developers should not need to worry with these macros. The following documentation about these macros is included completeness.</source>
          <target state="translated">下面的宏指定了某些类型的 SQLite 编译的接口链接。通常Makefiles会自动处理这些宏的设置。应用程序开发人员不需要担心这些宏。以下是关于这些宏的完整文档。</target>
        </trans-unit>
        <trans-unit id="e520cf121083171350ce54bdc25d9fb94f2ae9df" translate="yes" xml:space="preserve">
          <source>The following must be true for this function to succeed. If any of the following statements are false when sqlite3_snapshot_get() is called, SQLITE_ERROR is returned. The final value of *P is undefined in this case.</source>
          <target state="translated">为了使这个函数成功,以下语句必须为真。如果调用sqlite3_snapshot_get()时,以下任何一条语句为假,则返回SQLITE_ERROR。在这种情况下,*P的最终值是未定义的。</target>
        </trans-unit>
        <trans-unit id="13b4c313c53ce999997969a2a1da623479829206" translate="yes" xml:space="preserve">
          <source>The following options can be used to &lt;a href=&quot;footprint&quot;&gt;reduce the size of the compiled library&lt;/a&gt; by omitting unused features. This is probably only useful in embedded systems where space is especially tight, as even with all features included the SQLite library is relatively small. Don't forget to tell your compiler to optimize for binary size! (the -Os option if using GCC). Telling your compiler to optimize for size usually has a much larger impact on library footprint than employing any of these compile-time options. You should also verify that &lt;a href=&quot;#debugoptions&quot;&gt;debugging options&lt;/a&gt; are disabled.</source>
          <target state="translated">以下选项可用于通过省略未使用的功能来&lt;a href=&quot;footprint&quot;&gt;减小编译库的大小&lt;/a&gt;。这可能仅在空间特别狭窄的嵌入式系统中有用，因为即使包括了所有功能，SQLite库也相对较小。不要忘记告诉编译器针对二进制大小进行优化！（如果使用GCC，则为-Os选项）。与使用任何这些编译时选项相比，告诉编译器进行大小优化通常对库占用空间的影响要大得多。您还应该验证&lt;a href=&quot;#debugoptions&quot;&gt;调试选项&lt;/a&gt;是否已禁用。</target>
        </trans-unit>
        <trans-unit id="aa7c844b688230c89a2857560379c0f551e0b077" translate="yes" xml:space="preserve">
          <source>The following query computes an approximation of the Mandelbrot Set and outputs the result as ASCII-art:</source>
          <target state="translated">下面的查询计算了Mandelbrot Set的近似值,并将结果输出为ASCII-art。</target>
        </trans-unit>
        <trans-unit id="165c7c17f77322908874e60dfb0fb76218a06202" translate="yes" xml:space="preserve">
          <source>The following query parameters are recognized by SQLite as of &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;version 3.15.0&lt;/a&gt; (2016-10-14). New query parameters might be added in the future.</source>
          <target state="translated">SQLite从&lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;版本3.15.0&lt;/a&gt;（2016-10-14）起可以识别以下查询参数。将来可能会添加新的查询参数。</target>
        </trans-unit>
        <trans-unit id="482aaeeca1acb6ff828caa9e341d537cef50e256" translate="yes" xml:space="preserve">
          <source>The following query returns all integers between 1 and 1000000:</source>
          <target state="translated">下面的查询返回1到1000000之间的所有整数。</target>
        </trans-unit>
        <trans-unit id="df61dccd4718a46758145386ef91e3af7a125626" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 1 of the above procedure in more detail.</source>
          <target state="translated">以下要求更详细地描述了上述程序的步骤1。</target>
        </trans-unit>
        <trans-unit id="c7e0a9c1d2e39a35866f813a7b58e616f8a0dfa1" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 2 of the above procedure in more detail.</source>
          <target state="translated">以下要求更详细地描述了上述程序的第2步。</target>
        </trans-unit>
        <trans-unit id="ab60a1fc45053970e49cb2236072b7574ce682f2" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 3 of the above procedure in more detail.</source>
          <target state="translated">以下要求更详细地描述了上述程序的第3步。</target>
        </trans-unit>
        <trans-unit id="0f5ce0f453d6b71b276dab07b31a916fac2ad143" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 4 of the above procedure in more detail.</source>
          <target state="translated">以下要求更详细地描述了上述程序的步骤4。</target>
        </trans-unit>
        <trans-unit id="ff1604c4fd7473773943aa62c8883c18d8179ef1" translate="yes" xml:space="preserve">
          <source>The following requirements describe the steps enumerated above in more detail.</source>
          <target state="translated">以下要求更详细地描述了上述步骤。</target>
        </trans-unit>
        <trans-unit id="ca6589a3a75bae1a771049671e8297b9c43f424f" translate="yes" xml:space="preserve">
          <source>The following restrictions apply to DELETE statements that occur within the body of a &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement:</source>
          <target state="translated">以下限制适用于在&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;语句内出现的DELETE 语句：</target>
        </trans-unit>
        <trans-unit id="1404887613e3d3d478c15bfa20064138fe1f758d" translate="yes" xml:space="preserve">
          <source>The following routines are used to implement user-defined collating sequences:</source>
          <target state="translated">以下例程用于实现用户定义的整理序列。</target>
        </trans-unit>
        <trans-unit id="9d61d2cb84c2da7119bdaa99ad1c2d7a32c4afe9" translate="yes" xml:space="preserve">
          <source>The following rules and caveats apply to the values specified as part of each INSERT statement:</source>
          <target state="translated">以下规则和注意事项适用于作为每个INSERT语句的一部分而指定的值。</target>
        </trans-unit>
        <trans-unit id="a26a29856749163d9eb4f80a667633bb87f813e9" translate="yes" xml:space="preserve">
          <source>The following rules show how each of the locks is used.</source>
          <target state="translated">下面的规则说明了各锁的使用方法。</target>
        </trans-unit>
        <trans-unit id="737ea9fa3e70c97a0a7b4c9228ebcdc9127f52cb" translate="yes" xml:space="preserve">
          <source>The following scenario illustrates how an SQLITE_BUSY_SNAPSHOT error might arise:</source>
          <target state="translated">下面的场景说明了SQLITE_BUSY_SNAPSHOT错误如何产生。</target>
        </trans-unit>
        <trans-unit id="4840312a4c02316c9bb1b228254597da9db65628" translate="yes" xml:space="preserve">
          <source>The following script was used to gather information for the table above.</source>
          <target state="translated">以下脚本用于收集上表的信息。</target>
        </trans-unit>
        <trans-unit id="5f95a6062676138baa336da2cd5b1ec87382d19c" translate="yes" xml:space="preserve">
          <source>The following section describes the API offered to auxiliary function implementations in detail. Further examples may be found in the &quot;fts5_aux.c&quot; file of the source code.</source>
          <target state="translated">下面一节详细描述了提供给辅助函数实现的API。更多的例子可以在源代码的 &quot;fts5_aux.c &quot;文件中找到。</target>
        </trans-unit>
        <trans-unit id="c91d01efc0ba3649e7eacbf59f700342ec3a53a5" translate="yes" xml:space="preserve">
          <source>The following sections describe some low-level details of the R*Tree implementation, that might be useful for trouble-shooting or performance analysis.</source>
          <target state="translated">下面的章节描述了R*Tree实现的一些低级细节,这些细节可能对故障排除或性能分析有用。</target>
        </trans-unit>
        <trans-unit id="17e43452198f5289d975fb07abeb874782ed48a0" translate="yes" xml:space="preserve">
          <source>The following sections describe the supported parameters. Specifying an unrecognized parameter name is an error.</source>
          <target state="translated">下面的章节描述了支持的参数。指定一个未被识别的参数名称是一个错误。</target>
        </trans-unit>
        <trans-unit id="009cc36fd7239429da331a5197a208b717cdb22a" translate="yes" xml:space="preserve">
          <source>The following sections provide additional detail on the operation of the various functions that are part of the json1 extension.</source>
          <target state="translated">下面的章节提供了关于json1扩展中各种函数操作的额外细节。</target>
        </trans-unit>
        <trans-unit id="0b996a91eae66dcc3a2860511963eb7fa7efc7eb" translate="yes" xml:space="preserve">
          <source>The following syntax documentation topics are available:</source>
          <target state="translated">以下是语法文档主题。</target>
        </trans-unit>
        <trans-unit id="0e5fa08cf1724f31556de517effc85351bb377ec" translate="yes" xml:space="preserve">
          <source>The following table shows how many common datatype names from more traditional SQL implementations are converted into affinities by the five rules of the previous section. This table shows only a small subset of the datatype names that SQLite will accept. Note that numeric arguments in parentheses that following the type name (ex: &quot;VARCHAR(255)&quot;) are ignored by SQLite - SQLite does not impose any length restrictions (other than the large global &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; limit) on the length of strings, BLOBs or numeric values.</source>
          <target state="translated">下表显示了通过上一节的五个规则将更传统的SQL实现中的多少个通用数据类型名称转换为关联性。该表仅显示SQLite将接受的数据类型名称的一小部分。请注意，SQLite会忽略类型名称后面的括号中的数字参数（例如：&amp;ldquo; VARCHAR（255）&amp;rdquo;）-SQLite不会对字符串，BLOB或字符串的长度施加任何长度限制（大的全局&lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;限制除外）。数值。</target>
        </trans-unit>
        <trans-unit id="54c0ab33937bb3d0205754132a184edc97ac8f8b" translate="yes" xml:space="preserve">
          <source>The following table shows the meanings of the (non-hidden) columns of DBSTAT in both normal and aggregated mode:</source>
          <target state="translated">下表显示了DBSTAT的(非隐藏)列在正常和聚合模式下的含义。</target>
        </trans-unit>
        <trans-unit id="54feeefe0d9e52f7880c035de3af5b0398710d6a" translate="yes" xml:space="preserve">
          <source>The following table shows the results of the NULL handling experiments.</source>
          <target state="translated">下表是NULL处理实验的结果。</target>
        </trans-unit>
        <trans-unit id="12e0a00ef75b703780c84d1074e0287b2f403501" translate="yes" xml:space="preserve">
          <source>The following table summarizes the SQLite file format changes that have occurred since version 1.0.0:</source>
          <target state="translated">下表总结了自1.0.0版本以来发生的SQLite文件格式变化。</target>
        </trans-unit>
        <trans-unit id="ea82e2bbe8fed4a7a8a0361c062cdbf2a7cb2e1f" translate="yes" xml:space="preserve">
          <source>The following two objects and eight methods comprise the essential elements of the SQLite interface:</source>
          <target state="translated">以下两个对象和八个方法构成了SQLite接口的基本元素。</target>
        </trans-unit>
        <trans-unit id="1b3057a8ce2692f0addf4973e487586ba5e334ab" translate="yes" xml:space="preserve">
          <source>The foregoing is all one really needs to know in order to use SQLite effectively. All the rest is optimization and detail.</source>
          <target state="translated">以上就是一个人真正需要知道的所有内容,以便有效地使用SQLite。剩下的都是优化和细节。</target>
        </trans-unit>
        <trans-unit id="75a22928178fbb3c0cbb048a8ad2cc0d5b3170b7" translate="yes" xml:space="preserve">
          <source>The foregoing text describes low-level aspects of the SQLite file format. The b-tree mechanism provides a powerful and efficient means of accessing a large data set. This section will describe how the low-level b-tree layer is used to implement higher-level SQL capabilities.</source>
          <target state="translated">前文介绍了SQLite文件格式的低级方面。b-tree机制提供了一种强大而高效的访问大型数据集的方法。本节将描述如何使用低级的b-tree层来实现更高级别的SQL功能。</target>
        </trans-unit>
        <trans-unit id="12199f4a726aab3fb6304db80ece6cf69a955319" translate="yes" xml:space="preserve">
          <source>The foreign key constraint is satisfied if for each row in the child table either one or more of the child key columns are NULL, or there exists a row in the parent table for which each parent key column contains a value equal to the value in its associated child key column.</source>
          <target state="translated">如果对于子表中的每条记录,有一个或多个子键列是NULL,或者在父表中存在一条记录,其中每个父键列包含的值等于其相关联的子键列中的值,则满足外键约束。</target>
        </trans-unit>
        <trans-unit id="7eb5b173b9130668a2a0b17e4f207640eaa017f0" translate="yes" xml:space="preserve">
          <source>The foreign key constraints created as part of tables</source>
          <target state="translated">作为表的一部分创建的外键约束</target>
        </trans-unit>
        <trans-unit id="add6cc21a0d1ec9f3c982acde6cc5dc3f05465f0" translate="yes" xml:space="preserve">
          <source>The foreign_key_check pragma checks the database, or the table called &quot;</source>
          <target state="translated">foreign_key_check pragma检查数据库,或者说检查名为&quot;&quot;的表。</target>
        </trans-unit>
        <trans-unit id="9efc16f15cca4547a2a6b1e6f0aea092764cfc35" translate="yes" xml:space="preserve">
          <source>The formalized assumptions in this section refer to</source>
          <target state="translated">本节的形式化假设是指</target>
        </trans-unit>
        <trans-unit id="fe9496c466bbe179ee18ac47ed69a346233c9cbd" translate="yes" xml:space="preserve">
          <source>The format for sqlite_stat2 is recorded here for legacy reference. Recent versions of SQLite no longer support sqlite_stat2 and the sqlite_stat2 table, if is exists, is simply ignored.</source>
          <target state="translated">这里记录了sqlite_stat2的格式,供旧版本参考。最新版本的SQLite不再支持sqlite_stat2,如果sqlite_stat2表存在,则直接忽略。</target>
        </trans-unit>
        <trans-unit id="d2a469c667d3464f2b4b57e3f59fb88c3da53ff2" translate="yes" xml:space="preserve">
          <source>The format of a cell depends on which kind of b-tree page the cell appears on. The following table shows the elements of a cell, in order of appearance, for the various b-tree page types.</source>
          <target state="translated">单元格的格式取决于单元格出现在哪种类型的b-tree页面上。下表显示了单元格的元素,按出现的顺序排列,适用于各种b-tree页面类型。</target>
        </trans-unit>
        <trans-unit id="8f6ebed1965bbd7f7af8c4c0949451b7c054d06f" translate="yes" xml:space="preserve">
          <source>The format of the arguments to the module is very general. Each module-argument may contain keywords, string literals, identifiers, numbers, and punctuation. Each module-argument is passed as written (as text) into the &lt;a href=&quot;vtab#xcreate&quot;&gt;constructor method&lt;/a&gt; of the virtual table implementation when the virtual table is created and that constructor is responsible for parsing and interpreting the arguments. The argument syntax is sufficiently general that a virtual table implementation can, if it wants to, interpret its arguments as &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definitions&lt;/a&gt; in an ordinary &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. The implementation could also impose some other interpretation on the arguments.</source>
          <target state="translated">模块参数的格式非常通用。每个模块参数可以包含关键字，字符串文字，标识符，数字和标点符号。创建虚拟表时，每个模块参数都以书面形式（作为文本）传递到虚拟表实现的&lt;a href=&quot;vtab#xcreate&quot;&gt;构造函数方法&lt;/a&gt;中，并且该构造函数负责解析和解释参数。参数语法足够通用，因此虚拟表实现可以在普通&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句中将其参数解释为&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;列定义&lt;/a&gt;。该实现还可以对参数进行其他解释。</target>
        </trans-unit>
        <trans-unit id="ce6813c51545b0e36cbda5b5ae9abe31c78f2212" translate="yes" xml:space="preserve">
          <source>The format of the main database file is as described in the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; document. The &lt;a href=&quot;fileformat2#vnums&quot;&gt;file format version numbers&lt;/a&gt; at offsets 18 and 19 into the main database must both be 2 to indicate that the database is in WAL mode. The main database may have an arbitrary name allowed by the underlying filesystem. No special file suffixes are required, though &quot;.db&quot;, &quot;.sqlite&quot;, and &quot;.sqlite3&quot; seem to be popular choices.</source>
          <target state="translated">主数据库文件的格式如&lt;a href=&quot;fileformat2&quot;&gt;文件格式&lt;/a&gt;文档中所述。主数据库中偏移量18和19 的&lt;a href=&quot;fileformat2#vnums&quot;&gt;文件格式版本号&lt;/a&gt;都必须均为2，以指示数据库处于WAL模式。主数据库可以具有基础文件系统允许的任意名称。尽管&amp;ldquo; .db&amp;rdquo;，&amp;ldquo;。sqlite&amp;rdquo;和&amp;ldquo; .sqlite3&amp;rdquo;似乎是流行的选择，但不需要特殊的文件后缀。</target>
        </trans-unit>
        <trans-unit id="c748249cfa33fdfdfb8560eb0a7a2d06c6a7130e" translate="yes" xml:space="preserve">
          <source>The format string for printf() is a template for the generated string. Substitutions are made whenever a &quot;%&quot; character appears in the format string. The &quot;%&quot; is followed by one or more additional characters that describe the substitution. Each substitution has the following format:</source>
          <target state="translated">printf()的格式字符串是生成字符串的模板。每当格式字符串中出现&quot;%&quot;字符时,就会进行替换。%&quot;后面是一个或多个描述替换的附加字符。每个替换的格式如下。</target>
        </trans-unit>
        <trans-unit id="e5481902d614e43b8906fc140d4dc2a9c7914623" translate="yes" xml:space="preserve">
          <source>The format used by SQLite database files has been completely revised. The old version 2.1 format and the new 3.0 format are incompatible with one another. Version 2.8 of SQLite will not read a version 3.0 database files and version 3.0 of SQLite will not read a version 2.8 database file.</source>
          <target state="translated">SQLite数据库文件所使用的格式已经被彻底修改。旧的2.1版格式和新的3.0版格式是不兼容的,2.8版的SQLite不能读取3.0版的数据库文件,3.0版的SQLite不能读取2.8版的数据库文件。2.8版本的SQLite无法读取3.0版本的数据库文件,3.0版本的SQLite无法读取2.8版本的数据库文件。</target>
        </trans-unit>
        <trans-unit id="a376c207dbbf638ec2db0cb626e4c46931a236b1" translate="yes" xml:space="preserve">
          <source>The fossil delta format may only be used to update BLOB values. Instead of storing the new BLOB within the data_% table, the fossil delta is stored instead. And instead of specifying an 'x' as part of the rbu_control string for the column to be updated, an 'f' character is stored. When processing an 'f' update, RBU loads the original BLOB data from disk, applies the fossil delta to it and stores the results back into the database file. The RBU databases generated by &lt;a href=&quot;rbu#sqldiff&quot;&gt;sqldiff --rbu&lt;/a&gt; make use of fossil deltas wherever doing so would save space in the RBU database.</source>
          <target state="translated">化石增量格式只能用于更新BLOB值。代替存储新的BLOB在data_％表中，而是存储化石增量。并且，不是在要更新的列的rbu_control字符串的一部分中指定&amp;ldquo; x&amp;rdquo;，而是存储了&amp;ldquo; f&amp;rdquo;字符。在处理&amp;ldquo; f&amp;rdquo;更新时，RBU从磁盘加载原始BLOB数据，对其应用化石增量并将结果存储回数据库文件中。&lt;a href=&quot;rbu#sqldiff&quot;&gt;sqldiff --rbu&lt;/a&gt;生成的RBU数据库在任何地方都可以利用化石三角洲，从而节省RBU数据库中的空间。</target>
        </trans-unit>
        <trans-unit id="23a39933682f9054d9fbfd81554ffb9e23300f95" translate="yes" xml:space="preserve">
          <source>The founder of SQLite and all current developers have pledged to follow spirit of The Rule to the best of their ability. They view The Rule as their promise to all SQLite users of how the developers are expected to behave in community. This is a one-way promise, or covenant. In other words, the developers are saying: &quot;We will treat you this way regardless of how you treat us.&quot;</source>
          <target state="translated">SQLite的创始人和所有当前的开发者都承诺将尽其所能地遵循The Rule的精神。他们认为The Rule是他们对所有SQLite用户的承诺,即开发者在社区中应该如何行事。这是一个单向的承诺,或者说是契约。换句话说,开发者们在说 &quot;无论你如何对待我们,我们都会这样对待你。&quot;</target>
        </trans-unit>
        <trans-unit id="5e2d48a3048a9448f3349d8ade2ca9593428346e" translate="yes" xml:space="preserve">
          <source>The founder of SQLite and all current developers have pledged to follow the spirit of The Rule to the best of their ability. They view The Rule as their promise to all SQLite users of how the developers are expected to behave. This is a one-way promise, or covenant. In other words, the developers are saying: &quot;We will treat you this way regardless of how you treat us.&quot;</source>
          <target state="translated">SQLite的创始人和所有当前的开发人员都承诺将尽其所能地遵循The Rule的精神。他们将The Rule视为他们对所有SQLite用户的承诺,即开发者应该如何行事。这是一个单向的承诺,或者说是契约。换句话说,开发人员在说 &quot;无论你如何对待我们,我们都会这样对待你。&quot;</target>
        </trans-unit>
        <trans-unit id="fac57078ba906f356fde5d5be039fc86e66f550e" translate="yes" xml:space="preserve">
          <source>The founder of SQLite, and all of the current developers at the time when this document was composed, have pledged to govern their interactions with each other, with their clients, and with the larger SQLite user community in accordance with the &quot;instruments of good works&quot; from chapter 4 of &lt;a href=&quot;https://en.wikipedia.org/wiki/Rule_of_Saint_Benedict&quot;&gt;The Rule of St. Benedict&lt;/a&gt; (hereafter: &quot;The Rule&quot;). This code of ethics has proven its mettle in thousands of diverse communities for over 1,500 years, and has served as a baseline for many civil law codes since the time of Charlemagne.</source>
          <target state="translated">SQLite的创始人以及撰写本文档时的所有当前开发人员已保证按照&amp;ldquo;好的工具&amp;rdquo;来管理彼此之间，与他们的客户以及与更大的SQLite用户社区之间的交互。 &amp;rdquo;摘自&lt;a href=&quot;https://en.wikipedia.org/wiki/Rule_of_Saint_Benedict&quot;&gt;《圣本尼迪克特规则&lt;/a&gt;》第4章（以下简称&amp;ldquo;规则&amp;rdquo;）。超过1500年以来，该道德准则已在数千个不同社区中证明了自己的才能，并且自查理曼大帝时代以来便已成为许多民法准则的基准。</target>
        </trans-unit>
        <trans-unit id="555d8586503882b041c2a8a309c2f9e999580160" translate="yes" xml:space="preserve">
          <source>The four utility functions</source>
          <target state="translated">四个效用函数</target>
        </trans-unit>
        <trans-unit id="6cfb5a37e3c4d212e2442aae712218c04b105dd5" translate="yes" xml:space="preserve">
          <source>The four-byte page number at offset 8 is the right-most pointer. This value appears in the header of interior b-tree pages only and is omitted from all other pages.</source>
          <target state="translated">偏移量8的4字节页码是最右边的指针。这个值只出现在内部b-tree页的页眉中,所有其他页面都被省略。</target>
        </trans-unit>
        <trans-unit id="76f618a5029c6002ebdae975ee6043d888618d19" translate="yes" xml:space="preserve">
          <source>The fourth argument (xFilter) passed to these functions is the &quot;filter callback&quot;. If it is not NULL, then for each table affected by at least one change in the changeset, the filter callback is invoked with the table name as the second argument, and a copy of the context pointer passed as the sixth argument as the first. If the &quot;filter callback&quot; returns zero, then no attempt is made to apply any changes to the table. Otherwise, if the return value is non-zero or the xFilter argument to is NULL, all changes related to the table are attempted.</source>
          <target state="translated">传递给这些函数的第四个参数(xFilter)是 &quot;过滤器回调&quot;。如果它不是NULL,那么对于每个受变化集中至少一个变化影响的表,过滤器回调将被调用,表名作为第二个参数,第六个参数传递的上下文指针的副本作为第一个参数。如果 &quot;过滤器回调 &quot;返回值为0,则不尝试对表应用任何更改。否则,如果返回值为非零或者xFilter参数为NULL,则会尝试对表进行所有相关的更改。</target>
        </trans-unit>
        <trans-unit id="999f04c49ef94f8766fa9cb6bb9bbba18afe2ece" translate="yes" xml:space="preserve">
          <source>The fourth argument, pArg, is an application data pointer that is passed through as the first argument to the collating function callback.</source>
          <target state="translated">第四个参数pArg是一个应用数据指针,作为整理函数回调的第一个参数通过。</target>
        </trans-unit>
        <trans-unit id="c6b1934196a189db01281779b0c51a4b66faf522" translate="yes" xml:space="preserve">
          <source>The fourth column is the maximum value of any rowid in the table.</source>
          <target state="translated">第四列是表中任何rowid的最大值。</target>
        </trans-unit>
        <trans-unit id="69cc3b7ae5b0c474135cb2e440fa03951919eaf0" translate="yes" xml:space="preserve">
          <source>The fourth parameter may also optionally include the &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag, which if present prevents the function from being invoked from within VIEWs or TRIGGERs. For security reasons, the &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag is recommended for any application-defined SQL function that has side-effects.</source>
          <target state="translated">第四个参数还可以选择包含&lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;标志，如果存在该标志，则防止从VIEW或TRIGGER内部调用该函数。出于安全原因，建议将&lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;标志用于任何有副作用的应用程序定义的SQL函数。</target>
        </trans-unit>
        <trans-unit id="c1fbaaa3083276ec5194db2d1a793d5691751026" translate="yes" xml:space="preserve">
          <source>The fourth parameter may also optionally include the &lt;a href=&quot;#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag, which if present prevents the function from being invoked from within VIEWs, TRIGGERs, CHECK constraints, generated column expressions, index expressions, or the WHERE clause of partial indexes.</source>
          <target state="translated">第四个参数还可以选择包含&lt;a href=&quot;#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;标志，如果存在该标志，则阻止从VIEW，TRIGGER，CHECK约束，生成的列表达式，索引表达式或部分索引的WHERE子句中调用该函数。</target>
        </trans-unit>
        <trans-unit id="f52c4099bf56a2a098b10ec045515f7e30e89130" translate="yes" xml:space="preserve">
          <source>The fourth parameter may also optionally include the &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag, which if present prevents the function from being invoked from within VIEWs or TRIGGERs. For security reasons, the &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag is recommended for any application-defined SQL function that has side-effects.</source>
          <target state="translated">第四个参数还可以选择包含&lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;标志，如果存在该标志，则防止从VIEW或TRIGGER内部调用该函数。出于安全原因，建议将&lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;标志用于任何有副作用的应用程序定义的SQL函数。</target>
        </trans-unit>
        <trans-unit id="67ad2195f1817b78a8b4837501855037b255117b" translate="yes" xml:space="preserve">
          <source>The fourth parameter may also optionally include the &lt;a href=&quot;c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag, which if present prevents the function from being invoked from within VIEWs, TRIGGERs, CHECK constraints, generated column expressions, index expressions, or the WHERE clause of partial indexes.</source>
          <target state="translated">第四个参数还可以选择包含&lt;a href=&quot;c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;标志，如果存在该标志，则阻止从VIEW，TRIGGER，CHECK约束，生成的列表达式，索引表达式或部分索引的WHERE子句中调用该函数。</target>
        </trans-unit>
        <trans-unit id="649add83c8043b4bf2ea6e4b6cf49a7fdf941dff" translate="yes" xml:space="preserve">
          <source>The fourth parameter may optionally be ORed with &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; to signal that the function will always return the same result given the same inputs within a single SQL statement. Most SQL functions are deterministic. The built-in &lt;a href=&quot;lang_corefunc#random&quot;&gt;random()&lt;/a&gt; SQL function is an example of a function that is not deterministic. The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is recommended where possible.</source>
          <target state="translated">可以选择将第四个参数与&lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;进行&amp;ldquo;或&amp;rdquo;运算，以表明在给定单个SQL语句中相同的输入的情况下，该函数将始终返回相同的结果。大多数SQL函数都是确定性的。内置的&lt;a href=&quot;lang_corefunc#random&quot;&gt;random（）&lt;/a&gt; SQL函数是不确定性函数的一个示例。 SQLite查询计划程序能够对确定性函数执行其他优化，因此建议尽可能使用&lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;标志。</target>
        </trans-unit>
        <trans-unit id="6481c8ccbbe2254925779028e6672b2de9b23312" translate="yes" xml:space="preserve">
          <source>The fourth parameter may optionally be ORed with &lt;a href=&quot;#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; to signal that the function will always return the same result given the same inputs within a single SQL statement. Most SQL functions are deterministic. The built-in &lt;a href=&quot;lang_corefunc#random&quot;&gt;random()&lt;/a&gt; SQL function is an example of a function that is not deterministic. The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the &lt;a href=&quot;#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is recommended where possible.</source>
          <target state="translated">可以选择将第四个参数与&lt;a href=&quot;#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;进行&amp;ldquo;或&amp;rdquo;运算，以表明在给定单个SQL语句中相同的输入的情况下，该函数将始终返回相同的结果。大多数SQL函数都是确定性的。内置的&lt;a href=&quot;lang_corefunc#random&quot;&gt;random（）&lt;/a&gt; SQL函数是不确定性函数的一个示例。SQLite查询计划程序能够对确定性函数执行其他优化，因此建议尽可能使用&lt;a href=&quot;#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;标志。</target>
        </trans-unit>
        <trans-unit id="658cc43bdf2652e8cf4b2cffdcf6459b264f185d" translate="yes" xml:space="preserve">
          <source>The fourth parameter may optionally be ORed with &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; to signal that the function will always return the same result given the same inputs within a single SQL statement. Most SQL functions are deterministic. The built-in &lt;a href=&quot;../lang_corefunc#random&quot;&gt;random()&lt;/a&gt; SQL function is an example of a function that is not deterministic. The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is recommended where possible.</source>
          <target state="translated">可以选择将第四个参数与&lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;进行&amp;ldquo;或&amp;rdquo;运算，以表明在给定单个SQL语句中相同的输入的情况下，该函数将始终返回相同的结果。大多数SQL函数都是确定性的。内置的&lt;a href=&quot;../lang_corefunc#random&quot;&gt;random（）&lt;/a&gt; SQL函数是不确定性函数的一个示例。 SQLite查询计划程序能够对确定性函数执行其他优化，因此建议尽可能使用&lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;标志。</target>
        </trans-unit>
        <trans-unit id="7980c4f3a8ec7ae6d00b95c7cb68067b43db4da9" translate="yes" xml:space="preserve">
          <source>The fourth parameter may optionally be ORed with &lt;a href=&quot;c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; to signal that the function will always return the same result given the same inputs within a single SQL statement. Most SQL functions are deterministic. The built-in &lt;a href=&quot;../lang_corefunc#random&quot;&gt;random()&lt;/a&gt; SQL function is an example of a function that is not deterministic. The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the &lt;a href=&quot;c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is recommended where possible.</source>
          <target state="translated">可以选择将第四个参数与&lt;a href=&quot;c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;进行&amp;ldquo;或&amp;rdquo;运算，以表明在给定单个SQL语句中相同的输入的情况下，该函数将始终返回相同的结果。大多数SQL函数都是确定性的。内置的&lt;a href=&quot;../lang_corefunc#random&quot;&gt;random（）&lt;/a&gt; SQL函数是不确定性函数的一个示例。SQLite查询计划程序能够对确定性函数执行其他优化，因此建议尽可能使用&lt;a href=&quot;c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;标志。</target>
        </trans-unit>
        <trans-unit id="feefd1b9ff1b8c4a1a74b3c8f0c879ca3de261f9" translate="yes" xml:space="preserve">
          <source>The fourth parameter to sqlite3_open_v2() is the name of the &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object that defines the operating system interface that the new database connection should use. If the fourth parameter is a NULL pointer then the default &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is used.</source>
          <target state="translated">sqlite3_open_v2（）的第四个参数是&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的名称，该对象定义新数据库连接应使用的操作系统接口。如果第四个参数是NULL指针，则使用默认的&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="b7bbbda582299a1f3186b36dde756d304b0fa7e6" translate="yes" xml:space="preserve">
          <source>The fourth parameter to sqlite3_open_v2() is the name of the &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object that defines the operating system interface that the new database connection should use. If the fourth parameter is a NULL pointer then the default &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is used.</source>
          <target state="translated">sqlite3_open_v2（）的第四个参数是&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象的名称，该对象定义新数据库连接应使用的操作系统接口。如果第四个参数是NULL指针，则使用默认的&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="d063d165e08786a1b7ee913cfa396d1655f4a730" translate="yes" xml:space="preserve">
          <source>The fourth parameter, eTextRep, specifies what &lt;a href=&quot;#SQLITE_ANY&quot;&gt;text encoding&lt;/a&gt; this SQL function prefers for its parameters. The application should set this parameter to &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; if the function implementation invokes &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16le()&lt;/a&gt; on an input, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; if the implementation invokes &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16be()&lt;/a&gt; on an input, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; if &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; is used, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt; otherwise. The same SQL function may be registered multiple times using different preferred text encodings, with different implementations for each encoding. When multiple implementations of the same function are available, SQLite will pick the one that involves the least amount of data conversion.</source>
          <target state="translated">第四个参数eTextRep指定此SQL函数首选使用哪种&lt;a href=&quot;#SQLITE_ANY&quot;&gt;文本编码&lt;/a&gt;。该应用程序应此参数设置为&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;如果函数实现调用&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16le（）&lt;/a&gt;的输入，或&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;如果实现调用&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16be（）&lt;/a&gt;的输入，或&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;如果&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16（）&lt;/a&gt;被使用，或&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;除此以外。相同的SQL函数可以使用不同的首选文本编码多次注册，每种编码具有不同的实现方式。当同一功能的多个实现可用时，SQLite将选择涉及最少数据转换量的实现。</target>
        </trans-unit>
        <trans-unit id="57c66b621bee32c598b5cb9d09e4c1e1ae3f09dc" translate="yes" xml:space="preserve">
          <source>The fourth parameter, eTextRep, specifies what &lt;a href=&quot;c_any&quot;&gt;text encoding&lt;/a&gt; this SQL function prefers for its parameters. The application should set this parameter to &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; if the function implementation invokes &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16le()&lt;/a&gt; on an input, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; if the implementation invokes &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16be()&lt;/a&gt; on an input, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; if &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; is used, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt; otherwise. The same SQL function may be registered multiple times using different preferred text encodings, with different implementations for each encoding. When multiple implementations of the same function are available, SQLite will pick the one that involves the least amount of data conversion.</source>
          <target state="translated">第四个参数eTextRep指定此SQL函数首选使用哪种&lt;a href=&quot;c_any&quot;&gt;文本编码&lt;/a&gt;。该应用程序应此参数设置为&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;如果函数实现调用&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16le（）&lt;/a&gt;的输入，或&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;如果实现调用&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16be（）&lt;/a&gt;的输入，或&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;如果&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16（）&lt;/a&gt;被使用，或&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;除此以外。相同的SQL函数可以使用不同的首选文本编码多次注册，每种编码具有不同的实现方式。当同一功能的多个实现可用时，SQLite将选择涉及最少数据转换量的实现。</target>
        </trans-unit>
        <trans-unit id="cdeeaf74a0034cfafd692646911468eeef688545" translate="yes" xml:space="preserve">
          <source>The fragment is optional. If present, it is ignored.</source>
          <target state="translated">该片段是可选的。如果存在,则会被忽略。</target>
        </trans-unit>
        <trans-unit id="36f14f55d888327ce43d396d69903a3ff7fd8e07" translate="yes" xml:space="preserve">
          <source>The frame boundary is the first row in the &lt;a href=&quot;windowfunctions#ptxn&quot;&gt;partition&lt;/a&gt;.</source>
          <target state="translated">框架边界是&lt;a href=&quot;windowfunctions#ptxn&quot;&gt;分区中&lt;/a&gt;的第一行。</target>
        </trans-unit>
        <trans-unit id="3a03f5ecd3e39afb46315f6d23c888ecf09dac7b" translate="yes" xml:space="preserve">
          <source>The frame boundary is the last row in the &lt;a href=&quot;windowfunctions#ptxn&quot;&gt;partition&lt;/a&gt;.</source>
          <target state="translated">框架边界是&lt;a href=&quot;windowfunctions#ptxn&quot;&gt;分区中&lt;/a&gt;的最后一行。</target>
        </trans-unit>
        <trans-unit id="d8ad39ba6054748efcf881cf5f3cfd24dafacebd" translate="yes" xml:space="preserve">
          <source>The frame-spec determines which output rows are read by an aggregate window function. The frame-spec consists of four parts:</source>
          <target state="translated">Frame-spec决定了集合窗口函数读取哪些输出行。框架规格由四个部分组成:</target>
        </trans-unit>
        <trans-unit id="8eb0b0542bfd6ed405e2b53c332150eda864217a" translate="yes" xml:space="preserve">
          <source>The freelist is organized as a linked list of freelist trunk pages with each trunk page containing page numbers for zero or more freelist leaf pages.</source>
          <target state="translated">自由列表的组织形式是自由列表主干页的链接列表,每个主干页包含零或多个自由列表叶页的页码。</target>
        </trans-unit>
        <trans-unit id="4faa37aa2595b1d3bc75280cd8996cd072597ac3" translate="yes" xml:space="preserve">
          <source>The fts3tokenize virtual table can be used on any tokenizer, regardless of whether or not there exists an FTS3 or FTS4 table that actually uses that tokenizer.</source>
          <target state="translated">fts3tokenize 虚拟表可以在任何标记器上使用,无论是否存在实际使用该标记器的 FTS3 或 FTS4 表。</target>
        </trans-unit>
        <trans-unit id="346445abda1b7582bb76e9ab2cc48bb753bf4d95" translate="yes" xml:space="preserve">
          <source>The fts5 unicode61 tokenizer is byte-for-byte compatible with the fts3/4 unicode61 tokenizer.</source>
          <target state="translated">fts5 unicode61 tokenizer与fts3/4 unicode61 tokenizer字节对字节兼容。</target>
        </trans-unit>
        <trans-unit id="78675caf2de7d160a88a0d764272d7a44454db10" translate="yes" xml:space="preserve">
          <source>The fts5_api structure is defined as follows. It exposes three methods, one each for registering new auxiliary functions and tokenizers, and one for retrieving existing tokenizer. The latter is intended to facilitate the implementation of &quot;tokenizer wrappers&quot; similar to the built-in porter tokenizer.</source>
          <target state="translated">fts5_api 结构定义如下。它公开了三个方法,一个用于注册新的辅助函数和令牌器,另一个用于检索现有的令牌器。后者的目的是为了方便实现类似于内置的 porter tokenizer 的 &quot;tokenizer 包装器&quot;。</target>
        </trans-unit>
        <trans-unit id="162ffee085d8569c08bb1ab9fff2a388996d64c4" translate="yes" xml:space="preserve">
          <source>The fts5_api structure methods are described individually in the following sections.</source>
          <target state="translated">fts5_api结构方法将在下面的章节中单独描述。</target>
        </trans-unit>
        <trans-unit id="10c372ee6826e322ad4396357787688e82cce472" translate="yes" xml:space="preserve">
          <source>The fts5vocab virtual table module allows users to extract information from an FTS5 full-text index directly. The fts5vocab module is a part of FTS5 - it is available whenever FTS5 is.</source>
          <target state="translated">fts5vocab虚拟表模块允许用户直接从FTS5全文索引中提取信息。fts5vocab模块是FTS5的一部分--只要FTS5在,它就可以使用。</target>
        </trans-unit>
        <trans-unit id="7f3f12f1d0cab297fd4ff2f20d0ccb7ef0778aa5" translate="yes" xml:space="preserve">
          <source>The full pathname of the database file is now remembered even if a relative path is passed into sqlite_open(). This allows the library to continue operating correctly after a chdir().</source>
          <target state="translated">即使将相对路径传递给 sqlite_open(),数据库文件的完整路径名也会被记住。这允许库在chdir()之后继续正确运行。</target>
        </trans-unit>
        <trans-unit id="3b9a46ef2b67e207b1134faeedabd205f3bd8481" translate="yes" xml:space="preserve">
          <source>The full syntax for specifying foreign key constraints is available as part of the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; documentation. Replacing the phrase above with any of the following creates an immediate foreign key constraint.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;文档的一部分提供了用于指定外键约束的完整语法。用以下任何一项替换上面的短语会创建立即外键约束。</target>
        </trans-unit>
        <trans-unit id="976d387f058fd1530001e6bc24b270372cb7f6ff" translate="yes" xml:space="preserve">
          <source>The full-text index maintained by FTS5 is stored as a series of fixed-size blobs in a database table. It is not strictly necessary for all blobs that make up a full-text index to be the same size. The pgsz option determines the size of all blobs created by subsequent index writers. The default value is 1000.</source>
          <target state="translated">FTS5维护的全文索引以一系列固定大小的blobs的形式存储在数据库表中。严格来说,组成全文索引的所有 blobs 的大小并不需要相同。pgsz 选项决定了后续索引写入者创建的所有 blobs 的大小。默认值是1000。</target>
        </trans-unit>
        <trans-unit id="7d7917f6db9701130aeed21c2478cad3cdfc0903" translate="yes" xml:space="preserve">
          <source>The function name is specified in UTF-8. A separate sqlite3_create_function16() API works the same as sqlite_create_function() except that the function name is specified in UTF-16 host byte order.</source>
          <target state="translated">函数名用UTF-8指定。一个单独的sqlite3_create_function16()API的工作原理与sqlite_create_function()相同,只是函数名是以UTF-16主机字节顺序指定的。</target>
        </trans-unit>
        <trans-unit id="026205ed147556f48d88752d5a21eccbd2a64b48" translate="yes" xml:space="preserve">
          <source>The function pointer returned by this routine must be valid for the lifetime of the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object given in the first parameter.</source>
          <target state="translated">此例程返回的函数指针必须在第一个参数中给出的&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;对象的生存期内有效。</target>
        </trans-unit>
        <trans-unit id="d5578e17f6c531f672841ef155dfdacbfa341e5d" translate="yes" xml:space="preserve">
          <source>The function presented in the previous example copies the entire source database in one call to &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt;. This requires holding a read-lock on the source database file for the duration of the operation, preventing any other database user from writing to the database. It also holds the mutex associated with database pInMemory throughout the copy, preventing any other thread from using it. The C function in this section, designed to be called by a background thread or process for creating a backup of an online database, avoids these problems using the following approach:</source>
          <target state="translated">上一个示例中提供的函数通过一次调用将整个源数据库复制到&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（）&lt;/a&gt;。这要求在操作期间在源数据库文件上保持读取锁定，以防止任何其他数据库用户写入数据库。它还在整个副本中保留与数据库pInMemory相关联的互斥锁，从而防止任何其他线程使用它。本节中的C函数旨在由后台线程或用于创建在线数据库备份的进程调用，它使用以下方法避免了这些问题：</target>
        </trans-unit>
        <trans-unit id="0137a1cc90b7f7f164b60d3e6a0abb13294403cf" translate="yes" xml:space="preserve">
          <source>The functionality provided by the fts4aux module is now provided by &lt;a href=&quot;fts5#the_fts5vocab_virtual_table_module&quot;&gt;fts5vocab&lt;/a&gt;. The schema of these two tables is slightly different.</source>
          <target state="translated">fts5vocab现在提供了fts4aux模块提供的&lt;a href=&quot;fts5#the_fts5vocab_virtual_table_module&quot;&gt;功能&lt;/a&gt;。这两个表的架构略有不同。</target>
        </trans-unit>
        <trans-unit id="82f4a608941f31ed6516bc837d2ee3e175fc4792" translate="yes" xml:space="preserve">
          <source>The functionality required of each of the above functions is described in comments in sqlite3async.c.</source>
          <target state="translated">以上每个函数所需的功能在sqlite3async.c的注释中都有描述。</target>
        </trans-unit>
        <trans-unit id="a3e3ee73e4504a9b18df3710202691563a7ae8e5" translate="yes" xml:space="preserve">
          <source>The general purpose memory allocator is the most difficult memory pool to manage because it supports allocations of varying sizes. Since &lt;b&gt;n&lt;/b&gt; is a multiplier on &lt;b&gt;M&lt;/b&gt; we want to keep &lt;b&gt;n&lt;/b&gt; as small as possible. This argues for keeping the minimum allocation size for &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; as large as possible. In most applications, the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; is able to handle small allocations. So it is reasonable to set the minimum allocation size for &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; to 2, 4 or even 8 times the maximum size of a lookaside allocation. A minimum allocation size of 512 is a reasonable setting.</source>
          <target state="translated">通用内存分配器是最难管理的内存池，因为它支持大小不同的分配。由于&lt;b&gt;n&lt;/b&gt;是&lt;b&gt;M&lt;/b&gt;的乘数，因此我们要使&lt;b&gt;n&lt;/b&gt;尽可能小。这&lt;a href=&quot;malloc#memsys5&quot;&gt;表明应将memsys5&lt;/a&gt;的最小分配大小保持尽可能大。在大多数应用程序中，&lt;a href=&quot;malloc#lookaside&quot;&gt;后备内存分配器&lt;/a&gt;能够处理少量分配。因此，将&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;的最小分配大小设置为后备分配最大大小的2倍，4倍甚至8倍是合理的。最小分配大小为512是合理的设置。</target>
        </trans-unit>
        <trans-unit id="30bdbd95e17bffd329d217ead465e3fe28cd023c" translate="yes" xml:space="preserve">
          <source>The general rule is that indexes are only useful if there are WHERE-clause constraints on the left-most columns of the index. However, in some cases, SQLite is able to use an index even if the first few columns of the index are omitted from the WHERE clause but later columns are included.</source>
          <target state="translated">一般的规则是,只有在索引的最左边的列上有WHERE子句约束时,索引才有用。然而,在某些情况下,即使在WHERE子句中省略了索引的前几列,但包含了后面的列,SQLite也能够使用索引。</target>
        </trans-unit>
        <trans-unit id="084577b6dd782fa1eb4651ff451c238f84ef2391" translate="yes" xml:space="preserve">
          <source>The general-purpose memory allocator (&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;).</source>
          <target state="translated">通用内存分配器（&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="21a012c95267cb8d2b8d45dbbd928793f6616b70" translate="yes" xml:space="preserve">
          <source>The generate_series Table-Valued Function</source>
          <target state="translated">generate_series 表值函数</target>
        </trans-unit>
        <trans-unit id="476dfd7c8482f7d1208e7bd9537292c089264e39" translate="yes" xml:space="preserve">
          <source>The generate_series table can be simulated using a &lt;a href=&quot;lang_with#recursivecte&quot;&gt;recursive common table expression&lt;/a&gt;. If the three parameters are $start, $end, and $step, then the equivalent common table expression is:</source>
          <target state="translated">可以使用&lt;a href=&quot;lang_with#recursivecte&quot;&gt;递归公用表表达式&lt;/a&gt;来模拟generate_series表。如果三个参数分别是$ start，$ end和$ step，则等效的公用表表达式为：</target>
        </trans-unit>
        <trans-unit id="4e3c394ee97ca6ac89b21ae3983e2fd5668b4aa8" translate="yes" xml:space="preserve">
          <source>The generate_series(START,END,STEP) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; included in the SQLite source tree, and compiled into the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;. The generate_series() table has a single result column named &quot;value&quot; holding integer values and a number of rows determined by the parameters START, END, and STEP. The first row of the table has a value of START. Subsequent rows increase by STEP up to END.</source>
          <target state="translated">generate_series（START，END，STEP）&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;是SQLite源树中包含的&lt;a href=&quot;loadext&quot;&gt;可加载扩展&lt;/a&gt;，并已编译到&lt;a href=&quot;cli&quot;&gt;命令行shell中&lt;/a&gt;。generate_series（）表具有一个名为&amp;ldquo; value&amp;rdquo;的单个结果列，其中包含整数值，并且包含由参数START，END和STEP确定的行数。该表的第一行的值为START。随后的行按STEP递增，直到END。</target>
        </trans-unit>
        <trans-unit id="3f2ed0d414c19e451dbd160a6e3115271ef19a02" translate="yes" xml:space="preserve">
          <source>The geopoly module defines several new SQL functions that are useful for dealing with polygons. All polygon arguments to these functions can be either the GeoJSON format or the internal binary format.</source>
          <target state="translated">geopoly模块定义了几个新的SQL函数,这些函数对处理多边形很有用。这些函数的所有多边形参数可以是GeoJSON格式或内部二进制格式。</target>
        </trans-unit>
        <trans-unit id="8d993a3d44bf40860242bebc1265b2783cf9c63f" translate="yes" xml:space="preserve">
          <source>The geopoly module is an extension to the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;. Geopoly uses the same underlying logic and shadow tables as the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;. Geopoly merely presents a different interface, and provides some extra logic to compute polygon decoding, overlap, and containment.</source>
          <target state="translated">geopoly模块是&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展的扩展&lt;/a&gt;。Geopoly使用与&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展&lt;/a&gt;相同的基础逻辑和影子表。Geopoly仅提供了一个不同的界面，并提供了一些额外的逻辑来计算多边形解码，重叠和包含。</target>
        </trans-unit>
        <trans-unit id="acb138b945d23f00cd83af917d94b141700de307" translate="yes" xml:space="preserve">
          <source>The geopoly module is built on top of the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; and uses the same underlying shadow tables and algorithms. For indexing purposes, each polygon is represented in the shadow tables as a rectangular bounding box. The underlying R-Tree implementation uses bounding boxes to limit the search space. Then the geoploy_overlap() and/or geopoly_within() routines further refine the search to the exact answer.</source>
          <target state="translated">地理多边形模块建立在&lt;a href=&quot;rtree&quot;&gt;R-Tree扩展的&lt;/a&gt;顶部，并使用相同的基础阴影表和算法。为了建立索引，每个多边形在阴影表中均表示为矩形边界框。底层的R-Tree实现使用边界框来限制搜索空间。然后，geoploy_overlap（）和/或geopoly_within（）例程将搜索进一步优化为确切的答案。</target>
        </trans-unit>
        <trans-unit id="fdb9ae6360ea866b8222993691854e31ea695989" translate="yes" xml:space="preserve">
          <source>The geopoly_ccw(J) function returns the polygon J with counter-clockwise (CCW) rotation.</source>
          <target state="translated">geopoly_ccw(J)函数返回逆时针(CCW)旋转的多边形J。</target>
        </trans-unit>
        <trans-unit id="58be5b36690d1c8a61ca619684c9087df6d3c79c" translate="yes" xml:space="preserve">
          <source>The geopoly_group_bbox(P) function is an aggregate version of geopoly_bbox(P). The geopoly_group_bbox(P) function returns the smallest rectangle that will enclose all P values seen during aggregation.</source>
          <target state="translated">geopoly_group_bbox(P)函数是geopoly_bbox(P)的集合版本。geopoly_group_bbox(P)函数返回在聚合过程中所有P值的最小矩形。</target>
        </trans-unit>
        <trans-unit id="7aa31a665e34b0f93544b760a7bd5d5549c54d97" translate="yes" xml:space="preserve">
          <source>The geopoly_overlap(P1,P2) function is special in that the geopoly virtual table knows how to use R*Tree indexes to optimize queries in which the WHERE clause uses geopoly_overlap() as a boolean function. Only the geopoly_overlap(P1,P2) and geopoly_within(P1,P2) functions have this capability.</source>
          <target state="translated">geopoly_overlap(P1,P2)函数的特殊之处在于,geopoly虚拟表知道如何使用R*Tree索引来优化查询,其中WHERE子句使用geopoly_overlap()作为布尔函数。只有geopoly_overlap(P1,P2)和geopoly_within(P1,P2)函数具有这种能力。</target>
        </trans-unit>
        <trans-unit id="4552cf5a5f2e459423714152983f2ca48f86f169" translate="yes" xml:space="preserve">
          <source>The geopoly_regular(X,Y,R,N) function returns a convex, simple, regular, equilateral, equiangular polygon with N sides, centered at X,Y, and with a circumradius of R. Or, if R is negative or if N is less than 3, the function returns NULL. The N value is capped at 1000 so that the routine will never render a polygon with more than 1000 sides even if the N value is larger than 1000.</source>
          <target state="translated">geopoly_regular(X,Y,R,N)函数返回一个以X,Y为中心,周长为R的具有N条边的凸面、简单、规则、等边、等角的多边形,或者,如果R为负值或者N小于3,函数返回NULL。N值的上限为1000,因此即使N值大于1000,该例程也不会渲染一个边数超过1000的多边形。</target>
        </trans-unit>
        <trans-unit id="01eba492c4ddd36076bba0e9fe7c2f9d9c526116" translate="yes" xml:space="preserve">
          <source>The geopoly_within(P1,P2) function is special in that the geopoly virtual table knows how to use R*Tree indexes to optimize queries in which the WHERE clause uses geopoly_within() as a boolean function. Only the geopoly_within(P1,P2) and geopoly_overlap(P1,P2) functions have this capability.</source>
          <target state="translated">geopoly_within(P1,P2)函数的特殊之处在于,geopoly虚拟表知道如何使用R*Tree索引来优化查询,其中WHERE子句使用geopoly_within()作为布尔函数。只有geopoly_within(P1,P2)和geopoly_overlap(P1,P2)函数具有这种能力。</target>
        </trans-unit>
        <trans-unit id="45313c37ef01af04ca79cf8e508d2efcd3ced709" translate="yes" xml:space="preserve">
          <source>The geopoly_xform(P,A,B,C,D,E,F) function returns a new polygon that is an affine transformation of the polygon P and where the transformation is defined by values A,B,C,D,E,F. If P is not a valid polygon, this routine returns NULL.</source>
          <target state="translated">geopoly_xform(P,A,B,C,D,E,F)函数返回一个新的多边形,这个多边形是多边形P的仿射变换,变换的定义是A,B,C,D,E,F。如果P不是一个有效的多边形,这个例程返回NULL。</target>
        </trans-unit>
        <trans-unit id="8a7538a75bac0dc91c968f2f943ef8c77b915108" translate="yes" xml:space="preserve">
          <source>The glob(X,Y) function is equivalent to the expression &quot;&lt;b&gt;Y GLOB X&lt;/b&gt;&quot;. Note that the X and Y arguments are reversed in the glob() function relative to the infix &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator. Y is the string and X is the pattern. So, for example, the following expressions are equivalent:</source>
          <target state="translated">glob（X，Y）函数等效于表达式&amp;ldquo; &lt;b&gt;Y GLOB X&lt;/b&gt; &amp;rdquo;。请注意，相对于中缀&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;运算符，glob（）函数中的X和Y参数是相反的。Y是字符串，X是模式。因此，例如，以下表达式是等效的：</target>
        </trans-unit>
        <trans-unit id="57af892941202e82d82f19e609a84ccb0531eaad" translate="yes" xml:space="preserve">
          <source>The goal is to make SQLite handle NULLs in a standards-compliant way. But the descriptions in the SQL standards on how to handle NULLs seem ambiguous. It is not clear from the standards documents exactly how NULLs should be handled in all circumstances.</source>
          <target state="translated">目标是让SQLite以符合标准的方式处理NULLs。但是SQL标准中关于如何处理NULLs的描述似乎很模糊。从标准文档中看不出在所有情况下到底应该如何处理NULLs。</target>
        </trans-unit>
        <trans-unit id="2ba0147df5ada0e089bdabaebc1a5094f5e9a20f" translate="yes" xml:space="preserve">
          <source>The goal of this query is to compute some value for the five most recent entries in the table. But in the query above, the &quot;expensive_function()&quot; is invoked prior to the sort and thus is invoked on every row of the table, even rows that are ultimately omitted due to the LIMIT clause. A co-routine can be used to work around this:</source>
          <target state="translated">这个查询的目标是为表中最近的五个条目计算一些值。但是在上面的查询中,&quot; expensive_function()&quot;是在排序之前被调用的,因此在表中的每一条记录上都会被调用,甚至是由于limit子句而最终被省略的记录。可以使用一个联合程序来解决这个问题。</target>
        </trans-unit>
        <trans-unit id="6cb2a89894c9f8119dfc52f2d254fce8328dc0f1" translate="yes" xml:space="preserve">
          <source>The goal of this query is to compute some value for the five most recent entries in the table. In the query above, the &quot;expensive_function()&quot; is invoked prior to the sort and thus is invoked on every row of the table, even rows that are ultimately omitted due to the LIMIT clause. A co-routine can be used to work around this:</source>
          <target state="translated">这个查询的目标是为表中最近的五个条目计算一些值。在上面的查询中,&quot; expensive_function()&quot;是在排序之前被调用的,因此在表中的每一条记录上都会被调用,甚至是由于limit子句而最终被省略的记录。可以使用一个联合程序来解决这个问题。</target>
        </trans-unit>
        <trans-unit id="27130ed911ba5b72cf5d70b6f38c66e3447f97b9" translate="yes" xml:space="preserve">
          <source>The grammar syntax is less error prone - using symbolic names for semantic values rather that the &quot;$1&quot;-style positional notation of Yacc.</source>
          <target state="translated">语法不容易出错--使用符号名来表示语义值,而不是Yacc的 &quot;1美元 &quot;式的位置符号。</target>
        </trans-unit>
        <trans-unit id="8288ae8eb06e54b34a1335f8c6fbfb99327b7542" translate="yes" xml:space="preserve">
          <source>The graph below shows the number of CPU cycles used by SQLite on a standard workload, for versions of SQLite going back about 10 years. Recent versions of SQLite use about one third as many the CPU cycles compared to older versions.</source>
          <target state="translated">下图显示了SQLite在标准工作负载上使用的CPU周期数,对于SQLite的版本可以追溯到10年前。与旧版本相比,最新版本的SQLite所使用的CPU周期约为三分之一。</target>
        </trans-unit>
        <trans-unit id="ea3dfc83e3fad7e5da84aa92171fa1f2ebb6adae" translate="yes" xml:space="preserve">
          <source>The group_concat() function returns a string which is the concatenation of all non-NULL values of</source>
          <target state="translated">group_concat()函数返回一个字符串,这个字符串是所有非NULL值的连接。</target>
        </trans-unit>
        <trans-unit id="998c879f2d9a4a324ed589705e44b7743eed8ace" translate="yes" xml:space="preserve">
          <source>The group_concat(x,'') SQL function returns NULL instead of an empty string when all inputs are empty strings. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/55746f9e65f85&quot;&gt;55746f9e65&lt;/a&gt;</source>
          <target state="translated">当所有输入均为空字符串时，group_concat（x，''）SQL函数将返回NULL而不是空字符串。机票&lt;a href=&quot;http://www.sqlite.org/src/info/55746f9e65f85&quot;&gt;55746F9E65&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="784b868822e251a84f7723c4b68b20334805a9ba" translate="yes" xml:space="preserve">
          <source>The group_concat(x,'') SQL function returns NULL instead of an empty string when all inputs are empty strings. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/55746f9e65f85&quot;&gt;55746f9e65&lt;/a&gt;</source>
          <target state="translated">当所有输入均为空字符串时，group_concat（x，''）SQL函数将返回NULL而不是空字符串。机票&lt;a href=&quot;https://www.sqlite.org/src/info/55746f9e65f85&quot;&gt;55746F9E65&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3cc69e429ade6ced467dc065c3703a231254bc0f" translate="yes" xml:space="preserve">
          <source>The handling of IN and NOT IN operators that contain a NULL on their right-hand side expression is brought into compliance with the SQL standard and with other SQL database engines. This is a bug fix, but as it has the potential to break legacy applications that depend on the older buggy behavior, we mark that as a *** Potentially incompatible change ***</source>
          <target state="translated">IN 和 NOT IN 运算符的处理,如果在其右侧表达式中包含 NULL,则符合 SQL 标准和其他 SQL 数据库引擎。这是一个bug修复,但由于它有可能破坏依赖于旧的bug行为的遗留应用程序,我们将其标记为***潜在的不兼容变化***。</target>
        </trans-unit>
        <trans-unit id="d0efc6030fa81d141b43a701523b55c7bcf660fd" translate="yes" xml:space="preserve">
          <source>The hash tables in the shm file are designed to answer the following question quickly:</source>
          <target state="translated">shm文件中的哈希表是为了快速回答以下问题而设计的。</target>
        </trans-unit>
        <trans-unit id="2856b370cad55dc7412b44b6f210c8cf053331d6" translate="yes" xml:space="preserve">
          <source>The hashes that identify check-ins and files on the Git mirror are different from the hashes in Fossil. There are many reasons for this, chief among them that Fossil uses a SHA3-256 hash whereas Git uses a SHA1 hash. During export, the original Fossil hash for each check-in is added as a footer to check-in comments. To avoid confusion, always use the original Fossil hash, not the Git hash, when referring to SQLite check-ins.</source>
          <target state="translated">Git 镜像上识别签到和文件的哈希值与 Fossil 的哈希值不同。这有很多原因,其中最主要的原因是 Fossil 使用的是 SHA3-256 哈希值,而 Git 使用的是 SHA1 哈希值。在导出过程中,每个签入的Fossil原始哈希值会被添加到签入注释的脚注中。为了避免混淆,在引用 SQLite 检查记录时,请使用 Fossil 的原始哈希值,而不是 Git 的哈希值。</target>
        </trans-unit>
        <trans-unit id="e115da518074674c7bed9606a1f3c39c1334b0dc" translate="yes" xml:space="preserve">
          <source>The header of the rollback journal can be overwritten with invalid header text (for example, all zeros).</source>
          <target state="translated">回滚日志的头可以用无效的头文字(例如,全部为零)覆盖。</target>
        </trans-unit>
        <trans-unit id="328251bbc9b91a18ef755ecd2993b4b5eb3cf221" translate="yes" xml:space="preserve">
          <source>The header of the rollback journal is well-formed and in particular has not been zeroed out.</source>
          <target state="translated">回滚期刊的刊头成型良好,特别是没有被清零。</target>
        </trans-unit>
        <trans-unit id="8908758df6621b583f7634e3a00bc808f16a9ffb" translate="yes" xml:space="preserve">
          <source>The header size varint and serial type varints will usually consist of a single byte. The serial type varints for large strings and BLOBs might extend to two or three byte varints, but that is the exception rather than the rule. The varint format is very efficient at coding the record header.</source>
          <target state="translated">头部大小变位符和序列类型变位符通常由一个字节组成。大字符串和BLOB的序列类型变位数可能会扩展到两个或三个字节的变位数,但这是例外而不是规则。varint格式对记录头的编码非常有效。</target>
        </trans-unit>
        <trans-unit id="6a561080aa600994c95f7609f8c9a76e07664cc1" translate="yes" xml:space="preserve">
          <source>The header string: &quot;SQLite format 3\000&quot;</source>
          <target state="translated">标题字符串:&quot;SQLite format 3\000&quot;</target>
        </trans-unit>
        <trans-unit id="9618d06778e016225462d5681eb6b291f7c80aa5" translate="yes" xml:space="preserve">
          <source>The heap limits are not enforced in the current implementation if one or more of following conditions are true:</source>
          <target state="translated">如果以下一个或多个条件为真,则在当前实施中不执行堆限制。</target>
        </trans-unit>
        <trans-unit id="95f9212fdc8a88cf98b4e1490976ec2f7354c6a2" translate="yes" xml:space="preserve">
          <source>The heavy wrapper employed by &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; is intended for use only during testing, analysis, and debugging of SQLite. The heavy wrapper has a significant performance and memory overhead and probably should not be used in production.</source>
          <target state="translated">&lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt;使用的重包装仅适用于SQLite的测试，分析和调试。繁重的包装程序具有显着的性能和内存开销，因此可能不应该在生产中使用。</target>
        </trans-unit>
        <trans-unit id="eb4610f1226d8f274f85d7debe217f5d65427f90" translate="yes" xml:space="preserve">
          <source>The heavy wrapper that is used when &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; is set also makes sure each new allocation is filled with nonsense data prior to returning the allocation to the caller. And as soon as an allocation is free, it is again filled with nonsense data. These two actions help to ensure that the SQLite core does not make assumptions about the state of newly allocated memory and that memory allocations are not used after they have been freed.</source>
          <target state="translated">设置&lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt;时使用的重包装器还可以确保在将分配返回给调用者之前，每个新分配都被无用数据填充。一旦分配是免费的，它就会再次被废话数据填充。这两个动作有助于确保SQLite核心不对新分配的内存状态做出假设，并且确保释放内存后不使用内存分配。</target>
        </trans-unit>
        <trans-unit id="a33b86543e89aa7fc91f1c01c079a10eabc5b26c" translate="yes" xml:space="preserve">
          <source>The hex() function interprets its argument as a BLOB and returns a string which is the upper-case hexadecimal rendering of the content of that blob.</source>
          <target state="translated">hex()函数将其参数解释为BLOB,并返回一个字符串,该字符串是该blob内容的大写十六进制渲染。</target>
        </trans-unit>
        <trans-unit id="47e9ec1a2ca9f6468b5d5ea9dca27a7ef3e3db0a" translate="yes" xml:space="preserve">
          <source>The high repeatability of cachegrind allows the SQLite developers to implement and measure &quot;microoptimizations&quot;. A microoptimization is a change to the code that results in a very small performance increase. Typical micro-optimizations reduce the number of CPU cycles by 0.1% or 0.05% or even less. Such improvements are impossible to measure with real-world timings. But hundreds or thousands of microoptimizations add up, resulting in measurable real-world performance gains.</source>
          <target state="translated">cachegrind的高重复性使得SQLite开发人员可以实现和测量 &quot;微优化&quot;。微优化是指对代码进行修改,使其性能得到很小的提升。典型的微优化可以减少0.1%或0.05%甚至更少的CPU周期数。这样的改进是无法用真实世界的时序来衡量的。但数百或数千次的微优化累积起来,就会产生可衡量的实际性能提升。</target>
        </trans-unit>
        <trans-unit id="8ccb63c8eb8186df2591985e1dd0399f9de8ed53" translate="yes" xml:space="preserve">
          <source>The high-reliability of SQLite is proven in practice. SQLite has been used without problems in multiple billions of smart-phones, IoT devices, and desktop applications, around the world, and for almost two decades.</source>
          <target state="translated">SQLite的高可靠性在实践中得到了验证。SQLite已经在全球多亿部智能手机、物联网设备和桌面应用中顺利使用,并且使用了近二十年。</target>
        </trans-unit>
        <trans-unit id="8285d1c1b74bc88c5caec05770baddba5bd483b5" translate="yes" xml:space="preserve">
          <source>The high-reliability of SQLite is proven in practice. SQLite has been used without problems in multiple billions of smart-phones, IoT devices, and desktop applications, around the world, and for over a decade.</source>
          <target state="translated">SQLite的高可靠性在实践中得到了验证。SQLite已经在全球多亿部智能手机、物联网设备和桌面应用中顺利使用,并且已经使用了十几年。</target>
        </trans-unit>
        <trans-unit id="f6fadaee687e9cfda1c93f7fa51b5ba3b3240bd6" translate="yes" xml:space="preserve">
          <source>The highlight() function returns a copy of the text from a specified column of the current row with extra markup text inserted to mark the start and end of phrase matches.</source>
          <target state="translated">Highlight()函数从当前行的指定列中返回一份文本的副本,并插入额外的标记文本来标记短语匹配的开始和结束。</target>
        </trans-unit>
        <trans-unit id="e43753ce0913d39afca1c9c249ea51ebaf6b6f06" translate="yes" xml:space="preserve">
          <source>The highlight() must be invoked with exactly three arguments following the table name. To be interpreted as follows:</source>
          <target state="translated">调用highlight()时,必须在表名后正好有三个参数。解释如下:</target>
        </trans-unit>
        <trans-unit id="bb9d506afb5b0054b66298f3975841775d6d258d" translate="yes" xml:space="preserve">
          <source>The histogram data is only useful if the right-hand side of the constraint is a simple compile-time constant or &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and not an expression.</source>
          <target state="translated">直方图数据仅在约束的右侧是简单的编译时常量或&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;而不是表达式的情况下才有用。</target>
        </trans-unit>
        <trans-unit id="754b3dec45709dc037212c7449e27878498a6122" translate="yes" xml:space="preserve">
          <source>The historical behavior of SQLite is incorrect according to the SQL:1999 standard and it is inconsistent with the behavior of MySQL and PostgreSQL. Version 3.6.0 changes the behavior of the IN and NOT IN operators to conform to the standard and to give the same results as other SQL database engines.</source>
          <target state="translated">根据SQL:1999标准,SQLite的历史行为是不正确的,它与MySQL和PostgreSQL的行为不一致。3.6.0版本改变了IN和NOT IN运算符的行为,以符合标准,并提供与其他SQL数据库引擎相同的结果。</target>
        </trans-unit>
        <trans-unit id="3be31364c3c06e62038927597ca88135a8ca4d7a" translate="yes" xml:space="preserve">
          <source>The iCost column is the numeric cost of transforming cFrom into cTo. This value should be a non-negative integer, and should probably be less than 100. The default single-character insertion and deletion costs are 100 and the default single-character to single-character substitution cost is 150. A cost of 10000 or more is considered &quot;infinite&quot; and causes the rule to be ignored.</source>
          <target state="translated">iCost列是将cFrom转换为cTo的数字成本。这个值应该是一个非负的整数,可能应该小于100。默认的单字符插入和删除成本是100,默认的单字符到单字符的替换成本是150。成本为10000或更多则被认为是 &quot;无限 &quot;的,会导致规则被忽略。</target>
        </trans-unit>
        <trans-unit id="d0b9d0aa5d29da45f0b93b40de44e2f95388c2e0" translate="yes" xml:space="preserve">
          <source>The iLang column is a non-negative integer that identifies a set of costs appropriate for a particular language. The editdist3 function will only use a single iLang value for any given edit-distance computation. The default value is 0. It is recommended that applications that only need to use a single language always use iLang==0 for all entries.</source>
          <target state="translated">iLang列是一个非负的整数,它标识了一组适合特定语言的成本。editdist3函数在任何给定的edit-distance计算中都只使用一个iLang值,默认值是0。默认值是0,建议只需要使用单一语言的应用程序总是对所有条目使用iLang==0。</target>
        </trans-unit>
        <trans-unit id="5013f8a1a10fac4a872743ceb29c353308c4297d" translate="yes" xml:space="preserve">
          <source>The iVersion field of &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; is provided as insurance against future enhancements. The iVersion value should always be 1 for SQLite version 3.5.</source>
          <target state="translated">提供&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;的iVersion字段作为将来增强功能的保证。对于SQLite版本3.5，iVersion值应始终为1。</target>
        </trans-unit>
        <trans-unit id="8b61610ddf9130372f875adae334c360bf359102" translate="yes" xml:space="preserve">
          <source>The iVersion field of &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; should be 1 for SQLite version 3.5.0. This number may increase in future versions of SQLite if we have to modify the VFS object in some way. We hope that this never happens, but the provision is made in case it does.</source>
          <target state="translated">对于SQLite版本3.5.0 ，&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;的iVersion字段应为1。如果我们必须以某种方式修改VFS对象，则在将来的SQLite版本中此数目可能会增加。我们希望这种情况永远不会发生，但会在必要时作出规定。</target>
        </trans-unit>
        <trans-unit id="ea830f2d673441ec5d80e9c5eb8623ea5999e87b" translate="yes" xml:space="preserve">
          <source>The idea behind a reserved lock is that it signals that a process intends to modify the database file in the near future but has not yet started to make the modifications. And because the modifications have not yet started, other processes can continue to read from the database. However, no other process should also begin trying to write to the database.</source>
          <target state="translated">保留锁背后的想法是,它标志着一个进程打算在不久的将来修改数据库文件,但还没有开始进行修改。而由于修改还没有开始,其他进程可以继续从数据库中读取。但是,其他进程也不应该开始尝试向数据库写入。</target>
        </trans-unit>
        <trans-unit id="b86c36b3766e07cfb666e3625925c99f4017f8b5" translate="yes" xml:space="preserve">
          <source>The idxNum and idxPtr values are recorded and passed into the &lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; is used to free idxPtr if and only if needToFreeIdxPtr is true.</source>
          <target state="translated">记录idxNum和idxPtr值，并将其传递到&lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;方法中。当且仅当needToFreeIdxPtr为true时，才使用&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放idxPtr。</target>
        </trans-unit>
        <trans-unit id="357574f6e5fd171b87a29904a513e7015690c872" translate="yes" xml:space="preserve">
          <source>The idxNum and idxPtr values are recorded and passed into the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; is used to free idxPtr if and only if needToFreeIdxPtr is true.</source>
          <target state="translated">记录idxNum和idxPtr值，并将其传递到&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;方法中。当且仅当needToFreeIdxPtr为true时，才使用&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;释放idxPtr。</target>
        </trans-unit>
        <trans-unit id="013b479832be35dd0d8a4395d938100b93b10f74" translate="yes" xml:space="preserve">
          <source>The idxStr value may be a string obtained from an SQLite memory allocation function such as &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;. If this is the case, then the needToFreeIdxStr flag must be set to true so that the SQLite core will know to call &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; on that string when it has finished with it, and thus avoid a memory leak. The idxStr value may also be a static constant string, in which case the needToFreeIdxStr boolean should remain false.</source>
          <target state="translated">idxStr值可以是从SQLite内存分配函数（例如&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（））&lt;/a&gt;获得的字符串。如果是这种情况，那么必须将needToFreeIdxStr标志设置为true，以便SQLite内核在完成该字符串后将知道在该字符串上调用&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;，从而避免了内存泄漏。idxStr值也可以是静态常量字符串，在这种情况下，needToFreeIdxStr布尔值应保持为false。</target>
        </trans-unit>
        <trans-unit id="53bc345818e3cfbbe8c82ba1be412d51eef79f34" translate="yes" xml:space="preserve">
          <source>The ieee754 extension converts a floating point number between its binary64 representation and the M&amp;times;2&lt;sup&gt;&lt;small&gt;E&lt;/small&gt;&lt;/sup&gt; format. In other words in the expression:</source>
          <target state="translated">ieee754扩展名在其binary64表示形式和M&amp;times;2 &lt;sup&gt;&lt;small&gt;E&lt;/small&gt;&lt;/sup&gt;格式之间转换浮点数。换句话说，在表达式中：</target>
        </trans-unit>
        <trans-unit id="d2f1322e38e7bf458c5d54d75c7506d3ae73217c" translate="yes" xml:space="preserve">
          <source>The ieee754 extension converts between F and (M,E) and back again.</source>
          <target state="translated">ieee754扩展在F和(M,E)之间转换,然后再返回。</target>
        </trans-unit>
        <trans-unit id="7d7e2d6ba2a9578fe636d96019c4ffb56636fdf7" translate="yes" xml:space="preserve">
          <source>The ieee754 extension is not part of the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, but it is included by default in the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;. If you want to include the ieee754 extension in your application, you will need to compile and load it separately.</source>
          <target state="translated">ieee754扩展名不是&lt;a href=&quot;amalgamation&quot;&gt;合并的&lt;/a&gt;一部分，但默认情况下包含在&lt;a href=&quot;cli&quot;&gt;CLI中&lt;/a&gt;。如果要在应用程序中包含ieee754扩展名，则需要分别编译和加载它。</target>
        </trans-unit>
        <trans-unit id="ac62a77b019e01de7ef209efbe441dd3c0eb2c08" translate="yes" xml:space="preserve">
          <source>The ieee754(F) SQL function takes a single floating-point argument as its input and returns a string that looks like this:</source>
          <target state="translated">ieee754(F)SQL函数将一个浮点参数作为输入,并返回一个类似于这样的字符串。</target>
        </trans-unit>
        <trans-unit id="79c018ce9988c89e6d43c340880c6cf378ed2e6c" translate="yes" xml:space="preserve">
          <source>The ieee754_to_blob(F) SQL function converts the floating point number F into an 8-byte BLOB that is the big-endian binary64 encoding of that number. The ieee754_from_blob(B) function goes the other way, converting an 8-byte blob into the floating-point value that the binary64 encoding represents.</source>
          <target state="translated">ieee754_to_blob(F)SQL函数将浮点数F转换为一个8字节的BLOB,这个BLOB是这个数字的大二进制64编码。ieee754_from_blob(B)函数则反其道而行之,将一个8字节的blob转换为二进制64编码所代表的浮点值。</target>
        </trans-unit>
        <trans-unit id="4d5a7e8bc386f87dedf4ba3978aa31bcde8d6916" translate="yes" xml:space="preserve">
          <source>The ifnull() function returns a copy of its first non-NULL argument, or NULL if both arguments are NULL. Ifnull() must have exactly 2 arguments. The ifnull() function is equivalent to &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt; with two arguments.</source>
          <target state="translated">ifnull（）函数返回其第一个非NULL参数的副本，如果两个参数均为NULL，则返回NULL。 Ifnull（）必须正好有2个参数。 ifnull（）函数等效于带有两个参数的&lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="003c977ed53ddacaa1a12c60c49d228fced8878c" translate="yes" xml:space="preserve">
          <source>The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise. The iif(X,Y,Z) function is logically equivalent to and generates the same &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; as the &lt;a href=&quot;lang_expr#case&quot;&gt;CASE expression&lt;/a&gt; &quot;CASE WHEN X THEN Y ELSE Z END&quot;.</source>
          <target state="translated">如果X为true，则iif（X，Y，Z）函数返回值Y，否则返回Z。的IIF（X，Y，Z）函数在逻辑上等同于，并产生相同的&lt;a href=&quot;opcode&quot;&gt;字节码&lt;/a&gt;为&lt;a href=&quot;lang_expr#case&quot;&gt;CASE表达式&lt;/a&gt;&amp;ldquo;CASE WHEN X，则Y ELSEŽEND&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="46220a05919fd727bb5192ff33d2f0412a4a1656" translate="yes" xml:space="preserve">
          <source>The immutable query parameter is a boolean that signals to SQLite that the underlying database file is held on read-only media and cannot be modified, even by another process with elevated privileges. SQLite always opens immutable database files read-only and it skips all file locking and change detection on immutable database files. If these query parameter (or the &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_IMMUTABLE&lt;/a&gt; bit in xDeviceCharacteristics) asserts that a database file is immutable and that file changes anyhow, then SQLite might return incorrect query results and/or &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; errors.</source>
          <target state="translated">不可变的查询参数是一个布尔值，它向SQLite发出信号，通知其基础数据库文件位于只读介质上，并且即使具有更高特权的另一个进程也无法对其进行修改。 SQLite始终以只读方式打开不可变数据库文件，并跳过所有文件锁定并更改不可变数据库文件的更改检测。如果这些查询参数（或&lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;xDeviceCharacteristics&lt;/a&gt;中的SQLITE_IOCAP_IMMUTABLE位）断言数据库文件是不可变的，并且该文件无论如何都会发生更改，则SQLite可能返回错误的查询结果和/或&lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt;错误。</target>
        </trans-unit>
        <trans-unit id="a6b9b8cf3a7d94e9575aa22c08feee5317ab9464" translate="yes" xml:space="preserve">
          <source>The implementation for the spellfix1 virtual table is held in the SQLite source tree in the miscellaneous extensions folder and in particular in the file &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=ext/misc/spellfix.c&quot;&gt;ext/misc/spellfix1.c&lt;/a&gt;. The spellfix1 virtual table is not included in the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; and is not a part of any standard SQLite build. It is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;.</source>
          <target state="translated">spellfix1虚拟表的实现保存在SQLite源树的其他扩展文件夹中，尤其是在文件&lt;a href=&quot;http://www.sqlite.org/src/finfo?name=ext/misc/spellfix.c&quot;&gt;ext / misc / spellfix1.c中&lt;/a&gt;。spellfix1虚拟表未包含在SQLite &lt;a href=&quot;amalgamation&quot;&gt;合并中&lt;/a&gt;，也不是任何标准SQLite构建的一部分。这是一个&lt;a href=&quot;loadext&quot;&gt;可加载的扩展&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b2bd756ff188c7be1eef7fbb7b81b9836511fcee" translate="yes" xml:space="preserve">
          <source>The implementation for the spellfix1 virtual table is held in the SQLite source tree in the miscellaneous extensions folder and in particular in the file &lt;a href=&quot;https://www.sqlite.org/src/finfo?name=ext/misc/spellfix.c&quot;&gt;ext/misc/spellfix1.c&lt;/a&gt;. The spellfix1 virtual table is not included in the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; and is not a part of any standard SQLite build. It is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;.</source>
          <target state="translated">spellfix1虚拟表的实现保存在其他扩展文件夹中的SQLite源树中，尤其是在文件&lt;a href=&quot;https://www.sqlite.org/src/finfo?name=ext/misc/spellfix.c&quot;&gt;ext / misc / spellfix1.c中&lt;/a&gt;。spellfix1虚拟表不包括在SQLite&lt;a href=&quot;amalgamation&quot;&gt;合并中&lt;/a&gt;，也不是任何标准SQLite构建的一部分。这是一个&lt;a href=&quot;loadext&quot;&gt;可加载的扩展&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8eb5688bafc7d4405d9e0ef667e71e04726e76e8" translate="yes" xml:space="preserve">
          <source>The implementation is not required to provide versions of these routines that actually work. If the implementation does not provide working versions of these routines, it should at least provide stubs that always return true so that one does not get spurious assertion failures.</source>
          <target state="translated">不要求实施者提供这些例程的实际工作版本。如果实现不提供这些例程的工作版本,它至少应该提供总是返回true的存根,这样就不会出现虚假的断言失败。</target>
        </trans-unit>
        <trans-unit id="8b40a9e730bef66c422bb631b44b6863716defa7" translate="yes" xml:space="preserve">
          <source>The implementation is registered with the FTS5 module by calling the xCreateFunction() method of the fts5_api object. If there is already an auxiliary function with the same name, it is replaced by the new function. If a non-NULL xDestroy parameter is passed to xCreateFunction(), it is invoked with a copy of the pContext pointer passed as the only argument when the database handle is closed or when the registered auxiliary function is replaced.</source>
          <target state="translated">通过调用fts5_api对象的xCreateFunction()方法,实现在FTS5模块中注册。如果已经有一个同名的辅助函数,那么它将被新函数所取代。如果向xCreateFunction()传递了一个非NULL的xDestroy参数,那么当数据库句柄关闭或已注册的辅助函数被替换时,它将被调用,传递的pContext指针的副本作为唯一的参数。</target>
        </trans-unit>
        <trans-unit id="bbe3105d33c8a4906448b08f8925bf436af3dd67" translate="yes" xml:space="preserve">
          <source>The implementation is registered with the FTS5 module by calling the xCreateTokenizer() method of the fts5_api object. If there is already a tokenizer with the same name, it is replaced. If a non-NULL xDestroy parameter is passed to xCreateTokenizer(), it is invoked with a copy of the pContext pointer passed as the only argument when the database handle is closed or when the tokenizer is replaced.</source>
          <target state="translated">通过调用fts5_api对象的xCreateTokenizer()方法,实现在FTS5模块中注册。如果已经有一个同名的tokenizer,它将被替换。如果xCreateTokenizer()方法中传递了一个非NULL的xDestroy参数,那么当数据库句柄关闭或tokenizer被替换时,将以pContext指针的副本作为唯一的参数被调用。</target>
        </trans-unit>
        <trans-unit id="8b89a513d4c178ab8d213508b88c8e5c09e3c7a1" translate="yes" xml:space="preserve">
          <source>The implementation language for the example code is &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TCL&lt;/a&gt;, though you can easily do the same thing in another programming language. Remember that the code here is a demonstration of the technique, not a drop-in module that will automatically do everything for you. The demonstration code shown below is derived from actual code in production use. But you will need to make changes to tailor it to your application.</source>
          <target state="translated">示例代码的实现语言是&lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TCL&lt;/a&gt;，尽管您可以轻松地用另一种编程语言来做同样的事情。请记住，这里的代码是该技术的演示，而不是将自动为您做所有事情的嵌入式模块。下面显示的演示代码源自生产中的实际代码。但是您将需要进行更改以使其适合您的应用程序。</target>
        </trans-unit>
        <trans-unit id="1c7602fe1bd4486f649d10efe941c63ad9ebc01d" translate="yes" xml:space="preserve">
          <source>The implementation of this function could be enhanced in at least two ways:</source>
          <target state="translated">至少可以从两个方面加强这一功能的实施。</target>
        </trans-unit>
        <trans-unit id="fb654149d36243346cb33110dabec3f86ec0e93a" translate="yes" xml:space="preserve">
          <source>The important parts of the output (the parts that the developers pay the most attention to) are shown in red. Basically, the developers want to know the size of the compiled SQLite library and how many CPU cycles were needed to run the performance test.</source>
          <target state="translated">输出的重要部分(开发者最关注的部分)用红色显示。基本上,开发人员想知道编译后的SQLite库的大小,以及运行性能测试需要多少CPU周期。</target>
        </trans-unit>
        <trans-unit id="98a68810edc43f0319b74cd65a4602d55569695b" translate="yes" xml:space="preserve">
          <source>The imposter table mechanism is a power analysis and debugging tool for SQLite. But as with all sharp tools, it can also be dangerous and can result in corrupt database files if misused. Do not attempt to use imposter tables in an application. Imposter tables are intended for use in the laboratory by experts.</source>
          <target state="translated">冒名表机制是SQLite的一个强大的分析和调试工具。但是和所有的利器一样,它也是危险的,如果误用的话,可能会导致数据库文件的损坏。不要试图在应用程序中使用冒名表。冒牌表是供专家在实验室使用的。</target>
        </trans-unit>
        <trans-unit id="f137c1fa92f06c6d9054e4f6699dd72be9e8aeef" translate="yes" xml:space="preserve">
          <source>The in-header database size is only considered to be valid if it is non-zero and if the 4-byte &lt;a href=&quot;fileformat2#chngctr&quot;&gt;change counter&lt;/a&gt; at offset 24 exactly matches the 4-byte &lt;a href=&quot;fileformat2#validfor&quot;&gt;version-valid-for number&lt;/a&gt; at offset 92. The in-header database size is always valid when the database is only modified using recent versions of SQLite, versions 3.7.0 (2010-07-21) and later. If a legacy version of SQLite writes to the database, it will not know to update the in-header database size and so the in-header database size could be incorrect. But legacy versions of SQLite will also leave the version-valid-for number at offset 92 unchanged so it will not match the change-counter. Hence, invalid in-header database sizes can be detected (and ignored) by observing when the change-counter does not match the version-valid-for number.</source>
          <target state="translated">头内数据库大小只有在非零且偏移量为24 的4字节&lt;a href=&quot;fileformat2#chngctr&quot;&gt;更改计数器&lt;/a&gt;与偏移量92处的4字节&lt;a href=&quot;fileformat2#validfor&quot;&gt;版本有效号&lt;/a&gt;完全匹配时，才被认为是有效的。头内数据库当仅使用SQLite的最新版本3.7.0（2010-07-21）和更高版本修改数据库时，size始终有效。如果旧版本的SQLite写入数据库，它将不知道更新头中数据库的大小，因此头中数据库的大小可能不正确。但是SQLite的旧版本还将在偏移量92处保留版本有效号，因此它不会与更改计数器匹配。因此，可以通过观察更改计数器何时与版本有效期号不匹配来检测（并忽略）无效的页眉内数据库大小。</target>
        </trans-unit>
        <trans-unit id="856311d50a8fd5f75cd3339835ec40132b3ad9e1" translate="yes" xml:space="preserve">
          <source>The incremental_vacuum pragma causes up to</source>
          <target state="translated">递增式真空原则最多可以造成</target>
        </trans-unit>
        <trans-unit id="2444d76ed75c2820750a8e50ad8c1d29d5247c49" translate="yes" xml:space="preserve">
          <source>The index is not usable at all because the left-most column of the index (column &quot;a&quot;) is not constrained. Assuming there are no other indexes, the query above would result in a full table scan.</source>
          <target state="translated">该索引根本无法使用,因为该索引最左边的列(列 &quot;a&quot;)没有约束。假设没有其他索引,上面的查询将导致全表扫描。</target>
        </trans-unit>
        <trans-unit id="2dd53e3930b5b852ae3198064e374d5480957b02" translate="yes" xml:space="preserve">
          <source>The index is not usable at all because the left-most column of the index (column &quot;a&quot;) is not constrained. Assuming there are no other indices, the query above would result in a full table scan.</source>
          <target state="translated">该索引根本无法使用,因为该索引最左边的列(列 &quot;a&quot;)没有受到约束。假设没有其他索引,上面的查询将导致全表扫描。</target>
        </trans-unit>
        <trans-unit id="5bb4d2a2c9144ace7c8a07adac81542aa803ab36" translate="yes" xml:space="preserve">
          <source>The index is not usable because the WHERE clause terms are connected by OR instead of AND. This query would result in a full table scan. However, if three additional indexes where added that contained columns b, c, and d as their left-most columns, then the &lt;a href=&quot;#or_opt&quot;&gt;OR-clause optimization&lt;/a&gt; might apply.</source>
          <target state="translated">该索引不可用，因为WHERE子句项通过OR而不是AND连接。此查询将导致全表扫描。但是，如果添加了另外三个包含b，c和d列作为其最左列的索引，则可能应用&lt;a href=&quot;#or_opt&quot;&gt;OR子句优化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af8e63da60690ffa41a028a8c03b3a46553b1974" translate="yes" xml:space="preserve">
          <source>The index is not usable because the WHERE clause terms are connected by OR instead of AND. This query would result in a full table scan. However, if three additional indices where added that contained columns b, c, and d as their left-most columns, then the &lt;a href=&quot;#or_opt&quot;&gt;OR-clause optimization&lt;/a&gt; might apply.</source>
          <target state="translated">该索引不可用，因为WHERE子句项通过OR而不是AND连接。该查询将导致全表扫描。但是，如果添加的另外三个索引包含b，c和d列作为它们的最左列，则可能应用&lt;a href=&quot;#or_opt&quot;&gt;OR子句优化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="672cc6d4ea8af33a329ad85f582fc436091b60cb" translate="yes" xml:space="preserve">
          <source>The index of the term instance within its column. Terms are numbered in order of occurrence starting from 0.</source>
          <target state="translated">术语实例在其列中的索引。术语按出现的顺序从0开始编号。</target>
        </trans-unit>
        <trans-unit id="9be4bc1fc0e600b05c5d496186036ea84f9ef15d" translate="yes" xml:space="preserve">
          <source>The indexed documents are not stored within the SQLite database at all (a &quot;contentless&quot; FTS4 table), or</source>
          <target state="translated">索引的文档根本没有存储在SQLite数据库中(一个 &quot;无内容 &quot;的FTS4表),或</target>
        </trans-unit>
        <trans-unit id="e1d425e949e65fa344c6b8fb0277d12b499d6fc9" translate="yes" xml:space="preserve">
          <source>The indexed documents are stored in a database table created and managed by the user (an &quot;external content&quot; FTS4 table).</source>
          <target state="translated">索引文件存储在用户创建和管理的数据库表中(&quot;外部内容 &quot;FTS4表)。</target>
        </trans-unit>
        <trans-unit id="4f34a5ba84b8851d3a1f9940d6783cb16a9d85e9" translate="yes" xml:space="preserve">
          <source>The indexes are not required, but they do help performance for large graphs. To find all nodes of the graph that are connected to node 59, use a query similar to the following:</source>
          <target state="translated">索引不是必需的,但它们确实有助于大型图的性能。要找到图中与节点59相连的所有节点,请使用类似下面的查询。</target>
        </trans-unit>
        <trans-unit id="4aef068b1a0d56e1caa7dcf9dfa167672f1599ff" translate="yes" xml:space="preserve">
          <source>The infix LIKE operator is implemented by calling the application-defined SQL functions &lt;a href=&quot;lang_corefunc#like&quot;&gt;like(&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;X&lt;/i&gt;)&lt;/a&gt; or &lt;a href=&quot;lang_corefunc#like&quot;&gt;like(&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/a&gt;.</source>
          <target state="translated">通过调用应用程序定义的SQL函数&lt;a href=&quot;lang_corefunc#like&quot;&gt;（如（&lt;i&gt;Y&lt;/i&gt;，&lt;i&gt;X&lt;/i&gt;）&lt;/a&gt;或&lt;a href=&quot;lang_corefunc#like&quot;&gt;like（&lt;i&gt;Y&lt;/i&gt;，&lt;i&gt;X&lt;/i&gt;，&lt;i&gt;Z&lt;/i&gt;）&lt;/a&gt;来实现infix LIKE运算符。</target>
        </trans-unit>
        <trans-unit id="88a733d117cd4f0a7921fa6f2a987e25c2eb02d1" translate="yes" xml:space="preserve">
          <source>The information above can be recast into a table format as follows:</source>
          <target state="translated">上述信息可改写成如下表格格式:</target>
        </trans-unit>
        <trans-unit id="7c260215b8c7aaba3e0315515668088d0bdaae79" translate="yes" xml:space="preserve">
          <source>The information accessed using this API and its companion xPhraseFirstColumn() may also be obtained using xPhraseFirst/xPhraseNext (or xInst/xInstCount). The chief advantage of this API is that it is significantly more efficient than those alternatives when used with &quot;detail=column&quot; tables.</source>
          <target state="translated">使用该API及其配套的xPhraseFirstColumn()访问的信息也可以使用xPhraseFirst/xPhraseNext(或xInst/xInstCount)获得。这个API的主要优点是,当与 &quot;detail=column &quot;表一起使用时,它的效率明显高于这些替代方法。</target>
        </trans-unit>
        <trans-unit id="e6d1054c7b3f35c96345a991890c1e40578c9e8c" translate="yes" xml:space="preserve">
          <source>The information in the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure is ephemeral and may be overwritten or deallocated as soon as the xBestIndex method returns. If the xBestIndex method needs to remember any part of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure, it should make a copy. Care must be take to store the copy in a place where it will be deallocated, such as in the idxStr field with needToFreeIdxStr set to 1.</source>
          <target state="translated">&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;结构中的信息是短暂的，并且xBestIndex方法返回时可能会被覆盖或释放。如果xBestIndex方法需要记住&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;结构的任何部分，则应进行复制。必须注意将副本存储在将要释放的位置，例如，在NeedToFreeIdxStr设置为1的idxStr字段中。</target>
        </trans-unit>
        <trans-unit id="32cf05e222bbae76e66c5abe0ecf2fd84a3a7c70" translate="yes" xml:space="preserve">
          <source>The information in this article applies only when SQLite is operating in &quot;rollback mode&quot;, or in other words when SQLite is not using a &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;. SQLite still supports atomic commit when write-ahead logging is enabled, but it accomplishes atomic commit by a different mechanism from the one described in this article. See the &lt;a href=&quot;wal&quot;&gt;write-ahead log documentation&lt;/a&gt; for additional information on how SQLite supports atomic commit in that context.</source>
          <target state="translated">本文中的信息仅在SQLite在&amp;ldquo;回退模式&amp;rdquo;下运行时才适用，换句话说，当SQLite不使用&lt;a href=&quot;wal&quot;&gt;预写日志&lt;/a&gt;时才适用。启用预写日志记录后，SQLite仍支持原子提交，但是它通过与本文介绍的机制不同的机制来实现原子提交。有关SQLite在该上下文中如何支持原子提交的其他信息，请参见&lt;a href=&quot;wal&quot;&gt;预写日志文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f9342562e97e372cf7348a184a4d34dd086f3cc5" translate="yes" xml:space="preserve">
          <source>The initial &quot;INSERT&quot; keyword can be replaced by &quot;REPLACE&quot; or &quot;INSERT OR</source>
          <target state="translated">最初的 &quot;INSERT &quot;关键字可以用 &quot;REPLACE &quot;或 &quot;INSERT OR &quot;代替。</target>
        </trans-unit>
        <trans-unit id="d2a90ccaf25a62976be28829cc53054a6feb5a8b" translate="yes" xml:space="preserve">
          <source>The initial content is UTF-16 text and sqlite3_column_bytes() or sqlite3_column_text() is called. The content must be converted to UTF-8.</source>
          <target state="translated">初始内容为UTF-16文本,调用sqlite3_column_bytes()或sqlite3_column_text()。内容必须转换为UTF-8。</target>
        </trans-unit>
        <trans-unit id="f5abf60cee620000168958a8b5acfa6d74016d3a" translate="yes" xml:space="preserve">
          <source>The initial content is UTF-8 text and sqlite3_column_bytes16() or sqlite3_column_text16() is called. The content must be converted to UTF-16.</source>
          <target state="translated">初始内容为UTF-8文本,调用sqlite3_column_bytes16()或sqlite3_column_text16()。内容必须转换为UTF-16。</target>
        </trans-unit>
        <trans-unit id="16a79a9ef866be9ddb29420482c978bd29b5a111" translate="yes" xml:space="preserve">
          <source>The initial content is a BLOB and sqlite3_column_text() or sqlite3_column_text16() is called. A zero-terminator might need to be added to the string.</source>
          <target state="translated">初始内容是一个BLOB,调用sqlite3_column_text()或sqlite3_column_text16()。可能需要在字符串中添加一个零结束符。</target>
        </trans-unit>
        <trans-unit id="e8f78c0547aa09c0045543ed5c95b2ff19b12417" translate="yes" xml:space="preserve">
          <source>The initial implementation of NGQP chooses N=1 for simple queries, N=5 for two-way joins and N=10 for all joins with three or more tables. This formula for selecting N might change in subsequent releases.</source>
          <target state="translated">NGQP的初始实现对简单查询选择N=1,对双向连接选择N=5,对所有有三个或更多表的连接选择N=10。这个选择N的公式在后续版本中可能会改变。</target>
        </trans-unit>
        <trans-unit id="433c6a25716e7b035366d6fcddc3266fd3d25e85" translate="yes" xml:space="preserve">
          <source>The initial portion of the payload that does not spill to overflow pages.</source>
          <target state="translated">不溢出到溢出页的有效载荷的初始部分。</target>
        </trans-unit>
        <trans-unit id="dd04f34f18dd2c979d9e74f1f84fb7d84f3f8036" translate="yes" xml:space="preserve">
          <source>The initial-select in this case is the simple query &quot;SELECT 59&quot;. This establishes the base case. The recursive-select consists of the other two SELECT statements. The first recursive SELECT follows edges in the bb-to-aa direction and the second recursive SELECT follows edges in the aa-to-bb direction. UNION is used instead of UNION ALL to prevent the recursion from entering an infinite loop if the graph contains cycles.</source>
          <target state="translated">本例中的初始选择是简单的查询 &quot;SELECT 59&quot;。这就建立了基本情况。递归选择由另外两个SELECT语句组成。第一个递归select在bb到aa的方向上跟随边缘,第二个递归select在aa到bb的方向上跟随边缘。使用UNION代替UNION ALL,以防止在图中包含循环时递归进入无限循环。</target>
        </trans-unit>
        <trans-unit id="a60a09b4b0f1a33259942d5b4f17c8bccd4a335d" translate="yes" xml:space="preserve">
          <source>The inner SELECT statement is implemented by instructions 1 through 10. All this code does is make an entry in the temporary table for each row of the examp2 table with a non-NULL value for the &quot;three&quot; column. The key for each temporary table entry is the &quot;three&quot; column of examp2 and the data is an empty string since it is never used.</source>
          <target state="translated">内部的SELECT语句由指令1至10实现。这段代码所做的就是在临时表中为examp2表的每一行做一个条目,&quot;三 &quot;列的值为非NULL。每个临时表条目的键是examp2的 &quot;三 &quot;列,数据是一个空字符串,因为它从未被使用过。</target>
        </trans-unit>
        <trans-unit id="059bc1f5d258819deb1954aaf03c0ff2e66225d4" translate="yes" xml:space="preserve">
          <source>The input data used by a simple SELECT query is a set of</source>
          <target state="translated">一个简单的SELECT查询所使用的输入数据是一系列的</target>
        </trans-unit>
        <trans-unit id="6894645090ea407676b9f33e59a0dad3066f4727" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete()&lt;/a&gt; must be a zero-terminated UTF-8 string.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete（）&lt;/a&gt;的输入必须是一个零终止的UTF-8字符串。</target>
        </trans-unit>
        <trans-unit id="4d7419b960ffd32c455a130a0e74d0adde2f9624" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete16()&lt;/a&gt; must be a zero-terminated UTF-16 string in native byte order.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete16（）&lt;/a&gt;的输入必须是以本机字节顺序为零终止的UTF-16字符串。</target>
        </trans-unit>
        <trans-unit id="4b672bd7f0a1d030d51edf7b207eec2b4f3ae087" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;complete&quot;&gt;sqlite3_complete()&lt;/a&gt; must be a zero-terminated UTF-8 string.</source>
          <target state="translated">&lt;a href=&quot;complete&quot;&gt;sqlite3_complete（）&lt;/a&gt;的输入必须是一个零终止的UTF-8字符串。</target>
        </trans-unit>
        <trans-unit id="cfd5dd711daa7423070d67fd7c844d95a0e5c24f" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;complete&quot;&gt;sqlite3_complete16()&lt;/a&gt; must be a zero-terminated UTF-16 string in native byte order.</source>
          <target state="translated">&lt;a href=&quot;complete&quot;&gt;sqlite3_complete16（）&lt;/a&gt;的输入必须是以本机字节顺序为零终止的UTF-16字符串。</target>
        </trans-unit>
        <trans-unit id="2d24c8f818c9e23a7423d1fe6a231842fef7a551" translate="yes" xml:space="preserve">
          <source>The inputs to TH3 are test modules written in C or SQL and small configuration files that determine how to initialize SQLite. The TH3 package includes 1,444 test modules and more than 47 configurations (as of 2018-05-19). New modules and configurations can be added to customize TH3 for specialized applications. Each time TH3 is run, it reads a subset of the available test modules and configuration files to generate a custom C program that performs all of the specified tests under all specified configurations. A complete test of SQLite normally involves running TH3 multiple times to generate multiple test programs covering different aspects of SQLite's operation, then linking all test programs against a common SQLite library and running them separately on the target platform.</source>
          <target state="translated">TH3的输入是用C或SQL编写的测试模块和决定如何初始化SQLite的小配置文件。TH3包包括1,444个测试模块和超过47种配置(截至2018-05-19)。可以添加新的模块和配置,以便为专门的应用定制TH3。每次运行TH3时,它都会读取可用的测试模块和配置文件的子集,以生成一个自定义C程序,在所有指定的配置下执行所有指定的测试。一个完整的SQLite测试通常需要多次运行TH3生成多个测试程序,涵盖SQLite操作的不同方面,然后将所有测试程序针对一个通用的SQLite库进行链接,并在目标平台上分别运行。</target>
        </trans-unit>
        <trans-unit id="bb4e6367e51d64e49b708aca20c83e616d792f73" translate="yes" xml:space="preserve">
          <source>The inspiration for this document is &lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt;. Among quality standards, DO-178B seems to have the highest usefulness to paperwork ratio. Even so, the amount of documentation needed for a full-up DO-178B implementation is vast. SQLite strives to be nimble and low-ceremony, and to that end, much of the required DO-178B documentation is omitted. We retain only those parts that genuinely improve quality for a open-source software project such as SQLite.</source>
          <target state="translated">本文档的灵感来自&lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt;。在质量标准中，DO-178B似乎对文书工作的使用率最高。即使这样，完整的DO-178B实施所需的文档数量仍然很大。SQLite努力做到敏捷和低礼仪，为此，省略了许多必需的DO-178B文档。我们仅保留那些真正提高了开源软件项目（例如SQLite）质量的部分。</target>
        </trans-unit>
        <trans-unit id="eeb6f7cf85fc1473abd39059a6c5676d36ad32d5" translate="yes" xml:space="preserve">
          <source>The instr(X,Y) function finds the first occurrence of string Y within string X and returns the number of prior characters plus 1, or 0 if Y is nowhere found within X. Or, if X and Y are both BLOBs, then instr(X,Y) returns one more than the number bytes prior to the first occurrence of Y, or 0 if Y does not occur anywhere within X. If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs then both are interpreted as strings. If either X or Y are NULL in instr(X,Y) then the result is NULL.</source>
          <target state="translated">instr(X,Y)函数在字符串X中找到字符串Y的首次出现,并返回前面的字符数加1,如果在X中找不到Y,则返回0。或者,如果X和Y都是BLOB,那么instr(X,Y)返回比Y首次出现之前的字节数多1,如果Y在X中没有出现,则返回0。如果instr(X,Y)的参数X和Y都是非NULL,并且不是BLOB,那么两者都被解释为字符串。如果在instr(X,Y)中X或Y都是NULL,那么结果就是NULL。</target>
        </trans-unit>
        <trans-unit id="a78743c67ceb66f35152669e19fad52bf271ff90" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Close&quot;&gt;Close&lt;/a&gt; closes a cursor previously opened as P1 (0, the only open cursor). If P1 is not currently open, this instruction is a no-op.</source>
          <target state="translated">&amp;ldquo; &lt;a href=&quot;opcode#Close&quot;&gt;关闭&lt;/a&gt; &amp;rdquo;指令关闭先前打开为P1（0，唯一打开的游标）的游标。如果P1当前未打开，则该指令为无操作。</target>
        </trans-unit>
        <trans-unit id="e8c5c65cb041570fcd5ae40ccc7306b738bb99f4" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Commit&quot;&gt;Commit&lt;/a&gt; causes all modifications to the database that have been made since the last Transaction to actually take effect. No additional modifications are allowed until another transaction is started. The Commit instruction deletes the journal file and releases the write lock on the database. A read lock continues to be held if there are still cursors open.</source>
          <target state="translated">&lt;a href=&quot;opcode#Commit&quot;&gt;提交&lt;/a&gt;指令使自上次事务处理以来对数据库所做的所有修改实际生效。在开始另一个事务之前，不允许进行其他修改。提交指令删除日志文件并释放数据库上的写锁。如果仍有游标打开，则将继续保持读锁定。</target>
        </trans-unit>
        <trans-unit id="71d724f14f1b112c6a8977fb693b84af3a6cb813" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; causes the VDBE engine to exit immediately. All open cursors, Lists, Sorts, etc are closed automatically. P1 is the result code returned by sqlite_exec(). For a normal halt, this should be SQLITE_OK (0). For errors, it can be some other value. The operand P2 is only used when there is an error. There is an implied &quot;Halt 0 0 0&quot; instruction at the end of every program, which the VDBE appends when it prepares a program to run.</source>
          <target state="translated">&lt;a href=&quot;opcode#Halt&quot;&gt;停止&lt;/a&gt;指令使VDBE引擎立即退出。所有打开的游标，列表，排序等都将自动关闭。 P1是sqlite_exec（）返回的结果代码。对于正常的停止，该值应为SQLITE_OK（0）。对于错误，它可以是其他值。仅在出现错误时才使用操作数P2。每个程序的末尾都有一个隐含的&amp;ldquo; Halt 0 0 0&amp;rdquo;指令，VDBE在准备要运行的程序时会附加该指令。</target>
        </trans-unit>
        <trans-unit id="4a2e93cc788564162251660dae046bf0362122e8" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#IdxRecno&quot;&gt;IdxRecno&lt;/a&gt; at 13 pushes onto the stack the table record number from the index. The following MoveTo pops it and moves the table cursor to that row. The next 3 instructions select the column data the same way as in the non- indexed case. The Column instructions fetch the column data and the callback function is invoked. The final Next instruction advances the index cursor, not the table cursor, to the next row, and then branches back to the start of the loop if there are any index records left.</source>
          <target state="translated">位于13 的指令&lt;a href=&quot;opcode#IdxRecno&quot;&gt;IdxRecno&lt;/a&gt;将来自索引的表记录号压入堆栈。下面的MoveTo弹出它，并将表格光标移动到该行。接下来的3条指令以与未索引情况相同的方式选择列数据。列指令获取列数据并调用回调函数。最后一条Next指令将索引游标（而不是表游标）前进到下一行，然后在剩余索引记录的情况下分支回到循环的开始。</target>
        </trans-unit>
        <trans-unit id="89a91a29199817279a977a2ce4541fd6e7fee24a" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt; pushes its P1 operand (99) onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">指令&lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt;将其P1操作数（99）压入堆栈。之后，堆栈如下所示：</target>
        </trans-unit>
        <trans-unit id="15f722b882a29ac5b03a20e923af0ef9dcb502b1" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt; pushes the integer value P1 (0) onto the stack. Here 0 is the number of the database to use in the following OpenWrite instruction. If P3 is not NULL then it is a string representation of the same integer. Afterwards the stack looks like this:</source>
          <target state="translated">指令&lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt;将整数值P1（0）压入堆栈。0是下面的OpenWrite指令中要使用的数据库的编号。如果P3不为NULL，则它是相同整数的字符串表示形式。之后，堆栈如下所示：</target>
        </trans-unit>
        <trans-unit id="d1df5b7ac8ac4ed32e40d9d958d1c725defad872" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; pops the top P1 elements off the stack (2 in this case) and converts them into the binary format used for storing records in a database file. (See the &lt;a href=&quot;fileformat&quot;&gt;file format&lt;/a&gt; description for details.) The new record generated by the MakeRecord instruction is pushed back onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;指令将顶部的P1元素弹出堆栈（在这种情况下为2），并将其转换为用于在数据库文件中存储记录的二进制格式。（有关详细信息，请参见&lt;a href=&quot;fileformat&quot;&gt;文件格式&lt;/a&gt;说明。）由MakeRecord指令生成的新记录将推回堆栈。之后，堆栈如下所示：</target>
        </trans-unit>
        <trans-unit id="21bb54c4787b5b030612c3d381e1ba9b4bb1f341" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#NewRecno&quot;&gt;NewRecno&lt;/a&gt; creates a new integer record number for the table pointed to by cursor P1. The record number is one not currently used as a key in the table. The new record number is pushed onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">指令&lt;a href=&quot;opcode#NewRecno&quot;&gt;NewRecno&lt;/a&gt;为光标P1指向的表创建一个新的整数记录号。记录号是当前未在表中用作键的记录号。新的记录号被压入堆栈。之后，堆栈如下所示：</target>
        </trans-unit>
        <trans-unit id="213073395c8927a399e8bb754b1febc0fe16eb95" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt; opens a new read/write cursor with handle P1 (0 in this case) on table &quot;examp&quot;, whose root page is P2 (3, in this database file). Cursor handles can be any non-negative integer. But the VDBE allocates cursors in an array with the size of the array being one more than the largest cursor. So to conserve memory, it is best to use handles beginning with zero and working upward consecutively. Here P3 (&quot;examp&quot;) is the name of the table being opened, but this is unused, and only generated to make the code easier to read. This instruction pops the database number to use (0, the main database) from the top of the stack, so afterwards the stack is empty again.</source>
          <target state="translated">指令&lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt;在表&amp;ldquo; examp&amp;rdquo;上用句柄P1（在这种情况下为0）打开一个新的读/写游标，该表的根页为P2（在此数据库文件中为3）。游标句柄可以是任何非负整数。但是VDBE在数组中分配游标，该数组的大小比最大游标大一。因此，为了节省内存，最好使用从零开始并连续向上处理的句柄。这里的P3（&amp;ldquo;示例&amp;rdquo;）是要打开的表的名称，但是未使用，仅是为了使代码易于阅读而生成的。该指令从堆栈顶部弹出要使用的数据库编号（0，即主数据库），因此此后堆栈再次为空。</target>
        </trans-unit>
        <trans-unit id="98bb30ff1b874474319c63eb890c40ec0fb09de2" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#PutIntKey&quot;&gt;PutIntKey&lt;/a&gt; uses the top 2 stack entries to write an entry into the table pointed to by cursor P1. A new entry is created if it doesn't already exist or the data for an existing entry is overwritten. The record data is the top stack entry, and the key is the next entry down. The stack is popped twice by this instruction. Because operand P2 is 1 the row change count is incremented and the rowid is stored for subsequent return by the sqlite_last_insert_rowid() function. If P2 is 0 the row change count is unmodified. This instruction is where the insert actually occurs.</source>
          <target state="translated">指令&lt;a href=&quot;opcode#PutIntKey&quot;&gt;PutIntKey&lt;/a&gt;使用前2个堆栈条目将条目写入光标P1指向的表中。如果尚不存在新条目或现有条目的数据被覆盖，则会创建一个新条目。记录数据是顶部堆栈条目，而键是下一个条目。该指令将堆栈弹出两次。因为操作数P2为1，所以行更改计数增加，并且存储rowid以供sqlite_last_insert_rowid（）函数随后返回。如果P2为0，则行更改计数不变。该指令是插入实际发生的位置。</target>
        </trans-unit>
        <trans-unit id="0b320ec6225176f371f5c1f951d40976365b4443" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; pushes its P3 operand onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">指令&lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt;将其P3操作数压入堆栈。之后，堆栈如下所示：</target>
        </trans-unit>
        <trans-unit id="d914ce420de942b21ca6d5eb303d1b4bdd87f483" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt; begins a transaction. The transaction ends when a Commit or Rollback opcode is encountered. P1 is the index of the database file on which the transaction is started. Index 0 is the main database file. A write lock is obtained on the database file when a transaction is started. No other process can read or write the file while the transaction is underway. Starting a transaction also creates a rollback journal. A transaction must be started before any changes can be made to the database.</source>
          <target state="translated">指令&lt;a href=&quot;opcode#Transaction&quot;&gt;交易&lt;/a&gt;开始交易。遇到Commit或Rollback操作码时，事务结束。 P1是在其上启动事务的数据库文件的索引。索引0是主数据库文件。启动事务时，将在数据库文件上获得写锁定。事务进行期间，没有其他进程可以读取或写入文件。启动事务还会创建回滚日志。必须先启动事务，然后才能对数据库进行任何更改。</target>
        </trans-unit>
        <trans-unit id="766fac627c726045a9f4c4dcb9828d544fcadbb2" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#VerifyCookie&quot;&gt;VerifyCookie&lt;/a&gt; checks cookie 0 (the database schema version) to make sure it is equal to P2 (the value obtained when the database schema was last read). P1 is the database number (0 for the main database). This is done to make sure the database schema hasn't been changed by another thread, in which case it has to be reread.</source>
          <target state="translated">指令&lt;a href=&quot;opcode#VerifyCookie&quot;&gt;VerifyCookie会&lt;/a&gt;检查cookie 0（数据库模式版本）以确保它等于P2（上一次读取数据库模式时获得的值）。 P1是数据库编号（主数据库为0）。这样做是为了确保数据库架构没有被另一个线程更改，在这种情况下，必须重新读取它。</target>
        </trans-unit>
        <trans-unit id="1541b9a811a194a4f9e80a336055e479ef3f480e" translate="yes" xml:space="preserve">
          <source>The instruction at address 9 implements the branching part of the loop. Together with the Rewind at address 5 it forms the loop logic. This is a key concept that you should pay close attention to. The &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; instruction advances the cursor P1 to the next record. If the cursor advance was successful, then jump immediately to P2 (6, the beginning of the loop body). If the cursor was at the end, then fall through to the following instruction, which ends the loop.</source>
          <target state="translated">地址9处的指令实现了循环的分支部分。它与地址5的倒带一起形成循环逻辑。这是您应该密切注意的关键概念。在&lt;a href=&quot;opcode#Next&quot;&gt;下一步&lt;/a&gt;指令游标前进P1到下一个记录。如果光标前进成功，则立即跳转到P2（循环主体的开始6）。如果光标位于末尾，则进入以下指令，从而结束循环。</target>
        </trans-unit>
        <trans-unit id="14da6ae11560ca2b2c31ae75e094431766a4621e" translate="yes" xml:space="preserve">
          <source>The instruction at the address in register P1 is a &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt;. &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; to the P2 parameter of that &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt;. After the jump, register P1 becomes undefined.</source>
          <target state="translated">寄存器P1中地址处的指令为&lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt;。&lt;a href=&quot;opcode#Jump&quot;&gt;跳至&lt;/a&gt;该&lt;a href=&quot;opcode#Yield&quot;&gt;收益率&lt;/a&gt;的P2参数。跳转后，寄存器P1变为未定义。</target>
        </trans-unit>
        <trans-unit id="cd201e480371afb73e8686f10704843996fccd91" translate="yes" xml:space="preserve">
          <source>The instructions 6 through 8 form the body of the loop that will execute once for each record in the database file. The &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; instructions at addresses 6 and 7 each take the P2-th column from the P1-th cursor and push it onto the stack. In this example, the first Column instruction is pushing the value for the column &quot;one&quot; onto the stack and the second Column instruction is pushing the value for column &quot;two&quot;. The &lt;a href=&quot;opcode#Callback&quot;&gt;Callback&lt;/a&gt; instruction at address 8 invokes the callback() function. The P1 operand to Callback becomes the value for &lt;b&gt;nColumn&lt;/b&gt;. The Callback instruction pops P1 values from the stack and uses them to fill the &lt;b&gt;azData[]&lt;/b&gt; array.</source>
          <target state="translated">指令6至8构成循环的主体，该循环将对数据库文件中的每个记录执行一次。地址6和7 的&lt;a href=&quot;opcode#Column&quot;&gt;列&lt;/a&gt;指令分别从第P1个游标获取第P2列，并将其压入堆栈。在此示例中，第一个Column指令将列&amp;ldquo; one&amp;rdquo;的值压入堆栈，第二个Column指令将列&amp;ldquo; two&amp;rdquo;的值压入堆栈。地址8 的&lt;a href=&quot;opcode#Callback&quot;&gt;Callback&lt;/a&gt;指令调用callback（）函数。回调的P1操作数成为&lt;b&gt;nColumn&lt;/b&gt;的值。回调指令从堆栈中弹出P1值，并使用它们填充&lt;b&gt;azData []&lt;/b&gt;数组。</target>
        </trans-unit>
        <trans-unit id="c46964020db9e221e22ce0203153f52f7c4afbe0" translate="yes" xml:space="preserve">
          <source>The integer values returned by two invocations of &quot;PRAGMA data_version&quot; from the same connection will be different if changes were committed to the database by any other connection in the interim. The &quot;PRAGMA data_version&quot; value is unchanged for commits made on the same database connection. The behavior of &quot;PRAGMA data_version&quot; is the same for all database connections, including database connections in separate processes and &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; database connections.</source>
          <target state="translated">如果在此期间任何其他连接将更改提交给数据库，则从同一连接两次调用&amp;ldquo; PRAGMA data_version&amp;rdquo;返回的整数值将有所不同。对于在同一数据库连接上进行的提交，&amp;ldquo; PRAGMA data_version&amp;rdquo;值不变。所有数据库连接（包括独立进程中的数据库连接和&lt;a href=&quot;sharedcache&quot;&gt;共享缓存&lt;/a&gt;数据库连接）的&amp;ldquo; PRAGMA data_version&amp;rdquo;行为都是相同的。</target>
        </trans-unit>
        <trans-unit id="4e05f2b57d17a355c0ea1387908101e6bd52b31e" translate="yes" xml:space="preserve">
          <source>The integer values to xLock() and xUnlock() are one of</source>
          <target state="translated">xLock()和xUnlock()的整数值是其中之一。</target>
        </trans-unit>
        <trans-unit id="3a9652af526f0c1e8a87ab92c4d5d7f777a76ac5" translate="yes" xml:space="preserve">
          <source>The integrity-check command is invoked by inserting the text value 'integrity-check' into the special column with the same name as the FTS5 table. For example:</source>
          <target state="translated">通过在与FTS5表同名的特殊列中插入文本值 &quot;诚信检查 &quot;来调用诚信检查命令。例如:</target>
        </trans-unit>
        <trans-unit id="aa2dd68a608108fab7fa4442484da9ffd1d6fcde" translate="yes" xml:space="preserve">
          <source>The integrity-check command is invoked by inserting the text value 'integrity-check' into the special column with the same name as the FTS5 table. If a value is supplied for the &quot;rank&quot; column, it must be either 0 or 1. For example:</source>
          <target state="translated">通过在与FTS5表同名的特殊列中插入文本值 &quot;诚信检查 &quot;来调用诚信检查命令。如果为 &quot;等级 &quot;列提供了一个值,它必须是0或1。例如:&quot;等级 &quot;栏的值必须是0或1。</target>
        </trans-unit>
        <trans-unit id="8b9cbbc162055ec87304da9b44deb92f428d9750" translate="yes" xml:space="preserve">
          <source>The intended use of this pragma is only for testing and validation of SQLite. This pragma is subject to change without notice and is not recommended for use by application programs.</source>
          <target state="translated">这个pragma的预期用途只是为了测试和验证SQLite。这个pragma可能会在没有通知的情况下发生变化,不建议应用程序使用。</target>
        </trans-unit>
        <trans-unit id="ff65b14ad46243e5d5f2ba9708d0bfaa67d238c4" translate="yes" xml:space="preserve">
          <source>The intent of the developers is to support SQLite through the year 2050.</source>
          <target state="translated">开发者的意图是支持SQLite到2050年。</target>
        </trans-unit>
        <trans-unit id="b8c5c15fb8411770e1f2302c0a93c745cb58106c" translate="yes" xml:space="preserve">
          <source>The intent of these enhancements to the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; and &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; commands is to ensure that they cannot be used to create a database that contains foreign key violations, at least while foreign key constraints are enabled. There is one exception to this rule though. If a parent key is not subject to a PRIMARY KEY or UNIQUE constraint created as part of the parent table definition, but is subject to a UNIQUE constraint by virtue of an index created using the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; command, then the child table may be populated without causing a &quot;foreign key mismatch&quot; error. If the UNIQUE index is dropped from the database schema, then the parent table itself is dropped, no error will be reported. However the database may be left in a state where the child table of the foreign key constraint contains rows that do not refer to any parent table row. This case can be avoided if all parent keys in the database schema are constrained by PRIMARY KEY or UNIQUE constraints added as part of the parent table definition, not by external UNIQUE indexes.</source>
          <target state="translated">对&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;和&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;命令进行这些增强的目的是确保至少在启用外键约束的情况下，不能将它们用于创建包含外键违规的数据库。但是，此规则有一个例外。如果父键不受作为父表定义一部分创建的PRIMARY KEY或UNIQUE约束的约束，但由于使用&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;创建的索引而受UNIQUE约束的约束命令，然后可以填充子表而不会引起&amp;ldquo;外键不匹配&amp;rdquo;错误。如果从数据库架构中删除了UNIQUE索引，那么父表本身也将被删除，则不会报告任何错误。但是，数据库可能处于外键约束的子表包含不引用任何父表行的行的状态。如果数据库架构中的所有父键都由作为父表定义的一部分添加的PRIMARY KEY或UNIQUE约束而不是由外部UNIQUE索引约束，则可以避免这种情况。</target>
        </trans-unit>
        <trans-unit id="f25fb84e751737880254b9bbae4d5bcd681d4573" translate="yes" xml:space="preserve">
          <source>The interface between the VDBE and B-Tree layer is enhanced such that the VDBE provides hints to the B-Tree layer letting the B-Tree layer know when it is safe to use hashing instead of B-Trees for transient tables.</source>
          <target state="translated">VDBE和B-Tree层之间的接口得到了增强,VDBE为B-Tree层提供了提示,让B-Tree层知道什么时候使用哈希而不是B-Tree来处理瞬时表是安全的。</target>
        </trans-unit>
        <trans-unit id="8f6df7d6e95fb6e2e2d0cc834a6496c76dd46264" translate="yes" xml:space="preserve">
          <source>The interface to the B-tree subsystem and the rest of the SQLite library is defined by the header file &lt;a href=&quot;https://sqlite.org/src/file/src/btree.h&quot;&gt;btree.h&lt;/a&gt;.</source>
          <target state="translated">B-tree子系统和其余SQLite库的接口&lt;a href=&quot;https://sqlite.org/src/file/src/btree.h&quot;&gt;由头&lt;/a&gt;文件btree.h定义。</target>
        </trans-unit>
        <trans-unit id="b91796ad2d511be2d8979f83ba1c6fb0431a4019" translate="yes" xml:space="preserve">
          <source>The interface to the SQLite library consists of single tcl command named &lt;b&gt;sqlite3&lt;/b&gt; Because there is only this one command, the interface is not placed in a separate namespace.</source>
          <target state="translated">SQLite库的接口由单个名为&lt;b&gt;sqlite3的&lt;/b&gt; tcl命令组成。由于只有一个命令，因此该接口不会放置在单独的命名空间中。</target>
        </trans-unit>
        <trans-unit id="3c849c0d323b0ad6135a0bb1621f8f7a986a9fa1" translate="yes" xml:space="preserve">
          <source>The interface to the SQLite library consists of three core functions, one opaque data structure, and some constants used as return values. The core interface is as follows:</source>
          <target state="translated">SQLite库的接口由三个核心函数、一个不透明的数据结构和一些用作返回值的常量组成。核心接口如下。</target>
        </trans-unit>
        <trans-unit id="da5910db62046423c913e2518dadca7a36c2bb7d" translate="yes" xml:space="preserve">
          <source>The interface used by the implementation of the aforementioned functions to retrieve the collation sequence set by this opcode is not available publicly. Only built-in functions have access to this feature.</source>
          <target state="translated">上述函数的实现用来检索该操作码设置的整理序列的接口是不公开的。只有内置的函数可以使用这个功能。</target>
        </trans-unit>
        <trans-unit id="1824212549f384e7aed12eb3886c9cf696af6dde" translate="yes" xml:space="preserve">
          <source>The interfaces necessary to construct a function that is sometimes deterministic and sometimes non-deterministic depending on their inputs, such as the built-in date/time functions, are not published. Generic &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; must be always deterministic or always non-deterministic.</source>
          <target state="translated">未发布构造有时取决于其输入的确定性和有时不确定性的功能所必需的接口，例如内置的日期/时间函数。通用的&lt;a href=&quot;appfunc&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;必须始终是确定性的或始终是不确定性的。</target>
        </trans-unit>
        <trans-unit id="82c461e3315f13aa8457935ffce58f8ac7ef7cd3" translate="yes" xml:space="preserve">
          <source>The interfaces necessary to construct a function that is sometimes deterministic and sometimes non-deterministic depending on their inputs, such as the built-in date/time functions, are not published. Generic &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; must be always deterministic or always non-deterministic.</source>
          <target state="translated">未发布构造有时取决于其输入的确定性和有时不确定性的功能所必需的接口，例如内置的日期/时间函数。通用的&lt;a href=&quot;c3ref/create_function&quot;&gt;应用程序定义的SQL函数&lt;/a&gt;必须始终是确定性的或始终是不确定性的。</target>
        </trans-unit>
        <trans-unit id="15015bc60e3376a39ca9d7ebc27d602beffae1d0" translate="yes" xml:space="preserve">
          <source>The internal Mem object stores the value for a single register. The abstract &lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt; object that is exposed in the API is really just a Mem object or register.</source>
          <target state="translated">内部Mem对象存储单个寄存器的值。API中公开的抽象&lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt;对象实际上只是一个Mem对象或寄存器。</target>
        </trans-unit>
        <trans-unit id="e1059fa5a511cb460ad6acfc6dbdaaa7898a9f5d" translate="yes" xml:space="preserve">
          <source>The internal organization of the SQLite library can be viewed as the stack of modules shown to the right. The Tokenizer, Parser, and Code Generator components are used to process SQL statements and convert them into executable programs in a virtual machine language or byte code. Roughly speaking, these top three layers implement &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. The byte code generated by the top three layers is a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt;. The Virtual Machine module is responsible for running the SQL statement byte code. The B-Tree module organizes a database file into multiple key/value stores with ordered keys and logarithmic performance. The Pager module is responsible for loading pages of the database file into memory, for implementing and controlling transactions, and for creating and maintaining the journal files that prevent database corruption following a crash or power failure. The OS Interface is a thin abstraction that provides a common set of routines for adapting SQLite to run on different operating systems. Roughly speaking, the bottom four layers implement &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">SQLite库的内部组织可以视为如右图所示的模块堆栈。令牌生成器，解析器和代码生成器组件用于处理SQL语句，并将其转换为虚拟机语言或字节码的可执行程序。粗略地说，这三层实现了&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;。前三层生成的字节码是&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;。虚拟机模块负责运行SQL语句字节代码。B-Tree模块将数据库文件组织到具有有序键和对数性能的多个键/值存储中。Pager模块负责将数据库文件的页面加载到内存中，以实现和控制事务，并创建和维护日记文件，以防止崩溃或电源故障后数据库损坏。OS Interface是一个瘦的抽象，它提供了一套通用的例程，以使SQLite适应在不同的操作系统上运行。粗略地讲，最下面的四层实现&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b82fe06906efdf8da65bc9a3b09aabf0c14e629e" translate="yes" xml:space="preserve">
          <source>The internet is an increasingly hostile place. These day, developers should assume that attackers will find a way to execute arbitrary SQL in an application. Applications should be designed to prevent the execution of arbitrary SQL from escalating into a more severe exploit.</source>
          <target state="translated">互联网是一个越来越敌对的地方。如今,开发人员应该假设攻击者会找到一种方法在应用程序中执行任意SQL。应用程序的设计应该防止任意SQL的执行升级为更严重的利用。</target>
        </trans-unit>
        <trans-unit id="541368df6be3b3211d485998b29f10dd5bcba535" translate="yes" xml:space="preserve">
          <source>The interpretation of the final column, if it is present, is &lt;a href=&quot;swarmvtab#component_table_context_values&quot;&gt;described here&lt;/a&gt;.</source>
          <target state="translated">如果存在最后一栏，则&lt;a href=&quot;swarmvtab#component_table_context_values&quot;&gt;在此处进行说明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ecf9411adae8ae3787bf4274e751f3717d6110f0" translate="yes" xml:space="preserve">
          <source>The ioctl on Mac OS X to control syncing to disk is F_FULLFSYNC, not F_FULLSYNC. The previous release had it wrong.</source>
          <target state="translated">Mac OS X 上控制同步到磁盘的 ioctl 是 F_FULLFSYNC,而不是 F_FULLSYNC。以前的版本是错的。</target>
        </trans-unit>
        <trans-unit id="d9c0a5f06c6830c793bad013d5441e96d45f8af0" translate="yes" xml:space="preserve">
          <source>The job of the eval method is to execute the SQL statement or statements given in the second argument. For example, to create a new table in a database, you can do this:</source>
          <target state="translated">eval方法的工作是执行第二个参数中给出的SQL语句或语句。例如,要在数据库中创建一个新表,可以这样做。</target>
        </trans-unit>
        <trans-unit id="ce55e90a07de980cc86c5f2dfac419a865729e47" translate="yes" xml:space="preserve">
          <source>The job of this method is to construct the new virtual table object (an &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object) and return a pointer to it in *ppVTab.</source>
          <target state="translated">此方法的工作是构造新的虚拟表对象（&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;对象），并在* ppVTab中返回指向它的指针。</target>
        </trans-unit>
        <trans-unit id="82b29f2835b0336ce594d7095e779f9ce1307885" translate="yes" xml:space="preserve">
          <source>The journal header is non-zero and well-formed, and</source>
          <target state="translated">日志标头是非零的,而且格式良好,而且。</target>
        </trans-unit>
        <trans-unit id="3978774f2c0624ee0736d9f40af64bca3b94a2e0" translate="yes" xml:space="preserve">
          <source>The journal tests are an additional double-check over and above the crash tests to make sure that SQLite transactions will be atomic across system crashes and power failures.</source>
          <target state="translated">日志测试是在崩溃测试之上的额外双重检查,以确保SQLite事务在系统崩溃和电源故障时是原子的。</target>
        </trans-unit>
        <trans-unit id="eadea62ca220c75cf3d8b7ee7d22ba8de7aa3934" translate="yes" xml:space="preserve">
          <source>The journal_mode pragma returns a string which is the new journal mode. On success, the pragma will return the string &quot;&lt;code&gt;wal&lt;/code&gt;&quot;. If the conversion to WAL could not be completed (for example, if the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; does not support the necessary shared-memory primitives) then the journaling mode will be unchanged and the string returned from the primitive will be the prior journaling mode (for example &quot;&lt;code&gt;delete&lt;/code&gt;&quot;).</source>
          <target state="translated">journal_mode编译指示返回一个字符串，它是新的日志模式。成功时，编译指示将返回字符串&amp;ldquo; &lt;code&gt;wal&lt;/code&gt; &amp;rdquo;。如果无法完成向WAL的转换（例如，如果&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;不支持必要的共享内存原语），则日记记录模式将保持不变，并且从原语返回的字符串将是先前的日记记录模式（例如&amp;ldquo; &lt;code&gt;delete&lt;/code&gt; &amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="cf12bc7373958f09d761ed0f9bf5075e87444a0e" translate="yes" xml:space="preserve">
          <source>The journal_size_limit pragma may be used to limit the size of rollback-journal and WAL files left in the file-system after transactions or checkpoints. Each time a transaction is committed or a WAL file resets, SQLite compares the size of the rollback journal file or WAL file left in the file-system to the size limit set by this pragma and if the journal or WAL file is larger it is truncated to the limit.</source>
          <target state="translated">journal_size_limit pragma可以用来限制事务或检查点之后留在文件系统中的回滚日志文件和WAL文件的大小。每当一个事务被提交或WAL文件被重置时,SQLite会将留在文件系统中的回滚日志文件或WAL文件的大小与这个pragma设置的大小限制进行比较,如果日志或WAL文件的大小较大,则会被截断到该限制。</target>
        </trans-unit>
        <trans-unit id="e4ee7815366ce998637e6c73fab93997f9ad3bf9" translate="yes" xml:space="preserve">
          <source>The json(X) function verifies that its argument X is a valid JSON string and returns a minified version of that JSON string (with all unnecessary whitespace removed). If X is not a well-formed JSON string, then this routine throws an error.</source>
          <target state="translated">json(X)函数验证其参数X是一个有效的JSON字符串,并返回该JSON字符串的最小化版本(去掉所有不必要的空格)。如果X不是一个格式良好的JSON字符串,那么这个例程会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="b38a8f8844d02f721e88e8305af9dc835b4312f1" translate="yes" xml:space="preserve">
          <source>The json1 extension (currently) stores JSON as ordinary text.</source>
          <target state="translated">json1扩展(目前)以普通文本的形式存储JSON。</target>
        </trans-unit>
        <trans-unit id="600cff3bfb9b2a0fb597c7fc0f7fa3f65076ca7b" translate="yes" xml:space="preserve">
          <source>The json1 extension does not (currently) support a binary encoding of JSON. Experiments have been unable to find a binary encoding that is significantly smaller or faster than a plain text encoding. (The present implementation parses JSON text at over 1 GB/s.) All json1 functions currently throw an error if any of their arguments are BLOBs because BLOBs are reserved for a future enhancement in which BLOBs will store the binary encoding for JSON.</source>
          <target state="translated">json1扩展(目前)不支持JSON的二进制编码。实验无法找到比纯文本编码更小更快的二进制编码。(目前的实现以超过1 GB/s的速度解析JSON文本。)目前所有的json1函数如果其任何参数是BLOBs,都会抛出一个错误,因为BLOBs是为将来的增强版保留的,其中BLOBs将存储JSON的二进制编码。</target>
        </trans-unit>
        <trans-unit id="50447979a47d38485f569438ae4849e4fe11a47d" translate="yes" xml:space="preserve">
          <source>The json1 extension uses the &lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; interfaces that were introduced with SQLite version 3.9.0 (2015-10-14) The json1 extension will not work in earlier versions of SQLite.</source>
          <target state="translated">json1扩展使用SQLite版本3.9.0（2015-10-14）引入的&lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype（）&lt;/a&gt;和&lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype（）&lt;/a&gt;接口json1扩展在早期版本的SQLite中将不起作用。</target>
        </trans-unit>
        <trans-unit id="96336d37aaa994d4a790a5daf6a1eabf939e9f47" translate="yes" xml:space="preserve">
          <source>The json1 source code is included with the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, though it is disabled by default. Add the &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; compile-time option to enable the json1 extension that is built into the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. The standard makefiles include -DSQLITE_ENABLE_JSON1 when building the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; and some of the test utilities so this extension is normally available in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">json1源代码包含在SQLite &lt;a href=&quot;amalgamation&quot;&gt;合并中&lt;/a&gt;，但默认情况下已禁用。添加&lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt;编译时选项，以启用内置于&lt;a href=&quot;amalgamation&quot;&gt;amalgamation中&lt;/a&gt;的json1扩展。构建&lt;a href=&quot;cli&quot;&gt;命令行外壳&lt;/a&gt;程序时，标准的makefile包括-DSQLITE_ENABLE_JSON1 以及一些测试实用程序，因此此扩展名通常在&lt;a href=&quot;cli&quot;&gt;命令行外壳&lt;/a&gt;程序中可用。</target>
        </trans-unit>
        <trans-unit id="bb08cc12ccf8da2d3e2af52ece257a447253b7e8" translate="yes" xml:space="preserve">
          <source>The json_array() SQL function accepts zero or more arguments and returns a well-formed JSON array that is composed from those arguments. If any argument to json_array() is a BLOB then an error is thrown.</source>
          <target state="translated">json_array()SQL函数接受0个或多个参数,并返回一个由这些参数组成的格式良好的JSON数组。如果json_array()的任何参数是一个BLOB,那么就会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="9521182f315a0d302eb912198a80302f20c295c7" translate="yes" xml:space="preserve">
          <source>The json_array_length(X) function returns the number of elements in the JSON array X, or 0 if X is some kind of JSON value other than an array. The json_array_length(X,P) locates the array at path P within X and returns the length of that array, or 0 if path P locates an element or X other than a JSON array, and NULL if path P does not locate any element of X. Errors are thrown if either X is not well-formed JSON or if P is not a well-formed path.</source>
          <target state="translated">json_array_length(X)函数返回JSON数组X中的元素数,如果X是数组以外的JSON值,则返回0。json_array_length(X,P)函数定位X中的路径P处的数组,并返回数组的长度,如果路径P定位到了JSON数组以外的元素或X,则返回0;如果路径P没有定位到X中的任何元素,则返回NULL。如果X不是格式良好的JSON,或者P不是格式良好的路径,则会产生错误。</target>
        </trans-unit>
        <trans-unit id="a38155ffebbf6577ab0909bd9445bf04a40481a5" translate="yes" xml:space="preserve">
          <source>The json_each(X) and json_tree(X) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; walk the JSON value provided as their first argument and return one row for each element. The json_each(X) function only walks the immediate children of the top-level array or object or or just the top-level element itself if the top-level element is a primitive value. The json_tree(X) function recursively walks through the JSON substructure starting with the top-level element.</source>
          <target state="translated">&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt; json_each（X）和json_tree（X）遍历作为其第一个参数提供的JSON值，并为每个元素返回一行。json_each（X）函数仅遍历顶级数组或对象的直接子级，或者如果顶级元素是原始值，则仅遍历顶级元素本身。json_tree（X）函数以递归的方式遍历从顶层元素开始的JSON子结构。</target>
        </trans-unit>
        <trans-unit id="41fff21b05289cb2b0be52b887077b0fcae3db31" translate="yes" xml:space="preserve">
          <source>The json_each(X,P) and json_tree(X,P) functions work just like their one-argument counterparts except that they treat the element identified by path P as the top-level element.</source>
          <target state="translated">json_each(X,P)和json_tree(X,P)函数的工作原理和它们的单参数对应函数一样,只是它们将路径P所标识的元素视为顶层元素。</target>
        </trans-unit>
        <trans-unit id="c2ff80179397d0e306699ce5e6f1d0c9aff0af74" translate="yes" xml:space="preserve">
          <source>The json_extract(X,P1,P2,...) extracts and returns one or more values from the well-formed JSON at X. If only a single path P1 is provided, then the SQL datatype of the result is NULL for a JSON null, INTEGER or REAL for a JSON numeric value, an INTEGER zero for a JSON false value, an INTEGER one for a JSON true value, the dequoted text for a JSON string value, and a text representation for JSON object and array values. If there are multiple path arguments (P1, P2, and so forth) then this routine returns SQLite text which is a well-formed JSON array holding the various values.</source>
          <target state="translated">json_extract(X,P1,P2,...)从X处格式良好的JSON中提取并返回一个或多个值。如果只提供了一个路径P1,那么结果的SQL数据类型为:JSON空值为NULL,JSON数值为INTEGER或REAL,JSON假值为INTEGER 0,JSON真值为INTEGER 1,JSON字符串值为去引号文本,JSON对象和数组值为文本表示。如果有多个路径参数(P1、P2等),那么这个例程就会返回SQLite文本,这个文本是一个格式良好的JSON数组,存放着各种值。</target>
        </trans-unit>
        <trans-unit id="0f1627c2753898c7b2ebba7d223fce4a18da0c11" translate="yes" xml:space="preserve">
          <source>The json_group_array(X) function is an &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate SQL function&lt;/a&gt; that returns a JSON array comprised of all X values in the aggregation. Similarly, the json_group_object(NAME,VALUE) function returns a JSON object comprised of all NAME/VALUE pairs in the aggregation.</source>
          <target state="translated">json_group_array（X）函数是一个&lt;a href=&quot;lang_aggfunc&quot;&gt;聚合SQL函数&lt;/a&gt;，该函数返回一个由聚合中所有X值组成的JSON数组。同样，json_group_object（NAME，VALUE）函数返回由聚合中的所有NAME / VALUE对组成的JSON对象。</target>
        </trans-unit>
        <trans-unit id="08b54ec339ea85bd242a6d5ab159f649d0636c35" translate="yes" xml:space="preserve">
          <source>The json_insert(), json_replace(), and json_set() functions always take an odd number of arguments. The first argument is always the original JSON to be edited. Subsequent arguments occur in pairs with the first element of each pair being a path and the second element being the value to insert or replace or set on that path.</source>
          <target state="translated">json_insert()、json_replace()和json_set()函数总是取奇数的参数。第一个参数总是要编辑的原始JSON。随后的参数成对出现,每个参数对的第一个元素是一个路径,第二个元素是要插入或替换或设置在该路径上的值。</target>
        </trans-unit>
        <trans-unit id="cc677da89c2d6a3534f49f58dca0325fe7275ac0" translate="yes" xml:space="preserve">
          <source>The json_insert(), json_replace, and json_set() functions all take a single JSON value as their first argument followed by zero or more pairs of path and value arguments, and return a new JSON string formed by updating the input JSON by the path/value pairs. The functions differ only in how they deal with creating new values and overwriting preexisting values.</source>
          <target state="translated">json_insert()、json_replace和json_set()函数都以一个JSON值作为它们的第一个参数,后面跟着零个或多个路径和值参数对,并返回一个新的JSON字符串,这个字符串是通过更新输入的JSON的路径/值对形成的。这些函数的不同之处仅在于它们如何处理创建新值和覆盖已有值。</target>
        </trans-unit>
        <trans-unit id="a89fe09131a222458243e59c86a47b9418f5cefc" translate="yes" xml:space="preserve">
          <source>The json_object() SQL function accepts zero or more pairs of arguments and returns a well-formed JSON object that is composed from those arguments. The first argument of each pair is the label and the second argument of each pair is the value. If any argument to json_object() is a BLOB then an error is thrown.</source>
          <target state="translated">json_object()SQL函数接受0个或多个参数对,并返回一个由这些参数组成的格式良好的JSON对象。每对参数的第一个参数是标签,第二个参数是值。如果json_object()的任何参数是一个BLOB,那么就会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="2288fffe16f420052bb17e5c8958c3ccdbc841f2" translate="yes" xml:space="preserve">
          <source>The json_object() function currently allows duplicate labels without complaint, though this might change in a future enhancement.</source>
          <target state="translated">json_object()函数目前允许重复的标签,不过这一点可能会在未来的改进中改变。</target>
        </trans-unit>
        <trans-unit id="5e496b884466eb1ac12c106e9502f3cd98163883" translate="yes" xml:space="preserve">
          <source>The json_patch(T,P) SQL function runs the &lt;a href=&quot;https://tools.ietf.org/html/rfc7396&quot;&gt;RFC-7396&lt;/a&gt; MergePatch algorithm to apply patch P against input T. The patched copy of T is returned.</source>
          <target state="translated">json_patch（T，P）SQL函数运行&lt;a href=&quot;https://tools.ietf.org/html/rfc7396&quot;&gt;RFC-7396&lt;/a&gt; MergePatch算法，将补丁P应用于输入T。返回T的补丁副本。</target>
        </trans-unit>
        <trans-unit id="d843d41461d41ce71296d2cc16a75e0d0ddb050b" translate="yes" xml:space="preserve">
          <source>The json_quote(X) function converts the SQL value X (a number or a string) into its corresponding JSON representation.</source>
          <target state="translated">json_quote(X)函数将SQL值X(一个数字或字符串)转换为相应的JSON表示。</target>
        </trans-unit>
        <trans-unit id="076810db69b99bc12f8c66592e6373c496370f8e" translate="yes" xml:space="preserve">
          <source>The json_remove() function throws an error if the first argument is not well-formed JSON or if any later argument is not a well-formed path, or if any argument is a BLOB.</source>
          <target state="translated">如果第一个参数不是格式良好的JSON,或者任何后面的参数不是格式良好的路径,或者任何参数是BLOB,那么json_remove()函数会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="70b06ba9150c7a013b0718a5467fee57d49bd476" translate="yes" xml:space="preserve">
          <source>The json_remove(X,P,...) function takes a single JSON value as its first argument followed by zero or more path arguments. The json_remove(X,P,...) function returns a copy of the X parameter with all the elements identified by path arguments removed. Paths that select elements not found in X are silently ignored.</source>
          <target state="translated">json_remove(X,P,...)函数的第一个参数是一个JSON值,后面是0个或多个路径参数。json_remove(X,P,...)函数返回一个X参数的副本,其中包含所有由路径参数标识的元素。选择X中没有的元素的路径会被默默忽略。</target>
        </trans-unit>
        <trans-unit id="07c228732927cc33b2fd2172e7d852ff75280285" translate="yes" xml:space="preserve">
          <source>The json_remove(X,P,...) function takes a single JSON value as its first argument followed by zero or more path arguments. The json_remove(X,P,...) function returns a new JSON value that is the X with all the elements identified by path arguments removed. Paths that select elements not found in X are silently ignored.</source>
          <target state="translated">json_remove(X,P,...)函数的第一个参数是一个JSON值,后面是0个或多个路径参数。json_remove(X,P,...)函数返回一个新的JSON值,这个新的JSON值就是X,它包含了路径参数所标识的所有元素。选择在X中没有找到的元素的路径会被默默忽略。</target>
        </trans-unit>
        <trans-unit id="dc2a43381f4cc4dcc4e70977bde02a9d9d1a46e8" translate="yes" xml:space="preserve">
          <source>The json_type() function throws an error if any of its arguments are not well-formed or is a BLOB.</source>
          <target state="translated">如果它的任何一个参数不是形式良好的或者是BLOB,json_type()函数会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="4607298214330613e115639247f1a2af460f4cfe" translate="yes" xml:space="preserve">
          <source>The json_type(X) function returns the &quot;type&quot; of the outermost element of X. The json_type(X,P) function returns the &quot;type&quot; of the element in X that is selected by path P. The &quot;type&quot; returned by json_type() is on of the following an SQL text values: 'null', 'true', 'false', 'integer', 'real', 'text', 'array', or 'object'. If the path P in json_type(X,P) selects an element that does not exist in X, then this function returns NULL.</source>
          <target state="translated">json_type(X)函数返回X中最外层元素的 &quot;类型&quot;。json_type(X,P)函数返回X中被路径P选中的元素的 &quot;类型&quot;。json_type()返回的 &quot;类型 &quot;是以下SQL文本值中的一种。'null'、'true'、'false'、'integer'、'real'、'text'、'array'或'object'。如果json_type(X,P)中的路径P选择了一个在X中不存在的元素,那么这个函数返回NULL。</target>
        </trans-unit>
        <trans-unit id="719a758ba2801754e03a7b8fe39124f85c9b0d1b" translate="yes" xml:space="preserve">
          <source>The json_type(X) function returns the &quot;type&quot; of the outermost element of X. The json_type(X,P) function returns the &quot;type&quot; of the element in X that is selected by path P. The &quot;type&quot; returned by json_type() is one of the following an SQL text values: 'null', 'true', 'false', 'integer', 'real', 'text', 'array', or 'object'. If the path P in json_type(X,P) selects an element that does not exist in X, then this function returns NULL.</source>
          <target state="translated">json_type(X)函数返回X中最外层元素的 &quot;类型&quot;。json_type(X,P)函数返回X中被路径P选中的元素的 &quot;类型&quot;。json_type()返回的 &quot;类型 &quot;是以下SQL文本值之一。'null'、'true'、'false'、'integer'、'real'、'text'、'array'或'object'。如果json_type(X,P)中的路径P选择了一个在X中不存在的元素,那么这个函数返回NULL。</target>
        </trans-unit>
        <trans-unit id="98bb00412965806c0f2fa0e24dcf65a44105fd64" translate="yes" xml:space="preserve">
          <source>The json_valid(X) function return 1 if the argument X is well-formed JSON and return 0 if the argument X is not well-formed JSON.</source>
          <target state="translated">json_valid(X)函数如果参数X是格式良好的JSON,则返回1,如果参数X不是格式良好的JSON,则返回0。</target>
        </trans-unit>
        <trans-unit id="b554cbe69a3700d4f56fb5609be0488decea2e7b" translate="yes" xml:space="preserve">
          <source>The key element of a</source>
          <target state="translated">的关键因素。</target>
        </trans-unit>
        <trans-unit id="1f79347fd256f18500712ca620e7ffb89d509d9e" translate="yes" xml:space="preserve">
          <source>The key point is that SQLite is very forgiving of the type of data that you put into the database. For example, if a column has a datatype of &quot;INTEGER&quot; and the application inserts a text string into that column, SQLite will first try to convert the text string into an integer, just like every other SQL database engine. Thus, if one inserts &lt;b&gt;'1234'&lt;/b&gt; into an INTEGER column, that value is converted into an integer 1234 and stored. But, if you insert a non-numeric string like &lt;b&gt;'wxyz'&lt;/b&gt; into an INTEGER column, unlike other SQL databases, SQLite does not throw an error. Instead, SQLite stores the actual string value in the column.</source>
          <target state="translated">关键是，SQLite非常宽容您放入数据库中的数据类型。例如，如果某列的数据类型为&amp;ldquo; INTEGER&amp;rdquo;，并且应用程序在该列中插入了文本字符串，则与其他所有SQL数据库引擎一样，SQLite将首先尝试将文本字符串转换为整数。因此，如果将&lt;b&gt;&amp;ldquo; 1234&amp;rdquo;&lt;/b&gt;插入到INTEGER列中，则该值将转换为整数1234并存储。但是，与其他SQL数据库不同，如果将像&lt;b&gt;'wxyz'&lt;/b&gt;这样的非数字字符串插入INTEGER列，则SQLite不会引发错误。相反，SQLite将实际的字符串值存储在该列中。</target>
        </trans-unit>
        <trans-unit id="3e290f56c0ef256cb5bbb18b2ba0fb09ea68db61" translate="yes" xml:space="preserve">
          <source>The key point is this: Building the CLI consists of compiling together two C-language files. The &lt;b&gt;shell.c&lt;/b&gt; file contains the definition of the entry point and the user input loop and the SQLite amalgamation &lt;b&gt;sqlite3.c&lt;/b&gt; contains the complete implementation of the SQLite library.</source>
          <target state="translated">关键是：构建CLI包括将两个C语言文件编译在一起。该&lt;b&gt;shell.c&lt;/b&gt;文件包含入口点的定义和用户输入回路和SQLite的融合&lt;b&gt;sqlite3.c&lt;/b&gt;包含了SQLite库的完整实现。</target>
        </trans-unit>
        <trans-unit id="bb2fbeab5253f75ff8183f69852d5cbb7ab2bba6" translate="yes" xml:space="preserve">
          <source>The key points of the previous example were the use of the Callback instruction to invoke the callback function, and the use of the Next instruction to implement a loop over all records of the database file. This example attempts to drive home those ideas by demonstrating a slightly more complex query that involves more columns of output, some of which are computed values, and a WHERE clause that limits which records actually make it to the callback function. Consider this query:</source>
          <target state="translated">上一个例子的关键点是使用Callback指令来调用回调函数,以及使用Next指令来实现对数据库文件所有记录的循环。这个例子试图通过演示一个略微复杂的查询来阐述这些观点,这个查询涉及更多的输出列,其中一些是计算值,还有一个WHERE子句来限制哪些记录实际进入回调函数。考虑一下这个查询。</target>
        </trans-unit>
        <trans-unit id="986f899677204f1290b417dd64fe3fcaa05f7c30" translate="yes" xml:space="preserve">
          <source>The keys used by each segment b-tree are terms (words). As well as the key, each segment b-tree entry has an associated &quot;doclist&quot; (document list). A doclist consists of zero or more entries, where each entry consists of:</source>
          <target state="translated">每个段b树使用的键是术语(词)。除了键,每个段b树条目还有一个相关的 &quot;doclist&quot;(文档列表)。doclist由0个或多个条目组成,其中每个条目包括:</target>
        </trans-unit>
        <trans-unit id="a93934848f28a5d1e280c92cac942b828e6dc7e9" translate="yes" xml:space="preserve">
          <source>The keyword &quot;INSERT&quot;, &quot;UPDATE&quot;, or &quot;DELETE&quot;, as appropriate</source>
          <target state="translated">关键字 &quot;INSERT&quot;、&quot;UPDATE &quot;或 &quot;DELETE&quot;,视情况而定。</target>
        </trans-unit>
        <trans-unit id="799f75f9fa5e2cb1d9335f9637de442233918b1a" translate="yes" xml:space="preserve">
          <source>The kvtest program is compiled and run on Android as follows. First install the Android SDK and NDK. Then prepare a script named &quot;android-gcc&quot; that looks approximately like this:</source>
          <target state="translated">kvtest程序在Android上编译运行的方法如下。首先安装Android SDK和NDK。然后准备一个名为 &quot;android-gcc &quot;的脚本,大致如下。</target>
        </trans-unit>
        <trans-unit id="a518e69633f247201841ea47eb51e547b9e7d52f" translate="yes" xml:space="preserve">
          <source>The label to the right of an AS in the column list of a SELECT can now be used as part of an expression in the WHERE, ORDER BY, GROUP BY, and/or HAVING clauses.</source>
          <target state="translated">现在,SELECT列列表中AS右边的标签可以作为WHERE、ORDER BY、GROUP BY和/或HAVING子句中表达式的一部分。</target>
        </trans-unit>
        <trans-unit id="5d78c31e6fd49e38e9a6929f67e573c2fcc27d5f" translate="yes" xml:space="preserve">
          <source>The language id for this entry.</source>
          <target state="translated">本条目的语言标识。</target>
        </trans-unit>
        <trans-unit id="e80fa2a23c99c4e0919bc332ef910ec1f3215c2c" translate="yes" xml:space="preserve">
          <source>The languageid option causes the FTS4 table to have an additional hidden integer column that identifies the language of the text contained in each row. The use of the languageid option allows the same FTS4 table to hold text in multiple languages or scripts, each with different tokenizer rules, and to query each language independently of the others.</source>
          <target state="translated">languageid 选项使 FTS4 表有一个额外的隐藏整数列,用于标识每行所含文本的语言。使用languageid选项可以让同一个FTS4表容纳多种语言或脚本的文本,每种语言或脚本都有不同的标记规则,并且可以独立查询每种语言。</target>
        </trans-unit>
        <trans-unit id="333c7dbdc428cf52a63d6a76d33660a2004630b2" translate="yes" xml:space="preserve">
          <source>The largest payload found anywhere in the current page or btree.</source>
          <target state="translated">在当前页面或btree中找到的最大有效载荷。</target>
        </trans-unit>
        <trans-unit id="3a93c8c9ebe55117d8275a20a3a64f1279cc0414" translate="yes" xml:space="preserve">
          <source>The largest possible setting for SQLITE_MAX_PAGE_COUNT is 2147483646. When used with the maximum page size of 65536, this gives a maximum SQLite database size of about 140 terabytes.</source>
          <target state="translated">SQLITE_MAX_PAGE_COUNT的最大可能设置是2147483646。当与最大页面大小65536一起使用时,这将使SQLite数据库的最大大小约为140TB。</target>
        </trans-unit>
        <trans-unit id="4e80216c90c51ba3170a6cfbdb6ff5453a279861" translate="yes" xml:space="preserve">
          <source>The largest possible setting for SQLITE_MAX_PAGE_COUNT is 4294967294. When used with the maximum page size of 65536, this gives a maximum SQLite database size of about 281 terabytes.</source>
          <target state="translated">SQLITE_MAX_PAGE_COUNT的最大可能设置是4294967294。当与最大页面大小65536一起使用时,这将使SQLite数据库的最大大小约为281TB。</target>
        </trans-unit>
        <trans-unit id="d0fabb1072d1e3ea604e33e251741f22426c0f61" translate="yes" xml:space="preserve">
          <source>The last (fourth) bullet above merits additional comment. When SQLite creates a journal file on Unix, it opens the directory that contains that file and calls fsync() on the directory, in an effort to push the directory information to disk. But suppose some other process is adding or removing unrelated files to the directory that contains the database and journal at the moment of a power failure. The supposedly unrelated actions of this other process might result in the journal file being dropped from the directory and moved into &quot;lost+found&quot;. This is an unlikely scenario, but it could happen. The best defenses are to use a journaling filesystem or to keep the database and journal in a directory by themselves.</source>
          <target state="translated">上面最后一个(第四个)项目值得补充评论。当SQLite在Unix上创建一个日志文件时,它会打开包含该文件的目录,并对该目录调用fsync(),努力将目录信息推送到磁盘上。但假设在断电的时刻,有其他进程在向包含数据库和日志的目录中添加或删除不相关的文件。这个其他进程的所谓不相关的行为可能会导致日志文件从目录中被删除,并移到 &quot;丢失+发现 &quot;中。这种情况不太可能,但有可能发生。最好的防御措施是使用日志文件系统,或者将数据库和日志单独放在一个目录中。</target>
        </trans-unit>
        <trans-unit id="0d792644cd574497ddbf62ba435f6dbc99253564" translate="yes" xml:space="preserve">
          <source>The last bullet above is illustrated by the following:</source>
          <target state="translated">上述最后一个项目的说明如下:</target>
        </trans-unit>
        <trans-unit id="6fcee6d642fa1ca93fa14337ac4410163d2a9df9" translate="yes" xml:space="preserve">
          <source>The last output mode is &quot;html&quot;. In this mode, sqlite3 writes the results of the query as an XHTML table. The beginning &amp;lt;TABLE&amp;gt; and the ending &amp;lt;/TABLE&amp;gt; are not written, but all of the intervening &amp;lt;TR&amp;gt;s, &amp;lt;TH&amp;gt;s, and &amp;lt;TD&amp;gt;s are. The html output mode is envisioned as being useful for CGI.</source>
          <target state="translated">最后的输出模式是&amp;ldquo; html&amp;rdquo;。在这种模式下，sqlite3将查询结果写入XHTML表。开头的&amp;lt;TABLE&amp;gt;和结尾的&amp;lt;/ TABLE&amp;gt;均未写入，但所有中间的&amp;lt;TR&amp;gt;，&amp;lt;TH&amp;gt;和&amp;lt;TD&amp;gt;均已写入。可以设想html输出模式对于CGI很有用。</target>
        </trans-unit>
        <trans-unit id="a123c1f8dadbf6bb9cc227ef0871a1fb2cbe0f9d" translate="yes" xml:space="preserve">
          <source>The last parameter to the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; routines is a pointer to a procedure used to dispose of the P pointer once SQLite has finished with it. This pointer can be NULL, in which case no destructor is called.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;和&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;例程的最后一个参数是指向SQLite完成处理P指针的过程的指针。该指针可以为NULL，在这种情况下，不会调用任何析构函数。</target>
        </trans-unit>
        <trans-unit id="d52a179000f827088051359c744fec0210401d8f" translate="yes" xml:space="preserve">
          <source>The last step in the commit process is to release the exclusive lock so that other processes can once again start accessing the database file.</source>
          <target state="translated">提交过程的最后一步是释放独占锁,以便其他进程可以再次开始访问数据库文件。</target>
        </trans-unit>
        <trans-unit id="56b9bbac0263da28aef9dee3010ecc1e8725f669" translate="yes" xml:space="preserve">
          <source>The last transaction started will be the first transaction committed or rolled back.</source>
          <target state="translated">最后启动的交易将是第一个提交或回滚的交易。</target>
        </trans-unit>
        <trans-unit id="c2015d5e4ba733546bdea54c6daefbab27ed0b3f" translate="yes" xml:space="preserve">
          <source>The last two allocations can be controlled and/or eliminated by configuring the &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;, and &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; appropriately, as described above. The storage space required for &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects depends to some extent on the length of the filename of the database file, but rarely exceeds 2KB on 32-bit systems. (More space is required on 64-bit systems due to the increased size of pointers.) Each parser object uses about 1.6KB of memory. Thus, elements 3 through 7 above can easily be controlled to keep the maximum memory allocation size below 2KB.</source>
          <target state="translated">如上所述，可以通过适当地配置页面&lt;a href=&quot;malloc#pagecache&quot;&gt;缓存内存分配器&lt;/a&gt;和&lt;a href=&quot;malloc#lookaside&quot;&gt;后备内存分配器&lt;/a&gt;来控制和/或消除最后两个分配。&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;对象所需的存储空间在某种程度上取决于数据库文件名的长度，但在32位系统上很少超过2KB。 （由于指针的增加，在64位系统上需要更多空间。）每个解析器对象使用大约1.6KB的内存。因此，可以容易地控制上述元件3至7以将最大存储器分配大小保持在2KB以下。</target>
        </trans-unit>
        <trans-unit id="dd770eea393f2ccabe1cb964e8f446d8577e90ba" translate="yes" xml:space="preserve">
          <source>The last two queries take the same amount of time, in our example. So which index, Idx1 or Idx2, will SQLite choose? If the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command has been run on the database, so that SQLite has had an opportunity to gather statistics about the available indices, then SQLite will know that the Idx1 index usually narrows the search down to a single item (our example of fruit='Orange' is the exception to this rule) whereas the Idx2 index will normally only narrow the search down to two rows. So, if all else is equal, SQLite will choose Idx1 with the hope of narrowing the search to as small a number of rows as possible. This choice is only possible because of the statistics provided by &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;. If &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has not been run then the choice of which index to use is arbitrary.</source>
          <target state="translated">在我们的示例中，最后两个查询花费相同的时间。那么，SQLite将选择哪个索引Idx1或Idx2？如果在数据库上运行了&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令，则SQLite有机会收集了有关可用索引的统计信息，那么SQLite将知道Idx1索引通常将搜索范围缩小到单个项目（我们的fruit ='示例）。橙色&amp;rdquo;是该规则的例外），而Idx2索引通常只会将搜索范围缩小到两行。因此，如果其他所有条件都相等，SQLite将选择Idx1，希望将搜索范围缩小到尽可能少的行。由于&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;提供的统计信息，因此只能进行此选择。如果&lt;a href=&quot;lang_analyze&quot;&gt;分析&lt;/a&gt; 尚未运行，则选择使用哪个索引是任意的。</target>
        </trans-unit>
        <trans-unit id="0271db818028a9ffb097a09e837d0647ab050705" translate="yes" xml:space="preserve">
          <source>The last_insert_rowid() function returns the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; of the last row insert from the database connection which invoked the function. The last_insert_rowid() SQL function is a wrapper around the &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; C/C++ interface function.</source>
          <target state="translated">last_insert_rowid（）函数从调用该函数的数据库连接返回最后一行插入的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;。last_insert_rowid（）SQL函数是&lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt; C / C ++接口函数的包装。</target>
        </trans-unit>
        <trans-unit id="dc54cc3b765595ad1e2bcb9ada53a0d0dfaa1af8" translate="yes" xml:space="preserve">
          <source>The latest checklists contain approximately 200 items that are individually verified for each release. Some checklist items only take a few seconds to verify and mark off. Others involve test suites that run for many hours.</source>
          <target state="translated">最新的核对表包含大约200个项目,这些项目是针对每个版本进行单独验证的。有些检查清单项目只需要几秒钟的时间来验证和标记。其他项目则涉及运行数小时的测试套件。</target>
        </trans-unit>
        <trans-unit id="972ae3a81fba75ac7b1cb927798468eb94557f5e" translate="yes" xml:space="preserve">
          <source>The latter query can not use the partial index because there might be rows in the table with b=456 and where c is NULL. But those rows would not be in the partial index.</source>
          <target state="translated">后一个查询不能使用部分索引,因为在表中可能有b=456的记录,并且c是NULL。但是这些记录不会出现在部分索引中。</target>
        </trans-unit>
        <trans-unit id="5d0da56ef4fd6dfbe12fe3015e9d0a6d277654f6" translate="yes" xml:space="preserve">
          <source>The leftmost column of the &quot;%_content&quot; table is an INTEGER PRIMARY KEY field named &quot;docid&quot;. Following this is one column for each column of the FTS virtual table as declared by the user, named by prepending the column name supplied by the user with &quot;c</source>
          <target state="translated">&quot;%_content &quot;表的最左边一列是一个名为 &quot;docid &quot;的INTEGER主键字段。在这之后是用户声明的FTS虚拟表的每一列,命名时在用户提供的列名前加上 &quot;c</target>
        </trans-unit>
        <trans-unit id="3fe10f10852f3ac1156d75127fc7c938a298af76" translate="yes" xml:space="preserve">
          <source>The legacy &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; compile-time option is now a no-op.</source>
          <target state="translated">现在，旧版&lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3的&lt;/a&gt;编译时选项为空操作。</target>
        </trans-unit>
        <trans-unit id="19d5e9050bddb7e40ed3e17c750502a0acf23cf7" translate="yes" xml:space="preserve">
          <source>The legacy alter table behavior can also be toggled on and off using the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyaltertable&quot;&gt;SQLITE_DBCONFIG_LEGACY_ALTER_TABLE&lt;/a&gt; option to the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface.</source>
          <target state="translated">也可以使用&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;接口的&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyaltertable&quot;&gt;SQLITE_DBCONFIG_LEGACY_ALTER_TABLE&lt;/a&gt;选项来打开和关闭旧式alter table行为。</target>
        </trans-unit>
        <trans-unit id="41fd664aa5a45cba5ac773955a3426725e8decb9" translate="yes" xml:space="preserve">
          <source>The legacy alter table behavior is a per-connection setting. Turning this features on or off affects all attached database files within the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. The setting does not persist. Changing this setting in one connection does not affect any other connections.</source>
          <target state="translated">旧版alter table行为是每个连接的设置。启用或禁用此功能会影响&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接中&lt;/a&gt;所有附加的数据库文件。设置不会持续。在一个连接中更改此设置不会影响任何其他连接。</target>
        </trans-unit>
        <trans-unit id="e0281c5597d6458d92c064f8c4ce4817fe25c10e" translate="yes" xml:space="preserve">
          <source>The legacy xGeom callback is invoked with four arguments. The first argument is a pointer to an sqlite3_rtree_geometry structure which provides information about how the SQL function was invoked. The second argument is the number of coordinates in each r-tree entry, and is always the same for any given R*Tree. The number of coordinates is 2 for a 1-dimensional R*Tree, 4 for a 2-dimensional R*Tree, 6 for a 3-dimensional R*Tree, and so forth. The third argument, aCoord[], is an array of nCoord coordinates that defines a bounding box to be tested. The last argument is a pointer into which the callback result should be written. The result is zero if the bounding-box defined by aCoord[] is completely outside the region defined by the xGeom callback and the result is non-zero if the bounding-box is inside or overlaps with the xGeom region. The xGeom callback should normally return SQLITE_OK. If xGeom returns anything other than SQLITE_OK, then the r-tree query will abort with an error.</source>
          <target state="translated">传统的xGeom回调有四个参数。第一个参数是指向 sqlite3_rtree_geometry 结构的指针,它提供了关于 SQL 函数如何被调用的信息。第二个参数是每个r-tree条目中的坐标数,对于任何给定的R*Tree来说,坐标数总是相同的。一维R*Tree的坐标数为2,二维R*Tree为4,三维R*Tree为6,以此类推。第三个参数aCoord[]是一个nCoord坐标数组,定义了一个要测试的边界框。最后一个参数是一个指针,回调结果应该写入其中。如果aCoord[]定义的边界框完全在xGeom回调定义的区域之外,则结果为零;如果边界框在xGeom区域内或与xGeom区域重合,则结果为非零。xGeom回调通常应该返回SQLITE_OK。如果xGeom返回的不是SQLITE_OK,那么r-tree查询将以错误的方式中止。</target>
        </trans-unit>
        <trans-unit id="c26ac59b1bddfababdeff98e88ee3a4d181edb8a" translate="yes" xml:space="preserve">
          <source>The legacy_file_format pragma is initialized to OFF when an existing database in the newer file format is first opened.</source>
          <target state="translated">当第一次打开一个较新文件格式的现有数据库时,legacy_file_format pragma被初始化为OFF。</target>
        </trans-unit>
        <trans-unit id="5c416af28ee6cf9f448dc251869a118022ef5870" translate="yes" xml:space="preserve">
          <source>The length of a function name may not exceed 255 characters. Any attempt to create a function whose name exceeds 255 characters in length will result in an error.</source>
          <target state="translated">一个函数名称的长度不能超过255个字符。任何试图创建一个名称长度超过255个字符的函数都会导致错误。</target>
        </trans-unit>
        <trans-unit id="64a58fb27f585f3af736420c55a5c7aba354a480" translate="yes" xml:space="preserve">
          <source>The length of the argument value can be specified by one or more letters that occur just prior to the substitution type letter. In SQLite, the length only matter for integer types. The length is ignored for the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; which always uses 64-bit values. The following table shows the length specifiers allowed by SQLite:</source>
          <target state="translated">参数值的长度可以由替换类型字母之前的一个或多个字母指定。在SQLite中，长度仅与整数类型有关。对于始终使用64位值的&lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf（）SQL函数&lt;/a&gt;，将忽略该长度。下表显示了SQLite允许的长度说明符：</target>
        </trans-unit>
        <trans-unit id="835ff0a5a3c1f19c6461eba222151b4907f96047" translate="yes" xml:space="preserve">
          <source>The letter &quot;j&quot; pronounced like &quot;h&quot; in Spanish: LaJolla</source>
          <target state="translated">字母 &quot;j &quot;在西班牙语中发音像 &quot;h&quot;。LaJolla</target>
        </trans-unit>
        <trans-unit id="ee9eb5ebb3823c5e0db14477052af2948a8b37ee" translate="yes" xml:space="preserve">
          <source>The library now assumes data is stored as UTF-8 if the --enable-utf8 option is given to configure. The default behavior is to assume iso8859-x, as it has always done. This only makes a difference for LIKE and GLOB operators and the LENGTH and SUBSTR functions.</source>
          <target state="translated">如果给定了 --enable-utf8 选项来配置,该库现在假定数据以 UTF-8 存储。默认的行为是假设为iso8859-x,因为它一直都是这样做的。这只对 LIKE 和 GLOB 操作符以及 LENGTH 和 SUBSTR 函数有所区别。</target>
        </trans-unit>
        <trans-unit id="2b11a2ab2af2c4ff66c5a4f077ed6909c7421f85" translate="yes" xml:space="preserve">
          <source>The life-cycle of a prepared statement object usually goes like this:</source>
          <target state="translated">一个准备好的报表对象的生命周期通常是这样的。</target>
        </trans-unit>
        <trans-unit id="610e163977a4d438d498cc7745085654d18422e2" translate="yes" xml:space="preserve">
          <source>The lifecycle of an sqlite3_str object is as follows:</source>
          <target state="translated">sqlite3_str对象的生命周期如下。</target>
        </trans-unit>
        <trans-unit id="e1c985dd036afafc48409f9dec76735bbf115b4e" translate="yes" xml:space="preserve">
          <source>The like() function is used to implement the &quot;&lt;b&gt;Y LIKE X [ESCAPE Z]&lt;/b&gt;&quot; expression. If the optional ESCAPE clause is present, then the like() function is invoked with three arguments. Otherwise, it is invoked with two arguments only. Note that the X and Y parameters are reversed in the like() function relative to the infix &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator. X is the pattern and Y is the string to match against that pattern. Hence, the following expressions are equivalent:</source>
          <target state="translated">like（）函数用于实现&amp;ldquo; &lt;b&gt;Y LIKE X [ESCAPE Z]&lt;/b&gt; &amp;rdquo;表达式。如果存在可选的ESCAPE子句，则使用三个参数调用like（）函数。否则，仅使用两个参数调用它。请注意，like（）函数中的X和Y参数相对于infix &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;运算符是相反的。 X是模式，Y是要与该模式匹配的字符串。因此，以下表达式是等效的：</target>
        </trans-unit>
        <trans-unit id="1725d5bdba0b7e8833554a2371c0c343ab2395e2" translate="yes" xml:space="preserve">
          <source>The likelihood(X,Y) function returns argument X unchanged. The value Y in likelihood(X,Y) must be a floating point constant between 0.0 and 1.0, inclusive. The likelihood(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles during run-time (that is, during calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;). The purpose of the likelihood(X,Y) function is to provide a hint to the query planner that the argument X is a boolean that is true with a probability of approximately Y. The &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely(X)&lt;/a&gt; function is short-hand for likelihood(X,0.0625). The &lt;a href=&quot;lang_corefunc#likely&quot;&gt;likely(X)&lt;/a&gt; function is short-hand for likelihood(X,0.9375).</source>
          <target state="translated">似然性（X，Y）函数不变地返回参数X。似然性（X，Y）中的值Y必须是介于0.0和1.0之间（包括两者）的浮点常量。似然性（X）函数是一种无操作，代码生成器会对其进行优化，以使其在运行时（即在调用&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;期间）不占用任何CPU周期。似然的（X，Y）的目的的功能是提供一个提示来查询规划该参数X是一个布尔值，是真正用约Y的概率&lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;不可能的（X）&lt;/a&gt;函数是短手的可能性（ X，0.0625）。的&lt;a href=&quot;lang_corefunc#likely&quot;&gt;可能的（X）&lt;/a&gt;函数是短手的可能性（X，0.9375）。</target>
        </trans-unit>
        <trans-unit id="047f4505a74dbe546931a88238b570dcea0e5906" translate="yes" xml:space="preserve">
          <source>The likely(X) function returns the argument X unchanged. The likely(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles at run-time (that is, during calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;). The purpose of the likely(X) function is to provide a hint to the query planner that the argument X is a boolean value that is usually true. The likely(X) function is equivalent to &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood&lt;/a&gt;(X,0.9375). See also: &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely(X)&lt;/a&gt;.</source>
          <target state="translated">可能的（X）函数返回参数X不变。可能（X）函数是一个无操作函数，代码生成器会对其进行优化，以使其在运行时（即在调用&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;期间）不占用任何CPU周期。 Possible（X）函数的目的是向查询计划者提供一个提示，即参数X是通常为true的布尔值。可能性（X）函数等效于&lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;可能性&lt;/a&gt;（X，0.9375）。另请参阅：&lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;不太可能（X）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="604c341d9009d83169d386485e03d9e7bc04c662" translate="yes" xml:space="preserve">
          <source>The limit value is set to zero.</source>
          <target state="translated">限值设置为零。</target>
        </trans-unit>
        <trans-unit id="7008986405b40055720891f4830c40ce21496380" translate="yes" xml:space="preserve">
          <source>The line &quot;.once</source>
          <target state="translated">这一行&quot;.一旦</target>
        </trans-unit>
        <trans-unit id="d0c3acc92dc701e819ac94a0c8098f2db90a205c" translate="yes" xml:space="preserve">
          <source>The list below is not exhaustive. Other virtual table implementation exist in the SQLite source tree and elsewhere. The list below tries to capture the more interesting virtual table implementations.</source>
          <target state="translated">下面的列表并不详尽。在SQLite源码树和其他地方还存在其他的虚拟表实现。下面的列表试图捕捉更有趣的虚拟表实现。</target>
        </trans-unit>
        <trans-unit id="d3b78caa21f35e034eafcfa346ed07394d0ca6e0" translate="yes" xml:space="preserve">
          <source>The list below shows all possible keywords used by any build of SQLite regardless of &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt;. Most reasonable configurations use most or all of these keywords, but some keywords may be omitted when SQL language features are disabled. Applications can use the &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count()&lt;/a&gt;, &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name()&lt;/a&gt;, and &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check()&lt;/a&gt; interfaces to determine the keywords recognized by SQLite at run-time. Regardless of the compile-time configuration, any identifier that is not on the following 143 element list is not a keyword to the SQL parser in SQLite:</source>
          <target state="translated">下面的列表显示了任何SQLite版本都使用的所有可能的关键字，而不管&lt;a href=&quot;compile&quot;&gt;编译时选项如何&lt;/a&gt;。最合理的配置使用大多数或所有这些关键字，但是当禁用SQL语言功能时，某些关键字可能会省略。应用程序可以使用&lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count（）&lt;/a&gt;，&lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name（）&lt;/a&gt;和&lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check（）&lt;/a&gt;接口来确定SQLite在运行时识别的关键字。不管编译时配置如何，不在以下143元素列表中的任何标识符都不是SQLite中SQL解析器的关键字：</target>
        </trans-unit>
        <trans-unit id="0180a1bb67bb5f33291414ccd4cfdc93226599e9" translate="yes" xml:space="preserve">
          <source>The list below shows all possible keywords used by any build of SQLite regardless of &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt;. Most reasonable configurations use most or all of these keywords, but some keywords may be omitted when SQL language features are disabled. Applications can use the &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count()&lt;/a&gt;, &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name()&lt;/a&gt;, and &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check()&lt;/a&gt; interfaces to determine the keywords recognized by SQLite at run-time. Regardless of the compile-time configuration, any identifier that is not on the following 145 element list is not a keyword to the SQL parser in SQLite:</source>
          <target state="translated">下面的列表显示了任何SQLite版本都使用的所有可能的关键字，而不管&lt;a href=&quot;compile&quot;&gt;编译时选项如何&lt;/a&gt;。最合理的配置使用大多数或所有这些关键字，但是当禁用SQL语言功能时，可能会省略某些关键字。应用程序可以使用&lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count（）&lt;/a&gt;，&lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name（）&lt;/a&gt;和&lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check（）&lt;/a&gt;接口来确定SQLite在运行时识别的关键字。不管编译时配置如何，不在以下145个元素列表上的任何标识符都不是SQLite中SQL解析器的关键字：</target>
        </trans-unit>
        <trans-unit id="281c02e8bf5d35129f9e1be609bd2e9295d15355" translate="yes" xml:space="preserve">
          <source>The list of coordinates in the binary format contains no redundancy. The last coordinate is not a repeat of the first as it is with GeoJSON. Hence, there is always one fewer coordinate pair in the binary representation of a polygon compared to the GeoJSON representation.</source>
          <target state="translated">二进制格式的坐标列表不包含多余的内容。最后一个坐标不会像GeoJSON那样重复第一个坐标。因此,与GeoJSON表示法相比,多边形的二进制表示法总是少一个坐标对。</target>
        </trans-unit>
        <trans-unit id="31509dccb06d1116de02483b9bec949662404996" translate="yes" xml:space="preserve">
          <source>The list of expressions between the SELECT and FROM keywords is known as the result expression list. If a result expression is the special expression &quot;*&quot; then all columns in the input data are substituted for that one expression. If the expression is the alias of a table or subquery in the FROM clause followed by &quot;.*&quot; then all columns from the named table or subquery are substituted for the single expression. It is an error to use a &quot;*&quot; or &quot;alias.*&quot; expression in any context other than a result expression list. It is also an error to use a &quot;*&quot; or &quot;alias.*&quot; expression in a simple SELECT query that does not have a FROM clause.</source>
          <target state="translated">SELECT和FROM关键字之间的表达式列表称为结果表达式列表。如果结果表达式是特殊表达式 &quot;*&quot;,那么输入数据中的所有列都会被这一个表达式所替代。如果表达式是FROM子句中表或子查询的别名,后面加&quot;.*&quot;,那么被命名的表或子查询中的所有列都会被这一个表达式所替代。在结果表达式列表以外的任何上下文中使用 &quot;*&quot;或 &quot;alias.*&quot;表达式都是错误的。在没有FROM子句的简单SELECT查询中使用 &quot;*&quot;或 &quot;alias.*&quot;表达式也是错误的。</target>
        </trans-unit>
        <trans-unit id="aff07670c95df2683c32cdb3b9c35bd30fecbe25" translate="yes" xml:space="preserve">
          <source>The list of integers in the stat column can optionally be followed by arguments, each of which is a sequence of non-space characters. All arguments are preceded by a single space. Unrecognized arguments are silently ignored.</source>
          <target state="translated">统计列中的整数列表可以选择跟在参数后面,每个参数都是一个非空格字符的序列。所有参数前面都有一个空格。未识别的参数将被忽略。</target>
        </trans-unit>
        <trans-unit id="5c584c3300424511e57cf7c45771316447fd9008" translate="yes" xml:space="preserve">
          <source>The load_extension() function will fail if the extension attempts to modify or delete an SQL function or collating sequence. The extension can add new functions or collating sequences, but cannot modify or delete existing functions or collating sequences because those functions and/or collating sequences might be used elsewhere in the currently running SQL statement. To load an extension that changes or deletes functions or collating sequences, use the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; C-language API.</source>
          <target state="translated">如果扩展尝试修改或删除SQL函数或整理序列，则load_extension（）函数将失败。该扩展可以添加新功能或整理序列，但不能修改或删除现有功能或整理序列，因为这些功能和/或整理序列可能在当前运行的SQL语句中的其他位置使用。要加载更改或删除函数或整理序列的扩展，请使用&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt; C语言API。</target>
        </trans-unit>
        <trans-unit id="349abdc2376164ceeb049d0fdce3e4218d275600" translate="yes" xml:space="preserve">
          <source>The load_extension(X,Y) function loads &lt;a href=&quot;loadext&quot;&gt;SQLite extensions&lt;/a&gt; out of the shared library file named X using the entry point Y. The result of load_extension() is always a NULL. If Y is omitted then the default entry point name is used. The load_extension() function raises an exception if the extension fails to load or initialize correctly.</source>
          <target state="translated">load_extension（X，Y）函数使用入口点Y从名为X的共享库文件中加载&lt;a href=&quot;loadext&quot;&gt;SQLite扩展&lt;/a&gt;。load_extension（）的结果始终为NULL。如果省略Y，则使用默认入口点名称。如果扩展无法正确加载或初始化，load_extension（）函数将引发异常。</target>
        </trans-unit>
        <trans-unit id="3c476d76e8d35e3c5addfedd0889c28cfa2868c0" translate="yes" xml:space="preserve">
          <source>The local copy of the remote head</source>
          <target state="translated">远程云台的本地副本</target>
        </trans-unit>
        <trans-unit id="9c687c8acb9d37e788292221df58e5cc9d9b9e4e" translate="yes" xml:space="preserve">
          <source>The local head</source>
          <target state="translated">当地负责人</target>
        </trans-unit>
        <trans-unit id="ef999d9e04e59df040c534586df9501decb45621" translate="yes" xml:space="preserve">
          <source>The lock-byte page</source>
          <target state="translated">锁定字节页</target>
        </trans-unit>
        <trans-unit id="5c06094b5494afcc6bc0546930a2d751ec1db7b7" translate="yes" xml:space="preserve">
          <source>The lock-byte page arose from the need to support Win95 which was the predominant operating system when this file format was designed and which only supported mandatory file locking. All modern operating systems that we know of support advisory file locking, and so the lock-byte page is not really needed any more, but is retained for backwards compatibility.</source>
          <target state="translated">锁定字节页的产生是由于需要支持Win95,而Win95在设计这种文件格式时是最主要的操作系统,它只支持强制文件锁定。我们所知道的所有现代操作系统都支持咨询文件锁定,因此不再需要锁定字节页,而是为了向后兼容而保留。</target>
        </trans-unit>
        <trans-unit id="4bd512e93ea74564dff8bf82d8627bae1ed3c48e" translate="yes" xml:space="preserve">
          <source>The lock-byte page is set aside for use by the operating-system specific &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementation in implementing the database file locking primitives. SQLite does not use the lock-byte page. The SQLite core will never read or write the lock-byte page, though operating-system specific &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations may choose to read or write bytes on the lock-byte page according to the needs and proclivities of the underlying system. The unix and win32 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations that come built into SQLite do not write to the lock-byte page, but third-party VFS implementations for other operating systems might.</source>
          <target state="translated">保留了锁定字节页面，以供操作系统特定的&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;实现在实现数据库文件锁定原语时使用。 SQLite不使用锁定字节页面。尽管特定于操作系统的&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;实现可能会根据底层系统的需要和倾向选择在锁定字节页上读取或写入字节，但SQLite核心永远不会读取或写入锁定字节页。SQLite内置的unix和win32 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;实现不会写入锁定字节页，但是其他操作系统的第三方VFS实现可能会写入。</target>
        </trans-unit>
        <trans-unit id="df185932a5473981e68a610e19ea95a4f593a072" translate="yes" xml:space="preserve">
          <source>The lock-byte page is the single page of the database file that contains the bytes at offsets between 1073741824 and 1073742335, inclusive. A database file that is less than or equal to 1073741824 bytes in size contains no lock-byte page. A database file larger than 1073741824 contains exactly one lock-byte page.</source>
          <target state="translated">锁字节页是指数据库文件中包含1073741824和1073742335(含)之间偏移量的字节的单页。小于或等于1073741824字节大小的数据库文件不包含锁字节页。大于1073741824字节的数据库文件正好包含一个锁字节页。</target>
        </trans-unit>
        <trans-unit id="dda6a9ed2d568f9a7c6dc08407b442fb82119304" translate="yes" xml:space="preserve">
          <source>The logic is summarized like this:</source>
          <target state="translated">逻辑是这样总结的。</target>
        </trans-unit>
        <trans-unit id="355578bfd3a4498b2a633a6f3c4ff7c7b09de69f" translate="yes" xml:space="preserve">
          <source>The logical database size is now stored in the database header so that bytes can be appended to the end of the database file without corrupting it and so that SQLite will work correctly on systems that lack support for ftruncate().</source>
          <target state="translated">现在,逻辑数据库的大小存储在数据库头中,这样就可以在不破坏数据库文件的情况下将字节追加到文件末尾,这样SQLite就可以在缺乏ftruncate()支持的系统上正确工作。</target>
        </trans-unit>
        <trans-unit id="e93186cc2b2b96f693bcff5f9715523649b95afa" translate="yes" xml:space="preserve">
          <source>The lookaside configuration can only be changed while there are no outstanding lookaside allocations for the database connection. Hence, the configuration should be set immediately after creating the database connection using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; (or equivalent) and before evaluating any SQL statements on the connection.</source>
          <target state="translated">仅当数据库连接没有未完成的后备分配时，才能更改后备配置。因此，应在使用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;（或等效方法）创建数据库连接之后并在评估连接上的任何SQL语句之前立即设置配置。</target>
        </trans-unit>
        <trans-unit id="98de1d7e1c308aef9eeb240a9c0c48340d7aa4c3" translate="yes" xml:space="preserve">
          <source>The lookaside memory allocator is really intended as performance optimization, not as a method for assuring breakdown-free memory allocation, so it is not unreasonable to completely disable the lookaside memory allocator for safety-critical operations.</source>
          <target state="translated">lookaside内存分配器的真正目的是为了优化性能,而不是保证无故障内存分配的方法,所以对于安全关键的操作,完全禁用lookaside内存分配器并非不合理。</target>
        </trans-unit>
        <trans-unit id="02f0ada4fc69e2b3f3d2c6c843b91333faf8b563" translate="yes" xml:space="preserve">
          <source>The lookaside pool can be changed for an individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; &quot;db&quot; using this call:</source>
          <target state="translated">可以使用以下调用为单个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt; &amp;ldquo; db&amp;rdquo; 更改后备池：</target>
        </trans-unit>
        <trans-unit id="31d19ac91c3d68e4ec2f5534877ee0ca68a0efec" translate="yes" xml:space="preserve">
          <source>The loop begins with the &lt;a href=&quot;opcode#MemLoad&quot;&gt;MemLoad&lt;/a&gt; instruction at 11 which pushes a copy of the index key back onto the stack. The instruction &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; at 12 compares the key to the key in the current index record pointed to by cursor P1. If the index key at the current cursor location is greater than the index we are looking for, then jump out of the loop.</source>
          <target state="translated">循环从11处的&lt;a href=&quot;opcode#MemLoad&quot;&gt;MemLoad&lt;/a&gt;指令开始，该指令将索引键的副本推回堆栈中。位于12 的指令&lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt;将键与光标P1指向的当前索引记录中的键进行比较。如果当前光标位置的索引键大于我们要查找的索引，则跳出循环。</target>
        </trans-unit>
        <trans-unit id="9b4e40524d32f647817434932fe77ea61e285d86" translate="yes" xml:space="preserve">
          <source>The lower(X) function returns a copy of string X with all ASCII characters converted to lower case. The default built-in lower() function works for ASCII characters only. To do case conversions on non-ASCII characters, load the ICU extension.</source>
          <target state="translated">lower(X)函数返回字符串 X 的副本,并将所有 ASCII 字符转换为小写。默认内置的 lower()函数只对 ASCII 字符起作用,如果要对非 ASCII 字符进行大小写转换,请加载 ICU 扩展。要对非 ASCII 字符进行大小写转换,请加载 ICU 扩展。</target>
        </trans-unit>
        <trans-unit id="84e26bc0d335ef0f3f91dcbee9450cd939575e9d" translate="yes" xml:space="preserve">
          <source>The ltrim(X,Y) function returns a string formed by removing any and all characters that appear in Y from the left side of X. If the Y argument is omitted, ltrim(X) removes spaces from the left side of X.</source>
          <target state="translated">ltrim(X,Y)函数返回一个从X的左侧删除Y中出现的所有字符形成的字符串,如果省略Y参数,ltrim(X)将删除X左侧的空格。</target>
        </trans-unit>
        <trans-unit id="dcd00f490e6b7624f89a2b1b208cdec82ae08bf5" translate="yes" xml:space="preserve">
          <source>The mFlags parameter to sqlite3_carray_bind() must be one of:</source>
          <target state="translated">sqlite3_carray_bind()的mFlags参数必须是其中之一。</target>
        </trans-unit>
        <trans-unit id="fdcc55ab3a12db83d0fd351a3149fb5d3844b7fd" translate="yes" xml:space="preserve">
          <source>The macros in this section do not require values. The following compilation switches all have the same effect:</source>
          <target state="translated">本节中的宏不需要值。下面的编译开关都有同样的效果。</target>
        </trans-unit>
        <trans-unit id="9225c9e6b4935393e2d3171b186997ddaa13f218" translate="yes" xml:space="preserve">
          <source>The main database file consists of one or more pages. The size of a page is a power of two between 512 and 65536 inclusive. All pages within the same database are the same size. The page size for a database file is determined by the 2-byte integer located at an offset of 16 bytes from the beginning of the database file.</source>
          <target state="translated">主数据库文件由一个或多个页面组成。一个页面的大小是512到65536(含)之间的二倍。同一数据库中的所有页面大小相同。数据库文件的页面大小由位于数据库文件开头16字节偏移处的2字节整数决定。</target>
        </trans-unit>
        <trans-unit id="7d6f37716756d458f806be1f0cab62c9c7d22175" translate="yes" xml:space="preserve">
          <source>The main database file with an arbitrary name &quot;X&quot;.</source>
          <target state="translated">主数据库文件的名称为任意 &quot;X&quot;。</target>
        </trans-unit>
        <trans-unit id="f6b3e874976f8a865414a00bc3a0b52995dae0f9" translate="yes" xml:space="preserve">
          <source>The main expression bubble diagram above shows a single syntax for all function invocations. But this is merely to simplify the expression bubble diagram. In reality, each type of function has a slightly different syntax, shown below. The function invocation syntax shown in the main expression bubble diagram is the union of the three syntaxes shown here:</source>
          <target state="translated">上面的主表达式气泡图显示了所有函数调用的单一语法。但这只是为了简化表达式气泡图。实际上,每种类型的函数都有稍微不同的语法,如下图所示。主表达式气泡图中所示的函数调用语法是这里所示的三种语法的结合。</target>
        </trans-unit>
        <trans-unit id="408e5f03d044dab233873eb64f906cb6ccb49b90" translate="yes" xml:space="preserve">
          <source>The main machine in Dallas &lt;a href=&quot;https://www.sqlite.org/&quot;&gt;https://www.sqlite.org/&lt;/a&gt; is the primary server and the one that most people use. The other two are considered backups.</source>
          <target state="translated">达拉斯&lt;a href=&quot;https://www.sqlite.org/&quot;&gt;https://www.sqlite.org/&lt;/a&gt;中的主机是主要服务器，也是大多数人使用的服务器。其他两个被视为备份。</target>
        </trans-unit>
        <trans-unit id="1d698f91852ce738e8b0efe94402ad56dc5b35ee" translate="yes" xml:space="preserve">
          <source>The main result from &lt;b&gt;sqlite_get_table&lt;/b&gt; is an array of pointers to strings. There is one element in this array for each column of each row in the result. NULL results are represented by a NULL pointer. In addition to the regular data, there is an added row at the beginning of the array that contains the name of each column of the result.</source>
          <target state="translated">&lt;b&gt;sqlite_get_table&lt;/b&gt;的主要结果是一个指向字符串的指针数组。结果中每一行的每一列在此数组中都有一个元素。NULL结果由NULL指针表示。除常规数据外，数组开头还有一个添加的行，其中包含结果每一列的名称。</target>
        </trans-unit>
        <trans-unit id="2fb1295c928ccfed10f4bea85ec6d057bdb858da" translate="yes" xml:space="preserve">
          <source>The main thing that the SQLite core is trying to communicate to the virtual table is the constraints that are available to limit the number of rows that need to be searched. The aConstraint[] array contains one entry for each constraint. There will be exactly nConstraint entries in that array.</source>
          <target state="translated">SQLite核心要传达给虚拟表的主要内容是可用来限制需要搜索的行数的约束。aConstraint[]数组包含每个约束的一个条目。该数组中正好会有n个Constraint条目。</target>
        </trans-unit>
        <trans-unit id="c00fa1abbc4e41f8e98c7516bdb7add3970ff677" translate="yes" xml:space="preserve">
          <source>The makefiles and scripts used to generate the documentation gather text from baseline documents in the documentation source repository. Additional text is extracted from comments in the SQLite source code. Requirements coverage information is extract from special comments in the &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt; which is part of the source repository, and from comments in the &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; test suite which is a separate private repository.</source>
          <target state="translated">用于生成文档的makefile和脚本从文档源存储库中的基准文档中收集文本。其他文本是从SQLite源代码中的注释中提取的。需求覆盖率信息是从&lt;a href=&quot;testing#tcl&quot;&gt;TCL测试套件（&lt;/a&gt;它是源存储库的一部分）中的特殊注释以及&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;测试套件（一个单独的私有存储库）中的注释中提取的。</target>
        </trans-unit>
        <trans-unit id="42a78601e6da24d033fc5c1c1ee7512e6c89f88c" translate="yes" xml:space="preserve">
          <source>The makefiles for SQLite have an &quot;sqlite3.c&quot; target for building the file we call &quot;the amalgamation&quot;. The amalgamation is a single C code file, named &quot;sqlite3.c&quot;, that contains all C code for the core SQLite library and the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;, &lt;a href=&quot;dbstat&quot;&gt;DBSTAT&lt;/a&gt;, &lt;a href=&quot;json1&quot;&gt;JSON1&lt;/a&gt;, and &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; extensions. This file contains about 184K lines of code (113K if you omit blank lines and comments) and is over 6.4 megabytes in size. Though the various extensions are included in the &quot;sqlite3.c&quot; amalgamation file, they are disabled using #ifdef statements. Activate the extensions using &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; like:</source>
          <target state="translated">SQLite的makefile具有一个&amp;ldquo; sqlite3.c&amp;rdquo;目标，用于构建我们称为&amp;ldquo;合并&amp;rdquo;的文件。合并是一个单独的C代码文件，名为&amp;ldquo; sqlite3.c&amp;rdquo;，其中包含核心SQLite库以及&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;，&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;，&lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;，&lt;a href=&quot;dbstat&quot;&gt;DBSTAT&lt;/a&gt;，&lt;a href=&quot;json1&quot;&gt;JSON1&lt;/a&gt;和&lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt;扩展的所有C代码。该文件包含大约18.4万行代码（如果省略空行和注释，则为113K），大小超过6.4兆字节。尽管&amp;ldquo; sqlite3.c&amp;rdquo;合并文件中包含各种扩展名，但是使用#ifdef语句将其禁用。使用如下&lt;a href=&quot;compile&quot;&gt;编译时选项&lt;/a&gt;激活扩展：</target>
        </trans-unit>
        <trans-unit id="0980756624132b6830b479bc71ea60b90272891a" translate="yes" xml:space="preserve">
          <source>The manner in which SQLite uses temporary files is not considered part of the contract that SQLite makes with applications. The information in this document is a correct description of how SQLite operates at the time that this document was written or last updated. But there is no guarantee that future versions of SQLite will use temporary files in the same way. New kinds of temporary files might be employed and some of the current temporary file uses might be discontinued in future releases of SQLite.</source>
          <target state="translated">SQLite使用临时文件的方式不被认为是SQLite与应用程序签订的合同的一部分。本文档中的信息是本文档编写或最后一次更新时对SQLite操作方式的正确描述。但不能保证未来版本的SQLite会以同样的方式使用临时文件。在未来的SQLite版本中,可能会采用新的临时文件种类,而且当前的一些临时文件的使用可能会被停止。</target>
        </trans-unit>
        <trans-unit id="3c2b798d423398f0b8335bc4cb33aea4b3800944" translate="yes" xml:space="preserve">
          <source>The mapping from character to affinity is given by the SQLITE_AFF_ macros defined in sqliteInt.h.</source>
          <target state="translated">从字符到亲和力的映射由 sqliteInt.h 中定义的 SQLITE_AFF_宏给出。</target>
        </trans-unit>
        <trans-unit id="e5801820a892b25589a4f5acb0cdb08d7136d42b" translate="yes" xml:space="preserve">
          <source>The master journal file is only created for &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; operations that involve multiple database files where at least two of the databases meet all of the following requirements:</source>
          <target state="translated">仅为涉及多个数据库文件的&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;操作创建主日志文件，其中至少两个数据库满足以下所有要求：</target>
        </trans-unit>
        <trans-unit id="31da1199925e2ef2121e09ef393e19f883001204" translate="yes" xml:space="preserve">
          <source>The master journal file is used as part of the atomic commit process when a single transaction makes changes to multiple databases that have been added to a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. The master journal file is always located in the same directory as the main database file (the main database file is the database that is identified in the original &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that created the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;) with a randomized suffix. The master journal file contains the names of all of the various attached auxiliary databases that were changed during the transaction. The multi-database transaction commits when the master journal file is deleted. See the documentation titled &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit In SQLite&lt;/a&gt; for additional detail.</source>
          <target state="translated">当单个事务对使用&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;语句添加到单个&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;中的多个数据库进行更改时，主日志文件将用作原子提交过程的一部分。主日志文件始终与主数据库文件位于同一目录中（主数据库文件是在创建&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt;的原始&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;或&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;调用中标识的数据库）），并带有随机后缀。主日志文件包含在事务期间更改的所有各种附加辅助数据库的名称。当删除主日记文件时，将执行多数据库事务。有关更多详细信息，请参见标题为&amp;ldquo; &lt;a href=&quot;atomiccommit&quot;&gt;SQLite&lt;/a&gt;中的原子提交&amp;rdquo;的文档。</target>
        </trans-unit>
        <trans-unit id="772c6b302e1774e25495c91e9341c8308af64569" translate="yes" xml:space="preserve">
          <source>The matchinfo 'b' flag provides similar information to the &lt;a href=&quot;fts3#matchinfo-y&quot; id=&quot;matchinfo-b&quot;&gt;matchinfo 'y' flag&lt;/a&gt;, but in a more compact form. Instead of the precise number of hits, 'b' provides a single boolean flag for each phrase/column combination. If the phrase is present in the column at least once (i.e. if the corresponding integer output of 'y' would be non-zero), the corresponding flag is set. Otherwise cleared.</source>
          <target state="translated">所述matchinfo&amp;ldquo;b&amp;rdquo;标记提供类似的信息给&lt;a href=&quot;fts3#matchinfo-y&quot; id=&quot;matchinfo-b&quot;&gt;matchinfo&amp;ldquo;y&amp;rdquo;的标志&lt;/a&gt;，但在一个更紧凑的形式。&amp;ldquo; b&amp;rdquo;代替了准确的匹配数，而是为每个短语/列组合提供了一个布尔标志。如果该短语在该列中至少存在一次（即，如果&amp;ldquo; y&amp;rdquo;的相应整数输出为非零），则设置相应的标志。否则清除。</target>
        </trans-unit>
        <trans-unit id="0e92769ac2bedb9028e89c1796d219b3c41ebfd0" translate="yes" xml:space="preserve">
          <source>The matchinfo function is called with either one or two arguments. As for all auxiliary functions, the first argument must be the special &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt;. The second argument, if it is specified, must be a text value comprised only of the characters 'p', 'c', 'n', 'a', 'l', 's', 'x', 'y' and 'b'. If no second argument is explicitly supplied, it defaults to &quot;pcx&quot;. The second argument is referred to as the &quot;format string&quot; below.</source>
          <target state="translated">使用一个或两个参数调用matchinfo函数。对于所有辅助功能，第一个参数必须是特殊的&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS隐藏列&lt;/a&gt;。第二个参数（如果已指定）必须是仅由字符&amp;ldquo; p&amp;rdquo;，&amp;ldquo; c&amp;rdquo;，&amp;ldquo; n&amp;rdquo;，&amp;ldquo; a&amp;rdquo;，&amp;ldquo; l&amp;rdquo;，&amp;ldquo; s&amp;rdquo;，&amp;ldquo; x&amp;rdquo;，&amp;ldquo; y&amp;rdquo;组成的文本值和&amp;ldquo; b&amp;rdquo;。如果未显式提供第二个参数，则默认为&amp;ldquo; pcx&amp;rdquo;。第二个参数在下面称为&amp;ldquo;格式字符串&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d7687da8f246deec886a3154fb495c0792554c7d" translate="yes" xml:space="preserve">
          <source>The matchinfo function is much faster than either the snippet or offsets functions. This is because the implementation of both snippet and offsets is required to retrieve the documents being analyzed from disk, whereas all data required by matchinfo is available as part of the same portions of the full-text index that are required to implement the full-text query itself. This means that of the following two queries, the first may be an order of magnitude faster than the second:</source>
          <target state="translated">matchinfo 函数比 snippet 或 offsets 函数快得多。这是因为实现snippet和offsets都需要从磁盘上检索被分析的文档,而matchinfo所需要的所有数据都可以作为全文索引的一部分,这些部分是实现全文查询本身所需要的。这意味着,在以下两个查询中,第一个查询可能比第二个查询快一个数量级。</target>
        </trans-unit>
        <trans-unit id="c65df31b33c2a6ca0926acfdea9fd52aa875638d" translate="yes" xml:space="preserve">
          <source>The matchinfo function provides all the information required to calculate probabilistic &quot;bag-of-words&quot; relevancy scores such as &lt;a href=&quot;http://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;Okapi BM25/BM25F&lt;/a&gt; that may be used to order results in a full-text search application. Appendix A of this document, &quot;&lt;a href=&quot;fts3#appendix_a&quot;&gt;search application tips&lt;/a&gt;&quot;, contains an example of using the matchinfo() function efficiently.</source>
          <target state="translated">matchinfo函数提供了计算概率&amp;ldquo;单词袋&amp;rdquo;相关性分数所需的所有信息，例如&lt;a href=&quot;http://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;Okapi BM25 / BM25F&lt;/a&gt;，可用于对全文搜索应用程序中的结果进行排序。本文档的附录A&amp;ldquo; &lt;a href=&quot;fts3#appendix_a&quot;&gt;搜索应用程序技巧&lt;/a&gt; &amp;rdquo;包含一个有效使用matchinfo（）函数的示例。</target>
        </trans-unit>
        <trans-unit id="e88a358cc99cfdf65d05c6a19d241ddd08554be3" translate="yes" xml:space="preserve">
          <source>The matchinfo function provides all the information required to calculate probabilistic &quot;bag-of-words&quot; relevancy scores such as &lt;a href=&quot;https://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;Okapi BM25/BM25F&lt;/a&gt; that may be used to order results in a full-text search application. Appendix A of this document, &quot;&lt;a href=&quot;fts3#appendix_a&quot;&gt;search application tips&lt;/a&gt;&quot;, contains an example of using the matchinfo() function efficiently.</source>
          <target state="translated">matchinfo函数提供计算概率&amp;ldquo;单词袋&amp;rdquo;相关性分数所需的所有信息，例如&lt;a href=&quot;https://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;Okapi BM25 / BM25F&lt;/a&gt;，这些分数可用于在全文搜索应用程序中对结果进行排序。本文档的附录A&amp;ldquo;&lt;a href=&quot;fts3#appendix_a&quot;&gt;搜索应用程序技巧&lt;/a&gt;&amp;rdquo;包含一个有效使用matchinfo（）函数的示例。</target>
        </trans-unit>
        <trans-unit id="e90549847387fb18f595713064d87ed6f095e05c" translate="yes" xml:space="preserve">
          <source>The matchinfo function returns a blob value. If it is used within a query that does not use the full-text index (a &quot;query by rowid&quot; or &quot;linear scan&quot;), then the blob is zero bytes in size. Otherwise, the blob consists of zero or more 32-bit unsigned integers in machine byte-order. The exact number of integers in the returned array depends on both the query and the value of the second argument (if any) passed to the matchinfo function.</source>
          <target state="translated">matchinfo函数返回一个blob值。如果它是在一个不使用全文索引的查询中使用的(&quot;按rowid查询 &quot;或 &quot;线性扫描&quot;),那么blob的大小为零字节。否则,blob由0个或更多的32位无符号整数按机器字节顺序组成。返回数组中整数的确切数量取决于查询和传递给matchinfo函数的第二个参数的值(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="5fd973e0c684054ad3dbbf4a32a2b97ce84282bb" translate="yes" xml:space="preserve">
          <source>The matchinfo option may only be set to the value &quot;fts3&quot;. Attempting to set matchinfo to anything other than &quot;fts3&quot; is an error. If this option is specified, then some of the extra information stored by FTS4 is omitted. This reduces the amount of disk space consumed by an FTS4 table until it is almost the same as the amount that would be used by the equivalent FTS3 table, but also means that the data accessed by passing the 'l' flag to the &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; function is not available.</source>
          <target state="translated">matchinfo选项只能设置为值&amp;ldquo; fts3&amp;rdquo;。尝试将matchinfo设置为除&amp;ldquo; fts3&amp;rdquo;以外的任何其他内容是错误的。如果指定了此选项，则将省略FTS4存储的一些额外信息。这将减少FTS4表占用的磁盘空间量，直到与等效的FTS3表所使用的磁盘空间几乎相同为止，而且还意味着通过将'l'标志传递给&lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo（）&lt;/a&gt;来访问数据。功能不可用。</target>
        </trans-unit>
        <trans-unit id="30566a971375718efb83d0535cdd7975a1033a22" translate="yes" xml:space="preserve">
          <source>The matrix below shows the time needed to read BLOBs stored in separate files divided by the time needed to read BLOBs stored entirely in the database. Hence, for numbers larger than 1.0, it is faster to store the BLOBs directly in the database. For numbers smaller than 1.0, it is faster to store the BLOBs in separate files.</source>
          <target state="translated">下面的矩阵显示了读取存储在单独文件中的BLOB所需的时间除以读取完全存储在数据库中的BLOB所需的时间。因此,对于大于1.0的数字,直接将BLOBs存储在数据库中更快。对于小于1.0的数字,将BLOB存储在单独的文件中更快。</target>
        </trans-unit>
        <trans-unit id="4c2fbc6111561deb5f89baa2a61ac965889a611a" translate="yes" xml:space="preserve">
          <source>The max() aggregate function returns the maximum value of all values in the group. The maximum value is the value that would be returned last in an ORDER BY on the same column. Aggregate max() returns NULL if and only if there are no non-NULL values in the group.</source>
          <target state="translated">max()集合函数返回该组中所有值的最大值,最大值是同一列的ORDER BY中最后返回的值。最大值是在同一列的ORDER BY中最后返回的值。如果且仅当组中没有非NULL值时,聚合函数max()返回NULL。</target>
        </trans-unit>
        <trans-unit id="259079b25b4ee53dd3af62dccf64b88cf7401fe7" translate="yes" xml:space="preserve">
          <source>The maximum allowed value for the 'automerge' parameter is 16. The default value is 4. Setting the 'automerge' parameter to 0 disables the automatic incremental merging of b-trees altogether.</source>
          <target state="translated">automerge &quot;参数的最大允许值是16,默认值是4。默认值是4,将'automerge'参数设置为0,则完全禁止b树的自动增量合并。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
