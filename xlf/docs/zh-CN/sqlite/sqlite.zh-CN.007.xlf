<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="38f9d9f26118d80f3d659b4ee2e2b654e7c605c0" translate="yes" xml:space="preserve">
          <source>Choose the column names in a compound query from the left-most SELECT instead of the right-most.</source>
          <target state="translated">在复合查询中,从最左边的SELECT中选择列名,而不是最右边的。</target>
        </trans-unit>
        <trans-unit id="11cfd2c677994d3ba2e81eb3cb8ff4634809c573" translate="yes" xml:space="preserve">
          <source>Choosing good indexes for each loop</source>
          <target state="translated">为每个循环选择好的索引</target>
        </trans-unit>
        <trans-unit id="070374ff80947b819eb8815e8d492bf0a862577e" translate="yes" xml:space="preserve">
          <source>Chronology</source>
          <target state="translated">Chronology</target>
        </trans-unit>
        <trans-unit id="b104217954a3ac451efc2e2bfb3fdea27198ddd0" translate="yes" xml:space="preserve">
          <source>Cksumvfs is a &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt;. When loaded, &quot;cksmvfs&quot; becomes the new default VFS, and it uses the prior default VFS as the next VFS down in the stack. This is normally what you want. However, in complex situations where multiple VFS shims are being loaded, it might be important to ensure that cksumvfs is loaded in the correct order so that it sequences itself into the default VFS Shim stack in the right order.</source>
          <target state="translated">Cksumvfs是&lt;a href=&quot;vfs#shim&quot;&gt;VFS填充程序&lt;/a&gt;。加载后，&amp;ldquo; cksmvfs&amp;rdquo;成为新的默认VFS，并且它将先前的默认VFS用作堆栈中的下一个VFS。这通常是您想要的。但是，在要加载多个VFS垫片的复杂情况下，重要的是要确保cksumvfs以正确的顺序加载，以便以正确的顺序将其自身放入默认的VFS垫片堆栈中。</target>
        </trans-unit>
        <trans-unit id="d697c3a479d4940e72936c6c5796e737d83de121" translate="yes" xml:space="preserve">
          <source>Clean up comments and variable names. Changes to documentation. No functional changes to the code.</source>
          <target state="translated">清理注释和变量名。对文档进行修改。对代码没有功能上的改变。</target>
        </trans-unit>
        <trans-unit id="719ea396ad92e01b4757ec2b93bb1e5f270f771d" translate="yes" xml:space="preserve">
          <source>Clear</source>
          <target state="translated">Clear</target>
        </trans-unit>
        <trans-unit id="7fe36a4f7ea83f99a8ac259b32e3aa3e06a3e0ea" translate="yes" xml:space="preserve">
          <source>Clearly, a hardware or operating system fault that introduces incorrect data into the middle of the database file or journal will cause problems. Likewise, if a rogue process opens a database file or journal and writes malformed data into the middle of it, then the database will become corrupt. There is not much that can be done about these kinds of problems so they are given no further attention.</source>
          <target state="translated">显然,硬件或操作系统的故障,如果将不正确的数据引入数据库文件或日记本中间,就会造成问题。同样,如果一个流氓进程打开数据库文件或日志,并将畸形的数据写入其中,那么数据库就会损坏。对于这类问题,我们也没有什么办法,所以也就没有再关注。</target>
        </trans-unit>
        <trans-unit id="95490bb933b1b789f5f61256736c0ee3697b1303" translate="yes" xml:space="preserve">
          <source>Client applications typically use a generic database interface that allows connections to various SQL database engines. It makes good sense to include SQLite in the mix of supported databases and to statically link the SQLite engine in with the client. That way the client program can be used standalone with an SQLite data file for testing or for demonstrations.</source>
          <target state="translated">客户端应用程序通常使用一个通用数据库接口,允许连接到各种SQL数据库引擎。在支持的数据库组合中包含SQLite,并将SQLite引擎与客户端进行静态链接是很有意义的。这样客户端程序就可以独立使用SQLite数据文件进行测试或演示。</target>
        </trans-unit>
        <trans-unit id="525256fa1745ebe5497d79cf726d90129b04804e" translate="yes" xml:space="preserve">
          <source>Client/server SQL database engines strive to implement a shared repository of enterprise data. They emphasize scalability, concurrency, centralization, and control. SQLite strives to provide local data storage for individual applications and devices. SQLite emphasizes economy, efficiency, reliability, independence, and simplicity.</source>
          <target state="translated">客户端/服务器SQL数据库引擎努力实现企业数据的共享存储库。它们强调可扩展性、并发性、集中化和控制。SQLite努力为各个应用和设备提供本地数据存储。SQLite强调经济、效率、可靠性、独立性和简单性。</target>
        </trans-unit>
        <trans-unit id="e1dbee15a55011ce9dd54d220174f35b9020dbef" translate="yes" xml:space="preserve">
          <source>Client/server database engines are designed to live inside a lovingly-attended datacenter at the core of the network. SQLite works there too, but SQLite also thrives at the edge of the network, fending for itself while providing fast and reliable data services to applications that would otherwise have dodgy connectivity.</source>
          <target state="translated">客户端/服务器数据库引擎被设计为生活在网络核心的一个精心呵护的数据中心内。SQLite也可以在那里工作,但SQLite也可以在网络边缘茁壮成长,自力更生,同时为应用程序提供快速可靠的数据服务,否则这些应用程序的连接就会变得很糟糕。</target>
        </trans-unit>
        <trans-unit id="63b283ce3f8b364e187012832c04f432c579a52d" translate="yes" xml:space="preserve">
          <source>Client/server databases like MySQL, PostgreSQL, SQL Server, Oracle, and others are an important component of modern systems. These systems solve an important problem. But SQLite solves a different problem. Both SQLite and client/server databases have their role. Developers who are comparing SQLite against other SQL database engines need to clearly understand this distinction.</source>
          <target state="translated">MySQL、PostgreSQL、SQL Server、Oracle等客户/服务器数据库是现代系统的重要组成部分。这些系统解决了一个重要的问题。但SQLite解决的是不同的问题。SQLite和客户/服务器数据库都有其作用。开发人员在将SQLite与其他SQL数据库引擎进行比较时,需要清楚地了解这种区别。</target>
        </trans-unit>
        <trans-unit id="bbfa773e5a63a5ea58c9b6207e608ca0120e592a" translate="yes" xml:space="preserve">
          <source>Close</source>
          <target state="translated">Close</target>
        </trans-unit>
        <trans-unit id="d692c2c202249e9e4fe0069f00e6bff039f0c2b5" translate="yes" xml:space="preserve">
          <source>Close A BLOB Handle</source>
          <target state="translated">关闭一个BLOB手柄</target>
        </trans-unit>
        <trans-unit id="2e50e33188cf1bf73dcb5e4643c391e4e29a00af" translate="yes" xml:space="preserve">
          <source>Close a cursor previously opened as P1. If P1 is not currently open, this instruction is a no-op.</source>
          <target state="translated">关闭之前作为P1打开的游标。如果P1当前没有打开,那么这条指令是无操作的。</target>
        </trans-unit>
        <trans-unit id="0e4d537da92d49358e224a4a747dea32342b05b1" translate="yes" xml:space="preserve">
          <source>Close both cursors.</source>
          <target state="translated">关闭两个光标。</target>
        </trans-unit>
        <trans-unit id="29aaf7cec2af0b1f202abf31695f4cd37d74e8ff" translate="yes" xml:space="preserve">
          <source>Close the cursor.</source>
          <target state="translated">关闭光标。</target>
        </trans-unit>
        <trans-unit id="f1ceaea1ade786b6daac7b066c7f274b9fd722f8" translate="yes" xml:space="preserve">
          <source>Closing A Database Connection</source>
          <target state="translated">关闭数据库连接</target>
        </trans-unit>
        <trans-unit id="e0046ff4ec6b0abe476379971c2a006ff70bf46c" translate="yes" xml:space="preserve">
          <source>Closing a Connection</source>
          <target state="translated">关闭连接</target>
        </trans-unit>
        <trans-unit id="8661917419fb7cc5ef82c55b2e68e555b2266617" translate="yes" xml:space="preserve">
          <source>Closing a connection.</source>
          <target state="translated">关闭一个连接。</target>
        </trans-unit>
        <trans-unit id="db1b559a50c46dcb478b73c9953c212ac94e2736" translate="yes" xml:space="preserve">
          <source>Closing a database connection is a simple matter. The open VFS file-handle is closed and in-memory</source>
          <target state="translated">关闭数据库连接是一件简单的事情。打开的VFS文件柄被关闭,内存中的</target>
        </trans-unit>
        <trans-unit id="7c60089a30c51b5540b0120bd48683a09f4c83f6" translate="yes" xml:space="preserve">
          <source>Clothe the naked.</source>
          <target state="translated">给裸体的人穿上衣服。</target>
        </trans-unit>
        <trans-unit id="bb887cae0ad4591660280c949ded3080d0ff24a8" translate="yes" xml:space="preserve">
          <source>Clustered Indexes and the WITHOUT ROWID Optimization</source>
          <target state="translated">集群索引和WITHOUT ROWID的优化</target>
        </trans-unit>
        <trans-unit id="79a91b7b9e81e75043a22ebed1514d4b90a130a5" translate="yes" xml:space="preserve">
          <source>Clustered indexes</source>
          <target state="translated">聚类指数</target>
        </trans-unit>
        <trans-unit id="339841482704071d6be66d22a76e8ac915ed405e" translate="yes" xml:space="preserve">
          <source>Co-routines are better than storing the complete result set of the subquery in a transient table because co-routines use less memory. With a co-routine, only a single row of the result needs to be remembered, whereas all rows of the result must be stored for a transient table. Also, because the co-routine does not need to run to completion before the outer query begins its work, the first rows of output can appear much sooner, and if the overall query is aborted, less work is done overall.</source>
          <target state="translated">协同例程比在瞬时表中存储子查询的完整结果集更好,因为协同例程使用的内存更少。使用协同例程时,只需要记住结果中的一行,而瞬时表必须存储结果的所有行。另外,由于协同例程不需要在外层查询开始工作之前运行完成,所以输出的第一行可以更快地出现,如果整体查询被中止,那么整体上做的工作就会减少。</target>
        </trans-unit>
        <trans-unit id="fd74b2a71394e7ee81bb386b6917d0be84ba18b0" translate="yes" xml:space="preserve">
          <source>Code Generator</source>
          <target state="translated">代码生成器</target>
        </trans-unit>
        <trans-unit id="47dea711cabe6deab879a9b733dd07b05a63631b" translate="yes" xml:space="preserve">
          <source>Code Of Conduct</source>
          <target state="translated">行为准则</target>
        </trans-unit>
        <trans-unit id="74e1db16aadf744876e02c6a4f106f1aa7afb651" translate="yes" xml:space="preserve">
          <source>Code Of Ethics</source>
          <target state="translated">道德准则</target>
        </trans-unit>
        <trans-unit id="ae87810899e1431de7026ce043d8dda320fed1e7" translate="yes" xml:space="preserve">
          <source>Code change inspection</source>
          <target state="translated">代码变更检查</target>
        </trans-unit>
        <trans-unit id="b5a54c50fda17aa53c6eedfc8045f9c24c210470" translate="yes" xml:space="preserve">
          <source>Code changes to compile cleanly using OpenWatcom.</source>
          <target state="translated">代码变化,使用OpenWatcom编译干净。</target>
        </trans-unit>
        <trans-unit id="264398069882e7753347718021d0c9c51b7ce8fc" translate="yes" xml:space="preserve">
          <source>Code of Conduct</source>
          <target state="translated">行为守则</target>
        </trans-unit>
        <trans-unit id="478104ea503bb6e0eff3a5e3bdba87d5231ae12a" translate="yes" xml:space="preserve">
          <source>Code optimization and refactoring for improved performance.</source>
          <target state="translated">代码优化和重构以提高性能。</target>
        </trans-unit>
        <trans-unit id="c2b53cecb4c71a1d486f72dfb3a0761cddc764ad" translate="yes" xml:space="preserve">
          <source>Coincidentally, that same index is useful for locating the team leader of a particular team:</source>
          <target state="translated">巧合的是,同样的索引对于找到某支队伍的队长很有用。</target>
        </trans-unit>
        <trans-unit id="d5e560637618ccf843afba6188e722395d88af53" translate="yes" xml:space="preserve">
          <source>CollSeq</source>
          <target state="translated">CollSeq</target>
        </trans-unit>
        <trans-unit id="bdc2214c3a09bee2f36f96131835f28a7049fea6" translate="yes" xml:space="preserve">
          <source>Collating functions only matter when comparing string values. Numeric values are always compared numerically, and BLOBs are always compared byte-by-byte using memcmp().</source>
          <target state="translated">整理函数只有在比较字符串值时才有意义。数字值总是以数字方式进行比较,而BLOB总是使用memcmp()逐个字节进行比较。</target>
        </trans-unit>
        <trans-unit id="d660ea76dd255d7ad9c4922511054c5e967af78f" translate="yes" xml:space="preserve">
          <source>Collating sequences are used for comparing two text strings. The collating sequence does not change the ordering of NULLs, numbers, or BLOBs, only text.</source>
          <target state="translated">整理序列用于比较两个文本字符串。整理序列不会改变NULLs、数字或BLOBs的顺序,只会改变文本。</target>
        </trans-unit>
        <trans-unit id="1e254a056c86801f8b560ebd071943f8829e763e" translate="yes" xml:space="preserve">
          <source>Collation Needed Callbacks</source>
          <target state="translated">整理需要的回调</target>
        </trans-unit>
        <trans-unit id="e0c052d2751435fee70a8eb47de4eb3956e79de1" translate="yes" xml:space="preserve">
          <source>Collectively, the aPgno entries record the database page number stored in all frames of the WAL file. The aPgno[0] entry on the first hash table records the database page number stored in the very first frame in the WAL file. The aPgno[i] entry from the first hash table is the database page number for the i-th frame in the WAL file. The aPgno[k] entry for the second hash table is the database page number for the (k+4062)-th frame in the WAL file. The aPgno[k] entry for the n-th 32768-byte hash table in the shm file (for n&amp;gt;1) holds the database page number stored in the (k+4062+4096*(n-2))-th frame of the WAL file.</source>
          <target state="translated">aPgno条目共同记录存储在WAL文件的所有帧中的数据库页号。第一个哈希表上的aPgno [0]条目记录存储在WAL文件的第一帧中的数据库页号。第一个哈希表中的aPgno [i]条目是WAL文件中第i帧的数据库页号。第二个哈希表的aPgno [k]条目是WAL文件中第（k + 4062）帧的数据库页号。 shm文件中第n个32768字节哈希表的aPgno [k]条目（对于n&amp;gt; 1）保存存储在第（k + 4062 + 4096 *（n-2））帧中的数据库页号WAL文件。</target>
        </trans-unit>
        <trans-unit id="d2925a5d74339b84bdd408d91b33688b6815af58" translate="yes" xml:space="preserve">
          <source>Colloquially, the Robson proof shows that in order to guarantee breakdown-free operation, any memory allocator must use a memory pool of size &lt;b&gt;N&lt;/b&gt; which exceeds the maximum amount of memory ever used &lt;b&gt;M&lt;/b&gt; by a multiplier that depends on &lt;b&gt;n&lt;/b&gt;, the ratio of the largest to the smallest allocation size. In other words, unless all memory allocations are of exactly the same size (&lt;b&gt;n&lt;/b&gt;=1) then the system needs access to more memory than it will ever use at one time. Furthermore, we see that the amount of surplus memory required grows rapidly as the ratio of largest to smallest allocations increases, and so there is strong incentive to keep all allocations as near to the same size as possible.</source>
          <target state="translated">通俗地说，在罗布森证明表明，为了保证无故障运行，任何内存分配器必须使用的大小的存储器池&lt;b&gt;&amp;Ntilde;&lt;/b&gt;超过用过的存储器的最大量&lt;b&gt;中号&lt;/b&gt;由取决于乘法器&lt;b&gt;&amp;Ntilde;&lt;/b&gt;，最大的比例到最小的分配大小。换句话说，除非所有内存分配的大小都完全相同（&lt;b&gt;n&lt;/b&gt; = 1），否则系统需要访问的内存将比一次使用的内存更多。此外，我们看到，随着最大分配与最小分配之比的增加，所需的剩余内存量迅速增长，因此有强烈的动机将所有分配保持在尽可能近的相同大小。</target>
        </trans-unit>
        <trans-unit id="65ba00e95e60fb8971e699c771908e7c41d91624" translate="yes" xml:space="preserve">
          <source>Column</source>
          <target state="translated">Column</target>
        </trans-unit>
        <trans-unit id="7457b5eaf3d7bfc87797ee1a1767fe0cb49411af" translate="yes" xml:space="preserve">
          <source>Column Contents</source>
          <target state="translated">栏目内容</target>
        </trans-unit>
        <trans-unit id="dc9eb343792aa10d2e4b6816e5d06cae705abefb" translate="yes" xml:space="preserve">
          <source>Column Declared Type</source>
          <target state="translated">栏目申报类型</target>
        </trans-unit>
        <trans-unit id="edbb850ee1e2303abaa75179e5da0bca25a8e6e9" translate="yes" xml:space="preserve">
          <source>Column Definitions</source>
          <target state="translated">栏目定义</target>
        </trans-unit>
        <trans-unit id="f0e08cc3301877a460436bcf15d46df904fa1c8f" translate="yes" xml:space="preserve">
          <source>Column Name</source>
          <target state="translated">栏目名称</target>
        </trans-unit>
        <trans-unit id="cfbfc51b4b3062caab10bcf86299598910467bc8" translate="yes" xml:space="preserve">
          <source>Column Names In A Result Set</source>
          <target state="translated">结果集中的列名</target>
        </trans-unit>
        <trans-unit id="2a8d5de5174e3943971a2875266b6881264de3bb" translate="yes" xml:space="preserve">
          <source>Column definition</source>
          <target state="translated">栏目定义</target>
        </trans-unit>
        <trans-unit id="087b86714eee3da08b0eea49abe7223a80fbe1f7" translate="yes" xml:space="preserve">
          <source>Column filter queries are not available.</source>
          <target state="translated">列过滤查询不可用。</target>
        </trans-unit>
        <trans-unit id="1fb21b8e379e9449d53a5880fcc60a3256a75dc9" translate="yes" xml:space="preserve">
          <source>Column filter specifications may also be applied to arbitrary expressions enclosed in parenthesis. In this case the column filter applies to all phrases within the expression. Nested column filter operations may only further restrict the subset of columns matched, they can not be used to re-enable filtered columns. For example:</source>
          <target state="translated">列式过滤器规格也可以应用于括号中的任意表达式。在这种情况下,列过滤器适用于表达式中的所有短语。嵌套的列过滤器操作只能进一步限制匹配的列子集,它们不能用来重新启用过滤的列。例如</target>
        </trans-unit>
        <trans-unit id="8cf5932e078596670c3be6928bc34be28df50868" translate="yes" xml:space="preserve">
          <source>Column names in UPDATE statements were case sensitive. This mistake has now been fixed.</source>
          <target state="translated">UPDATE语句中的列名是区分大小写的。现在这个错误已经被修正。</target>
        </trans-unit>
        <trans-unit id="c8e2e6347929b3f4a547cbe78f19fbf98ffe174e" translate="yes" xml:space="preserve">
          <source>Column names in the expressions of a DO UPDATE refer to the original unchanged value of the column, before the attempted INSERT. To use the value that would have been inserted had the constraint not failed, add the special &quot;excluded.&quot; table qualifier to the column name.</source>
          <target state="translated">DO UPDATE表达式中的列名指的是列的原始不变值,在尝试INSERT之前。要使用如果约束没有失败就会被插入的值,请在列名中添加特殊的 &quot;excluded.&quot;表限定符。</target>
        </trans-unit>
        <trans-unit id="032e3b2732306732c32848d470fa8748f95c6026" translate="yes" xml:space="preserve">
          <source>Column zColumn does not exist,</source>
          <target state="translated">列z列不存在。</target>
        </trans-unit>
        <trans-unit id="ce5679997a2153bf86b8f374126d7b829b91fac4" translate="yes" xml:space="preserve">
          <source>Column zColumn is part of an index, PRIMARY KEY or UNIQUE constraint and the blob is being opened for read/write access,</source>
          <target state="translated">Column zColumn是索引、primary key或unique约束的一部分,并且blob被打开进行读写访问。</target>
        </trans-unit>
        <trans-unit id="e8afcd3f4d854da704b3aef5efd35d7f5bc218f3" translate="yes" xml:space="preserve">
          <source>Column-separator is an optional column separator string. The default is the ASCII tab character \t.</source>
          <target state="translated">Column-separator是一个可选的列分隔符字符串。缺省值是ASCII标签字符 &quot;t&quot;。</target>
        </trans-unit>
        <trans-unit id="cf723c59b62a173547c39c3d661c4ee7c240bab1" translate="yes" xml:space="preserve">
          <source>Columns</source>
          <target state="translated">Columns</target>
        </trans-unit>
        <trans-unit id="56b17410d6d1be4171831dc03181ac757a05e7fe" translate="yes" xml:space="preserve">
          <source>Columns of type INTEGER PRIMARY KEY are actually used as the primary key in underlying B-Tree representation of the table.</source>
          <target state="translated">类型为INTEGER PRIMARY KEY的列实际上是作为表的底层B-Tree表示中的主键。</target>
        </trans-unit>
        <trans-unit id="2c97a82dbca5a469c866fbcfd4a0a433b2a0bbf3" translate="yes" xml:space="preserve">
          <source>ColumnsUsed</source>
          <target state="translated">ColumnsUsed</target>
        </trans-unit>
        <trans-unit id="7dbd619aad6c366ee15f8ec72b738cda247ce874" translate="yes" xml:space="preserve">
          <source>Combine the implementations of LIKE and GLOB into a single pattern-matching subroutine.</source>
          <target state="translated">将LIKE和GLOB的实现结合到一个模式匹配子程序中。</target>
        </trans-unit>
        <trans-unit id="1f542b583ad5e9c038e3b491fcfbca274b74980c" translate="yes" xml:space="preserve">
          <source>Combining all the code for SQLite into one big file makes SQLite easier to deploy &amp;mdash; there is just one file to keep track of. And because all code is in a single translation unit, compilers can do better inter-procedure optimization resulting in machine code that is between 5% and 10% faster.</source>
          <target state="translated">将SQLite的所有代码组合到一个大文件中，可使SQLite易于部署-仅需跟踪一个文件。而且由于所有代码都在一个翻译单元中，因此编译器可以更好地进行过程间优化，从而使机器代码的速度提高5％到10％。</target>
        </trans-unit>
        <trans-unit id="833e395a74a9048d3a6708096c9bceb3c4d61ab8" translate="yes" xml:space="preserve">
          <source>Comes with a standalone &lt;a href=&quot;cli&quot;&gt;command-line interface&lt;/a&gt; (CLI) client that can be used to administer SQLite databases.</source>
          <target state="translated">带有一个独立的&lt;a href=&quot;cli&quot;&gt;命令行界面&lt;/a&gt;（CLI）客户端，该客户端可用于管理SQLite数据库。</target>
        </trans-unit>
        <trans-unit id="606ffe665dbeafe4183539a3e178cfb9ca0e425d" translate="yes" xml:space="preserve">
          <source>Command Line Shell For SQLite</source>
          <target state="translated">SQLite的命令行外壳</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="0538dff4886a4148d161292cddf7f24f025bd278" translate="yes" xml:space="preserve">
          <source>Comments are not SQL commands, but can occur within the text of SQL queries passed to &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and related interfaces. Comments are treated as whitespace by the parser. Comments can begin anywhere whitespace can be found, including inside expressions that span multiple lines.</source>
          <target state="translated">注释不是SQL命令，但可以在传递给&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;和相关接口的SQL查询文本内出现。解析器将注释视为空白。注释可以在可以找到空格的任何地方开始，包括跨越多行的内部表达式。</target>
        </trans-unit>
        <trans-unit id="ce2337551468efeca0ed2bee143ae11b7529f35e" translate="yes" xml:space="preserve">
          <source>Comments can appear anywhere whitespace can occur, including inside expressions and in the middle of other SQL statements. Comments do not nest.</source>
          <target state="translated">注释可以出现在任何可以出现空格的地方,包括表达式内部和其他SQL语句的中间。注释不能嵌套。</target>
        </trans-unit>
        <trans-unit id="ffc61bb49c86bffaff083a2ed5fcbad20841a45a" translate="yes" xml:space="preserve">
          <source>Commit And Rollback Notification Callbacks</source>
          <target state="translated">提交和回滚通知回调</target>
        </trans-unit>
        <trans-unit id="b67528525c7cbe3a2bdfe091a15601f0cfe434dc" translate="yes" xml:space="preserve">
          <source>Commit the transaction started in step 2.</source>
          <target state="translated">提交步骤2中开始的交易。</target>
        </trans-unit>
        <trans-unit id="3e921ad8fb3469be1c1aae1e9c542f259ea843f7" translate="yes" xml:space="preserve">
          <source>Commit the transaction started on step 1 above.</source>
          <target state="translated">承诺以上步骤1开始的交易。</target>
        </trans-unit>
        <trans-unit id="dcb41d75c37afedd19b91ddeac8ef4a861184289" translate="yes" xml:space="preserve">
          <source>Committing a</source>
          <target state="translated">承诺</target>
        </trans-unit>
        <trans-unit id="ca50d239d0c5f707752157b74490a4762cc31cc1" translate="yes" xml:space="preserve">
          <source>Committing a Transaction</source>
          <target state="translated">承诺交易</target>
        </trans-unit>
        <trans-unit id="a6b2b4078078c94d88c10ba671b8570bcd19b64c" translate="yes" xml:space="preserve">
          <source>Committing a multi-file transaction.</source>
          <target state="translated">承诺多文件交易。</target>
        </trans-unit>
        <trans-unit id="938c8ff92d76193cdabf706c7c9bd4d6322fdb0d" translate="yes" xml:space="preserve">
          <source>Committing a read-write transaction.</source>
          <target state="translated">进行读写交易。</target>
        </trans-unit>
        <trans-unit id="7f07598efa7d083be720757f9b4819e013d7faa3" translate="yes" xml:space="preserve">
          <source>Committing a statement transaction.</source>
          <target state="translated">进行报表交易。</target>
        </trans-unit>
        <trans-unit id="3d0965b4050b33d43b6f8f1d0b90555ef5b6f358" translate="yes" xml:space="preserve">
          <source>Common Table Expressions or CTEs act like temporary &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt; that exist only for the duration of a single SQL statement. There are two kinds of common table expressions: &quot;ordinary&quot; and &quot;recursive&quot;. Ordinary common table expressions are helpful for making queries easier to understand by factoring subqueries out of the main SQL statement. Recursive common table expressions provide the ability to do hierarchical or recursive queries of trees and graphs, a capability that is not otherwise available in the SQL language.</source>
          <target state="translated">公用表表达式或CTE的作用类似于仅在单个SQL语句期间存在的临时&lt;a href=&quot;lang_createview&quot;&gt;视图&lt;/a&gt;。共有两种常见的表表达式：&amp;ldquo;普通&amp;rdquo;和&amp;ldquo;递归&amp;rdquo;。普通的公共表表达式通过将主查询中的子查询分解出来，有助于使查询更易于理解。递归公用表表达式提供了对树和图进行分层或递归查询的功能，而该功能在SQL语言中是不可用的。</target>
        </trans-unit>
        <trans-unit id="8d105cf44d3926289e65c1c83d8e37cb23fd049e" translate="yes" xml:space="preserve">
          <source>Compare</source>
          <target state="translated">Compare</target>
        </trans-unit>
        <trans-unit id="61bf40991dc6cf79e005a417dde1c212c92bf988" translate="yes" xml:space="preserve">
          <source>Compare the ages of two snapshot handles</source>
          <target state="translated">比较两个快照手柄的年龄</target>
        </trans-unit>
        <trans-unit id="c69b8e330786eb35150cb1cdb917926c81985161" translate="yes" xml:space="preserve">
          <source>Compare the ages of two snapshot handles.</source>
          <target state="translated">比较两个快照手柄的年龄。</target>
        </trans-unit>
        <trans-unit id="b7893f36396a39c33c9b065563149f1fc3b7de3a" translate="yes" xml:space="preserve">
          <source>Compare the values in register P1 and P3. If reg(P3)&amp;lt;reg(P1) then jump to address P2. Or if the SQLITE_STOREP2 flag is set in P5 store the result of comparison (0 or 1 or NULL) into register P2.</source>
          <target state="translated">比较寄存器P1和P3中的值。如果reg（P3）&amp;lt;reg（P1），则跳转到地址P2。或者，如果在P5中设置了SQLITE_STOREP2标志，则将比较结果（0或1或NULL）存储到寄存器P2中。</target>
        </trans-unit>
        <trans-unit id="64f72da6a28852747af852811f0159350ec037fd" translate="yes" xml:space="preserve">
          <source>Compare the values in register P1 and P3. If reg(P3)==reg(P1) then jump to address P2. Or if the SQLITE_STOREP2 flag is set in P5, then store the result of comparison in register P2.</source>
          <target state="translated">比较寄存器P1和P3中的值,如果reg(P3)==reg(P1),则跳转到地址P2。如果reg(P3)==reg(P1),则跳转到地址P2。或者如果在P5中设置了SQLITE_STOREP2标志,那么将比较结果存储在寄存器P2中。</target>
        </trans-unit>
        <trans-unit id="716736d76052378cdb4fa2fb220c0af66c296429" translate="yes" xml:space="preserve">
          <source>Compare two vectors of registers in reg(P1)..reg(P1+P3-1) (call this vector &quot;A&quot;) and in reg(P2)..reg(P2+P3-1) (&quot;B&quot;). Save the result of the comparison for use by the next &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; instruct.</source>
          <target state="translated">比较reg（P1）.. reg（P1 + P3-1）（称为此向量&amp;ldquo; A&amp;rdquo;）和reg（P2）.. reg（P2 + P3-1）（&amp;ldquo; B&amp;rdquo;）中寄存器的两个向量。保存比较结果，以供下一个&lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt;指令使用。</target>
        </trans-unit>
        <trans-unit id="83d5898be3634e470654cbd85b9deec85a9c9f73" translate="yes" xml:space="preserve">
          <source>Comparison affinity rules</source>
          <target state="translated">比较亲和力规则</target>
        </trans-unit>
        <trans-unit id="134badaaa974d64bb5437d6b34d1293f7d86554c" translate="yes" xml:space="preserve">
          <source>Comparison expressions</source>
          <target state="translated">表达方式的比较</target>
        </trans-unit>
        <trans-unit id="8f31c13dc4b4da5bf8cbe8bac8ef033f779731d8" translate="yes" xml:space="preserve">
          <source>Comparison with fts4</source>
          <target state="translated">与FTS4的比较</target>
        </trans-unit>
        <trans-unit id="5d60c7dd62fdcf4abcc61a6a7d335b7117968b4d" translate="yes" xml:space="preserve">
          <source>Compatibility</source>
          <target state="translated">Compatibility</target>
        </trans-unit>
        <trans-unit id="7637a56b8025cf4632b2ae465571d61372b6d40e" translate="yes" xml:space="preserve">
          <source>Compatibility node: Prior to SQLite version 3.28.0 (2019-04-16) only the --update option was supported but that option worked like --insert in that it always reinserted every file regardless of whether or not it had changed.</source>
          <target state="translated">兼容性节点。在SQLite 3.28.0版本(2019-04-16)之前,只支持--update选项,但该选项的工作原理和--insert一样,它总是重新插入每个文件,而不管文件是否发生了变化。</target>
        </trans-unit>
        <trans-unit id="633ffa201e66fd459288742adf70c255cf4ddcdc" translate="yes" xml:space="preserve">
          <source>Compile SQLite in an as-delivered configuration, without any special telemetry or debugging options.</source>
          <target state="translated">在按交付配置编译SQLite,没有任何特殊的遥测或调试选项。</target>
        </trans-unit>
        <trans-unit id="4435f0088179f3879b5ae857aab9a8517a3bf84a" translate="yes" xml:space="preserve">
          <source>Compile SQLite using the &lt;a href=&quot;compile#trusted_schema&quot;&gt;-DSQLITE_TRUSTED_SCHEMA=0&lt;/a&gt; compile-time option.</source>
          <target state="translated">使用&lt;a href=&quot;compile#trusted_schema&quot;&gt;-DSQLITE_TRUSTED_SCHEMA = 0&lt;/a&gt;编译时选项编译SQLite 。</target>
        </trans-unit>
        <trans-unit id="47c942ddb7cb0b2c2a634cd495a4fe44be7c77ab" translate="yes" xml:space="preserve">
          <source>Compile SQLite using the &lt;a href=&quot;compile#trusted_schema&quot;&gt;-DSQLITE_TRUSTED_SCHEMA=0&lt;/a&gt; compile-time option. This make SQLite distrust application-defined functions inside of the schema by default.</source>
          <target state="translated">使用&lt;a href=&quot;compile#trusted_schema&quot;&gt;-DSQLITE_TRUSTED_SCHEMA = 0&lt;/a&gt;编译时选项编译SQLite 。默认情况下，这会使SQLite不信任架构内部的应用程序定义的函数。</target>
        </trans-unit>
        <trans-unit id="7a5b8e5cc0e47f26d2d005f2486e0f5c2a2c206c" translate="yes" xml:space="preserve">
          <source>Compile fts</source>
          <target state="translated">编制fts</target>
        </trans-unit>
        <trans-unit id="107e25274d1b787330bb17ec68cf503455bc4672" translate="yes" xml:space="preserve">
          <source>Compile the SQLite library with the either the compile-time options &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=1&lt;/a&gt; or &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=2&lt;/a&gt;. Support for 8+3 filenames is not included in SQLite by default because it does introduce some overhead. The overhead is tiny, but even so, we do not want to burden the billions of SQLite applications that do not need 8+3 filename support.</source>
          <target state="translated">使用编译时选项&lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 1&lt;/a&gt;或&lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 2&lt;/a&gt;编译SQLite库。默认情况下，SQLite不包括对8 + 3文件名的支持，因为这确实会带来一些开销。开销很小，但是即使如此，我们也不想负担不需要8 + 3文件名支持的数十亿个SQLite应用程序的负担。</target>
        </trans-unit>
        <trans-unit id="c8149cd52fe785ecf8f59126442a4f04b3761167" translate="yes" xml:space="preserve">
          <source>Compile-Time Authorization Callbacks</source>
          <target state="translated">编译时的授权回调</target>
        </trans-unit>
        <trans-unit id="5ce286997996977a2b237b29a86f8db1efc35204" translate="yes" xml:space="preserve">
          <source>Compile-Time Library Version Numbers</source>
          <target state="translated">编译时库版本号</target>
        </trans-unit>
        <trans-unit id="ab7d35e46c49beab638f326c5a28b5f3ad2b8c85" translate="yes" xml:space="preserve">
          <source>Compile-time Options</source>
          <target state="translated">编译时选项</target>
        </trans-unit>
        <trans-unit id="1453f0519dea087605be7dc19703a1f478ff0ab3" translate="yes" xml:space="preserve">
          <source>Compile-time options OS_UNIX, OS_WIN, OS_OS2, OS_OTHER, and TEMP_STORE have been renamed to include an &quot;SQLITE_&quot; prefix in order to help avoid namespace collisions with application software. The new names of these options are respectively: SQLITE_OS_UNIX, SQLITE_OS_WIN, SQLITE_OS_OS2, SQLITE_OS_OTHER, and &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;.</source>
          <target state="translated">编译时选项OS_UNIX，OS_WIN，OS_OS2，OS_OTHER和TEMP_STORE已重命名为包括&amp;ldquo; SQLITE_&amp;rdquo;前缀，以帮助避免名称空间与应用程序软件冲突。这些选项的新名称分别为：SQLITE_OS_UNIX，SQLITE_OS_WIN，SQLITE_OS_OS2，SQLITE_OS_OTHER和&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b67395ae5988ac5f1079e7140abc23ed771501d4" translate="yes" xml:space="preserve">
          <source>Compile-time options to SQLite are controlled by C-preprocessor macros. SQLite version 3.6.0 changes the names of some of these macros so that all C-preprocessor macros that are specific to SQLite begin with the &quot;SQLITE_&quot; prefix. This is done to reduce the risk of name collisions with other software modules.</source>
          <target state="translated">SQLite的编译时选项是由C-预处理程序宏控制的。SQLite 3.6.0版本改变了其中一些宏的名称,使所有特定于SQLite的C-预处理程序宏都以 &quot;SQLITE_&quot;前缀开头。这样做的目的是为了减少与其他软件模块发生名称冲突的风险。</target>
        </trans-unit>
        <trans-unit id="7bfb67af50943c68cc8db4a086f448c070c20b10" translate="yes" xml:space="preserve">
          <source>Compiling An SQL Statement</source>
          <target state="translated">编译SQL语句</target>
        </trans-unit>
        <trans-unit id="5aad775a4fde57c9a7d789da7ebb4f28bacbccb3" translate="yes" xml:space="preserve">
          <source>Compiling Loadable Extensions</source>
          <target state="translated">编译可加载扩展程序</target>
        </trans-unit>
        <trans-unit id="17dae604367670c84a2179095a23e948fe606538" translate="yes" xml:space="preserve">
          <source>Compiling the CLI</source>
          <target state="translated">编译CLI</target>
        </trans-unit>
        <trans-unit id="42bc083c37979291f51503e346021e5adf7ef736" translate="yes" xml:space="preserve">
          <source>Compiling the TCL interface</source>
          <target state="translated">编译TCL接口</target>
        </trans-unit>
        <trans-unit id="f6b7336de511d34be1007604b55dc1686fbabd26" translate="yes" xml:space="preserve">
          <source>Compiling with GCC and -Os results in a binary that is slightly less than 500KB in size. (Update 2018-07-07: Due to the addition of new features such as &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt; and &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;, the library footprint is now slightly larger than 500KB.)</source>
          <target state="translated">使用GCC和-Os进行编译会导致二进制文件的大小略小于500KB。（更新2018-07-07：由于增加了&lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt;和&lt;a href=&quot;windowfunctions&quot;&gt;窗口功能&lt;/a&gt;等新功能，库的占用空间现在略大于500KB。）</target>
        </trans-unit>
        <trans-unit id="016600cc08f9b09c5ede26e00051860d386d3258" translate="yes" xml:space="preserve">
          <source>Completely disable all mutexing for use in single-threaded applications.</source>
          <target state="translated">在单线程应用程序中完全禁用所有的互斥。</target>
        </trans-unit>
        <trans-unit id="92cab31e763f04f0a9379d06fa22ebdf435b210d" translate="yes" xml:space="preserve">
          <source>Completion = 100% * (pagecount() - remaining()) / pagecount()</source>
          <target state="translated">完成度=100%*(页数()-剩余())/页数()</target>
        </trans-unit>
        <trans-unit id="0e8198cb08e14211a17b2113a2bd05ad2475de6d" translate="yes" xml:space="preserve">
          <source>Complex SQL queries that compile down to large &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;.</source>
          <target state="translated">复杂的SQL查询可编译为大型&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a71a43f0af5e946760833a731194bc756332728" translate="yes" xml:space="preserve">
          <source>Component tables must not be declared WITHOUT ROWID, and must all have the same schema, but may have different names within their databases. In this context, &quot;the same schema&quot; means that:</source>
          <target state="translated">组成表不得声明without ROWID,而且必须都有相同的模式,但在其数据库中可以有不同的名称。在这里,&quot;同一模式 &quot;是指:</target>
        </trans-unit>
        <trans-unit id="73fefbebc7ea5875c1b1def30f50ddaec200fca3" translate="yes" xml:space="preserve">
          <source>Compound SELECT Statements</source>
          <target state="translated">复合SELECT语句</target>
        </trans-unit>
        <trans-unit id="fc1dbf04d5c2c01646f4f6f5a41a610a2c9e6452" translate="yes" xml:space="preserve">
          <source>Compound SELECT statements joined by UNION, EXCEPT, or INTERSECT</source>
          <target state="translated">由UNION、EXCEPT或INTERSECT连接的复合SELECT语句。</target>
        </trans-unit>
        <trans-unit id="b777b90633cd6198da59fc74556aaf318e15c82b" translate="yes" xml:space="preserve">
          <source>Compound Select Statements</source>
          <target state="translated">复合选择语句</target>
        </trans-unit>
        <trans-unit id="41afde278d24cef38341e9c639a6f290a66a33e9" translate="yes" xml:space="preserve">
          <source>Compound select</source>
          <target state="translated">化合物选择</target>
        </trans-unit>
        <trans-unit id="e99b67d469ceb0e0903f3fdb83544c4883bac6aa" translate="yes" xml:space="preserve">
          <source>Compressed FTS4 content</source>
          <target state="translated">压缩的FTS4内容</target>
        </trans-unit>
        <trans-unit id="d750266cb42e04add18c2049e2c2458292889a29" translate="yes" xml:space="preserve">
          <source>Compute all columns for the current row of the result.</source>
          <target state="translated">计算结果中当前行的所有列。</target>
        </trans-unit>
        <trans-unit id="83c78585de25cd96c1c2ab80c2c2412af55dbfdf" translate="yes" xml:space="preserve">
          <source>Compute the Mandelbrot set</source>
          <target state="translated">计算Mandelbrot集</target>
        </trans-unit>
        <trans-unit id="b448f9527d237644e1fc4a194d188e6a4b4d1334" translate="yes" xml:space="preserve">
          <source>Compute the current date.</source>
          <target state="translated">计算当前日期。</target>
        </trans-unit>
        <trans-unit id="41873a1f5500f4b614234079571f3016e43ab82f" translate="yes" xml:space="preserve">
          <source>Compute the current unix timestamp.</source>
          <target state="translated">计算当前的unix时间戳。</target>
        </trans-unit>
        <trans-unit id="e04bc35c7b102a71d56a8c32d3bd5fac01970545" translate="yes" xml:space="preserve">
          <source>Compute the date and time given a unix timestamp 1092941466, and compensate for your local timezone.</source>
          <target state="translated">计算给定的unix时间戳1092941466的日期和时间,并补偿当地的时区。</target>
        </trans-unit>
        <trans-unit id="a79ce5022e7222955180721f104a747e76cc865d" translate="yes" xml:space="preserve">
          <source>Compute the date and time given a unix timestamp 1092941466.</source>
          <target state="translated">计算给定unix时间戳1092941466的日期和时间。</target>
        </trans-unit>
        <trans-unit id="876432c3d5981b5bb35c00fb0bc71a0643cea495" translate="yes" xml:space="preserve">
          <source>Compute the date of the first Tuesday in October for the current year.</source>
          <target state="translated">计算当年10月第一个星期二的日期。</target>
        </trans-unit>
        <trans-unit id="85e08c9c66c5c14d3d7f7fdaf91b03031363b7fc" translate="yes" xml:space="preserve">
          <source>Compute the hash value: h = P * 383</source>
          <target state="translated">计算哈希值:h=P*383</target>
        </trans-unit>
        <trans-unit id="7548a41024e6603fd25f9fadf45476eb046bf623" translate="yes" xml:space="preserve">
          <source>Compute the last day of the current month.</source>
          <target state="translated">计算当月的最后一天。</target>
        </trans-unit>
        <trans-unit id="1c0a0d1208aea03d34c1fcb88dbad15854e8464f" translate="yes" xml:space="preserve">
          <source>Compute the number of days since the signing of the US Declaration of Independence.</source>
          <target state="translated">计算美国《独立宣言》签署后的天数。</target>
        </trans-unit>
        <trans-unit id="5d82004a2aadc6ec6baebba8982b8bfbd8ed18a8" translate="yes" xml:space="preserve">
          <source>Compute the number of seconds since a particular moment in 2004:</source>
          <target state="translated">计算2004年某一时刻以来的秒数。</target>
        </trans-unit>
        <trans-unit id="9240e490f170f5bfe9b5ac2684f082567e717920" translate="yes" xml:space="preserve">
          <source>Compute the remainder after integer register P2 is divided by register P1 and store the result in register P3. If the value in register P1 is zero the result is NULL. If either operand is NULL, the result is NULL.</source>
          <target state="translated">计算整数寄存器P2除以寄存器P1后的余数,并将结果存储在寄存器P3中。如果寄存器P1中的值为0,则结果为NULL。如果其中一个操作数为NULL,则结果为NULL。</target>
        </trans-unit>
        <trans-unit id="f47380023b575b27550d43814811cc725e477ad2" translate="yes" xml:space="preserve">
          <source>Compute the time since the unix epoch in seconds (like strftime('%s','now') except includes fractional part):</source>
          <target state="translated">计算自unix纪元以来的时间,以秒为单位(像strftime('%s','now'),除了包括小数部分)。</target>
        </trans-unit>
        <trans-unit id="e144db42c7fe7841a847f92a642087b247050e3f" translate="yes" xml:space="preserve">
          <source>Compute the transitive closure of a set.</source>
          <target state="translated">计算一个集合的转折性闭合。</target>
        </trans-unit>
        <trans-unit id="6ad79ab6353b1eee8ebbc085e10d17c4fcfb024f" translate="yes" xml:space="preserve">
          <source>Concat</source>
          <target state="translated">Concat</target>
        </trans-unit>
        <trans-unit id="bbae6853fb6e0fd40e4ce00a77adbb0072630198" translate="yes" xml:space="preserve">
          <source>Concatenate Two Changeset Objects</source>
          <target state="translated">连接两个变化集对象</target>
        </trans-unit>
        <trans-unit id="dbcb0f9023d09dcdfc6e54ecf5de70332ecf46a5" translate="yes" xml:space="preserve">
          <source>Conceptually, the wal-index is shared memory, though the current VFS implementations use a memory-mapped file for operating-system portability. The memory-mapped file is in the same directory as the database and has the same name as the database with a &quot;&lt;code&gt;-shm&lt;/code&gt;&quot; suffix appended. Because the wal-index is shared memory, SQLite does not support &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode=WAL&lt;/a&gt; on a network filesystem when clients are on different machines, as all clients of the database must be able to share the same memory.</source>
          <target state="translated">从概念上讲，wal-index是共享内存，尽管当前的VFS实现使用内存映射文件来实现操作系统的可移植性。内存映射文件与数据库位于同一目录中，并且与数据库名称相同，后缀为&amp;ldquo; &lt;code&gt;-shm&lt;/code&gt; &amp;rdquo;。因为wal-index是共享内存，所以当客户端位于不同计算机上时，SQLite 在网络文件系统上不支持&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode = WAL&lt;/a&gt;，因为数据库的所有客户端必须能够共享同一内存。</target>
        </trans-unit>
        <trans-unit id="49b7441ed47d615d68b5fa69e66989fb88012252" translate="yes" xml:space="preserve">
          <source>Conceptually, there is just a single DELETE-mode lock. The DELETE-mode lock for a single database connection can be in exactly one of the following states:</source>
          <target state="translated">从概念上讲,只有一个DELETE模式的锁。单个数据库连接的DELETE模式锁完全可以处于以下状态之一。</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="7a3f4c2c7a172166630a7d362c10fe1d0fc91c29" translate="yes" xml:space="preserve">
          <source>Concurrent Use By Multiple Processes</source>
          <target state="translated">多进程并发使用</target>
        </trans-unit>
        <trans-unit id="eef82957c155636f622355147508a53bea076447" translate="yes" xml:space="preserve">
          <source>Configurable edit distances</source>
          <target state="translated">可配置的编辑距离</target>
        </trans-unit>
        <trans-unit id="b8577c99aaca7f628cb921ee68fce4bf962909c4" translate="yes" xml:space="preserve">
          <source>Configuration Options</source>
          <target state="translated">配置选项</target>
        </trans-unit>
        <trans-unit id="e6080fcd15996fc8da790077d2f333df934dd233" translate="yes" xml:space="preserve">
          <source>Configuration continues to use the SQLITE_DBCONFIG_LOOKASIDE or SQLITE_CONFIG_LOOKASIDE configuration options, as described above, with parameters &quot;sz&quot; and &quot;cnt&quot;. The total heap space used for lookaside continues to be sz*cnt bytes. But the space is allocated between the small-slot lookaside and big-slot lookaside, with preference given to small-slot lookaside. The total number of slots will usually exceed &quot;cnt&quot;, since &quot;sz&quot; is typically much larger than the small-slot size of 128 bytes.</source>
          <target state="translated">配置继续使用SQLITE_DBCONFIG_LOOKASIDE或SQLITE_CONFIG_LOOKASIDE配置选项,如上所述,参数为 &quot;sz &quot;和 &quot;cnt&quot;。用于lookaside的总堆空间仍然是sz*cnt字节。但空间分配在小槽lookaside和大槽lookaside之间,优先选择小槽lookaside。由于 &quot;sz &quot;通常比128字节的小槽大小大得多,所以槽的总数通常会超过 &quot;cnt&quot;。</target>
        </trans-unit>
        <trans-unit id="5d3a088dea7acb9fc65cbb6e86dc351c6aa1d47c" translate="yes" xml:space="preserve">
          <source>Configure a changeset rebaser object</source>
          <target state="translated">配置一个改变集rebaser对象</target>
        </trans-unit>
        <trans-unit id="c2e506c363291ec2edbc4c00e46f58bf68ba2d4e" translate="yes" xml:space="preserve">
          <source>Configure a changeset rebaser object.</source>
          <target state="translated">配置一个改变集rebaser对象。</target>
        </trans-unit>
        <trans-unit id="1cfd39d93ce243f8209e2cb0fd6a72bd5199a441" translate="yes" xml:space="preserve">
          <source>Configure an auto-checkpoint</source>
          <target state="translated">配置自动检查点</target>
        </trans-unit>
        <trans-unit id="5cda84f2fffb92ec6200fae3e17f21d369027339" translate="yes" xml:space="preserve">
          <source>Configure database connections</source>
          <target state="translated">配置数据库连接</target>
        </trans-unit>
        <trans-unit id="9104fdd73ba3ec2b0c456f6d3cca5876e340e73f" translate="yes" xml:space="preserve">
          <source>Configure global parameters</source>
          <target state="translated">配置全局参数</target>
        </trans-unit>
        <trans-unit id="fffa5ae7207c4ce72ae9a5c16488369d68b30ee7" translate="yes" xml:space="preserve">
          <source>Configure the changeset rebaser object to rebase changesets according to the conflict resolutions described by buffer pRebase (size nRebase bytes), which must have been obtained from a previous call to sqlite3changeset_apply_v2().</source>
          <target state="translated">配置changeset rebaser对象,根据缓冲区pRebase(大小为nRebase字节)所描述的冲突解决方法对变化集进行重定位,该缓冲区必须从之前对sqlite3changeset_apply_v2()的调用中获得。</target>
        </trans-unit>
        <trans-unit id="037fffb22a00fbc77fceb8bfd136c7237a83b229" translate="yes" xml:space="preserve">
          <source>Configuring Memory-Mapped I/O</source>
          <target state="translated">配置内存映射I/O</target>
        </trans-unit>
        <trans-unit id="9d3bc7d832ae044f63c47a2f9e7fae292f78d77f" translate="yes" xml:space="preserve">
          <source>Configuring The SQLite Library</source>
          <target state="translated">配置SQLite库</target>
        </trans-unit>
        <trans-unit id="3479acef100487d6ec8205ddc884e90381568fa7" translate="yes" xml:space="preserve">
          <source>Configuring an ON UPDATE or ON DELETE action does not mean that the foreign key constraint does not need to be satisfied. For example, if an &quot;ON DELETE SET DEFAULT&quot; action is configured, but there is no row in the parent table that corresponds to the default values of the child key columns, deleting a parent key while dependent child keys exist still causes a foreign key violation. For example:</source>
          <target state="translated">配置 &quot;ON UPDATE &quot;或 &quot;ON DELETE &quot;操作,并不意味着不需要满足外键约束。例如,如果配置了 &quot;ON DELETE SET DEFAULT &quot;操作,但父表中没有与子键列的默认值相对应的记录,那么在依赖的子键存在的情况下删除父键仍然会引起外键违规。例如</target>
        </trans-unit>
        <trans-unit id="377ada5c437e4e8ecbb86b359c764c7d510c3e88" translate="yes" xml:space="preserve">
          <source>Conflict Resolution Algorithms</source>
          <target state="translated">冲突解决算法</target>
        </trans-unit>
        <trans-unit id="8975355354bcb513bcd2981e89b88a2159127a86" translate="yes" xml:space="preserve">
          <source>Conflict resolution modes</source>
          <target state="translated">解决冲突的模式</target>
        </trans-unit>
        <trans-unit id="9658bf354692dbe100fe5694b8f321b7b117d4a0" translate="yes" xml:space="preserve">
          <source>Conflict-algorithm must be one of the SQLite conflict algorithms for the INSERT statement:</source>
          <target state="translated">冲突算法必须是INSERT语句的SQLite冲突算法之一。</target>
        </trans-unit>
        <trans-unit id="af76481a91ddbca2a009d9ab58cd9c8e2ed5ef31" translate="yes" xml:space="preserve">
          <source>Connections hold an exclusive lock when change in between WAL mode and any of the various rollback-modes. Connections might also attempt to obtain an EXCLUSIVE lock when they disconnect from WAL mode. If a connection is able to obtain an EXCLUSIVE lock, that means it is the only connection to the database and so it may attempt to checkpoint and then delete the WAL-index and WAL files.</source>
          <target state="translated">当在WAL模式和任何一种回滚模式之间转换时,连接持有一个专属锁。当连接从WAL模式断开连接时,也可能会试图获得一个专属锁。如果一个连接能够获得一个专属锁,那就意味着它是数据库的唯一连接,因此它可能会尝试检查点,然后删除WAL-index和WAL文件。</target>
        </trans-unit>
        <trans-unit id="aec1d9b262374bdba4b3ad5a6350b6ef2fd31b30" translate="yes" xml:space="preserve">
          <source>Consider a different database with &quot;CREATE TABLE big(json JSON)&quot;. To see a complete line-by-line decomposition of the data:</source>
          <target state="translated">考虑换一个数据库,用 &quot;CREATE TABLE big(json JSON)&quot;。要看到完整的数据逐行分解。</target>
        </trans-unit>
        <trans-unit id="89d5e40d39c9d5acb3a34ddf23480e47ca55947d" translate="yes" xml:space="preserve">
          <source>Consider a slightly different scenario:</source>
          <target state="translated">考虑一个稍微不同的情况。</target>
        </trans-unit>
        <trans-unit id="c5d0d6c9988bc87a91e1eceb2b1190187ebda45c" translate="yes" xml:space="preserve">
          <source>Consider a table (shown below) intended to store a vocabulary of words together with a count of the number of occurrences of each word in some text corpus:</source>
          <target state="translated">考虑一个表格(如下图所示),旨在存储一个词汇表以及每个词在某个文本语料库中的出现次数统计。</target>
        </trans-unit>
        <trans-unit id="8ec68a1b2150a873bc929bf5c86810425d54b691" translate="yes" xml:space="preserve">
          <source>Consider a table such as the following:</source>
          <target state="translated">考虑如下表格:</target>
        </trans-unit>
        <trans-unit id="163f9a2c7a0b11befe42d8af38ac3f4e6b7bc949" translate="yes" xml:space="preserve">
          <source>Consider a table that describes the members of an organization as well as the chain-of-command within that organization:</source>
          <target state="translated">考虑用一张表来描述一个组织的成员以及该组织内部的指挥链。</target>
        </trans-unit>
        <trans-unit id="4d89aaebca400a1430435ad2d544ef0799645f0e" translate="yes" xml:space="preserve">
          <source>Consider an example. Suppose you are trying to insert a string value into a database table where the string value was obtained from user input. Suppose the string to be inserted is stored in a variable named zString. The code to do the insertion might look like this:</source>
          <target state="translated">考虑一个例子。假设你正试图将一个字符串值插入到一个数据库表中,其中的字符串值是从用户输入中获得的。假设要插入的字符串存储在一个名为zString的变量中。进行插入的代码可能是这样的。</target>
        </trans-unit>
        <trans-unit id="968f255a5a54f60fb698955e4fcb28ea4353bc5f" translate="yes" xml:space="preserve">
          <source>Consider explicit collate clauses when matching WHERE constraints to indices in the query optimizer. Ticket #2391</source>
          <target state="translated">当在查询优化器中匹配WHERE约束条件到索引时,考虑显式整理子句。Ticket #2391</target>
        </trans-unit>
        <trans-unit id="444e122b76db00a9b4c3d12c64b80faed572e3e1" translate="yes" xml:space="preserve">
          <source>Consider how this query works. The initial-select runs first and returns a single row with a single column &quot;1&quot;. This one row is added to the queue. In step 2a, that one row is extracted from the queue and added to &quot;cnt&quot;. Then the recursive-select is run in accordance with step 2c generating a single new row with value &quot;2&quot; to add to the queue. The queue still has one row, so step 2 repeats. The &quot;2&quot; row is extracted and added to the recursive table by steps 2a and 2b. Then the row containing 2 is used as if it were the complete content of the recursive table and the recursive-select is run again, resulting in a row with value &quot;3&quot; being added to the queue. This repeats 999999 times until finally at step 2a the only value on the queue is a row containing 1000000. That row is extracted and added to the recursive table. But this time, the WHERE clause causes the recursive-select to return no rows, so the queue remains empty and the recursion stops.</source>
          <target state="translated">考虑一下这个查询是如何工作的。Initial-select首先运行,并返回一条单列 &quot;1 &quot;的记录。这一条记录被添加到队列中。在步骤2a中,这一行从队列中提取出来,并添加到 &quot;cnt &quot;中。然后按照步骤2c运行递归选择,生成一条新的具有 &quot;2 &quot;值的行添加到队列中。队列中仍然有一条记录,所以重复步骤2。通过步骤2a和2b提取 &quot;2 &quot;行并添加到递归表中。然后将包含2的行当作递归表的完整内容使用,并再次运行递归选择,结果一条值为 &quot;3 &quot;的行被添加到队列中。这样重复999999次,直到最后在步骤2a处,队列上只有一条包含1000000的值的行。这条记录被提取出来并添加到递归表中。但是这一次,WHERE子句导致递归选择没有返回任何行,所以队列仍然是空的,递归停止。</target>
        </trans-unit>
        <trans-unit id="f8fa74d8815f89442ddf62f70a180b631fe1665c" translate="yes" xml:space="preserve">
          <source>Consider querying this table to find the number of occurrences of the word &quot;xyzzy&quot;.:</source>
          <target state="translated">考虑查询这张表,找出 &quot;xyzzy &quot;这个词的出现次数。</target>
        </trans-unit>
        <trans-unit id="8e332dd9034fe99b489d4794d57d3e6f28bfd9ef" translate="yes" xml:space="preserve">
          <source>Consider the following SQL:</source>
          <target state="translated">考虑以下SQL。</target>
        </trans-unit>
        <trans-unit id="e890ad26c51af96d02d41774ffeaa333b700b830" translate="yes" xml:space="preserve">
          <source>Consider the following two command sequences:</source>
          <target state="translated">考虑以下两个命令序列。</target>
        </trans-unit>
        <trans-unit id="38f2ce12e9214d8cde3ab5b6d1808e89b342965a" translate="yes" xml:space="preserve">
          <source>Consider using the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface to limit the scope of SQL that will be processed. For example, an application that does not need to change the database schema might add an sqlite3_set_authorizer() callback that causes any CREATE or DROP statement to fail.</source>
          <target state="translated">考虑使用&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;接口来限制将要处理的SQL的范围。例如，不需要更改数据库架构的应用程序可以添加sqlite3_set_authorizer（）回调，该回调导致任何CREATE或DROP语句失败。</target>
        </trans-unit>
        <trans-unit id="3f881ec6e1c51116405b7bd7506d06d9368faea1" translate="yes" xml:space="preserve">
          <source>Consider what would happen if disk sector writes are interrupted by a power loss. If an application writes two or three bytes in the middle of some file, the operating system will implement this by first reading the entire sector containing those bytes, making the change to the sector in memory, then writing the entire sector back to the disk. If a power loss occurs during the writeback and the sector was not completely written, then on the next read after reboot, error correcting codes in the sector will probably detect irreparable damage and the disk controller will read out the sector as all zeros or all ones. Thus values will have changed outside of the range of the two or three bytes that were written at the application level - a violation of the powersafe overwrite property.</source>
          <target state="translated">考虑一下如果磁盘扇区写入因断电而中断会发生什么。如果一个应用程序在某个文件中间写了两三个字节,操作系统会通过先读取包含这些字节的整个扇区,在内存中对扇区进行修改,然后将整个扇区写回磁盘来实现。如果在回写过程中发生了断电,扇区没有被完全写入,那么在重启后的下一次读取时,扇区中的纠错代码很可能会检测到不可修复的损坏,磁盘控制器会将扇区读出全部为0或全部为1。这样一来,值就会在应用层写入的两三个字节的范围外发生变化--这就违反了powerafe overwrite属性。</target>
        </trans-unit>
        <trans-unit id="454478261b68992469d64496e9cfb5f053cfbed3" translate="yes" xml:space="preserve">
          <source>Console the sorrowing.</source>
          <target state="translated">安慰悲痛的人。</target>
        </trans-unit>
        <trans-unit id="c51c1399ff5b435aa7c4c51efe988981e74f0189" translate="yes" xml:space="preserve">
          <source>Constant value 0.</source>
          <target state="translated">定值0。</target>
        </trans-unit>
        <trans-unit id="f14defda3a0615f9817e1062360bb6f9e7654bb6" translate="yes" xml:space="preserve">
          <source>Constant value 1. This field is omitted for any term-offset list associated with column 0.</source>
          <target state="translated">常量值1。对于与第0栏相关的任何术语偏移量清单,此字段被省略。</target>
        </trans-unit>
        <trans-unit id="f7d639ba9c48f5467c4d1a8f0152a2dc90222051" translate="yes" xml:space="preserve">
          <source>Constants Defining Special Destructor Behavior</source>
          <target state="translated">定义特殊破坏者行为的常量。</target>
        </trans-unit>
        <trans-unit id="af7e74633bc458147e8d5da16df8562d003b392e" translate="yes" xml:space="preserve">
          <source>Constants Passed To The Conflict Handler</source>
          <target state="translated">传递给冲突处理程序的常量</target>
        </trans-unit>
        <trans-unit id="aa0aeb15b7dcd6d473c7d1bf166a40ca61fee668" translate="yes" xml:space="preserve">
          <source>Constants Returned By The Conflict Handler</source>
          <target state="translated">冲突处理程序返回的常量</target>
        </trans-unit>
        <trans-unit id="6337f09e95dde3b3b58675d8b6f0257adf22ba40" translate="yes" xml:space="preserve">
          <source>Constants:</source>
          <target state="translated">Constants:</target>
        </trans-unit>
        <trans-unit id="f37e46006a1745cf96ebe1f73c1de5744dcf1d1d" translate="yes" xml:space="preserve">
          <source>Constraint Conflict Resolution in SQLite</source>
          <target state="translated">SQLite中的约束冲突解决</target>
        </trans-unit>
        <trans-unit id="6889aa68d48cec7c8c38bf28801d4701520ff0dc" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt;</source>
          <target state="translated">构造函数：&lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a878fca8a43e71d4ec596dfa4ec029c0c81a75d0" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt;</source>
          <target state="translated">构造函数：&lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a2c5628cdcd91822efac04edcb216499727358f" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;</source>
          <target state="translated">构造函数：&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1cdc0adde4d7b415af1d0d33bde5ec5e8f55638" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3changegroup_new&quot;&gt;sqlite3changegroup_new()&lt;/a&gt;</source>
          <target state="translated">构造函数：&lt;a href=&quot;#sqlite3changegroup_new&quot;&gt;sqlite3changegroup_new（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d43a93e241e64f205e9be40e6849d360ecb314d2" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt;</source>
          <target state="translated">构造函数：&lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06e9fffe66b7ccd965b3d8281c4189b6873e699b" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt;</source>
          <target state="translated">构造函数：&lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e898f79bdd10cd47ee3054a83ab75f61437a7aa4" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt;</source>
          <target state="translated">构造函数：&lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="08db86cfe6351f2012dbf46992a9fa7d1631a5e2" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;sqlite3changegroup_new&quot;&gt;sqlite3changegroup_new()&lt;/a&gt;</source>
          <target state="translated">构造函数：&lt;a href=&quot;sqlite3changegroup_new&quot;&gt;sqlite3changegroup_new（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="38014e350b2ec610dc63ea6835bc8bf20566c178" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt;</source>
          <target state="translated">构造函数：&lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f94c6d14960e90153f9e56ef05e080f43ace38fd" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;</source>
          <target state="translated">构造函数：&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3617dc14ae8be730219fa2aabd32aaa900ccfc3a" translate="yes" xml:space="preserve">
          <source>Constructors: &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;</source>
          <target state="translated">构造函数：&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b2da4ffc9b2e344254d3be3ef8d1b5463c6c55d3" translate="yes" xml:space="preserve">
          <source>Constructors: &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;, &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2()&lt;/a&gt;</source>
          <target state="translated">构造函数：&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b84725656dbaa01e32202bf862175e15f3aa743" translate="yes" xml:space="preserve">
          <source>Constructors: &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;</source>
          <target state="translated">构造函数：&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;open&quot;&gt;sqlite3_open16（）&lt;/a&gt;，&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63842448f26d096823a3c51f076ae6fb704d1709" translate="yes" xml:space="preserve">
          <source>Constructors: &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;, &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2()&lt;/a&gt;</source>
          <target state="translated">构造函数：&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;，&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e8adbf806de9adae308cb1a722a2834efb03d01" translate="yes" xml:space="preserve">
          <source>Contains the actual data inserted into the FTS5 table. This shadow table is not present for &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless&lt;/a&gt; or &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content&lt;/a&gt; FTS5 tables.</source>
          <target state="translated">包含插入FTS5表中的实际数据。这个影子表不存在用于&lt;a href=&quot;fts5#contentless_tables&quot;&gt;无内容&lt;/a&gt;或&lt;a href=&quot;fts5#external_content_tables&quot;&gt;外部内容&lt;/a&gt; FTS5表。</target>
        </trans-unit>
        <trans-unit id="6773795897579cbc7647c6d1ac1d4b8bc25387d4" translate="yes" xml:space="preserve">
          <source>Contains the size of each column of each row in the virtual table in tokens. This shadow table is not present if the &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;columnsize&quot; option&lt;/a&gt; is set to 0.</source>
          <target state="translated">包含令牌中虚拟表中每一行每一列的大小。如果&lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&amp;ldquo; columnsize&amp;rdquo;选项&lt;/a&gt;设置为0 ，则此影子表不存在。</target>
        </trans-unit>
        <trans-unit id="c6336221afe18ddc0e53b18acd141d3c916c6884" translate="yes" xml:space="preserve">
          <source>Contains the text of the term for this row.</source>
          <target state="translated">包含本行术语的文本。</target>
        </trans-unit>
        <trans-unit id="8149ba57ba940e5c3672ef00fa60ad0d2afcb776" translate="yes" xml:space="preserve">
          <source>Contains the values of persistent configuration parameters.</source>
          <target state="translated">包含持久化配置参数的值。</target>
        </trans-unit>
        <trans-unit id="17ad25c1af7990d50b53a9e2d46ba0f493597884" translate="yes" xml:space="preserve">
          <source>Content Size</source>
          <target state="translated">内容大小</target>
        </trans-unit>
        <trans-unit id="311a2e63246045d0ca04704e25eb8fe09678745a" translate="yes" xml:space="preserve">
          <source>Content can be accessed and updated using concise SQL queries instead of lengthy and error-prone procedural routines.</source>
          <target state="translated">可以使用简洁的SQL查询来访问和更新内容,而不是使用冗长和容易出错的程序程序。</target>
        </trans-unit>
        <trans-unit id="54e6a597c2b0fe05466617946d21001a0e849ccf" translate="yes" xml:space="preserve">
          <source>Content can be updated continuously and atomically so that little or no work is lost in a power failure or crash.</source>
          <target state="translated">内容可以连续和原子化地更新,因此在断电或崩溃时几乎不会丢失工作。</target>
        </trans-unit>
        <trans-unit id="5a0ca8d8e7e6987ce002e1b9cc19498346916cd0" translate="yes" xml:space="preserve">
          <source>Content stored in an SQLite database is more likely to be recoverable decades in the future, long after all traces of the original application have been lost. Data lives longer than code.</source>
          <target state="translated">存储在SQLite数据库中的内容更有可能在未来数十年内恢复,而这是在原始应用的所有痕迹都消失之后的很长一段时间。数据的寿命比代码更长。</target>
        </trans-unit>
        <trans-unit id="2d4a0281b46f5532a617239a67837a43f539390e" translate="yes" xml:space="preserve">
          <source>Contentless FTS4 tables also support SELECT statements. However, it is an error to attempt to retrieve the value of any table column other than the docid column. The auxiliary function matchinfo() may be used, but snippet() and offsets() may not. For example:</source>
          <target state="translated">无内容的FTS4表也支持SELECT语句。但是,如果试图检索除docid列以外的任何表列的值,都是一个错误。辅助函数matchinfo()可以使用,但snippet()和offsets()不能使用。例如</target>
        </trans-unit>
        <trans-unit id="466e0c80c6a0ee6d90e9a1cf84c5c7f81c6af7ec" translate="yes" xml:space="preserve">
          <source>Contentless FTS5 tables do not support UPDATE or DELETE statements, or INSERT statements that do not supply a non-NULL value for the rowid field. Contentless tables do not support REPLACE conflict handling. REPLACE and INSERT OR REPLACE statements are treated as regular INSERT statements. Rows may be deleted from a contentless table using an &lt;a href=&quot;fts5#the_delete_command&quot;&gt;FTS5 delete command&lt;/a&gt;.</source>
          <target state="translated">无内容的FTS5表不支持UPDATE或DELETE语句，或者不为rowid字段提供非NULL值的INSERT语句。无内容表不支持REPLACE冲突处理。REPLACE和INSERT OR REPLACE语句被视为常规INSERT语句。可以使用&lt;a href=&quot;fts5#the_delete_command&quot;&gt;FTS5 delete命令&lt;/a&gt;从无内容表中删除行。</target>
        </trans-unit>
        <trans-unit id="450f660f2dc175257d82b71bd1a3662299271f61" translate="yes" xml:space="preserve">
          <source>Contentless fts4 tables</source>
          <target state="translated">无内容的fts4表</target>
        </trans-unit>
        <trans-unit id="f5cbdf6bfb51439be085b5c6b7460a7c91eabc3c" translate="yes" xml:space="preserve">
          <source>Contents</source>
          <target state="translated">Contents</target>
        </trans-unit>
        <trans-unit id="38c62e79a8a690e9f86401a7b90826fac3d70fe4" translate="yes" xml:space="preserve">
          <source>Continuing enhancements and improvements to &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;.</source>
          <target state="translated">对&lt;a href=&quot;fts3&quot;&gt;FTS3的&lt;/a&gt;持续增强和改进。</target>
        </trans-unit>
        <trans-unit id="2009f584db4b6762c01a87103a205a43fe3cb848" translate="yes" xml:space="preserve">
          <source>Continuing improvements to the test suite and fixes to obscure bugs and inconsistencies that the test suite improvements are uncovering.</source>
          <target state="translated">继续改进测试套件,并修复测试套件改进所发现的模糊错误和不一致之处。</target>
        </trans-unit>
        <trans-unit id="1ca7bf3d67fb3020228ac37bd4bc93280daba832" translate="yes" xml:space="preserve">
          <source>Contrary to the intuition of many, &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; does not reset the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; on a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. Use this routine to reset all host parameters to NULL.</source>
          <target state="translated">与许多直觉相反，&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;不会重置已&lt;a href=&quot;#sqlite3_stmt&quot;&gt;准备好的语句&lt;/a&gt;上的&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;绑定&lt;/a&gt;。使用此例程将所有主机参数重置为NULL。</target>
        </trans-unit>
        <trans-unit id="cdcbd7d39f460823aca9b9fc7f28e86a6837fad5" translate="yes" xml:space="preserve">
          <source>Contrary to the intuition of many, &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; does not reset the &lt;a href=&quot;bind_blob&quot;&gt;bindings&lt;/a&gt; on a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. Use this routine to reset all host parameters to NULL.</source>
          <target state="translated">与许多直觉相反，&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;不会重置已&lt;a href=&quot;stmt&quot;&gt;准备好的语句&lt;/a&gt;上的&lt;a href=&quot;bind_blob&quot;&gt;绑定&lt;/a&gt;。使用此例程将所有主机参数重置为NULL。</target>
        </trans-unit>
        <trans-unit id="56e3d51f494e6dd366ee62fae61ac03a93a7f2a3" translate="yes" xml:space="preserve">
          <source>Controlling Depth-First Versus Breadth-First Search Of a Tree Using ORDER BY</source>
          <target state="translated">使用ORDER BY控制树的深度优先和广度优先搜索。</target>
        </trans-unit>
        <trans-unit id="ea782105450bbc3723c1b76880caef4ed08032a7" translate="yes" xml:space="preserve">
          <source>Convenience Routines For Running Queries</source>
          <target state="translated">运行查询的方便例程</target>
        </trans-unit>
        <trans-unit id="9151f8433f795cb0f0b5b6743aeb7de77ec49f00" translate="yes" xml:space="preserve">
          <source>Conversion</source>
          <target state="translated">Conversion</target>
        </trans-unit>
        <trans-unit id="5e7d5a98bcc47f452d8a4ce28a7202d2ed515e6c" translate="yes" xml:space="preserve">
          <source>Conversion Processing</source>
          <target state="translated">转换处理</target>
        </trans-unit>
        <trans-unit id="d77ae256c17778b6b22cdb6d26f46c01f50b1386" translate="yes" xml:space="preserve">
          <source>Conversions between UTF-16be and UTF-16le are always done in place and do not invalidate a prior pointer, though of course the content of the buffer that the prior pointer references will have been modified. Other kinds of conversion are done in place when it is possible, but sometimes they are not possible and in those cases prior pointers are invalidated.</source>
          <target state="translated">UTF-16be和UTF-16le之间的转换总是在原地进行,不会使先前的指针无效,当然先前指针引用的缓冲区的内容会被修改。其他类型的转换在可能的情况下会在原地进行,但有时不可能,在这种情况下,先前的指针会失效。</target>
        </trans-unit>
        <trans-unit id="8527a14f28507a486e3c2038fa5167e707f4acec" translate="yes" xml:space="preserve">
          <source>Convert P2 registers beginning with P1 into the &lt;a href=&quot;fileformat2#record_format&quot;&gt;record format&lt;/a&gt; use as a data record in a database table or as a key in an index. The &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; opcode can decode the record later.</source>
          <target state="translated">将以P1开头的P2寄存器转换为&lt;a href=&quot;fileformat2#record_format&quot;&gt;记录格式，&lt;/a&gt;用作数据库表中的数据记录或索引中的键。该&lt;a href=&quot;opcode#Column&quot;&gt;列&lt;/a&gt;码后可以解码记录。</target>
        </trans-unit>
        <trans-unit id="6110d61a4f0b93f4f1786cc181b877ffbc07b6f5" translate="yes" xml:space="preserve">
          <source>Convert all &quot;&lt;code&gt;#&lt;/code&gt;&quot; characters into &quot;&lt;code&gt;%23&lt;/code&gt;&quot;.</source>
          <target state="translated">将所有&amp;ldquo; &lt;code&gt;#&lt;/code&gt; &amp;rdquo;字符转换为&amp;ldquo; &lt;code&gt;%23&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="cb7da03590965d6f39aa9b4cc1a3abd9c78729ec" translate="yes" xml:space="preserve">
          <source>Convert all &quot;&lt;code&gt;?&lt;/code&gt;&quot; characters into &quot;&lt;code&gt;%3f&lt;/code&gt;&quot;.</source>
          <target state="translated">将所有&amp;ldquo; &lt;code&gt;?&lt;/code&gt; &amp;rdquo;字符转换为&amp;ldquo; &lt;code&gt;%3f&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="aba96b2a30818bbfb1c821c9fb2ff8c5dd760ffc" translate="yes" xml:space="preserve">
          <source>Convert all sequences of two or more &quot;&lt;code&gt;/&lt;/code&gt;&quot; characters into a single &quot;&lt;code&gt;/&lt;/code&gt;&quot; character.</source>
          <target state="translated">将两个或更多&amp;ldquo; &lt;code&gt;/&lt;/code&gt; &amp;rdquo;字符的所有序列转换为单个&amp;ldquo; &lt;code&gt;/&lt;/code&gt; &amp;rdquo;字符。</target>
        </trans-unit>
        <trans-unit id="9218bd4afe759364703b183410a2dc13af3bfd80" translate="yes" xml:space="preserve">
          <source>Convert array constants in the code to have type &quot;const&quot;.</source>
          <target state="translated">将代码中的数组常量转换为 &quot;const &quot;类型。</target>
        </trans-unit>
        <trans-unit id="efad9a1cd6300f3155adba4fdbf6f2272fac9217" translate="yes" xml:space="preserve">
          <source>Convert from integer to float</source>
          <target state="translated">从整数转换为浮点数</target>
        </trans-unit>
        <trans-unit id="2d1e75be417c65c8d6a61a4be607d4baf9fd907e" translate="yes" xml:space="preserve">
          <source>Convert the underlying virtual machine to be a register-based machine rather than a stack-based machine. The only user-visible change is in the output of EXPLAIN.</source>
          <target state="translated">将底层虚拟机转换为基于寄存器的机器,而不是基于栈的机器。唯一用户可见的变化是在EXPLAIN的输出中。</target>
        </trans-unit>
        <trans-unit id="293e7888094e60e7ae942b34aacf8692de6ac28c" translate="yes" xml:space="preserve">
          <source>Convert to the new website: http://www.sqlite.org/</source>
          <target state="translated">转换到新网站:http://www.sqlite.org/</target>
        </trans-unit>
        <trans-unit id="af74f7c5362aaee985bf8cda3dd75fc80751ce51" translate="yes" xml:space="preserve">
          <source>Copy</source>
          <target state="translated">Copy</target>
        </trans-unit>
        <trans-unit id="62e344ae607b939275b619f121fe73746c0c7f9a" translate="yes" xml:space="preserve">
          <source>Copy And Free SQL Values</source>
          <target state="translated">复制和免费的SQL值</target>
        </trans-unit>
        <trans-unit id="2a054004f4716fcfdd66797784227739af6ae2e6" translate="yes" xml:space="preserve">
          <source>Copy data</source>
          <target state="translated">复制数据</target>
        </trans-unit>
        <trans-unit id="a8edd5c34da27f929be29297a3e1a0b2b7d510c9" translate="yes" xml:space="preserve">
          <source>Copy the contents of all</source>
          <target state="translated">复制所有的内容</target>
        </trans-unit>
        <trans-unit id="206ba42d17a054137e160f699cf45b4c2254d889" translate="yes" xml:space="preserve">
          <source>Copy the database file using an external tool (for example the unix 'cp' utility or the DOS 'copy' command).</source>
          <target state="translated">使用外部工具(例如unix的'cp'工具或DOS的'copy'命令)复制数据库文件。</target>
        </trans-unit>
        <trans-unit id="c901be66df5ef99ab4f24023bacf5da468cc8855" translate="yes" xml:space="preserve">
          <source>Copying a database file without also copying its journal.</source>
          <target state="translated">复制数据库文件时,不需要同时复制其日志。</target>
        </trans-unit>
        <trans-unit id="9a851d1cd68948a591dc0c34333564d39d950b93" translate="yes" xml:space="preserve">
          <source>Copyright on all code was disclaimed. The library is now in the public domain.</source>
          <target state="translated">所有代码的版权均已声明。该库现已进入公共领域。</target>
        </trans-unit>
        <trans-unit id="3bc488c7530d4abc0197fb3c29656e9202c9e37f" translate="yes" xml:space="preserve">
          <source>Core Functions</source>
          <target state="translated">核心功能</target>
        </trans-unit>
        <trans-unit id="c93aea3a25070916d94552b3271d6e2cb60ffbf1" translate="yes" xml:space="preserve">
          <source>Core URI query parameters</source>
          <target state="translated">核心URI查询参数</target>
        </trans-unit>
        <trans-unit id="48e09e45c570a5fc20d51a90faf1c88a9a965b16" translate="yes" xml:space="preserve">
          <source>Correct</source>
          <target state="translated">Correct</target>
        </trans-unit>
        <trans-unit id="ab43f5950b771276d5096eea017224ae40627bd3" translate="yes" xml:space="preserve">
          <source>Correct affinity computations for a SELECT on the RHS of an IN operator. Fix for ticket &lt;a href=&quot;https://sqlite.org/src/info/199df4168c&quot;&gt;199df4168c&lt;/a&gt;.</source>
          <target state="translated">在IN运算符的RHS上为SELECT校正正确的相似性计算。修复票&lt;a href=&quot;https://sqlite.org/src/info/199df4168c&quot;&gt;199df4168c&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a9b4eee2570183dd2ddac6a6366a16f57f34e60" translate="yes" xml:space="preserve">
          <source>Correct column meta-information returned for aggregate queries</source>
          <target state="translated">为集合查询返回正确的列元信息。</target>
        </trans-unit>
        <trans-unit id="27273ddb3178ccf762d7085c22704a1fb0549237" translate="yes" xml:space="preserve">
          <source>Correct handling of columns with redundant unique indexes when those columns are used on the LHS of an &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt;. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/0eab1ac759&quot;&gt;0eab1ac759&lt;/a&gt;.</source>
          <target state="translated">当在&lt;a href=&quot;lang_expr#in_op&quot;&gt;IN运算符&lt;/a&gt;的LHS上使用具有冗余唯一索引的列时，请正确处理这些列。修复&lt;a href=&quot;https://www.sqlite.org/src/info/0eab1ac759&quot;&gt;故障&lt;/a&gt;单0eab1ac759。</target>
        </trans-unit>
        <trans-unit id="cfd7a02e00c8b2f225f8799044d14f56f7302d29" translate="yes" xml:space="preserve">
          <source>Correct handling of integers in SQL expressions that are larger than what can be represented by the machine integer.</source>
          <target state="translated">正确处理SQL表达式中大于机器整数所能表示的整数。</target>
        </trans-unit>
        <trans-unit id="cd691a2e765f41b11a9cf96cd3df086682295d23" translate="yes" xml:space="preserve">
          <source>Correct miscounts in the sqlite3_analyzer.exe utility related to WITHOUT ROWID tables.</source>
          <target state="translated">纠正sqlite3_analyzer.exe实用程序中与WITHOUT ROWID表相关的错误计数。</target>
        </trans-unit>
        <trans-unit id="4bfdca133fa3a4141a30355604a149499e687b80" translate="yes" xml:space="preserve">
          <source>Correctly compute a LEFT OUTER JOINs that is constrained on the left table only</source>
          <target state="translated">正确计算只约束在左表的LEFT OUTER JOINs。</target>
        </trans-unit>
        <trans-unit id="ad24fffac831d94ed1f6d73e123b29057262887e" translate="yes" xml:space="preserve">
          <source>Correctly handle NULL filenames in ATTACH and DETACH</source>
          <target state="translated">正确处理ATTACH和DETACH中的NULL文件名。</target>
        </trans-unit>
        <trans-unit id="f488953bdefc614e6154ab271713b957ab57b302" translate="yes" xml:space="preserve">
          <source>Correctly handle comparisons between an INTEGER PRIMARY KEY and a floating point number.</source>
          <target state="translated">正确处理INTEGER主键和浮点数之间的比较。</target>
        </trans-unit>
        <trans-unit id="35c4ec0c87f0e558ee367fb68087e03066aab5fb" translate="yes" xml:space="preserve">
          <source>Correctly handle quoted names in CREATE INDEX statements.</source>
          <target state="translated">正确处理CREATE INDEX语句中引用的名称。</target>
        </trans-unit>
        <trans-unit id="352dc237e245240eb4ea083bad4ff8dfb11f6950" translate="yes" xml:space="preserve">
          <source>Correctly handle the integer literal -0x8000000000000000 in the query planner.</source>
          <target state="translated">在查询规划器中正确处理整数文字-0x8000000000000000。</target>
        </trans-unit>
        <trans-unit id="88e07d9ff26fe66b408e72d9ac5048ccb06e2c58" translate="yes" xml:space="preserve">
          <source>Correctly interpret negative &quot;PRAGMA cache_size&quot; values when determining the cache size used for sorting large amounts of data.</source>
          <target state="translated">在确定用于排序大量数据的缓存大小时,正确解释负的 &quot;PRAGMA cache_size &quot;值。</target>
        </trans-unit>
        <trans-unit id="ee9849f5daa0323fb5d424718df3f8368eafb771" translate="yes" xml:space="preserve">
          <source>Correlated Subqueries</source>
          <target state="translated">相关子查询</target>
        </trans-unit>
        <trans-unit id="f13b587e5391fe217559af3492527b67d6307d3d" translate="yes" xml:space="preserve">
          <source>Correlated subqueries</source>
          <target state="translated">相关的子查询</target>
        </trans-unit>
        <trans-unit id="44355aa8b49da824d97a083ad2a8a3860b7b6f30" translate="yes" xml:space="preserve">
          <source>Corresponds to a puzzle like this:</source>
          <target state="translated">对应着这样一个难题。</target>
        </trans-unit>
        <trans-unit id="9de7bd4ef28516474c07432e4cafa11ec15920ae" translate="yes" xml:space="preserve">
          <source>Corruption to the underlying SQLite database file. (See documentation on &lt;a href=&quot;howtocorrupt&quot;&gt;how to corrupt&lt;/a&gt; and SQLite database for additional information.)</source>
          <target state="translated">基础SQLite数据库文件损坏。（有关其他信息，请参见有关&lt;a href=&quot;howtocorrupt&quot;&gt;如何损坏&lt;/a&gt;和SQLite数据库的文档。）</target>
        </trans-unit>
        <trans-unit id="66e12969c225cc6d65e18210488acb826eba907e" translate="yes" xml:space="preserve">
          <source>Count</source>
          <target state="translated">Count</target>
        </trans-unit>
        <trans-unit id="0939fecded0f0c9d546d71641c3908e28d8f44d4" translate="yes" xml:space="preserve">
          <source>Count The Number Of Rows Modified</source>
          <target state="translated">计算修改的行数</target>
        </trans-unit>
        <trans-unit id="2b8bef37451c2cbce07a23488203e5542d9f4dd1" translate="yes" xml:space="preserve">
          <source>Count the number of CPU cycles consumed using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt;.</source>
          <target state="translated">计算使用&lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt;消耗的CPU周期数。</target>
        </trans-unit>
        <trans-unit id="49d2ca2c89047e9021ce54796bb5abdb2fd3bc0c" translate="yes" xml:space="preserve">
          <source>Countless bug fixes</source>
          <target state="translated">无数错误修复</target>
        </trans-unit>
        <trans-unit id="00252cf377dd27368f8326fbe29b91bd69acc82e" translate="yes" xml:space="preserve">
          <source>Countless minor bug fixes, documentation improvements, new and improved test cases, and code simplifications and cleanups.</source>
          <target state="translated">无数的小bug修复,文档改进,新的和改进的测试案例,以及代码简化和清理。</target>
        </trans-unit>
        <trans-unit id="30106347ab7dfc885850c282c1789d99c22c045f" translate="yes" xml:space="preserve">
          <source>Coverage Testing</source>
          <target state="translated">覆盖测试</target>
        </trans-unit>
        <trans-unit id="1c7ccdf4836b4b91d53aaf066e241e1e63bcb54a" translate="yes" xml:space="preserve">
          <source>Covering indexes</source>
          <target state="translated">覆盖指数</target>
        </trans-unit>
        <trans-unit id="cf43e93921ba031c40cac261f4d24c6115ca0a3e" translate="yes" xml:space="preserve">
          <source>Covering indices</source>
          <target state="translated">覆盖指数</target>
        </trans-unit>
        <trans-unit id="ba58feb4df54a21eed20b23d82daa39d2f414cf2" translate="yes" xml:space="preserve">
          <source>Crash and power loss tests</source>
          <target state="translated">碰撞和失电测试</target>
        </trans-unit>
        <trans-unit id="d1e3f610852d10da5d8935701b8e1938e2ea49d4" translate="yes" xml:space="preserve">
          <source>Crash testing seeks to demonstrate that an SQLite database will not go corrupt if the application or operating system crashes or if there is a power failure in the middle of a database update. A separate white-paper titled &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit in SQLite&lt;/a&gt; describes the defensive measure SQLite takes to prevent database corruption following a crash. Crash tests strive to verify that those defensive measures are working correctly.</source>
          <target state="translated">崩溃测试旨在证明，如果应用程序或操作系统崩溃或数据库更新过程中出现电源故障，SQLite数据库也不会损坏。另一篇名为《&lt;a href=&quot;atomiccommit&quot;&gt;SQLite&lt;/a&gt;中的原子提交》的白皮书介绍了SQLite采取的防御措施，以防止崩溃后数据库损坏。碰撞测试旨在验证这些防御措施是否正常运行。</target>
        </trans-unit>
        <trans-unit id="a6531b5d9a390a38e977f855630c550e6d918ac6" translate="yes" xml:space="preserve">
          <source>Crash tests in SQLite use a modified VFS that can simulate the kinds of filesystem damage that occur during a power loss or operating system crash. The crash-test VFS can simulate incomplete sector writes, pages filled with garbage data because a write has not completed, and out of order writes, all occurring at varying points during a test scenario. Crash tests execute transactions over and over, varying the time at which a simulated power loss occurs and the properties of the damage inflicted. Each test then reopens the database after the simulated crash and verifies that the transaction either occurred completely or not at all and that the database is in a completely consistent state.</source>
          <target state="translated">SQLite中的崩溃测试使用一个修改过的VFS,可以模拟断电或操作系统崩溃时发生的各种文件系统损坏。崩溃测试的VFS可以模拟不完整的扇区写入、因为写入没有完成而充满垃圾数据的页面,以及失序写入,所有这些情况都会在测试场景中的不同点发生。崩溃测试一遍又一遍地执行事务,改变模拟断电发生的时间和造成损害的属性。每个测试都会在模拟崩溃后重新打开数据库,并验证事务是否完全发生或根本没有发生,数据库是否处于完全一致的状态。</target>
        </trans-unit>
        <trans-unit id="b3391e1c037afbc39bd6f7690619a52ba958e865" translate="yes" xml:space="preserve">
          <source>Crash when calling undocumented SQL function sqlite_rename_parent() with NULL parameters. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/264b970c4379fd&quot;&gt;264b970c43&lt;/a&gt;</source>
          <target state="translated">使用NULL参数调用未公开的SQL函数sqlite_rename_parent（）时崩溃。机票&lt;a href=&quot;http://www.sqlite.org/src/info/264b970c4379fd&quot;&gt;264b970c43&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6588ffe6a8f71a2ceafb0b706f12dc32c85feb21" translate="yes" xml:space="preserve">
          <source>Crash when calling undocumented SQL function sqlite_rename_parent() with NULL parameters. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/264b970c4379fd&quot;&gt;264b970c43&lt;/a&gt;</source>
          <target state="translated">使用NULL参数调用未公开的SQL函数sqlite_rename_parent（）时崩溃。机票&lt;a href=&quot;https://www.sqlite.org/src/info/264b970c4379fd&quot;&gt;264b970c43&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cbedd1aa577cfa78e4159988e6015e4a622476e7" translate="yes" xml:space="preserve">
          <source>Create A New Changegroup Object</source>
          <target state="translated">创建一个新的变更组对象</target>
        </trans-unit>
        <trans-unit id="0eb8a02be6b191c11fc9bb259dafebba87dc4f53" translate="yes" xml:space="preserve">
          <source>Create A New Database</source>
          <target state="translated">创建一个新的数据库</target>
        </trans-unit>
        <trans-unit id="49b9f541df9267a1e81a2e1318c39164b9049cf8" translate="yes" xml:space="preserve">
          <source>Create A New Dynamic String Object</source>
          <target state="translated">创建一个新的动态字符串对象</target>
        </trans-unit>
        <trans-unit id="b6fb0a01eeb8fbfa08db1af0e99f321400dca595" translate="yes" xml:space="preserve">
          <source>Create A New Session Object</source>
          <target state="translated">创建一个新的会话对象</target>
        </trans-unit>
        <trans-unit id="b8c295ec5c8d9e2d803be8b00c7291210939416a" translate="yes" xml:space="preserve">
          <source>Create An Iterator To Traverse A Changeset</source>
          <target state="translated">创建一个迭代器来遍历一个变化集。</target>
        </trans-unit>
        <trans-unit id="f738b7c71ee4fcfa212cb684acc179c459d0f67c" translate="yes" xml:space="preserve">
          <source>Create Or Redefine SQL Functions</source>
          <target state="translated">创建或重新定义SQL函数</target>
        </trans-unit>
        <trans-unit id="fd00ea9a768424e224cb5c7effdeb94d4b4041fe" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;创建一个&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f9c0f9f8f5c2a818fac05ebd0144409b195c2755" translate="yes" xml:space="preserve">
          <source>Create a Makefile as described in &lt;a href=&quot;howtocompile&quot;&gt;How To Compile SQLite&lt;/a&gt;.</source>
          <target state="translated">按照&lt;a href=&quot;howtocompile&quot;&gt;如何编译SQLite中&lt;/a&gt;所述创建Makefile 。</target>
        </trans-unit>
        <trans-unit id="340fd5cb0d944699f9f2262601f8e8515f6277c0" translate="yes" xml:space="preserve">
          <source>Create a background thread to perform write operations and call sqlite3async_run().</source>
          <target state="translated">创建一个后台线程来执行写操作,并调用sqlite3async_run()。</target>
        </trans-unit>
        <trans-unit id="af7db7815d1cb1d51e5af0cd7f358563250421b6" translate="yes" xml:space="preserve">
          <source>Create a changeset rebaser object</source>
          <target state="translated">创建一个变化集rebaser对象</target>
        </trans-unit>
        <trans-unit id="08a7eb180eb01b1b848907571f8cab91fa3fadc5" translate="yes" xml:space="preserve">
          <source>Create a changeset rebaser object.</source>
          <target state="translated">创建一个变化集rebaser对象。</target>
        </trans-unit>
        <trans-unit id="43d32b083ccd73d48458a8a788df239ec0749647" translate="yes" xml:space="preserve">
          <source>Create a fossil repository to host the private branch using the following command:</source>
          <target state="translated">使用以下命令创建一个化石库来托管私有分支。</target>
        </trans-unit>
        <trans-unit id="020976ba5dc8b4a36c10d54c801ec1a4a89f48ac" translate="yes" xml:space="preserve">
          <source>Create a master-journal. The name of the master-journal is arbitrary. (The current implementation appends random suffixes to the name of the main database file until it finds a name that does not previously exist.) Fill the master journal with the names of all the individual journals and flush its contents to disk.</source>
          <target state="translated">创建一个主日志。主日记本的名称是任意的,(目前的实现是在主数据库文件的名称中随机添加后缀,直到找到之前不存在的名称)。(目前的实现是在主数据库文件的名称上随机添加后缀,直到找到一个之前不存在的名称。)在主日志中填入所有单个日志的名称,并将其内容冲入磁盘。</target>
        </trans-unit>
        <trans-unit id="da3af537bba9d7121766b2210dfaab8be2fac3f3" translate="yes" xml:space="preserve">
          <source>Create a new archive containing specified files.</source>
          <target state="translated">创建一个包含指定文件的新档案。</target>
        </trans-unit>
        <trans-unit id="afef83edf1b36bb49d450af9b70529ceb53e63d8" translate="yes" xml:space="preserve">
          <source>Create a new archive, overwriting any existing archive (either in the current &quot;main&quot; db or in the file specified by a --file option). Each argument following the options is a file to add to the archive. Directories are imported recursively. See above for examples.</source>
          <target state="translated">创建一个新的归档,覆盖任何现有的归档(可以是当前的 &quot;main &quot;db中的,也可以是--file选项指定的文件中的)。选项后的每个参数都是要添加到归档中的文件。目录是递归导入的。参见上面的例子。</target>
        </trans-unit>
        <trans-unit id="6c399fd2512bbe2d0e4a05efd898526951d10b8a" translate="yes" xml:space="preserve">
          <source>Create a new session object attached to database handle db. If successful, a pointer to the new object is written to *ppSession and SQLITE_OK is returned. If an error occurs, *ppSession is set to NULL and an SQLite error code (e.g. SQLITE_NOMEM) is returned.</source>
          <target state="translated">创建一个连接到数据库句柄db的新会话对象。如果成功,新对象的指针被写入*ppSession,并返回SQLITE_OK。如果发生错误,*ppSession被设置为NULL,并返回一个SQLite错误代码(如SQLITE_NOMEM)。</target>
        </trans-unit>
        <trans-unit id="7ef7c8e6020507b3b903b737530a1a743ade6fb2" translate="yes" xml:space="preserve">
          <source>Create a partial index by adding a WHERE clause to the end of an ordinary &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement.</source>
          <target state="translated">通过在普通&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;语句的末尾添加WHERE子句来创建部分索引。</target>
        </trans-unit>
        <trans-unit id="7044aef02f57d684bf1ace2c33f2aa3769b845ad" translate="yes" xml:space="preserve">
          <source>Create a static and constant &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object containing pointers to the methods from the previous step.</source>
          <target state="translated">创建一个静态和恒定的&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象，该对象包含指向上一步中的方法的指针。</target>
        </trans-unit>
        <trans-unit id="9927b43b64a34cad4b966d3687a6725b0b51be8b" translate="yes" xml:space="preserve">
          <source>Create a super-journal. The name of the super-journal is arbitrary. (The current implementation appends random suffixes to the name of the main database file until it finds a name that does not previously exist.) Fill the super-journal with the names of all the individual journals and flush its contents to disk.</source>
          <target state="translated">创建一个超级期刊。超级日记本的名称是任意的,(目前的实现是在主数据库文件的名称上随机添加后缀,直到找到之前不存在的名称)。(目前的实现是在主数据库文件的名称上随机添加后缀,直到找到一个之前不存在的名称。)用所有单个期刊的名称填充超级期刊,并将其内容刷新到磁盘上。</target>
        </trans-unit>
        <trans-unit id="ce77c2b32feacc25a54f9d8046773c75cc6d0f0f" translate="yes" xml:space="preserve">
          <source>Create an instance of the &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; structure containing pointers to all the methods from step 1.</source>
          <target state="translated">创建&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt;结构的实例，该实例包含指向步骤1中所有方法的指针。</target>
        </trans-unit>
        <trans-unit id="0a8ad313a3f6f92e33200837c1d1b7d9a66475fb" translate="yes" xml:space="preserve">
          <source>Create an iterator used to iterate through the contents of a changeset. If successful, *pp is set to point to the iterator handle and SQLITE_OK is returned. Otherwise, if an error occurs, *pp is set to zero and an SQLite error code is returned.</source>
          <target state="translated">创建一个迭代器,用于遍历变化集的内容。如果成功,*pp被设置为指向迭代器句柄,并返回SQLITE_OK。否则,如果发生错误,*pp被设置为0,并返回一个SQLite错误代码。</target>
        </trans-unit>
        <trans-unit id="68f3d9400dc4770bb7d1f485473e1cabff22fc1f" translate="yes" xml:space="preserve">
          <source>Create and Destroy VFS Filenames</source>
          <target state="translated">创建和销毁VFS文件名</target>
        </trans-unit>
        <trans-unit id="f282c6f0dcaa864a9b91c1b0857728fb4f3b6cf7" translate="yes" xml:space="preserve">
          <source>Create if does not exist?</source>
          <target state="translated">创建如果不存在?</target>
        </trans-unit>
        <trans-unit id="a6746bd3f5b981be1960788a63b361beb206e80d" translate="yes" xml:space="preserve">
          <source>Create new table</source>
          <target state="translated">创建新表</target>
        </trans-unit>
        <trans-unit id="552737e86fdab069e1553393c32b2d735d03da2b" translate="yes" xml:space="preserve">
          <source>Create the prepared statement object using &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;创建准备好的语句对象。</target>
        </trans-unit>
        <trans-unit id="b3aaf4f3bc8aa8975fba3c24e7982e7ad410e2d3" translate="yes" xml:space="preserve">
          <source>Create the prepared statement object using &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;创建准备好的语句对象。</target>
        </trans-unit>
        <trans-unit id="b6cd0fb8dc0636107f3c2eeec94775a363db607d" translate="yes" xml:space="preserve">
          <source>CreateBtree</source>
          <target state="translated">CreateBtree</target>
        </trans-unit>
        <trans-unit id="f6d526ccd323387bacc30fe97239e7bfe08e6f7e" translate="yes" xml:space="preserve">
          <source>Created a new mutex subsystem and made it replicable at compile-time.</source>
          <target state="translated">创建了一个新的mutex子系统,并使其在编译时可以复制。</target>
        </trans-unit>
        <trans-unit id="015db039081a96e714bbc870bb70163882fcd0ef" translate="yes" xml:space="preserve">
          <source>Created the &lt;a href=&quot;dbhash&quot;&gt;dbhash.exe&lt;/a&gt; command-line utility.</source>
          <target state="translated">创建了&lt;a href=&quot;dbhash&quot;&gt;dbhash.exe&lt;/a&gt;命令行实用程序。</target>
        </trans-unit>
        <trans-unit id="acf789d2331ea2a8bf5399f72dadd8b178eecbe4" translate="yes" xml:space="preserve">
          <source>Creation of a transient imposter table involves a special &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; call. Unlike all other SQLite APIs, &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; interface is subject to incompatible changes from one release to the next, and so the mechanism described below is not guaranteed to work in future releases of SQLite. The SQLite developers do not consider this a problem because imposter tables should not be used in applications. Imposter tables are for analysis and testing use only.</source>
          <target state="translated">临时冒名顶替者表的创建涉及一个特殊的&lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control（）&lt;/a&gt;调用。与所有其他SQLite API不同，&lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control（）&lt;/a&gt;接口在一个版本与另一个版本之间可能会发生不兼容的更改，因此，不能保证下文所述的机制在SQLite的将来版本中也可以使用。 SQLite开发人员不会将此视为问题，因为不应在应用程序中使用冒名顶替者表。冒名顶替者表仅用于分析和测试。</target>
        </trans-unit>
        <trans-unit id="bfac50d6424b5166c3ee2808c85ae7c139b5182f" translate="yes" xml:space="preserve">
          <source>Credits</source>
          <target state="translated">Credits</target>
        </trans-unit>
        <trans-unit id="f3072cfe38995c94aede1e379bdbc87872e32b2e" translate="yes" xml:space="preserve">
          <source>Cross-Platform</source>
          <target state="translated">Cross-Platform</target>
        </trans-unit>
        <trans-unit id="a84c73487927d0c8de6b6f553d91f81e8f3c67ef" translate="yes" xml:space="preserve">
          <source>Cross-platform: Android, *BSD, iOS, Linux, Mac, Solaris, VxWorks, and Windows (Win32, WinCE, WinRT) are supported out of the box. Easy to port to other systems.</source>
          <target state="translated">跨平台。安卓、*BSD、iOS、Linux、Mac、Solaris、VxWorks和Windows(Win32、WinCE、WinRT)都支持。易于移植到其他系统。</target>
        </trans-unit>
        <trans-unit id="fe50f9415f0538595ee673bee95f6e9b7af30913" translate="yes" xml:space="preserve">
          <source>Currently the asynchronous IO extension is compatible with win32 systems and systems that support the pthreads interface, including Mac OS X, Linux, and other varieties of Unix.</source>
          <target state="translated">目前异步IO扩展兼容win32系统和支持pthreads接口的系统,包括Mac OS X、Linux和其他品种的Unix。</target>
        </trans-unit>
        <trans-unit id="5527dcef9928e4b30b2e113bf906b6aad70626b4" translate="yes" xml:space="preserve">
          <source>Cursor P1 is on an index btree. If the record identified by P3 and P4 contains any NULL value, jump immediately to P2. If all terms of the record are not-NULL then a check is done to determine if any row in the P1 index btree has a matching key prefix. If there are no matches, jump immediately to P2. If there is a match, fall through and leave the P1 cursor pointing to the matching row.</source>
          <target state="translated">光标P1在一个索引树上。如果P3和P4所标识的记录包含任何NULL值,则立即跳转到P2。如果记录的所有项都不是NULL,那么就会进行检查,以确定P1索引btree中是否有匹配的键前缀的行。如果没有匹配,则立即跳转到P2。如果有匹配的记录,则跳过并让P1游标指向匹配的记录。</target>
        </trans-unit>
        <trans-unit id="d32c868a8066f0bb0c8cbc2fdacd1dcc4df55aff" translate="yes" xml:space="preserve">
          <source>Cursor P1 is on an index btree. If the record identified by P3 and P4 is a prefix of any entry in P1 then a jump is made to P2 and P1 is left pointing at the matching entry.</source>
          <target state="translated">光标P1在一个索引树上。如果P3和P4所标识的记录是P1中任何条目的前缀,那么就会跳转到P2,P1将被留在指向匹配条目的位置。</target>
        </trans-unit>
        <trans-unit id="e4499a408e8cf9ba0a64b6a7abae32a3e8598a9c" translate="yes" xml:space="preserve">
          <source>Cursor P1 is on an index btree. If the record identified by P3 and P4 is not the prefix of any entry in P1 then a jump is made to P2. If P1 does contain an entry whose prefix matches the P3/P4 record then control falls through to the next instruction and P1 is left pointing at the matching entry.</source>
          <target state="translated">光标P1在一个索引树上。如果P3和P4标识的记录不是P1中任何一个条目的前缀,那么就会跳转到P2。如果P1中确实包含了一个前缀与P3/P4记录相匹配的条目,那么控制权就会落到下一条指令上,P1就会被留在指向匹配条目的位置。</target>
        </trans-unit>
        <trans-unit id="cce417cb09cb0e87ed39f345b9827448814078c5" translate="yes" xml:space="preserve">
          <source>Cursor P1 is on an index btree. If the seekHit flag is set on P1, then this opcode is a no-op. But if the seekHit flag of P1 is clear, then check to see if there is any entry in P1 that matches the prefix identified by P3 and P4. If no entry matches the prefix, jump to P2. Otherwise fall through.</source>
          <target state="translated">游标P1在索引btree上,如果在P1上设置了seekHit标志,那么这个操作码就是无操作。如果P1上的seekHit标志被设置,那么这个操作码就是一个无操作码。但是如果P1的seekHit标志是明确的,那么检查P1中是否有任何条目与P3和P4确定的前缀相匹配。如果没有符合前缀的条目,则跳转到P2。否则掉过头来。</target>
        </trans-unit>
        <trans-unit id="22ec5d401662b5703126ca0123e136b6c810e79d" translate="yes" xml:space="preserve">
          <source>CursorHint</source>
          <target state="translated">CursorHint</target>
        </trans-unit>
        <trans-unit id="f164c696c942f1b7ba36a19ad9dc745042621e3b" translate="yes" xml:space="preserve">
          <source>CursorLock</source>
          <target state="translated">CursorLock</target>
        </trans-unit>
        <trans-unit id="a11839ff842a324c26003221096de9b6e7ceaccd" translate="yes" xml:space="preserve">
          <source>CursorUnlock</source>
          <target state="translated">CursorUnlock</target>
        </trans-unit>
        <trans-unit id="836bce7485bd48ef5bf35926e3fb08781cfcdae7" translate="yes" xml:space="preserve">
          <source>Custom Builds Of SQLite</source>
          <target state="translated">自定义构建的SQLite</target>
        </trans-unit>
        <trans-unit id="dfcc51a98311f46893672f2fb6d173d44d66fc77" translate="yes" xml:space="preserve">
          <source>Custom Page Cache Object</source>
          <target state="translated">自定义页面缓存对象</target>
        </trans-unit>
        <trans-unit id="076c8e2f21c1b5d23882403c8926d30c1101585d" translate="yes" xml:space="preserve">
          <source>Custom auxiliary functions</source>
          <target state="translated">自定义辅助功能</target>
        </trans-unit>
        <trans-unit id="c77373601428abf208eee7bad389ec98739fcb31" translate="yes" xml:space="preserve">
          <source>Custom r-tree queries</source>
          <target state="translated">自定义r树查询</target>
        </trans-unit>
        <trans-unit id="7057308b175a54061ae194ee69576ebf4bb75f55" translate="yes" xml:space="preserve">
          <source>Custom tokenizers</source>
          <target state="translated">自定义记号器</target>
        </trans-unit>
        <trans-unit id="c9cb8f8539741bdce4da7c0edbda58f7c8a5bb30" translate="yes" xml:space="preserve">
          <source>Custom tokenizers may also support synonyms. Consider a case in which a user wishes to query for a phrase such as &quot;first place&quot;. Using the built-in tokenizers, the FTS5 query 'first + place' will match instances of &quot;first place&quot; within the document set, but not alternative forms such as &quot;1st place&quot;. In some applications, it would be better to match all instances of &quot;first place&quot; or &quot;1st place&quot; regardless of which form the user specified in the MATCH query text.</source>
          <target state="translated">自定义标记器也可以支持同义词。考虑到用户希望查询一个短语,如 &quot;first place&quot;。使用内置的标记器,FTS5查询 &quot;first+place &quot;将匹配文档集中的 &quot;first place &quot;实例,但不匹配 &quot;1st place &quot;等其他形式。在某些应用中,无论用户在MATCH查询文本中指定了哪种形式,最好都能匹配 &quot;first place &quot;或 &quot;1st place &quot;的所有实例。</target>
        </trans-unit>
        <trans-unit id="5ffd763a855efd9c913568b8cd20dab17c4af423" translate="yes" xml:space="preserve">
          <source>Cut over configuration management to a new CVS repository with its own CVSTrac bug tracking system.</source>
          <target state="translated">将配置管理转移到一个新的CVS仓库,并拥有自己的CVSTrac错误跟踪系统。</target>
        </trans-unit>
        <trans-unit id="fd5aaa888331e7fdbb9873b0f3118383cbd0f6f2" translate="yes" xml:space="preserve">
          <source>Cut-over to the &lt;a href=&quot;queryplanner-ng&quot;&gt;next generation query planner&lt;/a&gt; for faster and better query plans.</source>
          <target state="translated">过渡到&lt;a href=&quot;queryplanner-ng&quot;&gt;下一代查询计划器，&lt;/a&gt;以实现更快，更好的查询计划。</target>
        </trans-unit>
        <trans-unit id="50c9e8d5fc98727b4bbc93cf5d64a68db647f04f" translate="yes" xml:space="preserve">
          <source>D</source>
          <target state="translated">D</target>
        </trans-unit>
        <trans-unit id="339588e68f8e2dd5f57cc156ab01c5b4dcaa9da0" translate="yes" xml:space="preserve">
          <source>DATABASE</source>
          <target state="translated">DATABASE</target>
        </trans-unit>
        <trans-unit id="8c76abdec41a7652375d00f4bf05256b82c68494" translate="yes" xml:space="preserve">
          <source>DATE</source>
          <target state="translated">DATE</target>
        </trans-unit>
        <trans-unit id="6e915cae90d2c29f2358559dc05c3df58595f55d" translate="yes" xml:space="preserve">
          <source>DATETIME</source>
          <target state="translated">DATETIME</target>
        </trans-unit>
        <trans-unit id="e37624f858dc2af6156398ee78609c8c3c886ca3" translate="yes" xml:space="preserve">
          <source>DB2</source>
          <target state="translated">DB2</target>
        </trans-unit>
        <trans-unit id="645f10d83e7588e1eb33d0d2939905688a530e61" translate="yes" xml:space="preserve">
          <source>DB2, SQL Anywhere, and Borland Interbase do not allow NULLs in a UNIQUE column.</source>
          <target state="translated">DB2、SQL Anywhere和Borland Interbase不允许在UNIQUE列中使用NULL。</target>
        </trans-unit>
        <trans-unit id="cbdd0b7d0c739234955599c5455d354e4fae19b3" translate="yes" xml:space="preserve">
          <source>DDDDDDDDDD</source>
          <target state="translated">DDDDDDDDDD</target>
        </trans-unit>
        <trans-unit id="3a98757f7ab109581d6b2954839e6421cda4bacd" translate="yes" xml:space="preserve">
          <source>DECIMAL(10,5)</source>
          <target state="translated">DECIMAL(10,5)</target>
        </trans-unit>
        <trans-unit id="c189207a55da45305c884fe2b50e086fcad4724b" translate="yes" xml:space="preserve">
          <source>DEFAULT</source>
          <target state="translated">DEFAULT</target>
        </trans-unit>
        <trans-unit id="b79011ba88d8043cebb3f51bd20a68d85873c9ee" translate="yes" xml:space="preserve">
          <source>DEFAULT VALUES&quot; form of the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement is not supported.</source>
          <target state="translated">不支持&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;语句的&amp;ldquo;默认值&amp;rdquo;形式。</target>
        </trans-unit>
        <trans-unit id="eb9fe9e9d3e08f670bce95fe32d00c47dbc6b299" translate="yes" xml:space="preserve">
          <source>DEFERRABLE</source>
          <target state="translated">DEFERRABLE</target>
        </trans-unit>
        <trans-unit id="10f984f7d502771d13c63406af087a7b917fd1aa" translate="yes" xml:space="preserve">
          <source>DEFERRED</source>
          <target state="translated">DEFERRED</target>
        </trans-unit>
        <trans-unit id="6bdd4912d7dc55fbe1d47cc1e7b6480731d73ff0" translate="yes" xml:space="preserve">
          <source>DEFERRED means that the transaction does not actually start until the database is first accessed. Internally, the BEGIN DEFERRED statement merely sets a flag on the database connection that turns off the automatic commit that would normally occur when the last statement finishes. This causes the transaction that is automatically started to persist until an explicit COMMIT or ROLLBACK or until a rollback is provoked by an error or an ON CONFLICT ROLLBACK clause. If the first statement after BEGIN DEFERRED is a SELECT, then a read transaction is started. Subsequent write statements will upgrade the transaction to a write transaction if possible, or return SQLITE_BUSY. If the first statement after BEGIN DEFERRED is a write statement, then a write transaction is started.</source>
          <target state="translated">DEFERRED意味着在第一次访问数据库之前,事务实际上并没有开始。在内部,BEGIN DEFERRED语句只是在数据库连接上设置了一个标志,关闭了通常在最后一条语句结束时发生的自动提交。这将导致自动启动的事务持续存在,直到明确的COMMIT或ROLLBACK,或者直到由错误或ON CONFLICT ROLLBACK子句引发回滚。如果BEGIN DEFERRED之后的第一条语句是SELECT,那么就会启动一个读事务。随后的写语句将尽可能把事务升级为写事务,或者返回SQLITE_BUSY。如果BEGIN DEFERRED之后的第一条语句是一条写语句,那么就会启动一个写事务。</target>
        </trans-unit>
        <trans-unit id="5d0190695366a57cfee9ace793fdb8c89b47bb42" translate="yes" xml:space="preserve">
          <source>DEFERRED means that the transaction does not actually start until the database is first accessed. Internally, the BEGIN DEFERRRED statement merely sets a flag on the database connection that turns off the automatic commit that would normally occur when the last statement finishes. This causes the transaction that is automatically started to persist until an explicit COMMIT or ROLLBACK or until a rollback is provoked by an error or an ON CONFLICT ROLLBACK clause. If the first statement after BEGIN DEFERRED is a SELECT, then a read transaction is started. Subsequent write statements will upgrade the transaction to a write transaction if possible, or return SQLITE_BUSY. If the first statement after BEGIN DEFERRED is a write statement, then a write transaction is started.</source>
          <target state="translated">DEFERRED意味着在第一次访问数据库之前,事务实际上并没有开始。在内部,BEGIN DEFERRRED语句只是在数据库连接上设置了一个标志,关闭了通常在最后一条语句结束时发生的自动提交。这将导致自动启动的事务持续存在,直到明确的COMMIT或ROLLBACK,或者直到由错误或ON CONFLICT ROLLBACK子句引发回滚。如果BEGIN DEFERRED之后的第一条语句是SELECT,那么就会启动一个读事务。随后的写语句将尽可能把事务升级为写事务,或者返回SQLITE_BUSY。如果BEGIN DEFERRED之后的第一条语句是一条写语句,那么就会启动一个写事务。</target>
        </trans-unit>
        <trans-unit id="c44f0fc249bf9f56573cce35739bdbf358753ec9" translate="yes" xml:space="preserve">
          <source>DEFERRED, IMMEDIATE, and EXCLUSIVE transactions</source>
          <target state="translated">推迟、即时和独家交易。</target>
        </trans-unit>
        <trans-unit id="d6f5636098cd458ce9d22939f8e3e8deab0e9bd0" translate="yes" xml:space="preserve">
          <source>DELETE</source>
          <target state="translated">DELETE</target>
        </trans-unit>
        <trans-unit id="ddf5a8b95a67a245ead92340f3a1d492b967db1c" translate="yes" xml:space="preserve">
          <source>DELETE Changes</source>
          <target state="translated">删除变更</target>
        </trans-unit>
        <trans-unit id="6d2d8ff5f66968f5a9016744e065d7b055778fa4" translate="yes" xml:space="preserve">
          <source>DELETE FROM t1;</source>
          <target state="translated">DELETE FROM t1;</target>
        </trans-unit>
        <trans-unit id="ee62fe04ef6c5b85e13e87e697e2bed7ca49475c" translate="yes" xml:space="preserve">
          <source>DELETE FROM t2 WHERE a&amp;gt;10 AND a&amp;lt;20000;</source>
          <target state="translated">从t2删除a&amp;gt; 10并且a &amp;lt;20000;</target>
        </trans-unit>
        <trans-unit id="a5ebf9c0b02aa24303cdb7fb5cf5371c628bba2a" translate="yes" xml:space="preserve">
          <source>DELETE FROM t2 WHERE c LIKE '%fifty%';</source>
          <target state="translated">DELETE FROM t2 WHERE c LIKE '%fifty%'。</target>
        </trans-unit>
        <trans-unit id="b4aac6d0cf9ea3a89dec994c5ddb8ad46701ed40" translate="yes" xml:space="preserve">
          <source>DELETE records consist of the primary key fields only. The original values of other fields are omitted.</source>
          <target state="translated">DELETE记录只包括主键字段。其他字段的原始值被省略。</target>
        </trans-unit>
        <trans-unit id="b5093023417eb749513563ec16d8c0c821aa5aff" translate="yes" xml:space="preserve">
          <source>DESC</source>
          <target state="translated">DESC</target>
        </trans-unit>
        <trans-unit id="a26814be2b9a9bc0d8c52b43abfaf6e5c82a51a4" translate="yes" xml:space="preserve">
          <source>DESC indices</source>
          <target state="translated">DESC指数</target>
        </trans-unit>
        <trans-unit id="c10fec47e3203a12a4865741f863a30dc8d9e348" translate="yes" xml:space="preserve">
          <source>DETACH</source>
          <target state="translated">DETACH</target>
        </trans-unit>
        <trans-unit id="53dda846085ef522df42849d527936da7055a14d" translate="yes" xml:space="preserve">
          <source>DETACH DATABASE</source>
          <target state="translated">DETACH DATABASE</target>
        </trans-unit>
        <trans-unit id="45b1a3f093ba639c208b0bbbbe6cad9eff65396f" translate="yes" xml:space="preserve">
          <source>DISTINCT</source>
          <target state="translated">DISTINCT</target>
        </trans-unit>
        <trans-unit id="3804145294052baefad623cd8cebfa752f431578" translate="yes" xml:space="preserve">
          <source>DISTINCT, ORDER BY, GROUP BY, HAVING, LIMIT, and OFFSET</source>
          <target state="translated">DISTINCT,ORDER BY,GROUP BY,HAVING,LIMIT,和OFFSET。</target>
        </trans-unit>
        <trans-unit id="8feb29077a1df95bd8e261f267cf55119b1eac74" translate="yes" xml:space="preserve">
          <source>DO</source>
          <target state="translated">DO</target>
        </trans-unit>
        <trans-unit id="9bf5aa462fedb77794614582aa9cb6f368384112" translate="yes" xml:space="preserve">
          <source>DOC - Word Perfect and Microsoft Office documents</source>
          <target state="translated">DOC-Word Perfect和Microsoft Office文件</target>
        </trans-unit>
        <trans-unit id="097274c5c7abaa172853282efd2062239c4afe9d" translate="yes" xml:space="preserve">
          <source>DOUBLE</source>
          <target state="translated">DOUBLE</target>
        </trans-unit>
        <trans-unit id="0282a2e2726b5fdbd89b48e12c5edb38b5d2c29e" translate="yes" xml:space="preserve">
          <source>DOUBLE PRECISION</source>
          <target state="translated">双倍精度</target>
        </trans-unit>
        <trans-unit id="39514a7a66f0433579dbc23ecfbb8c6c3e079395" translate="yes" xml:space="preserve">
          <source>DROP</source>
          <target state="translated">DROP</target>
        </trans-unit>
        <trans-unit id="383ac905b2bc5cb0e45bdf7ad063398c7f4d0280" translate="yes" xml:space="preserve">
          <source>DROP INDEX</source>
          <target state="translated">滴滴指数</target>
        </trans-unit>
        <trans-unit id="ac02c0b871c5f0a59ae432b32af6203946972208" translate="yes" xml:space="preserve">
          <source>DROP TABLE</source>
          <target state="translated">删除表</target>
        </trans-unit>
        <trans-unit id="1627fd06710bbc68919d746def7dc2f189b53feb" translate="yes" xml:space="preserve">
          <source>DROP TABLE t1;</source>
          <target state="translated">DROP TABLE t1;</target>
        </trans-unit>
        <trans-unit id="d1be8c338ef5a7bcca5157c5203b61e7d14d5f12" translate="yes" xml:space="preserve">
          <source>DROP TABLE t2;</source>
          <target state="translated">DROP TABLE t2;</target>
        </trans-unit>
        <trans-unit id="5771355d686a88f9aec56e2304026908b55bffb4" translate="yes" xml:space="preserve">
          <source>DROP TABLE t3;</source>
          <target state="translated">DROP TABLE t3;</target>
        </trans-unit>
        <trans-unit id="fc6194eca24e844585523f3d0e5cb90acd2f1cd1" translate="yes" xml:space="preserve">
          <source>DROP TRIGGER</source>
          <target state="translated">跌落触发器</target>
        </trans-unit>
        <trans-unit id="6a23d5fa27b31fab3e560233e685dfb52af23fcc" translate="yes" xml:space="preserve">
          <source>DROP VIEW</source>
          <target state="translated">下拉视图</target>
        </trans-unit>
        <trans-unit id="6a98041e1291d5c0fcb8031e8dc6b0f10dbdcd21" translate="yes" xml:space="preserve">
          <source>DWG - AutoCAD drawings</source>
          <target state="translated">DWG-AutoCAD图纸</target>
        </trans-unit>
        <trans-unit id="4b5fe1d0668c6a074a9b45de43a0ab7e93ea3537" translate="yes" xml:space="preserve">
          <source>Daily in your prayers, with tears and sighs, confess your past sins to God, and amend them for the future.</source>
          <target state="translated">每天在祷告中,流着泪,叹着气,向神承认你过去的罪,为将来修正。</target>
        </trans-unit>
        <trans-unit id="352953a16a74f0790135416ee3270f630371240c" translate="yes" xml:space="preserve">
          <source>Data Change Notification Callbacks</source>
          <target state="translated">数据变更通知回调</target>
        </trans-unit>
        <trans-unit id="a073b1a4a370adc09bf5c624ac412d5da3300853" translate="yes" xml:space="preserve">
          <source>Data can be inserted into such an FTS4 table using an INSERT statements. However, unlike ordinary FTS4 tables, the user must supply an explicit integer docid value. For example:</source>
          <target state="translated">可以使用INSERT语句将数据插入到这样的FTS4表中。然而,与普通的FTS4表不同,用户必须提供一个显式的整数docid值。例如:</target>
        </trans-unit>
        <trans-unit id="9dd6b7f9a7a5a10b73550e3715829adf5933cc29" translate="yes" xml:space="preserve">
          <source>Data dominates. If you've chosen the right data structures and organized things well, the algorithms will almost always be self-evident. Data structures, not algorithms, are central to programming.</source>
          <target state="translated">数据占主导地位。如果你选择了正确的数据结构,并把事情组织得很好,算法几乎总是不言而喻的。数据结构而不是算法,是编程的核心。</target>
        </trans-unit>
        <trans-unit id="7765119a34cb37ce325b7908102a741f5f04decc" translate="yes" xml:space="preserve">
          <source>Data format conversions can invalidate the pointer returned by prior calls to sqlite3_column_blob(), sqlite3_column_text(), and/or sqlite3_column_text16(). Pointers might be invalided in the following cases:</source>
          <target state="translated">数据格式转换会使之前调用sqlite3_column_blob()、sqlite3_column_text()和/或sqlite3_column_text16()返回的指针无效。在以下情况下,指针可能会被无效化。</target>
        </trans-unit>
        <trans-unit id="d6f53192d7efb1f452daf4e4ce9588f68c43c7ab" translate="yes" xml:space="preserve">
          <source>Data read while in the process of opening a read-only transaction (see section</source>
          <target state="translated">在打开一个只读事务的过程中读取的数据(见第3章)。</target>
        </trans-unit>
        <trans-unit id="ee503fe5765b8d9456bf21def7f9e06d2b12ebb6" translate="yes" xml:space="preserve">
          <source>Data type</source>
          <target state="translated">数据类型</target>
        </trans-unit>
        <trans-unit id="c0b1a7d66556ee25336c34353c17486dba3e302f" translate="yes" xml:space="preserve">
          <source>Data-types specified as part of the &quot;CREATE VIRTUAL TABLE&quot; statement used to create an FTS table are ignored completely. Instead of the normal rules for applying type &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; to inserted values, all values inserted into FTS table columns (except the special rowid column) are converted to type TEXT before being stored.</source>
          <target state="translated">作为创建FTS表的&amp;ldquo; CREATE VIRTUAL TABLE&amp;rdquo;语句的一部分指定的数据类型将被完全忽略。代替将类型&lt;a href=&quot;datatype3#affinity&quot;&gt;亲和力&lt;/a&gt;应用于插入值的一般规则，所有插入FTS表列（特殊rowid列除外）的值在存储之前都将转换为TEXT类型。</target>
        </trans-unit>
        <trans-unit id="5c196bb9b92e16036aa92c8d07d6256ad34cf47b" translate="yes" xml:space="preserve">
          <source>Database Connection Configuration Options</source>
          <target state="translated">数据库连接配置选项</target>
        </trans-unit>
        <trans-unit id="87ad120a4ba60c79863260e10eca7015248baadd" translate="yes" xml:space="preserve">
          <source>Database Connection For Functions</source>
          <target state="translated">函数的数据库连接</target>
        </trans-unit>
        <trans-unit id="f77d22fb96d5dfa5073b2fe8ffcf8caa0f1f055f" translate="yes" xml:space="preserve">
          <source>Database Connection Handle</source>
          <target state="translated">数据库连接手柄</target>
        </trans-unit>
        <trans-unit id="ed913bb076648fca64b8de1c707bbce02bda0945" translate="yes" xml:space="preserve">
          <source>Database Connection Status</source>
          <target state="translated">数据库连接状态</target>
        </trans-unit>
        <trans-unit id="d7a15726be6aee139cc047e8d19aae61e2286733" translate="yes" xml:space="preserve">
          <source>Database Connections</source>
          <target state="translated">数据库连接</target>
        </trans-unit>
        <trans-unit id="3390636be52618dc7d118d178ce5ea03789b0200" translate="yes" xml:space="preserve">
          <source>Database Corruption Warning</source>
          <target state="translated">数据库损坏警告</target>
        </trans-unit>
        <trans-unit id="89085c43a43d9dcfe7b225f94c340033a3bf8f40" translate="yes" xml:space="preserve">
          <source>Database File Corresponding To A Journal</source>
          <target state="translated">对应期刊的数据库文件</target>
        </trans-unit>
        <trans-unit id="e9ab5f94bcd6c1898d03a1e6b8469a59f0ed3a77" translate="yes" xml:space="preserve">
          <source>Database File Format</source>
          <target state="translated">数据库文件格式</target>
        </trans-unit>
        <trans-unit id="ff50d56bfc81a7b956e4d1921d6d66d7a383a42b" translate="yes" xml:space="preserve">
          <source>Database Header Format</source>
          <target state="translated">数据库头格式</target>
        </trans-unit>
        <trans-unit id="a3535d6748b55df8651025dc19ca0f9492aecee6" translate="yes" xml:space="preserve">
          <source>Database Object Name Resolution</source>
          <target state="translated">数据库对象名称解析</target>
        </trans-unit>
        <trans-unit id="bd8632f168d3516aef62fc843146b450c3c26a99" translate="yes" xml:space="preserve">
          <source>Database Page Size</source>
          <target state="translated">数据库页面大小</target>
        </trans-unit>
        <trans-unit id="4f02b6e9702df3600e6e312d593f7caa8819e1dd" translate="yes" xml:space="preserve">
          <source>Database Snapshot</source>
          <target state="translated">数据库快照</target>
        </trans-unit>
        <trans-unit id="bd1d5e56dd1e83bbe0ee14778f6008e4f92501fb" translate="yes" xml:space="preserve">
          <source>Database Speed Comparison</source>
          <target state="translated">数据库速度比较</target>
        </trans-unit>
        <trans-unit id="a8dad839985eddb5586b8b561fd417de9bc6e759" translate="yes" xml:space="preserve">
          <source>Database URI</source>
          <target state="translated">数据库URI</target>
        </trans-unit>
        <trans-unit id="2d4c00611e1b6734ce538563059febb504705359" translate="yes" xml:space="preserve">
          <source>Database as object</source>
          <target state="translated">数据库作为对象</target>
        </trans-unit>
        <trans-unit id="83a5cb19e95dc1d8b5d7e1441d8c579a45d5724b" translate="yes" xml:space="preserve">
          <source>Database cache can be optionally shared between connections in the same thread</source>
          <target state="translated">数据库缓存可以在同一线程的连接之间选择共享</target>
        </trans-unit>
        <trans-unit id="e7de38dba43f0a278e3056a00a39519bfc9b665e" translate="yes" xml:space="preserve">
          <source>Database connections can now be used by multiple threads, not just the thread in which they were created.</source>
          <target state="translated">数据库连接现在可以被多个线程使用,而不仅仅是创建它们的线程。</target>
        </trans-unit>
        <trans-unit id="212efa9f11c5959aadd0fce19cdf94993470615e" translate="yes" xml:space="preserve">
          <source>Database corruption caused by inconsistent use of 8+3 filenames</source>
          <target state="translated">由于不一致地使用8+3文件名导致数据库损坏。</target>
        </trans-unit>
        <trans-unit id="053ad514468635665438176cd86a58d603813544" translate="yes" xml:space="preserve">
          <source>Database filename aliasing</source>
          <target state="translated">数据库文件名别名</target>
        </trans-unit>
        <trans-unit id="3b7f204e04933e97d6ac68630583c1313b9cb271" translate="yes" xml:space="preserve">
          <source>Database files can now grow to be up to 2^41 bytes. The old limit was 2^31 bytes.</source>
          <target state="translated">数据库文件现在可以增长到2^41字节。旧的限制是2^31字节。</target>
        </trans-unit>
        <trans-unit id="73a52851158627ec8f4a087842d9a7bc471fcd2f" translate="yes" xml:space="preserve">
          <source>Database files that contain partial indices are not readable or writable by versions of SQLite prior to 3.8.0. However, a database file created by SQLite 3.8.0 is still readable and writable by prior versions as long as its schema contains no partial indexes. A database that is unreadable by legacy versions of SQLite can be made readable simply by running &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt; on the partial indexes.</source>
          <target state="translated">3.8.0之前的版本的SQLite无法读取或写入包含部分索引的数据库文件。但是，由SQLite 3.8.0创建的数据库文件仍可被以前的版本读取和写入，只要其架构不包含部分索引即可。只需在部分索引上运行&lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt;，就可以使旧版SQLite无法读取的数据库变得可读。</target>
        </trans-unit>
        <trans-unit id="b78486fa6ae30389540b15aab7739d7ecbc3140a" translate="yes" xml:space="preserve">
          <source>Database header</source>
          <target state="translated">数据库头</target>
        </trans-unit>
        <trans-unit id="d8a9d9190c53a37330666f4da1d52eb4d5397265" translate="yes" xml:space="preserve">
          <source>Database locks obtained by a connection in EXCLUSIVE mode may be released either by closing the database connection, or by setting the locking-mode back to NORMAL using this pragma and then accessing the database file (for read or write). Simply setting the locking-mode to NORMAL is not enough - locks are not released until the next time the database file is accessed.</source>
          <target state="translated">在EXCLUSIVE模式下的连接所获得的数据库锁可以通过关闭数据库连接来释放,或者通过使用这个pragma将锁定模式设置回NORMAL,然后访问数据库文件(读或写)。仅仅将锁定模式设置为NORMAL是不够的--在下次访问数据库文件之前,锁不会被释放。</target>
        </trans-unit>
        <trans-unit id="9118c7b06bcc534b6f4c486616838692892faa73" translate="yes" xml:space="preserve">
          <source>Database page size. Example: 1024</source>
          <target state="translated">数据库页面大小。例如:1024</target>
        </trans-unit>
        <trans-unit id="19e5379d75e917575fd8db9bff227b50947f62a7" translate="yes" xml:space="preserve">
          <source>Database read and write operations, and the way in which they interact with and use the</source>
          <target state="translated">数据库的读写操作,以及这些操作与数据库的交互和使用方式。</target>
        </trans-unit>
        <trans-unit id="c8a8e97f4d032178ae62a7d1cf0df7f938947c9e" translate="yes" xml:space="preserve">
          <source>Database zDb does not exist,</source>
          <target state="translated">数据库zDb不存在。</target>
        </trans-unit>
        <trans-unit id="684ece0a836446078b844add11528674b80daff5" translate="yes" xml:space="preserve">
          <source>Databases are opened using &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;Append VFS&lt;/a&gt; when the --append flag is used on the command line or with the .open command.</source>
          <target state="translated">当在命令行上使用--append标志或与.open命令一起使用&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;Append VFS&lt;/a&gt;打开数据库。</target>
        </trans-unit>
        <trans-unit id="537610cacac4e984aff9fc9a16523e33b6616036" translate="yes" xml:space="preserve">
          <source>Databases created by the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command always use the same encoding as the main database. An attempt to &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; a database with a different text encoding from the &quot;main&quot; database will fail.</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;命令创建的数据库始终使用与主数据库相同的编码。尝试使用与&amp;ldquo;主&amp;rdquo;数据库不同的文本编码来&lt;a href=&quot;lang_attach&quot;&gt;附加&lt;/a&gt;数据库的尝试将失败。</target>
        </trans-unit>
        <trans-unit id="3c4ce966e1af83816196cb8a675f0d67e707135b" translate="yes" xml:space="preserve">
          <source>Databases generated with this option enabled are not readable by SQLite version 3.1.6 (2005-03-17) and earlier. Also, databases generated with this option enabled are prone to triggering the &lt;a href=&quot;https://www.sqlite.org/src/info/e6e962d6b0f06f46e&quot;&gt;e6e962d6b0f06f46&lt;/a&gt; bug in the &lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; interface. For those reasons, this optimization is disabled by default. However, this optimization may be enabled by default in a future release of SQLite.</source>
          <target state="translated">启用了此选项的数据库不能被SQLite 3.1.6（2005-03-17）及更早版本读取。此外，启用此选项的情况下生成的数据库很容易在&lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;接口中触发&lt;a href=&quot;https://www.sqlite.org/src/info/e6e962d6b0f06f46e&quot;&gt;e6e962d6b0f06f46&lt;/a&gt;错误。由于这些原因，默认情况下将禁用此优化。但是，在将来的SQLite版本中可能默认启用此优化。</target>
        </trans-unit>
        <trans-unit id="2b3b2437f86ea4a0a8830ee6f8676cb1c3fc7da2" translate="yes" xml:space="preserve">
          <source>Datatype</source>
          <target state="translated">Datatype</target>
        </trans-unit>
        <trans-unit id="8562930b64d8c57b6dc3907022c61a4e6a5ac83f" translate="yes" xml:space="preserve">
          <source>Datatypes</source>
          <target state="translated">Datatypes</target>
        </trans-unit>
        <trans-unit id="baca0ff89b200ca165a0e54ccac355e7a923a643" translate="yes" xml:space="preserve">
          <source>Datatypes In SQLite Version 2</source>
          <target state="translated">SQLite中的数据类型第2版</target>
        </trans-unit>
        <trans-unit id="1148668ae941abc0a854dc721e03d190e3485da6" translate="yes" xml:space="preserve">
          <source>Datatypes In SQLite Version 3</source>
          <target state="translated">SQLite中的数据类型第3版</target>
        </trans-unit>
        <trans-unit id="1c55ea91377b3b902abf3a2f501f4ea2f40cdee4" translate="yes" xml:space="preserve">
          <source>Datatypes In SQLite version 2</source>
          <target state="translated">SQLite中的数据类型第2版</target>
        </trans-unit>
        <trans-unit id="233589836b520dde667809090f43b167594ea046" translate="yes" xml:space="preserve">
          <source>Date And Time Functions</source>
          <target state="translated">日期和时间功能</target>
        </trans-unit>
        <trans-unit id="6e2d2613130a40dc5bf62f65d270a32aa2b8b643" translate="yes" xml:space="preserve">
          <source>Date and time datatype</source>
          <target state="translated">日期和时间数据类型</target>
        </trans-unit>
        <trans-unit id="75a33d1bae263935cd17a2f9f5d07d057859dce8" translate="yes" xml:space="preserve">
          <source>Dbhash can be used to compare two databases to confirm that they are equivalent, even though their representation on disk is quite different. Dbhash might also be used to verify the content of a remote database without having to transmit the entire content of the remote database over a slow link.</source>
          <target state="translated">Dbhash可用于比较两个数据库,以确认它们是等价的,即使它们在磁盘上的表示方式大不相同。Dbhash还可以用来验证远程数据库的内容,而不必通过慢速链接传输远程数据库的全部内容。</target>
        </trans-unit>
        <trans-unit id="3bbc93e532fc52d7a861418ae6b728933b34062d" translate="yes" xml:space="preserve">
          <source>Dbhash ignores extraneous formatting details and hashes only the database schema and content. Hence the hash is constant even if the database file is modified by:</source>
          <target state="translated">Dbhash 忽略无关的格式细节,只对数据库模式和内容进行哈希。因此,即使数据库文件被修改,哈希值也是不变的。</target>
        </trans-unit>
        <trans-unit id="fb601abda7bdb73c50bfb1396b0751c831eb5fce" translate="yes" xml:space="preserve">
          <source>Dbhash is a command-line utility. To run it, type &quot;dbhash&quot; on a command-line prompt followed by the names of one or more SQLite database files that are to be hashed. The database hashes will be displayed on standard output. For example:</source>
          <target state="translated">Dbhash 是一个命令行工具。要运行它,请在命令行提示符上键入 &quot;dbhash&quot;,然后输入一个或多个要哈希的SQLite数据库文件的名称。数据库的哈希值将显示在标准输出中。例如,在命令行中输入</target>
        </trans-unit>
        <trans-unit id="e18681716fd7987f00ad554ff7f96da73e19fc13" translate="yes" xml:space="preserve">
          <source>Dbhash supports command-line options that can restrict the tables of the database file that are hashed, or restrict the hash to only content or only the schema. Run &quot;dbhash --help&quot; for further information.</source>
          <target state="translated">Dbhash支持命令行选项,这些选项可以限制数据库文件中被哈希的表,或限制哈希只限于内容或只限于模式。运行 &quot;dbhash --help &quot;可以获得更多信息。</target>
        </trans-unit>
        <trans-unit id="4a3882260abac88b66d6979bfd1282ccb93420d4" translate="yes" xml:space="preserve">
          <source>Deactivate the &lt;a href=&quot;lang_select#distinct&quot;&gt;DISTINCT&lt;/a&gt; keyword on subqueries on the right-hand side of the &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;lang_expr#in_op&quot;&gt;IN运算符&lt;/a&gt;右侧的子查询上停用&lt;a href=&quot;lang_select#distinct&quot;&gt;DISTINCT&lt;/a&gt;关键字。</target>
        </trans-unit>
        <trans-unit id="7f6794b197abfdc80b581fdd1340dcd8182be7db" translate="yes" xml:space="preserve">
          <source>Debugging Hints</source>
          <target state="translated">调试提示</target>
        </trans-unit>
        <trans-unit id="6558db0cb9f4028912366a41e3c7533d49d4b391" translate="yes" xml:space="preserve">
          <source>Debugging memory allocator</source>
          <target state="translated">调试内存分配器</target>
        </trans-unit>
        <trans-unit id="7c281fc0eea49fa90d5204752efe02a46e78181a" translate="yes" xml:space="preserve">
          <source>Debugging mode. Do not actually perform any optimizations but instead return one line of text for each optimization that would have been done. Off by default.</source>
          <target state="translated">调试模式。不实际执行任何优化,而是为每项优化返回一行本应执行的文本。默认为关闭。</target>
        </trans-unit>
        <trans-unit id="e4c3a2d0cc24a4535ef91791064ffe989cbd382a" translate="yes" xml:space="preserve">
          <source>Decimal</source>
          <target state="translated">Decimal</target>
        </trans-unit>
        <trans-unit id="4884a58f8854eaff9e14e4541fa2bfc15e139d8a" translate="yes" xml:space="preserve">
          <source>Declare The Schema Of A Virtual Table</source>
          <target state="translated">声明一个虚拟表的模式。</target>
        </trans-unit>
        <trans-unit id="c657d4e9ebee4c198c968bcba7aff6eeab9209c1" translate="yes" xml:space="preserve">
          <source>Declared Datatype Of A Query Result</source>
          <target state="translated">已声明的查询结果的数据类型</target>
        </trans-unit>
        <trans-unit id="52f7f00d0ba2d4f4aaef6d6440932d8183870fe3" translate="yes" xml:space="preserve">
          <source>Decompose the &quot;settings.xml&quot; file into an SQL table that is more easily viewed and edited by separate applications.</source>
          <target state="translated">将 &quot;settings.xml &quot;文件分解成一个SQL表,更容易被单独的应用程序查看和编辑。</target>
        </trans-unit>
        <trans-unit id="e090288f7922e2e7bbb158d2a90c3c98da108024" translate="yes" xml:space="preserve">
          <source>DecrJumpZero</source>
          <target state="translated">DecrJumpZero</target>
        </trans-unit>
        <trans-unit id="7078198f7cae420890a1abe183a812a6a35f8ed6" translate="yes" xml:space="preserve">
          <source>Default Value</source>
          <target state="translated">默认值</target>
        </trans-unit>
        <trans-unit id="349c243fc47f07030e17a3729d694bcfe2dadb05" translate="yes" xml:space="preserve">
          <source>Default builds of SQLite contain appropriate &lt;a href=&quot;vfs&quot;&gt;VFS objects&lt;/a&gt; for talking to underlying operating system, and those VFS objects will contain operating system calls such as open(), read(), write(), fsync(), and so forth. All of these interfaces are readily available on most platforms, and custom VFSes can be designed to run SQLite on even the most austere embedded devices.</source>
          <target state="translated">SQLite的默认内部版本包含用于与底层操作系统进行通信的适当&lt;a href=&quot;vfs&quot;&gt;VFS对象&lt;/a&gt;，并且这些VFS对象将包含诸如open（），read（），write（），fsync（）等操作系统调用。所有这些接口都可以在大多数平台上使用，并且可以将自定义VFS设计为即使在最苛刻的嵌入式设备上也可以运行SQLite。</target>
        </trans-unit>
        <trans-unit id="038803a5a725763be7d5665007510dd34ef1f8ce" translate="yes" xml:space="preserve">
          <source>Default memory allocator</source>
          <target state="translated">默认内存分配器</target>
        </trans-unit>
        <trans-unit id="e25af978372277845b3d313829fc8e2e019d17ec" translate="yes" xml:space="preserve">
          <source>Default page cache size.</source>
          <target state="translated">默认页面缓存大小。</target>
        </trans-unit>
        <trans-unit id="bdffe654f8554300a98d2acefcbbf1d894339b2b" translate="yes" xml:space="preserve">
          <source>Default value</source>
          <target state="translated">默认值</target>
        </trans-unit>
        <trans-unit id="f9d91891053643138161539927c04de3021744dd" translate="yes" xml:space="preserve">
          <source>Defense Against Dark Arts</source>
          <target state="translated">防御暗术</target>
        </trans-unit>
        <trans-unit id="c78392ffee2ec805b3bc60c680fa04c8a3bfdd3e" translate="yes" xml:space="preserve">
          <source>DeferredSeek</source>
          <target state="translated">DeferredSeek</target>
        </trans-unit>
        <trans-unit id="2a32a694b454b48f0c6093b3ea95bcc7ae1e63ab" translate="yes" xml:space="preserve">
          <source>Define New Collating Sequences</source>
          <target state="translated">定义新的整理序列</target>
        </trans-unit>
        <trans-unit id="7a8df33d7a4ee8c98b8a16229139f0094608d9e9" translate="yes" xml:space="preserve">
          <source>Define a static (but not constant) &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; structure that contains pointers to the xOpen method and the other methods and which contains the appropriate values for iVersion, szOsFile, mxPathname, zName, and pAppData.</source>
          <target state="translated">定义一个静态（但不是常数）&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;结构，该结构包含指向xOpen方法和其他方法的指针，并包含iVersion，szOsFile，mxPathname，zName和pAppData的适当值。</target>
        </trans-unit>
        <trans-unit id="d00d0274d811a9571e6a7d0d105251d14e6c534a" translate="yes" xml:space="preserve">
          <source>Define an appropriate subclass of the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object.</source>
          <target state="translated">定义&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;对象的适当子类。</target>
        </trans-unit>
        <trans-unit id="8eb6b16d370a1014df05c39f19a4497ee0d61573" translate="yes" xml:space="preserve">
          <source>Define the &quot;payload&quot; of a cell to be the arbitrary length section of the cell. For an index b-tree, the key is always arbitrary in length and hence the payload is the key. There are no arbitrary length elements in the cells of interior table b-tree pages and so those cells have no payload. Table b-tree leaf pages contain arbitrary length content and so for cells on those pages the payload is the content.</source>
          <target state="translated">定义单元的 &quot;有效载荷 &quot;为单元的任意长度部分。对于索引b树,键总是任意长度的,因此有效载荷就是键。在表b树内部页的单元格中没有任意长度的元素,因此这些单元格没有有效载荷。表b树叶页中含有任意长度的内容,因此对于这些页面上的单元格,有效载荷就是内容。</target>
        </trans-unit>
        <trans-unit id="09695710d6ec87af0ba3720c928922e55056227a" translate="yes" xml:space="preserve">
          <source>Define the depth of a leaf b-tree to be 1 and the depth of any interior b-tree to be one more than the maximum depth of any of its children. In a well-formed database, all children of an interior b-tree have the same depth.</source>
          <target state="translated">定义叶子b树的深度为1,任何内部b树的深度比其任何子树的最大深度多一个。在一个完善的数据库中,内部b树的所有子树都有相同的深度。</target>
        </trans-unit>
        <trans-unit id="e75225c3111252da2f1b0958f137acf031ed75f2" translate="yes" xml:space="preserve">
          <source>Defining this option causes the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; command to be omitted from the library. Attempting to execute an &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; statement will cause a parse error.</source>
          <target state="translated">定义此选项将导致从库中省略&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;命令。尝试执行&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;语句将导致解析错误。</target>
        </trans-unit>
        <trans-unit id="95e30519291de496ce9227bf803508402c5b0e39" translate="yes" xml:space="preserve">
          <source>Defining this option omits pragmas for querying and modifying the database schema version and user version from the build. Specifically, the &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version&lt;/a&gt; PRAGMAs are omitted.</source>
          <target state="translated">定义此选项将省略用于从构建中查询和修改数据库架构版本和用户版本的编译指示。具体来说，将省略&lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version&lt;/a&gt; PRAGMA。</target>
        </trans-unit>
        <trans-unit id="438bf5a3e905d9e27a03501948a3300c579faa96" translate="yes" xml:space="preserve">
          <source>Defining this option omits pragmas for querying the database schema from the build.</source>
          <target state="translated">定义这个选项可以省略从构建中查询数据库模式的实用程序。</target>
        </trans-unit>
        <trans-unit id="fb53b1a942ec49b6ce242dc0903a83562676a9de" translate="yes" xml:space="preserve">
          <source>Defining this option omits pragmas related to the pager subsystem from the build.</source>
          <target state="translated">定义这个选项可以从构建中省略与寻呼机子系统相关的实用程序。</target>
        </trans-unit>
        <trans-unit id="dc2296b74c87da37e10da27f66b21bb73a4427d7" translate="yes" xml:space="preserve">
          <source>Defining this option omits support for TRIGGER objects. Neither the &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; or &lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt; commands are available in this case, and attempting to execute either will result in a parse error. This option also disables enforcement of &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt;, since the code that implements triggers and which is omitted by this option is also used to implement &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt;.</source>
          <target state="translated">定义此选项将省略对TRIGGER对象的支持。无论是&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;或&lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt;命令在这种情况下是可用的，并试图执行要么会导致解析错误。此选项还禁用&lt;a href=&quot;foreignkeys&quot;&gt;外键约束的实施&lt;/a&gt;，因为实现触发器的代码（此选项省略了该代码）也用于实现&lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;外键动作&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="15c4cfc354a842ec38f01dc56ced3bf25c4ad5b6" translate="yes" xml:space="preserve">
          <source>Defining this option omits support for VIEW objects. Neither the &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; nor the &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; commands are available in this case, and attempting to execute either will result in a parse error.</source>
          <target state="translated">定义此选项将省略对VIEW对象的支持。无论是&lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;也没有&lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt;命令，在这种情况下是可用的，并试图既可以执行将导致解析错误。</target>
        </trans-unit>
        <trans-unit id="a8d0bb74e48c16e4de7827a8ffc7d0dc3f87633f" translate="yes" xml:space="preserve">
          <source>Defining this option omits the authorization callback feature from the library. The &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; API function is not present in the library.</source>
          <target state="translated">定义此选项将忽略库中的授权回调功能。该库中不存在&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt; API函数。</target>
        </trans-unit>
        <trans-unit id="83f644802e49a1cbe2ffeee1f4e6042a39cd0de9" translate="yes" xml:space="preserve">
          <source>Definition: A &lt;b&gt;result table&lt;/b&gt; is memory data structure created by the &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; interface. A result table records the complete query results from one or more queries.</source>
          <target state="translated">定义：&lt;b&gt;结果表&lt;/b&gt;是由&lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;接口创建的内存数据结构。结果表记录一个或多个查询的完整查询结果。</target>
        </trans-unit>
        <trans-unit id="e259d1f20b6fd6c9ce46ea6e1dc31fde6f204fb8" translate="yes" xml:space="preserve">
          <source>Definition: A &lt;b&gt;result table&lt;/b&gt; is memory data structure created by the &lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; interface. A result table records the complete query results from one or more queries.</source>
          <target state="translated">定义：&lt;b&gt;结果表&lt;/b&gt;是由&lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;接口创建的内存数据结构。结果表记录一个或多个查询的完整查询结果。</target>
        </trans-unit>
        <trans-unit id="f6fdbe48dc54dd86f63097a03bd24094dedd713a" translate="yes" xml:space="preserve">
          <source>Delete</source>
          <target state="translated">Delete</target>
        </trans-unit>
        <trans-unit id="6ae0a530b1b7677b78998487aadb9d2cadf7f88f" translate="yes" xml:space="preserve">
          <source>Delete A Changegroup Object</source>
          <target state="translated">删除一个变更组对象</target>
        </trans-unit>
        <trans-unit id="2b620c0b18464aba1294c125c40ed5d238146244" translate="yes" xml:space="preserve">
          <source>Delete A Session Object</source>
          <target state="translated">删除会话对象</target>
        </trans-unit>
        <trans-unit id="12eda7c48435244e864fe35cc6d11a7bc5eebd9b" translate="yes" xml:space="preserve">
          <source>Delete a changeset rebaser object</source>
          <target state="translated">删除改变集rebaser对象</target>
        </trans-unit>
        <trans-unit id="6ccb779f78fa4c2f40b79e1431ac32a6c85e1c13" translate="yes" xml:space="preserve">
          <source>Delete a changeset rebaser object.</source>
          <target state="translated">删除一个改变集rebaser对象。</target>
        </trans-unit>
        <trans-unit id="12991bc9bb4a12d326aa6753050041d7a4fabc24" translate="yes" xml:space="preserve">
          <source>Delete a session object previously allocated using &lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt;. Once a session object has been deleted, the results of attempting to use pSession with any other session module function are undefined.</source>
          <target state="translated">删除先前使用&lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create（）&lt;/a&gt;分配的会话对象。删除会话对象后，尝试将pSession与其他任何会话模块功能一起使用的结果均未定义。</target>
        </trans-unit>
        <trans-unit id="d762d1040e85482796c9fd4d534519cef24d74ed" translate="yes" xml:space="preserve">
          <source>Delete a session object previously allocated using &lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt;. Once a session object has been deleted, the results of attempting to use pSession with any other session module function are undefined.</source>
          <target state="translated">删除先前使用&lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create（）&lt;/a&gt;分配的会话对象。删除会话对象后，尝试将pSession与其他任何会话模块功能一起使用的结果均未定义。</target>
        </trans-unit>
        <trans-unit id="02512a6317bed133605bfc468e6ef4822f972b23" translate="yes" xml:space="preserve">
          <source>Delete all contents from the ephemeral table or sorter that is open on cursor P1.</source>
          <target state="translated">删除光标P1上打开的历时表或分拣机中的所有内容。</target>
        </trans-unit>
        <trans-unit id="aedb82abe0e510f8fa2d29632ac81d5268819e7f" translate="yes" xml:space="preserve">
          <source>Delete all contents of the database table or index whose root page in the database file is given by P1. But, unlike &lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt;, do not remove the table or index from the database file.</source>
          <target state="translated">删除数据库表或索引的所有内容，数据库表或索引的根页由P1给出。但是，与&lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt;不同，请不要从数据库文件中删除表或索引。</target>
        </trans-unit>
        <trans-unit id="6f095a0ada2906d2012dfcefd96beaf7902bce51" translate="yes" xml:space="preserve">
          <source>Delete all individual journal files.</source>
          <target state="translated">删除所有的个人日志文件。</target>
        </trans-unit>
        <trans-unit id="bf1b9b7fadc6e867c3913361047ae2f1e082e237" translate="yes" xml:space="preserve">
          <source>Delete an entire database table or index whose root page in the database file is given by P1.</source>
          <target state="translated">删除数据库文件中根页面由P1给出的整个数据库表或索引。</target>
        </trans-unit>
        <trans-unit id="5bc9013dca7ae3cd28443b3643084c1962bbbebb" translate="yes" xml:space="preserve">
          <source>Delete the changeset rebaser object and all associated resources. There should be one call to this function for each successful invocation of sqlite3rebaser_create().</source>
          <target state="translated">删除变化集rebaser对象和所有相关资源。每成功调用一次sqlite3rebaser_create(),就应该调用一次这个函数。</target>
        </trans-unit>
        <trans-unit id="60bf70613708367f728d96356276360d98741581" translate="yes" xml:space="preserve">
          <source>Delete the journal file (or truncate the journal to zero bytes in length if &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=TRUNCATE&lt;/a&gt; is set, or zero the journal header if &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=PERSIST&lt;/a&gt; is set).</source>
          <target state="translated">删除日志文件（如果设置了&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = TRUNCATE&lt;/a&gt;，则将日志的长度截断为零字节；如果设置了&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = PERSIST&lt;/a&gt;，则将日志的标题截断为零）。</target>
        </trans-unit>
        <trans-unit id="424c686346d72ee424e3afead9478d41b73e0e95" translate="yes" xml:space="preserve">
          <source>Delete the journal file. (Or if the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt; is TRUNCATE or PERSIST, truncate the journal file or zero the header of the journal file, respectively.) This is the instant when the changes are committed. Prior to deleting the journal file, if a power failure or crash occurs, the next process to open the database will see that it has a hot journal and will roll the changes back. After the journal is deleted, there will no longer be a hot journal and the changes will persist.</source>
          <target state="translated">删除日志文件。（或者，如果&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt;为TRUNCATE或PERSIST，则分别截断日志文件或将日志文件的标题清零。）这是提交更改的瞬间。在删除日志文件之前，如果发生电源故障或崩溃，则下一个打开数据库的过程将看到它具有热日志，并将回滚所做的更改。删除日志后，将不再有热日志，并且更改将保留。</target>
        </trans-unit>
        <trans-unit id="aae017b3d4b04098148419004c202430e143c042" translate="yes" xml:space="preserve">
          <source>Delete the master journal file if it is safe to do so. This step is optional. It is here only to prevent stale master journals from cluttering up the disk drive. See the discussion below for details.</source>
          <target state="translated">如果安全的话,删除主日志文件。这一步是可选的。此处只是为了防止过期的主日志杂乱无章地占据磁盘驱动器。详情请看下面的讨论。</target>
        </trans-unit>
        <trans-unit id="e10f41bbb6b9a5c4d90c81334bd806252b81f5b3" translate="yes" xml:space="preserve">
          <source>Delete the master journal file. This is the instant when the changes are committed. Prior to deleting the master journal file, if a power failure or crash occurs, the individual file journals will be considered hot and will be rolled back by the next process that attempts to read them. After the master journal has been deleted, the file journals will no longer be considered hot and the changes will persist.</source>
          <target state="translated">删除主日志文件。这是提交更改的瞬间。在删除主日志文件之前,如果发生断电或崩溃,单个文件日志将被视为热日志,并将被下一个试图读取它们的进程回滚。主日志被删除后,文件日志将不再被视为热日志,更改将持续存在。</target>
        </trans-unit>
        <trans-unit id="29e75bc2e3dd1128b5b5e72142f38e94e6c04b31" translate="yes" xml:space="preserve">
          <source>Delete the record at which the P1 cursor is currently pointing.</source>
          <target state="translated">删除当前P1光标所指向的记录。</target>
        </trans-unit>
        <trans-unit id="4fcd91afe095d0c6dacc95e2b6d58ad6d5e14534" translate="yes" xml:space="preserve">
          <source>Delete the super-journal file if it is safe to do so. This step is optional. It is here only to prevent stale super-journals from cluttering up the disk drive. See the discussion below for details.</source>
          <target state="translated">如果安全的话,请删除超级日记本文件。这一步是可选的。此处只是为了防止陈旧的超级日志在磁盘驱动器上堆积。详情请看下面的讨论。</target>
        </trans-unit>
        <trans-unit id="2453d64dea3e074099ee813a3f51329c03660891" translate="yes" xml:space="preserve">
          <source>Delete the super-journal file. This is the instant when the changes are committed. Prior to deleting the super-journal file, if a power failure or crash occurs, the individual file journals will be considered hot and will be rolled back by the next process that attempts to read them. After the super-journal has been deleted, the file journals will no longer be considered hot and the changes will persist.</source>
          <target state="translated">删除超级日志文件。这是修改提交的瞬间。在删除超级日志文件之前,如果发生断电或崩溃,单个文件日志将被视为热点,并将被下一个试图读取它们的进程回滚。在删除超级日志后,文件日志将不再被视为热日志,更改将持续存在。</target>
        </trans-unit>
        <trans-unit id="91c899cb9487830103f86062414b65279777c00c" translate="yes" xml:space="preserve">
          <source>Delete triggers fire when rows are removed due to a &lt;a href=&quot;lang_conflict&quot;&gt;REPLACE conflict resolution&lt;/a&gt;. This feature is only enabled when recursive triggers are enabled.</source>
          <target state="translated">由于&lt;a href=&quot;lang_conflict&quot;&gt;REPLACE解决冲突&lt;/a&gt;而删除行时，Delete触发器将触发。仅在启用递归触发器时才启用此功能。</target>
        </trans-unit>
        <trans-unit id="f97f11b2a9d7f4d5cfcb9f5b6bc157b876524629" translate="yes" xml:space="preserve">
          <source>Deleting a file is an expensive operation on many systems. So as an optimization, SQLite can be configured to avoid the delete operation of &lt;a href=&quot;#section_3_11&quot;&gt;section 3.11&lt;/a&gt;. Instead of deleting the journal file in order to commit a transaction, the file is either truncated to zero bytes in length or its header is overwritten with zeros. Truncating the file to zero length saves having to make modifications to the directory containing the file since the file is not removed from the directory. Overwriting the header has the additional savings of not having to update the length of the file (in the &quot;inode&quot; on many systems) and not having to deal with newly freed disk sectors. Furthermore, at the next transaction the journal will be created by overwriting existing content rather than appending new content onto the end of a file, and overwriting is often much faster than appending.</source>
          <target state="translated">在许多系统上，删除文件是一项昂贵的操作。因此，作为一种优化，可以配置SQLite以避免&lt;a href=&quot;#section_3_11&quot;&gt;3.11节&lt;/a&gt;的删除操作。。而不是删除日记文件以提交事务，该文件要么被截断为零字节长度，要么其头被零覆盖。将文件截断为零长度可以节省对包含文件的目录的修改，因为不会从目录中删除文件。覆盖头具有额外的节省，不必更新文件的长度（在许多系统上位于&amp;ldquo; inode&amp;rdquo;中），也不必处理新释放的磁盘扇区。此外，在下一次交易中，将通过覆盖现有内容而不是将新内容附加到文件末尾来创建日记，并且覆盖通常比附加快得多。</target>
        </trans-unit>
        <trans-unit id="2696b8d0813903709611732c9e8977b50fd62e40" translate="yes" xml:space="preserve">
          <source>Deleting a file is not really an atomic operation, but it appears to be from the point of view of a user process. A process is always able to ask the operating system &quot;does this file exist?&quot; and the process will get back a yes or no answer. After a power failure that occurs during a transaction commit, SQLite will ask the operating system whether or not the rollback journal file exists. If the answer is &quot;yes&quot; then the transaction is incomplete and is rolled back. If the answer is &quot;no&quot; then it means the transaction did commit.</source>
          <target state="translated">删除一个文件并不是真正的原子操作,但从用户进程的角度来看,它似乎是一个原子操作。进程总是能够问操作系统 &quot;这个文件是否存在?&quot;,进程会得到一个是或不是的答案。在事务提交过程中发生断电后,SQLite会询问操作系统 &quot;回滚日志文件是否存在&quot;。如果答案是 &quot;是&quot;,那么事务不完整,会被回滚。如果答案是 &quot;no&quot;,那么意味着事务确实提交了。</target>
        </trans-unit>
        <trans-unit id="c09fda80ecfdf9e281d56a4afdd3670077682c0b" translate="yes" xml:space="preserve">
          <source>Deleting a hot journal</source>
          <target state="translated">删除热门日志</target>
        </trans-unit>
        <trans-unit id="9d50c7931911f099d06f9c5c9dcef20c05a1a010" translate="yes" xml:space="preserve">
          <source>Deliberately changing out of WAL mode changes the database file format version numbers back to 1 so that older versions of SQLite can once again access the database file.</source>
          <target state="translated">故意改出WAL模式,将数据库文件格式的版本号改回1,这样老版本的SQLite可以再次访问数据库文件。</target>
        </trans-unit>
        <trans-unit id="94c24d036a23e21672451696acb1226b9371946b" translate="yes" xml:space="preserve">
          <source>Deny oneself in order to follow Christ.</source>
          <target state="translated">为了跟从基督而舍弃自己。</target>
        </trans-unit>
        <trans-unit id="4b72ef41c3b1c98245c65c2469b7a10fdf627d58" translate="yes" xml:space="preserve">
          <source>Depending how badly your database is corrupted, you may be able to recover some of the data by using the CLI to dump the schema and contents to a file and then recreate. Unfortunately, once humpty-dumpty falls off the wall, it is generally not possible to put him back together again.</source>
          <target state="translated">根据你的数据库损坏的严重程度,你也许可以通过使用CLI将模式和内容转储到一个文件,然后重新创建来恢复一些数据。不幸的是,一旦humpty-dumpty从墙上掉下来,一般情况下是不可能再把他装回去的。</target>
        </trans-unit>
        <trans-unit id="5466f1e1c1f4f0fffe016c26643a67d2ad503e26" translate="yes" xml:space="preserve">
          <source>Depending on the query, SQLite might need to materialize the &quot;(SELECT b FROM ex2)&quot; subquery into a temporary table, then perform the join between ex1 and the temporary table. The query optimizer tries to avoid this by &quot;flattening&quot; the query. In the previous example the query can be flattened, and SQLite will automatically transform the query into</source>
          <target state="translated">根据查询,SQLite可能需要将&quot;(SELECT b FROM ex2)&quot;子查询具体化为一个临时表,然后在ex1和临时表之间执行连接。查询优化器试图通过 &quot;扁平化 &quot;查询来避免这种情况。在前面的例子中,可以对查询进行扁平化处理,SQLite会自动将查询转化为</target>
        </trans-unit>
        <trans-unit id="886d67dc402c58b18f059201de3cb182bdcca2d0" translate="yes" xml:space="preserve">
          <source>Depending on the type of conflict, a sessions application has a variety of configurable options for dealing with conflicts, ranging from omitting the conflicting change, aborting the entire changeset application or applying the change despite the conflict. For details, refer to the documentation for the &lt;a href=&quot;session/sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; API.</source>
          <target state="translated">根据冲突的类型，会话应用程序可以使用多种可配置的选项来处理冲突，从忽略冲突的更改，中止整个变更集应用程序或尽管发生冲突也应用更改。有关详细信息，请参阅&lt;a href=&quot;session/sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt; API 的文档。</target>
        </trans-unit>
        <trans-unit id="99099b8d7e1bb8542438e0ec64f4aa03573d7d34" translate="yes" xml:space="preserve">
          <source>Depending on which parameter is being interrogated, one of the VALUE or HIWTR mark measurements might be undefined. For example, only the high-water mark is meaningful for &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmallocsize&quot;&gt;SQLITE_STATUS_MALLOC_SIZE&lt;/a&gt;, and only the current value is meaningful for &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscacheused&quot;&gt;SQLITE_DBSTATUS_CACHE_USED&lt;/a&gt;. For rows where one or the other of VALUE or HIWTR is not meaningful, that value is returned as NULL. the interfaces, with the initial</source>
          <target state="translated">根据要询问的参数，可能未定义VALUE或HIWTR标记测量之一。例如，仅在高水位标记是有意义&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmallocsize&quot;&gt;SQLITE_STATUS_MALLOC_SIZE&lt;/a&gt;，并且只有当前值是有意义的&lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscacheused&quot;&gt;SQLITE_DBSTATUS_CACHE_USED&lt;/a&gt;。对于VALUE或HIWTR中一个或另一个没有意义的行，该值将返回NULL。接口，与初始</target>
        </trans-unit>
        <trans-unit id="3a49085fe4eb15cab436b357201995ee9bf9e4bd" translate="yes" xml:space="preserve">
          <source>Depending on your hardware and operating system, you should see that reads from the test1.db database file are about 35% faster than reads from individual files in the test1.dir or test1.tree folders. Results can vary significantly from one run to the next due to caching, so it is advisable to run tests multiple times and take an average or a worst case or a best case, depending on your requirements.</source>
          <target state="translated">根据您的硬件和操作系统,您应该看到,从test1.db数据库文件读取比从test1.dir或test1.tree文件夹中的单个文件读取要快35%左右。由于缓存的原因,每次运行的结果可能会有很大的不同,所以建议多次运行测试,并根据您的要求取一个平均值或最坏情况或最佳情况。</target>
        </trans-unit>
        <trans-unit id="527600bf0272b6bf3abcb495a99c6ee346bb82b2" translate="yes" xml:space="preserve">
          <source>Deprecated</source>
          <target state="translated">Deprecated</target>
        </trans-unit>
        <trans-unit id="42a66abe1669ce3ffad7695dbe407c22ed591eb2" translate="yes" xml:space="preserve">
          <source>Deprecated Functions</source>
          <target state="translated">废弃的函数</target>
        </trans-unit>
        <trans-unit id="bfc32553e9a3941dedadb9fb40b33e7008f653d9" translate="yes" xml:space="preserve">
          <source>Deprecated Soft Heap Limit Interface</source>
          <target state="translated">废弃的软堆限制接口</target>
        </trans-unit>
        <trans-unit id="3a682fd508565521834d60be19ff2f936a43d34b" translate="yes" xml:space="preserve">
          <source>Deprecated interfaces have been superceded by better methods of accomplishing the same thing and should be avoided in new applications. Deprecated interfaces continue to be supported for the sake of backwards compatibility. At some point in the future, it is possible that deprecated interfaces may be removed.</source>
          <target state="translated">废弃的接口已经被更好的方法所取代,在新的应用中应该避免使用这些接口。为了向后的兼容性,废弃的接口将继续得到支持。在未来的某一天,被废弃的接口有可能会被删除。</target>
        </trans-unit>
        <trans-unit id="2bd86ca0936a352d07e01faf8385985c6bcfbe7d" translate="yes" xml:space="preserve">
          <source>Deprecated interfaces should not be used in new code and might be removed in some future release.</source>
          <target state="translated">废弃的接口不应该在新的代码中使用,可能会在未来的某个版本中被删除。</target>
        </trans-unit>
        <trans-unit id="384385f4ecfb14efac5a6de95da0a3708e15bd88" translate="yes" xml:space="preserve">
          <source>Descending indices</source>
          <target state="translated">降序指数</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="4d25e019c14ea4edb8919779e923685a3363cdef" translate="yes" xml:space="preserve">
          <source>Description Of File Format Change</source>
          <target state="translated">文件格式变更说明</target>
        </trans-unit>
        <trans-unit id="cd8429891c87cd83470eecb59eba348d84f2f5d1" translate="yes" xml:space="preserve">
          <source>Deserialize a database</source>
          <target state="translated">反序列化数据库</target>
        </trans-unit>
        <trans-unit id="99d0530263d176ccac0fdc529fd7f2dedfa20826" translate="yes" xml:space="preserve">
          <source>Designing software is hard. It takes a lot of focus. A good version control system should provide the developer with assistance, not frustration. Git has gotten better in this regard over the past decade, but it still has a long way to go.</source>
          <target state="translated">设计软件是很难的。它需要大量的注意力。一个好的版本控制系统应该为开发者提供帮助,而不是挫败感。在过去的十年中,Git在这方面已经变得更好了,但它仍然有很长的路要走。</target>
        </trans-unit>
        <trans-unit id="a83ebad2040aac26354ce69d33c75a8e23379288" translate="yes" xml:space="preserve">
          <source>Desire eternal life with all the passion of the spirit.</source>
          <target state="translated">用精神的全部热情渴望永恒的生命。</target>
        </trans-unit>
        <trans-unit id="7cd8f751199e13822ef7d9714c88c6e47db10e8e" translate="yes" xml:space="preserve">
          <source>Despite the name, this function always returns a value between 0.0 and 1.0 equal to (</source>
          <target state="translated">尽管名字很好听,但这个函数总是返回一个介于0.0和1.0之间的值,等于(</target>
        </trans-unit>
        <trans-unit id="577ef7dc1516f4b3c43ddbe63327a8a039a0edec" translate="yes" xml:space="preserve">
          <source>Destroy</source>
          <target state="translated">Destroy</target>
        </trans-unit>
        <trans-unit id="839c441dcc29d361bfacf38afa416f18a1637928" translate="yes" xml:space="preserve">
          <source>Destroy A Prepared Statement Object</source>
          <target state="translated">销毁一个已准备好的声明对象</target>
        </trans-unit>
        <trans-unit id="8a43abf112611732f3dfb583fa8f44e2049379d4" translate="yes" xml:space="preserve">
          <source>Destroy a snapshot</source>
          <target state="translated">销毁快照</target>
        </trans-unit>
        <trans-unit id="7d83f3ed4b5d324ccef4af3b6f9a3539eb93e67c" translate="yes" xml:space="preserve">
          <source>Destroy the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; using &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;销毁&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c75278c7e28535f5ea9e950ab84092bdea32a614" translate="yes" xml:space="preserve">
          <source>Destroy the object using &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;销毁对象。</target>
        </trans-unit>
        <trans-unit id="64b1ed1f1b53763efdc1c78265116d5fa0da95e8" translate="yes" xml:space="preserve">
          <source>Destroy the object using &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;销毁对象。</target>
        </trans-unit>
        <trans-unit id="5284d7d2a9c5b9dbf72aafe5558f4a26a439739f" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;</source>
          <target state="translated">析构&lt;a href=&quot;#sqlite3_blob_close&quot;&gt;函数&lt;/a&gt;：sqlite3_blob_close（）</target>
        </trans-unit>
        <trans-unit id="1afb291d062f0484331555f28baeeafd003c3dfa" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;</source>
          <target state="translated">析构&lt;a href=&quot;#sqlite3_finalize&quot;&gt;函数&lt;/a&gt;：sqlite3_finalize（）</target>
        </trans-unit>
        <trans-unit id="be5ef256fde14f27a6be2d2b33459ee64ab4a321" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt;</source>
          <target state="translated">析构&lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;函数&lt;/a&gt;：sqlite3_snapshot_free（）</target>
        </trans-unit>
        <trans-unit id="1bc54ba31c2c513271f833dc8e2d60c1be1b1091" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt;</source>
          <target state="translated">析构&lt;a href=&quot;#sqlite3_str_finish&quot;&gt;函数&lt;/a&gt;：sqlite3_str_finish（）</target>
        </trans-unit>
        <trans-unit id="689b80c76ccc07fa3d2942a087706f3eef81d330" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;#sqlite3changegroup_delete&quot;&gt;sqlite3changegroup_delete()&lt;/a&gt;</source>
          <target state="translated">析构&lt;a href=&quot;#sqlite3changegroup_delete&quot;&gt;函数&lt;/a&gt;：sqlite3changegroup_delete（）</target>
        </trans-unit>
        <trans-unit id="c105a9f0c702f6cd4ef79cd3b0f385965920de3c" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;#sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt;</source>
          <target state="translated">析构&lt;a href=&quot;#sqlite3session_delete&quot;&gt;函数&lt;/a&gt;：sqlite3session_delete（）</target>
        </trans-unit>
        <trans-unit id="ed39236d0e8e7446d0cb599cd5b738b2811bcf10" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;</source>
          <target state="translated">析构&lt;a href=&quot;blob_close&quot;&gt;函数&lt;/a&gt;：sqlite3_blob_close（）</target>
        </trans-unit>
        <trans-unit id="d822a3174515e8f21e47ce59b4339bb51f6db978" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;</source>
          <target state="translated">析构&lt;a href=&quot;finalize&quot;&gt;函数&lt;/a&gt;：sqlite3_finalize（）</target>
        </trans-unit>
        <trans-unit id="f60221cb8d7f3a49adecb2493f31cebddcb5e00c" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt;</source>
          <target state="translated">析构&lt;a href=&quot;snapshot_free&quot;&gt;函数&lt;/a&gt;：sqlite3_snapshot_free（）</target>
        </trans-unit>
        <trans-unit id="e83f5c6e38c161fc2b5c1d7abe156cb9aad8f5f3" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;sqlite3changegroup_delete&quot;&gt;sqlite3changegroup_delete()&lt;/a&gt;</source>
          <target state="translated">析构&lt;a href=&quot;sqlite3changegroup_delete&quot;&gt;函数&lt;/a&gt;：sqlite3changegroup_delete（）</target>
        </trans-unit>
        <trans-unit id="41e4345992429802aea5872bac2716f7c77be8e3" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt;</source>
          <target state="translated">析构&lt;a href=&quot;sqlite3session_delete&quot;&gt;函数&lt;/a&gt;：sqlite3session_delete（）</target>
        </trans-unit>
        <trans-unit id="e6b6c509cccb52d51368c6e4ebb375738475d8f0" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt;</source>
          <target state="translated">析构&lt;a href=&quot;str_finish&quot;&gt;函数&lt;/a&gt;：sqlite3_str_finish（）</target>
        </trans-unit>
        <trans-unit id="359201cc8ce5eb69bceb0fd81af7a37ed2f96a48" translate="yes" xml:space="preserve">
          <source>Destructors: &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2()&lt;/a&gt;</source>
          <target state="translated">析构&lt;a href=&quot;#sqlite3_close&quot;&gt;函数&lt;/a&gt;：sqlite3_close（），&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4e0b565701116b40edb353da662ba766f93f65b1" translate="yes" xml:space="preserve">
          <source>Destructors: &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;, &lt;a href=&quot;close&quot;&gt;sqlite3_close_v2()&lt;/a&gt;</source>
          <target state="translated">析构&lt;a href=&quot;close&quot;&gt;函数&lt;/a&gt;：sqlite3_close（），&lt;a href=&quot;close&quot;&gt;sqlite3_close_v2（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="3ee5fd57c6234479272be39f53b7a756c8fad2c3" translate="yes" xml:space="preserve">
          <source>Details of the low-level B-tree format used in SQLite version 3.0 can be found in header comments to the &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/btreeInt.h&quot;&gt;btreeInt.h&lt;/a&gt; source file and in the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; documentation.</source>
          <target state="translated">可在&lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/btreeInt.h&quot;&gt;btreeInt.h&lt;/a&gt;源文件的标题注释中和&lt;a href=&quot;fileformat2&quot;&gt;文件格式&lt;/a&gt;文档中找到SQLite 3.0版中使用的低级B树格式的详细信息。</target>
        </trans-unit>
        <trans-unit id="86854b99d9fbede6e67de0731be237a6aa227bba" translate="yes" xml:space="preserve">
          <source>Details of the low-level B-tree format used in SQLite version 3.0 can be found in header comments to the &lt;a href=&quot;https://www.sqlite.org/src/finfo?name=src/btreeInt.h&quot;&gt;btreeInt.h&lt;/a&gt; source file and in the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; documentation.</source>
          <target state="translated">可在&lt;a href=&quot;https://www.sqlite.org/src/finfo?name=src/btreeInt.h&quot;&gt;btreeInt.h&lt;/a&gt;源文件的标题注释中和&lt;a href=&quot;fileformat2&quot;&gt;文件格式&lt;/a&gt;文档中找到SQLite 3.0版中使用的低级B树格式的详细信息。</target>
        </trans-unit>
        <trans-unit id="057c54e32daecfe5f3f91aea6c17b8880637989a" translate="yes" xml:space="preserve">
          <source>Detect integer overflow in abs().</source>
          <target state="translated">检测abs()中的整数溢出。</target>
        </trans-unit>
        <trans-unit id="0cb93bae74fdeaac6fc236f4e82d733ebb774f3f" translate="yes" xml:space="preserve">
          <source>Determine If A Prepared Statement Has Been Reset</source>
          <target state="translated">确定已编制的报表是否已被重设</target>
        </trans-unit>
        <trans-unit id="db966195ad1f618275836e22992513b99d0a007c" translate="yes" xml:space="preserve">
          <source>Determine If An SQL Statement Is Complete</source>
          <target state="translated">确定一个SQL语句是否完整</target>
        </trans-unit>
        <trans-unit id="625d5f335e20e089846651b3578340604a6b4c2f" translate="yes" xml:space="preserve">
          <source>Determine If An SQL Statement Writes The Database</source>
          <target state="translated">确定一条SQL语句是否写入数据库</target>
        </trans-unit>
        <trans-unit id="eb26a9bebe8d2e098f033d011256a86267629d8a" translate="yes" xml:space="preserve">
          <source>Determine If Virtual Table Column Access Is For UPDATE</source>
          <target state="translated">确定虚拟表列访问是否是为了UPDATE</target>
        </trans-unit>
        <trans-unit id="5ad12b059791066c3ea756f7418d5b987aa492a2" translate="yes" xml:space="preserve">
          <source>Determine The Collation For a Virtual Table Constraint</source>
          <target state="translated">确定虚拟表约束的整理方式</target>
        </trans-unit>
        <trans-unit id="c8aa46b4240b68859dbf6ca40dcc17adbb0b5d9d" translate="yes" xml:space="preserve">
          <source>Determine The Number Of Foreign Key Constraint Violations</source>
          <target state="translated">确定违反外键约束的数量。</target>
        </trans-unit>
        <trans-unit id="3e28f586fecd10c20cfef343cf0e0a2554afa731" translate="yes" xml:space="preserve">
          <source>Determine The Virtual Table Conflict Policy</source>
          <target state="translated">确定虚拟表冲突策略</target>
        </trans-unit>
        <trans-unit id="378e53b0c9705af12aa3d20a3dfea2de180d3964" translate="yes" xml:space="preserve">
          <source>Determine if a database is read-only</source>
          <target state="translated">确定数据库是否为只读。</target>
        </trans-unit>
        <trans-unit id="f1558195c991d1d2ecb7709c602a5647cac88ff4" translate="yes" xml:space="preserve">
          <source>Determine the transaction state of a database</source>
          <target state="translated">确定数据库的事务状态</target>
        </trans-unit>
        <trans-unit id="ec9ead520b9e56d263fd7de0b9b24771183e3061" translate="yes" xml:space="preserve">
          <source>Deterministic SQL Functions</source>
          <target state="translated">确定性SQL函数</target>
        </trans-unit>
        <trans-unit id="96de162ae9388387b4d27ffd24dfdaec4b72faef" translate="yes" xml:space="preserve">
          <source>Developers report that SQLite is often faster than a client/server SQL database engine in this scenario. Database requests are serialized by the server, so concurrency is not an issue. Concurrency is also improved by &quot;database sharding&quot;: using separate database files for different subdomains. For example, the server might have a separate SQLite database for each user, so that the server can handle hundreds or thousands of simultaneous connections, but each SQLite database is only used by one connection.</source>
          <target state="translated">开发人员报告说,在这种情况下,SQLite通常比客户/服务器SQL数据库引擎更快。数据库请求是由服务器序列化的,所以并发性不是问题。并发性还可以通过 &quot;数据库分片 &quot;来提高:为不同的子域使用单独的数据库文件。例如,服务器可能为每个用户都有一个单独的SQLite数据库,这样服务器就可以处理成百上千的并发连接,但每个SQLite数据库只被一个连接使用。</target>
        </trans-unit>
        <trans-unit id="b17665b2663239e18f10a989ee4b32e6490c33f2" translate="yes" xml:space="preserve">
          <source>Developers sometimes experience trouble debugging the 185,000-line-long amalgamation source file because some debuggers are only able to handle source code line numbers less than 32,768. The amalgamation source code runs fine. One just cannot single-step through it in a debugger.</source>
          <target state="translated">开发人员有时会遇到调试185,000行的amalgamation源文件的麻烦,因为一些调试器只能处理少于32,768行的源代码行数。amalgamation源码运行良好。只是不能在调试器中单步通过它。</target>
        </trans-unit>
        <trans-unit id="db23e94c152c3c70f28ce4fd2250cf8e7e90d0ef" translate="yes" xml:space="preserve">
          <source>Device Characteristics</source>
          <target state="translated">设备特性</target>
        </trans-unit>
        <trans-unit id="10fe8e0881142639bc54f8ec9a79de4f49557439" translate="yes" xml:space="preserve">
          <source>Devote yourself frequently to prayer.</source>
          <target state="translated">经常投入祷告。</target>
        </trans-unit>
        <trans-unit id="d2bfc098e435319899700359a7c7ade5b2cceea5" translate="yes" xml:space="preserve">
          <source>Direct writes to &lt;a href=&quot;../vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt;.</source>
          <target state="translated">直接写入&lt;a href=&quot;../vtab#xshadowname&quot;&gt;影子表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ea4196b155e79b0ed2d425b768b9f76a1de7e8d" translate="yes" xml:space="preserve">
          <source>Direct writes to &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt;.</source>
          <target state="translated">直接写入&lt;a href=&quot;vtab#xshadowname&quot;&gt;影子表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d9d75aac27ba7c6d07be6644243da8087e5f97b8" translate="yes" xml:space="preserve">
          <source>Disable schema editing using &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=OFF&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = OFF&lt;/a&gt;禁用模式编辑。</target>
        </trans-unit>
        <trans-unit id="d741b71f5f87bb5b09855b9b7b964ab4719c4656" translate="yes" xml:space="preserve">
          <source>Disable the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer callback&lt;/a&gt; while reparsing the schema.</source>
          <target state="translated">重新解析架构时禁用&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;授权者回调&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="48c40051997047e6342e6473938090c8ad6cd8b6" translate="yes" xml:space="preserve">
          <source>Disable the surreptitious use of custom SQL functions and virtual tables by setting the &lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag on all custom SQL functions and the &lt;a href=&quot;c3ref/c_vtab_constraint_support#sqlitevtabdirectonly&quot;&gt;SQLITE_VTAB_DIRECTONLY&lt;/a&gt; flag on all custom virtual tables.</source>
          <target state="translated">通过设置禁止暗中使用自定义的SQL函数和虚拟表&lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;标志上所有的自定义SQL函数和&lt;a href=&quot;c3ref/c_vtab_constraint_support#sqlitevtabdirectonly&quot;&gt;SQLITE_VTAB_DIRECTONLY&lt;/a&gt;所有自定义虚拟桌旗。</target>
        </trans-unit>
        <trans-unit id="2b94299f848122e7aa2027a43aba54a8bdf1eb66" translate="yes" xml:space="preserve">
          <source>Disable the use of posix_fallocate() on all (unix) systems unless the HAVE_POSIX_FALLOCATE compile-time option is used.</source>
          <target state="translated">在所有(unix)系统上禁用posix_fallocate(),除非使用HAVE_POSIX_FALLOCATE编译时选项。</target>
        </trans-unit>
        <trans-unit id="dc4409d907665c9eda9e8c714ab538568a93fe4c" translate="yes" xml:space="preserve">
          <source>Disable the use of the strchrnul() C-library routine unless it is specifically enabled using the -DHAVE_STRCHRNULL compile-time option.</source>
          <target state="translated">禁用 strchrnul()C-library 例程,除非使用 -DHAVE_STRCHRNULL 编译时选项特别启用。</target>
        </trans-unit>
        <trans-unit id="44313c14bb780bbf9fd9d83b8ed923886b89675b" translate="yes" xml:space="preserve">
          <source>Disabled optimization tests</source>
          <target state="translated">停用优化测试</target>
        </trans-unit>
        <trans-unit id="801e1c0ae6276f6c1470108fe61a442d30ca4372" translate="yes" xml:space="preserve">
          <source>Disabling mutexes at run-time is not as effective as disabling them at compile-time since SQLite still must do a test of a boolean variable to see if mutexes are enabled or disabled at each point where a mutex might be required. But there is still a performance advantage for disabling mutexes at run-time.</source>
          <target state="translated">在运行时禁用mutexes并不像在编译时禁用它们那样有效,因为SQLite仍然必须在每个可能需要mutex的地方对布尔变量进行测试,以确定是否启用或禁用mutexes。但在运行时禁用突变仍有性能优势。</target>
        </trans-unit>
        <trans-unit id="db38b8db0ff11ad2083b7f6905b27367bbd64018" translate="yes" xml:space="preserve">
          <source>Disallow &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; in the &lt;a href=&quot;lang_with&quot;&gt;WITH clause&lt;/a&gt; of triggers and views. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/b918d4b4e546d&quot;&gt;b918d4b4e546d&lt;/a&gt;</source>
          <target state="translated">禁止在触发器和视图的&lt;a href=&quot;lang_with&quot;&gt;WITH子句&lt;/a&gt;中使用&lt;a href=&quot;lang_expr#varparam&quot;&gt;参数&lt;/a&gt;。入住&lt;a href=&quot;https://www.sqlite.org/src/info/b918d4b4e546d&quot;&gt;B918D4B4E546D&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5a4f5b6881f751cbf37ca7be8a10d5fc1ce5e931" translate="yes" xml:space="preserve">
          <source>Disallow control characters inside of strings in JSON. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6c9b5514077fed34551&quot;&gt;6c9b5514077fed34551&lt;/a&gt;.</source>
          <target state="translated">禁止在JSON中的字符串内使用控制字符。修复票证&lt;a href=&quot;https://www.sqlite.org/src/info/6c9b5514077fed34551&quot;&gt;6c9b5514077fed34551&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4fbe5a75e7ecac67d383efc523453d8ca0e96ce9" translate="yes" xml:space="preserve">
          <source>Disallow leading zeros in numeric constants in JSON. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/b93be8729a895a528e2&quot;&gt;b93be8729a895a528e2&lt;/a&gt;.</source>
          <target state="translated">禁止在JSON中的数字常量中使用前导零。修复票务&lt;a href=&quot;https://www.sqlite.org/src/info/b93be8729a895a528e2&quot;&gt;b93be8729a895a528e2&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2630cbc2f1d0549bdb067048921921ca0d31c770" translate="yes" xml:space="preserve">
          <source>Disallow temporary indices on permanent tables.</source>
          <target state="translated">不允许在永久表上使用临时索引。</target>
        </trans-unit>
        <trans-unit id="5acb0a0adde49aba96e6fc288d48b3950eb87672" translate="yes" xml:space="preserve">
          <source>Disallow the use of &quot;rowid&quot; in &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt;.</source>
          <target state="translated">禁止在&lt;a href=&quot;lang_with&quot;&gt;公用表表达式中&lt;/a&gt;使用&amp;ldquo; rowid&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="664d42cee9dc2838800ae0429fea3975df123ee1" translate="yes" xml:space="preserve">
          <source>Disallow the use of &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt; in the recursive part of a CTE. Ticket &lt;a href=&quot;https://sqlite.org/src/info/e8275b415a2f03bee&quot;&gt;e8275b415a2f03bee&lt;/a&gt;</source>
          <target state="translated">禁止在CTE的递归部分中使用&lt;a href=&quot;windowfunctions&quot;&gt;窗口函数&lt;/a&gt;。门票&lt;a href=&quot;https://sqlite.org/src/info/e8275b415a2f03bee&quot;&gt;e8275b415a2f03bee&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="268c696f729a3bb7208ee6e45627908c164ce6fd" translate="yes" xml:space="preserve">
          <source>Disclose wrongful thoughts to your spiritual mentor.</source>
          <target state="translated">向你的心灵导师倾诉错误的想法。</target>
        </trans-unit>
        <trans-unit id="df353315b1ac203fbf0fbde5acfa1d6dd139f099" translate="yes" xml:space="preserve">
          <source>Discontinue the use of posix_fallocate() on unix, as it does not work on all filesystems.</source>
          <target state="translated">停止在unix上使用posix_fallocate(),因为它不能在所有文件系统上工作。</target>
        </trans-unit>
        <trans-unit id="630ed0127b8c49cb6701137391eeab0c764d29db" translate="yes" xml:space="preserve">
          <source>Discontinue the use of thread-specific data for out-of-memory exception handling</source>
          <target state="translated">停止使用特定线程数据来处理内存外的异常。</target>
        </trans-unit>
        <trans-unit id="dc4ca73be659333abaa3afecb8d712a96bb9f569" translate="yes" xml:space="preserve">
          <source>Disk I/O operations tends to be more sequential using WAL.</source>
          <target state="translated">使用WAL的磁盘I/O操作更趋向于顺序化。</target>
        </trans-unit>
        <trans-unit id="875cf7c3c58abcb6b2af3c59e6f41f8c4ce9ca26" translate="yes" xml:space="preserve">
          <source>Distinctive Features Of SQLite</source>
          <target state="translated">SQLite的独特功能</target>
        </trans-unit>
        <trans-unit id="f327b00a868bc2fc77c6168d0e2d509cf7d8a51a" translate="yes" xml:space="preserve">
          <source>Diverse content which might otherwise be stored as a &quot;pile-of-files&quot; is encapsulated into a single disk file for simpler transport via scp/ftp, USB stick, and/or email attachment.</source>
          <target state="translated">原本可能以 &quot;一堆文件 &quot;形式存储的各种内容被封装在一个单一的磁盘文件中,以便通过scp/ftp、U盘和/或电子邮件附件进行更简单的传输。</target>
        </trans-unit>
        <trans-unit id="104ed7c21cfc9b8ba11824e5729cef81f421e172" translate="yes" xml:space="preserve">
          <source>Divide</source>
          <target state="translated">Divide</target>
        </trans-unit>
        <trans-unit id="6a4bfffd32ff9d65b9739b01f6b92d5a2a406ec8" translate="yes" xml:space="preserve">
          <source>Divide the value in register P1 by the value in register P2 and store the result in register P3 (P3=P2/P1). If the value in register P1 is zero, then the result is NULL. If either input is NULL, the result is NULL.</source>
          <target state="translated">寄存器P1中的值除以寄存器P2中的值,并将结果存储在寄存器P3中(P3=P2/P1)。如果寄存器P1中的值为0,则结果为NULL。如果其中一个输入为NULL,则结果为NULL。</target>
        </trans-unit>
        <trans-unit id="45a5d54bca163767dafad34692c5f65f7f63e81e" translate="yes" xml:space="preserve">
          <source>Do a better job of detecting missing, incomplete, and/or dodgy &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt; data and generates good query plans in spite of the misinformation.</source>
          <target state="translated">尽管存在错误信息，但可以更好地检测丢失，不完整和/或不&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;可靠的sql​​ite_stat1&lt;/a&gt;数据，并生成良好的查询计划。</target>
        </trans-unit>
        <trans-unit id="4bd6c15a025907299e44072515501d69283cf065" translate="yes" xml:space="preserve">
          <source>Do an analysis of the currently open database. Store in register P1 the text of an error message describing any problems. If no problems are found, store a NULL in register P1.</source>
          <target state="translated">对当前打开的数据库进行分析。在寄存器P1中存储描述任何问题的错误信息的文本。如果没有发现问题,则在寄存器P1中存储一个NULL。</target>
        </trans-unit>
        <trans-unit id="b58dc41668bbf2d2a5ac0f7843e60d1fd0b29a30" translate="yes" xml:space="preserve">
          <source>Do full-table scans using covering indices when possible, under the theory that an index will be smaller and hence can be scanned with less I/O.</source>
          <target state="translated">尽可能使用覆盖索引进行全表扫描,理论上索引会更小,因此可以用更少的I/O进行扫描。</target>
        </trans-unit>
        <trans-unit id="d61e75c7c6aa57e44ccfb36bea2e0d2cd4826003" translate="yes" xml:space="preserve">
          <source>Do no wrong to anyone, and bear patiently wrongs done to yourself.</source>
          <target state="translated">对任何人都不能做错,对自己做错的事也要耐心承受。</target>
        </trans-unit>
        <trans-unit id="c7acd87886221e65424bf1acce3086f3655acf30" translate="yes" xml:space="preserve">
          <source>Do not allocate a new page. Return NULL.</source>
          <target state="translated">不要分配一个新的页面。返回NULL。</target>
        </trans-unit>
        <trans-unit id="d1baafbd29f15f73b5db2bd55006fe595ca88606" translate="yes" xml:space="preserve">
          <source>Do not allow dot-commands of the command-line shell to occur in the middle of a real SQL command.</source>
          <target state="translated">不允许命令行shell的点命令出现在真正的SQL命令中间。</target>
        </trans-unit>
        <trans-unit id="722464d20a4d3822872080ca5426f1791b661a71" translate="yes" xml:space="preserve">
          <source>Do not apply the WHERE-clause pushdown optimization on terms that originate in the ON or USING clause of a LEFT JOIN. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/c2a19d81652f40568c&quot;&gt;c2a19d81652f40568c&lt;/a&gt;.</source>
          <target state="translated">不要对源自LEFT JOIN的ON或USING子句的术语应用WHERE子句下推优化。修复票证&lt;a href=&quot;https://www.sqlite.org/src/info/c2a19d81652f40568c&quot;&gt;c2a19d81652f40568c&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9e626f7dec3803cf39b9ed3c8d4b8ddd26aa3a01" translate="yes" xml:space="preserve">
          <source>Do not apply the flattening optimization if the outer query is an aggregate and the inner query contains ORDER BY. (Ticket #2943)</source>
          <target state="translated">如果外部查询是一个集合,而内部查询包含ORDER BY,不要应用扁平化优化。(Ticket #2943)</target>
        </trans-unit>
        <trans-unit id="47f951dc04aa5e685ae032b56eb35642da21ee4e" translate="yes" xml:space="preserve">
          <source>Do not attempt to use terms from the WHERE clause to enable indexed lookup of the right-hand table of a LEFT JOIN. Ticket &lt;a href=&quot;https://sqlite.org/src/info/4ba5abf65c5b0f9a96a7a&quot;&gt;4ba5abf65c5b0f9a96a7a&lt;/a&gt;</source>
          <target state="translated">不要尝试使用WHERE子句中的术语来启用对LEFT JOIN右侧表的索引查找。门票&lt;a href=&quot;https://sqlite.org/src/info/4ba5abf65c5b0f9a96a7a&quot;&gt;4ba5abf65c5b0f9a96a7a&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb440372f32dec89b9398b09a9e6e2779b9db126" translate="yes" xml:space="preserve">
          <source>Do not attempt to use the strchrnul() function from the standard C library unless the HAVE_STRCHRNULL compile-time option is set.</source>
          <target state="translated">不要试图使用标准C库中的strchrnul()函数,除非设置了HAVE_STRCHRNULL编译时选项。</target>
        </trans-unit>
        <trans-unit id="b64adffd7b86aaa3092ff02c70021235bc894300" translate="yes" xml:space="preserve">
          <source>Do not be afraid to explore and experiment. Without a log-in you won't be able to push back any changes you make, so you cannot damage the project.</source>
          <target state="translated">不要害怕探索和实验。如果没有登录,你将无法推回你所做的任何更改,所以你不能破坏项目。</target>
        </trans-unit>
        <trans-unit id="d05159095924dcadc1e25110c5f5f929ebba2a2a" translate="yes" xml:space="preserve">
          <source>Do not be confused by the fact that a column might have a &quot;numeric&quot; datatype. This does not mean that the column can contain only numbers. It merely means that if the column does contain a number, that number will sort in numerical order.</source>
          <target state="translated">不要被某一列可能具有 &quot;数字 &quot;数据类型这一事实所迷惑。这并不意味着该列只能包含数字。这仅仅意味着,如果列中包含一个数字,该数字将按数字顺序排序。</target>
        </trans-unit>
        <trans-unit id="7b5c9cbefc6ca63f2b182857e9018d39b28c3534" translate="yes" xml:space="preserve">
          <source>Do not be misled by the &quot;Lite&quot; in the name. SQLite has a full-featured SQL implementation, including:</source>
          <target state="translated">不要被名字中的 &quot;精简版 &quot;所误导。SQLite有一个功能齐全的SQL实现,包括:。</target>
        </trans-unit>
        <trans-unit id="83ad576ed2750422c0fb9b979bec85d0e4fc99e1" translate="yes" xml:space="preserve">
          <source>Do not bear false witness.</source>
          <target state="translated">不要做假证。</target>
        </trans-unit>
        <trans-unit id="dc340a536129d864cf116ede217fe057492374c8" translate="yes" xml:space="preserve">
          <source>Do not become attached to pleasures.</source>
          <target state="translated">不要执着于快乐。</target>
        </trans-unit>
        <trans-unit id="47541d37d26b95f8c181a2dc345a039022162ef4" translate="yes" xml:space="preserve">
          <source>Do not commit adultery.</source>
          <target state="translated">不要通奸。</target>
        </trans-unit>
        <trans-unit id="0527e2ce52914545d104d45569846431699a53a2" translate="yes" xml:space="preserve">
          <source>Do not confuse automatic indexes with the &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; (having names like &quot;sqlite_autoindex_</source>
          <target state="translated">请勿将自动索引与&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部索引&lt;/a&gt;混淆（名称类似&amp;ldquo; sqlite_autoindex_</target>
        </trans-unit>
        <trans-unit id="5b87dbbc2f82f39fe5e094dea4061b8791b8238e" translate="yes" xml:space="preserve">
          <source>Do not confuse the SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags with the &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt;=NORMAL and &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt;=FULL settings. The &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;synchronous pragma&lt;/a&gt; determines when calls to the xSync VFS method occur and applies uniformly across all platforms. The SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags determine how energetic or rigorous or forceful the sync operations are and only make a difference on Mac OSX for the default SQLite code. (Third-party VFS implementations might also make the distinction between SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL, but among the operating systems natively supported by SQLite, only Mac OSX cares about the difference.)</source>
          <target state="translated">不要将SQLITE_SYNC_NORMAL和SQLITE_SYNC_FULL标志与&lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt; = NORMAL和&lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt; = FULL设置混淆。的&lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;同步编译指示&lt;/a&gt;确定何时所述XSYNC VFS方法调用发生和在所有平台上均匀地施加。SQLITE_SYNC_NORMAL和SQLITE_SYNC_FULL标志确定同步操作的能量，强度或强度，仅在Mac OSX上对默认SQLite代码有所不同。（第三方VFS实现也可能会在SQLITE_SYNC_NORMAL和SQLITE_SYNC_FULL之间进行区分，但在SQLite本身支持的操作系统中，只有Mac OSX会在意这一区别。）</target>
        </trans-unit>
        <trans-unit id="002e1751e184528adf8c6f1d702e80e85446806a" translate="yes" xml:space="preserve">
          <source>Do not confuse the SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags with the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt;=NORMAL and &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt;=FULL settings. The &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;synchronous pragma&lt;/a&gt; determines when calls to the xSync VFS method occur and applies uniformly across all platforms. The SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags determine how energetic or rigorous or forceful the sync operations are and only make a difference on Mac OSX for the default SQLite code. (Third-party VFS implementations might also make the distinction between SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL, but among the operating systems natively supported by SQLite, only Mac OSX cares about the difference.)</source>
          <target state="translated">不要将SQLITE_SYNC_NORMAL和SQLITE_SYNC_FULL标志与&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt; = NORMAL和&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同步&lt;/a&gt; = FULL设置混淆。的&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;同步编译指示&lt;/a&gt;确定何时所述XSYNC VFS方法调用发生和在所有平台上均匀地施加。SQLITE_SYNC_NORMAL和SQLITE_SYNC_FULL标志确定同步操作的能量，强度或强度，仅在Mac OSX上对默认SQLite代码有所不同。（第三方VFS实现也可能会在SQLITE_SYNC_NORMAL和SQLITE_SYNC_FULL之间进行区分，但在SQLite本身支持的操作系统中，只有Mac OSX会在意这一区别。）</target>
        </trans-unit>
        <trans-unit id="ad2017a368e4acba6381b0a256f7226272260dc0" translate="yes" xml:space="preserve">
          <source>Do not count rows where the IGNORE conflict resolution occurs in the row count.</source>
          <target state="translated">不要在行数中计算发生IGNORE冲突解决的行。</target>
        </trans-unit>
        <trans-unit id="b7c755ee6b849cdf60ae59e908ab1fc867a27494" translate="yes" xml:space="preserve">
          <source>Do not covet.</source>
          <target state="translated">不要贪恋。</target>
        </trans-unit>
        <trans-unit id="db62bb840a97eee5b8883ebcef3e582e3e673f43" translate="yes" xml:space="preserve">
          <source>Do not curse those who curse you, but rather bless them.</source>
          <target state="translated">不要诅咒那些诅咒你的人,而是要祝福他们。</target>
        </trans-unit>
        <trans-unit id="2d234151c3e9c3911335b0f3da32177b2942f1e3" translate="yes" xml:space="preserve">
          <source>Do not do to another what you would not have done to yourself.</source>
          <target state="translated">己所不欲,勿施于人。</target>
        </trans-unit>
        <trans-unit id="acd5314ee2a0e4064ce9351ca89b05b07641e78e" translate="yes" xml:space="preserve">
          <source>Do not enable memory-mapped I/O. In other words, make sure that &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size=0&lt;/a&gt;.</source>
          <target state="translated">不要启用内存映射的I / O。换句话说，请确保&lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size = 0&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="034edd930627c1bd6308a4139c12b6665fcb2787" translate="yes" xml:space="preserve">
          <source>Do not entertain deceit in your heart.</source>
          <target state="translated">不要在你的心底藏着欺骗。</target>
        </trans-unit>
        <trans-unit id="81fd74cab483c5a336f294ba599bad0042897a37" translate="yes" xml:space="preserve">
          <source>Do not escape the backslash '\' character in the output of the &lt;b&gt;sqlite&lt;/b&gt; command-line access program.</source>
          <target state="translated">不要在&lt;b&gt;sqlite&lt;/b&gt;命令行访问程序的输出中转义反斜杠&amp;ldquo; \&amp;rdquo;字符。</target>
        </trans-unit>
        <trans-unit id="c890cde5441c19e16767be21e8b596d667fd4a4d" translate="yes" xml:space="preserve">
          <source>Do not even call &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; on a database connection from a child process if the connection was opened in the parent. It is safe to close the underlying file descriptor, but the &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; interface might invoke cleanup activities that will delete content out from under the parent, leading to errors and perhaps even database corruption.</source>
          <target state="translated">如果在父进程中打开了数据库连接，则甚至不要从子进程调用数据库连接&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;。关闭基础文件描述符是安全的，但是&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;接口可能会调用清除活动，这些活动将从父目录下删除内容，从而导致错误甚至数据库损坏。</target>
        </trans-unit>
        <trans-unit id="9842d9ca1b62003346b1050ca3868a78c6e6df5b" translate="yes" xml:space="preserve">
          <source>Do not flush the page cache (and thus avoiding a cache refill) unless another process changes the underlying database file.</source>
          <target state="translated">除非另一个进程改变了底层数据库文件,否则不要刷新页面缓存(从而避免重新填充缓存)。</target>
        </trans-unit>
        <trans-unit id="2176e7264952425c2f250491ec533bbb7089a674" translate="yes" xml:space="preserve">
          <source>Do not forsake charity.</source>
          <target state="translated">不要放弃慈善。</target>
        </trans-unit>
        <trans-unit id="bca45f5adbe0136828b61d27215211c39ce6b83c" translate="yes" xml:space="preserve">
          <source>Do not give a false peace.</source>
          <target state="translated">不要给一个虚假的和平。</target>
        </trans-unit>
        <trans-unit id="0fe47eb7b363d5a152896bf66373bc2d500a51a8" translate="yes" xml:space="preserve">
          <source>Do not give way to anger.</source>
          <target state="translated">不要让步于愤怒。</target>
        </trans-unit>
        <trans-unit id="3d1cede4ac2a286b898864b92bb8c0cd08137e3b" translate="yes" xml:space="preserve">
          <source>Do not love much or boisterous laughter.</source>
          <target state="translated">不爱多,不爱轰轰烈烈的笑声。</target>
        </trans-unit>
        <trans-unit id="3c45d126a4940542085bf1e96a3ac522f5385ee4" translate="yes" xml:space="preserve">
          <source>Do not love much talking.</source>
          <target state="translated">不爱多说话。</target>
        </trans-unit>
        <trans-unit id="68cc3d30139a8559e135cd4c8f558235d11abccb" translate="yes" xml:space="preserve">
          <source>Do not love quarreling.</source>
          <target state="translated">不爱吵架。</target>
        </trans-unit>
        <trans-unit id="629a7228998a89704c92b419f13085418997b310" translate="yes" xml:space="preserve">
          <source>Do not misunderstand: There is nothing technically wrong with displaying the error logger messages to end users. The messages do not contain sensitive or private information that must be protected from unauthorized viewing. Rather the messages are technical in nature and are not useful or meaningful to the typical end user. The messages coming from the error logger are intended for database geeks. Display them accordingly.</source>
          <target state="translated">不要误解。向终端用户显示错误记录器信息在技术上没有任何问题。这些信息并不包含敏感或私人信息,必须加以保护,防止未经授权的人查看。相反,这些消息是技术性的,对典型的最终用户没有用处或意义。来自错误记录器的消息是为数据库极客准备的。请相应地显示它们。</target>
        </trans-unit>
        <trans-unit id="8f8ddbae63c42651d375c0bd04cebf3413348f90" translate="yes" xml:space="preserve">
          <source>Do not murder.</source>
          <target state="translated">不要谋杀。</target>
        </trans-unit>
        <trans-unit id="1f35225b21f15dae6087ed7eeacb7e2fc8285c86" translate="yes" xml:space="preserve">
          <source>Do not nurse a grudge.</source>
          <target state="translated">不要怀恨在心。</target>
        </trans-unit>
        <trans-unit id="0a1c640222a0771668990edc889cc0113169d8ac" translate="yes" xml:space="preserve">
          <source>Do not open an SQLite database connection, then fork(), then try to use that database connection in the child process. All kinds of locking problems will result and you can easily end up with a corrupt database. SQLite is not designed to support that kind of behavior. Any database connection that is used in a child process must be opened in the child process, not inherited from the parent.</source>
          <target state="translated">不要打开一个SQLite数据库连接,然后fork(),然后尝试在子进程中使用该数据库连接。会导致各种锁定问题,你很容易最终得到一个损坏的数据库。SQLite的设计并不支持这种行为。任何在子进程中使用的数据库连接必须在子进程中打开,而不是从父进程中继承。</target>
        </trans-unit>
        <trans-unit id="3df8aad94da73f8e621cafc5e1cbb5ccbe166028" translate="yes" xml:space="preserve">
          <source>Do not put write locks on the file used to hold TEMP tables.</source>
          <target state="translated">不要在用来存放TEMP表的文件上加写锁。</target>
        </trans-unit>
        <trans-unit id="167222828b6a7323e00470f04ccff91439f97f91" translate="yes" xml:space="preserve">
          <source>Do not read in the (meaningless) content of pages extracted from the freelist.</source>
          <target state="translated">不要阅读从自由列表中提取的页面(无意义)内容。</target>
        </trans-unit>
        <trans-unit id="88443743067599e18c7d1c7b495b0aed7fcc56ac" translate="yes" xml:space="preserve">
          <source>Do not read the last page of an overflow chain when deleting the row - just add that page to the freelist.</source>
          <target state="translated">删除行时不要读取溢出链的最后一页--只需将该页添加到自由列表中即可。</target>
        </trans-unit>
        <trans-unit id="a7d06580230b34d6f8a726d493bee6f3225055ed" translate="yes" xml:space="preserve">
          <source>Do not require commas between constraints in CREATE TABLE statements.</source>
          <target state="translated">在CREATE TABLE语句中,约束条件之间不需要逗号。</target>
        </trans-unit>
        <trans-unit id="7fc4941b3cd021627fe69bb109677c3c3d923f4e" translate="yes" xml:space="preserve">
          <source>Do not return evil for evil.</source>
          <target state="translated">勿以恶报恶。</target>
        </trans-unit>
        <trans-unit id="21dd78a660444cf8065985daa16f5a53b2b94b26" translate="yes" xml:space="preserve">
          <source>Do not steal.</source>
          <target state="translated">不要偷。</target>
        </trans-unit>
        <trans-unit id="ad5e34ebf9599545e50b3a0dc2ba3f44f88168b2" translate="yes" xml:space="preserve">
          <source>Do not store pages being deleted in the rollback journal.</source>
          <target state="translated">不要在回滚日志中存储被删除的页面。</target>
        </trans-unit>
        <trans-unit id="4db470ddd81b2b754811d69f10c92e79bba57171" translate="yes" xml:space="preserve">
          <source>Do not swear, for fear of perjuring yourself.</source>
          <target state="translated">不要发誓,怕作伪证。</target>
        </trans-unit>
        <trans-unit id="ec7cd9078e5c61634a562846d1cb709ab20d0358" translate="yes" xml:space="preserve">
          <source>Do not use a partial index to do a table scan on an IN operator. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/1d958d90596593a774&quot;&gt;1d958d90596593a774&lt;/a&gt;.</source>
          <target state="translated">不要使用局部索引对IN运算符进行表扫描。票证&lt;a href=&quot;https://www.sqlite.org/src/info/1d958d90596593a774&quot;&gt;1d958d90596593a774&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="20680b9a624f1f557a55b0811ddc984091848e37" translate="yes" xml:space="preserve">
          <source>Do not use the &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt; for a sub-query on the RHS of a LEFT JOIN if that subquery reads data from a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; as doing so prevents the query planner from creating &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexes&lt;/a&gt; on the results of the sub-query, which can slow down the query.</source>
          <target state="translated">如果子查询从&lt;a href=&quot;vtab&quot;&gt;虚拟表中&lt;/a&gt;读取数据，请不要在LEFT JOIN的RHS上对子查询使用&lt;a href=&quot;optoverview#flattening&quot;&gt;扁平化优化&lt;/a&gt;，因为这样做会阻止查询计划程序在子查询的结果上创建&lt;a href=&quot;optoverview#autoindex&quot;&gt;自动索引&lt;/a&gt;。查询。</target>
        </trans-unit>
        <trans-unit id="f5a36cf13f2d75f5b1d063cbaf3e6dabed9e5e96" translate="yes" xml:space="preserve">
          <source>Do not wish to be called holy before one is holy; but first to be holy, that you may be truly so called.</source>
          <target state="translated">不愿人未成圣,先成圣,才能真正成圣。</target>
        </trans-unit>
        <trans-unit id="5969cbceed42549abcad3776ee3d2a22161ed52f" translate="yes" xml:space="preserve">
          <source>Do not write changes to standard output. Instead, write a (binary) changeset file into FILE. The changeset can be interpreted using the sessions extension to SQLite.</source>
          <target state="translated">不要将更改写入标准输出。取而代之的是,将一个(二进制)变化集文件写入FILE。变更集可以使用session扩展来解释SQLite。</target>
        </trans-unit>
        <trans-unit id="9ab50d236c22af4547ec015790d6040a4642e45e" translate="yes" xml:space="preserve">
          <source>Do nothing. This instruction is often useful as a jump destination.</source>
          <target state="translated">什么也不做。这个指令通常作为跳转目标很有用。</target>
        </trans-unit>
        <trans-unit id="19eb9de9fe2776c399eac9b123129daec5f5dd94" translate="yes" xml:space="preserve">
          <source>Document Lists And Indexes</source>
          <target state="translated">文件清单和索引</target>
        </trans-unit>
        <trans-unit id="8c461e6b3d5184a9059cf94be86da7dbc747e4cf" translate="yes" xml:space="preserve">
          <source>Document Structure</source>
          <target state="translated">文件结构</target>
        </trans-unit>
        <trans-unit id="3a469072b5974a6ac1b0b86818461b57cc048dea" translate="yes" xml:space="preserve">
          <source>Document the hazards of type conversions in &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_blob()&lt;/a&gt; and related APIs. Fix unnecessary type conversions. Ticket #2321.</source>
          <target state="translated">在&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_blob（）&lt;/a&gt;和相关API 中记录类型转换的危害。修复不必要的类型转换。机票＃2321。</target>
        </trans-unit>
        <trans-unit id="28ddcac222be4dd54f888cc20f015c092a5e040c" translate="yes" xml:space="preserve">
          <source>Document versioning</source>
          <target state="translated">文件版本管理</target>
        </trans-unit>
        <trans-unit id="fe7304ab51248437db8b4b66ad9ad43f8b781a02" translate="yes" xml:space="preserve">
          <source>Documentation updates</source>
          <target state="translated">文件更新</target>
        </trans-unit>
        <trans-unit id="e7eabf63bf0b622355ee7928fc5a397625e241a7" translate="yes" xml:space="preserve">
          <source>Documentation updates and typo fixes</source>
          <target state="translated">文件更新和排版修复</target>
        </trans-unit>
        <trans-unit id="b3606774842986999d74ead8587f30081f764162" translate="yes" xml:space="preserve">
          <source>Documentation updates.</source>
          <target state="translated">文件更新。</target>
        </trans-unit>
        <trans-unit id="b4f8a8a7e46cd0f4bef297d6b523710d4bbf11e1" translate="yes" xml:space="preserve">
          <source>Documentation updates. Mostly fixing of typos and spelling errors.</source>
          <target state="translated">文件更新。主要是修复打字和拼写错误。</target>
        </trans-unit>
        <trans-unit id="2014de1c64e4558d3e684536a5eead31d8646480" translate="yes" xml:space="preserve">
          <source>Documented support for the &lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4 content option&lt;/a&gt;. This feature has actually been in the code since &lt;a href=&quot;#version_3_7_9&quot;&gt;version 3.7.9&lt;/a&gt; but is only now considered to be officially supported.</source>
          <target state="translated">记录支持&lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4内容选项&lt;/a&gt;。此功能实际上是自&lt;a href=&quot;#version_3_7_9&quot;&gt;3.7.9版&lt;/a&gt;以来的代码中，但是现在才被认为是正式支持的功能。</target>
        </trans-unit>
        <trans-unit id="1141953a3cac893e565c0cb7afc09130be28d815" translate="yes" xml:space="preserve">
          <source>Does SQLite support a BLOB type?</source>
          <target state="translated">SQLite是否支持BLOB类型?</target>
        </trans-unit>
        <trans-unit id="d7ac8ab68849b9ef0f13b08bdcc3c9b49215d5ba" translate="yes" xml:space="preserve">
          <source>Does SQLite support foreign keys?</source>
          <target state="translated">SQLite支持外键吗?</target>
        </trans-unit>
        <trans-unit id="e2a8b45f99cb6f35744147d23ba67820b9196a7e" translate="yes" xml:space="preserve">
          <source>Does not support ZIP archives that span multiple files.</source>
          <target state="translated">不支持跨越多个文件的ZIP存档。</target>
        </trans-unit>
        <trans-unit id="f67d427a021b49d829af064322fcd164d0d520fe" translate="yes" xml:space="preserve">
          <source>Does not support encryption.</source>
          <target state="translated">不支持加密。</target>
        </trans-unit>
        <trans-unit id="a182c94fa152e112192c0491165a8fdd3fd894bc" translate="yes" xml:space="preserve">
          <source>Does not support zip64 extensions.</source>
          <target state="translated">不支持zip64扩展。</target>
        </trans-unit>
        <trans-unit id="266906722673b9d89a70b9366dca968b0e3c9bf4" translate="yes" xml:space="preserve">
          <source>Dot-commands do not recognize comments.</source>
          <target state="translated">Dot-commands不识别注释。</target>
        </trans-unit>
        <trans-unit id="8a31aee94d3aa206ec99f016bf029e559e48bfac" translate="yes" xml:space="preserve">
          <source>Dot-file locking style. This locking style is used when neither flock nor POSIX locking styles are supported by the file system. Database locks are obtained by creating and entry in the file-system at a well-known location relative to the database file (a &quot;dot-file&quot;) and relinquished by deleting the same file.</source>
          <target state="translated">点文件锁定样式。当文件系统既不支持flock也不支持POSIX锁定方式时,就会使用这种锁定方式。数据库锁是通过在文件系统中相对于数据库文件(&quot;点文件&quot;)的一个众所周知的位置上创建和输入来获得的,并通过删除同一文件来放弃。</target>
        </trans-unit>
        <trans-unit id="5886a74b53398ec47ad06e2d60de33d78d94131a" translate="yes" xml:space="preserve">
          <source>Double-Quoted Strings Allowed</source>
          <target state="translated">允许使用双引号字符串</target>
        </trans-unit>
        <trans-unit id="9527eaee4dc6adf69520b29f63dfd254ba6893eb" translate="yes" xml:space="preserve">
          <source>Double-quoted strings interpreted as column names not text literals.</source>
          <target state="translated">双引号字符串被解释为列名而非文本字面。</target>
        </trans-unit>
        <trans-unit id="ffe7363e8f5e47f6d5cff2a021a49b0ba15973c3" translate="yes" xml:space="preserve">
          <source>Download The Code</source>
          <target state="translated">下载代码</target>
        </trans-unit>
        <trans-unit id="2bf81ffb06a97ae87b64f9122c76cd7ce2c19062" translate="yes" xml:space="preserve">
          <source>Download the self-contained Fossil executable from &lt;a href=&quot;https://fossil-scm.org/fossil/uv/download.html&quot;&gt;https://fossil-scm.org/fossil/uv/download.html&lt;/a&gt; and put the executable somewhere on your $PATH.</source>
          <target state="translated">从&lt;a href=&quot;https://fossil-scm.org/fossil/uv/download.html&quot;&gt;https://fossil-scm.org/fossil/uv/download.html&lt;/a&gt;下载自包含的Fossil可执行文件，并将该可执行文件放在$ PATH上的某个位置。</target>
        </trans-unit>
        <trans-unit id="bf164a21eb062e18af9a991c052f3c70484a26df" translate="yes" xml:space="preserve">
          <source>Dozens of minor bug fixes</source>
          <target state="translated">数十项小错误修复</target>
        </trans-unit>
        <trans-unit id="a929098ee87888960431567bedaf2f19daf292b0" translate="yes" xml:space="preserve">
          <source>Drop all support for the &lt;a href=&quot;malloc#memsysx&quot;&gt;experimental memory allocators&lt;/a&gt; memsys4 and memsys6.</source>
          <target state="translated">删除对&lt;a href=&quot;malloc#memsysx&quot;&gt;实验内存分配器&lt;/a&gt; memsys4和memsys6的所有支持。</target>
        </trans-unit>
        <trans-unit id="1f3f7deb8c2edee3371b95381860beff36c9b366" translate="yes" xml:space="preserve">
          <source>Drop built-in support for OS/2. If you need to upgrade an OS/2 application to use this or a later version of SQLite, then add an application-defined &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface. The code removed in this release can serve as a baseline for the application-defined VFS.</source>
          <target state="translated">删除对OS / 2的内置支持。如果需要升级OS / 2应用程序以使用此版本或更高版本的SQLite，请使用&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;接口添加应用程序定义的&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;。在此版本中删除的代码可以用作应用程序定义的VFS的基准。</target>
        </trans-unit>
        <trans-unit id="c3e9878b7430ec40bb0aac87c5455cd33a663347" translate="yes" xml:space="preserve">
          <source>Drop old table</source>
          <target state="translated">丢掉旧桌子</target>
        </trans-unit>
        <trans-unit id="831cee7fe7313360794c461d24e27019d0aa0fa8" translate="yes" xml:space="preserve">
          <source>Drop support for SQLITE_ENABLE_TREE_EXPLAIN. The SELECTTRACE mechanism provides more useful diagnostics information.</source>
          <target state="translated">放弃对SQLITE_ENABLE_TREE_EXPLAIN的支持。SELECTTRACE机制提供了更有用的诊断信息。</target>
        </trans-unit>
        <trans-unit id="0bd2f0f029e99d0a73743bc173e5b08aa4ae2984" translate="yes" xml:space="preserve">
          <source>Drop the EXCLUSIVE and PENDING locks but retain the SHARED lock.</source>
          <target state="translated">丢掉 &quot;专属 &quot;和 &quot;待定 &quot;锁,但保留 &quot;共享 &quot;锁。</target>
        </trans-unit>
        <trans-unit id="cece823a856676f78f4a41646b3bcd314a06e9ba" translate="yes" xml:space="preserve">
          <source>Drop the EXCLUSIVE and PENDING locks from all database files.</source>
          <target state="translated">删除所有数据库文件中的EXCLUSIVE和PENDING锁。</target>
        </trans-unit>
        <trans-unit id="41ede7277f5fa3c98b30f351e4b2a0728bbb7eac" translate="yes" xml:space="preserve">
          <source>Drop the EXCLUSIVE and PENDING locks from the database file.</source>
          <target state="translated">删除数据库文件中的EXCLUSIVE和PENDING锁。</target>
        </trans-unit>
        <trans-unit id="daced6c943d50569fdbed0b8c852df4819f96d8b" translate="yes" xml:space="preserve">
          <source>Drop the old table X: &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE X&lt;/a&gt;.</source>
          <target state="translated">删除旧表X：&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE X&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e57de85bbf5c15a59892ff50c8f7c01032ec317" translate="yes" xml:space="preserve">
          <source>DropIndex</source>
          <target state="translated">DropIndex</target>
        </trans-unit>
        <trans-unit id="4a8749bce90b847b8afa8914da8c1204a28e572c" translate="yes" xml:space="preserve">
          <source>DropTable</source>
          <target state="translated">DropTable</target>
        </trans-unit>
        <trans-unit id="5194da2ad6f6b74ff6082f247ce4ac8437a9ce02" translate="yes" xml:space="preserve">
          <source>DropTrigger</source>
          <target state="translated">DropTrigger</target>
        </trans-unit>
        <trans-unit id="e5c413032a9c5e630e19fe262e62d7fb21ec3a73" translate="yes" xml:space="preserve">
          <source>Dropped support for the &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#omitfeatures&quot;&gt;不再&lt;/a&gt;支持SQLITE_OMIT_MEMORY_ALLOCATION编译时选项。</target>
        </trans-unit>
        <trans-unit id="3d8ac8b86a476ff206c2f789a4c49e5873137fba" translate="yes" xml:space="preserve">
          <source>Due to an historical oversight, columns named in the &quot;UPDATE OF&quot; clause do not actually have to exist in the table being updated. Unrecognized column names are silently ignored. It would be more helpful if SQLite would fail the CREATE TRIGGER statement if any of the names in the &quot;UPDATE OF&quot; clause are not columns in the table. However, as this problem was discovered many years after SQLite was widely deployed, we have resisted fixing the problem for fear of breaking legacy applications.</source>
          <target state="translated">由于历史上的疏忽,在 &quot;UPDATE OF &quot;子句中命名的列实际上不必存在于被更新的表中。未识别的列名会被默默忽略。如果在 &quot;UPDATE OF &quot;子句中的任何名称不是表中的列,SQLite会使CREATE TRIGGER语句失败,这将更有帮助。然而,由于这个问题是在SQLite广泛部署多年后才被发现的,我们一直抵制修复这个问题,因为害怕破坏传统的应用程序。</target>
        </trans-unit>
        <trans-unit id="4b6731ebd9d31b14578dc5f16096a35b64787c3e" translate="yes" xml:space="preserve">
          <source>Due to concerns raised by readers, this document has been removed. The separate &lt;a href=&quot;codeofethics&quot;&gt;Code of Ethics&lt;/a&gt; document is similar to what this document used to be, but with a different name. The new name is an effort to more clearly communicate the purpose and scope of the document.</source>
          <target state="translated">由于读者的担忧，本文档已被删除。单独的&lt;a href=&quot;codeofethics&quot;&gt;《道德守则》&lt;/a&gt;文档与本文档以前的文档相似，但名称不同。新名称是为了更清楚地传达文档的目的和范围而做出的努力。</target>
        </trans-unit>
        <trans-unit id="13fc6ee3a5aa40fdb0e1d5ecf732cd2ab210b40a" translate="yes" xml:space="preserve">
          <source>Duplicate ephemeral cursors are used for self-joins of materialized views.</source>
          <target state="translated">复制的外延光标用于物化视图的自连接。</target>
        </trans-unit>
        <trans-unit id="22bb6bc640d9e76642a03f301228df50bc0c544a" translate="yes" xml:space="preserve">
          <source>Duplicate row returned on a query against a table with more than 16 indices, each on a separate column, and all used via OR-connected constraints. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/10fb063b11&quot;&gt;10fb063b11&lt;/a&gt;</source>
          <target state="translated">针对具有16个以上索引的表的查询中返回的重复行，每个索引在单独的列上，并且全部通过&amp;ldquo;或&amp;rdquo;连接的约束使用。机票&lt;a href=&quot;http://www.sqlite.org/src/info/10fb063b11&quot;&gt;10fb063b11&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="682723332ab997d0429b9afe0e471e4ac0019270" translate="yes" xml:space="preserve">
          <source>Duplicate row returned on a query against a table with more than 16 indices, each on a separate column, and all used via OR-connected constraints. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/10fb063b11&quot;&gt;10fb063b11&lt;/a&gt;</source>
          <target state="translated">针对包含16个以上索引的表的查询中返回的重复行，每个索引在单独的列上，并且所有索引都通过OR连接的约束使用。门票&lt;a href=&quot;https://www.sqlite.org/src/info/10fb063b11&quot;&gt;10fb063b11&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="93d7730f8826a2d54d04e212d85d32152f0ff3ce" translate="yes" xml:space="preserve">
          <source>During a transaction, SQLite stores additional information in a second file called the &quot;rollback journal&quot;, or if SQLite is in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, a write-ahead log file.</source>
          <target state="translated">在事务期间，SQLite将其他信息存储在称为&amp;ldquo;回滚日志&amp;rdquo;的第二个文件中；如果SQLite处于&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;，则该文件为预写日志文件。</target>
        </trans-unit>
        <trans-unit id="d30f21585fed5c23f99fb922e9805bc00a1eabdf" translate="yes" xml:space="preserve">
          <source>During a transaction, some of the data written to an FTS table may be cached in memory and written to the database only when the transaction is committed. However the implementation of the fts4aux module is only able to read data from the database. In practice this means that if an fts4aux table is queried from within a transaction in which the associated FTS table has been modified, the results of the query are likely to reflect only a (possibly empty) subset of the changes made.</source>
          <target state="translated">在事务过程中,写入FTS表的部分数据可能会缓存在内存中,只有在事务提交时才会写入数据库。然而fts4aux模块的实现只能从数据库中读取数据。在实践中,这意味着,如果在一个事务中对fts4aux表进行查询,而在这个事务中,相关的FTS表已经被修改,那么查询的结果很可能只反映出所做的修改的一个子集(可能是空的)。</target>
        </trans-unit>
        <trans-unit id="ad42e3b2740327c2dba977f94946673b656caef3" translate="yes" xml:space="preserve">
          <source>During most testing, however, these macros will throw an assertion fault if their argument does not have the expected truth value. This alerts the developers quickly to incorrect design assumptions.</source>
          <target state="translated">然而,在大多数测试过程中,如果这些宏的参数不具有预期的真值,就会抛出一个断言故障。这就会让开发人员迅速注意到不正确的设计假设。</target>
        </trans-unit>
        <trans-unit id="12f7d01f7aef91494af4f6f7a834f78084a02691" translate="yes" xml:space="preserve">
          <source>During part of SQLite's INSERT and SELECT processing, the complete content of each row in the database is encoded as a single BLOB. So the SQLITE_MAX_LENGTH parameter also determines the maximum number of bytes in a row.</source>
          <target state="translated">在SQLite的部分INSERT和SELECT处理过程中,数据库中每条记录的完整内容都被编码为一个BLOB。所以SQLITE_MAX_LENGTH参数也决定了一行的最大字节数。</target>
        </trans-unit>
        <trans-unit id="11df476623628b473251d2d86924a52d99a7ec80" translate="yes" xml:space="preserve">
          <source>During recovery of the global shared-memory WAL-index, exclusive locks are held on WAL_WRITE_LOCK, WAL_CKPT_LOCK, WAL_RECOVER_LOCK, and WAL_READ_LOCK(1) through WAL_READ_LOCK(4). In other words, all locks associated with the WAL-index except for WAL_READ_LOCK(0) are held exclusively. This prevents any other thread from writing the database and from reading any transactions that are held in the WAL, until the recovery is complete.</source>
          <target state="translated">在恢复全局共享内存WAL-索引的过程中,独占锁被持有在WAL_WRITE_LOCK、WAL_CKPT_LOCK、WAL_RECOVER_LOCK和WAL_READ_LOCK(1)到WAL_READ_LOCK(4)上。换句话说,除了WAL_READ_LOCK(0)之外,所有与WAL-index相关的锁都是独家持有的。这可以防止任何其他线程写入数据库和读取WAL中持有的任何事务,直到恢复完成。</target>
        </trans-unit>
        <trans-unit id="1358f8df690459d3328e508cecf523a429f80164" translate="yes" xml:space="preserve">
          <source>During testing, the SQLite library is compiled with special instrumentation that allows the test scripts to simulate a wide variety of failures in order to verify that SQLite recovers correctly. Memory allocation is carefully tracked and no memory leaks occur, even following memory allocation failures. A custom VFS layer is used to simulate operating system crashes and power failures in order to ensure that transactions are atomic across these events. A mechanism for deliberately injecting I/O errors shows that SQLite is resilient to such malfunctions. (As an experiment, try inducing these kinds of errors on other SQL database engines and see what happens!)</source>
          <target state="translated">在测试过程中,SQLite库是用特殊的仪器编译的,测试脚本可以模拟各种各样的故障,以验证SQLite是否正确恢复。内存分配被仔细跟踪,即使在内存分配失败后,也不会发生内存泄漏。自定义的VFS层用于模拟操作系统崩溃和电源故障,以确保事务在这些事件中是原子的。故意注入I/O错误的机制表明,SQLite对这种故障是有弹性的。(作为一个实验,尝试在其他SQL数据库引擎上诱导这些类型的错误,看看会发生什么!)</target>
        </trans-unit>
        <trans-unit id="083eeb3cf3761acd0b9b1944cd026822ab96a1ec" translate="yes" xml:space="preserve">
          <source>During the 250 ms sleep in step 3 above, no read-lock is held on the database file and the mutex associated with pDb is not held. This allows other threads to use &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; pDb and other connections to write to the underlying database file.</source>
          <target state="translated">在上述步骤3的250 ms睡眠期间，数据库文件未保留任何读锁定，并且未保留与pDb相关联的互斥锁。这允许其他线程使用&lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接&lt;/a&gt; pDb和其他连接来写入基础数据库文件。</target>
        </trans-unit>
        <trans-unit id="5bc5d8e5dea4ffc98e00ec0c1ec074dd1e7d3ff2" translate="yes" xml:space="preserve">
          <source>During the conclusion of a</source>
          <target state="translated">在结束时</target>
        </trans-unit>
        <trans-unit id="fe8ce31db6eecdb3f85f2298aa1ab49d66128d02" translate="yes" xml:space="preserve">
          <source>Dynamic Memory Allocation</source>
          <target state="translated">动态内存分配</target>
        </trans-unit>
        <trans-unit id="720d5bb7b021bd57042c2b5aa6c65c1226f1ffcd" translate="yes" xml:space="preserve">
          <source>Dynamic Memory Allocation In SQLite</source>
          <target state="translated">SQLite中的动态内存分配</target>
        </trans-unit>
        <trans-unit id="6a1ec417f9656bfa58ac913f9a623361c31817a1" translate="yes" xml:space="preserve">
          <source>Dynamic String Object</source>
          <target state="translated">动态字符串对象</target>
        </trans-unit>
        <trans-unit id="75da5571b32189815fa4662789976e48c0ca6b04" translate="yes" xml:space="preserve">
          <source>Dynamic analysis refers to internal and external checks on the SQLite code which are performed while the code is live and running. Dynamic analysis has proven to be a great help in maintaining the quality of SQLite.</source>
          <target state="translated">动态分析指的是对SQLite代码的内部和外部检查,这些检查是在代码上线运行时进行的。事实证明,动态分析对保持SQLite的质量有很大帮助。</target>
        </trans-unit>
        <trans-unit id="a5cb0906656acf2bda3bc32fbfc18bd37f772de3" translate="yes" xml:space="preserve">
          <source>Dynamic and static analysis of the code</source>
          <target state="translated">代码的动态和静态分析</target>
        </trans-unit>
        <trans-unit id="758e372147a13eab85e0e2348816aeca5a5cf87b" translate="yes" xml:space="preserve">
          <source>Dynamically Typed Value Object</source>
          <target state="translated">动态类型值对象</target>
        </trans-unit>
        <trans-unit id="dd5afbce0893bc1f40078bd68b471379645389da" translate="yes" xml:space="preserve">
          <source>EACH</source>
          <target state="translated">EACH</target>
        </trans-unit>
        <trans-unit id="bf4cc46f7f1441b1500c1ac4cef239d17020ff30" translate="yes" xml:space="preserve">
          <source>ELSE</source>
          <target state="translated">ELSE</target>
        </trans-unit>
        <trans-unit id="d205abee3d2a71688a6b66568be289a94050031c" translate="yes" xml:space="preserve">
          <source>END</source>
          <target state="translated">END</target>
        </trans-unit>
        <trans-unit id="79e27d141723fbb1d4275c9dc81bef88d08e1858" translate="yes" xml:space="preserve">
          <source>END TRANSACTION</source>
          <target state="translated">结束交易</target>
        </trans-unit>
        <trans-unit id="4351e320e43aa32eebed42b35b21b2097a23c049" translate="yes" xml:space="preserve">
          <source>END TRANSACTION is an alias for COMMIT.</source>
          <target state="translated">END TRANSACTION是COMMIT的别称。</target>
        </trans-unit>
        <trans-unit id="01dce0e5ecf8d5b17ab6b7c1ca9a8662e220cefd" translate="yes" xml:space="preserve">
          <source>EPUB - The Electronic Publication format used by non-Kindle eBooks</source>
          <target state="translated">EPUB--非Kindle电子书使用的电子出版格式。</target>
        </trans-unit>
        <trans-unit id="ac47189c9768197d8574c8f14988b8ef7e5d8f6d" translate="yes" xml:space="preserve">
          <source>ESCAPE</source>
          <target state="translated">ESCAPE</target>
        </trans-unit>
        <trans-unit id="c23142c6f147963dd2685f230238ef6772802e99" translate="yes" xml:space="preserve">
          <source>EXCEPT</source>
          <target state="translated">EXCEPT</target>
        </trans-unit>
        <trans-unit id="9cb33cc90a8a55873e7bc639c8e97e85186cc428" translate="yes" xml:space="preserve">
          <source>EXCLUDE</source>
          <target state="translated">EXCLUDE</target>
        </trans-unit>
        <trans-unit id="6a142f6999680571fa05b1a87552e101c1e3b874" translate="yes" xml:space="preserve">
          <source>EXCLUSIVE</source>
          <target state="translated">EXCLUSIVE</target>
        </trans-unit>
        <trans-unit id="e374cc411cf56ba9d22e8a8dfb723b4ab3e4424c" translate="yes" xml:space="preserve">
          <source>EXCLUSIVE is similar to IMMEDIATE in that a write transaction is started immediately. EXCLUSIVE and IMMEDIATE are the same in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, but in other journaling modes, EXCLUSIVE prevents other database connections from reading the database while the transaction is underway.</source>
          <target state="translated">EXCLUSIVE与IMMEDIATE相似，因为立即开始写事务。EXCLUSIVE和IMMEDIATE在&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;是相同的，但是在其他日记记录模式下，EXCLUSIVE阻止其他数据库连接在事务进行过程中读取数据库。</target>
        </trans-unit>
        <trans-unit id="644b5806e118fe0af3936c64572a1496ddda7507" translate="yes" xml:space="preserve">
          <source>EXISTS</source>
          <target state="translated">EXISTS</target>
        </trans-unit>
        <trans-unit id="4f7eee905948e6076168f8edbc3bf97ae8823930" translate="yes" xml:space="preserve">
          <source>EXPLAIN</source>
          <target state="translated">EXPLAIN</target>
        </trans-unit>
        <trans-unit id="2fbf78b206db15c2139a66a9634e3bf1d2176ccc" translate="yes" xml:space="preserve">
          <source>EXPLAIN QUERY PLAN</source>
          <target state="translated">解释查询计划</target>
        </trans-unit>
        <trans-unit id="38addf8721d2c74e08b308b7b8b2dd7a72f15eb2" translate="yes" xml:space="preserve">
          <source>EXPLAIN QUERY PLAN is most useful on a SELECT statement, but may also appear with other statements that read data from database tables (e.g. UPDATE, DELETE, INSERT INTO ... SELECT).</source>
          <target state="translated">EXPLAIN QUERY PLAN在SELECT语句中最有用,但也可能出现在其他从数据库表中读取数据的语句中(如UPDATE、DELETE、INSERT INTO ...SELECT)。</target>
        </trans-unit>
        <trans-unit id="8e9da9a85266351f71e77f3e9609cc22715ef94e" translate="yes" xml:space="preserve">
          <source>EXPLAIN operates at run-time, not at prepare-time</source>
          <target state="translated">EXPLAIN在运行时操作,而不是在准备时操作。</target>
        </trans-unit>
        <trans-unit id="f817892a6b7b040f6bf499b1ab6645711184a4f1" translate="yes" xml:space="preserve">
          <source>EXPR</source>
          <target state="translated">EXPR</target>
        </trans-unit>
        <trans-unit id="18fd69d15aa01be81ef0e1d97815be761eb30270" translate="yes" xml:space="preserve">
          <source>EXTRA synchronous is like FULL with the addition that the directory containing a &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; is synced after that journal is unlinked to commit a transaction in DELETE mode. EXTRA provides additional durability if the commit is followed closely by a power loss.</source>
          <target state="translated">EXTRA sync类似于FULL，另外，在取消链接包含&lt;a href=&quot;lockingv3#rollback&quot;&gt;回滚日志&lt;/a&gt;的目录以在DELETE模式下提交事务之后，将同步该目录。如果提交紧随功率损耗，则EXTRA可提供额外的耐用性。</target>
        </trans-unit>
        <trans-unit id="3633746b067241666bc462dcfe7a24ff23a8db68" translate="yes" xml:space="preserve">
          <source>Each</source>
          <target state="translated">Each</target>
        </trans-unit>
        <trans-unit id="483d2106efe09daa894eea6a0c9033d9a67cc38c" translate="yes" xml:space="preserve">
          <source>Each 5-byte entry on a ptrmap page provides back-link information about one of the pages that immediately follow the pointer map. If page B is a ptrmap page then back-link information about page B+1 is provided by the first entry on the pointer map. Information about page B+2 is provided by the second entry. And so forth.</source>
          <target state="translated">ptrmap页面上的每一个5字节的条目都提供了紧跟在指针图之后的一个页面的反向链接信息,如果页面B是一个ptrmap页面,那么B+1页面的反向链接信息由指针图上的第一个条目提供。如果B页是一个ptrmap页,那么关于B+1页的反向链接信息由指针图上的第一个条目提供。B+2页的信息由第二个条目提供。以此类推。</target>
        </trans-unit>
        <trans-unit id="1aabd87ca95da90a5c129eaf9247506c8bd66646" translate="yes" xml:space="preserve">
          <source>Each 5-byte ptrmap entry consists of one byte of &quot;page type&quot; information followed by a 4-byte big-endian page number. Five page types are recognized:</source>
          <target state="translated">每个5字节的ptrmap条目由一个字节的 &quot;页面类型 &quot;信息和一个4字节的big-endian页号组成。有五种页面类型可供选择。</target>
        </trans-unit>
        <trans-unit id="9a01146dc5470d97274ce8927b43f8fec82d7371" translate="yes" xml:space="preserve">
          <source>Each DELETE change is changed to an INSERT, and</source>
          <target state="translated">每一个DELETE的改变都会被改为INSERT,并且</target>
        </trans-unit>
        <trans-unit id="eeb9033e1e45a2bbbcad76e978600d892c37b372" translate="yes" xml:space="preserve">
          <source>Each INSERT change is changed to a DELETE, and</source>
          <target state="translated">每次INSERT更改都会被改为DELETE,并且</target>
        </trans-unit>
        <trans-unit id="7b99091b54756df2ed9f1a0564ab23ebb66063ec" translate="yes" xml:space="preserve">
          <source>Each ORDER BY expression is processed as follows:</source>
          <target state="translated">每个ORDER BY表达式的处理方法如下。</target>
        </trans-unit>
        <trans-unit id="90ec8a858058608d92c79ea2b4e9e7b9bbccd9eb" translate="yes" xml:space="preserve">
          <source>Each SQL index, whether explicitly declared via a &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement or implied by a UNIQUE or PRIMARY KEY constraint, corresponds to an index b-tree in the database file. Each entry in the index b-tree corresponds to a single row in the associated SQL table. The key to an index b-tree is a record composed of the columns that are being indexed followed by the key of the corresponding table row. For ordinary tables, the row key is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, and for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables the row key is the PRIMARY KEY. Because every row in the table has a unique row key, all keys in an index are unique.</source>
          <target state="translated">每个SQL索引，无论是通过&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;语句显式声明的，还是由UNIQUE或PRIMARY KEY约束隐含的，都对应于数据库文件中的索引b树。索引b树中的每个条目对应于关联的SQL表中的一行。索引b树的键是一条记录，该记录由要索引的列组成，后跟相应表行的键。对于普通表，行键是&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;，对于&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表，行键是PRIMARY KEY。由于表中的每一行都有唯一的行键，因此索引中的所有键都是唯一的。</target>
        </trans-unit>
        <trans-unit id="972d3bbdff7b7be08051158b4855057f49ea49cd" translate="yes" xml:space="preserve">
          <source>Each SQL statement in the statement list is an instance of the following:</source>
          <target state="translated">语句列表中的每一条SQL语句都是下面的一个实例。</target>
        </trans-unit>
        <trans-unit id="8780624428063f8d9d37cbf9ecae097671b04573" translate="yes" xml:space="preserve">
          <source>Each SQLite &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; records cases when the query planner would benefit from having accurate results of ANALYZE at hand. These records are held in memory and accumulate over the life of a database connection. The &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; command looks at those records and runs ANALYZE on only those tables for which new or updated ANALYZE data seems likely to be useful. In most cases &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; will not run ANALYZE, but it will occasionally do so either for tables that have never before been analyzed, or for tables that have grown significantly since they were last analyzed.</source>
          <target state="translated">每个SQLite &lt;a href=&quot;c3ref/sqlite3&quot;&gt;数据库连接都会&lt;/a&gt;记录查询计划者从准确的ANALYZE结果中受益时的情况。这些记录保存在内存中，并在数据库连接的整个生命周期内累积。该&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA优化&lt;/a&gt;命令会查看这些记录，并运行分析关于只有那些能够获得新的或更新的分析数据，很可能是有用的表格。在大多数情况下，&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA优化&lt;/a&gt;将不会运行ANALYZE，但偶尔会对从未进行过分析的表或自上次分析以来已显着增长的表进行分析。</target>
        </trans-unit>
        <trans-unit id="830748b5154094e00d6f1556c43a3fc63fc4833c" translate="yes" xml:space="preserve">
          <source>Each VFS implementation will subclass the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; by adding additional fields at the end to hold whatever information the VFS needs to know about an open file. It does not matter what information is stored as long as the total size of the structure does not exceed the szOsFile value recorded in the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object.</source>
          <target state="translated">每个VFS实现都会通过在末尾添加其他字段来保存&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;的子类，以保存VFS需要了解的有关打开文件的任何信息。只要结构的总大小不超过&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;对象中记录的szOsFile值，存储什么信息都没有关系。</target>
        </trans-unit>
        <trans-unit id="096a69c85e04b646e0b565d9908edc0c892b7052" translate="yes" xml:space="preserve">
          <source>Each argument specified as part of a &quot;CREATE VIRTUAL TABLE ... USING fts5 ...&quot; statement is either a column declaration or a configuration option. A &lt;b&gt;column declaration&lt;/b&gt; consists of one or more whitespace separated FTS5 barewords or string literals quoted in any manner acceptable to SQLite.</source>
          <target state="translated">作为&amp;ldquo; CREATE VIRTUAL TABLE ... USING fts5 ...&amp;rdquo;语句的一部分指定的每个参数都是列声明或配置选项。甲&lt;b&gt;列声明&lt;/b&gt;由一个或多个空格隔开FTS5裸字或文字串在可接受的SQLite任何方式引用的。</target>
        </trans-unit>
        <trans-unit id="c100bec1aacd96fc583726f3228e69edd0918c29" translate="yes" xml:space="preserve">
          <source>Each call to &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; affects subsequent database connections created using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. Database connections that already exist are unaffected. Each call to &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; overrides all previous calls within the same process.</source>
          <target state="translated">每次调用&lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）都会&lt;/a&gt;影响使用&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;，&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;或&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;创建的后续数据库连接。已经存在的数据库连接不受影响。每次调用&lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）都会&lt;/a&gt;覆盖同一进程中的所有先前调用。</target>
        </trans-unit>
        <trans-unit id="f53a6a65a1ce3426676e4e3e0eefc393f32a825e" translate="yes" xml:space="preserve">
          <source>Each call to either sqlite3_trace() or sqlite3_trace_v2() overrides (cancels) any prior calls to sqlite3_trace() or sqlite3_trace_v2().</source>
          <target state="translated">每次调用sqlite3_trace()或sqlite3_trace_v2()都会覆盖(取消)之前对sqlite3_trace()或sqlite3_trace_v2()的任何调用。</target>
        </trans-unit>
        <trans-unit id="210d7d62dedd7b7a03aaed5a472bf17f4f31c5cb" translate="yes" xml:space="preserve">
          <source>Each call to sqlite3rbu_step() does a small amount of work towards completing the vacuum operation. Depending on the size of the database, a single vacuum may require thousands of calls to sqlite3rbu_step(). sqlite3rbu_step() returns SQLITE_DONE if the vacuum operation has finished, SQLITE_OK if the vacuum operation has not finished but no error has occurred, and an SQLite error code if an error is encountered. If an error does occur, all subsequent calls to sqlite3rbu_step() immediately return the same error code.</source>
          <target state="translated">对 sqlite3rbu_step()的每一次调用都会为完成真空操作做少量的工作,根据数据库的大小,一次真空操作可能需要调用 sqlite3rbu_step()数千次。根据数据库的大小,一次真空操作可能需要调用数千次sqlite3rbu_step()。如果真空操作已经完成,sqlite3rbu_step()将返回SQLITE_DONE;如果真空操作没有完成但没有发生错误,则返回SQLITE_OK;如果遇到错误,则返回SQLite错误代码。如果确实发生了错误,所有后续对 sqlite3rbu_step()的调用都会立即返回相同的错误代码。</target>
        </trans-unit>
        <trans-unit id="945385f146c601eb7773bb4497e85e560cda1868" translate="yes" xml:space="preserve">
          <source>Each call to xUpdate will fall into one of cases shown below. Not that references to &lt;b&gt;argv[i]&lt;/b&gt; mean the SQL value held within the argv[i] object, not the argv[i] object itself.</source>
          <target state="translated">对xUpdate的每次调用将属于以下情况之一。并不是说对&lt;b&gt;argv [i]的&lt;/b&gt;引用意味着argv [i]对象中保存的SQL值，而不是argv [i]对象本身。</target>
        </trans-unit>
        <trans-unit id="fc164ad4bbc60e4e26ece4689029d1fc885eb00a" translate="yes" xml:space="preserve">
          <source>Each change recorded by a session object is marked as either direct or indirect. A change is marked as indirect if either:</source>
          <target state="translated">会话对象记录的每项变更都被标记为直接或间接。如果有以下两种情况,则标记为间接变化:</target>
        </trans-unit>
        <trans-unit id="23f47a6b73c8dc551b62d8a4d686a08cd0fe7e37" translate="yes" xml:space="preserve">
          <source>Each column in an SQLite 3 database is assigned one of the following type affinities:</source>
          <target state="translated">SQLite 3数据库中的每一列都被分配了以下类型的亲和力之一。</target>
        </trans-unit>
        <trans-unit id="b225a6098d76a95e7290e27ffd041b5076929def" translate="yes" xml:space="preserve">
          <source>Each column name or expression can be followed by one of the &quot;ASC&quot; or &quot;DESC&quot; keywords to indicate sort order. The sort order may or may not be ignored depending on the database file format, and in particular the &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format number&lt;/a&gt;. The &quot;legacy&quot; schema format (1) ignores index sort order. The descending index schema format (4) takes index sort order into account. Only versions of SQLite 3.3.0 (2006-01-11) and later are able to understand the descending index format. For compatibility, version of SQLite between 3.3.0 and 3.7.9 use the legacy schema format by default. The newer schema format is used by default in version 3.7.10 (2012-01-16) and later. The &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt; can be used to change set the specific behavior for any version of SQLite.</source>
          <target state="translated">每个列名称或表达式后面都可以带有&amp;ldquo; ASC&amp;rdquo;或&amp;ldquo; DESC&amp;rdquo;关键字之一，以指示排序顺序。排序顺序可能会或可能不会被忽略，具体取决于数据库文件格式，尤其是&lt;a href=&quot;fileformat2#schemaformat&quot;&gt;架构格式编号&lt;/a&gt;。 &amp;ldquo;旧式&amp;rdquo;模式格式（1）忽略索引排序顺序。降序索引架构格式（4）考虑了索引排序顺序。只有SQLite 3.3.0（2006-01-11）和更高版本可以理解降序索引格式。为了兼容性，默认情况下，3.3.0和3.7.9之间的SQLite版本使用旧模式格式。默认情况下，版本3.7.10（2012-01-16）和更高版本中使用较新的架构格式。该&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format编译&lt;/a&gt;可用于更改设置的SQLite的任何版本的具体行为。</target>
        </trans-unit>
        <trans-unit id="49f9ccaac189604c31d61c6229cff4580f28bbe6" translate="yes" xml:space="preserve">
          <source>Each component query of a &lt;a href=&quot;lang_select#compound&quot;&gt;compound query&lt;/a&gt; (UNION, UNION ALL, EXCEPT or INTERSECT) is assigned computed separately and is given its own line in the EXPLAIN QUERY PLAN output.</source>
          <target state="translated">&lt;a href=&quot;lang_select#compound&quot;&gt;复合查询的&lt;/a&gt;每个组件查询（UNION，UNION ALL，EXCEPT或INTERSECT）均被分配为单独计算，并在EXPLAIN QUERY PLAN输出中赋予其自己的行。</target>
        </trans-unit>
        <trans-unit id="a75cebae36bdcbe0495a4d634fceea0a434ea48a" translate="yes" xml:space="preserve">
          <source>Each condition in a decision is shown to independently affect the outcome of the decision.</source>
          <target state="translated">决策中的每个条件都显示出对决策结果的独立影响。</target>
        </trans-unit>
        <trans-unit id="eda97b5c1428b06749d7192d2daf361d1e6b41f6" translate="yes" xml:space="preserve">
          <source>Each condition in a decision takes on every possible outcome.</source>
          <target state="translated">决策中的每个条件都要考虑到每一个可能的结果。</target>
        </trans-unit>
        <trans-unit id="672a397b8caf80d825496d9e4addec34b7e37369" translate="yes" xml:space="preserve">
          <source>Each constraint will usually correspond to a term in the WHERE clause or in a USING or ON clause that is of the form</source>
          <target state="translated">每个约束条件通常对应于WHERE子句或USING子句或ON子句中的一个术语,其形式为</target>
        </trans-unit>
        <trans-unit id="f6b6e4c189b9effbef953c5009fced4ccf9808f2" translate="yes" xml:space="preserve">
          <source>Each contiguous run of one or more token characters is considered to be a token. The tokenizer is case-insensitive according to the rules defined by Unicode 6.1.</source>
          <target state="translated">每个连续运行的一个或多个标记字符都被认为是一个标记。根据Unicode 6.1定义的规则,tokenizer是不区分大小写的。</target>
        </trans-unit>
        <trans-unit id="e0c15694bfecc642469801a997c362ec50ff854e" translate="yes" xml:space="preserve">
          <source>Each database connection can only have a single &lt;a href=&quot;c3ref/busy_handler&quot;&gt;busy handler&lt;/a&gt;. This PRAGMA sets the busy handler for the process, possibly overwriting any previously set busy handler.</source>
          <target state="translated">每个数据库连接只能有一个&lt;a href=&quot;c3ref/busy_handler&quot;&gt;繁忙的处理程序&lt;/a&gt;。此PRAGMA设置进程的繁忙处理程序，可能覆盖任何先前设置的繁忙处理程序。</target>
        </trans-unit>
        <trans-unit id="7265aba95bac18bc11991bd9aa22402abe89a0a4" translate="yes" xml:space="preserve">
          <source>Each decision tries every possible outcome.</source>
          <target state="translated">每一个决定都会尝试各种可能的结果。</target>
        </trans-unit>
        <trans-unit id="961e40cf47703a11a49b067baf0edeff976d2243" translate="yes" xml:space="preserve">
          <source>Each diagram is hand-written using the &lt;a href=&quot;https://pikchr.org/&quot;&gt;Pikchr&lt;/a&gt; diagramming language. These hand-written specifications are converted into SVG and inserted inline in the HTML files as part of the documentation build process.</source>
          <target state="translated">每个图表都是使用&lt;a href=&quot;https://pikchr.org/&quot;&gt;Pikchr&lt;/a&gt;图表语言手写的。这些手写的规范将转换为SVG，并作为文档构建过程的一部分内联插入HTML文件中。</target>
        </trans-unit>
        <trans-unit id="f26f253bc3ab871e59787a1a1782281f2039ee4f" translate="yes" xml:space="preserve">
          <source>Each entry and exit point is invoked.</source>
          <target state="translated">每个进入和退出点都会被调用。</target>
        </trans-unit>
        <trans-unit id="6b70891edf39568734c049868720f59bea931ef9" translate="yes" xml:space="preserve">
          <source>Each entry in a table b-tree consists of a 64-bit signed integer key and up to 2147483647 bytes of arbitrary data. (The key of a table b-tree corresponds to the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the SQL table that the b-tree implements.) Interior table b-trees hold only keys and pointers to children. All data is contained in the table b-tree leaves.</source>
          <target state="translated">表b树中的每个条目都由一个64位带符号整数键和最多2147483647个字节的任意数据组成。（表b树的键对应于b树实现的SQL表的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;。）内部表b树仅保留键和指向子级的指针。所有数据都包含在表的b树叶子中。</target>
        </trans-unit>
        <trans-unit id="d5c3f1f6e5f1d0cee7e536d0dc65315194aa51a9" translate="yes" xml:space="preserve">
          <source>Each entry in an index b-tree consists of an arbitrary key of up to 2147483647 bytes in length and no data.</source>
          <target state="translated">索引b树中的每个条目由一个长度不超过2147483647字节的任意键组成,没有数据。</target>
        </trans-unit>
        <trans-unit id="24437abe274be0540b142250bde8d16bab60708f" translate="yes" xml:space="preserve">
          <source>Each entry in most SQLite tables (except for &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables) has a unique 64-bit signed integer key called the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;&quot;rowid&quot;&lt;/a&gt;. The rowid is always available as an undeclared column named ROWID, OID, or _ROWID_ as long as those names are not also used by explicitly declared columns. If the table has a column of type &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; then that column is another alias for the rowid.</source>
          <target state="translated">大多数SQLite表（&lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表除外）中的每个条目都有一个唯一的称为&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;&amp;ldquo; rowid&amp;rdquo;的&lt;/a&gt; 64位带符号整数键。只要未显式声明的列也未使用行名，ROWID始终可以用作未声明的列ROWID，OID或_ROWID_。如果表中的列类型为&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY，&lt;/a&gt;则该列是该行ID的另一个别名。</target>
        </trans-unit>
        <trans-unit id="d1943964848547ccdd4634c64ac1256e964eb11b" translate="yes" xml:space="preserve">
          <source>Each entry in most SQLite tables (except for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables) has a unique 64-bit signed integer key called the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;&quot;rowid&quot;&lt;/a&gt;. The rowid is always available as an undeclared column named ROWID, OID, or _ROWID_ as long as those names are not also used by explicitly declared columns. If the table has a column of type &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; then that column is another alias for the rowid.</source>
          <target state="translated">大多数SQLite表（&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表除外）中的每个条目都有一个唯一的称为&lt;a href=&quot;lang_createtable#rowid&quot;&gt;&amp;ldquo; rowid&amp;rdquo;的&lt;/a&gt; 64位带符号整数键。只要未显式声明的列也未使用行名，ROWID始终可以用作未声明的列ROWID，OID或_ROWID_。如果表中的列类型为&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY，&lt;/a&gt;则该列是该行ID的另一个别名。</target>
        </trans-unit>
        <trans-unit id="901d9854ab50278bb04e1634932e0c3162943701" translate="yes" xml:space="preserve">
          <source>Each entry in the aPgno array has a single corresponding entry in the aHash array. There are more available slots in aHash than there are in aPgno. The unused slots in aHash are filled with zero. And since there are guaranteed to be unused slots in aHash, that means the loop that computes X is guaranteed to terminate. The expected size of X is less than 2. The worst case is that X will be the same as the number of entries in aPgno, in which case the algorithm runs at about the same speed as a linear scan of aPgno. But that worst case performance is exceedingly rare. Usually, the size of X will be small and the use of the aHash array allows one to compute FindFrame(P,M) much faster.</source>
          <target state="translated">aPgno数组中的每个条目在aHash数组中都有一个对应的条目。aHash中的可用槽位比aPgno中的可用槽位多。aHash中未使用的槽位用零填充。由于aHash中保证有未使用的槽位,这意味着计算X的循环保证终止。X的预期大小小于2,最坏的情况是X将与aPgno中的条目数相同,在这种情况下,算法的运行速度与aPgno的线性扫描速度差不多。但这种最坏的情况下的性能是极其罕见的。通常情况下,X的大小会很小,使用aHash数组可以让人们更快地计算FindFrame(P,M)。</target>
        </trans-unit>
        <trans-unit id="0dcf88c184067656c86b627d1a59f0fe0f8cb79f" translate="yes" xml:space="preserve">
          <source>Each entry in the account_change table records a deposit or a withdrawal into an account. Deposits have a positive &quot;amt&quot; and withdrawals have a negative &quot;amt&quot;.</source>
          <target state="translated">在account_change表中的每个条目都记录了一个账户的存款或提款。存款的 &quot;amt &quot;为正数,提款的 &quot;amt &quot;为负数。</target>
        </trans-unit>
        <trans-unit id="a6062c6a4e671adbb7f1cae985fca6efdd1bcc95" translate="yes" xml:space="preserve">
          <source>Each entry in the spellfix1 virtual table is associated with a particular language, identified by the integer &quot;langid&quot; column. The default langid is 0 and if no other actions are taken, the entire vocabulary is a part of the 0 language. But if your application needs to operate in multiple languages, then you can specify different vocabulary items for each language by specifying the langid field when populating the table. For example:</source>
          <target state="translated">spellfix1虚拟表中的每个条目都与特定的语言相关联,由整数 &quot;langid &quot;列标识。默认的langid是0,如果没有其他操作,整个词汇都是0语言的一部分。但是如果你的应用程序需要用多种语言进行操作,那么你可以在填充表时通过指定langid字段为每种语言指定不同的词汇项。比如说</target>
        </trans-unit>
        <trans-unit id="5fac2cc29010afaae6cb51cb626533541baf3f7b" translate="yes" xml:space="preserve">
          <source>Each expression in the result-set is then evaluated once for each group of rows. If the expression is an aggregate expression, it is evaluated across all rows in the group. Otherwise, it is evaluated against a single arbitrarily chosen row from within the group. If there is more than one non-aggregate expression in the result-set, then all such expressions are evaluated for the same row.</source>
          <target state="translated">然后,结果集中的每个表达式对每组行都会被评估一次。如果该表达式是一个集合表达式,那么它将对该组中的所有行进行评估。否则,它将针对组内任意选择的一条记录进行评估。如果结果集中有一个以上的非聚合表达式,那么所有这些表达式都会对同一行进行评估。</target>
        </trans-unit>
        <trans-unit id="6438047b3d0359d4736da15419bdcf6543fd0081" translate="yes" xml:space="preserve">
          <source>Each extension function is allocated a single auxiliary data slot for each FTS query (MATCH expression). If the extension function is invoked more than once for a single FTS query, then all invocations share a single auxiliary data context.</source>
          <target state="translated">每个扩展函数都会为每个FTS查询分配一个辅助数据槽(MATCH表达式)。如果一个FTS查询的扩展函数被调用一次以上,那么所有的调用都共享一个辅助数据上下文。</target>
        </trans-unit>
        <trans-unit id="d33d8aa62c5b61bac293e45f756797b6cb85d50a" translate="yes" xml:space="preserve">
          <source>Each foreign key constraint in SQLite is classified as either immediate or deferred. Foreign key constraints are immediate by default. All the foreign key examples presented so far have been of immediate foreign key constraints.</source>
          <target state="translated">在SQLite中,每个外键约束都被分为即时或延迟。外键约束默认为即时外键约束。到目前为止介绍的所有外键例子都是即时外键约束。</target>
        </trans-unit>
        <trans-unit id="6a1805543360f1e22766e2854c401aca860aeb6b" translate="yes" xml:space="preserve">
          <source>Each fts5vocab table is associated with a single FTS5 table. An fts5vocab table is usually created by specifying two arguments in place of column names in the CREATE VIRTUAL TABLE statement - the name of the associated FTS5 table and the type of fts5vocab table. Currently there are three types of fts5vocab table; &quot;row&quot;, &quot;col&quot; and &quot;instance&quot;. Unless the fts5vocab table is created within the &quot;temp&quot; database, it must be part of the same database as the associated FTS5 table.</source>
          <target state="translated">每个fts5vocab表都与一个fts5表相关联。在CREATE VIRTUAL TABLE语句中,通常通过指定两个参数代替列名来创建fts5vocab表--关联的FTS5表的名称和fts5vocab表的类型。目前fts5vocab表有三种类型:&quot;行&quot;、&quot;列 &quot;和 &quot;实例&quot;。除非fts5vocab表是在 &quot;temp &quot;数据库内创建的,否则它必须与关联的FTS5表属于同一个数据库。</target>
        </trans-unit>
        <trans-unit id="e745e43219ffcc55c78ef25c933503a8941d7638" translate="yes" xml:space="preserve">
          <source>Each group of input dataset rows contributes a single row to the set of result rows. Subject to filtering associated with the DISTINCT keyword, the number of rows returned by an aggregate query with a GROUP BY clause is the same as the number of groups of rows produced by applying the GROUP BY and HAVING clauses to the filtered input dataset.</source>
          <target state="translated">每一组输入数据集的行都为结果行集贡献了一条行。根据与DISTINCT关键字相关联的过滤,使用GROUP BY子句的集合查询所返回的行数与对过滤后的输入数据集应用GROUP BY和HAVING子句所产生的行组数相同。</target>
        </trans-unit>
        <trans-unit id="7843ace013d2f4a1d502e5350d480fd1304c50c8" translate="yes" xml:space="preserve">
          <source>Each host parameter in an SQLite statement is assigned a number. The numbers normally begin with 1 and increase by one with each new parameter. However, when the &quot;?123&quot; form is used, the host parameter number is the number that follows the question mark.</source>
          <target state="translated">SQLite语句中的每个主机参数都被分配了一个数字。数字通常以1开头,每增加一个新参数就增加一个。但是,当使用&quot;?123 &quot;形式时,主机参数编号是问号后面的数字。</target>
        </trans-unit>
        <trans-unit id="aa86db673d2e11cfb16c97d7614715b23b7a434b" translate="yes" xml:space="preserve">
          <source>Each individual test module might contain dozens, hundreds, or thousands of separate tests. The test modules can be written in C or as scripts of SQL or a mixture of the two. About two-thirds of the existing test modules are written in pure SQL with the remainder either in pure C or a combination of C and SQL.</source>
          <target state="translated">每个测试模块可能包含几十个、几百个或几千个独立的测试。测试模块可以用C语言编写,也可以用SQL脚本编写,或者两者混合编写。现有的测试模块中约有三分之二是用纯SQL编写的,其余的则是用纯C或C和SQL的组合编写的。</target>
        </trans-unit>
        <trans-unit id="2c6f71e4dfef9dffaef271af8b4c7b3a147f1117" translate="yes" xml:space="preserve">
          <source>Each inserted row must be accompanied by an explicitly specified rowid value. If a contentless table is configured with columnsize=0, attempting to insert a NULL value into the rowid is an SQLITE_MISMATCH error.</source>
          <target state="translated">每一条插入的记录都必须有一个明确指定的rowid值。如果一个无内容表配置为columnsize=0,那么试图在rowid中插入一个NULL值是一个SQLITE_MISMATCH错误。</target>
        </trans-unit>
        <trans-unit id="899a2acd85a7e060ed04cbcbd2e9466f80cde441" translate="yes" xml:space="preserve">
          <source>Each instruction of the VDBE language contains an opcode and three operands labeled P1, P2, and P3. Operand P1 is an arbitrary integer. P2 is a non-negative integer. P3 is a pointer to a data structure or null-terminated string, possibly null. Only a few VDBE instructions use all three operands. Many instructions use only one or two operands. A significant number of instructions use no operands at all but instead take their data and store their results on the execution stack. The details of what each instruction does and which operands it uses are described in the separate &lt;a href=&quot;opcode&quot;&gt;opcode description&lt;/a&gt; document.</source>
          <target state="translated">VDBE语言的每个指令均包含一个操作码和三个标记为P1，P2和P3的操作数。操作数P1是任意整数。 P2是一个非负整数。 P3是指向数据结构或以null终止的字符串（可能为null）的指针。只有很少的VDBE指令使用所有这三个操作数。许多指令仅使用一个或两个操作数。大量指令完全不使用操作数，而是取其数据并将其结果存储在执行堆栈中。每个指令的作用以及使用的操作数的详细信息在单独的&lt;a href=&quot;opcode&quot;&gt;操作码描述&lt;/a&gt;文档中进行了描述。</target>
        </trans-unit>
        <trans-unit id="f76b1f05c7f0ee24d16c42b081d0c67e73247f0e" translate="yes" xml:space="preserve">
          <source>Each instruction of the VDBE language contains an opcode and three operands labeled P1, P2, and P3. Operand P1 is an arbitrary integer. P2 is a non-negative integer. P3 is a pointer to a data structure or zero-terminated string, possibly null. Only a few VDBE instructions use all three operands. Many instructions use only one or two operands. A significant number of instructions use no operands at all but instead take their data and store their results on the execution stack. The details of what each instruction does and which operands it uses are described in the separate &lt;a href=&quot;opcode&quot;&gt;opcode description&lt;/a&gt; document.</source>
          <target state="translated">VDBE语言的每个指令包含一个操作码和三个标记为P1，P2和P3的操作数。操作数P1是任意整数。 P2是一个非负整数。 P3是指向数据结构或零终止字符串的指针，可能为空。只有很少的VDBE指令使用所有这三个操作数。许多指令仅使用一个或两个操作数。大量指令根本不使用任何操作数，而是取其数据并将其结果存储在执行堆栈中。每个指令的作用及其使用的操作数的详细信息在单独的&lt;a href=&quot;opcode&quot;&gt;操作码描述&lt;/a&gt;文档中进行了描述。</target>
        </trans-unit>
        <trans-unit id="66fd5c0b46cc5a181a71fe28426b2f8ae830bb14" translate="yes" xml:space="preserve">
          <source>Each invocation of &lt;b&gt;sqlite_step&lt;/b&gt; returns an integer code that indicates what happened during that step. This code may be SQLITE_BUSY, SQLITE_ROW, SQLITE_DONE, SQLITE_ERROR, or SQLITE_MISUSE.</source>
          <target state="translated">每次调用&lt;b&gt;sqlite_step都会&lt;/b&gt;返回一个整数代码，该代码指示在该步骤期间发生了什么。此代码可以是SQLITE_BUSY，SQLITE_ROW，SQLITE_DONE，SQLITE_ERROR或SQLITE_MISUSE。</target>
        </trans-unit>
        <trans-unit id="bda57e5707a682202e3ea3669b23018d0d5aa983" translate="yes" xml:space="preserve">
          <source>Each local changeset is rebased by calling sqlite3rebaser_rebase().</source>
          <target state="translated">每一个本地变化集都是通过调用sqlite3rebaser_rebase()来重设的。</target>
        </trans-unit>
        <trans-unit id="77c7956712463753fdecca1cf0561681966682aa" translate="yes" xml:space="preserve">
          <source>Each of the b-trees that make up the full-text index is assigned to a &quot;level&quot; based on its size. Level-0 b-trees are the smallest, as they contain the contents of a single transaction. Higher level b-trees are the result of merging two or more level-0 b-trees together and so they are larger. FTS5 begins to merge b-trees together once there exist</source>
          <target state="translated">构成全文索引的每个b树都根据其大小被分配到一个 &quot;级别&quot;。0级b树是最小的,因为它们包含一个事务的内容。更高级别的b树是将两个或多个0级b树合并在一起的结果,所以它们更大。FTS5开始将b树合并在一起,一旦有了</target>
        </trans-unit>
        <trans-unit id="a769a3ad4df79c7cb38d60dba3f3bf7d78452a22" translate="yes" xml:space="preserve">
          <source>Each of these points will be described in more detail below, after first considering more closely the meaning of &quot;application file format&quot;. See also the &lt;a href=&quot;aff_short&quot;&gt;short version&lt;/a&gt; of this whitepaper.</source>
          <target state="translated">在首先更仔细地考虑&amp;ldquo;应用程序文件格式&amp;rdquo;的含义之后，下面将更详细地描述这些要点。另请参见本白皮书的&lt;a href=&quot;aff_short&quot;&gt;简短版本&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5b3811f86b94838c4eb44ef8dbbc1bed6e5053e" translate="yes" xml:space="preserve">
          <source>Each open SQLite database is represented by a pointer to an instance of the opaque structure named &quot;sqlite3&quot;. It is useful to think of an sqlite3 pointer as an object. The &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interfaces are its constructors, and &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2()&lt;/a&gt; are its destructors. There are many other interfaces (such as &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; to name but three) that are methods on an sqlite3 object.</source>
          <target state="translated">每个打开的SQLite数据库都由一个指向名为&amp;ldquo; sqlite3&amp;rdquo;的不透明结构实例的指针表示。将sqlite3指针视为对象很有用。所述&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（） &lt;/a&gt;，&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16（） &lt;/a&gt;，和&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;接口是它的构造，和&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2（）&lt;/a&gt;是它的析构函数。还有许多其他接口（例如&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;，&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;和&lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;命名为三个）是sqlite3对象上的方法。</target>
        </trans-unit>
        <trans-unit id="92b7576547952b019821d8e7929a16a6e6b6d4ff" translate="yes" xml:space="preserve">
          <source>Each open SQLite database is represented by a pointer to an instance of the opaque structure named &quot;sqlite3&quot;. It is useful to think of an sqlite3 pointer as an object. The &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interfaces are its constructors, and &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt; and &lt;a href=&quot;close&quot;&gt;sqlite3_close_v2()&lt;/a&gt; are its destructors. There are many other interfaces (such as &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;, and &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; to name but three) that are methods on an sqlite3 object.</source>
          <target state="translated">每个打开的SQLite数据库都由一个指向名为&amp;ldquo; sqlite3&amp;rdquo;的不透明结构实例的指针表示。将sqlite3指针视为对象很有用。所述&lt;a href=&quot;open&quot;&gt;sqlite3_open（） &lt;/a&gt;，&lt;a href=&quot;open&quot;&gt;sqlite3_open16（） &lt;/a&gt;，和&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;接口是它的构造，和&lt;a href=&quot;close&quot;&gt;sqlite3_close（）&lt;/a&gt;和&lt;a href=&quot;close&quot;&gt;sqlite3_close_v2（）&lt;/a&gt;是它的析构函数。还有许多其他接口（例如&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;，&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;和&lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;命名为三个）是sqlite3对象上的方法。</target>
        </trans-unit>
        <trans-unit id="ee894daabc7121702b3448691c905adb7d440b29" translate="yes" xml:space="preserve">
          <source>Each ordinary SQL table in the database schema is represented on-disk by a table b-tree. Each entry in the table b-tree corresponds to a row of the SQL table. The &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the SQL table is the 64-bit signed integer key for each entry in the table b-tree.</source>
          <target state="translated">数据库模式中的每个普通SQL表在磁盘上都由表b树表示。表b树中的每个条目对应于SQL表的一行。SQL表的&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;是表b树中每个条目的64位带符号整数键。</target>
        </trans-unit>
        <trans-unit id="74ebddba931d62de6d9b53e43959c1987854ff78" translate="yes" xml:space="preserve">
          <source>Each polygon in the Geopoly module can be associated with an arbitrary number of auxiliary data fields.</source>
          <target state="translated">Geopoly模块中的每个多边形可以与任意数量的辅助数据字段关联。</target>
        </trans-unit>
        <trans-unit id="a000525bb8067810fd906490555a5fd20fbf3f0a" translate="yes" xml:space="preserve">
          <source>Each prepared statement maintains various &lt;a href=&quot;#SQLITE_STMTSTATUS%20counter&quot;&gt;SQLITE_STMTSTATUS counters&lt;/a&gt; that measure the number of times it has performed specific operations. These counters can be used to monitor the performance characteristics of the prepared statements. For example, if the number of table steps greatly exceeds the number of table searches or result rows, that would tend to indicate that the prepared statement is using a full table scan rather than an index.</source>
          <target state="translated">每个准备好的语句都维护各种&lt;a href=&quot;#SQLITE_STMTSTATUS%20counter&quot;&gt;SQLITE_STMTSTATUS计数器&lt;/a&gt;，这些计数器测量其执行特定操作的次数。这些计数器可用于监视准备好的语句的性能特征。例如，如果表步骤的数量大大超过表搜索或结果行的数量，这将倾向于表明已准备好的语句正在使用全表扫描而不是索引。</target>
        </trans-unit>
        <trans-unit id="0107ece90b86e808837320ac7220432f2669eb1d" translate="yes" xml:space="preserve">
          <source>Each prepared statement maintains various &lt;a href=&quot;c_stmtstatus_counter&quot;&gt;SQLITE_STMTSTATUS counters&lt;/a&gt; that measure the number of times it has performed specific operations. These counters can be used to monitor the performance characteristics of the prepared statements. For example, if the number of table steps greatly exceeds the number of table searches or result rows, that would tend to indicate that the prepared statement is using a full table scan rather than an index.</source>
          <target state="translated">每个准备好的语句都维护各种&lt;a href=&quot;c_stmtstatus_counter&quot;&gt;SQLITE_STMTSTATUS计数器&lt;/a&gt;，这些计数器测量其执行特定操作的次数。这些计数器可用于监视准备好的语句的性能特征。例如，如果表步骤的数量大大超过表搜索或结果行的数量，这将倾向于表明已准备好的语句正在使用全表扫描而不是索引。</target>
        </trans-unit>
        <trans-unit id="999331a91fda475fee950bbc880e18a160954827" translate="yes" xml:space="preserve">
          <source>Each read lock byte corresponds to one of the five 32-bit read-mark integers located in bytes 100 through 119 of the WAL-index header, as follows:</source>
          <target state="translated">每个读锁字节对应于位于WAL-索引头字节100至119的5个32位读标记整数中的一个,如下所示。</target>
        </trans-unit>
        <trans-unit id="fd4a538875dcd8a3da92631d9e514ff489421f3d" translate="yes" xml:space="preserve">
          <source>Each row in a table with a primary key must have a unique combination of values in its primary key columns. For the purposes of determining the uniqueness of primary key values, NULL values are considered distinct from all other values, including other NULLs. If an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; or &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement attempts to modify the table content so that two or more rows have identical primary key values, that is a constraint violation.</source>
          <target state="translated">具有主键的表中的每一行在其主键列中必须具有唯一的值组合。为了确定主键值的唯一性，将NULL值视为与所有其他值（包括其他NULL）不同。如果&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;或&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;语句尝试修改表内容，以使两行或更多行具有相同的主键值，则违反约束。</target>
        </trans-unit>
        <trans-unit id="c5fe898fae0731eeb92ba7918d3cd1096012e142" translate="yes" xml:space="preserve">
          <source>Each row in ex25ae contains five columns: a, e, d, c, a. The &quot;a&quot; column is repeated since the first occurrence of &quot;a&quot; has a collating function of &quot;nocase&quot; and the second has a collating sequence of &quot;binary&quot;. If the &quot;a&quot; column is not repeated and if the table contains two or more entries with the same &quot;e&quot; value and where &quot;a&quot; differs only in case, then all of those table entries would correspond to a single entry in the index, which would break the one-to-one correspondence between the table and the index.</source>
          <target state="translated">ex25ae中的每一行都包含五列:a,e,d,c,a。&quot;a &quot;列是重复的,因为第一次出现的 &quot;a &quot;具有 &quot;nocase &quot;的整理函数,第二次出现的 &quot;a &quot;具有 &quot;binary &quot;的整理序列。如果 &quot;a &quot;列不重复,如果表中有两个或两个以上具有相同 &quot;e &quot;值的条目,且其中 &quot;a &quot;仅在大小写上有差异,那么这些表条目都将对应于索引中的一个条目,这将打破表与索引之间的一对一对应关系。</target>
        </trans-unit>
        <trans-unit id="ea6d65e1c2c837dfdc0a485f823d815f1cb8af08" translate="yes" xml:space="preserve">
          <source>Each row in ex25ae contains five columns: c, e, d, c, a. The c column is repeated since the first occurrence of c has a collating function of &quot;nocase&quot; and the second has a collating sequence of &quot;binary&quot;. If the c column is not repeated and if the table contains two or more entries with the same e value and where c differs only in case, then all of those table entries would correspond to a single entry in the index, which would break the one-to-one correspondence between the table and the index.</source>
          <target state="translated">ex25ae中的每一行都包含五列:c、e、d、c、a。c列是重复的,因为第一次出现的c的整理函数为 &quot;nocase&quot;,第二次出现的c的整理序列为 &quot;binary&quot;。如果c列不重复,如果表中包含两个或两个以上具有相同e值的条目,且c仅在大小写上有差异,那么这些表条目都将对应于索引中的一个条目,这将打破表与索引之间的一对一对应关系。</target>
        </trans-unit>
        <trans-unit id="f36fe249b41449ff09e1c30c002890daff1cad55" translate="yes" xml:space="preserve">
          <source>Each row in the ex25ce index is a record with these columns: c, e, d, a. The first two columns are the columns being indexed, c and e. The remaining columns are the primary key of the corresponding table row. Normally, the primary key would be columns d, c, and a, but because column c already appears earlier in the index, it is omitted from the key suffix.</source>
          <target state="translated">ex25ce索引中的每一行都是一条记录,有以下几列:c,e,d,a。前两列是被索引的列,c和e,其余的列是对应表行的主键。通常情况下,主键应该是d、c、a列,但是由于c列已经出现在索引的前面,所以在键后缀中省略了。</target>
        </trans-unit>
        <trans-unit id="cab24ffbbc0f1bf68fc2e07923e9d56fc10203eb" translate="yes" xml:space="preserve">
          <source>Each row in the spellfix1 virtual table has a unique rowid with seven columns plus five extra hidden columns. The columns are as follows:</source>
          <target state="translated">spellfix1虚拟表中的每一行都有一个唯一的rowid,有7列加上5列额外的隐藏列。这些列如下:</target>
        </trans-unit>
        <trans-unit id="8b6636128d8303465a6612a171949922d9167128" translate="yes" xml:space="preserve">
          <source>Each row of the SQLAR table holds the content of a single file. The filename (the full pathname relative to the root of the archive) is in the &quot;name&quot; field. The &quot;mode&quot; field is an integer which is the unix-style access permissions for the file. &quot;mtime&quot; is the modification time of the file in seconds since 1970. &quot;sz&quot; is the original uncompressed size of the file. The &quot;data&quot; field contains the file content. The content is usually compressed using &lt;a href=&quot;http://zlib.net/&quot;&gt;Deflate&lt;/a&gt;, though not always. If the &quot;sz&quot; field is equal to the size of the &quot;data&quot; field, then the content is stored uncompressed.</source>
          <target state="translated">SQLAR表的每一行都保存单个文件的内容。文件名（相对于归档根目录的完整路径名）在&amp;ldquo;名称&amp;rdquo;字段中。 &amp;ldquo;模式&amp;rdquo;字段是一个整数，它是文件的Unix风格的访问权限。 &amp;ldquo; mtime&amp;rdquo;是自1970年以来文件的修改时间，以秒为单位。&amp;ldquo; sz&amp;rdquo;是文件的原始未压缩大小。 &amp;ldquo;数据&amp;rdquo;字段包含文件内容。通常使用&lt;a href=&quot;http://zlib.net/&quot;&gt;Deflate&lt;/a&gt;压缩内容，尽管并非总是如此。如果&amp;ldquo; sz&amp;rdquo;字段等于&amp;ldquo; data&amp;rdquo;字段的大小，则内容将以未压缩的方式存储。</target>
        </trans-unit>
        <trans-unit id="cf4fd240cba207d7e7a635148ee703f41a77d115" translate="yes" xml:space="preserve">
          <source>Each row of the SQLAR table holds the content of a single file. The filename (the full pathname relative to the root of the archive) is in the &quot;name&quot; field. The &quot;mode&quot; field is an integer which is the unix-style access permissions for the file. &quot;mtime&quot; is the modification time of the file in seconds since 1970. &quot;sz&quot; is the original uncompressed size of the file. The &quot;data&quot; field contains the file content. The content is usually compressed using &lt;a href=&quot;https://zlib.net/&quot;&gt;Deflate&lt;/a&gt;, though not always. If the &quot;sz&quot; field is equal to the size of the &quot;data&quot; field, then the content is stored uncompressed.</source>
          <target state="translated">SQLAR表的每一行都保存单个文件的内容。文件名（相对于归档根目录的完整路径名）在&amp;ldquo;名称&amp;rdquo;字段中。 &amp;ldquo;模式&amp;rdquo;字段是一个整数，它是文件的Unix风格的访问权限。 &amp;ldquo; mtime&amp;rdquo;是文件自1970年以来的修改时间，以秒为单位。&amp;ldquo; sz&amp;rdquo;是文件的原始未压缩大小。 &amp;ldquo;数据&amp;rdquo;字段包含文件内容。内容通常使用&lt;a href=&quot;https://zlib.net/&quot;&gt;Deflate&lt;/a&gt;压缩，尽管并非总是如此。如果&amp;ldquo; sz&amp;rdquo;字段等于&amp;ldquo; data&amp;rdquo;字段的大小，则内容将以未压缩的方式存储。</target>
        </trans-unit>
        <trans-unit id="b6165a221a3e4a38199edcd68a8e62b04991c252" translate="yes" xml:space="preserve">
          <source>Each row of the SQLITE_MEMSTAT table corresponds to a single call to one of the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; or &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interfaces. The NAME column of the row identifies which &quot;verb&quot; was passed to those interfaces. For example, if &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; is invoked with &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;, then the NAME column is 'MEMORY_USED'. Or if &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; is invoked with &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscacheused&quot;&gt;SQLITE_DBSTATUS_CACHE_USED&lt;/a&gt;, then the NAME column is &quot;DB_CACHE_USED&quot;.</source>
          <target state="translated">SQLITE_MEMSTAT表的每一行对应于对&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64（）&lt;/a&gt;或&lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;接口之一的一次调用。该行的NAME列标识将哪个&amp;ldquo;动词&amp;rdquo;传递给这些接口。例如，如果使用&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;调用&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64（）&lt;/a&gt;，则NAME列为'MEMORY_USED'。或者，如果使用&lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscacheused&quot;&gt;SQLITE_DBSTATUS_CACHE_USED&lt;/a&gt;调用&lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;，则NAME 列为 &amp;ldquo; DB_CACHE_USED&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="997a34331755f5f92b0f76283ad7cb1a20992bfb" translate="yes" xml:space="preserve">
          <source>Each small sort is run independently, meaning that much less information needs to be kept in temporary storage at any one time.</source>
          <target state="translated">每一个小的排序都是独立运行的,这意味着在任何时候需要保存在临时存储中的信息要少得多。</target>
        </trans-unit>
        <trans-unit id="f0b0b5952e142633475481798bf66c99ae914842" translate="yes" xml:space="preserve">
          <source>Each subsequent string or bareword in a column declaration is a column option that modifies the behaviour of that column. Column options are case-independent. Unlike the SQLite core, FTS5 considers unrecognized column options to be errors. Currently, the only option recognized is &lt;a href=&quot;fts5#the_unindexed_column_option&quot;&gt;&quot;UNINDEXED&quot; (see below)&lt;/a&gt;.</source>
          <target state="translated">列声明中的每个后续字符串或裸字都是一个列选项，用于修改该列的行为。列选项不区分大小写。与SQLite核心不同，FTS5将无法识别的列选项视为错误。当前，唯一识别的选项是&lt;a href=&quot;fts5#the_unindexed_column_option&quot;&gt;&amp;ldquo; UNINDEXED&amp;rdquo;（请参阅​​下文）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="818d5604974790264ec0e5e9c61bfb95c5744c47" translate="yes" xml:space="preserve">
          <source>Each table and each index in SQLite is stored in a separate b-tree in the database file. Each b-tree is identified by its root page number. The root page number for any index or table can be found by querying the &quot;rootpage&quot; column of the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master table&lt;/a&gt;. See the &lt;a href=&quot;queryplanner&quot;&gt;indexing tutorial&lt;/a&gt; and the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; documentation for further background on this design.</source>
          <target state="translated">SQLite中的每个表和每个索引都存储在数据库文件中单独的b树中。每个b树都通过其根页码来标识。可以通过查询&lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master表&lt;/a&gt;的&amp;ldquo; rootpage&amp;rdquo;列找到任何索引或表的根页号。有关该设计的更多背景信息，请参见&lt;a href=&quot;queryplanner&quot;&gt;索引教程&lt;/a&gt;和&lt;a href=&quot;fileformat2&quot;&gt;文件格式&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="4807a7d80bff2589aaa09c4b3fda6efeec4f7456" translate="yes" xml:space="preserve">
          <source>Each table and each index in SQLite is stored in a separate b-tree in the database file. Each b-tree is identified by its root page number. The root page number for any index or table can be found by querying the &quot;rootpage&quot; column of the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt;. See the &lt;a href=&quot;queryplanner&quot;&gt;indexing tutorial&lt;/a&gt; and the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; documentation for further background on this design.</source>
          <target state="translated">SQLite中的每个表和每个索引都存储在数据库文件中单独的b树中。每个b树都通过其根页码来标识。可以通过查询&lt;a href=&quot;schematab&quot;&gt;sqlite_schema表&lt;/a&gt;的&amp;ldquo; rootpage&amp;rdquo;列来找到任何索引或表的根页号。有关该设计的更多背景信息，请参见&lt;a href=&quot;queryplanner&quot;&gt;索引教程&lt;/a&gt;和&lt;a href=&quot;fileformat2&quot;&gt;文件格式&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="5ce016ce4a1263a1e308f54a333440722a399bac" translate="yes" xml:space="preserve">
          <source>Each table and index requires at least one page in the database file. An &quot;index&quot; in the previous sentence means an index created explicitly using a &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement or implicit indices created by UNIQUE and PRIMARY KEY constraints. Since the maximum number of pages in a database file is 2147483646 (a little over 2 billion) this is also then an upper bound on the number of tables and indices in a schema.</source>
          <target state="translated">每个表和索引在数据库文件中至少需要一页。前一句中的&amp;ldquo;索引&amp;rdquo;是指使用&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;语句显式创建的索引或由UNIQUE和PRIMARY KEY约束创建的隐式索引。由于数据库文件中的最大页面数为2147483646（略高于20亿），因此这也是架构中表和索引数的上限。</target>
        </trans-unit>
        <trans-unit id="7fd6452e149193b7e1151a0184d1459cf1e10a68" translate="yes" xml:space="preserve">
          <source>Each table in SQLite may have at most one &lt;b&gt;PRIMARY KEY&lt;/b&gt;. If the keywords PRIMARY KEY are added to a column definition, then the primary key for the table consists of that single column. Or, if a PRIMARY KEY clause is specified as a &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt;, then the primary key of the table consists of the list of columns specified as part of the PRIMARY KEY clause. The PRIMARY KEY clause must contain only column names &amp;mdash; the use of expressions in an &lt;a href=&quot;syntax/indexed-column&quot;&gt;indexed-column&lt;/a&gt; of a PRIMARY KEY is not supported. An error is raised if more than one PRIMARY KEY clause appears in a CREATE TABLE statement. The PRIMARY KEY is optional for ordinary tables but is required for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">SQLite中的每个表最多可以具有一个&lt;b&gt;PRIMARY KEY&lt;/b&gt;。如果将关键字PRIMARY KEY添加到列定义，则表的主键由该单个列组成。或者，如果将PRIMARY KEY子句指定为&lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt;，则表的主键由指定为PRIMARY KEY子句的一部分的列列表组成。 PRIMARY KEY子句必须仅包含列名- 不支持在PRIMARY KEY 的&lt;a href=&quot;syntax/indexed-column&quot;&gt;索引列&lt;/a&gt;中使用表达式。如果在CREATE TABLE语句中出现多个PRIMARY KEY子句，则会引发错误。 PRIMARY KEY对于普通表是可选的，但对于&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表则是必需的。</target>
        </trans-unit>
        <trans-unit id="ae4ff650538e5636d95dba9544b5db7a50ea2e27" translate="yes" xml:space="preserve">
          <source>Each table in SQLite may have at most one PRIMARY KEY. If the keywords PRIMARY KEY are added to a column definition, then the primary key for the table consists of that single column. Or, if a PRIMARY KEY clause is specified as a &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt;, then the primary key of the table consists of the list of columns specified as part of the PRIMARY KEY clause. The PRIMARY KEY clause must contain only column names &amp;mdash; the use of expressions in an &lt;a href=&quot;syntax/indexed-column&quot;&gt;indexed-column&lt;/a&gt; of a PRIMARY KEY is not supported. An error is raised if more than one PRIMARY KEY clause appears in a CREATE TABLE statement. The PRIMARY KEY is optional for ordinary tables but is required for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">SQLite中的每个表最多可以具有一个PRIMARY KEY。如果将关键字PRIMARY KEY添加到列定义，则表的主键由该单个列组成。或者，如果将PRIMARY KEY子句指定为&lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt;，则表的主键由指定为PRIMARY KEY子句的一部分的列列表组成。 PRIMARY KEY子句必须仅包含列名-不支持在PRIMARY KEY的&lt;a href=&quot;syntax/indexed-column&quot;&gt;索引列&lt;/a&gt;中使用表达式。如果CREATE TABLE语句中出现多个PRIMARY KEY子句，则会引发错误。 PRIMARY KEY对于普通表是可选的，但对于&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表则是必需的。</target>
        </trans-unit>
        <trans-unit id="f56c17c407782cb41791f352b9432a0853413a96" translate="yes" xml:space="preserve">
          <source>Each table in the FROM clause of a query can use at most one index (except when the &lt;a href=&quot;#or_opt&quot;&gt;OR-clause optimization&lt;/a&gt; comes into play) and SQLite strives to use at least one index on each table. Sometimes, two or more indexes might be candidates for use on a single table. For example:</source>
          <target state="translated">查询的FROM子句中的每个表最多可以使用一个索引（&lt;a href=&quot;#or_opt&quot;&gt;OR子句优化&lt;/a&gt;生效时除外），SQLite努力在每个表上至少使用一个索引。有时，两个或多个索引可能是在单个表上使用的候选对象。例如：</target>
        </trans-unit>
        <trans-unit id="da7220645d88bb24fc93c16ec387c215924ce8f1" translate="yes" xml:space="preserve">
          <source>Each table in the FROM clause of a query can use at most one index (except when the &lt;a href=&quot;#or_opt&quot;&gt;OR-clause optimization&lt;/a&gt; comes into play) and SQLite strives to use at least one index on each table. Sometimes, two or more indices might be candidates for use on a single table. For example:</source>
          <target state="translated">查询的FROM子句中的每个表最多可以使用一个索引（&lt;a href=&quot;#or_opt&quot;&gt;OR子句优化&lt;/a&gt;生效时除外），SQLite努力在每个表上至少使用一个索引。有时，两个或多个索引可能是在单个表上使用的候选对象。例如：</target>
        </trans-unit>
        <trans-unit id="6d5f5bbc1c1dec038bbb126443a4f518b5530436" translate="yes" xml:space="preserve">
          <source>Each temporary table and index is given its own page cache which can store a maximum number of database pages determined by the SQLITE_DEFAULT_TEMP_CACHE_SIZE compile-time parameter. (The default value is 500 pages.) The maximum number of database pages in the page cache is the same for every temporary table and index. The value cannot be changed at run-time or on a per-table or per-index basis. Each temporary file gets its own private page cache with its own SQLITE_DEFAULT_TEMP_CACHE_SIZE page limit.</source>
          <target state="translated">每个临时表和索引都有自己的页面缓存,它可以存储由SQLITE_DEFAULT_TEMP_CACHE_SIZE编译时参数确定的最大数据库页数。(默认值是500页。)页面缓存中的最大数据库页数对于每个临时表和索引都是一样的。这个值不能在运行时或在每个表或每个索引的基础上改变。每个临时文件都会得到自己的私有页面缓存,并有自己的SQLITE_DEFAULT_TEMP_CACHE_SIZE页面限制。</target>
        </trans-unit>
        <trans-unit id="396be9e68045d4b494141a2b61767c3d988f291c" translate="yes" xml:space="preserve">
          <source>Each test module file contains a header which describes the circumstances under which the test is valid. For a particular configuration, only those modules that are compatible with the configuration are run.</source>
          <target state="translated">每个测试模块文件都包含一个头,它描述了测试有效的情况。对于一个特定的配置,只有那些与该配置兼容的模块才会运行。</target>
        </trans-unit>
        <trans-unit id="82839803e7b91a3d746402c43f4f5e99695c5aff" translate="yes" xml:space="preserve">
          <source>Each time a row is inserted into the table by an INSERT statement that does not provide explicit values for all table columns the values stored in the new row are determined by their default values, as follows:</source>
          <target state="translated">每次通过INSERT语句向表中插入一条记录时,如果没有为所有表列提供显式值,则新行中存储的值由其默认值决定,如下所示。</target>
        </trans-unit>
        <trans-unit id="821f4ad950cccc21cbff55f2ebad926da59331c6" translate="yes" xml:space="preserve">
          <source>Each time the conflict handler function is invoked, it must return one of &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_OMIT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_ABORT&lt;/a&gt; or &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;. SQLITE_CHANGESET_REPLACE may only be returned if the second argument passed to the conflict handler is either SQLITE_CHANGESET_DATA or SQLITE_CHANGESET_CONFLICT. If the conflict-handler returns an illegal value, any changes already made are rolled back and the call to sqlite3changeset_apply() returns SQLITE_MISUSE. Different actions are taken by sqlite3changeset_apply() depending on the value returned by each invocation of the conflict-handler function. Refer to the documentation for the three &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;available return values&lt;/a&gt; for details.</source>
          <target state="translated">每次调用冲突处理程序函数时，它都必须返回&lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_OMIT&lt;/a&gt;，&lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_ABORT&lt;/a&gt;或&lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE中的一个&lt;/a&gt;。仅当传递给冲突处理程序的第二个参数是SQLITE_CHANGESET_DATA或SQLITE_CHANGESET_CONFLICT时，才可以返回SQLITE_CHANGESET_REPLACE。如果冲突处理程序返回非法值，则已进行的所有更改都将回滚，对sqlite3changeset_apply（）的调用将返回SQLITE_MISUSE。 sqlite3changeset_apply（）会根据冲突处理程序函数每次调用返回的值采取不同的操作。有关详细信息，请参考文档中的三个&lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;可用返回值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4fdebc8e16d47a197b7a842f6a3967c8187697b" translate="yes" xml:space="preserve">
          <source>Each time the conflict handler function is invoked, it must return one of &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_OMIT&lt;/a&gt;, &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_ABORT&lt;/a&gt; or &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;. SQLITE_CHANGESET_REPLACE may only be returned if the second argument passed to the conflict handler is either SQLITE_CHANGESET_DATA or SQLITE_CHANGESET_CONFLICT. If the conflict-handler returns an illegal value, any changes already made are rolled back and the call to sqlite3changeset_apply() returns SQLITE_MISUSE. Different actions are taken by sqlite3changeset_apply() depending on the value returned by each invocation of the conflict-handler function. Refer to the documentation for the three &lt;a href=&quot;c_changeset_abort&quot;&gt;available return values&lt;/a&gt; for details.</source>
          <target state="translated">每次调用冲突处理程序函数时，它都必须返回&lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_OMIT&lt;/a&gt;，&lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_ABORT&lt;/a&gt;或&lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE中的一个&lt;/a&gt;。仅当传递给冲突处理程序的第二个参数是SQLITE_CHANGESET_DATA或SQLITE_CHANGESET_CONFLICT时，才可以返回SQLITE_CHANGESET_REPLACE。如果冲突处理程序返回非法值，则已进行的所有更改都将回滚，对sqlite3changeset_apply（）的调用将返回SQLITE_MISUSE。 sqlite3changeset_apply（）会根据冲突处理程序函数每次调用返回的值采取不同的操作。有关详细信息，请参考文档中的三个&lt;a href=&quot;c_changeset_abort&quot;&gt;可用返回值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d207a3340b7e4a9461110fe5af6c49d7e816b35" translate="yes" xml:space="preserve">
          <source>Each time the xInput callback is invoked by the sessions module, the first argument passed is a copy of the supplied pIn context pointer. The second argument, pData, points to a buffer (*pnData) bytes in size. Assuming no error occurs the xInput method should copy up to (*pnData) bytes of data into the buffer and set (*pnData) to the actual number of bytes copied before returning SQLITE_OK. If the input is completely exhausted, (*pnData) should be set to zero to indicate this. Or, if an error occurs, an SQLite error code should be returned. In all cases, if an xInput callback returns an error, all processing is abandoned and the streaming API function returns a copy of the error code to the caller.</source>
          <target state="translated">每次xInput回调被session模块调用时,传递的第一个参数是所提供的pIn上下文指针的副本,第二个参数pData指向大小为字节的缓冲区(*pnData)。第二个参数pData指向一个缓冲区(*pnData)的大小。假设没有发生错误,xInput方法应该将最多(*pnData)字节的数据复制到缓冲区中,并将(*pnData)设置为实际复制的字节数,然后返回SQLITE_OK。如果输入的数据已经完全用完,则应将(*pnData)设为0来表示。或者,如果发生错误,应该返回一个SQLite错误代码。在所有情况下,如果xInput回调返回一个错误,所有的处理都会被放弃,流式API函数会返回一个错误代码的副本给调用者。</target>
        </trans-unit>
        <trans-unit id="23d4a49b5fad6a5cff3892e56560d6b2467c05f2" translate="yes" xml:space="preserve">
          <source>Each transaction can be committed by overwriting the rollback journal header with zeros rather than deleting the journal file. This avoids having to modify the directory entry for the journal file and it avoids having to deallocate disk sectors associated with the journal. Furthermore, the next transaction will overwrite existing journal file content rather than append new content and on most systems overwriting is much faster than appending.</source>
          <target state="translated">每个事务都可以通过用零覆盖回滚日志头而不是删除日志文件来提交。这就避免了修改日记文件的目录条目,也避免了重新分配与日记相关的磁盘扇区。此外,下一个事务将覆盖现有的日记文件内容,而不是追加新的内容,在大多数系统中,覆盖比追加快得多。</target>
        </trans-unit>
        <trans-unit id="159aa0e59fdea8a05c775d6b054f429c0df2af88" translate="yes" xml:space="preserve">
          <source>Each transient index is stored in its own temporary file. The temporary file for a transient index is automatically deleted at the end of the statement that uses it.</source>
          <target state="translated">每个瞬时索引都存储在自己的临时文件中。在使用瞬时索引的语句结束时,瞬时索引的临时文件会被自动删除。</target>
        </trans-unit>
        <trans-unit id="ffcf7118e5b3afe3526ba81a60229a24d4e643bd" translate="yes" xml:space="preserve">
          <source>Each trigger must specify that it will fire for one of the following operations: &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;. The trigger fires once for each row that is deleted, inserted, or updated. If the &quot;UPDATE OF column-name&quot; syntax is used, then the trigger will only fire if column-name appears on the left-hand side of one of the terms in the SET clause of the &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement.</source>
          <target state="translated">每个触发器必须指定将针对以下操作之一触发：&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;，&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;，&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;。触发器针对删除，插入或更新的每一行触发一次。如果使用&amp;ldquo; UPDATE OF column-name&amp;rdquo;语法，则仅当column-name出现在&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;语句的SET子句中某个术语的左侧时，才会触发触发器。</target>
        </trans-unit>
        <trans-unit id="fca57b0c6d20c7ecd27ccd8ad15ef9f43027716b" translate="yes" xml:space="preserve">
          <source>Each value stored in an SQLite database (or manipulated by the database engine) has one of the following storage classes:</source>
          <target state="translated">存储在SQLite数据库中的每个值(或由数据库引擎操作)都有以下存储类之一。</target>
        </trans-unit>
        <trans-unit id="6e662adf0f870371f71f9ee7e2791e8f09589bff" translate="yes" xml:space="preserve">
          <source>Each virtual table instance is represented by an &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure. The sqlite3_vtab structure looks like this:</source>
          <target state="translated">每个虚拟表实例均由&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;结构表示。sqlite3_vtab结构如下所示：</target>
        </trans-unit>
        <trans-unit id="e3984e1960f4cb3742e6adde6b1867fad529f949" translate="yes" xml:space="preserve">
          <source>Easily Extensible</source>
          <target state="translated">易扩展性</target>
        </trans-unit>
        <trans-unit id="efc0c6647d46f478a09189ceb3aa9a013e35a075" translate="yes" xml:space="preserve">
          <source>Edits occur sequentially from left to right. Changes caused by prior edits can affect the path search for subsequent edits.</source>
          <target state="translated">从左到右依次进行编辑。之前的编辑造成的更改会影响后续编辑的路径搜索。</target>
        </trans-unit>
        <trans-unit id="441046fa5ffdde9809362069e6548a3082c7a725" translate="yes" xml:space="preserve">
          <source>Edits occurs sequentially from left to right. Changes caused by prior edits can affect the path search for subsequent edits.</source>
          <target state="translated">从左到右依次进行编辑。之前的编辑造成的改变会影响后续编辑的路径搜索。</target>
        </trans-unit>
        <trans-unit id="e0dfbd71d0c98711cf3c97133105aec44ca6de76" translate="yes" xml:space="preserve">
          <source>Eight bytes of space are set aside in the header to support file locking using the xShmLock() method in the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object. These eight bytes are never read nor written by SQLite since some VFSes (ex: Windows) might implement locks using mandatory file locks.</source>
          <target state="translated">标头中预留了八个字节的空间，以使用&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;对象中的xShmLock（）方法支持文件锁定。由于某些VFS（例如Windows）可能使用强制性文件锁来实现锁，因此SQLite永远不会读取或写入这八个字节。</target>
        </trans-unit>
        <trans-unit id="ace11e5b34a13ed99fabf311ff93445f3668386e" translate="yes" xml:space="preserve">
          <source>Either of the following input table schemas may be used:</source>
          <target state="translated">可使用以下任一输入表模式:</target>
        </trans-unit>
        <trans-unit id="39d37f85cf0de81fb27668a49df7ae8937fb1c1d" translate="yes" xml:space="preserve">
          <source>Either the query is DISTINCT or else the ON or USING clause on the LEFT JOIN constrains the join such that it matches only a single row</source>
          <target state="translated">要么是查询是DISTINCT,要么是LEFT JOIN上的ON或USING子句限制了连接,使得它只匹配一条记录。</target>
        </trans-unit>
        <trans-unit id="4728cde333d59654162b98fb2f80035a1df0e676" translate="yes" xml:space="preserve">
          <source>Else if the ORDER BY is ASC then the boundary is the first row for which X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt;&amp;gt;=X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt;-&amp;lt;expr&amp;gt;.</source>
          <target state="translated">否则，如果ORDER BY是ASC，则边界是X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; &amp;gt; = X &lt;sub&gt;&lt;small&gt;c-&lt;/small&gt;&lt;/sub&gt; &amp;lt;expr&amp;gt; 的第一行。</target>
        </trans-unit>
        <trans-unit id="299837df5991cc66f1e3ca4e6217b98091245afa" translate="yes" xml:space="preserve">
          <source>Else if the ORDER BY is DESC then the boundary is the first row for which X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt;&amp;lt;=X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt;-&amp;lt;expr&amp;gt;.</source>
          <target state="translated">否则，如果ORDER BY是DESC，则边界是X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; &amp;lt;= X &lt;sub&gt;&lt;small&gt;c-&lt;/small&gt;&lt;/sub&gt; &amp;lt;expr&amp;gt; 的第一行。</target>
        </trans-unit>
        <trans-unit id="ec4efc66414e2d0acccb9c6dda956e43ccfc0932" translate="yes" xml:space="preserve">
          <source>ElseNotEq</source>
          <target state="translated">ElseNotEq</target>
        </trans-unit>
        <trans-unit id="742075f0a90a29b1298aa6bdc53785796a5215d5" translate="yes" xml:space="preserve">
          <source>Embedded applications may wish to provide their own mutex implementation. If SQLite is compiled with the -DSQLITE_MUTEX_APPDEF=1 compile-time flag then the SQLite core provides no mutex subsystem and a mutex subsystem that matches the interface described above must be provided by the application that links against SQLite.</source>
          <target state="translated">嵌入式应用可能希望提供自己的mutex实现。如果SQLite在编译时使用-DSQLITE_MUTEX_APPDEF=1编译时标志,那么SQLite核心就不提供mutex子系统,与上述接口相匹配的mutex子系统必须由与SQLite链接的应用程序提供。</target>
        </trans-unit>
        <trans-unit id="e5634a9969e757fb962e238b6f317c641fe0f639" translate="yes" xml:space="preserve">
          <source>Embedded integers can be of arbitrary length. Comparison is not limited to integers that can be expressed as a 64-bit machine integer.</source>
          <target state="translated">嵌入式整数的长度可以是任意的。比较不限于可以用64位机器整数表示的整数。</target>
        </trans-unit>
        <trans-unit id="c53320e0cd9a6276b0d7615514d5e92e35c47d10" translate="yes" xml:space="preserve">
          <source>Enable Or Disable A Session Object</source>
          <target state="translated">启用金币 禁用会话对象</target>
        </trans-unit>
        <trans-unit id="47209fc977a3d6844b590f95a2e890da8c62a167" translate="yes" xml:space="preserve">
          <source>Enable Or Disable Extended Result Codes</source>
          <target state="translated">启用或禁用扩展结果代码</target>
        </trans-unit>
        <trans-unit id="2ae5828f55ab597198616d5a6a29272c5472108b" translate="yes" xml:space="preserve">
          <source>Enable Or Disable Extension Loading</source>
          <target state="translated">启用或禁用扩展加载</target>
        </trans-unit>
        <trans-unit id="4f3889a08ab86ec8ddcc4be30913885c66215716" translate="yes" xml:space="preserve">
          <source>Enable Or Disable Shared Pager Cache</source>
          <target state="translated">启用或禁用共享寻呼机缓存。</target>
        </trans-unit>
        <trans-unit id="9ea1888b42850afab6ed8b09793199ea8c9bea55" translate="yes" xml:space="preserve">
          <source>Enable or disable the recording of changes by a session object. When enabled, a session object records changes made to the database. When disabled - it does not. A newly created session object is enabled. Refer to the documentation for &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; for further details regarding how enabling and disabling a session object affects the eventual changesets.</source>
          <target state="translated">启用或禁用会话对象的更改记录。启用后，会话对象将记录对数据库所做的更改。禁用时-不会。启用了新创建的会话对象。有关启用和禁用会话对象如何影响最终变更集的更多详细信息，请参见&lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset（）&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="17f9b9420a663ed4c76c71c9c8073e9fc9710b0f" translate="yes" xml:space="preserve">
          <source>Enable or disable the recording of changes by a session object. When enabled, a session object records changes made to the database. When disabled - it does not. A newly created session object is enabled. Refer to the documentation for &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; for further details regarding how enabling and disabling a session object affects the eventual changesets.</source>
          <target state="translated">启用或禁用会话对象的更改记录。启用后，会话对象将记录对数据库所做的更改。禁用时-不会。启用了新创建的会话对象。有关启用和禁用会话对象如何影响最终变更集的更多详细信息，请参见&lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset（）&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="d4dfbc50e373163a24f20145d89cc661c7f9016f" translate="yes" xml:space="preserve">
          <source>Enable the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt; for cases when the ESCAPE keyword is present and &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;PRAGMA case_sensitive_like&lt;/a&gt; is on.</source>
          <target state="translated">当存在ESCAPE关键字且&lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;PRAGMA case_sensitive_like处于&lt;/a&gt;打开状态时，启用&lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE优化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="38bd8aad51460f777742311f6118d4753c58ac85" translate="yes" xml:space="preserve">
          <source>Enable the &lt;a href=&quot;pragma#pragma_cell_size_check&quot;&gt;PRAGMA cell_size_check=ON&lt;/a&gt; setting.</source>
          <target state="translated">启用&lt;a href=&quot;pragma#pragma_cell_size_check&quot;&gt;PRAGMA cell_size_check = ON&lt;/a&gt;设置。</target>
        </trans-unit>
        <trans-unit id="9de93a7abfad3451907ee76c7e8380b3e2a12e38" translate="yes" xml:space="preserve">
          <source>Enable the &lt;a href=&quot;queryplanner#or_in_where&quot;&gt;OR optimization&lt;/a&gt; for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">对&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表启用&lt;a href=&quot;queryplanner#or_in_where&quot;&gt;OR优化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="139b97f174f99845864a6e58fe92ec54c44c22d0" translate="yes" xml:space="preserve">
          <source>Enable the code the implements the &lt;a href=&quot;rbu&quot;&gt;RBU extension&lt;/a&gt;.</source>
          <target state="translated">启用实现&lt;a href=&quot;rbu&quot;&gt;RBU扩展&lt;/a&gt;的代码。</target>
        </trans-unit>
        <trans-unit id="2a4b947c5d7c94485590879fd68adb16381cb913" translate="yes" xml:space="preserve">
          <source>Enabled &lt;a href=&quot;loadext#persist&quot;&gt;persistent loadable extensions&lt;/a&gt; using the new &lt;a href=&quot;rescode#ok_load_permanently&quot;&gt;SQLITE_OK_LOAD_PERMANENTLY&lt;/a&gt; return code from the extension entry point.</source>
          <target state="translated">使用新的&lt;a href=&quot;rescode#ok_load_permanently&quot;&gt;SQLITE_OK_LOAD_PERMANENTLY&lt;/a&gt;返回代码从扩展入口点启用的&lt;a href=&quot;loadext#persist&quot;&gt;持久性可加载扩展&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8ea330e39a61763b4ace4d9831f5c3c48035f13c" translate="yes" xml:space="preserve">
          <source>Enabling SQL manipulation of data in statistics packages like R</source>
          <target state="translated">在R等统计软件包中实现对数据的SQL操作。</target>
        </trans-unit>
        <trans-unit id="658589b85baec8128d8a55f7bca7bc8f71c38156" translate="yes" xml:space="preserve">
          <source>Enabling mutexes incurs a measurable performance penalty. So if speed is of utmost importance, it makes sense to disable the mutexes. But for maximum safety, mutexes should be enabled. The default behavior is for mutexes to be enabled.</source>
          <target state="translated">启用mutexes会带来可衡量的性能惩罚。因此,如果速度是最重要的,那么禁用mutexes是合理的。但为了最大限度的安全,应该启用互斥。默认的行为是启用mutexes。</target>
        </trans-unit>
        <trans-unit id="a2894e6ce65268ab410ea576f81be8b800728595" translate="yes" xml:space="preserve">
          <source>Enabling shared-cache for an in-memory database allows two or more database connections in the same process to have access to the same in-memory database. An in-memory database in shared cache is automatically deleted and memory is reclaimed when the last connection to that database closes.</source>
          <target state="translated">为内存数据库启用共享缓存,可以让同一进程中的两个或多个数据库连接访问同一个内存数据库。当最后一个数据库连接关闭时,共享缓存中的内存数据库会被自动删除,并回收内存。</target>
        </trans-unit>
        <trans-unit id="e9d959f1da0d822e6e152768cadbd40ebe86ec7f" translate="yes" xml:space="preserve">
          <source>Encoded Representation</source>
          <target state="translated">编码代表</target>
        </trans-unit>
        <trans-unit id="ce95e3947ec272a5e059c01e37e860b0eadf0f49" translate="yes" xml:space="preserve">
          <source>EndCoroutine</source>
          <target state="translated">EndCoroutine</target>
        </trans-unit>
        <trans-unit id="227897f6614bd1979b06a47b741b2b7b86d2c18a" translate="yes" xml:space="preserve">
          <source>Ending a Read-only Transaction</source>
          <target state="translated">结束一个只读事务</target>
        </trans-unit>
        <trans-unit id="66d638205095ec32694e8e53496ae104a46818bd" translate="yes" xml:space="preserve">
          <source>Enhance &quot;&lt;a href=&quot;cli#dtables&quot;&gt;.tables&lt;/a&gt;&quot; so that it shows the schema names for all attached if the name is anything other than &quot;main&quot;.</source>
          <target state="translated">增强&amp;ldquo; &lt;a href=&quot;cli#dtables&quot;&gt;.tables&lt;/a&gt; &amp;rdquo;，以便在名称不是&amp;ldquo; main&amp;rdquo;以外的其他名称时显示所有附加的架构名称。</target>
        </trans-unit>
        <trans-unit id="86691e1c27add4aa9b223b839c80106c74dae104" translate="yes" xml:space="preserve">
          <source>Enhance &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2(TRUNCATE)&lt;/a&gt; interface so that it truncates the WAL file even if there is no checkpoint work to be done.</source>
          <target state="translated">增强&lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（TRUNCATE）&lt;/a&gt;接口，以便即使没有检查点工作也可以将WAL文件截断。</target>
        </trans-unit>
        <trans-unit id="3a80638ab16814f00dc09b0caf66656e977b1595" translate="yes" xml:space="preserve">
          <source>Enhance &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; to avoid using excess stack space when there are a huge number of terms on the right-hand side of the MATCH operator. A side-effect of this change is that the MATCH operator can only accommodate 12 NEAR operators at a time.</source>
          <target state="translated">增强&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;以避免在MATCH运算符右侧有大量术语时使用过多的堆栈空间。此更改的副作用是MATCH运算符一次只能容纳12个NEAR运算符。</target>
        </trans-unit>
        <trans-unit id="e9e7233e0df128965e10fbf74799b90510b5e89b" translate="yes" xml:space="preserve">
          <source>Enhance &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; so that it recognizes &quot;true&quot; and &quot;false&quot; as valid arguments to DEFAULT.</source>
          <target state="translated">增强&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;，使其可以将&amp;ldquo; true&amp;rdquo;和&amp;ldquo; false&amp;rdquo;识别为DEFAULT的有效参数。</target>
        </trans-unit>
        <trans-unit id="61d4c1e114b8bbe836328fc74b71eb868e847409" translate="yes" xml:space="preserve">
          <source>Enhance &lt;a href=&quot;lang_with#recursivecte&quot;&gt;recursive common table expressions&lt;/a&gt; to support two or more recursive terms as is done by SQL Server, since this helps make &lt;a href=&quot;lang_with#rcex3&quot;&gt;queries against graphs&lt;/a&gt; easier to write and faster to execute.</source>
          <target state="translated">像SQL Server一样，增强&lt;a href=&quot;lang_with#recursivecte&quot;&gt;递归公用表表达式&lt;/a&gt;以支持两个或多个递归术语，因为这有助于使&lt;a href=&quot;lang_with#rcex3&quot;&gt;针对图的查询&lt;/a&gt;更易于编写和执行。</target>
        </trans-unit>
        <trans-unit id="adabac8599a55ec6de7c3ac30be20a3119f8f411" translate="yes" xml:space="preserve">
          <source>Enhance &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; so that they verify &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;.</source>
          <target state="translated">增强&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA完整性&lt;/a&gt;&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;检查&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA快速&lt;/a&gt;检查，以便它们验证CHECK约束。</target>
        </trans-unit>
        <trans-unit id="536fdd0657f2b3142f09507f33c8fdf8c4fc486c" translate="yes" xml:space="preserve">
          <source>Enhance &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; so that it identifies tables that have two or more rows with the same &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">增强&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA的完整性检查，&lt;/a&gt;以便它标识具有两行或更多行且具有相同&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid的表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6c8ab102b2516f5a84e5ee68a4f1dbbb2f643256" translate="yes" xml:space="preserve">
          <source>Enhance &lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt; so that it provides information about &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual tables&lt;/a&gt;.</source>
          <target state="translated">增强&lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt;，使其提供有关&lt;a href=&quot;vtab#epovtab&quot;&gt;同名虚拟表的信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0ba1f90920b2bd9339636a57ccf3fdacffa95fd7" translate="yes" xml:space="preserve">
          <source>Enhance IN operator processing to make use of indices with numeric affinities.</source>
          <target state="translated">加强IN运算符的处理,以利用具有数字亲和力的指数。</target>
        </trans-unit>
        <trans-unit id="38025365863e59085f7f2a503fa8e731d8d8f915" translate="yes" xml:space="preserve">
          <source>Enhance sqlite3_set_authorizer() to provide notification of calls to SQL functions.</source>
          <target state="translated">增强 sqlite3_set_authorizer()以提供调用 SQL 函数的通知。</target>
        </trans-unit>
        <trans-unit id="4c0c2336da07f0e2529ec9f7395eaa4d63613663" translate="yes" xml:space="preserve">
          <source>Enhance the &quot;.lint fkey-indexes&quot; command so that it works with &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">增强&amp;ldquo; .lint fkey-indexes&amp;rdquo;命令，使其与&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表一起使用。</target>
        </trans-unit>
        <trans-unit id="f112cd8de55589eb0d44900a6dc12bd6545e1a14" translate="yes" xml:space="preserve">
          <source>Enhance the &quot;&lt;a href=&quot;cli#dschema&quot;&gt;.schema&lt;/a&gt;&quot; command to show the schema of all attached databases.</source>
          <target state="translated">增强&amp;ldquo; &lt;a href=&quot;cli#dschema&quot;&gt;.schema&lt;/a&gt; &amp;rdquo;命令以显示所有连接的数据库的架构。</target>
        </trans-unit>
        <trans-unit id="1450749989600a2169e792f923ae3be06e80b2a3" translate="yes" xml:space="preserve">
          <source>Enhance the &quot;deserialize&quot; command of the &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; to give it new &quot;--maxsize N&quot; and &quot;--readonly BOOLEAN&quot; options.</source>
          <target state="translated">增强&lt;a href=&quot;tclsqlite&quot;&gt;TCL接口&lt;/a&gt;的&amp;ldquo;反序列化&amp;rdquo;命令，为其提供新的&amp;ldquo; --maxsize N&amp;rdquo;和&amp;ldquo; --readonly BOOLEAN&amp;rdquo;选项。</target>
        </trans-unit>
        <trans-unit id="bc34eefa1c910b5c9ea20b6e33d4506c020abe02" translate="yes" xml:space="preserve">
          <source>Enhance the .filectrl command to support the --schema option.</source>
          <target state="translated">加强.filectrl命令,支持--schema选项。</target>
        </trans-unit>
        <trans-unit id="e9d52f4b3f406b97743f08bc0e546085a24804d2" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count()&lt;/a&gt; interface so that it can be used to determine if SQLITE_DONE has been seen on the prepared statement.</source>
          <target state="translated">增强&lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count（）&lt;/a&gt;接口，以便可以用来确定在准备好的语句中是否已看到SQLITE_DONE。</target>
        </trans-unit>
        <trans-unit id="c405bef651c9af2e88b5ab4ee422e433b81082a5" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; family of interfaces and the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf SQL function&lt;/a&gt; to put comma separators at the thousands marks for integers, if the &quot;,&quot; format modifier is used in between the &quot;%&quot; and the &quot;d&quot; (example: &quot;%,d&quot;).</source>
          <target state="translated">增强&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;系列接口和&lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf SQL函数&lt;/a&gt;，如果在&amp;ldquo;％&amp;rdquo;和&amp;ldquo; d&amp;rdquo;之间使用&amp;ldquo;，&amp;rdquo;格式修饰符（例如：&amp;ldquo;％， d&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="ecc927d861dbadc6775d2c50454d6230fe66defe" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; mechanism so that nested SQL statements such as might be generated by virtual tables are shown but are shown in comments and without parameter expansion. This greatly improves tracing output when using the FTS3/4 and/or RTREE virtual tables.</source>
          <target state="translated">增强&lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace（）&lt;/a&gt;机制，以便显示嵌套的SQL语句，例如可能由虚拟表生成的SQL语句，但在注释中显示，并且不带参数扩展。使用FTS3 / 4和/或RTREE虚拟表时，这可以大大改善跟踪输出。</target>
        </trans-unit>
        <trans-unit id="cea177cb2c536b15d2be8672b409ec45ad8edd94" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; so that a non-zero argument to the &quot;.exit&quot; command causes the shell to exit immediately without cleanly shutting down the database connection.</source>
          <target state="translated">增强&lt;a href=&quot;cli&quot;&gt;命令行外壳程序&lt;/a&gt;，以使&amp;ldquo; .exit&amp;rdquo;命令的非零参数使外壳程序立即退出，而无需彻底关闭数据库连接。</target>
        </trans-unit>
        <trans-unit id="772c4e5a177463139498eb947b87f718df183bb0" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;compile#direct_overflow_read&quot;&gt;SQLITE_DIRECT_OVERFLOW_READ&lt;/a&gt; option so that it works in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; as long as the pages being read are not in the WAL file.</source>
          <target state="translated">增强&lt;a href=&quot;compile#direct_overflow_read&quot;&gt;SQLITE_DIRECT_OVERFLOW_READ&lt;/a&gt;选项，以便在读取的页面不在WAL文件中时，它可以在&lt;a href=&quot;wal&quot;&gt;WAL模式下&lt;/a&gt;工作。</target>
        </trans-unit>
        <trans-unit id="a2b293874fb33d8df6143b9bdce0ba562527728b" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; compile-time option so that it works for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">增强&lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt;编译时选项，使其适用于&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表。</target>
        </trans-unit>
        <trans-unit id="5fc1b69a4cc0c897120d80264056737d7bc2f24c" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux&lt;/a&gt; virtual table so that it can be a TEMP table.</source>
          <target state="translated">增强&lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux&lt;/a&gt;虚拟表，使其可以成为TEMP表。</target>
        </trans-unit>
        <trans-unit id="cbfa3ac4fe2276010370af97ef50f174cd9f6489" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; query syntax so that &lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;column filters&lt;/a&gt; may be applied to arbitrary expressions.</source>
          <target state="translated">增强&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;查询语法，以便可以将&lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;列过滤器&lt;/a&gt;应用于任意表达式。</target>
        </trans-unit>
        <trans-unit id="8ac4e55168d2c25c1939a1629c34937f2515a40d" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;fts5#the_fts5vocab_virtual_table_module&quot;&gt;fts5vocab&lt;/a&gt; virtual table to handle &quot;ORDER BY term&quot; efficiently.</source>
          <target state="translated">增强&lt;a href=&quot;fts5#the_fts5vocab_virtual_table_module&quot;&gt;fts5vocab&lt;/a&gt;虚拟表以有效处理&amp;ldquo; ORDER BY term&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="8e95c6938845927220cf396e7f0c74146b449c86" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;json1#jex&quot;&gt;json_extract()&lt;/a&gt; function to cache and reuse parses of JSON input text.</source>
          <target state="translated">增强&lt;a href=&quot;json1#jex&quot;&gt;json_extract（）&lt;/a&gt;函数以缓存和重用JSON输入文本的解析。</target>
        </trans-unit>
        <trans-unit id="0da54e01b930ee69209e9bd5617e79e614dba785" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command to support the name of an index as its argument, in order to analyze just that one index.</source>
          <target state="translated">增强&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;命令以支持索引名称作为其参数，以便仅分析该索引。</target>
        </trans-unit>
        <trans-unit id="d919d17746299ff0de59c9893d2b29b08bd6e5c1" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; command to support the IF NOT EXISTS clause.</source>
          <target state="translated">增强&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;命令以支持IF NOT EXISTS子句。</target>
        </trans-unit>
        <trans-unit id="4351170db4e47371fac160f7e790286a7669ec9d" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; so that the 'unixepoch' modifier works for the full span of supported dates.</source>
          <target state="translated">增强&lt;a href=&quot;lang_datefunc&quot;&gt;日期和时间功能，&lt;/a&gt;以便&amp;ldquo; unixepoch&amp;rdquo;修饰符可在受支持日期的整个范围内使用。</target>
        </trans-unit>
        <trans-unit id="98c955efd33e3f668b175fbbc0bf42eb02234928" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;'utc' modifier&lt;/a&gt; in the &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; so that it is a no-op if the date/time is known to already be in UTC. (This is not a compatibility break since the behavior has long been documented as &quot;undefined&quot; in that case.)</source>
          <target state="translated">增强&lt;a href=&quot;lang_datefunc&quot;&gt;日期和时间功能中&lt;/a&gt;的&lt;a href=&quot;lang_datefunc#localtime&quot;&gt;'utc'修饰符&lt;/a&gt;，以便在已知日期/时间已经存在于UTC中的情况下禁止操作。（这不是兼容性中断，因为在这种情况下，长期以来该行为被记录为&amp;ldquo;未定义&amp;rdquo;。）</target>
        </trans-unit>
        <trans-unit id="ba8fa245aa7effdf69df893d75d48b052b4da271" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; syntax to allow multiple rows to be inserted via the VALUES clause.</source>
          <target state="translated">增强&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;语法，以允许通过VALUES子句插入多行。</target>
        </trans-unit>
        <trans-unit id="39f00e6685deaa75aceff3c6d176c2d609bfced0" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command so that pending queries are allowed to continue as long as the schema is unchanged. Formerly, a ROLLBACK would cause all pending queries to fail with an &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; or &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; error. That error is still returned if the ROLLBACK modifies the schema.</source>
          <target state="translated">增强&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;命令，以便在架构不变的情况下允许继续执行挂起的查询。以前，ROLLBACK会导致所有挂起的查询失败，并显示&lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;或&lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt;错误。如果ROLLBACK修改架构，则仍会返回该错误。</target>
        </trans-unit>
        <trans-unit id="b1ae47128c1a762921f457e8e1bfe678e897d057" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; so that it can store the parser object as a stack variable rather than allocating space from the heap and make use of that enhancement in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;.</source>
          <target state="translated">增强&lt;a href=&quot;lemon&quot;&gt;Lemon解析器生成器&lt;/a&gt;，使其可以将解析器对象存储为堆栈变量，而不是从堆中分配空间，并在&lt;a href=&quot;amalgamation&quot;&gt;合并中&lt;/a&gt;利用该增强功能。</target>
        </trans-unit>
        <trans-unit id="a0f666e6813fb5c4fe717347ffd40771c1d7b80b" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;loadext&quot;&gt;extension loading&lt;/a&gt; mechanism to be more flexible (while still maintaining backwards compatibility) in two ways:</source>
          <target state="translated">通过两种方式增强&lt;a href=&quot;loadext&quot;&gt;扩展加载&lt;/a&gt;机制，使其更灵活（同时仍保持向后兼容性）：</target>
        </trans-unit>
        <trans-unit id="abd36cf21afd6f7d8bfb48fcbea3c10187ce565b" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt; so that it is able to flatten views on the right-hand side of a LEFT JOIN.</source>
          <target state="translated">增强展&lt;a href=&quot;optoverview#flattening&quot;&gt;平优化&lt;/a&gt;，使其能够展平左联接右侧的视图。</target>
        </trans-unit>
        <trans-unit id="897318b35a6a9404b9601809620b672a31ea4c74" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt; so that it works for arbitrary expressions on the left-hand side as long as the LIKE pattern on the right-hand side does not begin with a digit or minus sign.</source>
          <target state="translated">增强&lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE优化，&lt;/a&gt;以便它适用于左侧的任意表达式，只要右侧的LIKE模式不以数字或减号开头。</target>
        </trans-unit>
        <trans-unit id="48de942fdbd65dcbd99636658f1be1df7651f0d2" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan&lt;/a&gt; optimization so that it is able to skip index terms that occur in the middle of the index, not just as the left-hand side of the index.</source>
          <target state="translated">增强&lt;a href=&quot;optoverview#skipscan&quot;&gt;跳过扫描&lt;/a&gt;优化，以便它能够跳过出现在索引中间的索引词，而不仅仅是出现在索引的左侧。</target>
        </trans-unit>
        <trans-unit id="8d2a8ec267addf3f625f62574683688a31353a8e" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;pragma#pragma_cache_spill&quot;&gt;PRAGMA cache_spill&lt;/a&gt; statement to accept a 32-bit integer parameter which is the threshold below which cache spilling is prohibited.</source>
          <target state="translated">增强&lt;a href=&quot;pragma#pragma_cache_spill&quot;&gt;PRAGMA cache_spill&lt;/a&gt;语句以接受32位整数参数，该参数是阈值，低于该阈值禁止缓存溢出。</target>
        </trans-unit>
        <trans-unit id="6af9f76eeba6bbc6beb0d63968ad71854f553990" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;pragma#pragma_function_list&quot;&gt;function_list pragma&lt;/a&gt; to show the number of arguments on each function, the type of function (scalar, aggregate, window), and the function property flags &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;, &lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;, &lt;a href=&quot;c3ref/c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt;, and/or &lt;a href=&quot;c3ref/c_deterministic#sqlitesubtype&quot;&gt;SQLITE_SUBTYPE&lt;/a&gt;.</source>
          <target state="translated">增强&lt;a href=&quot;pragma#pragma_function_list&quot;&gt;function_list杂注&lt;/a&gt;以显示每个函数的参数数量，函数的类型（标量，集合，窗口）以及函数属性标志&lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;，&lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;，&lt;a href=&quot;c3ref/c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt;和/或&lt;a href=&quot;c3ref/c_deterministic#sqlitesubtype&quot;&gt;SQLITE_SUBTYPE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7925d1322092ec92042d18a4d3bf644989f4dd6" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; command for improved detection of problems on the page freelist.</source>
          <target state="translated">增强&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA完整性检查&lt;/a&gt;命令，以改进对页面空闲列表中问题的检测。</target>
        </trans-unit>
        <trans-unit id="219b1962c9f3fd940e59a7c4455cdb5d4fd58474" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; command to use much less memory when processing multi-gigabyte databases.</source>
          <target state="translated">增强&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA完整性检查&lt;/a&gt;命令，以在处理数GB的数据库时使用更少的内存。</target>
        </trans-unit>
        <trans-unit id="8df03990bad246d4ae7e8d5ff6f0df49f2131cd4" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt; command so that the &quot;pk&quot; column is an increasing integer to show the order of columns in the primary key.</source>
          <target state="translated">增强&lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt;命令，以使&amp;ldquo; pk&amp;rdquo;列是一个递增的整数，以显示主键中列的顺序。</target>
        </trans-unit>
        <trans-unit id="467321e371cfce36156fc492790ccfffef995b05" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; extension to support &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.</source>
          <target state="translated">增强&lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt;扩展以支持&lt;a href=&quot;expridx&quot;&gt;表达式索引&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="231b7b233c891814a3929090a78107d20ccb49c0" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;session/sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; interface so that it is hardened against attacks from deliberately corrupted &lt;a href=&quot;sessionintro#changeset&quot;&gt;changeset&lt;/a&gt; objects.</source>
          <target state="translated">增强&lt;a href=&quot;session/sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;接口，以增强其抵御故意损坏的&lt;a href=&quot;sessionintro#changeset&quot;&gt;变更集&lt;/a&gt;对象的攻击的能力。</target>
        </trans-unit>
        <trans-unit id="e8d859c94c8aab395c8d624a4d2e4d798aac099e" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;sessionintro&quot;&gt;session extension&lt;/a&gt; to support &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">增强&lt;a href=&quot;sessionintro&quot;&gt;会话扩展&lt;/a&gt;以支持&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表。</target>
        </trans-unit>
        <trans-unit id="8752b22acf88cad45a773b2eaf772abcc4d468b3" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; extension so that the edit distance cost table can be changed at runtime by inserting a string like 'edit_cost_table=TABLE' into the &quot;command&quot; field.</source>
          <target state="translated">增强&lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt;扩展名，以便可以在运行时通过将&amp;ldquo; edit_cost_table = TABLE&amp;rdquo;之类的字符串插入&amp;ldquo;命令&amp;rdquo;字段来更改编辑距离成本表。</target>
        </trans-unit>
        <trans-unit id="8b13a66a5bb583f4d677f5f0eca1ac21ccbb9fa6" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; extension to support &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clauses.</source>
          <target state="translated">增强&lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt;扩展名以支持&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;子句。</target>
        </trans-unit>
        <trans-unit id="a9847e0191d05131d0f627947fd7ce04c0efa7b0" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; virtual table so that it can search efficiently by rowid.</source>
          <target state="translated">增强&lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt;虚拟表，使其可以按rowid有效地进行搜索。</target>
        </trans-unit>
        <trans-unit id="2aab8554cf986b2fcf65f02990aae7c32a2d4293" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt; utility program so that it shows the number of bytes of metadata on btree pages.</source>
          <target state="translated">增强&lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt;实用程序，使其在btree页面上显示元数据的字节数。</target>
        </trans-unit>
        <trans-unit id="9c1a0bc76cd9728f28938754bb61c49141b278e1" translate="yes" xml:space="preserve">
          <source>Enhance the Windows OS layer to provide detailed error codes</source>
          <target state="translated">增强Windows操作系统层,提供详细的错误代码。</target>
        </trans-unit>
        <trans-unit id="28df058400861b985faef942373bae5431c24f4a" translate="yes" xml:space="preserve">
          <source>Enhance the page cache so that it can preallocate a block of memory to use for the initial set page cache lines. Set the default preallocation to 100 pages. Yields about a 5% performance increase on common workloads.</source>
          <target state="translated">增强页面缓存,使其能够预分配一块内存,用于初始设置页面缓存行。将默认预分配设置为100页。在普通工作负载上产生约5%的性能提升。</target>
        </trans-unit>
        <trans-unit id="f43e9f09e30e90da585a7e2f997499c318811db5" translate="yes" xml:space="preserve">
          <source>Enhance the presentation concept beyond the simple linear sequence of slides to allow for side-tracks and excursions to be taken depending on how the audience is responding.</source>
          <target state="translated">加强演示概念,超越简单的线性幻灯片序列,根据听众的反应,可以进行旁敲侧击和游览。</target>
        </trans-unit>
        <trans-unit id="dd0cc6e91ac3090a90fc5fc0536b586ecd051561" translate="yes" xml:space="preserve">
          <source>Enhance the query optimizer so that ORDER BY clauses are more aggressively optimized, especially in joins where various terms of the ORDER BY clause come from separate tables of the join.</source>
          <target state="translated">增强查询优化器,使ORDER BY子句得到更积极的优化,特别是在连接中,ORDER BY子句的各种条件来自连接的不同表。</target>
        </trans-unit>
        <trans-unit id="cb820f0118ef79630d408199d7422e6f8fb9737c" translate="yes" xml:space="preserve">
          <source>Enhance the query optimizer to exploit transitive join constraints.</source>
          <target state="translated">增强查询优化器,以利用转折性连接约束。</target>
        </trans-unit>
        <trans-unit id="e627de0a427baf27ab64042414ff38a649039427" translate="yes" xml:space="preserve">
          <source>Enhance the query planner so that it always prefers an index that uses a superset of WHERE clause terms relative to some other index.</source>
          <target state="translated">增强查询规划器,使其总是优先选择使用相对于其他索引的WHERE子句超集的索引。</target>
        </trans-unit>
        <trans-unit id="d0052283e64299690870842cb9d496fab1611f5c" translate="yes" xml:space="preserve">
          <source>Enhance the query planner so that it will try to use a &lt;a href=&quot;queryplanner#covidx&quot;&gt;covering index&lt;/a&gt; on queries that make use of &lt;a href=&quot;optoverview#or_opt&quot;&gt;or optimization&lt;/a&gt;.</source>
          <target state="translated">增强查询计划程序，使其尝试对使用&lt;a href=&quot;optoverview#or_opt&quot;&gt;或优化的&lt;/a&gt;查询使用&lt;a href=&quot;queryplanner#covidx&quot;&gt;覆盖索引&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a1d5782317135d4e9e1b715596bb2a96d2101b89" translate="yes" xml:space="preserve">
          <source>Enhance the query planner to permit &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; on FROM-clause subqueries that are implemented by co-routine.</source>
          <target state="translated">增强查询计划程序，以允许对由协同例程实现的FROM子句子查询进行&lt;a href=&quot;optoverview#autoindex&quot;&gt;自动索引&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40575878eee4f99d3db668f19cca94585d78c781" translate="yes" xml:space="preserve">
          <source>Enhance the query plans for joins to detect empty tables early and halt without doing unnecessary work.</source>
          <target state="translated">加强对联接的查询计划,及早发现空表并停止,不做不必要的工作。</target>
        </trans-unit>
        <trans-unit id="7e270b8357535bbb251d02aee12541124f9d7c3b" translate="yes" xml:space="preserve">
          <source>Enhance virtual tables so that they can potentially use an index when the WHERE clause contains the IN operator.</source>
          <target state="translated">增强虚拟表的功能,当WHERE子句包含IN操作符时,它们可以使用索引。</target>
        </trans-unit>
        <trans-unit id="64b37213a97e0883e534b3385cdb0e0b6f843807" translate="yes" xml:space="preserve">
          <source>Enhanced &quot;WHERE x NOT NULL&quot; &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt; so that they are usable if the &quot;x&quot; column appears in a LIKE or GLOB operator.</source>
          <target state="translated">增强的&amp;ldquo; WHERE x NOT NULL&amp;rdquo; &lt;a href=&quot;partialindex&quot;&gt;部分索引，&lt;/a&gt;以便在LIKE或GLOB运算符中出现&amp;ldquo; x&amp;rdquo;列时可以使用它们。</target>
        </trans-unit>
        <trans-unit id="a53735f6ffe5602297bc4654161d4607e891ee5a" translate="yes" xml:space="preserve">
          <source>Enhanced &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; so that it interrupts &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operations that are in process.</source>
          <target state="translated">增强的&lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt（），&lt;/a&gt;以便中断正在进行的&lt;a href=&quot;wal#ckpt&quot;&gt;检查点&lt;/a&gt;操作。</target>
        </trans-unit>
        <trans-unit id="0812496f77019d7c2d50d40287e3b617287deab7" translate="yes" xml:space="preserve">
          <source>Enhanced &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; to support &lt;a href=&quot;fts5#trigramidx&quot;&gt;trigram indexes&lt;/a&gt;.</source>
          <target state="translated">增强的&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;支持三字母&lt;a href=&quot;fts5#trigramidx&quot;&gt;索引&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d9ce2a6349e3a16f7d2da3b2d327d63134ac2a74" translate="yes" xml:space="preserve">
          <source>Enhanced &lt;a href=&quot;lang_vacuum#vacuuminto&quot;&gt;VACUUM INTO&lt;/a&gt; so that it works for read-only databases.</source>
          <target state="translated">增强的&lt;a href=&quot;lang_vacuum#vacuuminto&quot;&gt;VACUUM INTO&lt;/a&gt;，使其适用于只读数据库。</target>
        </trans-unit>
        <trans-unit id="d58eb320cd88342fcb6b05fb5333e1bcd0a48413" translate="yes" xml:space="preserve">
          <source>Enhanced &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; to detect obscure row corruption that they were formerly missing. Also update both pragmas so that they return error text rather than SQLITE_CORRUPT when encountering corruption in &lt;a href=&quot;fileformat2#record_format&quot;&gt;records&lt;/a&gt;.</source>
          <target state="translated">增强的&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA完整性检查&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA快速检查功能，&lt;/a&gt;以检测以前丢失的模糊行损坏。同时更新两个编译指示，以便遇到&lt;a href=&quot;fileformat2#record_format&quot;&gt;记录&lt;/a&gt;损坏时返回错误文本，而不是SQLITE_CORRUPT 。</target>
        </trans-unit>
        <trans-unit id="02e341c795f6d9f53e59131ad36a699c4ff420f9" translate="yes" xml:space="preserve">
          <source>Enhanced &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; so that it works efficiently with transactions that are larger than the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt;.</source>
          <target state="translated">增强的&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;，使其可以有效地处理大于&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size的&lt;/a&gt;事务。</target>
        </trans-unit>
        <trans-unit id="938e043ef3afc8ac9c960dfd817d79b316b06aa6" translate="yes" xml:space="preserve">
          <source>Enhanced &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;:</source>
          <target state="translated">增强的&lt;a href=&quot;windowfunctions&quot;&gt;窗口功能&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="7660b18630bc2b632af83f376ef82bda6bdc2e58" translate="yes" xml:space="preserve">
          <source>Enhanced Query Syntax Precedence</source>
          <target state="translated">增强的查询语法优先性</target>
        </trans-unit>
        <trans-unit id="8bcd37976631ed421f835c87d3d23437e964c0a6" translate="yes" xml:space="preserve">
          <source>Enhanced output from EXPLAIN QUERY PLAN</source>
          <target state="translated">增强的EXPLAIN QUERY PLAN输出。</target>
        </trans-unit>
        <trans-unit id="1c6f13fb6731d5f1314775333c356324516fd9b6" translate="yes" xml:space="preserve">
          <source>Enhanced query syntax</source>
          <target state="translated">增强的查询语法</target>
        </trans-unit>
        <trans-unit id="dc0f782772ac6cdd040a571e5d1cd41d9b2afc70" translate="yes" xml:space="preserve">
          <source>Enhanced robustness against corrupt database files</source>
          <target state="translated">增强对数据库文件损坏的稳健性</target>
        </trans-unit>
        <trans-unit id="9e2446878f5c7a8d27e1c2936004a6080d4f4b4a" translate="yes" xml:space="preserve">
          <source>Enhanced support for QNX.</source>
          <target state="translated">增强对QNX的支持。</target>
        </trans-unit>
        <trans-unit id="0223b7b5ad2a577e9f0cf5bf1f244664a462bf07" translate="yes" xml:space="preserve">
          <source>Enhanced the &quot;.explain&quot; output formatting of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; so that loops are indented to better show the structure of the program.</source>
          <target state="translated">增强了&lt;a href=&quot;cli&quot;&gt;命令行外壳程序&lt;/a&gt;的&amp;ldquo; .explain&amp;rdquo;输出格式，以便缩进循环以更好地显示程序的结构。</target>
        </trans-unit>
        <trans-unit id="94edddbbf9619d5825cd24602cf6d956452cf785" translate="yes" xml:space="preserve">
          <source>Enhanced the &quot;.stats&quot; command in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; to show more information about I/O performance obtained from /proc, when available.</source>
          <target state="translated">增强了&lt;a href=&quot;cli&quot;&gt;命令行外壳中&lt;/a&gt;的&amp;ldquo; .stats&amp;rdquo;命令，以显示有关从/ proc获得的I / O性能的更多信息（如果有）。</target>
        </trans-unit>
        <trans-unit id="2aa8aa5b2dc44e64f3c9062e559b9b8c4adaf741" translate="yes" xml:space="preserve">
          <source>Enhanced the &quot;.timer&quot; feature of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; so that it shows wall-clock time in addition to system and user times.</source>
          <target state="translated">增强了&lt;a href=&quot;cli&quot;&gt;命令行外壳程序&lt;/a&gt;的&amp;ldquo; .timer&amp;rdquo;功能，因此除了系统和用户时间外，它还显示墙上时钟时间。</target>
        </trans-unit>
        <trans-unit id="e9eedfea42ccb52b08d5d71e48835b1549173842" translate="yes" xml:space="preserve">
          <source>Enhanced the &quot;PRAGMA integrity_check&quot; command to verify indices.</source>
          <target state="translated">增强了 &quot;PRAGMA integrity_check &quot;命令来验证指数。</target>
        </trans-unit>
        <trans-unit id="22989ee7d350e245715e0beb8399b8e0157509a2" translate="yes" xml:space="preserve">
          <source>Enhanced the &lt;a href=&quot;carray&quot;&gt;carray() table-valued function&lt;/a&gt; to include a single-argument form that is bound using the auxiliary &lt;a href=&quot;carray#onearg&quot;&gt;sqlite3_carray_bind()&lt;/a&gt; interface.</source>
          <target state="translated">增强了&lt;a href=&quot;carray&quot;&gt;carray（）表值函数的功能，&lt;/a&gt;以包括使用辅助&lt;a href=&quot;carray#onearg&quot;&gt;sqlite3_carray_bind（）&lt;/a&gt;接口绑定的单参数形式。</target>
        </trans-unit>
        <trans-unit id="eb3be9ff58724d11d359ec60b1f2bdd37d420981" translate="yes" xml:space="preserve">
          <source>Enhanced the &lt;a href=&quot;csv&quot;&gt;CSV virtual table&lt;/a&gt; so that it accepts the last row of input if the final new-line character is missing.</source>
          <target state="translated">增强了&lt;a href=&quot;csv&quot;&gt;CSV虚拟表，&lt;/a&gt;以便在缺少最后一个换行符的情况下接受最后一行输入。</target>
        </trans-unit>
        <trans-unit id="03045a32dbdfe87bdfc9bebef5d2e3a25bb91ada" translate="yes" xml:space="preserve">
          <source>Enhanced the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt; so that it can be used as a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; where the argument is the schema to be analyzed.</source>
          <target state="translated">增强了&lt;a href=&quot;dbstat&quot;&gt;dbstat虚拟表&lt;/a&gt;，使其可以用作&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;，其中参数是要分析的模式。</target>
        </trans-unit>
        <trans-unit id="ad6a5655675e95781c7a9176042eb4c49edd8c22" translate="yes" xml:space="preserve">
          <source>Enhanced the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; and &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; matching algorithm to be faster for cases when the pattern contains multiple wildcards.</source>
          <target state="translated">增强了&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;和&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;匹配算法，以在模式包含多个通配符的情况下更快。</target>
        </trans-unit>
        <trans-unit id="9c97dd68b6c9f22cde01203cef9708636a363e9d" translate="yes" xml:space="preserve">
          <source>Enhanced the &lt;a href=&quot;optoverview&quot;&gt;query planner&lt;/a&gt; so that it is able to use a &lt;a href=&quot;queryplanner#covidx&quot;&gt;covering index&lt;/a&gt; as part of the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt;.</source>
          <target state="translated">增强了&lt;a href=&quot;optoverview&quot;&gt;查询计划程序&lt;/a&gt;，使其能够将&lt;a href=&quot;queryplanner#covidx&quot;&gt;覆盖索引&lt;/a&gt;用作&lt;a href=&quot;optoverview#or_opt&quot;&gt;OR优化的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="256c4a1bf22f495e02d25767299c762ded55fdd3" translate="yes" xml:space="preserve">
          <source>Enhanced the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt; so that it works with an &lt;a href=&quot;lang_expr#like&quot;&gt;ESCAPE&lt;/a&gt; clause.</source>
          <target state="translated">增强了&lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE优化&lt;/a&gt;，使其可以与&lt;a href=&quot;lang_expr#like&quot;&gt;ESCAPE&lt;/a&gt;子句一起使用。</target>
        </trans-unit>
        <trans-unit id="bde313d13aaa9fdf420067e179b8337b3404aa95" translate="yes" xml:space="preserve">
          <source>Enhanced the &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; command to detect &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; constraint violations.</source>
          <target state="translated">增强了&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;命令，以检测&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;和&lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt;约束冲突。</target>
        </trans-unit>
        <trans-unit id="7c51abaf51ff7f2df08f11da95255ddde7c74fef" translate="yes" xml:space="preserve">
          <source>Enhanced the comments that are inserted into &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; output when the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">增强了启用&lt;a href=&quot;compile#enable_explain_comments&quot;&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt;编译时选项时插入&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;输出中的注释。</target>
        </trans-unit>
        <trans-unit id="dff3454f906eefe264d191aaa218dcd2cf753166" translate="yes" xml:space="preserve">
          <source>Enhanced the default memory allocator to make use of _msize() on windows, malloc_size() on Mac, and malloc_usable_size() on Linux.</source>
          <target state="translated">增强了默认的内存分配器,在windows下使用_msize(),在Mac上使用malloc_size(),在Linux上使用malloc_usable_size()。</target>
        </trans-unit>
        <trans-unit id="8dccfbae6b585eff24791000050934f841f040bd" translate="yes" xml:space="preserve">
          <source>Enhanced the internal text-to-numeric conversion routines so that they work with UTF8 or UTF16, thereby avoiding some UTF16-to-UTF8 text conversions.</source>
          <target state="translated">增强了内部文本到数字的转换例程,使其能与UTF8或UTF16一起工作,从而避免了一些UTF16到UTF8的文本转换。</target>
        </trans-unit>
        <trans-unit id="6609f817a6cdf7acf014351660bd59875dbce83c" translate="yes" xml:space="preserve">
          <source>Enhanced the query optimizer so that &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; are able to make use of OR and IN operators in the WHERE clause.</source>
          <target state="translated">增强了查询优化器，以便&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;能够在WHERE子句中使用OR和IN运算符。</target>
        </trans-unit>
        <trans-unit id="b8bc09d2f6561ee38b5b8b664bf1d3480673895a" translate="yes" xml:space="preserve">
          <source>Enhanced the query optimizer so that it is able to use multiple indices to efficiently process &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR-connected constraints&lt;/a&gt; in a WHERE clause.</source>
          <target state="translated">增强了查询优化器，使其能够使用多个索引来有效处理WHERE子句中的&lt;a href=&quot;optoverview#or_opt&quot;&gt;OR连接约束&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cbc1ad5cd7bef1c364230feb92b6f22c6fc43de9" translate="yes" xml:space="preserve">
          <source>Enhanced the query planner flattening logic to allow UNION ALL compounds to be promoted upwards to replace a simple wrapper SELECT even if the compounds are joins.</source>
          <target state="translated">增强了查询规划器的扁平化逻辑,允许UNION ALL化合物向上提升,以取代简单的包装SELECT,即使化合物是join。</target>
        </trans-unit>
        <trans-unit id="4282b314fce027a8694a86f4759e991c3a4226cf" translate="yes" xml:space="preserve">
          <source>Enhanced the query planner so that it can factor terms in and out of OR expressions in the WHERE clause in an effort to find better indices.</source>
          <target state="translated">增强了查询规划器,使其能够在WHERE子句中加入或不加入OR表达式的因素,以努力找到更好的索引。</target>
        </trans-unit>
        <trans-unit id="c87a7d0685fbf2f5e8470e67e88964a89110390d" translate="yes" xml:space="preserve">
          <source>Enhanced the query planner so that the xfer optimization can be used with INTEGER PRIMARY KEY ON CONFLICT as long as the destination table is initially empty.</source>
          <target state="translated">增强了查询规划器,使xfer优化可以使用INTEGER PRIMARY KEY ON CONFLICT,只要目标表初始为空。</target>
        </trans-unit>
        <trans-unit id="930e0780c36ad4d8952bea14bbd67981a9f86931" translate="yes" xml:space="preserve">
          <source>Enhanced the query planner to support index queries with range constraints on the rowid.</source>
          <target state="translated">增强了查询规划器,以支持对rowid有范围限制的索引查询。</target>
        </trans-unit>
        <trans-unit id="6066357831db7e4ebf2e25439868067d246d8025" translate="yes" xml:space="preserve">
          <source>Enhanced the windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; so that all system calls can be overridden using the xSetSystemCall interface.</source>
          <target state="translated">增强了Windows &lt;a href=&quot;vfs&quot;&gt;VFS，&lt;/a&gt;以便可以使用xSetSystemCall接口覆盖所有系统调用。</target>
        </trans-unit>
        <trans-unit id="cb3a978152b2c95d938f4ec5dfecdfd4dc03a088" translate="yes" xml:space="preserve">
          <source>Enhanced triggers so that they can use &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that exist in schemas other than the schema where the trigger is defined.</source>
          <target state="translated">增强的触发器，以便他们可以使用除定义触发器的模式以外的其他模式中存在的&lt;a href=&quot;vtab#tabfunc2&quot;&gt;表值函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="297f948f999cfb4c21e3fe30f5e217f38826c758" translate="yes" xml:space="preserve">
          <source>Enhancements the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command:</source>
          <target state="translated">增强了&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;命令：</target>
        </trans-unit>
        <trans-unit id="f946c53a255ba7d27e70b7ff3738d27f161850fa" translate="yes" xml:space="preserve">
          <source>Enhancements the command-line shell:</source>
          <target state="translated">增强命令行shell的功能。</target>
        </trans-unit>
        <trans-unit id="e09172df6aacada6ccbcf1a3a11e6a3c3af4636e" translate="yes" xml:space="preserve">
          <source>Enhancements to &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;.</source>
          <target state="translated">解释&lt;a href=&quot;eqp&quot;&gt;查询计划的&lt;/a&gt;增强。</target>
        </trans-unit>
        <trans-unit id="db4d9e44ef71d40ff1e7e4dbe80b15d3513543b3" translate="yes" xml:space="preserve">
          <source>Enhancements to &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt;, so that it generates a faster parser.</source>
          <target state="translated">&lt;a href=&quot;lemon&quot;&gt;Lemon解析器生成器的&lt;/a&gt;增强功能，使其生成更快的解析器。</target>
        </trans-unit>
        <trans-unit id="ef9855917607b6442c695951a3f7754c39d33b47" translate="yes" xml:space="preserve">
          <source>Enhancements to &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; so that they can optionally check just a single attached database instead of all attached databases.</source>
          <target state="translated">对&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA完整性检查&lt;/a&gt;和&lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA快速&lt;/a&gt;检查的增强，以便他们可以选择仅检查单个附加数据库，而不是所有附加数据库。</target>
        </trans-unit>
        <trans-unit id="0e60f213182ea7cd574f070de9a038e0287e1d3a" translate="yes" xml:space="preserve">
          <source>Enhancements to &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; processing that ensure that at least one valid read-mark is available at all times, so that read-only processes can always read the database.</source>
          <target state="translated">对&lt;a href=&quot;wal&quot;&gt;WAL模式&lt;/a&gt;处理的增强，确保始终有至少一个有效的读取标记可用，以便只读进程始终可以读取数据库。</target>
        </trans-unit>
        <trans-unit id="088c949064c93e6690dd186376b133008579ec58" translate="yes" xml:space="preserve">
          <source>Enhancements to FTS4:</source>
          <target state="translated">加强FTS4。</target>
        </trans-unit>
        <trans-unit id="4b227272818268b73b926c2192e43b3603222a58" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; interface:</source>
          <target state="translated">&lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize（）&lt;/a&gt;接口的增强功能：</target>
        </trans-unit>
        <trans-unit id="b9dd3ac79af68e2372047ab33b4b26d154857e4a" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;, mostly to support testing and debugging of the SQLite library itself:</source>
          <target state="translated">对&lt;a href=&quot;cli&quot;&gt;CLI的&lt;/a&gt;增强，主要是为了支持SQLite库本身的测试和调试：</target>
        </trans-unit>
        <trans-unit id="fa6f25098613c466df6cb1b3c3e2f32bf515195d" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;CLI的&lt;/a&gt;增强功能：</target>
        </trans-unit>
        <trans-unit id="9316eb92f3fb8393c8d086dc09173f0ba01a3c1c" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;命令行外壳的&lt;/a&gt;增强功能：</target>
        </trans-unit>
        <trans-unit id="f3b9e87c6fa6f39266403ab6cc48cf4b6737e704" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;floatingpoint#ieee754ext&quot;&gt;ieee754 extension&lt;/a&gt; for working with IEEE 754 binary64 numbers.</source>
          <target state="translated">对&lt;a href=&quot;floatingpoint#ieee754ext&quot;&gt;ieee754扩展的&lt;/a&gt;增强，以使用IEEE 754 binary64数字。</target>
        </trans-unit>
        <trans-unit id="a5c7ab4a0f809431a8ff58a35ffa041e958442f1" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;geopoly&quot;&gt;geopoly&lt;/a&gt; extension:</source>
          <target state="translated">&lt;a href=&quot;geopoly&quot;&gt;地理&lt;/a&gt;扩展的增强功能：</target>
        </trans-unit>
        <trans-unit id="e5b6cb44cb4a567950e71ad422f75b3ca4e22c90" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; so that it creates a smaller and faster SQL parser.</source>
          <target state="translated">对&lt;a href=&quot;lemon&quot;&gt;Lemon解析器生成器&lt;/a&gt;进行了增强，使其创建了更小，更快的SQL解析器。</target>
        </trans-unit>
        <trans-unit id="15944ac14355213e9f3cb2cebd5dc54b91adbbac" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt; for cases when the left-hand side column has numeric affinity.</source>
          <target state="translated">&lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE优化的&lt;/a&gt;增强功能，用于左侧列具有数字亲和力的情况。</target>
        </trans-unit>
        <trans-unit id="adcb27ea2162302878492824ccdd337602297736" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; extension:</source>
          <target state="translated">&lt;a href=&quot;sessionintro&quot;&gt;会话&lt;/a&gt;扩展的增强功能：</target>
        </trans-unit>
        <trans-unit id="08a98f05f116677a58ecae89a193381dca3467a0" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;tclsqlite&quot;&gt;TCL接口的&lt;/a&gt;增强功能：</target>
        </trans-unit>
        <trans-unit id="edf69de137296726150f431f3016d8e1e1082416" translate="yes" xml:space="preserve">
          <source>Enhancements to the query planner:</source>
          <target state="translated">增强了查询规划器的功能。</target>
        </trans-unit>
        <trans-unit id="887cd62dcf1fd561060a7f3820e302dbe0e7e1de" translate="yes" xml:space="preserve">
          <source>Enhancements to the sqlite3_analyzer utility program to provide size information separately for each individual index of a table, in addition to the aggregate size.</source>
          <target state="translated">增强了 sqlite3_analyzer 实用程序,除了提供总大小外,还分别提供表的每个独立索引的大小信息。</target>
        </trans-unit>
        <trans-unit id="d0b79f3e5d56b3b3ee7240cd85a024ed61c576ed" translate="yes" xml:space="preserve">
          <source>Enhancements to the sqlite3_analyzer utility program, including the --pageinfo and --stats options and support for multiplexed databases.</source>
          <target state="translated">增强了 sqlite3_analyzer 实用程序,包括 --pageinfo 和 --stats 选项以及对多路数据库的支持。</target>
        </trans-unit>
        <trans-unit id="37973a2aab5304ee633b9d20aeca0be76434d6ed" translate="yes" xml:space="preserve">
          <source>Enhancements to the test_quota.c extension to support stdio-like interfaces with quotas.</source>
          <target state="translated">增强 test_quota.c 扩展,以支持类似 stdio 的配额接口。</target>
        </trans-unit>
        <trans-unit id="a1ba10f45054081b97f16d5bc6e667a78fce6d45" translate="yes" xml:space="preserve">
          <source>Enhancements to the test_quota.c module so that it can track preexisting files.</source>
          <target state="translated">增强了test_quota.c模块,使其能够跟踪预先存在的文件。</target>
        </trans-unit>
        <trans-unit id="071262c4e43816b952c8af7674854fa203027685" translate="yes" xml:space="preserve">
          <source>Ensure durability following a power loss with &quot;PRAGMA journal_mode=TRUNCATE&quot; by calling fsync() right after truncating the journal file.</source>
          <target state="translated">使用 &quot;PRAGMA journal_mode=TRUNCATE &quot;确保断电后的耐久性,在截断日志文件后立即调用fsync()。</target>
        </trans-unit>
        <trans-unit id="763267566a8b7c92a18ab7a9852c919207037954" translate="yes" xml:space="preserve">
          <source>Ensure that ALTER TABLE modifies table and column names embedded in WITH clauses that are part of views and triggers.</source>
          <target state="translated">确保ALTER TABLE修改嵌入在WITH子句中的表和列名,这些子句是视图和触发器的一部分。</target>
        </trans-unit>
        <trans-unit id="6f4e25c9d19972ec4e16af218b9ac640575e4282" translate="yes" xml:space="preserve">
          <source>Ensure that floating point values are preserved exactly when reconstructing a database from the output of the &quot;.dump&quot; command of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;从命令行shell&lt;/a&gt;的&amp;ldquo; .dump&amp;rdquo;命令的输出重建数据库时，请确保精确保留浮点值。</target>
        </trans-unit>
        <trans-unit id="f0f3d6acbe6809d0d4b5ba59e3106dfa722b6856" translate="yes" xml:space="preserve">
          <source>Ensure that indexed expressions with collating sequences are handled correctly. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/eb703ba7b50c1a5&quot;&gt;eb703ba7b50c1a5&lt;/a&gt;.</source>
          <target state="translated">确保带有整理序列的索引表达式已正确处理。修复票务&lt;a href=&quot;https://www.sqlite.org/src/info/eb703ba7b50c1a5&quot;&gt;eb703ba7b50c1a5&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="320fb77964ce8dd238dcf51a0d55555931872f7c" translate="yes" xml:space="preserve">
          <source>Ensure that prepared statements automatically reset on extended error codes of SQLITE_BUSY and SQLITE_LOCKED even when compiled using &lt;a href=&quot;compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt;.</source>
          <target state="translated">即使使用&lt;a href=&quot;compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET进行&lt;/a&gt;编译，也要确保准备好的语句在SQLITE_BUSY和SQLITE_LOCKED的扩展错误代码上自动重置。</target>
        </trans-unit>
        <trans-unit id="73ff9e87e31a6b30accfec1ac5b07289b8ed1a4a" translate="yes" xml:space="preserve">
          <source>Ensure that the &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; counters in the sqlite_sequence table are initialized doing &quot;Xfer Optimization&quot; on &quot;INSERT ... SELECT&quot; statements. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7b3328086a5c116c&quot;&gt;7b3328086a5c116c&lt;/a&gt;.</source>
          <target state="translated">确保通过对&amp;ldquo; INSERT ... SELECT&amp;rdquo;语句执行&amp;ldquo; Xfer Optimization&amp;rdquo;来初始化sqlite_sequence表中的&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;计数器。修复票&lt;a href=&quot;https://www.sqlite.org/src/info/7b3328086a5c116c&quot;&gt;7b3328086a5c116c&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1edcdd81c8138145ea48433a6dac68321ba6e0c9" translate="yes" xml:space="preserve">
          <source>Ensure that the &lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; interface can correctly handle short rows. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/e6e962d6b0f06f46e&quot;&gt;e6e962d6b0f06f46e&lt;/a&gt;.</source>
          <target state="translated">确保&lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;接口可以正确处理短行。修复票证&lt;a href=&quot;https://www.sqlite.org/src/info/e6e962d6b0f06f46e&quot;&gt;e6e962d6b0f06f46e&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f2b0dfe3853d12157319b6b0f40a3e7dfe9eef04" translate="yes" xml:space="preserve">
          <source>Ensure that the query planner knows that any column of a &lt;a href=&quot;optoverview#flattening&quot;&gt;flattened&lt;/a&gt; LEFT JOIN can be NULL even if that column is labeled with &quot;NOT NULL&quot;. Fix for ticket &lt;a href=&quot;https://sqlite.org/src/info/892fc34f173e99d8&quot;&gt;892fc34f173e99d8&lt;/a&gt;.</source>
          <target state="translated">确保查询计划程序知道&lt;a href=&quot;optoverview#flattening&quot;&gt;拼合的&lt;/a&gt; LEFT JOIN的任何列都可以为NULL，即使该列标记为&amp;ldquo; NOT NULL&amp;rdquo;。修复票证&lt;a href=&quot;https://sqlite.org/src/info/892fc34f173e99d8&quot;&gt;892fc34f173e99d8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d45306d706d54fdd9fd4abd095a83e5c593f770" translate="yes" xml:space="preserve">
          <source>Ensure that the query planner never tries to use a self-made transient index in place of a schema-defined index.</source>
          <target state="translated">确保查询规划器永远不会尝试使用自制的瞬时索引来代替模式定义的索引。</target>
        </trans-unit>
        <trans-unit id="c4719004d8e5511993396b7647b091764d35ec35" translate="yes" xml:space="preserve">
          <source>Ensuring that</source>
          <target state="translated">确保</target>
        </trans-unit>
        <trans-unit id="8b17ecadc249ae5820d4616f49592537cf85eaca" translate="yes" xml:space="preserve">
          <source>Enter SQL commands at the prompt to create and populate the new database.</source>
          <target state="translated">在提示符下输入SQL命令,创建并填充新的数据库。</target>
        </trans-unit>
        <trans-unit id="083f743b36c02cef28d51a51219ba95b2ec6026d" translate="yes" xml:space="preserve">
          <source>Enterprise-class client/server SQL database engines do not normally make this guarantee. In client/server SQL database engines, the server keeps track of statistics on the sizes of tables and on the quality of indexes and the query planner uses those statistics to help select the best plans. As content is added, deleted, or changed in the database, the statistics will evolve and may cause the query planner to begin using a different query plan for some particular query. Usually the new plan will be better for the evolving structure of the data. But sometimes the new query plan will cause a performance reduction. With a client/server database engine, there is typically a Database Administrator (DBA) on hand to deal with these rare problems as they come up. But DBAs are not available to fix problems in an embedded database like SQLite, and hence SQLite is careful to ensure that plans do not change unexpectedly after deployment.</source>
          <target state="translated">企业级客户机/服务器SQL数据库引擎通常不做这种保证。在客户机/服务器SQL数据库引擎中,服务器跟踪统计表的大小和索引的质量,查询规划器使用这些统计数据来帮助选择最佳计划。随着数据库中内容的添加、删除或更改,统计数据将发生变化,可能会导致查询规划器开始对某些特定查询使用不同的查询计划。通常新的计划会更好地适应不断发展的数据结构。但有时新的查询计划会导致性能降低。对于客户/服务器数据库引擎,通常会有一个数据库管理员(DBA)在现场处理这些罕见的问题。但是在像SQLite这样的嵌入式数据库中,DBA是无法解决问题的,因此SQLite会很小心地确保计划在部署后不会发生意外变化。</target>
        </trans-unit>
        <trans-unit id="016d284bc7fd185fb86cbef4e6f410ad531ec41f" translate="yes" xml:space="preserve">
          <source>Entries may be added to a zip archive by inserting new rows. The easiest way to do this is to specify values for the &quot;name&quot; and &quot;data&quot; columns only and have zipfile fill in sensible defaults for other fields. To insert a directory into the archive, set the &quot;data&quot; column to NULL. For example, to add the directory &quot;dir1&quot; and the file &quot;m.txt&quot; containing the text &quot;abcdefghi&quot; to zip archive &quot;test.zip&quot;:</source>
          <target state="translated">通过插入新的行,可以将条目添加到 zip 档案中。最简单的方法是只指定 &quot;name &quot;和 &quot;data &quot;列的值,并让zipfile为其他字段填写合理的默认值。要在存档中插入一个目录,将 &quot;data &quot;列设置为NULL。例如,将目录 &quot;dir1 &quot;和包含文本 &quot;abcdefghi &quot;的文件 &quot;m.txt &quot;添加到压缩包 &quot;test.zip &quot;中。</target>
        </trans-unit>
        <trans-unit id="e2f64a45118887196b8716103b9556bdce2656b8" translate="yes" xml:space="preserve">
          <source>Entries within a doclist are sorted by docid. Positions within a doclist entry are stored in ascending order.</source>
          <target state="translated">doclist中的条目是按docid排序的。doclist条目中的位置按升序存储。</target>
        </trans-unit>
        <trans-unit id="8bffcbc21c3bf69becb564637d592afa3a71b0f7" translate="yes" xml:space="preserve">
          <source>Eponymous virtual table</source>
          <target state="translated">同名虚拟桌</target>
        </trans-unit>
        <trans-unit id="afcfba63ae8c7c116df2f46471e75a3359724931" translate="yes" xml:space="preserve">
          <source>Eq</source>
          <target state="translated">Eq</target>
        </trans-unit>
        <trans-unit id="4b4a2f957af622a456d578794d868743c5030e6f" translate="yes" xml:space="preserve">
          <source>Equivalent sqlite3.exe Command</source>
          <target state="translated">相当于 sqlite3.exe 命令。</target>
        </trans-unit>
        <trans-unit id="c73f93f4b9a02f4e5a949fd11052e3a166c6f2ac" translate="yes" xml:space="preserve">
          <source>Error Codes And Messages</source>
          <target state="translated">错误代码和信息</target>
        </trans-unit>
        <trans-unit id="7fc353a0378a6af6e63cb4e746bbbbd0e56d46cc" translate="yes" xml:space="preserve">
          <source>Error Logging Interface</source>
          <target state="translated">错误记录接口</target>
        </trans-unit>
        <trans-unit id="e124b3535d5c4804fddcec1bfc75b893589b726b" translate="yes" xml:space="preserve">
          <source>Errors related to attempting to retrieve column values other than docid are runtime errors that occur within sqlite3_step(). In some cases, for example if the MATCH expression in a SELECT query matches zero rows, there may be no error at all even if a statement does refer to column values other than docid.</source>
          <target state="translated">与试图检索docid以外的列值有关的错误是发生在sqlite3_step()中的运行时错误。在某些情况下,例如,如果SELECT查询中的MATCH表达式匹配的记录数为零,那么即使一个语句引用了docid以外的列值,也可能不会出现错误。</target>
        </trans-unit>
        <trans-unit id="2037e33c6466adf8969b72c11fda6491583b0bfa" translate="yes" xml:space="preserve">
          <source>Errors returned by &quot;close&quot; invocations are always ignored.</source>
          <target state="translated">由 &quot;close &quot;调用返回的错误总是被忽略。</target>
        </trans-unit>
        <trans-unit id="3ba0ca62e050a94c881b9cbcdd137fb7152c40f3" translate="yes" xml:space="preserve">
          <source>Escape control characters in JSON strings. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/ad2559db380abf8&quot;&gt;ad2559db380abf8&lt;/a&gt;.</source>
          <target state="translated">JSON字符串中的转义控制字符。已修复票&lt;a href=&quot;https://www.sqlite.org/src/info/ad2559db380abf8&quot;&gt;ad2559db380abf8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1cb7d33bba7989feceb4f470ecd1849be76ca550" translate="yes" xml:space="preserve">
          <source>Establish a shared lock on the database file using the SQLite API (i.e. the shell tool).</source>
          <target state="translated">使用SQLite API(即shell工具)在数据库文件上建立共享锁。</target>
        </trans-unit>
        <trans-unit id="acdfd966a90117b3a07f2283d0066679d289a192" translate="yes" xml:space="preserve">
          <source>Established a Git mirror of the offical SQLite source tree. The canonical sources for SQLite are maintained using the &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt; at &lt;a href=&quot;https://sqlite.org/src&quot;&gt;https://sqlite.org/src&lt;/a&gt;. The Git mirror can be seen at &lt;a href=&quot;https://github.com/sqlite/sqlite&quot;&gt;https://github.com/sqlite/sqlite&lt;/a&gt;.</source>
          <target state="translated">建立了官方SQLite源树的Git镜像。SQLite的规范源使用的是保持&lt;a href=&quot;https://fossil-scm.org/&quot;&gt;化石DVCS&lt;/a&gt;在&lt;a href=&quot;https://sqlite.org/src&quot;&gt;https://sqlite.org/src&lt;/a&gt;。可以在&lt;a href=&quot;https://github.com/sqlite/sqlite&quot;&gt;https://github.com/sqlite/sqlite&lt;/a&gt;上看到Git镜像。</target>
        </trans-unit>
        <trans-unit id="bfac7c251d7e73e29a463cec3912b52bd890b9a8" translate="yes" xml:space="preserve">
          <source>Estimate the number of rows in the table P1. &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; to P2 if that estimate is less than approximately 2**(0.1*P3).</source>
          <target state="translated">估计表P1中的行数。如果该估计值小于约2 **（0.1 * P3），则&lt;a href=&quot;opcode#Jump&quot;&gt;跳至&lt;/a&gt; P2。</target>
        </trans-unit>
        <trans-unit id="f07e6ba2d9a77c57620b0b92e2928b26dca79a5c" translate="yes" xml:space="preserve">
          <source>Estimate the sizes of table and index rows and use the smallest applicable B-Tree for full scans and &quot;count(*)&quot; operations.</source>
          <target state="translated">估算表和索引行的大小,并使用最小的适用B树进行全扫描和 &quot;count(*)&quot;操作。</target>
        </trans-unit>
        <trans-unit id="b8465fee9c60fa18c66485376de57ad47eb492b1" translate="yes" xml:space="preserve">
          <source>Evaluate An SQL Statement</source>
          <target state="translated">评估一条SQL语句</target>
        </trans-unit>
        <trans-unit id="494757b93d645c3ec03e2cb39c698d02501c9269" translate="yes" xml:space="preserve">
          <source>Evaluate WHERE clause constraints involving correlated subqueries last, in the hope that they never have be evaluated at all.</source>
          <target state="translated">最后评估涉及相关子查询的WHERE子句约束,希望它们从未被评估过。</target>
        </trans-unit>
        <trans-unit id="f5f8716393fff4c33fd231cf4a1b3dfd35e3ce79" translate="yes" xml:space="preserve">
          <source>Evaluate terms of the WHERE clause that only involve columns from the first table. If any term is false (meaning that the whole WHERE clause must be false) then skip the rest of this loop and continue to the next record.</source>
          <target state="translated">评估WHERE子句中只涉及第一个表中的列的条款。如果任何术语是false(意味着整个WHERE子句必须是false),那么跳过这个循环的其余部分,继续下一条记录。</target>
        </trans-unit>
        <trans-unit id="e98cbf4cf1877f0ce5b5cb8101d45d36a7f1c8d6" translate="yes" xml:space="preserve">
          <source>Evaluate the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; by calling &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; one or more times.</source>
          <target state="translated">通过调用&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;一次或多次来评估&lt;a href=&quot;c3ref/stmt&quot;&gt;准备好的语句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="afc24d20b1189859f163127fa057eee2672ebd26" translate="yes" xml:space="preserve">
          <source>Even after the original data of a database page has been written into the journal file using calls to the journal file file-handle xWrite method (section</source>
          <target state="translated">即使在使用调用日志文件文件柄xWrite方法将数据库页面的原始数据写入日志文件后,也是如此(节</target>
        </trans-unit>
        <trans-unit id="5499799ae4809c21043cab7ce18584b7a12c2dc6" translate="yes" xml:space="preserve">
          <source>Even if an application or system failure does not occur while a</source>
          <target state="translated">即使应用程序或系统故障没有发生,而一个</target>
        </trans-unit>
        <trans-unit id="02ed13066a4e0b144f34e2ad6070e86a20374570" translate="yes" xml:space="preserve">
          <source>Even if the application does not deliberately accept database files from untrusted sources, beware of attacks in which a local database file is altered. For best security, any database file which might have ever been writable by an agent in a different security domain should be treated as suspect.</source>
          <target state="translated">即使应用程序不故意接受来自不受信任来源的数据库文件,也要小心本地数据库文件被更改的攻击。为了达到最佳的安全性,任何可能曾被不同安全域的代理写入的数据库文件都应被视为可疑文件。</target>
        </trans-unit>
        <trans-unit id="680fadd60094a533809d5b7446aadfd1591e54a1" translate="yes" xml:space="preserve">
          <source>Even if the application does not deliberately accept database files from untrusted sources, beware of attacks in which a local database file is surreptitiously altered to contain harmful content.</source>
          <target state="translated">即使应用程序没有刻意接受来自不受信任来源的数据库文件,也要小心本地数据库文件被暗中修改为包含有害内容的攻击。</target>
        </trans-unit>
        <trans-unit id="c9ba37d0d3bee815cbbaa36b0c20151324c7ee1f" translate="yes" xml:space="preserve">
          <source>Even if this function returns zero, it is possible that calling &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; on the session handle may still return a changeset that contains no changes. This can happen when a row in an attached table is modified and then later on the original values are restored. However, if this function returns non-zero, then it is guaranteed that a call to sqlite3session_changeset() will return a changeset containing zero changes.</source>
          <target state="translated">即使此函数返回零，也有可能在会话句柄上调用&lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset（）&lt;/a&gt;可能仍返回不包含任何更改的更改集。当修改附加表中的一行，然后在以后还原原始值时，可能会发生这种情况。但是，如果此函数返回非零值，则可以确保对sqlite3session_changeset（）的调用将返回包含零个更改的更改集。</target>
        </trans-unit>
        <trans-unit id="50ed987259f75ac65d7652aac78952559c72c7f6" translate="yes" xml:space="preserve">
          <source>Even if this function returns zero, it is possible that calling &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; on the session handle may still return a changeset that contains no changes. This can happen when a row in an attached table is modified and then later on the original values are restored. However, if this function returns non-zero, then it is guaranteed that a call to sqlite3session_changeset() will return a changeset containing zero changes.</source>
          <target state="translated">即使此函数返回零，也有可能在会话句柄上调用&lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset（）&lt;/a&gt;可能仍返回不包含任何更改的更改集。当修改附加表中的一行，然后在以后还原原始值时，可能会发生这种情况。但是，如果此函数返回非零值，则可以确保对sqlite3session_changeset（）的调用将返回包含零个更改的更改集。</target>
        </trans-unit>
        <trans-unit id="400a8e0a43afcabf1ad09a38d392479429277735" translate="yes" xml:space="preserve">
          <source>Even in the JOIN form, the query can be made clearer through the use of row values:</source>
          <target state="translated">即使在JOIN形式下,也可以通过使用行值使查询更加清晰。</target>
        </trans-unit>
        <trans-unit id="dc5632548c0bc2270c52cd3517d4c2d3312ffda6" translate="yes" xml:space="preserve">
          <source>Even though SQLite allows the datatype to be omitted, it is still a good idea to include it in your CREATE TABLE statements, since the data type often serves as a good hint to other programmers about what you intend to put in the column. And if you ever port your code to another database engine, that other engine will probably require a datatype of some kind. SQLite accepts all the usual datatypes. For example:</source>
          <target state="translated">尽管SQLite允许省略数据类型,但在CREATE TABLE语句中包含它仍然是一个好主意,因为数据类型经常作为一个很好的提示给其他程序员,告诉他们你打算在列中放入什么。如果你把你的代码移植到另一个数据库引擎中,那个引擎可能会需要某种数据类型。SQLite接受所有常用的数据类型。比如说</target>
        </trans-unit>
        <trans-unit id="0ba77bb0cea9f5158d237371e94228e6f6766570" translate="yes" xml:space="preserve">
          <source>Even though a disk file is allocated for each temporary database, in practice the temporary database usually resides in the in-memory pager cache and hence is very little difference between a pure in-memory database created by &quot;:memory:&quot; and a temporary database created by an empty filename. The sole difference is that a &quot;:memory:&quot; database must remain in memory at all times whereas parts of a temporary database might be flushed to disk if database becomes large or if SQLite comes under memory pressure.</source>
          <target state="translated">尽管为每个临时数据库分配了一个磁盘文件,但在实践中,临时数据库通常驻留在内存中的分页缓存中,因此,由&quot;:memory:&quot;创建的纯内存数据库和由空文件名创建的临时数据库之间几乎没有区别。唯一的区别是,&quot;:memory:&quot;数据库必须始终保持在内存中,而临时数据库的部分内容可能会在数据库变大或SQLite面临内存压力时被冲到磁盘上。</target>
        </trans-unit>
        <trans-unit id="30543192e192dd4d27222f9a28b926a35b6f7b01" translate="yes" xml:space="preserve">
          <source>Even though it is possible to open a read-only WAL-mode database, it is good practice to converted to &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=DELETE&lt;/a&gt; prior to burning an SQLite database image onto read-only media.</source>
          <target state="translated">即使可以打开只读的WAL模式数据库，在将SQLite数据库映像刻录到只读介质上之前，最好将其转换为&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = DELETE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c6df707f631d9b02f87ed26337109bf5dac9246" translate="yes" xml:space="preserve">
          <source>Even though it may not be possible to attribute the row to a specific database table, it may be part of a tree structure within the database file. In this case, the root page number of that tree structure is stored in this column. Or, if the page the row was found on is not part of a tree structure, this column stores a copy of the value in column &quot;pgno&quot; - the page number of the page the row was found on. In many, although not all, cases, all rows in the lost_and_found table with the same value in this column belong to the same table.</source>
          <target state="translated">即使不可能将该行归属于某个特定的数据库表,它也可能是数据库文件中树形结构的一部分。在这种情况下,树形结构的根号就会存储在这一列中。或者,如果记录所在的页面不是树结构的一部分,那么这一列将存储 &quot;pgno &quot;列中的值的副本--记录所在页面的页码。在很多情况下,虽然不是所有情况,但是在lost_and_found表中,所有在这一列中具有相同值的行都属于同一个表。</target>
        </trans-unit>
        <trans-unit id="1d9b26bf7bc27f4c82b4fef5ddd5b50d847ddf5d" translate="yes" xml:space="preserve">
          <source>Even though open-source users do not have direct access to TH3, all users of SQLite benefit from TH3 indirectly since each version of SQLite is validated running TH3 on multiple platforms (Linux, Windows, WinRT, Mac, OpenBSD) prior to release. So anyone using an official release of SQLite can deploy their application with the confidence of knowing that it has been tested using TH3. They simply cannot rerun those tests themselves without purchasing a TH3 license.</source>
          <target state="translated">尽管开源用户不能直接访问TH3,但所有SQLite用户都能间接从TH3中受益,因为每个版本的SQLite在发布之前都会在多个平台(Linux、Windows、WinRT、Mac、OpenBSD)上运行TH3进行验证。因此,任何使用SQLite官方版本的人都可以放心地部署他们的应用程序,因为他们知道该应用程序已经使用TH3进行了测试。如果没有购买TH3许可证,他们根本无法自己重新运行这些测试。</target>
        </trans-unit>
        <trans-unit id="022ac40cfda55e83a99de9e911e78bfc09ab9640" translate="yes" xml:space="preserve">
          <source>Even though sqlite_stat1 does not have a PRIMARY KEY, changes are recorded for it as if the PRIMARY KEY is (tbl,idx). Additionally, changes are recorded for rows for which (idx IS NULL) is true. However, for such rows a zero-length blob (SQL value X'') is stored in the changeset or patchset instead of a NULL value. This allows such changesets to be manipulated by legacy implementations of sqlite3changeset_invert(), concat() and similar.</source>
          <target state="translated">即使sqlite_stat1没有PRIMARY KEY,但是如果PRIMARY KEY是(tbl,idx),那么就会记录它的变化。此外,对于那些(idx IS NULL)为真的记录,也会记录更改。然而,对于这样的行,一个零长度的blob(SQL值X'')被存储在变化集或补丁集中,而不是一个NULL值。这使得这样的变化集可以被sqlite3changeset_invert(),concat()和类似的传统实现所操作。</target>
        </trans-unit>
        <trans-unit id="9461afee379ce7062d22cecc827bf8826de4bdca" translate="yes" xml:space="preserve">
          <source>Even though the &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; function only allows the caller to specify a single user-context pointer, an unlock-notify callback is passed an array of such context pointers. This is because if when a blocking connection concludes its transaction, if there is more than one unlock-notify registered to call the same C function, the context-pointers are marshaled into an array and a single callback issued. If each thread were assigned a priority, then instead of just signaling the threads in arbitrary order as this implementation does, higher priority threads could be signaled before lower priority threads.</source>
          <target state="translated">即使&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;函数仅允许调用方指定单个用户上下文指针，解锁通知回调仍会传递此类上下文指针的数组。这是因为，当阻塞连接结束其事务时，如果注册了多个调用同一C函数的解锁通知，则上下文指针将编组到数组中，并发出单个回调。如果为每个线程分配了优先级，则不仅可以像此实现那样以任意顺序发信号通知线程，还可以在低优先级线程之前发信号通知高优先级线程。</target>
        </trans-unit>
        <trans-unit id="ef242512e741cb13f0a9ba0e8d336abee8249668" translate="yes" xml:space="preserve">
          <source>Even though the database</source>
          <target state="translated">尽管数据库</target>
        </trans-unit>
        <trans-unit id="31dfaf84589e564bfee1b65ff3c5d7573077d711" translate="yes" xml:space="preserve">
          <source>Even though the function prototype shows that xEntryPoint() takes no arguments and returns void, SQLite invokes xEntryPoint() with three arguments and expects an integer result as if the signature of the entry point where as follows:</source>
          <target state="translated">尽管函数原型显示xEntryPoint()不接受任何参数并返回void,但SQLite调用xEntryPoint()时有三个参数,并期望得到一个整数结果,就像进入点的签名一样,如下所示。</target>
        </trans-unit>
        <trans-unit id="4b42b7e22dd2091056535ea5f248d0c4a2e55603" translate="yes" xml:space="preserve">
          <source>Even when the SQLITE_ENABLE_SORTER_REFERENCES compile-time option is on, sorter references are still disabled by default. To use sorter references, the application must set a sorter reference size threshold using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsorterrefsize&quot;&gt;SQLITE_CONFIG_SORTERREF_SIZE&lt;/a&gt;) interface at start-time.</source>
          <target state="translated">即使启用了SQLITE_ENABLE_SORTER_REFERENCES编译时选项，默认情况下仍禁用分类器引用。要使用分类器引用，应用程序必须在启动时使用&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsorterrefsize&quot;&gt;SQLITE_CONFIG_SORTERREF_SIZE&lt;/a&gt;）接口设置分类器引用大小阈值。</target>
        </trans-unit>
        <trans-unit id="c9faf17aed220247be5c3b4b3c5ce1890f9062f4" translate="yes" xml:space="preserve">
          <source>Eventually, the writing process will want to update the database file, either because its memory cache has filled up or because it is ready to commit its changes. Before this happens, the writer must make sure no other process is reading the database and that the rollback journal data is safely on the disk surface so that it can be used to rollback incomplete changes in the event of a power failure. The steps are as follows:</source>
          <target state="translated">最终,写入过程会想要更新数据库文件,可能是因为它的内存缓存已满,也可能是因为它准备好提交其更改。在这之前,写入者必须确保没有其他进程在读取数据库,并且回滚日志数据安全地保存在磁盘表面,以便在断电时可以用来回滚不完整的更改。步骤如下。</target>
        </trans-unit>
        <trans-unit id="89e7b1ca2d523bd7c0cba8f71e13245a8608c1a8" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt; implementation uses a subclass of the following structure to describe cursors that point into the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; and are used to loop through the virtual table. Cursors are created using the &lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt; method of the module and are destroyed by the &lt;a href=&quot;vtab#xclose&quot;&gt;xClose&lt;/a&gt; method. Cursors are used by the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;, &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt;, &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt;, &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;, and &lt;a href=&quot;vtab#xrowid&quot;&gt;xRowid&lt;/a&gt; methods of the module. Each module implementation will define the content of a cursor structure to suit its own needs.</source>
          <target state="translated">每个&lt;a href=&quot;#sqlite3_module&quot;&gt;虚拟表模块&lt;/a&gt;实现都使用以下结构的子类来描述指向&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;并用于遍历虚拟表的游标。游标使用所创建的&lt;a href=&quot;vtab#xopen&quot;&gt;XOPEN&lt;/a&gt;模块的方法和由所述被破坏&lt;a href=&quot;vtab#xclose&quot;&gt;xClose&lt;/a&gt;方法。模块的&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;，&lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt;，&lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt;，&lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;和&lt;a href=&quot;vtab#xrowid&quot;&gt;xRowid&lt;/a&gt;方法使用游标。每个模块实现都将定义游标结构的内容以适合其自身的需求。</target>
        </trans-unit>
        <trans-unit id="736f9f0cc1331d7eb8b3f3146d63e9ed826e6bf1" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt; implementation uses a subclass of this object to describe a particular instance of the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;. Each subclass will be tailored to the specific needs of the module implementation. The purpose of this superclass is to define certain fields that are common to all module implementations.</source>
          <target state="translated">每个&lt;a href=&quot;#sqlite3_module&quot;&gt;虚拟表模块&lt;/a&gt;实现都使用此对象的子类来描述&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;的特定实例。每个子类将根据模块实现的特定需求进行定制。该超类的目的是定义所有模块实现通用的某些字段。</target>
        </trans-unit>
        <trans-unit id="97f4ee6ffc1e6119472d334b08a9eb970b87d195" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt; implementation uses a subclass of the following structure to describe cursors that point into the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; and are used to loop through the virtual table. Cursors are created using the &lt;a href=&quot;../vtab#xopen&quot;&gt;xOpen&lt;/a&gt; method of the module and are destroyed by the &lt;a href=&quot;../vtab#xclose&quot;&gt;xClose&lt;/a&gt; method. Cursors are used by the &lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;, &lt;a href=&quot;../vtab#xnext&quot;&gt;xNext&lt;/a&gt;, &lt;a href=&quot;../vtab#xeof&quot;&gt;xEof&lt;/a&gt;, &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;, and &lt;a href=&quot;../vtab#xrowid&quot;&gt;xRowid&lt;/a&gt; methods of the module. Each module implementation will define the content of a cursor structure to suit its own needs.</source>
          <target state="translated">每个&lt;a href=&quot;module&quot;&gt;虚拟表模块&lt;/a&gt;实现都使用以下结构的子类来描述指向&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;并用于遍历虚拟表的游标。游标使用所创建的&lt;a href=&quot;../vtab#xopen&quot;&gt;XOPEN&lt;/a&gt;模块的方法和由所述被破坏&lt;a href=&quot;../vtab#xclose&quot;&gt;xClose&lt;/a&gt;方法。模块的&lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;，&lt;a href=&quot;../vtab#xnext&quot;&gt;xNext&lt;/a&gt;，&lt;a href=&quot;../vtab#xeof&quot;&gt;xEof&lt;/a&gt;，&lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;和&lt;a href=&quot;../vtab#xrowid&quot;&gt;xRowid&lt;/a&gt;方法使用游标。每个模块实现都将定义游标结构的内容以适合其自身的需求。</target>
        </trans-unit>
        <trans-unit id="4a7edaa14334e8a1c0b858598b1fb6dee8c4645f" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt; implementation uses a subclass of this object to describe a particular instance of the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;. Each subclass will be tailored to the specific needs of the module implementation. The purpose of this superclass is to define certain fields that are common to all module implementations.</source>
          <target state="translated">每个&lt;a href=&quot;module&quot;&gt;虚拟表模块&lt;/a&gt;实现都使用此对象的子类来描述&lt;a href=&quot;../vtab&quot;&gt;虚拟表&lt;/a&gt;的特定实例。每个子类将根据模块实现的特定需求进行定制。该超类的目的是定义所有模块实现通用的某些字段。</target>
        </trans-unit>
        <trans-unit id="5f5bf4a9e3a3b1713480df787f65c0a1a83ce231" translate="yes" xml:space="preserve">
          <source>Every CREATE TABLE statement must specify a name for the new table. Table names that begin with &quot;sqlite_&quot; are reserved for internal use. It is an error to attempt to create a table with a name that starts with &quot;sqlite_&quot;.</source>
          <target state="translated">每一条CREATE TABLE语句都必须为新表指定一个名称。以 &quot;sqlite_&quot;开头的表名是保留给内部使用的。试图创建一个名称以 &quot;sqlite_&quot;开头的表是错误的。</target>
        </trans-unit>
        <trans-unit id="c09016ba5ad82dc79c272414a45cdfd7263b163c" translate="yes" xml:space="preserve">
          <source>Every FTS table has a &lt;a href=&quot;vtab#hiddencol&quot; id=&quot;hiddencol&quot;&gt;hidden column&lt;/a&gt; with the same name as the table itself. The value contained in each row for the hidden column is a blob that is only useful as the left operand of a &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH&lt;/a&gt; operator, or as the left-most argument to one of the &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt;.</source>
          <target state="translated">每个FTS表都有一个&lt;a href=&quot;vtab#hiddencol&quot; id=&quot;hiddencol&quot;&gt;隐藏的列&lt;/a&gt;，其名称与表本身相同。隐藏列的每一行中包含的值是一个Blob，仅可用作&lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH&lt;/a&gt;运算符的左操作数或&lt;a href=&quot;fts3#snippet&quot;&gt;FTS辅助功能&lt;/a&gt;之一的最左参数。</target>
        </trans-unit>
        <trans-unit id="993c036bb5f364557a67f157a0c471a9889968ba" translate="yes" xml:space="preserve">
          <source>Every SQL database engine compiles each SQL statement into some kind of internal data structure which is then used to carry out the work of the statement. But in most SQL engines that internal data structure is a complex web of interlinked structures and objects. In SQLite, the compiled form of statements is a short program in a machine-language like representation. Users of the database can view this &lt;a href=&quot;opcode&quot;&gt;virtual machine language&lt;/a&gt; by prepending the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; keyword to a query.</source>
          <target state="translated">每个SQL数据库引擎都会将每个SQL语句编译为某种内部数据结构，然后将其用于执行该语句的工作。但是在大多数SQL引擎中，内部数据结构是一个由相互链接的结构和对象组成的复杂网络。在SQLite中，语句的编译形式是机器语言（如表示形式）中的简短程序。数据库用户可以通过在查询之前添加&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;关键字来查看此&lt;a href=&quot;opcode&quot;&gt;虚拟机语言&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="127b4b3b406ae503f3997bc734ac5e49c93499f4" translate="yes" xml:space="preserve">
          <source>Every SQL statement that SQLite interprets results in a program for the virtual machine. But if the SQL statement begins with the keyword &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; the virtual machine will not execute the program. Instead, the instructions of the program will be returned, one instruction per row, like a query result. This feature is useful for debugging and for learning how the virtual machine operates. For example:</source>
          <target state="translated">SQLite解释的每个SQL语句都会为虚拟机生成一个程序。但是，如果SQL语句以关键字&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;开头，则虚拟机将不会执行该程序。而是返回程序的指令，每行一条指令，如查询结果。此功能对于调试和了解虚拟机的运行方式很有用。例如：</target>
        </trans-unit>
        <trans-unit id="c76ae55ded832cccc106e5cddd7373805f7aff24" translate="yes" xml:space="preserve">
          <source>Every SQLite database contains a single &quot;schema table&quot; that stores the schema for that database. The schema for a database is a description of all of the other tables, indexes, triggers, and views that are contained within the database. The schema table looks like this:</source>
          <target state="translated">每个SQLite数据库都包含一个 &quot;模式表&quot;,该表存储了该数据库的模式。数据库的模式是对数据库中包含的所有其他表、索引、触发器和视图的描述。模式表的样子是这样的。</target>
        </trans-unit>
        <trans-unit id="05725310bea32a87080c57a7b88490274c131486" translate="yes" xml:space="preserve">
          <source>Every WITHOUT ROWID table must have a &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;. An error is raised if a CREATE TABLE statement with the WITHOUT ROWID clause lacks a PRIMARY KEY.</source>
          <target state="translated">每个WITHOUT ROWID表都必须具有&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;。如果带有WITHOUT ROWID子句的CREATE TABLE语句缺少PRIMARY KEY，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="a2a07182d50aca4f020b64628bbefdfb26b38c35" translate="yes" xml:space="preserve">
          <source>Every argv entry will have a non-NULL value in C but may contain the SQL value NULL. In other words, it is always true that &lt;code&gt;argv[i]!=0&lt;/code&gt; for &lt;b&gt;i&lt;/b&gt; between 0 and &lt;code&gt;argc-1&lt;/code&gt;. However, it might be the case that &lt;code&gt;sqlite3_value_type(argv[i])==SQLITE_NULL&lt;/code&gt;.</source>
          <target state="translated">每个argv条目在C语言中都有一个非NULL值，但可能包含SQL值NULL。换句话说，它始终是真的 &lt;code&gt;argv[i]!=0&lt;/code&gt; 为&lt;b&gt;我&lt;/b&gt;介于0和 &lt;code&gt;argc-1&lt;/code&gt; 。但是， &lt;code&gt;sqlite3_value_type(argv[i])==SQLITE_NULL&lt;/code&gt; 可能是这种情况。</target>
        </trans-unit>
        <trans-unit id="32f0b85ad6b7e5f1d163dd080cc52ed9499f5b4a" translate="yes" xml:space="preserve">
          <source>Every b-tree page has at most one parent b-tree page. A b-tree page without a parent is called a root page. A root b-tree page together with the closure of its children form a complete b-tree. It is possible (and in fact rather common) to have a complete b-tree that consists of a single page that is both a leaf and the root. Because there are pointers from parents to children, every page of a complete b-tree can be located if only the root page is known. Hence, b-trees are identified by their root page number.</source>
          <target state="translated">每个b-tree页面最多只有一个父b-tree页面。没有父页的b树页称为根页。一个b树根页和它的子页一起构成一个完整的b树。一个完整的b树是有可能的(事实上也是很常见的),它由一个既是叶子又是根的页面组成。因为有从父页到子页的指针,所以如果只知道根页,就可以找到完整b树的每一页。因此,b树由其根页号来识别。</target>
        </trans-unit>
        <trans-unit id="55a99fde5c029672563046825e6673a5103f75ad" translate="yes" xml:space="preserve">
          <source>Every bytecode program has a fixed (but potentially large) number of registers. A single register can hold a variety of objects:</source>
          <target state="translated">每个字节码程序都有一个固定的(但可能很大的)寄存器数量。一个寄存器可以容纳各种对象。</target>
        </trans-unit>
        <trans-unit id="87fc7f1f92913eaea5a702a31bf26215c9004f47" translate="yes" xml:space="preserve">
          <source>Every column of every table has an associated collating function. If no collating function is explicitly defined, then the collating function defaults to BINARY. The COLLATE clause of the &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definition&lt;/a&gt; is used to define alternative collating functions for a column.</source>
          <target state="translated">每个表的每一列都有一个关联的整理功能。如果未显式定义整理函数，则整理函数默认为BINARY。&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;列定义&lt;/a&gt;的COLLATE子句用于定义列的替代整理功能。</target>
        </trans-unit>
        <trans-unit id="3214d30b9335d3698a80d09df52d21c7f7db6f83" translate="yes" xml:space="preserve">
          <source>Every database consists of one or more &quot;pages&quot;. Within a single database, every page is the same size, but different database can have page sizes that are powers of two between 512 and 65536, inclusive. The maximum size of a database file is 2147483646 pages. At the maximum page size of 65536 bytes, this translates into a maximum database size of approximately 1.4e+14 bytes (140 terabytes, or 128 tebibytes, or 140,000 gigabytes or 128,000 gibibytes).</source>
          <target state="translated">每个数据库都由一个或多个 &quot;页面 &quot;组成。在一个数据库中,每个页面的大小都是一样的,但不同的数据库的页面大小可以是512到65536(含)之间的2次方。一个数据库文件的最大大小是2147483646页。按最大页面大小65536字节计算,相当于数据库的最大大小约为1.4e+14字节(140TB,或128Tebibytes,或140000Gigabytes或128000Gibytes)。</target>
        </trans-unit>
        <trans-unit id="c2e6403515f1bf32ac4e648a9caa0419f6afeca1" translate="yes" xml:space="preserve">
          <source>Every database consists of one or more &quot;pages&quot;. Within a single database, every page is the same size, but different database can have page sizes that are powers of two between 512 and 65536, inclusive. The maximum size of a database file is 4294967294 pages. At the maximum page size of 65536 bytes, this translates into a maximum database size of approximately 1.4e+14 bytes (281 terabytes, or 256 tebibytes, or 281474 gigabytes or 256,000 gibibytes).</source>
          <target state="translated">每个数据库都由一个或多个 &quot;页面 &quot;组成。在一个数据库中,每个页面的大小都是一样的,但不同的数据库的页面大小可以是512到65536(含)之间的2次方。一个数据库文件的最大大小是4294967294页。在最大页面大小为65536字节时,相当于数据库的最大大小约为1.4e+14字节(281TB,或256TB,或281474GB,或256000GB)。</target>
        </trans-unit>
        <trans-unit id="492468356f24318b48960ab6726d183969622442" translate="yes" xml:space="preserve">
          <source>Every effort has been made to ensure that the various combinations of compilation options work harmoniously and produce a working library. Nevertheless, it is strongly recommended that the SQLite test-suite be executed to check for errors before using an SQLite library built with non-standard compilation options.</source>
          <target state="translated">我们已经尽一切努力确保各种编译选项的组合能够和谐地工作,并产生一个工作库。然而,我们强烈建议在使用用非标准编译选项构建的SQLite库之前,先执行SQLite测试套件来检查错误。</target>
        </trans-unit>
        <trans-unit id="851c55d70f2242d9f00006ba4265653d3268a46b" translate="yes" xml:space="preserve">
          <source>Every file opened by the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method populates an &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object (or, more commonly, a subclass of the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object) with a pointer to an instance of this object. This object defines the methods used to perform various operations against the open file represented by the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;方法打开的每个文件都使用指向该对象实例的指针填充&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt;对象（或更常见的是&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt;对象的子类）。该对象定义用于对&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt;对象表示的打开文件执行各种操作的方法。</target>
        </trans-unit>
        <trans-unit id="acba6a710579420286ddba1b5725059065fac3c6" translate="yes" xml:space="preserve">
          <source>Every file opened by the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method populates an &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object (or, more commonly, a subclass of the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object) with a pointer to an instance of this object. This object defines the methods used to perform various operations against the open file represented by the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;方法打开的每个文件都使用指向该对象实例的指针填充&lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt;对象（或更常见的是&lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt;对象的子类）。该对象定义用于对&lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt;对象表示的打开文件执行各种操作的方法。</target>
        </trans-unit>
        <trans-unit id="41db9f975be9405dd8cb84bdb860cef93b013806" translate="yes" xml:space="preserve">
          <source>Every leaf entry and node (subtree) within the R*Tree has an integer &quot;level&quot;. The leaves have a level of 0. The first containing subtree of the leaves has a level of 1. The root of the R*Tree has the largest level value. The mxLevel entry in the sqlite3_rtree_query_info structure is the level value for the root of the R*Tree. The iLevel entry in sqlite3_rtree_query_info gives the level for the object being interrogated.</source>
          <target state="translated">R*Tree中的每个叶子条目和节点(子树)都有一个整数 &quot;级别&quot;。叶子的级别为0,叶子的第一个子树的级别为1,R*Tree的根的级别值最大。sqlite3_rtree_query_info结构中的mxLevel条目是R*Tree根的级别值。sqlite3_rtree_query_info结构中的iLevel条目给出了被查询对象的级别。</target>
        </trans-unit>
        <trans-unit id="b83b5bef3193f9d71b5510c871842564bded152b" translate="yes" xml:space="preserve">
          <source>Every member in the organization has a name, and most members have a single boss. (The head of the whole organization has a NULL &quot;boss&quot; field.) The rows of the &quot;org&quot; table form a tree.</source>
          <target state="translated">组织中的每个成员都有一个名字,大多数成员都有一个老板。(整个组织的负责人有一个NULL的 &quot;老板 &quot;字段。)&quot;org &quot;表的行形成一棵树。</target>
        </trans-unit>
        <trans-unit id="8f03f228f31451b11bb432dc265147274d2ce013" translate="yes" xml:space="preserve">
          <source>Every new &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; defaults to having the auto-checkpoint enabled with a threshold of 1000 or &lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt; pages. The use of this interface is only necessary if the default setting is found to be suboptimal for a particular application.</source>
          <target state="translated">默认情况下，每个新的&lt;a href=&quot;#sqlite3&quot;&gt;数据库连接&lt;/a&gt;都会启用自动检查点，其阈值为1000或&lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt;页面。仅当发现默认设置对于特定应用程序不是最佳时，才需要使用此接口。</target>
        </trans-unit>
        <trans-unit id="b7af72a8a5bd73c0f21a3d8802bbfe1036436982" translate="yes" xml:space="preserve">
          <source>Every new &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; defaults to having the auto-checkpoint enabled with a threshold of 1000 or &lt;a href=&quot;../compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt; pages. The use of this interface is only necessary if the default setting is found to be suboptimal for a particular application.</source>
          <target state="translated">默认情况下，每个新的&lt;a href=&quot;sqlite3&quot;&gt;数据库连接&lt;/a&gt;都会启用自动检查点，其阈值为1000或&lt;a href=&quot;../compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt;页面。仅当发现默认设置对于特定应用程序不是最佳时，才需要使用此接口。</target>
        </trans-unit>
        <trans-unit id="690c0362c23abb50bf57905b3d0de565bf19cc04" translate="yes" xml:space="preserve">
          <source>Every now and then someone discovers a new failure mode for the atomic commit mechanism in SQLite and the developers have to put in a patch. This is happening less and less and the failure modes are becoming more and more obscure. But it would still be foolish to suppose that the atomic commit logic of SQLite is entirely bug-free. The developers are committed to fixing these bugs as quickly as they might be found.</source>
          <target state="translated">每隔一段时间就会有人发现SQLite中原子提交机制出现了新的失败模式,开发者不得不打上补丁。这种情况越来越少,失败模式也越来越模糊。但如果认为SQLite的原子提交逻辑完全没有bug,那还是很愚蠢的。开发者致力于尽快修复这些可能发现的bug。</target>
        </trans-unit>
        <trans-unit id="5f4785ec886c54cc0fadcbaced75cf5fb546955b" translate="yes" xml:space="preserve">
          <source>Every row of a table has a unique rowid. If the table defines a column with the type &quot;INTEGER PRIMARY KEY&quot; then that column becomes an alias for the rowid. But with or without an INTEGER PRIMARY KEY column, every row still has a rowid.</source>
          <target state="translated">一个表的每一行都有一个唯一的rowid。如果表定义了一个类型为 &quot;INTEGER PRIMARY KEY &quot;的列,那么这个列就成为了rowid的别名。但是不管有没有INTEGER PRIMARY KEY列,每一行都有一个rowid。</target>
        </trans-unit>
        <trans-unit id="80c2c192e2c163c4bc5aa39b793ee2331ee10eba" translate="yes" xml:space="preserve">
          <source>Every row of an SQLite table has a unique integer key. If the table has a column labeled INTEGER PRIMARY KEY, then that column serves as the key. If there is no INTEGER PRIMARY KEY column then the key is a unique integer. The key for a row can be accessed in a SELECT statement or used in a WHERE or ORDER BY clause using any of the names &quot;ROWID&quot;, &quot;OID&quot;, or &quot;_ROWID_&quot;.</source>
          <target state="translated">SQLite表的每一行都有一个唯一的整数键。如果表有一列标有INTEGER PRIMARY KEY的列,那么该列就作为键。如果没有INTEGER PRIMARY KEY列,那么键就是一个唯一的整数。可以在SELECT语句中访问行的键,或者在WHERE或ORDER BY子句中使用 &quot;ROWID&quot;、&quot;OID &quot;或&quot;_ROWID_&quot;中的任何一个名称。</target>
        </trans-unit>
        <trans-unit id="523f1beb41c9b6ccdf7d3e8baf9a9fab841b07a9" translate="yes" xml:space="preserve">
          <source>Every table (except the &quot;sqlite_master&quot; table itself) and every named index in an SQLite database has an entry in the sqlite_master table. You can query this table using a SELECT statement just like any other table. But you are not allowed to directly change the table using UPDATE, INSERT, or DELETE. Changes to sqlite_master have to occur using the CREATE and DROP commands because SQLite also has to update some of its internal data structures when tables and indices are added or destroyed.</source>
          <target state="translated">SQLite数据库中的每一张表(除了 &quot;sqlite_master &quot;表本身)和每一个命名的索引都在sqlite_master表中有一个条目。你可以像其他表一样,使用SELECT语句查询这个表。但不允许你直接使用UPDATE、INSERT或DELETE来改变这个表。对sqlite_master的更改必须使用CREATE和DROP命令进行,因为当表和索引被添加或销毁时,SQLite也要更新其内部的一些数据结构。</target>
        </trans-unit>
        <trans-unit id="ee8f8904135a756c4539e015e36cc2347848e522" translate="yes" xml:space="preserve">
          <source>Every table column has a type affinity (one of BLOB, TEXT, INTEGER, REAL, or NUMERIC) but expressions do no necessarily have an affinity.</source>
          <target state="translated">每个表列都有一个类型亲和力(BLOB、TEXT、INTEGER、REAL或NUMERIC中的一种),但表达式不一定有亲和力。</target>
        </trans-unit>
        <trans-unit id="f32098850bf86d28dad50eda2ef7aba6cca6adf4" translate="yes" xml:space="preserve">
          <source>Every table column has a type affinity (one of BLOB, TEXT, INTEGER, REAL, or NUMERIC) but expressions do not necessarily have an affinity.</source>
          <target state="translated">每个表列都有一个类型亲和力(BLOB、TEXT、INTEGER、REAL或NUMERIC中的一种),但表达式不一定有亲和力。</target>
        </trans-unit>
        <trans-unit id="0ed8a6fcdde7fff586bbaf9d083a7c2eda68dd03" translate="yes" xml:space="preserve">
          <source>Every table must have at least one non-generated column.</source>
          <target state="translated">每个表必须至少有一个非生成列。</target>
        </trans-unit>
        <trans-unit id="a4b08058b164391fddf9b32eae0d934e211c5565" translate="yes" xml:space="preserve">
          <source>Every union-vtab must be in the TEMP namespace. Hence, the &quot;&lt;b&gt;temp.&lt;/b&gt;&quot; prior to</source>
          <target state="translated">每个union-vtab必须在TEMP名称空间中。因此，之前的&amp;ldquo; &lt;b&gt;温度&lt;/b&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="07d98b3ee8d9544f097098f5c8c00f7db4bddabb" translate="yes" xml:space="preserve">
          <source>Every valid SQLite database file begins with the following 16 bytes (in hex): 53 51 4c 69 74 65 20 66 6f 72 6d 61 74 20 33 00. This byte sequence corresponds to the UTF-8 string &quot;SQLite format 3&quot; including the nul terminator character at the end.</source>
          <target state="translated">每个有效的SQLite数据库文件都以下列16个字节(十六进制)开始:53 51 4c 69 74 65 20 66 6f 72 6d 61 74 20 33 00。这个字节序列对应于UTF-8字符串 &quot;SQLite格式3&quot;,包括末尾的nul终止符。</target>
        </trans-unit>
        <trans-unit id="3fb9e9a96d68ea92a8c52ca6ed6ad8f58a99797f" translate="yes" xml:space="preserve">
          <source>Every value in SQLite has one of five fundamental datatypes:</source>
          <target state="translated">SQLite中的每个值都有五个基本数据类型之一。</target>
        </trans-unit>
        <trans-unit id="bfeeeccf4fe9e729f75c5da5ce8becce10cd642f" translate="yes" xml:space="preserve">
          <source>Every virtual machine that &lt;b&gt;sqlite_compile&lt;/b&gt; creates should eventually be handed to &lt;b&gt;sqlite_finalize&lt;/b&gt;. The sqlite_finalize() procedure deallocates the memory and other resources that the virtual machine uses. Failure to call sqlite_finalize() will result in resource leaks in your program.</source>
          <target state="translated">&lt;b&gt;sqlite_compile&lt;/b&gt;创建的每个虚拟机最终应移交给&lt;b&gt;sqlite_finalize&lt;/b&gt;。 sqlite_finalize（）过程取消分配虚拟机使用的内存和其他资源。未能调用sqlite_finalize（）会导致程序中的资源泄漏。</target>
        </trans-unit>
        <trans-unit id="441d9ec48f064dd7fdb10449b684859c580c29d7" translate="yes" xml:space="preserve">
          <source>Everything works correctly if any of the following are true:</source>
          <target state="translated">如果以下任何一项为真,一切都能正常工作。</target>
        </trans-unit>
        <trans-unit id="8604e6b6fdb1f3b4989ca256181c53477f03dab5" translate="yes" xml:space="preserve">
          <source>Exactly how a constraint violation is dealt with is determined by the &lt;a href=&quot;lang_conflict&quot;&gt;constraint conflict resolution algorithm&lt;/a&gt;. Each PRIMARY KEY, UNIQUE, NOT NULL and CHECK constraint has a default conflict resolution algorithm. PRIMARY KEY, UNIQUE and NOT NULL constraints may be explicitly assigned a default conflict resolution algorithm by including a &lt;a href=&quot;syntax/conflict-clause&quot;&gt;conflict-clause&lt;/a&gt; in their definitions. Or, if a constraint definition does not include a &lt;a href=&quot;syntax/conflict-clause&quot;&gt;conflict-clause&lt;/a&gt; or it is a CHECK constraint, the default conflict resolution algorithm is ABORT. Different constraints within the same table may have different default conflict resolution algorithms. See the section titled &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; for additional information.</source>
          <target state="translated">&lt;a href=&quot;lang_conflict&quot;&gt;约束冲突解决算法&lt;/a&gt;确定了如何处理约束冲突。每个PRIMARY KEY，UNIQUE，NOT NULL和CHECK约束都有一个默认的冲突解决算法。通过在其定义中包含&lt;a href=&quot;syntax/conflict-clause&quot;&gt;冲突子句&lt;/a&gt;，可以显式分配PRIMARY KEY，UNIQUE和NOT NULL约束，作为默认冲突解决算法。或者，如果约束定义不包含&lt;a href=&quot;syntax/conflict-clause&quot;&gt;冲突子句&lt;/a&gt;或它是CHECK约束，则默认冲突解决算法为ABORT。同一张表中的不同约束可能具有不同的默认冲突解决算法。有关其他信息，请参见标题为&amp;ldquo; &lt;a href=&quot;lang_conflict&quot;&gt;冲突&lt;/a&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ea502dec1cc13ee575d4e1a550b73652d77d9edc" translate="yes" xml:space="preserve">
          <source>Exactly how such a potential race-condition is handled depends on the threads and synchronization primitives interface used by the application. This example uses pthreads, the interface provided by modern UNIX-like systems, including Linux.</source>
          <target state="translated">究竟如何处理这种潜在的竞赛条件,取决于应用程序使用的线程和同步基元接口。这个例子使用了pthreads,这是现代类UNIX系统(包括Linux)提供的接口。</target>
        </trans-unit>
        <trans-unit id="8bb56a9e102b28af62ab0fa87c8a54e2b7c186a7" translate="yes" xml:space="preserve">
          <source>Example 1: Loading and Saving In-Memory Databases</source>
          <target state="translated">例1:加载和保存内存数据库</target>
        </trans-unit>
        <trans-unit id="51937c8938bd2ebee4b2832c7cafa5f90c5d7f5e" translate="yes" xml:space="preserve">
          <source>Example 2: Online Backup of a Running Database</source>
          <target state="translated">例2:正在运行的数据库的在线备份</target>
        </trans-unit>
        <trans-unit id="422445b132a0ddb86add309db860ce13ab867af6" translate="yes" xml:space="preserve">
          <source>Example Code</source>
          <target state="translated">示例代码</target>
        </trans-unit>
        <trans-unit id="4899b03c6613d4db35e464f13d4310eba09ed242" translate="yes" xml:space="preserve">
          <source>Example Typenames From The</source>
          <target state="translated">类型名称示例</target>
        </trans-unit>
        <trans-unit id="c6f5f53793eadfd32dbab5c6aaa82a0136b96344" translate="yes" xml:space="preserve">
          <source>Example illustrating the difference between the &quot;simple&quot; and &quot;porter&quot; tokenizers:</source>
          <target state="translated">举例说明 &quot;简单 &quot;和 &quot;搬运工 &quot;令牌器之间的区别。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="ef9725acb0b6336e45af3212bad902a609b4a04c" translate="yes" xml:space="preserve">
          <source>Example: Let the index be</source>
          <target state="translated">例子。让指数是</target>
        </trans-unit>
        <trans-unit id="e401b272925dcc99ebcfccff32208c1de26ee958" translate="yes" xml:space="preserve">
          <source>Example: To verify that an R*Tree named &quot;demo_index&quot; is well-formed and internally consistent, run:</source>
          <target state="translated">例子:要验证名为 &quot;demo_index &quot;的R*Tree是否形状良好且内部一致,运行:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="a2d6c3cd648514e93054fc43de972ef1a1395513" translate="yes" xml:space="preserve">
          <source>Except for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables, all rows within SQLite tables have a 64-bit signed integer key that uniquely identifies the row within its table. This integer is usually called the &quot;rowid&quot;. The rowid value can be accessed using one of the special case-independent names &quot;rowid&quot;, &quot;oid&quot;, or &quot;_rowid_&quot; in place of a column name. If a table contains a user defined column named &quot;rowid&quot;, &quot;oid&quot; or &quot;_rowid_&quot;, then that name always refers the explicitly declared column and cannot be used to retrieve the integer rowid value.</source>
          <target state="translated">除&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表外，SQLite表中的所有行都有一个64位带符号整数键，可唯一标识其表中的行。该整数通常称为&amp;ldquo; rowid&amp;rdquo;。可以使用与大小写无关的特殊名称之一&amp;ldquo; rowid&amp;rdquo;，&amp;ldquo; oid&amp;rdquo;或&amp;ldquo; _rowid_&amp;rdquo;代替列名来访问rowid值。如果表包含用户定义的名为&amp;ldquo; rowid&amp;rdquo;，&amp;ldquo; oid&amp;rdquo;或&amp;ldquo; _rowid_&amp;rdquo;的列，则该名称始终引用显式声明的列，并且不能用于检索整数rowid值。</target>
        </trans-unit>
        <trans-unit id="248eb9944419f3599ba80de676ca2d1922746437" translate="yes" xml:space="preserve">
          <source>Except for the WHERE clause, the structure of the program for this example is very much like the prior example, just with an extra column. There are now 3 columns, instead of 2 as before, and there are three ColumnName instructions. A cursor is opened using the OpenRead instruction, just like in the prior example. The Rewind instruction at address 6 and the Next at address 17 form a loop over all records of the table. The Close instruction at the end is there to give the Rewind instruction something to jump to when it is done. All of this is just like in the first query demonstration.</source>
          <target state="translated">除了WHERE子句之外,这个例子的程序结构和前面的例子非常相似,只是多了一列。现在有3列,而不是之前的2列,并且有3条ColumnName指令。使用OpenRead指令打开一个光标,就像之前的例子一样。地址6的Rewind指令和地址17的Next指令在表的所有记录上形成了一个循环。最后的Close指令是为了让Rewind指令完成后有东西可以跳转。所有这些都和第一个查询演示中一样。</target>
        </trans-unit>
        <trans-unit id="7141d556020acb770b395a3f91e4943886944cf0" translate="yes" xml:space="preserve">
          <source>Except for the read operation required by H35070 and those reads made as part of opening a read-only transaction, SQLite shall ensure that a</source>
          <target state="translated">除了H35070要求的读操作和作为打开只读事务的一部分进行的读操作外,SQLite应确保一个</target>
        </trans-unit>
        <trans-unit id="daf367d9a62995933815a1367ba71ebafe36cdd3" translate="yes" xml:space="preserve">
          <source>Except in the case of &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; database connections with &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted&lt;/a&gt; turned on, all transactions in SQLite show &quot;serializable&quot; isolation. SQLite implements serializable transactions by actually serializing the writes. There can only be a single writer at a time to an SQLite database. There can be multiple database connections open at the same time, and all of those database connections can write to the database file, but they have to take turns. SQLite uses locks to serialization of the writes automatically; this is not something that the applications using SQLite need to worry with.</source>
          <target state="translated">除了在&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted已&lt;/a&gt;打开的&lt;a href=&quot;sharedcache&quot;&gt;共享缓存&lt;/a&gt;数据库连接的情况下，SQLite中的所有事务都显示&amp;ldquo;可序列化&amp;rdquo;隔离。 SQLite通过实际序列化写入来实现可序列化的事务。一个SQLite数据库一次只能有一个编写器。可以同时打开多个数据库连接，并且所有这些数据库连接都可以写入数据库文件，但是它们必须轮流使用。 SQLite使用锁来自动序列化写操作。这不是使用SQLite的应用程序需要担心的事情。</target>
        </trans-unit>
        <trans-unit id="375d2d4de08327323baabaae8fa05d31e96227c2" translate="yes" xml:space="preserve">
          <source>Except that the M and E are replaced by the mantissa and exponent of the floating point number. For example:</source>
          <target state="translated">只是M和E用浮点数的万字符和指数代替。例如:</target>
        </trans-unit>
        <trans-unit id="05e17a55270022b0935203eb1ff65bd637b9eb0b" translate="yes" xml:space="preserve">
          <source>Except, the statement above does not work, thanks to pointer types. The pointer generated by the MATCH operator has a type of &quot;fts3cursor&quot; but the carray() function expects to receives a pointer of type &quot;carray&quot;. Because the pointer type on the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; does not match the pointer type on the &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; call, &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; returns NULL in carray() and thus signals the CARRAY extension that it has been passed an invalid pointer.</source>
          <target state="translated">除此之外，由于指针类型的原因，以上语句不起作用。由MATCH运算符生成的指针的类型为&amp;ldquo; fts3cursor&amp;rdquo;，但carray（）函数希望接收的指针类型为&amp;ldquo; carray&amp;rdquo;。由于&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;上的指针类型与&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;调用上的指针类型不匹配，因此&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;在carray（）中返回NULL，因此向CARRAY扩展表示已传递了无效的指针。</target>
        </trans-unit>
        <trans-unit id="0829c4066912f266e388974fa121b62d34c08be6" translate="yes" xml:space="preserve">
          <source>Exclude clause</source>
          <target state="translated">排除条款</target>
        </trans-unit>
        <trans-unit id="6898c23bf064b43d330b025080e2f7ca1c663675" translate="yes" xml:space="preserve">
          <source>Execute applicable AFTER trigger programs.</source>
          <target state="translated">执行适用的AFTER触发程序。</target>
        </trans-unit>
        <trans-unit id="c543e4bf2eac6c17a5bcafecd505a60bc0758ff2" translate="yes" xml:space="preserve">
          <source>Execute applicable BEFORE trigger programs,</source>
          <target state="translated">执行适用的BEFORE触发程序。</target>
        </trans-unit>
        <trans-unit id="dc88af1c57b78a22fe3c05896efc419ad226673e" translate="yes" xml:space="preserve">
          <source>Execute the trigger program passed as P4 (type P4_SUBPROGRAM).</source>
          <target state="translated">执行作为 P4 传递的触发程序 (类型 P4_SUBPROGRAM)。</target>
        </trans-unit>
        <trans-unit id="92e0a28a0ba14dbc0f9870c2587f7dd1fa43da35" translate="yes" xml:space="preserve">
          <source>Execute the xInverse function for an aggregate. The function has P5 arguments. P4 is a pointer to the FuncDef structure that specifies the function. Register P3 is the accumulator.</source>
          <target state="translated">执行一个集合的xInverse函数。该函数有P5参数,P4是指向指定函数的FuncDef结构的指针。P4是指向指定函数的FuncDef结构的指针。寄存器P3是累加器。</target>
        </trans-unit>
        <trans-unit id="8e826ee24e5eaa789db2ffc2c5ffba3d2ef490ea" translate="yes" xml:space="preserve">
          <source>Execute the xStep (if P1==0) or xInverse (if P1!=0) function for an aggregate. The function has P5 arguments. P4 is a pointer to the FuncDef structure that specifies the function. Register P3 is the accumulator.</source>
          <target state="translated">执行一个集合的xStep(如果P1==0)或xInverse(如果P1!=0)函数。该函数有P5参数,P4是指向指定函数的FuncDef结构的指针。P4是指向指定函数的FuncDef结构的指针。寄存器P3是累加器。</target>
        </trans-unit>
        <trans-unit id="d25e5f6cc8e8e8f6df2982b8a71bbe3109ad8777" translate="yes" xml:space="preserve">
          <source>Execute the xStep function for an aggregate. The function has P5 arguments. P4 is a pointer to the FuncDef structure that specifies the function. Register P3 is the accumulator.</source>
          <target state="translated">执行一个集合的xStep函数。该函数有P5参数,P4是指向指定函数的FuncDef结构的指针。P4是指向指定函数的FuncDef结构的指针。寄存器P3是累加器。</target>
        </trans-unit>
        <trans-unit id="3abcc2cf0440581468341c7211f2946754168feb" translate="yes" xml:space="preserve">
          <source>Executive Summary</source>
          <target state="translated">执行摘要</target>
        </trans-unit>
        <trans-unit id="23225800cd0002edfbed8ad40f888fff569bdb43" translate="yes" xml:space="preserve">
          <source>Existing Change</source>
          <target state="translated">现有变化</target>
        </trans-unit>
        <trans-unit id="c6a4c238411feb293bac6b4620c00bdb61a3fa23" translate="yes" xml:space="preserve">
          <source>Existing zip archive entries may be modified using UPDATE statements.</source>
          <target state="translated">现有的压缩包条目可以使用UPDATE语句进行修改。</target>
        </trans-unit>
        <trans-unit id="53b42835fb01a0646614ba4e81e2b65a9cff9bdf" translate="yes" xml:space="preserve">
          <source>Exit immediately. All open cursors, etc are closed automatically.</source>
          <target state="translated">立即退出。所有打开的光标等都会自动关闭。</target>
        </trans-unit>
        <trans-unit id="b718f8c3a83788b1b360cc38380401a994fb4892" translate="yes" xml:space="preserve">
          <source>Experimental</source>
          <target state="translated">Experimental</target>
        </trans-unit>
        <trans-unit id="9be8055dafdd8df7dd5ded321f98b5d4a3c23849" translate="yes" xml:space="preserve">
          <source>Experimental And Deprecated Interfaces</source>
          <target state="translated">实验性和过时的接口</target>
        </trans-unit>
        <trans-unit id="7fea72449d921c55e0065d056e69bc920823d9b0" translate="yes" xml:space="preserve">
          <source>Experimental FTS2 module added</source>
          <target state="translated">增加的实验性FTS2模块</target>
        </trans-unit>
        <trans-unit id="3fdb876749dabb65b0a863fa4088f5b7655056a5" translate="yes" xml:space="preserve">
          <source>Experimental Interfaces</source>
          <target state="translated">实验接口</target>
        </trans-unit>
        <trans-unit id="e4bb6c1ea9830afec3b0ef3a107b2b9f3dde8942" translate="yes" xml:space="preserve">
          <source>Experimental date/time functions added.</source>
          <target state="translated">增加实验性的日期/时间功能。</target>
        </trans-unit>
        <trans-unit id="358e8b7fb082176243da08a7a31fe5a4d1333969" translate="yes" xml:space="preserve">
          <source>Experimental date/time functions revised.</source>
          <target state="translated">修订了实验性的日期/时间功能。</target>
        </trans-unit>
        <trans-unit id="7eb10f0095483031f4d115113847c4183b77a491" translate="yes" xml:space="preserve">
          <source>Experimental interfaces are subject to change and/or removal at any time.</source>
          <target state="translated">实验界面可随时更改和/或删除。</target>
        </trans-unit>
        <trans-unit id="b8727cd9638a0f2713c26e6983da8bcb851353a9" translate="yes" xml:space="preserve">
          <source>Experimental interfaces are subject to change. Applications that use experimental interfaces may need to be modified when upgrading to a newer SQLite release, though this is rare. When new interfaces are added to SQLite, they generally begin as experimental interfaces. After an interface has been in use for a while and the developers are confident that the design of the interface is sound and worthy of long-term support, the interface is marked as stable.</source>
          <target state="translated">实验性接口可能会发生变化。当升级到较新的SQLite版本时,使用实验性接口的应用程序可能需要修改,不过这种情况很少。当新的接口被添加到SQLite中时,它们一般都是以实验接口的形式开始的。当一个接口使用了一段时间后,开发人员确信该接口的设计是合理的,值得长期支持的,该接口就会被标记为稳定接口。</target>
        </trans-unit>
        <trans-unit id="a20b1cb075c4a00d0abbf8e26207c972c09680bb" translate="yes" xml:space="preserve">
          <source>Experimental memory allocators</source>
          <target state="translated">实验性内存分配器</target>
        </trans-unit>
        <trans-unit id="ef394d562795d87e8981a3ef0b747f4f8415b4e8" translate="yes" xml:space="preserve">
          <source>Experimental sqlite_last_statement_changes() API added. Fixed the last_insert_rowid() function so that it works correctly with triggers.</source>
          <target state="translated">增加了实验性的 sqlite_last_statement_changes()API。修正了last_insert_rowid()函数,使其能够正确地与触发器一起工作。</target>
        </trans-unit>
        <trans-unit id="3da5d6c17cd08f8fd17c037a2c324328332c9e1f" translate="yes" xml:space="preserve">
          <source>Expire</source>
          <target state="translated">Expire</target>
        </trans-unit>
        <trans-unit id="3491713fb12e8a067f41197ec08bfafa31b9fad4" translate="yes" xml:space="preserve">
          <source>Export the sqlite_changes() function from Windows DLLs.</source>
          <target state="translated">从Windows DLLs中导出sqlite_changes()函数。</target>
        </trans-unit>
        <trans-unit id="1cdccf3f2c55fca61416f93409d6573cd4ec6636" translate="yes" xml:space="preserve">
          <source>Export the sqlite_function_type() API function in the Windows DLL</source>
          <target state="translated">导出Windows DLL中的sqlite_function_type()API函数。</target>
        </trans-unit>
        <trans-unit id="d5fbd7523567abe11b73fcd31b6d3a54394db40c" translate="yes" xml:space="preserve">
          <source>Export to excel</source>
          <target state="translated">出口到excel</target>
        </trans-unit>
        <trans-unit id="d3564717c402a8a051ea3b35dc177cb473a37b25" translate="yes" xml:space="preserve">
          <source>Expose SQLite's internal pseudo-random number generator (PRNG) via the &lt;a href=&quot;c3ref/randomness&quot;&gt;sqlite3_randomness()&lt;/a&gt; interface</source>
          <target state="translated">通过&lt;a href=&quot;c3ref/randomness&quot;&gt;sqlite3_randomness（）&lt;/a&gt;接口公开SQLite的内部伪随机数生成器（PRNG）</target>
        </trans-unit>
        <trans-unit id="ae70d9011360d64f28a8a35dd90c8da3ddd3466d" translate="yes" xml:space="preserve">
          <source>Expose the &lt;a href=&quot;c3ref/stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; interface for use by extensions and applications.</source>
          <target state="translated">公开&lt;a href=&quot;c3ref/stricmp&quot;&gt;sqlite3_strnicmp（）&lt;/a&gt;接口，供扩展程序和应用程序使用。</target>
        </trans-unit>
        <trans-unit id="43a8bde69f1d5429f321700a30e06b249b531dc6" translate="yes" xml:space="preserve">
          <source>Expression Affinity</source>
          <target state="translated">表达亲和力</target>
        </trans-unit>
        <trans-unit id="2dd84143cc8f5bbd9454bf39088a896b30eb6b90" translate="yes" xml:space="preserve">
          <source>Expression affinity</source>
          <target state="translated">表达亲和力</target>
        </trans-unit>
        <trans-unit id="3d1f752f9df92f5925b4848ce31d612b54cbf2eb" translate="yes" xml:space="preserve">
          <source>Expression affinity is determined by the following rules:</source>
          <target state="translated">表达式亲和力由以下规则决定。</target>
        </trans-unit>
        <trans-unit id="59d2facf767d8cd997d901649d83987ad43a4414" translate="yes" xml:space="preserve">
          <source>Expressions in CREATE INDEX statements may contain function calls, but only to functions whose output is always determined completely by its input parameters (a.k.a.: &lt;a href=&quot;deterministic&quot;&gt;deterministic functions&lt;/a&gt;). Obviously, functions like &lt;a href=&quot;lang_corefunc#random&quot;&gt;random()&lt;/a&gt; will not work well in an index. But also functions like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;, though they are constant across any one database connection, are not constant across the life of the underlying database file, and hence may not be used in a CREATE INDEX statement.</source>
          <target state="translated">CREATE INDEX语句中的表达式可以包含函数调用，但只能用于其输出始终完全由其输入参数&lt;a href=&quot;deterministic&quot;&gt;确定的函数&lt;/a&gt;（又称确定性函数）。显然，像&lt;a href=&quot;lang_corefunc#random&quot;&gt;random（）&lt;/a&gt;这样的函数在索引中不能很好地工作。但是像&lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version（）&lt;/a&gt;这样的函数，尽管它们在任何一个数据库连接中都是恒定的，但在基础数据库文件的生命周期中却不是恒定的，因此可能无法在CREATE INDEX语句中使用。</target>
        </trans-unit>
        <trans-unit id="19a6e91fe10c5674eb13c2fd762a7021fa8a05d5" translate="yes" xml:space="preserve">
          <source>Expressions in CREATE INDEX statements may not use subqueries.</source>
          <target state="translated">CREATE INDEX语句中的表达式不能使用子查询。</target>
        </trans-unit>
        <trans-unit id="7cfe3f417ef1d8d91b4195c28077dbb7d62d18f6" translate="yes" xml:space="preserve">
          <source>Expressions in CREATE INDEX statements may only refer to columns of the table being indexed, not to columns in other tables.</source>
          <target state="translated">CREATE INDEX语句中的表达式只能引用被索引的表的列,不能引用其他表的列。</target>
        </trans-unit>
        <trans-unit id="31c8785ad9b4a9d7dc1446ae294e913645b75702" translate="yes" xml:space="preserve">
          <source>Expressions in an index may not reference other tables and may not use subqueries nor functions whose result might change (ex: &lt;a href=&quot;lang_corefunc#random&quot;&gt;random()&lt;/a&gt; or &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;). Expressions in an index may only refer to columns in the table that is being indexed. Indexes on expression will not work with versions of SQLite prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). See the &lt;a href=&quot;expridx&quot;&gt;Indexes On Expressions&lt;/a&gt; document for additional information about using general expressions in CREATE INDEX statements.</source>
          <target state="translated">索引中的表达式可能不会引用其他表，并且可能不会使用子查询或结果可能会更改的函数（例如：&lt;a href=&quot;lang_corefunc#random&quot;&gt;random（）&lt;/a&gt;或&lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version（）&lt;/a&gt;）。索引中的表达式只能引用正在索引的表中的列。表达式索引不适用于&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;3.9.0&lt;/a&gt;（2015-10-14）之前的SQLite 版本。有关在CREATE INDEX语句中使用通用表达式的其他信息，请参见&amp;ldquo; &lt;a href=&quot;expridx&quot;&gt;索引上&lt;/a&gt;的索引&amp;rdquo;文档。</target>
        </trans-unit>
        <trans-unit id="c735d025b09f54040c918a48c63f4553312abde0" translate="yes" xml:space="preserve">
          <source>Expressions may only be used in CREATE INDEX statements, not within &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints within the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement.</source>
          <target state="translated">表达式只能在CREATE INDEX语句中使用，而不能在&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;语句的&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;或&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;约束中使用。</target>
        </trans-unit>
        <trans-unit id="16ba9ffc3e58ab67f2eeb64637e9739a29beccda" translate="yes" xml:space="preserve">
          <source>Extend the expression syntax to support &quot;expr NOT NULL&quot; (with a space between the &quot;NOT&quot; and the &quot;NULL&quot;) in addition to &quot;expr NOTNULL&quot; (with no space).</source>
          <target state="translated">扩展表达式语法,除了 &quot;expr NOTNULL&quot;(没有空格)之外,还支持 &quot;expr NOT NULL&quot;(在 &quot;NOT &quot;和 &quot;NULL &quot;之间有一个空格)。</target>
        </trans-unit>
        <trans-unit id="6d86bea998341375770658644790ac8289ea0fef" translate="yes" xml:space="preserve">
          <source>Extended Result Codes</source>
          <target state="translated">扩展结果代码</target>
        </trans-unit>
        <trans-unit id="09d1c9addf77edc2a7d8092f6e72ee640d2e255e" translate="yes" xml:space="preserve">
          <source>Extended result code</source>
          <target state="translated">扩展结果代码</target>
        </trans-unit>
        <trans-unit id="432cee7e4f965361237e9452306378119ba23eec" translate="yes" xml:space="preserve">
          <source>Extended the &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; statement so that it can optionally be limited to verifying just a single table and its indexes, rather than the entire database file.</source>
          <target state="translated">扩展了&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;语句，以便可以选择将其限制为仅验证单个表及其索引，而不是验证整个数据库文件。</target>
        </trans-unit>
        <trans-unit id="61badc5a87beafb6593c6e7cfe212f92bad7bbcd" translate="yes" xml:space="preserve">
          <source>Extended the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; interface, and in particular the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; object to allow a virtual table to report its estimate on the number of rows that will be returned by a query.</source>
          <target state="translated">扩展了&lt;a href=&quot;vtab&quot;&gt;虚拟表&lt;/a&gt;接口，尤其是扩展了&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;对象，以允许虚拟表报告其对查询将返回的行数的估计。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
