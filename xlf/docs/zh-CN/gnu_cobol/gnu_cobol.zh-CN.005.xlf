<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="gnu_cobol">
    <body>
      <group id="gnu_cobol">
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="1ba54893e49d5a98fdd72b1731cb837c15733eae" translate="yes" xml:space="preserve">
          <source>F, FACTORIAL, FACTORY, FALSE, FD, FILE, FILE-CONTROL, FILE-ID, FILLER, FINAL, FIRST, FIXED, FLOAT-BINARY-128, FLOAT-BINARY-32, FLOAT-BINARY-64, FLOAT-DECIMAL-16, FLOAT-DECIMAL-34, FLOAT-EXTENDED, FLOAT-INFINITY, FLOAT-LONG, FLOAT-NOT-A-NUMBER, FLOAT-SHORT, FOOTING, FOR, FOREGROUND-COLOR, FOREGROUND-COLOUR, FOREVER, FORMAT, FORMATTED-CURRENT-DATE, FORMATTED-DATE, FORMATTED-DATETIME, FORMATTED-TIME, FORMFEED, FRACTION-PART, FREE, FROM, FULL, FUNCTION, FUNCTION-ID, FUNCTION-POINTER</source>
          <target state="translated">F,FACTORIAL,FACTORY,FALSE,FD,FILE,FILE-CONTROL,FILE-ID,FILLER,FINAL,FIRST,FIXED,FLOAT-BINARY-128,FLOAT-BINARY-32,FLOAT-BINARY-64,FLOAT-DECIMAL-16,FLOAT-DECIMAL-34,FLOAT-EXTENDED,FLOAT-INFINITY,FLOAT-LONG,FLOAT-NOT-A-NUMBER,FLOAT-SHORT,FOOTING,FOR,FOREGROUND-COLOR,FOREGROUND-COLOUR,FOREVER,FORMAT,FORMATTED-CURRENT-DATE,FORMATTED-DATE,FORMATTED-DATETIME,FORMATTED-TIME,FORMFEED,FRACTION-PART,FREE,FROM,FULL,FUNCTION,FUNCTION-ID,FUNCTION-POINTER。</target>
        </trans-unit>
        <trans-unit id="d7caf280db3cab23a3efd52f861a41479460fa6f" translate="yes" xml:space="preserve">
          <source>F, FACTORIAL, FACTORY, FALSE, FD, FILE-CONTROL, FILE-ID, FILE-NAME, FILE-POS, FILE, FILL-COLOR2, FILL-COLOR, FILLER, FILL-PERCENT, FINAL, FINISH-REASON, FIRST, FIXED-FONT, FIXED-WIDTH, FIXED, FLAT-BUTTONS, FLAT, FLOAT-BINARY-128, FLOAT-BINARY-32, FLOAT-BINARY-64, FLOAT-DECIMAL-16, FLOAT-DECIMAL-34, FLOAT-EXTENDED, FLOAT-INFINITY, FLOATING, FLOAT-LONG, FLOAT-NOT-A-NUMBER, FLOAT-SHORT, FLOAT, FONT, FOOTING, FOREGROUND-COLOR, FOREGROUND-COLOUR, FOREVER, FORMAT, FORMATTED-CURRENT-DATE, FORMATTED-DATETIME, FORMATTED-DATE, FORMATTED-TIME, FORMFEED, FOR, FRACTION-PART, FRAMED, FRAME, FREE, FROM, FULL-HEIGHT, FULL, FUNCTION-ID, FUNCTION-POINTER, FUNCTION</source>
          <target state="translated">F,FACTORIAL,FACTORY,FALSE,FD,FILE-CONTROL,FILE-ID,FILE-NAME,FILE-POS,FILE,FILL-COLOR2,FILL-COLOR,FILLER,FILL-PERCENT,FINAL,FINISH-REASON,FIRST,FIXED-FONT,FIXED-WIDTH,FIXED,FLAT-BUTTONS,FLAT,FLOAT-BINARY-128,FLOAT-BINARY-32,FLOAT-BINARY-64,FLOAT-DECIMAL-16,FLOAT-DECIMAL-34,FLOAT-EXTENDED,FLOAT-INFINITY,FLOATING,FLOAT-LONG,FLOAT-NOT-A-NUMBER,FLOAT-SHORT,FLOAT,FONT,FOOTING,FOREGROUND-COLOR,FOREGROUND-COLOUR,FOREVER,FORMAT,FORMATTED-CURRENT-DATE,FORMATTED-DATETIME,FORMATTED-DATE,FORMATTED-TIME,FORMFEED,FOR,FRACTION-Part,FRAMED,FRAME,FREE,FROM,FULL-HEIGHT,FULL,FUNCTION-ID,FUNCTION-POINTER,FUNCTION</target>
        </trans-unit>
        <trans-unit id="c388ca73e917511c83a42c7c3347b5330aa45cac" translate="yes" xml:space="preserve">
          <source>F1&amp;ndash;F64, respectively, were pressed</source>
          <target state="translated">分别按F1-F64</target>
        </trans-unit>
        <trans-unit id="03de1b80d9ce6c956e045a67ec26864bd9ba86c4" translate="yes" xml:space="preserve">
          <source>FACTORIAL Function Syntax</source>
          <target state="translated">FACTORIAL 函数语法</target>
        </trans-unit>
        <trans-unit id="c9236dbf1d5f35b60810d9900ebae017d4554e9f" translate="yes" xml:space="preserve">
          <source>FALSE Clause Syntax</source>
          <target state="translated">FALSE 子句语法</target>
        </trans-unit>
        <trans-unit id="a721f50a7a690a4a15e9a37c997197a6892fe7c1" translate="yes" xml:space="preserve">
          <source>FETCH</source>
          <target state="translated">FETCH</target>
        </trans-unit>
        <trans-unit id="237f463d19c40eb262085170910a45a2579d4007" translate="yes" xml:space="preserve">
          <source>FILE SECTION Syntax</source>
          <target state="translated">FILE SECTION 语法</target>
        </trans-unit>
        <trans-unit id="6dfe1492af3adfd94529936ae7572256a4829765" translate="yes" xml:space="preserve">
          <source>FILE-SECTION-Data-Item</source>
          <target state="translated">FILE-SECTION-Data-Item</target>
        </trans-unit>
        <trans-unit id="a00fbabfeb0e3333ddad8f67452398d7a56df6cc" translate="yes" xml:space="preserve">
          <source>FILE-SECTION-Data-Item Syntax</source>
          <target state="translated">FILE-SECTION-Data-Item 语法</target>
        </trans-unit>
        <trans-unit id="9e0f66f312ce180a9aae7f3163bafb7826f66328" translate="yes" xml:space="preserve">
          <source>FINAL CONTROL FOOTING</source>
          <target state="translated">最终控制脚步</target>
        </trans-unit>
        <trans-unit id="731f027415da5cfbed9659d7626ce1ec426fcffa" translate="yes" xml:space="preserve">
          <source>FOOTING AT</source>
          <target state="translated">脚踏实地</target>
        </trans-unit>
        <trans-unit id="3e19d8cecb7e5bc7a9e28e9032b126d8e079e6f9" translate="yes" xml:space="preserve">
          <source>FOREGROUND-COLOR Attribute Syntax</source>
          <target state="translated">FOREGROUND-COLOR 属性 语法</target>
        </trans-unit>
        <trans-unit id="c692d3a2f6af3743ae5e8378f4c972f6314b9106" translate="yes" xml:space="preserve">
          <source>FORMATTED-CURRENT-DATE Function Syntax</source>
          <target state="translated">功能描述 该命令为 &quot;格式化当前日期&quot;。</target>
        </trans-unit>
        <trans-unit id="0d6c854d359a51e18bcbb535437b70bfcccdf40e" translate="yes" xml:space="preserve">
          <source>FORMATTED-DATE Function Syntax</source>
          <target state="translated">函数语法</target>
        </trans-unit>
        <trans-unit id="2356dae93cb030bd9402e0c53b8de8c6ad996010" translate="yes" xml:space="preserve">
          <source>FORMATTED-DATETIME Function Syntax</source>
          <target state="translated">FORMATTED-DATETIME 函数语法</target>
        </trans-unit>
        <trans-unit id="38f8e91eae2a330b39222f7cba3ef7d527f6dd64" translate="yes" xml:space="preserve">
          <source>FORMATTED-TIME Function Syntax</source>
          <target state="translated">FORMATTED-TIME 函数语法</target>
        </trans-unit>
        <trans-unit id="d5452f4037c6aa0b6e742313c3d7af9ddb944ba1" translate="yes" xml:space="preserve">
          <source>FRACTION-PART Function Syntax</source>
          <target state="translated">FRACTION-ART 函数语法</target>
        </trans-unit>
        <trans-unit id="6a87ce926e3fdeec20b1a39152e04f9b4879b7c9" translate="yes" xml:space="preserve">
          <source>FREE Syntax</source>
          <target state="translated">免费语法</target>
        </trans-unit>
        <trans-unit id="42879485a7a11418680abc60f6ddfab84a32360f" translate="yes" xml:space="preserve">
          <source>FROM Clause Syntax</source>
          <target state="translated">FROM子句语法</target>
        </trans-unit>
        <trans-unit id="2f45ea6b6316a4f10231808ddaece8cd1888d793" translate="yes" xml:space="preserve">
          <source>FULL Attribute Syntax</source>
          <target state="translated">FULL属性语法</target>
        </trans-unit>
        <trans-unit id="f8bf04d41870db2b7d965f6fcab85ce00b574e04" translate="yes" xml:space="preserve">
          <source>FUNCTION ALL INTRINSIC</source>
          <target state="translated">功能 ALL INTRINSIC</target>
        </trans-unit>
        <trans-unit id="19aa8d076903fa405aac265ff791623484d35537" translate="yes" xml:space="preserve">
          <source>Fails due to rule #1</source>
          <target state="translated">因规则1而失败</target>
        </trans-unit>
        <trans-unit id="c8f41e04860a699d459755ee5bc85c6fd14d5b99" translate="yes" xml:space="preserve">
          <source>Fails due to rule #2a</source>
          <target state="translated">因规则2a而失败</target>
        </trans-unit>
        <trans-unit id="ff00be8ee320bab1c7ba44d9360894c017495313" translate="yes" xml:space="preserve">
          <source>Fails due to rule #2b</source>
          <target state="translated">因规则2b而失败</target>
        </trans-unit>
        <trans-unit id="75efda3b01e99fcd496782dcc687d25e00babfe5" translate="yes" xml:space="preserve">
          <source>Fails due to rule #3a</source>
          <target state="translated">因规则3a而失败</target>
        </trans-unit>
        <trans-unit id="050c309a1409aa9e640bd99affba7737a0884c7e" translate="yes" xml:space="preserve">
          <source>Fails due to rule #3b</source>
          <target state="translated">因规则3b而失败</target>
        </trans-unit>
        <trans-unit id="296fa1d7af3bb7cac562c31b466a3232f2bb3696" translate="yes" xml:space="preserve">
          <source>Fails due to rule #5</source>
          <target state="translated">因第5条规则而失败</target>
        </trans-unit>
        <trans-unit id="8ba4b7cd854379dc43efe678aa9fc863d5f197f9" translate="yes" xml:space="preserve">
          <source>Fails due to rule #6</source>
          <target state="translated">因第6条规则而失败</target>
        </trans-unit>
        <trans-unit id="1c882dc98a68cae48a636d1057fb89ac7d36d44d" translate="yes" xml:space="preserve">
          <source>Failure Reason</source>
          <target state="translated">失败原因</target>
        </trans-unit>
        <trans-unit id="915120b00045631c4e8983c0043b1f79dd8a3042" translate="yes" xml:space="preserve">
          <source>Fatal</source>
          <target state="translated">Fatal</target>
        </trans-unit>
        <trans-unit id="c35c802e8500c8d21fd613e5ef4507f4da40a451" translate="yes" xml:space="preserve">
          <source>Fatal screen I/O error</source>
          <target state="translated">致命的屏幕I/O错误</target>
        </trans-unit>
        <trans-unit id="e19ab926093727a391692498a7ce5cfb742d2ae9" translate="yes" xml:space="preserve">
          <source>Field Outlining</source>
          <target state="translated">实地勾画</target>
        </trans-unit>
        <trans-unit id="3e7ab145eda1bc068c4891bdc4d2491b7ca3babf" translate="yes" xml:space="preserve">
          <source>Figurative Constants</source>
          <target state="translated">形象常数</target>
        </trans-unit>
        <trans-unit id="03bfea69bef182d9778a417b4cddffa248ed1ef1" translate="yes" xml:space="preserve">
          <source>Figurative constants are reserved words that may be used as literals anywhere the figurative constants value could be interpreted as an arbitrarily long sequence of the characters in question. When a specific length is required, such as would be the case with an argument to a subprogram, a figurative constant may not be used. Thus, the following are valid uses of figurative constants:</source>
          <target state="translated">形象常量是保留字,可以在形象常量值可以被解释为任意长的有关字符序列的任何地方作为字面意思使用。当需要特定的长度时,比如子程序的参数,就不能使用形象常量。因此,以下是形象常量的有效用途。</target>
        </trans-unit>
        <trans-unit id="daa8d8ba501862c2b07978aab870f1b814a865ba" translate="yes" xml:space="preserve">
          <source>File Location Strings are used (at runtime) to identify the path and filename to the data file that must be attached to &amp;lt;</source>
          <target state="translated">使用文件位置字符串（在运行时）标识必须附加到&amp;lt;的数据文件的路径和文件名。</target>
        </trans-unit>
        <trans-unit id="13f7443b10b7ca5925342febfec77171568b9348" translate="yes" xml:space="preserve">
          <source>File Location Strings are used (at runtime) to identify the path and filename to the data file that must be attached to &lt;var&gt;file-name-1&lt;/var&gt; when that file is opened.</source>
          <target state="translated">使用文件位置字符串（在运行时）标识打开文件时必须附加到 &lt;var&gt;file-name-1&lt;/var&gt; 的数据文件的路径和文件名。</target>
        </trans-unit>
        <trans-unit id="0f3e89f8a70a0298352574b5f3d10f8e9f6307ef" translate="yes" xml:space="preserve">
          <source>File Location Strings will be discussed shortly.</source>
          <target state="translated">文件位置字符串将很快被讨论。</target>
        </trans-unit>
        <trans-unit id="30ee6392d050dffb23e534b9b1e788b586e3c285" translate="yes" xml:space="preserve">
          <source>File already open</source>
          <target state="translated">文件已经打开</target>
        </trans-unit>
        <trans-unit id="1f1c6a46840542ee93667be29fe00c4a2ca6e55e" translate="yes" xml:space="preserve">
          <source>File not available</source>
          <target state="translated">文件不详</target>
        </trans-unit>
        <trans-unit id="a22e9c3b6a9f5c70de4f76a464810ecba1fb97c3" translate="yes" xml:space="preserve">
          <source>File not found</source>
          <target state="translated">未找到文件</target>
        </trans-unit>
        <trans-unit id="d5a01ba68e46b606375d0915c493efcb6d3e3101" translate="yes" xml:space="preserve">
          <source>File not open</source>
          <target state="translated">文件无法打开</target>
        </trans-unit>
        <trans-unit id="aa73a3bd94b48e7abeca430b784ba4827580e7e5" translate="yes" xml:space="preserve">
          <source>File section data buffers (and therefore all 01-level record layouts defined in the file section) are initialized to all binary zeros when the program is loaded into storage.</source>
          <target state="translated">文件部分数据缓冲区(因此文件部分定义的所有01级记录布局)在程序加载到存储中时被初始化为所有二进制零。</target>
        </trans-unit>
        <trans-unit id="2b5ebf13d43a94cfe869d3ece0ff8aa5a1595ced" translate="yes" xml:space="preserve">
          <source>File sharing failure</source>
          <target state="translated">文件共享失败</target>
        </trans-unit>
        <trans-unit id="182a34198299cefa26a74b5a5e4c6b7e382dfda1" translate="yes" xml:space="preserve">
          <source>File sharing is controlled through the use of a &lt;code&gt;SHARING&lt;/code&gt; clause:</source>
          <target state="translated">文件共享是通过使用 &lt;code&gt;SHARING&lt;/code&gt; 子句控制的：</target>
        </trans-unit>
        <trans-unit id="d6b7a316c213638a85b3dd6184fc41aa5cc4fb7b" translate="yes" xml:space="preserve">
          <source>File sharing is controlled through the use of a&lt;code&gt;SHARING&lt;/code&gt;</source>
          <target state="translated">文件共享是通过使用受控 &lt;code&gt;SHARING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f47df965cafac62967f207b6e7f09ae5add8b8f" translate="yes" xml:space="preserve">
          <source>File-Based SORT Syntax</source>
          <target state="translated">基于文件的SORT语法</target>
        </trans-unit>
        <trans-unit id="d87ff91def81de51380ccde36991f463b59063af" translate="yes" xml:space="preserve">
          <source>File/Sort-Description Syntax</source>
          <target state="translated">语法 文件/排序-描述</target>
        </trans-unit>
        <trans-unit id="0330be4deafe2943904ace5eb8bb1fc169381304" translate="yes" xml:space="preserve">
          <source>Files assigned to &lt;code&gt;PRINTER&lt;/code&gt; or &lt;code&gt;CONSOLE&lt;/code&gt; should be specified as &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt;.</source>
          <target state="translated">分配给 &lt;code&gt;PRINTER&lt;/code&gt; 或 &lt;code&gt;CONSOLE&lt;/code&gt; 的文件应指定为 &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7083473fe7c031e4e4634ba20b9fb70b80346024" translate="yes" xml:space="preserve">
          <source>Files assigned to&lt;code&gt;PRINTER&lt;/code&gt;or&lt;code&gt;CONSOLE&lt;/code&gt;should be specified as&lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt;</source>
          <target state="translated">分配给 &lt;code&gt;PRINTER&lt;/code&gt; 或 &lt;code&gt;CONSOLE&lt;/code&gt; 的文件应指定为 &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="31bbe64669631ae63fd6fe6257505f9cc209fe68" translate="yes" xml:space="preserve">
          <source>Files declared as &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; will consist of records terminated by an end-of-record delimiter character or character sequence.</source>
          <target state="translated">声明为 &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; 的文件将由以记录结尾定界符或字符序列终止的记录组成。</target>
        </trans-unit>
        <trans-unit id="8ece89d6efecefef42df7b76a92d5e414e65d7fc" translate="yes" xml:space="preserve">
          <source>Files declared as &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; will consist of records with no explicit end-of-record delimiter character sequences; records in such files are &amp;ldquo;delineated&amp;rdquo; by a calculated byte-offset (based on the maximum record length) into the file.</source>
          <target state="translated">声明为 &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; 的文件将由没有明确的记录结束定界符字符序列的记录组成；此类文件中的记录由计算出的字节偏移（基于最大记录长度）&amp;ldquo;描绘&amp;rdquo;到文件中。</target>
        </trans-unit>
        <trans-unit id="fadccef542c5815627f9bfef0daa01bf051a65a4" translate="yes" xml:space="preserve">
          <source>Files destined for use as sort/merge work files must be described with a Sort/Merge File Description (&lt;code&gt;SD&lt;/code&gt;) while every other file is described with a File Description (&lt;code&gt;FD&lt;/code&gt;). Each of these descriptions will almost always be followed with at least one record description.</source>
          <target state="translated">注定要用作排序/合并工作文件的文件必须使用排序/合并文件描述（ &lt;code&gt;SD&lt;/code&gt; ）进行描述，而其他所有文件都应使用文件描述（ &lt;code&gt;FD&lt;/code&gt; ）进行描述。这些描述中的每一个几乎总是跟着至少一个记录描述。</target>
        </trans-unit>
        <trans-unit id="edea6aacf2ec3d63ce72d8e95db88b7bd15eacd7" translate="yes" xml:space="preserve">
          <source>Files destined for use as sort/merge work files must be described with a Sort/Merge File Description &lt;code&gt;SD&lt;/code&gt; while every other file is described with a File Description &lt;code&gt;FD&lt;/code&gt;. Each of these descriptions will almost always be followed with at least one record description.</source>
          <target state="translated">用作排序/合并工作文件的文件必须使用&amp;ldquo;排序/合并文件描述&amp;rdquo; &lt;code&gt;SD&lt;/code&gt; 进行描述，而其他所有文件都应使用文件描述 &lt;code&gt;FD&lt;/code&gt; 进行描述。这些描述中的每一个几乎总是跟着至少一个记录描述。</target>
        </trans-unit>
        <trans-unit id="367feea21d15dacc3ac862c7a57bd856bad73096" translate="yes" xml:space="preserve">
          <source>Finally, COBOL has the ability to perform in-place sorts of the data that is found in a table.</source>
          <target state="translated">最后,COBOL有能力对表中的数据进行就地排序。</target>
        </trans-unit>
        <trans-unit id="a6001a209721116a31aff91d01e445326ed01374" translate="yes" xml:space="preserve">
          <source>Finally, here&amp;rsquo;s the report the program generates!</source>
          <target state="translated">最后，这是程序生成的报告！</target>
        </trans-unit>
        <trans-unit id="f20c28fefd559b4e296c1d1db0eefc938688cab3" translate="yes" xml:space="preserve">
          <source>Finally,the &lt;code&gt;REPORT FOOTING&lt;/code&gt; group, if any, will be presented.</source>
          <target state="translated">最后，将显示&amp;ldquo; &lt;code&gt;REPORT FOOTING&lt;/code&gt; 组（如果有）。</target>
        </trans-unit>
        <trans-unit id="f8e1fd8ed05817c2c1238d06570433fc37097c39" translate="yes" xml:space="preserve">
          <source>Finally,the&lt;code&gt;REPORT FOOTING&lt;/code&gt;group, if any, will be presented.</source>
          <target state="translated">最后，将显示&amp;ldquo; &lt;code&gt;REPORT FOOTING&lt;/code&gt; 组（如果有）。</target>
        </trans-unit>
        <trans-unit id="8a928ac89796afd20a583c169e78e1d2e97f3cee" translate="yes" xml:space="preserve">
          <source>First, the &quot;Hard Way&quot;:</source>
          <target state="translated">一是 &quot;硬道理&quot;。</target>
        </trans-unit>
        <trans-unit id="700b01ba4bdd2da33483f145da324ac61e1b1906" translate="yes" xml:space="preserve">
          <source>First, the &amp;ldquo;Hard Way&amp;rdquo;:</source>
          <target state="translated">首先，&amp;ldquo;硬道理&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="69a656c5968fc19e26398c39c1d42930578021ec" translate="yes" xml:space="preserve">
          <source>First/Last Digit</source>
          <target state="translated">第一个/最后一个数字</target>
        </trans-unit>
        <trans-unit id="c698ef5e7b0a316052b55cd8ba9f275dd3cc64d1" translate="yes" xml:space="preserve">
          <source>Fixed Format Mode</source>
          <target state="translated">固定格式模式</target>
        </trans-unit>
        <trans-unit id="fb6455fd910bbce0c221e84e30d7a80946a5a47c" translate="yes" xml:space="preserve">
          <source>Floating-point values using &quot;Enn&quot; notation such as 9.92E25, representing 9.92 x 10^25 (10 raised to the 25th power) or 5.7E-14, representing 5.7 x 10^-14 (10 raised to the -14th power). Both the mantissa (the number before the E) and the exponent (the number after the E) may be explicitly specified as positive (with a +), negative (with a -) or unsigned (and therefore implicitly positive). A floating-point literals value must be within the range -1.7 x 10^308 to +1.7 x 10^308 with no more than 15 decimal digits of precision.</source>
          <target state="translated">浮点值使用 &quot;Enn &quot;符号,如9.92E25,表示9.92×10^25(10升至25次方),或5.7E-14,表示5.7×10^-14(10升至-14次方)。尾数(E前面的数字)和指数(E后面的数字)都可以显式地指定为正数(带+)、负数(带-)或无符号(因此隐式为正数)。浮点数的值必须在-1.7 x 10^308到+1.7 x 10^308的范围内,精度不超过15位小数。</target>
        </trans-unit>
        <trans-unit id="3669c6f52ce8ae20cb1c5200355804595b964532" translate="yes" xml:space="preserve">
          <source>Floating-point values using &amp;lsquo;</source>
          <target state="translated">浮点值使用'</target>
        </trans-unit>
        <trans-unit id="5988bca9b2f3443b9ecd1f06fab806eb243168de" translate="yes" xml:space="preserve">
          <source>Footing Area</source>
          <target state="translated">底板面积</target>
        </trans-unit>
        <trans-unit id="87ab5909b2f76e9e20c96df08cc1254796e8a1d7" translate="yes" xml:space="preserve">
          <source>Footing Area &amp;mdash; An exception to this is the situation where the report footing report group contains the &lt;code&gt;NEXT PAGE&lt;/code&gt; option in its &lt;code&gt;LINE&lt;/code&gt; (see &lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt;) clause; in those cases, the report footing will be presented on a page by itself at the end of the report.</source>
          <target state="translated">立足点区域&amp;mdash;例外情况是，报表立足点报告组的 &lt;code&gt;LINE&lt;/code&gt; （请参阅&lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt;）子句中包含 &lt;code&gt;NEXT PAGE&lt;/code&gt; 选项；在这种情况下，报告基础将在报告末尾单独显示在页面上。</target>
        </trans-unit>
        <trans-unit id="e40c95fbb3b9dc7a620c19bde2435c717bde7695" translate="yes" xml:space="preserve">
          <source>Footing Area &amp;mdash; An exception to this is the situation where the report footing report group contains the&lt;code&gt;NEXT PAGE&lt;/code&gt;option in its&lt;code&gt;LINE&lt;/code&gt;(see &lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt;) clause; in those cases, the report footing will be presented on a page by itself at the end of the report.</source>
          <target state="translated">立足点区域&amp;mdash;例外情况是，报表立足点报告组的 &lt;code&gt;LINE&lt;/code&gt; （请参阅&lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt;）子句中包含 &lt;code&gt;NEXT PAGE&lt;/code&gt; 选项；在这种情况下，报告基础将在报告末尾单独显示在页面上。</target>
        </trans-unit>
        <trans-unit id="f1f2df0044b1fb68f6dc423b5264f3723a7c8996" translate="yes" xml:space="preserve">
          <source>For all other data types, the field size is set to the size of the item (same as if &lt;code&gt;CONVERT&lt;/code&gt; were not specified).</source>
          <target state="translated">对于所有其他数据类型，字段大小设置为项目的大小（与未指定 &lt;code&gt;CONVERT&lt;/code&gt; 相同）。</target>
        </trans-unit>
        <trans-unit id="a3127f980dbd36611f50532c041a2233802b3eff" translate="yes" xml:space="preserve">
          <source>For all other data types, the field size is set to the size of the item (same as if CONVERT were not specified).</source>
          <target state="translated">对于所有其他数据类型,字段大小被设置为项目的大小(与未指定CONVERT时相同)。</target>
        </trans-unit>
        <trans-unit id="aa49eb1e0aec6d10ce624911ab1285a133bc19a0" translate="yes" xml:space="preserve">
          <source>For any given version of GnuCOBOL you can also list the full current set of reserved words by running cobc with</source>
          <target state="translated">对于任何给定的GnuCOBOL版本,你也可以通过运行cobc与</target>
        </trans-unit>
        <trans-unit id="3f10546dc4d3d3e676fa3bc40fd34171c3147ee1" translate="yes" xml:space="preserve">
          <source>For composite &lt;code&gt;DISPLAY&lt;/code&gt;&amp;rsquo;s, the attributes are always only applied to the previous source-item but the following also allows a change by variable or literal</source>
          <target state="translated">对于复合 &lt;code&gt;DISPLAY&lt;/code&gt; ，属性始终仅应用于前一个源项目，但以下内容也允许按变量或文字进行更改</target>
        </trans-unit>
        <trans-unit id="0be022f00b31b21ff6869cd088d057bfb0e3270f" translate="yes" xml:space="preserve">
          <source>For each implementation of the GnuCOBOL compiler the supplied files NEWS should also be read for any last minute updates along with files README and INSTALL for building the compiler.</source>
          <target state="translated">对于每一个GnuCOBOL编译器的实现,所提供的文件NEWS也应该被阅读,以便进行任何最后一分钟的更新,同时还有用于构建编译器的文件README和INSTALL。</target>
        </trans-unit>
        <trans-unit id="c1fcb175d336c0714548be23a006f2304e931f29" translate="yes" xml:space="preserve">
          <source>For each source item, the contents of the sending item will be copied &amp;mdash; character-by-character &amp;mdash; into &amp;lt;</source>
          <target state="translated">对于每个源项目，发送项目的内容将按字符复制到&amp;lt;</target>
        </trans-unit>
        <trans-unit id="8d55093f3e06168b03c01ccd400fda41e135275a" translate="yes" xml:space="preserve">
          <source>For each source item, the contents of the sending item will be copied &amp;mdash; character-by-character &amp;mdash; into &lt;var&gt;identifier-3&lt;/var&gt; at the character position specified by the current character pointer. After each character is copied, the current character pointer will be incremented by 1 so that it points to the position within &lt;var&gt;identifier-3&lt;/var&gt; where the</source>
          <target state="translated">对于每个源项目，发送项目的内容将按字符逐个复制到当前字符指针指定的字符位置处的 &lt;var&gt;identifier-3&lt;/var&gt; 中。复制每个字符后，当前字符指针将增加1，以使其指向 &lt;var&gt;identifier-3&lt;/var&gt; 内的位置，</target>
        </trans-unit>
        <trans-unit id="cf9156cf449643f9bda337a140c24f2f1504f039" translate="yes" xml:space="preserve">
          <source>For example, You will not expect to see any difference whatsoever between values of 1, 100, 500 or 1000, but you should see a difference between values such as 250000000 and 500000000.</source>
          <target state="translated">例如,你不会期望看到1、100、500或1000的值之间有任何差异,但你应该看到250000000和500000000等值之间的差异。</target>
        </trans-unit>
        <trans-unit id="67f2916632d9738b41e6e54331471967b49d6ae6" translate="yes" xml:space="preserve">
          <source>For example, assuming the program is using the standard &lt;small&gt;ASCII&lt;/small&gt; collating sequence, &lt;code&gt;ORD('!')&lt;/code&gt; returns 34 because &amp;lsquo;</source>
          <target state="translated">例如，假设程序正在使用标准&lt;small&gt;ASCII&lt;/small&gt;整理序列，则 &lt;code&gt;ORD('!')&lt;/code&gt; 返回34，因为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="7766723a8b265a321d985162bb404da7b04dcd19" translate="yes" xml:space="preserve">
          <source>For example, assuming the program is using the standard &lt;small&gt;ASCII&lt;/small&gt; collating sequence, &lt;code&gt;ORD-MAX('Z', 'z', '!')&lt;/code&gt; returns 2 because the 2nd character in the argument list (the &lt;small&gt;ASCII&lt;/small&gt; character &amp;lsquo;</source>
          <target state="translated">例如，假设程序正在使用标准&lt;small&gt;ASCII&lt;/small&gt;整理序列，则 &lt;code&gt;ORD-MAX('Z', 'z', '!')&lt;/code&gt; 返回2，因为参数列表中的第二个字符（&lt;small&gt;ASCII&lt;/small&gt;字符'</target>
        </trans-unit>
        <trans-unit id="0ed29102fb766b9394cd4e12f35df95ed7177458" translate="yes" xml:space="preserve">
          <source>For example, assuming the program is using the standard &lt;small&gt;ASCII&lt;/small&gt; collating sequence, &lt;code&gt;ORD-MIN('Z', 'z', '!')&lt;/code&gt; returns 3 because the 3rd character in the argument list (the &lt;small&gt;ASCII&lt;/small&gt; character &amp;lsquo;</source>
          <target state="translated">例如，假设程序正在使用标准&lt;small&gt;ASCII&lt;/small&gt;整理序列，则 &lt;code&gt;ORD-MIN('Z', 'z', '!')&lt;/code&gt; 返回3，因为参数列表中的第三个字符（&lt;small&gt;ASCII&lt;/small&gt;字符'</target>
        </trans-unit>
        <trans-unit id="3368f51d3762d71c83916eebf4457e0236b996e5" translate="yes" xml:space="preserve">
          <source>For example, assuming the program is using the standard ASCII collating sequence,&lt;code&gt;ORD('!')&lt;/code&gt;returns 34 because &quot;!&quot; is the 34th ASCII character. If you are using this function to convert an ASCII character to its numeric value, you must subtract one from the result.</source>
          <target state="translated">例如，假设程序正在使用标准ASCII整理序列，则 &lt;code&gt;ORD('!')&lt;/code&gt; 返回34，因为&amp;ldquo;！&amp;rdquo; 是第34个ASCII字符。如果使用此函数将ASCII字符转换为其数值，则必须从结果中减去1。</target>
        </trans-unit>
        <trans-unit id="55a9ee5de13cdf67bb331bd003f29ecf42021db7" translate="yes" xml:space="preserve">
          <source>For example, assuming the program is using the standard ASCII collating sequence,&lt;code&gt;ORD-MAX('Z', 'z', '!')&lt;/code&gt;returns 2 because the 2nd character in the argument list (the ASCII character &amp;rsquo;z&amp;rsquo;) occurs after &amp;rsquo;Z&amp;rsquo; and &amp;rsquo;!&amp;rsquo; in the program collating sequence. Each &amp;lt;</source>
          <target state="translated">例如，假设程序正在使用标准ASCII整理序列，则 &lt;code&gt;ORD-MAX('Z', 'z', '!')&lt;/code&gt; 返回2，因为参数列表中的第二个字符（ASCII字符&amp;ldquo; z&amp;rdquo;）在'Z'和'！' 在程序整理顺序中。每个&amp;lt;</target>
        </trans-unit>
        <trans-unit id="0b8897a3e322f2447e1c9d83730f3c7e2254e611" translate="yes" xml:space="preserve">
          <source>For example, assuming the program is using the standard ASCII collating sequence,&lt;code&gt;ORD-MIN('Z', 'z', '!')&lt;/code&gt;returns 3 because the 3rd character in the argument list (the ASCII character &amp;rsquo;!&amp;rsquo;) occurs before &amp;rsquo;Z&amp;rsquo; and &amp;rsquo;z&amp;rsquo; in the program collating sequence. Each &amp;lt;</source>
          <target state="translated">例如，假设程序使用的是标准ASCII整理顺序，则 &lt;code&gt;ORD-MIN('Z', 'z', '!')&lt;/code&gt; 返回3，因为参数列表中的第三个字符（ASCII字符&amp;ldquo;！&amp;rdquo;）先于程序整理顺序中的&amp;ldquo; Z&amp;rdquo;和&amp;ldquo; z&amp;rdquo;。每个&amp;lt;</target>
        </trans-unit>
        <trans-unit id="749e13e172aac64f618104a47c4a2c7a40595730" translate="yes" xml:space="preserve">
          <source>For example, if &amp;lt;</source>
          <target state="translated">例如，如果&amp;lt;</target>
        </trans-unit>
        <trans-unit id="897cd42747603a9b53f6ab8470617280073ce9e3" translate="yes" xml:space="preserve">
          <source>For example, if &lt;var&gt;string&lt;/var&gt; is encoded using a double-byte character set such as Unicode UTF-16 (where each character is represented by 16 bits of storage, not the 8-bits inherent to character sets like &lt;small&gt;ASCII&lt;/small&gt; or &lt;small&gt;EBCDIC&lt;/small&gt;), then calling this function with a &lt;var&gt;string&lt;/var&gt; argument whose &lt;code&gt;PICTURE&lt;/code&gt; (see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) is &lt;code&gt;X(4)&lt;/code&gt; would return a value of 8 rather than the value 4.</source>
          <target state="translated">例如，如果使用双字节字符集（例如Unicode UTF-16）对 &lt;var&gt;string&lt;/var&gt; 进行编码（其中每个字符由16位存储空间表示，而不是诸如&lt;small&gt;ASCII&lt;/small&gt;或&lt;small&gt;EBCDIC&lt;/small&gt;这样的字符集固有的8位），则调用此方法带有 &lt;code&gt;PICTURE&lt;/code&gt; （请参阅&lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;）为 &lt;code&gt;X(4)&lt;/code&gt; 的 &lt;var&gt;string&lt;/var&gt; 参数的函数将返回值8而不是值4。</target>
        </trans-unit>
        <trans-unit id="9ee8b6b0eabb2430a55cd033971a62ef89f44236" translate="yes" xml:space="preserve">
          <source>For example, if the program is using the (default) &lt;small&gt;ASCII&lt;/small&gt; character set, CHAR(34) returns the 34th character in the &lt;small&gt;ASCII&lt;/small&gt; character set &amp;mdash; an exclamation-point (&amp;lsquo;</source>
          <target state="translated">例如，如果程序使用的是（默认）&lt;small&gt;ASCII&lt;/small&gt;字符集，则CHAR（34）返回&lt;small&gt;ASCII&lt;/small&gt;字符集中的第34个字符-感叹号（'</target>
        </trans-unit>
        <trans-unit id="24697a3ba1d925f052573a7696493b003e3077cd" translate="yes" xml:space="preserve">
          <source>For example, if the program is using the (default) ASCII character set, CHAR(34) returns the 34th character in the ASCII character set &amp;mdash; an exclamation-point (&quot;!&quot;). If you are using this function to convert a numeric value to its corresponding ASCII character, you must use an argument value one greater than the numeric value.</source>
          <target state="translated">例如，如果程序使用（默认）ASCII字符集，则CHAR（34）返回ASCII字符集中的第34个字符-感叹号（&amp;ldquo;！&amp;rdquo;）。如果使用此函数将数字值转换为其相应的ASCII字符，则必须使用比数字值大一的参数值。</target>
        </trans-unit>
        <trans-unit id="86d303a32d15849fb5f8b370e6bee4a9d77d8625" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s assume we&amp;rsquo;re sorting a series of financial transactions. The SORT statement might look like this:</source>
          <target state="translated">例如，假设我们正在对一系列金融交易进行排序。SORT语句可能如下所示：</target>
        </trans-unit>
        <trans-unit id="fb00a63cdc6f6eb78d00ce4dd102beadda021aab" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say you need to allocate a data item that contains however many millions of dollars of revenue your company has in gross revenues this year:</source>
          <target state="translated">例如，假设您需要分配一个数据项，其中包含公司今年总收入中有数百万美元的收入：</target>
        </trans-unit>
        <trans-unit id="baad68c9ee59c08b3b83b0d9b5e6c9c54362d8ca" translate="yes" xml:space="preserve">
          <source>For example, observe the following data structure which defines a 4 column by 3 row grid of characters:</source>
          <target state="translated">例如,观察以下数据结构,它定义了一个4列3行的字符网格。</target>
        </trans-unit>
        <trans-unit id="1e1810c68bddd424a5992ed3cf44b3e08e986f15" translate="yes" xml:space="preserve">
          <source>For example, on a GnuCOBOL build for a Windows PC using MinGW and &amp;ldquo;PDCurses&amp;rdquo;, &lt;code&gt;F1&lt;/code&gt;&amp;ndash;&lt;code&gt;F12&lt;/code&gt; are the actual F-keys on the PC keyboard, &lt;code&gt;F&lt;var&gt;13&lt;/var&gt;&lt;/code&gt;&amp;ndash;&lt;code&gt;F&lt;var&gt;24&lt;/var&gt;&lt;/code&gt; are entered by shifting the F-keys, &lt;code&gt;F&lt;var&gt;25&lt;/var&gt;&lt;/code&gt;&amp;ndash;&lt;code&gt;F&lt;var&gt;36&lt;/var&gt;&lt;/code&gt; are entered by holding Ctrl while pressing an F-key and &lt;code&gt;F&lt;var&gt;37&lt;/var&gt;&lt;/code&gt;&amp;ndash;&lt;code&gt;F&lt;var&gt;48&lt;/var&gt;&lt;/code&gt; are entered by holding Alt while pressing an F-key. On the other hand, a GnuCOBOL implementation built for Windows using Cygwin and NCurses treats the PCs &lt;code&gt;F&lt;var&gt;1&lt;/var&gt;&lt;/code&gt;&amp;ndash;&lt;code&gt;F&lt;var&gt;12&lt;/var&gt;&lt;/code&gt; keys as the actual &lt;code&gt;F&lt;var&gt;1&lt;/var&gt;&lt;/code&gt;&amp;ndash;&lt;code&gt;F&lt;var&gt;12&lt;/var&gt;&lt;/code&gt;, while shifted F-keys will enter &lt;code&gt;F&lt;var&gt;11&lt;/var&gt;&lt;/code&gt;&amp;ndash;&lt;code&gt;F&lt;var&gt;2&lt;/var&gt;&lt;/code&gt;0. With Cygwin/NCurses, Ctrl- and Alt-modified F-keys aren&amp;rsquo;t recognized, nor are &lt;code&gt;Shift-F&lt;var&gt;11&lt;/var&gt;&lt;/code&gt; or &lt;code&gt;Shift-F&lt;var&gt;12&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">例如，在使用MinGW和&amp;ldquo;PDCurses&amp;rdquo;，一个GnuCOBOL建立在Windows PC &lt;code&gt;F1&lt;/code&gt; - &lt;code&gt;F12&lt;/code&gt; 是PC键盘上的实际的F键， &lt;code&gt;F&lt;var&gt;13&lt;/var&gt;&lt;/code&gt; - &lt;code&gt;F&lt;var&gt;24&lt;/var&gt;&lt;/code&gt; 是通过移动F键进入， &lt;code&gt;F&lt;var&gt;25&lt;/var&gt;&lt;/code&gt; - &lt;code&gt;F&lt;var&gt;36&lt;/var&gt;&lt;/code&gt; 在按住F键的同时按住Ctrl可以输入36，而在按住F键的同时按住Alt可以输入 &lt;code&gt;F&lt;var&gt;37&lt;/var&gt;&lt;/code&gt; &amp;ndash; &lt;code&gt;F&lt;var&gt;48&lt;/var&gt;&lt;/code&gt; 。在另一方面，GnuCOBOL实施Windows中使用Cygwin和ncurses的对待电脑内置 &lt;code&gt;F&lt;var&gt;1&lt;/var&gt;&lt;/code&gt; - &lt;code&gt;F&lt;var&gt;12&lt;/var&gt;&lt;/code&gt; 键作为实际 &lt;code&gt;F&lt;var&gt;1&lt;/var&gt;&lt;/code&gt; - &lt;code&gt;F&lt;var&gt;12&lt;/var&gt;&lt;/code&gt; ，而移位F键就会进入 &lt;code&gt;F&lt;var&gt;11&lt;/var&gt;&lt;/code&gt; - &lt;code&gt;F&lt;var&gt;2&lt;/var&gt;&lt;/code&gt; 0。Cygwin的/ NCURSES，按Ctrl -和Alt改性F键不被识别，也不是 &lt;code&gt;Shift-F&lt;var&gt;11&lt;/var&gt;&lt;/code&gt; 或者 &lt;code&gt;Shift-F&lt;var&gt;12&lt;/var&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3aafb29761d15f601ec670e73bfded28362456c7" translate="yes" xml:space="preserve">
          <source>For example, the following defines a class called &quot;Hexadecimal&quot;, the definition of which specifies the only characters that may be present in an alphanumeric data item if that data item is to be part of the &quot;Hexadecimal&quot; class:</source>
          <target state="translated">例如,下面定义了一个名为 &quot;十六进制 &quot;的类,该类的定义指定了一个字母数字数据项中可能存在的唯一字符,如果该数据项是 &quot;十六进制 &quot;类的一部分。</target>
        </trans-unit>
        <trans-unit id="affabf883c8efcc9b6ac761a06fc5f1e4af89db5" translate="yes" xml:space="preserve">
          <source>For example, the following defines a class called &lt;code&gt;Hexadecimal&lt;/code&gt;, the definition of which specifies the only characters that may be present in an alphanumeric data item if that data item is to be part of the &lt;code&gt;Hexadecimal&lt;/code&gt; class:</source>
          <target state="translated">例如，以下内容定义了一个名为 &lt;code&gt;Hexadecimal&lt;/code&gt; 的类，该类的定义指定了字母数字数据项中唯一的字符（如果该数据项将成为 &lt;code&gt;Hexadecimal&lt;/code&gt; 类的一部分）：</target>
        </trans-unit>
        <trans-unit id="0bfaac6856103f819db17ad997ea57d182a00507" translate="yes" xml:space="preserve">
          <source>For example, you will not expect to see any difference between values of 1, 100, 500 or 1000, but you should see a difference between values such as 250000000 and 500000000.</source>
          <target state="translated">例如,你不会期望看到1、100、500或1000的值之间有任何差异,但你应该看到250000000和500000000等值之间的差异。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="768d8aa397739d0da5300dfc289107304c48653e" translate="yes" xml:space="preserve">
          <source>For files in the &lt;code&gt;SEQUENTIAL&lt;/code&gt; access mode, the last input-output statement executed against &lt;var&gt;file-name-1&lt;/var&gt; prior to the execution of the &lt;code&gt;DELETE&lt;/code&gt; statement must have been a successfully executed sequential-format &lt;code&gt;READ&lt;/code&gt; statement (see &lt;a href=&quot;#Sequential-READ&quot;&gt;Sequential READ&lt;/a&gt;). That &lt;code&gt;READ&lt;/code&gt; will therefore identify the record to be deleted.</source>
          <target state="translated">对于处于 &lt;code&gt;SEQUENTIAL&lt;/code&gt; 访问模式的 &lt;var&gt;file-name-1&lt;/var&gt; ，在执行 &lt;code&gt;DELETE&lt;/code&gt; 语句之前针对file-name-1执行的最后一个输入输出语句必须已经成功执行了顺序格式 &lt;code&gt;READ&lt;/code&gt; 语句（请参见&lt;a href=&quot;#Sequential-READ&quot;&gt;Sequential READ&lt;/a&gt;）。这 &lt;code&gt;READ&lt;/code&gt; 因此将标识记录被删除。</target>
        </trans-unit>
        <trans-unit id="dab6ce21e23d5e22f729efd782034eee11b18ef5" translate="yes" xml:space="preserve">
          <source>For files in the&lt;code&gt;SEQUENTIAL&lt;/code&gt;access mode, the last input-output statement executed against &amp;lt;</source>
          <target state="translated">对于处于 &lt;code&gt;SEQUENTIAL&lt;/code&gt; 访问模式的文件，针对&amp;lt;</target>
        </trans-unit>
        <trans-unit id="e59cbd1f100864f2a69aca9178b5457c051de746" translate="yes" xml:space="preserve">
          <source>For non-trivial computations, &lt;code&gt;COMPUTE&lt;/code&gt; statements &amp;ldquo;read&amp;rdquo; better. Take this, for example:</source>
          <target state="translated">对于非平凡的计算， &lt;code&gt;COMPUTE&lt;/code&gt; 语句&amp;ldquo;读取&amp;rdquo;效果更好。以这个为例：</target>
        </trans-unit>
        <trans-unit id="a39b87b77ac08a2facf379872c177dbaf2f50de3" translate="yes" xml:space="preserve">
          <source>For non-trivial computations, &lt;code&gt;COMPUTE&lt;/code&gt; statements may execute faster than the equivalent chain of basic arithmetic statements. For example, the COMPUTE statement shown above executes about 25% faster on my computer using GnuCOBOL than does the MULTIPLY-ADD-DIVIDE sequence.</source>
          <target state="translated">对于非平凡的计算， &lt;code&gt;COMPUTE&lt;/code&gt; 语句的执行速度可能比基本算术语句的等效链更快。例如，上面显示的COMPUTE语句在我的计算机上使用GnuCOBOL的执行速度比MULTIPLY-ADD-DIVIDE序列的执行速度快约25％。</target>
        </trans-unit>
        <trans-unit id="0033fcaf736090140a9ae955ceeeed639d0db017" translate="yes" xml:space="preserve">
          <source>For non-trivial computations,&lt;code&gt;COMPUTE&lt;/code&gt;statements &quot;read&quot; better. Take this, for example:</source>
          <target state="translated">对于非平凡的计算， &lt;code&gt;COMPUTE&lt;/code&gt; 语句&amp;ldquo;读取&amp;rdquo;效果更好。以这个为例：</target>
        </trans-unit>
        <trans-unit id="4b25cf83aa9b241d27a0438f702e22b38e6a5771" translate="yes" xml:space="preserve">
          <source>For non-trivial computations,&lt;code&gt;COMPUTE&lt;/code&gt;statements may execute faster than the equivalent chain of basic arithmetic statements. For example, the COMPUTE statement shown above executes about 25% faster on my computer using GnuCOBOL than does the MULTIPLY-ADD-DIVIDE sequence.</source>
          <target state="translated">对于非平凡的计算， &lt;code&gt;COMPUTE&lt;/code&gt; 语句的执行速度可能比基本算术语句的等效链更快。例如，上面显示的COMPUTE语句在我的计算机上使用GnuCOBOL的执行速度比MULTIPLY-ADD-DIVIDE序列的执行速度快约25％。</target>
        </trans-unit>
        <trans-unit id="4921ac486a9a7a241c39c923f2dc1b53c77e5445" translate="yes" xml:space="preserve">
          <source>For purposes of comparison, trailing spaces are truncated from the operands except that an operand consisting of all spaces is truncated to a single space.</source>
          <target state="translated">为了比较,除了由所有空格组成的操作数被截断为一个空格之外,操作数的尾部空格都被截断。</target>
        </trans-unit>
        <trans-unit id="4ea212aeaa1a2268b2a88fc06fad4dfb6854c1d1" translate="yes" xml:space="preserve">
          <source>For quite a while now (back to the late 1970&amp;rsquo;s), the</source>
          <target state="translated">现在（回溯到1970年代后期），</target>
        </trans-unit>
        <trans-unit id="483a043da3e58761a7a31d92b7cee03f34d3a0e9" translate="yes" xml:space="preserve">
          <source>For quite a while now (back to the late 1970&amp;rsquo;s), the &quot;sequence number area&quot; of a COBOL statement (columns 1-6) has come to be used as a change indicator area. Programmers would place a code in columns 1-6 of every line they changed in a program. The author works in a COBOL shop where change indicators of the form &quot;xxmmyy&quot; are required on every altered line of a program &amp;mdash; &quot;xx&quot; is the initials of the programmer while &quot;mmyy&quot; are the month and two-digit year of the date the change was made. This is frequently accompanied by a comment block at or near the top of a COBOL program providing general documentation of what changes were made and what change indicator was used to mark that change.</source>
          <target state="translated">现在已经很长一段时间了（回到1970年代后期），COBOL语句的&amp;ldquo;序列号区域&amp;rdquo;（第1-6列）已被用作变更指示符区域。程序员将在他们在程序中更改的每一行的1-6列中放置一个代码。作者在COBOL商店工作，在程序的每条更改的行上都需要使用&amp;ldquo; xxmmyy&amp;rdquo;形式的更改指示符-&amp;ldquo; xx&amp;rdquo;是程序员的姓名缩写，而&amp;ldquo; mmyy&amp;rdquo;是日期的月份和两位数字进行了更改。这通常在COBOL程序顶部或附近带有注释框，该注释框提供有关所做的更改以及使用哪些更改指示符标记更改的常规文档。</target>
        </trans-unit>
        <trans-unit id="457470efdde973d009f597e9d358f8aba703173f" translate="yes" xml:space="preserve">
          <source>For syntax details for the &lt;code&gt;ORGANIZATION&lt;/code&gt; clause, see next group of paragraphs.</source>
          <target state="translated">有关 &lt;code&gt;ORGANIZATION&lt;/code&gt; 子句的语法详细信息，请参见下一组段落。</target>
        </trans-unit>
        <trans-unit id="e2dea5e1669c0a9fe3c1fbcb48cb6bd943c60b26" translate="yes" xml:space="preserve">
          <source>For the sake of brevity, this document lists the data in three columns.</source>
          <target state="translated">为简洁起见,本文件分三栏列出数据。</target>
        </trans-unit>
        <trans-unit id="aa9a0c097479cba30f19eaa01767298dde8ef7ef" translate="yes" xml:space="preserve">
          <source>For the values specified on a &lt;code&gt;PAGE LIMIT&lt;/code&gt; clause to be valid, all of the following must be true:</source>
          <target state="translated">为了使 &lt;code&gt;PAGE LIMIT&lt;/code&gt; 子句上指定的值有效，以下所有条件必须为真：</target>
        </trans-unit>
        <trans-unit id="ba325520d21c79af4680da537a3249fca4c6eeab" translate="yes" xml:space="preserve">
          <source>For the values specified on a&lt;code&gt;PAGE LIMIT&lt;/code&gt;clause to be valid, all of the following must be true:</source>
          <target state="translated">为了使 &lt;code&gt;PAGE LIMIT&lt;/code&gt; 子句上指定的值有效，以下所有条件必须为真：</target>
        </trans-unit>
        <trans-unit id="6b68ca39097c0a0bedb3dc7024be567498339bfa" translate="yes" xml:space="preserve">
          <source>For those wishing to learn COBOL for the first time, Gary can strongly recommend the following resources.</source>
          <target state="translated">对于那些希望第一次学习COBOL的人,Gary可以强烈推荐以下资源。</target>
        </trans-unit>
        <trans-unit id="efdae81d538ace29e7236aee7c1c96a4ee6706e5" translate="yes" xml:space="preserve">
          <source>For trivial computations, on the other hand, I prefer the inherent readability of a statement such as this:</source>
          <target state="translated">另一方面,对于琐碎的计算,我更喜欢这样的语句的内在可读性。</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="410ac084c444abe7ef2e13dea30c88749ac663a7" translate="yes" xml:space="preserve">
          <source>Format 1 of the &lt;code&gt;REPLACE&lt;/code&gt; statement can be used to make changes to program source code in much the same way as the  &lt;code&gt;REPLACING&lt;/code&gt; option of the &lt;code&gt;COPY&lt;/code&gt; statement can, via these options:</source>
          <target state="translated">通过以下选项， &lt;code&gt;REPLACE&lt;/code&gt; 语句的格式1可用于更改程序源代码，其方式与 &lt;code&gt;COPY&lt;/code&gt; 语句的 &lt;code&gt;REPLACING&lt;/code&gt; 选项几乎相同：</target>
        </trans-unit>
        <trans-unit id="09bebf0bea412802e3fbb625d9294d89526d28f2" translate="yes" xml:space="preserve">
          <source>Format 1 of the&lt;code&gt;REPLACE&lt;/code&gt;statement can be used to make changes to program source code in much the same way as the&lt;code&gt;REPLACING&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;REPLACE&lt;/code&gt; 语句的格式1 可以用于更改程序源代码，其方式与 &lt;code&gt;REPLACING&lt;/code&gt; 几乎相同</target>
        </trans-unit>
        <trans-unit id="dcc8ef045e79317e7c9e712ad4f3b0696cfbb717" translate="yes" xml:space="preserve">
          <source>Format a numeric item for output, including thousands-separators (&amp;lsquo;</source>
          <target state="translated">格式化数字项目以输出，包括数千个分隔符（'</target>
        </trans-unit>
        <trans-unit id="e143df1aa83eabbe82d17220703bff1e6c2ae88e" translate="yes" xml:space="preserve">
          <source>Free Format Mode</source>
          <target state="translated">自由格式模式</target>
        </trans-unit>
        <trans-unit id="fbc349f93c5e079ef91504e8bcea3293322299f8" translate="yes" xml:space="preserve">
          <source>From the sequence of &amp;lt;</source>
          <target state="translated">从&amp;lt;</target>
        </trans-unit>
        <trans-unit id="df46413f7f4a5b9afba020897df1c289f4be82fa" translate="yes" xml:space="preserve">
          <source>From the sequence of &lt;var&gt;identifier-1&lt;/var&gt; data items specified on the &lt;code&gt;INITIALIZE&lt;/code&gt; statement, a list of initialized fields referred to as the</source>
          <target state="translated">从在 &lt;code&gt;INITIALIZE&lt;/code&gt; 语句上指定的 &lt;var&gt;identifier-1&lt;/var&gt; 数据项的序列中，一个初始化字段的列表被称为</target>
        </trans-unit>
        <trans-unit id="ffd07c1bac910139b31da58ed3629443089db490" translate="yes" xml:space="preserve">
          <source>Full awareness of where the &quot;pen&quot; is about to &quot;write&quot; on the current page, automatically forcing an eject to a new page, along with the automatic generation of a page footer to close the old page and/or a page header to begin the new one.</source>
          <target state="translated">充分意识到 &quot;笔 &quot;即将在当前页面上 &quot;书写 &quot;的位置,自动强制弹出到新页面,同时自动生成页脚关闭旧页面和/或页眉开始新页面。</target>
        </trans-unit>
        <trans-unit id="b45a6d9d6000937f47f8b7fba24889e8e6116874" translate="yes" xml:space="preserve">
          <source>Full awareness of where the &amp;ldquo;pen&amp;rdquo; is about to &amp;ldquo;write&amp;rdquo; on the current page, automatically forcing an eject to a new page, along with the automatic generation of a page footer to close the old page and/or a page header to begin the new one.</source>
          <target state="translated">充分了解&amp;ldquo;笔&amp;rdquo;在当前页面上的&amp;ldquo;书写&amp;rdquo;位置，自动强制弹出到新页面，并自动生成页面页脚以关闭旧页面和/或页面标题以开始新的那一个。</target>
        </trans-unit>
        <trans-unit id="3a8b63681a5465651b7dd860e482efb9e8de5eee" translate="yes" xml:space="preserve">
          <source>Full-line comments</source>
          <target state="translated">全行评论</target>
        </trans-unit>
        <trans-unit id="a21a4b632492cfc3397cd22cf7495b9aac4c3cd0" translate="yes" xml:space="preserve">
          <source>Full-line comments with form-feed</source>
          <target state="translated">带表格反馈的全行评论</target>
        </trans-unit>
        <trans-unit id="a09ae3cf11bf198bd67625dda3216ea87527262f" translate="yes" xml:space="preserve">
          <source>Function argument error</source>
          <target state="translated">函数参数错误</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="fe94fb61bab790759d07739129a3829c99d0ddcc" translate="yes" xml:space="preserve">
          <source>GENERATE Syntax</source>
          <target state="translated">GENERATE 语法</target>
        </trans-unit>
        <trans-unit id="ce7e9bdff283283e8c751261303522d7a587ceec" translate="yes" xml:space="preserve">
          <source>GENERATE, GET, GIVING, GLOBAL, GO, GOBACK, GREATER, GRID, GROUP, GROUP-USAGE</source>
          <target state="translated">生成,得到,奉献,全球,去,归来,更大,GRID,GROUP,GROUP-USAGE.</target>
        </trans-unit>
        <trans-unit id="ce40a1df1f0f92cc5772759de30fb76faa874571" translate="yes" xml:space="preserve">
          <source>GENERATE, GET, GIVING, GLOBAL, GOBACK, GO-BACK, GO-FORWARD, GO-HOME, GO-SEARCH, GO, GRAPHICAL, GREATER, GRID, GROUP-USAGE, GROUP-VALUE, GROUP</source>
          <target state="translated">GENERATE,GET,GIVING,GLOBAL,GOBACK,GO-BACK,GO-FORWARD,GO-HOME,GO-SEARCH,GO,GRAPHICAL,GREATER,GRID,GROUP-USAGE,GROUP-VALUE,GROUP</target>
        </trans-unit>
        <trans-unit id="3f77fc06eaeeaf7f12de14c907a75f7348ac4dc4" translate="yes" xml:space="preserve">
          <source>GLOBAL Attribute Syntax</source>
          <target state="translated">全球属性语法</target>
        </trans-unit>
        <trans-unit id="de1cb4189a6066e305ef5c9f7a84a37a249dad4c" translate="yes" xml:space="preserve">
          <source>GO TO DEPENDING ON</source>
          <target state="translated">转到依赖</target>
        </trans-unit>
        <trans-unit id="be6aeb1acd05ec878a2af6fecff181b13e85aa9a" translate="yes" xml:space="preserve">
          <source>GO TO DEPENDING ON Syntax</source>
          <target state="translated">转到根据语法</target>
        </trans-unit>
        <trans-unit id="64f22d3218b9eaee10fe86a76b0f4f7308747bfe" translate="yes" xml:space="preserve">
          <source>GOBACK Syntax</source>
          <target state="translated">GOBACK 语法</target>
        </trans-unit>
        <trans-unit id="508368112dc00f3cf1200af84f7e4f2f7a3b1cbd" translate="yes" xml:space="preserve">
          <source>GROUP-INDICATE Attribute Syntax</source>
          <target state="translated">GROUP-INDICATE 属性 语法说明</target>
        </trans-unit>
        <trans-unit id="c9af09d3388e8d49bb54cf04c1c03cad69919dbf" translate="yes" xml:space="preserve">
          <source>Generally, these routines are intended to match those available in Micro Focus COBOL, ACUCOBOL and directly for GnuCOBOL.</source>
          <target state="translated">一般来说,这些例程旨在匹配Micro Focus COBOL、ACUCOBOL和直接用于GnuCOBOL的例程。</target>
        </trans-unit>
        <trans-unit id="9d41e5d8aa938481797b811e06ef4d213ca2b12d" translate="yes" xml:space="preserve">
          <source>Generic terms representing user-defined substitutable items will be shown entirely in lower-case in syntax diagrams. When such items are referenced in text, they will appear as &amp;lt;</source>
          <target state="translated">代表用户定义的可替换项的通用术语将在语法图中完全以小写形式显示。在文本中引用此类项目时，它们将显示为&amp;lt;</target>
        </trans-unit>
        <trans-unit id="39e33c54ed774d897c1886a402826062bfaee877" translate="yes" xml:space="preserve">
          <source>Generic terms representing user-defined substitutable items will be shown entirely in lower-case in syntax diagrams. When such items are referenced in text, they will appear as &lt;var&gt;substitutable-items&lt;/var&gt;.</source>
          <target state="translated">代表用户定义的可替换项的通用术语将在语法图中完全以小写形式显示。当在文本中引用此类项目时，它们将显示为可 &lt;var&gt;substitutable-items&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9457bdd27c6a3d78025d6c377d1adcbbc659a08" translate="yes" xml:space="preserve">
          <source>Getting file information (size and last-modification date/time)</source>
          <target state="translated">获取文件信息(大小和最后修改日期/时间)</target>
        </trans-unit>
        <trans-unit id="75e08852c633c9bcebe7ab91746503bd91ff4946" translate="yes" xml:space="preserve">
          <source>Getting the length (in bytes) of an argument passed to a subroutine</source>
          <target state="translated">获取传递给子程序的参数的长度(以字节为单位)。</target>
        </trans-unit>
        <trans-unit id="838fcc5009c91a67ccafcd3d8a98dceb9843f0c5" translate="yes" xml:space="preserve">
          <source>Giving a table an initial, compile-time value is one of the trickier aspects of COBOL data definition. There are basically three standard techniques and a fourth that people familiar with other COBOL implementations but new to GnuCOBOL may find interesting. So, here are the three</source>
          <target state="translated">给一个表一个初始的、编译时的值是COBOL数据定义中比较棘手的一个方面。基本上有三种标准技术和第四种技术,熟悉其他COBOL实现但对GnuCOBOL不熟悉的人可能会觉得有趣。那么,以下是三种技术</target>
        </trans-unit>
        <trans-unit id="dacd5d80181f68a262558fbeed5d04078293a6de" translate="yes" xml:space="preserve">
          <source>GnuCOBOL</source>
          <target state="translated">GnuCOBOL</target>
        </trans-unit>
        <trans-unit id="0f9a00d4af4500b63568bfe0a468268ec41fa076" translate="yes" xml:space="preserve">
          <source>GnuCOBOL Programmer&amp;rsquo;s Guide</source>
          <target state="translated">GnuCOBOL程序员指南</target>
        </trans-unit>
        <trans-unit id="081f0e8a59ba2bfacc1ba96aeec3dec3e6c1b941" translate="yes" xml:space="preserve">
          <source>GnuCOBOL Quick Reference</source>
          <target state="translated">GnuCOBOL快速参考</target>
        </trans-unit>
        <trans-unit id="b879a384bcf6b18e0b722cf0970e253d133c9742" translate="yes" xml:space="preserve">
          <source>GnuCOBOL Sample Programs</source>
          <target state="translated">GnuCOBOL示例程序</target>
        </trans-unit>
        <trans-unit id="2015e1c594285c68a45a46a4c1c754031a21ab4b" translate="yes" xml:space="preserve">
          <source>GnuCOBOL always behaves as if the &lt;code&gt;WITH DUPLICATES IN ORDER&lt;/code&gt; clause is specified, even if it isn&amp;rsquo;t.</source>
          <target state="translated">GnuCOBOL始终表现得就像指定了 &lt;code&gt;WITH DUPLICATES IN ORDER&lt;/code&gt; 子句一样，即使未指定也是如此。</target>
        </trans-unit>
        <trans-unit id="e9fc1fe76cf391a32dad55a122f4e0a0353992f7" translate="yes" xml:space="preserve">
          <source>GnuCOBOL always behaves as if the&lt;code&gt;WITH DUPLICATES IN ORDER&lt;/code&gt;clause is specified, even if it isn&amp;rsquo;t.</source>
          <target state="translated">GnuCOBOL始终表现得就像指定了 &lt;code&gt;WITH DUPLICATES IN ORDER&lt;/code&gt; 子句一样，即使未指定也是如此。</target>
        </trans-unit>
        <trans-unit id="7ad04b4d1ad6af7bea77754b5641545c0ecdeb13" translate="yes" xml:space="preserve">
          <source>GnuCOBOL considers  &lt;code&gt;ASCII&lt;/code&gt;,  &lt;code&gt;STANDARD-1&lt;/code&gt; and  &lt;code&gt;STANDARD-2&lt;/code&gt; to be interchangeable.</source>
          <target state="translated">GnuCOBOL认为 &lt;code&gt;ASCII&lt;/code&gt; ， &lt;code&gt;STANDARD-1&lt;/code&gt; 和 &lt;code&gt;STANDARD-2&lt;/code&gt; 是可互换的。</target>
        </trans-unit>
        <trans-unit id="9e90bf626298379ff7d3f8b411b399e5608f6660" translate="yes" xml:space="preserve">
          <source>GnuCOBOL considers&lt;code&gt;ASCII&lt;/code&gt;</source>
          <target state="translated">GnuCOBOL考虑 &lt;code&gt;ASCII&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c9a66a6ceb8182d84df581737874a3597f8a4882" translate="yes" xml:space="preserve">
          <source>GnuCOBOL controls concurrent-file access at the highest level through the concept of file sharing, enforced when a program attempts to open a file. This is accomplished via a UNIX operating-system routine called &lt;code&gt;fcntl&lt;/code&gt;. That module is not currently supported by Windows and is not present in the MinGW Unix-emulation package. GnuCOBOL builds created using a MinGW environment will be incapable of supporting file-sharing controls &amp;mdash; files will always be shared in such environments. A GnuCOBOL build created using the Cygwin environment on Windows</source>
          <target state="translated">GnuCOBOL通过文件共享的概念在最高级别上控制并发文件访问，该文件共享是在程序尝试打开文件时实施的。这是通过称为 &lt;code&gt;fcntl&lt;/code&gt; 的UNIX操作系统例程完成的。Windows当前不支持该模块，MinGW Unix仿真程序包中不存在该模块。使用MinGW环境创建的GnuCOBOL版本将无法支持文件共享控件-文件将始终在此类环境中共享。在Windows上使用Cygwin环境创建的GnuCOBOL构建</target>
        </trans-unit>
        <trans-unit id="a42d16409222bdca47c6d18f713049cd4e48dfe5" translate="yes" xml:space="preserve">
          <source>GnuCOBOL data items, like those of other COBOL implementations, are described in a hierarchical manner. This accommodates the fact that data items frequently need to be able to be broken up into subordinate items. Take for example, the following logical layout of a portion of a data item named &lt;code&gt;Employee&lt;/code&gt;:</source>
          <target state="translated">像其他COBOL实现的GnuCOBOL数据项一样，以分层方式进行描述。这适应了以下事实：数据项经常需要能够分解为从属项。例如，以下名为 &lt;code&gt;Employee&lt;/code&gt; 的数据项的一部分的逻辑布局：</target>
        </trans-unit>
        <trans-unit id="000801f5dd39b155259c54a804c2b16d6f375132" translate="yes" xml:space="preserve">
          <source>GnuCOBOL defines &lt;em&gt;compilation variables&lt;/em&gt; when various conditions are true. If the condition associated with a variable is false, the variable is not defined.</source>
          <target state="translated">当满足各种条件时，GnuCOBOL定义&lt;em&gt;编译变量&lt;/em&gt;。如果与变量关联的条件为假，则未定义变量。</target>
        </trans-unit>
        <trans-unit id="ade20b6aef56cd0ff2aed2427da9159fa14af39b" translate="yes" xml:space="preserve">
          <source>GnuCOBOL defines compilation variables when certain conditions are true.</source>
          <target state="translated">GnuCOBOL定义了某些条件为真时的编译变量。</target>
        </trans-unit>
        <trans-unit id="ce92bb9f1fd0286db331c868da0f7ad81d39837c" translate="yes" xml:space="preserve">
          <source>GnuCOBOL fully supports much of the ANSI 85 standard for COBOL (the only major exclusion is the Communications Module) and also supports some of the components of the COBOL2002 and COBOL2014 standards, such as the &lt;code&gt;SCREEN SECTION&lt;/code&gt; (see &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;), table-based &lt;code&gt;SORT&lt;/code&gt; (see &lt;a href=&quot;#Table-SORT&quot;&gt;Table SORT&lt;/a&gt;) and user-defined functions. There are others with more being added almost weekly.</source>
          <target state="translated">GnuCOBOL完全支持大多数针对COBOL的ANSI 85标准（唯一的主要例外是通信模块），还支持COBOL2002和COBOL2014标准的某些组件，例如 &lt;code&gt;SCREEN SECTION&lt;/code&gt; （请参阅&lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;），基于表的 &lt;code&gt;SORT&lt;/code&gt; （请参阅&lt;a href=&quot;#Table-SORT&quot;&gt;表SORT&lt;/a&gt;）和用户定义的函数。还有其他一些几乎每周都会添加的内容。</target>
        </trans-unit>
        <trans-unit id="12cf00b4626858f857b18dd724c1c9875f678c7e" translate="yes" xml:space="preserve">
          <source>GnuCOBOL fully supports much of the ANSI 85 standard for COBOL (the only major exclusion is the Communications Module) and also supports some of the components of the COBOL2002 standard, such as the&lt;code&gt;SCREEN SECTION&lt;/code&gt;(see &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;), table-based&lt;code&gt;SORT&lt;/code&gt;(see &lt;a href=&quot;#Table-SORT&quot;&gt;Table SORT&lt;/a&gt;) and user-defined functions.</source>
          <target state="translated">GnuCOBOL完全支持大部分针对COBOL的ANSI 85标准（唯一的主要例外是通信模块），并且还支持COBOL2002标准的某些组件，例如 &lt;code&gt;SCREEN SECTION&lt;/code&gt; （请参见&lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;），基于表的 &lt;code&gt;SORT&lt;/code&gt; （请参见&lt;a href=&quot;#Table-SORT&quot;&gt;表SORT&lt;/a&gt;）和用户定义的函数。</target>
        </trans-unit>
        <trans-unit id="97e9d0710dd9b847b88301b5ded4630f6ebd6cf5" translate="yes" xml:space="preserve">
          <source>GnuCOBOL has also been built as a truly native Windows application utilizing Microsoft&amp;rsquo;s freely-downloadable Visual Studio Express package to provide the C compiler and linker/loader. This approach does not lend itself well to a &quot;portable&quot; distribution.</source>
          <target state="translated">GnuCOBOL也已利用Microsoft的可免费下载的Visual Studio Express软件包构建为真正的Windows应用程序，以提供C编译器和链接器/加载器。这种方法不适用于&amp;ldquo;便携式&amp;rdquo;发行版。</target>
        </trans-unit>
        <trans-unit id="989809682a477dc64a331b0aedc581e943030842" translate="yes" xml:space="preserve">
          <source>GnuCOBOL has also been built as a truly native Windows application utilizing Microsoft&amp;rsquo;s freely-downloadable Visual Studio Express package to provide the C compiler and linker/loader. This approach does not lend itself well to a &amp;ldquo;portable&amp;rdquo; distribution.</source>
          <target state="translated">GnuCOBOL也已利用Microsoft的可免费下载的Visual Studio Express软件包构建为真正的Windows应用程序，以提供C编译器和链接器/加载器。这种方法不适用于&amp;ldquo;便携式&amp;rdquo;发行版。</target>
        </trans-unit>
        <trans-unit id="7ec4d6f9297d331838c7e1bc3be7fcca33c892c1" translate="yes" xml:space="preserve">
          <source>GnuCOBOL includes an implementation of the Report Writer Control System, or RWCS. The reportwriter module is now fully implemented as of version 3.0. This is a standardized, optional add-on feature to the COBOL language which automates much of the mechanics involved in the generation of printed reports by:</source>
          <target state="translated">GnuCOBOL包含了报告编写控制系统,或RWCS的实现。从3.0版本开始,报告编写模块已经完全实现。这是COBOL语言的一个标准化的、可选择的附加功能,它通过以下方式使生成打印报告的大部分机制自动化:</target>
        </trans-unit>
        <trans-unit id="748dc4c0de13fcba44056b388d77f85eed18ba64" translate="yes" xml:space="preserve">
          <source>GnuCOBOL is a free and open sourced COBOL compiler and runtime environment, written using the C programming language. GnuCOBOL is typically distributed in source-code form, and must then be built for your computer&amp;rsquo;s operating system using the system&amp;rsquo;s C compiler and loader. While originally developed for the UNIX and Linux operating systems, GnuCOBOL has also been successfully built for computers running OSX and Windows utilizing the UNIX-emulation features of such tools as Cygwin and MinGW. Also see the &lt;a href=&quot;https://savannah.gnu.org/projects/gnucobol&quot;&gt;GNU website&lt;/a&gt; for more information at.</source>
          <target state="translated">GnuCOBOL是一个免费的开源COBOL编译器和运行时环境，使用C编程语言编写。 GnuCOBOL通常以源代码形式分发，然后必须使用系统的C编译器和加载器为计算机的操作系统构建GnuCOBOL。 GnuCOBOL最初是为UNIX和Linux操作系统开发的，但现在它已经利用Cygwin和MinGW之类的工具的UNIX仿真功能成功地为运行OSX和Windows的计算机构建。另请参见&lt;a href=&quot;https://savannah.gnu.org/projects/gnucobol&quot;&gt;GNU网站&lt;/a&gt;以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="fe0e58c1b50f38b5d5939b86c78fc28f3f84cd98" translate="yes" xml:space="preserve">
          <source>GnuCOBOL is compiling the source unit.</source>
          <target state="translated">GnuCOBOL正在编译源单元。</target>
        </trans-unit>
        <trans-unit id="6ec33f04258b5a5ce00f804f3a7f12afecaa7b22" translate="yes" xml:space="preserve">
          <source>GnuCOBOL programs compiled with the</source>
          <target state="translated">GnuCOBOL程序是用该软件编译的。</target>
        </trans-unit>
        <trans-unit id="763499a319b22b6d28fecd96e5e4577d44422e38" translate="yes" xml:space="preserve">
          <source>GnuCOBOL programs compiled with the&lt;code&gt;-x&lt;/code&gt;switch</source>
          <target state="translated">用 &lt;code&gt;-x&lt;/code&gt; 开关编译的GnuCOBOL程序</target>
        </trans-unit>
        <trans-unit id="093449c074389871b78ba91d90fbe11fdc681ce0" translate="yes" xml:space="preserve">
          <source>GnuCOBOL provides for control over the final rounding process applied to the receiving fields on all arithmetic verbs. Each of the arithmetic statements (&lt;code&gt;ADD&lt;/code&gt; (see &lt;a href=&quot;#ADD&quot;&gt;ADD&lt;/a&gt;), &lt;code&gt;COMPUTE&lt;/code&gt; (see &lt;a href=&quot;#COMPUTE&quot;&gt;COMPUTE&lt;/a&gt;), &lt;code&gt;DIVIDE&lt;/code&gt; (see &lt;a href=&quot;#DIVIDE&quot;&gt;DIVIDE&lt;/a&gt;), &lt;code&gt;MULTIPLY&lt;/code&gt; (see &lt;a href=&quot;#MULTIPLY&quot;&gt;MULTIPLY&lt;/a&gt;) and &lt;code&gt;SUBTRACT&lt;/code&gt; (see &lt;a href=&quot;#SUBTRACT&quot;&gt;SUBTRACT&lt;/a&gt;)) statements allow an optional &lt;code&gt;ROUNDED&lt;/code&gt; clause to be applied to each receiving data item.</source>
          <target state="translated">GnuCOBOL提供了对应用于所有算术动词的接收字段的最终舍入过程的控制。每个算术语句（ &lt;code&gt;ADD&lt;/code&gt; （请参阅&lt;a href=&quot;#ADD&quot;&gt;ADD&lt;/a&gt;）， &lt;code&gt;COMPUTE&lt;/code&gt; （请参阅&lt;a href=&quot;#COMPUTE&quot;&gt;COMPUTE&lt;/a&gt;）， &lt;code&gt;DIVIDE&lt;/code&gt; （请参阅&lt;a href=&quot;#DIVIDE&quot;&gt;DIVIDE&lt;/a&gt;）， &lt;code&gt;MULTIPLY&lt;/code&gt; （请参阅&lt;a href=&quot;#MULTIPLY&quot;&gt;MULTIPLY&lt;/a&gt;）和 &lt;code&gt;SUBTRACT&lt;/code&gt; （请参阅&lt;a href=&quot;#SUBTRACT&quot;&gt;SUBTRACT&lt;/a&gt;））语句均允许对每个接收数据项应用可选的 &lt;code&gt;ROUNDED&lt;/code&gt; 子句。</target>
        </trans-unit>
        <trans-unit id="a9cf477a6985387b61c2ac288aa91a195ba51db5" translate="yes" xml:space="preserve">
          <source>GnuCOBOL run-time screen management must have been initialized prior to CALLing this routine in order to receive meaningful values. This means that a &lt;code&gt;DISPLAY screen-data-item&lt;/code&gt; statement (see &lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY screen-data-item&lt;/a&gt;) or a &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;) must have been executed prior to executing the &lt;code&gt;CALL&lt;/code&gt; statement.</source>
          <target state="translated">在调用此例程之前，必须先初始化GnuCOBOL运行时屏幕管理，以便接收有意义的值。这意味着在执行 &lt;code&gt;CALL&lt;/code&gt; 语句之前，必须先执行 &lt;code&gt;DISPLAY screen-data-item&lt;/code&gt; 语句（请参见&lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY屏幕数据项&lt;/a&gt;）或 &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; 语句（请参见&lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT屏幕数据项&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="20252ad5ff4fe084533d45067eda2369ad4e5568" translate="yes" xml:space="preserve">
          <source>GnuCOBOL run-time screen management must have been initialized prior to CALLing this routine in order to receive meaningful values. This means that a&lt;code&gt;DISPLAY screen-data-item&lt;/code&gt;statement (see &lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY screen-data-item&lt;/a&gt;) or a&lt;code&gt;ACCEPT screen-data-item&lt;/code&gt;statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;) must have been executed prior to executing the&lt;code&gt;CALL&lt;/code&gt;statement.</source>
          <target state="translated">在调用此例程之前，必须先初始化GnuCOBOL运行时屏幕管理，以便接收有意义的值。这意味着在执行 &lt;code&gt;CALL&lt;/code&gt; 语句之前，必须先执行 &lt;code&gt;DISPLAY screen-data-item&lt;/code&gt; 语句（请参见&lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY屏幕数据项&lt;/a&gt;）或 &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; 语句（请参见&lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT屏幕数据项&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b10af487d74e250e882604b1bf9bb79ff41e00cf" translate="yes" xml:space="preserve">
          <source>GnuCOBOL stores &lt;code&gt;FLOAT-DECIMAL-16&lt;/code&gt; and &lt;code&gt;FLOAT-DECIMAL-34&lt;/code&gt; data items using either Big-Endian or Little-Endian form, whichever is native to the system.</source>
          <target state="translated">GnuCOBOL使用Big-Endian或Little-Endian格式存储 &lt;code&gt;FLOAT-DECIMAL-16&lt;/code&gt; 和 &lt;code&gt;FLOAT-DECIMAL-34&lt;/code&gt; 数据项，以系统固有的形式为准。</target>
        </trans-unit>
        <trans-unit id="577f54cb6512af8b81a61cc8247c3cb8a51134a5" translate="yes" xml:space="preserve">
          <source>GnuCOBOL stores &lt;code&gt;FLOAT-LONG&lt;/code&gt; and &lt;code&gt;FLOAT-SHORT&lt;/code&gt; data items using either Big-Endian or Little-Endian form, whichever is native to the system.</source>
          <target state="translated">GnuCOBOL使用Big-Endian或Little-Endian格式（系统固有的任何一种）存储 &lt;code&gt;FLOAT-LONG&lt;/code&gt; 和 &lt;code&gt;FLOAT-SHORT&lt;/code&gt; 数据项。</target>
        </trans-unit>
        <trans-unit id="bca9afd1bdb28fa197bd33fb7a24153cdc7c56b4" translate="yes" xml:space="preserve">
          <source>GnuCOBOL stores&lt;code&gt;FLOAT-DECIMAL-16&lt;/code&gt;and&lt;code&gt;FLOAT-DECIMAL-34&lt;/code&gt;data items using either Big-Endian or Little-Endian form, whichever is native to the system.</source>
          <target state="translated">GnuCOBOL 使用Big-Endian或Little-Endian格式存储 &lt;code&gt;FLOAT-DECIMAL-16&lt;/code&gt; 和 &lt;code&gt;FLOAT-DECIMAL-34&lt;/code&gt; 数据项，以系统固有的形式为准。</target>
        </trans-unit>
        <trans-unit id="3b9f975d574fd7cc4ea7de4b02075b1a7eaf9bfc" translate="yes" xml:space="preserve">
          <source>GnuCOBOL stores&lt;code&gt;FLOAT-LONG&lt;/code&gt;and&lt;code&gt;FLOAT-SHORT&lt;/code&gt;data items using either Big-Endian or Little-Endian form, whichever is native to the system.</source>
          <target state="translated">GnuCOBOL 使用Big-Endian或Little-Endian格式（系统固有的任何一种）存储 &lt;code&gt;FLOAT-LONG&lt;/code&gt; 和 &lt;code&gt;FLOAT-SHORT&lt;/code&gt; 数据项。</target>
        </trans-unit>
        <trans-unit id="6ab3cffbe92c165a46df6ca158ad1c4a6a0c158c" translate="yes" xml:space="preserve">
          <source>GnuCOBOL subprograms may be created as either static or dynamic subprograms, as desired by the programmer.</source>
          <target state="translated">GnuCOBOL子程序可以根据程序员的需要创建为静态或动态子程序。</target>
        </trans-unit>
        <trans-unit id="90caf4fdcad7d8990c1ca4da35e29871f7d9e6ce" translate="yes" xml:space="preserve">
          <source>GnuCOBOL supports a wide variety of &amp;ldquo;intrinsic functions&amp;rdquo; that may be used anywhere in the PROCEDURE DIVISION where a literal is allowed. For example:</source>
          <target state="translated">GnuCOBOL支持各种各样的&amp;ldquo;内部函数&amp;rdquo;，这些过程可以在允许文字的&amp;ldquo;程序&amp;rdquo;部分中的任何位置使用。例如：</target>
        </trans-unit>
        <trans-unit id="5d2f811d109dc8d5b31442b8bf34dfb7a89f84e4" translate="yes" xml:space="preserve">
          <source>GnuCOBOL supports the following visual attribute specifications in the &lt;code&gt;SCREEN SECTION&lt;/code&gt; (see &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;):</source>
          <target state="translated">GnuCOBOL在&amp;ldquo; &lt;code&gt;SCREEN SECTION&lt;/code&gt; 支持以下视觉属性规范（请参阅&amp;ldquo;&lt;a href=&quot;#SCREEN-SECTION&quot;&gt;屏幕部分&amp;rdquo;&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="183088592eb0fa2ad8ba5f34425e030453ebfcc8" translate="yes" xml:space="preserve">
          <source>GnuCOBOL supports the following visual attribute specifications in the&lt;code&gt;SCREEN SECTION&lt;/code&gt;(see &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;):</source>
          <target state="translated">GnuCOBOL在&amp;ldquo; &lt;code&gt;SCREEN SECTION&lt;/code&gt; 支持以下视觉属性规范（请参见&amp;ldquo; &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;屏幕部分&amp;rdquo;&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="4323e46dfc1114d37bb106302840110ba00746d3" translate="yes" xml:space="preserve">
          <source>GnuCOBOL uses compiler configuration files to define various options that will control the compilation process. These configuration files are specified using the</source>
          <target state="translated">GnuCOBOL使用编译器配置文件来定义各种控制编译过程的选项。这些配置文件是用</target>
        </trans-unit>
        <trans-unit id="6684809df42a659397430ece5dce09f5dd77386c" translate="yes" xml:space="preserve">
          <source>GnuCOBOL uses compiler configuration files to define various options that will control the compilation process. These configuration files are specified using the&lt;code&gt;-conf&lt;/code&gt;switch</source>
          <target state="translated">GnuCOBOL使用编译器配置文件来定义将控制编译过程的各种选项。这些配置文件是使用 &lt;code&gt;-conf&lt;/code&gt; 开关指定的</target>
        </trans-unit>
        <trans-unit id="0825d5ebac283b0d7888040222d108fb9bbc2f52" translate="yes" xml:space="preserve">
          <source>GnuCOBOL, like other COBOL dialects, includes a number of data items that are automatically available to a programmer without the need to actually define them in the data division. COBOL refers to such items as registers or special registers. The special registers available to a GnuCOBOL program are as follows:</source>
          <target state="translated">GnuCOBOL和其他COBOL方言一样,包括一些数据项,这些数据项可以自动提供给程序员,而不需要在数据划分中实际定义它们。COBOL将这类项目称为寄存器或特殊寄存器。GnuCOBOL程序可用的特殊寄存器如下。</target>
        </trans-unit>
        <trans-unit id="3bd06fc3f53a54465c3ccaa768b1a3b1875dd413" translate="yes" xml:space="preserve">
          <source>GnuCOBOL, like other COBOL implementations, supports a number of reserved words that may be used to represent a specific literal value. These are known as figurative constants. See &lt;a href=&quot;#Figurative-Constants&quot;&gt;Figurative Constants&lt;/a&gt;, for more information.</source>
          <target state="translated">与其他COBOL实现一样，GnuCOBOL支持许多保留字，这些保留字可用于表示特定的文字值。这些被称为图形常数。有关更多信息，请参见&lt;a href=&quot;#Figurative-Constants&quot;&gt;图形常量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e2bb4d252c23fe267cb78311b78a5c392a8eb567" translate="yes" xml:space="preserve">
          <source>Good programmers have &amp;mdash; for decades &amp;mdash; maintained their own skeleton &quot;template&quot; programs for a variety of program types; simply load a template into a text editor and you&amp;rsquo;ve got a good start to the program&amp;hellip;</source>
          <target state="translated">优秀的程序员几十年来一直为各种程序类型维护自己的框架式&amp;ldquo;模板&amp;rdquo;程序。只需将模板加载到文本编辑器中，您就可以很好地开始程序了&amp;hellip;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="79b4a37e7986f285a68bde2a7f6753b7d96b28bf" translate="yes" xml:space="preserve">
          <source>Good programmers have &amp;mdash; for decades &amp;mdash; maintained their own skeleton &amp;ldquo;template&amp;rdquo; programs for a variety of program types; simply load a template into a text editor and you&amp;rsquo;ve got a good start to the program&amp;hellip;</source>
          <target state="translated">优秀的程序员数十年来一直为各种程序类型维护自己的框架式&amp;ldquo;模板&amp;rdquo;程序。只需将模板加载到文本编辑器中，您就可以很好地开始该程序了&amp;hellip;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="7bb1297cd4586126018027c7f1e1612420c22c4d" translate="yes" xml:space="preserve">
          <source>Green: COB-COLOR-GREEN</source>
          <target state="translated">绿色:COB-COLOR-GREEN。</target>
        </trans-unit>
        <trans-unit id="7c42686edc5c14ca17081cedfebfa14c924ebc58" translate="yes" xml:space="preserve">
          <source>Group Item</source>
          <target state="translated">集团项目</target>
        </trans-unit>
        <trans-unit id="df7d4a9ed92798538291678b66f3ab2363cff6fa" translate="yes" xml:space="preserve">
          <source>Group Item &amp;mdash; A group item in which debugging information generated by a &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; section in the declaratives area of the procedure division will place information documenting why the &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; procedure was invoked. Consult the &lt;code&gt;DECLARATIVES&lt;/code&gt; (see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) documentation for information on the structure of this register.</source>
          <target state="translated">组项目-组项目，其中由 &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; 部分在过程分区的声明性区域中生成的调试信息将放置记录为何调用 &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; 过程的信息。有关该寄存器结构的信息，请查阅 &lt;code&gt;DECLARATIVES&lt;/code&gt; （请参阅&lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;）文档。</target>
        </trans-unit>
        <trans-unit id="abf442e977221f7e251a5aee4a674647ed69f44a" translate="yes" xml:space="preserve">
          <source>Group Item &amp;mdash; A group item in which debugging information generated by a&lt;code&gt;USE FOR DEBUGGING&lt;/code&gt;section in the declaratives area of the procedure division will place information documenting why the&lt;code&gt;USE FOR DEBUGGING&lt;/code&gt;procedure was invoked. Consult the&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) documentation for information on the structure of this register.</source>
          <target state="translated">组项目-组项目，其中由 &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; 部分在过程分区的声明性区域中生成的调试信息将放置记录为何调用 &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; 过程的信息。有关该寄存器结构的信息，请查阅 &lt;code&gt;DECLARATIVES&lt;/code&gt; （请参阅&lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;）文档。</target>
        </trans-unit>
        <trans-unit id="31b43f990792fb2f0f7720e964fcf810fe794cb0" translate="yes" xml:space="preserve">
          <source>Group items (those without  &lt;code&gt;PICTURE&lt;/code&gt; clauses) are frequently used to describe entire lines of a report, while elementary items (those with a picture clause) are frequently used to describe specific fields of information on the report. When this coding convention is being used, group items will have &lt;code&gt;LINE&lt;/code&gt; (see &lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt;) clauses and no &lt;code&gt;COLUMN&lt;/code&gt; (see &lt;a href=&quot;#COLUMN&quot;&gt;COLUMN&lt;/a&gt;) clauses while elementary items will be specified the other way around.</source>
          <target state="translated">分组项目（没有 &lt;code&gt;PICTURE&lt;/code&gt; 子句的项目）通常用于描述报告的整个行，而基本项目（具有图片的子句的项目）经常用于描述报告中特定的信息字段。使用此编码约定时，组项目将具有 &lt;code&gt;LINE&lt;/code&gt; （请参阅&lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt;）子句，而没有 &lt;code&gt;COLUMN&lt;/code&gt; （请参阅&lt;a href=&quot;#COLUMN&quot;&gt;COLUMN&lt;/a&gt;）子句，而基本项目将以其他方式指定。</target>
        </trans-unit>
        <trans-unit id="810a65e9b0bdcfef9d822c231c10d01c65b32ddf" translate="yes" xml:space="preserve">
          <source>Group items (those without&lt;code&gt;PICTURE&lt;/code&gt;</source>
          <target state="translated">群组项目（没有 &lt;code&gt;PICTURE&lt;/code&gt; 项目</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="fa57db087f0e8c33baf60078a3ea31594a8db65b" translate="yes" xml:space="preserve">
          <source>HANDLE, HAS-CHILDREN, HEADING-COLOR, HEADING-DIVIDER-COLOR, HEADING-FONT, HEADING, HEAVY, HEIGHT-IN-CELLS, HIDDEN-DATA, HIGH-COLOR, HIGHEST-ALGEBRAIC, HIGHLIGHT, HIGH-VALUES, HIGH-VALUE, HOT-TRACK, HSCROLL-POS, HSCROLL</source>
          <target state="translated">HANDLE,HAS-CHILDREN,HEADING-COLOR,HEADING-DIVIDER-COLOR,HEADING-FONT,HEADING,HEAVY,HEIGHT-IN-CELLS,HIDDEN-DATA,HIGH-COLOR,HIGH-ALGEBRAIC,HIGHLIGHT,HIGH-VALUES,HIGH-VALUE,HOT-TRACK,HSCROLL-POS,HSCROLL</target>
        </trans-unit>
        <trans-unit id="89a17ef0f66b4296a009bd40714a7d880bc71878" translate="yes" xml:space="preserve">
          <source>HEADING, HIGHEST-ALGEBRAIC, HIGHLIGHT, HIGH-VALUE, HIGH-VALUES</source>
          <target state="translated">标题,最高档次,高亮度,高价值,高价值。</target>
        </trans-unit>
        <trans-unit id="30cfc7dc90ba24ab43e38507c7e4463f0560ba02" translate="yes" xml:space="preserve">
          <source>HIGHEST-ALGEBRAIC Function Syntax</source>
          <target state="translated">最强大脑函数语法</target>
        </trans-unit>
        <trans-unit id="d60066848e06a51085c8e2354e105347e3c601c8" translate="yes" xml:space="preserve">
          <source>HIGHLIGHT Attribute Syntax</source>
          <target state="translated">HIGHLIGHT 属性 语法</target>
        </trans-unit>
        <trans-unit id="020f748f595dbf9466daa5cd4e6bc7d9ede66c6f" translate="yes" xml:space="preserve">
          <source>Had there been at least one space to the left and/or the right of the &lt;code&gt;-&lt;/code&gt;, there would have been no ambiguity &amp;mdash; the compiler would have been forced to use the individual &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; data items.</source>
          <target state="translated">曾经有过至少一个空间的左侧和/或右侧 &lt;code&gt;-&lt;/code&gt; ，就不会有任何含糊-编译器会被强制使用个人 &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt; 的数据项。</target>
        </trans-unit>
        <trans-unit id="8c6979d233b84b4e040cc3b6f33204115bd4f223" translate="yes" xml:space="preserve">
          <source>Had there been at least one space to the left and/or the right of the&lt;code&gt;-&lt;/code&gt; there would have been no ambiguity &amp;mdash; the compiler would have been forced to use the individual&lt;code&gt;C&lt;/code&gt;and&lt;code&gt;D&lt;/code&gt;data items.</source>
          <target state="translated">如果左侧和/或右侧至少有一个空格 &lt;code&gt;-&lt;/code&gt; 不会有歧义-编译器将被迫使用单独的 &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt; 数据项。</target>
        </trans-unit>
        <trans-unit id="87a433cf0bc677c32d39cd5b979920082688b536" translate="yes" xml:space="preserve">
          <source>Heading Area</source>
          <target state="translated">标题区域</target>
        </trans-unit>
        <trans-unit id="2ac9d02efcfc8c69f3e81956659315a414e9db18" translate="yes" xml:space="preserve">
          <source>Heading Area &amp;mdash; An exception to this is the situation where the report heading report group contains the &lt;code&gt;NEXT GROUP NEXT PAGE&lt;/code&gt; (see &lt;a href=&quot;#NEXT-GROUP&quot;&gt;NEXT GROUP&lt;/a&gt;) option; in those cases, the report heading will be presented on a page by itself (anywhere on that page) at the beginning of the report.</source>
          <target state="translated">标题区域-例外情况是报告标题报告组包含 &lt;code&gt;NEXT GROUP NEXT PAGE&lt;/code&gt; （请参阅&lt;a href=&quot;#NEXT-GROUP&quot;&gt;NEXT GROUP&lt;/a&gt;）选项；在这种情况下，报告标题将在报告开始处单独显示在页面上（该页面上的任何地方）。</target>
        </trans-unit>
        <trans-unit id="cbbb9cee65c6576a367576c2ac65ada91311b34f" translate="yes" xml:space="preserve">
          <source>Heading Area &amp;mdash; An exception to this is the situation where the report heading report group contains the&lt;code&gt;NEXT GROUP NEXT PAGE&lt;/code&gt;(see &lt;a href=&quot;#NEXT-GROUP&quot;&gt;NEXT GROUP&lt;/a&gt;) option; in those cases, the report heading will be presented on a page by itself (anywhere on that page) at the beginning of the report.</source>
          <target state="translated">标题区域-例外情况是报告标题报告组包含 &lt;code&gt;NEXT GROUP NEXT PAGE&lt;/code&gt; （请参阅&lt;a href=&quot;#NEXT-GROUP&quot;&gt;NEXT GROUP&lt;/a&gt;）选项；在这种情况下，报告标题将在报告开头单独显示在页面上（该页面上的任何地方）。</target>
        </trans-unit>
        <trans-unit id="9a3fc3dac7c2610f19172d33b654b99f82029bf8" translate="yes" xml:space="preserve">
          <source>Here are a few examples:</source>
          <target state="translated">下面是几个例子。</target>
        </trans-unit>
        <trans-unit id="a58d0be2a26b29065720289affde96b396953bc6" translate="yes" xml:space="preserve">
          <source>Here are some examples of how the precedence of operations affects the results of arithmetic expressions (all examples use numeric literals, to simplify the discussion).</source>
          <target state="translated">下面是一些关于运算的优先性如何影响算术表达式结果的例子(为了简化讨论,所有的例子都使用了数字文字)。</target>
        </trans-unit>
        <trans-unit id="ce8b7658bf191725329e97e66717da8863c93fce" translate="yes" xml:space="preserve">
          <source>Here are the facts &amp;mdash; draw your own conclusions as to which approach is more appropriate under which circumstances.</source>
          <target state="translated">这是事实，请您得出自己的结论，即在哪种情况下哪种方法更合适。</target>
        </trans-unit>
        <trans-unit id="71e41b379565b9db9a0898e306e44094c8f202bb" translate="yes" xml:space="preserve">
          <source>Here are the meanings of the three options:</source>
          <target state="translated">下面是三个选项的含义。</target>
        </trans-unit>
        <trans-unit id="53cbe05ea3a4478bf935f4356ab4ff0f5e1c960c" translate="yes" xml:space="preserve">
          <source>Here are the relevant sections of code in a program named</source>
          <target state="translated">以下是一个名为的程序中的相关代码部分</target>
        </trans-unit>
        <trans-unit id="8db79160667581172099438ddb7cbe10fdc25a56" translate="yes" xml:space="preserve">
          <source>Here are the relevant sections of code in a program named &quot;testprog&quot;, which is designed to simply announce if SWITCH-1 is on:</source>
          <target state="translated">下面是一个名为 &quot;testprog &quot;的程序中的相关代码,它的目的是简单地宣布SWITCH-1是否开启。</target>
        </trans-unit>
        <trans-unit id="4806c2364021b8f8145a30057c39a5142245883f" translate="yes" xml:space="preserve">
          <source>Here are the results:</source>
          <target state="translated">下面是结果。</target>
        </trans-unit>
        <trans-unit id="6bcf44b499d0088da0556d2de36d212cd7d4aaa3" translate="yes" xml:space="preserve">
          <source>Here are the rules about GnuCOBOL dynamically-loadable modules:</source>
          <target state="translated">下面是关于GnuCOBOL动态加载模块的规则。</target>
        </trans-unit>
        <trans-unit id="d98760fd5f7d0d451fc2f1b70dda01b46952cd2b" translate="yes" xml:space="preserve">
          <source>Here are two different &quot;Hello World&quot; applications &amp;mdash; one written in Java and the second in GnuCOBOL. First, the Java version:</source>
          <target state="translated">这是两个不同的&amp;ldquo; Hello World&amp;rdquo;应用程序-一个用Java编写，另一个用GnuCOBOL编写。首先，Java版本：</target>
        </trans-unit>
        <trans-unit id="9a7a5c011f0ce663c0dc595e94b546e1a82c50ac" translate="yes" xml:space="preserve">
          <source>Here are two different &amp;ldquo;Hello World&amp;rdquo; applications, one written in Java and the second in GnuCOBOL. First, the Java version:</source>
          <target state="translated">这是两个不同的&amp;ldquo; Hello World&amp;rdquo;应用程序，一个用Java编写，第二个用GnuCOBOL编写。首先，Java版本：</target>
        </trans-unit>
        <trans-unit id="e6bcd662dbb0c6100434bd63900ae3c2799a7347" translate="yes" xml:space="preserve">
          <source>Here are two examples of using &lt;code&gt;cobcrun&lt;/code&gt;. First, on a Unix, OSX or Windows/Cygwin system:</source>
          <target state="translated">这是使用 &lt;code&gt;cobcrun&lt;/code&gt; 的两个示例。首先，在Unix，OSX或Windows / Cygwin系统上：</target>
        </trans-unit>
        <trans-unit id="2486c63ce113fa9dfa91ee5ea183529c4d50239f" translate="yes" xml:space="preserve">
          <source>Here are two examples of using&lt;code&gt;cobcrun&lt;/code&gt; First, on a Unix, OSX or Windows/Cygwin system:</source>
          <target state="translated">这是在Unix，OSX或Windows / Cygwin系统上使用 &lt;code&gt;cobcrun&lt;/code&gt; First的两个示例：</target>
        </trans-unit>
        <trans-unit id="88f0b25a36a42c34f75db34b7878e30378e348fc" translate="yes" xml:space="preserve">
          <source>Here is a sample program that illustrates the EVALUATE statement.</source>
          <target state="translated">下面是一个说明EVALUATE语句的示例程序。</target>
        </trans-unit>
        <trans-unit id="b44351443986b8d6208b8077f937b80d2c5d797f" translate="yes" xml:space="preserve">
          <source>Here is an example of a main program (DEMOFACT) that calls both a subprogram (SUB) and a user-defined function (FUNC) to compute the factorial value of a number.</source>
          <target state="translated">这里是一个主程序(DEMOFACT)的例子,它同时调用一个子程序(SUB)和一个用户自定义函数(FUNC)来计算一个数字的阶乘值。</target>
        </trans-unit>
        <trans-unit id="fce56f05dd0a684307248e0509281b28f6150e2a" translate="yes" xml:space="preserve">
          <source>Here is an example. The following two GnuCOBOL statements both display the same result (27):</source>
          <target state="translated">下面是一个例子。下面两个GnuCOBOL语句都显示相同的结果(27)。</target>
        </trans-unit>
        <trans-unit id="b6e578854c806b2cf1a7f51f1181b4443af68716" translate="yes" xml:space="preserve">
          <source>Here is how the main program and the three subprograms could be compiled if the three subprograms are to be dynamic:</source>
          <target state="translated">下面是主程序和三个子程序的编译方法,如果三个子程序是动态的。</target>
        </trans-unit>
        <trans-unit id="b8a4250afe2b9b703be52c8963f7c7e83af93bec" translate="yes" xml:space="preserve">
          <source>Here is how these four programs would be compiled if the three subprograms are to be static:</source>
          <target state="translated">下面是这四个程序的编译方法,如果这三个子程序是静态的。</target>
        </trans-unit>
        <trans-unit id="beb1c1603f299093bba7034e28d01c9ea9428c93" translate="yes" xml:space="preserve">
          <source>Here is the data that the program will be reading. Each record reflects the aggregated benchmark scoring for one particular CPU, as scores for benchmarks against that CPU have been reported to the &lt;a href=&quot;https://gnucobol.sourceforge.io/HTML/cpubenchmark.net&quot;&gt;cpubenchmark.net&lt;/a&gt; website by their PassMark benchmark software. The data consists of four fields. Fields are separated from one another by a single comma. The descriptions of the fields are as follows:</source>
          <target state="translated">这是程序将要读取的数据。每条记录反映了一个特定CPU的汇总基准测试得分，因为针对该CPU的基准测试得分已通过其PassMark基准测试软件报告到&lt;a href=&quot;https://gnucobol.sourceforge.io/HTML/cpubenchmark.net&quot;&gt;cpubenchmark.net&lt;/a&gt;网站。数据包含四个字段。字段之间用一个逗号分隔。字段说明如下：</target>
        </trans-unit>
        <trans-unit id="3885b22c6e4bdc48af657c6fedb7ca8f97433747" translate="yes" xml:space="preserve">
          <source>Here is the data that the program will be reading. Each record reflects the aggregated benchmark scoring for one particular CPU, as scores for benchmarks against that CPU have been reported to the &lt;a href=&quot;https://open-cobol.sourceforge.io/HTML/cpubenchmark.net&quot;&gt;cpubenchmark.net&lt;/a&gt; website by their PassMark benchmark software. The data consists of four fields. Fields are separated from one another by a single comma. The descriptions of the fields are as follows:</source>
          <target state="translated">这是程序将要读取的数据。每条记录反映了一个特定CPU的汇总基准测试得分，因为针对该CPU的基准测试得分已通过其PassMark基准测试软件报告到&lt;a href=&quot;https://open-cobol.sourceforge.io/HTML/cpubenchmark.net&quot;&gt;cpubenchmark.net&lt;/a&gt;网站。数据包含四个字段。字段之间用一个逗号隔开。字段说明如下：</target>
        </trans-unit>
        <trans-unit id="b01180e30ff342f12b30bea352d08df8ee331a14" translate="yes" xml:space="preserve">
          <source>Here is the listing of a GnuCOBOL program that uses 01-level constants to display the length (in bytes) of the various picture-less usage types.</source>
          <target state="translated">这里列出了一个GnuCOBOL程序,该程序使用01级常量来显示各种无图使用类型的长度(以字节为单位)。</target>
        </trans-unit>
        <trans-unit id="1857cc7a022f0e1395961419f1f74e43d98e7680" translate="yes" xml:space="preserve">
          <source>Here is the program that will be producing the report. Pay attention to how the data is sorted and how the control hierarchy (&lt;code&gt;CONTROLS ARE&lt;/code&gt;) relates to the &lt;code&gt;SORT&lt;/code&gt;.</source>
          <target state="translated">这是将生成报告的程序。注意数据如何排序以及控件层次结构（ &lt;code&gt;CONTROLS ARE&lt;/code&gt; ）与 &lt;code&gt;SORT&lt;/code&gt; 的关系。</target>
        </trans-unit>
        <trans-unit id="73247c417733995d371c239937b20d07507d4db9" translate="yes" xml:space="preserve">
          <source>Here is the program that will be producing the report. Pay attention to how the data is sorted and how the control hierarchy &lt;code&gt;CONTROLS ARE&lt;/code&gt; relates to the&lt;code&gt;SORT&lt;/code&gt;</source>
          <target state="translated">这是将生成报告的程序。注意数据如何排序以及控件层次结构 &lt;code&gt;CONTROLS ARE&lt;/code&gt; 与 &lt;code&gt;SORT&lt;/code&gt; 的关系</target>
        </trans-unit>
        <trans-unit id="da6729e808d0a3e4a663c2fea411af7a2fdc2b58" translate="yes" xml:space="preserve">
          <source>Here we see that &lt;code&gt;PROG2&lt;/code&gt; is nested inside of &lt;code&gt;PROG1&lt;/code&gt; because there is no &lt;code&gt;END PROGRAM&lt;/code&gt; marker separating them. This means that data items or files defined within &lt;code&gt;PROG1&lt;/code&gt; can be used within &lt;code&gt;PROG2&lt;/code&gt; simply by attaching the &lt;code&gt;GLOBAL&lt;/code&gt; (see &lt;a href=&quot;#GLOBAL&quot;&gt;GLOBAL&lt;/a&gt;) attribute to them back in &lt;code&gt;PROG1&lt;/code&gt; when they are defined.</source>
          <target state="translated">在这里我们看到 &lt;code&gt;PROG2&lt;/code&gt; 嵌套在 &lt;code&gt;PROG1&lt;/code&gt; 内，因为没有 &lt;code&gt;END PROGRAM&lt;/code&gt; 标记将它们分开。这意味着内定义的数据项目或文件 &lt;code&gt;PROG1&lt;/code&gt; 可以内使用 &lt;code&gt;PROG2&lt;/code&gt; 简单地通过附加 &lt;code&gt;GLOBAL&lt;/code&gt; （参见&lt;a href=&quot;#GLOBAL&quot;&gt;GLOBAL&lt;/a&gt;）属性以它们放回 &lt;code&gt;PROG1&lt;/code&gt; 它们被定义时。</target>
        </trans-unit>
        <trans-unit id="e5a81b08e879fde5dd2a59dae3f46849e9f50742" translate="yes" xml:space="preserve">
          <source>Here we see that PROG2 is nested inside of PROG1 because there is no&lt;code&gt;END PROGRAM&lt;/code&gt;marker separating them. This means that data items or files defined within PROG1 can be used within PROG2 simply by attaching the&lt;code&gt;GLOBAL&lt;/code&gt;(see &lt;a href=&quot;#GLOBAL&quot;&gt;GLOBAL&lt;/a&gt;) attribute to them back in PROG1 when they are defined.</source>
          <target state="translated">在这里我们看到PROG2嵌套在PROG1内部，因为没有 &lt;code&gt;END PROGRAM&lt;/code&gt; 标记将它们分开。这意味着在PROG1中定义的数据项或文件可以在PROG2中使用，只需在定义它们时将 &lt;code&gt;GLOBAL&lt;/code&gt; （请参阅&lt;a href=&quot;#GLOBAL&quot;&gt;GLOBAL&lt;/a&gt;）属性附加到PROG1中即可。</target>
        </trans-unit>
        <trans-unit id="9e665b8afaa854f3affd19ae081739fadefc957c" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a demonstration:</source>
          <target state="translated">这是一个示范：</target>
        </trans-unit>
        <trans-unit id="1bb3a890739a2d89878b41828136b7843797b0c4" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a more practical view of the difference. Let&amp;rsquo;s say that a table has 1,000 entries in it. With a sequential search, on average, you&amp;rsquo;ll have to check 500 of them to find an entry and you&amp;rsquo;ll have to look at all 1,000 of them to find that an entry doesn&amp;rsquo;t exist.</source>
          <target state="translated">这是区别的更实际的看法。假设一个表中有1,000个条目。平均而言，通过顺序搜索，您将必须检查其中的500个才能找到条目，并且必须查看所有的1000个才能发现条目不存在。</target>
        </trans-unit>
        <trans-unit id="5e93bdc7d9e913c109cf4064444cedee83b88ddb" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a sample of a GnuCOBOL program that CALLs a C subprogram.</source>
          <target state="translated">这是一个调用C子程序的GnuCOBOL程序的示例。</target>
        </trans-unit>
        <trans-unit id="bce0f5ae6fe98feb4beb66b9de11f14f54d3934d" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a small example:</source>
          <target state="translated">这是一个小例子：</target>
        </trans-unit>
        <trans-unit id="79a379c34c53ce83d07e71356345ea69136a74d1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example:</source>
          <target state="translated">这是一个例子：</target>
        </trans-unit>
        <trans-unit id="b4f96988044521adc26ab35ce61bb5f09db1123c" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the output of the compilation process as well as the program&amp;rsquo;s execution. The example assumes a Windows system with a GnuCOBOL build that uses the GNU C compiler on that system; the technique works equally well regardless of which C compiler and which operating system you&amp;rsquo;re using.</source>
          <target state="translated">这是编译过程以及程序执行的输出。该示例假定Windows系统的GnuCOBOL版本使用该系统上的GNU C编译器。无论您使用哪个C编译器和哪个操作系统，该技术都同样有效。</target>
        </trans-unit>
        <trans-unit id="54b1a90f72334cf67c79da3608b8cff7cc194a79" translate="yes" xml:space="preserve">
          <source>Hexadecimal</source>
          <target state="translated">Hexadecimal</target>
        </trans-unit>
        <trans-unit id="411f51a5654b397be9062ca82d9069ac5e760156" translate="yes" xml:space="preserve">
          <source>Hexadecimal Alphanumeric Literal</source>
          <target state="translated">十六进制字母数字字词</target>
        </trans-unit>
        <trans-unit id="0622237faae035a0d62bd2b8400c09913d5beb12" translate="yes" xml:space="preserve">
          <source>Hexadecimal Numeric Literal</source>
          <target state="translated">十六进制数字文字</target>
        </trans-unit>
        <trans-unit id="94ab07f464da8a3b187f31192ac4d12a08adf1a8" translate="yes" xml:space="preserve">
          <source>Hexadecimal number using &lt;code&gt;H#&lt;/code&gt; or &lt;code&gt;X#&lt;/code&gt; &amp;lsquo;</source>
          <target state="translated">使用 &lt;code&gt;H#&lt;/code&gt; 或 &lt;code&gt;X#&lt;/code&gt; '的十六进制数</target>
        </trans-unit>
        <trans-unit id="9b5d84e4c523dc629848bb4349e680f8bf34c64b" translate="yes" xml:space="preserve">
          <source>Hexadecimal numeric literals</source>
          <target state="translated">十六进制数字字符</target>
        </trans-unit>
        <trans-unit id="fc83f87e3f62574b840ab2334e64d62930fb1c3c" translate="yes" xml:space="preserve">
          <source>Historically in the early 60&amp;rsquo;s programs were first punched on to paper tape and by the mid 60&amp;rsquo;s that was replaced almost totally, by punched cards although paper tape was still used by programmers for the odd few changes to their sources held on magnetic tape or disk as a portable paper tape punch could be put in your pocket. Now the problem with punched cards were there was 2,000 cards per box and that they could and did, get dropped. So, cc (column) 1 through 6 had the card sequence number in and that way if a box was dropped they could be feed in to a card sorter to be fixed. This was after the cards was cleaned up so that they were all in the same direction which one corner cut out helped.</source>
          <target state="translated">从历史上讲，在60年代初期，程序首先打在纸带上，到60年代中期，打孔卡几乎完全取代了程序，尽管程序员仍然使用纸带来改变磁带或磁盘上存储的源的奇数变化。便携式纸带打孔器可以放在口袋里。现在，打孔卡的问题是每盒有2,000张卡，而且它们可以而且确实会掉落。因此，cc（第1列至第6列）具有卡序列号，这样，如果放下一个盒子，它们可以送入固定的卡片分类器中。这是在清理卡之后，使它们都朝一个切角帮助的方向。</target>
        </trans-unit>
        <trans-unit id="82581b08d1abc17171e1f2f9cf9815374d6d8df7" translate="yes" xml:space="preserve">
          <source>Historically, back in the days when punched-cards were used to submit COBOL program source to a COBOL compiler, this part of a COBOL statement was reserved for a six-digit sequence number. While the contents of this area are ignored by COBOL compilers, it existed so that a program actually punched on 80-character cards could &amp;mdash; if the card deck were dropped on the floor &amp;mdash; be run through a card sorter machine and restored to it&amp;rsquo;s proper sequence. Of course, this isn&amp;rsquo;t necessary today; if truth be told, it hasn&amp;rsquo;t been necessary for a long time.</source>
          <target state="translated">从历史上看，在使用打孔卡将COBOL程序源提交给COBOL编译器的时代，COBOL语句的这一部分保留用于六位序列号。尽管该区域的内容被COBOL编译器忽略，但它的存在是为了使实际打在80个字符的卡片上的程序（如果卡片组掉落在地板上）可以通过卡片分类机运行并恢复到正确的顺序。当然，今天没有必要。如果说实话，很长一段时间都没有必要。</target>
        </trans-unit>
        <trans-unit id="02647b82d9fa83c81d555404d1e10b603758c168" translate="yes" xml:space="preserve">
          <source>Historically, back in the days when punched-cards were used to submit COBOL program source to a COBOL compiler, this part of a COBOL statement was reserved for a six-digit sequence number. While the contents of this area are ignored by COBOL compilers, it existed so that a program actually punched on 80-character cards could &amp;mdash; if the card deck were dropped on the floor &amp;mdash; be run through a card sorter machine and restored to its proper sequence. Of course, this isn&amp;rsquo;t necessary today; if truth be told, it hasn&amp;rsquo;t been necessary for a long time.</source>
          <target state="translated">从历史上看，在使用打孔卡将COBOL程序源提交给COBOL编译器的时代，COBOL语句的这一部分是保留给六位序列号的。尽管该区域的内容被COBOL编译器忽略，但它的存在是为了使实际上打在80个字符的卡片上的程序（如果卡片组掉落在地板上）可以通过卡片分类机运行，并恢复到正确的顺序。当然，今天没有必要。如果说实话，很长一段时间都没有必要。</target>
        </trans-unit>
        <trans-unit id="0df9e10180565ea1110b91a867b356bd0e25bf9c" translate="yes" xml:space="preserve">
          <source>How then do we inform the compiler that the &lt;code&gt;DISPLAY&lt;/code&gt; statement is outside the scope of the &lt;code&gt;IF&lt;/code&gt;?</source>
          <target state="translated">然后，我们如何通知编译器 &lt;code&gt;DISPLAY&lt;/code&gt; 语句不在 &lt;code&gt;IF&lt;/code&gt; 的范围之内？</target>
        </trans-unit>
        <trans-unit id="dbfbb76720b9c478938cb351772ad799b84f9efe" translate="yes" xml:space="preserve">
          <source>I also ran the tests multiple times, just to make sure I had consistent results (I did). Like I mentioned earlier, this is not a rigorous, scientific benchmark of numeric performance; it&amp;rsquo;s just a quick-and-dirty comparison.</source>
          <target state="translated">我还多次运行测试，以确保我得到一致的结果（确实如此）。就像我之前提到的，这不是严格的数字性能科学基准。这只是一个简单的比较。</target>
        </trans-unit>
        <trans-unit id="555eb23964b638ebb4898ef46762a788413b2a7a" translate="yes" xml:space="preserve">
          <source>I always include a numeric prefix to all procedure names I define, for the reasons stated earlier.</source>
          <target state="translated">出于前面所述的原因,我总是在我定义的所有存储过程名称中包含一个数字前缀。</target>
        </trans-unit>
        <trans-unit id="6ef71f90a853f2945a57020e6c1ee95aebd594b3" translate="yes" xml:space="preserve">
          <source>I changed the &lt;code&gt;CONTROLS ARE&lt;/code&gt; clause on the sample program from this:</source>
          <target state="translated">我从此更改了示例程序上的 &lt;code&gt;CONTROLS ARE&lt;/code&gt; 子句：</target>
        </trans-unit>
        <trans-unit id="df6a4fe99929dd991e0202127b86aa20cecf96af" translate="yes" xml:space="preserve">
          <source>I changed the&lt;code&gt;CONTROLS ARE&lt;/code&gt;clause on the sample program from this:</source>
          <target state="translated">我从此更改了示例程序上的 &lt;code&gt;CONTROLS ARE&lt;/code&gt; 子句：</target>
        </trans-unit>
        <trans-unit id="d4babbd3edc9eb4d910c787c66392fcc67f2231b" translate="yes" xml:space="preserve">
          <source>I do not use &lt;code&gt;THRU&lt;/code&gt; on any &lt;code&gt;MERGE&lt;/code&gt;, &lt;code&gt;PERFORM&lt;/code&gt; or &lt;code&gt;SORT&lt;/code&gt; statement unless the programming standards of the shop in which I am working require it. My reasoning for this is that it is too easy to accidentally introduce a new procedure into the scope of a &lt;code&gt;THRU&lt;/code&gt;.</source>
          <target state="translated">我不会在任何 &lt;code&gt;MERGE&lt;/code&gt; ， &lt;code&gt;PERFORM&lt;/code&gt; 或 &lt;code&gt;SORT&lt;/code&gt; 语句上使用 &lt;code&gt;THRU&lt;/code&gt; ，除非我工作所在商店的编程标准对此有要求。我的理由是，很容易将新过程意外地引入 &lt;code&gt;THRU&lt;/code&gt; 的范围。</target>
        </trans-unit>
        <trans-unit id="8d7255df40c7e6bd55c76738ac87c79c48b55013" translate="yes" xml:space="preserve">
          <source>I do not use&lt;code&gt;THRU&lt;/code&gt;on any&lt;code&gt;MERGE&lt;/code&gt;&lt;code&gt;PERFORM&lt;/code&gt;or&lt;code&gt;SORT&lt;/code&gt;statement unless the programming standards of the shop in which I am working require it. My reasoning for this is that it is too easy to accidentally introduce a new procedure into the scope of a&lt;code&gt;THRU&lt;/code&gt;</source>
          <target state="translated">除非我工作所在商店的编程标准要求，否则我不会在任何 &lt;code&gt;MERGE&lt;/code&gt; &lt;code&gt;PERFORM&lt;/code&gt; 或 &lt;code&gt;SORT&lt;/code&gt; 语句中使用 &lt;code&gt;THRU&lt;/code&gt; 。我的理由是，很容易意外地将新过程引入 &lt;code&gt;THRU&lt;/code&gt; 的范围</target>
        </trans-unit>
        <trans-unit id="1fbc97a4457717dc23d1ecc1bf25f471eabb9c4f" translate="yes" xml:space="preserve">
          <source>I like to use procedure division paragraphs and sections as follows:</source>
          <target state="translated">我喜欢用程序划分段和节,如下:</target>
        </trans-unit>
        <trans-unit id="80ed72858cef207934e285ac054f1c8a269fc88f" translate="yes" xml:space="preserve">
          <source>I-O status &quot;1x&quot;</source>
          <target state="translated">I-O状态 &quot;1x&quot;</target>
        </trans-unit>
        <trans-unit id="e7876f32dd29146c722eec80cdba831c36ef9026" translate="yes" xml:space="preserve">
          <source>I-O status &quot;2x&quot;</source>
          <target state="translated">I-O状态 &quot;2x&quot;</target>
        </trans-unit>
        <trans-unit id="76b397e0ec9019d1f6c9d9402f9be35add987c62" translate="yes" xml:space="preserve">
          <source>I-O status &quot;3x&quot;</source>
          <target state="translated">I-O状态 &quot;3x&quot;</target>
        </trans-unit>
        <trans-unit id="6eff1612faad7c99ae78ea1e6080ebc0dc3c4df1" translate="yes" xml:space="preserve">
          <source>I-O status &quot;4x&quot;</source>
          <target state="translated">I-O状态 &quot;4x&quot;</target>
        </trans-unit>
        <trans-unit id="67e793587f319a335dc7c63a71a23c530563d185" translate="yes" xml:space="preserve">
          <source>I-O status &quot;5x&quot;</source>
          <target state="translated">I-O状态 &quot;5x&quot;</target>
        </trans-unit>
        <trans-unit id="b8524f001cba70110ae60dee01287daded416b11" translate="yes" xml:space="preserve">
          <source>I-O status &quot;6x&quot;</source>
          <target state="translated">I-O状态 &quot;6x&quot;</target>
        </trans-unit>
        <trans-unit id="be335b5a5eadd43e4b4e63cf77557e87542095cf" translate="yes" xml:space="preserve">
          <source>I-O status &quot;9x&quot;</source>
          <target state="translated">I-O状态 &quot;9x&quot;</target>
        </trans-unit>
        <trans-unit id="6a40883c56a23e578d1618cce3df76e43d5b7350" translate="yes" xml:space="preserve">
          <source>I-O status &lt;code&gt;1x&lt;/code&gt;</source>
          <target state="translated">IO状态 &lt;code&gt;1x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87ff1a1275bf109eaff56708cd4e221f5ca0d8bc" translate="yes" xml:space="preserve">
          <source>I-O status &lt;code&gt;2x&lt;/code&gt;</source>
          <target state="translated">IO状态 &lt;code&gt;2x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be7973453310dbe96df8c3018a9424798391b2e4" translate="yes" xml:space="preserve">
          <source>I-O status &lt;code&gt;3x&lt;/code&gt;</source>
          <target state="translated">IO状态 &lt;code&gt;3x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2458183a044f5219cfb3b7ef88f92e2d8c9e5f33" translate="yes" xml:space="preserve">
          <source>I-O status &lt;code&gt;4x&lt;/code&gt;</source>
          <target state="translated">IO状态 &lt;code&gt;4x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="38cedebc1b1941a50e028e9d6550e769870941c1" translate="yes" xml:space="preserve">
          <source>I-O status &lt;code&gt;5x&lt;/code&gt;</source>
          <target state="translated">IO状态 &lt;code&gt;5x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a3d793e81b9a3c98c450a59713300bf381d8058c" translate="yes" xml:space="preserve">
          <source>I-O status &lt;code&gt;6x&lt;/code&gt;</source>
          <target state="translated">IO状态 &lt;code&gt;6x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="555a7b0c863d6be59d84386e7390b5bbffbf7505" translate="yes" xml:space="preserve">
          <source>I-O status &lt;code&gt;9x&lt;/code&gt;</source>
          <target state="translated">IO状态 &lt;code&gt;9x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f12b2d4b4f8188676296a19fede62525110b1c0" translate="yes" xml:space="preserve">
          <source>I-O-CONTROL MULTIPLE FILE Syntax</source>
          <target state="translated">I-O-CONTROL MULTIPLE FILE 语法描述</target>
        </trans-unit>
        <trans-unit id="6f75dae5c47d389ce684040629f1e36258a6ce54" translate="yes" xml:space="preserve">
          <source>I-O-CONTROL SAME AREA Syntax</source>
          <target state="translated">I-O-CONTROL SAME AREA 语法说明</target>
        </trans-unit>
        <trans-unit id="bb6745092ff5da5fbe4ae9f7460a002043bade91" translate="yes" xml:space="preserve">
          <source>ICON, IDENTIFICATION, IDENTIFIED, ID, IF, IGNORE, IGNORING, IMPLEMENTS, INDEPENDENT, INDEXED, INDEX, INDICATE, INHERITS, INITIALISED, INITIALISE, INITIALIZED, INITIALIZE, INITIAL, INITIATE, INPUT-OUTPUT, INPUT, INQUIRE, INSERTION-INDEX, INSERT-ROWS, INSPECT, INSTALLATION, INTEGER-OF-BOOLEAN, INTEGER-OF-DATE, INTEGER-OF-DAY, INTEGER-OF-FORMATTED-DATE, INTEGER-PART, INTEGER, INTERFACE-ID, INTERFACE, INTERMEDIATE, INTO, INTRINSIC, INVALID, INVOKE, IN, I-O-CONTROL, I-O, IS, ITEM-TEXT, ITEM-TO-ADD, ITEM-TO-DELETE, ITEM-TO-EMPTY, ITEM-VALUE, ITEM</source>
          <target state="translated">ICON,IDENTIFICATION,IDENTIFIED,ID,IF,IGNORE,IGNORING,IMPLEMENTS,INDEPENDENT,INDEXED,INDEX,INDICATE,INHERITS,INITIALISED,INITIALISE,INITIALIZED,INITIAL,INITIATE,INPUT-OUTPUT,INPUT,INQUIRE,INSERTION-INDEX,INSERT-ROWS,INSPECT,INSTALLATION,INTEGER-OF-BOOLEAN,INTEGER-OF-DATE,INTEGER-OF-DAY,INTEGER-OF-FORMATTED-DATE,INTEGER-PART,INTEGER,INTERFACE-ID,INTERFACE,INTERMEDIATE,INTO,INTRINSIC,INVALID,INVOKE,IN,I-O-CONTROL,I-O,IS,ITEM-TEXT,ITEM-TO-ADD,ITEM-TO-DELETE,ITEM-TO-PTY,ITEM-VALUE,ITEM。</target>
        </trans-unit>
        <trans-unit id="9c32595038680ec5b76e6c8935109525fa67eebc" translate="yes" xml:space="preserve">
          <source>ID, IDENTIFICATION, IF, IGNORE, IGNORING, IMPLEMENTS, IN, INDEX, INDEXED, INDICATE, INHERITS, INITIAL, INITIALISE, INITIALISED, INITIALIZE, INITIALIZED, INITIATE, INPUT, INPUT-OUTPUT, INSPECT, INSTALLATION, INTEGER, INTEGER-OF-BOOLEAN, INTEGER-OF-DATE, INTEGER-OF-DAY, INTEGER-OF-FORMATTED-DATE, INTEGER-PART, INTERFACE, INTERFACE-ID, INTERMEDIATE, INTO, INTRINSIC, INVALID, INVOKE, I-O, I-O-CONTROL, IS</source>
          <target state="translated">ID,IDENTIFICATION,IF,IGNORE,IGNORING,IMPLEMENTS,IN,INDEX,INDEXED,INDICATE,INHERITS,INITIAL,INITIALISE,INITIALISED,INITIALIZE,INITIALIZED,INITIATE,INPUT,INPUT-OUTPUT,INSPECT,INSTALLATION,INTEGER,INTEGER-OF-BOOLEAN,INTEGER-OF-DATE,INTEGER-OF-DAY,INTEGER-OF-FORMATTED-DATE,INTEGER-PART,INTERFACE,INTERFACE-ID,INTERMEDIATE,INTO,INTRINSIC,INVALID,INVOKE,I-O,I-O-CONTROL,IS</target>
        </trans-unit>
        <trans-unit id="9b9c55248e0c5e189619271ca0ded3b5bd005453" translate="yes" xml:space="preserve">
          <source>IDENTIFICATION DIVISION Syntax</source>
          <target state="translated">识别区 语法</target>
        </trans-unit>
        <trans-unit id="b825b4511a0db8bbe7c5d10a6be13d4b3f73d3e5" translate="yes" xml:space="preserve">
          <source>IF Syntax</source>
          <target state="translated">IF 语法</target>
        </trans-unit>
        <trans-unit id="8a579c7bbbf6cdd11286272217a8b94f74b4f75a" translate="yes" xml:space="preserve">
          <source>INITIALIZE Syntax</source>
          <target state="translated">INITIALIZE 语法</target>
        </trans-unit>
        <trans-unit id="f22feedf7bc3a1ceec5b7c202882c8aa6f0e185d" translate="yes" xml:space="preserve">
          <source>INITIATE Syntax</source>
          <target state="translated">INITIATE 语法</target>
        </trans-unit>
        <trans-unit id="4f5b873e331f2e93c7e38f36475cf57cbfec3d6a" translate="yes" xml:space="preserve">
          <source>INPUT-OUTPUT SECTION Syntax</source>
          <target state="translated">INPUT-OUTPUT SECTION 命令格式</target>
        </trans-unit>
        <trans-unit id="baa55ae57b9d3c323f03e28edc87f8c479cca623" translate="yes" xml:space="preserve">
          <source>INSPECT Syntax</source>
          <target state="translated">INSPECT 语法</target>
        </trans-unit>
        <trans-unit id="078ab307f07f53957c6ec7a0918c5e4474c21ea5" translate="yes" xml:space="preserve">
          <source>INTEGER Function Syntax</source>
          <target state="translated">INTEGER 函数语法</target>
        </trans-unit>
        <trans-unit id="c9e25e51f813fe8bc79fe92425c0aa73a9ead86d" translate="yes" xml:space="preserve">
          <source>INTEGER-OF-BOOLEAN Function Syntax</source>
          <target state="translated">INTEGER-OF-BOOLEAN 函数语法</target>
        </trans-unit>
        <trans-unit id="2c22d504f0b728c455886a880af6cd5a9ad23315" translate="yes" xml:space="preserve">
          <source>INTEGER-OF-DATE Function Syntax</source>
          <target state="translated">INTEGER-OF-DATE 函数语法</target>
        </trans-unit>
        <trans-unit id="c56815bbf474260cef47707dfeb34754b39ce7d9" translate="yes" xml:space="preserve">
          <source>INTEGER-OF-DAY Function Syntax</source>
          <target state="translated">INTEGER-OF-DAY 函数语法</target>
        </trans-unit>
        <trans-unit id="4d95e4ffa5addf9dfa93519bd4426b5f3b805749" translate="yes" xml:space="preserve">
          <source>INTEGER-OF-FORMATTED-DATE Function Syntax</source>
          <target state="translated">INTEGER-OF-FORMATTED-DATE 函数语法</target>
        </trans-unit>
        <trans-unit id="8690212db49eea2a08db459f36ed19a01dcc1797" translate="yes" xml:space="preserve">
          <source>INTEGER-PART Function Syntax</source>
          <target state="translated">INTEGER-PART 函数语法</target>
        </trans-unit>
        <trans-unit id="b7b5138514830769db3bcc33e44ecf17e41dd72e" translate="yes" xml:space="preserve">
          <source>INVALID KEY Syntax</source>
          <target state="translated">INVALID KEY 语法</target>
        </trans-unit>
        <trans-unit id="ec4a2a5056d72d8e03345caaebf4607d163e6dd7" translate="yes" xml:space="preserve">
          <source>IS</source>
          <target state="translated">IS</target>
        </trans-unit>
        <trans-unit id="52a5254cfd81b370ec179ea32fe392572fa23032" translate="yes" xml:space="preserve">
          <source>Identified sub strings will be moved into each destination field in the sequence they are identified; values moved into a destination field will be truncated if the sub string length exceeds the destination field length, or padded with spaces if the destination field length exceeds the sub string length. Both truncation and padding will be controlled by the presence or absence of a &lt;code&gt;JUSTIFIED&lt;/code&gt; (see &lt;a href=&quot;#JUSTIFIED&quot;&gt;JUSTIFIED&lt;/a&gt;) clause on the destination field.</source>
          <target state="translated">识别出的子字符串将按照它们被识别的顺序移动到每个目标字段中。如果子字符串长度超过目标字段长度，则移入目标字段的值将被截断；如果目标字段长度超过子字符串长度，则将用空格填充。截断和填充都将由目标字段上是否存在 &lt;code&gt;JUSTIFIED&lt;/code&gt; （请参见&lt;a href=&quot;#JUSTIFIED&quot;&gt;JUSTIFIED&lt;/a&gt;）子句来控制。</target>
        </trans-unit>
        <trans-unit id="1e0e983b66f7b85304dc35598bdbe112fd3d5cf6" translate="yes" xml:space="preserve">
          <source>Identified sub strings will be moved into each destination field in the sequence they are identified; values moved into a destination field will be truncated if the sub string length exceeds the destination field length, or padded with spaces if the destination field length exceeds the sub string length. Both truncation and padding will be controlled by the presence or absence of a&lt;code&gt;JUSTIFIED&lt;/code&gt;(see &lt;a href=&quot;#JUSTIFIED&quot;&gt;JUSTIFIED&lt;/a&gt;) clause on the destination field.</source>
          <target state="translated">识别出的子字符串将按照它们被识别的顺序移入每个目标字段。如果子字符串长度超过目标字段长度，则移入目标字段的值将被截断；如果目标字段长度超过子字符串长度，则将用空格填充。截断和填充都将由目标字段上是否存在 &lt;code&gt;JUSTIFIED&lt;/code&gt; （请参见&lt;a href=&quot;#JUSTIFIED&quot;&gt;JUSTIFIED&lt;/a&gt;）子句来控制。</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="3322b13c210812f0828395f739652509dab01dfe" translate="yes" xml:space="preserve">
          <source>If  &lt;code&gt;AFTER ADVANCING&lt;/code&gt; is used (or implied), the &lt;code&gt;ADVANCING&lt;/code&gt; action writes line-terminator characters to the file and then the record data is written to the file.</source>
          <target state="translated">如果使用（或暗含） &lt;code&gt;AFTER ADVANCING&lt;/code&gt; ，则 &lt;code&gt;ADVANCING&lt;/code&gt; 操作将行终止符写入文件，然后将记录数据写入文件。</target>
        </trans-unit>
        <trans-unit id="85fdddf7199ca1a02d1e410b6661de3c0d82e8ec" translate="yes" xml:space="preserve">
          <source>If &amp;lt;</source>
          <target state="translated">如果&amp;lt;</target>
        </trans-unit>
        <trans-unit id="d2c897fd06a8b3a329cd50ec25ba6764ec9129b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;CALL &lt;var&gt;literal&lt;/var&gt;&lt;/code&gt; is used, the subroutine can only be located and linked with the calling program at compilation time.</source>
          <target state="translated">如果使用 &lt;code&gt;CALL &lt;var&gt;literal&lt;/var&gt;&lt;/code&gt; ，则只能在编译时找到子例程并将其与调用程序链接。</target>
        </trans-unit>
        <trans-unit id="15806721a5363c12e0ab5309e695812b2ca53124" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;CALL &lt;var&gt;literal&lt;/var&gt;&lt;/code&gt; is used, the subroutine will be located and linked in with the calling program at compile time or may be dynamically located and loaded at execution time, depending on compiler switch settings and operating system capabilities.</source>
          <target state="translated">如果使用 &lt;code&gt;CALL &lt;var&gt;literal&lt;/var&gt;&lt;/code&gt; ，则该子例程将在编译时定位并与调用程序链接，或者可以在执行时动态定位并加载，这取决于编译器开关设置和操作系统功能。</target>
        </trans-unit>
        <trans-unit id="2766f1a1a46e9b0ceae7190dd211a923f2adb01a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PICTURE&lt;/code&gt; 9 and contains &amp;lsquo;</source>
          <target state="translated">如果 &lt;code&gt;PICTURE&lt;/code&gt; 9包含&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="806c67b77afcd84b74bff546c895a4a635e84b62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PICTURE&lt;/code&gt; contains &amp;lsquo;</source>
          <target state="translated">如果 &lt;code&gt;PICTURE&lt;/code&gt; 包含&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="31f064c7a8360dece576eaaabb04042e1b417012" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RETURNING&lt;/code&gt; is not used the &lt;code&gt;RETURN-CODE&lt;/code&gt; special register receives the status-code where zero is success and non-zero it is not.</source>
          <target state="translated">如果未使用 &lt;code&gt;RETURNING&lt;/code&gt; ,则 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器将接收状态码，其中零表示成功，非零表示不成功。</target>
        </trans-unit>
        <trans-unit id="95fee7622299f954f5a78d52d81bfb663497c86f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WITH TEST AFTER&lt;/code&gt; was specified, control will return back to the &lt;code&gt;PERFORM&lt;/code&gt;, where &lt;var&gt;conditional-expression-1&lt;/var&gt; will be evaluated, and processing of the &lt;code&gt;PERFORM&lt;/code&gt; will halt if the expression evaluates to &lt;code&gt;TRUE&lt;/code&gt;. If &lt;code&gt;WITH TEST AFTER&lt;/code&gt; was</source>
          <target state="translated">如果指定了 &lt;code&gt;WITH TEST AFTER&lt;/code&gt; ，则控制权将返回到 &lt;code&gt;PERFORM&lt;/code&gt; ，在此将对 &lt;var&gt;conditional-expression-1&lt;/var&gt; 进行评估，并且如果该表达式的评估结果为 &lt;code&gt;TRUE&lt;/code&gt; ，则 &lt;code&gt;PERFORM&lt;/code&gt; 的处理将停止。如果&amp;ldquo; &lt;code&gt;WITH TEST AFTER&lt;/code&gt; 为</target>
        </trans-unit>
        <trans-unit id="7d673c8ed35a3c161a6adb890f355404e231d51a" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;argument-1&lt;/var&gt; is a combined date and time format, the content of &lt;var&gt;argument-2&lt;/var&gt; shall be a valid combined date and time in same format.</source>
          <target state="translated">如果 &lt;var&gt;argument-1&lt;/var&gt; 为日期和时间的组合格式，则 &lt;var&gt;argument-2&lt;/var&gt; 的内容应为有效格式相同的日期和时间的组合。</target>
        </trans-unit>
        <trans-unit id="b161484e3fd2f91300ced0138276489baa7a3071" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;argument-1&lt;/var&gt; is a date format the content of &lt;var&gt;argument-2&lt;/var&gt; shall be a valid date in that format.</source>
          <target state="translated">如果 &lt;var&gt;argument-1&lt;/var&gt; 为日期格式，则 &lt;var&gt;argument-2&lt;/var&gt; 的内容应为该格式的有效日期。</target>
        </trans-unit>
        <trans-unit id="cebb80a273ff58e8cda6576d2d206c71054b7fc1" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;argument-2&lt;/var&gt; is specified, each character in &lt;var&gt;argument-1&lt;/var&gt; that has no corresponding national representation is converted to the substitution character specified by &lt;var&gt;argument-2&lt;/var&gt;.</source>
          <target state="translated">如果指定了 &lt;var&gt;argument-2&lt;/var&gt; ,则 &lt;var&gt;argument-1&lt;/var&gt; 中没有对应国家代表的每个字符都将转换为 &lt;var&gt;argument-2&lt;/var&gt; 指定的替换字符。</target>
        </trans-unit>
        <trans-unit id="eada64104bafc15080cf4986ed1d995224af39ae" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;argument-2&lt;/var&gt; is specified, the alphanumeric substitution character is returned for each national character in &lt;var&gt;argument-1&lt;/var&gt; that has no corresponding alphanumeric character representation.</source>
          <target state="translated">如果指定了自 &lt;var&gt;argument-2&lt;/var&gt; ，则对自 &lt;var&gt;argument-1&lt;/var&gt; 中没有相应字母数字字符表示形式的每个国家字符返回字母数字替换字符。</target>
        </trans-unit>
        <trans-unit id="41229338f436e811725413188daac4719abf2425" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;argument-2&lt;/var&gt; is un-specified, and &lt;var&gt;argument-1&lt;/var&gt; contains a national character for which there is no corresponding alphanumeric character representation, an substitution character is used as the corresponding alphanumeric character and the EC-DATA-CONVERSION exception condition is set.</source>
          <target state="translated">如果未指定 &lt;var&gt;argument-2&lt;/var&gt; ，并且 &lt;var&gt;argument-1&lt;/var&gt; 包含没有对应字母数字字符表示形式的国家字符，则将替换字符用作对应的字母数字字符，并设置EC-DATA-CONVERSION例外条件。</target>
        </trans-unit>
        <trans-unit id="acea6d05311cd87855cd26011e8b713e8b0a701e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;argument-2&lt;/var&gt; is unspecified and &lt;var&gt;argument-1&lt;/var&gt; contains an alphanumeric character for which there is no corresponding national character representation, a substitution character is used as the corresponding national character and the &lt;code&gt;EC-DATA-CONVERSION&lt;/code&gt; exception condition is set to exist.</source>
          <target state="translated">如果未指定 &lt;var&gt;argument-2&lt;/var&gt; ，并且 &lt;var&gt;argument-1&lt;/var&gt; 包含没有对应的国家字符表示形式的字母数字字符，则将替换字符用作相应的国家字符，并且将 &lt;code&gt;EC-DATA-CONVERSION&lt;/code&gt; 例外条件设置为存在。</target>
        </trans-unit>
        <trans-unit id="70189109ae068537461ee39c4f8e066bfd97e8b8" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;argument-4&lt;/var&gt; is unspecified, the highest level defined in the ordering table is used for the comparison.</source>
          <target state="translated">如果未指定 &lt;var&gt;argument-4&lt;/var&gt; ，则使用排序表中定义的最高级别进行比较。</target>
        </trans-unit>
        <trans-unit id="5adaf014414135fbd03c55a5e2040f272de5bc12" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;category-name-1&lt;/var&gt; is specified instead of &lt;code&gt;ALL&lt;/code&gt;, only those members of the field list with &lt;code&gt;VALUE&lt;/code&gt; clauses that also meet the criteria set down for the specified &lt;var&gt;category-name&lt;/var&gt; (see the list above) will qualify.</source>
          <target state="translated">如果指定了 &lt;var&gt;category-name-1&lt;/var&gt; 而不是 &lt;code&gt;ALL&lt;/code&gt; ，则只有具有 &lt;code&gt;VALUE&lt;/code&gt; 子句的字段列表的那些成员也符合为指定的 &lt;var&gt;category-name&lt;/var&gt; 设置的条件（请参见上面的列表）才有资格。</target>
        </trans-unit>
        <trans-unit id="bf8869d2fca2a3ed90b31983b8854737520e2708" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;conditional-expression&lt;/var&gt; evaluates to &lt;code&gt;TRUE&lt;/code&gt;, &lt;var&gt;imperative-statement-1&lt;/var&gt; will be executed regardless of whether or not an  &lt;code&gt;ELSE&lt;/code&gt; clause is present. Once &lt;var&gt;imperative-statement-1&lt;/var&gt; has been executed, control falls into the first statement following the &lt;code&gt;END-IF&lt;/code&gt; or to the first statement of the next sentence if there is no &lt;code&gt;END-IF&lt;/code&gt; clause.</source>
          <target state="translated">如果 &lt;var&gt;conditional-expression&lt;/var&gt; 的计算结果为 &lt;code&gt;TRUE&lt;/code&gt; ，则无论是否存在 &lt;code&gt;ELSE&lt;/code&gt; 子句，都将执行 &lt;var&gt;imperative-statement-1&lt;/var&gt; 。一旦执行了 &lt;var&gt;imperative-statement-1&lt;/var&gt; ，如果没有 &lt;code&gt;END-IF&lt;/code&gt; 子句，控制权将落在 &lt;code&gt;END-IF&lt;/code&gt; 之后的第一条语句中或下一个句子的第一条语句中。</target>
        </trans-unit>
        <trans-unit id="bcaac60957317961c413c6d092bcc276d2b47710" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;convert-length&lt;/var&gt; is negative or zero, no conversion will be performed.</source>
          <target state="translated">如果 &lt;var&gt;convert-length&lt;/var&gt; 为负或零，将不执行任何转换。</target>
        </trans-unit>
        <trans-unit id="07c13d6426ecaae87b4c4a28931d4fa60cb75464" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;days&lt;/var&gt; is less than 1 or greater than 3,067,671, or if &lt;var&gt;seconds&lt;/var&gt; is less than 1 or greater than 86,400, a value of 0 is returned and a runtime error will result.</source>
          <target state="translated">如果 &lt;var&gt;days&lt;/var&gt; 数小于1或大于3,067,671，或者 &lt;var&gt;seconds&lt;/var&gt; 小于1或大于86,400，则返回0值，并且将导致运行时错误。</target>
        </trans-unit>
        <trans-unit id="b9f1024cba4d9345c0a63209d2870b749e90c2d6" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file-name-1&lt;/var&gt; is a &lt;code&gt;RELATIVE&lt;/code&gt; file whose &lt;code&gt;ACCESS MODE&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;) is either &lt;code&gt;RANDOM&lt;/code&gt; or &lt;code&gt;DYNAMIC&lt;/code&gt;, the record to be deleted is the one whose relative record number is currently the value of the field specified as the files  &lt;code&gt;RELATIVE KEY&lt;/code&gt; in its &lt;code&gt;SELECT&lt;/code&gt; statement.</source>
          <target state="translated">如果 &lt;var&gt;file-name-1&lt;/var&gt; 是一个 &lt;code&gt;RELATIVE&lt;/code&gt; 文件，其 &lt;code&gt;ACCESS MODE&lt;/code&gt; （请参见&lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;）是 &lt;code&gt;RANDOM&lt;/code&gt; 或 &lt;code&gt;DYNAMIC&lt;/code&gt; ，则要删除的记录是其相对记录号当前是指定为该文件中 &lt;code&gt;RELATIVE KEY&lt;/code&gt; 的字段的值的记录。它的 &lt;code&gt;SELECT&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="d6e9fbaab9d61e6f5e6e5a867b015f6b71b3228d" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file-name-1&lt;/var&gt; is a Sort/Merge work file, no action will be taken.</source>
          <target state="translated">如果 &lt;var&gt;file-name-1&lt;/var&gt; 是&amp;ldquo;排序/合并&amp;rdquo;工作文件，则将不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="6801050e9c52b67ea54ec1034310f5f1e7764d49" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file-name-1&lt;/var&gt; is a relative file, &lt;var&gt;identifier-1&lt;/var&gt; must be the defined &lt;code&gt;RELATIVE KEY&lt;/code&gt; of the file.</source>
          <target state="translated">如果 &lt;var&gt;file-name-1&lt;/var&gt; 是相对文件，则 &lt;var&gt;identifier-1&lt;/var&gt; 必须是该文件的已定义 &lt;code&gt;RELATIVE KEY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f16c5b4c23ecd3d0bf7b5b50d4f95f840e67dc51" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file-name-1&lt;/var&gt; is an &lt;code&gt;INDEXED&lt;/code&gt; file whose &lt;code&gt;ACCESS MODE&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;) is &lt;code&gt;RANDOM&lt;/code&gt; or &lt;code&gt;DYNAMIC&lt;/code&gt;, the record to be deleted is the one whose primary key is currently the value of the field specified as the  &lt;code&gt;RECORD KEY&lt;/code&gt; in the file&amp;rsquo;s &lt;code&gt;SELECT&lt;/code&gt; statement.</source>
          <target state="translated">如果 &lt;var&gt;file-name-1&lt;/var&gt; 是一个 &lt;code&gt;INDEXED&lt;/code&gt; 文件，其 &lt;code&gt;ACCESS MODE&lt;/code&gt; （请参见&lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;）是 &lt;code&gt;RANDOM&lt;/code&gt; 或 &lt;code&gt;DYNAMIC&lt;/code&gt; ，则要删除的记录是其主键当前是该文件的 &lt;code&gt;SELECT&lt;/code&gt; 中指定为 &lt;code&gt;RECORD KEY&lt;/code&gt; 的字段的值的记录。陈述。</target>
        </trans-unit>
        <trans-unit id="0cc5aaff69dc11c0104e28890f987c56b77e0ded" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file-name-1&lt;/var&gt; is an &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;) or &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;) file with &lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt;, this statement as well as a random &lt;code&gt;READ&lt;/code&gt; (see &lt;a href=&quot;#Random-READ&quot;&gt;Random READ&lt;/a&gt;) may be used.</source>
          <target state="translated">如果 &lt;var&gt;file-name-1&lt;/var&gt; 是具有 &lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt; 的 &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; （请参阅&lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;）或 &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; （请参见&lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;）文件，则可以使用此语句以及随机 &lt;code&gt;READ&lt;/code&gt; （请参阅&lt;a href=&quot;#Random-READ&quot;&gt;Random READ&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="feee2421e42f2b2e6a2dd8b71df262f9e36a6466" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file-name-1&lt;/var&gt; is an &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;) or &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;) file with &lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt;, this statement as well as a sequential &lt;code&gt;READ&lt;/code&gt; (see &lt;a href=&quot;#Sequential-READ&quot;&gt;Sequential READ&lt;/a&gt;) may be used.</source>
          <target state="translated">如果 &lt;var&gt;file-name-1&lt;/var&gt; 是具有 &lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt; 的 &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; （请参见&lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;）或 &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; （请参见&lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;）文件，则可以使用此语句以及顺序 &lt;code&gt;READ&lt;/code&gt; （请参见&lt;a href=&quot;#Sequential-READ&quot;&gt;Sequential READ&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="902b8ff8b63de74c2449d52d8e0f866355ef7969" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file-name-1&lt;/var&gt; is an &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;) or &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;) file with an &lt;code&gt;ACCESS MODE RANDOM&lt;/code&gt;, this statement cannot be used.</source>
          <target state="translated">如果 &lt;var&gt;file-name-1&lt;/var&gt; 是具有 &lt;code&gt;ACCESS MODE RANDOM&lt;/code&gt; 的 &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; （请参阅&lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;）或 &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; （请参见&lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;）文件，则不能使用此语句。</target>
        </trans-unit>
        <trans-unit id="6de6701cf8243f215a533b45a324eb216e5e7e58" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file-name-1&lt;/var&gt; is an indexed file, &lt;var&gt;identifier-1&lt;/var&gt; must be the defined &lt;code&gt;RECORD KEY&lt;/code&gt; of the file or any of the &lt;code&gt;ALTERNATE RECORD KEY&lt;/code&gt; fields for the file.</source>
          <target state="translated">如果 &lt;var&gt;file-name-1&lt;/var&gt; 是索引文件，则 &lt;var&gt;identifier-1&lt;/var&gt; 必须是文件的已定义 &lt;code&gt;RECORD KEY&lt;/code&gt; 或文件的任何 &lt;code&gt;ALTERNATE RECORD KEY&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="d5d4d8566ac4ba9f4843bebb395b7f0e5f6c1ec7" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file-name-1&lt;/var&gt; was specified as &lt;code&gt;ACCESS MODE SEQUENTIAL&lt;/code&gt;, this is the</source>
          <target state="translated">如果将 &lt;var&gt;file-name-1&lt;/var&gt; 指定为 &lt;code&gt;ACCESS MODE SEQUENTIAL&lt;/code&gt; ，则这是</target>
        </trans-unit>
        <trans-unit id="c635cc29031373da581d69c58507380ea8674609" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;function-reference-1&lt;/var&gt; is specified, it must be an invocation of an intrinsic function that returns a</source>
          <target state="translated">如果指定了 &lt;var&gt;function-reference-1&lt;/var&gt; ，则它必须是对返回一个a的内在函数的调用</target>
        </trans-unit>
        <trans-unit id="7a82f6faf02bfc8a064e8072fdb8d01d8438d86a" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;identifier-1&lt;/var&gt; is a &lt;code&gt;BASED&lt;/code&gt; data item and that data item is currently based (meaning it currently has memory allocated to it), its memory is released and &lt;var&gt;identifier-1&lt;/var&gt; will become un-based and therefore unusable. If &lt;var&gt;identifier-1&lt;/var&gt; was not based, no action will be taken.</source>
          <target state="translated">如果 &lt;var&gt;identifier-1&lt;/var&gt; 是 &lt;code&gt;BASED&lt;/code&gt; 数据项，并且该数据项当前是基础数据（意味着它当前已分配了内存），则其内存将被释放，并且 &lt;var&gt;identifier-1&lt;/var&gt; 将成为非基础数据，因此无法使用。如果 &lt;var&gt;identifier-1&lt;/var&gt; 不是基于的，则不会采取任何措施。</target>
        </trans-unit>
        <trans-unit id="601b9a08fc689a416f43353282b056e64d29cfa8" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;identifier-1&lt;/var&gt; is a &lt;code&gt;USAGE POINTER&lt;/code&gt; data item and it contains a valid address, the &lt;code&gt;FREE&lt;/code&gt; statement will release the memory block the pointer references. In addition, any &lt;code&gt;BASED&lt;/code&gt; data items that the pointer was used to provide an address for will become un-based and therefore unusable. If &lt;var&gt;identifier-1&lt;/var&gt; did not contain a valid address, no action will be taken.</source>
          <target state="translated">如果 &lt;var&gt;identifier-1&lt;/var&gt; 是 &lt;code&gt;USAGE POINTER&lt;/code&gt; 数据项，并且包含有效地址，则 &lt;code&gt;FREE&lt;/code&gt; 语句将释放指针引用的存储块。此外，指针用来为其提供地址的任何 &lt;code&gt;BASED&lt;/code&gt; 数据项都将变得不基于基础，因此无法使用。如果 &lt;var&gt;identifier-1&lt;/var&gt; 不包含有效地址，则不会采取任何措施。</target>
        </trans-unit>
        <trans-unit id="7eefce7fd4f33c7516ec5fe7dc7febf7af0c0c45" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;identifier-1&lt;/var&gt; is a numeric data item, the character value read from the console or standard-input device will be parsed according to the rules for input to the &lt;code&gt;NUMVAL&lt;/code&gt; intrinsic function (see &lt;a href=&quot;#NUMVAL&quot;&gt;NUMVAL&lt;/a&gt;), except that none of the trailing sign formats are honoured.</source>
          <target state="translated">如果 &lt;var&gt;identifier-1&lt;/var&gt; 是数字数据项，则将从控制台或标准输入设备读取的字符值将根据输入到 &lt;code&gt;NUMVAL&lt;/code&gt; 内在函数（请参阅&lt;a href=&quot;#NUMVAL&quot;&gt;NUMVAL&lt;/a&gt;）的规则进行解析，但不包括尾随符号格式荣幸。</target>
        </trans-unit>
        <trans-unit id="b2beffe69683166de2996cc3ad1d307a3b738cdc" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;identifier-1&lt;/var&gt; is coded, the value of the identifier will serve as the File Location String that will identify the data file.</source>
          <target state="translated">如果 &lt;var&gt;identifier-1&lt;/var&gt; 被编码，则标识符的值将用作标识数据文件的文件位置字符串。</target>
        </trans-unit>
        <trans-unit id="65401601e1b5f316be7956b04fef58574812c3c4" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;identifier-1&lt;/var&gt; is defined as numeric edited, entered data must be acceptable as &lt;code&gt;NUMVAL-C&lt;/code&gt; intrinsic function (see &lt;a href=&quot;#NUMVAL_002dC&quot;&gt;NUMVAL-C&lt;/a&gt;) input (again, no decimal points are allowed). The value stored into &lt;var&gt;identifier-1&lt;/var&gt; will be as if the input were passed to that function.</source>
          <target state="translated">如果将 &lt;var&gt;identifier-1&lt;/var&gt; 定义为数字编辑形式，则输入的数据必须可以作为 &lt;code&gt;NUMVAL-C&lt;/code&gt; 内在函数（请参见&lt;a href=&quot;#NUMVAL_002dC&quot;&gt;NUMVAL-C&lt;/a&gt;）输入（同样，不允许使用小数点）。存储在 &lt;var&gt;identifier-1&lt;/var&gt; 的值就像输入已传递给该函数一样。</target>
        </trans-unit>
        <trans-unit id="f0b993fc56bd4161c6cb118462c21f8a02792ac0" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;identifier-1&lt;/var&gt; is defined as numeric, entered data must be acceptable as &lt;code&gt;NUMVAL&lt;/code&gt; intrinsic function (see &lt;a href=&quot;#NUMVAL&quot;&gt;NUMVAL&lt;/a&gt;) input (no decimal points are allowed, however). The value stored into &lt;var&gt;identifier-1&lt;/var&gt; will be as if the input were passed to that function.</source>
          <target state="translated">如果将 &lt;var&gt;identifier-1&lt;/var&gt; 定义为数字，则输入的数据必须可以作为 &lt;code&gt;NUMVAL&lt;/code&gt; 内在函数（请参见&lt;a href=&quot;#NUMVAL&quot;&gt;NUMVAL&lt;/a&gt;）输入（但是，不允许小数点）。存储在 &lt;var&gt;identifier-1&lt;/var&gt; 的值就像输入已传递给该函数一样。</target>
        </trans-unit>
        <trans-unit id="e6e9927c6cd1c05d327eeb65ca2308723fd015a5" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;identifier-1&lt;/var&gt; is defined in the &lt;code&gt;SCREEN SECTION&lt;/code&gt; (see &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;), any &lt;code&gt;AT&lt;/code&gt;, &lt;var&gt;Attribute-Specification&lt;/var&gt; and &lt;code&gt;WITH&lt;/code&gt; clauses will be ignored. All field definition, cursor positioning and screen control will occur as a result of the screen section definition of &lt;var&gt;identifier-1&lt;/var&gt;.</source>
          <target state="translated">如果在 &lt;code&gt;SCREEN SECTION&lt;/code&gt; 中定义了 &lt;var&gt;identifier-1&lt;/var&gt; （请参阅&lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;），则将忽略任何 &lt;code&gt;AT&lt;/code&gt; ， &lt;var&gt;Attribute-Specification&lt;/var&gt; 和 &lt;code&gt;WITH&lt;/code&gt; 子句。所有字段定义，光标定位和屏幕控制将作为 &lt;var&gt;identifier-1&lt;/var&gt; 的屏幕部分定义的结果。</target>
        </trans-unit>
        <trans-unit id="a0be8c8fcd431f360b0c36422f8f1d1039c159c1" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;identifier-1&lt;/var&gt; is defined in the &lt;code&gt;SCREEN SECTION&lt;/code&gt; (see &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;), any &lt;code&gt;AT&lt;/code&gt;, &lt;var&gt;Attribute-Specification&lt;/var&gt;, &lt;code&gt;LOWER&lt;/code&gt;, &lt;code&gt;UPPER&lt;/code&gt; or &lt;code&gt;SCROLL&lt;/code&gt; clauses will be ignored. In these cases, an implied &lt;code&gt;DISPLAY&lt;/code&gt; (see &lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY screen-data-item&lt;/a&gt;) of &lt;var&gt;identifier-1&lt;/var&gt; will occur before input is accepted. Coding an explicit &lt;code&gt;DISPLAY identifier-1&lt;/code&gt; before an &lt;code&gt;ACCEPT identifier-1&lt;/code&gt; is redundant and will incur the performance penalty of painting the screen contents twice.</source>
          <target state="translated">如果在 &lt;code&gt;SCREEN SECTION&lt;/code&gt; 中定义了 &lt;var&gt;identifier-1&lt;/var&gt; （请参阅&lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;），则将忽略任何 &lt;code&gt;AT&lt;/code&gt; ， &lt;var&gt;Attribute-Specification&lt;/var&gt; ， &lt;code&gt;LOWER&lt;/code&gt; ， &lt;code&gt;UPPER&lt;/code&gt; 或 &lt;code&gt;SCROLL&lt;/code&gt; 子句。在这些情况下，在接受输入之前，将出现 &lt;var&gt;identifier-1&lt;/var&gt; 的隐含 &lt;code&gt;DISPLAY&lt;/code&gt; （请参阅&lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY screen-data-item&lt;/a&gt;）。在 &lt;code&gt;ACCEPT identifier-1&lt;/code&gt; &lt;code&gt;DISPLAY identifier-1&lt;/code&gt; 之前对显式DISPLAY标识符1进行编码是多余的，并且会产生两次绘画屏幕内容的性能损失。</target>
        </trans-unit>
        <trans-unit id="956b6a2cf4a9431c2521f13980ff654199ac7292" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;identifier-1&lt;/var&gt; is used to specify either an absolute or relative column position, &lt;var&gt;identifier-1&lt;/var&gt; must be defined as a numeric item of any &lt;code&gt;USAGE&lt;/code&gt; (see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) other than &lt;code&gt;COMPUTATIONAL-1&lt;/code&gt; or &lt;code&gt;COMPUTATIONAL-2&lt;/code&gt;, without editing symbols. The value of &lt;var&gt;identifier-1&lt;/var&gt; at the time the screen data item is presented must be 1 or greater. Note that a &lt;code&gt;COMPUTATIONAL-1&lt;/code&gt; or &lt;code&gt;COMPUTATIONAL-2&lt;/code&gt; identifier will be accepted by the compiler, but will produce unpredictable results at run-time.</source>
          <target state="translated">如果使用 &lt;var&gt;identifier-1&lt;/var&gt; 来指定绝对列位置或相对列位置，则必须将 &lt;var&gt;identifier-1&lt;/var&gt; 定义为 &lt;code&gt;COMPUTATIONAL-1&lt;/code&gt; 或 &lt;code&gt;COMPUTATIONAL-2&lt;/code&gt; 以外的任何 &lt;code&gt;USAGE&lt;/code&gt; （请参阅&lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;）的数字项，而无需编辑符号。显示屏幕数据项时， &lt;var&gt;identifier-1&lt;/var&gt; 的值必须为1或更大。注意， &lt;code&gt;COMPUTATIONAL-1&lt;/code&gt; 或 &lt;code&gt;COMPUTATIONAL-2&lt;/code&gt; 标识符将被编译器接受，但在运行时将产生不可预测的结果。</target>
        </trans-unit>
        <trans-unit id="8935f15a51dfdcb07032c577d7b0309e385b373c" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;identifier-1&lt;/var&gt; or any screen data item subordinate to it are defined as numeric edited, entered data must be acceptable as &lt;code&gt;NUMVAL-C&lt;/code&gt; intrinsic function (see &lt;a href=&quot;#NUMVAL_002dC&quot;&gt;NUMVAL-C&lt;/a&gt;) input (again, no decimal points are allowed). The value stored into the screen data item will be as if the input were passed to that function.</source>
          <target state="translated">如果将 &lt;var&gt;identifier-1&lt;/var&gt; 或从属它的任何屏幕数据项定义为数字编辑的，则输入的数据必须可以作为 &lt;code&gt;NUMVAL-C&lt;/code&gt; 内在函数（请参见&lt;a href=&quot;#NUMVAL_002dC&quot;&gt;NUMVAL-C&lt;/a&gt;）输入（同样，不允许小数点）。存储在屏幕数据项中的值就像是将输入传递给该功能一样。</target>
        </trans-unit>
        <trans-unit id="31b0d79efa4947cd92b96b43401a7ba32221e382" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;identifier-1&lt;/var&gt; or any screen data item subordinate to it are defined as numeric, entered data must be acceptable as &lt;code&gt;NUMVAL&lt;/code&gt; intrinsic function (see &lt;a href=&quot;#NUMVAL&quot;&gt;NUMVAL&lt;/a&gt;) input (no decimal points are allowed, however). The value stored into the screen data item will be as if the input were passed to that function.</source>
          <target state="translated">如果将 &lt;var&gt;identifier-1&lt;/var&gt; 或从属于它的任何屏幕数据项定义为数字，则输入的数据必须可以作为 &lt;code&gt;NUMVAL&lt;/code&gt; 内在函数（请参见&lt;a href=&quot;#NUMVAL&quot;&gt;NUMVAL&lt;/a&gt;）输入（但是不允许小数点）。存储在屏幕数据项中的值就像是将输入传递给该功能一样。</target>
        </trans-unit>
        <trans-unit id="75a91a06fe865c44309aca591d5aa524e8b8ce58" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;literal-1&lt;/var&gt; is coded, the value of the literal will serve as the File Location String that will identify the data file.</source>
          <target state="translated">如果对 &lt;var&gt;literal-1&lt;/var&gt; 进行了编码，则该literal的值将用作标识数据文件的文件位置字符串。</target>
        </trans-unit>
        <trans-unit id="7685ca3db5a671108387e10e7c45ec2601aa2125" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;literal-1&lt;/var&gt; is specified, only the &lt;code&gt;TALLYING&lt;/code&gt; clause may be specified.</source>
          <target state="translated">如果指定了 &lt;var&gt;literal-1&lt;/var&gt; ，则只能指定 &lt;code&gt;TALLYING&lt;/code&gt; 子句。</target>
        </trans-unit>
        <trans-unit id="feef07f33e68757737bb23c63cff57a7595d6eb9" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;word-1&lt;/var&gt; (a syntactically valid word not duplicating a reserved or user-defined word) is coded, and a &lt;var&gt;Type&lt;/var&gt; is &lt;code&gt;EXTERNAL&lt;/code&gt;, then &lt;var&gt;word-1&lt;/var&gt; itself will serve as the File Location String that will identify the data file. If, however, a &lt;var&gt;Type&lt;/var&gt; of &lt;code&gt;EXTERNAL&lt;/code&gt; was</source>
          <target state="translated">如果对 &lt;var&gt;word-1&lt;/var&gt; （语法上有效的词，不与保留的或用户定义的词重复）进行编码，并且 &lt;var&gt;Type&lt;/var&gt; 为 &lt;code&gt;EXTERNAL&lt;/code&gt; ，则 &lt;var&gt;word-1&lt;/var&gt; 本身将用作文件位置字符串，用于标识数据文件。但是，如果&amp;ldquo; &lt;code&gt;EXTERNAL&lt;/code&gt; &lt;var&gt;Type&lt;/var&gt; &amp;rdquo;为</target>
        </trans-unit>
        <trans-unit id="a4c0ae6969ecd1edf278dc7c43adf6ccf840a59b" translate="yes" xml:space="preserve">
          <source>If CALL &quot;literal&quot; is used, the subroutine can only be located and linked with the calling program at compilation time.</source>
          <target state="translated">如果使用CALL &quot;字面&quot;,子程序只能在编译时与调用程序进行定位和链接。</target>
        </trans-unit>
        <trans-unit id="fb834ae0ee1fee06659da54155901a048c8ab107" translate="yes" xml:space="preserve">
          <source>If CALL &quot;literal&quot; is used, the subroutine will be located and linked in with the calling program at compile time or may be dynamically located and loaded at execution time, depending on compiler switch settings and operating system capabilities.</source>
          <target state="translated">如果使用CALL &quot;literal&quot;,子程序将在编译时与调用程序一起被定位和链接,也可能在执行时被动态定位和加载,这取决于编译器开关设置和操作系统的能力。</target>
        </trans-unit>
        <trans-unit id="1c0a19ff2f39be755da80b6e4db03b3261af8ab0" translate="yes" xml:space="preserve">
          <source>If COB_SET_TRACE is set to Y, then tracing will always occur regardless of the presence of READY TRACE or RESET TRACE so in effect they will have no action on program execution.</source>
          <target state="translated">如果COB_SET_TRACE被设置为Y,那么无论是否存在READY TRACE或RESET TRACE,跟踪都会发生,因此实际上它们对程序执行没有任何作用。</target>
        </trans-unit>
        <trans-unit id="6d1a23e212f8e65bc46791457b48cc5d7fbdbbe2" translate="yes" xml:space="preserve">
          <source>If Replace Mode is currently active, a &lt;code&gt;REPLACE LAST OFF.&lt;/code&gt; will replace the current replace specification(s) with those popped off the top of the stack. If there were no replace specification(s) on the stack, the effect will be as if a &lt;code&gt;REPLACE OFF.&lt;/code&gt; had been coded.</source>
          <target state="translated">如果&amp;ldquo;替换模式&amp;rdquo;当前处于活动状态，则&amp;ldquo; &lt;code&gt;REPLACE LAST OFF.&lt;/code&gt; 一次替换&amp;rdquo;。将使用从堆栈顶部弹出的那些替换规范替换当前的替换规范。如果堆栈上没有替换规范，则效果将类似于&amp;ldquo; &lt;code&gt;REPLACE OFF.&lt;/code&gt; 已被编码。</target>
        </trans-unit>
        <trans-unit id="0bc67cadf74afefc80e1f9092f0b4284c7c21baf" translate="yes" xml:space="preserve">
          <source>If Replace Mode is currently active, a &lt;code&gt;REPLACE OFF.&lt;/code&gt; will deactivate Replace Mode and discard any replace specification(s) on the stack. The compiler will henceforth operate as if no &lt;code&gt;REPLACE&lt;/code&gt; had ever been encountered, until such time as another Format 1 &lt;code&gt;REPLACE&lt;/code&gt; is encountered.</source>
          <target state="translated">如果&amp;ldquo;替换模式&amp;rdquo;当前处于活动状态，则&amp;ldquo; &lt;code&gt;REPLACE OFF.&lt;/code&gt; 将停用&amp;ldquo;替换模式&amp;rdquo;并丢弃堆栈上的所有替换规范。此后，编译器将像从未遇到过 &lt;code&gt;REPLACE&lt;/code&gt; 一样运行，直到遇到另一个Format 1 &lt;code&gt;REPLACE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fca0edd85d905b4998e39dbc0abfe08d59abf9e2" translate="yes" xml:space="preserve">
          <source>If Replace Mode is currently active, a&lt;code&gt;REPLACE LAST OFF.&lt;/code&gt;will replace the current replace specification(s) with those popped off the top of the stack. If there were no replace specification(s) on the stack, the effect will be as if a&lt;code&gt;REPLACE OFF.&lt;/code&gt;had been coded.</source>
          <target state="translated">如果&amp;ldquo;替换模式&amp;rdquo;当前处于活动状态，则&amp;ldquo; &lt;code&gt;REPLACE LAST OFF.&lt;/code&gt; 一次替换&amp;rdquo;。将使用从堆栈顶部弹出的那些替换规范替换当前的替换规范。如果堆栈上没有替换规范，则效果将类似于&amp;ldquo; &lt;code&gt;REPLACE OFF.&lt;/code&gt; 已被编码。</target>
        </trans-unit>
        <trans-unit id="3aa454bf040b4488335636d3825b242cd96c6894" translate="yes" xml:space="preserve">
          <source>If Replace Mode is currently active, a&lt;code&gt;REPLACE OFF.&lt;/code&gt;will deactivate Replace Mode and discard any replace specification(s) on the stack. The compiler will henceforth operate as if no&lt;code&gt;REPLACE&lt;/code&gt;had ever been encountered, until such time as another Format 1&lt;code&gt;REPLACE&lt;/code&gt;is encountered.</source>
          <target state="translated">如果&amp;ldquo;替换模式&amp;rdquo;当前处于活动状态，则&amp;ldquo; &lt;code&gt;REPLACE OFF.&lt;/code&gt; 将停用替换模式并丢弃堆栈上的所有替换规范。此后，编译器将像从未遇到过 &lt;code&gt;REPLACE&lt;/code&gt; 一样运行，直到遇到另一种Format 1 &lt;code&gt;REPLACE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80910c1b2c959a05703945d16cb5a530953c00b1" translate="yes" xml:space="preserve">
          <source>If Replace Mode is currently inactive, the Format 2 &lt;code&gt;REPLACE&lt;/code&gt; statement will be ignored.</source>
          <target state="translated">如果&amp;ldquo;替换模式&amp;rdquo;当前处于非活动状态，则格式2 &lt;code&gt;REPLACE&lt;/code&gt; 语句将被忽略。</target>
        </trans-unit>
        <trans-unit id="f9f8b4a7fa7d08d0000f216b49dbe0fdb7aba40b" translate="yes" xml:space="preserve">
          <source>If Replace Mode is currently inactive, the Format 2 REPLACE statement will be ignored.</source>
          <target state="translated">如果替换模式当前处于非活动状态,格式2 REPLACE语句将被忽略。</target>
        </trans-unit>
        <trans-unit id="0f7541fee62285ef531295f6b5bcda473caf4aa3" translate="yes" xml:space="preserve">
          <source>If a  &lt;code&gt;CONVERTING&lt;/code&gt; clause is specified, neither the  &lt;code&gt;TALLYING&lt;/code&gt; nor  &lt;code&gt;REPLACING&lt;/code&gt; clauses may be used.</source>
          <target state="translated">如果 &lt;code&gt;CONVERTING&lt;/code&gt; 指定子句，既不 &lt;code&gt;TALLYING&lt;/code&gt; 也不 &lt;code&gt;REPLACING&lt;/code&gt; ，可以使用条款。</target>
        </trans-unit>
        <trans-unit id="02d270f35c2331a3f0b66309eedab53f64314826" translate="yes" xml:space="preserve">
          <source>If a &amp;lt;</source>
          <target state="translated">如果&amp;lt;</target>
        </trans-unit>
        <trans-unit id="eab9e954d4363fe95501767a50e10db235e4192f" translate="yes" xml:space="preserve">
          <source>If a &amp;lt;&amp;lt;</source>
          <target state="translated">如果&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="fc1c32024a481de06916a31d66dbe9f8f79db74e" translate="yes" xml:space="preserve">
          <source>If a &amp;rsquo;</source>
          <target state="translated">如果一个 '</target>
        </trans-unit>
        <trans-unit id="de6289cc04bef66b51bd9ae8b980cf5848e4a2b3" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DEFAULT&lt;/code&gt; clause is specified, any remaining uninitialized members of the field list will be initialized according to the default for their class (numeric and numeric-edited are initialized to &lt;code&gt;ZERO&lt;/code&gt;, all others are initialized to &lt;code&gt;SPACES&lt;/code&gt;).</source>
          <target state="translated">如果指定了 &lt;code&gt;DEFAULT&lt;/code&gt; 子句，则将根据其类的默认值初始化字段列表中所有剩余的未初始化成员（数字和数字编辑的对象初始化为 &lt;code&gt;ZERO&lt;/code&gt; ，所有其他的成员初始化为 &lt;code&gt;SPACES&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b7df430cdd4beaec68b52b642faa847848df1390" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;GO TO&lt;/code&gt; is executed within the scope of&amp;hellip;</source>
          <target state="translated">如果在以下范围内执行了 &lt;code&gt;GO TO&lt;/code&gt; ...</target>
        </trans-unit>
        <trans-unit id="086b6db77bb8a4063af573e2157e345885d882c7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;LINAGE&lt;/code&gt; clause is also specified, Values specified for &lt;code&gt;LINAGE IS&lt;/code&gt; and &lt;code&gt;FOOTING AT&lt;/code&gt; will be ignored. The values of &lt;code&gt;LINES AT BOTTOM&lt;/code&gt; and &lt;code&gt;LINES AT TOP&lt;/code&gt;, if any, will be honoured.</source>
          <target state="translated">如果还指定了 &lt;code&gt;LINAGE&lt;/code&gt; 子句，则将忽略为 &lt;code&gt;LINAGE IS&lt;/code&gt; 和 &lt;code&gt;FOOTING AT&lt;/code&gt; 指定的值。 &lt;code&gt;LINES AT BOTTOM&lt;/code&gt; &lt;code&gt;LINES AT TOP&lt;/code&gt; 和顶部线的值（如果有的话）将被兑现。</target>
        </trans-unit>
        <trans-unit id="5be09d0f0d2567af382c50f46015e5dfada291d2" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;REMAINDER&lt;/code&gt; clause is specified, the value of the one and only &lt;var&gt;identifier-3&lt;/var&gt; (as stated earlier, if &lt;code&gt;REMAINDER&lt;/code&gt; is specified there may only be a single &lt;var&gt;identifier-3&lt;/var&gt; coded on the statement) after it was assigned a value according to the previous rule will be multiplied by the value of &lt;var&gt;literal-1&lt;/var&gt; or &lt;var&gt;identifier-1&lt;/var&gt;; that result is then subtracted from the value of &lt;var&gt;literal-2&lt;/var&gt; or &lt;var&gt;identifier-2&lt;/var&gt; and</source>
          <target state="translated">如果指定了 &lt;code&gt;REMAINDER&lt;/code&gt; 子句，则在根据前一个值分配了一个值之后，一个唯一 &lt;var&gt;identifier-3&lt;/var&gt; （如前所述，如果指定了 &lt;code&gt;REMAINDER&lt;/code&gt; ，则该语句上可能只有一个 &lt;var&gt;identifier-3&lt;/var&gt; 编码）。规则将乘以 &lt;var&gt;literal-1&lt;/var&gt; 或 &lt;var&gt;identifier-1&lt;/var&gt; 的值；该结果然后从的值中减去 &lt;var&gt;literal-2&lt;/var&gt; 或 &lt;var&gt;identifier-2&lt;/var&gt; 和</target>
        </trans-unit>
        <trans-unit id="84aa3649a06583fe904bb0cbe1044a6769ee21ac" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;REMAINDER&lt;/code&gt; clause is specified, the value of the one and only &lt;var&gt;identifier-3&lt;/var&gt; (as stated earlier, if &lt;code&gt;REMAINDER&lt;/code&gt; is specified there may only be a single &lt;var&gt;identifier-3&lt;/var&gt; coded on the statement) after it was assigned a value according to the previous rule will be multiplied by the value of &lt;var&gt;literal-2&lt;/var&gt; or &lt;var&gt;identifier-2&lt;/var&gt;; that result is then subtracted from the value of &lt;var&gt;literal-1&lt;/var&gt; or &lt;var&gt;identifier-1&lt;/var&gt; and</source>
          <target state="translated">如果指定了 &lt;code&gt;REMAINDER&lt;/code&gt; 子句，则在根据前一个值分配了一个值之后，一个唯一 &lt;var&gt;identifier-3&lt;/var&gt; （如前所述，如果指定了 &lt;code&gt;REMAINDER&lt;/code&gt; ，则该语句上可能只有一个 &lt;var&gt;identifier-3&lt;/var&gt; 编码）。规则将乘以 &lt;var&gt;literal-2&lt;/var&gt; 或 &lt;var&gt;identifier-2&lt;/var&gt; ；该结果然后从的值中减去 &lt;var&gt;literal-1&lt;/var&gt; 或 &lt;var&gt;identifier-1&lt;/var&gt; 和</target>
        </trans-unit>
        <trans-unit id="c7594e0aab5f388821a150d339e4244378eb19f3" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;REPLACING&lt;/code&gt; clause is specified on the &lt;code&gt;INITIALIZE&lt;/code&gt; statement, each qualifying member of the field list that was not already initialized by a &lt;code&gt;VALUE&lt;/code&gt; clause, if any, will be initialized to the specified &lt;var&gt;literal-1&lt;/var&gt; or &lt;var&gt;identifier-1&lt;/var&gt; value.</source>
          <target state="translated">如果在 &lt;code&gt;INITIALIZE&lt;/code&gt; 语句上指定了 &lt;code&gt;REPLACING&lt;/code&gt; 子句，则尚未由 &lt;code&gt;VALUE&lt;/code&gt; 子句初始化的字段列表的每个合格成员（如果有）将被初始化为指定的 &lt;var&gt;literal-1&lt;/var&gt; 或 &lt;var&gt;identifier-1&lt;/var&gt; 值。</target>
        </trans-unit>
        <trans-unit id="33813c77e109dc9b4f61adc0fc691a4853fcf07b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;TALLYING&lt;/code&gt; clause is coded, &lt;var&gt;identifier-8&lt;/var&gt; will be incremented by 1 each time a destination field is populated.</source>
          <target state="translated">如果对 &lt;code&gt;TALLYING&lt;/code&gt; 子句进行了编码，则每次填充目标字段时， &lt;var&gt;identifier-8&lt;/var&gt; 都会增加1。</target>
        </trans-unit>
        <trans-unit id="cfbcf8874de3c3aaa304872f76604715abf41f16" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; (see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) section exists, the code within it will be disabled unless this environment variable is set to a value of &amp;lsquo;</source>
          <target state="translated">如果存在 &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; （请参阅&lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;）部分，则除非该环境变量的值设置为'，否则将禁用其中的代码。</target>
        </trans-unit>
        <trans-unit id="cfeeade2dc63344bcaf30d0b6c55fa29ff959fe6" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;VALUE&lt;/code&gt; clause is specified on the &lt;code&gt;INITIALIZE&lt;/code&gt; statement, each qualifying member of the field list having a compile-time &lt;code&gt;VALUE&lt;/code&gt; (see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) specified in its definition will be initialized to that value. Field list members with &lt;code&gt;VALUE&lt;/code&gt; clauses will qualify for this treatment as follows:</source>
          <target state="translated">如果 &lt;code&gt;VALUE&lt;/code&gt; 上指定子句 &lt;code&gt;INITIALIZE&lt;/code&gt; 语句，具有一个编译时间字段列表的每个限定构件 &lt;code&gt;VALUE&lt;/code&gt; （见&lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;）在其定义中指定将被初始化到该值。具有 &lt;code&gt;VALUE&lt;/code&gt; 子句的字段列表成员将有资格获得以下待遇：</target>
        </trans-unit>
        <trans-unit id="b332c79b04dd17e719157d2d796d16e81fdbe72a" translate="yes" xml:space="preserve">
          <source>If a &lt;var&gt;Locator&lt;/var&gt; clause is coded, the COBOL file &lt;var&gt;file-name-1&lt;/var&gt; will be attached to a data file within any file system that is mounted and available to the executing program at the time &lt;var&gt;file-name-1&lt;/var&gt; is opened. How that file is identified varies, depending upon the specified &lt;var&gt;Locator&lt;/var&gt;, as follows:</source>
          <target state="translated">如果 &lt;var&gt;Locator&lt;/var&gt; 子句编码时，COBOL文件 &lt;var&gt;file-name-1&lt;/var&gt; 将被连接到在该时间被安装并且可用于执行程序的任何文件系统内的数据文件 &lt;var&gt;file-name-1&lt;/var&gt; 被打开。根据指定的 &lt;var&gt;Locator&lt;/var&gt; ，如何标识该文件会有所不同，如下所示：</target>
        </trans-unit>
        <trans-unit id="54691cdf72f92aa16f748c67998097c3dcd32cbc" translate="yes" xml:space="preserve">
          <source>If a dynamically-loadable module unloaded by the &lt;code&gt;CANCEL&lt;/code&gt; statement is subsequently re-executed, all data division storage for that module will once again be in its initial state.</source>
          <target state="translated">如果随后重新执行由 &lt;code&gt;CANCEL&lt;/code&gt; 语句卸载的可动态加载的模块，则该模块的所有数据分区存储将再次处于其初始状态。</target>
        </trans-unit>
        <trans-unit id="edb4a54100b677ae4d121fffad6d12711ca6c737" translate="yes" xml:space="preserve">
          <source>If a dynamically-loadable module unloaded by the&lt;code&gt;CANCEL&lt;/code&gt;statement is subsequently re-executed, all data division storage for that module will once again be in it&amp;rsquo;s initial state.</source>
          <target state="translated">如果随后重新执行由 &lt;code&gt;CANCEL&lt;/code&gt; 语句卸载的可动态加载的模块，则该模块的所有数据分区存储将再次处于其初始状态。</target>
        </trans-unit>
        <trans-unit id="5eebbcc68042ec2300934665674cc9484d03e969" translate="yes" xml:space="preserve">
          <source>If a numeric literal or &lt;code&gt;PIC 9&lt;/code&gt; identifier is specified as an argument, decimal points, if any, will be removed and negative signs in &lt;code&gt;PIC S9&lt;/code&gt; fields or numeric literals will be inserted as defined by the &lt;code&gt;SIGN IS&lt;/code&gt; (see &lt;a href=&quot;#SIGN-IS&quot;&gt;SIGN IS&lt;/a&gt;) clause (or absence thereof) of the field. Numeric literals are processed as if &lt;code&gt;SIGN IS TRAILING SEPARATE&lt;/code&gt; were in effect.</source>
          <target state="translated">如果将数字文字或 &lt;code&gt;PIC 9&lt;/code&gt; 标识符指定为参数，则将删除小数点（如果有的话），并按 &lt;code&gt;SIGN IS&lt;/code&gt; （请参阅&lt;a href=&quot;#SIGN-IS&quot;&gt;SIGN IS&lt;/a&gt;）子句的定义插入 &lt;code&gt;PIC S9&lt;/code&gt; 字段或数字文字中的负号（或不存在）。数值字面量的处理就好像 &lt;code&gt;SIGN IS TRAILING SEPARATE&lt;/code&gt; 一样有效。</target>
        </trans-unit>
        <trans-unit id="df6f3afc62331cf6c1dea91965aa4ef057173188" translate="yes" xml:space="preserve">
          <source>If a numeric literal or&lt;code&gt;PIC 9&lt;/code&gt;identifier is specified as an argument, decimal points, if any, will be removed and negative signs in&lt;code&gt;PIC S9&lt;/code&gt;fields or numeric literals will be inserted as defined by the&lt;code&gt;SIGN IS&lt;/code&gt;(see &lt;a href=&quot;#SIGN-IS&quot;&gt;SIGN IS&lt;/a&gt;) clause (or absence thereof) of the field. Numeric literals are processed as if&lt;code&gt;SIGN IS TRAILING SEPARATE&lt;/code&gt;were in effect.</source>
          <target state="translated">如果将数字文字或 &lt;code&gt;PIC 9&lt;/code&gt; 标识符指定为参数，则将删除小数点（如果有的话），并按照 &lt;code&gt;SIGN IS&lt;/code&gt; （请参阅&lt;a href=&quot;#SIGN-IS&quot;&gt;SIGN IS&lt;/a&gt;）子句的定义插入 &lt;code&gt;PIC S9&lt;/code&gt; 字段或数字文字中的负号。缺少）。数值字面量的处理就好像 &lt;code&gt;SIGN IS TRAILING SEPARATE&lt;/code&gt; 一样有效。</target>
        </trans-unit>
        <trans-unit id="b18f2b8fc696ea2a37c9ab7e4932c0f375cc7203" translate="yes" xml:space="preserve">
          <source>If a report data item&amp;rsquo;s description includes the &lt;code&gt;SOURCE&lt;/code&gt; (see &lt;a href=&quot;#SOURCE&quot;&gt;SOURCE&lt;/a&gt;), &lt;code&gt;SUM&lt;/code&gt; (see &lt;a href=&quot;#SUM&quot;&gt;SUM&lt;/a&gt;) or &lt;code&gt;VALUE&lt;/code&gt; (see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause but has no &lt;code&gt;COLUMN&lt;/code&gt; clause, &lt;code&gt;COLUMN PLUS 1&lt;/code&gt; will be assumed.</source>
          <target state="translated">如果报表数据项的描述包含 &lt;code&gt;SOURCE&lt;/code&gt; （请参阅&lt;a href=&quot;#SOURCE&quot;&gt;SOURCE&lt;/a&gt;）， &lt;code&gt;SUM&lt;/code&gt; （请参阅&lt;a href=&quot;#SUM&quot;&gt;SUM&lt;/a&gt;）或 &lt;code&gt;VALUE&lt;/code&gt; （请参阅&lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;）子句，但不包含 &lt;code&gt;COLUMN&lt;/code&gt; 子句，则将使用 &lt;code&gt;COLUMN PLUS 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57490b79cb430dd4450134ac2677f6cf11e26604" translate="yes" xml:space="preserve">
          <source>If a report data item&amp;rsquo;s description includes the&lt;code&gt;SOURCE&lt;/code&gt;(see &lt;a href=&quot;#SOURCE&quot;&gt;SOURCE&lt;/a&gt;),&lt;code&gt;SUM&lt;/code&gt;(see &lt;a href=&quot;#SUM&quot;&gt;SUM&lt;/a&gt;) or&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause but has no&lt;code&gt;COLUMN&lt;/code&gt;clause,&lt;code&gt;COLUMN PLUS 1&lt;/code&gt;will be assumed.</source>
          <target state="translated">如果报表数据项的描述包含 &lt;code&gt;SOURCE&lt;/code&gt; （请参阅&lt;a href=&quot;#SOURCE&quot;&gt;SOURCE&lt;/a&gt;）， &lt;code&gt;SUM&lt;/code&gt; （请参阅&lt;a href=&quot;#SUM&quot;&gt;SUM&lt;/a&gt;）或 &lt;code&gt;VALUE&lt;/code&gt; （请参阅&lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;）子句，但不包含 &lt;code&gt;COLUMN&lt;/code&gt; 子句，则将使用 &lt;code&gt;COLUMN PLUS 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e78fe002204288bdbf727c66cab2b49730fadeb" translate="yes" xml:space="preserve">
          <source>If a screen data item&amp;rsquo;s description includes the &lt;code&gt;FROM&lt;/code&gt; (see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;), &lt;code&gt;TO&lt;/code&gt; (see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;), &lt;code&gt;USING&lt;/code&gt; (see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) or &lt;code&gt;VALUE&lt;/code&gt; (see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause but has no &lt;code&gt;COLUMN&lt;/code&gt; clause, the new screen field will begin at the column coordinate of the last character of the previous field.</source>
          <target state="translated">如果屏幕数据项的描述包含 &lt;code&gt;FROM&lt;/code&gt; （请参阅&lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;）， &lt;code&gt;TO&lt;/code&gt; （请参阅&lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;）， &lt;code&gt;USING&lt;/code&gt; （请参阅&lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;）或 &lt;code&gt;VALUE&lt;/code&gt; （请参阅&lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;）子句，但没有 &lt;code&gt;COLUMN&lt;/code&gt; 子句，则新的屏幕字段将从前一个字段的最后一个字符。</target>
        </trans-unit>
        <trans-unit id="2ff794a9c9880c18c06d094247c0f0194d807cda" translate="yes" xml:space="preserve">
          <source>If a screen data item&amp;rsquo;s description includes the &lt;code&gt;FROM&lt;/code&gt; (see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;), &lt;code&gt;TO&lt;/code&gt; (see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;), &lt;code&gt;USING&lt;/code&gt; (see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) or &lt;code&gt;VALUE&lt;/code&gt; (see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause but has no LINE clause, the &amp;ldquo;current screen line&amp;rdquo; will be assumed.</source>
          <target state="translated">如果屏幕数据项的描述包含 &lt;code&gt;FROM&lt;/code&gt; （请参阅&lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;）， &lt;code&gt;TO&lt;/code&gt; （请参阅&lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;）， &lt;code&gt;USING&lt;/code&gt; （请参阅&lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;）或 &lt;code&gt;VALUE&lt;/code&gt; （请参阅&lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;）子句，但没有LINE子句，则将假定为&amp;ldquo;当前屏幕行&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="71da1ffb9548582f3fa4c8e682811f42638458f2" translate="yes" xml:space="preserve">
          <source>If a screen data item&amp;rsquo;s description includes the&lt;code&gt;FROM&lt;/code&gt;(see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;),&lt;code&gt;TO&lt;/code&gt;(see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;),&lt;code&gt;USING&lt;/code&gt;(see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) or&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause but has no LINE clause, the &quot;current screen line&quot; will be assumed.</source>
          <target state="translated">如果屏幕数据项的描述包含 &lt;code&gt;FROM&lt;/code&gt; （请参阅&lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;）， &lt;code&gt;TO&lt;/code&gt; （请参阅&lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;）， &lt;code&gt;USING&lt;/code&gt; （请参阅&lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;）或 &lt;code&gt;VALUE&lt;/code&gt; （请参阅&lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;）子句，但没有LINE子句，则将假定为&amp;ldquo;当前屏幕行&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="48d3ea6a5c04f441a3bbe9ad4aa57d07cef44e81" translate="yes" xml:space="preserve">
          <source>If a screen data item&amp;rsquo;s description includes the&lt;code&gt;FROM&lt;/code&gt;(see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;),&lt;code&gt;TO&lt;/code&gt;(see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;),&lt;code&gt;USING&lt;/code&gt;(see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) or&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause but has no&lt;code&gt;COLUMN&lt;/code&gt;clause, the new screen field will begin at the column coordinate of the last character of the previous field.</source>
          <target state="translated">如果屏幕数据项的描述包含 &lt;code&gt;FROM&lt;/code&gt; （请参阅&lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;）， &lt;code&gt;TO&lt;/code&gt; （请参阅&lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;）， &lt;code&gt;USING&lt;/code&gt; （请参阅&lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;）或 &lt;code&gt;VALUE&lt;/code&gt; （请参阅&lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;）子句，但不包含 &lt;code&gt;COLUMN&lt;/code&gt; 子句，则新的屏幕字段将从该字段的列坐标开始前一个字段的最后一个字符。</target>
        </trans-unit>
        <trans-unit id="59f4cb284f3687d766f621905e37ba2b4393b002" translate="yes" xml:space="preserve">
          <source>If a subprogram does not expect any arguments, it should not have a &lt;code&gt;USING&lt;/code&gt; clause specified on its procedure division header.</source>
          <target state="translated">如果子程序不希望有任何参数，则不应在其过程划分头中指定 &lt;code&gt;USING&lt;/code&gt; 子句。</target>
        </trans-unit>
        <trans-unit id="1ecf4f102cec092a989e853dbb05716d18d10735" translate="yes" xml:space="preserve">
          <source>If a subprogram does not expect any arguments, it should not have a&lt;code&gt;USING&lt;/code&gt;clause specified on it&amp;rsquo;s procedure division header.</source>
          <target state="translated">如果子程序不希望有任何参数，则不应在其过程划分头中指定 &lt;code&gt;USING&lt;/code&gt; 子句。</target>
        </trans-unit>
        <trans-unit id="92b7f84efc871dae3988a9b29ad470f6b8703091" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;CONVERTING&lt;/code&gt;</source>
          <target state="translated">如果正在 &lt;code&gt;CONVERTING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2032d4dadae8be3fe061169d553c0926d6a379ee" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;DEFAULT&lt;/code&gt;clause is specified, any remaining uninitialized members of the field list will be initialized according to the default for their class (numeric and numeric-edited are initialized to ZERO, all others are initialized to SPACES).</source>
          <target state="translated">如果指定了 &lt;code&gt;DEFAULT&lt;/code&gt; 子句，则字段列表中所有剩余的未初始化成员将根据其类的默认值进行初始化（将数字和数字编辑的值初始化为ZERO，将所有其他的值初始化为SPACES）。</target>
        </trans-unit>
        <trans-unit id="7156dc318e4e3f5aa0881e3dc01f136733e5ac30" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;GO TO&lt;/code&gt;is executed within the scope of&amp;hellip;</source>
          <target state="translated">如果在...的范围内执行了 &lt;code&gt;GO TO&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e12db606ad57abcf661cf0d99d8020cc167d9db0" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;LINAGE&lt;/code&gt;clause is also specified, Values specified for&lt;code&gt;LINAGE IS&lt;/code&gt;and&lt;code&gt;FOOTING AT&lt;/code&gt;will be ignored. The values of&lt;code&gt;LINES AT BOTTOM&lt;/code&gt;and&lt;code&gt;LINES AT TOP&lt;/code&gt; if any, will be honoured.</source>
          <target state="translated">如果还指定了 &lt;code&gt;LINAGE&lt;/code&gt; 子句，则将忽略为 &lt;code&gt;LINAGE IS&lt;/code&gt; 和 &lt;code&gt;FOOTING AT&lt;/code&gt; 指定的值。值 &lt;code&gt;LINES AT BOTTOM&lt;/code&gt; 和 &lt;code&gt;LINES AT TOP&lt;/code&gt; 如果有的话，会受到尊重。</target>
        </trans-unit>
        <trans-unit id="b64062bb86b4cc026b65a0da4120142c176e5547" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;REMAINDER&lt;/code&gt;clause is specified, the value of the one and only &amp;lt;</source>
          <target state="translated">如果指定了 &lt;code&gt;REMAINDER&lt;/code&gt; 子句，则一个且仅&amp;lt;</target>
        </trans-unit>
        <trans-unit id="c8a9ba4a49154db62b70c94627e9f9a09a50f6f3" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;REPLACING&lt;/code&gt;clause is specified on the&lt;code&gt;INITIALIZE&lt;/code&gt;statement, each qualifying member of the field list that was not already initialized by a&lt;code&gt;VALUE&lt;/code&gt;clause, if any, will be initialized to the specified &amp;lt;</source>
          <target state="translated">如果在 &lt;code&gt;INITIALIZE&lt;/code&gt; 语句上指定了 &lt;code&gt;REPLACING&lt;/code&gt; 子句，则尚未由 &lt;code&gt;VALUE&lt;/code&gt; 子句初始化的字段列表的每个合格成员（如果有）将被初始化为指定的&amp;lt;</target>
        </trans-unit>
        <trans-unit id="5b838d7717f95d20a08cd03498f7882a18db7072" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;TALLYING&lt;/code&gt;clause is coded, &amp;lt;</source>
          <target state="translated">如果对 &lt;code&gt;TALLYING&lt;/code&gt; 子句进行了编码，则&amp;lt;</target>
        </trans-unit>
        <trans-unit id="42850d1581077257d5fcf6cbd3d76feb45a57582" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;USE FOR DEBUGGING&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) section exists, the code within it will be disabled unless this environment variable is set to a value of &quot;Y&quot;, &quot;y&quot; or &quot;1&quot;.</source>
          <target state="translated">如果存在 &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; （请参阅&lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;）部分，则除非该环境变量的值设置为&amp;ldquo; Y&amp;rdquo;，&amp;ldquo; y&amp;rdquo;或&amp;ldquo; 1&amp;rdquo;，否则将禁用其中的代码。</target>
        </trans-unit>
        <trans-unit id="936f63734566944fcd01e49ee30a1e66bbeaea72" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;VALUE&lt;/code&gt;clause is specified on the&lt;code&gt;INITIALIZE&lt;/code&gt;statement, each qualifying member of the field list having a compile-time&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) specified in it&amp;rsquo;s definition will be initialized to that value. Field list members with&lt;code&gt;VALUE&lt;/code&gt;clauses will qualify for this treatment as follows:</source>
          <target state="translated">如果 &lt;code&gt;VALUE&lt;/code&gt; 在指定条款 &lt;code&gt;INITIALIZE&lt;/code&gt; 语句，其编译时间字段列表中的每个符合条件的成员 &lt;code&gt;VALUE&lt;/code&gt; （见&lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;）在它的定义中指定将被初始化到该值。具有 &lt;code&gt;VALUE&lt;/code&gt; 子句的字段列表成员将有资格获得以下待遇：</target>
        </trans-unit>
        <trans-unit id="bbb21152f55feeb2156f854427c62c771c0ef692" translate="yes" xml:space="preserve">
          <source>If all &amp;lt;</source>
          <target state="translated">如果全部&amp;lt;</target>
        </trans-unit>
        <trans-unit id="b0c2ba2e09c1e900b3eb01b9e52898d0118ff88e" translate="yes" xml:space="preserve">
          <source>If all &lt;var&gt;conditional-expression-n&lt;/var&gt;s evaluated to FALSE:</source>
          <target state="translated">如果所有的 &lt;var&gt;conditional-expression-n&lt;/var&gt; 都评估为FALSE：</target>
        </trans-unit>
        <trans-unit id="ca4cd8a8a2a1d8c22e29cd6e90d36ad1fe723b40" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ASSIGN&lt;/code&gt; clause is coded without a &lt;var&gt;Device&lt;/var&gt;, the device &lt;code&gt;DISC&lt;/code&gt; will be assumed.</source>
          <target state="translated">如果在没有 &lt;var&gt;Device&lt;/var&gt; 情况下对 &lt;code&gt;ASSIGN&lt;/code&gt; 子句进行了编码，则将假定设备为 &lt;code&gt;DISC&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="857d57ff196431645c6d9af6fd43be900ca29f6f" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;EXIT PARAGRAPH&lt;/code&gt; statement or &lt;code&gt;EXIT SECTION&lt;/code&gt; statement resides</source>
          <target state="translated">如果驻留 &lt;code&gt;EXIT PARAGRAPH&lt;/code&gt; 语句或 &lt;code&gt;EXIT SECTION&lt;/code&gt; 语句</target>
        </trans-unit>
        <trans-unit id="34351b99792f0fec35328d816d720a1f1eee1e44" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;EXIT PARAGRAPH&lt;/code&gt; statement or &lt;code&gt;EXIT SECTION&lt;/code&gt; statement resides in a paragraph</source>
          <target state="translated">如果 &lt;code&gt;EXIT PARAGRAPH&lt;/code&gt; 语句或 &lt;code&gt;EXIT SECTION&lt;/code&gt; 语句位于段落中</target>
        </trans-unit>
        <trans-unit id="efdf48973d179f8a73d7a44db16fe05e785724d6" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;INITIATE&lt;/code&gt; is followed by a &lt;code&gt;TERMINATE&lt;/code&gt; with no intervening &lt;code&gt;GENERATE&lt;/code&gt; (see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) statements (all pertaining to the same report, of course), no report groups will be presented to the output file.</source>
          <target state="translated">如果在 &lt;code&gt;INITIATE&lt;/code&gt; 之后是 &lt;code&gt;TERMINATE&lt;/code&gt; ，而中间没有 &lt;code&gt;GENERATE&lt;/code&gt; （请参阅&lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;）语句（当然，所有语句都与同一报告有关），则不会将报告组呈现给输出文件。</target>
        </trans-unit>
        <trans-unit id="ff2c2cd31d2de130d184a1a6186491ebcbe37896" translate="yes" xml:space="preserve">
          <source>If an argument identifier is smaller in storage size than the token value to be stored in it, the right-most excess characters of the token value will be truncated as the value is moved in. Any &lt;code&gt;JUSTIFIED RIGHT&lt;/code&gt; clause on such an argument identifier will be ignored.</source>
          <target state="translated">如果参数标识符的存储大小小于要存储在其中的令牌值，则令牌值的最右边多余字符将在值被移入时被截断。此类参数标识符上的任何 &lt;code&gt;JUSTIFIED RIGHT&lt;/code&gt; 子句都将被删除。忽略了。</target>
        </trans-unit>
        <trans-unit id="82152df9872b03795b0f65167d26e2e94749c462" translate="yes" xml:space="preserve">
          <source>If an argument identifier is smaller in storage size than the token value to be stored in it, the right-most excess characters of the token value will be truncated as the value is moved in. Any JUSTIFIED RIGHT clause on such an argument identifier will be ignored.</source>
          <target state="translated">如果一个参数标识符的存储大小小于要存储在其中的标记值,那么当值被移入时,标记值最右边的多余字符将被截断。任何关于这种参数标识符的JUSTIFIED RIGHT子句将被忽略。</target>
        </trans-unit>
        <trans-unit id="07a8ee359a67bccd96333577bde8fdcc626d0ff2" translate="yes" xml:space="preserve">
          <source>If an argument is larger in storage size than the token value to be stored in it, the token value will be moved into the argument identifier in a left-justified manner. unmodified-modified byte positions in the identifier will be space filled, unless the argument identifier is defined as &lt;code&gt;PIC 9 USAGE DISPLAY&lt;/code&gt;, in which case unmodified bytes will be filled with &amp;lsquo;</source>
          <target state="translated">如果参数的存储大小大于要存储在其中的令牌值，则令牌值将以左对齐的方式移入参数标识符。除非参数标识符定义为 &lt;code&gt;PIC 9 USAGE DISPLAY&lt;/code&gt; ，否则标识符中未修改字节的位置将用空格填充，在这种情况下，未修改字节将用'</target>
        </trans-unit>
        <trans-unit id="bccb47600312a31302d4243c123c27cac5d4e303" translate="yes" xml:space="preserve">
          <source>If an argument is larger in storage size than the token value to be stored in it, the token value will be moved into the argument identifier in a left-justified manner. unmodified-modified byte positions in the identifier will be space filled, unless the argument identifier is defined as PIC 9 USAGE DISPLAY, in which case unmodified bytes will be filled with &quot;0&quot; characters from the systems native character set.</source>
          <target state="translated">如果一个参数的存储大小大于要存储在其中的标记值,标记值将以左对齐的方式移动到参数标识符中。标识符中未经修改的字节位置将被填满,除非参数标识符被定义为PIC 9 USAGE DISPLAY,在这种情况下,未经修改的字节将被系统本地字符集中的 &quot;0 &quot;字符填充。</target>
        </trans-unit>
        <trans-unit id="238de03036789e77a079b1d3ae5e90db16e38bae" translate="yes" xml:space="preserve">
          <source>If an argument lacks a &lt;code&gt;BY&lt;/code&gt; clause, the most-recently encountered &lt;code&gt;BY&lt;/code&gt; specification on that &lt;code&gt;CALL&lt;/code&gt; statement will be assumed. If the first argument specified on a &lt;code&gt;CALL&lt;/code&gt; lacks a &lt;code&gt;BY&lt;/code&gt; clause, &lt;code&gt;BY REFERENCE&lt;/code&gt; will be assumed.</source>
          <target state="translated">如果参数缺少 &lt;code&gt;BY&lt;/code&gt; 子句，则将假定该 &lt;code&gt;CALL&lt;/code&gt; 语句上最近遇到的 &lt;code&gt;BY&lt;/code&gt; 规范。如果在 &lt;code&gt;CALL&lt;/code&gt; 上指定的第一个参数缺少 &lt;code&gt;BY&lt;/code&gt; 子句，则将采用 &lt;code&gt;BY REFERENCE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="14f8fa4ce97209c48ec71484cb50b99ef2bd0709" translate="yes" xml:space="preserve">
          <source>If an argument lacks a&lt;code&gt;BY&lt;/code&gt;clause, the most-recently encountered&lt;code&gt;BY&lt;/code&gt;specification on that&lt;code&gt;CALL&lt;/code&gt;statement will be assumed. If the first argument specified on a&lt;code&gt;CALL&lt;/code&gt;lacks a&lt;code&gt;BY&lt;/code&gt;clause,&lt;code&gt;BY REFERENCE&lt;/code&gt;will be assumed.</source>
          <target state="translated">如果参数缺少 &lt;code&gt;BY&lt;/code&gt; 子句，则将假定该 &lt;code&gt;CALL&lt;/code&gt; 语句上最近遇到的 &lt;code&gt;BY&lt;/code&gt; 规范。如果在 &lt;code&gt;CALL&lt;/code&gt; 上指定的第一个参数缺少 &lt;code&gt;BY&lt;/code&gt; 子句，则将采用 &lt;code&gt;BY REFERENCE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05823b59c6e317b0d6f6bda99166cee75a4f73b6" translate="yes" xml:space="preserve">
          <source>If an argument whose value is less than 1 or greater than 256 is specified, the character in the program collating sequence corresponding to a value of all zero bits is returned.</source>
          <target state="translated">如果指定了一个值小于1或大于256的参数,则返回程序整理序列中对应于所有零位值的字符。</target>
        </trans-unit>
        <trans-unit id="2b8c1834ab8abb452a19e34dee7da8437a78703c" translate="yes" xml:space="preserve">
          <source>If an environment variable was found, it&amp;rsquo;s value will serve as the path and filename to the data file.</source>
          <target state="translated">如果找到环境变量，则其值将用作数据文件的路径和文件名。</target>
        </trans-unit>
        <trans-unit id="87ade2418959261313850658cf96a90fea7f484f" translate="yes" xml:space="preserve">
          <source>If an environment variable was found, its value will serve as the path and filename to the data file.</source>
          <target state="translated">如果找到一个环境变量,它的值将作为数据文件的路径和文件名。</target>
        </trans-unit>
        <trans-unit id="bcab58a3e462d384fa130cd4e9016e959b6a71b4" translate="yes" xml:space="preserve">
          <source>If an&lt;code&gt;ASSIGN&lt;/code&gt;clause is coded without a &amp;lt;&amp;lt;</source>
          <target state="translated">如果 &lt;code&gt;ASSIGN&lt;/code&gt; 子句的编码不带&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="c44efa18b320631b1a96a201bad730ca80153f8d" translate="yes" xml:space="preserve">
          <source>If an&lt;code&gt;EXIT PARAGRAPH&lt;/code&gt;statement or&lt;code&gt;EXIT SECTION&lt;/code&gt;statement resides</source>
          <target state="translated">如果驻留 &lt;code&gt;EXIT PARAGRAPH&lt;/code&gt; 语句或 &lt;code&gt;EXIT SECTION&lt;/code&gt; 语句</target>
        </trans-unit>
        <trans-unit id="87612bdd6bb75a44b81526c8c27d9968de497f3d" translate="yes" xml:space="preserve">
          <source>If an&lt;code&gt;EXIT PARAGRAPH&lt;/code&gt;statement or&lt;code&gt;EXIT SECTION&lt;/code&gt;statement resides in a paragraph</source>
          <target state="translated">如果 &lt;code&gt;EXIT PARAGRAPH&lt;/code&gt; 语句或 &lt;code&gt;EXIT SECTION&lt;/code&gt; 语句位于段落中</target>
        </trans-unit>
        <trans-unit id="3f0242e3af04c028a1ddce44867fb3964faf61b9" translate="yes" xml:space="preserve">
          <source>If an&lt;code&gt;INITIATE&lt;/code&gt;is followed by a&lt;code&gt;TERMINATE&lt;/code&gt;with no intervening&lt;code&gt;GENERATE&lt;/code&gt;(see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) statements (all pertaining to the same report, of course), no report groups will be presented to the output file.</source>
          <target state="translated">如果在 &lt;code&gt;INITIATE&lt;/code&gt; 之后是 &lt;code&gt;TERMINATE&lt;/code&gt; ，而中间没有 &lt;code&gt;GENERATE&lt;/code&gt; （请参阅&lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;）语句（当然，所有语句都与同一报告有关），则不会将报告组呈现给输出文件。</target>
        </trans-unit>
        <trans-unit id="1989e1692cf63856050ee6de069649854e1b7eed" translate="yes" xml:space="preserve">
          <source>If any &amp;lt;</source>
          <target state="translated">如果有&amp;lt;</target>
        </trans-unit>
        <trans-unit id="8c41868f40616dcddd4c750ebaeb0a81bc5fba89" translate="yes" xml:space="preserve">
          <source>If any &lt;var&gt;identifier-7&lt;/var&gt; data item is defined in the report section, it must be a sum counter.</source>
          <target state="translated">如果在报告部分中定义了任何 &lt;var&gt;identifier-7&lt;/var&gt; 数据项，则该数据项必须是总和计数器。</target>
        </trans-unit>
        <trans-unit id="ded48aebbdbbf018e482c90608c9d4d54578f860" translate="yes" xml:space="preserve">
          <source>If any of the paragraphs within one of the sections are coded, the section header itself must be coded.</source>
          <target state="translated">如果其中一节内的任何段落被编码,则该节标题本身必须被编码。</target>
        </trans-unit>
        <trans-unit id="ed99d154978b96e721c4902c0ac26b3300f9f982" translate="yes" xml:space="preserve">
          <source>If at least one &lt;code&gt;GENERATE&lt;/code&gt; statement of this form is executed against a report, the report is said to be a  &lt;em&gt;detail report&lt;/em&gt;. If no &lt;code&gt;GENERATE&lt;/code&gt; statements of this form are executed against a report, the report is said to be a  &lt;em&gt;summary report&lt;/em&gt;.</source>
          <target state="translated">如果针对一个报告执行了至少一个这种形式的 &lt;code&gt;GENERATE&lt;/code&gt; 语句，则该报告被称为&lt;em&gt;明细报告&lt;/em&gt;。如果没有针对报告执行此格式的 &lt;code&gt;GENERATE&lt;/code&gt; 语句，则该报告被称为&lt;em&gt;摘要报告&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="098c66a7cc7db43fe1a5e65ab50d6051cee41a88" translate="yes" xml:space="preserve">
          <source>If at least one&lt;code&gt;GENERATE&lt;/code&gt;statement of this form is executed against a report, the report is said to be a &amp;rsquo;</source>
          <target state="translated">如果针对一个报告执行了至少一个此表的 &lt;code&gt;GENERATE&lt;/code&gt; 语句，则该报告被称为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="bbb1f438e0e2ddccdd230dea44836bc244c52259" translate="yes" xml:space="preserve">
          <source>If both optional sections of this division are coded, they must be coded in the sequence shown.</source>
          <target state="translated">如果本分部的两个可选部分都进行编码,则必须按所示顺序进行编码。</target>
        </trans-unit>
        <trans-unit id="745c71ce2e06f35a39cb484c7fa128871c700a6d" translate="yes" xml:space="preserve">
          <source>If both statement types are coded in the &lt;code&gt;I-O-CONTROL&lt;/code&gt; paragraph, the order in which those statements are coded is irrelevant.</source>
          <target state="translated">如果两种语句类型都在 &lt;code&gt;I-O-CONTROL&lt;/code&gt; 段落中编码，则这些语句的编码顺序无关紧要。</target>
        </trans-unit>
        <trans-unit id="e41dfd24c49449dc06a287d66915bfb31196edfa" translate="yes" xml:space="preserve">
          <source>If both statement types are coded in the&lt;code&gt;I-O-CONTROL&lt;/code&gt;paragraph, the order in which those statements are coded is irrelevant.</source>
          <target state="translated">如果两种语句类型均在 &lt;code&gt;I-O-CONTROL&lt;/code&gt; 段落中编码，则这些语句的编码顺序无关紧要。</target>
        </trans-unit>
        <trans-unit id="6382741c00dff89ae4bdb6330bb5ee8e859bb989" translate="yes" xml:space="preserve">
          <source>If both the &lt;code&gt;TALLYING&lt;/code&gt; and &lt;code&gt;REPLACING&lt;/code&gt; clauses are specified, they must be specified in the order shown.</source>
          <target state="translated">如果同时 &lt;code&gt;TALLYING&lt;/code&gt; ，并 &lt;code&gt;REPLACING&lt;/code&gt; 指定的条款，他们必须在显示的顺序来指定。</target>
        </trans-unit>
        <trans-unit id="776f3c5eecbcd34d511d3925b8b352f3fe294871" translate="yes" xml:space="preserve">
          <source>If both the&lt;code&gt;TALLYING&lt;/code&gt;and&lt;code&gt;REPLACING&lt;/code&gt;clauses are specified, they must be specified in the order shown.</source>
          <target state="translated">如果同时 &lt;code&gt;TALLYING&lt;/code&gt; ，并 &lt;code&gt;REPLACING&lt;/code&gt; 指定的条款，他们必须在显示的顺序来指定。</target>
        </trans-unit>
        <trans-unit id="5240d922a647b65cd3c813dbacecd9ac5a5286ba" translate="yes" xml:space="preserve">
          <source>If control of execution is transferred to a procedure named on the statement, and the &lt;code&gt;GO TO&lt;/code&gt; is executed within the scope of&amp;hellip;</source>
          <target state="translated">如果执行控制权转移到该语句上命名的过程，并且 &lt;code&gt;GO TO&lt;/code&gt; 在以下范围内执行：</target>
        </trans-unit>
        <trans-unit id="49551f9075c0114086955d559a1442bce3fdaf10" translate="yes" xml:space="preserve">
          <source>If control of execution is transferred to a procedure named on the statement, and the&lt;code&gt;GO TO&lt;/code&gt;is executed within the scope of&amp;hellip;</source>
          <target state="translated">如果执行控制权转移到该语句中命名的过程，并且 &lt;code&gt;GO TO&lt;/code&gt; 在以下范围内执行：</target>
        </trans-unit>
        <trans-unit id="cc41015e2010811d0a9e0da87d915540d0d175bb" translate="yes" xml:space="preserve">
          <source>If copybooks your program needs are</source>
          <target state="translated">如果您的程序需要的拷贝本是</target>
        </trans-unit>
        <trans-unit id="25bbb2134d570b993f324faa68838566a3259e83" translate="yes" xml:space="preserve">
          <source>If copybooks your program needs are NOT stored in the same directory as your program, set this environment variable to the folder in which the copybooks may be found (IBM mainframe programmers will recognize this as &quot;SYSLIB&quot;).</source>
          <target state="translated">如果你的程序所需要的拷贝本没有和你的程序存放在同一个目录下,那么就把这个环境变量设置为可以找到拷贝本的文件夹(IBM大型机程序员会把它识别为 &quot;SYSLIB&quot;)。</target>
        </trans-unit>
        <trans-unit id="325de08baac6d6bd1b4e1ebed585b6caa542bf6a" translate="yes" xml:space="preserve">
          <source>If desired, screen fields used as input fields may defined as &quot;secure&quot; fields, where each input character (regardless of what was actually typed) will appear as an asterisk (*) character. The actual character whose key was pressed will still be stored into the field in the program, however. This is very useful for password or account number fields.</source>
          <target state="translated">如果需要,用作输入字段的屏幕字段可以定义为 &quot;安全 &quot;字段,其中每个输入字符(无论实际输入了什么)将以星号(*)字符的形式出现。然而,被按下键的实际字符仍然会被存储到程序中的字段中。这对密码或帐号字段非常有用。</target>
        </trans-unit>
        <trans-unit id="b98d4aa5c71bffe8c951cb1f6b2c3a833d26abf4" translate="yes" xml:space="preserve">
          <source>If desired, screen fields used as input fields may defined as &amp;ldquo;secure&amp;rdquo; fields, where each input character (regardless of what was actually typed) will appear as an asterisk (*) character. The actual character whose key was pressed will still be stored into the field in the program, however. This is very useful for password or account number fields.</source>
          <target state="translated">如果需要，可以将用作输入字段的屏幕字段定义为&amp;ldquo;安全&amp;rdquo;字段，其中每个输入字符（无论实际键入什么内容）都将显示为星号（*）字符。但是，实际按下其键的字符仍将存储在程序的字段中。这对于密码或帐号字段非常有用。</target>
        </trans-unit>
        <trans-unit id="3ce1ca984a9baec19cd93dd7844ad13f57d63d88" translate="yes" xml:space="preserve">
          <source>If desired, you may reverse the roles of the &amp;lsquo;</source>
          <target state="translated">如果需要，您可以将&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="e8c0e23858d8c34351be31b2e2dd7ef0f308a47c" translate="yes" xml:space="preserve">
          <source>If desired, you may reverse the roles of the&lt;code&gt;.&lt;/code&gt;and&lt;code&gt;,&lt;/code&gt;editing symbols by specifying&lt;code&gt;DECIMAL POINT IS COMMA&lt;/code&gt;in the&lt;code&gt;SPECIAL-NAMES&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) paragraph.</source>
          <target state="translated">如果需要，您可以反转的角色 &lt;code&gt;.&lt;/code&gt; 并且 &lt;code&gt;,&lt;/code&gt; 通过指定编辑符号 &lt;code&gt;DECIMAL POINT IS COMMA&lt;/code&gt; 在 &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; （参见&lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;）段。</target>
        </trans-unit>
        <trans-unit id="0fe77fd80daaf49b4bba036f938fdc3be72e0ebb" translate="yes" xml:space="preserve">
          <source>If either condition has a value of &lt;code&gt;TRUE&lt;/code&gt;, the result of &lt;code&gt;OR&lt;/code&gt;ing the two together will result in a value of &lt;code&gt;TRUE&lt;/code&gt;. &lt;code&gt;OR&lt;/code&gt;ing two &lt;code&gt;FALSE&lt;/code&gt; conditions will result in a value of &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">如果任何一个条件的值为 &lt;code&gt;TRUE&lt;/code&gt; ，则将两个条件进行&amp;ldquo; &lt;code&gt;OR&lt;/code&gt; 的结果将为 &lt;code&gt;TRUE&lt;/code&gt; 。 &lt;code&gt;OR&lt;/code&gt; 荷兰国际集团2个 &lt;code&gt;FALSE&lt;/code&gt; 条件将导致值 &lt;code&gt;FALSE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cfeb571780980c15ef5118f06fd533dfd406e005" translate="yes" xml:space="preserve">
          <source>If either condition has a value of TRUE, the result of&lt;code&gt;OR&lt;/code&gt;</source>
          <target state="translated">如果任一条件的值为TRUE，则 &lt;code&gt;OR&lt;/code&gt; 的结果</target>
        </trans-unit>
        <trans-unit id="ed9d44430038aa1155fc55e46a2d9a9ecb6312ec" translate="yes" xml:space="preserve">
          <source>If either the &lt;code&gt;TALLYING&lt;/code&gt; or &lt;code&gt;REPLACING&lt;/code&gt; clauses are specified, the &lt;code&gt;CONVERTING&lt;/code&gt; clause cannot be used.</source>
          <target state="translated">如果任一该 &lt;code&gt;TALLYING&lt;/code&gt; 或 &lt;code&gt;REPLACING&lt;/code&gt; 被指定条款， &lt;code&gt;CONVERTING&lt;/code&gt; 不能使用子句。</target>
        </trans-unit>
        <trans-unit id="bc1c6b979e9c37d992caa4fdb32b5bbe5b97b0db" translate="yes" xml:space="preserve">
          <source>If either the&lt;code&gt;TALLYING&lt;/code&gt;or&lt;code&gt;REPLACING&lt;/code&gt;clauses are specified, the&lt;code&gt;CONVERTING&lt;/code&gt;clause cannot be used.</source>
          <target state="translated">如果任一该 &lt;code&gt;TALLYING&lt;/code&gt; 或 &lt;code&gt;REPLACING&lt;/code&gt; 被指定条款， &lt;code&gt;CONVERTING&lt;/code&gt; 不能使用子句。</target>
        </trans-unit>
        <trans-unit id="4d7f77af0291647c5dacacbc811f9084a6405007" translate="yes" xml:space="preserve">
          <source>If event</source>
          <target state="translated">如果事件</target>
        </trans-unit>
        <trans-unit id="65d896699ba7417f38fac49a744a6351011f2338" translate="yes" xml:space="preserve">
          <source>If event (A) occurs, &amp;lt;</source>
          <target state="translated">如果发生事件（A），&amp;lt;</target>
        </trans-unit>
        <trans-unit id="c6ea8276245b74726b44312b8cbb459b9ea45f59" translate="yes" xml:space="preserve">
          <source>If event (A) occurs, none of the destination field contents (or the contents of their&lt;code&gt;DELIMITER&lt;/code&gt;or &amp;lt;</source>
          <target state="translated">如果事件（A）发生，则目标字段内容（或其 &lt;code&gt;DELIMITER&lt;/code&gt; 或&amp;lt;</target>
        </trans-unit>
        <trans-unit id="c766138e5b6a0fb5e159fe3be6df3cb65c15aa94" translate="yes" xml:space="preserve">
          <source>If excess space is allocated, the returned value will be padded with spaces (to the right).</source>
          <target state="translated">如果分配了多余的空间,返回的值将用空格填充(向右)。</target>
        </trans-unit>
        <trans-unit id="0ee821a14b535409c9db6845f5fa9d2ad8f3ef2b" translate="yes" xml:space="preserve">
          <source>If executed by a main program, neither the &lt;code&gt;EXIT PROGRAM&lt;/code&gt; nor &lt;code&gt;EXIT FUNCTION&lt;/code&gt; statements will take any action.</source>
          <target state="translated">如果由主程序执行，则 &lt;code&gt;EXIT PROGRAM&lt;/code&gt; 或 &lt;code&gt;EXIT FUNCTION&lt;/code&gt; 语句均不会采取任何措施。</target>
        </trans-unit>
        <trans-unit id="dcf599fa35195bfeb7d750a1aa7ddb9854348d4d" translate="yes" xml:space="preserve">
          <source>If executed by a main program, neither the&lt;code&gt;EXIT PROGRAM&lt;/code&gt;nor&lt;code&gt;EXIT FUNCTION&lt;/code&gt;statements will take any action.</source>
          <target state="translated">如果由主程序执行，则 &lt;code&gt;EXIT PROGRAM&lt;/code&gt; 或 &lt;code&gt;EXIT FUNCTION&lt;/code&gt; 语句均不会采取任何措施。</target>
        </trans-unit>
        <trans-unit id="ec56e985e662e98e355eae2b56f2b8eb89f00cd3" translate="yes" xml:space="preserve">
          <source>If executed within a main program, &lt;code&gt;GOBACK&lt;/code&gt; will act as a &lt;code&gt;STOP RUN&lt;/code&gt; statement.</source>
          <target state="translated">如果在主程序中执行， &lt;code&gt;GOBACK&lt;/code&gt; 将充当 &lt;code&gt;STOP RUN&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="adc22a801c0d5cf9afd2251ba837acc24c7e7595" translate="yes" xml:space="preserve">
          <source>If executed within a main program,&lt;code&gt;GOBACK&lt;/code&gt;will act as a&lt;code&gt;STOP RUN&lt;/code&gt;statement.</source>
          <target state="translated">如果在主程序中执行，则 &lt;code&gt;GOBACK&lt;/code&gt; 将充当 &lt;code&gt;STOP RUN&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="29e21ce7e21f0a3076c47fd2aba39be700d024bc" translate="yes" xml:space="preserve">
          <source>If executed within a subprogram (i.e. a subroutine or user-defined function), &lt;code&gt;GOBACK&lt;/code&gt; behaves like an &lt;code&gt;EXIT PROGRAM&lt;/code&gt; or &lt;code&gt;EXIT FUNCTION&lt;/code&gt; statement, respectively.</source>
          <target state="translated">如果在子程序（即子例程或用户定义的函数）中执行，则 &lt;code&gt;GOBACK&lt;/code&gt; 的行为分别类似于 &lt;code&gt;EXIT PROGRAM&lt;/code&gt; 或 &lt;code&gt;EXIT FUNCTION&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="0c913e686677f4f2542ed04551fc54a61ca3b586" translate="yes" xml:space="preserve">
          <source>If executed within a subprogram (i.e. a subroutine or user-defined function),&lt;code&gt;GOBACK&lt;/code&gt;behaves like an&lt;code&gt;EXIT PROGRAM&lt;/code&gt;or&lt;code&gt;EXIT FUNCTION&lt;/code&gt;statement, respectively.</source>
          <target state="translated">如果在子程序（即子例程或用户定义的函数）中执行，则 &lt;code&gt;GOBACK&lt;/code&gt; 的行为分别类似于 &lt;code&gt;EXIT PROGRAM&lt;/code&gt; 或 &lt;code&gt;EXIT FUNCTION&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="37a5ec4ba4f6eb14fb6bc4cdf6c2b834a2e18251" translate="yes" xml:space="preserve">
          <source>If insufficient space is allocated, the returned value will be truncated.</source>
          <target state="translated">如果分配的空间不足,返回的值将被截断。</target>
        </trans-unit>
        <trans-unit id="20788d6df5c521759ffd6da038d7efacbc53537c" translate="yes" xml:space="preserve">
          <source>If it begins with a capital &quot;C&quot;, the value will be centred</source>
          <target state="translated">如果是以大写的 &quot;C &quot;开头,则数值将居中。</target>
        </trans-unit>
        <trans-unit id="cce45705eb2edf3ee981ccb8a02325faa9873b7a" translate="yes" xml:space="preserve">
          <source>If it begins with a capital &quot;L&quot;, the value will be left-justified, space-filled to the right</source>
          <target state="translated">如果它以大写的 &quot;L &quot;开头,则该值将被左对齐,空格向右填充</target>
        </trans-unit>
        <trans-unit id="49095cec719464061ddd1eea1650a1e60b0b3522" translate="yes" xml:space="preserve">
          <source>If it begins with a capital &quot;R&quot;, the value will be right-justified, space-filled to the left</source>
          <target state="translated">如果它以大写的 &quot;R &quot;开头,则该值将被右对齐,并向左填充空间</target>
        </trans-unit>
        <trans-unit id="e6e9d41a84edd6ab6b611b8a64b21d8cc9efa7ef" translate="yes" xml:space="preserve">
          <source>If it begins with anything else, or is absent, it will be treated as if it is present and begins with a capital &quot;R&quot;</source>
          <target state="translated">如果它以任何其他事物开头,或不存在,将被视为存在,并以大写的 &quot;R &quot;开头。</target>
        </trans-unit>
        <trans-unit id="0a89badd7879c4ca69abaf146998c7ff5dc1ad26" translate="yes" xml:space="preserve">
          <source>If it begins with anything else, or is absent, it will be treated as if it is present and begins with a capital &amp;lsquo;</source>
          <target state="translated">如果它以其他任何内容开头或不存在，则将其视为存在并以大写字母'</target>
        </trans-unit>
        <trans-unit id="e314a2cf494e58e27d506f6b9a3b270acdcc85b6" translate="yes" xml:space="preserve">
          <source>If it contains a &lt;code&gt;CR&lt;/code&gt;, &lt;code&gt;DB&lt;/code&gt;, or the minus sign (&amp;lsquo;</source>
          <target state="translated">如果包含 &lt;code&gt;CR&lt;/code&gt; ， &lt;code&gt;DB&lt;/code&gt; 或减号（'</target>
        </trans-unit>
        <trans-unit id="ddfddaec4eb6defafd4236c3804acb2833a56ffc" translate="yes" xml:space="preserve">
          <source>If it is a dynamic subroutine, the GnuCOBOL run-time system will check to see if a dynamically-loadable module containing the subprogram&amp;rsquo;s entry point was already located. If it was, no further &quot;location&quot; activity is needed. If not, the dynamically-loadable module will be located (see &lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;Locating Dynamically-Loadable Modules&lt;/a&gt;).</source>
          <target state="translated">如果它是动态子例程，则GnuCOBOL运行时系统将检查是否已找到包含子程序入口点的可动态加载模块。如果是这样，则不需要进一步的&amp;ldquo;定位&amp;rdquo;活动。否则，将&lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;找到可动态加载的模块&lt;/a&gt;（请参阅查找可动态加载的模块）。</target>
        </trans-unit>
        <trans-unit id="c2c2b30c5a2cdcf0f0e42916c610b89f78e14195" translate="yes" xml:space="preserve">
          <source>If it is a dynamic subroutine, the GnuCOBOL run-time system will check to see if a dynamically-loadable module containing the subprogram&amp;rsquo;s entry point was already located. If it was, no further &amp;ldquo;location&amp;rdquo; activity is needed. If not, the dynamically-loadable module will be located (see &lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;Locating Dynamically-Loadable Modules&lt;/a&gt;).</source>
          <target state="translated">如果它是动态子例程，则GnuCOBOL运行时系统将检查是否已找到包含子程序入口点的可动态加载模块。如果是这样，则不需要进一步的&amp;ldquo;定位&amp;rdquo;活动。否则，将&lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;找到可动态加载的模块&lt;/a&gt;（请参阅查找可动态加载的模块）。</target>
        </trans-unit>
        <trans-unit id="a084bcee5f6f297e9fac72fc57197692e67653da" translate="yes" xml:space="preserve">
          <source>If it is a dynamic user-defined function, the GnuCOBOL run-time system will check to see if a dynamically-loadable module containing the function&amp;rsquo;s entry point was already located. If it was, no further &quot;location&quot; activity is needed. If not, the dynamically-loadable module will be located (see &lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;Locating Dynamically-Loadable Modules&lt;/a&gt;).</source>
          <target state="translated">如果它是动态的用户定义函数，则GnuCOBOL运行时系统将检查是否已找到包含该函数入口点的可动态加载模块。如果是这样，则不需要进一步的&amp;ldquo;定位&amp;rdquo;活动。否则，将&lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;找到可动态加载的模块&lt;/a&gt;（请参阅查找可动态加载的模块）。</target>
        </trans-unit>
        <trans-unit id="3a587abb6e0208602df7555796aa18f2e38bcaa6" translate="yes" xml:space="preserve">
          <source>If it is a dynamic user-defined function, the GnuCOBOL run-time system will check to see if a dynamically-loadable module containing the function&amp;rsquo;s entry point was already located. If it was, no further &amp;ldquo;location&amp;rdquo; activity is needed. If not, the dynamically-loadable module will be located (see &lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;Locating Dynamically-Loadable Modules&lt;/a&gt;).</source>
          <target state="translated">如果它是动态的用户定义函数，则GnuCOBOL运行时系统将检查是否已找到包含该函数入口点的可动态加载的模块。如果是这样，则不需要进一步的&amp;ldquo;定位&amp;rdquo;活动。否则，将&lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;找到可动态加载的模块&lt;/a&gt;（请参阅查找可动态加载的模块）。</target>
        </trans-unit>
        <trans-unit id="1d35a2709398b64faf3d0f6a4cba74a904396997" translate="yes" xml:space="preserve">
          <source>If it is a static subroutine, it will already be part of the executable program issuing the &lt;code&gt;CALL&lt;/code&gt; (see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;).</source>
          <target state="translated">如果它是静态子例程，则它将成为发出 &lt;code&gt;CALL&lt;/code&gt; 的可执行程序的一部分（请参见&lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d0f43ca29a675e226a37e6b6d8088cdbc37ebd39" translate="yes" xml:space="preserve">
          <source>If it is a static subroutine, it will already be part of the executable program issuing the&lt;code&gt;CALL&lt;/code&gt;(see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;).</source>
          <target state="translated">如果它是静态子例程，则它将成为发出 &lt;code&gt;CALL&lt;/code&gt; 的可执行程序的一部分（请参见&lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="caa175b4499a85fc8b3c0efe4a0f73f3d1c1c886" translate="yes" xml:space="preserve">
          <source>If it is a static user-defined function, it will already be part of the executable file containing the calling program.</source>
          <target state="translated">如果它是一个用户定义的静态函数,它将已经是包含调用程序的可执行文件的一部分。</target>
        </trans-unit>
        <trans-unit id="84a0f01c66da97418e3aa21d01e0ef5b3ae55060" translate="yes" xml:space="preserve">
          <source>If more than one section is needed in the data division (a common situation), the sections must be coded in the sequence they are presented above.</source>
          <target state="translated">如果在数据分割中需要一个以上的部分(一种常见的情况),则必须按上述顺序对各部分进行编码。</target>
        </trans-unit>
        <trans-unit id="08575c4d82cf8b371a6f7d53f268979ac88898e9" translate="yes" xml:space="preserve">
          <source>If necessary, &amp;lt;</source>
          <target state="translated">如有必要，&amp;lt;</target>
        </trans-unit>
        <trans-unit id="f3c5cfa2cd5754ef4f9ebd8819c023866cec6753" translate="yes" xml:space="preserve">
          <source>If necessary, &lt;var&gt;identifier-1&lt;/var&gt; may be qualified with a report name.</source>
          <target state="translated">如有必要， &lt;var&gt;identifier-1&lt;/var&gt; 可以使用报告名称来限定。</target>
        </trans-unit>
        <trans-unit id="a07bc04cad751bf3729834d0eede1f438f0dd23e" translate="yes" xml:space="preserve">
          <source>If neither &lt;var&gt;argument-2&lt;/var&gt; nor the &lt;code&gt;LOCALE&lt;/code&gt; keyword is specified, there shall be only one currency string used, either the default currency sign or a currency string specified in the &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; paragraph.</source>
          <target state="translated">如果既未指定 &lt;var&gt;argument-2&lt;/var&gt; ,也未指定 &lt;code&gt;LOCALE&lt;/code&gt; 关键字，则将仅使用一种货币字符串，即默认货币符号或 &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; 段落中指定的货币字符串。</target>
        </trans-unit>
        <trans-unit id="7e171173d63b5e9bade35a7d12eac799bc4e2f54" translate="yes" xml:space="preserve">
          <source>If neither paragraph is coded, the &lt;code&gt;INPUT-OUTPUT SECTION.&lt;/code&gt; header itself may be omitted, otherwise it is normally required.</source>
          <target state="translated">如果两个段落均未编码，则 &lt;code&gt;INPUT-OUTPUT SECTION.&lt;/code&gt; 标头本身可以省略，否则通常是必需的。</target>
        </trans-unit>
        <trans-unit id="f63584104f0c3fb031bde71d0b6dcee112c103e0" translate="yes" xml:space="preserve">
          <source>If neither paragraph is coded, the&lt;code&gt;INPUT-OUTPUT SECTION.&lt;/code&gt;header itself may be omitted, otherwise it is normally required.</source>
          <target state="translated">如果两个段落均未编码，则 &lt;code&gt;INPUT-OUTPUT SECTION.&lt;/code&gt; 标头本身可以省略，否则通常是必需的。</target>
        </trans-unit>
        <trans-unit id="2c24d8323d5e2e2f3832cf5a89d8b67b228d4bcd" translate="yes" xml:space="preserve">
          <source>If neither symbol nor the &lt;code&gt;LOCALE&lt;/code&gt; keyword is specified, there shall be only one currency string used, either the default currency sign or a currency string specified in the &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; paragraph.</source>
          <target state="translated">如果既未指定符号也未指定 &lt;code&gt;LOCALE&lt;/code&gt; 关键字，则将仅使用一种货币字符串，即默认货币符号或在 &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; 段落中指定的货币字符串。</target>
        </trans-unit>
        <trans-unit id="7b645e3fb4170a043aa45114410ba79af6cbd2a8" translate="yes" xml:space="preserve">
          <source>If no  &lt;code&gt;UPON&lt;/code&gt; clause is specified, &lt;code&gt;UPON CONSOLE&lt;/code&gt; will be assumed. If the &lt;code&gt;UPON&lt;/code&gt; clause</source>
          <target state="translated">如果未指定 &lt;code&gt;UPON&lt;/code&gt; 子句，则将假定为 &lt;code&gt;UPON CONSOLE&lt;/code&gt; 。如果是 &lt;code&gt;UPON&lt;/code&gt; 子句</target>
        </trans-unit>
        <trans-unit id="3c31c5678998b1cb03f4a683a72bb094dd2d47bc" translate="yes" xml:space="preserve">
          <source>If no  &lt;code&gt;VALUE&lt;/code&gt;,  &lt;code&gt;REPLACING&lt;/code&gt; or  &lt;code&gt;DEFAULT&lt;/code&gt; clauses are coded, each member of the field list will be initialized as if the figurative constant &lt;code&gt;ZERO&lt;/code&gt; (if the field list item is numeric or numeric-edited) or &lt;code&gt;SPACES&lt;/code&gt; (otherwise) were being moved to it.</source>
          <target state="translated">如果未对 &lt;code&gt;VALUE&lt;/code&gt; ， &lt;code&gt;REPLACING&lt;/code&gt; 或 &lt;code&gt;DEFAULT&lt;/code&gt; 子句进行编码，则将初始化字段列表的每个成员，就像将比喻常量 &lt;code&gt;ZERO&lt;/code&gt; （如果字段列表项是数字或数字编辑的）或 &lt;code&gt;SPACES&lt;/code&gt; （否则）移动到该字段一样。</target>
        </trans-unit>
        <trans-unit id="112a01f52ed19b32bc288508d6054c95da8fdd85" translate="yes" xml:space="preserve">
          <source>If no &amp;lt;</source>
          <target state="translated">如果没有&amp;lt;</target>
        </trans-unit>
        <trans-unit id="c520e3d4aae69229f5d030660491f8d24e39ce90" translate="yes" xml:space="preserve">
          <source>If no &amp;lt;&amp;lt;</source>
          <target state="translated">如果没有&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="cccae1dc6e8637e1b5c5c2fbf5052d3f0ccf07fa" translate="yes" xml:space="preserve">
          <source>If no &amp;rsquo;</source>
          <target state="translated">如果不 '</target>
        </trans-unit>
        <trans-unit id="243c405d0e431941f396cdf2cc7debb85eff9bdf" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;ADVANCING&lt;/code&gt; clause is specified on a &lt;code&gt;WRITE&lt;/code&gt; to a line-advancing file, &lt;code&gt;AFTER ADVANCING 1 LINE&lt;/code&gt; will be assumed; on other than line-advancing files, &lt;code&gt;BEFORE ADVANCING 1 LINE&lt;/code&gt; will be assumed.</source>
          <target state="translated">如果在 &lt;code&gt;WRITE&lt;/code&gt; 上未对行前进文件指定 &lt;code&gt;ADVANCING&lt;/code&gt; 子句，则将假定 &lt;code&gt;AFTER ADVANCING 1 LINE&lt;/code&gt; ；否则，将假定为AFTER ADVANCING 1 LINE。在行前进文件之外的其他文件上，将假定前进 &lt;code&gt;BEFORE ADVANCING 1 LINE&lt;/code&gt; 行之前。</target>
        </trans-unit>
        <trans-unit id="534401253d3dd6379f2606857f4cc89f0c94f6f0" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;AFTER&lt;/code&gt; is specified, the first character position of the target range will be character position #1 of the inspect subject.</source>
          <target state="translated">如果未指定 &lt;code&gt;AFTER&lt;/code&gt; ，则目标范围的第一个字符位置将是检查对象的字符位置＃1。</target>
        </trans-unit>
        <trans-unit id="eb47f868ee5f1f162e6f6003816f7c136573587c" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;BEFORE&lt;/code&gt; is specified, the last character position of the target range will be the last character position of the inspect subject.</source>
          <target state="translated">如果未指定 &lt;code&gt;BEFORE&lt;/code&gt; ，则目标范围的最后一个字符位置将是检查对象的最后一个字符位置。</target>
        </trans-unit>
        <trans-unit id="6fd871db48d394ff9b78f12f0fce35ca9364a8e1" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; clause is specified, the collating sequence implied by the character set native to the computer (usually ASCII) will be used.</source>
          <target state="translated">如果未指定 &lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; 子句，则将使用计算机本机字符集（通常为ASCII）所隐含的整理顺序。</target>
        </trans-unit>
        <trans-unit id="d88264a069243f7453b6028d4a728c1fac697306" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;FIRST&lt;/code&gt;, &lt;code&gt;LAST&lt;/code&gt; or &lt;code&gt;KEY&lt;/code&gt; clause is specified, &lt;code&gt;KEY IS EQUAL TO &lt;var&gt;xxx&lt;/var&gt;&lt;/code&gt; will be assumed, where &lt;code&gt;&lt;var&gt;xxx&lt;/var&gt;&lt;/code&gt; is the defined &lt;code&gt;RELATIVE KEY&lt;/code&gt; of (if &lt;var&gt;file-name-1&lt;/var&gt; is a relative file) or the defined &lt;code&gt;RECORD KEY&lt;/code&gt; (if &lt;var&gt;file-name-1&lt;/var&gt; is an indexed file).</source>
          <target state="translated">如果未指定 &lt;code&gt;FIRST&lt;/code&gt; ， &lt;code&gt;LAST&lt;/code&gt; 或 &lt;code&gt;KEY&lt;/code&gt; 子句，则将假定 &lt;code&gt;KEY IS EQUAL TO &lt;var&gt;xxx&lt;/var&gt;&lt;/code&gt; ，其中 &lt;code&gt;&lt;var&gt;xxx&lt;/var&gt;&lt;/code&gt; 是已定义的 &lt;code&gt;RELATIVE KEY&lt;/code&gt; （如果 &lt;var&gt;file-name-1&lt;/var&gt; 是相对文件）或已定义的 &lt;code&gt;RECORD KEY&lt;/code&gt; （如果 &lt;var&gt;file-name-1&lt;/var&gt; 是索引文件）。</target>
        </trans-unit>
        <trans-unit id="4293878bed72313a6e2568d2a16aac81190571f1" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;FROM&lt;/code&gt; clause is specified, &lt;code&gt;FROM CONSOLE&lt;/code&gt; is assumed.</source>
          <target state="translated">如果未指定 &lt;code&gt;FROM&lt;/code&gt; 子句，则假定 &lt;code&gt;FROM CONSOLE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2cceaf02110825913a3c818819bfaba8864abacf" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;PAGE LIMITS&lt;/code&gt; clause is specified, the entire report will be generated as if it consists of a single arbitrarily long page.</source>
          <target state="translated">如果未指定 &lt;code&gt;PAGE LIMITS&lt;/code&gt; 子句，则将生成整个报告，就好像它由一个任意长的页面组成。</target>
        </trans-unit>
        <trans-unit id="e498385d96185eed7cacd4320d52a11ef46ca39a" translate="yes" xml:space="preserve">
          <source>If no &lt;var&gt;CDF-Conditional-Expression-n&lt;/var&gt; evaluates to &lt;code&gt;TRUE&lt;/code&gt; and there is no &lt;code&gt;&amp;gt;&amp;gt;ELSE&lt;/code&gt; clause, then none of the &lt;var&gt;Program-Source-Lines-n&lt;/var&gt; block of statements within the &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt;-&lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt; scope will be processed by the compiler.</source>
          <target state="translated">如果没有 &lt;var&gt;CDF-Conditional-Expression-n&lt;/var&gt; 计算结果为 &lt;code&gt;TRUE&lt;/code&gt; ,并且没有 &lt;code&gt;&amp;gt;&amp;gt;ELSE&lt;/code&gt; 子句，则 &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt; - &lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt; 范围内的 &lt;var&gt;Program-Source-Lines-n&lt;/var&gt; 语句块都不会被处理由编译器。</target>
        </trans-unit>
        <trans-unit id="c439aee91e928500a2dd00bc3e6fe3094d07c6fa" translate="yes" xml:space="preserve">
          <source>If no &lt;var&gt;CDF-Conditional-Expression&lt;/var&gt; evaluates to &lt;code&gt;TRUE&lt;/code&gt;, and there is an &lt;code&gt;&amp;gt;&amp;gt;ELSE&lt;/code&gt; clause, the &lt;var&gt;Program-Source-Lines-3&lt;/var&gt; block of statements following the &lt;code&gt;&amp;gt;&amp;gt;ELSE&lt;/code&gt; clause will be processed by the compiler and all others within the &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt;-&lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt; scope will be ignored.</source>
          <target state="translated">如果没有 &lt;var&gt;CDF-Conditional-Expression&lt;/var&gt; 计算结果为 &lt;code&gt;TRUE&lt;/code&gt; ，并且有 &lt;code&gt;&amp;gt;&amp;gt;ELSE&lt;/code&gt; 子句，则 &lt;code&gt;&amp;gt;&amp;gt;ELSE&lt;/code&gt; 子句后面的 &lt;var&gt;Program-Source-Lines-3&lt;/var&gt; 语句块将由编译器以及 &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt; 所有其他对象处理IF - &lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt; 范围将被忽略。</target>
        </trans-unit>
        <trans-unit id="ea11b50cea12a93376d57eb2c22cc7b7c141fc7a" translate="yes" xml:space="preserve">
          <source>If no &lt;var&gt;Locator&lt;/var&gt; is coded, &lt;var&gt;file-name-1&lt;/var&gt; will be attached to a logical device or a file based upon the specified (or implied) &lt;var&gt;Device&lt;/var&gt;, as follows:</source>
          <target state="translated">如果未对 &lt;var&gt;Locator&lt;/var&gt; 进行编码，则 &lt;var&gt;file-name-1&lt;/var&gt; 将附加到逻辑设备或基于指定（或隐含） &lt;var&gt;Device&lt;/var&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="326b1fc9786b9941320c69f4a2d328c2621c654e" translate="yes" xml:space="preserve">
          <source>If no &lt;var&gt;alphabet-name-1&lt;/var&gt; is specified, the systems native character set will be assumed.</source>
          <target state="translated">如果未指定 &lt;var&gt;alphabet-name-1&lt;/var&gt; ，则将假定系统使用本机字符集。</target>
        </trans-unit>
        <trans-unit id="f8d3967f390234b0e1110f4076dff26d44bdbae2" translate="yes" xml:space="preserve">
          <source>If no &lt;var&gt;char&lt;/var&gt; argument is provided, a period (&amp;lsquo;</source>
          <target state="translated">如果未提供 &lt;var&gt;char&lt;/var&gt; 参数，则使用句点（'</target>
        </trans-unit>
        <trans-unit id="a2a4248b2b64fc34d7fa95f6235b59c5f46f6584" translate="yes" xml:space="preserve">
          <source>If no &lt;var&gt;length&lt;/var&gt; is specified, a value equivalent to the remaining character positions from &lt;var&gt;start&lt;/var&gt; to the end of &lt;var&gt;identifier-1&lt;/var&gt; or to the end of the value returned by the function will be assumed.</source>
          <target state="translated">如果未指定 &lt;var&gt;length&lt;/var&gt; ，则将假定一个值，该值等于从 &lt;var&gt;identifier-1&lt;/var&gt; &lt;var&gt;start&lt;/var&gt; 到结尾的剩余字符位置，或者等于该函数返回的值的末尾。</target>
        </trans-unit>
        <trans-unit id="5a3a61b3775ed7776f1c79b27fb6ed8d88789b91" translate="yes" xml:space="preserve">
          <source>If no data division sections are needed, the &lt;code&gt;DATA DIVISION.&lt;/code&gt; header itself may be omitted.</source>
          <target state="translated">如果不需要数据划分部分，则进行数据划分 &lt;code&gt;DATA DIVISION.&lt;/code&gt; 标头本身可以省略。</target>
        </trans-unit>
        <trans-unit id="80ec6de7e7c7e7960f42ef9bf764d5e364ff0ae6" translate="yes" xml:space="preserve">
          <source>If no data division sections are needed, the&lt;code&gt;DATA DIVISION.&lt;/code&gt;header itself may be omitted.</source>
          <target state="translated">如果不需要数据划分部分，则使用数据划分 &lt;code&gt;DATA DIVISION.&lt;/code&gt; 标头本身可以省略。</target>
        </trans-unit>
        <trans-unit id="e5c8083a19d4bf6b791a2ad3bee37fd9780d046a" translate="yes" xml:space="preserve">
          <source>If no data will be described in one of the data division sections, that section header may be omitted.</source>
          <target state="translated">如果某个数据分割部分不描述数据,则可省略该部分标题。</target>
        </trans-unit>
        <trans-unit id="052c39714759c532cb982b4e847835f597be06cb" translate="yes" xml:space="preserve">
          <source>If no environment variable was found, or the</source>
          <target state="translated">如果没有找到环境变量,或者</target>
        </trans-unit>
        <trans-unit id="4ea37cd62fe13ae475efaf0fa631e7d1254a22ce" translate="yes" xml:space="preserve">
          <source>If no environment variable was found, or the &quot;config&quot; file used to compile the program had a &quot;filename-mapping&quot; value of &quot;no&quot;, then the File Locator String value will serve as the path and filename to the data file.</source>
          <target state="translated">如果没有找到环境变量,或者用于编译程序的 &quot;config &quot;文件的 &quot;文件名映射 &quot;值为 &quot;no&quot;,那么文件定位符串值将作为数据文件的路径和文件名。</target>
        </trans-unit>
        <trans-unit id="bd8e0699d8e0136dc7ce2219053480886ff4034d" translate="yes" xml:space="preserve">
          <source>If no format or range problems occur during evaluation of &lt;var&gt;argument-2&lt;/var&gt; according to the format in &lt;var&gt;argument-1&lt;/var&gt;, the returned value is zero. Otherwise the returned value is the ordinal character position at which the first error in &lt;var&gt;argument-2&lt;/var&gt; was detected.</source>
          <target state="translated">如果根据 &lt;var&gt;argument-1&lt;/var&gt; 的格式在参数 &lt;var&gt;argument-2&lt;/var&gt; 求值过程中没有格式或范围问题，则返回值为零。否则，返回值是在 &lt;var&gt;argument-2&lt;/var&gt; 中检测到第一个错误的顺序字符位置。</target>
        </trans-unit>
        <trans-unit id="97d63005403252ba6869749f325e5b668c7826c7" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;ADVANCING&lt;/code&gt;clause is specified on a&lt;code&gt;WRITE&lt;/code&gt;to a line-advancing file,&lt;code&gt;AFTER ADVANCING 1 LINE&lt;/code&gt;will be assumed; on other than line-advancing files,&lt;code&gt;BEFORE ADVANCING 1 LINE&lt;/code&gt;will be assumed.</source>
          <target state="translated">如果在 &lt;code&gt;WRITE&lt;/code&gt; 上未对行前进文件指定 &lt;code&gt;ADVANCING&lt;/code&gt; 子句，则将假定 &lt;code&gt;AFTER ADVANCING 1 LINE&lt;/code&gt; ；在行前进文件之外的其他文件上，将假定前进 &lt;code&gt;BEFORE ADVANCING 1 LINE&lt;/code&gt; 行之前。</target>
        </trans-unit>
        <trans-unit id="6c0dd54af0bcfe6aba553419a7f8fa41175966da" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;AFTER&lt;/code&gt;is specified, the first character position of the target range will be character position #1 of the inspect subject.</source>
          <target state="translated">如果未指定 &lt;code&gt;AFTER&lt;/code&gt; ，则目标范围的第一个字符位置将是检查对象的字符位置＃1。</target>
        </trans-unit>
        <trans-unit id="15393df0a9af6eb90b29b75caf239e68d67158ac" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;BEFORE&lt;/code&gt;is specified, the last character position of the target range will be the last character position of the inspect subject.</source>
          <target state="translated">如果未指定 &lt;code&gt;BEFORE&lt;/code&gt; ，则目标范围的最后一个字符位置将是检查对象的最后一个字符位置。</target>
        </trans-unit>
        <trans-unit id="1a0d2b27d4ce9b801ffdc741e7e7060c7a514405" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;COLLATING SEQUENCE&lt;/code&gt;clause is specified, the collating sequence implied by the character set native to the computer (usually ASCII) will be used.</source>
          <target state="translated">如果未指定 &lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; 子句，则将使用计算机本机字符集（通常为ASCII）所隐含的整理顺序。</target>
        </trans-unit>
        <trans-unit id="938ef54a5b2f3a79dc5e586019fcecd25b200f27" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;FIRST&lt;/code&gt;&lt;code&gt;LAST&lt;/code&gt;or&lt;code&gt;KEY&lt;/code&gt;clause is specified,&lt;code&gt;KEY IS EQUAL TO xxx&lt;/code&gt;will be assumed, where &quot;xxx&quot; is the defined&lt;code&gt;RELATIVE KEY&lt;/code&gt;of (if &amp;lt;</source>
          <target state="translated">如果未指定 &lt;code&gt;FIRST&lt;/code&gt; &lt;code&gt;LAST&lt;/code&gt; 或 &lt;code&gt;KEY&lt;/code&gt; 子句，则将假定 &lt;code&gt;KEY IS EQUAL TO xxx&lt;/code&gt; ，其中&amp;ldquo; xxx&amp;rdquo;是已定义的 &lt;code&gt;RELATIVE KEY&lt;/code&gt; （如果&amp;lt;</target>
        </trans-unit>
        <trans-unit id="3c134ddd26a13c987732536178ffc2d3596e0cc0" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;FROM&lt;/code&gt;clause is specified,&lt;code&gt;FROM CONSOLE&lt;/code&gt;is assumed.</source>
          <target state="translated">如果未指定 &lt;code&gt;FROM&lt;/code&gt; 子句，则假定 &lt;code&gt;FROM CONSOLE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a936605766c63b6943b34a949cbfd95d11891a47" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;PAGE LIMITS&lt;/code&gt;clause is specified, the entire report will be generated as if it consists of a single arbitrarily long page.</source>
          <target state="translated">如果未指定 &lt;code&gt;PAGE LIMITS&lt;/code&gt; 子句，则将生成整个报告，就好像它是由一个任意长的页面组成。</target>
        </trans-unit>
        <trans-unit id="8df6bcbeab6aa11894e4fe7cbd9a91d3d00317e5" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;UPON&lt;/code&gt;</source>
          <target state="translated">如果没有 &lt;code&gt;UPON&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe6ea8dfb325db99c6308c46b06bda141821bb43" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;VALUE&lt;/code&gt;</source>
          <target state="translated">如果没有 &lt;code&gt;VALUE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17a7486226a182e50e61ddf27a8089d1e7d3a4e7" translate="yes" xml:space="preserve">
          <source>If none of the features provided by the configuration section are required by a program, the entire &lt;code&gt;CONFIGURATION SECTION.&lt;/code&gt; header may be omitted from the program.</source>
          <target state="translated">如果程序不需要配置部分提供的功能，则请整个 &lt;code&gt;CONFIGURATION SECTION.&lt;/code&gt; 标头可以从程序中省略。</target>
        </trans-unit>
        <trans-unit id="acc316a6b22ed428d8859027514f370adf001d62" translate="yes" xml:space="preserve">
          <source>If none of the features provided by the configuration section are required by a program, the entire&lt;code&gt;CONFIGURATION SECTION.&lt;/code&gt;header may be omitted from the program.</source>
          <target state="translated">如果程序不需要配置部分提供的功能，则请整个 &lt;code&gt;CONFIGURATION SECTION.&lt;/code&gt; 标头可以从程序中省略。</target>
        </trans-unit>
        <trans-unit id="38302bf8e20435daf87449711673f45dc0fc7efa" translate="yes" xml:space="preserve">
          <source>If none of the paragraphs within one of the sections are coded, the section header itself may be omitted.</source>
          <target state="translated">如果其中一节中没有任何段落被编码,则可省略该节标题本身。</target>
        </trans-unit>
        <trans-unit id="3dadd5125e77aeeda6a5112001c153a016dba637" translate="yes" xml:space="preserve">
          <source>If none of the sections within the data division are coded (a highly unlikely, but theoretically possible circumstance), the &lt;code&gt;DATA DIVISION.&lt;/code&gt; header itself may be omitted.</source>
          <target state="translated">如果数据分区内的任何部分均未编码（极不可能，但理论上可能的情况），则使用&amp;ldquo;数据分区&amp;rdquo; &lt;code&gt;DATA DIVISION.&lt;/code&gt; 标头本身可以省略。</target>
        </trans-unit>
        <trans-unit id="c20690aa244c08791983cf1b27135cf3c295161b" translate="yes" xml:space="preserve">
          <source>If none of the sections within the data division are coded (a highly unlikely, but theoretically possible circumstance), the&lt;code&gt;DATA DIVISION.&lt;/code&gt;header itself may be omitted.</source>
          <target state="translated">如果数据分区内的任何部分均未编码（极不可能，但理论上可能的情况），则使用数据分区 &lt;code&gt;DATA DIVISION.&lt;/code&gt; 标头本身可以省略。</target>
        </trans-unit>
        <trans-unit id="614f1bfd9e62febeba4cb5fdaea32c820a1ed346" translate="yes" xml:space="preserve">
          <source>If none of the sections within the environment division are coded, the &lt;code&gt;ENVIRONMENT DIVISION.&lt;/code&gt; header itself may be omitted.</source>
          <target state="translated">如果环境部门内的任何部分均未编码，则 &lt;code&gt;ENVIRONMENT DIVISION.&lt;/code&gt; 标头本身可以省略。</target>
        </trans-unit>
        <trans-unit id="0a6df96501f79aab798f69106ec9e2b97487e708" translate="yes" xml:space="preserve">
          <source>If none of the sections within the environment division are coded, the&lt;code&gt;ENVIRONMENT DIVISION.&lt;/code&gt;header itself may be omitted.</source>
          <target state="translated">如果环境部门内的任何部分均未编码，则 &lt;code&gt;ENVIRONMENT DIVISION.&lt;/code&gt; 标头本身可以省略。</target>
        </trans-unit>
        <trans-unit id="3f3504ace1fcbbfe8785eaf44906c2e8b0fac8ce" translate="yes" xml:space="preserve">
          <source>If references to table elements are going to be performed many, many times (tens or hundreds of thousands of times or more) during program execution, you will probably see a noticeable reduction in program execution time if you use indexing versus subscripting.</source>
          <target state="translated">如果在程序执行过程中对表元素的引用要执行很多很多次(几万次或几十万次以上),如果使用索引与下标,可能会看到程序执行时间明显减少。</target>
        </trans-unit>
        <trans-unit id="8e464aa3baae37e1c17db766f8597a99a293b6e4" translate="yes" xml:space="preserve">
          <source>If references to table elements are not going to be performed many, many times it probably won&amp;rsquo;t make much difference whether you use indexing or subscripting.</source>
          <target state="translated">如果对表元素的引用不会执行很多次，那么无论使用索引还是下标都可能不会有太大的不同。</target>
        </trans-unit>
        <trans-unit id="aaecf6782edaccec3acfe39a9b02ed5a4cd9c916" translate="yes" xml:space="preserve">
          <source>If rule</source>
          <target state="translated">如果规则</target>
        </trans-unit>
        <trans-unit id="2d7b2b72b6ddc84fee15212248b1a81b23f1b096" translate="yes" xml:space="preserve">
          <source>If rule (A) is violated, the compiler will reject the&lt;code&gt;SEARCH ALL&lt;/code&gt; If rules (B) and/or (C) are violated, there will be no message issued by the compiler, but the run-time results of a&lt;code&gt;SEARCH ALL&lt;/code&gt;against the table will probably be incorrect.</source>
          <target state="translated">如果规则（A）被违反，则编译器将拒绝该 &lt;code&gt;SEARCH ALL&lt;/code&gt; 如果规则（B）和/或（C）受到侵害时，将没有由编译器发出的消息，而是一个的运行时的结果 &lt;code&gt;SEARCH ALL&lt;/code&gt; 针对该表可能不正确。</target>
        </trans-unit>
        <trans-unit id="953965bec96dd86973cb12584b0c3f4d8e27d9dc" translate="yes" xml:space="preserve">
          <source>If set to &quot;Y&quot;, &quot;y&quot; or &quot;1&quot;, a&lt;code&gt;CANCEL&lt;/code&gt;statement (see &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;) will physically unload a subprogram dynamically-loadable module.</source>
          <target state="translated">如果设置为&amp;ldquo; Y&amp;rdquo;，&amp;ldquo; y&amp;rdquo;或&amp;ldquo; 1&amp;rdquo;，则 &lt;code&gt;CANCEL&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;）将物理卸载可动态加载的子程序模块。</target>
        </trans-unit>
        <trans-unit id="f88d67aae9fbbcc5e6bf0dc40d8e5dbe106478a0" translate="yes" xml:space="preserve">
          <source>If set to &amp;lsquo;</source>
          <target state="translated">如果设置为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="e304fe2f130a29229fe3b203d139f3c8d0b1b8a9" translate="yes" xml:space="preserve">
          <source>If set to a value of &quot;Y&quot;, any run-time warnings (such as noting the implicit closing of open files when a&lt;code&gt;GOBACK&lt;/code&gt;statement (see &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;) or&lt;code&gt;STOP&lt;/code&gt;statement (see &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;) with the&lt;code&gt;RUN&lt;/code&gt;option is executed) will be displayed. Any other value for this environment variable (including not setting the variable at all) will suppress such messages.</source>
          <target state="translated">如果将值设置为&amp;ldquo; Y&amp;rdquo;，则将显示任何运行时警告（例如，在执行带有 &lt;code&gt;RUN&lt;/code&gt; 选项的 &lt;code&gt;GOBACK&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;）或 &lt;code&gt;STOP&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;）时注意隐式关闭打开的文件） 。此环境变量的任何其他值（包括根本不设置变量）将禁止显示此类消息。</target>
        </trans-unit>
        <trans-unit id="2e24028937a15160864d8d70027a4e0de73165b6" translate="yes" xml:space="preserve">
          <source>If set to a value of &amp;lsquo;</source>
          <target state="translated">如果设置为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="2bc077c4c98b87e839493508304c45c1d8484f6d" translate="yes" xml:space="preserve">
          <source>If set to a value of upper- or lower-case &quot;p&quot;, this variable will force a file commit every time a file is written to (ensuring that data is immediately written to the file rather than retained in memory until a future commit occurs). This will slow-down update access to files, but will provide for better integrity in the event of a program failure.</source>
          <target state="translated">如果设置为大写或小写的 &quot;p &quot;值,这个变量将在每次写入文件时强制进行文件提交(确保数据立即写入文件,而不是保留在内存中,直到未来发生提交)。这将减慢对文件的更新访问速度,但在程序失败时将提供更好的完整性。</target>
        </trans-unit>
        <trans-unit id="8ef009313288e4b38dade52c03aab10d1ff99537" translate="yes" xml:space="preserve">
          <source>If set to a value of upper- or lower-case &amp;lsquo;</source>
          <target state="translated">如果设置为大写或小写'</target>
        </trans-unit>
        <trans-unit id="a40079ff225e97a80fb28e577e2103bb2e14eadc" translate="yes" xml:space="preserve">
          <source>If set to any non-blank value, this variable allows a &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;) to detect the &lt;code&gt;Esc&lt;/code&gt; key.</source>
          <target state="translated">如果设置为任何非空白值，则此变量允许 &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;）检测 &lt;code&gt;Esc&lt;/code&gt; 键。</target>
        </trans-unit>
        <trans-unit id="1ff6dd80412acb65fea091eeee45227f17f79745" translate="yes" xml:space="preserve">
          <source>If set to any non-blank value, this variable allows a&lt;code&gt;ACCEPT screen-data-item&lt;/code&gt;statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;) to detect the &quot;Esc&quot; key.</source>
          <target state="translated">如果设置为任何非空白值，则此变量允许 &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;）检测&amp;ldquo; Esc&amp;rdquo;键。</target>
        </trans-unit>
        <trans-unit id="e1484a009cf90e95f0122b3b84adf74c213a3afb" translate="yes" xml:space="preserve">
          <source>If set to any non-null value, this environment variable specifies the file to which all</source>
          <target state="translated">如果设置为非空值,这个环境变量将指定所有的</target>
        </trans-unit>
        <trans-unit id="02c873d8dea11df102afae708aa8d02b69151e6b" translate="yes" xml:space="preserve">
          <source>If set to any non-null value, this environment variable specifies the file to which all&lt;code&gt;-ftrace&lt;/code&gt;switch and&lt;code&gt;-ftraceall&lt;/code&gt;switch output will be written.</source>
          <target state="translated">如果设置为任何非null值，则此环境变量指定将所有 &lt;code&gt;-ftrace&lt;/code&gt; 开关和 &lt;code&gt;-ftraceall&lt;/code&gt; 开关输出写入的文件。</target>
        </trans-unit>
        <trans-unit id="422d3cddd2d7b811c88085d18de9df66cdccb313" translate="yes" xml:space="preserve">
          <source>If set to any non-null value, this variable will cause all dynamically-loadable libraries to be loaded when the program begins execution (rather than searching for and loading the module upon first use).</source>
          <target state="translated">如果设置为任何非空值,这个变量将导致所有可动态加载的库在程序开始执行时被加载(而不是在第一次使用时搜索和加载模块)。</target>
        </trans-unit>
        <trans-unit id="d8aab5d7cf6334fa7d1d64a36e03690790d2311f" translate="yes" xml:space="preserve">
          <source>If set to anything else, a&lt;code&gt;CANCEL&lt;/code&gt;statement (see &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;) logically unloads a module so that subsequent use will re-initialize the module as if it had actually been reloaded, but the overhead of actually reloading the module will be avoided.</source>
          <target state="translated">如果设置为其他任何值，则 &lt;code&gt;CANCEL&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;）从逻辑上卸载模块，以便后续使用将重新初始化该模块，就好像它实际上已经被重新加载一样，但是可以避免实际重新加载模块的开销。</target>
        </trans-unit>
        <trans-unit id="8a128e5ae83dd950222f98e00dbd8196d885904f" translate="yes" xml:space="preserve">
          <source>If set to either &lt;code&gt;UPPER&lt;/code&gt; or &lt;code&gt;LOWER&lt;/code&gt;, this environment variable will internally convert referenced entry-point names to either upper- or lower-case before initiating searches for dynamically-loadable modules. The &lt;code&gt;UPPER&lt;/code&gt; and &lt;code&gt;LOWER&lt;/code&gt; values of the environment variable are actually case-insensitive.</source>
          <target state="translated">如果设置为 &lt;code&gt;UPPER&lt;/code&gt; 或 &lt;code&gt;LOWER&lt;/code&gt; ，则此环境变量将在开始搜索可动态加载的模块之前在内部将引用的入口点名称转换为大写或小写。环境变量的 &lt;code&gt;UPPER&lt;/code&gt; 和 &lt;code&gt;LOWER&lt;/code&gt; 值实际上不区分大小写。</target>
        </trans-unit>
        <trans-unit id="ffb03e9553a2471b244e5697186cb21ecae1836a" translate="yes" xml:space="preserve">
          <source>If set to either&lt;code&gt;UPPER&lt;/code&gt;or&lt;code&gt;LOWER&lt;/code&gt; this environment variable will internally convert referenced entry-point names to either upper- or lower-case before initiating searches for dynamically-loadable modules. The&lt;code&gt;UPPER&lt;/code&gt;and&lt;code&gt;LOWER&lt;/code&gt;values of the environment variable are actually case-insensitive.</source>
          <target state="translated">如果设置为 &lt;code&gt;UPPER&lt;/code&gt; 或 &lt;code&gt;LOWER&lt;/code&gt; ,则此环境变量将在开始搜索可动态加载的模块之前在内部将引用的入口点名称转换为大写或小写。环境变量的 &lt;code&gt;UPPER&lt;/code&gt; 和 &lt;code&gt;LOWER&lt;/code&gt; 值实际上不区分大小写。</target>
        </trans-unit>
        <trans-unit id="75ff3ad897d4389bd5d4346a9d0cead6b649265f" translate="yes" xml:space="preserve">
          <source>If specified, &amp;lt;</source>
          <target state="translated">如果指定，&amp;lt;</target>
        </trans-unit>
        <trans-unit id="f6d52ca0abfa8f5411c2983924d29df64c8c256d" translate="yes" xml:space="preserve">
          <source>If specified, &lt;var&gt;file-name-1&lt;/var&gt; and &lt;var&gt;file-name-2&lt;/var&gt; must reference &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE SEQUENTIAL&lt;/a&gt;) or &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;) files. These files must be defined using a file description (&lt;code&gt;FD&lt;/code&gt; (see &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File/Sort-Description&lt;/a&gt;)). The same file(s) may be used for &lt;var&gt;file-name-1&lt;/var&gt; and &lt;var&gt;file-name-2&lt;/var&gt;.</source>
          <target state="translated">如果指定了 &lt;var&gt;file-name-1&lt;/var&gt; 和 &lt;var&gt;file-name-2&lt;/var&gt; 必须引用 &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; （请参见&lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE SEQUENTIAL&lt;/a&gt;）或 &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; （请参见&lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;）文件。这些文件必须使用文件描述（ &lt;code&gt;FD&lt;/code&gt; （请参阅&lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;文件/排序描述&lt;/a&gt;））进行定义。相同的文件可以用于 &lt;var&gt;file-name-1&lt;/var&gt; 和 &lt;var&gt;file-name-2&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="d643f7a76d11f3783c425395dd049a444b2d9584" translate="yes" xml:space="preserve">
          <source>If specified, &lt;var&gt;literal-1&lt;/var&gt; must be an actual alphanumeric literal and may not be a figurative constant.</source>
          <target state="translated">如果指定， &lt;var&gt;literal-1&lt;/var&gt; 必须是实际的字母数字文字，并且不能是图形常量。</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">如果</target>
        </trans-unit>
        <trans-unit id="a61102f29e127858b5b49ad3ddadb11d241c6452" translate="yes" xml:space="preserve">
          <source>If the  &lt;code&gt;CONSTANT&lt;/code&gt; option is used, &lt;var&gt;literal-1&lt;/var&gt; must also be used. This option provides another means of defining constants that may be used anywhere in the program that a literal could be specified.</source>
          <target state="translated">如果使用了 &lt;code&gt;CONSTANT&lt;/code&gt; 选项，则还必须使用 &lt;var&gt;literal-1&lt;/var&gt; 。此选项提供了另一种定义常量的方法，这些常量可以在程序中可以指定文字的任何位置使用。</target>
        </trans-unit>
        <trans-unit id="1b97cb6dfd7464ecb308b4b7b48f8c5eb2d3f1b9" translate="yes" xml:space="preserve">
          <source>If the  &lt;code&gt;CRT STATUS&lt;/code&gt; clause is not specified, an implicit  &lt;code&gt;COB-CRT-STATUS&lt;/code&gt; identifier (with a &lt;code&gt;PICTURE 9(4)&lt;/code&gt;) will be allocated for the purpose of receiving screen &lt;code&gt;ACCEPT&lt;/code&gt; statuses. If &lt;code&gt;CRT STATUS&lt;/code&gt; is specified, then &lt;var&gt;identifier-1&lt;/var&gt; must be defined in the program as a &lt;code&gt;PICTURE 9(4)&lt;/code&gt; field.</source>
          <target state="translated">如果未指定 &lt;code&gt;CRT STATUS&lt;/code&gt; 子句，则会为接收屏幕 &lt;code&gt;ACCEPT&lt;/code&gt; 状态分配一个隐式 &lt;code&gt;COB-CRT-STATUS&lt;/code&gt; 标识符（带有 &lt;code&gt;PICTURE 9(4)&lt;/code&gt; ）。如果指定了 &lt;code&gt;CRT STATUS&lt;/code&gt; ，则 &lt;var&gt;identifier-1&lt;/var&gt; 必须在程序中定义为 &lt;code&gt;PICTURE 9(4)&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="3d34d52f388167ee4038f6dc4387fe17a911a532" translate="yes" xml:space="preserve">
          <source>If the  &lt;code&gt;LOCK ON&lt;/code&gt; clause is</source>
          <target state="translated">如果 &lt;code&gt;LOCK ON&lt;/code&gt; 子句是</target>
        </trans-unit>
        <trans-unit id="10f70fdda4e9fca981b962e0cf0e57130077fb32" translate="yes" xml:space="preserve">
          <source>If the  &lt;code&gt;REMAINDER&lt;/code&gt; clause is coded, there may be only one &lt;var&gt;identifier-3&lt;/var&gt; specified.</source>
          <target state="translated">如果对 &lt;code&gt;REMAINDER&lt;/code&gt; 子句进行了编码，则可能只指定了一个 &lt;var&gt;identifier-3&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc641baf619f0e3d0d10496e69f3b55fd6e604c8" translate="yes" xml:space="preserve">
          <source>If the &amp;lt;</source>
          <target state="translated">如果&amp;lt;</target>
        </trans-unit>
        <trans-unit id="e13e056c87fa2f427f793205b7eacd30a5fd277c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ACCESS MODE&lt;/code&gt; of &lt;var&gt;file-name-1&lt;/var&gt; is &lt;code&gt;RANDOM&lt;/code&gt;, this is the</source>
          <target state="translated">如果 &lt;code&gt;ACCESS MODE&lt;/code&gt; 的 &lt;var&gt;file-name-1&lt;/var&gt; 是 &lt;code&gt;RANDOM&lt;/code&gt; ，这是</target>
        </trans-unit>
        <trans-unit id="cbfec2ca247c35b1fe3cd674bf865aa9c4e77254" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ACCESS MODE&lt;/code&gt; of &lt;var&gt;file-name-1&lt;/var&gt; is &lt;code&gt;SEQUENTIAL&lt;/code&gt;, or the &lt;code&gt;ORGANIZATION&lt;/code&gt; of the file is any form of sequential, this format of the &lt;code&gt;READ&lt;/code&gt; statement cannot be used.</source>
          <target state="translated">如果 &lt;code&gt;ACCESS MODE&lt;/code&gt; 的 &lt;var&gt;file-name-1&lt;/var&gt; 是 &lt;code&gt;SEQUENTIAL&lt;/code&gt; ，或 &lt;code&gt;ORGANIZATION&lt;/code&gt; 文件的任何形式的顺序时，这种格式 &lt;code&gt;READ&lt;/code&gt; 不能使用的语句。</target>
        </trans-unit>
        <trans-unit id="3b99a4ee59cfeb5de61b259ea000c70aa7e4d712" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ADDRESS OF&lt;/code&gt; clause is absent after the &lt;code&gt;TO&lt;/code&gt;, the contents of &lt;var&gt;pointer-name-2&lt;/var&gt; will serve as the address to be assigned.</source>
          <target state="translated">如果 &lt;code&gt;TO&lt;/code&gt; 后面不存在 &lt;code&gt;ADDRESS OF&lt;/code&gt; 子句，则 &lt;var&gt;pointer-name-2&lt;/var&gt; 的内容将用作要分配的地址。</target>
        </trans-unit>
        <trans-unit id="3a39328d467fa4aba02370624eef3ef047a3e884" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ALL&lt;/code&gt; keyword was specified on the &lt;code&gt;VALUE&lt;/code&gt; clause, all members of the field list with &lt;code&gt;VALUE&lt;/code&gt; clauses will qualify.</source>
          <target state="translated">如果在 &lt;code&gt;VALUE&lt;/code&gt; 子句上指定了 &lt;code&gt;ALL&lt;/code&gt; 关键字，则带有 &lt;code&gt;VALUE&lt;/code&gt; 子句的字段列表的所有成员都将符合条件。</target>
        </trans-unit>
        <trans-unit id="affc8978f778bb38e14313c6ca5fcc039529bb95" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ANYCASE&lt;/code&gt; keyword is specified, the matching rules for detecting a currency string in &lt;var&gt;argument-1&lt;/var&gt; are case-insensitive. If not specified, the matching rules are case-sensitive.</source>
          <target state="translated">如果指定了 &lt;code&gt;ANYCASE&lt;/code&gt; 关键字，则用于检测 &lt;var&gt;argument-1&lt;/var&gt; 中的货币字符串的匹配规则不区分大小写。如果未指定，则匹配规则区分大小写。</target>
        </trans-unit>
        <trans-unit id="6c01a232d52ad2f85603f61ab340b0cc67dd59c9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ANYCASE&lt;/code&gt; keyword is used the matching rules for detecting a currency string in &lt;var&gt;argument-1&lt;/var&gt; are case-insensitive. If the &lt;code&gt;ANYCASE&lt;/code&gt; keyword is not specified, the matching rules are case-sensitive.</source>
          <target state="translated">如果使用 &lt;code&gt;ANYCASE&lt;/code&gt; 关键字，则用于检测 &lt;var&gt;argument-1&lt;/var&gt; 中的货币字符串的匹配规则不区分大小写。如果未指定 &lt;code&gt;ANYCASE&lt;/code&gt; 关键字，则匹配规则区分大小写。</target>
        </trans-unit>
        <trans-unit id="cb8f2b64fc86910982f5fae1234323c5b508ae09" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;DISPLAY&lt;/code&gt; verb is executing, then the size is the same as if the &lt;code&gt;CONVERT&lt;/code&gt; phrase were not specified except for numeric items. For numeric items, the size is the number of digits in the item, plus one if it is not an integer, plus one if it is signed. The remaining cases cover the size when an &lt;code&gt;ACCEPT&lt;/code&gt; statement is used.</source>
          <target state="translated">如果正在执行 &lt;code&gt;DISPLAY&lt;/code&gt; 动词，则大小与未指定 &lt;code&gt;CONVERT&lt;/code&gt; 短语的大小相同，除了数字项。对于数字项目，大小是项目中的位数，如果不是整数，则加1，如果是带符号的，则加1。其余的情况包括使用 &lt;code&gt;ACCEPT&lt;/code&gt; 语句时的大小。</target>
        </trans-unit>
        <trans-unit id="b21479425a0b5f1b3972c0bb6a5e095100ce63f5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;FD&lt;/code&gt; of the file contains the &lt;code&gt;RECORD CONTAINS&lt;/code&gt; or &lt;code&gt;RECORD IS VARYING&lt;/code&gt; clause, and that clause allows the record size to vary, the size</source>
          <target state="translated">如果文件的 &lt;code&gt;FD&lt;/code&gt; 包含 &lt;code&gt;RECORD CONTAINS&lt;/code&gt; 或 &lt;code&gt;RECORD IS VARYING&lt;/code&gt; 子句，并且该子句允许记录大小发生变化，则该大小</target>
        </trans-unit>
        <trans-unit id="612748aa0fd9fd900088d10208b06bb3cf2d1475" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;FD&lt;/code&gt; of the file contains the &lt;code&gt;RECORD CONTAINS&lt;/code&gt; or &lt;code&gt;RECORD IS VARYING&lt;/code&gt; clause, and that clause allows the record size to vary, the size of &lt;var&gt;record-name-1&lt;/var&gt; cannot be altered.</source>
          <target state="translated">如果文件的 &lt;code&gt;FD&lt;/code&gt; 包含 &lt;code&gt;RECORD CONTAINS&lt;/code&gt; 或 &lt;code&gt;RECORD IS VARYING&lt;/code&gt; 子句，并且该子句允许更改记录大小，则无法更改 &lt;var&gt;record-name-1&lt;/var&gt; 的大小。</target>
        </trans-unit>
        <trans-unit id="e7c0d4e8f13608d05ca72c7f3b1d750f90712a45" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;KEY&lt;/code&gt; clause</source>
          <target state="translated">如果 &lt;code&gt;KEY&lt;/code&gt; 子句</target>
        </trans-unit>
        <trans-unit id="4547815fd9462b9fdfd1b9e08a5b31f916fcc311" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;KEY&lt;/code&gt; clause is absent, and the file is</source>
          <target state="translated">如果不存在 &lt;code&gt;KEY&lt;/code&gt; 子句，并且文件为</target>
        </trans-unit>
        <trans-unit id="c131416981dbc6b7002b415e8799c61201dcee0e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LINAGE&lt;/code&gt; (see &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File/Sort-Description&lt;/a&gt;) clause is</source>
          <target state="translated">如果 &lt;code&gt;LINAGE&lt;/code&gt; （请参阅&lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File / Sort-Description&lt;/a&gt;）子句是</target>
        </trans-unit>
        <trans-unit id="5958dd0b525624c148252a3b2cc0e92d9d3b1d1c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LOCK ON&lt;/code&gt; clause</source>
          <target state="translated">如果 &lt;code&gt;LOCK ON&lt;/code&gt; 子句</target>
        </trans-unit>
        <trans-unit id="4d86db89a19e04fde3c518d2333f8c4d9f0d9c88" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;PERFORM&lt;/code&gt; specifies or implies &lt;code&gt;WITH TEST BEFORE&lt;/code&gt;, &lt;var&gt;conditional-expression-1&lt;/var&gt; will be evaluated and processing of the &lt;code&gt;PERFORM&lt;/code&gt; will halt if the expression evaluates to &lt;code&gt;TRUE&lt;/code&gt;. If &lt;code&gt;WITH TEST BEFORE&lt;/code&gt; was</source>
          <target state="translated">如果 &lt;code&gt;PERFORM&lt;/code&gt; 指定或暗示 &lt;code&gt;WITH TEST BEFORE&lt;/code&gt; ，则将对 &lt;var&gt;conditional-expression-1&lt;/var&gt; 进行求值，并且如果表达式的求值为 &lt;code&gt;TRUE&lt;/code&gt; ，则 &lt;code&gt;PERFORM&lt;/code&gt; 的处理将停止。如果&amp;ldquo;在 &lt;code&gt;WITH TEST BEFORE&lt;/code&gt; 为</target>
        </trans-unit>
        <trans-unit id="c8a8781b936d58dad050ed871a38906d8222a3e3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;PROGRAM-ID&lt;/code&gt; (see &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt;) clause of the subprogram included the  &lt;code&gt;INITIAL&lt;/code&gt; clause, the program will be reinitialized back to its compile-time state. This will happen regardless of the &lt;code&gt;INITIAL&lt;/code&gt; clause the first time the subprogram is executed.</source>
          <target state="translated">如果子程序的 &lt;code&gt;PROGRAM-ID&lt;/code&gt; （请参阅&lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt;）子句包含 &lt;code&gt;INITIAL&lt;/code&gt; 子句，则该程序将重新初始化回到其编译时状态。不管首次执行子程序时的 &lt;code&gt;INITIAL&lt;/code&gt; 子句如何，都会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="61c625a5b9d0d59baca0aca12858bf1329830d25" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;RD&lt;/code&gt; (see &lt;a href=&quot;#REPORT-SECTION&quot;&gt;REPORT SECTION&lt;/a&gt;) in which the report group containing a &lt;code&gt;NEXT GROUP&lt;/code&gt; clause does not contain a &lt;code&gt;PAGE LIMITS&lt;/code&gt; clause, only the &lt;code&gt;PLUS integer-1&lt;/code&gt; option may be specified.</source>
          <target state="translated">如果 &lt;code&gt;RD&lt;/code&gt; （请参阅&lt;a href=&quot;#REPORT-SECTION&quot;&gt;REPORT SECTION&lt;/a&gt;）中包含 &lt;code&gt;NEXT GROUP&lt;/code&gt; 子句的报告组不包含 &lt;code&gt;PAGE LIMITS&lt;/code&gt; 子句，则只能指定 &lt;code&gt;PLUS integer-1&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="c8e781dd56448e51eb78f19906f5d0d7a4bbccc2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;RESET&lt;/code&gt; option is coded, &lt;code&gt;FINAL&lt;/code&gt; or &lt;var&gt;identifier-8&lt;/var&gt; (whichever is coded on the &lt;code&gt;RESET&lt;/code&gt;) must be one of the report&amp;rsquo;s control breaks specified on the &lt;code&gt;CONTROLS&lt;/code&gt; clause.</source>
          <target state="translated">如果对 &lt;code&gt;RESET&lt;/code&gt; 选项进行了编码，则 &lt;code&gt;FINAL&lt;/code&gt; 或 &lt;var&gt;identifier-8&lt;/var&gt; （以 &lt;code&gt;RESET&lt;/code&gt; 编码为准）必须是 &lt;code&gt;CONTROLS&lt;/code&gt; 子句中指定的报告控制中断之一。</target>
        </trans-unit>
        <trans-unit id="9731559b4666a0155b6ed6fd6776bba0461135ca" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;SELECT&lt;/code&gt; (see &lt;a href=&quot;#SELECT&quot;&gt;SELECT&lt;/a&gt;) statement or file &lt;code&gt;OPEN&lt;/code&gt; (see &lt;a href=&quot;#OPEN&quot;&gt;OPEN&lt;/a&gt;) specifies &lt;code&gt;SHARING WITH NO OTHER&lt;/code&gt;, record locking will be disabled.</source>
          <target state="translated">如果 &lt;code&gt;SELECT&lt;/code&gt; （请参阅&lt;a href=&quot;#SELECT&quot;&gt;SELECT&lt;/a&gt;）语句或 &lt;code&gt;OPEN&lt;/code&gt; （请参阅&lt;a href=&quot;#OPEN&quot;&gt;OPEN&lt;/a&gt;）文件指定 &lt;code&gt;SHARING WITH NO OTHER&lt;/code&gt; ，则将禁用记录锁定。</target>
        </trans-unit>
        <trans-unit id="c36b400baefa619ddc6f8161b993620feb6e7338" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;SELECT&lt;/code&gt; of a file is coded with a &lt;code&gt;FILE STATUS&lt;/code&gt; clause, &lt;code&gt;OPEN&lt;/code&gt; failures &amp;mdash; including those induced by sharing failures &amp;mdash; will be detectable by the program and a graceful recovery (or at least a graceful termination) will be possible. If no such clause was coded, however, a runtime message will be issued and the program will be terminated.</source>
          <target state="translated">如果使用 &lt;code&gt;FILE STATUS&lt;/code&gt; 子句对文件的 &lt;code&gt;SELECT&lt;/code&gt; 进行编码，则 &lt;code&gt;OPEN&lt;/code&gt; 失败-包括由共享失败引起的失败-将由程序检测到，并且可以正常恢复（或至少正常终止）。但是，如果未对此类子句进行编码，则会发出运行时消息并终止程序。</target>
        </trans-unit>
        <trans-unit id="6ae0587444dde6ad68a36a9c51951f280dcedd0b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;SEPARATE CHARACTER&lt;/code&gt; clause</source>
          <target state="translated">如果 &lt;code&gt;SEPARATE CHARACTER&lt;/code&gt; 子句</target>
        </trans-unit>
        <trans-unit id="8833ea8060feeb2e21ef8632dc5243ea617a1936" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;SIZE&lt;/code&gt; phrase is not used, then the field length defaults to the size of the item being accepted or displayed. If the &lt;code&gt;CONVERT&lt;/code&gt; phrase is used, however, then the size of the field depends on the data type of the item and the verb being used.</source>
          <target state="translated">如果未使用 &lt;code&gt;SIZE&lt;/code&gt; 短语，则字段长度默认为接受或显示的项目的大小。但是，如果使用了 &lt;code&gt;CONVERT&lt;/code&gt; 短语，则字段的大小取决于项目的数据类型和所使用的动词。</target>
        </trans-unit>
        <trans-unit id="f2e7f31806cccbda89316cd317a96b918accf50b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;SYNCRONIZED&lt;/code&gt; clause is coded on anything but a numeric data item with a &lt;code&gt;USAGE&lt;/code&gt; (see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) that specifies storage of data in a binary form, the &lt;code&gt;SYNCRONIZED&lt;/code&gt; clause will be ignored.</source>
          <target state="translated">如果将 &lt;code&gt;SYNCRONIZED&lt;/code&gt; 子句编码在除数字数据项之外的任何内容上，并且 &lt;code&gt;USAGE&lt;/code&gt; （请参阅&lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;）指定以二进制形式存储数据，则 &lt;code&gt;SYNCRONIZED&lt;/code&gt; 子句将被忽略。</target>
        </trans-unit>
        <trans-unit id="adb29705e22e972e94afa12e6e0d59c74f962b10" translate="yes" xml:space="preserve">
          <source>If the &lt;var&gt;Program-Source-Lines-n&lt;/var&gt;&amp;gt; statement block selected for processing is empty, no error results &amp;mdash; there will just be no code generated from the &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt;-&lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt; structure.</source>
          <target state="translated">如果选择要处理的 &lt;var&gt;Program-Source-Lines-n&lt;/var&gt; &amp;gt;语句块为空，则不会产生错误结果- &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt; - &lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt; 结构将不会生成任何代码。</target>
        </trans-unit>
        <trans-unit id="564bf6b26846f0e8ea8231e86eea4efd5ec50259" translate="yes" xml:space="preserve">
          <source>If the &lt;var&gt;Selection-Object&lt;/var&gt; is a &lt;var&gt;partial-expression&lt;/var&gt;, then the conditional expression that would be represented by coding &lt;code&gt;&lt;var&gt;Selection-Subject&lt;/var&gt; &lt;var&gt;Selection-Object&lt;/var&gt;&lt;/code&gt; evaluates to &lt;code&gt;TRUE&lt;/code&gt;</source>
          <target state="translated">如果 &lt;var&gt;Selection-Object&lt;/var&gt; 是 &lt;var&gt;partial-expression&lt;/var&gt; ，则将通过编码 &lt;code&gt;&lt;var&gt;Selection-Subject&lt;/var&gt; &lt;var&gt;Selection-Object&lt;/var&gt;&lt;/code&gt; 表示的条件表达式的计算结果为 &lt;code&gt;TRUE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66b0f3198b803257325039929d9fe35011c49095" translate="yes" xml:space="preserve">
          <source>If the &lt;var&gt;date&lt;/var&gt; is valid, a 0 value is returned. If it isn&amp;rsquo;t, a value of 1, 2 or 3 is returned signalling the problem lies with the year, month or day, respectively.</source>
          <target state="translated">如果 &lt;var&gt;date&lt;/var&gt; 有效，则返回0值。如果不是，则返回值1、2或3，分别表示问题出在年，月或日。</target>
        </trans-unit>
        <trans-unit id="9c430cd31b9abfd8e44351ebd7f1aa3c9a7a5032" translate="yes" xml:space="preserve">
          <source>If the &lt;var&gt;identifier-1&lt;/var&gt; option was used, altering the value of that data item within the perform scope will</source>
          <target state="translated">如果使用了 &lt;var&gt;identifier-1&lt;/var&gt; 选项，则在执行范围内更改该数据项的值将</target>
        </trans-unit>
        <trans-unit id="80f8927587ac8a416163b826212188d6cd97481c" translate="yes" xml:space="preserve">
          <source>If the DISPLAY verb is executing, then the size is the same as if the CONVERT phrase were not specified except for numeric items. For numeric items, the size is the number of digits in the item, plus one if it is not an integer, plus one if it is signed. The remaining cases cover the size when an ACCEPT statement is used.</source>
          <target state="translated">如果DISPLAY动词正在执行,那么大小与未指定CONVERT短语的情况相同,但数字项目除外。对于数字项,大小是项中的数字数,如果不是整数,则加1,如果是有符号的,则加1。其余情况包括使用ACCEPT语句时的大小。</target>
        </trans-unit>
        <trans-unit id="fd1fa5d5fdcea9b7c73d25c9d04a3be93ca9dd38" translate="yes" xml:space="preserve">
          <source>If the GnuCOBOL build you are using was configured to use the Berkeley Database (BDB) package for indexed file I/O, record locking will be available by using the</source>
          <target state="translated">如果你所使用的GnuCOBOL构建被配置为使用Berkeley数据库(BDB)包来进行索引文件I/O,那么记录锁定将可以通过使用</target>
        </trans-unit>
        <trans-unit id="0d899de06d6d01d580a3dfba1caa36e62b45d65a" translate="yes" xml:space="preserve">
          <source>If the GnuCOBOL build you are using was configured to use the Berkeley Database (BDB) package for indexed file I/O, record locking will be available by using the   &lt;code&gt;DB_HOME&lt;/code&gt; run-time environment variable.</source>
          <target state="translated">如果将您正在使用的GnuCOBOL构建配置为使用Berkeley数据库（BDB）包进行索引文件I / O，则可以通过使用 &lt;code&gt;DB_HOME&lt;/code&gt; 运行时环境变量来进行记录锁定。</target>
        </trans-unit>
        <trans-unit id="d9251feae92fd6a356cf9eb5cd17eee1487827fc" translate="yes" xml:space="preserve">
          <source>If the GnuCOBOL compiler you are using was built to utilize a native Windows environment, use a semicolon (&amp;lsquo;</source>
          <target state="translated">如果您使用的GnuCOBOL编译器是为利用本机Windows环境而构建的，请使用分号（'</target>
        </trans-unit>
        <trans-unit id="aa11e579492cde59f0f2b4460dae0515f472c0c0" translate="yes" xml:space="preserve">
          <source>If the GnuCOBOL compiler you are using was built to utilize a native Windows environment, use a semicolon (;) as the delimiter character.</source>
          <target state="translated">如果你使用的GnuCOBOL编译器是为了利用本地Windows环境而建立的,请使用分号(;)作为分隔符。</target>
        </trans-unit>
        <trans-unit id="e8e174d71b0a53ce0abb721ccafcd0e36830ee7a" translate="yes" xml:space="preserve">
          <source>If the LINAGE clause is</source>
          <target state="translated">如果LINAGE子句是</target>
        </trans-unit>
        <trans-unit id="876792b175fdff61a6c190841827c8f95e62bf94" translate="yes" xml:space="preserve">
          <source>If the SIZE phrase is not used, then the field length defaults to the size of the item being accepted or displayed. If the CONVERT phrase is used, however, then the size of the field depends on the data type of the item and the verb being used.</source>
          <target state="translated">如果不使用SIZE短语,那么字段长度默认为被接受或显示的项目的大小。但是,如果使用convert短语,那么字段的大小取决于项目的数据类型和使用的动词。</target>
        </trans-unit>
        <trans-unit id="629f7e68a3bad837fc28d40bdbf837b0b7cb4fda" translate="yes" xml:space="preserve">
          <source>If the arguments are of different classes, and one is national, the other argument is converted to class national for purposes of comparison.</source>
          <target state="translated">如果论点是不同类的,其中一个论点是全国性的,则另一个论点转为类全国性的,以便比较。</target>
        </trans-unit>
        <trans-unit id="56af7538068ae678c4d858d4ef9cbf8a92b01ddc" translate="yes" xml:space="preserve">
          <source>If the attempt to copy the file fails (for example, it or the destination directory doesn&amp;rsquo;t exist), the   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to 128; on successful completion it will be set to 0.</source>
          <target state="translated">如果尝试复制文件失败（例如，文件复制或目标目录不存在），则 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器（请参见&amp;ldquo;&lt;a href=&quot;#Special-Registers&quot;&gt;特殊寄存器&amp;rdquo;&lt;/a&gt;）将设置为128；否则，将设置为128。成功完成后，它将设置为0。</target>
        </trans-unit>
        <trans-unit id="a1a846b486d6a849fb5aee6dc27f07a8ed92c919" translate="yes" xml:space="preserve">
          <source>If the attempt to copy the file fails (for example, it or the destination directory doesn&amp;rsquo;t exist), the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to 128; on successful completion it will be set to 0.</source>
          <target state="translated">如果尝试复制文件失败（例如，文件失败或目标目录不存在），则 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器（请参见&lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;）将设置为128；成功完成后，它将设置为0。</target>
        </trans-unit>
        <trans-unit id="96df2a17b61b3c904901bfed0767bc034fc48ebb" translate="yes" xml:space="preserve">
          <source>If the attempt to delete the file fails (for example, it doesn&amp;rsquo;t exist), the   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to 128; on successful completion it will be set to 0.</source>
          <target state="translated">如果尝试删除文件失败（例如，该文件不存在），则 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器（请参见&lt;a href=&quot;#Special-Registers&quot;&gt;特殊寄存器&lt;/a&gt;）将设置为128；否则，该文件将被删除。成功完成后，它将设置为0。</target>
        </trans-unit>
        <trans-unit id="da68db930b7285a3ca3007bae8464343ac79a0ea" translate="yes" xml:space="preserve">
          <source>If the attempt to delete the file fails (for example, it doesn&amp;rsquo;t exist), the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to 128; on successful completion it will be set to 0.</source>
          <target state="translated">如果尝试删除文件失败（例如，该文件不存在），则 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器（请参见&lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;）将设置为128；成功完成后，它将设置为0。</target>
        </trans-unit>
        <trans-unit id="46a66bc0217d79087be7ab86156a7254a4cba8b6" translate="yes" xml:space="preserve">
          <source>If the attempt to move the file fails (for example, it doesn&amp;rsquo;t exist), the   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to 128; on successful completion it will be set to 0.</source>
          <target state="translated">如果尝试移动文件失败（例如，该文件不存在），则 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器（请参见&amp;ldquo;&lt;a href=&quot;#Special-Registers&quot;&gt;特殊寄存器&amp;rdquo;&lt;/a&gt;）将设置为128；否则，将设置为128。成功完成后，它将设置为0。</target>
        </trans-unit>
        <trans-unit id="6d499ade6d8bd513045d21fd97b496bc7d59e814" translate="yes" xml:space="preserve">
          <source>If the attempt to move the file fails (for example, it doesn&amp;rsquo;t exist), the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to 128; on successful completion it will be set to 0.</source>
          <target state="translated">如果尝试移动文件失败（例如，该文件不存在），则 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器（请参见&lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;）将设置为128；成功完成后，它将设置为0。</target>
        </trans-unit>
        <trans-unit id="9cc49a6a7bfb3aab04847a284111d2050a7803d8" translate="yes" xml:space="preserve">
          <source>If the binary item occupies four bytes of storage, the binary item is allocated at the next word boundary.</source>
          <target state="translated">如果二进制项占用4个字节的存储空间,则在下一个字边界分配二进制项。</target>
        </trans-unit>
        <trans-unit id="c9eb3b2ff78316af9e06d9ecdca03186e9054272" translate="yes" xml:space="preserve">
          <source>If the binary item occupies one byte of storage, no synchronization is performed.</source>
          <target state="translated">如果二进制项占用一个字节的存储空间,则不进行同步。</target>
        </trans-unit>
        <trans-unit id="29ee50f202c57db2b363fa927e6f5d81d5d2accb" translate="yes" xml:space="preserve">
          <source>If the binary item occupies two bytes of storage, the binary item is allocated at the next half-word boundary.</source>
          <target state="translated">如果二进制项占用两个字节的存储空间,则在下一个半字边界分配二进制项。</target>
        </trans-unit>
        <trans-unit id="1516aad53f3f5948528f5a4d82dbb11e687a6c3e" translate="yes" xml:space="preserve">
          <source>If the calling program included a &lt;code&gt;RETURNING&lt;/code&gt; clause on the &lt;code&gt;CALL&lt;/code&gt; statement that invoked the subprogram, the value of the &lt;code&gt;RETURNING&lt;/code&gt; data item in the subroutine is moved to that data item. If there was no &lt;code&gt;RETURNING&lt;/code&gt; specified in the subroutine, the value of the   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register is moved to that data item.</source>
          <target state="translated">如果调用程序在调用子程序的 &lt;code&gt;CALL&lt;/code&gt; 语句中包含 &lt;code&gt;RETURNING&lt;/code&gt; 子句，则子例程中 &lt;code&gt;RETURNING&lt;/code&gt; 数据项的值将移至该数据项。如果在子例程中未指定 &lt;code&gt;RETURNING&lt;/code&gt; ，则将 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器的值移至该数据项。</target>
        </trans-unit>
        <trans-unit id="78d1c026459ef474eb28e2011cf978cfda3d3820" translate="yes" xml:space="preserve">
          <source>If the calling program included a&lt;code&gt;RETURNING&lt;/code&gt;clause on the&lt;code&gt;CALL&lt;/code&gt;statement that invoked the subprogram, the value of the&lt;code&gt;RETURNING&lt;/code&gt;data item in the subroutine is moved to that data item. If there was no&lt;code&gt;RETURNING&lt;/code&gt;specified in the subroutine, the value of the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register is moved to that data item.</source>
          <target state="translated">如果调用程序在调用子程序的 &lt;code&gt;CALL&lt;/code&gt; 语句中包含 &lt;code&gt;RETURNING&lt;/code&gt; 子句，则子例程中 &lt;code&gt;RETURNING&lt;/code&gt; 数据项的值将移至该数据项。如果在子例程中未指定 &lt;code&gt;RETURNING&lt;/code&gt; ，则将 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器的值移至该数据项。</target>
        </trans-unit>
        <trans-unit id="e083d7f833ec502784a9231152a3dee4dd0d633a" translate="yes" xml:space="preserve">
          <source>If the compiler</source>
          <target state="translated">如果编译器</target>
        </trans-unit>
        <trans-unit id="237f820b1887571d0c11ce781473f803467fad98" translate="yes" xml:space="preserve">
          <source>If the compiler &quot;config&quot; file (see &lt;a href=&quot;#Compiler-Configuration-Files&quot;&gt;Compiler Configuration Files&lt;/a&gt;) you used to compile the program specified &quot;mf&quot; as the &quot;assign-clause&quot; value, then the File Locator String will be interpreted according to Microfocus COBOL rules &amp;mdash; namely, everything before the last &quot;-&quot; in the File Locator String will be ignored; the characters after the last &quot;-&quot; will be treated as the base of an environment variable name. If there is no &quot;-&quot; character in the File Locator String then the entire File Locator String will serve as the base of an environment variable name. This is the default behaviour for every config file except &quot;ibm&quot;.</source>
          <target state="translated">如果您用来编译程序的编译器&amp;ldquo; config&amp;rdquo;文件（请参阅&lt;a href=&quot;#Compiler-Configuration-Files&quot;&gt;编译器配置文件&lt;/a&gt;）指定为&amp;ldquo; asf-clause&amp;rdquo;值，则文件定位符字符串将根据Microfocus COBOL规则进行解释，即之前的所有内容。文件定位符字符串中的最后一个&amp;ldquo;-&amp;rdquo;将被忽略；最后一个&amp;ldquo;-&amp;rdquo;之后的字符将被视为环境变量名称的基础。如果文件定位符字符串中没有&amp;ldquo;-&amp;rdquo;字符，则整个文件定位符字符串将用作环境变量名称的基础。这是除&amp;ldquo; ibm&amp;rdquo;以外的每个配置文件的缺省行为。</target>
        </trans-unit>
        <trans-unit id="be7c428b2bd6fcf64ba18d7fc20a33ae78ee6418" translate="yes" xml:space="preserve">
          <source>If the compiler &quot;config&quot; file you are using has &quot;relaxed-syntax-check&quot; set to &quot;yes&quot;, the&lt;code&gt;FILE-CONTROL&lt;/code&gt;and&lt;code&gt;I-O-CONTROL&lt;/code&gt;paragraphs may be specified without the&lt;code&gt;INPUT-OUTPUT SECTION.&lt;/code&gt;header having been coded.</source>
          <target state="translated">如果您正在使用的编译器&amp;ldquo; config&amp;rdquo;文件的&amp;ldquo; relaxed-syntax-check&amp;rdquo;设置为&amp;ldquo; yes&amp;rdquo;，则可以指定 &lt;code&gt;FILE-CONTROL&lt;/code&gt; 和 &lt;code&gt;I-O-CONTROL&lt;/code&gt; 段落，而无需 &lt;code&gt;INPUT-OUTPUT SECTION.&lt;/code&gt; 标头已编码。</target>
        </trans-unit>
        <trans-unit id="fe92b0755173ad538d05379125cea0810a360175" translate="yes" xml:space="preserve">
          <source>If the compiler &quot;config&quot; file you used to compile the program with had a &quot;filename-mapping&quot; value of &quot;yes&quot;, the GnuCOBOL runtime system will first attempt to identify a currently-defined environment variable whose value will serve as the data file&amp;rsquo;s path and filename, as follows:</source>
          <target state="translated">如果您用来编译程序的编译器&amp;ldquo; config&amp;rdquo;文件的&amp;ldquo;文件名映射&amp;rdquo;值为&amp;ldquo; yes&amp;rdquo;，则GnuCOBOL运行时系统将首先尝试识别当前定义的环境变量，该变量将用作数据文件的路径和文件名，如下所示：</target>
        </trans-unit>
        <trans-unit id="ada8d4fd5949881c69e3976ea553cf9ce6a69ad2" translate="yes" xml:space="preserve">
          <source>If the compiler is already in the specified mode, this statement will have no effect.</source>
          <target state="translated">如果编译器已经在指定的模式下,这条语句将没有任何效果。</target>
        </trans-unit>
        <trans-unit id="e079882ba26c2f94b1fe1a9df7387534f553e034" translate="yes" xml:space="preserve">
          <source>If the condition associated with a variable is false, the variable is not defined during compilations.</source>
          <target state="translated">如果与变量相关联的条件为false,则在编译过程中不定义变量。</target>
        </trans-unit>
        <trans-unit id="481059d865593d9863661241b07d6b44c95410c1" translate="yes" xml:space="preserve">
          <source>If the condition-name has a value of &lt;code&gt;TRUE&lt;/code&gt;, the group will be presented.</source>
          <target state="translated">如果condition-name的值为 &lt;code&gt;TRUE&lt;/code&gt; ，则将显示该组。</target>
        </trans-unit>
        <trans-unit id="3a326fe6a76a0eaf9c6262d498515fe5ffc5ef03" translate="yes" xml:space="preserve">
          <source>If the condition-name has a value of TRUE, the group will be presented.</source>
          <target state="translated">如果条件名称的值为 &quot;TRUE&quot;,则该组将被呈现。</target>
        </trans-unit>
        <trans-unit id="4acbc5f8b855a0f2c7b341b78e53f686bdfdc939" translate="yes" xml:space="preserve">
          <source>If the counter has a value greater than zero, the statement(s) within the &lt;code&gt;PERFORM&lt;/code&gt; scope will be executed, after which the counter will be decremented by 1 with each repetition. Once that counter reaches zero, repetition will cease and control will fall into the next statement following the &lt;code&gt;PERFORM&lt;/code&gt;.</source>
          <target state="translated">如果计数器的值大于零，则将执行 &lt;code&gt;PERFORM&lt;/code&gt; 范围内的语句，此后每次重复计数器将减1。一旦该计数器达到零，重复将停止并且控制权将落在 &lt;code&gt;PERFORM&lt;/code&gt; 之后的下一条语句中。</target>
        </trans-unit>
        <trans-unit id="8c023cec5138da702e62deee764a0698dddd5f75" translate="yes" xml:space="preserve">
          <source>If the counter has a value greater than zero, the statement(s) within the&lt;code&gt;PERFORM&lt;/code&gt;scope will be executed, after which the counter will be decremented by 1 with each repetition. Once that counter reaches zero, repetition will cease and control will fall into the next statement following the&lt;code&gt;PERFORM&lt;/code&gt;</source>
          <target state="translated">如果计数器的值大于零，则将执行 &lt;code&gt;PERFORM&lt;/code&gt; 范围内的语句，此后每次重复计数器将减1。一旦该计数器达到零，重复将停止并且控制权将落入 &lt;code&gt;PERFORM&lt;/code&gt; 之后的下一条语句中</target>
        </trans-unit>
        <trans-unit id="8c6046d88dbdb2938b2d2acebdcd24126952a996" translate="yes" xml:space="preserve">
          <source>If the cultural ordering table is not available on the processor, or the specified ordering level is not available, or the level number specified by &lt;var&gt;argument-4&lt;/var&gt; is not defined in the ordering table, the &lt;code&gt;EC-ORDER-NOT-SUPPORTED&lt;/code&gt; exception condition is set.</source>
          <target state="translated">如果文化排序表在处理器上不可用，或者指定的订购级别不可用，或者在订购表中未定义 &lt;var&gt;argument-4&lt;/var&gt; 指定的级别号，则将设置 &lt;code&gt;EC-ORDER-NOT-SUPPORTED&lt;/code&gt; 异常条件。</target>
        </trans-unit>
        <trans-unit id="4e9e418e6dfdb063a1e13b0c99a0aba0ba8470f4" translate="yes" xml:space="preserve">
          <source>If the data item in which the &lt;code&gt;SUM&lt;/code&gt; clause appears has been assigned its own identifier name, and that name is not &lt;code&gt;FILLER&lt;/code&gt;, then that data item is referred to as a sum counter.</source>
          <target state="translated">如果出现 &lt;code&gt;SUM&lt;/code&gt; 子句的数据项已分配了自己的标识符名称，并且该名称不是 &lt;code&gt;FILLER&lt;/code&gt; ，则将该数据项称为总和计数器。</target>
        </trans-unit>
        <trans-unit id="139a2f116480a978d8a516ae3f69011cef95b11e" translate="yes" xml:space="preserve">
          <source>If the data item in which the&lt;code&gt;SUM&lt;/code&gt;clause appears has been assigned it&amp;rsquo;s own identifier name, and that name is not&lt;code&gt;FILLER&lt;/code&gt; then that data item is referred to as a sum counter.</source>
          <target state="translated">如果已为出现 &lt;code&gt;SUM&lt;/code&gt; 子句的数据项分配了自己的标识符名称，并且该名称不是 &lt;code&gt;FILLER&lt;/code&gt; ,则该数据项称为总和计数器。</target>
        </trans-unit>
        <trans-unit id="d6641aac6877a23c3a650b80aa0141134bfbab68" translate="yes" xml:space="preserve">
          <source>If the date is valid, a 0 value is returned. If it isn&amp;rsquo;t, a value of 1 or 2 is returned signalling the problem lies with the year or day, respectively.</source>
          <target state="translated">如果日期有效，则返回0值。如果不是，则返回值1或2，分别表示问题出在年或日。</target>
        </trans-unit>
        <trans-unit id="7b011773af10dd8c1b119874aa6b6d6a7bdffaf9" translate="yes" xml:space="preserve">
          <source>If the file defined by the &amp;lt;</source>
          <target state="translated">如果文件由&amp;lt;</target>
        </trans-unit>
        <trans-unit id="280352139004548c36bc2735b683a84068a2d2ad" translate="yes" xml:space="preserve">
          <source>If the file defined by the &lt;var&gt;file-handle&lt;/var&gt; argument (a &lt;code&gt;PIC X(4) USAGE COMP-X&lt;/code&gt; data item) was opened for output, an implicit &lt;code&gt;CBL_FLUSH_FILE&lt;/code&gt; built-in system subroutine (see &lt;a href=&quot;#CBL_005fFLUSH_005fFILE&quot;&gt;CBL_FLUSH_FILE&lt;/a&gt;) will be performed before the file is closed.</source>
          <target state="translated">如果打开了由 &lt;var&gt;file-handle&lt;/var&gt; 参数定义的文件（ &lt;code&gt;PIC X(4) USAGE COMP-X&lt;/code&gt; 数据项）以进行输出，则在关闭文件之前，将执行隐式 &lt;code&gt;CBL_FLUSH_FILE&lt;/code&gt; 内置系统子例程（请参见&lt;a href=&quot;#CBL_005fFLUSH_005fFILE&quot;&gt;CBL_FLUSH_FILE&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b49b836ff4d8cb3dab39eaf631a058c6fcd3656e" translate="yes" xml:space="preserve">
          <source>If the file has &lt;code&gt;ACCESS MODE SEQUENTIAL&lt;/code&gt;, the record to be rewritten will be the one retrieved by the most-recently executed &lt;code&gt;READ&lt;/code&gt; of the file. If the file has &lt;code&gt;ACCESS MODE RANDOM&lt;/code&gt; or &lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt;, no &lt;code&gt;READ&lt;/code&gt; is required before a record may be rewritten &amp;mdash; the &lt;code&gt;RELATIVE KEY&lt;/code&gt; or &lt;code&gt;RECORD KEY&lt;/code&gt; definition for the file, respectively, will specify the record to be updated.</source>
          <target state="translated">如果文件具有 &lt;code&gt;ACCESS MODE SEQUENTIAL&lt;/code&gt; ，则要重写的记录将是最近执行的文件 &lt;code&gt;READ&lt;/code&gt; 检索的记录。如果文件具有 &lt;code&gt;ACCESS MODE RANDOM&lt;/code&gt; 或 &lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt; ，则在可以重写记录之前不需要 &lt;code&gt;READ&lt;/code&gt; -文件的 &lt;code&gt;RELATIVE KEY&lt;/code&gt; 或 &lt;code&gt;RECORD KEY&lt;/code&gt; 定义将分别指定要更新的记录。</target>
        </trans-unit>
        <trans-unit id="b92cdda09e23c6babe9323f2fab796558b95e032" translate="yes" xml:space="preserve">
          <source>If the file has &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;) or &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;):</source>
          <target state="translated">如果文件具有 &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; （请参见&lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;）或 &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; （请参见&lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="9bb8fcfe2e45e1f8ae2ed6c423aee276e8feaa74" translate="yes" xml:space="preserve">
          <source>If the file has &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;):</source>
          <target state="translated">如果文件具有 &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; （请参见&lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="8308b61ce7bcbfc94d926cc1722564983504a579" translate="yes" xml:space="preserve">
          <source>If the file has&lt;code&gt;ACCESS MODE SEQUENTIAL&lt;/code&gt; the record to be rewritten will be the one retrieved by the most-recently executed&lt;code&gt;READ&lt;/code&gt;of the file. If the file has&lt;code&gt;ACCESS MODE RANDOM&lt;/code&gt;or&lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt; no&lt;code&gt;READ&lt;/code&gt;is required before a record may be rewritten &amp;mdash; the&lt;code&gt;RELATIVE KEY&lt;/code&gt;or&lt;code&gt;RECORD KEY&lt;/code&gt;definition for the file, respectively, will specify the record to be updated.</source>
          <target state="translated">如果文件具有 &lt;code&gt;ACCESS MODE SEQUENTIAL&lt;/code&gt; ，则要重写的记录将是最近执行的文件 &lt;code&gt;READ&lt;/code&gt; 检索的记录。如果文件具有 &lt;code&gt;ACCESS MODE RANDOM&lt;/code&gt; 或 &lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt; ,则在可以重写记录之前不需要 &lt;code&gt;READ&lt;/code&gt; -文件的 &lt;code&gt;RELATIVE KEY&lt;/code&gt; 或 &lt;code&gt;RECORD KEY&lt;/code&gt; 定义将分别指定要更新的记录。</target>
        </trans-unit>
        <trans-unit id="979f0a1fc8e50fd115ef1c5a2607d25c8a146e66" translate="yes" xml:space="preserve">
          <source>If the file has&lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;) or&lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;):</source>
          <target state="translated">如果文件具有 &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; （请参见&lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;）或 &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; （请参见&lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="a1d7d6e295ed262b048e40c65c57cc69c1a22916" translate="yes" xml:space="preserve">
          <source>If the file has&lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;):</source>
          <target state="translated">如果文件具有 &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; （请参见&lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="ebc6dd0f2cfa35fc8904be11678446623b9ff834" translate="yes" xml:space="preserve">
          <source>If the file&amp;rsquo;s &lt;code&gt;SELECT&lt;/code&gt; contains a &lt;code&gt;LOCK MODE IS AUTOMATIC&lt;/code&gt; clause, every time a record is read from the file, that record is automatically locked. Other programs may access</source>
          <target state="translated">如果文件的 &lt;code&gt;SELECT&lt;/code&gt; 包含 &lt;code&gt;LOCK MODE IS AUTOMATIC&lt;/code&gt; 子句，则每次从文件中读取一条记录时，该记录都会被自动锁定。其他程序可能会访问</target>
        </trans-unit>
        <trans-unit id="5581252930e28cda52f7dd409750375325db5ed0" translate="yes" xml:space="preserve">
          <source>If the file&amp;rsquo;s &lt;code&gt;SELECT&lt;/code&gt; contains a &lt;code&gt;LOCK MODE IS MANUAL&lt;/code&gt; clause, locks are placed on records</source>
          <target state="translated">如果文件的 &lt;code&gt;SELECT&lt;/code&gt; 包含 &lt;code&gt;LOCK MODE IS MANUAL&lt;/code&gt; 子句，则将锁放置在记录上</target>
        </trans-unit>
        <trans-unit id="e57bb4b94ad8d138b6e068547fa0dd3393b0fc4d" translate="yes" xml:space="preserve">
          <source>If the file&amp;rsquo;s&lt;code&gt;SELECT&lt;/code&gt;contains a&lt;code&gt;LOCK MODE IS AUTOMATIC&lt;/code&gt;</source>
          <target state="translated">如果文件的 &lt;code&gt;SELECT&lt;/code&gt; 包含 &lt;code&gt;LOCK MODE IS AUTOMATIC&lt;/code&gt; 的LOCK MODE</target>
        </trans-unit>
        <trans-unit id="b0edb822a1ecdc41221997c63041ba9a3c222689" translate="yes" xml:space="preserve">
          <source>If the file&amp;rsquo;s&lt;code&gt;SELECT&lt;/code&gt;contains a&lt;code&gt;LOCK MODE IS MANUAL&lt;/code&gt;</source>
          <target state="translated">如果文件的&amp;ldquo; &lt;code&gt;SELECT&lt;/code&gt; &amp;rdquo;包含&amp;ldquo; &lt;code&gt;LOCK MODE IS MANUAL&lt;/code&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="10abb20b2ca302db903ccde6ac80ddbd1e14af4b" translate="yes" xml:space="preserve">
          <source>If the format in &lt;var&gt;argument-1&lt;/var&gt; indicates that the returned value is to be expressed in UTC, the time portion of the returned value reflects the adjustment of the value in &lt;var&gt;argument-2&lt;/var&gt; by the offset in &lt;var&gt;argument-3&lt;/var&gt;.</source>
          <target state="translated">如果在格式 &lt;var&gt;argument-1&lt;/var&gt; 表示返回的值是在UTC中表达，则返回的值的时间部分反映值在调整 &lt;var&gt;argument-2&lt;/var&gt; 通过在偏移 &lt;var&gt;argument-3&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fd625e9cd0e795e1abbea2d50fee9d16f247fea" translate="yes" xml:space="preserve">
          <source>If the format in &lt;var&gt;argument-1&lt;/var&gt; indicates that the returned value is to be expressed in UTC, the time portion of the returned value reflects the adjustment of the value in &lt;var&gt;argument-3&lt;/var&gt; by the offset in &lt;var&gt;argument-4&lt;/var&gt;.</source>
          <target state="translated">如果在格式 &lt;var&gt;argument-1&lt;/var&gt; 表示返回的值是在UTC中表达，则返回的值的时间部分反映值在调整 &lt;var&gt;argument-3&lt;/var&gt; 通过在偏移 &lt;var&gt;argument-4&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="166178cacdbe5fd462fb190489612b357d06f5ce" translate="yes" xml:space="preserve">
          <source>If the format in &lt;var&gt;argument-1&lt;/var&gt; indicates that the time is to be returned as an offset from UTC, the value in &lt;var&gt;argument-2&lt;/var&gt; is reflected directly in the time portion of the returned value and the offset in &lt;var&gt;argument-3&lt;/var&gt; is reflected directly in the offset portion of the returned value.</source>
          <target state="translated">如果 &lt;var&gt;argument-1&lt;/var&gt; 的格式指示要以相对于UTC的偏移量返回时间，则 &lt;var&gt;argument-2&lt;/var&gt; 的值将直接反映在返回值的时间部分中， &lt;var&gt;argument-3&lt;/var&gt; 的偏移量将直接反映在返回值中返回值的偏移量部分。</target>
        </trans-unit>
        <trans-unit id="26e28a33e8881735eccfadfa004e07caea00d59d" translate="yes" xml:space="preserve">
          <source>If the format in &lt;var&gt;argument-1&lt;/var&gt; indicates that the time is to be returned as an offset from UTC, the value in &lt;var&gt;argument-3&lt;/var&gt; is reflected directly in the time portion of the returned value and the offset in &lt;var&gt;argument-4&lt;/var&gt; is reflected directly in the offset portion of the returned value.</source>
          <target state="translated">如果在格式 &lt;var&gt;argument-1&lt;/var&gt; 表示该时刻将被返回作为偏移从UTC，中值 &lt;var&gt;argument-3&lt;/var&gt; 在返回的值的时间部分直接反射，并且在偏移 &lt;var&gt;argument-4&lt;/var&gt; 在被直接反射返回值的偏移量部分。</target>
        </trans-unit>
        <trans-unit id="baea16fa39768fdef0af9d58e56f8513fcbd8390" translate="yes" xml:space="preserve">
          <source>If the function issues a &lt;code&gt;STOP&lt;/code&gt; statement (see &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;) with the &lt;code&gt;RUN&lt;/code&gt; option, program execution ceases and control returns to the operating system or whatever execution shell invoked the main program.</source>
          <target state="translated">如果函数使用 &lt;code&gt;RUN&lt;/code&gt; 选项发出 &lt;code&gt;STOP&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;），则程序将停止执行，并且控制权返回到操作系统或调用主程序的任何执行外壳。</target>
        </trans-unit>
        <trans-unit id="9ac3ef7c53e5a1a9ebd82e6132c731fb366bb269" translate="yes" xml:space="preserve">
          <source>If the function issues a&lt;code&gt;STOP&lt;/code&gt;statement (see &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;) with the&lt;code&gt;RUN&lt;/code&gt;option, program execution ceases and control returns to the operating system or whatever execution shell invoked the main program.</source>
          <target state="translated">如果该函数使用 &lt;code&gt;RUN&lt;/code&gt; 选项发出 &lt;code&gt;STOP&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;），则程序将停止执行，控制权将返回到操作系统或调用主程序的任何执行外壳。</target>
        </trans-unit>
        <trans-unit id="35a6f4e231eb8c92eedcef095e1eb5b985195124" translate="yes" xml:space="preserve">
          <source>If the function wishes to return control back to the calling program, it will do so using either the &lt;code&gt;GOBACK&lt;/code&gt; statement (see &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;) or the &lt;code&gt;EXIT FUNCTION&lt;/code&gt; statement (see &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;). At this time:</source>
          <target state="translated">如果函数希望将控制权返回给调用程序，它将使用 &lt;code&gt;GOBACK&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;）或 &lt;code&gt;EXIT FUNCTION&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;）来完成。此时：</target>
        </trans-unit>
        <trans-unit id="768fc6ac0826962232769e54ee3d27933dbe814a" translate="yes" xml:space="preserve">
          <source>If the function wishes to return control back to the calling program, it will do so using either the&lt;code&gt;GOBACK&lt;/code&gt;statement (see &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;) or the&lt;code&gt;EXIT FUNCTION&lt;/code&gt;statement (see &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;). At this time:</source>
          <target state="translated">如果函数希望将控制权返回给调用程序，它将使用 &lt;code&gt;GOBACK&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;）或 &lt;code&gt;EXIT FUNCTION&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;）来完成。此时：</target>
        </trans-unit>
        <trans-unit id="30455ee292f12916879ea7b27b16596593857296" translate="yes" xml:space="preserve">
          <source>If the item is alphanumeric edited, then the size is set to the number of &quot;A&quot; or &quot;X&quot; positions specified in its PICTURE clause.</source>
          <target state="translated">如果项目是字母数字编辑,则大小设置为其PICTURE子句中指定的 &quot;A &quot;或 &quot;X &quot;位置数。</target>
        </trans-unit>
        <trans-unit id="7a208a6cc6a893ebed7ca1af029a4cbd81f73ef4" translate="yes" xml:space="preserve">
          <source>If the item is alphanumeric edited, then the size is set to the number of &amp;lsquo;</source>
          <target state="translated">如果项目是字母数字编辑的，则将大小设置为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="5a3ac59ecad83c4e62bbb64e4efcc1980153a8fd" translate="yes" xml:space="preserve">
          <source>If the item is numeric or numeric edited, then the size is the number of digits in the item, plus one if it is not an integer, plus one if it is signed.</source>
          <target state="translated">如果项目是数字或数字编辑,则大小为项目中的数字数,如果不是整数则加1,如果是符号则加1。</target>
        </trans-unit>
        <trans-unit id="0bf6190961c1d912062042b050c89a336fba6e4f" translate="yes" xml:space="preserve">
          <source>If the key(s) and value(s) match, &amp;lt;</source>
          <target state="translated">如果键和值匹配，则&amp;lt;</target>
        </trans-unit>
        <trans-unit id="364099d939dac1d20ae3d5cb7f9ea15deb38944b" translate="yes" xml:space="preserve">
          <source>If the key(s) and value(s) match, &lt;var&gt;imperative-statement-2&lt;/var&gt; (see &lt;a href=&quot;#Imperative-Statement&quot;&gt;Imperative Statement&lt;/a&gt;) is executed, after which control falls through into the next statement following the &lt;code&gt;SEARCH ALL&lt;/code&gt;.</source>
          <target state="translated">如果键和值匹配，则执行 &lt;var&gt;imperative-statement-2&lt;/var&gt; （请参阅&lt;a href=&quot;#Imperative-Statement&quot;&gt;Imperative语句&lt;/a&gt;），然后控制权落到 &lt;code&gt;SEARCH ALL&lt;/code&gt; 之后的下一个语句中。</target>
        </trans-unit>
        <trans-unit id="8718b549db26737624f77d41114ec5bbc3bc5cfc" translate="yes" xml:space="preserve">
          <source>If the key(s) are GREATER THAN the value(s), then the table entry being searched for can only occur in the &quot;first&quot; to &quot;current&quot; range of the table, so a new &quot;last&quot; pointer value is set (it will be set to the &quot;current&quot; pointer).</source>
          <target state="translated">如果key(s)大于value(s),那么被搜索的表条目只能出现在表的 &quot;first &quot;到 &quot;current &quot;范围内,所以设置一个新的 &quot;last &quot;指针值(它将被设置为 &quot;current &quot;指针)。</target>
        </trans-unit>
        <trans-unit id="26a06caa2d8e4511f177ae678ee1706922a64e12" translate="yes" xml:space="preserve">
          <source>If the key(s) are GREATER THAN the value(s), then the table entry being searched for can only occur in the &amp;ldquo;first&amp;rdquo; to &amp;ldquo;current&amp;rdquo; range of the table, so a new &amp;ldquo;last&amp;rdquo; pointer value is set (it will be set to the &amp;ldquo;current&amp;rdquo; pointer).</source>
          <target state="translated">如果键的值大于值，则所搜索的表项只能出现在表的&amp;ldquo;第一个&amp;rdquo;到&amp;ldquo;当前&amp;rdquo;范围内，因此设置了一个新的&amp;ldquo;最后一个&amp;rdquo;指针值（它将被设置为&amp;ldquo;当前&amp;rdquo;指针）。</target>
        </trans-unit>
        <trans-unit id="f855f7c7ead100cd07565ea01cc7a9230a155db1" translate="yes" xml:space="preserve">
          <source>If the key(s) are LESS THAN the value(s), then the table entry being searched for can only occur in the &quot;current&quot; to &quot;last&quot; range of the table, so a new &quot;first&quot; pointer value is set (it will be set to the &quot;current&quot; pointer).</source>
          <target state="translated">如果key(s)小于value(s),那么被搜索的表条目只能出现在表的 &quot;current &quot;到 &quot;last &quot;范围内,所以设置一个新的 &quot;first &quot;指针值(它将被设置为 &quot;current &quot;指针)。</target>
        </trans-unit>
        <trans-unit id="998f5bf567570409a15717d5bf167eb530056f3b" translate="yes" xml:space="preserve">
          <source>If the key(s) are LESS THAN the value(s), then the table entry being searched for can only occur in the &amp;ldquo;current&amp;rdquo; to &amp;ldquo;last&amp;rdquo; range of the table, so a new &amp;ldquo;first&amp;rdquo; pointer value is set (it will be set to the &amp;ldquo;current&amp;rdquo; pointer).</source>
          <target state="translated">如果键小于值，则要搜索的表条目只能出现在表的&amp;ldquo;当前&amp;rdquo;到&amp;ldquo;最后&amp;rdquo;范围内，因此设置了新的&amp;ldquo;第一个&amp;rdquo;指针值（它将被设置为&amp;ldquo;当前&amp;rdquo;指针）。</target>
        </trans-unit>
        <trans-unit id="67dac445610e60fc54c4fe228d7fb92749633d59" translate="yes" xml:space="preserve">
          <source>If the last exception status is not an &lt;code&gt;EC-I-O&lt;/code&gt; exception condition, the returned value is two national zeros.</source>
          <target state="translated">如果最后一个异常状态不是 &lt;code&gt;EC-I-O&lt;/code&gt; 异常条件，则返回值为两个国家零。</target>
        </trans-unit>
        <trans-unit id="75791070ef3413617c60c665e733867b07b700c6" translate="yes" xml:space="preserve">
          <source>If the length of &amp;lt;</source>
          <target state="translated">如果长度&amp;lt;</target>
        </trans-unit>
        <trans-unit id="bde88dc03a2aeb1136469227b1d64906347783ff" translate="yes" xml:space="preserve">
          <source>If the length of &lt;var&gt;literal-7&lt;/var&gt; or &lt;var&gt;identifier-8&lt;/var&gt; (the &amp;ldquo;from&amp;rdquo; string)</source>
          <target state="translated">如果 &lt;var&gt;literal-7&lt;/var&gt; 或 &lt;var&gt;identifier-8&lt;/var&gt; 的长度（&amp;ldquo; from&amp;rdquo;字符串）</target>
        </trans-unit>
        <trans-unit id="f678ec7b4d2b5c8286ebadce4169b6ec51506464" translate="yes" xml:space="preserve">
          <source>If the length of the &quot;from&quot; string</source>
          <target state="translated">如果 &quot;from &quot;字符串的长度</target>
        </trans-unit>
        <trans-unit id="4967916491cd5aa62c1b2e2727ffb24cfed85aa7" translate="yes" xml:space="preserve">
          <source>If the length of the &amp;ldquo;from&amp;rdquo; string</source>
          <target state="translated">如果&amp;ldquo; from&amp;rdquo;字符串的长度</target>
        </trans-unit>
        <trans-unit id="163af06aed58d0ce62be6ce917a711c8bc398a55" translate="yes" xml:space="preserve">
          <source>If the new &quot;first&quot; and &quot;last&quot; pointers are different than the old &quot;first&quot; and &quot;last&quot; pointers, there&amp;rsquo;s more left to be searched, so return to step (A) and continue.</source>
          <target state="translated">如果新的&amp;ldquo;第一个&amp;rdquo;和&amp;ldquo;最后一个&amp;rdquo;指针与旧的&amp;ldquo;第一个&amp;rdquo;和&amp;ldquo;最后一个&amp;rdquo;指针不同，则还有更多要搜索的指针，因此返回步骤（A）并继续。</target>
        </trans-unit>
        <trans-unit id="20cd460d91c2dd82c32020553b0991e55b5ca84b" translate="yes" xml:space="preserve">
          <source>If the new &quot;first&quot; and &quot;last&quot; pointers are the same as the old &quot;first&quot; and &quot;last&quot; pointers, the table has been exhausted and the entry being searched for cannot be found; &amp;lt;</source>
          <target state="translated">如果新的&amp;ldquo;第一个&amp;rdquo;和&amp;ldquo;最后一个&amp;rdquo;指针与旧的&amp;ldquo;第一个&amp;rdquo;和&amp;ldquo;最后一个&amp;rdquo;指针相同，则表已用尽，无法找到要搜索的条目；&amp;lt;</target>
        </trans-unit>
        <trans-unit id="3aa34417c0be454f4995442d8a7806453694a874" translate="yes" xml:space="preserve">
          <source>If the new &amp;ldquo;first&amp;rdquo; and &amp;ldquo;last&amp;rdquo; pointers are different than the old &amp;ldquo;first&amp;rdquo; and &amp;ldquo;last&amp;rdquo; pointers, there&amp;rsquo;s more left to be searched, so return to step</source>
          <target state="translated">如果新的&amp;ldquo;第一个&amp;rdquo;和&amp;ldquo;最后一个&amp;rdquo;指针与旧的&amp;ldquo;第一个&amp;rdquo;和&amp;ldquo;最后一个&amp;rdquo;指针不同，则还有更多要搜索的内容，因此返回步骤</target>
        </trans-unit>
        <trans-unit id="e9ca8c9950d6818daad84f3ad32fa98a7278a457" translate="yes" xml:space="preserve">
          <source>If the new &amp;ldquo;first&amp;rdquo; and &amp;ldquo;last&amp;rdquo; pointers are the same as the old &amp;ldquo;first&amp;rdquo; and &amp;ldquo;last&amp;rdquo; pointers, the table has been exhausted and the entry being searched for cannot be found; &lt;var&gt;imperative-statement-1&lt;/var&gt; is executed, after which control falls through into the next statement following the &lt;code&gt;SEARCH ALL&lt;/code&gt;. If there is no &lt;code&gt;AT END&lt;/code&gt; clause coded, control simply falls into the next statement following the &lt;code&gt;SEARCH ALL&lt;/code&gt;.</source>
          <target state="translated">如果新的&amp;ldquo;第一个&amp;rdquo;和&amp;ldquo;最后一个&amp;rdquo;指针与旧的&amp;ldquo;第一个&amp;rdquo;和&amp;ldquo;最后一个&amp;rdquo;指针相同，则表已用尽，无法找到要搜索的条目； &lt;var&gt;imperative-statement-1&lt;/var&gt; ，然后控制权落到 &lt;code&gt;SEARCH ALL&lt;/code&gt; 之后的下一条语句中。如果没有编码的 &lt;code&gt;AT END&lt;/code&gt; 子句，则控制权将落在 &lt;code&gt;SEARCH ALL&lt;/code&gt; 之后的下一条语句中。</target>
        </trans-unit>
        <trans-unit id="37e0698c4d0426b5a1539d9872daa55a48e4b3fd" translate="yes" xml:space="preserve">
          <source>If the optional  &lt;code&gt;ALL&lt;/code&gt; clause is used, it may only be used with an alphanumeric literal value; the value will be repeated as needed to completely fill the data item. Here are some examples with and without &lt;code&gt;ALL&lt;/code&gt; (the symbol</source>
          <target state="translated">如果使用了可选的 &lt;code&gt;ALL&lt;/code&gt; 子句，则该子句只能与字母数字文字值一起使用；该值将根据需要重复以完全填充数据项。这是一些带有和不带有 &lt;code&gt;ALL&lt;/code&gt; （符号</target>
        </trans-unit>
        <trans-unit id="eb9269c6626b9c22244a99ff3bcdeb28d197891f" translate="yes" xml:space="preserve">
          <source>If the optional  &lt;code&gt;WITH FILLER&lt;/code&gt; clause is included on the &lt;code&gt;INITIALIZE&lt;/code&gt; statement, then every FILLER elementary item subordinate to each &lt;var&gt;identifier-1&lt;/var&gt; will be included as well, provided that elementary item neither contains a &lt;code&gt;REDEFINES&lt;/code&gt; clause in its definition nor belongs to a group item</source>
          <target state="translated">如果 &lt;code&gt;INITIALIZE&lt;/code&gt; 语句中包含可选的 &lt;code&gt;WITH FILLER&lt;/code&gt; 子句，则也将包括从属于每个 &lt;var&gt;identifier-1&lt;/var&gt; 的每个FILLER基本项目，前提是该基本项目在其定义中既不包含 &lt;code&gt;REDEFINES&lt;/code&gt; 子句，也不属于组项目</target>
        </trans-unit>
        <trans-unit id="305f0831253ff348ae38af25eb67e6760bc88db7" translate="yes" xml:space="preserve">
          <source>If the optional &lt;code&gt;ELSE&lt;/code&gt; clause is present and conditional-expression evaluates to false, then (and only then) &lt;var&gt;imperative-statement-2&lt;/var&gt; will be executed. Once &lt;var&gt;imperative-statement-2&lt;/var&gt; has been executed, control falls into the first statement following the &lt;code&gt;END-IF&lt;/code&gt; or to the first statement of the next sentence if there is no &lt;code&gt;END-IF&lt;/code&gt; clause.</source>
          <target state="translated">如果存在可选的 &lt;code&gt;ELSE&lt;/code&gt; 子句，并且conditional-expression的计算结果为false，则（并且仅在此之后）将执行 &lt;var&gt;imperative-statement-2&lt;/var&gt; 。一旦执行了 &lt;var&gt;imperative-statement-2&lt;/var&gt; ，如果没有 &lt;code&gt;END-IF&lt;/code&gt; 子句，控制权将落在 &lt;code&gt;END-IF&lt;/code&gt; 之后的第一条语句中或下一个句子的第一条语句中。</target>
        </trans-unit>
        <trans-unit id="99b9a44588304e8fd897153b6442bc44498ed178" translate="yes" xml:space="preserve">
          <source>If the optional&lt;code&gt;ALL&lt;/code&gt;</source>
          <target state="translated">如果可选 &lt;code&gt;ALL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7bdbfa412dd855282c99935345311e80faa35ff" translate="yes" xml:space="preserve">
          <source>If the optional&lt;code&gt;ELSE&lt;/code&gt;clause is present and conditional-expression evaluates to false, then (and only then) &amp;lt;</source>
          <target state="translated">如果存在可选的 &lt;code&gt;ELSE&lt;/code&gt; 子句，并且条件表达式的计算结果为false，则（并且仅此）&amp;lt;</target>
        </trans-unit>
        <trans-unit id="214f8446472e76c131789cea52e9df99ff6d7324" translate="yes" xml:space="preserve">
          <source>If the optional&lt;code&gt;WITH FILLER&lt;/code&gt;</source>
          <target state="translated">如果可选的 &lt;code&gt;WITH FILLER&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f4352556df8eac0b7e634194c0f18b8190333b57" translate="yes" xml:space="preserve">
          <source>If the program is compiled with the</source>
          <target state="translated">如果程序是用</target>
        </trans-unit>
        <trans-unit id="0e0c98a1a847d99310eeb35f540d53fc5e523af7" translate="yes" xml:space="preserve">
          <source>If the program is compiled with the&lt;code&gt;-fsyntax-extension&lt;/code&gt;switch</source>
          <target state="translated">如果程序是使用 &lt;code&gt;-fsyntax-extension&lt;/code&gt; 开关编译的</target>
        </trans-unit>
        <trans-unit id="28811669593d85ac3f545d78f92b27c993663314" translate="yes" xml:space="preserve">
          <source>If the replacement string is a multiple-item phrase or is to be deleted altogether, you must use the &lt;code&gt;==&lt;var&gt;pseudo-text-2&lt;/var&gt;==&lt;/code&gt; option. If &lt;code&gt;&lt;var&gt;pseudo-text-2&lt;/var&gt;&lt;/code&gt; is null (in other words, the replacement text is specified as &lt;code&gt;====&lt;/code&gt;), all encountered occurrences of the search string will be deleted.</source>
          <target state="translated">如果替换字符串是一个多项目短语或将要完全删除，则必须使用 &lt;code&gt;==&lt;var&gt;pseudo-text-2&lt;/var&gt;==&lt;/code&gt; 选项。如果 &lt;code&gt;&lt;var&gt;pseudo-text-2&lt;/var&gt;&lt;/code&gt; 为null（换句话说，将替换文本指定为 &lt;code&gt;====&lt;/code&gt; ），则将删除所有遇到的搜索字符串。</target>
        </trans-unit>
        <trans-unit id="3f250bad0b5b4ae9aea9503229c333bf1801f01f" translate="yes" xml:space="preserve">
          <source>If the replacement string is a multiple-item phrase or is to be deleted altogether, you must use the&lt;code&gt;==&amp;lt;&lt;i&gt;pseudo-text-2&lt;/i&gt;&amp;gt;==&lt;/code&gt;option. If&lt;code&gt;&amp;lt;&lt;i&gt;pseudo-text-2&lt;/i&gt;&amp;gt;&lt;/code&gt;is null (in other words, the replacement text is specified as&lt;code&gt;====&lt;/code&gt;, all encountered occurrences of the search string will be deleted.</source>
          <target state="translated">如果替换字符串是一个多项目短语或将要完全删除，则必须使用 &lt;code&gt;==&amp;lt;&lt;i&gt;pseudo-text-2&lt;/i&gt;&amp;gt;==&lt;/code&gt; 选项。如果 &lt;code&gt;&amp;lt;&lt;i&gt;pseudo-text-2&lt;/i&gt;&amp;gt;&lt;/code&gt; 为空（换言之，将替换文本指定为 &lt;code&gt;====&lt;/code&gt; ，则将删除所有遇到的搜索字符串。</target>
        </trans-unit>
        <trans-unit id="f5f6ed5272b3e9c841cbdbf96eb7afe75d6967c2" translate="yes" xml:space="preserve">
          <source>If the routine is successful, a value of 0 will be returned to the   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;). If the routine failed because of a problem with an argument (such as a negative or 0 length), a value of 128 will result. Finally, if the 1&lt;sup&gt;st&lt;/sup&gt; argument value is anything but zero, the routine will fail with a 129 value.</source>
          <target state="translated">如果例程成功，则将0值返回到 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器（请参见&lt;a href=&quot;#Special-Registers&quot;&gt;特殊寄存器&lt;/a&gt;）。如果例程由于参数问题（例如负数或0长度）而失败，则结果将为128。最后，如果1&lt;sup&gt;日&lt;/sup&gt;参数值是什么，但为零，程序将失败，129的值。</target>
        </trans-unit>
        <trans-unit id="b864101b1cf94817be38b70b043aacccfa75cd6e" translate="yes" xml:space="preserve">
          <source>If the routine is successful, a value of 0 will be returned to the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;). If the routine failed because of a problem with an argument (such as a negative or 0 length), a value of 128 will result. Finally, if the 1st argument value is anything but zero, the routine will fail with a 129 value.</source>
          <target state="translated">如果例程成功，则将值0返回到 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器（请参见&lt;a href=&quot;#Special-Registers&quot;&gt;特殊寄存器&lt;/a&gt;）。如果例程由于参数问题（例如负数或0长度）而失败，则结果为128。最后，如果第一个参数值不为零，则例程将失败并返回129值。</target>
        </trans-unit>
        <trans-unit id="5a1b44b26b84f05f8af22b9e038aef3fc238f233" translate="yes" xml:space="preserve">
          <source>If the search index now has a value greater than the number of entries in the table, the search is considered to have failed and the &amp;lt;</source>
          <target state="translated">如果现在搜索索引的值大于表中的条目数，则认为搜索失败，并且&amp;lt;</target>
        </trans-unit>
        <trans-unit id="da9683de4eb44741b248beaf10f0ef79a0a17667" translate="yes" xml:space="preserve">
          <source>If the search index now has a value greater than the number of entries in the table, the search is considered to have failed and the &lt;var&gt;imperative-statement-1&lt;/var&gt; on the optional  &lt;code&gt;AT END&lt;/code&gt; clause, if any, will be executed. After that, control will fall into the first executable statement following the &lt;code&gt;SEARCH&lt;/code&gt;.</source>
          <target state="translated">如果现在搜索索引的值大于表中条目的数量，则认为搜索失败，并且将执行可选 &lt;code&gt;AT END&lt;/code&gt; 子句中的 &lt;var&gt;imperative-statement-1&lt;/var&gt; （如果有）。之后，控制将落在 &lt;code&gt;SEARCH&lt;/code&gt; 之后的第一个可执行语句中。</target>
        </trans-unit>
        <trans-unit id="94565d23be2bb0fc7d85c959aef69eff52cd9069" translate="yes" xml:space="preserve">
          <source>If the search index now has a value less than or equal to the number of entries in the table, search processing returns back to step (A).</source>
          <target state="translated">如果现在搜索索引的值小于或等于表中的条目数,则搜索处理返回到步骤(A)。</target>
        </trans-unit>
        <trans-unit id="05d2db096b087a315ef5bec8efc903576ddb9453" translate="yes" xml:space="preserve">
          <source>If the search index now has a value less than or equal to the number of entries in the table, search processing returns back to step A.</source>
          <target state="translated">如果现在搜索索引的值小于或等于表中的条目数,则搜索处理返回到步骤A。</target>
        </trans-unit>
        <trans-unit id="63b646dd35f2ad5b466ac70be0367ce3e11e5b92" translate="yes" xml:space="preserve">
          <source>If the specified argument does not exist, or an invalid argument number is specified, a value of 0 is returned.</source>
          <target state="translated">如果指定的参数不存在,或者指定了无效的参数号,则返回0值。</target>
        </trans-unit>
        <trans-unit id="226dbbe68839151abdc383473011282ae0f610cd" translate="yes" xml:space="preserve">
          <source>If the specified condition-name has a value of FALSE when a &lt;code&gt;GENERATE&lt;/code&gt; statement (see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) causes a report group to be presented, the presentation of that group will be suppressed.</source>
          <target state="translated">如果在 &lt;code&gt;GENERATE&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;）使要显示的报告组时指定的条件名称的值为FALSE ，则该组的显示将被禁止。</target>
        </trans-unit>
        <trans-unit id="a1c8f712007564d99604775da06766bbac9f03bb" translate="yes" xml:space="preserve">
          <source>If the specified condition-name has a value of FALSE when a&lt;code&gt;GENERATE&lt;/code&gt;statement (see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) causes a report group to be presented, the presentation of that group will be suppressed.</source>
          <target state="translated">如果当 &lt;code&gt;GENERATE&lt;/code&gt; 语句（请参见&lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;）使要显示的报告组时指定的条件名称的值为FALSE ，则该组的显示将被禁止。</target>
        </trans-unit>
        <trans-unit id="66774ceedbe10981e42302c55639170b0ed0f28a" translate="yes" xml:space="preserve">
          <source>If the structure contains the following grid of characters:</source>
          <target state="translated">如果该结构包含以下字符网格:</target>
        </trans-unit>
        <trans-unit id="2e19606b520468997579db75010657ce092d9a6b" translate="yes" xml:space="preserve">
          <source>If the subprogram being called is a GnuCOBOL program, and if that program had the &lt;code&gt;INITIAL&lt;/code&gt; (see &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt;) attribute specified on its &lt;code&gt;PROGRAM-ID&lt;/code&gt; clause, all of the subprogram&amp;rsquo;s data division data will be restored to its initial state each time the subprogram is executed, regardless of which entry-point within the subprogram is being referenced.</source>
          <target state="translated">如果被调用的子程序是GnuCOBOL程序，并且该程序具有在其 &lt;code&gt;PROGRAM-ID&lt;/code&gt; 子句中指定的 &lt;code&gt;INITIAL&lt;/code&gt; （请参阅&lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt;）属性，则每次子程序被执行时，所有子程序的数据划分数据都将恢复为其初始状态。无论引用了子程序中的哪个入口点，都将执行该命令。</target>
        </trans-unit>
        <trans-unit id="5be0ca5096c1af0f623320b98f1b64f052b51144" translate="yes" xml:space="preserve">
          <source>If the subprogram being called is a GnuCOBOL program, and if that program had the&lt;code&gt;INITIAL&lt;/code&gt;(see &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt;) attribute specified on its&lt;code&gt;PROGRAM-ID&lt;/code&gt;clause, all of the subprogram&amp;rsquo;s data division data will be restored to its initial state each time the subprogram is executed, regardless of which entry-point within the subprogram is being referenced.</source>
          <target state="translated">如果被调用的子程序是GnuCOBOL程序，并且该程序具有在其 &lt;code&gt;PROGRAM-ID&lt;/code&gt; 子句中指定的 &lt;code&gt;INITIAL&lt;/code&gt; （请参阅&lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt;）属性，则每次子程序被执行时，所有子程序的数据划分数据都将恢复为其初始状态。无论引用了子程序中的哪个入口点，都将执行。</target>
        </trans-unit>
        <trans-unit id="9dd526e1cd7c1977c8a7c4056a1348911b1c31d3" translate="yes" xml:space="preserve">
          <source>If the subprogram issues a &lt;code&gt;STOP&lt;/code&gt; statement (see &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;) with the &lt;code&gt;RUN&lt;/code&gt; option, program execution ceases and control returns to the operating system or whatever execution shell invoked the main program.</source>
          <target state="translated">如果子程序发出带有 &lt;code&gt;RUN&lt;/code&gt; 选项的 &lt;code&gt;STOP&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;），则程序将停止执行，并且控制权返回到操作系统或调用主程序的任何执行外壳程序。</target>
        </trans-unit>
        <trans-unit id="1ad68b7c421e5be7cfd3f061b145123e5b308674" translate="yes" xml:space="preserve">
          <source>If the subprogram issues a&lt;code&gt;STOP&lt;/code&gt;statement (see &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;) with the&lt;code&gt;RUN&lt;/code&gt;option, program execution ceases and control returns to the operating system or whatever execution shell invoked the main program.</source>
          <target state="translated">如果子程序发出带有 &lt;code&gt;RUN&lt;/code&gt; 选项的 &lt;code&gt;STOP&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;），则程序将停止执行，并且控制权返回到操作系统或调用主程序的任何执行外壳程序。</target>
        </trans-unit>
        <trans-unit id="4c7b6241365e4ec6dc288450226d6b64947002d1" translate="yes" xml:space="preserve">
          <source>If the subprogram returns a value, the data item in which the value is returned must also be defined in the subprogram&amp;rsquo;s linkage section, with a &lt;code&gt;USAGE&lt;/code&gt; (see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of &lt;code&gt;BINARY-LONG SIGNED&lt;/code&gt;, or its equivalent.</source>
          <target state="translated">如果子程序返回一个值，则还必须在子程序的链接部分中&lt;a href=&quot;#USAGE&quot;&gt;使用&lt;/a&gt; &lt;code&gt;BINARY-LONG SIGNED&lt;/code&gt; 的 &lt;code&gt;USAGE&lt;/code&gt; （请参阅USAGE）或其等效项定义返回值的数据项。</target>
        </trans-unit>
        <trans-unit id="3fddc95876d626c2ec7bbbe309cf154f2991a624" translate="yes" xml:space="preserve">
          <source>If the subprogram returns a value, the data item in which the value is returned must also be defined in the subprogram&amp;rsquo;s linkage section, with a&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of&lt;code&gt;BINARY-LONG SIGNED&lt;/code&gt; or it&amp;rsquo;s equivalent.</source>
          <target state="translated">如果子程序返回一个值，则还必须在子程序的链接部分中定义返回值的数据项，其 &lt;code&gt;USAGE&lt;/code&gt; （请参阅&lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;）为 &lt;code&gt;BINARY-LONG SIGNED&lt;/code&gt; 或等效。</target>
        </trans-unit>
        <trans-unit id="d18f5e6b28b4c653d9208ecaefc48bd300bc047a" translate="yes" xml:space="preserve">
          <source>If the subprogram wishes to return control back to the calling program, it will do so using either the &lt;code&gt;GOBACK&lt;/code&gt; statement (see &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;) or the &lt;code&gt;EXIT PROGRAM&lt;/code&gt; statement (see &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;). At this time:</source>
          <target state="translated">如果子程序希望将控制权返回给调用程序，它将使用 &lt;code&gt;GOBACK&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;）或 &lt;code&gt;EXIT PROGRAM&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;）来完成。此时：</target>
        </trans-unit>
        <trans-unit id="3977b529e0e7ac10b11afc507f2c9eb5bfc68f03" translate="yes" xml:space="preserve">
          <source>If the subprogram wishes to return control back to the calling program, it will do so using either the&lt;code&gt;GOBACK&lt;/code&gt;statement (see &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;) or the&lt;code&gt;EXIT PROGRAM&lt;/code&gt;statement (see &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;). At this time:</source>
          <target state="translated">如果子程序希望将控制权返回给调用程序，它将使用 &lt;code&gt;GOBACK&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;）或 &lt;code&gt;EXIT PROGRAM&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;）来完成。此时：</target>
        </trans-unit>
        <trans-unit id="b7d442294a11ad2647525adddd4f76ac113b07cb" translate="yes" xml:space="preserve">
          <source>If the subprograms procedure division header or &lt;code&gt;ENTRY&lt;/code&gt; statement included a  &lt;code&gt;RETURNING&lt;/code&gt;, the value of the data item found on that clause is moved to the   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;); this behaviour can be altered utilizing the &lt;code&gt;CALL-CONVENTION&lt;/code&gt; (see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) feature to leave &lt;code&gt;RETURN-CODE&lt;/code&gt; unchanged.</source>
          <target state="translated">如果子程序过程分区标头或 &lt;code&gt;ENTRY&lt;/code&gt; 语句包含 &lt;code&gt;RETURNING&lt;/code&gt; ，则在该子句中找到的数据项的值将移到 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器中（请参见&lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;）；可以使用 &lt;code&gt;CALL-CONVENTION&lt;/code&gt; （请参阅&lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;）功能更改此行为，以保持 &lt;code&gt;RETURN-CODE&lt;/code&gt; 不变。</target>
        </trans-unit>
        <trans-unit id="fb4435d664648be40b4a8cc4319cd6f4b4970f02" translate="yes" xml:space="preserve">
          <source>If the subprograms procedure division header or&lt;code&gt;ENTRY&lt;/code&gt;statement included a&lt;code&gt;RETURNING&lt;/code&gt; (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;); this behaviour can be altered utilizing the&lt;code&gt;CALL-CONVENTION&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) feature to leave&lt;code&gt;RETURN-CODE&lt;/code&gt;unchanged.</source>
          <target state="translated">如果子程序的过程分区标头或 &lt;code&gt;ENTRY&lt;/code&gt; 语句包含 &lt;code&gt;RETURNING&lt;/code&gt; （请参见&lt;a href=&quot;#Special-Registers&quot;&gt;特殊寄存器&lt;/a&gt;）；可以使用 &lt;code&gt;CALL-CONVENTION&lt;/code&gt; （请参阅&lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;）功能更改此行为，以保持 &lt;code&gt;RETURN-CODE&lt;/code&gt; 不变。</target>
        </trans-unit>
        <trans-unit id="c11c1280cd66204488ac2a1a06bc536f96275c7f" translate="yes" xml:space="preserve">
          <source>If the subroutine is successful, a value of 0 will be returned in the   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;). Failure to retrieve the needed statistics on the file will cause a   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register value of 35 to be passed back. Supplying less than two arguments will generate a 128   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register value.</source>
          <target state="translated">如果该子例程成功，则将在 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器中返回0值（请参见&lt;a href=&quot;#Special-Registers&quot;&gt;特殊寄存器&lt;/a&gt;）。无法检索文件上所需的统计信息将导致将 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器值35传回。提供少于两个参数将生成一个128 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器值。</target>
        </trans-unit>
        <trans-unit id="f09551bd08e29b51e6abf0aea5fe4a5e33e0c372" translate="yes" xml:space="preserve">
          <source>If the subroutine is successful, a value of 0 will be returned in the   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;). Failure will cause a   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register value of -1 to be passed back.</source>
          <target state="translated">如果该子例程成功，则将在 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器中返回0值（请参见&lt;a href=&quot;#Special-Registers&quot;&gt;特殊寄存器&lt;/a&gt;）。失败将导致将 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器值-1传回。</target>
        </trans-unit>
        <trans-unit id="4fca4d357c4da52ecdfe09ff7f3b59313032d58e" translate="yes" xml:space="preserve">
          <source>If the subroutine is successful, a value of 0 will be returned in the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;). Failure to retrieve the needed statistics on the file will cause a&lt;code&gt;RETURN-CODE&lt;/code&gt;special register value of 35 to be passed back. Supplying less than two arguments will generate a 128&lt;code&gt;RETURN-CODE&lt;/code&gt;special register value.</source>
          <target state="translated">如果该子例程成功，则将在 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器中返回 0值（请参见&lt;a href=&quot;#Special-Registers&quot;&gt;特殊寄存器&lt;/a&gt;）。无法检索文件上所需的统计信息将导致将 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器值35传回。提供少于两个参数将生成一个128 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器值。</target>
        </trans-unit>
        <trans-unit id="2e2d3e910dfeb525715cdc365898fd54399a43c4" translate="yes" xml:space="preserve">
          <source>If the subroutine is successful, a value of 0 will be returned in the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;). Failure will cause a&lt;code&gt;RETURN-CODE&lt;/code&gt;special register value of -1 to be passed back.</source>
          <target state="translated">如果该子例程成功，则将在 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器中返回 0值（请参见&lt;a href=&quot;#Special-Registers&quot;&gt;特殊寄存器&lt;/a&gt;）。失败将导致将 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器值-1传回。</target>
        </trans-unit>
        <trans-unit id="f698aa2435d6084a56df16270589b76ed6111e07" translate="yes" xml:space="preserve">
          <source>If the value being stored into the field is the same length as the receiving field, the presence or absence of the &lt;code&gt;JUSTIFIED RIGHT&lt;/code&gt; clause on that field&amp;rsquo;s description is irrelevant.</source>
          <target state="translated">如果存储在字段中的值与接收字段的长度相同，则该字段描述中是否存在 &lt;code&gt;JUSTIFIED RIGHT&lt;/code&gt; 子句是无关紧要的。</target>
        </trans-unit>
        <trans-unit id="d1bb984fa6207ca92b69374fdf44a4d8170a10b1" translate="yes" xml:space="preserve">
          <source>If the value being stored into the field is the same length as the receiving field, the presence or absence of the&lt;code&gt;JUSTIFIED RIGHT&lt;/code&gt;clause on that field&amp;rsquo;s description is irrelevant.</source>
          <target state="translated">如果存储在字段中的值与接收字段的长度相同，则该字段说明中是否存在 &lt;code&gt;JUSTIFIED RIGHT&lt;/code&gt; 子句是无关紧要的。</target>
        </trans-unit>
        <trans-unit id="e5b69bef404018740f53a3d7738badc9ff4e4531" translate="yes" xml:space="preserve">
          <source>If the value of &amp;lt;</source>
          <target state="translated">如果&amp;lt;</target>
        </trans-unit>
        <trans-unit id="bb8439f9510a756d8324157cc108db5bd22ad20d" translate="yes" xml:space="preserve">
          <source>If the value of &lt;var&gt;identifier-1&lt;/var&gt; has the value 1, control will be transferred to the 1&lt;sup&gt;st&lt;/sup&gt; specified procedure name. If the value is 2, control will transfer to the 2nd procedure name, and so on.</source>
          <target state="translated">如果值 &lt;var&gt;identifier-1&lt;/var&gt; 的值为1，控制将被传递到1 &lt;sup&gt;ST&lt;/sup&gt;指定的程序名。如果值为2，则控制权将转移到第二个过程名称，依此类推。</target>
        </trans-unit>
        <trans-unit id="b45314dff2682587d20ce286905a20dcf658ec33" translate="yes" xml:space="preserve">
          <source>If the value of &lt;var&gt;identifier-1&lt;/var&gt; is less than 1 or exceeds the total number of procedure names specified on the statement, control will simply fall through into the next statement following the &lt;code&gt;GO TO&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;var&gt;identifier-1&lt;/var&gt; 的值小于1或超过语句中指定的过程名称的总数，则控制将直接进入 &lt;code&gt;GO TO&lt;/code&gt; 之后的下一个语句。</target>
        </trans-unit>
        <trans-unit id="a8941ef78769624061ef92939b2c773736817ccd" translate="yes" xml:space="preserve">
          <source>If the value of the numeric value moved into the field is positive (0 or greater), a &quot;+&quot; character will be inserted. If the value is negative (less than 0), a &quot;-&quot; character is inserted.</source>
          <target state="translated">如果移动到字段中的数值为正值(0或更大),将插入一个 &quot;+&quot;字符,如果数值为负值(小于0),则插入一个&quot;-&quot;字符。如果数值为负值(小于0),则插入&quot;-&quot;字符。</target>
        </trans-unit>
        <trans-unit id="acd1e3bc19ece522be6fdfb971b0319b26484139" translate="yes" xml:space="preserve">
          <source>If the value of the numeric value moved into the field is positive (0 or greater), a &amp;lsquo;</source>
          <target state="translated">如果移入该字段的数值的值为正（0或更大），则'</target>
        </trans-unit>
        <trans-unit id="fa45922afd3a1788e3ef11576266d429b5817fba" translate="yes" xml:space="preserve">
          <source>If the value of the numeric value moved into the field is positive (0 or greater), a space will be inserted. If the value is negative (less than 0), a &quot;-&quot; character is inserted.</source>
          <target state="translated">如果移动到字段中的数值为正值(0或更大),则会插入一个空格;如果数值为负值(小于0),则会插入一个&quot;-&quot;字。如果数值为负值(小于0),则插入一个&quot;-&quot;字符。</target>
        </trans-unit>
        <trans-unit id="fef0c37a2cadff9632c6704e1cf9b5158cf0c3f9" translate="yes" xml:space="preserve">
          <source>If the value of the numeric value moved into the field is positive (0 or greater), a space will be inserted. If the value is negative (less than 0), a &amp;lsquo;</source>
          <target state="translated">如果移入该字段的数值的值为正（0或更大），则将插入一个空格。如果值是负数（小于0），则'</target>
        </trans-unit>
        <trans-unit id="48dd00b4185648ad98a04dd28fc9dd3c41fb5dc5" translate="yes" xml:space="preserve">
          <source>If the value specified for the &amp;lt;</source>
          <target state="translated">如果为&amp;lt;</target>
        </trans-unit>
        <trans-unit id="be2c15d4233159c72f68bc3cfec16dff9b82c54c" translate="yes" xml:space="preserve">
          <source>If the value specified for the &lt;var&gt;length&lt;/var&gt; argument is LESS THAN the actual length of &lt;var&gt;buffer&lt;/var&gt; argument, the current directory path will be left-justified and space filled within the first &lt;var&gt;length&lt;/var&gt; bytes of &lt;var&gt;buffer&lt;/var&gt; &amp;mdash; any bytes in &lt;var&gt;buffer&lt;/var&gt; after that point will be unchanged.</source>
          <target state="translated">如果为 &lt;var&gt;length&lt;/var&gt; 参数指定的值小于 &lt;var&gt;buffer&lt;/var&gt; 参数的实际长度，则当前目录路径将左对齐，并在 &lt;var&gt;buffer&lt;/var&gt; 的第一个 &lt;var&gt;length&lt;/var&gt; 字节内填充空格- &lt;var&gt;buffer&lt;/var&gt; 此后的任何字节都将保持不变。</target>
        </trans-unit>
        <trans-unit id="0831d72b5b85932627f6976dfb6259ade2e7b74e" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;-fintrinsics=WHEN-COMPILED&lt;/code&gt;switch or&lt;code&gt;-fintrinsics=ALL&lt;/code&gt;switch is specified to the compiler or the&lt;code&gt;REPOSITORY&lt;/code&gt;(see &lt;a href=&quot;#REPOSITORY&quot;&gt;REPOSITORY&lt;/a&gt;) paragraph specifies either&lt;code&gt;FUNCTION WHEN-COMPILED INTRINSIC&lt;/code&gt;or&lt;code&gt;FUNCTION ALL INTRINSIC&lt;/code&gt; then references to&lt;code&gt;WHEN-COMPILED&lt;/code&gt;(without a leading&lt;code&gt;FUNCTION&lt;/code&gt;keyword will always reference this intrinsic function and there will be no way to access the&lt;code&gt;WHEN-COMPILED&lt;/code&gt;special register.</source>
          <target state="translated">如果将 &lt;code&gt;-fintrinsics=WHEN-COMPILED&lt;/code&gt; 开关或 &lt;code&gt;-fintrinsics=ALL&lt;/code&gt; 开关指定给编译器，或者 &lt;code&gt;REPOSITORY&lt;/code&gt; （请参阅&lt;a href=&quot;#REPOSITORY&quot;&gt;REPOSITORY&lt;/a&gt;）段落指定 &lt;code&gt;FUNCTION WHEN-COMPILED INTRINSIC&lt;/code&gt; 或 &lt;code&gt;FUNCTION ALL INTRINSIC&lt;/code&gt; ,则引用 &lt;code&gt;WHEN-COMPILED&lt;/code&gt; （不带前导 &lt;code&gt;FUNCTION&lt;/code&gt; 关键字将始终引用此内在函数，并且将无法访问 &lt;code&gt;WHEN-COMPILED&lt;/code&gt; 特殊寄存器。</target>
        </trans-unit>
        <trans-unit id="3b420486302df3f6e207a4313dfd931a759d89b7" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;-ftrace&lt;/code&gt;switch</source>
          <target state="translated">如果 &lt;code&gt;-ftrace&lt;/code&gt; 开关</target>
        </trans-unit>
        <trans-unit id="3349b7269aaccc8bb1cc998766e4a46beb55bde2" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;ACCESS MODE&lt;/code&gt;of &amp;lt;</source>
          <target state="translated">如果 &lt;code&gt;ACCESS MODE&lt;/code&gt; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="2e5d9e90a43cf87c9978ea30182b2bcd04cc6c52" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;ADDRESS OF&lt;/code&gt;clause is absent after the&lt;code&gt;TO&lt;/code&gt; the contents of &amp;lt;</source>
          <target state="translated">如果在 &lt;code&gt;TO&lt;/code&gt; 之后缺少 &lt;code&gt;ADDRESS OF&lt;/code&gt; 子句，则&amp;lt;</target>
        </trans-unit>
        <trans-unit id="26199d3754ff366a5846d65d208ee2e6de9686ad" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;ALL&lt;/code&gt;keyword was specified on the&lt;code&gt;VALUE&lt;/code&gt;clause, all members of the field list with&lt;code&gt;VALUE&lt;/code&gt;clauses will qualify.</source>
          <target state="translated">如果在 &lt;code&gt;VALUE&lt;/code&gt; 子句上指定了 &lt;code&gt;ALL&lt;/code&gt; 关键字，则带有 &lt;code&gt;VALUE&lt;/code&gt; 子句的字段列表的所有成员将符合条件。</target>
        </trans-unit>
        <trans-unit id="df5d251bac8a9bff6db280d0993ff1dbfac8f41c" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;CONSTANT&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;CONSTANT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c81429e41c0cb12a035faac7aa149969b981744" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;CRT STATUS&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;CRT STATUS&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bdf79d6d2d1dddc9f4d79dc6b3151fcff14428de" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;FD&lt;/code&gt;of the file contains the&lt;code&gt;RECORD CONTAINS&lt;/code&gt;or&lt;code&gt;RECORD IS VARYING&lt;/code&gt;clause, and that clause allows the record size to vary, the size</source>
          <target state="translated">如果文件的 &lt;code&gt;FD&lt;/code&gt; 包含 &lt;code&gt;RECORD CONTAINS&lt;/code&gt; 或 &lt;code&gt;RECORD IS VARYING&lt;/code&gt; 子句，并且该子句允许记录大小变化，则该大小</target>
        </trans-unit>
        <trans-unit id="7cd7e97ca9d4f2995a04bb967f17ad631843750e" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;FD&lt;/code&gt;of the file contains the&lt;code&gt;RECORD CONTAINS&lt;/code&gt;or&lt;code&gt;RECORD IS VARYING&lt;/code&gt;clause, and that clause allows the record size to vary, the size of &amp;lt;</source>
          <target state="translated">如果文件的 &lt;code&gt;FD&lt;/code&gt; 包含 &lt;code&gt;RECORD CONTAINS&lt;/code&gt; 或 &lt;code&gt;RECORD IS VARYING&lt;/code&gt; 子句，并且该子句允许记录大小发生变化，则&amp;lt;</target>
        </trans-unit>
        <trans-unit id="8342745452a46e82129819210173c072a362af42" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;LINAGE&lt;/code&gt;(see &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File/Sort-Description&lt;/a&gt;) clause is</source>
          <target state="translated">如果 &lt;code&gt;LINAGE&lt;/code&gt; （请参阅&lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File / Sort-Description&lt;/a&gt;）子句是</target>
        </trans-unit>
        <trans-unit id="67faed20b65d381e0f35f57376ea02fccee28463" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;LOCK ON&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;LOCK ON&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a4cf245f7ab4d128cf1a215befd46fe8ca30464" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;LOCK ON&lt;/code&gt;clause</source>
          <target state="translated">如果 &lt;code&gt;LOCK ON&lt;/code&gt; 子句</target>
        </trans-unit>
        <trans-unit id="5348e096005262a0ab82c3168003e7e7371e7dae" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;PERFORM&lt;/code&gt;specifies or implies&lt;code&gt;WITH TEST BEFORE&lt;/code&gt; &amp;lt;</source>
          <target state="translated">如果 &lt;code&gt;PERFORM&lt;/code&gt; 指定或暗示 &lt;code&gt;WITH TEST BEFORE&lt;/code&gt; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="dd5a2104ff28017a6be9e284824ff9c6d67e6603" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;PROGRAM-ID&lt;/code&gt;(see &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt;) clause of the subprogram included the&lt;code&gt;INITIAL&lt;/code&gt;</source>
          <target state="translated">如果子程序的 &lt;code&gt;PROGRAM-ID&lt;/code&gt; （请参阅&lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt;）子句包含 &lt;code&gt;INITIAL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="68679aad3ae2e21817a3db3c1cd8a4c87162b63f" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;RD&lt;/code&gt;(see &lt;a href=&quot;#REPORT-SECTION&quot;&gt;REPORT SECTION&lt;/a&gt;) in which the report group containing a&lt;code&gt;NEXT GROUP&lt;/code&gt;clause does not contain a&lt;code&gt;PAGE LIMITS&lt;/code&gt;clause, only the&lt;code&gt;PLUS integer-1&lt;/code&gt;option may be specified.</source>
          <target state="translated">如果 &lt;code&gt;RD&lt;/code&gt; （请参见&lt;a href=&quot;#REPORT-SECTION&quot;&gt;REPORT SECTION&lt;/a&gt;）中包含 &lt;code&gt;NEXT GROUP&lt;/code&gt; 子句的报告组不包含 &lt;code&gt;PAGE LIMITS&lt;/code&gt; 子句，则只能指定 &lt;code&gt;PLUS integer-1&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="6326e274617c726298b0f2a259364a71ec08cb9a" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;REMAINDER&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;REMAINDER&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d46ae7e0403a69183623c2c0c30c04ac183c02a4" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;RESET&lt;/code&gt;option is coded,&lt;code&gt;FINAL&lt;/code&gt;or &amp;lt;</source>
          <target state="translated">如果对 &lt;code&gt;RESET&lt;/code&gt; 选项进行了编码，则 &lt;code&gt;FINAL&lt;/code&gt; 或&amp;lt;</target>
        </trans-unit>
        <trans-unit id="38a1fbfcc2ff5f0f55dba89a7b49d153d656d7e5" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;SELECT&lt;/code&gt;(see &lt;a href=&quot;#SELECT&quot;&gt;SELECT&lt;/a&gt;) statement or file&lt;code&gt;OPEN&lt;/code&gt;(see &lt;a href=&quot;#OPEN&quot;&gt;OPEN&lt;/a&gt;) specifies&lt;code&gt;SHARING WITH NO OTHER&lt;/code&gt; record locking will be disabled.</source>
          <target state="translated">如果 &lt;code&gt;SELECT&lt;/code&gt; （参见&lt;a href=&quot;#SELECT&quot;&gt;SELECT&lt;/a&gt;）语句或 &lt;code&gt;OPEN&lt;/code&gt; （参见&lt;a href=&quot;#OPEN&quot;&gt;OPEN&lt;/a&gt;）文件指定 &lt;code&gt;SHARING WITH NO OTHER&lt;/code&gt; ,则记录锁定将被禁用。</target>
        </trans-unit>
        <trans-unit id="4469b431cec5ac5fa31a45bf59859b62ee522aee" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;SELECT&lt;/code&gt;of a file is coded with a&lt;code&gt;FILE STATUS&lt;/code&gt;clause,&lt;code&gt;OPEN&lt;/code&gt;failures &amp;mdash; including those induced by sharing failures &amp;mdash; will be detectable by the program and a graceful recovery (or at least a graceful termination) will be possible. If no such clause was coded, however, a runtime message will be issued and the program will be terminated.</source>
          <target state="translated">如果使用 &lt;code&gt;FILE STATUS&lt;/code&gt; 子句对文件的 &lt;code&gt;SELECT&lt;/code&gt; 进行编码，则 &lt;code&gt;OPEN&lt;/code&gt; 故障（包括由共享故障引起的故障）将可由程序检测到，并且可以正常恢复（或至少正常终止）。但是，如果未对此类子句进行编码，则将发出运行时消息并终止程序。</target>
        </trans-unit>
        <trans-unit id="d43773d0d9856113d341b49d71c616d3ba81cd29" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;SEPARATE CHARACTER&lt;/code&gt;clause</source>
          <target state="translated">如果 &lt;code&gt;SEPARATE CHARACTER&lt;/code&gt; 子句</target>
        </trans-unit>
        <trans-unit id="cc7da6fe4678bd908df6708f4cd87c152a905cc1" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;SYNCRONIZED&lt;/code&gt;clause is coded on anything but a numeric data item with a&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) that specifies storage of data in a binary form, the&lt;code&gt;SYNCRONIZED&lt;/code&gt;clause will be ignored.</source>
          <target state="translated">如果将 &lt;code&gt;SYNCRONIZED&lt;/code&gt; 子句编码在除数字数据项之外的任何内容上，并且 &lt;code&gt;USAGE&lt;/code&gt; （请参阅&lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;）以二进制形式指定数据存储，则 &lt;code&gt;SYNCRONIZED&lt;/code&gt; 子句将被忽略。</target>
        </trans-unit>
        <trans-unit id="d78ec8f2b4dfe7f01a17864e7420734286b9c412" translate="yes" xml:space="preserve">
          <source>If there are fewer tokens than there are arguments, the excess arguments will be initialized as if the &lt;code&gt;INITIALIZE &lt;var&gt;identifier-1&lt;/var&gt;&lt;/code&gt; (see &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt;) statement were executed.</source>
          <target state="translated">如果令牌少于参数，则多余的参数将被初始化，就像执行 &lt;code&gt;INITIALIZE &lt;var&gt;identifier-1&lt;/var&gt;&lt;/code&gt; （请参阅&lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt;）语句一样。</target>
        </trans-unit>
        <trans-unit id="3d2f7b6539018dd97bf4f7ebf6332805f3b4ccf8" translate="yes" xml:space="preserve">
          <source>If there are fewer tokens than there are arguments, the excess arguments will be initialized as if the&lt;code&gt;INITIALIZE &amp;lt;&lt;i&gt;identifier-1&lt;/i&gt;&amp;gt;&lt;/code&gt;(see &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt;) statement were executed.</source>
          <target state="translated">如果令牌少于参数，则多余的参数将被初始化，就像执行 &lt;code&gt;INITIALIZE &amp;lt;&lt;i&gt;identifier-1&lt;/i&gt;&amp;gt;&lt;/code&gt; （请参阅&lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt;）语句一样。</target>
        </trans-unit>
        <trans-unit id="061529f2e81b4789d20b56f0ff94bb58b24306f6" translate="yes" xml:space="preserve">
          <source>If there are more tokens than there are arguments, the excess tokens will be discarded.</source>
          <target state="translated">如果代币数量多于论证数量,多余的代币将被丢弃。</target>
        </trans-unit>
        <trans-unit id="f2d936a65b86a2841ae9003e465d423ea6c6934c" translate="yes" xml:space="preserve">
          <source>If there are multiple cash registers in a particular department of a specific store, the data needs to be further sorted so that the cash registers are ordered in sequence of their register number.</source>
          <target state="translated">如果某个商店的某个部门有多台收银机,则需要进一步对数据进行排序,使收银机按收银机号的顺序排列。</target>
        </trans-unit>
        <trans-unit id="e59de2a27b6a35a90e0f8bc07988b0621533bd24" translate="yes" xml:space="preserve">
          <source>If there are multiple record descriptions present for a given &lt;code&gt;FD&lt;/code&gt; or &lt;code&gt;SD&lt;/code&gt;, the one with the longest length will define the size of the record buffer into which a &lt;code&gt;READ&lt;/code&gt; statement (see &lt;a href=&quot;#READ&quot;&gt;READ&lt;/a&gt;) or a &lt;code&gt;RETURN&lt;/code&gt; statement (see &lt;a href=&quot;#RETURN&quot;&gt;RETURN&lt;/a&gt;) will deliver data read from the file and from which a &lt;code&gt;WRITE&lt;/code&gt; statement (see &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;) or &lt;code&gt;RELEASE&lt;/code&gt; statement (see &lt;a href=&quot;#RELEASE&quot;&gt;RELEASE&lt;/a&gt;) statement will obtain the data to be written to the file.</source>
          <target state="translated">如果给定的 &lt;code&gt;FD&lt;/code&gt; 或 &lt;code&gt;SD&lt;/code&gt; 存在多个记录描述，则长度最长的描述将定义记录缓冲区的大小，其中 &lt;code&gt;READ&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#READ&quot;&gt;READ&lt;/a&gt;）或 &lt;code&gt;RETURN&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#RETURN&quot;&gt;RETURN&lt;/a&gt;）将传递从中读取的数据文件，然后 &lt;code&gt;WRITE&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;）或 &lt;code&gt;RELEASE&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#RELEASE&quot;&gt;RELEASE&lt;/a&gt;）语句将从文件中获取要写入的数据。</target>
        </trans-unit>
        <trans-unit id="3972fbb29cfb0307f762dc829ca3e5c79c5963a7" translate="yes" xml:space="preserve">
          <source>If there are multiple record descriptions present for a given&lt;code&gt;FD&lt;/code&gt;or&lt;code&gt;SD&lt;/code&gt; the one with the longest length will define the size of the record buffer into which a&lt;code&gt;READ&lt;/code&gt;statement (see &lt;a href=&quot;#READ&quot;&gt;READ&lt;/a&gt;) or a&lt;code&gt;RETURN&lt;/code&gt;statement (see &lt;a href=&quot;#RETURN&quot;&gt;RETURN&lt;/a&gt;) will deliver data read from the file and from which a&lt;code&gt;WRITE&lt;/code&gt;statement (see &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;) or&lt;code&gt;RELEASE&lt;/code&gt;statement (see &lt;a href=&quot;#RELEASE&quot;&gt;RELEASE&lt;/a&gt;) statement will obtain the data to be written to the file.</source>
          <target state="translated">如果给定的 &lt;code&gt;FD&lt;/code&gt; 或 &lt;code&gt;SD&lt;/code&gt; 有多个记录描述，则最长的长度将定义记录缓冲区的大小，其中 &lt;code&gt;READ&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#READ&quot;&gt;READ&lt;/a&gt;）或 &lt;code&gt;RETURN&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#RETURN&quot;&gt;RETURN&lt;/a&gt;）将传递从FD或SD读取的数据。文件，并且 &lt;code&gt;WRITE&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;）或 &lt;code&gt;RELEASE&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#RELEASE&quot;&gt;RELEASE&lt;/a&gt;）语句将从文件中获取要写入的数据。</target>
        </trans-unit>
        <trans-unit id="6af5fafade490255d4c9294e9ca6e0bf011fdff0" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;C-D&lt;/code&gt; data item, then are there &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; data items? If not, the &lt;code&gt;COMPUTE&lt;/code&gt; statement is in error. If there are, however, then code will be generated to subtract the value of &lt;code&gt;D&lt;/code&gt; from &lt;code&gt;C&lt;/code&gt; and add 1 to the result.</source>
          <target state="translated">如果没有 &lt;code&gt;C-D&lt;/code&gt; 数据项，那么是否有 &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt; 数据项？如果不是，则 &lt;code&gt;COMPUTE&lt;/code&gt; 语句错误。但是，如果存在，则将生成代码以从 &lt;code&gt;C&lt;/code&gt; 中减去 &lt;code&gt;D&lt;/code&gt; 的值并将结果加1。</target>
        </trans-unit>
        <trans-unit id="c8b3aecda840e3adb64a0514f90c687896399421" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;CONTROL&lt;/code&gt; clause, the report will contain no control breaks; this implies that there can be no &lt;code&gt;CONTROL HEADING&lt;/code&gt; or &lt;code&gt;CONTROL FOOTING&lt;/code&gt; report groups defined for this &lt;code&gt;RD&lt;/code&gt;.</source>
          <target state="translated">如果没有 &lt;code&gt;CONTROL&lt;/code&gt; 子句，则报告将不包含控制中断；这意味着不能为此 &lt;code&gt;RD&lt;/code&gt; 定义 &lt;code&gt;CONTROL HEADING&lt;/code&gt; 或 &lt;code&gt;CONTROL FOOTING&lt;/code&gt; 报告组。</target>
        </trans-unit>
        <trans-unit id="d762e7f62e886e48e2ba03dcf5bc48c95f682f84" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;INITIAL&lt;/code&gt; clause specified, the target range is the entire inspect subject.</source>
          <target state="translated">如果未指定 &lt;code&gt;INITIAL&lt;/code&gt; 子句，则目标范围是整个检查对象。</target>
        </trans-unit>
        <trans-unit id="16abcea8905ec59c88cbf72bfdd646aa20d52b18" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;RESET&lt;/code&gt; option coded, the sum counter will be reset back to zero after each time the control footing containing the &lt;code&gt;SUM&lt;/code&gt; clause is presented. This is the typical behaviour that would be expected.</source>
          <target state="translated">如果未编码任何 &lt;code&gt;RESET&lt;/code&gt; 选项，则每次出现包含 &lt;code&gt;SUM&lt;/code&gt; 子句的控制基础时，总和计数器将重置为零。这是预期的典型行为。</target>
        </trans-unit>
        <trans-unit id="41ec3f30640928a7442c69732eddf2379b4afaed" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;UPON&lt;/code&gt; clause specified, the value of &lt;var&gt;identifier-7&lt;/var&gt; or &lt;var&gt;literal-2&lt;/var&gt; will be added into the sum counter whenever a &lt;code&gt;GENERATE&lt;/code&gt; (see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) of any detail report group in the report is executed.</source>
          <target state="translated">如果未指定 &lt;code&gt;UPON&lt;/code&gt; 子句，则在执行报告中任何详细报告组的 &lt;code&gt;GENERATE&lt;/code&gt; （请参阅&lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;）时，都会将 &lt;var&gt;identifier-7&lt;/var&gt; 或 &lt;var&gt;literal-2&lt;/var&gt; 值添加到总和计数器中。</target>
        </trans-unit>
        <trans-unit id="d3312782c3bd864e73fc604ba5b82a1e503c0463" translate="yes" xml:space="preserve">
          <source>If there is no picture clause and the &lt;code&gt;ALL&lt;/code&gt; option is specified, the &lt;code&gt;ALL&lt;/code&gt; option will be ignored.</source>
          <target state="translated">如果没有图片子句和 &lt;code&gt;ALL&lt;/code&gt; 指定选项， &lt;code&gt;ALL&lt;/code&gt; 选项都将被忽略。</target>
        </trans-unit>
        <trans-unit id="75eb31de9a88419e99f8f2249dfa222651219fe7" translate="yes" xml:space="preserve">
          <source>If there is no picture clause and the&lt;code&gt;ALL&lt;/code&gt;option is specified, the&lt;code&gt;ALL&lt;/code&gt;option will be ignored.</source>
          <target state="translated">如果没有图片子句和 &lt;code&gt;ALL&lt;/code&gt; 指定选项， &lt;code&gt;ALL&lt;/code&gt; 选项都将被忽略。</target>
        </trans-unit>
        <trans-unit id="0c755b4b694e7c4beb9b1c5901a6f3a6e90065fa" translate="yes" xml:space="preserve">
          <source>If there is no picture clause specified, the size of the screen data item will be the length of the &amp;lt;</source>
          <target state="translated">如果未指定picture子句，则屏幕数据项的大小将为&amp;lt;</target>
        </trans-unit>
        <trans-unit id="65e6d23a23213a7521f378d2234f516bcfe5dc63" translate="yes" xml:space="preserve">
          <source>If there is no picture clause specified, the size of the screen data item will be the length of the &lt;var&gt;literal-1&lt;/var&gt; value.</source>
          <target state="translated">如果未指定picture子句，则屏幕数据项的大小将为 &lt;var&gt;literal-1&lt;/var&gt; 值的长度。</target>
        </trans-unit>
        <trans-unit id="be6e32115bff0c291e8d3c6d6525390722099349" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;C-D&lt;/code&gt;data item, then are there&lt;code&gt;C&lt;/code&gt;and&lt;code&gt;D&lt;/code&gt;data items? If not, the&lt;code&gt;COMPUTE&lt;/code&gt;statement is in error. If there are, however, then code will be generated to subtract the value of&lt;code&gt;D&lt;/code&gt;from&lt;code&gt;C&lt;/code&gt;and add 1 to the result.</source>
          <target state="translated">如果没有 &lt;code&gt;C-D&lt;/code&gt; 数据项，那么是否有 &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt; 数据项？如果不是，则 &lt;code&gt;COMPUTE&lt;/code&gt; 语句错误。如果存在，则将生成代码以从 &lt;code&gt;C&lt;/code&gt; 中减去 &lt;code&gt;D&lt;/code&gt; 的值并将结果加1。</target>
        </trans-unit>
        <trans-unit id="6dbb73155f0ea4fd82ba811977b3d699fc88a4ae" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;CONTROL&lt;/code&gt;clause, the report will contain no control breaks; this implies that there can be no&lt;code&gt;CONTROL HEADING&lt;/code&gt;or&lt;code&gt;CONTROL FOOTING&lt;/code&gt;report groups defined for this&lt;code&gt;RD&lt;/code&gt;</source>
          <target state="translated">如果没有 &lt;code&gt;CONTROL&lt;/code&gt; 子句，则报告将不包含控制中断；这意味着不能为此 &lt;code&gt;RD&lt;/code&gt; 定义 &lt;code&gt;CONTROL HEADING&lt;/code&gt; 或 &lt;code&gt;CONTROL FOOTING&lt;/code&gt; 报告组</target>
        </trans-unit>
        <trans-unit id="a351d89c95027f7701058bc9f942df00ed507cdc" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;INITIAL&lt;/code&gt;clause specified, the target range is the entire inspect subject.</source>
          <target state="translated">如果未指定 &lt;code&gt;INITIAL&lt;/code&gt; 子句，则目标范围是整个检查对象。</target>
        </trans-unit>
        <trans-unit id="f81540f4079ee51c4206d96a7efc736809a22ed7" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;RESET&lt;/code&gt;option coded, the sum counter will be reset back to zero after each time the control footing containing the&lt;code&gt;SUM&lt;/code&gt;clause is presented. This is the typical behaviour that would be expected.</source>
          <target state="translated">如果未编码任何 &lt;code&gt;RESET&lt;/code&gt; 选项，则每次出现包含 &lt;code&gt;SUM&lt;/code&gt; 子句的控制基础时，总和计数器将重置为零。这是预期的典型行为。</target>
        </trans-unit>
        <trans-unit id="d5e252dc91e0d99f464bda7bc7cffd6140f7edd1" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;UPON&lt;/code&gt;clause specified, the value of &amp;lt;</source>
          <target state="translated">如果未指定 &lt;code&gt;UPON&lt;/code&gt; 子句，则&amp;lt;</target>
        </trans-unit>
        <trans-unit id="85ed95cffb116ddc0e04b0ff9f3f85cb3f686c72" translate="yes" xml:space="preserve">
          <source>If there is only a single detail group in the report&amp;rsquo;s definition, the &lt;code&gt;UPON&lt;/code&gt; clause is meaningless.</source>
          <target state="translated">如果报告的定义中只有一个详细信息组，则 &lt;code&gt;UPON&lt;/code&gt; 子句是没有意义的。</target>
        </trans-unit>
        <trans-unit id="3241679c69995dc4a256fad0940c95e8635b9f3e" translate="yes" xml:space="preserve">
          <source>If there is only a single detail group in the report&amp;rsquo;s definition, the&lt;code&gt;UPON&lt;/code&gt;clause is meaningless.</source>
          <target state="translated">如果报告的定义中只有一个详细信息组，则 &lt;code&gt;UPON&lt;/code&gt; 子句将毫无意义。</target>
        </trans-unit>
        <trans-unit id="8336291c2ee7aa90b14f47a5ffa73da4f4ccca8c" translate="yes" xml:space="preserve">
          <source>If this format of the &lt;code&gt;GO TO&lt;/code&gt; statement appears in a consecutive sequence of imperative statements (see &lt;a href=&quot;#Imperative-Statement&quot;&gt;Imperative Statement&lt;/a&gt;) within a sentence, it must be the</source>
          <target state="translated">如果 &lt;code&gt;GO TO&lt;/code&gt; 语句的这种格式出现在句子中的命令式语句的连续序列中（请参见&lt;a href=&quot;#Imperative-Statement&quot;&gt;命令式语句&lt;/a&gt;），则它必须是</target>
        </trans-unit>
        <trans-unit id="c11b35162c1c669848bde8fb8b4adb40363c054b" translate="yes" xml:space="preserve">
          <source>If this format of the&lt;code&gt;GO TO&lt;/code&gt;statement appears in a consecutive sequence of imperative statements (see &lt;a href=&quot;#Imperative-Statement&quot;&gt;Imperative Statement&lt;/a&gt;) within a sentence, it must be the</source>
          <target state="translated">如果 &lt;code&gt;GO TO&lt;/code&gt; 语句的这种格式出现在句子中的命令式语句的连续序列中（请参见&lt;a href=&quot;#Imperative-Statement&quot;&gt;命令式语句&lt;/a&gt;），则它必须是</target>
        </trans-unit>
        <trans-unit id="87568d2d981805ff51bcc79d09c4d6bfd7b2a8ef" translate="yes" xml:space="preserve">
          <source>If this is NOT set to a value, all&lt;code&gt;-ftrace&lt;/code&gt;switch and&lt;code&gt;-ftraceall&lt;/code&gt;switch output will be written to STDERR, where it may be piped via a &quot;2&amp;gt; filename&quot; on the command that executes the program.</source>
          <target state="translated">如果未将其设置为值，则所有 &lt;code&gt;-ftrace&lt;/code&gt; 开关和 &lt;code&gt;-ftraceall&lt;/code&gt; 开关的输出都将写入STDERR，在此处可以通过执行程序的命令上的&amp;ldquo; 2&amp;gt;文件名&amp;rdquo;将其输出。</target>
        </trans-unit>
        <trans-unit id="a83736211ab7a8ebcd841864f94ccc4520a7dfa7" translate="yes" xml:space="preserve">
          <source>If this is needed then the use of &lt;code&gt;CONCATENATE&lt;/code&gt; to built more than one element together prior to the display,</source>
          <target state="translated">如果需 &lt;code&gt;CONCATENATE&lt;/code&gt; ，则在显示之前使用CONCATENATE一起构建多个元素，</target>
        </trans-unit>
        <trans-unit id="a889b90fb05948e48163ce89cde9903008828bde" translate="yes" xml:space="preserve">
          <source>If this is not defined under *nix it will default to</source>
          <target state="translated">如果这在*nix下没有定义,它将默认为</target>
        </trans-unit>
        <trans-unit id="e41eac2db71cda7170c71b8ec2c30d7834407d0c" translate="yes" xml:space="preserve">
          <source>If this is not defined under *nix it will default to /usr/local/share/gnucobol/config.</source>
          <target state="translated">如果在*nix下没有定义,它将默认为/usr/local/share/gnucobol/config。</target>
        </trans-unit>
        <trans-unit id="f658454bbe0cb00adbd321dd682ed210523825d2" translate="yes" xml:space="preserve">
          <source>If this references the &lt;code&gt;LOCALE&lt;/code&gt; :</source>
          <target state="translated">如果这引用了 &lt;code&gt;LOCALE&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="13a780ab73e0d98067b8082c96e09315273c7654" translate="yes" xml:space="preserve">
          <source>If used with &lt;code&gt;PIC X&lt;/code&gt;, allocates one byte of storage per &amp;lsquo;</source>
          <target state="translated">如果与 &lt;code&gt;PIC X&lt;/code&gt; 一起使用，则每个'分配一个字节的存储空间。</target>
        </trans-unit>
        <trans-unit id="023cf0ecfd0afc5f6ae392348d069495edac90d8" translate="yes" xml:space="preserve">
          <source>If used with&lt;code&gt;PIC X&lt;/code&gt; allocates one byte of storage per&lt;code&gt;X&lt;/code&gt; range of values is 0 to max storable in that many bytes. If used with&lt;code&gt;PIC 9&lt;/code&gt; range of values depends on number of&lt;code&gt;9&lt;/code&gt; in PICTURE</source>
          <target state="translated">如果与 &lt;code&gt;PIC X&lt;/code&gt; 一起使用，则每个 &lt;code&gt;X&lt;/code&gt; 的值范围为0到最大可存储字节数，分配一个字节的存储空间。如果与 &lt;code&gt;PIC 9&lt;/code&gt; 一起使用，则取值范围取决于PICTURE 中 &lt;code&gt;9&lt;/code&gt; 的数量</target>
        </trans-unit>
        <trans-unit id="5b48ea3221a5bd190b3da00947706eadb4325c47" translate="yes" xml:space="preserve">
          <source>If used, &amp;lt;</source>
          <target state="translated">如果使用，&amp;lt;</target>
        </trans-unit>
        <trans-unit id="b86b211a643f0894516daa2e4887ef0058458a13" translate="yes" xml:space="preserve">
          <source>If used, &lt;var&gt;expression-1&lt;/var&gt; must be an arithmetic expression with a non-zero positive integer value.</source>
          <target state="translated">如果使用 &lt;var&gt;expression-1&lt;/var&gt; 必须是具有非零正整数值的算术表达式。</target>
        </trans-unit>
        <trans-unit id="b8e42b7d06183584a3c82a1e30a497fb1500ac29" translate="yes" xml:space="preserve">
          <source>If used, &lt;var&gt;identifier-1&lt;/var&gt; should be an 01-level item defined in working-storage or local-storage with the &lt;code&gt;BASED&lt;/code&gt; (see &lt;a href=&quot;#BASED&quot;&gt;BASED&lt;/a&gt;) attribute. It may be an 01 item defined in the linkage section without the &lt;code&gt;BASED&lt;/code&gt; attribute, but using such a data item is not recommended.</source>
          <target state="translated">如果使用 &lt;var&gt;identifier-1&lt;/var&gt; 应该是在工作存储或本地存储中使用 &lt;code&gt;BASED&lt;/code&gt; （请参阅&lt;a href=&quot;#BASED&quot;&gt;BASED&lt;/a&gt;）属性定义的01级项目。它可能是链接部分中定义的01项，没有 &lt;code&gt;BASED&lt;/code&gt; 属性，但是不建议使用这种数据项。</target>
        </trans-unit>
        <trans-unit id="9bc0724035e374262548f9e5245c6c8b9be6bbaa" translate="yes" xml:space="preserve">
          <source>If used, &lt;var&gt;identifier-2&lt;/var&gt; should be a &lt;code&gt;POINTER&lt;/code&gt; (see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) data item.</source>
          <target state="translated">如果使用的话， &lt;var&gt;identifier-2&lt;/var&gt; 应该是一个 &lt;code&gt;POINTER&lt;/code&gt; （请参阅&lt;a href=&quot;#USAGE&quot;&gt;用法&lt;/a&gt;）数据项。</target>
        </trans-unit>
        <trans-unit id="71f1f5a847333c2f0a308baea3e7cd54b097d32f" translate="yes" xml:space="preserve">
          <source>If you already know a programming language other than COBOL, chances are that language is Java, C or C++. You will find COBOL much different from those; sometimes the differences are a good thing and sometimes they aren&amp;rsquo;t. The thing to remember about COBOL is this:</source>
          <target state="translated">如果您已经知道除COBOL之外的其他编程语言，则该语言很可能是Java，C或C ++。您会发现COBOL与那些有很大的不同。有时差异是一件好事，有时却不是。关于COBOL要记住的是：</target>
        </trans-unit>
        <trans-unit id="f92f6ebb3f39d6efd118da1f36149fda0df27506" translate="yes" xml:space="preserve">
          <source>If you are comfortable with the &quot;C&quot; programming language, you might find the following simple GnuCOBOL program useful in exploring the differences between subscripting and indexing:</source>
          <target state="translated">如果你对 &quot;C &quot;编程语言很熟悉,你可能会发现下面这个简单的GnuCOBOL程序对探索下标和索引之间的区别很有用。</target>
        </trans-unit>
        <trans-unit id="d72a55c3208d833e5593b857446fb0e285092f9f" translate="yes" xml:space="preserve">
          <source>If you are comfortable with the C programming language, you might find the following simple GnuCOBOL program useful in exploring the differences between subscripting and indexing:</source>
          <target state="translated">如果你对 C 语言编程很熟悉,你可能会发现下面这个简单的 GnuCOBOL 程序对探索下标和索引之间的区别很有用。</target>
        </trans-unit>
        <trans-unit id="66062304bf503c5649ee5c39992874bd53f8d855" translate="yes" xml:space="preserve">
          <source>If you are planning on using static-linked subroutine libraries, set this variable to the path of the directory containing your libraries.</source>
          <target state="translated">如果你打算使用静态链接的子程序库,请将这个变量设置为包含库的目录路径。</target>
        </trans-unit>
        <trans-unit id="01f92f2645932d2e7b72a1c8110cdcfbd8882f1a" translate="yes" xml:space="preserve">
          <source>If you are sorting &amp;lt;</source>
          <target state="translated">如果要排序&amp;lt;</target>
        </trans-unit>
        <trans-unit id="004cad48c1c7e5cd3697d0259ff8f530252b1f42" translate="yes" xml:space="preserve">
          <source>If you are sorting &lt;var&gt;table-name-1&lt;/var&gt; for the purpose of preparing the table for use with a &lt;code&gt;SEARCH ALL&lt;/code&gt; statement (see &lt;a href=&quot;#SEARCH-ALL&quot;&gt;SEARCH ALL&lt;/a&gt;), care must be taken that the &lt;code&gt;KEY&lt;/code&gt; specifications on the &lt;code&gt;SORT&lt;/code&gt; agree with those in the table&amp;rsquo;s definition.</source>
          <target state="translated">如果要对 &lt;var&gt;table-name-1&lt;/var&gt; 进行排序是为了准备将表与 &lt;code&gt;SEARCH ALL&lt;/code&gt; 语句一起使用（请参阅&lt;a href=&quot;#SEARCH-ALL&quot;&gt;SEARCH ALL&lt;/a&gt;），则必须注意 &lt;code&gt;SORT&lt;/code&gt; 上的 &lt;code&gt;KEY&lt;/code&gt; 规范与表定义中的KEY规范一致。</target>
        </trans-unit>
        <trans-unit id="02aa6a4a695c82943ebf8b43c9d16d82122de6f1" translate="yes" xml:space="preserve">
          <source>If you are using Fixed Format Mode, the alphanumeric literal can be run right up to and including column 72. The literal may then be continued on the next line anywhere after column 11 by coding another quote or apostrophe (whichever was used to begin the literal originally). The continuation line must also have a hyphen (-)</source>
          <target state="translated">如果您使用的是固定格式模式,字母数字文字可以一直运行到第72列。然后,在第11列之后的下一行,可以通过编码另一个引号或撇号(以最初用于开始字词的为准)来延续字词。延续行还必须有一个连字符(-)。</target>
        </trans-unit>
        <trans-unit id="c9f65d9b9ed555da4b63d4488fe138317d725d8d" translate="yes" xml:space="preserve">
          <source>If you attempt to store a negative number into a packed decimal field that has no &amp;lsquo;</source>
          <target state="translated">如果您尝试将负数存储到没有'</target>
        </trans-unit>
        <trans-unit id="67c575e7eebaede09fa7a3ba7a66b085e2b666ab" translate="yes" xml:space="preserve">
          <source>If you attempt to store a negative number into a packed decimal field that has no&lt;code&gt;S&lt;/code&gt;in its&lt;code&gt;PICTURE&lt;/code&gt; the absolute value of the negative number will actually be stored.</source>
          <target state="translated">如果试图为负数存储到一个没有压缩十进制场 &lt;code&gt;S&lt;/code&gt; 在其 &lt;code&gt;PICTURE&lt;/code&gt; 负数的绝对值实际上将被保存。</target>
        </trans-unit>
        <trans-unit id="33f09798c9350fe782168c79a484ebfce1dfd921" translate="yes" xml:space="preserve">
          <source>If you have used other versions of COBOL before (particularly mainframe implementations), you&amp;rsquo;ve possibly seen subroutine calls made passing a procedure name as an argument &amp;mdash; that is not possible in GnuCOBOL; instead, you need to know how to use this form of the&lt;code&gt;SET&lt;/code&gt;statement.</source>
          <target state="translated">如果您以前使用过其他版本的COBOL（尤其是大型机实现），则可能已经看到通过将过程名称作为参数来进行子例程调用-这在GnuCOBOL中是不可能的。相反，您需要知道如何使用这种形式的 &lt;code&gt;SET&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="3e0e21f3fa3e35e385e61b770f9f269497ad078b" translate="yes" xml:space="preserve">
          <source>If you like to hold a book in your hands, I strongly recommend</source>
          <target state="translated">如果你喜欢手捧一本书,我强烈建议你</target>
        </trans-unit>
        <trans-unit id="8575747ffb34e15317f4825a1a6d194e243908c5" translate="yes" xml:space="preserve">
          <source>If you like to hold a book in your hands, I strongly recommend &quot;Murach&amp;rsquo;s Structured COBOL&quot;, by Mike Murach, Anne Prince and Raul Menendez (2000) - ISBN 9781890774059. Mike Murach and his various writing partners have been writing outstanding COBOL textbooks for decades, and this text is no exception. It&amp;rsquo;s an excellent book for those familiar with the concepts of programming in other languages, but unfamiliar with COBOL.</source>
          <target state="translated">如果您想拿一本书，我强烈推荐Mike Murach，Anne Prince和Raul Menendez（2000）撰写的&amp;ldquo; Murach的结构化COBOL&amp;rdquo;-ISBN9781890774059。Mike Murach和他的各个写作伙伴一直在为几十年，本文也不例外。对于那些熟悉其他语言的编程概念但不熟悉COBOL的人来说，这是一本非常不错的书。</target>
        </trans-unit>
        <trans-unit id="a983cec50cc8adb2cb72101e62421b49b40c3f8f" translate="yes" xml:space="preserve">
          <source>If you need to allocate space for a data item whose format is two letters followed by five digits followed by three letters, you could use the &amp;lt;</source>
          <target state="translated">如果需要为格式为两个字母，五个数字和三个字母的数据项分配空间，则可以使用&amp;lt;</target>
        </trans-unit>
        <trans-unit id="8d26eb887b2bfd89c144e5b52c0cdeb9c7a63cdb" translate="yes" xml:space="preserve">
          <source>If you need to allocate space for a data item whose format is two letters followed by five digits followed by three letters, you could use the &lt;var&gt;picture-string&lt;/var&gt;&lt;code&gt;AA99999AAA&lt;/code&gt;, &lt;code&gt;A(2)9(5)A(3)&lt;/code&gt;&lt;code&gt;XXXXXXXXXX&lt;/code&gt; or &lt;code&gt;X(10)&lt;/code&gt;. There is absolutely no functional difference whatsoever between the four &amp;mdash; none of them provide any functionality the others do not. The first two probably make for better</source>
          <target state="translated">如果需要为格式为两个字母，五个数字和三个字母的数据项分配空间，则可以使用 &lt;var&gt;picture-string&lt;/var&gt; &lt;code&gt;AA99999AAA&lt;/code&gt; ， &lt;code&gt;A(2)9(5)A(3)&lt;/code&gt; &lt;code&gt;XXXXXXXXXX&lt;/code&gt; 或 &lt;code&gt;X(10)&lt;/code&gt; 。四个之间绝对没有功能上的区别-它们都没有提供其他没有的任何功能。前两个可能会变得更好</target>
        </trans-unit>
        <trans-unit id="85dc896ccc0af03eabd5023a9189c0f764205518" translate="yes" xml:space="preserve">
          <source>If you need to apply &lt;code&gt;REPLACING&lt;/code&gt; initialization to multiple &lt;var&gt;category-name-2&lt;/var&gt; values, you may repeat the syntax after the reserved word &lt;code&gt;REPLACING&lt;/code&gt;, as necessary.</source>
          <target state="translated">如果需要将 &lt;code&gt;REPLACING&lt;/code&gt; 初始化应用于多个 &lt;var&gt;category-name-2&lt;/var&gt; 值，则可以根据需要在保留字 &lt;code&gt;REPLACING&lt;/code&gt; 之后重复语法。</target>
        </trans-unit>
        <trans-unit id="6f07cc92bcdb1fb4966a29f8bc48cd7ec589d721" translate="yes" xml:space="preserve">
          <source>If you need to apply &lt;code&gt;VALUE&lt;/code&gt; initialization to multiple &lt;var&gt;category-name-1&lt;/var&gt; values, you will need to use multiple &lt;code&gt;INITIALIZE&lt;/code&gt; statements.</source>
          <target state="translated">如果需要将 &lt;code&gt;VALUE&lt;/code&gt; 初始化应用于多个 &lt;var&gt;category-name-1&lt;/var&gt; 值，则将需要使用多个 &lt;code&gt;INITIALIZE&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="3d7ab34ba2edb8344ca5cd05ed4f78d8ca295856" translate="yes" xml:space="preserve">
          <source>If you need to apply&lt;code&gt;REPLACING&lt;/code&gt;initialization to multiple &amp;lt;</source>
          <target state="translated">如果您需要将 &lt;code&gt;REPLACING&lt;/code&gt; 初始化应用于多个&amp;lt;</target>
        </trans-unit>
        <trans-unit id="0be77805ea73d60e3aa2532f09cd1417a0b5f725" translate="yes" xml:space="preserve">
          <source>If you need to apply&lt;code&gt;VALUE&lt;/code&gt;initialization to multiple &amp;lt;</source>
          <target state="translated">如果您需要将 &lt;code&gt;VALUE&lt;/code&gt; 初始化应用于多个&amp;lt;</target>
        </trans-unit>
        <trans-unit id="faedf40171740f5c51b093163f9803ad34a888e7" translate="yes" xml:space="preserve">
          <source>If you need to qualify a reference to a table, do so by coding something like &lt;code&gt;&lt;var&gt;identifier-1&lt;/var&gt; OF &lt;var&gt;identifier-2&lt;/var&gt; ( &lt;var&gt;subscript(s)&lt;/var&gt; )&lt;/code&gt;.</source>
          <target state="translated">如果你需要有资格的表引用，通过编码像这样做 &lt;code&gt;&lt;var&gt;identifier-1&lt;/var&gt; OF &lt;var&gt;identifier-2&lt;/var&gt; ( &lt;var&gt;subscript(s)&lt;/var&gt; )&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09b277bb04315e13de2ea2c1d6215f972f449420" translate="yes" xml:space="preserve">
          <source>If you need to qualify a reference to a table, do so by coding something like&lt;code&gt;&amp;lt;&lt;i&gt;identifier-1&lt;/i&gt;&amp;gt; OF &amp;lt;&lt;i&gt;identifier-2&lt;/i&gt;&amp;gt; ( subscript(s) )&lt;/code&gt;</source>
          <target state="translated">如果您需要限定对表的引用，可以通过对 &lt;code&gt;&amp;lt;&lt;i&gt;identifier-1&lt;/i&gt;&amp;gt; OF &amp;lt;&lt;i&gt;identifier-2&lt;/i&gt;&amp;gt; ( subscript(s) )&lt;/code&gt; &lt;i&gt;identifier-1&lt;/i&gt; &amp;gt; OF &amp;lt; &lt;i&gt;identifier-2&lt;/i&gt; &amp;gt;（下标）之类的代码进行编码&lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="ea477a1b93e894e00c5029bde5c4700835a658bc" translate="yes" xml:space="preserve">
          <source>If you only need to use the computed occurrence number once, you might as well just use the computed occurrence number data item as a subscript. If, however, you will need to use a computed &quot;subscript&quot; many more times than once, the run-time overhead of converting that occurrence value to an index (via&lt;code&gt;SET Index&lt;/code&gt; will be worth the coding effort.</source>
          <target state="translated">如果只需要使用一次计算的出现次数，则最好将计算的出现次数数据项用作下标。但是，如果您需要多次使用计算出的&amp;ldquo;下标&amp;rdquo;，那么将发生值转换为索引的运行时开销（通过 &lt;code&gt;SET Index&lt;/code&gt; )将值得进行编码。</target>
        </trans-unit>
        <trans-unit id="08d6331d8b515c4ddcea5626d36be26117cd2759" translate="yes" xml:space="preserve">
          <source>If you only need to use the computed occurrence number once, you might as well just use the computed occurrence number data item as a subscript. If, however, you will need to use a computed &amp;ldquo;subscript&amp;rdquo; many more times than once, the run-time overhead of converting that occurrence value to an index (via &lt;code&gt;SET Index&lt;/code&gt;) will be worth the coding effort.</source>
          <target state="translated">如果只需要使用一次计算的出现次数，则最好将计算的出现次数数据项用作下标。但是，如果您需要多次使用计算出的&amp;ldquo;下标&amp;rdquo;，那么将发生值转换为索引（通过 &lt;code&gt;SET Index&lt;/code&gt; ）的运行时开销值得进行编码。</target>
        </trans-unit>
        <trans-unit id="2b11929fcfd27ebcc5881e51e66067da91bf2b68" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;FINAL&lt;/code&gt;, it must be the first control break named in the &lt;code&gt;RD&lt;/code&gt;.</source>
          <target state="translated">如果指定 &lt;code&gt;FINAL&lt;/code&gt; ，则它必须是 &lt;code&gt;RD&lt;/code&gt; 中命名的第一个控制中断。</target>
        </trans-unit>
        <trans-unit id="c7ef595b63c0ad5f2b42b214045d49f212ec5149" translate="yes" xml:space="preserve">
          <source>If you specify a specific filename in the sort/merge work file&amp;rsquo;s &lt;code&gt;SELECT&lt;/code&gt;, it will be ignored.</source>
          <target state="translated">如果您在排序/合并工作文件的 &lt;code&gt;SELECT&lt;/code&gt; 中指定了特定的文件名，它将被忽略。</target>
        </trans-unit>
        <trans-unit id="1b1aec7f2d01b9337cb99ecf14cbd063323c6bfc" translate="yes" xml:space="preserve">
          <source>If you specify a specific filename in the sort/merge work file&amp;rsquo;s&lt;code&gt;SELECT&lt;/code&gt; it will be ignored.</source>
          <target state="translated">如果您在排序/合并工作文件的 &lt;code&gt;SELECT&lt;/code&gt; 中指定了特定的文件名，它将被忽略。</target>
        </trans-unit>
        <trans-unit id="db4b705d51633a3053f41836b85c013703781c0c" translate="yes" xml:space="preserve">
          <source>If you specify&lt;code&gt;FINAL&lt;/code&gt; it must be the first control break named in the&lt;code&gt;RD&lt;/code&gt;</source>
          <target state="translated">如果指定 &lt;code&gt;FINAL&lt;/code&gt; ,则它必须是 &lt;code&gt;RD&lt;/code&gt; 中命名的第一个控制中断</target>
        </trans-unit>
        <trans-unit id="ff6d082d36226e2e4f40a2e7e8119f64d1550bdf" translate="yes" xml:space="preserve">
          <source>If you want to squeeze every last bit of performance out of your GnuCOBOL programs, don&amp;rsquo;t forget to investigate the</source>
          <target state="translated">如果您想从GnuCOBOL程序中挤出所有最后的性能，别忘了调查一下</target>
        </trans-unit>
        <trans-unit id="bd75b97fc760ccc29226f53558113a860ab9c393" translate="yes" xml:space="preserve">
          <source>If you want to squeeze every last bit of performance out of your GnuCOBOL programs, don&amp;rsquo;t forget to investigate the&lt;code&gt;-O&lt;/code&gt;switch</source>
          <target state="translated">如果您想从GnuCOBOL程序中挤出所有最后的性能，别忘了研究 &lt;code&gt;-O&lt;/code&gt; 开关</target>
        </trans-unit>
        <trans-unit id="1395a21f9c2355a2d51c47b543c90015c04147c1" translate="yes" xml:space="preserve">
          <source>If you wanted to store the value 128 million into that field, you would do so as if the &amp;lsquo;</source>
          <target state="translated">如果您想将价值1.28亿美元的值存储到该字段中，则可以将&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="d6f238b944da72a8958154ef52736f8bf20193b7" translate="yes" xml:space="preserve">
          <source>If you wanted to store the value 128 million into that field, you would do so as if the&lt;code&gt;P&lt;/code&gt; were&lt;code&gt;9&lt;/code&gt;:</source>
          <target state="translated">如果要将值1.28亿存储到该字段中，则将 &lt;code&gt;P&lt;/code&gt; 设置为 &lt;code&gt;9&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3a1e11453cfdbd4a0f6b18b6c27cb66cedc0741d" translate="yes" xml:space="preserve">
          <source>If you will be porting existing code over to GnuCOBOL, you&amp;rsquo;ll find it an accommodating facility capable of conforming to whatever language and coding standards that code is likely to use. If you are creating new GnuCOBOL programs, however, I would strongly counsel you to use the &lt;code&gt;END-&lt;var&gt;verb&lt;/var&gt;&lt;/code&gt; structures in those programs.</source>
          <target state="translated">如果要将现有代码移植到GnuCOBOL，您会发现它是一种容纳工具，能够符合可能使用的任何语言和编码标准。但是，如果您要创建新的GnuCOBOL程序，我强烈建议您在这些程序中使用 &lt;code&gt;END-&lt;var&gt;verb&lt;/var&gt;&lt;/code&gt; 结构。</target>
        </trans-unit>
        <trans-unit id="f960091ad57764e902ba6a62fa5a1b8ba304ce95" translate="yes" xml:space="preserve">
          <source>If you will be porting existing code over to GnuCOBOL, you&amp;rsquo;ll find it an accommodating facility capable of conforming to whatever language and coding standards that code is likely to use. If you are creating new GnuCOBOL programs, however, I would strongly counsel you to use the&lt;code&gt;END-verb&lt;/code&gt;structures in those programs.</source>
          <target state="translated">如果要将现有代码移植到GnuCOBOL，您会发现它是一种容纳工具，能够符合可能使用的任何语言和编码标准。但是，如果您要创建新的GnuCOBOL程序，我强烈建议您在这些程序中使用END- &lt;code&gt;END-verb&lt;/code&gt; 结构。</target>
        </trans-unit>
        <trans-unit id="bc53cf603e35a32cb8513a9837d8949b255f4fa1" translate="yes" xml:space="preserve">
          <source>If your GnuCOBOL build uses the Berkeley Database (BDB) package, use this environment variable to specify the folder in which the lock management files to be associated with all non-SORT files opened by the program will be stored. &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;) files will also have their data file allocated in the folder pointed to by this environment variable, if it exists.. Having this variable defined will activate record locking features on the &lt;code&gt;READ&lt;/code&gt; statement (see &lt;a href=&quot;#READ&quot;&gt;READ&lt;/a&gt;), &lt;code&gt;REWRITE&lt;/code&gt; statement (see &lt;a href=&quot;#REWRITE&quot;&gt;REWRITE&lt;/a&gt;) and &lt;code&gt;WRITE&lt;/code&gt; statement (see &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;). Even with DB_HOME, locking will not work with &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;), &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE SEQUENTIAL&lt;/a&gt;) or ORGANIZATION RELATIVE files with GnuCOBOL builds created for Windows/MinGW. &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; locks will work with Windows/MinGW + BDB and all locks will work for all file organizations with UNIX GnuCOBOL builds.</source>
          <target state="translated">如果您的GnuCOBOL版本使用Berkeley数据库（BDB）包，请使用此环境变量指定将与程序打开的所有非SORT文件相关联的锁管理文件存储的文件夹。 &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; （请参阅&lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;组织索引&lt;/a&gt;）文件还将在此环境变量所指向的文件夹（如果存在）中分配其数据文件。定义此变量将激活 &lt;code&gt;READ&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#READ&quot;&gt;READ&lt;/a&gt;）， &lt;code&gt;REWRITE&lt;/code&gt; 语句上的记录锁定功能。（请参阅&lt;a href=&quot;#REWRITE&quot;&gt;REWRITE&lt;/a&gt;）和 &lt;code&gt;WRITE&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;）。即使使用DB_HOME，锁定也无法使用 &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; 具有为Windows / MinGW创建的GnuCOBOL构建的ORGANIZATION SEQUENTIAL（请参阅&lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;）， &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; （请参见&lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE SEQUENTIAL&lt;/a&gt;）或ORGANIZATION RELative。 &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; 锁将与Windows / MinGW + BDB一起使用，并且所有锁将对具有UNIX GnuCOBOL构建的所有文件组织都起作用。</target>
        </trans-unit>
        <trans-unit id="84f76abe3e8dfd99557f1d9c28b5a29519b7cdd8" translate="yes" xml:space="preserve">
          <source>If your GnuCOBOL build uses the Berkeley Database (BDB) package, use this environment variable to specify the folder in which the lock management files to be associated with all non-SORT files opened by the program will be stored.&lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;) files will also have their data file allocated in the folder pointed to by this environment variable, if it exists.. Having this variable defined will activate record locking features on the&lt;code&gt;READ&lt;/code&gt;statement (see &lt;a href=&quot;#READ&quot;&gt;READ&lt;/a&gt;),&lt;code&gt;REWRITE&lt;/code&gt;statement (see &lt;a href=&quot;#REWRITE&quot;&gt;REWRITE&lt;/a&gt;) and&lt;code&gt;WRITE&lt;/code&gt;statement (see &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;). Even with DB_HOME, locking will not work with&lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;),&lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE SEQUENTIAL&lt;/a&gt;) or ORGANIZATION RELATIVE files with GnuCOBOL builds created for Windows/MinGW.&lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt;locks will work with Windows/MinGW + BDB and all locks will work for all file organizations with UNIX GnuCOBOL builds.</source>
          <target state="translated">如果您的GnuCOBOL版本使用Berkeley数据库（BDB）包，请使用此环境变量指定文件夹，在该文件夹中将存储与程序打开的所有非SORT文件相关联的锁管理文件。 &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; （请参阅&lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;组织索引&lt;/a&gt;）文件还将在此环境变量所指向的文件夹（如果存在）中分配其数据文件。定义此变量将激活 &lt;code&gt;READ&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#READ&quot;&gt;READ&lt;/a&gt;）， &lt;code&gt;REWRITE&lt;/code&gt; 语句上的记录锁定功能。（请参阅&lt;a href=&quot;#REWRITE&quot;&gt;REWRITE&lt;/a&gt;）和 &lt;code&gt;WRITE&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;）。即使使用DB_HOME，锁定也不适用于 &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; （请参阅&lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;组织顺序&lt;/a&gt;）， &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; （请参见&lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;组织&lt;/a&gt;顺序）或具有为Windows / MinGW创建的GnuCOBOL构建的组织相对文件。 &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; 锁将与Windows / MinGW + BDB一起使用，并且所有锁将对具有UNIX GnuCOBOL构建的所有文件组织都起作用。</target>
        </trans-unit>
        <trans-unit id="5d5c76b0afd98975a32ec5cfb6a7e9651011522c" translate="yes" xml:space="preserve">
          <source>If your program is using Free Format Mode, there&amp;rsquo;s less need to continue long alphanumeric literals because statements may be as long as 255 characters.</source>
          <target state="translated">如果您的程序使用的是&amp;ldquo;自由格式模式&amp;rdquo;，则无需再继续使用长字母数字文字，因为语句可能长达255个字符。</target>
        </trans-unit>
        <trans-unit id="95fac7041303838d18e876497588b4e3cf6b6006" translate="yes" xml:space="preserve">
          <source>If, however, the GnuCOBOL compiler was built for a Unix, OSX or Linux environment, or was built for a Windows environment utilizing either the Cygwin or MinGW Unix emulators, use a colon character (&amp;lsquo;</source>
          <target state="translated">但是，如果GnuCOBOL编译器是为Unix，OSX或Linux环境构建的，或者是为使用Cygwin或MinGW Unix仿真器的Windows环境构建的，则使用冒号（'</target>
        </trans-unit>
        <trans-unit id="9ec069692353086fbfea33bd5148cbb40a61d28b" translate="yes" xml:space="preserve">
          <source>If, however, the GnuCOBOL compiler was built for a Unix, OSX or Linux environment, or was built for a Windows environment utilizing either the Cygwin or MinGW Unix emulators, use a colon character (:) as the delimiter.</source>
          <target state="translated">但是,如果GnuCOBOL编译器是为Unix、OSX或Linux环境构建的,或者是利用Cygwin或MinGW Unix模拟器为Windows环境构建的,则使用冒号字符(:)作为分隔符。</target>
        </trans-unit>
        <trans-unit id="c5c01c32e00c545ff3bdc88e7beddc787c903e01" translate="yes" xml:space="preserve">
          <source>If, however, you want to reset the &lt;code&gt;SUM&lt;/code&gt; counter only when the control footing for a control break higher in the control hierarchy is presented, specify that higher control break on the &lt;code&gt;RESET&lt;/code&gt; option.</source>
          <target state="translated">但是，如果仅在显示控件层次结构中较高的控件中断的控件基础时才希望重置 &lt;code&gt;SUM&lt;/code&gt; 计数器，请在 &lt;code&gt;RESET&lt;/code&gt; 选项上指定较高的控件中断。</target>
        </trans-unit>
        <trans-unit id="732d00d8a979e2d6acfa93077091ec5aa45575e1" translate="yes" xml:space="preserve">
          <source>If, however, you want to reset the&lt;code&gt;SUM&lt;/code&gt;counter only when the control footing for a control break higher in the control hierarchy is presented, specify that higher control break on the&lt;code&gt;RESET&lt;/code&gt;option.</source>
          <target state="translated">但是，如果仅在显示控件层次结构中较高的控件中断的控件基础时才希望重置 &lt;code&gt;SUM&lt;/code&gt; 计数器，请在 &lt;code&gt;RESET&lt;/code&gt; 选项上指定较高的控件中断。</target>
        </trans-unit>
        <trans-unit id="5806c2a3b18d52c426a775c9f93d63ac19b6bb13" translate="yes" xml:space="preserve">
          <source>If, on the other hand, the compiler</source>
          <target state="translated">另一方面,如果编译器</target>
        </trans-unit>
        <trans-unit id="2cd8cc804f2a5ff93a10ce1b74fdd3576f5a7e3f" translate="yes" xml:space="preserve">
          <source>If, on the other hand, the compiler &quot;config&quot; file you used to compile the program specified &quot;mf&quot; as the &quot;assign-clause&quot; value, then the File Locator String will be interpreted according to according to IBM COBOL rules &amp;mdash; namely, the File Locator String is expected to be of the form &quot;S-xxx&quot; or &quot;AS-xxx&quot;, in which case the &quot;xxx&quot; will be treated as the base of an environment variable name. If there is no &quot;-&quot; character in the File Locator String then the entire File Locator String will serve as the base of an environment variable name.</source>
          <target state="translated">另一方面，如果您用来编译程序的编译器&amp;ldquo; config&amp;rdquo;文件将&amp;ldquo; mf&amp;rdquo;指定为&amp;ldquo; assign-clause&amp;rdquo;值，则文件定位符字符串将根据IBM COBOL规则进行解释，即，文件定位符字符串的格式应为&amp;ldquo; S-xxx&amp;rdquo;或&amp;ldquo; AS-xxx&amp;rdquo;，在这种情况下，&amp;ldquo; xxx&amp;rdquo;将被视为环境变量名称的基础。如果文件定位符字符串中没有&amp;ldquo;-&amp;rdquo;字符，则整个文件定位符字符串将用作环境变量名称的基础。</target>
        </trans-unit>
        <trans-unit id="14a1e778d3d526022a292de2dd1ee46c48882f7a" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;AFTER ADVANCING&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;AFTER ADVANCING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2484c7b62fe9d88e48bcea28b9bbba49a4a0abff" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;FIRST&lt;/code&gt;was specified, the logical record pointer will point to the first record in the file.</source>
          <target state="translated">如果指定了 &lt;code&gt;FIRST&lt;/code&gt; ，则逻辑记录指针将指向文件中的第一条记录。</target>
        </trans-unit>
        <trans-unit id="7863a8759644caaed13a6998607dcd0f2e23acf3" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;KEY&lt;/code&gt;was specified or implied, the logical record pointer will be specified to the</source>
          <target state="translated">如果指定或暗示了 &lt;code&gt;KEY&lt;/code&gt; ，则将逻辑记录指针指定为</target>
        </trans-unit>
        <trans-unit id="1552ccf0c116c7d239331a720f9d74cec693c257" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;LAST&lt;/code&gt;was specified, the logical record pointer will point to the last record in the file.</source>
          <target state="translated">如果指定了 &lt;code&gt;LAST&lt;/code&gt; ，则逻辑记录指针将指向文件中的最后一条记录。</target>
        </trans-unit>
        <trans-unit id="8278b8c8384858282c9b205d0ba2082757d20698" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;PICTURE&lt;/code&gt;9 and contains&lt;code&gt;S&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;PICTURE&lt;/code&gt; 9包含 &lt;code&gt;S&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8061e9cae2be0636e69237bf17be3f7098f0542a" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;PICTURE&lt;/code&gt;contains&lt;code&gt;S&lt;/code&gt;</source>
          <target state="translated">If&lt;code&gt;PICTURE&lt;/code&gt;contains&lt;code&gt;S&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9cd6edca65a7476c700085fccd1713df6568c8bd" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;n&lt;/code&gt;represents the level number of the object, then no other data items with a level number numerically less than&lt;code&gt;n&lt;/code&gt;may be defined between the subject and object data items.</source>
          <target state="translated">如果 &lt;code&gt;n&lt;/code&gt; 表示对象的级别号，则在对象和对象数据项之间不能定义级别数字小于 &lt;code&gt;n&lt;/code&gt; 的其他数据项。</target>
        </trans-unit>
        <trans-unit id="d3c3a4ef34b214c7901c86d04f87249a39615cfd" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;n&lt;/code&gt;represents the level number of the object, then no other data items with level number&lt;code&gt;n&lt;/code&gt;may be defined between the subject and object data items unless they too are&lt;code&gt;REDEFINES&lt;/code&gt;of the subject.</source>
          <target state="translated">如果 &lt;code&gt;n&lt;/code&gt; 表示对象的级别数，则没有与电平数量的其他数据项 &lt;code&gt;n&lt;/code&gt; 可在主体与客体的数据项之间所限定，除非他们也 &lt;code&gt;REDEFINES&lt;/code&gt; 受试者的。</target>
        </trans-unit>
        <trans-unit id="44bac4e7eb3f9b6dfa360542d18651d867fe0f3a" translate="yes" xml:space="preserve">
          <source>Imagine my surprise, however, when I discovered that the use of</source>
          <target state="translated">想象一下,当我发现使用的是</target>
        </trans-unit>
        <trans-unit id="41e3512adad8c7a49c2bc5818c26857faf073355" translate="yes" xml:space="preserve">
          <source>Imagine my surprise, however, when I discovered that the use of&lt;code&gt;-fnotrunc&lt;/code&gt;switch also made a difference:</source>
          <target state="translated">但是，当我发现使用 &lt;code&gt;-fnotrunc&lt;/code&gt; 开关也有所作为时，请想象一下我的惊奇：</target>
        </trans-unit>
        <trans-unit id="ba2d2155230191737321736ab1c421252a9d474f" translate="yes" xml:space="preserve">
          <source>Imperative Statement</source>
          <target state="translated">必要性声明</target>
        </trans-unit>
        <trans-unit id="093f2fea111647ab73586789136bb3d0d4a0950c" translate="yes" xml:space="preserve">
          <source>Implementation-defined accept condition</source>
          <target state="translated">实施定义的接受条件</target>
        </trans-unit>
        <trans-unit id="3d29bb9dbd4be0c211a42d389e2c3292fd50b3aa" translate="yes" xml:space="preserve">
          <source>Implementation-defined display condition</source>
          <target state="translated">实施定义的显示条件</target>
        </trans-unit>
        <trans-unit id="b6644f9a8f19bd69003afc9a5c99d078e33e6700" translate="yes" xml:space="preserve">
          <source>In Micro Focus COBOL, calling this subroutine flushes any as-yet unwritten buffers for the (output) file whose file-handle is specified as the argument to disk.</source>
          <target state="translated">在Micro Focus COBOL中,调用这个子程序可以为(输出)文件刷新任何尚未写入的缓冲区,其文件柄被指定为磁盘的参数。</target>
        </trans-unit>
        <trans-unit id="9a3d8039ba479addeceb49cf9771fd1febf412b7" translate="yes" xml:space="preserve">
          <source>In addition there is the &lt;a href=&quot;https://gnucobol.sourceforge.io/faq/index.html&quot;&gt;GnuCOBOL FAQ&lt;/a&gt; &amp;mdash; which has now exceeded 1,400 pages &amp;mdash; available as HTML or a downloadable</source>
          <target state="translated">此外，还有&lt;a href=&quot;https://gnucobol.sourceforge.io/faq/index.html&quot;&gt;GnuCOBOL常见问题解答&lt;/a&gt;（现已超过1,400页），可通过HTML或可下载的方式获得</target>
        </trans-unit>
        <trans-unit id="d9ef63e2e17e3ccc69daafe9826c9b7b1b6876dd" translate="yes" xml:space="preserve">
          <source>In addition, you can add and/or remove reserved words by adding one of these options to cobc to add</source>
          <target state="translated">此外,您可以通过向cobc添加以下选项之一来添加和/或删除保留字,以添加</target>
        </trans-unit>
        <trans-unit id="a1823875f108e53987aa44c7484ef1eb0340b856" translate="yes" xml:space="preserve">
          <source>In an attempt to correct the problem, we could qualify the reference to &lt;code&gt;CITY&lt;/code&gt; as &lt;code&gt;MOVE 'Philadelphia' TO CITY OF MAILING-ADDRESS&lt;/code&gt;.</source>
          <target state="translated">在试图解决问题，我们有资格的参考 &lt;code&gt;CITY&lt;/code&gt; 为 &lt;code&gt;MOVE 'Philadelphia' TO CITY OF MAILING-ADDRESS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d3ffee367a47df22f0329d2161f7179c7140f49" translate="yes" xml:space="preserve">
          <source>In an attempt to correct the problem, we could qualify the reference to CITY as&lt;code&gt;MOVE 'Philadelphia' TO CITY OF MAILING-ADDRESS&lt;/code&gt;</source>
          <target state="translated">为了解决该问题，我们可以将对CITY的引用限定为将 &lt;code&gt;MOVE 'Philadelphia' TO CITY OF MAILING-ADDRESS&lt;/code&gt; 移至&amp;ldquo;邮件地址&amp;rdquo;城市</target>
        </trans-unit>
        <trans-unit id="1132a1566c2ed19e4f36c07a65dd3752e2bf4c83" translate="yes" xml:space="preserve">
          <source>In complex expressions composed of multiple operators and operands, a precedence of operation applies whereby those operations having a higher precedence are computed first before operations with a lower precedence.</source>
          <target state="translated">在由多个操作符和操作数组成的复杂表达式中,操作的优先性适用于先计算优先性较高的操作,再计算优先性较低的操作。</target>
        </trans-unit>
        <trans-unit id="79c5dda42b4edec899decd22cc8013757597eb29" translate="yes" xml:space="preserve">
          <source>In either instance, program</source>
          <target state="translated">在这两种情况下,程序</target>
        </trans-unit>
        <trans-unit id="67cd2a991339c0db61eccf443f46cb731b97b13e" translate="yes" xml:space="preserve">
          <source>In either instance, program &quot;A&quot; is referred to as the &amp;rsquo;</source>
          <target state="translated">在这两种情况下，程序&amp;ldquo; A&amp;rdquo;都称为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="b68b4bcf151b57e71e554fe7952a0e73619a414f" translate="yes" xml:space="preserve">
          <source>In general, each picture symbol represents either a single character in storage or a single decimal digit. There are a few exceptions, and they will be discussed as needed.</source>
          <target state="translated">一般来说,每个图片符号代表存储中的一个字符或一个十进制数字。有少数例外,将根据需要进行讨论。</target>
        </trans-unit>
        <trans-unit id="2411df7c12420101004e143cb3943a4101a56bf7" translate="yes" xml:space="preserve">
          <source>In general, table references such as example #1 (constant subscript) generate the smallest, simplest and fastest object code while table references such as example #2 (numeric data item subscript) generate the largest, most-complicated and slowest object code.</source>
          <target state="translated">一般来说,表引用如例#1(常量下标)产生的对象代码最小、最简单、最快,而表引用如例#2(数值数据项下标)产生的对象代码最大、最复杂、最慢。</target>
        </trans-unit>
        <trans-unit id="9f3d74011ccc810b1770ab4e3dfbc7f8f1fdf305" translate="yes" xml:space="preserve">
          <source>In highest to lowest order of precedence, here is a discussion of each category of operation:</source>
          <target state="translated">按照从高到低的顺序,以下是对每一类行动的讨论。</target>
        </trans-unit>
        <trans-unit id="37e03fd035bc729f5e1bac261783ab6dc96b9a08" translate="yes" xml:space="preserve">
          <source>In order for &amp;lt;</source>
          <target state="translated">为了&amp;lt;</target>
        </trans-unit>
        <trans-unit id="8be023fea55c01ac8e26c286b3ef96dd0c3a62af" translate="yes" xml:space="preserve">
          <source>In order for &lt;code&gt;AND&lt;/code&gt; to yield a value of &lt;code&gt;TRUE&lt;/code&gt;, both conditions must have a value of &lt;code&gt;TRUE&lt;/code&gt;. In all other circumstances, &lt;code&gt;AND&lt;/code&gt; produces a &lt;code&gt;FALSE&lt;/code&gt; value.</source>
          <target state="translated">为了使 &lt;code&gt;AND&lt;/code&gt; 得出 &lt;code&gt;TRUE&lt;/code&gt; 值，两个条件都必须具有 &lt;code&gt;TRUE&lt;/code&gt; 值。在所有其他情况下， &lt;code&gt;AND&lt;/code&gt; 会产生 &lt;code&gt;FALSE&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="403d7a15fce45769c754a15681e968a4fbdf42a3" translate="yes" xml:space="preserve">
          <source>In order for &lt;var&gt;data-item-1&lt;/var&gt;, defined subordinate to group item &lt;var&gt;group-item-1&lt;/var&gt; to be a</source>
          <target state="translated">为了使 &lt;var&gt;data-item-1&lt;/var&gt; ，定义从属于组项目 &lt;var&gt;group-item-1&lt;/var&gt; 是一个</target>
        </trans-unit>
        <trans-unit id="6bb3bbadc2d27138c4c9dae5d396fb6f7ddc8694" translate="yes" xml:space="preserve">
          <source>In order for a &amp;lt;</source>
          <target state="translated">为了&amp;lt;</target>
        </trans-unit>
        <trans-unit id="696cb05cea8df84db487d490488180e06e42f98d" translate="yes" xml:space="preserve">
          <source>In order for a &lt;var&gt;Selection-Subject&lt;/var&gt; to match the corresponding &lt;var&gt;Selection-Object&lt;/var&gt; on a &lt;code&gt;WHEN&lt;/code&gt; clause, at least one of the following must be true:</source>
          <target state="translated">为了使 &lt;var&gt;Selection-Subject&lt;/var&gt; 与 &lt;code&gt;WHEN&lt;/code&gt; 子句上的对应 &lt;var&gt;Selection-Object&lt;/var&gt; 相匹配，必须至少满足以下条件之一：</target>
        </trans-unit>
        <trans-unit id="36616f50c54eeaba783ad05be353c37e7580b497" translate="yes" xml:space="preserve">
          <source>In order for this clause to take effect at execution time, the user must move the cursor into the field having this clause in its definition.</source>
          <target state="translated">为了使这个子句在执行时生效,用户必须将光标移动到有这个子句定义的字段中。</target>
        </trans-unit>
        <trans-unit id="444f270a7cbd0c09971c70be690ab851095b1a67" translate="yes" xml:space="preserve">
          <source>In order for this statement to be functional, tracing code must have been generated into the compiled program using either the</source>
          <target state="translated">为了使该语句发挥作用,跟踪代码必须在编译后的程序中使用</target>
        </trans-unit>
        <trans-unit id="d4cc191768c1993e9df309f3f21d935b4723ece5" translate="yes" xml:space="preserve">
          <source>In order for this statement to be functional, tracing code must have been generated into the compiled program using either the&lt;code&gt;-ftrace&lt;/code&gt;switch</source>
          <target state="translated">为了使该语句起作用，必须使用 &lt;code&gt;-ftrace&lt;/code&gt; 开关将跟踪代码生成到已编译的程序中</target>
        </trans-unit>
        <trans-unit id="d5716d69487d7213f5a154886aec1d579f1359df" translate="yes" xml:space="preserve">
          <source>In order for&lt;code&gt;AND&lt;/code&gt;</source>
          <target state="translated">为了 &lt;code&gt;AND&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="55a2f8f43b118a2097c61e0a121129644cb22e23" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;ldquo;curses&amp;rdquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;ldquo;PDCurses&amp;rdquo; package (used for native Windows or MinGW builds) does not support &lt;code&gt;EMPTY-CHECK&lt;/code&gt;.</source>
          <target state="translated">为了发挥作用，必须使用构建GnuCOBOL实现的基础&amp;ldquo; curses&amp;rdquo;包来支持此属性。截至目前，&amp;ldquo; PDCurses&amp;rdquo;软件包（用于本机Windows或MinGW构建）不支持 &lt;code&gt;EMPTY-CHECK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10f811fb445b449e40e131320d635a7695478fd5" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;ldquo;curses&amp;rdquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;ldquo;PDCurses&amp;rdquo; package (used for native Windows or MinGW builds) does not support &lt;code&gt;FULL&lt;/code&gt;.</source>
          <target state="translated">为了发挥作用，必须使用构建GnuCOBOL实现的基础&amp;ldquo; curses&amp;rdquo;包来支持此属性。截至目前，&amp;ldquo; PDCurses&amp;rdquo;软件包（用于本机Windows或MinGW构建）不支持 &lt;code&gt;FULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee0e64cc488517a5d97ddaf5487ad3ecb48a7a2a" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;ldquo;curses&amp;rdquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;ldquo;PDCurses&amp;rdquo; package (used for native Windows or MinGW builds) does not support &lt;code&gt;LENGTH-CHECK&lt;/code&gt;.</source>
          <target state="translated">为了发挥作用，必须使用构建GnuCOBOL实现的基础&amp;ldquo; curses&amp;rdquo;包来支持此属性。截至目前，&amp;ldquo; PDCurses&amp;rdquo;软件包（用于本机Windows或MinGW构建）不支持 &lt;code&gt;LENGTH-CHECK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa94c33bd182287b891147b289c4b02751b3b24e" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;ldquo;curses&amp;rdquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;ldquo;PDCurses&amp;rdquo; package (used for native Windows or MinGW builds) does not support &lt;code&gt;REQUIRED&lt;/code&gt;.</source>
          <target state="translated">为了发挥作用，必须使用构建GnuCOBOL实现的基础&amp;ldquo; curses&amp;rdquo;包来支持此属性。截至目前，&amp;ldquo; PDCurses&amp;rdquo;软件包（用于本机Windows或MinGW构建）不支持 &lt;code&gt;REQUIRED&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12840b41d70472b409489727335424ef0070e853" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;rsquo;curses&amp;rsquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;rsquo;PDCurses&amp;rsquo; package (used for native Windows or MinGW builds) does not support&lt;code&gt;EMPTY-CHECK&lt;/code&gt;</source>
          <target state="translated">为了发挥作用，必须使用构建GnuCOBOL实现的基础&amp;ldquo; curses&amp;rdquo;包支持此属性。截至目前，&amp;ldquo; PDCurses&amp;rdquo;软件包（用于本机Windows或MinGW构建）不支持 &lt;code&gt;EMPTY-CHECK&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17d285867c49f9dd90eb1f27cf9c7a60d1e38df8" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;rsquo;curses&amp;rsquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;rsquo;PDCurses&amp;rsquo; package (used for native Windows or MinGW builds) does not support&lt;code&gt;FULL&lt;/code&gt;</source>
          <target state="translated">为了发挥作用，必须使用构建GnuCOBOL实现的基础&amp;ldquo; curses&amp;rdquo;包支持此属性。截至目前，&amp;ldquo; PDCurses&amp;rdquo;软件包（用于本机Windows或MinGW构建）不支持 &lt;code&gt;FULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0a81aca05eb7b3e3ebeefcb93bfd42b8a77e381a" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;rsquo;curses&amp;rsquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;rsquo;PDCurses&amp;rsquo; package (used for native Windows or MinGW builds) does not support&lt;code&gt;LENGTH-CHECK&lt;/code&gt;</source>
          <target state="translated">为了发挥作用，必须使用构建GnuCOBOL实现的基础&amp;ldquo; curses&amp;rdquo;包支持此属性。截至目前，&amp;ldquo; PDCurses&amp;rdquo;软件包（用于本机Windows或MinGW构建）不支持 &lt;code&gt;LENGTH-CHECK&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="de32275ede835ac63170073ab2d665b3951078da" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;rsquo;curses&amp;rsquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;rsquo;PDCurses&amp;rsquo; package (used for native Windows or MinGW builds) does not support&lt;code&gt;REQUIRED&lt;/code&gt;</source>
          <target state="translated">为了发挥作用，必须使用构建GnuCOBOL实现的基础&amp;ldquo; curses&amp;rdquo;包支持此属性。截至目前，&amp;ldquo; PDCurses&amp;rdquo;软件包（用于本机Windows或MinGW构建）不支持 &lt;code&gt;REQUIRED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8ea48fcaef90024e13873585a7560dd9b545d9d4" translate="yes" xml:space="preserve">
          <source>In order to take effect, the user must first move the cursor into the field having this clause in its definition.</source>
          <target state="translated">为了生效,用户必须首先将光标移动到定义中有该子句的字段中。</target>
        </trans-unit>
        <trans-unit id="6329aaa46fe1739509d0184063f2f41cb7ae1982" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; paragraph, an external switch name can be associated with one or more condition names. These condition names may then be used to test the ON/OFF status of the external switch.</source>
          <target state="translated">在 &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; 段落中，可以将一个外部交换机名称与一个或多个条件名称相关联。然后，可以使用这些条件名称来测试外部开关的ON / OFF状态。</target>
        </trans-unit>
        <trans-unit id="cc57fee8f92052111c736b00a5242c4a85a7c964" translate="yes" xml:space="preserve">
          <source>In the above examples, a comma is used as a separator character between the two subscript values; semicolons (&lt;code&gt;;&lt;/code&gt;) are also valid subscript separator characters, as are spaces! The use of a comma or semicolon separator in such a situation is technically optional, but by convention most COBOL programmers use one or the other. The use of no separator character (other than a space) is not recommended, even though it is syntactically correct, as this practice can lead to programmer-unfriendly code. It isn&amp;rsquo;t too difficult to read and understand &lt;code&gt;GRID-CHARACTER(2 3)&lt;/code&gt;, but it&amp;rsquo;s another story entirely when trying to comprehend &lt;code&gt;GRID-CHARACTER(I + 1 J / 3)&lt;/code&gt; (instead of &lt;code&gt;GRID-CHARACTER(I + 1, J / 3)&lt;/code&gt;). The compiler accepts it, but too much of this would make</source>
          <target state="translated">在上面的示例中，逗号用作两个下标值之间的分隔符；分号（ &lt;code&gt;;&lt;/code&gt; ）也是有效的下标分隔符，空格也是！在这种情况下，使用逗号或分号分隔符在技术上是可选的，但按照惯例，大多数COBOL程序员都使用一种或另一种。即使在语法上正确，也不建议使用无分隔符（空格除外），因为这种做法会导致程序员不友好的代码。阅读和理解 &lt;code&gt;GRID-CHARACTER(2 3)&lt;/code&gt; 并不是太困难，但是当试图理解 &lt;code&gt;GRID-CHARACTER(I + 1 J / 3)&lt;/code&gt; （而不是 &lt;code&gt;GRID-CHARACTER(I + 1, J / 3)&lt;/code&gt; ）时，这完全是另一个故事。/ 3））。编译器接受它，但是太多会使</target>
        </trans-unit>
        <trans-unit id="c1ff1f707da403375eb5aac3df8097ce50066a1d" translate="yes" xml:space="preserve">
          <source>In the above examples, a comma is used as a separator character between the two subscript values; semicolons &lt;code&gt;;&lt;/code&gt; are also valid subscript separator characters, as are spaces! The use of a comma or semicolon separator in such a situation is technically optional, but by convention most COBOL programmers use one or the other. The use of no separator character (other than a space) is not recommended, even though it is syntactically correct, as this practice can lead to programmer-unfriendly code. It isn&amp;rsquo;t too difficult to read and understand&lt;code&gt;GRID-CHARACTER(2 3)&lt;/code&gt; but it&amp;rsquo;s another story entirely when trying to comprehend&lt;code&gt;GRID-CHARACTER(I + 1 J / 3)&lt;/code&gt;(instead of&lt;code&gt;GRID-CHARACTER(I + 1, J / 3)&lt;/code&gt;. The compiler accepts it, but too much of this would make</source>
          <target state="translated">在上面的示例中，逗号用作两个下标值之间的分隔符；分号 &lt;code&gt;;&lt;/code&gt; 也是有效的下标分隔符，空格也是！在这种情况下，使用逗号或分号分隔符在技术上是可选的，但按照惯例，大多数COBOL程序员都使用一种或另一种。即使在语法上正确，也不建议使用无分隔符（空格除外），因为这种做法会导致程序员不友好的代码。阅读和理解 &lt;code&gt;GRID-CHARACTER(2 3)&lt;/code&gt; 并不是很困难，但是当试图理解 &lt;code&gt;GRID-CHARACTER(I + 1 J / 3)&lt;/code&gt; （而不是 &lt;code&gt;GRID-CHARACTER(I + 1, J / 3)&lt;/code&gt; 。编译器接受它，但是这样做太多会使</target>
        </trans-unit>
        <trans-unit id="52f55f41b9c4760d3c377c604dc4758316a39ba3" translate="yes" xml:space="preserve">
          <source>In the absence of the  &lt;code&gt;OVERRIDE&lt;/code&gt; option, &lt;var&gt;cdf-variable-1&lt;/var&gt; must not yet have been defined. When the &lt;code&gt;OVERRIDE&lt;/code&gt; option is specified, &lt;var&gt;cdf-variable-1&lt;/var&gt; will be created with the specified value, if it had not yet been defined. If it had already been defined, it will be redefined with the new value.</source>
          <target state="translated">如果没有 &lt;code&gt;OVERRIDE&lt;/code&gt; 选项，则必须尚未定义 &lt;var&gt;cdf-variable-1&lt;/var&gt; 。当 &lt;code&gt;OVERRIDE&lt;/code&gt; 指定选项， &lt;var&gt;cdf-variable-1&lt;/var&gt; 将使用指定的值创建，如果它尚未确定。如果已经定义，则将使用新值重新定义它。</target>
        </trans-unit>
        <trans-unit id="ab0a8c97ecdd65110e9781dbe9e9bcdabaa33882" translate="yes" xml:space="preserve">
          <source>In the absence of the&lt;code&gt;OVERRIDE&lt;/code&gt;</source>
          <target state="translated">在没有 &lt;code&gt;OVERRIDE&lt;/code&gt; 的情况下</target>
        </trans-unit>
        <trans-unit id="bfc5f4c3999bc465f3a7a57164398621856b4683" translate="yes" xml:space="preserve">
          <source>In the case of the former, the &lt;code&gt;USING&lt;/code&gt; clause on the procedure division header should describe the argument via the  &lt;code&gt;BY REFERENCE&lt;/code&gt; clause &amp;mdash; in the latter case, a  &lt;code&gt;BY VALUE&lt;/code&gt; specification should be coded. This allows the code generated by the compiler to properly reference the subprogram arguments at run-time.</source>
          <target state="translated">在前者的情况下，过程划分头上的 &lt;code&gt;USING&lt;/code&gt; 子句应通过 &lt;code&gt;BY REFERENCE&lt;/code&gt; 子句描述自变量-在后一种情况下，应编码 &lt;code&gt;BY VALUE&lt;/code&gt; 规范。这允许编译器生成的代码在运行时正确引用子程序参数。</target>
        </trans-unit>
        <trans-unit id="be9ad81756c2c029daadb7f85dc6de13011d4872" translate="yes" xml:space="preserve">
          <source>In the case of the former, the&lt;code&gt;USING&lt;/code&gt;clause on the procedure division header should describe the argument via the&lt;code&gt;BY REFERENCE&lt;/code&gt;</source>
          <target state="translated">在前者的情况下，过程除标头上的 &lt;code&gt;USING&lt;/code&gt; 子句应通过 &lt;code&gt;BY REFERENCE&lt;/code&gt; 描述自变量</target>
        </trans-unit>
        <trans-unit id="3683f2272e68eee3328548bbf75c6cbed2e45e7d" translate="yes" xml:space="preserve">
          <source>In the late 70&amp;rsquo;s cards was also on its way out to the point where P.C&amp;rsquo;s started being used (and no they were not made by IBM), so these columns could be used for other purposes including cc 73 - 80 instead of indicating the 8 character program name which was the maximum size allowed on a IBM system.</source>
          <target state="translated">在70年代后期，显示卡也即将使用到开始使用PC的地步（而且它们不是IBM制造的），因此这些列可用于其他用途，包括cc 73-80，而不是指示8个字符的程序名称，这是IBM系统上允许的最大大小。</target>
        </trans-unit>
        <trans-unit id="d448bc8e604cd799be10bb1a12e035041426f0fc" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;EXIT&lt;/code&gt; statement takes no other run-time action.</source>
          <target state="translated">在这种情况下， &lt;code&gt;EXIT&lt;/code&gt; 语句不执行其他任何运行时操作。</target>
        </trans-unit>
        <trans-unit id="82849a227b43e92353f440e6cf481dde7d3eb800" translate="yes" xml:space="preserve">
          <source>In this case, the&lt;code&gt;EXIT&lt;/code&gt;statement takes no other run-time action.</source>
          <target state="translated">在这种情况下， &lt;code&gt;EXIT&lt;/code&gt; 语句不执行其他任何运行时操作。</target>
        </trans-unit>
        <trans-unit id="f943ab0caafc93abf22796cdb3e33af1b9b863ef" translate="yes" xml:space="preserve">
          <source>In this context, &lt;code&gt;VALUE&lt;/code&gt; specifies an initial compilation-time value that will be assigned to the storage occupied by the data item in the program object code generated by the compiler.</source>
          <target state="translated">在这种情况下， &lt;code&gt;VALUE&lt;/code&gt; 指定初始编译时值，该值将分配给编译器生成的程序目标代码中数据项所占用的存储。</target>
        </trans-unit>
        <trans-unit id="2a9d1dc97c6798126e8a06dda35c75cc92d21220" translate="yes" xml:space="preserve">
          <source>In this context,&lt;code&gt;VALUE&lt;/code&gt;specifies an initial compilation-time value that will be assigned to the storage occupied by the data item in the program object code generated by the compiler.</source>
          <target state="translated">在这种情况下， &lt;code&gt;VALUE&lt;/code&gt; 指定初始编译时值，该值将分配给编译器生成的程序目标代码中数据项所占用的存储。</target>
        </trans-unit>
        <trans-unit id="eec8378c7504896f2e89770da7d03a86fe4ae4b3" translate="yes" xml:space="preserve">
          <source>In this example, all six &amp;lsquo;</source>
          <target state="translated">在此示例中，所有六个&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="84cb1e4aa0b378b3db93b48860594751f6ae285f" translate="yes" xml:space="preserve">
          <source>In this example, all six&lt;code&gt;A&lt;/code&gt;items will be initialized to &quot;?&quot;, all six&lt;code&gt;B&lt;/code&gt;items will be initialized to &quot;%&quot; and all six&lt;code&gt;N&lt;/code&gt;items will be initialized to 10. It&amp;rsquo;s not clear exactly how many times this sort of initialization will be useful, but it&amp;rsquo;s there if you need it.</source>
          <target state="translated">在此示例中，所有六个 &lt;code&gt;A&lt;/code&gt; 项目将被初始化为&amp;ldquo;？&amp;rdquo;，所有六个 &lt;code&gt;B&lt;/code&gt; 项目将被初始化为&amp;ldquo;％&amp;rdquo;，所有六个 &lt;code&gt;N&lt;/code&gt; 项目将被初始化为10。目前尚不清楚这种初始化将执行多少次。很有用，但是如果您需要它，它就在那里。</target>
        </trans-unit>
        <trans-unit id="bdd4beaea45ea4f61aa50c556d96af34394add5c" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;IF&lt;/code&gt; statement actually has a scope that can include two sets of associated statements: one set to be executed when the &lt;code&gt;IF&lt;/code&gt; (see &lt;a href=&quot;#IF&quot;&gt;IF&lt;/a&gt;) condition is &lt;code&gt;TRUE&lt;/code&gt;, and another if it is &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">在此示例中， &lt;code&gt;IF&lt;/code&gt; 语句实际上具有一个范围，该范围可以包括两组关联的语句：一组在 &lt;code&gt;IF&lt;/code&gt; （请参阅&lt;a href=&quot;#IF&quot;&gt;IF&lt;/a&gt;）条件为 &lt;code&gt;TRUE&lt;/code&gt; 时执行，而另一组在 &lt;code&gt;FALSE&lt;/code&gt; 时执行。</target>
        </trans-unit>
        <trans-unit id="2879e2f56bb5d870554e86f04a4bf9ebe7fb4ed9" translate="yes" xml:space="preserve">
          <source>In this example, the IF statement actually has a scope that can include two sets of associated statements &amp;ndash; one set to be executed when the&lt;code&gt;IF&lt;/code&gt;(see &lt;a href=&quot;#IF&quot;&gt;IF&lt;/a&gt;) condition is TRUE and another if it is FALSE.</source>
          <target state="translated">在此示例中，IF语句实际上具有一个范围，该范围可以包括两组关联的语句-一组在 &lt;code&gt;IF&lt;/code&gt; （请参阅&lt;a href=&quot;#IF&quot;&gt;IF&lt;/a&gt;）条件为TRUE 时执行，而另一组在FALSE时执行。</target>
        </trans-unit>
        <trans-unit id="b671b6f79a2badfb5c4ccb993eb5f1ff2485bd4c" translate="yes" xml:space="preserve">
          <source>In which case 9 characters of storage will be reserved. The values 000000000 through 999999999 will represent the gross-revenues. But, if only the millions are tracked (meaning the last six digits are always going to be 0), you could define the field as:</source>
          <target state="translated">在这种情况下,将保留9个字符的存储空间。000000000到99999999的数值将代表总收入。但是,如果只跟踪百万收入(意味着最后六位数字永远是0),您可以将该字段定义为。</target>
        </trans-unit>
        <trans-unit id="0f756e9a80d7e50bae6b071828fc08b35abbddf1" translate="yes" xml:space="preserve">
          <source>Include the reserved word  &lt;code&gt;FINAL&lt;/code&gt; if you want to include a special control heading before the first detail line is generated (&lt;code&gt;CONTROL HEADING FINAL&lt;/code&gt;) or after the last detail line is generated (&lt;code&gt;CONTROL FOOTING FINAL&lt;/code&gt;).</source>
          <target state="translated">如果要在生成第一个细节行之前（ &lt;code&gt;CONTROL HEADING FINAL&lt;/code&gt; ）或在生成最后一个细节行之后（ &lt;code&gt;CONTROL FOOTING FINAL&lt;/code&gt; ）包括特殊的控件标题，请包括保留字 &lt;code&gt;FINAL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6178a2fcb450efe4624273996659b2d5392d26b6" translate="yes" xml:space="preserve">
          <source>Include the reserved word&lt;code&gt;FINAL&lt;/code&gt;</source>
          <target state="translated">包括保留字 &lt;code&gt;FINAL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="86e3af29a6d78fb45be9ab4a356d52986963f954" translate="yes" xml:space="preserve">
          <source>Including an &lt;code&gt;ON SIZE ERROR&lt;/code&gt; clause on an arithmetic statement will allow your program to trap a failure of an arithmetic statement (either generating a result too large for the receiving field, or attempting to divide by zero) and handle it gracefully by executing &lt;var&gt;imperative-statement-1&lt;/var&gt; (see &lt;a href=&quot;#Imperative-Statement&quot;&gt;Imperative Statement&lt;/a&gt;). Field size overflow conditions occur silently, usually without any runtime messages being generated, even though such events rarely lend themselves to generating correct results. Division by zero errors, when no &lt;code&gt;ON SIZE ERROR&lt;/code&gt; clause exists, will produce an error message (by the GnuCOBOL runtime library) to the &lt;code&gt;SYSERR&lt;/code&gt; device (pipe 2) and will also abort the program.</source>
          <target state="translated">在算术语句上包含 &lt;code&gt;ON SIZE ERROR&lt;/code&gt; 子句将使您的程序能够捕获算术语句的失败（要么为接收字段生成太大的结果，要么尝试除以零）并通过执行 &lt;var&gt;imperative-statement-1&lt;/var&gt; 来优雅地处理它-1（请参阅&lt;a href=&quot;#Imperative-Statement&quot;&gt;命令式声明&lt;/a&gt;）。字段大小溢出条件会以静默方式发生，通常不会生成任何运行时消息，即使此类事件很少有助于产生正确的结果。当不存在 &lt;code&gt;ON SIZE ERROR&lt;/code&gt; 子句时，除以零的错误将对 &lt;code&gt;SYSERR&lt;/code&gt; 设备（管道2）产生一条错误消息（通过GnuCOBOL运行时库），并且还将中止该程序。</target>
        </trans-unit>
        <trans-unit id="4587868819f3914fb0d960b2a017af52903b843c" translate="yes" xml:space="preserve">
          <source>Including an&lt;code&gt;ON SIZE ERROR&lt;/code&gt;clause on an arithmetic statement will allow your program to trap a failure of an arithmetic statement (either generating a result too large for the receiving field, or attempting to divide by zero) and handle it gracefully by executing &amp;lt;</source>
          <target state="translated">在算术语句上包含 &lt;code&gt;ON SIZE ERROR&lt;/code&gt; 子句将使您的程序能够捕获算术语句的失败（或者为接收字段生成太大的结果，或者尝试除以零）并通过执行&amp;lt;</target>
        </trans-unit>
        <trans-unit id="2ec9e5e5288405f63d74272e4e8bcad544b64e15" translate="yes" xml:space="preserve">
          <source>Incompatible data exception</source>
          <target state="translated">不兼容的数据异常</target>
        </trans-unit>
        <trans-unit id="e0049c7018b06d02f3c0ba2245a0ee83c74d7cc7" translate="yes" xml:space="preserve">
          <source>Inconsistent filename</source>
          <target state="translated">文件名不一致</target>
        </trans-unit>
        <trans-unit id="e5d727021f58d38c370cf7243256d9dff80ee53f" translate="yes" xml:space="preserve">
          <source>Independent Subprograms</source>
          <target state="translated">独立次级方案</target>
        </trans-unit>
        <trans-unit id="0e0834dadd433c69c101f415ef11e7aef2f4805a" translate="yes" xml:space="preserve">
          <source>Indexed files are processed using the following statements:</source>
          <target state="translated">索引文件使用以下语句进行处理。</target>
        </trans-unit>
        <trans-unit id="1744e48f509016afca9d63b5cee3efedb0414b54" translate="yes" xml:space="preserve">
          <source>Indexed files, like relative files, may have their records processed in either a sequential or random manner. Unlike relative files, however, the actual location of a record in an indexed file is calculated automatically based upon the value(s) of one or more alphanumeric fields within records of the file. For example, an indexed file containing product data might use the product identification code as a record key. This means you may read, write or update the &lt;code&gt;A6G4328&lt;/code&gt;&lt;sup&gt;th&lt;/sup&gt; record or the &lt;code&gt;Z8X7723&lt;/code&gt;&lt;sup&gt;th&lt;/sup&gt; record directly, based upon the product id value of those records!</source>
          <target state="translated">索引文件（如相对文件）可以按顺序或随机方式处理其记录。但是，与相对文件不同，索引文件中记录的实际位置是根据文件记录中一个或多个字母数字字段的值自动计算的。例如，包含产品数据的索引文件可能会将产品标识代码用作记录键。这意味着你可以读取，写入或更新 &lt;code&gt;A6G4328&lt;/code&gt; &lt;sup&gt;个&lt;/sup&gt;记录或 &lt;code&gt;Z8X7723&lt;/code&gt; &lt;sup&gt;个&lt;/sup&gt;直接记录，基于价值的这些记录的产品ID！</target>
        </trans-unit>
        <trans-unit id="53ce26f7aaa0c6fd7bd1bac7547ef119ea253eb9" translate="yes" xml:space="preserve">
          <source>Indexing is the process of referencing an element of a table utilizing a data item with an explicitly or implicitly defined &lt;code&gt;USAGE&lt;/code&gt; (see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of &lt;code&gt;INDEX&lt;/code&gt; to select the desired occurrence, while &amp;hellip;</source>
          <target state="translated">索引是使用数据项引用表元素的过程，该数据项具有 &lt;code&gt;INDEX&lt;/code&gt; 的显式或隐式定义的 &lt;code&gt;USAGE&lt;/code&gt; （请参阅&lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;）来选择所需的出现，而&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="9353f9003cee9268ec86b3a1ea7f4d4ecb16eb1c" translate="yes" xml:space="preserve">
          <source>Indexing is the process of referencing an element of a table utilizing a data item with an explicitly or implicitly defined&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of&lt;code&gt;INDEX&lt;/code&gt;to select the desired occurrence, while &amp;hellip;</source>
          <target state="translated">索引是使用数据项引用表元素的过程，该数据项具有 &lt;code&gt;INDEX&lt;/code&gt; 的显式或隐式定义的 &lt;code&gt;USAGE&lt;/code&gt; （请参阅&lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;）来选择所需的出现，而&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="93776ca03e71b3ad421edc98eae15b926b860367" translate="yes" xml:space="preserve">
          <source>Indicator Area</source>
          <target state="translated">指示器区域</target>
        </trans-unit>
        <trans-unit id="2fd879baf4180584f7bd97459985ff5ec005ec3f" translate="yes" xml:space="preserve">
          <source>Individually</source>
          <target state="translated">Individually</target>
        </trans-unit>
        <trans-unit id="b89618369028da6501ce98bcb744af95461452b5" translate="yes" xml:space="preserve">
          <source>Initialize small tables at compile time by including a &lt;code&gt;VALUE&lt;/code&gt; clause on the group item that serves as a parent to the table, as follows:</source>
          <target state="translated">通过在作为表父级的组项中包含 &lt;code&gt;VALUE&lt;/code&gt; 子句，在编译时初始化小表，如下所示：</target>
        </trans-unit>
        <trans-unit id="a6c6b82216692a3106690069e47ca45a2e70d92d" translate="yes" xml:space="preserve">
          <source>Initialize small tables at compile time by including a&lt;code&gt;VALUE&lt;/code&gt;clause on the group item that serves as a parent to the table, as follows:</source>
          <target state="translated">通过在作为表父级的组项中包含 &lt;code&gt;VALUE&lt;/code&gt; 子句，在编译时初始化小表，如下所示：</target>
        </trans-unit>
        <trans-unit id="27a882e0892fd25d36e3f04ed9f9da709b0210eb" translate="yes" xml:space="preserve">
          <source>Initialize tables of almost any size at compilation time by utilizing the &lt;code&gt;REDEFINES&lt;/code&gt; (see &lt;a href=&quot;#REDEFINES&quot;&gt;REDEFINES&lt;/a&gt;) clause:</source>
          <target state="translated">利用 &lt;code&gt;REDEFINES&lt;/code&gt; （请参阅&lt;a href=&quot;#REDEFINES&quot;&gt;REDEFINES&lt;/a&gt;）子句在编译时初始化几乎任何大小的表：</target>
        </trans-unit>
        <trans-unit id="24b3196c683087c1c3199428c0580a1c1d58213b" translate="yes" xml:space="preserve">
          <source>Initialize tables of almost any size at compilation time by utilizing the&lt;code&gt;REDEFINES&lt;/code&gt;(see &lt;a href=&quot;#REDEFINES&quot;&gt;REDEFINES&lt;/a&gt;) clause:</source>
          <target state="translated">利用 &lt;code&gt;REDEFINES&lt;/code&gt; （请参阅&lt;a href=&quot;#REDEFINES&quot;&gt;REDEFINES&lt;/a&gt;）子句在编译时初始化几乎任何大小的表：</target>
        </trans-unit>
        <trans-unit id="2fec9ecf2a45eb0fd0af8f70fdb0cee7e4377f3b" translate="yes" xml:space="preserve">
          <source>Inline PERFORM Syntax</source>
          <target state="translated">内联PERFORM语法</target>
        </trans-unit>
        <trans-unit id="bc36d8128c5a1e8ca8d8c4f2854d174a361c1c90" translate="yes" xml:space="preserve">
          <source>Input fields may have any character used as a fill character. These fill characters provide a visual indication of the size of the input field, and will automatically be transformed into spaces when the input field is processed by the program. If no such character is defined for an input field, an underscore (&quot;_&quot;) will be assumed.</source>
          <target state="translated">输入字段可以使用任何字符作为填充字符。这些填充字符提供了输入字段大小的视觉指示,并将在程序处理输入字段时自动转化为空格。如果没有为输入字段定义这样的字符,将假定为下划线(&quot;_&quot;)。</target>
        </trans-unit>
        <trans-unit id="ec96e3ae34d38a6710e8a26303046f2131923ec8" translate="yes" xml:space="preserve">
          <source>Input fields may have any character used as a fill character. These fill characters provide a visual indication of the size of the input field, and will automatically be transformed into spaces when the input field is processed by the program. If no such character is defined for an input field, an underscore (&amp;lsquo;</source>
          <target state="translated">输入字段可以将任何字符用作填充字符。这些填充字符提供了对输入字段大小的直观指示，当程序处理输入字段时，这些填充字符将自动转换为空格。如果没有为输入字段定义此类字符，请使用下划线（'</target>
        </trans-unit>
        <trans-unit id="33e5e7e82f76a11ddf2991effebf767de7f3deb5" translate="yes" xml:space="preserve">
          <source>Input validation</source>
          <target state="translated">输入验证</target>
        </trans-unit>
        <trans-unit id="0f58e23445d1adbd9ab6441d745e78e9796ac8aa" translate="yes" xml:space="preserve">
          <source>Input will be read either from the console window (&lt;code&gt;CONSOLE&lt;/code&gt;) or from the system-standard input (pipe 0 = &lt;code&gt;STDIN&lt;/code&gt;, &lt;code&gt;SYSIN&lt;/code&gt; or &lt;code&gt;SYSIPT&lt;/code&gt;) and will be saved in &lt;var&gt;identifier-1&lt;/var&gt;.</source>
          <target state="translated">输入将从控制台窗口（ &lt;code&gt;CONSOLE&lt;/code&gt; ）或系统标准输入（管道0 = &lt;code&gt;STDIN&lt;/code&gt; ， &lt;code&gt;SYSIN&lt;/code&gt; 或 &lt;code&gt;SYSIPT&lt;/code&gt; ）读取，并将其保存在 &lt;var&gt;identifier-1&lt;/var&gt; 中。</target>
        </trans-unit>
        <trans-unit id="d4fe42447823ec3b9e2e9421bf9fdef259cf35f1" translate="yes" xml:space="preserve">
          <source>Input will be read either from the console window &lt;code&gt;CONSOLE&lt;/code&gt; or from the system-standard input (pipe 0 =&lt;code&gt;STDIN&lt;/code&gt;&lt;code&gt;SYSIN&lt;/code&gt;or&lt;code&gt;SYSIPT&lt;/code&gt; and will be saved in &amp;lt;</source>
          <target state="translated">输入将从控制台窗口 &lt;code&gt;CONSOLE&lt;/code&gt; 或系统标准输入中读取（管道0 = &lt;code&gt;STDIN&lt;/code&gt; &lt;code&gt;SYSIN&lt;/code&gt; 或 &lt;code&gt;SYSIPT&lt;/code&gt; ，并将其保存在&amp;lt;</target>
        </trans-unit>
        <trans-unit id="11b11dadbac78c35efb5d86e561bfcff60c6701b" translate="yes" xml:space="preserve">
          <source>Integer and non-integer operands may be freely intermixed</source>
          <target state="translated">整数操作数和非整数操作数可以自由混合。</target>
        </trans-unit>
        <trans-unit id="8626f5223c37139c00a44d21c18f768de6e8df20" translate="yes" xml:space="preserve">
          <source>Integers such as 1, 56, 2192 or -54.</source>
          <target state="translated">整数,如1、56、2192或-54。</target>
        </trans-unit>
        <trans-unit id="d47bc2c05ec93f214d2f93848b03eba3a04ff0c4" translate="yes" xml:space="preserve">
          <source>Integrating well with non-COBOL infrastructures such as XML, SOA, MQ, almost any DBMS, Transaction Processing platforms, Queue-Management facilities and other programming languages.</source>
          <target state="translated">与非COBOL基础架构,如XML、SOA、MQ、几乎所有的DBMS、事务处理平台、队列管理设施和其他编程语言很好的集成。</target>
        </trans-unit>
        <trans-unit id="8b3eb3d9c05dbc205b027a6d0771b0af833c1b89" translate="yes" xml:space="preserve">
          <source>Interactions between the program and the user will take place using the standard input, standard output and standard error streams. Any screen section I/O performed by the program will take place within the command shell &quot;window&quot;.</source>
          <target state="translated">程序和用户之间的交互将使用标准输入、标准输出和标准错误流进行。程序执行的任何屏幕部分I/O将在命令壳 &quot;窗口 &quot;内进行。</target>
        </trans-unit>
        <trans-unit id="a9a9b5bdf1a9e72af88d9b1c9aeeec1f68626f9e" translate="yes" xml:space="preserve">
          <source>Interactions between the program and the user will take place using the standard input, standard output and standard error streams. Any screen section I/O performed by the program will take place within the terminal window.</source>
          <target state="translated">程序和用户之间的交互将通过标准输入、标准输出和标准错误流进行。程序执行的任何屏幕部分I/O都将在终端窗口中进行。</target>
        </trans-unit>
        <trans-unit id="4004bbedc882730cd7377c55c8a60c3d77d841f3" translate="yes" xml:space="preserve">
          <source>Intrinsic Function</source>
          <target state="translated">本质功能</target>
        </trans-unit>
        <trans-unit id="79732e9fc9080596110feae301927876fc7259e7" translate="yes" xml:space="preserve">
          <source>Is a representation of the standard numeric time contained in &lt;var&gt;argument-2&lt;/var&gt; according to the format in &lt;var&gt;argument-1&lt;/var&gt;.</source>
          <target state="translated">根据 &lt;var&gt;argument-1&lt;/var&gt; 的格式，表示参数 &lt;var&gt;argument-2&lt;/var&gt; 包含的标准数字时间。</target>
        </trans-unit>
        <trans-unit id="e5ee413f8103631bd485cdfac46dfe6d0d5e3fd5" translate="yes" xml:space="preserve">
          <source>Is there a data item named &lt;code&gt;C-D&lt;/code&gt; defined? If so, use its value for the character sequence &lt;code&gt;C-D&lt;/code&gt;.</source>
          <target state="translated">是否定义了名为 &lt;code&gt;C-D&lt;/code&gt; 的数据项？如果是这样，请将其值用于字符序列 &lt;code&gt;C-D&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3afb87dd54b38fa7410a22ca94bf84568bc6f936" translate="yes" xml:space="preserve">
          <source>Is there a data item named&lt;code&gt;C-D&lt;/code&gt;defined? If so, use its value for the character sequence&lt;code&gt;C-D&lt;/code&gt;</source>
          <target state="translated">是否定义了名为 &lt;code&gt;C-D&lt;/code&gt; 的数据项？如果是这样，请将其值用于字符序列 &lt;code&gt;C-D&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b2a3023db707fff296813396a984d683cabd59f0" translate="yes" xml:space="preserve">
          <source>It is also possible to create source files where GnuCOBOL programs are nested inside each other. Take for example these four GnuCOBOL programs:</source>
          <target state="translated">也可以创建GnuCOBOL程序相互嵌套的源文件。以这四个GnuCOBOL程序为例。</target>
        </trans-unit>
        <trans-unit id="84300e8f98a0f3852c30d9579e7c60614ed0dbd3" translate="yes" xml:space="preserve">
          <source>It is expected that:</source>
          <target state="translated">预计:</target>
        </trans-unit>
        <trans-unit id="ca9e6f0f2e7f593201ed043e07c2e0d871facea5" translate="yes" xml:space="preserve">
          <source>It is possible to generate executable modules for all GnuCOBOL programs, not just subprograms, by choosing to use the</source>
          <target state="translated">可以为所有GnuCOBOL程序生成可执行模块,而不仅仅是子程序,选择使用</target>
        </trans-unit>
        <trans-unit id="6c528e93ea46610dc90b04c262c6d8a0c4d80f39" translate="yes" xml:space="preserve">
          <source>It is possible to generate executable modules for all GnuCOBOL programs, not just subprograms, by choosing to use the&lt;code&gt;-m&lt;/code&gt;switch</source>
          <target state="translated">通过选择使用 &lt;code&gt;-m&lt;/code&gt; 开关，可以为所有GnuCOBOL程序（不仅仅是子程序）生成可执行模块。</target>
        </trans-unit>
        <trans-unit id="e3e380ef206ba659e48d91cb175358e2449a8b4e" translate="yes" xml:space="preserve">
          <source>It is possible, however, to automatically cause all &lt;code&gt;COPY&lt;/code&gt; statements to &amp;ldquo;fold&amp;rdquo; the names of all copybooks to upper-case by specifying the</source>
          <target state="translated">但是，可以通过指定以下命令自动使所有 &lt;code&gt;COPY&lt;/code&gt; 语句将所有副本的名称&amp;ldquo;折叠&amp;rdquo;为大写。</target>
        </trans-unit>
        <trans-unit id="b97faf48dcb0719b17e707ba50e23f3c431c6b2f" translate="yes" xml:space="preserve">
          <source>It is possible, however, to automatically cause all library names to &amp;rsquo;fold&amp;rsquo; to upper-case by specifying the</source>
          <target state="translated">但是，可以通过指定</target>
        </trans-unit>
        <trans-unit id="fd71df406ad79246a83a283db27a4507793dc703" translate="yes" xml:space="preserve">
          <source>It is possible, however, to automatically cause all library names to &amp;rsquo;fold&amp;rsquo; to upper-case by specifying the&lt;code&gt;-ffold-call&lt;/code&gt;switch</source>
          <target state="translated">但是，可以通过指定 &lt;code&gt;-ffold-call&lt;/code&gt; 开关自动使所有库名&amp;ldquo;折叠&amp;rdquo;为大写</target>
        </trans-unit>
        <trans-unit id="0f5ff5b5b0cc8eb3a5f026f5c68c2c34d3dd2e58" translate="yes" xml:space="preserve">
          <source>It is possible, however, to automatically cause all&lt;code&gt;COPY&lt;/code&gt;statements to &amp;rsquo;fold&amp;rsquo; the names of all copybooks to upper-case by specifying the&lt;code&gt;-ffold-copy&lt;/code&gt;switch</source>
          <target state="translated">但是，可以通过指定 &lt;code&gt;-ffold-copy&lt;/code&gt; 开关自动使所有 &lt;code&gt;COPY&lt;/code&gt; 语句将所有副本的名称&amp;ldquo;折叠&amp;rdquo;为大写。</target>
        </trans-unit>
        <trans-unit id="7fd4db1874deb79d1734c24cfc068bf9dfa3c2af" translate="yes" xml:space="preserve">
          <source>It is possible, if supported by the</source>
          <target state="translated">如果得到《公约》的支持,是可以的。</target>
        </trans-unit>
        <trans-unit id="8d95a0b3b4408000436885116c035d2b4d4eb090" translate="yes" xml:space="preserve">
          <source>It is possible, if supported by the &quot;curses&quot; package being used, to draw borders on the top, left and/or bottom edges of a field.</source>
          <target state="translated">如果使用的 &quot;curses &quot;包支持,可以在字段的顶部、左侧和/或底部边缘绘制边框。</target>
        </trans-unit>
        <trans-unit id="7d7394694e1e1adbaef5eeee92d5a9373e538bc3" translate="yes" xml:space="preserve">
          <source>It is recommended to change the CBL_OC routines to CBL_GC for forward compatability as at some point they will be removed as they are a hangover from Open Cobol.</source>
          <target state="translated">建议将CBL_OC例程改为CBL_GC,以便向前兼容,因为在某些时候它们会被删除,因为它们是Open Cobol的遗留问题。</target>
        </trans-unit>
        <trans-unit id="061e684ce444da672f8f250f9c15f353e99d24e9" translate="yes" xml:space="preserve">
          <source>It is recommended to change the CBL_OC routines to CBL_GC for forward compatibility as at some point they will be removed as they are a hangover from Open Cobol.</source>
          <target state="translated">建议将CBL_OC例程改为CBL_GC,以便向前兼容,因为在某些时候它们会被删除,因为它们是Open Cobol的遗留问题。</target>
        </trans-unit>
        <trans-unit id="4bc4bb06183a156efac27d1054572b8c27c65421" translate="yes" xml:space="preserve">
          <source>It is worth mentioning that if the</source>
          <target state="translated">值得一提的是,如果</target>
        </trans-unit>
        <trans-unit id="7246d8ea302a84c950724aa56d84b52fff1c6e02" translate="yes" xml:space="preserve">
          <source>It returns 0 when match, 1 on failure, case matters as does length, &quot;arg&quot; won&amp;rsquo;t match.</source>
          <target state="translated">匹配时返回0，失败则返回1，大小写与长度同样重要，&amp;ldquo; arg&amp;rdquo;不匹配。</target>
        </trans-unit>
        <trans-unit id="18a80c8fa72d80aad7d81f986d63eacc53ab4b98" translate="yes" xml:space="preserve">
          <source>It would appear that it should be possible to locate and process any record in the file directly simply by calculating its starting character position based upon the program-defined record size. Even so, however, records must be still be read or written to these files in a purely sequential manner. The only way to read (or write) record number 100 would be to have read (or written) records number 1 through 99 first.</source>
          <target state="translated">看来,只要根据程序定义的记录大小计算其起始字符位置,就可以直接找到并处理文件中的任何记录。然而,即使如此,记录仍然必须以纯粹的顺序方式被读取或写入这些文件。读取(或写入)100号记录的唯一方法是先读取(或写入)1到99号记录。</target>
        </trans-unit>
        <trans-unit id="70dcde551f3b6956e677f96a1f00fa175867fa96" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s impossible to perform any arithmetic operation against an index data item directly (other than a simple incrementation or decremental operation via the &lt;code&gt;SET UP/DOWN&lt;/code&gt; statement (see &lt;a href=&quot;#SET-UP_002fDOWN&quot;&gt;SET UP/DOWN&lt;/a&gt;)). Situations where any non-trivial computations are required to calculate the effective occurrence number for a table reference will require you to use a conventional unedited numeric data item as the receiving field for the calculation. That calculated value would then need to be saved into the index data item via a &lt;code&gt;SET Index&lt;/code&gt; statement.</source>
          <target state="translated">无法直接对索引数据项执行任何算术运算（除了通过 &lt;code&gt;SET UP/DOWN&lt;/code&gt; 语句进行简单的递增或递减运算（请参阅&lt;a href=&quot;#SET-UP_002fDOWN&quot;&gt;SET UP / DOWN&lt;/a&gt;））。在需要任何非平凡的计算来计算表引用的有效出现次数的情况下，您将需要使用常规的未经编辑的数值数据项作为计算的接收字段。然后，需要通过 &lt;code&gt;SET Index&lt;/code&gt; 语句将计算出的值保存到索引数据项中。</target>
        </trans-unit>
        <trans-unit id="6d1a9ad994fd74f3ea9c0abfcfff5c67eb069908" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s impossible to perform any arithmetic operation against an index data item directly (other than a simple incrementation or decremental operation via the&lt;code&gt;SET UP/DOWN&lt;/code&gt;statement (see &lt;a href=&quot;#SET-UP_002fDOWN&quot;&gt;SET UP/DOWN&lt;/a&gt;)). Situations where any non-trivial computations are required to calculate the effective occurrence number for a table reference will require you to use a conventional unedited numeric data item as the receiving field for the calculation. That calculated value would then need to be saved into the index data item via a&lt;code&gt;SET Index&lt;/code&gt;statement.</source>
          <target state="translated">无法直接对索引数据项执行任何算术运算（除了通过 &lt;code&gt;SET UP/DOWN&lt;/code&gt; 语句进行简单的递增或递减运算（请参阅&lt;a href=&quot;#SET-UP_002fDOWN&quot;&gt;SET UP / DOWN&lt;/a&gt;））。在需要任何非平凡的计算来计算表引用的有效出现次数的情况下，您将需要使用常规的未经编辑的数值数据项作为计算的接收字段。然后，需要通过 &lt;code&gt;SET Index&lt;/code&gt; 语句将该计算值保存到索引数据项中。</target>
        </trans-unit>
        <trans-unit id="48149098c4b72f980cb6ef484a18559b6952ecbd" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s probably a true that an IT professional can no longer afford to allow COBOL to be the</source>
          <target state="translated">IT专业人员再也负担不起让COBOL成为</target>
        </trans-unit>
        <trans-unit id="02387685edacc74ddafb8999ab4d02ea233cee8c" translate="yes" xml:space="preserve">
          <source>Items appearing in Mixed Case within a syntax diagram represent complex clauses of other syntax elements that may appear in that position. Some COBOL syntax gets quite complicated, and using a convention such as this significantly reduces the complexity of a syntax diagram. When such items are referenced in text, they will appear as &amp;lt;&amp;lt;</source>
          <target state="translated">语法图中出现在&amp;ldquo;混合大小写&amp;rdquo;中的项目表示可能出现在该位置的其他语法元素的复杂子句。一些COBOL语法变得相当复杂，并且使用这样的约定可以大大降低语法图的复杂性。在文本中引用此类项目时，它们将显示为&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="4c435dc1bbde5c2dacc928889559b530821b3122" translate="yes" xml:space="preserve">
          <source>Items appearing in Mixed Case within a syntax diagram represent complex clauses of other syntax elements that may appear in that position. Some COBOL syntax gets quite complicated, and using a convention such as this significantly reduces the complexity of a syntax diagram. When such items are referenced in text, they will appear as &lt;var&gt;Complex-Syntax-Clause&lt;/var&gt;.</source>
          <target state="translated">语法图中出现在&amp;ldquo;混合大小写&amp;rdquo;中的项目表示可能出现在该位置的其他语法元素的复杂子句。一些COBOL语法变得相当复杂，并且使用这样的约定可以大大降低语法图的复杂性。在文本中引用此类项目时，它们将显示为 &lt;var&gt;Complex-Syntax-Clause&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="56625773bdd51fd820fa786a2e0f16b75e88d894" translate="yes" xml:space="preserve">
          <source>JUST, JUSTIFIED</source>
          <target state="translated">公正、合理</target>
        </trans-unit>
        <trans-unit id="362a2940964523b043977ef5c326c0da3c417c71" translate="yes" xml:space="preserve">
          <source>JUSTIFIED Attribute Syntax</source>
          <target state="translated">JUSTIFIED属性 语法</target>
        </trans-unit>
        <trans-unit id="90e0e514b7cbaade00f2505567f728c431ef2c8f" translate="yes" xml:space="preserve">
          <source>JUSTIFIED, JUST</source>
          <target state="translated">合理、公正</target>
        </trans-unit>
        <trans-unit id="5722133c7e6a0b8bbf45b32c72de74b6bc64c397" translate="yes" xml:space="preserve">
          <source>Just as multiplication takes precedence over addition in arithmetic expressions, so does &lt;code&gt;AND&lt;/code&gt; take precedence over &lt;code&gt;OR&lt;/code&gt; in combined conditions. Use parenthesis to change this precedence, if necessary. For example:</source>
          <target state="translated">正如在算术表达式中乘法优先于加法一样 &lt;code&gt;AND&lt;/code&gt; 在组合条件下AND优先于 &lt;code&gt;OR&lt;/code&gt; 。如有必要，请使用括号更改此优先级。例如：</target>
        </trans-unit>
        <trans-unit id="69d7203c7ddac97c0f7dbb23cc2fe036c4f8c92f" translate="yes" xml:space="preserve">
          <source>Just as multiplication takes precedence over addition in arithmetic expressions, so does&lt;code&gt;AND&lt;/code&gt;take precedence over&lt;code&gt;OR&lt;/code&gt;in combined conditions. Use parenthesis to change this precedence, if necessary. For example:</source>
          <target state="translated">正如在算术表达式中乘法优先于加法一样 &lt;code&gt;AND&lt;/code&gt; 在组合条件下AND优先于 &lt;code&gt;OR&lt;/code&gt; 。如有必要，请使用括号更改此优先级。例如：</target>
        </trans-unit>
        <trans-unit id="7d13eab767d2368877889bd7045a0a16db421d69" translate="yes" xml:space="preserve">
          <source>Just because COBOL doesn&amp;rsquo;t traditionally support objects, classes, and the like doesn&amp;rsquo;t mean that its &quot;procedural&quot; approach to computing isn&amp;rsquo;t valuable &amp;mdash; after all, it runs 70% of the</source>
          <target state="translated">仅仅因为COBOL传统上不支持对象，类等并不意味着它的&amp;ldquo;过程式&amp;rdquo;计算方法就没有价值-毕竟，它运行了70％的</target>
        </trans-unit>
        <trans-unit id="d8c01857f89a36261130d305fde5b5812e5298f0" translate="yes" xml:space="preserve">
          <source>Just because COBOL doesn&amp;rsquo;t traditionally support objects, classes, and the like doesn&amp;rsquo;t mean that its &amp;ldquo;procedural&amp;rdquo; approach to computing isn&amp;rsquo;t valuable &amp;mdash; after all, it runs 70% of the</source>
          <target state="translated">仅仅因为COBOL传统上不支持对象，类等并不意味着它的&amp;ldquo;过程式&amp;rdquo;计算方法就没有价值-毕竟，它运行了70％的</target>
        </trans-unit>
        <trans-unit id="979a2652877865746b7247ec58a121d845b88ba1" translate="yes" xml:space="preserve">
          <source>Just because the table has one or more &lt;code&gt;KEY&lt;/code&gt; clauses doesn&amp;rsquo;t mean the data is actually</source>
          <target state="translated">仅仅因为表具有一个或多个 &lt;code&gt;KEY&lt;/code&gt; 子句并不意味着数据实际上是</target>
        </trans-unit>
        <trans-unit id="eab1ffaceb7e528d02f388bc4a44de1ac999f956" translate="yes" xml:space="preserve">
          <source>Just because the table has one or more&lt;code&gt;KEY&lt;/code&gt;clauses doesn&amp;rsquo;t mean the data is actually</source>
          <target state="translated">仅仅因为表具有一个或多个 &lt;code&gt;KEY&lt;/code&gt; 子句并不意味着数据实际上是</target>
        </trans-unit>
        <trans-unit id="5b5d12ea2ea365ae4f8ff7a7d00d39c0f6a22117" translate="yes" xml:space="preserve">
          <source>Justification (left, right or centred) of a string field</source>
          <target state="translated">字符串字段的对齐方式(左、右或居中)。</target>
        </trans-unit>
        <trans-unit id="c2d43141ba675c34b7c1d27c2a20a48306114ad6" translate="yes" xml:space="preserve">
          <source>Justifying a field left-, right- or center-aligned</source>
          <target state="translated">证明一个字段左、右或中间对齐的合理性</target>
        </trans-unit>
        <trans-unit id="84f38d3f20c7775e2217cde20dd53b4fca4c4de9" translate="yes" xml:space="preserve">
          <source>KEPT, KEY, KEYBOARD</source>
          <target state="translated">保持,钥匙,键盘。</target>
        </trans-unit>
        <trans-unit id="dff84808f4a83b06a0b8dc389f4ca84fd6e483a3" translate="yes" xml:space="preserve">
          <source>Key already exists</source>
          <target state="translated">钥匙已经存在</target>
        </trans-unit>
        <trans-unit id="92bd34b75e6ff630359dc24ce994bebb8b03c58a" translate="yes" xml:space="preserve">
          <source>Key boundary violation</source>
          <target state="translated">关键边界违规</target>
        </trans-unit>
        <trans-unit id="a1abb8bae6a20d6d2a3d297fadb85dbb06f153f7" translate="yes" xml:space="preserve">
          <source>Key invalid</source>
          <target state="translated">钥匙无效</target>
        </trans-unit>
        <trans-unit id="0dca24f2a9944795f9d4824194f21fc80ddaa094" translate="yes" xml:space="preserve">
          <source>Key not found</source>
          <target state="translated">未找到钥匙</target>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="6114979f0d6bbe96ece7032f3f733bd6eddb23b0" translate="yes" xml:space="preserve">
          <source>LABEL-OFFSET, LABEL, LARGE-FONT, LARGE-OFFSET, LAST-ROW, LAST, LAYOUT-DATA, LAYOUT-MANAGER, LC_ALL, LC_COLLATE, LC_CTYPE, LC_MESSAGES, LC_MONETARY, LC_NUMERIC, LC_TIME, LEADING-SHIFT, LEADING, LEFT-JUSTIFY, LEFTLINE, LEFT-TEXT, LEFT, LENGTH-AN, LENGTH-CHECK, LENGTH, LESS, LIMITS, LIMIT, LINAGE-COUNTER, LINAGE, LINE-COUNTER, LINES-AT-ROOT, LINE-SEQUENTIAL, LINES, LINE, LINKAGE, LIST-BOX, LM-RESIZE, LOCALE-COMPARE, LOCALE-DATE, LOCALE-TIME-FROM-SECONDS, LOCALE-TIME, LOCALE, LOCAL-STORAGE, LOCK, LOG10, LOG, LONG-DATE, LOW-COLOR, LOWER-CASE, LOWERED, LOWER, LOWEST-ALGEBRAIC, LOWLIGHT, LOW-VALUES, LOW-VALUE</source>
          <target state="translated">LABEL-OFFSET,LABEL,LARGE-FONT,LARGE-OFFSET,LAST-ROW,LAST,LAYOUT-DATA,LAYOUT-MANAGER,LC_ALL,LC_COLLATE,LC_CTYPE,LC_MESSAGES,LC_MONETARY,LC_NUMERIC,LC_TIME,LEADING-SHIFT,LEADING,LEFT-JUSTIFY,LEFTLINE,LEFT-TEXT,LEFT,LENGTH-AN,LENGTH-CHECK,LENGTH,LESS,LIMITS,LIMIT,LINAGE-COUNTER,LINAGE,LINE-COUNTER,LINES-AT-ROOT,LINE-SEQUENTIAL,LINES,LINE,LINKAGE,LIST-BOX,LM-RESIZE,LOCALE-COMPARE,LOCALE-DATE,LOCALE-TIME-FROM-SECONDS,LOCALE-TIME,LOCALE,LOCAL-STORAGE,LOCK,LOG10,LOG,LONG-DATE,LOW-COLOR,LOWER-CASE,LOWERED,LOWER,LOWEST-ALGEBRAIC,LOWLIGHT,LOW-VALUES,LOW-VALUE.</target>
        </trans-unit>
        <trans-unit id="b27d585a06f48010c011f378dec6cda9ce6fe385" translate="yes" xml:space="preserve">
          <source>LABEL. LAST, LC_ALL, LC_COLLATE, LC_CTYPE, LC_MESSAGES, LC_MONETARY, LC_NUMERIC, LC_TIME, LEADING, LEFT, LEFT-JUSTIFY, LEFTLINE, LENGTH, LENGTH-AN, LENGTH-CHECK, LESS, LIMIT, LIMITS, LINAGE, LINAGE-COUNTER, LINE, LINE-COUNTER, LINES, LINKAGE, LOCALE, LOCALE-COMPARE, LOCALE-DATE, LOCALE-TIME, LOCALE-TIME-FROM-SECONDS, LOCAL-STORAGE, LOCK, LOG, LOG10, LOWER, LOWER-CASE, LOWEST-ALGEBRAIC, LOWLIGHT, LOW-VALUE, LOW-VALUES</source>
          <target state="translated">标签:LAST,LC_ALL,LC_COLLATE,LC_CTYPE,LC_MESSAGES,LC_MONETARY,LC_NUMERIC,LC_TIME,LEADING,LEFT,LEFT-JUSTIFY,LEFTLINE,LENGTH,LENGTH-AN,LENGTH-CHECK,LESS,LIMIT,LIMITS,LINAGE,LINAGE-COUNTER,LINE,LINE-COUNTER,LINES,LINKAGE,LOCALE,LOCALE-COMPARE,LOCALE-DATE,LOCALE-TIME,LOCALE-TIME-ROM-SECONDS,LOCAL-STORAGE,LOCK,LOG,LOG10,LOWER,LOWER-CASE,LOWEST-ALGEBRAIC,LOWLIGHT,LOW-VALUE,LOW-VALUES。</target>
        </trans-unit>
        <trans-unit id="f7adab25c99ba32828c8334645ed0e592317c0dd" translate="yes" xml:space="preserve">
          <source>LEFTLINE Attribute Syntax</source>
          <target state="translated">LEFTLINE 属性 语法</target>
        </trans-unit>
        <trans-unit id="131342f51da66f70ac3d8ad3a42ad6266e7cfe09" translate="yes" xml:space="preserve">
          <source>LENGTH Function Syntax</source>
          <target state="translated">LENGTH 函数语法</target>
        </trans-unit>
        <trans-unit id="d74d405b72ac688357a94ddb91f3bd1d36b38a48" translate="yes" xml:space="preserve">
          <source>LENGTH OF Syntax</source>
          <target state="translated">语法长度</target>
        </trans-unit>
        <trans-unit id="a6c3bbbb104612f77a62807c2c1de5109220484e" translate="yes" xml:space="preserve">
          <source>LENGTH-AN Function Syntax</source>
          <target state="translated">LENGTH-AN 函数语法</target>
        </trans-unit>
        <trans-unit id="954f779688b59664bc2c0157a1a346f68764ce28" translate="yes" xml:space="preserve">
          <source>LENGTH-CHECK Attribute Syntax</source>
          <target state="translated">LENGTH-CHECK 属性 语法</target>
        </trans-unit>
        <trans-unit id="f4069c469e237582353fbcc1ca054bde5eb25517" translate="yes" xml:space="preserve">
          <source>LINAGE IS n LINES</source>
          <target state="translated">LINAGE IS n LINES</target>
        </trans-unit>
        <trans-unit id="700c1989f8b190ed7e6537ef207d774a560d050f" translate="yes" xml:space="preserve">
          <source>LINE (REPORT SECTION) Clause Syntax</source>
          <target state="translated">行(报告部分)子句语法</target>
        </trans-unit>
        <trans-unit id="e8f4389c48575a281e9f925b390e924cf0c4233d" translate="yes" xml:space="preserve">
          <source>LINE (SCREEN SECTION) Clause Syntax</source>
          <target state="translated">行(屏幕部分)子句语法</target>
        </trans-unit>
        <trans-unit id="7c6e6d7676fc26598c1022695002f33ef9cb1a7f" translate="yes" xml:space="preserve">
          <source>LINES AT BOTTOM</source>
          <target state="translated">底部的线</target>
        </trans-unit>
        <trans-unit id="2bb17bd344a3058733c23cfa10c4a15543c5a7a0" translate="yes" xml:space="preserve">
          <source>LINES AT TOP</source>
          <target state="translated">上方的线</target>
        </trans-unit>
        <trans-unit id="e4f2ff384d74fc8578647b7045a783150209d9b6" translate="yes" xml:space="preserve">
          <source>LINKAGE-SECTION-Data-Item</source>
          <target state="translated">LINKAGE-SECTION-Data-Item</target>
        </trans-unit>
        <trans-unit id="6c615d91fc665579223c013c286410416b6e1014" translate="yes" xml:space="preserve">
          <source>LINKAGE-SECTION-Data-Item Syntax</source>
          <target state="translated">链接-部分-数据-项目 语法</target>
        </trans-unit>
        <trans-unit id="de80fa7cc22fe7bc720ec1f880b19a375e416fad" translate="yes" xml:space="preserve">
          <source>LOCAL-STORAGE-SECTION-Data-Item</source>
          <target state="translated">LOCAL-STORAGE-SECTION-Data-Item</target>
        </trans-unit>
        <trans-unit id="7aaab284fb19784decbd8f8b27788cee676e6312" translate="yes" xml:space="preserve">
          <source>LOCAL-STORAGE-SECTION-Data-Item Syntax</source>
          <target state="translated">LOCAL-STORAGE-SECTION-Data-Item 语法</target>
        </trans-unit>
        <trans-unit id="43137ffee30418f0ee2f9cddfdfde852be8ee37f" translate="yes" xml:space="preserve">
          <source>LOCALE-COMPARE Function Syntax</source>
          <target state="translated">LOCALE-COMPARE 函数语法</target>
        </trans-unit>
        <trans-unit id="b1fca96794478203376fc5f182a5206a1cd9879a" translate="yes" xml:space="preserve">
          <source>LOCALE-DATE Function Syntax</source>
          <target state="translated">LOCALE-DATE 函数语法</target>
        </trans-unit>
        <trans-unit id="bb3ee280b5397e14e50725a5217c3a5d3ba477ce" translate="yes" xml:space="preserve">
          <source>LOCALE-TIME Function Syntax</source>
          <target state="translated">LOCALE-TIME 函数语法</target>
        </trans-unit>
        <trans-unit id="5471c4a61062a5428ab007db0990af8c067fcb5d" translate="yes" xml:space="preserve">
          <source>LOCALE-TIME-FROM-SECONDS Function Syntax</source>
          <target state="translated">LOCALE-TIME-FROM-SECONDS 函数语法</target>
        </trans-unit>
        <trans-unit id="37c5bf8af77ce9710567f4d33ea9e7df839040cc" translate="yes" xml:space="preserve">
          <source>LOG Function Syntax</source>
          <target state="translated">LOG 功能描述</target>
        </trans-unit>
        <trans-unit id="9192c8decf1f9c720375df3f6fa03e112ff20e88" translate="yes" xml:space="preserve">
          <source>LOG10 Function Syntax</source>
          <target state="translated">LOG10 功能语法</target>
        </trans-unit>
        <trans-unit id="ee7e6e2ad53ef8f056736d307514898fdd404c69" translate="yes" xml:space="preserve">
          <source>LOWER-CASE Function Syntax</source>
          <target state="translated">LOWER-CASE 函数语法</target>
        </trans-unit>
        <trans-unit id="439e85988349d2d4d56bcd162fc79031cbfe5293" translate="yes" xml:space="preserve">
          <source>LOWEST-ALGEBRAIC Function Syntax</source>
          <target state="translated">LOWEST-ALGEBRAIC 函数语法</target>
        </trans-unit>
        <trans-unit id="a8456caa490bee9c2c0be989a83696a4f186cc13" translate="yes" xml:space="preserve">
          <source>LOWLIGHT Attribute Syntax</source>
          <target state="translated">LOWLIGHT 属性语法</target>
        </trans-unit>
        <trans-unit id="ab9f0a91ded19b860a0bb2aa383c74029ea96c55" translate="yes" xml:space="preserve">
          <source>Language &lt;code&gt;DIVISION&lt;/code&gt;, &lt;code&gt;SECTION&lt;/code&gt; and paragraph section headers must b egin in Area A, as must the level numbers 01, 77 in data description entries and the &lt;code&gt;FD&lt;/code&gt; and &lt;code&gt;SD&lt;/code&gt; file and &lt;code&gt;SORT&lt;/code&gt; description headers.</source>
          <target state="translated">语言 &lt;code&gt;DIVISION&lt;/code&gt; ， &lt;code&gt;SECTION&lt;/code&gt; 和段落部分标题必须位于区域A中，数据描述条目以及 &lt;code&gt;FD&lt;/code&gt; 和 &lt;code&gt;SD&lt;/code&gt; 文件以及 &lt;code&gt;SORT&lt;/code&gt; 描述标题中的级别编号01、77也必须如此。</target>
        </trans-unit>
        <trans-unit id="b77f5ed95a31f852095a500e8931cb13a5b9471b" translate="yes" xml:space="preserve">
          <source>Language DIVISION, SECTION and paragraph section headers must begin in Area A, as must the level numbers 01, 77 in data description entries and the &quot;FD&quot; and &quot;SD&quot; file and SORT description headers.</source>
          <target state="translated">语文的DIVISION、SECTION和段落部分的标题必须从A区开始,数据描述条目中的等级号01、77以及 &quot;FD &quot;和 &quot;SD &quot;文件和SORT描述标题也必须如此。</target>
        </trans-unit>
        <trans-unit id="1882dc6a1967f34bbac58b9f9a979e4a9b63398b" translate="yes" xml:space="preserve">
          <source>Later, when you wish to compile a calling program and combine any needed assembly language subroutines in (as static subroutines &amp;mdash; see &lt;a href=&quot;#Dynamic-vs-Static-Subprograms&quot;&gt;Dynamic vs Static Subprograms&lt;/a&gt;), use a command such as this:</source>
          <target state="translated">以后，当您希望编译一个调用程序并在其中组合任何所需的汇编语言子例程（作为静态子例程，请参见&lt;a href=&quot;#Dynamic-vs-Static-Subprograms&quot;&gt;动态与静态子程序&lt;/a&gt;）时，请使用如下命令：</target>
        </trans-unit>
        <trans-unit id="66985c4b56238cdffd3d626011e0ae9656911e65" translate="yes" xml:space="preserve">
          <source>Leading and/or trailing spaces are allowed, as are spaces before and/or after any sign characters.</source>
          <target state="translated">允许有前导和/或尾部空格,也允许在任何符号字符之前和/或之后有空格。</target>
        </trans-unit>
        <trans-unit id="0ff8a66126e2608d00693ba8dd0efcf5b6c8473c" translate="yes" xml:space="preserve">
          <source>Leading and/or trailing spaces are allowed, as are spaces before and/or after the currency symbol, sign, CR and DB characters.</source>
          <target state="translated">允许有前导和/或尾部空格,货币符号、符号、CR和DB字符之前和/或之后也允许有空格。</target>
        </trans-unit>
        <trans-unit id="13235fcc87f3e6e8669414dd697a803db485fc34" translate="yes" xml:space="preserve">
          <source>Leading and/or trailing spaces are allowed, as are spaces before and/or after the sign, CR and DB characters.</source>
          <target state="translated">允许有前导和/或尾部空格,也允许在符号、CR和DB字符前和/或后有空格。</target>
        </trans-unit>
        <trans-unit id="d8c6e1dcd78cbde53dbfb5d9de88b738224cdda7" translate="yes" xml:space="preserve">
          <source>Leading and/or trailing spaces are allowed, as are spaces before the first digit.</source>
          <target state="translated">允许有前导和/或尾部的空格,第一个数字前的空格也是允许的。</target>
        </trans-unit>
        <trans-unit id="4a73716efd725dd69ed96a4ea0bb80f513d3861e" translate="yes" xml:space="preserve">
          <source>Left Dbl Click</source>
          <target state="translated">左侧Dbl点击</target>
        </trans-unit>
        <trans-unit id="88fb5a06f570b6e81cc3331af90bb5ea437de3f2" translate="yes" xml:space="preserve">
          <source>Left Pressed</source>
          <target state="translated">左压式</target>
        </trans-unit>
        <trans-unit id="cd690f11442f85e3110b4a63bf12f94127c762cc" translate="yes" xml:space="preserve">
          <source>Left Released</source>
          <target state="translated">左侧获释</target>
        </trans-unit>
        <trans-unit id="6d1192545a490f725efd7534bb1ad77133927978" translate="yes" xml:space="preserve">
          <source>Legend has it that there&amp;rsquo;s actually only been ONE program ever written in COBOL, and all programs ever &quot;written&quot; thereafter were simply derivatives of that one. Although this is clearly intended as a (probably) bad joke, it is nevertheless close to the very simple truth that many programmers&quot;reuse&quot; existing COBOL programs when creating new ones. There&amp;rsquo;s certainly nothing preventing this from happening with programs written in other languages, but it does seem to happen more in COBOL shops. It&amp;rsquo;s ironic that &quot;code re-usability&quot; is one of the arguments used to justify the existence of the &quot;modern&quot; languages.</source>
          <target state="translated">传说它实际上只有一个用COBOL编写的程序，此后所有&amp;ldquo;编写&amp;rdquo;的程序仅仅是该程序的派生。尽管这显然是一个（可能）恶作剧，但它非常接近一个非常简单的事实，即许多程序员在创建新程序时会&amp;ldquo;重用&amp;rdquo;现有的COBOL程序。用其他语言编写的程序当然不能阻止这种情况的发生，但是在COBOL商店中似乎确实会发生这种情况。具有讽刺意味的是，&amp;ldquo;代码可重用性&amp;rdquo;是用来证明&amp;ldquo;现代&amp;rdquo;语言存在的理由之一。</target>
        </trans-unit>
        <trans-unit id="9c975edbd71a157d47b1d648200e63954dd79c0f" translate="yes" xml:space="preserve">
          <source>Legend has it that there&amp;rsquo;s actually only been ONE program ever written in COBOL, and all programs ever &amp;ldquo;written&amp;rdquo; thereafter were simply derivatives of that one. Although this is clearly intended as a (probably) bad joke, it is nevertheless close to the very simple truth that many programmers&amp;ldquo;reuse&amp;rdquo; existing COBOL programs when creating new ones. There&amp;rsquo;s certainly nothing preventing this from happening with programs written in other languages, but it does seem to happen more in COBOL shops. It&amp;rsquo;s ironic that &amp;ldquo;code re-usability&amp;rdquo; is one of the arguments used to justify the existence of the &amp;ldquo;modern&amp;rdquo; languages.</source>
          <target state="translated">传说它实际上只有一个用COBOL编写的程序，此后所有&amp;ldquo;编写&amp;rdquo;的程序仅仅是该程序的派生。尽管这显然是在（可能）是一个恶作剧，但它非常接近一个非常简单的事实，即许多程序员在创建新程序时会&amp;ldquo;重用&amp;rdquo;现有的COBOL程序。用其他语言编写的程序当然不能阻止这种情况的发生，但是在COBOL商店中似乎确实会发生这种情况。具有讽刺意味的是，&amp;ldquo;代码可重用性&amp;rdquo;是用来证明&amp;ldquo;现代&amp;rdquo;语言存在的理由之一。</target>
        </trans-unit>
        <trans-unit id="0b3fb64877d0da3cc80aa54b2402a8b8eaf24bde" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a different problem. Surely a program that asks a user to input a positive integer, generates the sum of all positive integers from 1 to that number and then prints the result will be MUCH shorter and MUCH easier to understand when coded in Java than in COBOL, right?</source>
          <target state="translated">让我们看一个不同的问题。当然，要求用户输入一个正整数，生成从1到该数字的所有正整数之和，然后打印结果的程序将比使用COBOL用Java编码的时候短很多并且更容易理解，对吧？</target>
        </trans-unit>
        <trans-unit id="26e5808de92654f265239c37c8e3bd7a273163fd" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at how much more &quot;wordy&quot; COBOL is than Java. Count the characters in the two programs. The Java program has 95 (not counting carriage returns and any indentation). The COBOL program has 89 (again, not counting carriage returns and indentation)! Technically, it could have been only 65 because the&lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt;header is actually optional. Clearly, &quot;Hello World&quot; doesn&amp;rsquo;t look any more concise in Java than it does in COBOL.</source>
          <target state="translated">让我们看一下&amp;ldquo;罗y&amp;rdquo;的COBOL比Java多得多。计算两个程序中的字符。Java程序有95（不计算回车符和任何缩进）。COBOL程序有89个（再次，不算回车和缩进）！从技术上讲，由于 &lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt; 原因，它本来只能是65 。标头实际上是可选的。显然，Java中的&amp;ldquo; Hello World&amp;rdquo;看起来比COBOL中的简洁得多。</target>
        </trans-unit>
        <trans-unit id="fce67368220fd5d1a069d467b1d821a9f6cc0caf" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at how much more &amp;ldquo;wordy&amp;rdquo; COBOL is than Java. Count the characters in the two programs. The Java program has 95 (not counting carriage returns and any indentation). The COBOL program has 89 (again, not counting carriage returns and indentation)! Technically, it could have been only 65 because the &lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt; header is actually optional. Clearly, &amp;ldquo;Hello World&amp;rdquo; doesn&amp;rsquo;t look any more concise in Java than it does in COBOL.</source>
          <target state="translated">让我们看一下&amp;ldquo;罗y&amp;rdquo;的COBOL比Java多得多。计算两个程序中的字符。Java程序有95（不计算回车符和任何缩进）。COBOL程序有89个（再次，不算回车和缩进）！从技术上讲，由于 &lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt; 原因，它本来只能是65 。标头实际上是可选的。显然，Java中的&amp;ldquo; Hello World&amp;rdquo;看起来不比COBOL中的简洁。</target>
        </trans-unit>
        <trans-unit id="963bbbacb61f8751db91170e221a486a9a4d3b42" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say the 3x4 &quot;grid&quot; defined by the above structure has these values:</source>
          <target state="translated">假设上述结构定义的3x4&amp;ldquo;网格&amp;rdquo;具有以下值：</target>
        </trans-unit>
        <trans-unit id="5974d6c322da30f80987e1170616d04027e9daef" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say the 3x4 &amp;ldquo;grid&amp;rdquo; defined by the above structure has these values:</source>
          <target state="translated">假设上述结构定义的3x4&amp;ldquo;网格&amp;rdquo;具有以下值：</target>
        </trans-unit>
        <trans-unit id="5f6c75fa3581f1fe3d845277eaa7b25f5ef95342" translate="yes" xml:space="preserve">
          <source>Level 1 (Highest) &amp;mdash; Unary Sign Specification (&lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; with a single argument)</source>
          <target state="translated">级别1（最高）&amp;mdash;一元符号规范（带有单个参数的 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="807ef358de181fc6f5a56bc69f36677531a8d93e" translate="yes" xml:space="preserve">
          <source>Level 1 (Highest) &amp;mdash; Unary Sign Specification &lt;code&gt;+&lt;/code&gt;and&lt;code&gt;-&lt;/code&gt;with a single argument)</source>
          <target state="translated">级别1（最高）&amp;mdash;一元符号规范 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt; (带单个参数）</target>
        </trans-unit>
        <trans-unit id="c1fb74ac0d874a2011af4ed300de85b0a379c044" translate="yes" xml:space="preserve">
          <source>Level 2 &amp;mdash; Exponentiation (&lt;code&gt;**&lt;/code&gt; or &lt;code&gt;^&lt;/code&gt;)</source>
          <target state="translated">级别2 &amp;mdash;求幂（ &lt;code&gt;**&lt;/code&gt; 或 &lt;code&gt;^&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="c0776e45f0a30777bc589139ec70ff962e33c83c" translate="yes" xml:space="preserve">
          <source>Level 2 &amp;mdash; Exponentiation &lt;code&gt;**&lt;/code&gt;or&lt;code&gt;^&lt;/code&gt;</source>
          <target state="translated">2级-指数 &lt;code&gt;**&lt;/code&gt; 或 &lt;code&gt;^&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19f33b8f84b6acbf527317823b1dc97071f87bb0" translate="yes" xml:space="preserve">
          <source>Level 3 &amp;mdash; Multiplication (&lt;code&gt;*&lt;/code&gt;) and division (&lt;code&gt;/&lt;/code&gt;)</source>
          <target state="translated">级别3 &amp;mdash;乘法（ &lt;code&gt;*&lt;/code&gt; ）和除法（ &lt;code&gt;/&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="b6d3eb2924374b17ead104f2e6704337373d534b" translate="yes" xml:space="preserve">
          <source>Level 3 &amp;mdash; Multiplication &lt;code&gt;*&lt;/code&gt; and division &lt;code&gt;/&lt;/code&gt;</source>
          <target state="translated">第3级-乘法 &lt;code&gt;*&lt;/code&gt; 和除法 &lt;code&gt;/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ff1bbf028b1676dcbed5efec78712eec2eec2f1" translate="yes" xml:space="preserve">
          <source>Level 4 &amp;mdash; Addition (&lt;code&gt;+&lt;/code&gt;) or subtraction (&lt;code&gt;+&lt;/code&gt;)</source>
          <target state="translated">级别4 &amp;mdash;加（ &lt;code&gt;+&lt;/code&gt; ）或减（ &lt;code&gt;+&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="76c7a53b8aaf3b4d3d4c40f9ab98b835416a16f8" translate="yes" xml:space="preserve">
          <source>Level 4 &amp;mdash; Addition &lt;code&gt;+&lt;/code&gt; or subtraction &lt;code&gt;+&lt;/code&gt;</source>
          <target state="translated">等级4 -加 &lt;code&gt;+&lt;/code&gt; 或减法 &lt;code&gt;+&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5597f96dc9d80c27ec5e33857991562ca948cabc" translate="yes" xml:space="preserve">
          <source>Level Number</source>
          <target state="translated">级别数</target>
        </trans-unit>
        <trans-unit id="3052fa9dd47259fbdfdaada2330b8f6e3cbdd9ac" translate="yes" xml:space="preserve">
          <source>Level numbers 66, 77, 78 and 88 all have special uses &amp;mdash; See &lt;a href=&quot;#Special-Data-Items&quot;&gt;Special Data Items&lt;/a&gt;, for details.</source>
          <target state="translated">级别66、77、78和88都有特殊用途-有关详细信息，请参见&lt;a href=&quot;#Special-Data-Items&quot;&gt;特殊数据项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c40b4c76be763282435e76a210c233701e5f2f23" translate="yes" xml:space="preserve">
          <source>Level numbers 66, 77, 78 and 88 identify special properties of a data description entry.</source>
          <target state="translated">等级号66、77、78和88标识数据描述条目的特殊属性。</target>
        </trans-unit>
        <trans-unit id="f058b290679bb97e2e65e2ade8e908cf0471986c" translate="yes" xml:space="preserve">
          <source>Level numbers in the range 1 through 49 indicate the position of a data item in the hierarchical structure of a logical record. Level numbers in the range 1 through 9 can be written either as a single digit or as a zero followed by the significant digit.</source>
          <target state="translated">1至49范围内的级别号表示数据项在逻辑记录的层次结构中的位置。1至9范围内的级数既可以写成一个数字,也可以写成一个零,然后再写上重要的数字。</target>
        </trans-unit>
        <trans-unit id="0d0db8c2b020268e4b2e48ddcbb42e59195d905a" translate="yes" xml:space="preserve">
          <source>Licensed under the GNU Free Documentation License.</source>
          <target state="translated">以GNU自由文档许可证授权。</target>
        </trans-unit>
        <trans-unit id="1c7be671b82e536f670976ec80f415fa5dd43afc" translate="yes" xml:space="preserve">
          <source>Like line sequential files, these files should not be defined to contain any exact binary data fields because the contents of those fields could inadvertently have the end-of-record sequence as part of their values &amp;mdash; this would confuse the runtime system when reading the file, and it would interpret that value as an actual end-of-record sequence.</source>
          <target state="translated">像行顺序文件一样，不应将这些文件定义为包含任何确切的二进制数据字段，因为这些字段的内容可能会无意中将记录结束序列作为其值的一部分&amp;mdash;这会在读取文件时混淆运行时系统，它将将该值解释为实际的记录结束序列。</target>
        </trans-unit>
        <trans-unit id="57489ee4e43a2ed5c736dd719377be4582a70ea3" translate="yes" xml:space="preserve">
          <source>Like most other implementations of the COBOL language, GnuCOBOL utilizes a run-time library. When the first program executed in a given execution sequence is a GnuCOBOL program, any run-time library initialization will be performed by the compiled COBOL code in a manner that is transparent to the C-language programmer. If, however, a C program is the first to execute, the burden of performing GnuCOBOL run-time library initialization falls upon the C program. See &lt;a href=&quot;#C-Main-Programs-Calling-GnuCOBOL-Subprograms&quot;&gt;C Main Programs Calling GnuCOBOL Subprograms&lt;/a&gt;, for an example of how to do this.</source>
          <target state="translated">像大多数其他COBOL语言实现一样，GnuCOBOL也使用运行时库。当以给定的执行顺序执行的第一个程序是GnuCOBOL程序时，任何运行时库初始化都将由已编译的COBOL代码以对C语言程序员透明的方式执行。但是，如果首先执行C程序，则执行GnuCOBOL运行时库初始化的负担将落在C程序上。有关如何执行此操作的示例，请参见&lt;a href=&quot;#C-Main-Programs-Calling-GnuCOBOL-Subprograms&quot;&gt;C主程序调用GnuCOBOL子程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="57fb879374ae97e5eb278f255c02c63fea22e809" translate="yes" xml:space="preserve">
          <source>Line Sequential files are processed using the following statements:</source>
          <target state="translated">行顺序文件使用以下语句处理。</target>
        </trans-unit>
        <trans-unit id="705ab24e9e88484bd36a188c2786c37738960962" translate="yes" xml:space="preserve">
          <source>Line number beyond which nothing may be printed except for any footing that is to appear on every page. The default for this if not specified is zero, meaning there will be no footings. This value cannot be larger than the &lt;code&gt;LINAGE IS &lt;var&gt;n&lt;/var&gt; LINES&lt;/code&gt; value.</source>
          <target state="translated">行号，除了在每页上显示的任何基脚之外，什么都不能打印。如果未指定，则默认值为零，这意味着将没有立足点。该值不能大于 &lt;code&gt;LINAGE IS &lt;var&gt;n&lt;/var&gt; LINES&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="92e97e035f44f8980e413b0d3167603ea36902ee" translate="yes" xml:space="preserve">
          <source>Literal</source>
          <target state="translated">Literal</target>
        </trans-unit>
        <trans-unit id="0f04cc81bf496e196dc1ead869612937cb48371b" translate="yes" xml:space="preserve">
          <source>Literals are constant values that will not change during the execution of a program. There are two fundamental types of literals &amp;mdash; numeric and alphanumeric.</source>
          <target state="translated">文字是在程序执行期间不会更改的常量值。文字有两种基本类型-数字和字母数字。</target>
        </trans-unit>
        <trans-unit id="44ac976e13987b2e461319b6b07bf2f1d2977574" translate="yes" xml:space="preserve">
          <source>Little-Endian</source>
          <target state="translated">Little-Endian</target>
        </trans-unit>
        <trans-unit id="226d589b5f25caf9198d123daff4d9daae8eba87" translate="yes" xml:space="preserve">
          <source>Little-endian data allocation calls for the bytes that comprise a binary item to be allocated such that the least-significant byte is the left-most byte. For example, a four-byte binary item having a value of decimal 20 would be little-endian allocated as 14000000 (shown in hexadecimal notation).</source>
          <target state="translated">小恩典数据分配要求对组成二进制项的字节进行分配,使最不重要的字节成为最左边的字节。例如,一个值为十进制20的四字节二进制项目将被小恩典分配为14000000(用十六进制符号表示)。</target>
        </trans-unit>
        <trans-unit id="835de5c115f7b3e75f88f1bf5d8aaf4ad47e0bd8" translate="yes" xml:space="preserve">
          <source>Local-storage cannot be used in nested subprograms.</source>
          <target state="translated">本地存储不能用于嵌套的子程序中。</target>
        </trans-unit>
        <trans-unit id="a5e093ebdd409890bed85c2fed42792048e3ee67" translate="yes" xml:space="preserve">
          <source>Local-storage, if any, is de-allocated.</source>
          <target state="translated">本地存储,如果有的话,将被取消分配。</target>
        </trans-unit>
        <trans-unit id="3690da6677c866b7070485f97c20dfa1fc2058b7" translate="yes" xml:space="preserve">
          <source>Local-storage, if any, will be allocated and initialized.</source>
          <target state="translated">本地存储,如果有的话,将被分配和初始化。</target>
        </trans-unit>
        <trans-unit id="029c39972ba6042647e3f70b02f4bd91260e9fb3" translate="yes" xml:space="preserve">
          <source>Locator</source>
          <target state="translated">Locator</target>
        </trans-unit>
        <trans-unit id="8d02c4cdcb2b9946ab2619bfecc5df1af1b12a02" translate="yes" xml:space="preserve">
          <source>Locks acquired vie multiple record locking remain in-effect until the program holding the lock&amp;hellip;</source>
          <target state="translated">通过多条记录锁定获取的锁定将保持有效，直到持有该锁定的程序&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="256b0211cd7dcbaef103250b00102fed3e6e0d1e" translate="yes" xml:space="preserve">
          <source>M.cbl</source>
          <target state="translated">M.cbl</target>
        </trans-unit>
        <trans-unit id="fc3ab2432b8c18e9520aae59030cc15f96a27da9" translate="yes" xml:space="preserve">
          <source>MAGNETIC-TAPE, MANUAL, MASS-UPDATE, MAX-LINES, MAX-PROGRESS, MAX-TEXT, MAX-VAL, MAX, MEAN, MEDIAN, MEDIUM-FONT, MEMORY, MENU, MERGE, MESSAGE, METHOD-ID, METHOD, MIDRANGE, MINUS, MIN-VAL, MIN, MODE, MODIFY, MODULE-CALLER-ID, MODULE-DATE, MODULE-FORMATTED-DATE, MODULE-ID, MODULE-PATH, MODULE-SOURCE, MODULES, MODULE-TIME, MOD, MONETARY-DECIMAL-POINT, MONETARY-THOUSANDS-SEPARATOR, MOVE, MULTILINE, MULTIPLE, MULTIPLY</source>
          <target state="translated">MAGNETIC-TAPE,MANUAL,MASS-UPDATE,MAX-LINES,MAX-PROGRESS,MAX-TEXT,MAX-VAL,MAX,MEAN,MEDIAN,MEDIUM-FONT,MEMORY,MENU,MERGE,MESSAGE,METHOD-ID,METHOD,MIDRANGE,MINUS,MIN-VAL,MIN,MODE,MODIFY,MODULE-CALLER-ID,MODULE-DATE,MODULE-FORMATTED-DATE,MODULE-ID,MODULE-PATH,MODULE-SOURCE,MODULES,MODULE-TIME,MOD,MONETARY-DECIMAL-POINT,MONETARY-THOUSANDS-SEPARATOR,MOVE,MULTILINE,MULTIPLE,MULTIPLY。</target>
        </trans-unit>
        <trans-unit id="be9a3c255cc059f59d89184276ee44ce2ff74a47" translate="yes" xml:space="preserve">
          <source>MAGNETIC-TAPE, MANUAL, MAX, MEAN, MEDIAN, MEMORY, MERGE, MESSAGE, METHOD, METHOD-ID, MIDRANGE, MIN, MINUS, MOD, MODE, MODULE-CALLER-ID, MODULE-DATE, MODULE-FORMATTED-DATE, MODULE-ID, MODULE-PATH, MODULES, MODULE-SOURCE, MODULE-TIME, MONETARY-DECIMAL-POINT, MONETARY-THOUSANDS-SEPARATOR, MOVE, MULTIPLE, MULTIPLY</source>
          <target state="translated">MAGNETIC-TAPE,MANUAL,MAX,MEAN,MEDIAN,MEMORY,MERGE,MESSAGE,METHOD,METHOD-ID,MIDRANGE,MIN,MINUS,MOD,MODE,MODULE-CALLER-ID,MODULE-DATE,MODULE-FORMATTED-DATE,MODULE-ID,MODULE-ID,MODULE-PATH,MODULES,MODULE-SOURCE,MODULE-TIME,MONETARY-DECIMAL-POINT,MONETARY-THOUSANDS-SEPARATOR,MOVE,MULTIPLE,MULTIPLY。</target>
        </trans-unit>
        <trans-unit id="57e71373c55e995e80f24e3f2087d0a7b5dbbec9" translate="yes" xml:space="preserve">
          <source>MAX Function Syntax</source>
          <target state="translated">MAX 函数语法</target>
        </trans-unit>
        <trans-unit id="0abf13bfa8b362e60f0cf8bd2bacaab30d7f67c9" translate="yes" xml:space="preserve">
          <source>MEAN Function Syntax</source>
          <target state="translated">MEAN 函数语法</target>
        </trans-unit>
        <trans-unit id="31a496c910f49ef35450cbdb8cbc4374b9f67273" translate="yes" xml:space="preserve">
          <source>MEDIAN Function Syntax</source>
          <target state="translated">MEDIAN 函数语法</target>
        </trans-unit>
        <trans-unit id="daee7fdd946c270a9b400d0cb5b7e42fe5872e0c" translate="yes" xml:space="preserve">
          <source>MERGE Syntax</source>
          <target state="translated">MERGE 语法</target>
        </trans-unit>
        <trans-unit id="c8035dd19f4b057f89b85a604ee1af37d346e31e" translate="yes" xml:space="preserve">
          <source>MIDRANGE Function Syntax</source>
          <target state="translated">MIDRANGE 函数语法</target>
        </trans-unit>
        <trans-unit id="b3922fba0ffbf0d82c96e71393fb62e945ccf5b9" translate="yes" xml:space="preserve">
          <source>MIN Function Syntax</source>
          <target state="translated">MIN 函数语法</target>
        </trans-unit>
        <trans-unit id="6df76c53746f58160bf9ed45943e438821905bb2" translate="yes" xml:space="preserve">
          <source>MOD Function Syntax</source>
          <target state="translated">MOD功能语法</target>
        </trans-unit>
        <trans-unit id="fb9072e5497502c8b0c9f0cc92c12083bdb2cecc" translate="yes" xml:space="preserve">
          <source>MODULE-CALLER-ID Function Syntax</source>
          <target state="translated">MODULE-CALLER-ID 函数语法</target>
        </trans-unit>
        <trans-unit id="77023dbd5e71addbd6ecdf7b0de7955c05a7cbcc" translate="yes" xml:space="preserve">
          <source>MODULE-DATE Function Syntax</source>
          <target state="translated">MODULE-DATE 函数语法</target>
        </trans-unit>
        <trans-unit id="e4f1aeb1a72fe45f289846eea035900277d6474e" translate="yes" xml:space="preserve">
          <source>MODULE-FORMATTED-DATE Function Syntax</source>
          <target state="translated">MODULE-FORMATTED-DATE 函数语法</target>
        </trans-unit>
        <trans-unit id="e4708a13b25aed7fbcdde2ed7eb4f478e4e5a0d2" translate="yes" xml:space="preserve">
          <source>MODULE-ID Function Syntax</source>
          <target state="translated">MODULE-ID 功能描述</target>
        </trans-unit>
        <trans-unit id="9c157b8be74a13e0253ff0fdbcddcca6237613e4" translate="yes" xml:space="preserve">
          <source>MODULE-PATH Function Syntax</source>
          <target state="translated">MODULE-PATH 函数语法</target>
        </trans-unit>
        <trans-unit id="6aeac5d8bb6edf96b2cc15b2e1900d618339fe87" translate="yes" xml:space="preserve">
          <source>MODULE-SOURCE Function Syntax</source>
          <target state="translated">MODULE-SOURCE 功能描述</target>
        </trans-unit>
        <trans-unit id="9ba6dae63e2adfd381389ee805e05d8f98957c6a" translate="yes" xml:space="preserve">
          <source>MODULE-TIME Function Syntax</source>
          <target state="translated">MODULE-TIME 功能描述</target>
        </trans-unit>
        <trans-unit id="f73ead11798a2b39d355bdb9cc3ee0afd6c73ca2" translate="yes" xml:space="preserve">
          <source>MONETARY-DECIMAL-POINT Function Syntax</source>
          <target state="translated">货币-小数-点函数语法</target>
        </trans-unit>
        <trans-unit id="f959bf7a22a6fa8fd96fe2dd391a08fa5dd22aa0" translate="yes" xml:space="preserve">
          <source>MONETARY-THOUSANDS-SEPARATOR Function Syntax</source>
          <target state="translated">货币--单位--分离器 函数语法</target>
        </trans-unit>
        <trans-unit id="ec0648f1ef8e6f8e156101c88dcd2b9563d62924" translate="yes" xml:space="preserve">
          <source>MOVE CORRESPONDING Syntax</source>
          <target state="translated">MOVE CORRESPONDING 命令格式</target>
        </trans-unit>
        <trans-unit id="569fe924e80927234226e1da480e2aaeb896476b" translate="yes" xml:space="preserve">
          <source>MULTIPLY BY Syntax</source>
          <target state="translated">MULTIPLY BY 语法</target>
        </trans-unit>
        <trans-unit id="3ad347c2697684ef0953e3a767d0bc1635d31d5a" translate="yes" xml:space="preserve">
          <source>MULTIPLY GIVING Syntax</source>
          <target state="translated">MULTIPLY GIVING 语法</target>
        </trans-unit>
        <trans-unit id="412299ff020a7154d245c3b0f04152fc824d367f" translate="yes" xml:space="preserve">
          <source>Magenta: COB-COLOR-MAGENTA</source>
          <target state="translated">洋红色:COB-COLOR-MAGENTA。</target>
        </trans-unit>
        <trans-unit id="4ad990da0619f2f6612747fd3b18ae051e2e5eca" translate="yes" xml:space="preserve">
          <source>Main Program</source>
          <target state="translated">主程序</target>
        </trans-unit>
        <trans-unit id="62df8b8e9bbaa8bb9f1517aa2bf38f13fc37e36a" translate="yes" xml:space="preserve">
          <source>Main program</source>
          <target state="translated">主程序</target>
        </trans-unit>
        <trans-unit id="154c8bfc5f3e601547791b40d3a205f6ed780b67" translate="yes" xml:space="preserve">
          <source>Main programs compiled in this manner should be executed as follows:</source>
          <target state="translated">以这种方式编译的主程序应按以下方式执行。</target>
        </trans-unit>
        <trans-unit id="ad9766c462696f99f3025a340a18914544b7bff9" translate="yes" xml:space="preserve">
          <source>Main programs that wish to &quot;pass back&quot; a return code value to the operating system when they exit do not use RETURNING - they do so simply by MOVEing a value to the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register.</source>
          <target state="translated">希望在退出时将返回码值&amp;ldquo;回传&amp;rdquo;到操作系统的主程序不使用RETURNING，而是通过将值移到 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器中来简单地做到这一点。</target>
        </trans-unit>
        <trans-unit id="0cb2ae133e90657ae54e6ab6a5c15f115ac565ee" translate="yes" xml:space="preserve">
          <source>Main programs that wish to &amp;ldquo;pass back&amp;rdquo; a return code value to the operating system when they exit do not use &lt;code&gt;RETURNING&lt;/code&gt; - they do so simply by MOVEing a value to the &lt;code&gt;RETURN-CODE&lt;/code&gt; special register.</source>
          <target state="translated">主要程序，希望&amp;ldquo;回传&amp;rdquo;返回码值到操作系统时，他们退出不使用 &lt;code&gt;RETURNING&lt;/code&gt; -他们这样做只是通过MOVEing一个值 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器。</target>
        </trans-unit>
        <trans-unit id="7a5053f6a0e7ffe3e98db384f4662350eb992d81" translate="yes" xml:space="preserve">
          <source>Management of areas on the printed page such as top-of page headers, bottom-of-page footers, dealing with &quot;full page&quot; situations and the like are now the joint responsibility of the programmer and the GnuCOBOL run-time library, which provides tools such as the&lt;code&gt;LINAGE-COUNTER&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) and the&lt;code&gt;END-OF-PAGE&lt;/code&gt;</source>
          <target state="translated">现在，程序员和GnuCOBOL运行时库共同负责管理打印页面上的区域，例如页面顶部的页眉，页面底部的页脚，处理&amp;ldquo;整页&amp;rdquo;情况等。诸如 &lt;code&gt;LINAGE-COUNTER&lt;/code&gt; 特殊寄存器（请参阅&lt;a href=&quot;#Special-Registers&quot;&gt;特殊寄存器&lt;/a&gt;）和 &lt;code&gt;END-OF-PAGE&lt;/code&gt; 之类的工具</target>
        </trans-unit>
        <trans-unit id="535d01a3bb7e25e935da4ad3d0028806321932cc" translate="yes" xml:space="preserve">
          <source>Management of areas on the printed page such as top-of page headers, bottom-of-page footers, dealing with &quot;full page&quot; situations and the like are the complete responsibility of the programmer.</source>
          <target state="translated">管理印刷页面上的区域,如页眉、页脚、处理 &quot;整页 &quot;等情况,完全由程序员负责。</target>
        </trans-unit>
        <trans-unit id="c39f4af3f8ee369d5da98590dfa9970ef82b38d1" translate="yes" xml:space="preserve">
          <source>Management of areas on the printed page such as top-of page headers, bottom-of-page footers, dealing with &amp;ldquo;full page&amp;rdquo; situations and the like are now the joint responsibility of the programmer and the GnuCOBOL run-time library, which provides tools such as the   &lt;code&gt;LINAGE-COUNTER&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) and the  &lt;code&gt;END-OF-PAGE&lt;/code&gt; clause to deal with page formatting issues.</source>
          <target state="translated">现在，程序员和GnuCOBOL运行时库共同负责管理打印页面上的区域，例如页面顶部标题，页面底部页脚，处理&amp;ldquo;整页&amp;rdquo;情况等。诸如 &lt;code&gt;LINAGE-COUNTER&lt;/code&gt; 特殊寄存器（请参阅&lt;a href=&quot;#Special-Registers&quot;&gt;特殊寄存器&lt;/a&gt;）和 &lt;code&gt;END-OF-PAGE&lt;/code&gt; 子句之类的工具来处理页面格式问题。</target>
        </trans-unit>
        <trans-unit id="1eae0d85460231010a2eeca71dca39a95cfe258b" translate="yes" xml:space="preserve">
          <source>Management of areas on the printed page such as top-of page headers, bottom-of-page footers, dealing with &amp;ldquo;full page&amp;rdquo; situations and the like are the complete responsibility of the programmer.</source>
          <target state="translated">对打印页面上区域的管理，例如页面顶部的页眉，页面底部的页脚，处理&amp;ldquo;整页&amp;rdquo;情况等，是程序员的全部责任。</target>
        </trans-unit>
        <trans-unit id="72c571f7110392bd7e9a608a8c56799f3c875b76" translate="yes" xml:space="preserve">
          <source>Many COBOL compilers do not allow the use of &lt;code&gt;VALUE&lt;/code&gt; and &lt;code&gt;OCCURS&lt;/code&gt; (see &lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt;) on the same data item; additionally, they don&amp;rsquo;t allow a &lt;code&gt;VALUE&lt;/code&gt; clause on a data item subordinate to an &lt;code&gt;OCCURS&lt;/code&gt;. GnuCOBOL, however, has neither of these restrictions!</source>
          <target state="translated">许多COBOL编译器不允许在同一数据项上使用 &lt;code&gt;VALUE&lt;/code&gt; 和 &lt;code&gt;OCCURS&lt;/code&gt; （请参阅&lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt;）。此外，它们不允许在 &lt;code&gt;OCCURS&lt;/code&gt; 后面的数据项上使用 &lt;code&gt;VALUE&lt;/code&gt; 子句。但是，GnuCOBOL没有这两个限制！</target>
        </trans-unit>
        <trans-unit id="5d904664fde10f48cc22ff0d5ed913f64ac37406" translate="yes" xml:space="preserve">
          <source>Many COBOL compilers do not allow the use of&lt;code&gt;VALUE&lt;/code&gt;and&lt;code&gt;OCCURS&lt;/code&gt;(see &lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt;) on the same data item; additionally, they don&amp;rsquo;t allow a&lt;code&gt;VALUE&lt;/code&gt;clause on a data item subordinate to an&lt;code&gt;OCCURS&lt;/code&gt; GnuCOBOL, however, has neither of these restrictions!</source>
          <target state="translated">许多COBOL编译器不允许在同一数据项上使用 &lt;code&gt;VALUE&lt;/code&gt; 和 &lt;code&gt;OCCURS&lt;/code&gt; （请参阅&lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt;）。另外，它们不允许在 &lt;code&gt;OCCURS&lt;/code&gt; GnuCOBOL后面的数据项上使用 &lt;code&gt;VALUE&lt;/code&gt; 子句，但是，这两个限制都没有！</target>
        </trans-unit>
        <trans-unit id="cec330cac6c061d7cea06b901961f17d2342ed88" translate="yes" xml:space="preserve">
          <source>Many systems have program-development tools available to ease the task of coding programs; those tools that concentrate on COBOL are capable of providing templates for much of the &quot;overhead&quot; verbiage of any program&amp;hellip;</source>
          <target state="translated">许多系统都有程序开发工具，可简化代码编写任务。那些专注于COBOL的工具能够为任何程序的大部分&amp;ldquo;开销&amp;rdquo;语言提供模板&amp;hellip;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="16eba348bc9f50336686ef5cc4e108f9eb85d221" translate="yes" xml:space="preserve">
          <source>Many systems have program-development tools available to ease the task of coding programs; those tools that concentrate on COBOL are capable of providing templates for much of the &amp;ldquo;overhead&amp;rdquo; verbiage of any program&amp;hellip;</source>
          <target state="translated">许多系统都有可用的程序开发工具来简化对程序进行编码的任务。那些专注于COBOL的工具能够为任何程序的大部分&amp;ldquo;开销&amp;rdquo;语言提供模板。</target>
        </trans-unit>
        <trans-unit id="bea0e296af322cedefa66548ccd5635e5218df89" translate="yes" xml:space="preserve">
          <source>Many times these businesses are finding the cost of the system/networking engineering, operational management and monitoring and risk management (i.e. disaster recovery) infrastructures necessary to support truly mission-critical applications to be so high that the &quot;less-expensive&quot; solution really isn&amp;rsquo;t; in these cases the mainframe may remain the best option, thus leaving COBOL in play and businesses seeking another solution for at least part of their application base.</source>
          <target state="translated">这些企业常常发现，支持真正的关键任务应用程序所必需的系统/网络工程，运营管理，监视和风险管理（即灾难恢复）基础架构的成本如此之高，以至于&amp;ldquo;廉价&amp;rdquo;解决方案的确不可行。 't;在这些情况下，大型机可能仍然是最佳选择，从而使COBOL发挥了作用，并且企业正在为其至少一部分应用程序库寻求其他解决方案。</target>
        </trans-unit>
        <trans-unit id="2f715c7f265bfdd61e133e71be0ec5656198b750" translate="yes" xml:space="preserve">
          <source>Many times these businesses are finding the cost of the system/networking engineering, operational management and monitoring and risk management (i.e. disaster recovery) infrastructures necessary to support truly mission-critical applications to be so high that the &amp;ldquo;less-expensive&amp;rdquo; solution really isn&amp;rsquo;t; in these cases the mainframe may remain the best option, thus leaving COBOL in play and businesses seeking another solution for at least part of their application base.</source>
          <target state="translated">这些企业常常发现，支持真正的关键任务应用程序所必需的系统/网络工程，运营管理，监视和风险管理（即灾难恢复）基础架构的成本如此之高，以至于&amp;ldquo;廉价&amp;rdquo;的解决方案实际上并没有't; 在这些情况下，大型机可能仍然是最佳选择，从而使COBOL发挥了作用，并且企业正在为其至少一部分应用程序库寻求另一种解决方案。</target>
        </trans-unit>
        <trans-unit id="02c05fa5e2daee8ddf4a77057b17571c14977849" translate="yes" xml:space="preserve">
          <source>Marking changes becomes more of a challenge when free-format source code is in effect. Creating a top-of-program comment block to generically describe changes that have been made isn&amp;rsquo;t difficult, even in free-form. What</source>
          <target state="translated">当自由格式的源代码生效时，标记更改将成为更大的挑战。创建程序顶部的注释块以一般性地描述所做的更改并不困难，即使是自由格式的也不例外。什么</target>
        </trans-unit>
        <trans-unit id="5c7162a608e9a76bc0cf997699b25c2bb027fd85" translate="yes" xml:space="preserve">
          <source>Marking changes becomes more of a challenge when free-format source code is in effect. Creating a top-of-program comment block to generically describe changes that have been made isn&amp;rsquo;t difficult, even in free-form. What IS difficult, however, is coming up with a scheme for per-statement mark up of changes that doesn&amp;rsquo;t introduce a ridiculously excessive number of source lines to the program. I&amp;rsquo;m not sure there is a good answer to this problem (if a reader has one, please let me know). Generally, I&amp;rsquo;ve noticed that shops using free-format conventions for their COBOL source tend to stick with just the top-of-program comment block combined with minimal comment blocks sprinkled throughout the program noting areas that underwent major changes.</source>
          <target state="translated">当自由格式的源代码生效时，标记更改变得更加困难。创建程序顶部的注释块以一般性地描述所做的更改，即使是自由格式也不难。但是，要想出的是一种针对每个语句的更改标记方案，该方案不会给程序带来过多的源代码行。我不确定这个问题是否有好的答案（如果读者有一个答案，请告诉我）。通常，我已经注意到，使用自由格式约定作为COBOL源的商店倾向于只使用程序顶部的注释框，并在整个程序中散布最少的注释框，注意那些需要进行重大更改的区域。</target>
        </trans-unit>
        <trans-unit id="44df495b9a46d581843f66787d274a1a7bcc6fc8" translate="yes" xml:space="preserve">
          <source>Matching up GnuCOBOL numeric Usage s with their C language data type equivalents is possible via the following chart:</source>
          <target state="translated">通过下图可以将 GnuCOBOL 数字用法与它们的 C 语言数据类型等价物进行匹配。</target>
        </trans-unit>
        <trans-unit id="b2f00dc90e71c34249a20020c959899070b8c43f" translate="yes" xml:space="preserve">
          <source>Matching up GnuCOBOL numeric Usage&amp;rsquo;s with their C language data type equivalents is possible via the following chart:</source>
          <target state="translated">可以通过以下图表将GnuCOBOL数字用法与其C语言数据类型等效项进行匹配：</target>
        </trans-unit>
        <trans-unit id="1278cc3d1ceb3c4e92292f1cb7c4a187629fa8a3" translate="yes" xml:space="preserve">
          <source>Max Field</source>
          <target state="translated">最大场次</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="f15a625eabeb2b9b8fbf957ba6acb6ea6384e8c2" translate="yes" xml:space="preserve">
          <source>Meaning if 0</source>
          <target state="translated">意思是如果0</target>
        </trans-unit>
        <trans-unit id="0b296b5b70a4eb122d3023d41ac6ce6b7484aab3" translate="yes" xml:space="preserve">
          <source>Meaning if 1</source>
          <target state="translated">意思是如果1</target>
        </trans-unit>
        <trans-unit id="1b4220e0370bfab2a63184640badca2fac263661" translate="yes" xml:space="preserve">
          <source>Mid Dbl Click</source>
          <target state="translated">中置双击</target>
        </trans-unit>
        <trans-unit id="9535e3b01f3281dac5bb35122bd26a849b2a9282" translate="yes" xml:space="preserve">
          <source>Mid Pressed</source>
          <target state="translated">中压式</target>
        </trans-unit>
        <trans-unit id="95b9cc214c1eef97ef2b6df8fd8ea55bec0588af" translate="yes" xml:space="preserve">
          <source>Mid Released</source>
          <target state="translated">中間釋放</target>
        </trans-unit>
        <trans-unit id="84025296e15836cc805dc0fcce6f78c345ddda06" translate="yes" xml:space="preserve">
          <source>Module being compiled contains the main program.</source>
          <target state="translated">正在编译的模块包含主程序。</target>
        </trans-unit>
        <trans-unit id="b59a4226fd1a0c6fe0f0ae5ec580ab41c849fe7f" translate="yes" xml:space="preserve">
          <source>Monoalphabetic substitution of one or more characters in a string with different characters</source>
          <target state="translated">单字母替换字符串中的一个或多个字符,用不同的字符替换。</target>
        </trans-unit>
        <trans-unit id="f99e481919f7772162edf428466c40acaa045b03" translate="yes" xml:space="preserve">
          <source>Most &amp;lt;</source>
          <target state="translated">大多数&amp;lt;</target>
        </trans-unit>
        <trans-unit id="924840d8c80007140d8bdc6ad8624d02dec61d6e" translate="yes" xml:space="preserve">
          <source>Most &lt;code&gt;&lt;var&gt;VARYING-Clause&lt;/var&gt;&lt;/code&gt;s have no &lt;code&gt;AFTER&lt;/code&gt; specified. Those that do, however, are establishing a loop-within-a-loop situation where the process described above in steps (&amp;lsquo;</source>
          <target state="translated">大多数 &lt;code&gt;&lt;var&gt;VARYING-Clause&lt;/var&gt;&lt;/code&gt; ■找没有 &lt;code&gt;AFTER&lt;/code&gt; 指定。但是，确实这样做的人正在建立一个循环内的情况，其中上述过程分步进行（</target>
        </trans-unit>
        <trans-unit id="ffb0edd87964fd75f70c6e96275eddb4f0d8c34a" translate="yes" xml:space="preserve">
          <source>Most COBOL programmers, when using &lt;code&gt;WITH TEST BEFORE&lt;/code&gt; explicitly or implicitly have developed the habit of using &amp;lsquo;</source>
          <target state="translated">大多数COBOL程序员 &lt;code&gt;WITH TEST BEFORE&lt;/code&gt; 显式或隐式使用WITH TEST之前使用时，已经养成了使用'</target>
        </trans-unit>
        <trans-unit id="f9aaebcdc913ba77329c6f07dbfd334a3e319cb4" translate="yes" xml:space="preserve">
          <source>Most COBOL programmers, when using&lt;code&gt;WITH TEST BEFORE&lt;/code&gt;explicitly or implicitly have developed the habit of using &quot;&amp;gt;&quot; rather than &quot;=&quot; on&lt;code&gt;UNTIL&lt;/code&gt;clauses. This would make the sample code:</source>
          <target state="translated">大多数COBOL程序员 &lt;code&gt;WITH TEST BEFORE&lt;/code&gt; 显式或隐式使用WITH TEST之前使用时，已经养成了在 &lt;code&gt;UNTIL&lt;/code&gt; 子句上使用&amp;ldquo;&amp;gt;&amp;rdquo;而不是&amp;ldquo; =&amp;rdquo;的习惯。这将使示例代码：</target>
        </trans-unit>
        <trans-unit id="af302c911fcda5124147255d68b3ea18b4163a54" translate="yes" xml:space="preserve">
          <source>Most of the call-by-number routines have evolved into even more powerful call-by-name routines, many of which are supported by GnuCOBOL.</source>
          <target state="translated">大部分的逐号例程已经演变成更强大的逐名例程,其中很多例程都被GnuCOBOL所支持。</target>
        </trans-unit>
        <trans-unit id="817d5274cb3dad555ae670d47cd2b238950e0a1b" translate="yes" xml:space="preserve">
          <source>Most other COBOL implementations reject the use of multiple occurrences of multiple floating editing symbols. For example, they would reject &amp;lt;</source>
          <target state="translated">大多数其他COBOL实现都拒绝使用多次出现的多个浮动编辑符号。例如，他们会拒绝&amp;lt;</target>
        </trans-unit>
        <trans-unit id="58de159141a408dd736236a21261f443f9261611" translate="yes" xml:space="preserve">
          <source>Most other COBOL implementations reject the use of multiple occurrences of multiple floating editing symbols. For example, they would reject &lt;var&gt;picture-string&lt;/var&gt;s such as &lt;code&gt;+++$$$9.99&lt;/code&gt;, &lt;code&gt;$$$ZZZ9.99&lt;/code&gt; and so on. GnuCOBOL accepts these. Programmers creating GnuCOBOL programs should avoid such &lt;var&gt;picture-string&lt;/var&gt;s if there is any likelihood that those programs may be used with other COBOL implementations.</source>
          <target state="translated">大多数其他COBOL实现都拒绝使用多次出现的多个浮动编辑符号。例如，他们会拒绝 &lt;var&gt;picture-string&lt;/var&gt; 例如 &lt;code&gt;+++$$$9.99&lt;/code&gt; ， &lt;code&gt;$$$ZZZ9.99&lt;/code&gt; 等。GnuCOBOL接受这些。如果有可能这些程序可以与其他COBOL实现一起使用，则创建GnuCOBOL程序的程序员应避免使用此类 &lt;var&gt;picture-string&lt;/var&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae88dcc958cf082a5ddff5e3bffb27559f0abd8e" translate="yes" xml:space="preserve">
          <source>Mouse Key codes are populated only if mouse management has been enabled. To enable mouse it is first necessary to set &lt;code&gt;COB_MOUSE_FLAGS&lt;/code&gt; (either externally via terminal command, or internally via &lt;code&gt;SET ENVIRONMENT&lt;/code&gt; to the applicable ?mouse mask? (specifying which activities you wish the program to detect). Here is an example of setting the mask from a COBOL program:</source>
          <target state="translated">仅当启用了鼠标管理时，才会填充鼠标键代码。要启用鼠标，首先需要设置 &lt;code&gt;COB_MOUSE_FLAGS&lt;/code&gt; （通过终端命令从外部或通过 &lt;code&gt;SET ENVIRONMENT&lt;/code&gt; 在内部设置为适用的&amp;ldquo;鼠标掩码&amp;rdquo;（指定希望程序检测到哪些活动）。一个COBOL程序：</target>
        </trans-unit>
        <trans-unit id="e99a5dcdcef05304aba95db02a55182cfff694d7" translate="yes" xml:space="preserve">
          <source>Mouse Move</source>
          <target state="translated">鼠标移动</target>
        </trans-unit>
        <trans-unit id="bd8dc228cac7dc6165d9a7427a86371a364ab9e9" translate="yes" xml:space="preserve">
          <source>Moving files (a destructive &quot;copy&quot;)</source>
          <target state="translated">移动文件(破坏性的 &quot;复制&quot;)</target>
        </trans-unit>
        <trans-unit id="af7bc5186e5f6587dd7cf943c6a4e4b97482ae2e" translate="yes" xml:space="preserve">
          <source>Moving files (a destructive &amp;ldquo;copy&amp;rdquo;)</source>
          <target state="translated">移动文件（破坏性的&amp;ldquo;副本&amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="b3170807df2699f5d0529b6da50976a416981ad4" translate="yes" xml:space="preserve">
          <source>Multiple &amp;lsquo;</source>
          <target state="translated">多种的 '</target>
        </trans-unit>
        <trans-unit id="c6f6bfc686d3122948fbe2220d2b1d5226a79270" translate="yes" xml:space="preserve">
          <source>Multiple programs, separated from one another by &lt;code&gt;END PROGRAM&lt;/code&gt; or &lt;code&gt;END FUNCTION&lt;/code&gt; statements. The final program in such a source code file need not have an &lt;code&gt;END PROGRAM&lt;/code&gt; or &lt;code&gt;END FUNCTION&lt;/code&gt; statement.</source>
          <target state="translated">多个程序，由 &lt;code&gt;END PROGRAM&lt;/code&gt; 或 &lt;code&gt;END FUNCTION&lt;/code&gt; 语句彼此分隔。这样的源代码文件中的最终程序不必具有 &lt;code&gt;END PROGRAM&lt;/code&gt; 或 &lt;code&gt;END FUNCTION&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="8068c142bfb974eaa19e904ed221669dae03ee9c" translate="yes" xml:space="preserve">
          <source>Multiple programs, separated from one another by&lt;code&gt;END PROGRAM&lt;/code&gt;or&lt;code&gt;END FUNCTION&lt;/code&gt;statements. The final program in such a source code file need not have an&lt;code&gt;END PROGRAM&lt;/code&gt;or&lt;code&gt;END FUNCTION&lt;/code&gt;statement.</source>
          <target state="translated">多个程序，由 &lt;code&gt;END PROGRAM&lt;/code&gt; 或 &lt;code&gt;END FUNCTION&lt;/code&gt; 语句彼此分隔。这样的源代码文件中的最终程序不必具有 &lt;code&gt;END PROGRAM&lt;/code&gt; 或 &lt;code&gt;END FUNCTION&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="02160c2d59fcbe5c753ac574ebfed903f459af79" translate="yes" xml:space="preserve">
          <source>Multiple space-delimited tokens may be treated as a single token by enclosing them in quotes. For example, there are only three tokens generated from the command line &lt;code&gt;C:\Pgms\myprog.exe &quot;THIS IS A&quot; TEST&lt;/code&gt; &amp;mdash; &quot;C:\Pgms\myprog.exe&quot;, &quot;THIS IS A&quot; and &quot;TEST&quot;. When quote characters are used to create multi-word tokens, the quote characters themselves are stripped from the token&amp;rsquo;s value.</source>
          <target state="translated">通过将多个用空格分隔的标记括在引号中，可以将它们视为单个标记。例如，仅从命令行 &lt;code&gt;C:\Pgms\myprog.exe &quot;THIS IS A&quot; TEST&lt;/code&gt; 生成三个令牌-&amp;ldquo; C：\ Pgms \ myprog.exe&amp;rdquo;，&amp;ldquo;这是一个&amp;rdquo;和&amp;ldquo;测试&amp;rdquo;。当使用引号字符创建多词标记时，引号字符本身会从标记的值中删除。</target>
        </trans-unit>
        <trans-unit id="a00cb7c2ea609150a27e4dadeed928c42c11310c" translate="yes" xml:space="preserve">
          <source>Multiple space-delimited tokens may be treated as a single token by enclosing them in quotes. For example, there are only three tokens generated from the command line &lt;code&gt;C:\Pgms\myprog.exe &amp;lsquo;&lt;samp&gt;THIS IS A&lt;/samp&gt;&amp;rsquo; TEST&lt;/code&gt; &amp;mdash; &amp;lsquo;</source>
          <target state="translated">通过将多个用空格分隔的标记括在引号中，可以将它们视为单个标记。例如，从命令行 &lt;code&gt;C:\Pgms\myprog.exe &amp;lsquo;&lt;samp&gt;THIS IS A&lt;/samp&gt;&amp;rsquo; TEST&lt;/code&gt; 仅生成三个令牌。&lt;samp&gt;这是一个&lt;/samp&gt;'测试-'</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
