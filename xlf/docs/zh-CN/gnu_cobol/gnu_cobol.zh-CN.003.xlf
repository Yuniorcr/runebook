<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="gnu_cobol">
    <body>
      <group id="gnu_cobol">
        <trans-unit id="e9543acb0a3b6ae140b676bdd75a9f04b94c736b" translate="yes" xml:space="preserve">
          <source>CONFIGURATION SECTION Syntax</source>
          <target state="translated">CONFIGURATION SECTION 语法</target>
        </trans-unit>
        <trans-unit id="fd14e0768d8e03137017ff03d76cc74754b47cbb" translate="yes" xml:space="preserve">
          <source>CONSTANT Attribute Syntax</source>
          <target state="translated">CONSTANT属性语法</target>
        </trans-unit>
        <trans-unit id="45f863a18c883ddde1c38a1609e1083371a910f8" translate="yes" xml:space="preserve">
          <source>CONTINUE Syntax</source>
          <target state="translated">CONTINUE 语法</target>
        </trans-unit>
        <trans-unit id="57c118d0153aad86aee87fdaf7399dce402a08bd" translate="yes" xml:space="preserve">
          <source>CONTROL FOOTING(S) [2]</source>
          <target state="translated">控制蹄铁 [2]</target>
        </trans-unit>
        <trans-unit id="a0b77db4412f953dc79ec3e8dadb8c3312edb9f0" translate="yes" xml:space="preserve">
          <source>CONTROL HEADING(S) [2]</source>
          <target state="translated">控制标题 [2]</target>
        </trans-unit>
        <trans-unit id="a0fe3388635d6d014a065ee11d0aee898e490bea" translate="yes" xml:space="preserve">
          <source>COS Function Syntax</source>
          <target state="translated">COS函数语法</target>
        </trans-unit>
        <trans-unit id="e2bf90245c3eae70b50309837f6647c1f83fdf58" translate="yes" xml:space="preserve">
          <source>COUNT</source>
          <target state="translated">COUNT</target>
        </trans-unit>
        <trans-unit id="46a355610c958a2df7dbd1b4d7bf89438582b10c" translate="yes" xml:space="preserve">
          <source>CURRENCY-SYMBOL Function Syntax</source>
          <target state="translated">货币符号 函数语法</target>
        </trans-unit>
        <trans-unit id="7ab87c3b533221867b4462ee901838685c51bd46" translate="yes" xml:space="preserve">
          <source>CURRENT-DATE Function Syntax</source>
          <target state="translated">函数语法 CURRENT-DATE</target>
        </trans-unit>
        <trans-unit id="a2b6abc7961dcf84b76adf0da7d0e3cb7258497a" translate="yes" xml:space="preserve">
          <source>Called Program</source>
          <target state="translated">呼叫程序</target>
        </trans-unit>
        <trans-unit id="08e86dd2cb3e588792e5a1445c80be0d6ca86b4d" translate="yes" xml:space="preserve">
          <source>Called program not found</source>
          <target state="translated">未找到被调用的程序</target>
        </trans-unit>
        <trans-unit id="79de0a0be26f9fe0196ab734446be6015cb155b5" translate="yes" xml:space="preserve">
          <source>Calling Program</source>
          <target state="translated">呼叫程序</target>
        </trans-unit>
        <trans-unit id="4aa75fa92437b6df595f9667af7d64254448be0b" translate="yes" xml:space="preserve">
          <source>Care must be taken that &amp;lt;</source>
          <target state="translated">必须注意&amp;lt;</target>
        </trans-unit>
        <trans-unit id="232276f2c2caa7b4c6621023fcbe761e2f25eb06" translate="yes" xml:space="preserve">
          <source>Care must be taken that programs reading such a file describe records whose length is exactly the same as that used by the program that created the file. For example, the following shows the contents of a&lt;code&gt;SEQUENTIAL&lt;/code&gt;file created by a program that wrote five 6-character records to it. The &quot;A&quot;, &quot;B&quot;, &amp;hellip; values reflect the records that were written to the file:</source>
          <target state="translated">必须注意，读取此类文件的程序所描述的记录的长度必须与创建该文件的程序所使用的长度完全相同。例如，以下内容显示了一个程序创建的 &lt;code&gt;SEQUENTIAL&lt;/code&gt; 文件的内容，该程序向其中写入了五个6个字符的记录。&amp;ldquo; A&amp;rdquo;，&amp;ldquo; B&amp;rdquo;，&amp;hellip;&amp;hellip;值反映了已写入文件的记录：</target>
        </trans-unit>
        <trans-unit id="0d6ab5c40892951a44701a3cbbc3363615028003" translate="yes" xml:space="preserve">
          <source>Care must be taken that programs reading such a file describe records whose length is exactly the same as that used by the programs that created the file. It won&amp;rsquo;t end well if the GnuCOBOL runtime library interprets a four-byte ASCII character string as a record length when it transfers data from the file into the program!</source>
          <target state="translated">必须注意，读取此类文件的程序所描述的记录的长度必须与创建该文件的程序所使用的长度完全相同。如果GnuCOBOL运行时库在将数据从文件传输到程序中时将4字节ASCII字符串解释为记录长度，将不会很好！</target>
        </trans-unit>
        <trans-unit id="008af863881dc7149313286a97c8945b993a34fe" translate="yes" xml:space="preserve">
          <source>Case-folding may also be turned on and off within the program source code using the CDF&lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt;statement (see &lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt;SET&lt;/a&gt;).</source>
          <target state="translated">也可以使用CDF &lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; 语句在程序源代码中打开和关闭大小写折叠（请参见&lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt; SET&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="98accb26910de4948b37b8fbb0b408fbd1a965e0" translate="yes" xml:space="preserve">
          <source>Caution. Although this document is for version 2.2 of the compiler, it also includes a description of the functions of the RWCS (Report Writer module) which is not included in the compiler version 2.2. Please see availability notes on this at 1.3.13.</source>
          <target state="translated">注意:虽然本文件是针对2.2版本的编译器,但其中也包括了RWCS(报告编写模块)功能的描述,而这些功能并不包含在2.2版本的编译器中。虽然这个文档是针对2.2版本的编译器,但它也包含了对RWCS(Report Writer模块)功能的描述,而RWCS不包含在2.2版本的编译器中。请参见1.3.13的可用性说明。</target>
        </trans-unit>
        <trans-unit id="fb48ed86295c01e223491405da96e0725331ba29" translate="yes" xml:space="preserve">
          <source>Changes made by a subprogram to the value of an argument specified on the&lt;code&gt;USING&lt;/code&gt;clause will &quot;be visible&quot; to the calling program only if&lt;code&gt;BY REFERENCE&lt;/code&gt;was explicitly specified or implicitly assumed for the argument on the subprogram&amp;rsquo;s procedure division header</source>
          <target state="translated">子程序对 &lt;code&gt;USING&lt;/code&gt; 子句中指定的参数的值所做的更改只有在为子程序的过程划分标头上的参数明确指定或隐式假定了 &lt;code&gt;BY REFERENCE&lt;/code&gt; 时，才对调用程序&amp;ldquo;可见&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="1cf367703f62db4730492b29e986ff87aabe8968" translate="yes" xml:space="preserve">
          <source>Changing the currency symbol via the&lt;code&gt;SPECIAL-NAMES&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) paragraph&amp;rsquo;s&lt;code&gt;CURRENCY SYMBOL&lt;/code&gt;setting will</source>
          <target state="translated">通过 &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; （请参阅&lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;）段落的 &lt;code&gt;CURRENCY SYMBOL&lt;/code&gt; 设置更改货币符号将</target>
        </trans-unit>
        <trans-unit id="3290313e1574c3d689ba9eb70ce2b545abfe41ec" translate="yes" xml:space="preserve">
          <source>Changing the current directory</source>
          <target state="translated">更改当前目录</target>
        </trans-unit>
        <trans-unit id="6dd47dabb9df79c85d4c9bbf8e536ca75ef3576e" translate="yes" xml:space="preserve">
          <source>Character positions in this list do not affect the actual binary storage values used for the characters &amp;mdash; binary values will still be those of the&lt;code&gt;NATIVE&lt;/code&gt;character set.</source>
          <target state="translated">此列表中的字符位置不会影响用于字符的实际二进制存储值-二进制值仍将是 &lt;code&gt;NATIVE&lt;/code&gt; 字符集的二进制存储值。</target>
        </trans-unit>
        <trans-unit id="b6f59f08fd6d58c6725e21a9ec24e068148ec586" translate="yes" xml:space="preserve">
          <source>Characters</source>
          <target state="translated">Characters</target>
        </trans-unit>
        <trans-unit id="06ba9f8b51464a92c09ba8adb0428ae07c0698c2" translate="yes" xml:space="preserve">
          <source>Class-Condition Syntax</source>
          <target state="translated">类条件语法</target>
        </trans-unit>
        <trans-unit id="6dcfeb045a3fd680afc99e0a6405f85f4b06bc0e" translate="yes" xml:space="preserve">
          <source>Class-Definition-Clause</source>
          <target state="translated">Class-Definition-Clause</target>
        </trans-unit>
        <trans-unit id="88225646933261b2af20b61cd0a15701c0f8d989" translate="yes" xml:space="preserve">
          <source>Clearly, even a non-programmer could at least conceptually understand what was going on! Over time, languages like FORTRAN evolved more robust variable names, and COBOL introduced a more formula-based syntactical capability for arithmetic operations, but FORTRAN was never as readable as COBOL.</source>
          <target state="translated">显然,即使是一个非程序员,至少也能从概念上理解发生了什么事!随着时间的推移,FORTRAN等语言发展出了更强大的变量名,而COBOL则引入了更多基于公式的算术运算能力,但FORTRAN始终没有COBOL那样的可读性。随着时间的推移,FORTRAN等语言发展出了更强大的变量名,COBOL也为算术运算引入了更多基于公式的语法能力,但FORTRAN始终没有COBOL那样的可读性。</target>
        </trans-unit>
        <trans-unit id="732a5387092d26a94fef7e2ce8d5d9519c238b19" translate="yes" xml:space="preserve">
          <source>Closed with lock</source>
          <target state="translated">带锁关闭</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="594422a8373a45016503112a0d76d479ebc2de36" translate="yes" xml:space="preserve">
          <source>Collating Sequence</source>
          <target state="translated">整理序列</target>
        </trans-unit>
        <trans-unit id="1d0c8304baedcf8e3a78982c2e7c0b04622bf2a0" translate="yes" xml:space="preserve">
          <source>Color</source>
          <target state="translated">Color</target>
        </trans-unit>
        <trans-unit id="5ff247b294c4c4680923f6b83955ad2dd9bcc50b" translate="yes" xml:space="preserve">
          <source>Colors may also be specified using a numeric non-edited identifier whose value is in the range 0-7.</source>
          <target state="translated">颜色也可以使用数值的非编辑标识符来指定,其数值范围为0-7。</target>
        </trans-unit>
        <trans-unit id="3da9b0a1bd95ee2ff92f0876a9bc1660e1b7f92d" translate="yes" xml:space="preserve">
          <source>Column 7 serves as an indicator in which one of five possible values will appear &amp;mdash; space,&lt;code&gt;D&lt;/code&gt;(or&lt;code&gt;d&lt;/code&gt;,&lt;code&gt;-&lt;/code&gt;(dash),&lt;code&gt;/&lt;/code&gt;or&lt;code&gt;*&lt;/code&gt; The meanings of these characters are as follows:</source>
          <target state="translated">第7列用作指示符，其中将出现五个可能的值之一-空格， &lt;code&gt;D&lt;/code&gt; （或 &lt;code&gt;d&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; （破折号）， &lt;code&gt;/&lt;/code&gt; 或 &lt;code&gt;*&lt;/code&gt; ）。这些字符的含义如下：</target>
        </trans-unit>
        <trans-unit id="f92afaa3e8bfcd3ea4fa0e30b81b8a7e79d9e878" translate="yes" xml:space="preserve">
          <source>Column headings describing the fields within the detail group(s)</source>
          <target state="translated">描述详细组内字段的列标题。</target>
        </trans-unit>
        <trans-unit id="ef3b24c82e2e70a56915cb2e013177a3e224de2a" translate="yes" xml:space="preserve">
          <source>Combined Condition Syntax</source>
          <target state="translated">组合条件语法</target>
        </trans-unit>
        <trans-unit id="11bac06e449288d8a0080c4c6a977a78a032bea7" translate="yes" xml:space="preserve">
          <source>Comment Type</source>
          <target state="translated">如何类型</target>
        </trans-unit>
        <trans-unit id="94ef186c06d95cc1077474be4d410b632a210905" translate="yes" xml:space="preserve">
          <source>Comments that may be treated as code, typically for debugging purposes</source>
          <target state="translated">可被视为代码的注释,通常用于调试的目的</target>
        </trans-unit>
        <trans-unit id="2fd8ee31128a27c3741cf64157f9abf402269ba4" translate="yes" xml:space="preserve">
          <source>Compatible Binary Integer</source>
          <target state="translated">兼容二进制整数</target>
        </trans-unit>
        <trans-unit id="da8cf05ee405cd9a986668c8c46c9a8e120fd720" translate="yes" xml:space="preserve">
          <source>Compilation Group</source>
          <target state="translated">汇编组</target>
        </trans-unit>
        <trans-unit id="96cd345d12b5b7ca5ae139bb77e1a9c53007e491" translate="yes" xml:space="preserve">
          <source>Compilation Unit</source>
          <target state="translated">汇编股</target>
        </trans-unit>
        <trans-unit id="e859ddacb886ecaac3920b7f115299577527697c" translate="yes" xml:space="preserve">
          <source>Compilations may be performed to generate dynamically-loadable modules (or dynamically-loadable libraries, as they are frequently called). These compilations are performed by using the&lt;code&gt;-m&lt;/code&gt;switch</source>
          <target state="translated">可以执行编译以生成动态可加载模块（或动态加载模块，因为它们经常被调用）。这些编译是通过使用 &lt;code&gt;-m&lt;/code&gt; 开关执行的</target>
        </trans-unit>
        <trans-unit id="6218c92ed166d6dee1c3823d57775cd989a17afa" translate="yes" xml:space="preserve">
          <source>Compile this program as follows (the assumption is made that you are executing the&lt;code&gt;cobc&lt;/code&gt;command from the directory in which the above program source code (subvsindex.cbl) exists.</source>
          <target state="translated">如下编译该程序（假设您正在从以上程序源代码（subvsindex.cbl）所在的目录中执行 &lt;code&gt;cobc&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="c4e180aae5f5ffed0f5284c8c7daee050f8017a2" translate="yes" xml:space="preserve">
          <source>Compiler directives are</source>
          <target state="translated">编译器指令是</target>
        </trans-unit>
        <trans-unit id="746fe304b6da04f2948db99dc5a6735e74cebf7a" translate="yes" xml:space="preserve">
          <source>Complete GnuCOBOL Program Syntax</source>
          <target state="translated">GnuCOBOL程序语法大全</target>
        </trans-unit>
        <trans-unit id="e0f7f8b906be02847bd6c0bc57ead1c617c67102" translate="yes" xml:space="preserve">
          <source>Complex-Syntax-Clause</source>
          <target state="translated">Complex-Syntax-Clause</target>
        </trans-unit>
        <trans-unit id="8e66b8e5477316fe83d734c891de408f9f788241" translate="yes" xml:space="preserve">
          <source>Computer scientists will compare the two techniques implemented by the&lt;code&gt;SEARCH&lt;/code&gt;and&lt;code&gt;SEARCH ALL&lt;/code&gt;statements as follows:</source>
          <target state="translated">计算机科学家将比较 &lt;code&gt;SEARCH&lt;/code&gt; 和 &lt;code&gt;SEARCH ALL&lt;/code&gt; 语句实现的两种技术，如下所示：</target>
        </trans-unit>
        <trans-unit id="333d34a78170ebdea1656c8398a11eab37b54584" translate="yes" xml:space="preserve">
          <source>Condition names are Boolean (i.e. TRUE / FALSE) data items that receive their TRUE and FALSE values based upon the values of the non 88-level data item whose definition they immediately follow.</source>
          <target state="translated">条件名称是布尔型(即TRUE/FALSE)数据项,根据其定义紧随其后的非88级数据项的值获得其TRUE和FALSE值。</target>
        </trans-unit>
        <trans-unit id="c87464dfce9a9aff3851d0944fefb1558383352f" translate="yes" xml:space="preserve">
          <source>Condition names are always defined subordinate to another (non 88-level) data item. That data item must be an elementary item. Whenever the parent data item assumes one of the values specified on the 88-level item&amp;rsquo;s&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause, &amp;lt;</source>
          <target state="translated">条件名称始终定义为从属于另一个（非88级）数据项。该数据项必须是基本项。每当父数据项采用在88级项目的 &lt;code&gt;VALUE&lt;/code&gt; （请参阅&lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;）子句中指定的值之一时，&amp;lt;</target>
        </trans-unit>
        <trans-unit id="027a11b37533ca20669bb17281d210c5767e61eb" translate="yes" xml:space="preserve">
          <source>Condition names do not occupy any storage.</source>
          <target state="translated">条件名称不占用任何存储空间。</target>
        </trans-unit>
        <trans-unit id="300654fa157f6c6e091010b7777c8e3f6af9ccc2" translate="yes" xml:space="preserve">
          <source>Conflicting attribute</source>
          <target state="translated">冲突的属性</target>
        </trans-unit>
        <trans-unit id="bd243da61bc83e255c691b0eeb1676f5cf315d17" translate="yes" xml:space="preserve">
          <source>Consider</source>
          <target state="translated">Consider</target>
        </trans-unit>
        <trans-unit id="fdb2d9eaefe67e778b752e4f472db4c9da926388" translate="yes" xml:space="preserve">
          <source>Consider including a trailing descriptor of the nature of all data items in their names. The following chart presents a variety of such descriptors the author has encountered and used through the years.</source>
          <target state="translated">考虑在所有数据项的名称中加入一个尾部描述符,说明其性质。下图是笔者多年来遇到和使用的各种此类描述符。</target>
        </trans-unit>
        <trans-unit id="49ad35a272291924fe1567effd78bef2707d1787" translate="yes" xml:space="preserve">
          <source>Consider including an acronym to be inserted into the name of any data item defined directly or indirectly subordinate to an 01-level item, typically to be specified after any section-level tag, if you&amp;rsquo;re using them. For example, consider the names used in the following structure:</source>
          <target state="translated">考虑使用首字母缩略词插入到直接或间接从属于01级项目的任何数据项的名称中，如果要使用它们，通常在任何节级标签之后指定。例如，考虑以下结构中使用的名称：</target>
        </trans-unit>
        <trans-unit id="474092c4530711a5712f2088d0c7006e1c6ea236" translate="yes" xml:space="preserve">
          <source>Consider using&lt;code&gt;SET ENVIRONMENT&lt;/code&gt;(see &lt;a href=&quot;#SET-ENVIRONMENT&quot;&gt;SET ENVIRONMENT&lt;/a&gt;) in lieu of&lt;code&gt;DISPLAY&lt;/code&gt;to set environment variables as it is much simpler.</source>
          <target state="translated">考虑使用 &lt;code&gt;SET ENVIRONMENT&lt;/code&gt; （请参阅&lt;a href=&quot;#SET-ENVIRONMENT&quot;&gt;SET ENVIRONMENT&lt;/a&gt;）代替 &lt;code&gt;DISPLAY&lt;/code&gt; 来设置环境变量，因为它要简单得多。</target>
        </trans-unit>
        <trans-unit id="cd60aa178f4b05c8b4e18662c70566d29b29c05b" translate="yes" xml:space="preserve">
          <source>Console output when run (user input follows the colons on the prompts for input):</source>
          <target state="translated">运行时的控制台输出(用户输入在输入提示的冒号后面)。</target>
        </trans-unit>
        <trans-unit id="482dcfb6a26e7cc8dbfee8b9c6882a08cb82b778" translate="yes" xml:space="preserve">
          <source>Constants defined in this way become undefined once an&lt;code&gt;END PROGRAM&lt;/code&gt;or&lt;code&gt;END FUNCTION&lt;/code&gt;is encountered in the input source.</source>
          <target state="translated">一旦在输入源中遇到 &lt;code&gt;END PROGRAM&lt;/code&gt; 或 &lt;code&gt;END FUNCTION&lt;/code&gt; ,以这种方式定义的常数将变为未定义。</target>
        </trans-unit>
        <trans-unit id="97f677ffe8002bb978e6196b88b1b9221d3315cd" translate="yes" xml:space="preserve">
          <source>Consult the documentation on the</source>
          <target state="translated">请查阅有关文件。</target>
        </trans-unit>
        <trans-unit id="ee9d7834b4e03028e401f780d9d177af07cb943c" translate="yes" xml:space="preserve">
          <source>Contain a leading numeric component (for example:&lt;code&gt;2000-Update-Customer&lt;/code&gt;, AND&amp;hellip;</source>
          <target state="translated">包含前导数字部分（例如： &lt;code&gt;2000-Update-Customer&lt;/code&gt; ，AND&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="d504f89e29051ac2c61a4e1307b823272b01fbfa" translate="yes" xml:space="preserve">
          <source>Contained Subprograms</source>
          <target state="translated">包含的子方案</target>
        </trans-unit>
        <trans-unit id="32b3d87c6ceda12546f190f2210a22df0cdf6e15" translate="yes" xml:space="preserve">
          <source>Contrast this function with the&lt;code&gt;BYTE-LENGTH&lt;/code&gt;(see &lt;a href=&quot;#BYTE_002dLENGTH&quot;&gt;BYTE-LENGTH&lt;/a&gt;) and&lt;code&gt;LENGTH-AN&lt;/code&gt;(see &lt;a href=&quot;#LENGTH_002dAN&quot;&gt;LENGTH-AN&lt;/a&gt;) functions.</source>
          <target state="translated">将此功能与 &lt;code&gt;BYTE-LENGTH&lt;/code&gt; （请参见&lt;a href=&quot;#BYTE_002dLENGTH&quot;&gt;BYTE-LENGTH&lt;/a&gt;）和 &lt;code&gt;LENGTH-AN&lt;/code&gt; （请参见&lt;a href=&quot;#LENGTH_002dAN&quot;&gt;LENGTH-AN&lt;/a&gt;）功能进行比较。</target>
        </trans-unit>
        <trans-unit id="c13b5b85342bf60c0e7b3cad62d98a00d84bed25" translate="yes" xml:space="preserve">
          <source>Contrast this with the&lt;code&gt;LENGTH&lt;/code&gt;(see &lt;a href=&quot;#LENGTH&quot;&gt;LENGTH&lt;/a&gt;) function.</source>
          <target state="translated">将此与 &lt;code&gt;LENGTH&lt;/code&gt; （请参见&lt;a href=&quot;#LENGTH&quot;&gt;LENGTH&lt;/a&gt;）功能进行对比。</target>
        </trans-unit>
        <trans-unit id="d864d1d594bb58da63124b3e532077a2280da211" translate="yes" xml:space="preserve">
          <source>Control Break</source>
          <target state="translated">控制中断</target>
        </trans-unit>
        <trans-unit id="e707dbac72bfee188a71125817eb3d24f8da1780" translate="yes" xml:space="preserve">
          <source>Control Field</source>
          <target state="translated">控制领域</target>
        </trans-unit>
        <trans-unit id="960257afeb12f77fa6f8f055108e92a370b0072a" translate="yes" xml:space="preserve">
          <source>Control Footing</source>
          <target state="translated">控制脚</target>
        </trans-unit>
        <trans-unit id="b37055601ddd24b634819c08af5e0ee3aec0c2f5" translate="yes" xml:space="preserve">
          <source>Control Heading</source>
          <target state="translated">控制标题</target>
        </trans-unit>
        <trans-unit id="3089ab53c60beb89e389be8470443c8bae92e074" translate="yes" xml:space="preserve">
          <source>Control Hierarchy</source>
          <target state="translated">控制层次结构</target>
        </trans-unit>
        <trans-unit id="1bef2ffd2d898c95784379f9d8d159b85d5b9c39" translate="yes" xml:space="preserve">
          <source>Control will return back to the&lt;code&gt;PERFORM&lt;/code&gt; where &amp;mdash; if&lt;code&gt;WITH TEST AFTER&lt;/code&gt;was specified &amp;mdash; &amp;lt;</source>
          <target state="translated">控制将返回到 &lt;code&gt;PERFORM&lt;/code&gt; 地方-如果 &lt;code&gt;WITH TEST AFTER&lt;/code&gt; 指定- &amp;lt;</target>
        </trans-unit>
        <trans-unit id="6b631a4ffc81ee3a9a3caa199af3dfcb4b9eebb2" translate="yes" xml:space="preserve">
          <source>Control will then proceed to the statement following the&lt;code&gt;END-EVALUATE&lt;/code&gt;or the first statement that follows the next period if there is no&lt;code&gt;END-EVALUATE&lt;/code&gt; If,however, the &amp;lt;</source>
          <target state="translated">如果没有 &lt;code&gt;END-EVALUATE&lt;/code&gt; ，控制将继续到 &lt;code&gt;END-EVALUATE&lt;/code&gt; 之后的语句或下一个句点之后的第一条语句。</target>
        </trans-unit>
        <trans-unit id="6821ab076fc8e4c97eea6b8244b17e70476d24ee" translate="yes" xml:space="preserve">
          <source>Controlling the pagination of reports, including:</source>
          <target state="translated">控制报告的分页,包括:</target>
        </trans-unit>
        <trans-unit id="7dd804bb2edf5c6b71e08057b1fe7806375aa80d" translate="yes" xml:space="preserve">
          <source>Copybook</source>
          <target state="translated">Copybook</target>
        </trans-unit>
        <trans-unit id="e2aa0e7c3bd507e669da6cc819890494774937c3" translate="yes" xml:space="preserve">
          <source>Copybooks containing code intended for the identification division. These will be rare as you almost never encounter copied code in the identification division.</source>
          <target state="translated">载有供识别部门使用的代码的拷贝本。这类书籍很少,因为在识别部门几乎从未遇到过复制的代码。</target>
        </trans-unit>
        <trans-unit id="ae4bb1674f81c29f3e27ad4dcb083e8655d69118" translate="yes" xml:space="preserve">
          <source>Copybooks containing code intended for use in the environment division. These copybooks are generally used for predefined&lt;code&gt;SPECIAL-NAMES&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) or&lt;code&gt;FILE-CONTROL&lt;/code&gt;(see &lt;a href=&quot;#INPUT_002dOUTPUT-SECTION&quot;&gt;INPUT-OUTPUT SECTION&lt;/a&gt;) syntax,</source>
          <target state="translated">抄本包含打算在环境部门使用的代码。这些副本通常用于预定义的 &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; （请参阅&lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;）或 &lt;code&gt;FILE-CONTROL&lt;/code&gt; （请参见&lt;a href=&quot;#INPUT_002dOUTPUT-SECTION&quot;&gt;INPUT-OUTPUT SECTION&lt;/a&gt;）语法，</target>
        </trans-unit>
        <trans-unit id="2518777d2abfc517966e28f0596ae3116363bcc5" translate="yes" xml:space="preserve">
          <source>Copybooks that contain data definitions.</source>
          <target state="translated">载有数据定义的抄本;</target>
        </trans-unit>
        <trans-unit id="752aff643f4fc290408c7437031076a71eebc79b" translate="yes" xml:space="preserve">
          <source>Copybooks that contain executable instructions.</source>
          <target state="translated">含有可执行指令的拷贝本;</target>
        </trans-unit>
        <trans-unit id="b6a8b5660c828f3b2c93bf54e7099762c731d4dd" translate="yes" xml:space="preserve">
          <source>Copying files</source>
          <target state="translated">复制文件</target>
        </trans-unit>
        <trans-unit id="154784820baffd42626a2bcde20aa0381aaae095" translate="yes" xml:space="preserve">
          <source>Copyright &amp;copy; 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.</source>
          <target state="translated">版权所有&amp;copy;2000、2001、2002、2007、2008 Free Software Foundation，Inc.</target>
        </trans-unit>
        <trans-unit id="cb54a4d008dbbbce9c32d6cda871fb64051a8eba" translate="yes" xml:space="preserve">
          <source>Could be abbreviated as:</source>
          <target state="translated">可简写为:</target>
        </trans-unit>
        <trans-unit id="8e7fb87ed35f3e95693d0d85ac2e5bb078a3fccb" translate="yes" xml:space="preserve">
          <source>Creating a directory</source>
          <target state="translated">创建一个目录</target>
        </trans-unit>
        <trans-unit id="364920436a8c309c1b52c0fc8087c58a7ed12784" translate="yes" xml:space="preserve">
          <source>Creating, Opening, Closing, Reading and Writing byte-stream files</source>
          <target state="translated">创建、打开、关闭、读取和写入字节流文件。</target>
        </trans-unit>
        <trans-unit id="03cc92b2de6a93842702049006d74479339df02c" translate="yes" xml:space="preserve">
          <source>Current date in Gregorian form</source>
          <target state="translated">目前的日期,以格里高利形式</target>
        </trans-unit>
        <trans-unit id="1ff8e9efb80c4e62bf5d39a66f9af66f72010f2d" translate="yes" xml:space="preserve">
          <source>Current date in Julian form</source>
          <target state="translated">当前日期,以朱利安形式</target>
        </trans-unit>
        <trans-unit id="38570a962a72c984faa65f99b9fe8bbed297680c" translate="yes" xml:space="preserve">
          <source>Current programming philosophy would prefer the use of the&lt;code&gt;EVALUATE&lt;/code&gt;statement to that of this form of the&lt;code&gt;GO TO&lt;/code&gt;statement.</source>
          <target state="translated">当前的编程原理更喜欢使用 &lt;code&gt;EVALUATE&lt;/code&gt; 语句而不是这种形式的 &lt;code&gt;GO TO&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="176c3c5df0bbd0c7ccd68b1562b9f4c3348a64ae" translate="yes" xml:space="preserve">
          <source>Currently, the only allowable value for the flags argument is 0. This argument may be specified either as a numeric literal or as a&lt;code&gt;PIC X(1) USAGE COMP-X&lt;/code&gt;data item.</source>
          <target state="translated">当前，flags参数的唯一允许值为0。此参数可以指定为数字文字或 &lt;code&gt;PIC X(1) USAGE COMP-X&lt;/code&gt; 数据项。</target>
        </trans-unit>
        <trans-unit id="93fe007c4c23a7d4870c091f49c3529c51d38ef8" translate="yes" xml:space="preserve">
          <source>Cyan (Turquoise): COB-COLOR-CYAN</source>
          <target state="translated">青色(绿松石)。COB-COLOR-CYAN</target>
        </trans-unit>
        <trans-unit id="d2b0ee310620d9febc825ce9071e2fb5b6a37cd7" translate="yes" xml:space="preserve">
          <source>D/d</source>
          <target state="translated">D/d</target>
        </trans-unit>
        <trans-unit id="cacf54f34dffa98ab8fe95ec01049b87cf34a8a2" translate="yes" xml:space="preserve">
          <source>DATA DIVISION Syntax</source>
          <target state="translated">DATA DIVISION 语法</target>
        </trans-unit>
        <trans-unit id="ef1ab2c530e1e7a4a273bb9ed22fe35098c7702a" translate="yes" xml:space="preserve">
          <source>DATA, DATA-POINTER, DATE, DATE-COMPILED, DATE-MODIFIED, DATE-OF-INTEGER, DATE-TO-YYYYMMDD, DATE-WRITTEN, DAY, DAY-OF-INTEGER, DAY-OF-WEEK, DAY-TO-YYYYDDD, DE, DEBUGGING, DECIMAL-POINT, DECLARATIVES, DEFAULT, DELETE, DELIMITED, DELIMITER, DEPENDING, DESCENDING, DESTINATION, DETAIL, DISABLE, DISC, DISK, DISPLAY, DISPLAY-OF, DIVIDE, DIVISION, DOWN, DUPLICATES, DYNAMIC</source>
          <target state="translated">DATA,DATA-POINTER,DATE,DATE-COMPILED,DATE-MODIFIED,DATE-OF-INTEGER,DATE-TO-YYYMMDD,DATE-WRITTEN,DAY,DAY-OF-INTEGER,DAY-OF-WEEK,DAY-TO-YYYDDD,DE,DEBUGGING,DECIMAL-POINT,DECLARATIVES,DEFAULT,DELETE,DELIMITED,DELIMITER,DEPENDING,DESCENDING,DESTINATION,DETAIL,DISC,DISK,DISPLAY,DISPLAY-OF,DIVIDE,DIVISION,DOWN,DUPLICATES,DYNAMIC......。</target>
        </trans-unit>
        <trans-unit id="9a7769dbf47324c33f9163090c128fdce266a34c" translate="yes" xml:space="preserve">
          <source>DATE-OF-INTEGER Function Syntax</source>
          <target state="translated">DATE-OF-INTEGER 函数语法</target>
        </trans-unit>
        <trans-unit id="de2d56241f31b520010f3bce0b98db0bbbf5b2cb" translate="yes" xml:space="preserve">
          <source>DATE-TO-YYYYMMDD Function Syntax</source>
          <target state="translated">DATE-TO-YYYMMDD 函数语法</target>
        </trans-unit>
        <trans-unit id="39bcedb8c2b80fd139b489090f66d6091874fd22" translate="yes" xml:space="preserve">
          <source>DAY-OF-INTEGER Function Syntax</source>
          <target state="translated">DAY-OF-INTEGER 函数语法</target>
        </trans-unit>
        <trans-unit id="2bf1dfe2e631bd8b0d7dad6f48c0cacb9a884526" translate="yes" xml:space="preserve">
          <source>DAY-TO-YYYYDDD Function Syntax</source>
          <target state="translated">函数语法 DAY-TO-YYYDDD。</target>
        </trans-unit>
        <trans-unit id="025121e8c60ec006f18d8b8d88589c258c15c1d7" translate="yes" xml:space="preserve">
          <source>DDDDEEEEEE</source>
          <target state="translated">DDDDEEEEEE</target>
        </trans-unit>
        <trans-unit id="86bb1aaff76c60b46fc6063e792d77c4344339b1" translate="yes" xml:space="preserve">
          <source>DECLARATIVES Syntax</source>
          <target state="translated">DECLARATIVES 语法</target>
        </trans-unit>
        <trans-unit id="143eef2ea0db77ce833000c49d3c0b7fd423279e" translate="yes" xml:space="preserve">
          <source>DELETE Syntax</source>
          <target state="translated">DELETE 语法</target>
        </trans-unit>
        <trans-unit id="3a15730e7f841dfe68e53a32b12047839a2d3fb6" translate="yes" xml:space="preserve">
          <source>DETAIL GROUP(S) [2]</source>
          <target state="translated">细节组[2]</target>
        </trans-unit>
        <trans-unit id="4f10c1a7a81f590cb0c5833f5f9e81467169d145" translate="yes" xml:space="preserve">
          <source>DISPLAY UPON COMMAND-LINE Syntax</source>
          <target state="translated">DISPLAY UPON COMMAND-LINE 命令行语法</target>
        </trans-unit>
        <trans-unit id="adda0092f73a761f60d98ab42f5c7b4bba54e2d5" translate="yes" xml:space="preserve">
          <source>DISPLAY UPON ENVIRONMENT-NAME Syntax</source>
          <target state="translated">DISPLAY UP ON ENVIRONMENT-NAME(显示环境名称)。</target>
        </trans-unit>
        <trans-unit id="dc0e227d85b3e8e67592171973f030e41c7ab926" translate="yes" xml:space="preserve">
          <source>DISPLAY UPON device Syntax</source>
          <target state="translated">DISPLAY UPON 设备</target>
        </trans-unit>
        <trans-unit id="6145b9122a8e41c787d9431bd205fd12fd53c5a1" translate="yes" xml:space="preserve">
          <source>DISPLAY screen-data-item Syntax</source>
          <target state="translated">DISPLAY screen-data-item 语法描述</target>
        </trans-unit>
        <trans-unit id="c274523a24ad6574ea39bdfb176f7732c4c4c3d8" translate="yes" xml:space="preserve">
          <source>DIVIDE BY GIVING Syntax</source>
          <target state="translated">DIVIDE BY GIVING 语法</target>
        </trans-unit>
        <trans-unit id="1719d6e667413941c4bdcd1de4638431f43816ff" translate="yes" xml:space="preserve">
          <source>DIVIDE INTO GIVING Syntax</source>
          <target state="translated">DIVIDE INTO GIVING 语法</target>
        </trans-unit>
        <trans-unit id="b020f4b6ba07306586627a0af3f4509d6885ff83" translate="yes" xml:space="preserve">
          <source>DIVIDE INTO Syntax</source>
          <target state="translated">分成语法</target>
        </trans-unit>
        <trans-unit id="542d08c7255dff568bdff9294205546046c0a7c5" translate="yes" xml:space="preserve">
          <source>Data Item</source>
          <target state="translated">数据项目</target>
        </trans-unit>
        <trans-unit id="b5ab5631945fc781f3a554ec97b7ea5c28882fb6" translate="yes" xml:space="preserve">
          <source>Data Retrieved</source>
          <target state="translated">检索数据</target>
        </trans-unit>
        <trans-unit id="86ce25bf2c845338976617d76d9424c933ce8444" translate="yes" xml:space="preserve">
          <source>Data descriptions of this form do not actually allocate any storage &amp;mdash; they merely define a name (&amp;lt;</source>
          <target state="translated">这种形式的数据描述实际上并没有分配任何存储空间，它们只是定义了一个名称（&amp;lt;</target>
        </trans-unit>
        <trans-unit id="e82b1d0242f8c91a364756e74c764b6e3af9b59f" translate="yes" xml:space="preserve">
          <source>Data items declared with the&lt;code&gt;ANY LENGTH&lt;/code&gt;attribute have no fixed compile-time length. Such items may only be defined in the linkage section of a subprogram as they may only serve as subroutine argument descriptions. These items must have a&lt;code&gt;PICTURE&lt;/code&gt;(see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) clause that specifies exactly one A, X or 9 symbol.</source>
          <target state="translated">用 &lt;code&gt;ANY LENGTH&lt;/code&gt; 属性声明的数据项没有固定的编译时长度。此类项目只能在子程序的链接部分中定义，因为它们只能用作子例程参数描述。这些项目必须具有 &lt;code&gt;PICTURE&lt;/code&gt; （请参阅&lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;）子句，该子句恰好指定一个A，X或9符号。</target>
        </trans-unit>
        <trans-unit id="8ff9e95bc3e45b129ac52c4861ceb28707b8b1d0" translate="yes" xml:space="preserve">
          <source>Data items declared with&lt;code&gt;BASED&lt;/code&gt;are allocated no storage at compilation time. At run-time, the&lt;code&gt;ALLOCATE&lt;/code&gt;(see &lt;a href=&quot;#ALLOCATE&quot;&gt;ALLOCATE&lt;/a&gt;) or&lt;code&gt;SET ADDRESS&lt;/code&gt;(see &lt;a href=&quot;#SET-ADDRESS&quot;&gt;SET ADDRESS&lt;/a&gt;) statements are used to allocate space for and (optionally) initialize such items.</source>
          <target state="translated">使用 &lt;code&gt;BASED&lt;/code&gt; 声明的数据项在编译时不会分配任何存储空间。在运行时，使用 &lt;code&gt;ALLOCATE&lt;/code&gt; （请参阅&lt;a href=&quot;#ALLOCATE&quot;&gt;ALLOCATE&lt;/a&gt;）或 &lt;code&gt;SET ADDRESS&lt;/code&gt; （请参阅&lt;a href=&quot;#SET-ADDRESS&quot;&gt;SET ADDRESS&lt;/a&gt;）语句为此类项目分配空间并（可选）初始化。</target>
        </trans-unit>
        <trans-unit id="3884223bd8738175ccb76e30292953182185f26d" translate="yes" xml:space="preserve">
          <source>Data items defined in a calling program may be passed to either type of called program (subroutine or user-defined function) as arguments.</source>
          <target state="translated">在调用程序中定义的数据项可以作为参数传递给任何一种类型的被调用程序(子程序或用户定义的函数)。</target>
        </trans-unit>
        <trans-unit id="8b6be4a0a08f89796b4ca060304e3df78e6642bf" translate="yes" xml:space="preserve">
          <source>Data items defined in the screen section describe input, output or combination screen layouts to be used with&lt;code&gt;ACCEPT screen-data-item&lt;/code&gt;statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;) or&lt;code&gt;DISPLAY screen-data-item&lt;/code&gt;statement (see &lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY screen-data-item&lt;/a&gt;) statements. These screen layouts may define the entire available screen area or any subset of it.</source>
          <target state="translated">屏幕部分中定义的数据项描述了与 &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; 语句（请参见&lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;）或 &lt;code&gt;DISPLAY screen-data-item&lt;/code&gt; 语句（请参见&lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY screen-data-&lt;/a&gt;）一起使用的输入，输出或组合屏幕布局。item）语句。这些屏幕布局可以定义整个可用屏幕区域或其任何子集。</target>
        </trans-unit>
        <trans-unit id="5b209ac3623f15088290faf41d529558938a6bd3" translate="yes" xml:space="preserve">
          <source>Data items defined within the working-storage section are automatically initialized once &amp;mdash; as the program in which the data is defined is loaded into memory. Subprograms may be loaded into memory more than once (see the&lt;code&gt;CANCEL&lt;/code&gt;statement (see &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;)), in which case initialization will happen each time they are loaded. See &lt;a href=&quot;#Data-Initialization&quot;&gt;Data Initialization&lt;/a&gt;, for a discussion of the initialization rules.</source>
          <target state="translated">在工作存储部分中定义的数据项将自动初始化一次，因为定义了数据的程序已加载到内存中。子程序可能多次加载到内存中（请参阅 &lt;code&gt;CANCEL&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;）），在这种情况下，每次加载子程序时都会进行初始化。有关初始化规则的讨论，请参见&lt;a href=&quot;#Data-Initialization&quot;&gt;数据初始化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4eb8574d2d5270d2d786dec0a24f5040d14d6919" translate="yes" xml:space="preserve">
          <source>Data items that have the&lt;code&gt;UNSIGNED&lt;/code&gt;</source>
          <target state="translated">具有未 &lt;code&gt;UNSIGNED&lt;/code&gt; 数据项</target>
        </trans-unit>
        <trans-unit id="b9af005425ba8ce8de1a932e2c2f2ab684e4ed8c" translate="yes" xml:space="preserve">
          <source>Data items with an explicit&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause in their definition will be initialized to that specific value.</source>
          <target state="translated">在其定义中具有显式 &lt;code&gt;VALUE&lt;/code&gt; （请参阅&lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;）子句的数据项将被初始化为该特定值。</target>
        </trans-unit>
        <trans-unit id="25d47c3faf24644ac0e22641a7e663390a36c7aa" translate="yes" xml:space="preserve">
          <source>Data items with level numbers 01 (Constants), 66, 78 and 88 may be used in the screen section; they have the same syntax, rules and usage as they do in the other data division sections.</source>
          <target state="translated">等级号为01(常量)、66、78和88的数据项可以在屏幕部分使用;它们的语法、规则和用法与其他数据划分部分相同。</target>
        </trans-unit>
        <trans-unit id="3f037b50f5ed4565ce4707a24021f4f6ad083ed5" translate="yes" xml:space="preserve">
          <source>Data-pointer contains an address that is out of bounds</source>
          <target state="translated">数据指针包含一个越界的地址。</target>
        </trans-unit>
        <trans-unit id="874809dfddadcc0363d1a9a37ac20f4611145b1a" translate="yes" xml:space="preserve">
          <source>Declarative procedures may not reference any other procedures defined outside the scope of DECLARATIVES.</source>
          <target state="translated">宣告性程序不得引用在《宣言》范围之外界定的任何其他程序。</target>
        </trans-unit>
        <trans-unit id="d14e2f78a3303228220a36dc985b5fd5e385137b" translate="yes" xml:space="preserve">
          <source>Defined by the quantity of&lt;code&gt;9&lt;/code&gt; and the presence or absence of an&lt;code&gt;S&lt;/code&gt;in the PICTURE</source>
          <target state="translated">通过量定义 &lt;code&gt;9&lt;/code&gt; 和存在或不存在的 &lt;code&gt;S&lt;/code&gt; 在图片</target>
        </trans-unit>
        <trans-unit id="1e681574ae7448c8ae4c05d776be5265b2dc953d" translate="yes" xml:space="preserve">
          <source>Defined by the quantity of&lt;code&gt;9&lt;/code&gt; and the presence or absence of an&lt;code&gt;S&lt;/code&gt;in the&lt;code&gt;PICTURE&lt;/code&gt;</source>
          <target state="translated">通过量定义 &lt;code&gt;9&lt;/code&gt; 和存在或不存在的 &lt;code&gt;S&lt;/code&gt; 在 &lt;code&gt;PICTURE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3721726af464447c08ddb23c2de0ce50d614e3dd" translate="yes" xml:space="preserve">
          <source>Defines an implied digit position that will be considered to be a zero when the data item is referenced at run-time. This symbol is used to allow data items that will contain very large values to be allocated using less storage by assuming a certain number of trailing zeros (one per&lt;code&gt;P&lt;/code&gt; to exist at the end of values.</source>
          <target state="translated">定义一个隐含的数字位置，当在运行时引用数据项时，该位置将被视为零。该符号用于通过假设一定数量的尾随零（值的末尾存在每个 &lt;code&gt;P&lt;/code&gt; 个)来允许使用较少的存储量分配包含非常大的值的数据项。</target>
        </trans-unit>
        <trans-unit id="d2dadb60fe73f669fa3a07340c506372af50e9c1" translate="yes" xml:space="preserve">
          <source>Defines storage reserved for a single alphabetic character &lt;code&gt;A&lt;/code&gt;&lt;code&gt;Z&lt;/code&gt;&lt;code&gt;a&lt;/code&gt;&lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">定义为单个字母字符 &lt;code&gt;A&lt;/code&gt; &lt;code&gt;Z&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;z&lt;/code&gt; 保留的存储。</target>
        </trans-unit>
        <trans-unit id="cc276340305e669eb0c75e2233fed96937f0eb10" translate="yes" xml:space="preserve">
          <source>Defines storage reserved for a single alphanumeric character (any character).</source>
          <target state="translated">定义为单个字母数字字符(任何字符)保留的存储空间。</target>
        </trans-unit>
        <trans-unit id="9157b25b7fe6ae0f7d0e3ba566a50c8e263af1e0" translate="yes" xml:space="preserve">
          <source>Defines storage reserved for a single character in the computer&amp;rsquo;s &amp;rsquo;</source>
          <target state="translated">定义为计算机的&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="94ae1e544866ccd53a2d46a1a530f0a06f98b727" translate="yes" xml:space="preserve">
          <source>Defines storage reserved for a single numeric digit character &lt;code&gt;0&lt;/code&gt;&lt;code&gt;9&lt;/code&gt;.</source>
          <target state="translated">定义为单个数字字符 &lt;code&gt;0&lt;/code&gt; &lt;code&gt;9&lt;/code&gt; 保留的存储。</target>
        </trans-unit>
        <trans-unit id="4c35955c5a43713921be58f39b4f9f08b952ef23" translate="yes" xml:space="preserve">
          <source>Defining a control hierarchy (via&lt;code&gt;CONTROLS ARE&lt;/code&gt; that does not match the actual sequence in which data will be processed is a great way to guarantee a &quot;broken&quot; report. I&amp;rsquo;ll show you an example in a later section.</source>
          <target state="translated">定义控件层次结构（通过 &lt;code&gt;CONTROLS ARE&lt;/code&gt; 与数据处理的实际顺序不匹配）是保证&amp;ldquo;破损&amp;rdquo;报告的一种好方法。我将在下一节中向您展示一个示例。</target>
        </trans-unit>
        <trans-unit id="86f4d7d5ec62e8d3cd6d42936730cd899552e6b1" translate="yes" xml:space="preserve">
          <source>Deleting directories (folders)</source>
          <target state="translated">删除目录(文件夹)</target>
        </trans-unit>
        <trans-unit id="184170aedafad0bad24b165d0963d2623119dff1" translate="yes" xml:space="preserve">
          <source>Deleting files</source>
          <target state="translated">删除文件</target>
        </trans-unit>
        <trans-unit id="a300dcf45b8bb3ac35bf8bf6fa05fb9627dec545" translate="yes" xml:space="preserve">
          <source>Depending upon which source format mode the compiler is in, you will need to follow various rules for the format mode currently in effect. These rules are presented in the upcoming paragraphs.</source>
          <target state="translated">根据编译器所处的源格式模式,你需要遵循当前有效的格式模式的各种规则。这些规则将在接下来的段落中介绍。</target>
        </trans-unit>
        <trans-unit id="e1d3403c95ff976211a614c7aff47a8b06f0d474" translate="yes" xml:space="preserve">
          <source>Depends on number of&lt;code&gt;9&lt;/code&gt; in the&lt;code&gt;PICTURE&lt;/code&gt;and the&lt;code&gt;binary-size&lt;/code&gt;setting of the configuration file used to compile the program</source>
          <target state="translated">取决于数 &lt;code&gt;9&lt;/code&gt; 在 &lt;code&gt;PICTURE&lt;/code&gt; 和 &lt;code&gt;binary-size&lt;/code&gt; 的配置文件的设置中使用的编译程序</target>
        </trans-unit>
        <trans-unit id="8f554af0cabf84f3acc6bcb170a806e225d3ade1" translate="yes" xml:space="preserve">
          <source>Depends on&lt;code&gt;PICTURE&lt;/code&gt; One character per X, A, 9, period, $, Z, 0, *, S (if&lt;code&gt;SEPARATE CHARACTER&lt;/code&gt;specified), +, - or B symbol in&lt;code&gt;PICTURE&lt;/code&gt; Add 2 more bytes if the&lt;code&gt;DB&lt;/code&gt;or&lt;code&gt;CR&lt;/code&gt;editing symbol is used</source>
          <target state="translated">取决于 &lt;code&gt;PICTURE&lt;/code&gt; -每个X，A，9，周期，$，Z，0的一个字符，*，S（如果 &lt;code&gt;SEPARATE CHARACTER&lt;/code&gt; 指定），+， -中或B符号 &lt;code&gt;PICTURE&lt;/code&gt; 添加2个更多的字节，如果 &lt;code&gt;DB&lt;/code&gt; 或 &lt;code&gt;CR&lt;/code&gt; 编辑符号用来</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="a7bc7ee00f8b51dc232f39ec929df41c6a0ebda7" translate="yes" xml:space="preserve">
          <source>Despite what the name of this routine might make you believe, this routine is more than just a simple &quot;rename&quot; &amp;mdash; it will actually move the file supplied as the 1st argument to the file specified as the 2nd argument. Think of it as a two-step sequence, first copying the &amp;lt;</source>
          <target state="translated">尽管您可以相信该例程的名称，但是该例程不仅仅是一个简单的&amp;ldquo;重命名&amp;rdquo;，它实际上会将作为第一个参数提供的文件移动到指定为第二个参数的文件。将其视为两个步骤，首先复制&amp;lt;</target>
        </trans-unit>
        <trans-unit id="6dc01a0b93964e7ed3110112972c2448074cd5a5" translate="yes" xml:space="preserve">
          <source>Despite what you&amp;rsquo;ve seen here, the more complex the programming logic being implemented, the more concise the Java code will appear to be, even compared to 2002-standard COBOL. That conciseness comes with a price though &amp;mdash; program code readability. Java (or C or C++ or C#) programs are generally intelligible only to trained programmers. COBOL programs can, however, be quite understandable by non-programmers. This is actually a side-effect of the &quot;wordiness&quot; of the language, where COBOL statements use natural English words to describe their actions. This inherent readability has come in handy many times throughout my career when I&amp;rsquo;ve had to learn obscure business (or legal) processes by reading the COBOL program code that supports them.</source>
          <target state="translated">尽管您在这里看到了什么，但实现的编程逻辑越复杂，即使与2002年标准的COBOL相比，Java代码也将显得更加简洁。简明扼要的代价是程序代码的可读性。 Java（或C或C ++或C＃）程序通常只有经过培训的程序员才能理解。但是，非程序员可以完全理解COBOL程序。这实际上是语言&amp;ldquo;冗长&amp;rdquo;的副作用，COBOL语句使用自然的英语单词来描述其行为。在我的整个职业生涯中，这种固有的可读性已经派上了很多用场，当时我不得不通过阅读支持它们的COBOL程序代码来学习晦涩的业务（或法律）流程。</target>
        </trans-unit>
        <trans-unit id="7d18a0bca02af71f36038a10035b4fe89b253e6e" translate="yes" xml:space="preserve">
          <source>Detail Group</source>
          <target state="translated">详细组</target>
        </trans-unit>
        <trans-unit id="fc513aa1c1486f07867ac9c63a186583402ee0ec" translate="yes" xml:space="preserve">
          <source>Detail Report</source>
          <target state="translated">详细报告</target>
        </trans-unit>
        <trans-unit id="c352d575e112605537ad32d24ea8d1abed42a987" translate="yes" xml:space="preserve">
          <source>Determining how many arguments were passed to a subroutine</source>
          <target state="translated">确定传递给子程序的参数数量</target>
        </trans-unit>
        <trans-unit id="a5a74a6df09278b88cb6ea23b7d7f2570c33babf" translate="yes" xml:space="preserve">
          <source>Device</source>
          <target state="translated">Device</target>
        </trans-unit>
        <trans-unit id="b4bdf8d06c8ee9447b53a8835fd50fd6f2691a97" translate="yes" xml:space="preserve">
          <source>Did you notice that there are two each of&lt;code&gt;Year&lt;/code&gt;&lt;code&gt;Month&lt;/code&gt;and&lt;code&gt;Day&lt;/code&gt;data names defined? That&amp;rsquo;s perfectly legal, provided that each can be uniquely&lt;code&gt;qualified&lt;/code&gt;so as to be distinct from the other. Take for example the&lt;code&gt;Year&lt;/code&gt;items. One is defined as part of the&lt;code&gt;From-Date&lt;/code&gt;data item while the other is defined as part of the &quot;To-Date&quot; data item. In COBOL, we would actually code references to these two data items as either&lt;code&gt;Year OF From-Date&lt;/code&gt;and&lt;code&gt;Year OF To-Date&lt;/code&gt;or&lt;code&gt;Year IN From-Date&lt;/code&gt;and&lt;code&gt;Year IN To-Date&lt;/code&gt;(COBOL allows either&lt;code&gt;IN&lt;/code&gt;or&lt;code&gt;OF&lt;/code&gt;to be used). Since these references would clarify any confusion to us as to which&lt;code&gt;Year&lt;/code&gt;might be referenced, the GnuCOBOL compiler won&amp;rsquo;t be confused either.</source>
          <target state="translated">您是否注意到分别定义了 &lt;code&gt;Year&lt;/code&gt; &lt;code&gt;Month&lt;/code&gt; 和&amp;ldquo; &lt;code&gt;Day&lt;/code&gt; 两个数据名称？这是完全合法的，只要每个人都可以唯一地具有 &lt;code&gt;qualified&lt;/code&gt; ，从而彼此区别即可。以 &lt;code&gt;Year&lt;/code&gt; 项目为例。一个定义为 &lt;code&gt;From-Date&lt;/code&gt; 数据项的一部分，另一个定义为&amp;ldquo; To-Date&amp;rdquo;数据项的一部分。在COBOL中，我们实际上将对这两个数据项的引用进行编码，例如 &lt;code&gt;Year OF From-Date&lt;/code&gt; 和 &lt;code&gt;Year OF To-Date&lt;/code&gt; 或 &lt;code&gt;Year IN From-Date&lt;/code&gt; 和 &lt;code&gt;Year IN To-Date&lt;/code&gt; （COBOL允许 &lt;code&gt;IN&lt;/code&gt; 或 &lt;code&gt;OF&lt;/code&gt; 要使用的）。由于这些引用将使我们澄清可能引用哪个 &lt;code&gt;Year&lt;/code&gt; 的困惑，因此GnuCOBOL编译器也不会感到困惑。</target>
        </trans-unit>
        <trans-unit id="3dae4df8e307eadc33cccfbf09afcf7803b28a27" translate="yes" xml:space="preserve">
          <source>Did you notice the output showing the contents of &quot;Arg1&quot; after the subroutine was called? Those contents were unchanged! The subroutine</source>
          <target state="translated">你是否注意到子程序被调用后,输出显示 &quot;Arg1 &quot;的内容?这些内容没有变化 子程序</target>
        </trans-unit>
        <trans-unit id="6db57f7358d87d80d9ffe675eab1fa80c2597c75" translate="yes" xml:space="preserve">
          <source>Direct program execution syntax is as follows:</source>
          <target state="translated">直接程序执行语法如下。</target>
        </trans-unit>
        <trans-unit id="f3a08a300c1fa7c7b7c3869e07803b1ee488a676" translate="yes" xml:space="preserve">
          <source>Directly executable form</source>
          <target state="translated">可直接执行的形式</target>
        </trans-unit>
        <trans-unit id="bbbec44416269797757a1579d0b1247911acd066" translate="yes" xml:space="preserve">
          <source>Division</source>
          <target state="translated">Division</target>
        </trans-unit>
        <trans-unit id="50a314209c54751015d5ea87733dbccc98864d31" translate="yes" xml:space="preserve">
          <source>Division by zero</source>
          <target state="translated">除以零</target>
        </trans-unit>
        <trans-unit id="3c91054f46891fec1cae6331f29fdbccb03d6a39" translate="yes" xml:space="preserve">
          <source>Divisions</source>
          <target state="translated">Divisions</target>
        </trans-unit>
        <trans-unit id="768a18bcfd50a4cdbad454ea5c1997d92ec2f9ed" translate="yes" xml:space="preserve">
          <source>Do not specify the &quot;.so&quot; or &quot;.dll&quot; extension on the program name. The</source>
          <target state="translated">不要在程序名上指定&quot;.so &quot;或&quot;.dll &quot;后缀。在程序名上不要指定&quot;.so &quot;或&quot;.dll &quot;的扩展名。</target>
        </trans-unit>
        <trans-unit id="fa34cf297b7f3240b7cd6005ab3bf76a3b53feb2" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t bother worrying about it at compile-time. Use the&lt;code&gt;INITIALIZE&lt;/code&gt;(see &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt;) to initialize all data item occurrences in a table (at run-time) to their data-type-specific default values (numerics: 0, alphabetic and alphanumerics: spaces).</source>
          <target state="translated">不要在编译时担心它。使用 &lt;code&gt;INITIALIZE&lt;/code&gt; （请参阅&lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt;）将表中所有数据项的出现（在运行时）初始化为其特定于数据类型的默认值（数字：0，字母和字母数字：空格）。</target>
        </trans-unit>
        <trans-unit id="a1aca23a3aa1e9e5ee434e5c251ba724ccb58be9" translate="yes" xml:space="preserve">
          <source>Down-Arrow was pressed</source>
          <target state="translated">按下箭头</target>
        </trans-unit>
        <trans-unit id="c121671e83c83f33db959abee0785d1ae6b8351f" translate="yes" xml:space="preserve">
          <source>During the presentation of the&lt;code&gt;CONTROL FOOTING&lt;/code&gt;groups, any necessary&lt;code&gt;PAGE FOOTING&lt;/code&gt;and&lt;code&gt;PAGE HEADING&lt;/code&gt;groups will be presented as well.</source>
          <target state="translated">在 &lt;code&gt;CONTROL FOOTING&lt;/code&gt; 组的呈现过程中，还将显示所有必要的 &lt;code&gt;PAGE FOOTING&lt;/code&gt; 和 &lt;code&gt;PAGE HEADING&lt;/code&gt; 组。</target>
        </trans-unit>
        <trans-unit id="a70150b4c0486379b53b2bc61cc3b9e1cb791978" translate="yes" xml:space="preserve">
          <source>Dynamic Subprogram</source>
          <target state="translated">动态子程序</target>
        </trans-unit>
        <trans-unit id="6eb0f764570bb14c352993b6d496277e64157960" translate="yes" xml:space="preserve">
          <source>Dynamically-loadable</source>
          <target state="translated">Dynamically-loadable</target>
        </trans-unit>
        <trans-unit id="1348d390510adbb26537a28adfa74ec9b8165ca8" translate="yes" xml:space="preserve">
          <source>Dynamically-loadable executable form</source>
          <target state="translated">动态加载的可执行形式</target>
        </trans-unit>
        <trans-unit id="eb8d20220991838c8009592b6e63139e1b78c3ba" translate="yes" xml:space="preserve">
          <source>Dynamically-loadable modules may be removed from memory via the&lt;code&gt;CANCEL&lt;/code&gt;statement (see &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;).</source>
          <target state="translated">可通过 &lt;code&gt;CANCEL&lt;/code&gt; 语句从内存中删除可动态加载的模块（请参阅&lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="901bdca5f99ca3f0f8c3c45d17df5cd4768b3649" translate="yes" xml:space="preserve">
          <source>Dynamically-loadable modules will be named &quot;xxxxxxxx.dll&quot; on a Windows system, &quot;xxxxxxxx.so&quot; on a Unix system or &quot;xxxxxxxx.dylib&quot; on an OSX system, where &quot;xxxxxxxx&quot; exactly matches, including the usage of upper- and lower-case letters, the primary entry-point name &lt;code&gt;PROGRAM-ID&lt;/code&gt;or&lt;code&gt;FUNCTION-ID&lt;/code&gt; or an alternate entry point name defined via the&lt;code&gt;ENTRY&lt;/code&gt;statement (see &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt;) of any one of the GnuCOBOL programs included in that module.</source>
          <target state="translated">可动态加载的模块在Windows系统上将被命名为&amp;ldquo; xxxxxxxx.dll&amp;rdquo;，在Unix系统上将被命名为&amp;ldquo; xxxxxxxx.so&amp;rdquo;，在OSX系统上将被命名为&amp;ldquo; xxxxxxxx.dylib&amp;rdquo;，其中&amp;ldquo; xxxxxxxx&amp;rdquo;完全匹配，包括使用小写字母，主要入口点名称 &lt;code&gt;PROGRAM-ID&lt;/code&gt; 或 &lt;code&gt;FUNCTION-ID&lt;/code&gt; 或通过该模块中包含的任何一个GnuCOBOL程序的 &lt;code&gt;ENTRY&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt;）定义的备用入口点名称。</target>
        </trans-unit>
        <trans-unit id="1ba95e0268763043cd1e34a29d8c36e35ba2d644" translate="yes" xml:space="preserve">
          <source>Dynamically-loaded subprograms are executed (from a COBOL syntax point of view) just like any other subprograms. What makes them unique, however, is that they are loaded into memory only when they are actually used the first time during the execution of a program.</source>
          <target state="translated">动态加载子程序的执行(从COBOL语法的角度看)就像其他子程序一样。但它们的独特之处在于,只有在程序执行过程中第一次实际使用时,它们才会被加载到内存中。</target>
        </trans-unit>
        <trans-unit id="030dcb4209a1709b74f2d59ef6da0355f006e9c6" translate="yes" xml:space="preserve">
          <source>E Function Syntax</source>
          <target state="translated">E 功能语法</target>
        </trans-unit>
        <trans-unit id="765a70eecffa68061065b3955fd85a92329d8392" translate="yes" xml:space="preserve">
          <source>E, EBCDIC, EC, ECHO, EGI, ELSE, EMI, EMPTY-CHECK, ENABLE, END, END-ACCEPT, END-ADD, END-CALL, END-CHAIN, END-COMPUTE, END-DELETE, END-DISPLAY, END-DIVIDE, END-EVALUATE, END-IF, END-MULTIPLY, END-OF-PAGE, END-PERFORM, END-READ, END-RECEIVE, END-RETURN, END-REWRITE, END-SEARCH, END-START, END-STRING, END-SUBTRACT, END-UNSTRING, END-WRITE, ENTRY, ENTRY-CONVENTION, ENVIRONMENT, ENVIRONMENT-NAME, ENVIRONMENT-VALUE, EO, EOL, EOP, EOS, EQUAL, EQUALS, ERASE, ERROR, ESCAPE, ESI, EVALUATE, EXCEPTION, EXCEPTION-FILE, EXCEPTION-FILE-N, EXCEPTION-LOCATION, EXCEPTION-LOCATION-N, EXCEPTION-OBJECT, EXCEPTION-STATEMENT, EXCEPTION-STATUS, EXCLUSIVE, EXIT, EXP, EXP10, EXPANDS, EXTEND, EXTERN, EXTERNAL</source>
          <target state="translated">E,EBCDIC,EC,ECHO,EGI,ELSE,EMI,EMPTY-CHECK,ENABLE,END,END-ACCEPT,END-ADD,END-CALL,END-CHAIN,END-COMPUTE,END-DELETE,END-DISPLAY,END-DIVIDE,END-VALUATE,END-IF,END-MULTIPLY,END-OF-Page,END-PERFORM,END-READ,END-RECEIVE,END-RETURN,END-WRITE,END-SEARCH,END-START,END-STRING,END-SUBTRACT,END-UNSTRING,END-WRITE,ENTRY。ENTRY-CONVENTION,ENVIRONMENT,ENVIRONMENT-NAME,ENVIRONMENT-VALUE,EO,EOL,EOP,EOS,EQUAL,EQUALS,ERASE,ERROR,ESCAPE,ESI,EVALUATE,EXCEPTION,EXCEPTION-FILE,EXCEPTION-FILE-N,EXCEPTION-LOCATION,EXCEPTION-LOCATION-N,EXCEPTION-OBJECT,EXCEPTION-STATEMENT,EXCEPTION-STATUS,EXCLUSIVE,EXIT,EXP,EXP10,EXPANDS,EXTEND,EXTERN,EXTERNAL</target>
        </trans-unit>
        <trans-unit id="5effca06a41a1d22ea816cb82b7101e0e5ef5985" translate="yes" xml:space="preserve">
          <source>EC-ARGUMENT-FUNCTION</source>
          <target state="translated">EC-ARGUMENT-FUNCTION</target>
        </trans-unit>
        <trans-unit id="6f64130193ed68a9cf43ad043a1db86b51b7732f" translate="yes" xml:space="preserve">
          <source>EC-BOUND-ODO</source>
          <target state="translated">EC-BOUND-ODO</target>
        </trans-unit>
        <trans-unit id="7758bece637db0db2aa2eaf68b0a5ca23becb2f7" translate="yes" xml:space="preserve">
          <source>EC-BOUND-PTR</source>
          <target state="translated">EC-BOUND-PTR</target>
        </trans-unit>
        <trans-unit id="35ce6218474a39cc348cc1b04f5cfeb6a7093fba" translate="yes" xml:space="preserve">
          <source>EC-BOUND-REF-MOD</source>
          <target state="translated">EC-BOUND-REF-MOD</target>
        </trans-unit>
        <trans-unit id="b180672a32ac9f504a398165500845e145ddac86" translate="yes" xml:space="preserve">
          <source>EC-BOUND-SUBSCRIPT</source>
          <target state="translated">EC-BOUND-SUBSCRIPT</target>
        </trans-unit>
        <trans-unit id="47bd90096a9329462194bb3efc2ec0777c1cc384" translate="yes" xml:space="preserve">
          <source>EC-DATA-INCOMPATIBLE</source>
          <target state="translated">EC-DATA-INCOMPATIBLE</target>
        </trans-unit>
        <trans-unit id="599ae453fdf489e4c5507f42fe19ed6e9f07ec45" translate="yes" xml:space="preserve">
          <source>EC-I-O</source>
          <target state="translated">EC-I-O</target>
        </trans-unit>
        <trans-unit id="37a26c3979aa50c34cd4c0ac08b0ca77f51e47c2" translate="yes" xml:space="preserve">
          <source>EC-I-O-AT-END</source>
          <target state="translated">EC-I-O-AT-END</target>
        </trans-unit>
        <trans-unit id="7695dbca75bfb201f44d69c5f1d6236c16575ead" translate="yes" xml:space="preserve">
          <source>EC-I-O-EOP</source>
          <target state="translated">EC-I-O-EOP</target>
        </trans-unit>
        <trans-unit id="f5e8f83ff584e8d475c4cd5b0545216bba034cd9" translate="yes" xml:space="preserve">
          <source>EC-I-O-FILE-SHARING</source>
          <target state="translated">EC-I-O-FILE-SHARING</target>
        </trans-unit>
        <trans-unit id="6f67df493e29d40d1c466d3532abcf2151feb116" translate="yes" xml:space="preserve">
          <source>EC-I-O-IMP</source>
          <target state="translated">EC-I-O-IMP</target>
        </trans-unit>
        <trans-unit id="2bedcca397988fdafc22d2b1db2fe596c55b7abc" translate="yes" xml:space="preserve">
          <source>EC-I-O-INVALID-KEY</source>
          <target state="translated">EC-I-O-INVALID-KEY</target>
        </trans-unit>
        <trans-unit id="d37a719c5ec9cc280a3423d35c359f53361556cf" translate="yes" xml:space="preserve">
          <source>EC-I-O-LOGIC-ERROR</source>
          <target state="translated">EC-I-O-LOGIC-ERROR</target>
        </trans-unit>
        <trans-unit id="22c38171abcae25c72623446be7e409f53d9f1cb" translate="yes" xml:space="preserve">
          <source>EC-I-O-PERMANENT-ERROR</source>
          <target state="translated">EC-I-O-PERMANENT-ERROR</target>
        </trans-unit>
        <trans-unit id="e57f56d25192a637896e66e92bcae79d33a72575" translate="yes" xml:space="preserve">
          <source>EC-I-O-RECORD-OPERATION</source>
          <target state="translated">EC-I-O-RECORD-OPERATION</target>
        </trans-unit>
        <trans-unit id="f232808a3899bdcf8d909765f6e715db467fc08e" translate="yes" xml:space="preserve">
          <source>EC-IMP-ACCEPT</source>
          <target state="translated">EC-IMP-ACCEPT</target>
        </trans-unit>
        <trans-unit id="5b7c6f8d33dccc651230c71c804f70a23dfd3fb3" translate="yes" xml:space="preserve">
          <source>EC-IMP-DISPLAY</source>
          <target state="translated">EC-IMP-DISPLAY</target>
        </trans-unit>
        <trans-unit id="0348c4c249e24b62ec6318d07a0918b290c97136" translate="yes" xml:space="preserve">
          <source>EC-OVERFLOW</source>
          <target state="translated">EC-OVERFLOW</target>
        </trans-unit>
        <trans-unit id="39873e8196f86a467a7a5394f6dae0df7cb7ec49" translate="yes" xml:space="preserve">
          <source>EC-OVERFLOW-STRING</source>
          <target state="translated">EC-OVERFLOW-STRING</target>
        </trans-unit>
        <trans-unit id="a912b54889e1360e1822bf001ecc4bcce0057de1" translate="yes" xml:space="preserve">
          <source>EC-OVERFLOW-UNSTRING</source>
          <target state="translated">EC-OVERFLOW-UNSTRING</target>
        </trans-unit>
        <trans-unit id="642796743342819c46389d927083877ea07d115a" translate="yes" xml:space="preserve">
          <source>EC-PROGRAM-NOT-FOUND</source>
          <target state="translated">EC-PROGRAM-NOT-FOUND</target>
        </trans-unit>
        <trans-unit id="fbeac2b7df577454ec16676f61d4d1c2dd9e4b66" translate="yes" xml:space="preserve">
          <source>EC-RANGE-INSPECT-SIZE</source>
          <target state="translated">EC-RANGE-INSPECT-SIZE</target>
        </trans-unit>
        <trans-unit id="44603209bfd2fe1e4c13a73d2183c6926c88fa44" translate="yes" xml:space="preserve">
          <source>EC-SIZE</source>
          <target state="translated">EC-SIZE</target>
        </trans-unit>
        <trans-unit id="d4c83319eed34736080dc026b83369dc0ab0f9e0" translate="yes" xml:space="preserve">
          <source>EC-SIZE-OVERFLOW</source>
          <target state="translated">EC-SIZE-OVERFLOW</target>
        </trans-unit>
        <trans-unit id="995fc7c1e9f2389fb223769d4efff5b6078bcd23" translate="yes" xml:space="preserve">
          <source>EC-SIZE-TRUNCATION</source>
          <target state="translated">EC-SIZE-TRUNCATION</target>
        </trans-unit>
        <trans-unit id="2b0855452a33f27ee0e3591f258c880264670a28" translate="yes" xml:space="preserve">
          <source>EC-SIZE-ZERO-DIVIDE</source>
          <target state="translated">EC-SIZE-ZERO-DIVIDE</target>
        </trans-unit>
        <trans-unit id="74425f6db6d6bbce95e0144ef83b5f7377196c52" translate="yes" xml:space="preserve">
          <source>EC-STORAGE-NOT-ALLOC</source>
          <target state="translated">EC-STORAGE-NOT-ALLOC</target>
        </trans-unit>
        <trans-unit id="2bcce8379324db20847e97d1dbdd7613e1e978ce" translate="yes" xml:space="preserve">
          <source>EC-STORAGE-NOT-AVAIL</source>
          <target state="translated">EC-STORAGE-NOT-AVAIL</target>
        </trans-unit>
        <trans-unit id="af80c9b4c454f7d961a11331ae6fb9445df82b42" translate="yes" xml:space="preserve">
          <source>EMPTY-CHECK Attribute Syntax</source>
          <target state="translated">EMPTY-CHECK 属性 语法</target>
        </trans-unit>
        <trans-unit id="f84802327b6f04b6ca9f5ad265dd6839e26a2682" translate="yes" xml:space="preserve">
          <source>ENTER key pressed</source>
          <target state="translated">回车键</target>
        </trans-unit>
        <trans-unit id="1737c25f7adeb7b4b0cf8beddc7007f6c44cee3c" translate="yes" xml:space="preserve">
          <source>ENTRY Syntax</source>
          <target state="translated">ENTRY 语法</target>
        </trans-unit>
        <trans-unit id="c8d3810b7c62cddd57ba48b6b05b3d7aaeb1d1c3" translate="yes" xml:space="preserve">
          <source>ENTRY-Argument</source>
          <target state="translated">ENTRY-Argument</target>
        </trans-unit>
        <trans-unit id="56bc597bd92048db144c774480c4ac8ebc388d8a" translate="yes" xml:space="preserve">
          <source>ENTRY-Argument Syntax</source>
          <target state="translated">ENTRY-参数语法</target>
        </trans-unit>
        <trans-unit id="aeefff7bdd0630e9dbc6edcccf44b29d8e1b5f66" translate="yes" xml:space="preserve">
          <source>ENVIRONMENT DIVISION Syntax</source>
          <target state="translated">环境部 句法</target>
        </trans-unit>
        <trans-unit id="10be88097f9b48fa4b8f5918ab59b09ba828e0cf" translate="yes" xml:space="preserve">
          <source>ERASE Clause Syntax</source>
          <target state="translated">ERASE子句语法</target>
        </trans-unit>
        <trans-unit id="5dad113e5d1b8f3e62a36027129de407d3e20ed5" translate="yes" xml:space="preserve">
          <source>EVALUATE Selection Object Syntax</source>
          <target state="translated">EVALUATE 选择对象 语法</target>
        </trans-unit>
        <trans-unit id="5a83d6a3d7ae8bc96fedf1c772fbc996a4a470be" translate="yes" xml:space="preserve">
          <source>EVALUATE Selection Subject Syntax</source>
          <target state="translated">EVALUATE 选择主题 语法</target>
        </trans-unit>
        <trans-unit id="692ff2f950c444cebee2d4c4c60df5cc939b8fd9" translate="yes" xml:space="preserve">
          <source>EVALUATE Syntax</source>
          <target state="translated">EVALUATE 语法</target>
        </trans-unit>
        <trans-unit id="469cc380359b81f762280d15538dfac8966996c9" translate="yes" xml:space="preserve">
          <source>EXCEPTION-FILE Function Syntax</source>
          <target state="translated">EXCEPTION-FILE 函数语法</target>
        </trans-unit>
        <trans-unit id="479aad1c99b2dd0808d2f3ab8cbcb8f9343aaefd" translate="yes" xml:space="preserve">
          <source>EXCEPTION-LOCATION Function Syntax</source>
          <target state="translated">EXCEPTION-LOCATION 函数语法</target>
        </trans-unit>
        <trans-unit id="33912bed8a51a3f75c3314cf3a0622c55f3ea0f0" translate="yes" xml:space="preserve">
          <source>EXCEPTION-STATEMENT Function Syntax</source>
          <target state="translated">EXCEPTION-STATEMENT 函数语法</target>
        </trans-unit>
        <trans-unit id="e953091eafe979edb67d0cb82e5a7cfb2279431b" translate="yes" xml:space="preserve">
          <source>EXCEPTION-STATUS Function Syntax</source>
          <target state="translated">功能描述 该功能描述如下。</target>
        </trans-unit>
        <trans-unit id="2d0d9c09a42e3d4ca8de4f760e2a0e18040ed305" translate="yes" xml:space="preserve">
          <source>EXIT Syntax</source>
          <target state="translated">EXIT 语法</target>
        </trans-unit>
        <trans-unit id="d686d0c0c789b999f85984848eb8e9e113877d1c" translate="yes" xml:space="preserve">
          <source>EXP Function Syntax</source>
          <target state="translated">EXP 功能描述</target>
        </trans-unit>
        <trans-unit id="82ec30d94a7c621453c959d12251cec86e515836" translate="yes" xml:space="preserve">
          <source>EXP10 Function Syntax</source>
          <target state="translated">EXP10 功能语法</target>
        </trans-unit>
        <trans-unit id="f6c4ca6abf37447285ca9c9057e5a05661c09827" translate="yes" xml:space="preserve">
          <source>EXTERN the program name is treated as an external reference.</source>
          <target state="translated">EXTERN程序名称被视为外部引用。</target>
        </trans-unit>
        <trans-unit id="03fa72b305c4462fb55710bd2cd41b8ac8239e43" translate="yes" xml:space="preserve">
          <source>EXTERNAL Attribute Syntax</source>
          <target state="translated">外部属性语法</target>
        </trans-unit>
        <trans-unit id="76da433919c17ebd8d966fabcaa51186d16cbb3c" translate="yes" xml:space="preserve">
          <source>Each &amp;lt;</source>
          <target state="translated">每个&amp;lt;</target>
        </trans-unit>
        <trans-unit id="ab7a12a52c6f9b3787b7205827450dfa5e210ea2" translate="yes" xml:space="preserve">
          <source>Each &amp;lt;&amp;lt;</source>
          <target state="translated">每个&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="212df151f4df6b415b0184ea3c628ccc78c3a454" translate="yes" xml:space="preserve">
          <source>Each 01-level data item described within a subprogram&amp;rsquo;s linkage section should correspond to an argument passed on a&lt;code&gt;CALL&lt;/code&gt;statement (see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;) or an argument on a function call to the subprogram.</source>
          <target state="translated">子程序的链接部分中描述的每个01级数据项都应对应于 &lt;code&gt;CALL&lt;/code&gt; 语句（请参见&lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;）上传递的参数或子程序的函数调用上的参数。</target>
        </trans-unit>
        <trans-unit id="50184d6f70a255b3866145aa336ae939da7ab9ab" translate="yes" xml:space="preserve">
          <source>Each Event-Handler-Routine will be a separate section devoted to trapping a particular run-time event. If there are no such sections coded, the&lt;code&gt;DECLARATIVES.&lt;/code&gt;and&lt;code&gt;END DECLARATIVES.&lt;/code&gt;lines may be omitted.</source>
          <target state="translated">每个Event-Handler-Routine将是一个单独的部分，专门用于捕获特定的运行时事件。如果没有编码这些部分，则使用 &lt;code&gt;DECLARATIVES.&lt;/code&gt; 和 &lt;code&gt;END DECLARATIVES.&lt;/code&gt; 行可以省略。</target>
        </trans-unit>
        <trans-unit id="0b25dfd77ca9db15d2164fe35f200c91c7b2bda7" translate="yes" xml:space="preserve">
          <source>Each character, in turn, within the &quot;from&quot; string will be searched for in the target range of the inspect subject. Each located occurrence will be replaced by the corresponding character of the &quot;to&quot; string.</source>
          <target state="translated">&quot;from &quot;字符串中的每个字符,将依次在检查对象的目标范围内进行搜索。每一个找到的字符都将被 &quot;to &quot;字串中的相应字符所取代。</target>
        </trans-unit>
        <trans-unit id="97de2fc8d281d19be767cf651c3cbc1b7509f469" translate="yes" xml:space="preserve">
          <source>Each data item has 7 added to it ten</source>
          <target state="translated">每个数据项都有7个添加到它十</target>
        </trans-unit>
        <trans-unit id="83ca16f4859e7d91cc156f672d81b61c4963b390" translate="yes" xml:space="preserve">
          <source>Each destination field may have an optional&lt;code&gt;COUNT&lt;/code&gt;</source>
          <target state="translated">每个目标字段都可以有一个可选的 &lt;code&gt;COUNT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ce3fcdc8c9dc594c99b3c39bb2ebb465ca20a452" translate="yes" xml:space="preserve">
          <source>Each destination field may have an optional&lt;code&gt;DELIMITER&lt;/code&gt;</source>
          <target state="translated">每个目标字段都可以有一个可选的 &lt;code&gt;DELIMITER&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="824ef1a5b203c9da09868c95374d778cb8131338" translate="yes" xml:space="preserve">
          <source>Each division may consist of a variety of sections and each section consists of one or more paragraphs. A paragraph consists of sentences, each of which consists of one or more statements.</source>
          <target state="translated">每个分部可由多个章节组成,每个章节由一个或多个段落组成。一个段落由句子组成,每个句子由一个或多个陈述组成。</target>
        </trans-unit>
        <trans-unit id="e2bd01ccaa12000bd7c8aa2fcbf0347999187549" translate="yes" xml:space="preserve">
          <source>Each file specified on the&lt;code&gt;cobc&lt;/code&gt;command constitutes a &amp;rsquo;</source>
          <target state="translated">&lt;code&gt;cobc&lt;/code&gt; 命令上指定的每个文件都构成一个'</target>
        </trans-unit>
        <trans-unit id="00f5259fa9f0d932f10e8397b1eec6feeb68f182" translate="yes" xml:space="preserve">
          <source>Each occurrence is referenced using the subscript syntax (a numeric literal, arithmetic expression or numeric identifier enclosed within parenthesis) shown above.</source>
          <target state="translated">每一次出现都使用上图所示的下标语法(括号内的数字文字、算术表达式或数字标识符)进行引用。</target>
        </trans-unit>
        <trans-unit id="2246e9f359281d69c5119e3504fc16ed25bac66e" translate="yes" xml:space="preserve">
          <source>Each occurrence that is set to a value of zero prior to the&lt;code&gt;CALL X&quot;91&quot;&lt;/code&gt;will cause the corresponding switch to be cleared. Each occurrence set to 1 prior to the&lt;code&gt;CALL X&quot;91&quot;&lt;/code&gt;will cause the corresponding switch to be set.</source>
          <target state="translated">在 &lt;code&gt;CALL X&quot;91&quot;&lt;/code&gt; 之前将每次出现的值设置为零将导致清除相应的开关。在 &lt;code&gt;CALL X&quot;91&quot;&lt;/code&gt; 之前将每次出现设置为1，将导致设置相应的开关。</target>
        </trans-unit>
        <trans-unit id="47a2c92912290d0b93c63c77a2120c44882c45e8" translate="yes" xml:space="preserve">
          <source>Each of &amp;lt;</source>
          <target state="translated">每个&amp;lt;</target>
        </trans-unit>
        <trans-unit id="a97f6698ca0ef433fb7ac939df954fa715d8f25a" translate="yes" xml:space="preserve">
          <source>Each of the &amp;lt;</source>
          <target state="translated">每个&amp;lt;</target>
        </trans-unit>
        <trans-unit id="7287503eaa543018b27e0323b8db19263aedff48" translate="yes" xml:space="preserve">
          <source>Each of the 1st eight occurrences of the array will be set to either 0 or 1 &amp;mdash; 1 if the corresponding switch is set, 0 otherwise.</source>
          <target state="translated">如果设置了相应的开关，则数组的第8次出现的每一个将被设置为0或1-1，否则设置为0。</target>
        </trans-unit>
        <trans-unit id="c09592cadb2ed51d0f1c709d0f7fdfe9b96c7560" translate="yes" xml:space="preserve">
          <source>Each of the folders named on the&lt;code&gt;COBCPY&lt;/code&gt;compilation-time environment variable</source>
          <target state="translated">在 &lt;code&gt;COBCPY&lt;/code&gt; 编译时环境变量上命名的每个文件夹</target>
        </trans-unit>
        <trans-unit id="324c91e30099fbc60529755c27c3efdd05d14a69" translate="yes" xml:space="preserve">
          <source>Each of the following symbols behave like a&lt;code&gt;9&lt;/code&gt; until such point as all digits in the numeric value are exhausted and leading zeros are about to be inserted. In effect, these editing symbols define what should happen to those leading zero.</source>
          <target state="translated">在数字值中的所有数字都用完并且即将插入前导零之前，以下每个符号的行为都类似于 &lt;code&gt;9&lt;/code&gt; 。实际上，这些编辑符号定义了那些前导零将发生什么。</target>
        </trans-unit>
        <trans-unit id="d9d2be1b968bb484ea3bd99238ffa88f1a9b097c" translate="yes" xml:space="preserve">
          <source>Each of these sections consists of a series of specific paragraphs &lt;code&gt;SOURCE-COMPUTER&lt;/code&gt;and&lt;code&gt;OBJECT-COMPUTER&lt;/code&gt; for example). Each of these paragraphs serves a specific purpose. If no code is required for the purpose one of the paragraphs serves, the entire paragraph may be omitted.</source>
          <target state="translated">每个部分都包含一系列特定的段落，例如 &lt;code&gt;SOURCE-COMPUTER&lt;/code&gt; 和 &lt;code&gt;OBJECT-COMPUTER&lt;/code&gt; 。这些段落中的每一个都有特定的目的。如果出于以下任一目的而无需代码，则可以省略整个段落。</target>
        </trans-unit>
        <trans-unit id="49fb2845c3cf679efe7de1449e9eb5da506280b3" translate="yes" xml:space="preserve">
          <source>Each of these sections consists of code which serves a specific purpose. If no code is required for the purpose one of those sections serves, the entire section, including it&amp;rsquo;s header, may be omitted.</source>
          <target state="translated">每个部分均包含用于特定目的的代码。如果出于这些部分之一的目的而不需要代码，则可以省略整个部分，包括其标题。</target>
        </trans-unit>
        <trans-unit id="e5476f035d3a01cedf662032e9a562423f2c27af" translate="yes" xml:space="preserve">
          <source>Each of those files is assumed to be already sorted according to the specifications set forth on the&lt;code&gt;MERGE&lt;/code&gt;statement&amp;rsquo;s&lt;code&gt;KEY&lt;/code&gt;</source>
          <target state="translated">假定每个文件都已经按照 &lt;code&gt;MERGE&lt;/code&gt; 语句 &lt;code&gt;KEY&lt;/code&gt; 上列出的规范进行了排序</target>
        </trans-unit>
        <trans-unit id="39b6b7cca90aab953adf3ec432fdd03b2921cced" translate="yes" xml:space="preserve">
          <source>Each page of a report is divided into as many as five (5) areas, as shown in the following diagram.</source>
          <target state="translated">报告的每一页都被分为多达五(5)个区域,如下图所示。</target>
        </trans-unit>
        <trans-unit id="e972c979eeb51709c3026fa1585338428e0bcde2" translate="yes" xml:space="preserve">
          <source>Each program consists of up to four &amp;rsquo;</source>
          <target state="translated">每个程序最多包含四个&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="41ad41c5b7c7e05b20b0cee772dbf1deebed0213" translate="yes" xml:space="preserve">
          <source>Each report referenced on a&lt;code&gt;REPORT IS&lt;/code&gt;clause (see &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File/Sort-Description&lt;/a&gt;) must be described with a report description &lt;code&gt;RD&lt;/code&gt;.</source>
          <target state="translated">必须在 &lt;code&gt;REPORT IS&lt;/code&gt; 子句（请参阅&lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File / Sort-Description&lt;/a&gt;）上引用的每个报告都使用报告描述 &lt;code&gt;RD&lt;/code&gt; 进行描述。</target>
        </trans-unit>
        <trans-unit id="c43f0748874dff6862d449d932e3f73e50432ff7" translate="yes" xml:space="preserve">
          <source>Each set of counting instructions contains the following information:</source>
          <target state="translated">每套计数指令包含以下信息:</target>
        </trans-unit>
        <trans-unit id="1713797d1fd5be38aa62ec74f40cb5e4ea9a66cb" translate="yes" xml:space="preserve">
          <source>Each set of replacement instructions contains the following information:</source>
          <target state="translated">每套更换说明书包含以下信息:</target>
        </trans-unit>
        <trans-unit id="ec64521d31f73aadd610d57e3314c5c0cb07d6c8" translate="yes" xml:space="preserve">
          <source>Each specified switch must have at least one of a&lt;code&gt;IS &amp;lt;&lt;i&gt;mnemonic-name-1&lt;/i&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;ON STATUS&lt;/code&gt;or an&lt;code&gt;OFF STATUS&lt;/code&gt;option defined for it, otherwise there will be no way to reference the switch from within a GnuCOBOL program.</source>
          <target state="translated">每个指定的开关必须至少为其定义了 &lt;code&gt;IS &amp;lt;&lt;i&gt;mnemonic-name-1&lt;/i&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;ON STATUS&lt;/code&gt; 或 &lt;code&gt;OFF STATUS&lt;/code&gt; 选项之一，否则将无法从GnuCOBOL程序中引用该开关。</target>
        </trans-unit>
        <trans-unit id="e559cbff67ac689ef745772d42537a3b513d5011" translate="yes" xml:space="preserve">
          <source>Each symbolic character name will be associated with the corresponding &amp;lt;</source>
          <target state="translated">每个符号字符名称都将与相应的&amp;lt;</target>
        </trans-unit>
        <trans-unit id="4c00430742f8eba1eaf3bd142512606b4b7f5494" translate="yes" xml:space="preserve">
          <source>Each time a&lt;code&gt;GENERATE&lt;/code&gt;statement (see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) is executed against a detail report group defined for this&lt;code&gt;RD&lt;/code&gt; the RWCS will check the contents of each &amp;lt;</source>
          <target state="translated">每次针对为此 &lt;code&gt;RD&lt;/code&gt; 定义的详细报告组执行 &lt;code&gt;GENERATE&lt;/code&gt; 语句（请参见&lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;）时，RWCS都会检查每个&amp;lt;</target>
        </trans-unit>
        <trans-unit id="48545f108d6d890063854ad082ddb7636b0f7c42" translate="yes" xml:space="preserve">
          <source>Each&lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt;directive must be terminated by an&lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt;</source>
          <target state="translated">每个 &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt; 指令必须以 &lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt; 终止</target>
        </trans-unit>
        <trans-unit id="3fecee34669e35b4e24782aec546eab94e861c5a" translate="yes" xml:space="preserve">
          <source>Each&lt;code&gt;RD&lt;/code&gt;will have the following allocated for it:</source>
          <target state="translated">每个 &lt;code&gt;RD&lt;/code&gt; 将为其分配以下内容：</target>
        </trans-unit>
        <trans-unit id="558bbf35a31701a51f5e603c87d6e37860e5bac5" translate="yes" xml:space="preserve">
          <source>Each&lt;code&gt;WHEN&lt;/code&gt;clause (other than the&lt;code&gt;WHEN OTHER&lt;/code&gt;</source>
          <target state="translated">每个 &lt;code&gt;WHEN&lt;/code&gt; 子句（ &lt;code&gt;WHEN OTHER&lt;/code&gt; 除外）</target>
        </trans-unit>
        <trans-unit id="db708aa4613d2d89fc52c61a7a68b8e5310b35b1" translate="yes" xml:space="preserve">
          <source>Early versions of Micro Focus COBOL allowed programmers to access various runtime library routines by using a single two-digit hexadecimal number as the entry-point name. These were known as call-by-number routines. Over time, Micro Focus COBOL evolved, replacing most of the call-by-number routines with ones accessible using a more conventional call-by-name technique.</source>
          <target state="translated">早期版本的Micro Focus COBOL允许程序员通过使用一个单一的两位数十六进制数字作为入口点名称来访问各种运行时库例程。这些被称为逐号调用例程。随着时间的推移,Micro Focus COBOL不断发展,用那些使用更传统的逐名调用技术访问的例程取代了大部分的逐名调用例程。</target>
        </trans-unit>
        <trans-unit id="60914652372d8aacfba426f94ef0a27b6bd64788" translate="yes" xml:space="preserve">
          <source>Effortlessly providing arithmetic accuracy to 31 digits, with performance approaching that of well-written assembly-language programs. Don&amp;rsquo;t think this isn&amp;rsquo;t critically important to banks, investment houses and any business interested in tracking revenues, expenses and profits (duh - like ALL of them).</source>
          <target state="translated">毫不费力地提供了31位的算术精度，其性能接近编写良好的汇编语言程序的性能。不要以为这对银行，投资公司以及任何对跟踪收入，支出和利润感兴趣的企业都不是至关重要的（du-就像所有这些一样）。</target>
        </trans-unit>
        <trans-unit id="eb8c33f1bd7b54199aabb312bdff6ad20c4a00e4" translate="yes" xml:space="preserve">
          <source>Eight (8) different colors may be specified for both the background (screen) and foreground (text) color of any row/column position on the screen. Colors are specified by number, although a copybook supplied with all GnuCOBOL distributions (&quot;screenio.cpy&quot;) defines COB-COLOR-xxxxxx names for the various colors so they may be specified as a more meaningful name rather than a number. The eight colors, by number, with the constant names defined in screenio.cpy, are as follows:</source>
          <target state="translated">8种不同的颜色可以指定屏幕上任何一行/一列位置的背景(屏幕)和前景(文本)的颜色,颜色是由数字指定的,尽管所有GnuCOBOL发行版提供的副本(&quot;screenio.cpy&quot;)为各种颜色定义了COB-COLOR-xxxxxx的名称,因此它们可以指定。颜色是通过数字来指定的,尽管所有GnuCOBOL发行版提供的副本(&quot;screenio.cpy&quot;)为各种颜色定义了COB-COLOR-xxxxxx名称,因此它们可以被指定为更有意义的名称而不是数字。八种颜色,按数字排列,在screenio.cpy中定义的常量名称如下。</target>
        </trans-unit>
        <trans-unit id="0de188972590d50f27e84d7799cae74d5422d21a" translate="yes" xml:space="preserve">
          <source>Either a statement that begins with a non decision-making verb and specifies an unconditional action to be taken or a conditional verb such as&lt;code&gt;IF&lt;/code&gt;or&lt;code&gt;EVALUATE&lt;/code&gt; delimited by its explicit scope terminator (such as&lt;code&gt;END-IF&lt;/code&gt;or&lt;code&gt;END-EVALUATE&lt;/code&gt;. An imperative statement can consist of a sequence of imperative statements.</source>
          <target state="translated">无论是与非决策动词和指定要采取无条件行动或条件动词，如开头的语句 &lt;code&gt;IF&lt;/code&gt; 或 &lt;code&gt;EVALUATE&lt;/code&gt; 通过其明确的范围终止符隔开（如 &lt;code&gt;END-IF&lt;/code&gt; 或 &lt;code&gt;END-EVALUATE&lt;/code&gt; 。命令式语句由一系列命令式语句组成。</target>
        </trans-unit>
        <trans-unit id="30ea0da285c9a0b0bf611b3900abc0d992ef03bb" translate="yes" xml:space="preserve">
          <source>Either a&lt;code&gt;BEFORE&lt;/code&gt;phrase, an&lt;code&gt;AFTER&lt;/code&gt;phrase or both may be specified. They may be specified in any order.</source>
          <target state="translated">可以指定 &lt;code&gt;BEFORE&lt;/code&gt; 短语， &lt;code&gt;AFTER&lt;/code&gt; 短语或两者。它们可以以任何顺序指定。</target>
        </trans-unit>
        <trans-unit id="0caa91b8f1f5f36fcf7fbe55099f1de176c8fde9" translate="yes" xml:space="preserve">
          <source>Either or both of the 1st two arguments may be an alphanumeric literal, a group item or an elementary item appropriate to storing alphabetic or alphanumeric data. If the lengths of the two arguments are unequal, the shorter will be assumed to be padded to the right with spaces.</source>
          <target state="translated">第1、2个参数中的任何一个或两个都可以是字母数字文字,一个组项或一个适合存储字母或字母数字数据的基本项。如果两个参数的长度不相等,较短的参数将被假定为用空格向右填充。</target>
        </trans-unit>
        <trans-unit id="858e7defec8698672940f8ce436c406862616ecb" translate="yes" xml:space="preserve">
          <source>Either the name of an identifier or a procedure in the program. GnuCOBOL limits user-defined names to a maximum of 31 characters taken from the set of numeric digits, upper- and lower-case letters, hyphens and underscores. A user-defined name may neither begin nor end with a hyphen or underscore. User-defined names used as file names may additionally not begin with a digit although - unlike many other programming languages - user-defined names used as identifiers or procedure names may.</source>
          <target state="translated">程序中的一个标识符或一个过程的名称。GnuCOBOL限制用户定义的名称最多为31个字符,这些字符来自数字数字、大写和小写字母、连字符和下划线的集合。用户自定义名称既不能以连字符或下划线开始,也不能以连字符或下划线结束。此外,用作文件名的用户自定义名称也不能以数字开头,尽管与许多其他编程语言不同,用作标识符或程序名的用户自定义名称可以以数字开头。</target>
        </trans-unit>
        <trans-unit id="7567d0d8aa3c2f98c0119f54054a4094bbdf6b09" translate="yes" xml:space="preserve">
          <source>Either the&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of &amp;lt;</source>
          <target state="translated">&amp;lt;&amp;lt; 的 &lt;code&gt;USAGE&lt;/code&gt; （请参阅&lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="12419b0638b06653e626b1a31d9f95a7e8c75d0a" translate="yes" xml:space="preserve">
          <source>Elementary Item</source>
          <target state="translated">基本项目</target>
        </trans-unit>
        <trans-unit id="f61c9f064c3d39237a20a4d7d3d38cc92ed48b49" translate="yes" xml:space="preserve">
          <source>End of file reached if reading forward or beginning-of-file reached if reading backward</source>
          <target state="translated">如果向前读,则到达文件的终点;如果向后读,则到达文件的起点。</target>
        </trans-unit>
        <trans-unit id="eb4a1c1bc69354df732a1fb660f7766fbc1365bb" translate="yes" xml:space="preserve">
          <source>End of page</source>
          <target state="translated">页尾</target>
        </trans-unit>
        <trans-unit id="1f90eed9e128990aa3916d4821f0afedd06fce42" translate="yes" xml:space="preserve">
          <source>Entry-point</source>
          <target state="translated">Entry-point</target>
        </trans-unit>
        <trans-unit id="318f6eeac5e0a5f73cec3c1a7fec998a2d2b42bf" translate="yes" xml:space="preserve">
          <source>Entry-point Name</source>
          <target state="translated">入境点名称</target>
        </trans-unit>
        <trans-unit id="f15859f3eeefa48c8447da8cc8be18ae2f96c167" translate="yes" xml:space="preserve">
          <source>Environment variables created or changed from within GnuCOBOL programs will be available to any sub-shell processes spawned by that program (i.e. CALL &quot;SYSTEM&quot;) but will not be known to the shell or console window that started the GnuCOBOL program.</source>
          <target state="translated">从GnuCOBOL程序内部创建或更改的环境变量将对该程序产生的任何子shell进程(即CALL &quot;SYSTEM&quot;)可用,但不会被启动GnuCOBOL程序的shell或控制台窗口所知。</target>
        </trans-unit>
        <trans-unit id="d9b239553d90073cbc48e1842b57308d0f503d32" translate="yes" xml:space="preserve">
          <source>Environment variables created or changed from within GnuCOBOL programs will be available to any sub-shell processes spawned by that program (i.e.&lt;code&gt;CALL 'SYSTEM'&lt;/code&gt;(see &lt;a href=&quot;#SYSTEM&quot;&gt;SYSTEM&lt;/a&gt;)) but will not be known to the shell or console window that started the GnuCOBOL program.</source>
          <target state="translated">从GnuCOBOL程序内部创建或更改的环境变量将可供该程序产生的任何子Shell进程（即CALL'SYSTEM &lt;code&gt;CALL 'SYSTEM'&lt;/code&gt; （请参阅&lt;a href=&quot;#SYSTEM&quot;&gt;SYSTEM&lt;/a&gt;））使用，但启动GnuCOBOL程序的Shell或控制台窗口将不知道该环境变量。</target>
        </trans-unit>
        <trans-unit id="a831ca77884d7fa1627dca65d5bcf5b32460e5b1" translate="yes" xml:space="preserve">
          <source>Erased areas will have their foreground and background colors set to the attributes of the field containing the&lt;code&gt;ERASE&lt;/code&gt;clause.</source>
          <target state="translated">被擦除的区域将其前景色和背景色设置为包含 &lt;code&gt;ERASE&lt;/code&gt; 子句的字段的属性。</target>
        </trans-unit>
        <trans-unit id="5da25ad570031cfc548ccf057713182fe2696bf6" translate="yes" xml:space="preserve">
          <source>Error Type</source>
          <target state="translated">错误类型</target>
        </trans-unit>
        <trans-unit id="091e812df524f11e726f776aeeac24e5d0a26bc7" translate="yes" xml:space="preserve">
          <source>Esc was pressed</source>
          <target state="translated">按了Esc键</target>
        </trans-unit>
        <trans-unit id="1d5c1c82e60d938ff99b4032766d8759f53965f9" translate="yes" xml:space="preserve">
          <source>Evaluates to FALSE</source>
          <target state="translated">评价为FALSE</target>
        </trans-unit>
        <trans-unit id="7718b010814db3432233ea3bdf4b33cc8999b495" translate="yes" xml:space="preserve">
          <source>Evaluates to FALSE AND (FALSE AND TRUE) which evaluates to FALSE</source>
          <target state="translated">评估为FALSE和(FALSE和TRUE),评估为FALSE。</target>
        </trans-unit>
        <trans-unit id="e61648f7d13955bbfcf9bc100110e4859aa8fce4" translate="yes" xml:space="preserve">
          <source>Evaluates to FALSE AND FALSE AND TRUE which evaluates to FALSE</source>
          <target state="translated">评估为FALSE和FALSE和TRUE,评估为FALSE。</target>
        </trans-unit>
        <trans-unit id="dcd13fd025cd8853636d96d1e4febe9db19f5d33" translate="yes" xml:space="preserve">
          <source>Evaluates to NOT (FALSE) which evaluates to TRUE</source>
          <target state="translated">评估为NOT(FALSE),即评估为TRUE。</target>
        </trans-unit>
        <trans-unit id="382d1cb13ed9d55b2c9159d78c596a71f0163e66" translate="yes" xml:space="preserve">
          <source>Evaluates to TRUE</source>
          <target state="translated">评价为 &quot;真&quot;。</target>
        </trans-unit>
        <trans-unit id="f75486ff1410d50667eeed0386b80ad55880746c" translate="yes" xml:space="preserve">
          <source>Evaluates to TRUE (since AND has precedence over OR) - this is identical to the previous example</source>
          <target state="translated">计算为TRUE(因为AND优先于OR)--这与前面的例子相同。</target>
        </trans-unit>
        <trans-unit id="4d6d770c334405188a688baa0a731edb1fd48f77" translate="yes" xml:space="preserve">
          <source>Even without the&lt;code&gt;DEBUGGING MODE&lt;/code&gt;clause, it is still possible to compile debugging lines. Debugging lines may also be compiled by specifying the&lt;code&gt;-fdebugging-line&lt;/code&gt;switch</source>
          <target state="translated">即使没有 &lt;code&gt;DEBUGGING MODE&lt;/code&gt; 子句，仍然可以编译调试行。调试行也可以通过指定 &lt;code&gt;-fdebugging-line&lt;/code&gt; 开关进行编译</target>
        </trans-unit>
        <trans-unit id="91552a3314a03734e404c7b97ca06f17613df4cd" translate="yes" xml:space="preserve">
          <source>Every &amp;lt;</source>
          <target state="translated">每个&amp;lt;</target>
        </trans-unit>
        <trans-unit id="9f42753b88c31f07e6bcdfda34cbd05a816f1808" translate="yes" xml:space="preserve">
          <source>Every &amp;lt;&amp;lt;</source>
          <target state="translated">每个&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="77e9bb85e78385998b2213a27bb8d8376a21fddb" translate="yes" xml:space="preserve">
          <source>Every data item at the same&lt;code&gt;level&lt;/code&gt;of a hierarchy diagram such as the one you see here (if you were to make one, which you rarely &amp;mdash; if ever &amp;mdash; will, once you get used to this concept) must have the same level number.</source>
          <target state="translated">层次结构图在同一 &lt;code&gt;level&lt;/code&gt; 上的每个数据项，例如您在此处看到的数据项（如果要创建一个，一旦习惯了这个概念，您很少（如果有的话）就不会）将必须具有相同的级别号。</target>
        </trans-unit>
        <trans-unit id="464315bf9feceba501caec897c0b6079a97e791c" translate="yes" xml:space="preserve">
          <source>Every entry-point has a name. That name must be unique for all programs that comprise an executable program. Entry-point names are defined using a subroutine&amp;rsquo;s&lt;code&gt;PROGRAM-ID&lt;/code&gt;paragraph, a user-defined function&amp;rsquo;s&lt;code&gt;FUNCTION-ID&lt;/code&gt;paragraph or via&lt;code&gt;ENTRY&lt;/code&gt;(see &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt;) statements coded in a subprogram&amp;rsquo;s procedure division.</source>
          <target state="translated">每个入口点都有一个名称。对于组成可执行程序的所有程序，该名称必须唯一。入口点名称是使用子程序的 &lt;code&gt;PROGRAM-ID&lt;/code&gt; 段落，用户定义的函数的 &lt;code&gt;FUNCTION-ID&lt;/code&gt; 段落或通过子程序的过程分区中编码的 &lt;code&gt;ENTRY&lt;/code&gt; （请参阅&lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt;）语句定义的。</target>
        </trans-unit>
        <trans-unit id="22c250c80a48d66257ba552ab395682e38c843f2" translate="yes" xml:space="preserve">
          <source>Every new level uses a level number that is strictly greater than the one used in the parent (next higher) level.</source>
          <target state="translated">每一个新的关卡使用的关卡号都要严格大于上级(下一级)关卡中使用的关卡号。</target>
        </trans-unit>
        <trans-unit id="e22c344c08f0a674fec53d0ccadbf31f6f3afb87" translate="yes" xml:space="preserve">
          <source>Every non-FILLER elementary item subordinate to &amp;lt;</source>
          <target state="translated">每个非FILLER基本项目从属于&amp;lt;</target>
        </trans-unit>
        <trans-unit id="004439041e706926e609b461ee10ab7fd206e801" translate="yes" xml:space="preserve">
          <source>Every program has at least one entry-point &amp;mdash; known as the primary entry-point &amp;mdash; which corresponds to the first executable statement in the procedure division following the declaratives area, if any.</source>
          <target state="translated">每个程序都有至少一个入口点（称为主入口点），该入口点对应于声明区域之后的过程分区中的第一个可执行语句。</target>
        </trans-unit>
        <trans-unit id="1601a99f6446d942e939a06dabeb60be03814480" translate="yes" xml:space="preserve">
          <source>Every report has the same basic structure, as shown here, even though not all reports will have all of the groups shown. In fact, it is a very unusual report indeed that actually has every one of these groups:</source>
          <target state="translated">每份报告都有相同的基本结构,如图所示,尽管并非所有的报告都有所有的组别。事实上,真正拥有这些组别中的每一个组别的报告确实非常不寻常。</target>
        </trans-unit>
        <trans-unit id="cec461b13ba9e76a1b658d70ba02bcb163ba81a4" translate="yes" xml:space="preserve">
          <source>Every report that employs control breaks has a natural hierarchy of those control breaks based upon the manner in which the data the report is being generated from is sorted. This concept is best understood using an example which assumes a COBOL program to process sales data collected from every computerized cash register across a chain of stores having multiple departments is being developed.</source>
          <target state="translated">每一个采用控制断点的报表都有一个自然的控制断点层次,其基础是对报表生成的数据进行排序的方式。这个概念最好用一个例子来理解,这个例子假设正在开发一个COBOL程序,以处理从具有多个部门的连锁商店的每个计算机化收银机收集的销售数据。</target>
        </trans-unit>
        <trans-unit id="b56d93d247b7135e025b8bb06d8e4f1f8158cab1" translate="yes" xml:space="preserve">
          <source>Every time this program is executed, it will produce the same output, because the same sequence of pseudo-random numbers will be generated:</source>
          <target state="translated">每次执行这个程序,都会产生相同的输出,因为会产生相同的伪随机数序列。</target>
        </trans-unit>
        <trans-unit id="631a83a57af68e8b556c535abcfba9d122280242" translate="yes" xml:space="preserve">
          <source>Executable File</source>
          <target state="translated">可执行文件</target>
        </trans-unit>
        <trans-unit id="c4aff9d44d0a696a912102a8ff52dc1f8917cec9" translate="yes" xml:space="preserve">
          <source>Executing a&lt;code&gt;DISPLAY UPON COMMAND-LINE&lt;/code&gt;will influence subsequent&lt;code&gt;ACCEPT FROM COMMAND-LINE&lt;/code&gt;statements (which will then return the value you displayed), but will not influence subsequent&lt;code&gt;ACCEPT FROM ARGUMENT-VALUE&lt;/code&gt;statements &amp;mdash; these will continue to return the original program execution parameters.</source>
          <target state="translated">执行 &lt;code&gt;DISPLAY UPON COMMAND-LINE&lt;/code&gt; 将影响后续的 &lt;code&gt;ACCEPT FROM COMMAND-LINE&lt;/code&gt; 语句（它将返回您显示的值），但不会影响后续的 &lt;code&gt;ACCEPT FROM ARGUMENT-VALUE&lt;/code&gt; 语句-这些将继续返回原始程序执行参数。</target>
        </trans-unit>
        <trans-unit id="b5eccd53038d68d6fe98e6c74bbc70fbdda0f1d8" translate="yes" xml:space="preserve">
          <source>Executing the statement&lt;code&gt;SET &amp;lt;&lt;i&gt;condition-name-1&lt;/i&gt;&amp;gt; TO FALSE&lt;/code&gt;will cause &amp;lt;</source>
          <target state="translated">执行语句 &lt;code&gt;SET &amp;lt;&lt;i&gt;condition-name-1&lt;/i&gt;&amp;gt; TO FALSE&lt;/code&gt; 将导致&amp;lt;</target>
        </trans-unit>
        <trans-unit id="d3202330dc255528350ed15988600d69cebe769e" translate="yes" xml:space="preserve">
          <source>Executing the statement&lt;code&gt;SET &amp;lt;&lt;i&gt;condition-name-1&lt;/i&gt;&amp;gt; TO TRUE&lt;/code&gt;will cause &amp;lt;</source>
          <target state="translated">执行语句 &lt;code&gt;SET &amp;lt;&lt;i&gt;condition-name-1&lt;/i&gt;&amp;gt; TO TRUE&lt;/code&gt; 将导致&amp;lt;</target>
        </trans-unit>
        <trans-unit id="699332aeb03074ecdaa898353c6db354128e04e0" translate="yes" xml:space="preserve">
          <source>Execution Thread</source>
          <target state="translated">执行线程</target>
        </trans-unit>
        <trans-unit id="f7b699c1f1fca94c3574d70d8a9956ade47096d2" translate="yes" xml:space="preserve">
          <source>Execution of the calling program is suspended and control will transfer to the called program, as follows:</source>
          <target state="translated">调用程序的执行被暂停,控制权将转移到被调用程序上,具体如下。</target>
        </trans-unit>
        <trans-unit id="c1fdde2e7a98a43a8969fd6782e1df3e5e50ec04" translate="yes" xml:space="preserve">
          <source>Execution will begin at the first executable statement following the subprograms entry-point. The entry point will be either the first executable statement following any&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) that might be present (if the subprogram was invoked using its primary entry-point name) or the first executable statement following the&lt;code&gt;ENTRY&lt;/code&gt;statement (see &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt;) naming the entry-point specified on the&lt;code&gt;CALL&lt;/code&gt;if the subprogram was invoked using an alternate entry point.</source>
          <target state="translated">执行将从子程序入口点之后的第一个可执行语句开始。入口点将是可能存在的任何 &lt;code&gt;DECLARATIVES&lt;/code&gt; （请参阅&lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;）之后的第一个可执行语句（如果子程序是使用其主要入口点名称调用的）或 &lt;code&gt;ENTRY&lt;/code&gt; 语句后的第一个可执行语句（请参阅&lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt;）。如果使用备用入口点调用了子程序，则在 &lt;code&gt;CALL&lt;/code&gt; 上指定入口点。</target>
        </trans-unit>
        <trans-unit id="df928d8218fa60aea80b123d18575cb29a66dc2a" translate="yes" xml:space="preserve">
          <source>Execution will begin with the first executable statement in the procedure division following any&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) that might be present.</source>
          <target state="translated">执行将从可能存在的任何 &lt;code&gt;DECLARATIVES&lt;/code&gt; （请参阅&lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;）之后的过程分区中的第一个可执行语句开始。</target>
        </trans-unit>
        <trans-unit id="813d8ff4c4f053c1fe5a4302c6f9c49604c7c000" translate="yes" xml:space="preserve">
          <source>Execution will resume back in the calling program at the point where the returned value of the function is needed. At that point, the value in the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register will be used for the function&amp;rsquo;s value.</source>
          <target state="translated">执行将在需要返回函数值的位置返回到调用程序。届时， &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器中的值将用作函数的值。</target>
        </trans-unit>
        <trans-unit id="6604bac134b018c911ef4c369060da53971d99cd" translate="yes" xml:space="preserve">
          <source>Execution will resume back in the calling program with the first executable statement following the&lt;code&gt;CALL&lt;/code&gt;that invoked the subprogram.</source>
          <target state="translated">执行将在调用程序中恢复，并在调用子程序的 &lt;code&gt;CALL&lt;/code&gt; 之后返回第一个可执行语句。</target>
        </trans-unit>
        <trans-unit id="1c4f897e49f43d61c8c285a5f8b529c6df7d4952" translate="yes" xml:space="preserve">
          <source>Expiration of the&lt;code&gt;TIMEOUT&lt;/code&gt;timer &amp;mdash; this will be treated as if the Enter key had been pressed with no data being entered.</source>
          <target state="translated">&lt;code&gt;TIMEOUT&lt;/code&gt; 定时器到期-将其视为已按下Enter键且未输入任何数据。</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="1ba54893e49d5a98fdd72b1731cb837c15733eae" translate="yes" xml:space="preserve">
          <source>F, FACTORIAL, FACTORY, FALSE, FD, FILE, FILE-CONTROL, FILE-ID, FILLER, FINAL, FIRST, FIXED, FLOAT-BINARY-128, FLOAT-BINARY-32, FLOAT-BINARY-64, FLOAT-DECIMAL-16, FLOAT-DECIMAL-34, FLOAT-EXTENDED, FLOAT-INFINITY, FLOAT-LONG, FLOAT-NOT-A-NUMBER, FLOAT-SHORT, FOOTING, FOR, FOREGROUND-COLOR, FOREGROUND-COLOUR, FOREVER, FORMAT, FORMATTED-CURRENT-DATE, FORMATTED-DATE, FORMATTED-DATETIME, FORMATTED-TIME, FORMFEED, FRACTION-PART, FREE, FROM, FULL, FUNCTION, FUNCTION-ID, FUNCTION-POINTER</source>
          <target state="translated">F,FACTORIAL,FACTORY,FALSE,FD,FILE,FILE-CONTROL,FILE-ID,FILLER,FINAL,FIRST,FIXED,FLOAT-BINARY-128,FLOAT-BINARY-32,FLOAT-BINARY-64,FLOAT-DECIMAL-16,FLOAT-DECIMAL-34,FLOAT-EXTENDED,FLOAT-INFINITY,FLOAT-LONG,FLOAT-NOT-A-NUMBER,FLOAT-SHORT,FOOTING,FOR,FOREGROUND-COLOR,FOREGROUND-COLOUR,FOREVER,FORMAT,FORMATTED-CURRENT-DATE,FORMATTED-DATE,FORMATTED-DATETIME,FORMATTED-TIME,FORMFEED,FRACTION-PART,FREE,FROM,FULL,FUNCTION,FUNCTION-ID,FUNCTION-POINTER。</target>
        </trans-unit>
        <trans-unit id="c388ca73e917511c83a42c7c3347b5330aa45cac" translate="yes" xml:space="preserve">
          <source>F1&amp;ndash;F64, respectively, were pressed</source>
          <target state="translated">分别按F1-F64</target>
        </trans-unit>
        <trans-unit id="03de1b80d9ce6c956e045a67ec26864bd9ba86c4" translate="yes" xml:space="preserve">
          <source>FACTORIAL Function Syntax</source>
          <target state="translated">FACTORIAL 函数语法</target>
        </trans-unit>
        <trans-unit id="c9236dbf1d5f35b60810d9900ebae017d4554e9f" translate="yes" xml:space="preserve">
          <source>FALSE Clause Syntax</source>
          <target state="translated">FALSE 子句语法</target>
        </trans-unit>
        <trans-unit id="237f463d19c40eb262085170910a45a2579d4007" translate="yes" xml:space="preserve">
          <source>FILE SECTION Syntax</source>
          <target state="translated">FILE SECTION 语法</target>
        </trans-unit>
        <trans-unit id="6dfe1492af3adfd94529936ae7572256a4829765" translate="yes" xml:space="preserve">
          <source>FILE-SECTION-Data-Item</source>
          <target state="translated">FILE-SECTION-Data-Item</target>
        </trans-unit>
        <trans-unit id="a00fbabfeb0e3333ddad8f67452398d7a56df6cc" translate="yes" xml:space="preserve">
          <source>FILE-SECTION-Data-Item Syntax</source>
          <target state="translated">FILE-SECTION-Data-Item 语法</target>
        </trans-unit>
        <trans-unit id="3e19d8cecb7e5bc7a9e28e9032b126d8e079e6f9" translate="yes" xml:space="preserve">
          <source>FOREGROUND-COLOR Attribute Syntax</source>
          <target state="translated">FOREGROUND-COLOR 属性 语法</target>
        </trans-unit>
        <trans-unit id="d5452f4037c6aa0b6e742313c3d7af9ddb944ba1" translate="yes" xml:space="preserve">
          <source>FRACTION-PART Function Syntax</source>
          <target state="translated">FRACTION-ART 函数语法</target>
        </trans-unit>
        <trans-unit id="6a87ce926e3fdeec20b1a39152e04f9b4879b7c9" translate="yes" xml:space="preserve">
          <source>FREE Syntax</source>
          <target state="translated">免费语法</target>
        </trans-unit>
        <trans-unit id="42879485a7a11418680abc60f6ddfab84a32360f" translate="yes" xml:space="preserve">
          <source>FROM Clause Syntax</source>
          <target state="translated">FROM子句语法</target>
        </trans-unit>
        <trans-unit id="2f45ea6b6316a4f10231808ddaece8cd1888d793" translate="yes" xml:space="preserve">
          <source>FULL Attribute Syntax</source>
          <target state="translated">FULL属性语法</target>
        </trans-unit>
        <trans-unit id="19aa8d076903fa405aac265ff791623484d35537" translate="yes" xml:space="preserve">
          <source>Fails due to rule #1</source>
          <target state="translated">因规则1而失败</target>
        </trans-unit>
        <trans-unit id="c8f41e04860a699d459755ee5bc85c6fd14d5b99" translate="yes" xml:space="preserve">
          <source>Fails due to rule #2a</source>
          <target state="translated">因规则2a而失败</target>
        </trans-unit>
        <trans-unit id="ff00be8ee320bab1c7ba44d9360894c017495313" translate="yes" xml:space="preserve">
          <source>Fails due to rule #2b</source>
          <target state="translated">因规则2b而失败</target>
        </trans-unit>
        <trans-unit id="75efda3b01e99fcd496782dcc687d25e00babfe5" translate="yes" xml:space="preserve">
          <source>Fails due to rule #3a</source>
          <target state="translated">因规则3a而失败</target>
        </trans-unit>
        <trans-unit id="050c309a1409aa9e640bd99affba7737a0884c7e" translate="yes" xml:space="preserve">
          <source>Fails due to rule #3b</source>
          <target state="translated">因规则3b而失败</target>
        </trans-unit>
        <trans-unit id="296fa1d7af3bb7cac562c31b466a3232f2bb3696" translate="yes" xml:space="preserve">
          <source>Fails due to rule #5</source>
          <target state="translated">因第5条规则而失败</target>
        </trans-unit>
        <trans-unit id="8ba4b7cd854379dc43efe678aa9fc863d5f197f9" translate="yes" xml:space="preserve">
          <source>Fails due to rule #6</source>
          <target state="translated">因第6条规则而失败</target>
        </trans-unit>
        <trans-unit id="1c882dc98a68cae48a636d1057fb89ac7d36d44d" translate="yes" xml:space="preserve">
          <source>Failure Reason</source>
          <target state="translated">失败原因</target>
        </trans-unit>
        <trans-unit id="c35c802e8500c8d21fd613e5ef4507f4da40a451" translate="yes" xml:space="preserve">
          <source>Fatal screen I/O error</source>
          <target state="translated">致命的屏幕I/O错误</target>
        </trans-unit>
        <trans-unit id="e19ab926093727a391692498a7ce5cfb742d2ae9" translate="yes" xml:space="preserve">
          <source>Field Outlining</source>
          <target state="translated">实地勾画</target>
        </trans-unit>
        <trans-unit id="3e7ab145eda1bc068c4891bdc4d2491b7ca3babf" translate="yes" xml:space="preserve">
          <source>Figurative Constants</source>
          <target state="translated">形象常数</target>
        </trans-unit>
        <trans-unit id="daa8d8ba501862c2b07978aab870f1b814a865ba" translate="yes" xml:space="preserve">
          <source>File Location Strings are used (at runtime) to identify the path and filename to the data file that must be attached to &amp;lt;</source>
          <target state="translated">使用文件位置字符串（在运行时）标识必须附加到&amp;lt;的数据文件的路径和文件名。</target>
        </trans-unit>
        <trans-unit id="0f3e89f8a70a0298352574b5f3d10f8e9f6307ef" translate="yes" xml:space="preserve">
          <source>File Location Strings will be discussed shortly.</source>
          <target state="translated">文件位置字符串将很快被讨论。</target>
        </trans-unit>
        <trans-unit id="30ee6392d050dffb23e534b9b1e788b586e3c285" translate="yes" xml:space="preserve">
          <source>File already open</source>
          <target state="translated">文件已经打开</target>
        </trans-unit>
        <trans-unit id="1f1c6a46840542ee93667be29fe00c4a2ca6e55e" translate="yes" xml:space="preserve">
          <source>File not available</source>
          <target state="translated">文件不详</target>
        </trans-unit>
        <trans-unit id="a22e9c3b6a9f5c70de4f76a464810ecba1fb97c3" translate="yes" xml:space="preserve">
          <source>File not found</source>
          <target state="translated">未找到文件</target>
        </trans-unit>
        <trans-unit id="d5a01ba68e46b606375d0915c493efcb6d3e3101" translate="yes" xml:space="preserve">
          <source>File not open</source>
          <target state="translated">文件无法打开</target>
        </trans-unit>
        <trans-unit id="aa73a3bd94b48e7abeca430b784ba4827580e7e5" translate="yes" xml:space="preserve">
          <source>File section data buffers (and therefore all 01-level record layouts defined in the file section) are initialized to all binary zeros when the program is loaded into storage.</source>
          <target state="translated">文件部分数据缓冲区(因此文件部分定义的所有01级记录布局)在程序加载到存储中时被初始化为所有二进制零。</target>
        </trans-unit>
        <trans-unit id="2b5ebf13d43a94cfe869d3ece0ff8aa5a1595ced" translate="yes" xml:space="preserve">
          <source>File sharing failure</source>
          <target state="translated">文件共享失败</target>
        </trans-unit>
        <trans-unit id="d6b7a316c213638a85b3dd6184fc41aa5cc4fb7b" translate="yes" xml:space="preserve">
          <source>File sharing is controlled through the use of a&lt;code&gt;SHARING&lt;/code&gt;</source>
          <target state="translated">文件共享是通过使用受控 &lt;code&gt;SHARING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f47df965cafac62967f207b6e7f09ae5add8b8f" translate="yes" xml:space="preserve">
          <source>File-Based SORT Syntax</source>
          <target state="translated">基于文件的SORT语法</target>
        </trans-unit>
        <trans-unit id="d87ff91def81de51380ccde36991f463b59063af" translate="yes" xml:space="preserve">
          <source>File/Sort-Description Syntax</source>
          <target state="translated">语法 文件/排序-描述</target>
        </trans-unit>
        <trans-unit id="7083473fe7c031e4e4634ba20b9fb70b80346024" translate="yes" xml:space="preserve">
          <source>Files assigned to&lt;code&gt;PRINTER&lt;/code&gt;or&lt;code&gt;CONSOLE&lt;/code&gt;should be specified as&lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt;</source>
          <target state="translated">分配给 &lt;code&gt;PRINTER&lt;/code&gt; 或 &lt;code&gt;CONSOLE&lt;/code&gt; 的文件应指定为 &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="edea6aacf2ec3d63ce72d8e95db88b7bd15eacd7" translate="yes" xml:space="preserve">
          <source>Files destined for use as sort/merge work files must be described with a Sort/Merge File Description &lt;code&gt;SD&lt;/code&gt; while every other file is described with a File Description &lt;code&gt;FD&lt;/code&gt;. Each of these descriptions will almost always be followed with at least one record description.</source>
          <target state="translated">用作排序/合并工作文件的文件必须使用&amp;ldquo;排序/合并文件描述&amp;rdquo; &lt;code&gt;SD&lt;/code&gt; 进行描述，而其他所有文件都应使用文件描述 &lt;code&gt;FD&lt;/code&gt; 进行描述。这些描述中的每一个几乎总是跟着至少一个记录描述。</target>
        </trans-unit>
        <trans-unit id="367feea21d15dacc3ac862c7a57bd856bad73096" translate="yes" xml:space="preserve">
          <source>Finally, COBOL has the ability to perform in-place sorts of the data that is found in a table.</source>
          <target state="translated">最后,COBOL有能力对表中的数据进行就地排序。</target>
        </trans-unit>
        <trans-unit id="a6001a209721116a31aff91d01e445326ed01374" translate="yes" xml:space="preserve">
          <source>Finally, here&amp;rsquo;s the report the program generates!</source>
          <target state="translated">最后，这是程序生成的报告！</target>
        </trans-unit>
        <trans-unit id="f8e1fd8ed05817c2c1238d06570433fc37097c39" translate="yes" xml:space="preserve">
          <source>Finally,the&lt;code&gt;REPORT FOOTING&lt;/code&gt;group, if any, will be presented.</source>
          <target state="translated">最后，将显示&amp;ldquo; &lt;code&gt;REPORT FOOTING&lt;/code&gt; 组（如果有）。</target>
        </trans-unit>
        <trans-unit id="8a928ac89796afd20a583c169e78e1d2e97f3cee" translate="yes" xml:space="preserve">
          <source>First, the &quot;Hard Way&quot;:</source>
          <target state="translated">一是 &quot;硬道理&quot;。</target>
        </trans-unit>
        <trans-unit id="69a656c5968fc19e26398c39c1d42930578021ec" translate="yes" xml:space="preserve">
          <source>First/Last Digit</source>
          <target state="translated">第一个/最后一个数字</target>
        </trans-unit>
        <trans-unit id="c698ef5e7b0a316052b55cd8ba9f275dd3cc64d1" translate="yes" xml:space="preserve">
          <source>Fixed Format Mode</source>
          <target state="translated">固定格式模式</target>
        </trans-unit>
        <trans-unit id="fb6455fd910bbce0c221e84e30d7a80946a5a47c" translate="yes" xml:space="preserve">
          <source>Floating-point values using &quot;Enn&quot; notation such as 9.92E25, representing 9.92 x 10^25 (10 raised to the 25th power) or 5.7E-14, representing 5.7 x 10^-14 (10 raised to the -14th power). Both the mantissa (the number before the E) and the exponent (the number after the E) may be explicitly specified as positive (with a +), negative (with a -) or unsigned (and therefore implicitly positive). A floating-point literals value must be within the range -1.7 x 10^308 to +1.7 x 10^308 with no more than 15 decimal digits of precision.</source>
          <target state="translated">浮点值使用 &quot;Enn &quot;符号,如9.92E25,表示9.92×10^25(10升至25次方),或5.7E-14,表示5.7×10^-14(10升至-14次方)。尾数(E前面的数字)和指数(E后面的数字)都可以显式地指定为正数(带+)、负数(带-)或无符号(因此隐式为正数)。浮点数的值必须在-1.7 x 10^308到+1.7 x 10^308的范围内,精度不超过15位小数。</target>
        </trans-unit>
        <trans-unit id="5988bca9b2f3443b9ecd1f06fab806eb243168de" translate="yes" xml:space="preserve">
          <source>Footing Area</source>
          <target state="translated">底板面积</target>
        </trans-unit>
        <trans-unit id="e40c95fbb3b9dc7a620c19bde2435c717bde7695" translate="yes" xml:space="preserve">
          <source>Footing Area &amp;mdash; An exception to this is the situation where the report footing report group contains the&lt;code&gt;NEXT PAGE&lt;/code&gt;option in its&lt;code&gt;LINE&lt;/code&gt;(see &lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt;) clause; in those cases, the report footing will be presented on a page by itself at the end of the report.</source>
          <target state="translated">立足点区域&amp;mdash;例外情况是，报表立足点报告组的 &lt;code&gt;LINE&lt;/code&gt; （请参阅&lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt;）子句中包含 &lt;code&gt;NEXT PAGE&lt;/code&gt; 选项；在这种情况下，报告基础将在报告末尾单独显示在页面上。</target>
        </trans-unit>
        <trans-unit id="a3127f980dbd36611f50532c041a2233802b3eff" translate="yes" xml:space="preserve">
          <source>For all other data types, the field size is set to the size of the item (same as if CONVERT were not specified).</source>
          <target state="translated">对于所有其他数据类型,字段大小被设置为项目的大小(与未指定CONVERT时相同)。</target>
        </trans-unit>
        <trans-unit id="c1fcb175d336c0714548be23a006f2304e931f29" translate="yes" xml:space="preserve">
          <source>For each source item, the contents of the sending item will be copied &amp;mdash; character-by-character &amp;mdash; into &amp;lt;</source>
          <target state="translated">对于每个源项目，发送项目的内容将按字符复制到&amp;lt;</target>
        </trans-unit>
        <trans-unit id="cf9156cf449643f9bda337a140c24f2f1504f039" translate="yes" xml:space="preserve">
          <source>For example, You will not expect to see any difference whatsoever between values of 1, 100, 500 or 1000, but you should see a difference between values such as 250000000 and 500000000.</source>
          <target state="translated">例如,你不会期望看到1、100、500或1000的值之间有任何差异,但你应该看到250000000和500000000等值之间的差异。</target>
        </trans-unit>
        <trans-unit id="3368f51d3762d71c83916eebf4457e0236b996e5" translate="yes" xml:space="preserve">
          <source>For example, assuming the program is using the standard ASCII collating sequence,&lt;code&gt;ORD('!')&lt;/code&gt;returns 34 because &quot;!&quot; is the 34th ASCII character. If you are using this function to convert an ASCII character to its numeric value, you must subtract one from the result.</source>
          <target state="translated">例如，假设程序正在使用标准ASCII整理序列，则 &lt;code&gt;ORD('!')&lt;/code&gt; 返回34，因为&amp;ldquo;！&amp;rdquo; 是第34个ASCII字符。如果使用此函数将ASCII字符转换为其数值，则必须从结果中减去1。</target>
        </trans-unit>
        <trans-unit id="55a9ee5de13cdf67bb331bd003f29ecf42021db7" translate="yes" xml:space="preserve">
          <source>For example, assuming the program is using the standard ASCII collating sequence,&lt;code&gt;ORD-MAX('Z', 'z', '!')&lt;/code&gt;returns 2 because the 2nd character in the argument list (the ASCII character &amp;rsquo;z&amp;rsquo;) occurs after &amp;rsquo;Z&amp;rsquo; and &amp;rsquo;!&amp;rsquo; in the program collating sequence. Each &amp;lt;</source>
          <target state="translated">例如，假设程序正在使用标准ASCII整理序列，则 &lt;code&gt;ORD-MAX('Z', 'z', '!')&lt;/code&gt; 返回2，因为参数列表中的第二个字符（ASCII字符&amp;ldquo; z&amp;rdquo;）在'Z'和'！' 在程序整理顺序中。每个&amp;lt;</target>
        </trans-unit>
        <trans-unit id="0b8897a3e322f2447e1c9d83730f3c7e2254e611" translate="yes" xml:space="preserve">
          <source>For example, assuming the program is using the standard ASCII collating sequence,&lt;code&gt;ORD-MIN('Z', 'z', '!')&lt;/code&gt;returns 3 because the 3rd character in the argument list (the ASCII character &amp;rsquo;!&amp;rsquo;) occurs before &amp;rsquo;Z&amp;rsquo; and &amp;rsquo;z&amp;rsquo; in the program collating sequence. Each &amp;lt;</source>
          <target state="translated">例如，假设程序使用的是标准ASCII整理顺序，则 &lt;code&gt;ORD-MIN('Z', 'z', '!')&lt;/code&gt; 返回3，因为参数列表中的第三个字符（ASCII字符&amp;ldquo;！&amp;rdquo;）先于程序整理顺序中的&amp;ldquo; Z&amp;rdquo;和&amp;ldquo; z&amp;rdquo;。每个&amp;lt;</target>
        </trans-unit>
        <trans-unit id="749e13e172aac64f618104a47c4a2c7a40595730" translate="yes" xml:space="preserve">
          <source>For example, if &amp;lt;</source>
          <target state="translated">例如，如果&amp;lt;</target>
        </trans-unit>
        <trans-unit id="24697a3ba1d925f052573a7696493b003e3077cd" translate="yes" xml:space="preserve">
          <source>For example, if the program is using the (default) ASCII character set, CHAR(34) returns the 34th character in the ASCII character set &amp;mdash; an exclamation-point (&quot;!&quot;). If you are using this function to convert a numeric value to its corresponding ASCII character, you must use an argument value one greater than the numeric value.</source>
          <target state="translated">例如，如果程序使用（默认）ASCII字符集，则CHAR（34）返回ASCII字符集中的第34个字符-感叹号（&amp;ldquo;！&amp;rdquo;）。如果使用此函数将数字值转换为其相应的ASCII字符，则必须使用比数字值大一的参数值。</target>
        </trans-unit>
        <trans-unit id="86d303a32d15849fb5f8b370e6bee4a9d77d8625" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s assume we&amp;rsquo;re sorting a series of financial transactions. The SORT statement might look like this:</source>
          <target state="translated">例如，假设我们正在对一系列金融交易进行排序。SORT语句可能如下所示：</target>
        </trans-unit>
        <trans-unit id="fb00a63cdc6f6eb78d00ce4dd102beadda021aab" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say you need to allocate a data item that contains however many millions of dollars of revenue your company has in gross revenues this year:</source>
          <target state="translated">例如，假设您需要分配一个数据项，其中包含公司今年总收入中有数百万美元的收入：</target>
        </trans-unit>
        <trans-unit id="baad68c9ee59c08b3b83b0d9b5e6c9c54362d8ca" translate="yes" xml:space="preserve">
          <source>For example, observe the following data structure which defines a 4 column by 3 row grid of characters:</source>
          <target state="translated">例如,观察以下数据结构,它定义了一个4列3行的字符网格。</target>
        </trans-unit>
        <trans-unit id="3aafb29761d15f601ec670e73bfded28362456c7" translate="yes" xml:space="preserve">
          <source>For example, the following defines a class called &quot;Hexadecimal&quot;, the definition of which specifies the only characters that may be present in an alphanumeric data item if that data item is to be part of the &quot;Hexadecimal&quot; class:</source>
          <target state="translated">例如,下面定义了一个名为 &quot;十六进制 &quot;的类,该类的定义指定了一个字母数字数据项中可能存在的唯一字符,如果该数据项是 &quot;十六进制 &quot;类的一部分。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="dab6ce21e23d5e22f729efd782034eee11b18ef5" translate="yes" xml:space="preserve">
          <source>For files in the&lt;code&gt;SEQUENTIAL&lt;/code&gt;access mode, the last input-output statement executed against &amp;lt;</source>
          <target state="translated">对于处于 &lt;code&gt;SEQUENTIAL&lt;/code&gt; 访问模式的文件，针对&amp;lt;</target>
        </trans-unit>
        <trans-unit id="0033fcaf736090140a9ae955ceeeed639d0db017" translate="yes" xml:space="preserve">
          <source>For non-trivial computations,&lt;code&gt;COMPUTE&lt;/code&gt;statements &quot;read&quot; better. Take this, for example:</source>
          <target state="translated">对于非平凡的计算， &lt;code&gt;COMPUTE&lt;/code&gt; 语句&amp;ldquo;读取&amp;rdquo;效果更好。以这个为例：</target>
        </trans-unit>
        <trans-unit id="4b25cf83aa9b241d27a0438f702e22b38e6a5771" translate="yes" xml:space="preserve">
          <source>For non-trivial computations,&lt;code&gt;COMPUTE&lt;/code&gt;statements may execute faster than the equivalent chain of basic arithmetic statements. For example, the COMPUTE statement shown above executes about 25% faster on my computer using GnuCOBOL than does the MULTIPLY-ADD-DIVIDE sequence.</source>
          <target state="translated">对于非平凡的计算， &lt;code&gt;COMPUTE&lt;/code&gt; 语句的执行速度可能比基本算术语句的等效链更快。例如，上面显示的COMPUTE语句在我的计算机上使用GnuCOBOL的执行速度比MULTIPLY-ADD-DIVIDE序列的执行速度快约25％。</target>
        </trans-unit>
        <trans-unit id="483a043da3e58761a7a31d92b7cee03f34d3a0e9" translate="yes" xml:space="preserve">
          <source>For quite a while now (back to the late 1970&amp;rsquo;s), the &quot;sequence number area&quot; of a COBOL statement (columns 1-6) has come to be used as a change indicator area. Programmers would place a code in columns 1-6 of every line they changed in a program. The author works in a COBOL shop where change indicators of the form &quot;xxmmyy&quot; are required on every altered line of a program &amp;mdash; &quot;xx&quot; is the initials of the programmer while &quot;mmyy&quot; are the month and two-digit year of the date the change was made. This is frequently accompanied by a comment block at or near the top of a COBOL program providing general documentation of what changes were made and what change indicator was used to mark that change.</source>
          <target state="translated">现在已经很长一段时间了（回到1970年代后期），COBOL语句的&amp;ldquo;序列号区域&amp;rdquo;（第1-6列）已被用作变更指示符区域。程序员将在他们在程序中更改的每一行的1-6列中放置一个代码。作者在COBOL商店工作，在程序的每条更改的行上都需要使用&amp;ldquo; xxmmyy&amp;rdquo;形式的更改指示符-&amp;ldquo; xx&amp;rdquo;是程序员的姓名缩写，而&amp;ldquo; mmyy&amp;rdquo;是日期的月份和两位数字进行了更改。这通常在COBOL程序顶部或附近带有注释框，该注释框提供有关所做的更改以及使用哪些更改指示符标记更改的常规文档。</target>
        </trans-unit>
        <trans-unit id="e2dea5e1669c0a9fe3c1fbcb48cb6bd943c60b26" translate="yes" xml:space="preserve">
          <source>For the sake of brevity, this document lists the data in three columns.</source>
          <target state="translated">为简洁起见,本文件分三栏列出数据。</target>
        </trans-unit>
        <trans-unit id="ba325520d21c79af4680da537a3249fca4c6eeab" translate="yes" xml:space="preserve">
          <source>For the values specified on a&lt;code&gt;PAGE LIMIT&lt;/code&gt;clause to be valid, all of the following must be true:</source>
          <target state="translated">为了使 &lt;code&gt;PAGE LIMIT&lt;/code&gt; 子句上指定的值有效，以下所有条件必须为真：</target>
        </trans-unit>
        <trans-unit id="efdae81d538ace29e7236aee7c1c96a4ee6706e5" translate="yes" xml:space="preserve">
          <source>For trivial computations, on the other hand, I prefer the inherent readability of a statement such as this:</source>
          <target state="translated">另一方面,对于琐碎的计算,我更喜欢这样的语句的内在可读性。</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="09bebf0bea412802e3fbb625d9294d89526d28f2" translate="yes" xml:space="preserve">
          <source>Format 1 of the&lt;code&gt;REPLACE&lt;/code&gt;statement can be used to make changes to program source code in much the same way as the&lt;code&gt;REPLACING&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;REPLACE&lt;/code&gt; 语句的格式1 可以用于更改程序源代码，其方式与 &lt;code&gt;REPLACING&lt;/code&gt; 几乎相同</target>
        </trans-unit>
        <trans-unit id="e143df1aa83eabbe82d17220703bff1e6c2ae88e" translate="yes" xml:space="preserve">
          <source>Free Format Mode</source>
          <target state="translated">自由格式模式</target>
        </trans-unit>
        <trans-unit id="fbc349f93c5e079ef91504e8bcea3293322299f8" translate="yes" xml:space="preserve">
          <source>From the sequence of &amp;lt;</source>
          <target state="translated">从&amp;lt;</target>
        </trans-unit>
        <trans-unit id="ffd07c1bac910139b31da58ed3629443089db490" translate="yes" xml:space="preserve">
          <source>Full awareness of where the &quot;pen&quot; is about to &quot;write&quot; on the current page, automatically forcing an eject to a new page, along with the automatic generation of a page footer to close the old page and/or a page header to begin the new one.</source>
          <target state="translated">充分意识到 &quot;笔 &quot;即将在当前页面上 &quot;书写 &quot;的位置,自动强制弹出到新页面,同时自动生成页脚关闭旧页面和/或页眉开始新页面。</target>
        </trans-unit>
        <trans-unit id="3a8b63681a5465651b7dd860e482efb9e8de5eee" translate="yes" xml:space="preserve">
          <source>Full-line comments</source>
          <target state="translated">全行评论</target>
        </trans-unit>
        <trans-unit id="a21a4b632492cfc3397cd22cf7495b9aac4c3cd0" translate="yes" xml:space="preserve">
          <source>Full-line comments with form-feed</source>
          <target state="translated">带表格反馈的全行评论</target>
        </trans-unit>
        <trans-unit id="a09ae3cf11bf198bd67625dda3216ea87527262f" translate="yes" xml:space="preserve">
          <source>Function argument error</source>
          <target state="translated">函数参数错误</target>
        </trans-unit>
        <trans-unit id="fe94fb61bab790759d07739129a3829c99d0ddcc" translate="yes" xml:space="preserve">
          <source>GENERATE Syntax</source>
          <target state="translated">GENERATE 语法</target>
        </trans-unit>
        <trans-unit id="ce7e9bdff283283e8c751261303522d7a587ceec" translate="yes" xml:space="preserve">
          <source>GENERATE, GET, GIVING, GLOBAL, GO, GOBACK, GREATER, GRID, GROUP, GROUP-USAGE</source>
          <target state="translated">生成,得到,奉献,全球,去,归来,更大,GRID,GROUP,GROUP-USAGE.</target>
        </trans-unit>
        <trans-unit id="3f77fc06eaeeaf7f12de14c907a75f7348ac4dc4" translate="yes" xml:space="preserve">
          <source>GLOBAL Attribute Syntax</source>
          <target state="translated">全球属性语法</target>
        </trans-unit>
        <trans-unit id="be6aeb1acd05ec878a2af6fecff181b13e85aa9a" translate="yes" xml:space="preserve">
          <source>GO TO DEPENDING ON Syntax</source>
          <target state="translated">转到根据语法</target>
        </trans-unit>
        <trans-unit id="64f22d3218b9eaee10fe86a76b0f4f7308747bfe" translate="yes" xml:space="preserve">
          <source>GOBACK Syntax</source>
          <target state="translated">GOBACK 语法</target>
        </trans-unit>
        <trans-unit id="508368112dc00f3cf1200af84f7e4f2f7a3b1cbd" translate="yes" xml:space="preserve">
          <source>GROUP-INDICATE Attribute Syntax</source>
          <target state="translated">GROUP-INDICATE 属性 语法说明</target>
        </trans-unit>
        <trans-unit id="c9af09d3388e8d49bb54cf04c1c03cad69919dbf" translate="yes" xml:space="preserve">
          <source>Generally, these routines are intended to match those available in Micro Focus COBOL, ACUCOBOL and directly for GnuCOBOL.</source>
          <target state="translated">一般来说,这些例程旨在匹配Micro Focus COBOL、ACUCOBOL和直接用于GnuCOBOL的例程。</target>
        </trans-unit>
        <trans-unit id="9d41e5d8aa938481797b811e06ef4d213ca2b12d" translate="yes" xml:space="preserve">
          <source>Generic terms representing user-defined substitutable items will be shown entirely in lower-case in syntax diagrams. When such items are referenced in text, they will appear as &amp;lt;</source>
          <target state="translated">代表用户定义的可替换项的通用术语将在语法图中完全以小写形式显示。在文本中引用此类项目时，它们将显示为&amp;lt;</target>
        </trans-unit>
        <trans-unit id="a9457bdd27c6a3d78025d6c377d1adcbbc659a08" translate="yes" xml:space="preserve">
          <source>Getting file information (size and last-modification date/time)</source>
          <target state="translated">获取文件信息(大小和最后修改日期/时间)</target>
        </trans-unit>
        <trans-unit id="75e08852c633c9bcebe7ab91746503bd91ff4946" translate="yes" xml:space="preserve">
          <source>Getting the length (in bytes) of an argument passed to a subroutine</source>
          <target state="translated">获取传递给子程序的参数的长度(以字节为单位)。</target>
        </trans-unit>
        <trans-unit id="838fcc5009c91a67ccafcd3d8a98dceb9843f0c5" translate="yes" xml:space="preserve">
          <source>Giving a table an initial, compile-time value is one of the trickier aspects of COBOL data definition. There are basically three standard techniques and a fourth that people familiar with other COBOL implementations but new to GnuCOBOL may find interesting. So, here are the three</source>
          <target state="translated">给一个表一个初始的、编译时的值是COBOL数据定义中比较棘手的一个方面。基本上有三种标准技术和第四种技术,熟悉其他COBOL实现但对GnuCOBOL不熟悉的人可能会觉得有趣。那么,以下是三种技术</target>
        </trans-unit>
        <trans-unit id="dacd5d80181f68a262558fbeed5d04078293a6de" translate="yes" xml:space="preserve">
          <source>GnuCOBOL</source>
          <target state="translated">GnuCOBOL</target>
        </trans-unit>
        <trans-unit id="b879a384bcf6b18e0b722cf0970e253d133c9742" translate="yes" xml:space="preserve">
          <source>GnuCOBOL Sample Programs</source>
          <target state="translated">GnuCOBOL示例程序</target>
        </trans-unit>
        <trans-unit id="e9fc1fe76cf391a32dad55a122f4e0a0353992f7" translate="yes" xml:space="preserve">
          <source>GnuCOBOL always behaves as if the&lt;code&gt;WITH DUPLICATES IN ORDER&lt;/code&gt;clause is specified, even if it isn&amp;rsquo;t.</source>
          <target state="translated">GnuCOBOL始终表现得就像指定了 &lt;code&gt;WITH DUPLICATES IN ORDER&lt;/code&gt; 子句一样，即使未指定也是如此。</target>
        </trans-unit>
        <trans-unit id="9e90bf626298379ff7d3f8b411b399e5608f6660" translate="yes" xml:space="preserve">
          <source>GnuCOBOL considers&lt;code&gt;ASCII&lt;/code&gt;</source>
          <target state="translated">GnuCOBOL考虑 &lt;code&gt;ASCII&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ade20b6aef56cd0ff2aed2427da9159fa14af39b" translate="yes" xml:space="preserve">
          <source>GnuCOBOL defines compilation variables when certain conditions are true.</source>
          <target state="translated">GnuCOBOL定义了某些条件为真时的编译变量。</target>
        </trans-unit>
        <trans-unit id="12cf00b4626858f857b18dd724c1c9875f678c7e" translate="yes" xml:space="preserve">
          <source>GnuCOBOL fully supports much of the ANSI 85 standard for COBOL (the only major exclusion is the Communications Module) and also supports some of the components of the COBOL2002 standard, such as the&lt;code&gt;SCREEN SECTION&lt;/code&gt;(see &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;), table-based&lt;code&gt;SORT&lt;/code&gt;(see &lt;a href=&quot;#Table-SORT&quot;&gt;Table SORT&lt;/a&gt;) and user-defined functions.</source>
          <target state="translated">GnuCOBOL完全支持大部分针对COBOL的ANSI 85标准（唯一的主要例外是通信模块），并且还支持COBOL2002标准的某些组件，例如 &lt;code&gt;SCREEN SECTION&lt;/code&gt; （请参见&lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;），基于表的 &lt;code&gt;SORT&lt;/code&gt; （请参见&lt;a href=&quot;#Table-SORT&quot;&gt;表SORT&lt;/a&gt;）和用户定义的函数。</target>
        </trans-unit>
        <trans-unit id="97e9d0710dd9b847b88301b5ded4630f6ebd6cf5" translate="yes" xml:space="preserve">
          <source>GnuCOBOL has also been built as a truly native Windows application utilizing Microsoft&amp;rsquo;s freely-downloadable Visual Studio Express package to provide the C compiler and linker/loader. This approach does not lend itself well to a &quot;portable&quot; distribution.</source>
          <target state="translated">GnuCOBOL也已利用Microsoft的可免费下载的Visual Studio Express软件包构建为真正的Windows应用程序，以提供C编译器和链接器/加载器。这种方法不适用于&amp;ldquo;便携式&amp;rdquo;发行版。</target>
        </trans-unit>
        <trans-unit id="763499a319b22b6d28fecd96e5e4577d44422e38" translate="yes" xml:space="preserve">
          <source>GnuCOBOL programs compiled with the&lt;code&gt;-x&lt;/code&gt;switch</source>
          <target state="translated">用 &lt;code&gt;-x&lt;/code&gt; 开关编译的GnuCOBOL程序</target>
        </trans-unit>
        <trans-unit id="20252ad5ff4fe084533d45067eda2369ad4e5568" translate="yes" xml:space="preserve">
          <source>GnuCOBOL run-time screen management must have been initialized prior to CALLing this routine in order to receive meaningful values. This means that a&lt;code&gt;DISPLAY screen-data-item&lt;/code&gt;statement (see &lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY screen-data-item&lt;/a&gt;) or a&lt;code&gt;ACCEPT screen-data-item&lt;/code&gt;statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;) must have been executed prior to executing the&lt;code&gt;CALL&lt;/code&gt;statement.</source>
          <target state="translated">在调用此例程之前，必须先初始化GnuCOBOL运行时屏幕管理，以便接收有意义的值。这意味着在执行 &lt;code&gt;CALL&lt;/code&gt; 语句之前，必须先执行 &lt;code&gt;DISPLAY screen-data-item&lt;/code&gt; 语句（请参见&lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY屏幕数据项&lt;/a&gt;）或 &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; 语句（请参见&lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT屏幕数据项&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bca9afd1bdb28fa197bd33fb7a24153cdc7c56b4" translate="yes" xml:space="preserve">
          <source>GnuCOBOL stores&lt;code&gt;FLOAT-DECIMAL-16&lt;/code&gt;and&lt;code&gt;FLOAT-DECIMAL-34&lt;/code&gt;data items using either Big-Endian or Little-Endian form, whichever is native to the system.</source>
          <target state="translated">GnuCOBOL 使用Big-Endian或Little-Endian格式存储 &lt;code&gt;FLOAT-DECIMAL-16&lt;/code&gt; 和 &lt;code&gt;FLOAT-DECIMAL-34&lt;/code&gt; 数据项，以系统固有的形式为准。</target>
        </trans-unit>
        <trans-unit id="3b9f975d574fd7cc4ea7de4b02075b1a7eaf9bfc" translate="yes" xml:space="preserve">
          <source>GnuCOBOL stores&lt;code&gt;FLOAT-LONG&lt;/code&gt;and&lt;code&gt;FLOAT-SHORT&lt;/code&gt;data items using either Big-Endian or Little-Endian form, whichever is native to the system.</source>
          <target state="translated">GnuCOBOL 使用Big-Endian或Little-Endian格式（系统固有的任何一种）存储 &lt;code&gt;FLOAT-LONG&lt;/code&gt; 和 &lt;code&gt;FLOAT-SHORT&lt;/code&gt; 数据项。</target>
        </trans-unit>
        <trans-unit id="6ab3cffbe92c165a46df6ca158ad1c4a6a0c158c" translate="yes" xml:space="preserve">
          <source>GnuCOBOL subprograms may be created as either static or dynamic subprograms, as desired by the programmer.</source>
          <target state="translated">GnuCOBOL子程序可以根据程序员的需要创建为静态或动态子程序。</target>
        </trans-unit>
        <trans-unit id="183088592eb0fa2ad8ba5f34425e030453ebfcc8" translate="yes" xml:space="preserve">
          <source>GnuCOBOL supports the following visual attribute specifications in the&lt;code&gt;SCREEN SECTION&lt;/code&gt;(see &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;):</source>
          <target state="translated">GnuCOBOL在&amp;ldquo; &lt;code&gt;SCREEN SECTION&lt;/code&gt; 支持以下视觉属性规范（请参见&amp;ldquo; &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;屏幕部分&amp;rdquo;&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="6684809df42a659397430ece5dce09f5dd77386c" translate="yes" xml:space="preserve">
          <source>GnuCOBOL uses compiler configuration files to define various options that will control the compilation process. These configuration files are specified using the&lt;code&gt;-conf&lt;/code&gt;switch</source>
          <target state="translated">GnuCOBOL使用编译器配置文件来定义将控制编译过程的各种选项。这些配置文件是使用 &lt;code&gt;-conf&lt;/code&gt; 开关指定的</target>
        </trans-unit>
        <trans-unit id="3bd06fc3f53a54465c3ccaa768b1a3b1875dd413" translate="yes" xml:space="preserve">
          <source>GnuCOBOL, like other COBOL implementations, supports a number of reserved words that may be used to represent a specific literal value. These are known as figurative constants. See &lt;a href=&quot;#Figurative-Constants&quot;&gt;Figurative Constants&lt;/a&gt;, for more information.</source>
          <target state="translated">与其他COBOL实现一样，GnuCOBOL支持许多保留字，这些保留字可用于表示特定的文字值。这些被称为图形常数。有关更多信息，请参见&lt;a href=&quot;#Figurative-Constants&quot;&gt;图形常量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e2bb4d252c23fe267cb78311b78a5c392a8eb567" translate="yes" xml:space="preserve">
          <source>Good programmers have &amp;mdash; for decades &amp;mdash; maintained their own skeleton &quot;template&quot; programs for a variety of program types; simply load a template into a text editor and you&amp;rsquo;ve got a good start to the program&amp;hellip;</source>
          <target state="translated">优秀的程序员几十年来一直为各种程序类型维护自己的框架式&amp;ldquo;模板&amp;rdquo;程序。只需将模板加载到文本编辑器中，您就可以很好地开始程序了&amp;hellip;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="7bb1297cd4586126018027c7f1e1612420c22c4d" translate="yes" xml:space="preserve">
          <source>Green: COB-COLOR-GREEN</source>
          <target state="translated">绿色:COB-COLOR-GREEN。</target>
        </trans-unit>
        <trans-unit id="7c42686edc5c14ca17081cedfebfa14c924ebc58" translate="yes" xml:space="preserve">
          <source>Group Item</source>
          <target state="translated">集团项目</target>
        </trans-unit>
        <trans-unit id="abf442e977221f7e251a5aee4a674647ed69f44a" translate="yes" xml:space="preserve">
          <source>Group Item &amp;mdash; A group item in which debugging information generated by a&lt;code&gt;USE FOR DEBUGGING&lt;/code&gt;section in the declaratives area of the procedure division will place information documenting why the&lt;code&gt;USE FOR DEBUGGING&lt;/code&gt;procedure was invoked. Consult the&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) documentation for information on the structure of this register.</source>
          <target state="translated">组项目-组项目，其中由 &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; 部分在过程分区的声明性区域中生成的调试信息将放置记录为何调用 &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; 过程的信息。有关该寄存器结构的信息，请查阅 &lt;code&gt;DECLARATIVES&lt;/code&gt; （请参阅&lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;）文档。</target>
        </trans-unit>
        <trans-unit id="810a65e9b0bdcfef9d822c231c10d01c65b32ddf" translate="yes" xml:space="preserve">
          <source>Group items (those without&lt;code&gt;PICTURE&lt;/code&gt;</source>
          <target state="translated">群组项目（没有 &lt;code&gt;PICTURE&lt;/code&gt; 项目</target>
        </trans-unit>
        <trans-unit id="89a17ef0f66b4296a009bd40714a7d880bc71878" translate="yes" xml:space="preserve">
          <source>HEADING, HIGHEST-ALGEBRAIC, HIGHLIGHT, HIGH-VALUE, HIGH-VALUES</source>
          <target state="translated">标题,最高档次,高亮度,高价值,高价值。</target>
        </trans-unit>
        <trans-unit id="30cfc7dc90ba24ab43e38507c7e4463f0560ba02" translate="yes" xml:space="preserve">
          <source>HIGHEST-ALGEBRAIC Function Syntax</source>
          <target state="translated">最强大脑函数语法</target>
        </trans-unit>
        <trans-unit id="d60066848e06a51085c8e2354e105347e3c601c8" translate="yes" xml:space="preserve">
          <source>HIGHLIGHT Attribute Syntax</source>
          <target state="translated">HIGHLIGHT 属性 语法</target>
        </trans-unit>
        <trans-unit id="8c6979d233b84b4e040cc3b6f33204115bd4f223" translate="yes" xml:space="preserve">
          <source>Had there been at least one space to the left and/or the right of the&lt;code&gt;-&lt;/code&gt; there would have been no ambiguity &amp;mdash; the compiler would have been forced to use the individual&lt;code&gt;C&lt;/code&gt;and&lt;code&gt;D&lt;/code&gt;data items.</source>
          <target state="translated">如果左侧和/或右侧至少有一个空格 &lt;code&gt;-&lt;/code&gt; 不会有歧义-编译器将被迫使用单独的 &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt; 数据项。</target>
        </trans-unit>
        <trans-unit id="87a433cf0bc677c32d39cd5b979920082688b536" translate="yes" xml:space="preserve">
          <source>Heading Area</source>
          <target state="translated">标题区域</target>
        </trans-unit>
        <trans-unit id="cbbb9cee65c6576a367576c2ac65ada91311b34f" translate="yes" xml:space="preserve">
          <source>Heading Area &amp;mdash; An exception to this is the situation where the report heading report group contains the&lt;code&gt;NEXT GROUP NEXT PAGE&lt;/code&gt;(see &lt;a href=&quot;#NEXT-GROUP&quot;&gt;NEXT GROUP&lt;/a&gt;) option; in those cases, the report heading will be presented on a page by itself (anywhere on that page) at the beginning of the report.</source>
          <target state="translated">标题区域-例外情况是报告标题报告组包含 &lt;code&gt;NEXT GROUP NEXT PAGE&lt;/code&gt; （请参阅&lt;a href=&quot;#NEXT-GROUP&quot;&gt;NEXT GROUP&lt;/a&gt;）选项；在这种情况下，报告标题将在报告开头单独显示在页面上（该页面上的任何地方）。</target>
        </trans-unit>
        <trans-unit id="9a3fc3dac7c2610f19172d33b654b99f82029bf8" translate="yes" xml:space="preserve">
          <source>Here are a few examples:</source>
          <target state="translated">下面是几个例子。</target>
        </trans-unit>
        <trans-unit id="a58d0be2a26b29065720289affde96b396953bc6" translate="yes" xml:space="preserve">
          <source>Here are some examples of how the precedence of operations affects the results of arithmetic expressions (all examples use numeric literals, to simplify the discussion).</source>
          <target state="translated">下面是一些关于运算的优先性如何影响算术表达式结果的例子(为了简化讨论,所有的例子都使用了数字文字)。</target>
        </trans-unit>
        <trans-unit id="ce8b7658bf191725329e97e66717da8863c93fce" translate="yes" xml:space="preserve">
          <source>Here are the facts &amp;mdash; draw your own conclusions as to which approach is more appropriate under which circumstances.</source>
          <target state="translated">这是事实，请您得出自己的结论，即在哪种情况下哪种方法更合适。</target>
        </trans-unit>
        <trans-unit id="71e41b379565b9db9a0898e306e44094c8f202bb" translate="yes" xml:space="preserve">
          <source>Here are the meanings of the three options:</source>
          <target state="translated">下面是三个选项的含义。</target>
        </trans-unit>
        <trans-unit id="8db79160667581172099438ddb7cbe10fdc25a56" translate="yes" xml:space="preserve">
          <source>Here are the relevant sections of code in a program named &quot;testprog&quot;, which is designed to simply announce if SWITCH-1 is on:</source>
          <target state="translated">下面是一个名为 &quot;testprog &quot;的程序中的相关代码,它的目的是简单地宣布SWITCH-1是否开启。</target>
        </trans-unit>
        <trans-unit id="4806c2364021b8f8145a30057c39a5142245883f" translate="yes" xml:space="preserve">
          <source>Here are the results:</source>
          <target state="translated">下面是结果。</target>
        </trans-unit>
        <trans-unit id="6bcf44b499d0088da0556d2de36d212cd7d4aaa3" translate="yes" xml:space="preserve">
          <source>Here are the rules about GnuCOBOL dynamically-loadable modules:</source>
          <target state="translated">下面是关于GnuCOBOL动态加载模块的规则。</target>
        </trans-unit>
        <trans-unit id="d98760fd5f7d0d451fc2f1b70dda01b46952cd2b" translate="yes" xml:space="preserve">
          <source>Here are two different &quot;Hello World&quot; applications &amp;mdash; one written in Java and the second in GnuCOBOL. First, the Java version:</source>
          <target state="translated">这是两个不同的&amp;ldquo; Hello World&amp;rdquo;应用程序-一个用Java编写，另一个用GnuCOBOL编写。首先，Java版本：</target>
        </trans-unit>
        <trans-unit id="2486c63ce113fa9dfa91ee5ea183529c4d50239f" translate="yes" xml:space="preserve">
          <source>Here are two examples of using&lt;code&gt;cobcrun&lt;/code&gt; First, on a Unix, OSX or Windows/Cygwin system:</source>
          <target state="translated">这是在Unix，OSX或Windows / Cygwin系统上使用 &lt;code&gt;cobcrun&lt;/code&gt; First的两个示例：</target>
        </trans-unit>
        <trans-unit id="88f0b25a36a42c34f75db34b7878e30378e348fc" translate="yes" xml:space="preserve">
          <source>Here is a sample program that illustrates the EVALUATE statement.</source>
          <target state="translated">下面是一个说明EVALUATE语句的示例程序。</target>
        </trans-unit>
        <trans-unit id="b44351443986b8d6208b8077f937b80d2c5d797f" translate="yes" xml:space="preserve">
          <source>Here is an example of a main program (DEMOFACT) that calls both a subprogram (SUB) and a user-defined function (FUNC) to compute the factorial value of a number.</source>
          <target state="translated">这里是一个主程序(DEMOFACT)的例子,它同时调用一个子程序(SUB)和一个用户自定义函数(FUNC)来计算一个数字的阶乘值。</target>
        </trans-unit>
        <trans-unit id="fce56f05dd0a684307248e0509281b28f6150e2a" translate="yes" xml:space="preserve">
          <source>Here is an example. The following two GnuCOBOL statements both display the same result (27):</source>
          <target state="translated">下面是一个例子。下面两个GnuCOBOL语句都显示相同的结果(27)。</target>
        </trans-unit>
        <trans-unit id="b6e578854c806b2cf1a7f51f1181b4443af68716" translate="yes" xml:space="preserve">
          <source>Here is how the main program and the three subprograms could be compiled if the three subprograms are to be dynamic:</source>
          <target state="translated">下面是主程序和三个子程序的编译方法,如果三个子程序是动态的。</target>
        </trans-unit>
        <trans-unit id="b8a4250afe2b9b703be52c8963f7c7e83af93bec" translate="yes" xml:space="preserve">
          <source>Here is how these four programs would be compiled if the three subprograms are to be static:</source>
          <target state="translated">下面是这四个程序的编译方法,如果这三个子程序是静态的。</target>
        </trans-unit>
        <trans-unit id="3885b22c6e4bdc48af657c6fedb7ca8f97433747" translate="yes" xml:space="preserve">
          <source>Here is the data that the program will be reading. Each record reflects the aggregated benchmark scoring for one particular CPU, as scores for benchmarks against that CPU have been reported to the &lt;a href=&quot;https://open-cobol.sourceforge.io/HTML/cpubenchmark.net&quot;&gt;cpubenchmark.net&lt;/a&gt; website by their PassMark benchmark software. The data consists of four fields. Fields are separated from one another by a single comma. The descriptions of the fields are as follows:</source>
          <target state="translated">这是程序将要读取的数据。每条记录反映了一个特定CPU的汇总基准测试得分，因为针对该CPU的基准测试得分已通过其PassMark基准测试软件报告到&lt;a href=&quot;https://open-cobol.sourceforge.io/HTML/cpubenchmark.net&quot;&gt;cpubenchmark.net&lt;/a&gt;网站。数据包含四个字段。字段之间用一个逗号隔开。字段说明如下：</target>
        </trans-unit>
        <trans-unit id="b01180e30ff342f12b30bea352d08df8ee331a14" translate="yes" xml:space="preserve">
          <source>Here is the listing of a GnuCOBOL program that uses 01-level constants to display the length (in bytes) of the various picture-less usage types.</source>
          <target state="translated">这里列出了一个GnuCOBOL程序,该程序使用01级常量来显示各种无图使用类型的长度(以字节为单位)。</target>
        </trans-unit>
        <trans-unit id="73247c417733995d371c239937b20d07507d4db9" translate="yes" xml:space="preserve">
          <source>Here is the program that will be producing the report. Pay attention to how the data is sorted and how the control hierarchy &lt;code&gt;CONTROLS ARE&lt;/code&gt; relates to the&lt;code&gt;SORT&lt;/code&gt;</source>
          <target state="translated">这是将生成报告的程序。注意数据如何排序以及控件层次结构 &lt;code&gt;CONTROLS ARE&lt;/code&gt; 与 &lt;code&gt;SORT&lt;/code&gt; 的关系</target>
        </trans-unit>
        <trans-unit id="e5a81b08e879fde5dd2a59dae3f46849e9f50742" translate="yes" xml:space="preserve">
          <source>Here we see that PROG2 is nested inside of PROG1 because there is no&lt;code&gt;END PROGRAM&lt;/code&gt;marker separating them. This means that data items or files defined within PROG1 can be used within PROG2 simply by attaching the&lt;code&gt;GLOBAL&lt;/code&gt;(see &lt;a href=&quot;#GLOBAL&quot;&gt;GLOBAL&lt;/a&gt;) attribute to them back in PROG1 when they are defined.</source>
          <target state="translated">在这里我们看到PROG2嵌套在PROG1内部，因为没有 &lt;code&gt;END PROGRAM&lt;/code&gt; 标记将它们分开。这意味着在PROG1中定义的数据项或文件可以在PROG2中使用，只需在定义它们时将 &lt;code&gt;GLOBAL&lt;/code&gt; （请参阅&lt;a href=&quot;#GLOBAL&quot;&gt;GLOBAL&lt;/a&gt;）属性附加到PROG1中即可。</target>
        </trans-unit>
        <trans-unit id="9e665b8afaa854f3affd19ae081739fadefc957c" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a demonstration:</source>
          <target state="translated">这是一个示范：</target>
        </trans-unit>
        <trans-unit id="1bb3a890739a2d89878b41828136b7843797b0c4" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a more practical view of the difference. Let&amp;rsquo;s say that a table has 1,000 entries in it. With a sequential search, on average, you&amp;rsquo;ll have to check 500 of them to find an entry and you&amp;rsquo;ll have to look at all 1,000 of them to find that an entry doesn&amp;rsquo;t exist.</source>
          <target state="translated">这是区别的更实际的看法。假设一个表中有1,000个条目。平均而言，通过顺序搜索，您将必须检查其中的500个才能找到条目，并且必须查看所有的1000个才能发现条目不存在。</target>
        </trans-unit>
        <trans-unit id="5e93bdc7d9e913c109cf4064444cedee83b88ddb" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a sample of a GnuCOBOL program that CALLs a C subprogram.</source>
          <target state="translated">这是一个调用C子程序的GnuCOBOL程序的示例。</target>
        </trans-unit>
        <trans-unit id="bce0f5ae6fe98feb4beb66b9de11f14f54d3934d" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a small example:</source>
          <target state="translated">这是一个小例子：</target>
        </trans-unit>
        <trans-unit id="79a379c34c53ce83d07e71356345ea69136a74d1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example:</source>
          <target state="translated">这是一个例子：</target>
        </trans-unit>
        <trans-unit id="b4f96988044521adc26ab35ce61bb5f09db1123c" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the output of the compilation process as well as the program&amp;rsquo;s execution. The example assumes a Windows system with a GnuCOBOL build that uses the GNU C compiler on that system; the technique works equally well regardless of which C compiler and which operating system you&amp;rsquo;re using.</source>
          <target state="translated">这是编译过程以及程序执行的输出。该示例假定Windows系统的GnuCOBOL版本使用该系统上的GNU C编译器。无论您使用哪个C编译器和哪个操作系统，该技术都同样有效。</target>
        </trans-unit>
        <trans-unit id="411f51a5654b397be9062ca82d9069ac5e760156" translate="yes" xml:space="preserve">
          <source>Hexadecimal Alphanumeric Literal</source>
          <target state="translated">十六进制字母数字字词</target>
        </trans-unit>
        <trans-unit id="0622237faae035a0d62bd2b8400c09913d5beb12" translate="yes" xml:space="preserve">
          <source>Hexadecimal Numeric Literal</source>
          <target state="translated">十六进制数字文字</target>
        </trans-unit>
        <trans-unit id="9b5d84e4c523dc629848bb4349e680f8bf34c64b" translate="yes" xml:space="preserve">
          <source>Hexadecimal numeric literals</source>
          <target state="translated">十六进制数字字符</target>
        </trans-unit>
        <trans-unit id="fc83f87e3f62574b840ab2334e64d62930fb1c3c" translate="yes" xml:space="preserve">
          <source>Historically in the early 60&amp;rsquo;s programs were first punched on to paper tape and by the mid 60&amp;rsquo;s that was replaced almost totally, by punched cards although paper tape was still used by programmers for the odd few changes to their sources held on magnetic tape or disk as a portable paper tape punch could be put in your pocket. Now the problem with punched cards were there was 2,000 cards per box and that they could and did, get dropped. So, cc (column) 1 through 6 had the card sequence number in and that way if a box was dropped they could be feed in to a card sorter to be fixed. This was after the cards was cleaned up so that they were all in the same direction which one corner cut out helped.</source>
          <target state="translated">从历史上讲，在60年代初期，程序首先打在纸带上，到60年代中期，打孔卡几乎完全取代了程序，尽管程序员仍然使用纸带来改变磁带或磁盘上存储的源的奇数变化。便携式纸带打孔器可以放在口袋里。现在，打孔卡的问题是每盒有2,000张卡，而且它们可以而且确实会掉落。因此，cc（第1列至第6列）具有卡序列号，这样，如果放下一个盒子，它们可以送入固定的卡片分类器中。这是在清理卡之后，使它们都朝一个切角帮助的方向。</target>
        </trans-unit>
        <trans-unit id="82581b08d1abc17171e1f2f9cf9815374d6d8df7" translate="yes" xml:space="preserve">
          <source>Historically, back in the days when punched-cards were used to submit COBOL program source to a COBOL compiler, this part of a COBOL statement was reserved for a six-digit sequence number. While the contents of this area are ignored by COBOL compilers, it existed so that a program actually punched on 80-character cards could &amp;mdash; if the card deck were dropped on the floor &amp;mdash; be run through a card sorter machine and restored to it&amp;rsquo;s proper sequence. Of course, this isn&amp;rsquo;t necessary today; if truth be told, it hasn&amp;rsquo;t been necessary for a long time.</source>
          <target state="translated">从历史上看，在使用打孔卡将COBOL程序源提交给COBOL编译器的时代，COBOL语句的这一部分保留用于六位序列号。尽管该区域的内容被COBOL编译器忽略，但它的存在是为了使实际打在80个字符的卡片上的程序（如果卡片组掉落在地板上）可以通过卡片分类机运行并恢复到正确的顺序。当然，今天没有必要。如果说实话，很长一段时间都没有必要。</target>
        </trans-unit>
        <trans-unit id="dbfbb76720b9c478938cb351772ad799b84f9efe" translate="yes" xml:space="preserve">
          <source>I also ran the tests multiple times, just to make sure I had consistent results (I did). Like I mentioned earlier, this is not a rigorous, scientific benchmark of numeric performance; it&amp;rsquo;s just a quick-and-dirty comparison.</source>
          <target state="translated">我还多次运行测试，以确保我得到一致的结果（确实如此）。就像我之前提到的，这不是严格的数字性能科学基准。这只是一个简单的比较。</target>
        </trans-unit>
        <trans-unit id="555eb23964b638ebb4898ef46762a788413b2a7a" translate="yes" xml:space="preserve">
          <source>I always include a numeric prefix to all procedure names I define, for the reasons stated earlier.</source>
          <target state="translated">出于前面所述的原因,我总是在我定义的所有存储过程名称中包含一个数字前缀。</target>
        </trans-unit>
        <trans-unit id="df6a4fe99929dd991e0202127b86aa20cecf96af" translate="yes" xml:space="preserve">
          <source>I changed the&lt;code&gt;CONTROLS ARE&lt;/code&gt;clause on the sample program from this:</source>
          <target state="translated">我从此更改了示例程序上的 &lt;code&gt;CONTROLS ARE&lt;/code&gt; 子句：</target>
        </trans-unit>
        <trans-unit id="8d7255df40c7e6bd55c76738ac87c79c48b55013" translate="yes" xml:space="preserve">
          <source>I do not use&lt;code&gt;THRU&lt;/code&gt;on any&lt;code&gt;MERGE&lt;/code&gt;&lt;code&gt;PERFORM&lt;/code&gt;or&lt;code&gt;SORT&lt;/code&gt;statement unless the programming standards of the shop in which I am working require it. My reasoning for this is that it is too easy to accidentally introduce a new procedure into the scope of a&lt;code&gt;THRU&lt;/code&gt;</source>
          <target state="translated">除非我工作所在商店的编程标准要求，否则我不会在任何 &lt;code&gt;MERGE&lt;/code&gt; &lt;code&gt;PERFORM&lt;/code&gt; 或 &lt;code&gt;SORT&lt;/code&gt; 语句中使用 &lt;code&gt;THRU&lt;/code&gt; 。我的理由是，很容易意外地将新过程引入 &lt;code&gt;THRU&lt;/code&gt; 的范围</target>
        </trans-unit>
        <trans-unit id="1fbc97a4457717dc23d1ecc1bf25f471eabb9c4f" translate="yes" xml:space="preserve">
          <source>I like to use procedure division paragraphs and sections as follows:</source>
          <target state="translated">我喜欢用程序划分段和节,如下:</target>
        </trans-unit>
        <trans-unit id="80ed72858cef207934e285ac054f1c8a269fc88f" translate="yes" xml:space="preserve">
          <source>I-O status &quot;1x&quot;</source>
          <target state="translated">I-O状态 &quot;1x&quot;</target>
        </trans-unit>
        <trans-unit id="e7876f32dd29146c722eec80cdba831c36ef9026" translate="yes" xml:space="preserve">
          <source>I-O status &quot;2x&quot;</source>
          <target state="translated">I-O状态 &quot;2x&quot;</target>
        </trans-unit>
        <trans-unit id="76b397e0ec9019d1f6c9d9402f9be35add987c62" translate="yes" xml:space="preserve">
          <source>I-O status &quot;3x&quot;</source>
          <target state="translated">I-O状态 &quot;3x&quot;</target>
        </trans-unit>
        <trans-unit id="6eff1612faad7c99ae78ea1e6080ebc0dc3c4df1" translate="yes" xml:space="preserve">
          <source>I-O status &quot;4x&quot;</source>
          <target state="translated">I-O状态 &quot;4x&quot;</target>
        </trans-unit>
        <trans-unit id="67e793587f319a335dc7c63a71a23c530563d185" translate="yes" xml:space="preserve">
          <source>I-O status &quot;5x&quot;</source>
          <target state="translated">I-O状态 &quot;5x&quot;</target>
        </trans-unit>
        <trans-unit id="b8524f001cba70110ae60dee01287daded416b11" translate="yes" xml:space="preserve">
          <source>I-O status &quot;6x&quot;</source>
          <target state="translated">I-O状态 &quot;6x&quot;</target>
        </trans-unit>
        <trans-unit id="be335b5a5eadd43e4b4e63cf77557e87542095cf" translate="yes" xml:space="preserve">
          <source>I-O status &quot;9x&quot;</source>
          <target state="translated">I-O状态 &quot;9x&quot;</target>
        </trans-unit>
        <trans-unit id="0f12b2d4b4f8188676296a19fede62525110b1c0" translate="yes" xml:space="preserve">
          <source>I-O-CONTROL MULTIPLE FILE Syntax</source>
          <target state="translated">I-O-CONTROL MULTIPLE FILE 语法描述</target>
        </trans-unit>
        <trans-unit id="6f75dae5c47d389ce684040629f1e36258a6ce54" translate="yes" xml:space="preserve">
          <source>I-O-CONTROL SAME AREA Syntax</source>
          <target state="translated">I-O-CONTROL SAME AREA 语法说明</target>
        </trans-unit>
        <trans-unit id="9c32595038680ec5b76e6c8935109525fa67eebc" translate="yes" xml:space="preserve">
          <source>ID, IDENTIFICATION, IF, IGNORE, IGNORING, IMPLEMENTS, IN, INDEX, INDEXED, INDICATE, INHERITS, INITIAL, INITIALISE, INITIALISED, INITIALIZE, INITIALIZED, INITIATE, INPUT, INPUT-OUTPUT, INSPECT, INSTALLATION, INTEGER, INTEGER-OF-BOOLEAN, INTEGER-OF-DATE, INTEGER-OF-DAY, INTEGER-OF-FORMATTED-DATE, INTEGER-PART, INTERFACE, INTERFACE-ID, INTERMEDIATE, INTO, INTRINSIC, INVALID, INVOKE, I-O, I-O-CONTROL, IS</source>
          <target state="translated">ID,IDENTIFICATION,IF,IGNORE,IGNORING,IMPLEMENTS,IN,INDEX,INDEXED,INDICATE,INHERITS,INITIAL,INITIALISE,INITIALISED,INITIALIZE,INITIALIZED,INITIATE,INPUT,INPUT-OUTPUT,INSPECT,INSTALLATION,INTEGER,INTEGER-OF-BOOLEAN,INTEGER-OF-DATE,INTEGER-OF-DAY,INTEGER-OF-FORMATTED-DATE,INTEGER-PART,INTERFACE,INTERFACE-ID,INTERMEDIATE,INTO,INTRINSIC,INVALID,INVOKE,I-O,I-O-CONTROL,IS</target>
        </trans-unit>
        <trans-unit id="9b9c55248e0c5e189619271ca0ded3b5bd005453" translate="yes" xml:space="preserve">
          <source>IDENTIFICATION DIVISION Syntax</source>
          <target state="translated">识别区 语法</target>
        </trans-unit>
        <trans-unit id="b825b4511a0db8bbe7c5d10a6be13d4b3f73d3e5" translate="yes" xml:space="preserve">
          <source>IF Syntax</source>
          <target state="translated">IF 语法</target>
        </trans-unit>
        <trans-unit id="8a579c7bbbf6cdd11286272217a8b94f74b4f75a" translate="yes" xml:space="preserve">
          <source>INITIALIZE Syntax</source>
          <target state="translated">INITIALIZE 语法</target>
        </trans-unit>
        <trans-unit id="f22feedf7bc3a1ceec5b7c202882c8aa6f0e185d" translate="yes" xml:space="preserve">
          <source>INITIATE Syntax</source>
          <target state="translated">INITIATE 语法</target>
        </trans-unit>
        <trans-unit id="4f5b873e331f2e93c7e38f36475cf57cbfec3d6a" translate="yes" xml:space="preserve">
          <source>INPUT-OUTPUT SECTION Syntax</source>
          <target state="translated">INPUT-OUTPUT SECTION 命令格式</target>
        </trans-unit>
        <trans-unit id="baa55ae57b9d3c323f03e28edc87f8c479cca623" translate="yes" xml:space="preserve">
          <source>INSPECT Syntax</source>
          <target state="translated">INSPECT 语法</target>
        </trans-unit>
        <trans-unit id="078ab307f07f53957c6ec7a0918c5e4474c21ea5" translate="yes" xml:space="preserve">
          <source>INTEGER Function Syntax</source>
          <target state="translated">INTEGER 函数语法</target>
        </trans-unit>
        <trans-unit id="2c22d504f0b728c455886a880af6cd5a9ad23315" translate="yes" xml:space="preserve">
          <source>INTEGER-OF-DATE Function Syntax</source>
          <target state="translated">INTEGER-OF-DATE 函数语法</target>
        </trans-unit>
        <trans-unit id="c56815bbf474260cef47707dfeb34754b39ce7d9" translate="yes" xml:space="preserve">
          <source>INTEGER-OF-DAY Function Syntax</source>
          <target state="translated">INTEGER-OF-DAY 函数语法</target>
        </trans-unit>
        <trans-unit id="8690212db49eea2a08db459f36ed19a01dcc1797" translate="yes" xml:space="preserve">
          <source>INTEGER-PART Function Syntax</source>
          <target state="translated">INTEGER-PART 函数语法</target>
        </trans-unit>
        <trans-unit id="b7b5138514830769db3bcc33e44ecf17e41dd72e" translate="yes" xml:space="preserve">
          <source>INVALID KEY Syntax</source>
          <target state="translated">INVALID KEY 语法</target>
        </trans-unit>
        <trans-unit id="1e0e983b66f7b85304dc35598bdbe112fd3d5cf6" translate="yes" xml:space="preserve">
          <source>Identified sub strings will be moved into each destination field in the sequence they are identified; values moved into a destination field will be truncated if the sub string length exceeds the destination field length, or padded with spaces if the destination field length exceeds the sub string length. Both truncation and padding will be controlled by the presence or absence of a&lt;code&gt;JUSTIFIED&lt;/code&gt;(see &lt;a href=&quot;#JUSTIFIED&quot;&gt;JUSTIFIED&lt;/a&gt;) clause on the destination field.</source>
          <target state="translated">识别出的子字符串将按照它们被识别的顺序移入每个目标字段。如果子字符串长度超过目标字段长度，则移入目标字段的值将被截断；如果目标字段长度超过子字符串长度，则将用空格填充。截断和填充都将由目标字段上是否存在 &lt;code&gt;JUSTIFIED&lt;/code&gt; （请参见&lt;a href=&quot;#JUSTIFIED&quot;&gt;JUSTIFIED&lt;/a&gt;）子句来控制。</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="85fdddf7199ca1a02d1e410b6661de3c0d82e8ec" translate="yes" xml:space="preserve">
          <source>If &amp;lt;</source>
          <target state="translated">如果&amp;lt;</target>
        </trans-unit>
        <trans-unit id="a4c0ae6969ecd1edf278dc7c43adf6ccf840a59b" translate="yes" xml:space="preserve">
          <source>If CALL &quot;literal&quot; is used, the subroutine can only be located and linked with the calling program at compilation time.</source>
          <target state="translated">如果使用CALL &quot;字面&quot;,子程序只能在编译时与调用程序进行定位和链接。</target>
        </trans-unit>
        <trans-unit id="fb834ae0ee1fee06659da54155901a048c8ab107" translate="yes" xml:space="preserve">
          <source>If CALL &quot;literal&quot; is used, the subroutine will be located and linked in with the calling program at compile time or may be dynamically located and loaded at execution time, depending on compiler switch settings and operating system capabilities.</source>
          <target state="translated">如果使用CALL &quot;literal&quot;,子程序将在编译时与调用程序一起被定位和链接,也可能在执行时被动态定位和加载,这取决于编译器开关设置和操作系统的能力。</target>
        </trans-unit>
        <trans-unit id="1c0a19ff2f39be755da80b6e4db03b3261af8ab0" translate="yes" xml:space="preserve">
          <source>If COB_SET_TRACE is set to Y, then tracing will always occur regardless of the presence of READY TRACE or RESET TRACE so in effect they will have no action on program execution.</source>
          <target state="translated">如果COB_SET_TRACE被设置为Y,那么无论是否存在READY TRACE或RESET TRACE,跟踪都会发生,因此实际上它们对程序执行没有任何作用。</target>
        </trans-unit>
        <trans-unit id="fca0edd85d905b4998e39dbc0abfe08d59abf9e2" translate="yes" xml:space="preserve">
          <source>If Replace Mode is currently active, a&lt;code&gt;REPLACE LAST OFF.&lt;/code&gt;will replace the current replace specification(s) with those popped off the top of the stack. If there were no replace specification(s) on the stack, the effect will be as if a&lt;code&gt;REPLACE OFF.&lt;/code&gt;had been coded.</source>
          <target state="translated">如果&amp;ldquo;替换模式&amp;rdquo;当前处于活动状态，则&amp;ldquo; &lt;code&gt;REPLACE LAST OFF.&lt;/code&gt; 一次替换&amp;rdquo;。将使用从堆栈顶部弹出的那些替换规范替换当前的替换规范。如果堆栈上没有替换规范，则效果将类似于&amp;ldquo; &lt;code&gt;REPLACE OFF.&lt;/code&gt; 已被编码。</target>
        </trans-unit>
        <trans-unit id="3aa454bf040b4488335636d3825b242cd96c6894" translate="yes" xml:space="preserve">
          <source>If Replace Mode is currently active, a&lt;code&gt;REPLACE OFF.&lt;/code&gt;will deactivate Replace Mode and discard any replace specification(s) on the stack. The compiler will henceforth operate as if no&lt;code&gt;REPLACE&lt;/code&gt;had ever been encountered, until such time as another Format 1&lt;code&gt;REPLACE&lt;/code&gt;is encountered.</source>
          <target state="translated">如果&amp;ldquo;替换模式&amp;rdquo;当前处于活动状态，则&amp;ldquo; &lt;code&gt;REPLACE OFF.&lt;/code&gt; 将停用替换模式并丢弃堆栈上的所有替换规范。此后，编译器将像从未遇到过 &lt;code&gt;REPLACE&lt;/code&gt; 一样运行，直到遇到另一种Format 1 &lt;code&gt;REPLACE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9f8b4a7fa7d08d0000f216b49dbe0fdb7aba40b" translate="yes" xml:space="preserve">
          <source>If Replace Mode is currently inactive, the Format 2 REPLACE statement will be ignored.</source>
          <target state="translated">如果替换模式当前处于非活动状态,格式2 REPLACE语句将被忽略。</target>
        </trans-unit>
        <trans-unit id="02d270f35c2331a3f0b66309eedab53f64314826" translate="yes" xml:space="preserve">
          <source>If a &amp;lt;</source>
          <target state="translated">如果&amp;lt;</target>
        </trans-unit>
        <trans-unit id="eab9e954d4363fe95501767a50e10db235e4192f" translate="yes" xml:space="preserve">
          <source>If a &amp;lt;&amp;lt;</source>
          <target state="translated">如果&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="fc1c32024a481de06916a31d66dbe9f8f79db74e" translate="yes" xml:space="preserve">
          <source>If a &amp;rsquo;</source>
          <target state="translated">如果一个 '</target>
        </trans-unit>
        <trans-unit id="edb4a54100b677ae4d121fffad6d12711ca6c737" translate="yes" xml:space="preserve">
          <source>If a dynamically-loadable module unloaded by the&lt;code&gt;CANCEL&lt;/code&gt;statement is subsequently re-executed, all data division storage for that module will once again be in it&amp;rsquo;s initial state.</source>
          <target state="translated">如果随后重新执行由 &lt;code&gt;CANCEL&lt;/code&gt; 语句卸载的可动态加载的模块，则该模块的所有数据分区存储将再次处于其初始状态。</target>
        </trans-unit>
        <trans-unit id="df6f3afc62331cf6c1dea91965aa4ef057173188" translate="yes" xml:space="preserve">
          <source>If a numeric literal or&lt;code&gt;PIC 9&lt;/code&gt;identifier is specified as an argument, decimal points, if any, will be removed and negative signs in&lt;code&gt;PIC S9&lt;/code&gt;fields or numeric literals will be inserted as defined by the&lt;code&gt;SIGN IS&lt;/code&gt;(see &lt;a href=&quot;#SIGN-IS&quot;&gt;SIGN IS&lt;/a&gt;) clause (or absence thereof) of the field. Numeric literals are processed as if&lt;code&gt;SIGN IS TRAILING SEPARATE&lt;/code&gt;were in effect.</source>
          <target state="translated">如果将数字文字或 &lt;code&gt;PIC 9&lt;/code&gt; 标识符指定为参数，则将删除小数点（如果有的话），并按照 &lt;code&gt;SIGN IS&lt;/code&gt; （请参阅&lt;a href=&quot;#SIGN-IS&quot;&gt;SIGN IS&lt;/a&gt;）子句的定义插入 &lt;code&gt;PIC S9&lt;/code&gt; 字段或数字文字中的负号。缺少）。数值字面量的处理就好像 &lt;code&gt;SIGN IS TRAILING SEPARATE&lt;/code&gt; 一样有效。</target>
        </trans-unit>
        <trans-unit id="57490b79cb430dd4450134ac2677f6cf11e26604" translate="yes" xml:space="preserve">
          <source>If a report data item&amp;rsquo;s description includes the&lt;code&gt;SOURCE&lt;/code&gt;(see &lt;a href=&quot;#SOURCE&quot;&gt;SOURCE&lt;/a&gt;),&lt;code&gt;SUM&lt;/code&gt;(see &lt;a href=&quot;#SUM&quot;&gt;SUM&lt;/a&gt;) or&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause but has no&lt;code&gt;COLUMN&lt;/code&gt;clause,&lt;code&gt;COLUMN PLUS 1&lt;/code&gt;will be assumed.</source>
          <target state="translated">如果报表数据项的描述包含 &lt;code&gt;SOURCE&lt;/code&gt; （请参阅&lt;a href=&quot;#SOURCE&quot;&gt;SOURCE&lt;/a&gt;）， &lt;code&gt;SUM&lt;/code&gt; （请参阅&lt;a href=&quot;#SUM&quot;&gt;SUM&lt;/a&gt;）或 &lt;code&gt;VALUE&lt;/code&gt; （请参阅&lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;）子句，但不包含 &lt;code&gt;COLUMN&lt;/code&gt; 子句，则将使用 &lt;code&gt;COLUMN PLUS 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="71da1ffb9548582f3fa4c8e682811f42638458f2" translate="yes" xml:space="preserve">
          <source>If a screen data item&amp;rsquo;s description includes the&lt;code&gt;FROM&lt;/code&gt;(see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;),&lt;code&gt;TO&lt;/code&gt;(see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;),&lt;code&gt;USING&lt;/code&gt;(see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) or&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause but has no LINE clause, the &quot;current screen line&quot; will be assumed.</source>
          <target state="translated">如果屏幕数据项的描述包含 &lt;code&gt;FROM&lt;/code&gt; （请参阅&lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;）， &lt;code&gt;TO&lt;/code&gt; （请参阅&lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;）， &lt;code&gt;USING&lt;/code&gt; （请参阅&lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;）或 &lt;code&gt;VALUE&lt;/code&gt; （请参阅&lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;）子句，但没有LINE子句，则将假定为&amp;ldquo;当前屏幕行&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="48d3ea6a5c04f441a3bbe9ad4aa57d07cef44e81" translate="yes" xml:space="preserve">
          <source>If a screen data item&amp;rsquo;s description includes the&lt;code&gt;FROM&lt;/code&gt;(see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;),&lt;code&gt;TO&lt;/code&gt;(see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;),&lt;code&gt;USING&lt;/code&gt;(see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) or&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause but has no&lt;code&gt;COLUMN&lt;/code&gt;clause, the new screen field will begin at the column coordinate of the last character of the previous field.</source>
          <target state="translated">如果屏幕数据项的描述包含 &lt;code&gt;FROM&lt;/code&gt; （请参阅&lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;）， &lt;code&gt;TO&lt;/code&gt; （请参阅&lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;）， &lt;code&gt;USING&lt;/code&gt; （请参阅&lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;）或 &lt;code&gt;VALUE&lt;/code&gt; （请参阅&lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;）子句，但不包含 &lt;code&gt;COLUMN&lt;/code&gt; 子句，则新的屏幕字段将从该字段的列坐标开始前一个字段的最后一个字符。</target>
        </trans-unit>
        <trans-unit id="1ecf4f102cec092a989e853dbb05716d18d10735" translate="yes" xml:space="preserve">
          <source>If a subprogram does not expect any arguments, it should not have a&lt;code&gt;USING&lt;/code&gt;clause specified on it&amp;rsquo;s procedure division header.</source>
          <target state="translated">如果子程序不希望有任何参数，则不应在其过程划分头中指定 &lt;code&gt;USING&lt;/code&gt; 子句。</target>
        </trans-unit>
        <trans-unit id="92b7f84efc871dae3988a9b29ad470f6b8703091" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;CONVERTING&lt;/code&gt;</source>
          <target state="translated">如果正在 &lt;code&gt;CONVERTING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2032d4dadae8be3fe061169d553c0926d6a379ee" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;DEFAULT&lt;/code&gt;clause is specified, any remaining uninitialized members of the field list will be initialized according to the default for their class (numeric and numeric-edited are initialized to ZERO, all others are initialized to SPACES).</source>
          <target state="translated">如果指定了 &lt;code&gt;DEFAULT&lt;/code&gt; 子句，则字段列表中所有剩余的未初始化成员将根据其类的默认值进行初始化（将数字和数字编辑的值初始化为ZERO，将所有其他的值初始化为SPACES）。</target>
        </trans-unit>
        <trans-unit id="7156dc318e4e3f5aa0881e3dc01f136733e5ac30" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;GO TO&lt;/code&gt;is executed within the scope of&amp;hellip;</source>
          <target state="translated">如果在...的范围内执行了 &lt;code&gt;GO TO&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e12db606ad57abcf661cf0d99d8020cc167d9db0" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;LINAGE&lt;/code&gt;clause is also specified, Values specified for&lt;code&gt;LINAGE IS&lt;/code&gt;and&lt;code&gt;FOOTING AT&lt;/code&gt;will be ignored. The values of&lt;code&gt;LINES AT BOTTOM&lt;/code&gt;and&lt;code&gt;LINES AT TOP&lt;/code&gt; if any, will be honoured.</source>
          <target state="translated">如果还指定了 &lt;code&gt;LINAGE&lt;/code&gt; 子句，则将忽略为 &lt;code&gt;LINAGE IS&lt;/code&gt; 和 &lt;code&gt;FOOTING AT&lt;/code&gt; 指定的值。值 &lt;code&gt;LINES AT BOTTOM&lt;/code&gt; 和 &lt;code&gt;LINES AT TOP&lt;/code&gt; 如果有的话，会受到尊重。</target>
        </trans-unit>
        <trans-unit id="b64062bb86b4cc026b65a0da4120142c176e5547" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;REMAINDER&lt;/code&gt;clause is specified, the value of the one and only &amp;lt;</source>
          <target state="translated">如果指定了 &lt;code&gt;REMAINDER&lt;/code&gt; 子句，则一个且仅&amp;lt;</target>
        </trans-unit>
        <trans-unit id="c8a9ba4a49154db62b70c94627e9f9a09a50f6f3" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;REPLACING&lt;/code&gt;clause is specified on the&lt;code&gt;INITIALIZE&lt;/code&gt;statement, each qualifying member of the field list that was not already initialized by a&lt;code&gt;VALUE&lt;/code&gt;clause, if any, will be initialized to the specified &amp;lt;</source>
          <target state="translated">如果在 &lt;code&gt;INITIALIZE&lt;/code&gt; 语句上指定了 &lt;code&gt;REPLACING&lt;/code&gt; 子句，则尚未由 &lt;code&gt;VALUE&lt;/code&gt; 子句初始化的字段列表的每个合格成员（如果有）将被初始化为指定的&amp;lt;</target>
        </trans-unit>
        <trans-unit id="5b838d7717f95d20a08cd03498f7882a18db7072" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;TALLYING&lt;/code&gt;clause is coded, &amp;lt;</source>
          <target state="translated">如果对 &lt;code&gt;TALLYING&lt;/code&gt; 子句进行了编码，则&amp;lt;</target>
        </trans-unit>
        <trans-unit id="42850d1581077257d5fcf6cbd3d76feb45a57582" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;USE FOR DEBUGGING&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) section exists, the code within it will be disabled unless this environment variable is set to a value of &quot;Y&quot;, &quot;y&quot; or &quot;1&quot;.</source>
          <target state="translated">如果存在 &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; （请参阅&lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;）部分，则除非该环境变量的值设置为&amp;ldquo; Y&amp;rdquo;，&amp;ldquo; y&amp;rdquo;或&amp;ldquo; 1&amp;rdquo;，否则将禁用其中的代码。</target>
        </trans-unit>
        <trans-unit id="936f63734566944fcd01e49ee30a1e66bbeaea72" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;VALUE&lt;/code&gt;clause is specified on the&lt;code&gt;INITIALIZE&lt;/code&gt;statement, each qualifying member of the field list having a compile-time&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) specified in it&amp;rsquo;s definition will be initialized to that value. Field list members with&lt;code&gt;VALUE&lt;/code&gt;clauses will qualify for this treatment as follows:</source>
          <target state="translated">如果 &lt;code&gt;VALUE&lt;/code&gt; 在指定条款 &lt;code&gt;INITIALIZE&lt;/code&gt; 语句，其编译时间字段列表中的每个符合条件的成员 &lt;code&gt;VALUE&lt;/code&gt; （见&lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;）在它的定义中指定将被初始化到该值。具有 &lt;code&gt;VALUE&lt;/code&gt; 子句的字段列表成员将有资格获得以下待遇：</target>
        </trans-unit>
        <trans-unit id="bbb21152f55feeb2156f854427c62c771c0ef692" translate="yes" xml:space="preserve">
          <source>If all &amp;lt;</source>
          <target state="translated">如果全部&amp;lt;</target>
        </trans-unit>
        <trans-unit id="82152df9872b03795b0f65167d26e2e94749c462" translate="yes" xml:space="preserve">
          <source>If an argument identifier is smaller in storage size than the token value to be stored in it, the right-most excess characters of the token value will be truncated as the value is moved in. Any JUSTIFIED RIGHT clause on such an argument identifier will be ignored.</source>
          <target state="translated">如果一个参数标识符的存储大小小于要存储在其中的标记值,那么当值被移入时,标记值最右边的多余字符将被截断。任何关于这种参数标识符的JUSTIFIED RIGHT子句将被忽略。</target>
        </trans-unit>
        <trans-unit id="bccb47600312a31302d4243c123c27cac5d4e303" translate="yes" xml:space="preserve">
          <source>If an argument is larger in storage size than the token value to be stored in it, the token value will be moved into the argument identifier in a left-justified manner. unmodified-modified byte positions in the identifier will be space filled, unless the argument identifier is defined as PIC 9 USAGE DISPLAY, in which case unmodified bytes will be filled with &quot;0&quot; characters from the systems native character set.</source>
          <target state="translated">如果一个参数的存储大小大于要存储在其中的标记值,标记值将以左对齐的方式移动到参数标识符中。标识符中未经修改的字节位置将被填满,除非参数标识符被定义为PIC 9 USAGE DISPLAY,在这种情况下,未经修改的字节将被系统本地字符集中的 &quot;0 &quot;字符填充。</target>
        </trans-unit>
        <trans-unit id="14f8fa4ce97209c48ec71484cb50b99ef2bd0709" translate="yes" xml:space="preserve">
          <source>If an argument lacks a&lt;code&gt;BY&lt;/code&gt;clause, the most-recently encountered&lt;code&gt;BY&lt;/code&gt;specification on that&lt;code&gt;CALL&lt;/code&gt;statement will be assumed. If the first argument specified on a&lt;code&gt;CALL&lt;/code&gt;lacks a&lt;code&gt;BY&lt;/code&gt;clause,&lt;code&gt;BY REFERENCE&lt;/code&gt;will be assumed.</source>
          <target state="translated">如果参数缺少 &lt;code&gt;BY&lt;/code&gt; 子句，则将假定该 &lt;code&gt;CALL&lt;/code&gt; 语句上最近遇到的 &lt;code&gt;BY&lt;/code&gt; 规范。如果在 &lt;code&gt;CALL&lt;/code&gt; 上指定的第一个参数缺少 &lt;code&gt;BY&lt;/code&gt; 子句，则将采用 &lt;code&gt;BY REFERENCE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05823b59c6e317b0d6f6bda99166cee75a4f73b6" translate="yes" xml:space="preserve">
          <source>If an argument whose value is less than 1 or greater than 256 is specified, the character in the program collating sequence corresponding to a value of all zero bits is returned.</source>
          <target state="translated">如果指定了一个值小于1或大于256的参数,则返回程序整理序列中对应于所有零位值的字符。</target>
        </trans-unit>
        <trans-unit id="2b8c1834ab8abb452a19e34dee7da8437a78703c" translate="yes" xml:space="preserve">
          <source>If an environment variable was found, it&amp;rsquo;s value will serve as the path and filename to the data file.</source>
          <target state="translated">如果找到环境变量，则其值将用作数据文件的路径和文件名。</target>
        </trans-unit>
        <trans-unit id="bcab58a3e462d384fa130cd4e9016e959b6a71b4" translate="yes" xml:space="preserve">
          <source>If an&lt;code&gt;ASSIGN&lt;/code&gt;clause is coded without a &amp;lt;&amp;lt;</source>
          <target state="translated">如果 &lt;code&gt;ASSIGN&lt;/code&gt; 子句的编码不带&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="c44efa18b320631b1a96a201bad730ca80153f8d" translate="yes" xml:space="preserve">
          <source>If an&lt;code&gt;EXIT PARAGRAPH&lt;/code&gt;statement or&lt;code&gt;EXIT SECTION&lt;/code&gt;statement resides</source>
          <target state="translated">如果驻留 &lt;code&gt;EXIT PARAGRAPH&lt;/code&gt; 语句或 &lt;code&gt;EXIT SECTION&lt;/code&gt; 语句</target>
        </trans-unit>
        <trans-unit id="87612bdd6bb75a44b81526c8c27d9968de497f3d" translate="yes" xml:space="preserve">
          <source>If an&lt;code&gt;EXIT PARAGRAPH&lt;/code&gt;statement or&lt;code&gt;EXIT SECTION&lt;/code&gt;statement resides in a paragraph</source>
          <target state="translated">如果 &lt;code&gt;EXIT PARAGRAPH&lt;/code&gt; 语句或 &lt;code&gt;EXIT SECTION&lt;/code&gt; 语句位于段落中</target>
        </trans-unit>
        <trans-unit id="3f0242e3af04c028a1ddce44867fb3964faf61b9" translate="yes" xml:space="preserve">
          <source>If an&lt;code&gt;INITIATE&lt;/code&gt;is followed by a&lt;code&gt;TERMINATE&lt;/code&gt;with no intervening&lt;code&gt;GENERATE&lt;/code&gt;(see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) statements (all pertaining to the same report, of course), no report groups will be presented to the output file.</source>
          <target state="translated">如果在 &lt;code&gt;INITIATE&lt;/code&gt; 之后是 &lt;code&gt;TERMINATE&lt;/code&gt; ，而中间没有 &lt;code&gt;GENERATE&lt;/code&gt; （请参阅&lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;）语句（当然，所有语句都与同一报告有关），则不会将报告组呈现给输出文件。</target>
        </trans-unit>
        <trans-unit id="1989e1692cf63856050ee6de069649854e1b7eed" translate="yes" xml:space="preserve">
          <source>If any &amp;lt;</source>
          <target state="translated">如果有&amp;lt;</target>
        </trans-unit>
        <trans-unit id="ded48aebbdbbf018e482c90608c9d4d54578f860" translate="yes" xml:space="preserve">
          <source>If any of the paragraphs within one of the sections are coded, the section header itself must be coded.</source>
          <target state="translated">如果其中一节内的任何段落被编码,则该节标题本身必须被编码。</target>
        </trans-unit>
        <trans-unit id="098c66a7cc7db43fe1a5e65ab50d6051cee41a88" translate="yes" xml:space="preserve">
          <source>If at least one&lt;code&gt;GENERATE&lt;/code&gt;statement of this form is executed against a report, the report is said to be a &amp;rsquo;</source>
          <target state="translated">如果针对一个报告执行了至少一个此表的 &lt;code&gt;GENERATE&lt;/code&gt; 语句，则该报告被称为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="bbb1f438e0e2ddccdd230dea44836bc244c52259" translate="yes" xml:space="preserve">
          <source>If both optional sections of this division are coded, they must be coded in the sequence shown.</source>
          <target state="translated">如果本分部的两个可选部分都进行编码,则必须按所示顺序进行编码。</target>
        </trans-unit>
        <trans-unit id="e41dfd24c49449dc06a287d66915bfb31196edfa" translate="yes" xml:space="preserve">
          <source>If both statement types are coded in the&lt;code&gt;I-O-CONTROL&lt;/code&gt;paragraph, the order in which those statements are coded is irrelevant.</source>
          <target state="translated">如果两种语句类型均在 &lt;code&gt;I-O-CONTROL&lt;/code&gt; 段落中编码，则这些语句的编码顺序无关紧要。</target>
        </trans-unit>
        <trans-unit id="776f3c5eecbcd34d511d3925b8b352f3fe294871" translate="yes" xml:space="preserve">
          <source>If both the&lt;code&gt;TALLYING&lt;/code&gt;and&lt;code&gt;REPLACING&lt;/code&gt;clauses are specified, they must be specified in the order shown.</source>
          <target state="translated">如果同时 &lt;code&gt;TALLYING&lt;/code&gt; ，并 &lt;code&gt;REPLACING&lt;/code&gt; 指定的条款，他们必须在显示的顺序来指定。</target>
        </trans-unit>
        <trans-unit id="49551f9075c0114086955d559a1442bce3fdaf10" translate="yes" xml:space="preserve">
          <source>If control of execution is transferred to a procedure named on the statement, and the&lt;code&gt;GO TO&lt;/code&gt;is executed within the scope of&amp;hellip;</source>
          <target state="translated">如果执行控制权转移到该语句中命名的过程，并且 &lt;code&gt;GO TO&lt;/code&gt; 在以下范围内执行：</target>
        </trans-unit>
        <trans-unit id="25bbb2134d570b993f324faa68838566a3259e83" translate="yes" xml:space="preserve">
          <source>If copybooks your program needs are NOT stored in the same directory as your program, set this environment variable to the folder in which the copybooks may be found (IBM mainframe programmers will recognize this as &quot;SYSLIB&quot;).</source>
          <target state="translated">如果你的程序所需要的拷贝本没有和你的程序存放在同一个目录下,那么就把这个环境变量设置为可以找到拷贝本的文件夹(IBM大型机程序员会把它识别为 &quot;SYSLIB&quot;)。</target>
        </trans-unit>
        <trans-unit id="325de08baac6d6bd1b4e1ebed585b6caa542bf6a" translate="yes" xml:space="preserve">
          <source>If desired, screen fields used as input fields may defined as &quot;secure&quot; fields, where each input character (regardless of what was actually typed) will appear as an asterisk (*) character. The actual character whose key was pressed will still be stored into the field in the program, however. This is very useful for password or account number fields.</source>
          <target state="translated">如果需要,用作输入字段的屏幕字段可以定义为 &quot;安全 &quot;字段,其中每个输入字符(无论实际输入了什么)将以星号(*)字符的形式出现。然而,被按下键的实际字符仍然会被存储到程序中的字段中。这对密码或帐号字段非常有用。</target>
        </trans-unit>
        <trans-unit id="e8c0e23858d8c34351be31b2e2dd7ef0f308a47c" translate="yes" xml:space="preserve">
          <source>If desired, you may reverse the roles of the&lt;code&gt;.&lt;/code&gt;and&lt;code&gt;,&lt;/code&gt;editing symbols by specifying&lt;code&gt;DECIMAL POINT IS COMMA&lt;/code&gt;in the&lt;code&gt;SPECIAL-NAMES&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) paragraph.</source>
          <target state="translated">如果需要，您可以反转的角色 &lt;code&gt;.&lt;/code&gt; 并且 &lt;code&gt;,&lt;/code&gt; 通过指定编辑符号 &lt;code&gt;DECIMAL POINT IS COMMA&lt;/code&gt; 在 &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; （参见&lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;）段。</target>
        </trans-unit>
        <trans-unit id="cfeb571780980c15ef5118f06fd533dfd406e005" translate="yes" xml:space="preserve">
          <source>If either condition has a value of TRUE, the result of&lt;code&gt;OR&lt;/code&gt;</source>
          <target state="translated">如果任一条件的值为TRUE，则 &lt;code&gt;OR&lt;/code&gt; 的结果</target>
        </trans-unit>
        <trans-unit id="bc1c6b979e9c37d992caa4fdb32b5bbe5b97b0db" translate="yes" xml:space="preserve">
          <source>If either the&lt;code&gt;TALLYING&lt;/code&gt;or&lt;code&gt;REPLACING&lt;/code&gt;clauses are specified, the&lt;code&gt;CONVERTING&lt;/code&gt;clause cannot be used.</source>
          <target state="translated">如果任一该 &lt;code&gt;TALLYING&lt;/code&gt; 或 &lt;code&gt;REPLACING&lt;/code&gt; 被指定条款， &lt;code&gt;CONVERTING&lt;/code&gt; 不能使用子句。</target>
        </trans-unit>
        <trans-unit id="65d896699ba7417f38fac49a744a6351011f2338" translate="yes" xml:space="preserve">
          <source>If event (A) occurs, &amp;lt;</source>
          <target state="translated">如果发生事件（A），&amp;lt;</target>
        </trans-unit>
        <trans-unit id="c6ea8276245b74726b44312b8cbb459b9ea45f59" translate="yes" xml:space="preserve">
          <source>If event (A) occurs, none of the destination field contents (or the contents of their&lt;code&gt;DELIMITER&lt;/code&gt;or &amp;lt;</source>
          <target state="translated">如果事件（A）发生，则目标字段内容（或其 &lt;code&gt;DELIMITER&lt;/code&gt; 或&amp;lt;</target>
        </trans-unit>
        <trans-unit id="c766138e5b6a0fb5e159fe3be6df3cb65c15aa94" translate="yes" xml:space="preserve">
          <source>If excess space is allocated, the returned value will be padded with spaces (to the right).</source>
          <target state="translated">如果分配了多余的空间,返回的值将用空格填充(向右)。</target>
        </trans-unit>
        <trans-unit id="dcf599fa35195bfeb7d750a1aa7ddb9854348d4d" translate="yes" xml:space="preserve">
          <source>If executed by a main program, neither the&lt;code&gt;EXIT PROGRAM&lt;/code&gt;nor&lt;code&gt;EXIT FUNCTION&lt;/code&gt;statements will take any action.</source>
          <target state="translated">如果由主程序执行，则 &lt;code&gt;EXIT PROGRAM&lt;/code&gt; 或 &lt;code&gt;EXIT FUNCTION&lt;/code&gt; 语句均不会采取任何措施。</target>
        </trans-unit>
        <trans-unit id="adc22a801c0d5cf9afd2251ba837acc24c7e7595" translate="yes" xml:space="preserve">
          <source>If executed within a main program,&lt;code&gt;GOBACK&lt;/code&gt;will act as a&lt;code&gt;STOP RUN&lt;/code&gt;statement.</source>
          <target state="translated">如果在主程序中执行，则 &lt;code&gt;GOBACK&lt;/code&gt; 将充当 &lt;code&gt;STOP RUN&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="0c913e686677f4f2542ed04551fc54a61ca3b586" translate="yes" xml:space="preserve">
          <source>If executed within a subprogram (i.e. a subroutine or user-defined function),&lt;code&gt;GOBACK&lt;/code&gt;behaves like an&lt;code&gt;EXIT PROGRAM&lt;/code&gt;or&lt;code&gt;EXIT FUNCTION&lt;/code&gt;statement, respectively.</source>
          <target state="translated">如果在子程序（即子例程或用户定义的函数）中执行，则 &lt;code&gt;GOBACK&lt;/code&gt; 的行为分别类似于 &lt;code&gt;EXIT PROGRAM&lt;/code&gt; 或 &lt;code&gt;EXIT FUNCTION&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="37a5ec4ba4f6eb14fb6bc4cdf6c2b834a2e18251" translate="yes" xml:space="preserve">
          <source>If insufficient space is allocated, the returned value will be truncated.</source>
          <target state="translated">如果分配的空间不足,返回的值将被截断。</target>
        </trans-unit>
        <trans-unit id="20788d6df5c521759ffd6da038d7efacbc53537c" translate="yes" xml:space="preserve">
          <source>If it begins with a capital &quot;C&quot;, the value will be centred</source>
          <target state="translated">如果是以大写的 &quot;C &quot;开头,则数值将居中。</target>
        </trans-unit>
        <trans-unit id="cce45705eb2edf3ee981ccb8a02325faa9873b7a" translate="yes" xml:space="preserve">
          <source>If it begins with a capital &quot;L&quot;, the value will be left-justified, space-filled to the right</source>
          <target state="translated">如果它以大写的 &quot;L &quot;开头,则该值将被左对齐,空格向右填充</target>
        </trans-unit>
        <trans-unit id="49095cec719464061ddd1eea1650a1e60b0b3522" translate="yes" xml:space="preserve">
          <source>If it begins with a capital &quot;R&quot;, the value will be right-justified, space-filled to the left</source>
          <target state="translated">如果它以大写的 &quot;R &quot;开头,则该值将被右对齐,并向左填充空间</target>
        </trans-unit>
        <trans-unit id="e6e9d41a84edd6ab6b611b8a64b21d8cc9efa7ef" translate="yes" xml:space="preserve">
          <source>If it begins with anything else, or is absent, it will be treated as if it is present and begins with a capital &quot;R&quot;</source>
          <target state="translated">如果它以任何其他事物开头,或不存在,将被视为存在,并以大写的 &quot;R &quot;开头。</target>
        </trans-unit>
        <trans-unit id="ddfddaec4eb6defafd4236c3804acb2833a56ffc" translate="yes" xml:space="preserve">
          <source>If it is a dynamic subroutine, the GnuCOBOL run-time system will check to see if a dynamically-loadable module containing the subprogram&amp;rsquo;s entry point was already located. If it was, no further &quot;location&quot; activity is needed. If not, the dynamically-loadable module will be located (see &lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;Locating Dynamically-Loadable Modules&lt;/a&gt;).</source>
          <target state="translated">如果它是动态子例程，则GnuCOBOL运行时系统将检查是否已找到包含子程序入口点的可动态加载模块。如果是这样，则不需要进一步的&amp;ldquo;定位&amp;rdquo;活动。否则，将&lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;找到可动态加载的模块&lt;/a&gt;（请参阅查找可动态加载的模块）。</target>
        </trans-unit>
        <trans-unit id="a084bcee5f6f297e9fac72fc57197692e67653da" translate="yes" xml:space="preserve">
          <source>If it is a dynamic user-defined function, the GnuCOBOL run-time system will check to see if a dynamically-loadable module containing the function&amp;rsquo;s entry point was already located. If it was, no further &quot;location&quot; activity is needed. If not, the dynamically-loadable module will be located (see &lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;Locating Dynamically-Loadable Modules&lt;/a&gt;).</source>
          <target state="translated">如果它是动态的用户定义函数，则GnuCOBOL运行时系统将检查是否已找到包含该函数入口点的可动态加载模块。如果是这样，则不需要进一步的&amp;ldquo;定位&amp;rdquo;活动。否则，将&lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;找到可动态加载的模块&lt;/a&gt;（请参阅查找可动态加载的模块）。</target>
        </trans-unit>
        <trans-unit id="d0f43ca29a675e226a37e6b6d8088cdbc37ebd39" translate="yes" xml:space="preserve">
          <source>If it is a static subroutine, it will already be part of the executable program issuing the&lt;code&gt;CALL&lt;/code&gt;(see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;).</source>
          <target state="translated">如果它是静态子例程，则它将成为发出 &lt;code&gt;CALL&lt;/code&gt; 的可执行程序的一部分（请参见&lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="caa175b4499a85fc8b3c0efe4a0f73f3d1c1c886" translate="yes" xml:space="preserve">
          <source>If it is a static user-defined function, it will already be part of the executable file containing the calling program.</source>
          <target state="translated">如果它是一个用户定义的静态函数,它将已经是包含调用程序的可执行文件的一部分。</target>
        </trans-unit>
        <trans-unit id="84a0f01c66da97418e3aa21d01e0ef5b3ae55060" translate="yes" xml:space="preserve">
          <source>If more than one section is needed in the data division (a common situation), the sections must be coded in the sequence they are presented above.</source>
          <target state="translated">如果在数据分割中需要一个以上的部分(一种常见的情况),则必须按上述顺序对各部分进行编码。</target>
        </trans-unit>
        <trans-unit id="08575c4d82cf8b371a6f7d53f268979ac88898e9" translate="yes" xml:space="preserve">
          <source>If necessary, &amp;lt;</source>
          <target state="translated">如有必要，&amp;lt;</target>
        </trans-unit>
        <trans-unit id="f63584104f0c3fb031bde71d0b6dcee112c103e0" translate="yes" xml:space="preserve">
          <source>If neither paragraph is coded, the&lt;code&gt;INPUT-OUTPUT SECTION.&lt;/code&gt;header itself may be omitted, otherwise it is normally required.</source>
          <target state="translated">如果两个段落均未编码，则 &lt;code&gt;INPUT-OUTPUT SECTION.&lt;/code&gt; 标头本身可以省略，否则通常是必需的。</target>
        </trans-unit>
        <trans-unit id="112a01f52ed19b32bc288508d6054c95da8fdd85" translate="yes" xml:space="preserve">
          <source>If no &amp;lt;</source>
          <target state="translated">如果没有&amp;lt;</target>
        </trans-unit>
        <trans-unit id="c520e3d4aae69229f5d030660491f8d24e39ce90" translate="yes" xml:space="preserve">
          <source>If no &amp;lt;&amp;lt;</source>
          <target state="translated">如果没有&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="cccae1dc6e8637e1b5c5c2fbf5052d3f0ccf07fa" translate="yes" xml:space="preserve">
          <source>If no &amp;rsquo;</source>
          <target state="translated">如果不 '</target>
        </trans-unit>
        <trans-unit id="80ec6de7e7c7e7960f42ef9bf764d5e364ff0ae6" translate="yes" xml:space="preserve">
          <source>If no data division sections are needed, the&lt;code&gt;DATA DIVISION.&lt;/code&gt;header itself may be omitted.</source>
          <target state="translated">如果不需要数据划分部分，则使用数据划分 &lt;code&gt;DATA DIVISION.&lt;/code&gt; 标头本身可以省略。</target>
        </trans-unit>
        <trans-unit id="e5c8083a19d4bf6b791a2ad3bee37fd9780d046a" translate="yes" xml:space="preserve">
          <source>If no data will be described in one of the data division sections, that section header may be omitted.</source>
          <target state="translated">如果某个数据分割部分不描述数据,则可省略该部分标题。</target>
        </trans-unit>
        <trans-unit id="4ea37cd62fe13ae475efaf0fa631e7d1254a22ce" translate="yes" xml:space="preserve">
          <source>If no environment variable was found, or the &quot;config&quot; file used to compile the program had a &quot;filename-mapping&quot; value of &quot;no&quot;, then the File Locator String value will serve as the path and filename to the data file.</source>
          <target state="translated">如果没有找到环境变量,或者用于编译程序的 &quot;config &quot;文件的 &quot;文件名映射 &quot;值为 &quot;no&quot;,那么文件定位符串值将作为数据文件的路径和文件名。</target>
        </trans-unit>
        <trans-unit id="97d63005403252ba6869749f325e5b668c7826c7" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;ADVANCING&lt;/code&gt;clause is specified on a&lt;code&gt;WRITE&lt;/code&gt;to a line-advancing file,&lt;code&gt;AFTER ADVANCING 1 LINE&lt;/code&gt;will be assumed; on other than line-advancing files,&lt;code&gt;BEFORE ADVANCING 1 LINE&lt;/code&gt;will be assumed.</source>
          <target state="translated">如果在 &lt;code&gt;WRITE&lt;/code&gt; 上未对行前进文件指定 &lt;code&gt;ADVANCING&lt;/code&gt; 子句，则将假定 &lt;code&gt;AFTER ADVANCING 1 LINE&lt;/code&gt; ；在行前进文件之外的其他文件上，将假定前进 &lt;code&gt;BEFORE ADVANCING 1 LINE&lt;/code&gt; 行之前。</target>
        </trans-unit>
        <trans-unit id="6c0dd54af0bcfe6aba553419a7f8fa41175966da" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;AFTER&lt;/code&gt;is specified, the first character position of the target range will be character position #1 of the inspect subject.</source>
          <target state="translated">如果未指定 &lt;code&gt;AFTER&lt;/code&gt; ，则目标范围的第一个字符位置将是检查对象的字符位置＃1。</target>
        </trans-unit>
        <trans-unit id="15393df0a9af6eb90b29b75caf239e68d67158ac" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;BEFORE&lt;/code&gt;is specified, the last character position of the target range will be the last character position of the inspect subject.</source>
          <target state="translated">如果未指定 &lt;code&gt;BEFORE&lt;/code&gt; ，则目标范围的最后一个字符位置将是检查对象的最后一个字符位置。</target>
        </trans-unit>
        <trans-unit id="1a0d2b27d4ce9b801ffdc741e7e7060c7a514405" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;COLLATING SEQUENCE&lt;/code&gt;clause is specified, the collating sequence implied by the character set native to the computer (usually ASCII) will be used.</source>
          <target state="translated">如果未指定 &lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; 子句，则将使用计算机本机字符集（通常为ASCII）所隐含的整理顺序。</target>
        </trans-unit>
        <trans-unit id="938ef54a5b2f3a79dc5e586019fcecd25b200f27" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;FIRST&lt;/code&gt;&lt;code&gt;LAST&lt;/code&gt;or&lt;code&gt;KEY&lt;/code&gt;clause is specified,&lt;code&gt;KEY IS EQUAL TO xxx&lt;/code&gt;will be assumed, where &quot;xxx&quot; is the defined&lt;code&gt;RELATIVE KEY&lt;/code&gt;of (if &amp;lt;</source>
          <target state="translated">如果未指定 &lt;code&gt;FIRST&lt;/code&gt; &lt;code&gt;LAST&lt;/code&gt; 或 &lt;code&gt;KEY&lt;/code&gt; 子句，则将假定 &lt;code&gt;KEY IS EQUAL TO xxx&lt;/code&gt; ，其中&amp;ldquo; xxx&amp;rdquo;是已定义的 &lt;code&gt;RELATIVE KEY&lt;/code&gt; （如果&amp;lt;</target>
        </trans-unit>
        <trans-unit id="3c134ddd26a13c987732536178ffc2d3596e0cc0" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;FROM&lt;/code&gt;clause is specified,&lt;code&gt;FROM CONSOLE&lt;/code&gt;is assumed.</source>
          <target state="translated">如果未指定 &lt;code&gt;FROM&lt;/code&gt; 子句，则假定 &lt;code&gt;FROM CONSOLE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a936605766c63b6943b34a949cbfd95d11891a47" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;PAGE LIMITS&lt;/code&gt;clause is specified, the entire report will be generated as if it consists of a single arbitrarily long page.</source>
          <target state="translated">如果未指定 &lt;code&gt;PAGE LIMITS&lt;/code&gt; 子句，则将生成整个报告，就好像它是由一个任意长的页面组成。</target>
        </trans-unit>
        <trans-unit id="8df6bcbeab6aa11894e4fe7cbd9a91d3d00317e5" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;UPON&lt;/code&gt;</source>
          <target state="translated">如果没有 &lt;code&gt;UPON&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe6ea8dfb325db99c6308c46b06bda141821bb43" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;VALUE&lt;/code&gt;</source>
          <target state="translated">如果没有 &lt;code&gt;VALUE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="acc316a6b22ed428d8859027514f370adf001d62" translate="yes" xml:space="preserve">
          <source>If none of the features provided by the configuration section are required by a program, the entire&lt;code&gt;CONFIGURATION SECTION.&lt;/code&gt;header may be omitted from the program.</source>
          <target state="translated">如果程序不需要配置部分提供的功能，则请整个 &lt;code&gt;CONFIGURATION SECTION.&lt;/code&gt; 标头可以从程序中省略。</target>
        </trans-unit>
        <trans-unit id="38302bf8e20435daf87449711673f45dc0fc7efa" translate="yes" xml:space="preserve">
          <source>If none of the paragraphs within one of the sections are coded, the section header itself may be omitted.</source>
          <target state="translated">如果其中一节中没有任何段落被编码,则可省略该节标题本身。</target>
        </trans-unit>
        <trans-unit id="c20690aa244c08791983cf1b27135cf3c295161b" translate="yes" xml:space="preserve">
          <source>If none of the sections within the data division are coded (a highly unlikely, but theoretically possible circumstance), the&lt;code&gt;DATA DIVISION.&lt;/code&gt;header itself may be omitted.</source>
          <target state="translated">如果数据分区内的任何部分均未编码（极不可能，但理论上可能的情况），则使用数据分区 &lt;code&gt;DATA DIVISION.&lt;/code&gt; 标头本身可以省略。</target>
        </trans-unit>
        <trans-unit id="0a6df96501f79aab798f69106ec9e2b97487e708" translate="yes" xml:space="preserve">
          <source>If none of the sections within the environment division are coded, the&lt;code&gt;ENVIRONMENT DIVISION.&lt;/code&gt;header itself may be omitted.</source>
          <target state="translated">如果环境部门内的任何部分均未编码，则 &lt;code&gt;ENVIRONMENT DIVISION.&lt;/code&gt; 标头本身可以省略。</target>
        </trans-unit>
        <trans-unit id="3f3504ace1fcbbfe8785eaf44906c2e8b0fac8ce" translate="yes" xml:space="preserve">
          <source>If references to table elements are going to be performed many, many times (tens or hundreds of thousands of times or more) during program execution, you will probably see a noticeable reduction in program execution time if you use indexing versus subscripting.</source>
          <target state="translated">如果在程序执行过程中对表元素的引用要执行很多很多次(几万次或几十万次以上),如果使用索引与下标,可能会看到程序执行时间明显减少。</target>
        </trans-unit>
        <trans-unit id="8e464aa3baae37e1c17db766f8597a99a293b6e4" translate="yes" xml:space="preserve">
          <source>If references to table elements are not going to be performed many, many times it probably won&amp;rsquo;t make much difference whether you use indexing or subscripting.</source>
          <target state="translated">如果对表元素的引用不会执行很多次，那么无论使用索引还是下标都可能不会有太大的不同。</target>
        </trans-unit>
        <trans-unit id="2d7b2b72b6ddc84fee15212248b1a81b23f1b096" translate="yes" xml:space="preserve">
          <source>If rule (A) is violated, the compiler will reject the&lt;code&gt;SEARCH ALL&lt;/code&gt; If rules (B) and/or (C) are violated, there will be no message issued by the compiler, but the run-time results of a&lt;code&gt;SEARCH ALL&lt;/code&gt;against the table will probably be incorrect.</source>
          <target state="translated">如果规则（A）被违反，则编译器将拒绝该 &lt;code&gt;SEARCH ALL&lt;/code&gt; 如果规则（B）和/或（C）受到侵害时，将没有由编译器发出的消息，而是一个的运行时的结果 &lt;code&gt;SEARCH ALL&lt;/code&gt; 针对该表可能不正确。</target>
        </trans-unit>
        <trans-unit id="953965bec96dd86973cb12584b0c3f4d8e27d9dc" translate="yes" xml:space="preserve">
          <source>If set to &quot;Y&quot;, &quot;y&quot; or &quot;1&quot;, a&lt;code&gt;CANCEL&lt;/code&gt;statement (see &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;) will physically unload a subprogram dynamically-loadable module.</source>
          <target state="translated">如果设置为&amp;ldquo; Y&amp;rdquo;，&amp;ldquo; y&amp;rdquo;或&amp;ldquo; 1&amp;rdquo;，则 &lt;code&gt;CANCEL&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;）将物理卸载可动态加载的子程序模块。</target>
        </trans-unit>
        <trans-unit id="e304fe2f130a29229fe3b203d139f3c8d0b1b8a9" translate="yes" xml:space="preserve">
          <source>If set to a value of &quot;Y&quot;, any run-time warnings (such as noting the implicit closing of open files when a&lt;code&gt;GOBACK&lt;/code&gt;statement (see &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;) or&lt;code&gt;STOP&lt;/code&gt;statement (see &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;) with the&lt;code&gt;RUN&lt;/code&gt;option is executed) will be displayed. Any other value for this environment variable (including not setting the variable at all) will suppress such messages.</source>
          <target state="translated">如果将值设置为&amp;ldquo; Y&amp;rdquo;，则将显示任何运行时警告（例如，在执行带有 &lt;code&gt;RUN&lt;/code&gt; 选项的 &lt;code&gt;GOBACK&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;）或 &lt;code&gt;STOP&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;）时注意隐式关闭打开的文件） 。此环境变量的任何其他值（包括根本不设置变量）将禁止显示此类消息。</target>
        </trans-unit>
        <trans-unit id="2bc077c4c98b87e839493508304c45c1d8484f6d" translate="yes" xml:space="preserve">
          <source>If set to a value of upper- or lower-case &quot;p&quot;, this variable will force a file commit every time a file is written to (ensuring that data is immediately written to the file rather than retained in memory until a future commit occurs). This will slow-down update access to files, but will provide for better integrity in the event of a program failure.</source>
          <target state="translated">如果设置为大写或小写的 &quot;p &quot;值,这个变量将在每次写入文件时强制进行文件提交(确保数据立即写入文件,而不是保留在内存中,直到未来发生提交)。这将减慢对文件的更新访问速度,但在程序失败时将提供更好的完整性。</target>
        </trans-unit>
        <trans-unit id="1ff6dd80412acb65fea091eeee45227f17f79745" translate="yes" xml:space="preserve">
          <source>If set to any non-blank value, this variable allows a&lt;code&gt;ACCEPT screen-data-item&lt;/code&gt;statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;) to detect the &quot;Esc&quot; key.</source>
          <target state="translated">如果设置为任何非空白值，则此变量允许 &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;）检测&amp;ldquo; Esc&amp;rdquo;键。</target>
        </trans-unit>
        <trans-unit id="02c873d8dea11df102afae708aa8d02b69151e6b" translate="yes" xml:space="preserve">
          <source>If set to any non-null value, this environment variable specifies the file to which all&lt;code&gt;-ftrace&lt;/code&gt;switch and&lt;code&gt;-ftraceall&lt;/code&gt;switch output will be written.</source>
          <target state="translated">如果设置为任何非null值，则此环境变量指定将所有 &lt;code&gt;-ftrace&lt;/code&gt; 开关和 &lt;code&gt;-ftraceall&lt;/code&gt; 开关输出写入的文件。</target>
        </trans-unit>
        <trans-unit id="422d3cddd2d7b811c88085d18de9df66cdccb313" translate="yes" xml:space="preserve">
          <source>If set to any non-null value, this variable will cause all dynamically-loadable libraries to be loaded when the program begins execution (rather than searching for and loading the module upon first use).</source>
          <target state="translated">如果设置为任何非空值,这个变量将导致所有可动态加载的库在程序开始执行时被加载(而不是在第一次使用时搜索和加载模块)。</target>
        </trans-unit>
        <trans-unit id="d8aab5d7cf6334fa7d1d64a36e03690790d2311f" translate="yes" xml:space="preserve">
          <source>If set to anything else, a&lt;code&gt;CANCEL&lt;/code&gt;statement (see &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;) logically unloads a module so that subsequent use will re-initialize the module as if it had actually been reloaded, but the overhead of actually reloading the module will be avoided.</source>
          <target state="translated">如果设置为其他任何值，则 &lt;code&gt;CANCEL&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;）从逻辑上卸载模块，以便后续使用将重新初始化该模块，就好像它实际上已经被重新加载一样，但是可以避免实际重新加载模块的开销。</target>
        </trans-unit>
        <trans-unit id="ffb03e9553a2471b244e5697186cb21ecae1836a" translate="yes" xml:space="preserve">
          <source>If set to either&lt;code&gt;UPPER&lt;/code&gt;or&lt;code&gt;LOWER&lt;/code&gt; this environment variable will internally convert referenced entry-point names to either upper- or lower-case before initiating searches for dynamically-loadable modules. The&lt;code&gt;UPPER&lt;/code&gt;and&lt;code&gt;LOWER&lt;/code&gt;values of the environment variable are actually case-insensitive.</source>
          <target state="translated">如果设置为 &lt;code&gt;UPPER&lt;/code&gt; 或 &lt;code&gt;LOWER&lt;/code&gt; ,则此环境变量将在开始搜索可动态加载的模块之前在内部将引用的入口点名称转换为大写或小写。环境变量的 &lt;code&gt;UPPER&lt;/code&gt; 和 &lt;code&gt;LOWER&lt;/code&gt; 值实际上不区分大小写。</target>
        </trans-unit>
        <trans-unit id="75ff3ad897d4389bd5d4346a9d0cead6b649265f" translate="yes" xml:space="preserve">
          <source>If specified, &amp;lt;</source>
          <target state="translated">如果指定，&amp;lt;</target>
        </trans-unit>
        <trans-unit id="fc641baf619f0e3d0d10496e69f3b55fd6e604c8" translate="yes" xml:space="preserve">
          <source>If the &amp;lt;</source>
          <target state="translated">如果&amp;lt;</target>
        </trans-unit>
        <trans-unit id="80f8927587ac8a416163b826212188d6cd97481c" translate="yes" xml:space="preserve">
          <source>If the DISPLAY verb is executing, then the size is the same as if the CONVERT phrase were not specified except for numeric items. For numeric items, the size is the number of digits in the item, plus one if it is not an integer, plus one if it is signed. The remaining cases cover the size when an ACCEPT statement is used.</source>
          <target state="translated">如果DISPLAY动词正在执行,那么大小与未指定CONVERT短语的情况相同,但数字项目除外。对于数字项,大小是项中的数字数,如果不是整数,则加1,如果是有符号的,则加1。其余情况包括使用ACCEPT语句时的大小。</target>
        </trans-unit>
        <trans-unit id="fd1fa5d5fdcea9b7c73d25c9d04a3be93ca9dd38" translate="yes" xml:space="preserve">
          <source>If the GnuCOBOL build you are using was configured to use the Berkeley Database (BDB) package for indexed file I/O, record locking will be available by using the</source>
          <target state="translated">如果你所使用的GnuCOBOL构建被配置为使用Berkeley数据库(BDB)包来进行索引文件I/O,那么记录锁定将可以通过使用</target>
        </trans-unit>
        <trans-unit id="aa11e579492cde59f0f2b4460dae0515f472c0c0" translate="yes" xml:space="preserve">
          <source>If the GnuCOBOL compiler you are using was built to utilize a native Windows environment, use a semicolon (;) as the delimiter character.</source>
          <target state="translated">如果你使用的GnuCOBOL编译器是为了利用本地Windows环境而建立的,请使用分号(;)作为分隔符。</target>
        </trans-unit>
        <trans-unit id="e8e174d71b0a53ce0abb721ccafcd0e36830ee7a" translate="yes" xml:space="preserve">
          <source>If the LINAGE clause is</source>
          <target state="translated">如果LINAGE子句是</target>
        </trans-unit>
        <trans-unit id="876792b175fdff61a6c190841827c8f95e62bf94" translate="yes" xml:space="preserve">
          <source>If the SIZE phrase is not used, then the field length defaults to the size of the item being accepted or displayed. If the CONVERT phrase is used, however, then the size of the field depends on the data type of the item and the verb being used.</source>
          <target state="translated">如果不使用SIZE短语,那么字段长度默认为被接受或显示的项目的大小。但是,如果使用convert短语,那么字段的大小取决于项目的数据类型和使用的动词。</target>
        </trans-unit>
        <trans-unit id="a1a846b486d6a849fb5aee6dc27f07a8ed92c919" translate="yes" xml:space="preserve">
          <source>If the attempt to copy the file fails (for example, it or the destination directory doesn&amp;rsquo;t exist), the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to 128; on successful completion it will be set to 0.</source>
          <target state="translated">如果尝试复制文件失败（例如，文件失败或目标目录不存在），则 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器（请参见&lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;）将设置为128；成功完成后，它将设置为0。</target>
        </trans-unit>
        <trans-unit id="da68db930b7285a3ca3007bae8464343ac79a0ea" translate="yes" xml:space="preserve">
          <source>If the attempt to delete the file fails (for example, it doesn&amp;rsquo;t exist), the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to 128; on successful completion it will be set to 0.</source>
          <target state="translated">如果尝试删除文件失败（例如，该文件不存在），则 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器（请参见&lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;）将设置为128；成功完成后，它将设置为0。</target>
        </trans-unit>
        <trans-unit id="6d499ade6d8bd513045d21fd97b496bc7d59e814" translate="yes" xml:space="preserve">
          <source>If the attempt to move the file fails (for example, it doesn&amp;rsquo;t exist), the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to 128; on successful completion it will be set to 0.</source>
          <target state="translated">如果尝试移动文件失败（例如，该文件不存在），则 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器（请参见&lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;）将设置为128；成功完成后，它将设置为0。</target>
        </trans-unit>
        <trans-unit id="9cc49a6a7bfb3aab04847a284111d2050a7803d8" translate="yes" xml:space="preserve">
          <source>If the binary item occupies four bytes of storage, the binary item is allocated at the next word boundary.</source>
          <target state="translated">如果二进制项占用4个字节的存储空间,则在下一个字边界分配二进制项。</target>
        </trans-unit>
        <trans-unit id="c9eb3b2ff78316af9e06d9ecdca03186e9054272" translate="yes" xml:space="preserve">
          <source>If the binary item occupies one byte of storage, no synchronization is performed.</source>
          <target state="translated">如果二进制项占用一个字节的存储空间,则不进行同步。</target>
        </trans-unit>
        <trans-unit id="29ee50f202c57db2b363fa927e6f5d81d5d2accb" translate="yes" xml:space="preserve">
          <source>If the binary item occupies two bytes of storage, the binary item is allocated at the next half-word boundary.</source>
          <target state="translated">如果二进制项占用两个字节的存储空间,则在下一个半字边界分配二进制项。</target>
        </trans-unit>
        <trans-unit id="78d1c026459ef474eb28e2011cf978cfda3d3820" translate="yes" xml:space="preserve">
          <source>If the calling program included a&lt;code&gt;RETURNING&lt;/code&gt;clause on the&lt;code&gt;CALL&lt;/code&gt;statement that invoked the subprogram, the value of the&lt;code&gt;RETURNING&lt;/code&gt;data item in the subroutine is moved to that data item. If there was no&lt;code&gt;RETURNING&lt;/code&gt;specified in the subroutine, the value of the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register is moved to that data item.</source>
          <target state="translated">如果调用程序在调用子程序的 &lt;code&gt;CALL&lt;/code&gt; 语句中包含 &lt;code&gt;RETURNING&lt;/code&gt; 子句，则子例程中 &lt;code&gt;RETURNING&lt;/code&gt; 数据项的值将移至该数据项。如果在子例程中未指定 &lt;code&gt;RETURNING&lt;/code&gt; ，则将 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器的值移至该数据项。</target>
        </trans-unit>
        <trans-unit id="237f820b1887571d0c11ce781473f803467fad98" translate="yes" xml:space="preserve">
          <source>If the compiler &quot;config&quot; file (see &lt;a href=&quot;#Compiler-Configuration-Files&quot;&gt;Compiler Configuration Files&lt;/a&gt;) you used to compile the program specified &quot;mf&quot; as the &quot;assign-clause&quot; value, then the File Locator String will be interpreted according to Microfocus COBOL rules &amp;mdash; namely, everything before the last &quot;-&quot; in the File Locator String will be ignored; the characters after the last &quot;-&quot; will be treated as the base of an environment variable name. If there is no &quot;-&quot; character in the File Locator String then the entire File Locator String will serve as the base of an environment variable name. This is the default behaviour for every config file except &quot;ibm&quot;.</source>
          <target state="translated">如果您用来编译程序的编译器&amp;ldquo; config&amp;rdquo;文件（请参阅&lt;a href=&quot;#Compiler-Configuration-Files&quot;&gt;编译器配置文件&lt;/a&gt;）指定为&amp;ldquo; asf-clause&amp;rdquo;值，则文件定位符字符串将根据Microfocus COBOL规则进行解释，即之前的所有内容。文件定位符字符串中的最后一个&amp;ldquo;-&amp;rdquo;将被忽略；最后一个&amp;ldquo;-&amp;rdquo;之后的字符将被视为环境变量名称的基础。如果文件定位符字符串中没有&amp;ldquo;-&amp;rdquo;字符，则整个文件定位符字符串将用作环境变量名称的基础。这是除&amp;ldquo; ibm&amp;rdquo;以外的每个配置文件的缺省行为。</target>
        </trans-unit>
        <trans-unit id="be7c428b2bd6fcf64ba18d7fc20a33ae78ee6418" translate="yes" xml:space="preserve">
          <source>If the compiler &quot;config&quot; file you are using has &quot;relaxed-syntax-check&quot; set to &quot;yes&quot;, the&lt;code&gt;FILE-CONTROL&lt;/code&gt;and&lt;code&gt;I-O-CONTROL&lt;/code&gt;paragraphs may be specified without the&lt;code&gt;INPUT-OUTPUT SECTION.&lt;/code&gt;header having been coded.</source>
          <target state="translated">如果您正在使用的编译器&amp;ldquo; config&amp;rdquo;文件的&amp;ldquo; relaxed-syntax-check&amp;rdquo;设置为&amp;ldquo; yes&amp;rdquo;，则可以指定 &lt;code&gt;FILE-CONTROL&lt;/code&gt; 和 &lt;code&gt;I-O-CONTROL&lt;/code&gt; 段落，而无需 &lt;code&gt;INPUT-OUTPUT SECTION.&lt;/code&gt; 标头已编码。</target>
        </trans-unit>
        <trans-unit id="fe92b0755173ad538d05379125cea0810a360175" translate="yes" xml:space="preserve">
          <source>If the compiler &quot;config&quot; file you used to compile the program with had a &quot;filename-mapping&quot; value of &quot;yes&quot;, the GnuCOBOL runtime system will first attempt to identify a currently-defined environment variable whose value will serve as the data file&amp;rsquo;s path and filename, as follows:</source>
          <target state="translated">如果您用来编译程序的编译器&amp;ldquo; config&amp;rdquo;文件的&amp;ldquo;文件名映射&amp;rdquo;值为&amp;ldquo; yes&amp;rdquo;，则GnuCOBOL运行时系统将首先尝试识别当前定义的环境变量，该变量将用作数据文件的路径和文件名，如下所示：</target>
        </trans-unit>
        <trans-unit id="ada8d4fd5949881c69e3976ea553cf9ce6a69ad2" translate="yes" xml:space="preserve">
          <source>If the compiler is already in the specified mode, this statement will have no effect.</source>
          <target state="translated">如果编译器已经在指定的模式下,这条语句将没有任何效果。</target>
        </trans-unit>
        <trans-unit id="e079882ba26c2f94b1fe1a9df7387534f553e034" translate="yes" xml:space="preserve">
          <source>If the condition associated with a variable is false, the variable is not defined during compilations.</source>
          <target state="translated">如果与变量相关联的条件为false,则在编译过程中不定义变量。</target>
        </trans-unit>
        <trans-unit id="3a326fe6a76a0eaf9c6262d498515fe5ffc5ef03" translate="yes" xml:space="preserve">
          <source>If the condition-name has a value of TRUE, the group will be presented.</source>
          <target state="translated">如果条件名称的值为 &quot;TRUE&quot;,则该组将被呈现。</target>
        </trans-unit>
        <trans-unit id="8c023cec5138da702e62deee764a0698dddd5f75" translate="yes" xml:space="preserve">
          <source>If the counter has a value greater than zero, the statement(s) within the&lt;code&gt;PERFORM&lt;/code&gt;scope will be executed, after which the counter will be decremented by 1 with each repetition. Once that counter reaches zero, repetition will cease and control will fall into the next statement following the&lt;code&gt;PERFORM&lt;/code&gt;</source>
          <target state="translated">如果计数器的值大于零，则将执行 &lt;code&gt;PERFORM&lt;/code&gt; 范围内的语句，此后每次重复计数器将减1。一旦该计数器达到零，重复将停止并且控制权将落入 &lt;code&gt;PERFORM&lt;/code&gt; 之后的下一条语句中</target>
        </trans-unit>
        <trans-unit id="139a2f116480a978d8a516ae3f69011cef95b11e" translate="yes" xml:space="preserve">
          <source>If the data item in which the&lt;code&gt;SUM&lt;/code&gt;clause appears has been assigned it&amp;rsquo;s own identifier name, and that name is not&lt;code&gt;FILLER&lt;/code&gt; then that data item is referred to as a sum counter.</source>
          <target state="translated">如果已为出现 &lt;code&gt;SUM&lt;/code&gt; 子句的数据项分配了自己的标识符名称，并且该名称不是 &lt;code&gt;FILLER&lt;/code&gt; ,则该数据项称为总和计数器。</target>
        </trans-unit>
        <trans-unit id="d6641aac6877a23c3a650b80aa0141134bfbab68" translate="yes" xml:space="preserve">
          <source>If the date is valid, a 0 value is returned. If it isn&amp;rsquo;t, a value of 1 or 2 is returned signalling the problem lies with the year or day, respectively.</source>
          <target state="translated">如果日期有效，则返回0值。如果不是，则返回值1或2，分别表示问题出在年或日。</target>
        </trans-unit>
        <trans-unit id="7b011773af10dd8c1b119874aa6b6d6a7bdffaf9" translate="yes" xml:space="preserve">
          <source>If the file defined by the &amp;lt;</source>
          <target state="translated">如果文件由&amp;lt;</target>
        </trans-unit>
        <trans-unit id="8308b61ce7bcbfc94d926cc1722564983504a579" translate="yes" xml:space="preserve">
          <source>If the file has&lt;code&gt;ACCESS MODE SEQUENTIAL&lt;/code&gt; the record to be rewritten will be the one retrieved by the most-recently executed&lt;code&gt;READ&lt;/code&gt;of the file. If the file has&lt;code&gt;ACCESS MODE RANDOM&lt;/code&gt;or&lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt; no&lt;code&gt;READ&lt;/code&gt;is required before a record may be rewritten &amp;mdash; the&lt;code&gt;RELATIVE KEY&lt;/code&gt;or&lt;code&gt;RECORD KEY&lt;/code&gt;definition for the file, respectively, will specify the record to be updated.</source>
          <target state="translated">如果文件具有 &lt;code&gt;ACCESS MODE SEQUENTIAL&lt;/code&gt; ，则要重写的记录将是最近执行的文件 &lt;code&gt;READ&lt;/code&gt; 检索的记录。如果文件具有 &lt;code&gt;ACCESS MODE RANDOM&lt;/code&gt; 或 &lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt; ,则在可以重写记录之前不需要 &lt;code&gt;READ&lt;/code&gt; -文件的 &lt;code&gt;RELATIVE KEY&lt;/code&gt; 或 &lt;code&gt;RECORD KEY&lt;/code&gt; 定义将分别指定要更新的记录。</target>
        </trans-unit>
        <trans-unit id="979f0a1fc8e50fd115ef1c5a2607d25c8a146e66" translate="yes" xml:space="preserve">
          <source>If the file has&lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;) or&lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;):</source>
          <target state="translated">如果文件具有 &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; （请参见&lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;）或 &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; （请参见&lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="a1d7d6e295ed262b048e40c65c57cc69c1a22916" translate="yes" xml:space="preserve">
          <source>If the file has&lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;):</source>
          <target state="translated">如果文件具有 &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; （请参见&lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="e57bb4b94ad8d138b6e068547fa0dd3393b0fc4d" translate="yes" xml:space="preserve">
          <source>If the file&amp;rsquo;s&lt;code&gt;SELECT&lt;/code&gt;contains a&lt;code&gt;LOCK MODE IS AUTOMATIC&lt;/code&gt;</source>
          <target state="translated">如果文件的 &lt;code&gt;SELECT&lt;/code&gt; 包含 &lt;code&gt;LOCK MODE IS AUTOMATIC&lt;/code&gt; 的LOCK MODE</target>
        </trans-unit>
        <trans-unit id="b0edb822a1ecdc41221997c63041ba9a3c222689" translate="yes" xml:space="preserve">
          <source>If the file&amp;rsquo;s&lt;code&gt;SELECT&lt;/code&gt;contains a&lt;code&gt;LOCK MODE IS MANUAL&lt;/code&gt;</source>
          <target state="translated">如果文件的&amp;ldquo; &lt;code&gt;SELECT&lt;/code&gt; &amp;rdquo;包含&amp;ldquo; &lt;code&gt;LOCK MODE IS MANUAL&lt;/code&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="9ac3ef7c53e5a1a9ebd82e6132c731fb366bb269" translate="yes" xml:space="preserve">
          <source>If the function issues a&lt;code&gt;STOP&lt;/code&gt;statement (see &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;) with the&lt;code&gt;RUN&lt;/code&gt;option, program execution ceases and control returns to the operating system or whatever execution shell invoked the main program.</source>
          <target state="translated">如果该函数使用 &lt;code&gt;RUN&lt;/code&gt; 选项发出 &lt;code&gt;STOP&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;），则程序将停止执行，控制权将返回到操作系统或调用主程序的任何执行外壳。</target>
        </trans-unit>
        <trans-unit id="768fc6ac0826962232769e54ee3d27933dbe814a" translate="yes" xml:space="preserve">
          <source>If the function wishes to return control back to the calling program, it will do so using either the&lt;code&gt;GOBACK&lt;/code&gt;statement (see &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;) or the&lt;code&gt;EXIT FUNCTION&lt;/code&gt;statement (see &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;). At this time:</source>
          <target state="translated">如果函数希望将控制权返回给调用程序，它将使用 &lt;code&gt;GOBACK&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;）或 &lt;code&gt;EXIT FUNCTION&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;）来完成。此时：</target>
        </trans-unit>
        <trans-unit id="30455ee292f12916879ea7b27b16596593857296" translate="yes" xml:space="preserve">
          <source>If the item is alphanumeric edited, then the size is set to the number of &quot;A&quot; or &quot;X&quot; positions specified in its PICTURE clause.</source>
          <target state="translated">如果项目是字母数字编辑,则大小设置为其PICTURE子句中指定的 &quot;A &quot;或 &quot;X &quot;位置数。</target>
        </trans-unit>
        <trans-unit id="5a3ac59ecad83c4e62bbb64e4efcc1980153a8fd" translate="yes" xml:space="preserve">
          <source>If the item is numeric or numeric edited, then the size is the number of digits in the item, plus one if it is not an integer, plus one if it is signed.</source>
          <target state="translated">如果项目是数字或数字编辑,则大小为项目中的数字数,如果不是整数则加1,如果是符号则加1。</target>
        </trans-unit>
        <trans-unit id="0bf6190961c1d912062042b050c89a336fba6e4f" translate="yes" xml:space="preserve">
          <source>If the key(s) and value(s) match, &amp;lt;</source>
          <target state="translated">如果键和值匹配，则&amp;lt;</target>
        </trans-unit>
        <trans-unit id="8718b549db26737624f77d41114ec5bbc3bc5cfc" translate="yes" xml:space="preserve">
          <source>If the key(s) are GREATER THAN the value(s), then the table entry being searched for can only occur in the &quot;first&quot; to &quot;current&quot; range of the table, so a new &quot;last&quot; pointer value is set (it will be set to the &quot;current&quot; pointer).</source>
          <target state="translated">如果key(s)大于value(s),那么被搜索的表条目只能出现在表的 &quot;first &quot;到 &quot;current &quot;范围内,所以设置一个新的 &quot;last &quot;指针值(它将被设置为 &quot;current &quot;指针)。</target>
        </trans-unit>
        <trans-unit id="f855f7c7ead100cd07565ea01cc7a9230a155db1" translate="yes" xml:space="preserve">
          <source>If the key(s) are LESS THAN the value(s), then the table entry being searched for can only occur in the &quot;current&quot; to &quot;last&quot; range of the table, so a new &quot;first&quot; pointer value is set (it will be set to the &quot;current&quot; pointer).</source>
          <target state="translated">如果key(s)小于value(s),那么被搜索的表条目只能出现在表的 &quot;current &quot;到 &quot;last &quot;范围内,所以设置一个新的 &quot;first &quot;指针值(它将被设置为 &quot;current &quot;指针)。</target>
        </trans-unit>
        <trans-unit id="75791070ef3413617c60c665e733867b07b700c6" translate="yes" xml:space="preserve">
          <source>If the length of &amp;lt;</source>
          <target state="translated">如果长度&amp;lt;</target>
        </trans-unit>
        <trans-unit id="f678ec7b4d2b5c8286ebadce4169b6ec51506464" translate="yes" xml:space="preserve">
          <source>If the length of the &quot;from&quot; string</source>
          <target state="translated">如果 &quot;from &quot;字符串的长度</target>
        </trans-unit>
        <trans-unit id="163af06aed58d0ce62be6ce917a711c8bc398a55" translate="yes" xml:space="preserve">
          <source>If the new &quot;first&quot; and &quot;last&quot; pointers are different than the old &quot;first&quot; and &quot;last&quot; pointers, there&amp;rsquo;s more left to be searched, so return to step (A) and continue.</source>
          <target state="translated">如果新的&amp;ldquo;第一个&amp;rdquo;和&amp;ldquo;最后一个&amp;rdquo;指针与旧的&amp;ldquo;第一个&amp;rdquo;和&amp;ldquo;最后一个&amp;rdquo;指针不同，则还有更多要搜索的指针，因此返回步骤（A）并继续。</target>
        </trans-unit>
        <trans-unit id="20cd460d91c2dd82c32020553b0991e55b5ca84b" translate="yes" xml:space="preserve">
          <source>If the new &quot;first&quot; and &quot;last&quot; pointers are the same as the old &quot;first&quot; and &quot;last&quot; pointers, the table has been exhausted and the entry being searched for cannot be found; &amp;lt;</source>
          <target state="translated">如果新的&amp;ldquo;第一个&amp;rdquo;和&amp;ldquo;最后一个&amp;rdquo;指针与旧的&amp;ldquo;第一个&amp;rdquo;和&amp;ldquo;最后一个&amp;rdquo;指针相同，则表已用尽，无法找到要搜索的条目；&amp;lt;</target>
        </trans-unit>
        <trans-unit id="99b9a44588304e8fd897153b6442bc44498ed178" translate="yes" xml:space="preserve">
          <source>If the optional&lt;code&gt;ALL&lt;/code&gt;</source>
          <target state="translated">如果可选 &lt;code&gt;ALL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7bdbfa412dd855282c99935345311e80faa35ff" translate="yes" xml:space="preserve">
          <source>If the optional&lt;code&gt;ELSE&lt;/code&gt;clause is present and conditional-expression evaluates to false, then (and only then) &amp;lt;</source>
          <target state="translated">如果存在可选的 &lt;code&gt;ELSE&lt;/code&gt; 子句，并且条件表达式的计算结果为false，则（并且仅此）&amp;lt;</target>
        </trans-unit>
        <trans-unit id="214f8446472e76c131789cea52e9df99ff6d7324" translate="yes" xml:space="preserve">
          <source>If the optional&lt;code&gt;WITH FILLER&lt;/code&gt;</source>
          <target state="translated">如果可选的 &lt;code&gt;WITH FILLER&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e0c98a1a847d99310eeb35f540d53fc5e523af7" translate="yes" xml:space="preserve">
          <source>If the program is compiled with the&lt;code&gt;-fsyntax-extension&lt;/code&gt;switch</source>
          <target state="translated">如果程序是使用 &lt;code&gt;-fsyntax-extension&lt;/code&gt; 开关编译的</target>
        </trans-unit>
        <trans-unit id="3f250bad0b5b4ae9aea9503229c333bf1801f01f" translate="yes" xml:space="preserve">
          <source>If the replacement string is a multiple-item phrase or is to be deleted altogether, you must use the&lt;code&gt;==&amp;lt;&lt;i&gt;pseudo-text-2&lt;/i&gt;&amp;gt;==&lt;/code&gt;option. If&lt;code&gt;&amp;lt;&lt;i&gt;pseudo-text-2&lt;/i&gt;&amp;gt;&lt;/code&gt;is null (in other words, the replacement text is specified as&lt;code&gt;====&lt;/code&gt;, all encountered occurrences of the search string will be deleted.</source>
          <target state="translated">如果替换字符串是一个多项目短语或将要完全删除，则必须使用 &lt;code&gt;==&amp;lt;&lt;i&gt;pseudo-text-2&lt;/i&gt;&amp;gt;==&lt;/code&gt; 选项。如果 &lt;code&gt;&amp;lt;&lt;i&gt;pseudo-text-2&lt;/i&gt;&amp;gt;&lt;/code&gt; 为空（换言之，将替换文本指定为 &lt;code&gt;====&lt;/code&gt; ，则将删除所有遇到的搜索字符串。</target>
        </trans-unit>
        <trans-unit id="b864101b1cf94817be38b70b043aacccfa75cd6e" translate="yes" xml:space="preserve">
          <source>If the routine is successful, a value of 0 will be returned to the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;). If the routine failed because of a problem with an argument (such as a negative or 0 length), a value of 128 will result. Finally, if the 1st argument value is anything but zero, the routine will fail with a 129 value.</source>
          <target state="translated">如果例程成功，则将值0返回到 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器（请参见&lt;a href=&quot;#Special-Registers&quot;&gt;特殊寄存器&lt;/a&gt;）。如果例程由于参数问题（例如负数或0长度）而失败，则结果为128。最后，如果第一个参数值不为零，则例程将失败并返回129值。</target>
        </trans-unit>
        <trans-unit id="5a1b44b26b84f05f8af22b9e038aef3fc238f233" translate="yes" xml:space="preserve">
          <source>If the search index now has a value greater than the number of entries in the table, the search is considered to have failed and the &amp;lt;</source>
          <target state="translated">如果现在搜索索引的值大于表中的条目数，则认为搜索失败，并且&amp;lt;</target>
        </trans-unit>
        <trans-unit id="94565d23be2bb0fc7d85c959aef69eff52cd9069" translate="yes" xml:space="preserve">
          <source>If the search index now has a value less than or equal to the number of entries in the table, search processing returns back to step (A).</source>
          <target state="translated">如果现在搜索索引的值小于或等于表中的条目数,则搜索处理返回到步骤(A)。</target>
        </trans-unit>
        <trans-unit id="63b646dd35f2ad5b466ac70be0367ce3e11e5b92" translate="yes" xml:space="preserve">
          <source>If the specified argument does not exist, or an invalid argument number is specified, a value of 0 is returned.</source>
          <target state="translated">如果指定的参数不存在,或者指定了无效的参数号,则返回0值。</target>
        </trans-unit>
        <trans-unit id="a1c8f712007564d99604775da06766bbac9f03bb" translate="yes" xml:space="preserve">
          <source>If the specified condition-name has a value of FALSE when a&lt;code&gt;GENERATE&lt;/code&gt;statement (see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) causes a report group to be presented, the presentation of that group will be suppressed.</source>
          <target state="translated">如果当 &lt;code&gt;GENERATE&lt;/code&gt; 语句（请参见&lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;）使要显示的报告组时指定的条件名称的值为FALSE ，则该组的显示将被禁止。</target>
        </trans-unit>
        <trans-unit id="66774ceedbe10981e42302c55639170b0ed0f28a" translate="yes" xml:space="preserve">
          <source>If the structure contains the following grid of characters:</source>
          <target state="translated">如果该结构包含以下字符网格:</target>
        </trans-unit>
        <trans-unit id="5be0ca5096c1af0f623320b98f1b64f052b51144" translate="yes" xml:space="preserve">
          <source>If the subprogram being called is a GnuCOBOL program, and if that program had the&lt;code&gt;INITIAL&lt;/code&gt;(see &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt;) attribute specified on its&lt;code&gt;PROGRAM-ID&lt;/code&gt;clause, all of the subprogram&amp;rsquo;s data division data will be restored to its initial state each time the subprogram is executed, regardless of which entry-point within the subprogram is being referenced.</source>
          <target state="translated">如果被调用的子程序是GnuCOBOL程序，并且该程序具有在其 &lt;code&gt;PROGRAM-ID&lt;/code&gt; 子句中指定的 &lt;code&gt;INITIAL&lt;/code&gt; （请参阅&lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt;）属性，则每次子程序被执行时，所有子程序的数据划分数据都将恢复为其初始状态。无论引用了子程序中的哪个入口点，都将执行。</target>
        </trans-unit>
        <trans-unit id="1ad68b7c421e5be7cfd3f061b145123e5b308674" translate="yes" xml:space="preserve">
          <source>If the subprogram issues a&lt;code&gt;STOP&lt;/code&gt;statement (see &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;) with the&lt;code&gt;RUN&lt;/code&gt;option, program execution ceases and control returns to the operating system or whatever execution shell invoked the main program.</source>
          <target state="translated">如果子程序发出带有 &lt;code&gt;RUN&lt;/code&gt; 选项的 &lt;code&gt;STOP&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;），则程序将停止执行，并且控制权返回到操作系统或调用主程序的任何执行外壳程序。</target>
        </trans-unit>
        <trans-unit id="3fddc95876d626c2ec7bbbe309cf154f2991a624" translate="yes" xml:space="preserve">
          <source>If the subprogram returns a value, the data item in which the value is returned must also be defined in the subprogram&amp;rsquo;s linkage section, with a&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of&lt;code&gt;BINARY-LONG SIGNED&lt;/code&gt; or it&amp;rsquo;s equivalent.</source>
          <target state="translated">如果子程序返回一个值，则还必须在子程序的链接部分中定义返回值的数据项，其 &lt;code&gt;USAGE&lt;/code&gt; （请参阅&lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;）为 &lt;code&gt;BINARY-LONG SIGNED&lt;/code&gt; 或等效。</target>
        </trans-unit>
        <trans-unit id="3977b529e0e7ac10b11afc507f2c9eb5bfc68f03" translate="yes" xml:space="preserve">
          <source>If the subprogram wishes to return control back to the calling program, it will do so using either the&lt;code&gt;GOBACK&lt;/code&gt;statement (see &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;) or the&lt;code&gt;EXIT PROGRAM&lt;/code&gt;statement (see &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;). At this time:</source>
          <target state="translated">如果子程序希望将控制权返回给调用程序，它将使用 &lt;code&gt;GOBACK&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;）或 &lt;code&gt;EXIT PROGRAM&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;）来完成。此时：</target>
        </trans-unit>
        <trans-unit id="fb4435d664648be40b4a8cc4319cd6f4b4970f02" translate="yes" xml:space="preserve">
          <source>If the subprograms procedure division header or&lt;code&gt;ENTRY&lt;/code&gt;statement included a&lt;code&gt;RETURNING&lt;/code&gt; (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;); this behaviour can be altered utilizing the&lt;code&gt;CALL-CONVENTION&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) feature to leave&lt;code&gt;RETURN-CODE&lt;/code&gt;unchanged.</source>
          <target state="translated">如果子程序的过程分区标头或 &lt;code&gt;ENTRY&lt;/code&gt; 语句包含 &lt;code&gt;RETURNING&lt;/code&gt; （请参见&lt;a href=&quot;#Special-Registers&quot;&gt;特殊寄存器&lt;/a&gt;）；可以使用 &lt;code&gt;CALL-CONVENTION&lt;/code&gt; （请参阅&lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;）功能更改此行为，以保持 &lt;code&gt;RETURN-CODE&lt;/code&gt; 不变。</target>
        </trans-unit>
        <trans-unit id="4fca4d357c4da52ecdfe09ff7f3b59313032d58e" translate="yes" xml:space="preserve">
          <source>If the subroutine is successful, a value of 0 will be returned in the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;). Failure to retrieve the needed statistics on the file will cause a&lt;code&gt;RETURN-CODE&lt;/code&gt;special register value of 35 to be passed back. Supplying less than two arguments will generate a 128&lt;code&gt;RETURN-CODE&lt;/code&gt;special register value.</source>
          <target state="translated">如果该子例程成功，则将在 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器中返回 0值（请参见&lt;a href=&quot;#Special-Registers&quot;&gt;特殊寄存器&lt;/a&gt;）。无法检索文件上所需的统计信息将导致将 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器值35传回。提供少于两个参数将生成一个128 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器值。</target>
        </trans-unit>
        <trans-unit id="2e2d3e910dfeb525715cdc365898fd54399a43c4" translate="yes" xml:space="preserve">
          <source>If the subroutine is successful, a value of 0 will be returned in the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;). Failure will cause a&lt;code&gt;RETURN-CODE&lt;/code&gt;special register value of -1 to be passed back.</source>
          <target state="translated">如果该子例程成功，则将在 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器中返回 0值（请参见&lt;a href=&quot;#Special-Registers&quot;&gt;特殊寄存器&lt;/a&gt;）。失败将导致将 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器值-1传回。</target>
        </trans-unit>
        <trans-unit id="d1bb984fa6207ca92b69374fdf44a4d8170a10b1" translate="yes" xml:space="preserve">
          <source>If the value being stored into the field is the same length as the receiving field, the presence or absence of the&lt;code&gt;JUSTIFIED RIGHT&lt;/code&gt;clause on that field&amp;rsquo;s description is irrelevant.</source>
          <target state="translated">如果存储在字段中的值与接收字段的长度相同，则该字段说明中是否存在 &lt;code&gt;JUSTIFIED RIGHT&lt;/code&gt; 子句是无关紧要的。</target>
        </trans-unit>
        <trans-unit id="e5b69bef404018740f53a3d7738badc9ff4e4531" translate="yes" xml:space="preserve">
          <source>If the value of &amp;lt;</source>
          <target state="translated">如果&amp;lt;</target>
        </trans-unit>
        <trans-unit id="a8941ef78769624061ef92939b2c773736817ccd" translate="yes" xml:space="preserve">
          <source>If the value of the numeric value moved into the field is positive (0 or greater), a &quot;+&quot; character will be inserted. If the value is negative (less than 0), a &quot;-&quot; character is inserted.</source>
          <target state="translated">如果移动到字段中的数值为正值(0或更大),将插入一个 &quot;+&quot;字符,如果数值为负值(小于0),则插入一个&quot;-&quot;字符。如果数值为负值(小于0),则插入&quot;-&quot;字符。</target>
        </trans-unit>
        <trans-unit id="fa45922afd3a1788e3ef11576266d429b5817fba" translate="yes" xml:space="preserve">
          <source>If the value of the numeric value moved into the field is positive (0 or greater), a space will be inserted. If the value is negative (less than 0), a &quot;-&quot; character is inserted.</source>
          <target state="translated">如果移动到字段中的数值为正值(0或更大),则会插入一个空格;如果数值为负值(小于0),则会插入一个&quot;-&quot;字。如果数值为负值(小于0),则插入一个&quot;-&quot;字符。</target>
        </trans-unit>
        <trans-unit id="48dd00b4185648ad98a04dd28fc9dd3c41fb5dc5" translate="yes" xml:space="preserve">
          <source>If the value specified for the &amp;lt;</source>
          <target state="translated">如果为&amp;lt;</target>
        </trans-unit>
        <trans-unit id="0831d72b5b85932627f6976dfb6259ade2e7b74e" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;-fintrinsics=WHEN-COMPILED&lt;/code&gt;switch or&lt;code&gt;-fintrinsics=ALL&lt;/code&gt;switch is specified to the compiler or the&lt;code&gt;REPOSITORY&lt;/code&gt;(see &lt;a href=&quot;#REPOSITORY&quot;&gt;REPOSITORY&lt;/a&gt;) paragraph specifies either&lt;code&gt;FUNCTION WHEN-COMPILED INTRINSIC&lt;/code&gt;or&lt;code&gt;FUNCTION ALL INTRINSIC&lt;/code&gt; then references to&lt;code&gt;WHEN-COMPILED&lt;/code&gt;(without a leading&lt;code&gt;FUNCTION&lt;/code&gt;keyword will always reference this intrinsic function and there will be no way to access the&lt;code&gt;WHEN-COMPILED&lt;/code&gt;special register.</source>
          <target state="translated">如果将 &lt;code&gt;-fintrinsics=WHEN-COMPILED&lt;/code&gt; 开关或 &lt;code&gt;-fintrinsics=ALL&lt;/code&gt; 开关指定给编译器，或者 &lt;code&gt;REPOSITORY&lt;/code&gt; （请参阅&lt;a href=&quot;#REPOSITORY&quot;&gt;REPOSITORY&lt;/a&gt;）段落指定 &lt;code&gt;FUNCTION WHEN-COMPILED INTRINSIC&lt;/code&gt; 或 &lt;code&gt;FUNCTION ALL INTRINSIC&lt;/code&gt; ,则引用 &lt;code&gt;WHEN-COMPILED&lt;/code&gt; （不带前导 &lt;code&gt;FUNCTION&lt;/code&gt; 关键字将始终引用此内在函数，并且将无法访问 &lt;code&gt;WHEN-COMPILED&lt;/code&gt; 特殊寄存器。</target>
        </trans-unit>
        <trans-unit id="3b420486302df3f6e207a4313dfd931a759d89b7" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;-ftrace&lt;/code&gt;switch</source>
          <target state="translated">如果 &lt;code&gt;-ftrace&lt;/code&gt; 开关</target>
        </trans-unit>
        <trans-unit id="3349b7269aaccc8bb1cc998766e4a46beb55bde2" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;ACCESS MODE&lt;/code&gt;of &amp;lt;</source>
          <target state="translated">如果 &lt;code&gt;ACCESS MODE&lt;/code&gt; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="2e5d9e90a43cf87c9978ea30182b2bcd04cc6c52" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;ADDRESS OF&lt;/code&gt;clause is absent after the&lt;code&gt;TO&lt;/code&gt; the contents of &amp;lt;</source>
          <target state="translated">如果在 &lt;code&gt;TO&lt;/code&gt; 之后缺少 &lt;code&gt;ADDRESS OF&lt;/code&gt; 子句，则&amp;lt;</target>
        </trans-unit>
        <trans-unit id="26199d3754ff366a5846d65d208ee2e6de9686ad" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;ALL&lt;/code&gt;keyword was specified on the&lt;code&gt;VALUE&lt;/code&gt;clause, all members of the field list with&lt;code&gt;VALUE&lt;/code&gt;clauses will qualify.</source>
          <target state="translated">如果在 &lt;code&gt;VALUE&lt;/code&gt; 子句上指定了 &lt;code&gt;ALL&lt;/code&gt; 关键字，则带有 &lt;code&gt;VALUE&lt;/code&gt; 子句的字段列表的所有成员将符合条件。</target>
        </trans-unit>
        <trans-unit id="df5d251bac8a9bff6db280d0993ff1dbfac8f41c" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;CONSTANT&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;CONSTANT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c81429e41c0cb12a035faac7aa149969b981744" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;CRT STATUS&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;CRT STATUS&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bdf79d6d2d1dddc9f4d79dc6b3151fcff14428de" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;FD&lt;/code&gt;of the file contains the&lt;code&gt;RECORD CONTAINS&lt;/code&gt;or&lt;code&gt;RECORD IS VARYING&lt;/code&gt;clause, and that clause allows the record size to vary, the size</source>
          <target state="translated">如果文件的 &lt;code&gt;FD&lt;/code&gt; 包含 &lt;code&gt;RECORD CONTAINS&lt;/code&gt; 或 &lt;code&gt;RECORD IS VARYING&lt;/code&gt; 子句，并且该子句允许记录大小变化，则该大小</target>
        </trans-unit>
        <trans-unit id="7cd7e97ca9d4f2995a04bb967f17ad631843750e" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;FD&lt;/code&gt;of the file contains the&lt;code&gt;RECORD CONTAINS&lt;/code&gt;or&lt;code&gt;RECORD IS VARYING&lt;/code&gt;clause, and that clause allows the record size to vary, the size of &amp;lt;</source>
          <target state="translated">如果文件的 &lt;code&gt;FD&lt;/code&gt; 包含 &lt;code&gt;RECORD CONTAINS&lt;/code&gt; 或 &lt;code&gt;RECORD IS VARYING&lt;/code&gt; 子句，并且该子句允许记录大小发生变化，则&amp;lt;</target>
        </trans-unit>
        <trans-unit id="8342745452a46e82129819210173c072a362af42" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;LINAGE&lt;/code&gt;(see &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File/Sort-Description&lt;/a&gt;) clause is</source>
          <target state="translated">如果 &lt;code&gt;LINAGE&lt;/code&gt; （请参阅&lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File / Sort-Description&lt;/a&gt;）子句是</target>
        </trans-unit>
        <trans-unit id="67faed20b65d381e0f35f57376ea02fccee28463" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;LOCK ON&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;LOCK ON&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a4cf245f7ab4d128cf1a215befd46fe8ca30464" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;LOCK ON&lt;/code&gt;clause</source>
          <target state="translated">如果 &lt;code&gt;LOCK ON&lt;/code&gt; 子句</target>
        </trans-unit>
        <trans-unit id="5348e096005262a0ab82c3168003e7e7371e7dae" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;PERFORM&lt;/code&gt;specifies or implies&lt;code&gt;WITH TEST BEFORE&lt;/code&gt; &amp;lt;</source>
          <target state="translated">如果 &lt;code&gt;PERFORM&lt;/code&gt; 指定或暗示 &lt;code&gt;WITH TEST BEFORE&lt;/code&gt; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="dd5a2104ff28017a6be9e284824ff9c6d67e6603" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;PROGRAM-ID&lt;/code&gt;(see &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt;) clause of the subprogram included the&lt;code&gt;INITIAL&lt;/code&gt;</source>
          <target state="translated">如果子程序的 &lt;code&gt;PROGRAM-ID&lt;/code&gt; （请参阅&lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt;）子句包含 &lt;code&gt;INITIAL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="68679aad3ae2e21817a3db3c1cd8a4c87162b63f" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;RD&lt;/code&gt;(see &lt;a href=&quot;#REPORT-SECTION&quot;&gt;REPORT SECTION&lt;/a&gt;) in which the report group containing a&lt;code&gt;NEXT GROUP&lt;/code&gt;clause does not contain a&lt;code&gt;PAGE LIMITS&lt;/code&gt;clause, only the&lt;code&gt;PLUS integer-1&lt;/code&gt;option may be specified.</source>
          <target state="translated">如果 &lt;code&gt;RD&lt;/code&gt; （请参见&lt;a href=&quot;#REPORT-SECTION&quot;&gt;REPORT SECTION&lt;/a&gt;）中包含 &lt;code&gt;NEXT GROUP&lt;/code&gt; 子句的报告组不包含 &lt;code&gt;PAGE LIMITS&lt;/code&gt; 子句，则只能指定 &lt;code&gt;PLUS integer-1&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="6326e274617c726298b0f2a259364a71ec08cb9a" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;REMAINDER&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;REMAINDER&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d46ae7e0403a69183623c2c0c30c04ac183c02a4" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;RESET&lt;/code&gt;option is coded,&lt;code&gt;FINAL&lt;/code&gt;or &amp;lt;</source>
          <target state="translated">如果对 &lt;code&gt;RESET&lt;/code&gt; 选项进行了编码，则 &lt;code&gt;FINAL&lt;/code&gt; 或&amp;lt;</target>
        </trans-unit>
        <trans-unit id="38a1fbfcc2ff5f0f55dba89a7b49d153d656d7e5" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;SELECT&lt;/code&gt;(see &lt;a href=&quot;#SELECT&quot;&gt;SELECT&lt;/a&gt;) statement or file&lt;code&gt;OPEN&lt;/code&gt;(see &lt;a href=&quot;#OPEN&quot;&gt;OPEN&lt;/a&gt;) specifies&lt;code&gt;SHARING WITH NO OTHER&lt;/code&gt; record locking will be disabled.</source>
          <target state="translated">如果 &lt;code&gt;SELECT&lt;/code&gt; （参见&lt;a href=&quot;#SELECT&quot;&gt;SELECT&lt;/a&gt;）语句或 &lt;code&gt;OPEN&lt;/code&gt; （参见&lt;a href=&quot;#OPEN&quot;&gt;OPEN&lt;/a&gt;）文件指定 &lt;code&gt;SHARING WITH NO OTHER&lt;/code&gt; ,则记录锁定将被禁用。</target>
        </trans-unit>
        <trans-unit id="4469b431cec5ac5fa31a45bf59859b62ee522aee" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;SELECT&lt;/code&gt;of a file is coded with a&lt;code&gt;FILE STATUS&lt;/code&gt;clause,&lt;code&gt;OPEN&lt;/code&gt;failures &amp;mdash; including those induced by sharing failures &amp;mdash; will be detectable by the program and a graceful recovery (or at least a graceful termination) will be possible. If no such clause was coded, however, a runtime message will be issued and the program will be terminated.</source>
          <target state="translated">如果使用 &lt;code&gt;FILE STATUS&lt;/code&gt; 子句对文件的 &lt;code&gt;SELECT&lt;/code&gt; 进行编码，则 &lt;code&gt;OPEN&lt;/code&gt; 故障（包括由共享故障引起的故障）将可由程序检测到，并且可以正常恢复（或至少正常终止）。但是，如果未对此类子句进行编码，则将发出运行时消息并终止程序。</target>
        </trans-unit>
        <trans-unit id="d43773d0d9856113d341b49d71c616d3ba81cd29" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;SEPARATE CHARACTER&lt;/code&gt;clause</source>
          <target state="translated">如果 &lt;code&gt;SEPARATE CHARACTER&lt;/code&gt; 子句</target>
        </trans-unit>
        <trans-unit id="cc7da6fe4678bd908df6708f4cd87c152a905cc1" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;SYNCRONIZED&lt;/code&gt;clause is coded on anything but a numeric data item with a&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) that specifies storage of data in a binary form, the&lt;code&gt;SYNCRONIZED&lt;/code&gt;clause will be ignored.</source>
          <target state="translated">如果将 &lt;code&gt;SYNCRONIZED&lt;/code&gt; 子句编码在除数字数据项之外的任何内容上，并且 &lt;code&gt;USAGE&lt;/code&gt; （请参阅&lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;）以二进制形式指定数据存储，则 &lt;code&gt;SYNCRONIZED&lt;/code&gt; 子句将被忽略。</target>
        </trans-unit>
        <trans-unit id="3d2f7b6539018dd97bf4f7ebf6332805f3b4ccf8" translate="yes" xml:space="preserve">
          <source>If there are fewer tokens than there are arguments, the excess arguments will be initialized as if the&lt;code&gt;INITIALIZE &amp;lt;&lt;i&gt;identifier-1&lt;/i&gt;&amp;gt;&lt;/code&gt;(see &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt;) statement were executed.</source>
          <target state="translated">如果令牌少于参数，则多余的参数将被初始化，就像执行 &lt;code&gt;INITIALIZE &amp;lt;&lt;i&gt;identifier-1&lt;/i&gt;&amp;gt;&lt;/code&gt; （请参阅&lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt;）语句一样。</target>
        </trans-unit>
        <trans-unit id="061529f2e81b4789d20b56f0ff94bb58b24306f6" translate="yes" xml:space="preserve">
          <source>If there are more tokens than there are arguments, the excess tokens will be discarded.</source>
          <target state="translated">如果代币数量多于论证数量,多余的代币将被丢弃。</target>
        </trans-unit>
        <trans-unit id="f2d936a65b86a2841ae9003e465d423ea6c6934c" translate="yes" xml:space="preserve">
          <source>If there are multiple cash registers in a particular department of a specific store, the data needs to be further sorted so that the cash registers are ordered in sequence of their register number.</source>
          <target state="translated">如果某个商店的某个部门有多台收银机,则需要进一步对数据进行排序,使收银机按收银机号的顺序排列。</target>
        </trans-unit>
        <trans-unit id="3972fbb29cfb0307f762dc829ca3e5c79c5963a7" translate="yes" xml:space="preserve">
          <source>If there are multiple record descriptions present for a given&lt;code&gt;FD&lt;/code&gt;or&lt;code&gt;SD&lt;/code&gt; the one with the longest length will define the size of the record buffer into which a&lt;code&gt;READ&lt;/code&gt;statement (see &lt;a href=&quot;#READ&quot;&gt;READ&lt;/a&gt;) or a&lt;code&gt;RETURN&lt;/code&gt;statement (see &lt;a href=&quot;#RETURN&quot;&gt;RETURN&lt;/a&gt;) will deliver data read from the file and from which a&lt;code&gt;WRITE&lt;/code&gt;statement (see &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;) or&lt;code&gt;RELEASE&lt;/code&gt;statement (see &lt;a href=&quot;#RELEASE&quot;&gt;RELEASE&lt;/a&gt;) statement will obtain the data to be written to the file.</source>
          <target state="translated">如果给定的 &lt;code&gt;FD&lt;/code&gt; 或 &lt;code&gt;SD&lt;/code&gt; 有多个记录描述，则最长的长度将定义记录缓冲区的大小，其中 &lt;code&gt;READ&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#READ&quot;&gt;READ&lt;/a&gt;）或 &lt;code&gt;RETURN&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#RETURN&quot;&gt;RETURN&lt;/a&gt;）将传递从FD或SD读取的数据。文件，并且 &lt;code&gt;WRITE&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;）或 &lt;code&gt;RELEASE&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#RELEASE&quot;&gt;RELEASE&lt;/a&gt;）语句将从文件中获取要写入的数据。</target>
        </trans-unit>
        <trans-unit id="75eb31de9a88419e99f8f2249dfa222651219fe7" translate="yes" xml:space="preserve">
          <source>If there is no picture clause and the&lt;code&gt;ALL&lt;/code&gt;option is specified, the&lt;code&gt;ALL&lt;/code&gt;option will be ignored.</source>
          <target state="translated">如果没有图片子句和 &lt;code&gt;ALL&lt;/code&gt; 指定选项， &lt;code&gt;ALL&lt;/code&gt; 选项都将被忽略。</target>
        </trans-unit>
        <trans-unit id="0c755b4b694e7c4beb9b1c5901a6f3a6e90065fa" translate="yes" xml:space="preserve">
          <source>If there is no picture clause specified, the size of the screen data item will be the length of the &amp;lt;</source>
          <target state="translated">如果未指定picture子句，则屏幕数据项的大小将为&amp;lt;</target>
        </trans-unit>
        <trans-unit id="be6e32115bff0c291e8d3c6d6525390722099349" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;C-D&lt;/code&gt;data item, then are there&lt;code&gt;C&lt;/code&gt;and&lt;code&gt;D&lt;/code&gt;data items? If not, the&lt;code&gt;COMPUTE&lt;/code&gt;statement is in error. If there are, however, then code will be generated to subtract the value of&lt;code&gt;D&lt;/code&gt;from&lt;code&gt;C&lt;/code&gt;and add 1 to the result.</source>
          <target state="translated">如果没有 &lt;code&gt;C-D&lt;/code&gt; 数据项，那么是否有 &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt; 数据项？如果不是，则 &lt;code&gt;COMPUTE&lt;/code&gt; 语句错误。如果存在，则将生成代码以从 &lt;code&gt;C&lt;/code&gt; 中减去 &lt;code&gt;D&lt;/code&gt; 的值并将结果加1。</target>
        </trans-unit>
        <trans-unit id="6dbb73155f0ea4fd82ba811977b3d699fc88a4ae" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;CONTROL&lt;/code&gt;clause, the report will contain no control breaks; this implies that there can be no&lt;code&gt;CONTROL HEADING&lt;/code&gt;or&lt;code&gt;CONTROL FOOTING&lt;/code&gt;report groups defined for this&lt;code&gt;RD&lt;/code&gt;</source>
          <target state="translated">如果没有 &lt;code&gt;CONTROL&lt;/code&gt; 子句，则报告将不包含控制中断；这意味着不能为此 &lt;code&gt;RD&lt;/code&gt; 定义 &lt;code&gt;CONTROL HEADING&lt;/code&gt; 或 &lt;code&gt;CONTROL FOOTING&lt;/code&gt; 报告组</target>
        </trans-unit>
        <trans-unit id="a351d89c95027f7701058bc9f942df00ed507cdc" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;INITIAL&lt;/code&gt;clause specified, the target range is the entire inspect subject.</source>
          <target state="translated">如果未指定 &lt;code&gt;INITIAL&lt;/code&gt; 子句，则目标范围是整个检查对象。</target>
        </trans-unit>
        <trans-unit id="f81540f4079ee51c4206d96a7efc736809a22ed7" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;RESET&lt;/code&gt;option coded, the sum counter will be reset back to zero after each time the control footing containing the&lt;code&gt;SUM&lt;/code&gt;clause is presented. This is the typical behaviour that would be expected.</source>
          <target state="translated">如果未编码任何 &lt;code&gt;RESET&lt;/code&gt; 选项，则每次出现包含 &lt;code&gt;SUM&lt;/code&gt; 子句的控制基础时，总和计数器将重置为零。这是预期的典型行为。</target>
        </trans-unit>
        <trans-unit id="d5e252dc91e0d99f464bda7bc7cffd6140f7edd1" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;UPON&lt;/code&gt;clause specified, the value of &amp;lt;</source>
          <target state="translated">如果未指定 &lt;code&gt;UPON&lt;/code&gt; 子句，则&amp;lt;</target>
        </trans-unit>
        <trans-unit id="3241679c69995dc4a256fad0940c95e8635b9f3e" translate="yes" xml:space="preserve">
          <source>If there is only a single detail group in the report&amp;rsquo;s definition, the&lt;code&gt;UPON&lt;/code&gt;clause is meaningless.</source>
          <target state="translated">如果报告的定义中只有一个详细信息组，则 &lt;code&gt;UPON&lt;/code&gt; 子句将毫无意义。</target>
        </trans-unit>
        <trans-unit id="c11b35162c1c669848bde8fb8b4adb40363c054b" translate="yes" xml:space="preserve">
          <source>If this format of the&lt;code&gt;GO TO&lt;/code&gt;statement appears in a consecutive sequence of imperative statements (see &lt;a href=&quot;#Imperative-Statement&quot;&gt;Imperative Statement&lt;/a&gt;) within a sentence, it must be the</source>
          <target state="translated">如果 &lt;code&gt;GO TO&lt;/code&gt; 语句的这种格式出现在句子中的命令式语句的连续序列中（请参见&lt;a href=&quot;#Imperative-Statement&quot;&gt;命令式语句&lt;/a&gt;），则它必须是</target>
        </trans-unit>
        <trans-unit id="87568d2d981805ff51bcc79d09c4d6bfd7b2a8ef" translate="yes" xml:space="preserve">
          <source>If this is NOT set to a value, all&lt;code&gt;-ftrace&lt;/code&gt;switch and&lt;code&gt;-ftraceall&lt;/code&gt;switch output will be written to STDERR, where it may be piped via a &quot;2&amp;gt; filename&quot; on the command that executes the program.</source>
          <target state="translated">如果未将其设置为值，则所有 &lt;code&gt;-ftrace&lt;/code&gt; 开关和 &lt;code&gt;-ftraceall&lt;/code&gt; 开关的输出都将写入STDERR，在此处可以通过执行程序的命令上的&amp;ldquo; 2&amp;gt;文件名&amp;rdquo;将其输出。</target>
        </trans-unit>
        <trans-unit id="e41eac2db71cda7170c71b8ec2c30d7834407d0c" translate="yes" xml:space="preserve">
          <source>If this is not defined under *nix it will default to /usr/local/share/gnucobol/config.</source>
          <target state="translated">如果在*nix下没有定义,它将默认为/usr/local/share/gnucobol/config。</target>
        </trans-unit>
        <trans-unit id="023cf0ecfd0afc5f6ae392348d069495edac90d8" translate="yes" xml:space="preserve">
          <source>If used with&lt;code&gt;PIC X&lt;/code&gt; allocates one byte of storage per&lt;code&gt;X&lt;/code&gt; range of values is 0 to max storable in that many bytes. If used with&lt;code&gt;PIC 9&lt;/code&gt; range of values depends on number of&lt;code&gt;9&lt;/code&gt; in PICTURE</source>
          <target state="translated">如果与 &lt;code&gt;PIC X&lt;/code&gt; 一起使用，则每个 &lt;code&gt;X&lt;/code&gt; 的值范围为0到最大可存储字节数，分配一个字节的存储空间。如果与 &lt;code&gt;PIC 9&lt;/code&gt; 一起使用，则取值范围取决于PICTURE 中 &lt;code&gt;9&lt;/code&gt; 的数量</target>
        </trans-unit>
        <trans-unit id="5b48ea3221a5bd190b3da00947706eadb4325c47" translate="yes" xml:space="preserve">
          <source>If used, &amp;lt;</source>
          <target state="translated">如果使用，&amp;lt;</target>
        </trans-unit>
        <trans-unit id="f92f6ebb3f39d6efd118da1f36149fda0df27506" translate="yes" xml:space="preserve">
          <source>If you are comfortable with the &quot;C&quot; programming language, you might find the following simple GnuCOBOL program useful in exploring the differences between subscripting and indexing:</source>
          <target state="translated">如果你对 &quot;C &quot;编程语言很熟悉,你可能会发现下面这个简单的GnuCOBOL程序对探索下标和索引之间的区别很有用。</target>
        </trans-unit>
        <trans-unit id="66062304bf503c5649ee5c39992874bd53f8d855" translate="yes" xml:space="preserve">
          <source>If you are planning on using static-linked subroutine libraries, set this variable to the path of the directory containing your libraries.</source>
          <target state="translated">如果你打算使用静态链接的子程序库,请将这个变量设置为包含库的目录路径。</target>
        </trans-unit>
        <trans-unit id="01f92f2645932d2e7b72a1c8110cdcfbd8882f1a" translate="yes" xml:space="preserve">
          <source>If you are sorting &amp;lt;</source>
          <target state="translated">如果要排序&amp;lt;</target>
        </trans-unit>
        <trans-unit id="02aa6a4a695c82943ebf8b43c9d16d82122de6f1" translate="yes" xml:space="preserve">
          <source>If you are using Fixed Format Mode, the alphanumeric literal can be run right up to and including column 72. The literal may then be continued on the next line anywhere after column 11 by coding another quote or apostrophe (whichever was used to begin the literal originally). The continuation line must also have a hyphen (-)</source>
          <target state="translated">如果您使用的是固定格式模式,字母数字文字可以一直运行到第72列。然后,在第11列之后的下一行,可以通过编码另一个引号或撇号(以最初用于开始字词的为准)来延续字词。延续行还必须有一个连字符(-)。</target>
        </trans-unit>
        <trans-unit id="67c575e7eebaede09fa7a3ba7a66b085e2b666ab" translate="yes" xml:space="preserve">
          <source>If you attempt to store a negative number into a packed decimal field that has no&lt;code&gt;S&lt;/code&gt;in its&lt;code&gt;PICTURE&lt;/code&gt; the absolute value of the negative number will actually be stored.</source>
          <target state="translated">如果试图为负数存储到一个没有压缩十进制场 &lt;code&gt;S&lt;/code&gt; 在其 &lt;code&gt;PICTURE&lt;/code&gt; 负数的绝对值实际上将被保存。</target>
        </trans-unit>
        <trans-unit id="33f09798c9350fe782168c79a484ebfce1dfd921" translate="yes" xml:space="preserve">
          <source>If you have used other versions of COBOL before (particularly mainframe implementations), you&amp;rsquo;ve possibly seen subroutine calls made passing a procedure name as an argument &amp;mdash; that is not possible in GnuCOBOL; instead, you need to know how to use this form of the&lt;code&gt;SET&lt;/code&gt;statement.</source>
          <target state="translated">如果您以前使用过其他版本的COBOL（尤其是大型机实现），则可能已经看到通过将过程名称作为参数来进行子例程调用-这在GnuCOBOL中是不可能的。相反，您需要知道如何使用这种形式的 &lt;code&gt;SET&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="8575747ffb34e15317f4825a1a6d194e243908c5" translate="yes" xml:space="preserve">
          <source>If you like to hold a book in your hands, I strongly recommend &quot;Murach&amp;rsquo;s Structured COBOL&quot;, by Mike Murach, Anne Prince and Raul Menendez (2000) - ISBN 9781890774059. Mike Murach and his various writing partners have been writing outstanding COBOL textbooks for decades, and this text is no exception. It&amp;rsquo;s an excellent book for those familiar with the concepts of programming in other languages, but unfamiliar with COBOL.</source>
          <target state="translated">如果您想拿一本书，我强烈推荐Mike Murach，Anne Prince和Raul Menendez（2000）撰写的&amp;ldquo; Murach的结构化COBOL&amp;rdquo;-ISBN9781890774059。Mike Murach和他的各个写作伙伴一直在为几十年，本文也不例外。对于那些熟悉其他语言的编程概念但不熟悉COBOL的人来说，这是一本非常不错的书。</target>
        </trans-unit>
        <trans-unit id="a983cec50cc8adb2cb72101e62421b49b40c3f8f" translate="yes" xml:space="preserve">
          <source>If you need to allocate space for a data item whose format is two letters followed by five digits followed by three letters, you could use the &amp;lt;</source>
          <target state="translated">如果需要为格式为两个字母，五个数字和三个字母的数据项分配空间，则可以使用&amp;lt;</target>
        </trans-unit>
        <trans-unit id="3d7ab34ba2edb8344ca5cd05ed4f78d8ca295856" translate="yes" xml:space="preserve">
          <source>If you need to apply&lt;code&gt;REPLACING&lt;/code&gt;initialization to multiple &amp;lt;</source>
          <target state="translated">如果您需要将 &lt;code&gt;REPLACING&lt;/code&gt; 初始化应用于多个&amp;lt;</target>
        </trans-unit>
        <trans-unit id="0be77805ea73d60e3aa2532f09cd1417a0b5f725" translate="yes" xml:space="preserve">
          <source>If you need to apply&lt;code&gt;VALUE&lt;/code&gt;initialization to multiple &amp;lt;</source>
          <target state="translated">如果您需要将 &lt;code&gt;VALUE&lt;/code&gt; 初始化应用于多个&amp;lt;</target>
        </trans-unit>
        <trans-unit id="09b277bb04315e13de2ea2c1d6215f972f449420" translate="yes" xml:space="preserve">
          <source>If you need to qualify a reference to a table, do so by coding something like&lt;code&gt;&amp;lt;&lt;i&gt;identifier-1&lt;/i&gt;&amp;gt; OF &amp;lt;&lt;i&gt;identifier-2&lt;/i&gt;&amp;gt; ( subscript(s) )&lt;/code&gt;</source>
          <target state="translated">如果您需要限定对表的引用，可以通过对 &lt;code&gt;&amp;lt;&lt;i&gt;identifier-1&lt;/i&gt;&amp;gt; OF &amp;lt;&lt;i&gt;identifier-2&lt;/i&gt;&amp;gt; ( subscript(s) )&lt;/code&gt; &lt;i&gt;identifier-1&lt;/i&gt; &amp;gt; OF &amp;lt; &lt;i&gt;identifier-2&lt;/i&gt; &amp;gt;（下标）之类的代码进行编码&lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="ea477a1b93e894e00c5029bde5c4700835a658bc" translate="yes" xml:space="preserve">
          <source>If you only need to use the computed occurrence number once, you might as well just use the computed occurrence number data item as a subscript. If, however, you will need to use a computed &quot;subscript&quot; many more times than once, the run-time overhead of converting that occurrence value to an index (via&lt;code&gt;SET Index&lt;/code&gt; will be worth the coding effort.</source>
          <target state="translated">如果只需要使用一次计算的出现次数，则最好将计算的出现次数数据项用作下标。但是，如果您需要多次使用计算出的&amp;ldquo;下标&amp;rdquo;，那么将发生值转换为索引的运行时开销（通过 &lt;code&gt;SET Index&lt;/code&gt; )将值得进行编码。</target>
        </trans-unit>
        <trans-unit id="1b1aec7f2d01b9337cb99ecf14cbd063323c6bfc" translate="yes" xml:space="preserve">
          <source>If you specify a specific filename in the sort/merge work file&amp;rsquo;s&lt;code&gt;SELECT&lt;/code&gt; it will be ignored.</source>
          <target state="translated">如果您在排序/合并工作文件的 &lt;code&gt;SELECT&lt;/code&gt; 中指定了特定的文件名，它将被忽略。</target>
        </trans-unit>
        <trans-unit id="db4b705d51633a3053f41836b85c013703781c0c" translate="yes" xml:space="preserve">
          <source>If you specify&lt;code&gt;FINAL&lt;/code&gt; it must be the first control break named in the&lt;code&gt;RD&lt;/code&gt;</source>
          <target state="translated">如果指定 &lt;code&gt;FINAL&lt;/code&gt; ,则它必须是 &lt;code&gt;RD&lt;/code&gt; 中命名的第一个控制中断</target>
        </trans-unit>
        <trans-unit id="bd75b97fc760ccc29226f53558113a860ab9c393" translate="yes" xml:space="preserve">
          <source>If you want to squeeze every last bit of performance out of your GnuCOBOL programs, don&amp;rsquo;t forget to investigate the&lt;code&gt;-O&lt;/code&gt;switch</source>
          <target state="translated">如果您想从GnuCOBOL程序中挤出所有最后的性能，别忘了研究 &lt;code&gt;-O&lt;/code&gt; 开关</target>
        </trans-unit>
        <trans-unit id="d6f238b944da72a8958154ef52736f8bf20193b7" translate="yes" xml:space="preserve">
          <source>If you wanted to store the value 128 million into that field, you would do so as if the&lt;code&gt;P&lt;/code&gt; were&lt;code&gt;9&lt;/code&gt;:</source>
          <target state="translated">如果要将值1.28亿存储到该字段中，则将 &lt;code&gt;P&lt;/code&gt; 设置为 &lt;code&gt;9&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f960091ad57764e902ba6a62fa5a1b8ba304ce95" translate="yes" xml:space="preserve">
          <source>If you will be porting existing code over to GnuCOBOL, you&amp;rsquo;ll find it an accommodating facility capable of conforming to whatever language and coding standards that code is likely to use. If you are creating new GnuCOBOL programs, however, I would strongly counsel you to use the&lt;code&gt;END-verb&lt;/code&gt;structures in those programs.</source>
          <target state="translated">如果要将现有代码移植到GnuCOBOL，您会发现它是一种容纳工具，能够符合可能使用的任何语言和编码标准。但是，如果您要创建新的GnuCOBOL程序，我强烈建议您在这些程序中使用END- &lt;code&gt;END-verb&lt;/code&gt; 结构。</target>
        </trans-unit>
        <trans-unit id="84f76abe3e8dfd99557f1d9c28b5a29519b7cdd8" translate="yes" xml:space="preserve">
          <source>If your GnuCOBOL build uses the Berkeley Database (BDB) package, use this environment variable to specify the folder in which the lock management files to be associated with all non-SORT files opened by the program will be stored.&lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;) files will also have their data file allocated in the folder pointed to by this environment variable, if it exists.. Having this variable defined will activate record locking features on the&lt;code&gt;READ&lt;/code&gt;statement (see &lt;a href=&quot;#READ&quot;&gt;READ&lt;/a&gt;),&lt;code&gt;REWRITE&lt;/code&gt;statement (see &lt;a href=&quot;#REWRITE&quot;&gt;REWRITE&lt;/a&gt;) and&lt;code&gt;WRITE&lt;/code&gt;statement (see &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;). Even with DB_HOME, locking will not work with&lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;),&lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE SEQUENTIAL&lt;/a&gt;) or ORGANIZATION RELATIVE files with GnuCOBOL builds created for Windows/MinGW.&lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt;locks will work with Windows/MinGW + BDB and all locks will work for all file organizations with UNIX GnuCOBOL builds.</source>
          <target state="translated">如果您的GnuCOBOL版本使用Berkeley数据库（BDB）包，请使用此环境变量指定文件夹，在该文件夹中将存储与程序打开的所有非SORT文件相关联的锁管理文件。 &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; （请参阅&lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;组织索引&lt;/a&gt;）文件还将在此环境变量所指向的文件夹（如果存在）中分配其数据文件。定义此变量将激活 &lt;code&gt;READ&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#READ&quot;&gt;READ&lt;/a&gt;）， &lt;code&gt;REWRITE&lt;/code&gt; 语句上的记录锁定功能。（请参阅&lt;a href=&quot;#REWRITE&quot;&gt;REWRITE&lt;/a&gt;）和 &lt;code&gt;WRITE&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;）。即使使用DB_HOME，锁定也不适用于 &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; （请参阅&lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;组织顺序&lt;/a&gt;）， &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; （请参见&lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;组织&lt;/a&gt;顺序）或具有为Windows / MinGW创建的GnuCOBOL构建的组织相对文件。 &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; 锁将与Windows / MinGW + BDB一起使用，并且所有锁将对具有UNIX GnuCOBOL构建的所有文件组织都起作用。</target>
        </trans-unit>
        <trans-unit id="5d5c76b0afd98975a32ec5cfb6a7e9651011522c" translate="yes" xml:space="preserve">
          <source>If your program is using Free Format Mode, there&amp;rsquo;s less need to continue long alphanumeric literals because statements may be as long as 255 characters.</source>
          <target state="translated">如果您的程序使用的是&amp;ldquo;自由格式模式&amp;rdquo;，则无需再继续使用长字母数字文字，因为语句可能长达255个字符。</target>
        </trans-unit>
        <trans-unit id="9ec069692353086fbfea33bd5148cbb40a61d28b" translate="yes" xml:space="preserve">
          <source>If, however, the GnuCOBOL compiler was built for a Unix, OSX or Linux environment, or was built for a Windows environment utilizing either the Cygwin or MinGW Unix emulators, use a colon character (:) as the delimiter.</source>
          <target state="translated">但是,如果GnuCOBOL编译器是为Unix、OSX或Linux环境构建的,或者是利用Cygwin或MinGW Unix模拟器为Windows环境构建的,则使用冒号字符(:)作为分隔符。</target>
        </trans-unit>
        <trans-unit id="732d00d8a979e2d6acfa93077091ec5aa45575e1" translate="yes" xml:space="preserve">
          <source>If, however, you want to reset the&lt;code&gt;SUM&lt;/code&gt;counter only when the control footing for a control break higher in the control hierarchy is presented, specify that higher control break on the&lt;code&gt;RESET&lt;/code&gt;option.</source>
          <target state="translated">但是，如果仅在显示控件层次结构中较高的控件中断的控件基础时才希望重置 &lt;code&gt;SUM&lt;/code&gt; 计数器，请在 &lt;code&gt;RESET&lt;/code&gt; 选项上指定较高的控件中断。</target>
        </trans-unit>
        <trans-unit id="2cd8cc804f2a5ff93a10ce1b74fdd3576f5a7e3f" translate="yes" xml:space="preserve">
          <source>If, on the other hand, the compiler &quot;config&quot; file you used to compile the program specified &quot;mf&quot; as the &quot;assign-clause&quot; value, then the File Locator String will be interpreted according to according to IBM COBOL rules &amp;mdash; namely, the File Locator String is expected to be of the form &quot;S-xxx&quot; or &quot;AS-xxx&quot;, in which case the &quot;xxx&quot; will be treated as the base of an environment variable name. If there is no &quot;-&quot; character in the File Locator String then the entire File Locator String will serve as the base of an environment variable name.</source>
          <target state="translated">另一方面，如果您用来编译程序的编译器&amp;ldquo; config&amp;rdquo;文件将&amp;ldquo; mf&amp;rdquo;指定为&amp;ldquo; assign-clause&amp;rdquo;值，则文件定位符字符串将根据IBM COBOL规则进行解释，即，文件定位符字符串的格式应为&amp;ldquo; S-xxx&amp;rdquo;或&amp;ldquo; AS-xxx&amp;rdquo;，在这种情况下，&amp;ldquo; xxx&amp;rdquo;将被视为环境变量名称的基础。如果文件定位符字符串中没有&amp;ldquo;-&amp;rdquo;字符，则整个文件定位符字符串将用作环境变量名称的基础。</target>
        </trans-unit>
        <trans-unit id="14a1e778d3d526022a292de2dd1ee46c48882f7a" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;AFTER ADVANCING&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;AFTER ADVANCING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2484c7b62fe9d88e48bcea28b9bbba49a4a0abff" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;FIRST&lt;/code&gt;was specified, the logical record pointer will point to the first record in the file.</source>
          <target state="translated">如果指定了 &lt;code&gt;FIRST&lt;/code&gt; ，则逻辑记录指针将指向文件中的第一条记录。</target>
        </trans-unit>
        <trans-unit id="7863a8759644caaed13a6998607dcd0f2e23acf3" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;KEY&lt;/code&gt;was specified or implied, the logical record pointer will be specified to the</source>
          <target state="translated">如果指定或暗示了 &lt;code&gt;KEY&lt;/code&gt; ，则将逻辑记录指针指定为</target>
        </trans-unit>
        <trans-unit id="1552ccf0c116c7d239331a720f9d74cec693c257" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;LAST&lt;/code&gt;was specified, the logical record pointer will point to the last record in the file.</source>
          <target state="translated">如果指定了 &lt;code&gt;LAST&lt;/code&gt; ，则逻辑记录指针将指向文件中的最后一条记录。</target>
        </trans-unit>
        <trans-unit id="8278b8c8384858282c9b205d0ba2082757d20698" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;PICTURE&lt;/code&gt;9 and contains&lt;code&gt;S&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;PICTURE&lt;/code&gt; 9包含 &lt;code&gt;S&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8061e9cae2be0636e69237bf17be3f7098f0542a" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;PICTURE&lt;/code&gt;contains&lt;code&gt;S&lt;/code&gt;</source>
          <target state="translated">If&lt;code&gt;PICTURE&lt;/code&gt;contains&lt;code&gt;S&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9cd6edca65a7476c700085fccd1713df6568c8bd" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;n&lt;/code&gt;represents the level number of the object, then no other data items with a level number numerically less than&lt;code&gt;n&lt;/code&gt;may be defined between the subject and object data items.</source>
          <target state="translated">如果 &lt;code&gt;n&lt;/code&gt; 表示对象的级别号，则在对象和对象数据项之间不能定义级别数字小于 &lt;code&gt;n&lt;/code&gt; 的其他数据项。</target>
        </trans-unit>
        <trans-unit id="d3c3a4ef34b214c7901c86d04f87249a39615cfd" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;n&lt;/code&gt;represents the level number of the object, then no other data items with level number&lt;code&gt;n&lt;/code&gt;may be defined between the subject and object data items unless they too are&lt;code&gt;REDEFINES&lt;/code&gt;of the subject.</source>
          <target state="translated">如果 &lt;code&gt;n&lt;/code&gt; 表示对象的级别数，则没有与电平数量的其他数据项 &lt;code&gt;n&lt;/code&gt; 可在主体与客体的数据项之间所限定，除非他们也 &lt;code&gt;REDEFINES&lt;/code&gt; 受试者的。</target>
        </trans-unit>
        <trans-unit id="41e3512adad8c7a49c2bc5818c26857faf073355" translate="yes" xml:space="preserve">
          <source>Imagine my surprise, however, when I discovered that the use of&lt;code&gt;-fnotrunc&lt;/code&gt;switch also made a difference:</source>
          <target state="translated">但是，当我发现使用 &lt;code&gt;-fnotrunc&lt;/code&gt; 开关也有所作为时，请想象一下我的惊奇：</target>
        </trans-unit>
        <trans-unit id="ba2d2155230191737321736ab1c421252a9d474f" translate="yes" xml:space="preserve">
          <source>Imperative Statement</source>
          <target state="translated">必要性声明</target>
        </trans-unit>
        <trans-unit id="093f2fea111647ab73586789136bb3d0d4a0950c" translate="yes" xml:space="preserve">
          <source>Implementation-defined accept condition</source>
          <target state="translated">实施定义的接受条件</target>
        </trans-unit>
        <trans-unit id="3d29bb9dbd4be0c211a42d389e2c3292fd50b3aa" translate="yes" xml:space="preserve">
          <source>Implementation-defined display condition</source>
          <target state="translated">实施定义的显示条件</target>
        </trans-unit>
        <trans-unit id="3d3ffee367a47df22f0329d2161f7179c7140f49" translate="yes" xml:space="preserve">
          <source>In an attempt to correct the problem, we could qualify the reference to CITY as&lt;code&gt;MOVE 'Philadelphia' TO CITY OF MAILING-ADDRESS&lt;/code&gt;</source>
          <target state="translated">为了解决该问题，我们可以将对CITY的引用限定为将 &lt;code&gt;MOVE 'Philadelphia' TO CITY OF MAILING-ADDRESS&lt;/code&gt; 移至&amp;ldquo;邮件地址&amp;rdquo;城市</target>
        </trans-unit>
        <trans-unit id="1132a1566c2ed19e4f36c07a65dd3752e2bf4c83" translate="yes" xml:space="preserve">
          <source>In complex expressions composed of multiple operators and operands, a precedence of operation applies whereby those operations having a higher precedence are computed first before operations with a lower precedence.</source>
          <target state="translated">在由多个操作符和操作数组成的复杂表达式中,操作的优先性适用于先计算优先性较高的操作,再计算优先性较低的操作。</target>
        </trans-unit>
        <trans-unit id="67cd2a991339c0db61eccf443f46cb731b97b13e" translate="yes" xml:space="preserve">
          <source>In either instance, program &quot;A&quot; is referred to as the &amp;rsquo;</source>
          <target state="translated">在这两种情况下，程序&amp;ldquo; A&amp;rdquo;都称为&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="b68b4bcf151b57e71e554fe7952a0e73619a414f" translate="yes" xml:space="preserve">
          <source>In general, each picture symbol represents either a single character in storage or a single decimal digit. There are a few exceptions, and they will be discussed as needed.</source>
          <target state="translated">一般来说,每个图片符号代表存储中的一个字符或一个十进制数字。有少数例外,将根据需要进行讨论。</target>
        </trans-unit>
        <trans-unit id="2411df7c12420101004e143cb3943a4101a56bf7" translate="yes" xml:space="preserve">
          <source>In general, table references such as example #1 (constant subscript) generate the smallest, simplest and fastest object code while table references such as example #2 (numeric data item subscript) generate the largest, most-complicated and slowest object code.</source>
          <target state="translated">一般来说,表引用如例#1(常量下标)产生的对象代码最小、最简单、最快,而表引用如例#2(数值数据项下标)产生的对象代码最大、最复杂、最慢。</target>
        </trans-unit>
        <trans-unit id="9f3d74011ccc810b1770ab4e3dfbc7f8f1fdf305" translate="yes" xml:space="preserve">
          <source>In highest to lowest order of precedence, here is a discussion of each category of operation:</source>
          <target state="translated">按照从高到低的顺序,以下是对每一类行动的讨论。</target>
        </trans-unit>
        <trans-unit id="37e03fd035bc729f5e1bac261783ab6dc96b9a08" translate="yes" xml:space="preserve">
          <source>In order for &amp;lt;</source>
          <target state="translated">为了&amp;lt;</target>
        </trans-unit>
        <trans-unit id="6bb3bbadc2d27138c4c9dae5d396fb6f7ddc8694" translate="yes" xml:space="preserve">
          <source>In order for a &amp;lt;</source>
          <target state="translated">为了&amp;lt;</target>
        </trans-unit>
        <trans-unit id="36616f50c54eeaba783ad05be353c37e7580b497" translate="yes" xml:space="preserve">
          <source>In order for this clause to take effect at execution time, the user must move the cursor into the field having this clause in its definition.</source>
          <target state="translated">为了使这个子句在执行时生效,用户必须将光标移动到有这个子句定义的字段中。</target>
        </trans-unit>
        <trans-unit id="d4cc191768c1993e9df309f3f21d935b4723ece5" translate="yes" xml:space="preserve">
          <source>In order for this statement to be functional, tracing code must have been generated into the compiled program using either the&lt;code&gt;-ftrace&lt;/code&gt;switch</source>
          <target state="translated">为了使该语句起作用，必须使用 &lt;code&gt;-ftrace&lt;/code&gt; 开关将跟踪代码生成到已编译的程序中</target>
        </trans-unit>
        <trans-unit id="d5716d69487d7213f5a154886aec1d579f1359df" translate="yes" xml:space="preserve">
          <source>In order for&lt;code&gt;AND&lt;/code&gt;</source>
          <target state="translated">为了 &lt;code&gt;AND&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12840b41d70472b409489727335424ef0070e853" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;rsquo;curses&amp;rsquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;rsquo;PDCurses&amp;rsquo; package (used for native Windows or MinGW builds) does not support&lt;code&gt;EMPTY-CHECK&lt;/code&gt;</source>
          <target state="translated">为了发挥作用，必须使用构建GnuCOBOL实现的基础&amp;ldquo; curses&amp;rdquo;包支持此属性。截至目前，&amp;ldquo; PDCurses&amp;rdquo;软件包（用于本机Windows或MinGW构建）不支持 &lt;code&gt;EMPTY-CHECK&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17d285867c49f9dd90eb1f27cf9c7a60d1e38df8" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;rsquo;curses&amp;rsquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;rsquo;PDCurses&amp;rsquo; package (used for native Windows or MinGW builds) does not support&lt;code&gt;FULL&lt;/code&gt;</source>
          <target state="translated">为了发挥作用，必须使用构建GnuCOBOL实现的基础&amp;ldquo; curses&amp;rdquo;包支持此属性。截至目前，&amp;ldquo; PDCurses&amp;rdquo;软件包（用于本机Windows或MinGW构建）不支持 &lt;code&gt;FULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0a81aca05eb7b3e3ebeefcb93bfd42b8a77e381a" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;rsquo;curses&amp;rsquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;rsquo;PDCurses&amp;rsquo; package (used for native Windows or MinGW builds) does not support&lt;code&gt;LENGTH-CHECK&lt;/code&gt;</source>
          <target state="translated">为了发挥作用，必须使用构建GnuCOBOL实现的基础&amp;ldquo; curses&amp;rdquo;包支持此属性。截至目前，&amp;ldquo; PDCurses&amp;rdquo;软件包（用于本机Windows或MinGW构建）不支持 &lt;code&gt;LENGTH-CHECK&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="de32275ede835ac63170073ab2d665b3951078da" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;rsquo;curses&amp;rsquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;rsquo;PDCurses&amp;rsquo; package (used for native Windows or MinGW builds) does not support&lt;code&gt;REQUIRED&lt;/code&gt;</source>
          <target state="translated">为了发挥作用，必须使用构建GnuCOBOL实现的基础&amp;ldquo; curses&amp;rdquo;包支持此属性。截至目前，&amp;ldquo; PDCurses&amp;rdquo;软件包（用于本机Windows或MinGW构建）不支持 &lt;code&gt;REQUIRED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8ea48fcaef90024e13873585a7560dd9b545d9d4" translate="yes" xml:space="preserve">
          <source>In order to take effect, the user must first move the cursor into the field having this clause in its definition.</source>
          <target state="translated">为了生效,用户必须首先将光标移动到定义中有该子句的字段中。</target>
        </trans-unit>
        <trans-unit id="c1ff1f707da403375eb5aac3df8097ce50066a1d" translate="yes" xml:space="preserve">
          <source>In the above examples, a comma is used as a separator character between the two subscript values; semicolons &lt;code&gt;;&lt;/code&gt; are also valid subscript separator characters, as are spaces! The use of a comma or semicolon separator in such a situation is technically optional, but by convention most COBOL programmers use one or the other. The use of no separator character (other than a space) is not recommended, even though it is syntactically correct, as this practice can lead to programmer-unfriendly code. It isn&amp;rsquo;t too difficult to read and understand&lt;code&gt;GRID-CHARACTER(2 3)&lt;/code&gt; but it&amp;rsquo;s another story entirely when trying to comprehend&lt;code&gt;GRID-CHARACTER(I + 1 J / 3)&lt;/code&gt;(instead of&lt;code&gt;GRID-CHARACTER(I + 1, J / 3)&lt;/code&gt;. The compiler accepts it, but too much of this would make</source>
          <target state="translated">在上面的示例中，逗号用作两个下标值之间的分隔符；分号 &lt;code&gt;;&lt;/code&gt; 也是有效的下标分隔符，空格也是！在这种情况下，使用逗号或分号分隔符在技术上是可选的，但按照惯例，大多数COBOL程序员都使用一种或另一种。即使在语法上正确，也不建议使用无分隔符（空格除外），因为这种做法会导致程序员不友好的代码。阅读和理解 &lt;code&gt;GRID-CHARACTER(2 3)&lt;/code&gt; 并不是很困难，但是当试图理解 &lt;code&gt;GRID-CHARACTER(I + 1 J / 3)&lt;/code&gt; （而不是 &lt;code&gt;GRID-CHARACTER(I + 1, J / 3)&lt;/code&gt; 。编译器接受它，但是这样做太多会使</target>
        </trans-unit>
        <trans-unit id="ab0a8c97ecdd65110e9781dbe9e9bcdabaa33882" translate="yes" xml:space="preserve">
          <source>In the absence of the&lt;code&gt;OVERRIDE&lt;/code&gt;</source>
          <target state="translated">在没有 &lt;code&gt;OVERRIDE&lt;/code&gt; 的情况下</target>
        </trans-unit>
        <trans-unit id="be9ad81756c2c029daadb7f85dc6de13011d4872" translate="yes" xml:space="preserve">
          <source>In the case of the former, the&lt;code&gt;USING&lt;/code&gt;clause on the procedure division header should describe the argument via the&lt;code&gt;BY REFERENCE&lt;/code&gt;</source>
          <target state="translated">在前者的情况下，过程除标头上的 &lt;code&gt;USING&lt;/code&gt; 子句应通过 &lt;code&gt;BY REFERENCE&lt;/code&gt; 描述自变量</target>
        </trans-unit>
        <trans-unit id="3683f2272e68eee3328548bbf75c6cbed2e45e7d" translate="yes" xml:space="preserve">
          <source>In the late 70&amp;rsquo;s cards was also on its way out to the point where P.C&amp;rsquo;s started being used (and no they were not made by IBM), so these columns could be used for other purposes including cc 73 - 80 instead of indicating the 8 character program name which was the maximum size allowed on a IBM system.</source>
          <target state="translated">在70年代后期，显示卡也即将使用到开始使用PC的地步（而且它们不是IBM制造的），因此这些列可用于其他用途，包括cc 73-80，而不是指示8个字符的程序名称，这是IBM系统上允许的最大大小。</target>
        </trans-unit>
        <trans-unit id="82849a227b43e92353f440e6cf481dde7d3eb800" translate="yes" xml:space="preserve">
          <source>In this case, the&lt;code&gt;EXIT&lt;/code&gt;statement takes no other run-time action.</source>
          <target state="translated">在这种情况下， &lt;code&gt;EXIT&lt;/code&gt; 语句不执行其他任何运行时操作。</target>
        </trans-unit>
        <trans-unit id="2a9d1dc97c6798126e8a06dda35c75cc92d21220" translate="yes" xml:space="preserve">
          <source>In this context,&lt;code&gt;VALUE&lt;/code&gt;specifies an initial compilation-time value that will be assigned to the storage occupied by the data item in the program object code generated by the compiler.</source>
          <target state="translated">在这种情况下， &lt;code&gt;VALUE&lt;/code&gt; 指定初始编译时值，该值将分配给编译器生成的程序目标代码中数据项所占用的存储。</target>
        </trans-unit>
        <trans-unit id="84cb1e4aa0b378b3db93b48860594751f6ae285f" translate="yes" xml:space="preserve">
          <source>In this example, all six&lt;code&gt;A&lt;/code&gt;items will be initialized to &quot;?&quot;, all six&lt;code&gt;B&lt;/code&gt;items will be initialized to &quot;%&quot; and all six&lt;code&gt;N&lt;/code&gt;items will be initialized to 10. It&amp;rsquo;s not clear exactly how many times this sort of initialization will be useful, but it&amp;rsquo;s there if you need it.</source>
          <target state="translated">在此示例中，所有六个 &lt;code&gt;A&lt;/code&gt; 项目将被初始化为&amp;ldquo;？&amp;rdquo;，所有六个 &lt;code&gt;B&lt;/code&gt; 项目将被初始化为&amp;ldquo;％&amp;rdquo;，所有六个 &lt;code&gt;N&lt;/code&gt; 项目将被初始化为10。目前尚不清楚这种初始化将执行多少次。很有用，但是如果您需要它，它就在那里。</target>
        </trans-unit>
        <trans-unit id="2879e2f56bb5d870554e86f04a4bf9ebe7fb4ed9" translate="yes" xml:space="preserve">
          <source>In this example, the IF statement actually has a scope that can include two sets of associated statements &amp;ndash; one set to be executed when the&lt;code&gt;IF&lt;/code&gt;(see &lt;a href=&quot;#IF&quot;&gt;IF&lt;/a&gt;) condition is TRUE and another if it is FALSE.</source>
          <target state="translated">在此示例中，IF语句实际上具有一个范围，该范围可以包括两组关联的语句-一组在 &lt;code&gt;IF&lt;/code&gt; （请参阅&lt;a href=&quot;#IF&quot;&gt;IF&lt;/a&gt;）条件为TRUE 时执行，而另一组在FALSE时执行。</target>
        </trans-unit>
        <trans-unit id="b671b6f79a2badfb5c4ccb993eb5f1ff2485bd4c" translate="yes" xml:space="preserve">
          <source>In which case 9 characters of storage will be reserved. The values 000000000 through 999999999 will represent the gross-revenues. But, if only the millions are tracked (meaning the last six digits are always going to be 0), you could define the field as:</source>
          <target state="translated">在这种情况下,将保留9个字符的存储空间。000000000到99999999的数值将代表总收入。但是,如果只跟踪百万收入(意味着最后六位数字永远是0),您可以将该字段定义为。</target>
        </trans-unit>
        <trans-unit id="6178a2fcb450efe4624273996659b2d5392d26b6" translate="yes" xml:space="preserve">
          <source>Include the reserved word&lt;code&gt;FINAL&lt;/code&gt;</source>
          <target state="translated">包括保留字 &lt;code&gt;FINAL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4587868819f3914fb0d960b2a017af52903b843c" translate="yes" xml:space="preserve">
          <source>Including an&lt;code&gt;ON SIZE ERROR&lt;/code&gt;clause on an arithmetic statement will allow your program to trap a failure of an arithmetic statement (either generating a result too large for the receiving field, or attempting to divide by zero) and handle it gracefully by executing &amp;lt;</source>
          <target state="translated">在算术语句上包含 &lt;code&gt;ON SIZE ERROR&lt;/code&gt; 子句将使您的程序能够捕获算术语句的失败（或者为接收字段生成太大的结果，或者尝试除以零）并通过执行&amp;lt;</target>
        </trans-unit>
        <trans-unit id="2ec9e5e5288405f63d74272e4e8bcad544b64e15" translate="yes" xml:space="preserve">
          <source>Incompatible data exception</source>
          <target state="translated">不兼容的数据异常</target>
        </trans-unit>
        <trans-unit id="e0049c7018b06d02f3c0ba2245a0ee83c74d7cc7" translate="yes" xml:space="preserve">
          <source>Inconsistent filename</source>
          <target state="translated">文件名不一致</target>
        </trans-unit>
        <trans-unit id="e5d727021f58d38c370cf7243256d9dff80ee53f" translate="yes" xml:space="preserve">
          <source>Independent Subprograms</source>
          <target state="translated">独立次级方案</target>
        </trans-unit>
        <trans-unit id="0e0834dadd433c69c101f415ef11e7aef2f4805a" translate="yes" xml:space="preserve">
          <source>Indexed files are processed using the following statements:</source>
          <target state="translated">索引文件使用以下语句进行处理。</target>
        </trans-unit>
        <trans-unit id="9353f9003cee9268ec86b3a1ea7f4d4ecb16eb1c" translate="yes" xml:space="preserve">
          <source>Indexing is the process of referencing an element of a table utilizing a data item with an explicitly or implicitly defined&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of&lt;code&gt;INDEX&lt;/code&gt;to select the desired occurrence, while &amp;hellip;</source>
          <target state="translated">索引是使用数据项引用表元素的过程，该数据项具有 &lt;code&gt;INDEX&lt;/code&gt; 的显式或隐式定义的 &lt;code&gt;USAGE&lt;/code&gt; （请参阅&lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;）来选择所需的出现，而&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="a6c6b82216692a3106690069e47ca45a2e70d92d" translate="yes" xml:space="preserve">
          <source>Initialize small tables at compile time by including a&lt;code&gt;VALUE&lt;/code&gt;clause on the group item that serves as a parent to the table, as follows:</source>
          <target state="translated">通过在作为表父级的组项中包含 &lt;code&gt;VALUE&lt;/code&gt; 子句，在编译时初始化小表，如下所示：</target>
        </trans-unit>
        <trans-unit id="24b3196c683087c1c3199428c0580a1c1d58213b" translate="yes" xml:space="preserve">
          <source>Initialize tables of almost any size at compilation time by utilizing the&lt;code&gt;REDEFINES&lt;/code&gt;(see &lt;a href=&quot;#REDEFINES&quot;&gt;REDEFINES&lt;/a&gt;) clause:</source>
          <target state="translated">利用 &lt;code&gt;REDEFINES&lt;/code&gt; （请参阅&lt;a href=&quot;#REDEFINES&quot;&gt;REDEFINES&lt;/a&gt;）子句在编译时初始化几乎任何大小的表：</target>
        </trans-unit>
        <trans-unit id="2fec9ecf2a45eb0fd0af8f70fdb0cee7e4377f3b" translate="yes" xml:space="preserve">
          <source>Inline PERFORM Syntax</source>
          <target state="translated">内联PERFORM语法</target>
        </trans-unit>
        <trans-unit id="bc36d8128c5a1e8ca8d8c4f2854d174a361c1c90" translate="yes" xml:space="preserve">
          <source>Input fields may have any character used as a fill character. These fill characters provide a visual indication of the size of the input field, and will automatically be transformed into spaces when the input field is processed by the program. If no such character is defined for an input field, an underscore (&quot;_&quot;) will be assumed.</source>
          <target state="translated">输入字段可以使用任何字符作为填充字符。这些填充字符提供了输入字段大小的视觉指示,并将在程序处理输入字段时自动转化为空格。如果没有为输入字段定义这样的字符,将假定为下划线(&quot;_&quot;)。</target>
        </trans-unit>
        <trans-unit id="d4fe42447823ec3b9e2e9421bf9fdef259cf35f1" translate="yes" xml:space="preserve">
          <source>Input will be read either from the console window &lt;code&gt;CONSOLE&lt;/code&gt; or from the system-standard input (pipe 0 =&lt;code&gt;STDIN&lt;/code&gt;&lt;code&gt;SYSIN&lt;/code&gt;or&lt;code&gt;SYSIPT&lt;/code&gt; and will be saved in &amp;lt;</source>
          <target state="translated">输入将从控制台窗口 &lt;code&gt;CONSOLE&lt;/code&gt; 或系统标准输入中读取（管道0 = &lt;code&gt;STDIN&lt;/code&gt; &lt;code&gt;SYSIN&lt;/code&gt; 或 &lt;code&gt;SYSIPT&lt;/code&gt; ，并将其保存在&amp;lt;</target>
        </trans-unit>
        <trans-unit id="11b11dadbac78c35efb5d86e561bfcff60c6701b" translate="yes" xml:space="preserve">
          <source>Integer and non-integer operands may be freely intermixed</source>
          <target state="translated">整数操作数和非整数操作数可以自由混合。</target>
        </trans-unit>
        <trans-unit id="8626f5223c37139c00a44d21c18f768de6e8df20" translate="yes" xml:space="preserve">
          <source>Integers such as 1, 56, 2192 or -54.</source>
          <target state="translated">整数,如1、56、2192或-54。</target>
        </trans-unit>
        <trans-unit id="d47bc2c05ec93f214d2f93848b03eba3a04ff0c4" translate="yes" xml:space="preserve">
          <source>Integrating well with non-COBOL infrastructures such as XML, SOA, MQ, almost any DBMS, Transaction Processing platforms, Queue-Management facilities and other programming languages.</source>
          <target state="translated">与非COBOL基础架构,如XML、SOA、MQ、几乎所有的DBMS、事务处理平台、队列管理设施和其他编程语言很好的集成。</target>
        </trans-unit>
        <trans-unit id="8b3eb3d9c05dbc205b027a6d0771b0af833c1b89" translate="yes" xml:space="preserve">
          <source>Interactions between the program and the user will take place using the standard input, standard output and standard error streams. Any screen section I/O performed by the program will take place within the command shell &quot;window&quot;.</source>
          <target state="translated">程序和用户之间的交互将使用标准输入、标准输出和标准错误流进行。程序执行的任何屏幕部分I/O将在命令壳 &quot;窗口 &quot;内进行。</target>
        </trans-unit>
        <trans-unit id="4004bbedc882730cd7377c55c8a60c3d77d841f3" translate="yes" xml:space="preserve">
          <source>Intrinsic Function</source>
          <target state="translated">本质功能</target>
        </trans-unit>
        <trans-unit id="3afb87dd54b38fa7410a22ca94bf84568bc6f936" translate="yes" xml:space="preserve">
          <source>Is there a data item named&lt;code&gt;C-D&lt;/code&gt;defined? If so, use its value for the character sequence&lt;code&gt;C-D&lt;/code&gt;</source>
          <target state="translated">是否定义了名为 &lt;code&gt;C-D&lt;/code&gt; 的数据项？如果是这样，请将其值用于字符序列 &lt;code&gt;C-D&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b2a3023db707fff296813396a984d683cabd59f0" translate="yes" xml:space="preserve">
          <source>It is also possible to create source files where GnuCOBOL programs are nested inside each other. Take for example these four GnuCOBOL programs:</source>
          <target state="translated">也可以创建GnuCOBOL程序相互嵌套的源文件。以这四个GnuCOBOL程序为例。</target>
        </trans-unit>
        <trans-unit id="84300e8f98a0f3852c30d9579e7c60614ed0dbd3" translate="yes" xml:space="preserve">
          <source>It is expected that:</source>
          <target state="translated">预计:</target>
        </trans-unit>
        <trans-unit id="6c528e93ea46610dc90b04c262c6d8a0c4d80f39" translate="yes" xml:space="preserve">
          <source>It is possible to generate executable modules for all GnuCOBOL programs, not just subprograms, by choosing to use the&lt;code&gt;-m&lt;/code&gt;switch</source>
          <target state="translated">通过选择使用 &lt;code&gt;-m&lt;/code&gt; 开关，可以为所有GnuCOBOL程序（不仅仅是子程序）生成可执行模块。</target>
        </trans-unit>
        <trans-unit id="fd71df406ad79246a83a283db27a4507793dc703" translate="yes" xml:space="preserve">
          <source>It is possible, however, to automatically cause all library names to &amp;rsquo;fold&amp;rsquo; to upper-case by specifying the&lt;code&gt;-ffold-call&lt;/code&gt;switch</source>
          <target state="translated">但是，可以通过指定 &lt;code&gt;-ffold-call&lt;/code&gt; 开关自动使所有库名&amp;ldquo;折叠&amp;rdquo;为大写</target>
        </trans-unit>
        <trans-unit id="0f5ff5b5b0cc8eb3a5f026f5c68c2c34d3dd2e58" translate="yes" xml:space="preserve">
          <source>It is possible, however, to automatically cause all&lt;code&gt;COPY&lt;/code&gt;statements to &amp;rsquo;fold&amp;rsquo; the names of all copybooks to upper-case by specifying the&lt;code&gt;-ffold-copy&lt;/code&gt;switch</source>
          <target state="translated">但是，可以通过指定 &lt;code&gt;-ffold-copy&lt;/code&gt; 开关自动使所有 &lt;code&gt;COPY&lt;/code&gt; 语句将所有副本的名称&amp;ldquo;折叠&amp;rdquo;为大写。</target>
        </trans-unit>
        <trans-unit id="8d95a0b3b4408000436885116c035d2b4d4eb090" translate="yes" xml:space="preserve">
          <source>It is possible, if supported by the &quot;curses&quot; package being used, to draw borders on the top, left and/or bottom edges of a field.</source>
          <target state="translated">如果使用的 &quot;curses &quot;包支持,可以在字段的顶部、左侧和/或底部边缘绘制边框。</target>
        </trans-unit>
        <trans-unit id="7d7394694e1e1adbaef5eeee92d5a9373e538bc3" translate="yes" xml:space="preserve">
          <source>It is recommended to change the CBL_OC routines to CBL_GC for forward compatability as at some point they will be removed as they are a hangover from Open Cobol.</source>
          <target state="translated">建议将CBL_OC例程改为CBL_GC,以便向前兼容,因为在某些时候它们会被删除,因为它们是Open Cobol的遗留问题。</target>
        </trans-unit>
        <trans-unit id="4bc4bb06183a156efac27d1054572b8c27c65421" translate="yes" xml:space="preserve">
          <source>It is worth mentioning that if the</source>
          <target state="translated">值得一提的是,如果</target>
        </trans-unit>
        <trans-unit id="18a80c8fa72d80aad7d81f986d63eacc53ab4b98" translate="yes" xml:space="preserve">
          <source>It would appear that it should be possible to locate and process any record in the file directly simply by calculating its starting character position based upon the program-defined record size. Even so, however, records must be still be read or written to these files in a purely sequential manner. The only way to read (or write) record number 100 would be to have read (or written) records number 1 through 99 first.</source>
          <target state="translated">看来,只要根据程序定义的记录大小计算其起始字符位置,就可以直接找到并处理文件中的任何记录。然而,即使如此,记录仍然必须以纯粹的顺序方式被读取或写入这些文件。读取(或写入)100号记录的唯一方法是先读取(或写入)1到99号记录。</target>
        </trans-unit>
        <trans-unit id="6d1a9ad994fd74f3ea9c0abfcfff5c67eb069908" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s impossible to perform any arithmetic operation against an index data item directly (other than a simple incrementation or decremental operation via the&lt;code&gt;SET UP/DOWN&lt;/code&gt;statement (see &lt;a href=&quot;#SET-UP_002fDOWN&quot;&gt;SET UP/DOWN&lt;/a&gt;)). Situations where any non-trivial computations are required to calculate the effective occurrence number for a table reference will require you to use a conventional unedited numeric data item as the receiving field for the calculation. That calculated value would then need to be saved into the index data item via a&lt;code&gt;SET Index&lt;/code&gt;statement.</source>
          <target state="translated">无法直接对索引数据项执行任何算术运算（除了通过 &lt;code&gt;SET UP/DOWN&lt;/code&gt; 语句进行简单的递增或递减运算（请参阅&lt;a href=&quot;#SET-UP_002fDOWN&quot;&gt;SET UP / DOWN&lt;/a&gt;））。在需要任何非平凡的计算来计算表引用的有效出现次数的情况下，您将需要使用常规的未经编辑的数值数据项作为计算的接收字段。然后，需要通过 &lt;code&gt;SET Index&lt;/code&gt; 语句将该计算值保存到索引数据项中。</target>
        </trans-unit>
        <trans-unit id="48149098c4b72f980cb6ef484a18559b6952ecbd" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s probably a true that an IT professional can no longer afford to allow COBOL to be the</source>
          <target state="translated">IT专业人员再也负担不起让COBOL成为</target>
        </trans-unit>
        <trans-unit id="02387685edacc74ddafb8999ab4d02ea233cee8c" translate="yes" xml:space="preserve">
          <source>Items appearing in Mixed Case within a syntax diagram represent complex clauses of other syntax elements that may appear in that position. Some COBOL syntax gets quite complicated, and using a convention such as this significantly reduces the complexity of a syntax diagram. When such items are referenced in text, they will appear as &amp;lt;&amp;lt;</source>
          <target state="translated">语法图中出现在&amp;ldquo;混合大小写&amp;rdquo;中的项目表示可能出现在该位置的其他语法元素的复杂子句。一些COBOL语法变得相当复杂，并且使用这样的约定可以大大降低语法图的复杂性。在文本中引用此类项目时，它们将显示为&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="56625773bdd51fd820fa786a2e0f16b75e88d894" translate="yes" xml:space="preserve">
          <source>JUST, JUSTIFIED</source>
          <target state="translated">公正、合理</target>
        </trans-unit>
        <trans-unit id="362a2940964523b043977ef5c326c0da3c417c71" translate="yes" xml:space="preserve">
          <source>JUSTIFIED Attribute Syntax</source>
          <target state="translated">JUSTIFIED属性 语法</target>
        </trans-unit>
        <trans-unit id="69d7203c7ddac97c0f7dbb23cc2fe036c4f8c92f" translate="yes" xml:space="preserve">
          <source>Just as multiplication takes precedence over addition in arithmetic expressions, so does&lt;code&gt;AND&lt;/code&gt;take precedence over&lt;code&gt;OR&lt;/code&gt;in combined conditions. Use parenthesis to change this precedence, if necessary. For example:</source>
          <target state="translated">正如在算术表达式中乘法优先于加法一样 &lt;code&gt;AND&lt;/code&gt; 在组合条件下AND优先于 &lt;code&gt;OR&lt;/code&gt; 。如有必要，请使用括号更改此优先级。例如：</target>
        </trans-unit>
        <trans-unit id="7d13eab767d2368877889bd7045a0a16db421d69" translate="yes" xml:space="preserve">
          <source>Just because COBOL doesn&amp;rsquo;t traditionally support objects, classes, and the like doesn&amp;rsquo;t mean that its &quot;procedural&quot; approach to computing isn&amp;rsquo;t valuable &amp;mdash; after all, it runs 70% of the</source>
          <target state="translated">仅仅因为COBOL传统上不支持对象，类等并不意味着它的&amp;ldquo;过程式&amp;rdquo;计算方法就没有价值-毕竟，它运行了70％的</target>
        </trans-unit>
        <trans-unit id="eab1ffaceb7e528d02f388bc4a44de1ac999f956" translate="yes" xml:space="preserve">
          <source>Just because the table has one or more&lt;code&gt;KEY&lt;/code&gt;clauses doesn&amp;rsquo;t mean the data is actually</source>
          <target state="translated">仅仅因为表具有一个或多个 &lt;code&gt;KEY&lt;/code&gt; 子句并不意味着数据实际上是</target>
        </trans-unit>
        <trans-unit id="c2d43141ba675c34b7c1d27c2a20a48306114ad6" translate="yes" xml:space="preserve">
          <source>Justifying a field left-, right- or center-aligned</source>
          <target state="translated">证明一个字段左、右或中间对齐的合理性</target>
        </trans-unit>
        <trans-unit id="84f38d3f20c7775e2217cde20dd53b4fca4c4de9" translate="yes" xml:space="preserve">
          <source>KEPT, KEY, KEYBOARD</source>
          <target state="translated">保持,钥匙,键盘。</target>
        </trans-unit>
        <trans-unit id="a1abb8bae6a20d6d2a3d297fadb85dbb06f153f7" translate="yes" xml:space="preserve">
          <source>Key invalid</source>
          <target state="translated">钥匙无效</target>
        </trans-unit>
        <trans-unit id="0dca24f2a9944795f9d4824194f21fc80ddaa094" translate="yes" xml:space="preserve">
          <source>Key not found</source>
          <target state="translated">未找到钥匙</target>
        </trans-unit>
        <trans-unit id="b27d585a06f48010c011f378dec6cda9ce6fe385" translate="yes" xml:space="preserve">
          <source>LABEL. LAST, LC_ALL, LC_COLLATE, LC_CTYPE, LC_MESSAGES, LC_MONETARY, LC_NUMERIC, LC_TIME, LEADING, LEFT, LEFT-JUSTIFY, LEFTLINE, LENGTH, LENGTH-AN, LENGTH-CHECK, LESS, LIMIT, LIMITS, LINAGE, LINAGE-COUNTER, LINE, LINE-COUNTER, LINES, LINKAGE, LOCALE, LOCALE-COMPARE, LOCALE-DATE, LOCALE-TIME, LOCALE-TIME-FROM-SECONDS, LOCAL-STORAGE, LOCK, LOG, LOG10, LOWER, LOWER-CASE, LOWEST-ALGEBRAIC, LOWLIGHT, LOW-VALUE, LOW-VALUES</source>
          <target state="translated">标签:LAST,LC_ALL,LC_COLLATE,LC_CTYPE,LC_MESSAGES,LC_MONETARY,LC_NUMERIC,LC_TIME,LEADING,LEFT,LEFT-JUSTIFY,LEFTLINE,LENGTH,LENGTH-AN,LENGTH-CHECK,LESS,LIMIT,LIMITS,LINAGE,LINAGE-COUNTER,LINE,LINE-COUNTER,LINES,LINKAGE,LOCALE,LOCALE-COMPARE,LOCALE-DATE,LOCALE-TIME,LOCALE-TIME-ROM-SECONDS,LOCAL-STORAGE,LOCK,LOG,LOG10,LOWER,LOWER-CASE,LOWEST-ALGEBRAIC,LOWLIGHT,LOW-VALUE,LOW-VALUES。</target>
        </trans-unit>
        <trans-unit id="f7adab25c99ba32828c8334645ed0e592317c0dd" translate="yes" xml:space="preserve">
          <source>LEFTLINE Attribute Syntax</source>
          <target state="translated">LEFTLINE 属性 语法</target>
        </trans-unit>
        <trans-unit id="131342f51da66f70ac3d8ad3a42ad6266e7cfe09" translate="yes" xml:space="preserve">
          <source>LENGTH Function Syntax</source>
          <target state="translated">LENGTH 函数语法</target>
        </trans-unit>
        <trans-unit id="d74d405b72ac688357a94ddb91f3bd1d36b38a48" translate="yes" xml:space="preserve">
          <source>LENGTH OF Syntax</source>
          <target state="translated">语法长度</target>
        </trans-unit>
        <trans-unit id="a6c3bbbb104612f77a62807c2c1de5109220484e" translate="yes" xml:space="preserve">
          <source>LENGTH-AN Function Syntax</source>
          <target state="translated">LENGTH-AN 函数语法</target>
        </trans-unit>
        <trans-unit id="954f779688b59664bc2c0157a1a346f68764ce28" translate="yes" xml:space="preserve">
          <source>LENGTH-CHECK Attribute Syntax</source>
          <target state="translated">LENGTH-CHECK 属性 语法</target>
        </trans-unit>
        <trans-unit id="700c1989f8b190ed7e6537ef207d774a560d050f" translate="yes" xml:space="preserve">
          <source>LINE (REPORT SECTION) Clause Syntax</source>
          <target state="translated">行(报告部分)子句语法</target>
        </trans-unit>
        <trans-unit id="e8f4389c48575a281e9f925b390e924cf0c4233d" translate="yes" xml:space="preserve">
          <source>LINE (SCREEN SECTION) Clause Syntax</source>
          <target state="translated">行(屏幕部分)子句语法</target>
        </trans-unit>
        <trans-unit id="e4f2ff384d74fc8578647b7045a783150209d9b6" translate="yes" xml:space="preserve">
          <source>LINKAGE-SECTION-Data-Item</source>
          <target state="translated">LINKAGE-SECTION-Data-Item</target>
        </trans-unit>
        <trans-unit id="6c615d91fc665579223c013c286410416b6e1014" translate="yes" xml:space="preserve">
          <source>LINKAGE-SECTION-Data-Item Syntax</source>
          <target state="translated">链接-部分-数据-项目 语法</target>
        </trans-unit>
        <trans-unit id="de80fa7cc22fe7bc720ec1f880b19a375e416fad" translate="yes" xml:space="preserve">
          <source>LOCAL-STORAGE-SECTION-Data-Item</source>
          <target state="translated">LOCAL-STORAGE-SECTION-Data-Item</target>
        </trans-unit>
        <trans-unit id="7aaab284fb19784decbd8f8b27788cee676e6312" translate="yes" xml:space="preserve">
          <source>LOCAL-STORAGE-SECTION-Data-Item Syntax</source>
          <target state="translated">LOCAL-STORAGE-SECTION-Data-Item 语法</target>
        </trans-unit>
        <trans-unit id="43137ffee30418f0ee2f9cddfdfde852be8ee37f" translate="yes" xml:space="preserve">
          <source>LOCALE-COMPARE Function Syntax</source>
          <target state="translated">LOCALE-COMPARE 函数语法</target>
        </trans-unit>
        <trans-unit id="b1fca96794478203376fc5f182a5206a1cd9879a" translate="yes" xml:space="preserve">
          <source>LOCALE-DATE Function Syntax</source>
          <target state="translated">LOCALE-DATE 函数语法</target>
        </trans-unit>
        <trans-unit id="bb3ee280b5397e14e50725a5217c3a5d3ba477ce" translate="yes" xml:space="preserve">
          <source>LOCALE-TIME Function Syntax</source>
          <target state="translated">LOCALE-TIME 函数语法</target>
        </trans-unit>
        <trans-unit id="5471c4a61062a5428ab007db0990af8c067fcb5d" translate="yes" xml:space="preserve">
          <source>LOCALE-TIME-FROM-SECONDS Function Syntax</source>
          <target state="translated">LOCALE-TIME-FROM-SECONDS 函数语法</target>
        </trans-unit>
        <trans-unit id="37c5bf8af77ce9710567f4d33ea9e7df839040cc" translate="yes" xml:space="preserve">
          <source>LOG Function Syntax</source>
          <target state="translated">LOG 功能描述</target>
        </trans-unit>
        <trans-unit id="9192c8decf1f9c720375df3f6fa03e112ff20e88" translate="yes" xml:space="preserve">
          <source>LOG10 Function Syntax</source>
          <target state="translated">LOG10 功能语法</target>
        </trans-unit>
        <trans-unit id="ee7e6e2ad53ef8f056736d307514898fdd404c69" translate="yes" xml:space="preserve">
          <source>LOWER-CASE Function Syntax</source>
          <target state="translated">LOWER-CASE 函数语法</target>
        </trans-unit>
        <trans-unit id="439e85988349d2d4d56bcd162fc79031cbfe5293" translate="yes" xml:space="preserve">
          <source>LOWEST-ALGEBRAIC Function Syntax</source>
          <target state="translated">LOWEST-ALGEBRAIC 函数语法</target>
        </trans-unit>
        <trans-unit id="a8456caa490bee9c2c0be989a83696a4f186cc13" translate="yes" xml:space="preserve">
          <source>LOWLIGHT Attribute Syntax</source>
          <target state="translated">LOWLIGHT 属性语法</target>
        </trans-unit>
        <trans-unit id="b77f5ed95a31f852095a500e8931cb13a5b9471b" translate="yes" xml:space="preserve">
          <source>Language DIVISION, SECTION and paragraph section headers must begin in Area A, as must the level numbers 01, 77 in data description entries and the &quot;FD&quot; and &quot;SD&quot; file and SORT description headers.</source>
          <target state="translated">语文的DIVISION、SECTION和段落部分的标题必须从A区开始,数据描述条目中的等级号01、77以及 &quot;FD &quot;和 &quot;SD &quot;文件和SORT描述标题也必须如此。</target>
        </trans-unit>
        <trans-unit id="1882dc6a1967f34bbac58b9f9a979e4a9b63398b" translate="yes" xml:space="preserve">
          <source>Later, when you wish to compile a calling program and combine any needed assembly language subroutines in (as static subroutines &amp;mdash; see &lt;a href=&quot;#Dynamic-vs-Static-Subprograms&quot;&gt;Dynamic vs Static Subprograms&lt;/a&gt;), use a command such as this:</source>
          <target state="translated">以后，当您希望编译一个调用程序并在其中组合任何所需的汇编语言子例程（作为静态子例程，请参见&lt;a href=&quot;#Dynamic-vs-Static-Subprograms&quot;&gt;动态与静态子程序&lt;/a&gt;）时，请使用如下命令：</target>
        </trans-unit>
        <trans-unit id="66985c4b56238cdffd3d626011e0ae9656911e65" translate="yes" xml:space="preserve">
          <source>Leading and/or trailing spaces are allowed, as are spaces before and/or after any sign characters.</source>
          <target state="translated">允许有前导和/或尾部空格,也允许在任何符号字符之前和/或之后有空格。</target>
        </trans-unit>
        <trans-unit id="0ff8a66126e2608d00693ba8dd0efcf5b6c8473c" translate="yes" xml:space="preserve">
          <source>Leading and/or trailing spaces are allowed, as are spaces before and/or after the currency symbol, sign, CR and DB characters.</source>
          <target state="translated">允许有前导和/或尾部空格,货币符号、符号、CR和DB字符之前和/或之后也允许有空格。</target>
        </trans-unit>
        <trans-unit id="13235fcc87f3e6e8669414dd697a803db485fc34" translate="yes" xml:space="preserve">
          <source>Leading and/or trailing spaces are allowed, as are spaces before and/or after the sign, CR and DB characters.</source>
          <target state="translated">允许有前导和/或尾部空格,也允许在符号、CR和DB字符前和/或后有空格。</target>
        </trans-unit>
        <trans-unit id="6d1192545a490f725efd7534bb1ad77133927978" translate="yes" xml:space="preserve">
          <source>Legend has it that there&amp;rsquo;s actually only been ONE program ever written in COBOL, and all programs ever &quot;written&quot; thereafter were simply derivatives of that one. Although this is clearly intended as a (probably) bad joke, it is nevertheless close to the very simple truth that many programmers&quot;reuse&quot; existing COBOL programs when creating new ones. There&amp;rsquo;s certainly nothing preventing this from happening with programs written in other languages, but it does seem to happen more in COBOL shops. It&amp;rsquo;s ironic that &quot;code re-usability&quot; is one of the arguments used to justify the existence of the &quot;modern&quot; languages.</source>
          <target state="translated">传说它实际上只有一个用COBOL编写的程序，此后所有&amp;ldquo;编写&amp;rdquo;的程序仅仅是该程序的派生。尽管这显然是一个（可能）恶作剧，但它非常接近一个非常简单的事实，即许多程序员在创建新程序时会&amp;ldquo;重用&amp;rdquo;现有的COBOL程序。用其他语言编写的程序当然不能阻止这种情况的发生，但是在COBOL商店中似乎确实会发生这种情况。具有讽刺意味的是，&amp;ldquo;代码可重用性&amp;rdquo;是用来证明&amp;ldquo;现代&amp;rdquo;语言存在的理由之一。</target>
        </trans-unit>
        <trans-unit id="0b3fb64877d0da3cc80aa54b2402a8b8eaf24bde" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a different problem. Surely a program that asks a user to input a positive integer, generates the sum of all positive integers from 1 to that number and then prints the result will be MUCH shorter and MUCH easier to understand when coded in Java than in COBOL, right?</source>
          <target state="translated">让我们看一个不同的问题。当然，要求用户输入一个正整数，生成从1到该数字的所有正整数之和，然后打印结果的程序将比使用COBOL用Java编码的时候短很多并且更容易理解，对吧？</target>
        </trans-unit>
        <trans-unit id="26e5808de92654f265239c37c8e3bd7a273163fd" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at how much more &quot;wordy&quot; COBOL is than Java. Count the characters in the two programs. The Java program has 95 (not counting carriage returns and any indentation). The COBOL program has 89 (again, not counting carriage returns and indentation)! Technically, it could have been only 65 because the&lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt;header is actually optional. Clearly, &quot;Hello World&quot; doesn&amp;rsquo;t look any more concise in Java than it does in COBOL.</source>
          <target state="translated">让我们看一下&amp;ldquo;罗y&amp;rdquo;的COBOL比Java多得多。计算两个程序中的字符。Java程序有95（不计算回车符和任何缩进）。COBOL程序有89个（再次，不算回车和缩进）！从技术上讲，由于 &lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt; 原因，它本来只能是65 。标头实际上是可选的。显然，Java中的&amp;ldquo; Hello World&amp;rdquo;看起来比COBOL中的简洁得多。</target>
        </trans-unit>
        <trans-unit id="963bbbacb61f8751db91170e221a486a9a4d3b42" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say the 3x4 &quot;grid&quot; defined by the above structure has these values:</source>
          <target state="translated">假设上述结构定义的3x4&amp;ldquo;网格&amp;rdquo;具有以下值：</target>
        </trans-unit>
        <trans-unit id="807ef358de181fc6f5a56bc69f36677531a8d93e" translate="yes" xml:space="preserve">
          <source>Level 1 (Highest) &amp;mdash; Unary Sign Specification &lt;code&gt;+&lt;/code&gt;and&lt;code&gt;-&lt;/code&gt;with a single argument)</source>
          <target state="translated">级别1（最高）&amp;mdash;一元符号规范 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt; (带单个参数）</target>
        </trans-unit>
        <trans-unit id="c0776e45f0a30777bc589139ec70ff962e33c83c" translate="yes" xml:space="preserve">
          <source>Level 2 &amp;mdash; Exponentiation &lt;code&gt;**&lt;/code&gt;or&lt;code&gt;^&lt;/code&gt;</source>
          <target state="translated">2级-指数 &lt;code&gt;**&lt;/code&gt; 或 &lt;code&gt;^&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6d3eb2924374b17ead104f2e6704337373d534b" translate="yes" xml:space="preserve">
          <source>Level 3 &amp;mdash; Multiplication &lt;code&gt;*&lt;/code&gt; and division &lt;code&gt;/&lt;/code&gt;</source>
          <target state="translated">第3级-乘法 &lt;code&gt;*&lt;/code&gt; 和除法 &lt;code&gt;/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76c7a53b8aaf3b4d3d4c40f9ab98b835416a16f8" translate="yes" xml:space="preserve">
          <source>Level 4 &amp;mdash; Addition &lt;code&gt;+&lt;/code&gt; or subtraction &lt;code&gt;+&lt;/code&gt;</source>
          <target state="translated">等级4 -加 &lt;code&gt;+&lt;/code&gt; 或减法 &lt;code&gt;+&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5597f96dc9d80c27ec5e33857991562ca948cabc" translate="yes" xml:space="preserve">
          <source>Level Number</source>
          <target state="translated">级别数</target>
        </trans-unit>
        <trans-unit id="3052fa9dd47259fbdfdaada2330b8f6e3cbdd9ac" translate="yes" xml:space="preserve">
          <source>Level numbers 66, 77, 78 and 88 all have special uses &amp;mdash; See &lt;a href=&quot;#Special-Data-Items&quot;&gt;Special Data Items&lt;/a&gt;, for details.</source>
          <target state="translated">级别66、77、78和88都有特殊用途-有关详细信息，请参见&lt;a href=&quot;#Special-Data-Items&quot;&gt;特殊数据项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c40b4c76be763282435e76a210c233701e5f2f23" translate="yes" xml:space="preserve">
          <source>Level numbers 66, 77, 78 and 88 identify special properties of a data description entry.</source>
          <target state="translated">等级号66、77、78和88标识数据描述条目的特殊属性。</target>
        </trans-unit>
        <trans-unit id="f058b290679bb97e2e65e2ade8e908cf0471986c" translate="yes" xml:space="preserve">
          <source>Level numbers in the range 1 through 49 indicate the position of a data item in the hierarchical structure of a logical record. Level numbers in the range 1 through 9 can be written either as a single digit or as a zero followed by the significant digit.</source>
          <target state="translated">1至49范围内的级别号表示数据项在逻辑记录的层次结构中的位置。1至9范围内的级数既可以写成一个数字,也可以写成一个零,然后再写上重要的数字。</target>
        </trans-unit>
        <trans-unit id="0d0db8c2b020268e4b2e48ddcbb42e59195d905a" translate="yes" xml:space="preserve">
          <source>Licensed under the GNU Free Documentation License.</source>
          <target state="translated">以GNU自由文档许可证授权。</target>
        </trans-unit>
        <trans-unit id="1c7be671b82e536f670976ec80f415fa5dd43afc" translate="yes" xml:space="preserve">
          <source>Like line sequential files, these files should not be defined to contain any exact binary data fields because the contents of those fields could inadvertently have the end-of-record sequence as part of their values &amp;mdash; this would confuse the runtime system when reading the file, and it would interpret that value as an actual end-of-record sequence.</source>
          <target state="translated">像行顺序文件一样，不应将这些文件定义为包含任何确切的二进制数据字段，因为这些字段的内容可能会无意中将记录结束序列作为其值的一部分&amp;mdash;这会在读取文件时混淆运行时系统，它将将该值解释为实际的记录结束序列。</target>
        </trans-unit>
        <trans-unit id="57489ee4e43a2ed5c736dd719377be4582a70ea3" translate="yes" xml:space="preserve">
          <source>Like most other implementations of the COBOL language, GnuCOBOL utilizes a run-time library. When the first program executed in a given execution sequence is a GnuCOBOL program, any run-time library initialization will be performed by the compiled COBOL code in a manner that is transparent to the C-language programmer. If, however, a C program is the first to execute, the burden of performing GnuCOBOL run-time library initialization falls upon the C program. See &lt;a href=&quot;#C-Main-Programs-Calling-GnuCOBOL-Subprograms&quot;&gt;C Main Programs Calling GnuCOBOL Subprograms&lt;/a&gt;, for an example of how to do this.</source>
          <target state="translated">像大多数其他COBOL语言实现一样，GnuCOBOL也使用运行时库。当以给定的执行顺序执行的第一个程序是GnuCOBOL程序时，任何运行时库初始化都将由已编译的COBOL代码以对C语言程序员透明的方式执行。但是，如果首先执行C程序，则执行GnuCOBOL运行时库初始化的负担将落在C程序上。有关如何执行此操作的示例，请参见&lt;a href=&quot;#C-Main-Programs-Calling-GnuCOBOL-Subprograms&quot;&gt;C主程序调用GnuCOBOL子程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="57fb879374ae97e5eb278f255c02c63fea22e809" translate="yes" xml:space="preserve">
          <source>Line Sequential files are processed using the following statements:</source>
          <target state="translated">行顺序文件使用以下语句处理。</target>
        </trans-unit>
        <trans-unit id="92e97e035f44f8980e413b0d3167603ea36902ee" translate="yes" xml:space="preserve">
          <source>Literal</source>
          <target state="translated">Literal</target>
        </trans-unit>
        <trans-unit id="44ac976e13987b2e461319b6b07bf2f1d2977574" translate="yes" xml:space="preserve">
          <source>Little-Endian</source>
          <target state="translated">Little-Endian</target>
        </trans-unit>
        <trans-unit id="226d589b5f25caf9198d123daff4d9daae8eba87" translate="yes" xml:space="preserve">
          <source>Little-endian data allocation calls for the bytes that comprise a binary item to be allocated such that the least-significant byte is the left-most byte. For example, a four-byte binary item having a value of decimal 20 would be little-endian allocated as 14000000 (shown in hexadecimal notation).</source>
          <target state="translated">小恩典数据分配要求对组成二进制项的字节进行分配,使最不重要的字节成为最左边的字节。例如,一个值为十进制20的四字节二进制项目将被小恩典分配为14000000(用十六进制符号表示)。</target>
        </trans-unit>
        <trans-unit id="835de5c115f7b3e75f88f1bf5d8aaf4ad47e0bd8" translate="yes" xml:space="preserve">
          <source>Local-storage cannot be used in nested subprograms.</source>
          <target state="translated">本地存储不能用于嵌套的子程序中。</target>
        </trans-unit>
        <trans-unit id="a5e093ebdd409890bed85c2fed42792048e3ee67" translate="yes" xml:space="preserve">
          <source>Local-storage, if any, is de-allocated.</source>
          <target state="translated">本地存储,如果有的话,将被取消分配。</target>
        </trans-unit>
        <trans-unit id="3690da6677c866b7070485f97c20dfa1fc2058b7" translate="yes" xml:space="preserve">
          <source>Local-storage, if any, will be allocated and initialized.</source>
          <target state="translated">本地存储,如果有的话,将被分配和初始化。</target>
        </trans-unit>
        <trans-unit id="029c39972ba6042647e3f70b02f4bd91260e9fb3" translate="yes" xml:space="preserve">
          <source>Locator</source>
          <target state="translated">Locator</target>
        </trans-unit>
        <trans-unit id="8d02c4cdcb2b9946ab2619bfecc5df1af1b12a02" translate="yes" xml:space="preserve">
          <source>Locks acquired vie multiple record locking remain in-effect until the program holding the lock&amp;hellip;</source>
          <target state="translated">通过多条记录锁定获取的锁定将保持有效，直到持有该锁定的程序&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="be9a3c255cc059f59d89184276ee44ce2ff74a47" translate="yes" xml:space="preserve">
          <source>MAGNETIC-TAPE, MANUAL, MAX, MEAN, MEDIAN, MEMORY, MERGE, MESSAGE, METHOD, METHOD-ID, MIDRANGE, MIN, MINUS, MOD, MODE, MODULE-CALLER-ID, MODULE-DATE, MODULE-FORMATTED-DATE, MODULE-ID, MODULE-PATH, MODULES, MODULE-SOURCE, MODULE-TIME, MONETARY-DECIMAL-POINT, MONETARY-THOUSANDS-SEPARATOR, MOVE, MULTIPLE, MULTIPLY</source>
          <target state="translated">MAGNETIC-TAPE,MANUAL,MAX,MEAN,MEDIAN,MEMORY,MERGE,MESSAGE,METHOD,METHOD-ID,MIDRANGE,MIN,MINUS,MOD,MODE,MODULE-CALLER-ID,MODULE-DATE,MODULE-FORMATTED-DATE,MODULE-ID,MODULE-ID,MODULE-PATH,MODULES,MODULE-SOURCE,MODULE-TIME,MONETARY-DECIMAL-POINT,MONETARY-THOUSANDS-SEPARATOR,MOVE,MULTIPLE,MULTIPLY。</target>
        </trans-unit>
        <trans-unit id="57e71373c55e995e80f24e3f2087d0a7b5dbbec9" translate="yes" xml:space="preserve">
          <source>MAX Function Syntax</source>
          <target state="translated">MAX 函数语法</target>
        </trans-unit>
        <trans-unit id="0abf13bfa8b362e60f0cf8bd2bacaab30d7f67c9" translate="yes" xml:space="preserve">
          <source>MEAN Function Syntax</source>
          <target state="translated">MEAN 函数语法</target>
        </trans-unit>
        <trans-unit id="31a496c910f49ef35450cbdb8cbc4374b9f67273" translate="yes" xml:space="preserve">
          <source>MEDIAN Function Syntax</source>
          <target state="translated">MEDIAN 函数语法</target>
        </trans-unit>
        <trans-unit id="daee7fdd946c270a9b400d0cb5b7e42fe5872e0c" translate="yes" xml:space="preserve">
          <source>MERGE Syntax</source>
          <target state="translated">MERGE 语法</target>
        </trans-unit>
        <trans-unit id="c8035dd19f4b057f89b85a604ee1af37d346e31e" translate="yes" xml:space="preserve">
          <source>MIDRANGE Function Syntax</source>
          <target state="translated">MIDRANGE 函数语法</target>
        </trans-unit>
        <trans-unit id="b3922fba0ffbf0d82c96e71393fb62e945ccf5b9" translate="yes" xml:space="preserve">
          <source>MIN Function Syntax</source>
          <target state="translated">MIN 函数语法</target>
        </trans-unit>
        <trans-unit id="6df76c53746f58160bf9ed45943e438821905bb2" translate="yes" xml:space="preserve">
          <source>MOD Function Syntax</source>
          <target state="translated">MOD功能语法</target>
        </trans-unit>
        <trans-unit id="fb9072e5497502c8b0c9f0cc92c12083bdb2cecc" translate="yes" xml:space="preserve">
          <source>MODULE-CALLER-ID Function Syntax</source>
          <target state="translated">MODULE-CALLER-ID 函数语法</target>
        </trans-unit>
        <trans-unit id="77023dbd5e71addbd6ecdf7b0de7955c05a7cbcc" translate="yes" xml:space="preserve">
          <source>MODULE-DATE Function Syntax</source>
          <target state="translated">MODULE-DATE 函数语法</target>
        </trans-unit>
        <trans-unit id="e4f1aeb1a72fe45f289846eea035900277d6474e" translate="yes" xml:space="preserve">
          <source>MODULE-FORMATTED-DATE Function Syntax</source>
          <target state="translated">MODULE-FORMATTED-DATE 函数语法</target>
        </trans-unit>
        <trans-unit id="e4708a13b25aed7fbcdde2ed7eb4f478e4e5a0d2" translate="yes" xml:space="preserve">
          <source>MODULE-ID Function Syntax</source>
          <target state="translated">MODULE-ID 功能描述</target>
        </trans-unit>
        <trans-unit id="9c157b8be74a13e0253ff0fdbcddcca6237613e4" translate="yes" xml:space="preserve">
          <source>MODULE-PATH Function Syntax</source>
          <target state="translated">MODULE-PATH 函数语法</target>
        </trans-unit>
        <trans-unit id="6aeac5d8bb6edf96b2cc15b2e1900d618339fe87" translate="yes" xml:space="preserve">
          <source>MODULE-SOURCE Function Syntax</source>
          <target state="translated">MODULE-SOURCE 功能描述</target>
        </trans-unit>
        <trans-unit id="9ba6dae63e2adfd381389ee805e05d8f98957c6a" translate="yes" xml:space="preserve">
          <source>MODULE-TIME Function Syntax</source>
          <target state="translated">MODULE-TIME 功能描述</target>
        </trans-unit>
        <trans-unit id="f73ead11798a2b39d355bdb9cc3ee0afd6c73ca2" translate="yes" xml:space="preserve">
          <source>MONETARY-DECIMAL-POINT Function Syntax</source>
          <target state="translated">货币-小数-点函数语法</target>
        </trans-unit>
        <trans-unit id="f959bf7a22a6fa8fd96fe2dd391a08fa5dd22aa0" translate="yes" xml:space="preserve">
          <source>MONETARY-THOUSANDS-SEPARATOR Function Syntax</source>
          <target state="translated">货币--单位--分离器 函数语法</target>
        </trans-unit>
        <trans-unit id="ec0648f1ef8e6f8e156101c88dcd2b9563d62924" translate="yes" xml:space="preserve">
          <source>MOVE CORRESPONDING Syntax</source>
          <target state="translated">MOVE CORRESPONDING 命令格式</target>
        </trans-unit>
        <trans-unit id="569fe924e80927234226e1da480e2aaeb896476b" translate="yes" xml:space="preserve">
          <source>MULTIPLY BY Syntax</source>
          <target state="translated">MULTIPLY BY 语法</target>
        </trans-unit>
        <trans-unit id="3ad347c2697684ef0953e3a767d0bc1635d31d5a" translate="yes" xml:space="preserve">
          <source>MULTIPLY GIVING Syntax</source>
          <target state="translated">MULTIPLY GIVING 语法</target>
        </trans-unit>
        <trans-unit id="412299ff020a7154d245c3b0f04152fc824d367f" translate="yes" xml:space="preserve">
          <source>Magenta: COB-COLOR-MAGENTA</source>
          <target state="translated">洋红色:COB-COLOR-MAGENTA。</target>
        </trans-unit>
        <trans-unit id="4ad990da0619f2f6612747fd3b18ae051e2e5eca" translate="yes" xml:space="preserve">
          <source>Main Program</source>
          <target state="translated">主程序</target>
        </trans-unit>
        <trans-unit id="62df8b8e9bbaa8bb9f1517aa2bf38f13fc37e36a" translate="yes" xml:space="preserve">
          <source>Main program</source>
          <target state="translated">主程序</target>
        </trans-unit>
        <trans-unit id="154c8bfc5f3e601547791b40d3a205f6ed780b67" translate="yes" xml:space="preserve">
          <source>Main programs compiled in this manner should be executed as follows:</source>
          <target state="translated">以这种方式编译的主程序应按以下方式执行。</target>
        </trans-unit>
        <trans-unit id="ad9766c462696f99f3025a340a18914544b7bff9" translate="yes" xml:space="preserve">
          <source>Main programs that wish to &quot;pass back&quot; a return code value to the operating system when they exit do not use RETURNING - they do so simply by MOVEing a value to the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register.</source>
          <target state="translated">希望在退出时将返回码值&amp;ldquo;回传&amp;rdquo;到操作系统的主程序不使用RETURNING，而是通过将值移到 &lt;code&gt;RETURN-CODE&lt;/code&gt; 特殊寄存器中来简单地做到这一点。</target>
        </trans-unit>
        <trans-unit id="7a5053f6a0e7ffe3e98db384f4662350eb992d81" translate="yes" xml:space="preserve">
          <source>Management of areas on the printed page such as top-of page headers, bottom-of-page footers, dealing with &quot;full page&quot; situations and the like are now the joint responsibility of the programmer and the GnuCOBOL run-time library, which provides tools such as the&lt;code&gt;LINAGE-COUNTER&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) and the&lt;code&gt;END-OF-PAGE&lt;/code&gt;</source>
          <target state="translated">现在，程序员和GnuCOBOL运行时库共同负责管理打印页面上的区域，例如页面顶部的页眉，页面底部的页脚，处理&amp;ldquo;整页&amp;rdquo;情况等。诸如 &lt;code&gt;LINAGE-COUNTER&lt;/code&gt; 特殊寄存器（请参阅&lt;a href=&quot;#Special-Registers&quot;&gt;特殊寄存器&lt;/a&gt;）和 &lt;code&gt;END-OF-PAGE&lt;/code&gt; 之类的工具</target>
        </trans-unit>
        <trans-unit id="535d01a3bb7e25e935da4ad3d0028806321932cc" translate="yes" xml:space="preserve">
          <source>Management of areas on the printed page such as top-of page headers, bottom-of-page footers, dealing with &quot;full page&quot; situations and the like are the complete responsibility of the programmer.</source>
          <target state="translated">管理印刷页面上的区域,如页眉、页脚、处理 &quot;整页 &quot;等情况,完全由程序员负责。</target>
        </trans-unit>
        <trans-unit id="5d904664fde10f48cc22ff0d5ed913f64ac37406" translate="yes" xml:space="preserve">
          <source>Many COBOL compilers do not allow the use of&lt;code&gt;VALUE&lt;/code&gt;and&lt;code&gt;OCCURS&lt;/code&gt;(see &lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt;) on the same data item; additionally, they don&amp;rsquo;t allow a&lt;code&gt;VALUE&lt;/code&gt;clause on a data item subordinate to an&lt;code&gt;OCCURS&lt;/code&gt; GnuCOBOL, however, has neither of these restrictions!</source>
          <target state="translated">许多COBOL编译器不允许在同一数据项上使用 &lt;code&gt;VALUE&lt;/code&gt; 和 &lt;code&gt;OCCURS&lt;/code&gt; （请参阅&lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt;）。另外，它们不允许在 &lt;code&gt;OCCURS&lt;/code&gt; GnuCOBOL后面的数据项上使用 &lt;code&gt;VALUE&lt;/code&gt; 子句，但是，这两个限制都没有！</target>
        </trans-unit>
        <trans-unit id="cec330cac6c061d7cea06b901961f17d2342ed88" translate="yes" xml:space="preserve">
          <source>Many systems have program-development tools available to ease the task of coding programs; those tools that concentrate on COBOL are capable of providing templates for much of the &quot;overhead&quot; verbiage of any program&amp;hellip;</source>
          <target state="translated">许多系统都有程序开发工具，可简化代码编写任务。那些专注于COBOL的工具能够为任何程序的大部分&amp;ldquo;开销&amp;rdquo;语言提供模板&amp;hellip;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="bea0e296af322cedefa66548ccd5635e5218df89" translate="yes" xml:space="preserve">
          <source>Many times these businesses are finding the cost of the system/networking engineering, operational management and monitoring and risk management (i.e. disaster recovery) infrastructures necessary to support truly mission-critical applications to be so high that the &quot;less-expensive&quot; solution really isn&amp;rsquo;t; in these cases the mainframe may remain the best option, thus leaving COBOL in play and businesses seeking another solution for at least part of their application base.</source>
          <target state="translated">这些企业常常发现，支持真正的关键任务应用程序所必需的系统/网络工程，运营管理，监视和风险管理（即灾难恢复）基础架构的成本如此之高，以至于&amp;ldquo;廉价&amp;rdquo;解决方案的确不可行。 't;在这些情况下，大型机可能仍然是最佳选择，从而使COBOL发挥了作用，并且企业正在为其至少一部分应用程序库寻求其他解决方案。</target>
        </trans-unit>
        <trans-unit id="5c7162a608e9a76bc0cf997699b25c2bb027fd85" translate="yes" xml:space="preserve">
          <source>Marking changes becomes more of a challenge when free-format source code is in effect. Creating a top-of-program comment block to generically describe changes that have been made isn&amp;rsquo;t difficult, even in free-form. What IS difficult, however, is coming up with a scheme for per-statement mark up of changes that doesn&amp;rsquo;t introduce a ridiculously excessive number of source lines to the program. I&amp;rsquo;m not sure there is a good answer to this problem (if a reader has one, please let me know). Generally, I&amp;rsquo;ve noticed that shops using free-format conventions for their COBOL source tend to stick with just the top-of-program comment block combined with minimal comment blocks sprinkled throughout the program noting areas that underwent major changes.</source>
          <target state="translated">当自由格式的源代码生效时，标记更改变得更加困难。创建程序顶部的注释块以一般性地描述所做的更改，即使是自由格式也不难。但是，要想出的是一种针对每个语句的更改标记方案，该方案不会给程序带来过多的源代码行。我不确定这个问题是否有好的答案（如果读者有一个答案，请告诉我）。通常，我已经注意到，使用自由格式约定作为COBOL源的商店倾向于只使用程序顶部的注释框，并在整个程序中散布最少的注释框，注意那些需要进行重大更改的区域。</target>
        </trans-unit>
        <trans-unit id="44df495b9a46d581843f66787d274a1a7bcc6fc8" translate="yes" xml:space="preserve">
          <source>Matching up GnuCOBOL numeric Usage s with their C language data type equivalents is possible via the following chart:</source>
          <target state="translated">通过下图可以将 GnuCOBOL 数字用法与它们的 C 语言数据类型等价物进行匹配。</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="f15a625eabeb2b9b8fbf957ba6acb6ea6384e8c2" translate="yes" xml:space="preserve">
          <source>Meaning if 0</source>
          <target state="translated">意思是如果0</target>
        </trans-unit>
        <trans-unit id="0b296b5b70a4eb122d3023d41ac6ce6b7484aab3" translate="yes" xml:space="preserve">
          <source>Meaning if 1</source>
          <target state="translated">意思是如果1</target>
        </trans-unit>
        <trans-unit id="f99e481919f7772162edf428466c40acaa045b03" translate="yes" xml:space="preserve">
          <source>Most &amp;lt;</source>
          <target state="translated">大多数&amp;lt;</target>
        </trans-unit>
        <trans-unit id="f9aaebcdc913ba77329c6f07dbfd334a3e319cb4" translate="yes" xml:space="preserve">
          <source>Most COBOL programmers, when using&lt;code&gt;WITH TEST BEFORE&lt;/code&gt;explicitly or implicitly have developed the habit of using &quot;&amp;gt;&quot; rather than &quot;=&quot; on&lt;code&gt;UNTIL&lt;/code&gt;clauses. This would make the sample code:</source>
          <target state="translated">大多数COBOL程序员 &lt;code&gt;WITH TEST BEFORE&lt;/code&gt; 显式或隐式使用WITH TEST之前使用时，已经养成了在 &lt;code&gt;UNTIL&lt;/code&gt; 子句上使用&amp;ldquo;&amp;gt;&amp;rdquo;而不是&amp;ldquo; =&amp;rdquo;的习惯。这将使示例代码：</target>
        </trans-unit>
        <trans-unit id="af302c911fcda5124147255d68b3ea18b4163a54" translate="yes" xml:space="preserve">
          <source>Most of the call-by-number routines have evolved into even more powerful call-by-name routines, many of which are supported by GnuCOBOL.</source>
          <target state="translated">大部分的逐号例程已经演变成更强大的逐名例程,其中很多例程都被GnuCOBOL所支持。</target>
        </trans-unit>
        <trans-unit id="817d5274cb3dad555ae670d47cd2b238950e0a1b" translate="yes" xml:space="preserve">
          <source>Most other COBOL implementations reject the use of multiple occurrences of multiple floating editing symbols. For example, they would reject &amp;lt;</source>
          <target state="translated">大多数其他COBOL实现都拒绝使用多次出现的多个浮动编辑符号。例如，他们会拒绝&amp;lt;</target>
        </trans-unit>
        <trans-unit id="bd8dc228cac7dc6165d9a7427a86371a364ab9e9" translate="yes" xml:space="preserve">
          <source>Moving files (a destructive &quot;copy&quot;)</source>
          <target state="translated">移动文件(破坏性的 &quot;复制&quot;)</target>
        </trans-unit>
        <trans-unit id="8068c142bfb974eaa19e904ed221669dae03ee9c" translate="yes" xml:space="preserve">
          <source>Multiple programs, separated from one another by&lt;code&gt;END PROGRAM&lt;/code&gt;or&lt;code&gt;END FUNCTION&lt;/code&gt;statements. The final program in such a source code file need not have an&lt;code&gt;END PROGRAM&lt;/code&gt;or&lt;code&gt;END FUNCTION&lt;/code&gt;statement.</source>
          <target state="translated">多个程序，由 &lt;code&gt;END PROGRAM&lt;/code&gt; 或 &lt;code&gt;END FUNCTION&lt;/code&gt; 语句彼此分隔。这样的源代码文件中的最终程序不必具有 &lt;code&gt;END PROGRAM&lt;/code&gt; 或 &lt;code&gt;END FUNCTION&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="02160c2d59fcbe5c753ac574ebfed903f459af79" translate="yes" xml:space="preserve">
          <source>Multiple space-delimited tokens may be treated as a single token by enclosing them in quotes. For example, there are only three tokens generated from the command line &lt;code&gt;C:\Pgms\myprog.exe &quot;THIS IS A&quot; TEST&lt;/code&gt; &amp;mdash; &quot;C:\Pgms\myprog.exe&quot;, &quot;THIS IS A&quot; and &quot;TEST&quot;. When quote characters are used to create multi-word tokens, the quote characters themselves are stripped from the token&amp;rsquo;s value.</source>
          <target state="translated">通过将多个用空格分隔的标记括在引号中，可以将它们视为单个标记。例如，仅从命令行 &lt;code&gt;C:\Pgms\myprog.exe &quot;THIS IS A&quot; TEST&lt;/code&gt; 生成三个令牌-&amp;ldquo; C：\ Pgms \ myprog.exe&amp;rdquo;，&amp;ldquo;这是一个&amp;rdquo;和&amp;ldquo;测试&amp;rdquo;。当使用引号字符创建多词标记时，引号字符本身会从标记的值中删除。</target>
        </trans-unit>
        <trans-unit id="0c9327341de5e837b95068cae1399d3901498283" translate="yes" xml:space="preserve">
          <source>Multiple-item search strings can be specified using the&lt;code&gt;==&amp;lt;&lt;i&gt;pseudo-text-1&lt;/i&gt;&amp;gt;==&lt;/code&gt;option. For example, to replace all occurrences of&lt;code&gt;UPON PRINTER&lt;/code&gt; you would specify&lt;code&gt;==UPON PRINTER==&lt;/code&gt;</source>
          <target state="translated">可以使用 &lt;code&gt;==&amp;lt;&lt;i&gt;pseudo-text-1&lt;/i&gt;&amp;gt;==&lt;/code&gt; 选项指定多项目搜索字符串。例如，要替换所有出现的 &lt;code&gt;UPON PRINTER&lt;/code&gt; ,您可以指定 &lt;code&gt;==UPON PRINTER==&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="512c7a9b64ee7852d8007b60e8e382406285cb64" translate="yes" xml:space="preserve">
          <source>Multiple&lt;code&gt;/&lt;/code&gt;symbols may be coded.</source>
          <target state="translated">多个 &lt;code&gt;/&lt;/code&gt; 符号可被编码。</target>
        </trans-unit>
        <trans-unit id="1bb573db89249b4de6d85f0d6303b423ef55f890" translate="yes" xml:space="preserve">
          <source>Multiple&lt;code&gt;0&lt;/code&gt;symbols may be coded.</source>
          <target state="translated">可以编码多个 &lt;code&gt;0&lt;/code&gt; 符号。</target>
        </trans-unit>
        <trans-unit id="4e4e78bcc251379bcccaef2662ec5c92b786e53d" translate="yes" xml:space="preserve">
          <source>Multiple&lt;code&gt;B&lt;/code&gt;symbols may be coded.</source>
          <target state="translated">多个 &lt;code&gt;B&lt;/code&gt; 符号可以被编码。</target>
        </trans-unit>
        <trans-unit id="4272ab5411f12b91ef6d0e34934e3b2c6d362159" translate="yes" xml:space="preserve">
          <source>Multiply the result of this function times the desired principal amount to determine the amount of each period&amp;rsquo;s payment.</source>
          <target state="translated">将此函数的结果乘以所需的本金，即可确定每个期间的付款额。</target>
        </trans-unit>
        <trans-unit id="257327ddfd98406ae03a0f3e1b7b410f8b01fe5e" translate="yes" xml:space="preserve">
          <source>My familiarity with COBOL may be prejudicing my opinion, but it doesn&amp;rsquo;t appear to me that the Java code is any simpler than the COBOL code. In case you&amp;rsquo;re interested in character counts, the Java code comes in at 278 (not counting indentation characters). The COBOL code is 298 (274 without the&lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt;header).</source>
          <target state="translated">我对COBOL的熟悉可能会影响我的见解，但是在我看来，Java代码没有比COBOL代码更简单的了。如果您对字符计数感兴趣，则Java代码以278出现（不计算缩进字符）。COBOL代码为298（274，不包含 &lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt; 标头）。</target>
        </trans-unit>
        <trans-unit id="8841ca9cf4a3d6697ad899f49ceee826a96da464" translate="yes" xml:space="preserve">
          <source>N/A (no GnuCOBOL equivalent)</source>
          <target state="translated">不适用(无GnuCOBOL等价物)</target>
        </trans-unit>
        <trans-unit id="456048850e9d09e5cbfde5c2a6be5799c526a49a" translate="yes" xml:space="preserve">
          <source>NAME, NATIONAL, NATIONAL-EDITED, NATIONAL-OF, NATIVE, NEAREST-AWAY-FROM-ZERO, NEAREST-EVEN, NEAREST-TOWARD-ZERO, NEGATIVE, NESTED, NEXT, NO, NO-ECHO, NONE, NORMAL, NOT, NOTHING, NULL, NULLS, NUMBER, NUMBER-OF-CALL-PARAMETERS, NUMBERS, NUMERIC, NUMERIC-DECIMAL-POINT, NUMERIC-EDITED, NUMERIC-THOUSANDS-SEPARATOR, NUMVAL, NUMVAL-C, NUMVAL-F</source>
          <target state="translated">NAME,NATIONAL,NATIONAL-EDITED,NATIONAL-OF,NATIVE,NEAREST-AWAY-OF-ZERO,NEAREST-EVEN,NEAREST-TOWARD-ZERO,NEGATIVE,NESTED,NEXT,NO,NO-ECHO,NONE,NORMAL,NOT,NOTHING,NULL,NULLS,NUMBER,NUMBER-OF-CALL-PARAMETERS,NUMBERS,NUMERIC,NUMERIC-DECIMAL-POINT,NUMERIC-EDITED,NUMERIC-THOUSANDS-SEPARATOR,NUMVAL,NUMVAL-C,NUMVAL-F</target>
        </trans-unit>
        <trans-unit id="23579a7244afbe343b0ef7777f40fe65dd6d391f" translate="yes" xml:space="preserve">
          <source>NEXT-GROUP Clause Syntax</source>
          <target state="translated">NEXT-GROUP子句语法</target>
        </trans-unit>
        <trans-unit id="4fd04833b3755cfdf59219f364a4c19cf95dcc36" translate="yes" xml:space="preserve">
          <source>NO-ECHO Attribute Syntax</source>
          <target state="translated">NO-ECHO属性语法</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="a9ea4f7a4f03a9c52a7aa0d54a54e0ee6d21feed" translate="yes" xml:space="preserve">
          <source>NOTE that CBL_GC_PRINTABLE replaces this although it is currently still supported for legacy reasons.</source>
          <target state="translated">注意,CBL_GC_PRINTABLE 取代了这个功能,尽管由于传统的原因,目前仍然支持它。</target>
        </trans-unit>
        <trans-unit id="1c7a5d29d866f9947d87ce89b623e7dcee44fb1b" translate="yes" xml:space="preserve">
          <source>NUMERIC-DECIMAL-POINT Function Syntax</source>
          <target state="translated">NUMERIC-DECIMAL-POINT 函数语法</target>
        </trans-unit>
        <trans-unit id="0f7032d6214932877eaeb90684d8b5e91b84fe2d" translate="yes" xml:space="preserve">
          <source>NUMERIC-THOUSANDS-SEPARATOR Function Syntax</source>
          <target state="translated">NUMERIC-THOUSANDS-SEPARATOR函数语法</target>
        </trans-unit>
        <trans-unit id="24a2cb0031362dfda9217165484fefd16498a931" translate="yes" xml:space="preserve">
          <source>NUMVAL Function Syntax</source>
          <target state="translated">NUMVAL 函数语法</target>
        </trans-unit>
        <trans-unit id="31988bddc5cc6a4166042e84de6cbd874cb74a99" translate="yes" xml:space="preserve">
          <source>NUMVAL-C Function Syntax</source>
          <target state="translated">NUMVAL-C 函数语法</target>
        </trans-unit>
        <trans-unit id="ae21c526020f5a22401b17f7aa4bfb1762439159" translate="yes" xml:space="preserve">
          <source>NUMVAL-F Function Syntax</source>
          <target state="translated">NUMVAL-F 函数语法</target>
        </trans-unit>
        <trans-unit id="057d3c3f4e6e8dc1ec58c53e9789c01dd0b62e89" translate="yes" xml:space="preserve">
          <source>National Character set</source>
          <target state="translated">国字集</target>
        </trans-unit>
        <trans-unit id="4245f0ee71bd17093500ac16c41a1dd1b33008e5" translate="yes" xml:space="preserve">
          <source>Native Binary Integer</source>
          <target state="translated">原生二进制整数</target>
        </trans-unit>
        <trans-unit id="3f00afda761d5e13a699220ac15df2aa008259c3" translate="yes" xml:space="preserve">
          <source>Native IEEE 754 Binary32</source>
          <target state="translated">原生IEEE 754 Binary32</target>
        </trans-unit>
        <trans-unit id="38d71bfaf2af5e86c02dd007bae5cd22e8350547" translate="yes" xml:space="preserve">
          <source>Native IEEE 754 Binary64 Floating-point</source>
          <target state="translated">原生的IEEE 754二进制64浮点数</target>
        </trans-unit>
        <trans-unit id="4775cd57bf8ad48397acf03e156ee31bbc505817" translate="yes" xml:space="preserve">
          <source>Native IEEE 754 Decimal128 Floating-point</source>
          <target state="translated">原生的IEEE 754 十进制128 浮点数</target>
        </trans-unit>
        <trans-unit id="1579bca067a63e4a82df0092b6bb19e611a1879b" translate="yes" xml:space="preserve">
          <source>Native IEEE 754 Decimal64 Floating-point</source>
          <target state="translated">原生的IEEE 754十进制64 浮点数</target>
        </trans-unit>
        <trans-unit id="663645109bc4810ff83f3fcb9242af60d6271f15" translate="yes" xml:space="preserve">
          <source>Native unsigned (X) or signed (9) Binary</source>
          <target state="translated">原生无符号(X)或有符号(9)二进制。</target>
        </trans-unit>
        <trans-unit id="0bb1805002fe928c11731e2fe434c6710e0546aa" translate="yes" xml:space="preserve">
          <source>Negated Condition Syntax</source>
          <target state="translated">否定条件语法</target>
        </trans-unit>
        <trans-unit id="b258f825a32604b32cf66b5f27af5bbeed3d0dbd" translate="yes" xml:space="preserve">
          <source>Negative Values Allowed?:</source>
          <target state="translated">允许负值?</target>
        </trans-unit>
        <trans-unit id="569eabdf4b8f2757a51f46ddb9444a185ebc7cb4" translate="yes" xml:space="preserve">
          <source>Negative values are returned for system dependand error codes and -1 if the function is not available on the current system.</source>
          <target state="translated">对于系统依赖性和错误代码返回负值,如果该函数在当前系统中不可用,则返回-1。</target>
        </trans-unit>
        <trans-unit id="fac968968fa4c7a06b3ca207e37616b4cf010c7c" translate="yes" xml:space="preserve">
          <source>Neither &amp;lt;</source>
          <target state="translated">都不&amp;lt;</target>
        </trans-unit>
        <trans-unit id="dcdcf73a59a8f2ad5bc285a8314df00761fcb686" translate="yes" xml:space="preserve">
          <source>Neither a another file-based&lt;code&gt;SORT&lt;/code&gt;statement nor a&lt;code&gt;MERGE&lt;/code&gt;statement may be executed within the input procedure unless those statements utilize a different sort or merge work file.</source>
          <target state="translated">除非这些基于语句的 &lt;code&gt;SORT&lt;/code&gt; 语句或 &lt;code&gt;MERGE&lt;/code&gt; 语句使用其他排序或合并工作文件，否则它们都不能在输入过程中执行。</target>
        </trans-unit>
        <trans-unit id="24fe46648b02cf0f40c1f64b86fe9a8a1b238380" translate="yes" xml:space="preserve">
          <source>Neither a another file-based&lt;code&gt;SORT&lt;/code&gt;statement nor a&lt;code&gt;MERGE&lt;/code&gt;statement may be executed within the output procedure unless those statements utilize a different sort or merge work file.</source>
          <target state="translated">除非那些基于文件的 &lt;code&gt;SORT&lt;/code&gt; 语句或 &lt;code&gt;MERGE&lt;/code&gt; 语句均不能使用其他排序或合并工作文件，否则它们都不能在输出过程中执行。</target>
        </trans-unit>
        <trans-unit id="1a3ec78fb2431caff148e7bb1cf8ea0ff18e700c" translate="yes" xml:space="preserve">
          <source>Neither a file-based&lt;code&gt;SORT&lt;/code&gt;statement (see &lt;a href=&quot;#File_002dBased-SORT&quot;&gt;File-Based SORT&lt;/a&gt;) nor another&lt;code&gt;MERGE&lt;/code&gt;statement may be executed within the scope of the procedures comprising the output procedure unless those statements utilize a different sort or merge work file.</source>
          <target state="translated">在包含输出过程的过程范围内，都不能执行&lt;a href=&quot;#File_002dBased-SORT&quot;&gt;基于&lt;/a&gt;文件的 &lt;code&gt;SORT&lt;/code&gt; 语句（请参见基于文件的SORT）或另一个 &lt;code&gt;MERGE&lt;/code&gt; 语句，除非这些语句利用了不同的排序或合并工作文件。</target>
        </trans-unit>
        <trans-unit id="cc989bf49db06aa48ebb1422a2de0e6c00423d9d" translate="yes" xml:space="preserve">
          <source>Neither the presence of an encoded digit (see above) nor an actual&lt;code&gt;+&lt;/code&gt;or&lt;code&gt;-&lt;/code&gt;character embedded within the data item&amp;rsquo;s storage prevents the data item from being used as a source field in arithmetic operations.</source>
          <target state="translated">编码项（参见上文）的存在或嵌入在数据项存储中的实际 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt; 字符都不能阻止数据项在算术运算中用作源字段。</target>
        </trans-unit>
        <trans-unit id="f5e391e55efc04c3c0f99e29e799c743a6b88a5c" translate="yes" xml:space="preserve">
          <source>Neither the value of &amp;lt;</source>
          <target state="translated">&amp;lt;</target>
        </trans-unit>
        <trans-unit id="a8d23bd6a6b56505c754a0566832b43e6c7deddd" translate="yes" xml:space="preserve">
          <source>Neither&lt;code&gt;EXIT PROGRAM&lt;/code&gt;nor&lt;code&gt;EXIT FUNCTION&lt;/code&gt;may be used within a&lt;code&gt;USE GLOBAL&lt;/code&gt;routine in&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;).</source>
          <target state="translated">既不 &lt;code&gt;EXIT PROGRAM&lt;/code&gt; 也不 &lt;code&gt;EXIT FUNCTION&lt;/code&gt; 可以由内使用 &lt;code&gt;USE GLOBAL&lt;/code&gt; 常规 &lt;code&gt;DECLARATIVES&lt;/code&gt; （见&lt;a href=&quot;#DECLARATIVES&quot;&gt;陈述句&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2ef44da87cf7da408056f5b8df3aee8b08f3e63d" translate="yes" xml:space="preserve">
          <source>Nested Subprograms</source>
          <target state="translated">嵌套子方案</target>
        </trans-unit>
        <trans-unit id="02345bc4e59618249ddd33b89a552e74eefc9cca" translate="yes" xml:space="preserve">
          <source>New programs requiring a stand-alone elementary item should be coded to use a level number of 01 rather than 77.</source>
          <target state="translated">新的项目需要独立的基本项目,应使用01而不是77的级别号进行编码。</target>
        </trans-unit>
        <trans-unit id="cb2f4a912a9c59ceb0b74adc342b766667a643e7" translate="yes" xml:space="preserve">
          <source>Next, the&lt;code&gt;CONTROL HEADING&lt;/code&gt;for each &amp;lt;</source>
          <target state="translated">接着， &lt;code&gt;CONTROL HEADING&lt;/code&gt; 对于每个&amp;lt;</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="1a6b2761c5a03cb41776cc1a48760cf197b63fc7" translate="yes" xml:space="preserve">
          <source>No data is available on screen ACCEPT</source>
          <target state="translated">屏幕上没有数据 ACCEPT</target>
        </trans-unit>
        <trans-unit id="22f4fdea4baac33f85e6d27a113ce40e1b051a05" translate="yes" xml:space="preserve">
          <source>No more than 36 arguments may be passed to a subroutine, unless the GnuCOBOL compiler was built with a specifically different argument limit specified for it. If you have access to the GnuCOBOL source code, you may adjust this limit by changing the value of the&lt;code&gt;COB_MAX_FIELD_PARAMS&lt;/code&gt;in the&lt;code&gt;common.h&lt;/code&gt;file (found in the&lt;code&gt;libcob&lt;/code&gt;folder) before you run&lt;code&gt;make&lt;/code&gt;to build the compiler and run-time library.</source>
          <target state="translated">除非向GnuCOBOL编译器指定了一个特别不同的参数限制，否则子例程最多只能传递36个参数。如果你有机会到GnuCOBOL源代码，你可以通过改变的值来调整这个限制 &lt;code&gt;COB_MAX_FIELD_PARAMS&lt;/code&gt; 在 &lt;code&gt;common.h&lt;/code&gt; 文件（在发现 &lt;code&gt;libcob&lt;/code&gt; 文件夹中）在运行之前 &lt;code&gt;make&lt;/code&gt; 构建编译器和运行时库。</target>
        </trans-unit>
        <trans-unit id="9d5b904086ff2a2ac1ab9032a0b17994d3c8146f" translate="yes" xml:space="preserve">
          <source>No report content will actually presented to the report file as a result of a successful&lt;code&gt;INITIATE&lt;/code&gt;statement &amp;mdash; that will not occur until the first&lt;code&gt;GENERATE&lt;/code&gt;statement (see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) is executed.</source>
          <target state="translated">成功执行 &lt;code&gt;INITIATE&lt;/code&gt; 语句后，实际上不会将任何报告内容呈现到报告文件中-在执行第一个 &lt;code&gt;GENERATE&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;）之前不会发生。</target>
        </trans-unit>
        <trans-unit id="841e2fb51fda0ae1893e020320984500822af311" translate="yes" xml:space="preserve">
          <source>No rounding is performed. If the value cannot be represented exactly in the desired format, the EC-SIZE-TRUNCATION condition (exception code 1005) is set (and may be retrieved via the&lt;code&gt;ACCEPT&lt;/code&gt;(see &lt;a href=&quot;#ACCEPT-FROM-Runtime_002dInfo&quot;&gt;ACCEPT FROM Runtime-Info&lt;/a&gt;) statement) and the results of the operation are undefined.</source>
          <target state="translated">不进行舍入。如果不能完全以所需的格式表示该值，则设置EC-SIZE-TRUNCATION条件（异常代码1005）（可以通过 &lt;code&gt;ACCEPT&lt;/code&gt; （请参见&lt;a href=&quot;#ACCEPT-FROM-Runtime_002dInfo&quot;&gt;ACCEPT FROM Runtime-Info&lt;/a&gt;）语句检索）和操作结果未定义。</target>
        </trans-unit>
        <trans-unit id="eae4ac248869b9a9f5a910afc02caead622a3640" translate="yes" xml:space="preserve">
          <source>No special meaning &amp;mdash; this is the normal character that will appear in this area.</source>
          <target state="translated">没有特殊含义-这是将在此区域显示的常规字符。</target>
        </trans-unit>
        <trans-unit id="0cfdaae490927c423f2c8197638d2a8e5c4b9c06" translate="yes" xml:space="preserve">
          <source>No storage is allocated for data defined in the linkage section; the data descriptions there are merely defining storage areas that will be passed to the subprogram by a calling program. Therefore, any discussion of the default initialization of such data is irrelevant. It</source>
          <target state="translated">没有为链接部分定义的数据分配存储空间;那里的数据描述只是定义了将被调用程序传递给子程序的存储区域。因此,任何关于这些数据的默认初始化的讨论都是不相关的。它</target>
        </trans-unit>
        <trans-unit id="7438d13425aae9891e97195f6fa784ef1702eda9" translate="yes" xml:space="preserve">
          <source>No two of those files may be referenced on a&lt;code&gt;SAME RECORD AREA&lt;/code&gt;(see &lt;a href=&quot;#SAME-RECORD-AREA&quot;&gt;SAME RECORD AREA&lt;/a&gt;),&lt;code&gt;SAME SORT AREA&lt;/code&gt;or&lt;code&gt;SAME SORT-MERGE AREA&lt;/code&gt;statement.</source>
          <target state="translated">在 &lt;code&gt;SAME RECORD AREA&lt;/code&gt; （请参阅&lt;a href=&quot;#SAME-RECORD-AREA&quot;&gt;相同的记录区域&lt;/a&gt;）， &lt;code&gt;SAME SORT AREA&lt;/code&gt; 或 &lt;code&gt;SAME SORT-MERGE AREA&lt;/code&gt; 语句中，不能引用这些文件中的两个。</target>
        </trans-unit>
        <trans-unit id="de44dc71aad924a999900997ea794d8dd652830f" translate="yes" xml:space="preserve">
          <source>No two records in the table may have the same&lt;code&gt;KEY&lt;/code&gt;field values. If the table has multiple&lt;code&gt;KEY&lt;/code&gt;definitions, then no two records in the table may have the same</source>
          <target state="translated">表中的两个记录都不能具有相同的 &lt;code&gt;KEY&lt;/code&gt; 字段值。如果表具有多个 &lt;code&gt;KEY&lt;/code&gt; 定义，则表中没有两个记录可能具有相同的</target>
        </trans-unit>
        <trans-unit id="a81a89d7fe3f234fdfe59b26feaf85b577259ebb" translate="yes" xml:space="preserve">
          <source>No two report groups in the same report &lt;code&gt;RD&lt;/code&gt; may named with the same &amp;lt;</source>
          <target state="translated">同一份报告 &lt;code&gt;RD&lt;/code&gt; 中的两个报告组均不得使用相同的&amp;lt;</target>
        </trans-unit>
        <trans-unit id="d7e5774021597c332a13e1b5235f812224be797b" translate="yes" xml:space="preserve">
          <source>No&lt;code&gt;INVALID KEY&lt;/code&gt;or&lt;code&gt;NOT INVALID KEY&lt;/code&gt;clause may be specified for a file who&amp;rsquo;s&lt;code&gt;ACCESS MODE IS SEQUENTIAL&lt;/code&gt;</source>
          <target state="translated">没有 &lt;code&gt;INVALID KEY&lt;/code&gt; 或 &lt;code&gt;NOT INVALID KEY&lt;/code&gt; 子句可以对文件谁的指定 &lt;code&gt;ACCESS MODE IS SEQUENTIAL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf0db7b3bb9f408f9b74f8f298755ddc3e66b9b8" translate="yes" xml:space="preserve">
          <source>No&lt;code&gt;OCCURS&lt;/code&gt;(see &lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt;) clause may be part of the definition of either the subject or object data items. Either or both, however, may be group items that</source>
          <target state="translated">主题或对象数据项的定义中不得包含 &lt;code&gt;OCCURS&lt;/code&gt; （请参阅&lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt;）子句。但是，这两者之一可能都是</target>
        </trans-unit>
        <trans-unit id="ca1b683a95bedaa03b1b7fa72858ee0c6ecd486e" translate="yes" xml:space="preserve">
          <source>No&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause may be defined on the object data item, and no data items subordinate to the object data item may have&lt;code&gt;VALUE&lt;/code&gt;clauses, with the exception of level-88 condition names.</source>
          <target state="translated">没有 &lt;code&gt;VALUE&lt;/code&gt; （见&lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;）子句可以对目标数据项进行定义，并没有数据项从属于目标数据项可以具有 &lt;code&gt;VALUE&lt;/code&gt; 的条款，与一级88名条件的除外。</target>
        </trans-unit>
        <trans-unit id="25fc4526232d80ffb715ab31181b4409345c2f9b" translate="yes" xml:space="preserve">
          <source>Non-integer fixed point values such as 1.317 or -2.95.</source>
          <target state="translated">非整数定点值,如1.317或-2.95。</target>
        </trans-unit>
        <trans-unit id="e2c9b438099e818e760bdec714a929f4ed0713ad" translate="yes" xml:space="preserve">
          <source>None of &amp;lt;</source>
          <target state="translated">没有&amp;lt;</target>
        </trans-unit>
        <trans-unit id="b822fcd670cee5b981bb06fc3472b35bc909a687" translate="yes" xml:space="preserve">
          <source>None of them may be open at the time the&lt;code&gt;MERGE&lt;/code&gt;is executed.</source>
          <target state="translated">在执行 &lt;code&gt;MERGE&lt;/code&gt; 时，它们都不能打开。</target>
        </trans-unit>
        <trans-unit id="e27f545e660688ab7b2fa768237fd2139f657e72" translate="yes" xml:space="preserve">
          <source>Not all GnuCOBOL implementations support file sharing and record-locking options. Whether they do or not depends upon the operating system they were built for and the build options that were used when the specific GnuCOBOL implementation was generated.</source>
          <target state="translated">并非所有的GnuCOBOL实现都支持文件共享和记录锁定选项。它们是否支持取决于它们的操作系统和生成特定的GnuCOBOL实现时使用的构建选项。</target>
        </trans-unit>
        <trans-unit id="306e41cc992ba155fc93cf3121e83571aae63d84" translate="yes" xml:space="preserve">
          <source>Not all GnuCOBOL implementations support locking. Whether they do or not depends upon the operating system they were built for and the build options that were used when GnuCOBOL was generated. When a program using one of those GnuCOBOL implementations issues an UNLOCK, it will ignored. There will be no compiler message issued. Buffer syncing, if needed, will still occur.</source>
          <target state="translated">并非所有的GnuCOBOL实现都支持锁定。它们是否支持锁定取决于它们的操作系统和生成GnuCOBOL时使用的构建选项。当一个使用这些GnuCOBOL实现的程序发出一个UNLOCK时,它将被忽略。不会有编译器消息发出。如果需要的话,缓冲区同步仍然会发生。</target>
        </trans-unit>
        <trans-unit id="e9c1ce73c055e69ee3402cf0e4efbc368e26f9fc" translate="yes" xml:space="preserve">
          <source>Not all divisions are needed in every program, but they must be specified in the order shown when they</source>
          <target state="translated">并非每个程序中都需要所有的分部,但必须按下列顺序进行指定,当它们</target>
        </trans-unit>
        <trans-unit id="70ba7f89a0cdff0df48d89a63760a916d2a3530e" translate="yes" xml:space="preserve">
          <source>Not specifying an &amp;lt;</source>
          <target state="translated">没有指定&amp;lt;</target>
        </trans-unit>
        <trans-unit id="dc309739aae3a8f2ebf82a717d61d549c5be4bac" translate="yes" xml:space="preserve">
          <source>Note how the COBOL program ensures that a null end-of-string terminator is present on both string arguments.</source>
          <target state="translated">请注意COBOL程序如何确保在两个字符串参数上都有一个空的字符串结束符。</target>
        </trans-unit>
        <trans-unit id="9c109c67ad2b3a941d3d17742fa522392c11f75b" translate="yes" xml:space="preserve">
          <source>Note how the word&lt;code&gt;FUNCTION&lt;/code&gt;is part of the syntax when you use an intrinsic function. You can use intrinsic functions without having to include the reserved word&lt;code&gt;FUNCTION&lt;/code&gt;via settings in the&lt;code&gt;REPOSITORY&lt;/code&gt;(see &lt;a href=&quot;#REPOSITORY&quot;&gt;REPOSITORY&lt;/a&gt;) paragraph. You may accomplish the same thing by specifying the&lt;code&gt;-fintrinsics&lt;/code&gt;switch</source>
          <target state="translated">请注意，当您使用内在函数时， &lt;code&gt;FUNCTION&lt;/code&gt; 一词是语法的一部分。您可以使用内在函数，而不必通过 &lt;code&gt;REPOSITORY&lt;/code&gt; （请参阅&lt;a href=&quot;#REPOSITORY&quot;&gt;REPOSITORY&lt;/a&gt;）段落中的设置来包括保留字 &lt;code&gt;FUNCTION&lt;/code&gt; 。您可以通过指定 &lt;code&gt;-fintrinsics&lt;/code&gt; 开关来完成相同的操作</target>
        </trans-unit>
        <trans-unit id="d04e9fec76c5812c7a9b640cbfeccc8e41ebd984" translate="yes" xml:space="preserve">
          <source>Note how the&lt;code&gt;cobcrun&lt;/code&gt;command does not allow a path to be specified with the program name &amp;mdash; the directory in which the programs dynamically loadable module exists must either be the current directory or must be defined in the current PATH.</source>
          <target state="translated">请注意， &lt;code&gt;cobcrun&lt;/code&gt; 命令如何不允许使用程序名称指定路径-程序动态可加载模块所在的目录必须是当前目录，或者必须在当前PATH中定义。</target>
        </trans-unit>
        <trans-unit id="ec332543bc6a4b8ecabc6857c2e09711a937c08d" translate="yes" xml:space="preserve">
          <source>Note that bit 0 is the right-most bit in the binary value.</source>
          <target state="translated">请注意,位0是二进制值中最右边的位。</target>
        </trans-unit>
        <trans-unit id="2539952aecc19d7b3a92ef3357fabc279c56a247" translate="yes" xml:space="preserve">
          <source>Note that even though we told GnuCOBOL that the 1st argument was to be&lt;code&gt;BY VALUE&lt;/code&gt; it was treated as if it were&lt;code&gt;BY REFERENCE&lt;/code&gt;anyway. String (char array) arguments passed from C callers to GnuCOBOL subprograms will be modifiable by the subprogram. It&amp;rsquo;s best to pass a copy of such data if you want to ensure that the subprogram doesn&amp;rsquo;t change it.</source>
          <target state="translated">请注意，即使我们告诉GnuCOBOL第一个参数是 &lt;code&gt;BY VALUE&lt;/code&gt; ，无论如何它仍被视为 &lt;code&gt;BY REFERENCE&lt;/code&gt; 。从C调用者传递给GnuCOBOL子程序的字符串（字符数组）参数将可由该子程序修改。如果要确保子程序不会更改它，最好传递此类数据的副本。</target>
        </trans-unit>
        <trans-unit id="871c018f1f8ef5bab7bedbfc57441be80385c284" translate="yes" xml:space="preserve">
          <source>Note that the OUTPUT phrase changes the way in which the default field size is computed. See that heading above for details. Also note that the OUTPUT phrase affects only the way items are displayed on the screen; the internal format of accepted data is not affected.</source>
          <target state="translated">请注意,OUTPUT短语改变了计算默认字段大小的方式。详情请看上面的标题。还请注意,OUTPUT短语只影响项目在屏幕上的显示方式,接受数据的内部格式不受影响。</target>
        </trans-unit>
        <trans-unit id="1fbd4eeb5f6972ceb99cdf3aac9f4be0886c77cb" translate="yes" xml:space="preserve">
          <source>Note that the legacy name of this routine starts with CBL_OC is deprecated, as is HOSTED but will still work. It is recommended that all libary routines names starting with CBL_OC are replaced with CBL_GC to minimise issues.</source>
          <target state="translated">请注意,这个例程以 CBL_OC 开头的传统名称已被废弃,HOSTED 也是如此,但仍然可以使用。建议将所有以CBL_OC开头的libary例程名称替换为CBL_GC,以减少问题。</target>
        </trans-unit>
        <trans-unit id="7a40b40bf40810b907f7cf0d8aaaa83843011c4d" translate="yes" xml:space="preserve">
          <source>Note that the legacy name of this routine that starts with CBL_OC is deprecated, as is NANOSLEEP but will still work. It is recommended that all libary routines names starting with CBL_OC are replaced with CBL_GC to minimise issues.</source>
          <target state="translated">请注意,这个例程以CBL_OC开头的传统名称已被废弃,NANOSLEEP也是如此,但仍然可以使用。建议将所有以CBL_OC开头的libary例程名称替换为CBL_GC,以减少问题。</target>
        </trans-unit>
        <trans-unit id="efe51ebdd06327d81c22d954a952f012e8b5debd" translate="yes" xml:space="preserve">
          <source>Note that the value returned by this function is not the number of</source>
          <target state="translated">需要注意的是,这个函数返回的值并不是指的是</target>
        </trans-unit>
        <trans-unit id="f3452b747551a3e31882fb7b479a113ecf58accb" translate="yes" xml:space="preserve">
          <source>Note that these errors include but are not limited to: argument (string) is zero length, contains only spaces or contains valid characters but is incomplete, such as the string &quot;+.&quot;.</source>
          <target state="translated">需要注意的是,这些错误包括但不限于:参数(字符串)长度为零、只包含空格或包含有效字符但不完整,如字符串 &quot;+.&quot;。</target>
        </trans-unit>
        <trans-unit id="cc0412d45415b86da0a43a8c1ca6e6dc158f2456" translate="yes" xml:space="preserve">
          <source>Note that what constitutes a &quot;letter&quot; (or upper/lower case too, for that manner) may be influenced through the use of&lt;code&gt;CHARACTER CLASSIFICATION&lt;/code&gt;specifications in the&lt;code&gt;OBJECT-COMPUTER&lt;/code&gt;(see &lt;a href=&quot;#OBJECT_002dCOMPUTER&quot;&gt;OBJECT-COMPUTER&lt;/a&gt;) paragraph.</source>
          <target state="translated">请注意，构成&amp;ldquo;字母&amp;rdquo;的内容（或以这种方式也代表大写/小写字母）可能会受到 &lt;code&gt;OBJECT-COMPUTER&lt;/code&gt; （请参阅&lt;a href=&quot;#OBJECT_002dCOMPUTER&quot;&gt;对象计算机&lt;/a&gt;）段落中 &lt;code&gt;CHARACTER CLASSIFICATION&lt;/code&gt; 规范的使用的影响。</target>
        </trans-unit>
        <trans-unit id="5d3c2b08b61d1a38bbeee29bc320c48df653d057" translate="yes" xml:space="preserve">
          <source>Note that you cannot supply the CONVERT phrase in the Screen Section. Thus the size of a Screen Section field is always the size of its screen entry unless the SIZE phrase is specified.</source>
          <target state="translated">请注意,您不能在屏幕部分提供convert短语,因此,屏幕部分字段的大小总是其屏幕条目的大小,除非指定SIZE短语。因此,除非指定SIZE短语,否则屏幕部分字段的大小始终是其屏幕条目的大小。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="28b8e9bdefe3979b0685c44999ad9084995ed4c9" translate="yes" xml:space="preserve">
          <source>Now observe the following code, which will execute the&lt;code&gt;150-Process-Hex-Value&lt;/code&gt;procedure if&lt;code&gt;Entered-Value&lt;/code&gt;contains nothing but valid hexadecimal digits:</source>
          <target state="translated">现在观察以下代码，如果 &lt;code&gt;Entered-Value&lt;/code&gt; 除了有效的十六进制数字之外，什么都将执行 &lt;code&gt;150-Process-Hex-Value&lt;/code&gt; 过程：</target>
        </trans-unit>
        <trans-unit id="d9e0e91f86531814b287253e68ce747a1135f32c" translate="yes" xml:space="preserve">
          <source>Now that you know</source>
          <target state="translated">现在你知道了</target>
        </trans-unit>
        <trans-unit id="d0861e2e052b3dc839be9fe7e44875aa59ec9523" translate="yes" xml:space="preserve">
          <source>Now there can be no confusion as to which CITY is being changed. Fortunately, you don&amp;rsquo;t need to be quite so specific; COBOL allows intermediate and unnecessary qualification levels to be omitted. This allows&lt;code&gt;MOVE 'Philadelphia' TO CITY OF EMPLOYEE&lt;/code&gt;to do the job nicely.</source>
          <target state="translated">现在，对于哪个城市正在更改，不会造成混淆。幸运的是，您不需要这么具体；COBOL允许省略中间和不必要的资格等级。这使将 &lt;code&gt;MOVE 'Philadelphia' TO CITY OF EMPLOYEE&lt;/code&gt; 可以做得很好。</target>
        </trans-unit>
        <trans-unit id="219877a3941189d29da78605ffc816ab5f2a7b89" translate="yes" xml:space="preserve">
          <source>Now, assume that another program reads this file, but describes 10-character records rather than 6. Here are the records</source>
          <target state="translated">现在,假设另一个程序读取这个文件,但描述的是10个字符的记录,而不是6个字符的记录,以下是这些记录</target>
        </trans-unit>
        <trans-unit id="9b0d34c0dc28860109b36ba3a6f8a912103ad454" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s deal with the problem of setting the CITY portion of an EMPLOYEEs MAILING-ADDRESS to &quot;Philadelphia&quot;. Clearly,&lt;code&gt;MOVE 'Philadelphia' TO CITY&lt;/code&gt;cannot work because the compiler will be unable to determine which of the two CITY fields you are referring to.</source>
          <target state="translated">现在，让我们处理将雇员的邮件地址的城市部分设置为&amp;ldquo;费城&amp;rdquo;的问题。显然， &lt;code&gt;MOVE 'Philadelphia' TO CITY&lt;/code&gt; 无法正常工作，因为编译器将无法确定您所引用的两个CITY字段中的哪一个。</target>
        </trans-unit>
        <trans-unit id="ce50db412280505597bf9414695fbcc5fc0e3f7b" translate="yes" xml:space="preserve">
          <source>Now, the roles of the two languages in the previous section will be reversed, having a C main program execute a GnuCOBOL subprogram.</source>
          <target state="translated">现在,上一节中两种语言的角色将颠倒过来,让一个C主程序执行一个GnuCOBOL子程序。</target>
        </trans-unit>
        <trans-unit id="f60c8b64229a047f941675b68f85587ecce4b520" translate="yes" xml:space="preserve">
          <source>Numeric Data Item</source>
          <target state="translated">数值数据项</target>
        </trans-unit>
        <trans-unit id="c9fbc7f3c5ecccd87db3e696a9c121879251fe81" translate="yes" xml:space="preserve">
          <source>Numeric Edited</source>
          <target state="translated">数字编辑</target>
        </trans-unit>
        <trans-unit id="63ddf527a277f4c347e2246f00b1c4f8cda03669" translate="yes" xml:space="preserve">
          <source>Numeric Edited Data Item</source>
          <target state="translated">数值编辑数据项</target>
        </trans-unit>
        <trans-unit id="a24a22f9b40fcfe4d2691a6016ec524613059e17" translate="yes" xml:space="preserve">
          <source>Numeric Literal</source>
          <target state="translated">数值字面</target>
        </trans-unit>
        <trans-unit id="be2d608e3fa3ed6ad269186745305eb23ec33b56" translate="yes" xml:space="preserve">
          <source>Numeric data items will be initialized to a value of&lt;code&gt;ZERO&lt;/code&gt;</source>
          <target state="translated">数值数据项将初始化 &lt;code&gt;ZERO&lt;/code&gt; 值</target>
        </trans-unit>
        <trans-unit id="289405511920b64e6183e96801f299b0a1170932" translate="yes" xml:space="preserve">
          <source>Numeric keypad keys are not recognizable on Windows MinGW/PDCurses builds of GnuCOBOL, regardless of the number lock settings. Windows Cygwin/NCurses builds recognize numeric keypad inputs properly. Although not tested during the preparation of this documentation, I would expect native Windows builds using PDCurses to behave as MinGW builds do and native Unix builds using NCurses to behave as do Cygwin builds.</source>
          <target state="translated">在Windows MinGW/PDCurses构建的GnuCOBOL上,无论数字锁定设置如何,数字键盘键都无法识别。Windows Cygwin/NCurses构建的GnuCOBOL可以正确识别数字键盘输入。虽然在编写本文档时没有进行测试,但我希望使用PDCurses的Windows本地构建能够像MinGW构建一样,而使用NCurses的Unix本地构建能够像Cygwin构建一样。</target>
        </trans-unit>
        <trans-unit id="8eeea7541c21f9801d7c1875ed5f9c434348ce35" translate="yes" xml:space="preserve">
          <source>Numeric literals may be split across lines just as alphanumeric literals are, using either of the above techniques and both reserved and user-defined words can be split across lines too (using the first technique). The continuation of numeric literals and user-defined/reserved words is provided merely to provide compatibility with older COBOL versions and programs, but should not be used with new programs &amp;mdash; it just makes for ugly-looking programs.</source>
          <target state="translated">使用以上两种技术之一，数字文字都可以像字母数字文字一样跨行分割，并且保留字和用户定义的词也可以跨行分割（使用第一种技术）。提供数字文字和用户定义/保留字的连续性仅仅是为了提供与较旧的COBOL版本和程序的兼容性，而不能与新程序一起使用-它只会使外观难看的程序。</target>
        </trans-unit>
        <trans-unit id="6f2932e8faff18c0314f3a04f9aec75edec07a2f" translate="yes" xml:space="preserve">
          <source>OBJECT, OBJECT-COMPUTER, OBJECT-REFERENCE, OCCURS, OF, OFF, OMITTED, ON, ONLY, OPEN, OPTIONAL, OPTIONS, OR, ORD, ORDER, ORD-MAX, ORD-MIN, ORGANISATION, ORGANIZATION, OTHER, OUTPUT, OVERFLOW, OVERLINE, OVERRIDE</source>
          <target state="translated">OBJECT,OBJECT-COMPUTER,OBJECT-REFERENCE,OCCURS,OF,OFF,OMITTED,ON,ONLY,OPEN,OPTIONAL,OPTIONS,OR,ORD,ORDER,ORD-MAX,ORD-MIN,ORGANISATION,ORGANIZATION,OTHER,OUTPUT,OVERFLOW,OVERLINE,OVERRIDE。</target>
        </trans-unit>
        <trans-unit id="2e78bec2d3800e6a21f1a284d7a3afd18c2fcd63" translate="yes" xml:space="preserve">
          <source>OBJECT-COMPUTER Syntax</source>
          <target state="translated">OBJECT-COMPUTER 语法说明</target>
        </trans-unit>
        <trans-unit id="cec1574213ff5c57fb26687d05dd766be420fc2b" translate="yes" xml:space="preserve">
          <source>OCCURS &amp;hellip; DEPENDING ON data item out of bounds</source>
          <target state="translated">发生&amp;hellip;&amp;hellip;依赖于数据项超出范围</target>
        </trans-unit>
        <trans-unit id="b800486653c7a1c77e853e0c004749a0fd2748a9" translate="yes" xml:space="preserve">
          <source>OCCURS (All Other Sections Clause Syntax</source>
          <target state="translated">OCCURS (所有其他章节条款语法)</target>
        </trans-unit>
        <trans-unit id="dd0b3221d40b5306dd784b27996de5c44ec57b1a" translate="yes" xml:space="preserve">
          <source>OCCURS (REPORT SECTION) Clause Syntax</source>
          <target state="translated">OCCURS(报告部分)子句语法</target>
        </trans-unit>
        <trans-unit id="6b31ee2b7fdf9b827a81f695d24c794e1825c9ac" translate="yes" xml:space="preserve">
          <source>OCCURS (SCREEN SECTION) Clause Syntax</source>
          <target state="translated">OCCURS (SCREEN SECTION)子句语法</target>
        </trans-unit>
        <trans-unit id="12163d548f84d0d3a65be49f9405b588882fb830" translate="yes" xml:space="preserve">
          <source>ON EXCEPTION Syntax</source>
          <target state="translated">ON EXCEPTION 语法</target>
        </trans-unit>
        <trans-unit id="fae727086e90c1747900d70ffd7f8b15f8dbda95" translate="yes" xml:space="preserve">
          <source>ON OVERFLOW Syntax</source>
          <target state="translated">ON OVERFLOW 命令格式</target>
        </trans-unit>
        <trans-unit id="66bebaca5aeeed104d7154b3d0f92463c9dd8dd1" translate="yes" xml:space="preserve">
          <source>ON SIZE ERROR Syntax</source>
          <target state="translated">ON SIZE ERROR 语法</target>
        </trans-unit>
        <trans-unit id="36dfa4bed24bebe94e869396499f245644973c4a" translate="yes" xml:space="preserve">
          <source>OPEN Syntax</source>
          <target state="translated">OPEN 语法</target>
        </trans-unit>
        <trans-unit id="cf0fe9af8bea7d1e731289cfef0c8038f4bc83dd" translate="yes" xml:space="preserve">
          <source>ORD Function Syntax</source>
          <target state="translated">ORD 函数语法</target>
        </trans-unit>
        <trans-unit id="9ad6006b98ba7b9576a4512aa283c527f6a05c6a" translate="yes" xml:space="preserve">
          <source>ORD-MAX Function Syntax</source>
          <target state="translated">ORD-MAX 函数语法</target>
        </trans-unit>
        <trans-unit id="09ee84df5eb17ff7d1f3553b1cbd5d58418d7791" translate="yes" xml:space="preserve">
          <source>ORD-MIN Function Syntax</source>
          <target state="translated">ORD-MIN 函数语法</target>
        </trans-unit>
        <trans-unit id="08b26f9634d2a732e998aa2218316415ad38194c" translate="yes" xml:space="preserve">
          <source>ORGANIZATION INDEXED Clause Syntax</source>
          <target state="translated">ORGANIZATION INDEXED 子句句式。</target>
        </trans-unit>
        <trans-unit id="2df4622dcdea677d5d9a83663b8cbf91c2189a6b" translate="yes" xml:space="preserve">
          <source>ORGANIZATION LINE SEQUENTIAL Clause Syntax</source>
          <target state="translated">组织线序列式子句语法</target>
        </trans-unit>
        <trans-unit id="86ee1da50c2e8a0ec7111d29363f3c837bd97118" translate="yes" xml:space="preserve">
          <source>ORGANIZATION RELATIVE Clause Syntax</source>
          <target state="translated">ORGANIZATION RELATIVE 子句 语法</target>
        </trans-unit>
        <trans-unit id="750186647b33c3656503302d8eccc530bc37f0af" translate="yes" xml:space="preserve">
          <source>ORGANIZATION SEQUENTIAL Clause Syntax</source>
          <target state="translated">ORGANIZATION SEQUENTIAL 子句语法</target>
        </trans-unit>
        <trans-unit id="578fbcff15d7037e9429c12a53b4d74f6a1577f1" translate="yes" xml:space="preserve">
          <source>OS/2 &quot;OPTLINK&quot; conventions will be used to CALL the subprogram.</source>
          <target state="translated">OS/2的 &quot;OPTLINK &quot;约定将被用于CALL子程序。</target>
        </trans-unit>
        <trans-unit id="c666501d06dc9305a9b7b68de3b3d3562fd28b49" translate="yes" xml:space="preserve">
          <source>OS/2 &quot;OPTLINK&quot; conventions will not be used to CALL the subprogram.</source>
          <target state="translated">OS/2的 &quot;OPTLINK &quot;约定将不会被用于CALL子程序。</target>
        </trans-unit>
        <trans-unit id="c8e1209593b1149f5f3f8ee76008515520f2193a" translate="yes" xml:space="preserve">
          <source>OVERLINE Attribute Syntax</source>
          <target state="translated">OVERLINE 属性语法</target>
        </trans-unit>
        <trans-unit id="4924a4d3bf56aa4a828e65f5066f009ce7e62b7d" translate="yes" xml:space="preserve">
          <source>Observe the definitions of data items &quot;Q&quot; and &quot;Y&quot;&amp;hellip;</source>
          <target state="translated">遵守数据项&amp;ldquo; Q&amp;rdquo;和&amp;ldquo; Y&amp;rdquo;的定义&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="46c20583dd7802c40938fc2ba6c6048df2b3e1e9" translate="yes" xml:space="preserve">
          <source>Observe the following example, which illustrates a fourth manner in which tables may be initialized in GnuCOBOL:</source>
          <target state="translated">请看下面的例子,它说明了在GnuCOBOL中初始化表的第四种方式。</target>
        </trans-unit>
        <trans-unit id="cec634d4f1c842c1c34e5d70b1e1bba15a325f09" translate="yes" xml:space="preserve">
          <source>Of course, arithmetic expression operands may be numeric data items (any USAGE except POINTER or PROGRAM POINTER) as well as numeric literals.</source>
          <target state="translated">当然,算术表达式操作数可以是数字数据项(除POINTER或PROGRAM POINTER外的任何USAGE),也可以是数字文字。</target>
        </trans-unit>
        <trans-unit id="78a794760583154700dfa158ef52ff59305ad6d4" translate="yes" xml:space="preserve">
          <source>Of course, in keeping with the long-standing COBOL tradition of maintaining backwards compatibility with older standards, programmers (and, of course, compliant COBOL compilers) are capable of working in either mode. It is even possible to switch back and forth in the same program. The terms &amp;rsquo;</source>
          <target state="translated">当然，为了与长期保持向后兼容旧标准的COBOL传统保持一致，程序员（当然还有兼容的COBOL编译器）可以在任何一种模式下工作。甚至可以在同一程序中来回切换。条款 '</target>
        </trans-unit>
        <trans-unit id="c2e2ad12fe5d5be1ef373c4a92ce471d2c101183" translate="yes" xml:space="preserve">
          <source>Of course, whatever software you are using to deliver the printed document to the printer with must allow the ASCII form-feed character to pass through to the printer.</source>
          <target state="translated">当然,无论您使用什么软件将打印的文档传送给打印机,都必须允许ASCII格式进纸字符通过打印机。</target>
        </trans-unit>
        <trans-unit id="debcb349f44f33085c8c31a98daa95f7f75004d5" translate="yes" xml:space="preserve">
          <source>Of those currency symbols that correspond to character positions in which leading zeros reside, the right-most will have its &quot;0&quot; value replaced by the currency symbol in-effect for the program (see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;). Any remaining leading zero values occupying positions described by this symbol will be replaced by spaces.</source>
          <target state="translated">在与前导零所在的字符位置相对应的那些货币符号中，最右端的&amp;ldquo; 0&amp;rdquo;值将被程序中无效的货币符号替换（请参阅&lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;）。该符号描述的任何剩余的占据位置零的前导零值将被空格替换。</target>
        </trans-unit>
        <trans-unit id="6b4cb7a0fee3f3079461060f2f2b75e5bfc06ee6" translate="yes" xml:space="preserve">
          <source>Of those&lt;code&gt;+&lt;/code&gt;symbols that correspond to character positions in which leading zeros reside, the right-most will have its &quot;0&quot; value replaced by a &quot;+&quot; if the value in the data item is zero or greater or a &quot;-&quot; otherwise. Any remaining leading zero values occupying positions described by this symbol will be replaced by spaces. You cannot use both&lt;code&gt;+&lt;/code&gt;and&lt;code&gt;-&lt;/code&gt;in the same &amp;lt;</source>
          <target state="translated">在与前导零所在的字符位置相对应的那些 &lt;code&gt;+&lt;/code&gt; 符号中，如果数据项中的值为零或更大，则最右边的&amp;ldquo; 0&amp;rdquo;值将由&amp;ldquo; +&amp;rdquo;替换，否则为&amp;ldquo;-&amp;rdquo;。该符号描述的任何剩余的占据位置零的前导零值将被空格替换。你不能同时使用 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt; 在同一&amp;lt;</target>
        </trans-unit>
        <trans-unit id="bbf75e8475f5c8168cfdefa614e07198b0695e55" translate="yes" xml:space="preserve">
          <source>Of those&lt;code&gt;-&lt;/code&gt;symbols that correspond to character positions in which leading zeros reside, the right-most will have its &quot;0&quot; value replaced by a space if the value in the data item is zero or greater or a &quot;-&quot; otherwise. Any remaining leading zero values occupying positions described by this symbol will be replaced by spaces. You cannot use both&lt;code&gt;+&lt;/code&gt;and&lt;code&gt;-&lt;/code&gt;in the same &amp;lt;</source>
          <target state="translated">在那些与前导零所在的字符位置相对应的 &lt;code&gt;-&lt;/code&gt; 符号中，如果数据项中的值为零或更大，则最右边的&amp;ldquo; 0&amp;rdquo;值将由空格替换，否则为&amp;ldquo;-&amp;rdquo;。该符号描述的任何剩余的占据位置零的前导零值将被空格替换。你不能同时使用 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt; 在同一&amp;lt;</target>
        </trans-unit>
        <trans-unit id="8b1fab1aa655192e46dd089ef5dc5c15017129e0" translate="yes" xml:space="preserve">
          <source>On UNIX (including OSX, Windows/Cygwin and Windows/MinGW) systems, your locale is established via the</source>
          <target state="translated">在UNIX(包括OSX、Windows/Cygwin和Windows/MinGW)系统上,您的locale是通过以下方式建立的</target>
        </trans-unit>
        <trans-unit id="7a4815ab2f080a81cd2be95835f85ca49905ca48" translate="yes" xml:space="preserve">
          <source>On Unix, OSX, or Windows/Cygwin builds, the&lt;code&gt;-x&lt;/code&gt;switch switch will generate an executable binary file, usually with no particular extension unless one is explicitly requested of the compiler via the&lt;code&gt;-o&lt;/code&gt;switch</source>
          <target state="translated">在Unix，OSX或Windows / Cygwin版本上， &lt;code&gt;-x&lt;/code&gt; 开关将生成可执行的二进制文件，通常没有特定扩展名，除非通过 &lt;code&gt;-o&lt;/code&gt; 开关明确要求编译器</target>
        </trans-unit>
        <trans-unit id="baa101f65e9944384124638ea3189587789c566a" translate="yes" xml:space="preserve">
          <source>On Windows systems, single-quote, or apostrophe characters (&amp;rsquo;) will be treated just like any other data character and will NOT delineate argument strings.</source>
          <target state="translated">在Windows系统上，单引号或撇号字符（'）将像其他任何数据字符一样被对待，并且不会划定参数字符串。</target>
        </trans-unit>
        <trans-unit id="4540801fc126e86f0e453dd121110c00baa3a3f3" translate="yes" xml:space="preserve">
          <source>On a UNIX system this means the programs may be executed from a command shell such as bash, csh, ksh and so forth. When a GnuCOBOL program runs on a Windows system, it runs within a console window (i.e. &quot;cmd.exe&quot;). OSX versions of GnuCOBOL programs run within a &quot;terminal.app&quot; window.</source>
          <target state="translated">在UNIX系统中,这意味着程序可以从命令壳中执行,如bash、csh、ksh等。当GnuCOBOL程序在Windows系统上运行时,它在一个控制台窗口中运行(即 &quot;cmd.exe&quot;)。OSX版本的GnuCOBOL程序是在 &quot;terminal.app &quot;窗口中运行的。</target>
        </trans-unit>
        <trans-unit id="29e07a8440be1b45abe631d62a1c13d7f8e27480" translate="yes" xml:space="preserve">
          <source>On a Unix system, the shell environment will be established using the default shell program. This is also true when using a GnuCOBOL build created with and for OSX or the Cygwin Unix emulator.</source>
          <target state="translated">在Unix系统上,shell环境将使用默认的shell程序来建立,这在使用OSX或Cygwin Unix模拟器创建的GnuCOBOL构建时也是如此。当使用OSX或Cygwin Unix模拟器创建的GnuCOBOL构建时也是如此。</target>
        </trans-unit>
        <trans-unit id="09cea21f0e62fb9defc06b78067faf5ba65df913" translate="yes" xml:space="preserve">
          <source>On a Windows system, the&lt;code&gt;TMP&lt;/code&gt;environment variable is normally set for you when you logon. If you wish to use a different temporary folder, you may set&lt;code&gt;TMPDIR&lt;/code&gt;yourself and have no fear of disrupting other Windows software that relies on TMP.</source>
          <target state="translated">在Windows系统上，登录时通常会为您设置 &lt;code&gt;TMP&lt;/code&gt; 环境变量。如果希望使用其他临时文件夹，则可以自己设置 &lt;code&gt;TMPDIR&lt;/code&gt; ，而不必担心破坏依赖TMP的其他Windows软件。</target>
        </trans-unit>
        <trans-unit id="49c811f291ecda0c24fa5479b92e28877266432a" translate="yes" xml:space="preserve">
          <source>On a system supporting only one format of binary storage (generally, that would be big-endian), the terms &amp;rsquo;most-efficient&amp;rsquo; and &amp;rsquo;native format&amp;rsquo; are synonymous.</source>
          <target state="translated">在仅支持一种二进制存储格式（通常为big-endian）的系统上，术语&amp;ldquo;最高效&amp;rdquo;和&amp;ldquo;本机格式&amp;rdquo;是同义词。</target>
        </trans-unit>
        <trans-unit id="8cf55637bf6e9946a839f557065a9756657be924" translate="yes" xml:space="preserve">
          <source>On the first presentation of the detail group after any control break occurs.</source>
          <target state="translated">在任何控制断裂发生后,细节组的第一次呈现。</target>
        </trans-unit>
        <trans-unit id="e5bea69f1d184e8b4396de7835faab7aa40b288f" translate="yes" xml:space="preserve">
          <source>On the first presentation of the detail group after every new page is started.</source>
          <target state="translated">在每一个新的页面开始后,细节组的第一次呈现。</target>
        </trans-unit>
        <trans-unit id="17545f79b06e402b5aa4758aadea0e8d4f7b4497" translate="yes" xml:space="preserve">
          <source>On the first presentation of the detail group following the&lt;code&gt;INITIATE&lt;/code&gt;(see &lt;a href=&quot;#INITIATE&quot;&gt;INITIATE&lt;/a&gt;) of the report.</source>
          <target state="translated">在报告的 &lt;code&gt;INITIATE&lt;/code&gt; （请参阅&lt;a href=&quot;#INITIATE&quot;&gt;INITIATE&lt;/a&gt;）之后的详细信息组的第一个演示中。</target>
        </trans-unit>
        <trans-unit id="621bb9957748f1c9660b66609e36e16b3f8976de" translate="yes" xml:space="preserve">
          <source>Once GnuCOBOL programs have been compiled into either directly-executable programs (created via the&lt;code&gt;-x&lt;/code&gt;switch) or dynamically-loadable libraries (created via the&lt;code&gt;-m&lt;/code&gt;switch), those programs may be executed from any shell environment. The exact manner in which the two are executed will differ, as described in the upcoming sections.</source>
          <target state="translated">一旦将GnuCOBOL程序编译为可直接执行的程序（通过 &lt;code&gt;-x&lt;/code&gt; 开关创建）或可动态加载的库（通过 &lt;code&gt;-m&lt;/code&gt; 开关创建），则可以从任何Shell环境中执行这些程序。如后面几节所述，执行两者的确切方式将有所不同。</target>
        </trans-unit>
        <trans-unit id="77004179f0b5866728a6a173ab6e2cd8c6678cae" translate="yes" xml:space="preserve">
          <source>Once a Format 1&lt;code&gt;REPLACE&lt;/code&gt;statement is encountered in the currently-compiling source file, Replace Mode becomes active, and the change(s) specified by that statement will be automatically made on all subsequent source statements the compiler reads from the file.</source>
          <target state="translated">在当前正在编译的源文件中遇到Format 1 &lt;code&gt;REPLACE&lt;/code&gt; 语句后，替换模式将变为活动状态，并且该语句指定的更改将自动在编译器从文件读取的所有后续源语句中进行。</target>
        </trans-unit>
        <trans-unit id="dc16e338caa3250507aeb7e1c7c59077ca7fc160" translate="yes" xml:space="preserve">
          <source>Once a dynamically-loadable module is actually loaded into memory, even if it is subsequently unloaded (via the&lt;code&gt;CANCEL&lt;/code&gt;statement), it&amp;rsquo;s list of entry-points remain available to the GnuCOBOL run-time library and subsequent re-executions of any of those entry points will be able to bypass the search (rule #4) as well as the &quot;first-execution rule&quot; (rule #3).</source>
          <target state="translated">一旦将可动态加载的模块实际加载到内存中，即使随后将其卸载（通过 &lt;code&gt;CANCEL&lt;/code&gt; 语句），它的入口点列表仍可用于GnuCOBOL运行时库，并随后重新执行其中的任何条目点将能够绕过搜索（规则4）以及&amp;ldquo;首次执行规则&amp;rdquo;（规则3）。</target>
        </trans-unit>
        <trans-unit id="59e918dab4bdf59a27422aa9bebbbdf5591d8385" translate="yes" xml:space="preserve">
          <source>Once a field list has been determined, each item in that field list will be initialized as if an individual&lt;code&gt;MOVE&lt;/code&gt;(see &lt;a href=&quot;#MOVE&quot;&gt;MOVE&lt;/a&gt;) statement to that effect had been coded. The rules for initialization are as follows:</source>
          <target state="translated">一旦确定了字段列表，该字段列表中的每个项目都将被初始化，就好像已经编码了一个单独的 &lt;code&gt;MOVE&lt;/code&gt; 语句（参见&lt;a href=&quot;#MOVE&quot;&gt;MOVE&lt;/a&gt;）一样。初始化规则如下：</target>
        </trans-unit>
        <trans-unit id="286757838794003214e83168a9d3c53442e79df6" translate="yes" xml:space="preserve">
          <source>Once an environment variable name base (let&amp;rsquo;s refer to it as &quot;bbbb&quot;) has been determined, the runtime system will look for the first one of the following environment variables that exists, in this sequence:</source>
          <target state="translated">一旦确定了环境变量名称库（我们将其称为&amp;ldquo; bbbb&amp;rdquo;），则运行时系统将按以下顺序查找存在的以下环境变量中的第一个：</target>
        </trans-unit>
        <trans-unit id="e625244fde391b91510dca176749dade404d9a46" translate="yes" xml:space="preserve">
          <source>Once class &quot;Hexadecimal&quot; has been defined, program code could then use a statement such as&lt;code&gt;IF input-item IS Hexadecimal&lt;/code&gt;to determine if the value of characters in a data item are valid according to that class.</source>
          <target state="translated">一旦定义了&amp;ldquo;十六进制&amp;rdquo;类别，程序代码便可以使用诸如 &lt;code&gt;IF input-item IS Hexadecimal&lt;/code&gt; 类的语句来确定数据项中的字符值是否根据该类别有效。</target>
        </trans-unit>
        <trans-unit id="0585d2910d0c3575c9ce966ec284963466eee0b8" translate="yes" xml:space="preserve">
          <source>Once in that form, mathematical operations may be performed against the internal date before it is transformed back into a date using the&lt;code&gt;DATE-OF-INTEGER&lt;/code&gt;(see &lt;a href=&quot;#DATE_002dOF_002dINTEGER&quot;&gt;DATE-OF-INTEGER&lt;/a&gt;) or&lt;code&gt;DAY-OF-INTEGER&lt;/code&gt;(see &lt;a href=&quot;#DAY_002dOF_002dINTEGER&quot;&gt;DAY-OF-INTEGER&lt;/a&gt;) function.</source>
          <target state="translated">一旦采用这种形式，就可以对内部日期执行数学运算，然后再使用 &lt;code&gt;DATE-OF-INTEGER&lt;/code&gt; （请参阅&lt;a href=&quot;#DATE_002dOF_002dINTEGER&quot;&gt;DATE-OF-INTEGER&lt;/a&gt;）或 &lt;code&gt;DAY-OF-INTEGER&lt;/code&gt; （请参阅&lt;a href=&quot;#DAY_002dOF_002dINTEGER&quot;&gt;DAY-OF-INTEGER&lt;/a&gt;）将其转换回日期。）功能。</target>
        </trans-unit>
        <trans-unit id="3d181d18b6a5fa0a6fa8cff3acb56941d7cd3053" translate="yes" xml:space="preserve">
          <source>Once read from the file, the newly-retrieved record data will be saved into the 01-level record structure(s) that immediately follow the file&amp;rsquo;s&lt;code&gt;FD&lt;/code&gt; If the optional&lt;code&gt;INTO&lt;/code&gt;</source>
          <target state="translated">一旦从文件中读取，新建，检索记录的数据将被保存到01级别的记录结构（一个或多个）紧跟在文件的 &lt;code&gt;FD&lt;/code&gt; 如果可选 &lt;code&gt;INTO&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed7991d9259d5488ffed54f05830f63330c16c88" translate="yes" xml:space="preserve">
          <source>Once the &amp;lt;</source>
          <target state="translated">一次&amp;lt;</target>
        </trans-unit>
        <trans-unit id="76eaa092cafda97efbcf2f6303d6984802250d02" translate="yes" xml:space="preserve">
          <source>Once the address of a procedure division code area has been acquired in this way, the address could be passed to a subroutine (usually written in C) for whatever use it needs it for. For examples of&lt;code&gt;PROGRAM-POINTER&lt;/code&gt; at work, see the discussions of the&lt;code&gt;CBL_ERROR_PROC&lt;/code&gt;built-in system subroutine (see &lt;a href=&quot;#CBL_005fERROR_005fPROC&quot;&gt;CBL_ERROR_PROC&lt;/a&gt;) and&lt;code&gt;CBL_EXIT_PROC&lt;/code&gt;built-in system subroutine (see &lt;a href=&quot;#CBL_005fEXIT_005fPROC&quot;&gt;CBL_EXIT_PROC&lt;/a&gt;).</source>
          <target state="translated">一旦以此方式获取了过程划分代码区的地址，就可以将该地址传递给子例程（通常用C编写）以用于其所需的用途。有关工作中的 &lt;code&gt;PROGRAM-POINTER&lt;/code&gt; 的示例，请参见 &lt;code&gt;CBL_ERROR_PROC&lt;/code&gt; 内置系统子例程（请参阅&lt;a href=&quot;#CBL_005fERROR_005fPROC&quot;&gt;CBL_ERROR_PROC&lt;/a&gt;）和 &lt;code&gt;CBL_EXIT_PROC&lt;/code&gt; 内置系统子例程（请参见&lt;a href=&quot;#CBL_005fEXIT_005fPROC&quot;&gt;CBL_EXIT_PROC&lt;/a&gt;）的讨论。</target>
        </trans-unit>
        <trans-unit id="e7b3e993beace23677f33388c1750dc84928bf9a" translate="yes" xml:space="preserve">
          <source>Once the dynamically-loadable module has been successfully loaded, any of the entry-points contained within it are now available for reference.</source>
          <target state="translated">一旦可动态加载的模块被成功加载,其中包含的任何一个入口点现在都可供参考。</target>
        </trans-unit>
        <trans-unit id="bf655804b96355c58d780ad7c184b2358e70ed87" translate="yes" xml:space="preserve">
          <source>Once the input procedure terminates, the input phase is complete.</source>
          <target state="translated">一旦输入程序终止,输入阶段就完成了。</target>
        </trans-unit>
        <trans-unit id="3fd5f8ce1885cd5e6704d4107925ee0fa79ae370" translate="yes" xml:space="preserve">
          <source>Once the list of control breaks has been determined, the&lt;code&gt;CONTROL FOOTING&lt;/code&gt;for each &amp;lt;</source>
          <target state="translated">一旦控制中断的列表已被确定，则 &lt;code&gt;CONTROL FOOTING&lt;/code&gt; 每个&amp;lt;</target>
        </trans-unit>
        <trans-unit id="da82fa2addff5a8b53971b5198ac5b3f2dbaf44c" translate="yes" xml:space="preserve">
          <source>Once the module has been located (if location was needed), it will be loaded into memory (if not already loaded).</source>
          <target state="translated">一旦模块被定位(如果需要定位),它将被加载到内存中(如果尚未加载)。</target>
        </trans-unit>
        <trans-unit id="4ea7f4222f4e79b517953879f7a0910e37dccbb7" translate="yes" xml:space="preserve">
          <source>Once the output procedure terminates, or the last &amp;lt;</source>
          <target state="translated">输出过程终止后，或最后一个&amp;lt;</target>
        </trans-unit>
        <trans-unit id="ff0f3a202fb5e56e9e5055a0c22a464e320087b3" translate="yes" xml:space="preserve">
          <source>Once the output procedure terminates, the sort is complete.</source>
          <target state="translated">一旦输出过程终止,排序就完成了。</target>
        </trans-unit>
        <trans-unit id="aa2d27ad2b6a5bb2d485b2b3cf531800fdf57d2a" translate="yes" xml:space="preserve">
          <source>Once the sort stage is complete, a copy of the sorted data will be written to each &amp;lt;</source>
          <target state="translated">排序阶段完成后，已排序数据的副本将被写入每个&amp;lt;</target>
        </trans-unit>
        <trans-unit id="a952da0c3633e235f52bb16ddddf1c8394a97156" translate="yes" xml:space="preserve">
          <source>Once tokens have been identified, the first (the command) will be discarded; the rest will be stored into the &quot;CHAINING&quot; arguments when the program begins execution, with the 2nd token going to the 1st argument, the 3rd token going to the 2nd argument and so forth.</source>
          <target state="translated">一旦确定了令牌,第一个令牌(命令)将被丢弃;其余的令牌将在程序开始执行时存储到 &quot;CHAINING &quot;参数中,第2个令牌进入第1个参数,第3个令牌进入第2个参数,以此类推。</target>
        </trans-unit>
        <trans-unit id="fc842de35b43065fcc2486b3f9cd1a54afa40e68" translate="yes" xml:space="preserve">
          <source>Once you have defined an alphabet name, that alphabet name may be used on specifications in&lt;code&gt;CODE-SET&lt;/code&gt;&lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; or&lt;code&gt;SYMBOLIC CHARACTERS&lt;/code&gt;clauses elsewhere in the program.</source>
          <target state="translated">一旦定义了字母名称，该字母名称就可以在程序中其他位置的 &lt;code&gt;CODE-SET&lt;/code&gt; &lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; 或SYMBOLIC &lt;code&gt;SYMBOLIC CHARACTERS&lt;/code&gt; 子句中的规范上使用。</target>
        </trans-unit>
        <trans-unit id="1db8d869f5e31c2a114146e31c6c3bb19304efe6" translate="yes" xml:space="preserve">
          <source>Once you know the answer to questions 1-4, you may easily determine the answers to the remaining questions as follows:</source>
          <target state="translated">一旦你知道了问题1-4的答案,你就可以很容易地确定其余问题的答案,如下所示。</target>
        </trans-unit>
        <trans-unit id="d64e944e7805a2994fd1366f274fdd6a314f0fc1" translate="yes" xml:space="preserve">
          <source>Once your program has been thoroughly tested, you&amp;rsquo;ll want different sequences to be generated each time the program runs. One possible way to accomplish this is to use a &amp;lt;</source>
          <target state="translated">一旦对程序进行了全面的测试，您将希望在每次运行时生成不同的序列。完成此操作的一种可能方法是使用&amp;lt;</target>
        </trans-unit>
        <trans-unit id="54f89a5962f679ffd2d3e844b0b1ce85b6df3297" translate="yes" xml:space="preserve">
          <source>One of these environment variables must be set to a directory/folder appropriate to create temporary files in. They will be checked in the order shown. This will be used by the&lt;code&gt;SORT&lt;/code&gt;statement (see &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;) and&lt;code&gt;MERGE&lt;/code&gt;statement (see &lt;a href=&quot;#MERGE&quot;&gt;MERGE&lt;/a&gt;) to create temporary work files. You may also use this folder for any temporary files your application may require.</source>
          <target state="translated">这些环境变量之一必须设置为适合在其中创建临时文件的目录/文件夹。将按照所示顺序对其进行检查。这将被用来 &lt;code&gt;SORT&lt;/code&gt; 声明（见&lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;）和 &lt;code&gt;MERGE&lt;/code&gt; 语句（见&lt;a href=&quot;#MERGE&quot;&gt;MERGE&lt;/a&gt;）创建临时工作文件。您也可以将该文件夹用于应用程序可能需要的任何临时文件。</target>
        </trans-unit>
        <trans-unit id="f6463f11b8fdf738c63c7b961b5112c2ffeb1404" translate="yes" xml:space="preserve">
          <source>One or more consecutive lines on a report that serve a common informational purpose or function. For example, lines of text that are displayed at the top or bottom of every printed page of a report.</source>
          <target state="translated">报告中具有共同信息目的或功能的一行或多行连续文字。例如,显示在报告每一页印刷品顶部或底部的文字行。</target>
        </trans-unit>
        <trans-unit id="6c681ed8f13156a1b9ed27937daab32b1e788722" translate="yes" xml:space="preserve">
          <source>Only after this processing has occurred will the detail report group specified on the&lt;code&gt;GENERATE&lt;/code&gt;be presented.</source>
          <target state="translated">仅在执行此处理后，才会显示在 &lt;code&gt;GENERATE&lt;/code&gt; 上指定的详细报告组。</target>
        </trans-unit>
        <trans-unit id="003eead4533ce41b48b2d118ad6982ea6215902b" translate="yes" xml:space="preserve">
          <source>Only data items whose&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) is either explicitly or implicitly defined as&lt;code&gt;DISPLAY&lt;/code&gt;may be used in&lt;code&gt;NUMERIC&lt;/code&gt;or any of the&lt;code&gt;ALPHABETIC&lt;/code&gt;class conditions.</source>
          <target state="translated">在 &lt;code&gt;NUMERIC&lt;/code&gt; 或任何 &lt;code&gt;ALPHABETIC&lt;/code&gt; 类条件中，只能 &lt;code&gt;USAGE&lt;/code&gt; 其USAGE（请参阅&lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;）被显式或隐式定义为 &lt;code&gt;DISPLAY&lt;/code&gt; 的数据项。</target>
        </trans-unit>
        <trans-unit id="d711ce7b6238bc52f8a6bcb50fdf5f00798177b9" translate="yes" xml:space="preserve">
          <source>Only files intended for use as work files for either the&lt;code&gt;SORT&lt;/code&gt;(see &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;) or&lt;code&gt;MERGE&lt;/code&gt;(see &lt;a href=&quot;#MERGE&quot;&gt;MERGE&lt;/a&gt;) statements should be coded with an SD &amp;mdash; all others should be defined with a FD.</source>
          <target state="translated">只有打算用作 &lt;code&gt;SORT&lt;/code&gt; （请参阅&lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;）或 &lt;code&gt;MERGE&lt;/code&gt; （请参阅&lt;a href=&quot;#MERGE&quot;&gt;MERGE&lt;/a&gt;）语句的工作文件的文件才应使用SD进行编码-其他所有文件都应使用FD进行定义。</target>
        </trans-unit>
        <trans-unit id="5e7f05d01153592a3701f9579ca1ebed0c7e36f8" translate="yes" xml:space="preserve">
          <source>Only numeric data can be moved to a numeric or numeric-edited &amp;lt;</source>
          <target state="translated">只能将数字数据移动到数字或数字编辑的&amp;lt;</target>
        </trans-unit>
        <trans-unit id="1a023314ae52d9ab2ebf57a5486f828683de142e" translate="yes" xml:space="preserve">
          <source>Only one of the &amp;lt;&amp;lt;</source>
          <target state="translated">&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="6e90f6903d2acd5d4289ceddbb76ae736395dc5d" translate="yes" xml:space="preserve">
          <source>Only one user-defined error procedure may be in effect at any time.</source>
          <target state="translated">任何时候只能有一个用户定义的错误程序有效。</target>
        </trans-unit>
        <trans-unit id="27fae19fb8fcab28fe3712f2fe8be9894d412e8a" translate="yes" xml:space="preserve">
          <source>Only one user-defined exit procedure may be in effect at any time.</source>
          <target state="translated">任何时候只能有一个用户定义的退出程序有效。</target>
        </trans-unit>
        <trans-unit id="8276bb34bd3b8954c5e1d44b6e4b6663af21c5d2" translate="yes" xml:space="preserve">
          <source>Only the final clause specified within this paragraph should be terminated with a period.</source>
          <target state="translated">只有本段内规定的最后条款才应以句号结束。</target>
        </trans-unit>
        <trans-unit id="19093a1f09bb5bb1f9ea7e1e012a0f82b409bbd3" translate="yes" xml:space="preserve">
          <source>Only the lowest-level directory (last) in the specified path can be created &amp;mdash; all others must already exist. This subroutine will NOT behave as a&lt;code&gt;mkdir -p&lt;/code&gt;(Unix) or&lt;code&gt;mkdir /p&lt;/code&gt;(Windows).</source>
          <target state="translated">只能创建指定路径中的最低级别的目录（最后一个）-所有其他目录必须已经存在。该子例程将不会表现为 &lt;code&gt;mkdir -p&lt;/code&gt; （Unix）或 &lt;code&gt;mkdir /p&lt;/code&gt; （Windows）。</target>
        </trans-unit>
        <trans-unit id="18a2770fd2028b8848e5939f9beca76f8630c1c6" translate="yes" xml:space="preserve">
          <source>Only the lowest-level directory (last) in the specified path will be deleted, and that directory must be empty to be deleted.</source>
          <target state="translated">只有指定路径中的最低级目录(最后一个)才会被删除,而且该目录必须为空才能被删除。</target>
        </trans-unit>
        <trans-unit id="1aec312e1ee36a7183965a81eb1e3cb89dc201e9" translate="yes" xml:space="preserve">
          <source>Only those as-yet uninitialized list members meeting the criteria set forth for the specified &amp;lt;</source>
          <target state="translated">仅那些尚未满足指定的&amp;lt;</target>
        </trans-unit>
        <trans-unit id="e4d4f39f5c6f13114530b1c856be188e28a33feb" translate="yes" xml:space="preserve">
          <source>Opening a file with this sharing option indicates you are willing to allow other programs to&lt;code&gt;OPEN&lt;/code&gt;the file for input while you have it open. If they attempt any other&lt;code&gt;OPEN&lt;/code&gt; theirs will fail with a file status of 37. Of course, your program may fail if someone else got to the file first and opened it with a sharing option that imposed file-sharing limitations.</source>
          <target state="translated">使用此共享选项打开文件表示您愿意在 &lt;code&gt;OPEN&lt;/code&gt; 文件的同时允许其他程序打开文件进行输入。如果他们尝试任何其他的 &lt;code&gt;OPEN&lt;/code&gt; 操作,他们的文件状态都将失败，并且状态为37。当然，如果其他人首先访问该文件并使用施加了文件共享限制的共享选项打开了该文件，则您的程序可能会失败。</target>
        </trans-unit>
        <trans-unit id="b290988bf20769fb3be0ec9ad35e8ff883c8e032" translate="yes" xml:space="preserve">
          <source>Optionally, the&lt;code&gt;-o&lt;/code&gt;switch</source>
          <target state="translated">（可选） &lt;code&gt;-o&lt;/code&gt; 开关</target>
        </trans-unit>
        <trans-unit id="447171bcea279a3f9260c4de4e227c2d6dd68c76" translate="yes" xml:space="preserve">
          <source>Or it could simply utilize the condition name XL as follows:</source>
          <target state="translated">或者它可以简单地利用条件名称XL,如下所示:</target>
        </trans-unit>
        <trans-unit id="370e4c255f90d246d5721bdc9fd05e213464a25e" translate="yes" xml:space="preserve">
          <source>Or, on a Native Windows or Windows/MinGW system:</source>
          <target state="translated">或者,在Native Windows或Windows/MinGW系统上。</target>
        </trans-unit>
        <trans-unit id="ba479d2e9dd775cad43c293e560fad3af36bde42" translate="yes" xml:space="preserve">
          <source>Other programming language provide the programmer with a similar capability of creating their own words (names) for parts of a program; COBOL is somewhat unusual when compared to other languages in that user-defined words may</source>
          <target state="translated">其他编程语言为程序员提供了类似的能力,可以为程序的各个部分创建自己的词(名称);与其他语言相比,COBOL有些不同,因为用户定义的词可能是</target>
        </trans-unit>
        <trans-unit id="8bbcce1456c742787b1580fde33b8148c8987df5" translate="yes" xml:space="preserve">
          <source>Out of key range</source>
          <target state="translated">超出音域</target>
        </trans-unit>
        <trans-unit id="a553d2153badfb1db45ee73715be9107f08adc68" translate="yes" xml:space="preserve">
          <source>Output from the command (if any) will appear in the command window in which the GnuCOBOL program was executed.</source>
          <target state="translated">命令的输出(如果有的话)将出现在执行GnuCOBOL程序的命令窗口中。</target>
        </trans-unit>
        <trans-unit id="bf18ec4bed8c30a9b19eac1b32547e33a663188d" translate="yes" xml:space="preserve">
          <source>Over the years, there has been much debate over the efficiency and arithmetic accuracy of using the&lt;code&gt;COMPUTE&lt;/code&gt;statement (see &lt;a href=&quot;#COMPUTE&quot;&gt;COMPUTE&lt;/a&gt;) rather than the four basic arithmetic operation statements.</source>
          <target state="translated">多年来，关于使用 &lt;code&gt;COMPUTE&lt;/code&gt; 语句（请参阅&lt;a href=&quot;#COMPUTE&quot;&gt;COMPUTE&lt;/a&gt;）而不是四个基本的算术运算语句的效率和算术准确性存在很多争论。</target>
        </trans-unit>
        <trans-unit id="0e6ac5f3f6d5399374fefa09919d1c279a782632" translate="yes" xml:space="preserve">
          <source>Overflow condition</source>
          <target state="translated">溢出条件</target>
        </trans-unit>
        <trans-unit id="9caea4b058bdda37551cfd4b0757e6365f49b9e6" translate="yes" xml:space="preserve">
          <source>PACKED-DECIMAL, PADDING, PAGE, PAGE-COUNTER, PARAGRAPH, PERFORM, PF, PH, PI, PIC, PICTURE, PLUS, POINTER, POSITION, POSITIVE, PREFIXED, PRESENT, PRESENT-VALUE, PREVIOUS, PRINT, PRINTER, PRINTER-1, PRINTING, PROCEDURE, PROCEDURE-POINTER, PROCEDURES, PROCEED, PROGRAM, PROGRAM-ID, PROGRAM-POINTER, PROHIBITED, PROMPT, PROPERTY, PROTECTED, PROTOTYPE, PURGE</source>
          <target state="translated">PACKED-DECIMAL,PADDING,PAGE,PAGE-COUNTER,PARAGRAPH,PERFORM,PF,PH,PI,PIC,PICTURE,PLUS,POINTER,POSITION,POSITIVE,PREFIXED,PRESENT,PRESENT-VALUE,PREVIOUS,PRINT,PRINTER,PRINTER-1,PRINTING,PROCEDURE,PROCEDURE-POINTER,PROCEDURES,PROCEED,PROGRAM,PROGRAM-ID,PROGRAM-POINTER,PROHIBITED,PROMPT,PROPERTY,PROTECTED,PROTOTYPE,PURGE</target>
        </trans-unit>
        <trans-unit id="d48971351ade6fc5f890bc67a75e3fa21b22ca7e" translate="yes" xml:space="preserve">
          <source>PAGE FOOTING [1]</source>
          <target state="translated">页脚 [1]</target>
        </trans-unit>
        <trans-unit id="74d126652169159b5d6e6ea5e735209263036ae6" translate="yes" xml:space="preserve">
          <source>PAGE HEADING [1]</source>
          <target state="translated">页面标题[1]</target>
        </trans-unit>
        <trans-unit id="a7aa2c13f70d4d267a113972d52fc8706a2f0e22" translate="yes" xml:space="preserve">
          <source>PI Function Syntax</source>
          <target state="translated">PI函数语法</target>
        </trans-unit>
        <trans-unit id="b3194ebbb74c1fdb2502a50c00eae2deeb0fe962" translate="yes" xml:space="preserve">
          <source>PIC 9(4) &amp;mdash; This is the default data item allocated for use by the&lt;code&gt;ACCEPT &amp;lt;&lt;i&gt;screen-data-item&lt;/i&gt;&amp;gt;&lt;/code&gt;statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;), if no&lt;code&gt;CRT STATUS&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) clause was specified..</source>
          <target state="translated">PIC 9（4）&amp;mdash; 如果未指定 &lt;code&gt;CRT STATUS&lt;/code&gt; （请参阅&lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;）子句，这是分配给 &lt;code&gt;ACCEPT &amp;lt;&lt;i&gt;screen-data-item&lt;/i&gt;&amp;gt;&lt;/code&gt; 语句使用的默认数据项（请参见&lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT屏幕数据项&lt;/a&gt;）。 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
