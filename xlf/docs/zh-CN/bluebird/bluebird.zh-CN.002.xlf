<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="bluebird">
    <body>
      <group id="bluebird">
        <trans-unit id="d5b43ccfa15a68ea76732113925885a846a983e2" translate="yes" xml:space="preserve">
          <source>Given an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;&lt;code&gt;Iterable&lt;/code&gt;&lt;/a&gt;(arrays are &lt;code&gt;Iterable&lt;/code&gt;), or a promise of an &lt;code&gt;Iterable&lt;/code&gt;, which produces promises (or a mix of promises and values), iterate over all the values in the &lt;code&gt;Iterable&lt;/code&gt; into an array and &lt;a href=&quot;http://en.wikipedia.org/wiki/Map_(higher-order_function)&quot;&gt;map the array to another&lt;/a&gt; using the given &lt;code&gt;mapper&lt;/code&gt; function.</source>
          <target state="translated">给定一个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt; &lt;code&gt;Iterable&lt;/code&gt; &lt;/a&gt;（数组是 &lt;code&gt;Iterable&lt;/code&gt; ），或一个 &lt;code&gt;Iterable&lt;/code&gt; 的一个Promise，它会产生Promise（或Promise和值的混合），将 &lt;code&gt;Iterable&lt;/code&gt; 中的所有值迭代到一个数组中，并使用给定的 &lt;code&gt;mapper&lt;/code&gt; &lt;a href=&quot;http://en.wikipedia.org/wiki/Map_(higher-order_function)&quot;&gt;将该数组&lt;/a&gt;映射到另一个数组功能。</target>
        </trans-unit>
        <trans-unit id="5e99be03578b916bd80ede8ae2a2062901092637" translate="yes" xml:space="preserve">
          <source>Given an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;&lt;code&gt;Iterable&lt;/code&gt;&lt;/a&gt;(arrays are &lt;code&gt;Iterable&lt;/code&gt;), or a promise of an &lt;code&gt;Iterable&lt;/code&gt;, which produces promises (or a mix of promises and values), iterate over all the values in the &lt;code&gt;Iterable&lt;/code&gt; into an array and iterate over the array serially, in-order.</source>
          <target state="translated">给定一个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt; &lt;code&gt;Iterable&lt;/code&gt; &lt;/a&gt;（阵列是 &lt;code&gt;Iterable&lt;/code&gt; ），或一个的一个承诺 &lt;code&gt;Iterable&lt;/code&gt; ，其产生的承诺（或承诺和值的组合），迭代中的所有值 &lt;code&gt;Iterable&lt;/code&gt; 和阵列上串联到一个数组迭代，在阶。</target>
        </trans-unit>
        <trans-unit id="1f8e9d0b39417bd51e7781fa7d8ff0682741fabe" translate="yes" xml:space="preserve">
          <source>Given an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;&lt;code&gt;Iterable&lt;/code&gt;&lt;/a&gt;(arrays are &lt;code&gt;Iterable&lt;/code&gt;), or a promise of an &lt;code&gt;Iterable&lt;/code&gt;, which produces promises (or a mix of promises and values), iterate over all the values in the &lt;code&gt;Iterable&lt;/code&gt; into an array and return a promise that is fulfilled as soon as &lt;code&gt;count&lt;/code&gt; promises are fulfilled in the array. The fulfillment value is an array with &lt;code&gt;count&lt;/code&gt; values in the order they were fulfilled.</source>
          <target state="translated">给定一个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt; &lt;code&gt;Iterable&lt;/code&gt; &lt;/a&gt;（数组是 &lt;code&gt;Iterable&lt;/code&gt; ），或一个 &lt;code&gt;Iterable&lt;/code&gt; 的一个Promise，它会产生Promise（或Promise和值的混合），将 &lt;code&gt;Iterable&lt;/code&gt; 中的所有值迭代到一个数组中，并尽快返回一个已实现的Promise &lt;code&gt;count&lt;/code&gt; 承诺在数组中实现。履行值是一个数组，其中包含按履行顺序 &lt;code&gt;count&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="857f3458334e4f2213e0a21ea4b51230697211bb" translate="yes" xml:space="preserve">
          <source>Given an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;&lt;code&gt;Iterable&lt;/code&gt;&lt;/a&gt;(arrays are &lt;code&gt;Iterable&lt;/code&gt;), or a promise of an &lt;code&gt;Iterable&lt;/code&gt;, which produces promises (or a mix of promises and values), iterate over all the values in the &lt;code&gt;Iterable&lt;/code&gt; into an array and return a promise that is fulfilled or rejected as soon as a promise in the array is fulfilled or rejected with the respective rejection reason or fulfillment value.</source>
          <target state="translated">给定一个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt; &lt;code&gt;Iterable&lt;/code&gt; &lt;/a&gt;（阵列是 &lt;code&gt;Iterable&lt;/code&gt; ），或一个的一个承诺 &lt;code&gt;Iterable&lt;/code&gt; ，其产生的承诺（或承诺和值的组合），迭代中的所有的值 &lt;code&gt;Iterable&lt;/code&gt; 到一个数组并返回满足或拒绝作为一个承诺一旦数组中的承诺被履行或被拒绝，并带有相应的拒绝原因或履行值。</target>
        </trans-unit>
        <trans-unit id="69cab8471b98016cf118f04639071683711e51b8" translate="yes" xml:space="preserve">
          <source>Given an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;&lt;code&gt;Iterable&lt;/code&gt;&lt;/a&gt;(arrays are &lt;code&gt;Iterable&lt;/code&gt;), or a promise of an &lt;code&gt;Iterable&lt;/code&gt;, which produces promises (or a mix of promises and values), iterate over all the values in the &lt;code&gt;Iterable&lt;/code&gt; into an array and return a promise that is fulfilled when all the items in the array are fulfilled. The promise's fulfillment value is an array with fulfillment values at respective positions to the original array. If any promise in the array rejects, the returned promise is rejected with the rejection reason.</source>
          <target state="translated">给定一个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt; &lt;code&gt;Iterable&lt;/code&gt; &lt;/a&gt;（数组是 &lt;code&gt;Iterable&lt;/code&gt; ），或者是Iterable的一个 &lt;code&gt;Iterable&lt;/code&gt; ，它会产生Promise（或Promise和值的混合），将 &lt;code&gt;Iterable&lt;/code&gt; 中的所有值迭代到一个数组中，并在所有数组中的项目已实现。许诺的履行值是一个数组，在原始数组的各个位置上都有履行值。如果数组中的任何承诺被拒绝，则返回的承诺将被拒绝，并带有拒绝原因。</target>
        </trans-unit>
        <trans-unit id="ba72cdcdd80c07ac4fdce4644a5bd2dcebb0c4dd" translate="yes" xml:space="preserve">
          <source>Gives</source>
          <target state="translated">Gives</target>
        </trans-unit>
        <trans-unit id="dd8ed7e2a547ceb0fcc1dd88e8912c6fe49d6651" translate="yes" xml:space="preserve">
          <source>Global rejection events</source>
          <target state="translated">全球拒绝事件</target>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="eecad68c8e79b4757501bd51103a0fe41d4c17f1" translate="yes" xml:space="preserve">
          <source>Happy coding, &lt;a href=&quot;https://github.com/sukima&quot;&gt;@sukima&lt;/a&gt;.</source>
          <target state="translated">快乐的编码，&lt;a href=&quot;https://github.com/sukima&quot;&gt;@sukima&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0c271c8f62efa33d3ac8edbe0fea6e52fc84150" translate="yes" xml:space="preserve">
          <source>Haskell</source>
          <target state="translated">Haskell</target>
        </trans-unit>
        <trans-unit id="8886c5567b21fd2984bb26867070a05a64fb4320" translate="yes" xml:space="preserve">
          <source>Here is a simple example (where &lt;code&gt;getConnection()&lt;/code&gt; has been defined to return a proper Disposer object)</source>
          <target state="translated">这是一个简单的示例（已定义 &lt;code&gt;getConnection()&lt;/code&gt; 以返回适当的Disposer对象）</target>
        </trans-unit>
        <trans-unit id="26f58fc7b427a0eccff2284be30066c7abd9204c" translate="yes" xml:space="preserve">
          <source>Here is another example with an API that lets us know when a connection is ready. The attempt here is imperfect and we'll describe why soon:</source>
          <target state="translated">下面是另一个例子,用一个API让我们知道什么时候连接准备好了。这里的尝试是不完美的,我们将很快描述为什么。</target>
        </trans-unit>
        <trans-unit id="e65979c6ef8becc2e43f319defd5989fed1be73a" translate="yes" xml:space="preserve">
          <source>Here is another example with an API that lets us know when when a connection is ready. The attempt here is imperfect and we'll describe why soon:</source>
          <target state="translated">这里是另一个例子,用一个API让我们知道什么时候连接准备好了。这里的尝试是不完美的,我们将很快描述为什么。</target>
        </trans-unit>
        <trans-unit id="4ba16b105db298af09af0af0a8b19da53c43e1d3" translate="yes" xml:space="preserve">
          <source>Here is how to create a disposer for the MySQL driver:</source>
          <target state="translated">下面是如何为MySQL驱动创建一个处置器。</target>
        </trans-unit>
        <trans-unit id="74bcba50f0bf4efbc2a611c31d423e7be3cb7101" translate="yes" xml:space="preserve">
          <source>Here is how to create a disposer for the PostgreSQL driver:</source>
          <target state="translated">下面是如何为PostgreSQL驱动创建一个处置器。</target>
        </trans-unit>
        <trans-unit id="27bacef699ed8cc8da7b95cbf6d769cd8c4fda27" translate="yes" xml:space="preserve">
          <source>Here is some example HTML for the Progress Dialog:</source>
          <target state="translated">下面是进度对话框的一些HTML示例。</target>
        </trans-unit>
        <trans-unit id="7718e6b52e055c2b6bb02d338b08d91075171e40" translate="yes" xml:space="preserve">
          <source>Here's an example of &lt;code&gt;fs.readFile&lt;/code&gt; with or without promises:</source>
          <target state="translated">这是带有或不带有承诺的 &lt;code&gt;fs.readFile&lt;/code&gt; 的示例：</target>
        </trans-unit>
        <trans-unit id="be1eea5cafc8d8f3342d7b87a0e1c5e1c6e75fa0" translate="yes" xml:space="preserve">
          <source>However because it is possible to handle a rejected promise at any time in the indeterminate future, some programming patterns will result in false positives. Because such programming patterns are not necessary and can always be refactored to never cause false positives, we recommend doing that to keep debugging as easy as possible . You may however feel differently so bluebird provides hooks to implement more complex failure policies.</source>
          <target state="translated">然而由于可以在不确定的未来任何时候处理被拒绝的承诺,所以有些编程模式会导致误报。因为这样的编程模式并不是必须的,而且可以随时重构到不会产生误报,所以我们建议这样做,以保证调试工作尽可能的简单。然而你可能会有不同的感受,所以bluebird提供了钩子来实现更复杂的失败策略。</target>
        </trans-unit>
        <trans-unit id="13c4ea634e9c241cc16a70243b1aa4d2e0af9262" translate="yes" xml:space="preserve">
          <source>However if you want stack traces and cleaner string output, then you should do:</source>
          <target state="translated">然而如果你想要堆栈痕迹和更干净的字符串输出,那么你应该这样做。</target>
        </trans-unit>
        <trans-unit id="43fb3aa6954ef56f7c44e1242c17a1fae9ea1ce7" translate="yes" xml:space="preserve">
          <source>However, a bluebird promise is more powerful than the current implementation of &lt;code&gt;std::future&lt;/code&gt; since while chaining has been discussed it is not yet implemented. Promises can be chained together.</source>
          <target state="translated">但是，蓝鸟的Promise比当前 &lt;code&gt;std::future&lt;/code&gt; 实现更强大，因为虽然已经讨论了链接，但尚未实现。承诺可以链接在一起。</target>
        </trans-unit>
        <trans-unit id="3ead241876e467071326c285d4a421554cfb1153" translate="yes" xml:space="preserve">
          <source>However, if the second &lt;code&gt;getConnection&lt;/code&gt; throws &lt;strong&gt;synchronously&lt;/strong&gt;, the first connection is leaked. This will not happen when using APIs through bluebird promisified methods though. You can wrap functions that could throw in &lt;a href=&quot;promise.method&quot;&gt;&lt;code&gt;Promise.method&lt;/code&gt;&lt;/a&gt; which will turn synchronous rejections into rejected promises.</source>
          <target state="translated">但是，如果第二个 &lt;code&gt;getConnection&lt;/code&gt; &lt;strong&gt;同步&lt;/strong&gt;引发，则第一个连接将泄漏。但是，通过bluebird承诺方法使用API​​时不会发生这种情况。您可以包装可能会引发&lt;a href=&quot;promise.method&quot;&gt; &lt;code&gt;Promise.method&lt;/code&gt; 的&lt;/a&gt;函数，该函数会将同步拒绝变为拒绝的Promise。</target>
        </trans-unit>
        <trans-unit id="c6545029e669f49f67f406d14c0ceb316e3ab45f" translate="yes" xml:space="preserve">
          <source>However, if you are utilizing the full bluebird API offering, you will &lt;em&gt;almost never&lt;/em&gt; need to resort to nesting promises in the first place. The above should be written more like:</source>
          <target state="translated">但是，如果您正在使用完整的bluebird API产品，则&lt;em&gt;几乎根本&lt;/em&gt;不需要使用嵌套承诺。上面应该写得更像：</target>
        </trans-unit>
        <trans-unit id="0e98b78455e3426551238440ba2fef34bfa9f53b" translate="yes" xml:space="preserve">
          <source>However, there are many differences when you look closer:</source>
          <target state="translated">然而,仔细观察,却有许多不同之处。</target>
        </trans-unit>
        <trans-unit id="0cae8b925e624929841b55477c73030393e870ed" translate="yes" xml:space="preserve">
          <source>I hope this helps illustrate some concepts available with Promises and a different perspective on how promises can represent more then just AJAX data.</source>
          <target state="translated">我希望这能帮助说明承诺的一些可用概念,并从不同的角度说明承诺如何代表更多的AJAX数据。</target>
        </trans-unit>
        <trans-unit id="6de1ea5d0581cc815a017782a4875ebd7b42beb9" translate="yes" xml:space="preserve">
          <source>IE7 and IE8 do not support using keywords as property names, so if supporting these browsers is required you need to use the compatibility aliases:</source>
          <target state="translated">IE7和IE8不支持使用关键字作为属性名,所以如果需要支持这些浏览器就需要使用兼容性别名。</target>
        </trans-unit>
        <trans-unit id="5a58805bb7bfd807b86a57ffc79cb53fbd8d908e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;index&lt;/code&gt; is negative, the indexed load will become &lt;code&gt;obj.length + index&lt;/code&gt;. So that -1 can be used to read last item in the array, -2 to read the second last and so on. For example:</source>
          <target state="translated">如果 &lt;code&gt;index&lt;/code&gt; 为负，则索引的负载将变为 &lt;code&gt;obj.length + index&lt;/code&gt; 。这样-1可以用来读取数组中的最后一个项目，-2可以用来读取倒数第二个项目，依此类推。例如：</target>
        </trans-unit>
        <trans-unit id="48754e7d553962c152a84287f9d6e3171c36cf69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;object&lt;/code&gt; is a trusted &lt;code&gt;Promise&lt;/code&gt;, then it will be treated as a promise for object rather than for its properties. All other objects (except &lt;code&gt;Map&lt;/code&gt;s) are treated for their properties as is returned by &lt;code&gt;Object.keys&lt;/code&gt; - the object's own enumerable properties.</source>
          <target state="translated">如果 &lt;code&gt;object&lt;/code&gt; 是受信任的 &lt;code&gt;Promise&lt;/code&gt; ，那么它将被视为对对象的承诺而不是其属性。所有其他对象（ &lt;code&gt;Map&lt;/code&gt; 除外）的属性均由 &lt;code&gt;Object.keys&lt;/code&gt; 返回（对象本身的可枚举属性）来对待。</target>
        </trans-unit>
        <trans-unit id="5e792131e2122a704cd149f5cb06c842a0d1f08e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;thisArg&lt;/code&gt; is a promise or thenable, its resolution will be awaited for and the bound value will be the promise's fulfillment value. If &lt;code&gt;thisArg&lt;/code&gt; rejects then the returned promise is rejected with the &lt;code&gt;thisArg's&lt;/code&gt; rejection reason. Note that this means you cannot use &lt;code&gt;this&lt;/code&gt; without checking inside catch handlers for promises that bind to promise because in case of rejection of &lt;code&gt;thisArg&lt;/code&gt;, &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;thisArg&lt;/code&gt; 是一个promise或thenable，则将等待其解决，绑定值将是promise的实现值。如果 &lt;code&gt;thisArg&lt;/code&gt; 拒绝，则使用 &lt;code&gt;thisArg's&lt;/code&gt; 拒绝原因拒绝返回的承诺。注意，这意味着你不能使用 &lt;code&gt;this&lt;/code&gt; 没有检查里面catch处理器的承诺，其结合答应，因为在拒绝的情况下 &lt;code&gt;thisArg&lt;/code&gt; ， &lt;code&gt;this&lt;/code&gt; 将 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17736fb74e4b535caabcc3cb12766cd80da44a84" translate="yes" xml:space="preserve">
          <source>If a bound promise is returned by the callback to &lt;a href=&quot;api/promise.method&quot;&gt;&lt;code&gt;Promise.method&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;api/promise.try&quot;&gt;&lt;code&gt;Promise.try&lt;/code&gt;&lt;/a&gt;, the returned promise will be bound to the same value</source>
          <target state="translated">如果通过&lt;a href=&quot;api/promise.method&quot;&gt; &lt;code&gt;Promise.method&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;api/promise.try&quot;&gt; &lt;code&gt;Promise.try&lt;/code&gt; &lt;/a&gt;的回调返回绑定的诺言，则返回的诺言将被绑定到相同的值</target>
        </trans-unit>
        <trans-unit id="ef5dc1064fadc46c525a97dba4427bc7dea4bdd5" translate="yes" xml:space="preserve">
          <source>If a disposer method throws or returns a rejected promise, it's highly likely that it failed to dispose of the resource. In that case, Bluebird has two options - it can either ignore the error and continue with program execution or throw an exception (crashing the process in node.js).</source>
          <target state="translated">如果一个处置器方法抛出或返回一个被拒绝的承诺,那么它极有可能未能处置资源。在这种情况下,Bluebird有两个选择--它可以忽略这个错误并继续执行程序,或者抛出一个异常(在node.js中使进程崩溃)。</target>
        </trans-unit>
        <trans-unit id="043349c3f8c506768b7d9272ca348300465fc593" translate="yes" xml:space="preserve">
          <source>If a method name already has an &lt;code&gt;&quot;Async&quot;&lt;/code&gt;-suffix, an exception will be thrown.</source>
          <target state="translated">如果方法名称已经具有 &lt;code&gt;&quot;Async&quot;&lt;/code&gt; 后缀，则将引发异常。</target>
        </trans-unit>
        <trans-unit id="ea797b951ef4dd11b65a893a9dcb482b48c90fe6" translate="yes" xml:space="preserve">
          <source>If a method name already has an &lt;code&gt;&quot;Async&quot;&lt;/code&gt;-suffix, it will be duplicated. E.g. &lt;code&gt;getAsync&lt;/code&gt;'s promisified name is &lt;code&gt;getAsyncAsync&lt;/code&gt;.</source>
          <target state="translated">如果方法名称已经具有 &lt;code&gt;&quot;Async&quot;&lt;/code&gt; 后缀，它将被复制。例如， &lt;code&gt;getAsync&lt;/code&gt; 的约定名称为 &lt;code&gt;getAsyncAsync&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00ca6822bc67d26b0bb8b67bfe840b57c60568ab" translate="yes" xml:space="preserve">
          <source>If a module has multiple argument callbacks as an exception rather than the rule, you can filter out the multiple argument methods in first go and then promisify rest of the module in second go:</source>
          <target state="translated">如果一个模块有多个参数回调,这是一个例外,而不是规则,你可以在第一遍过滤掉多个参数方法,然后在第二遍承诺模块的其余部分。</target>
        </trans-unit>
        <trans-unit id="39d2831120e0fc914a1f915ed431ccee51054c24" translate="yes" xml:space="preserve">
          <source>If all iterations resolve successfully, the &lt;code&gt;Promise.each&lt;/code&gt; call resolves to a new array containing the resolved values of the original input elements.</source>
          <target state="translated">如果所有迭代都成功解析，则 &lt;code&gt;Promise.each&lt;/code&gt; 调用将解析为一个包含原始输入元素的解析值的新数组。</target>
        </trans-unit>
        <trans-unit id="129cbea3a99c2245487d23413194e397b8dee441" translate="yes" xml:space="preserve">
          <source>If all iterations resolve successfully, the &lt;code&gt;Promise.mapSeries&lt;/code&gt; call resolves to a new array containing the results of each &lt;code&gt;mapper&lt;/code&gt; execution, in order.</source>
          <target state="translated">如果所有迭代都成功解析，则 &lt;code&gt;Promise.mapSeries&lt;/code&gt; 调用将解析为一个新数组，该数组依次包含每个 &lt;code&gt;mapper&lt;/code&gt; 执行的结果。</target>
        </trans-unit>
        <trans-unit id="72964c7b91aee68d8763c1b1f6924364f8c00e31" translate="yes" xml:space="preserve">
          <source>If any promise in the input array is rejected or any promise returned by the iterator function is rejected, the result will be rejected as well.</source>
          <target state="translated">如果输入数组中的任何承诺被拒绝,或者迭代函数返回的任何承诺被拒绝,结果也会被拒绝。</target>
        </trans-unit>
        <trans-unit id="962010428071535fe6f8370fa09691795307bc72" translate="yes" xml:space="preserve">
          <source>If destructuring parameters are supported, &lt;code&gt;.spread(function(arg1, arg2) {})&lt;/code&gt; can be replaced with &lt;code&gt;.then(function([arg1, arg2]){})&lt;/code&gt;.</source>
          <target state="translated">如果支持解构参数，则可以将 &lt;code&gt;.spread(function(arg1, arg2) {})&lt;/code&gt; 替换为 &lt;code&gt;.then(function([arg1, arg2]){})&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9bcd1a977e9bc00ed376c144fd15da6e11e726d" translate="yes" xml:space="preserve">
          <source>If fetching tweets fails before the document is ready the rejection is reported as unhandled even though it will be eventually handled when the document is ready. This is of course impossible to determine automatically, but you can explicitly do so using &lt;code&gt;.suppressUnhandledRejections()&lt;/code&gt;:</source>
          <target state="translated">如果在文档准备好之前获取推文失败，则拒绝将被报告为未处理，即使在文档准备就绪时最终也会被处理。当然这是不可能自动确定的，但是您可以使用 &lt;code&gt;.suppressUnhandledRejections()&lt;/code&gt; 显式地确定：</target>
        </trans-unit>
        <trans-unit id="d135771ca2084fbac51f59a830fdefe27d1f73a3" translate="yes" xml:space="preserve">
          <source>If not there already, an additional wrapper function is required to undefined leaking or sharing &lt;code&gt;scope&lt;/code&gt;</source>
          <target state="translated">如果还不存在，则需要一个附加的包装函数来未定义的泄漏或共享 &lt;code&gt;scope&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2702634b1adf7d64f121049f0317c538e848c615" translate="yes" xml:space="preserve">
          <source>If that ES6 import &lt;a href=&quot;https://github.com/petkaantonov/bluebird/pull/1594&quot;&gt;doesn't work&lt;/a&gt;</source>
          <target state="translated">如果该ES6导入&lt;a href=&quot;https://github.com/petkaantonov/bluebird/pull/1594&quot;&gt;不起作用&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dd08bf528d1b25718f075d1d36c59b224befab3e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;index&lt;/code&gt; is still negative after &lt;code&gt;obj.length + index&lt;/code&gt;, it will be clamped to 0.</source>
          <target state="translated">如果在 &lt;code&gt;obj.length + index&lt;/code&gt; 之后 &lt;code&gt;index&lt;/code&gt; 仍然为负，它将被限制为0。</target>
        </trans-unit>
        <trans-unit id="a9c21a6c272866c083275685b7da39922c4ca853" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;nodeFunction&lt;/code&gt; calls its callback with multiple success values, the fulfillment value will be the first fulfillment item.</source>
          <target state="translated">如果 &lt;code&gt;nodeFunction&lt;/code&gt; 使用多个成功值调用其回调，则实现值将是第一个实现项。</target>
        </trans-unit>
        <trans-unit id="f04284cbd4e7048ff2d892690b33de55e02378db" translate="yes" xml:space="preserve">
          <source>If the fade out completes successfully, the returned promise will be fulfilled or rejected with the value from &lt;code&gt;xhr&lt;/code&gt;. If &lt;code&gt;.fadeOut&lt;/code&gt; throws an exception or passes an error to the callback, the returned promise will be rejected with the error from &lt;code&gt;.fadeOut&lt;/code&gt;.</source>
          <target state="translated">如果淡出成功完成，则将使用 &lt;code&gt;xhr&lt;/code&gt; 的值来实现或拒绝返回的promise 。如果 &lt;code&gt;.fadeOut&lt;/code&gt; 引发异常或将错误传递给回调，则返回的诺言将因 &lt;code&gt;.fadeOut&lt;/code&gt; 中的错误而被拒绝。</target>
        </trans-unit>
        <trans-unit id="361168b0ad7608978a2fce0c19d538f5024c4a7e" translate="yes" xml:space="preserve">
          <source>If the handler function passed to &lt;code&gt;.finally&lt;/code&gt; returns a promise, the promise returned by &lt;code&gt;.finally&lt;/code&gt; will not be settled until the promise returned by the handler is settled. If the handler fulfills its promise, the returned promise will be fulfilled or rejected with the original value. If the handler rejects its promise, the returned promise will be rejected with the handler's value. This is similar to throwing an exception in a synchronous &lt;code&gt;finally&lt;/code&gt; block, causing the original value or exception to be forgotten. This delay can be useful if the actions performed by the handler are done asynchronously. For example:</source>
          <target state="translated">如果传递给 &lt;code&gt;.finally&lt;/code&gt; 的处理函数返回了一个 &lt;code&gt;.finally&lt;/code&gt; 则直到该处理程序返回的Promise被解决之前，.finally返回的Promise才会被解决。如果处理程序履行其诺言，则返回的诺言将以原始值实现或拒绝。如果处理程序拒绝其承诺，则返回的承诺将与处理程序的值一起被拒绝。这类似于在同步的 &lt;code&gt;finally&lt;/code&gt; 块中引发异常，从而导致原始值或异常被遗忘。如果处理程序执行的操作是异步完成的，则此延迟可能很有用。例如：</target>
        </trans-unit>
        <trans-unit id="01c2d4f954ef5c2b127397874ff03e84be89fce3" translate="yes" xml:space="preserve">
          <source>If the reducer function returns a promise, then the result of the promise is awaited, before continuing with next iteration. If any promise in the array is rejected or a promise returned by the reducer function is rejected, the result is rejected as well.</source>
          <target state="translated">如果reducer函数返回一个承诺,那么在继续下一次迭代之前,将等待承诺的结果。如果数组中的任何承诺被拒绝,或者被reducer函数返回的承诺被拒绝,那么结果也会被拒绝。</target>
        </trans-unit>
        <trans-unit id="9a8efabed45049c7b109e41750da5ffac5adcb88" translate="yes" xml:space="preserve">
          <source>If the waterfall elements are static, you can just replace it with a normal promise chain. For waterfalls with dynamic steps, use &lt;a href=&quot;api/promise.each&quot;&gt;&lt;code&gt;Promise.each&lt;/code&gt;&lt;/a&gt;. Multiple arguments can be ferried in an array.</source>
          <target state="translated">如果瀑布元素是静态的，则可以将其替换为常规的Promise链。对于具有动态步幅的瀑布，请使用&lt;a href=&quot;api/promise.each&quot;&gt; &lt;code&gt;Promise.each&lt;/code&gt; &lt;/a&gt;。可以在数组中传递多个参数。</target>
        </trans-unit>
        <trans-unit id="6feea941cd7828f9478631d06744c6dde53e3bff" translate="yes" xml:space="preserve">
          <source>If too many promises are rejected so that the promise can never become fulfilled, it will be immediately rejected with an &lt;a href=&quot;aggregateerror&quot;&gt;&lt;code&gt;AggregateError&lt;/code&gt;&lt;/a&gt; of the rejection reasons in the order they were thrown in.</source>
          <target state="translated">如果拒绝了太多的承诺，从而使承诺永远无法实现，则将立即按照抛出原因的拒绝原因，通过&lt;a href=&quot;aggregateerror&quot;&gt; &lt;code&gt;AggregateError&lt;/code&gt; &lt;/a&gt;拒绝该承诺。</target>
        </trans-unit>
        <trans-unit id="c2cf94f34d6e1d8b4f98bef3770ba3552f18a017" translate="yes" xml:space="preserve">
          <source>If you cannot do static promisification (promisify and promisifyAll perform too slowly to use at runtime), you may use &lt;a href=&quot;api/promise.fromcallback&quot;&gt;&lt;code&gt;Promise.fromCallback&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您不能执行静态承诺（promisify和promisifyAll的执行速度太慢而无法在运行时使用），则可以使用&lt;a href=&quot;api/promise.fromcallback&quot;&gt; &lt;code&gt;Promise.fromCallback&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4aad0286aecb732eace47330d3eb9225ba7439ee" translate="yes" xml:space="preserve">
          <source>If you do have some code using jQuery deferred methods extensively try to see if some of these jQuery deferred patterns and their replacements can be applied:</source>
          <target state="translated">如果你确实有一些代码广泛使用jQuery递延方法,试着看看这些jQuery递延模式和它们的替换是否可以被应用。</target>
        </trans-unit>
        <trans-unit id="ee3233f06ac157e8dbc09dc2625b57a65257f7e1" translate="yes" xml:space="preserve">
          <source>If you don't want to return a bound promise to the consumers of a promise, you can rebind the chain at the end:</source>
          <target state="translated">如果你不想把绑定的承诺返还给承诺的消费者,你可以在最后重新绑定链条。</target>
        </trans-unit>
        <trans-unit id="4a1d38286aed9fdb4ea56d22e0878f2efd4afec6" translate="yes" xml:space="preserve">
          <source>If you find this issue in a common library please &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/new&quot;&gt;open an issue&lt;/a&gt;.</source>
          <target state="translated">如果您在公共图书馆中发现此问题，请&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/new&quot;&gt;打开一个问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6d2c92c43afa270ba31f20fa3a4fd3f374ada753" translate="yes" xml:space="preserve">
          <source>If you know what you're doing and don't want to silence all warnings, you can create runaway promises without causing this warning by returning e.g. &lt;code&gt;null&lt;/code&gt;:</source>
          <target state="translated">如果你知道你在做什么，不希望关闭所有的警告，你可以不通过返回例如导致此警告创建失控的承诺 &lt;code&gt;null&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4317fd792e9166b0fb459f84f12ac0c69c772134" translate="yes" xml:space="preserve">
          <source>If you pass a &lt;code&gt;context&lt;/code&gt;, the &lt;code&gt;nodeFunction&lt;/code&gt; will be called as a method on the &lt;code&gt;context&lt;/code&gt;.</source>
          <target state="translated">如果传递 &lt;code&gt;context&lt;/code&gt; ，则 &lt;code&gt;nodeFunction&lt;/code&gt; 将作为 &lt;code&gt;context&lt;/code&gt; 的方法被调用。</target>
        </trans-unit>
        <trans-unit id="725473ba1a25ffa9ed75e25bf705064099a7373d" translate="yes" xml:space="preserve">
          <source>If you pass a promise object to the &lt;code&gt;resolve&lt;/code&gt; function, the created promise will follow the state of that promise.</source>
          <target state="translated">如果将promise对象传递给 &lt;code&gt;resolve&lt;/code&gt; 函数，则创建的promise将遵循该promise的状态。</target>
        </trans-unit>
        <trans-unit id="c8c7f36a8c78ffc855273674eee0d9d279347fca" translate="yes" xml:space="preserve">
          <source>If you see this warning your code is probably not doing what you expect it to, the most common reason is passing the &lt;em&gt;result&lt;/em&gt; of calling a function to &lt;a href=&quot;api/then&quot;&gt;&lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; instead of the function &lt;em&gt;itself&lt;/em&gt;:</source>
          <target state="translated">如果您看到此警告，则您的代码可能未达到预期的效果，最常见的原因是将调用函数的&lt;em&gt;结果&lt;/em&gt;传递给&lt;a href=&quot;api/then&quot;&gt; &lt;code&gt;.then()&lt;/code&gt; &lt;/a&gt;而不是函数&lt;em&gt;本身&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="209a23ebfb5748a6ab8f80e05376ebdb5ccf11de" translate="yes" xml:space="preserve">
          <source>If you want to coordinate several discrete concurrent promises, use &lt;a href=&quot;promise.join&quot;&gt;&lt;code&gt;Promise.join&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">如果要协调多个离散的并发承诺，请使用&lt;a href=&quot;promise.join&quot;&gt; &lt;code&gt;Promise.join&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5b76d752c005430b67f6283cff61f81e57d83ce0" translate="yes" xml:space="preserve">
          <source>If you want to wrap an API with a promise manually, the correct syntax is:</source>
          <target state="translated">如果你想用一个承诺手动包装一个API,正确的语法是。</target>
        </trans-unit>
        <trans-unit id="700d4beb4e694e797eaff4fa5778aa5c5d7f5298" translate="yes" xml:space="preserve">
          <source>If you're familiar with PromiseKit, it is based on a same specification bluebird is based on so the API should feel familiar right away.</source>
          <target state="translated">如果你熟悉PromiseKit,那么它是基于和bluebird相同的规范,所以这个API应该会让你觉得很熟悉。</target>
        </trans-unit>
        <trans-unit id="966394e4086caa71b33f7995eed9fbcc4b6e2187" translate="yes" xml:space="preserve">
          <source>If your library needs to do something obtrusive like adding or modifying methods on the &lt;code&gt;Promise&lt;/code&gt; prototype, uses long stack traces or uses a custom unhandled rejection handler then... that's totally ok as long as you don't use &lt;code&gt;require(&quot;bluebird&quot;)&lt;/code&gt;. Instead you should create a file that creates an isolated copy. For example, creating a file called &lt;code&gt;bluebird-extended.js&lt;/code&gt; that contains:</source>
          <target state="translated">如果您的库需要在 &lt;code&gt;Promise&lt;/code&gt; 原型上做一些麻烦的事情，例如添加或修改方法，使用长堆栈跟踪或使用自定义未处理的拒绝处理程序，那么...只要您不使用 &lt;code&gt;require(&quot;bluebird&quot;)&lt;/code&gt; ，那完全没问题。相反，您应该创建一个创建隔离副本的文件。例如，创建一个名为 &lt;code&gt;bluebird-extended.js&lt;/code&gt; 的文件，其中包含：</target>
        </trans-unit>
        <trans-unit id="cbc582b62a43024af9610875e2f1c1a993555795" translate="yes" xml:space="preserve">
          <source>If your'e familiar with Java 8 lambdas, you can think of a promise as a &lt;code&gt;Future&lt;/code&gt; you can &lt;code&gt;map&lt;/code&gt; to another future.</source>
          <target state="translated">如果您熟悉Java 8 lambda，则可以将诺言视为 &lt;code&gt;Future&lt;/code&gt; ，可以 &lt;code&gt;map&lt;/code&gt; 到另一个Future。</target>
        </trans-unit>
        <trans-unit id="834102510a799a81df534fb9d6f8cdb91d442836" translate="yes" xml:space="preserve">
          <source>If, at any step:</source>
          <target state="translated">如果,在任何一步。</target>
        </trans-unit>
        <trans-unit id="f76b9571c2fa26f1c9c053453e48baf3102b175e" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;api/reflect&quot;&gt;&lt;code&gt;.reflect()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">实现&lt;a href=&quot;api/reflect&quot;&gt; &lt;code&gt;.reflect()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0de27db7a173e23bc1b1a951c986b9e75189651d" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#promisecoroutineaddyieldhandlerfunction-handler---void&quot;&gt;&lt;code&gt;Promise.coroutine.addYieldHandler()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">实现&lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#promisecoroutineaddyieldhandlerfunction-handler---void&quot;&gt; &lt;code&gt;Promise.coroutine.addYieldHandler()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="debaea1257108cf0777761addbfa5ec8ad866a63" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#tapfunction-handler---promise&quot;&gt;&lt;code&gt;Promise.prototype.tap()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">实现&lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#tapfunction-handler---promise&quot;&gt; &lt;code&gt;Promise.prototype.tap()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5a1c43a24101780f93b51137f52374d22e70596b" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;.bind&lt;/code&gt; and &lt;code&gt;Promise.bind&lt;/code&gt;</source>
          <target state="translated">实现 &lt;code&gt;.bind&lt;/code&gt; 和 &lt;code&gt;Promise.bind&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f380a273aee2d6cf970a6fe45244632c5d9b4cc" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;.return()&lt;/code&gt;</source>
          <target state="translated">实现 &lt;code&gt;.return()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4c72d943e49cf756fcbd5f12144b514c9e719f9" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;.throw()&lt;/code&gt;</source>
          <target state="translated">实现 &lt;code&gt;.throw()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae49e6671f17e74abdd91283eaaa890a378ca81b" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;Promise.method()&lt;/code&gt;</source>
          <target state="translated">实现 &lt;code&gt;Promise.method()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1d181fb40191fdf3fe9541cbc7a61c14dc076b35" translate="yes" xml:space="preserve">
          <source>Implement RejectionError wrapping and &lt;code&gt;.error()&lt;/code&gt; method</source>
          <target state="translated">实现RejectionError包装和 &lt;code&gt;.error()&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="ff1c32750ed475d16c2e3d6ee2570476a4351b7a" translate="yes" xml:space="preserve">
          <source>Implemented &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#global-rejection-events&quot;&gt;global rejection events&lt;/a&gt; (&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/428&quot;&gt;#428&lt;/a&gt;, &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/357&quot;&gt;#357&lt;/a&gt;)</source>
          <target state="translated">已实施的&lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#global-rejection-events&quot;&gt;全局拒绝事件&lt;/a&gt;（&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/428&quot;&gt;＃428&lt;/a&gt;，&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/357&quot;&gt;＃357&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="6677e178a6bc2ac6cc38cee7e51212de4486b2b2" translate="yes" xml:space="preserve">
          <source>Implementing general progress interfaces like in C#:</source>
          <target state="translated">像在C#中一样实现一般的进度接口。</target>
        </trans-unit>
        <trans-unit id="733eea0f9f3a4d9f23332caa166015a4f890c124" translate="yes" xml:space="preserve">
          <source>Implementing the example from &lt;a href=&quot;https://github.com/caolan/async#waterfalltasks-callback&quot;&gt;async homepage&lt;/a&gt;</source>
          <target state="translated">从&lt;a href=&quot;https://github.com/caolan/async#waterfalltasks-callback&quot;&gt;异步主页&lt;/a&gt;实现示例</target>
        </trans-unit>
        <trans-unit id="97ecdd3f427cfc303e767bb0913667606529c860" translate="yes" xml:space="preserve">
          <source>Implicit &lt;code&gt;Promise.all()&lt;/code&gt; when yielding an array from generators</source>
          <target state="translated">从生成器产生数组时隐式 &lt;code&gt;Promise.all()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1dd411a1bd6013312e12e897a0c51cd4f4318ca0" translate="yes" xml:space="preserve">
          <source>Improve &lt;code&gt;promisifyAll&lt;/code&gt; detection of functions that are class constructors. Fixes mongodb 2.x promisification.</source>
          <target state="translated">改进对作为类构造函数的函数的 &lt;code&gt;promisifyAll&lt;/code&gt; 检测。修复了mongodb 2.x promisification。</target>
        </trans-unit>
        <trans-unit id="213e96bdfb4a128bc3bd87f532efaf90f14c5e6a" translate="yes" xml:space="preserve">
          <source>Improve output of reporting unhandled non-errors</source>
          <target state="translated">改进报告未处理的非错误的输出。</target>
        </trans-unit>
        <trans-unit id="21437ff0b7933ce8b58f0d38d668c7b9602b5664" translate="yes" xml:space="preserve">
          <source>Improve overall performance when not using &lt;code&gt;.bind()&lt;/code&gt; or cancellation.</source>
          <target state="translated">不使用 &lt;code&gt;.bind()&lt;/code&gt; 或取消时提高整体性能。</target>
        </trans-unit>
        <trans-unit id="a3cd986d15205ea786fe95cf148b685b17a4a66b" translate="yes" xml:space="preserve">
          <source>Improve overall performance.</source>
          <target state="translated">提高整体业绩。</target>
        </trans-unit>
        <trans-unit id="d91321dac872eb3a4ecd05762060d481636fa793" translate="yes" xml:space="preserve">
          <source>Improve overall performance. Be able to sustain infinite recursion when using promises.</source>
          <target state="translated">提高整体性能。在使用承诺时,能够维持无限递归。</target>
        </trans-unit>
        <trans-unit id="23dc55298841549083703a0dc975bff9f3e5d5fc" translate="yes" xml:space="preserve">
          <source>Improve performance of .finally.</source>
          <target state="translated">提高.finally的性能。</target>
        </trans-unit>
        <trans-unit id="b5cef6dcb86b0975f111f8f1d79bf5d753600cad" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;.props()&lt;/code&gt; and collection methods when used with immediate values</source>
          <target state="translated">与立即值一起使用时，提高 &lt;code&gt;.props()&lt;/code&gt; 和收集方法的性能</target>
        </trans-unit>
        <trans-unit id="6533fb39d2c4b52d57bf0b0080357de93b567761" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;.reduce()&lt;/code&gt; when &lt;code&gt;initialValue&lt;/code&gt; can be synchronously cast to a value</source>
          <target state="translated">当 &lt;code&gt;initialValue&lt;/code&gt; 可以同步转换为一个值时，提高 &lt;code&gt;.reduce()&lt;/code&gt; 的性能</target>
        </trans-unit>
        <trans-unit id="b79e5ce64b3cc6df23f96da6189a55cda2f3a24b" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;.some()&lt;/code&gt;</source>
          <target state="translated">提高 &lt;code&gt;.some()&lt;/code&gt; 的性能</target>
        </trans-unit>
        <trans-unit id="6605838414ae4861872117f11458f4f7c032e53b" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;Promise.method&lt;/code&gt;</source>
          <target state="translated">提高 &lt;code&gt;Promise.method&lt;/code&gt; 的性能</target>
        </trans-unit>
        <trans-unit id="1801c2ab62399342798816e151c62d526a208232" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;Promise.race&lt;/code&gt;</source>
          <target state="translated">提高 &lt;code&gt;Promise.race&lt;/code&gt; 的性能</target>
        </trans-unit>
        <trans-unit id="b47c1066dd0e09e1dc6291709e049b1a62126113" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;Promise.try&lt;/code&gt;</source>
          <target state="translated">提高 &lt;code&gt;Promise.try&lt;/code&gt; 的绩效</target>
        </trans-unit>
        <trans-unit id="f0221a27976575e573ab343e0c7bf4e30199750e" translate="yes" xml:space="preserve">
          <source>Improve performance of all collection methods</source>
          <target state="translated">提高所有收集方法的性能</target>
        </trans-unit>
        <trans-unit id="69bc40cef74e6b8ed6de0d57bc11088841731b08" translate="yes" xml:space="preserve">
          <source>Improve performance of catch filters.</source>
          <target state="translated">提高捕获过滤器的性能。</target>
        </trans-unit>
        <trans-unit id="493b04565b586c443227bda9dba7b5733786d595" translate="yes" xml:space="preserve">
          <source>Improve performance of collection methods</source>
          <target state="translated">提高收集方法的性能</target>
        </trans-unit>
        <trans-unit id="f3e709b44915764f7a5d40fc9df801ca2e482471" translate="yes" xml:space="preserve">
          <source>Improve performance of generators</source>
          <target state="translated">提高发电机的性能</target>
        </trans-unit>
        <trans-unit id="f2f07a6efaf7192742177f90f38e34f5cffb946a" translate="yes" xml:space="preserve">
          <source>Improve performance of promise chains</source>
          <target state="translated">提高承诺链的绩效</target>
        </trans-unit>
        <trans-unit id="ab32070153659d73fbda42374c3ef4d00f9c1281" translate="yes" xml:space="preserve">
          <source>Improve performance of promisified functions on V8</source>
          <target state="translated">提高V8上已承诺功能的性能</target>
        </trans-unit>
        <trans-unit id="9c964cafe501b6c71e57bfaecc51d7213a1f33ad" translate="yes" xml:space="preserve">
          <source>Improve performance of promisified functions.</source>
          <target state="translated">提高承诺功能的性能。</target>
        </trans-unit>
        <trans-unit id="d0964ce694308926e6cce53db966d728b2dd5ab4" translate="yes" xml:space="preserve">
          <source>Improved performance and readability</source>
          <target state="translated">提高性能和可读性</target>
        </trans-unit>
        <trans-unit id="70e80457a02f473b417d800f6ebe8e2a3e15d72c" translate="yes" xml:space="preserve">
          <source>In 2.x, promise cancellation looked very differently. Promise cancellation received a major overhaul for version 3 in order to create a sound variant of cancellable promises. You can still use 2.x cancellation with bluebird 2.x (which is still supported - but not recommended). See &lt;a href=&quot;http://bluebirdjs.com/cancellation.html&quot;&gt;Cancellation&lt;/a&gt; for more details. The 2.x docs are &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/2.x/API.md&quot;&gt;still accessible under the 2.x branch&lt;/a&gt;.</source>
          <target state="translated">在2.x中，承诺取消的外观非常不同。承诺取消对版本3进行了大修，以创建可取消承诺的合理变体。您仍然可以对bluebird 2.x使用2.x取消（仍受支持-但不建议这样做）。有关更多详细信息，请参见&lt;a href=&quot;http://bluebirdjs.com/cancellation.html&quot;&gt;取消&lt;/a&gt;。&lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/2.x/API.md&quot;&gt;在2.x分支下仍可以访问&lt;/a&gt; 2.x文档。</target>
        </trans-unit>
        <trans-unit id="e8fc7d5be5578254c3c3ba0dde3ab83e463051fa" translate="yes" xml:space="preserve">
          <source>In Node.js you may configure warnings and long stack traces for the entire process using environment variables:</source>
          <target state="translated">在Node.js中,你可以使用环境变量为整个进程配置警告和长栈跟踪。</target>
        </trans-unit>
        <trans-unit id="361446f42424e75edad97d144b32a1e290e72cc3" translate="yes" xml:space="preserve">
          <source>In Node/io.js most APIs follow a convention of &lt;a href=&quot;https://gist.github.com/CrabDude/10907185&quot;&gt;'error-first, single-parameter'&lt;/a&gt; as such:</source>
          <target state="translated">在Node / io.js中，大多数API遵循&lt;a href=&quot;https://gist.github.com/CrabDude/10907185&quot;&gt;&amp;ldquo;错误优先，单参数&amp;rdquo;&lt;/a&gt;的约定，例如：</target>
        </trans-unit>
        <trans-unit id="20a81f38445f0a6f17f84f7b1c945721cfb38a3e" translate="yes" xml:space="preserve">
          <source>In Web Workers you may use &lt;code&gt;self.addEventListener&lt;/code&gt;.</source>
          <target state="translated">在Web &lt;code&gt;self.addEventListener&lt;/code&gt; 您可以使用self.addEventListener。</target>
        </trans-unit>
        <trans-unit id="6b759cd2431b6c3f52be7951a07c24cc5f5b3b96" translate="yes" xml:space="preserve">
          <source>In addition promises are always unwrapped. A promise implicitly has &lt;code&gt;Task.Unwrap&lt;/code&gt; called on it - that is, promises perform recursive assimilation of promises within them.</source>
          <target state="translated">此外，承诺总是无法兑现的。一个 &lt;code&gt;Task.Unwrap&lt;/code&gt; 隐式地调用了Task.Unwrap，即Promise在其中执行Promise的递归同化。</target>
        </trans-unit>
        <trans-unit id="da70284ad0b5f811fe8223b6b3d83e713568a28f" translate="yes" xml:space="preserve">
          <source>In addition promises are always unwrapped. That is, promises perform recursive assimilation of promises within them. You can't have a &lt;code&gt;Promise&amp;lt;Promise&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; where a &lt;code&gt;Future[Future[T]]&lt;/code&gt; is valid in Scala.</source>
          <target state="translated">此外，承诺总是无法兑现的。也就是说，promise在其中执行promise的递归同化。您没有 &lt;code&gt;Promise&amp;lt;Promise&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;Future[Future[T]]&lt;/code&gt; 在Scala中有效。</target>
        </trans-unit>
        <trans-unit id="b3db467e4305c26c33d91d438b39bab7913a7d8d" translate="yes" xml:space="preserve">
          <source>In all of the above cases the library made its classes available in one way or another. If this is not the case, you can still promisify by creating a throwaway instance:</source>
          <target state="translated">在上述所有情况下,库都以某种方式提供了它的类。如果不是这种情况,你仍然可以通过创建一个抛弃式实例来承诺。</target>
        </trans-unit>
        <trans-unit id="a37bb782f65c2292150ec12a9ec0ac667bbafa9d" translate="yes" xml:space="preserve">
          <source>In bluebird we've chosen to do the latter because resources are typically scarce. For example, if a database connection cannot be disposed of and Bluebird ignores that, the connection pool will be quickly depleted and the process will become unusable (all requests that query the database will wait forever). Since Bluebird doesn't know how to handle that, the only sensible default is to crash the process. That way, rather than getting a useless process that cannot fulfill more requests, we can swap the faulty worker with a new one letting the OS clean up the resources for us.</source>
          <target state="translated">在bluebird中,我们选择做后者,因为资源通常是稀缺的。例如,如果一个数据库连接无法处理,而Bluebird又忽略了这一点,那么连接池将很快耗尽,进程将变得无法使用(所有查询数据库的请求将永远等待)。由于Bluebird不知道如何处理这种情况,唯一明智的默认情况是崩溃进程。这样一来,与其得到一个无用的进程,无法满足更多的请求,我们可以用一个新的进程交换有问题的worker,让操作系统为我们清理资源。</target>
        </trans-unit>
        <trans-unit id="ca0b3dbad60939fa3e3338aec5bf46570e2d8a1a" translate="yes" xml:space="preserve">
          <source>In conjunction with &lt;a href=&quot;disposer&quot;&gt;&lt;code&gt;.disposer&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;using&lt;/code&gt; will make sure that no matter what, the specified disposer will be called when the promise returned by the callback passed to &lt;code&gt;using&lt;/code&gt; has settled. The disposer is necessary because there is no standard interface in node for disposing resources.</source>
          <target state="translated">与&lt;a href=&quot;disposer&quot;&gt; &lt;code&gt;.disposer&lt;/code&gt; &lt;/a&gt;结合使用， &lt;code&gt;using&lt;/code&gt; 将确保无论如何，当传递给 &lt;code&gt;using&lt;/code&gt; 的回调所返回的承诺已经解决时，将调用指定的处置器。该处理器是必需的，因为节点中没有用于配置资源的标准接口。</target>
        </trans-unit>
        <trans-unit id="879b1a8e6173fcc0fe684d08d132ce1871ae3253" translate="yes" xml:space="preserve">
          <source>In general, the usage of &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; is along the lines of &lt;code&gt;var fs = Promise.promisifyAll(require(&quot;fs&quot;))&lt;/code&gt;.</source>
          <target state="translated">一般来说，使用&lt;a href=&quot;api/promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt;是沿着线 &lt;code&gt;var fs = Promise.promisifyAll(require(&quot;fs&quot;))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8efb8cf18cab76bf61b065fcc2def10c9ed9fac9" translate="yes" xml:space="preserve">
          <source>In our dialog example perhaps we want to differentiate between a rejected promise because of some problem (bad AJAX, programming error, etc.) or because the user pressed the cancel button.</source>
          <target state="translated">在我们的对话框示例中,也许我们想区分因为某些问题(坏的AJAX,编程错误等)或因为用户按下取消按钮而被拒绝的承诺。</target>
        </trans-unit>
        <trans-unit id="b6bbd69af3538cceaf0f293038d0f3eaed462ca8" translate="yes" xml:space="preserve">
          <source>In practice:</source>
          <target state="translated">在实践中:</target>
        </trans-unit>
        <trans-unit id="21b9f4a2f2ffcaff8935b98b291fdfb43db81e8c" translate="yes" xml:space="preserve">
          <source>In recent versions generator libraries started abandoning old ideas of special tokens passed to callbacks and started using promises for what's being yielded.</source>
          <target state="translated">在最近的版本中,生成器库开始摒弃传递给回调的特殊令牌的旧观念,开始使用承诺来处理被产的东西。</target>
        </trans-unit>
        <trans-unit id="90361caad2f10101ee0f756a8ebd2978182891e3" translate="yes" xml:space="preserve">
          <source>In the above example, the connection returned by &lt;code&gt;getConnection&lt;/code&gt; can only be used via &lt;code&gt;Promise.using&lt;/code&gt;, like so:</source>
          <target state="translated">在上面的示例中，只能通过 &lt;code&gt;Promise.using&lt;/code&gt; 使用 &lt;code&gt;getConnection&lt;/code&gt; 返回的连接，如下所示：</target>
        </trans-unit>
        <trans-unit id="cb64939e278ff57bb52a7c44ea2a2cbd428cb81a" translate="yes" xml:space="preserve">
          <source>In the explicit construction anti-pattern, promise objects are created for no reason, complicating code.</source>
          <target state="translated">在显式构造反模式中,无缘无故创建承诺对象,使代码复杂化。</target>
        </trans-unit>
        <trans-unit id="b0070e87ecff77ecb23ce611e38aac089e617332" translate="yes" xml:space="preserve">
          <source>In the following example you might want to handle just the &lt;code&gt;SyntaxError&lt;/code&gt; from JSON.parse and Filesystem errors from &lt;code&gt;fs&lt;/code&gt; but let programmer errors bubble as unhandled rejections:</source>
          <target state="translated">在以下示例中，您可能只想处理JSON.parse中的 &lt;code&gt;SyntaxError&lt;/code&gt; 和 &lt;code&gt;fs&lt;/code&gt; 中的 Filesystem错误，但让程序员错误冒泡为未处理的拒绝：</target>
        </trans-unit>
        <trans-unit id="73d3bed94715ad4383569042f35e985547cd7283" translate="yes" xml:space="preserve">
          <source>In the latter the indentation stays flat no matter how many previous variables you need, whereas with the former each additional previous value would require an additional nesting level.</source>
          <target state="translated">在后一种情况下,无论你需要多少个前一个变量,都会保持平铺直叙,而在前一种情况下,每增加一个前一个值都需要增加一个嵌套级别。</target>
        </trans-unit>
        <trans-unit id="dd6afd7e774c8e6fdacd9e8f55a35e835be8f939" translate="yes" xml:space="preserve">
          <source>In this case, the promise resolves with itself which was is not intended.</source>
          <target state="translated">在这种情况下,承诺与自己解决了本来不打算解决的问题。</target>
        </trans-unit>
        <trans-unit id="30b4d4283864d46d2836b690ac2cbfeafa74746b" translate="yes" xml:space="preserve">
          <source>Individual promisifcation uses current &lt;code&gt;this&lt;/code&gt; if no explicit receiver is given</source>
          <target state="translated">个人promisifcation使用当前 &lt;code&gt;this&lt;/code&gt; 如果没有明确的接收器给出</target>
        </trans-unit>
        <trans-unit id="68c8caa0f2f33563e5d4c95632e8edaafba86244" translate="yes" xml:space="preserve">
          <source>Initially the Dialog class sets the two callbacks to &lt;em&gt;noop&lt;/em&gt; functions. It is up to the child class to call them when necessary. We break down the promise creation to one function &lt;code&gt;waitForUser()&lt;/code&gt; that sets the callbacks and returns a promise. At this level the &lt;code&gt;show()&lt;/code&gt; and &lt;code&gt;hide()&lt;/code&gt; are just &lt;em&gt;noop&lt;/em&gt; functions as well and will be implemented by the child classes.</source>
          <target state="translated">最初，Dialog类将两个回调设置为&lt;em&gt;noop&lt;/em&gt;函数。在必要时，由孩子们决定调用它们。我们将promise创建分解为一个函数 &lt;code&gt;waitForUser()&lt;/code&gt; ，该函数设置回调并返回promise。在这个级别上， &lt;code&gt;show()&lt;/code&gt; 和 &lt;code&gt;hide()&lt;/code&gt; 也是&lt;em&gt;noop&lt;/em&gt;函数，将由子类实现。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="d84677d86357a2c0115e2ed2adb5f6ec133b7f26" translate="yes" xml:space="preserve">
          <source>Instead of using the Deferred anti-pattern, the code should simply return the promise it already has and propagate values using &lt;code&gt;return&lt;/code&gt;:</source>
          <target state="translated">该代码不应使用Deferred反模式，而应简单地返回它已经具有的promise，并使用 &lt;code&gt;return&lt;/code&gt; 传播值：</target>
        </trans-unit>
        <trans-unit id="1aed780a746f68d28a85c473dd835c234712b990" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; :</source>
          <target state="translated">而是使用&lt;a href=&quot;api/promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="659525747c675f26d0d0761f93182ab5228cbc26" translate="yes" xml:space="preserve">
          <source>Into this:</source>
          <target state="translated">进入这个。</target>
        </trans-unit>
        <trans-unit id="a66cb4039287c802cdc27ed98f34dc1c2d5d9411" translate="yes" xml:space="preserve">
          <source>It also works on singletons or specific instances:</source>
          <target state="translated">它也适用于单子或特定实例。</target>
        </trans-unit>
        <trans-unit id="6b5d95eeedfe49016755274286b46a188fd09776" translate="yes" xml:space="preserve">
          <source>It comes in two variants. - A tapCatch-all variant similar to &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; block. This variant is compatible with native promises. - A filtered variant (like other non-JS languages typically have) that lets you only handle specific errors. &lt;strong&gt;This variant is usually preferable&lt;/strong&gt;.</source>
          <target state="translated">它有两种变体。-与&lt;a href=&quot;catch&quot;&gt; &lt;code&gt;.catch&lt;/code&gt; &lt;/a&gt;块类似的tapCatch-all变体。此变体与本机承诺兼容。-过滤的变体（类似于其他非JS语言通常具有的变体），仅允许您处理特定的错误。&lt;strong&gt;通常最好使用此变体&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="e2a3866a72ba04bc9a62fa718c486091a65f59f8" translate="yes" xml:space="preserve">
          <source>It is equivalent to the following &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; pattern:</source>
          <target state="translated">它等效于以下&lt;a href=&quot;catch&quot;&gt; &lt;code&gt;.catch&lt;/code&gt; &lt;/a&gt;模式：</target>
        </trans-unit>
        <trans-unit id="0b0ded67bc5c7c35daa1f171d80dccf1a33e74e4" translate="yes" xml:space="preserve">
          <source>It is essentially an efficient shortcut for doing a &lt;a href=&quot;map&quot;&gt;&lt;code&gt;.map&lt;/code&gt;&lt;/a&gt; and then &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter&quot;&gt;&lt;code&gt;Array#filter&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">从本质&lt;a href=&quot;map&quot;&gt; &lt;code&gt;.map&lt;/code&gt; &lt;/a&gt;，它是执行.map然后执行&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter&quot;&gt; &lt;code&gt;Array#filter&lt;/code&gt; &lt;/a&gt;的有效快捷方式：</target>
        </trans-unit>
        <trans-unit id="67ad0cadb6c3a5671744781f608f9a02e1c5a392" translate="yes" xml:space="preserve">
          <source>It is more likely that you would write this instead in the sync world:</source>
          <target state="translated">在同步世界里,你更有可能写出这样的代替。</target>
        </trans-unit>
        <trans-unit id="53a01add8c2bcb3ae05a334c130487578987c686" translate="yes" xml:space="preserve">
          <source>It is often said that promises cannot be cancellable because they can have multiple consumers.</source>
          <target state="translated">人们常说,承诺不能取消,因为承诺可以有多个消费者。</target>
        </trans-unit>
        <trans-unit id="6b0e7d44695db980a8f0ed40ee055bb11d90c7f7" translate="yes" xml:space="preserve">
          <source>It is very subtle but over time this code will exhaust the entire connection pool and the server needs to be restarted. This is because reading the file may fail and then of course &lt;code&gt;.spread&lt;/code&gt; is not called at all and thus the connection is not closed.</source>
          <target state="translated">这非常微妙，但是随着时间的流逝，这段代码将耗尽整个连接池，并且需要重新启动服务器。这是因为读取文件可能会失败，然后当然不会调用 &lt;code&gt;.spread&lt;/code&gt; ，因此连接不会关闭。</target>
        </trans-unit>
        <trans-unit id="25e4aad38b66ae4f579919e5442c2f87282d298e" translate="yes" xml:space="preserve">
          <source>It might look like this:</source>
          <target state="translated">它可能是这样的。</target>
        </trans-unit>
        <trans-unit id="f3201aa0565e8be1e1547bcb52a2f64c00b2bc44" translate="yes" xml:space="preserve">
          <source>It should be noted that there is no real need to attach the handlers asynchronously. Exactly the same effect can be achieved with:</source>
          <target state="translated">需要注意的是,并没有真正需要异步附加处理程序。可以用以下方法实现完全相同的效果:</target>
        </trans-unit>
        <trans-unit id="f25d9aa71a1aef724d7f8d933c376e203e6ccfd0" translate="yes" xml:space="preserve">
          <source>It's also possible to use a disposer pattern (but not actual disposers) for transaction management:</source>
          <target state="translated">也可以使用处置器模式(但不是实际处置器)进行事务管理。</target>
        </trans-unit>
        <trans-unit id="a3b38a83ae257f40976a60195f877e73b38d539c" translate="yes" xml:space="preserve">
          <source>Iterate over an array, or a promise of an array, which contains promises (or a mix of promises and values) with the given &lt;code&gt;iterator&lt;/code&gt; function with the signature &lt;code&gt;(value, index, length)&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the resolved value of a respective promise in the input array. &lt;strong&gt;Iteration happens serially&lt;/strong&gt;. If the iterator function returns a promise or a thenable, then the result of the promise is awaited before continuing with next iteration. If any promise in the input array is rejected, then the returned promise is rejected as well.</source>
          <target state="translated">遍历数组或数组的promise，该数组或promise包含带有给定 &lt;code&gt;iterator&lt;/code&gt; 函数的promise（或promise和值的混合），并带有签名 &lt;code&gt;(value, index, length)&lt;/code&gt; ，其中 &lt;code&gt;value&lt;/code&gt; 是输入数组。&lt;strong&gt;迭代是串行发生的&lt;/strong&gt;。如果迭代器函数返回promise或thenable，则在继续下一次迭代之前，将等待promise的结果。如果输入数组中的任何promise被拒绝，那么返回的promise也将被拒绝。</target>
        </trans-unit>
        <trans-unit id="d889900760cbb5576feda8db1d4c5015016f6e85" translate="yes" xml:space="preserve">
          <source>Iterate over an array, or a promise of an array, which contains promises (or a mix of promises and values) with the given &lt;code&gt;iterator&lt;/code&gt; function with the signature &lt;code&gt;(value, index, length)&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the resolved value of a respective promise in the input array. Iteration happens serially. If any promise in the input array is rejected the returned promise is rejected as well.</source>
          <target state="translated">遍历数组或数组的promise，该数组或promise包含带有给定 &lt;code&gt;iterator&lt;/code&gt; 函数的promise（或promise和值的混合），并带有签名 &lt;code&gt;(value, index, length)&lt;/code&gt; ，其中 &lt;code&gt;value&lt;/code&gt; 是输入数组。迭代是串行发生的。如果输入数组中的任何承诺被拒绝，则返回的承诺也将被拒绝。</target>
        </trans-unit>
        <trans-unit id="e027e57610f85225767aafbbf23fed7457e55828" translate="yes" xml:space="preserve">
          <source>Java</source>
          <target state="translated">Java</target>
        </trans-unit>
        <trans-unit id="769460330d98abc38d4f157088d641889b8e080c" translate="yes" xml:space="preserve">
          <source>Just like a future, a promise represents a value over time. The value can resolve to either a fulfilled (ok completion) or rejected (error completion) state.</source>
          <target state="translated">就像未来一样,一个承诺代表了一个时间上的值,这个值可以解析为满足(ok完成)或拒绝(错误完成)状态。这个值可以解析为实现(ok完成)或拒绝(错误完成)状态。</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">根据麻省理工学院许可证授权。</target>
        </trans-unit>
        <trans-unit id="d2b04d056ad9ef4e9bfb796dceb8c12c3d2724b7" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;all&quot;&gt;&lt;code&gt;.all&lt;/code&gt;&lt;/a&gt; but for object properties or &lt;code&gt;Map&lt;/code&gt;s* entries instead of iterated values. Returns a promise that is fulfilled when all the properties of the object or the &lt;code&gt;Map&lt;/code&gt;'s' values** are fulfilled. The promise's fulfillment value is an object or a &lt;code&gt;Map&lt;/code&gt; with fulfillment values at respective keys to the original object or a &lt;code&gt;Map&lt;/code&gt;. If any promise in the object or &lt;code&gt;Map&lt;/code&gt; rejects, the returned promise is rejected with the rejection reason.</source>
          <target state="translated">类似于&lt;a href=&quot;all&quot;&gt; &lt;code&gt;.all&lt;/code&gt; ,&lt;/a&gt;但对象属性或 &lt;code&gt;Map&lt;/code&gt; s *条目（而不是迭代值）。返回当对象的所有属性或 &lt;code&gt;Map&lt;/code&gt; 的值**都满足时实现的promise 。许诺的实现值是一个对象或 &lt;code&gt;Map&lt;/code&gt; ，在原始对象或 &lt;code&gt;Map&lt;/code&gt; 的各个键处具有实现值。如果对象或 &lt;code&gt;Map&lt;/code&gt; 中的任何承诺被拒绝，则返回的承诺将被拒绝，并带有拒绝原因。</target>
        </trans-unit>
        <trans-unit id="0868022eae9754566ebce8819ba10c34f00156c4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; but instead of catching all types of exceptions, it only catches operational errors.</source>
          <target state="translated">像&lt;a href=&quot;catch&quot;&gt; &lt;code&gt;.catch&lt;/code&gt; &lt;/a&gt;一样，但不捕获所有类型的异常，它仅捕获操作错误。</target>
        </trans-unit>
        <trans-unit id="f7724ecb2f95d5397a59e0da7c44a35554300566" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;finally&quot;&gt;&lt;code&gt;.finally&lt;/code&gt;&lt;/a&gt; that is not called for fulfillments.</source>
          <target state="translated">像&lt;a href=&quot;finally&quot;&gt; &lt;code&gt;.finally&lt;/code&gt; &lt;/a&gt;一样，这并不要求实现。</target>
        </trans-unit>
        <trans-unit id="4b705bae03f08f49a3c59a2a4c3c23676360ce32" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;promise.some&quot;&gt;&lt;code&gt;Promise.some&lt;/code&gt;&lt;/a&gt;, with 1 as &lt;code&gt;count&lt;/code&gt;. However, if the promise fulfills, the fulfillment value is not an array of 1 but the value directly.</source>
          <target state="translated">像&lt;a href=&quot;promise.some&quot;&gt; &lt;code&gt;Promise.some&lt;/code&gt; &lt;/a&gt;一样，以1为 &lt;code&gt;count&lt;/code&gt; 。但是，如果Promise满足，则实现值不是1的数组，而是直接值。</target>
        </trans-unit>
        <trans-unit id="a0572842c5b510f6b6c6d450ffa47af7bfa19546" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;then&quot;&gt;&lt;code&gt;.then&lt;/code&gt;&lt;/a&gt;, but any unhandled rejection that ends up here will crash the process (in node) or be thrown as an error (in browsers). The use of this method is heavily discouraged and it only exists for historical reasons.</source>
          <target state="translated">像&lt;a href=&quot;then&quot;&gt; &lt;code&gt;.then&lt;/code&gt; &lt;/a&gt;一样，但是任何最终未解决的拒绝最终都会使进程崩溃（在节点中）或作为错误抛出（在浏览器中）。不鼓励使用此方法，并且仅出于历史原因存在。</target>
        </trans-unit>
        <trans-unit id="1d64e920d46f5914cb7b3fc3949b2df8768d761d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;.map&lt;/code&gt; and &lt;code&gt;.filter&lt;/code&gt;, &lt;code&gt;.reduce&lt;/code&gt; now allows returning promises and thenables from the iteration function.</source>
          <target state="translated">像 &lt;code&gt;.map&lt;/code&gt; 和 &lt;code&gt;.filter&lt;/code&gt; ， &lt;code&gt;.reduce&lt;/code&gt; 现在允许从迭代函数返回的承诺和thenables。</target>
        </trans-unit>
        <trans-unit id="f9b88079f4caa0345add2b49d7a0be51ed016806" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;.then()&lt;/code&gt;, but any unhandled rejection that ends up here will be thrown as an error. Again, only the variant with the progression handler is deprecated here. &lt;code&gt;.done&lt;/code&gt; is still fully supported.</source>
          <target state="translated">就像 &lt;code&gt;.then()&lt;/code&gt; 一样，但是任何未处理的拒绝最终都将作为错误抛出。同样，此处仅弃用带有进度处理程序的变量。 &lt;code&gt;.done&lt;/code&gt; 仍得到完全支持。</target>
        </trans-unit>
        <trans-unit id="eaab59843408be17f1182d2a7ba7d498c9751120" translate="yes" xml:space="preserve">
          <source>Like calling &lt;code&gt;.then&lt;/code&gt;, but the fulfillment value &lt;em&gt;must be&lt;/em&gt; an array, which is flattened to the formal parameters of the fulfillment handler.</source>
          <target state="translated">就像调用 &lt;code&gt;.then&lt;/code&gt; 一样，但是实现值&lt;em&gt;必须是&lt;/em&gt;一个数组，该数组将展平为实现处理程序的形式参数。</target>
        </trans-unit>
        <trans-unit id="4d46fec21cdff120fbce1d5c81043ed187891e17" translate="yes" xml:space="preserve">
          <source>Local rejection events</source>
          <target state="translated">本地拒绝活动</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Logging</target>
        </trans-unit>
        <trans-unit id="25c9bdc07ce0dfdf61f61c6ce40dbedeb1c6dd8e" translate="yes" xml:space="preserve">
          <source>Logging after the promise became GCd (requires a native node.js module)</source>
          <target state="translated">承诺变成GCd后的日志记录(需要原生node.js模块)</target>
        </trans-unit>
        <trans-unit id="44413342754143aa1961f15d95ef6db04a6b6098" translate="yes" xml:space="preserve">
          <source>Long stack traces</source>
          <target state="translated">长堆栈痕迹</target>
        </trans-unit>
        <trans-unit id="4d0119ac596cae5eba4e7c9ece07c3d282260f3e" translate="yes" xml:space="preserve">
          <source>Long stack traces are enabled by default in the debug build.</source>
          <target state="translated">在调试构建中,默认启用长栈跟踪。</target>
        </trans-unit>
        <trans-unit id="5585738e86f015af086921d0b41e009a6fb65e3d" translate="yes" xml:space="preserve">
          <source>Long stack traces are only supported in Chrome, recent Firefoxes and Internet Explorer 10+</source>
          <target state="translated">只有在Chrome、最近的Firefox和Internet Explorer 10以上版本中才支持长堆栈痕迹。</target>
        </trans-unit>
        <trans-unit id="9aba1e438bce5b03f5ff76a06150c5afd0f112d5" translate="yes" xml:space="preserve">
          <source>Long stack traces are supported now in IE10+</source>
          <target state="translated">现在在IE10+中支持长堆栈痕迹。</target>
        </trans-unit>
        <trans-unit id="0d4e72958bdd71df94bdc91c2471299f772d9de9" translate="yes" xml:space="preserve">
          <source>Long stack traces have been re-designed. They are now much more readable, succint, relevant and consistent across bluebird features.</source>
          <target state="translated">重新设计了长堆栈痕迹,使其更具可读性、简洁性、相关性,并与蓝鸟的特征保持一致。现在,它们的可读性更强,更简洁,更相关,而且在蓝鸟的功能上也更一致。</target>
        </trans-unit>
        <trans-unit id="4d32bb2f1ca24d68c701d853a17b879746200c1e" translate="yes" xml:space="preserve">
          <source>Major debuggability improvements:</source>
          <target state="translated">重大的调试性改进。</target>
        </trans-unit>
        <trans-unit id="4e7cd8e3e2364f713fb55eb6da548439b6487c93" translate="yes" xml:space="preserve">
          <source>Major internal refactoring related to testing code and source code file layout</source>
          <target state="translated">与测试代码和源码文件布局有关的重大内部重构</target>
        </trans-unit>
        <trans-unit id="7d05db1f390d07e6c3780eb841599459e0bc86db" translate="yes" xml:space="preserve">
          <source>Make .race() and Promise.race() forever pending on empty collections</source>
          <target state="translated">让.race()和Promise.race()在空的集合上永远挂起。</target>
        </trans-unit>
        <trans-unit id="a958e3fae41091d69ad2857f0e309f4e5d0123cb" translate="yes" xml:space="preserve">
          <source>Make PromiseRejectionEvent confrom to spec (&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/1509&quot;&gt;&lt;code&gt;#1509&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">将PromiseRejectionEvent设置为spec（&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/1509&quot;&gt; &lt;code&gt;#1509&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="f545f488c8e51d1bcb95f6e96e06f76a78762db7" translate="yes" xml:space="preserve">
          <source>Make build script's output work without TTY</source>
          <target state="translated">使构建脚本的输出在没有TTY的情况下也能正常工作。</target>
        </trans-unit>
        <trans-unit id="6de105dd31451a68ffa7b10edcdad659c72911a0" translate="yes" xml:space="preserve">
          <source>Make progress a core feature. Fixes &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/535&quot;&gt;&lt;code&gt;#535&lt;/code&gt;&lt;/a&gt; Note that progress has been removed in 3.x - this is only a fix necessary for 2.x custom builds.</source>
          <target state="translated">使进度成为核心功能。修复&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/535&quot;&gt; &lt;code&gt;#535&lt;/code&gt; &lt;/a&gt;注意，在3.x中已删除进度-这仅是2.x自定义构建所必需的修复。</target>
        </trans-unit>
        <trans-unit id="d25de34f144aaa815f7ee100219c0875ec327f00" translate="yes" xml:space="preserve">
          <source>Make tests pass Internet Explorer 8</source>
          <target state="translated">使测试通过Internet Explorer 8</target>
        </trans-unit>
        <trans-unit id="2ae67022300ef1cd200bf479b96deb439531bc00" translate="yes" xml:space="preserve">
          <source>Managing resources properly without leaks can be challenging. Simply using &lt;code&gt;.finally&lt;/code&gt; is not enough as the following example demonstrates:</source>
          <target state="translated">正确地管理资源而不会泄漏可能是一个挑战。如下面的示例所示，仅使用 &lt;code&gt;.finally&lt;/code&gt; 是不够的：</target>
        </trans-unit>
        <trans-unit id="107b1032597492e8483d652c4a4ce608f171eba8" translate="yes" xml:space="preserve">
          <source>Map Option: concurrency</source>
          <target state="translated">地图选项:并发量</target>
        </trans-unit>
        <trans-unit id="a50a46e16b741d58429e4aa0f944bc0391ee46f8" translate="yes" xml:space="preserve">
          <source>Methods of &lt;code&gt;Promise&lt;/code&gt; instances and core static methods of the Promise class to deal with collections of promises or mixed promises and values.</source>
          <target state="translated">方法 &lt;code&gt;Promise&lt;/code&gt; 实例和承诺类的核心静态方法来处理的承诺或混合承诺和值的集合。</target>
        </trans-unit>
        <trans-unit id="ae38184c5e1cc02a77f22646c0e9e6fb64bf94fd" translate="yes" xml:space="preserve">
          <source>Methods on &lt;code&gt;Function.prototype&lt;/code&gt; are no longer promisified (&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/680&quot;&gt;&lt;code&gt;#680&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;Function.prototype&lt;/code&gt; 的方法不再适用（&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/680&quot;&gt; &lt;code&gt;#680&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="af7ee6528f585594a5d8dbab3c9c2ad5078d7461" translate="yes" xml:space="preserve">
          <source>Minified source file meant to be used in production. Warnings and long straces are disabled. The gzipped size is 17.76KB.</source>
          <target state="translated">小型化的源文件,用于生产中。警告和长链被禁用。压缩后的大小为17.76KB。</target>
        </trans-unit>
        <trans-unit id="cddf33528c938c1495240e1ee5dc6ea07a8ea077" translate="yes" xml:space="preserve">
          <source>Misc:</source>
          <target state="translated">Misc:</target>
        </trans-unit>
        <trans-unit id="cbb2eaaf602b7e2cec410e3a49e5f52907359976" translate="yes" xml:space="preserve">
          <source>Mongoose works with persistent connections and the driver takes care of reconnections/disposals. For this reason using &lt;code&gt;using&lt;/code&gt; with it isn't required - instead connect on server startup and use promisification to expose promises.</source>
          <target state="translated">猫鼬使用持久连接，驱动程序负责重新连接/处置。因此，不需要 &lt;code&gt;using&lt;/code&gt; 它-而是在服务器启动时连接并使用promisification公开承诺。</target>
        </trans-unit>
        <trans-unit id="bc8341442a59c4454f469778737b7b06e02ad229" translate="yes" xml:space="preserve">
          <source>Mongoose/MongoDB</source>
          <target state="translated">Mongoose/MongoDB</target>
        </trans-unit>
        <trans-unit id="331f3f9f6d3697a3169ac32b4263f8b1778c3e97" translate="yes" xml:space="preserve">
          <source>More Common Examples</source>
          <target state="translated">更常见的例子</target>
        </trans-unit>
        <trans-unit id="5623f76074955ea9ab1db3ab04c9bff15d87a6c2" translate="yes" xml:space="preserve">
          <source>More common examples</source>
          <target state="translated">更常见的例子</target>
        </trans-unit>
        <trans-unit id="eb77d4b0690c471c302bf76046f4c7afa76f3db6" translate="yes" xml:space="preserve">
          <source>More performance improvements when long stack traces are enabled</source>
          <target state="translated">启用长堆栈跟踪后,性能得到更多提升。</target>
        </trans-unit>
        <trans-unit id="3a7a86c3c7bb6f061ed4b7dd4612a07ea2e55494" translate="yes" xml:space="preserve">
          <source>More reading:</source>
          <target state="translated">更多的阅读。</target>
        </trans-unit>
        <trans-unit id="deaa0c393a6613972aaccbf1fecfdad67aa21e88" translate="yes" xml:space="preserve">
          <source>MySQL</source>
          <target state="translated">MySQL</target>
        </trans-unit>
        <trans-unit id="63cd8ad40499d81ac4cfa72cb023f0f0e2a46fc4" translate="yes" xml:space="preserve">
          <source>New in bluebird 3.0</source>
          <target state="translated">bluebird 3.0中的新功能</target>
        </trans-unit>
        <trans-unit id="4c06116ec441fcbe51fa98c044bc02e5a87998c7" translate="yes" xml:space="preserve">
          <source>New method: &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#promiseonunhandledrejectionhandledfunction-handler---undefined&quot;&gt;&lt;code&gt;Promise.onUnhandledRejectionHandled()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">新方法：&lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#promiseonunhandledrejectionhandledfunction-handler---undefined&quot;&gt; &lt;code&gt;Promise.onUnhandledRejectionHandled()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98ef7df279344d4e364f9fc4312d95513017e539" translate="yes" xml:space="preserve">
          <source>New method: &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#reason---dynamic&quot;&gt;&lt;code&gt;.reason()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">新方法：&lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#reason---dynamic&quot;&gt; &lt;code&gt;.reason()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7244a976bd562fa5bdab260bfa92ffb53b2f75df" translate="yes" xml:space="preserve">
          <source>New method: &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#value---dynamic&quot;&gt;&lt;code&gt;.value()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">新方法：&lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#value---dynamic&quot;&gt; &lt;code&gt;.value()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e97753de8b2fb704fe13fb56eee1b6956901e28" translate="yes" xml:space="preserve">
          <source>Node environment detection can no longer be fooled</source>
          <target state="translated">节点环境检测不能再上当了</target>
        </trans-unit>
        <trans-unit id="36f139c394850c9c9489f54e55411c65c03b1e5e" translate="yes" xml:space="preserve">
          <source>Node installation</source>
          <target state="translated">节点安装</target>
        </trans-unit>
        <trans-unit id="10b3493287f831e81a438811a1ffba01f8cec4b7" translate="yes" xml:space="preserve">
          <source>Node.js</source>
          <target state="translated">Node.js</target>
        </trans-unit>
        <trans-unit id="973a79d67e462fcd740058903de5ac75c5e42ed4" translate="yes" xml:space="preserve">
          <source>Node.js performance: promisified functions try to check amount of passed arguments in most optimal order</source>
          <target state="translated">Node.js性能:承诺的函数会以最佳顺序检查传递的参数数量。</target>
        </trans-unit>
        <trans-unit id="21d569f35ecd5c10a6a6f1ab8aec8e1753640885" translate="yes" xml:space="preserve">
          <source>Node.js promisified functions will have same &lt;code&gt;.length&lt;/code&gt; as the original function minus one (for the callback parameter)</source>
          <target state="translated">Node.js的promisified功能将具有相同 &lt;code&gt;.length&lt;/code&gt; 与原函数负一（回调参数）</target>
        </trans-unit>
        <trans-unit id="6c8c6cfa65668d483f7a4b264c38fc353e937af3" translate="yes" xml:space="preserve">
          <source>Nodeify doesn't pass second argument to the callback if the promise is fulfilled with &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">如果承诺与兑现Nodeify没有通过第二个参数回调 &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b5673141cf57847c5379b8f84249704a24a566a4" translate="yes" xml:space="preserve">
          <source>None of the collection methods modify the original input. Holes in arrays are treated as if they were defined with the value &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">没有任何一种收集方法会修改原始输入。将数组中的孔视为使用值 &lt;code&gt;undefined&lt;/code&gt; 定义。</target>
        </trans-unit>
        <trans-unit id="7e35ac0a9b7c71da68e4e0db0a51a9c2cf39da4d" translate="yes" xml:space="preserve">
          <source>Normal callbacks:</source>
          <target state="translated">正常回调。</target>
        </trans-unit>
        <trans-unit id="0d7e35c7b10d9ccf8a2e395ca44cbdd4ab1c9fb3" translate="yes" xml:space="preserve">
          <source>Normally stack traces don't go beyond asynchronous boundaries so their utility is greatly reduced in asynchronous code:</source>
          <target state="translated">通常堆栈痕迹不会超出异步的边界,所以在异步代码中,堆栈痕迹的作用会大大降低。</target>
        </trans-unit>
        <trans-unit id="5bbef690c10dd98cdafb9fad511260630850d165" translate="yes" xml:space="preserve">
          <source>Not only is the code shorter but more importantly, if there is any error it will propagate properly to the final consumer.</source>
          <target state="translated">不仅代码更短,更重要的是,如果有任何错误,它将正确地传播给最终消费者。</target>
        </trans-unit>
        <trans-unit id="601e20ca34667b0a121fe532f625d50ac9e32a89" translate="yes" xml:space="preserve">
          <source>Note - in order to get full stack traces with warnings in Node 6.x+ you need to enable to &lt;code&gt;--trace-warnings&lt;/code&gt; flag which will give you a full stack trace of where the warning is coming from.</source>
          <target state="translated">注意-为了在Node 6.x +中获得带有警告的完整堆栈跟踪，您需要启用 &lt;code&gt;--trace-warnings&lt;/code&gt; 标志，这将为您提供警告来源的完整堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="14f4f32d734d4dde2357de9c28aa2e9db4f442b8" translate="yes" xml:space="preserve">
          <source>Note about disposers in node</source>
          <target state="translated">节点中处置器的注意事项</target>
        </trans-unit>
        <trans-unit id="628368b01a8c147d7adbe65259137f54770d74df" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;spread&quot;&gt;&lt;code&gt;.spread()&lt;/code&gt;&lt;/a&gt; implicitly does &lt;a href=&quot;all&quot;&gt;&lt;code&gt;.all()&lt;/code&gt;&lt;/a&gt; but the ES6 destructuring syntax doesn't, hence the manual &lt;code&gt;.all()&lt;/code&gt; call in the above code.</source>
          <target state="translated">注意，&lt;a href=&quot;spread&quot;&gt; &lt;code&gt;.spread()&lt;/code&gt; &lt;/a&gt;隐式地做&lt;a href=&quot;all&quot;&gt; &lt;code&gt;.all()&lt;/code&gt; &lt;/a&gt;，但ES6解构语法不，因此手册 &lt;code&gt;.all()&lt;/code&gt; 在上面的代码调用。</target>
        </trans-unit>
        <trans-unit id="4f4cc52a9da922cd3c5be1d218aeb2480ead589e" translate="yes" xml:space="preserve">
          <source>Note that Mongoose already ships with promise support but the promises it offers are significantly slower and don't report unhandled rejections so it is recommended to use automatic promisification with it anyway:</source>
          <target state="translated">需要注意的是,Mongoose已经提供了诺言支持,但它提供的诺言速度明显较慢,而且不会报告未处理的拒绝,所以建议还是使用自动诺言与之配合。</target>
        </trans-unit>
        <trans-unit id="29e8a3550207f0693fbe258a0b408370b65284bd" translate="yes" xml:space="preserve">
          <source>Note that bind is only propagated with promise transformation. If you create new promise chains inside a handler, those chains are not bound to the &quot;upper&quot; &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">请注意，绑定仅通过promise转换传播。如果处理程序中创建新的承诺链，这些链不是绑定到&amp;ldquo;上&amp;rdquo; &lt;code&gt;this&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e18ae6fc287a535de54a7ef47226f40baba44a5f" translate="yes" xml:space="preserve">
          <source>Note that if the node function is a method of some object, you can pass the object as the second argument like so:</source>
          <target state="translated">注意,如果节点函数是某个对象的方法,你可以像这样把对象作为第二个参数传递。</target>
        </trans-unit>
        <trans-unit id="049b2f103da24d1cdf9b651db0f13464d2a62368" translate="yes" xml:space="preserve">
          <source>Note that if using ES6, the above can be replaced with &lt;a href=&quot;then&quot;&gt;&lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; and destructuring:</source>
          <target state="translated">请注意，如果使用ES6，则可以将以上内容替换为&lt;a href=&quot;then&quot;&gt; &lt;code&gt;.then()&lt;/code&gt; &lt;/a&gt;并进行解构：</target>
        </trans-unit>
        <trans-unit id="e0a368b621b24c61956a2d40d7353ec38ebe9f4e" translate="yes" xml:space="preserve">
          <source>Note that if you have no use for the result object other than retrieving the properties, it is more convenient to use &lt;a href=&quot;promise.join&quot;&gt;&lt;code&gt;Promise.join&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">请注意，如果除了检索属性之外对结果对象没有其他用途，则使用&lt;a href=&quot;promise.join&quot;&gt; &lt;code&gt;Promise.join&lt;/code&gt; &lt;/a&gt;更为方便：</target>
        </trans-unit>
        <trans-unit id="3de0bd0db4f60bc1b355d5d97bda28262272a5e5" translate="yes" xml:space="preserve">
          <source>Note that it is an error to consume an already cancelled promise, doing such a thing will give you a promise that is rejected with &lt;code&gt;new CancellationError(&quot;late cancellation observer&quot;)&lt;/code&gt; as the rejection reason.</source>
          <target state="translated">请注意，使用已经取消的承诺是错误的，执行此操作将给您一个被 &lt;code&gt;new CancellationError(&quot;late cancellation observer&quot;)&lt;/code&gt; 作为拒绝原因而拒绝的承诺。</target>
        </trans-unit>
        <trans-unit id="7fba6dfbb297631502284b27e815e4abd333271d" translate="yes" xml:space="preserve">
          <source>Note that promises model a &lt;em&gt;single value through time&lt;/em&gt;, they only resolve &lt;em&gt;once&lt;/em&gt; - so while they're a good fit for a single event, they are not recommended for multiple event APIs.</source>
          <target state="translated">请注意，promise &lt;em&gt;通过时间&lt;/em&gt;对&lt;em&gt;单个值&lt;/em&gt;建模，它们只能解析&lt;em&gt;一次&lt;/em&gt; -因此，尽管它们非常适合单个事件，但不建议将其用于多个事件API。</target>
        </trans-unit>
        <trans-unit id="6c0a18493f92a9cdbebf344b13ce97703f7982f1" translate="yes" xml:space="preserve">
          <source>Note that the 3.0.1 update is strictly speaking backward-incompatible with 3.0.0. Version 3.0.0 changed the previous behavior of the &lt;code&gt;.each&lt;/code&gt; method and made it work more same as the new &lt;code&gt;.mapSeries&lt;/code&gt; - 3.0.1 unrolls this change by reverting to the &lt;code&gt;.tap&lt;/code&gt;-like behavior found in 2.x However, this would only affect users who updated to 3.0.0 during the short time that it wasn't deprecated and started relying on the new &lt;code&gt;.each&lt;/code&gt; behavior. This seems unlikely, and therefore the major version was not changed.</source>
          <target state="translated">请注意，严格来讲3.0.1更新与3.0.0向后不兼容。版本3.0.0更改了 &lt;code&gt;.each&lt;/code&gt; 方法的先前行为，并使它的工作原理与新的 &lt;code&gt;.mapSeries&lt;/code&gt; -3.0.1通过恢复为2.x中 &lt;code&gt;.tap&lt;/code&gt; 的行为来展开此更改相同。影响在短时间内未更新为3.0.0并开始依赖新的 &lt;code&gt;.each&lt;/code&gt; 行为的用户。这似乎不太可能，因此主要版本未更改。</target>
        </trans-unit>
        <trans-unit id="11cceaa640eecb54100f4808cad7ab17b5e595d4" translate="yes" xml:space="preserve">
          <source>Note that the 3.0.1 update is strictly speaking backward-incompatible with 3.0.0. Version 3.0.0 changed the previous behavior of the &lt;code&gt;.each&lt;/code&gt; method and made it work the same as the new &lt;code&gt;.mapSeries&lt;/code&gt; - 3.0.1 unrolls this change by reverting to the &lt;code&gt;.tap&lt;/code&gt;-like behavior found in 2.x However, this would only affect users who updated to 3.0.0 during the short time that it wasn't deprecated and started relying on the new &lt;code&gt;.each&lt;/code&gt; behavior. This seems unlikely, and therefore the major version was not changed.</source>
          <target state="translated">请注意，严格来讲3.0.1更新与3.0.0向后不兼容。3.0.0版更改了 &lt;code&gt;.each&lt;/code&gt; 方法的先前行为，并使其工作与新的 &lt;code&gt;.mapSeries&lt;/code&gt; -3.0.1相同，其工作方式是恢复为在2.x中发现的 &lt;code&gt;.tap&lt;/code&gt; 的行为。但是，这只会影响在短时间内未更新为3.0.0并开始依赖新的 &lt;code&gt;.each&lt;/code&gt; 行为的用户。这似乎不太可能，因此主要版本未更改。</target>
        </trans-unit>
        <trans-unit id="ddb0ec4c290533d8d13b5512c50f3aff8444246e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;onCancel&lt;/code&gt; hook is really an optional disconnected optimization, there is no real requirement to register any cancellation hooks for cancellation to work. As such, any errors that may occur while inside the &lt;code&gt;onCancel&lt;/code&gt; callback are not caught and turned into rejections.</source>
          <target state="translated">请注意， &lt;code&gt;onCancel&lt;/code&gt; 挂钩实际上是可选的断开连接的优化，实际上并不需要注册任何取消挂钩以使取消起作用。这样，在 &lt;code&gt;onCancel&lt;/code&gt; 回调中可能发生的任何错误都不会被捕获并变为拒绝。</target>
        </trans-unit>
        <trans-unit id="1635db28b0639fbcd8af0cf2d7a5c771bbc04b90" translate="yes" xml:space="preserve">
          <source>Note that the above is an exceptional case because &lt;code&gt;fs&lt;/code&gt; is a singleton instance. Most libraries can be promisified by requiring the library's classes (constructor functions) and calling promisifyAll on the &lt;code&gt;.prototype&lt;/code&gt;. This only needs to be done once in the entire application's lifetime and after that you may use the library's methods exactly as they are documented, except by appending the &lt;code&gt;&quot;Async&quot;&lt;/code&gt;-suffix to method calls and using the promise interface instead of the callback interface.</source>
          <target state="translated">请注意，上述情况是特殊情况，因为 &lt;code&gt;fs&lt;/code&gt; 是单例实例。可以通过要求库的类（构造函数）并在.prototype上调用promisifyAll来实现大多数库的 &lt;code&gt;.prototype&lt;/code&gt; 。这只需要在整个应用程序的生命周期中执行一次，然后您可以完全按照记录的方式使用库的方法，除了在方法调用中附加 &lt;code&gt;&quot;Async&quot;&lt;/code&gt; 后缀，并使用promise接口而不是回调接口。</target>
        </trans-unit>
        <trans-unit id="684fbd25281e8e786735f4d9605ff396ce6c04e1" translate="yes" xml:space="preserve">
          <source>Note that the original methods on the object are not overwritten but new methods are created with the &lt;code&gt;Async&lt;/code&gt;-suffix. For example, if you &lt;code&gt;promisifyAll&lt;/code&gt; the node.js &lt;code&gt;fs&lt;/code&gt; object use &lt;code&gt;fs.statAsync&lt;/code&gt; to call the promisified &lt;code&gt;stat&lt;/code&gt; method.</source>
          <target state="translated">请注意，在对象上原来的方法不会被覆盖，但与创建新方法 &lt;code&gt;Async&lt;/code&gt; -suffix。例如，如果 &lt;code&gt;promisifyAll&lt;/code&gt; 所有node.js &lt;code&gt;fs&lt;/code&gt; 对象，请使用 &lt;code&gt;fs.statAsync&lt;/code&gt; 调用承诺的 &lt;code&gt;stat&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="8918cb785368659b0f7041103fcbbc46ea52e50b" translate="yes" xml:space="preserve">
          <source>Note that you can mix promises and disposers, so that you can acquire all the things you need in parallel instead of sequentially</source>
          <target state="translated">需要注意的是,你可以将承诺和处置器混合使用,这样你就可以并行而不是依次获得所有你需要的东西了</target>
        </trans-unit>
        <trans-unit id="2203e249f5db0b7bf8e8cc90b06047ef5edc44d9" translate="yes" xml:space="preserve">
          <source>Note the new method is suffixed with &lt;code&gt;Async&lt;/code&gt;, as in &lt;code&gt;fs.readFileAsync&lt;/code&gt;. It did not replace the &lt;code&gt;fs.readFile&lt;/code&gt; function. Single functions can also be promisified for example:</source>
          <target state="translated">请注意，新方法在 &lt;code&gt;fs.readFileAsync&lt;/code&gt; 中带有 &lt;code&gt;Async&lt;/code&gt; 后缀。它没有取代 &lt;code&gt;fs.readFile&lt;/code&gt; 函数。单个功能也可以实现，例如：</target>
        </trans-unit>
        <trans-unit id="c1642a8259cf0bac4672e4af1533d8b457f9d5a0" translate="yes" xml:space="preserve">
          <source>Notice that use of &lt;code&gt;return this;&lt;/code&gt; in most of the functions? That pattern will allow method chaining as you'll see shortly.</source>
          <target state="translated">注意使用 &lt;code&gt;return this;&lt;/code&gt; 在大多数功能中？如您不久将看到的那样，该模式将允许方法链接。</target>
        </trans-unit>
        <trans-unit id="28b7a468a3970ae2784b6d1486ec7ed0a21533b5" translate="yes" xml:space="preserve">
          <source>Now if someone uses this function, they will catch all errors in their Promise &lt;code&gt;.catch&lt;/code&gt; handlers instead of having to handle both synchronous and asynchronous exception flows.</source>
          <target state="translated">现在，如果有人使用此功能，他们将在Promise &lt;code&gt;.catch&lt;/code&gt; 处理程序中捕获所有错误，而不必同时处理同步和异步异常流。</target>
        </trans-unit>
        <trans-unit id="ae7be4be424720d6a240c42d8e70d90f0de37f8e" translate="yes" xml:space="preserve">
          <source>Now the animation is hidden but, unless it throws an exception, the function has no effect on the fulfilled or rejected value of the returned promise. This is similar to how the synchronous &lt;code&gt;finally&lt;/code&gt; keyword behaves.</source>
          <target state="translated">现在，动画已隐藏，但是，除非引发异常，否则该函数对返回的诺言的已实现或已拒绝值没有影响。这类似于sync的 &lt;code&gt;finally&lt;/code&gt; 关键字的行为。</target>
        </trans-unit>
        <trans-unit id="fdea957426d725edc153e2fdbdd6516cd7a9e40a" translate="yes" xml:space="preserve">
          <source>Now to the fun part. For this tutorial we will &lt;em&gt;fake&lt;/em&gt; a lengthy file upload by using &lt;code&gt;setTimeout&lt;/code&gt;. The intent is to provide a promise and to allow a progress to be periodically ticked away. We will expect a function to be passed which is called whenever the progress needs updating. And it returns a promise.</source>
          <target state="translated">现在到有趣的部分。在本教程中，我们将使用 &lt;code&gt;setTimeout&lt;/code&gt; &lt;em&gt;伪造&lt;/em&gt;一个冗长的文件上传。目的是提供承诺并允许进度被定期剔除。我们希望传递一个需要在进度需要更新时调用的函数。它返回了一个承诺。</target>
        </trans-unit>
        <trans-unit id="f511b5b4eefa1fbd39717d9bca91d08c89eb55c8" translate="yes" xml:space="preserve">
          <source>Now we can add a &lt;code&gt;cancel()&lt;/code&gt; reject with this in our event listener:</source>
          <target state="translated">现在我们可以在事件监听器中添加一个 &lt;code&gt;cancel()&lt;/code&gt; 拒绝：</target>
        </trans-unit>
        <trans-unit id="dd58dca3cb5c00590780331e30aa954b4d6ecb97" translate="yes" xml:space="preserve">
          <source>Now when the user presses the &lt;strong&gt;Set Name&lt;/strong&gt; button the clock continues to update while the dialog is visible.</source>
          <target state="translated">现在，当用户按下&amp;ldquo; &lt;strong&gt;设置名称&amp;rdquo;&lt;/strong&gt;按钮时，在对话框可见时时钟将继续更新。</target>
        </trans-unit>
        <trans-unit id="c1c4edbd07c221b59e680f6880827ab56a3c246a" translate="yes" xml:space="preserve">
          <source>Now, because there is no catch-all handler, if you typed &lt;code&gt;console.lag&lt;/code&gt; (causes an error you don't expect), you will see:</source>
          <target state="translated">现在，因为没有万能的处理程序，所以如果您键入 &lt;code&gt;console.lag&lt;/code&gt; （导致您不希望出现的错误），您将看到：</target>
        </trans-unit>
        <trans-unit id="9cf4af30df052d80876381f9ec0e05811ecd3d08" translate="yes" xml:space="preserve">
          <source>Objective-C</source>
          <target state="translated">Objective-C</target>
        </trans-unit>
        <trans-unit id="d1d56bab874d88dafd718a2b7e212040a9f0e45f" translate="yes" xml:space="preserve">
          <source>Of course you could use hacks like monkey patching or domains but these break down when something can't be monkey patched or new apis are introduced.</source>
          <target state="translated">当然,你可以使用猴子补丁或域名等黑客,但当一些东西不能被猴子补丁或引入新的apis时,这些就会崩溃。</target>
        </trans-unit>
        <trans-unit id="f9466283542f875b75d8d6a69434fd428fb07f65" translate="yes" xml:space="preserve">
          <source>Often browser APIs are nonstandard and automatic promisification will fail for them. If you're running into an API that you can't promisify with &lt;a href=&quot;api/promisify&quot;&gt;&lt;code&gt;promisify&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;api/promisifyall&quot;&gt;&lt;code&gt;promisifyAll&lt;/code&gt;&lt;/a&gt; - please consult the &lt;a href=&quot;#working-with-any-other-apis&quot;&gt;working with other APIs section&lt;/a&gt;</source>
          <target state="translated">浏览器API通常是非标准的，因此自动进行Promisification会失败。如果您遇到的API不能通过&lt;a href=&quot;api/promisify&quot;&gt; &lt;code&gt;promisify&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;api/promisifyall&quot;&gt; &lt;code&gt;promisifyAll&lt;/code&gt; 进行promisify-&lt;/a&gt;请参阅&lt;a href=&quot;#working-with-any-other-apis&quot;&gt;使用其他API部分&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09c49c4361b267a50eb7359cfbbb3c119709f70d" translate="yes" xml:space="preserve">
          <source>Often it is known in certain code paths that a promise is guaranteed to be fulfilled at that point - it would then be extremely inconvenient to use &lt;a href=&quot;api/then&quot;&gt;&lt;code&gt;.then&lt;/code&gt;&lt;/a&gt; to get at the promise's value as the callback is always called asynchronously.</source>
          <target state="translated">通常在某些代码路径中都知道可以保证在那一点上实现承诺-然后使用&lt;a href=&quot;api/then&quot;&gt; &lt;code&gt;.then&lt;/code&gt; &lt;/a&gt;来获得承诺的值非常不便，因为回调总是被异步调用。</target>
        </trans-unit>
        <trans-unit id="ba70c55cb182e14f7aec5abbfd219d10161351d3" translate="yes" xml:space="preserve">
          <source>Often it is known in certain code paths that a promise is guaranteed to be fulfilled at that point - it would then be extremely inconvenient to use &lt;a href=&quot;then&quot;&gt;&lt;code&gt;.then&lt;/code&gt;&lt;/a&gt; to get at the promise's value as the callback is always called asynchronously.</source>
          <target state="translated">通常在某些代码路径中都知道可以保证在那一点上实现承诺-然后使用&lt;a href=&quot;then&quot;&gt; &lt;code&gt;.then&lt;/code&gt; &lt;/a&gt;来获得承诺的值非常不便，因为回调总是被异步调用。</target>
        </trans-unit>
        <trans-unit id="fb455bed4997b8d29dbd05a23ac828990139aad3" translate="yes" xml:space="preserve">
          <source>Old Promise Cancellation</source>
          <target state="translated">取消旧承诺</target>
        </trans-unit>
        <trans-unit id="c2882dbf534ae9b61f7574e530dc35a635e26a00" translate="yes" xml:space="preserve">
          <source>On client side, long stack traces currently only work in recent Firefoxes, Chrome and Internet Explorer 10+.</source>
          <target state="translated">在客户端,长栈痕迹目前只在最近的Firefox、Chrome和Internet Explorer 10+中工作。</target>
        </trans-unit>
        <trans-unit id="4e5a14a36dfaaeaed4f8ef85cfc8efef0579501d" translate="yes" xml:space="preserve">
          <source>One could solve this by either reading the file first or connecting first, and only proceeding if the first step succeeds. However, this would lose a lot of the benefits of using asynchronity and we might almost as well go back to using simple synchronous code.</source>
          <target state="translated">我们可以通过先读取文件或者先连接,只有第一步成功了才会继续。然而,这将失去很多使用异步的好处,我们几乎可以回到使用简单的同步代码。</target>
        </trans-unit>
        <trans-unit id="6d2c6e796751446bf03d009641c4f94308285962" translate="yes" xml:space="preserve">
          <source>One possible cause is using &lt;code&gt;.indexOf&lt;/code&gt; which returns &lt;code&gt;-1&lt;/code&gt; when it doesn't find the value being searched for.</source>
          <target state="translated">一种可能的原因是使用 &lt;code&gt;.indexOf&lt;/code&gt; ，当它找不到要搜索的值时将返回 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bebf09d62dbf5ff3d0ee7b594d24983d9fecce2" translate="yes" xml:space="preserve">
          <source>OperationalError</source>
          <target state="translated">OperationalError</target>
        </trans-unit>
        <trans-unit id="5b01979a9cdca6e73817895c6a9c23e60230c14d" translate="yes" xml:space="preserve">
          <source>OperationalError()</source>
          <target state="translated">OperationalError()</target>
        </trans-unit>
        <trans-unit id="104370c5891b8b4ba98b88fdedf6b3dd37566a91" translate="yes" xml:space="preserve">
          <source>Option: filter</source>
          <target state="translated">选项:过滤器</target>
        </trans-unit>
        <trans-unit id="fd4d82f7dc12888a6113e02d99a1cd1ae6480faa" translate="yes" xml:space="preserve">
          <source>Option: multiArgs</source>
          <target state="translated">选项:multiArgs</target>
        </trans-unit>
        <trans-unit id="c7fb7b92da5e81c452b72cf73b9e7e606a4be8c6" translate="yes" xml:space="preserve">
          <source>Option: promisifier</source>
          <target state="translated">备选办法:许诺人</target>
        </trans-unit>
        <trans-unit id="739bd13df9b75cbacc926456c2659db41a7a2e16" translate="yes" xml:space="preserve">
          <source>Option: spread</source>
          <target state="translated">备选方案:传播</target>
        </trans-unit>
        <trans-unit id="c86f01917e960f8cf0838c6de23ce3408a649b20" translate="yes" xml:space="preserve">
          <source>Option: suffix</source>
          <target state="translated">选项:后缀</target>
        </trans-unit>
        <trans-unit id="ad34d2a8ce003a253f94ae6e4eb935a9468f0f43" translate="yes" xml:space="preserve">
          <source>Optionally, you can define a custom filter through the options object:</source>
          <target state="translated">您也可以通过选项对象定义一个自定义过滤器。</target>
        </trans-unit>
        <trans-unit id="8110acd1b3d0f8ca4e9e279edf4604f42dc6b48b" translate="yes" xml:space="preserve">
          <source>Optionally, you can define a custom promisifier, so you could promisifyAll e.g. the chrome APIs used in Chrome extensions.</source>
          <target state="translated">你也可以定义一个自定义的许诺器,这样你就可以许诺所有,比如Chrome扩展中使用的chrome API。</target>
        </trans-unit>
        <trans-unit id="889a0e5ec1b3411c0cd35c6e73319943162df789" translate="yes" xml:space="preserve">
          <source>Optionally, you can define a custom suffix through the options object:</source>
          <target state="translated">您也可以通过选项对象定义一个自定义后缀。</target>
        </trans-unit>
        <trans-unit id="d850b7adaa397dfa33c1141f5bb572b4b4cee8d2" translate="yes" xml:space="preserve">
          <source>Or to use &lt;a href=&quot;api/promise.coroutine.addyieldhandler&quot;&gt;&lt;code&gt;Promise.coroutine.addYieldHandler`&lt;/code&gt;&lt;/a&gt; to teach &lt;a href=&quot;api/promise.coroutine&quot;&gt;&lt;code&gt;Promise.coroutine&lt;/code&gt;&lt;/a&gt; to accept these sort of values.</source>
          <target state="translated">或使用&lt;a href=&quot;api/promise.coroutine.addyieldhandler&quot;&gt; &lt;code&gt;Promise.coroutine.addYieldHandler`&lt;/code&gt; &lt;/a&gt;来教&lt;a href=&quot;api/promise.coroutine&quot;&gt; &lt;code&gt;Promise.coroutine&lt;/code&gt; &lt;/a&gt;接受此类值。</target>
        </trans-unit>
        <trans-unit id="24ea190190a1068b342fd38d88b87afd5b7878ff" translate="yes" xml:space="preserve">
          <source>Or you could take advantage of the fact that if we reach password validation, then the user promise must be fulfilled:</source>
          <target state="translated">或者你也可以利用,如果我们达到密码验证,那么用户的承诺就必须实现。</target>
        </trans-unit>
        <trans-unit id="0b17d6ff961144643224165079cbd11a9c6bc25a" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;PromptDialog&lt;/code&gt; class is responsible for inheriting from &lt;code&gt;Dialog&lt;/code&gt; and setting up the required DOM scaffolding and eventually call &lt;code&gt;this._okCallback&lt;/code&gt; or &lt;code&gt;this._cancelCallback&lt;/code&gt; as appropriate.</source>
          <target state="translated">我们的 &lt;code&gt;PromptDialog&lt;/code&gt; 类负责从 &lt;code&gt;Dialog&lt;/code&gt; 继承并设置所需的DOM支架，并最终根据需要调用 &lt;code&gt;this._okCallback&lt;/code&gt; 或 &lt;code&gt;this._cancelCallback&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57cb5629649d7407a80d8544726571004c96c657" translate="yes" xml:space="preserve">
          <source>PascalCase the suffix</source>
          <target state="translated">PascalCase后缀</target>
        </trans-unit>
        <trans-unit id="feee47953c269413e18b8e3f8b2d28f42be54e4a" translate="yes" xml:space="preserve">
          <source>Pass a handler that will be called regardless of this promise's fate. Returns a new promise chained from this promise. There are special semantics for &lt;a href=&quot;finally&quot;&gt;&lt;code&gt;.finally&lt;/code&gt;&lt;/a&gt; in that the final value cannot be modified from the handler.</source>
          <target state="translated">传递一个处理程序，无论此承诺的命运如何，该处理程序都会被调用。返回与此承诺链接的新承诺。&lt;a href=&quot;finally&quot;&gt; &lt;code&gt;.finally&lt;/code&gt; &lt;/a&gt;有特殊的语义，因为不能从处理程序中修改最终值。</target>
        </trans-unit>
        <trans-unit id="9b4b02b67bed0ffe4b0b1b17a183e58f6d178ecc" translate="yes" xml:space="preserve">
          <source>Pass it a constructor that inherits from &lt;code&gt;Error&lt;/code&gt;:</source>
          <target state="translated">将继承自 &lt;code&gt;Error&lt;/code&gt; 的构造函数传递给它：</target>
        </trans-unit>
        <trans-unit id="ef62afb0d13c7501004b9f7402ac0fe34f1df36d" translate="yes" xml:space="preserve">
          <source>Passing no value or a non-function will have the effect of removing any kind of handling for possibly unhandled rejections.</source>
          <target state="translated">传递无值或非函数会对可能未处理的拒绝进行任何形式的处理。</target>
        </trans-unit>
        <trans-unit id="14a1550a1e49d7c4df7b61809151dec155b9464f" translate="yes" xml:space="preserve">
          <source>Performance improvements when long stack traces are enabled</source>
          <target state="translated">启用长堆栈跟踪时的性能改进</target>
        </trans-unit>
        <trans-unit id="f6d83e264c56100a2c68d859c185e245cdf12d6c" translate="yes" xml:space="preserve">
          <source>Perhaps the greatest thing about promises is that it unifies all error handling into one mechanism where errors propagate automatically and have to be explicitly ignored.</source>
          <target state="translated">也许诺言最伟大的地方在于,它将所有的错误处理统一到一个机制中,错误会自动传播,必须明确忽略。</target>
        </trans-unit>
        <trans-unit id="13bc9fc907ba93237d886bb7661f405dca851032" translate="yes" xml:space="preserve">
          <source>Playing with the first example with and without limits, and seeing how it affects the duration when reading 20 files:</source>
          <target state="translated">玩第一个例子有限制和无限制,看看它对读取20个文件时的持续时间有什么影响。</target>
        </trans-unit>
        <trans-unit id="5e982889494e481131cdc4a0b26924bfa22d7d53" translate="yes" xml:space="preserve">
          <source>Please consider reading about &lt;a href=&quot;api/new-promise&quot;&gt;&lt;code&gt;new Promise&lt;/code&gt;&lt;/a&gt; and also consider checking out automatic &lt;a href=&quot;api/promisification&quot;&gt;&lt;code&gt;promisification&lt;/code&gt;&lt;/a&gt; as well as &lt;a href=&quot;api/promise.method&quot;&gt;&lt;code&gt;Promise.method&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">请考虑阅读有关&lt;a href=&quot;api/new-promise&quot;&gt; &lt;code&gt;new Promise&lt;/code&gt; &lt;/a&gt;，并考虑检查自动&lt;a href=&quot;api/promisification&quot;&gt; &lt;code&gt;promisification&lt;/code&gt; &lt;/a&gt;以及&lt;a href=&quot;api/promise.method&quot;&gt; &lt;code&gt;Promise.method&lt;/code&gt; 。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3b51c4c13d41d7852eb369e20c236af48cef84cc" translate="yes" xml:space="preserve">
          <source>Please consider reading more about &lt;a href=&quot;api/synchronous-inspection&quot;&gt;&lt;code&gt;synchronous inspection&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">请考虑阅读更多有关&lt;a href=&quot;api/synchronous-inspection&quot;&gt; &lt;code&gt;synchronous inspection&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1e14f1308fe5c8dea2b2ef541f7aee826d27d5e0" translate="yes" xml:space="preserve">
          <source>Please consider reading the API docs for &lt;a href=&quot;api/some&quot;&gt;&lt;code&gt;.some&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">请考虑阅读&lt;a href=&quot;api/some&quot;&gt; &lt;code&gt;.some&lt;/code&gt; &lt;/a&gt;的API文档</target>
        </trans-unit>
        <trans-unit id="c5ef6b96fc3e88fc35fff339fde30327dde1a698" translate="yes" xml:space="preserve">
          <source>Please refer to the relevant section in the documentation about &lt;a href=&quot;api/generators&quot;&gt;&lt;code&gt;Generators&lt;/code&gt;&lt;/a&gt; in order to get usage instructions:</source>
          <target state="translated">请参阅有关&lt;a href=&quot;api/generators&quot;&gt; &lt;code&gt;Generators&lt;/code&gt; &lt;/a&gt;的文档中的相关部分，以获取使用说明：</target>
        </trans-unit>
        <trans-unit id="5ad1bb14fb0bdc68c8977349fd048e917d0e042c" translate="yes" xml:space="preserve">
          <source>Please see the API docs of &lt;a href=&quot;api/catch&quot;&gt;&lt;code&gt;.catch()&lt;/code&gt;&lt;/a&gt; on how to use predicate catches.</source>
          <target state="translated">请参阅&lt;a href=&quot;api/catch&quot;&gt; &lt;code&gt;.catch()&lt;/code&gt; &lt;/a&gt;的API文档，以了解如何使用谓语捕获。</target>
        </trans-unit>
        <trans-unit id="7c7ed98d6ff8cb1bb3beee177d5536fda218b9d6" translate="yes" xml:space="preserve">
          <source>Possibly unhandled rejection handler will always get a stack trace, even if the rejection or thrown error was not an error</source>
          <target state="translated">可能未处理的拒绝处理程序总是会得到一个堆栈跟踪,即使拒绝或抛出的错误不是错误。</target>
        </trans-unit>
        <trans-unit id="24fd6c2d1150de6a47543209150ff4c2a2d3104f" translate="yes" xml:space="preserve">
          <source>PostgreSQL</source>
          <target state="translated">PostgreSQL</target>
        </trans-unit>
        <trans-unit id="642cccd7308199d6f0935637f8e1d6bddc7a7f5d" translate="yes" xml:space="preserve">
          <source>Predicate functions that only check properties have a handy shorthand. In place of a predicate function, you can pass an object, and its properties will be checked against the error object for a match:</source>
          <target state="translated">只检查属性的谓词函数有一个方便的速记。你可以通过一个对象来代替一个谓词函数,它的属性将与错误对象进行匹配检查。</target>
        </trans-unit>
        <trans-unit id="ef29f5e7937f710796c69d5f2e8ef62b93259503" translate="yes" xml:space="preserve">
          <source>Predicates should allow for very fine grained control over caught errors: pattern matching, error-type sets with set operations and many other techniques can be implemented on top of them.</source>
          <target state="translated">谓词应该允许对捕捉到的错误进行非常精细的控制:模式匹配、带有集合操作的错误类型集以及许多其他技术都可以在它们之上实现。</target>
        </trans-unit>
        <trans-unit id="966e683ff73ac6a6ff53e83d6497f2f1ad6da22d" translate="yes" xml:space="preserve">
          <source>Preserve bound-with-promise promises across the entire chain (&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/702&quot;&gt;&lt;code&gt;#702&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">在整个链中保留承诺承诺（&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/702&quot;&gt; &lt;code&gt;#702&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b1d7cb674f49e0b746c342035d00a2302db4c737" translate="yes" xml:space="preserve">
          <source>Progress bar</source>
          <target state="translated">进度条</target>
        </trans-unit>
        <trans-unit id="51674123623b6ab6e8ea7ca7250debfd7286bf63" translate="yes" xml:space="preserve">
          <source>Progress the underlying promise with &lt;code&gt;value&lt;/code&gt; as the progression value.</source>
          <target state="translated">以 &lt;code&gt;value&lt;/code&gt; 作为进步价值来实现潜在的承诺。</target>
        </trans-unit>
        <trans-unit id="685e262241d88a216ab9353d6e8f0939b5803641" translate="yes" xml:space="preserve">
          <source>Progression</source>
          <target state="translated">Progression</target>
        </trans-unit>
        <trans-unit id="25eee37f31e0eba9807d8e531ecf239e4d0cd542" translate="yes" xml:space="preserve">
          <source>Progression has been removed as there are composability and chaining issues with APIs that use promise progression handlers. Implementing the common use case of progress bars can be accomplished using a pattern similar to &lt;a href=&quot;http://blogs.msdn.com/b/dotnet/archive/2012/06/06/async-in-4-5-enabling-progress-and-cancellation-in-async-apis.aspx&quot;&gt;IProgress&lt;/a&gt; in C#.</source>
          <target state="translated">进度已被删除，因为使用承诺进度处理程序的API存在可组合性和链接问题。可以使用类似于C＃中的&lt;a href=&quot;http://blogs.msdn.com/b/dotnet/archive/2012/06/06/async-in-4-5-enabling-progress-and-cancellation-in-async-apis.aspx&quot;&gt;IProgress&lt;/a&gt;的模式来实现进度条的常见用例。</target>
        </trans-unit>
        <trans-unit id="3248b463906e068e9fcc220b46e1a5d372a78fb1" translate="yes" xml:space="preserve">
          <source>Progression migration</source>
          <target state="translated">渐进式迁移</target>
        </trans-unit>
        <trans-unit id="be45959fa7407eeadb36fe64732e21bc44a21868" translate="yes" xml:space="preserve">
          <source>Promise config returns reference to Bluebird library</source>
          <target state="translated">诺言配置返回对Bluebird库的引用。</target>
        </trans-unit>
        <trans-unit id="fb6113ea309f0d5b9bec49fc1796cd040f492643" translate="yes" xml:space="preserve">
          <source>Promise exception handling mirrors native exception handling in JavaScript. A synchronous function &lt;code&gt;throw&lt;/code&gt;ing is similar to a promise rejecting. Here is an example to illustrate it:</source>
          <target state="translated">承诺异常处理反映了JavaScript中的本机异常处理。同步函数 &lt;code&gt;throw&lt;/code&gt; 类似于承诺拒绝。这是一个示例说明：</target>
        </trans-unit>
        <trans-unit id="8782a387409c7a9a87576a85d07c1e64505c1544" translate="yes" xml:space="preserve">
          <source>Promise monitoring</source>
          <target state="translated">承诺监测</target>
        </trans-unit>
        <trans-unit id="4dbc67ef437634d86ab184513509ef1b7aec9846" translate="yes" xml:space="preserve">
          <source>Promise nuggets</source>
          <target state="translated">承诺金块</target>
        </trans-unit>
        <trans-unit id="cd4139a3b1a43d871cf4ddb3e7a6d5193448c48c" translate="yes" xml:space="preserve">
          <source>Promise progression has been completely removed.</source>
          <target state="translated">答应的进展已被完全删除。</target>
        </trans-unit>
        <trans-unit id="7726aabf1843e710a9f37fd6b562d6f56faa7e88" translate="yes" xml:space="preserve">
          <source>Promise resolution</source>
          <target state="translated">答应解决</target>
        </trans-unit>
        <trans-unit id="65f81fcc4877a1e4dd84dd9b0c2863d1631025a9" translate="yes" xml:space="preserve">
          <source>Promise returning functions &lt;em&gt;should never throw&lt;/em&gt;, they should always successfully return a promise which is rejected in the case of an error. Throwing from a promise returning function will force you to use both a &lt;code&gt;} catch {&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; a &lt;code&gt;.catch&lt;/code&gt;. People using promisified APIs do not expect promises to throw. If you're not sure how async APIs work in JS - please &lt;a href=&quot;http://stackoverflow.com/questions/14220321/how-to-return-the-response-from-an-asynchronous-call/16825593#16825593&quot;&gt;see this answer&lt;/a&gt; first.</source>
          <target state="translated">承诺返回函数&lt;em&gt;绝不能抛出&lt;/em&gt;，它们应该总是成功返回一个promise，该promise在发生错误时会被拒绝。从承诺返回函数投掷将迫使你同时使用 &lt;code&gt;} catch {&lt;/code&gt; &lt;em&gt;和&lt;/em&gt;一个 &lt;code&gt;.catch&lt;/code&gt; 。使用承诺的API的人们不会期望诺言。如果您不确定JS中异步API的工作方式-请首先&lt;a href=&quot;http://stackoverflow.com/questions/14220321/how-to-return-the-response-from-an-asynchronous-call/16825593#16825593&quot;&gt;查看此答案&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="32c88e7c01a53d5b288b9de6a6aab20cb547871d" translate="yes" xml:space="preserve">
          <source>Promise.all</source>
          <target state="translated">Promise.all</target>
        </trans-unit>
        <trans-unit id="a6755a6ad2728b869d475dc11ace6f3bf5ea4871" translate="yes" xml:space="preserve">
          <source>Promise.all()</source>
          <target state="translated">Promise.all()</target>
        </trans-unit>
        <trans-unit id="8a9f46eacb22a3bbe6409bdb49b4254651eff678" translate="yes" xml:space="preserve">
          <source>Promise.any</source>
          <target state="translated">Promise.any</target>
        </trans-unit>
        <trans-unit id="59a3e9eecb28443ad28e7c96175567acc96c62f3" translate="yes" xml:space="preserve">
          <source>Promise.any()</source>
          <target state="translated">Promise.any()</target>
        </trans-unit>
        <trans-unit id="380ddbb670a463da41bcb2f09102155dde8e708e" translate="yes" xml:space="preserve">
          <source>Promise.bind</source>
          <target state="translated">Promise.bind</target>
        </trans-unit>
        <trans-unit id="c504dbf7b03cd885ada0adc0180bde1c542f6ff6" translate="yes" xml:space="preserve">
          <source>Promise.bind()</source>
          <target state="translated">Promise.bind()</target>
        </trans-unit>
        <trans-unit id="94cffff23a1082b260d53b460f0199319830c332" translate="yes" xml:space="preserve">
          <source>Promise.config</source>
          <target state="translated">Promise.config</target>
        </trans-unit>
        <trans-unit id="14cca1b3fd91fce3c7d78898b9b8ab87641cd45f" translate="yes" xml:space="preserve">
          <source>Promise.config()</source>
          <target state="translated">Promise.config()</target>
        </trans-unit>
        <trans-unit id="0281c083d21b56d693df7c85bdc8760d5a153cb3" translate="yes" xml:space="preserve">
          <source>Promise.coroutine</source>
          <target state="translated">Promise.coroutine</target>
        </trans-unit>
        <trans-unit id="417c8a52e78b52649cc8c0d1a4a5c72e470fba46" translate="yes" xml:space="preserve">
          <source>Promise.coroutine()</source>
          <target state="translated">Promise.coroutine()</target>
        </trans-unit>
        <trans-unit id="1c7ffab7487989ed4fab5bf27ffc68d6a9e83f84" translate="yes" xml:space="preserve">
          <source>Promise.coroutine.addYieldHandler</source>
          <target state="translated">Promise.coroutine.addYieldHandler</target>
        </trans-unit>
        <trans-unit id="b32e1c4e626c99ffd6f0e20eaa5f3f6e5768bfd5" translate="yes" xml:space="preserve">
          <source>Promise.coroutine.addYieldHandler()</source>
          <target state="translated">Promise.coroutine.addYieldHandler()</target>
        </trans-unit>
        <trans-unit id="0eaf3c7722c589dfef45cece747a91a4f63eb1c4" translate="yes" xml:space="preserve">
          <source>Promise.delay</source>
          <target state="translated">Promise.delay</target>
        </trans-unit>
        <trans-unit id="b0fcfeaf123206f651b32c45d020a06c0161b597" translate="yes" xml:space="preserve">
          <source>Promise.delay()</source>
          <target state="translated">Promise.delay()</target>
        </trans-unit>
        <trans-unit id="58c05c22c80b95286ff97a890b8a711ca2bc4455" translate="yes" xml:space="preserve">
          <source>Promise.each</source>
          <target state="translated">Promise.each</target>
        </trans-unit>
        <trans-unit id="a620ec9f632f36f8a08e631069c08191868f6916" translate="yes" xml:space="preserve">
          <source>Promise.each()</source>
          <target state="translated">Promise.each()</target>
        </trans-unit>
        <trans-unit id="36ed6ee5c85807e4301bf69d782f38ceb4470326" translate="yes" xml:space="preserve">
          <source>Promise.filter</source>
          <target state="translated">Promise.filter</target>
        </trans-unit>
        <trans-unit id="86054f183176a3f69e770d2c34d2bdeae915a41e" translate="yes" xml:space="preserve">
          <source>Promise.filter()</source>
          <target state="translated">Promise.filter()</target>
        </trans-unit>
        <trans-unit id="98d41166fbaafb718942a7d54eb7a52ea584c71b" translate="yes" xml:space="preserve">
          <source>Promise.fromCallback</source>
          <target state="translated">Promise.fromCallback</target>
        </trans-unit>
        <trans-unit id="3f0b67925c3695da1eb2886d38a30665c003a3b1" translate="yes" xml:space="preserve">
          <source>Promise.fromCallback()</source>
          <target state="translated">Promise.fromCallback()</target>
        </trans-unit>
        <trans-unit id="fd3f3e356627367a0a1deb529a31724afae6adf2" translate="yes" xml:space="preserve">
          <source>Promise.getNewLibraryCopy</source>
          <target state="translated">Promise.getNewLibraryCopy</target>
        </trans-unit>
        <trans-unit id="89fb5dda745c6bafe6968a6f413760af47aceae1" translate="yes" xml:space="preserve">
          <source>Promise.getNewLibraryCopy()</source>
          <target state="translated">Promise.getNewLibraryCopy()</target>
        </trans-unit>
        <trans-unit id="40fdb4632aedb0a1797f0c8a54579a1fde171242" translate="yes" xml:space="preserve">
          <source>Promise.join</source>
          <target state="translated">Promise.join</target>
        </trans-unit>
        <trans-unit id="23d8f43c5ac526250cf76c302ad4119a7b1ab47b" translate="yes" xml:space="preserve">
          <source>Promise.join()</source>
          <target state="translated">Promise.join()</target>
        </trans-unit>
        <trans-unit id="7978c060e1559749beb237c1e2cd848a0c8c4d0d" translate="yes" xml:space="preserve">
          <source>Promise.map</source>
          <target state="translated">Promise.map</target>
        </trans-unit>
        <trans-unit id="ca13a4d72f15f0ca07d5d50979466ec8d5754e56" translate="yes" xml:space="preserve">
          <source>Promise.map()</source>
          <target state="translated">Promise.map()</target>
        </trans-unit>
        <trans-unit id="4228fbfb6f0c4ca7c03f7f3fe02a32213a675bb6" translate="yes" xml:space="preserve">
          <source>Promise.mapSeries</source>
          <target state="translated">Promise.mapSeries</target>
        </trans-unit>
        <trans-unit id="e726d78ebf8fa9e8d4dd4170765a788187160409" translate="yes" xml:space="preserve">
          <source>Promise.mapSeries()</source>
          <target state="translated">Promise.mapSeries()</target>
        </trans-unit>
        <trans-unit id="02c686952be30df3ceda356456842c51ca54d6b6" translate="yes" xml:space="preserve">
          <source>Promise.method</source>
          <target state="translated">Promise.method</target>
        </trans-unit>
        <trans-unit id="745df198c177406843ab6f0aef1a0ee5dfc83def" translate="yes" xml:space="preserve">
          <source>Promise.method()</source>
          <target state="translated">Promise.method()</target>
        </trans-unit>
        <trans-unit id="84f80dd435e5e59f09d00da45ff238df86a37a40" translate="yes" xml:space="preserve">
          <source>Promise.noConflict</source>
          <target state="translated">Promise.noConflict</target>
        </trans-unit>
        <trans-unit id="7531a2c2c6b7c98ad21e08d5e3ae1c19a0b22683" translate="yes" xml:space="preserve">
          <source>Promise.noConflict()</source>
          <target state="translated">Promise.noConflict()</target>
        </trans-unit>
        <trans-unit id="71c980a14f65b0a2704a085acb674ac28a814685" translate="yes" xml:space="preserve">
          <source>Promise.onPossiblyUnhandledRejection</source>
          <target state="translated">Promise.onPossiblyUnhandledRejection</target>
        </trans-unit>
        <trans-unit id="c371d88740f13aaaca5694582d4b3f1c2be33ab4" translate="yes" xml:space="preserve">
          <source>Promise.onPossiblyUnhandledRejection()</source>
          <target state="translated">Promise.onPossiblyUnhandledRejection()</target>
        </trans-unit>
        <trans-unit id="829674402143cb4c85191f62c464c46f218abca2" translate="yes" xml:space="preserve">
          <source>Promise.onUnhandledRejectionHandled</source>
          <target state="translated">Promise.onUnhandledRejectionHandled</target>
        </trans-unit>
        <trans-unit id="9c2cbfa68db14a1011a8bf225d1d930825635838" translate="yes" xml:space="preserve">
          <source>Promise.onUnhandledRejectionHandled()</source>
          <target state="translated">Promise.onUnhandledRejectionHandled()</target>
        </trans-unit>
        <trans-unit id="1bd4c78395725232fde1b79374d6efc9908e559c" translate="yes" xml:space="preserve">
          <source>Promise.promisify</source>
          <target state="translated">Promise.promisify</target>
        </trans-unit>
        <trans-unit id="1713f0d05877ab5fe29b2ac17f3c75196afacdff" translate="yes" xml:space="preserve">
          <source>Promise.promisify()</source>
          <target state="translated">Promise.promisify()</target>
        </trans-unit>
        <trans-unit id="97bebc26a4bce522904a06ed52ef00804ef373fc" translate="yes" xml:space="preserve">
          <source>Promise.promisifyAll</source>
          <target state="translated">Promise.promisifyAll</target>
        </trans-unit>
        <trans-unit id="582205a63795dfa2ded431e29909f2b0510003b9" translate="yes" xml:space="preserve">
          <source>Promise.promisifyAll()</source>
          <target state="translated">Promise.promisifyAll()</target>
        </trans-unit>
        <trans-unit id="27847ed541d9e1eeb76f5dbeb0044fcdbf775d18" translate="yes" xml:space="preserve">
          <source>Promise.props</source>
          <target state="translated">Promise.props</target>
        </trans-unit>
        <trans-unit id="4f38df349b880a0f534b640b3a8136437dece180" translate="yes" xml:space="preserve">
          <source>Promise.props now takes a &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/f41edac61b7c421608ff439bb5a09b7cffeadcf9/test/mocha/props.js#L197-L217&quot;&gt;thenable-for-collection&lt;/a&gt;</source>
          <target state="translated">Promise.props现在需要&lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/f41edac61b7c421608ff439bb5a09b7cffeadcf9/test/mocha/props.js#L197-L217&quot;&gt;收集&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9db0fa212e5a187e62cb941c0f3eb586f29ed38d" translate="yes" xml:space="preserve">
          <source>Promise.props()</source>
          <target state="translated">Promise.props()</target>
        </trans-unit>
        <trans-unit id="6196396df0252ad4dc6749ba58e4f523ddc5109d" translate="yes" xml:space="preserve">
          <source>Promise.race</source>
          <target state="translated">Promise.race</target>
        </trans-unit>
        <trans-unit id="c805ba00efdcb8c7baa42fe61c954261ddd4c775" translate="yes" xml:space="preserve">
          <source>Promise.race()</source>
          <target state="translated">Promise.race()</target>
        </trans-unit>
        <trans-unit id="09422a77b11ac9569156f52e83edb0002c26642c" translate="yes" xml:space="preserve">
          <source>Promise.reduce</source>
          <target state="translated">Promise.reduce</target>
        </trans-unit>
        <trans-unit id="3036bc3d125176ce64d7f9e3b21c3e0d47ea6b85" translate="yes" xml:space="preserve">
          <source>Promise.reduce()</source>
          <target state="translated">Promise.reduce()</target>
        </trans-unit>
        <trans-unit id="783910d23dd1b1558a9b16d71c0ed4b397115fd3" translate="yes" xml:space="preserve">
          <source>Promise.reject</source>
          <target state="translated">Promise.reject</target>
        </trans-unit>
        <trans-unit id="8a2f2af4e6e3d7ca0c77296866bcfff0749f0dd9" translate="yes" xml:space="preserve">
          <source>Promise.reject()</source>
          <target state="translated">Promise.reject()</target>
        </trans-unit>
        <trans-unit id="0a3c75bb1d9e15c9996579992a0721a69da28c55" translate="yes" xml:space="preserve">
          <source>Promise.resolve</source>
          <target state="translated">Promise.resolve</target>
        </trans-unit>
        <trans-unit id="3cf132f388e7330298717bcc33a49e9f948aa7e5" translate="yes" xml:space="preserve">
          <source>Promise.resolve and PromiseResolver.resolve follow thenables too.</source>
          <target state="translated">Promise.resolve和PromiseResolver.resolve也是按照thenables来的。</target>
        </trans-unit>
        <trans-unit id="47b038849d964f2910c38df87756eeab2c33c845" translate="yes" xml:space="preserve">
          <source>Promise.resolve()</source>
          <target state="translated">Promise.resolve()</target>
        </trans-unit>
        <trans-unit id="2bd5fccacac7e4b32307e5e90275cc00e52adab2" translate="yes" xml:space="preserve">
          <source>Promise.setScheduler</source>
          <target state="translated">Promise.setScheduler</target>
        </trans-unit>
        <trans-unit id="4f357c9ea9b4ced021695eb3da83abef0f53a5bc" translate="yes" xml:space="preserve">
          <source>Promise.setScheduler()</source>
          <target state="translated">Promise.setScheduler()</target>
        </trans-unit>
        <trans-unit id="b2b14953357fd6fd7061ee19d3a46165592f8187" translate="yes" xml:space="preserve">
          <source>Promise.some</source>
          <target state="translated">Promise.some</target>
        </trans-unit>
        <trans-unit id="a7f83b619aac204250fe4b4b48cffc16048afd2a" translate="yes" xml:space="preserve">
          <source>Promise.some()</source>
          <target state="translated">Promise.some()</target>
        </trans-unit>
        <trans-unit id="bcaec27b9cbb2228f24361eaa259b8fadc6e76b0" translate="yes" xml:space="preserve">
          <source>Promise.try</source>
          <target state="translated">Promise.try</target>
        </trans-unit>
        <trans-unit id="285c74e7f15b5592587b905c39313a8c4c3631cd" translate="yes" xml:space="preserve">
          <source>Promise.try()</source>
          <target state="translated">Promise.try()</target>
        </trans-unit>
        <trans-unit id="54ae20ee3d30d8a4d9a8c3f51ddc74ab08078bce" translate="yes" xml:space="preserve">
          <source>Promise.using</source>
          <target state="translated">Promise.using</target>
        </trans-unit>
        <trans-unit id="d12fa97fde3870925fdf7d6a0ac552e0c8c9b94a" translate="yes" xml:space="preserve">
          <source>Promise.using()</source>
          <target state="translated">Promise.using()</target>
        </trans-unit>
        <trans-unit id="1a5d11d2f1ddb5249c87ef7bd69381bb0b693272" translate="yes" xml:space="preserve">
          <source>PromiseInspection</source>
          <target state="translated">PromiseInspection</target>
        </trans-unit>
        <trans-unit id="868dfb6858e3ed48b9b873232bb97b0244d9d0bf" translate="yes" xml:space="preserve">
          <source>Promises are a concurrency primitive with a proven track record and language integration in most modern programming languages. They have been extensively studied since the 80s and will make your life much easier.</source>
          <target state="translated">承诺是一种并发基元,在大多数现代编程语言中都有成熟的记录和语言集成。自80年代以来,它们已经得到了广泛的研究,并将使您的生活更加轻松。</target>
        </trans-unit>
        <trans-unit id="4979e5d38a5edf382533cb2038c51eb19a4dee6f" translate="yes" xml:space="preserve">
          <source>Promises are now not cancellable by default. This is backwards incompatible change - see &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#cancellable---promise&quot;&gt;&lt;code&gt;.cancellable()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">现在默认情况下无法取消承诺。这是向后不兼容的更改-请参见&lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#cancellable---promise&quot;&gt; &lt;code&gt;.cancellable()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed5dd788dfd2194a43ab6fd8c2d1b84eb1ecc96e" translate="yes" xml:space="preserve">
          <source>Promises can be rejected with falsy values (or no value at all, equal to rejecting with &lt;code&gt;undefined&lt;/code&gt;), however &lt;code&gt;.asCallback&lt;/code&gt; will call the callback with an &lt;code&gt;Error&lt;/code&gt; object if the promise's rejection reason is a falsy value. You can retrieve the original falsy value from the error's &lt;code&gt;.cause&lt;/code&gt; property.</source>
          <target state="translated">可以用虚假值拒绝承诺（或根本没有值，等于用 &lt;code&gt;undefined&lt;/code&gt; 拒绝），但是，如果承诺的拒绝原因是虚假值，则 &lt;code&gt;.asCallback&lt;/code&gt; 将使用 &lt;code&gt;Error&lt;/code&gt; 对象调用回调。您可以从错误的 &lt;code&gt;.cause&lt;/code&gt; 属性中检索原始的假值。</target>
        </trans-unit>
        <trans-unit id="51f657ce6a52627dea6e94af335b6ca122d8163b" translate="yes" xml:space="preserve">
          <source>Promises can have a steep learning curve and it doesn't help that promise standards go out of their way to make it even harder. Bluebird works around the limitations by providing warnings where the standards disallow throwing errors when incorrect usage is detected. See &lt;a href=&quot;warning-explanations&quot;&gt;Warning Explanations&lt;/a&gt; for the possible warnings that bluebird covers.</source>
          <target state="translated">承诺可能会有陡峭的学习曲线，并且承诺标准过分地加重难度也无济于事。蓝鸟通过提供警告（标准检测到错误使用时不允许抛出错误）来解决这些限制。请参阅&lt;a href=&quot;warning-explanations&quot;&gt;警告说明&lt;/a&gt;以了解bluebird可能发出的警告。</target>
        </trans-unit>
        <trans-unit id="3be96f5495c2d83069fb9e4fe84ca585a4ab5539" translate="yes" xml:space="preserve">
          <source>Promises do not aim to solve such live updating problems directly. One option would be to use an intermediate promise - for example a &lt;code&gt;.loaded&lt;/code&gt; property on the model that fulfills with nothing.</source>
          <target state="translated">承诺并非旨在直接解决此类实时更新问题。一种选择是使用中间承诺-例如，模型上的 &lt;code&gt;.loaded&lt;/code&gt; 属性一无所获。</target>
        </trans-unit>
        <trans-unit id="63104f36ddfde5f398242d3c9a325847a623a94b" translate="yes" xml:space="preserve">
          <source>Promises have state, they start as pending and can settle to:</source>
          <target state="translated">承诺有状态,开始是待定,可以结算到。</target>
        </trans-unit>
        <trans-unit id="dc07d53901ac77bfe4d99f439fd922d98f514777" translate="yes" xml:space="preserve">
          <source>Promises now clean up all references (to handlers, child promises etc) as soon as possible.</source>
          <target state="translated">承诺现在尽快清理所有引用(对处理程序、子承诺等)。</target>
        </trans-unit>
        <trans-unit id="4f7e995a45e8a7aa84e5616f32bd9b6d2f616aeb" translate="yes" xml:space="preserve">
          <source>Promises now delete references to handlers attached to them as soon as possible</source>
          <target state="translated">承诺现在会尽快删除对附加在处理程序上的引用。</target>
        </trans-unit>
        <trans-unit id="85f84a547296b83c2cd9be954bf35fa432933967" translate="yes" xml:space="preserve">
          <source>Promises perform a role similar to &lt;code&gt;IO&lt;/code&gt; in that they allow for easy chaining of asynchronous non-blocking operations. &lt;code&gt;Promise.coroutine&lt;/code&gt; can be seen as similar to &lt;code&gt;do&lt;/code&gt; notation although in practice it's not an accurate comparison.</source>
          <target state="translated">承诺执行类似于 &lt;code&gt;IO&lt;/code&gt; 的角色，因为它们允许轻松地链接异步非阻塞操作。 &lt;code&gt;Promise.coroutine&lt;/code&gt; 可以看作与 &lt;code&gt;do&lt;/code&gt; 表示法相似，尽管实际上这不是一个准确的比较。</target>
        </trans-unit>
        <trans-unit id="3e8ddebed649b44e7a85d5ae2af303397fa7ea81" translate="yes" xml:space="preserve">
          <source>Promises provide a lot of really cool and powerful guarantees like throw safety which are hard to provide when manually converting APIs to use promises. Thus, whenever it is possible to use the &lt;code&gt;Promise.promisify&lt;/code&gt; and &lt;code&gt;Promise.promisifyAll&lt;/code&gt; methods - we recommend you use them. Not only are they the safest form of conversion - they also use techniques of dynamic recompilation to introduce very little overhead.</source>
          <target state="translated">Promise提供了很多非常酷而强大的保证，例如抛出安全性，当手动将API转换为使用Promise时很难提供这些保证。因此，只要有可能使用 &lt;code&gt;Promise.promisify&lt;/code&gt; 和 &lt;code&gt;Promise.promisifyAll&lt;/code&gt; 方法-我们建议您使用它们。它们不仅是最安全的转换形式，而且还使用动态重新编译技术来引入很少的开销。</target>
        </trans-unit>
        <trans-unit id="45fe5ca98fd7d2bd4d25dbf8138ba708e64fdca4" translate="yes" xml:space="preserve">
          <source>Promises returned by the &lt;code&gt;mapper&lt;/code&gt; function are awaited for and the returned promise doesn't fulfill until all mapped promises have fulfilled as well. If any promise in the array is rejected, or any promise returned by the &lt;code&gt;mapper&lt;/code&gt; function is rejected, the returned promise is rejected as well.</source>
          <target state="translated">由返回的承诺 &lt;code&gt;mapper&lt;/code&gt; 功能正在等待并返回的承诺未履行，直到所有映射的承诺已经履行了为好。如果数组中的任何promise被拒绝，或者 &lt;code&gt;mapper&lt;/code&gt; 函数返回的任何promise 被拒绝，则返回的promise也将被拒绝。</target>
        </trans-unit>
        <trans-unit id="7e30cdf817cbb4a8901ddafd58155a4d7d146650" translate="yes" xml:space="preserve">
          <source>Promises:</source>
          <target state="translated">Promises:</target>
        </trans-unit>
        <trans-unit id="7bdd89f28407b699d8b7e554f8c4f6ce47ea6c46" translate="yes" xml:space="preserve">
          <source>Promisification</source>
          <target state="translated">Promisification</target>
        </trans-unit>
        <trans-unit id="590f705f9b259c4f0eb3b51eea47cea46ae9c547" translate="yes" xml:space="preserve">
          <source>Promisification API changes</source>
          <target state="translated">许诺API变更</target>
        </trans-unit>
        <trans-unit id="1a75c237f8187352ba7d075c4badc17c24ae0667" translate="yes" xml:space="preserve">
          <source>Promisification means converting an existing promise-unaware API to a promise-returning API.</source>
          <target state="translated">许诺化是指将现有的不知道许诺的API转换为许诺返回的API。</target>
        </trans-unit>
        <trans-unit id="f53b14543d28697f9e7972521e017a85547d2532" translate="yes" xml:space="preserve">
          <source>Promisification now consider all functions on the object and its prototype chain</source>
          <target state="translated">许诺化现在考虑对象及其原型链上的所有功能。</target>
        </trans-unit>
        <trans-unit id="0968c7924c5fa044c0bc32de590809b8b7a0237f" translate="yes" xml:space="preserve">
          <source>Promisification on steroids</source>
          <target state="translated">类固醇的诱惑</target>
        </trans-unit>
        <trans-unit id="f0fa280902593381c17c8ba3cc647f71fd36f85f" translate="yes" xml:space="preserve">
          <source>Promisified methods from promisifyAll no longer call the original method when it is overriden</source>
          <target state="translated">从 promisifyAll 中得到的 Promisified 方法被覆盖后,不再调用原来的方法。</target>
        </trans-unit>
        <trans-unit id="852dd44380a8f2d2fa9332abfb43753326f8154b" translate="yes" xml:space="preserve">
          <source>Promisifier APIs.</source>
          <target state="translated">Promisifier APIs。</target>
        </trans-unit>
        <trans-unit id="b7ec2af376bac24219fefb48cbd2c962d80ace5d" translate="yes" xml:space="preserve">
          <source>Promisifies the entire object by going through the object's properties and creating an async equivalent of each function on the object and its prototype chain. The promisified method name will be the original method name suffixed with &lt;code&gt;suffix&lt;/code&gt; (default is &lt;code&gt;&quot;Async&quot;&lt;/code&gt;). Any class properties of the object (which is the case for the main export of many modules) are also promisified, both static and instance methods. Class property is a property with a function value that has a non-empty &lt;code&gt;.prototype&lt;/code&gt; object. Returns the input object.</source>
          <target state="translated">通过遍历对象的属性，并在对象及其原型链上创建每个函数的异步等效项，来使整个对象承诺化。约定的方法名称将是带有 &lt;code&gt;suffix&lt;/code&gt; 的原始方法名称（默认为 &lt;code&gt;&quot;Async&quot;&lt;/code&gt; ）。对象的任何类属性（许多模块的主要输出就是这种情况）也都可以实现，包括静态方法和实例方法。类属性是具有函数值的属性，该函数值具有非空的 &lt;code&gt;.prototype&lt;/code&gt; 对象。返回输入对象。</target>
        </trans-unit>
        <trans-unit id="7adb5806d2a6c639cdca0db8fdac9403bca0bc03" translate="yes" xml:space="preserve">
          <source>Promisifying multiple classes in one go</source>
          <target state="translated">一次性答应多个班级</target>
        </trans-unit>
        <trans-unit id="c938fd9d6e36daebdbc0cf487cfd4869c4aa7f93" translate="yes" xml:space="preserve">
          <source>Proper version check supporting VSCode(&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/1576&quot;&gt;&lt;code&gt;#1576&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">支持VSCode（&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/1576&quot;&gt; &lt;code&gt;#1576&lt;/code&gt; &lt;/a&gt;）的正确版本检查</target>
        </trans-unit>
        <trans-unit id="6e3604888c4b4ec08e2837913d012fe2834ffa83" translate="yes" xml:space="preserve">
          <source>Python</source>
          <target state="translated">Python</target>
        </trans-unit>
        <trans-unit id="4177920eedb2d8d91fca3384f4b40aec4d20dcd2" translate="yes" xml:space="preserve">
          <source>Q and bluebird share a lot of common methods that nevertheless have different names:</source>
          <target state="translated">Q和蓝鸟有很多共同的方法,然而却有不同的名字。</target>
        </trans-unit>
        <trans-unit id="e9f05aa2c47c6bff64cd5f9cf0a523af4429924d" translate="yes" xml:space="preserve">
          <source>Rate Limiting</source>
          <target state="translated">费率限制</target>
        </trans-unit>
        <trans-unit id="161ffbbe54e77d4760152fa5b4074a0a6142966a" translate="yes" xml:space="preserve">
          <source>Read given files sequentially while summing their contents as an integer. Each file contains just the text &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">顺序读取给定文件，同时将它们的内容累加为整数。每个文件仅包含文本 &lt;code&gt;10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26bb4a571dec15958b5bf88436f13b472b9923db" translate="yes" xml:space="preserve">
          <source>Real example 2:</source>
          <target state="translated">真实的例子2。</target>
        </trans-unit>
        <trans-unit id="cf7056b7cac2c0b2ad06995c1808b40114dc8624" translate="yes" xml:space="preserve">
          <source>Real example:</source>
          <target state="translated">真正的例子。</target>
        </trans-unit>
        <trans-unit id="ede0567a2a6e0fddab65269f6559f8f6dd06aeb3" translate="yes" xml:space="preserve">
          <source>Rebinding can also be abused to do something gratuitous like this:</source>
          <target state="translated">重装也可以滥用,做这样无偿的事情。</target>
        </trans-unit>
        <trans-unit id="bf87a9a8812fbf363e857266207b8e2473838eca" translate="yes" xml:space="preserve">
          <source>Reduce minified full browser build file size by not including unused code generation functionality.</source>
          <target state="translated">通过不包含未使用的代码生成功能来减少最小化的完整浏览器构建文件大小。</target>
        </trans-unit>
        <trans-unit id="aef1e9eebf3f426cee92bf8ff691ff6719cedbd1" translate="yes" xml:space="preserve">
          <source>Register a node-style callback on this promise. When this promise is either fulfilled or rejected, the node callback will be called back with the node.js convention where error reason is the first argument and success value is the second argument. The error argument will be &lt;code&gt;null&lt;/code&gt; in case of success.</source>
          <target state="translated">在此承诺上注册节点样式的回调。当实现或拒绝了这个承诺时，将使用node.js约定来回调节点回调，其中错误原因是第一个参数，成功值是第二个参数。如果成功，错误参数将为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8d6efc26ea6904bda20ba7769db8ea12c079f56" translate="yes" xml:space="preserve">
          <source>Reject the underlying promise with &lt;code&gt;reason&lt;/code&gt; as the rejection reason.</source>
          <target state="translated">以 &lt;code&gt;reason&lt;/code&gt; 作为拒绝理由，拒绝潜在的承诺。</target>
        </trans-unit>
        <trans-unit id="3368ac8416e6d7cbc9d06211f6a676de253db2de" translate="yes" xml:space="preserve">
          <source>Rejections originating from &lt;code&gt;Promise.reject&lt;/code&gt;</source>
          <target state="translated">源自 &lt;code&gt;Promise.reject&lt;/code&gt; 的拒绝</target>
        </trans-unit>
        <trans-unit id="8b0dba4404c73e60c9ff9e9453523c35331ea038" translate="yes" xml:space="preserve">
          <source>Rejections originating from &lt;code&gt;PromiseResolver&lt;/code&gt; where &lt;code&gt;.reject()&lt;/code&gt; method is called explicitly</source>
          <target state="translated">源自 &lt;code&gt;PromiseResolver&lt;/code&gt; 的拒绝，其中显式调用 &lt;code&gt;.reject()&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="41142268db768fb66fa944cf61f77fd9b9826e36" translate="yes" xml:space="preserve">
          <source>Rejections originating from &lt;code&gt;new Promise&lt;/code&gt; constructor where the &lt;code&gt;reject&lt;/code&gt; callback is called explicitly</source>
          <target state="translated">来自 &lt;code&gt;new Promise&lt;/code&gt; 构造函数的 &lt;code&gt;reject&lt;/code&gt; ，其中拒绝回调被显式调用</target>
        </trans-unit>
        <trans-unit id="4fe2d523f67748538641074127a1db6157d74f6a" translate="yes" xml:space="preserve">
          <source>Rejections originating from promisified callbacks which use the &lt;code&gt;errback&lt;/code&gt; argument</source>
          <target state="translated">拒绝源自使用 &lt;code&gt;errback&lt;/code&gt; 参数的有承诺的回调</target>
        </trans-unit>
        <trans-unit id="8eec88d2942215a1433216bd7c1c773ddcf67d09" translate="yes" xml:space="preserve">
          <source>Rejections originating from thenables using the &lt;code&gt;reject&lt;/code&gt; callback</source>
          <target state="translated">使用 &lt;code&gt;reject&lt;/code&gt; 回调源自可售商品的拒绝</target>
        </trans-unit>
        <trans-unit id="198141ba7b56bcf3bec5a18ddd355c8adf68088b" translate="yes" xml:space="preserve">
          <source>Release control of the &lt;code&gt;Promise&lt;/code&gt; namespace to whatever it was before this library was loaded. Returns a reference to the library namespace so you can attach it to something else.</source>
          <target state="translated">将 &lt;code&gt;Promise&lt;/code&gt; 命名空间的控制权释放到加载此库之前的状态。返回对库名称空间的引用，以便可以将其附加到其他内容。</target>
        </trans-unit>
        <trans-unit id="0181ee2fe3f8479b72a162b35eb3977b69562275" translate="yes" xml:space="preserve">
          <source>Remove dependency of es5-shim and es5-sham when using ES3.</source>
          <target state="translated">当使用ES3时,删除es5-shim和es5-sham的依赖性。</target>
        </trans-unit>
        <trans-unit id="e444431ea8965e36418e87f29f232d6f066fbe6e" translate="yes" xml:space="preserve">
          <source>Remove kew from benchmarks due to bugs in the library breaking the benchmark</source>
          <target state="translated">由于库中的bug破坏了基准,因此从基准中删除kew。</target>
        </trans-unit>
        <trans-unit id="1a4dd4da1213db0bc986ba8e811f9173d4dfd37c" translate="yes" xml:space="preserve">
          <source>Remove memoization of thenables</source>
          <target state="translated">取消对时效性的记忆</target>
        </trans-unit>
        <trans-unit id="851f4336d464dd91890330239ecdcbcd3eede50c" translate="yes" xml:space="preserve">
          <source>Remove uses of dynamic evaluation (&lt;code&gt;new Function&lt;/code&gt;, &lt;code&gt;eval&lt;/code&gt; etc) when strictly not necessary. Use feature detection to use static evaluation to avoid errors when dynamic evaluation is prohibited.</source>
          <target state="translated">在完全不必要的情况下，请删除动态评估（ &lt;code&gt;new Function&lt;/code&gt; ， &lt;code&gt;eval&lt;/code&gt; 等）的使用。当禁止动态评估时，使用特征检测可以使用静态评估来避免错误。</target>
        </trans-unit>
        <trans-unit id="963bc143de16fd9c36ff8020e48785b4de1b5fa2" translate="yes" xml:space="preserve">
          <source>Removed the &lt;code&gt;.inspect()&lt;/code&gt; method</source>
          <target state="translated">删除了 &lt;code&gt;.inspect()&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="73c105dee9adb30dced75f9d53b912f789492799" translate="yes" xml:space="preserve">
          <source>Rename PromiseResolver#asCallback to PromiseResolver#callback</source>
          <target state="translated">将PromiseResolver#asCallback重命名为PromiseResolver#callback。</target>
        </trans-unit>
        <trans-unit id="a93b7a7d13386c2b9229d1b2d9f532763ef7e300" translate="yes" xml:space="preserve">
          <source>Report unhandled rejections even when long stack traces are disabled</source>
          <target state="translated">即使禁用了长栈跟踪,也要报告未处理的拒绝。</target>
        </trans-unit>
        <trans-unit id="212187c4ba067f96c7eec7538c40788ae9024465" translate="yes" xml:space="preserve">
          <source>Represents an error is an explicit promise rejection as opposed to a thrown error. For example, if an error is errbacked by a callback API promisified through &lt;a href=&quot;promise.promisify&quot;&gt;&lt;code&gt;Promise.promisify&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; and is not a typed error, it will be converted to a &lt;code&gt;OperationalError&lt;/code&gt; which has the original error in the &lt;code&gt;.cause&lt;/code&gt; property.</source>
          <target state="translated">表示错误是与抛出错误相反的显式承诺拒绝。例如，如果错误是通过&lt;a href=&quot;promise.promisify&quot;&gt; &lt;code&gt;Promise.promisify&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; 允许&lt;/a&gt;的回调API错误返回的，而不是类型错误，则它将转换为 &lt;code&gt;OperationalError&lt;/code&gt; ，该错误的原始错误在 &lt;code&gt;.cause&lt;/code&gt; 属性中。</target>
        </trans-unit>
        <trans-unit id="f957ddaaf86217c5ba862399d723b49b7e0b15cb" translate="yes" xml:space="preserve">
          <source>Requires a statement so cannot be used in an expression context</source>
          <target state="translated">需要一个语句,所以不能用于表达式上下文中</target>
        </trans-unit>
        <trans-unit id="9c076f55ca621ae470e8e6540a2f2547c25d4dbe" translate="yes" xml:space="preserve">
          <source>Resolve the underlying promise with &lt;code&gt;value&lt;/code&gt; as the resolution value. If &lt;code&gt;value&lt;/code&gt; is a thenable or a promise, the underlying promise will assume its state.</source>
          <target state="translated">用 &lt;code&gt;value&lt;/code&gt; 作为解决方案价值解决潜在的承诺。如果 &lt;code&gt;value&lt;/code&gt; 是可兑现的或承诺，则基础承诺将采用其状态。</target>
        </trans-unit>
        <trans-unit id="78389e9ab495397e98445c046d321313be7d1269" translate="yes" xml:space="preserve">
          <source>Resolves to the original array unmodified, this method is meant to be used for side effects. If the iterator function returns a promise or a thenable, then the result of the promise is awaited, before continuing with next iteration.</source>
          <target state="translated">解析到原来的数组不做修改,这个方法是用来做副作用的。如果迭代函数返回一个promise或thenable,则等待promise的结果,然后继续下一次迭代。</target>
        </trans-unit>
        <trans-unit id="ce09507134e744cff09a805076e969ccb76e51c1" translate="yes" xml:space="preserve">
          <source>Resolves to the original array unmodified. This method is meant to be used for side effects.</source>
          <target state="translated">重组到原始数组,不做修改。此方法是为了副作用而使用的。</target>
        </trans-unit>
        <trans-unit id="9e392aa0bd224f1b62eea587068fd172df50f2e7" translate="yes" xml:space="preserve">
          <source>Resource management</source>
          <target state="translated">资源管理</target>
        </trans-unit>
        <trans-unit id="0d5055e26e1fb07ecf2ddfcb210895ed4ebe7ce8" translate="yes" xml:space="preserve">
          <source>Rethink already uses Bluebird promises internally and has promise returning APIs. Use those.</source>
          <target state="translated">Rethink内部已经使用Bluebird承诺,并且有承诺返回API。使用这些。</target>
        </trans-unit>
        <trans-unit id="89ddb5cfb70d8bad46dda602a6ccbd88515a58d8" translate="yes" xml:space="preserve">
          <source>RethinkDB</source>
          <target state="translated">RethinkDB</target>
        </trans-unit>
        <trans-unit id="48ceb22a9c112e78b0de9c59218daa18a395591e" translate="yes" xml:space="preserve">
          <source>Returns a Disposer object which encapsulates both the resource as well as the method to clean it up. The user can pass this object to &lt;code&gt;Promise.using&lt;/code&gt; to get access to the resource when it becomes available, as well as to ensure it's automatically cleaned up.</source>
          <target state="translated">返回一个Disposer对象，该对象封装了资源以及清理资源的方法。用户可以将此对象传递给 &lt;code&gt;Promise.using&lt;/code&gt; ，以在资源可用时访问该资源，并确保其被自动清理。</target>
        </trans-unit>
        <trans-unit id="5f6f3eb0a331057a9ce7728d16275ef0f0403798" translate="yes" xml:space="preserve">
          <source>Returns a function that can use &lt;code&gt;yield&lt;/code&gt; to yield promises. Control is returned back to the generator when the yielded promise settles. This can lead to less verbose code when doing lots of sequential async calls with minimal processing in between. Requires node.js 0.12+, io.js 1.0+ or Google Chrome 40+.</source>
          <target state="translated">返回可以使用 &lt;code&gt;yield&lt;/code&gt; 产生promise 的函数。当产生的承诺成立时，控制权将返回给生成器。进行大量顺序异步调用且之间的处理最少时，这可以减少冗长的代码。需要node.js 0.12 +，io.js 1.0+或Google Chrome 40+。</target>
        </trans-unit>
        <trans-unit id="0f8e633d273655fa3f1e81f2818120962168742f" translate="yes" xml:space="preserve">
          <source>Returns a function that will wrap the given &lt;code&gt;nodeFunction&lt;/code&gt;. Instead of taking a callback, the returned function will return a promise whose fate is decided by the callback behavior of the given node function. The node function should conform to node.js convention of accepting a callback as last argument and calling that callback with error as the first argument and success value on the second argument.</source>
          <target state="translated">返回一个将包装给定 &lt;code&gt;nodeFunction&lt;/code&gt; 的函数。返回的函数将返回一个promise，而不是执行回调，该promise的命运由给定节点函数的回调行为决定。node函数应符合node.js约定，即接受回调作为最后一个参数，并以错误作为第一个参数并在第二个参数上获得成功值来调用该回调。</target>
        </trans-unit>
        <trans-unit id="77302444e8cc66fc3523da337688a121188e8a8c" translate="yes" xml:space="preserve">
          <source>Returns a new function that wraps the given function &lt;code&gt;fn&lt;/code&gt;. The new function will always return a promise that is fulfilled with the original functions return values or rejected with thrown exceptions from the original function.</source>
          <target state="translated">返回包装给定函数 &lt;code&gt;fn&lt;/code&gt; 的新函数。新函数将始终返回由原始函数返回值实现的承诺，或因原始函数引发的异常而被拒绝的承诺。</target>
        </trans-unit>
        <trans-unit id="d0084f22c144f601402343afe0d33d4fb7f3e903" translate="yes" xml:space="preserve">
          <source>Returns a new independent copy of the Bluebird library.</source>
          <target state="translated">返回Bluebird库的一个新的独立副本。</target>
        </trans-unit>
        <trans-unit id="1b966690c369fe4ac468c8b47b2a688522f4806f" translate="yes" xml:space="preserve">
          <source>Returns a promise for an array that contains the values returned by the &lt;code&gt;iterator&lt;/code&gt; function in their respective positions. The iterator won't be called for an item until its previous item, and the promise returned by the iterator for that item are fulfilled. This results in a &lt;code&gt;mapSeries&lt;/code&gt; kind of utility but it can also be used simply as a side effect iterator similar to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;Array#forEach&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回一个数组的promise，该数组包含 &lt;code&gt;iterator&lt;/code&gt; 函数在各自位置返回的值。直到它的上一个项目被调用时，迭代器才会被调用，并且迭代器为该项目返回的promise将被兑现。这产生了 &lt;code&gt;mapSeries&lt;/code&gt; 类的实用程序，但它也可以简单地用作类似于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;Array#forEach&lt;/code&gt; 的&lt;/a&gt;副作用迭代器。</target>
        </trans-unit>
        <trans-unit id="9fa83662ab7e1494742b674953702f77f5f38fa1" translate="yes" xml:space="preserve">
          <source>Returns a promise that is resolved by a node style callback function. This is the most fitting way to do on the fly promisification when libraries don't expose classes for automatic promisification by undefined.</source>
          <target state="translated">返回一个由节点式回调函数解析的承诺。当库中没有暴露类以实现未定义的自动承诺时,这是最合适的即时承诺方式。</target>
        </trans-unit>
        <trans-unit id="4da867e8cf20d6ea986a5fd922cf7a1fb8f17c8a" translate="yes" xml:space="preserve">
          <source>Returns a promise that will be fulfilled with this promise's fulfillment value or rejection reason. However, if this promise is not fulfilled or rejected within &lt;code&gt;ms&lt;/code&gt; milliseconds, the returned promise is rejected with a &lt;a href=&quot;timeouterror&quot;&gt;&lt;code&gt;TimeoutError&lt;/code&gt;&lt;/a&gt; or the &lt;code&gt;error&lt;/code&gt; as the reason.</source>
          <target state="translated">返回将用该承诺的履行价值或拒绝原因来履行的承诺。但是，如果未在 &lt;code&gt;ms&lt;/code&gt; 毫秒内实现或拒绝此承诺，则将以&lt;a href=&quot;timeouterror&quot;&gt; &lt;code&gt;TimeoutError&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;error&lt;/code&gt; 作为原因拒绝返回的承诺。</target>
        </trans-unit>
        <trans-unit id="dd6aed551657efa53d35002ee36b6a3e0c3755d8" translate="yes" xml:space="preserve">
          <source>Returns a promise that will be resolved with &lt;code&gt;value&lt;/code&gt; (or &lt;code&gt;undefined&lt;/code&gt;) after given &lt;code&gt;ms&lt;/code&gt; milliseconds. If &lt;code&gt;value&lt;/code&gt; is a promise, the delay will start counting down when it is fulfilled and the returned promise will be fulfilled with the fulfillment value of the &lt;code&gt;value&lt;/code&gt; promise. If &lt;code&gt;value&lt;/code&gt; is a rejected promise, the resulting promise will be rejected immediately.</source>
          <target state="translated">返回在给定 &lt;code&gt;ms&lt;/code&gt; 毫秒后将使用 &lt;code&gt;value&lt;/code&gt; （或 &lt;code&gt;undefined&lt;/code&gt; ）解析的promise 。如果 &lt;code&gt;value&lt;/code&gt; 是一个承诺，则延迟将在履行时开始递减计数，并且返回的承诺将以 &lt;code&gt;value&lt;/code&gt; 承诺的履行价值来履行。如果 &lt;code&gt;value&lt;/code&gt; 是被拒绝的承诺，则所产生的承诺将立即被拒绝。</target>
        </trans-unit>
        <trans-unit id="0baaeaec06f70621397f1ef99fcbfb8ddf084acc" translate="yes" xml:space="preserve">
          <source>Returns back this promise instead of creating a new one. If the &lt;code&gt;callback&lt;/code&gt; argument is not a function, this method does not do anything.</source>
          <target state="translated">返回此承诺，而不是创建一个新的承诺。如果 &lt;code&gt;callback&lt;/code&gt; 参数不是函数，则此方法不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="f7778ce7c8366fce862636b34420e6d9618d48dd" translate="yes" xml:space="preserve">
          <source>Revert monitoring feature due to crash in browser</source>
          <target state="translated">浏览器崩溃导致的反向监控功能</target>
        </trans-unit>
        <trans-unit id="48334a9d7741c7c5b6ebf7eef29195609c38e705" translate="yes" xml:space="preserve">
          <source>Rollback non-working multiple fresh copies feature</source>
          <target state="translated">回滚不工作的多个新鲜副本功能</target>
        </trans-unit>
        <trans-unit id="af2379a3b3b95738bc09586b8c9af459a812b070" translate="yes" xml:space="preserve">
          <source>Run example on JSBin</source>
          <target state="translated">在JSBin上运行示例</target>
        </trans-unit>
        <trans-unit id="080508f70cca7834ce2ef4eef4f37dd98ffff2b4" translate="yes" xml:space="preserve">
          <source>Running the example:</source>
          <target state="translated">运行这个例子。</target>
        </trans-unit>
        <trans-unit id="e2fa217fe73b363a41e739397cee0e3ca1933591" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.all&quot;&gt;&lt;code&gt;Promise.all(this)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;promise.all&quot;&gt; &lt;code&gt;Promise.all(this)&lt;/code&gt; &lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="2b23caad0148511b77a2cf241f932d7c6709a7d3" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.any&quot;&gt;&lt;code&gt;Promise.any(this)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;promise.any&quot;&gt; &lt;code&gt;Promise.any(this)&lt;/code&gt; &lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="580ea88db97d01930313a97fceee680b30d45b7d" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.filter&quot;&gt;&lt;code&gt;Promise.filter(this, filterer, options)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;promise.filter&quot;&gt; &lt;code&gt;Promise.filter(this, filterer, options)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="975ef8a2ddc0a473b966c6a5cf58d6b15ce60290" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.map&quot;&gt;&lt;code&gt;Promise.map(this, mapper, options)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;promise.map&quot;&gt; &lt;code&gt;Promise.map(this, mapper, options)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6801edeea7902bcdcddad94e4e019a39b6cf35a" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.mapseries&quot;&gt;&lt;code&gt;Promise.mapSeries(this, iterator)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;promise.mapseries&quot;&gt; &lt;code&gt;Promise.mapSeries(this, iterator)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b8c55e09fe61d7950e9b369ac035513826c1d2a6" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.props&quot;&gt;&lt;code&gt;Promise.props(this)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;promise.props&quot;&gt; &lt;code&gt;Promise.props(this)&lt;/code&gt; &lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="8a380c08b4944e2caae2cd146735f961151b5e6e" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.reduce&quot;&gt;&lt;code&gt;Promise.reduce(this, reducer, initialValue)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;promise.reduce&quot;&gt; &lt;code&gt;Promise.reduce(this, reducer, initialValue)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a356dad7c25106bdfd17533e6d57d965a40a5a84" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.some&quot;&gt;&lt;code&gt;Promise.some(this, count)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;promise.some&quot;&gt; &lt;code&gt;Promise.some(this, count)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6cc344c16a1e8b60323a0d888ae481c9928a8ab" translate="yes" xml:space="preserve">
          <source>Same as calling &lt;a href=&quot;promise.bind&quot;&gt;&lt;code&gt;Promise.bind(thisArg, thisPromise)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与调用&lt;a href=&quot;promise.bind&quot;&gt; &lt;code&gt;Promise.bind(thisArg, thisPromise)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e458385af15b3281d6aad96024285a33aab42f7e" translate="yes" xml:space="preserve">
          <source>Same as calling &lt;a href=&quot;promise.delay&quot;&gt;&lt;code&gt;Promise.delay(ms, this)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与调用&lt;a href=&quot;promise.delay&quot;&gt; &lt;code&gt;Promise.delay(ms, this)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c2c078b3023463c3ffc03ea245f314b93b9997db" translate="yes" xml:space="preserve">
          <source>Same limitations regarding to the binding time of &lt;code&gt;reason&lt;/code&gt; to apply as with &lt;a href=&quot;return&quot;&gt;&lt;code&gt;.return&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;return&quot;&gt; &lt;code&gt;.return&lt;/code&gt; &lt;/a&gt;一样，对申请 &lt;code&gt;reason&lt;/code&gt; 的约束时间也有相同的限制。</target>
        </trans-unit>
        <trans-unit id="c5f6c90a1ad0cebcb9beb15aafa1cb6735ec4a6f" translate="yes" xml:space="preserve">
          <source>Same limitations regarding to the binding time of &lt;code&gt;value&lt;/code&gt; to apply as with &lt;a href=&quot;return&quot;&gt;&lt;code&gt;.return&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;return&quot;&gt; &lt;code&gt;.return&lt;/code&gt; &lt;/a&gt;相同的关于 &lt;code&gt;value&lt;/code&gt; 绑定时间的限制。</target>
        </trans-unit>
        <trans-unit id="7b7e70bcf209a5323526033a9cbf768a3ae70c2c" translate="yes" xml:space="preserve">
          <source>Scala</source>
          <target state="translated">Scala</target>
        </trans-unit>
        <trans-unit id="4c8d353832617594b0903e9beaf0a3bc9414fd0a" translate="yes" xml:space="preserve">
          <source>Scheduler should be a function that asynchronously schedules the calling of the passed in function:</source>
          <target state="translated">Scheduler应该是一个异步调度调用传入函数的函数。</target>
        </trans-unit>
        <trans-unit id="b6e22d4f13d0bc08ae5171b4f3faa591b3854aba" translate="yes" xml:space="preserve">
          <source>Scoped prototypes</source>
          <target state="translated">范围内的原型</target>
        </trans-unit>
        <trans-unit id="1e4c2c805f8ac17da444424c8f8bf077911b3260" translate="yes" xml:space="preserve">
          <source>Second example is creating a function that does nothing but manually wrap a callback API and doing a poor job at that:</source>
          <target state="translated">第二个例子是创建一个函数,除了手动封装回调API之外,什么都不做,而且在这方面做得很差。</target>
        </trans-unit>
        <trans-unit id="c651da6b87ea51d587627a0d63283b28e42fd9e4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#map-option-concurrency&quot;&gt;Map Option: concurrency&lt;/a&gt;</source>
          <target state="translated">请参阅&lt;a href=&quot;#map-option-concurrency&quot;&gt;地图选项：并发&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3fc2fab79463362dbab8dbab63714a6f37b5961f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#promisification&quot;&gt;promisification&lt;/a&gt; for more examples.</source>
          <target state="translated">有关更多示例，请参见&lt;a href=&quot;#promisification&quot;&gt;promisification&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23a68335a77ae0704a80f59d32facaab6ffbdba9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/cancellation&quot;&gt;&lt;code&gt;Cancellation&lt;/code&gt;&lt;/a&gt; for how to use cancellation.</source>
          <target state="translated">有关如何使用取消的信息，请参见&lt;a href=&quot;api/cancellation&quot;&gt; &lt;code&gt;Cancellation&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f52e149e8a0803d7f7b841c33681f919e936364" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/environment-variables&quot;&gt;&lt;code&gt;Environment Variables&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;api/environment-variables&quot;&gt; &lt;code&gt;Environment Variables&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab38b0ca0dbd1886ea0aa3b5d41ba2fd2e703bb5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/error-management-configuration#global-rejection-events&quot;&gt;global rejection events&lt;/a&gt; to learn more about the hooks.</source>
          <target state="translated">查看&lt;a href=&quot;api/error-management-configuration#global-rejection-events&quot;&gt;全局拒绝事件&lt;/a&gt;以了解有关挂钩的更多信息。</target>
        </trans-unit>
        <trans-unit id="06395aee9e31cf27b400d0aac841e6752959ba6e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/progression-migration&quot;&gt;Progression Migration&lt;/a&gt; for migration assistance and examples of how to convert APIs that use progression to ones that do not.</source>
          <target state="translated">请参阅&lt;a href=&quot;api/progression-migration&quot;&gt;渐进迁移&lt;/a&gt;以获取迁移帮助，以及如何将使用渐进的API转换为不使用渐进的API的示例。</target>
        </trans-unit>
        <trans-unit id="68ba78b1d14da78646ebff542d287d69dbc5a960" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://stackoverflow.com/a/17891099/227176&quot;&gt;this StackOverflow answer&lt;/a&gt; for a more detailed and feature complete way to make custom errors.</source>
          <target state="translated">请参阅&lt;a href=&quot;http://stackoverflow.com/a/17891099/227176&quot;&gt;此StackOverflow答案&lt;/a&gt;，以获取更详细且功能完整的自定义错误方法。</target>
        </trans-unit>
        <trans-unit id="06706fc1eca556ceadf36cdc2fed09eb5719e880" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://stackoverflow.com/questions/22724883/js-deferred-promise-future-compared-to-functional-languages-like-scala&quot;&gt;this question on StackOverflow&lt;/a&gt; for more differences.</source>
          <target state="translated">有关更多差异，请参见&lt;a href=&quot;http://stackoverflow.com/questions/22724883/js-deferred-promise-future-compared-to-functional-languages-like-scala&quot;&gt;StackOverflow上的此问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="87f924e288cbca74d9deadff4feb3964dc20a0cb" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://stackoverflow.com/questions/26136389/how-can-i-realize-pattern-promise-deffered&quot;&gt;this question on StackOverflow&lt;/a&gt; for more differences.</source>
          <target state="translated">有关更多差异，请参见&lt;a href=&quot;http://stackoverflow.com/questions/26136389/how-can-i-realize-pattern-promise-deffered&quot;&gt;StackOverflow上的此问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b47ded2bd3e84b6a1d18b1f7005536f6c95a4c4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;install&quot;&gt;installation&lt;/a&gt; on how to enable long stack traces in your environment.</source>
          <target state="translated">有关如何在您的环境中启用长堆栈跟踪的信息，请参见&lt;a href=&quot;install&quot;&gt;安装&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40938884818bf7e771e25611b0ecc72ecf13d826" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;install&quot;&gt;installation&lt;/a&gt; on how to enable warnings in your environment.</source>
          <target state="translated">有关如何在您的环境中启用警告的信息，请参见&lt;a href=&quot;install&quot;&gt;安装&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd18968e9220ec2edbcb69219a62b308e07af8ca" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;new-in-bluebird-3&quot;&gt;New in 3.0&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;new-in-bluebird-3&quot;&gt;3.0中的新增功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a128fef004cd14934d7a35ae580447b292348acd" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">另请参阅&lt;a href=&quot;api/promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c964d6768cfba0357dc178ad5c1c5b834096887" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">另请参阅&lt;a href=&quot;promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec633a7c6034c365e8ffcaf57fd91b71d7eba69d" translate="yes" xml:space="preserve">
          <source>See if this &lt;code&gt;promise&lt;/code&gt; has been cancelled.</source>
          <target state="translated">查看此 &lt;code&gt;promise&lt;/code&gt; 是否已取消。</target>
        </trans-unit>
        <trans-unit id="e2ba106a736de3c98da11dcab4e39f4c475860bf" translate="yes" xml:space="preserve">
          <source>See if this &lt;code&gt;promise&lt;/code&gt; is pending (not fulfilled or rejected or cancelled).</source>
          <target state="translated">查看此 &lt;code&gt;promise&lt;/code&gt; 是否未完成（未实现，拒绝或取消）。</target>
        </trans-unit>
        <trans-unit id="43f5e31f9196af8cf21954e2abe72267402aeb61" translate="yes" xml:space="preserve">
          <source>See if this promise has been fulfilled.</source>
          <target state="translated">看看这个承诺是否已经实现了。</target>
        </trans-unit>
        <trans-unit id="a4923f987cce26c1b5f0647eecfad58c0130790b" translate="yes" xml:space="preserve">
          <source>See if this promise has been rejected.</source>
          <target state="translated">看看这个承诺是否已经被拒绝。</target>
        </trans-unit>
        <trans-unit id="00853e3a835e9b91810aba99eb34ee3eaa60c4cf" translate="yes" xml:space="preserve">
          <source>See the API on &lt;a href=&quot;api/synchronous-inspection&quot;&gt;&lt;code&gt;synchronous inspection&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">有关更多信息，请参阅&lt;a href=&quot;api/synchronous-inspection&quot;&gt; &lt;code&gt;synchronous inspection&lt;/code&gt; &lt;/a&gt;的API 。</target>
        </trans-unit>
        <trans-unit id="b6d3dd68401ad34ac91e21bd296d96dcc691d3a3" translate="yes" xml:space="preserve">
          <source>See the API page about &lt;a href=&quot;api/promise.longstacktraces&quot;&gt;&lt;code&gt;Promise.longStackTraces&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">请参阅有关&lt;a href=&quot;api/promise.longstacktraces&quot;&gt; &lt;code&gt;Promise.longStackTraces&lt;/code&gt; &lt;/a&gt;的API页面</target>
        </trans-unit>
        <trans-unit id="32248b4544c4dacee860f46416e5a89b6310bc5c" translate="yes" xml:space="preserve">
          <source>Sequelize</source>
          <target state="translated">Sequelize</target>
        </trans-unit>
        <trans-unit id="0353c268d6003a0b1d6e372faa2ae4914cf1ab42" translate="yes" xml:space="preserve">
          <source>Sequelize already uses Bluebird promises internally and has promise returning APIs. Use those.</source>
          <target state="translated">Sequelize内部已经使用Bluebird承诺,并且有承诺返回API。使用这些。</target>
        </trans-unit>
        <trans-unit id="0477fce5eb6ea953b269e6b50843ad48931e59dd" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;multiArgs&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; means the resulting promise will always fulfill with an array of the callback's success value(s). This is needed because promises only support a single success value while some callback API's have multiple success value. The default is to ignore all but the first success value of a callback function.</source>
          <target state="translated">将 &lt;code&gt;multiArgs&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 意味着所产生的承诺将始终通过回调的成功值数组来实现。之所以需要这样做，是因为Promise仅支持单个成功值，而某些回调API具有多个成功值。默认值是忽略除回调函数的第一个成功值以外的所有值。</target>
        </trans-unit>
        <trans-unit id="9d87c38ef9cdbe40b70787a797d9e70b16e2a6cd" translate="yes" xml:space="preserve">
          <source>Setting a custom scheduler could be necessary when you need a faster way to schedule functions than bluebird does by default. It also makes bluebird possible to use in platforms where normal timing constructs like &lt;code&gt;setTimeout&lt;/code&gt; and &lt;code&gt;process.nextTick&lt;/code&gt; are not available (like Nashhorn).</source>
          <target state="translated">当您需要一种比bluebird默认情况下更快的方法来调度功能时，可能需要设置自定义调度程序。它还使bluebird可以用于没有 &lt;code&gt;setTimeout&lt;/code&gt; 和 &lt;code&gt;process.nextTick&lt;/code&gt; 之类的常规计时结构的平台（如Nashhorn）。</target>
        </trans-unit>
        <trans-unit id="3932ebbf539f8a931c6f13cf255530da552644ed" translate="yes" xml:space="preserve">
          <source>Setting the environment variable &lt;code&gt;NODE_ENV&lt;/code&gt; to &lt;code&gt;&quot;development&quot;&lt;/code&gt; also automatically enables long stack traces.</source>
          <target state="translated">将环境变量 &lt;code&gt;NODE_ENV&lt;/code&gt; 设置为 &lt;code&gt;&quot;development&quot;&lt;/code&gt; 也会自动启用长堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="4742ee0d05bf00094d42512b9006ce355572faaf" translate="yes" xml:space="preserve">
          <source>Several examples of databases follow.</source>
          <target state="translated">下面举几个数据库的例子。</target>
        </trans-unit>
        <trans-unit id="6e704260c9c34a30c1e1c6e9cc96dcbaba23b9e4" translate="yes" xml:space="preserve">
          <source>Several popular Android libraries use promises - for example the Parse Java API returns &lt;code&gt;Task&lt;/code&gt;s which are similar to JavaScript promises.</source>
          <target state="translated">几种流行的Android库都使用诺言-例如，Parse Java API返回与JavaScript诺言相似的 &lt;code&gt;Task&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79948cec8617f2b258642406e788e89df84d104b" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;.then(null, null, handler);&lt;/code&gt;. Attach a progress handler that will be called if this promise is progressed. Returns a new promise chained from this promise.</source>
          <target state="translated">&lt;code&gt;.then(null, null, handler);&lt;/code&gt; 简写；。附加一个进度处理程序，如果该承诺完成，将被调用。返回与此承诺链接的新承诺。</target>
        </trans-unit>
        <trans-unit id="d2d63e7d6731c58944766cb081aef40963e6cb50" translate="yes" xml:space="preserve">
          <source>Showing a live list of rejected promises</source>
          <target state="translated">显示被拒绝承诺的实时列表</target>
        </trans-unit>
        <trans-unit id="8bbe005c943c12fa6ff0d2f8cafd5ad98bc70211" translate="yes" xml:space="preserve">
          <source>Signals that an operation has been aborted or cancelled. The default reason used by &lt;a href=&quot;cancel&quot;&gt;&lt;code&gt;.cancel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">表示操作已被中止或取消。&lt;a href=&quot;cancel&quot;&gt; &lt;code&gt;.cancel&lt;/code&gt; &lt;/a&gt;使用的默认原因。</target>
        </trans-unit>
        <trans-unit id="299f23dc5dcc08c7bfee7c8ae781aacf85c196cb" translate="yes" xml:space="preserve">
          <source>Signals that an operation has timed out. Used as a custom cancellation reason in &lt;a href=&quot;timeout&quot;&gt;&lt;code&gt;.timeout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">表示操作已超时。用作&lt;a href=&quot;timeout&quot;&gt; &lt;code&gt;.timeout&lt;/code&gt; 中&lt;/a&gt;的自定义取消原因。</target>
        </trans-unit>
        <trans-unit id="46bf40da88360ad7bbfcf32d9dd42056cd2f6ff3" translate="yes" xml:space="preserve">
          <source>Significantly improve parallel promise performance and memory usage (+50% faster, -50% less memory)</source>
          <target state="translated">显著提高并行承诺性能和内存使用率(快50%,内存减少50%)。</target>
        </trans-unit>
        <trans-unit id="d63c65ce4045c196a80e2036ef184d1e29767129" translate="yes" xml:space="preserve">
          <source>Significantly improve performance of foreign bluebird thenables</source>
          <target state="translated">显著提高国外蓝鸟的性能。</target>
        </trans-unit>
        <trans-unit id="730519283954b4569cc72648083ced3012f2475e" translate="yes" xml:space="preserve">
          <source>Similarly, with promises:</source>
          <target state="translated">同样,对于承诺。</target>
        </trans-unit>
        <trans-unit id="e16c84188a248cb435f2ade69bfef7f54bb36e8f" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;api/promise.all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt; takes promises, it must also take jQuery deferreds, so the above can be shortened to:</source>
          <target state="translated">由于&lt;a href=&quot;api/promise.all&quot;&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;/a&gt;承诺，因此还必须采用jQuery延迟，因此上述内容可以简化为：</target>
        </trans-unit>
        <trans-unit id="71d62301257a57ffc03da0d5c42ed2549e221316" translate="yes" xml:space="preserve">
          <source>Since all objects support having properties you might still wonder why exactly does it have to be an error object and not just any object. In addition to supporting properties, an equally important feature necessary for values that are automatically propagated is the stack trace property (&lt;code&gt;.stack&lt;/code&gt;). A stack trace allows you easily find where an error originated from as it gives the code's call stack - along with line numbers for reference in code files.</source>
          <target state="translated">由于所有对象都支持具有属性，因此您可能仍然想知道为什么它必须是错误对象而不是任何对象。除了支持属性之外，堆栈跟踪属性（ &lt;code&gt;.stack&lt;/code&gt; ）是自动传播的值所必需的同等重要的功能。堆栈跟踪可让您轻松找到错误的出处，因为它给出了代码的调用堆栈-以及代码文件中引用的行号。</target>
        </trans-unit>
        <trans-unit id="92d019d6c6f872eca710a5e9fe46091f1e234c2c" translate="yes" xml:space="preserve">
          <source>Since in bluebird &lt;a href=&quot;api/promisification&quot;&gt;&lt;code&gt;promisification&lt;/code&gt;&lt;/a&gt; is made trivial, you can get long stack traces all the time:</source>
          <target state="translated">由于在bluebird中，&lt;a href=&quot;api/promisification&quot;&gt; &lt;code&gt;promisification&lt;/code&gt; &lt;/a&gt;变得微不足道，因此您可以一直获得长堆栈跟踪：</target>
        </trans-unit>
        <trans-unit id="fd8d850f23fc1a81c14cb9cdd8a5e00431fefc26" translate="yes" xml:space="preserve">
          <source>Since the array passed to waterfall is static (always the same 3 functions) a plain old promise chain is used:</source>
          <target state="translated">由于传递给waterfall的数组是静态的(总是相同的3个函数),所以使用了一个普通的承诺链。</target>
        </trans-unit>
        <trans-unit id="ead75c8725f0a9530a5abc673013177ab974cfdf" translate="yes" xml:space="preserve">
          <source>Small performance improvements for all collection methods</source>
          <target state="translated">所有收集方法的性能都略有提高</target>
        </trans-unit>
        <trans-unit id="dc101ed1f69471502ee81d7871e2413721d60887" translate="yes" xml:space="preserve">
          <source>So how then could we represent a progress bar like dialog? Well the answer is to manage the progress through callbacks outside the promise API. Bluebird has since &lt;a href=&quot;deprecated-apis#progression&quot;&gt;deprecated the progression feature&lt;/a&gt; and offers an alternative which I hope to illustrate here.</source>
          <target state="translated">那么我们怎样才能代表对话框等进度条呢？答案是通过promise API之外的回调来管理进度。此后，Bluebird已&lt;a href=&quot;deprecated-apis#progression&quot;&gt;弃用了渐进功能，&lt;/a&gt;并提供了一种替代方法，我希望在此处进行说明。</target>
        </trans-unit>
        <trans-unit id="e1ae1ffa70bbe4990a8964de54d99ecd7b5fd6b5" translate="yes" xml:space="preserve">
          <source>So please write the same when using promises too:</source>
          <target state="translated">所以请在使用承诺时也写上同样的内容。</target>
        </trans-unit>
        <trans-unit id="e0e6caa4611dfebbc5e6e21fabaf9c486084de89" translate="yes" xml:space="preserve">
          <source>Some examples of the above practice applied to some popular libraries:</source>
          <target state="translated">上述做法应用于一些流行图书馆的一些例子。</target>
        </trans-unit>
        <trans-unit id="328f2682f2d41aa9dcab87997132944918cfc2f4" translate="yes" xml:space="preserve">
          <source>Some nodebacks expect more than 1 success value but there is no mapping for this in the promise world. You may specify the option &lt;code&gt;spread&lt;/code&gt; to call the nodeback with multiple values when the fulfillment value is an array:</source>
          <target state="translated">一些nodebacks期望成功值超过1，但是在promise世界中没有映射。您可以指定 &lt;code&gt;spread&lt;/code&gt; 选项，以在实现值为数组时使用多个值来调用节点回调：</target>
        </trans-unit>
        <trans-unit id="d38c75cc8957e65c44573a2e27f3885375d06448" translate="yes" xml:space="preserve">
          <source>Something missing from the above example is proper error handling. When it comes to promises it is a best practise to always &lt;em&gt;reject a promise with an Error&lt;/em&gt; and not with plain data such as an object, string, number, or null/undefined. The reasoning for this is promises are best used as a way to regain some of the syntax you have with the standard &lt;code&gt;try {} catch() {}&lt;/code&gt; blocks with asynchronous code.</source>
          <target state="translated">上面的示例缺少的是正确的错误处理。关于承诺，最好的做法是始终&lt;em&gt;拒绝带有错误的承诺，&lt;/em&gt;而不是&lt;em&gt;拒绝&lt;/em&gt;诸如对象，字符串，数字或空/未定义之类的简单数据。这样做的理由是，promise最好用作通过异步代码重新获得标准 &lt;code&gt;try {} catch() {}&lt;/code&gt; 块所具有的某些语法的一种方式。</target>
        </trans-unit>
        <trans-unit id="f5366b89baa9bf31993646740e57cd8f67859925" translate="yes" xml:space="preserve">
          <source>Sometimes we want to find out when a single one time event has finished. For example - a stream is done. For this we can use &lt;a href=&quot;api/new-promise&quot;&gt;&lt;code&gt;new Promise&lt;/code&gt;&lt;/a&gt;. Note that this option should be considered only if &lt;a href=&quot;#working-with-callback-apis-using-the-node-convention&quot;&gt;automatic conversion&lt;/a&gt; isn't possible.</source>
          <target state="translated">有时我们想找出单个事件何时结束。例如-流完成。为此，我们可以使用&lt;a href=&quot;api/new-promise&quot;&gt; &lt;code&gt;new Promise&lt;/code&gt; &lt;/a&gt;。请注意，仅当无法&lt;a href=&quot;#working-with-callback-apis-using-the-node-convention&quot;&gt;自动转换&lt;/a&gt;时才应考虑使用此选项。</target>
        </trans-unit>
        <trans-unit id="c0b9d85f33b2e758641f19550f5a9be3023ea242" translate="yes" xml:space="preserve">
          <source>Sometimes you have to work with APIs that are inconsistent and do not follow a common convention.</source>
          <target state="translated">有时,你必须与那些不一致的、不遵循通用惯例的API合作。</target>
        </trans-unit>
        <trans-unit id="47f7595fc4eaf9c4327785c6f28cc0a3cb93f37a" translate="yes" xml:space="preserve">
          <source>Sparse array holes are not skipped by collection methods but treated as existing elements with &lt;code&gt;undefined&lt;/code&gt; value</source>
          <target state="translated">稀疏数组孔不会被收集方法跳过，而是被视为具有 &lt;code&gt;undefined&lt;/code&gt; 值的现有元素</target>
        </trans-unit>
        <trans-unit id="334f0f329646de4898c801e89bc81110c62b9723" translate="yes" xml:space="preserve">
          <source>Start the chain of promises with &lt;code&gt;Promise.try&lt;/code&gt;. Any synchronous exceptions will be turned into rejections on the returned promise.</source>
          <target state="translated">从 &lt;code&gt;Promise.try&lt;/code&gt; 开始承诺链。任何同步异常都将变成对返回的诺言的拒绝。</target>
        </trans-unit>
        <trans-unit id="7544908a62ca43e11724d7886c37028c419b528e" translate="yes" xml:space="preserve">
          <source>Starting from 2.7.0 all bluebird instances also fire rejection events globally so that applications can register one universal hook for them.</source>
          <target state="translated">从2.7.0开始,所有的bluebird实例都会在全局范围内触发拒绝事件,这样应用程序就可以为它们注册一个通用钩子。</target>
        </trans-unit>
        <trans-unit id="3603ca6749bcc3136f65ac99d1a525e581f1708b" translate="yes" xml:space="preserve">
          <source>Stream libraries tend to serve a different purpose than promise libraries. Unlike promise libraries streams can represent multiple values.</source>
          <target state="translated">流库的作用往往与承诺库不同。与承诺库不同的是,流可以表示多个值。</target>
        </trans-unit>
        <trans-unit id="9a8475ec2272fa6b1c6b05f2bd678210b89009cf" translate="yes" xml:space="preserve">
          <source>Such a constructor can be minimally created like so:</source>
          <target state="translated">这样的构造函数可以这样最小化创建。</target>
        </trans-unit>
        <trans-unit id="d58681e9c8fb0c509a2cfc71f3a1d6ba692e9b25" translate="yes" xml:space="preserve">
          <source>Such policies could include:</source>
          <target state="translated">这种政策可以包括:</target>
        </trans-unit>
        <trans-unit id="8f1919f0096a6b3087e18c842a5097f047b54d80" translate="yes" xml:space="preserve">
          <source>Such wrappers should be rare, if they're common for the reason that the promise library cannot generically promisify them, you should file an issue.</source>
          <target state="translated">这样的包装器应该很少见,如果因为承诺库不能通用承诺的原因而常见,你应该提交一个问题。</target>
        </trans-unit>
        <trans-unit id="0158596539b88e3d14cfe51fe82aba75fca71681" translate="yes" xml:space="preserve">
          <source>Summary of breaking changes</source>
          <target state="translated">突破性变化摘要</target>
        </trans-unit>
        <trans-unit id="c1e51f0164b5bdc44f9880dc21c2988e1430f473" translate="yes" xml:space="preserve">
          <source>Support primitives in catch filters</source>
          <target state="translated">支持捕获过滤器中的基元</target>
        </trans-unit>
        <trans-unit id="34c6c2ddc426343eed559ce47d4c777df69eba0c" translate="yes" xml:space="preserve">
          <source>Supported platforms</source>
          <target state="translated">支持的平台</target>
        </trans-unit>
        <trans-unit id="f02259e275f481a7fdda40736a24df99f0cd3a67" translate="yes" xml:space="preserve">
          <source>Surfacing unhandled errors</source>
          <target state="translated">浮现未处理的错误</target>
        </trans-unit>
        <trans-unit id="a3f9e4820c3b2f7bbea724b622595d004feda9b4" translate="yes" xml:space="preserve">
          <source>Swallowing all errors (challenge your debugging skills)</source>
          <target state="translated">吞下所有的错误(挑战你的调试技术)。</target>
        </trans-unit>
        <trans-unit id="9d4e83066087dd1079c656c148313dafa0d0a48a" translate="yes" xml:space="preserve">
          <source>Synchronous inspection</source>
          <target state="translated">同步检查</target>
        </trans-unit>
        <trans-unit id="560cd166df807614aa93c9f2544b674451945594" translate="yes" xml:space="preserve">
          <source>Synchronous inspection allows you to retrieve the fulfillment value of an already fulfilled promise or the rejection reason of an already rejected promise synchronously.</source>
          <target state="translated">同步检查可以同步检索已经实现的承诺的实现值或已经拒绝的承诺的拒绝原因。</target>
        </trans-unit>
        <trans-unit id="3f22a0a957f0468c0084e1e9ae07dd450cc45ad2" translate="yes" xml:space="preserve">
          <source>That is, you can return either a promise &lt;em&gt;or a plain value&lt;/em&gt; from a &lt;code&gt;then&lt;/code&gt; without wrapping it.</source>
          <target state="translated">也就是说，您可以从 &lt;code&gt;then&lt;/code&gt; 返回承诺&lt;em&gt;或纯值&lt;/em&gt;，而无需将其包装。</target>
        </trans-unit>
        <trans-unit id="34bb1fab188a923aeae77d6108a07ce0c4ce134b" translate="yes" xml:space="preserve">
          <source>That means &lt;code&gt;value&lt;/code&gt; is bound at the time of calling &lt;a href=&quot;return&quot;&gt;&lt;code&gt;.return&lt;/code&gt;&lt;/a&gt; so this will not work as expected:</source>
          <target state="translated">这意味着在调用&lt;a href=&quot;return&quot;&gt; &lt;code&gt;.return&lt;/code&gt; &lt;/a&gt; &lt;code&gt;value&lt;/code&gt; 是绑定的，因此这将无法按预期工作：</target>
        </trans-unit>
        <trans-unit id="6e5c6863d3d57d6db5e4a2e948905db8b10466ee" translate="yes" xml:space="preserve">
          <source>That means when you have a problem there probably isn't an existing function tailored exactly to that problem but instead you can just combine the existing utilities to arrive at a solution. The upside of this is that you don't need to come up with all these different functions to solve problems that are not that different from each other. The most important thing to do when migrating from async to bluebird is this profound shift in philosophy.</source>
          <target state="translated">这意味着当你遇到一个问题时,可能并没有一个现有的函数完全为这个问题量身定做,而是可以将现有的实用程序结合起来,得出一个解决方案。这样做的好处是,你不需要想出所有这些不同的函数来解决彼此之间没有太大区别的问题。从async迁移到bluebird时,最重要的就是这种理念的深刻转变。</target>
        </trans-unit>
        <trans-unit id="c31fbbf769a579d258b6c345c7359a66afd6aa22" translate="yes" xml:space="preserve">
          <source>That said, if you have code written using jQuery deferred methods, such as &lt;code&gt;.then&lt;/code&gt;, &lt;code&gt;.done&lt;/code&gt; and so on, you cannot drop-in replace the jQuery deferred with a bluebird promise in that code. Despite having the same names, jQuery deferred methods have different semantics than bluebird promise methods. These differences are due to the completely different goals of the implementations. Bluebird is &lt;a href=&quot;http://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;an internal DSL&lt;/a&gt; for the domain of asynchronous control flow while jQuery deferreds are a callback aggregator utility (&quot;glorified event emitters&quot;).</source>
          <target state="translated">就是说，如果您有使用jQuery延迟方法（例如 &lt;code&gt;.then&lt;/code&gt; ， &lt;code&gt;.done&lt;/code&gt; 等）编写的代码，则无法在该代码中直接用bluebird promise替换延迟的jQuery。尽管名称相同，但jQuery延迟方法与Bluebird Promise方法具有不同的语义。这些差异是由于实现的目标完全不同。蓝鸟是异步控制流领域&lt;a href=&quot;http://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;的内部DSL&lt;/a&gt;，而jQuery延迟的是回调聚合器实用程序（&amp;ldquo;事件化的事件发射器&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="9576ae41ed6c2fc691cc3233977df2602674a9e5" translate="yes" xml:space="preserve">
          <source>The &quot;a promise was created in a handler but not returned from it&quot; warning now adds the bluebird API method used to create the non-returned promise at the top of the warning stack</source>
          <target state="translated">&quot;在处理程序中创建了一个承诺但没有返回 &quot;的警告现在在警告堆栈的顶部添加了用于创建未返回承诺的bluebird API方法。</target>
        </trans-unit>
        <trans-unit id="2387bf8a5eec038b8dc1d6a136dd30eb885c69f6" translate="yes" xml:space="preserve">
          <source>The &quot;a promise was created in a handler but not returned from it&quot; warning now highlights the file, line and column where the return statement is missing.</source>
          <target state="translated">&quot;在处理程序中创建了一个承诺,但没有从它那里返回 &quot;的警告现在突出显示了缺少返回语句的文件、行和列。</target>
        </trans-unit>
        <trans-unit id="9172632794382321ca96b52eb375dcf229573bb4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reflect&quot;&gt;&lt;code&gt;.reflect&lt;/code&gt;&lt;/a&gt; method returns a promise that is always successful when this promise is settled. Its fulfillment value is an object that implements the &lt;a href=&quot;promiseinspection&quot;&gt;&lt;code&gt;PromiseInspection&lt;/code&gt;&lt;/a&gt; interface and reflects the resolution of this promise.</source>
          <target state="translated">该&lt;a href=&quot;reflect&quot;&gt; &lt;code&gt;.reflect&lt;/code&gt; &lt;/a&gt;方法返回一个承诺，当这一承诺得到解决，始终是成功的。它的实现值是一个对象，该对象实现&lt;a href=&quot;promiseinspection&quot;&gt; &lt;code&gt;PromiseInspection&lt;/code&gt; &lt;/a&gt;接口并反映此诺言的解决方案。</target>
        </trans-unit>
        <trans-unit id="dcc5097b492ec34ac1dac37541df7fa6d5523657" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.props&lt;/code&gt; method expects to receive an object.</source>
          <target state="translated">该 &lt;code&gt;.props&lt;/code&gt; 方法期望接收的对象。</target>
        </trans-unit>
        <trans-unit id="b0eb698af924dfb32cf54d281b02888c506ead09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.then(success, fail)&lt;/code&gt; anti-pattern</source>
          <target state="translated">的 &lt;code&gt;.then(success, fail)&lt;/code&gt; 反模式</target>
        </trans-unit>
        <trans-unit id="0fcdb3492bd1cc7aa9ff1b548b88ce52afafa5d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.then&lt;/code&gt; signature is mostly about interop, there is &lt;em&gt;almost&lt;/em&gt; never a reason to use &lt;code&gt;.then(success, fail)&lt;/code&gt; in application code. It is even awkward to express it in the sync parallel:</source>
          <target state="translated">的 &lt;code&gt;.then&lt;/code&gt; 签名主要是关于互操作，也&lt;em&gt;几乎&lt;/em&gt;从来没有一个理由来使用 &lt;code&gt;.then(success, fail)&lt;/code&gt; 在应用程序代码。在同步并行中表达它甚至很尴尬：</target>
        </trans-unit>
        <trans-unit id="e944db85ee16051290ad72f2026b7a41fb2a4813" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;map&lt;/code&gt; operation is expecting an array here (or a promise on one) and instead gets the number &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;map&lt;/code&gt; 操作在这里期望的阵列（或许诺上一个），而不是获取数 &lt;code&gt;5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f752091c174b33d9da17500cd7d1d3ae7eb2bd9" translate="yes" xml:space="preserve">
          <source>The Explicit Construction Anti-Pattern</source>
          <target state="translated">明确结构反模式</target>
        </trans-unit>
        <trans-unit id="7ae99b6910e577d7be696210c2dbfc212e81ffa5" translate="yes" xml:space="preserve">
          <source>The JavaScript is the same as the &lt;code&gt;PromptDialog&lt;/code&gt; only we will add a &lt;code&gt;setProgress()&lt;/code&gt; method:</source>
          <target state="translated">JavaScript与 &lt;code&gt;PromptDialog&lt;/code&gt; 相同，只是我们将添加 &lt;code&gt;setProgress()&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="987db8ad0cd3c6e2880ebfda0417324d809a8643" translate="yes" xml:space="preserve">
          <source>The above calls the function &lt;code&gt;processImage()&lt;/code&gt;&lt;em&gt;immediately&lt;/em&gt; and passes the result to &lt;a href=&quot;api/then&quot;&gt;&lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; (which is most likely &lt;code&gt;undefined&lt;/code&gt; - the default return value when a function doesn't return anything).</source>
          <target state="translated">上面的代码&lt;em&gt;立即&lt;/em&gt;调用了 &lt;code&gt;processImage()&lt;/code&gt; 函数，并将结果传递给&lt;a href=&quot;api/then&quot;&gt; &lt;code&gt;.then()&lt;/code&gt; &lt;/a&gt;（这很可能是 &lt;code&gt;undefined&lt;/code&gt; -函数不返回任何内容时的默认返回值）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1c5b45d618d205b79bdd2339e1eb511e0597ceee" translate="yes" xml:space="preserve">
          <source>The above can also be written as (with a caveat, see below)</source>
          <target state="translated">上述内容也可以写成(有一点要注意,见下文)</target>
        </trans-unit>
        <trans-unit id="b9d96d94c20e29d7be811aad09d5f2fc69d847ac" translate="yes" xml:space="preserve">
          <source>The above does a &lt;code&gt;console.log&lt;/code&gt; of &lt;code&gt;my-element&lt;/code&gt;. Doing it this way is necessary because neither of the methods (&lt;code&gt;getElementById&lt;/code&gt;, &lt;code&gt;console.log&lt;/code&gt;) can be called as stand-alone methods.</source>
          <target state="translated">以上做了 &lt;code&gt;console.log&lt;/code&gt; 的 &lt;code&gt;my-element&lt;/code&gt; 。这样做是必要的，因为这两个方法（ &lt;code&gt;getElementById&lt;/code&gt; ， &lt;code&gt;console.log&lt;/code&gt; ）都不能称为独立方法。</target>
        </trans-unit>
        <trans-unit id="4ff51746636ecc3655cfcaa3b14edb8e79b82038" translate="yes" xml:space="preserve">
          <source>The above ensures &lt;code&gt;getConnection&lt;/code&gt; fulfills the contract of a promise-returning function of never throwing a synchronous exception. Also see &lt;a href=&quot;promise.try&quot;&gt;&lt;code&gt;Promise.try&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;promise.method&quot;&gt;&lt;code&gt;Promise.method&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">上面的方法确保 &lt;code&gt;getConnection&lt;/code&gt; 履行从不抛出同步异常的承诺返回函数的约定。另请参阅&lt;a href=&quot;promise.try&quot;&gt; &lt;code&gt;Promise.try&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;promise.method&quot;&gt; &lt;code&gt;Promise.method&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec563887821c925f0b9a15bbaeb4d94ba4967bb9" translate="yes" xml:space="preserve">
          <source>The above function can then make everyone happy.</source>
          <target state="translated">以上功能就可以让大家开心了。</target>
        </trans-unit>
        <trans-unit id="cb5a0fcd51c35945773869b7451e685e33fe2b5b" translate="yes" xml:space="preserve">
          <source>The above has a direct translation:</source>
          <target state="translated">以上有直译。</target>
        </trans-unit>
        <trans-unit id="be3a5d7ac08554519f84fa1292d020a1294faf0a" translate="yes" xml:space="preserve">
          <source>The above without &lt;a href=&quot;bind&quot;&gt;&lt;code&gt;.bind&lt;/code&gt;&lt;/a&gt; could be achieved with:</source>
          <target state="translated">上面没有&lt;a href=&quot;bind&quot;&gt; &lt;code&gt;.bind&lt;/code&gt; 的&lt;/a&gt;可以通过以下方式实现：</target>
        </trans-unit>
        <trans-unit id="a6770726e6458fe58ea6b5f4fd62bd9042424df5" translate="yes" xml:space="preserve">
          <source>The actual subscription API depends on the environment.</source>
          <target state="translated">实际的订阅API取决于环境。</target>
        </trans-unit>
        <trans-unit id="f16cc25950a83115317503e4adef79079d08a456" translate="yes" xml:space="preserve">
          <source>The advantage of using &lt;code&gt;.suppressUnhandledRejections()&lt;/code&gt; over &lt;code&gt;.catch(function(){})&lt;/code&gt; is that it doesn't increment the branch count of the promise. Branch counts matter when using cancellation because a promise will only be cancelled if all of its branches want to cancel it.</source>
          <target state="translated">与 &lt;code&gt;.catch(function(){})&lt;/code&gt; 相比，使用 &lt;code&gt;.suppressUnhandledRejections()&lt;/code&gt; 的优势在于，它不会增加promise的分支计数。使用取消时，分支计数很重要，因为仅当其所有分支都希望取消承诺时，才会取消承诺。</target>
        </trans-unit>
        <trans-unit id="9c56f54fb10413e626d1f27ae289fc09dbb6d933" translate="yes" xml:space="preserve">
          <source>The advantages of the new cancellation compared to the old cancellation are:</source>
          <target state="translated">与旧注销相比,新注销的优势在于:1.</target>
        </trans-unit>
        <trans-unit id="f38af64a279ce9559ab9430fe352d1985725b5b6" translate="yes" xml:space="preserve">
          <source>The cancellation feature is &lt;strong&gt;by default turned off&lt;/strong&gt;, you can enable it using &lt;a href=&quot;promise.config&quot;&gt;&lt;code&gt;Promise.config&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">取消功能&lt;strong&gt;默认情况下处于关闭状态&lt;/strong&gt;，您可以使用&lt;a href=&quot;promise.config&quot;&gt; &lt;code&gt;Promise.config&lt;/code&gt; &lt;/a&gt;启用它。</target>
        </trans-unit>
        <trans-unit id="6200a8a72cc85fe3cd189630a2f941b849b20c71" translate="yes" xml:space="preserve">
          <source>The concurrency limit applies to Promises returned by the mapper function and it basically limits the number of Promises created. For example, if &lt;code&gt;concurrency&lt;/code&gt; is &lt;code&gt;3&lt;/code&gt; and the mapper callback has been called enough so that there are three returned Promises currently pending, no further callbacks are called until one of the pending Promises resolves. So the mapper function will be called three times and it will be called again only after at least one of the Promises resolves.</source>
          <target state="translated">并发限制适用于mapper函数返回的Promises，它基本上限制了创建的Promises的数量。例如，如果 &lt;code&gt;concurrency&lt;/code&gt; 为 &lt;code&gt;3&lt;/code&gt; ,并且已足够调用mapper回调，以便当前有三个返回的Promises处于未决状态，则在未决的Promises之一解决之前，不会再调用任何回调。因此，映射器函数将被调用三次，并且只有在至少一个Promises解析之后，才会再次调用它。</target>
        </trans-unit>
        <trans-unit id="a9dfc798d7155c42f102e1690ecdc5d11f1eed13" translate="yes" xml:space="preserve">
          <source>The current element of the iteration is a &lt;em&gt;pending&lt;/em&gt; promise, that promise will be awaited before running the iterator.</source>
          <target state="translated">迭代的当前元素是一个&lt;em&gt;待处理的&lt;/em&gt;promise，该promise将在运行迭代器之前等待。</target>
        </trans-unit>
        <trans-unit id="e4676232a799b417212732864ed73ce3337f094d" translate="yes" xml:space="preserve">
          <source>The current element of the iteration is a &lt;em&gt;pending&lt;/em&gt; promise, that promise will be awaited before running the mapper.</source>
          <target state="translated">迭代的当前元素是一个&lt;em&gt;悬而未决&lt;/em&gt;的承诺，这一承诺将在运行映射之前等待。</target>
        </trans-unit>
        <trans-unit id="7901af52e1d3bb0c5159bcb56902f980986ef864" translate="yes" xml:space="preserve">
          <source>The current element of the iteration is a &lt;em&gt;rejected&lt;/em&gt; promise, the iteration will stop and be rejected as well (with the same reason).</source>
          <target state="translated">迭代的当前元素是&lt;em&gt;被拒绝的&lt;/em&gt;承诺，迭代也将停止并被拒绝（原因相同）。</target>
        </trans-unit>
        <trans-unit id="31ab830fa32b91594137493c8717fb7b7a2afbf7" translate="yes" xml:space="preserve">
          <source>The default approach of bluebird is to immediately log the stack trace when there is an unhandled rejection. This is similar to how uncaught exceptions cause the stack trace to be logged so that you have something to work with when something is not working as expected.</source>
          <target state="translated">bluebird的默认做法是,当出现未处理的拒绝时,立即记录堆栈跟踪。这与未捕获的异常会导致堆栈跟踪被记录的情况类似,这样当出现异常时,你就有了可以利用的东西。</target>
        </trans-unit>
        <trans-unit id="79301b912f99cabfc6b1d506271ff79825a49941" translate="yes" xml:space="preserve">
          <source>The default filter function will ignore properties that start with a leading underscore, properties that are not valid JavaScript identifiers and constructor functions (function which have enumerable properties in their &lt;code&gt;.prototype&lt;/code&gt;).</source>
          <target state="translated">默认的过滤器函数将忽略以下划线开头的属性，无效的JavaScript标识符和构造函数（在 &lt;code&gt;.prototype&lt;/code&gt; 中具有可枚举属性的函数）。</target>
        </trans-unit>
        <trans-unit id="fb7c7d829660ad1b607e4ff44a0e6cb994eacdf1" translate="yes" xml:space="preserve">
          <source>The dialog interface might look like this:</source>
          <target state="translated">对话界面可能是这样的。</target>
        </trans-unit>
        <trans-unit id="2ec7326b7197ff7aa9ec6904e534048cbee04708" translate="yes" xml:space="preserve">
          <source>The difference between a &lt;code&gt;Task&lt;/code&gt; and a promise are that a task might not be started and might require a &lt;code&gt;.Start&lt;/code&gt; call where a promise always represents an already started operation.</source>
          <target state="translated">&lt;code&gt;Task&lt;/code&gt; 和Promise 之间的区别在于，可能不会启动任务，并且可能需要 &lt;code&gt;.Start&lt;/code&gt; 调用，其中Promise始终表示已经开始的操作。</target>
        </trans-unit>
        <trans-unit id="801933290ac764cce3fee90e0b881f138a330a0e" translate="yes" xml:space="preserve">
          <source>The entire prototype chain of the object is promisified on the object. Only enumerable are considered. If the object already has a promisified version of the method, it will be skipped. The target methods are assumed to conform to node.js callback convention of accepting a callback as last argument and calling that callback with error as the first argument and success value on the second argument. If the node method calls its callback with multiple success values, the fulfillment value will be an array of them.</source>
          <target state="translated">对象的整个原型链在对象上被承诺。只有枚举式才会被考虑。如果对象已经有了方法的承诺版本,那么它将被跳过。目标方法被认为符合node.js的回调约定,即接受一个回调作为最后一个参数,并以错误作为第一个参数,以成功值作为第二个参数来调用该回调。如果节点方法调用其回调时有多个成功值,那么履行值将是它们的一个数组。</target>
        </trans-unit>
        <trans-unit id="d6be4df893a1137d6b3ab84348ff99be431c883e" translate="yes" xml:space="preserve">
          <source>The explicit construction anti-pattern</source>
          <target state="translated">显性结构反模式</target>
        </trans-unit>
        <trans-unit id="40e45891046aa649e068bb199da2efeaca661dda" translate="yes" xml:space="preserve">
          <source>The following lifecycle events are available:</source>
          <target state="translated">以下是可用的生命周期事件。</target>
        </trans-unit>
        <trans-unit id="b55e86c0fc753c356970890234eaa0b0ce6daee6" translate="yes" xml:space="preserve">
          <source>The function being called expects a Promise, but is given something different. There are two main reasons why this may occur.</source>
          <target state="translated">被调用的函数期望得到一个Promise,但得到的却是不同的东西。出现这种情况主要有两个原因。</target>
        </trans-unit>
        <trans-unit id="0fa7caae49fcd453bbf69746e24b32d9fbb6ba35" translate="yes" xml:space="preserve">
          <source>The generic promisification is likely to be faster because it can use internals directly but also handles edge cases like &lt;code&gt;libraryFunction&lt;/code&gt; throwing synchronously or using multiple success values.</source>
          <target state="translated">通用承诺可能会更快，因为它可以直接使用内部函数，而且还可以处理诸如 &lt;code&gt;libraryFunction&lt;/code&gt; 同步抛出或使用多个成功值之类的极端情况。</target>
        </trans-unit>
        <trans-unit id="7b2748080c6d9715db0ad2710e45478c0f7c5d34" translate="yes" xml:space="preserve">
          <source>The global events are:</source>
          <target state="translated">全球性事件是:</target>
        </trans-unit>
        <trans-unit id="ac6f6a9e8f68d43e290c78abcefdf4dfcc31bc80" translate="yes" xml:space="preserve">
          <source>The handler functions are now closures, thus less efficient and not reusable</source>
          <target state="translated">处理函数现在是闭包,因此效率较低,不可重用。</target>
        </trans-unit>
        <trans-unit id="578ba1114aa6fcded1f091d1702ddf63eaf4722c" translate="yes" xml:space="preserve">
          <source>The implementations for this benchmark are found in &lt;a href=&quot;https://github.com/petkaantonov/bluebird/tree/master/benchmark/doxbee-sequential&quot;&gt;&lt;code&gt;benchmark/doxbee-sequential&lt;/code&gt;&lt;/a&gt; directory.</source>
          <target state="translated">可在&lt;a href=&quot;https://github.com/petkaantonov/bluebird/tree/master/benchmark/doxbee-sequential&quot;&gt; &lt;code&gt;benchmark/doxbee-sequential&lt;/code&gt; &lt;/a&gt;目录中找到此基准的实现。</target>
        </trans-unit>
        <trans-unit id="2beec3e3018a687405477c67e8972c8a6a40dae3" translate="yes" xml:space="preserve">
          <source>The implementations for this benchmark are found in &lt;a href=&quot;https://github.com/petkaantonov/bluebird/tree/master/benchmark/madeup-parallel&quot;&gt;&lt;code&gt;benchmark/madeup-parallel&lt;/code&gt;&lt;/a&gt; directory.</source>
          <target state="translated">在&lt;a href=&quot;https://github.com/petkaantonov/bluebird/tree/master/benchmark/madeup-parallel&quot;&gt; &lt;code&gt;benchmark/madeup-parallel&lt;/code&gt; &lt;/a&gt;目录中找到此基准的实现。</target>
        </trans-unit>
        <trans-unit id="5ab9ea41bf2d998f0ea876fa3d95827572dbbe3d" translate="yes" xml:space="preserve">
          <source>The iterator returns a promise or a thenable, it is awaited before continuing to the next iteration.</source>
          <target state="translated">迭代器返回一个promise或thenable,在继续下一次迭代之前,它是等待的。</target>
        </trans-unit>
        <trans-unit id="9448500cacb1ff64a30efd5b0e2bea57a588d796" translate="yes" xml:space="preserve">
          <source>The mapper function for a given item is called as soon as possible, that is, when the promise for that item's index in the input array is fulfilled. This doesn't mean that the result array has items in random order, it means that &lt;code&gt;.map&lt;/code&gt; can be used for concurrency coordination unlike &lt;code&gt;.all&lt;/code&gt;.</source>
          <target state="translated">给定项目的映射器函数会尽快调用，也就是说，当满足输入数组中该项目的索引的诺言时。这并不意味着结果数组具有随机顺序的项，这意味着 &lt;code&gt;.map&lt;/code&gt; 可以与 &lt;code&gt;.all&lt;/code&gt; 不同，可用于并发协调。</target>
        </trans-unit>
        <trans-unit id="575b00766f4d58c35e179c44f5a23cda579eb7ad" translate="yes" xml:space="preserve">
          <source>The mapper returns a promise or a thenable, it is awaited before continuing to the next iteration.</source>
          <target state="translated">映射器返回一个承诺或一个thenable,在继续下一次迭代之前,它会被等待。</target>
        </trans-unit>
        <trans-unit id="6416948697e16aeabbf92ec68782960804a2782d" translate="yes" xml:space="preserve">
          <source>The methods of a &lt;code&gt;PromiseResolver&lt;/code&gt; have no effect if the fate of the underlying promise is already decided (follow, reject, fulfill).</source>
          <target state="translated">如果潜在承诺的命运已经确定（跟随，拒绝，履行），则 &lt;code&gt;PromiseResolver&lt;/code&gt; 的方法将无效。</target>
        </trans-unit>
        <trans-unit id="666da53e9ba5fafe397413f91312c555ed1b2845" translate="yes" xml:space="preserve">
          <source>The mortals that can handle it may now release Zalgo by &lt;code&gt;require(&quot;bluebird/zalgo&quot;);&lt;/code&gt;</source>
          <target state="translated">现在可以处理它的凡人可以通过 &lt;code&gt;require(&quot;bluebird/zalgo&quot;);&lt;/code&gt; 释放Zalgo ；</target>
        </trans-unit>
        <trans-unit id="788c3f097a42e7ff06bdab38fdaf7df400494dfe" translate="yes" xml:space="preserve">
          <source>The new cancellation has &quot;don't care&quot; semantics while the old cancellation had abort semantics. Cancelling a promise simply means that its handler callbacks will not be called.</source>
          <target state="translated">新的取消具有 &quot;不在乎 &quot;的语义,而旧的取消具有中止的语义。取消一个承诺只是意味着它的处理程序回调将不会被调用。</target>
        </trans-unit>
        <trans-unit id="9a98aedc50b84c7ebb0badc2de651f3ecf8937b9" translate="yes" xml:space="preserve">
          <source>The object predicate passed to &lt;code&gt;.catch&lt;/code&gt; in the above code (&lt;code&gt;{code: 'ENOENT'}&lt;/code&gt;) is shorthand for a predicate function &lt;code&gt;function predicate(e) { return isObject(e) &amp;amp;&amp;amp; e.code == 'ENOENT' }&lt;/code&gt;, I.E. loose equality is used.</source>
          <target state="translated">上面的代码（ &lt;code&gt;{code: 'ENOENT'}&lt;/code&gt; ）中传递给 &lt;code&gt;.catch&lt;/code&gt; 的对象谓词是谓词函数 &lt;code&gt;function predicate(e) { return isObject(e) &amp;amp;&amp;amp; e.code == 'ENOENT' }&lt;/code&gt; ，即IE松散使用平等。</target>
        </trans-unit>
        <trans-unit id="25c421b7ad33c6aa4c4ac1a5b06c22ec76d37875" translate="yes" xml:space="preserve">
          <source>The old progression API was meant to be used for tracking the progress of promise resolution. In retrospect, it did not work or compose very well. We understand that problem better now and the use case could be better solved without it.</source>
          <target state="translated">旧的进展API是用来跟踪承诺解决的进度。回过头来看,它并没有很好地工作或编译。我们现在更好地理解了这个问题,没有它的用例可以更好地解决。</target>
        </trans-unit>
        <trans-unit id="090f1f6fbdfbd7a3e0db64396e47bb24d64eb73a" translate="yes" xml:space="preserve">
          <source>The order &lt;code&gt;map&lt;/code&gt; calls the mapper function on the array elements is not specified, there is no guarantee on the order in which it'll execute the &lt;code&gt;map&lt;/code&gt;er on the elements. For order guarantee in sequential execution - see &lt;a href=&quot;promise.mapseries&quot;&gt;&lt;code&gt;Promise.mapSeries&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">未指定在数组元素 &lt;code&gt;map&lt;/code&gt; 调用mapper函数的顺序映射，无法保证它将在元素上执行 &lt;code&gt;map&lt;/code&gt; 的顺序。有关顺序执行中的顺序保证，请参见&lt;a href=&quot;promise.mapseries&quot;&gt; &lt;code&gt;Promise.mapSeries&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22323bb03a1bb54a462c5535aaf1a55e597ca564" translate="yes" xml:space="preserve">
          <source>The problem with the above is that &lt;code&gt;getConnection&lt;/code&gt; itself might throw for some reason and if it does we'll get a synchronous rejection. An asynchronous operation should always be asynchronous to prevent double guarding and race conditions so it's best to always put the sync parts inside the promise constructor as such:</source>
          <target state="translated">上面的问题是 &lt;code&gt;getConnection&lt;/code&gt; 本身可能出于某种原因抛出，如果这样做，我们将得到一个同步拒绝。异步操作应始终是异步的，以防止出现双重保护和竞态条件，因此最好始终将同步部分放置在promise构造函数中，如下所示：</target>
        </trans-unit>
        <trans-unit id="5b81307bb00a714d49523b7e191e0b6160f8ce58" translate="yes" xml:space="preserve">
          <source>The promisifier gets a reference to the original method and should return a function which returns a promise.</source>
          <target state="translated">承诺者得到对原始方法的引用,应该返回一个返回承诺的函数。</target>
        </trans-unit>
        <trans-unit id="1a87fc5ef703ad3003e186be301223055a0f1187" translate="yes" xml:space="preserve">
          <source>The resolver function is passed a callback that expects to be called back according to error-first node conventions.</source>
          <target state="translated">解析器函数被传递了一个回调,期望按照错误优先的节点约定被回调。</target>
        </trans-unit>
        <trans-unit id="db5aac58e5c09043c491849101f61a81a5b4d12d" translate="yes" xml:space="preserve">
          <source>The resolver is called synchronously (the following is for documentation purposes and not idiomatic code):</source>
          <target state="translated">解析器会被同步调用(以下为文档目的,不是习惯性代码)。</target>
        </trans-unit>
        <trans-unit id="fa4bfc9835f1db3d068610dc3f23387d9b6dbcae" translate="yes" xml:space="preserve">
          <source>The same can also be written more concisely with &lt;code&gt;Function.prototype.bind&lt;/code&gt;:</source>
          <target state="translated">也可以使用 &lt;code&gt;Function.prototype.bind&lt;/code&gt; 更简洁地编写相同的代码：</target>
        </trans-unit>
        <trans-unit id="e4d032a40184c01ff45a4fcd6a47f5f6ed12cc2d" translate="yes" xml:space="preserve">
          <source>The same thing can be done with less code using jQuery's &lt;a href=&quot;https://api.jquery.com/on/#event-names&quot;&gt;event namespacing&lt;/a&gt;.</source>
          <target state="translated">使用jQuery的&lt;a href=&quot;https://api.jquery.com/on/#event-names&quot;&gt;事件namepacing&lt;/a&gt;可以用更少的代码完成同一件事。</target>
        </trans-unit>
        <trans-unit id="3c2a20abb7e468fc73f206d7f17b3365726ea73c" translate="yes" xml:space="preserve">
          <source>The second argument passed to a disposer is the result promise of the using block, which you can inspect synchronously.</source>
          <target state="translated">传递给处置器的第二个参数是使用块的结果答应,你可以同步视察。</target>
        </trans-unit>
        <trans-unit id="7e1062ee61728ebe80f9bce80f90c97c30f5a642" translate="yes" xml:space="preserve">
          <source>The situation can be fixed with &lt;code&gt;.finally&lt;/code&gt;:</source>
          <target state="translated">这种情况可以用 &lt;code&gt;.finally&lt;/code&gt; 解决：</target>
        </trans-unit>
        <trans-unit id="d8cfd5d14e8e321897ce3ab8e2b61c1f01768a60" translate="yes" xml:space="preserve">
          <source>The solution is to either convert it to a promise by calling &lt;code&gt;Promise.resolve&lt;/code&gt; on it or &lt;code&gt;Promise.promisify&lt;/code&gt; if it's a callback:</source>
          <target state="translated">解决方案是通过调用 &lt;code&gt;Promise.resolve&lt;/code&gt; 或 &lt;code&gt;Promise.promisify&lt;/code&gt; (如果是回调）将其转换为Promise：</target>
        </trans-unit>
        <trans-unit id="a959d4cee575b4382df36392cd8df64e24184dbc" translate="yes" xml:space="preserve">
          <source>The stack trace for &lt;a href=&quot;warning-explanations#warning-a-promise-was-created-in-a-handler-but-none-were-returned-from-it&quot;&gt;forgotten return warnings&lt;/a&gt; is more useful now.</source>
          <target state="translated">现在，用于&lt;a href=&quot;warning-explanations#warning-a-promise-was-created-in-a-handler-but-none-were-returned-from-it&quot;&gt;忘记返回警告&lt;/a&gt;的堆栈跟踪更加有用。</target>
        </trans-unit>
        <trans-unit id="b7cfeae4442044317b39c717825ad07af88a84b2" translate="yes" xml:space="preserve">
          <source>The standard &lt;a href=&quot;http://promises-aplus.github.io/promises-spec/&quot;&gt;Promises/A+ &lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; is still supported by Bluebird and support for it will continue indefinitely . However, the variant accepting a third &lt;code&gt;progressHandler&lt;/code&gt; argument is no longer supported.</source>
          <target state="translated">Bluebird仍支持标准&lt;a href=&quot;http://promises-aplus.github.io/promises-spec/&quot;&gt;Promises / A + &lt;code&gt;.then()&lt;/code&gt; &lt;/a&gt;，并且它将无限期地支持它。但是，不再支持接受第三个 &lt;code&gt;progressHandler&lt;/code&gt; 参数的变量。</target>
        </trans-unit>
        <trans-unit id="0578afb0e805324fd3d6ef6661225daacb79ec32" translate="yes" xml:space="preserve">
          <source>The suffix must be a valid JavaScript identifier using ASCII letters</source>
          <target state="translated">后缀必须是一个有效的JavaScript标识符,使用ASCII字母。</target>
        </trans-unit>
        <trans-unit id="51e5ddd442738d3ba0fcf36bd1580ce1e7b6558a" translate="yes" xml:space="preserve">
          <source>The usage pattern is similar to the PostgreSQL example above. You can also use a disposer pattern (but not an actual .disposer). See the PostgreSQL example above for instructions.</source>
          <target state="translated">使用模式与上面PostgreSQL的例子类似。你也可以使用disposer模式(但不是实际的.disposer)。请参阅上面PostgreSQL的例子以获得说明。</target>
        </trans-unit>
        <trans-unit id="28bb7fa145553052b5508efe6d9bb705def39d86" translate="yes" xml:space="preserve">
          <source>The usual way to use promises in node is to &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; some API and start exclusively calling promise returning versions of the APIs methods. E.g.</source>
          <target state="translated">在节点中使用promise的通常方法是&lt;a href=&quot;api/promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt;一些API并开始专门调用API方法的promise返回版本。例如</target>
        </trans-unit>
        <trans-unit id="9d0826c3236c309fa1a8bb247d52444104239f26" translate="yes" xml:space="preserve">
          <source>The usual way to use promises in node is to &lt;a href=&quot;promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; some API and start exclusively calling promise returning versions of the APIs methods. E.g.</source>
          <target state="translated">在节点中使用promise的通常方法是&lt;a href=&quot;promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt;一些API并开始专门调用API方法的promise返回版本。例如</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="fdf91bb0325fcdd18970709eb26b34f64a3672d1" translate="yes" xml:space="preserve">
          <source>There are many third party promise libraries available for JavaScript and even the standard library contains a promise implementation in newer versions of browsers and node/io.js. This page will explore why one might use bluebird promises over other third party or the standard library implementations. For reasons to use promises in general, see the &lt;a href=&quot;why-promises&quot;&gt;Why Promises?&lt;/a&gt; article.</source>
          <target state="translated">有许多可用于JavaScript的第三方诺言库，甚至标准库都包含在较新版本的浏览器和node / io.js中的诺言实现。该页面将探讨为什么人们可能会在其他第三方或标准库实现中使用蓝鸟承诺。有关一般使用承诺的原因，请参阅&amp;ldquo;&lt;a href=&quot;why-promises&quot;&gt;为什么要承诺？&amp;rdquo; &lt;/a&gt;文章。</target>
        </trans-unit>
        <trans-unit id="12dfbb41929f3ee02dc34311b3347fac9dec5515" translate="yes" xml:space="preserve">
          <source>There are many third party promise libraries available for JavaScript and even the standard library contains a promise implementation in newer versions of browsers and node/io.js. This page will explore why one might use bluebird promises over other third party or the standard library implementations. For reasons why to use promises in general, see the &lt;a href=&quot;why-promises&quot;&gt;Why Promises?&lt;/a&gt; article.</source>
          <target state="translated">有许多可用于JavaScript的第三方诺言库，甚至标准库都包含在较新版本的浏览器和node / io.js中的诺言实现。该页面将探讨为什么人们可能会在其他第三方或标准库实现中使用蓝鸟承诺。出于一般为何使用承诺的原因，请参阅&amp;ldquo; &lt;a href=&quot;why-promises&quot;&gt;为什么要承诺&amp;rdquo;？&lt;/a&gt;文章。</target>
        </trans-unit>
        <trans-unit id="0016f6e7c65d90d1ef2d07a4adbd7695a74d6216" translate="yes" xml:space="preserve">
          <source>There are many ways to use bluebird in browsers:</source>
          <target state="translated">在浏览器中使用bluebird的方法有很多。</target>
        </trans-unit>
        <trans-unit id="acfa8f7a74926d5b3e71d319fe2e3737e67b4a45" translate="yes" xml:space="preserve">
          <source>There are still a few problems with the earlier code example. It feels like it is doing too much. A &lt;em&gt;squint&lt;/em&gt; test reveals behavior for showing the dialog, set the dialog's message, attach two DOM events, construct a promise, event delegation, hide the dialog, and finally detach DOM events. That is a lot for one little function. A refactoring can help.</source>
          <target state="translated">较早的代码示例仍然存在一些问题。感觉好像做得太多了。一&lt;em&gt;眯&lt;/em&gt;试验表明行为显示对话框，设置对话框中的消息，连接两个DOM事件，构建一个承诺，事件代理，隐藏对话框，最后分离DOM事件。一个小功能有很多。重构可以提供帮助。</target>
        </trans-unit>
        <trans-unit id="c2d9fdb7b10a480524179ca553be134c2cab93bd" translate="yes" xml:space="preserve">
          <source>There are two primary methods of converting callback based APIs into promise based ones. You can either manually map the API calls to promise returning functions or you can let the bluebird do it for you. We &lt;strong&gt;strongly&lt;/strong&gt; recommend the latter.</source>
          <target state="translated">有两种将基于回调的API转换为基于Promise的API的主要方法。您可以手动将API调用映射为承诺返回函数，也可以让bluebird为您完成。我们&lt;strong&gt;强烈&lt;/strong&gt;建议您使用后者。</target>
        </trans-unit>
        <trans-unit id="f594978f8f4cce365338daa917338cba030de34d" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;http://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;this more general StackOverflow question&lt;/a&gt; about conversion of callback APIs to promises. If you find anything missing in this guide however, please do open an issue or pull request.</source>
          <target state="translated">还有&lt;a href=&quot;http://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;一个&lt;/a&gt;关于将回调API转换为Promise的更一般的StackOverflow问题。但是，如果您发现本指南中缺少任何内容，请提出问题或提出要求。</target>
        </trans-unit>
        <trans-unit id="82ffbfbc41fe53312b41cce044330748666500e8" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;https://www.promisejs.org/generators/&quot;&gt;excellent article&lt;/a&gt; on promisejs.org detailing how to combine promises with generators to achieve much cleaner code. Instead of the &lt;code&gt;async&lt;/code&gt; function the article proposes, you can use &lt;a href=&quot;api/promise.coroutine&quot;&gt;&lt;code&gt;Promise.coroutine&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在promisejs.org上有一篇&lt;a href=&quot;https://www.promisejs.org/generators/&quot;&gt;很棒的文章&lt;/a&gt;，详细介绍了如何将promise与生成器结合以实现更简洁的代码。可以使用&lt;a href=&quot;api/promise.coroutine&quot;&gt; &lt;code&gt;Promise.coroutine&lt;/code&gt; &lt;/a&gt;代替本文提出的 &lt;code&gt;async&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="ccd6b50860623f70756069f499d23f01b6d13e5c" translate="yes" xml:space="preserve">
          <source>There is no effect on performance if the user doesn't actually pass a node-style callback function.</source>
          <target state="translated">如果用户没有真正传递一个节点式的回调函数,对性能没有影响。</target>
        </trans-unit>
        <trans-unit id="a899a39eea077d35fbd555f33e92cdecfa97e0f3" translate="yes" xml:space="preserve">
          <source>There is no need to convert timeouts/delays to a bluebird API, bluebird already ships with the &lt;a href=&quot;api/promise.delay&quot;&gt;&lt;code&gt;Promise.delay&lt;/code&gt;&lt;/a&gt; function for this use case. Please consult the &lt;a href=&quot;api/timers&quot;&gt;&lt;code&gt;timers&lt;/code&gt;&lt;/a&gt; section of the docs on usage and examples.</source>
          <target state="translated">无需将超时/延迟转换为bluebird API，bluebird已在该用例中&lt;a href=&quot;api/promise.delay&quot;&gt; &lt;code&gt;Promise.delay&lt;/code&gt; &lt;/a&gt;函数。请参考文档的&lt;a href=&quot;api/timers&quot;&gt; &lt;code&gt;timers&lt;/code&gt; &lt;/a&gt;部分，了解用法和示例。</target>
        </trans-unit>
        <trans-unit id="816256e371a68e0a4e42cc5d7e31e59e968b1550" translate="yes" xml:space="preserve">
          <source>This APIs are what most core modules in Node/io use and bluebird comes with a fast and efficient way to convert them to promise based APIs through the &lt;code&gt;Promise.promisify&lt;/code&gt; and &lt;code&gt;Promise.promisifyAll&lt;/code&gt; function calls.</source>
          <target state="translated">这些API是Node / io中大多数核心模块使用的，bluebird带有快速有效的方法，可通过 &lt;code&gt;Promise.promisify&lt;/code&gt; 和 &lt;code&gt;Promise.promisifyAll&lt;/code&gt; 函数调用将其转换为基于Promise的API 。</target>
        </trans-unit>
        <trans-unit id="3d88bc0890f9955d9aafd69e5e422f7404df8670" translate="yes" xml:space="preserve">
          <source>This abstraction can be expanded on in other ways. For example a notification dialog:</source>
          <target state="translated">这个抽象可以用其他方式来扩展。例如一个通知对话框。</target>
        </trans-unit>
        <trans-unit id="4ef92d2a854bbe01523868d53a897ee9b600001a" translate="yes" xml:space="preserve">
          <source>This also happens when implementing live-updating models with a &lt;code&gt;.then&lt;/code&gt; method that indicates when the model is &quot;ready&quot;. A promise is a process, it starts and it ends.</source>
          <target state="translated">当使用 &lt;code&gt;.then&lt;/code&gt; 方法实现实时更新模型时，也会发生这种情况，该方法指示模型何时&amp;ldquo;就绪&amp;rdquo;。一个承诺是一个过程，它开始并结束。</target>
        </trans-unit>
        <trans-unit id="1d9ddcdc77c9d4a96e7a508b17988600ecaa73fc" translate="yes" xml:space="preserve">
          <source>This also means that disposers should not contain code that does anything other than resource disposal. For example, you cannot write code inside a disposer to commit or rollback a transaction, because there is no mechanism for the disposer to signal a failure of the commit or rollback action without crashing the process.</source>
          <target state="translated">这也意味着处置器中不应该包含除资源处置以外的任何代码。例如,你不能在处置器中写代码来提交或回滚一个事务,因为没有机制让处置器在提交或回滚操作失败时发出信号而不使进程崩溃。</target>
        </trans-unit>
        <trans-unit id="66b2c8b4731b0f7ba7e6bf98e67448082824c523" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/api/promise.each.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">本文未完成或部分未完成。欢迎您创建&lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/api/promise.each.md&quot;&gt;拉取请求&lt;/a&gt;以帮助完成本文。</target>
        </trans-unit>
        <trans-unit id="9b70a0a7654e551108da4764c9f005aab32644aa" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/async-dialogs.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">本文未完成或部分未完成。欢迎您创建&lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/async-dialogs.md&quot;&gt;拉取请求&lt;/a&gt;以帮助完成本文。</target>
        </trans-unit>
        <trans-unit id="e1c525d7a299f5e8e85d4de9a717c3aacb38e9c7" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/beginners-guide.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">本文未完成或部分未完成。欢迎您创建&lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/beginners-guide.md&quot;&gt;拉取请求&lt;/a&gt;以帮助完成本文。</target>
        </trans-unit>
        <trans-unit id="c52f9c032871178393d4fecda1b976e39b1a06b1" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/deprecated-apis.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">本文未完成或部分未完成。欢迎您创建&lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/deprecated-apis.md&quot;&gt;拉取请求&lt;/a&gt;以帮助完成本文。</target>
        </trans-unit>
        <trans-unit id="b6f8fae1cd767c72257bf951d6fae38ca4750167" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/features.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">本文未完成或部分未完成。欢迎您创建&lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/features.md&quot;&gt;拉取请求&lt;/a&gt;以帮助完成本文。</target>
        </trans-unit>
        <trans-unit id="0b80a141eb9286b1bcd67d018003d3e43d4ca6b1" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/getting-started.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">本文未完成或部分未完成。欢迎您创建&lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/getting-started.md&quot;&gt;拉取请求&lt;/a&gt;以帮助完成本文。</target>
        </trans-unit>
        <trans-unit id="c9d9ce5a1a1cedf3cd3c1bf2b642c4920ce3d476" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/warning-explanations.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">本文未完成或部分未完成。欢迎您创建&lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/warning-explanations.md&quot;&gt;拉取请求&lt;/a&gt;以帮助完成本文。</target>
        </trans-unit>
        <trans-unit id="01153e43a1c1cb6db13e7e38cfc4a7ca277baf87" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/what-about-generators.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">本文未完成或部分未完成。欢迎您创建&lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/what-about-generators.md&quot;&gt;拉取请求&lt;/a&gt;以帮助完成本文。</target>
        </trans-unit>
        <trans-unit id="3b2b6fdf4dc9492f2c92f1362815d504f5b44c1e" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/why-performance.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">本文未完成或部分未完成。欢迎您创建&lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/why-performance.md&quot;&gt;拉取请求&lt;/a&gt;以帮助完成本文。</target>
        </trans-unit>
        <trans-unit id="7a69f82bc8c73af862fe6ee2765641d403ac8822" translate="yes" xml:space="preserve">
          <source>This can be used to create APIs that both accept node-style callbacks and return promises:</source>
          <target state="translated">这可以用来创建既接受节点式回调又返回承诺的API。</target>
        </trans-unit>
        <trans-unit id="2af698572346d77b6e2820e63d397c65adf61bf3" translate="yes" xml:space="preserve">
          <source>This can be useful if a function returns a promise (say into a chain) but can optionally return a static value. Say, for a lazy-loaded value. Example:</source>
          <target state="translated">如果一个函数返回一个承诺(比如说进入一个链),但可以选择返回一个静态值,这就很有用。比如,对于一个懒加载的值。例子:</target>
        </trans-unit>
        <trans-unit id="01154032238ce0a62f38ce2edfeea44425f1609e" translate="yes" xml:space="preserve">
          <source>This can happen when you are calling &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; on a function and invoking it instead of passing it.</source>
          <target state="translated">当您在函数上调用&lt;a href=&quot;api/promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt;并调用它而不是传递它时，可能会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="b7e20e128e0a8a57b67f7c7c358d05477f3c5d61" translate="yes" xml:space="preserve">
          <source>This can happen when you tried to do something like:</source>
          <target state="translated">当你试图做这样的事情时,可能会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="caac030e0f988203bfd2f85f66f13be073b83988" translate="yes" xml:space="preserve">
          <source>This doesn't add much much using &lt;code&gt;window.prompt&lt;/code&gt;; however, one advantage is the API that promises provide. In the case where we call &lt;code&gt;promptPromise(&amp;hellip;)&lt;/code&gt; we can easily react to the result of the dialog without having to worry about how it is implemented. In our example we've implemented the &lt;code&gt;window.prompt&lt;/code&gt; but our call to &lt;code&gt;promptPromise()&lt;/code&gt; doesn't care. This makes a change to an &lt;em&gt;asynchronous&lt;/em&gt; dialog a little more future proof.</source>
          <target state="translated">使用 &lt;code&gt;window.prompt&lt;/code&gt; 并不会增加太多；但是，一个优点是承诺提供的API。在我们调用 &lt;code&gt;promptPromise(&amp;hellip;)&lt;/code&gt; 的情况下，我们可以轻松地对对话框的结果做出反应，而不必担心其实现方式。在我们的示例中，我们已经实现了 &lt;code&gt;window.prompt&lt;/code&gt; ,但是对 &lt;code&gt;promptPromise()&lt;/code&gt; 调用并不重要。这使得对&lt;em&gt;异步&lt;/em&gt;对话框的更改成为将来的证明。</target>
        </trans-unit>
        <trans-unit id="71b6120513a7366580cee8aba7b9480ac2cf93a2" translate="yes" xml:space="preserve">
          <source>This error indicates you have tried to call &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; on an object that already has a property with the &lt;code&gt;Async&lt;/code&gt; suffix:</source>
          <target state="translated">此错误表明您尝试对已经具有 &lt;code&gt;Async&lt;/code&gt; 后缀的属性的对象调用&lt;a href=&quot;api/promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="a572d9a56addbf0b78e49d060a13678d16002f76" translate="yes" xml:space="preserve">
          <source>This example doesn't work as intended because the &lt;code&gt;then&lt;/code&gt; handler actually swallows the exception and returns &lt;code&gt;undefined&lt;/code&gt; for any further chainers.</source>
          <target state="translated">该示例无法按预期工作，因为 &lt;code&gt;then&lt;/code&gt; 处理程序实际上吞没了该异常，并为任何进一步的链接器返回 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c54ec4bcf6b3320c0e8ec781b0cb320bbd68320" translate="yes" xml:space="preserve">
          <source>This example pings 4 nameservers, and logs the fastest 2 on console:</source>
          <target state="translated">这个例子ping了4个nameservers,并在控制台记录了最快的两个。</target>
        </trans-unit>
        <trans-unit id="2b07ce3ee1a174adcf4f487506a3c9e336575eaf" translate="yes" xml:space="preserve">
          <source>This feature enables subscription to promise lifecycle events via standard global events mechanisms in browsers and Node.js.</source>
          <target state="translated">该功能可以通过浏览器和Node.js中的标准全局事件机制来实现订阅承诺生命周期事件。</target>
        </trans-unit>
        <trans-unit id="876ee350821244d6855a5b5648beee14fb439673" translate="yes" xml:space="preserve">
          <source>This feature has to be explicitly enabled by calling &lt;a href=&quot;api/promise.config&quot;&gt;&lt;code&gt;Promise.config&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;monitoring: true&lt;/code&gt;.</source>
          <target state="translated">此功能必须通过调用明确启用&lt;a href=&quot;api/promise.config&quot;&gt; &lt;code&gt;Promise.config&lt;/code&gt; &lt;/a&gt;与 &lt;code&gt;monitoring: true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca7179462cda9a709541b309d7c01bbb585212a4" translate="yes" xml:space="preserve">
          <source>This file contains documentation for APIs that are no longer supported by Bluebird. These APIs still work in Bluebird but will be removed at a future version of the library.</source>
          <target state="translated">这个文件包含Bluebird不再支持的API的文档。这些API仍然可以在Bluebird中使用,但会在未来的库版本中被移除。</target>
        </trans-unit>
        <trans-unit id="4e1d1e209b1192c78f57f02dae0b2d4bf136ca53" translate="yes" xml:space="preserve">
          <source>This happens when a non object value or a promise that resolves with something that is not an object is being passed instead.</source>
          <target state="translated">当一个非对象值或一个用非对象的东西解析的承诺被传递时,就会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="fb3b4bfaeb441a21b0068d6c2bb1331473c59ffc" translate="yes" xml:space="preserve">
          <source>This happens when you call &lt;code&gt;.some&lt;/code&gt; passing it a negative value or a non-integer.</source>
          <target state="translated">当您调用 &lt;code&gt;.some&lt;/code&gt; 将其传递为负值或非整数时，会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="361cf2ec170969184f8f35c3d2c58d91c88e0978" translate="yes" xml:space="preserve">
          <source>This inherits from &lt;code&gt;Dialog&lt;/code&gt; and stores references to the required DOM elements that this dialog uses. It then attaches the require DOM events (&lt;code&gt;attachDomEvents()&lt;/code&gt;) which eventually call the callbacks. Then it implements the &lt;code&gt;show()&lt;/code&gt; and &lt;code&gt;hide()&lt;/code&gt; methods. Its usage is more flexible and verbose:</source>
          <target state="translated">这从 &lt;code&gt;Dialog&lt;/code&gt; 继承，并存储对该对话框使用的必需DOM元素的引用。然后，它将附加要求DOM事件（ &lt;code&gt;attachDomEvents()&lt;/code&gt; ），该事件最终将调用回调。然后，它实现 &lt;code&gt;show()&lt;/code&gt; 和 &lt;code&gt;hide()&lt;/code&gt; 方法。它的用法更加灵活和冗长：</target>
        </trans-unit>
        <trans-unit id="1c40c501429304b951f3e9a1e618216d7da3fae9" translate="yes" xml:space="preserve">
          <source>This interface is implemented by &lt;code&gt;Promise&lt;/code&gt; instances as well as the &lt;code&gt;PromiseInspection&lt;/code&gt; result given by &lt;a href=&quot;reflect&quot;&gt;&lt;code&gt;.reflect()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该接口由 &lt;code&gt;Promise&lt;/code&gt; 实例以及 &lt;code&gt;PromiseInspection&lt;/code&gt; &lt;a href=&quot;reflect&quot;&gt; &lt;code&gt;.reflect()&lt;/code&gt; &lt;/a&gt;给出的PromiseInspection结果实现。</target>
        </trans-unit>
        <trans-unit id="1625642eae18357d2f9d1a1405e4d5fa15c5195c" translate="yes" xml:space="preserve">
          <source>This is Gorki Kosev's benchmark used in the article &lt;a href=&quot;http://spion.github.io/posts/analysis-generators-and-other-async-patterns-node.html&quot;&gt;Analysis of generators and other async patterns in node&lt;/a&gt;. The benchmark emulates a situation where N=10000 requests are being made concurrently to execute some mixed async/sync action with fast I/O response times.</source>
          <target state="translated">这是Gorki Kosev在基准点中的&lt;a href=&quot;http://spion.github.io/posts/analysis-generators-and-other-async-patterns-node.html&quot;&gt;生成器分析和其他异步模式中&lt;/a&gt;使用的基准。该基准测试模拟了以下情况：同时发出N = 10000个请求，以执行具有快速I / O响应时间的混合异步/同步操作。</target>
        </trans-unit>
        <trans-unit id="c49dfefe9b869fa007a2d85f8deb59c16587b42f" translate="yes" xml:space="preserve">
          <source>This is a catch-all exception handler, shortcut for calling &lt;a href=&quot;then&quot;&gt;&lt;code&gt;.then(null, handler)&lt;/code&gt;&lt;/a&gt; on this promise. Any exception happening in a &lt;code&gt;.then&lt;/code&gt;-chain will propagate to nearest &lt;code&gt;.catch&lt;/code&gt; handler.</source>
          <target state="translated">这是一个包罗万象的异常处理程序，是在此promise上调用&lt;a href=&quot;then&quot;&gt; &lt;code&gt;.then(null, handler)&lt;/code&gt; &lt;/a&gt;快捷方式。任何异常的发生 &lt;code&gt;.then&lt;/code&gt; &amp;alpha;-链将传播到最近的 &lt;code&gt;.catch&lt;/code&gt; 处理程序。</target>
        </trans-unit>
        <trans-unit id="41cc0d7fb9773615b0a72dbe0951bb7f568b688b" translate="yes" xml:space="preserve">
          <source>This is a convenience method for doing:</source>
          <target state="translated">这是一种方便的方法,做。</target>
        </trans-unit>
        <trans-unit id="ab45ed2cecaf14b1bbcc736ecc5d3c6da77d3562" translate="yes" xml:space="preserve">
          <source>This is a throughput benchmark.</source>
          <target state="translated">这是一个吞吐量基准。</target>
        </trans-unit>
        <trans-unit id="0bb50cb46856cf19733b9b720a91a5dbcedf8961" translate="yes" xml:space="preserve">
          <source>This is an extension to &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; to work more like catch-clauses in languages like Java or C#. Instead of manually checking &lt;code&gt;instanceof&lt;/code&gt; or &lt;code&gt;.name === &quot;SomeError&quot;&lt;/code&gt;, you may specify a number of error constructors which are eligible for this catch handler. The catch handler that is first met that has eligible constructors specified, is the one that will be called.</source>
          <target state="translated">这是对&lt;a href=&quot;catch&quot;&gt; &lt;code&gt;.catch&lt;/code&gt; &lt;/a&gt;的扩展，使其更像Java或C＃语言中的catch子句。代替手动检查 &lt;code&gt;instanceof&lt;/code&gt; 或 &lt;code&gt;.name === &quot;SomeError&quot;&lt;/code&gt; ，您可以指定许多符合此catch处理程序的错误构造函数。将首先调用具有指定的合格构造函数的catch处理程序。</target>
        </trans-unit>
        <trans-unit id="4e6f1e1654fff47bb7489453d9f0b688afc82574" translate="yes" xml:space="preserve">
          <source>This is an extension to &lt;a href=&quot;tapcatch&quot;&gt;&lt;code&gt;.tapCatch&lt;/code&gt;&lt;/a&gt; to filter exceptions similarly to languages like Java or C#. Instead of manually checking &lt;code&gt;instanceof&lt;/code&gt; or &lt;code&gt;.name === &quot;SomeError&quot;&lt;/code&gt;, you may specify a number of error constructors which are eligible for this tapCatch handler. The tapCatch handler that is first met that has eligible constructors specified, is the one that will be called.</source>
          <target state="translated">这是对&lt;a href=&quot;tapcatch&quot;&gt; &lt;code&gt;.tapCatch&lt;/code&gt; &lt;/a&gt;的扩展，以类似于Java或C＃之类的语言过滤异常。代替手动检查 &lt;code&gt;instanceof&lt;/code&gt; 或 &lt;code&gt;.name === &quot;SomeError&quot;&lt;/code&gt; ，您可以指定许多可用于此tapCatch处理程序的错误构造函数。将首先调用具有指定的合格构造函数的tapCatch处理程序。</target>
        </trans-unit>
        <trans-unit id="de9b1d19482e049c5d2755c5328d90634cf4cf49" translate="yes" xml:space="preserve">
          <source>This is because Bluebird adds the &lt;code&gt;Async&lt;/code&gt; suffix to distinguish the original method from the promisified one, so &lt;code&gt;fooAsync&lt;/code&gt; would have been overridden. In order to avoid this - either rename &lt;code&gt;fooAsync&lt;/code&gt; before promisifying the API, or call &lt;a href=&quot;api/promise.promisify&quot;&gt;&lt;code&gt;Promise.promisify&lt;/code&gt;&lt;/a&gt; manually on select properties.</source>
          <target state="translated">这是因为Bluebird添加了 &lt;code&gt;Async&lt;/code&gt; 后缀以区分原始方法和已承诺的方法，因此 &lt;code&gt;fooAsync&lt;/code&gt; 将被覆盖。为了避免这种情况- 在使API &lt;code&gt;fooAsync&lt;/code&gt; 之前重命名fooAsync，或在选择属性上手动调用&lt;a href=&quot;api/promise.promisify&quot;&gt; &lt;code&gt;Promise.promisify&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fb04140a6d6f4216a6dfa405bfd92da440efbba0" translate="yes" xml:space="preserve">
          <source>This is exactly like the synchronous code:</source>
          <target state="translated">这和同步代码一模一样。</target>
        </trans-unit>
        <trans-unit id="bfb76de6040fe50d520474f7810629da738b7706" translate="yes" xml:space="preserve">
          <source>This is far more readable when done with promises:</source>
          <target state="translated">这在做承诺的时候,可读性要强得多。</target>
        </trans-unit>
        <trans-unit id="618293c3c21f06bb90993a614c9db3abe676ad93" translate="yes" xml:space="preserve">
          <source>This is reinventing the square wheel because any callback API wrapping can and should be done immediately using the promise library's promisification methods:</source>
          <target state="translated">这是在重新发明方轮,因为任何回调API包装都可以而且应该立即使用承诺库的承诺化方法来完成。</target>
        </trans-unit>
        <trans-unit id="278f2f5f91e65aca9cba986cd298d5b80d084994" translate="yes" xml:space="preserve">
          <source>This is relevant to browser environments with no module loader.</source>
          <target state="translated">这与没有模块加载器的浏览器环境有关。</target>
        </trans-unit>
        <trans-unit id="72dacc01b0328b9bb5e5b49e4a3b2f09a68d5835" translate="yes" xml:space="preserve">
          <source>This is the most common anti-pattern. It is easy to fall into this when you don't really understand promises and think of them as glorified event emitters or callback utility. It's also sometimes called the promise constructor anti-pattern. Let's recap: promises are about making asynchronous code retain most of the lost properties of synchronous code such as flat indentation and one exception channel. This pattern is also called the deferred anti-pattern.</source>
          <target state="translated">这是最常见的反模式。当你不真正理解承诺,把它们当作美化的事件发射器或回调工具时,很容易陷入这种情况。它有时也被称为承诺构造函数反模式。我们来总结一下:诺言就是让异步代码保留大部分同步代码失去的属性,比如扁平缩进和一个异常通道。这种模式也被称为延迟反模式。</target>
        </trans-unit>
        <trans-unit id="83310ff097e8beff42467f80b6885cac44a4a774" translate="yes" xml:space="preserve">
          <source>This is the point&amp;mdash;to have something that works like &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;throw&lt;/code&gt; in synchronous code.</source>
          <target state="translated">这就是要点&amp;mdash; 在同步代码中具有类似于 &lt;code&gt;return&lt;/code&gt; 和 &lt;code&gt;throw&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="158db758d5ef9e5d2ebee4458ff60d03b8698f8f" translate="yes" xml:space="preserve">
          <source>This is to enable better stack trace support and to have more consistent and logical code.</source>
          <target state="translated">这是为了能够更好的支持堆栈跟踪,让代码更加一致和逻辑。</target>
        </trans-unit>
        <trans-unit id="eb2cd71a05d06d1a123d046c307b240be60c02ec" translate="yes" xml:space="preserve">
          <source>This made-up scenario runs 25 shimmed queries in parallel per each request (N=10000) with fast I/O response times.</source>
          <target state="translated">这个编造的方案,每个请求并行运行25个shimmed查询(N=10000),I/O响应时间快。</target>
        </trans-unit>
        <trans-unit id="1cc8fcf272c1fddb57ef8ff18a07070dc64c720d" translate="yes" xml:space="preserve">
          <source>This means you can insert &lt;code&gt;.tap()&lt;/code&gt; into a &lt;code&gt;.then()&lt;/code&gt; chain without affecting what is passed through the chain. (See example below).</source>
          <target state="translated">这意味着你可以插入 &lt;code&gt;.tap()&lt;/code&gt; 成 &lt;code&gt;.then()&lt;/code&gt; 链，而不会影响通过链条传递。 （请参见下面的示例）。</target>
        </trans-unit>
        <trans-unit id="3c0de91929a03e3312c7e239b95e998f29ef038e" translate="yes" xml:space="preserve">
          <source>This method also supports predicate-based filters. If you pass a predicate function instead of an error constructor, the predicate will receive the error as an argument. The return result of the predicate will be used determine whether the error handler should be called.</source>
          <target state="translated">该方法还支持基于谓词的过滤器。如果传递一个谓词函数而不是错误构造函数,谓词将接收错误作为参数。谓词的返回结果将用于决定是否应该调用错误处理程序。</target>
        </trans-unit>
        <trans-unit id="b9befc4f3f3a5debf1bc48e96cdc0758b3d6448b" translate="yes" xml:space="preserve">
          <source>This method is compatible with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt; from native promises.</source>
          <target state="translated">此方法与本机&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;/a&gt;兼容。</target>
        </trans-unit>
        <trans-unit id="a0481512ec7eb9822880d2eb57c4e1770159cdaa" translate="yes" xml:space="preserve">
          <source>This method is convenient when a function can sometimes return synchronously or throw synchronously.</source>
          <target state="translated">当一个函数有时可以同步返回或同步抛出时,这种方法很方便。</target>
        </trans-unit>
        <trans-unit id="05db19a6c7c0e842cae324b6edc66273dd337537" translate="yes" xml:space="preserve">
          <source>This method is deprecated. Use &lt;a href=&quot;promise.config&quot;&gt;Promise.config&lt;/a&gt; instead.</source>
          <target state="translated">不建议使用此方法。请改用&lt;a href=&quot;promise.config&quot;&gt;Promise.config&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f63178b611e277d3437aa6cb79a370492a0a4d4d" translate="yes" xml:space="preserve">
          <source>This method is only implemented because it's in the ES6 standard. If you want to race promises to fulfillment the &lt;a href=&quot;any&quot;&gt;&lt;code&gt;.any&lt;/code&gt;&lt;/a&gt; method is more appropriate as it doesn't qualify a rejected promise as the winner. It also has less surprises: &lt;code&gt;.race&lt;/code&gt; must become infinitely pending if an empty array is passed but passing an empty array to &lt;a href=&quot;any&quot;&gt;&lt;code&gt;.any&lt;/code&gt;&lt;/a&gt; is more usefully a &lt;code&gt;RangeError&lt;/code&gt;</source>
          <target state="translated">仅由于采用ES6标准，因此才实现此方法。如果您想兑现承诺，则&lt;a href=&quot;any&quot;&gt; &lt;code&gt;.any&lt;/code&gt; &lt;/a&gt;方法更合适，因为它不能使被拒绝的承诺成为赢家。它也有少惊喜： &lt;code&gt;.race&lt;/code&gt; 必须成为无限，如果一个空数组传递，但传递一个空数组未决&lt;a href=&quot;any&quot;&gt; &lt;code&gt;.any&lt;/code&gt; &lt;/a&gt;是更有用的一个 &lt;code&gt;RangeError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17f763d4342a3b00b5440e744954545f7480822a" translate="yes" xml:space="preserve">
          <source>This method is useful for when you want to wait for more than one promise to complete.</source>
          <target state="translated">当你想等待一个以上的承诺完成时,这个方法很有用。</target>
        </trans-unit>
        <trans-unit id="e13b547a51d6973b8e8ea8229673f31834f1a93d" translate="yes" xml:space="preserve">
          <source>This method should be used before you use any of the methods which would otherwise alter the global &lt;code&gt;Bluebird&lt;/code&gt; object - to avoid polluting global state.</source>
          <target state="translated">在使用任何可能会更改全局 &lt;code&gt;Bluebird&lt;/code&gt; 对象的方法之前，应使用此方法-以避免污染全局状态。</target>
        </trans-unit>
        <trans-unit id="bb88a06a14951217dbf7da64e1c214d581435513" translate="yes" xml:space="preserve">
          <source>This page describes parallels of using promises in other languages. Promises as a pattern are very common in other languages and knowing what they map to in other languages might help you with grasping them conceptually</source>
          <target state="translated">本页介绍了在其他语言中使用承诺的相似之处。承诺作为一种模式在其他语言中非常常见,了解它们在其他语言中的映射可能会帮助你从概念上掌握它们。</target>
        </trans-unit>
        <trans-unit id="f8caafd4bd28c25bbaa9e7e7281f27609e085879" translate="yes" xml:space="preserve">
          <source>This page explains how to interface your code with existing callback APIs and libraries you're using. We'll see that making bluebird work with callback APIs is not only easy - it's also fast.</source>
          <target state="translated">本页将介绍如何将你的代码与现有的回调API和你正在使用的库相连接。我们将看到,让bluebird与回调API配合使用不仅简单而且快速。</target>
        </trans-unit>
        <trans-unit id="31362f3d4d915353baa5045a042087f3f740de15" translate="yes" xml:space="preserve">
          <source>This page is a reference for migrating to bluebird from other flow control or promise libraries. See &lt;a href=&quot;install&quot;&gt;installation&lt;/a&gt; on how to use bluebird in your environment.</source>
          <target state="translated">此页面是从其他流控制或Promise库迁移到bluebird的参考。有关如何在您的环境中使用bluebird的信息，请参见&lt;a href=&quot;install&quot;&gt;安装&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a9a982268e14e003930e216d5e26566cf85c426" translate="yes" xml:space="preserve">
          <source>This page will contain common promise anti-patterns that are exercised in the wild.</source>
          <target state="translated">本页将包含在野外行使的常见答应反式样。</target>
        </trans-unit>
        <trans-unit id="aa9be090a3976e3bdcf5c7d5ffe1e9f09746eddc" translate="yes" xml:space="preserve">
          <source>This section lists the most common async module replacements.</source>
          <target state="translated">本节列出了最常见的异步模块替换。</target>
        </trans-unit>
        <trans-unit id="bbbc8fd10030426b3463e06d9b5b51c19c29316d" translate="yes" xml:space="preserve">
          <source>This section only applies to node.js or io.js.</source>
          <target state="translated">本节仅适用于node.js或io.js。</target>
        </trans-unit>
        <trans-unit id="dde97755fad5f67be03bd6d1c4049a9360dedd37" translate="yes" xml:space="preserve">
          <source>This superfluous wrapping is also dangerous, any kind of errors and rejections are swallowed and not propagated to the caller of this function.</source>
          <target state="translated">这种多余的包装也是很危险的,任何一种错误和拒绝都会被吞噬,不会传播给这个函数的调用者。</target>
        </trans-unit>
        <trans-unit id="12297c68c5f136df52d6d18d4a5ba1ec592d81f8" translate="yes" xml:space="preserve">
          <source>This usually happens when you have a promise that resolves or rejects with itself.</source>
          <target state="translated">这种情况通常发生在你有一个承诺,解决或拒绝与自己。</target>
        </trans-unit>
        <trans-unit id="22c09fd50a68a2d3dd2ca54a203b3e20039f8ff5" translate="yes" xml:space="preserve">
          <source>This usually means that you simply forgot a &lt;code&gt;return&lt;/code&gt; statement somewhere, which will cause a runaway promise that is not connected to any promise chain.</source>
          <target state="translated">这通常意味着您只是在某处忘记了 &lt;code&gt;return&lt;/code&gt; 语句，这将导致未与任何诺言链连接的诺言。</target>
        </trans-unit>
        <trans-unit id="641aada61fdf6b191fac4681998d3181bd3d099f" translate="yes" xml:space="preserve">
          <source>This will ensure that &lt;code&gt;connection.close()&lt;/code&gt; will be called once the promise returned from the &lt;code&gt;Promise.using&lt;/code&gt; closure is resolved or if an exception was thrown in the closure body.</source>
          <target state="translated">这将确保一旦 &lt;code&gt;Promise.using&lt;/code&gt; 闭包返回的承诺被解决，或者在闭包主体中引发了异常，则将调用 &lt;code&gt;connection.close()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1caca18b80550e74fc714f5129356a12216a1b3" translate="yes" xml:space="preserve">
          <source>This works because the array acts as a &quot;module&quot; where the indices are the &quot;module&quot;'s properties for classes.</source>
          <target state="translated">这样做的原因是数组作为一个 &quot;模块&quot;,其中的索引是 &quot;模块 &quot;的类的属性。</target>
        </trans-unit>
        <trans-unit id="642f5108aa274866c1da99279aa0b6d98b1fdf21" translate="yes" xml:space="preserve">
          <source>Through the use of &lt;a href=&quot;api/each&quot;&gt;&lt;code&gt;.each&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;api/map&quot;&gt;&lt;code&gt;.map&lt;/code&gt;&lt;/a&gt; doing things just at the right concurrency level becomes a breeze.</source>
          <target state="translated">通过使用&lt;a href=&quot;api/each&quot;&gt; &lt;code&gt;.each&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;api/map&quot;&gt; &lt;code&gt;.map&lt;/code&gt; &lt;/a&gt;，仅在正确的并发级别执行事务就变得轻而易举。</target>
        </trans-unit>
        <trans-unit id="22a4ad2c60d9b1a4a4ab47810c732e12faec00b0" translate="yes" xml:space="preserve">
          <source>TimeoutError</source>
          <target state="translated">TimeoutError</target>
        </trans-unit>
        <trans-unit id="ae5a9ed10e48f39a8b693714bce92b1291ca1c8b" translate="yes" xml:space="preserve">
          <source>TimeoutError()</source>
          <target state="translated">TimeoutError()</target>
        </trans-unit>
        <trans-unit id="841cd03a97cd854590864d79ae48ee749c5e902e" translate="yes" xml:space="preserve">
          <source>Timers</source>
          <target state="translated">Timers</target>
        </trans-unit>
        <trans-unit id="23658960168be8cdbfbe275f17c4c761b8a8f3e9" translate="yes" xml:space="preserve">
          <source>To do this we will have two &lt;code&gt;catch()&lt;/code&gt; functions one for &lt;code&gt;UserCanceledError&lt;/code&gt; and one for any other &lt;code&gt;Error&lt;/code&gt;. We can make a custom error like so:</source>
          <target state="translated">为此，我们将有两个 &lt;code&gt;catch()&lt;/code&gt; 函数，一个用于 &lt;code&gt;UserCanceledError&lt;/code&gt; ，另一个用于其他 &lt;code&gt;Error&lt;/code&gt; 。我们可以这样做一个自定义错误：</target>
        </trans-unit>
        <trans-unit id="b1a3ce42d2f42f9c24273b4cda598b33af25fce3" translate="yes" xml:space="preserve">
          <source>To drive home the synchronous nature of the &lt;code&gt;window.prompt&lt;/code&gt; notice that the time stops ticking when the prompt dialog is displayed. Let's fix that by making our own prompt. Since our dialog is just DOM manipulation the page won't be blocked while waiting for user input.</source>
          <target state="translated">为了使 &lt;code&gt;window.prompt&lt;/code&gt; 具有同步特性，请注意当显示提示对话框时，时间停止计时。让我们通过自己提示来解决此问题。由于我们的对话框只是DOM操作，因此在等待用户输入时不会阻止页面。</target>
        </trans-unit>
        <trans-unit id="a7035efe5121276c8995557c4e8d8404d5096469" translate="yes" xml:space="preserve">
          <source>To enable long stack traces and warnings in node development:</source>
          <target state="translated">在节点开发中启用长栈跟踪和警告。</target>
        </trans-unit>
        <trans-unit id="0e38679fea7f9ddcf16ac2341ac48ffb3d6a13cd" translate="yes" xml:space="preserve">
          <source>To enable long stack traces and warnings in node production:</source>
          <target state="translated">在节点生产中启用长栈跟踪和警告。</target>
        </trans-unit>
        <trans-unit id="302b55ad14f02d86e137c0363366e824866304b7" translate="yes" xml:space="preserve">
          <source>To enable them in all instances of bluebird in node.js, use the environment variable &lt;code&gt;BLUEBIRD_DEBUG&lt;/code&gt;:</source>
          <target state="translated">要在node.js的所有bluebird实例中启用它们，请使用环境变量 &lt;code&gt;BLUEBIRD_DEBUG&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6a347bd13a256b214fb6fa7d0dff43a0c457c811" translate="yes" xml:space="preserve">
          <source>To fix it, simply pass the function reference to &lt;a href=&quot;api/then&quot;&gt;&lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; as is:</source>
          <target state="translated">要解决此问题，只需按原样将函数引用传递给&lt;a href=&quot;api/then&quot;&gt; &lt;code&gt;.then()&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="1ab4b669048933cdcafeed010c60563bc2fd72dd" translate="yes" xml:space="preserve">
          <source>To fix it, you need to &lt;code&gt;return&lt;/code&gt; the promise:</source>
          <target state="translated">要解决此问题，您需要 &lt;code&gt;return&lt;/code&gt; 诺言：</target>
        </trans-unit>
        <trans-unit id="67cb18d088b9f1e447cdd241d432d091a17f83ef" translate="yes" xml:space="preserve">
          <source>To fix, simply remember to add &lt;code&gt;return&lt;/code&gt; in front of your promise-complying function:</source>
          <target state="translated">要解决此问题，只需记住在您的遵守诺言的函数前添加 &lt;code&gt;return&lt;/code&gt; 即可：</target>
        </trans-unit>
        <trans-unit id="9dfea82804728489558d139da2f0b772571e485c" translate="yes" xml:space="preserve">
          <source>To make sure a function that returns a promise is following the implicit but critically important contract of promises, you can start a function with &lt;code&gt;new Promise&lt;/code&gt; if you cannot start a chain immediately:</source>
          <target state="translated">为确保返回承诺的函数遵循了隐含但至关重要的承诺契约，如果无法立即启动链，则可以使用 &lt;code&gt;new Promise&lt;/code&gt; 启动函数：</target>
        </trans-unit>
        <trans-unit id="4f45ac1d08d953780ed4fe1af6ee2f1aafa55655" translate="yes" xml:space="preserve">
          <source>Together with &lt;code&gt;onPossiblyUnhandledRejection&lt;/code&gt; these hooks can be used to implement a debugger that will show a list of unhandled promise rejections updated in real time as promises become handled.</source>
          <target state="translated">这些钩子与 &lt;code&gt;onPossiblyUnhandledRejection&lt;/code&gt; 一起可以用于实现调试器，该调试器将显示未处理的承诺拒绝列表，这些承诺将在处理承诺时实时更新。</target>
        </trans-unit>
        <trans-unit id="cffb3821e2781468cd3c381c1dd88d7da75f44e5" translate="yes" xml:space="preserve">
          <source>Typically &lt;em&gt;promises&lt;/em&gt; are used in conjunction with asynchronous tasks such as a network request or a &lt;code&gt;setTimeout&lt;/code&gt;; a lesser explored use is dealing with user input. Since a program has to wait for a user to continue some actions it makes sense to consider it an asynchronous event.</source>
          <target state="translated">通常，&lt;em&gt;promise&lt;/em&gt;与异步任务（例如网络请求或 &lt;code&gt;setTimeout&lt;/code&gt; )结合使用；一种较小的探索用途是处理用户输入。由于程序必须等待用户继续执行某些操作，因此将其视为异步事件是有意义的。</target>
        </trans-unit>
        <trans-unit id="95e39893849d27ccdda4985a773f9d1a23141d52" translate="yes" xml:space="preserve">
          <source>Unhandled errors are not silently swallowed by default but reported along with helpful stack traces where applicable. All of this is of course configurable.</source>
          <target state="translated">默认情况下,未处理的错误不会被默默地吞噬,而是在适用的情况下与有用的堆栈痕迹一起报告。当然,所有这些都是可以配置的。</target>
        </trans-unit>
        <trans-unit id="3a34c30705919f5365483a84e6ffe973cf51a891" translate="yes" xml:space="preserve">
          <source>Unhandled rejections are tracked per promise, not per error. So if you create multiple branches from a single ancestor and that ancestor gets rejected, each branch with no error handler with the end will cause a possibly unhandled rejection handler invocation</source>
          <target state="translated">未处理的拒绝是按承诺跟踪的,而不是按错误跟踪的。因此,如果你从一个祖先创建了多个分支,并且该祖先被拒绝,那么每个分支的末端没有错误处理程序,将导致可能的未处理拒绝处理程序调用。</target>
        </trans-unit>
        <trans-unit id="4c350ad9142ecaab016e03c764abcb7074c45e90" translate="yes" xml:space="preserve">
          <source>Unless an AMD loader is installed, the script tag installation exposes the library in the &lt;code&gt;Promise&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; namespaces. If you want to restore the &lt;code&gt;Promise&lt;/code&gt; namespace, use &lt;code&gt;var Bluebird = Promise.noConflict()&lt;/code&gt;.</source>
          <target state="translated">除非安装了AMD加载程序，否则脚本标记安装将在 &lt;code&gt;Promise&lt;/code&gt; 和 &lt;code&gt;P&lt;/code&gt; 名称空间中公开该库。如果要还原 &lt;code&gt;Promise&lt;/code&gt; 命名空间，请使用 &lt;code&gt;var Bluebird = Promise.noConflict()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44e42a41d2a20532fa9a5c2908e1e8626e2a7e8e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;finally&quot;&gt;&lt;code&gt;.finally&lt;/code&gt;&lt;/a&gt; this is not called for rejections.</source>
          <target state="translated">与&lt;a href=&quot;finally&quot;&gt; &lt;code&gt;.finally&lt;/code&gt; &lt;/a&gt;不同，这不称为拒绝。</target>
        </trans-unit>
        <trans-unit id="8371d8f357f54bfda7d7c8677986ada6f8fa2ae9" translate="yes" xml:space="preserve">
          <source>Unminified source file meant to be used in development. Warnings and long stack traces are enabled which are taxing on performance.</source>
          <target state="translated">未定义的源文件,用于开发。启用了警告和长堆栈跟踪,这对性能有影响。</target>
        </trans-unit>
        <trans-unit id="c6395a030ac1269e7ce9bae273ab910b5d2f5034" translate="yes" xml:space="preserve">
          <source>Update acorn dependency</source>
          <target state="translated">更新橡子的依赖性</target>
        </trans-unit>
        <trans-unit id="42a8536e189c405379021d94a1e8532ff836496d" translate="yes" xml:space="preserve">
          <source>Updated logo</source>
          <target state="translated">更新的标志</target>
        </trans-unit>
        <trans-unit id="08b6f1fdb58d25854a37bb391362fd81dc049478" translate="yes" xml:space="preserve">
          <source>Usage examples include:</source>
          <target state="translated">用例包括:</target>
        </trans-unit>
        <trans-unit id="eb4421a3da2485be27f4aababc58c8de5da2c8d7" translate="yes" xml:space="preserve">
          <source>Use setImmediate if available</source>
          <target state="translated">如果有,请使用setImmediate</target>
        </trans-unit>
        <trans-unit id="289a45d725e898c1ca06ab7fa01837771482ed99" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;api/promise.all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt; to implement the example from &lt;a href=&quot;https://github.com/caolan/async#parallel&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="translated">使用&lt;a href=&quot;api/promise.all&quot;&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;/a&gt;从&lt;a href=&quot;https://github.com/caolan/async#parallel&quot;&gt;异步主页&lt;/a&gt;实现示例：</target>
        </trans-unit>
        <trans-unit id="d609f610f666b772e57874290c0b6739f1e46b91" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;api/promise.each&quot;&gt;&lt;code&gt;Promise.each&lt;/code&gt;&lt;/a&gt; to implement the example from &lt;a href=&quot;https://github.com/caolan/async#maparr-iterator-callback&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="translated">使用&lt;a href=&quot;api/promise.each&quot;&gt; &lt;code&gt;Promise.each&lt;/code&gt; &lt;/a&gt;从&lt;a href=&quot;https://github.com/caolan/async#maparr-iterator-callback&quot;&gt;异步主页&lt;/a&gt;实现示例：</target>
        </trans-unit>
        <trans-unit id="7b37cc52da759eea0a61e35010724d1f98be048a" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;api/promise.map&quot;&gt;&lt;code&gt;Promise.map&lt;/code&gt;&lt;/a&gt; to implement the example from &lt;a href=&quot;https://github.com/caolan/async#maparr-iterator-callback&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="translated">使用&lt;a href=&quot;api/promise.map&quot;&gt; &lt;code&gt;Promise.map&lt;/code&gt; &lt;/a&gt;从&lt;a href=&quot;https://github.com/caolan/async#maparr-iterator-callback&quot;&gt;异步主页&lt;/a&gt;实现示例：</target>
        </trans-unit>
        <trans-unit id="87872433fa3fca67fb5bcea17254b8b45dc74c5d" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;api/promise.mapseries&quot;&gt;&lt;code&gt;Promise.mapSeries&lt;/code&gt;&lt;/a&gt; to implement the example from &lt;a href=&quot;https://github.com/caolan/async#seriestasks-callback&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="translated">使用&lt;a href=&quot;api/promise.mapseries&quot;&gt; &lt;code&gt;Promise.mapSeries&lt;/code&gt; &lt;/a&gt;从&lt;a href=&quot;https://github.com/caolan/async#seriestasks-callback&quot;&gt;异步主页&lt;/a&gt;实现示例：</target>
        </trans-unit>
        <trans-unit id="5a34d8c3d20da73e7fdd61d0a9cd7e9a530150eb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;.reflect()&lt;/code&gt; to implement &lt;code&gt;settleAll&lt;/code&gt; (wait until all promises in an array are either rejected or fulfilled) functionality</source>
          <target state="translated">使用 &lt;code&gt;settleAll&lt;/code&gt; &lt;code&gt;.reflect()&lt;/code&gt; 来实现resolveAll（等待直到数组中的所有promise被拒绝或实现）</target>
        </trans-unit>
        <trans-unit id="a030f13931277422b23a2b7aa92804eba9dbfca1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;.reflect()&lt;/code&gt; to implement &lt;code&gt;settleProps&lt;/code&gt; (like settleAll for an object's properties) functionality</source>
          <target state="translated">使用 &lt;code&gt;settleProps&lt;/code&gt; &lt;code&gt;.reflect()&lt;/code&gt; 来实现resolveProps（例如对对象属性的resolveAll）</target>
        </trans-unit>
        <trans-unit id="510bd1d1748aa6be73d0b3f164f968144ae8f326" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;defaultPromisifier&lt;/code&gt; parameter to add enhancements on top of normal node promisification:</source>
          <target state="translated">使用 &lt;code&gt;defaultPromisifier&lt;/code&gt; 参数在常规节点承诺化之上添加增强功能：</target>
        </trans-unit>
        <trans-unit id="a7f32ad8c97706d5425fc98083d499e4e2b0f38a" translate="yes" xml:space="preserve">
          <source>Using CoffeeScript's &lt;code&gt;class&lt;/code&gt; for the same:</source>
          <target state="translated">同样使用CoffeeScript的 &lt;code&gt;class&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="39b2fb1fa487e5be55b2254cc478460136f04a5f" translate="yes" xml:space="preserve">
          <source>Using DOM3 &lt;code&gt;addEventListener&lt;/code&gt; APIs (support starting from IE9+):</source>
          <target state="translated">使用DOM3 &lt;code&gt;addEventListener&lt;/code&gt; API（从IE9 +开始支持）：</target>
        </trans-unit>
        <trans-unit id="0031ac8ff26e8b6b8c4fa9f5d7c7a8c5ff06fc8d" translate="yes" xml:space="preserve">
          <source>Using ECMAScript6 generators feature to implement C# 5.0 &lt;code&gt;async/await&lt;/code&gt; like syntax.</source>
          <target state="translated">使用ECMAScript6生成器功能来实现C＃5.0 &lt;code&gt;async/await&lt;/code&gt; 语法。</target>
        </trans-unit>
        <trans-unit id="acac6fbc07a16dd7002db7cd3b214125856ce811" translate="yes" xml:space="preserve">
          <source>Using an abstraction like this the &lt;code&gt;promisePrompt&lt;/code&gt; no longer needs to know anything about the DOM and concentrates on just providing a promise. This will also make things easier to create a promised version of a progress bar or confirmation dialog or any other type of UI that we want to have a value for. All we will need to do is write a class for that dialog type with the same interface and just pass that class into our promise making method.</source>
          <target state="translated">使用这样的抽象， &lt;code&gt;promisePrompt&lt;/code&gt; 不再需要了解有关DOM的任何知识，而只专注于提供一个Promise。这也将使创建进度条或确认对话框或我们希望为其提供值的任何其他类型的UI的承诺版本更加容易。我们要做的就是为具有相同接口的对话框类型编写一个类，然后将该类传递给我们的promisemake方法。</target>
        </trans-unit>
        <trans-unit id="92e2993e6dea235a7dcb1db5bb36202c8485dbc9" translate="yes" xml:space="preserve">
          <source>Using it:</source>
          <target state="translated">使用它。</target>
        </trans-unit>
        <trans-unit id="d829b44477e34c8358b0978984bdca898183bed9" translate="yes" xml:space="preserve">
          <source>Using jQuery after:</source>
          <target state="translated">使用jQuery后。</target>
        </trans-unit>
        <trans-unit id="c991e6de4c7c9ecea657f843e9921caf549f2112" translate="yes" xml:space="preserve">
          <source>Using jQuery before:</source>
          <target state="translated">使用jQuery之前。</target>
        </trans-unit>
        <trans-unit id="ee10eda3c3f21aee43203ae597d2c13cd07e6eea" translate="yes" xml:space="preserve">
          <source>Using legacy APIs (support starting from IE6+):</source>
          <target state="translated">使用传统的API(从IE6+开始支持)。</target>
        </trans-unit>
        <trans-unit id="51f995a28f75764b72a6c79dc89d54dd724921f6" translate="yes" xml:space="preserve">
          <source>Using manual resolver:</source>
          <target state="translated">使用手动解析器。</target>
        </trans-unit>
        <trans-unit id="d99578b7705756deffc2aa58f6ae34fb2dbdb0c2" translate="yes" xml:space="preserve">
          <source>Using multiple resources:</source>
          <target state="translated">使用多种资源;</target>
        </trans-unit>
        <trans-unit id="a3f65738b0a1c42c2a41e0b59a0029999f986703" translate="yes" xml:space="preserve">
          <source>Using no hooks and using &lt;a href=&quot;api/done&quot;&gt;&lt;code&gt;.done&lt;/code&gt;&lt;/a&gt; to manually to mark end points where rejections will not be handled</source>
          <target state="translated">不使用钩子并使用&lt;a href=&quot;api/done&quot;&gt; &lt;code&gt;.done&lt;/code&gt; &lt;/a&gt;手动标记不会处理拒绝的端点</target>
        </trans-unit>
        <trans-unit id="678ad3a7449dc9211f664a6a26c9f4eeb83dd91e" translate="yes" xml:space="preserve">
          <source>Using no hooks and using &lt;a href=&quot;done&quot;&gt;&lt;code&gt;.done&lt;/code&gt;&lt;/a&gt; to manually to mark end points where rejections will not be handled</source>
          <target state="translated">不使用钩子并使用&lt;a href=&quot;done&quot;&gt; &lt;code&gt;.done&lt;/code&gt; &lt;/a&gt;手动标记不会处理拒绝的端点</target>
        </trans-unit>
        <trans-unit id="7de8d54140fb8771440fc81fb18f3d53f9f6bb4f" translate="yes" xml:space="preserve">
          <source>Using recursion to implement the example from &lt;a href=&quot;https://github.com/caolan/async#whilsttest-fn-callback&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="translated">使用递归从&lt;a href=&quot;https://github.com/caolan/async#whilsttest-fn-callback&quot;&gt;异步主页&lt;/a&gt;实现示例：</target>
        </trans-unit>
        <trans-unit id="40c7e148244964ef32867f708db116db37aa2e23" translate="yes" xml:space="preserve">
          <source>Using the same function &lt;code&gt;Promise.method&lt;/code&gt;, there is no need to manually wrap direct return or throw values into a promise:</source>
          <target state="translated">使用相同的 &lt;code&gt;Promise.method&lt;/code&gt; 函数，无需手动将直接返回值或将值扔到promise中：</target>
        </trans-unit>
        <trans-unit id="fdf3b6cb551f8ba0a6b556e915881b1d2f0aa867" translate="yes" xml:space="preserve">
          <source>Using the value &lt;code&gt;0&lt;/code&gt; will explicitly disable a feature despite debug environment otherwise activating it:</source>
          <target state="translated">尽管调试环境有效，但使用值 &lt;code&gt;0&lt;/code&gt; 将显式禁用某个功能，否则将其激活：</target>
        </trans-unit>
        <trans-unit id="6642c87a17774c8b004c1431ca83c93a48edf11b" translate="yes" xml:space="preserve">
          <source>Using webpack for development/debugging:</source>
          <target state="translated">使用webpack进行开发/调试。</target>
        </trans-unit>
        <trans-unit id="a94a8b8570fef0a3371781d1978a7c51f05ee4ff" translate="yes" xml:space="preserve">
          <source>Using webpack for production/performance:</source>
          <target state="translated">使用webpack进行生产/性能。</target>
        </trans-unit>
        <trans-unit id="89189507b2a074e98b2e877227343a6e1f27b3ab" translate="yes" xml:space="preserve">
          <source>Utility</source>
          <target state="translated">Utility</target>
        </trans-unit>
        <trans-unit id="02024b434dc6bfc227f2288a4656819d24c77710" translate="yes" xml:space="preserve">
          <source>Warn when &lt;a href=&quot;api/then&quot;&gt;&lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; is passed non-functions</source>
          <target state="translated">当&lt;a href=&quot;api/then&quot;&gt; &lt;code&gt;.then()&lt;/code&gt; &lt;/a&gt;被传递时发出警告</target>
        </trans-unit>
        <trans-unit id="76bc85fbac802c9c28a4f34074f76273aa28dba3" translate="yes" xml:space="preserve">
          <source>Warning Explanations</source>
          <target state="translated">警告说明</target>
        </trans-unit>
        <trans-unit id="e326d603e8ef33a0ace61e8bd45d1476027c27c7" translate="yes" xml:space="preserve">
          <source>Warning: .then() only accepts functions</source>
          <target state="translated">警告:.then()只接受函数</target>
        </trans-unit>
        <trans-unit id="2f253a4ff30df6ead65cd95ca2db9916033eb9d8" translate="yes" xml:space="preserve">
          <source>Warning: a promise was created in a handler but was not returned from it</source>
          <target state="translated">警告:在处理程序中创建了一个承诺,但没有从它那里返回。</target>
        </trans-unit>
        <trans-unit id="5f19b7cfb75065744f09c3f3dbd1dd8602fb5742" translate="yes" xml:space="preserve">
          <source>Warning: a promise was rejected with a non-error</source>
          <target state="translated">警告:以非错误方式拒绝了一个承诺。</target>
        </trans-unit>
        <trans-unit id="1430f976c596795274458abcfbc4f280cbfcebac" translate="yes" xml:space="preserve">
          <source>Warnings</source>
          <target state="translated">Warnings</target>
        </trans-unit>
        <trans-unit id="f9b093958e9b93291eee426980c6f76c2af8380b" translate="yes" xml:space="preserve">
          <source>Warnings about created promises that are not returned are no longer given if the handler promise has not been chained. This should reduce the amount of false positives with this warning.</source>
          <target state="translated">如果处理程序承诺没有被链起来,则不再发出关于创建的承诺没有返回的警告。这将减少该警告的误报量。</target>
        </trans-unit>
        <trans-unit id="987519cc8247ea08d785b3bed0d0edba12ab4768" translate="yes" xml:space="preserve">
          <source>Warnings have been added to report usages which are very likely to be programmer errors. See &lt;a href=&quot;api/promise.config&quot;&gt;&lt;code&gt;Promise.config&lt;/code&gt;&lt;/a&gt; for how to enable warnings. See &lt;a href=&quot;warning-explanations&quot;&gt;Warning Explanations&lt;/a&gt; for list of the warnings and their explanations.</source>
          <target state="translated">已添加警告以报告使用情况，这很可能是程序员错误。有关如何启用警告，请参见&lt;a href=&quot;api/promise.config&quot;&gt; &lt;code&gt;Promise.config&lt;/code&gt; &lt;/a&gt;。有关&lt;a href=&quot;warning-explanations&quot;&gt;警告&lt;/a&gt;及其说明的列表，请参阅警告说明。</target>
        </trans-unit>
        <trans-unit id="2346b64bd2ceb68b2dd0fe9b356367b311b6a6a1" translate="yes" xml:space="preserve">
          <source>We can do better, retaining concurrency and not leaking resources, by using:</source>
          <target state="translated">我们可以做得更好,保留并发性,不泄露资源,通过使用。</target>
        </trans-unit>
        <trans-unit id="d449d2a1898fdf6171ab397563a248fe80459a1d" translate="yes" xml:space="preserve">
          <source>We can use the promise constructor to convert it to a promise returning function:</source>
          <target state="translated">我们可以使用承诺构造函数将其转换为承诺返回函数。</target>
        </trans-unit>
        <trans-unit id="0998ac30de0c1580642c82716276399b1c613149" translate="yes" xml:space="preserve">
          <source>We will want to keep the same API so our change will be only to the &lt;code&gt;promisePrompt&lt;/code&gt;. It will find the dialog DOM elements, attach events to the elements, show the dialog box, return a promise that is resolved based on the attached events, and finally detaches the events and cleans up after itself (hiding the dialog box for another use later).</source>
          <target state="translated">我们将希望保留相同的API，以便仅对 &lt;code&gt;promisePrompt&lt;/code&gt; 进行更改。它将找到对话框DOM元素，将事件附加到元素，显示对话框，返回根据附加事件解决的Promise，最后分离事件并对其进行清理（隐藏对话框供以后使用） ）。</target>
        </trans-unit>
        <trans-unit id="86974e9cfd94347a9d8035a721441882b61e40c8" translate="yes" xml:space="preserve">
          <source>We'll cover several subjects. If you want to get the tl;dr what you need is likely the &lt;a href=&quot;#working-with-callback-apis-using-the-node-convention&quot;&gt;Working with callback APIs using the Node convention&lt;/a&gt; section.</source>
          <target state="translated">我们将涵盖几个主题。如果要获取tl; dr，则可能需要&lt;a href=&quot;#working-with-callback-apis-using-the-node-convention&quot;&gt;使用&amp;ldquo;使用节点约定&amp;rdquo;的回调API&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="41b24863fa5a051446f6f2ae3860594cb7d071eb" translate="yes" xml:space="preserve">
          <source>Well simply, when you have to.</source>
          <target state="translated">好吧简单,当你不得不这样做的时候。</target>
        </trans-unit>
        <trans-unit id="f8c4fdd7823278887156d018b49c43e024631c27" translate="yes" xml:space="preserve">
          <source>What About Generators?</source>
          <target state="translated">那发电机呢?</target>
        </trans-unit>
        <trans-unit id="30a484e5211183ba2cee4378c92b44d3105eeaf7" translate="yes" xml:space="preserve">
          <source>What about promises that have multiple consumers?</source>
          <target state="translated">那有多个消费者的承诺呢?</target>
        </trans-unit>
        <trans-unit id="6b7c4ebe4c5f3bfe7fb62f4c2a84779817b88487" translate="yes" xml:space="preserve">
          <source>What actually happens is that &lt;code&gt;result&lt;/code&gt; keeps track of how many consumers it has, in this case 2, and only if all the consumers signal cancel will the request be aborted. However, as far as &lt;code&gt;firstConsumer&lt;/code&gt; can tell, the promise was successfully cancelled and its handlers will not be called.</source>
          <target state="translated">实际发生的是，该 &lt;code&gt;result&lt;/code&gt; 将跟踪它拥有多少个使用者（在这种情况下为2），并且只有当所有使用者发出取消信号后，该请求才会被中止。但是，据 &lt;code&gt;firstConsumer&lt;/code&gt; 所知，promise已成功取消，并且不会调用其处理程序。</target>
        </trans-unit>
        <trans-unit id="07c519ceae2b771a7ddeac59daf39ed209a19525" translate="yes" xml:space="preserve">
          <source>What is the the point of promises</source>
          <target state="translated">承诺的意义何在?</target>
        </trans-unit>
        <trans-unit id="56aab8af41c28bb5f9c760d67856cb60689f1c68" translate="yes" xml:space="preserve">
          <source>What's new in 2.0</source>
          <target state="translated">2.0的新内容</target>
        </trans-unit>
        <trans-unit id="b2223542269901e7186ce7f97c69174f8009c3e4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;NODE_ENV&lt;/code&gt; environment variable is &lt;code&gt;&quot;development&quot;&lt;/code&gt; setting &lt;code&gt;BLUEBIRD_DEBUG&lt;/code&gt; environment variable to &lt;code&gt;0&lt;/code&gt; can now be used to disable debug mode</source>
          <target state="translated">现在将 &lt;code&gt;NODE_ENV&lt;/code&gt; 环境变量设置为 &lt;code&gt;&quot;development&quot;&lt;/code&gt; 将 &lt;code&gt;BLUEBIRD_DEBUG&lt;/code&gt; 环境变量设置为 &lt;code&gt;0&lt;/code&gt; ,以禁用调试模式</target>
        </trans-unit>
        <trans-unit id="268de3a5addf552f9cb9505acf541fb1a6c7d1c4" translate="yes" xml:space="preserve">
          <source>When called, the coroutine function will start an instance of the generator and returns a promise for its final value.</source>
          <target state="translated">当调用时,coroutine函数将启动一个生成器的实例,并为其最终值返回一个承诺。</target>
        </trans-unit>
        <trans-unit id="abcda78ef2264e69cff0163a190c8f4b357591ac" translate="yes" xml:space="preserve">
          <source>When chaining &lt;code&gt;.spread&lt;/code&gt;, returning an array of promises also works:</source>
          <target state="translated">链接 &lt;code&gt;.spread&lt;/code&gt; 时，返回一个promise数组也可以：</target>
        </trans-unit>
        <trans-unit id="b6c0e36e057ee58c2317285366278f58808242b8" translate="yes" xml:space="preserve">
          <source>When debugging or performing a one-time operation on a variable before passing it to a function, a return variable is forgotten.</source>
          <target state="translated">当调试或在将变量传递给函数之前对其进行一次性操作时,会忘记返回变量。</target>
        </trans-unit>
        <trans-unit id="64d8621b03578f1c94ccc629a4cc7c4de3a568ed" translate="yes" xml:space="preserve">
          <source>When there are asynchronous tasks that have the ability to notify progress as they complete it can be tempting to want that in the promise that represents that task. Unfortunately this is a bit of an anti-pattern. That is because the point of promises is to represent a value as if it was natural (like it is in normal synchronous code) and not to be over glorified callback management.</source>
          <target state="translated">当有一些异步任务能够在完成时通知进度时,很想在代表该任务的承诺中实现这一点。不幸的是,这有点反模式。这是因为承诺的重点是代表一个值,仿佛它是自然的(就像在正常的同步代码中一样),而不是过度美化的回调管理。</target>
        </trans-unit>
        <trans-unit id="b3f5f46aab39a3a9a507394c2c440bab65f0ea48" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;longStackTraces&lt;/code&gt; the first line in your code after requiring Bluebird should be:</source>
          <target state="translated">使用 &lt;code&gt;longStackTraces&lt;/code&gt; 时，在要求Bluebird之后，代码的第一行应为：</target>
        </trans-unit>
        <trans-unit id="b9be79b81b6d65c3ed9b6fe0e6688b7fd74367ea" translate="yes" xml:space="preserve">
          <source>When using script tags the global variables &lt;code&gt;Promise&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; (alias for &lt;code&gt;Promise&lt;/code&gt;) become available. Bluebird runs on a wide variety of browsers including older versions. We'd like to thank BrowserStack for giving us a free account which helps us test that.</source>
          <target state="translated">使用脚本标签时，全局变量 &lt;code&gt;Promise&lt;/code&gt; 和 &lt;code&gt;P&lt;/code&gt; （ &lt;code&gt;Promise&lt;/code&gt; 的别名）可用。Bluebird可在包括旧版本在内的各种浏览器上运行。我们要感谢BrowserStack为我们提供了一个免费的帐户，该帐户可以帮助我们进行测试。</target>
        </trans-unit>
        <trans-unit id="4a2fe4cb42752a52e254b8a6bf3ceb42b7e1ac55" translate="yes" xml:space="preserve">
          <source>When using the first signature, you may specify a custom error message with the &lt;code&gt;message&lt;/code&gt; parameter.</source>
          <target state="translated">使用第一个签名时，可以使用 &lt;code&gt;message&lt;/code&gt; 参数指定自定义错误消息。</target>
        </trans-unit>
        <trans-unit id="25f41737292fcc0beb27bde5ba12d4c02e4d5a28" translate="yes" xml:space="preserve">
          <source>When we construct our &lt;code&gt;ProgressDialog&lt;/code&gt; we use the &lt;code&gt;waitForUser()&lt;/code&gt; method to capture the user interaction promise and then use &lt;code&gt;delayedPromise()&lt;/code&gt; to capture the fake network promise and finally &lt;code&gt;Promise.reace()&lt;/code&gt; to manage the two simultaneously and end with a single promise as usual.</source>
          <target state="translated">当我们构造 &lt;code&gt;ProgressDialog&lt;/code&gt; 时,我们使用 &lt;code&gt;waitForUser()&lt;/code&gt; 方法来捕获用户交互承诺，然后使用 &lt;code&gt;delayedPromise()&lt;/code&gt; 来捕获虚假的网络承诺，最后使用 &lt;code&gt;Promise.reace()&lt;/code&gt; 来同时管理两个承诺，并像往常一样以单个承诺结尾。</target>
        </trans-unit>
        <trans-unit id="294f81c22475eef4fbaab8c79a52c780d37a7f28" translate="yes" xml:space="preserve">
          <source>When working with promises the philosophy is basically a complete opposite than when using &lt;code&gt;async&lt;/code&gt;. Async provides a huge bag of uncomposable helper functions that work at a very low level of abstraction. When using promises you can get the utility otherwise provided by uncountable amount of inflexible helper functions by just combining and composing a few existing functions and concepts.</source>
          <target state="translated">与promise一起使用时，该哲学与使用 &lt;code&gt;async&lt;/code&gt; 基本上是完全相反的。异步提供了大量无法使用的辅助函数，这些辅助函数只能在非常低的抽象级别上工作。使用Promise时，只需合并并组成一些现有功能和概念，就可以获得大量的，灵活的助手功能所提供的实用程序。</target>
        </trans-unit>
        <trans-unit id="aa0d63ddeca860f4dd0ee04e6e6dfb59036ec440" translate="yes" xml:space="preserve">
          <source>Where blocking on a Future in scala is discouraged, in JavaScript it's downright impossible.</source>
          <target state="translated">在scala中,封锁Future是不被鼓励的,而在JavaScript中则根本不可能。</target>
        </trans-unit>
        <trans-unit id="a04b5cdd0c9e7373883bf0306180ab9eff2c21cc" translate="yes" xml:space="preserve">
          <source>Which is needed in case error handlers are attached asynchronously to the promise later, which would otherwise result in premature unhandled rejection reporting.</source>
          <target state="translated">这一点是需要的,以防以后异步附加错误处理程序到承诺上,否则会导致过早的未处理拒绝报告。</target>
        </trans-unit>
        <trans-unit id="eee12cfe2d4a58cb2a6fc803d3775440ef97f722" translate="yes" xml:space="preserve">
          <source>Which would allow you to use:</source>
          <target state="translated">这将允许你使用。</target>
        </trans-unit>
        <trans-unit id="35d4fe62a5e87bc7beed2b0eec9121835e2b2243" translate="yes" xml:space="preserve">
          <source>Which would let you do:</source>
          <target state="translated">这将让你做。</target>
        </trans-unit>
        <trans-unit id="048203462f9f2ccf893052bbc1b4ea9379b53188" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;cancel().&lt;/code&gt; is synchronous - &lt;code&gt;onCancel()&lt;/code&gt; is called asynchronously (in the next turn) just like &lt;code&gt;then&lt;/code&gt; handlers.</source>
          <target state="translated">而 &lt;code&gt;cancel().&lt;/code&gt; 是同步的- 就像 &lt;code&gt;then&lt;/code&gt; 处理程序一样， &lt;code&gt;onCancel()&lt;/code&gt; 被异步调用（下一轮）。</target>
        </trans-unit>
        <trans-unit id="50051d4da0ca7d94943f9fa9969394e5949e12c1" translate="yes" xml:space="preserve">
          <source>While with long stack traces disabled, you would get:</source>
          <target state="translated">而在禁用长栈跟踪时,你会得到。</target>
        </trans-unit>
        <trans-unit id="a448f3eb7ee54eee8b460fbecc359153bf18d65f" translate="yes" xml:space="preserve">
          <source>Why I am switching to promises</source>
          <target state="translated">我为什么要改用承诺</target>
        </trans-unit>
        <trans-unit id="1472dbb2e195b22057a90d66f7a65b38461e79ba" translate="yes" xml:space="preserve">
          <source>Why Performance?</source>
          <target state="translated">为什么是性能?</target>
        </trans-unit>
        <trans-unit id="103997b340ba267b74ce431e1b85c8fb216b7d7d" translate="yes" xml:space="preserve">
          <source>Why Promises?</source>
          <target state="translated">为什么要承诺?</target>
        </trans-unit>
        <trans-unit id="7eed14a899fe9a4d5bf8f80b6404d95efa7b1db8" translate="yes" xml:space="preserve">
          <source>Why bluebird?</source>
          <target state="translated">为什么是蓝鸟?</target>
        </trans-unit>
        <trans-unit id="0f975858c19a385aa9526530dd08a5074375be2f" translate="yes" xml:space="preserve">
          <source>With the use of abstract classes can the similarities between &lt;code&gt;PromptDialog&lt;/code&gt; and &lt;code&gt;NotifyDialog&lt;/code&gt; be abstracted? Make a sub class of &lt;code&gt;Dialog&lt;/code&gt; that abstracts the common DOM code (&lt;code&gt;DOMDialog&lt;/code&gt;). Then refactor the &lt;code&gt;PromptDialog&lt;/code&gt; and &lt;code&gt;NotifyDialog&lt;/code&gt; to inherate from &lt;code&gt;DOMDialog&lt;/code&gt; but references the correct DOM selectors.</source>
          <target state="translated">通过使用抽象类，可以抽象 &lt;code&gt;PromptDialog&lt;/code&gt; 和 &lt;code&gt;NotifyDialog&lt;/code&gt; 之间的相似性吗？创建 &lt;code&gt;Dialog&lt;/code&gt; 的子类，该子类抽象出常见的DOM代码（ &lt;code&gt;DOMDialog&lt;/code&gt; ）。然后将 &lt;code&gt;PromptDialog&lt;/code&gt; 和 &lt;code&gt;NotifyDialog&lt;/code&gt; 重构为从 &lt;code&gt;DOMDialog&lt;/code&gt; 继承,但引用正确的DOM选择器。</target>
        </trans-unit>
        <trans-unit id="b389c6872f328b7947b20ae5c017fe2c10bb9526" translate="yes" xml:space="preserve">
          <source>Without arrow functions that provide lexical &lt;code&gt;this&lt;/code&gt;, the correspondence between async and sync code breaks down when writing object-oriented code. &lt;a href=&quot;bind&quot;&gt;&lt;code&gt;.bind&lt;/code&gt;&lt;/a&gt; alleviates this.</source>
          <target state="translated">如果没有提供词汇表 &lt;code&gt;this&lt;/code&gt; 的箭头功能，那么在编写面向对象的代码时，异步代码和同步代码之间的对应关系就会崩溃。&lt;a href=&quot;bind&quot;&gt; &lt;code&gt;.bind&lt;/code&gt; 可以&lt;/a&gt;缓解这种情况。</target>
        </trans-unit>
        <trans-unit id="673b91ef144006953b2d0d3e1f31a66ba0a792bd" translate="yes" xml:space="preserve">
          <source>Working with Callbacks</source>
          <target state="translated">使用回调</target>
        </trans-unit>
        <trans-unit id="4814f16d83ce4c03a7697dffe837dd35ff625c3c" translate="yes" xml:space="preserve">
          <source>Working with any other APIs</source>
          <target state="translated">与任何其他API一起工作</target>
        </trans-unit>
        <trans-unit id="d5431ac75df408d5c9ffc310217a12d8d9dcbf00" translate="yes" xml:space="preserve">
          <source>Working with browser APIs</source>
          <target state="translated">使用浏览器API</target>
        </trans-unit>
        <trans-unit id="e3c2aac0738162450c1ba5ec6b637d0caf73d2e1" translate="yes" xml:space="preserve">
          <source>Working with callback APIs using the Node convention</source>
          <target state="translated">使用Node约定的回调API工作</target>
        </trans-unit>
        <trans-unit id="37dd709d1ccc2e12457cf6c183d0dbd315ee98c2" translate="yes" xml:space="preserve">
          <source>Working with databases</source>
          <target state="translated">使用数据库</target>
        </trans-unit>
        <trans-unit id="f06f929d4baa5a3ecf78b00957e3722d031a73c3" translate="yes" xml:space="preserve">
          <source>Working with delays</source>
          <target state="translated">处理延误问题</target>
        </trans-unit>
        <trans-unit id="5122dff991374514454140bce7e200af64069d8d" translate="yes" xml:space="preserve">
          <source>Working with delays/setTimeout</source>
          <target state="translated">使用延迟/设置超时</target>
        </trans-unit>
        <trans-unit id="a1c7659f3ee1ffff84437f6bd7a29c13e55a9375" translate="yes" xml:space="preserve">
          <source>Working with one time events</source>
          <target state="translated">一次性事件的工作</target>
        </trans-unit>
        <trans-unit id="37316c9a58ae41ce75652d0e2a54b3a2feb756f2" translate="yes" xml:space="preserve">
          <source>Working with one time events.</source>
          <target state="translated">与一次性事件合作。</target>
        </trans-unit>
        <trans-unit id="8b04f9b661548e262a9e539e7d756bac07782fea" translate="yes" xml:space="preserve">
          <source>Write a function that takes a &lt;code&gt;Dialog&lt;/code&gt; instance and a default value. Have it return a promise that resolves to the default value if the user clicks cancel.</source>
          <target state="translated">编写一个带有 &lt;code&gt;Dialog&lt;/code&gt; 实例和默认值的函数。如果用户单击&amp;ldquo;取消&amp;rdquo;，它返回一个可解析为默认值的promise。</target>
        </trans-unit>
        <trans-unit id="0cf07d9d6990a0b3a8a806a431339f0ecf271176" translate="yes" xml:space="preserve">
          <source>Yield handlers are called when you yield something that is not supported by default. The first yield handler to return a promise or a thenable will be used. If no yield handler returns a promise or a thenable then an error is raised.</source>
          <target state="translated">当你产生一些默认不支持的东西时,就会调用Yield处理程序。第一个返回 promise 或 thenable 的 yield 处理程序将被使用。如果没有yield处理程序返回承诺或thenable,那么就会引发一个错误。</target>
        </trans-unit>
        <trans-unit id="cb668cd94f8eca0b469371342b38d09219dbd2d0" translate="yes" xml:space="preserve">
          <source>Yielding an array from a coroutine is not supported by default. You can use &lt;a href=&quot;api/coroutine.addyieldhandler&quot;&gt;&lt;code&gt;coroutine.addYieldHandler()&lt;/code&gt;&lt;/a&gt; to configure the old behavior (or any behavior you want).</source>
          <target state="translated">默认情况下，不支持从协程生成数组。您可以使用&lt;a href=&quot;api/coroutine.addyieldhandler&quot;&gt; &lt;code&gt;coroutine.addYieldHandler()&lt;/code&gt; &lt;/a&gt;配置旧行为（或所需的任何行为）。</target>
        </trans-unit>
        <trans-unit id="b43584c4df9052974185d0f13b0565b92e014095" translate="yes" xml:space="preserve">
          <source>You are able to yield non-promise values by adding your own yield handler using &lt;a href=&quot;promise.coroutine.addyieldhandler&quot;&gt;&lt;code&gt;Promise.coroutine.addYieldHandler&lt;/code&gt;&lt;/a&gt; or calling &lt;code&gt;Promise.coroutine()&lt;/code&gt; with a yield handler function as &lt;code&gt;options.yieldHandler&lt;/code&gt;.</source>
          <target state="translated">您可以通过使用&lt;a href=&quot;promise.coroutine.addyieldhandler&quot;&gt; &lt;code&gt;Promise.coroutine.addYieldHandler&lt;/code&gt; &lt;/a&gt;添加自己的收益处理程序或使用收益处理程序功能作为 &lt;code&gt;options.yieldHandler&lt;/code&gt; 调用 &lt;code&gt;Promise.coroutine()&lt;/code&gt; 来产生非承诺值。</target>
        </trans-unit>
        <trans-unit id="e127999f42b63c2eddd476b0efc6c0cd617fe5c2" translate="yes" xml:space="preserve">
          <source>You are getting this error because you are enabling long stack traces after a promise has already been created.</source>
          <target state="translated">之所以出现这个错误,是因为你在创建承诺后启用了长栈跟踪。</target>
        </trans-unit>
        <trans-unit id="bf62350a61d792a4742ad486033ffd83aaf0f56d" translate="yes" xml:space="preserve">
          <source>You are getting this error because you have tried to &lt;code&gt;yield&lt;/code&gt; something in a coroutine without a yield handler, for example:</source>
          <target state="translated">之所以会出现此错误，是因为您试图在没有产量处理程序的协程中 &lt;code&gt;yield&lt;/code&gt; 某些东西，例如：</target>
        </trans-unit>
        <trans-unit id="66ca93bb6eb46f59e659c6e2ebfd242ff1f0e6ac" translate="yes" xml:space="preserve">
          <source>You are getting this error when trying to use &lt;a href=&quot;api/promise.coroutine&quot;&gt;&lt;code&gt;Promise.coroutine&lt;/code&gt;&lt;/a&gt; and not passing it a generator function as a parameter. For example:</source>
          <target state="translated">尝试使用&lt;a href=&quot;api/promise.coroutine&quot;&gt; &lt;code&gt;Promise.coroutine&lt;/code&gt; &lt;/a&gt;而不将生成器函数作为参数传递给它时，您会收到此错误。例如：</target>
        </trans-unit>
        <trans-unit id="91785a774efe083e20f0a926f490793891f37e71" translate="yes" xml:space="preserve">
          <source>You can also pass the resources in an array in the first argument. In this case the handler function will only be called with one argument that is the array containing the resolved resources in respective positions in the array. Example:</source>
          <target state="translated">你也可以在第一个参数中传递数组中的资源。在这种情况下,处理函数将只调用一个参数,即包含解析资源的数组,在数组的各个位置。例子:</target>
        </trans-unit>
        <trans-unit id="e1e28c9edbfac1286ca67380518a1038c18f9339" translate="yes" xml:space="preserve">
          <source>You can also refactor some looping patterns to a more natural form that would &lt;a href=&quot;https://github.com/promises-aplus/promises-spec/issues/179&quot;&gt;leak memory when using native promises&lt;/a&gt;.</source>
          <target state="translated">您还可以将某些循环模式重构为更自然的形式，这会&lt;a href=&quot;https://github.com/promises-aplus/promises-spec/issues/179&quot;&gt;在使用本机Promise时泄漏内存&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="437864fc7461809f33ab9ef10e2c5d258352b129" translate="yes" xml:space="preserve">
          <source>You can also use it as a hook:</source>
          <target state="translated">你也可以把它当作钩子使用。</target>
        </trans-unit>
        <trans-unit id="5c5b397ce7d92f145be04aede9a7905dd3a775cc" translate="yes" xml:space="preserve">
          <source>You can also use promises to improve code that was written with callbacks:</source>
          <target state="translated">你也可以使用承诺来改进用回调编写的代码。</target>
        </trans-unit>
        <trans-unit id="283713c3baaf7fbedb1d299415d2545b4024ca50" translate="yes" xml:space="preserve">
          <source>You can change bluebird behavior globally with various environment variables. These global variables affect all instances of bluebird that are running in your environment, rather than just the one you have &lt;code&gt;require&lt;/code&gt;d in your application. The effect an environment variable has depends on the bluebird version.</source>
          <target state="translated">您可以使用各种环境变量全局更改蓝鸟行为。这些全局变量会影响环境中正在运行的所有bluebird实例，而不仅是您在应用程序中 &lt;code&gt;require&lt;/code&gt; d 实例。环境变量的作用取决于蓝鸟版本。</target>
        </trans-unit>
        <trans-unit id="06b2e22d4bf3505ebf9bddb84ee0510239a546e0" translate="yes" xml:space="preserve">
          <source>You can configure the warning for checking forgotten return statements with &lt;code&gt;wForgottenReturn&lt;/code&gt;:</source>
          <target state="translated">您可以使用 &lt;code&gt;wForgottenReturn&lt;/code&gt; 配置警告以检查忘记的返回语句：</target>
        </trans-unit>
        <trans-unit id="f5a9baad84a48a76541ea70044c4acc58a16ccf2" translate="yes" xml:space="preserve">
          <source>You can correct this by doing:</source>
          <target state="translated">你可以通过以下方式进行纠正。</target>
        </trans-unit>
        <trans-unit id="81293703b0f372c4f1dd8c1c5f5f64e0b6876c85" translate="yes" xml:space="preserve">
          <source>You can get a reference to &lt;a href=&quot;aggregateerror&quot;&gt;&lt;code&gt;AggregateError&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;Promise.AggregateError&lt;/code&gt;.</source>
          <target state="translated">您可以从 &lt;code&gt;Promise.AggregateError&lt;/code&gt; 获得对&lt;a href=&quot;aggregateerror&quot;&gt; &lt;code&gt;AggregateError&lt;/code&gt; &lt;/a&gt;的引用。</target>
        </trans-unit>
        <trans-unit id="1fa9ba97c4236ec4af4790e170f1a3227c61dec4" translate="yes" xml:space="preserve">
          <source>You can get this error for several reasons:</source>
          <target state="translated">你可能会因为几个原因而出现这个错误。</target>
        </trans-unit>
        <trans-unit id="ef442967cec8981710fc742773b5611ef039af93" translate="yes" xml:space="preserve">
          <source>You can get this error when you're trying to call &lt;code&gt;.value&lt;/code&gt; or &lt;code&gt;.error&lt;/code&gt; when inspecting a promise where the promise has not been fulfilled or rejected yet.</source>
          <target state="translated">当您在尚未兑现或拒绝承诺的情况下检查承诺时，尝试调用 &lt;code&gt;.value&lt;/code&gt; 或 &lt;code&gt;.error&lt;/code&gt; 时，会出现此错误。</target>
        </trans-unit>
        <trans-unit id="6f5a4a44a59a1f96bff1bedb0c04a482fd574dd1" translate="yes" xml:space="preserve">
          <source>You can promisify multiple classes in one go by constructing an array out of the classes and passing it to &lt;code&gt;promisifyAll&lt;/code&gt;:</source>
          <target state="translated">您可以通过在类之外构造一个数组并将其传递给 &lt;code&gt;promisifyAll&lt;/code&gt; 来一次性实现多个类：</target>
        </trans-unit>
        <trans-unit id="a9fb5d736e0ab6fce975e6a9b34a4fef475d7bc7" translate="yes" xml:space="preserve">
          <source>You got this error because you used &lt;code&gt;new Promise()&lt;/code&gt; or &lt;code&gt;new Promise(something)&lt;/code&gt; without passing a function as the parameter.</source>
          <target state="translated">之所以出现此错误，是因为您使用了 &lt;code&gt;new Promise()&lt;/code&gt; 或 &lt;code&gt;new Promise(something)&lt;/code&gt; 而没有将函数作为参数传递。</target>
        </trans-unit>
        <trans-unit id="a4d97ed3b9b528f072b3b9ef916af019f8c658c3" translate="yes" xml:space="preserve">
          <source>You got this this error because you've used &lt;code&gt;Promise.promisify&lt;/code&gt; on an object, for example:</source>
          <target state="translated">之所以出现此错误，是因为在对象上使用了 &lt;code&gt;Promise.promisify&lt;/code&gt; ，例如：</target>
        </trans-unit>
        <trans-unit id="9ca3543e4c8b58e9db66720a46ab1377349e2f9b" translate="yes" xml:space="preserve">
          <source>You may also add multiple filters for a catch handler:</source>
          <target state="translated">你也可以为一个捕获处理程序添加多个过滤器。</target>
        </trans-unit>
        <trans-unit id="83847d072bb765ac14ac4e083fdf4b485ddcd196" translate="yes" xml:space="preserve">
          <source>You may also use the custom suffix option to choose another suffix that doesn't result in conflicts.</source>
          <target state="translated">你也可以使用自定义后缀选项来选择其他不会导致冲突的后缀。</target>
        </trans-unit>
        <trans-unit id="6624c3c603bb59caba6a82386be7841487cbe7f2" translate="yes" xml:space="preserve">
          <source>You may now return promises and thenables from the filterer function used in &lt;code&gt;Promise.filter&lt;/code&gt; and &lt;code&gt;Promise.prototype.filter&lt;/code&gt;.</source>
          <target state="translated">您现在可以从 &lt;code&gt;Promise.filter&lt;/code&gt; 和 &lt;code&gt;Promise.prototype.filter&lt;/code&gt; 中使用的过滤器函数中返回promise和thenables。</target>
        </trans-unit>
        <trans-unit id="05e60416b3790827596a6ef7f2cab94aae07bff3" translate="yes" xml:space="preserve">
          <source>You may optionally prepend one predicate function or ErrorClass to pattern match the error (the generic &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; methods accepts multiple)</source>
          <target state="translated">您可以选择在一个谓词函数或ErrorClass之前添加前缀以与错误进行模式匹配（通用&lt;a href=&quot;catch&quot;&gt; &lt;code&gt;.catch&lt;/code&gt; &lt;/a&gt;方法接受多个）</target>
        </trans-unit>
        <trans-unit id="4dea303545fcf8fcdea34efebeca4ef1c0a6fbdc" translate="yes" xml:space="preserve">
          <source>You may optionally specify a concurrency limit:</source>
          <target state="translated">您可以选择性地指定并发量限制。</target>
        </trans-unit>
        <trans-unit id="1f96ba6d073dbbb822c6dc38156f5d2c778c3e34" translate="yes" xml:space="preserve">
          <source>You may register an optional cancellation hook at a root promise by using the &lt;code&gt;onCancel&lt;/code&gt; argument that is passed to the executor function when cancellation is enabled:</source>
          <target state="translated">您可以使用启用取消时传递给执行程序函数的 &lt;code&gt;onCancel&lt;/code&gt; 参数，在根目录中注册一个可选的取消挂钩：</target>
        </trans-unit>
        <trans-unit id="da7c4c4ceabe5cd66746addf080121cd0177cb25" translate="yes" xml:space="preserve">
          <source>You may use &lt;a href=&quot;api/promise.setscheduler&quot;&gt;&lt;code&gt;Promise.setScheduler&lt;/code&gt;&lt;/a&gt; to pass a custom scheduler that your environment supports. For example in DukTape:</source>
          <target state="translated">您可以使用&lt;a href=&quot;api/promise.setscheduler&quot;&gt; &lt;code&gt;Promise.setScheduler&lt;/code&gt; &lt;/a&gt;传递您的环境支持的自定义调度程序。例如在DukTape中：</target>
        </trans-unit>
        <trans-unit id="72d529e0be153c472000cf98a0b7d4552852d11f" translate="yes" xml:space="preserve">
          <source>You may use browserify on the main export</source>
          <target state="translated">您可以在主输出上使用 browserify</target>
        </trans-unit>
        <trans-unit id="5178ce348175a2d6a2e16b69f6aa6c59ef943a40" translate="yes" xml:space="preserve">
          <source>You may use the &lt;a href=&quot;http://bower.io&quot;&gt;bower&lt;/a&gt; package.</source>
          <target state="translated">您可以使用&lt;a href=&quot;http://bower.io&quot;&gt;凉亭&lt;/a&gt;包装。</target>
        </trans-unit>
        <trans-unit id="79662f72fb448baebdf8a6c7d0131a375dff4095" translate="yes" xml:space="preserve">
          <source>You might have to use a deferred object when wrapping a callback API that doesn't follow the standard convention. Like &lt;code&gt;setTimeout&lt;/code&gt;:</source>
          <target state="translated">包装不遵循标准约定的回调API时，可能必须使用延迟对象。像 &lt;code&gt;setTimeout&lt;/code&gt; 一样：</target>
        </trans-unit>
        <trans-unit id="c2ac050d03d9c2bd58543cfcee398d79f07ec7bc" translate="yes" xml:space="preserve">
          <source>You might notice that the promise approach looks very similar to using synchronous I/O:</source>
          <target state="translated">你可能会注意到,承诺的方法看起来与使用同步I/O非常相似。</target>
        </trans-unit>
        <trans-unit id="a07914b7b08162442f33327417b0ff4a50f4409e" translate="yes" xml:space="preserve">
          <source>You passed a non-function where a function was expected.</source>
          <target state="translated">你传递了一个非函数,而预期的是一个函数。</target>
        </trans-unit>
        <trans-unit id="cc81677e43359861a52ce63568e3d792c6bcee22" translate="yes" xml:space="preserve">
          <source>You should check if this promise is &lt;a href=&quot;isfulfilled&quot;&gt;&lt;code&gt;.isFulfilled()&lt;/code&gt;&lt;/a&gt; in code paths where it's not guaranteed that this promise is fulfilled.</source>
          <target state="translated">您应在不能保证实现此保证的代码路径中检查此保证是否为&lt;a href=&quot;isfulfilled&quot;&gt; &lt;code&gt;.isFulfilled()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88143ae7a4624ccb7145716c9f902897a88d096d" translate="yes" xml:space="preserve">
          <source>You should check if this promise is &lt;a href=&quot;isrejected&quot;&gt;&lt;code&gt;.isRejected()&lt;/code&gt;&lt;/a&gt; in code paths where it's guaranteed that this promise is rejected.</source>
          <target state="translated">您应在保证该承诺被拒绝的代码路径中检查此承诺是否为&lt;a href=&quot;isrejected&quot;&gt; &lt;code&gt;.isRejected()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5bc1b292604f8a755bedb0d6bdc5baa78c79e97" translate="yes" xml:space="preserve">
          <source>You should enabled long stack traces if you want better debugging experience. For example:</source>
          <target state="translated">如果你想获得更好的调试体验,你应该启用长栈跟踪。例如</target>
        </trans-unit>
        <trans-unit id="9389a4bd5323ad51b671d2380af345d329495a0f" translate="yes" xml:space="preserve">
          <source>You should heed this warning because rejecting a promise with a non-error makes debugging extremely hard and costly. Additionally, if you reject with simple primitives such as &lt;code&gt;undefined&lt;/code&gt; (commonly caused by simply calling &lt;code&gt;reject()&lt;/code&gt;) you cannot handle errors at all because it's impossible to tell from &lt;code&gt;undefined&lt;/code&gt; what exactly went wrong. All you can tell the user is that &quot;something went wrong&quot; and lose them forever.</source>
          <target state="translated">您应该留意此警告，因为拒绝无错误的承诺会使调试极其困难且成本很高。另外，如果使用诸如 &lt;code&gt;undefined&lt;/code&gt; 之类的简单原语拒绝（通常是由于简单地调用 &lt;code&gt;reject()&lt;/code&gt; 引起的），则根本无法处理错误，因为无法通过 &lt;code&gt;undefined&lt;/code&gt; 判断出到底出了什么问题。您只能告诉用户&amp;ldquo;出了点问题&amp;rdquo;，并永远失去了它们。</target>
        </trans-unit>
        <trans-unit id="ee7d769e258faced0824e928a0c2037e1a245676" translate="yes" xml:space="preserve">
          <source>You should use promises to turn this:</source>
          <target state="translated">你应该用承诺来转这个。</target>
        </trans-unit>
        <trans-unit id="3801444ae548127f53972d4de9db926d35147429" translate="yes" xml:space="preserve">
          <source>Your library can then use &lt;code&gt;var Promise = require(&quot;bluebird-extended&quot;);&lt;/code&gt; and do whatever it wants with it. Then if the application or other library uses their own bluebird promises they will all play well together because of Promises/A+ thenable assimilation magic.</source>
          <target state="translated">然后，您的库可以使用 &lt;code&gt;var Promise = require(&quot;bluebird-extended&quot;);&lt;/code&gt; 并随心所欲地做。然后，如果应用程序或其他库使用其自己的bluebird承诺，则由于Promises / A +可能的同化魔术，它们将一起很好地发挥作用。</target>
        </trans-unit>
        <trans-unit id="2ea5d7794d32ab52b93c85c9e6c21b1aea324d24" translate="yes" xml:space="preserve">
          <source>because &lt;code&gt;data&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt; at the time &lt;code&gt;.return&lt;/code&gt; is called.</source>
          <target state="translated">因为在调用 &lt;code&gt;.return&lt;/code&gt; 时 &lt;code&gt;data&lt;/code&gt; 是 &lt;code&gt;undefined&lt;/code&gt; 的。</target>
        </trans-unit>
        <trans-unit id="2c304689dc11138fde5d03ea645ecb41953e1334" translate="yes" xml:space="preserve">
          <source>bugfix</source>
          <target state="translated">bugfix</target>
        </trans-unit>
        <trans-unit id="321ef65dd8e0fe725eb1aefadf1bd87479757769" translate="yes" xml:space="preserve">
          <source>composes with other bluebird features, like &lt;a href=&quot;promise.all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与其他&lt;a href=&quot;promise.all&quot;&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;/a&gt;功能（例如Promise.all）组成。</target>
        </trans-unit>
        <trans-unit id="4b7615dce52c4c05ce4e1d374e9c61a13717ac7c" translate="yes" xml:space="preserve">
          <source>feature</source>
          <target state="translated">feature</target>
        </trans-unit>
        <trans-unit id="03e02ad7e48448605c30956ca4071a16aaf4bf8b" translate="yes" xml:space="preserve">
          <source>in the case where &lt;code&gt;value&lt;/code&gt; doesn't change its value because its binding time is different than when using a closure.</source>
          <target state="translated">在 &lt;code&gt;value&lt;/code&gt; 不改变其值的情况下，因为其绑定时间与使用闭包时不同。</target>
        </trans-unit>
        <trans-unit id="fdb19623519a22b9149620557f13925f7b42fd29" translate="yes" xml:space="preserve">
          <source>new Promise</source>
          <target state="translated">新承诺</target>
        </trans-unit>
        <trans-unit id="afbedb8dbf47bdab5c49c2b9d92015b7b3581a43" translate="yes" xml:space="preserve">
          <source>new Promise()</source>
          <target state="translated">new Promise()</target>
        </trans-unit>
        <trans-unit id="558916e0aef77e0a7a2bbe15ca31648114109299" translate="yes" xml:space="preserve">
          <source>no setup code required to make cancellation work</source>
          <target state="translated">无需设置代码即可取消工作</target>
        </trans-unit>
        <trans-unit id="4397a4d17f5c537ce4e705bcaf7b0efdd50c51d6" translate="yes" xml:space="preserve">
          <source>reasonable semantics for multiple consumer cancellation</source>
          <target state="translated">多次消费取消的合理语义</target>
        </trans-unit>
        <trans-unit id="748bc7560ff57854e11d5ab937864f0ff100bb12" translate="yes" xml:space="preserve">
          <source>resolving it with itself tells it &quot;it is done when it is done&quot;</source>
          <target state="translated">用自己来解决它,告诉它 &quot;解决了就解决了&quot;</target>
        </trans-unit>
        <trans-unit id="9379d4b4f4ef9775cb3c71402acd9e3e7970ea7f" translate="yes" xml:space="preserve">
          <source>throw TypeError when thenable resolves with itself</source>
          <target state="translated">当thenable与自身解析时,抛出TypeError。</target>
        </trans-unit>
        <trans-unit id="44176cf9434e38d37133324ac3fb90ae6fc35afd" translate="yes" xml:space="preserve">
          <source>~~Promise.longStackTraces~~</source>
          <target state="translated">~~Promise.longStackTraces~~</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
