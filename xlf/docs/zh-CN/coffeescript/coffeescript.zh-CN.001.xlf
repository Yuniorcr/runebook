<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="coffeescript">
    <body>
      <group id="coffeescript">
        <trans-unit id="e11557a88106e7fe5bb613921c6f637bccd31989" translate="yes" xml:space="preserve">
          <source>%%</source>
          <target state="translated">%%</target>
        </trans-unit>
        <trans-unit id="7ccf396b1e0174237c52a3c6bc495b340169bd3c" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2009&amp;ndash;2018 Jeremy Ashkenas</source>
          <target state="translated">分级为4 +&amp;copy;2009&amp;ndash;2018 Jeremy Ashkenas</target>
        </trans-unit>
        <trans-unit id="e00eab0c44161a5c6e125f234cee4992a6fcd8e4" translate="yes" xml:space="preserve">
          <source>&amp;hellip;and object properties.</source>
          <target state="translated">&amp;hellip;以及对象属性。</target>
        </trans-unit>
        <trans-unit id="73dd43829ef8eae899eaf52c55d9ad5b84c8821f" translate="yes" xml:space="preserve">
          <source>&amp;quot;text/coffeescript&amp;quot; Script Tags</source>
          <target state="translated">&amp;ldquo;文本/咖啡&amp;rdquo;脚本标签</target>
        </trans-unit>
        <trans-unit id="bc2f74c22f98f7b6ffbc2f67453dbfa99bce9a32" translate="yes" xml:space="preserve">
          <source>**</source>
          <target state="translated">**</target>
        </trans-unit>
        <trans-unit id="ebbffb7d7ea5362a22bfa1bab0bfdeb1617cd610" translate="yes" xml:space="preserve">
          <source>//</source>
          <target state="translated">//</target>
        </trans-unit>
        <trans-unit id="53f56e39c6568e87ed693f2d221db24632d7aa00" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#modules&quot;&gt;Modules&lt;/a&gt; and &lt;a href=&quot;#jsx&quot;&gt;JSX&lt;/a&gt; always require transpilation.</source>
          <target state="translated">&lt;a href=&quot;#modules&quot;&gt;模块&lt;/a&gt;和&lt;a href=&quot;#jsx&quot;&gt;JSX&lt;/a&gt;始终需要进行翻译。</target>
        </trans-unit>
        <trans-unit id="2b5a9a675a7d370676eff4f216883a2020ccc476" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://coffeescript.org/#splats&quot;&gt;Splats, a.k.a. object rest/spread syntax, for objects&lt;/a&gt; are supported by Node 8.6+.</source>
          <target state="translated">&lt;a href=&quot;https://coffeescript.org/#splats&quot;&gt;&lt;/a&gt;Node 8.6+支持对象的Splats（又名对象剩余/扩展语法）。</target>
        </trans-unit>
        <trans-unit id="7f2498c383e4e6502a04279ccad6e370f86b3e20" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports&quot;&gt;Dynamic import&lt;/a&gt; is also supported, with mandatory parentheses:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports&quot;&gt;&lt;/a&gt;还支持动态导入，并带有强制括号：</target>
        </trans-unit>
        <trans-unit id="f82ee4d52cb6f66ab432c78025692d4f93c8400d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/react/docs/introducing-jsx.html&quot;&gt;JSX&lt;/a&gt; is JavaScript containing interspersed XML elements. While conceived for &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt;, it is not specific to any particular library or framework.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/react/docs/introducing-jsx.html&quot;&gt;JSX&lt;/a&gt;是包含散布的XML元素的JavaScript。虽然是为&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React设计的&lt;/a&gt;，但它并不特定于任何特定的库或框架。</target>
        </trans-unit>
        <trans-unit id="5ab0d5c504f451bb7b8744a031b2895facf00809" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;Async generator functions&lt;/a&gt; are supported by Node 10+.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;&lt;/a&gt;节点10+支持异步生成器功能。</target>
        </trans-unit>
        <trans-unit id="3eea75d33a4b7141282062785cc396fb0821bbd2" translate="yes" xml:space="preserve">
          <source>&lt;code id=&quot;this&quot;&gt;@&lt;/code&gt;, &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;this&quot;&gt;@&lt;/code&gt; ， &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6bddde52d2ce96695935a88af3457fe562602600" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;text/coffeescript&quot;&lt;/code&gt; Script Tags</source>
          <target state="translated">&lt;code&gt;&quot;text/coffeescript&quot;&lt;/code&gt; 脚本标签</target>
        </trans-unit>
        <trans-unit id="4f3b179798446cf0398649b8ad3d668bf9055a6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--bare&lt;/code&gt; and &lt;code&gt;--no-header&lt;/code&gt; are important because Flow requires the first line of the file to be the comment &lt;code&gt;// @flow&lt;/code&gt;. If you configure your build chain to compile CoffeeScript and pass the result to Flow in-memory, you can get better performance than this example; and a proper build tool should be able to watch your CoffeeScript files and recompile and type-check them for you on save.</source>
          <target state="translated">&lt;code&gt;--bare&lt;/code&gt; 和 &lt;code&gt;--no-header&lt;/code&gt; 很重要，因为Flow要求文件的第一行是注释 &lt;code&gt;// @flow&lt;/code&gt; 。如果将构建链配置为编译CoffeeScript并将结果传递给Flow in-memory，则可以获得比本示例更好的性能；请参见图5。并且适当的构建工具应该能够监视您的CoffeeScript文件并重新编译并在保存时为您进行类型检查。</target>
        </trans-unit>
        <trans-unit id="4d635daf3b49933b2580d4b7f115dbf3f7192ece" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a?(b, c)&lt;/code&gt; or &lt;code&gt;a? b, c&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a?(b, c)&lt;/code&gt; 或 &lt;code&gt;a? b, c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b195b055ae12191320d58268dcf96e63ba61e34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a?.b&lt;/code&gt; or &lt;code&gt;a?['b']&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a?.b&lt;/code&gt; 或 &lt;code&gt;a?['b']&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f26a6ff56f6f4d1453881906a2fedcfdf70a4192" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;console.log sys.inspect object&lt;/code&gt; &amp;rarr; &lt;code&gt;console.log(sys.inspect(object));&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;console.log sys.inspect object&lt;/code&gt; &amp;rarr; &lt;code&gt;console.log(sys.inspect(object));&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="671572b1210bb1454fe66f9c4630dc77eb820b08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt;, &lt;code&gt;no&lt;/code&gt;, &lt;code&gt;off&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; ， &lt;code&gt;no&lt;/code&gt; ， &lt;code&gt;off&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08092e8ae424c160938c270677dd88a77a69c59c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; keyword shorthand syntax</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 关键字速记语法</target>
        </trans-unit>
        <trans-unit id="6797ae36e87fa19e1efa9483eaa78cd02c6979d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;, as keywords preceding functions or class methods, are intentionally unimplemented in CoffeeScript.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 作为函数或类方法之前的关键字，在CoffeeScript中有意未实现。</target>
        </trans-unit>
        <trans-unit id="b4e24c06746537f3bcc316c7b684e6a1288745a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; statements can be written without the use of parentheses and curly brackets. As with functions and other block expressions, multi-line conditionals are delimited by indentation. There&amp;rsquo;s also a handy postfix form, with the &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;unless&lt;/code&gt; at the end.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; 语句可以不使用括号和大括号来编写。与函数和其他块表达式一样，多行条件由缩进分隔。还有一个方便的后缀形式，结尾是 &lt;code&gt;if&lt;/code&gt; 或 &lt;code&gt;unless&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c898449ed9c27c9ce84efe5f7a1f6fed9d1a6120" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; add a useful ability to JavaScript in that you can use them to declare variables within a &lt;em&gt;block&lt;/em&gt; scope, for example within an &lt;code&gt;if&lt;/code&gt; statement body or a &lt;code&gt;for&lt;/code&gt; loop body, whereas &lt;code&gt;var&lt;/code&gt; always declares variables in the scope of an entire function. When CoffeeScript 2 was designed, there was much discussion of whether this functionality was useful enough to outweigh the simplicity offered by never needing to consider variable declaration in CoffeeScript. In the end, it was decided that the simplicity was more valued. In CoffeeScript there remains only one type of variable.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 为JavaScript添加了有用的功能，因为您可以使用它们在&lt;em&gt;块&lt;/em&gt;范围内声明变量，例如在 &lt;code&gt;if&lt;/code&gt; 语句主体或 &lt;code&gt;for&lt;/code&gt; 循环主体中声明变量，而 &lt;code&gt;var&lt;/code&gt; 始终在整个函数范围内声明变量。在设计CoffeeScript 2时，围绕此功能是否足够有用而超过了从不考虑在CoffeeScript中考虑变量声明所提供的简单性的讨论很多。最后，我们决定更加重视简单性。在CoffeeScript中，仅保留一种类型的变量。</target>
        </trans-unit>
        <trans-unit id="0d755861b046842e4e015fd91408805286afea66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;: block-scoped and reassignment-protected variables</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; ：块作用域和重新分配保护的变量</target>
        </trans-unit>
        <trans-unit id="69bdd67b5f2fb2b4bc55bed7c7cf382b91714c45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options.bare&lt;/code&gt;, boolean: if true, output without the &lt;a href=&quot;#lexical-scope&quot;&gt;top-level function safety wrapper&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;options.bare&lt;/code&gt; ，boolean：如果为true，则输出不包含&lt;a href=&quot;#lexical-scope&quot;&gt;顶级函数安全包装器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e88224b1d5d85954af2e05694587845ce15ef6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options.filename&lt;/code&gt;, string: the filename to use for the source map. It can include a path (relative or absolute).</source>
          <target state="translated">&lt;code&gt;options.filename&lt;/code&gt; ，字符串：用于源映射的文件名。它可以包含路径（相对或绝对）。</target>
        </trans-unit>
        <trans-unit id="0668f9660893b6c173226ef928d6f8c135d49c5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options.header&lt;/code&gt;, boolean: if true, output the &lt;code&gt;Generated by CoffeeScript&lt;/code&gt; header.</source>
          <target state="translated">&lt;code&gt;options.header&lt;/code&gt; ，boolean：如果为true，则输出 &lt;code&gt;Generated by CoffeeScript&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="5d11ef802af0f76e518643ed277b582fea058806" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options.inlineMap&lt;/code&gt;, boolean: if true, output the source map as a base64-encoded string in a comment at the bottom.</source>
          <target state="translated">&lt;code&gt;options.inlineMap&lt;/code&gt; ，布尔值：如果为true，则在底部的注释中将源地图输出为base64编码的字符串。</target>
        </trans-unit>
        <trans-unit id="0e70b1c0b6768b86125fef4bd20eb872934d31f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options.sourceMap&lt;/code&gt;, boolean: if true, a source map will be generated; and instead of returning a string, &lt;code&gt;compile&lt;/code&gt; will return an object of the form &lt;code&gt;{js, v3SourceMap, sourceMap}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;options.sourceMap&lt;/code&gt; ，boolean：如果为true，将生成源映射；否则为false。并且 &lt;code&gt;compile&lt;/code&gt; 不会返回字符串，而是会返回 &lt;code&gt;{js, v3SourceMap, sourceMap}&lt;/code&gt; 形式的对象。</target>
        </trans-unit>
        <trans-unit id="bd359cce40eaca31c9f0f745fb688f4ff5606e6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options.transpile&lt;/code&gt;, &lt;strong&gt;object&lt;/strong&gt;: if set, this must be an object with the &lt;a href=&quot;https://babeljs.io/docs/usage/api/#options&quot;&gt;options to pass to Babel&lt;/a&gt;. See &lt;a href=&quot;#transpilation&quot;&gt;Transpilation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;options.transpile&lt;/code&gt; ，&lt;strong&gt;object&lt;/strong&gt;：如果设置，则必须是一个带有&lt;a href=&quot;https://babeljs.io/docs/usage/api/#options&quot;&gt;选项&lt;/a&gt;的对象，该选项可以传递给Babel。参见&lt;a href=&quot;#transpilation&quot;&gt;翻译&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="42ddf3bee0d00b958b57a4f0c778746594dce840" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;require()&lt;/code&gt; the given module before starting the REPL or evaluating the code given with the &lt;code&gt;--eval&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;require()&lt;/code&gt; 在启动REPL或评估带有 &lt;code&gt;--eval&lt;/code&gt; 标志的给定代码之前，require（）给定模块。</target>
        </trans-unit>
        <trans-unit id="da337d04d46816ce3f960cc13a8c58049d709032" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;super&lt;/code&gt; and &lt;code&gt;extends&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;super&lt;/code&gt; 和 &lt;code&gt;extends&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f91468df92b13b248660811a65d1664a64a85a87" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;super&lt;/code&gt; and &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;super&lt;/code&gt; 和 &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="febc77da193c1450f3079a54b815c08cfb84cae7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switch&lt;/code&gt; statements can also be used without a control expression, turning them in to a cleaner alternative to &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; chains.</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 语句也可以在没有控制表达式的情况下使用，将它们替换为 &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; 链的更干净的替代方法。</target>
        </trans-unit>
        <trans-unit id="f14836fb2c4f448ff7f89a8d54a114f65adceb8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switch&lt;/code&gt; statements in JavaScript are a bit awkward. You need to remember to &lt;code&gt;break&lt;/code&gt; at the end of every &lt;code&gt;case&lt;/code&gt; statement to avoid accidentally falling through to the default case. CoffeeScript prevents accidental fall-through, and can convert the &lt;code&gt;switch&lt;/code&gt; into a returnable, assignable expression. The format is: &lt;code&gt;switch&lt;/code&gt; condition, &lt;code&gt;when&lt;/code&gt; clauses, &lt;code&gt;else&lt;/code&gt; the default case.</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; JavaScript中的switch语句有点尴尬。您需要记住，在每个 &lt;code&gt;case&lt;/code&gt; 语句的末尾都要 &lt;code&gt;break&lt;/code&gt; ，以免意外掉入默认大小写。CoffeeScript可以防止意外掉线，并且可以将 &lt;code&gt;switch&lt;/code&gt; 转换为可返回的可分配表达式。格式为： &lt;code&gt;switch&lt;/code&gt; 条件， &lt;code&gt;when&lt;/code&gt; 子句， &lt;code&gt;else&lt;/code&gt; 为默认情况。</target>
        </trans-unit>
        <trans-unit id="beb8408aed5d5e0b2e7958d3840c0f622534b644" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;yes&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; ， &lt;code&gt;yes&lt;/code&gt; ， &lt;code&gt;on&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4cfd4f6560eea48a3bbb6452c625b3643616abf4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;try&lt;/code&gt; expressions have the same semantics as &lt;code&gt;try&lt;/code&gt; statements in JavaScript, though in CoffeeScript, you may omit &lt;em&gt;both&lt;/em&gt; the catch and finally parts. The catch part may also omit the error parameter if it is not needed.</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 词汇具有相同的语义 &lt;code&gt;try&lt;/code&gt; 在JavaScript语句，尽管在CoffeeScript中，你可能会忽略&lt;em&gt;两者&lt;/em&gt;的渔获物和最后部分。如果不需要，捕获部分也可以忽略错误参数。</target>
        </trans-unit>
        <trans-unit id="4068635871de89a0425d7ae15c3ee28c166fda6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unless&lt;/code&gt; can be used as the inverse of &lt;code&gt;if&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;unless&lt;/code&gt; 可以用作 &lt;code&gt;if&lt;/code&gt; 的逆函数。</target>
        </trans-unit>
        <trans-unit id="146594e8060979ead0f6d28256eb4ef1779d3dcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield*&lt;/code&gt; is called &lt;code&gt;yield from&lt;/code&gt;, and &lt;code&gt;yield return&lt;/code&gt; may be used if you need to force a generator that doesn&amp;rsquo;t yield.</source>
          <target state="translated">&lt;code&gt;yield*&lt;/code&gt; 称为 &lt;code&gt;yield from&lt;/code&gt; ，如果需要强制生成不屈服的生成器，则可以使用 &lt;code&gt;yield return&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eea76de22707204f2de04392630e2b08c9b49475" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;CoffeeScript on the topleft, compiled JavaScript output on the bottomright. The CoffeeScript is editable!&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;左上方的CoffeeScript，右下方的已编译JavaScript输出。CoffeeScript是可编辑的！&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7315b2762c97737d5039c4b20d8a25a1b9ad4687" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Many of the examples can be run (where it makes sense) by pressing the&lt;/em&gt;&lt;small&gt;▶&lt;/small&gt;&lt;em&gt;button on the right. The CoffeeScript on the left is editable, and the JavaScript will update as you edit.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;通过按&lt;/em&gt;&lt;em&gt;右侧&lt;/em&gt;&lt;em&gt;的&lt;/em&gt;&lt;small&gt;▶ &lt;/small&gt;&lt;em&gt;按钮，&lt;/em&gt;&lt;em&gt;可以运行许多示例（有意义的示例）&lt;/em&gt;&lt;em&gt;。左侧的CoffeeScript是可编辑的，并且JavaScript将在您编辑时更新。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c277fcd54562e2635bc26a8132a87027a7d6a56f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This reference is structured so that it can be read from top to bottom, if you like. Later sections use ideas and syntax previously introduced. Familiarity with JavaScript is assumed. In all of the following examples, the source CoffeeScript is provided on the left, and the direct compilation into JavaScript is on the right.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;该参考文件的结构使其可以根据需要从上至下阅读。后面的部分将使用先前介绍的思想和语法。假定您熟悉JavaScript。在以下所有示例中，左侧提供源CoffeeScript，右侧提供直接编译为JavaScript的代码。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a3e61d6a409d40b1cc7e66218d36a04024655912" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CoffeeScript is a little language that compiles into JavaScript.&lt;/strong&gt; Underneath that awkward Java-esque patina, JavaScript has always had a gorgeous heart. CoffeeScript is an attempt to expose the good parts of JavaScript in a simple way.</source>
          <target state="translated">&lt;strong&gt;CoffeeScript是一种可编译为JavaScript的小语言。&lt;/strong&gt;在那尴尬的Java风格的铜绿之下，JavaScript一直有着一颗华丽的心。CoffeeScript试图以简单的方式公开JavaScript的优秀部分。</target>
        </trans-unit>
        <trans-unit id="3a49dc083df4f29ffc84eceec33918bc2ac078a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Latest Version:&lt;/strong&gt;&lt;a href=&quot;https://github.com/jashkenas/coffeescript/tarball/2.4.1&quot;&gt;2.4.1&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;最新版本：&lt;/strong&gt;&lt;a href=&quot;https://github.com/jashkenas/coffeescript/tarball/2.4.1&quot;&gt;2.4.1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9a78211436f6d425ec38f5c4e02270801f3524f8" translate="yes" xml:space="preserve">
          <source>@</source>
          <target state="translated">@</target>
        </trans-unit>
        <trans-unit id="749387032ae04dba9bbbf8a243b19977245cf1a6" translate="yes" xml:space="preserve">
          <source>A few caveats:</source>
          <target state="translated">一些注意事项。</target>
        </trans-unit>
        <trans-unit id="2992ef6e06f5285c1589f15bbd6cdefabccc9e93" translate="yes" xml:space="preserve">
          <source>All together now, watch and recompile an entire project as you work on it:</source>
          <target state="translated">现在都在一起了,边看边重新编译整个项目。</target>
        </trans-unit>
        <trans-unit id="ef9a81eb41028081130a2daf5219d439c4552d2b" translate="yes" xml:space="preserve">
          <source>All together now:</source>
          <target state="translated">现在都在一起了。</target>
        </trans-unit>
        <trans-unit id="de911cf89f46bf4aab8399057a0b6f4d24430428" translate="yes" xml:space="preserve">
          <source>Along those lines, code blocks within list items or blockquotes are not treated as executable code. Since list items and blockquotes imply their own indentation, it would be ambiguous how to treat indentation between successive code blocks when some are within these other blocks and some are not.</source>
          <target state="translated">按照这些思路,列表项或块引号内的代码块不被视为可执行代码。由于列表项和方块引号意味着它们自己的缩进,因此,当一些代码块在这些其他代码块中,而一些不在这些代码块中时,如何处理连续代码块之间的缩进就会很模糊。</target>
        </trans-unit>
        <trans-unit id="f205799358de5de3653ec6932d7fc9cc5631d19a" translate="yes" xml:space="preserve">
          <source>Also note that any file with an &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; statement will be output without a &lt;a href=&quot;#lexical-scope&quot;&gt;top-level function safety wrapper&lt;/a&gt;; in other words, importing or exporting modules will automatically trigger &lt;a href=&quot;#usage&quot;&gt;bare&lt;/a&gt; mode for that file. This is because per the ES2015 spec, &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; statements must occur at the topmost scope.</source>
          <target state="translated">还要注意，任何带有 &lt;code&gt;import&lt;/code&gt; 或 &lt;code&gt;export&lt;/code&gt; 语句的文件都将在没有&lt;a href=&quot;#lexical-scope&quot;&gt;顶级功能安全包装器的&lt;/a&gt;情况下输出；换句话说，导入或导出模块将自动触发该文件的&lt;a href=&quot;#usage&quot;&gt;裸&lt;/a&gt;模式。这是因为根据ES2015规范， &lt;code&gt;import&lt;/code&gt; 或 &lt;code&gt;export&lt;/code&gt; 语句必须出现在最顶层。</target>
        </trans-unit>
        <trans-unit id="8d8c347317a31c9b96b2eb66a2e233fab6fd3515" translate="yes" xml:space="preserve">
          <source>Although suppressed within this documentation for clarity, all CoffeeScript output (except in files with &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; statements) is wrapped in an anonymous function: &lt;code&gt;(function(){ &amp;hellip; })();&lt;/code&gt;. This safety wrapper, combined with the automatic generation of the &lt;code&gt;var&lt;/code&gt; keyword, make it exceedingly difficult to pollute the global namespace by accident. (The safety wrapper can be disabled with the &lt;a href=&quot;#usage&quot;&gt;&lt;code&gt;bare&lt;/code&gt; option&lt;/a&gt;, and is unnecessary and automatically disabled when using modules.)</source>
          <target state="translated">尽管为了清楚起见在本文档中进行了抑制，但所有CoffeeScript输出（带有 &lt;code&gt;import&lt;/code&gt; 或 &lt;code&gt;export&lt;/code&gt; 语句的文件除外）都包装在匿名函数中： &lt;code&gt;(function(){ &amp;hellip; })();&lt;/code&gt; 。此安全包装程序与 &lt;code&gt;var&lt;/code&gt; 关键字的自动生成相结合，使得意外污染全局名称空间极为困难。（可以使用&lt;a href=&quot;#usage&quot;&gt; &lt;code&gt;bare&lt;/code&gt; 选项&lt;/a&gt;禁用安全包装，并且不需要，并且在使用模块时会自动禁用。）</target>
        </trans-unit>
        <trans-unit id="d1862e82363559b6fb9a22118afd3352933e73f2" translate="yes" xml:space="preserve">
          <source>Argument parsing and shebang (&lt;code&gt;#!&lt;/code&gt;) lines</source>
          <target state="translated">参数解析和shebang（ &lt;code&gt;#!&lt;/code&gt; ）行</target>
        </trans-unit>
        <trans-unit id="65f9c0eea18b31eb35e30364b4d18f13f72f3e80" translate="yes" xml:space="preserve">
          <source>Arguments can be forwarded explicitly using splats:</source>
          <target state="translated">可以使用splats明确转发参数。</target>
        </trans-unit>
        <trans-unit id="bc8d4bce0a86d2f62284d889ea176cb257eb81cf" translate="yes" xml:space="preserve">
          <source>Array Slicing and Splicing with Ranges</source>
          <target state="translated">阵列切片和使用范围的拼接。</target>
        </trans-unit>
        <trans-unit id="9ba9135f5143cdbcf8f067d358d2f101a0291868" translate="yes" xml:space="preserve">
          <source>As a shortcut for &lt;code&gt;this.property&lt;/code&gt;, you can use &lt;code&gt;@property&lt;/code&gt;.</source>
          <target state="translated">作为一个快捷方式 &lt;code&gt;this.property&lt;/code&gt; ，您可以使用 &lt;code&gt;@property&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d5ff33811e35eec43fb0c6d044ee1aebaa01617" translate="yes" xml:space="preserve">
          <source>As in &lt;a href=&quot;http://yaml.org/&quot;&gt;YAML&lt;/a&gt;, &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;yes&lt;/code&gt; are the same as boolean &lt;code&gt;true&lt;/code&gt;, while &lt;code&gt;off&lt;/code&gt; and &lt;code&gt;no&lt;/code&gt; are boolean &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">与&lt;a href=&quot;http://yaml.org/&quot;&gt;YAML一样&lt;/a&gt;， &lt;code&gt;on&lt;/code&gt; 和 &lt;code&gt;yes&lt;/code&gt; 与boolean &lt;code&gt;true&lt;/code&gt; 相同，而 &lt;code&gt;off&lt;/code&gt; 和 &lt;code&gt;no&lt;/code&gt; 则为布尔 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c940962594d626d789e7139cf6327778f46a3c66" translate="yes" xml:space="preserve">
          <source>As in Ruby, &lt;code&gt;switch&lt;/code&gt; statements in CoffeeScript can take multiple values for each &lt;code&gt;when&lt;/code&gt; clause. If any of the values match, the clause runs.</source>
          <target state="translated">与Ruby中一样，CoffeeScript中的 &lt;code&gt;switch&lt;/code&gt; 语句可以为每个 &lt;code&gt;when&lt;/code&gt; 子句采用多个值。如果任何值匹配，则该子句运行。</target>
        </trans-unit>
        <trans-unit id="785872c21d2152c8e487aa14ed3c436575fb2e25" translate="yes" xml:space="preserve">
          <source>As well as silly things, like passing a &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; statement directly into a function call:</source>
          <target state="translated">除了愚蠢的事情外，例如将 &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 语句直接传递给函数调用：</target>
        </trans-unit>
        <trans-unit id="e17003d05d795ba33cb9b8fb93fce1a1e17abcdc" translate="yes" xml:space="preserve">
          <source>Async Functions</source>
          <target state="translated">异步函数</target>
        </trans-unit>
        <trans-unit id="baaf2143528768ba7feea8a142baf40647bed225" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;==&lt;/code&gt; operator frequently causes undesirable coercion, is intransitive, and has a different meaning than in other languages, CoffeeScript compiles &lt;code&gt;==&lt;/code&gt; into &lt;code&gt;===&lt;/code&gt;, and &lt;code&gt;!=&lt;/code&gt; into &lt;code&gt;!==&lt;/code&gt;. In addition, &lt;code&gt;is&lt;/code&gt; compiles into &lt;code&gt;===&lt;/code&gt;, and &lt;code&gt;isnt&lt;/code&gt; into &lt;code&gt;!==&lt;/code&gt;.</source>
          <target state="translated">因为 &lt;code&gt;==&lt;/code&gt; 运算符经常引起不期望的强制性，是不透明的，并且具有与其他语言不同的含义，因此CoffeeScript将 &lt;code&gt;==&lt;/code&gt; 编译为 &lt;code&gt;===&lt;/code&gt; ，并将 &lt;code&gt;!=&lt;/code&gt; 编译为 &lt;code&gt;!==&lt;/code&gt; 。此外， &lt;code&gt;is&lt;/code&gt; 编译成 &lt;code&gt;===&lt;/code&gt; ，和 &lt;code&gt;isnt&lt;/code&gt; 成 &lt;code&gt;!==&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48eae9d012f5bd3812c09f9e579487b2ac854c74" translate="yes" xml:space="preserve">
          <source>Because variable declarations occur at the top of scope, assignment can be used within expressions, even for variables that haven&amp;rsquo;t been seen before:</source>
          <target state="translated">由于变量声明出现在作用域的顶部，因此可以在表达式中使用赋值，即使对于以前从未见过的变量也是如此：</target>
        </trans-unit>
        <trans-unit id="6a73ea1c2b90501e9d317af3a06faec56721a224" translate="yes" xml:space="preserve">
          <source>Because you don&amp;rsquo;t have direct access to the &lt;code&gt;var&lt;/code&gt; keyword, it&amp;rsquo;s impossible to shadow an outer variable on purpose, you may only refer to it. So be careful that you&amp;rsquo;re not reusing the name of an external variable accidentally, if you&amp;rsquo;re writing a deeply nested function.</source>
          <target state="translated">因为您没有直接访问 &lt;code&gt;var&lt;/code&gt; 关键字的权限，所以不可能故意屏蔽外部变量，您只能引用它。因此，请注意，如果要编写深层嵌套的函数，请不要误用外部变量的名称。</target>
        </trans-unit>
        <trans-unit id="500d6e30307a158cda828a2b4b51aff3d203b972" translate="yes" xml:space="preserve">
          <source>Besides being used as an ordinary programming language, CoffeeScript may also be written in &amp;ldquo;literate&amp;rdquo; mode. If you name your file with a &lt;code&gt;.litcoffee&lt;/code&gt; extension, you can write it as a Markdown document &amp;mdash; a document that also happens to be executable CoffeeScript code. The compiler will treat any indented blocks (Markdown&amp;rsquo;s way of indicating source code) as executable code, and ignore the rest as comments. Code blocks must also be separated from comments by at least one blank line.</source>
          <target state="translated">除了用作普通编程语言外，CoffeeScript还可以以&amp;ldquo;识字&amp;rdquo;模式编写。如果使用 &lt;code&gt;.litcoffee&lt;/code&gt; 扩展名命名文件，则可以将其写为Markdown文档-该文档也恰好是可执行的CoffeeScript代码。编译器会将任何缩进的块（Markdown指示源代码的方式）都视为可执行代码，其余部分则视为注释。代码块也必须与注释之间至少留空一行。</target>
        </trans-unit>
        <trans-unit id="52c6757f76d4c59aa1a2f5c458ff43e37ce42012" translate="yes" xml:space="preserve">
          <source>Block Regular Expressions</source>
          <target state="translated">阻止正则表达式</target>
        </trans-unit>
        <trans-unit id="88e6d3a6135787b6b130ff7bc9cdd589be5f2a49" translate="yes" xml:space="preserve">
          <source>Block strings, delimited by &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; or &lt;code&gt;'''&lt;/code&gt;, can be used to hold formatted or indentation-sensitive text (or, if you just don&amp;rsquo;t feel like escaping quotes and apostrophes). The indentation level that begins the block is maintained throughout, so you can keep it all aligned with the body of your code.</source>
          <target state="translated">块字符串，以 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 或 &lt;code&gt;'''&lt;/code&gt; 分隔，可用于保存格式化或缩进敏感的文本（或者，如果您只是不想转义引号和撇号），将保持开始该块的缩进级别整个过程，因此您可以使其与代码主体保持一致。</target>
        </trans-unit>
        <trans-unit id="0860d71a0ec2e658f3d9a3738433ca07ec8f0787" translate="yes" xml:space="preserve">
          <source>Bound (Fat Arrow) Functions</source>
          <target state="translated">绑定(胖箭头)功能</target>
        </trans-unit>
        <trans-unit id="c0919393bb78439cc6bdad954e816bfa9e7b5395" translate="yes" xml:space="preserve">
          <source>Bound (fat arrow) functions</source>
          <target state="translated">绑定(胖箭头)功能</target>
        </trans-unit>
        <trans-unit id="3146c3bce8a6f3c5954cf4d17548170dd8fa9a5d" translate="yes" xml:space="preserve">
          <source>Bound generator functions</source>
          <target state="translated">绑定生成器功能</target>
        </trans-unit>
        <trans-unit id="66a99a10fccdc00a933b3a257862c3f84baadadd" translate="yes" xml:space="preserve">
          <source>Bound generator functions, a.k.a. generator arrow functions, &lt;a href=&quot;https://stackoverflow.com/questions/27661306/can-i-use-es6s-arrow-function-syntax-with-generators-arrow-notation&quot;&gt;aren&amp;rsquo;t allowed in ECMAScript&lt;/a&gt;. You can write &lt;code&gt;function*&lt;/code&gt; or &lt;code&gt;=&amp;gt;&lt;/code&gt;, but not both. Therefore, CoffeeScript code like this:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/27661306/can-i-use-es6s-arrow-function-syntax-with-generators-arrow-notation&quot;&gt;ECMAScript中不允许&lt;/a&gt;绑定生成器函数（也称为生成器箭头函数）。您可以编写 &lt;code&gt;function*&lt;/code&gt; 或 &lt;code&gt;=&amp;gt;&lt;/code&gt; ，但不能两者都写。因此，CoffeeScript代码如下：</target>
        </trans-unit>
        <trans-unit id="3f1d6f17ca16b010bf909bd90956813c62360340" translate="yes" xml:space="preserve">
          <source>Breaking Changes From 1.x</source>
          <target state="translated">从1.x开始的突破性变化</target>
        </trans-unit>
        <trans-unit id="3501da7b50f11f0bed95d1651f5526076186c9d5" translate="yes" xml:space="preserve">
          <source>Breaking Changes From CoffeeScript 1.x to 2</source>
          <target state="translated">从CoffeeScript 1.x到2的突破性变化。</target>
        </trans-unit>
        <trans-unit id="476e56d0eff6f65aab9d09fede93409b5105aa4b" translate="yes" xml:space="preserve">
          <source>But it&amp;rsquo;s also helpful for dealing with functions that return multiple values.</source>
          <target state="translated">但这对于处理返回多个值的函数也很有帮助。</target>
        </trans-unit>
        <trans-unit id="eed3eed03e17d439596291023c0881f19f4179f4" translate="yes" xml:space="preserve">
          <source>By default, Babel doesn&amp;rsquo;t do anything&amp;mdash;it doesn&amp;rsquo;t make assumptions about what you want to transpile to. You need to provide it with a configuration so that it knows what to do. One way to do this is by creating a &lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt;&lt;code&gt;.babelrc&lt;/code&gt; file&lt;/a&gt; in the folder containing the files you&amp;rsquo;re compiling, or in any parent folder up the path above those files. (Babel supports &lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt;other ways&lt;/a&gt;, too.) A minimal &lt;code&gt;.babelrc&lt;/code&gt; file would be just &lt;code&gt;{ &quot;presets&quot;: [&quot;@babel/env&quot;] }&lt;/code&gt;. This implies that you have installed &lt;a href=&quot;https://babeljs.io/docs/plugins/preset-env/&quot;&gt;&lt;code&gt;@babel/preset-env&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">默认情况下，Babel不会执行任何操作，它不会对您想要转换的内容进行任何假设。您需要为其提供配置，以便它知道该怎么做。一种方法是在包含要编译&lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt;文件&lt;/a&gt;的文件夹中或这些文件上方路径的任何父文件夹中创建一个 &lt;code&gt;.babelrc&lt;/code&gt; 文件。（Babel也支持&lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt;其他方式&lt;/a&gt;。）最小的 &lt;code&gt;.babelrc&lt;/code&gt; 文件将只是 &lt;code&gt;{ &quot;presets&quot;: [&quot;@babel/env&quot;] }&lt;/code&gt; presets &amp;rdquo;：[&amp;ldquo; @ babel / env&amp;rdquo;]}。这意味着您已经安装了&lt;a href=&quot;https://babeljs.io/docs/plugins/preset-env/&quot;&gt; &lt;code&gt;@babel/preset-env&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="49f1d818998e74de59695f157376f3a90606565f" translate="yes" xml:space="preserve">
          <source>Cake, and Cakefiles</source>
          <target state="translated">蛋糕,和蛋糕文件</target>
        </trans-unit>
        <trans-unit id="0088170b2bb2e7f289a6285cc617ed958ec50055" translate="yes" xml:space="preserve">
          <source>Chained Comparisons</source>
          <target state="translated">链式比较</target>
        </trans-unit>
        <trans-unit id="0ccff6f387e0efef20c206a781d53627c48f2db7" translate="yes" xml:space="preserve">
          <source>Chaining Function Calls</source>
          <target state="translated">链式函数调用</target>
        </trans-unit>
        <trans-unit id="0671ba2a2caa16a2ef58982abbdd6ace7b22a6a2" translate="yes" xml:space="preserve">
          <source>Class constructors can&amp;rsquo;t be invoked without &lt;code&gt;new&lt;/code&gt;:</source>
          <target state="translated">没有 &lt;code&gt;new&lt;/code&gt; 不能调用类构造函数：</target>
        </trans-unit>
        <trans-unit id="c53d0a7efe848343f2bc3b9f8c6dabb21e16c959" translate="yes" xml:space="preserve">
          <source>Class methods can&amp;rsquo;t be used with &lt;code&gt;new&lt;/code&gt; (uncommon):</source>
          <target state="translated">类方法不能与 &lt;code&gt;new&lt;/code&gt; （不常见）一起使用：</target>
        </trans-unit>
        <trans-unit id="ed1846afee3be21521286932b99e2aeae9e6414a" translate="yes" xml:space="preserve">
          <source>Classes</source>
          <target state="translated">Classes</target>
        </trans-unit>
        <trans-unit id="76ac356fa19e9b009cd862e7b800bf5b501caee5" translate="yes" xml:space="preserve">
          <source>Classes are compiled to ES2015 classes</source>
          <target state="translated">类被编译成ES2015类</target>
        </trans-unit>
        <trans-unit id="ed3b73338063d6639e5a81aae81f93fb2d0aed3e" translate="yes" xml:space="preserve">
          <source>Code blocks need to maintain consistent indentation relative to each other. When the compiler parses your Literate CoffeeScript file, it first discards all the non-code block lines and then parses the remainder as a regular CoffeeScript file. Therefore the code blocks need to be written as if the comment lines don&amp;rsquo;t exist, with consistent indentation (including whether they are indented with tabs or spaces).</source>
          <target state="translated">代码块需要相对于彼此保持一致的缩进。当编译器解析您的Literate CoffeeScript文件时，它首先丢弃所有非代码块行，然后将其余部分解析为常规CoffeeScript文件。因此，需要编写代码块，就像注释行不存在一样，并具有一致的缩进（包括是否使用制表符或空格进行缩进）。</target>
        </trans-unit>
        <trans-unit id="5fe0a62d44f69e6416546051403b163d3b065fd0" translate="yes" xml:space="preserve">
          <source>Code blocks should also now maintain a consistent indentation level&amp;mdash;so an indentation of one tab (or whatever you consider to be a tab stop, like 2 spaces or 4 spaces) should be treated as your code&amp;rsquo;s &amp;ldquo;left margin,&amp;rdquo; with all code in the file relative to that column.</source>
          <target state="translated">现在，代码块还应保持一致的缩进级别-因此，一个选项卡（或任何您认为是制表位的缩进，如2个空格或4个空格）的缩进应被视为代码的&amp;ldquo;左边界&amp;rdquo;，所有代码都在相对于该列的文件。</target>
        </trans-unit>
        <trans-unit id="d51fafef78efa145bafb428481015a68d05f79b1" translate="yes" xml:space="preserve">
          <source>Code blocks that you want to be part of the commentary, and not executed, must have at least one line (ideally the first line of the block) completely unindented.</source>
          <target state="translated">你想成为注释的一部分而不执行的代码块,必须至少有一行(最好是代码块的第一行)完全没有indindented。</target>
        </trans-unit>
        <trans-unit id="082a42c3704ee38739d3dd41511c5b78ea5ca8f3" translate="yes" xml:space="preserve">
          <source>CoffeeScript</source>
          <target state="translated">CoffeeScript</target>
        </trans-unit>
        <trans-unit id="555ad83e1b73fa461de685e684efafbb06947391" translate="yes" xml:space="preserve">
          <source>CoffeeScript 1 provided the &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;extends&lt;/code&gt; keywords as syntactic sugar for working with prototypal functions. With ES2015, JavaScript has adopted those keywords; so CoffeeScript 2 compiles its &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;extends&lt;/code&gt; keywords to ES2015 classes.</source>
          <target state="translated">CoffeeScript 1提供了 &lt;code&gt;class&lt;/code&gt; ， &lt;code&gt;extends&lt;/code&gt; 关键字作为语法糖进行了扩展，以使用原型功能。在ES2015中，JavaScript采纳了这些关键字。因此CoffeeScript 2会编译其 &lt;code&gt;class&lt;/code&gt; ， &lt;code&gt;extends&lt;/code&gt; 关键字扩展到ES2015类。</target>
        </trans-unit>
        <trans-unit id="f07be14301b91058d1c6c7135618a2b966428618" translate="yes" xml:space="preserve">
          <source>CoffeeScript 1.x allowed the &lt;code&gt;extends&lt;/code&gt; keyword to set up prototypal inheritance between functions, and &lt;code&gt;super&lt;/code&gt; could be used manually prototype-assigned functions:</source>
          <target state="translated">CoffeeScript 1.x允许 &lt;code&gt;extends&lt;/code&gt; 关键字在函数之间建立原型继承，并且 &lt;code&gt;super&lt;/code&gt; 可以手动使用原型分配的函数：</target>
        </trans-unit>
        <trans-unit id="2e05d2fb1ef65aeec22154353f09cc33a5cf2c6c" translate="yes" xml:space="preserve">
          <source>CoffeeScript 2</source>
          <target state="translated">CoffeeScript 2</target>
        </trans-unit>
        <trans-unit id="e14399e2ffb6a507f01ea44f0297fe153054114d" translate="yes" xml:space="preserve">
          <source>CoffeeScript 2 aims to output as much idiomatic ES2015+ syntax as possible with as few breaking changes from CoffeeScript 1.x as possible. Some breaking changes, unfortunately, were unavoidable.</source>
          <target state="translated">CoffeeScript 2的目标是尽可能多地输出习惯性的ES2015+语法,并尽可能少地对CoffeeScript 1.x进行破坏性修改。不幸的是,一些突破性的变化是不可避免的。</target>
        </trans-unit>
        <trans-unit id="a88022140a2d5d855a42ac84ed596e5d08bb28cc" translate="yes" xml:space="preserve">
          <source>CoffeeScript 2 generates JavaScript that uses the latest, modern syntax. The runtime or browsers where you want your code to run &lt;a href=&quot;#compatibility&quot;&gt;might not support all of that syntax&lt;/a&gt;. In that case, we want to convert modern JavaScript into older JavaScript that will run in older versions of Node or older browsers; for example, &lt;code&gt;{ a } = obj&lt;/code&gt; into &lt;code&gt;a = obj.a&lt;/code&gt;. This is done via transpilers like &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;, &lt;a href=&quot;https://buble.surge.sh/&quot;&gt;Bubl&amp;eacute;&lt;/a&gt; or &lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;Traceur Compiler&lt;/a&gt;.</source>
          <target state="translated">CoffeeScript 2生成使用最新的现代语法的JavaScript。您要运行代码的运行时或浏览器&lt;a href=&quot;#compatibility&quot;&gt;可能不支持所有语法&lt;/a&gt;。在这种情况下，我们想将现代JavaScript转换为可在Node的较旧版本或浏览器中运行的JavaScript。例如， &lt;code&gt;{ a } = obj&lt;/code&gt; 成 &lt;code&gt;a = obj.a&lt;/code&gt; 。这是通过&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;，&lt;a href=&quot;https://buble.surge.sh/&quot;&gt;Bubl&amp;eacute;&lt;/a&gt;或&lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;Traceur编译器之类的编译器完成的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca8a8ef142b86f16c228064c3ea4de5a99994a0a" translate="yes" xml:space="preserve">
          <source>CoffeeScript 2&amp;rsquo;s parsing of Literate CoffeeScript has been refactored to now be more careful about not treating indented lists as code blocks; but this means that all code blocks (unless they are to be interpreted as comments) must be separated by at least one blank line from lists.</source>
          <target state="translated">重构了CoffeeScript 2对Literate CoffeeScript的解析，现在要更加谨慎，不要将缩进的列表视为代码块。但这意味着所有代码块（除非它们被解释为注释）都必须由列表中至少有一个空行分隔。</target>
        </trans-unit>
        <trans-unit id="0b2ffccac37a106e2b15a0c8a15a92e2320522bc" translate="yes" xml:space="preserve">
          <source>CoffeeScript borrows &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#not-in&quot;&gt;chained comparisons&lt;/a&gt; from Python &amp;mdash; making it easy to test if a value falls within a certain range.</source>
          <target state="translated">CoffeeScript借鉴了Python的&lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#not-in&quot;&gt;链式比较&lt;/a&gt; -使测试值是否在一定范围内变得容易。</target>
        </trans-unit>
        <trans-unit id="897a6b8fdb2cee9e51b9a916b9a26978c1b5ce7a" translate="yes" xml:space="preserve">
          <source>CoffeeScript can compile &lt;code&gt;if&lt;/code&gt; statements into JavaScript expressions, using the ternary operator when possible, and closure wrapping otherwise. There is no explicit ternary statement in CoffeeScript &amp;mdash; you simply use a regular &lt;code&gt;if&lt;/code&gt; statement on a single line.</source>
          <target state="translated">CoffeeScript可以将 &lt;code&gt;if&lt;/code&gt; 语句编译为JavaScript表达式，并尽可能使用三元运算符，否则使用闭包。CoffeeScript中没有显式的三元语句-您只需在一行上使用常规 &lt;code&gt;if&lt;/code&gt; 语句即可。</target>
        </trans-unit>
        <trans-unit id="ed27d5551e9a44acadffac9bd86e6ee4d3d53ca3" translate="yes" xml:space="preserve">
          <source>CoffeeScript does not do any type checking itself; the JavaScript output you see above needs to get passed to Flow for it to validate your code. We expect most people will use a &lt;a href=&quot;#es2015plus-output&quot;&gt;build tool&lt;/a&gt; for this, but here&amp;rsquo;s how to do it the simplest way possible using the &lt;a href=&quot;#cli&quot;&gt;CoffeeScript&lt;/a&gt; and &lt;a href=&quot;https://flow.org/en/docs/usage/&quot;&gt;Flow&lt;/a&gt; command-line tools, assuming you&amp;rsquo;ve already &lt;a href=&quot;https://flow.org/en/docs/install/&quot;&gt;installed Flow&lt;/a&gt; and the &lt;a href=&quot;#installation&quot;&gt;latest CoffeeScript&lt;/a&gt; in your project folder:</source>
          <target state="translated">CoffeeScript本身不会进行任何类型检查；您上面看到的JavaScript输出需要传递给Flow才能验证您的代码。我们希望大多数人会为此使用&lt;a href=&quot;#es2015plus-output&quot;&gt;构建工具&lt;/a&gt;，但是假设您已经在项目文件夹中&lt;a href=&quot;https://flow.org/en/docs/install/&quot;&gt;安装了Flow&lt;/a&gt;和&lt;a href=&quot;#installation&quot;&gt;最新的CoffeeScript&lt;/a&gt;，以下是使用&lt;a href=&quot;#cli&quot;&gt;CoffeeScript&lt;/a&gt;和&lt;a href=&quot;https://flow.org/en/docs/usage/&quot;&gt;Flow&lt;/a&gt;命令行工具以最简单的方式进行操作的方法：</target>
        </trans-unit>
        <trans-unit id="06ec89ba18aa176efa0f4a92848e200506fd34ed" translate="yes" xml:space="preserve">
          <source>CoffeeScript has a shortcut for creating objects when you want the key to be set with a variable of the same name. Note that the &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; are required for this shorthand.</source>
          <target state="translated">当您希望使用相同名称的变量设置键时，CoffeeScript具有创建对象的快捷方式。请注意，此速记必须使用 &lt;code&gt;{&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39400b54ccebc49551a1b624ebd5fccd176ecf9a" translate="yes" xml:space="preserve">
          <source>CoffeeScript includes a (very) simple build system similar to &lt;a href=&quot;https://www.gnu.org/software/make/&quot;&gt;Make&lt;/a&gt; and &lt;a href=&quot;http://rake.rubyforge.org/&quot;&gt;Rake&lt;/a&gt;. Naturally, it&amp;rsquo;s called Cake, and is used for the tasks that build and test the CoffeeScript language itself. Tasks are defined in a file named &lt;code&gt;Cakefile&lt;/code&gt;, and can be invoked by running &lt;code&gt;cake [task]&lt;/code&gt; from within the directory. To print a list of all the tasks and options, just type &lt;code&gt;cake&lt;/code&gt;.</source>
          <target state="translated">CoffeeScript包含一个（非常）简单的构建系统，类似于&lt;a href=&quot;https://www.gnu.org/software/make/&quot;&gt;Make&lt;/a&gt;和&lt;a href=&quot;http://rake.rubyforge.org/&quot;&gt;Rake&lt;/a&gt;。自然，它称为Cake，用于构建和测试CoffeeScript语言本身的任务。任务在名为 &lt;code&gt;Cakefile&lt;/code&gt; 的文件中定义，并且可以通过在目录中运行 &lt;code&gt;cake [task]&lt;/code&gt; 来调用。要打印所有任务和选项的列表，只需输入 &lt;code&gt;cake&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb466ef914e340bd4cbaa0c07a1d399d449cd21c" translate="yes" xml:space="preserve">
          <source>CoffeeScript includes support for generating source maps, a way to tell your JavaScript engine what part of your CoffeeScript program matches up with the code being evaluated. Browsers that support it can automatically use source maps to show your original source code in the debugger. To generate source maps alongside your JavaScript files, pass the &lt;code&gt;--map&lt;/code&gt; or &lt;code&gt;-m&lt;/code&gt; flag to the compiler.</source>
          <target state="translated">CoffeeScript包括对生成源映射的支持，这是一种告诉JavaScript引擎CoffeeScript程序的哪一部分与所评估的代码相匹配的方法。支持它的浏览器可以自动使用源映射在调试器中显示原始源代码。要在JavaScript文件旁边生成源地图，请将 &lt;code&gt;--map&lt;/code&gt; 或 &lt;code&gt;-m&lt;/code&gt; 标志传递给编译器。</target>
        </trans-unit>
        <trans-unit id="3db6d625e027881b87b075cf48db7c76a9bdaa5a" translate="yes" xml:space="preserve">
          <source>CoffeeScript supports &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals&quot;&gt;ES2015 tagged template literals&lt;/a&gt;, which enable customized string interpolation. If you immediately prefix a string with a function name (no space between the two), CoffeeScript will output this &amp;ldquo;function plus string&amp;rdquo; combination as an ES2015 tagged template literal, which will &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals&quot;&gt;behave accordingly&lt;/a&gt;: the function is called, with the parameters being the input text and expression parts that make up the interpolated string. The function can then assemble these parts into an output string, providing custom string interpolation.</source>
          <target state="translated">CoffeeScript支持&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals&quot;&gt;ES2015标记的模板文字&lt;/a&gt;，可启用自定义字符串插值。如果您立即在字符串前面加上函数名称（两者之间没有空格），CoffeeScript将以ES2015标记的模板文字形式输出此&amp;ldquo;函数加字符串&amp;rdquo;组合，其&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals&quot;&gt;行为&lt;/a&gt;将相应地发生：调用函数，参数为输入组成插值字符串的文本和表达式部分。然后，该函数可以将这些部分组装成输出字符串，从而提供自定义字符串插值。</target>
        </trans-unit>
        <trans-unit id="6062d895dad2882c3d733740c8180cb30cd93245" translate="yes" xml:space="preserve">
          <source>CoffeeScript supports ES2015 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;generator functions&lt;/a&gt; through the &lt;code&gt;yield&lt;/code&gt; keyword. There&amp;rsquo;s no &lt;code&gt;function*(){}&lt;/code&gt; nonsense &amp;mdash; a generator in CoffeeScript is simply a function that yields.</source>
          <target state="translated">CoffeeScript 通过 &lt;code&gt;yield&lt;/code&gt; 关键字支持ES2015 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;生成器功能&lt;/a&gt;。没有 &lt;code&gt;function*(){}&lt;/code&gt; 废话-CoffeeScript中的生成器只是产生函数。</target>
        </trans-unit>
        <trans-unit id="a64e782a7ca1ed608a5e5d8b58e56c5b34418abf" translate="yes" xml:space="preserve">
          <source>CoffeeScript supports interspersed XML elements, without the need for separate plugins or special settings. The XML elements will be compiled as such, outputting JSX that could be parsed like any normal JSX file, for example by &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-react-jsx/&quot;&gt;Babel with the React JSX transform&lt;/a&gt;. CoffeeScript does &lt;em&gt;not&lt;/em&gt; output &lt;code&gt;React.createElement&lt;/code&gt; calls or any code specific to React or any other framework. It is up to you to attach another step in your build chain to convert this JSX to whatever function calls you wish the XML elements to compile to.</source>
          <target state="translated">CoffeeScript支持散布的XML元素，而无需单独的插件或特殊设置。XML元素将这样编译，输出可以像任何普通JSX文件一样解析的JSX，例如由&lt;a href=&quot;https://babeljs.io/docs/plugins/transform-react-jsx/&quot;&gt;Babel使用React JSX transform&lt;/a&gt;进行解析。CoffeeScript中确实&lt;em&gt;没有&lt;/em&gt;输出 &lt;code&gt;React.createElement&lt;/code&gt; 来电或任何特定代码反应或任何其他框架。由您决定在构建链中附加另一步骤，以将此JSX转换为希望XML元素编译为的任何函数调用。</target>
        </trans-unit>
        <trans-unit id="59b0754344014d9d6347724f39bcacbaf47c2e7d" translate="yes" xml:space="preserve">
          <source>Command Line</source>
          <target state="translated">命令行</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="5d60c7dd62fdcf4abcc61a6a7d335b7117968b4d" translate="yes" xml:space="preserve">
          <source>Compatibility</source>
          <target state="translated">Compatibility</target>
        </trans-unit>
        <trans-unit id="4300e2d5a6e06edd248521ea98c722082a8b228a" translate="yes" xml:space="preserve">
          <source>Compile a &lt;code&gt;.coffee&lt;/code&gt; script into a &lt;code&gt;.js&lt;/code&gt; JavaScript file of the same name.</source>
          <target state="translated">将 &lt;code&gt;.coffee&lt;/code&gt; 脚本编译为同名的 &lt;code&gt;.js&lt;/code&gt; JavaScript文件。</target>
        </trans-unit>
        <trans-unit id="e6a3565f7ffca2f5f11e68c1b128efdad5b5cdd7" translate="yes" xml:space="preserve">
          <source>Compile a directory tree of &lt;code&gt;.coffee&lt;/code&gt; files in &lt;code&gt;src&lt;/code&gt; into a parallel tree of &lt;code&gt;.js&lt;/code&gt; files in &lt;code&gt;lib&lt;/code&gt;:</source>
          <target state="translated">将 &lt;code&gt;src&lt;/code&gt; 中的 &lt;code&gt;.coffee&lt;/code&gt; 文件的目录树编译为 &lt;code&gt;lib&lt;/code&gt; 中的 &lt;code&gt;.js&lt;/code&gt; 文件的并行树：</target>
        </trans-unit>
        <trans-unit id="0a3b0300d1b064869ff33a3d2ebe6e0e6baae51a" translate="yes" xml:space="preserve">
          <source>Compile and print a little snippet of CoffeeScript directly from the command line. For example:</source>
          <target state="translated">直接从命令行编译并打印一小段CoffeeScript。例如</target>
        </trans-unit>
        <trans-unit id="7c79230adcfcd792fe3990fd8abbc8770972c8c7" translate="yes" xml:space="preserve">
          <source>Compile the JavaScript without the &lt;a href=&quot;#lexical-scope&quot;&gt;top-level function safety wrapper&lt;/a&gt;.</source>
          <target state="translated">编译没有&lt;a href=&quot;#lexical-scope&quot;&gt;顶层函数安全包装器&lt;/a&gt;的JavaScript 。</target>
        </trans-unit>
        <trans-unit id="cfc3a5e15482fb7edb84902d1ef3f824dafd8030" translate="yes" xml:space="preserve">
          <source>Comprehensions can also be used to iterate over the keys and values in an object. Use &lt;code&gt;of&lt;/code&gt; to signal comprehension over the properties of an object instead of the values in an array.</source>
          <target state="translated">理解也可以用于迭代对象中的键和值。使用 &lt;code&gt;of&lt;/code&gt; ，以信号理解在物体上，而不是在阵列中的值的属性。</target>
        </trans-unit>
        <trans-unit id="23c37ee042c74f1f491788e4316571902ea348c4" translate="yes" xml:space="preserve">
          <source>Comprehensions should be able to handle most places where you otherwise would use a loop, &lt;code&gt;each&lt;/code&gt;/&lt;code&gt;forEach&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, or &lt;code&gt;select&lt;/code&gt;/&lt;code&gt;filter&lt;/code&gt;, for example:</source>
          <target state="translated">理解应该能够处理您可能会使用循环的大多数地方， &lt;code&gt;each&lt;/code&gt; / &lt;code&gt;forEach&lt;/code&gt; ， &lt;code&gt;map&lt;/code&gt; 或 &lt;code&gt;select&lt;/code&gt; / &lt;code&gt;filter&lt;/code&gt; ，例如：</target>
        </trans-unit>
        <trans-unit id="f4408c72041f1642066f98a95c77bb7d47148a6c" translate="yes" xml:space="preserve">
          <source>Concatenate a list of files into a single script:</source>
          <target state="translated">将一个文件列表连成一个脚本。</target>
        </trans-unit>
        <trans-unit id="ec59c7801544b7219c543bca6994038a564b01b6" translate="yes" xml:space="preserve">
          <source>Default values for function parameters and destructured elements</source>
          <target state="translated">函数参数和反结构元素的默认值。</target>
        </trans-unit>
        <trans-unit id="bf1be2b7ad07bae2fe92475d10173eb638774def" translate="yes" xml:space="preserve">
          <source>Definition</source>
          <target state="translated">Definition</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="3971221e4434ee7c22e0cd88456435a7a35e2f99" translate="yes" xml:space="preserve">
          <source>Destructuring Assignment</source>
          <target state="translated">破坏性作业</target>
        </trans-unit>
        <trans-unit id="693d95d6190509bd73966d59486aedaea1f2f65e" translate="yes" xml:space="preserve">
          <source>Destructuring assignment can be used with any depth of array and object nesting, to help pull out deeply nested properties.</source>
          <target state="translated">解构赋值可以用于任意深度的数组和对象嵌套,帮助拉出深度嵌套的属性。</target>
        </trans-unit>
        <trans-unit id="084d80478954c0fd6df8a1f5371f23b6b7d2b0bb" translate="yes" xml:space="preserve">
          <source>Destructuring assignment can even be combined with splats.</source>
          <target state="translated">破坏性作业甚至可以与飞溅相结合。</target>
        </trans-unit>
        <trans-unit id="03c2ead8f6c7800e07ddee30aab9ffe372df05ad" translate="yes" xml:space="preserve">
          <source>Destructuring assignment is also useful when combined with class constructors to assign properties to your instance from an options object passed to the constructor.</source>
          <target state="translated">当与类构造函数相结合,从传递给构造函数的选项对象中为你的实例分配属性时,析构赋值也很有用。</target>
        </trans-unit>
        <trans-unit id="ee64309bcad68d432618adc16618ac8cd4342081" translate="yes" xml:space="preserve">
          <source>Double-quoted block strings, like other double-quoted strings, allow interpolation.</source>
          <target state="translated">双引号的块状字符串和其他双引号的字符串一样,允许进行插值。</target>
        </trans-unit>
        <trans-unit id="76c71025ffe95216c3f2960d37aa6448ff56912e" translate="yes" xml:space="preserve">
          <source>Due to a syntax clash with &lt;code&gt;super&lt;/code&gt; with accessors, &amp;ldquo;bare&amp;rdquo; &lt;code&gt;super&lt;/code&gt; (the keyword &lt;code&gt;super&lt;/code&gt; without parentheses) no longer compiles to a super call forwarding all arguments.</source>
          <target state="translated">由于与 &lt;code&gt;super&lt;/code&gt; 与访问器的语法冲突，&amp;ldquo;裸&amp;rdquo; &lt;code&gt;super&lt;/code&gt; （无括号的关键字 &lt;code&gt;super&lt;/code&gt; ）不再编译为转发所有参数的super调用。</target>
        </trans-unit>
        <trans-unit id="cd6c049a857c66bb824182c8c447a61a862212dd" translate="yes" xml:space="preserve">
          <source>Due to the hoisting required to compile to ES2015 classes, dynamic keys in class methods can&amp;rsquo;t use values from the executable class body unless the methods are assigned in prototype style.</source>
          <target state="translated">由于需要编译ES2015类，因此类方法中的动态键不能使用可执行类主体中的值，除非以原型样式分配方法。</target>
        </trans-unit>
        <trans-unit id="abd4833636e3bf75c96fa84f99c79c1dfd504f8f" translate="yes" xml:space="preserve">
          <source>Due to the switch to ES2015 &lt;code&gt;extends&lt;/code&gt; and &lt;code&gt;super&lt;/code&gt;, using these keywords for prototypal functions are no longer supported. The above case could be refactored to:</source>
          <target state="translated">由于切换到ES2015 &lt;code&gt;extends&lt;/code&gt; 和 &lt;code&gt;super&lt;/code&gt; ，因此不再支持将这些关键字用于原型功能。上述情况可以重构为：</target>
        </trans-unit>
        <trans-unit id="68f15e98bbba94444d4a5758a91c0b8c7f4919c0" translate="yes" xml:space="preserve">
          <source>ES2015 classes and their methods have some restrictions beyond those on regular functions.</source>
          <target state="translated">ES2015类及其方法除了对常规函数的限制外,还有一些限制。</target>
        </trans-unit>
        <trans-unit id="686eb8e68104e706ebea5afdbc1c1082e68d1d72" translate="yes" xml:space="preserve">
          <source>ES2015 classes don&amp;rsquo;t allow bound (fat arrow) methods. The CoffeeScript compiler goes through some contortions to preserve support for them, but one thing that can&amp;rsquo;t be accommodated is calling a bound method before it is bound:</source>
          <target state="translated">ES2015类不允许使用绑定（胖箭头）方法。CoffeeScript编译器会经历一些扭曲，以保留对它们的支持，但无法容纳的一件事是在绑定之前调用bound方法：</target>
        </trans-unit>
        <trans-unit id="ee88a511a3dd54469352e7cc993bdb9390253e24" translate="yes" xml:space="preserve">
          <source>ES2015 modules are supported in CoffeeScript, with very similar &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; syntax:</source>
          <target state="translated">CoffeeScript支持ES2015模块，其 &lt;code&gt;import&lt;/code&gt; 和 &lt;code&gt;export&lt;/code&gt; 语法非常相似：</target>
        </trans-unit>
        <trans-unit id="a673b896c1665557ccd0cee7c0afccf5405fc642" translate="yes" xml:space="preserve">
          <source>ES2017&amp;rsquo;s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;async functions&lt;/a&gt; are supported through the &lt;code&gt;await&lt;/code&gt; keyword. Like with generators, there&amp;rsquo;s no need for an &lt;code&gt;async&lt;/code&gt; keyword; an async function in CoffeeScript is simply a function that awaits.</source>
          <target state="translated">通过 &lt;code&gt;await&lt;/code&gt; 关键字支持ES2017的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;异步功能&lt;/a&gt;。像生成器一样，不需要 &lt;code&gt;async&lt;/code&gt; 关键字。CoffeeScript中的异步函数只是一个等待的函数。</target>
        </trans-unit>
        <trans-unit id="bfc783ddd79a9914d8fbf1e5c70ddebce72e3d6a" translate="yes" xml:space="preserve">
          <source>Embedded JavaScript</source>
          <target state="translated">嵌入JavaScript</target>
        </trans-unit>
        <trans-unit id="a71f86015fbc5b12f95827124758fcdcd748d4e5" translate="yes" xml:space="preserve">
          <source>Escape backslashes before backticks with more backslashes: &lt;code&gt;\\\`​&lt;/code&gt; becomes &lt;code&gt;\`​&lt;/code&gt;.</source>
          <target state="translated">逃生更多反引号反斜杠反斜杠前： &lt;code&gt;\\\`​&lt;/code&gt; 变成 &lt;code&gt;\`​&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec5f2d9c1baacad5c9a2a2c7ebd37ab7e094639c" translate="yes" xml:space="preserve">
          <source>Escape backticks with backslashes: &lt;code&gt;\`​&lt;/code&gt; becomes &lt;code&gt;`​&lt;/code&gt;.</source>
          <target state="translated">逃生用反斜杠反引号： &lt;code&gt;\`​&lt;/code&gt; 变成 &lt;code&gt;`​&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca324f5a8ab7f029b85119d0ccec4498c155b7a5" translate="yes" xml:space="preserve">
          <source>Even though functions will always return their final value, it&amp;rsquo;s both possible and encouraged to return early from a function body writing out the explicit return (&lt;code&gt;return value&lt;/code&gt;), when you know that you&amp;rsquo;re done.</source>
          <target state="translated">即使函数总是返回其最终值，当您知道已完成操作时，也可以鼓励函数从函数体中提前返回，并写出显式return（ &lt;code&gt;return value&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7fde14a080208598ce35fabd5b0ea5f2affbf555" translate="yes" xml:space="preserve">
          <source>Everything is an Expression</source>
          <target state="translated">一切都是一种表达方式</target>
        </trans-unit>
        <trans-unit id="7af36896f436a2940c2c5a2723b3bc0c8c329291" translate="yes" xml:space="preserve">
          <source>Everything is an Expression (at least, as much as possible)</source>
          <target state="translated">一切都是一种表达(至少,尽可能的表达)。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="e2a4095571338493938d9208d1a8bdc53cd52da1" translate="yes" xml:space="preserve">
          <source>Existential Operator</source>
          <target state="translated">存在运算符</target>
        </trans-unit>
        <trans-unit id="340b3c1e6a8d3673bdad04f30b83addc47a3c77e" translate="yes" xml:space="preserve">
          <source>Expansion can be used to retrieve elements from the end of an array without having to assign the rest of its values. It works in function parameter lists as well.</source>
          <target state="translated">扩充可以用来从数组的末尾检索元素,而不需要分配其其余的值。它也适用于函数参数列表。</target>
        </trans-unit>
        <trans-unit id="9435e660888a944ea96d68e322b87de298b0b35d" translate="yes" xml:space="preserve">
          <source>Finally, class definitions are blocks of executable code, which make for interesting metaprogramming possibilities. In the context of a class definition, &lt;code&gt;this&lt;/code&gt; is the class object itself; therefore, you can assign static properties by using &lt;code&gt;@property: value&lt;/code&gt;.</source>
          <target state="translated">最后，类定义是可执行代码的块，这使得有趣的元编程可能性成为可能。在类定义的上下文中， &lt;code&gt;this&lt;/code&gt; 是类对象本身。因此，您可以使用 &lt;code&gt;@property: value&lt;/code&gt; 分配静态属性。</target>
        </trans-unit>
        <trans-unit id="aa7d66d6f53b9efb770a67714bce600a748ba8a3" translate="yes" xml:space="preserve">
          <source>First, the basics: CoffeeScript uses significant whitespace to delimit blocks of code. You don&amp;rsquo;t need to use semicolons &lt;code&gt;;&lt;/code&gt; to terminate expressions, ending the line will do just as well (although semicolons can still be used to fit multiple expressions onto a single line). Instead of using curly braces &lt;code&gt;{ }&lt;/code&gt; to surround blocks of code in &lt;a href=&quot;#literals&quot;&gt;functions&lt;/a&gt;, &lt;a href=&quot;#conditionals&quot;&gt;if-statements&lt;/a&gt;, &lt;a href=&quot;#switch&quot;&gt;switch&lt;/a&gt;, and &lt;a href=&quot;#try&quot;&gt;try/catch&lt;/a&gt;, use indentation.</source>
          <target state="translated">首先，基础知识：CoffeeScript使用大量空白来分隔代码块。您不需要使用分号 &lt;code&gt;;&lt;/code&gt; 要终止表达式，结束行也一样（尽管分号仍可用于将多个表达式拟合到一行）。代替使用大括号 &lt;code&gt;{ }&lt;/code&gt; 来包围&lt;a href=&quot;#literals&quot;&gt;函数&lt;/a&gt;，&lt;a href=&quot;#conditionals&quot;&gt;if语句&lt;/a&gt;，&lt;a href=&quot;#switch&quot;&gt;switch&lt;/a&gt;和&lt;a href=&quot;#try&quot;&gt;try / catch中&lt;/a&gt;的代码块，请使用缩进。</target>
        </trans-unit>
        <trans-unit id="ee19e7cadbb13d1440abec3b34a17cd12b6c5c48" translate="yes" xml:space="preserve">
          <source>For a full introduction to source maps, how they work, and how to hook them up in your browser, read the &lt;a href=&quot;https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/&quot;&gt;HTML5 Tutorial&lt;/a&gt;.</source>
          <target state="translated">有关源地图，它们如何工作以及如何在浏览器中进行连接的完整介绍，请阅读&lt;a href=&quot;https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/&quot;&gt;HTML5教程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e01b86e80df0b25b6f0247ef3986bce39d12f358" translate="yes" xml:space="preserve">
          <source>For completeness:</source>
          <target state="translated">为完整起见:</target>
        </trans-unit>
        <trans-unit id="8a4f6d4faf8398cfa0cd411363607d10de4be976" translate="yes" xml:space="preserve">
          <source>For logic, &lt;code&gt;and&lt;/code&gt; compiles to &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, and &lt;code&gt;or&lt;/code&gt; into &lt;code&gt;||&lt;/code&gt;.</source>
          <target state="translated">对于逻辑， &lt;code&gt;and&lt;/code&gt; 编译为 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ，和 &lt;code&gt;or&lt;/code&gt; 成 &lt;code&gt;||&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1fa703ef8acae65b0063e84a587fc7eda00827c3" translate="yes" xml:space="preserve">
          <source>For readability, the &lt;code&gt;until&lt;/code&gt; keyword is equivalent to &lt;code&gt;while not&lt;/code&gt;, and the &lt;code&gt;loop&lt;/code&gt; keyword is equivalent to &lt;code&gt;while true&lt;/code&gt;.</source>
          <target state="translated">出于可读性考虑， &lt;code&gt;until&lt;/code&gt; 关键字 &lt;code&gt;while not&lt;/code&gt; 等于while，而等于关键字 &lt;code&gt;loop&lt;/code&gt; 等于 &lt;code&gt;while true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8898a99d18cf365fdf183321827b4e34c0860021" translate="yes" xml:space="preserve">
          <source>From the root of your project:</source>
          <target state="translated">从你项目的根。</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="2f64931a65a6e89a9512c49457d675893ed09df0" translate="yes" xml:space="preserve">
          <source>Functions are defined by an optional list of parameters in parentheses, an arrow, and the function body. The empty function looks like this: &lt;code&gt;-&amp;gt;&lt;/code&gt;</source>
          <target state="translated">函数由括号中的可选参数列表，箭头和函数体定义。空函数如下所示： &lt;code&gt;-&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98cb6e01b2ef1f74900d474df5478cc6c3f8d839" translate="yes" xml:space="preserve">
          <source>Functions may also have default values for arguments, which will be used if the incoming argument is missing (&lt;code&gt;undefined&lt;/code&gt;).</source>
          <target state="translated">函数还可能具有参数的默认值，如果缺少传入参数（ &lt;code&gt;undefined&lt;/code&gt; ），将使用默认值。</target>
        </trans-unit>
        <trans-unit id="3c74a2f5bbae6a65aa71e01f3ca337b3eb0139aa" translate="yes" xml:space="preserve">
          <source>Generate source maps alongside the compiled JavaScript files. Adds &lt;code&gt;sourceMappingURL&lt;/code&gt; directives to the JavaScript as well.</source>
          <target state="translated">与编译的JavaScript文件一起生成源映射。也将 &lt;code&gt;sourceMappingURL&lt;/code&gt; 指令添加到JavaScript。</target>
        </trans-unit>
        <trans-unit id="532aff027e5f3d32201aa60d2efb5271e9bd4744" translate="yes" xml:space="preserve">
          <source>Generator Functions</source>
          <target state="translated">发电机功能</target>
        </trans-unit>
        <trans-unit id="e76ffcd1f650481542d7dda729cb91d61d3111a0" translate="yes" xml:space="preserve">
          <source>Hopefully, you&amp;rsquo;ll never need to use it, but if you ever need to intersperse snippets of JavaScript within your CoffeeScript, you can use backticks to pass it straight through.</source>
          <target state="translated">希望您永远不需要使用它，但是如果您需要在CoffeeScript中散布JavaScript片段，则可以使用反引号将其直接传递。</target>
        </trans-unit>
        <trans-unit id="abe858446febb39efadf27fc1b2fba8c7df3ab4e" translate="yes" xml:space="preserve">
          <source>If a variable might be undeclared, the compiler does a thorough check. This is what JavaScript coders &lt;em&gt;should&lt;/em&gt; be typing when they want to check if a mystery variable exists.</source>
          <target state="translated">如果可能未声明变量，则编译器会进行彻底检查。这是JavaScript编码人员要检查神秘变量是否存在时&lt;em&gt;应该&lt;/em&gt;输入的内容。</target>
        </trans-unit>
        <trans-unit id="0cfbe04d5e5abb311561c2a3f5993f9e83c1d7a6" translate="yes" xml:space="preserve">
          <source>If this were saved as &lt;code&gt;executable.coffee&lt;/code&gt;, it could be made executable and run:</source>
          <target state="translated">如果将此另存为 &lt;code&gt;executable.coffee&lt;/code&gt; ，则可以将其设置为可执行并运行：</target>
        </trans-unit>
        <trans-unit id="42eb1c2c93bbc5c5388c60ca8defece372ea8114" translate="yes" xml:space="preserve">
          <source>If we had used &lt;code&gt;-&amp;gt;&lt;/code&gt; in the callback above, &lt;code&gt;@customer&lt;/code&gt; would have referred to the undefined &amp;ldquo;customer&amp;rdquo; property of the DOM element, and trying to call &lt;code&gt;purchase()&lt;/code&gt; on it would have raised an exception.</source>
          <target state="translated">如果在上面的回调中使用了 &lt;code&gt;-&amp;gt;&lt;/code&gt; ，则 &lt;code&gt;@customer&lt;/code&gt; 会引用DOM元素的未定义&amp;ldquo; customer&amp;rdquo;属性，并且尝试对其调用call &lt;code&gt;purchase()&lt;/code&gt; 会引发异常。</target>
        </trans-unit>
        <trans-unit id="7e3d568c0c336ebae7d8c3b53ecc75b8f5da93b6" translate="yes" xml:space="preserve">
          <source>If you are using CoffeeScript in a project, you should install it locally for that project so that the version of CoffeeScript is tracked as one of your project&amp;rsquo;s dependencies. Within that project&amp;rsquo;s folder:</source>
          <target state="translated">如果在项目中使用CoffeeScript，则应在该项目的本地安装它，以便将CoffeeScript的版本作为项目的依赖项之一进行跟踪。在该项目的文件夹中：</target>
        </trans-unit>
        <trans-unit id="9dbf6cbf52cbf3a1c6022d16008907342c32a283" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t need the current iteration value you may omit it: &lt;code&gt;browser.closeCurrentTab() for [0...count]&lt;/code&gt;</source>
          <target state="translated">如果不需要当前的迭代值，则可以忽略它： &lt;code&gt;browser.closeCurrentTab() for [0...count]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53c4a51d299b5a23747c3c2aa3bbf171cdb568d0" translate="yes" xml:space="preserve">
          <source>If you know of another way to achieve static type checking with CoffeeScript, please &lt;a href=&quot;https://github.com/jashkenas/coffeescript/issues/new&quot;&gt;create an issue&lt;/a&gt; and let us know.</source>
          <target state="translated">如果您知道使用CoffeeScript实现静态类型检查的另一种方法，请&lt;a href=&quot;https://github.com/jashkenas/coffeescript/issues/new&quot;&gt;创建一个问题&lt;/a&gt;并告知我们。</target>
        </trans-unit>
        <trans-unit id="e4cb8e7ac3be882b151de631a19cf2ab37f9bb1b" translate="yes" xml:space="preserve">
          <source>If you know the start and end of your loop, or would like to step through in fixed-size increments, you can use a range to specify the start and end of your comprehension.</source>
          <target state="translated">如果你知道你的循环的开始和结束,或者想以固定大小的增量步入,你可以使用一个范围来指定你理解的开始和结束。</target>
        </trans-unit>
        <trans-unit id="690eeea1dea81c1df3ff122ee050e1d70f25607b" translate="yes" xml:space="preserve">
          <source>If you need to invoke one task before another &amp;mdash; for example, running &lt;code&gt;build&lt;/code&gt; before &lt;code&gt;test&lt;/code&gt;, you can use the &lt;code&gt;invoke&lt;/code&gt; function: &lt;code&gt;invoke 'build'&lt;/code&gt;. Cake tasks are a minimal way to expose your CoffeeScript functions to the command line, so &lt;a href=&quot;https://coffeescript.org/v2/annotated-source/cake.html&quot;&gt;don&amp;rsquo;t expect any fanciness built-in&lt;/a&gt;. If you need dependencies, or async callbacks, it&amp;rsquo;s best to put them in your code itself &amp;mdash; not the cake task.</source>
          <target state="translated">如果需要先调用一个任务（例如，运行 &lt;code&gt;test&lt;/code&gt; 之前的 &lt;code&gt;build&lt;/code&gt; )，则可以使用 &lt;code&gt;invoke&lt;/code&gt; 函数： &lt;code&gt;invoke 'build'&lt;/code&gt; 。Cake任务是将CoffeeScript函数公开到命令行的最小方式，因此&lt;a href=&quot;https://coffeescript.org/v2/annotated-source/cake.html&quot;&gt;不要期望内置任何幻想&lt;/a&gt;。如果您需要依赖项或异步回调，则最好将它们放在代码本身中，而不是蛋糕任务。</target>
        </trans-unit>
        <trans-unit id="6183792822af0844154cbd94b88cbdf4d74c526f" translate="yes" xml:space="preserve">
          <source>If you plan to use the &lt;code&gt;--transpile&lt;/code&gt; option (see &lt;a href=&quot;#transpilation&quot;&gt;Transpilation&lt;/a&gt;) you will need to also install &lt;code&gt;@babel/core&lt;/code&gt; either globally or locally, depending on whether you are running a globally or locally installed version of CoffeeScript.</source>
          <target state="translated">如果您打算使用 &lt;code&gt;--transpile&lt;/code&gt; 选项（请参阅&lt;a href=&quot;#transpilation&quot;&gt;Transpilation&lt;/a&gt;），则还需要全局或本地安装 &lt;code&gt;@babel/core&lt;/code&gt; ，这取决于您运行的是CoffeeScript的全局版本还是本地安装版本。</target>
        </trans-unit>
        <trans-unit id="16a1eb24f6b65a8ec749d8523bc57eb23ee0101f" translate="yes" xml:space="preserve">
          <source>If you want to use the compiler&amp;rsquo;s API, for example to make an app that compiles strings of CoffeeScript on the fly, you can &lt;code&gt;require&lt;/code&gt; the full module:</source>
          <target state="translated">如果要使用编译器的API（例如，要使应用程序即时编译CoffeeScript字符串），则可以 &lt;code&gt;require&lt;/code&gt; 使用完整的模块：</target>
        </trans-unit>
        <trans-unit id="e2028691c6ca114b3e56e788fbd92f28d5fc0156" translate="yes" xml:space="preserve">
          <source>If you would like to iterate over just the keys that are defined on the object itself, by adding a &lt;code&gt;hasOwnProperty&lt;/code&gt; check to avoid properties that may be inherited from the prototype, use &lt;code&gt;for own key, value of object&lt;/code&gt;.</source>
          <target state="translated">如果您只想遍历对象本身定义的键，可以通过添加 &lt;code&gt;hasOwnProperty&lt;/code&gt; 检查来避免可能从原型继承的属性，将 &lt;code&gt;for own key, value of object&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="592b59788a4d3ef118683778c8b805c5c84cd8ca" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to create top-level variables for other scripts to use, attach them as properties on &lt;code&gt;window&lt;/code&gt;; attach them as properties on the &lt;code&gt;exports&lt;/code&gt; object in CommonJS; or use an &lt;a href=&quot;#modules&quot;&gt;&lt;code&gt;export&lt;/code&gt; statement&lt;/a&gt;. If you&amp;rsquo;re targeting both CommonJS and the browser, the &lt;a href=&quot;#existential-operator&quot;&gt;existential operator&lt;/a&gt; (covered below), gives you a reliable way to figure out where to add them: &lt;code&gt;exports ? this&lt;/code&gt;.</source>
          <target state="translated">如果要创建供其他脚本使用的顶级变量，请将它们作为属性附加到 &lt;code&gt;window&lt;/code&gt; ；将它们作为属性附加到CommonJS 的 &lt;code&gt;exports&lt;/code&gt; 对象上；或使用&lt;a href=&quot;#modules&quot;&gt; &lt;code&gt;export&lt;/code&gt; 声明&lt;/a&gt;。如果您同时针对CommonJS和浏览器，则&lt;a href=&quot;#existential-operator&quot;&gt;存在性运算符&lt;/a&gt;（如下所述）为您提供了一种可靠的方式来确定将它们添加到何处： &lt;code&gt;exports ? this&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="146aec742e33fd45508faaf1fd9479d63b8d9e3b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to use Node.js&amp;rsquo; CommonJS to &lt;code&gt;require&lt;/code&gt; CoffeeScript files, e.g. &lt;code&gt;require './app.coffee'&lt;/code&gt;, you must first &amp;ldquo;register&amp;rdquo; CoffeeScript as an extension:</source>
          <target state="translated">如果您想使用Node.js的CommonJS &lt;code&gt;require&lt;/code&gt; CoffeeScript文件，例如 &lt;code&gt;require './app.coffee'&lt;/code&gt; ，则必须首先&amp;ldquo;注册&amp;rdquo; CoffeeScript作为扩展名：</target>
        </trans-unit>
        <trans-unit id="46e33650ad57bc5c400b19005fe7df0765a3fb90" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using CoffeeScript via the &lt;a href=&quot;https://coffeescript.org/nodejs_usage&quot;&gt;Node API&lt;/a&gt;, where you call &lt;code&gt;CoffeeScript.compile&lt;/code&gt; with a string to be compiled and an &lt;code&gt;options&lt;/code&gt; object, the &lt;code&gt;transpile&lt;/code&gt; key of the &lt;code&gt;options&lt;/code&gt; object should be the Babel options:</source>
          <target state="translated">如果您是通过使用CoffeeScript的&lt;a href=&quot;https://coffeescript.org/nodejs_usage&quot;&gt;节点API&lt;/a&gt;，在那里你打电话 &lt;code&gt;CoffeeScript.compile&lt;/code&gt; 与被编译字符串和 &lt;code&gt;options&lt;/code&gt; 对象时， &lt;code&gt;transpile&lt;/code&gt; 的关键 &lt;code&gt;options&lt;/code&gt; 对象应该是巴贝尔选项：</target>
        </trans-unit>
        <trans-unit id="016766665df92106ffce5000526613553ce1231c" translate="yes" xml:space="preserve">
          <source>If, Else, Unless, and Conditional Assignment</source>
          <target state="translated">If,Else,Unless,和条件赋值。</target>
        </trans-unit>
        <trans-unit id="1e1733da0a2b3323346e10e76e4e0da637c155fe" translate="yes" xml:space="preserve">
          <source>In CoffeeScript 1.x, &lt;code&gt;--&lt;/code&gt; was required after the path and filename of the script to be run, but before any arguments passed to that script. This convention is now deprecated. So instead of:</source>
          <target state="translated">在CoffeeScript 1.x中， &lt;code&gt;--&lt;/code&gt; 在要运行的脚本的路径和文件名之后但在传递给该脚本的任何参数之前是必需的。现在不推荐使用此约定。所以代替：</target>
        </trans-unit>
        <trans-unit id="7064346047d308376ffa12374eb5bf9c93709bc8" translate="yes" xml:space="preserve">
          <source>In CoffeeScript 1.x, &lt;code&gt;=&amp;gt;&lt;/code&gt; compiled to a regular &lt;code&gt;function&lt;/code&gt; but with references to &lt;code&gt;this&lt;/code&gt;/&lt;code&gt;@&lt;/code&gt; rewritten to use the outer scope&amp;rsquo;s &lt;code&gt;this&lt;/code&gt;, or with the inner function bound to the outer scope via &lt;code&gt;.bind&lt;/code&gt; (hence the name &amp;ldquo;bound function&amp;rdquo;). In CoffeeScript 2, &lt;code&gt;=&amp;gt;&lt;/code&gt; compiles to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;ES2015&amp;rsquo;s &lt;code&gt;=&amp;gt;&lt;/code&gt;&lt;/a&gt;, which behaves slightly differently. The largest difference is that in ES2015, &lt;code&gt;=&amp;gt;&lt;/code&gt; functions lack an &lt;code&gt;arguments&lt;/code&gt; object:</source>
          <target state="translated">在CoffeeScript 1.x中， &lt;code&gt;=&amp;gt;&lt;/code&gt; 编译为常规 &lt;code&gt;function&lt;/code&gt; 但使用 &lt;code&gt;this&lt;/code&gt; 的引用/ &lt;code&gt;@&lt;/code&gt; 重写以使用外部范围的 &lt;code&gt;this&lt;/code&gt; ，或内部函数通过 &lt;code&gt;.bind&lt;/code&gt; 绑定到外部范围（因此称为&amp;ldquo;绑定函数&amp;rdquo;） 。在CoffeeScript 2中， &lt;code&gt;=&amp;gt;&lt;/code&gt; 编译为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;ES2015的 &lt;code&gt;=&amp;gt;&lt;/code&gt; &lt;/a&gt;，其行为略有不同。最大的区别在于，在ES2015中， &lt;code&gt;=&amp;gt;&lt;/code&gt; 函数缺少 &lt;code&gt;arguments&lt;/code&gt; 对象：</target>
        </trans-unit>
        <trans-unit id="04b792bc52fa41c8f5a917a0ddd4654b6dc5918b" translate="yes" xml:space="preserve">
          <source>In CoffeeScript 1.x, this used to fail when trying to pass arguments to the script. Some users on OS X worked around the problem by using &lt;code&gt;#!/usr/bin/env coffee --&lt;/code&gt; as the first line of the file. That didn&amp;rsquo;t work on Linux, however, which cannot parse shebang lines with more than a single argument. While such scripts will still run on OS X, CoffeeScript will now display a warning before compiling or evaluating files that begin with a too-long shebang line. Now that CoffeeScript 2 supports passing arguments without needing &lt;code&gt;--&lt;/code&gt;, we recommend simply changing the shebang lines in such scripts to just &lt;code&gt;#!/usr/bin/env coffee&lt;/code&gt;.</source>
          <target state="translated">在CoffeeScript 1.x中，此方法在尝试将参数传递给脚本时会失败。 OS X上的某些用户通过使用 &lt;code&gt;#!/usr/bin/env coffee --&lt;/code&gt; 作为文件的第一行来解决此问题。但是，这在Linux上不起作用，因为Linux无法使用多个参数来解析shebang行。尽管此类脚本仍将在OS X上运行，但CoffeeScript现在将在编译或评估以太长的Shebang行开头的文件之前显示警告。现在，CoffeeScript 2支持传递参数而无需 &lt;code&gt;--&lt;/code&gt; ，我们建议您只需将此类脚本中的shebang行更改为 &lt;code&gt;#!/usr/bin/env coffee&lt;/code&gt; 即可。</target>
        </trans-unit>
        <trans-unit id="788287c76d023cee7c5e146f9e2387cfe9252f53" translate="yes" xml:space="preserve">
          <source>In CoffeeScript, comments are denoted by the &lt;code&gt;#&lt;/code&gt; character to the end of a line, or from &lt;code&gt;###&lt;/code&gt; to the next appearance of &lt;code&gt;###&lt;/code&gt;. Comments are ignored by the compiler, though the compiler makes its best effort at reinserting your comments into the output JavaScript after compilation.</source>
          <target state="translated">在的CoffeeScript，注释被表示为 &lt;code&gt;#&lt;/code&gt; 字符的线的端部，或者从 &lt;code&gt;###&lt;/code&gt; 到下一个外观 &lt;code&gt;###&lt;/code&gt; 。尽管编译器会尽最大努力在编译后将注释重新插入到输出JavaScript中，但注释会被编译器忽略。</target>
        </trans-unit>
        <trans-unit id="9ffbb2a04cb76868837eab857f3bd0071b209bde" translate="yes" xml:space="preserve">
          <source>In ECMAScript this is called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;spread syntax&lt;/a&gt;, and has been supported for arrays since ES2015 and objects since ES2018.</source>
          <target state="translated">在ECMAScript中，这称为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;扩展语法&lt;/a&gt;，自ES2015开始支持数组，从ES2018开始支持对象。</target>
        </trans-unit>
        <trans-unit id="d2f7a2b157c518d92490aade9f7bd6b939d63730" translate="yes" xml:space="preserve">
          <source>In JavaScript, the &lt;code&gt;this&lt;/code&gt; keyword is dynamically scoped to mean the object that the current function is attached to. If you pass a function as a callback or attach it to a different object, the original value of &lt;code&gt;this&lt;/code&gt; will be lost. If you&amp;rsquo;re not familiar with this behavior, &lt;a href=&quot;https://web.archive.org/web/20150316122013/http://www.digital-web.com/articles/scope_in_javascript&quot;&gt;this Digital Web article&lt;/a&gt; gives a good overview of the quirks.</source>
          <target state="translated">在JavaScript中， &lt;code&gt;this&lt;/code&gt; 关键字的动态范围是指当前函数所附加的对象。如果你将一个函数作为回调或将其连接到不同的对象，原值 &lt;code&gt;this&lt;/code&gt; 将丢失。如果您不熟悉此行为，则&lt;a href=&quot;https://web.archive.org/web/20150316122013/http://www.digital-web.com/articles/scope_in_javascript&quot;&gt;此Digital Web文章&lt;/a&gt;会很好地概述这些怪癖。</target>
        </trans-unit>
        <trans-unit id="58ccf15493189686fa8384205d1ffa6634f16256" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;for&lt;/code&gt; loop, &lt;code&gt;from&lt;/code&gt; compiles to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;ES2015 &lt;code&gt;of&lt;/code&gt;&lt;/a&gt;. (Yes, it&amp;rsquo;s unfortunate; the CoffeeScript &lt;code&gt;of&lt;/code&gt; predates the ES2015 &lt;code&gt;of&lt;/code&gt;.)</source>
          <target state="translated">在 &lt;code&gt;for&lt;/code&gt; 循环， &lt;code&gt;from&lt;/code&gt; 编译到&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;ES2015 &lt;code&gt;of&lt;/code&gt; &lt;/a&gt;。（是的，很不幸，在CoffeeScript中 &lt;code&gt;of&lt;/code&gt; 早于ES2015 &lt;code&gt;of&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="a40e241967ca5277adef3eea005b6b4be0ffdb99" translate="yes" xml:space="preserve">
          <source>In addition to supporting ES2015 classes, CoffeeScript provides a shortcut for working with prototypes. The &lt;code&gt;::&lt;/code&gt; operator gives you quick access to an object&amp;rsquo;s prototype:</source>
          <target state="translated">除了支持ES2015类，CoffeeScript还提供了用于处理原型的快捷方式。该 &lt;code&gt;::&lt;/code&gt; 操作使您可以快速访问对象的原型：</target>
        </trans-unit>
        <trans-unit id="451347f5385b9e51f536746d2dbc2451299a59b5" translate="yes" xml:space="preserve">
          <source>In the constructor of a derived class (a class that &lt;code&gt;extends&lt;/code&gt; another class), &lt;code&gt;this&lt;/code&gt; cannot be used before calling &lt;code&gt;super&lt;/code&gt;:</source>
          <target state="translated">在派生类（即一类的构造 &lt;code&gt;extends&lt;/code&gt; 另一个类）， &lt;code&gt;this&lt;/code&gt; 不能被调用之前使用 &lt;code&gt;super&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ba1d2a3ac8a3cfec3370e8237d30cfd830778b27" translate="yes" xml:space="preserve">
          <source>Inline &lt;code&gt;###&lt;/code&gt; comments make &lt;a href=&quot;#type-annotations&quot;&gt;type annotations&lt;/a&gt; possible.</source>
          <target state="translated">内联 &lt;code&gt;###&lt;/code&gt; 注释使&lt;a href=&quot;#type-annotations&quot;&gt;类型注释成为&lt;/a&gt;可能。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="6cb9cbd3b08c7fd8fb0c40e013ef550f116fcf3b" translate="yes" xml:space="preserve">
          <source>Instead of a newline or semicolon, &lt;code&gt;then&lt;/code&gt; can be used to separate conditions from expressions, in &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;, and &lt;code&gt;switch&lt;/code&gt;/&lt;code&gt;when&lt;/code&gt; statements.</source>
          <target state="translated">&lt;code&gt;then&lt;/code&gt; 可以使用 &lt;code&gt;while&lt;/code&gt; ， &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; 和 &lt;code&gt;switch&lt;/code&gt; / &lt;code&gt;when&lt;/code&gt; 语句代替换行符或分号，将条件与表达式分开。</target>
        </trans-unit>
        <trans-unit id="288bf7e5a0f1cc7c60023fb37b337bf4edaa3530" translate="yes" xml:space="preserve">
          <source>Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler.</source>
          <target state="translated">不编译CoffeeScript,只需对其进行勒克斯和解析,并打印出解析树。用于调试编译器。</target>
        </trans-unit>
        <trans-unit id="3ca0e2b8ad0603647ea093f1fbd32497da2b06a4" translate="yes" xml:space="preserve">
          <source>Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler.</source>
          <target state="translated">不解析CoffeeScript,只需lex它,并打印出token流。用来调试编译器。</target>
        </trans-unit>
        <trans-unit id="1448cab4186e9f54c8b08d7cd2d0636b94d3ac93" translate="yes" xml:space="preserve">
          <source>Instead of writing out the JavaScript as a file, print it directly to &lt;strong&gt;stdout&lt;/strong&gt;.</source>
          <target state="translated">与其将JavaScript作为文件写出来，不如直接将其打印到&lt;strong&gt;stdout&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="7b3c2dba907edd3594545f099a0344f3f1d12c7b" translate="yes" xml:space="preserve">
          <source>It can also be used for safer conditional assignment than the JavaScript pattern &lt;code&gt;a = a || value&lt;/code&gt; provides, for cases where you may be handling numbers or strings.</source>
          <target state="translated">它也可以用于比JavaScript模式 &lt;code&gt;a = a || value&lt;/code&gt; 更安全的条件分配。如果您正在处理数字或字符串，则value提供。</target>
        </trans-unit>
        <trans-unit id="4656fa0b7f789159a4076da2dd99866678c8fbb1" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a little difficult to check for the existence of a variable in JavaScript. &lt;code&gt;if (variable) &amp;hellip;&lt;/code&gt; comes close, but fails for zero, the empty string, and false (to name just the most common cases). CoffeeScript&amp;rsquo;s existential operator &lt;code&gt;?&lt;/code&gt; returns true unless a variable is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; or undeclared, which makes it analogous to Ruby&amp;rsquo;s &lt;code&gt;nil?&lt;/code&gt;.</source>
          <target state="translated">检查JavaScript中是否存在变量有点困难。 &lt;code&gt;if (variable) &amp;hellip;&lt;/code&gt; 接近，但失败为零，空字符串和false（仅列举最常见的情况）。CoffeeScript的存在运算符 &lt;code&gt;?&lt;/code&gt; 除非变量为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 或未声明，否则返回true ，这使其类似于Ruby的 &lt;code&gt;nil?&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes" xml:space="preserve">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="c5be221a82247da9792ee8a3ab8649882bae0a0f" translate="yes" xml:space="preserve">
          <source>JSX and the &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; operators</source>
          <target state="translated">JSX和 &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&lt;/code&gt; 运算符</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="fb109f3d3ac46e3151be505c1e1c1768023b31d1" translate="yes" xml:space="preserve">
          <source>Just for kicks, a little bit of the compiler is currently implemented in this fashion: See it &lt;a href=&quot;https://gist.github.com/jashkenas/3fc3c1a8b1009c00d9df&quot;&gt;as a document&lt;/a&gt;, &lt;a href=&quot;https://raw.githubusercontent.com/jashkenas/coffeescript/master/src/scope.litcoffee&quot;&gt;raw&lt;/a&gt;, and &lt;a href=&quot;https://cl.ly/LxEu&quot;&gt;properly highlighted in a text editor&lt;/a&gt;.</source>
          <target state="translated">只是为了方便起见，目前以这种方式实现了一些编译器：将其&lt;a href=&quot;https://gist.github.com/jashkenas/3fc3c1a8b1009c00d9df&quot;&gt;视为文档&lt;/a&gt;，&lt;a href=&quot;https://raw.githubusercontent.com/jashkenas/coffeescript/master/src/scope.litcoffee&quot;&gt;原始&lt;/a&gt;文档并&lt;a href=&quot;https://cl.ly/LxEu&quot;&gt;在文本编辑器中正确突出显示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e7d0e20d61ed8a7062ca711313b21c2b761a366" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;--map&lt;/code&gt;, but include the source map directly in the compiled JavaScript files, rather than in a separate file.</source>
          <target state="translated">就像 &lt;code&gt;--map&lt;/code&gt; 一样，但是将源映射直接包含在已编译的JavaScript文件中，而不是包含在单独的文件中。</target>
        </trans-unit>
        <trans-unit id="ea7ef5627d33e5626e9aefb01f2fd84df3980789" translate="yes" xml:space="preserve">
          <source>Just like JavaScript (since ES2015), CoffeeScript has destructuring assignment syntax. When you assign an array or object literal to a value, CoffeeScript breaks up and matches both sides against each other, assigning the values on the right to the variables on the left. In the simplest case, it can be used for parallel assignment:</source>
          <target state="translated">就像JavaScript一样(从ES2015开始),CoffeeScript有解构赋值语法。当你将一个数组或对象文字赋值时,CoffeeScript会将两边打散并相互匹配,将右边的值赋给左边的变量。在最简单的情况下,它可以用于并行赋值。</target>
        </trans-unit>
        <trans-unit id="4c6043a5a849b28412ad4dbe8490852a177ab12e" translate="yes" xml:space="preserve">
          <source>Just like in JSX and HTML, denote XML tags using &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;. You can interpolate CoffeeScript code inside a tag using &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;. To avoid compiler errors, when using &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; to mean &amp;ldquo;less than&amp;rdquo; or &amp;ldquo;greater than,&amp;rdquo; you should wrap the operators in spaces to distinguish them from XML tags. So &lt;code&gt;i &amp;lt; len&lt;/code&gt;, not &lt;code&gt;i&amp;lt;len&lt;/code&gt;. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the &amp;ldquo;less than&amp;rdquo; and &amp;ldquo;greater than&amp;rdquo; operators will remove ambiguity.</source>
          <target state="translated">就像在JSX和HTML中一样，使用 &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&lt;/code&gt; 表示XML标签。您可以使用 &lt;code&gt;{&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt; 在标签内插入CoffeeScript代码。为避免编译器错误，当使用 &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&lt;/code&gt; 表示&amp;ldquo;小于&amp;rdquo;或&amp;ldquo;大于&amp;rdquo;时，应将运算符包装在空格中以将其与XML标记区分开。所以 &lt;code&gt;i &amp;lt; len&lt;/code&gt; ，不是 &lt;code&gt;i&amp;lt;len&lt;/code&gt; 。当可以肯定您的意图时，编译器会尝试宽恕，但始终在&amp;ldquo;小于&amp;rdquo;和&amp;ldquo;大于&amp;rdquo;运算符周围放置空格会消除歧义。</target>
        </trans-unit>
        <trans-unit id="ee197e1e03ed057d123cd58113296e983974f7c3" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;const&lt;/code&gt; only protects you from &lt;em&gt;reassigning&lt;/em&gt; a variable; it doesn&amp;rsquo;t prevent the variable&amp;rsquo;s value from changing, the way constants usually do in other languages:</source>
          <target state="translated">请记住， &lt;code&gt;const&lt;/code&gt; 仅保护您免于&lt;em&gt;重新分配&lt;/em&gt;变量。它并不能阻止变量的值改变，这与常量在其他语言中通常会发生的变化一样：</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="b52e6ec9fa3d5c13a402c0dc8beb63c9192cad04" translate="yes" xml:space="preserve">
          <source>Language Reference</source>
          <target state="translated">语言参考</target>
        </trans-unit>
        <trans-unit id="b49dc37eaf51e72990aba7aaaf76623a346cbd37" translate="yes" xml:space="preserve">
          <source>Launch an interactive CoffeeScript session to try short snippets. Identical to calling &lt;code&gt;coffee&lt;/code&gt; with no arguments.</source>
          <target state="translated">启动交互式CoffeeScript会话以尝试简短片段。等同于不加参数地呼叫 &lt;code&gt;coffee&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3e90043205a881c2853c2eca6f3e45fcbc541f7" translate="yes" xml:space="preserve">
          <source>Leading &lt;code&gt;.&lt;/code&gt; closes all open calls, allowing for simpler chaining syntax.</source>
          <target state="translated">领先 &lt;code&gt;.&lt;/code&gt; 关闭所有打开的调用，允许使用更简单的链接语法。</target>
        </trans-unit>
        <trans-unit id="9f985d44bdfbd0484f99e8d147e15d78e5abb70b" translate="yes" xml:space="preserve">
          <source>Lexical Scoping and Variable Safety</source>
          <target state="translated">词汇范围和可变安全性</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">根据麻省理工学院许可证授权。</target>
        </trans-unit>
        <trans-unit id="807e50c12f9e6b05f56a04dd9b9ff076073a65d0" translate="yes" xml:space="preserve">
          <source>Like JavaScript and many other languages, CoffeeScript supports strings as delimited by the &lt;code&gt;&quot;&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt; characters. CoffeeScript also supports string interpolation within &lt;code&gt;&quot;&lt;/code&gt;-quoted strings, using &lt;code&gt;#{ &amp;hellip; }&lt;/code&gt;. Single-quoted strings are literal. You may even use interpolation in object keys.</source>
          <target state="translated">像JavaScript和许多其他语言，CoffeeScript的支持作为分隔由字符串 &lt;code&gt;&quot;&lt;/code&gt; 或 &lt;code&gt;'&lt;/code&gt; 字。CoffeeScript中还支持内串插 &lt;code&gt;&quot;&lt;/code&gt; -quoted串，使用 &lt;code&gt;#{ &amp;hellip; }&lt;/code&gt; 。单引号字符串是文字。您甚至可以在对象键中使用插值。</target>
        </trans-unit>
        <trans-unit id="4f3952077d0c37b4982e8e71fecd691cae455a81" translate="yes" xml:space="preserve">
          <source>List items can be at most only one paragraph long. The second paragraph of a list item would be indented after a blank line, and therefore indistinguishable from a code block.</source>
          <target state="translated">列表项最多只能有一段长度。列表项的第二段将在空行后缩进,因此与代码块无法区分。</target>
        </trans-unit>
        <trans-unit id="f9958a2677c3ef0351f8de1b9c79ba7331f155a4" translate="yes" xml:space="preserve">
          <source>Literate CoffeeScript</source>
          <target state="translated">Literate CoffeeScript</target>
        </trans-unit>
        <trans-unit id="e0923ed716463b8c9d5b244e2f6ba2d222d500d9" translate="yes" xml:space="preserve">
          <source>Literate CoffeeScript parsing</source>
          <target state="translated">识字的CoffeeScript解析</target>
        </trans-unit>
        <trans-unit id="e83f1c0d81e570990421db9c6c5103dd52bab5e9" translate="yes" xml:space="preserve">
          <source>Loops and Comprehensions</source>
          <target state="translated">循环和理解</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="d0b44f3bb54288ce6ecf8af194238e14f5bd47a8" translate="yes" xml:space="preserve">
          <source>Most modern JavaScript features that CoffeeScript supports can run natively in Node 7.6+, meaning that Node can run CoffeeScript&amp;rsquo;s output without any further processing required. Here are some notable exceptions:</source>
          <target state="translated">CoffeeScript支持的大多数现代JavaScript功能都可以在Node 7.6+中本地运行，这意味着Node可以运行CoffeeScript的输出而无需任何进一步处理。以下是一些值得注意的例外：</target>
        </trans-unit>
        <trans-unit id="5987894415f15faa1342fc04b8e4f45d10eb5711" translate="yes" xml:space="preserve">
          <source>Most of the loops you&amp;rsquo;ll write in CoffeeScript will be &lt;strong&gt;comprehensions&lt;/strong&gt; over arrays, objects, and ranges. Comprehensions replace (and compile into) &lt;code&gt;for&lt;/code&gt; loops, with optional guard clauses and the value of the current array index. Unlike for loops, array comprehensions are expressions, and can be returned and assigned.</source>
          <target state="translated">您将在CoffeeScript中编写的大多数循环都是对数组，对象和范围的&lt;strong&gt;理解&lt;/strong&gt;。推导替换（和编译成） &lt;code&gt;for&lt;/code&gt; 环，可选后卫子句和当前数组索引的值。与for循环不同，数组推导是表达式，可以返回和分配。</target>
        </trans-unit>
        <trans-unit id="e980a53fb5f690679ff0ebade16b508f890902d3" translate="yes" xml:space="preserve">
          <source>Multiline strings are allowed in CoffeeScript. Lines are joined by a single space unless they end with a backslash. Indentation is ignored.</source>
          <target state="translated">CoffeeScript中允许使用多行字符串。除非以反斜杠结尾,否则用一个空格连接行。缩进被忽略。</target>
        </trans-unit>
        <trans-unit id="9c21b9713784f3e4cfd595b3aa43dab514b15d2c" translate="yes" xml:space="preserve">
          <source>Named functions and function declarations</source>
          <target state="translated">命名函数和函数声明</target>
        </trans-unit>
        <trans-unit id="685d8185cabac29e4bc33d85c18962f2c64b8915" translate="yes" xml:space="preserve">
          <source>Needs to be rewritten the old-fashioned way:</source>
          <target state="translated">需要用老办法重写。</target>
        </trans-unit>
        <trans-unit id="9367a041098127356c25562e1a256085d58951ce" translate="yes" xml:space="preserve">
          <source>Newcomers to CoffeeScript often wonder how to generate the JavaScript &lt;code&gt;function foo() {}&lt;/code&gt;, as opposed to the &lt;code&gt;foo = function() {}&lt;/code&gt; that CoffeeScript produces. The first form is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function&quot;&gt;function declaration&lt;/a&gt;, and the second is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function&quot;&gt;function expression&lt;/a&gt;. As stated above, in CoffeeScript &lt;a href=&quot;#expressions&quot;&gt;everything is an expression&lt;/a&gt;, so naturally we favor the expression form. Supporting only one variant helps avoid confusing bugs that can arise from the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function#Function_declaration_hoisting&quot;&gt;subtle differences between the two forms&lt;/a&gt;.</source>
          <target state="translated">CoffeeScript的新手经常想知道如何生成JavaScript &lt;code&gt;function foo() {}&lt;/code&gt; ，而不是CoffeeScript生成的 &lt;code&gt;foo = function() {}&lt;/code&gt; 。第一种形式是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function&quot;&gt;函数声明&lt;/a&gt;，第二种形式是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function&quot;&gt;函数表达式&lt;/a&gt;。如上所述，在CoffeeScript中，&lt;a href=&quot;#expressions&quot;&gt;一切都是表达式&lt;/a&gt;，因此自然而然地我们喜欢表达式形式。仅支持一种变体有助于避免混淆由于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function#Function_declaration_hoisting&quot;&gt;两种形式之间的细微差异而&lt;/a&gt;引起的错误。</target>
        </trans-unit>
        <trans-unit id="10b3493287f831e81a438811a1ffba01f8cec4b7" translate="yes" xml:space="preserve">
          <source>Node.js</source>
          <target state="translated">Node.js</target>
        </trans-unit>
        <trans-unit id="a17d639e61da9d0653ca53ca643f92af7655ebe3" translate="yes" xml:space="preserve">
          <source>Note how because we are assigning the value of the comprehensions to a variable in the example above, CoffeeScript is collecting the result of each iteration into an array. Sometimes functions end with loops that are intended to run only for their side-effects. Be careful that you&amp;rsquo;re not accidentally returning the results of the comprehension in these cases, by adding a meaningful return value &amp;mdash; like &lt;code&gt;true&lt;/code&gt; &amp;mdash; or &lt;code&gt;null&lt;/code&gt;, to the bottom of your function.</source>
          <target state="translated">请注意，由于在上面的示例中我们将理解值分配给了一个变量，因此CoffeeScript将每次迭代的结果收集到一个数组中。有时函数以循环结束，这些循环仅出于其副作用而运行。通过在函数底部添加有意义的返回值（如 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;null&lt;/code&gt; )，请注意不要在这种情况下意外返回理解结果。</target>
        </trans-unit>
        <trans-unit id="7878aae2bc5e1df5f94aa51acb2a5c0788234496" translate="yes" xml:space="preserve">
          <source>Note that JavaScript strings are immutable, and can&amp;rsquo;t be spliced.</source>
          <target state="translated">请注意，JavaScript字符串是不可变的，不能进行拼接。</target>
        </trans-unit>
        <trans-unit id="d3179b6c8afd9cdc3bb1ec6e1c16cc445004943e" translate="yes" xml:space="preserve">
          <source>Note that if the compiler knows that &lt;code&gt;a&lt;/code&gt; is in scope and therefore declared, &lt;code&gt;a?&lt;/code&gt; compiles to &lt;code&gt;a != null&lt;/code&gt;, &lt;em&gt;not&lt;/em&gt;&lt;code&gt;a !== null&lt;/code&gt;. The &lt;code&gt;!=&lt;/code&gt; makes a loose comparison to &lt;code&gt;null&lt;/code&gt;, which does double duty also comparing against &lt;code&gt;undefined&lt;/code&gt;. The reverse also holds for &lt;code&gt;not a?&lt;/code&gt; or &lt;code&gt;unless a?&lt;/code&gt;.</source>
          <target state="translated">注意，如果编译器知道 &lt;code&gt;a&lt;/code&gt; 在范围内并因此被声明，则 &lt;code&gt;a?&lt;/code&gt; 编译为 &lt;code&gt;a != null&lt;/code&gt; ，&lt;em&gt;而不是&lt;/em&gt; &lt;code&gt;a !== null&lt;/code&gt; 。该 &lt;code&gt;!=&lt;/code&gt; 使得松散比较 &lt;code&gt;null&lt;/code&gt; ，它有双重任务还比较反对 &lt;code&gt;undefined&lt;/code&gt; 。反之亦然 &lt;code&gt;not a?&lt;/code&gt; 还是 &lt;code&gt;unless a?&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c346bd383bcb5c9fab50c836103159e19fa051e2" translate="yes" xml:space="preserve">
          <source>Note that the CoffeeScript compiler &lt;strong&gt;does not resolve modules&lt;/strong&gt;; writing an &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; statement in CoffeeScript will produce an &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; statement in the resulting output. It is your responsibility to &lt;a href=&quot;#transpilation&quot;&gt;transpile&lt;/a&gt; this ES2015 syntax into code that will work in your target runtimes.</source>
          <target state="translated">注意CoffeeScript编译器&lt;strong&gt;不解析模块&lt;/strong&gt;；在CoffeeScript中编写 &lt;code&gt;import&lt;/code&gt; 或 &lt;code&gt;export&lt;/code&gt; 语句将在结果输出中生成 &lt;code&gt;import&lt;/code&gt; 或 &lt;code&gt;export&lt;/code&gt; 语句。这是你的责任，&lt;a href=&quot;#transpilation&quot;&gt;transpile&lt;/a&gt;这个ES2015语法到的代码，将在您的目标运行时的工作。</target>
        </trans-unit>
        <trans-unit id="3da55fdb5cea2e3963662a9bb50c1c4e14f19b69" translate="yes" xml:space="preserve">
          <source>Note that transpiling doesn&amp;rsquo;t automatically supply &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Polyfill&quot;&gt;polyfills&lt;/a&gt; for your code. CoffeeScript itself will output &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf&quot;&gt;&lt;code&gt;Array.indexOf&lt;/code&gt;&lt;/a&gt; if you use the &lt;code&gt;in&lt;/code&gt; operator, or destructuring or spread/rest syntax; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;&lt;code&gt;Function.bind&lt;/code&gt;&lt;/a&gt; if you use a bound (&lt;code&gt;=&amp;gt;&lt;/code&gt;) method in a class. Both are supported in Internet Explorer 9+ and all more recent browsers, but you will need to supply polyfills if you need to support Internet Explorer 8 or below and are using features that would cause these methods to be output. You&amp;rsquo;ll also need to supply polyfills if your own code uses these methods or another method added in recent versions of JavaScript. One polyfill option is &lt;a href=&quot;https://babeljs.io/docs/en/babel-polyfill/&quot;&gt;&lt;code&gt;@babel/polyfill&lt;/code&gt;&lt;/a&gt;, though there are many &lt;a href=&quot;https://hackernoon.com/polyfills-everything-you-ever-wanted-to-know-or-maybe-a-bit-less-7c8de164e423&quot;&gt;other&lt;/a&gt;&lt;a href=&quot;https://philipwalton.com/articles/loading-polyfills-only-when-needed/&quot;&gt;strategies&lt;/a&gt;.</source>
          <target state="translated">需要注意的是transpiling不会自动提供&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Polyfill&quot;&gt;polyfills&lt;/a&gt;为您的代码。如果您使用 &lt;code&gt;in&lt;/code&gt; 运算符，或者使用解构或扩展/其余语法，则CoffeeScript本身将输出&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf&quot;&gt; &lt;code&gt;Array.indexOf&lt;/code&gt; &lt;/a&gt;；如果在类中使用bound（ &lt;code&gt;=&amp;gt;&lt;/code&gt; ）方法，则返回&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt; &lt;code&gt;Function.bind&lt;/code&gt; &lt;/a&gt;。 Internet Explorer 9+和所有更新的浏览器均支持这两种方法，但是如果需要支持Internet Explorer 8或更低版本，并且使用的功能会导致输出这些方法，则需要提供polyfill。如果您自己的代码使用这些方法或最新版本的JavaScript中添加的其他方法，则还需要提供polyfills。尽管有很多选项，但是&lt;a href=&quot;https://babeljs.io/docs/en/babel-polyfill/&quot;&gt; &lt;code&gt;@babel/polyfill&lt;/code&gt; &lt;/a&gt;是一个polyfill选项。&lt;a href=&quot;https://hackernoon.com/polyfills-everything-you-ever-wanted-to-know-or-maybe-a-bit-less-7c8de164e423&quot;&gt;其他&lt;/a&gt;&lt;a href=&quot;https://philipwalton.com/articles/loading-polyfills-only-when-needed/&quot;&gt;策略&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b0e75b1cc5940f3dfdf0f98f2537757533933df2" translate="yes" xml:space="preserve">
          <source>Notice how all of the variable declarations have been pushed up to the top of the closest scope, the first time they appear. &lt;code&gt;outer&lt;/code&gt; is not redeclared within the inner function, because it&amp;rsquo;s already in scope; &lt;code&gt;inner&lt;/code&gt; within the function, on the other hand, should not be able to change the value of the external variable of the same name, and therefore has a declaration of its own.</source>
          <target state="translated">请注意，所有变量声明在首次出现时是如何被推到最接近作用域的顶部的。 &lt;code&gt;outer&lt;/code&gt; 函数未在内部函数内声明，因为它已经在范围内；另一方面，函数 &lt;code&gt;inner&lt;/code&gt; 内部应该不能更改相同名称的外部变量的值，因此具有自己的声明。</target>
        </trans-unit>
        <trans-unit id="ca1abda92d5b54711ee766219d8e2c4693c6ca7a" translate="yes" xml:space="preserve">
          <source>Now you would just type:</source>
          <target state="translated">现在你就会打字。</target>
        </trans-unit>
        <trans-unit id="566c9ccf76b4698b00a6f761b3c71b9f0e05eb29" translate="yes" xml:space="preserve">
          <source>Objects and Arrays</source>
          <target state="translated">对象和数组</target>
        </trans-unit>
        <trans-unit id="5fc811955d55e0ff5b82d1a49c11e277df049033" translate="yes" xml:space="preserve">
          <source>Older plugins or forks of CoffeeScript supported JSX syntax and referred to it as CSX or CJSX. They also often used a &lt;code&gt;.cjsx&lt;/code&gt; file extension, but this is no longer necessary; regular &lt;code&gt;.coffee&lt;/code&gt; will do.</source>
          <target state="translated">CoffeeScript的较早插件或分支支持JSX语法，并将其称为CSX或CJSX。他们还经常使用 &lt;code&gt;.cjsx&lt;/code&gt; 文件扩展名，但这不再是必需的。普通的 &lt;code&gt;.coffee&lt;/code&gt; 可以。</target>
        </trans-unit>
        <trans-unit id="47445da7574ef1c2b9f9dbbf29f9a3e160cc9748" translate="yes" xml:space="preserve">
          <source>On non-Windows platforms, a &lt;code&gt;.coffee&lt;/code&gt; file can be made executable by adding a shebang (&lt;code&gt;#!&lt;/code&gt;) line at the top of the file and marking the file as executable. For example:</source>
          <target state="translated">在非Windows平台上，可以通过在文件顶部添加shebang（ &lt;code&gt;#!&lt;/code&gt; ）行并将该文件标记为可执行文件来使 &lt;code&gt;.coffee&lt;/code&gt; 文件变为可执行文件。例如：</target>
        </trans-unit>
        <trans-unit id="88e58b2db811a67c2866ad03f41850be69476b09" translate="yes" xml:space="preserve">
          <source>Once installed, you should have access to the &lt;code&gt;coffee&lt;/code&gt; command, which can execute scripts, compile &lt;code&gt;.coffee&lt;/code&gt; files into &lt;code&gt;.js&lt;/code&gt;, and provide an interactive REPL. The &lt;code&gt;coffee&lt;/code&gt; command takes the following options:</source>
          <target state="translated">安装后，您应该可以访问 &lt;code&gt;coffee&lt;/code&gt; 命令，该命令可以执行脚本，将 &lt;code&gt;.coffee&lt;/code&gt; 文件编译为 &lt;code&gt;.js&lt;/code&gt; 并提供交互式REPL。该 &lt;code&gt;coffee&lt;/code&gt; 命令采用下列选项：</target>
        </trans-unit>
        <trans-unit id="968e4a68ad115837ed26068f6b0ed2cb269d66ce" translate="yes" xml:space="preserve">
          <source>Once you have &lt;code&gt;@babel/core&lt;/code&gt; and &lt;code&gt;@babel/preset-env&lt;/code&gt; (or other presets or plugins) installed, and a &lt;code&gt;.babelrc&lt;/code&gt; file (or other equivalent) in place, you can use &lt;code&gt;coffee --transpile&lt;/code&gt; to pipe CoffeeScript&amp;rsquo;s output through Babel using the options you&amp;rsquo;ve saved.</source>
          <target state="translated">一旦安装了 &lt;code&gt;@babel/core&lt;/code&gt; 和 &lt;code&gt;@babel/preset-env&lt;/code&gt; （或其他预设或插件），并安装了 &lt;code&gt;.babelrc&lt;/code&gt; 文件（或其他等效文件），就可以使用 &lt;code&gt;coffee --transpile&lt;/code&gt; 通过Babel使用以下命令通过Pipe传递CoffeeScript的输出您保存的选项。</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="1863519535480ab59ac39566f63c3643c8a7c46d" translate="yes" xml:space="preserve">
          <source>Operators and Aliases</source>
          <target state="translated">操作符和别名</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="70d58de47bef0c1dc805b8a5582bf3bb4065cd12" translate="yes" xml:space="preserve">
          <source>Or if you know that the parent function doesn&amp;rsquo;t require arguments, just call &lt;code&gt;super()&lt;/code&gt;:</source>
          <target state="translated">或者，如果您知道父函数不需要参数，则只需调用 &lt;code&gt;super()&lt;/code&gt; 即可：</target>
        </trans-unit>
        <trans-unit id="4abfdc58ca2958fb7f19e78ea1f0eafecc095c1b" translate="yes" xml:space="preserve">
          <source>Or if you&amp;rsquo;re running the &lt;code&gt;coffee&lt;/code&gt; command outside of a project folder, using a globally-installed &lt;code&gt;coffeescript&lt;/code&gt; module, &lt;code&gt;@babel/core&lt;/code&gt; needs to be installed globally:</source>
          <target state="translated">或者，如果您在项目文件夹外部运行 &lt;code&gt;coffee&lt;/code&gt; 命令，则使用全局安装的 &lt;code&gt;coffeescript&lt;/code&gt; 模块，需要全局安装 &lt;code&gt;@babel/core&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="3582229790b1aa109582562e652fba246dfb989e" translate="yes" xml:space="preserve">
          <source>Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over &lt;strong&gt;stdio&lt;/strong&gt;, or using some sort of extension-less file name.</source>
          <target state="translated">将代码解析为Literate CoffeeScript。您仅需要在直接通过&lt;strong&gt;stdio&lt;/strong&gt;传递代码或使用某种无扩展名的文件名时指定此选项。</target>
        </trans-unit>
        <trans-unit id="4f1dcee64c9b040dea753f1d5184978e4fd28e2b" translate="yes" xml:space="preserve">
          <source>Per the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters&quot;&gt;ES2015 spec regarding function default parameters&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values&quot;&gt;destructuring default values&lt;/a&gt;, default values are only applied when a value is missing or &lt;code&gt;undefined&lt;/code&gt;. In CoffeeScript 1.x, the default value would be applied in those cases but also if the value was &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters&quot;&gt;ES2015规范中有关函数默认参数&lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values&quot;&gt;解构默认值的规定&lt;/a&gt;，仅当缺少或 &lt;code&gt;undefined&lt;/code&gt; 值时才应用默认值。在CoffeeScript 1.x中，默认值将在这些情况下应用，但是如果该值为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd72d92f93bcbc4707fdbf29cee5a48b123c133c" translate="yes" xml:space="preserve">
          <source>Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example:</source>
          <target state="translated">将CoffeeScript管到STDIN,并通过STDOUT获取JavaScript。适合与其他语言编写的进程一起使用。一个例子。</target>
        </trans-unit>
        <trans-unit id="bb867dd7a9b38a2aedeac5fcb2379aed6eed2d63" translate="yes" xml:space="preserve">
          <source>Pipe the CoffeeScript compiler&amp;rsquo;s output through Babel before saving or running the generated JavaScript. Requires &lt;code&gt;@babel/core&lt;/code&gt; to be installed, and options to pass to Babel in a &lt;code&gt;.babelrc&lt;/code&gt; file or a &lt;code&gt;package.json&lt;/code&gt; with a &lt;code&gt;babel&lt;/code&gt; key in the path of the file or folder to be compiled. See &lt;a href=&quot;#transpilation&quot;&gt;Transpilation&lt;/a&gt;.</source>
          <target state="translated">在保存或运行生成的JavaScript之前，请通过Babel传递CoffeeScript编译器的输出。要求安装 &lt;code&gt;@babel/core&lt;/code&gt; ，并带有在要编译的文件或文件夹路径中带有 &lt;code&gt;babel&lt;/code&gt; 键的 &lt;code&gt;.babelrc&lt;/code&gt; 文件或 &lt;code&gt;package.json&lt;/code&gt; 中传递给Babel的选项。参见&lt;a href=&quot;#transpilation&quot;&gt;翻译&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c65de7239130b2221dc156af1c9b5fa8125b9bf3" translate="yes" xml:space="preserve">
          <source>Polyfills</source>
          <target state="translated">Polyfills</target>
        </trans-unit>
        <trans-unit id="32f6d152131c542beafde761060b9c5187fa0fd9" translate="yes" xml:space="preserve">
          <source>Print out the compiled JS from a one-liner:</source>
          <target state="translated">从单行本中打印出编译后的JS。</target>
        </trans-unit>
        <trans-unit id="a4e2d5650ff557033b751f41cc52650a02e0ddc8" translate="yes" xml:space="preserve">
          <source>Prototypal Inheritance</source>
          <target state="translated">原型继承</target>
        </trans-unit>
        <trans-unit id="d07133c8504b6a0e98371a1b9afe2ca2855a7270" translate="yes" xml:space="preserve">
          <source>Quickstart</source>
          <target state="translated">Quickstart</target>
        </trans-unit>
        <trans-unit id="0d5fda95e3940bc09dc1ccc22666813c0b54f73d" translate="yes" xml:space="preserve">
          <source>Ranges</source>
          <target state="translated">Ranges</target>
        </trans-unit>
        <trans-unit id="24aaf8084dd55feaa39e1aafbe6c650fc362ceae" translate="yes" xml:space="preserve">
          <source>Ranges can also be used to extract slices of arrays. With two dots (&lt;code&gt;3..6&lt;/code&gt;), the range is inclusive (&lt;code&gt;3, 4, 5, 6&lt;/code&gt;); with three dots (&lt;code&gt;3...6&lt;/code&gt;), the range excludes the end (&lt;code&gt;3, 4, 5&lt;/code&gt;). Slices indices have useful defaults. An omitted first index defaults to zero and an omitted second index defaults to the size of the array.</source>
          <target state="translated">范围也可以用于提取数组的切片。用两个点（ &lt;code&gt;3..6&lt;/code&gt; ）的范围内，是包含性的（ &lt;code&gt;3, 4, 5, 6&lt;/code&gt; ）; 包含三个点（ &lt;code&gt;3...6&lt;/code&gt; ），该范围不包括结尾（ &lt;code&gt;3, 4, 5&lt;/code&gt; ）。切片索引具有有用的默认值。省略的第一索引默认为零，省略的第二索引默认为数组的大小。</target>
        </trans-unit>
        <trans-unit id="87df60de337fb58864343e396696d74611e0d403" translate="yes" xml:space="preserve">
          <source>Resources</source>
          <target state="translated">Resources</target>
        </trans-unit>
        <trans-unit id="28bada3d37bb0a3a9f2a34311d7e6164ba0dc426" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://babeljs.io/docs/plugins/&quot;&gt;Babel&amp;rsquo;s website to learn about presets and plugins&lt;/a&gt; and the multitude of options you have. Another preset you might need is &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-react-jsx/&quot;&gt;&lt;code&gt;@babel/plugin-transform-react-jsx&lt;/code&gt;&lt;/a&gt; if you&amp;rsquo;re using JSX with React (JSX can also be used with other frameworks).</source>
          <target state="translated">请&lt;a href=&quot;https://babeljs.io/docs/plugins/&quot;&gt;访问Babel网站，以了解预设和插件&lt;/a&gt;以及您拥有的众多选项。如果您将JSX与React一起使用，则可能需要的另一个预设是&lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-react-jsx/&quot;&gt; &lt;code&gt;@babel/plugin-transform-react-jsx&lt;/code&gt; &lt;/a&gt;（JSX也可以与其他框架一起使用）。</target>
        </trans-unit>
        <trans-unit id="74aa7d3d7d4395b004fa0da48ff50e997cf268b3" translate="yes" xml:space="preserve">
          <source>Similar to block strings and comments, CoffeeScript supports block regexes &amp;mdash; extended regular expressions that ignore internal whitespace and can contain comments and interpolation. Modeled after Perl&amp;rsquo;s &lt;code&gt;/x&lt;/code&gt; modifier, CoffeeScript&amp;rsquo;s block regexes are delimited by &lt;code&gt;///&lt;/code&gt; and go a long way towards making complex regular expressions readable. To quote from the CoffeeScript source:</source>
          <target state="translated">与块字符串和注释类似，CoffeeScript支持块正则表达式-扩展正则表达式，它们忽略内部空格并可以包含注释和插值。以Perl的 &lt;code&gt;/x&lt;/code&gt; 修饰符为模型，CoffeeScript的块正则表达式由 &lt;code&gt;///&lt;/code&gt; 分隔，在使复杂的正则表达式可读方面大有帮助。要引用CoffeeScript来源：</target>
        </trans-unit>
        <trans-unit id="8159f92ff6c06035d06cbb7eb3033fede5940b02" translate="yes" xml:space="preserve">
          <source>Similar to how &lt;code&gt;yield return&lt;/code&gt; forces a generator, &lt;code&gt;await return&lt;/code&gt; may be used to force a function to be async.</source>
          <target state="translated">与 &lt;code&gt;yield return&lt;/code&gt; 强制生成器的方式类似， &lt;code&gt;await return&lt;/code&gt; 可用于强制函数异步。</target>
        </trans-unit>
        <trans-unit id="d4a58561dd9ce9ebf0ef891fdc51fcf365c7dc7e" translate="yes" xml:space="preserve">
          <source>Since CoffeeScript takes care of all variable declaration, it is not possible to declare variables with ES2015&amp;rsquo;s &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt;. &lt;a href=&quot;#unsupported-let-const&quot;&gt;This is intentional&lt;/a&gt;; we feel that the simplicity gained by not having to think about variable declaration outweighs the benefit of having three separate ways to declare variables.</source>
          <target state="translated">由于CoffeeScript负责所有变量的声明，因此无法使用ES2015的 &lt;code&gt;let&lt;/code&gt; 或 &lt;code&gt;const&lt;/code&gt; 声明变量。&lt;a href=&quot;#unsupported-let-const&quot;&gt;这是有意的&lt;/a&gt; ; 我们认为不必考虑变量声明而获得的简单性胜过使用三种单独的方法来声明变量的好处。</target>
        </trans-unit>
        <trans-unit id="5774da7b802f7af9150c4273aaf57f7387c8eb1d" translate="yes" xml:space="preserve">
          <source>Source Maps</source>
          <target state="translated">源地图</target>
        </trans-unit>
        <trans-unit id="da68b1026804cc80434fc637d86d0eb96635cb24" translate="yes" xml:space="preserve">
          <source>Splats also let us elide array elements&amp;hellip;</source>
          <target state="translated">Splats还使我们能够忽略数组元素&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="424dbd400ae6e38a2f49aadeb924ee108357cfdb" translate="yes" xml:space="preserve">
          <source>Splats, or Rest Parameters/Spread Syntax</source>
          <target state="translated">溅射,或静止 参数/撒布 语法</target>
        </trans-unit>
        <trans-unit id="326a96ab3ee59b29761fe875d4032ef3fd1dcd75" translate="yes" xml:space="preserve">
          <source>Start the CoffeeScript REPL (&lt;code&gt;Ctrl-D&lt;/code&gt; to exit, &lt;code&gt;Ctrl-V&lt;/code&gt;for multi-line):</source>
          <target state="translated">启动CoffeeScript REPL（ &lt;code&gt;Ctrl-D&lt;/code&gt; 退出， &lt;code&gt;Ctrl-V&lt;/code&gt; 表示多行）：</target>
        </trans-unit>
        <trans-unit id="5653cebc057d4791ce07031ad9286e729de6d691" translate="yes" xml:space="preserve">
          <source>Statements</source>
          <target state="translated">Statements</target>
        </trans-unit>
        <trans-unit id="fd9b9a809e9699ee433dd5e37059d01714f797c7" translate="yes" xml:space="preserve">
          <source>Static methods can be defined using &lt;code&gt;@&lt;/code&gt; before the method name:</source>
          <target state="translated">可以在方法名称前使用 &lt;code&gt;@&lt;/code&gt; 定义静态方法：</target>
        </trans-unit>
        <trans-unit id="bb5eff5196ac991028b63b54dacf4e8686fd3692" translate="yes" xml:space="preserve">
          <source>Static type checking can be achieved in CoffeeScript by using &lt;a href=&quot;https://flow.org/&quot;&gt;Flow&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;Comment Types syntax&lt;/a&gt;:</source>
          <target state="translated">可以使用&lt;a href=&quot;https://flow.org/&quot;&gt;Flow&lt;/a&gt;的&lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;Comment Types语法&lt;/a&gt;在CoffeeScript中实现静态类型检查：</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="84130039777ac54831b333570728881088c16ed5" translate="yes" xml:space="preserve">
          <source>Suppress the &amp;ldquo;Generated by CoffeeScript&amp;rdquo; header.</source>
          <target state="translated">禁止显示&amp;ldquo;由CoffeeScript生成&amp;rdquo;标题。</target>
        </trans-unit>
        <trans-unit id="292abefb8a7c036089ac917fd0757a7bb6e3111c" translate="yes" xml:space="preserve">
          <source>Switch/When/Else</source>
          <target state="translated">Switch/When/Else</target>
        </trans-unit>
        <trans-unit id="5fd53f2212dd11ad266f50696cd5a9ca1ea708d6" translate="yes" xml:space="preserve">
          <source>Tagged Template Literals</source>
          <target state="translated">标签:模板文学</target>
        </trans-unit>
        <trans-unit id="468657e1c13e92e3564728da3cdadc47c49817c6" translate="yes" xml:space="preserve">
          <source>Task definitions are written in CoffeeScript, so you can put arbitrary code in your Cakefile. Define a task with a name, a long description, and the function to invoke when the task is run. If your task takes a command-line option, you can define the option with short and long flags, and it will be made available in the &lt;code&gt;options&lt;/code&gt; object. Here&amp;rsquo;s a task that uses the Node.js API to rebuild CoffeeScript&amp;rsquo;s parser:</source>
          <target state="translated">任务定义是用CoffeeScript编写的，因此您可以在Cakefile中放入任意代码。使用名称，详细说明以及运行任务时要调用的函数来定义任务。如果您的任务使用命令行选项，则可以使用长标记和长标记定义选项，并且该选项将在 &lt;code&gt;options&lt;/code&gt; 对象中可用。这是一个使用Node.js API来重建CoffeeScript解析器的任务：</target>
        </trans-unit>
        <trans-unit id="1bc65a5d778ee3969a41b1e46397162f821ca5f0" translate="yes" xml:space="preserve">
          <source>Technically, &lt;code&gt;foo = function() {}&lt;/code&gt; is creating an anonymous function that gets assigned to a variable named &lt;code&gt;foo&lt;/code&gt;. Some very early versions of CoffeeScript named this function, e.g. &lt;code&gt;foo = function foo() {}&lt;/code&gt;, but this was dropped because of compatibility issues with Internet Explorer. For a while this annoyed people, as these functions would be unnamed in stack traces; but modern JavaScript runtimes &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name&quot;&gt;infer the names of such anonymous functions&lt;/a&gt; from the names of the variables to which they&amp;rsquo;re assigned. Given that this is the case, it&amp;rsquo;s simplest to just preserve the current behavior.</source>
          <target state="translated">从技术上讲， &lt;code&gt;foo = function() {}&lt;/code&gt; 正在创建一个匿名函数，该匿名函数被分配给名为 &lt;code&gt;foo&lt;/code&gt; 的变量。CoffeeScript的一些非常早期的版本将其命名为该函数，例如 &lt;code&gt;foo = function foo() {}&lt;/code&gt; ，但由于与Internet Explorer的兼容性问题而将其删除。有一阵子，这使人们很烦恼，因为这些功能在堆栈跟踪中是无法命名的。但是现代的JavaScript运行时会从分配给它们的变量的名称中&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name&quot;&gt;推断出此类匿名函数&lt;/a&gt;的名称。在这种情况下，仅保留当前行为是最简单的。</target>
        </trans-unit>
        <trans-unit id="7572c0330f0713d1c5e756a7afc16d79cdfd440e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/tc39/proposal-regexp-dotall-flag&quot;&gt;regular expression &lt;code&gt;s&lt;/code&gt; (dotall) flag&lt;/a&gt; is supported by Node 9+.</source>
          <target state="translated">该&lt;a href=&quot;https://github.com/tc39/proposal-regexp-dotall-flag&quot;&gt;正则表达式 &lt;code&gt;s&lt;/code&gt; （DOTALL）标志&lt;/a&gt;是由节点9+支持。</target>
        </trans-unit>
        <trans-unit id="c056ef78212ae02220f393b10157bf5612f52880" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;coffee&lt;/code&gt; and &lt;code&gt;cake&lt;/code&gt; commands will first look in the current folder to see if CoffeeScript is installed locally, and use that version if so. This allows different versions of CoffeeScript to be installed globally and locally.</source>
          <target state="translated">该 &lt;code&gt;coffee&lt;/code&gt; 和 &lt;code&gt;cake&lt;/code&gt; 命令将首先在当前文件夹以查看是否CoffeeScript的本地安装和使用该版本如果是这样。这允许在全球和本地安装不同版本的CoffeeScript。</target>
        </trans-unit>
        <trans-unit id="ba748e704aff73a187b5b4d11e627d8c846dc17c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compile&lt;/code&gt; method has the signature &lt;code&gt;compile(code, options)&lt;/code&gt; where &lt;code&gt;code&lt;/code&gt; is a string of CoffeeScript code, and the optional &lt;code&gt;options&lt;/code&gt; is an object with some or all of the following properties:</source>
          <target state="translated">该 &lt;code&gt;compile&lt;/code&gt; 方法具有签名 &lt;code&gt;compile(code, options)&lt;/code&gt; ，其中 &lt;code&gt;code&lt;/code&gt; 是CoffeeScript的代码串，和可选的 &lt;code&gt;options&lt;/code&gt; 是与一些或所有下列性质的目的：</target>
        </trans-unit>
        <trans-unit id="655422e26379c46e7d5bcfbd8d6d8f7315e989f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;node&lt;/code&gt; executable has some useful options you can set, such as &lt;code&gt;--debug&lt;/code&gt;, &lt;code&gt;--debug-brk&lt;/code&gt;, &lt;code&gt;--max-stack-size&lt;/code&gt;, and &lt;code&gt;--expose-gc&lt;/code&gt;. Use this flag to forward options directly to Node.js. To pass multiple flags, use &lt;code&gt;--nodejs&lt;/code&gt; multiple times.</source>
          <target state="translated">该 &lt;code&gt;node&lt;/code&gt; 可执行文件有，你可以设置一些有用的选项，如 &lt;code&gt;--debug&lt;/code&gt; ， &lt;code&gt;--debug-brk&lt;/code&gt; ， &lt;code&gt;--max-stack-size&lt;/code&gt; ，和 &lt;code&gt;--expose-gc&lt;/code&gt; 。使用此标志可以将选项直接转发到Node.js。要传递多个标志， &lt;code&gt;--nodejs&lt;/code&gt; 多次使用--nodejs。</target>
        </trans-unit>
        <trans-unit id="4d06fa582277c824a5eedd0cdf8c8c43e8fd4e37" translate="yes" xml:space="preserve">
          <source>The CoffeeScript compiler takes care to make sure that all of your variables are properly declared within lexical scope &amp;mdash; you never need to write &lt;code&gt;var&lt;/code&gt; yourself.</source>
          <target state="translated">CoffeeScript编译器会确保确保所有变量均在词法范围内正确声明-您无需自己编写 &lt;code&gt;var&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6f6a454b2aadf8379fc2d7a711646b0c0889b8e" translate="yes" xml:space="preserve">
          <source>The CoffeeScript literals for objects and arrays look very similar to their JavaScript cousins. When each property is listed on its own line, the commas are optional. Objects may be created using indentation instead of explicit braces, similar to &lt;a href=&quot;http://yaml.org&quot;&gt;YAML&lt;/a&gt;.</source>
          <target state="translated">对象和数组的CoffeeScript文字看上去与它们的JavaScript表亲非常相似。当每个属性单独列出时，逗号是可选的。可以使用缩进而不是显式花括号来创建对象，类似于&lt;a href=&quot;http://yaml.org&quot;&gt;YAML&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="632671d8e925198953b170ddd065e3816277d5e2" translate="yes" xml:space="preserve">
          <source>The Existential Operator</source>
          <target state="translated">存在运算符</target>
        </trans-unit>
        <trans-unit id="c299679511c002544394508b8a38855769b0948a" translate="yes" xml:space="preserve">
          <source>The JavaScript &lt;code&gt;arguments&lt;/code&gt; object is a useful way to work with functions that accept variable numbers of arguments. CoffeeScript provides splats &lt;code&gt;...&lt;/code&gt;, both for function definition as well as invocation, making variable numbers of arguments a little bit more palatable. ES2015 adopted this feature as their &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters&quot;&gt;rest parameters&lt;/a&gt;.</source>
          <target state="translated">JavaScript &lt;code&gt;arguments&lt;/code&gt; 对象是使用接受可变数量参数的函数的有用方法。CoffeeScript提供了splats &lt;code&gt;...&lt;/code&gt; ，用于函数定义和调用，使可变数量的参数更加可口。ES2015将此功能用作&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters&quot;&gt;其余参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cde9be47142db0d427c3f2b4c90516cab84ab990" translate="yes" xml:space="preserve">
          <source>The above example also demonstrates that if properties are missing in the destructured object or array, you can, just like in JavaScript, provide defaults. Note though that unlike with the existential operator, the default is only applied with the value is missing or &lt;code&gt;undefined&lt;/code&gt;&amp;mdash;&lt;a href=&quot;#breaking-changes-default-values&quot;&gt;passing &lt;code&gt;null&lt;/code&gt; will set a value of &lt;code&gt;null&lt;/code&gt;&lt;/a&gt;, not the default.</source>
          <target state="translated">上面的示例还演示了，如果在解构的对象或数组中缺少属性，则可以像在JavaScript中一样提供默认值。请注意，尽管与存在运算符不同，默认值仅适用于缺少或 &lt;code&gt;undefined&lt;/code&gt; 的值- &lt;a href=&quot;#breaking-changes-default-values&quot;&gt;传递 &lt;code&gt;null&lt;/code&gt; 将设置值为 &lt;code&gt;null&lt;/code&gt; &lt;/a&gt;，而不是默认值。</target>
        </trans-unit>
        <trans-unit id="e95f0f8970d570907faaeca191b0a67113a7c21d" translate="yes" xml:space="preserve">
          <source>The accessor variant of the existential operator &lt;code&gt;?.&lt;/code&gt; can be used to soak up null references in a chain of properties. Use it instead of the dot accessor &lt;code&gt;.&lt;/code&gt; in cases where the base value may be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. If all of the properties exist then you&amp;rsquo;ll get the expected result, if the chain is broken, &lt;code&gt;undefined&lt;/code&gt; is returned instead of the &lt;code&gt;TypeError&lt;/code&gt; that would be raised otherwise.</source>
          <target state="translated">存在运算符 &lt;code&gt;?.&lt;/code&gt; 的存取器变体。可用于吸收属性链中的空引用。用它代替点访问器 &lt;code&gt;.&lt;/code&gt; 如果基值可以为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 。如果所有属性都存在，那么您将获得预期的结果，如果链条断开，则返回 &lt;code&gt;undefined&lt;/code&gt; ，而不是否则将 &lt;code&gt;TypeError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39b4b99d9e71ee2e70bef418e0e782a2d14d8671" translate="yes" xml:space="preserve">
          <source>The biggest change in CoffeeScript 2 is that now the CoffeeScript compiler produces modern JavaScript syntax (ES6, or ES2015 and later). A CoffeeScript &lt;code&gt;=&amp;gt;&lt;/code&gt; becomes a JS &lt;code&gt;=&amp;gt;&lt;/code&gt;, a CoffeeScript &lt;code&gt;class&lt;/code&gt; becomes a JS &lt;code&gt;class&lt;/code&gt; and so on. Major new features in CoffeeScript 2 include &lt;a href=&quot;#async-functions&quot;&gt;async functions&lt;/a&gt; and &lt;a href=&quot;#jsx&quot;&gt;JSX&lt;/a&gt;. You can read more in the &lt;a href=&quot;https://coffeescript.org/announcing-coffeescript-2/&quot;&gt;announcement&lt;/a&gt;.</source>
          <target state="translated">CoffeeScript 2中的最大变化是，现在CoffeeScript编译器可以生成现代的JavaScript语法（ES6或ES2015及更高版本）。CoffeeScript &lt;code&gt;=&amp;gt;&lt;/code&gt; 成为JS &lt;code&gt;=&amp;gt;&lt;/code&gt; ，CoffeeScript &lt;code&gt;class&lt;/code&gt; 成为JS &lt;code&gt;class&lt;/code&gt; ，依此类推。CoffeeScript 2的主要新功能包括&lt;a href=&quot;#async-functions&quot;&gt;异步功能&lt;/a&gt;和&lt;a href=&quot;#jsx&quot;&gt;JSX&lt;/a&gt;。您可以在&lt;a href=&quot;https://coffeescript.org/announcing-coffeescript-2/&quot;&gt;公告中&lt;/a&gt;阅读更多内容。</target>
        </trans-unit>
        <trans-unit id="c2497321a935f3118d62328f3ee12bcb5c1b7482" translate="yes" xml:space="preserve">
          <source>The command-line version of &lt;code&gt;coffee&lt;/code&gt; is available as a &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; utility, requiring Node 6 or later. The &lt;a href=&quot;https://coffeescript.org/v2/browser-compiler-modern/coffeescript.js&quot;&gt;core compiler&lt;/a&gt; however, does not depend on Node, and can be run in any JavaScript environment, or in the browser (see &lt;a href=&quot;#try&quot;&gt;Try CoffeeScript&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;coffee&lt;/code&gt; 的命令行版本可以作为&lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;实用工具使用，需要Node 6或更高版本。该&lt;a href=&quot;https://coffeescript.org/v2/browser-compiler-modern/coffeescript.js&quot;&gt;内核编译&lt;/a&gt;不过，不依赖于节点，并可以在任何JavaScript环境中运行，或者在浏览器中（见&lt;a href=&quot;#try&quot;&gt;尝试的CoffeeScript&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="31dc4964bd6db99efc6d651e6a7fe7980e835c06" translate="yes" xml:space="preserve">
          <source>The deprecated version will still work, but it will print a warning before running the script.</source>
          <target state="translated">废弃的版本仍然可以使用,但它会在运行脚本之前打印一个警告。</target>
        </trans-unit>
        <trans-unit id="917837c752afebbd8afb9fd1d5377edebb699af5" translate="yes" xml:space="preserve">
          <source>The fat arrow &lt;code&gt;=&amp;gt;&lt;/code&gt; can be used to both define a function, and to bind it to the current value of &lt;code&gt;this&lt;/code&gt;, right on the spot. This is helpful when using callback-based libraries like Prototype or jQuery, for creating iterator functions to pass to &lt;code&gt;each&lt;/code&gt;, or event-handler functions to use with &lt;code&gt;on&lt;/code&gt;. Functions created with the fat arrow are able to access properties of the &lt;code&gt;this&lt;/code&gt; where they&amp;rsquo;re defined.</source>
          <target state="translated">粗箭头 &lt;code&gt;=&amp;gt;&lt;/code&gt; 既可以用来定义函数，也可以将其绑定到 &lt;code&gt;this&lt;/code&gt; 的当前值。当使用基于回调的库（例如Prototype或jQuery）来创建要传递给 &lt;code&gt;each&lt;/code&gt; 函数的迭代器函数或与 &lt;code&gt;on&lt;/code&gt; 一起使用的事件处理函数时，这很有用。使用粗箭头创建的函数可以访问在其定义位置的 &lt;code&gt;this&lt;/code&gt; 的属性。</target>
        </trans-unit>
        <trans-unit id="29b0a191e077542f4d37bce4ac1081f2f9f11272" translate="yes" xml:space="preserve">
          <source>The fat arrow was one of the most popular features of CoffeeScript, and ES2015 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;adopted it&lt;/a&gt;; so CoffeeScript 2 compiles &lt;code&gt;=&amp;gt;&lt;/code&gt; to ES &lt;code&gt;=&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">粗箭头是CoffeeScript最受欢迎的功能之一，ES2015 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;采纳了它&lt;/a&gt;。因此CoffeeScript 2将 &lt;code&gt;=&amp;gt;&lt;/code&gt; 编译为ES &lt;code&gt;=&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="881be262b3282151a82d808d99bc918261a00f29" translate="yes" xml:space="preserve">
          <source>The golden rule of CoffeeScript is: &lt;em&gt;&amp;ldquo;It&amp;rsquo;s just JavaScript.&amp;rdquo;&lt;/em&gt; The code compiles one-to-one into the equivalent JS, and there is no interpretation at runtime. You can use any existing JavaScript library seamlessly from CoffeeScript (and vice-versa). The compiled output is readable, pretty-printed, and tends to run as fast or faster than the equivalent handwritten JavaScript.</source>
          <target state="translated">CoffeeScript的黄金法则是：&lt;em&gt;&amp;ldquo;这只是JavaScript。&amp;rdquo; &lt;/em&gt;该代码一对一地编译成等效的JS，并且在运行时没有解释。您可以从CoffeeScript无缝使用任何现有的JavaScript库（反之亦然）。编译后的输出可读性强，打印精美，并且往往比等效的手写JavaScript快或快。</target>
        </trans-unit>
        <trans-unit id="57f6f3bb66cdefe66d61e33b194bae86dc442bf7" translate="yes" xml:space="preserve">
          <source>The only low-level loop that CoffeeScript provides is the &lt;code&gt;while&lt;/code&gt; loop. The main difference from JavaScript is that the &lt;code&gt;while&lt;/code&gt; loop can be used as an expression, returning an array containing the result of each iteration through the loop.</source>
          <target state="translated">CoffeeScript提供的唯一低级循环是 &lt;code&gt;while&lt;/code&gt; 循环。与JavaScript的主要区别在于， &lt;code&gt;while&lt;/code&gt; 循环可以用作表达式，返回一个包含循环中每次迭代结果的数组。</target>
        </trans-unit>
        <trans-unit id="dd6c377bf16ffa88eb3fd655b8bf77b2715b54a5" translate="yes" xml:space="preserve">
          <source>The same syntax can be used with assignment to replace a segment of an array with new values, splicing it.</source>
          <target state="translated">同样的语法可以和赋值一起使用,用新的值替换数组中的一段,将其拼接起来。</target>
        </trans-unit>
        <trans-unit id="d00bce92adf2e76e903d27d857e2684b1a2fb26a" translate="yes" xml:space="preserve">
          <source>The usual caveats about CoffeeScript apply &amp;mdash; your inline scripts will run within a closure wrapper, so if you want to expose global variables or functions, attach them to the &lt;code&gt;window&lt;/code&gt; object.</source>
          <target state="translated">有关CoffeeScript的常见警告适用于您的内联脚本将在闭包中运行，因此，如果要公开全局变量或函数，请将它们附加到 &lt;code&gt;window&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="0407053f9f37c54f4e22762737710b115655c046" translate="yes" xml:space="preserve">
          <source>There are a few ECMAScript features that CoffeeScript intentionally doesn&amp;rsquo;t support.</source>
          <target state="translated">有一些ECMAScript功能是CoffeeScript有意不支持的。</target>
        </trans-unit>
        <trans-unit id="dd46d0c19fd2206d2a20dcf63dd1ac447d8ef9a0" translate="yes" xml:space="preserve">
          <source>There are a handful of statements in JavaScript that can&amp;rsquo;t be meaningfully converted into expressions, namely &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt;, and &lt;code&gt;return&lt;/code&gt;. If you make use of them within a block of code, CoffeeScript won&amp;rsquo;t try to perform the conversion.</source>
          <target state="translated">JavaScript中有少数语句无法有意义地转换为表达式，即 &lt;code&gt;break&lt;/code&gt; ， &lt;code&gt;continue&lt;/code&gt; 和 &lt;code&gt;return&lt;/code&gt; 。如果您在代码块中使用它们，CoffeeScript将不会尝试执行转换。</target>
        </trans-unit>
        <trans-unit id="8ead996d7aeda765800718ece4a37b9a3d073db9" translate="yes" xml:space="preserve">
          <source>There are very few &lt;a href=&quot;#breaking-changes&quot;&gt;breaking changes from CoffeeScript 1.x to 2&lt;/a&gt;; we hope the upgrade process is smooth for most projects.</source>
          <target state="translated">&lt;a href=&quot;#breaking-changes&quot;&gt;从CoffeeScript 1.x到2&lt;/a&gt;几乎没有什么重大更改；我们希望大多数项目的升级过程都很顺利。</target>
        </trans-unit>
        <trans-unit id="7625eae784aaf6c02294c43cdfe6aba3b3340de1" translate="yes" xml:space="preserve">
          <source>Things that would otherwise be statements in JavaScript, when used as part of an expression in CoffeeScript, are converted into expressions by wrapping them in a closure. This lets you do useful things, like assign the result of a comprehension to a variable:</source>
          <target state="translated">在JavaScript中本来是语句的东西,当在CoffeeScript中作为表达式的一部分使用时,会通过将它们包装在一个闭包中转换成表达式。这让你可以做一些有用的事情,比如将理解的结果分配给一个变量。</target>
        </trans-unit>
        <trans-unit id="4b17290b6006c13901c34d75f37b8174f2cf35d0" translate="yes" xml:space="preserve">
          <source>This also means you cannot pass a reference to &lt;code&gt;this&lt;/code&gt; as an argument to &lt;code&gt;super&lt;/code&gt; in the constructor of a derived class:</source>
          <target state="translated">这也意味着您不能在派生类的构造函数中将 &lt;code&gt;this&lt;/code&gt; 的引用作为参数传递给 &lt;code&gt;super&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="212e8a3822b15e29b023624fc8e0a3036b265be8" translate="yes" xml:space="preserve">
          <source>This is a limitation of ES2015 classes. As a workaround, assign to &lt;code&gt;this&lt;/code&gt; after the &lt;code&gt;super&lt;/code&gt; call:</source>
          <target state="translated">这是ES2015类的限制。解决方法是，在 &lt;code&gt;super&lt;/code&gt; 调用之后分配给 &lt;code&gt;this&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ebe0a630e1017ea59b90b6804799a28e26c85ded" translate="yes" xml:space="preserve">
          <source>This is to avoid grammatical ambiguity, since in CoffeeScript such a construct looks identical to a function call (e.g. &lt;code&gt;get(function foo() {})&lt;/code&gt;); and because there is an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt;alternate syntax&lt;/a&gt; that is slightly more verbose but just as effective:</source>
          <target state="translated">这是为了避免语法上的歧义，因为在CoffeeScript中，这种构造看起来与函数调用相同（例如， &lt;code&gt;get(function foo() {})&lt;/code&gt; ）；并且因为还有&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt;另一种语法&lt;/a&gt;稍微冗长一些但同样有效：</target>
        </trans-unit>
        <trans-unit id="e35a04b81c2c241c9e49ed37e23da66a8ec2f106" translate="yes" xml:space="preserve">
          <source>This list may be incomplete, and excludes versions of Node that support newer features behind flags; please refer to &lt;a href=&quot;http://node.green/&quot;&gt;node.green&lt;/a&gt; for full details. You can &lt;a href=&quot;https://coffeescript.org/test.html&quot;&gt;run the tests in your browser&lt;/a&gt; to see what your browser supports. It is your responsibility to ensure that your runtime supports the modern features you use; or that you &lt;a href=&quot;#transpilation&quot;&gt;transpile&lt;/a&gt; your code. When in doubt, transpile.</source>
          <target state="translated">该列表可能是不完整的，并且不包括支持标志后的较新功能的Node版本；请参阅&lt;a href=&quot;http://node.green/&quot;&gt;node.green&lt;/a&gt;了解更多详细信息。您可以&lt;a href=&quot;https://coffeescript.org/test.html&quot;&gt;在浏览器中运行测试以查看浏览&lt;/a&gt;器支持的功能。确保您的运行时支持所使用的现代功能是您的责任；或您&lt;a href=&quot;#transpilation&quot;&gt;转换&lt;/a&gt;代码。如有疑问，请进行转换。</target>
        </trans-unit>
        <trans-unit id="df2efdc78bbbd411a239e3ac6067de5bfdc8c098" translate="yes" xml:space="preserve">
          <source>This will make the &lt;code&gt;coffee&lt;/code&gt; and &lt;code&gt;cake&lt;/code&gt; commands available globally.</source>
          <target state="translated">这将使 &lt;code&gt;coffee&lt;/code&gt; 和 &lt;code&gt;cake&lt;/code&gt; 命令在全球范围内可用。</target>
        </trans-unit>
        <trans-unit id="60e4dcb12e7b736abe3c6d872654f5052718c59b" translate="yes" xml:space="preserve">
          <source>To install, first make sure you have a working copy of the latest stable version of &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;. You can then install CoffeeScript globally with &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;:</source>
          <target state="translated">要安装，请首先确保您具有&lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;的最新稳定版本的工作副本。然后，您可以使用&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;在全局范围内安装CoffeeScript ：</target>
        </trans-unit>
        <trans-unit id="4d491acd5ee23c8cde5200452bec031026aa7e84" translate="yes" xml:space="preserve">
          <source>To iterate a generator function, use &lt;code&gt;from&lt;/code&gt;. See &lt;a href=&quot;#generator-iteration&quot;&gt;Generator Functions&lt;/a&gt;.</source>
          <target state="translated">要迭代生成器函数，请使用 &lt;code&gt;from&lt;/code&gt; 。请参阅&lt;a href=&quot;#generator-iteration&quot;&gt;生成器功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4879760675e96a4c59a258d8b135d6981fed61f9" translate="yes" xml:space="preserve">
          <source>To make things easy, CoffeeScript has built-in support for the popular &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; transpiler. You can use it via the &lt;code&gt;--transpile&lt;/code&gt; command-line option or the &lt;code&gt;transpile&lt;/code&gt; Node API option. To use either, &lt;code&gt;@babel/core&lt;/code&gt; must be installed in your project:</source>
          <target state="translated">为了使事情变得容易，CoffeeScript内置了对流行的&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;转译器的支持。您可以通过 &lt;code&gt;--transpile&lt;/code&gt; 命令行选项或 &lt;code&gt;transpile&lt;/code&gt; Node API选项使用它。要使用两者之一，必须在项目中安装 &lt;code&gt;@babel/core&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="32b8a5b68368acbc341573ad1e61a0edd20250e7" translate="yes" xml:space="preserve">
          <source>To simplify math expressions, &lt;code&gt;**&lt;/code&gt; can be used for exponentiation and &lt;code&gt;//&lt;/code&gt; performs floor division. &lt;code&gt;%&lt;/code&gt; works just like in JavaScript, while &lt;code&gt;%%&lt;/code&gt; provides &lt;a href=&quot;https://en.wikipedia.org/wiki/Modulo_operation&quot;&gt;&amp;ldquo;dividend dependent modulo&amp;rdquo;&lt;/a&gt;:</source>
          <target state="translated">为了简化数学表达式，可以将 &lt;code&gt;**&lt;/code&gt; 用于求幂，并 &lt;code&gt;//&lt;/code&gt; 执行地板除法。 &lt;code&gt;%&lt;/code&gt; 就像在JavaScript中一样工作，而 &lt;code&gt;%%&lt;/code&gt; 提供&lt;a href=&quot;https://en.wikipedia.org/wiki/Modulo_operation&quot;&gt;&amp;ldquo;取决于股息的模&amp;rdquo;&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="760008ba15d1db1590d7becaabcd77417431770e" translate="yes" xml:space="preserve">
          <source>To step through a range comprehension in fixed-size chunks, use &lt;code&gt;by&lt;/code&gt;, for example: &lt;code&gt;evens = (x for x in [0..10] by 2)&lt;/code&gt;</source>
          <target state="translated">要对固定大小的块进行范围理解，请使用 &lt;code&gt;by&lt;/code&gt; ，例如： &lt;code&gt;evens = (x for x in [0..10] by 2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ae484c4ea234c74c821257172381d6f5a5706c0" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;--transpile&lt;/code&gt;, see &lt;a href=&quot;#transpilation&quot;&gt;Transpilation&lt;/a&gt;.</source>
          <target state="translated">要使用 &lt;code&gt;--transpile&lt;/code&gt; ，请参见&lt;a href=&quot;#transpilation&quot;&gt;Transpilation&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="134608c329dd197fae36575214763a11330c0d6a" translate="yes" xml:space="preserve">
          <source>Transpilation</source>
          <target state="translated">Transpilation</target>
        </trans-unit>
        <trans-unit id="441544b175e1ff168280f364e13483ad37fdc025" translate="yes" xml:space="preserve">
          <source>Transpiling with the CoffeeScript compiler</source>
          <target state="translated">用CoffeeScript编译器进行转写</target>
        </trans-unit>
        <trans-unit id="2996879f5c4aef02081b95d839c49eeb3e309880" translate="yes" xml:space="preserve">
          <source>Try/Catch/Finally</source>
          <target state="translated">Try/Catch/Finally</target>
        </trans-unit>
        <trans-unit id="22d158ab75d63715d420bc5e58daab5d8357398c" translate="yes" xml:space="preserve">
          <source>Type Annotations</source>
          <target state="translated">类型注释</target>
        </trans-unit>
        <trans-unit id="01692a80e99068bf423c4ff03463fa9389fe6247" translate="yes" xml:space="preserve">
          <source>Unsupported ECMAScript Features</source>
          <target state="translated">不支持的ECMAScript功能</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="ec90f891d39b4bc9b7913655e4904c205deb12d7" translate="yes" xml:space="preserve">
          <source>Watch a file for changes, and recompile it every time the file is saved:</source>
          <target state="translated">观察文件的变化,并在每次保存文件时重新编译。</target>
        </trans-unit>
        <trans-unit id="a208b4d5c38d76b0c844e7782318c919be835059" translate="yes" xml:space="preserve">
          <source>Watch files for changes, rerunning the specified command when any file is updated.</source>
          <target state="translated">监视文件的变化,当任何文件被更新时,重新运行指定的命令。</target>
        </trans-unit>
        <trans-unit id="6f5de3a310cd5e9cdc833ca57fe2aff4bc3ad811" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s New In CoffeeScript 2?</source>
          <target state="translated">CoffeeScript 2有什么新功能？</target>
        </trans-unit>
        <trans-unit id="f83e4a5d898f47de1ab2a712714b5389d4018960" translate="yes" xml:space="preserve">
          <source>When CoffeeScript was designed, &lt;code&gt;var&lt;/code&gt; was &lt;a href=&quot;https://github.com/jashkenas/coffeescript/issues/238#issuecomment-153502&quot;&gt;intentionally omitted&lt;/a&gt;. This was to spare developers the mental housekeeping of needing to worry about variable &lt;em&gt;declaration&lt;/em&gt; (&lt;code&gt;var foo&lt;/code&gt;) as opposed to variable &lt;em&gt;assignment&lt;/em&gt; (&lt;code&gt;foo = 1&lt;/code&gt;). The CoffeeScript compiler automatically takes care of declaration for you, by generating &lt;code&gt;var&lt;/code&gt; statements at the top of every function scope. This makes it impossible to accidentally declare a global variable.</source>
          <target state="translated">当CoffeeScript的设计， &lt;code&gt;var&lt;/code&gt; 被&lt;a href=&quot;https://github.com/jashkenas/coffeescript/issues/238#issuecomment-153502&quot;&gt;故意省略&lt;/a&gt;。这是为了使开发人员不必担心担心变量&lt;em&gt;声明&lt;/em&gt;（ &lt;code&gt;var foo&lt;/code&gt; ）而不是变量&lt;em&gt;赋值&lt;/em&gt;（ &lt;code&gt;foo = 1&lt;/code&gt; ）。 CoffeeScript编译器通过在每个函数作用域的顶部生成 &lt;code&gt;var&lt;/code&gt; 语句，自动为您处理声明。这使得不可能意外地声明一个全局变量。</target>
        </trans-unit>
        <trans-unit id="5d84cf7d7535701ca31c3e2199811dcec3bed09b" translate="yes" xml:space="preserve">
          <source>When using a JavaScript loop to generate functions, it&amp;rsquo;s common to insert a closure wrapper in order to ensure that loop variables are closed over, and all the generated functions don&amp;rsquo;t just share the final values. CoffeeScript provides the &lt;code&gt;do&lt;/code&gt; keyword, which immediately invokes a passed function, forwarding any arguments.</source>
          <target state="translated">使用JavaScript循环生成函数时，通常会插入一个闭包包装，以确保循环变量被封闭，并且所有生成的函数不仅仅共享最终值。 CoffeeScript提供了 &lt;code&gt;do&lt;/code&gt; 关键字，该关键字立即调用传递的函数，并转发所有参数。</target>
        </trans-unit>
        <trans-unit id="ce527aeb1c14343036af5875ab0bc15b7dedfc43" translate="yes" xml:space="preserve">
          <source>While it&amp;rsquo;s not recommended for serious use, CoffeeScripts may be included directly within the browser using &lt;code&gt;&amp;lt;script type=&quot;text/coffeescript&quot;&amp;gt;&lt;/code&gt; tags. The source includes a compressed and minified version of the compiler (&lt;a href=&quot;https://coffeescript.org/v2/browser-compiler-legacy/coffeescript.js&quot;&gt;Download current version here, 77k when gzipped&lt;/a&gt;) as &lt;code&gt;docs/v2/browser-compiler-legacy/coffeescript.js&lt;/code&gt;. Include this file on a page with inline CoffeeScript tags, and it will compile and evaluate them in order.</source>
          <target state="translated">尽管不建议您认真使用它，但可以使用 &lt;code&gt;&amp;lt;script type=&quot;text/coffeescript&quot;&amp;gt;&lt;/code&gt; 标记将CoffeeScripts直接包含在浏览器中。源包含作为 &lt;code&gt;docs/v2/browser-compiler-legacy/coffeescript.js&lt;/code&gt; 的压缩和压缩的编译器&lt;a href=&quot;https://coffeescript.org/v2/browser-compiler-legacy/coffeescript.js&quot;&gt;版本（在此处下载当前版本，压缩后&lt;/a&gt;为77k）。将此文件包含在具有嵌入式CoffeeScript标签的页面上，它将按顺序编译和评估它们。</target>
        </trans-unit>
        <trans-unit id="7d27f693c7d9cd75cdbdffcd127b5355d5fa8843" translate="yes" xml:space="preserve">
          <source>With the addition of &lt;a href=&quot;#jsx&quot;&gt;JSX&lt;/a&gt;, the &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; characters serve as both the &amp;ldquo;less than&amp;rdquo; and &amp;ldquo;greater than&amp;rdquo; operators and as the delimiters for XML tags, like &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;. For best results, in general you should always wrap the operators in spaces to distinguish them from XML tags: &lt;code&gt;i &amp;lt; len&lt;/code&gt;, not &lt;code&gt;i&amp;lt;len&lt;/code&gt;. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the &amp;ldquo;less than&amp;rdquo; and &amp;ldquo;greater than&amp;rdquo; operators will remove ambiguity.</source>
          <target state="translated">通过添加&lt;a href=&quot;#jsx&quot;&gt;JSX&lt;/a&gt;， &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&lt;/code&gt; 字符既可以用作&amp;ldquo;小于&amp;rdquo;和&amp;ldquo;大于&amp;rdquo;运算符，又可以用作XML标签的分隔符，例如 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 。为了获得最佳结果，通常应始终将运算符包装在空格中，以将其与XML标记区分开： &lt;code&gt;i &amp;lt; len&lt;/code&gt; ，而不是 &lt;code&gt;i&amp;lt;len&lt;/code&gt; 。当可以肯定您的意图时，编译器会尝试宽恕，但始终在&amp;ldquo;小于&amp;rdquo;和&amp;ldquo;大于&amp;rdquo;运算符周围放置空格会消除歧义。</target>
        </trans-unit>
        <trans-unit id="91b3860286d34d188fac6fd2475f0b7c570b45ae" translate="yes" xml:space="preserve">
          <source>Write out all compiled JavaScript files into the specified directory. Use in conjunction with &lt;code&gt;--compile&lt;/code&gt; or &lt;code&gt;--watch&lt;/code&gt;.</source>
          <target state="translated">将所有已编译的JavaScript文件写到指定目录中。与 &lt;code&gt;--compile&lt;/code&gt; 或 &lt;code&gt;--watch&lt;/code&gt; 结合使用。</target>
        </trans-unit>
        <trans-unit id="7fa8e041a9d1bd281a4b489df18b79561d4193cb" translate="yes" xml:space="preserve">
          <source>You can also embed blocks of JavaScript using triple backticks. That&amp;rsquo;s easier than escaping backticks, if you need them inside your JavaScript block.</source>
          <target state="translated">您还可以使用三引号嵌入JavaScript块。如果您需要在JavaScript块中添加反引号，则比转义反引号要容易。</target>
        </trans-unit>
        <trans-unit id="895151cddefabe084525e0448e8f3c00c754930a" translate="yes" xml:space="preserve">
          <source>You can also transpile CoffeeScript&amp;rsquo;s output without using the &lt;code&gt;transpile&lt;/code&gt; option, for example as part of a build chain. This lets you use transpilers other than Babel, and it gives you greater control over the process. There are many great task runners for setting up JavaScript build chains, such as &lt;a href=&quot;http://gulpjs.com/&quot;&gt;Gulp&lt;/a&gt;, &lt;a href=&quot;https://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt;, &lt;a href=&quot;https://gruntjs.com/&quot;&gt;Grunt&lt;/a&gt; and &lt;a href=&quot;http://broccolijs.com/&quot;&gt;Broccoli&lt;/a&gt;.</source>
          <target state="translated">您还可以在不使用 &lt;code&gt;transpile&lt;/code&gt; 选项的情况下转换CoffeeScript的输出，例如，作为构建链的一部分。这使您可以使用Babel以外的其他编译器，并且可以更好地控制该过程。设置JavaScript构建链的任务执行者很多，例如&lt;a href=&quot;http://gulpjs.com/&quot;&gt;Gulp&lt;/a&gt;，&lt;a href=&quot;https://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt;，&lt;a href=&quot;https://gruntjs.com/&quot;&gt;Grunt&lt;/a&gt;和&lt;a href=&quot;http://broccolijs.com/&quot;&gt;Broccoli&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ea09dd580c1117ec826c105827011d4991d422fb" translate="yes" xml:space="preserve">
          <source>You can iterate over a generator function using &lt;code&gt;for&amp;hellip;from&lt;/code&gt;.</source>
          <target state="translated">您可以使用 &lt;code&gt;for&amp;hellip;from&lt;/code&gt; 迭代生成器函数。</target>
        </trans-unit>
        <trans-unit id="627a15b97853de570b928cbe1078ef7b23d9800d" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;in&lt;/code&gt; to test for array presence, and &lt;code&gt;of&lt;/code&gt; to test for JavaScript object-key presence.</source>
          <target state="translated">您可以使用 &lt;code&gt;in&lt;/code&gt; 测试数组存在，并且 &lt;code&gt;of&lt;/code&gt; 到测试JavaScript对象键的存在。</target>
        </trans-unit>
        <trans-unit id="f5d72942f9c85a2499d5ad0b4ecca991c6daa18a" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;not&lt;/code&gt; as an alias for &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">您可以将 &lt;code&gt;not&lt;/code&gt; 用作别名 &lt;code&gt;!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5cc987de3ea0a3222086b75436a669c943d85b76" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to use parentheses to invoke a function if you&amp;rsquo;re passing arguments. The implicit call wraps forward to the end of the line or block expression.</source>
          <target state="translated">如果您要传递参数，则无需使用括号来调用函数。隐式调用返回到行或块表达式的末尾。</target>
        </trans-unit>
        <trans-unit id="b83957bfb0e2f86c484bdb23a3ecc8d6b4ba1ba9" translate="yes" xml:space="preserve">
          <source>You might have noticed how even though we don&amp;rsquo;t add return statements to CoffeeScript functions, they nonetheless return their final value. The CoffeeScript compiler tries to make sure that all statements in the language can be used as expressions. Watch how the &lt;code&gt;return&lt;/code&gt; gets pushed down into each possible branch of execution in the function below.</source>
          <target state="translated">您可能已经注意到，即使我们不向CoffeeScript函数添加return语句，它们仍如何返回其最终值。CoffeeScript编译器尝试确保该语言中的所有语句都可以用作表达式。在下面的函数中，观察 &lt;code&gt;return&lt;/code&gt; 如何下推到每个可能的执行分支中。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="94695e0be1a132fc3c8773528fdeaed22b0e2166" translate="yes" xml:space="preserve">
          <source>assigns the value of &lt;code&gt;b&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is not in scope or if &lt;code&gt;a == null&lt;/code&gt;; produces the new value of &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 不在范围内或 &lt;code&gt;a == null&lt;/code&gt; ，则将 &lt;code&gt;b&lt;/code&gt; 的值分配给 &lt;code&gt;a&lt;/code&gt; ；产生的新值 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30118aa1aa8a06fa5365743b3a5db69fc62b9760" translate="yes" xml:space="preserve">
          <source>await</source>
          <target state="translated">await</target>
        </trans-unit>
        <trans-unit id="7a6e8d704c7decefa5e5d4fa00c771cd1a13ce51" translate="yes" xml:space="preserve">
          <source>coffee command</source>
          <target state="translated">咖啡命令</target>
        </trans-unit>
        <trans-unit id="bcf9c16f425ba1f8ea1288d2892a8012be3730df" translate="yes" xml:space="preserve">
          <source>for...from</source>
          <target state="translated">for...from</target>
        </trans-unit>
        <trans-unit id="af10ef20dd9060bbeead0afbc55381a66af442ef" translate="yes" xml:space="preserve">
          <source>in</source>
          <target state="translated">in</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">is</target>
        </trans-unit>
        <trans-unit id="d5a3e9a0d2ce4a1cae8033c54a253510da7f756a" translate="yes" xml:space="preserve">
          <source>isnt</source>
          <target state="translated">isnt</target>
        </trans-unit>
        <trans-unit id="557f255516719ea16f8f4a0aae1166054e2c9b43" translate="yes" xml:space="preserve">
          <source>not</source>
          <target state="translated">not</target>
        </trans-unit>
        <trans-unit id="de04fa0e29f9b35e24905d2e512bedc9bb6e09e4" translate="yes" xml:space="preserve">
          <source>of</source>
          <target state="translated">of</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="1f1590943b001194a7e6d7ed8992d476ad4e8a6a" translate="yes" xml:space="preserve">
          <source>returns &lt;code&gt;a.b&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is in scope and &lt;code&gt;a != null&lt;/code&gt;; otherwise, &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 在范围内并且 &lt;code&gt;a != null&lt;/code&gt; ，则返回 &lt;code&gt;a.b&lt;/code&gt; ；否则， &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf26d3117231e5075d4fd6c1bf28375ff8a7a8d2" translate="yes" xml:space="preserve">
          <source>returns &lt;code&gt;a&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is in scope and &lt;code&gt;a != null&lt;/code&gt;; otherwise, &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 在范围内，则返回 &lt;code&gt;a&lt;/code&gt; ；而 &lt;code&gt;a != null&lt;/code&gt; ；则返回null。否则， &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="effdab22f101bb837e277a0db2e80288c615f7e6" translate="yes" xml:space="preserve">
          <source>returns the result of calling &lt;code&gt;a&lt;/code&gt; (with arguments &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;) if &lt;code&gt;a&lt;/code&gt; is in scope and callable; otherwise, &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 在范围内且可调用，则返回调用 &lt;code&gt;a&lt;/code&gt; （带有参数 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; ）的结果；否则， &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8451ba8a14d79753d34cb33b51ba46b4b025eb81" translate="yes" xml:space="preserve">
          <source>super</source>
          <target state="translated">super</target>
        </trans-unit>
        <trans-unit id="e7c2a4c990184f8b6e86a548b889c307e41a3860" translate="yes" xml:space="preserve">
          <source>switch...when...else</source>
          <target state="translated">switch...when...else</target>
        </trans-unit>
        <trans-unit id="46aa5a11884223ec3dcfa5773b33d0a26fc9d06c" translate="yes" xml:space="preserve">
          <source>tests that &lt;code&gt;a&lt;/code&gt; is in scope and &lt;code&gt;a != null&lt;/code&gt;</source>
          <target state="translated">测试 &lt;code&gt;a&lt;/code&gt; 在范围内，并且 &lt;code&gt;a != null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f52d36be262c616a8c25a3ba007e4c58c101d1eb" translate="yes" xml:space="preserve">
          <source>try...catch...finally</source>
          <target state="translated">try...catch...finally</target>
        </trans-unit>
        <trans-unit id="42e184930956d048c819e40f18f94f0094d47bc6" translate="yes" xml:space="preserve">
          <source>unless</source>
          <target state="translated">unless</target>
        </trans-unit>
        <trans-unit id="6517f89c46c3f0d6db9cb009b8c7d1f98c371fa0" translate="yes" xml:space="preserve">
          <source>while</source>
          <target state="translated">while</target>
        </trans-unit>
        <trans-unit id="f12e1e8f455f823f59cc0134f1795184b98fe5ac" translate="yes" xml:space="preserve">
          <source>yield</source>
          <target state="translated">yield</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
