<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="3e20fcd0dc8894a575034d1d37150331fce67f9a" translate="yes" xml:space="preserve">
          <source>List all notification filters in an agent.</source>
          <target state="translated">列出代理中的所有通知过滤器。</target>
        </trans-unit>
        <trans-unit id="433e9558c472f250dda9655b9de01d8c5b1cbc95" translate="yes" xml:space="preserve">
          <source>List comprehensions are analogous to set comprehensions in Zermelo-Frankel set theory and are called ZF expressions in Miranda. They are analogous to the &lt;code&gt;setof&lt;/code&gt; and &lt;code&gt;findall&lt;/code&gt; predicates in Prolog.</source>
          <target state="translated">列表推导类似于Zermelo-Frankel集合论中的集合推导，在Miranda中称为ZF表达式。它们类似于Prolog中的 &lt;code&gt;setof&lt;/code&gt; 和 &lt;code&gt;findall&lt;/code&gt; 谓词。</target>
        </trans-unit>
        <trans-unit id="493415e452a1ca58d7ab0e55c11450201b1caf07" translate="yes" xml:space="preserve">
          <source>List comprehensions are written with the following syntax:</source>
          <target state="translated">列表理解的写法如下语法。</target>
        </trans-unit>
        <trans-unit id="f643c07aa2da6eaa1122e1bfdb07a56a6d60470e" translate="yes" xml:space="preserve">
          <source>List comprehensions is a feature of many modern functional programming languages. Subject to certain rules, they provide a succinct notation for generating elements in a list.</source>
          <target state="translated">列表理解是许多现代函数式编程语言的一个特点。根据一定的规则,它们为生成列表中的元素提供了一个简洁的符号。</target>
        </trans-unit>
        <trans-unit id="c0adcf806e6c6cb4dd52f21d37c6386d7fc26ec4" translate="yes" xml:space="preserve">
          <source>List comprehensions used to be implemented using funs, and in the old days funs were indeed slow.</source>
          <target state="translated">列表理解以前是用funs实现的,以前的funs确实很慢。</target>
        </trans-unit>
        <trans-unit id="6a97adf09881d30899eb88074972670e34c92836" translate="yes" xml:space="preserve">
          <source>List comprehensions with low-level &lt;code&gt;Mnesia&lt;/code&gt; functions can be combined in the same transaction. To raise the salary of all female employees, execute the following:</source>
          <target state="translated">具有低级 &lt;code&gt;Mnesia&lt;/code&gt; 功能的列表理解可以合并到同一事务中。要提高所有女性雇员的工资，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="49eee1559f1ee0d2b82c81d4f588a2ed770857f0" translate="yes" xml:space="preserve">
          <source>List comprehensions.</source>
          <target state="translated">列举理解。</target>
        </trans-unit>
        <trans-unit id="05e97a2b6e38fea3735726e5819ee8ba95e83bc5" translate="yes" xml:space="preserve">
          <source>List elements are the UTF-8 encodings of the individual characters in the string. Invalid codepoints will result in encode/decode failure. On encode, a UTF8String() can be specified as a binary, or as a nested list of binaries and codepoints.</source>
          <target state="translated">列表元素是字符串中单个字符的UTF-8编码。无效的编码点将导致编码/解码失败。在编码时,一个UTF8String()可以被指定为一个二进制,或者是一个二进制和编码点的嵌套列表。</target>
        </trans-unit>
        <trans-unit id="278d3b4f4ee0740a1de4cdf1bd2bf93be61d3954" translate="yes" xml:space="preserve">
          <source>List of algorithms to use in the algorithm negotiation. The default &lt;code&gt;algs_list()&lt;/code&gt; can be obtained from &lt;code&gt;&lt;a href=&quot;#default_algorithms-0&quot;&gt;default_algorithms/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在算法协商中使用的算法列表。可以从 &lt;code&gt;&lt;a href=&quot;#default_algorithms-0&quot;&gt;default_algorithms/0&lt;/a&gt;&lt;/code&gt; 获得默认的 &lt;code&gt;algs_list()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9db4243408e7145f00857f4260325dcb24458c15" translate="yes" xml:space="preserve">
          <source>List of extra arguments to the user callback functions. See the the reference manual for megaco_user for more info.</source>
          <target state="translated">用户回调函数的额外参数列表。更多信息请参见megaco_user的参考手册。</target>
        </trans-unit>
        <trans-unit id="46ea5ca4efb80ab899337d420e90c90285a406b1" translate="yes" xml:space="preserve">
          <source>List of protocols to send to the client if the client indicates that it supports the Next Protocol extension. The client can select a protocol that is not on this list. The list of protocols must not contain an empty binary. If the server negotiates a Next Protocol, it can be accessed using the &lt;code&gt;negotiated_next_protocol/1&lt;/code&gt; method.</source>
          <target state="translated">如果客户端指示它支持下一协议扩展，则发送给客户端的协议列表。客户端可以选择不在此列表上的协议。协议列表不得包含空二进制文件。如果服务器协商下一个协议，则可以使用 &lt;code&gt;negotiated_next_protocol/1&lt;/code&gt; 方法对其进行访问。</target>
        </trans-unit>
        <trans-unit id="98e5b6b3bdd287b5c011c0b0403e09b9164fe07d" translate="yes" xml:space="preserve">
          <source>List of unicode codepoints, a UTF-8 encoded binary, or a mix of the two, representing an &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; compliant URI (&lt;strong&gt;percent-encoded form&lt;/strong&gt;). A URI is a sequence of characters from a very limited set: the letters of the basic Latin alphabet, digits, and a few special characters.</source>
          <target state="translated">Unicode编码点列表，UTF-8编码的二进制或两者的混合，代表 &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; 兼容URI（&lt;strong&gt;百分比编码形式&lt;/strong&gt;）。URI是一组非常有限的字符序列：基本拉丁字母的字母，数字和一些特殊字符。</target>
        </trans-unit>
        <trans-unit id="d93d5d53babf56ebe1e390ba9a950fbf91d0cb2b" translate="yes" xml:space="preserve">
          <source>List of user (client) public key algorithms to try to use.</source>
          <target state="translated">要尝试使用的用户(客户端)公钥算法列表。</target>
        </trans-unit>
        <trans-unit id="cc9f7cb6591bec743e823fe706dead283d4905b5" translate="yes" xml:space="preserve">
          <source>List of variable bindings in the shell environment.</source>
          <target state="translated">shell环境中的变量绑定列表。</target>
        </trans-unit>
        <trans-unit id="f80b12db0f84fe26ec9bd3ed10dcbee12e085184" translate="yes" xml:space="preserve">
          <source>List processing</source>
          <target state="translated">名单处理</target>
        </trans-unit>
        <trans-unit id="8b3923bc8621a43a87bb226f3d90850a4f20ee30" translate="yes" xml:space="preserve">
          <source>List processing functions.</source>
          <target state="translated">列表处理功能。</target>
        </trans-unit>
        <trans-unit id="53479af7c4b258e47635cf3f831bd457573f3848" translate="yes" xml:space="preserve">
          <source>List the id's of all engines in OpenSSL's internal list.</source>
          <target state="translated">列出OpenSSL内部列表中所有引擎的id。</target>
        </trans-unit>
        <trans-unit id="a2cf5c534cf79a3ef7abbfc9f78dcce0140e6482" translate="yes" xml:space="preserve">
          <source>Listing without class combiner.</source>
          <target state="translated">没有类组合器的列表。</target>
        </trans-unit>
        <trans-unit id="9d1f72a30a3a6c56319d5de301e7dcd8d4ea9184" translate="yes" xml:space="preserve">
          <source>Lists all TCP, UDP and SCTP sockets, including those that the Erlang runtime system uses as well as those created by the application.</source>
          <target state="translated">列出所有TCP、UDP和SCTP套接字,包括Erlang运行时系统使用的套接字和应用程序创建的套接字。</target>
        </trans-unit>
        <trans-unit id="4337868b9d860ba3caf101beb26d92ab8c3abdd4" translate="yes" xml:space="preserve">
          <source>Lists all active connections for this user. Returns a list of megaco_conn_handle records.</source>
          <target state="translated">列出该用户的所有活动连接。返回megaco_conn_handle记录的列表。</target>
        </trans-unit>
        <trans-unit id="2714b113edcc2a65636a1ec94ae0d858a92ee520" translate="yes" xml:space="preserve">
          <source>Lists all active connections. Returns a list of megaco_conn_handle records.</source>
          <target state="translated">列出所有活动的连接。返回megaco_conn_handle记录的列表。</target>
        </trans-unit>
        <trans-unit id="c14044ad12ace6bccaea0455b877c42c13dc64aa" translate="yes" xml:space="preserve">
          <source>Lists all active users. Returns a list of megaco_mid()'s.</source>
          <target state="translated">列出所有活跃用户。返回megaco_mid()的列表。</target>
        </trans-unit>
        <trans-unit id="09883357a748a23703460bb6b31f36dc6eb24786" translate="yes" xml:space="preserve">
          <source>Lists all available start flags.</source>
          <target state="translated">列出所有可用的起始标志。</target>
        </trans-unit>
        <trans-unit id="4edfc25b8c7646b4111ec287d11e328fd05b2ca3" translate="yes" xml:space="preserve">
          <source>Lists all entries in the specified configuration file.</source>
          <target state="translated">列出指定配置文件中的所有条目。</target>
        </trans-unit>
        <trans-unit id="2c53d0f7e8e7f87d95870b0e5dd392fdbd1aed3a" translate="yes" xml:space="preserve">
          <source>Lists all files in a directory, &lt;strong&gt;except&lt;/strong&gt; files with raw filenames. Returns &lt;code&gt;{ok, Filenames}&lt;/code&gt; if successful, otherwise &lt;code&gt;{error, Reason}&lt;/code&gt;. &lt;code&gt;Filenames&lt;/code&gt; is a list of the names of all the files in the directory. The names are not sorted.</source>
          <target state="translated">列出目录中的所有文件，带有原始文件名的文件&lt;strong&gt;除外&lt;/strong&gt;。如果成功，则返回 &lt;code&gt;{ok, Filenames}&lt;/code&gt; ，否则返回 &lt;code&gt;{error, Reason}&lt;/code&gt; 。 &lt;code&gt;Filenames&lt;/code&gt; 是目录中所有文件名的列表。名称未排序。</target>
        </trans-unit>
        <trans-unit id="e14a213355b4d17f65990a6133f694eb009717fd" translate="yes" xml:space="preserve">
          <source>Lists all jobs. A list of all known jobs is printed. The current job name is prefixed with '*'.</source>
          <target state="translated">列出所有工作。打印所有已知作业的列表。当前的作业名称前有'*'。</target>
        </trans-unit>
        <trans-unit id="d449a2e13ab08f8d884a484f2a845df785c5c0f1" translate="yes" xml:space="preserve">
          <source>Lists all modified modules. Shorthand for &lt;code&gt;code:modified_modules/0&lt;/code&gt;.</source>
          <target state="translated">列出所有修改的模块。 &lt;code&gt;code:modified_modules/0&lt;/code&gt; 简写：modified_modules / 0。</target>
        </trans-unit>
        <trans-unit id="9e08270ad4d1c057bd6013ee9f18877c27d91e14" translate="yes" xml:space="preserve">
          <source>Lists all reports loaded in &lt;code&gt;rb_server&lt;/code&gt;. Each report is given a unique number that can be used as a reference to the report in function &lt;code&gt;&lt;a href=&quot;#show-1&quot;&gt;show/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">列出加载在 &lt;code&gt;rb_server&lt;/code&gt; 中的所有报告。每个报告都有一个唯一的编号，可以在 &lt;code&gt;&lt;a href=&quot;#show-1&quot;&gt;show/1&lt;/a&gt;&lt;/code&gt; 函数中用作对该报告的引用。</target>
        </trans-unit>
        <trans-unit id="3d585b5f080c2320d84337d311297ce3312051fb" translate="yes" xml:space="preserve">
          <source>Lists all the files in a directory, including files with raw filenames. Returns &lt;code id=&quot;list_dir_all&quot;&gt;{ok, Filenames}&lt;/code&gt; if successful, otherwise &lt;code&gt;{error, Reason}&lt;/code&gt;. &lt;code&gt;Filenames&lt;/code&gt; is a list of the names of all the files in the directory. The names are not sorted.</source>
          <target state="translated">列出目录中的所有文件，包括带有原始文件名的文件。如果成功，则返回 &lt;code id=&quot;list_dir_all&quot;&gt;{ok, Filenames}&lt;/code&gt; ，否则返回 &lt;code&gt;{error, Reason}&lt;/code&gt; 。 &lt;code&gt;Filenames&lt;/code&gt; 是目录中所有文件名的列表。名称未排序。</target>
        </trans-unit>
        <trans-unit id="02f72b758a50a88ea9e456ce7bb76a0ffe8cb08d" translate="yes" xml:space="preserve">
          <source>Lists all the files in a directory. Returns &lt;code&gt;{ok, Filenames}&lt;/code&gt; if successful, otherwise &lt;code&gt;error&lt;/code&gt;. &lt;code&gt;Filenames&lt;/code&gt; is a list of the names of all the files in the directory. The names are not sorted.</source>
          <target state="translated">列出目录中的所有文件。如果成功，则返回 &lt;code&gt;{ok, Filenames}&lt;/code&gt; ，否则返回 &lt;code&gt;error&lt;/code&gt; 。 &lt;code&gt;Filenames&lt;/code&gt; 是目录中所有文件名的列表。名称未排序。</target>
        </trans-unit>
        <trans-unit id="4410d2b8ea4abd8b562807aff638f01d51fdbe5b" translate="yes" xml:space="preserve">
          <source>Lists are compared element by element. Tuples are ordered by size, two tuples with the same size are compared element by element.</source>
          <target state="translated">列表是按元素进行比较的。图元组按大小排序,两个大小相同的图元组按元素进行比较。</target>
        </trans-unit>
        <trans-unit id="aaaad5080a7d5e7990259ba71c1c2a741010f595" translate="yes" xml:space="preserve">
          <source>Lists can only be built starting from the end and attaching list elements at the beginning. If you use the &quot;&lt;code&gt;++&lt;/code&gt;&quot; operator as follows, a new list is created that is a copy of the elements in &lt;code&gt;List1&lt;/code&gt;, followed by &lt;code&gt;List2&lt;/code&gt;:</source>
          <target state="translated">只能从末尾开始构建列表，并在开头附加列表元素。如果按如下方式使用&amp;ldquo; &lt;code&gt;++&lt;/code&gt; &amp;rdquo;运算符，则会创建一个新列表，该列表是 &lt;code&gt;List1&lt;/code&gt; 中元素的副本，后跟 &lt;code&gt;List2&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4926eced8ea62bd521cb340059a74702d8b7f96d" translate="yes" xml:space="preserve">
          <source>Lists comprehensions still have a reputation for being slow. They used to be implemented using funs, which used to be slow.</source>
          <target state="translated">Lists comprehensions仍然以慢著称。它们过去是用funs实现的,而funs过去是很慢的。</target>
        </trans-unit>
        <trans-unit id="813529648a19db76d9b2436854b7d6cbfd832327" translate="yes" xml:space="preserve">
          <source>Lists directory &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">列出目录 &lt;code&gt;Dir&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7ad6d844316d235b7276ea8fedc7b6ce5feb6d2" translate="yes" xml:space="preserve">
          <source>Lists files in directory &lt;code&gt;Dir&lt;/code&gt; or, if &lt;code&gt;Dir&lt;/code&gt; is a file, only lists it.</source>
          <target state="translated">列出目录 &lt;code&gt;Dir&lt;/code&gt; 中的文件，或者如果 &lt;code&gt;Dir&lt;/code&gt; 是文件，则仅列出它。</target>
        </trans-unit>
        <trans-unit id="89af84891678e7a6adbb862fe15a05f7928921ee" translate="yes" xml:space="preserve">
          <source>Lists files in the current directory.</source>
          <target state="translated">列出当前目录下的文件。</target>
        </trans-unit>
        <trans-unit id="c58c2a350f07347551b9f3634b864bd30234359c" translate="yes" xml:space="preserve">
          <source>Lists names registered with the currently running &lt;code&gt;epmd&lt;/code&gt;.</source>
          <target state="translated">列出在当前运行的 &lt;code&gt;epmd&lt;/code&gt; 中注册的名称。</target>
        </trans-unit>
        <trans-unit id="6d04787e574b0b36059101cd1aba185b5fe294f5" translate="yes" xml:space="preserve">
          <source>Lists the given directory on the server, returning the filenames as a list of strings.</source>
          <target state="translated">列出服务器上给定的目录,以字符串列表的形式返回文件名。</target>
        </trans-unit>
        <trans-unit id="a5b64a6325e7fd542159a3c84889b713d8f57a43" translate="yes" xml:space="preserve">
          <source>Lisu</source>
          <target state="translated">Lisu</target>
        </trans-unit>
        <trans-unit id="4dca4b373f502fbb16dccc9e0b7237d86410b372" translate="yes" xml:space="preserve">
          <source>Load &lt;code&gt;Mibs&lt;/code&gt; into an agent. If the agent cannot load all MIBs (the default value of the &lt;code&gt;Force&lt;/code&gt; argument is &lt;code&gt;false&lt;/code&gt;), it will indicate where loading was aborted. The &lt;code&gt;MibName&lt;/code&gt; is the name of the Mib, including the path to where the compiled mib is found. For example,</source>
          <target state="translated">将 &lt;code&gt;Mibs&lt;/code&gt; 装入代理。如果代理无法加载所有MIB（ &lt;code&gt;Force&lt;/code&gt; 参数的默认值为 &lt;code&gt;false&lt;/code&gt; ），它将指示加载在何处中止。该 &lt;code&gt;MibName&lt;/code&gt; MIB的名称，包括路径到编译MIB发现。例如，</target>
        </trans-unit>
        <trans-unit id="c4d7f412fb063f70b02868e384179ef9d1b1a087" translate="yes" xml:space="preserve">
          <source>Load a &lt;code&gt;Mib&lt;/code&gt; into the manager. The &lt;code&gt;MibName&lt;/code&gt; is the name of the Mib, including the path to where the compiled mib is found. For example,</source>
          <target state="translated">将 &lt;code&gt;Mib&lt;/code&gt; 加载到管理器中。该 &lt;code&gt;MibName&lt;/code&gt; MIB的名称，包括路径到编译MIB发现。例如，</target>
        </trans-unit>
        <trans-unit id="b3e3360ea19707f02f4a020e3f19c3e4bc8449f2" translate="yes" xml:space="preserve">
          <source>Load a crypto engine, should be done once per engine used. For example dynamically load the engine called &lt;code&gt;MyEngine&lt;/code&gt;:</source>
          <target state="translated">加载加密引擎，每个引擎应执行一次。例如，动态加载名为 &lt;code&gt;MyEngine&lt;/code&gt; 的引擎：</target>
        </trans-unit>
        <trans-unit id="8a579cb5ea4d299e98f6e3305e729a2e2691eb3c" translate="yes" xml:space="preserve">
          <source>Load a single &lt;code&gt;Mib&lt;/code&gt; into an agent. The &lt;code&gt;MibName&lt;/code&gt; is the name of the Mib, including the path to where the compiled mib is found. For example:</source>
          <target state="translated">将单个 &lt;code&gt;Mib&lt;/code&gt; 加载到代理中。该 &lt;code&gt;MibName&lt;/code&gt; MIB的名称，包括路径到编译MIB发现。例如：</target>
        </trans-unit>
        <trans-unit id="c51c159c86fd747d2e5230014dcc8e2ec41e6224" translate="yes" xml:space="preserve">
          <source>Load an engine with the help of the dynamic engine and just replace some engine methods.</source>
          <target state="translated">在动态引擎的帮助下加载一个引擎,只需替换一些引擎方法即可。</target>
        </trans-unit>
        <trans-unit id="4c42d226cb6d70b946e6d5b82bc4c3543f9c44ef" translate="yes" xml:space="preserve">
          <source>Load an engine with the help of the dynamic engine by giving the path to the library.</source>
          <target state="translated">在动态引擎的帮助下,通过给出库的路径来加载一个引擎。</target>
        </trans-unit>
        <trans-unit id="32bc843d0b756c56e85673fa55374b9397575f9a" translate="yes" xml:space="preserve">
          <source>Load distribution facility.</source>
          <target state="translated">负荷分配设施。</target>
        </trans-unit>
        <trans-unit id="76bad6da55b53cc690e8073bcd70b2d51d7df367" translate="yes" xml:space="preserve">
          <source>Load mode. Loads all recompiled modules.</source>
          <target state="translated">加载模式。加载所有重新编译的模块。</target>
        </trans-unit>
        <trans-unit id="2cccf6ad0728e7b357295554e6d28b49c3a4a67a" translate="yes" xml:space="preserve">
          <source>Load raw Erlang trace from a file, port or process.</source>
          <target state="translated">从文件、端口或进程加载原始 Erlang 跟踪。</target>
        </trans-unit>
        <trans-unit id="9270554fc2af7c0fd3400f7998148c1961fce683" translate="yes" xml:space="preserve">
          <source>Load the &lt;code&gt;dyntrace&lt;/code&gt; module.</source>
          <target state="translated">加载 &lt;code&gt;dyntrace&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="c237f6e4c5365a30ac145a8b509d8e8b9dd96a4d" translate="yes" xml:space="preserve">
          <source>Load the compiled MIB into the agent.</source>
          <target state="translated">将编译后的MIB加载到代理中。</target>
        </trans-unit>
        <trans-unit id="20c1d6dc95e25c92e1610b1211f7233c890d0b64" translate="yes" xml:space="preserve">
          <source>Load the event table from a file.</source>
          <target state="translated">从文件中加载事件表。</target>
        </trans-unit>
        <trans-unit id="a92787cc36930707fbb75a6d9a3de46ba71425a8" translate="yes" xml:space="preserve">
          <source>Load the mib specified by the &lt;code&gt;Filename&lt;/code&gt; argument into the mib-server. The &lt;code&gt;MeOverride&lt;/code&gt; and &lt;code&gt;TeOverride&lt;/code&gt; arguments specifies how the mib-server shall handle duplicate mib- and trap- entries.</source>
          <target state="translated">将 &lt;code&gt;Filename&lt;/code&gt; 参数指定的mib加载到mib服务器中。该 &lt;code&gt;MeOverride&lt;/code&gt; 和 &lt;code&gt;TeOverride&lt;/code&gt; 参数指定MIB-服务器应如何处理重复的MIB-和TRAP-条目。</target>
        </trans-unit>
        <trans-unit id="ffabdc1b0aada0df09c6b33e94264210e3036668" translate="yes" xml:space="preserve">
          <source>Loading and Unloading of OTP-OS-MON-MIB</source>
          <target state="translated">OTP-OS-MON-MIB的加载和卸载。</target>
        </trans-unit>
        <trans-unit id="59f753c4a89d6cb4b2fbf224764ebcc567bab7f3" translate="yes" xml:space="preserve">
          <source>Loading and unloading of MIBs are quite cheap operations. However, if the application does this very often, perhaps several times per minute, it should load the MIBs once and for all in a sub-agent. This sub-agent only registers and unregisters itself under another agent instead of loading the MIBs each time. This is cheaper than loading an MIB.</source>
          <target state="translated">MIB的加载和卸载是相当便宜的操作。然而,如果应用程序经常这样做,也许每分钟要做几次,它应该在一个子代理中一次性加载MIB。这个子代理只在另一个代理下注册和解注册自己,而不是每次都加载MIBs。这比加载一个MIB要便宜。</target>
        </trans-unit>
        <trans-unit id="4bbdf176626164bdc51fe89c8ab7ac24003faec2" translate="yes" xml:space="preserve">
          <source>Loading can fail for one the following reasons:</source>
          <target state="translated">加载失败的原因有以下几种:</target>
        </trans-unit>
        <trans-unit id="c7b4c7383cbd28718a91c4b0a187d7de34640193" translate="yes" xml:space="preserve">
          <source>Loading on previous releases is &lt;strong&gt;not&lt;/strong&gt; supported.</source>
          <target state="translated">&lt;strong&gt;不&lt;/strong&gt;支持在以前的版本中加载。</target>
        </trans-unit>
        <trans-unit id="b3ddb8527fe2c15b0846a1df5469d7936b6ac994" translate="yes" xml:space="preserve">
          <source>Loading tables at startup</source>
          <target state="translated">启动时加载表格</target>
        </trans-unit>
        <trans-unit id="262bab97e2113ec92485a2a01d5cabfcd110e445" translate="yes" xml:space="preserve">
          <source>Loading the NIF library overrides the stub implementations and cause calls to &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; to be dispatched to the NIF implementations instead.</source>
          <target state="translated">加载NIF库会覆盖存根实现，并导致对 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt; 的调用被分派到NIF实现。</target>
        </trans-unit>
        <trans-unit id="766009fe24c4fa886de18bd755755efdbd37a7b5" translate="yes" xml:space="preserve">
          <source>Loading/unloading an application does not load/unload the code used by the application. Code loading is done the usual way.</source>
          <target state="translated">加载/卸载应用程序不会加载/卸载应用程序使用的代码。代码加载是以通常的方式进行的。</target>
        </trans-unit>
        <trans-unit id="595a176aa31ecdb076d6a4fbcfdce5bb9c525cbc" translate="yes" xml:space="preserve">
          <source>Loads &lt;code&gt;Module&lt;/code&gt; on all nodes.</source>
          <target state="translated">在所有节点上加载 &lt;code&gt;Module&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ffc53d4569575bdb25ef1541658266ca11f4420" translate="yes" xml:space="preserve">
          <source>Loads a new module &lt;code&gt;Mod&lt;/code&gt;.</source>
          <target state="translated">加载新模块 &lt;code&gt;Mod&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="663b889f55fd7cc7ec3d743d418d4fed670a69b0" translate="yes" xml:space="preserve">
          <source>Loads a series of definitions and data found in the text file (generated with &lt;code&gt;mnesia:dump_to_textfile/1&lt;/code&gt;) into Mnesia. This function also starts Mnesia and possibly creates a new schema. This function is intended for educational purposes only. It is recommended to use other functions to deal with real backups.</source>
          <target state="translated">将在文本文件（使用 &lt;code&gt;mnesia:dump_to_textfile/1&lt;/code&gt; 生成）中找到的一系列定义和数据加载到Mnesia中。此功能还会启动Mnesia，并可能创建一个新的架构。此功能仅用于教育目的。建议使用其他功能来处理实际备份。</target>
        </trans-unit>
        <trans-unit id="5b69f0a046ca1124c0aebf63391cf8345c5a3dd5" translate="yes" xml:space="preserve">
          <source>Loads and links a dynamic library containing native implemented functions (NIFs) for a module. &lt;code&gt;Path&lt;/code&gt; is a file path to the shareable object/dynamic library file minus the OS-dependent file extension (&lt;code&gt;.so&lt;/code&gt; for Unix and &lt;code&gt;.dll&lt;/code&gt; for Windows). Notice that on most OSs the library has to have a different name on disc when an upgrade of the nif is done. If the name is the same, but the contents differ, the old library may be loaded instead. For information on how to implement a NIF library, see &lt;code&gt;&lt;a href=&quot;erl_nif&quot;&gt;erl_nif(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">加载并链接包含一个模块的本机实现功能（NIF）的动态库。 &lt;code&gt;Path&lt;/code&gt; 是可共享对象/动态库文件的文件路径，减去操作系统相关的文件扩展名（对于Unix是 &lt;code&gt;.so&lt;/code&gt; ，对于Windows是 &lt;code&gt;.dll&lt;/code&gt; ）。请注意，在大多数操作系统上，完成nif升级后，该库在磁盘上的名称必须不同。如果名称相同，但内容不同，则可以加载旧库。有关如何实现NIF库的信息，请参见 &lt;code&gt;&lt;a href=&quot;erl_nif&quot;&gt;erl_nif(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82f1623ae8a87546c7dd248aabd05fecaf6a3b4a" translate="yes" xml:space="preserve">
          <source>Loads and links the dynamic driver &lt;code&gt;Name&lt;/code&gt;. &lt;code&gt;Path&lt;/code&gt; is a file path to the directory containing the driver. &lt;code&gt;Name&lt;/code&gt; must be a sharable object/dynamic library. Two drivers with different &lt;code&gt;Path&lt;/code&gt; parameters cannot be loaded under the same name. &lt;code&gt;Name&lt;/code&gt; is a string or atom containing at least one character.</source>
          <target state="translated">加载并链接动态驱动程序 &lt;code&gt;Name&lt;/code&gt; 。 &lt;code&gt;Path&lt;/code&gt; 是包含驱动程序的目录的文件路径。 &lt;code&gt;Name&lt;/code&gt; 必须是可共享的对象/动态库。无法使用相同的名称加载具有不同 &lt;code&gt;Path&lt;/code&gt; 参数的两个驱动程序。 &lt;code&gt;Name&lt;/code&gt; 是包含至少一个字符的字符串或原子。</target>
        </trans-unit>
        <trans-unit id="a9103067a9d66d079fdfa3978fe03390b072c888" translate="yes" xml:space="preserve">
          <source>Loads configuration variables using the specified callback module and configuration string. The callback module is to be either loaded or present in the code part. Loaded configuration variables can later be removed using function &lt;code&gt;&lt;a href=&quot;#remove_config-2&quot;&gt;ct:remove_config/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用指定的回调模块和配置字符串加载配置变量。回调模块将被加载或存在于代码部分中。稍后可以使用功能 &lt;code&gt;&lt;a href=&quot;#remove_config-2&quot;&gt;ct:remove_config/2&lt;/a&gt;&lt;/code&gt; 删除已加载的配置变量。</target>
        </trans-unit>
        <trans-unit id="92030378678e8bb7a8c82cb9b51ba59dd5bd9509" translate="yes" xml:space="preserve">
          <source>Loads the MIBs into agent &lt;code&gt;snmp_master_agent&lt;/code&gt;.</source>
          <target state="translated">将MIB加载到代理 &lt;code&gt;snmp_master_agent&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="4dbafa4e360e2579c05082b7f407c76430fb3b56" translate="yes" xml:space="preserve">
          <source>Loads the OTP-MIB.</source>
          <target state="translated">加载OTP-MIB。</target>
        </trans-unit>
        <trans-unit id="309db15774fbe5a771972504b9f3ef690359b4c3" translate="yes" xml:space="preserve">
          <source>Loads the OTP-OS-MON-MIB.</source>
          <target state="translated">加载OTP-OS-MON-MIB。</target>
        </trans-unit>
        <trans-unit id="294bfed427ce1e4aaf41a120556a07d884c20438" translate="yes" xml:space="preserve">
          <source>Loads the OpenSSL engine given by &lt;code&gt;EngineId&lt;/code&gt; if it is available and then returns ok and an engine handle. An error tuple is returned if the engine can't be loaded.</source>
          <target state="translated">加载由 &lt;code&gt;EngineId&lt;/code&gt; 提供的OpenSSL引擎（如果可用），然后返回ok和引擎句柄。如果无法加载引擎，则会返回一个错误的元组。</target>
        </trans-unit>
        <trans-unit id="19c49f3d4456a895329c5795a2a2e050a1652c20" translate="yes" xml:space="preserve">
          <source>Loads the OpenSSL engine given by &lt;code&gt;EngineId&lt;/code&gt; if it is available and then returns ok and an engine handle. This function is the same as calling &lt;code&gt;engine_load/4&lt;/code&gt; with &lt;code&gt;EngineMethods&lt;/code&gt; set to a list of all the possible methods. An error tuple is returned if the engine can't be loaded.</source>
          <target state="translated">加载由 &lt;code&gt;EngineId&lt;/code&gt; 提供的OpenSSL引擎（如果可用），然后返回ok和引擎句柄。此功能与调用 &lt;code&gt;engine_load/4&lt;/code&gt; 与 &lt;code&gt;EngineMethods&lt;/code&gt; 设置为所有可能的方法的列表。如果无法加载引擎，则会返回一个错误的元组。</target>
        </trans-unit>
        <trans-unit id="40397b451950fbe4fa114fa0103e62e80e7fa347" translate="yes" xml:space="preserve">
          <source>Loads the application specification for an application into the application controller. It also loads the application specifications for any included applications. Notice that the function does not load the Erlang object code.</source>
          <target state="translated">将应用程序的应用程序规范加载到应用程序控制器中。它也加载任何包含的应用程序的应用程序规范。请注意,该函数不加载Erlang对象代码。</target>
        </trans-unit>
        <trans-unit id="ca0882de707c0d281667a21347a4ebcd6453edd4" translate="yes" xml:space="preserve">
          <source>Loads the modules &lt;code&gt;[Mod]&lt;/code&gt; from the directories specified in &lt;code&gt;Path&lt;/code&gt;. The script interpreter fetches the appropriate module by calling &lt;code&gt;erl_prim_loader:get_file(Mod)&lt;/code&gt;. A fatal error that terminates the system occurs if the module cannot be located.</source>
          <target state="translated">从 &lt;code&gt;Path&lt;/code&gt; 中指定的目录中加载模块 &lt;code&gt;[Mod]&lt;/code&gt; 。脚本解释器通过调用 &lt;code&gt;erl_prim_loader:get_file(Mod)&lt;/code&gt; 来获取适当的模块。如果找不到模块，则会发生致命错误并终止系统。</target>
        </trans-unit>
        <trans-unit id="b222c6a3c319314c492cf0438513476921b1937e" translate="yes" xml:space="preserve">
          <source>Local Calls (*).</source>
          <target state="translated">本地电话(*)。</target>
        </trans-unit>
        <trans-unit id="036d28f25e340f821fe07d1de47fc1a75ea76b56" translate="yes" xml:space="preserve">
          <source>Local Functions (*). All local functions of analyzed modules.</source>
          <target state="translated">本地函数(*)。分析模块的所有本地函数。</target>
        </trans-unit>
        <trans-unit id="fc554992a28c61639d93b552c374a6c7640f6fd7" translate="yes" xml:space="preserve">
          <source>Local and universal time, day of the week, date and time conversions.</source>
          <target state="translated">本地和通用时间、星期、日期和时间转换。</target>
        </trans-unit>
        <trans-unit id="3a24185719639d033f0e83cfef0d2ecbbd64ed33" translate="yes" xml:space="preserve">
          <source>Local content tables</source>
          <target state="translated">本地内容表</target>
        </trans-unit>
        <trans-unit id="eec0b138b64b9281f5ecd12aa0d772831301eadf" translate="yes" xml:space="preserve">
          <source>Local error handling (catch/throw).</source>
          <target state="translated">本地错误处理(抓/扔)。</target>
        </trans-unit>
        <trans-unit id="90de80d54249d1e2b8e04f06115d77bf6522dcbe" translate="yes" xml:space="preserve">
          <source>Local or remote process is monitored by name.</source>
          <target state="translated">本地或远程进程按名称进行监控。</target>
        </trans-unit>
        <trans-unit id="9c7734a4ec06d4dd200eb7b25986d4166f45276c" translate="yes" xml:space="preserve">
          <source>Local port is monitored by name. Please note, that remote port monitors are not supported, so &lt;code&gt;Node&lt;/code&gt; will always be the local node name.</source>
          <target state="translated">本地端口按名称监视。请注意，不支持远程端口监视器，因此 &lt;code&gt;Node&lt;/code&gt; 将始终是本地节点名称。</target>
        </trans-unit>
        <trans-unit id="e7d3e02be42f1c184b6a3c3c525e75c5179c0a77" translate="yes" xml:space="preserve">
          <source>Local port is monitored by port id.</source>
          <target state="translated">本地端口通过端口ID进行监控。</target>
        </trans-unit>
        <trans-unit id="5a6dd59b11d0e4520b4498e658eed0dbf5af795c" translate="yes" xml:space="preserve">
          <source>Local time is obtained from the Erlang BIF &lt;code&gt;localtime/0&lt;/code&gt;. Universal time is computed from the BIF &lt;code&gt;universaltime/0&lt;/code&gt;.</source>
          <target state="translated">本地时间是从Erlang BIF &lt;code&gt;localtime/0&lt;/code&gt; 获得的。通用时间是根据BIF &lt;code&gt;universaltime/0&lt;/code&gt; 计算的。</target>
        </trans-unit>
        <trans-unit id="4bbadc0e66c71769347f5cbcfb7c145c283ad8fd" translate="yes" xml:space="preserve">
          <source>LocalFunctionHandler,</source>
          <target state="translated">LocalFunctionHandler,</target>
        </trans-unit>
        <trans-unit id="fa3ca264b4b0fef6182372f6a2a3773355ef8380" translate="yes" xml:space="preserve">
          <source>Locally Used Functions (*). Functions of all modules that have been used in some local call.</source>
          <target state="translated">本地使用的函数(*)。在本地调用中使用过的所有模块的函数。</target>
        </trans-unit>
        <trans-unit id="5b09785286488bac8a487ce328cb324b03ce2288" translate="yes" xml:space="preserve">
          <source>Location data produced by the log macros, and/or metadata given as argument to the log call (API function or macro), are merged with the process metadata. If the same keys occur, values from the metadata argument to the log call overwrite values from the process metadata, which in turn overwrite values from the location data.</source>
          <target state="translated">由日志宏产生的位置数据和/或作为日志调用(API函数或宏)参数给出的元数据会与过程元数据合并。如果出现相同的键,则日志调用的元数据参数的值会覆盖过程元数据的值,而过程元数据的值又会覆盖位置数据的值。</target>
        </trans-unit>
        <trans-unit id="98d3b1967c02fdc780f97715c22bad74f36e5d2c" translate="yes" xml:space="preserve">
          <source>Location transparency. Programs can be written without knowledge of the actual data location.</source>
          <target state="translated">位置透明。可以在不知道实际数据位置的情况下编写程序。</target>
        </trans-unit>
        <trans-unit id="7786377791ba3a21918764c28fc12553cbbcfa4e" translate="yes" xml:space="preserve">
          <source>Location transparent version of the BIF &lt;code&gt;erlang:process_info/1&lt;/code&gt; in ERTS.</source>
          <target state="translated">ERTS中BIF &lt;code&gt;erlang:process_info/1&lt;/code&gt; 的位置透明版本。</target>
        </trans-unit>
        <trans-unit id="ee8a078095b685bbe1aa5a8273ed6ba602b4e833" translate="yes" xml:space="preserve">
          <source>Location transparent version of the BIF &lt;code&gt;erlang:process_info/2&lt;/code&gt; in ERTS.</source>
          <target state="translated">ERTS中BIF &lt;code&gt;erlang:process_info/2&lt;/code&gt; 的位置透明版本。</target>
        </trans-unit>
        <trans-unit id="7890346208b55e9f0de8ac7ad2436d80c5f1ce98" translate="yes" xml:space="preserve">
          <source>Lock &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Id&lt;/code&gt; for ports and processes are interchangeable with the use of &lt;code&gt;lcnt:swap_pid_keys/0&lt;/code&gt; and is the reason why &lt;code&gt;pid()&lt;/code&gt; and &lt;code&gt;port()&lt;/code&gt; options can be used in both &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Id&lt;/code&gt; space. Both pids and ports are special identifiers with stripped creation and can be recreated with &lt;code&gt;&lt;a href=&quot;#pid-3&quot;&gt;lcnt:pid/2,3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#port-2&quot;&gt;lcnt:port/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">端口和进程的锁 &lt;code&gt;Name&lt;/code&gt; 和 &lt;code&gt;Id&lt;/code&gt; 可与 &lt;code&gt;lcnt:swap_pid_keys/0&lt;/code&gt; 互换使用，这就是在 &lt;code&gt;Name&lt;/code&gt; 和 &lt;code&gt;Id&lt;/code&gt; 空间中都可以使用 &lt;code&gt;pid()&lt;/code&gt; 和 &lt;code&gt;port()&lt;/code&gt; 选项的原因。pid和port都是带剥离创建的特殊标识符，可以使用 &lt;code&gt;&lt;a href=&quot;#pid-3&quot;&gt;lcnt:pid/2,3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#port-2&quot;&gt;lcnt:port/1,2&lt;/a&gt;&lt;/code&gt; 重新创建。</target>
        </trans-unit>
        <trans-unit id="8a1f5f8eab7c8604bc5fd5406eb1dc291955e813" translate="yes" xml:space="preserve">
          <source>Lock physical memory. Defaults to &lt;code&gt;no&lt;/code&gt;, that is, no physical memory is locked. If set to &lt;code&gt;all&lt;/code&gt;, all memory mappings made by the runtime system are locked into physical memory. If set to &lt;code&gt;all&lt;/code&gt;, the runtime system fails to start if this feature is not supported, the user has not got enough privileges, or the user is not allowed to lock enough physical memory. The runtime system also fails with an out of memory condition if the user limit on the amount of locked memory is reached.</source>
          <target state="translated">锁定物理内存。默认为 &lt;code&gt;no&lt;/code&gt; ，即没有物理内存被锁定。如果设置为 &lt;code&gt;all&lt;/code&gt; ，则运行时系统进行的所有内存映射都将锁定到物理内存中。如果设置为 &lt;code&gt;all&lt;/code&gt; ，则在不支持此功能，用户没有足够的特权或者不允许用户锁定足够的物理内存时，运行时系统将无法启动。如果达到了用户对锁定内存量的限制，则运行时系统也会因内存不足而失败。</target>
        </trans-unit>
        <trans-unit id="d1d6079f6b5f44c82f4e240cfc0156faa4fc5b60" translate="yes" xml:space="preserve">
          <source>Locking</source>
          <target state="translated">Locking</target>
        </trans-unit>
        <trans-unit id="45057a24787103ff08cc02cd027e2fddb757a403" translate="yes" xml:space="preserve">
          <source>Locks a mutex. The calling thread is blocked until the mutex has been locked. A thread that has currently locked the mutex &lt;strong&gt;cannot&lt;/strong&gt; lock the same mutex again.</source>
          <target state="translated">锁定互斥锁。调用线程被阻塞，直到互斥锁已被锁定。当前已锁定互斥锁的线程&lt;strong&gt;无法&lt;/strong&gt;再次锁定同一互斥锁。</target>
        </trans-unit>
        <trans-unit id="07893be798653c5847566c8be8dbfc1f8e339a9a" translate="yes" xml:space="preserve">
          <source>Locks are released when the outermost transaction ends.</source>
          <target state="translated">当最外层的交易结束时,锁被释放。</target>
        </trans-unit>
        <trans-unit id="94c151cf6fbb179cda9bff3f3d73d852d7a92582" translate="yes" xml:space="preserve">
          <source>Locks have an inherent cost in execution time and memory space. It takes time initialize, destroy, aquiring or releasing locks. To decrease lock contention it some times necessary to use finer grained locking strategies. This will usually also increase the locking overhead and hence there is a tradeoff between lock contention and overhead. In general, lock contention increases with the number of threads running concurrently. The &lt;code&gt;lcnt&lt;/code&gt; tool does not measure locking overhead.</source>
          <target state="translated">锁在执行时间和存储空间上具有固有的成本。初始化，销毁，获取或释放锁需要时间。为了减少锁争用，有时必须使用更细粒度的锁策略。这通常也将增加锁定开销，因此在锁定争用和开销之间需要权衡。通常，锁争用随着并发运行的线程数而增加。该 &lt;code&gt;lcnt&lt;/code&gt; 工具不测量锁定开销。</target>
        </trans-unit>
        <trans-unit id="97e3b2745352de6be776b6b063835147719fb8df" translate="yes" xml:space="preserve">
          <source>Locks in the emulator are named after what type of resource they protect and where in the emulator they are initialized, those are lock 'classes'. Most of those locks are also instantiated several times, and given unique identifiers, to increase locking granularity. Typically an instantiated lock protects a disjunct set of the resource, for example ets tables, processes or ports. In other cases it protects a specific range of a resource, for example &lt;code&gt;pix_lock&lt;/code&gt; which protects index to process mappings, and is given a unique number within the class. A unique lock in &lt;code&gt;lcnt&lt;/code&gt; is referenced by a name (class) and an identifier: &lt;code&gt;{Name, Id}&lt;/code&gt;.</source>
          <target state="translated">仿真器中的锁以它们保护的资源类型以及在仿真器中的初始化位置（即锁&amp;ldquo;类&amp;rdquo;）命名。这些锁中的大多数还被实例化了几次，并赋予了唯一的标识符，以增加锁的粒度。通常，实例化的锁可保护资源的分离集，例如ets表，进程或端口。在其他情况下，它保护资源的特定范围，例如 &lt;code&gt;pix_lock&lt;/code&gt; ，它保护索引到进程的映射，并在类中被赋予唯一编号。 &lt;code&gt;lcnt&lt;/code&gt; 中的唯一锁由名称（类）和标识符 &lt;code&gt;{Name, Id}&lt;/code&gt; 引用。</target>
        </trans-unit>
        <trans-unit id="e8dbe53a83645d1cc991331113f81f0a7faf9914" translate="yes" xml:space="preserve">
          <source>Locks the configuration target.</source>
          <target state="translated">锁定配置目标。</target>
        </trans-unit>
        <trans-unit id="278c995aa0e75b2b9c086639c4daf158ccfe0917" translate="yes" xml:space="preserve">
          <source>Locks the driver used by the port &lt;code&gt;port&lt;/code&gt; in memory for the rest of the emulator process' lifetime. After this call, the driver behaves as one of Erlang's statically linked-in drivers.</source>
          <target state="translated">在仿真器进程的剩余寿命中，锁定端口 &lt;code&gt;port&lt;/code&gt; 在内存中使用的驱动程序。调用之后，该驱动程序将充当Erlang的静态链接驱动程序之一。</target>
        </trans-unit>
        <trans-unit id="877522e39f7783d66d9b87789ee2ec4ff4bf44e6" translate="yes" xml:space="preserve">
          <source>Locks the port data lock passed as argument (&lt;code&gt;pdl&lt;/code&gt;).</source>
          <target state="translated">锁定作为参数（ &lt;code&gt;pdl&lt;/code&gt; ）传递的端口数据锁。</target>
        </trans-unit>
        <trans-unit id="38f84854507a1065ca8c9cdcabd8f6b4e1e78700" translate="yes" xml:space="preserve">
          <source>Log a standard error event. Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">记录一个标准的错误事件。错误记录器将事件转发到Logger,包括元数据,允许向后兼容传统的错误记录器事件处理程序。</target>
        </trans-unit>
        <trans-unit id="d0480874641874b7e8e0be1a60fc5834def2580a" translate="yes" xml:space="preserve">
          <source>Log a standard error event. The &lt;code&gt;Format&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; arguments are the same as the arguments of &lt;code&gt;io:format/2&lt;/code&gt; in STDLIB.</source>
          <target state="translated">记录标准错误事件。的 &lt;code&gt;Format&lt;/code&gt; 和 &lt;code&gt;Data&lt;/code&gt; 参数是相同的参数 &lt;code&gt;io:format/2&lt;/code&gt; 在STDLIB。</target>
        </trans-unit>
        <trans-unit id="ad4ad09e24cbfd4d5d21372873fb510f9def4cc0" translate="yes" xml:space="preserve">
          <source>Log a standard information event. Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">记录一个标准信息事件。错误记录器将事件转发到记录器,包括元数据,允许向后兼容传统的错误记录器事件处理程序。</target>
        </trans-unit>
        <trans-unit id="b41037da94e8aee3e126b299e92f7fe2e27f3503" translate="yes" xml:space="preserve">
          <source>Log a standard information event. The &lt;code&gt;Format&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; arguments are the same as the arguments of &lt;code&gt;io:format/2&lt;/code&gt; in STDLIB.</source>
          <target state="translated">记录标准信息事件。的 &lt;code&gt;Format&lt;/code&gt; 和 &lt;code&gt;Data&lt;/code&gt; 参数是相同的参数 &lt;code&gt;io:format/2&lt;/code&gt; 在STDLIB。</target>
        </trans-unit>
        <trans-unit id="3fa6e0baa5d187967c02dcd11af5efcea6dd94e2" translate="yes" xml:space="preserve">
          <source>Log a standard warning event. Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">记录一个标准的警告事件。错误记录器将事件转发到Logger,包括元数据,允许向后兼容传统的错误记录器事件处理程序。</target>
        </trans-unit>
        <trans-unit id="0d4fed3a8c3034253fd45573f68ab458ca57cd12" translate="yes" xml:space="preserve">
          <source>Log a standard warning event. The &lt;code&gt;Format&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; arguments are the same as the arguments of &lt;code&gt;io:format/2&lt;/code&gt; in STDLIB.</source>
          <target state="translated">记录标准警告事件。的 &lt;code&gt;Format&lt;/code&gt; 和 &lt;code&gt;Data&lt;/code&gt; 参数是相同的参数 &lt;code&gt;io:format/2&lt;/code&gt; 在STDLIB。</target>
        </trans-unit>
        <trans-unit id="1844b1c7ae49d978743ba14c4e6a6dc7c218a27d" translate="yes" xml:space="preserve">
          <source>Log a user-defined error event. Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">记录一个用户定义的错误事件。错误记录器将事件转发到Logger,包括元数据,允许向后兼容传统的错误记录器事件处理程序。</target>
        </trans-unit>
        <trans-unit id="887d25b1b376c5062e3b1b29ffe4bc683a9b4867" translate="yes" xml:space="preserve">
          <source>Log a user-defined information event. Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">记录一个用户定义的信息事件。错误记录器将事件转发到记录器,包括元数据,允许向后兼容传统的错误记录器事件处理程序。</target>
        </trans-unit>
        <trans-unit id="6d52584bb8ee44c32d0e928afa86be59daa75386" translate="yes" xml:space="preserve">
          <source>Log a user-defined warning event. Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">记录一个用户定义的警告事件。错误记录器将事件转发到Logger,包括元数据,允许向后兼容传统的错误记录器事件处理程序。</target>
        </trans-unit>
        <trans-unit id="068d9dbd5d7dcab97d0cf593a32eb92cca768c9e" translate="yes" xml:space="preserve">
          <source>Log events that do not contain any domain field, match only when &lt;code&gt;Compare&lt;/code&gt; is equal to &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;not_equal&lt;/code&gt;.</source>
          <target state="translated">日志事件不包含任何域字段，仅当 &lt;code&gt;Compare&lt;/code&gt; 等于 &lt;code&gt;undefined&lt;/code&gt; 或 &lt;code&gt;not_equal&lt;/code&gt; 时才匹配。</target>
        </trans-unit>
        <trans-unit id="420705b9279101c5f7f8c29e1095fd25e0bd28a6" translate="yes" xml:space="preserve">
          <source>Log files are written in &lt;code&gt;log_dir&lt;/code&gt;. Each log file has a name of the form &lt;code&gt;erlang.log.N&lt;/code&gt;, where N is a generation number, ranging from 1 to 5. Each log file holds up to 100 kB text. As time goes by, the following log files are found in the log file directory:</source>
          <target state="translated">日志文件写入 &lt;code&gt;log_dir&lt;/code&gt; 。每个日志文件的名称格式为 &lt;code&gt;erlang.log.N&lt;/code&gt; ，其中N是世代号，范围为1到5。每个日志文件最多可容纳100 kB文本。随着时间的流逝，在日志文件目录中找到以下日志文​​件：</target>
        </trans-unit>
        <trans-unit id="a923af4f09938b28def56fc57c9c20863233189b" translate="yes" xml:space="preserve">
          <source>Log files from every repeated test run is saved in normal &lt;code&gt;Common Test&lt;/code&gt; fashion (described earlier).</source>
          <target state="translated">每次重复的测试运行中的日志文件都以普通的&amp;ldquo; &lt;code&gt;Common Test&lt;/code&gt; 方式保存（如前所述）。</target>
        </trans-unit>
        <trans-unit id="2578374749dfd011e3a5cbfbf27037022ad25cd6" translate="yes" xml:space="preserve">
          <source>Log files grow very large, very quickly.</source>
          <target state="translated">日志文件长得非常大,非常快。</target>
        </trans-unit>
        <trans-unit id="e92387004c6d91ee27198a23307e44f60b2be4d5" translate="yes" xml:space="preserve">
          <source>Log levels are expressed as atoms. Internally in Logger, the atoms are mapped to integer values, and a log event passes the log level check if the integer value of its log level is less than or equal to the currently configured log level. That is, the check passes if the event is equally or more severe than the configured level. See section &lt;code&gt;&lt;a href=&quot;#log_level&quot;&gt;Log Level&lt;/a&gt;&lt;/code&gt; for a listing and description of all log levels.</source>
          <target state="translated">对数水平表示为原子。在Logger内部，原子被映射为整数值，并且日志事件的日志级别的整数值小于或等于当前配置的日志级别，则日志事件通过日志级别检查。也就是说，如果事件的严重性等于或大于配置的级别，则检查通过。有关所有日志级别的列表和说明，请参阅 &lt;code&gt;&lt;a href=&quot;#log_level&quot;&gt;Log Level&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="e3d6b530f7c8342006e1b77a12ea94bab500b544" translate="yes" xml:space="preserve">
          <source>Log size.</source>
          <target state="translated">对数大小。</target>
        </trans-unit>
        <trans-unit id="2b4dcd80a65565039360cb58b9873fb3744a25eb" translate="yes" xml:space="preserve">
          <source>Log the given message.</source>
          <target state="translated">记录给定的信息。</target>
        </trans-unit>
        <trans-unit id="257f9074dd9a3273e0ecc0bf2277c09f48d1ab6f" translate="yes" xml:space="preserve">
          <source>Logger API functions that apply to handler configuration are:</source>
          <target state="translated">适用于处理机配置的记录仪API函数有:</target>
        </trans-unit>
        <trans-unit id="5304ec3e6860fd753d440e00b333f7b7952e2873" translate="yes" xml:space="preserve">
          <source>Logger API functions that apply to the primary Logger configuration are:</source>
          <target state="translated">适用于主要记录仪配置的记录仪 API 函数有:1:</target>
        </trans-unit>
        <trans-unit id="459822e04b58487fbab71512de0c13bbcb5802d9" translate="yes" xml:space="preserve">
          <source>Logger adds the following metadata to each log event:</source>
          <target state="translated">记录器为每个日志事件添加以下元数据。</target>
        </trans-unit>
        <trans-unit id="37165244e9071117a04c3897531cff43e65233d3" translate="yes" xml:space="preserve">
          <source>Logger allows adding multiple instances of a handler callback. That is, if a callback module implementation allows it, you can add multiple handler instances using the same callback module. The different instances are identified by unique handler identities.</source>
          <target state="translated">Logger 允许添加一个处理程序回调的多个实例。也就是说,如果回调模块的实现允许的话,你可以使用同一个回调模块添加多个处理程序实例。不同的实例由唯一的处理程序标识来识别。</target>
        </trans-unit>
        <trans-unit id="32814cbaff4ab32f839a5572bf470491707d186f" translate="yes" xml:space="preserve">
          <source>Logger does, to a certain extent, check its input data before forwarding a log event to filters and handlers. It does, however, not evaluate report callbacks, or check the validity of format strings and arguments. This means that all filters and handlers must be careful when formatting the data of a log event, making sure that it does not crash due to bad input data or faulty callbacks.</source>
          <target state="translated">在一定程度上,Logger 在将日志事件转发到过滤器和处理程序之前,会检查其输入数据。但是,它并不评估报告回调,也不检查格式字符串和参数的有效性。这意味着,所有过滤器和处理程序在格式化日志事件的数据时,必须小心谨慎,确保它不会因输入数据错误或回调错误而崩溃。</target>
        </trans-unit>
        <trans-unit id="5a30a202ff6e7537109cfe3ce75b8beb4047b16f" translate="yes" xml:space="preserve">
          <source>Logger merges all the metadata maps before forwarding the log event to the handlers. If the same keys occur, values from the log call overwrite process metadata, which in turn overwrite values set by Logger.</source>
          <target state="translated">在将日志事件转发到处理程序之前,Logger会合并所有的元数据映射。如果出现相同的键,来自日志调用的值就会覆盖进程元数据,而元数据又会覆盖Logger设置的值。</target>
        </trans-unit>
        <trans-unit id="12780a5781ba0da418e4440c2f80cf58b1993381" translate="yes" xml:space="preserve">
          <source>Logger provides backwards compatibility with &lt;code&gt;error_logger&lt;/code&gt; in the following ways:</source>
          <target state="translated">记录器通过以下方式提供与 &lt;code&gt;error_logger&lt;/code&gt; 的向后兼容性：</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Logging</target>
        </trans-unit>
        <trans-unit id="a4cf2d82c9d86421275e3d731c6c1f28619eb2da" translate="yes" xml:space="preserve">
          <source>Logging of events during execution</source>
          <target state="translated">执行过程中的事件记录</target>
        </trans-unit>
        <trans-unit id="70d888e147aabaf8fa1dfb2483f315253b5163ed" translate="yes" xml:space="preserve">
          <source>Logging to file with &lt;code&gt;ct:log/1,2,3,4,5&lt;/code&gt; or &lt;code&gt;ct:pal/1,2,3,4,5&lt;/code&gt; only works when &lt;code&gt;Common Test&lt;/code&gt; is running. Printouts with &lt;code&gt;ct:pal/1,2,3,4,5&lt;/code&gt; are however always displayed on screen.</source>
          <target state="translated">仅在运行 &lt;code&gt;Common Test&lt;/code&gt; 时，才能使用 &lt;code&gt;ct:log/1,2,3,4,5&lt;/code&gt; 或 &lt;code&gt;ct:pal/1,2,3,4,5&lt;/code&gt; 登录到文件。但是， &lt;code&gt;ct:pal/1,2,3,4,5&lt;/code&gt; 的打印输出始终显示在屏幕上。</target>
        </trans-unit>
        <trans-unit id="f2e14633e86adb02560262087e31589175004916" translate="yes" xml:space="preserve">
          <source>Logging.</source>
          <target state="translated">Logging.</target>
        </trans-unit>
        <trans-unit id="c5d5c5fb2a8798e4f962780fba63386de96b07b6" translate="yes" xml:space="preserve">
          <source>Logical AND</source>
          <target state="translated">逻辑和</target>
        </trans-unit>
        <trans-unit id="e9b0aefdf7ed2c67abbfc572bbc5743979450674" translate="yes" xml:space="preserve">
          <source>Logical OR</source>
          <target state="translated">逻辑OR</target>
        </trans-unit>
        <trans-unit id="93425a1fb1ee61afdd5c8bde53ad3e437fa5c378" translate="yes" xml:space="preserve">
          <source>Logical XOR</source>
          <target state="translated">逻辑XOR</target>
        </trans-unit>
        <trans-unit id="189c88af11bff23eaa5470818ba782219adfeb6c" translate="yes" xml:space="preserve">
          <source>Logical errors</source>
          <target state="translated">逻辑错误</target>
        </trans-unit>
        <trans-unit id="b639be33714dfa7d1e5de7c8923f3afaa6ea2eb2" translate="yes" xml:space="preserve">
          <source>Logs a warning message. See &lt;code&gt;error_logger:warning_msg/2&lt;/code&gt; for details.</source>
          <target state="translated">记录警告消息。有关详细信息，请参见 &lt;code&gt;error_logger:warning_msg/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c7284beba7b87f4db66029f580195bdcb14e18a" translate="yes" xml:space="preserve">
          <source>Logs an error message. See &lt;code&gt;error_logger:error_msg/2&lt;/code&gt; for details.</source>
          <target state="translated">记录错误消息。有关详细信息，请参见 &lt;code&gt;error_logger:error_msg/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="181bd8b6829579eef29a5e97835c83f4d8736de3" translate="yes" xml:space="preserve">
          <source>Logs an info message. See &lt;code&gt;error_logger:info_msg/2&lt;/code&gt; for details.</source>
          <target state="translated">记录信息消息。有关详细信息，请参见 &lt;code&gt;error_logger:info_msg/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="631539dc5343898549c85b01b6e598967f305bce" translate="yes" xml:space="preserve">
          <source>Logs can be found in &lt;code&gt;/usr/local/erl-target/log&lt;/code&gt;. This directory is specified as an argument to &lt;code&gt;run_erl&lt;/code&gt;in the start script listed above.</source>
          <target state="translated">日志可以在 &lt;code&gt;/usr/local/erl-target/log&lt;/code&gt; 中找到。在上面列出的启动脚本中，此目录被指定为 &lt;code&gt;run_erl&lt;/code&gt; 的参数。</target>
        </trans-unit>
        <trans-unit id="d394eaa2c896b383401e9868f1f1c7fd394042f0" translate="yes" xml:space="preserve">
          <source>Look up all current Logger configuration, including primary and handler configuration, and module level settings.</source>
          <target state="translated">查询所有当前记录仪配置,包括主配置和处理机配置,以及模块级设置。</target>
        </trans-unit>
        <trans-unit id="467add5a91389ace0fffa89049ee83d9c088b039" translate="yes" xml:space="preserve">
          <source>Look up all current module levels. Returns a list containing one &lt;code&gt;{Module,Level}&lt;/code&gt; element for each module for which the module level was previously set with &lt;code&gt;&lt;a href=&quot;#set_module_level-2&quot;&gt;set_module_level/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">查找所有当前模块级别。对于每个先前使用 &lt;code&gt;&lt;a href=&quot;#set_module_level-2&quot;&gt;set_module_level/2&lt;/a&gt;&lt;/code&gt; 设置模块级别的 &lt;code&gt;{Module,Level}&lt;/code&gt; 返回一个包含一个{Module，Level}元素的列表。</target>
        </trans-unit>
        <trans-unit id="ed68e7f8cb77748b3410c3da1ddc86795dc0c780" translate="yes" xml:space="preserve">
          <source>Look up the current configuration for all handlers.</source>
          <target state="translated">查询所有处理机的当前配置。</target>
        </trans-unit>
        <trans-unit id="67650debe1e8550cab53ba9b912a888f4830fbd0" translate="yes" xml:space="preserve">
          <source>Look up the current configuration for the given handler.</source>
          <target state="translated">查询给定处理程序的当前配置。</target>
        </trans-unit>
        <trans-unit id="5b7fd66f8792b2995650ec41a426440bdc8c6525" translate="yes" xml:space="preserve">
          <source>Look up the current level for the given modules. Returns a list containing one &lt;code&gt;{Module,Level}&lt;/code&gt; element for each of the given modules for which the module level was previously set with &lt;code&gt;&lt;a href=&quot;#set_module_level-2&quot;&gt;set_module_level/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">查找给定模块的当前级别。返回一个列表，其中包含每个给定模块的一个 &lt;code&gt;{Module,Level}&lt;/code&gt; 元素，这些模块先前已使用 &lt;code&gt;&lt;a href=&quot;#set_module_level-2&quot;&gt;set_module_level/2&lt;/a&gt;&lt;/code&gt; 设置了模块级别。</target>
        </trans-unit>
        <trans-unit id="28a2ce6edf729b5984078bb368a73e647f062c59" translate="yes" xml:space="preserve">
          <source>Look up the current primary configuration for Logger.</source>
          <target state="translated">查找记录仪的当前主配置。</target>
        </trans-unit>
        <trans-unit id="48789371fd54ac83d13e3db9cfce2e95be6bb545" translate="yes" xml:space="preserve">
          <source>Look up the identities for all installed handlers.</source>
          <target state="translated">查询所有安装的处理程序的身份。</target>
        </trans-unit>
        <trans-unit id="9eafe480d9cb3d8a690b9224bbee0ac5a9549b6e" translate="yes" xml:space="preserve">
          <source>Lookahead assertions start with (?= for positive assertions and (?! for negative assertions. For example, the following matches a word followed by a semicolon, but does not include the semicolon in the match:</source>
          <target state="translated">Lookahead断言以(?=开始表示正断言,以(?!开始表示负断言。例如,下面匹配一个单词,后面有分号,但不包括分号。</target>
        </trans-unit>
        <trans-unit id="c07ff987e22dccf5863c21c8249616b8a6ed83fb" translate="yes" xml:space="preserve">
          <source>Lookbehind assertions start with (?&amp;lt;= for positive assertions and (?&amp;lt;! for negative assertions. For example, the following finds an occurrence of &quot;bar&quot; that is not preceded by &quot;foo&quot;:</source>
          <target state="translated">向后断言以（？&amp;lt;=表示肯定断言，以（？&amp;lt;！表示否定断言。）例如，以下内容找到了出现在&amp;ldquo; bar&amp;rdquo;之前的&amp;ldquo; foo&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="0b4292b6dd1e4f4ea19e5757b522cc47b1f50858" translate="yes" xml:space="preserve">
          <source>Looking at how &lt;code&gt;lists:append/1&lt;/code&gt; or &lt;code&gt;++&lt;/code&gt; would be implemented in plain Erlang, clearly the first list is copied:</source>
          <target state="translated">查看 &lt;code&gt;lists:append/1&lt;/code&gt; 或 &lt;code&gt;++&lt;/code&gt; 如何用纯Erlang实现，很明显第一个列表是复制的：</target>
        </trans-unit>
        <trans-unit id="ae8011d7d2dbc5d36c38aa015da2647371e61405" translate="yes" xml:space="preserve">
          <source>Looking at the &lt;code&gt;tut17&lt;/code&gt; code, you see that the &lt;code&gt;pong&lt;/code&gt; function itself is unchanged, the following lines work in the same way irrespective of on which node the &quot;ping&quot; process is executes:</source>
          <target state="translated">查看 &lt;code&gt;tut17&lt;/code&gt; 代码，您会看到 &lt;code&gt;pong&lt;/code&gt; 函数本身未更改，无论&amp;ldquo; ping&amp;rdquo;进程在哪个节点上执行，以下几行都以相同的方式工作：</target>
        </trans-unit>
        <trans-unit id="dc4ea395786cdf2a9b882e1323bffb04f3d43ded" translate="yes" xml:space="preserve">
          <source>Looking at the function &lt;code&gt;ping/2&lt;/code&gt;, the second clause of &lt;code&gt;ping/2&lt;/code&gt; is executed since the value of the first argument is 3 (not 0) (first clause head is &lt;code&gt;ping(0,Pong_PID)&lt;/code&gt;, second clause head is &lt;code&gt;ping(N,Pong_PID)&lt;/code&gt;, so &lt;code&gt;N&lt;/code&gt; becomes 3).</source>
          <target state="translated">综观函数 &lt;code&gt;ping/2&lt;/code&gt; ，的第二个子句 &lt;code&gt;ping/2&lt;/code&gt; 被执行，因为第一个参数的值是3（不是0）（第一个子句头是 &lt;code&gt;ping(0,Pong_PID)&lt;/code&gt; ，第二子句头是 &lt;code&gt;ping(N,Pong_PID)&lt;/code&gt; ，因此 &lt;code&gt;N&lt;/code&gt; 变为3）。</target>
        </trans-unit>
        <trans-unit id="bb76af27b840c114115effd83744ad34a439d0c6" translate="yes" xml:space="preserve">
          <source>Looking up only &lt;code&gt;{2,2}&lt;/code&gt; would not return &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">仅查找 &lt;code&gt;{2,2}&lt;/code&gt; 不会返回 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79cecfb0f48fcf27b9c36092d68f350e007736e3" translate="yes" xml:space="preserve">
          <source>Looks for a file of the given name by applying suffix rules to the given directory path. For example, a rule &lt;code&gt;{&quot;ebin&quot;, &quot;src&quot;}&lt;/code&gt; means that if the directory path ends with &lt;code&gt;&quot;ebin&quot;&lt;/code&gt;, the corresponding path ending in &lt;code&gt;&quot;src&quot;&lt;/code&gt; should be searched.</source>
          <target state="translated">通过将后缀规则应用于给定目录路径来查找给定名称的文件。例如，规则 &lt;code&gt;{&quot;ebin&quot;, &quot;src&quot;}&lt;/code&gt; 意味着，如果目录路径以 &lt;code&gt;&quot;ebin&quot;&lt;/code&gt; 结尾，则应搜索以 &lt;code&gt;&quot;src&quot;&lt;/code&gt; 结尾的相应路径。</target>
        </trans-unit>
        <trans-unit id="572250e9df056859af227d0dcd9f4fa92b7ecd08" translate="yes" xml:space="preserve">
          <source>Looks up &lt;code&gt;Key&lt;/code&gt; in &lt;code&gt;Tree&lt;/code&gt;. Returns &lt;code&gt;{value, Value}&lt;/code&gt;, or &lt;code&gt;none&lt;/code&gt; if &lt;code&gt;Key&lt;/code&gt; is not present.</source>
          <target state="translated">在&amp;ldquo; &lt;code&gt;Tree&lt;/code&gt; 查找 &lt;code&gt;Key&lt;/code&gt; 。返回 &lt;code&gt;{value, Value}&lt;/code&gt; ，如果 &lt;code&gt;none&lt;/code&gt; &lt;code&gt;Key&lt;/code&gt; ，则不返回。</target>
        </trans-unit>
        <trans-unit id="fb9dfef148e9ec6b8cf8c2740447332c851aec8e" translate="yes" xml:space="preserve">
          <source>Looks up a cache entry. Is to be callable from any process.</source>
          <target state="translated">查找一个缓存条目。可以从任何进程调用。</target>
        </trans-unit>
        <trans-unit id="3a52acb767c4795552ad229633861bc31c72674b" translate="yes" xml:space="preserve">
          <source>Looks up a name in &lt;code&gt;global&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;global&lt;/code&gt; 中查找名称。</target>
        </trans-unit>
        <trans-unit id="78101c6cc3d27d2ba6e58fe21274768cb0746cd8" translate="yes" xml:space="preserve">
          <source>Looks up a port by its registered name.</source>
          <target state="translated">根据注册名称查找一个端口。</target>
        </trans-unit>
        <trans-unit id="30d78191ce5ffb897b0972e9eb8f6d616fa60717" translate="yes" xml:space="preserve">
          <source>Looks up a process by its registered name.</source>
          <target state="translated">按注册名称查找流程。</target>
        </trans-unit>
        <trans-unit id="1d157b4e78c7c3e66517498884591593ccc59f89" translate="yes" xml:space="preserve">
          <source>Looks up the OBJECT IDENTIFIER of a MIB object, given the symbolic name. Note, the OBJECT IDENTIFIER is given for the object, not for an instance.</source>
          <target state="translated">查询一个MIB对象的OBJECT IDENTIFIER,给定符号名。注意,OBJECT IDENTIFIER是针对对象而不是实例给出的。</target>
        </trans-unit>
        <trans-unit id="6c5bf56fd6ef4f1df6829e5e6bfa87397c2baa95" translate="yes" xml:space="preserve">
          <source>Looks up the symbolic name of a MIB object, given OBJECT IDENTIFIER.</source>
          <target state="translated">查阅给定OBJECT IDENTIFIER的MIB对象的符号名称。</target>
        </trans-unit>
        <trans-unit id="08b0f2af44d0672e5833994d490452fc72a7fb05" translate="yes" xml:space="preserve">
          <source>Lookup a dictionary entry and return zero or one value.</source>
          <target state="translated">查找一个字典条目并返回0或1个值。</target>
        </trans-unit>
        <trans-unit id="ae6f5a731780983b4856c7c170673fb5330edbc2" translate="yes" xml:space="preserve">
          <source>Lookup information about an active connection</source>
          <target state="translated">查询活动连接的信息</target>
        </trans-unit>
        <trans-unit id="045c842e1d6e6cd467265d71631ecd62a55e3333" translate="yes" xml:space="preserve">
          <source>Lookup join is handled analogously to lookup of constants in a table: if the join operator is &lt;code&gt;==/2&lt;/code&gt;, and the table where constants are to be looked up uses &lt;code&gt;=:=/2&lt;/code&gt; when testing keys for equality, then the &lt;code&gt;qlc&lt;/code&gt; module does not consider lookup join for that table.</source>
          <target state="translated">查找联接的处理类似于表中常量的查找：如果联接运算符为 &lt;code&gt;==/2&lt;/code&gt; ，并且要测试常数的表在测试键是否相等时使用 &lt;code&gt;=:=/2&lt;/code&gt; ，则 &lt;code&gt;qlc&lt;/code&gt; 模块会执行不考虑该表的查找联接。</target>
        </trans-unit>
        <trans-unit id="35bb462b9b5d0daab8ea39fbe0dc5389a6f8b9fe" translate="yes" xml:space="preserve">
          <source>Lookup method</source>
          <target state="translated">查询方法</target>
        </trans-unit>
        <trans-unit id="067bc036849c0ea9f3a88839506df146bbb74c53" translate="yes" xml:space="preserve">
          <source>Lookup system information</source>
          <target state="translated">查询系统信息</target>
        </trans-unit>
        <trans-unit id="95287f575a0e7411367945df70317705255f8115" translate="yes" xml:space="preserve">
          <source>Lookup the CRLs belonging to the distribution point &lt;code&gt;Distributionpoint&lt;/code&gt;. This function may choose to only look in the cache or to follow distribution point links depending on how the cache is administrated.</source>
          <target state="translated">查找属于分发点 &lt;code&gt;Distributionpoint&lt;/code&gt; 的CRL 。根据对缓存的管理方式，此功能可以选择仅查看缓存还是遵循分发点链接。</target>
        </trans-unit>
        <trans-unit id="a6fa78d0fd70423aadd6b451927544578762dd1d" translate="yes" xml:space="preserve">
          <source>Lookup user information</source>
          <target state="translated">查询用户信息</target>
        </trans-unit>
        <trans-unit id="19942bda356f106b651a5a8f34c9a238875451dc" translate="yes" xml:space="preserve">
          <source>Loops are detected by diameter when the return value of a request callback asks that a request be forwarded. Loop detection in other cases is the responsibility of the user.</source>
          <target state="translated">当请求回调的返回值要求转发请求时,环路会被直径检测出来。其他情况下的环路检测由用户负责。</target>
        </trans-unit>
        <trans-unit id="3dd4c3b37165b69206ec0c19aa805a2a0483a821" translate="yes" xml:space="preserve">
          <source>Low-Level Instructions</source>
          <target state="translated">低级指令</target>
        </trans-unit>
        <trans-unit id="3ac7f763ea9e07bb988a045d46a8d40a6820054e" translate="yes" xml:space="preserve">
          <source>Low-level Erlang loader.</source>
          <target state="translated">低级的Erlang加载器。</target>
        </trans-unit>
        <trans-unit id="5b779e63c115b7d4a7dfed98a4b6ed54c59b2bcc" translate="yes" xml:space="preserve">
          <source>Low-level socket connection (1)</source>
          <target state="translated">低层插座连接 (1)</target>
        </trans-unit>
        <trans-unit id="72c1e1d78aed59b6fe1fe5b89bf5d964d2c9be82" translate="yes" xml:space="preserve">
          <source>Lowercase letter</source>
          <target state="translated">小写字母</target>
        </trans-unit>
        <trans-unit id="26e7bfca24fa187e97eeb696c1c3b5c2e4216480" translate="yes" xml:space="preserve">
          <source>Lowercase letters</source>
          <target state="translated">小写字母</target>
        </trans-unit>
        <trans-unit id="71a644cdf0cedda6a1fe30c2848ffe7f7691a9bf" translate="yes" xml:space="preserve">
          <source>Luckily there is a simplified way to start tracing of &lt;code&gt;et:trace_me/5&lt;/code&gt; function calls. The idea is that you should instrument your code with calls to &lt;code&gt;et:trace_me/5&lt;/code&gt; in strategic places where you have interesting information available in your program. Then you just start the &lt;code&gt;Collector&lt;/code&gt; with global tracing enabled:</source>
          <target state="translated">幸运的是，有一种简化的方法可以开始跟踪 &lt;code&gt;et:trace_me/5&lt;/code&gt; 函数调用。这个想法是，您应该在战略性位置（对您的程序有兴趣的地方）通过调用 &lt;code&gt;et:trace_me/5&lt;/code&gt; 来检测代码。然后，您只需启用全局跟踪即可启动 &lt;code&gt;Collector&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f9156a05ab3755f6c7a6aab965a12bc73fd9cc2c" translate="yes" xml:space="preserve">
          <source>Lycian</source>
          <target state="translated">Lycian</target>
        </trans-unit>
        <trans-unit id="253fa34d4b816ad16ebad60a0945ef037709d0b8" translate="yes" xml:space="preserve">
          <source>Lydian</source>
          <target state="translated">Lydian</target>
        </trans-unit>
        <trans-unit id="dfec75d824ab931885b10c2deb8b602ddf385540" translate="yes" xml:space="preserve">
          <source>M-b</source>
          <target state="translated">M-b</target>
        </trans-unit>
        <trans-unit id="a213eb1de2d97fd8ab6c0c8486e553f7cdc3e521" translate="yes" xml:space="preserve">
          <source>M-d</source>
          <target state="translated">M-d</target>
        </trans-unit>
        <trans-unit id="add69bf7aa5e86e6ac1a17b8047a626986b67564" translate="yes" xml:space="preserve">
          <source>M-f</source>
          <target state="translated">M-f</target>
        </trans-unit>
        <trans-unit id="d6a7c28d96631e7edde69c8cc5ffb71acda67d91" translate="yes" xml:space="preserve">
          <source>MANDATORY</source>
          <target state="translated">MANDATORY</target>
        </trans-unit>
        <trans-unit id="2a10b6977b13d4b417a565ad4f26126926a4a59b" translate="yes" xml:space="preserve">
          <source>MFA ::= &lt;code&gt;{&lt;/code&gt;Module&lt;code&gt;,&lt;/code&gt; Function&lt;code&gt;,&lt;/code&gt; Arity&lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">MFA :: = &lt;code&gt;{&lt;/code&gt; 模块 &lt;code&gt;,&lt;/code&gt; 函数 &lt;code&gt;,&lt;/code&gt; Arity &lt;code&gt;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d945d68cd16cd86023529b0ae4e4b00d3131a1f" translate="yes" xml:space="preserve">
          <source>MIB View Semantics</source>
          <target state="translated">MIB视图语义</target>
        </trans-unit>
        <trans-unit id="04c6a062dba8d860ecd8d08014fad091eaa98372" translate="yes" xml:space="preserve">
          <source>MIB for SNMP. It generates a &lt;code&gt;.bin&lt;/code&gt; file.</source>
          <target state="translated">SNMP的MIB。它生成一个 &lt;code&gt;.bin&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="c4de5d52a9bb8b810300afe15b33e4b1a582332d" translate="yes" xml:space="preserve">
          <source>MIBs for agent configuration are defined.</source>
          <target state="translated">定义了代理配置的MIB。</target>
        </trans-unit>
        <trans-unit id="490ac4f548272126971fbad865a9e5c77d3dd621" translate="yes" xml:space="preserve">
          <source>MacOS X reorganizes the filenames so that the representation of accents, and so on, uses the &quot;combining characters&quot;. For example, character &lt;code&gt;&amp;ouml;&lt;/code&gt; is represented as code points &lt;code&gt;[111,776]&lt;/code&gt;, where &lt;code&gt;111&lt;/code&gt; is character &lt;code&gt;o&lt;/code&gt; and &lt;code&gt;776&lt;/code&gt; is the special accent character &quot;Combining Diaeresis&quot;. This way of normalizing Unicode is otherwise very seldom used. Erlang normalizes those filenames in the opposite way upon retrieval, so that filenames using combining accents are not passed up to the Erlang application. In Erlang, filename &quot;bj&amp;ouml;rn&quot; is retrieved as &lt;code&gt;[98,106,246,114,110]&lt;/code&gt;, not as &lt;code&gt;[98,106,117,776,114,110]&lt;/code&gt;, although the file system can think differently. The normalization into combining accents is redone when accessing files, so this can usually be ignored by the Erlang programmer.</source>
          <target state="translated">MacOS X重新组织了文件名，以便重音符号的表示等使用&amp;ldquo;组合字符&amp;rdquo;。例如，字符 &lt;code&gt;&amp;ouml;&lt;/code&gt; 被表示为代码点 &lt;code&gt;[111,776]&lt;/code&gt; ，其中 &lt;code&gt;111&lt;/code&gt; 是字符 &lt;code&gt;o&lt;/code&gt; ,而 &lt;code&gt;776&lt;/code&gt; 是特殊重音字符&amp;ldquo; Combining Diaeresis&amp;rdquo;。否则，很少使用这种标准化Unicode的方法。 Erlang在检索时会以相反的方式对这些文件名进行规范化，因此使用组合重音符号的文件名不会传递给Erlang应用程序。在Erlang中，文件名&amp;ldquo;bj&amp;ouml;rn&amp;rdquo;检索为 &lt;code&gt;[98,106,246,114,110]&lt;/code&gt; ，而不是 &lt;code&gt;[98,106,117,776,114,110]&lt;/code&gt; ，尽管文件系统可能会有所不同。访问文件时，将重做合并重音的规范化操作，因此Erlang程序员通常可以忽略这一点。</target>
        </trans-unit>
        <trans-unit id="768e486d6aa5224dfa45f14bc7b92f9b71384261" translate="yes" xml:space="preserve">
          <source>Macro definitions have the following format:</source>
          <target state="translated">宏定义的格式如下:</target>
        </trans-unit>
        <trans-unit id="c21df95bcab5149fd0542e1989e579553cef5ea9" translate="yes" xml:space="preserve">
          <source>Macros are expanded during compilation. A simple macro &lt;code&gt;?Const&lt;/code&gt; is replaced with &lt;code&gt;Replacement&lt;/code&gt;.</source>
          <target state="translated">宏在编译期间扩展。一个简单的宏 &lt;code&gt;?Const&lt;/code&gt; 替换为 &lt;code&gt;Replacement&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bafb56f75026725c63578890f318e2634ca3f79f" translate="yes" xml:space="preserve">
          <source>Magically notice traces of the &lt;code&gt;et:trace_me/5&lt;/code&gt; function and make appropriate &lt;code&gt;Events&lt;/code&gt;</source>
          <target state="translated">神奇地注意到 &lt;code&gt;et:trace_me/5&lt;/code&gt; 函数的痕迹，并进行适当的 &lt;code&gt;Events&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="607c4f3f1fc132b892e746284e6f6a2a7788ff50" translate="yes" xml:space="preserve">
          <source>Mahajani</source>
          <target state="translated">Mahajani</target>
        </trans-unit>
        <trans-unit id="ce03a922df1904d63b3c52366acd1e4d5dfa8f72" translate="yes" xml:space="preserve">
          <source>Main API of the Event Trace (ET) application</source>
          <target state="translated">事件追踪(ET)应用程序的主要API。</target>
        </trans-unit>
        <trans-unit id="c9a8168cc646feb22f71f8973ad3e9998dbfe20e" translate="yes" xml:space="preserve">
          <source>Main API of the Megaco application</source>
          <target state="translated">Megaco应用程序的主要API</target>
        </trans-unit>
        <trans-unit id="7290931f77376ec9118ea4cf32caad5589c36ebf" translate="yes" xml:space="preserve">
          <source>Main API of the Reltool application</source>
          <target state="translated">Reltool应用程序的主要API</target>
        </trans-unit>
        <trans-unit id="014771aa765bee2f30af23c70717253cfb96da9f" translate="yes" xml:space="preserve">
          <source>Main API of the diameter application.</source>
          <target state="translated">直径应用的主要API。</target>
        </trans-unit>
        <trans-unit id="4fcfcea0b000eea06fc6d4ed4be0088adbe04013" translate="yes" xml:space="preserve">
          <source>Main API of the ssh application</source>
          <target state="translated">ssh应用程序的主要API</target>
        </trans-unit>
        <trans-unit id="4140ba76dde001a1b5b6d82503aaee2fca05b0aa" translate="yes" xml:space="preserve">
          <source>Main multiblock carrier size. Sets the size of the main multiblock carrier for allocator &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt;. The main multiblock carrier is allocated through &lt;code&gt;sys_alloc&lt;/code&gt; and is never deallocated.</source>
          <target state="translated">主多块载波大小。设置分配器 &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; 的主多块载波的大小。主多块载波通过 &lt;code&gt;sys_alloc&lt;/code&gt; 分配，并且永不释放。</target>
        </trans-unit>
        <trans-unit id="98d070980c8de15123661b75681a9415be24bed3" translate="yes" xml:space="preserve">
          <source>Main user interface for the &lt;code&gt;Common Test&lt;/code&gt; framework.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 框架的主要用户界面。</target>
        </trans-unit>
        <trans-unit id="34c6a81f8a68bddb86631e45d9f0b3b6bd8f93e5" translate="yes" xml:space="preserve">
          <source>Main user interface for the Common Test framework.</source>
          <target state="translated">通用测试框架的主要用户界面。</target>
        </trans-unit>
        <trans-unit id="caf95b7396f0360a962cd9ce06b569c833ad967e" translate="yes" xml:space="preserve">
          <source>Maintenance of the fully connected network</source>
          <target state="translated">维护完全连接的网络</target>
        </trans-unit>
        <trans-unit id="683ba771dba7958f68fbac6a0cabbea4e324174e" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;Deferred&lt;/code&gt; suites become the least preferred suites, that is put them at the end of the cipher suite list &lt;code&gt;Suites&lt;/code&gt; after removing them from &lt;code&gt;Suites&lt;/code&gt; if present. &lt;code&gt;Deferred&lt;/code&gt; may be a list of cipher suits or a list of filters in which case the filters are use on &lt;code&gt;Suites&lt;/code&gt; to extract the Deferred cipher list.</source>
          <target state="translated">使 &lt;code&gt;Deferred&lt;/code&gt; 套房成为最不看好的套房，就是把他们的密码套件列表的末尾 &lt;code&gt;Suites&lt;/code&gt; 从取出之后， &lt;code&gt;Suites&lt;/code&gt; （如果存在）。 &lt;code&gt;Deferred&lt;/code&gt; 可以是密码 &lt;code&gt;Suites&lt;/code&gt; 的列表，也可以是过滤器的列表，在这种情况下，过滤器将在Suite上使用以提取Deferred密码列表。</target>
        </trans-unit>
        <trans-unit id="d09c0a2ffb9d90565c340512a769d32848189c99" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;Preferred&lt;/code&gt; suites become the most preferred suites that is put them at the head of the cipher suite list &lt;code&gt;Suites&lt;/code&gt; after removing them from &lt;code&gt;Suites&lt;/code&gt; if present. &lt;code&gt;Preferred&lt;/code&gt; may be a list of cipher suits or a list of filters in which case the filters are use on &lt;code&gt;Suites&lt;/code&gt; to extract the preferred cipher list.</source>
          <target state="translated">请 &lt;code&gt;Preferred&lt;/code&gt; 套房成为是把他们在密码套件列表的头部最优选套房 &lt;code&gt;Suites&lt;/code&gt; 从取出之后， &lt;code&gt;Suites&lt;/code&gt; （如果存在）。 &lt;code&gt;Preferred&lt;/code&gt; 可能是密码 &lt;code&gt;Suites&lt;/code&gt; 列表或过滤器列表，在这种情况下，过滤器将在套件上使用以提取首选的密码列表。</target>
        </trans-unit>
        <trans-unit id="b9ea499659acd96747d610ef617848faf8002c00" translate="yes" xml:space="preserve">
          <source>Make Dialyzer a bit more quiet.</source>
          <target state="translated">让Dialyzer更安静一些。</target>
        </trans-unit>
        <trans-unit id="ee2cafda4f9116a303a421f649a4f70f2f925a8d" translate="yes" xml:space="preserve">
          <source>Make Dialyzer a bit more verbose.</source>
          <target state="translated">让Dialyzer更啰嗦一些。</target>
        </trans-unit>
        <trans-unit id="10ba2efeabebf0489b4847ad8643fcdf0992e15a" translate="yes" xml:space="preserve">
          <source>Make Dialyzer emit warnings even when manipulating the PLT. Warnings are only emitted for files that are analyzed.</source>
          <target state="translated">使Dialyzer在操作PLT时也能发出警告。仅对被分析的文件发出警告。</target>
        </trans-unit>
        <trans-unit id="7715175917b7a7d605296680b1ca41edb30157cf" translate="yes" xml:space="preserve">
          <source>Make Dialyzer print information about the PLT and then quit. The PLT can be specified with &lt;code&gt;--plt(s)&lt;/code&gt;.</source>
          <target state="translated">使Dialyzer打印有关PLT的信息，然后退出。可以使用 &lt;code&gt;--plt(s)&lt;/code&gt; 指定PLT 。</target>
        </trans-unit>
        <trans-unit id="8f5adb962b2fbef3d7acd737ca5f836fe51e4afa" translate="yes" xml:space="preserve">
          <source>Make a copy of the Solaris standard configuration file for &lt;code&gt;syslogd&lt;/code&gt;. This file is usually named &lt;code&gt;syslog.conf&lt;/code&gt; and found in directory &lt;code&gt;/etc&lt;/code&gt;.</source>
          <target state="translated">为 &lt;code&gt;syslogd&lt;/code&gt; 复制Solaris标准配置文件。该文件通常名为 &lt;code&gt;syslog.conf&lt;/code&gt; ，位于目录 &lt;code&gt;/etc&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="0e586a8c6ff263d0afce189a56818cee918e1347" translate="yes" xml:space="preserve">
          <source>Make a key out of an event record or an old key.</source>
          <target state="translated">用事件记录或旧钥匙制作钥匙。</target>
        </trans-unit>
        <trans-unit id="1415885484de34303a471ea6db61c1acc9cb54f8" translate="yes" xml:space="preserve">
          <source>Make a simple hello world and try to compile it with the &lt;code&gt;cl&lt;/code&gt; command from within bash. If that does not work, your environment needs fixing. Remember, there should be no backslashes in your path environment variable in Cygwin bash, but LIB and INCLUDE should contain Windows style paths with semicolon, drive letters and backslashes.</source>
          <target state="translated">创建一个简单的hello世界，并尝试从bash中使用 &lt;code&gt;cl&lt;/code&gt; 命令对其进行编译。如果这样不起作用，则需要修复您的环境。请记住，在Cygwin bash中，路径环境变量中不应包含反斜杠，但LIB和INCLUDE应包含Windows样式的路径，并带有分号，驱动器号和反斜杠。</target>
        </trans-unit>
        <trans-unit id="1dcb4e238263c7a5afbedf884d34e60decef3679" translate="yes" xml:space="preserve">
          <source>Make an edited copy of the backup copy previously made.</source>
          <target state="translated">对之前制作的备份副本进行编辑。</target>
        </trans-unit>
        <trans-unit id="bfc8145db5663246acf8191e3d36605eb676990d" translate="yes" xml:space="preserve">
          <source>Make process &lt;code&gt;Pid&lt;/code&gt; the new owner of table &lt;code&gt;Tab&lt;/code&gt;. If successful, message &lt;code&gt;{'ETS-TRANSFER',Tab,FromPid,GiftData}&lt;/code&gt; is sent to the new owner.</source>
          <target state="translated">制作过程 &lt;code&gt;Pid&lt;/code&gt; 表的新所有者 &lt;code&gt;Tab&lt;/code&gt; 。如果成功，则将消息 &lt;code&gt;{'ETS-TRANSFER',Tab,FromPid,GiftData}&lt;/code&gt; 发送给新所有者。</target>
        </trans-unit>
        <trans-unit id="7b44f78041d63c29886fd3ab915b1c7a217bbe5f" translate="yes" xml:space="preserve">
          <source>Make some particular suites the most preferred, or least preferred by changing prepend to append.</source>
          <target state="translated">通过将前缀改为后缀,使一些特定的套路成为最喜欢的,或最不喜欢的。</target>
        </trans-unit>
        <trans-unit id="c2ba192403adbb128258a263d55b31ddd0872ee8" translate="yes" xml:space="preserve">
          <source>Make sure that the command &lt;code&gt;hostname&lt;/code&gt; returns a valid fully qualified host name (this is configured in &lt;code&gt;/etc/hostconfig&lt;/code&gt;). Otherwise you might experience problems when running distributed systems.</source>
          <target state="translated">确保命令 &lt;code&gt;hostname&lt;/code&gt; 返回有效的标准主机名（在 &lt;code&gt;/etc/hostconfig&lt;/code&gt; 中配置）。否则，在运行分布式系统时，您可能会遇到问题。</target>
        </trans-unit>
        <trans-unit id="605b087786603fea0d76e7acb85a392c7a2ca554" translate="yes" xml:space="preserve">
          <source>Make sure to install the basic dev tools, but avoid the MinGW autoconf and install the msys one instead.</source>
          <target state="translated">一定要安装基本的开发工具,但要避开MinGW的autoconf,而安装msys的。</target>
        </trans-unit>
        <trans-unit id="f71b08b9686f12317202560047739ba3b1216b0e" translate="yes" xml:space="preserve">
          <source>Make sure to set the PATH so that NSIS and Microsoft SDK is found before the MSYS/Cygwin tools and that Java is last in the PATH.</source>
          <target state="translated">确保设置PATH,使NSIS和微软SDK在MSYS/Cygwin工具之前被找到,并且Java在PATH的最后。</target>
        </trans-unit>
        <trans-unit id="bf36bcf4ace9356a062d8090033e2ca09b36f682" translate="yes" xml:space="preserve">
          <source>Make sure you're in the top directory in the source tree.</source>
          <target state="translated">确保你在源代码树的顶部目录中。</target>
        </trans-unit>
        <trans-unit id="c7432411584b2a6828a2cfe381ef427f482a9a7d" translate="yes" xml:space="preserve">
          <source>Make that series of NIF calls from the Erlang level.</source>
          <target state="translated">从Erlang层面进行那一系列的NIF调用。</target>
        </trans-unit>
        <trans-unit id="1f5db744ecb6a5d733780b21850a0e20203a81db" translate="yes" xml:space="preserve">
          <source>Make the client tell the server that the client accepts extension negotiation, that is, include &lt;code&gt;ext-info-c&lt;/code&gt; in the kexinit message sent. See &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8308&quot;&gt;RFC 8308&lt;/a&gt;&lt;/code&gt; for details and &lt;code&gt;ssh(6)&lt;/code&gt; for a list of currently implemented extensions.</source>
          <target state="translated">让客户端告知服务器客户端接受扩展协商，即在发送的kexinit消息中包含 &lt;code&gt;ext-info-c&lt;/code&gt; 。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8308&quot;&gt;RFC 8308&lt;/a&gt;&lt;/code&gt; ；有关当前实现的扩展的列表，请参见 &lt;code&gt;ssh(6)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5035cf3f169978e011505d0d2efbb3700dc36cf" translate="yes" xml:space="preserve">
          <source>Make the server (daemon) tell the client that the server accepts extension negotiation, that is, include &lt;code&gt;ext-info-s&lt;/code&gt; in the kexinit message sent. See &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8308&quot;&gt;RFC 8308&lt;/a&gt;&lt;/code&gt; for details and &lt;code&gt;ssh(6)&lt;/code&gt; for a list of currently implemented extensions.</source>
          <target state="translated">使服务器（守护程序）告诉客户端服务器接受扩展协商，即在发送的kexinit消息中包含 &lt;code&gt;ext-info-s&lt;/code&gt; 。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8308&quot;&gt;RFC 8308&lt;/a&gt;&lt;/code&gt; ；有关当前实现的扩展的列表，请参见 &lt;code&gt;ssh(6)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93aa92102b400ac9f00b97c87885b225d1e6c53c" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;init&lt;/code&gt; call the specified function. &lt;code&gt;Func&lt;/code&gt; defaults to &lt;code&gt;start&lt;/code&gt;. If no arguments are provided, the function is assumed to be of arity 0. Otherwise it is assumed to be of arity 1, taking the list &lt;code&gt;[Arg1,Arg2,...]&lt;/code&gt; as argument. All arguments are passed as atoms. See &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使 &lt;code&gt;init&lt;/code&gt; 调用指定的函数。 &lt;code&gt;Func&lt;/code&gt; 默认为 &lt;code&gt;start&lt;/code&gt; 。如果未提供任何参数，则假定该函数的值为0。否则，以列表 &lt;code&gt;[Arg1,Arg2,...]&lt;/code&gt; 作为参数，将该函数的值为1 。所有参数都作为原子传递。参见 &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc491ef04c29a912ad13bb0dab3aa78550c1a0b0" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;init&lt;/code&gt; call the specified function. &lt;code&gt;Func&lt;/code&gt; defaults to &lt;code&gt;start&lt;/code&gt;. If no arguments are provided, the function is assumed to be of arity 0. Otherwise it is assumed to be of arity 1, taking the list &lt;code&gt;[Arg1,Arg2,...]&lt;/code&gt; as argument. All arguments are passed as strings. See &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使 &lt;code&gt;init&lt;/code&gt; 调用指定的函数。 &lt;code&gt;Func&lt;/code&gt; 默认为 &lt;code&gt;start&lt;/code&gt; 。如果未提供任何参数，则假定该函数的值为0。否则，以列表 &lt;code&gt;[Arg1,Arg2,...]&lt;/code&gt; 作为参数，将该函数的值为1 。所有参数都作为字符串传递。参见 &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="effbaf150909b5681b041c7c93ee8c1dd9234e3b" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;init&lt;/code&gt; evaluate the expression &lt;code&gt;Expr&lt;/code&gt;; see &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使 &lt;code&gt;init&lt;/code&gt; 评估表达式 &lt;code&gt;Expr&lt;/code&gt; ; 参见 &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f6e437de83ae71822d270a49d45206d77f45c59" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;init&lt;/code&gt; write some debug information while interpreting the boot script.</source>
          <target state="translated">使 &lt;code&gt;init&lt;/code&gt; 在解释启动脚本时写一些调试信息。</target>
        </trans-unit>
        <trans-unit id="1c12aa164fb9326a07158879ddf33e08ec2da65e" translate="yes" xml:space="preserve">
          <source>Makes a &lt;code&gt;badarg&lt;/code&gt; exception to be returned from a NIF, and associates it with environment &lt;code&gt;env&lt;/code&gt;. Once a NIF or any function it calls invokes &lt;code&gt;enif_make_badarg&lt;/code&gt;, the runtime ensures that a &lt;code&gt;badarg&lt;/code&gt; exception is raised when the NIF returns, even if the NIF attempts to return a non-exception term instead.</source>
          <target state="translated">使 &lt;code&gt;badarg&lt;/code&gt; 异常从NIF返回，并将其与环境 &lt;code&gt;env&lt;/code&gt; 关联。一旦NIF或它调用的任何函数调用 &lt;code&gt;enif_make_badarg&lt;/code&gt; ，运行时就会确保在NIF返回时引发 &lt;code&gt;badarg&lt;/code&gt; 异常，即使NIF尝试返回非异常项也是如此。</target>
        </trans-unit>
        <trans-unit id="237c55ef12224693f0ea9298c5b4012406e52202" translate="yes" xml:space="preserve">
          <source>Makes a binary term from &lt;code&gt;bin&lt;/code&gt;. Any ownership of the binary data is transferred to the created term and &lt;code&gt;bin&lt;/code&gt; is to be considered read-only for the rest of the NIF call and then as released.</source>
          <target state="translated">从 &lt;code&gt;bin&lt;/code&gt; 中生成一个二进制项。二进制数据的所有所有权都将转移到创建的术语， &lt;code&gt;bin&lt;/code&gt; 对于其余的NIF调用将被视为只读，然后释放。</target>
        </trans-unit>
        <trans-unit id="b692874a74db2c05c40ad42ce60cf8791216d646" translate="yes" xml:space="preserve">
          <source>Makes a copy of map &lt;code&gt;map_in&lt;/code&gt; and inserts &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; already exists in &lt;code&gt;map_in&lt;/code&gt;, the old associated value is replaced by &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">制作地图 &lt;code&gt;map_in&lt;/code&gt; 的副本，并插入带有 &lt;code&gt;value&lt;/code&gt; 的 &lt;code&gt;key&lt;/code&gt; 。如果 &lt;code&gt;map_in&lt;/code&gt; 中已经存在 &lt;code&gt;key&lt;/code&gt; ，则旧的关联值将替换为 &lt;code&gt;value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bdd484fa8278609492e238310d156b1e791c1d1" translate="yes" xml:space="preserve">
          <source>Makes a copy of map &lt;code&gt;map_in&lt;/code&gt; and replace the old associated value for &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;new_value&lt;/code&gt;.</source>
          <target state="translated">使得地图的副本 &lt;code&gt;map_in&lt;/code&gt; 和替换旧的关联值 &lt;code&gt;key&lt;/code&gt; 与 &lt;code&gt;new_value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca6b1dc8e5e0672574d5436088c1dcb75a32cecf" translate="yes" xml:space="preserve">
          <source>Makes a copy of term &lt;code&gt;src_term&lt;/code&gt;. The copy is created in environment &lt;code&gt;dst_env&lt;/code&gt;. The source term can be located in any environment.</source>
          <target state="translated">复制术语 &lt;code&gt;src_term&lt;/code&gt; 。该副本在环境 &lt;code&gt;dst_env&lt;/code&gt; 中创建。源术语可以位于任何环境中。</target>
        </trans-unit>
        <trans-unit id="4f47a6753bc06d4318555d47c144bd14353686e3" translate="yes" xml:space="preserve">
          <source>Makes a hard link from &lt;code&gt;Existing&lt;/code&gt; to &lt;code&gt;New&lt;/code&gt; on platforms supporting links (Unix and Windows). This function returns &lt;code&gt;ok&lt;/code&gt; if the link was successfully created, otherwise &lt;code&gt;{error, Reason}&lt;/code&gt;. On platforms not supporting links, &lt;code&gt;{error,enotsup}&lt;/code&gt; is returned.</source>
          <target state="translated">在支持链接的平台（Unix和Windows）上建立从 &lt;code&gt;Existing&lt;/code&gt; 到 &lt;code&gt;New&lt;/code&gt; 的硬链接。如果成功创建了链接，则此函数返回 &lt;code&gt;ok&lt;/code&gt; ，否则返回 &lt;code&gt;{error, Reason}&lt;/code&gt; 。在不支持链接的平台上 &lt;code&gt;{error,enotsup}&lt;/code&gt; 将返回{error，enotsup}。</target>
        </trans-unit>
        <trans-unit id="31595caf2c636a46957c7deabbd5e7359493a864" translate="yes" xml:space="preserve">
          <source>Makes a map term from the given keys and values.</source>
          <target state="translated">根据给定的键和值制作一个映射项。</target>
        </trans-unit>
        <trans-unit id="5faa6d950f146c4cea5b655391ad27bfb6046562" translate="yes" xml:space="preserve">
          <source>Makes a node into a hidden node.</source>
          <target state="translated">使一个节点变成一个隐藏节点。</target>
        </trans-unit>
        <trans-unit id="bff410db84d22381d23b1c5efa073c2289972394" translate="yes" xml:space="preserve">
          <source>Makes a pid term from &lt;code&gt;*pid&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;*pid&lt;/code&gt; 定义一个pid项。</target>
        </trans-unit>
        <trans-unit id="7dd7181219d969635c334047d9c09a9edcb4c4b1" translate="yes" xml:space="preserve">
          <source>Makes a printout of all interpreted modules. Modules are printed together with the full path name of the corresponding source code file.</source>
          <target state="translated">打印所有解释过的模块。模块与相应的源代码文件的完整路径名一起打印。</target>
        </trans-unit>
        <trans-unit id="401f2043961677427104b10d6d8254a7b9499556" translate="yes" xml:space="preserve">
          <source>Makes a runtime system into a node, using long node names.</source>
          <target state="translated">使运行时系统成为一个节点,使用长节点名称。</target>
        </trans-unit>
        <trans-unit id="bcf8732784b73fa9047c7ff22861f746856adbaa" translate="yes" xml:space="preserve">
          <source>Makes a runtime system into a node, using short node names.</source>
          <target state="translated">将一个运行时系统变成一个节点,使用简短的节点名称。</target>
        </trans-unit>
        <trans-unit id="dd9eb421a3c6821005298718ecb81d1924332eb6" translate="yes" xml:space="preserve">
          <source>Makes a subbinary of binary &lt;code&gt;bin_term&lt;/code&gt;, starting at zero-based position &lt;code&gt;pos&lt;/code&gt; with a length of &lt;code&gt;size&lt;/code&gt; bytes. &lt;code&gt;bin_term&lt;/code&gt; must be a binary or bitstring. &lt;code&gt;pos+size&lt;/code&gt; must be less or equal to the number of whole bytes in &lt;code&gt;bin_term&lt;/code&gt;.</source>
          <target state="translated">使二进制的子二进制 &lt;code&gt;bin_term&lt;/code&gt; ，开始于基于零的位置 &lt;code&gt;pos&lt;/code&gt; 用的长度 &lt;code&gt;size&lt;/code&gt; 的字节。 &lt;code&gt;bin_term&lt;/code&gt; 必须为二进制或位串。 &lt;code&gt;pos+size&lt;/code&gt; 必须小于或等于 &lt;code&gt;bin_term&lt;/code&gt; 中的整个字节数。</target>
        </trans-unit>
        <trans-unit id="1da6e2cfd5a96004af2990791a93360f29c745d3" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to all &lt;code&gt;gen_server&lt;/code&gt; processes locally registered as &lt;code&gt;Name&lt;/code&gt; at the specified nodes by first sending a request to every node and then waits for the replies. The &lt;code&gt;gen_server&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; to handle the request.</source>
          <target state="translated">通过首先向每个节点发送请求，然后等待答复，来对指定节点上本地注册为 &lt;code&gt;Name&lt;/code&gt; 的所有 &lt;code&gt;gen_server&lt;/code&gt; 进程进行同步调用。的 &lt;code&gt;gen_server&lt;/code&gt; 进程调用 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 来处理该请求。</target>
        </trans-unit>
        <trans-unit id="ea1c1ab573f83f8ab3377d2d58aa5424f46f4767" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to event handler &lt;code&gt;Handler&lt;/code&gt; installed in event manager &lt;code&gt;EventMgrRef&lt;/code&gt; by sending a request and waiting until a reply arrives or a time-out occurs. The event manager calls &lt;code&gt;&lt;a href=&quot;#Module:handle_call-2&quot;&gt;Module:handle_call/2&lt;/a&gt;&lt;/code&gt; to handle the request.</source>
          <target state="translated">通过发送请求并等待答复到达或发生超时，来对安装在事件管理器 &lt;code&gt;EventMgrRef&lt;/code&gt; 中的事件处理程序 &lt;code&gt;Handler&lt;/code&gt; 进行同步调用。事件管理器调用 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-2&quot;&gt;Module:handle_call/2&lt;/a&gt;&lt;/code&gt; 来处理请求。</target>
        </trans-unit>
        <trans-unit id="f82c270c0090923069cb76b8c5ac5d301204fbd0" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to the &lt;code&gt;ServerRef&lt;/code&gt; of the &lt;code&gt;gen_server&lt;/code&gt; process by sending a request and waiting until a reply arrives or a time-out occurs. The &lt;code&gt;gen_server&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; to handle the request.</source>
          <target state="translated">通过发送请求并等待直到答复到达或发生超时来对 &lt;code&gt;gen_server&lt;/code&gt; 进程的 &lt;code&gt;ServerRef&lt;/code&gt; 进行同步调用。的 &lt;code&gt;gen_server&lt;/code&gt; 进程调用 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 来处理该请求。</target>
        </trans-unit>
        <trans-unit id="e047abadcd4125bf1a47c5e3a18f5763c2f66409" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to the &lt;code&gt;gen_statem&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;ServerRef&lt;/a&gt;&lt;/code&gt; by sending a request and waiting until its reply arrives. The &lt;code&gt;gen_statem&lt;/code&gt; calls the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;{call,From}&lt;/code&gt; and event content &lt;code&gt;Request&lt;/code&gt;.</source>
          <target state="translated">通过发送请求并等待其回复到达，来同步调用 &lt;code&gt;gen_statem&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;ServerRef&lt;/a&gt;&lt;/code&gt; 。该 &lt;code&gt;gen_statem&lt;/code&gt; 调用 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 有 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;{call,From}&lt;/code&gt; 和事件内容的 &lt;code&gt;Request&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5e97befb3fc0e650a9c087f592d9705da519e48" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to the channel process by sending a message and waiting until a reply arrives, or a time-out occurs. The channel calls &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; to handle the message. If the channel process does not exist, &lt;code&gt;{error, closed}&lt;/code&gt; is returned.</source>
          <target state="translated">通过发送消息并等待直到答复到达或发生超时，来对通道进程进行同步调用。通道调用 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 处理消息。如果通道进程不存在，则返回 &lt;code&gt;{error, closed}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb060cc8d8a3df5d96be3f4fcf2d8f7d2bded14f" translate="yes" xml:space="preserve">
          <source>Makes a trace pattern suitable to feed change_pattern/1</source>
          <target state="translated">制作一个适合馈送change_pattern/1的跟踪模式。</target>
        </trans-unit>
        <trans-unit id="ea447adb75c049935be0ade2d24d0e02a46cb4ff" translate="yes" xml:space="preserve">
          <source>Makes all the preprocessor macros of EUnit available, to help writing tests</source>
          <target state="translated">使EUnit的所有预处理器宏可用,以帮助编写测试。</target>
        </trans-unit>
        <trans-unit id="97e3039873bad96bb14bae33094fcd93e52bc160" translate="yes" xml:space="preserve">
          <source>Makes all warnings into errors.</source>
          <target state="translated">使所有的警告都变成错误。</target>
        </trans-unit>
        <trans-unit id="247956d646f73c5083d686557419faaf07611729" translate="yes" xml:space="preserve">
          <source>Makes an empty map term.</source>
          <target state="translated">使一个空的地图术语。</target>
        </trans-unit>
        <trans-unit id="48107dc847232e089a1763920ba9c6eb752826f4" translate="yes" xml:space="preserve">
          <source>Makes an existing process an &lt;code&gt;ssh_client_channel&lt;/code&gt; (replaces ssh_channel) process. Does not return, instead the calling process enters the &lt;code&gt;ssh_client_channel&lt;/code&gt; (replaces ssh_channel) process receive loop and become an &lt;code&gt;ssh_client_channel&lt;/code&gt; process. The process must have been started using one of the start functions in &lt;code&gt;proc_lib&lt;/code&gt;, see the &lt;code&gt;proc_lib(3)&lt;/code&gt; manual page in STDLIB. The user is responsible for any initialization of the process and must call &lt;code&gt;&lt;a href=&quot;#init-1&quot;&gt;init/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将现有进程 &lt;code&gt;ssh_client_channel&lt;/code&gt; （代替ssh_channel）进程。不返回，而是调用进程进入 &lt;code&gt;ssh_client_channel&lt;/code&gt; （代替ssh_channel）进程的接收循环，并成为 &lt;code&gt;ssh_client_channel&lt;/code&gt; 进程。必须使用 &lt;code&gt;proc_lib&lt;/code&gt; 中的启动功能之一来启动该过程，请参见STDLIB中的 &lt;code&gt;proc_lib(3)&lt;/code&gt; 手册页。用户负责进程的任何初始化，并且必须调用 &lt;code&gt;&lt;a href=&quot;#init-1&quot;&gt;init/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22bc96ed22188f42e5c515e5da6efb8258670300" translate="yes" xml:space="preserve">
          <source>Makes an existing process into a &lt;code&gt;gen_server&lt;/code&gt; process. Does not return, instead the calling process enters the &lt;code&gt;gen_server&lt;/code&gt; process receive loop and becomes a &lt;code&gt;gen_server&lt;/code&gt; process. The process &lt;strong&gt;must&lt;/strong&gt; have been started using one of the start functions in &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib(3)&lt;/a&gt;&lt;/code&gt;. The user is responsible for any initialization of the process, including registering a name for it.</source>
          <target state="translated">使现有进程成为 &lt;code&gt;gen_server&lt;/code&gt; 进程。不返回，而是调用进程进入 &lt;code&gt;gen_server&lt;/code&gt; 进程的接收循环并成为 &lt;code&gt;gen_server&lt;/code&gt; 进程。&lt;strong&gt;必须&lt;/strong&gt;使用 &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib(3)&lt;/a&gt;&lt;/code&gt; 中的启动功能之一来启动该过程。用户负责该过程的任何初始化，包括为其注册一个名称。</target>
        </trans-unit>
        <trans-unit id="ca23188a55ed798e178a8cdc711ee096dc651317" translate="yes" xml:space="preserve">
          <source>Makes another copy of a table at the node &lt;code&gt;Node&lt;/code&gt;. Argument &lt;code&gt;Type&lt;/code&gt; must be either of the atoms &lt;code&gt;ram_copies&lt;/code&gt;, &lt;code&gt;disc_copies&lt;/code&gt;, or &lt;code&gt;disc_only_copies&lt;/code&gt;. For example, the following call ensures that a disc replica of the &lt;code&gt;person&lt;/code&gt; table also exists at node &lt;code&gt;Node&lt;/code&gt;:</source>
          <target state="translated">在节点 &lt;code&gt;Node&lt;/code&gt; 上制作表的另一个副本。参数 &lt;code&gt;Type&lt;/code&gt; 必须是 &lt;code&gt;ram_copies&lt;/code&gt; ， &lt;code&gt;disc_copies&lt;/code&gt; 或 &lt;code&gt;disc_only_copies&lt;/code&gt; 原子。例如，以下调用确保在节点 &lt;code&gt;Node&lt;/code&gt; 上也存在 &lt;code&gt;person&lt;/code&gt; 表的光盘副本：</target>
        </trans-unit>
        <trans-unit id="aa974f84878c85c9522eb437dfa9236890e3b59a" translate="yes" xml:space="preserve">
          <source>Makes any process created by a traced process inherit its trace flags, including flag &lt;code&gt;set_on_spawn&lt;/code&gt;.</source>
          <target state="translated">使由跟踪进程创建的任何进程继承其跟踪标志，包括标志 &lt;code&gt;set_on_spawn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6fe67417b1a2349e7be32124ba5fe55fba98791" translate="yes" xml:space="preserve">
          <source>Makes any process linked by a traced process inherit its trace flags, including flag &lt;code&gt;set_on_link&lt;/code&gt;.</source>
          <target state="translated">使由跟踪的进程链接的任何进程继承其跟踪标志，包括标志 &lt;code&gt;set_on_link&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81962eacd7a836ddf3c4da74a5b02410645fe00a" translate="yes" xml:space="preserve">
          <source>Makes copies of the source file for the given modules, where it for each executable line is specified how many times it has been executed.</source>
          <target state="translated">为给定的模块制作源文件的副本,其中指定每行可执行文件的执行次数。</target>
        </trans-unit>
        <trans-unit id="91fe360029900348adebe5c87f81ee0c4d1d7bfa" translate="yes" xml:space="preserve">
          <source>Makes it possible to handle removal of releases outside the release handler. Tells the release handler that the release is removed from the system. This function does not delete any files.</source>
          <target state="translated">使其能够在释放处理程序之外处理释放的移除。告诉发布处理程序该发布已从系统中移除。此功能不删除任何文件。</target>
        </trans-unit>
        <trans-unit id="d8d3cd6f1fa13ad3388a331a2a27038c3db886f4" translate="yes" xml:space="preserve">
          <source>Makes it possible to handle unpacking of releases outside the release handler. Tells the release handler that the release is unpacked. &lt;code&gt;Vsn&lt;/code&gt; is extracted from the release resource file &lt;code&gt;RelFile&lt;/code&gt;.</source>
          <target state="translated">使在发布处理程序外部处理发布的拆包成为可能。告知发布处理程序发布的版本已解压缩。从发布资源文件 &lt;code&gt;RelFile&lt;/code&gt; 中提取 &lt;code&gt;Vsn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="550cc3842fa85cd7551150ef1a3ffbb8ecf08f4e" translate="yes" xml:space="preserve">
          <source>Makes it possible to read or write gzip compressed files. Option &lt;code&gt;compressed&lt;/code&gt; must be combined with &lt;code&gt;read&lt;/code&gt; or &lt;code&gt;write&lt;/code&gt;, but not both. Notice that the file size obtained with &lt;code&gt;&lt;a href=&quot;#read_file_info-1&quot;&gt;read_file_info/1&lt;/a&gt;&lt;/code&gt; does probably not match the number of bytes that can be read from a compressed file.</source>
          <target state="translated">使读取或写入gzip压缩文件成为可能。 &lt;code&gt;compressed&lt;/code&gt; 选项必须与 &lt;code&gt;read&lt;/code&gt; 或 &lt;code&gt;write&lt;/code&gt; 结合使用，但不能两者都结合使用。请注意，使用 &lt;code&gt;&lt;a href=&quot;#read_file_info-1&quot;&gt;read_file_info/1&lt;/a&gt;&lt;/code&gt; 获得的文件大小可能与可从压缩文件读取的字节数不匹配。</target>
        </trans-unit>
        <trans-unit id="47c408fbb745313fb815eff80dafd2c1c61a239e" translate="yes" xml:space="preserve">
          <source>Makes necessary initializations and returns the initial channel state if the initializations succeed.</source>
          <target state="translated">进行必要的初始化,如果初始化成功则返回初始通道状态。</target>
        </trans-unit>
        <trans-unit id="fa89cf81f10044b652f143f54fcc25e4b34fd715" translate="yes" xml:space="preserve">
          <source>Makes the &lt;code&gt;efile&lt;/code&gt; loader write some debug information, such as the reason for failures, while it handles files.</source>
          <target state="translated">使 &lt;code&gt;efile&lt;/code&gt; 装入程序在处理文件时写入一些调试信息，例如失败原因。</target>
        </trans-unit>
        <trans-unit id="d304b67681b86e2abd50ebc5b49fc156fedec9bb" translate="yes" xml:space="preserve">
          <source>Makes the Erlang emulator be restarted (with whatever parameters are registered for the service at the occasion) when it stops. If the emulator stops again within 10 seconds, it is not restarted to avoid an infinite loop, which could hang the Windows system.</source>
          <target state="translated">使得Erlang模拟器在停止时重新启动(使用当时为服务注册的任何参数),如果模拟器在10秒内再次停止,则不会重新启动,以避免无限循环,这可能会挂掉Windows系统。如果仿真器在10秒内再次停止,则不会重新启动,以避免无限循环,从而导致Windows系统挂起。</target>
        </trans-unit>
        <trans-unit id="e3a7e58acd1b6273937af4828973ccfe2aa9acaf" translate="yes" xml:space="preserve">
          <source>Makes the Erlang runtime system into a distributed node, similar to &lt;code&gt;-name&lt;/code&gt;, but the host name portion of the node name &lt;code&gt;Name@Host&lt;/code&gt; will be the short name, not fully qualified.</source>
          <target state="translated">使Erlang运行时系统成为分布式节点，类似于 &lt;code&gt;-name&lt;/code&gt; ，但是节点名称 &lt;code&gt;Name@Host&lt;/code&gt; 的主机名部分将是简称，不完全限定。</target>
        </trans-unit>
        <trans-unit id="f7aa031d2e4d7c3b20a440dd107fb282795ac6f0" translate="yes" xml:space="preserve">
          <source>Makes the Erlang runtime system into a distributed node. This flag invokes all network servers necessary for a node to become distributed; see &lt;code&gt;net_kernel(3)&lt;/code&gt;. It is also ensured that &lt;code&gt;epmd&lt;/code&gt; runs on the current host before Erlang is started; see &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd(1)&lt;/a&gt;&lt;/code&gt;.and the &lt;code&gt;&lt;a href=&quot;#start_epmd&quot;&gt;-start_epmd&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">使Erlang运行时系统成为分布式节点。此标志调用节点分发所需的所有网络服务器。参见 &lt;code&gt;net_kernel(3)&lt;/code&gt; 。还可以确保 &lt;code&gt;epmd&lt;/code&gt; 在启动Erlang之前在当前主机上运行；请参阅 &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd(1)&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#start_epmd&quot;&gt;-start_epmd&lt;/a&gt;&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="b8a750500054d695ef79dc67c8e3f89388948a20" translate="yes" xml:space="preserve">
          <source>Makes the Erlang runtime system invoke &lt;code&gt;make:all()&lt;/code&gt; in the current working directory and then terminate; see &lt;code&gt;make(3)&lt;/code&gt;. Implies &lt;code&gt;-noinput&lt;/code&gt;.</source>
          <target state="translated">使Erlang运行时系统在当前工作目录中调用 &lt;code&gt;make:all()&lt;/code&gt; 然后终止；参见 &lt;code&gt;make(3)&lt;/code&gt; 。表示 &lt;code&gt;-noinput&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c606e85ac2aed92be8eb1ce19cdcab5a15e4f9b9" translate="yes" xml:space="preserve">
          <source>Makes the array resizable. (Reverses the effects of &lt;code&gt;&lt;a href=&quot;#fix-1&quot;&gt;fix/1&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">使数组可调整大小。（反转 &lt;code&gt;&lt;a href=&quot;#fix-1&quot;&gt;fix/1&lt;/a&gt;&lt;/code&gt; 的效果。）</target>
        </trans-unit>
        <trans-unit id="ab845853493a2c837853fd6b3e8f0aaa392fd64f" translate="yes" xml:space="preserve">
          <source>Makes the breakpoint at &lt;code&gt;Line&lt;/code&gt; in &lt;code&gt;Module&lt;/code&gt; active.</source>
          <target state="translated">使得在断点处 &lt;code&gt;Line&lt;/code&gt; 在 &lt;code&gt;Module&lt;/code&gt; 激活。</target>
        </trans-unit>
        <trans-unit id="66efe312d73a33922588677a593f505e5441c8f3" translate="yes" xml:space="preserve">
          <source>Makes the breakpoint at &lt;code&gt;Line&lt;/code&gt; in &lt;code&gt;Module&lt;/code&gt; inactive.</source>
          <target state="translated">使得在断点处 &lt;code&gt;Line&lt;/code&gt; 在 &lt;code&gt;Module&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="4197e2c90774db9c9ce91b8b094791dfa882c29c" translate="yes" xml:space="preserve">
          <source>Makes the calling process become a &lt;code&gt;gen_statem&lt;/code&gt;. Does not return, instead the calling process enters the &lt;code&gt;gen_statem&lt;/code&gt; receive loop and becomes a &lt;code&gt;gen_statem&lt;/code&gt; server. The process &lt;strong&gt;must&lt;/strong&gt; have been started using one of the start functions in &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib&lt;/a&gt;&lt;/code&gt;. The user is responsible for any initialization of the process, including registering a name for it.</source>
          <target state="translated">使调用过程成为 &lt;code&gt;gen_statem&lt;/code&gt; 。不返回，而是调用进程进入 &lt;code&gt;gen_statem&lt;/code&gt; 接收循环并成为 &lt;code&gt;gen_statem&lt;/code&gt; 服务器。该过程&lt;strong&gt;必须&lt;/strong&gt;已经使用在启动功能之一开始 &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib&lt;/a&gt;&lt;/code&gt; 。用户负责该过程的任何初始化，包括为其注册一个名称。</target>
        </trans-unit>
        <trans-unit id="7816dd7bfd9f71c9801ecdf559eb8559d1fd39dd" translate="yes" xml:space="preserve">
          <source>Makes the current code for &lt;code&gt;Module&lt;/code&gt; become old code and deletes all references for this module from the export table. Returns &lt;code&gt;undefined&lt;/code&gt; if the module does not exist, otherwise &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">使 &lt;code&gt;Module&lt;/code&gt; 的当前代码成为旧代码，并从导出表中删除该模块的所有引用。如果模块不存在，则返回 &lt;code&gt;undefined&lt;/code&gt; ，否则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ffc4bee79fb8820e1fdd4f31e40972ffd12cfcd" translate="yes" xml:space="preserve">
          <source>Makes the current version of &lt;code&gt;Mod&lt;/code&gt; old. &lt;code&gt;PrePurge&lt;/code&gt; is ignored. For a description of &lt;code&gt;PostPurge&lt;/code&gt;, see the high-level instruction &lt;code&gt;update&lt;/code&gt; earlier.</source>
          <target state="translated">使当前版本的 &lt;code&gt;Mod&lt;/code&gt; 旧。 &lt;code&gt;PrePurge&lt;/code&gt; 被忽略。有关 &lt;code&gt;PostPurge&lt;/code&gt; 的描述，请参阅前面的高级指令 &lt;code&gt;update&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75ccf5b40e3c580610c11910676d267ac96338b9" translate="yes" xml:space="preserve">
          <source>Makes the emulator print its version number.</source>
          <target state="translated">使仿真器打印其版本号。</target>
        </trans-unit>
        <trans-unit id="03fcc3406838240ad7e71ecfcf6e7cb062a03c52" translate="yes" xml:space="preserve">
          <source>Makes the emulator print its version number. The same as &lt;code&gt;erl +V&lt;/code&gt;.</source>
          <target state="translated">使模拟器打印其版本号。与 &lt;code&gt;erl +V&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="0c6eda41af82625c188e23faff139b871d0dc271" translate="yes" xml:space="preserve">
          <source>Makes the file perform automatic translation of characters to and from a specific (Unicode) encoding. Notice that the data supplied to &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; or returned by &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; still is byte-oriented; this option denotes only how data is stored in the disk file.</source>
          <target state="translated">使文件与特定（Unicode）编码之间进行字符自动翻译。请注意，提供给 &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; 或由 &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; 返回的数据仍然是面向字节的；此选项仅表示磁盘文件中的数据存储方式。</target>
        </trans-unit>
        <trans-unit id="ce1b5535c27729e37b24da5577a1e2edda190797" translate="yes" xml:space="preserve">
          <source>Makes the first process created by a traced process inherit its trace flags, excluding flag &lt;code&gt;set_on_first_spawn&lt;/code&gt;.</source>
          <target state="translated">使由跟踪进程创建的第一个进程继承其跟踪标志，但不包括标志 &lt;code&gt;set_on_first_spawn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51a7e91b712508eac0b349f8e399224c503bf1a3" translate="yes" xml:space="preserve">
          <source>Makes the first process linked to by a traced process inherit its trace flags, excluding flag &lt;code&gt;set_on_first_link&lt;/code&gt;.</source>
          <target state="translated">使被跟踪进程链接的第一个进程继承其跟踪标志，但标志 &lt;code&gt;set_on_first_link&lt;/code&gt; 除外。</target>
        </trans-unit>
        <trans-unit id="699e692edb812c99776e6de21b71da2e27456acb" translate="yes" xml:space="preserve">
          <source>Makes the function &lt;code&gt;F/A&lt;/code&gt; no longer being auto-imported from the &lt;code&gt;erlang&lt;/code&gt; module, which resolves BIF name clashes. This option must be used to resolve name clashes with BIFs auto-imported before R14A, if it is needed to call the local function with the same name as an auto-imported BIF without module prefix.</source>
          <target state="translated">使功能 &lt;code&gt;F/A&lt;/code&gt; 不再从 &lt;code&gt;erlang&lt;/code&gt; 模块自动导入，从而解决BIF名称冲突。如果需要使用与没有模块前缀的自动导入的BIF相同的名称调用本地函数，则必须使用此选项来解决在R14A之前自动导入的BIF的名称冲突。</target>
        </trans-unit>
        <trans-unit id="5ad0c7129eb3658b1728b9b552dafdedadbc94c1" translate="yes" xml:space="preserve">
          <source>Makes the process &lt;code&gt;Pid&lt;/code&gt; leave the group &lt;code&gt;Name&lt;/code&gt;. If the process is not a member of the group, &lt;code&gt;ok&lt;/code&gt; is returned.</source>
          <target state="translated">使进程 &lt;code&gt;Pid&lt;/code&gt; 离开组 &lt;code&gt;Name&lt;/code&gt; 。如果该进程不是该组的成员，则返回 &lt;code&gt;ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45ad2871084bc4b367921bd684d396b4d847881d" translate="yes" xml:space="preserve">
          <source>Makes the specified release version &lt;code&gt;Vsn&lt;/code&gt; permanent.</source>
          <target state="translated">使指定的发行版本 &lt;code&gt;Vsn&lt;/code&gt; 永久。</target>
        </trans-unit>
        <trans-unit id="2f4cd63c2b38297a9b1944489ca49b98d5502133" translate="yes" xml:space="preserve">
          <source>Makes the transaction silently return the tuple &lt;code&gt;{aborted, Reason}&lt;/code&gt;. Termination of a Mnesia transaction means that an exception is thrown to an enclosing &lt;code&gt;catch&lt;/code&gt;. Thus, the expression &lt;code&gt;catch mnesia:abort(x)&lt;/code&gt; does not terminate the transaction.</source>
          <target state="translated">使事务静默返回元组 &lt;code&gt;{aborted, Reason}&lt;/code&gt; 。 Mnesia事务的终止意味着对封闭的 &lt;code&gt;catch&lt;/code&gt; 抛出异常。因此，表达式 &lt;code&gt;catch mnesia:abort(x)&lt;/code&gt; 不会终止事务。</target>
        </trans-unit>
        <trans-unit id="c3c361414f40468ac17c2fe68754d480ca1bcf62" translate="yes" xml:space="preserve">
          <source>Making a hardware watchdog available</source>
          <target state="translated">提供一个硬件监控系统</target>
        </trans-unit>
        <trans-unit id="a6b950fad26bf1993d43209bd38ff1959147aa83" translate="yes" xml:space="preserve">
          <source>Making calls from a &lt;code&gt;high&lt;/code&gt; priority process into code that you has no control over can cause the &lt;code&gt;high&lt;/code&gt; priority process to wait for a process with lower priority. That is, effectively decreasing the priority of the &lt;code&gt;high&lt;/code&gt; priority process during the call. Even if this is not the case with one version of the code that you have no control over, it can be the case in a future version of it. This can, for example, occur if a &lt;code&gt;high&lt;/code&gt; priority process triggers code loading, as the code server runs on priority &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">将来自 &lt;code&gt;high&lt;/code&gt; 优先级进程的调用转换为您无法控制的代码，可能导致 &lt;code&gt;high&lt;/code&gt; 优先级进程等待较低优先级的进程。即，在呼叫期间有效地降低 &lt;code&gt;high&lt;/code&gt; 优先级处理的优先级。即使您无法控制的一个版本的代码不是这种情况，在将来的版本中也可能如此。例如，如果 &lt;code&gt;high&lt;/code&gt; 优先级的进程触发代码加载，则可能会发生这种情况，因为代码服务器以优先级 &lt;code&gt;normal&lt;/code&gt; 运行。</target>
        </trans-unit>
        <trans-unit id="31c6d1769fe27f5b364867a2ba03a8a0ce740773" translate="yes" xml:space="preserve">
          <source>Making requests without checking that the return value indicates success can be OK if the test case fails later, but it is never acceptable just to print an error message (into the log file) and return successfully. Such test cases do harm, as they create a false sense of security when overviewing the test results.</source>
          <target state="translated">如果测试用例后来失败了,在不检查返回值是否表示成功的情况下提出请求是可以的,但是仅仅打印一个错误信息(到日志文件中)并成功返回是绝对不能接受的。这样的测试用例会造成伤害,因为它们会在浏览测试结果时产生一种虚假的安全感。</target>
        </trans-unit>
        <trans-unit id="2d4f453eee7e2dd34a8e386a2b75375fa105539c" translate="yes" xml:space="preserve">
          <source>Making several calls to &lt;code&gt;monitor/2&lt;/code&gt; for the same &lt;code&gt;Item&lt;/code&gt; and/or &lt;code&gt;Type&lt;/code&gt; is not an error; it results in as many independent monitoring instances.</source>
          <target state="translated">对相同的 &lt;code&gt;Item&lt;/code&gt; 和/或 &lt;code&gt;Type&lt;/code&gt; 多次调用 &lt;code&gt;monitor/2&lt;/code&gt; 并不是错误；它导致了许多独立的监视实例。</target>
        </trans-unit>
        <trans-unit id="466c358751442005c7e7d386e4d7e639cbf1ac39" translate="yes" xml:space="preserve">
          <source>Making several calls to &lt;code&gt;monitor_node(Node, true)&lt;/code&gt; for the same &lt;code&gt;Node&lt;/code&gt; is not an error; it results in as many independent monitoring instances.</source>
          <target state="translated">多次调用同一 &lt;code&gt;Node&lt;/code&gt; &lt;code&gt;monitor_node(Node, true)&lt;/code&gt; 并非错误；它导致了许多独立的监视实例。</target>
        </trans-unit>
        <trans-unit id="c730df3afaaac142f305e8f798eca241f12abf9f" translate="yes" xml:space="preserve">
          <source>Malayalam</source>
          <target state="translated">Malayalam</target>
        </trans-unit>
        <trans-unit id="eef68d8ca2c02e4bd3d5725888ca18ccdc7ca252" translate="yes" xml:space="preserve">
          <source>Manage a &lt;code&gt;Trace Pattern&lt;/code&gt;</source>
          <target state="translated">管理 &lt;code&gt;Trace Pattern&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff5123b141ff090ff835a7f30332c3740b2707e5" translate="yes" xml:space="preserve">
          <source>Manager configuration:</source>
          <target state="translated">经理配置。</target>
        </trans-unit>
        <trans-unit id="65a4a223a80dcdb4faa701bab0904a7145c7139e" translate="yes" xml:space="preserve">
          <source>Manager specific config options and types:</source>
          <target state="translated">管理员特定的配置选项和类型。</target>
        </trans-unit>
        <trans-unit id="63617cfe427854e42387ca5fb2dd42a8d02042c4" translate="yes" xml:space="preserve">
          <source>Mandaic</source>
          <target state="translated">Mandaic</target>
        </trans-unit>
        <trans-unit id="4c2ea2d10dc0ede0423eff4ee1aac7300cd7cc28" translate="yes" xml:space="preserve">
          <source>Mandatory</source>
          <target state="translated">Mandatory</target>
        </trans-unit>
        <trans-unit id="55779720bd078b43fecc03c38a4dee19d2f0260c" translate="yes" xml:space="preserve">
          <source>Mandatory RAM. The schema resides in RAM only. At startup, a tiny new schema is generated. This default schema contains only the definition of the schema table and resides on the local node only. Since no other nodes are found in the default schema, configuration parameter &lt;code&gt;extra_db_nodes&lt;/code&gt; must be used to let the node share its table definitions with other nodes. (Parameter &lt;code&gt;extra_db_nodes&lt;/code&gt; can also be used on disc-full nodes.)</source>
          <target state="translated">强制RAM。模式仅驻留在RAM中。在启动时，会生成一个微小的新架构。此默认架构仅包含架构表的定义，并且仅位于本地节点上。由于在默认模式中未找到其他节点， &lt;code&gt;extra_db_nodes&lt;/code&gt; 必须使用配置参数extra_db_nodes来使该节点与其他节点共享其表定义。（参数 &lt;code&gt;extra_db_nodes&lt;/code&gt; 也可以在已满光盘的节点上使用。）</target>
        </trans-unit>
        <trans-unit id="ef7f5fd2af32ce149c0ca960148e8bf3bd0f1d1a" translate="yes" xml:space="preserve">
          <source>Mandatory RAM. The schema resides in RAM only. At startup, a tiny new schema is generated. This default schema only contains the definition of the schema table and only resides on the local node. Since no other nodes are found in the default schema, configuration parameter &lt;code&gt;extra_db_nodes&lt;/code&gt; must be used to let the node share its table definitions with other nodes.</source>
          <target state="translated">强制RAM。模式仅驻留在RAM中。在启动时，会生成一个微小的新架构。此默认架构仅包含架构表的定义，并且仅驻留在本地节点上。由于在默认模式中未找到其他节点， &lt;code&gt;extra_db_nodes&lt;/code&gt; 必须使用配置参数extra_db_nodes来使该节点与其他节点共享其表定义。</target>
        </trans-unit>
        <trans-unit id="dd245892c4cf7481ff0b76736f06f016f9538140" translate="yes" xml:space="preserve">
          <source>Mandatory disc. The schema is assumed to be located in the &lt;code&gt;Mnesia&lt;/code&gt; directory. If the schema cannot be found, &lt;code&gt;Mnesia&lt;/code&gt; refuses to start.</source>
          <target state="translated">强制性光盘。假定该模式位于 &lt;code&gt;Mnesia&lt;/code&gt; 目录中。如果找不到该架构，则 &lt;code&gt;Mnesia&lt;/code&gt; 拒绝启动。</target>
        </trans-unit>
        <trans-unit id="056c789bb6261a61e562f98c5294a028b2c27e2a" translate="yes" xml:space="preserve">
          <source>Mandatory disc. The schema is assumed to be located in the Mnesia directory. If the schema cannot be found, Mnesia refuses to start. This is the old behavior.</source>
          <target state="translated">必备光盘。假设模式位于Mnesia目录中。如果找不到模式,Mnesia拒绝启动。这是旧的行为。</target>
        </trans-unit>
        <trans-unit id="9bf3e3f7107080f2dd0decda36be42d7dcd887d3" translate="yes" xml:space="preserve">
          <source>Mandatory if &lt;code&gt;-reldir&lt;/code&gt; is not specified and no &lt;code&gt;RELDIR&lt;/code&gt; exists in the environment. This specifies the Erlang installation root directory (under which the &lt;code&gt;lib&lt;/code&gt;, &lt;code&gt;releases&lt;/code&gt;, and &lt;code&gt;erts-&amp;lt;Version&amp;gt;&lt;/code&gt; directories are located). If only &lt;code&gt;-reldir&lt;/code&gt; (or environment variable &lt;code&gt;RELDIR&lt;/code&gt;) is specified, the Erlang root is assumed to be the directory exactly one level above the release directory.</source>
          <target state="translated">如果未指定 &lt;code&gt;RELDIR&lt;/code&gt; 且环境中不存在 &lt;code&gt;-reldir&lt;/code&gt; 则为必需。这指定了Erlang安装根目录（位于 &lt;code&gt;lib&lt;/code&gt; ， &lt;code&gt;releases&lt;/code&gt; 和 &lt;code&gt;erts-&amp;lt;Version&amp;gt;&lt;/code&gt; 目录下）。如果仅 &lt;code&gt;-reldir&lt;/code&gt; （或环境变量 &lt;code&gt;RELDIR&lt;/code&gt; ），则将Erlang根目录假定为发布目录正上方的目录。</target>
        </trans-unit>
        <trans-unit id="27228686f00efd9069abdd5d3e934b51d59f64a9" translate="yes" xml:space="preserve">
          <source>Mandatory if environment variable &lt;code&gt;RELDIR&lt;/code&gt; is not specified and no &lt;code&gt;-rootdir&lt;/code&gt; option is specified. Tells &lt;code&gt;start_erl&lt;/code&gt; where the root of the release tree is located in the file system (typically &amp;lt;Erlang root&amp;gt;\\releases). The &lt;code&gt;start_erl.data&lt;/code&gt; file is expected to be located in this directory (unless otherwise specified). If only option &lt;code&gt;-rootdir&lt;/code&gt; is specified, the directory is assumed to be &amp;lt;Erlang root&amp;gt;\\releases.</source>
          <target state="translated">如果未指定环境变量 &lt;code&gt;RELDIR&lt;/code&gt; 且未指定 &lt;code&gt;-rootdir&lt;/code&gt; 选项，则为必选。告诉 &lt;code&gt;start_erl&lt;/code&gt; 发行树的根在文件系统中的位置（通常为&amp;lt;Erlang根&amp;gt; \\ releases）。该 &lt;code&gt;start_erl.data&lt;/code&gt; 文件预计将位于该目录中（除非另有说明）。如果仅指定选项 &lt;code&gt;-rootdir&lt;/code&gt; ，则假定目录为&amp;lt;Erlang根目录&amp;gt; \\ releases。</target>
        </trans-unit>
        <trans-unit id="d51f3b74b92dcfdb5b928a635f84a5f51200457c" translate="yes" xml:space="preserve">
          <source>Mandatory. Delimits &lt;code&gt;start_erl&lt;/code&gt; options from normal Erlang options. Everything on the command line &lt;strong&gt;before&lt;/strong&gt;&lt;code&gt;++&lt;/code&gt; is interpreted as options to be sent to the &lt;code&gt;erl&lt;/code&gt; program. Everything &lt;strong&gt;after&lt;/strong&gt;&lt;code&gt;++&lt;/code&gt; is interpreted as options to &lt;code&gt;start_erl&lt;/code&gt; itself.</source>
          <target state="translated">必选 从普通的Erlang选项中分隔 &lt;code&gt;start_erl&lt;/code&gt; 选项。 &lt;code&gt;++&lt;/code&gt; &lt;strong&gt;之前&lt;/strong&gt;的命令行上的所有内容都解释为要发送到 &lt;code&gt;erl&lt;/code&gt; 程序的选项。 &lt;code&gt;++&lt;/code&gt; &lt;strong&gt;之后的&lt;/strong&gt;所有内容都解释为 &lt;code&gt;start_erl&lt;/code&gt; 本身的选项。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fc48591fe7588ae910f82a8e32e5898f8b677543" translate="yes" xml:space="preserve">
          <source>Mandatory: one or more</source>
          <target state="translated">强制性:一个或多个</target>
        </trans-unit>
        <trans-unit id="40331ec2ec252f48c8769280f8a9d0addf85621c" translate="yes" xml:space="preserve">
          <source>Manichaean</source>
          <target state="translated">Manichaean</target>
        </trans-unit>
        <trans-unit id="1a83f62a1c9d2ea7c7b76528168eeb1027e1c303" translate="yes" xml:space="preserve">
          <source>Manipulate the return of all suite configuration calls and by extension the result of the test themselves.</source>
          <target state="translated">操纵所有套件配置调用的返回,并延伸到测试本身的结果。</target>
        </trans-unit>
        <trans-unit id="a70642b028568014a36d3c8b54782719d4573d07" translate="yes" xml:space="preserve">
          <source>Manipulate the return of all suite configuration calls, and in extension, the result of the tests themselves.</source>
          <target state="translated">操纵所有套件配置调用的返回,并扩展到测试本身的结果。</target>
        </trans-unit>
        <trans-unit id="28533b136858ffce59b77b52f8bc0d5d5c92201b" translate="yes" xml:space="preserve">
          <source>Manipulate the runtime configuration before each suite configuration call.</source>
          <target state="translated">在每个套件配置调用之前,操纵运行时配置。</target>
        </trans-unit>
        <trans-unit id="a777446b5191e48dad7cad24722806c79d3f271e" translate="yes" xml:space="preserve">
          <source>Manipulation of data represented as Erlang data types</source>
          <target state="translated">对以Erlang数据类型表示的数据进行操作。</target>
        </trans-unit>
        <trans-unit id="8d09db94e4c55d4786f4570130a4d22ac51744f7" translate="yes" xml:space="preserve">
          <source>Manner in which incoming answer messages containing decode errors are handled.</source>
          <target state="translated">处理包含解码错误的应答信息的方式。</target>
        </trans-unit>
        <trans-unit id="6284d04575c3819f39fde9f65fd471b9435e0ad1" translate="yes" xml:space="preserve">
          <source>Manner in which incoming requests are handled when an error other than 3007 (DIAMETER_APPLICATION_UNSUPPORTED, which cannot be associated with an application callback module), is detected.</source>
          <target state="translated">当检测到除3007(DIAMETER_APPLICATION_UNSUPPORTED,不能与应用回调模块相关联)以外的错误时,处理传入请求的方式。</target>
        </trans-unit>
        <trans-unit id="5351cf3c5581dd875efa06c896ad751d99613d56" translate="yes" xml:space="preserve">
          <source>Manually performs a mib server cache gc. This can be done regardless of the value of the &lt;code&gt;autogc&lt;/code&gt; option. The &lt;code&gt;NumElementsGCed&lt;/code&gt; value indicates how many elements where actually removed from the cache.</source>
          <target state="translated">手动执行mib服务器缓存gc。无论 &lt;code&gt;autogc&lt;/code&gt; 选项的值如何，都可以执行此操作。该 &lt;code&gt;NumElementsGCed&lt;/code&gt; 值表示多少元素，其中真正从缓存中删除。</target>
        </trans-unit>
        <trans-unit id="c5c7ebf32bd378c4ba16c49e6124169115f258a7" translate="yes" xml:space="preserve">
          <source>Many assertions (of any sort) can occur in succession. For example, the following matches &quot;foo&quot; preceded by three digits that are not &quot;999&quot;:</source>
          <target state="translated">许多断言(任何类型)可以连续出现。例如,下面匹配的 &quot;foo &quot;前面有三个不是 &quot;999 &quot;的数字。</target>
        </trans-unit>
        <trans-unit id="7f887661a9b51d0d5237dac908440eb7b836be70" translate="yes" xml:space="preserve">
          <source>Many driver API functions have changed argument type and/or return value to &lt;code&gt;ErlDrvSizeT&lt;/code&gt; from mostly &lt;code&gt;int&lt;/code&gt;. Automatic type-casting probably makes these changes necessary only for a driver that encounters sizes &amp;gt; 32 bits.</source>
          <target state="translated">许多驱动程序API函数已将参数类型和/或返回值从大多为 &lt;code&gt;int&lt;/code&gt; 更改为 &lt;code&gt;ErlDrvSizeT&lt;/code&gt; 。自动类型转换可能仅对于遇到大小&amp;gt; 32位的驱动程序才需要进行这些更改。</target>
        </trans-unit>
        <trans-unit id="56029af12913d9bc7ea74d4914ee32e80f6707df" translate="yes" xml:space="preserve">
          <source>Many list comprehension expressions can be evaluated by the &lt;code&gt;qlc&lt;/code&gt; module. Exceptions are expressions, such that variables introduced in patterns (or filters) are used in some generator later in the list comprehension. As an example, consider an implementation of &lt;code&gt;lists:append(L)&lt;/code&gt;: &lt;code&gt;[X ||Y &amp;lt;- L, X &amp;lt;- Y]&lt;/code&gt;. &lt;code&gt;Y&lt;/code&gt; is introduced in the first generator and used in the second. The ordinary list comprehension is normally to be preferred when there is a choice as to which to use. One difference is that &lt;code&gt;&lt;a href=&quot;#eval-1&quot;&gt;eval/1,2&lt;/a&gt;&lt;/code&gt; collects answers in a list that is finally reversed, while list comprehensions collect answers on the stack that is finally unwound.</source>
          <target state="translated">&lt;code&gt;qlc&lt;/code&gt; 模块可以评估许多列表理解表达式。例外是表达式，以便稍后在列表理解中的某些生成器中使用模式（或过滤器）中引入的变量。例如，考虑一个 &lt;code&gt;lists:append(L)&lt;/code&gt; ： &lt;code&gt;[X ||Y &amp;lt;- L, X &amp;lt;- Y]&lt;/code&gt; 。 &lt;code&gt;Y&lt;/code&gt; 在第一个生成器中引入，在第二个生成器中使用。当可以选择使用哪种列表时，通常首选普通列表理解。一个区别是 &lt;code&gt;&lt;a href=&quot;#eval-1&quot;&gt;eval/1,2&lt;/a&gt;&lt;/code&gt; 在最终被颠倒的列表中收集答案，而列表推导在最终解开的堆栈中收集答案。</target>
        </trans-unit>
        <trans-unit id="4a3eae152029d738a0ebe7e23d689a8ac8f03946" translate="yes" xml:space="preserve">
          <source>Many nice things can be done with the iterator functions but take some caution about performance and memory use for large tables.</source>
          <target state="translated">使用迭代器函数可以做很多不错的事情,但是对于大表的性能和内存使用要谨慎一些。</target>
        </trans-unit>
        <trans-unit id="9fdf7f9f32446c75f533a26900329aea292fc48d" translate="yes" xml:space="preserve">
          <source>Many of the operators can only be applied to arguments of a certain type. For example, arithmetic operators can only be applied to numbers. An argument of the wrong type causes a &lt;code&gt;badarg&lt;/code&gt; runtime error.</source>
          <target state="translated">许多运算符只能应用于某种类型的参数。例如，算术运算符只能应用于数字。类型错误的参数会导致 &lt;code&gt;badarg&lt;/code&gt; 运行时错误。</target>
        </trans-unit>
        <trans-unit id="f2f1df17f07587c5055c0ce8c9221879d8708726" translate="yes" xml:space="preserve">
          <source>Many of the output functions have a &quot;header buffer&quot;, with &lt;code&gt;hbuf&lt;/code&gt; and &lt;code&gt;hlen&lt;/code&gt; parameters. This buffer is sent as a list before the binary (or list, depending on port mode) that is sent. This is convenient when matching on messages received from the port. (Although in the latest Erlang versions there is the binary syntax, which enables you to match on the beginning of a binary.)</source>
          <target state="translated">许多输出函数都有一个带有&amp;ldquo; &lt;code&gt;hbuf&lt;/code&gt; &amp;rdquo;和&amp;ldquo; &lt;code&gt;hlen&lt;/code&gt; &amp;rdquo;参数的&amp;ldquo;头缓冲区&amp;rdquo; 。该缓冲区在发送二进制文件（或列表，取决于端口模式）之前作为列表发送。当匹配从端口接收的消息时，这很方便。（尽管在最新的Erlang版本中有二进制语法，使您可以在二进制开头进行匹配。）</target>
        </trans-unit>
        <trans-unit id="21b179b8985ad61d572fc99ea80a2e913e1d0bdd" translate="yes" xml:space="preserve">
          <source>Many operations communicating with a process executing a dirty NIF can, however, complete while it executes the dirty NIF. For example, retrieving information about it through &lt;code&gt;erlang:process_info&lt;/code&gt;, setting its group leader, register/unregister its name, and so on.</source>
          <target state="translated">但是，与执行脏NIF的进程进行通信的许多操作可以在执行脏NIF的过程中完成。例如，通过 &lt;code&gt;erlang:process_info&lt;/code&gt; 检索有关它的信息，设置其组长，注册/注销其名称，等等。</target>
        </trans-unit>
        <trans-unit id="f86703eb2414253099183ba096ef8f59d855dec4" translate="yes" xml:space="preserve">
          <source>Many restrictions apply to the fun that is translated into a match specification. To put it simple: you cannot use anything in the fun that you cannot use in a match specification. This means that, among others, the following restrictions apply to the fun itself:</source>
          <target state="translated">许多限制都适用于被翻译成匹配规范的乐趣。简单来说:你不能在fun中使用任何不能在匹配规范中使用的东西。这意味着,除此之外,以下限制也适用于 fun 本身。</target>
        </trans-unit>
        <trans-unit id="b3277af475a535b5e15ac96f9ce422da3543b8bc" translate="yes" xml:space="preserve">
          <source>Many small test cases tend to result in extra, and possibly duplicated code, as well as slow test execution because of large overhead for initializations and cleanups. Avoid duplicated code, for example, by using common help functions. Otherwise, the resulting suite becomes difficult to read and understand, and expensive to maintain.</source>
          <target state="translated">许多小的测试用例往往会导致额外的、可能是重复的代码,以及由于初始化和清理的大量开销而导致测试执行缓慢。例如,通过使用通用的帮助函数来避免重复的代码。否则,所产生的套件就会变得难以阅读和理解,而且维护成本很高。</target>
        </trans-unit>
        <trans-unit id="f4757731a17b024e345545fcb6d59364979c23d4" translate="yes" xml:space="preserve">
          <source>Many telecommunications applications have unique requirements on lookup times for certain types of records. If the &lt;code&gt;Company&lt;/code&gt; database had been a part of a telecommunications system, it could be to minimize the lookup time of an employee &lt;strong&gt;together&lt;/strong&gt; with a list of the projects the employee is working on. If this is the case, a drastically different data model without direct relationships can be chosen. You would then have only the records themselves, and different records could contain either direct references to other records, or contain other records that are not part of the &lt;code&gt;Mnesia&lt;/code&gt; schema.</source>
          <target state="translated">许多电信应用程序对某些类型的记录的查找时间有独特的要求。如果 &lt;code&gt;Company&lt;/code&gt; 数据库是电信系统的一部分，它可能是一个员工的查找时间最小化&lt;strong&gt;一起&lt;/strong&gt;与员工正在工作的项目清单。如果是这种情况，可以选择没有直接关系的完全不同的数据模型。这样，您将只拥有记录本身，并且不同的记录可以包含对其他记录的直接引用，也可以包含不属于 &lt;code&gt;Mnesia&lt;/code&gt; 模式的其他记录。</target>
        </trans-unit>
        <trans-unit id="68017d6821eb323d2063e3ce0fd2add46797e7ea" translate="yes" xml:space="preserve">
          <source>Many telecommunications applications must be controlled and reconfigured remotely. It is sometimes an advantage to perform this remote control with an open protocol such as the Simple Network Management Protocol (SNMP). The alternatives to this would be the following:</source>
          <target state="translated">许多电信应用必须通过远程控制和重新配置。有时,使用简单网络管理协议(SNMP)等开放协议进行远程控制是一种优势。除此之外,还有以下几种选择:</target>
        </trans-unit>
        <trans-unit id="e7b004a583d02bc15f8db5aaa5239ed752c86ac6" translate="yes" xml:space="preserve">
          <source>Map holding the main components of a URI.</source>
          <target state="translated">包含URI的主要组成部分的地图。</target>
        </trans-unit>
        <trans-unit id="f9636957ea9c74ef69d5b705de848b9cde84373e" translate="yes" xml:space="preserve">
          <source>Mapping of SNMPv2 error message to SNMPv1:</source>
          <target state="translated">SNMPv2错误信息与SNMPv1的映射。</target>
        </trans-unit>
        <trans-unit id="c286942228a25588025573f075da4c09d52b9607" translate="yes" xml:space="preserve">
          <source>Maps are a set of key to value associations. These associations are encapsulated with &quot;#{&quot; and &quot;}&quot;. To create an association from &quot;key&quot; to value 42:</source>
          <target state="translated">地图是一组键到值的关联。这些关联用 &quot;#{&quot;和&quot;}&quot;封装。要创建一个从 &quot;键 &quot;到值的关联 42:</target>
        </trans-unit>
        <trans-unit id="04b5c5dbf8eab96a0231ea5b92737fd2b0a1ce74" translate="yes" xml:space="preserve">
          <source>Maps are allowed in guards as long as all subexpressions are valid guard expressions.</source>
          <target state="translated">只要所有的子表达式都是有效的守卫表达式,就允许在守卫中使用地图。</target>
        </trans-unit>
        <trans-unit id="363ad38891c14a93a51e759557264fd84b9d27cc" translate="yes" xml:space="preserve">
          <source>Maps are considered to be experimental during Erlang/OTP R17.</source>
          <target state="translated">在Erlang/OTP R17期间,地图被认为是试验性的。</target>
        </trans-unit>
        <trans-unit id="d13027fd4ebe765466d95071c641f5db67b026f6" translate="yes" xml:space="preserve">
          <source>Maps are ordered by size, two maps with the same size are compared by keys in ascending term order and then by values in key order. In maps key order integers types are considered less than floats types.</source>
          <target state="translated">地图按大小排序,两个相同大小的地图按升项顺序的键比较,然后按键顺序的值比较。在地图键序中,整数类型被认为比浮点数类型要少。</target>
        </trans-unit>
        <trans-unit id="d3761b3f052ddea8579fdb64072c5ede6d3ff627" translate="yes" xml:space="preserve">
          <source>Maps function F(K, V1) -&amp;gt; V2 to all key-value pairs of tree &lt;code&gt;Tree1&lt;/code&gt;. Returns a new tree &lt;code&gt;Tree2&lt;/code&gt; with the same set of keys as &lt;code&gt;Tree1&lt;/code&gt; and the new set of values &lt;code&gt;V2&lt;/code&gt;.</source>
          <target state="translated">将函数F（K，V1）-&amp;gt; V2映射到树 &lt;code&gt;Tree1&lt;/code&gt; 的所有键值对。返回具有与 &lt;code&gt;Tree2&lt;/code&gt; 相同的键 &lt;code&gt;Tree1&lt;/code&gt; 和新的值 &lt;code&gt;V2&lt;/code&gt; 集的新树Tree2。</target>
        </trans-unit>
        <trans-unit id="729cd71fbff021f36308a64f8ae94d9a49e5da1b" translate="yes" xml:space="preserve">
          <source>Maps processing</source>
          <target state="translated">地图处理</target>
        </trans-unit>
        <trans-unit id="7ea86ddec10f80bb2c7782afe4921fda0718970f" translate="yes" xml:space="preserve">
          <source>Maps processing functions.</source>
          <target state="translated">地图处理功能。</target>
        </trans-unit>
        <trans-unit id="6501b098152b10c2d1fd7868786d299194e00b4a" translate="yes" xml:space="preserve">
          <source>Maps the specified function onto each array element, skipping default-valued entries. The elements are visited in order from the lowest index to the highest. If &lt;code&gt;Function&lt;/code&gt; is not a function, the call fails with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">将指定的函数映射到每个数组元素，跳过默认值的条目。按从最低索引到最高索引的顺序访问元素。如果 &lt;code&gt;Function&lt;/code&gt; 不是函数，则调用失败，原因为 &lt;code&gt;badarg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d1791268d9973c2080f7cdeef13debd8dce8751" translate="yes" xml:space="preserve">
          <source>Maps the specified function onto each array element. The elements are visited in order from the lowest index to the highest. If &lt;code&gt;Function&lt;/code&gt; is not a function, the call fails with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">将指定的函数映射到每个数组元素。按从最低索引到最高索引的顺序访问元素。如果 &lt;code&gt;Function&lt;/code&gt; 不是函数，则调用失败，原因为 &lt;code&gt;badarg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31e9697d43a1a66f2e45db652019fb9a6216df22" translate="yes" xml:space="preserve">
          <source>Mark</source>
          <target state="translated">Mark</target>
        </trans-unit>
        <trans-unit id="10a075120eb484727a09f2f3701ac80c559eec39" translate="yes" xml:space="preserve">
          <source>Mark the directories/modules you want to analyze for discrepancies and click &lt;strong&gt;Add&lt;/strong&gt;. You can either add the &lt;code&gt;.beam&lt;/code&gt; and &lt;code&gt;.erl&lt;/code&gt; files directly, or add directories that contain these kind of files. Notice that you are only allowed to add the type of files that can be analyzed in the current mode of operation (see below), and that you cannot mix &lt;code&gt;.beam&lt;/code&gt; and &lt;code&gt;.erl&lt;/code&gt; files.</source>
          <target state="translated">标记要分析差异的目录/模块，然后单击&lt;strong&gt;添加&lt;/strong&gt;。您可以直接添加 &lt;code&gt;.beam&lt;/code&gt; 和 &lt;code&gt;.erl&lt;/code&gt; 文件，也可以添加包含此类文件的目录。请注意，仅允许您添加可以在当前操作模式下分析的文件类型（请参见下文），并且不能混合使用 &lt;code&gt;.beam&lt;/code&gt; 和 &lt;code&gt;.erl&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="197dfa50ea4b8649cb35689f0decbb6c374c77b7" translate="yes" xml:space="preserve">
          <source>Marks &lt;code&gt;Dir&lt;/code&gt; as sticky.</source>
          <target state="translated">将 &lt;code&gt;Dir&lt;/code&gt; 标记为粘性。</target>
        </trans-unit>
        <trans-unit id="7b5406131a661f19f4b14f972097e09771980111" translate="yes" xml:space="preserve">
          <source>Marks a registry object as dirty. This ensures that it is included in the next backup to &lt;code&gt;Mnesia&lt;/code&gt;. Normally this operation is not necessary, as all of the normal registry 'set' functions do this automatically. However, if you have retrieved the value of a string or binary object from the registry and modified the contents, then the change is invisible to the registry and the object is assumed to be unmodified. This function allows you to make such modifications and then let the registry know about them.</source>
          <target state="translated">将注册表对象标记为脏。这样可以确保它包含在 &lt;code&gt;Mnesia&lt;/code&gt; 的下一个备份中。通常，此操作不是必需的，因为所有常规注册表&amp;ldquo;设置&amp;rdquo;功能都会自动执行此操作。但是，如果您已从注册表中检索了字符串或二进制对象的值并修改了内容，则该更改对注册表不可见，并且假定该对象未修改。此功能允许您进行此类修改，然后让注册表知道它们。</target>
        </trans-unit>
        <trans-unit id="bcbfc3c88f06b01ad7c3cccfab1c852094317788" translate="yes" xml:space="preserve">
          <source>Marks that driver instances can handle being called in the &lt;code&gt;&lt;a href=&quot;#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;#outputv&quot;&gt;outputv&lt;/a&gt;&lt;/code&gt; callbacks although a driver instance has marked itself as busy (see &lt;code&gt;&lt;a href=&quot;erl_driver#set_busy_port&quot;&gt;erl_driver:set_busy_port&lt;/a&gt;&lt;/code&gt;). As from ERTS 5.7.4 this flag is required for drivers used by the Erlang distribution (the behavior has always been required by drivers used by the distribution).</source>
          <target state="translated">标记驱动程序实例可以处理在 &lt;code&gt;&lt;a href=&quot;#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt; 和/或 &lt;code&gt;&lt;a href=&quot;#outputv&quot;&gt;outputv&lt;/a&gt;&lt;/code&gt; 回调中被调用，尽管驱动程序实例已将其自身标记为繁忙（请参见 &lt;code&gt;&lt;a href=&quot;erl_driver#set_busy_port&quot;&gt;erl_driver:set_busy_port&lt;/a&gt;&lt;/code&gt; ）。从ERTS 5.7.4开始，Erlang发行版使用的驱动程序需要此标志（发行版使用的驱动程序始终要求该行为）。</target>
        </trans-unit>
        <trans-unit id="44a77f06fe20eb0136352abea280e4ae8f164595" translate="yes" xml:space="preserve">
          <source>Marshall T. Rose (1991), &quot;The Simple Book - An Introduction to Internet Management&quot;, Prentice-Hall</source>
          <target state="translated">Marshall T.Rose (1991),&quot;The Simple Book-An Introduction to Internet Management&quot;,Prentice-Hall.</target>
        </trans-unit>
        <trans-unit id="ff171d7e2ec66d8d77776b728f30299bf8e3e6c9" translate="yes" xml:space="preserve">
          <source>Match a pattern against a syntax tree (or patterns against syntax trees) returning an environment mapping variable names to subtrees; the environment is always sorted on keys. Note that multiple occurrences of metavariables in the pattern is not allowed, but is not checked.</source>
          <target state="translated">将模式与语法树匹配(或模式与语法树匹配),返回一个将变量名映射到子树的环境;环境总是按键排序。需要注意的是,不允许在模式中出现多个元变量,但不进行检查。</target>
        </trans-unit>
        <trans-unit id="d2de4afa174487d24d4a58ea206ea53aeb3c9f62" translate="yes" xml:space="preserve">
          <source>Match against one or more clauses with patterns and optional guards.</source>
          <target state="translated">与一个或多个带模式的子句和可选的护栏进行匹配。</target>
        </trans-unit>
        <trans-unit id="509635766fe25fda0e8fcb1e73a1a4900a524a90" translate="yes" xml:space="preserve">
          <source>Match all objects in an ETS table with arity &amp;gt; 1 and the first element is 'gandalf', and return element 2:</source>
          <target state="translated">匹配ETS表中arity&amp;gt; 1的所有对象，并且第一个元素是'gandalf'，然后返回元素2：</target>
        </trans-unit>
        <trans-unit id="5cb24c4903ed09ea4659ce737242ec2cae99a47b" translate="yes" xml:space="preserve">
          <source>Match all objects in an ETS table, where the first element is the atom &lt;code&gt;'strider'&lt;/code&gt; and the tuple arity is 3, and return the whole object:</source>
          <target state="translated">匹配ETS表中的所有对象，其中第一个元素是原子 &lt;code&gt;'strider'&lt;/code&gt; ，元组对数为3，然后返回整个对象：</target>
        </trans-unit>
        <trans-unit id="7edee42de18d23f1dd88981c1e38214f04375e1b" translate="yes" xml:space="preserve">
          <source>Match an argument list of three, where the first and third arguments are equal:</source>
          <target state="translated">匹配一个有三个参数的参数列表,其中第一个和第三个参数是相等的。</target>
        </trans-unit>
        <trans-unit id="007b6fe417206569cf211bcff5829b2fb375ff62" translate="yes" xml:space="preserve">
          <source>Match an argument list of three, where the second argument is a number &amp;gt; 3:</source>
          <target state="translated">匹配参数列表三，其中第二个参数是数字&amp;gt; 3：</target>
        </trans-unit>
        <trans-unit id="aaa654601a0768fd3a5ea8e1f4e632cb6ef820a5" translate="yes" xml:space="preserve">
          <source>Match an argument list of three, where the third argument is either a tuple containing argument one and two, &lt;strong&gt;or&lt;/strong&gt; a list beginning with argument one and two (that is, &lt;code&gt;[a,b,[a,b,c]]&lt;/code&gt; or &lt;code&gt;[a,b,{a,b}]&lt;/code&gt;):</source>
          <target state="translated">匹配参数列表3，其中第三个参数是包含参数1和2的元组，&lt;strong&gt;或者&lt;/strong&gt;是以参数1和2开头的列表（即 &lt;code&gt;[a,b,[a,b,c]]&lt;/code&gt; 或 &lt;code&gt;[a,b,{a,b}]&lt;/code&gt; ] ，b，{a，b}]）：</target>
        </trans-unit>
        <trans-unit id="92514756645fe7077028fc14821601f7e85836da" translate="yes" xml:space="preserve">
          <source>Match any character except newline (by default)</source>
          <target state="translated">匹配除换行以外的任何字符(默认情况下)。</target>
        </trans-unit>
        <trans-unit id="62e56bea29683834bf7ec08fb1eb30aa1828744a" translate="yes" xml:space="preserve">
          <source>Match some dictionary entries</source>
          <target state="translated">匹配一些字典条目</target>
        </trans-unit>
        <trans-unit id="311fb719c2d9cb64132a0b11b661fb396a3a0223" translate="yes" xml:space="preserve">
          <source>Match specification, see section &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; in the ERTS User's Guide and &lt;code&gt;&lt;a href=&quot;ms_transform&quot;&gt;ms_transform(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">匹配规范，请参阅《 ERTS用户指南》 &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; 中的&amp;ldquo; 匹配规范 &amp;rdquo;部分和 &lt;code&gt;&lt;a href=&quot;ms_transform&quot;&gt;ms_transform(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c08d65581b61fabe23402aa00e8ab9a94f3ae9ef" translate="yes" xml:space="preserve">
          <source>Match specifications are used more or less as filters. They resemble usual Erlang matching in a list comprehension or in a fun used with &lt;code&gt;&lt;a href=&quot;lists#foldl-3&quot;&gt;lists:foldl/3&lt;/a&gt;&lt;/code&gt;, and so on. However, the syntax of pure match specifications is awkward, as they are made up purely by Erlang terms, and the language has no syntax to make the match specifications more readable.</source>
          <target state="translated">匹配规范或多或少用作过滤器。它们在列表理解中或与 &lt;code&gt;&lt;a href=&quot;lists#foldl-3&quot;&gt;lists:foldl/3&lt;/a&gt;&lt;/code&gt; 一起使用时很像普通的Erlang匹配。但是，纯匹配规范的语法很尴尬，因为它们完全由Erlang术语组成，并且该语言没有使匹配规范更具可读性的语法。</target>
        </trans-unit>
        <trans-unit id="28103d4192f64923a9e433e5c840bc4e8b567bda" translate="yes" xml:space="preserve">
          <source>Match specifications used can be saved in a file (if a read-write file system is present) for use in later debugging sessions, see &lt;code&gt;&lt;a href=&quot;#wtp-1&quot;&gt;wtp/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#rtp-1&quot;&gt;rtp/1&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">可以将使用的匹配规范保存在文件中（如果存在读写文件系统），以供以后的调试会话使用，请参阅 &lt;code&gt;&lt;a href=&quot;#wtp-1&quot;&gt;wtp/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#rtp-1&quot;&gt;rtp/1&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1229fff8a073694fbfc1092526ee8748365e4bdf" translate="yes" xml:space="preserve">
          <source>Match specifications, see section &lt;code&gt;Match Specification in Erlang&lt;/code&gt; in ERTS User's Guide and the &lt;code&gt;&lt;a href=&quot;ms_transform&quot;&gt;ms_transform(3)&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">匹配规范，请参阅《ERTS用户指南》 &lt;code&gt;Match Specification in Erlang&lt;/code&gt; 中的&amp;ldquo; 匹配规范 &amp;rdquo;部分和 &lt;code&gt;&lt;a href=&quot;ms_transform&quot;&gt;ms_transform(3)&lt;/a&gt;&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="c45c41f60cedeecdd4b1c366db7e307e66a6a606" translate="yes" xml:space="preserve">
          <source>Match target</source>
          <target state="translated">匹配目标</target>
        </trans-unit>
        <trans-unit id="58de7407dcefed17ecbb0f0f0caecc0925acc26e" translate="yes" xml:space="preserve">
          <source>Match the &lt;code&gt;MatchHead&lt;/code&gt; part against the match target term, binding the &lt;code&gt;'$&amp;lt;number&amp;gt;'&lt;/code&gt; variables (much like in &lt;code&gt;ets:match/2&lt;/code&gt;). If the &lt;code&gt;MatchHead&lt;/code&gt; part cannot match the arguments, the match fails.</source>
          <target state="translated">将 &lt;code&gt;MatchHead&lt;/code&gt; 部分与匹配目标词进行匹配，并绑定 &lt;code&gt;'$&amp;lt;number&amp;gt;'&lt;/code&gt; 变量（非常类似于 &lt;code&gt;ets:match/2&lt;/code&gt; ）。如果 &lt;code&gt;MatchHead&lt;/code&gt; 部分无法匹配参数，则匹配失败。</target>
        </trans-unit>
        <trans-unit id="d0bb026735ab1b1a560327096ea49590520df5c7" translate="yes" xml:space="preserve">
          <source>Match three arguments. When all three are equal and are numbers, append the process dump to the trace message, otherwise let the trace message be &quot;as is&quot;, but set the sequential trace token label to 4711:</source>
          <target state="translated">匹配三个参数。当三个参数都相等且都是数字时,将进程转储附加到跟踪消息中,否则让跟踪消息 &quot;保持原样&quot;,但将顺序跟踪标记标签设置为4711。</target>
        </trans-unit>
        <trans-unit id="50d2b574a0b4bf14c816284735e4a32f6738492f" translate="yes" xml:space="preserve">
          <source>Match tuples of three elements, where the second element is either &lt;code&gt;'merry'&lt;/code&gt; or &lt;code&gt;'pippin'&lt;/code&gt;, and return the whole objects:</source>
          <target state="translated">匹配三个元素的元组，其中第二个元素是 &lt;code&gt;'merry'&lt;/code&gt; 或 &lt;code&gt;'pippin'&lt;/code&gt; ，并返回整个对象：</target>
        </trans-unit>
        <trans-unit id="b52bb892dfc03f66052c156357fd98f06f6d6ad0" translate="yes" xml:space="preserve">
          <source>Match two arguments, where the first is a tuple beginning with a list that in turn begins with the second argument times two (that is, &lt;code&gt;[{[4,x],y},2]&lt;/code&gt; or &lt;code&gt;[{[8], y, z},4])&lt;/code&gt;:</source>
          <target state="translated">匹配两个参数，第一个是一个元组，该元组以一个列表开头，第二个参数又乘以两个列表（即 &lt;code&gt;[{[4,x],y},2]&lt;/code&gt; 或 &lt;code&gt;[{[8], y, z},4])&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="da3931950dd632f760d810b04a1dfee915ca645d" translate="yes" xml:space="preserve">
          <source>MatchBody ::= [ ActionTerm ]</source>
          <target state="translated">MatchBody ::=[ActionTerm]。</target>
        </trans-unit>
        <trans-unit id="49eed79dc355081fc78c915df6e6741691fad326" translate="yes" xml:space="preserve">
          <source>MatchBody ::= [ ConditionExpression, ... ]</source>
          <target state="translated">MatchBody ::=[ConditionExpression,...]。</target>
        </trans-unit>
        <trans-unit id="e7543ce8b4424850514899929477fd3fd4bc7586" translate="yes" xml:space="preserve">
          <source>MatchCondition ::= { GuardFunction } | { GuardFunction, ConditionExpression, ... }</source>
          <target state="translated">MatchCondition ::={GuardFunction }。|{GuardFunction,ConditionExpression,...}</target>
        </trans-unit>
        <trans-unit id="7a1238f4170ab727b947ac14efc193f8277c9e1a" translate="yes" xml:space="preserve">
          <source>MatchConditions ::= [ MatchCondition, ...] | &lt;code&gt;[]&lt;/code&gt;</source>
          <target state="translated">MatchConditions :: = [MatchCondition，...] | &lt;code&gt;[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="95bf5fe6015be79d0f9353ed2e6ebd9f6f5c1aaf" translate="yes" xml:space="preserve">
          <source>MatchExpression ::= [ MatchFunction, ... ]</source>
          <target state="translated">MatchExpression ::=[MatchFunction,...]。</target>
        </trans-unit>
        <trans-unit id="4362346f5ab9c3e849d7a732cb6f7149b013ecea" translate="yes" xml:space="preserve">
          <source>MatchFunction ::= { MatchHead, MatchConditions, MatchBody }</source>
          <target state="translated">MatchFunction ::={MatchHead,MatchConditions,MatchBody }。</target>
        </trans-unit>
        <trans-unit id="62fe68ac64e3f31f3bc26fda2674c9914f299bee" translate="yes" xml:space="preserve">
          <source>MatchHead ::= MatchVariable | &lt;code&gt;'_'&lt;/code&gt; | [ MatchHeadPart, ... ]</source>
          <target state="translated">MatchHead :: = MatchVariable | &lt;code&gt;'_'&lt;/code&gt; | [MatchHeadPart，...]</target>
        </trans-unit>
        <trans-unit id="8d11a2590b00416cc7fd21aa567f9dc7dcd1e80a" translate="yes" xml:space="preserve">
          <source>MatchHead ::= MatchVariable | &lt;code&gt;'_'&lt;/code&gt; | { MatchHeadPart, ... }</source>
          <target state="translated">MatchHead :: = MatchVariable | &lt;code&gt;'_'&lt;/code&gt; | {MatchHeadPart，...}</target>
        </trans-unit>
        <trans-unit id="4c3dc5459e996623b4e979c498a0b4c1d7e9b686" translate="yes" xml:space="preserve">
          <source>MatchHeadPart ::= term() | MatchVariable | &lt;code&gt;'_'&lt;/code&gt;</source>
          <target state="translated">MatchHeadPart :: = term（）| MatchVariable | &lt;code&gt;'_'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b5c57568dca7b0bd330575231a9b4b598aa5de7d" translate="yes" xml:space="preserve">
          <source>MatchVariable ::= '$&amp;lt;number&amp;gt;'</source>
          <target state="translated">MatchVariable :: ='$ &amp;lt;数字&amp;gt;'</target>
        </trans-unit>
        <trans-unit id="0086ec33bc64b94a17c1488954c54ae1f0850ff5" translate="yes" xml:space="preserve">
          <source>Matches any character.</source>
          <target state="translated">匹配任何字符。</target>
        </trans-unit>
        <trans-unit id="b0bce32c5a3c3fc3ed0e703a29ce005a9a59c17b" translate="yes" xml:space="preserve">
          <source>Matches any number of characters up to the end of the filename, the next dot, or the next slash.</source>
          <target state="translated">匹配任意数量的字符,直到文件名的末尾,下一个点或下一个斜线。</target>
        </trans-unit>
        <trans-unit id="f115e2cfefeef7ee50e81931c874414b0559f037" translate="yes" xml:space="preserve">
          <source>Matches any of the characters listed. Two characters separated by a hyphen match a range of characters. Example: &lt;code&gt;[A-Z]&lt;/code&gt; matches any uppercase letter.</source>
          <target state="translated">匹配列出的任何字符。用连字符分隔的两个字符与一个字符范围匹配。示例： &lt;code&gt;[A-Z]&lt;/code&gt; 匹配任何大写字母。</target>
        </trans-unit>
        <trans-unit id="50795a0a08132b80e78d1e76523a0677ba80c9ba" translate="yes" xml:space="preserve">
          <source>Matches any peer. This is a convenience that provides a filter equivalent to no filter.</source>
          <target state="translated">匹配任何同行。这是一种方便,提供了一个相当于无过滤器的过滤器。</target>
        </trans-unit>
        <trans-unit id="45303a6504cacc79e7d23b3bbb52fa9c500e5dd8" translate="yes" xml:space="preserve">
          <source>Matches at a word boundary.</source>
          <target state="translated">在一个词的边界处进行匹配。</target>
        </trans-unit>
        <trans-unit id="7ac95a7b57dc892c5cbccecec503375cd8b75457" translate="yes" xml:space="preserve">
          <source>Matches at the end of the subject, and before a newline at the end of the subject.</source>
          <target state="translated">匹配在主题的末尾,以及主题末尾的新行之前。</target>
        </trans-unit>
        <trans-unit id="dfe97d17ef60dfa95587204790b8e7a03401165c" translate="yes" xml:space="preserve">
          <source>Matches at the first matching position in the subject.</source>
          <target state="translated">在主题的第一个匹配位置进行匹配。</target>
        </trans-unit>
        <trans-unit id="30957d7eb006582b971d8e18207879a7a2e62a2f" translate="yes" xml:space="preserve">
          <source>Matches at the start of the subject.</source>
          <target state="translated">匹配在主题的开始。</target>
        </trans-unit>
        <trans-unit id="c20e2cfc85fd5962f00bfd1aab37748d15201d74" translate="yes" xml:space="preserve">
          <source>Matches one character.</source>
          <target state="translated">匹配一个角色。</target>
        </trans-unit>
        <trans-unit id="bf384d7f3f9dc4a8d07f9032759bd099ac99af1e" translate="yes" xml:space="preserve">
          <source>Matches one or more &lt;code&gt;rs&lt;/code&gt;.</source>
          <target state="translated">匹配一个或多个 &lt;code&gt;rs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95b0a058c78027f9b36554648c7e31c06df213b3" translate="yes" xml:space="preserve">
          <source>Matches only at the end of the subject.</source>
          <target state="translated">只在科目末尾匹配。</target>
        </trans-unit>
        <trans-unit id="bce02edb2750c6f7e1edccc714e57113b0b26a46" translate="yes" xml:space="preserve">
          <source>Matches only those peers for which the specified &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; when applied to the connection's &lt;code&gt;diameter_caps&lt;/code&gt; record. Any other return value or exception is equivalent to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">仅匹配当指定 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 应用于连接的 &lt;code&gt;diameter_caps&lt;/code&gt; 记录时为其返回 &lt;code&gt;true&lt;/code&gt; 的那些对等方。其他任何返回值或异常都等同于 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c84c071e773e0343110738922ba722b0e2af3f2c" translate="yes" xml:space="preserve">
          <source>Matches only those peers matched by at least one filter in the specified list. The resulting list will be in match order, peers matching the first filter of the list sorting before those matched by the second, and so on.</source>
          <target state="translated">只匹配指定列表中至少一个过滤器匹配的对等体。结果列表将按匹配顺序排列,匹配列表中第一个过滤器的对等体在第二个过滤器匹配的对等体之前排序,以此类推。</target>
        </trans-unit>
        <trans-unit id="2f2592920b5282895068215ce350574baf645c52" translate="yes" xml:space="preserve">
          <source>Matches only those peers matched by each filter in the specified list.</source>
          <target state="translated">只匹配指定列表中每个过滤器所匹配的对等体。</target>
        </trans-unit>
        <trans-unit id="589f2d5ff54077f4e7ded5e562f61c1d207b2d40" translate="yes" xml:space="preserve">
          <source>Matches only those peers not matched by the specified filter.</source>
          <target state="translated">只匹配那些未被指定过滤器匹配的对等体。</target>
        </trans-unit>
        <trans-unit id="a63639f69671438d06e3a88ceb05c2fd6d45b827" translate="yes" xml:space="preserve">
          <source>Matches only those peers whose Origin-Host has the same value as Destination-Host in the outgoing request in question, or any peer if the request does not contain a Destination-Host AVP.</source>
          <target state="translated">只匹配那些Origin-Host和Destination-Host值相同的对等体,如果请求中不包含Destination-Host AVP,则匹配任何对等体。</target>
        </trans-unit>
        <trans-unit id="7246e14a8a2a6df71afafbd3a74a8b44cdfbd531" translate="yes" xml:space="preserve">
          <source>Matches only those peers whose Origin-Host has the specified value, or all peers if the atom &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">仅匹配Origin-Host具有指定值的那些对等方，如果原子 &lt;code&gt;any&lt;/code&gt; 则匹配所有对等体。</target>
        </trans-unit>
        <trans-unit id="95597417bac7dc49af239c255741702c0c22bdaf" translate="yes" xml:space="preserve">
          <source>Matches only those peers whose Origin-Realm has the same value as Destination-Realm in the outgoing request in question, or any peer if the request does not contain a Destination-Realm AVP.</source>
          <target state="translated">只匹配Origin-Realm和Destination-Realm值相同的对等体,如果请求中不包含Destination-Realm AVP,则匹配任何对等体。</target>
        </trans-unit>
        <trans-unit id="4616ccf0ec60315c7670131e4744903a3aa36484" translate="yes" xml:space="preserve">
          <source>Matches only those peers whose Origin-Realm has the specified value, or all peers if the atom &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">仅匹配Origin-Realm具有指定值的那些对等方，如果原子 &lt;code&gt;any&lt;/code&gt; 则匹配所有对等体。</target>
        </trans-unit>
        <trans-unit id="8a4e16b1f64f5c039f506ff58b839fd8686c547b" translate="yes" xml:space="preserve">
          <source>Matches some objects stored in a table and returns a non-empty list of the bindings matching a specified pattern in some unspecified order. The table, the pattern, and the number of objects that are matched are all defined by &lt;code&gt;Continuation&lt;/code&gt;, which has been returned by a previous call to &lt;code&gt;match/1&lt;/code&gt; or &lt;code&gt;match/3&lt;/code&gt;.</source>
          <target state="translated">匹配表中存储的某些对象，并以未指定的顺序返回与指定模式匹配的绑定的非空列表。该表，模式和匹配的对象数均由 &lt;code&gt;Continuation&lt;/code&gt; 定义，这是先前调用 &lt;code&gt;match/1&lt;/code&gt; 或 &lt;code&gt;match/3&lt;/code&gt; 返回的。</target>
        </trans-unit>
        <trans-unit id="fd0109e8c46b7b74ad55d61eaa83a0d60c1cd8f8" translate="yes" xml:space="preserve">
          <source>Matches some or all objects of table &lt;code&gt;Name&lt;/code&gt; and returns a non-empty list of the bindings that match &lt;code&gt;Pattern&lt;/code&gt; in some unspecified order. For a description of patterns, see &lt;code&gt;&lt;a href=&quot;ets#match-2&quot;&gt;ets:match/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">匹配表 &lt;code&gt;Name&lt;/code&gt; 的部分或全部对象，并以未指定的顺序返回与 &lt;code&gt;Pattern&lt;/code&gt; 匹配的绑定的非空列表。有关模式的描述，请参见 &lt;code&gt;&lt;a href=&quot;ets#match-2&quot;&gt;ets:match/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7450adfcb4b169def8a4607352e723d68bd86b34" translate="yes" xml:space="preserve">
          <source>Matches some or all objects stored in table &lt;code&gt;Name&lt;/code&gt; and returns a non-empty list of the objects that match &lt;code&gt;Pattern&lt;/code&gt; in some unspecified order. For a description of patterns, see &lt;code&gt;&lt;a href=&quot;ets#match-2&quot;&gt;ets:match/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">匹配表 &lt;code&gt;Name&lt;/code&gt; 中存储的一些或所有对象，并以未指定的顺序返回与 &lt;code&gt;Pattern&lt;/code&gt; 匹配的对象的非空列表。有关模式的描述，请参见 &lt;code&gt;&lt;a href=&quot;ets#match-2&quot;&gt;ets:match/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adb3e1824193dafdae7a5fd33b8ea49f66c2c1dd" translate="yes" xml:space="preserve">
          <source>Matches the beginning of a string.</source>
          <target state="translated">匹配一个字符串的开头。</target>
        </trans-unit>
        <trans-unit id="4c548c831bb16f2a3bc17e5430fb0fb7ff876eb6" translate="yes" xml:space="preserve">
          <source>Matches the end of a string.</source>
          <target state="translated">匹配一个字符串的末端。</target>
        </trans-unit>
        <trans-unit id="2cdef85f0928e6e8b1028572e8dc40e0e560c24e" translate="yes" xml:space="preserve">
          <source>Matches the escape sequence or literal character c.</source>
          <target state="translated">匹配转义序列或文字字符c。</target>
        </trans-unit>
        <trans-unit id="0435b1eedb79970f4013fe9211b9ebe7da670511" translate="yes" xml:space="preserve">
          <source>Matches the non-metacharacter c.</source>
          <target state="translated">匹配非元字c。</target>
        </trans-unit>
        <trans-unit id="e28e6ed212ebaee585530d5991166a71f8b48a86" translate="yes" xml:space="preserve">
          <source>Matches the objects in table &lt;code&gt;Tab&lt;/code&gt; against pattern &lt;code&gt;Pattern&lt;/code&gt;.</source>
          <target state="translated">将表 &lt;code&gt;Tab&lt;/code&gt; 中的对象与 &lt;code&gt;Pattern&lt;/code&gt; 相匹配。</target>
        </trans-unit>
        <trans-unit id="1d29aca058cbf8d1d0f58db77974d455fcaada07" translate="yes" xml:space="preserve">
          <source>Matches the objects in table &lt;code&gt;Tab&lt;/code&gt; against pattern &lt;code&gt;Pattern&lt;/code&gt;. For a description of patterns, see &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt;. The function returns a list of all objects that match the pattern.</source>
          <target state="translated">将表 &lt;code&gt;Tab&lt;/code&gt; 中的对象与 &lt;code&gt;Pattern&lt;/code&gt; 相匹配。有关模式的描述，请参见 &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt; 。该函数返回与模式匹配的所有对象的列表。</target>
        </trans-unit>
        <trans-unit id="db735a0007cc043e4574b21e24e3a6e8e46b90e2" translate="yes" xml:space="preserve">
          <source>Matches the objects in table &lt;code&gt;Tab&lt;/code&gt; using a &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt;. If the match specification returns &lt;code&gt;true&lt;/code&gt; for an object, that object considered a match and is counted. For any other result from the match specification the object is not considered a match and is therefore not counted.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 表 &lt;code&gt;Tab&lt;/code&gt; 中的对象。如果匹配规范对某个对象返回 &lt;code&gt;true&lt;/code&gt; ，则该对象被视为匹配并被计数。对于来自匹配规范的任何其他结果，该对象不被视为匹配，因此不计算在内。</target>
        </trans-unit>
        <trans-unit id="6b012b167808e61a37f3f13edeb00bcf37acbcee" translate="yes" xml:space="preserve">
          <source>Matches the objects in table &lt;code&gt;Tab&lt;/code&gt; using a &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt;. If the match specification returns &lt;code&gt;true&lt;/code&gt; for an object, that object is removed from the table. For any other result from the match specification the object is retained. This is a more general call than the &lt;code&gt;&lt;a href=&quot;#match_delete-2&quot;&gt;match_delete/2&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 表 &lt;code&gt;Tab&lt;/code&gt; 中的对象。如果匹配规范对某个对象返回 &lt;code&gt;true&lt;/code&gt; ，则将该对象从表中删除。对于匹配说明的任何其他结果，将保留该对象。这是比 &lt;code&gt;&lt;a href=&quot;#match_delete-2&quot;&gt;match_delete/2&lt;/a&gt;&lt;/code&gt; 调用更通用的调用。</target>
        </trans-unit>
        <trans-unit id="f314d3d7e1fd748578a641bfbf6311159aed1316" translate="yes" xml:space="preserve">
          <source>Matches the objects in table &lt;code&gt;Tab&lt;/code&gt; using a &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt;. This is a more general call than &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#match_object-2&quot;&gt;match_object/2&lt;/a&gt;&lt;/code&gt; calls. In its simplest form, the match specification is as follows:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 表 &lt;code&gt;Tab&lt;/code&gt; 中的对象。这比 &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#match_object-2&quot;&gt;match_object/2&lt;/a&gt;&lt;/code&gt; 调用更通用。匹配规范最简单的形式如下：</target>
        </trans-unit>
        <trans-unit id="8dfac617898b79dd2741468d1513c14a6c53d233" translate="yes" xml:space="preserve">
          <source>Matches the objects in table &lt;code&gt;Tab&lt;/code&gt; using a &lt;code&gt;match_spec&lt;/code&gt; as described in the &lt;code&gt;ERTS&lt;/code&gt; User's Guide, and returns a chunk of terms and a continuation. The wanted number of returned terms is specified by argument &lt;code&gt;NObjects&lt;/code&gt;. The lock argument can be &lt;code&gt;read&lt;/code&gt; or &lt;code&gt;write&lt;/code&gt;. The continuation is to be used as argument to &lt;code&gt;mnesia:select/1&lt;/code&gt;, if more or all answers are needed.</source>
          <target state="translated">按照 &lt;code&gt;ERTS&lt;/code&gt; 用户指南中的描述，使用 &lt;code&gt;match_spec&lt;/code&gt; 匹配表 &lt;code&gt;Tab&lt;/code&gt; 中的对象，并返回大量术语和后续内容。返回参数的期望数量由参数 &lt;code&gt;NObjects&lt;/code&gt; 指定。lock参数可以 &lt;code&gt;read&lt;/code&gt; 或 &lt;code&gt;write&lt;/code&gt; 。如果需要更多或所有答案，则继续将用作 &lt;code&gt;mnesia:select/1&lt;/code&gt; 的参数。</target>
        </trans-unit>
        <trans-unit id="e64640be20ca493c8fc40edf41b5b9186f3b2197" translate="yes" xml:space="preserve">
          <source>Matches the objects in table &lt;code&gt;Tab&lt;/code&gt; using a &lt;code&gt;match_spec&lt;/code&gt; as described in the &lt;code&gt;ets:select/3&lt;/code&gt;. Optionally a lock &lt;code&gt;read&lt;/code&gt; or &lt;code&gt;write&lt;/code&gt; can be given as the third argument. Default is &lt;code&gt;read&lt;/code&gt;. The return value depends on &lt;code&gt;MatchSpec&lt;/code&gt;.</source>
          <target state="translated">如 &lt;code&gt;ets:select/3&lt;/code&gt; 中所述，使用 &lt;code&gt;match_spec&lt;/code&gt; 匹配表 &lt;code&gt;Tab&lt;/code&gt; 中的对象。可以选择将锁定 &lt;code&gt;read&lt;/code&gt; 或 &lt;code&gt;write&lt;/code&gt; 作为第三个参数。默认为 &lt;code&gt;read&lt;/code&gt; 。返回值取决于 &lt;code&gt;MatchSpec&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1f9639126fbeb35a28a58c64b5cdf217294a65f" translate="yes" xml:space="preserve">
          <source>Matches the objects in the table &lt;code&gt;Tab&lt;/code&gt; using a &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt;. For each matched object, the existing object is replaced with the match specification result.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 表 &lt;code&gt;Tab&lt;/code&gt; 中的对象。对于每个匹配的对象，将现有对象替换为匹配说明结果。</target>
        </trans-unit>
        <trans-unit id="473b51b88af255ce39d9fa5d375d31e69528b449" translate="yes" xml:space="preserve">
          <source>Matches when not at a word boundary.</source>
          <target state="translated">当不在一个词的边界时,匹配。</target>
        </trans-unit>
        <trans-unit id="ff59d4c3d244f3cad2fc9a4df684903b72e3fa73" translate="yes" xml:space="preserve">
          <source>Matches zero or more &lt;code&gt;rs&lt;/code&gt;.</source>
          <target state="translated">匹配零个或多个 &lt;code&gt;rs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf4e77ebb7ccf37afab91a38875933929de61e50" translate="yes" xml:space="preserve">
          <source>Matches zero or one &lt;code&gt;rs&lt;/code&gt;.</source>
          <target state="translated">匹配零或一 &lt;code&gt;rs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b60d1249c4c758556a1d227c9f807ee709be4c34" translate="yes" xml:space="preserve">
          <source>Matching Syntax</source>
          <target state="translated">匹配语法</target>
        </trans-unit>
        <trans-unit id="71e571ae9130ba825368a44ee875bfb358022107" translate="yes" xml:space="preserve">
          <source>Matching a binary will also cause it to shrink and the next append operation will copy the binary data:</source>
          <target state="translated">匹配二进制也会使其收缩,下一次追加操作将复制二进制数据。</target>
        </trans-unit>
        <trans-unit id="36481aa97a951a1dcf7d8486d523f317dc45f5dc" translate="yes" xml:space="preserve">
          <source>Matching an expression against an empty map literal, matches its type but no variables are bound:</source>
          <target state="translated">将表达式与空的映射文字相匹配,匹配其类型,但不绑定变量。</target>
        </trans-unit>
        <trans-unit id="3d117b8c447d4889a004e4beb80ae87b3b9f61b4" translate="yes" xml:space="preserve">
          <source>Matching can be used in combination with records, as shown in the following example:</source>
          <target state="translated">匹配可以与记录结合使用,如下例所示。</target>
        </trans-unit>
        <trans-unit id="21db0315aaeea4915646c1ba5a3af148311bbc82" translate="yes" xml:space="preserve">
          <source>Matching characters by Unicode property is not fast, as PCRE must do a multistage table lookup to find a character property. That is why the traditional escape sequences such as \d and \w do not use Unicode properties in PCRE by default. However, you can make them do so by setting option &lt;code&gt;ucp&lt;/code&gt; or by starting the pattern with (*UCP).</source>
          <target state="translated">通过Unicode属性匹配字符不是很快，因为PCRE必须执行多阶段表查找才能找到字符属性。因此，默认情况下，\ d和\ w等传统转义序列在PCRE中不使用Unicode属性。但是，可以通过设置 &lt;code&gt;ucp&lt;/code&gt; 选项或通过（* UCP）启动模式来使它们这样做。</target>
        </trans-unit>
        <trans-unit id="daa0e37dc758ae15a4e0e7ac7d8a0c3a7422c8e2" translate="yes" xml:space="preserve">
          <source>Matching in maps only allows for &lt;code&gt;:=&lt;/code&gt; as delimiters of associations.</source>
          <target state="translated">映射中的匹配仅允许 &lt;code&gt;:=&lt;/code&gt; 作为关联的分隔符。</target>
        </trans-unit>
        <trans-unit id="e0b3439d7561cb2dee16bc2f99dd957cfc474df0" translate="yes" xml:space="preserve">
          <source>Matching of key-value associations from maps is done as follows:</source>
          <target state="translated">从地图中匹配键值关联的方法如下。</target>
        </trans-unit>
        <trans-unit id="e9cba95bb8e1514e71368d11f0995ae0398f3886" translate="yes" xml:space="preserve">
          <source>Matching of literals as keys are allowed in function heads:</source>
          <target state="translated">在函数头中允许将文字作为键进行匹配。</target>
        </trans-unit>
        <trans-unit id="74c212bf6fa09d18e1ec277db201559eabf9e7c0" translate="yes" xml:space="preserve">
          <source>Matching on the top-level of the fun head can be a more natural way to access &lt;code&gt;'$_'&lt;/code&gt;, see above.</source>
          <target state="translated">在&amp;ldquo; fun head&amp;rdquo;的顶层进行匹配可能是访问 &lt;code&gt;'$_'&lt;/code&gt; 的更自然的方法，请参见上文。</target>
        </trans-unit>
        <trans-unit id="565f0418bb5db88e5d8e94d04658199d8610d3a3" translate="yes" xml:space="preserve">
          <source>Matching with &lt;code&gt;=&lt;/code&gt; cannot be used in the body. It can only be used on the top-level in the head of the fun. Example from the shell again:</source>
          <target state="translated">与 &lt;code&gt;=&lt;/code&gt; 匹配不能在主体中使用。它只能在最有趣的顶层使用。再次从shell中获取示例：</target>
        </trans-unit>
        <trans-unit id="a3b81034e705bd05b97727252f92caaa6d4b0b26" translate="yes" xml:space="preserve">
          <source>Mathematical functions.</source>
          <target state="translated">数学函数。</target>
        </trans-unit>
        <trans-unit id="a06a77cda1f0fe480299649af647924142a54fb7" translate="yes" xml:space="preserve">
          <source>Mathematical symbol</source>
          <target state="translated">数学符号</target>
        </trans-unit>
        <trans-unit id="c58ea4f87745ada36a92fb71c082ea8bc73755ba" translate="yes" xml:space="preserve">
          <source>Max detail level activates tracing of all calls to &lt;code&gt;et:trace_me/4,5&lt;/code&gt;</source>
          <target state="translated">最大详细信息级别激活对 &lt;code&gt;et:trace_me/4,5&lt;/code&gt; 的所有调用的跟踪</target>
        </trans-unit>
        <trans-unit id="11d44674eb08f7f43d0a32b42fd60d63d0160c36" translate="yes" xml:space="preserve">
          <source>Max message size. If the encoded message (PDU) exceeds this size, the message should be segmented, and then encoded.</source>
          <target state="translated">最大报文大小,如果编码后的报文(PDU)超过这个大小,则应进行分段,然后再进行编码。如果编码后的消息(PDU)超过这个大小,则应将消息分段,然后再进行编码。</target>
        </trans-unit>
        <trans-unit id="3d97f56b8e291a3ee3880e81646a3d47ce560d1f" translate="yes" xml:space="preserve">
          <source>Max number of reconnection attempts = 3</source>
          <target state="translated">重新连接的最大尝试次数=3次</target>
        </trans-unit>
        <trans-unit id="8f6fcbc1873209046a71e4646a7bf770c375c7d7" translate="yes" xml:space="preserve">
          <source>Max number of simultaneous requests handled by the agent.</source>
          <target state="translated">代理人同时处理的最大请求数。</target>
        </trans-unit>
        <trans-unit id="134ec94ac95c6d28341162fd550979562d4d3df9" translate="yes" xml:space="preserve">
          <source>MaxHeapSize :: max_heap_size()}</source>
          <target state="translated">MaxHeapSize ::max_heap_size()}。</target>
        </trans-unit>
        <trans-unit id="7fb79c4fc5ed76bf0ff64ddd38b1f62fc36d71a2" translate="yes" xml:space="preserve">
          <source>Maximum &lt;code&gt;mseg_alloc&lt;/code&gt; carriers. Maximum number of carriers placed in separate memory segments. When this limit is reached, new carriers are placed in memory retrieved from &lt;code&gt;sys_alloc&lt;/code&gt;.</source>
          <target state="translated">最大 &lt;code&gt;mseg_alloc&lt;/code&gt; 载波。放置在单独的内存段中的最大载波数。当达到此限制时，新的载体将放置在从 &lt;code&gt;sys_alloc&lt;/code&gt; 检索的内存中。</target>
        </trans-unit>
        <trans-unit id="e6eacd663f585efc475070891fcbc20a37ca64c6" translate="yes" xml:space="preserve">
          <source>Maximum &lt;code&gt;mseg_alloc&lt;/code&gt; multiblock carriers. Maximum number of multiblock carriers allocated through &lt;code&gt;mseg_alloc&lt;/code&gt; by allocator &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt;. When this limit is reached, new multiblock carriers are allocated through &lt;code&gt;sys_alloc&lt;/code&gt;.</source>
          <target state="translated">最大 &lt;code&gt;mseg_alloc&lt;/code&gt; 多块载波。分配器 &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; 通过 &lt;code&gt;mseg_alloc&lt;/code&gt; 分配的最大多块载波数。达到此限制后，将通过 &lt;code&gt;sys_alloc&lt;/code&gt; 分配新的多块载波。</target>
        </trans-unit>
        <trans-unit id="bd2141dfa85073c5d5d798b526c7807965d10406" translate="yes" xml:space="preserve">
          <source>Maximum &lt;code&gt;mseg_alloc&lt;/code&gt; singleblock carriers. Maximum number of singleblock carriers allocated through &lt;code&gt;mseg_alloc&lt;/code&gt; by allocator &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt;. When this limit is reached, new singleblock carriers are allocated through &lt;code&gt;sys_alloc&lt;/code&gt;.</source>
          <target state="translated">最大 &lt;code&gt;mseg_alloc&lt;/code&gt; 单块载波。分配器 &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; 通过 &lt;code&gt;mseg_alloc&lt;/code&gt; 分配的最大单块载波数。达到此限制后，将通过 &lt;code&gt;sys_alloc&lt;/code&gt; 分配新的单块载波。</target>
        </trans-unit>
        <trans-unit id="2560b86e3ae10f6289deb0fb563e661e33d86418" translate="yes" xml:space="preserve">
          <source>Maximum block search depth. This flag has effect only if the good fit strategy is selected for allocator &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt;. When the good fit strategy is used, free blocks are placed in segregated free-lists. Each free-list contains blocks of sizes in a specific range. The maxiumum block search depth sets a limit on the maximum number of blocks to inspect in a free-list during a search for suitable block satisfying the request.</source>
          <target state="translated">最大块搜索深度。仅当为分配器 &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; 选择了合适策略时，此标志才有效。使用良好拟合策略时，会将空闲块放置在单独的空闲列表中。每个空闲列表都包含特定范围内的大小块。最大块搜索深度设置了在搜索满足请求的合适块期间要在自由列表中检查的最大块数的限制。</target>
        </trans-unit>
        <trans-unit id="d51cca9df00fb6d2d33b5042e7197395c4a8e7ed" translate="yes" xml:space="preserve">
          <source>Maximum cached segments. The maximum number of memory segments stored in the memory segment cache. Valid range is &lt;code&gt;[0, 30]&lt;/code&gt;. Defaults to &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">最大缓存段。存储在内存段缓存中的最大内存段数。有效范围是 &lt;code&gt;[0, 30]&lt;/code&gt; 。默认为 &lt;code&gt;10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3aacd33489c919c3259f3def36a32db78de3dce1" translate="yes" xml:space="preserve">
          <source>Maximum content-length in an incoming request, in bytes. Requests with content larger than this are answered with status 413. Default is &lt;code&gt;100000000&lt;/code&gt; (100 MB).</source>
          <target state="translated">传入请求中的最大内容长度（以字节为单位）。内容大于此内容的请求将以状态413进行响应。默认值为 &lt;code&gt;100000000&lt;/code&gt; （100 MB）。</target>
        </trans-unit>
        <trans-unit id="3d28b59ad57e9489a6f4dacef960badc6138d55c" translate="yes" xml:space="preserve">
          <source>Maximum number of accumulated ack's. At most this many ack's will be accumulated by the transaction sender (if started and configured to accumulate ack's).</source>
          <target state="translated">累计ACK的最大数量。交易发送方最多积累这么多ACK(如果启动并配置为积累ACK)。</target>
        </trans-unit>
        <trans-unit id="3fd6bff2681eda77c96a1c420386709c1976443f" translate="yes" xml:space="preserve">
          <source>Maximum number of accumulated requests. At most this many requests will be accumulated by the transaction sender (if started and configured to accumulate requests).</source>
          <target state="translated">累计请求的最大数量。交易发送方最多只能累积这么多请求(如果启动并配置为累积请求)。</target>
        </trans-unit>
        <trans-unit id="266851f73fafaca0bf2a7c683bc5bb3b6087f7f7" translate="yes" xml:space="preserve">
          <source>Maximum number of inbound streams</source>
          <target state="translated">最大入站流数</target>
        </trans-unit>
        <trans-unit id="8e8430ded43149745cb3e173c59fd623e6e072ee" translate="yes" xml:space="preserve">
          <source>Maximum number of locks printed or no limit with &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">印刷锁的最大数或没有限制 &lt;code&gt;none&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32bf44bb5328eccf585529f07558abf83b7b8e84" translate="yes" xml:space="preserve">
          <source>Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly; if 1 the path can be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, ROOT-CA, and so on. The default value is 1.</source>
          <target state="translated">在有效的认证路径中,可以跟随peer证书的非自发中间证书的最大数量。所以,如果深度为0,PEER必须由受信任的ROOT-CA直接签署;如果深度为1,路径可以是PEER、CA、ROOT-CA;如果深度为2,路径可以是PEER、CA、CA、ROOT-CA,以此类推。默认值为1。</target>
        </trans-unit>
        <trans-unit id="99fff8db195ccd6c7a048657d30498c73cc01e79" translate="yes" xml:space="preserve">
          <source>Maximum number of processes allowed in the application.</source>
          <target state="translated">应用程序中允许的最大进程数。</target>
        </trans-unit>
        <trans-unit id="2aaab3dedee65069b116c73b83377fb65720dd78" translate="yes" xml:space="preserve">
          <source>Maximum number of retransmissions before this address is considered unreachable (and an alternative address is selected)</source>
          <target state="translated">在该地址被认为无法到达(并选择一个替代地址)之前,重传的最大次数。</target>
        </trans-unit>
        <trans-unit id="f9241fef7fbe8fcf32ca009d6ccfebe5481eab50" translate="yes" xml:space="preserve">
          <source>Maximum retransmissions while establishing an association</source>
          <target state="translated">建立关联时的最大重传次数</target>
        </trans-unit>
        <trans-unit id="48fdfa1e1dccf2224acc92084ff1e406b0b85d9e" translate="yes" xml:space="preserve">
          <source>Maximum size of the accumulated requests. At most this much requests will be accumulated by the transaction sender (if started and configured to accumulate requests).</source>
          <target state="translated">累计请求的最大大小。事务发送方最多只能积累这么多的请求(如果启动并配置为积累请求)。</target>
        </trans-unit>
        <trans-unit id="28c7bf59062e8e7b399ad75612dd36c886f2132d" translate="yes" xml:space="preserve">
          <source>Maximum time in milliseconds for the authentication negotiation. Defaults to 120000 ms (2 minutes). If the client fails to log in within this time, the connection is closed.</source>
          <target state="translated">认证协商的最长时间(毫秒)。默认值为120000毫秒(2分钟)。如果客户端未能在此时间内登录,连接将被关闭。</target>
        </trans-unit>
        <trans-unit id="5ed8876370f72890efa02c30deff24e537f34e66" translate="yes" xml:space="preserve">
          <source>Maximum time, in milliseconds, that the application is allowed to run. After the specified time, the application terminates automatically.</source>
          <target state="translated">允许应用程序运行的最长时间,以毫秒为单位。在指定时间后,应用程序自动终止。</target>
        </trans-unit>
        <trans-unit id="1d10e5666a4350d3a74dfeb650aa6e788de3d69f" translate="yes" xml:space="preserve">
          <source>May throw exception &lt;code&gt;low_entropy&lt;/code&gt; in case the random generator failed due to lack of secure &quot;randomness&quot;.</source>
          <target state="translated">如果随机生成器由于缺乏安全的&amp;ldquo;随机性&amp;rdquo;而失败，则可能抛出异常 &lt;code&gt;low_entropy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="646deba2eac00f7933fd5cbe027cc187e501a16e" translate="yes" xml:space="preserve">
          <source>May throw exception &lt;code&gt;notsup&lt;/code&gt; in case the chosen &lt;code&gt;Type&lt;/code&gt; is not supported by the underlying OpenSSL implementation.</source>
          <target state="translated">如果基础的OpenSSL实现不支持所选的 &lt;code&gt;Type&lt;/code&gt; ,则可能抛出 &lt;code&gt;notsup&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="de3eaac3de9e89ba4866a20aae2b339c0035484b" translate="yes" xml:space="preserve">
          <source>May throw exception notsup in case there is no engine support in the underlying OpenSSL implementation.</source>
          <target state="translated">在底层OpenSSL实现中没有引擎支持的情况下,可能会抛出异常notsup。</target>
        </trans-unit>
        <trans-unit id="74a5150721719a6283a47c9cfb72e9bc9bff9f71" translate="yes" xml:space="preserve">
          <source>Md5 is a popular choice as a hash function, but it is not secure enough to be validated. Try to use sha instead wherever possible.</source>
          <target state="translated">Md5是一个流行的选择,作为哈希函数,但它不够安全,无法得到验证。尽量使用sha代替。</target>
        </trans-unit>
        <trans-unit id="d947c601b953e99cf3b99eb1e54ea06bc8cd7368" translate="yes" xml:space="preserve">
          <source>Meaning that you don't care if the reply is acknowledged or not.</source>
          <target state="translated">意思是说,你并不在意回复是否被承认。</target>
        </trans-unit>
        <trans-unit id="1c14c209285d898ae15b996256e223eda68f99fc" translate="yes" xml:space="preserve">
          <source>Meaning that you want an acknowledgement &lt;strong&gt;sometime&lt;/strong&gt;. When the acknowledgement eventually is received, the handle_trans_ack/4 callback function will be invoked with the ack_data() as one of its arguments. ack_data() may be any Erlang term.</source>
          <target state="translated">意味着您&lt;strong&gt;有时&lt;/strong&gt;需要确认。最终收到确认后，将使用ack_data（）作为其参数之一来调用handle_trans_ack / 4回调函数。ack_data（）可以是任何Erlang术语。</target>
        </trans-unit>
        <trans-unit id="0a6a0ba0223a6ae2bd06adfc210359ea6aab4c09" translate="yes" xml:space="preserve">
          <source>Meaning that you want an immediate acknowledgement when the other part receives this transaction reply. When the acknowledgement eventually is received, the handle_trans_ack/4 callback function will be invoked with the ack_data() as one of its arguments. ack_data() may be any Erlang term.</source>
          <target state="translated">意思是说,当另一部分收到这个事务回复时,你要立即得到一个确认。当最终收到确认时,handle_trans_ack/4回调函数将以ack_data()作为参数之一被调用。ack_data()可以是任何Erlang术语。</target>
        </trans-unit>
        <trans-unit id="7f498b784a10213b6d5daff6b5f8c433f00ab391" translate="yes" xml:space="preserve">
          <source>Meaningful atoms, not specified above, are the ssl option names.</source>
          <target state="translated">有意义的原子,上面没有指定,是ssl选项名。</target>
        </trans-unit>
        <trans-unit id="04424ff7354672ffdc45258bd640170e14936cbb" translate="yes" xml:space="preserve">
          <source>Measure Elapsed Time</source>
          <target state="translated">测量所需时间</target>
        </trans-unit>
        <trans-unit id="f049a7f84606387c1f036369b9d17679bb303ce9" translate="yes" xml:space="preserve">
          <source>Measure scheduler utilization</source>
          <target state="translated">测量调度器利用率</target>
        </trans-unit>
        <trans-unit id="7f45833b5c1ba2a9c0ab4a66fccfcb8ca4b25b6f" translate="yes" xml:space="preserve">
          <source>Measure utilization for normal and dirty-cpu schedulers during &lt;code&gt;Seconds&lt;/code&gt; seconds, and then return the result.</source>
          <target state="translated">在&amp;ldquo; &lt;code&gt;Seconds&lt;/code&gt; 秒内测量正常CPU和脏CPU调度程序的利用率，然后返回结果。</target>
        </trans-unit>
        <trans-unit id="abb7023ce648e065965ab27aefcab22defabb76e" translate="yes" xml:space="preserve">
          <source>Measurement tool directory name</source>
          <target state="translated">测量工具目录名</target>
        </trans-unit>
        <trans-unit id="28e896074d31c2da6938ce8b9dd8662ed8369129" translate="yes" xml:space="preserve">
          <source>Measurement(s)</source>
          <target state="translated">Measurement(s)</target>
        </trans-unit>
        <trans-unit id="d404968ea90b07f16774ce75c7978d6ff60962f2" translate="yes" xml:space="preserve">
          <source>Medium</source>
          <target state="translated">Medium</target>
        </trans-unit>
        <trans-unit id="d4bb05883bb5a243cfcc4f9296f5649fd60af7f8" translate="yes" xml:space="preserve">
          <source>Medium mathematical space</source>
          <target state="translated">中等数学空间</target>
        </trans-unit>
        <trans-unit id="a66ec7d3e2375014d1ffe12adf1704c1f323a128" translate="yes" xml:space="preserve">
          <source>Meetei_Mayek</source>
          <target state="translated">Meetei_Mayek</target>
        </trans-unit>
        <trans-unit id="291fdbd8f605e558c302e6b671f37cb0a11631da" translate="yes" xml:space="preserve">
          <source>Megaco and peer protocols are complementary in nature and entirely compatible within the same system. At a system level, Megaco allows for</source>
          <target state="translated">Megaco和对等协议在本质上是互补的,在同一系统中完全兼容。在系统层面,Megaco允许</target>
        </trans-unit>
        <trans-unit id="efb29db4c9a5b8efca98c20c485c0a71a7d66580" translate="yes" xml:space="preserve">
          <source>Megaco encoder behaviour.</source>
          <target state="translated">Megaco编码器行为。</target>
        </trans-unit>
        <trans-unit id="1ab0d5d513da1a6a7bc7432ddbc64c528b364f30" translate="yes" xml:space="preserve">
          <source>Megaco erlang dist compress behaviour.</source>
          <target state="translated">Megaco erlang dist压缩行为。</target>
        </trans-unit>
        <trans-unit id="220d827864f1e91dd8d479ee473263ef26b35de7" translate="yes" xml:space="preserve">
          <source>Megaco is a (master/slave) protocol for control of gateway functions at the edge of the packet network. Examples of this is IP-PSTN trunking gateways and analog line gateways. The main function of Megaco is to allow gateway decomposition into a call agent (call control) part (known as Media Gateway Controller, MGC) - master, and an gateway interface part (known as Media Gateway, MG) - slave. The MG has no call control knowledge and only handle making the connections and simple configurations.</source>
          <target state="translated">Megaco是一种(主/从)协议,用于控制分组网络边缘的网关功能。例如IP-PSTN中继网关和模拟线路网关。Megaco的主要功能是允许网关分解为呼叫代理(呼叫控制)部分(称为媒体网关控制器,MGC)--主站,和网关接口部分(称为媒体网关,MG)--从站。MG没有呼叫控制知识,只负责做连接和简单配置。</target>
        </trans-unit>
        <trans-unit id="5bffe747cacf35d066423541d229ecb49cc0807e" translate="yes" xml:space="preserve">
          <source>Megaco message transformation utility.</source>
          <target state="translated">Megaco信息转换工具。</target>
        </trans-unit>
        <trans-unit id="20993d68c2198a64d2417ac2d87867b327655a8f" translate="yes" xml:space="preserve">
          <source>Megaco transport behaviour.</source>
          <target state="translated">巨蟹座运输行为;</target>
        </trans-unit>
        <trans-unit id="234c693a674eb5d604a026611a56402135865454" translate="yes" xml:space="preserve">
          <source>Megaco/H.248 is a protocol for control of elements in a physically decomposed multimedia gateway, enabling separation of call control from media conversion. A Media Gateway Controller (MGC) controls one or more Media Gateways (MG).</source>
          <target state="translated">Megaco/H.248是一种协议,用于控制物理分解的多媒体网关中的元素,实现呼叫控制与媒体转换的分离。媒体网关控制器(MGC)控制一个或多个媒体网关(MG)。</target>
        </trans-unit>
        <trans-unit id="cda9df8ada294fa5717dc7c1fc6e9914b12f8c01" translate="yes" xml:space="preserve">
          <source>Megaco/H.248 version 1 (RFC3525) updated according to Implementors Guide version 10-13.</source>
          <target state="translated">Megaco/H.248版本1(RFC3525)根据《实施者指南》10-13版更新。</target>
        </trans-unit>
        <trans-unit id="8857c1ee6501c5ec79a912365370d5a6a0f747fc" translate="yes" xml:space="preserve">
          <source>Megaco/H.248 version 2 as defined by draft-ietf-megaco-h248v2-04 updated according to Implementors Guide version 10-13.</source>
          <target state="translated">Megaco/H.248版本2,由draft-ietf-megaco-h248v2-04定义,根据《实施者指南》10-13版本更新。</target>
        </trans-unit>
        <trans-unit id="56058cc7ccdad804c1b70639153c0e96607997f8" translate="yes" xml:space="preserve">
          <source>Megaco/H.248 version 3 as defined by ITU H.248.1 (09/2005).</source>
          <target state="translated">国际电联H.248.1定义的Megaco/H.248版本3(09/2005)。</target>
        </trans-unit>
        <trans-unit id="88287078a76b16499606b0eda112892d7c56b922" translate="yes" xml:space="preserve">
          <source>Membership of an object instance in an MIB view is determined by the following algorithm:</source>
          <target state="translated">MIB视图中对象实例的成员资格由以下算法确定。</target>
        </trans-unit>
        <trans-unit id="30350d30f29ea3b12a784ca65d59e4a1c44504dd" translate="yes" xml:space="preserve">
          <source>Memory allocated must be explicitly freed with a corresponding call to &lt;code&gt;&lt;a href=&quot;#driver_free&quot;&gt;driver_free&lt;/a&gt;&lt;/code&gt; (unless otherwise stated).</source>
          <target state="translated">必须使用对 &lt;code&gt;&lt;a href=&quot;#driver_free&quot;&gt;driver_free&lt;/a&gt;&lt;/code&gt; 的相应调用显式释放分配的内存（除非另有说明）。</target>
        </trans-unit>
        <trans-unit id="e570bc956a4274803362d894f6047828e5106277" translate="yes" xml:space="preserve">
          <source>Memory allocation functions.</source>
          <target state="translated">内存分配功能。</target>
        </trans-unit>
        <trans-unit id="2684c7e649eb37683099bd99b0ac2e74ac12a361" translate="yes" xml:space="preserve">
          <source>Memory allocation information. Equivalent to &lt;code&gt;erlang:memory/0&lt;/code&gt;.</source>
          <target state="translated">内存分配信息。等效于 &lt;code&gt;erlang:memory/0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="158a065a76be26284f9a9200a508e6ac49bd3965" translate="yes" xml:space="preserve">
          <source>Memory allocation information. Equivalent to &lt;code&gt;erlang:memory/1&lt;/code&gt;.</source>
          <target state="translated">内存分配信息。等效于 &lt;code&gt;erlang:memory/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="909293f836f9e597ec4a004c609be9b42bb7b1af" translate="yes" xml:space="preserve">
          <source>Memory allocator system flags have the following syntax: &lt;code&gt;+M&amp;lt;S&amp;gt;&amp;lt;P&amp;gt; &amp;lt;V&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; is a letter identifying a subsystem, &lt;code&gt;&amp;lt;P&amp;gt;&lt;/code&gt; is a parameter, and &lt;code&gt;&amp;lt;V&amp;gt;&lt;/code&gt; is the value to use. The flags can be passed to the Erlang emulator (&lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;) as command-line arguments.</source>
          <target state="translated">内存分配器系统标志具有以下语法： &lt;code&gt;+M&amp;lt;S&amp;gt;&amp;lt;P&amp;gt; &amp;lt;V&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; 是标识子系统的字母， &lt;code&gt;&amp;lt;P&amp;gt;&lt;/code&gt; 是参数，而 &lt;code&gt;&amp;lt;V&amp;gt;&lt;/code&gt; 是要使用的值。可以将这些标志作为命令行参数传递给Erlang仿真器（ &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8dd2eade140452aa8bdce3e4ed57281be8adbbab" translate="yes" xml:space="preserve">
          <source>Memory allocator-specific flags. For more information, see &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">内存分配器特定的标志。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fdb6e5cf15d341e3aa96990976dacd306d089ec3" translate="yes" xml:space="preserve">
          <source>Memory consumption, system limits</source>
          <target state="translated">内存消耗、系统限制</target>
        </trans-unit>
        <trans-unit id="7527155aa02588eea7da969db8693cc9ca0cf4a9" translate="yes" xml:space="preserve">
          <source>Memory types:</source>
          <target state="translated">记忆类型:</target>
        </trans-unit>
        <trans-unit id="1ac17298e965f8785571301bd292200f1c1741e9" translate="yes" xml:space="preserve">
          <source>Memory use for the loaded code, in bytes.</source>
          <target state="translated">加载代码的内存使用情况,单位:字节。</target>
        </trans-unit>
        <trans-unit id="4dd0c06f98123356440797c194d0014596cf4b1f" translate="yes" xml:space="preserve">
          <source>Memory use for the old code, if any.</source>
          <target state="translated">旧代码的内存使用情况(如有)。</target>
        </trans-unit>
        <trans-unit id="2bbb76271791ef8b2e5ac70d40f275e4232f3424" translate="yes" xml:space="preserve">
          <source>Mende_Kikakui</source>
          <target state="translated">Mende_Kikakui</target>
        </trans-unit>
        <trans-unit id="119e8b7d23fe6df42b1eaf06cf2b4d696139b05c" translate="yes" xml:space="preserve">
          <source>Merge the specified PLTs to create the initial PLT. This requires that the PLTs are disjoint (that is, do not have any module appearing in more than one PLT). The PLTs are created in the usual way:</source>
          <target state="translated">合并指定的PLT以创建初始PLT。这要求PLTs是不相干的(也就是说,没有任何模块出现在一个以上的PLT中)。PLTs是以通常的方式创建的。</target>
        </trans-unit>
        <trans-unit id="e3929df6cd4273ec09922ee67ab9ff5aa6b66122" translate="yes" xml:space="preserve">
          <source>Merges source code files and syntax trees to a single syntax tree. This is a file-reading front end to &lt;code&gt;merge_sources/3&lt;/code&gt;. &lt;code&gt;Name&lt;/code&gt; specifies the name of the resulting module - not the name of the output file. &lt;code&gt;Sources&lt;/code&gt; is a list of syntax trees and/or lists of &quot;source code form&quot; syntax trees, each entry representing a module definition. &lt;code&gt;Files&lt;/code&gt; is a list of file names and/or module names of source modules to be read and included. All the input modules must be distinctly named.</source>
          <target state="translated">将源代码文件和语法树合并为一个语法树。这是 &lt;code&gt;merge_sources/3&lt;/code&gt; 的文件读取前端。 &lt;code&gt;Name&lt;/code&gt; 指定结果模块的名称，而不是输出文件的名称。 &lt;code&gt;Sources&lt;/code&gt; 是语法树的列表和/或&amp;ldquo;源代码形式&amp;rdquo;语法树的列表，每个条目代表模块定义。 &lt;code&gt;Files&lt;/code&gt; 是要读取和包含的源模块的文件名和/或模块名的列表。所有输入模块必须明确命名。</target>
        </trans-unit>
        <trans-unit id="914f8309af3ca6cfa2e83d7e921c466e8a40172d" translate="yes" xml:space="preserve">
          <source>Merges source code files to a single file. &lt;code&gt;Name&lt;/code&gt; specifies the name of the resulting module - not the name of the output file. &lt;code&gt;Files&lt;/code&gt; is a list of file names and/or module names of source modules to be read and merged (see &lt;code&gt;merge_files/4&lt;/code&gt; for details). All the input modules must be distinctly named.</source>
          <target state="translated">将源代码文件合并为一个文件。 &lt;code&gt;Name&lt;/code&gt; 指定结果模块的名称，而不是输出文件的名称。 &lt;code&gt;Files&lt;/code&gt; 是要读取和合并的源模块的文件名和/或模块名的列表（有关详细信息，请参见 &lt;code&gt;merge_files/4&lt;/code&gt; ）。所有输入模块必须明确命名。</target>
        </trans-unit>
        <trans-unit id="61ef0f26ed0f675da05d869af4a295417123a3d7" translate="yes" xml:space="preserve">
          <source>Merges syntax trees to a single syntax tree. This is the main code merging &quot;engine&quot;. &lt;code&gt;Name&lt;/code&gt; specifies the name of the resulting module. &lt;code&gt;Sources&lt;/code&gt; is a list of syntax trees of type &lt;code&gt;form_list&lt;/code&gt; and/or lists of &quot;source code form&quot; syntax trees, each entry representing a module definition. All the input modules must be distinctly named.</source>
          <target state="translated">将语法树合并为单个语法树。这是合并&amp;ldquo;引擎&amp;rdquo;的主要代码。 &lt;code&gt;Name&lt;/code&gt; 指定结果模块的名称。 &lt;code&gt;Sources&lt;/code&gt; 是 &lt;code&gt;form_list&lt;/code&gt; 类型的语法树列表和/或&amp;ldquo; source code form&amp;rdquo;语法树列表，每个条目代表模块定义。所有输入模块必须明确命名。</target>
        </trans-unit>
        <trans-unit id="3d2a293b058966cf02ea5fa803aede107a277d1e" translate="yes" xml:space="preserve">
          <source>Merges terms on files. Each input file is assumed to be sorted.</source>
          <target state="translated">合并文件上的术语。假设每个输入文件都是经过排序的。</target>
        </trans-unit>
        <trans-unit id="ca627cc38a16c0db5470a1230525775bd4b5efc4" translate="yes" xml:space="preserve">
          <source>Merges tuples on files. Each input file is assumed to be sorted on key(s).</source>
          <target state="translated">合并文件上的元组。假设每个输入文件都是按键排序的。</target>
        </trans-unit>
        <trans-unit id="6351ca1bc7f6afb34d654f76c66afcef185ec40c" translate="yes" xml:space="preserve">
          <source>Merges two dictionaries, &lt;code&gt;Dict1&lt;/code&gt; and &lt;code&gt;Dict2&lt;/code&gt;, to create a new dictionary. All the &lt;code&gt;Key&lt;/code&gt;-&lt;code&gt;Value&lt;/code&gt; pairs from both dictionaries are included in the new dictionary. If a key occurs in both dictionaries, &lt;code&gt;Fun&lt;/code&gt; is called with the key and both values to return a new value. &lt;code&gt;merge&lt;/code&gt; can be defined as follows, but is faster:</source>
          <target state="translated">合并两个字典 &lt;code&gt;Dict1&lt;/code&gt; 和 &lt;code&gt;Dict2&lt;/code&gt; ，以创建一个新字典。两个词典中的所有&amp;ldquo; &lt;code&gt;Key&lt;/code&gt; - &lt;code&gt;Value&lt;/code&gt; 对都包含在新词典中。如果两个字典中都出现键，则将使用键和两个值调用 &lt;code&gt;Fun&lt;/code&gt; 来返回新值。 &lt;code&gt;merge&lt;/code&gt; 可以定义如下，但速度更快：</target>
        </trans-unit>
        <trans-unit id="d26d2ded712b884fedeee08ada284ef051b3b38a" translate="yes" xml:space="preserve">
          <source>Merges two dictionaries, &lt;code&gt;Orddict1&lt;/code&gt; and &lt;code&gt;Orddict2&lt;/code&gt;, to create a new dictionary. All the &lt;code&gt;Key&lt;/code&gt;-&lt;code&gt;Value&lt;/code&gt; pairs from both dictionaries are included in the new dictionary. If a key occurs in both dictionaries, &lt;code&gt;Fun&lt;/code&gt; is called with the key and both values to return a new value. &lt;code&gt;merge/3&lt;/code&gt; can be defined as follows, but is faster:</source>
          <target state="translated">合并两个字典 &lt;code&gt;Orddict1&lt;/code&gt; 和 &lt;code&gt;Orddict2&lt;/code&gt; ，以创建一个新字典。两个词典中的所有&amp;ldquo; &lt;code&gt;Key&lt;/code&gt; - &lt;code&gt;Value&lt;/code&gt; 对都包含在新词典中。如果两个字典中都出现键，则将使用键和两个值调用 &lt;code&gt;Fun&lt;/code&gt; 来返回新值。可以将 &lt;code&gt;merge/3&lt;/code&gt; 定义如下，但速度更快：</target>
        </trans-unit>
        <trans-unit id="ec7e01625093b63d2959063dd1a662a878ea5c0e" translate="yes" xml:space="preserve">
          <source>Merges two maps into a single map &lt;code&gt;Map3&lt;/code&gt;. If two keys exist in both maps, the value in &lt;code&gt;Map1&lt;/code&gt; is superseded by the value in &lt;code&gt;Map2&lt;/code&gt;.</source>
          <target state="translated">将两个地图合并为一个地图 &lt;code&gt;Map3&lt;/code&gt; 。如果在这两个图中存在两个键，在价值 &lt;code&gt;Map1&lt;/code&gt; 由值取代 &lt;code&gt;Map2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6735763c165e3286d74b4273c933f33e3f5ec752" translate="yes" xml:space="preserve">
          <source>Merging different versions of the schema table does not always require the cookies to be the same. If the storage type of the schema table is &lt;code&gt;disc_copies&lt;/code&gt;, the cookie is immutable, and all other &lt;code&gt;db_nodes&lt;/code&gt; must have the same cookie. When the schema is stored as type &lt;code&gt;ram_copies&lt;/code&gt;, its cookie can be replaced with a cookie from another node (&lt;code&gt;ram_copies&lt;/code&gt; or &lt;code&gt;disc_copies&lt;/code&gt;). The cookie replacement (during merge of the schema table definition) is performed each time a RAM node connects to another node.</source>
          <target state="translated">合并不同版本的架构表并不总是要求cookie是相同的。如果模式表的存储类型为 &lt;code&gt;disc_copies&lt;/code&gt; ，则该cookie是不可变的，并且所有其他 &lt;code&gt;db_nodes&lt;/code&gt; 必须具有相同的cookie。当模式存储为 &lt;code&gt;ram_copies&lt;/code&gt; 类型时，其cookie可替换为另一个节点（ &lt;code&gt;ram_copies&lt;/code&gt; 或 &lt;code&gt;disc_copies&lt;/code&gt; ）中的cookie 。每当RAM节点连接到另一个节点时，就会执行cookie替换（在合并模式表定义期间）。</target>
        </trans-unit>
        <trans-unit id="41b5e66fa06088a4b56fe703bb862a285dff3ab5" translate="yes" xml:space="preserve">
          <source>Merl can only parse a fragment of text if it follows the basic syntactical rules of Erlang. In most places, a normal Erlang variable can be used as metavariable, for example:</source>
          <target state="translated">Merl只有在遵循Erlang的基本语法规则的情况下,才能解析一个文本片段。在大多数地方,普通的Erlang变量可以作为元变量使用,例如。</target>
        </trans-unit>
        <trans-unit id="fad43e700acf724fbc03a57e905d1e33999d5a95" translate="yes" xml:space="preserve">
          <source>Meroitic_Cursive</source>
          <target state="translated">Meroitic_Cursive</target>
        </trans-unit>
        <trans-unit id="16256e81ed15ae584494444b4607752969d09a87" translate="yes" xml:space="preserve">
          <source>Meroitic_Hieroglyphs</source>
          <target state="translated">Meroitic_Hieroglyphs</target>
        </trans-unit>
        <trans-unit id="0d77c6f0a440925729997c58732eb390465bad0a" translate="yes" xml:space="preserve">
          <source>Message Processing and Dispatch module for the SNMP agent</source>
          <target state="translated">SNMP代理的消息处理和发送模块。</target>
        </trans-unit>
        <trans-unit id="834a3b3a12d9955dd19120adc9ef57807900ee6d" translate="yes" xml:space="preserve">
          <source>Message Processing and Dispatch module for the SNMP manager</source>
          <target state="translated">SNMP管理器的消息处理和发送模块。</target>
        </trans-unit>
        <trans-unit id="dfb051fb0d4beb2aa1f14d08e0e4d39de55bd026" translate="yes" xml:space="preserve">
          <source>Message Transformation</source>
          <target state="translated">转化信息</target>
        </trans-unit>
        <trans-unit id="79df93b3eaeb4cccfb42f6840f1b4d449096cc8e" translate="yes" xml:space="preserve">
          <source>Message authentication code</source>
          <target state="translated">信息验证码</target>
        </trans-unit>
        <trans-unit id="c6d065b029fde73824807bcb7a4f88522968466d" translate="yes" xml:space="preserve">
          <source>Message errors are detected remotely on the other side of the protocol. And you probably don't want to reply to it, but it may indicate that you have outstanding transactions that not will get any response (request -&amp;gt; reply; reply -&amp;gt; ack).</source>
          <target state="translated">在协议的另一端可以远程检测到消息错误。您可能不想答复它，但它可能表明您有未得到任何响应的未完成事务（请求-&amp;gt;答复；答复-&amp;gt; ack）。</target>
        </trans-unit>
        <trans-unit id="19842f503704a8912fdf5969e80cd251a7b79c11" translate="yes" xml:space="preserve">
          <source>Message package file</source>
          <target state="translated">信息包文件</target>
        </trans-unit>
        <trans-unit id="03bf9094ba44ce8eb3a756071ecbb6363ddf4c1c" translate="yes" xml:space="preserve">
          <source>Message reception detects 5001, 5004, 5005, 5008, 5009, 5010, 5011, 5014, 5015, and 5017 errors. It ignores 5013 errors at the admonition of sections 3 and 4.1.</source>
          <target state="translated">信息接收检测5001、5004、5005、5008、5009、5010、5011、5014、5015和5017错误。在第3节和4.1节的告诫下,它忽略5013错误。</target>
        </trans-unit>
        <trans-unit id="2297ecf9967e2341ba11a1ac6137bfeff96d6f16" translate="yes" xml:space="preserve">
          <source>Message records</source>
          <target state="translated">留言记录</target>
        </trans-unit>
        <trans-unit id="31deece58687e26fd50c8809af9d97cfb48aa92a" translate="yes" xml:space="preserve">
          <source>Message sending is asynchronous and safe, the message is guaranteed to eventually reach the recipient, provided that the recipient exists.</source>
          <target state="translated">消息发送是异步的、安全的,只要收件人存在,就能保证消息最终到达收件人。</target>
        </trans-unit>
        <trans-unit id="a7c63e918af7eff798c82c0e88aefb50d97f2578" translate="yes" xml:space="preserve">
          <source>Message size at which SCTP fragmentation occurs</source>
          <target state="translated">SCTP碎片发生时的信息大小</target>
        </trans-unit>
        <trans-unit id="7bf49996d9fb115e00764acfda8430d93e84eb42" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_from&quot;&gt;return_from&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">消息标签： &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_from&quot;&gt;return_from&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac347e4302154cf539a13312237b96cc114cdfa9" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_call&quot;&gt;call&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_from&quot;&gt;return_from&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_to&quot;&gt;return_to&lt;/a&gt;&lt;/code&gt;. Or rather, the absence of.</source>
          <target state="translated">消息标签： &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_from&quot;&gt;return_from&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_to&quot;&gt;return_to&lt;/a&gt;&lt;/code&gt; 。或更确切地说，没有。</target>
        </trans-unit>
        <trans-unit id="861b1c2d1e66807add82f45f362fb827341c6bc5" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_gc_minor_start&quot;&gt;gc_minor_start&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_gc_max_heap_size&quot;&gt;gc_max_heap_size&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_gc_minor_end&quot;&gt;gc_minor_end&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">消息标签： &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_gc_minor_start&quot;&gt;gc_minor_start&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_gc_max_heap_size&quot;&gt;gc_max_heap_size&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_gc_minor_end&quot;&gt;gc_minor_end&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64249446e1241b8f9d4c261cdb93987c31f20de2" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_in_exiting_proc&quot;&gt;in_exiting&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_exiting_proc&quot;&gt;out_exiting&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_exited_proc&quot;&gt;out_exited&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">消息标签： &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_in_exiting_proc&quot;&gt;in_exiting&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_exiting_proc&quot;&gt;out_exiting&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_exited_proc&quot;&gt;out_exited&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d456b159601bfe4ba88f4b3b670553e61afb6b4d" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_in_port&quot;&gt;in&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_port&quot;&gt;out&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">消息变量： &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_in_port&quot;&gt;in&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_port&quot;&gt;out&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="498dd804ab57af76daece1cf044904cff1eb753f" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_in_proc&quot;&gt;in&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_proc&quot;&gt;out&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">消息变量： &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_in_proc&quot;&gt;in&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_out_proc&quot;&gt;out&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fef22350b8b577df133e3cb6cedbf6dc60aaa87c" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_closed&quot;&gt;closed&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_register&quot;&gt;register&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_unregister&quot;&gt;unregister&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_linked&quot;&gt;getting_linked&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_unlinked&quot;&gt;getting_unlinked&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">消息标记： &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_closed&quot;&gt;closed&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_register&quot;&gt;register&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_unregister&quot;&gt;unregister&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_linked&quot;&gt;getting_linked&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_unlinked&quot;&gt;getting_unlinked&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d00e4b40aebde71fd90f9fddfebc8612e44ddb8f" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_receive&quot;&gt;'receive'&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">消息标签： &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_receive&quot;&gt;'receive'&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef5f53652270bb984920cbfaaa3925022a3b6e1c" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_to&quot;&gt;return_to&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">消息标签： &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_return_to&quot;&gt;return_to&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7160c31113f5c016d9d063ac1996aecb61589a8a" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_send&quot;&gt;send&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_send_to_non_existing_process&quot;&gt;send_to_non_existing_process&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">消息标签： &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_send&quot;&gt;send&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_send_to_non_existing_process&quot;&gt;send_to_non_existing_process&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ff3b1c2d91914176c2ace60ad5ed8c3dbe8dfb0" translate="yes" xml:space="preserve">
          <source>Message tags: &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_spawn&quot;&gt;spawn&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_spawned&quot;&gt;spawned&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_register&quot;&gt;register&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_unregister&quot;&gt;unregister&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_link&quot;&gt;link&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_linked&quot;&gt;getting_linked&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_unlinked&quot;&gt;getting_unlinked&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">消息标签： &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_spawn&quot;&gt;spawn&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_spawned&quot;&gt;spawned&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_register&quot;&gt;register&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_unregister&quot;&gt;unregister&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_link&quot;&gt;link&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_linked&quot;&gt;getting_linked&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#trace_3_trace_messages_getting_unlinked&quot;&gt;getting_unlinked&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c83c1bde9d4d8aa8318863a5d51aa34ce5bfc795" translate="yes" xml:space="preserve">
          <source>Messages are delivered on a per line basis. Each line (delimited by the OS-dependent newline sequence) is delivered in a single message. The message data format is &lt;code&gt;{Flag, Line}&lt;/code&gt;, where &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;eol&lt;/code&gt; or &lt;code&gt;noeol&lt;/code&gt;, and &lt;code&gt;Line&lt;/code&gt; is the data delivered (without the newline sequence).</source>
          <target state="translated">消息是按行传递的。每行（由与OS有关的换行符序列分隔）在一条消息中传递。消息数据格式为 &lt;code&gt;{Flag, Line}&lt;/code&gt; ，其中 &lt;code&gt;Flag&lt;/code&gt; 为 &lt;code&gt;eol&lt;/code&gt; 或 &lt;code&gt;noeol&lt;/code&gt; ，而 &lt;code&gt;Line&lt;/code&gt; 为传递的数据（不包含换行符序列）。</target>
        </trans-unit>
        <trans-unit id="4efc9f43ab150329eedfc4f946099f0a5f3094d9" translate="yes" xml:space="preserve">
          <source>Messages are preceded by their length, sent in &lt;code&gt;N&lt;/code&gt; bytes, with the most significant byte first. The valid values for &lt;code&gt;N&lt;/code&gt; are 1, 2, and 4.</source>
          <target state="translated">消息以其长度开头，以 &lt;code&gt;N&lt;/code&gt; 字节发送，最高有效字节在前。 &lt;code&gt;N&lt;/code&gt; 的有效值为1、2和4。</target>
        </trans-unit>
        <trans-unit id="6b07457b9a14b5fa6fa1cbfe7c24fba2d20941a5" translate="yes" xml:space="preserve">
          <source>Messages are sent to this process in the format &lt;code&gt;{http, ReplyInfo}&lt;/code&gt;.</source>
          <target state="translated">消息以 &lt;code&gt;{http, ReplyInfo}&lt;/code&gt; 格式发送到此进程。</target>
        </trans-unit>
        <trans-unit id="dea0176313f64667ac747bcda6d934ed85bcd005" translate="yes" xml:space="preserve">
          <source>Messages between Erlang processes are simply valid Erlang terms. That is, they can be lists, tuples, integers, atoms, pids, and so on.</source>
          <target state="translated">Erlang进程之间的消息只是有效的Erlang术语。也就是说,它们可以是列表、元组、整数、原子、pids等等。</target>
        </trans-unit>
        <trans-unit id="1ba3a1c108d58aee0ff81fd9ec2d1208708c9bdb" translate="yes" xml:space="preserve">
          <source>Messages encoded before the connection has been set up may still use the &lt;code&gt;SEND&lt;/code&gt; control message. However, once a &lt;code&gt;SEND_SENDER&lt;/code&gt; or &lt;code&gt;SEND_SENDER_TT&lt;/code&gt; control message has been sent, no more &lt;code&gt;SEND&lt;/code&gt; control messages will be sent in the same direction on the connection.</source>
          <target state="translated">在建立连接之前编码的消息仍可以使用 &lt;code&gt;SEND&lt;/code&gt; 控制消息。但是，一旦发送了 &lt;code&gt;SEND_SENDER&lt;/code&gt; 或 &lt;code&gt;SEND_SENDER_TT&lt;/code&gt; 控制消息，就不会再以相同方向在连接上发送 &lt;code&gt;SEND&lt;/code&gt; 控制消息。</target>
        </trans-unit>
        <trans-unit id="21f2cc5097a001d22180191c6222e6d580784485" translate="yes" xml:space="preserve">
          <source>Messages encoded before the connection has been set up may still use the &lt;code&gt;SEND_TT&lt;/code&gt; control message. However, once a &lt;code&gt;SEND_SENDER&lt;/code&gt; or &lt;code&gt;SEND_SENDER_TT&lt;/code&gt; control message has been sent, no more &lt;code&gt;SEND_TT&lt;/code&gt; control messages will be sent in the same direction on the connection.</source>
          <target state="translated">在建立连接之前编码的消息仍可以使用 &lt;code&gt;SEND_TT&lt;/code&gt; 控制消息。但是，一旦发送了 &lt;code&gt;SEND_SENDER&lt;/code&gt; 或 &lt;code&gt;SEND_SENDER_TT&lt;/code&gt; 控制消息，就不会再以相同方向在连接上发送 &lt;code&gt;SEND_TT&lt;/code&gt; 控制消息。</target>
        </trans-unit>
        <trans-unit id="b450d9a68961ebef8efd8c7dece1b02f8d8dab97" translate="yes" xml:space="preserve">
          <source>Messages received from the operating system results in an user defined callback function being called. This function can do whatever filtering and formatting is necessary and then deploy any type of logging suitable for the user's application.</source>
          <target state="translated">从操作系统接收到的消息会导致一个用户定义的回调函数被调用。这个函数可以进行任何必要的过滤和格式化,然后部署适合用户应用的任何类型的日志记录。</target>
        </trans-unit>
        <trans-unit id="7a53365e992adfd42db65c7720bf07ff4ac1814b" translate="yes" xml:space="preserve">
          <source>Messing up for subsequent test cases:</source>
          <target state="translated">为后续的测试用例添乱。</target>
        </trans-unit>
        <trans-unit id="30041e23a0f72a119313b16f9b3d4df540137e77" translate="yes" xml:space="preserve">
          <source>Meta-tracing traces all processes and does not care about the process trace flags set by &lt;code&gt;erlang:trace/3&lt;/code&gt;, the trace flags are instead fixed to &lt;code&gt;[call, timestamp]&lt;/code&gt;.</source>
          <target state="translated">元跟踪将跟踪所有进程，而不关心 &lt;code&gt;erlang:trace/3&lt;/code&gt; 设置的进程跟踪标志，而是将跟踪标志固定为 &lt;code&gt;[call, timestamp]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d674c23267ff3e893a9e1474fed16ac7f558c49" translate="yes" xml:space="preserve">
          <source>Metadata associated with one specific log event is given as the last parameter to the log macro or Logger API function when the event is issued. For example:</source>
          <target state="translated">与某一特定日志事件相关联的元数据在事件发布时作为日志宏或日志记录器 API 函数的最后一个参数给出。例如:</target>
        </trans-unit>
        <trans-unit id="885e65968ef7efdba81656ad741bbd6682841ebf" translate="yes" xml:space="preserve">
          <source>Metadata contains additional data associated with a log message. Logger inserts some metadata fields by default, and the client can add custom metadata in two different ways:</source>
          <target state="translated">元数据包含与日志消息相关联的附加数据。Logger默认插入一些元数据字段,客户端可以通过两种不同的方式添加自定义元数据。</target>
        </trans-unit>
        <trans-unit id="a1e44a13044d8e9cd06618d7ce5207e1fbeec00f" translate="yes" xml:space="preserve">
          <source>Metadata for the log event.</source>
          <target state="translated">日志事件的元数据。</target>
        </trans-unit>
        <trans-unit id="4342240162e294c2bc03db17fdee5ddbc87876d8" translate="yes" xml:space="preserve">
          <source>Metaprogramming in Erlang.</source>
          <target state="translated">Erlang中的元编程。</target>
        </trans-unit>
        <trans-unit id="87ced016c5bb1aba95f8f208a0c630b0abd89fd8" translate="yes" xml:space="preserve">
          <source>Metaprogramming in Erlang. Merl is a more user friendly interface to the &lt;code&gt;erl_syntax&lt;/code&gt; module, making it easy both to build new ASTs from scratch and to match and decompose existing ASTs. For details that are outside the scope of Merl itself, please see the documentation of &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang中的元编程。Merl是 &lt;code&gt;erl_syntax&lt;/code&gt; 模块的一个更加用户友好的界面，使从头开始构建新AST以及匹配和分解现有AST变得容易。有关Merl本身范围之外的详细信息，请参阅 &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="cc7e0e02c16756d9acee15cd9d7a7473daeb068d" translate="yes" xml:space="preserve">
          <source>Miao</source>
          <target state="translated">Miao</target>
        </trans-unit>
        <trans-unit id="1ead8ccfae61c22af5dea71102bcf319bd3b337a" translate="yes" xml:space="preserve">
          <source>Micka&amp;euml;l R&amp;eacute;mond mickael.remond@process-one.net</source>
          <target state="translated">Micka&amp;euml;lR&amp;eacute;mondmickael.remond@process-one.net</target>
        </trans-unit>
        <trans-unit id="e3161feceeebbf2efa94b967c31c3a533e827d4e" translate="yes" xml:space="preserve">
          <source>Micka&amp;euml;l R&amp;eacute;mond mickael.remond@process-one.net Richard Carlsson carlsson.richard@gmail.com</source>
          <target state="translated">Micka&amp;euml;lR&amp;eacute;mondmickael.remond@process-one.net Richard Carlsson carlsson.richard@gmail.com</target>
        </trans-unit>
        <trans-unit id="c51b97dfe72702f7a4db88668d6bbc27ffd18957" translate="yes" xml:space="preserve">
          <source>Microseconds</source>
          <target state="translated">Microseconds</target>
        </trans-unit>
        <trans-unit id="ad4d37efa374335ef5074617d100776dbcc4796b" translate="yes" xml:space="preserve">
          <source>Microsofts Windows SDK version 8.1 (corresponding to VC++ 12.0 and Visual Studio 2013). You'll find it here:</source>
          <target state="translated">Microsofts Windows SDK 8.1版本(对应VC++12.0和Visual Studio 2013)。你可以在这里找到它。</target>
        </trans-unit>
        <trans-unit id="5fe50fa08740afc3a20f9d3d442ba75955fee423" translate="yes" xml:space="preserve">
          <source>Microstate accounting can be used to measure how much time the Erlang runtime system spends doing various tasks. It is designed to be as lightweight as possible, but some overhead exists when this is enabled. Microstate accounting is meant to be a profiling tool to help finding performance bottlenecks. To &lt;code&gt;start&lt;/code&gt;/&lt;code&gt;stop&lt;/code&gt;/&lt;code&gt;reset&lt;/code&gt; microstate accounting, use system flag &lt;code&gt;&lt;a href=&quot;#system_flag_microstate_accounting&quot;&gt;microstate_accounting&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">微状态记帐可用于衡量Erlang运行时系统花在执行各种任务上的时间。它被设计为尽可能轻巧，但是启用它时会存在一些开销。微状态记帐本来是一个有助于发现性能瓶颈的性能分析工具。要 &lt;code&gt;start&lt;/code&gt; / &lt;code&gt;stop&lt;/code&gt; / &lt;code&gt;reset&lt;/code&gt; 微状态计费，请使用系统标志 &lt;code&gt;&lt;a href=&quot;#system_flag_microstate_accounting&quot;&gt;microstate_accounting&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5bc93878c3ba17340102ebf0f740f8c3302add0b" translate="yes" xml:space="preserve">
          <source>Milliseconds</source>
          <target state="translated">Milliseconds</target>
        </trans-unit>
        <trans-unit id="fb85391c2c8505ba20e51e3d8c6b33571699f58c" translate="yes" xml:space="preserve">
          <source>Min detail level deactivates tracing of calls to &lt;code&gt;et:trace_me/4,5&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;et:trace_me/4,5&lt;/code&gt; 详细信息级别会停用对et：trace_me / 4,5的调用的跟踪</target>
        </trans-unit>
        <trans-unit id="68daf61d5874aaae0cf757e3faf2f324a6515679" translate="yes" xml:space="preserve">
          <source>MinBinVHeapSize :: integer() &amp;gt;= 1}</source>
          <target state="translated">MinBinVHeapSize :: integer（）&amp;gt; = 1}</target>
        </trans-unit>
        <trans-unit id="4fed7661f4d42301d68ec8563e610bd36ddbbfe8" translate="yes" xml:space="preserve">
          <source>MinHeapSize :: integer() &amp;gt;= 1}</source>
          <target state="translated">MinHeapSize :: integer（）&amp;gt; = 1}</target>
        </trans-unit>
        <trans-unit id="f25a88ac3eb732d57dc4ba0d3e990489173fb9aa" translate="yes" xml:space="preserve">
          <source>Minimizes the representation of all entries in the list. This is equivalent to &lt;code&gt;[property(P) || P &amp;lt;- ListIn]&lt;/code&gt;.</source>
          <target state="translated">最小化列表中所有条目的表示。这等效于 &lt;code&gt;[property(P) || P &amp;lt;- ListIn]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32e23d465d0629b84d76e5f09fb507ede0cb1461" translate="yes" xml:space="preserve">
          <source>Miscellaneous flags:</source>
          <target state="translated">杂旗。</target>
        </trans-unit>
        <trans-unit id="3e70a7515b00e7c226a15edab218fd1f4dd573e0" translate="yes" xml:space="preserve">
          <source>Miscellaneous utility functions to be used when implementing Erlang web server API modules.</source>
          <target state="translated">实现Erlang web服务器API模块时要用到的各种实用函数。</target>
        </trans-unit>
        <trans-unit id="e28720b55817fffaed736aa55d8047afa4cf1137" translate="yes" xml:space="preserve">
          <source>Missing permission for reading the file or searching one of the parent directories.</source>
          <target state="translated">读取文件或搜索父目录之一的权限缺失。</target>
        </trans-unit>
        <trans-unit id="7aa38c37efdf79a5acef9cef7e555976f20e2ad9" translate="yes" xml:space="preserve">
          <source>Missing permission for reading the file, or for searching one of the parent directories.</source>
          <target state="translated">读取文件或搜索父目录之一的权限缺失。</target>
        </trans-unit>
        <trans-unit id="9efd7c6d83c7981adb874ec7297e295c58042b1f" translate="yes" xml:space="preserve">
          <source>Missing permission for the directory or one of its parents.</source>
          <target state="translated">该目录或其父目录之一的权限缺失。</target>
        </trans-unit>
        <trans-unit id="3baa40bad1885eea32466c0be3b003163935955e" translate="yes" xml:space="preserve">
          <source>Missing permission for the file or one of its parents.</source>
          <target state="translated">缺少文件或其父母之一的权限。</target>
        </trans-unit>
        <trans-unit id="da94f56d96d2d085bea8dd51d423535445ba4d6f" translate="yes" xml:space="preserve">
          <source>Missing permission for writing the file or searching one of the parent directories.</source>
          <target state="translated">写文件或搜索父目录之一的权限缺失。</target>
        </trans-unit>
        <trans-unit id="061e8bb20890cbf13271d93b5804b980c9a0f90b" translate="yes" xml:space="preserve">
          <source>Missing read or write permissions for the parent directories of &lt;code&gt;Existing&lt;/code&gt; or &lt;code&gt;New&lt;/code&gt;.</source>
          <target state="translated">缺少对 &lt;code&gt;Existing&lt;/code&gt; 或 &lt;code&gt;New&lt;/code&gt; 的父目录的读写权限。</target>
        </trans-unit>
        <trans-unit id="6b9b56e3be8c9130a50f7b4b55f58db626553ba0" translate="yes" xml:space="preserve">
          <source>Missing read or write permissions for the parent directories of &lt;code&gt;Source&lt;/code&gt; or &lt;code&gt;Destination&lt;/code&gt;. On some platforms, this error is given if either &lt;code&gt;Source&lt;/code&gt; or &lt;code&gt;Destination&lt;/code&gt; is open.</source>
          <target state="translated">缺少对 &lt;code&gt;Source&lt;/code&gt; 或 &lt;code&gt;Destination&lt;/code&gt; 的父目录的读写权限。在某些平台上，如果&amp;ldquo; &lt;code&gt;Source&lt;/code&gt; 或&amp;ldquo; &lt;code&gt;Destination&lt;/code&gt; 处于打开状态，则会出现此错误。</target>
        </trans-unit>
        <trans-unit id="28336423496ccaf52c7936f6b41a6f9ad88604eb" translate="yes" xml:space="preserve">
          <source>Missing read permission for one of the parents of the current directory.</source>
          <target state="translated">缺少当前目录的父目录之一的读取权限。</target>
        </trans-unit>
        <trans-unit id="d5005e02795d55eb02a3f6a112157b99bce1e935" translate="yes" xml:space="preserve">
          <source>Missing search or write permissions for &lt;code&gt;Dir&lt;/code&gt; or one of its parent directories.</source>
          <target state="translated">缺少 &lt;code&gt;Dir&lt;/code&gt; 或其父目录之一的搜索或写入权限。</target>
        </trans-unit>
        <trans-unit id="dc45e80a5b65727123e0ebc0703fe14768293b68" translate="yes" xml:space="preserve">
          <source>Missing search or write permissions for the parent directories of &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">缺少 &lt;code&gt;Dir&lt;/code&gt; 父目录的搜索或写入权限。</target>
        </trans-unit>
        <trans-unit id="dc1c55c040e5f0948f15231f73c916f3526d9f6e" translate="yes" xml:space="preserve">
          <source>Missing search permission for one of the parent directories of the file.</source>
          <target state="translated">文件的一个父目录缺少搜索权限。</target>
        </trans-unit>
        <trans-unit id="3450bbc34d200da9fb5b92b5c6f6571a71324a0a" translate="yes" xml:space="preserve">
          <source>Mnesia As Authentication Database</source>
          <target state="translated">Mnesia作为认证数据库</target>
        </trans-unit>
        <trans-unit id="3e14767dc1dedaea0f193b494b8754d578aec896" translate="yes" xml:space="preserve">
          <source>Mnesia contains the following features that combine to produce a fault-tolerant, distributed DBMS written in Erlang:</source>
          <target state="translated">Mnesia包含了以下功能,这些功能结合在一起产生了一个用Erlang编写的容错、分布式DBMS。</target>
        </trans-unit>
        <trans-unit id="2d270fde8f4afa30deacf2e5ac64258dc95380f4" translate="yes" xml:space="preserve">
          <source>Mnesia forwards calls to the following functions:</source>
          <target state="translated">Mnesia将调用转发到以下功能:</target>
        </trans-unit>
        <trans-unit id="e89dea5925db30b38ca5a4a01818590924fb2279" translate="yes" xml:space="preserve">
          <source>Mnesia has no special counter records. However, records of the form &lt;code&gt;{Tab, Key, Integer}&lt;/code&gt; can be used as (possibly disc-resident) counters when &lt;code&gt;Tab&lt;/code&gt; is a &lt;code&gt;set&lt;/code&gt;. This function updates a counter with a positive or negative number. However, counters can never become less than zero. There are two significant differences between this function and the action of first reading the record, performing the arithmetics, and then writing the record:</source>
          <target state="translated">Mnesia没有特殊的柜台记录。但是，当 &lt;code&gt;Tab&lt;/code&gt; 为 &lt;code&gt;set&lt;/code&gt; 时 &lt;code&gt;{Tab, Key, Integer}&lt;/code&gt; 格式为{Tab，Key，Integer}的记录可用作（可能位于光盘上）计数器。此功能使用正数或负数更新计数器。但是，计数器永远不会小于零。此功能与首先读取记录，执行算术然后写入记录的操作之间有两个重要区别：</target>
        </trans-unit>
        <trans-unit id="2a2c5988b423c05d899728a690476666f426fc19" translate="yes" xml:space="preserve">
          <source>Mnesia is a multiuser distributed DBMS specially made for industrial telecommunications applications written in Erlang, which is also the intended target language. Mnesia tries to address all the data management issues required for typical telecommunications systems. It has a number of features that are not normally found in traditional databases.</source>
          <target state="translated">Mnesia是一个多用户分布式DBMS,专门为工业电信应用而制作,用Erlang编写,Erlang也是预定的目标语言,Mnesia试图解决典型电信系统所需的所有数据管理问题。Mnesia试图解决典型电信系统所需的所有数据管理问题。它有许多传统数据库中通常没有的功能。</target>
        </trans-unit>
        <trans-unit id="a0af7e030b61efa3af7bcba4659fb088190690f3" translate="yes" xml:space="preserve">
          <source>Mnesia is also interesting because of its tight coupling to Erlang, thus almost turning Erlang into a database programming language. This has many benefits, the foremost is that the impedance mismatch between the data format used by the DBMS and the data format used by the programming language, which is used to manipulate the data, completely disappears.</source>
          <target state="translated">Mnesia的有趣之处还在于它与Erlang的紧密耦合,从而几乎把Erlang变成了一种数据库编程语言。这样做有很多好处,最主要的是DBMS使用的数据格式和编程语言使用的数据格式(用于操作数据)之间的阻抗不匹配完全消失了。</target>
        </trans-unit>
        <trans-unit id="44aa259738f2f02d017fee9119158e2bcbe7c0c2" translate="yes" xml:space="preserve">
          <source>Mnesia is designed with the typical data management problems of telecommunications applications in mind. This sets Mnesia apart from most other DBMS. Hence Mnesia combines many concepts found in traditional databases such as transactions and queries with concepts found in data management systems for telecommunications applications, for example:</source>
          <target state="translated">Mnesia的设计考虑到了电信应用的典型数据管理问题。这使得Mnesia与大多数其他DBMS不同。因此,Mnesia将传统数据库中的许多概念(如事务和查询)与电信应用的数据管理系统中的概念结合起来,例如:</target>
        </trans-unit>
        <trans-unit id="df09d370f13b24dc32d72bd352185aa6d3460032" translate="yes" xml:space="preserve">
          <source>Mnesia is implemented in, and tightly connected to Erlang. It provides the functionality that is necessary for the implementation of fault tolerant telecommunications systems.</source>
          <target state="translated">Mnesia是用Erlang实现的,并与Erlang紧密相连。它提供了实现容错电信系统所需的功能。</target>
        </trans-unit>
        <trans-unit id="fc6fa382209f2c0fc7fcb32177c787306e164f05" translate="yes" xml:space="preserve">
          <source>Mnesia is not as appropriate with the following types of applications:</source>
          <target state="translated">Mnesia不适合用于以下类型的应用:</target>
        </trans-unit>
        <trans-unit id="845e3498f5ba4596f8fba48d33cc6a74bac4d6f0" translate="yes" xml:space="preserve">
          <source>Mnesia is started on a node. &lt;code&gt;Node&lt;/code&gt; is the node name. By default this event is ignored.</source>
          <target state="translated">Mnesia在节点上启动。 &lt;code&gt;Node&lt;/code&gt; 是节点名称。默认情况下，将忽略此事件。</target>
        </trans-unit>
        <trans-unit id="b3e1fa53e8464658bfcdc7fbdecb69fa1444e78e" translate="yes" xml:space="preserve">
          <source>Mnesia is stopped on a node. &lt;code&gt;Node&lt;/code&gt; is the node name. By default this event is ignored.</source>
          <target state="translated">Mnesia在节点上停止。 &lt;code&gt;Node&lt;/code&gt; 是节点名称。默认情况下，将忽略此事件。</target>
        </trans-unit>
        <trans-unit id="7c1dcaece45ef92fbe42e06c5252abce132af739" translate="yes" xml:space="preserve">
          <source>Mnesia reads the following application configuration parameters:</source>
          <target state="translated">Mnesia读取以下应用配置参数。</target>
        </trans-unit>
        <trans-unit id="6d914dda751476720c28b61ae3bd0ff8b42cfeb7" translate="yes" xml:space="preserve">
          <source>Mode = &lt;code&gt;active | passive&lt;/code&gt;</source>
          <target state="translated">模式= &lt;code&gt;active | passive&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99f50e7814fad5179000cd91fa4e8ee4f72c44ef" translate="yes" xml:space="preserve">
          <source>Mode for running multiple independent test sessions in parallel with central control and configuration</source>
          <target state="translated">在中央控制和配置的同时运行多个独立测试会话的模式</target>
        </trans-unit>
        <trans-unit id="2620d89dab477718fe6a6ecadb48be52562f1585" translate="yes" xml:space="preserve">
          <source>Modi</source>
          <target state="translated">Modi</target>
        </trans-unit>
        <trans-unit id="347a94d0029aefe56171fcf91033436e5c682c85" translate="yes" xml:space="preserve">
          <source>Modified timing affects the following:</source>
          <target state="translated">修改后的时间会影响以下方面:</target>
        </trans-unit>
        <trans-unit id="bad23ea5529c0f8c6c8d290e83637676c692c2dd" translate="yes" xml:space="preserve">
          <source>Modifier letter</source>
          <target state="translated">改信</target>
        </trans-unit>
        <trans-unit id="253879158d55c56d709e1481da82674291cad63a" translate="yes" xml:space="preserve">
          <source>Modifier symbol</source>
          <target state="translated">更改符号</target>
        </trans-unit>
        <trans-unit id="a0cfb5739548a4dc910c1db16690c1ef42b6dcf6" translate="yes" xml:space="preserve">
          <source>Modifies the &lt;code&gt;erl_parse&lt;/code&gt; tree &lt;code&gt;Abstr&lt;/code&gt; by applying &lt;code&gt;Fun&lt;/code&gt; on each collection of annotations of the nodes of the &lt;code&gt;erl_parse&lt;/code&gt; tree, while at the same time updating an accumulator. The first call to &lt;code&gt;Fun&lt;/code&gt; has &lt;code&gt;AccIn&lt;/code&gt; as second argument, the returned accumulator &lt;code&gt;AccOut&lt;/code&gt; is passed to the next call, and so on. The modified &lt;code&gt;erl_parse&lt;/code&gt; tree and the final value of the accumulator are returned. The &lt;code&gt;erl_parse&lt;/code&gt; tree is traversed in a depth-first, left-to-right fashion.</source>
          <target state="translated">修改 &lt;code&gt;erl_parse&lt;/code&gt; 树 &lt;code&gt;Abstr&lt;/code&gt; 应用 &lt;code&gt;Fun&lt;/code&gt; 上的节点的注释的每个集合 &lt;code&gt;erl_parse&lt;/code&gt; 树，而在同一时间更新累加器。第一个通话 &lt;code&gt;Fun&lt;/code&gt; 有 &lt;code&gt;AccIn&lt;/code&gt; 作为第二个参数，蓄能器返回的 &lt;code&gt;AccOut&lt;/code&gt; 被传递到下一个电话，等等。返回修改后的 &lt;code&gt;erl_parse&lt;/code&gt; 树和累加器的最终值。该 &lt;code&gt;erl_parse&lt;/code&gt; 树的深度优先，左到右的方式运行。</target>
        </trans-unit>
        <trans-unit id="ada6b07489b4caa86b644d594e210d3d7df73a75" translate="yes" xml:space="preserve">
          <source>Modifies the &lt;code&gt;erl_parse&lt;/code&gt; tree &lt;code&gt;Abstr&lt;/code&gt; by applying &lt;code&gt;Fun&lt;/code&gt; on each collection of annotations of the nodes of the &lt;code&gt;erl_parse&lt;/code&gt; tree. The &lt;code&gt;erl_parse&lt;/code&gt; tree is traversed in a depth-first, left-to-right fashion.</source>
          <target state="translated">修改 &lt;code&gt;erl_parse&lt;/code&gt; 树 &lt;code&gt;Abstr&lt;/code&gt; 应用 &lt;code&gt;Fun&lt;/code&gt; 上的节点的注释的每个集合 &lt;code&gt;erl_parse&lt;/code&gt; 树。该 &lt;code&gt;erl_parse&lt;/code&gt; 树的深度优先，左到右的方式运行。</target>
        </trans-unit>
        <trans-unit id="d6767e7b3024caf3c0392eb069c62606173a9f1a" translate="yes" xml:space="preserve">
          <source>Modifies the filename of the annotations Anno.</source>
          <target state="translated">修改注释的文件名Anno。</target>
        </trans-unit>
        <trans-unit id="f5817a19c5f89b9a4e372f141f435c1a42a9dd33" translate="yes" xml:space="preserve">
          <source>Modifies the generated marker of the annotations Anno.</source>
          <target state="translated">修改注释Anno.Anno.的生成标记。</target>
        </trans-unit>
        <trans-unit id="037defcfe58535f15797aebbd1fbb203e7cd9af8" translate="yes" xml:space="preserve">
          <source>Modifies the line of the annotations Anno.</source>
          <target state="translated">修改注释Anno的行。</target>
        </trans-unit>
        <trans-unit id="c6cc4351008b5ab2535c804b7cd295d8836544e6" translate="yes" xml:space="preserve">
          <source>Modifies the list of algorithms to use in the algorithm negotiation. The modifications are applied after the option &lt;code&gt;preferred_algorithms&lt;/code&gt; (if existing) is applied.</source>
          <target state="translated">修改要在算法协商中使用的算法列表。修改是在应用了 &lt;code&gt;preferred_algorithms&lt;/code&gt; 选项（如果存在）之后应用的。</target>
        </trans-unit>
        <trans-unit id="c1311f97ce347997edad775a69d938fac98b1ab7" translate="yes" xml:space="preserve">
          <source>Modifies the location of the annotations Anno.</source>
          <target state="translated">修改注释Anno的位置。</target>
        </trans-unit>
        <trans-unit id="cf1b78ca3bb67cc73d9a5ef2e74df6aa835b463e" translate="yes" xml:space="preserve">
          <source>Modifies the record marker of the annotations Anno.</source>
          <target state="translated">修改注释的记录标记Anno。</target>
        </trans-unit>
        <trans-unit id="7eb7754f43a795536f0ab7aea723cfd8a2dcf954" translate="yes" xml:space="preserve">
          <source>Modifies the text of the annotations Anno.</source>
          <target state="translated">修改注释的文本Anno。</target>
        </trans-unit>
        <trans-unit id="fad6e92bd8f724516530123632d526536ce733e0" translate="yes" xml:space="preserve">
          <source>Modify PATH and other environment variables so that all these tools are runnable from a bash shell. Still standing in &lt;code&gt;$ERL_TOP&lt;/code&gt;, issue the following commands (for 32-bit Windows, remove the x64 from the first row and change &lt;code&gt;otp_win64_21&lt;/code&gt; to &lt;code&gt;otp_win32_21&lt;/code&gt; on the last row):</source>
          <target state="translated">修改PATH和其他环境变量，以便可以从bash shell运行所有这些工具。还站在 &lt;code&gt;$ERL_TOP&lt;/code&gt; ，发出以下命令（32位Windows，从第一行删除x64和改变 &lt;code&gt;otp_win64_21&lt;/code&gt; 到 &lt;code&gt;otp_win32_21&lt;/code&gt; 最后一行上）：</target>
        </trans-unit>
        <trans-unit id="12f926fde51df220b3a44737fd7a8d3f5f5cf650" translate="yes" xml:space="preserve">
          <source>Modify an entry.</source>
          <target state="translated">修改一个条目。</target>
        </trans-unit>
        <trans-unit id="10f726edf41c57d1e88f9e6b3584066a593e9aea" translate="yes" xml:space="preserve">
          <source>Modify the DN of an entry. &lt;code&gt;DeleteOldRDN&lt;/code&gt; indicates whether the current RDN should be removed from the attribute list after the after operation. &lt;code&gt;NewSupDN&lt;/code&gt; is the new parent that the RDN shall be moved to. If the old parent should remain as parent, &lt;code&gt;NewSupDN&lt;/code&gt; shall be &quot;&quot;.</source>
          <target state="translated">修改条目的DN。 &lt;code&gt;DeleteOldRDN&lt;/code&gt; 指示在after操作之后是否应从属性列表中删除当前RDN。 &lt;code&gt;NewSupDN&lt;/code&gt; 是RDN将被移动到的新父对象。如果旧的父级应保留为父级，则 &lt;code&gt;NewSupDN&lt;/code&gt; 应为&amp;ldquo;&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="aaa722d609855294fcc06f9f555621df06ec84a5" translate="yes" xml:space="preserve">
          <source>Modify the default handler to only print errors and more severe log events to &quot;log/erlang.log&quot;, and add another handler to print all log events to &quot;log/debug.log&quot;.</source>
          <target state="translated">修改默认处理程序,只打印错误和更严重的日志事件到 &quot;log/erlang.log&quot;,并添加另一个处理程序,打印所有日志事件到 &quot;log/debug.log&quot;。</target>
        </trans-unit>
        <trans-unit id="d3fd275091bd2e943ed17a3e09212992146dc33a" translate="yes" xml:space="preserve">
          <source>Modify the default handler to print each log event as a single line:</source>
          <target state="translated">修改默认处理程序,将每个日志事件打印为一行。</target>
        </trans-unit>
        <trans-unit id="dd1a86ac0a2c106289b6452634be890061d7e0ee" translate="yes" xml:space="preserve">
          <source>Modify the default handler to print the pid of the logging process for each log event:</source>
          <target state="translated">修改默认处理程序,以打印每个日志事件的日志进程pid。</target>
        </trans-unit>
        <trans-unit id="78a2b877311ab0e1542d92e5d0d77e8835127859" translate="yes" xml:space="preserve">
          <source>Modify the default handler to print to a file instead of &lt;code&gt;standard_io&lt;/code&gt;:</source>
          <target state="translated">修改默认处理程序以打印到文件而不是 &lt;code&gt;standard_io&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="60ff3ee60fb042d23c742fd31feed7fec7ed6a1c" translate="yes" xml:space="preserve">
          <source>Modify the password of a user.</source>
          <target state="translated">修改用户的密码。</target>
        </trans-unit>
        <trans-unit id="78971b16f8399500c31431d1ca9618f6dee87669" translate="yes" xml:space="preserve">
          <source>Modify the password of a user. See &lt;code&gt;&lt;a href=&quot;#modify_password-4&quot;&gt;modify_password/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">修改用户密码。请参阅 &lt;code&gt;&lt;a href=&quot;#modify_password-4&quot;&gt;modify_password/4&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51b459ec8aabe598314683815cd6576876569d8f" translate="yes" xml:space="preserve">
          <source>Modifying answers is the responsibility of the user in callbacks from diameter.</source>
          <target state="translated">在直径的回调中,修改答案是用户的责任。</target>
        </trans-unit>
        <trans-unit id="b8ff02892916ff59f7fbd4e617fccd01f6bca576" translate="yes" xml:space="preserve">
          <source>Module</source>
          <target state="translated">Module</target>
        </trans-unit>
        <trans-unit id="e38d402d9b28b267f7bbb774745d5b1326cac05a" translate="yes" xml:space="preserve">
          <source>Module :: module(),</source>
          <target state="translated">模块:模块();</target>
        </trans-unit>
        <trans-unit id="e2422bff0b69502b127f4dbc4235fb67ea1f739d" translate="yes" xml:space="preserve">
          <source>Module ::= Atom</source>
          <target state="translated">模块 ::=Atom</target>
        </trans-unit>
        <trans-unit id="7da910aa1163387303b43f2f30ab78aed84ec504" translate="yes" xml:space="preserve">
          <source>Module &lt;code&gt;&lt;a href=&quot;ssh_client_key_api&quot;&gt;ssh_client_key_api&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">模块 &lt;code&gt;&lt;a href=&quot;ssh_client_key_api&quot;&gt;ssh_client_key_api&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="734c7672bf31a9ad24405d2c26dfc8c63ce96e2a" translate="yes" xml:space="preserve">
          <source>Module &lt;code&gt;&lt;a href=&quot;ssh_server_key_api&quot;&gt;ssh_server_key_api&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">模块 &lt;code&gt;&lt;a href=&quot;ssh_server_key_api&quot;&gt;ssh_server_key_api&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5bda4d30c8d6fa83505f2d8e9d0cca830b01ddf" translate="yes" xml:space="preserve">
          <source>Module &lt;code&gt;multitrace&lt;/code&gt; in directory &lt;code&gt;src&lt;/code&gt; of the Observer application provides a small tool with three possible trace settings. The trace messages are written to binary files, which can be formatted with function &lt;code&gt;multitrace:format/1,2&lt;/code&gt;:</source>
          <target state="translated">Observer应用程序的 &lt;code&gt;src&lt;/code&gt; 目录中的模块 &lt;code&gt;multitrace&lt;/code&gt; 提供了一个带有三种可能的跟踪设置的小型工具。跟踪消息被写入二进制文件，可以使用 &lt;code&gt;multitrace:format/1,2&lt;/code&gt; 函数对其进行格式化：</target>
        </trans-unit>
        <trans-unit id="fadc79bb4f4079275ed96cbc52aaafb49fe144c9" translate="yes" xml:space="preserve">
          <source>Module &lt;code&gt;ttb&lt;/code&gt; is the interface to all functions in Trace Tool Builder.</source>
          <target state="translated">&lt;code&gt;ttb&lt;/code&gt; 模块是Trace Tool Builder中所有功能的接口。</target>
        </trans-unit>
        <trans-unit id="b1299646aab374780f3464f47be41a7599458cc8" translate="yes" xml:space="preserve">
          <source>Module Edges. All module calls.</source>
          <target state="translated">模块边缘。所有模块调用。</target>
        </trans-unit>
        <trans-unit id="4de0a6a0634d489b9158f70004696bcc4b277613" translate="yes" xml:space="preserve">
          <source>Module and application names are atoms, while file and directory names are strings. For backward compatibility reasons, some functions accept both strings and atoms, but a future release will probably only allow the arguments that are documented.</source>
          <target state="translated">模块和应用程序名称是原子,而文件和目录名称是字符串。出于向后兼容的原因,一些函数既接受字符串又接受原子,但未来的版本可能只允许使用有记录的参数。</target>
        </trans-unit>
        <trans-unit id="53bcb5e4dbe6774226d92c1d8796a8dd249ddb9a" translate="yes" xml:space="preserve">
          <source>Module attributes for the current code. This field is decoded when looked at by the Crashdump Viewer tool.</source>
          <target state="translated">当前代码的模块属性。这个字段在Crashdump Viewer工具中被解码。</target>
        </trans-unit>
        <trans-unit id="f7f9e0f5b07f095dde5495f6ff4abc79cb69752f" translate="yes" xml:space="preserve">
          <source>Module attributes for the old code, if any. This field is decoded when looked at by the Crashdump Viewer tool.</source>
          <target state="translated">旧代码的模块属性,如果有的话。这个字段在Crashdump Viewer工具中被解码。</target>
        </trans-unit>
        <trans-unit id="9ec0fffee38c98db4b9f15f636dd6e2046e7c657" translate="yes" xml:space="preserve">
          <source>Module declaration, defining the name of the module. The name &lt;code&gt;Module&lt;/code&gt;, an atom, is to be same as the file name minus the extension &lt;code&gt;.erl&lt;/code&gt;. Otherwise &lt;code&gt;&lt;a href=&quot;code_loading#loading&quot;&gt;code loading&lt;/a&gt;&lt;/code&gt; does not work as intended.</source>
          <target state="translated">模块声明，定义模块的名称。名称 &lt;code&gt;Module&lt;/code&gt; 是一个原子，应与文件名减去扩展名 &lt;code&gt;.erl&lt;/code&gt; 相同。否则， &lt;code&gt;&lt;a href=&quot;code_loading#loading&quot;&gt;code loading&lt;/a&gt;&lt;/code&gt; 无法按预期进行。</target>
        </trans-unit>
        <trans-unit id="a9f410e5b1b65a73903dd4626c286783c1bfbc2a" translate="yes" xml:space="preserve">
          <source>Module dependencies</source>
          <target state="translated">模块依赖性</target>
        </trans-unit>
        <trans-unit id="29831323c7df8a96814b2f509d3ff6857f030f35" translate="yes" xml:space="preserve">
          <source>Module implementing a transport process as defined in &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt;. Defaults to &lt;code&gt;diameter_tcp&lt;/code&gt;.</source>
          <target state="translated">模块实现实现在 &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 中定义的传输过程。默认为 &lt;code&gt;diameter_tcp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4e38a18f0719919f3c40ded9bbdfc81eabab76a" translate="yes" xml:space="preserve">
          <source>Module implementing the behaviour &lt;code&gt;&lt;a href=&quot;ssh_client_key_api&quot;&gt;ssh_client_key_api&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;ssh_server_key_api&quot;&gt;ssh_server_key_api&lt;/a&gt;&lt;/code&gt;. Can be used to customize the handling of public keys. If callback options are provided along with the module name, they are made available to the callback module via the options passed to it under the key 'key_cb_private'.</source>
          <target state="translated">实现行为 &lt;code&gt;&lt;a href=&quot;ssh_client_key_api&quot;&gt;ssh_client_key_api&lt;/a&gt;&lt;/code&gt; 和/或 &lt;code&gt;&lt;a href=&quot;ssh_server_key_api&quot;&gt;ssh_server_key_api&lt;/a&gt;&lt;/code&gt; 的模块。可用于自定义对公钥的处理。如果提供了回调选项以及模块名称，则可以通过在键&amp;ldquo; key_cb_private&amp;rdquo;下传递给回调模块的选项将其提供给回调模块。</target>
        </trans-unit>
        <trans-unit id="35eeaf69ae679cc6ded3a7a1fc0ebe15bf8b481c" translate="yes" xml:space="preserve">
          <source>Module implementing the callback interface defined in &lt;code&gt;diameter_app(3)&lt;/code&gt;, along with any extra arguments to be appended to those documented. Note that extra arguments specific to an outgoing request can be specified to &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt;, in which case those are appended to any module-specific extra arguments.</source>
          <target state="translated">实现在 &lt;code&gt;diameter_app(3)&lt;/code&gt; 中定义的回调接口的模块，以及附加到文档中的任何其他参数。请注意，可以将特定于传出请求的额外参数指定为 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; ，在这种情况下，这些额外参数将附加到任何特定于模块的额外参数。</target>
        </trans-unit>
        <trans-unit id="3b1e11776366f8fb2d72c2cb79f09bb4fa24e742" translate="yes" xml:space="preserve">
          <source>Module specific configuration. A module has a mandatory name and module level options that are described below.</source>
          <target state="translated">模块的具体配置。一个模块有一个强制性的名称和模块级别的选项,这些选项将在下面描述。</target>
        </trans-unit>
        <trans-unit id="f9b60e96ee40b88550cfc1f8c7fcfd25f0c8cd62" translate="yes" xml:space="preserve">
          <source>Module version. &lt;code&gt;Vsn&lt;/code&gt; is any literal term and can be retrieved using &lt;code&gt;beam_lib:version/1&lt;/code&gt;, see the &lt;code&gt;beam_lib(3)&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">模块版本。 &lt;code&gt;Vsn&lt;/code&gt; 是任何文字术语，可以使用 &lt;code&gt;beam_lib:version/1&lt;/code&gt; 检索，请参见STDLIB中的 &lt;code&gt;beam_lib(3)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="503ebafe676df7f757d99bf2c13d2488fb6ebde6" translate="yes" xml:space="preserve">
          <source>Module which handles the network interface filter part for the SNMP agent. Must implement the &lt;code&gt;&lt;a href=&quot;snmpa_network_interface_filter&quot;&gt;snmpa_network_interface_filter&lt;/a&gt;&lt;/code&gt; behaviour.</source>
          <target state="translated">处理SNMP代理的网络接口过滤器部分的模块。必须实现 &lt;code&gt;&lt;a href=&quot;snmpa_network_interface_filter&quot;&gt;snmpa_network_interface_filter&lt;/a&gt;&lt;/code&gt; 行为。</target>
        </trans-unit>
        <trans-unit id="1abddb44834be834e4e4bfa19c743e11a954f223" translate="yes" xml:space="preserve">
          <source>Module which handles the network interface filter part for the SNMP manager. Must implement the &lt;code&gt;&lt;a href=&quot;snmpm_network_interface_filter&quot;&gt;snmpm_network_interface_filter&lt;/a&gt;&lt;/code&gt; behaviour.</source>
          <target state="translated">处理SNMP管理器的网络接口过滤器部分的模块。必须实现 &lt;code&gt;&lt;a href=&quot;snmpm_network_interface_filter&quot;&gt;snmpm_network_interface_filter&lt;/a&gt;&lt;/code&gt; 行为。</target>
        </trans-unit>
        <trans-unit id="e44abc149b672de3d2e38a78a614dd0b902536c9" translate="yes" xml:space="preserve">
          <source>Module which handles the network interface part for the SNMP agent. Must implement the &lt;code&gt;&lt;a href=&quot;snmpa_network_interface&quot;&gt;snmpa_network_interface&lt;/a&gt;&lt;/code&gt; behaviour.</source>
          <target state="translated">处理SNMP代理的网络接口部分的模块。必须实现 &lt;code&gt;&lt;a href=&quot;snmpa_network_interface&quot;&gt;snmpa_network_interface&lt;/a&gt;&lt;/code&gt; 行为。</target>
        </trans-unit>
        <trans-unit id="e55ad072ead98bed5f6005b9ebdc8c72b3e6734f" translate="yes" xml:space="preserve">
          <source>Module-local type, that is, with a definition that is present in the code of the module</source>
          <target state="translated">模块-本地类型,即具有模块代码中存在的定义。</target>
        </trans-unit>
        <trans-unit id="3bb18ecc75afce04897d2fff035677396581e539" translate="yes" xml:space="preserve">
          <source>ModuleName = atom()</source>
          <target state="translated">ModuleName=atom()</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="91edcf2737edcc491331e2f8bedfb98b3d292c2d" translate="yes" xml:space="preserve">
          <source>Modules are auto loaded when they are first referenced if the runtime system runs in &lt;code&gt;interactive&lt;/code&gt; mode, which is the default. In &lt;code&gt;embedded&lt;/code&gt; mode modules are not auto loaded. The latter is recommended when the boot script preloads all modules, as conventionally happens in OTP releases. See &lt;code&gt;code(3)&lt;/code&gt;</source>
          <target state="translated">如果运行时系统以 &lt;code&gt;interactive&lt;/code&gt; 方式运行（默认设置），则在首次引用模块时会自动加载模块。在 &lt;code&gt;embedded&lt;/code&gt; 模式下，不会自动加载模块。当引导脚本预加载所有模块时（如OTP版本中通常发生的那样），建议使用后者。参见 &lt;code&gt;code(3)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb1481c22b555900c17ca93bb499831901e632cf" translate="yes" xml:space="preserve">
          <source>Modules for which these requirements are not fulfilled are not interpretable and are therefore displayed within parentheses.</source>
          <target state="translated">未满足这些要求的模块不能解释,因此在括号内显示。</target>
        </trans-unit>
        <trans-unit id="3655dff16c3acb075f3aa4eb83a55de4222d8dcd" translate="yes" xml:space="preserve">
          <source>Modules handling textual data (such as &lt;code&gt;io_lib&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt; are sometimes subject to conversion or extension to be able to handle Unicode characters.</source>
          <target state="translated">处理文本数据的模块（例如 &lt;code&gt;io_lib&lt;/code&gt; 和 &lt;code&gt;string&lt;/code&gt; 有时会经过转换或扩展，以便能够处理Unicode字符。</target>
        </trans-unit>
        <trans-unit id="5f2ee43d36d04a016e320f127714934e6c2e4d80" translate="yes" xml:space="preserve">
          <source>Modules that can use match specifications for optimized traversal of tables are to call &lt;code&gt;qlc:table/2&lt;/code&gt; with an unary &lt;code&gt;TraverseFun&lt;/code&gt;. An example is &lt;code&gt;&lt;a href=&quot;ets#table-2&quot;&gt;ets:table/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以使用匹配规范来优化表遍历的模块将使用一元 &lt;code&gt;TraverseFun&lt;/code&gt; 调用 &lt;code&gt;qlc:table/2&lt;/code&gt; 。一个示例是 &lt;code&gt;&lt;a href=&quot;ets#table-2&quot;&gt;ets:table/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="422ffac5358de536fa7258027d227737932e212a" translate="yes" xml:space="preserve">
          <source>Modules to be debugged must include debug information, for example, &lt;code&gt;erlc +debug_info MODULE.erl&lt;/code&gt;.</source>
          <target state="translated">要调试的模块必须包含调试信息，例如 &lt;code&gt;erlc +debug_info MODULE.erl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad051bc5d863047321817c8bcfbe0c4f0ad41d7f" translate="yes" xml:space="preserve">
          <source>Modules. All modules: analyzed modules, used library modules, and unknown modules.</source>
          <target state="translated">模块。所有模块:分析过的模块、使用过的库模块和未知模块。</target>
        </trans-unit>
        <trans-unit id="c3bdbab40a4be4ac1b8eb1ccb2dbb2eaf8ed480f" translate="yes" xml:space="preserve">
          <source>Mongolian</source>
          <target state="translated">Mongolian</target>
        </trans-unit>
        <trans-unit id="787f0f344756f8edefb0e5d7c62ebb26c5a4a55b" translate="yes" xml:space="preserve">
          <source>Mongolian Vowel Separator</source>
          <target state="translated">蒙古语元音分离器</target>
        </trans-unit>
        <trans-unit id="600aa04e59197f341b9f4d4f4b67aac5860b9298" translate="yes" xml:space="preserve">
          <source>Mongolian vowel separator</source>
          <target state="translated">元音分离符</target>
        </trans-unit>
        <trans-unit id="01e57fc0fd45173cbed0acd0fdb7a3a5528fd3cf" translate="yes" xml:space="preserve">
          <source>Monitor the SNMP manager. In case of a crash, the calling (monitoring) process will get a 'DOWN' message (see the erlang module for more info).</source>
          <target state="translated">监控SNMP管理器。如果发生崩溃,调用(监控)进程会得到一个 &quot;DOWN &quot;消息(详见erlang模块)。</target>
        </trans-unit>
        <trans-unit id="344910a8e2960c1213ce5adc8d4e0d2e7e946399" translate="yes" xml:space="preserve">
          <source>Monitor the current status of all processes executing code in interpreted modules, also processes at other Erlang nodes.</source>
          <target state="translated">监控所有在解释模块中执行代码的进程的当前状态,也包括其他Erlang节点的进程。</target>
        </trans-unit>
        <trans-unit id="861055aa27b6909c706d63bc66a51be73f91acc2" translate="yes" xml:space="preserve">
          <source>Monitor the status of the node &lt;code&gt;Node&lt;/code&gt;. If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, monitoring is turned on. If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, monitoring is turned off.</source>
          <target state="translated">监视节点 &lt;code&gt;Node&lt;/code&gt; 的状态。如果 &lt;code&gt;Flag&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则打开监视。如果 &lt;code&gt;Flag&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则关闭监视。</target>
        </trans-unit>
        <trans-unit id="ebcb5e6cac0f295c708f39a3c4a6170117db14de" translate="yes" xml:space="preserve">
          <source>MonitorRef</source>
          <target state="translated">MonitorRef</target>
        </trans-unit>
        <trans-unit id="470c3f4925fdbce53327014ba80ea684bb7bb834" translate="yes" xml:space="preserve">
          <source>Monitoring of the master node by the slaves. A slave node can be stopped if the master node terminates. (Configurable.)</source>
          <target state="translated">由从属节点对主节点进行监控。如果主节点终止,可以停止从属节点。(可配置。)</target>
        </trans-unit>
        <trans-unit id="0f28429d58b7c5efe00cd63a0b3f938a3c652898" translate="yes" xml:space="preserve">
          <source>Monitors are unidirectional. Repeated calls to &lt;code&gt;erlang:monitor(process, Pid)&lt;/code&gt; creates several independent monitors, and each one sends a 'DOWN' message when &lt;code&gt;Pid&lt;/code&gt; terminates.</source>
          <target state="translated">监视器是单向的。重复调用 &lt;code&gt;erlang:monitor(process, Pid)&lt;/code&gt; 会创建多个独立的监视器，并且当 &lt;code&gt;Pid&lt;/code&gt; 终止时，每个监视器都会发送&amp;ldquo; DOWN&amp;rdquo;消息。</target>
        </trans-unit>
        <trans-unit id="cdb09466cb66d0cbd945a8e99ed6c52ea020f0ad" translate="yes" xml:space="preserve">
          <source>Monitors can be created for processes with registered names, also at other nodes.</source>
          <target state="translated">可以在其他节点为注册名称的进程创建监控器。</target>
        </trans-unit>
        <trans-unit id="01bc156298d3c730abf64a20c2aed5c87c1f305c" translate="yes" xml:space="preserve">
          <source>Monitors changes in &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;time offset&lt;/a&gt;&lt;/code&gt; between &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt;. One valid &lt;code&gt;Item&lt;/code&gt; exists in combination with the &lt;code&gt;time_offset Type&lt;/code&gt;, namely the atom &lt;code&gt;clock_service&lt;/code&gt;. Notice that the atom &lt;code&gt;clock_service&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; the registered name of a process. In this case it serves as an identifier of the runtime system internal clock service at current runtime system instance.</source>
          <target state="translated">监视 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt; 之间的 &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;time offset&lt;/a&gt;&lt;/code&gt; 变化。一个有效的 &lt;code&gt;Item&lt;/code&gt; 与 &lt;code&gt;time_offset Type&lt;/code&gt; 结合在一起存在，即原子 &lt;code&gt;clock_service&lt;/code&gt; 。注意，原子 &lt;code&gt;clock_service&lt;/code&gt; 是&lt;strong&gt;不是&lt;/strong&gt;一个过程的注册名称。在这种情况下，它充当当前运行时系统实例处的运行时系统内部时钟服务的标识符。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6278940d00dc973b9fac020727e51dbaff5a2934" translate="yes" xml:space="preserve">
          <source>Monitors the new process (like &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt; does).</source>
          <target state="translated">监视新进程（就像 &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt; 一样）。</target>
        </trans-unit>
        <trans-unit id="cad13ed7bd36f4e4080c9a5204dc6f837cb3bfe8" translate="yes" xml:space="preserve">
          <source>Monitors the status of &lt;code&gt;Node&lt;/code&gt;. A message&lt;code&gt;{nodedown, Node}&lt;/code&gt; is received if the connection to it is lost.</source>
          <target state="translated">监视 &lt;code&gt;Node&lt;/code&gt; 的状态。如果 &lt;code&gt;{nodedown, Node}&lt;/code&gt; 断开连接，则会收到消息{nodedown，Node}。</target>
        </trans-unit>
        <trans-unit id="c216ef5762c4c0ce5f8e7770265d785983bc6ae3" translate="yes" xml:space="preserve">
          <source>Monitors when a driver gets unloaded. If one monitors a driver that is not present in the system, one immediately gets notified that the driver got unloaded. There is no guarantee that the driver was ever loaded.</source>
          <target state="translated">监视驱动程序何时被卸载。如果监视系统中不存在的驱动程序,就会立即得到该驱动程序被卸载的通知。不能保证该驱动程序曾经被加载。</target>
        </trans-unit>
        <trans-unit id="bd9b10ee2a0012e1817ee26b4049755fcb0ac1ff" translate="yes" xml:space="preserve">
          <source>More &lt;code&gt;Option&lt;/code&gt;s can be added in the future.</source>
          <target state="translated">将来可以添加更多 &lt;code&gt;Option&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d00ed339af89630d658502ba6fa422f63b92791b" translate="yes" xml:space="preserve">
          <source>More &lt;code&gt;Option&lt;/code&gt;s may be added in the future.</source>
          <target state="translated">将来可能会添加更多 &lt;code&gt;Option&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5800ca3d1d23bed63e706fafc9995e33a99a9d14" translate="yes" xml:space="preserve">
          <source>More &lt;strong&gt;Examples:&lt;/strong&gt;</source>
          <target state="translated">更多&lt;strong&gt;示例：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d583518560cd4a6b87be9bc7d0b5d20f375dd723" translate="yes" xml:space="preserve">
          <source>More about schema management</source>
          <target state="translated">更多关于模式管理</target>
        </trans-unit>
        <trans-unit id="6f6b5d611fb9be7645dc68d59bbad9a1cb5dc15a" translate="yes" xml:space="preserve">
          <source>More complicated assertions are coded as subpatterns. There are two kinds: those that look ahead of the current position in the subject string, and those that look behind it. An assertion subpattern is matched in the normal way, except that it does not cause the current matching position to be changed.</source>
          <target state="translated">更复杂的断言被编码为子模式。有两种:一种是在主题字符串中的当前位置前面看,另一种是在其后面看。断言子模式以正常的方式进行匹配,只是它不会导致当前匹配位置的改变。</target>
        </trans-unit>
        <trans-unit id="dc0707bf61bc70dcb1ccf38732ab029880726d5a" translate="yes" xml:space="preserve">
          <source>More complicated filters must be applied to all objects returned by &lt;code&gt;select/3&lt;/code&gt; given a match specification that matches all objects.</source>
          <target state="translated">给定与所有对象匹配的匹配规范，必须对 &lt;code&gt;select/3&lt;/code&gt; 返回的所有对象应用更复杂的过滤器。</target>
        </trans-unit>
        <trans-unit id="bc35fb8a88b65701f3530def0b268e553aeb3acf" translate="yes" xml:space="preserve">
          <source>More data is required for building a term. &lt;code&gt;Continuation1&lt;/code&gt; must be passed in a new call to &lt;code&gt;tokens/3,4&lt;/code&gt; when more data is available.</source>
          <target state="translated">建立术语需要更多数据。当有更多数据可用时，必须在对 &lt;code&gt;tokens/3,4&lt;/code&gt; 的新调用中传递 &lt;code&gt;Continuation1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61d71bef3701b166a8820075cfe5c6b25a998a5a" translate="yes" xml:space="preserve">
          <source>More data is required to build a term. &lt;code&gt;Continuation&lt;/code&gt; must be passed to &lt;code&gt;fread/3&lt;/code&gt; when more data becomes available.</source>
          <target state="translated">建立术语需要更多数据。当有更多数据可用时，必须将 &lt;code&gt;Continuation&lt;/code&gt; 传递给 &lt;code&gt;fread/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="724f9066e927cf5e78aa33ce4b0b56cdb2c9bad0" translate="yes" xml:space="preserve">
          <source>More examples are provided in &lt;code&gt;Programming Examples.&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Programming Examples.&lt;/code&gt; 示例中提供了更多示例。</target>
        </trans-unit>
        <trans-unit id="9ed94e5cafdef76e06a28a02d1fb7d9d847eb489" translate="yes" xml:space="preserve">
          <source>More examples are provided in &lt;code&gt;Programming Examples&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Programming Examples&lt;/code&gt; 示例中提供了更多示例。</target>
        </trans-unit>
        <trans-unit id="0f0c04bd8d50bdec5467c598e0a5b535a66ddbd3" translate="yes" xml:space="preserve">
          <source>More fine-grained &lt;code&gt;MSAcc_Thread_State&lt;/code&gt;s can be added through configure (such as &lt;code&gt;./configure --with-microstate-accounting=extra&lt;/code&gt;). Enabling these states causes performance degradation when microstate accounting is turned off and increases the overhead when it is turned on.</source>
          <target state="translated">可以通过configure添加更多细粒度的 &lt;code&gt;MSAcc_Thread_State&lt;/code&gt; （例如 &lt;code&gt;./configure --with-microstate-accounting=extra&lt;/code&gt; ）。启用这些状态会导致微状态计帐关闭时性能下降，而启用微状态计帐则增加开销。</target>
        </trans-unit>
        <trans-unit id="2acb3fbd866339988fd39b1c284e6c3b2ab38a8d" translate="yes" xml:space="preserve">
          <source>More identifiers can exist, for example, server-side namespace.</source>
          <target state="translated">可以存在更多的标识符,例如,服务器端名称空间。</target>
        </trans-unit>
        <trans-unit id="1694f778d2be24087b41889858ea210d0111ac2d" translate="yes" xml:space="preserve">
          <source>More information can be found at</source>
          <target state="translated">更多信息请见</target>
        </trans-unit>
        <trans-unit id="64269325714a31b2baa9a9331c4f44390f41f060" translate="yes" xml:space="preserve">
          <source>More information is provided by the &lt;code&gt;ms_transform&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">STDLIB中的 &lt;code&gt;ms_transform&lt;/code&gt; 手册页提供了更多信息。</target>
        </trans-unit>
        <trans-unit id="88f4919d857f59d8c447803f4828a40dd5c28e81" translate="yes" xml:space="preserve">
          <source>More information, if any. If the process is stopped at a breakpoint, the field contains information about the location &lt;code&gt;{Module,Line}&lt;/code&gt;. If the process has terminated, the field contains the exit reason.</source>
          <target state="translated">更多信息（如果有）。如果该过程在断点处停止，则该字段包含有关位置 &lt;code&gt;{Module,Line}&lt;/code&gt; 的信息。如果进程已终止，则该字段包含退出原因。</target>
        </trans-unit>
        <trans-unit id="ee6de05aba35fe8266245c0993bc1f9805274eb9" translate="yes" xml:space="preserve">
          <source>More options can be added in a future release.</source>
          <target state="translated">更多的选项可以在未来的版本中添加。</target>
        </trans-unit>
        <trans-unit id="624affd09f46bdb2e3938ac33ddbe38974e12c14" translate="yes" xml:space="preserve">
          <source>More than three parts are not possible with this indata, so</source>
          <target state="translated">在这个indata上不可能有三个以上的部分,所以。</target>
        </trans-unit>
        <trans-unit id="b885fb398d558b327a8bb15c26cf1ab822a084fa" translate="yes" xml:space="preserve">
          <source>More tuples in the returned list can be added in a future release.</source>
          <target state="translated">返回列表中的更多元组可以在未来的版本中添加。</target>
        </trans-unit>
        <trans-unit id="d2f77ff3575a46c8961aaa5e120590c63bc009a2" translate="yes" xml:space="preserve">
          <source>Most Unix operating systems have adopted a simpler approach, namely that Unicode file naming is not enforced, but by convention. Those systems usually use UTF-8 encoding for Unicode filenames, but do not enforce it. On such a system, a filename containing characters with code points from 128 through 255 can be named as plain ISO Latin-1 or use UTF-8 encoding. As no consistency is enforced, the Erlang VM cannot do consistent translation of all filenames.</source>
          <target state="translated">大多数Unix操作系统都采用了一种比较简单的方法,即不强制执行Unicode文件命名,而是按照惯例进行命名。这些系统通常对Unicode文件名使用UTF-8编码,但不强制执行。在这样的系统上,一个包含128到255码点的字符的文件名,可以命名为普通的ISO Latin-1,也可以使用UTF-8编码。由于没有强制执行一致性,所以Erlang虚拟机无法对所有文件名进行一致翻译。</target>
        </trans-unit>
        <trans-unit id="f0ba27548898cb4c334f12ba233f3dfd33b35de6" translate="yes" xml:space="preserve">
          <source>Most applications only need the Master Agent because an agent can have multiple MIBs loaded at the same time.</source>
          <target state="translated">大多数应用只需要主代理,因为一个代理可以同时加载多个MIB。</target>
        </trans-unit>
        <trans-unit id="f4dc046cd951e52d7b06645a8907d9bc64484dc4" translate="yes" xml:space="preserve">
          <source>Most drivers written before the runtime system with SMP support existed can run in the runtime system with SMP support, without being rewritten, if driver level locking is used.</source>
          <target state="translated">如果使用驱动级锁定,大多数在支持SMP的运行时系统存在之前编写的驱动程序可以在支持SMP的运行时系统中运行,而不需要重新编写。</target>
        </trans-unit>
        <trans-unit id="36d595b42429aa7673a2aecb223ad49cf5a73ec5" translate="yes" xml:space="preserve">
          <source>Most functions appear in a version with the suffix &lt;code&gt;_tmo&lt;/code&gt; appended to the function name. Those functions take an extra argument, a time-out in &lt;strong&gt;milliseconds&lt;/strong&gt;. The semantics is this: for each communication primitive involved in the operation, if the primitive does not complete within the time specified, the function returns an error and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;ETIMEDOUT&lt;/code&gt;. With communication primitive is meant an operation on the socket, like &lt;code&gt;connect&lt;/code&gt;, &lt;code&gt;accept&lt;/code&gt;, &lt;code&gt;recv&lt;/code&gt;, or &lt;code&gt;send&lt;/code&gt;.</source>
          <target state="translated">大多数功能显示在一个版本中，后缀 &lt;code&gt;_tmo&lt;/code&gt; 附加在功能名称后。这些函数需要一个额外的参数，即以&lt;strong&gt;毫秒为单位&lt;/strong&gt;的超时。语义是这样的：对于操作中涉及的每个通信原语，如果该原语在指定的时间内未完成，则该函数将返回错误，并且 &lt;code&gt;erl_errno&lt;/code&gt; 设置为 &lt;code&gt;ETIMEDOUT&lt;/code&gt; 。通信原语是指对套接字进行的操作，例如 &lt;code&gt;connect&lt;/code&gt; ， &lt;code&gt;accept&lt;/code&gt; ， &lt;code&gt;recv&lt;/code&gt; 或 &lt;code&gt;send&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a85fc0308845fa5554e3cce6dc65bbf6089cf9b5" translate="yes" xml:space="preserve">
          <source>Most functions in &lt;code&gt;Erl_Interface&lt;/code&gt; report failures to the caller by returning some otherwise meaningless value (typically &lt;code&gt;NULL&lt;/code&gt; or a negative number). As this only tells you that things did not go well, examine the error code in &lt;code&gt;erl_errno&lt;/code&gt; if you want to find out more about the failure.</source>
          <target state="translated">&lt;code&gt;Erl_Interface&lt;/code&gt; 中的大多数函数都会通过返回一些其他没有意义的值（通常为 &lt;code&gt;NULL&lt;/code&gt; 或负数）向调用方报告失败。因为这仅告诉您事情进展不顺利， &lt;code&gt;erl_errno&lt;/code&gt; 如果您想了解有关故障的更多信息，请检查erl_errno中的错误代码。</target>
        </trans-unit>
        <trans-unit id="6b9a8701c6eef5e39f2cf96b687e2ad091233f9f" translate="yes" xml:space="preserve">
          <source>Most functions in this API are &lt;strong&gt;not&lt;/strong&gt; thread-safe, that is, they &lt;strong&gt;cannot&lt;/strong&gt; be called from arbitrary threads. Functions that are not documented as thread-safe can only be called from driver callbacks or function calls descending from a driver callback call. Notice that driver callbacks can be called from different threads. This, however, is not a problem for any function in this API, as the emulator has control over these threads.</source>
          <target state="translated">此API中的大多数函数&lt;strong&gt;都不是&lt;/strong&gt;线程安全的，也就是说，&lt;strong&gt;不能&lt;/strong&gt;从任意线程中调用它们。未记录为线程安全的函数只能从驱动程序回调或从驱动程序回调调用派生的函数调用中调用。注意，可以从不同的线程调用驱动程序回调。但是，对于该API中的任何功能，这都不是问题，因为仿真器可以控制这些线程。</target>
        </trans-unit>
        <trans-unit id="66cf9f2e24e97469377d6bb06bc86d3532009574" translate="yes" xml:space="preserve">
          <source>Most importantly, the object must have been created with a single call to &lt;code&gt;malloc()&lt;/code&gt; (or similar), so that it can later be removed by a single call to &lt;code&gt;free()&lt;/code&gt;. Objects are freed by the registry when it is closed, or when you assign a new value to an object that previously contained a string or binary.</source>
          <target state="translated">最重要的是，必须通过单次调用 &lt;code&gt;malloc()&lt;/code&gt; （或类似方法）创建对象，以便以后可以通过单次调用 &lt;code&gt;free()&lt;/code&gt; 将其删除。当注册表关闭或向以前包含字符串或二进制文件的对象分配新值时，注册表将释放对象。</target>
        </trans-unit>
        <trans-unit id="259d848432008a34f52bb0dbba925c35f2c8e9d8" translate="yes" xml:space="preserve">
          <source>Most likely, some type of table coordinator already exists. This process should take care of the instrumentation for the table.</source>
          <target state="translated">最有可能的是,已经存在某种类型的表格协调器。这个过程应处理好表格的文书工作。</target>
        </trans-unit>
        <trans-unit id="d0e2d6f01b9b328d4a5f37c7cbd2074b9468e6ea" translate="yes" xml:space="preserve">
          <source>Most modern operating systems support Unicode filenames in some way. There are many different ways to do this and Erlang by default treats the different approaches differently:</source>
          <target state="translated">大多数现代操作系统都以某种方式支持Unicode文件名。有很多不同的方法可以做到这一点,默认情况下,Erlang会对不同的方法进行不同的处理。</target>
        </trans-unit>
        <trans-unit id="94bf990af8b5bba4715948822b6d909da6a73a07" translate="yes" xml:space="preserve">
          <source>Most of the functions expect all input to be normalized to one form, see for example &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt;unicode:characters_to_nfc_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">大多数功能都希望所有输入都被规范化为一种形式，例如参见 &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt;unicode:characters_to_nfc_list/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3acc15056b9b45c5a0b8bb83b1ecaadb55f64f07" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module have one variant with a &lt;code&gt;Timeout&lt;/code&gt; parameter, and one without. If nothing else is specified, the default value &lt;code&gt;infinity&lt;/code&gt; is used when the &lt;code&gt;Timeout&lt;/code&gt; parameter is not given.</source>
          <target state="translated">该模块中的大多数功能都有一个带有 &lt;code&gt;Timeout&lt;/code&gt; 参数的变体，另一个没有。如果未指定其他任何内容，则在未提供 &lt;code&gt;Timeout&lt;/code&gt; 参数的情况下使用默认值 &lt;code&gt;infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c21332b5de08b2fbd3d7faeca43f33090fab572" translate="yes" xml:space="preserve">
          <source>Most of the modules in Erlang/OTP are Unicode-unaware in the sense that they have no notion of Unicode and should not have. Typically they handle non-textual or byte-oriented data (such as &lt;code&gt;gen_tcp&lt;/code&gt;).</source>
          <target state="translated">从某种意义上说，Erlang / OTP中的大多数模块都不支持Unicode，因为它们没有Unicode概念，也应该没有。通常，它们处理非文本或面向字节的数据（例如 &lt;code&gt;gen_tcp&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="76641edebd3126877e42070a39301c6bf778343f" translate="yes" xml:space="preserve">
          <source>Most of the options are common for both the client and the server side, but some of them differs a little. The available &lt;code&gt;option()&lt;/code&gt;s are as follows:</source>
          <target state="translated">大多数选项对于客户端和服务器端都是通用的，但是其中一些有所不同。可用的 &lt;code&gt;option()&lt;/code&gt; 如下：</target>
        </trans-unit>
        <trans-unit id="5e0d4e811a2f740e5d587160a505db4b80acdc72" translate="yes" xml:space="preserve">
          <source>Most of these flags are highly implementation-dependent and can be changed or removed without prior notice.</source>
          <target state="translated">这些标志中的大部分是高度依赖实施的,可以在不事先通知的情况下更改或删除。</target>
        </trans-unit>
        <trans-unit id="e7cba0447d8d7195a8296a095d999aca792c4346" translate="yes" xml:space="preserve">
          <source>Most operating systems have a command interpreter or shell, UNIX and Linux have many, Windows has the command prompt. Erlang has its own shell where bits of Erlang code can be written directly, and be evaluated to see what happens (see the &lt;code&gt;shell(3)&lt;/code&gt; manual page in STDLIB).</source>
          <target state="translated">大多数操作系统都有命令解释器或shell，UNIX和Linux有很多，Windows有命令提示符。Erlang有自己的外壳，可以直接编写Erlang代码的位，并对其进行评估以查看会发生什么（请参阅STDLIB中的 &lt;code&gt;shell(3)&lt;/code&gt; 手册页）。</target>
        </trans-unit>
        <trans-unit id="39c2fb5ddc35fb498363b9b722fc5915d7d947f6" translate="yes" xml:space="preserve">
          <source>Most programmers also expect time to be reliable, at least until they realize that the wall clock time on their workstation is off by a minute. Then they set it to the correct time, but most probably not in a smooth way.</source>
          <target state="translated">大多数程序员也希望时间是可靠的,至少在他们意识到工作站上的挂钟时间偏离了一分钟之前是这样。然后他们就会把它设置成正确的时间,但很可能不是以一种平稳的方式。</target>
        </trans-unit>
        <trans-unit id="d49d2009b77de7ac08a0afaec3a6bddcd20dae8e" translate="yes" xml:space="preserve">
          <source>Most programs will be modified during their lifetime: bugs will be fixed, features will be added, optimizations may become necessary, or the code will need to be refactored or cleaned up in other ways to make it easier to work with. But every change to a working program is a risk of introducing new bugs - or reintroducing bugs that had previously been fixed. Having a set of unit tests that you can run with very little effort makes it easy to know that the code still works as it should (this use is called &lt;strong&gt;regression testing&lt;/strong&gt;; see &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt;). This goes a long way to reduce the resistance to changing and refactoring code.</source>
          <target state="translated">大多数程序将在其生命周期内进行修改：将修复错误，添加功能，可能需要进行优化，或者需要以其他方式重构或清理代码以使其更易于使用。但是，对工作程序进行的每次更改都有可能引入新的错误-或重新引入以前已修复的错误。拥有一组可以非常轻松地运行的单元测试，可以很容易地知道代码仍然可以正常工作（这种使用称为&lt;strong&gt;回归测试&lt;/strong&gt;；请参见 &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt; ）。这大大降低了对更改和重构代码的抵抗力。</target>
        </trans-unit>
        <trans-unit id="22312ab51d7c6c1f35dbc3ee3223deb0c786bd3e" translate="yes" xml:space="preserve">
          <source>Most role-specific behaviour is implemented by the user. How a node advertises itself at capabilities exchange is determined by user configuration.</source>
          <target state="translated">大多数特定角色的行为是由用户实现的。节点如何在能力交换时宣传自己,由用户配置决定。</target>
        </trans-unit>
        <trans-unit id="86e32c3cb060fb634a619eef0dd5d1eef4747958" translate="yes" xml:space="preserve">
          <source>Most systems handle variable &lt;code&gt;LC_CTYPE&lt;/code&gt; before &lt;code&gt;LANG&lt;/code&gt;, so if that is set, it must be set to &lt;code&gt;UTF-8&lt;/code&gt;:</source>
          <target state="translated">大多数系统在 &lt;code&gt;LANG&lt;/code&gt; 之前处理变量 &lt;code&gt;LC_CTYPE&lt;/code&gt; ，因此如果设置了该变量，则必须将其设置为 &lt;code&gt;UTF-8&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="56244bcac54ef39e9d4826088a4c9d7b27054731" translate="yes" xml:space="preserve">
          <source>Moves the copy of table &lt;code&gt;Tab&lt;/code&gt; from node &lt;code&gt;From&lt;/code&gt; to node &lt;code&gt;To&lt;/code&gt;.</source>
          <target state="translated">将表 &lt;code&gt;Tab&lt;/code&gt; 的副本从节点&amp;ldquo; &lt;code&gt;From&lt;/code&gt; 到节点&amp;ldquo; &lt;code&gt;To&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b30cc0ae00fc3d8210b07f3cf78930cce84bbd4" translate="yes" xml:space="preserve">
          <source>Mro</source>
          <target state="translated">Mro</target>
        </trans-unit>
        <trans-unit id="b1fee5a1630c4cf74b49738a6b5de770a03930a2" translate="yes" xml:space="preserve">
          <source>Much of the work involved is automated. This includes &lt;code&gt;get-next&lt;/code&gt; processing and &lt;code&gt;RowStatus&lt;/code&gt; handling.</source>
          <target state="translated">涉及的许多工作是自动化的。这包括 &lt;code&gt;get-next&lt;/code&gt; 处理和 &lt;code&gt;RowStatus&lt;/code&gt; 处理。</target>
        </trans-unit>
        <trans-unit id="28dd4fba871bafc6251102ec641d8e20bb52017b" translate="yes" xml:space="preserve">
          <source>Multi-Round-Time-Out AVP</source>
          <target state="translated">多轮次超时AVP</target>
        </trans-unit>
        <trans-unit id="e1f017ea475a1c73e4195e0bff09e16cde8df8aa" translate="yes" xml:space="preserve">
          <source>Multi-file error report logging is used to store error messages received by &lt;code&gt;error_logger&lt;/code&gt;. The error messages are stored in several files and each file is smaller than a specified number of kilobytes. No more than a specified number of files exist at the same time. The logging is very fast, as each error message is written as a binary term.</source>
          <target state="translated">多文件错误报告日志记录用于存储 &lt;code&gt;error_logger&lt;/code&gt; 接收到的错误消息。错误消息存储在多个文件中，每个文件小于指定的千字节数。同时存在的文件数不超过指定数量。日志记录非常快，因为每个错误消息都是用二进制术语编写的。</target>
        </trans-unit>
        <trans-unit id="d5421d352983c0b9fc43e3a80915204a161e3a58" translate="yes" xml:space="preserve">
          <source>Multiblock carriers are used for storage of several blocks.</source>
          <target state="translated">多块载体用于存储多个块。</target>
        </trans-unit>
        <trans-unit id="1fec23604015b2ecb5fcc1e2452ac43e2d5d2bf0" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;--inherits&lt;/code&gt; options can be specified.</source>
          <target state="translated">可以指定多个 &lt;code&gt;--inherits&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="41efb021af75ddc40ae618d768069c0d301604b2" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;-i&lt;/code&gt; options can be specified.</source>
          <target state="translated">可以指定多个 &lt;code&gt;-i&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="bdf347cf86397485cf04a5bdb8b11bd1e69ffecc" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;&lt;a href=&quot;#disconnect_cb&quot;&gt;disconnect_cb&lt;/a&gt;&lt;/code&gt; options can be specified, in which case the corresponding callbacks are applied until one of them returns a value other than &lt;code&gt;ignore&lt;/code&gt;. All callbacks returning &lt;code&gt;ignore&lt;/code&gt; is equivalent to not having configured them.</source>
          <target state="translated">可以指定多个 &lt;code&gt;&lt;a href=&quot;#disconnect_cb&quot;&gt;disconnect_cb&lt;/a&gt;&lt;/code&gt; 选项，在这种情况下，将应用相应的回调，直到其中一个返回除 &lt;code&gt;ignore&lt;/code&gt; 之外的值为止。所有返回 &lt;code&gt;ignore&lt;/code&gt; 的回调等效于未配置它们。</target>
        </trans-unit>
        <trans-unit id="204798c1114f47e98e981a537b711d39b1311eda" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;include&lt;/code&gt; options can be specified.</source>
          <target state="translated">可以指定多个 &lt;code&gt;include&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="6e0d1680057ecce93b665efdb88bfc3e3c1e5449" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;inherits&lt;/code&gt; options can be specified.</source>
          <target state="translated">可以指定多个 &lt;code&gt;inherits&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="ce8d65e7ae8dec4ab75e8c06bdc2eceb56c1abf6" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;ip&lt;/code&gt; options can be specified for a multihomed peer. If none are specified then the values of &lt;code&gt;Host-IP-Address&lt;/code&gt; in the &lt;code&gt;diameter_service&lt;/code&gt; record are used. Option &lt;code&gt;port&lt;/code&gt; defaults to 3868 for a listening transport and 0 for a connecting transport.</source>
          <target state="translated">可以为多宿主对等体指定多个 &lt;code&gt;ip&lt;/code&gt; 选项。如果没有指定随后的值 &lt;code&gt;Host-IP-Address&lt;/code&gt; 在 &lt;code&gt;diameter_service&lt;/code&gt; 记录被使用。对于侦听传输，选项 &lt;code&gt;port&lt;/code&gt; 默认为3868，对于连接传输，选项端口默认为0。</target>
        </trans-unit>
        <trans-unit id="088c280ad46a55ad788090a74438dc30fa9e951f" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;sys&lt;/code&gt; traceable replies</source>
          <target state="translated">多个 &lt;code&gt;sys&lt;/code&gt; 可追溯答复</target>
        </trans-unit>
        <trans-unit id="f06b4f8d09b8eaee5c332e885ceba194958a51dc" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;transport_module&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#transport_config&quot;&gt;transport_config&lt;/a&gt;&lt;/code&gt; options are allowed. The order of these is significant in this case (and only in this case), a &lt;code&gt;transport_module&lt;/code&gt; being paired with the first &lt;code&gt;&lt;a href=&quot;#transport_config&quot;&gt;transport_config&lt;/a&gt;&lt;/code&gt; following it in the options list, or the default value for trailing modules. Transport starts will be attempted with each of the modules in order until one establishes a connection within the corresponding timeout (see below) or all fail.</source>
          <target state="translated">允许使用多个 &lt;code&gt;transport_module&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#transport_config&quot;&gt;transport_config&lt;/a&gt;&lt;/code&gt; 选项。这些顺序是在此情况下显著（且仅在这种情况下），一个 &lt;code&gt;transport_module&lt;/code&gt; 与所述第一配对 &lt;code&gt;&lt;a href=&quot;#transport_config&quot;&gt;transport_config&lt;/a&gt;&lt;/code&gt; 选项列表中的以下，或用于拖拽模块的默认值。依次尝试每个模块的传输开始，直到一个模块在相应的超时时间内建立连接（请参见下文）或全部失败。</target>
        </trans-unit>
        <trans-unit id="8a333a79ebe5ff34c8d76c9900da678f2524bef2" translate="yes" xml:space="preserve">
          <source>Multiple Erlang nodes implementing the same Diameter node should be configured with different sequence masks to ensure that each node uses a unique range of End-to-End and Hop-by-Hop Identifiers for outgoing requests.</source>
          <target state="translated">实现同一Diameter节点的多个Erlang节点应配置不同的序列掩码,以确保每个节点使用独特的端到端和逐跳标识符范围来处理发出的请求。</target>
        </trans-unit>
        <trans-unit id="918e90f086f758494202e7c1057dc9d090319e70" translate="yes" xml:space="preserve">
          <source>Multiple connections are independent and governed by their own peer and watchdog state machines.</source>
          <target state="translated">多个连接是独立的,并由自己的对等和看门狗状态机管理。</target>
        </trans-unit>
        <trans-unit id="39c7dc292ea6c4ca667c03d03c78abb261ad3cd3" translate="yes" xml:space="preserve">
          <source>Multiple connections to the same peer is possible. ICMP messages are not interpreted.</source>
          <target state="translated">可以对同一对等体进行多个连接。不解释ICMP消息。</target>
        </trans-unit>
        <trans-unit id="47cd1d5d6231055845e7ad6743d6544e8318516d" translate="yes" xml:space="preserve">
          <source>Multiple entries of this type are allowed.</source>
          <target state="translated">这种类型的条目可以有多个。</target>
        </trans-unit>
        <trans-unit id="38d744a92105856b5a02b866c88de04b40d669df" translate="yes" xml:space="preserve">
          <source>Multiple generic named time-outs</source>
          <target state="translated">多个通用命名超时</target>
        </trans-unit>
        <trans-unit id="8b65c69f112a6d8c5b4685ec30e6ffdcf36c27c8" translate="yes" xml:space="preserve">
          <source>Multiple, thread-specific instances of the allocator. This option has only effect on the runtime system with SMP support. Default behavior on the runtime system with SMP support is &lt;code&gt;NoSchedulers+1&lt;/code&gt; instances. Each scheduler uses a lock-free instance of its own and other threads use a common instance.</source>
          <target state="translated">分配器的多个线程特定实例。此选项仅对具有SMP支持的运行时系统有效。具有SMP支持的运行时系统上的默认行为是 &lt;code&gt;NoSchedulers+1&lt;/code&gt; 实例。每个调度程序使用其自己的无锁实例，其他线程使用一个公共实例。</target>
        </trans-unit>
        <trans-unit id="2f6d5d47eb24e552ff49945236f4445a4cf174f2" translate="yes" xml:space="preserve">
          <source>Multiple-line comments as in C, &lt;code&gt;/* ... */&lt;/code&gt;, are supported.</source>
          <target state="translated">支持多行注释，如C， &lt;code&gt;/* ... */&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1914a937f0807f0283547ebd09066fb830cf5d9a" translate="yes" xml:space="preserve">
          <source>Must be seconds since or before Unix time epoch, which is 1970-01-01 00:00 UTC.</source>
          <target state="translated">必须是Unix时间纪元(即1970-01-01 00:00 UTC)之后或之前的秒数。</target>
        </trans-unit>
        <trans-unit id="0a004964de291cbe488f9f8bc3e151f3bcd7aa7b" translate="yes" xml:space="preserve">
          <source>Must be set to &lt;code&gt;0&lt;/code&gt; for a regular NIF. If the emulator was built with dirty scheduler support enabled, &lt;code&gt;flags&lt;/code&gt; can be set to either &lt;code&gt;ERL_NIF_DIRTY_JOB_CPU_BOUND&lt;/code&gt; if the job is expected to be CPU-bound, or &lt;code&gt;ERL_NIF_DIRTY_JOB_IO_BOUND&lt;/code&gt; for jobs that will be I/O-bound. If dirty scheduler threads are not available in the emulator, an attempt to schedule such a job results in a &lt;code&gt;notsup&lt;/code&gt; exception.</source>
          <target state="translated">对于常规NIF，必须将其设置为 &lt;code&gt;0&lt;/code&gt; 。如果仿真器是在启用了脏调度程序支持的情况下构建的，则可以将 &lt;code&gt;flags&lt;/code&gt; 设置为 &lt;code&gt;ERL_NIF_DIRTY_JOB_CPU_BOUND&lt;/code&gt; (如果预期该作业是CPU绑定的），或者将 &lt;code&gt;ERL_NIF_DIRTY_JOB_IO_BOUND&lt;/code&gt; 为ERL_NIF_DIRTY_JOB_IO_BOUND（对于将要进行I / O绑定的作业）。如果仿真器中没有脏的调度程序线程，则尝试调度此类作业的尝试将导致 &lt;code&gt;notsup&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="d99a3b8cea5bf9690f0427b0ac08c915ac93008c" translate="yes" xml:space="preserve">
          <source>Must be used with and be later than &lt;code&gt;StartTime&lt;/code&gt;. Values of &lt;code&gt;StopTime&lt;/code&gt; in the future are valid. This parameter is of type &lt;code&gt;dateTime&lt;/code&gt; and compliant to RFC 3339. Implementations must support time zones.</source>
          <target state="translated">必须与 &lt;code&gt;StartTime&lt;/code&gt; 一起使用，并且必须晚于StartTime。将来的 &lt;code&gt;StopTime&lt;/code&gt; 值有效。此参数的类型为 &lt;code&gt;dateTime&lt;/code&gt; ,并符合RFC3339。实现必须支持时区。</target>
        </trans-unit>
        <trans-unit id="343d9e25c8247ada5612875ca81c9f7947f3e480" translate="yes" xml:space="preserve">
          <source>Must denote a valid date and time.</source>
          <target state="translated">必须表示有效的日期和时间。</target>
        </trans-unit>
        <trans-unit id="1fa6f6533bff6aa5b9533df23cf9344981b03f0c" translate="yes" xml:space="preserve">
          <source>Must initiate data for a port. We do not create any sockets here, only initialize data structures.</source>
          <target state="translated">必须为一个 port 启动数据。我们在这里不创建任何套接字,只初始化数据结构。</target>
        </trans-unit>
        <trans-unit id="ac5b330f1d3ccf5e6f1d498219f9f2b403798468" translate="yes" xml:space="preserve">
          <source>Must of the functions below has an optional &lt;code&gt;Extra&lt;/code&gt; argument (e.g. &lt;code&gt;&lt;a href=&quot;#unexpected_trans&quot;&gt;handle_unexpected_trans/4&lt;/a&gt;&lt;/code&gt;). The functions which takes this argument will be called if and only if one of the functions &lt;code&gt;&lt;a href=&quot;megaco#receive_message&quot;&gt;receive_message/5&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;megaco#process_received_message&quot;&gt;process_received_message/5&lt;/a&gt;&lt;/code&gt; was called with the &lt;code&gt;Extra&lt;/code&gt; argument different than &lt;code&gt;ignore_extra&lt;/code&gt;.</source>
          <target state="translated">下面的功能必须具有一个可选的 &lt;code&gt;Extra&lt;/code&gt; 参数（例如 &lt;code&gt;&lt;a href=&quot;#unexpected_trans&quot;&gt;handle_unexpected_trans/4&lt;/a&gt;&lt;/code&gt; ）。仅当以下情况下才调用采用此参数的函数：仅当函数 &lt;code&gt;&lt;a href=&quot;megaco#receive_message&quot;&gt;receive_message/5&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;megaco#process_received_message&quot;&gt;process_received_message/5&lt;/a&gt;&lt;/code&gt; 中的一个函数使用 &lt;code&gt;Extra&lt;/code&gt; 参数不同于 &lt;code&gt;ignore_extra&lt;/code&gt; 时才被调用。</target>
        </trans-unit>
        <trans-unit id="7ffc4b83d53a4262e348ddeab52e859129df93ad" translate="yes" xml:space="preserve">
          <source>Mutual exclusion lock. Used for synchronizing access to shared data. Only one thread at a time can lock a mutex.</source>
          <target state="translated">相互排斥锁。用于同步访问共享数据。每次只有一个线程可以锁定一个互斥锁。</target>
        </trans-unit>
        <trans-unit id="928b7c48a60ad93b81bc3bee9d274c5f2aed9ad3" translate="yes" xml:space="preserve">
          <source>Myanmar</source>
          <target state="translated">Myanmar</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="19a21faf21159c116d212d930e958b4e48e27561" translate="yes" xml:space="preserve">
          <source>N | 0</source>
          <target state="translated">N | 0</target>
        </trans-unit>
        <trans-unit id="53110edb9232b435b7ecd44976ac1b46ea9cd99d" translate="yes" xml:space="preserve">
          <source>N'</source>
          <target state="translated">N'</target>
        </trans-unit>
        <trans-unit id="5372a9a248f9a06cc2f439c7194a9046904b1126" translate="yes" xml:space="preserve">
          <source>N/A means not accessible.</source>
          <target state="translated">N/A表示无法访问。</target>
        </trans-unit>
        <trans-unit id="0604b491f5fa41cfffff730fb0a22dcd65418e3f" translate="yes" xml:space="preserve">
          <source>N1</source>
          <target state="translated">N1</target>
        </trans-unit>
        <trans-unit id="65bb4fc755e8bb11ccb0ee8cbfedee5528535446" translate="yes" xml:space="preserve">
          <source>N2</source>
          <target state="translated">N2</target>
        </trans-unit>
        <trans-unit id="70c7d4c52124c93b637e59dd435f7ca991164c3f" translate="yes" xml:space="preserve">
          <source>N3</source>
          <target state="translated">N3</target>
        </trans-unit>
        <trans-unit id="ce71d863e71837e0ee26dc56978e19026728b6e0" translate="yes" xml:space="preserve">
          <source>N4</source>
          <target state="translated">N4</target>
        </trans-unit>
        <trans-unit id="d3406dc507b393378bb88f5316f07b7c31cea1fd" translate="yes" xml:space="preserve">
          <source>N5</source>
          <target state="translated">N5</target>
        </trans-unit>
        <trans-unit id="ee2493b90e1342d0219ace167d7fdfeb9ab6a044" translate="yes" xml:space="preserve">
          <source>NC</source>
          <target state="translated">NC</target>
        </trans-unit>
        <trans-unit id="66bebc7980918515be0940e1250f00a7cdb2a30c" translate="yes" xml:space="preserve">
          <source>NETCONF client module.</source>
          <target state="translated">.NETCONF客户端模块。</target>
        </trans-unit>
        <trans-unit id="b64c6c7cdb62874f32c03bc2fb48dabf64192bed" translate="yes" xml:space="preserve">
          <source>NETCONF sessions can either be opened by a single call to &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt; or by a call to &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1,2&lt;/a&gt;&lt;/code&gt; followed by one or more calls to &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1,2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">NETCONF会话可以通过对 &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt; 的单个调用或对 &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1,2&lt;/a&gt;&lt;/code&gt; 的调用，然后对 &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1,2,3&lt;/a&gt;&lt;/code&gt; 的一个或多个调用来打开。</target>
        </trans-unit>
        <trans-unit id="6cc17604486656396f55bda1048a9ca72c9fb9fd" translate="yes" xml:space="preserve">
          <source>NETCONF traffic is not logged.</source>
          <target state="translated">不记录NETCONF流量。</target>
        </trans-unit>
        <trans-unit id="57b93faae8cfee3611b3f0966ad1cb1ad092f30f" translate="yes" xml:space="preserve">
          <source>NIF libraries are loaded by calling &lt;code&gt;erlang:load_nif/2&lt;/code&gt;, with the name of the shared library as argument. The second argument can be any term that will be passed on to the library and used for initialization:</source>
          <target state="translated">通过调用 &lt;code&gt;erlang:load_nif/2&lt;/code&gt; ，以共享库的名称作为参数来加载NIF库。第二个参数可以是将传递给库并用于初始化的任何术语：</target>
        </trans-unit>
        <trans-unit id="f7f5adb8aa2205182a8ae0d0874dfd09d3d15439" translate="yes" xml:space="preserve">
          <source>NIFs were introduced in Erlang/OTP R13B03 as an experimental feature. It is a simpler and more efficient way of calling C-code than using port drivers. NIFs are most suitable for synchronous functions, such as &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; in the example, that do some relatively short calculations without side effects and return the result.</source>
          <target state="translated">NIF是作为实验功能引入Erlang / OTP R13B03中的。这是比使用端口驱动程序更简单，更有效的C代码调用方式。NIF最适用于同步函数，例如本例中的 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt; ，它们执行一些相对短的计算而没有副作用，并返回结果。</target>
        </trans-unit>
        <trans-unit id="dc50c726c2ad84ad90f8b5f7018cdda7d604c92c" translate="yes" xml:space="preserve">
          <source>NPTL glibc is strongly preferred, or a LinuxThreads glibc configured for &quot;floating stacks&quot;. Old non-floating stacks glibcs have a fundamental problem that makes HiPE support and threads support mutually exclusive.</source>
          <target state="translated">强烈推荐NPTL glibc,或者是为 &quot;浮动堆栈 &quot;配置的LinuxThreads glibc。旧的非浮动堆栈glibc有一个根本性的问题,使得HiPE支持和线程支持相互排斥。</target>
        </trans-unit>
        <trans-unit id="a707e05e3576a19dcc3c4c0b3a0f37a4d4a79406" translate="yes" xml:space="preserve">
          <source>NUMA node identifiers are system wide. That is, each NUMA node on the system must have a unique identifier. Processor identifiers are also system wide. Core identifiers are processor wide. Thread identifiers are core wide.</source>
          <target state="translated">NUMA节点标识符是全系统的。也就是说,系统中的每个NUMA节点必须有一个唯一的标识符。处理器标识符也是全系统的。核心标识符是处理器范围的。线程标识符是核心范围的。</target>
        </trans-unit>
        <trans-unit id="96ca732e61f2bdd45036bc7061a358ac23542609" translate="yes" xml:space="preserve">
          <source>NUMERIC (precision, scale), DECIMAL (precision, scale), DEC (precision, scale ) precision - total number of digits, scale - total number of decimal places</source>
          <target state="translated">NUMERIC(精度,刻度),DECIMAL(精度,刻度),DEC(精度,刻度)精度--数字总数,刻度--小数点总数。</target>
        </trans-unit>
        <trans-unit id="5c4cdee3ac47988555d2e4826cdf0ce2779c7bcd" translate="yes" xml:space="preserve">
          <source>Nabataean</source>
          <target state="translated">Nabataean</target>
        </trans-unit>
        <trans-unit id="49842eacbc9108e11c13f4f1a82e44c7d5e94e3e" translate="yes" xml:space="preserve">
          <source>Name = atom()</source>
          <target state="translated">名称=atom()</target>
        </trans-unit>
        <trans-unit id="09b603578ce92bd3efd6f652e0314619369218a8" translate="yes" xml:space="preserve">
          <source>Name and value of a TFTP option.</source>
          <target state="translated">TFTP选项的名称和值。</target>
        </trans-unit>
        <trans-unit id="c0f9e377e9e709bae968b8e8e63298cf66b15bba" translate="yes" xml:space="preserve">
          <source>Name collisions is another unwanted effect that can occur in multi file-compilation. The compiler solves this problem in one of two ways:</source>
          <target state="translated">名称碰撞是多文件编译中可能出现的另一个不必要的影响。编译器用两种方式解决这个问题。</target>
        </trans-unit>
        <trans-unit id="8fcf8ecda81b9b18e00c6dd548525fd833fd2355" translate="yes" xml:space="preserve">
          <source>Name identifying a Diameter application in service configuration. Passed to &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; when sending requests defined by the application.</source>
          <target state="translated">在服务配置中标识Diameter应用程序的名称。发送应用程序定义的请求时传递给 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="71819df6815dce60c7b749d24399fc212153d954" translate="yes" xml:space="preserve">
          <source>Name listing, that is, gives a list of all names registered on the host</source>
          <target state="translated">名称列表,即给出在主机上注册的所有名称的列表。</target>
        </trans-unit>
        <trans-unit id="8558c62ee07217f1a409e574c1eed556f16d0d5a" translate="yes" xml:space="preserve">
          <source>Name of a configuration parameter.</source>
          <target state="translated">配置参数的名称。</target>
        </trans-unit>
        <trans-unit id="fdd675b8843afe95f166148e521e9af5572f2c5b" translate="yes" xml:space="preserve">
          <source>Name of a service as passed to &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; and with which the service is identified. There can be at most one service with a given name on a given node. Note that &lt;code&gt;erlang:make_ref/0&lt;/code&gt; can be used to generate a service name that is somewhat unique.</source>
          <target state="translated">传递给 &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; 的服务名称，用于标识服务。给定节点上最多可以有一个具有给定名称的服务。注意， &lt;code&gt;erlang:make_ref/0&lt;/code&gt; 可用于生成有点唯一的服务名称。</target>
        </trans-unit>
        <trans-unit id="b9e1cf8d6c3186f4d60ebb503a782d0a2af71404" translate="yes" xml:space="preserve">
          <source>Name of an application included in the release.</source>
          <target state="translated">该版本中包含的应用程序的名称。</target>
        </trans-unit>
        <trans-unit id="8f09bbb27e998d8b4e1d54c80a6e9f9e419ecbbe" translate="yes" xml:space="preserve">
          <source>Name of an encode/decode module for the Diameter messages defined by the application. These modules are generated from files whose format is documented in &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">应用程序定义的Diameter消息的编码/解码模块的名称。这些模块是从文件中生成的，这些文件的格式记录在 &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="fea55da9488bc6b080a2d195d952706c2922e0f1" translate="yes" xml:space="preserve">
          <source>Name of another &lt;code&gt;.config&lt;/code&gt; file. Extension &lt;code&gt;.config&lt;/code&gt; can be omitted. It is recommended to use absolute paths. If a relative path is used, &lt;code&gt;File&lt;/code&gt; is searched, first, relative from &lt;code&gt;sys.config&lt;/code&gt; directory, then relative to the current working directory of the emulator, for backward compatibility. This allow to use a &lt;code&gt;sys.config&lt;/code&gt; pointing out other &lt;code&gt;.config&lt;/code&gt; files in a release or in a node started manually using &lt;code&gt;-config ...&lt;/code&gt; with same result whatever the current working directory.</source>
          <target state="translated">另一个 &lt;code&gt;.config&lt;/code&gt; 文件的名称。扩展名 &lt;code&gt;.config&lt;/code&gt; 可以省略。建议使用绝对路径。如果使用相对路径，则首先从 &lt;code&gt;sys.config&lt;/code&gt; 目录中搜索相对文件，然后从模拟器的当前工作目录中搜索 &lt;code&gt;File&lt;/code&gt; ，以实现向后兼容性。这允许使用 &lt;code&gt;sys.config&lt;/code&gt; 来指出发行版或使用 &lt;code&gt;-config ...&lt;/code&gt; 手动启动的节点中的其他 &lt;code&gt;.config&lt;/code&gt; 文件，无论当前工作目录是什么，其结果都相同。</target>
        </trans-unit>
        <trans-unit id="6861f1ccaff61ef5f193977a356660fc3597d944" translate="yes" xml:space="preserve">
          <source>Name of the module implementing the service-specific parts of the channel.</source>
          <target state="translated">实现通道中特定服务部分的模块名称。</target>
        </trans-unit>
        <trans-unit id="22d1ae1c673a94829dfb8e83a7bb9cf9e8965d80" translate="yes" xml:space="preserve">
          <source>Name of the node that the event originated from (only relevant for &lt;code&gt;Common Test&lt;/code&gt; Master event handlers).</source>
          <target state="translated">事件起源的节点的名称（仅与 &lt;code&gt;Common Test&lt;/code&gt; Master事件处理程序有关）。</target>
        </trans-unit>
        <trans-unit id="b760b08100c634abc56d0ded647804bdc7f195fd" translate="yes" xml:space="preserve">
          <source>Name of the other node. This field is only mandatory when this node initiates the connection. That is, when connection is set up via &lt;code&gt;&lt;a href=&quot;#setup&quot;&gt;setup/5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">另一个节点的名称。仅当此节点启动连接时，此字段才是必填字段。也就是说，通过 &lt;code&gt;&lt;a href=&quot;#setup&quot;&gt;setup/5&lt;/a&gt;&lt;/code&gt; 建立连接时。</target>
        </trans-unit>
        <trans-unit id="dc0f0987cfc3071fee54739de9248fcf0b3b84b9" translate="yes" xml:space="preserve">
          <source>Name of the profile, see &lt;code&gt;&lt;a href=&quot;#DATA_TYPES&quot;&gt;DATA TYPES&lt;/a&gt;&lt;/code&gt;. This option is mandatory.</source>
          <target state="translated">配置文件的名称，请参阅 &lt;code&gt;&lt;a href=&quot;#DATA_TYPES&quot;&gt;DATA TYPES&lt;/a&gt;&lt;/code&gt; 。此选项是必需的。</target>
        </trans-unit>
        <trans-unit id="7ca26e64b9064a42da13098416e3e7bb4bf4ed2c" translate="yes" xml:space="preserve">
          <source>Name of the reporting supervisor.</source>
          <target state="translated">报告主管的姓名。</target>
        </trans-unit>
        <trans-unit id="dfdc16cf0a3aafa431b5fbcdc7de5f060dd8e75e" translate="yes" xml:space="preserve">
          <source>Name of the security data file. The filename can either be absolute or relative to the &lt;code&gt;server_root&lt;/code&gt;. This file is used to store persistent data for module &lt;code&gt;mod_security&lt;/code&gt;.</source>
          <target state="translated">安全数据文件的名称。文件名可以是绝对文件名，也可以是相对于 &lt;code&gt;server_root&lt;/code&gt; 的文件名。该文件用于存储模块 &lt;code&gt;mod_security&lt;/code&gt; 的持久数据。</target>
        </trans-unit>
        <trans-unit id="815591c3d2946d084be9c0e9370d8e5d2a5e8031" translate="yes" xml:space="preserve">
          <source>Name of the user callback module. See the the reference manual for megaco_user for more info.</source>
          <target state="translated">用户回调模块的名称。更多信息请参考megaco_user的参考手册。</target>
        </trans-unit>
        <trans-unit id="f29ab265b46a1c65a2110325442c0296db3b5e7b" translate="yes" xml:space="preserve">
          <source>Name specification to use when starting a &lt;code&gt;gen_statem&lt;/code&gt; server. See &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;server_ref()&lt;/a&gt;&lt;/code&gt; below.</source>
          <target state="translated">启动 &lt;code&gt;gen_statem&lt;/code&gt; 服务器时使用的名称规范。请参阅下面的 &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;server_ref()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8f752f803e242b87f3c03a4082c687998ac3da7" translate="yes" xml:space="preserve">
          <source>Named lock or named set of locks (classes). The same name used for initializing the lock in the VM.</source>
          <target state="translated">命名的锁或命名的锁集(类)。用于初始化虚拟机中的锁的相同名称。</target>
        </trans-unit>
        <trans-unit id="e9dd77b6e1709773eb7654ae6b320bce9c21508d" translate="yes" xml:space="preserve">
          <source>Names consist of up to 32 alphanumeric characters and underscores, but must start with a non-digit. Named capturing parentheses are still allocated numbers as well as names, exactly as if the names were not present. The &lt;code&gt;capture&lt;/code&gt; specification to &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; can use named values if they are present in the regular expression.</source>
          <target state="translated">名称最多由32个字母数字字符和下划线组成，但必须以非数字开头。命名捕获括号仍然分配有数字和名称，就像没有名称一样。如果正则表达式中存在命名为 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;capture&lt;/code&gt; 规范，则可以使用它们。</target>
        </trans-unit>
        <trans-unit id="7093792812d2bcab51e7c92258df5d9e6b4b018a" translate="yes" xml:space="preserve">
          <source>Names of files needed by the test</source>
          <target state="translated">测试所需文件的名称</target>
        </trans-unit>
        <trans-unit id="7257f798528c7c674ee2f8465b8c5680983ef6ca" translate="yes" xml:space="preserve">
          <source>Names of programs to be executed during the test</source>
          <target state="translated">测试期间要执行的程序名称</target>
        </trans-unit>
        <trans-unit id="8df9c18f0f6605c9864c1c03438f7d9bd20d3dfe" translate="yes" xml:space="preserve">
          <source>Names used to identify capturing subpatterns need not be unique. This can be helpful for certain types of pattern when it is known that only one instance of the named subpattern can ever be matched. More details of named subpatterns are provided below.</source>
          <target state="translated">用于识别捕获子模式的名称不一定是唯一的。当已知命名的子模式只有一个实例可以被匹配时,这对某些类型的模式是有帮助的。下面提供了命名子模式的更多细节。</target>
        </trans-unit>
        <trans-unit id="400c3476c738eefb94528ac0d99970ee7cad1461" translate="yes" xml:space="preserve">
          <source>Nameservers</source>
          <target state="translated">Nameservers</target>
        </trans-unit>
        <trans-unit id="d081bf458b12ded79224fc426e9b704fda3eb830" translate="yes" xml:space="preserve">
          <source>Nanoseconds</source>
          <target state="translated">Nanoseconds</target>
        </trans-unit>
        <trans-unit id="69fd8f514808c906504e870b76d0ad25cb1a2810" translate="yes" xml:space="preserve">
          <source>Narrow no-break space</source>
          <target state="translated">狭窄的无缝隙空间</target>
        </trans-unit>
        <trans-unit id="19cf0fcc0b86f78ec04f6f1388bfa92de80267cc" translate="yes" xml:space="preserve">
          <source>Native atomic implementation in the order preferred:</source>
          <target state="translated">原生原子实现的顺序为首选。</target>
        </trans-unit>
        <trans-unit id="f4ceb03af949e9762ac45be133b29937865498db" translate="yes" xml:space="preserve">
          <source>Native lookup (system calls) is always the default resolver method. This is true for all platforms, except VxWorks and OSE Delta where &lt;code&gt;'file'&lt;/code&gt; or &lt;code&gt;'dns'&lt;/code&gt; is used (in that priority order).</source>
          <target state="translated">本机查找（系统调用）始终是默认的解析器方法。这适用于所有平台，但VxWorks和OSE Delta除外（使用 &lt;code&gt;'file'&lt;/code&gt; 或 &lt;code&gt;'dns'&lt;/code&gt; （按优先级顺序））。</target>
        </trans-unit>
        <trans-unit id="2f3e991d2e06301019e7df6974c400874b1e24a9" translate="yes" xml:space="preserve">
          <source>Native-endian means that the endianness is resolved at load time to be either big-endian or little-endian, depending on what is native for the CPU that the Erlang machine is run on. Endianness only matters when the Type is either &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, &lt;code&gt;utf32&lt;/code&gt;, or &lt;code&gt;float&lt;/code&gt;. The default is &lt;code&gt;big&lt;/code&gt;.</source>
          <target state="translated">Native-endian意味着在加载时将endianness解析为big-endian或little-endian，具体取决于运行Erlang机器的CPU的本机内容。仅当Type为 &lt;code&gt;integer&lt;/code&gt; ， &lt;code&gt;utf16&lt;/code&gt; ， &lt;code&gt;utf32&lt;/code&gt; 或 &lt;code&gt;float&lt;/code&gt; 时，字节顺序才重要。默认值为 &lt;code&gt;big&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88ec7eb1fe551ab56659dcb328c9e9308618cdd5" translate="yes" xml:space="preserve">
          <source>Need 10 bytes, plus the space for the node name, which is an atom.</source>
          <target state="translated">需要10个字节,加上节点名称的空间,这是一个原子。</target>
        </trans-unit>
        <trans-unit id="dfe1c4e24186450c5c19fcf8debfad6318586391" translate="yes" xml:space="preserve">
          <source>Need 3 bytes, plus 1 byte for each character (the terminating 0 is not encoded). Really long strings (more than 64k characters) are encoded as lists. Atoms cannot contain more than 256 characters.</source>
          <target state="translated">需要3个字节,加上每个字符的1个字节(末端的0不编码)。真正的长字符串(超过64k个字符)被编码为列表。原子不能包含超过256个字符。</target>
        </trans-unit>
        <trans-unit id="6a2629810e6dae5fd2ed18399d49c9f6234b2d75" translate="yes" xml:space="preserve">
          <source>Need 32 bytes.</source>
          <target state="translated">需要32个字节。</target>
        </trans-unit>
        <trans-unit id="dd1ab6a463a6a8cb3b094e2a5ffe579607280a5c" translate="yes" xml:space="preserve">
          <source>Need 5 bytes, plus the space for each element, and 1 more byte for the empty list at the end.</source>
          <target state="translated">需要5个字节,加上每个元素的空格,最后再加一个字节作为空列表。</target>
        </trans-unit>
        <trans-unit id="0331bba0a243dd4f934fa2e9828a630bcd871f86" translate="yes" xml:space="preserve">
          <source>Need 5 bytes, plus the space for each element.</source>
          <target state="translated">需要5个字节,加上每个元素的空间。</target>
        </trans-unit>
        <trans-unit id="c0aabf92511a79ab04e6d0216eff8b4f3d2d00af" translate="yes" xml:space="preserve">
          <source>Need 5 bytes.</source>
          <target state="translated">需要5个字节。</target>
        </trans-unit>
        <trans-unit id="175e1f869033a45b5e96e2f6f2ecaeb8e97b007a" translate="yes" xml:space="preserve">
          <source>Need 6 bytes, plus the space for the node name, which is an atom.</source>
          <target state="translated">需要6个字节,加上节点名称的空间,这是一个原子。</target>
        </trans-unit>
        <trans-unit id="1156c7af2383ba07233854d7dd710d317bc45336" translate="yes" xml:space="preserve">
          <source>Negate a filter.</source>
          <target state="translated">拒绝过滤。</target>
        </trans-unit>
        <trans-unit id="20692085423110f20958119048a05722032e1bc2" translate="yes" xml:space="preserve">
          <source>Negate the class, but only if the first character</source>
          <target state="translated">否定该类,但只有当第一个字符是</target>
        </trans-unit>
        <trans-unit id="f153dc3672bdd71d80e9c27aa57b80cf24f1ae5f" translate="yes" xml:space="preserve">
          <source>Negated character class, which matches any character except &lt;code&gt;abc...&lt;/code&gt;.</source>
          <target state="translated">否定的字符类，它匹配除 &lt;code&gt;abc...&lt;/code&gt; 之外的任何字符。</target>
        </trans-unit>
        <trans-unit id="de3797823858d972e58f40676bf0b9c8044164ac" translate="yes" xml:space="preserve">
          <source>Negated versions, such as [:^alpha:], use \P instead of \p. Three other POSIX classes are handled specially in UCP mode:</source>
          <target state="translated">否定的版本,如[:^alpha:],使用\P代替\p。另外三个POSIX类在UCP模式下被特殊处理。</target>
        </trans-unit>
        <trans-unit id="ea9c2b442d3489fafed30d313fd4bb83f3a5f3ae" translate="yes" xml:space="preserve">
          <source>Negates its single argument (anything other than &lt;code&gt;false&lt;/code&gt; gives &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">否定它的一个参数（其它任何东西比 &lt;code&gt;false&lt;/code&gt; 给 &lt;code&gt;false&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9ed6e5275d882c1d7a3e78254834d37cdc3ae869" translate="yes" xml:space="preserve">
          <source>Negative assertions are, however, different, to ensure that changing a positive assertion into a negative assertion changes its result. Backtracking into (*COMMIT), (*SKIP), or (*PRUNE) causes a negative assertion to be true, without considering any further alternative branches in the assertion. Backtracking into (*THEN) causes it to skip to the next enclosing alternative within the assertion (the normal behavior), but if the assertion does not have such an alternative, (*THEN) behaves like (*PRUNE).</source>
          <target state="translated">然而,负断言是不同的,以确保将正断言变为负断言会改变其结果。回溯到(*COMMIT)、(*SKIP)或(*PRUNE)会导致一个否定断言为真,而不考虑断言中的任何进一步的替代分支。回溯到(*THEN)会使它跳转到断言中的下一个封闭的替代分支(正常行为),但如果断言中没有这样的替代分支,(*THEN)的行为就像(*PRUNE)。</target>
        </trans-unit>
        <trans-unit id="ebf32ee53eee5495ff25445bebe98e3b2f6d93ca" translate="yes" xml:space="preserve">
          <source>Negative length can be used to extract bytes at the end of a binary, for example:</source>
          <target state="translated">例如,负长度可以用来提取二进制末尾的字节。</target>
        </trans-unit>
        <trans-unit id="b5a05483241f86212e46d2efad89e6999eecd1d1" translate="yes" xml:space="preserve">
          <source>Nested test cases:</source>
          <target state="translated">嵌套测试用例。</target>
        </trans-unit>
        <trans-unit id="127f49081f658cece5f3811cf0dc1334ffa1512f" translate="yes" xml:space="preserve">
          <source>Nested transactions</source>
          <target state="translated">嵌套交易</target>
        </trans-unit>
        <trans-unit id="9d178bd65e3d29cc6434618a4937bb2f5c582992" translate="yes" xml:space="preserve">
          <source>Net if must send the following message when it receives an SNMP PDU from the network that is aimed for the MasterAgent:</source>
          <target state="translated">当收到来自网络的针对MasterAgent的SNMP PDU时,Net if必须发送以下消息。</target>
        </trans-unit>
        <trans-unit id="8f62bf25b466c186d1af5cfde979303cd21e7891" translate="yes" xml:space="preserve">
          <source>Net load mode. Loads all recompiled modules on all known nodes.</source>
          <target state="translated">净加载模式。在所有已知节点上加载所有重新编译的模块。</target>
        </trans-unit>
        <trans-unit id="0114e1a690d0d3b69edf39a672c8130542ac6aac" translate="yes" xml:space="preserve">
          <source>Net tick time-out.</source>
          <target state="translated">净蜱超时。</target>
        </trans-unit>
        <trans-unit id="110548035d847260e8d0a9e8d8ce3832b7e46903" translate="yes" xml:space="preserve">
          <source>Never derefrence aliases, treat aliases as entries.</source>
          <target state="translated">切勿贬损别名,将别名视为条目。</target>
        </trans-unit>
        <trans-unit id="daa1ec0c63bdc175afef3521716bd266db3aa640" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;InfoItem&lt;/code&gt;s can be added and old undocumented &lt;code&gt;InfoItem&lt;/code&gt;s can be removed without notice.</source>
          <target state="translated">可以添加新的 &lt;code&gt;InfoItem&lt;/code&gt; ,而可以删除未 &lt;code&gt;InfoItem&lt;/code&gt; 的旧InfoItem，恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="65a81bf26d684841baa361ac6ddd6963f7889e13" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;InfoKey&lt;/code&gt;s can be added and old undocumented &lt;code&gt;InfoKey&lt;/code&gt;s can be removed without notice.</source>
          <target state="translated">可以添加新的 &lt;code&gt;InfoKey&lt;/code&gt; ,而可以删除未 &lt;code&gt;InfoKey&lt;/code&gt; 的旧InfoKey，恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="25dfab9ef64421c944663406fd9382ff81ddcbe8" translate="yes" xml:space="preserve">
          <source>New AVPs can be defined using the dictionary interface. Both RFC data formats and extensions are supported.</source>
          <target state="translated">可以使用字典接口定义新的AVP。同时支持RFC数据格式和扩展。</target>
        </trans-unit>
        <trans-unit id="5416773a10d805e30e6f5bc99d1554c94eafc798" translate="yes" xml:space="preserve">
          <source>New applications can be defined using the dictionary interface.</source>
          <target state="translated">新的应用程序可以使用字典接口来定义。</target>
        </trans-unit>
        <trans-unit id="416932539df1b3d2d48bade29a12d73c261c20c5" translate="yes" xml:space="preserve">
          <source>New commands can be defined using the dictionary interface.</source>
          <target state="translated">可以使用字典接口定义新的命令。</target>
        </trans-unit>
        <trans-unit id="b21bafe5e2b543d12417c1f410bfa49ddc920dfa" translate="yes" xml:space="preserve">
          <source>New maps can include multiple associations at construction by listing every association:</source>
          <target state="translated">新地图可以在建设时包括多个协会,列出每个协会。</target>
        </trans-unit>
        <trans-unit id="6664f56a53edf8b2fadc61d9507782caf98822df" translate="yes" xml:space="preserve">
          <source>New replicas can be added before all other replicas of the table have been loaded, provided that at least one other replica is active.</source>
          <target state="translated">在表的所有其他副本被加载之前,可以添加新的副本,条件是至少有一个其他副本处于活动状态。</target>
        </trans-unit>
        <trans-unit id="d04bdf4b4e76aa242a32e437a5883cf844d9d4b7" translate="yes" xml:space="preserve">
          <source>New schemas are created explicitly with the function &lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema/1&lt;/a&gt;&lt;/code&gt; or implicitly by starting &lt;code&gt;Mnesia&lt;/code&gt; without a disc resident schema. Whenever a table (including the schema table) is created, it is assigned its own unique cookie. The schema table is not created with the function &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table/2&lt;/a&gt;&lt;/code&gt; as normal tables.</source>
          <target state="translated">使用功能 &lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema/1&lt;/a&gt;&lt;/code&gt; 显式创建新模式，或者在没有光盘驻留模式的情况下启动 &lt;code&gt;Mnesia&lt;/code&gt; 隐式创建新模式。每当创建表（包括模式表）时，都会为其分配自己的唯一cookie。模式表不是使用函数 &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table/2&lt;/a&gt;&lt;/code&gt; 作为普通表创建的。</target>
        </trans-unit>
        <trans-unit id="b998dd3bf2b993a54515b2681267a6568c0a6475" translate="yes" xml:space="preserve">
          <source>New shell (&lt;code&gt;erlang-shell&lt;/code&gt;) - Starts a new Erlang shell.</source>
          <target state="translated">New shell（ &lt;code&gt;erlang-shell&lt;/code&gt; ）-启动新的Erlang Shell。</target>
        </trans-unit>
        <trans-unit id="aa4c2977862e2e3f49c4b7dd716229ca641b9204" translate="yes" xml:space="preserve">
          <source>New warnings may be issued between releases.</source>
          <target state="translated">在两次发布之间可能会发出新的警告。</target>
        </trans-unit>
        <trans-unit id="47cc38a5f6affc6fd9f8a8683e76dfafa574aed8" translate="yes" xml:space="preserve">
          <source>New_Tai_Lue</source>
          <target state="translated">New_Tai_Lue</target>
        </trans-unit>
        <trans-unit id="d706a7f27906e3a8bf4f4fed0f9c3d7edc4a240a" translate="yes" xml:space="preserve">
          <source>Newline</source>
          <target state="translated">Newline</target>
        </trans-unit>
        <trans-unit id="808b78209485244b8997d57758391c54f156212c" translate="yes" xml:space="preserve">
          <source>Newline (line feed).</source>
          <target state="translated">新线(换行)。</target>
        </trans-unit>
        <trans-unit id="5afff985ebf32e8270418f54db6417fb06d959ae" translate="yes" xml:space="preserve">
          <source>Newline is indicated by a single character &lt;code&gt;cr&lt;/code&gt; (ASCII 13).</source>
          <target state="translated">换行符由单个字符 &lt;code&gt;cr&lt;/code&gt; （ASCII 13）表示。</target>
        </trans-unit>
        <trans-unit id="e0b583b651d9a2285954a06341ac73241bded628" translate="yes" xml:space="preserve">
          <source>Newline is indicated by a single character CR (ASCII 13).</source>
          <target state="translated">新行用单个字符CR(ASCII 13)表示。</target>
        </trans-unit>
        <trans-unit id="9187e5ffa24cd194b0938789b60c4fc382a957ab" translate="yes" xml:space="preserve">
          <source>Newline is indicated by a single character LF (ASCII 10), the default.</source>
          <target state="translated">新行用一个字符LF(ASCII 10)表示,这是默认的。</target>
        </trans-unit>
        <trans-unit id="d601bad3ec62c50f75f6a3ba9573e21733220395" translate="yes" xml:space="preserve">
          <source>Newline is indicated by the two-character CRLF (ASCII 13 followed by ASCII 10) sequence.</source>
          <target state="translated">新行由两个字符的CRLF(ASCII 13和ASCII 10)序列表示。</target>
        </trans-unit>
        <trans-unit id="18d8a520a75d3617fd621fe2e386b1424f0b50e7" translate="yes" xml:space="preserve">
          <source>Next come the &lt;code&gt;grammar rules&lt;/code&gt;. Each rule has the general form</source>
          <target state="translated">接下来是 &lt;code&gt;grammar rules&lt;/code&gt; 。每个规则都有一般形式</target>
        </trans-unit>
        <trans-unit id="857695141b6b6a959a5e9f08218ec562945d5a77" translate="yes" xml:space="preserve">
          <source>Next comes a declaration of the &lt;code&gt;nonterminal categories&lt;/code&gt; to be used in the rules. For example:</source>
          <target state="translated">接下来是要在规则中使用的 &lt;code&gt;nonterminal categories&lt;/code&gt; 的声明。例如：</target>
        </trans-unit>
        <trans-unit id="e83a4b5708be5e10a3a091382f374fd5808b3211" translate="yes" xml:space="preserve">
          <source>Next comes a declaration of the &lt;code&gt;rootsymbol&lt;/code&gt;, or start category of the grammar. For example:</source>
          <target state="translated">接下来是 &lt;code&gt;rootsymbol&lt;/code&gt; 的声明，即语法的开始类别。例如：</target>
        </trans-unit>
        <trans-unit id="fef9750a2a463281a998e47d19f0d0871be00c7d" translate="yes" xml:space="preserve">
          <source>Next comes a declaration of the &lt;code&gt;terminal categories&lt;/code&gt;, which are the categories of tokens produced by the scanner. For example:</source>
          <target state="translated">接下来是 &lt;code&gt;terminal categories&lt;/code&gt; 的声明，终端类别是扫描程序生成的令牌的类别。例如：</target>
        </trans-unit>
        <trans-unit id="c9e370493e9e17b4819d6f79d261d079cacde553" translate="yes" xml:space="preserve">
          <source>Next comes one or more declarations of &lt;code&gt;operator precedences&lt;/code&gt;, if needed. These are used to resolve shift/reduce conflicts (see &lt;code&gt;yacc&lt;/code&gt; documentation).</source>
          <target state="translated">如果需要，接下来是一个或多个 &lt;code&gt;operator precedences&lt;/code&gt; 声明。这些用于解决移位/减少冲突（请参见 &lt;code&gt;yacc&lt;/code&gt; 文档）。</target>
        </trans-unit>
        <trans-unit id="0f7553f74bd8b74cc4fcc22ad756157cb5776f2f" translate="yes" xml:space="preserve">
          <source>Next is an example of using &lt;code&gt;after&lt;/code&gt;. This closes the file, even in the event of exceptions in &lt;code&gt;file:read/2&lt;/code&gt; or in &lt;code&gt;binary_to_term/1&lt;/code&gt;. The exceptions are the same as without the &lt;code&gt;try&lt;/code&gt;...&lt;code&gt;after&lt;/code&gt;...&lt;code&gt;end&lt;/code&gt; expression:</source>
          <target state="translated">接下来是使用 &lt;code&gt;after&lt;/code&gt; 的示例。即使在 &lt;code&gt;file:read/2&lt;/code&gt; 或 &lt;code&gt;binary_to_term/1&lt;/code&gt; 中发生异常的情况下，这也会关闭文件。异常与不使用 &lt;code&gt;try&lt;/code&gt; ... &lt;code&gt;after&lt;/code&gt; ... &lt;code&gt;end&lt;/code&gt; 表达式的情况相同：</target>
        </trans-unit>
        <trans-unit id="baf40b5d188d7e3554eac9acbf598ea4267e238b" translate="yes" xml:space="preserve">
          <source>Next is an example of using &lt;code&gt;try&lt;/code&gt; to emulate &lt;code&gt;catch Expr&lt;/code&gt;:</source>
          <target state="translated">接下来是一个使用 &lt;code&gt;try&lt;/code&gt; 仿真 &lt;code&gt;catch Expr&lt;/code&gt; 的示例：</target>
        </trans-unit>
        <trans-unit id="c4092f0a830b3e6796bef07ac155e4adee4739ca" translate="yes" xml:space="preserve">
          <source>Next line (NEL)</source>
          <target state="translated">下一行(NEL)</target>
        </trans-unit>
        <trans-unit id="49c36c588e423f9755f10724b38b806cab7bb00b" translate="yes" xml:space="preserve">
          <source>Next the system to be analyzed is added to the Xref server. Here the system will be OTP, so no library path will be needed. Otherwise, when analyzing a system that uses OTP, the OTP modules are typically made library modules by setting the library path to the default OTP code path (or to &lt;code&gt;code_path&lt;/code&gt;, see the &lt;code&gt;&lt;a href=&quot;xref#code_path&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt;). By default, the names of read BEAM files and warnings are output when adding analyzed modules, but these messages can be avoided by setting default values of some options:</source>
          <target state="translated">接下来，将要分析的系统添加到外部参照服务器。这里的系统将是OTP，因此不需要库路径。否则，在分析使用OTP的系统时，通常通过将库路径设置为默认OTP代码路径（或设置为 &lt;code&gt;code_path&lt;/code&gt; ，请参见 &lt;code&gt;&lt;a href=&quot;xref#code_path&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt; ）来将OTP模块制成库模块。默认情况下，添加分析的模块时会输出读取的BEAM文件的名称和警告，但是可以通过设置某些选项的默认值来避免这些消息：</target>
        </trans-unit>
        <trans-unit id="80d521b3788a65371a641f56d5e8d11c4ad08f4b" translate="yes" xml:space="preserve">
          <source>Next transaction id. A positive integer or the atom &lt;code&gt;undefined_serial&lt;/code&gt; (only in case of error).</source>
          <target state="translated">下一个交易ID。正整数或原子 &lt;code&gt;undefined_serial&lt;/code&gt; （仅在发生错误的情况下）。</target>
        </trans-unit>
        <trans-unit id="0defe52a66513a79940e5ab6dc6388b2167016ac" translate="yes" xml:space="preserve">
          <source>Next we handle the different requests, first the fairly generic multi-request type:</source>
          <target state="translated">接下来我们处理不同的请求,首先是相当通用的多请求类型。</target>
        </trans-unit>
        <trans-unit id="d2101e96703268b0a370202e8ee193996232f211" translate="yes" xml:space="preserve">
          <source>Next, the two higher order functions &lt;code&gt;pand&lt;/code&gt; and &lt;code&gt;por&lt;/code&gt; are defined. They combine primitive parsers to produce more complex parsers.</source>
          <target state="translated">接下来，定义了两个更高阶的函数 &lt;code&gt;pand&lt;/code&gt; 和 &lt;code&gt;por&lt;/code&gt; 。它们结合了原始解析器以产生更复杂的解析器。</target>
        </trans-unit>
        <trans-unit id="55674258a28777513c3ee8a1247d68d39b7e5128" translate="yes" xml:space="preserve">
          <source>Nko</source>
          <target state="translated">Nko</target>
        </trans-unit>
        <trans-unit id="cf9ccefe9fbda77917b667cca9134ccee3903031" translate="yes" xml:space="preserve">
          <source>Nlen</source>
          <target state="translated">Nlen</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="306df27b0e9baa7048471bce2f90b4c62b83a515" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;CLASSPATH&lt;/code&gt; or anything is needed. Type &lt;code&gt;javac&lt;/code&gt; in the bash prompt and you should get a list of available Java options. Make sure, e.g by typing &lt;code&gt;type java&lt;/code&gt;, that you use the Java you installed. Note however that Cygwin's/MinGW's/MSYS2's &lt;code&gt;jar.exe&lt;/code&gt; is used. That's why the JDK bin-directory should be added last in the &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">不需要 &lt;code&gt;CLASSPATH&lt;/code&gt; 或其他任何东西。在bash提示符下键入 &lt;code&gt;javac&lt;/code&gt; ，您应该获得可用Java选项的列表。确保（例如，通过键入 &lt;code&gt;type java&lt;/code&gt; 键入）使用已安装的Java。但是请注意，使用的是Cygwin / MinGW / MSYS2的 &lt;code&gt;jar.exe&lt;/code&gt; 。这就是为什么要在 &lt;code&gt;PATH&lt;/code&gt; 的最后添加JDK bin目录的原因。</target>
        </trans-unit>
        <trans-unit id="20123f437cbed011ee99b107692f5a0de92f5b78" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;OTP_VERSION&lt;/code&gt; file is placed in a &lt;code&gt;&lt;a href=&quot;create_target&quot;&gt;target system&lt;/a&gt;&lt;/code&gt; created by OTP tools. This since one easily can create a target system where it is hard to even determine the base OTP version. You can, however, place such a file there if you know the OTP version.</source>
          <target state="translated">OTP工具创建的 &lt;code&gt;&lt;a href=&quot;create_target&quot;&gt;target system&lt;/a&gt;&lt;/code&gt; 未放置任何 &lt;code&gt;OTP_VERSION&lt;/code&gt; 文件。这是因为可以轻松创建目标系统，甚至很难确定基本OTP版本。但是，如果您知道OTP版本，则可以在其中放置这样的文件。</target>
        </trans-unit>
        <trans-unit id="b26bf8ba2172d52337372f5408c0374da428f07b" translate="yes" xml:space="preserve">
          <source>No available CPU topology. That is, the runtime system was not able to detect the CPU topology automatically, and no &lt;code&gt;&lt;a href=&quot;#+sct&quot;&gt;user-defined CPU topology&lt;/a&gt;&lt;/code&gt; was set.</source>
          <target state="translated">没有可用的CPU拓扑。即，运行时系统无法自动检测CPU拓扑，并且未设置 &lt;code&gt;&lt;a href=&quot;#+sct&quot;&gt;user-defined CPU topology&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a85ad1a848cbb91f4217ade2f8af6dd92f90a8ce" translate="yes" xml:space="preserve">
          <source>No channel is started. This is done by calling &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/[2, 4]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">没有通道启动。这是通过调用 &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/[2, 4]&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fddf0f31436a33dc7eb65b7e662b0a272aad9fa5" translate="yes" xml:space="preserve">
          <source>No character in the Unicode table has the Cn (unassigned) property. This property is instead assumed for any code point that is not in the Unicode table.</source>
          <target state="translated">Unicode表中没有任何字符具有Cn(未分配)属性。而对于Unicode表中没有的任何码点,都会假设这个属性。</target>
        </trans-unit>
        <trans-unit id="dc57d984725306844c55a6e549f5434351f897bb" translate="yes" xml:space="preserve">
          <source>No execution mode. Just prints the name of each module that needs to be compiled.</source>
          <target state="translated">没有执行模式。只是打印每个需要编译的模块名称。</target>
        </trans-unit>
        <trans-unit id="4f359a331e2d8e32338d669077706cc69d91dc7c" translate="yes" xml:space="preserve">
          <source>No file with object code exists.</source>
          <target state="translated">不存在带有对象代码的文件。</target>
        </trans-unit>
        <trans-unit id="13241af56c130b238829c77fe317f13857c53de0" translate="yes" xml:space="preserve">
          <source>No file with object code was found.</source>
          <target state="translated">没有找到带有对象代码的文件。</target>
        </trans-unit>
        <trans-unit id="440071f450e51e9d450fcc9382feef4bf2695f38" translate="yes" xml:space="preserve">
          <source>No files are compressed.</source>
          <target state="translated">没有文件被压缩。</target>
        </trans-unit>
        <trans-unit id="0dc01295326d7bbe83d6152968ff814da6bb7e65" translate="yes" xml:space="preserve">
          <source>No form of peer discovery is implemented. The user can implement this independently of diameter if required.</source>
          <target state="translated">没有实现对等体发现的形式。如果需要,用户可以独立于直径来实现。</target>
        </trans-unit>
        <trans-unit id="72c55b9244448dbb0de0232a0eac2de1afdad171" translate="yes" xml:space="preserve">
          <source>No garbage collection was performed, as the process identified by &lt;code&gt;Pid&lt;/code&gt; terminated before the request could be satisfied.</source>
          <target state="translated">没有执行垃圾收集，因为由 &lt;code&gt;Pid&lt;/code&gt; 标识的过程在满足请求之前已终止。</target>
        </trans-unit>
        <trans-unit id="2f23a91f9bb422d0761d2bc7e964443f6476d113" translate="yes" xml:space="preserve">
          <source>No locks are released when child transactions terminate. Locks created by a sequence of nested transactions are kept until the topmost transaction terminates. Furthermore, any update performed by a nested transaction is only propagated in such a manner so that the parent of the nested transaction sees the updates. No final commitment is done until the top-level transaction terminates. So, although a nested transaction returns &lt;code&gt;{atomic, Val}&lt;/code&gt;, if the enclosing parent transaction terminates, the entire nested operation terminates.</source>
          <target state="translated">子事务终止时不会释放任何锁。保留由一系列嵌套事务创建的锁，直到最顶层的事务终止。此外，仅以这种方式传播由嵌套事务执行的任何更新，以使嵌套事务的父级看到更新。在顶级交易终止之前，不会做出任何最终承诺。因此，尽管嵌套事务返回 &lt;code&gt;{atomic, Val}&lt;/code&gt; ，但是如果封闭的父事务终止，则整个嵌套操作也会终止。</target>
        </trans-unit>
        <trans-unit id="f674a37123f0ffc3506454e7b55512d60713fa52" translate="yes" xml:space="preserve">
          <source>No matching branch is found when evaluating a &lt;code&gt;case&lt;/code&gt; expression. The value &lt;code&gt;V&lt;/code&gt; did not match.</source>
          <target state="translated">评估 &lt;code&gt;case&lt;/code&gt; 表达式时，找不到匹配的分支。值 &lt;code&gt;V&lt;/code&gt; 不匹配。</target>
        </trans-unit>
        <trans-unit id="7043cf82452e810d5c16d3e477ed93f700205d66" translate="yes" xml:space="preserve">
          <source>No matching branch is found when evaluating the of-section of a &lt;code&gt;try&lt;/code&gt; expression. The value &lt;code&gt;V&lt;/code&gt; did not match.</source>
          <target state="translated">评估 &lt;code&gt;try&lt;/code&gt; 表达式的部分时，找不到匹配的分支。值 &lt;code&gt;V&lt;/code&gt; 不匹配。</target>
        </trans-unit>
        <trans-unit id="bafda3e67a73a9fac5366e727d20ddc61884e3fb" translate="yes" xml:space="preserve">
          <source>No matching function clause is found when evaluating a function call.</source>
          <target state="translated">在评估一个函数调用时,没有找到匹配的函数子句。</target>
        </trans-unit>
        <trans-unit id="b154fd09fbcc9049abbeb9b2cae25aa1de56f340" translate="yes" xml:space="preserve">
          <source>No more available OS processes.</source>
          <target state="translated">没有更多可用的操作系统进程。</target>
        </trans-unit>
        <trans-unit id="30a54d12705f7304413a1180c01d997ab6369210" translate="yes" xml:space="preserve">
          <source>No more available file descriptors (for the OS process that the Erlang emulator runs in).</source>
          <target state="translated">没有更多可用的文件描述符(针对Erlang模拟器运行的操作系统进程)。</target>
        </trans-unit>
        <trans-unit id="a8ffa3b27d199208e567b9f7e6b61c30d8a4fd15" translate="yes" xml:space="preserve">
          <source>No more memory is available.</source>
          <target state="translated">没有更多的内存可用。</target>
        </trans-unit>
        <trans-unit id="bf3f0d88be368d141ccef5093be9613bf0c9230c" translate="yes" xml:space="preserve">
          <source>No network is available.</source>
          <target state="translated">没有网络。</target>
        </trans-unit>
        <trans-unit id="c489474600adaec621c887ab5f0e2e6aff78625a" translate="yes" xml:space="preserve">
          <source>No new options can be added, but those present in &lt;code&gt;SuggestedOptions&lt;/code&gt; can be omitted or replaced with new values in &lt;code&gt;AcceptedOptions&lt;/code&gt;.</source>
          <target state="translated">不能添加任何新选项，但是， &lt;code&gt;SuggestedOptions&lt;/code&gt; 中存在的选项可以省略，也可以用 &lt;code&gt;AcceptedOptions&lt;/code&gt; 中的新值替换。</target>
        </trans-unit>
        <trans-unit id="cccb01175197e57cc2cc371d3deb57037c621f92" translate="yes" xml:space="preserve">
          <source>No object code is found. It is assumed that the source code and object code are located either in the same directory, or in &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;ebin&lt;/code&gt; directories next to each other.</source>
          <target state="translated">找不到目标代码。假定源代码和目标代码位于同一目录中，或者位于彼此相邻的 &lt;code&gt;src&lt;/code&gt; 和 &lt;code&gt;ebin&lt;/code&gt; 目录中。</target>
        </trans-unit>
        <trans-unit id="a11ca60fca56c33b2c64441ebd0092b5a2034edf" translate="yes" xml:space="preserve">
          <source>No object with the correct key exists and no default object was supplied.</source>
          <target state="translated">没有正确键的对象存在,也没有提供默认对象。</target>
        </trans-unit>
        <trans-unit id="01bb309c51c64719a36ff0535eb3f933818be49b" translate="yes" xml:space="preserve">
          <source>No optimization was found. A match specification matching all objects is used if &lt;code&gt;TraverseFun&lt;/code&gt; is unary.</source>
          <target state="translated">找不到优化。如果 &lt;code&gt;TraverseFun&lt;/code&gt; 一元，则使用匹配所有对象的匹配规范。</target>
        </trans-unit>
        <trans-unit id="cd5da193599373a0a6119b861beeeab1a8bf22a1" translate="yes" xml:space="preserve">
          <source>No other support is available within this module that would guarantee consistency between objects. However, function &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; can be used to guarantee that a sequence of &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; calls traverse the table without errors and that each existing object in the table is visited exactly once, even if another (or the same) process simultaneously deletes or inserts objects into the table. Nothing else is guaranteed; in particular objects that are inserted or deleted during such a traversal can be visited once or not at all. Functions that internally traverse over a table, like &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match&lt;/a&gt;&lt;/code&gt;, give the same guarantee as &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此模块中没有其他可保证对象之间一致性的支持。但是，可以使用函数 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 来确保 &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; 调用序列可以无错误地遍历表，并且即使另一个（或相同的）进程也可以对表中的每个现有对象进行一次精确访问。同时删除对象或将对象插入表中。没有其他保证。特别是在这种遍历过程中插入或删除的对象只能被访问一次或根本不被访问。内部遍历表的函数（例如 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match&lt;/a&gt;&lt;/code&gt; ）的保证与 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="cd17e64205667c500758839414e3602b81b56476" translate="yes" xml:space="preserve">
          <source>No packaging is done.</source>
          <target state="translated">不做包装。</target>
        </trans-unit>
        <trans-unit id="ba80c47298de4f4f293a1e5e303c27b3b69db4f4" translate="yes" xml:space="preserve">
          <source>No packet handling is done. The entire binary is returned unless it is empty.</source>
          <target state="translated">不进行数据包处理。除非是空的,否则会返回整个二进制。</target>
        </trans-unit>
        <trans-unit id="ca6f2c7da1bb311124b43ce0e8411af0807caf66" translate="yes" xml:space="preserve">
          <source>No persistent information is updated, so these functions can be used on any Erlang node, embedded or not. Also, using these functions does not affect which code is loaded if there is a reboot.</source>
          <target state="translated">不会更新任何持久性信息,所以这些函数可以在任何Erlang节点上使用,无论是否嵌入。另外,如果有重启,使用这些函数也不会影响加载哪些代码。</target>
        </trans-unit>
        <trans-unit id="05eb06aea519cecedac753c3c3fc222e914de94b" translate="yes" xml:space="preserve">
          <source>No problems were found during the analysis and no warnings were emitted.</source>
          <target state="translated">分析过程中未发现问题,未发出警告。</target>
        </trans-unit>
        <trans-unit id="c647cf715eac6879d4c3134da30ff7c15996866b" translate="yes" xml:space="preserve">
          <source>No problems were found during the analysis, but warnings were emitted.</source>
          <target state="translated">分析过程中没有发现问题,但发出了警告。</target>
        </trans-unit>
        <trans-unit id="bd4d5686ec105c4061bf6d87bd047c5882b61b8e" translate="yes" xml:space="preserve">
          <source>No separate (variable) packages are generated. Applications that are found underneath a variable directory are ignored.</source>
          <target state="translated">不会生成单独的(变量)包。在变量目录下找到的应用程序将被忽略。</target>
        </trans-unit>
        <trans-unit id="c2645af938c8d0d4b9ae8e002cf483a4d95efd04" translate="yes" xml:space="preserve">
          <source>No source code is found. It is assumed that the source code and object code are located either in the same directory, or in &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;ebin&lt;/code&gt; directories next to each other.</source>
          <target state="translated">找不到源代码。假定源代码和目标代码位于同一目录中，或者位于彼此相邻的 &lt;code&gt;src&lt;/code&gt; 和 &lt;code&gt;ebin&lt;/code&gt; 目录中。</target>
        </trans-unit>
        <trans-unit id="c80de0efbf261d9e095f902e0f2d665fd88ad9d3" translate="yes" xml:space="preserve">
          <source>No space is left on the device.</source>
          <target state="translated">设备上不留空间。</target>
        </trans-unit>
        <trans-unit id="db50afb4ab4c477aba8edc312545bbe5ac56992b" translate="yes" xml:space="preserve">
          <source>No such file or directory, or directory already exists, or permission denied.</source>
          <target state="translated">没有这样的文件或目录,或目录已经存在,或权限被拒绝。</target>
        </trans-unit>
        <trans-unit id="861215d646ab11b3c7364a81ae9819205bd22341" translate="yes" xml:space="preserve">
          <source>No such type.</source>
          <target state="translated">没有这种类型。</target>
        </trans-unit>
        <trans-unit id="6f3f7a13db71f33cfa022de055c35c8dce0c2f17" translate="yes" xml:space="preserve">
          <source>No syntax rule definitions or other declarations may follow this section. To avoid conflicts with internal variables, do not use variable names beginning with two underscore characters ('__') in the Erlang code in this section, or in the code associated with the individual syntax rules.</source>
          <target state="translated">本节之后不得有语法规则定义或其他声明。为了避免与内部变量发生冲突,在本节的Erlang代码中,或者在与各个语法规则相关的代码中,不要使用以两个下划线字符('__')开头的变量名。</target>
        </trans-unit>
        <trans-unit id="56bd79ad5b51fb7729ca3566ff1b2fd96321741b" translate="yes" xml:space="preserve">
          <source>No trace outputs. This is the default.</source>
          <target state="translated">无跟踪输出。这是默认值。</target>
        </trans-unit>
        <trans-unit id="1bcae2b67b6703a4dda088ac83adf2fa3c139258" translate="yes" xml:space="preserve">
          <source>No true branch is found when evaluating an &lt;code&gt;if&lt;/code&gt; expression.</source>
          <target state="translated">评估 &lt;code&gt;if&lt;/code&gt; 表达式时，找不到真正的分支。</target>
        </trans-unit>
        <trans-unit id="eda586f9e6ba047d97471f1bf9867a4ab7b5c6e7" translate="yes" xml:space="preserve">
          <source>No trusted CA was found in the trusted store. The trusted CA is normally a so called ROOT CA, which is a self-signed certificate. Trust can be claimed for an intermediate CA (trusted anchor does not have to be self-signed according to X-509) by using option &lt;code&gt;partial_chain&lt;/code&gt;.</source>
          <target state="translated">在信任的存储中找不到信任的CA。可信CA通常是所谓的ROOT CA，它是一个自签名证书。可以使用选项 &lt;code&gt;partial_chain&lt;/code&gt; 声明对中间CA的信任（受信任的锚不必根据X-509自签名）。</target>
        </trans-unit>
        <trans-unit id="51620f6ec27898e6c0fbd64ab1461dbab02323bd" translate="yes" xml:space="preserve">
          <source>No way of finding all possible answers by looking up keys was found, but the filters could be transformed into a match specification. All answers are found by calling &lt;code&gt;TraverseFun(MatchExpression)&lt;/code&gt;.</source>
          <target state="translated">找不到通过查找键找到所有可能答案的方法，但是可以将过滤器转换为匹配规范。通过调用 &lt;code&gt;TraverseFun(MatchExpression)&lt;/code&gt; 可以找到所有答案。</target>
        </trans-unit>
        <trans-unit id="54c13c8fd7aa90de3fb8911bcf7fa43f2889a260" translate="yes" xml:space="preserve">
          <source>Node name of remote node. To be passed along to &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">远程节点的节点名称。传递给 &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="777c88d4603f4203bbb592ad1459cf50c6255ac4" translate="yes" xml:space="preserve">
          <source>Node name of this node. To be passed along to &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">该节点的节点名称。传递给 &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9eae106cd79565d2506dacd99d934bb27987eb1e" translate="yes" xml:space="preserve">
          <source>Node name of this node. To be passed along to &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">该节点的节点名称。传递给 &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4609ded8720acb4a14254c4923dd53fe7c48e94" translate="yes" xml:space="preserve">
          <source>Node name, &lt;code&gt;node&lt;/code&gt;</source>
          <target state="translated">节点名称， &lt;code&gt;node&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07577846f355b02783c690185edc121991468e96" translate="yes" xml:space="preserve">
          <source>Node table entries that are not referred linger in the table for at least the amount of time that this parameter determines. The lingering prevents repeated deletions and insertions in the tables from occurring.</source>
          <target state="translated">未被引用的节点表项在表中滞留的时间至少为该参数确定的时间量。滞留可以防止表内重复删除和插入的情况发生。</target>
        </trans-unit>
        <trans-unit id="609dd2f5616d5def969c38a398d805318ea1a788" translate="yes" xml:space="preserve">
          <source>Nodes can be added to and removed from a &lt;code&gt;Mnesia&lt;/code&gt; system. This can be done by adding a copy of the schema to those nodes.</source>
          <target state="translated">可以将节点添加到 &lt;code&gt;Mnesia&lt;/code&gt; 系统或从中删除。这可以通过将模式的副本添加到那些节点来完成。</target>
        </trans-unit>
        <trans-unit id="6747accaf683f772944ea14fe4c794ccba9b86a1" translate="yes" xml:space="preserve">
          <source>Nodes connected through hidden connections can be monitored as any other nodes.</source>
          <target state="translated">通过隐藏连接的节点可以像其他节点一样被监控。</target>
        </trans-unit>
        <trans-unit id="41e6879915cbf13a3b60e8d7f1f912973f81167b" translate="yes" xml:space="preserve">
          <source>Nodes connected to this node through hidden connections.</source>
          <target state="translated">通过隐藏连接连接到这个节点的节点。</target>
        </trans-unit>
        <trans-unit id="cc5d70b541f8501e9d01ec3e0e4e3fde1b4be2ae" translate="yes" xml:space="preserve">
          <source>Nodes connected to this node through normal connections.</source>
          <target state="translated">通过正常的连接连接到这个节点的节点。</target>
        </trans-unit>
        <trans-unit id="57c1df2289899b41768f671fc1b5ee2f1c0b48d9" translate="yes" xml:space="preserve">
          <source>Nodes from which communicated peers are made available in the remote candidates list of &lt;code&gt;pick_peer/4&lt;/code&gt; callbacks.</source>
          <target state="translated">在 &lt;code&gt;pick_peer/4&lt;/code&gt; 回调的远程候选者列表中，可以使用与之通信的对等节点。</target>
        </trans-unit>
        <trans-unit id="506bf95685aeda7d65c4825675264344d9902300" translate="yes" xml:space="preserve">
          <source>Nodes that are known to this node. That is, connected nodes and nodes referred to by process identifiers, port identifiers, and references located on this node. The set of known nodes is garbage collected. Notice that this garbage collection can be delayed. For more information, see &lt;code&gt;&lt;a href=&quot;erlang#system_info_delayed_node_table_gc&quot;&gt;erlang:system_info(delayed_node_table_gc)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该节点已知的节点。即，连接的节点以及由该节点上的进程标识符，端口标识符和引用引用的节点。已知节点集是垃圾收集的。请注意，此垃圾回收可能会延迟。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;erlang#system_info_delayed_node_table_gc&quot;&gt;erlang:system_info(delayed_node_table_gc)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7afefd4eb39dfd1fda9f65fc8df0dedddd2ab71e" translate="yes" xml:space="preserve">
          <source>Nodes to which peer connections established on the local Erlang node are communicated. Shared peers become available in the remote candidates list passed to &lt;code&gt;pick_peer/4&lt;/code&gt; callbacks on remote nodes whose services are configured to use them: see &lt;code&gt;use_shared_peers&lt;/code&gt; below.</source>
          <target state="translated">与在本地Erlang节点上建立的对等连接的节点进行通信。共享对等方在传递给服务配置为使用它们的远程节点上的 &lt;code&gt;pick_peer/4&lt;/code&gt; 回调的远程候选者列表中变为可用：请参见下面的 &lt;code&gt;use_shared_peers&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ad3afeccc2c07ec40ffda2f6fe1a23dce971210" translate="yes" xml:space="preserve">
          <source>Nodes with an ERTS version earlier than 5.7.2 does not pass the distribution flag that enables the distribution header. Messages passed between nodes have in this case the following format:</source>
          <target state="translated">ERTS版本早于5.7.2的节点不传递启用分发头的分发标志。节点之间传递的消息在这种情况下具有以下格式:</target>
        </trans-unit>
        <trans-unit id="8d28e8cb93663f40b3e02d5f32274b7bcf92428c" translate="yes" xml:space="preserve">
          <source>Nodes with disc database schema must be defined and implemented with the function &lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema(NodeList)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">具有磁盘数据库模式的节点必须使用函数 &lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema(NodeList)&lt;/a&gt;&lt;/code&gt; 定义和实现。</target>
        </trans-unit>
        <trans-unit id="9b1284ec6c573e51f2ee9f680fc573581c6be9d1" translate="yes" xml:space="preserve">
          <source>Noise has a high level as opposed to essentials.</source>
          <target state="translated">噪声相对于本质来说有很高的水平。</target>
        </trans-unit>
        <trans-unit id="a72b2ae853945e5b8956182bbfb749378e193bfd" translate="yes" xml:space="preserve">
          <source>Non-blocking version of &lt;code&gt;&lt;a href=&quot;#yield-1&quot;&gt;yield/1&lt;/a&gt;&lt;/code&gt;. It returns the tuple &lt;code&gt;{value, Val}&lt;/code&gt; when the computation is finished, or &lt;code&gt;timeout&lt;/code&gt; when &lt;code&gt;Timeout&lt;/code&gt; milliseconds has elapsed.</source>
          <target state="translated">非阻塞版本的 &lt;code&gt;&lt;a href=&quot;#yield-1&quot;&gt;yield/1&lt;/a&gt;&lt;/code&gt; 。它返回的元组 &lt;code&gt;{value, Val}&lt;/code&gt; 当计算完成后，或 &lt;code&gt;timeout&lt;/code&gt; 时 &lt;code&gt;Timeout&lt;/code&gt; 毫秒已过。</target>
        </trans-unit>
        <trans-unit id="5f87b67027ba8d1bf675b11281146e26fb2801e6" translate="yes" xml:space="preserve">
          <source>Non-break space</source>
          <target state="translated">非休息空间</target>
        </trans-unit>
        <trans-unit id="1ea42666026a195787b7284149d9b03550517a0d" translate="yes" xml:space="preserve">
          <source>Non-portable hash function that only guarantees the same hash for the same term within one Erlang VM instance.</source>
          <target state="translated">非可移植的哈希函数,只保证在一个Erlang虚拟机实例中,同一术语的哈希值相同。</target>
        </trans-unit>
        <trans-unit id="234a623f6ba9a7ff287ed003837119c0295841fe" translate="yes" xml:space="preserve">
          <source>Non-spacing mark</source>
          <target state="translated">无间隔标记</target>
        </trans-unit>
        <trans-unit id="26b2867ce328c59018c79a884756714da802589b" translate="yes" xml:space="preserve">
          <source>NonCompositeTerm ::= term() (not list or tuple or map)</source>
          <target state="translated">NonCompositeTerm ::=term()(不是 list 或 tuple 或 map)</target>
        </trans-unit>
        <trans-unit id="4c6ddabca28c82e409457c62e73c0bb7ebc8fa48" translate="yes" xml:space="preserve">
          <source>NonLocalFunctionHandler) -&amp;gt;</source>
          <target state="translated">NonLocalFunctionHandler）-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="18ebf28795ec5199819d1e5ac39fe97c6224fefd" translate="yes" xml:space="preserve">
          <source>NonLocalFunctionHandler,</source>
          <target state="translated">NonLocalFunctionHandler,</target>
        </trans-unit>
        <trans-unit id="d6ae77cee906d18da7aaf78a7c7ab33073d61cbe" translate="yes" xml:space="preserve">
          <source>None, but the version number was increased anyway.</source>
          <target state="translated">没有,但版本号还是增加了。</target>
        </trans-unit>
        <trans-unit id="cc969dc2084d0c57d3c3f18672b1cb587110032f" translate="yes" xml:space="preserve">
          <source>Normal Windows NT installation is performed. No additional application programs are needed, such as Internet Explorer or web server. Networking with TCP/IP is required.</source>
          <target state="translated">进行正常的Windows NT安装。不需要额外的应用程序,如Internet Explorer或Web服务器。需要使用TCP/IP进行联网。</target>
        </trans-unit>
        <trans-unit id="e00a61616c0ebb576daec9ce3da5c44b01d68c1a" translate="yes" xml:space="preserve">
          <source>Normal locking requires the following:</source>
          <target state="translated">正常的锁定需要以下几点:</target>
        </trans-unit>
        <trans-unit id="c968deef42bc269fc435a9f4d346232704145288" translate="yes" xml:space="preserve">
          <source>Normal mode, in which text lines can be edited and sent to the shell.</source>
          <target state="translated">普通模式,在该模式下,可以编辑文本行并发送至shell。</target>
        </trans-unit>
        <trans-unit id="c72d62413b1b0e473e04d83afe069f0e8f1245a9" translate="yes" xml:space="preserve">
          <source>Normal schedulers will have scheduler identifiers in the range &lt;code&gt;1 =&amp;lt; SchedulerId =&amp;lt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt;. Dirty CPU schedulers will have scheduler identifiers in the range &lt;code&gt;erlang:system_info(schedulers) &amp;lt; SchedulerId =&amp;lt; erlang:system_info(schedulers) +&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_dirty_cpu_schedulers&quot;&gt;erlang:system_info(dirty_cpu_schedulers)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">普通调度程序的调度程序标识符范围为 &lt;code&gt;1 =&amp;lt; SchedulerId =&amp;lt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; 。肮脏的CPU调度程序将具有 &lt;code&gt;erlang:system_info(schedulers) &amp;lt; SchedulerId =&amp;lt; erlang:system_info(schedulers) +&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_dirty_cpu_schedulers&quot;&gt;erlang:system_info(dirty_cpu_schedulers)&lt;/a&gt;&lt;/code&gt; 范围内的调度程序标识符。</target>
        </trans-unit>
        <trans-unit id="63856520df5f6e7c2b81ba0324073ec61c706fa4" translate="yes" xml:space="preserve">
          <source>Normal-form XML elements can thus be included in the simple-form representation. Note that content lists must be flat. An &lt;code&gt;IOString&lt;/code&gt; is a (possibly deep) list of characters and/or binaries.</source>
          <target state="translated">因此，标准格式的XML元素可以包含在简单格式的表示形式中。请注意，内容列表必须是平坦的。一个 &lt;code&gt;IOString&lt;/code&gt; 是字符和/或二进制文件的一个（可能深）列表。</target>
        </trans-unit>
        <trans-unit id="a74e793a642e0b2e3ac1ab81016078fc7282ff3d" translate="yes" xml:space="preserve">
          <source>Normalizes an issuer name so that it can be easily compared to another issuer name.</source>
          <target state="translated">规范化一个发行人名称,以便于与另一个发行人名称进行比较。</target>
        </trans-unit>
        <trans-unit id="123bb07c3020981f40b2d515466fa01c393f5d17" translate="yes" xml:space="preserve">
          <source>Normally a Media Gateway (MG) connects explicitly while a Media Gateway Controller (MGC) connects implicitly.</source>
          <target state="translated">通常情况下,媒体网关(MG)是显式连接,而媒体网关控制器(MGC)是隐式连接。</target>
        </trans-unit>
        <trans-unit id="62b21d6a5acaba334f3b92e5191990bacc474890" translate="yes" xml:space="preserve">
          <source>Normally a driver instance has no port data lock. If the driver instance wants to use a port data lock, it must create the port data lock by calling &lt;code&gt;&lt;a href=&quot;#driver_pdl_create&quot;&gt;driver_pdl_create&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通常，驱动程序实例没有端口数据锁。如果驱动程序实例要使用端口数据锁，则必须通过调用 &lt;code&gt;&lt;a href=&quot;#driver_pdl_create&quot;&gt;driver_pdl_create&lt;/a&gt;&lt;/code&gt; 来创建端口数据锁。</target>
        </trans-unit>
        <trans-unit id="c68be6d33361ec0e77716005c64c0f636bd81f1e" translate="yes" xml:space="preserve">
          <source>Normally a trusted certificate, but it can also be a path-validation error that can be discovered while constructing the input to this function and that is to be run through the &lt;code&gt;verify_fun&lt;/code&gt;. Examples are &lt;code&gt;unknown_ca&lt;/code&gt; and &lt;code&gt;selfsigned_peer.&lt;/code&gt;</source>
          <target state="translated">通常是受信任的证书，但也可能是路径验证错误，可以在构造此函数的输入时发现该错误，并通过 &lt;code&gt;verify_fun&lt;/code&gt; 运行该错误。示例为 &lt;code&gt;unknown_ca&lt;/code&gt; 和 &lt;code&gt;selfsigned_peer.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c1e2b2f12271535c195bd263adbd772fd1b1450" translate="yes" xml:space="preserve">
          <source>Normally an RSA, DSA or ECDSA public key, but handling of other public keys can be added</source>
          <target state="translated">通常是RSA、DSA或ECDSA公钥,但也可以添加对其他公钥的处理。</target>
        </trans-unit>
        <trans-unit id="32e8583c2f35a0fb6147ddcbc88cc5b16ce06fba" translate="yes" xml:space="preserve">
          <source>Normally an RSA, DSA or ECDSA public key, but handling of other public keys can be added.</source>
          <target state="translated">通常是RSA、DSA或ECDSA公钥,但也可以添加其他公钥的处理。</target>
        </trans-unit>
        <trans-unit id="5a323154df5db7c6023a4765a91c3d178bc3620d" translate="yes" xml:space="preserve">
          <source>Normally an allocator creates a &quot;main multiblock carrier&quot;. Main multiblock carriers are never deallocated. The size of the main multiblock carrier is determined by the value of parameter &lt;code&gt;&lt;a href=&quot;#M_mmbcs&quot;&gt;mmbcs&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通常，分配器创建&amp;ldquo;主多块载波&amp;rdquo;。主多块载波永远不会释放。主多块载波的大小由参数 &lt;code&gt;&lt;a href=&quot;#M_mmbcs&quot;&gt;mmbcs&lt;/a&gt;&lt;/code&gt; 的值确定。</target>
        </trans-unit>
        <trans-unit id="3b4c50780b89a61508f82bc073504b8cf437882c" translate="yes" xml:space="preserve">
          <source>Normally in the range &lt;code&gt;-15..-8 | 8..15&lt;/code&gt;.</source>
          <target state="translated">通常在 &lt;code&gt;-15..-8 | 8..15&lt;/code&gt; 范围内| 8..15。</target>
        </trans-unit>
        <trans-unit id="5a3591546de23ffebac17f3c960ad1cc664b2e7e" translate="yes" xml:space="preserve">
          <source>Normally it is the programmer's responsibility to free each Erlang term that has been returned from any of the &lt;code&gt;Erl_Interface&lt;/code&gt; functions. However, as many of the functions that build new Erlang terms in fact share objects with other existing terms, it can be difficult for the programmer to maintain pointers to all such terms to free them individually.</source>
          <target state="translated">通常，程序员有责任释放从任何 &lt;code&gt;Erl_Interface&lt;/code&gt; 函数返回的每个Erlang术语。但是，由于许多构建新Erlang术语的函数实际上与其他现有术语共享对象，因此程序员难以维护指向所有此类术语的指针以单独释放它们。</target>
        </trans-unit>
        <trans-unit id="1516500c60371d958d26c4174d5a863989b039fb" translate="yes" xml:space="preserve">
          <source>Normally the compiler treats calls to &lt;code&gt;is_record/2&lt;/code&gt; especially. It emits code to verify that &lt;code&gt;Term&lt;/code&gt; is a tuple, that its first element is &lt;code&gt;RecordTag&lt;/code&gt;, and that the size is correct. However, if &lt;code&gt;RecordTag&lt;/code&gt; is not a literal atom, the BIF &lt;code&gt;is_record/2&lt;/code&gt; is called instead and the size of the tuple is not verified.</source>
          <target state="translated">通常，编译器会特别处理对 &lt;code&gt;is_record/2&lt;/code&gt; 的调用。它发出代码以验证 &lt;code&gt;Term&lt;/code&gt; 是一个元组，第一个元素是 &lt;code&gt;RecordTag&lt;/code&gt; 以及大小是否正确。但是，如果 &lt;code&gt;RecordTag&lt;/code&gt; 不是文字原子，则调用BIF &lt;code&gt;is_record/2&lt;/code&gt; ,并且不验证元组的大小。</target>
        </trans-unit>
        <trans-unit id="ca1a7de4987b858f3cc368eec0c0c2caaad58778" translate="yes" xml:space="preserve">
          <source>Normally the compiler verifies that the module name given in the source code is the same as the base name of the output file and refuses to generate an output file if there is a mismatch. If you have a good reason (or other reason) for having a module name unrelated to the name of the output file, this option disables that verification (there will not even be a warning if there is a mismatch).</source>
          <target state="translated">通常情况下,编译器会验证源代码中给出的模块名称是否与输出文件的基本名称相同,如果不匹配,则拒绝生成输出文件。如果你有一个很好的理由(或其他原因)让模块名与输出文件名无关,这个选项就会禁止这种验证(如果有不匹配,甚至不会有警告)。</target>
        </trans-unit>
        <trans-unit id="c85cefd516f432dd52d61776ad47ad9e932cefa9" translate="yes" xml:space="preserve">
          <source>Normally the top directory of an application is located in library directory &lt;code&gt;$OTPROOT/lib&lt;/code&gt; or in a directory referred to by environment variable &lt;code&gt;ERL_LIBS&lt;/code&gt;. At startup, when the initial code path is computed, the code server also looks for archive files in these directories and possibly adds &lt;code&gt;ebin&lt;/code&gt; directories in archives to the code path. The code path then contains paths to directories that look like &lt;code&gt;$OTPROOT/lib/mnesia.ez/mnesia/ebin&lt;/code&gt; or &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin&lt;/code&gt;.</source>
          <target state="translated">通常，应用程序的顶层目录位于库目录 &lt;code&gt;$OTPROOT/lib&lt;/code&gt; 或环境变量 &lt;code&gt;ERL_LIBS&lt;/code&gt; 引用的目录中。在启动时，当计算初始代码路径时，代码服务器还将在这些目录中查找存档文件，并可能将存档中的 &lt;code&gt;ebin&lt;/code&gt; 目录添加到代码路径。然后，代码路径包含指向类似于 &lt;code&gt;$OTPROOT/lib/mnesia.ez/mnesia/ebin&lt;/code&gt; 或 &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16dc8854601f473350bd4444afad1c3e95d0bfe6" translate="yes" xml:space="preserve">
          <source>Normally these are minimal stub implementations that throw an exception. But they can also be used as fallback implementations for functions that do not have native implemenations on some architectures.</source>
          <target state="translated">通常这些都是抛出异常的最小的存根实现,但它们也可以作为某些架构上没有本地实现的函数的后备实现。但它们也可以作为某些架构上没有本地实现的函数的后备实现。</target>
        </trans-unit>
        <trans-unit id="d7e199a9abb107c5708b3c551b3f4ac7d6bc7e25" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;Loaded&lt;/code&gt; is the absolute filename &lt;code&gt;Filename&lt;/code&gt; from which the code is obtained. If the module is preloaded (see &lt;code&gt;script(4)&lt;/code&gt;), &lt;code&gt;Loaded==preloaded&lt;/code&gt;. If the module is Cover-compiled (see &lt;code&gt;cover(3)&lt;/code&gt;), &lt;code&gt;Loaded==cover_compiled&lt;/code&gt;.</source>
          <target state="translated">通常， &lt;code&gt;Loaded&lt;/code&gt; 是从中获取代码的绝对文件名 &lt;code&gt;Filename&lt;/code&gt; 。如果模块已预加载（请参阅 &lt;code&gt;script(4)&lt;/code&gt; ），则 &lt;code&gt;Loaded==preloaded&lt;/code&gt; 。如果模块是Cover编译的（请参见 &lt;code&gt;cover(3)&lt;/code&gt; ），则 &lt;code&gt;Loaded==cover_compiled&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5203fe540eb93014569c65ea374e32f208fcdb8" translate="yes" xml:space="preserve">
          <source>Normally, after a pending message has been received, the request is not resent (since a pending message is an indication that the request has been received). But since the reply (to the request) can be lost, this behaviour has its values.</source>
          <target state="translated">通常情况下,在收到待处理的消息后,请求不会被重新发送(因为待处理的消息表明请求已经收到)。但由于(对请求的)回复可能会丢失,这种行为有其价值。</target>
        </trans-unit>
        <trans-unit id="b537284cd04df03d36bf92033e8259f158494ca4" translate="yes" xml:space="preserve">
          <source>Normally, connections are established automatically when another node is referenced. This functionality can be disabled by setting Kernel configuration parameter &lt;code&gt;dist_auto_connect&lt;/code&gt; to &lt;code&gt;never&lt;/code&gt;, see &lt;code&gt;kernel(6)&lt;/code&gt;. In this case, connections must be established explicitly by calling &lt;code&gt;&lt;a href=&quot;#connect_node-1&quot;&gt;connect_node/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通常，引用另一个节点时会自动建立连接。可以通过将内核配置参数 &lt;code&gt;dist_auto_connect&lt;/code&gt; 设置为 &lt;code&gt;never&lt;/code&gt; 来禁用此功能，请参阅 &lt;code&gt;kernel(6)&lt;/code&gt; 。在这种情况下，必须通过调用 &lt;code&gt;&lt;a href=&quot;#connect_node-1&quot;&gt;connect_node/1&lt;/a&gt;&lt;/code&gt; 显式建立连接。</target>
        </trans-unit>
        <trans-unit id="637694f595e135bf986d734041974495ca2f7d71" translate="yes" xml:space="preserve">
          <source>Normally, the &lt;code&gt;/etc/ssh&lt;/code&gt; directory is only readable by root.</source>
          <target state="translated">通常， &lt;code&gt;/etc/ssh&lt;/code&gt; 目录仅可由root读取。</target>
        </trans-unit>
        <trans-unit id="c133a4bf588437e7a024274a632985a8eb26b1b7" translate="yes" xml:space="preserve">
          <source>Normally, the functions described above behave exactly as shown, but they are free to perform other actions. For example, a get-request may have side effects such as setting some other variable, perhaps a global &lt;code&gt;lastAccessed&lt;/code&gt; variable.</source>
          <target state="translated">通常，上述功能的行为与所示功能完全相同，但是可以自由执行其他操作。例如，get-request可能会有一些副作用，例如设置其他变量，可能是全局 &lt;code&gt;lastAccessed&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="544ca2481d30ca25eb88bc4478419d207c6b42f3" translate="yes" xml:space="preserve">
          <source>Normally, there is no need to worry about the speed of &lt;code&gt;length/1&lt;/code&gt;, because it is efficiently implemented in C. In time-critical code, you might want to avoid it if the input list could potentially be very long.</source>
          <target state="translated">通常，不必担心 &lt;code&gt;length/1&lt;/code&gt; 的速度，因为它可以在C中有效地实现。在时间要求严格的代码中，如果输入列表可能很长，则可能要避免使用它。</target>
        </trans-unit>
        <trans-unit id="432c6c8cb64925afd6f974d52af838a844075bba" translate="yes" xml:space="preserve">
          <source>Normally, when an Erlang process sends to a socket, the driver tries to send the data immediately. If that fails, the driver uses any means available to queue up the message to be sent whenever the operating system says it can handle it. Setting &lt;code&gt;{delay_send, true}&lt;/code&gt; makes &lt;strong&gt;all&lt;/strong&gt; messages queue up. The messages sent to the network are then larger but fewer. The option affects the scheduling of send requests versus Erlang processes instead of changing any real property of the socket. The option is implementation-specific. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">通常，当Erlang进程发送到套接字时，驱动程序会尝试立即发送数据。如果失败，驱动程序将使用任何可用的方法来使要发送的消息排队，只要操作系统说它可以处理它。设置 &lt;code&gt;{delay_send, true}&lt;/code&gt; 会使&lt;strong&gt;所有&lt;/strong&gt;消息排队。这样，发送到网络的消息就更大，但更少。该选项将影响发送请求与Erlang进程的调度，而不是更改套接字的任何实际属性。该选项是特定于实现的。默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fad0923dba8395d1d335b96e476819a3a071dc5" translate="yes" xml:space="preserve">
          <source>Normative References</source>
          <target state="translated">规范性参考文献</target>
        </trans-unit>
        <trans-unit id="4c829414eaf27118bfedf26c7e8237c300423db1" translate="yes" xml:space="preserve">
          <source>Not a &lt;code&gt;pid()&lt;/code&gt;.</source>
          <target state="translated">不是 &lt;code&gt;pid()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c737921363d7d8bbbfc2bf38000b57e386aed1b1" translate="yes" xml:space="preserve">
          <source>Not all functions are provided on all platforms. In particular, the &lt;code&gt;&lt;a href=&quot;#erf-1&quot;&gt;erf/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#erfc-1&quot;&gt;erfc/1&lt;/a&gt;&lt;/code&gt; functions are not provided on Windows.</source>
          <target state="translated">并非所有平台都提供所有功能。特别是，Windows上不提供 &lt;code&gt;&lt;a href=&quot;#erf-1&quot;&gt;erf/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#erfc-1&quot;&gt;erfc/1&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="f60564ddfb74e83034e43211b6dc56c962f055f4" translate="yes" xml:space="preserve">
          <source>Not all systems send signals. For details on valid string values, see RFC 4254, Section 6.10</source>
          <target state="translated">并非所有系统都会发送信号。有关有效字符串值的详细信息,请参见RFC 4254,第6.10节。</target>
        </trans-unit>
        <trans-unit id="a834a9b315fc2a330e09ba52fb9c66fcf454a31e" translate="yes" xml:space="preserve">
          <source>Not being able to control the application remotely</source>
          <target state="translated">无法远程控制应用程序</target>
        </trans-unit>
        <trans-unit id="1a46fcc227b8efe8fe76d1f3917346701207d128" translate="yes" xml:space="preserve">
          <source>Not built-in</source>
          <target state="translated">未内置</target>
        </trans-unit>
        <trans-unit id="e5c26cb1806bfcc16aba23e2bcd43b6fab4a7dce" translate="yes" xml:space="preserve">
          <source>Not enough memory to create the port.</source>
          <target state="translated">没有足够的内存来创建端口。</target>
        </trans-unit>
        <trans-unit id="5a93ba71c6009e894f071984d5a041fabb7da94e" translate="yes" xml:space="preserve">
          <source>Not enough space left to write the file.</source>
          <target state="translated">没有足够的空间来写文件。</target>
        </trans-unit>
        <trans-unit id="b498326e15a92ae0d8b8c9b12f4c1b41ff6d4998" translate="yes" xml:space="preserve">
          <source>Not equal to</source>
          <target state="translated">不等于</target>
        </trans-unit>
        <trans-unit id="46885249352a064243a6dddeac62ab075a4dd8a5" translate="yes" xml:space="preserve">
          <source>Not recommended, as the machine will possibly be inaccessible to interactive users.</source>
          <target state="translated">不建议使用,因为交互式用户可能无法使用该机器。</target>
        </trans-unit>
        <trans-unit id="943fa3c1c3bedd251cb678cfcff592882249becf" translate="yes" xml:space="preserve">
          <source>Not recommended; use &lt;code&gt;&lt;a href=&quot;erlc&quot;&gt;erlc&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">不建议; 请改用 &lt;code&gt;&lt;a href=&quot;erlc&quot;&gt;erlc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a35d63cc7db198d75edb76a9f80fbc617cd6daa6" translate="yes" xml:space="preserve">
          <source>Not unexpectedly, we see that &lt;code&gt;file:write/2&lt;/code&gt; was called from &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; and &lt;code&gt;foo:create_file_slow/2&lt;/code&gt;. The number of calls in each case as well as the used time are also just confirms the previous results.</source>
          <target state="translated">并不意外，我们看到从 &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; 和 &lt;code&gt;foo:create_file_slow/2&lt;/code&gt; 调用了 &lt;code&gt;file:write/2&lt;/code&gt; / 2。每种情况下的通话次数以及使用的时间也只是在确认先前的结果。</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="fb48271e25bdfecded1918413e5015fa92ec99a7" translate="yes" xml:space="preserve">
          <source>Note again that a successfull decode only returns a partially initiated message.</source>
          <target state="translated">请再次注意,一个成功的解码只返回一个部分发起的消息。</target>
        </trans-unit>
        <trans-unit id="8bb5fcd3ca24d41d35ec2f21eaba5915f96c6ec6" translate="yes" xml:space="preserve">
          <source>Note also that the &lt;code&gt;Options&lt;/code&gt; argument comes from the &lt;code&gt;options&lt;/code&gt; config option of the mib-storage config option, and is passed on as is.</source>
          <target state="translated">还要注意， &lt;code&gt;Options&lt;/code&gt; 参数来自mib-storage config选项的 &lt;code&gt;options&lt;/code&gt; config选项，并按原样传递。</target>
        </trans-unit>
        <trans-unit id="0627636f71c6f80361b94f0198da347d52ca866f" translate="yes" xml:space="preserve">
          <source>Note also that the shared group leader (&lt;code&gt;SharedGL&lt;/code&gt;) must never be terminated by the user, only by Common Test. Group leader processes for parallel test case groups (&lt;code&gt;OtherGLs&lt;/code&gt;) may however be terminated in post_end_per_group hook functions.</source>
          <target state="translated">还要注意，共享组长（ &lt;code&gt;SharedGL&lt;/code&gt; ）绝不能由用户终止，只能由Common Test终止。但是，可以在post_end_per_group挂钩函数中终止用于并行测试用例组（ &lt;code&gt;OtherGLs&lt;/code&gt; ）的组负责人进程。</target>
        </trans-unit>
        <trans-unit id="edc2e031b8dd55503b20741805cebfb2cf07a730" translate="yes" xml:space="preserve">
          <source>Note cleanup time. When storing a note in the note store, each note is given lifetime. Every &lt;code&gt;timeout&lt;/code&gt; the note_store process performs a GC to remove the expired note's. Time in milli-seconds.</source>
          <target state="translated">注意清理时间。在便笺存储区中存储便笺时，每个便笺都具有有效期。每次 &lt;code&gt;timeout&lt;/code&gt; ，note_store进程都会执行GC来删除过期的便笺。时间（以毫秒为单位）。</target>
        </trans-unit>
        <trans-unit id="ec5960d916e9578d7d801b0cab9fba678951306b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;LIMIT_MATCH&lt;/code&gt; and &lt;code&gt;LIMIT_RECURSION&lt;/code&gt; can only reduce the value of the limits set by the caller, not increase them.</source>
          <target state="translated">请注意， &lt;code&gt;LIMIT_MATCH&lt;/code&gt; 和 &lt;code&gt;LIMIT_RECURSION&lt;/code&gt; 只能减小调用方设置的限制值，而不能增大它们。</target>
        </trans-unit>
        <trans-unit id="d24e50ca0ad0e8aeae5b135428467a7fb92766a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;verify_fun&lt;/code&gt; needs to be written in a different form than the corresponding SSL/TLS option, since funs are not accepted on the command line.</source>
          <target state="translated">请注意，因为在命令行上不接受乐趣，所以 &lt;code&gt;verify_fun&lt;/code&gt; 需要以与相应的SSL / TLS选项不同的形式编写。</target>
        </trans-unit>
        <trans-unit id="1d1c85c3f2e3a52e04f26f9459fd07fac45960dd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;watchdog&lt;/code&gt;, &lt;code&gt;peer&lt;/code&gt;, &lt;code&gt;apps&lt;/code&gt;, &lt;code&gt;caps&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; entries depend on connectivity with the peer and may not be present. Note also that the &lt;code&gt;statistics&lt;/code&gt; entry presents values accumulated during the lifetime of the transport configuration.</source>
          <target state="translated">请注意， &lt;code&gt;watchdog&lt;/code&gt; ， &lt;code&gt;peer&lt;/code&gt; ，peer， &lt;code&gt;apps&lt;/code&gt; ， &lt;code&gt;caps&lt;/code&gt; 和 &lt;code&gt;port&lt;/code&gt; 条目取决于与同级的连接，因此可能不存在。还要注意， &lt;code&gt;statistics&lt;/code&gt; 条目显示了在传输配置的生存期内累积的值。</target>
        </trans-unit>
        <trans-unit id="336af6e83620751fb885cf9732b59c5d61916d15" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;{error,encode}&lt;/code&gt; is the only return value which guarantees that the request has &lt;strong&gt;not&lt;/strong&gt; been sent over the transport connection.</source>
          <target state="translated">请注意， &lt;code&gt;{error,encode}&lt;/code&gt; 是唯一保证&lt;strong&gt;未&lt;/strong&gt;通过传输连接发送请求的返回值。</target>
        </trans-unit>
        <trans-unit id="d0fdecc142de3ad70dcbabaed28cc8ece32529ae" translate="yes" xml:space="preserve">
          <source>Note that RFC 3588 did not allow 5xxx result codes in answers setting the E-bit, while RFC 6733 does. This is a potential interoperability problem since the Diameter protocol version has not changed.</source>
          <target state="translated">请注意,RFC 3588不允许在设置E位的答案中使用5xxx结果码,而RFC 6733则允许。这是一个潜在的互操作性问题,因为Diameter协议版本没有改变。</target>
        </trans-unit>
        <trans-unit id="383d8ab46c4dd3dcb7dacf32d96619c30112c096" translate="yes" xml:space="preserve">
          <source>Note that RFC 6733 requires that End-to-End Identifiers remain unique for a period of at least 4 minutes and that this and the call rate places a lower bound on appropriate values of &lt;code&gt;N&lt;/code&gt;: at a rate of &lt;code&gt;R&lt;/code&gt; requests per second, an &lt;code&gt;N&lt;/code&gt;-bit counter traverses all of its values in &lt;code&gt;(1 bsl N) div (R*60)&lt;/code&gt; minutes, so the bound is &lt;code&gt;4*R*60 =&amp;lt; 1 bsl N&lt;/code&gt;.</source>
          <target state="translated">请注意，RFC 6733要求端到端标识符在至少4分钟的时间内保持唯一，并且此速率和呼叫速率将 &lt;code&gt;N&lt;/code&gt; 的适当值设置为下限：以每秒 &lt;code&gt;R&lt;/code&gt; 个请求的速率（即 &lt;code&gt;N&lt;/code&gt; 位计数器在 &lt;code&gt;(1 bsl N) div (R*60)&lt;/code&gt; 分钟内遍历其所有值，因此界限为 &lt;code&gt;4*R*60 =&amp;lt; 1 bsl N&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d954d0938e64e5c37a1b11f9fbf14279ee90b30d" translate="yes" xml:space="preserve">
          <source>Note that \0dd is always an octal code, and that \8 and \9 are the literal characters &quot;8&quot; and &quot;9&quot;.</source>
          <target state="translated">请注意,\0dd总是一个八进制代码,\8和\9是字面意义上的 &quot;8 &quot;和 &quot;9&quot;。</target>
        </trans-unit>
        <trans-unit id="dd8f4a584e7baae9c7b73d493c112b4faac49187" translate="yes" xml:space="preserve">
          <source>Note that a dictionary module should have a unique name so as not collide with existing modules in the system.</source>
          <target state="translated">需要注意的是,字典模块应该有一个唯一的名字,这样才不会与系统中现有的模块相冲突。</target>
        </trans-unit>
        <trans-unit id="7d48dfa81ed35ed91309a0c63bf84e4d12b8db94" translate="yes" xml:space="preserve">
          <source>Note that a dictionary's &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;, together with the &lt;code&gt;outdir&lt;/code&gt; option, determine the output paths when the &lt;code&gt;return&lt;/code&gt; option is not specified. The &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; of a literal input dictionary defaults to &lt;code&gt;dictionary&lt;/code&gt;.</source>
          <target state="translated">请注意，当未指定 &lt;code&gt;return&lt;/code&gt; 选项时，字典的 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 和 &lt;code&gt;outdir&lt;/code&gt; 选项一起确定输出路径。文字输入字典的 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 默认为 &lt;code&gt;dictionary&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="592ecd079ddc2c5dbec2876bde4efe18192a7501" translate="yes" xml:space="preserve">
          <source>Note that a distributed node will fail to start if epmd is not running.</source>
          <target state="translated">注意,如果epmd没有运行,分布式节点将无法启动。</target>
        </trans-unit>
        <trans-unit id="210dee4c712f6038124cea11c85e7ab317eb49aa" translate="yes" xml:space="preserve">
          <source>Note that a single &lt;code&gt;up&lt;/code&gt; or &lt;code&gt;down&lt;/code&gt; event for a given peer corresponds to multiple &lt;code&gt;peer_up/3&lt;/code&gt; or &lt;code&gt;peer_down/3&lt;/code&gt; callbacks, one for each of the Diameter applications negotiated during capabilities exchange. That is, the event communicates connectivity with the peer as a whole while the callbacks communicate connectivity with respect to individual Diameter applications.</source>
          <target state="translated">请注意，给定对等方的单个 &lt;code&gt;up&lt;/code&gt; 或 &lt;code&gt;down&lt;/code&gt; 事件对应于多个 &lt;code&gt;peer_up/3&lt;/code&gt; 或 &lt;code&gt;peer_down/3&lt;/code&gt; 回调，其中一个针对在能力交换期间协商的每个Diameter应用程序。也就是说，事件在整体上与对等方通信，而回调在各个Diameter应用程序之间通信。</target>
        </trans-unit>
        <trans-unit id="87238ebabfbb3a6373dc0cd859835703ac206a8a" translate="yes" xml:space="preserve">
          <source>Note that a state enter call &lt;strong&gt;will&lt;/strong&gt; be done right before entering the initial state even though this formally is not a state change. In this case &lt;code&gt;OldState&lt;/code&gt; will be the same as &lt;code&gt;State&lt;/code&gt;, which can not happen for a subsequent state change, but will happen when repeating the state enter call.</source>
          <target state="translated">注意，状态输入调用&lt;strong&gt;将&lt;/strong&gt;在进入初始状态之前立即完成，即使这正式不是状态更改。在这种情况下， &lt;code&gt;OldState&lt;/code&gt; 将与 &lt;code&gt;State&lt;/code&gt; 相同，这在后续的状态更改中不会发生，但在重复状态enter调用时会发生。</target>
        </trans-unit>
        <trans-unit id="cea408404d235688202589e612b275a8ce277c9d" translate="yes" xml:space="preserve">
          <source>Note that all processing is done in the context of the calling process. A transport module could call this function via one of the &lt;code&gt;spawn&lt;/code&gt; functions (e.g. &lt;code&gt;spawn_opt&lt;/code&gt;). See also &lt;code&gt;receive_message/4,5&lt;/code&gt;.</source>
          <target state="translated">注意，所有处理都在调用过程的上下文中完成。传输模块可以通过其中一个 &lt;code&gt;spawn&lt;/code&gt; 函数（例如 &lt;code&gt;spawn_opt&lt;/code&gt; ）调用此函数。另请参见 &lt;code&gt;receive_message/4,5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f01d1482d475dcf2740463e55c6c430cd948d4e9" translate="yes" xml:space="preserve">
          <source>Note that an SMIv2 MIB can import an SMIv1 MIB and vice versa.</source>
          <target state="translated">请注意,一个SMIv2 MIB可以导入一个SMIv1 MIB,反之亦然。</target>
        </trans-unit>
        <trans-unit id="85f6954c77f955dafa6a2e123d05e96d272275df" translate="yes" xml:space="preserve">
          <source>Note that an alias-name is only unique within the mib, so when loading several mib's into a manager, there might be several instances of the same aliasname.</source>
          <target state="translated">请注意,一个别名只有在mib中才是唯一的,所以当把多个mib加载到一个管理器中时,可能会有几个相同的别名实例。</target>
        </trans-unit>
        <trans-unit id="44d8f63bf6bc16034f55c5cb547506223b7f3f16" translate="yes" xml:space="preserve">
          <source>Note that an event time-out does not work well with when you have for example a status call as in &lt;code&gt;&lt;a href=&quot;#All%20State%20Events&quot;&gt;All State Events&lt;/a&gt;&lt;/code&gt;, or handle unknown events, since all kinds of events will cancel the event time-out.</source>
          <target state="translated">请注意，事件超时不适用于例如状态为 &lt;code&gt;&lt;a href=&quot;#All%20State%20Events&quot;&gt;All State Events&lt;/a&gt;&lt;/code&gt; 或处理未知事件的状态调用，因为所有类型的事件都会取消事件超时。</target>
        </trans-unit>
        <trans-unit id="def0f5ad0a0ace41622689a594950eb3fe32da96" translate="yes" xml:space="preserve">
          <source>Note that an inherited AVP that sets the V flag takes its Vendor-Id from either &lt;code&gt;@avp_vendor_id&lt;/code&gt; in the inheriting dictionary or &lt;code&gt;@vendor&lt;/code&gt; in the inherited dictionary. In particular, &lt;code&gt;@avp_vendor_id&lt;/code&gt; in the inherited dictionary is ignored. Inheriting from a dictionary that specifies the required &lt;code&gt;@vendor&lt;/code&gt; is equivalent to using &lt;code&gt;@avp_vendor_id&lt;/code&gt; with a copy of the dictionary's definitions but the former makes for easier reuse.</source>
          <target state="translated">请注意，一个继承的AVP，其设定所述V标志采取它的厂商ID从任 &lt;code&gt;@avp_vendor_id&lt;/code&gt; 在继承字典或 &lt;code&gt;@vendor&lt;/code&gt; 在继承字典。特别是，继承的字典中的 &lt;code&gt;@avp_vendor_id&lt;/code&gt; 将被忽略。从指定所需 &lt;code&gt;@vendor&lt;/code&gt; 的字典继承等效于将 &lt;code&gt;@avp_vendor_id&lt;/code&gt; 与字典定义的副本一起使用，但是前者可以简化重用。</target>
        </trans-unit>
        <trans-unit id="f5995dd05307d17cf1cf0275ae54c1c965044890" translate="yes" xml:space="preserve">
          <source>Note that both lists in &lt;code&gt;cipher&lt;/code&gt; has been changed to the provided value (&lt;code&gt;'aes128-ctr'&lt;/code&gt;).</source>
          <target state="translated">请注意， &lt;code&gt;cipher&lt;/code&gt; 中的两个列表都已更改为提供的值（ &lt;code&gt;'aes128-ctr'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e251f553696cbbe8af62f9b6e14b96ffcbc62108" translate="yes" xml:space="preserve">
          <source>Note that clauses following a default action will be ignored.</source>
          <target state="translated">请注意,默认操作后的子句将被忽略。</target>
        </trans-unit>
        <trans-unit id="0160a9b8ce02f625812816b1ccc97166a7bb4956" translate="yes" xml:space="preserve">
          <source>Note that client_random, server_random and master_secret are values that affect the security of connection. Meaningful atoms, not specified above, are the ssl option names.</source>
          <target state="translated">请注意,client_random、server_random和master_secret是影响连接安全性的值。上面没有指定的有意义的原子是ssl选项名。</target>
        </trans-unit>
        <trans-unit id="1fbc0b27f1c4b9334d7d0f187cdb9b5cc6eedece" translate="yes" xml:space="preserve">
          <source>Note that e.g. the result of &lt;code&gt;atom(&quot;x\ny&quot;)&lt;/code&gt; represents any and all of `x\ny'', `x\12y'', `x\012y'' and `x\^Jy\''; see &lt;code&gt;&lt;a href=&quot;#string-1&quot;&gt;string/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">注意，例如 &lt;code&gt;atom(&quot;x\ny&quot;)&lt;/code&gt; 代表`x \ ny'，`x \ 12y'，`x \ 012y'和`x \ ^ Jy \''中的任何一个和所有；参见 &lt;code&gt;&lt;a href=&quot;#string-1&quot;&gt;string/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba188de7ea4673245bb93e421ced2f5246f6549c" translate="yes" xml:space="preserve">
          <source>Note that each tuple communicates one or more AVP values. It is an error to specify duplicate tuples.</source>
          <target state="translated">请注意,每个元组传递一个或多个AVP值。指定重复的元组是错误的。</target>
        </trans-unit>
        <trans-unit id="edc604b194978efcbdba0cbc4b89b369a9c99a82" translate="yes" xml:space="preserve">
          <source>Note that ec_gf2m is not strictly a public key algorithm, but a restriction on what curves are supported with ecdsa and ecdh.</source>
          <target state="translated">请注意,ec_gf2m并不是严格意义上的公钥算法,而是对ecdsa和ecdh支持哪些曲线的限制。</target>
        </trans-unit>
        <trans-unit id="29cd43d95778b2d115dbf308b03c62ae1c0160c0" translate="yes" xml:space="preserve">
          <source>Note that even if this function returns some &lt;code&gt;Tail&lt;/code&gt; that is not &lt;code&gt;none&lt;/code&gt;, the type of &lt;code&gt;Tail&lt;/code&gt; can be &lt;code&gt;nil&lt;/code&gt;, if the tail has been given explicitly, and the list skeleton has not been compacted (see &lt;code&gt;&lt;a href=&quot;#compact_list-1&quot;&gt;compact_list/1&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">请注意，即使此函数返回的 &lt;code&gt;Tail&lt;/code&gt; 值不是 &lt;code&gt;none&lt;/code&gt; ，如果显式指定了tail且列表框架尚未压缩（请参见 &lt;code&gt;&lt;a href=&quot;#compact_list-1&quot;&gt;compact_list/1&lt;/a&gt;&lt;/code&gt; ），则 &lt;code&gt;Tail&lt;/code&gt; 的类型也可以为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b99d2d0f80623c57fbaf51f6886234e7e4b951d" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;EngineId&lt;/code&gt; has the value &lt;code&gt;discovery&lt;/code&gt;, the agent cannot send &lt;code&gt;inform&lt;/code&gt; messages to that manager until it has performed the &lt;strong&gt;discovery&lt;/strong&gt; process with that manager.</source>
          <target state="translated">请注意，如果 &lt;code&gt;EngineId&lt;/code&gt; 具有 &lt;code&gt;discovery&lt;/code&gt; 值，则代理无法向该管理器发送 &lt;code&gt;inform&lt;/code&gt; 消息，直到它与该管理器执行了&lt;strong&gt;发现&lt;/strong&gt;过程。</target>
        </trans-unit>
        <trans-unit id="55bac8de272758448fe7d117efd8941f423d23e9" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;udp&lt;/code&gt; is used, the same transport process could be used for several connections. This could make upgrading impossible.</source>
          <target state="translated">请注意，如果使用 &lt;code&gt;udp&lt;/code&gt; ，则相同的传输过程可以用于多个连接。这样可能无法升级。</target>
        </trans-unit>
        <trans-unit id="ed4a9e62154b96609da080c17aec27f4dd9246b0" translate="yes" xml:space="preserve">
          <source>Note that if no &lt;code&gt;port&lt;/code&gt; is given and if &lt;code&gt;taddress&lt;/code&gt; does not contain a port number, the default value is used.</source>
          <target state="translated">请注意，如果未提供 &lt;code&gt;port&lt;/code&gt; ，并且 &lt;code&gt;taddress&lt;/code&gt; 不包含端口号，则使用默认值。</target>
        </trans-unit>
        <trans-unit id="c6b057ff98ba4785947d02f48c8fb42e16a4c39b" translate="yes" xml:space="preserve">
          <source>Note that if no &lt;code&gt;tdomain&lt;/code&gt; is given, the default value, &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt;, is used.</source>
          <target state="translated">请注意，如果未给出 &lt;code&gt;tdomain&lt;/code&gt; ，则使用默认值 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c484d69e82a05974946be309952b5bc3d7f4c76d" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;gen_statem&lt;/code&gt; is started through &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#enter_loop-4&quot;&gt;enter_loop/4-6&lt;/a&gt;&lt;/code&gt;, this callback will never be called. Since this callback is not optional it can in that case be implemented as:</source>
          <target state="translated">请注意，如果 &lt;code&gt;gen_statem&lt;/code&gt; 是通过 &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#enter_loop-4&quot;&gt;enter_loop/4-6&lt;/a&gt;&lt;/code&gt; 启动的，则永远不会调用此回调。由于此回调不是可选的，因此在这种情况下可以实现为：</target>
        </trans-unit>
        <trans-unit id="9c87f385bbe639188084f38ba17c84501fe670ca" translate="yes" xml:space="preserve">
          <source>Note that if the Version argument is &lt;code&gt;dynamic&lt;/code&gt;, the decoder should try to figure out the actual version from the message itself and then use the proper decoder, e.g. version 1.</source>
          <target state="translated">请注意，如果Version参数是 &lt;code&gt;dynamic&lt;/code&gt; ，则解码器应尝试从消息本身中找出实际版本，然后使用适当的解码器，例如version 1。</target>
        </trans-unit>
        <trans-unit id="12f48a08b82dbcdbabc6e426452d1ee74de3e1a7" translate="yes" xml:space="preserve">
          <source>Note that if the body is small all data may be delivered in only one chunk and then the callback will be called with {last, Data::binary(), undefined} without getting called with &lt;code&gt;{first, Data::binary()}&lt;/code&gt;.</source>
          <target state="translated">请注意，如果主体较小，则所有数据只能以一个块的形式传递，然后将使用{last，Data :: binary（），undefined}调用回调，而不会使用 &lt;code&gt;{first, Data::binary()}&lt;/code&gt; 调用回调。</target>
        </trans-unit>
        <trans-unit id="edf8bcd8d88dd948c2709c3f285acd4c03e67af3" translate="yes" xml:space="preserve">
          <source>Note that if the fun returns &lt;code&gt;unknown&lt;/code&gt; for an extension marked as critical, validation will fail.</source>
          <target state="translated">注意，如果对于标记为关键的扩展名，fun返回 &lt;code&gt;unknown&lt;/code&gt; ，则验证将失败。</target>
        </trans-unit>
        <trans-unit id="9d0a053447ab79088b7ef6197ebb840d173587a7" translate="yes" xml:space="preserve">
          <source>Note that if the option &lt;code&gt;warnings&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and the option &lt;code&gt;verbosity&lt;/code&gt; is &lt;code&gt;silence&lt;/code&gt;, warning messages will still be shown.</source>
          <target state="translated">请注意，如果选项 &lt;code&gt;warnings&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，而选项 &lt;code&gt;verbosity&lt;/code&gt; 为 &lt;code&gt;silence&lt;/code&gt; ，则仍将显示警告消息。</target>
        </trans-unit>
        <trans-unit id="5dec77651df10446f2452013b0e653832ee5a101" translate="yes" xml:space="preserve">
          <source>Note that if the reply is segmented (split into several smaller messages; segments), then some extra info, segment number and an indication if all segments of a reply has been received or not, is also included in the &lt;code&gt;UserReply&lt;/code&gt;.</source>
          <target state="translated">请注意，如果将答复分段（分成几个较小的消息；分段），则 &lt;code&gt;UserReply&lt;/code&gt; 中还将包含一些额外的信息，分段编号以及是否已接收到答复的所有分段的指示。</target>
        </trans-unit>
        <trans-unit id="3e84fec2f22c7d49771617b7f4326149f8363362" translate="yes" xml:space="preserve">
          <source>Note that in Erlang, a receive-expression must have at least one clause if no timeout part is specified.</source>
          <target state="translated">请注意,在Erlang中,如果没有指定超时部分,receive-expression必须至少有一个子句。</target>
        </trans-unit>
        <trans-unit id="8cef48befcd401dd112e3b47e9b84cfba29baac7" translate="yes" xml:space="preserve">
          <source>Note that in most implementations of TCP, doing a &lt;code&gt;close&lt;/code&gt; does not guarantee that any data sent is delivered to the recipient before the close is detected at the remote side. If you want to guarantee delivery of the data to the recipient there are two common ways to achieve this.</source>
          <target state="translated">请注意，在大多数TCP实现中，执行 &lt;code&gt;close&lt;/code&gt; 并不能保证在远程端检测到关闭之前，已发送的任何数据都已传递给接收方。如果要保证将数据传递给收件人，可以通过两种常用方法来实现。</target>
        </trans-unit>
        <trans-unit id="b9a4adbac3d627161edb16842c38f7517677ffd5" translate="yes" xml:space="preserve">
          <source>Note that in order for reltool to sort application versions and thereby be able to select the latest, it is required that the version id for the application consits of integers and dots only, for example &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2.0&lt;/code&gt; or &lt;code&gt;3.17.1&lt;/code&gt;.</source>
          <target state="translated">请注意，为了让reltool进行排序版本的应用程序，从而能够选择最新，要求该版本ID为唯一整数点的应用consits，例如 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;2.0&lt;/code&gt; 或 &lt;code&gt;3.17.1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e044f396b1f21f65746f1535663887993d7e14da" translate="yes" xml:space="preserve">
          <source>Note that integers in the list always represent code points regardless of &lt;code&gt;InEncoding&lt;/code&gt; passed. If &lt;code&gt;InEncoding latin1&lt;/code&gt; is passed, only code points &amp;lt; 256 are allowed; otherwise, all valid unicode code points are allowed.</source>
          <target state="translated">请注意，无论传递的 &lt;code&gt;InEncoding&lt;/code&gt; 如何，列表中的整数始终表示代码点。如果传递了 &lt;code&gt;InEncoding latin1&lt;/code&gt; ，则仅允许&amp;lt;256个代码点；否则，将允许所有有效的unicode代码点。</target>
        </trans-unit>
        <trans-unit id="da41371a24cf2bfa4ed67187ea540808d0a4589a" translate="yes" xml:space="preserve">
          <source>Note that it is easiest to write this kind of recursive generator using a help function, like the &lt;code&gt;lazy_gen/1&lt;/code&gt; function above. It can also be written using a recursive fun, if you prefer to not clutter your function namespace and are comfortable with writing that kind of code.</source>
          <target state="translated">请注意，最简单的方法是使用帮助函数（例如上面的 &lt;code&gt;lazy_gen/1&lt;/code&gt; 函数）编写这种递归生成器。如果您不想使您的函数名称空间混乱并且对编写这种代码感到满意，也可以使用递归的乐趣来编写它。</target>
        </trans-unit>
        <trans-unit id="b32d52e1a01dca7a3f60f88baf54204f13cb5c4b" translate="yes" xml:space="preserve">
          <source>Note that it is not possible nor needed to cancel this time-out, as it is cancelled automatically by any other event.</source>
          <target state="translated">注意,不可能也不需要取消这个超时,因为它会被任何其他事件自动取消。</target>
        </trans-unit>
        <trans-unit id="3d2bc208d4ef85523a8bb2be7f7fe6957054fa30" translate="yes" xml:space="preserve">
          <source>Note that it is possible for this function to filter out targets (but &lt;strong&gt;not&lt;/strong&gt; to add its own) by returning an updated &lt;code&gt;Targets&lt;/code&gt; list (&lt;code&gt;NewTargets&lt;/code&gt;).</source>
          <target state="translated">请注意，此函数可以通过返回更新的 &lt;code&gt;Targets&lt;/code&gt; 列表（ &lt;code&gt;NewTargets&lt;/code&gt; ）来过滤掉目标（但&lt;strong&gt;不能&lt;/strong&gt;添加自己的目标）。</target>
        </trans-unit>
        <trans-unit id="29e083fd2ab9cd6e5f1715c135b9ad0cd6133523" translate="yes" xml:space="preserve">
          <source>Note that it seldom needs to be started explicitly since it is automatically started by the functions that need a running server.</source>
          <target state="translated">请注意,它很少需要被显式启动,因为它是由需要运行服务器的函数自动启动的。</target>
        </trans-unit>
        <trans-unit id="bf76532ed69f19d320e28943c7ea7794c8213294" translate="yes" xml:space="preserve">
          <source>Note that its implementation dependant (and also dependent on mib-storage is used) if a backup is possible.</source>
          <target state="translated">需要注意的是,它的实现取决于(也取决于是否使用了mib-存储)是否可以进行备份。</target>
        </trans-unit>
        <trans-unit id="1ef50791d64ed0c0b90d9621e25834b3006be609" translate="yes" xml:space="preserve">
          <source>Note that no checking is done whether &lt;code&gt;Name&lt;/code&gt; is a reserved attribute name such as &lt;code&gt;module&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt;: it is assumed that the attribute is &quot;wild&quot;.</source>
          <target state="translated">请注意，不会检查 &lt;code&gt;Name&lt;/code&gt; 是否是保留的属性名称（例如 &lt;code&gt;module&lt;/code&gt; 或 &lt;code&gt;export&lt;/code&gt; )：假定属性为&amp;ldquo; wild&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="da792409efb1d957a763465a0f90eb01b22a65de" translate="yes" xml:space="preserve">
          <source>Note that no global trace patterns are affected by this function.</source>
          <target state="translated">请注意,此函数不会影响全局跟踪模式。</target>
        </trans-unit>
        <trans-unit id="1047c06dfd85c28e322de4ae968c83146c41303a" translate="yes" xml:space="preserve">
          <source>Note that processes that execute configuration functions or test cases are never included in &lt;code&gt;TestProcs&lt;/code&gt;. It is therefore safe to use post configuration hook functions (such as post_end_per_suite, post_end_per_group, post_end_per_testcase) to terminate all processes in &lt;code&gt;TestProcs&lt;/code&gt; that have the current group leader process as its group leader.</source>
          <target state="translated">请注意，执行配置功能或测试用例的过程永远不会包含在 &lt;code&gt;TestProcs&lt;/code&gt; 中。因此，可以安全地使用后配置挂钩函数（例如post_end_per_suite，post_end_per_group，post_end_per_testcase）终止 &lt;code&gt;TestProcs&lt;/code&gt; 中所有以当前组长进程作为其组长的进程。</target>
        </trans-unit>
        <trans-unit id="83100a56e14e247fd18ef628ef7f4b9f51213734" translate="yes" xml:space="preserve">
          <source>Note that raw filenames &lt;strong&gt;not&lt;/strong&gt; necessarily are encoded the same way as on the OS level.</source>
          <target state="translated">需要注意的是原始文件名&lt;strong&gt;没有&lt;/strong&gt;一定的编码方式为在操作系统级别相同。</target>
        </trans-unit>
        <trans-unit id="15df3770c93a08f3b7628f1b3671253fafbc1cf9" translate="yes" xml:space="preserve">
          <source>Note that special characters in the text (&amp;lt;, &amp;gt; and &amp;amp;) will be escaped by Common Test before the text is printed to the log file.</source>
          <target state="translated">请注意，在文本（&amp;lt;，&amp;gt;和＆）中的特殊字符将被打印到日志文件之前，Common Test将对其进行转义。</target>
        </trans-unit>
        <trans-unit id="7563ce9bbb8cb2de2be12e2c300f540e095441b0" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;RecordName&lt;/code&gt; and &lt;code&gt;Fields&lt;/code&gt; arguments my not be used in all implementations (they are actually only needed for mnesia-based implementations).</source>
          <target state="translated">请注意，并非在所有实现中都使用 &lt;code&gt;RecordName&lt;/code&gt; 和 &lt;code&gt;Fields&lt;/code&gt; 参数（实际上，仅基于mnesia的实现才需要它们）。</target>
        </trans-unit>
        <trans-unit id="79647059410cdcc68796c813c0ea00f1df08febf" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;erl_parse&lt;/code&gt; representation is identical for &quot;&lt;code&gt;FunctionType&lt;/code&gt;&quot; and &quot;&lt;code&gt;fun(FunctionType)&lt;/code&gt;&quot;.</source>
          <target state="translated">注意， &lt;code&gt;erl_parse&lt;/code&gt; 表示对于&amp;ldquo; &lt;code&gt;FunctionType&lt;/code&gt; &amp;rdquo;和&amp;ldquo; &lt;code&gt;fun(FunctionType)&lt;/code&gt; &amp;rdquo; 是相同的。</target>
        </trans-unit>
        <trans-unit id="77e8b76dc02c9cee773231d4002d964ee921a983" translate="yes" xml:space="preserve">
          <source>Note that the &lt;strong&gt;sect&lt;/strong&gt; curves are GF2m (characteristic two) curves and are only supported if the underlying OpenSSL has support for them. See also &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;crypto:supports/0&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">需要注意的是该&lt;strong&gt;教派&lt;/strong&gt;曲线GF2m（特征二）曲线，并且只支持如果底层OpenSSL无法对他们的支持。另见 &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;crypto:supports/0&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e846e6d7b0cd63a03e739f368b1e0f75bf3068da" translate="yes" xml:space="preserve">
          <source>Note that the AVP in question can be defined in an inherited dictionary in order to introduce additional values to an enumeration otherwise defined in another dictionary.</source>
          <target state="translated">请注意,有关的AVP可以在继承的字典中定义,以便为另一个字典中定义的枚举引入额外的值。</target>
        </trans-unit>
        <trans-unit id="545f0e872a991ae7619c44fcd6c8013504712aeb" translate="yes" xml:space="preserve">
          <source>Note that the CCF of this AVP is not the same as in RFC 3588.</source>
          <target state="translated">请注意,该AVP的CCF与RFC 3588中的CCF是不一样的。</target>
        </trans-unit>
        <trans-unit id="bc8a5b787d8524598e83ff6424d17b88b62138a1" translate="yes" xml:space="preserve">
          <source>Note that the actual supported dss_digest_type depends on the underlying crypto library. In OpenSSL version &amp;gt;= 1.0.1 the listed digest are supported, while in 1.0.0 only sha, sha224 and sha256 are supported. In version 0.9.8 only sha is supported.</source>
          <target state="translated">请注意，实际支持的dss_digest_type取决于基础加密库。在OpenSSL版本&amp;gt; = 1.0.1中，支持列出的摘要，而在1.0.0中仅支持sha，sha224和sha256。在0.9.8版中，仅支持sha。</target>
        </trans-unit>
        <trans-unit id="4ca45c6542e0b81fb0f24e8247dda5f01d933e7b" translate="yes" xml:space="preserve">
          <source>Note that the appended algorithm is removed from its original place and then appended to the same list.</source>
          <target state="translated">需要注意的是,追加的算法从原来的地方去掉,然后追加到同一个列表中。</target>
        </trans-unit>
        <trans-unit id="2f612c010562004f09536ba4c9211c91bf97b929" translate="yes" xml:space="preserve">
          <source>Note that the category argument is not required in order to only specify the importance of a printout. Example:</source>
          <target state="translated">请注意,如果只指定打印输出的重要性,则不需要类别参数。例如:</target>
        </trans-unit>
        <trans-unit id="4b7df81861af684495c97c5fff7559eaf0915d2f" translate="yes" xml:space="preserve">
          <source>Note that the client is free to use any order and to exclude methods.</source>
          <target state="translated">请注意,客户可以自由使用任何命令和排除方法。</target>
        </trans-unit>
        <trans-unit id="035d18f56820efe86cdac35e4891682c6e3af7b9" translate="yes" xml:space="preserve">
          <source>Note that the compiler may optimize away atoms. For example, the compiler will rewrite &lt;code&gt;atom_to_list(some_atom)&lt;/code&gt; to &lt;code&gt;&quot;some_atom&quot;&lt;/code&gt;. If that expression is the only mention of the atom &lt;code&gt;some_atom&lt;/code&gt; in the containing module, the atom will not be created when the module is loaded, and a subsequent call to &lt;code&gt;binary_to_existing_atom(&amp;lt;&amp;lt;&quot;some_atom&quot;&amp;gt;&amp;gt;, utf8)&lt;/code&gt; will fail.</source>
          <target state="translated">请注意，编译器可能会优化掉原子。例如，编译器会将 &lt;code&gt;atom_to_list(some_atom)&lt;/code&gt; 重写为 &lt;code&gt;&quot;some_atom&quot;&lt;/code&gt; 。如果该表达式是包含模块中唯一提及原子 &lt;code&gt;some_atom&lt;/code&gt; 的元素，则在加载模块时将不会创建该原子，并且随后对 &lt;code&gt;binary_to_existing_atom(&amp;lt;&amp;lt;&quot;some_atom&quot;&amp;gt;&amp;gt;, utf8)&lt;/code&gt; 调用将失败。</target>
        </trans-unit>
        <trans-unit id="f826da285ddceeccbdbefeb9bfa7b16ed554783f" translate="yes" xml:space="preserve">
          <source>Note that the compiler may optimize away atoms. For example, the compiler will rewrite &lt;code&gt;atom_to_list(some_atom)&lt;/code&gt; to &lt;code&gt;&quot;some_atom&quot;&lt;/code&gt;. If that expression is the only mention of the atom &lt;code&gt;some_atom&lt;/code&gt; in the containing module, the atom will not be created when the module is loaded, and a subsequent call to &lt;code&gt;list_to_existing_atom(&quot;some_atom&quot;)&lt;/code&gt; will fail.</source>
          <target state="translated">请注意，编译器可能会优化掉原子。例如，编译器会将 &lt;code&gt;atom_to_list(some_atom)&lt;/code&gt; 重写为 &lt;code&gt;&quot;some_atom&quot;&lt;/code&gt; 。如果该表达式是包含模块中唯一提及原子 &lt;code&gt;some_atom&lt;/code&gt; 的元素，则在加载模块时将不会创建该原子，并且随后对 &lt;code&gt;list_to_existing_atom(&quot;some_atom&quot;)&lt;/code&gt; 调用将失败。</target>
        </trans-unit>
        <trans-unit id="b82f239fea0a2dc9f48ac7fd1ebc1ab0b5051a56" translate="yes" xml:space="preserve">
          <source>Note that the data extracted from the imported (loaded) mibs are stored partly by the mib-server and partly by the symbolic-store server. See the default mib-server data module, &lt;code&gt;snmpa_mib_data_tttn&lt;/code&gt; for details.</source>
          <target state="translated">请注意，从导入（加载）的mib中提取的数据部分由mib服务器存储，部分由符号存储服务器存储。有关详细信息，请参见默认的mib服务器数据模块 &lt;code&gt;snmpa_mib_data_tttn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5bf74d56bb97406e9b99c3e9e52d5dbf134b453d" translate="yes" xml:space="preserve">
          <source>Note that the events &lt;code&gt;$s | $S&lt;/code&gt;, &lt;code&gt;l | $L&lt;/code&gt; and &lt;code&gt;$z | $Z&lt;/code&gt; has nothing to do with the timers using the same characters.</source>
          <target state="translated">请注意，事件 &lt;code&gt;$s | $S&lt;/code&gt; ， &lt;code&gt;l | $L&lt;/code&gt; 和 &lt;code&gt;$z | $Z&lt;/code&gt; 与使用相同字符的计时器无关。</target>
        </trans-unit>
        <trans-unit id="42629d78e6fdce7f2ed90c950f63dbfb4e3b847a" translate="yes" xml:space="preserve">
          <source>Note that the existing &lt;code&gt;.beam&lt;/code&gt; file must contain &lt;strong&gt;abstract code&lt;/strong&gt;, i.e. it must have been compiled with the &lt;code&gt;debug_info&lt;/code&gt; option. If not, the error reason &lt;code&gt;{no_abstract_code,BeamFile}&lt;/code&gt; is returned. If the abstract code is encrypted, and no key is available for decrypting it, the error reason &lt;code&gt;{encrypted_abstract_code,BeamFile}&lt;/code&gt; is returned.</source>
          <target state="translated">请注意，现有的 &lt;code&gt;.beam&lt;/code&gt; 文件必须包含&lt;strong&gt;抽象代码&lt;/strong&gt;，即它必须已使用 &lt;code&gt;debug_info&lt;/code&gt; 选项进行编译。如果不是，则返回错误原因 &lt;code&gt;{no_abstract_code,BeamFile}&lt;/code&gt; 。如果抽象代码已加密，并且没有可用的密钥对其进行解密 &lt;code&gt;{encrypted_abstract_code,BeamFile}&lt;/code&gt; 返回错误原因{encrypted_abstract_code，BeamFile}。</target>
        </trans-unit>
        <trans-unit id="9a18b13a51422254edcdb84073c354c33a88853b" translate="yes" xml:space="preserve">
          <source>Note that the following will always be loaded:</source>
          <target state="translated">请注意,以下内容将始终被加载。</target>
        </trans-unit>
        <trans-unit id="d1a2e58d441f9e2f474d803ab6a32dc6712ae978" translate="yes" xml:space="preserve">
          <source>Note that the function does not check if this entry already exists.</source>
          <target state="translated">请注意,该函数不会检查该条目是否已经存在。</target>
        </trans-unit>
        <trans-unit id="279bdf4d0a207f6c87ecb0b4e0489436649191bf" translate="yes" xml:space="preserve">
          <source>Note that the generated certificates and keys does not provide a formally correct PKIX-trust-chain and they can not be used to achieve real security. This function is provided for testing purposes only.</source>
          <target state="translated">请注意,生成的证书和密钥并不能提供一个正式正确的PKIX-信任链,它们不能用来实现真正的安全。此功能仅用于测试目的。</target>
        </trans-unit>
        <trans-unit id="02818bfeb97510589873cb15d812dd13537919d3" translate="yes" xml:space="preserve">
          <source>Note that the internal database is (re-)initiated during the compilation, meaning any previously collected coverage data for the module will be lost.</source>
          <target state="translated">请注意,在编译过程中,内部数据库是(重新)启动的,这意味着任何以前收集的模块的覆盖数据将丢失。</target>
        </trans-unit>
        <trans-unit id="cd70be69f8094d7d21e00a3313e50198d0e46168" translate="yes" xml:space="preserve">
          <source>Note that the network interface filter is something which is used by the network interface implementation provided by the application (&lt;code&gt;snmpa_net_if&lt;/code&gt;). The default filter accepts all messages.</source>
          <target state="translated">请注意，网络接口过滤器是应用程序（ &lt;code&gt;snmpa_net_if&lt;/code&gt; ）提供的网络接口实现所使用的东西。默认过滤器接受所有消息。</target>
        </trans-unit>
        <trans-unit id="ec89ab3b5094ea790ba1c908f83fb43e535fef72" translate="yes" xml:space="preserve">
          <source>Note that the network interface filter is something which is used by the network interface implementation provided by the application (&lt;code&gt;snmpm_net_if&lt;/code&gt; and &lt;code&gt;snmpm_net_if_mt&lt;/code&gt;). The default filter accepts all messages.</source>
          <target state="translated">请注意，网络接口过滤器是应用程序提供的网络接口实现（ &lt;code&gt;snmpm_net_if&lt;/code&gt; 和 &lt;code&gt;snmpm_net_if_mt&lt;/code&gt; ）使用的东西。默认过滤器接受所有消息。</target>
        </trans-unit>
        <trans-unit id="34cd017ef347f58960dd48f7604233f91388b9db" translate="yes" xml:space="preserve">
          <source>Note that the only way to actually start the agent in this way is to add the agent related config after starting the application (e.g it cannot be part of the normal application config; sys.config). This is done by calling: &lt;code&gt;application:set_env(snmp, agent, Conf)&lt;/code&gt;.</source>
          <target state="translated">请注意，以这种方式实际启动代理的唯一方法是在启动应用程序之后添加与代理相关的配置（例如，它不能成为常规应用程序配置的一部分sys.config）。可以通过调用以下命令完成： &lt;code&gt;application:set_env(snmp, agent, Conf)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81acf13e164a6ca93c0ecb3350e2a756f1a26bc4" translate="yes" xml:space="preserve">
          <source>Note that the only way to actually start the manager in this way is to add the manager related config after starting the application (e.g it cannot be part of the normal application config; sys.config). This is done by calling: &lt;code&gt;application:set_env(snmp, manager, Conf)&lt;/code&gt;.</source>
          <target state="translated">请注意，以这种方式实际启动管理器的唯一方法是在启动应用程序后添加与管理器相关的配置（例如，它不能是常规应用程序配置sys.config的一部分）。可以通过调用以下命令完成： &lt;code&gt;application:set_env(snmp, manager, Conf)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29a75f4183db30bfbd690aebb40a7591e31cfea3" translate="yes" xml:space="preserve">
          <source>Note that the ordering of the tuples in the lists didn't matter.</source>
          <target state="translated">注意,列表中元组的顺序并不重要。</target>
        </trans-unit>
        <trans-unit id="f94de51b2bccdc5fd6127e2ecc608b422d804fb9" translate="yes" xml:space="preserve">
          <source>Note that the process that calls this function &lt;strong&gt;must&lt;/strong&gt; be permanent. If it dies, the port(s) will exit and the driver unload.</source>
          <target state="translated">请注意，调用此函数的过程&lt;strong&gt;必须&lt;/strong&gt;是永久的。如果它死了，端口将退出并且驱动程序卸载。</target>
        </trans-unit>
        <trans-unit id="112c3dfc73e40a04304d2c8d43acbdb9eb33ab97" translate="yes" xml:space="preserve">
          <source>Note that the request specific parameters (such as &lt;code&gt;&lt;a href=&quot;#current_request_id&quot;&gt;current_request_id&lt;/a&gt;&lt;/code&gt;) are not accessible for the instrumentation functions if this function is used.</source>
          <target state="translated">请注意，如果使用此功能，则检测功能无法访问特定于请求的参数（例如 &lt;code&gt;&lt;a href=&quot;#current_request_id&quot;&gt;current_request_id&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="290365691c0a5e60df1a89c122ce6576ebc4f890" translate="yes" xml:space="preserve">
          <source>Note that the request specific parameters (such as &lt;code&gt;snmpa:current_request_id/0&lt;/code&gt; are not accessible for the instrumentation functions if this function is used.</source>
          <target state="translated">请注意，如果使用此功能，则检测功能无法访问特定于请求的参数（例如 &lt;code&gt;snmpa:current_request_id/0&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="becd11dbe64d3cd785c4bb1c3c28a2d4f227a406" translate="yes" xml:space="preserve">
          <source>Note that the segments are delivered to the user differently depending on which function is used to issue the original request. When issuing the request using the &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;megaco:cast&lt;/a&gt;&lt;/code&gt; function, the segments are delivered to the user via the &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; callback function one at a time, as they arrive. But this obviously doe not work for the &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt; function. In this case, the segments are accumulated and then delivered all at once as the function returns.</source>
          <target state="translated">请注意，取决于使用哪个功能来发出原始请求，这些段以不同的方式交付给用户。当使用 &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;megaco:cast&lt;/a&gt;&lt;/code&gt; 函数发出请求时，这些段在到达时通过 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; 回调函数一次传递给用户。但这显然不适用于 &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt; 函数。在这种情况下，段会被累积，然后在函数返回时立即全部交付。</target>
        </trans-unit>
        <trans-unit id="e78277755ce3bad3e06f00c82c4d07b3b9286ed6" translate="yes" xml:space="preserve">
          <source>Note that the ssl application is required for TLS and must be started before configuring TLS capability on diameter transports.</source>
          <target state="translated">需要注意的是,TSL需要ssl应用,并且必须在直径传输上配置TLS功能之前启动。</target>
        </trans-unit>
        <trans-unit id="2dee8e68f59d0a0eec57cc8147e1a5be661efd08" translate="yes" xml:space="preserve">
          <source>Note that the unmentioned lists (&lt;code&gt;public_key&lt;/code&gt;, &lt;code&gt;cipher&lt;/code&gt;, &lt;code&gt;mac&lt;/code&gt; and &lt;code&gt;compression&lt;/code&gt;) are un-changed.</source>
          <target state="translated">请注意，未提及的列表（ &lt;code&gt;public_key&lt;/code&gt; ， &lt;code&gt;cipher&lt;/code&gt; ， &lt;code&gt;mac&lt;/code&gt; 和 &lt;code&gt;compression&lt;/code&gt; ）未更改。</target>
        </trans-unit>
        <trans-unit id="d8989301ef700984d41bf0a2801b22ca08a2ce1f" translate="yes" xml:space="preserve">
          <source>Note that the use of the LocalEngineID argument is only intended for special cases, if the agent is to &quot;emulate&quot; multiple EngineIDs! By default, the agent uses the value of &lt;code&gt;SnmpEngineID&lt;/code&gt; (see SNMP-FRAMEWORK-MIB).</source>
          <target state="translated">请注意，如果代理要&amp;ldquo;模拟&amp;rdquo;多个EngineID，则仅在特殊情况下才使用LocalEngineID参数！默认情况下，代理使用 &lt;code&gt;SnmpEngineID&lt;/code&gt; 的值（请参阅SNMP-FRAMEWORK-MIB）。</target>
        </trans-unit>
        <trans-unit id="b41a1b6fd82bf7a6c9a348c40309d8522ab51f73" translate="yes" xml:space="preserve">
          <source>Note that there may be multiple entries with the same &lt;code&gt;ref&lt;/code&gt;, in contrast to &lt;code&gt;transport&lt;/code&gt; info.</source>
          <target state="translated">请注意，与 &lt;code&gt;transport&lt;/code&gt; 信息相反，可能有多个具有相同 &lt;code&gt;ref&lt;/code&gt; 的条目。</target>
        </trans-unit>
        <trans-unit id="8f8021919fad99cd5846d281ed37e3c831b466fa" translate="yes" xml:space="preserve">
          <source>Note that there need to be exactly one distribution controller per connection. A process or port can only be distribution controller for one connection. The registration as distribution controller cannot be undone. It will stick until the distribution controller terminates. The distribution controller should not ignore exit signals. It is allowed to trap exits, but it should then voluntarily terminate when an exit signal is received.</source>
          <target state="translated">请注意,每个连接必须有一个分配控制器。一个进程或端口只能成为一个连接的分配控制器。不能撤销作为分配控制器的注册。它将保持不变,直到分配控制器终止。分布控制器不应忽略退出信号。允许它捕捉退出信号,但当收到退出信号时,它应该主动终止。</target>
        </trans-unit>
        <trans-unit id="35ca0442324d4811fd6417d30d9643d51d667192" translate="yes" xml:space="preserve">
          <source>Note that these functions is intended to be called by the instrumentation functions and &lt;strong&gt;only&lt;/strong&gt; if they are executed in the context of the agent process (e.g. it does not work if called from a spawned process).</source>
          <target state="translated">请注意，&lt;strong&gt;仅&lt;/strong&gt;当在代理进程的上下文中执行这些功能时，才会由检测功能调用这些功能（例如，如果从生成的进程中调用，则这些功能将不起作用）。</target>
        </trans-unit>
        <trans-unit id="2c6d3e9f0a111d997b09cc65e98dfb115cd9cb64" translate="yes" xml:space="preserve">
          <source>Note that this check use application versions that are loaded, or will be loaded when used. You might have application versions that satisfies all dependencies installed in the system, but if those are not loaded this check will fail. The system will of course also fail when used like this. This may happen when you have multiple &lt;code&gt;branched versions&lt;/code&gt; of the same application installed in the system, but you do not use a &lt;code&gt;boot script&lt;/code&gt; identifing the correct application version.</source>
          <target state="translated">请注意，此检查使用已加载或将在使用时加载的应用程序版本。您的应用程序版本可能满足系统中安装的所有依赖关系，但是如果未加载所有依赖关系，此检查将失败。当这样使用时，系统当然也会失败。当您在系统中安装了同一应用程序的多个 &lt;code&gt;branched versions&lt;/code&gt; ，但是没有使用 &lt;code&gt;boot script&lt;/code&gt; 标识正确的应用程序版本时，可能会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="99d2fbc3cc50eaf8d82652d3e7dfaf6a59e6d53e" translate="yes" xml:space="preserve">
          <source>Note that this does not effect the messages that are sent autonomously by the stack. They use the protocol_version of the connection info.</source>
          <target state="translated">请注意,这不会影响堆栈自主发送的消息。它们使用的是连接信息的protocol_version。</target>
        </trans-unit>
        <trans-unit id="caecb85cc20edb5c5424262ff84251833ebf6fc6" translate="yes" xml:space="preserve">
          <source>Note that this function is executed in the context of the master-agent process.</source>
          <target state="translated">请注意,这个函数是在主代理进程的上下文中执行的。</target>
        </trans-unit>
        <trans-unit id="8fa22c35292c8c077560ab97a691881383aaa404" translate="yes" xml:space="preserve">
          <source>Note that this function will only be called if the user has set the &lt;code&gt;&lt;a href=&quot;megaco#ui_resend_indication&quot;&gt;resend_indication&lt;/a&gt;&lt;/code&gt; config option to &lt;code&gt;true&lt;/code&gt;&lt;strong&gt;and&lt;/strong&gt; it is in fact a message resend. If not &lt;strong&gt;both&lt;/strong&gt; of these condition's are meet, &lt;code&gt;send_message&lt;/code&gt; will be called.</source>
          <target state="translated">请注意，仅当用户将 &lt;code&gt;&lt;a href=&quot;megaco#ui_resend_indication&quot;&gt;resend_indication&lt;/a&gt;&lt;/code&gt; config选项设置为 &lt;code&gt;true&lt;/code&gt; &lt;strong&gt;且&lt;/strong&gt;实际上是消息重新发送时，才会调用此函数。如果&lt;strong&gt;这两个&lt;/strong&gt;条件都不&lt;strong&gt;同时&lt;/strong&gt;满足，将调用 &lt;code&gt;send_message&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="732f01521ba5984e435cb22a9ac9e6a45f29f1a3" translate="yes" xml:space="preserve">
          <source>Note that this has no effect on the actual sending of pending transactions. This is either implicit (e.g. when receiving a re-sent transaction request for a request which is being processed) or controlled by the pending_timer, see above.</source>
          <target state="translated">请注意,这对待处理事务的实际发送没有影响。这要么是隐含的(例如当收到一个正在处理的请求的重新发送的事务请求时),要么由pending_timer控制,见上文。</target>
        </trans-unit>
        <trans-unit id="5991c7ab4d7c54b2c691ce4af01a35ebe0bdc5ec" translate="yes" xml:space="preserve">
          <source>Note that this has no effect on the application configuration as defined by configuration files, so a node restart will revert the config to whatever is in those files.</source>
          <target state="translated">请注意,这对配置文件所定义的应用程序配置没有影响,所以节点重启会将配置恢复到这些文件中的任何内容。</target>
        </trans-unit>
        <trans-unit id="50e67d142a316144e7ab07bc77f835927707bee6" translate="yes" xml:space="preserve">
          <source>Note that this identifier occasionally has been called &quot;name&quot;. As far as possible, the terms &quot;identifier&quot; or &quot;id&quot; are now used but in order to keep backwards compatibility, some occurences of &quot;name&quot; can still be found, for example in error messages.</source>
          <target state="translated">请注意,这个标识符有时也被称为 &quot;名称&quot;。现在尽可能地使用 &quot;标识符 &quot;或 &quot;id&quot;,但为了保持向后的兼容性,仍然可以找到 &quot;name &quot;的出现,例如在错误信息中。</target>
        </trans-unit>
        <trans-unit id="4ccf4b0fd3e0f0b163b5d9f781f3e69fb98fcf9b" translate="yes" xml:space="preserve">
          <source>Note that this is also the maximum amount of data that can be received from a single recv call. If you are using higher than normal MTU consider setting buffer higher.</source>
          <target state="translated">请注意,这也是一次recv调用可以接收的最大数据量。如果你使用的MTU比正常的高,可以考虑将缓冲区设置得更高。</target>
        </trans-unit>
        <trans-unit id="8d6bbf6c0b04bfae62fc7c2e9271769120f7387b" translate="yes" xml:space="preserve">
          <source>Note that this is just a utility function, which does all the work of splitting the given string into words separated by whitespace and setting up a &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par&lt;/a&gt;&lt;/code&gt; with the proper indentation, containing a list of &lt;code&gt;&lt;a href=&quot;#text-1&quot;&gt;text&lt;/a&gt;&lt;/code&gt; elements.</source>
          <target state="translated">请注意，这只是一个实用程序函数，它完成将给定字符串拆分为由空格分隔的单词并设置带有适当缩进的 &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par&lt;/a&gt;&lt;/code&gt; （包含 &lt;code&gt;&lt;a href=&quot;#text-1&quot;&gt;text&lt;/a&gt;&lt;/code&gt; 元素列表）的所有工作。</target>
        </trans-unit>
        <trans-unit id="392cc3c5602edaac365f69343bd3fabeabbfabb8" translate="yes" xml:space="preserve">
          <source>Note that this might be an incomplete list of files that need to be updated.</source>
          <target state="translated">请注意,这可能是一个不完整的需要更新的文件列表。</target>
        </trans-unit>
        <trans-unit id="7ccf435027f13cc4c4ea5f6a451c968311242f89" translate="yes" xml:space="preserve">
          <source>Note that this only works as specified if the &lt;code&gt;sent_pending_limit&lt;/code&gt; config option has been set to an integer value.</source>
          <target state="translated">请注意，只有在 &lt;code&gt;sent_pending_limit&lt;/code&gt; 配置选项已设置为整数值的情况下，此选项才能按指定方式工作。</target>
        </trans-unit>
        <trans-unit id="14cde1c7fe3b7ab665fc387b99054848ce3fead5" translate="yes" xml:space="preserve">
          <source>Note that this whole module is experimental, and the representations used as well as the functionality is likely to change in the future.</source>
          <target state="translated">请注意,这整个模块是实验性的,所使用的表示方法以及功能在未来可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="6d0f64dc22706965239d477a1963f767ce3f8f64" translate="yes" xml:space="preserve">
          <source>Note that this will always be the default user that is called.</source>
          <target state="translated">请注意,这将永远是被调用的默认用户。</target>
        </trans-unit>
        <trans-unit id="8ec3dbe2e4a9ded21164737c3e53b41c247a0435" translate="yes" xml:space="preserve">
          <source>Note that transaction id's are (currently) maintained on a per user basis so there is no way to be sure that the value returned will actually be used for a transaction sent on this connection (in case a user has several connections, which is not at all unlikely).</source>
          <target state="translated">请注意,事务ID是(目前)以每个用户为基础进行维护的,所以无法确定返回的值是否真的会被用于在这个连接上发送的事务(如果一个用户有多个连接,这并不是不可能的)。</target>
        </trans-unit>
        <trans-unit id="8d60aba8258543e37473d13c94a9f81daa1cab90" translate="yes" xml:space="preserve">
          <source>Note that using this action from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; would be weird on the border of witchcraft since there has been no earlier call to a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; in this server.</source>
          <target state="translated">请注意，使用 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; 中的此操作在巫术的边界上会很奇怪，因为在此服务器中没有更早地调用 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f61aaf53fdf26271e4990884786f10164139b23" translate="yes" xml:space="preserve">
          <source>Note that when compiling a module &lt;strong&gt;all existing coverage data is removed&lt;/strong&gt;, including imported data. If a module is already compiled when data is imported, the imported data is &lt;strong&gt;added&lt;/strong&gt; to the existing coverage data.</source>
          <target state="translated">请注意，在编译模块时，将&lt;strong&gt;删除所有现有的coverage数据&lt;/strong&gt;，包括导入的数据。如果在导入数据时已经编译了模块，则导入的数据将&lt;strong&gt;添加&lt;/strong&gt;到现有coverage数据中。</target>
        </trans-unit>
        <trans-unit id="df20ba18430e7a9839bde3720f0b99fc09d3133d" translate="yes" xml:space="preserve">
          <source>Note that when the value of the data to input is a string, it has to be quoted with &lt;code&gt;'&lt;/code&gt;. Example:</source>
          <target state="translated">请注意，当要输入的数据值是字符串时，必须用 &lt;code&gt;'&lt;/code&gt; 引起来。例：</target>
        </trans-unit>
        <trans-unit id="686eb963081bb17804ec4126760703b99e0e06a4" translate="yes" xml:space="preserve">
          <source>Note that whenever a document in &lt;code&gt;Docs&lt;/code&gt; contains a line break, it will be placed on a separate line. Thus, neither a layout such as</source>
          <target state="translated">请注意，只要&amp;ldquo;文档&amp;rdquo;中的 &lt;code&gt;Docs&lt;/code&gt; 包含换行符，它将被放置在单独的行上。因此，无论是</target>
        </trans-unit>
        <trans-unit id="51ce8067681e0ca58dded25b6ecd3a75afe5a9e0" translate="yes" xml:space="preserve">
          <source>Note that work executing on dirty I/O schedulers are expected to mainly wait for I/O. That is, when you get high scheduler utilization on dirty I/O schedulers, CPU utilization is &lt;strong&gt;not&lt;/strong&gt; expected to be high due to this work.</source>
          <target state="translated">请注意，在脏的I / O调度程序上执行的工作应主要等待I / O。也就是说，当您在脏的I / O调度程序上获得较高的调度程序利用率时，由于这项工作，预计CPU利用率&lt;strong&gt;不会&lt;/strong&gt;很高。</target>
        </trans-unit>
        <trans-unit id="523d72a03618b74e2aff0e449d66e6cc2c0c698a" translate="yes" xml:space="preserve">
          <source>Note that you cannot define arbitrary variables in a cross compilation configuration file. Only the ones listed below will be guaranteed to be visible throughout the whole execution of all &lt;code&gt;configure&lt;/code&gt; scripts. Other variables needs to be defined as arguments to &lt;code&gt;configure&lt;/code&gt; or exported in the environment.</source>
          <target state="translated">请注意，您不能在交叉编译配置文件中定义任意变量。在所有 &lt;code&gt;configure&lt;/code&gt; 脚本的整个执行过程中，仅保证以下列出的内容可见。需要将其他变量定义为在环境中 &lt;code&gt;configure&lt;/code&gt; 或导出的参数。</target>
        </trans-unit>
        <trans-unit id="7bfec520257edb9cec974688079c41974b401d13" translate="yes" xml:space="preserve">
          <source>Note that you need to have run &lt;code&gt;(cd $ERL_TOP &amp;amp;&amp;amp; eval `./otp_build env_win32`)&lt;/code&gt; in the particular shell before building anything on Windows. After doing a make opt you can test your result by running &lt;code&gt;$ERL_TOP/bin/erl&lt;/code&gt;. If you want to copy the result to a release directory (say &lt;code&gt;/tmp/erl_release&lt;/code&gt;), you do this (still in &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt;)</source>
          <target state="translated">请注意，在Windows上构建任何东西之前，需要在特定的shell中运行 &lt;code&gt;(cd $ERL_TOP &amp;amp;&amp;amp; eval `./otp_build env_win32`)&lt;/code&gt; 。完成make opt后，您可以通过运行 &lt;code&gt;$ERL_TOP/bin/erl&lt;/code&gt; 来测试结果。如果要将结果复制到发布目录（例如 &lt;code&gt;/tmp/erl_release&lt;/code&gt; ），请执行此操作（仍在 &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="4a5f7a43dea5055412cd813699aecbdd4537ff72" translate="yes" xml:space="preserve">
          <source>Note that you're expected to have a fresh Erlang in your path when doing this, preferably the plain 21 you have built in the previous steps. You could also add &lt;code&gt;$ERL_TOP/bootstrap/bin&lt;/code&gt; to your &lt;code&gt;PATH&lt;/code&gt; before rebuilding specific libraries. That would give you a good enough Erlang system to compile any OTP erlang code. Setting up the path correctly is a little bit tricky. You still need to have &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools/vc&lt;/code&gt; and &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools&lt;/code&gt;&lt;strong&gt;before&lt;/strong&gt; the actual emulator in the path. A typical setting of the path for using the bootstrap compiler would be:</source>
          <target state="translated">请注意，在执行此操作时，您应该在路径中有一个新鲜的Erlang，最好是在先前步骤中构建的普通21。您还可以在重建特定库之前将 &lt;code&gt;$ERL_TOP/bootstrap/bin&lt;/code&gt; 添加到 &lt;code&gt;PATH&lt;/code&gt; 中。那将为您提供足够好的Erlang系统来编译任何OTP erlang代码。正确设置路径有些棘手。在路径中的实际仿真器&lt;strong&gt;之前&lt;/strong&gt;，您仍然需要具有 &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools/vc&lt;/code&gt; 和 &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools&lt;/code&gt; 。使用引导程序编译器的路径的典型设置为：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0f59844103d6ba8ed4dae0a9ab2a29d364c2a6a4" translate="yes" xml:space="preserve">
          <source>Note that, as a way to indicate the newest file, &lt;code&gt;run_erl&lt;/code&gt; will delete the oldest log file to maintain a &quot;hole&quot; in the file sequences. For example, if log files #1, #2, #4 and #5 exists, that means #2 is the latest and #4 is the oldest. You will therefore at most get one less log file than the value set by &lt;code&gt;RUN_ERL_LOG_GENERATIONS&lt;/code&gt;.</source>
          <target state="translated">请注意，作为指示最新文件的一种方式， &lt;code&gt;run_erl&lt;/code&gt; 将删除最旧的日志文件以在文件序列中保留&amp;ldquo;空洞&amp;rdquo;。例如，如果日志文件＃1，＃2，＃4和＃5存在，则意味着＃2是最新的，而＃4是最早的。因此，您获得的日志文件最多比 &lt;code&gt;RUN_ERL_LOG_GENERATIONS&lt;/code&gt; 设置的值少一个。</target>
        </trans-unit>
        <trans-unit id="d6c73dcf363499057947cccf47d8448b7dbaf012" translate="yes" xml:space="preserve">
          <source>Note the fact that you can use &lt;code&gt;throw&lt;/code&gt; to return the result, which can be useful. For example to bail out with &lt;code&gt;throw(keep_state_and_data)&lt;/code&gt; from deep within complex code that can not return &lt;code&gt;{next_state,State,Data}&lt;/code&gt; because &lt;code&gt;State&lt;/code&gt; or &lt;code&gt;Data&lt;/code&gt; is no longer in scope.</source>
          <target state="translated">请注意，您可以使用 &lt;code&gt;throw&lt;/code&gt; 返回结果，这很有用。例如，在无法返回 &lt;code&gt;{next_state,State,Data}&lt;/code&gt; 的复杂代码中深入使用 &lt;code&gt;throw(keep_state_and_data)&lt;/code&gt; 进行纾困，因为 &lt;code&gt;State&lt;/code&gt; 或 &lt;code&gt;Data&lt;/code&gt; 不在范围内。</target>
        </trans-unit>
        <trans-unit id="4317e03fcba152213e0ea0f2f44b86239f1e5599" translate="yes" xml:space="preserve">
          <source>Note this option is not needed in normal TLS usage and should not be used to implement new clients. But legacy clients that retries connections in the following manner</source>
          <target state="translated">注意这个选项在正常的TLS使用中是不需要的,也不应该用来实现新的客户端。但是,传统的客户端会以以下方式重试连接。</target>
        </trans-unit>
        <trans-unit id="308285ef58a3193174b243e20988fef230082fab" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;arity_qualifier&lt;/code&gt; nodes are recognized. This is to follow The Erlang Parser when it comes to wild attributes: both {F, A} and F/A are recognized, which makes it possible to turn wild attributes into recognized attributes without at the same time making it impossible to compile files using the new syntax with the old version of the Erlang Compiler.</source>
          <target state="translated">注意：识别 &lt;code&gt;arity_qualifier&lt;/code&gt; 节点。这是遵循Erlang Parser的狂野属性：{F，A}和F / A都可以识别的，这使得可以将狂野属性转换为公认的属性，而同时又无法使用旧版本的Erlang编译器提供了新语法。</target>
        </trans-unit>
        <trans-unit id="a0562ade2cea8acce9b76b0b4ab90737668e5d26" translate="yes" xml:space="preserve">
          <source>Note: Currently, the set of syntax trees which have a concrete representation is larger than the set of trees which can be built using the function &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt;. An abstract character will be concretised as an integer, while &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; does not at present yield an abstract character for any input. (Use the &lt;code&gt;&lt;a href=&quot;#char-1&quot;&gt;char/1&lt;/a&gt;&lt;/code&gt; function to explicitly create an abstract character.)</source>
          <target state="translated">注意：当前，具有具体表示形式的语法树的集合大于可以使用函数 &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; 构建的树的集合。抽象字符将具体化为整数，而 &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; 目前不会为任何输入产生抽象字符。（使用 &lt;code&gt;&lt;a href=&quot;#char-1&quot;&gt;char/1&lt;/a&gt;&lt;/code&gt; 函数显式创建一个抽象字符。）</target>
        </trans-unit>
        <trans-unit id="165ae8a32f7b6f64943274e92b98458ca7d19edd" translate="yes" xml:space="preserve">
          <source>Note: If some document in &lt;code&gt;Docs&lt;/code&gt; contains a line break, the vertical layout will always be selected.</source>
          <target state="translated">注意：如果文档中的某些 &lt;code&gt;Docs&lt;/code&gt; 包含换行符，则将始终选择垂直布局。</target>
        </trans-unit>
        <trans-unit id="3840eb20d7586de2203199630f1c366ff144d8c6" translate="yes" xml:space="preserve">
          <source>Note: If you get a &quot;syntax error&quot; message when trying to merge files (and you know those files to be correct), then try the &lt;code&gt;preprocess&lt;/code&gt; option. It typically means that your code contains too strange macros to be handled without actually performing the preprocessor expansions.</source>
          <target state="translated">注意：如果在尝试合并文件时收到&amp;ldquo;语法错误&amp;rdquo;消息（并且您知道这些文件是正确的），请尝试&amp;ldquo; &lt;code&gt;preprocess&lt;/code&gt; 选项。通常，这意味着您的代码包含太多奇怪的宏，无法在不实际执行预处理器扩展的情况下进行处理。</target>
        </trans-unit>
        <trans-unit id="884eb65502e4a057112e64304a3aee60ecdc8306" translate="yes" xml:space="preserve">
          <source>Note: Since &lt;code&gt;Node&lt;/code&gt; is a syntax tree, the actual run-time values corresponding to its subtrees may often be partially or completely unknown. Thus, if &lt;code&gt;Node&lt;/code&gt; represents e.g. &quot;&lt;code&gt;[... | Ns]&lt;/code&gt;&quot; (where &lt;code&gt;Ns&lt;/code&gt; is a variable), then the function will return &lt;code&gt;false&lt;/code&gt;, because it is not known whether &lt;code&gt;Ns&lt;/code&gt; will be bound to a list at run-time. If &lt;code&gt;Node&lt;/code&gt; instead represents e.g. &quot;&lt;code&gt;[1, 2, 3]&lt;/code&gt;&quot; or &quot;&lt;code&gt;[A | []]&lt;/code&gt;&quot;, then the function will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">注意：由于 &lt;code&gt;Node&lt;/code&gt; 是语法树，因此与其子树相对应的实际运行时值通常可能是部分或完全未知的。因此，如果 &lt;code&gt;Node&lt;/code&gt; 表示例如&amp;ldquo; &lt;code&gt;[... | Ns]&lt;/code&gt; &amp;rdquo;（其中 &lt;code&gt;Ns&lt;/code&gt; 是变量），则该函数将返回 &lt;code&gt;false&lt;/code&gt; ，因为尚不清楚 &lt;code&gt;Ns&lt;/code&gt; 是否在运行时绑定到列表。如果 &lt;code&gt;Node&lt;/code&gt; 相反表示&amp;ldquo; &lt;code&gt;[1, 2, 3]&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;[A | []]&lt;/code&gt; &amp;rdquo;，则该函数将返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef01dc14c91674b058f1673b8d98cbd24605f910" translate="yes" xml:space="preserve">
          <source>Note: The Erlang language has distinct 1-tuples, i.e., &lt;code&gt;{X}&lt;/code&gt; is always distinct from &lt;code&gt;X&lt;/code&gt; itself.</source>
          <target state="translated">注意：Erlang语言具有不同的1元组，即 &lt;code&gt;{X}&lt;/code&gt; 始终与 &lt;code&gt;X&lt;/code&gt; 本身不同。</target>
        </trans-unit>
        <trans-unit id="cbd9bd8a8c68fbfcb71e2f8c20f0bf3e55f2ea3f" translate="yes" xml:space="preserve">
          <source>Note: The distinction between &quot;static&quot; and &quot;safe&quot; modules is necessary in order not to break the semantics of dynamic code replacement. A &quot;static&quot; source module will not be replaced unless the target module also is. Now imagine a state machine implemented by placing the code for each state in a separate module, and suppose that we want to merge this into a single target module, marking all source modules as static. At each point in the original code where a call is made from one of the modules to another (i.e., the state transitions), code replacement is expected to be detected. Then, if we in the merged code do not check at these points if the &lt;strong&gt;target&lt;/strong&gt; module (the result of the merge) has been replaced, we can not be sure in general that we will be able to do code replacement of the merged state machine - it could run forever without detecting the code change. Therefore, all such calls must remain remote-calls (detecting code changes), but may call the target module directly.</source>
          <target state="translated">注意：为了避免破坏动态代码替换的语义，必须区分&amp;ldquo;静态&amp;rdquo;模块和&amp;ldquo;安全&amp;rdquo;模块。除非目标模块也将被替换，否则&amp;ldquo;静态&amp;rdquo;源模块将不会被替换。现在想象一下一个状态机，该状态机是通过将每个状态的代码放在单独的模块中来实现的，并假设我们要将其合并到单个目标模块中，并将所有源模块标记为静态。在原始代码中从模块之一调用到另一个模块的每个点（即状态转换），都期望检测到代码替换。然后，如果我们在合并的代码中不检查这些点上的&lt;strong&gt;目标&lt;/strong&gt;模块（合并的结果）已被替换，我们通常无法确定我们将能够对合并的状态机进行代码替换-它可以永久运行而不会检测到代码更改。因此，所有此类调用都必须保留为远程调用（检测代码更改），但可以直接调用目标模块。</target>
        </trans-unit>
        <trans-unit id="2872d7972612ca53705b122b06de88412b65023e" translate="yes" xml:space="preserve">
          <source>Note: The preprocessor macro definition directive &quot;&lt;code&gt;-define(Name, Body).&lt;/code&gt;&quot; has relatively few requirements on the syntactical form of &lt;code&gt;Body&lt;/code&gt; (viewed as a sequence of tokens). The &lt;code&gt;text&lt;/code&gt; node type can be used for a &lt;code&gt;Body&lt;/code&gt; that is not a normal Erlang construct.</source>
          <target state="translated">注意：预处理程序宏定义指令&amp;ldquo; &lt;code&gt;-define(Name, Body).&lt;/code&gt; &amp;rdquo;对 &lt;code&gt;Body&lt;/code&gt; 的语法形式的要求相对较少（视为标记序列）。该 &lt;code&gt;text&lt;/code&gt; 节点类型可以被用于 &lt;code&gt;Body&lt;/code&gt; 这不是一个正常的Erlang构建体。</target>
        </trans-unit>
        <trans-unit id="6a3d6a31994b23aff112f18cb8ed90847216cb94" translate="yes" xml:space="preserve">
          <source>Note: The primary constructor functions for a node type should always have the same name as the node type itself.</source>
          <target state="translated">注意:节点类型的主构造函数应该总是与节点类型本身具有相同的名称。</target>
        </trans-unit>
        <trans-unit id="a75af5c6559b7697b82cd55b9c2024ae62ccc77d" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(get_precomments(Node) == []) and (get_postcomments(Node) == [])&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注意：这等效于 &lt;code&gt;(get_precomments(Node) == []) and (get_postcomments(Node) == [])&lt;/code&gt; ，但可能更有效。</target>
        </trans-unit>
        <trans-unit id="bb58e56411d72b2c5de64c07dff668396f493062" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;add_postcomments(get_postcomments(Source), add_precomments(get_precomments(Source), Target))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注意：这等效于 &lt;code&gt;add_postcomments(get_postcomments(Source), add_precomments(get_precomments(Source), Target))&lt;/code&gt; ，但可能会更有效。</target>
        </trans-unit>
        <trans-unit id="f8cc9a8168087cf73aa91a1ca9a6fb283bef773c" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;set_postcomments(Node, get_postcomments(Node) ++ Comments)&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注意：这等效于 &lt;code&gt;set_postcomments(Node, get_postcomments(Node) ++ Comments)&lt;/code&gt; ，但可能更有效。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
